head	1.53;
access;
symbols
	OPENBSD_6_2:1.53.0.2
	OPENBSD_6_2_BASE:1.53
	OPENBSD_6_1:1.52.0.6
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.52.0.2
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.48.0.16
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.48.0.14
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.48.0.10
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.48.0.8
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.6
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.4
	OPENBSD_5_0:1.48.0.2
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.46.0.4
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.46.0.2
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.31.0.6
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.30.0.4
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.28.0.4
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.6
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.16
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.8
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.6
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.4
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.8
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.6
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.53
date	2017.09.08.05.36.53;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	uRv5pa9QDlZaYgwD;

1.52
date	2016.03.12.15.16.04;	author krw;	state Exp;
branches;
next	1.51;
commitid	zkFngOKA3woPgVlY;

1.51
date	2015.06.07.19.13.27;	author krw;	state Exp;
branches;
next	1.50;
commitid	MxUWuiPFtM1nRYxm;

1.50
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.49;
commitid	p4LJxGKbi0BU2cG6;

1.49
date	2014.12.15.02.11.57;	author tedu;	state Exp;
branches;
next	1.48;
commitid	idrzCI81iA9oSrel;

1.48
date	2011.06.21.22.36.42;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	2011.03.17.21.30.24;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2010.07.22.05.32.10;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	2010.07.10.02.52.38;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.01.16.18.28;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.01.03.06.43;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2010.04.23.01.39.05;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2010.02.27.00.03.53;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2010.01.04.00.45.58;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2009.12.01.01.40.02;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.12.06.20.27;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.10.10.13.08;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2009.11.05.03.33.52;	author marco;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.27.11.24.20;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2009.10.12.12.04.11;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.14.00.03.28;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2007.09.16.01.30.24;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.07.16.15.49;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.16.00.43.19;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.21.02.05.46;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.23.02.50.20;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.11.09.26.47;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.20.20.31.13;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.08.14.02.47;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.10.20.06.11;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.28.04.08.39;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.26.21.22.14;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.30.19.28.36;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.03.05.39.59;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.09.00.03.54;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.07.19.04.46;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.22.14.35.43;	author deraadt;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.04.30.21.21.54;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.25.03.50.53;	author todd;	state Exp;
branches;
next	1.10;

1.10
date	99.08.24.01.20.22;	author csapuntz;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	97.09.01.19.11.46;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.08.31.07.41.52;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.04.14.04.09.11;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.08.13.00.06.24;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.08.11.23.26.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.17.05.16.44;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.06.16.23.53.16;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.02.20.01.48.32;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches;
next	;

1.10.4.1
date	2001.05.14.22.44.59;	author niklas;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2001.07.04.11.00.05;	author niklas;	state Exp;
branches;
next	1.10.4.3;

1.10.4.3
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.10.4.4;

1.10.4.4
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.10.4.5;

1.10.4.5
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.10.4.6;

1.10.4.6
date	2004.02.19.11.01.30;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2002.01.31.22.55.48;	author niklas;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2002.06.11.03.32.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.53
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: scsi_ioctl.c,v 1.52 2016/03/12 15:16:04 krw Exp $	*/
/*	$NetBSD: scsi_ioctl.c,v 1.23 1996/10/12 23:23:17 christos Exp $	*/

/*
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Contributed by HD Associates (hd@@world.std.com).
 * Copyright (c) 1992, 1993 HD Associates
 *
 * Berkeley style copyright.
 */

#include <sys/param.h>
#include <sys/errno.h>
#include <sys/systm.h>
#include <sys/file.h>
#include <sys/pool.h>
#include <sys/device.h>
#include <sys/fcntl.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <sys/scsiio.h>
#include <sys/ataio.h>

int			scsi_ioc_cmd(struct scsi_link *, scsireq_t *);
int			scsi_ioc_ata_cmd(struct scsi_link *, atareq_t *);

const unsigned char scsi_readsafe_cmd[256] = {
	[0x00] = 1,	/* TEST UNIT READY */
	[0x03] = 1,	/* REQUEST SENSE */
	[0x08] = 1,	/* READ(6) */
	[0x12] = 1,	/* INQUIRY */
	[0x1a] = 1,	/* MODE SENSE */
	[0x1b] = 1,	/* START STOP */
	[0x23] = 1,	/* READ FORMAT CAPACITIES */
	[0x25] = 1,	/* READ CDVD CAPACITY */
	[0x28] = 1,	/* READ(10) */
	[0x2b] = 1,	/* SEEK */
	[0x2f] = 1,	/* VERIFY(10) */
	[0x3c] = 1,	/* READ BUFFER */
	[0x3e] = 1,	/* READ LONG */
	[0x42] = 1,	/* READ SUBCHANNEL */
	[0x43] = 1,	/* READ TOC PMA ATIP */
	[0x44] = 1,	/* READ HEADER */
	[0x45] = 1,	/* PLAY AUDIO(10) */
	[0x46] = 1,	/* GET CONFIGURATION */
	[0x47] = 1,	/* PLAY AUDIO MSF */
	[0x48] = 1,	/* PLAY AUDIO TI */
	[0x4a] = 1,	/* GET EVENT STATUS NOTIFICATION */
	[0x4b] = 1,	/* PAUSE RESUME */
	[0x4e] = 1,	/* STOP PLAY SCAN */
	[0x51] = 1,	/* READ DISC INFO */
	[0x52] = 1,	/* READ TRACK RZONE INFO */
	[0x5a] = 1,	/* MODE SENSE(10) */
	[0x88] = 1,	/* READ(16) */
	[0x8f] = 1,	/* VERIFY(16) */
	[0xa4] = 1,	/* REPORT KEY */
	[0xa5] = 1,	/* PLAY AUDIO(12) */
	[0xa8] = 1,	/* READ(12) */
	[0xac] = 1,	/* GET PERFORMANCE */
	[0xad] = 1,	/* READ DVD STRUCTURE */
	[0xb9] = 1,	/* READ CD MSF */
	[0xba] = 1,	/* SCAN */
	[0xbc] = 1,	/* PLAY CD */
	[0xbd] = 1,	/* MECHANISM STATUS */
	[0xbe] = 1	/* READ CD */
};

int
scsi_ioc_cmd(struct scsi_link *link, scsireq_t *screq)
{
	struct scsi_xfer *xs;
	int err = 0;

	if (screq->cmdlen > sizeof(struct scsi_generic))
		return (EFAULT);
	if (screq->datalen > MAXPHYS)
		return (EINVAL);

	xs = scsi_xs_get(link, 0);
	if (xs == NULL)
		return (ENOMEM);

	memcpy(xs->cmd, screq->cmd, screq->cmdlen);
	xs->cmdlen = screq->cmdlen;

	if (screq->datalen > 0) {
		xs->data = dma_alloc(screq->datalen, PR_WAITOK | PR_ZERO);
		if (xs->data == NULL) {
			err = ENOMEM;
			goto err;
		}
		xs->datalen = screq->datalen;
	}

	if (screq->flags & SCCMD_READ)
		xs->flags |= SCSI_DATA_IN;
	if (screq->flags & SCCMD_WRITE) {
		if (screq->datalen > 0) {
			err = copyin(screq->databuf, xs->data, screq->datalen);
			if (err != 0)
				goto err;
		}

		xs->flags |= SCSI_DATA_OUT;
	}

	xs->flags |= SCSI_SILENT;	/* User is responsible for errors. */
	xs->timeout = screq->timeout;
	xs->retries = 0; /* user must do the retries *//* ignored */

	scsi_xs_sync(xs);

	screq->retsts = 0;
	screq->status = xs->status;
	switch (xs->error) {
	case XS_NOERROR:
		/* probably rubbish */
		screq->datalen_used = xs->datalen - xs->resid;
		screq->retsts = SCCMD_OK;
		break;
	case XS_SENSE:
#ifdef SCSIDEBUG
		scsi_sense_print_debug(xs);
#endif
		screq->senselen_used = min(sizeof(xs->sense),
		    sizeof(screq->sense));
		memcpy(screq->sense, &xs->sense, screq->senselen_used);
		screq->retsts = SCCMD_SENSE;
		break;
	case XS_SHORTSENSE:
#ifdef SCSIDEBUG
		scsi_sense_print_debug(xs);
#endif
		printf("XS_SHORTSENSE\n");
		screq->senselen_used = min(sizeof(xs->sense),
		    sizeof(screq->sense));
		memcpy(screq->sense, &xs->sense, screq->senselen_used);
		screq->retsts = SCCMD_UNKNOWN;
		break;
	case XS_DRIVER_STUFFUP:
		screq->retsts = SCCMD_UNKNOWN;
		break;
	case XS_TIMEOUT:
		screq->retsts = SCCMD_TIMEOUT;
		break;
	case XS_BUSY:
		screq->retsts = SCCMD_BUSY;
		break;
	default:
		screq->retsts = SCCMD_UNKNOWN;
		break;
	}

	if (screq->datalen > 0 && screq->flags & SCCMD_READ) {
		err = copyout(xs->data, screq->databuf, screq->datalen);
		if (err != 0)
			goto err;
	}

err:
	if (xs->data)
		dma_free(xs->data, screq->datalen);
	scsi_xs_put(xs);

	return (err);
}

int
scsi_ioc_ata_cmd(struct scsi_link *link, atareq_t *atareq)
{
	struct scsi_xfer *xs;
	struct scsi_ata_passthru_12 *cdb;
	int err = 0;

	if (atareq->datalen > MAXPHYS)
		return (EINVAL);

	xs = scsi_xs_get(link, 0);
	if (xs == NULL)
		return (ENOMEM);

	cdb = (struct scsi_ata_passthru_12 *)xs->cmd;
	cdb->opcode = ATA_PASSTHRU_12;

	if (atareq->datalen > 0) {
		if (atareq->flags & ATACMD_READ) {
			cdb->count_proto = ATA_PASSTHRU_PROTO_PIO_DATAIN;
			cdb->flags = ATA_PASSTHRU_T_DIR_READ;
		} else {
			cdb->count_proto = ATA_PASSTHRU_PROTO_PIO_DATAOUT;
			cdb->flags = ATA_PASSTHRU_T_DIR_WRITE;
		}
		cdb->flags |= ATA_PASSTHRU_T_LEN_SECTOR_COUNT;
	} else {
		cdb->count_proto = ATA_PASSTHRU_PROTO_NON_DATA;
		cdb->flags = ATA_PASSTHRU_T_LEN_NONE;
	}
	cdb->features = atareq->features;
	cdb->sector_count = atareq->sec_count;
	cdb->lba_low = atareq->sec_num;
	cdb->lba_mid = atareq->cylinder;
	cdb->lba_high = atareq->cylinder >> 8;
	cdb->device = atareq->head & 0x0f;
	cdb->command = atareq->command;

	xs->cmdlen = sizeof(*cdb);

	if (atareq->datalen > 0) {
		xs->data = dma_alloc(atareq->datalen, PR_WAITOK | PR_ZERO);
		if (xs->data == NULL) {
			err = ENOMEM;
			goto err;
		}
		xs->datalen = atareq->datalen;
	}

	if (atareq->flags & ATACMD_READ)
		xs->flags |= SCSI_DATA_IN;
	if (atareq->flags & ATACMD_WRITE) {
		if (atareq->datalen > 0) {
			err = copyin(atareq->databuf, xs->data,
			    atareq->datalen);
			if (err != 0)
				goto err;
		}

		xs->flags |= SCSI_DATA_OUT;
	}

	xs->flags |= SCSI_SILENT;	/* User is responsible for errors. */
	xs->retries = 0; /* user must do the retries *//* ignored */

	scsi_xs_sync(xs);

	atareq->retsts = ATACMD_ERROR;
	switch (xs->error) {
	case XS_SENSE:
	case XS_SHORTSENSE:
#ifdef SCSIDEBUG
		scsi_sense_print_debug(xs);
#endif
		/* XXX this is not right */
	case XS_NOERROR:
		atareq->retsts = ATACMD_OK;
		break;
	default:
		atareq->retsts = ATACMD_ERROR;
		break;
	}

	if (atareq->datalen > 0 && atareq->flags & ATACMD_READ) {
		err = copyout(xs->data, atareq->databuf, atareq->datalen);
		if (err != 0)
			goto err;
	}

err:
	if (xs->data)
		dma_free(xs->data, atareq->datalen);
	scsi_xs_put(xs);

	return (err);
}

/*
 * Something (e.g. another driver) has called us
 * with a scsi_link for a target/lun/adapter, and a scsi
 * specific ioctl to perform, better try.
 */
int
scsi_do_ioctl(struct scsi_link *link, u_long cmd, caddr_t addr, int flag)
{
	SC_DEBUG(link, SDEV_DB2, ("scsi_do_ioctl(0x%lx)\n", cmd));

	switch(cmd) {
	case SCIOCIDENTIFY: {
		struct scsi_addr *sca = (struct scsi_addr *)addr;

		if ((link->flags & (SDEV_ATAPI | SDEV_UMASS)) == 0)
			/* A 'real' SCSI target. */
			sca->type = TYPE_SCSI;
		else
			/* An 'emulated' SCSI target. */
			sca->type = TYPE_ATAPI;
		sca->scbus = link->bus->sc_dev.dv_unit;
		sca->target = link->target;
		sca->lun = link->lun;
		return (0);
	}
	case SCIOCCOMMAND:
		if (scsi_readsafe_cmd[((scsireq_t *)addr)->cmd[0]])
			break;
		/* FALLTHROUGH */
	case ATAIOCCOMMAND:
	case SCIOCDEBUG:
		if ((flag & FWRITE) == 0)
			return (EPERM);
		break;
	default:
		if (link->adapter->ioctl)
			return ((link->adapter->ioctl)(link, cmd, addr,
			    flag));
		else
			return (ENOTTY);
	}

	switch(cmd) {
	case SCIOCCOMMAND:
		return (scsi_ioc_cmd(link, (scsireq_t *)addr));
	case ATAIOCCOMMAND:
		return (scsi_ioc_ata_cmd(link, (atareq_t *)addr));
	case SCIOCDEBUG: {
		int level = *((int *)addr);

		SC_DEBUG(link, SDEV_DB3, ("debug set to %d\n", level));
		link->flags &= ~SDEV_DBX; /* clear debug bits */
		if (level & 1)
			link->flags |= SDEV_DB1;
		if (level & 2)
			link->flags |= SDEV_DB2;
		if (level & 4)
			link->flags |= SDEV_DB3;
		if (level & 8)
			link->flags |= SDEV_DB4;
		return (0);
	}
	default:
#ifdef DIAGNOSTIC
		panic("scsi_do_ioctl: impossible cmd (%#lx)", cmd);
#endif
		return (0);
	}
}
@


1.52
log
@Standardize on calling local scsi_link variables 'link' instead of
'sc_link'. 'sc_link' is a field in the various device *_softc
structures, where the sc_ prefix was for 'softc'. Reduces potential
mental confusion. Newer code from down under was already using
'link'.

No functional change.

Prompted by bluhm@@'s adventures in scsi. ok dlg@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.51 2015/06/07 19:13:27 krw Exp $	*/
d40 1
a40 1
#include <sys/types.h>
a41 1
#include <sys/param.h>
@


1.51
log
@More damned eye searing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.50 2015/03/14 03:38:52 jsg Exp $	*/
d298 1
a298 1
 * with an sc_link for a target/lun/adapter, and a scsi
d302 1
a302 1
scsi_do_ioctl(struct scsi_link *sc_link, u_long cmd, caddr_t addr, int flag)
d304 1
a304 1
	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_do_ioctl(0x%lx)\n", cmd));
d310 1
a310 1
		if ((sc_link->flags & (SDEV_ATAPI | SDEV_UMASS)) == 0)
d316 3
a318 3
		sca->scbus = sc_link->bus->sc_dev.dv_unit;
		sca->target = sc_link->target;
		sca->lun = sc_link->lun;
d331 2
a332 2
		if (sc_link->adapter->ioctl)
			return ((sc_link->adapter->ioctl)(sc_link, cmd, addr,
d340 1
a340 1
		return (scsi_ioc_cmd(sc_link, (scsireq_t *)addr));
d342 1
a342 1
		return (scsi_ioc_ata_cmd(sc_link, (atareq_t *)addr));
d346 2
a347 2
		SC_DEBUG(sc_link, SDEV_DB3, ("debug set to %d\n", level));
		sc_link->flags &= ~SDEV_DBX; /* clear debug bits */
d349 1
a349 1
			sc_link->flags |= SDEV_DB1;
d351 1
a351 1
			sc_link->flags |= SDEV_DB2;
d353 1
a353 1
			sc_link->flags |= SDEV_DB3;
d355 1
a355 1
			sc_link->flags |= SDEV_DB4;
@


1.50
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.49 2014/12/15 02:11:57 tedu Exp $	*/
d313 1
a313 1
		else	
@


1.49
log
@convert bcopy to memcpy. ok dlg krw
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.48 2011/06/21 22:36:42 matthew Exp $	*/
a45 1
#include <sys/buf.h>
@


1.48
log
@scsi_link's scsibus field is redundant with bus->sc_dev.dv_unit, so
remove two of the remaining three uses of it.  (softraid(4) still uses
it at the moment, so the field and its assignment in scsibusattach()
stay for now...)

ok krw@@; feedback and "tenteiramen rejid"(!?) miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.47 2011/03/17 21:30:24 deraadt Exp $	*/
d159 1
a159 1
		bcopy(&xs->sense, screq->sense, screq->senselen_used);
d169 1
a169 1
		bcopy(&xs->sense, screq->sense, screq->senselen_used);
@


1.47
log
@use dma_alloc/dma_free instead of malloc to allocate buffers which need
to be in the right address space.
help from matthew and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.46 2010/07/22 05:32:10 matthew Exp $	*/
d317 1
a317 1
		sca->scbus = sc_link->scsibus;
@


1.46
log
@Mark two more DMA accessible malloc(9)s.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.45 2010/07/10 02:52:38 matthew Exp $	*/
d45 1
a45 1
#include <sys/malloc.h>
d119 1
a119 3
		/* XXX dma accessible */
		xs->data = malloc(screq->datalen, M_TEMP,
		    M_WAITOK | M_CANFAIL | M_ZERO);
d194 1
a194 1
		free(xs->data, M_TEMP);
d241 1
a241 3
		/* XXX dma accessible */
		xs->data = malloc(atareq->datalen, M_TEMP,
		    M_WAITOK | M_CANFAIL | M_ZERO);
d291 1
a291 1
		free(xs->data, M_TEMP);
@


1.45
log
@Limit SCIOCCOMMAND and ATAIOCCOMMAND requests to transferring MAXPHYS
bytes worth of data.  Also, pass M_CANFAIL to malloc(9) and handle
allocation failures by returning ENOMEM.

Prevents user space from causing a kernel panic by passing
ridiculously large datalen values.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.44 2010/07/01 16:18:28 krw Exp $	*/
d119 1
d243 1
@


1.44
log
@ioctl XS_SENSE/XS_SHORTSENSE should print the sense info like
everyone else when SCSIDEBUG is set.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.43 2010/07/01 03:06:43 matthew Exp $	*/
d108 2
d119 6
a124 1
		xs->data = malloc(screq->datalen, M_TEMP, M_WAITOK | M_ZERO);
d194 1
a194 1
	if (screq->datalen > 0)
d208 3
d242 6
a247 1
		xs->data = malloc(atareq->datalen, M_TEMP, M_WAITOK | M_ZERO);
d292 1
a292 1
	if (atareq->datalen > 0)
@


1.43
log
@Call malloc(9) with M_ZERO to prevent code paths from exposing
uninitialized memory to user space or devices.

ok deraadt@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.42 2010/06/15 04:11:34 dlg Exp $	*/
d148 3
d157 3
d258 3
@


1.42
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.41 2010/04/23 01:39:05 dlg Exp $	*/
d117 1
a117 1
		xs->data = malloc(screq->datalen, M_TEMP, M_WAITOK);
d226 1
a226 1
		xs->data = malloc(atareq->datalen, M_TEMP, M_WAITOK);
@


1.41
log
@the SAT spec from t10.org defines messages for tunnelling ATA commands over
SCSI when you're talking to a scsi to ata translation layer (satl). this
implements the ata command ioctl handler in scsi_ioctl.c that wraps the
ata command requests up in these scsi commands and then issues them against
the hardware. this cuts atascsi over to interpreting these scsi commands
rather than the ioctls directly.

this should allow mpi users (with a relatively recent firmware) to use
atactl against their SATA disks. i cant test cos my mpi(4) parts are too
old to either support these scsi commands or too old to take recent
firmwares.

ok marco@@ @@krw tested by krw@@ and me on ahci/atascsi
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.40 2010/02/27 00:03:53 krw Exp $	*/
a46 1
#include <sys/proc.h>
a278 2
 * If user-level type command, we must still be running
 * in the context of the calling process
d281 1
a281 2
scsi_do_ioctl(struct scsi_link *sc_link, dev_t dev, u_long cmd, caddr_t addr,
    int flag, struct proc *p)
d312 1
a312 1
			    flag, p));
@


1.40
log
@Don't print sense info for ioctl's. Let the userland program decide
what to tell the user. Silences cdio and cdrecord while probing
media.

ok dlg@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.39 2010/01/04 00:45:58 dlg Exp $	*/
d53 1
d55 1
d58 1
d189 87
d308 1
d324 2
@


1.39
log
@introduce scsi_xs_sync. this will synchronously execute a scsi_xfer
and do the appropriate sleeps, retries, error processing, and finally
returns an errno style value to the caller.

this cuts scsi_scsi_cmd, the ioctl code, sd_flush, and scsi_inquiry over
to scsi_xs_sync.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.38 2009/12/01 01:40:02 dlg Exp $	*/
d131 1
@


1.38
log
@put the midlayer changes back in.

the two issues affecting it last time are gone. the first, mishandling of
TRY_AGAIN_LATER is not relevant now that krw got rid of TRY_AGAIN_LATER.
the second, the misbehaving IBM disk was found to be a problem with siop
using ordered tags on most ops combined with the speed of the new code.

putting this in so we can move forward.

ok krw@@ "commit please" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.36 2009/11/10 10:13:08 dlg Exp $	*/
a102 1
	int s;
d134 1
a134 7
	xs->done = (void (*)(struct scsi_xfer *))wakeup;

	scsi_xs_exec(xs);
	s = splbio();
	while (!ISSET(xs->flags, ITSDONE))
		tsleep(xs, PRIBIO, "scsiioc", 0);
	splx(s);
@


1.37
log
@revert midlayer back to it was before i put my big rewrite in. this is
causing a weird problems on an alpha and also appears responsible for
isp(4) weirdness i havent had a chance to examine yet.

sigh, this makes me sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.35 2009/11/05 03:33:52 marco Exp $	*/
d55 1
a55 16
struct scsi_ioctl {
	LIST_ENTRY(scsi_ioctl)	si_list;
	struct buf		si_bp;
	struct uio		si_uio;
	struct iovec		si_iov;
	scsireq_t		si_screq;
	struct scsi_link	*si_sc_link;
};

LIST_HEAD(, scsi_ioctl)		si_head;

struct scsi_ioctl	*si_get(void);
void			si_free(struct scsi_ioctl *);
struct scsi_ioctl	*si_find(struct buf *);
void			scsistrategy(struct buf *);
void			scsiminphys(struct buf *);
d98 2
a99 2
struct scsi_ioctl *
si_get(void)
d101 3
a103 2
	struct scsi_ioctl			*si;
	int					s;
d105 2
a106 6
	si = malloc(sizeof(*si), M_TEMP, M_WAITOK | M_ZERO);
	s = splbio();
	LIST_INSERT_HEAD(&si_head, si, si_list);
	splx(s);
	return (si);
}
d108 3
a110 4
void
si_free(struct scsi_ioctl *si)
{
	int					s;
d112 2
a113 5
	s = splbio();
	LIST_REMOVE(si, si_list);
	splx(s);
	free(si, M_TEMP);
}
d115 3
a117 10
struct scsi_ioctl *
si_find(struct buf *bp)
{
	struct scsi_ioctl			*si;
	int					s;

	s = splbio();
	LIST_FOREACH(si, &si_head, si_list) {
		if (bp == &si->si_bp)
			break;
a118 1
	splx(s);
d120 8
a127 2
	return (si);
}
d129 1
a129 23
/*
 * We let the user interpret his own sense in the generic scsi world.
 * This routine is called at interrupt time if the SCSI_USER bit was set
 * in the flags passed to scsi_scsi_cmd(). No other completion processing
 * takes place, even if we are running over another device driver.
 * The lower level routines that call us here, will free the xs and restart
 * the device's queue if such exists.
 */
void
scsi_user_done(struct scsi_xfer *xs)
{
	struct buf				*bp;
	struct scsi_ioctl			*si;
	scsireq_t				*screq;
	struct scsi_link			*sc_link;

	splassert(IPL_BIO);

	bp = xs->bp;
	if (bp == NULL) {	/* ALL user requests must have a buf */
		sc_print_addr(xs->sc_link);
		printf("User command with no buf\n");
		return;
d132 4
a135 6
	si = si_find(bp);
	if (si == NULL) {
		sc_print_addr(xs->sc_link);
		printf("User command with no ioctl\n");
		return;
	}
d137 5
a141 3
	screq = &si->si_screq;
	sc_link = si->si_sc_link;
	SC_DEBUG(xs->sc_link, SDEV_DB2, ("user-done\n"));
a146 1
		SC_DEBUG(sc_link, SDEV_DB3, ("no error\n"));
d152 3
a154 3
		SC_DEBUG(sc_link, SDEV_DB3, ("have sense\n"));
		screq->senselen_used = min(sizeof(xs->sense), SENSEBUFLEN);
		bcopy(&xs->sense, screq->sense, screq->senselen);
d158 4
a161 3
		SC_DEBUG(sc_link, SDEV_DB3, ("have short sense\n"));
		screq->senselen_used = min(sizeof(xs->sense), SENSEBUFLEN);
		bcopy(&xs->sense, screq->sense, screq->senselen);
a164 2
		sc_print_addr(sc_link);
		printf("host adapter code inconsistency\n");
a167 1
		SC_DEBUG(sc_link, SDEV_DB3, ("timeout\n"));
a170 1
		SC_DEBUG(sc_link, SDEV_DB3, ("busy\n"));
a173 3
		sc_print_addr(sc_link);
		printf("unknown error category (0x%x) from host adapter code\n",
		    xs->error);
d178 4
a181 53
	biodone(bp); 	/* we're waiting on it in scsi_strategy() */
}


/* Pseudo strategy function
 * Called by scsi_do_ioctl() via physio/physstrat if there is to
 * be data transferred, and directly if there is no data transfer.
 * 
 * Should I reorganize this so it returns to physio instead
 * of sleeping in scsiio_scsi_cmd?  Is there any advantage, other
 * than avoiding the probable duplicate wakeup in iodone? [PD]
 *
 * No, seems ok to me... [JRE]
 * (I don't see any duplicate wakeups)
 *
 * Can't be used with block devices or raw_read/raw_write directly
 * from the cdevsw/bdevsw tables because they couldn't have added
 * the screq structure. [JRE]
 */
void
scsistrategy(struct buf *bp)
{
	struct scsi_ioctl			*si;
	scsireq_t				*screq;
	struct scsi_link			*sc_link;
	int					error;
	int					flags = 0;
	int					s;

	si = si_find(bp);
	if (si == NULL) {
		printf("user_strat: No ioctl\n");
		error = EINVAL;
		goto bad;
	}

	screq = &si->si_screq;
	sc_link = si->si_sc_link;
	SC_DEBUG(sc_link, SDEV_DB2, ("user_strategy\n"));

	/*
	 * We're in trouble if physio tried to break up the transfer.
	 */
	if (bp->b_bcount != screq->datalen) {
		sc_print_addr(sc_link);
		printf("physio split the request.. cannot proceed\n");
		error = EIO;
		goto bad;
	}

	if (screq->timeout == 0) {
		error = EINVAL;
		goto bad;
d184 4
a187 33
	if (screq->cmdlen > sizeof(struct scsi_generic)) {
		sc_print_addr(sc_link);
		printf("cmdlen too big\n");
		error = EFAULT;
		goto bad;
	}

	if (screq->flags & SCCMD_READ)
		flags |= SCSI_DATA_IN;
	if (screq->flags & SCCMD_WRITE)
		flags |= SCSI_DATA_OUT;
	if (screq->flags & SCCMD_TARGET)
		flags |= SCSI_TARGET;
	if (screq->flags & SCCMD_ESCAPE)
		flags |= SCSI_ESCAPE;

	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)screq->cmd,
	    screq->cmdlen, (u_char *)bp->b_data, screq->datalen,
	    0, /* user must do the retries *//* ignored */
	    screq->timeout, bp, flags | SCSI_USER | SCSI_NOSLEEP);

	/* because there is a bp, scsi_scsi_cmd will return immediately */
	if (error)
		goto bad;

	SC_DEBUG(sc_link, SDEV_DB3, ("about to sleep\n"));
	s = splbio();
	while ((bp->b_flags & B_DONE) == 0)
		tsleep(bp, PRIBIO, "scistr", 0);
	splx(s);
	SC_DEBUG(sc_link, SDEV_DB3, ("back from sleep\n"));

	return;
d189 1
a189 24
bad:
	bp->b_flags |= B_ERROR;
	bp->b_error = error;
	s = splbio();
	biodone(bp);
	splx(s);
}

void
scsiminphys(struct buf *bp)
{
	struct scsi_ioctl			*si;
	struct scsi_link			*sc_link;

	si = si_find(bp);
	if (si == NULL) {
		/* should not happen */
		bp->b_flags |= B_ERROR;
		bp->b_error = EINVAL;
		return;
	}

	sc_link = si->si_sc_link;
	(*sc_link->adapter->scsi_minphys)(bp, sc_link);
a202 2
	int					error;

a224 1
	case SCIOCRESET:
d237 2
a238 35
	case SCIOCCOMMAND: {
		scsireq_t *screq = (scsireq_t *)addr;
		struct scsi_ioctl *si;

		si = si_get();
		si->si_screq = *screq;
		si->si_sc_link = sc_link;
		if (screq->datalen) {
			si->si_iov.iov_base = screq->databuf;
			si->si_iov.iov_len = screq->datalen;
			si->si_uio.uio_iov = &si->si_iov;
			si->si_uio.uio_iovcnt = 1;
			si->si_uio.uio_resid = screq->datalen;
			si->si_uio.uio_offset = 0;
			si->si_uio.uio_segflg = UIO_USERSPACE;
			si->si_uio.uio_rw =
			    (screq->flags & SCCMD_READ) ? UIO_READ : UIO_WRITE;
			si->si_uio.uio_procp = p;
			error = physio(scsistrategy, &si->si_bp, dev,
			    (screq->flags & SCCMD_READ) ? B_READ : B_WRITE,
			    scsiminphys, &si->si_uio);
		} else {
			/* if no data, no need to translate it.. */
			si->si_bp.b_flags = 0;
			si->si_bp.b_data = 0;
			si->si_bp.b_bcount = 0;
			si->si_bp.b_dev = dev;
			si->si_bp.b_proc = p;
			scsistrategy(&si->si_bp);
			error = si->si_bp.b_error;
		}
		*screq = si->si_screq;
		si_free(si);
		return (error);
	}
a251 5
		return (0);
	}
	case SCIOCRESET: {
		scsi_scsi_cmd(sc_link, 0, 0, 0, 0, GENRETRY, 2000, NULL,
		    SCSI_RESET);
@


1.36
log
@backout the backout marco did of my code because of the NO_CCB breakage.
the fix for the NO_CCB breakage will follow shortly.

tested by krw@@ marco@@ johan@@
ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.33 2009/10/12 12:04:11 dlg Exp $	*/
d55 16
a70 1
int			scsi_ioc_cmd(struct scsi_link *, scsireq_t *);
d113 2
a114 2
int
scsi_ioc_cmd(struct scsi_link *link, scsireq_t *screq)
d116 2
a117 3
	struct scsi_xfer *xs;
	int err = 0;
	int s;
d119 6
a124 2
	if (screq->cmdlen > sizeof(struct scsi_generic))
		return (EFAULT);
d126 4
a129 3
	xs = scsi_xs_get(link, 0);
	if (xs == NULL)
		return (ENOMEM);
d131 5
a135 2
	memcpy(xs->cmd, screq->cmd, screq->cmdlen);
	xs->cmdlen = screq->cmdlen;
d137 10
a146 3
	if (screq->datalen > 0) {
		xs->data = malloc(screq->datalen, M_TEMP, M_WAITOK);
		xs->datalen = screq->datalen;
d148 1
d150 2
a151 8
	if (screq->flags & SCCMD_READ)
		xs->flags |= SCSI_DATA_IN;
	if (screq->flags & SCCMD_WRITE) {
		if (screq->datalen > 0) {
			err = copyin(screq->databuf, xs->data, screq->datalen);
			if (err != 0)
				goto err;
		}
d153 23
a175 1
		xs->flags |= SCSI_DATA_OUT;
d178 6
a183 4
	xs->timeout = screq->timeout;
	xs->retries = 0; /* user must do the retries *//* ignored */

	xs->done = (void (*)(struct scsi_xfer *))wakeup;
d185 3
a187 5
	scsi_xs_exec(xs);
	s = splbio();
	while (!ISSET(xs->flags, ITSDONE))
		tsleep(xs, PRIBIO, "scsiioc", 0);
	splx(s);
d193 1
d199 3
a201 3
		screq->senselen_used = min(sizeof(xs->sense),
		    sizeof(screq->sense));
		bcopy(&xs->sense, screq->sense, screq->senselen_used);
d205 3
a207 4
		printf("XS_SHORTSENSE\n");
		screq->senselen_used = min(sizeof(xs->sense),
		    sizeof(screq->sense));
		bcopy(&xs->sense, screq->sense, screq->senselen_used);
d211 2
d216 1
d220 1
d224 3
d231 53
a283 4
	if (screq->datalen > 0 && screq->flags & SCCMD_READ) {
		err = copyout(xs->data, screq->databuf, screq->datalen);
		if (err != 0)
			goto err;
d286 33
a318 4
err:
	if (screq->datalen > 0)
		free(xs->data, M_TEMP);
	scsi_xs_put(xs);
d320 24
a343 1
	return (err);
d357 2
d381 1
d394 35
a428 2
	case SCIOCCOMMAND:
		return (scsi_ioc_cmd(sc_link, (scsireq_t *)addr));
d442 5
@


1.35
log
@The big diff dlg committed to the midlayer breaks NO_CCB and
TRY_AGAIN_LATER.  NO_CCB is a timer based mechanism that can trivially
be made to fail by running IO to two or more disks simultaneously.  The
TRY_AGAIN_LATER thing is more subtle because it now is a permanent
failure instead of transient however this is much harder to hit because
something must have gone wrong before it hits.

ok deraadt krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.31 2009/02/16 21:19:07 miod Exp $	*/
d55 1
a55 16
struct scsi_ioctl {
	LIST_ENTRY(scsi_ioctl)	si_list;
	struct buf		si_bp;
	struct uio		si_uio;
	struct iovec		si_iov;
	scsireq_t		si_screq;
	struct scsi_link	*si_sc_link;
};

LIST_HEAD(, scsi_ioctl)		si_head;

struct scsi_ioctl	*si_get(void);
void			si_free(struct scsi_ioctl *);
struct scsi_ioctl	*si_find(struct buf *);
void			scsistrategy(struct buf *);
void			scsiminphys(struct buf *);
d98 2
a99 2
struct scsi_ioctl *
si_get(void)
d101 3
a103 2
	struct scsi_ioctl			*si;
	int					s;
d105 2
a106 6
	si = malloc(sizeof(*si), M_TEMP, M_WAITOK | M_ZERO);
	s = splbio();
	LIST_INSERT_HEAD(&si_head, si, si_list);
	splx(s);
	return (si);
}
d108 3
a110 4
void
si_free(struct scsi_ioctl *si)
{
	int					s;
d112 2
a113 5
	s = splbio();
	LIST_REMOVE(si, si_list);
	splx(s);
	free(si, M_TEMP);
}
d115 3
a117 10
struct scsi_ioctl *
si_find(struct buf *bp)
{
	struct scsi_ioctl			*si;
	int					s;

	s = splbio();
	LIST_FOREACH(si, &si_head, si_list) {
		if (bp == &si->si_bp)
			break;
a118 1
	splx(s);
d120 8
a127 2
	return (si);
}
d129 1
a129 23
/*
 * We let the user interpret his own sense in the generic scsi world.
 * This routine is called at interrupt time if the SCSI_USER bit was set
 * in the flags passed to scsi_scsi_cmd(). No other completion processing
 * takes place, even if we are running over another device driver.
 * The lower level routines that call us here, will free the xs and restart
 * the device's queue if such exists.
 */
void
scsi_user_done(struct scsi_xfer *xs)
{
	struct buf				*bp;
	struct scsi_ioctl			*si;
	scsireq_t				*screq;
	struct scsi_link			*sc_link;

	splassert(IPL_BIO);

	bp = xs->bp;
	if (bp == NULL) {	/* ALL user requests must have a buf */
		sc_print_addr(xs->sc_link);
		printf("User command with no buf\n");
		return;
d132 4
a135 6
	si = si_find(bp);
	if (si == NULL) {
		sc_print_addr(xs->sc_link);
		printf("User command with no ioctl\n");
		return;
	}
d137 5
a141 3
	screq = &si->si_screq;
	sc_link = si->si_sc_link;
	SC_DEBUG(xs->sc_link, SDEV_DB2, ("user-done\n"));
a146 1
		SC_DEBUG(sc_link, SDEV_DB3, ("no error\n"));
d152 3
a154 3
		SC_DEBUG(sc_link, SDEV_DB3, ("have sense\n"));
		screq->senselen_used = min(sizeof(xs->sense), SENSEBUFLEN);
		bcopy(&xs->sense, screq->sense, screq->senselen);
d158 4
a161 3
		SC_DEBUG(sc_link, SDEV_DB3, ("have short sense\n"));
		screq->senselen_used = min(sizeof(xs->sense), SENSEBUFLEN);
		bcopy(&xs->sense, screq->sense, screq->senselen);
a164 2
		sc_print_addr(sc_link);
		printf("host adapter code inconsistency\n");
a167 1
		SC_DEBUG(sc_link, SDEV_DB3, ("timeout\n"));
a170 1
		SC_DEBUG(sc_link, SDEV_DB3, ("busy\n"));
a173 3
		sc_print_addr(sc_link);
		printf("unknown error category (0x%x) from host adapter code\n",
		    xs->error);
d178 4
a181 53
	biodone(bp); 	/* we're waiting on it in scsi_strategy() */
}


/* Pseudo strategy function
 * Called by scsi_do_ioctl() via physio/physstrat if there is to
 * be data transferred, and directly if there is no data transfer.
 * 
 * Should I reorganize this so it returns to physio instead
 * of sleeping in scsiio_scsi_cmd?  Is there any advantage, other
 * than avoiding the probable duplicate wakeup in iodone? [PD]
 *
 * No, seems ok to me... [JRE]
 * (I don't see any duplicate wakeups)
 *
 * Can't be used with block devices or raw_read/raw_write directly
 * from the cdevsw/bdevsw tables because they couldn't have added
 * the screq structure. [JRE]
 */
void
scsistrategy(struct buf *bp)
{
	struct scsi_ioctl			*si;
	scsireq_t				*screq;
	struct scsi_link			*sc_link;
	int					error;
	int					flags = 0;
	int					s;

	si = si_find(bp);
	if (si == NULL) {
		printf("user_strat: No ioctl\n");
		error = EINVAL;
		goto bad;
	}

	screq = &si->si_screq;
	sc_link = si->si_sc_link;
	SC_DEBUG(sc_link, SDEV_DB2, ("user_strategy\n"));

	/*
	 * We're in trouble if physio tried to break up the transfer.
	 */
	if (bp->b_bcount != screq->datalen) {
		sc_print_addr(sc_link);
		printf("physio split the request.. cannot proceed\n");
		error = EIO;
		goto bad;
	}

	if (screq->timeout == 0) {
		error = EINVAL;
		goto bad;
d184 4
a187 33
	if (screq->cmdlen > sizeof(struct scsi_generic)) {
		sc_print_addr(sc_link);
		printf("cmdlen too big\n");
		error = EFAULT;
		goto bad;
	}

	if (screq->flags & SCCMD_READ)
		flags |= SCSI_DATA_IN;
	if (screq->flags & SCCMD_WRITE)
		flags |= SCSI_DATA_OUT;
	if (screq->flags & SCCMD_TARGET)
		flags |= SCSI_TARGET;
	if (screq->flags & SCCMD_ESCAPE)
		flags |= SCSI_ESCAPE;

	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)screq->cmd,
	    screq->cmdlen, (u_char *)bp->b_data, screq->datalen,
	    0, /* user must do the retries *//* ignored */
	    screq->timeout, bp, flags | SCSI_USER | SCSI_NOSLEEP);

	/* because there is a bp, scsi_scsi_cmd will return immediately */
	if (error)
		goto bad;

	SC_DEBUG(sc_link, SDEV_DB3, ("about to sleep\n"));
	s = splbio();
	while ((bp->b_flags & B_DONE) == 0)
		tsleep(bp, PRIBIO, "scistr", 0);
	splx(s);
	SC_DEBUG(sc_link, SDEV_DB3, ("back from sleep\n"));

	return;
d189 1
a189 24
bad:
	bp->b_flags |= B_ERROR;
	bp->b_error = error;
	s = splbio();
	biodone(bp);
	splx(s);
}

void
scsiminphys(struct buf *bp)
{
	struct scsi_ioctl			*si;
	struct scsi_link			*sc_link;

	si = si_find(bp);
	if (si == NULL) {
		/* should not happen */
		bp->b_flags |= B_ERROR;
		bp->b_error = EINVAL;
		return;
	}

	sc_link = si->si_sc_link;
	(*sc_link->adapter->scsi_minphys)(bp, sc_link);
a202 2
	int					error;

a224 1
	case SCIOCRESET:
d237 2
a238 35
	case SCIOCCOMMAND: {
		scsireq_t *screq = (scsireq_t *)addr;
		struct scsi_ioctl *si;

		si = si_get();
		si->si_screq = *screq;
		si->si_sc_link = sc_link;
		if (screq->datalen) {
			si->si_iov.iov_base = screq->databuf;
			si->si_iov.iov_len = screq->datalen;
			si->si_uio.uio_iov = &si->si_iov;
			si->si_uio.uio_iovcnt = 1;
			si->si_uio.uio_resid = screq->datalen;
			si->si_uio.uio_offset = 0;
			si->si_uio.uio_segflg = UIO_USERSPACE;
			si->si_uio.uio_rw =
			    (screq->flags & SCCMD_READ) ? UIO_READ : UIO_WRITE;
			si->si_uio.uio_procp = p;
			error = physio(scsistrategy, &si->si_bp, dev,
			    (screq->flags & SCCMD_READ) ? B_READ : B_WRITE,
			    scsiminphys, &si->si_uio);
		} else {
			/* if no data, no need to translate it.. */
			si->si_bp.b_flags = 0;
			si->si_bp.b_data = 0;
			si->si_bp.b_bcount = 0;
			si->si_bp.b_dev = dev;
			si->si_bp.b_proc = p;
			scsistrategy(&si->si_bp);
			error = si->si_bp.b_error;
		}
		*screq = si->si_screq;
		si_free(si);
		return (error);
	}
a251 5
		return (0);
	}
	case SCIOCRESET: {
		scsi_scsi_cmd(sc_link, 0, 0, 0, 0, GENRETRY, 2000, NULL,
		    SCSI_RESET);
@


1.34
log
@Check return value of scsi_xs_get() in scsi_ioc_cmd() for NULL. It
may or may not be possible to get NULL these days, but paranoia and
consistancy of usage are nice. Prompted by looking at PR#6247 from
Steven Mestdagh.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.33 2009/10/12 12:04:11 dlg Exp $	*/
d55 16
a70 1
int			scsi_ioc_cmd(struct scsi_link *, scsireq_t *);
d113 2
a114 2
int
scsi_ioc_cmd(struct scsi_link *link, scsireq_t *screq)
d116 2
a117 3
	struct scsi_xfer *xs;
	int err = 0;
	int s;
d119 6
a124 2
	if (screq->cmdlen > sizeof(struct scsi_generic))
		return (EFAULT);
d126 4
a129 3
	xs = scsi_xs_get(link, 0);
	if (xs == NULL)
		return (ENOMEM);
d131 5
a135 2
	memcpy(xs->cmd, screq->cmd, screq->cmdlen);
	xs->cmdlen = screq->cmdlen;
d137 10
a146 3
	if (screq->datalen > 0) {
		xs->data = malloc(screq->datalen, M_TEMP, M_WAITOK);
		xs->datalen = screq->datalen;
d148 1
d150 2
a151 8
	if (screq->flags & SCCMD_READ)
		xs->flags |= SCSI_DATA_IN;
	if (screq->flags & SCCMD_WRITE) {
		if (screq->datalen > 0) {
			err = copyin(screq->databuf, xs->data, screq->datalen);
			if (err != 0)
				goto err;
		}
d153 23
a175 1
		xs->flags |= SCSI_DATA_OUT;
d178 6
a183 4
	xs->timeout = screq->timeout;
	xs->retries = 0; /* user must do the retries *//* ignored */

	xs->done = (void (*)(struct scsi_xfer *))wakeup;
d185 3
a187 5
	scsi_xs_exec(xs);
	s = splbio();
	while (!ISSET(xs->flags, ITSDONE))
		tsleep(xs, PRIBIO, "scsiioc", 0);
	splx(s);
d193 1
d199 3
a201 3
		screq->senselen_used = min(sizeof(xs->sense),
		    sizeof(screq->sense));
		bcopy(&xs->sense, screq->sense, screq->senselen_used);
d205 3
a207 4
		printf("XS_SHORTSENSE\n");
		screq->senselen_used = min(sizeof(xs->sense),
		    sizeof(screq->sense));
		bcopy(&xs->sense, screq->sense, screq->senselen_used);
d211 2
d216 1
d220 1
d224 3
d231 53
a283 4
	if (screq->datalen > 0 && screq->flags & SCCMD_READ) {
		err = copyout(xs->data, screq->databuf, screq->datalen);
		if (err != 0)
			goto err;
d286 33
a318 4
err:
	if (screq->datalen > 0)
		free(xs->data, M_TEMP);
	scsi_xs_put(xs);
d320 24
a343 1
	return (err);
d357 2
d381 1
d394 35
a428 2
	case SCIOCCOMMAND:
		return (scsi_ioc_cmd(sc_link, (scsireq_t *)addr));
d442 5
@


1.33
log
@avoid smashing the stack when we have sense data to return back to userland
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.30 2007/09/16 01:30:24 krw Exp $	*/
d109 2
@


1.32
log
@rework the scsi midlayer to start addressing some problems i have
with it which became extremely annoying with what mpath wants to
do.

the major change is a new interface for submitting scsi commands.
previously the only way for drivers like sd, cd, st, etc to push
commands onto the hardware was via scsi_scsi_cmd(). the problem
with scsi_scsi_cmd is that it doesnt tell the caller if the command
failed, was queued, or completed unless you shoved a buf down with
it. this is important for mpath which wants to know what the physical
path to the device did so it can report it back to the midlayer
which called it.

this provides a new api which lets drivers like cd/sd/st/mpath etc
allocate an xs, fill it in, and provide a completion routine which
the midlayer will call with the state of the command when it is
finished with it. the caller is then responsible for freeing the
xs.

from the hba side of thing, the return code from the scsi_cmd
entrypoint is largely ignored now, and it is now always the
responsibility of the hba driver to call scsi_done when it has
completed the io, rather than returning COMPLETE and expecting the
midlayer to do it for you.

i have emulated scsi_scsi_cmd on top of this new api so existing
users of it will continue to work. sd(4) has been reworked to use
the new api directly to both demonstrate its use and test that the
new api actually does work.

this diff was mostly written in a day at f2k9. thanks to miod for poking
through hba drivers to help mitigate against fallout from the change to
the COMPLETE semantic. this has been reviewed by krw who didnt spot
anything wrong.

thanks to dave del debbio for testing.

ok deraadt@@
@
text
@d150 3
a152 2
		screq->senselen_used = min(sizeof(xs->sense), SENSEBUFLEN);
		bcopy(&xs->sense, screq->sense, screq->senselen);
d156 4
a159 2
		screq->senselen_used = min(sizeof(xs->sense), SENSEBUFLEN);
		bcopy(&xs->sense, screq->sense, screq->senselen);
@


1.31
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d55 1
a55 16
struct scsi_ioctl {
	LIST_ENTRY(scsi_ioctl)	si_list;
	struct buf		si_bp;
	struct uio		si_uio;
	struct iovec		si_iov;
	scsireq_t		si_screq;
	struct scsi_link	*si_sc_link;
};

LIST_HEAD(, scsi_ioctl)		si_head;

struct scsi_ioctl	*si_get(void);
void			si_free(struct scsi_ioctl *);
struct scsi_ioctl	*si_find(struct buf *);
void			scsistrategy(struct buf *);
void			scsiminphys(struct buf *);
d98 2
a99 2
struct scsi_ioctl *
si_get(void)
d101 3
a103 9
	struct scsi_ioctl			*si;
	int					s;

	si = malloc(sizeof(*si), M_TEMP, M_WAITOK | M_ZERO);
	s = splbio();
	LIST_INSERT_HEAD(&si_head, si, si_list);
	splx(s);
	return (si);
}
d105 2
a106 4
void
si_free(struct scsi_ioctl *si)
{
	int					s;
d108 1
a108 5
	s = splbio();
	LIST_REMOVE(si, si_list);
	splx(s);
	free(si, M_TEMP);
}
d110 2
a111 5
struct scsi_ioctl *
si_find(struct buf *bp)
{
	struct scsi_ioctl			*si;
	int					s;
d113 3
a115 4
	s = splbio();
	LIST_FOREACH(si, &si_head, si_list) {
		if (bp == &si->si_bp)
			break;
a116 1
	splx(s);
d118 8
a125 2
	return (si);
}
d127 1
a127 23
/*
 * We let the user interpret his own sense in the generic scsi world.
 * This routine is called at interrupt time if the SCSI_USER bit was set
 * in the flags passed to scsi_scsi_cmd(). No other completion processing
 * takes place, even if we are running over another device driver.
 * The lower level routines that call us here, will free the xs and restart
 * the device's queue if such exists.
 */
void
scsi_user_done(struct scsi_xfer *xs)
{
	struct buf				*bp;
	struct scsi_ioctl			*si;
	scsireq_t				*screq;
	struct scsi_link			*sc_link;

	splassert(IPL_BIO);

	bp = xs->bp;
	if (bp == NULL) {	/* ALL user requests must have a buf */
		sc_print_addr(xs->sc_link);
		printf("User command with no buf\n");
		return;
d130 2
a131 6
	si = si_find(bp);
	if (si == NULL) {
		sc_print_addr(xs->sc_link);
		printf("User command with no ioctl\n");
		return;
	}
d133 7
a139 3
	screq = &si->si_screq;
	sc_link = si->si_sc_link;
	SC_DEBUG(xs->sc_link, SDEV_DB2, ("user-done\n"));
a144 1
		SC_DEBUG(sc_link, SDEV_DB3, ("no error\n"));
a149 1
		SC_DEBUG(sc_link, SDEV_DB3, ("have sense\n"));
a154 1
		SC_DEBUG(sc_link, SDEV_DB3, ("have short sense\n"));
a159 2
		sc_print_addr(sc_link);
		printf("host adapter code inconsistency\n");
a162 1
		SC_DEBUG(sc_link, SDEV_DB3, ("timeout\n"));
a165 1
		SC_DEBUG(sc_link, SDEV_DB3, ("busy\n"));
a168 3
		sc_print_addr(sc_link);
		printf("unknown error category (0x%x) from host adapter code\n",
		    xs->error);
d173 4
a176 53
	biodone(bp); 	/* we're waiting on it in scsi_strategy() */
}


/* Pseudo strategy function
 * Called by scsi_do_ioctl() via physio/physstrat if there is to
 * be data transferred, and directly if there is no data transfer.
 * 
 * Should I reorganize this so it returns to physio instead
 * of sleeping in scsiio_scsi_cmd?  Is there any advantage, other
 * than avoiding the probable duplicate wakeup in iodone? [PD]
 *
 * No, seems ok to me... [JRE]
 * (I don't see any duplicate wakeups)
 *
 * Can't be used with block devices or raw_read/raw_write directly
 * from the cdevsw/bdevsw tables because they couldn't have added
 * the screq structure. [JRE]
 */
void
scsistrategy(struct buf *bp)
{
	struct scsi_ioctl			*si;
	scsireq_t				*screq;
	struct scsi_link			*sc_link;
	int					error;
	int					flags = 0;
	int					s;

	si = si_find(bp);
	if (si == NULL) {
		printf("user_strat: No ioctl\n");
		error = EINVAL;
		goto bad;
	}

	screq = &si->si_screq;
	sc_link = si->si_sc_link;
	SC_DEBUG(sc_link, SDEV_DB2, ("user_strategy\n"));

	/*
	 * We're in trouble if physio tried to break up the transfer.
	 */
	if (bp->b_bcount != screq->datalen) {
		sc_print_addr(sc_link);
		printf("physio split the request.. cannot proceed\n");
		error = EIO;
		goto bad;
	}

	if (screq->timeout == 0) {
		error = EINVAL;
		goto bad;
d179 4
a182 33
	if (screq->cmdlen > sizeof(struct scsi_generic)) {
		sc_print_addr(sc_link);
		printf("cmdlen too big\n");
		error = EFAULT;
		goto bad;
	}

	if (screq->flags & SCCMD_READ)
		flags |= SCSI_DATA_IN;
	if (screq->flags & SCCMD_WRITE)
		flags |= SCSI_DATA_OUT;
	if (screq->flags & SCCMD_TARGET)
		flags |= SCSI_TARGET;
	if (screq->flags & SCCMD_ESCAPE)
		flags |= SCSI_ESCAPE;

	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)screq->cmd,
	    screq->cmdlen, (u_char *)bp->b_data, screq->datalen,
	    0, /* user must do the retries *//* ignored */
	    screq->timeout, bp, flags | SCSI_USER | SCSI_NOSLEEP);

	/* because there is a bp, scsi_scsi_cmd will return immediately */
	if (error)
		goto bad;

	SC_DEBUG(sc_link, SDEV_DB3, ("about to sleep\n"));
	s = splbio();
	while ((bp->b_flags & B_DONE) == 0)
		tsleep(bp, PRIBIO, "scistr", 0);
	splx(s);
	SC_DEBUG(sc_link, SDEV_DB3, ("back from sleep\n"));

	return;
d184 1
a184 24
bad:
	bp->b_flags |= B_ERROR;
	bp->b_error = error;
	s = splbio();
	biodone(bp);
	splx(s);
}

void
scsiminphys(struct buf *bp)
{
	struct scsi_ioctl			*si;
	struct scsi_link			*sc_link;

	si = si_find(bp);
	if (si == NULL) {
		/* should not happen */
		bp->b_flags |= B_ERROR;
		bp->b_error = EINVAL;
		return;
	}

	sc_link = si->si_sc_link;
	(*sc_link->adapter->scsi_minphys)(bp, sc_link);
a197 2
	int					error;

a219 1
	case SCIOCRESET:
d232 2
a233 35
	case SCIOCCOMMAND: {
		scsireq_t *screq = (scsireq_t *)addr;
		struct scsi_ioctl *si;

		si = si_get();
		si->si_screq = *screq;
		si->si_sc_link = sc_link;
		if (screq->datalen) {
			si->si_iov.iov_base = screq->databuf;
			si->si_iov.iov_len = screq->datalen;
			si->si_uio.uio_iov = &si->si_iov;
			si->si_uio.uio_iovcnt = 1;
			si->si_uio.uio_resid = screq->datalen;
			si->si_uio.uio_offset = 0;
			si->si_uio.uio_segflg = UIO_USERSPACE;
			si->si_uio.uio_rw =
			    (screq->flags & SCCMD_READ) ? UIO_READ : UIO_WRITE;
			si->si_uio.uio_procp = p;
			error = physio(scsistrategy, &si->si_bp, dev,
			    (screq->flags & SCCMD_READ) ? B_READ : B_WRITE,
			    scsiminphys, &si->si_uio);
		} else {
			/* if no data, no need to translate it.. */
			si->si_bp.b_flags = 0;
			si->si_bp.b_data = 0;
			si->si_bp.b_bcount = 0;
			si->si_bp.b_dev = dev;
			si->si_bp.b_proc = p;
			scsistrategy(&si->si_bp);
			error = si->si_bp.b_error;
		}
		*screq = si->si_screq;
		si_free(si);
		return (error);
	}
a246 5
		return (0);
	}
	case SCIOCRESET: {
		scsi_scsi_cmd(sc_link, 0, 0, 0, 0, GENRETRY, 2000, NULL,
		    SCSI_RESET);
@


1.30
log
@MALLOC/FREE -> malloc/free, M_ZERO, extraneous casts,
extraneous #include <malloc.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.29 2007/09/07 16:15:49 krw Exp $	*/
d70 1
d328 18
d414 1
a414 1
			    sc_link->adapter->scsi_minphys, &si->si_uio);
@


1.29
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.28 2007/01/16 00:43:19 krw Exp $	*/
d118 1
a118 1
	si = malloc(sizeof(struct scsi_ioctl), M_TEMP, M_WAITOK | M_ZERO);
@


1.28
log
@Report SDEV_UMASS devices as non-'SCSI', i.e. 'ATAPI', devices when
asked via SCIOCIDENTIFY. More closely emulates the Linux
SCIOCIDENTIFY/SG_EMULATED_HOST combination used by cdparanoia (and
god knows what other ports). Nothing in the tree itself uses
SCIOCIDENTIFY.

Fixes cdparanoia's handling of USB CD drives that can't handle the
MODE SENSE command. cdparanoia sends 'ATAPI' devices only MODE SENSE
BIG (0x5a) commands. Finding actual SCSI devices that might have
trouble with MODE SENSE BIG (i.e. very old devices) behind USB is
deemed highly unlikely.

Problem reported, debugged and fix tested by bernd@@.

ok marco@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.27 2006/12/21 02:05:46 krw Exp $	*/
d118 1
a118 2
	si = malloc(sizeof(struct scsi_ioctl), M_TEMP, M_WAITOK);
	bzero(si, sizeof(struct scsi_ioctl));
@


1.27
log
@Fix some comment typos. 'immediatly' -> 'immediately', 'tranfer' ->
'transfer', 'tranfered' -> 'transferred'.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.26 2006/07/23 02:50:20 dlg Exp $	*/
d347 6
a352 2
		sca->type = (sc_link->flags & SDEV_ATAPI)
			? TYPE_ATAPI : TYPE_SCSI;
@


1.26
log
@remove some scsi ioctls, most importantly the ones that can reprobe the
bus. supporting these complicates the midlayer unnecessarily.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.25 2006/07/11 09:26:47 dlg Exp $	*/
d307 1
a307 1
	/* because there is a bp, scsi_scsi_cmd will return immediatly */
@


1.25
log
@a few formatting tweaks. this was mostly knf/ansi already. no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.24 2006/05/11 00:45:59 krw Exp $	*/
a343 8
	case OSCIOCIDENTIFY: {
		struct oscsi_addr *sca = (struct oscsi_addr *)addr;

		sca->scbus = sc_link->scsibus;
		sca->target = sc_link->target;
		sca->lun = sc_link->lun;
		return (0);
	}
a353 3
	case SCIOCRECONFIG:
	case SCIOCDECONFIG:
		return (EINVAL);
a358 2
	case SCIOCREPROBE:
	case OSCIOCREPROBE:
a420 10
	}
	case OSCIOCREPROBE: {
		struct oscsi_addr *sca = (struct oscsi_addr *)addr;

		return (scsi_probe_busses(sca->scbus, sca->target, sca->lun));
	}
	case SCIOCREPROBE: {
		struct scsi_addr *sca = (struct scsi_addr *)addr;

		return (scsi_probe_busses(sca->scbus, sca->target, sca->lun));
@


1.24
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.23 2006/04/20 20:31:13 miod Exp $	*/
d56 6
a61 6
	LIST_ENTRY(scsi_ioctl) si_list;
	struct buf si_bp;
	struct uio si_uio;
	struct iovec si_iov;
	scsireq_t si_screq;
	struct scsi_link *si_sc_link;
d64 1
a64 1
LIST_HEAD(, scsi_ioctl) si_head;
d66 4
a69 4
struct scsi_ioctl *si_get(void);
void si_free(struct scsi_ioctl *);
struct scsi_ioctl *si_find(struct buf *);
void scsistrategy(struct buf *);
d115 2
a116 2
	struct scsi_ioctl *si;
	int s;
d129 1
a129 1
	int s;
d140 2
a141 2
	struct scsi_ioctl *si;
	int s;
d144 1
a144 1
	LIST_FOREACH(si, &si_head, si_list)
d147 1
d149 1
d164 4
a167 4
	struct buf *bp;
	struct scsi_ioctl *si;
	scsireq_t *screq;
	struct scsi_link *sc_link;
d172 1
a172 1
	if (!bp) {	/* ALL user requests must have a buf */
d177 1
d179 1
a179 1
	if (!si) {
d184 1
d194 2
a195 1
		screq->datalen_used = xs->datalen - xs->resid; /* probably rubbish */
d230 1
d253 6
a258 6
	struct scsi_ioctl *si;
	scsireq_t *screq;
	struct scsi_link *sc_link;
	int error;
	int flags = 0;
	int s;
d261 1
a261 1
	if (!si) {
d266 1
d336 1
a336 1
scsi_do_ioctl( struct scsi_link *sc_link, dev_t dev, u_long cmd, caddr_t addr,
d339 1
a339 1
	int error;
@


1.23
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.22 2005/12/08 14:02:47 krw Exp $	*/
d33 1
a33 1
/* 
d37 1
a37 1
 * Berkeley style copyright.  
d348 1
a348 1
		sca->type = (sc_link->flags & SDEV_ATAPI) 
d361 1
a361 1
		/* FALLTHROUGH */	
d369 1
a369 1
	default:	
d371 1
a371 1
			return ((sc_link->adapter->ioctl)(sc_link, cmd, addr, 
d393 1
a393 1
			si->si_uio.uio_rw = 
@


1.22
log
@Don't panic for pathological i/o sizes unless minphys() really is
broken. Eliminate an unneeded variable and potential conversion issues
in SCIOCCOMMAND code before calling physio.

Similar to what NetBSD does.

Fixes cdda2wav vs "Billie Holiday - Songs for Distingue Lovers"
problem noted by Alexandre Ratchov.  Tested by Alexandre.

ok marco@@ pedro@@ deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.21 2005/10/10 20:06:11 krw Exp $	*/
d445 1
a445 1
		panic("scsi_do_ioctl: impossible cmd (%#x)", cmd);
@


1.21
log
@Make some panic messages more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.20 2005/05/28 04:08:39 krw Exp $	*/
a380 1
		int len;
d385 1
a385 2
		len = screq->datalen;
		if (len) {
d387 1
a387 1
			si->si_iov.iov_len = len;
d390 1
a390 1
			si->si_uio.uio_resid = len;
@


1.20
log
@Handle XS_SHORTSENSE error codes in ioctl situations. From NetBSD.

Fixes spurious error messages from cdparanoia when using ATAPI CDROM
in USB enclosure.

ok pascoe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.19 2004/12/26 21:22:14 miod Exp $	*/
d447 1
a447 1
		panic("scsi_do_ioctl: impossible");
@


1.19
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.18 2004/11/30 19:28:36 krw Exp $	*/
d198 6
@


1.18
log
@No longer require write permission for read-only SCSI commands
submitted via ioctl. Eliminate scsi_do_safeioctl(), thus permitting
ch, ss and st devices to submit SCSI commands. Return EPERM rather
than EBADF when permissions are inadequate.

Allows more programs to run with fewer permissions. Problem diagnosed
by Nikolay Sturm in mplayer port.

Tested by Nikolay, ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.17 2004/01/03 05:39:59 krw Exp $	*/
d144 1
a144 1
	for (si = si_head.lh_first; si != 0; si = si->si_list.le_next)
@


1.17
log
@Make 'unknown error category' message more informative by including error
number. Same change as was made to scsi_base.c a few days ago.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.16 2002/06/09 00:03:54 art Exp $	*/
d71 41
d113 1
a113 1
si_get()
d127 1
a127 2
si_free(si)
	struct scsi_ioctl *si;
d138 1
a138 2
si_find(bp)
	struct buf *bp;
d160 1
a160 2
scsi_user_done(xs)
	struct scsi_xfer *xs;
d239 1
a239 2
scsistrategy(bp)
	struct buf *bp;
d323 2
a324 7
scsi_do_ioctl(sc_link, dev, cmd, addr, flag, p)
	struct scsi_link *sc_link;
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
d330 40
a369 3
	/* If we don't have write access, just skip to the safe ones. */
	if ((flag & FWRITE) == 0)
		return scsi_do_safeioctl(sc_link, dev, cmd, addr, flag, p);
d407 1
a407 1
		return error;
d422 1
a422 1
		return 0;
d427 1
a427 1
		return scsi_probe_busses(sca->scbus, sca->target, sca->lun);
d432 1
a432 1
		return scsi_probe_busses(sca->scbus, sca->target, sca->lun);
a433 3
	case SCIOCRECONFIG:
	case SCIOCDECONFIG:
		return EINVAL;
a434 2
		if ((flag & FWRITE) == 0)
			return EBADF;
d437 1
a437 1
		return 0;
a439 3
		return scsi_do_safeioctl(sc_link, dev, cmd, addr, flag, p);
	}

d441 1
a441 1
	panic("scsi_do_ioctl: impossible");
d443 1
a443 47
}

int
scsi_do_safeioctl(sc_link, dev, cmd, addr, flag, p)
	struct scsi_link *sc_link;
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_do_safeioctl(0x%lx)\n", cmd));

	switch(cmd) {
	case OSCIOCIDENTIFY: {
		struct oscsi_addr *sca = (struct oscsi_addr *)addr;

		sca->scbus = sc_link->scsibus;
		sca->target = sc_link->target;
		sca->lun = sc_link->lun;
		return 0;
	}
	case SCIOCIDENTIFY: {
		struct scsi_addr *sca = (struct scsi_addr *)addr;

		sca->type = (sc_link->flags & SDEV_ATAPI) 
			? TYPE_ATAPI : TYPE_SCSI;
		sca->scbus = sc_link->scsibus;
		sca->target = sc_link->target;
		sca->lun = sc_link->lun;
		return 0;
	}
	case SCIOCCOMMAND:
	case SCIOCDEBUG:
	case SCIOCREPROBE:
	case OSCIOCREPROBE:
	case SCIOCRESET:
		return EBADF;
	case SCIOCRECONFIG:
	case SCIOCDECONFIG:
		return EINVAL;
	default:
		if (sc_link->adapter->ioctl)
			return (sc_link->adapter->ioctl)(sc_link, cmd, addr, 
			    flag, p);
		else
			return ENOTTY;
@


1.16
log
@some splassert and protection of biodone.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.15 2002/03/14 01:27:13 millert Exp $	*/
d176 2
a177 1
		printf("unknown error category from host adapter code\n");
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.14 2002/01/07 19:04:46 mickey Exp $	*/
d129 2
d272 1
d274 1
@


1.14
log
@pass the proc* down the ioctl chain to controller; mjacob@@ csapuntz@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.13 2001/06/22 14:35:43 deraadt Exp $	*/
d66 4
a69 4
struct scsi_ioctl *si_get __P((void));
void si_free __P((struct scsi_ioctl *));
struct scsi_ioctl *si_find __P((struct buf *));
void scsistrategy __P((struct buf *));
@


1.13
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.12 2001/04/30 21:21:54 csapuntz Exp $	*/
d421 1
a421 1
			    flag);
@


1.13.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.14 2002/01/07 19:04:46 mickey Exp $	*/
d421 1
a421 1
			    flag, p);
@


1.13.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.13.4.1 2002/01/31 22:55:48 niklas Exp $	*/
d66 4
a69 4
struct scsi_ioctl *si_get(void);
void si_free(struct scsi_ioctl *);
struct scsi_ioctl *si_find(struct buf *);
void scsistrategy(struct buf *);
a128 2
	splassert(IPL_BIO);

a269 1
	s = splbio();
a270 1
	splx(s);
@


1.12
log
@

Pass IOCTL to adapter device if not understood by SCSI layer.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.11 2001/01/25 03:50:53 todd Exp $	*/
d367 1
a367 1
		      SCSI_RESET);
@


1.11
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.10 1999/08/24 01:20:22 csapuntz Exp $	*/
d419 5
a423 1
		return ENOTTY;
@


1.10
log
@

Added type field to scsi_addr to reflect bus/device type (ATAPI or SCSI).
Updated ioctls to match

Minor patches in anticipation of wd->sd translation layer
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.9 1997/09/01 19:11:46 niklas Exp $	*/
d184 1
a184 1
 * be data transfered, and directly if there is no data transfer.
@


1.10.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.11 2001/01/25 03:50:53 todd Exp $	*/
d184 1
a184 1
 * be data transferred, and directly if there is no data transfer.
@


1.10.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.10.4.1 2001/05/14 22:44:59 niklas Exp $	*/
d367 1
a367 1
		    SCSI_RESET);
d419 1
a419 5
		if (sc_link->adapter->ioctl)
			return (sc_link->adapter->ioctl)(sc_link, cmd, addr, 
			    flag);
		else
			return ENOTTY;
@


1.10.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d421 1
a421 1
			    flag, p);
@


1.10.4.4
log
@Merge in -current from roughly a week ago
@
text
@d66 4
a69 4
struct scsi_ioctl *si_get(void);
void si_free(struct scsi_ioctl *);
struct scsi_ioctl *si_find(struct buf *);
void scsistrategy(struct buf *);
@


1.10.4.5
log
@Sync the SMP branch with 3.3
@
text
@a128 2
	splassert(IPL_BIO);

a269 1
	s = splbio();
a270 1
	splx(s);
@


1.10.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d176 1
a176 2
		printf("unknown error category (0x%x) from host adapter code\n",
		    xs->error);
@


1.9
log
@Correct a debug printout
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.8 1997/08/31 07:41:52 downsj Exp $	*/
d350 5
d391 8
d402 2
d412 1
@


1.8
log
@* Make scsi_do_ioctl() sane again.
* Use scsi_do_ioctl() in cd.c and uk.c again.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.7 1997/04/14 04:09:11 downsj Exp $	*/
d383 1
a383 1
	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_do_ioctl(0x%lx)\n", cmd));
@


1.7
log
@Merge in various pieces of current NetBSD scsi code, including but not limited
to:

* New changer driver.
* Better optical support.
* Different `done' semantics.
* New quirks for SCSI QIC tape driver, SCSI floppy drives.
* Better support for SCSI-I devices.

Everybody needs to test this.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.6 1996/08/13 00:06:24 niklas Exp $	*/
d293 3
a295 9
	/* Check for the safe-ness of this request. */
	switch (cmd) {
	case SCIOCIDENTIFY:
		break;

	default:
		if ((flag & FWRITE) == 0)
			return EBADF;
	}
a302 3
		if ((flag & FWRITE) == 0)
			return EBADF;

a337 2
		if ((flag & FWRITE) == 0)
			return EBADF;
a352 2
		if ((flag & FWRITE) == 0)
			return EBADF;
d394 8
@


1.6
log
@Remove unused variable
@
text
@d1 2
a2 2
/*	$OpenBSD: scsi_ioctl.c,v 1.5 1996/08/11 23:26:03 deraadt Exp $	*/
/*	$NetBSD: scsi_ioctl.c,v 1.20 1996/02/14 21:47:22 christos Exp $	*/
d49 1
d292 10
@


1.5
log
@limit ioctl priviledges
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.4 1996/06/17 05:16:44 downsj Exp $	*/
a384 2
	int error;

@


1.4
log
@SCIOCCOMMAND now requires that the device be open for writing.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_ioctl.c,v 1.3 1996/06/16 23:53:16 downsj Exp $	*/
d336 2
d353 2
d360 30
a397 5
	case SCIOCRESET: {
		scsi_scsi_cmd(sc_link, 0, 0, 0, 0, GENRETRY, 2000, NULL,
		      SCSI_RESET);
		return 0;
	}
a400 4

#ifdef DIAGNOSTIC
	panic("scsi_do_ioctl: impossible");
#endif
@


1.3
log
@netbsd pr#2220: add SCIOCRESET.  I can't think of any reason not to.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
d297 3
@


1.2
log
@Sync. w/ NetBSD: scsi prototypes.
@
text
@d1 1
d358 5
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: scsi_ioctl.c,v 1.19 1995/09/26 19:26:58 thorpej Exp $	*/
d62 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
