head	1.165;
access;
symbols
	OPENBSD_6_1:1.164.0.6
	OPENBSD_6_1_BASE:1.164
	OPENBSD_6_0:1.164.0.2
	OPENBSD_6_0_BASE:1.164
	OPENBSD_5_9:1.163.0.2
	OPENBSD_5_9_BASE:1.163
	OPENBSD_5_8:1.163.0.4
	OPENBSD_5_8_BASE:1.163
	OPENBSD_5_7:1.162.0.2
	OPENBSD_5_7_BASE:1.162
	OPENBSD_5_6:1.161.0.4
	OPENBSD_5_6_BASE:1.161
	OPENBSD_5_5:1.160.0.4
	OPENBSD_5_5_BASE:1.160
	OPENBSD_5_4:1.153.0.2
	OPENBSD_5_4_BASE:1.153
	OPENBSD_5_3:1.150.0.4
	OPENBSD_5_3_BASE:1.150
	OPENBSD_5_2:1.150.0.2
	OPENBSD_5_2_BASE:1.150
	OPENBSD_5_1_BASE:1.149
	OPENBSD_5_1:1.149.0.4
	OPENBSD_5_0:1.149.0.2
	OPENBSD_5_0_BASE:1.149
	OPENBSD_4_9:1.142.0.2
	OPENBSD_4_9_BASE:1.142
	OPENBSD_4_8:1.135.0.2
	OPENBSD_4_8_BASE:1.135
	OPENBSD_4_7:1.119.0.2
	OPENBSD_4_7_BASE:1.119
	OPENBSD_4_6:1.98.0.6
	OPENBSD_4_6_BASE:1.98
	OPENBSD_4_5:1.98.0.2
	OPENBSD_4_5_BASE:1.98
	OPENBSD_4_4:1.94.0.2
	OPENBSD_4_4_BASE:1.94
	OPENBSD_4_3:1.90.0.2
	OPENBSD_4_3_BASE:1.90
	OPENBSD_4_2:1.87.0.2
	OPENBSD_4_2_BASE:1.87
	OPENBSD_4_1:1.82.0.2
	OPENBSD_4_1_BASE:1.82
	OPENBSD_4_0:1.72.0.2
	OPENBSD_4_0_BASE:1.72
	OPENBSD_3_9:1.63.0.2
	OPENBSD_3_9_BASE:1.63
	OPENBSD_3_8:1.60.0.2
	OPENBSD_3_8_BASE:1.60
	OPENBSD_3_7:1.48.0.2
	OPENBSD_3_7_BASE:1.48
	OPENBSD_3_6:1.47.0.2
	OPENBSD_3_6_BASE:1.47
	SMP_SYNC_A:1.45
	SMP_SYNC_B:1.45
	OPENBSD_3_5:1.42.0.2
	OPENBSD_3_5_BASE:1.42
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	UBC_SYNC_A:1.38
	OPENBSD_3_3:1.37.0.2
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	UBC_SYNC_B:1.35
	UBC:1.31.0.2
	UBC_BASE:1.31
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.22.0.2
	OPENBSD_2_7_BASE:1.22
	SMP:1.21.0.2
	SMP_BASE:1.21
	kame_19991208:1.20
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.16.0.4
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.165
date	2017.05.19.08.31.43;	author sf;	state Exp;
branches;
next	1.164;
commitid	n7nn8wgZdQ89x62P;

1.164
date	2016.03.10.13.56.14;	author krw;	state Exp;
branches;
next	1.163;
commitid	1lzwtVyYzQ8tyf5s;

1.163
date	2015.06.07.19.13.27;	author krw;	state Exp;
branches;
next	1.162;
commitid	MxUWuiPFtM1nRYxm;

1.162
date	2014.09.09.20.30.08;	author dlg;	state Exp;
branches;
next	1.161;
commitid	s5NR8h94qcWZ2iYv;

1.161
date	2014.04.22.07.29.11;	author dlg;	state Exp;
branches;
next	1.160;

1.160
date	2014.01.31.02.53.41;	author dlg;	state Exp;
branches;
next	1.159;

1.159
date	2014.01.27.23.44.39;	author dlg;	state Exp;
branches;
next	1.158;

1.158
date	2014.01.18.02.42.31;	author dlg;	state Exp;
branches;
next	1.157;

1.157
date	2013.09.27.11.43.19;	author krw;	state Exp;
branches;
next	1.156;

1.156
date	2013.08.29.02.54.37;	author dlg;	state Exp;
branches;
next	1.155;

1.155
date	2013.08.26.01.37.13;	author dlg;	state Exp;
branches;
next	1.154;

1.154
date	2013.08.25.23.31.39;	author dlg;	state Exp;
branches;
next	1.153;

1.153
date	2013.06.11.16.42.17;	author deraadt;	state Exp;
branches;
next	1.152;

1.152
date	2013.03.28.16.55.27;	author deraadt;	state Exp;
branches;
next	1.151;

1.151
date	2013.03.04.00.41.54;	author dlg;	state Exp;
branches;
next	1.150;

1.150
date	2012.07.01.01.41.13;	author krw;	state Exp;
branches;
next	1.149;

1.149
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.148;

1.148
date	2011.07.09.00.34.59;	author matthew;	state Exp;
branches;
next	1.147;

1.147
date	2011.07.06.00.45.52;	author matthew;	state Exp;
branches;
next	1.146;

1.146
date	2011.07.05.21.39.56;	author matthew;	state Exp;
branches;
next	1.145;

1.145
date	2011.06.15.01.10.05;	author dlg;	state Exp;
branches;
next	1.144;

1.144
date	2011.04.06.15.16.54;	author dlg;	state Exp;
branches;
next	1.143;

1.143
date	2011.04.05.14.25.42;	author dlg;	state Exp;
branches;
next	1.142;

1.142
date	2010.12.24.02.45.33;	author krw;	state Exp;
branches;
next	1.141;

1.141
date	2010.10.12.00.53.32;	author krw;	state Exp;
branches;
next	1.140;

1.140
date	2010.09.20.00.19.47;	author dlg;	state Exp;
branches;
next	1.139;

1.139
date	2010.09.17.23.19.02;	author dlg;	state Exp;
branches;
next	1.138;

1.138
date	2010.09.14.01.39.44;	author dlg;	state Exp;
branches;
next	1.137;

1.137
date	2010.09.08.00.58.05;	author dlg;	state Exp;
branches;
next	1.136;

1.136
date	2010.08.25.00.31.35;	author dlg;	state Exp;
branches;
next	1.135;

1.135
date	2010.07.27.04.41.56;	author matthew;	state Exp;
branches;
next	1.134;

1.134
date	2010.07.27.04.17.10;	author dlg;	state Exp;
branches;
next	1.133;

1.133
date	2010.07.24.04.01.52;	author matthew;	state Exp;
branches;
next	1.132;

1.132
date	2010.07.22.00.31.06;	author krw;	state Exp;
branches;
next	1.131;

1.131
date	2010.07.13.00.30.30;	author krw;	state Exp;
branches;
next	1.130;

1.130
date	2010.07.01.05.11.18;	author krw;	state Exp;
branches;
next	1.129;

1.129
date	2010.07.01.03.20.39;	author matthew;	state Exp;
branches;
next	1.128;

1.128
date	2010.06.27.03.34.29;	author matthew;	state Exp;
branches;
next	1.127;

1.127
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.126;

1.126
date	2010.06.14.10.03.34;	author thib;	state Exp;
branches;
next	1.125;

1.125
date	2010.05.24.06.57.09;	author dlg;	state Exp;
branches;
next	1.124;

1.124
date	2010.04.17.00.51.13;	author dlg;	state Exp;
branches;
next	1.123;

1.123
date	2010.04.16.09.52.04;	author dlg;	state Exp;
branches;
next	1.122;

1.122
date	2010.04.16.09.51.30;	author dlg;	state Exp;
branches;
next	1.121;

1.121
date	2010.04.06.00.58.00;	author dlg;	state Exp;
branches;
next	1.120;

1.120
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.119;

1.119
date	2010.01.15.05.50.31;	author krw;	state Exp;
branches;
next	1.118;

1.118
date	2010.01.14.00.32.46;	author krw;	state Exp;
branches;
next	1.117;

1.117
date	2010.01.04.00.45.58;	author dlg;	state Exp;
branches;
next	1.116;

1.116
date	2010.01.01.06.30.27;	author dlg;	state Exp;
branches;
next	1.115;

1.115
date	2009.12.06.17.24.28;	author krw;	state Exp;
branches;
next	1.114;

1.114
date	2009.12.06.09.35.16;	author dlg;	state Exp;
branches;
next	1.113;

1.113
date	2009.12.01.01.50.35;	author dlg;	state Exp;
branches;
next	1.112;

1.112
date	2009.12.01.01.40.02;	author dlg;	state Exp;
branches;
next	1.111;

1.111
date	2009.11.22.20.16.43;	author krw;	state Exp;
branches;
next	1.110;

1.110
date	2009.11.22.20.09.53;	author krw;	state Exp;
branches;
next	1.109;

1.109
date	2009.11.12.06.20.27;	author dlg;	state Exp;
branches;
next	1.108;

1.108
date	2009.11.10.10.18.59;	author dlg;	state Exp;
branches;
next	1.107;

1.107
date	2009.11.10.10.13.08;	author dlg;	state Exp;
branches;
next	1.106;

1.106
date	2009.11.05.03.33.52;	author marco;	state Exp;
branches;
next	1.105;

1.105
date	2009.10.23.01.02.29;	author dlg;	state Exp;
branches;
next	1.104;

1.104
date	2009.10.22.11.56.32;	author dlg;	state Exp;
branches;
next	1.103;

1.103
date	2009.10.20.00.19.24;	author dlg;	state Exp;
branches;
next	1.102;

1.102
date	2009.10.14.01.33.22;	author dlg;	state Exp;
branches;
next	1.101;

1.101
date	2009.09.14.00.03.28;	author dlg;	state Exp;
branches;
next	1.100;

1.100
date	2009.08.13.19.49.31;	author dlg;	state Exp;
branches;
next	1.99;

1.99
date	2009.08.09.12.47.23;	author dlg;	state Exp;
branches;
next	1.98;

1.98
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.97;

1.97
date	2008.11.10.18.04.41;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2008.11.09.17.01.10;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2008.09.12.11.14.04;	author miod;	state Exp;
branches;
next	1.94;

1.94
date	2008.07.22.01.01.31;	author dlg;	state Exp;
branches;
next	1.93;

1.93
date	2008.06.21.21.11.34;	author krw;	state Exp;
branches;
next	1.92;

1.92
date	2008.06.14.01.57.51;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2008.06.13.04.27.08;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2007.12.29.00.45.26;	author dlg;	state Exp;
branches;
next	1.89;

1.89
date	2007.11.26.15.40.51;	author dlg;	state Exp;
branches;
next	1.88;

1.88
date	2007.11.25.22.28.54;	author dlg;	state Exp;
branches;
next	1.87;

1.87
date	2007.06.23.19.19.49;	author krw;	state Exp;
branches;
next	1.86;

1.86
date	2007.05.31.21.53.02;	author tedu;	state Exp;
branches;
next	1.85;

1.85
date	2007.05.31.18.21.44;	author dlg;	state Exp;
branches;
next	1.84;

1.84
date	2007.04.10.17.47.56;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2007.04.03.04.47.59;	author dlg;	state Exp;
branches;
next	1.82;

1.82
date	2006.12.12.02.44.36;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.80;

1.80
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.79;

1.79
date	2006.11.28.13.40.55;	author dlg;	state Exp;
branches;
next	1.78;

1.78
date	2006.11.26.11.15.22;	author dlg;	state Exp;
branches;
next	1.77;

1.77
date	2006.11.26.09.29.07;	author dlg;	state Exp;
branches;
next	1.76;

1.76
date	2006.10.21.07.36.15;	author dlg;	state Exp;
branches;
next	1.75;

1.75
date	2006.10.07.23.40.07;	author beck;	state Exp;
branches;
next	1.74;

1.74
date	2006.10.02.09.06.26;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2006.09.22.00.33.41;	author dlg;	state Exp;
branches;
next	1.72;

1.72
date	2006.07.29.02.40.45;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2006.07.23.14.34.55;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2006.07.22.18.03.07;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2006.07.13.11.46.16;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.11.21.55.46;	author dlg;	state Exp;
branches;
next	1.67;

1.67
date	2006.07.06.00.41.37;	author dlg;	state Exp;
branches;
next	1.66;

1.66
date	2006.06.20.00.58.56;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.31.19.43.56;	author jason;	state Exp;
branches;
next	1.64;

1.64
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2005.12.02.16.24.08;	author marco;	state Exp;
branches;
next	1.62;

1.62
date	2005.11.13.02.39.45;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2005.09.11.17.34.27;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2005.06.24.23.39.18;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2005.06.23.00.31.44;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2005.06.05.21.27.07;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2005.06.03.15.50.10;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2005.06.03.15.24.05;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.28.06.16.33;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.25.21.39.08;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2005.05.25.20.52.41;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2005.05.14.00.20.43;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2005.04.27.23.54.44;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2005.04.06.02.51.13;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2005.04.05.12.13.16;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2004.11.30.19.28.37;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.31.11.31.30;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2004.06.22.00.50.57;	author marco;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.17.23.57.51;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.09.05.33.59;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2004.04.18.00.49.29;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2004.03.10.01.37.40;	author krw;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2004.02.21.00.47.42;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.14.02.00.41;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2003.05.18.16.06.35;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.16.19.54.05;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.20.04.02.06;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2002.12.30.21.50.28;	author grange;	state Exp;
branches;
next	1.35;

1.35
date	2002.08.03.08.55.35;	author pvalchev;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.27.23.42.40;	author tdeval;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.07.19.04.46;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2001.10.26.10.50.26;	author krw;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2001.10.08.01.50.48;	author drahn;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.25.19.29.16;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.18.02.24.02;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2001.06.22.14.35.43;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2001.04.30.21.21.54;	author csapuntz;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.23.08.55.35;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2000.11.20.07.34.51;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.06.03.37.10;	author mjacob;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.08.19.19.33;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	99.12.16.05.17.36;	author mjacob;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	99.11.22.12.55.16;	author mjacob;	state Exp;
branches;
next	1.19;

1.19
date	99.07.25.07.09.19;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	99.07.20.06.21.59;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	99.07.18.22.49.41;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	98.08.04.22.35.05;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.02.16.21.23.26;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.09.05.05.56.50;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.08.22.04.43.26;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.04.14.04.09.15;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	97.01.18.16.18.32;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	97.01.16.14.23.33;	author maja;	state Exp;
branches;
next	1.9;

1.9
date	97.01.15.05.50.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.10.31.01.09.25;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.08.11.23.26.04;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.06.10.00.43.59;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.31.06;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.02.28.53;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.01.14.21.44.28;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.01.10.19.08.07;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches;
next	;

1.21.2.1
date	2001.05.14.22.44.59;	author niklas;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2001.07.04.11.00.06;	author niklas;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.21.2.5;

1.21.2.5
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.21.2.6;

1.21.2.6
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.21.2.7;

1.21.2.7
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.21.2.8;

1.21.2.8
date	2004.02.19.11.01.30;	author niklas;	state Exp;
branches;
next	1.21.2.9;

1.21.2.9
date	2004.06.05.23.13.08;	author niklas;	state Exp;
branches;
next	;

1.31.2.1
date	2002.01.31.22.55.48;	author niklas;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2002.06.11.03.32.13;	author art;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2003.05.19.22.28.21;	author tedu;	state Exp;
branches;
next	;

1.42.2.1
date	2004.04.30.22.07.37;	author brad;	state Exp;
branches;
next	;


desc
@@


1.165
log
@Add some comments about the assumptions of the scsi mid layer

ok krw@@
@
text
@/*	$OpenBSD: scsiconf.h,v 1.164 2016/03/10 13:56:14 krw Exp $	*/
/*	$NetBSD: scsiconf.h,v 1.35 1997/04/02 02:29:38 mycroft Exp $	*/

/*
 * Copyright (c) 1993, 1994, 1995 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Originally written by Julian Elischer (julian@@tfs.com)
 * for TRW Financial Systems for use under the MACH(2.5) operating system.
 *
 * TRW Financial Systems, in accordance with their agreement with Carnegie
 * Mellon University, makes this software available to CMU to distribute
 * or use in any manner that they see fit as long as this message is kept with
 * the software. For this reason TFS also grants any other persons or
 * organisations permission to use or modify this software.
 *
 * TFS supplies this software to be publicly redistributed
 * on the understanding that TFS is not responsible for the correct
 * functioning of this software in any circumstances.
 *
 * Ported to run under 386BSD by Julian Elischer (julian@@tfs.com) Sept 1992
 */

#ifndef	SCSI_SCSICONF_H
#define SCSI_SCSICONF_H

#include <sys/queue.h>
#include <sys/timeout.h>
#include <sys/mutex.h>
#include <scsi/scsi_debug.h>

static __inline void _lto2b(u_int32_t val, u_int8_t *bytes);
static __inline void _lto3b(u_int32_t val, u_int8_t *bytes);
static __inline void _lto4b(u_int32_t val, u_int8_t *bytes);
static __inline void _lto8b(u_int64_t val, u_int8_t *bytes);
static __inline u_int32_t _2btol(u_int8_t *bytes);
static __inline u_int32_t _3btol(u_int8_t *bytes);
static __inline u_int32_t _4btol(u_int8_t *bytes);
static __inline u_int64_t _5btol(u_int8_t *bytes);
static __inline u_int64_t _8btol(u_int8_t *bytes);

static __inline void
_lto2b(u_int32_t val, u_int8_t *bytes)
{

	bytes[0] = (val >> 8) & 0xff;
	bytes[1] = val & 0xff;
}

static __inline void
_lto3b(u_int32_t val, u_int8_t *bytes)
{

	bytes[0] = (val >> 16) & 0xff;
	bytes[1] = (val >> 8) & 0xff;
	bytes[2] = val & 0xff;
}

static __inline void
_lto4b(u_int32_t val, u_int8_t *bytes)
{

	bytes[0] = (val >> 24) & 0xff;
	bytes[1] = (val >> 16) & 0xff;
	bytes[2] = (val >> 8) & 0xff;
	bytes[3] = val & 0xff;
}

static __inline void
_lto8b(u_int64_t val, u_int8_t *bytes)
{

	bytes[0] = (val >> 56) & 0xff;
	bytes[1] = (val >> 48) & 0xff;
	bytes[2] = (val >> 40) & 0xff;
	bytes[3] = (val >> 32) & 0xff;
	bytes[4] = (val >> 24) & 0xff;
	bytes[5] = (val >> 16) & 0xff;
	bytes[6] = (val >> 8) & 0xff;
	bytes[7] = val & 0xff;
}

static __inline u_int32_t
_2btol(u_int8_t *bytes)
{
	u_int32_t rv;

	rv = (bytes[0] << 8) | bytes[1];
	return (rv);
}

static __inline u_int32_t
_3btol(u_int8_t *bytes)
{
	u_int32_t rv;

	rv = (bytes[0] << 16) | (bytes[1] << 8) | bytes[2];
	return (rv);
}

static __inline u_int32_t
_4btol(u_int8_t *bytes)
{
	u_int32_t rv;

	rv = (bytes[0] << 24) | (bytes[1] << 16) |
	    (bytes[2] << 8) | bytes[3];
	return (rv);
}

static __inline u_int64_t
_5btol(u_int8_t *bytes)
{
	u_int64_t rv;

	rv = ((u_int64_t)bytes[0] << 32) |
	     ((u_int64_t)bytes[1] << 24) |
	     ((u_int64_t)bytes[2] << 16) |
	     ((u_int64_t)bytes[3] << 8) |
	     (u_int64_t)bytes[4];
	return (rv);
}

static __inline u_int64_t
_8btol(u_int8_t *bytes)
{
	u_int64_t rv;

	rv = (((u_int64_t)bytes[0]) << 56) |
	    (((u_int64_t)bytes[1]) << 48) |
	    (((u_int64_t)bytes[2]) << 40) |
	    (((u_int64_t)bytes[3]) << 32) |
	    (((u_int64_t)bytes[4]) << 24) |
	    (((u_int64_t)bytes[5]) << 16) |
	    (((u_int64_t)bytes[6]) << 8) |
	    ((u_int64_t)bytes[7]);
	return (rv);
}

#ifdef _KERNEL

#define DEVID_NONE	0
#define DEVID_NAA	1
#define DEVID_EUI	2
#define DEVID_T10	3
#define DEVID_SERIAL	4
#define DEVID_WWN	5

struct devid {
	u_int8_t	d_type;
	u_int8_t	d_flags;
#define DEVID_F_PRINT		(1<<0)
	u_int8_t	d_refcount;
	u_int8_t	d_len;

	/*
	 * the devid struct is basically a header, the actual id is allocated
	 * immediately after it.
	 */
};

#define DEVID_CMP(_a, _b) (					\
	(_a) != NULL && (_b) != NULL &&				\
	((_a) == (_b) ||					\
	((_a)->d_type != DEVID_NONE &&				\
	 (_a)->d_type == (_b)->d_type &&			\
	 (_a)->d_len == (_b)->d_len &&				\
	 bcmp((_a) + 1, (_b) + 1, (_a)->d_len) == 0))		\
)

struct devid *	devid_alloc(u_int8_t, u_int8_t, u_int8_t, u_int8_t *);
struct devid *	devid_copy(struct devid *);
void		devid_free(struct devid *);

/*
 * The following documentation tries to describe the relationship between the
 * various structures defined in this file:
 *
 * each adapter type has a scsi_adapter struct. This describes the adapter and
 *    identifies routines that can be called to use the adapter.
 * each existing device position (scsibus + target + lun)
 *    can be described by a scsi_link struct.
 *    Only scsi positions that actually have devices, have a scsi_link
 *    structure assigned. so in effect each device has scsi_link struct.
 *    The scsi_link structure contains information identifying both the
 *    device driver and the adapter driver for that position on that scsi bus,
 *    and can be said to 'link' the two.
 * each individual scsi bus has an array that points to all the scsi_link
 *    structs associated with that scsi bus. Slots with no device have
 *    a NULL pointer.
 * each individual device also knows the address of its own scsi_link
 *    structure.
 *
 *				-------------
 *
 * The key to all this is the scsi_link structure which associates all the
 * other structures with each other in the correct configuration.  The
 * scsi_link is the connecting information that allows each part of the
 * scsi system to find the associated other parts.
 */

struct scsi_xfer;
struct scsi_link;
struct scsibus_softc;

/*
 * Temporary hack
 */
extern int scsi_autoconf;

/*
 * These entrypoints are called by the high-end drivers to get services from
 * whatever low-end drivers they are attached to.  Each adapter type has one
 * of these statically allocated.
 */
struct scsi_adapter {
	void		(*scsi_cmd)(struct scsi_xfer *);
	void		(*scsi_minphys)(struct buf *, struct scsi_link *);
	int		(*dev_probe)(struct scsi_link *);
	void		(*dev_free)(struct scsi_link *);
	int		(*ioctl)(struct scsi_link *, u_long, caddr_t, int);
};

struct scsi_iopool;

struct scsi_iohandler {
	TAILQ_ENTRY(scsi_iohandler) q_entry;
	u_int q_state;

	struct scsi_iopool *pool;
	void (*handler)(void *, void *);
	void *cookie;
};
TAILQ_HEAD(scsi_runq, scsi_iohandler);

struct scsi_iopool {
	/* access to the IOs */
	void	*iocookie;
	/*
	 * Get an IO. This must reserve all resources that are necessary
	 * to send the transfer to the device. The resources must stay
	 * reserved during the lifetime of the IO, as the IO may be re-used
	 * without being io_put(), first.
	 */
	void	*(*io_get)(void *);
	void	 (*io_put)(void *, void *);

	/* the runqueue */
	struct scsi_runq queue;
	/* runqueue semaphore */
	u_int running;
	/* protection for the runqueue and its semaphore */
	struct mutex mtx;
};

struct scsi_xshandler {
	struct scsi_iohandler ioh; /* must be first */

	struct scsi_link *link;
	void (*handler)(struct scsi_xfer *);
};

/*
 * This structure describes the connection between an adapter driver and
 * a device driver, and is used by each to call services provided by
 * the other, and to allow generic scsi glue code to call these services
 * as well.
 */
struct scsi_link {
	SLIST_ENTRY(scsi_link)	bus_list;

	u_int		state;
#define SDEV_S_WAITING		(1<<0)
#define SDEV_S_DYING		(1<<1)

	u_int8_t scsibus;		/* the Nth scsibus */
	u_int8_t luns;
	u_int16_t target;		/* targ of this dev */
	u_int16_t lun;			/* lun of this dev */
	u_int16_t openings;		/* available operations per lun */
	u_int64_t port_wwn;		/* world wide name of port */
	u_int64_t node_wwn;		/* world wide name of node */
	u_int16_t adapter_target;	/* what are we on the scsi bus */
	u_int16_t adapter_buswidth;	/* 8 (regular) or 16 (wide). (0 becomes 8) */
	u_int16_t flags;		/* flags that all devices have */
#define	SDEV_REMOVABLE		0x0001	/* media is removable */
#define	SDEV_MEDIA_LOADED	0x0002	/* device figures are still valid */
#define	SDEV_READONLY		0x0004	/* device is read-only */
#define	SDEV_OPEN		0x0008	/* at least 1 open session */
#define	SDEV_DBX		0x00f0	/* debugging flags (scsi_debug.h) */
#define	SDEV_EJECTING		0x0100	/* eject on device close */
#define	SDEV_ATAPI		0x0200	/* device is ATAPI */
#define	SDEV_2NDBUS		0x0400	/* device is a 'second' bus device */
#define SDEV_UMASS		0x0800	/* device is UMASS SCSI */
#define SDEV_VIRTUAL		0x1000	/* device is virtualised on the hba */
#define SDEV_OWN_IOPL		0x2000	/* scsibus */
	u_int16_t quirks;		/* per-device oddities */
#define	SDEV_AUTOSAVE		0x0001	/* do implicit SAVEDATAPOINTER on disconnect */
#define	SDEV_NOSYNC		0x0002	/* does not grok SDTR */
#define	SDEV_NOWIDE		0x0004	/* does not grok WDTR */
#define	SDEV_NOTAGS		0x0008	/* lies about having tagged queueing */
#define	SDEV_NOSYNCCACHE	0x0100	/* no SYNCHRONIZE_CACHE */
#define	ADEV_NOSENSE		0x0200	/* No request sense - ATAPI */
#define	ADEV_LITTLETOC		0x0400	/* little-endian TOC - ATAPI */
#define	ADEV_NOCAPACITY		0x0800	/* no READ CD CAPACITY */
#define	ADEV_NODOORLOCK		0x2000	/* can't lock door */
#define SDEV_ONLYBIG		0x4000  /* always use READ_BIG and WRITE_BIG */
	int	(*interpret_sense)(struct scsi_xfer *);
	void	*device_softc;		/* needed for call to foo_start */
	struct	scsi_adapter *adapter;	/* adapter entry points etc. */
	void	*adapter_softc;		/* needed for call to foo_scsi_cmd */
	struct	scsibus_softc *bus;	/* link to the scsibus we're on */
	struct	scsi_inquiry_data inqdata; /* copy of INQUIRY data from probe */
	struct  devid *id;

	struct	scsi_runq queue;
	u_int	running;
	u_short	pending;

	struct	scsi_iopool *pool;
};

int	scsiprint(void *, const char *);

/*
 * This describes matching information for scsi_inqmatch().  The more things
 * match, the higher the configuration priority.
 */
struct scsi_inquiry_pattern {
	u_int8_t type;
	int removable;
	char *vendor;
	char *product;
	char *revision;
};

struct scsibus_attach_args {
	struct scsi_link *saa_sc_link;
};

/*
 * One of these is allocated and filled in for each scsi bus.
 * It holds pointers to allow the scsi bus to get to the driver
 * that is running each LUN on the bus.
 * It also has a template entry which is the prototype struct
 * supplied by the adapter driver.  This is used to initialise
 * the others, before they have the rest of the fields filled in.
 */
struct scsibus_softc {
	struct device sc_dev;
	struct scsi_link *adapter_link;	/* prototype supplied by adapter */
	SLIST_HEAD(, scsi_link) sc_link_list;
	u_int16_t sc_buswidth;
};

/*
 * This is used to pass information from the high-level configuration code
 * to the device-specific drivers.
 */
struct scsi_attach_args {
	struct scsi_link *sa_sc_link;
	struct scsi_inquiry_data *sa_inqbuf;
};

/*
 * Each scsi transaction is fully described by one of these structures.
 * It includes information about the source of the command and also the
 * device and adapter for which the command is destined.
 * (via the scsi_link structure)
 */
struct scsi_xfer {
	SIMPLEQ_ENTRY(scsi_xfer) xfer_list;
	int	flags;
	struct	scsi_link *sc_link;	/* all about our device and adapter */
	int	retries;		/* the number of times to retry */
	int	timeout;		/* in milliseconds */
	struct	scsi_generic *cmd;	/* The scsi command to execute */
	int	cmdlen;			/* how long it is */
	u_char	*data;			/* dma address OR a uio address */
	int	datalen;		/* data len (blank if uio)    */
	size_t	resid;			/* how much buffer was not touched */
	int	error;			/* an error value	*/
	struct	buf *bp;		/* If we need to associate with a buf */
	struct	scsi_sense_data	sense;	/* 18 bytes*/
	u_int8_t status;		/* SCSI status */
	struct	scsi_generic cmdstore;	/* stash the command in here */
	/*
	 * timeout structure for hba's to use for a command
	 */
	struct timeout stimeout;
	void *cookie;
	void (*done)(struct scsi_xfer *);

	void *io;			/* adapter io resource */
};
SIMPLEQ_HEAD(scsi_xfer_list, scsi_xfer);

/*
 * Per-request Flag values
 */
#define	SCSI_NOSLEEP	0x00001	/* don't sleep */
#define	SCSI_POLL	0x00002	/* poll for completion */
#define	SCSI_AUTOCONF	0x00003	/* shorthand for SCSI_POLL | SCSI_NOSLEEP */
#define	ITSDONE		0x00008	/* the transfer is as done as it gets	*/
#define	SCSI_SILENT	0x00020	/* don't announce NOT READY or MEDIA CHANGE */
#define	SCSI_IGNORE_NOT_READY		0x00040	/* ignore NOT READY */
#define	SCSI_IGNORE_MEDIA_CHANGE	0x00080	/* ignore MEDIA CHANGE */
#define	SCSI_IGNORE_ILLEGAL_REQUEST	0x00100	/* ignore ILLEGAL REQUEST */
#define	SCSI_RESET	0x00200	/* Reset the device in question		*/
#define	SCSI_DATA_IN	0x00800	/* expect data to come INTO memory	*/
#define	SCSI_DATA_OUT	0x01000	/* expect data to flow OUT of memory	*/
#define	SCSI_TARGET	0x02000	/* This defines a TARGET mode op.	*/
#define	SCSI_ESCAPE	0x04000	/* Escape operation			*/
#define	SCSI_PRIVATE	0xf0000	/* private to each HBA flags */

/*
 * Escape op-codes.  This provides an extensible setup for operations
 * that are not scsi commands.  They are intended for modal operations.
 */

#define SCSI_OP_TARGET	0x0001
#define	SCSI_OP_RESET	0x0002
#define	SCSI_OP_BDINFO	0x0003

/*
 * Error values an adapter driver may return
 */
#define XS_NOERROR	0	/* there is no error, (sense is invalid)  */
#define XS_SENSE	1	/* Check the returned sense for the error */
#define	XS_DRIVER_STUFFUP 2	/* Driver failed to perform operation	  */
#define XS_SELTIMEOUT	3	/* The device timed out.. turned off?	  */
#define XS_TIMEOUT	4	/* The Timeout reported was caught by SW  */
#define XS_BUSY		5	/* The device busy, try again later?	  */
#define XS_SHORTSENSE   6	/* Check the ATAPI sense for the error */
#define XS_RESET	8	/* bus was reset; possible retry command  */
#define XS_NO_CCB	9	/* device should requeue io and retry */

/*
 * Possible retries for scsi_test_unit_ready()
 */
#define TEST_READY_RETRIES	5

/*
 * Possible retries for most SCSI commands.
 */
#define SCSI_RETRIES		4

const void *scsi_inqmatch(struct scsi_inquiry_data *, const void *, int,
	    int, int *);

void	scsi_init(void);
int	scsi_test_unit_ready(struct scsi_link *, int, int);
int	scsi_inquire(struct scsi_link *, struct scsi_inquiry_data *, int);
int	scsi_inquire_vpd(struct scsi_link *, void *, u_int, u_int8_t, int);
void	scsi_init_inquiry(struct scsi_xfer *, u_int8_t, u_int8_t,
	    void *, size_t);
int	scsi_prevent(struct scsi_link *, int, int);
int	scsi_start(struct scsi_link *, int, int);
int	scsi_mode_sense(struct scsi_link *, int, int, struct scsi_mode_header *,
	    size_t, int, int);
int	scsi_mode_sense_big(struct scsi_link *, int, int,
	    struct scsi_mode_header_big *, size_t, int, int);
void *	scsi_mode_sense_page(struct scsi_mode_header *, int);
void *	scsi_mode_sense_big_page(struct scsi_mode_header_big *, int);
int	scsi_do_mode_sense(struct scsi_link *, int,
	    union scsi_mode_sense_buf *, void **, u_int32_t *, u_int64_t *,
	    u_int32_t *, int, int, int *);
int	scsi_mode_select(struct scsi_link *, int, struct scsi_mode_header *,
	    int, int);
int	scsi_mode_select_big(struct scsi_link *, int,
	    struct scsi_mode_header_big *, int, int);
void	scsi_done(struct scsi_xfer *);
int	scsi_do_ioctl(struct scsi_link *, u_long, caddr_t, int);
void	sc_print_addr(struct scsi_link *);
int	scsi_report_luns(struct scsi_link *, int,
	    struct scsi_report_luns_data *, u_int32_t, int, int);
void	scsi_minphys(struct buf *, struct scsi_link *);
int	scsi_interpret_sense(struct scsi_xfer *);

void	scsi_xs_show(struct scsi_xfer *);
void	scsi_print_sense(struct scsi_xfer *);
void	scsi_show_mem(u_char *, int);
void	scsi_strvis(u_char *, u_char *, int);
int	scsi_delay(struct scsi_xfer *, int);

int	scsi_probe(struct scsibus_softc *, int, int);
int	scsi_probe_bus(struct scsibus_softc *);
int	scsi_probe_target(struct scsibus_softc *, int);
int	scsi_probe_lun(struct scsibus_softc *, int, int);

int	scsi_detach(struct scsibus_softc *, int, int, int);
int	scsi_detach_bus(struct scsibus_softc *, int);
int	scsi_detach_target(struct scsibus_softc *, int, int);
int	scsi_detach_lun(struct scsibus_softc *, int, int, int);

int	scsi_req_probe(struct scsibus_softc *, int, int);
int	scsi_req_detach(struct scsibus_softc *, int, int, int);

int	scsi_activate(struct scsibus_softc *, int, int, int);

struct scsi_link *	scsi_get_link(struct scsibus_softc *, int, int);
void			scsi_add_link(struct scsibus_softc *,
			    struct scsi_link *);
void			scsi_remove_link(struct scsibus_softc *,
			    struct scsi_link *);

extern const u_int8_t version_to_spc[];
#define SCSISPC(x)	(version_to_spc[(x) & SID_ANSII])

struct scsi_xfer *	scsi_xs_get(struct scsi_link *, int);
void			scsi_xs_exec(struct scsi_xfer *);
int			scsi_xs_sync(struct scsi_xfer *);
void			scsi_xs_put(struct scsi_xfer *);
#ifdef SCSIDEBUG
void			scsi_sense_print_debug(struct scsi_xfer *);
#endif

/*
 * iopool stuff
 */
void	scsi_iopool_init(struct scsi_iopool *, void *,
	    void *(*)(void *), void (*)(void *, void *));
void	scsi_iopool_run(struct scsi_iopool *);
void	scsi_iopool_destroy(struct scsi_iopool *);
void	scsi_link_shutdown(struct scsi_link *);

void *	scsi_io_get(struct scsi_iopool *, int);
void	scsi_io_put(struct scsi_iopool *, void *);

/*
 * default io allocator.
 */
#define SCSI_IOPOOL_POISON ((void *)0x5c5)
void *	scsi_default_get(void *);
void	scsi_default_put(void *, void *);

/*
 * io handler interface
 */
void	scsi_ioh_set(struct scsi_iohandler *, struct scsi_iopool *,
	    void (*)(void *, void *), void *);
int	scsi_ioh_add(struct scsi_iohandler *);
int	scsi_ioh_del(struct scsi_iohandler *);

void	scsi_xsh_set(struct scsi_xshandler *, struct scsi_link *,
	    void (*)(struct scsi_xfer *));
int	scsi_xsh_add(struct scsi_xshandler *);
int	scsi_xsh_del(struct scsi_xshandler *);

/*
 * utility functions
 */
int	scsi_pending_start(struct mutex *, u_int *);
int	scsi_pending_finish(struct mutex *, u_int *);

/*
 * Utility functions for SCSI HBA emulation.
 */
void	scsi_cmd_rw_decode(struct scsi_generic *, u_int64_t *, u_int32_t *);

#endif /* _KERNEL */
#endif /* SCSI_SCSICONF_H */
@


1.164
log
@Enforce some naming sanity. Stop using 'sc_link' to mean two different
things by renaming the field 'SLIST_HEAD(, scsi_link) sc_link' to
'sc_link_list' in struct scsibus_softc.  Use 'sb' as the short name
for scsibus_softc variables.

Impetus from & ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.163 2015/06/07 19:13:27 krw Exp $	*/
d265 6
d306 1
a306 1
	u_int16_t openings;		/* available operations */
@


1.163
log
@More damned eye searing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.162 2014/09/09 20:30:08 dlg Exp $	*/
d372 1
a372 1
	SLIST_HEAD(, scsi_link) sc_link;
@


1.162
log
@remove the scsi_task() wrapper around workq_add_task now that nothing
uses it. dont need to include workq.h anymore here either now.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.161 2014/04/22 07:29:11 dlg Exp $	*/
d267 1
a267 1
	
d306 2
a307 2
#define	SDEV_REMOVABLE	 	0x0001	/* media is removable */
#define	SDEV_MEDIA_LOADED 	0x0002	/* device figures are still valid */
d309 1
a309 1
#define	SDEV_OPEN	 	0x0008	/* at least 1 open session */
@


1.161
log
@factor out the code that figures out whether you're probing or detaching
a whole bus, a target, or a specific lun on a target from the bioctl
and scsi_req paths.

i want to reuse this factored code for something claudio wants.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.160 2014/01/31 02:53:41 dlg Exp $	*/
a54 1
#include <sys/workq.h>
a469 3

#define scsi_task(_f, _a1, _a2, _fl) \
    workq_add_task(NULL, (_fl), (_f), (_a1), (_a2))
@


1.160
log
@if a device doesnt have device ids or serial numbers, try using node_wwn to
generate a devid. if its an fc device this is good enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.159 2014/01/27 23:44:39 dlg Exp $	*/
d510 1
d515 1
@


1.159
log
@poison the io "allocated" by the default pool allocator so any attempt to
use it should cause a fault.

based on discussion with miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.158 2014/01/18 02:42:31 dlg Exp $	*/
d174 1
@


1.158
log
@rename scsi_ioh_runqueue to scsi_iopool_run, and make it available
outside scsi_base.c.

this will allow adapters to restrict access to iopool resources
based on some state, and then kick the pending requests on the pool
when the state comes good again.

ive been avoiding this for a long time, but it is the least worst
way to deal with some uses of XS_NO_CCB.

discussion with kettenis@@ helped me decide this was right.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.157 2013/09/27 11:43:19 krw Exp $	*/
d554 1
@


1.157
log
@scsi_size() is now used only by cd(4). So move it from scsi_base.c
to cd.c and call it cd_size(), like sd_size() lives in sd.c.

Tweak some daddr_t variables to u_int64_t on the way, when they are
for disk sector numbers, not 512-byte block numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.156 2013/08/29 02:54:37 dlg Exp $	*/
d544 1
@


1.156
log
@rename scsi_sem_{enter,leave} to scsi_pending_{start,finish}. these are
the wrappers around handling of pending work, theyre not semaphores.

names from tedu@@
ok krw@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.155 2013/08/26 01:37:13 dlg Exp $	*/
a474 1
daddr_t scsi_size(struct scsi_link *, int, u_int32_t *);
@


1.155
log
@make scsi_{xsh,ioh}_{add,del} return whether they moved something
on or off the queues so things calling them can tell if something
is or isnt going to happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.154 2013/08/25 23:31:39 dlg Exp $	*/
d573 2
a574 2
int	scsi_sem_enter(struct mutex *, u_int *);
int	scsi_sem_leave(struct mutex *, u_int *);
@


1.154
log
@move the prototypes of scsi_sem_{enter,leave} into a header so things
other than scsi_base.c can use them.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.153 2013/06/11 16:42:17 deraadt Exp $	*/
d562 2
a563 2
void	scsi_ioh_add(struct scsi_iohandler *);
void	scsi_ioh_del(struct scsi_iohandler *);
d567 2
a568 2
void	scsi_xsh_add(struct scsi_xshandler *);
void	scsi_xsh_del(struct scsi_xshandler *);
@


1.153
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.152 2013/03/28 16:55:27 deraadt Exp $	*/
d569 6
@


1.152
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.151 2013/03/04 00:41:54 dlg Exp $	*/
d475 1
a475 1
daddr64_t scsi_size(struct scsi_link *, int, u_int32_t *);
@


1.151
log
@replace the LIST_ENTRY in scsi_xfer with a SIMPLEQ_ENTRY. the things that
use it want something they can add to the end of they do horrible things
to be able to do that with the LIST_ENTRY.

this makes those horrible things a bit less horrible, and makes it easier
to use lists of scsi_xfers in other things.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.150 2012/07/01 01:41:13 krw Exp $	*/
a56 1
#include <machine/cpu.h>
@


1.150
log
@Nuke unused _[23]ltol() and _lto[23]l() inline functions. Move
_4ltol() and _lto4l() to bha, the only place they were used.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.149 2011/07/17 22:46:48 matthew Exp $	*/
d393 1
a393 1
	LIST_ENTRY(scsi_xfer) free_list;
d417 1
@


1.149
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.148 2011/07/09 00:34:59 matthew Exp $	*/
a69 7
static __inline void _lto2l(u_int32_t val, u_int8_t *bytes);
static __inline void _lto3l(u_int32_t val, u_int8_t *bytes);
static __inline void _lto4l(u_int32_t val, u_int8_t *bytes);
static __inline u_int32_t _2ltol(u_int8_t *bytes);
static __inline u_int32_t _3ltol(u_int8_t *bytes);
static __inline u_int32_t _4ltol(u_int8_t *bytes);

a164 55
	return (rv);
}

static __inline void
_lto2l(u_int32_t val, u_int8_t *bytes)
{

	bytes[0] = val & 0xff;
	bytes[1] = (val >> 8) & 0xff;
}

static __inline void
_lto3l(u_int32_t val, u_int8_t *bytes)
{

	bytes[0] = val & 0xff;
	bytes[1] = (val >> 8) & 0xff;
	bytes[2] = (val >> 16) & 0xff;
}

static __inline void
_lto4l(u_int32_t val, u_int8_t *bytes)
{

	bytes[0] = val & 0xff;
	bytes[1] = (val >> 8) & 0xff;
	bytes[2] = (val >> 16) & 0xff;
	bytes[3] = (val >> 24) & 0xff;
}

static __inline u_int32_t
_2ltol(u_int8_t *bytes)
{
	u_int32_t rv;

	rv = bytes[0] | (bytes[1] << 8);
	return (rv);
}

static __inline u_int32_t
_3ltol(u_int8_t *bytes)
{
	u_int32_t rv;

	rv = bytes[0] | (bytes[1] << 8) | (bytes[2] << 16);
	return (rv);
}

static __inline u_int32_t
_4ltol(u_int8_t *bytes)
{
	u_int32_t rv;

	rv = bytes[0] | (bytes[1] << 8) |
	    (bytes[2] << 16) | (bytes[3] << 24);
@


1.148
log
@Add SCSI_NO_ADAPTER_TARGET as a value for adapters to set
adapter_target to if their adapter isn't addressable on the bus.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.147 2011/07/06 00:45:52 matthew Exp $	*/
d356 1
d359 1
a405 2
#define	SCSI_NO_ADAPTER_TARGET	((u_int16_t) -1)

a421 2
	u_int16_t saa_targets;
	u_int16_t saa_luns;
d436 1
a436 2
	u_int16_t sc_targets;
	u_int16_t sc_luns;
@


1.147
log
@Add {sc,saa}_{targets,luns} to scsibus_softc and scsibus_attach_args.
These will be used to replace scsi_link's adapter_buswidth and luns
fields, but for now we stay compatible with existing SCSI adapter
driver conventions while I update them to set the scsibus_attach_args
fields directly.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.146 2011/07/05 21:39:56 matthew Exp $	*/
d403 2
@


1.146
log
@Garbage collect SDEV_S_WAITING and scsi_link->scsibus now that nothing
needs either of them.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.145 2011/06/15 01:10:05 dlg Exp $	*/
d420 2
d436 2
a437 1
	u_int16_t sc_buswidth;
@


1.145
log
@factor the common bits out of code that builds scsi inquiry commands into
scsi_init_inquiry(). cut the compiled INQUIRY code over to it.

ok and tweaks from krw@@
ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.144 2011/04/06 15:16:54 dlg Exp $	*/
a355 1
#define SDEV_S_WAITING		(1<<0)
a357 1
	u_int8_t scsibus;		/* the Nth scsibus */
@


1.144
log
@add a new "serial" devid type for scsi devices. add code to usb that fakes
it up by using the usb devices iSerial thing.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.143 2011/04/05 14:25:42 dlg Exp $	*/
d541 2
@


1.143
log
@move forward with scsi multipathing.

the big change is how paths between mpath capable devices and the
kernel are managed.

originally the midlayer would steal the links to the devices and
hide them behind mpath. all the changes an adapter made to a link
(eg activate or detach), the midlayer had to test if it was an mpath
link and then call special mpath code to handle it.

the original code also assumed that all paths behaved the same, but
the reality is that different devices have different command sets
and behaviours. figuring out which behaviour to pick and prioritising
them is basically the same job autoconf does with match and attach.

rather than special casing mpath in the midlayer and reimplimenting
autoconf, this turns paths into actual device drivers with match
and attach routines. after they figure out if the path is active,
they then give it to mpath(4) to use as a backend.

i have written drivers for symmetric access devices (sym(4)) where
all paths to the same logical unit are as good as each other,
lsi/engenio arrays (rdac(4), and emc arrays (emc(4)).

the rdac and emc drivers only detect active paths at attach time,
the do not cope if the controller changes state unless you unplug
the path and plug it in again to retest the active state. they also
do not have support for directing array failover.

operating and hoplugging has been tested with mpii(4), fc and sas
mpi(4), and iscsi via vscsi (claudio did this too).

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.142 2010/12/24 02:45:33 krw Exp $	*/
d236 1
@


1.142
log
@Have sd(4) devices check for and respect read-only information the
way st(4) does. Have both decline to open read-only devices for
anything but read-only access.

Suggestion to fail opens rather than individual i/o's from deraadt@@.

Problem USB device found and donated by chefren, who also tested
diffs. Thanks!

ok dlg@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.141 2010/10/12 00:53:32 krw Exp $	*/
a627 9

/*
 * Entrypoints for multipathing
 */
int	mpath_path_attach(struct scsi_link *);
int	mpath_path_detach(struct scsi_link *, int);

void	mpath_path_activate(struct scsi_link *);
void	mpath_path_deactivate(struct scsi_link *);
@


1.141
log
@Force openings to 1 for devices that can't do tagged i/o, i.e. more
than 1 i/o active at once.  This reduces the chances that concurrent
i/o's for such devices will confuse the device or the adapter code.
It also eliminates a reason for adapter code to maintain its own
queues.

Tweak all drivers that fake INQUIRY results to set the SID_CmdQue
flag, thus continuing to claim to be able to do tagged i/o.

Positive feedback from matthew@@ and marco@@ for an earlier version.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.140 2010/09/20 00:19:47 dlg Exp $	*/
d370 1
@


1.140
log
@bring back scsi_base.c r1.195 and scsiconf.h r1.138 now that
src/sys/dev/ata/atascsi.c r1.92 solves the problem that my scsi_link
change tickled.

tested by josh elsasser who reported the problem in pr6470
deraadt@@ is letting it in again so it can get widespread testing
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.139 2010/09/17 23:19:02 dlg Exp $	*/
d588 1
a588 1
#define SCSISPC(x)(version_to_spc[(x) & SID_ANSII])
@


1.139
log
@revert scsi_base.c r1.195 and scsiconf.h r1.138 as it screws up with some
disks in atascsi.

as reported in pr6470
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.137 2010/09/08 00:58:05 dlg Exp $	*/
d399 1
@


1.138
log
@the openings member of scsi_link is the maximum number of commands that a
scsi device can have in flight. instead of counting users of openings on
the bus by taking away from the openings value, count the number of
pending commands on the bus in a new pending variable.

this lets us know how many outstanding commands there are. we can then use
that to make sure that all commands a device has generated get completed
before detaching the device. this helps avoid resource leaks and use after
frees.

tested by me on pci ehci/umass, fc mpi, and sas mpi.
tested by jakemsr on cardbus ohci umass.
it found issues in sas mpi which were fixed as a result of this diff.
ok krw@@
@
text
@a398 1
	u_short	pending;
@


1.137
log
@activate hooks should return a value.

all from deraadt@@
tested by me with hotplugged disks on mpi(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.136 2010/08/25 00:31:35 dlg Exp $	*/
d399 1
@


1.136
log
@add scsi_iopool_destroy and scsi_link_shutdown. when a link or
device are going away, this will walk the pool and link queues and
wake up processes that are sleeping while waiting for an io or xs.
they will return NULL to the scsi_{xs,io}_get callers, which should
then check if they device is still alive. all other handlers that
are registered on the queues should be removed by their owners
before the destroy/shutdown funcs are called.

lots of help and discussion with matthew@@
ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.135 2010/07/27 04:41:56 matthew Exp $	*/
d578 1
a578 1
void	scsi_activate(struct scsibus_softc *, int, int, int);
@


1.135
log
@Add scsi_cmd_rw_decode() for decoding any SCSI READ or WRITE command,
and update atascsi(4) to make use of it.  (Other HBAs will be updated
post-release.)  Should allow for use of SATA drives with >2^32 LBAs.

ok deraadt@@, dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.134 2010/07/27 04:17:10 dlg Exp $	*/
d602 2
@


1.134
log
@the queue entry and state variables in the xsh and ioh structs are part
of a separate struct which the ioh struct includes for no good reason
anymore. just put the vars directly in the ioh.

this removes this useless abstraction.

ok krw@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.133 2010/07/24 04:01:52 matthew Exp $	*/
d633 5
@


1.133
log
@Get rid of scsi_deinit(), and change scsi_init() back to a one-time
initialization strategy, rather than pretending to do user reference
counting.  Previously, we would re-initialize the SCSI pool(9)s, which
had the fun consequence of causing sysctl(kern.pool.npools) to
infinite loop at IPL_VM.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.132 2010/07/22 00:31:06 krw Exp $	*/
a311 9
struct scsi_runq_entry {
	TAILQ_ENTRY(scsi_runq_entry) e;
	u_int state;
#define RUNQ_IDLE	0
#define RUNQ_LINKQ	1
#define RUNQ_POOLQ	3
};
TAILQ_HEAD(scsi_runq, scsi_runq_entry);

d315 2
a316 1
	struct scsi_runq_entry entry; /* must be first */
d322 1
a336 4

/*
 *
 */
@


1.132
log
@Eliminate scsi_scsi_cmd() now that ss(4) is gone and with it the
last bastardized sync and buf call through scsi_scsi_cmd(). Flatten
code to call scsi_xs_sync() directly for all commands.

Airplane typos shaken out by various.

ok dlg@@ matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.131 2010/07/13 00:30:30 krw Exp $	*/
a544 1
void	scsi_deinit(void);
@


1.131
log
@Correct comment. scsi_sense_data is now 18 bytes, not 32.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.130 2010/07/01 05:11:18 krw Exp $	*/
a565 3
int	scsi_scsi_cmd(struct scsi_link *, struct scsi_generic *,
	    int cmdlen, u_char *data_addr, int datalen, int retries,
	    int timeout, struct buf *bp, int flags);
@


1.130
log
@Die struct scsi_device! Die! Instead, save a pointer to the routine
to interpret sense errors. This is initialized to the basic
interpretation routine, and specific scsi drivers (sd/st/cd) can
replace this with their own. While here kill EJUSTRETURN dance and
make more specialized interpretation routines directly call the
basic routine if desired.

Fixes by matthew@@ to my first diff. Most original work by dlg@@.

ok matthew@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.129 2010/07/01 03:20:39 matthew Exp $	*/
d475 1
a475 1
	struct	scsi_sense_data	sense; /* 32 bytes*/
@


1.129
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.128 2010/06/27 03:34:29 matthew Exp $	*/
a268 2
 * each device type has a scsi_device struct. This describes the device and
 *    identifies routines that can be called to use the device.
a311 18
/*
 * These entry points are called by the low-end drivers to get services from
 * whatever high-end drivers they are attached to.  Each device type has one
 * of these statically allocated.
 */
struct scsi_device {
	int	(*err_handler)(struct scsi_xfer *);
			/* returns -1 to say err processing done */
	void	(*start)(void *);

	int	(*async)(void);
	void	(*done)(struct scsi_xfer *);
};

/*
 *
 */

d400 1
a400 1
	struct	scsi_device *device;	/* device entry points etc. */
d608 3
@


1.128
log
@"Believe it or not," nothing uses scsi_xfer's req_sense_length field
in any meaningful way, so just get rid of it.

ok krw@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.127 2010/06/15 04:11:34 dlg Exp $	*/
d383 2
d463 1
a463 1
	struct scsi_link ***sc_link;
d614 6
@


1.127
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.126 2010/06/14 10:03:34 thib Exp $	*/
a493 5
	/*
	 * Believe it or not, Some targets fall on the ground with
	 * anything but a certain sense length.
	 */
	int	req_sense_length;	/* Explicit request sense length */
@


1.126
log
@remove the scsi_buf_* functions as these have been
replaced by BUFQ's.

OK krw@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.125 2010/05/24 06:57:09 dlg Exp $	*/
d311 1
a311 2
	int		(*ioctl)(struct scsi_link *, u_long, caddr_t, int,
			    struct proc *);
d592 1
a592 2
int	scsi_do_ioctl(struct scsi_link *, dev_t, u_long, caddr_t,
	    int, struct proc *);
@


1.125
log
@removed prototypes for functions that were removed.

patch from matthew dempsky
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.124 2010/04/17 00:51:13 dlg Exp $	*/
a599 6

void		 scsi_buf_enqueue(struct buf *, struct buf *, struct mutex *);
struct buf	*scsi_buf_dequeue(struct buf *, struct mutex *);
void		 scsi_buf_requeue(struct buf *, struct buf *, struct mutex *);
int		 scsi_buf_canqueue(struct buf *, struct mutex *);
void		 scsi_buf_killqueue(struct buf *, struct mutex *);
@


1.124
log
@use the iopools mutex to protect the semaphore wrapping the openings
runqueue. less is more sometimes.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.123 2010/04/16 09:52:04 dlg Exp $	*/
a569 4
struct scsi_xfer *
	scsi_get_xs(struct scsi_link *, int);
void	scsi_free_xs(struct scsi_xfer *, int);
int	scsi_execute_xs(struct scsi_xfer *);
a589 1
void	scsi_user_done(struct scsi_xfer *);
@


1.123
log
@whitespace fix
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.122 2010/04/16 09:51:30 dlg Exp $	*/
a425 1
	struct	mutex mtx;
@


1.122
log
@fix an fatal flaw with iopools.

an xshandler gets put on a series of lists as it allocates different
resources, and uses the same tailq entry on each of these lists as
its only supposed to be on one of them at a time. however, it was
possible for the xshandler to be added to both at the same time,
therefore corrupting the lists and leading to a panic.

this diff moves from using separate flags for each queue an xshandler
could be on to having a single state variable that shows which one
it is on (or not on). this prevents an xshandler on the io runqueue
from being added to the openings runqueue, which in turn prevents
the list corruption.

some operations have been reordered to avoid races and complexity
in this little state machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.121 2010/04/06 00:58:00 dlg Exp $	*/
d334 1
a334 1
        TAILQ_ENTRY(scsi_runq_entry) e;
@


1.121
log
@implement a new mechanism for allocating resources on the bus.

instead of optimistically trying to use a resource by executing an
xs and then failing when there's no room for it, this puts things
that want to use the hardware on a runqueue. as resources become
available on the bus then consumers on the runqueue are popped off
and guaranteed access to the resource.

the resources are generally "ccbs" in adapter drivers, so this
abstracts a way for the midlayer to get access to them into something
called iopools.

it also provides a callback api for consumers of resources to use:
the scsi_ioh api for things that want direct access to the ccbs,
and the scsi_xsh api for things that want to issue a scsi_xfer on
the bus. these apis have been modelled on the timeout api.

scsi_xs_get and therefore scsi_scs_cmd have been cut over to using these
apis internally, so if they are allowed to sleep then can wait on the
runqueue for a resource to become available and therefore guarantee that
when executed on an adapter providing an iopool that they will succeed.

ok krw@@ beck@@ marco@@
tested by many including krw@@ beck@@ mk@@ okan@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.120 2010/03/23 01:57:20 krw Exp $	*/
d335 4
a345 1
	u_int onq;
a371 1
	u_int onq;
@


1.120
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.119 2010/01/15 05:50:31 krw Exp $	*/
d330 46
d405 1
d425 5
d507 2
d608 1
d637 28
@


1.119
log
@Abstract and merge the manual buf queue manipulating functions into
one place for easier debugging and maintenance. No intended functional
changes.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.118 2010/01/14 00:32:46 krw Exp $	*/
d307 1
a307 1
	int		(*scsi_cmd)(struct scsi_xfer *);
a313 7

/*
 * return values for scsi_cmd()
 */
#define SUCCESSFULLY_QUEUED	0
#define	COMPLETE		2
#define NO_CCB			4
@


1.118
log
@Tweak names a bit. show_mem -> scsi_show_mem, show_scsi_xs ->
scsi_xs_show.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.117 2010/01/04 00:45:58 dlg Exp $	*/
d557 5
@


1.117
log
@introduce scsi_xs_sync. this will synchronously execute a scsi_xfer
and do the appropriate sleeps, retries, error processing, and finally
returns an errno style value to the caller.

this cuts scsi_scsi_cmd, the ioctl code, sd_flush, and scsi_inquiry over
to scsi_xs_sync.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.116 2010/01/01 06:30:27 dlg Exp $	*/
d558 1
a558 1
void	show_scsi_xs(struct scsi_xfer *);
d560 1
a560 1
void	show_mem(u_char *, int);
@


1.116
log
@split the flags used in a scsi_link structure to represent its state at
runtime out into a separate state variable. only operate on the state bits
with atomic ops. introduce the DYING state so things that sleep can figure
out if they should keep going or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.114 2009/12/06 09:35:16 dlg Exp $	*/
d582 1
@


1.115
log
@Nuke SCSI_URGENT after removing its only use, in ncr53c9x.c. That use
was to try to play dangerous games with tagged queuing.

ok marco@@
@
text
@d343 4
a358 1
#define	SDEV_WAITING	 	0x0004	/* a process is waiting for this */
@


1.114
log
@SCSI_USER is deprecated. the ioctl handlers arent special with regard to
the midlayer.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.113 2009/12/01 01:50:35 dlg Exp $	*/
a476 1
#define SCSI_URGENT	0x08000	/* Urgent operation (e.g., HTAG)	*/
@


1.113
log
@properly handle all xs states that can be returned by an adapter in sd.

requested by krw@@ after spending a week munging through my code.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.112 2009/12/01 01:40:02 dlg Exp $	*/
a466 1
#define	SCSI_USER	0x00004	/* Is a user cmd, call scsi_user_done	*/
@


1.112
log
@put the midlayer changes back in.

the two issues affecting it last time are gone. the first, mishandling of
TRY_AGAIN_LATER is not relevant now that krw got rid of TRY_AGAIN_LATER.
the second, the misbehaving IBM disk was found to be a problem with siop
using ordered tags on most ops combined with the speed of the new code.

putting this in so we can move forward.

ok krw@@ "commit please" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.111 2009/11/22 20:16:43 krw Exp $	*/
d555 1
@


1.111
log
@Remove only use in the tree of ESCAPE_NOT_SUPPORTED. Which, ironically,
wasn't supported. Nuke #define of ESCAPE_NOT_SUPPORTED at the same
time.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.110 2009/11/22 20:09:53 krw Exp $	*/
d56 1
d238 10
a247 3
	int		 d_type;
	u_int		 d_len;
	u_int8_t	*d_id;
d250 7
a256 7
#define DEVID_CMP(_a, _b) (				\
	(_a) != NULL &&					\
	(_b) != NULL &&					\
	(_a)->d_type != DEVID_NONE &&			\
	(_a)->d_type == (_b)->d_type &&			\
	(_a)->d_len == (_b)->d_len &&			\
	bcmp((_a)->d_id, (_b)->d_id, (_a)->d_len) == 0	\
d259 4
a351 1
	u_int16_t active;		/* operations in progress */
d380 2
a381 1
	struct  devid id;
d457 2
d501 1
d573 2
d578 4
d587 3
@


1.110
log
@Nuke TRY_AGAIN_LATER now that no driver returns it.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.109 2009/11/12 06:20:27 dlg Exp $	*/
a307 1
#define	ESCAPE_NOT_SUPPORTED	3
@


1.109
log
@revert midlayer back to it was before i put my big rewrite in. this is
causing a weird problems on an alpha and also appears responsible for
isp(4) weirdness i havent had a chance to examine yet.

sigh, this makes me sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.106 2009/11/05 03:33:52 marco Exp $	*/
a306 1
#define TRY_AGAIN_LATER		1
@


1.108
log
@fix the NO_CCB handling i broke when working on simplifying the midlayer.

marco@@ discovered my rewrite retried commands rejected by an adapter
from a timeout, which was trivially starved by normal io going to
disks. this diff allows an xs to be marked as XS_NO_CCB, which will
cause it to be returned to the device driver to be retried as part
of the normal io queue.

tested by krw@@ marco@@ johan@@
ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.105 2009/10/23 01:02:29 dlg Exp $	*/
a55 1
#include <sys/mutex.h>
d237 3
a239 10
	u_int8_t	d_type;
	u_int8_t	d_flags;
#define DEVID_F_PRINT		(1<<0)
	u_int8_t	d_refcount;
	u_int8_t	d_len;

	/*
	 * the devid struct is basically a header, the actual id is allocated
	 * immediately after it.
	 */
d242 7
a248 7
#define DEVID_CMP(_a, _b) (					\
	(_a) != NULL && (_b) != NULL &&				\
	((_a) == (_b) ||					\
	((_a)->d_type != DEVID_NONE &&				\
	 (_a)->d_type == (_b)->d_type &&			\
	 (_a)->d_len == (_b)->d_len &&				\
	 bcmp((_a) + 1, (_b) + 1, (_a)->d_len) == 0))		\
a250 4
struct devid *	devid_alloc(u_int8_t, u_int8_t, u_int8_t, u_int8_t *);
struct devid *	devid_copy(struct devid *);
void		devid_free(struct devid *);

d342 1
d371 1
a371 2
	struct  devid *id;
	struct	mutex mtx;
a446 2
	void *cookie;
	void (*done)(struct scsi_xfer *);
a488 1
#define XS_NO_CCB	9	/* device should requeue io and retry */
a559 2
void	scsi_activate(struct scsibus_softc *, int, int, int);

a562 4
struct scsi_xfer *	scsi_xs_get(struct scsi_link *, int);
void			scsi_xs_exec(struct scsi_xfer *);
void			scsi_xs_put(struct scsi_xfer *);

a567 3

void	mpath_path_activate(struct scsi_link *);
void	mpath_path_deactivate(struct scsi_link *);
@


1.107
log
@backout the backout marco did of my code because of the NO_CCB breakage.
the fix for the NO_CCB breakage will follow shortly.

tested by krw@@ marco@@ johan@@
ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.104 2009/10/22 11:56:32 dlg Exp $	*/
d503 1
@


1.106
log
@The big diff dlg committed to the midlayer breaks NO_CCB and
TRY_AGAIN_LATER.  NO_CCB is a timer based mechanism that can trivially
be made to fail by running IO to two or more disks simultaneously.  The
TRY_AGAIN_LATER thing is more subtle because it now is a permanent
failure instead of transient however this is much harder to hit because
something must have gone wrong before it hits.

ok deraadt krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.100 2009/08/13 19:49:31 dlg Exp $	*/
d56 1
d238 10
a247 3
	int		 d_type;
	u_int		 d_len;
	u_int8_t	*d_id;
d250 7
a256 7
#define DEVID_CMP(_a, _b) (				\
	(_a) != NULL &&					\
	(_b) != NULL &&					\
	(_a)->d_type != DEVID_NONE &&			\
	(_a)->d_type == (_b)->d_type &&			\
	(_a)->d_len == (_b)->d_len &&			\
	bcmp((_a)->d_id, (_b)->d_id, (_a)->d_len) == 0	\
d259 4
a353 1
	u_int16_t active;		/* operations in progress */
d382 2
a383 1
	struct  devid id;
d459 2
d574 2
d579 4
d588 3
@


1.105
log
@if you're attempting to detach multiple devices (eg, many targets,
many luns, or the entire bus), dont report ENXIO as an error to the
caller. this broke autoconf when it tried to forcefully remove a
bus such as umass and it thought there was a failure.

this introduces a way for scsi hbas to call activate/deactivate on
a device based on its target/lun address via a call to scsi_activate().
they can then schedule the actual detach/attach in a thread later via
scsi_req_probe/detach.

the mpi changes tweak the sas event handling code to use these apis
to properly handle attaches and detaches of disks. event handling
is still disabled till i can make it less chatty.

umass breakage reported by form@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.104 2009/10/22 11:56:32 dlg Exp $	*/
a55 1
#include <sys/mutex.h>
d237 3
a239 10
	u_int8_t	d_type;
	u_int8_t	d_flags;
#define DEVID_F_PRINT		(1<<0)
	u_int8_t	d_refcount;
	u_int8_t	d_len;

	/*
	 * the devid struct is basically a header, the actual id is allocated
	 * immediately after it.
	 */
d242 7
a248 7
#define DEVID_CMP(_a, _b) (					\
	(_a) != NULL && (_b) != NULL &&				\
	((_a) == (_b) ||					\
	((_a)->d_type != DEVID_NONE &&				\
	 (_a)->d_type == (_b)->d_type &&			\
	 (_a)->d_len == (_b)->d_len &&				\
	 bcmp((_a) + 1, (_b) + 1, (_a)->d_len) == 0))		\
a250 4
struct devid *	devid_alloc(u_int8_t, u_int8_t, u_int8_t, u_int8_t *);
struct devid *	devid_copy(struct devid *);
void		devid_free(struct devid *);

d342 1
d371 1
a371 2
	struct  devid *id;
	struct	mutex mtx;
a446 2
	void *cookie;
	void (*done)(struct scsi_xfer *);
a559 2
void	scsi_activate(struct scsibus_softc *, int, int, int);

a562 4
struct scsi_xfer *	scsi_xs_get(struct scsi_link *, int);
void			scsi_xs_exec(struct scsi_xfer *);
void			scsi_xs_put(struct scsi_xfer *);

a567 3

void	mpath_path_activate(struct scsi_link *);
void	mpath_path_deactivate(struct scsi_link *);
@


1.104
log
@devices below the scsibus should all be detached via scsi_detach_lun.
scsibusdetach wasnt doign it properly, so we would be leaking on detach in
some cases.

now, with the introduction of mpath, the scsi_link structures can
represent a path to a mpath node as well as normal devices. this
intercepts the device activate entrypoints and sends them to mpath
if it it in use rather than assuming a device is always there. the
scsibusdetach change ensures that detach always ends up handling
the mpath node case too.

hotplug bus functionality (eg, usb) tested by form@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.103 2009/10/20 00:19:24 dlg Exp $	*/
d574 2
d589 2
a590 2
int	mpath_path_activate(struct scsi_link *);
int	mpath_path_deactivate(struct scsi_link *);
@


1.103
log
@"active" is an unused member of the scsi_link structure. i couldnt find any
uses of it in our tree.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.100 2009/08/13 19:49:31 dlg Exp $	*/
d586 3
@


1.102
log
@rework how devids are handled in the midlayer and mpath.

previously a devid was a structure containing its type, length, and
a pointer to the actual devid value. this has been changed so a
devid is a header followed immediately by the memory making up the
id value. this allows the header and its value to be allocated
together.

devids are now reference counted, so multiple things (eg, the mpath
node handlers and the various scsi_link structures) can share the
same allocation safely. this also frees devids when scsi_links go
away, which was previously not done.

if mpath is enabled, then print the devids out as part of the devices
attach line.
@
text
@a353 1
	u_int16_t active;		/* operations in progress */
@


1.101
log
@rework the scsi midlayer to start addressing some problems i have
with it which became extremely annoying with what mpath wants to
do.

the major change is a new interface for submitting scsi commands.
previously the only way for drivers like sd, cd, st, etc to push
commands onto the hardware was via scsi_scsi_cmd(). the problem
with scsi_scsi_cmd is that it doesnt tell the caller if the command
failed, was queued, or completed unless you shoved a buf down with
it. this is important for mpath which wants to know what the physical
path to the device did so it can report it back to the midlayer
which called it.

this provides a new api which lets drivers like cd/sd/st/mpath etc
allocate an xs, fill it in, and provide a completion routine which
the midlayer will call with the state of the command when it is
finished with it. the caller is then responsible for freeing the
xs.

from the hba side of thing, the return code from the scsi_cmd
entrypoint is largely ignored now, and it is now always the
responsibility of the hba driver to call scsi_done when it has
completed the io, rather than returning COMPLETE and expecting the
midlayer to do it for you.

i have emulated scsi_scsi_cmd on top of this new api so existing
users of it will continue to work. sd(4) has been reworked to use
the new api directly to both demonstrate its use and test that the
new api actually does work.

this diff was mostly written in a day at f2k9. thanks to miod for poking
through hba drivers to help mitigate against fallout from the change to
the COMPLETE semantic. this has been reviewed by krw who didnt spot
anything wrong.

thanks to dave del debbio for testing.

ok deraadt@@
@
text
@d238 10
a247 3
	int		 d_type;
	u_int		 d_len;
	u_int8_t	*d_id;
d250 7
a256 7
#define DEVID_CMP(_a, _b) (				\
	(_a) != NULL &&					\
	(_b) != NULL &&					\
	(_a)->d_type != DEVID_NONE &&			\
	(_a)->d_type == (_b)->d_type &&			\
	(_a)->d_len == (_b)->d_len &&			\
	bcmp((_a)->d_id, (_b)->d_id, (_a)->d_len) == 0	\
d259 4
d383 1
a383 1
	struct  devid id;
@


1.100
log
@provide an api for an interrupt (or something like it) to notify the
midlayer that a scsi device has appeared or dissapeared. the midlayer will
queue an event and run it in the system workq (which has process context)
to handle the attach or detach.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.99 2009/08/09 12:47:23 dlg Exp $	*/
d56 1
d373 1
d449 2
d566 4
@


1.99
log
@add mpath(4), a driver that steals paths to scsi devices if it
thinks they could be available via multiple paths. those stolen
devices are then made available via mpath(4).

this is the minimum amount of code to implement the stealing. it
is generally broken and very brittle, so it is currently disabled.

it is going in so i can work on it in the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.97 2008/11/10 18:04:41 deraadt Exp $	*/
d556 3
@


1.98
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d560 6
@


1.97
log
@clean namespace a fair bit; wrap kernel-use-only structures and gunk in
#ifdef _KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.96 2008/11/09 17:01:10 deraadt Exp $	*/
d296 1
a296 1
	void		(*scsi_minphys)(struct buf *);
d541 1
@


1.96
log
@workaround lack of struct proc.  this whole mess must be cleaned out.
userland processes should not see all the kernel components.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.95 2008/09/12 11:14:04 miod Exp $	*/
d51 1
a51 1
#define SCSI_SCSICONF_H 1
d59 172
a279 2
struct buf;
struct proc;
d556 1
a556 193
static __inline void _lto2b(u_int32_t val, u_int8_t *bytes);
static __inline void _lto3b(u_int32_t val, u_int8_t *bytes);
static __inline void _lto4b(u_int32_t val, u_int8_t *bytes);
static __inline void _lto8b(u_int64_t val, u_int8_t *bytes);
static __inline u_int32_t _2btol(u_int8_t *bytes);
static __inline u_int32_t _3btol(u_int8_t *bytes);
static __inline u_int32_t _4btol(u_int8_t *bytes);
static __inline u_int64_t _5btol(u_int8_t *bytes);
static __inline u_int64_t _8btol(u_int8_t *bytes);

static __inline void _lto2l(u_int32_t val, u_int8_t *bytes);
static __inline void _lto3l(u_int32_t val, u_int8_t *bytes);
static __inline void _lto4l(u_int32_t val, u_int8_t *bytes);
static __inline u_int32_t _2ltol(u_int8_t *bytes);
static __inline u_int32_t _3ltol(u_int8_t *bytes);
static __inline u_int32_t _4ltol(u_int8_t *bytes);

static __inline void
_lto2b(val, bytes)
	u_int32_t val;
	u_int8_t *bytes;
{

	bytes[0] = (val >> 8) & 0xff;
	bytes[1] = val & 0xff;
}

static __inline void
_lto3b(val, bytes)
	u_int32_t val;
	u_int8_t *bytes;
{

	bytes[0] = (val >> 16) & 0xff;
	bytes[1] = (val >> 8) & 0xff;
	bytes[2] = val & 0xff;
}

static __inline void
_lto4b(val, bytes)
	u_int32_t val;
	u_int8_t *bytes;
{

	bytes[0] = (val >> 24) & 0xff;
	bytes[1] = (val >> 16) & 0xff;
	bytes[2] = (val >> 8) & 0xff;
	bytes[3] = val & 0xff;
}

static __inline void
_lto8b(val, bytes)
	u_int64_t val;
	u_int8_t *bytes;
{

	bytes[0] = (val >> 56) & 0xff;
	bytes[1] = (val >> 48) & 0xff;
	bytes[2] = (val >> 40) & 0xff;
	bytes[3] = (val >> 32) & 0xff;
	bytes[4] = (val >> 24) & 0xff;
	bytes[5] = (val >> 16) & 0xff;
	bytes[6] = (val >> 8) & 0xff;
	bytes[7] = val & 0xff;
}

static __inline u_int32_t
_2btol(bytes)
	u_int8_t *bytes;
{
	u_int32_t rv;

	rv = (bytes[0] << 8) | bytes[1];
	return (rv);
}

static __inline u_int32_t
_3btol(bytes)
	u_int8_t *bytes;
{
	u_int32_t rv;

	rv = (bytes[0] << 16) | (bytes[1] << 8) | bytes[2];
	return (rv);
}

static __inline u_int32_t
_4btol(bytes)
	u_int8_t *bytes;
{
	u_int32_t rv;

	rv = (bytes[0] << 24) | (bytes[1] << 16) |
	    (bytes[2] << 8) | bytes[3];
	return (rv);
}

static __inline u_int64_t
_5btol(bytes)
	u_int8_t *bytes;
{
	u_int64_t rv;

	rv = ((u_int64_t)bytes[0] << 32) |
	     ((u_int64_t)bytes[1] << 24) |
	     ((u_int64_t)bytes[2] << 16) |
	     ((u_int64_t)bytes[3] << 8) |
	     (u_int64_t)bytes[4];
	return (rv);
}

static __inline u_int64_t
_8btol(bytes)
	u_int8_t *bytes;
{
	u_int64_t rv;

	rv = (((u_int64_t)bytes[0]) << 56) |
	    (((u_int64_t)bytes[1]) << 48) |
	    (((u_int64_t)bytes[2]) << 40) |
	    (((u_int64_t)bytes[3]) << 32) |
	    (((u_int64_t)bytes[4]) << 24) |
	    (((u_int64_t)bytes[5]) << 16) |
	    (((u_int64_t)bytes[6]) << 8) |
	    ((u_int64_t)bytes[7]);
	return (rv);
}

static __inline void
_lto2l(val, bytes)
	u_int32_t val;
	u_int8_t *bytes;
{

	bytes[0] = val & 0xff;
	bytes[1] = (val >> 8) & 0xff;
}

static __inline void
_lto3l(val, bytes)
	u_int32_t val;
	u_int8_t *bytes;
{

	bytes[0] = val & 0xff;
	bytes[1] = (val >> 8) & 0xff;
	bytes[2] = (val >> 16) & 0xff;
}

static __inline void
_lto4l(val, bytes)
	u_int32_t val;
	u_int8_t *bytes;
{

	bytes[0] = val & 0xff;
	bytes[1] = (val >> 8) & 0xff;
	bytes[2] = (val >> 16) & 0xff;
	bytes[3] = (val >> 24) & 0xff;
}

static __inline u_int32_t
_2ltol(bytes)
	u_int8_t *bytes;
{
	u_int32_t rv;

	rv = bytes[0] | (bytes[1] << 8);
	return (rv);
}

static __inline u_int32_t
_3ltol(bytes)
	u_int8_t *bytes;
{
	u_int32_t rv;

	rv = bytes[0] | (bytes[1] << 8) | (bytes[2] << 16);
	return (rv);
}

static __inline u_int32_t
_4ltol(bytes)
	u_int8_t *bytes;
{
	u_int32_t rv;

	rv = bytes[0] | (bytes[1] << 8) |
	    (bytes[2] << 16) | (bytes[3] << 24);
	return (rv);
}

extern const u_int8_t version_to_spc [];
d559 1
@


1.95
log
@SCSI_DATA_UIO is never used. Code which checks for it is either dead or
commented out, remove it. Unifdef TFS while there.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.94 2008/07/22 01:01:31 dlg Exp $	*/
d109 1
@


1.94
log
@implement the fetching of a scsi devices "devid". recent hardware provides
a vpd page that uniquely identifies a device no matter what bus topology or
addressing was used to find it.

we have a workaround for old school scsi devices that do not differentiate
between luns. if the inq data for high luns is the same as the inq data
for lun 0, we assume it is one of these buggy devices.

the problem with this is that things like SANs present multiple
volumes as luns and they all have the same inq data. if you wanted
to present more than one volume to openbsd you would only ever see
the first one.

devices give us a mechanism to differentiate between luns, so now
i do get all my volumes attached in openbsde.

review and feedback by krw@@ marco@@ testing by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.89 2007/11/26 15:40:51 dlg Exp $	*/
a290 1
#define	SCSI_DATA_UIO	0x00400	/* The data address refers to a UIO	*/
@


1.93
log
@fgsch@@ points out my last commit changed the retry limit for CD capacity
commands. Bump limit back to the standard 4, and at the same time eliminate
SDRETRIES and CDRETRIES (both defined to 4) in favour of a new define,
SCSI_RETRIES, also defined to 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.92 2008/06/14 01:57:51 krw Exp $	*/
d59 20
d200 1
@


1.92
log
@Nuke ADEV_NOTUR, always issue TEST UNIT READY to clear out power-up
errors before issuing INQUIRY. Fixes Sony YE-Data floppy drive and
probably other devices at the cost of possibly breaking some 10 year
old CD-ROM drives. Un-special cases mvme68k which was forcing these
initial TURs.

Now wait for the inevitable weird USB device that breaks to surface.

ok marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.91 2008/06/13 04:27:08 krw Exp $	*/
d300 1
a300 1
 * Possible retries numbers for scsi_test_unit_ready()
d303 5
@


1.91
log
@Merge show_scsi_xs() and show_scsi_cmd() and move invocation so the
debug output shows the xs/command before it's issued rather than
displaying it on command completion. Some commands don't come back
and it would be nice to see their details.

While here nuke invocations of scsi_show* in umass. If you want SCSI
debug output use SCSI debug options.

Only affects SCSI debug output.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.90 2007/12/29 00:45:26 dlg Exp $	*/
a171 1
#define	ADEV_NOTUR		0x1000	/* No TEST UNIT READY */
@


1.90
log
@the scsi layer always had function pointers for asking the hba about a
device before issuing scsi commands to it, but it was never implemented,
never used, and no hba actually filled them in. i came along and added
another two function pointers for the same thing.

this cleans up the extra pointers.

ok krw@@ marco@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.89 2007/11/26 15:40:51 dlg Exp $	*/
a348 1
void	show_scsi_cmd(struct scsi_xfer *);
@


1.89
log
@let scsibus ask the adapter about a device before probing it. also allow
the adapter to be notified when a device goes away so it can free any state
it maintains about that device.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.88 2007/11/25 22:28:54 dlg Exp $	*/
d106 2
a107 2
	int		(*open_target_lu)(void);
	int		(*close_target_lu)(void);
a109 2
	int		(*dev_probe)(struct scsi_link *);
	void		(*dev_free)(struct scsi_link *);
@


1.88
log
@dont use the adapter_softc member of scsi_link as a softc anymore. the
"adapter_softc" is simply a way for the adapter to determine what scsibus
it is now dealing with, not a pointer back to the adapters device struct.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.87 2007/06/23 19:19:49 krw Exp $	*/
d110 2
@


1.87
log
@Implement disk sizes > 2^32-1. Code modelled on NetBSD.

Tested, tweaked and ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.86 2007/05/31 21:53:02 tedu Exp $	*/
d91 1
d179 1
@


1.86
log
@ckuethe found i missed a file in the workq update.  my bad
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.85 2007/05/31 18:21:44 dlg Exp $	*/
d315 1
a315 1
u_long	scsi_size(struct scsi_link *, int, u_int32_t *);
@


1.85
log
@remove the scsi task thread, and replace it with the system workq.

"just :wq and do it" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.84 2007/04/10 17:47:56 miod Exp $	*/
d307 1
a307 1
    workq_add_task(NULL, (_f), (_a1), (_a2), (_fl))
@


1.84
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.83 2007/04/03 04:47:59 dlg Exp $	*/
d55 1
d306 3
a310 1
int	scsi_task(void (*func)(void *, void *), void *, void *, int);
@


1.83
log
@add a wrapper for querying vpd inquiry pages
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.82 2006/12/12 02:44:36 krw Exp $	*/
d76 1
a76 1
 * each individual device also knows the address of it's own scsi_link
@


1.82
log
@Give the SCSI layer the ability to requeue i/o's rejected by a driver
using the new NO_CCB result. Currently a no-op since no driver produces
that result.

ok dlg@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.81 2006/11/28 23:59:45 dlg Exp $	*/
d315 1
@


1.81
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.80 2006/11/28 16:56:50 dlg Exp $	*/
d117 1
d310 1
a310 1
void	scsi_free_xs(struct scsi_xfer *);
@


1.80
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.79 2006/11/28 13:40:55 dlg Exp $	*/
d191 4
@


1.79
log
@remove a comment that was describing a behaviour that was changed over nine
years ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.78 2006/11/26 11:15:22 dlg Exp $	*/
d212 1
a212 1
struct scsibus_attach_args {
@


1.78
log
@no argument names in prototypes pls
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.77 2006/11/26 09:29:07 dlg Exp $	*/
a128 6
	/*
	 * When called with `0' as the second argument, we expect status
	 * back from the upper-level driver.  When called with a `1',
	 * we're simply notifying the upper-level driver that the command
	 * is complete and expect no status back.
	 */
@


1.77
log
@provide scsi_detach_bus, _target, and _lun to wrap up config_detach for
scsi devices. the midlayer keeps some state for each device that is
attached which needs to be cleaned up on detach, hence this wrapper.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.76 2006/10/21 07:36:15 dlg Exp $	*/
d106 2
a107 2
	int		(*ioctl)(struct scsi_link *, u_long cmd,
			    caddr_t addrp, int flag, struct proc *p);
@


1.76
log
@rework the bus scanning code by splitting it out into separate functions
for walking the bus and targets, and probing the luns. this removes the
need to use magic numbers to wildcard each of these, which in turn makes
the code a lot easier to read. as a bonus we get some more space to work in
(80 chars isnt that much somtimes).

note that this code wont probe high luns if lun 0 doesnt exist.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.75 2006/10/07 23:40:07 beck Exp $	*/
d352 4
@


1.75
log
@make cd-roms retry forever while the device indicates that it is
"becoming ready" - this is done in the exact same way that it
was done for tape in st.c. This commit adds a cd specific interpret_sense
routine to cd.c that will catch the becoming ready case and handle it.
This also removes the need to use crazy timeouts to catch this case.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.74 2006/10/02 09:06:26 dlg Exp $	*/
a345 1
int	scsi_probe_busses(int, int, int);
d348 4
@


1.74
log
@get rid of a boolean typedef. this is c, we have ints, deal with it.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.73 2006/09/22 00:33:41 dlg Exp $	*/
d301 1
a301 3
#define TEST_READY_RETRIES_DEFAULT	5
#define TEST_READY_RETRIES_CD		10
#define TEST_READY_RETRIES_TAPE		60
@


1.73
log
@implement a kernel thread that can be used by the midlayer or scsi drivers
when they need a process context to do something. the most obvious task
that springs to mind is attaches and detaches of devices on scsibus.

ok krw@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.72 2006/07/29 02:40:45 krw Exp $	*/
a52 2
typedef	int			boolean;

d193 1
a193 1
	boolean removable;
@


1.72
log
@The version field of scsi_inquiry_data is not a simple numeric value
that specifies the version of SCSI being supported. Even the ANSI part
that we use is complex. 4 means 2, 5 means 3 and 6 means 4. Translate
and use the value correctly. Fixes SCSI5 and SCSI6 in dmesg. And
properly protects SCSI2 devices from getting SCSI3 commands.

"seems like an elegant solution to me" millert@@ ok dlg@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.71 2006/07/23 14:34:55 krw Exp $	*/
d311 2
@


1.71
log
@Use REPORT LUNS to get the list of LUNs to probe. If such a list is
obtained probe the LUNs given without checking for duplicate INQUIRY
data.

For non-USB, non-ATAPI, devices claiming to be SCSI-3 compliant. And
the target must have something attached at LUN 0.

If REPORT LUNS can't be used or isn't supported, the old scan process
is used.

Fixes Fibre Channel and SCSI enclosure devices that provide identical
INQUIRY data for all LUNs and were thus being misprobed as having
only LUN 0.

Tested by Bob Kitella, dlg@@, beck@@. Suggestions from deraadt@@.

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.70 2006/07/22 18:03:07 krw Exp $	*/
d543 3
@


1.70
log
@Nuke SCSIFORCELUN* and friends. These were introduced as a safety
valve in case our duplicate LUN checks had to be circumvented. Since
no one has found a need for them, and they were just one more place
trying to shift a bit 255 places to the left could be induced, remove
them.

"i don't think any options like that are worthwhile" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.69 2006/07/13 11:46:16 krw Exp $	*/
d341 2
@


1.69
log
@Eliminate scsi_link field 'scsi_version' and just use the INQUIRY data
stored in scsi_link. That's where the value came from anyway. Move 'luns'
field to where 'scsi_version' used to be to preserve alignment.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.68 2006/07/11 21:55:46 dlg Exp $	*/
a96 15

/*
 * Specify which buses and targets must scan all LUNs, even when IDENTIFY does
 * not seem to be working. Some devices (e.g. some external RAID devices) may
 * seem to have non-functional IDENTIFY because they return identical INQUIRY
 * data for all LUNs.
 */
#ifndef SCSIFORCELUN_BUSES
#define SCSIFORCELUN_BUSES	0
#endif
#ifndef SCSIFORCELUN_TARGETS
#define	SCSIFORCELUN_TARGETS	0
#endif

extern int scsiforcelun_buses, scsiforcelun_targets;
@


1.68
log
@the scsi_link structure contained a copy of the inquiry flags and the whole
inquiry. this removes the flags member and makes all its users refer to the
whole inquiry now.

ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.67 2006/07/06 00:41:37 dlg Exp $	*/
a161 1
	u_int8_t scsi_version;		/* SCSI-I, SCSI-II, etc. */
d163 1
a194 1
	u_char	luns;
@


1.67
log
@add a flag to sc_link to be used by a hba to mark the target as virtual.

grudging ok from deraadt@@ so i can move forward. this should be revisited
one day though.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.66 2006/06/20 00:58:56 deraadt Exp $	*/
d195 1
a195 1
	u_int8_t inquiry_flags;		/* copy of flags from probe INQUIRY */
a199 1
	u_char	luns;
@


1.66
log
@pack wwn fields into struct better; ok marco krw
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.65 2006/05/31 19:43:56 jason Exp $	*/
d182 1
@


1.65
log
@add a place to store the PortWWN and NodeWWN for fibre channel stuffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.64 2006/05/11 00:45:59 krw Exp $	*/
d166 3
a168 2
	u_int64_t port_wwn;
	u_int64_t node_wwn;
a170 1
	u_int16_t openings;		/* available operations */
@


1.64
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.63 2005/12/02 16:24:08 marco Exp $	*/
d166 2
@


1.63
log
@Remove one tab that cause a line to overflow.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.62 2005/11/13 02:39:45 krw Exp $	*/
d94 1
a94 1
 * Temporary hack 
@


1.62
log
@Use scsi_delay() instead of delay() when waiting for scsi disk to
become ready. Make verbiage SC_DEBUG().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.61 2005/09/11 17:34:27 krw Exp $	*/
d225 1
a225 1
	struct scsi_link *adapter_link;		/* prototype supplied by adapter */
@


1.61
log
@Simplify code by changing struct scsi_mode_sense_buf{ union {}
headers; } to just union scsi_mode_sense_buf {}. No functional change.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.60 2005/06/24 23:39:18 krw Exp $	*/
d362 1
@


1.60
log
@Fix botch introduced in r1.12. reduced_geometry.sectors is a 5 byte
field, with reduced_geometry.sectors[0] not being sectors/track. Add
_5btol() to correctly parse entire field. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.59 2005/06/23 00:31:44 krw Exp $	*/
d341 1
a341 1
	    struct scsi_mode_sense_buf *, void **, u_int32_t *, u_int64_t *,
@


1.59
log
@Don't discard the blocksize information provided by the READ CAPACITY
command. Return it in a new parameter to scsi_size.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.58 2005/06/05 21:27:07 krw Exp $	*/
d370 1
d457 14
@


1.58
log
@Fix scsi_mode_select() and scsi_mode_select_big() to send just the
required number of bytes, rather than a full scsi_mode_sense_buf. Some
devices (e.g. my HP SureStore DAT/24) decline to accept such oversized
transfers. Instead, force callers to fill in the data_length field in
the header and use that information to set the size of the transfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.57 2005/06/03 15:50:10 krw Exp $	*/
d329 1
a329 1
u_long	scsi_size(struct scsi_link *, int);
@


1.57
log
@Tweak scsi_do_mode_sense(). NetBSD was right and I was wrong. Sigh.
Add 'big' parameter to report which mode sense header type is being
returned. Eliminate icky pointer arithmetic, since it won't work if
only block descriptors are returned by the device.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.56 2005/06/03 15:24:05 krw Exp $	*/
d344 1
a344 1
	    size_t, int, int);
d346 1
a346 1
	    struct scsi_mode_header_big *, size_t, int, int);
@


1.56
log
@Cache a copy of the INQUIRY data obtained during device attachment in
the scsi_link structure. This is a more general solution than the
current inconsistant copying of fields into _softc structures. The
redundant fields in _softc's will be cleaned up later. The device
field will be used immediately to finish up the new mode sense code.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.55 2005/05/28 06:16:33 krw Exp $	*/
d342 1
a342 1
	    u_int32_t *, int, int);
@


1.55
log
@Add _lto8b() and _8btol() to decode nblocks field of
scsi_mode_blk_desc_big. Will be needed to move st to new mode sense
function.

Be a bit more careful with types of parameters to scsi_do_mode_sense,
using u_int32_t instead of int.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.54 2005/05/25 21:39:08 krw Exp $	*/
d198 1
@


1.54
log
@With PQUIK_NOMODESENSE gone, SDEV_NOMODESENSE can go too.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.53 2005/05/25 20:52:41 krw Exp $	*/
d340 2
a341 2
	    struct scsi_mode_sense_buf *, void **, int *, int *, int *, int,
	    int);
d365 1
d369 1
d411 16
d455 17
@


1.53
log
@Introduce safer, more general mode sense capability. Transparently use
both 10 byte and 6 byte MODE SENSE commands and just return error
checked values.

Convert sd_scsi.c to use new mechanism for non-optical drives. USB
umass devices will now display actual mode sense info if it is
available via a 10 byte MODE SENSE. Which may mean 0 heads, etc. is
shown until cosmetics are finalized.

ok marco@@ 'that is pretty cool' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.52 2005/05/14 00:20:43 krw Exp $	*/
a184 1
#define	SDEV_NOMODESENSE	0x0040	/* removable media/optical drives */
@


1.52
log
@Add scsi_mode_[sense|select]_big() and use it instead of
atapi_mode_[sense|select](). This will allow the removal of
atapi_base.c and atapi_all.h files, and sets the stage for better usb
mode sense handling amoung other things.

Remove cd_scsibus_[get|set]_mode() and
sd_scsibus_mode_sense() shims in favour of scsi_mode_[sense|select]().
Add zero'ing of reserved length field in scsi_mode_select(). Change
some uchar * type parameters to scsi_mode_header *.

No functional changes. Mostly from NetBSD.

ok dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.51 2005/04/27 23:54:44 krw Exp $	*/
d338 5
@


1.51
log
@Add SDEV_UMASS flag, analogous to SDEV_ATAPI, and use it to force a
full LUN scan on UMASS SCSI targets. UMASS provides reliable max lun
information so we shouldn't waste time. Fixes many x-in-1 card
reader/writers that report identical INQUIRY information for every
slot they provide.

Lots of diagnosis and testing by dlg@@, ok dlg@@, 'I can live with this'
marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.50 2005/04/06 02:51:13 krw Exp $	*/
d334 8
a341 4
int	scsi_mode_sense(struct scsi_link *, int, int, u_char *, size_t,
	    int, int);
int	scsi_mode_select(struct scsi_link *, int, u_char *, size_t, int,
	    int);
@


1.50
log
@De-register scsi.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.49 2005/04/05 12:13:16 krw Exp $	*/
d179 1
@


1.49
log
@Factor out scsi_mode_sense() and scsi_mode_select() like NetBSD does.
Eliminate some duplicate structures and defines along the way. SCSI CD
drives will now pay attention to the 'flags' parameter for MODE SENSE
and MODE SELECT commands. No other functional change.

ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.48 2004/11/30 19:28:37 krw Exp $	*/
d404 1
a404 1
	register u_int32_t rv;
d414 1
a414 1
	register u_int32_t rv;
d424 1
a424 1
	register u_int32_t rv;
d468 1
a468 1
	register u_int32_t rv;
d478 1
a478 1
	register u_int32_t rv;
d488 1
a488 1
	register u_int32_t rv;
@


1.48
log
@No longer require write permission for read-only SCSI commands
submitted via ioctl. Eliminate scsi_do_safeioctl(), thus permitting
ch, ss and st devices to submit SCSI commands. Return EPERM rather
than EBADF when permissions are inadequate.

Allows more programs to run with fewer permissions. Problem diagnosed
by Nikolay Sturm in mplayer port.

Tested by Nikolay, ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.47 2004/07/31 11:31:30 krw Exp $	*/
d333 4
@


1.47
log
@Remove scsi_change_def() and related command structure. Its only use
in the tree is #ifdef'd out and is fundamentally wrong anyway - it
tries to force *all* devices to SCSI-2. Also recent SCSI specs seem to
have marked the command as obsolete. Bonus - eliminates another
undocumented option (SCSI_2_DEF).

Found in a list of unused kernel functions posted to tech-kern@@netbsd
by Krister Walfridsson in 2002.

ok marco@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.46 2004/06/22 00:50:57 marco Exp $	*/
a338 2
	    int, struct proc *);
int	scsi_do_safeioctl(struct scsi_link *, dev_t, u_long, caddr_t,
@


1.46
log
@Add additional retries in TUR to allow for tape devices to settle after a reset.
More informative failure message and silence "already open" message.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.45 2004/05/17 23:57:51 krw Exp $	*/
a329 1
int	scsi_change_def(struct scsi_link *, int);
@


1.45
log
@Elminate SCSIRET_* synonyms for EJUSTRETURN and ERESTART by using
EJUSTRETURN and ERESTART instead. Delete unused SCSIRET_RETRY define.
From NetBSD.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.44 2004/05/09 05:33:59 krw Exp $	*/
d318 1
@


1.44
log
@Eliminate verbosity parameter to scsi_print_sense and the associated
chunk of code. It was never executed unless you were debugging a
mvmex8k 'vs' device.

ok miod@@ (mvmex8k bits) marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.43 2004/04/18 00:49:29 krw Exp $	*/
a133 9

/*
 * Device Specific Sense Handlers return either an errno
 * or one of these three items.
 */

#define SCSIRET_NOERROR   0	/* No Error */
#define SCSIRET_RETRY    -1	/* Retry the command that got this sense */
#define SCSIRET_CONTINUE -2	/* Continue with standard sense processing */
@


1.43
log
@Restore siop's (and possibly others) ability to negotiate tags/wide/sync by
reverting to a single (short) INQUIRY command during probe. Compensate in siop
by trying PPR on all targets on SCSI-3 buses and falling back to WDTR/SDTR if
PPR rejected.

Problem found by mickey@@. Tested on a wide variety of devices by Marco.

ok marco@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.42 2004/03/10 01:37:40 krw Exp $	*/
d354 1
a354 1
void	scsi_print_sense(struct scsi_xfer *, int);
@


1.42
log
@Simplify new LUN scanning logic, add diagnostic messages for all
instances of bad LUNs and add SCSIFORCELUN_BUSES and
SCSIFORCELUN_TARGETS options.

ok miod@@ deraadt@@. Tested in the Marco Peereboom torture chamber.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.41 2004/02/21 00:47:42 krw Exp $	*/
a201 1
	u_int8_t inquiry_flags2;	/* copy of flags2 from probe INQUIRY */
@


1.42.2.1
log
@MFC:
Fix by krw@@

Restore siop's (and possibly others) ability to negotiate tags/wide/sync by
reverting to a single (short) INQUIRY command during probe. Compensate in siop
by trying PPR on all targets on SCSI-3 buses and falling back to WDTR/SDTR if
PPR rejected.

Problem found by mickey@@. Tested on a wide variety of devices by Marco.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.42 2004/03/10 01:37:40 krw Exp $	*/
d202 1
@


1.41
log
@Eliminate the quirks SDEV_NOSTARTUNIT, UMASS_QUIRK_NO_START_STOP, and
UMASS_QUIRK_FORCE_SHORT_INQUIRY. Fixes a bunch of USB devices. Based
on work by Mycroft in NetBSD.

ok tdeval@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.40 2004/01/14 02:00:41 krw Exp $	*/
d97 15
@


1.40
log
@Nuke SDEV_NOLUNS, SDEV_FORCELUNS, and PQUIRK_FORCELUNS quirks. Also
moreluns field in scsi_link structure.  Instead, treat an INQUIRY
result that duplicates the INQUIRY result of LUN 0 as proof the LUN
does not exist.  Compensate for lack of SDEV_NOLUNS where necessary by
setting sc_link->luns to 1, which has the same effect. From Marco
Peereboom.

Don't issue Test Unit Ready command before INQUIRY command - not
necessary and potentially harmful to devices with ADEV_NOTUR quirk
since quirks have not been set yet. From mycroft@@NetBSD

ok deraadt@@, mvme* changes by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.39 2003/05/18 16:06:35 mickey Exp $	*/
a178 1
#define	SDEV_NOSTARTUNIT	0x0080	/* do not issue start unit requests in sd.c */
@


1.39
log
@constify the quirck tables and fix the scsi_inqmatch() proto accordingly; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.38 2003/05/16 19:54:05 krw Exp $	*/
a177 2
#define	SDEV_NOLUNS		0x0010	/* does not grok LUNs */
#define	SDEV_FORCELUNS		0x0020	/* prehistoric drive/ctlr groks LUNs */
a221 1
	u_int16_t moreluns;
@


1.38
log
@Provide most if not all the support required for the usb changes Nate
is trying to bring in.

1) Change name of SDEV_NOCDB6 to SDEV_ONLYBIG to align it with the
same quirk in NetBSD, and make it more clear what it is trying to do.
i.e. force the use of READ_BIG/WRITE_BIG commands, not suppress all
use of 6 byte CDB's.

2) Check SDEV_ONLYBIG in cd.c as well as sd.c. i.e. both places where
a choice is made to use the 6 or 10 byte versions of READ/WRITE.

3) Actually make use of the ADEV_NOTUR (No TEST UNIT READY) quirk to
suppress the emission of TEST UNIT READY commands.

4) Add some explanatory comments from NetBSD to scsiconf.h so that the
use of the quirks is made clear.

ok miod@@ tdeval@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.37 2003/02/20 04:02:06 krw Exp $	*/
d318 1
a318 1
caddr_t scsi_inqmatch(struct scsi_inquiry_data *, caddr_t, int,
@


1.37
log
@Eliminate unused parameter to scsi_free_xs().

ok deraadt@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.36 2002/12/30 21:50:28 grange Exp $	*/
d185 4
a188 4
#define	ADEV_NOCAPACITY		0x0800
#define	ADEV_NOTUR		0x1000
#define	ADEV_NODOORLOCK		0x2000
#define SDEV_NOCDB6		0x4000  /* does not support 6 byte CDB */
@


1.36
log
@Add new parameter to scsi_test_unit_ready(): retries number.
Use increased retries number and don't ignore SCSI_IGNORE_NOT_READY
when call scsi_test_unit_ready() for cd-rom, this makes system wait
if drive is loading media.
Tested by millert@@ and fgsch@@; some input and ok from krw@@.
Problem reported by The lord of the CD-writers
Igor Grabin <violent@@death.kiev.ua>.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.35 2002/08/03 08:55:35 pvalchev Exp $	*/
d324 1
a324 1
void	scsi_free_xs(struct scsi_xfer *, int);
@


1.35
log
@spell 'debugging' correctly with double 'g' (in comments)
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.34 2002/05/27 23:42:40 tdeval Exp $	*/
d312 6
d327 1
a327 1
int	scsi_test_unit_ready(struct scsi_link *, int);
@


1.34
log
@punctuation
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.33 2002/03/14 01:27:13 millert Exp $	*/
d169 1
a169 1
#define	SDEV_DBX		0x00f0	/* debuging flags (scsi_debug.h) */
@


1.33
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.32 2002/01/07 19:04:46 mickey Exp $	*/
d100 2
a101 2
 * whatever low-end drivers they are attached to each adapter type has one of
 * these statically allocated.
d214 5
a218 5
 * it holds pointers to allow the scsi bus to get to the driver
 * That is running each LUN on the bus
 * it also has a template entry which is the prototype struct
 * supplied by the adapter driver, this is used to initialise
 * the others, before they have the rest of the fields filled in
d238 1
a238 1
 * Each scsi transaction is fully described by one of these structures
d292 1
a292 1
 * Escape op codes.  This provides an extensible setup for operations
@


1.32
log
@pass the proc* down the ioctl chain to controller; mjacob@@ csapuntz@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.31 2001/10/26 10:50:26 krw Exp $	*/
d104 6
a109 6
	int		(*scsi_cmd) __P((struct scsi_xfer *));
	void		(*scsi_minphys) __P((struct buf *));
	int		(*open_target_lu) __P((void));
	int		(*close_target_lu) __P((void));
	int		(*ioctl) __P((struct scsi_link *, u_long cmd,
			    caddr_t addrp, int flag, struct proc *p));
d135 1
a135 1
	int	(*err_handler) __P((struct scsi_xfer *));
d137 1
a137 1
	void	(*start) __P((void *));
d139 1
a139 1
	int	(*async) __P((void));
d146 1
a146 1
	void	(*done)  __P((struct scsi_xfer *));
d198 1
a198 1
int	scsiprint __P((void *, const char *));
d312 2
a313 2
caddr_t scsi_inqmatch __P((struct scsi_inquiry_data *, caddr_t, int,
	    int, int *));
d315 1
a315 1
void	scsi_init __P((void));
d317 12
a328 12
	scsi_get_xs __P((struct scsi_link *, int));
void	scsi_free_xs __P((struct scsi_xfer *, int));
int	scsi_execute_xs __P((struct scsi_xfer *));
u_long	scsi_size __P((struct scsi_link *, int));
int	scsi_test_unit_ready __P((struct scsi_link *, int));
int	scsi_change_def __P((struct scsi_link *, int));
int	scsi_inquire __P((struct scsi_link *, struct scsi_inquiry_data *, int));
int	scsi_prevent __P((struct scsi_link *, int, int));
int	scsi_start __P((struct scsi_link *, int, int));
void	scsi_done __P((struct scsi_xfer *));
void	scsi_user_done __P((struct scsi_xfer *));
int	scsi_scsi_cmd __P((struct scsi_link *, struct scsi_generic *,
d330 27
a356 27
	    int timeout, struct buf *bp, int flags));
int	scsi_do_ioctl __P((struct scsi_link *, dev_t, u_long, caddr_t,
	    int, struct proc *));
int	scsi_do_safeioctl __P((struct scsi_link *, dev_t, u_long, caddr_t,
	    int, struct proc *));
void	sc_print_addr __P((struct scsi_link *));

void	show_scsi_xs __P((struct scsi_xfer *));
void	scsi_print_sense __P((struct scsi_xfer *, int));
void	show_scsi_cmd __P((struct scsi_xfer *));
void	show_mem __P((u_char *, int));
int	scsi_probe_busses __P((int, int, int));
void	scsi_strvis __P((u_char *, u_char *, int));

static __inline void _lto2b __P((u_int32_t val, u_int8_t *bytes));
static __inline void _lto3b __P((u_int32_t val, u_int8_t *bytes));
static __inline void _lto4b __P((u_int32_t val, u_int8_t *bytes));
static __inline u_int32_t _2btol __P((u_int8_t *bytes));
static __inline u_int32_t _3btol __P((u_int8_t *bytes));
static __inline u_int32_t _4btol __P((u_int8_t *bytes));

static __inline void _lto2l __P((u_int32_t val, u_int8_t *bytes));
static __inline void _lto3l __P((u_int32_t val, u_int8_t *bytes));
static __inline void _lto4l __P((u_int32_t val, u_int8_t *bytes));
static __inline u_int32_t _2ltol __P((u_int8_t *bytes));
static __inline u_int32_t _3ltol __P((u_int8_t *bytes));
static __inline u_int32_t _4ltol __P((u_int8_t *bytes));
@


1.31
log
@Remove unused #define INUSE. It was rendered superfluous by the
move to pools in SCSI layer.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.30 2001/10/08 01:50:48 drahn Exp $	*/
d109 1
a109 1
			    caddr_t addrp, int flag));
@


1.31.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.32 2002/01/07 19:04:46 mickey Exp $	*/
d109 1
a109 1
			    caddr_t addrp, int flag, struct proc *p));
@


1.31.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.31.2.1 2002/01/31 22:55:48 niklas Exp $	*/
d100 2
a101 2
 * whatever low-end drivers they are attached to.  Each adapter type has one
 * of these statically allocated.
d104 6
a109 6
	int		(*scsi_cmd)(struct scsi_xfer *);
	void		(*scsi_minphys)(struct buf *);
	int		(*open_target_lu)(void);
	int		(*close_target_lu)(void);
	int		(*ioctl)(struct scsi_link *, u_long cmd,
			    caddr_t addrp, int flag, struct proc *p);
d135 1
a135 1
	int	(*err_handler)(struct scsi_xfer *);
d137 1
a137 1
	void	(*start)(void *);
d139 1
a139 1
	int	(*async)(void);
d146 1
a146 1
	void	(*done)(struct scsi_xfer *);
d198 1
a198 1
int	scsiprint(void *, const char *);
d214 5
a218 5
 * It holds pointers to allow the scsi bus to get to the driver
 * that is running each LUN on the bus.
 * It also has a template entry which is the prototype struct
 * supplied by the adapter driver.  This is used to initialise
 * the others, before they have the rest of the fields filled in.
d238 1
a238 1
 * Each scsi transaction is fully described by one of these structures.
d292 1
a292 1
 * Escape op-codes.  This provides an extensible setup for operations
d312 2
a313 2
caddr_t scsi_inqmatch(struct scsi_inquiry_data *, caddr_t, int,
	    int, int *);
d315 1
a315 1
void	scsi_init(void);
d317 12
a328 12
	scsi_get_xs(struct scsi_link *, int);
void	scsi_free_xs(struct scsi_xfer *, int);
int	scsi_execute_xs(struct scsi_xfer *);
u_long	scsi_size(struct scsi_link *, int);
int	scsi_test_unit_ready(struct scsi_link *, int);
int	scsi_change_def(struct scsi_link *, int);
int	scsi_inquire(struct scsi_link *, struct scsi_inquiry_data *, int);
int	scsi_prevent(struct scsi_link *, int, int);
int	scsi_start(struct scsi_link *, int, int);
void	scsi_done(struct scsi_xfer *);
void	scsi_user_done(struct scsi_xfer *);
int	scsi_scsi_cmd(struct scsi_link *, struct scsi_generic *,
d330 27
a356 27
	    int timeout, struct buf *bp, int flags);
int	scsi_do_ioctl(struct scsi_link *, dev_t, u_long, caddr_t,
	    int, struct proc *);
int	scsi_do_safeioctl(struct scsi_link *, dev_t, u_long, caddr_t,
	    int, struct proc *);
void	sc_print_addr(struct scsi_link *);

void	show_scsi_xs(struct scsi_xfer *);
void	scsi_print_sense(struct scsi_xfer *, int);
void	show_scsi_cmd(struct scsi_xfer *);
void	show_mem(u_char *, int);
int	scsi_probe_busses(int, int, int);
void	scsi_strvis(u_char *, u_char *, int);

static __inline void _lto2b(u_int32_t val, u_int8_t *bytes);
static __inline void _lto3b(u_int32_t val, u_int8_t *bytes);
static __inline void _lto4b(u_int32_t val, u_int8_t *bytes);
static __inline u_int32_t _2btol(u_int8_t *bytes);
static __inline u_int32_t _3btol(u_int8_t *bytes);
static __inline u_int32_t _4btol(u_int8_t *bytes);

static __inline void _lto2l(u_int32_t val, u_int8_t *bytes);
static __inline void _lto3l(u_int32_t val, u_int8_t *bytes);
static __inline void _lto4l(u_int32_t val, u_int8_t *bytes);
static __inline u_int32_t _2ltol(u_int8_t *bytes);
static __inline u_int32_t _3ltol(u_int8_t *bytes);
static __inline u_int32_t _4ltol(u_int8_t *bytes);
@


1.31.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.31.2.2 2002/06/11 03:32:13 art Exp $	*/
d169 1
a169 1
#define	SDEV_DBX		0x00f0	/* debugging flags (scsi_debug.h) */
@


1.31.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d185 4
a188 4
#define	ADEV_NOCAPACITY		0x0800	/* no READ CD CAPACITY */
#define	ADEV_NOTUR		0x1000	/* No TEST UNIT READY */
#define	ADEV_NODOORLOCK		0x2000	/* can't lock door */
#define SDEV_ONLYBIG		0x4000  /* always use READ_BIG and WRITE_BIG */
a311 6
/*
 * Possible retries numbers for scsi_test_unit_ready()
 */
#define TEST_READY_RETRIES_DEFAULT	5
#define TEST_READY_RETRIES_CD		10

d318 1
a318 1
void	scsi_free_xs(struct scsi_xfer *);
d321 1
a321 1
int	scsi_test_unit_ready(struct scsi_link *, int, int);
@


1.30
log
@Add a new quirk type, SDEV_NOCDB6, some USB devices like ATAPI
do not support 6 byte CDBs.
This quirk is used for OLYMPUS USB cameras.
Loosely based on code in FreeBSD.
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.29 2001/08/25 19:29:16 fgsch Exp $	*/
a277 1
#define	INUSE		0x00010	/* The scsi_xfer block is in use	*/
@


1.29
log
@Change scsi_[free|get]_xs to use pool(9); art@@ krw@@ miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.28 2001/08/18 02:24:02 krw Exp $	*/
d188 1
@


1.28
log
@Make siop pay attention to quirks table. This not only eliminates the
ugly INQUIRY snooping but avoids adding even uglier #ifdef's to turn
off stuff, e.g. tagged queuing.

Add two disk drives now known to lie about supporting tagged queuing
to quirks table. One from millert@@ (<MICROP, 4421-07 0329SJ, 0329>)
and one from Hakan Olsson (<SEAGATE, ST150176LW, 0002>).

Add field 'inquiry_flags2' to struct scsi_link to hold flags2 field
from struct scsi_inquiry_data. These flags relate to SCSI-3 specific
features.

Clean up some logic, eliminating need for TARF_PPR flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.27 2001/06/22 14:35:43 deraadt Exp $	*/
d313 1
a313 1
	int, int *));
d315 28
a342 26
struct scsi_xfer *scsi_get_xs __P((struct scsi_link *, int));
void scsi_free_xs __P((struct scsi_xfer *, int));
int scsi_execute_xs __P((struct scsi_xfer *));
u_long scsi_size __P((struct scsi_link *, int));
int scsi_test_unit_ready __P((struct scsi_link *, int));
int scsi_change_def __P((struct scsi_link *, int));
int scsi_inquire __P((struct scsi_link *, struct scsi_inquiry_data *, int));
int scsi_prevent __P((struct scsi_link *, int, int));
int scsi_start __P((struct scsi_link *, int, int));
void scsi_done __P((struct scsi_xfer *));
void scsi_user_done __P((struct scsi_xfer *));
int scsi_scsi_cmd __P((struct scsi_link *, struct scsi_generic *,
	int cmdlen, u_char *data_addr, int datalen, int retries,
	int timeout, struct buf *bp, int flags));
int scsi_do_ioctl __P((struct scsi_link *, dev_t, u_long, caddr_t,
	int, struct proc *));
int scsi_do_safeioctl __P((struct scsi_link *, dev_t, u_long, caddr_t,
	int, struct proc *));
void sc_print_addr __P((struct scsi_link *));

void show_scsi_xs __P((struct scsi_xfer *));
void scsi_print_sense __P((struct scsi_xfer *, int));
void show_scsi_cmd __P((struct scsi_xfer *));
void show_mem __P((u_char *, int));
int scsi_probe_busses __P((int, int, int));
void scsi_strvis __P((u_char *, u_char *, int));
@


1.27
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.26 2001/04/30 21:21:54 csapuntz Exp $	*/
d189 1
@


1.26
log
@

Pass IOCTL to adapter device if not understood by SCSI layer.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.25 2000/11/23 08:55:35 deraadt Exp $	*/
d108 2
a109 2
	int             (*ioctl) __P((struct scsi_link *, u_long cmd,
					 caddr_t addrp, int flag));
d125 3
a127 3
#define SCSIRET_NOERROR   0     /* No Error */
#define SCSIRET_RETRY    -1     /* Retry the command that got this sense */
#define SCSIRET_CONTINUE -2     /* Continue with standard sense processing */
d171 1
a171 1
#define	SDEV_ATAPI              0x0200  /* device is ATAPI */
d174 14
a187 14
#define	SDEV_AUTOSAVE	      0x0001	/* do implicit SAVEDATAPOINTER on disconnect */
#define	SDEV_NOSYNC	      0x0002	/* does not grok SDTR */
#define	SDEV_NOWIDE	      0x0004	/* does not grok WDTR */
#define	SDEV_NOTAGS	      0x0008	/* lies about having tagged queueing */
#define	SDEV_NOLUNS	      0x0010	/* does not grok LUNs */
#define	SDEV_FORCELUNS	      0x0020	/* prehistoric drive/ctlr groks LUNs */
#define	SDEV_NOMODESENSE      0x0040	/* removable media/optical drives */
#define	SDEV_NOSTARTUNIT      0x0080	/* do not issue start unit requests in sd.c */
#define	SDEV_NOSYNCCACHE      0x0100    /* no SYNCHRONIZE_CACHE */
#define	ADEV_NOSENSE          0x0200    /* No request sense - ATAPI */
#define	ADEV_LITTLETOC        0x0400    /* little-endian TOC - ATAPI */
#define	ADEV_NOCAPACITY       0x0800
#define	ADEV_NOTUR            0x1000
#define	ADEV_NODOORLOCK       0x2000
d287 1
a287 1
#define SCSI_URGENT     0x08000	/* Urgent operation (e.g., HTAG)        */
d308 2
a309 2
#define XS_SHORTSENSE   6       /* Check the ATAPI sense for the error */
#define XS_RESET        8       /* bus was reset; possible retry command  */
d394 1
a394 2
	rv = (bytes[0] << 8) |
	     bytes[1];
d404 1
a404 3
	rv = (bytes[0] << 16) |
	     (bytes[1] << 8) |
	     bytes[2];
d414 2
a415 4
	rv = (bytes[0] << 24) |
	     (bytes[1] << 16) |
	     (bytes[2] << 8) |
	     bytes[3];
d458 1
a458 2
	rv = bytes[0] |
	     (bytes[1] << 8);
d468 1
a468 3
	rv = bytes[0] |
	     (bytes[1] << 8) |
	     (bytes[2] << 16);
d478 2
a479 4
	rv = bytes[0] |
	     (bytes[1] << 8) |
	     (bytes[2] << 16) |
	     (bytes[3] << 24);
@


1.25
log
@fix lun support, not as nice as i would like
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.24 2000/11/20 07:34:51 deraadt Exp $	*/
d91 1
d108 2
@


1.24
log
@limit luns on usb
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.23 2000/07/06 03:37:10 mjacob Exp $	*/
d190 1
a190 1
	u_char	maxlun;
@


1.23
log
@Add in a timeout structure to the scsi_xfer structure so that HBA's can
watchdog per command. Reserve 4 bits of the flags field for the HBA's
private use (e.g., for saying whether the commands in the middle of
being watchdogged....).
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.22 2000/04/08 19:19:33 csapuntz Exp $	*/
d190 1
@


1.22
log
@

These days, attach can occur outside the tsleep-restricted world of
BSD autoconf.

Don't use POLL & NOSLEEP mode if attaching after autoconf
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.21 1999/12/16 05:17:36 mjacob Exp $	*/
d56 1
d258 4
d267 18
a284 17
#define	SCSI_NOSLEEP	0x0001	/* don't sleep */
#define	SCSI_POLL	0x0002	/* poll for completion */
#define	SCSI_AUTOCONF	0x0003	/* shorthand for SCSI_POLL | SCSI_NOSLEEP */
#define	SCSI_USER	0x0004	/* Is a user cmd, call scsi_user_done	*/
#define	ITSDONE		0x0008	/* the transfer is as done as it gets	*/
#define	INUSE		0x0010	/* The scsi_xfer block is in use	*/
#define	SCSI_SILENT	0x0020	/* don't announce NOT READY or MEDIA CHANGE */
#define	SCSI_IGNORE_NOT_READY		0x0040	/* ignore NOT READY */
#define	SCSI_IGNORE_MEDIA_CHANGE	0x0080	/* ignore MEDIA CHANGE */
#define	SCSI_IGNORE_ILLEGAL_REQUEST	0x0100	/* ignore ILLEGAL REQUEST */
#define	SCSI_RESET	0x0200	/* Reset the device in question		*/
#define	SCSI_DATA_UIO	0x0400	/* The data address refers to a UIO	*/
#define	SCSI_DATA_IN	0x0800	/* expect data to come INTO memory	*/
#define	SCSI_DATA_OUT	0x1000	/* expect data to flow OUT of memory	*/
#define	SCSI_TARGET	0x2000	/* This defines a TARGET mode op.	*/
#define	SCSI_ESCAPE	0x4000	/* Escape operation			*/
#define SCSI_URGENT     0x8000  /* Urgent operation (e.g., HTAG)        */
@


1.21
log
@Split SDEV_NOSYNCWIDE into SDEV_NOSYNC and SDEV_NOWIDE (as is done
in NetBSD). Look at Inquiry data during probing to further set quirks
based upon device capabilities. Thanks to Todd.Miller@@courtesan.com for
doing the grunt work and encouraging this to get done fully.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.20 1999/11/22 12:55:16 mjacob Exp $	*/
d90 5
@


1.21.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.25 2000/11/23 08:55:35 deraadt Exp $	*/
a55 1
#include <sys/timeout.h>
a91 5
 * Temporary hack 
 */
extern int scsi_autoconf;

/*
a183 1
	u_char	luns;
a251 4
	/*
	 * timeout structure for hba's to use for a command
	 */
	struct timeout stimeout;
d257 17
a273 18
#define	SCSI_NOSLEEP	0x00001	/* don't sleep */
#define	SCSI_POLL	0x00002	/* poll for completion */
#define	SCSI_AUTOCONF	0x00003	/* shorthand for SCSI_POLL | SCSI_NOSLEEP */
#define	SCSI_USER	0x00004	/* Is a user cmd, call scsi_user_done	*/
#define	ITSDONE		0x00008	/* the transfer is as done as it gets	*/
#define	INUSE		0x00010	/* The scsi_xfer block is in use	*/
#define	SCSI_SILENT	0x00020	/* don't announce NOT READY or MEDIA CHANGE */
#define	SCSI_IGNORE_NOT_READY		0x00040	/* ignore NOT READY */
#define	SCSI_IGNORE_MEDIA_CHANGE	0x00080	/* ignore MEDIA CHANGE */
#define	SCSI_IGNORE_ILLEGAL_REQUEST	0x00100	/* ignore ILLEGAL REQUEST */
#define	SCSI_RESET	0x00200	/* Reset the device in question		*/
#define	SCSI_DATA_UIO	0x00400	/* The data address refers to a UIO	*/
#define	SCSI_DATA_IN	0x00800	/* expect data to come INTO memory	*/
#define	SCSI_DATA_OUT	0x01000	/* expect data to flow OUT of memory	*/
#define	SCSI_TARGET	0x02000	/* This defines a TARGET mode op.	*/
#define	SCSI_ESCAPE	0x04000	/* Escape operation			*/
#define SCSI_URGENT     0x08000	/* Urgent operation (e.g., HTAG)        */
#define	SCSI_PRIVATE	0xf0000	/* private to each HBA flags */
@


1.21.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.21.2.1 2001/05/14 22:44:59 niklas Exp $	*/
a90 1
struct scsi_link;
a106 2
	int		(*ioctl) __P((struct scsi_link *, u_long cmd,
			    caddr_t addrp, int flag));
d122 3
a124 3
#define SCSIRET_NOERROR   0	/* No Error */
#define SCSIRET_RETRY    -1	/* Retry the command that got this sense */
#define SCSIRET_CONTINUE -2	/* Continue with standard sense processing */
d168 1
a168 1
#define	SDEV_ATAPI		0x0200	/* device is ATAPI */
d171 14
a184 14
#define	SDEV_AUTOSAVE		0x0001	/* do implicit SAVEDATAPOINTER on disconnect */
#define	SDEV_NOSYNC		0x0002	/* does not grok SDTR */
#define	SDEV_NOWIDE		0x0004	/* does not grok WDTR */
#define	SDEV_NOTAGS		0x0008	/* lies about having tagged queueing */
#define	SDEV_NOLUNS		0x0010	/* does not grok LUNs */
#define	SDEV_FORCELUNS		0x0020	/* prehistoric drive/ctlr groks LUNs */
#define	SDEV_NOMODESENSE	0x0040	/* removable media/optical drives */
#define	SDEV_NOSTARTUNIT	0x0080	/* do not issue start unit requests in sd.c */
#define	SDEV_NOSYNCCACHE	0x0100	/* no SYNCHRONIZE_CACHE */
#define	ADEV_NOSENSE		0x0200	/* No request sense - ATAPI */
#define	ADEV_LITTLETOC		0x0400	/* little-endian TOC - ATAPI */
#define	ADEV_NOCAPACITY		0x0800
#define	ADEV_NOTUR		0x1000
#define	ADEV_NODOORLOCK		0x2000
d284 1
a284 1
#define SCSI_URGENT	0x08000	/* Urgent operation (e.g., HTAG)	*/
d305 2
a306 2
#define XS_SHORTSENSE   6	/* Check the ATAPI sense for the error */
#define XS_RESET	8	/* bus was reset; possible retry command  */
d391 2
a392 1
	rv = (bytes[0] << 8) | bytes[1];
d402 3
a404 1
	rv = (bytes[0] << 16) | (bytes[1] << 8) | bytes[2];
d414 4
a417 2
	rv = (bytes[0] << 24) | (bytes[1] << 16) |
	    (bytes[2] << 8) | bytes[3];
d460 2
a461 1
	rv = bytes[0] | (bytes[1] << 8);
d471 3
a473 1
	rv = bytes[0] | (bytes[1] << 8) | (bytes[2] << 16);
d483 4
a486 2
	rv = bytes[0] | (bytes[1] << 8) |
	    (bytes[2] << 16) | (bytes[3] << 24);
@


1.21.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.21.2.2 2001/07/04 11:00:06 niklas Exp $	*/
a187 1
#define SDEV_NOCDB6		0x4000  /* does not support 6 byte CDB */
a188 1
	u_int8_t inquiry_flags2;	/* copy of flags2 from probe INQUIRY */
d276 1
d312 1
a312 1
	    int, int *));
d314 26
a339 28
void	scsi_init __P((void));
struct scsi_xfer *
	scsi_get_xs __P((struct scsi_link *, int));
void	scsi_free_xs __P((struct scsi_xfer *, int));
int	scsi_execute_xs __P((struct scsi_xfer *));
u_long	scsi_size __P((struct scsi_link *, int));
int	scsi_test_unit_ready __P((struct scsi_link *, int));
int	scsi_change_def __P((struct scsi_link *, int));
int	scsi_inquire __P((struct scsi_link *, struct scsi_inquiry_data *, int));
int	scsi_prevent __P((struct scsi_link *, int, int));
int	scsi_start __P((struct scsi_link *, int, int));
void	scsi_done __P((struct scsi_xfer *));
void	scsi_user_done __P((struct scsi_xfer *));
int	scsi_scsi_cmd __P((struct scsi_link *, struct scsi_generic *,
	    int cmdlen, u_char *data_addr, int datalen, int retries,
	    int timeout, struct buf *bp, int flags));
int	scsi_do_ioctl __P((struct scsi_link *, dev_t, u_long, caddr_t,
	    int, struct proc *));
int	scsi_do_safeioctl __P((struct scsi_link *, dev_t, u_long, caddr_t,
	    int, struct proc *));
void	sc_print_addr __P((struct scsi_link *));

void	show_scsi_xs __P((struct scsi_xfer *));
void	scsi_print_sense __P((struct scsi_xfer *, int));
void	show_scsi_cmd __P((struct scsi_xfer *));
void	show_mem __P((u_char *, int));
int	scsi_probe_busses __P((int, int, int));
void	scsi_strvis __P((u_char *, u_char *, int));
@


1.21.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d109 1
a109 1
			    caddr_t addrp, int flag, struct proc *p));
@


1.21.2.5
log
@Merge in -current from roughly a week ago
@
text
@d104 6
a109 6
	int		(*scsi_cmd)(struct scsi_xfer *);
	void		(*scsi_minphys)(struct buf *);
	int		(*open_target_lu)(void);
	int		(*close_target_lu)(void);
	int		(*ioctl)(struct scsi_link *, u_long cmd,
			    caddr_t addrp, int flag, struct proc *p);
d135 1
a135 1
	int	(*err_handler)(struct scsi_xfer *);
d137 1
a137 1
	void	(*start)(void *);
d139 1
a139 1
	int	(*async)(void);
d146 1
a146 1
	void	(*done)(struct scsi_xfer *);
d198 1
a198 1
int	scsiprint(void *, const char *);
d312 2
a313 2
caddr_t scsi_inqmatch(struct scsi_inquiry_data *, caddr_t, int,
	    int, int *);
d315 1
a315 1
void	scsi_init(void);
d317 12
a328 12
	scsi_get_xs(struct scsi_link *, int);
void	scsi_free_xs(struct scsi_xfer *, int);
int	scsi_execute_xs(struct scsi_xfer *);
u_long	scsi_size(struct scsi_link *, int);
int	scsi_test_unit_ready(struct scsi_link *, int);
int	scsi_change_def(struct scsi_link *, int);
int	scsi_inquire(struct scsi_link *, struct scsi_inquiry_data *, int);
int	scsi_prevent(struct scsi_link *, int, int);
int	scsi_start(struct scsi_link *, int, int);
void	scsi_done(struct scsi_xfer *);
void	scsi_user_done(struct scsi_xfer *);
int	scsi_scsi_cmd(struct scsi_link *, struct scsi_generic *,
d330 27
a356 27
	    int timeout, struct buf *bp, int flags);
int	scsi_do_ioctl(struct scsi_link *, dev_t, u_long, caddr_t,
	    int, struct proc *);
int	scsi_do_safeioctl(struct scsi_link *, dev_t, u_long, caddr_t,
	    int, struct proc *);
void	sc_print_addr(struct scsi_link *);

void	show_scsi_xs(struct scsi_xfer *);
void	scsi_print_sense(struct scsi_xfer *, int);
void	show_scsi_cmd(struct scsi_xfer *);
void	show_mem(u_char *, int);
int	scsi_probe_busses(int, int, int);
void	scsi_strvis(u_char *, u_char *, int);

static __inline void _lto2b(u_int32_t val, u_int8_t *bytes);
static __inline void _lto3b(u_int32_t val, u_int8_t *bytes);
static __inline void _lto4b(u_int32_t val, u_int8_t *bytes);
static __inline u_int32_t _2btol(u_int8_t *bytes);
static __inline u_int32_t _3btol(u_int8_t *bytes);
static __inline u_int32_t _4btol(u_int8_t *bytes);

static __inline void _lto2l(u_int32_t val, u_int8_t *bytes);
static __inline void _lto3l(u_int32_t val, u_int8_t *bytes);
static __inline void _lto4l(u_int32_t val, u_int8_t *bytes);
static __inline u_int32_t _2ltol(u_int8_t *bytes);
static __inline u_int32_t _3ltol(u_int8_t *bytes);
static __inline u_int32_t _4ltol(u_int8_t *bytes);
@


1.21.2.6
log
@Sync the SMP branch with 3.3
@
text
@d100 2
a101 2
 * whatever low-end drivers they are attached to.  Each adapter type has one
 * of these statically allocated.
d169 1
a169 1
#define	SDEV_DBX		0x00f0	/* debugging flags (scsi_debug.h) */
d214 5
a218 5
 * It holds pointers to allow the scsi bus to get to the driver
 * that is running each LUN on the bus.
 * It also has a template entry which is the prototype struct
 * supplied by the adapter driver.  This is used to initialise
 * the others, before they have the rest of the fields filled in.
d238 1
a238 1
 * Each scsi transaction is fully described by one of these structures.
d292 1
a292 1
 * Escape op-codes.  This provides an extensible setup for operations
a311 6
/*
 * Possible retries numbers for scsi_test_unit_ready()
 */
#define TEST_READY_RETRIES_DEFAULT	5
#define TEST_READY_RETRIES_CD		10

d318 1
a318 1
void	scsi_free_xs(struct scsi_xfer *);
d321 1
a321 1
int	scsi_test_unit_ready(struct scsi_link *, int, int);
@


1.21.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.21.2.6 2003/03/28 00:08:47 niklas Exp $	*/
d185 4
a188 4
#define	ADEV_NOCAPACITY		0x0800	/* no READ CD CAPACITY */
#define	ADEV_NOTUR		0x1000	/* No TEST UNIT READY */
#define	ADEV_NODOORLOCK		0x2000	/* can't lock door */
#define SDEV_ONLYBIG		0x4000  /* always use READ_BIG and WRITE_BIG */
d318 1
a318 1
const void *scsi_inqmatch(struct scsi_inquiry_data *, const void *, int,
@


1.21.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d178 2
d224 1
@


1.21.2.9
log
@Merge with the trunk
@
text
@a98 15
 * Specify which buses and targets must scan all LUNs, even when IDENTIFY does
 * not seem to be working. Some devices (e.g. some external RAID devices) may
 * seem to have non-functional IDENTIFY because they return identical INQUIRY
 * data for all LUNs.
 */
#ifndef SCSIFORCELUN_BUSES
#define SCSIFORCELUN_BUSES	0
#endif
#ifndef SCSIFORCELUN_TARGETS
#define	SCSIFORCELUN_TARGETS	0
#endif

extern int scsiforcelun_buses, scsiforcelun_targets;

/*
d121 9
d179 1
d188 1
d341 1
a341 1
void	scsi_print_sense(struct scsi_xfer *);
@


1.20
log
@In order to support Fibre Channel fabric fatten scsi target id's to 16 bits.
Also, to support at least first level SCSI-3 hierarchical luns, fatten luns
to 16 bits too.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.19 1999/07/25 07:09:19 csapuntz Exp $	*/
d161 3
a163 2
#define SDEV_EJECTING		0x0100	/* eject on device close */
#define SDEV_ATAPI              0x0200  /* device is ATAPI */
d166 13
a178 12
#define	SDEV_NOSYNCWIDE	      0x0002	/* does not grok SDTR or WDTR */
#define	SDEV_NOLUNS	      0x0004	/* does not grok LUNs */
#define	SDEV_FORCELUNS	      0x0008	/* prehistoric drive/ctlr groks LUNs */
#define	SDEV_NOMODESENSE      0x0010	/* removable media/optical drives */
#define	SDEV_NOSTARTUNIT      0x0020	/* do not issue start unit requests in sd.c */
#define	SDEV_NOTAGS	      0x0040	/* lies about having tagged queueing */
#define ADEV_NOSENSE          0x0080    /* No request sense - ATAPI */
#define ADEV_LITTLETOC        0x0100    /* little-endian TOC - ATAPI */
#define ADEV_NOCAPACITY       0x0200
#define ADEV_NOTUR            0x0400
#define ADEV_NODOORLOCK       0x0800
#define SDEV_NOSYNCCACHE      0x1000    /* no SYNCHRONIZE_CACHE */
@


1.19
log
@

Merge sd stuff from NetBSD-current. Helps with LS-120, ZIP

More SCSI logic from NetBSD-current

Some tape fixes. ATAPI tapes do not work yet for most operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.18 1999/07/20 06:21:59 csapuntz Exp $	*/
d149 6
a154 6
	u_int8_t target;		/* targ of this dev */
	u_int8_t lun;			/* lun of this dev */
	u_int8_t adapter_target;	/* what are we on the scsi bus */
	u_int8_t adapter_buswidth;	/* 8 (regular) or 16 (wide). (0 becomes 8) */
	u_int8_t openings;		/* available operations */
	u_int8_t active;		/* operations in progress */
d211 1
a211 1
	u_int8_t sc_buswidth;
@


1.18
log
@

Make acd redundant.

Mostly based on NetBSD-current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.17 1999/07/18 22:49:41 csapuntz Exp $	*/
d112 9
d176 1
a176 1

d271 1
d291 2
@


1.17
log
@

Added SDEV_NOSENSE for ATAPI devices without request sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.16 1998/08/04 22:35:05 millert Exp $	*/
d153 14
a166 9
	u_int8_t quirks;		/* per-device oddities */
#define	SDEV_AUTOSAVE		0x01	/* do implicit SAVEDATAPOINTER on disconnect */
#define	SDEV_NOSYNCWIDE		0x02	/* does not grok SDTR or WDTR */
#define	SDEV_NOLUNS		0x04	/* does not grok LUNs */
#define	SDEV_FORCELUNS		0x08	/* prehistoric drive/ctlr groks LUNs */
#define	SDEV_NOMODESENSE	0x10	/* removable media/optical drives */
#define	SDEV_NOSTARTUNIT	0x20	/* do not issue start unit requests in sd.c */
#define	SDEV_NOTAGS		0x40	/* lies about having tagged queueing */
#define SDEV_NOSENSE            0x80    /* No request sense - ATAPI */
@


1.16
log
@make resid size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.15 1998/02/16 21:23:26 deraadt Exp $	*/
d161 2
@


1.15
log
@add SDEV_NOTAGS
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.14 1997/09/05 05:56:50 millert Exp $	*/
d223 1
a223 1
	int	resid;			/* how much buffer was not touched */
@


1.14
log
@Add SCSITERSE option which omits the (large) ASC/ASCQ table.
Old scsi error printing code is now gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.13 1997/08/22 04:43:26 millert Exp $	*/
d158 3
a160 2
#define SDEV_NOMODESENSE	0x10	/* removable media/optical drives */
#define SDEV_NOSTARTUNIT	0x20	/* do not issue start unit requests in sd.c */
@


1.13
log
@Add more detailed SCSI error printing by Matthew Jacob.  Enabled by
default.  Use "option SCSIVERBOSE=0" to turn off (only added 8Kb to my kernel).
From the NetBSD commit message:
    Add in more detailed SCSI error printing, based off of final SCSI-2 spec.
    This will also print out things like progress indicator errors, and will
    also dump out additional sense bytes that haven't been decoded.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.12 1997/04/14 04:09:15 downsj Exp $	*/
a297 1
#if	SCSIVERBOSE
a298 1
#endif
@


1.12
log
@Merge in various pieces of current NetBSD scsi code, including but not limited
to:

* New changer driver.
* Better optical support.
* Different `done' semantics.
* New quirks for SCSI QIC tape driver, SCSI floppy drives.
* Better support for SCSI-I devices.

Everybody needs to test this.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.11 1997/01/18 16:18:32 briggs Exp $	*/
d298 3
@


1.11
log
@scsi->moreluns is a bitfield based on target--should be u_int16_t, now.
@
text
@d1 2
a2 2
/*	$OpenBSD: scsiconf.h,v 1.10 1997/01/16 14:23:33 maja Exp $	*/
/*	$NetBSD: scsiconf.h,v 1.29 1996/03/19 03:07:50 mycroft Exp $	*/
d128 1
a128 1
	int	(*done)  __P((struct scsi_xfer *, int));
d138 1
d159 1
@


1.10
log
@Added scsiprint from NetBSD, needed by new driver for VAX. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.9 1997/01/15 05:50:29 deraadt Exp $	*/
d191 1
a191 1
	u_int8_t moreluns;
@


1.9
log
@sc_link.adapter_buswidth, set to 16 if wide scsi. if 0 it gets converted
to 8 internally so that drivers do not need to init it for regular scsi :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.8 1996/10/31 01:09:25 niklas Exp $	*/
d164 2
@


1.8
log
@$OpenBSD RCSIDs + comment fix in sd.c
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.h,v 1.29 1996/03/19 03:07:50 mycroft Exp $	*/
d142 1
d188 1
a188 1
	struct scsi_link *sc_link[8][8];
d190 1
@


1.7
log
@limit ioctl priviledges
@
text
@d1 1
@


1.6
log
@Several changes:
	* Implemented NetBSD PR#2529, adding ZIP 100.
	* Added MTIOCTOP support to acd, cd, and sd.
	* Implemented eject on close for acd, cd, and sd.

`mt -f /dev/rcd0d offline' now ejects a mounted {acd|cd|sd} when it is
unmounted.
@
text
@d267 2
a268 1
caddr_t scsi_inqmatch __P((struct scsi_inquiry_data *, caddr_t, int, int, int *));
d282 6
a287 5
			int cmdlen, u_char *data_addr,
			int datalen, int retries,
			int timeout, struct buf *bp,
			int flags));
int scsi_do_ioctl __P((struct scsi_link *, dev_t, u_long, caddr_t, int, struct proc *));
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d143 7
a149 6
	u_int8_t flags;			/* flags that all devices have */
#define	SDEV_REMOVABLE	 	0x01	/* media is removable */
#define	SDEV_MEDIA_LOADED 	0x02	/* device figures are still valid */
#define	SDEV_WAITING	 	0x04	/* a process is waiting for this */
#define	SDEV_OPEN	 	0x08	/* at least 1 open session */
#define	SDEV_DBX		0xf0	/* debuging flags (scsi_debug.h) */
d155 1
@


1.4
log
@Sync. with NetBSD:
- scsi prototypes.
- Add SCSI scanner support by Kenneth Stailey and Joachim Koenig-Baltes,
  hacked a but.  Needs more work.
ss.c:
- Truncate to the window size in ssminphys(), not ssread().
- Missed some prototyping foo.
- Minor tweak; make sure window size is 0 on close.
- Change variable name to avoid GCC warning.
- Handle EOF a little differently.
@
text
@d1 1
a1 1
/*	$NetBSD: scsiconf.h,v 1.28 1996/02/18 20:32:45 mycroft Exp $	*/
d292 151
a442 3

void lto3b __P((u_int32_t val, u_int8_t *bytes));
u_int32_t _3btol __P((u_int8_t *bytes));
@


1.3
log
@From NetBSD: (required for last change to scsi_base.c in case we get
	      "command aborted" status)
Handle cases like the following:
        - controller calls scsi_done() with error XS_TIMEOUT
        - scsi_done() calls sddone()
        - sddone() calls disk_unbusy()
        - scsi_done() calls controller to retry command (missing the
          call to disk_busy())
        - controller calls scsi_done()
        - scsi_done() calls sddone()
        - sddone() calls disk_busy(), which panics because of the imbalance.
Bug noticed by Leo Weppleman, who also suggested this fix; pass an additional
boolean argument ("complete") to the device's "done" routine, with a
value of `0' passed from the previous call to "done", and add an additional
call to "done" when the xfer resources are freed.
@
text
@d1 1
a1 1
/*	$NetBSD: scsiconf.h,v 1.26 1996/01/12 22:43:31 thorpej Exp $	*/
d87 2
d96 1
a96 1
	int		(*scsi_cmd)();
d98 2
a99 2
	int		(*open_target_lu)();
	int		(*close_target_lu)();
d116 5
a120 3
	int	(*err_handler)(); /* returns -1 to say err processing done */
	void	(*start)();
	int	(*async)();
d127 1
a127 1
	int	(*done)( /* struct scsi_xfer *, int */ );
d277 1
d289 3
@


1.2
log
@Save inquiry flags in sc_link so low-level drivers can use it.
@
text
@d1 1
a1 1
/*	$NetBSD: scsiconf.h,v 1.25 1995/08/12 20:31:44 mycroft Exp $	*/
d117 7
a123 1
	int	(*done)();	/* returns -1 to say done processing done */
@


1.1
log
@Initial revision
@
text
@d144 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
