head	1.55;
access;
symbols
	OPENBSD_6_0:1.55.0.4
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.54.0.6
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.51.0.14
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.51.0.10
	OPENBSD_5_4_BASE:1.51
	OPENBSD_5_3:1.51.0.8
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.51.0.6
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.4
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.47.0.8
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.47.0.10
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.47.0.6
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.47.0.4
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.39.0.2
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.2.0.4
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.8
	OPENBSD_2_8:1.1.0.6
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.55
date	2015.08.23.01.55.39;	author tedu;	state Exp;
branches;
next	1.54;
commitid	OczmFvlAy5J4Utsq;

1.54
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.53;
commitid	uzzBR7hz9ncd4O6G;

1.53
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.52;
commitid	jdBY2kKXhfcoQitp;

1.52
date	2014.07.12.18.50.25;	author tedu;	state Exp;
branches;
next	1.51;
commitid	iN7nvia2fLP712wt;

1.51
date	2011.03.17.21.30.24;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2010.08.30.02.47.56;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	2010.08.02.23.00.54;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.22.00.31.06;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.16.01.30.24;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.07.16.15.49;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.04.23.44.37;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2006.10.01.10.42.18;	author grange;	state Exp;
branches;
next	1.39;

1.39
date	2006.07.29.02.40.46;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.16.22.08.59;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.09.05.51.54;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2006.04.20.20.31.13;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.19.17.08.40;	author grange;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.11.08.21.21;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.13.02.38.27;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.13.02.21.42;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.12.08.09.47;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.12.08.06.45;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.29.07.19.35;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2005.08.23.23.44.28;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.23.05.29.41;	author marco;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.22.19.24.45;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2005.08.18.21.04.47;	author marco;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.18.12.26.39;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.13.01.38.19;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.10.10.55.33;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.09.11.37.02;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.08.18.42.08;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.05.03.20.26;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.05.00.34.51;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.04.14.31.53;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.04.14.28.51;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.04.02.14.30;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.03.15.34.13;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.03.15.00.26;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.02.03.35.14;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.01.23.14.31;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.31.06.22.56;	author dlg;	state dead;
branches;
next	1.7;

1.7
date	2004.05.09.04.01.59;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.03.14.08.54;	author espie;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.06.21.08.07;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.15.18.19.53;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.22.14.35.43;	author deraadt;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.02.21.08.23.30;	author mjacob;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.02.21.22.29.15;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.04.11.00.08;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2004.02.19.11.01.31;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2004.06.05.23.13.08;	author niklas;	state Exp;
branches;
next	;

1.2.4.1
date	2002.06.11.03.32.14;	author art;	state Exp;
branches;
next	;


desc
@@


1.55
log
@add some sizes to free. looked over by deraadt
@
text
@/*	$OpenBSD: ses.c,v 1.54 2014/09/14 14:17:26 jsg Exp $ */

/*
 * Copyright (c) 2005 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/scsiio.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/rwlock.h>
#include <sys/queue.h>
#include <sys/sensors.h>

#if NBIO > 0
#include <dev/biovar.h>
#endif

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <scsi/ses.h>

#ifdef SES_DEBUG
#define DPRINTF(x...)		do { if (sesdebug) printf(x); } while (0)
#define DPRINTFN(n, x...)	do { if (sesdebug > (n)) printf(x); } while (0)
int	sesdebug = 2;
#else
#define DPRINTF(x...)		/* x */
#define DPRINTFN(n,x...)	/* n: x */
#endif

int	ses_match(struct device *, void *, void *);
void	ses_attach(struct device *, struct device *, void *);
int	ses_detach(struct device *, int);

struct ses_sensor {
	struct ksensor		se_sensor;
	u_int8_t		se_type;
	struct ses_status	*se_stat;

	TAILQ_ENTRY(ses_sensor)	se_entry;
};

#if NBIO > 0
struct ses_slot {
	struct ses_status	*sl_stat;

	TAILQ_ENTRY(ses_slot)	sl_entry;
};
#endif

struct ses_softc {
	struct device		sc_dev;
	struct scsi_link	*sc_link;
	struct rwlock		sc_lock;

	enum {
		SES_ENC_STD,
		SES_ENC_DELL
	}			sc_enctype;

	u_char			*sc_buf;
	ssize_t			sc_buflen;

#if NBIO > 0
	TAILQ_HEAD(, ses_slot)	sc_slots;
#endif
	TAILQ_HEAD(, ses_sensor) sc_sensors;
	struct ksensordev	sc_sensordev;
	struct sensor_task	*sc_sensortask;
};

struct cfattach ses_ca = {
	sizeof(struct ses_softc), ses_match, ses_attach, ses_detach
};

struct cfdriver ses_cd = {
	NULL, "ses", DV_DULL
};

#define DEVNAME(s)	((s)->sc_dev.dv_xname)

#define SES_BUFLEN	2048 /* XXX is this enough? */

int	ses_read_config(struct ses_softc *);
int	ses_read_status(struct ses_softc *);
int	ses_make_sensors(struct ses_softc *, struct ses_type_desc *, int);
void	ses_refresh_sensors(void *);

#if NBIO > 0
int	ses_ioctl(struct device *, u_long, caddr_t);
int	ses_write_config(struct ses_softc *);
int	ses_bio_blink(struct ses_softc *, struct bioc_blink *);
#endif

void	ses_psu2sensor(struct ses_softc *, struct ses_sensor *);
void	ses_cool2sensor(struct ses_softc *, struct ses_sensor *);
void	ses_temp2sensor(struct ses_softc *, struct ses_sensor *);

#ifdef SES_DEBUG
void	ses_dump_enc_desc(struct ses_enc_desc *);
char	*ses_dump_enc_string(u_char *, ssize_t);
#endif

int
ses_match(struct device *parent, void *match, void *aux)
{
	struct scsi_attach_args		*sa = aux;
	struct scsi_inquiry_data	*inq = sa->sa_inqbuf;

	if (inq == NULL)
		return (0);

	if ((inq->device & SID_TYPE) == T_ENCLOSURE &&
	    SCSISPC(inq->version) >= 2)
		return (2);

	/* match on dell enclosures */
	if ((inq->device & SID_TYPE) == T_PROCESSOR &&
	    SCSISPC(inq->version) == 3)
		return (3);

	return (0);
}

void
ses_attach(struct device *parent, struct device *self, void *aux)
{
	struct ses_softc		*sc = (struct ses_softc *)self;
	struct scsi_attach_args		*sa = aux;
	char				vendor[33];
	struct ses_sensor		*sensor;
#if NBIO > 0
	struct ses_slot			*slot;
#endif

	sc->sc_link = sa->sa_sc_link;
	sa->sa_sc_link->device_softc = sc;
	rw_init(&sc->sc_lock, DEVNAME(sc));

	scsi_strvis(vendor, sc->sc_link->inqdata.vendor,
	    sizeof(sc->sc_link->inqdata.vendor));
	if (strncasecmp(vendor, "Dell", sizeof(vendor)) == 0)
		sc->sc_enctype = SES_ENC_DELL;
	else
		sc->sc_enctype = SES_ENC_STD;

	printf("\n");

	if (ses_read_config(sc) != 0) {
		printf("%s: unable to read enclosure configuration\n",
		    DEVNAME(sc));
		return;
	}

	if (!TAILQ_EMPTY(&sc->sc_sensors)) {
		sc->sc_sensortask = sensor_task_register(sc,
		    ses_refresh_sensors, 10);
		if (sc->sc_sensortask == NULL) {
			printf("%s: unable to register update task\n",
			    DEVNAME(sc));
			while (!TAILQ_EMPTY(&sc->sc_sensors)) {
				sensor = TAILQ_FIRST(&sc->sc_sensors);
				TAILQ_REMOVE(&sc->sc_sensors, sensor,
				    se_entry);
				free(sensor, M_DEVBUF, sizeof(*sensor));
			}
		} else {
			TAILQ_FOREACH(sensor, &sc->sc_sensors, se_entry)
				sensor_attach(&sc->sc_sensordev,
				    &sensor->se_sensor);
			sensordev_install(&sc->sc_sensordev);
		}
	}

#if NBIO > 0
	if (!TAILQ_EMPTY(&sc->sc_slots) &&
	    bio_register(self, ses_ioctl) != 0) {
		printf("%s: unable to register ioctl\n", DEVNAME(sc));
		while (!TAILQ_EMPTY(&sc->sc_slots)) {
			slot = TAILQ_FIRST(&sc->sc_slots);
			TAILQ_REMOVE(&sc->sc_slots, slot, sl_entry);
			free(slot, M_DEVBUF, sizeof(*slot));
		}
	}
#endif

	if (TAILQ_EMPTY(&sc->sc_sensors)
#if NBIO > 0
	    && TAILQ_EMPTY(&sc->sc_slots)
#endif
	    ) {
		dma_free(sc->sc_buf, sc->sc_buflen);
		sc->sc_buf = NULL;
	}
}

int
ses_detach(struct device *self, int flags)
{
	struct ses_softc		*sc = (struct ses_softc *)self;
	struct ses_sensor		*sensor;
#if NBIO > 0
	struct ses_slot			*slot;
#endif

	rw_enter_write(&sc->sc_lock);

#if NBIO > 0
	if (!TAILQ_EMPTY(&sc->sc_slots)) {
		bio_unregister(self);
		while (!TAILQ_EMPTY(&sc->sc_slots)) {
			slot = TAILQ_FIRST(&sc->sc_slots);
			TAILQ_REMOVE(&sc->sc_slots, slot, sl_entry);
			free(slot, M_DEVBUF, sizeof(*slot));
		}
	}
#endif

	if (!TAILQ_EMPTY(&sc->sc_sensors)) {
		sensordev_deinstall(&sc->sc_sensordev);
		sensor_task_unregister(sc->sc_sensortask);

		while (!TAILQ_EMPTY(&sc->sc_sensors)) {
			sensor = TAILQ_FIRST(&sc->sc_sensors);
			sensor_detach(&sc->sc_sensordev, &sensor->se_sensor);
			TAILQ_REMOVE(&sc->sc_sensors, sensor, se_entry);
			free(sensor, M_DEVBUF, sizeof(*sensor));
		}
	}

	if (sc->sc_buf != NULL)
		dma_free(sc->sc_buf, sc->sc_buflen);

	rw_exit_write(&sc->sc_lock);

	return (0);
}

int
ses_read_config(struct ses_softc *sc)
{
	struct ses_scsi_diag *cmd;
	struct ses_config_hdr *cfg;
	struct ses_type_desc *tdh, *tdlist;
#ifdef SES_DEBUG
	struct ses_enc_desc *desc;
#endif
	struct ses_enc_hdr *enc;
	struct scsi_xfer *xs;
	u_char *buf, *p;
	int error = 0, i;
	int flags = 0, ntypes = 0, nelems = 0;

	buf = dma_alloc(SES_BUFLEN, PR_NOWAIT | PR_ZERO);
	if (buf == NULL)
		return (1);

	if (cold)
		flags |= SCSI_AUTOCONF;
	xs = scsi_xs_get(sc->sc_link, flags | SCSI_DATA_IN | SCSI_SILENT);
	if (xs == NULL) {
		error = 1;
		goto done;
	}
	xs->cmdlen = sizeof(*cmd);
	xs->data = buf;
	xs->datalen = SES_BUFLEN;
	xs->retries = 2;
	xs->timeout = 3000;

	cmd = (struct ses_scsi_diag *)xs->cmd;
	cmd->opcode = RECEIVE_DIAGNOSTIC;
	cmd->flags |= SES_DIAG_PCV;
	cmd->pgcode = SES_PAGE_CONFIG;
	cmd->length = htobe16(SES_BUFLEN);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error) {
		error = 1;
		goto done;
	}

	cfg = (struct ses_config_hdr *)buf;
	if (cfg->pgcode != SES_PAGE_CONFIG || betoh16(cfg->length) >
	    SES_BUFLEN) {
		error = 1;
		goto done;
	}

	DPRINTF("%s: config: n_subenc: %d length: %d\n", DEVNAME(sc),
	    cfg->n_subenc, betoh16(cfg->length));

	p = buf + SES_CFG_HDRLEN;
	for (i = 0; i <= cfg->n_subenc; i++) {
		enc = (struct ses_enc_hdr *)p;
#ifdef SES_DEBUG
		DPRINTF("%s: enclosure %d enc_id: 0x%02x n_types: %d\n",
		    DEVNAME(sc), i, enc->enc_id, enc->n_types);
		desc = (struct ses_enc_desc *)(p + SES_ENC_HDRLEN);
		ses_dump_enc_desc(desc);
#endif /* SES_DEBUG */

		ntypes += enc->n_types;

		p += SES_ENC_HDRLEN + enc->vendor_len;
	}

	tdlist = (struct ses_type_desc *)p; /* stash this for later */

	for (i = 0; i < ntypes; i++) {
		tdh = (struct ses_type_desc *)p;
		DPRINTF("%s: td %d subenc_id: %d type 0x%02x n_elem: %d\n",
		    DEVNAME(sc), i, tdh->subenc_id, tdh->type, tdh->n_elem);

		nelems += tdh->n_elem;

		p += SES_TYPE_DESCLEN;
	}

#ifdef SES_DEBUG
	for (i = 0; i < ntypes; i++) {
		DPRINTF("%s: td %d '%s'\n", DEVNAME(sc), i,
		    ses_dump_enc_string(p, tdlist[i].desc_len));

		p += tdlist[i].desc_len;
	}
#endif /* SES_DEBUG */

	sc->sc_buflen = SES_STAT_LEN(ntypes, nelems);
	sc->sc_buf = dma_alloc(sc->sc_buflen, PR_NOWAIT);
	if (sc->sc_buf == NULL) {
		error = 1;
		goto done;
	}

	/* get the status page and then use it to generate a list of sensors */
	if (ses_make_sensors(sc, tdlist, ntypes) != 0) {
		dma_free(sc->sc_buf, sc->sc_buflen);
		error = 1;
		goto done;
	}

done:
	if (buf)
		dma_free(buf, SES_BUFLEN);
	return (error);
}

int
ses_read_status(struct ses_softc *sc)
{
	struct ses_scsi_diag *cmd;
	struct scsi_xfer *xs;
	int error, flags = 0;

	if (cold)
		flags |= SCSI_AUTOCONF;
	xs = scsi_xs_get(sc->sc_link, flags | SCSI_DATA_IN | SCSI_SILENT);
	if (xs == NULL)
		return (1);
	xs->cmdlen = sizeof(*cmd);
	xs->data = sc->sc_buf;
	xs->datalen = sc->sc_buflen;
	xs->retries = 2;
	xs->timeout = 3000;

	cmd = (struct ses_scsi_diag *)xs->cmd;
	cmd->opcode = RECEIVE_DIAGNOSTIC;
	cmd->flags |= SES_DIAG_PCV;
	cmd->pgcode = SES_PAGE_STATUS;
	cmd->length = htobe16(sc->sc_buflen);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error != 0)
		return (1);

	return (0);
}

int
ses_make_sensors(struct ses_softc *sc, struct ses_type_desc *types, int ntypes)
{
	struct ses_status		*status;
	struct ses_sensor		*sensor;
#if NBIO > 0
	struct ses_slot			*slot;
#endif
	enum sensor_type		stype;
	char				*fmt;
	int				i, j;

	if (ses_read_status(sc) != 0)
		return (1);

	strlcpy(sc->sc_sensordev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensordev.xname));

	TAILQ_INIT(&sc->sc_sensors);
#if NBIO > 0
	TAILQ_INIT(&sc->sc_slots);
#endif

	status = (struct ses_status *)(sc->sc_buf + SES_STAT_HDRLEN);
	for (i = 0; i < ntypes; i++) {
		/* ignore the overall status element for this type */
		DPRINTFN(1, "%s: %3d:-   0x%02x 0x%02x%02x%02x type: 0x%02x\n",
		     DEVNAME(sc), i, status->com, status->f1, status->f2,
		    status->f3, types[i].type);

		for (j = 0; j < types[i].n_elem; j++) {
			/* move to the current status element */
			status++;

			DPRINTFN(1, "%s: %3d:%-3d 0x%02x 0x%02x%02x%02x\n",
			    DEVNAME(sc), i, j, status->com, status->f1,
			    status->f2, status->f3);

			if (SES_STAT_CODE(status->com) == SES_STAT_CODE_NOTINST)
				continue;

			switch (types[i].type) {
#if NBIO > 0
			case SES_T_DEVICE:
				slot = malloc(sizeof(*slot), M_DEVBUF,
				    M_NOWAIT | M_ZERO);
				if (slot == NULL)
					goto error;

				slot->sl_stat = status;

				TAILQ_INSERT_TAIL(&sc->sc_slots, slot,
				    sl_entry);

				continue;
#endif

			case SES_T_POWERSUPPLY:
				stype = SENSOR_INDICATOR;
				fmt = "PSU";
				break;

			case SES_T_COOLING:
				stype = SENSOR_PERCENT;
				fmt = "Fan";
				break;

			case SES_T_TEMP:
				stype = SENSOR_TEMP;
				fmt = "";
				break;

			default:
				continue;
			}

			sensor = malloc(sizeof(*sensor), M_DEVBUF,
			    M_NOWAIT | M_ZERO);
			if (sensor == NULL)
				goto error;

			sensor->se_type = types[i].type;
			sensor->se_stat = status;
			sensor->se_sensor.type = stype;
			strlcpy(sensor->se_sensor.desc, fmt,
			    sizeof(sensor->se_sensor.desc));

			TAILQ_INSERT_TAIL(&sc->sc_sensors, sensor, se_entry);
		}

		/* move to the overall status element of the next type */
		status++;
	}

	return (0);
error:
#if NBIO > 0
	while (!TAILQ_EMPTY(&sc->sc_slots)) {
		slot = TAILQ_FIRST(&sc->sc_slots);
		TAILQ_REMOVE(&sc->sc_slots, slot, sl_entry);
		free(slot, M_DEVBUF, sizeof(*slot));
	}
#endif
	while (!TAILQ_EMPTY(&sc->sc_sensors)) {
		sensor = TAILQ_FIRST(&sc->sc_sensors);
		TAILQ_REMOVE(&sc->sc_sensors, sensor, se_entry);
		free(sensor, M_DEVBUF, sizeof(*sensor));
	}
	return (1);
}

void
ses_refresh_sensors(void *arg)
{
	struct ses_softc		*sc = (struct ses_softc *)arg;
	struct ses_sensor		*sensor;
	int				ret = 0;

	rw_enter_write(&sc->sc_lock);

	if (ses_read_status(sc) != 0) {
		rw_exit_write(&sc->sc_lock);
		return;
	}

	TAILQ_FOREACH(sensor, &sc->sc_sensors, se_entry) {
		DPRINTFN(10, "%s: %s 0x%02x 0x%02x%02x%02x\n", DEVNAME(sc),
		    sensor->se_sensor.desc, sensor->se_stat->com,
		    sensor->se_stat->f1, sensor->se_stat->f2,
		    sensor->se_stat->f3);

		switch (SES_STAT_CODE(sensor->se_stat->com)) {
		case SES_STAT_CODE_OK:
			sensor->se_sensor.status = SENSOR_S_OK;
			break;

		case SES_STAT_CODE_CRIT:
		case SES_STAT_CODE_UNREC:
			sensor->se_sensor.status = SENSOR_S_CRIT;
			break;

		case SES_STAT_CODE_NONCRIT:
			sensor->se_sensor.status = SENSOR_S_WARN;
			break;

		case SES_STAT_CODE_NOTINST:
		case SES_STAT_CODE_UNKNOWN:
		case SES_STAT_CODE_NOTAVAIL:
			sensor->se_sensor.status = SENSOR_S_UNKNOWN;
			break;
		}

		switch (sensor->se_type) {
		case SES_T_POWERSUPPLY:
			ses_psu2sensor(sc, sensor);
			break;

		case SES_T_COOLING:
			ses_cool2sensor(sc, sensor);
			break;

		case SES_T_TEMP:
			ses_temp2sensor(sc, sensor);
			break;

		default:
			ret = 1;
			break;
		}
	}

	rw_exit_write(&sc->sc_lock);

	if (ret)
		printf("%s: error in sensor data\n", DEVNAME(sc));
}

#if NBIO > 0
int
ses_ioctl(struct device *dev, u_long cmd, caddr_t addr)
{
	struct ses_softc		*sc = (struct ses_softc *)dev;
	int				error = 0;

	switch (cmd) {
	case BIOCBLINK:
		error = ses_bio_blink(sc, (struct bioc_blink *)addr);
		break;

	default:
		error = EINVAL;
		break;
	}

	return (error);
}

int
ses_write_config(struct ses_softc *sc)
{
	struct ses_scsi_diag *cmd;
	struct scsi_xfer *xs;
	int error, flags = 0;

	if (cold)
		flags |= SCSI_AUTOCONF;

	xs = scsi_xs_get(sc->sc_link, flags | SCSI_DATA_OUT | SCSI_SILENT);
	if (xs == NULL)
		return (1);
	xs->cmdlen = sizeof(*cmd);
	xs->data = sc->sc_buf;
	xs->datalen = sc->sc_buflen;
	xs->retries = 2;
	xs->timeout = 3000;

	cmd = (struct ses_scsi_diag *)xs->cmd;
	cmd->opcode = SEND_DIAGNOSTIC;
	cmd->flags |= SES_DIAG_PF;
	cmd->length = htobe16(sc->sc_buflen);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error != 0)
		return (1);

	return (0);
}

int
ses_bio_blink(struct ses_softc *sc, struct bioc_blink *blink)
{
	struct ses_slot			*slot;

	rw_enter_write(&sc->sc_lock);

	if (ses_read_status(sc) != 0) {
		rw_exit_write(&sc->sc_lock);
		return (EIO);
	}

	TAILQ_FOREACH(slot, &sc->sc_slots, sl_entry) {
		if (slot->sl_stat->f1 == blink->bb_target)
			break;
	}

	if (slot == NULL) {
		rw_exit_write(&sc->sc_lock);
		return (EINVAL);
	}

	DPRINTFN(3, "%s: 0x%02x 0x%02x 0x%02x 0x%02x\n", DEVNAME(sc),
	    slot->sl_stat->com, slot->sl_stat->f1, slot->sl_stat->f2,
	    slot->sl_stat->f3);

	slot->sl_stat->com = SES_STAT_SELECT;
	slot->sl_stat->f2 &= SES_C_DEV_F2MASK;
	slot->sl_stat->f3 &= SES_C_DEV_F3MASK;

	switch (blink->bb_status) {
	case BIOC_SBUNBLINK:
		slot->sl_stat->f2 &= ~SES_C_DEV_IDENT;
		break;

	case BIOC_SBBLINK:
		slot->sl_stat->f2 |= SES_C_DEV_IDENT;
		break;

	default:
		rw_exit_write(&sc->sc_lock);
		return (EINVAL);
	}

	DPRINTFN(3, "%s: 0x%02x 0x%02x 0x%02x 0x%02x\n", DEVNAME(sc),
	    slot->sl_stat->com, slot->sl_stat->f1, slot->sl_stat->f2,
	    slot->sl_stat->f3);

	if (ses_write_config(sc) != 0) {
		rw_exit_write(&sc->sc_lock);
		return (EIO);
	}

	rw_exit_write(&sc->sc_lock);

	return (0);
}
#endif

void
ses_psu2sensor(struct ses_softc *sc, struct ses_sensor *s)
{
	s->se_sensor.value = SES_S_PSU_OFF(s->se_stat) ? 0 : 1;
}

void
ses_cool2sensor(struct ses_softc *sc, struct ses_sensor *s)
{
	switch (sc->sc_enctype) {
	case SES_ENC_STD:
		switch (SES_S_COOL_CODE(s->se_stat)) {
		case SES_S_COOL_C_STOPPED:
			s->se_sensor.value = 0;
			break;
		case SES_S_COOL_C_LOW1:
		case SES_S_COOL_C_LOW2:
		case SES_S_COOL_C_LOW3:
			s->se_sensor.value = 33333;
			break;
		case SES_S_COOL_C_INTER:
		case SES_S_COOL_C_HI3:
		case SES_S_COOL_C_HI2:
			s->se_sensor.value = 66666;
			break;
		case SES_S_COOL_C_HI1:
			s->se_sensor.value = 100000;
			break;
		}
		break;

	/* Dell only use the first three codes to represent speed */
	case SES_ENC_DELL:
		switch (SES_S_COOL_CODE(s->se_stat)) {
		case SES_S_COOL_C_STOPPED:
			s->se_sensor.value = 0;
			break;
		case SES_S_COOL_C_LOW1:
			s->se_sensor.value = 33333;
			break;
		case SES_S_COOL_C_LOW2:
			s->se_sensor.value = 66666;
			break;
		case SES_S_COOL_C_LOW3:
		case SES_S_COOL_C_INTER:
		case SES_S_COOL_C_HI3:
		case SES_S_COOL_C_HI2:
		case SES_S_COOL_C_HI1:
			s->se_sensor.value = 100000;
			break;
		}
		break;
	}
}

void
ses_temp2sensor(struct ses_softc *sc, struct ses_sensor *s)
{
	s->se_sensor.value = (int64_t)SES_S_TEMP(s->se_stat);
	s->se_sensor.value += SES_S_TEMP_OFFSET;
	s->se_sensor.value *= 1000000; /* convert to micro (mu) degrees */
	s->se_sensor.value += 273150000; /* convert to kelvin */
}

#ifdef SES_DEBUG
void
ses_dump_enc_desc(struct ses_enc_desc *desc)
{
	char				str[32];

#if 0
	/* XXX not a string. wwn? */
	memset(str, 0, sizeof(str));
	memcpy(str, desc->logical_id, sizeof(desc->logical_id));
	DPRINTF("logical_id: %s", str);
#endif

	memset(str, 0, sizeof(str));
	memcpy(str, desc->vendor_id, sizeof(desc->vendor_id));
	DPRINTF(" vendor_id: %s", str);

	memset(str, 0, sizeof(str));
	memcpy(str, desc->prod_id, sizeof(desc->prod_id));
	DPRINTF(" prod_id: %s", str);

	memset(str, 0, sizeof(str));
	memcpy(str, desc->prod_rev, sizeof(desc->prod_rev));
	DPRINTF(" prod_rev: %s\n", str);
}

char *
ses_dump_enc_string(u_char *buf, ssize_t len)
{
	static char			str[256];

	memset(str, 0, sizeof(str));
	if (len > 0)
		memcpy(str, buf, len);

	return (str);
}
#endif /* SES_DEBUG */
@


1.54
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.53 2014/09/13 16:06:37 doug Exp $ */
d183 1
a183 1
				free(sensor, M_DEVBUF, 0);
d200 1
a200 1
			free(slot, M_DEVBUF, 0);
d232 1
a232 1
			free(slot, M_DEVBUF, 0);
d245 1
a245 1
			free(sensor, M_DEVBUF, 0);
d502 1
a502 1
		free(slot, M_DEVBUF, 0);
d508 1
a508 1
		free(sensor, M_DEVBUF, 0);
@


1.53
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.52 2014/07/12 18:50:25 tedu Exp $ */
a26 1
#include <sys/proc.h>
@


1.52
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.51 2011/03/17 21:30:24 deraadt Exp $ */
d650 1
a650 1
	if (slot == TAILQ_END(&sc->sc_slots)) {
@


1.51
log
@use dma_alloc/dma_free instead of malloc to allocate buffers which need
to be in the right address space.
help from matthew and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.50 2010/08/30 02:47:56 matthew Exp $ */
d184 1
a184 1
				free(sensor, M_DEVBUF);
d201 1
a201 1
			free(slot, M_DEVBUF);
d233 1
a233 1
			free(slot, M_DEVBUF);
d246 1
a246 1
			free(sensor, M_DEVBUF);
d503 1
a503 1
		free(slot, M_DEVBUF);
d509 1
a509 1
		free(sensor, M_DEVBUF);
@


1.50
log
@Avoid possible aliasing-related compiler issues by always writing to
cmd->opcode through the type casted command pointer rather than
through xs->cmd->opcode.

Requested by deraadt@@; ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.49 2010/08/02 23:00:54 krw Exp $ */
d26 1
d211 1
a211 1
		free(sc->sc_buf, M_DEVBUF);
d251 1
a251 1
		free(sc->sc_buf, M_DEVBUF);
d270 1
a270 1
	int error, i;
d273 1
a273 1
	buf = malloc(SES_BUFLEN, M_DEVBUF, M_NOWAIT | M_ZERO);
d281 2
a282 2
		free(buf, M_DEVBUF);
		return (1);
d300 2
a301 2
		free(buf, M_DEVBUF);
		return (1);
d307 2
a308 2
		free(buf, M_DEVBUF);
		return (1);
d351 1
a351 1
	sc->sc_buf = malloc(sc->sc_buflen, M_DEVBUF, M_NOWAIT);
d353 2
a354 2
		free(buf, M_DEVBUF);
		return (1);
d359 3
a361 3
		free(buf, M_DEVBUF);
		free(sc->sc_buf, M_DEVBUF);
		return (1);
d364 4
a367 2
	free(buf, M_DEVBUF);
	return (0);
@


1.49
log
@Don't refer to xs->cmd, even via a pointer to xs->cmd, after xs has
been put back in the pool. Fixes Daniel Dickman's ses device.

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.48 2010/07/22 00:31:06 krw Exp $ */
a282 1
	xs->cmd->opcode = RECEIVE_DIAGNOSTIC;
d290 1
a378 1
	xs->cmd->opcode = RECEIVE_DIAGNOSTIC;
d386 1
a609 1
	xs->cmd->opcode = SEND_DIAGNOSTIC;
d617 1
@


1.48
log
@Eliminate scsi_scsi_cmd() now that ss(4) is gone and with it the
last bastardized sync and buf call through scsi_scsi_cmd(). Flatten
code to call scsi_xs_sync() directly for all commands.

Airplane typos shaken out by various.

ok dlg@@ matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.47 2007/09/16 01:30:24 krw Exp $ */
d304 1
a304 1
	if (cfg->pgcode != cmd->pgcode || betoh16(cfg->length) >
@


1.47
log
@MALLOC/FREE -> malloc/free, M_ZERO, extraneous casts,
extraneous #include <malloc.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.46 2007/09/07 16:15:49 krw Exp $ */
d260 3
a262 7
	struct ses_scsi_diag		cmd;
	int				flags;

	u_char				*buf, *p;

	struct ses_config_hdr		*cfg;
	struct ses_enc_hdr		*enc;
d264 1
a264 1
	struct ses_enc_desc		*desc;
d266 5
a270 3
	struct ses_type_desc		*tdh, *tdlist;

	int				i, ntypes = 0, nelems = 0;
a275 10
	memset(&cmd, 0, sizeof(cmd));
	cmd.opcode = RECEIVE_DIAGNOSTIC;
	cmd.flags |= SES_DIAG_PCV;
	cmd.pgcode = SES_PAGE_CONFIG;
	cmd.length = htobe16(SES_BUFLEN);
	flags = SCSI_DATA_IN;
#ifndef SCSIDEBUG
	flags |= SCSI_SILENT;
#endif

d278 19
d298 1
a298 2
	if (scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), buf, SES_BUFLEN, 2, 3000, NULL, flags) != 0) {
d304 2
a305 1
	if (cfg->pgcode != cmd.pgcode || betoh16(cfg->length) > SES_BUFLEN) {
d370 3
a372 2
	struct ses_scsi_diag		cmd;
	int				flags;
a373 9
	memset(&cmd, 0, sizeof(cmd));
	cmd.opcode = RECEIVE_DIAGNOSTIC;
	cmd.flags |= SES_DIAG_PCV;
	cmd.pgcode = SES_PAGE_STATUS;
	cmd.length = htobe16(sc->sc_buflen);
	flags = SCSI_DATA_IN;
#ifndef SCSIDEBUG
	flags |= SCSI_SILENT;
#endif
d376 14
d391 4
a394 2
	if (scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), sc->sc_buf, sc->sc_buflen, 2, 3000, NULL, flags) != 0)
d600 3
a602 11
	struct ses_scsi_diag		cmd;
	int				flags;

	memset(&cmd, 0, sizeof(cmd));
	cmd.opcode = SEND_DIAGNOSTIC;
	cmd.flags |= SES_DIAG_PF;
	cmd.length = htobe16(sc->sc_buflen);
	flags = SCSI_DATA_OUT;
#ifndef SCSIDEBUG
	flags |= SCSI_SILENT;
#endif
d607 18
a624 2
	if (scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), sc->sc_buf, sc->sc_buflen, 2, 3000, NULL, flags) != 0)
@


1.46
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.45 2007/06/24 05:34:35 dlg Exp $ */
d429 2
a430 2
				slot = malloc(sizeof(struct ses_slot),
				    M_DEVBUF, M_NOWAIT | M_ZERO);
d461 1
a461 1
			sensor = malloc(sizeof(struct ses_sensor), M_DEVBUF,
@


1.45
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.44 2007/05/04 23:44:37 krw Exp $ */
d274 1
a274 1
	buf = malloc(SES_BUFLEN, M_DEVBUF, M_NOWAIT);
a277 1
	memset(buf, 0, SES_BUFLEN);
d430 1
a430 1
				    M_DEVBUF, M_NOWAIT);
a433 1
				memset(slot, 0, sizeof(struct ses_slot));
d462 1
a462 1
			    M_NOWAIT);
a465 1
			memset(sensor, 0, sizeof(struct ses_sensor));
@


1.44
log
@lockmgr -> rwlock.

"reads good" art@@ ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.43 2007/03/22 16:55:31 deraadt Exp $ */
d87 1
d173 17
a189 7
	if (!TAILQ_EMPTY(&sc->sc_sensors) &&
	    sensor_task_register(sc, ses_refresh_sensors, 10) != 0) {
		printf("%s: unable to register update task\n", DEVNAME(sc));
		while (!TAILQ_EMPTY(&sc->sc_sensors)) {
			sensor = TAILQ_FIRST(&sc->sc_sensors);
			TAILQ_REMOVE(&sc->sc_sensors, sensor, se_entry);
			free(sensor, M_DEVBUF);
a190 4
	} else {
		TAILQ_FOREACH(sensor, &sc->sc_sensors, se_entry)
			sensor_attach(&sc->sc_sensordev, &sensor->se_sensor);
		sensordev_install(&sc->sc_sensordev);
d239 1
a239 1
		sensor_task_unregister(sc);
@


1.43
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.42 2006/12/23 17:46:39 deraadt Exp $ */
d27 1
a27 1
#include <sys/lock.h>
d72 1
a72 1
	struct lock		sc_lock;
d155 1
a155 1
	lockinit(&sc->sc_lock, PZERO, DEVNAME(sc), 0, 0);
d217 1
a217 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d245 1
a245 2
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
	lockmgr(&sc->sc_lock, LK_DRAIN, NULL);
d499 1
a499 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d502 1
a502 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d552 1
a552 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d608 1
a608 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d611 1
a611 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d621 1
a621 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d643 1
a643 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d652 1
a652 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d656 1
a656 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
@


1.42
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.41 2006/11/28 16:56:50 dlg Exp $ */
d54 1
a54 1
	struct sensor		se_sensor;
d86 1
a86 1
	struct sensordev	sc_sensordev;
@


1.41
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.40 2006/10/01 10:42:18 grange Exp $ */
d86 1
d182 2
a183 1
			sensor_add(&sensor->se_sensor);
d231 1
d236 1
a236 1
			sensor_del(&sensor->se_sensor);
a389 1
	int				*typecnt;
d395 2
a396 4
	typecnt = malloc(sizeof(int) * SES_NUM_TYPES, M_TEMP, M_NOWAIT);
	if (typecnt == NULL)
		return (1);
	memset(typecnt, 0, sizeof(int) * SES_NUM_TYPES);
d440 1
a440 1
				fmt = "PSU%d";
d445 1
a445 1
				fmt = "Fan%d";
d450 1
a450 1
				fmt = "Temp%d";
d466 2
a467 5
			strlcpy(sensor->se_sensor.device, DEVNAME(sc),
			    sizeof(sensor->se_sensor.device));
			snprintf(sensor->se_sensor.desc,
			    sizeof(sensor->se_sensor.desc), fmt, 
			    typecnt[types[i].type]++);
a475 1
	free(typecnt, M_TEMP);
a489 1
	free(typecnt, M_TEMP);
@


1.40
log
@Free sensors on detach.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.39 2006/07/29 02:40:46 krw Exp $ */
d123 1
a123 1
	struct scsibus_attach_args	*sa = aux;
d145 1
a145 1
	struct scsibus_attach_args	*sa = aux;
@


1.39
log
@The version field of scsi_inquiry_data is not a simple numeric value
that specifies the version of SCSI being supported. Even the ANSI part
that we use is complex. 4 means 2, 5 means 3 and 6 means 4. Translate
and use the value correctly. Fixes SCSI5 and SCSI6 in dmesg. And
properly protects SCSI2 devices from getting SCSI3 commands.

"seems like an elegant solution to me" millert@@ ok dlg@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.38 2006/07/16 22:08:59 dlg Exp $ */
a229 6
		/*
		 * We can't free the sensors once theyre in the systems sensor
		 * list, so just mark them as invalid.
		 */
		TAILQ_FOREACH(sensor, &sc->sc_sensors, se_entry)
			sensor->se_sensor.flags |= SENSOR_FINVALID;
d231 6
@


1.38
log
@take a 1k array off the stack by using malloc to get it. found by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.37 2006/05/11 00:45:59 krw Exp $ */
d130 1
a130 1
	    (inq->version & SID_ANSII) >= SID_ANSII_SCSI2)
d135 1
a135 1
	    (inq->version & SID_ANSII) == SID_ANSII_SCSI3)
@


1.37
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.36 2006/05/09 05:51:54 deraadt Exp $ */
d387 1
a387 1
	int				typecnt[SES_NUM_TYPES];
d393 5
a397 1
	memset(typecnt, 0, sizeof(typecnt));
d479 1
d494 1
@


1.36
log
@make sensor names look more normal; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.35 2006/04/20 20:31:13 miod Exp $ */
d78 1
a78 1
	
d281 2
a282 2
 		flags |= SCSI_AUTOCONF;
 
d595 1
a595 1
 
@


1.35
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.34 2006/01/19 17:08:40 grange Exp $ */
d436 1
a436 1
				fmt = "psu%d";
d441 1
a441 1
				fmt = "fan%d";
d446 1
a446 1
				fmt = "temp%d";
@


1.34
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.33 2006/01/11 08:21:21 dlg Exp $ */
d555 1
a555 1
		printf("%s: error in sensor data\n");
@


1.33
log
@dont print anything if we're unable to read the status page

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.32 2005/11/19 02:18:01 pedro Exp $ */
d181 1
a181 1
			SENSOR_ADD(&sensor->se_sensor);
@


1.32
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.31 2005/11/13 02:38:27 dlg Exp $ */
a501 1
		printf("%s: unable to read enclosure status\n", DEVNAME(sc));
@


1.31
log
@lock accesses to the buffer so that it wont get confused between the
multiple processes using it
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.29 2005/11/12 08:09:47 dlg Exp $ */
d215 1
a215 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);
d242 2
a243 2
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
	lockmgr(&sc->sc_lock, LK_DRAIN, NULL, curproc);
d499 1
a499 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);
d503 1
a503 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d553 1
a553 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d609 1
a609 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);
d612 1
a612 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d622 1
a622 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d644 1
a644 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d653 1
a653 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d657 1
a657 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
@


1.30
log
@if the particular ses device has no slots or sensors to handle, then free
all the resources.
@
text
@d26 2
d72 1
d154 1
d215 2
d242 3
d499 2
d503 1
d553 2
d609 4
a612 1
	if (ses_read_status(sc) != 0)
d614 1
d621 2
a622 1
	if (slot == TAILQ_END(&sc->sc_slots))
d624 1
d644 1
d652 2
a653 1
	if (ses_write_config(sc) != 0)
d655 3
@


1.29
log
@clean up unused includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.28 2005/11/12 08:06:45 dlg Exp $ */
d192 8
@


1.28
log
@remove the ses kthread goop and use the sensor kthread for updates instead

tested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.27 2005/09/29 07:19:35 dlg Exp $ */
a20 1
#include <sys/types.h>
d23 1
a23 1
#include <sys/kernel.h>
a25 2
#include <sys/device.h>
#include <sys/conf.h>
a26 1
#include <sys/kthread.h>
a33 1
#include <scsi/scsi_disk.h>
@


1.27
log
@fix the check for the type of enclosure
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.26 2005/08/23 23:44:28 dlg Exp $ */
a71 2
struct ses_thread;

a87 1
	struct ses_thread	*sc_thread;
a101 8
struct ses_thread {
	struct ses_softc	*sc;
	volatile int		running;
};

void	ses_create_thread(void *);
void	ses_refresh(void *);

d105 1
a105 1
int	ses_refresh_sensors(struct ses_softc *);
d149 4
a154 1
	sc->sc_thread = NULL;
d166 2
a167 3
	sc->sc_thread = malloc(sizeof(struct ses_thread), M_DEVBUF, M_NOWAIT);
	if (sc->sc_thread == NULL) {
		printf("%s: unable to allocate thread information\n",
d172 12
a183 2
	sc->sc_thread->sc = sc;
	sc->sc_thread->running = 1;
d186 2
a187 3
	if (bio_register(self, ses_ioctl) != 0) {
		free(sc->sc_thread, M_DEVBUF);
		sc->sc_thread = NULL;
d189 5
a193 1
		return;
a196 12
	if (ses_read_config(sc) != 0) {
#if NBIO > 0
		bio_unregister(self);
#endif
		free(sc->sc_thread, M_DEVBUF);
		sc->sc_thread = NULL;
		printf("%s: unable to read enclosure configuration\n",
		    DEVNAME(sc));
		return;
	}

	kthread_create_deferred(ses_create_thread, sc);
a207 5
	if (sc->sc_thread != NULL) {
		sc->sc_thread->running = 0;
		wakeup(sc->sc_thread);
		sc->sc_thread = NULL;

d209 1
a210 1

d216 1
d219 2
d228 3
a231 1
	}
a235 35
void
ses_create_thread(void *arg)
{
	struct ses_softc		*sc = arg;

	if (kthread_create(ses_refresh, sc->sc_thread, NULL, DEVNAME(sc)) != 0)
		panic("ses thread");
}

void
ses_refresh(void *arg)
{
	struct ses_thread		*thread = arg;
	struct ses_softc		*sc = thread->sc;
	int				ok = 1;

	while (thread->running) {
		if (ses_refresh_sensors(sc) != 0) {
			if (ok)
				printf("%s: status read error\n", DEVNAME(sc));
			ok = 0;
		} else {
			if (!ok)
				printf("%s: status read ok\n", DEVNAME(sc));
			ok = 1;
		}

		tsleep(thread, PWAIT, "timeout", 10 * hz);
	}

	free(thread, M_DEVBUF);

	kthread_exit(0);
}

a462 2
	TAILQ_FOREACH(sensor, &sc->sc_sensors, se_entry)
		SENSOR_ADD(&sensor->se_sensor);
d480 2
a481 2
int
ses_refresh_sensors(struct ses_softc *sc)
d483 1
d487 4
a490 2
	if (ses_read_status(sc) != 0)
		return (1);
d538 2
a539 1
	return (ret);
@


1.26
log
@setting the FAULT flag on a device so the alarm led blinks may have
unwanted side effects, eg, disabling both fc ports and powering the disk
down. so remove this knob for now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.25 2005/08/23 05:29:41 marco Exp $ */
d159 1
d165 3
a167 2
	if (strncasecmp(sc->sc_link->inqdata.vendor, "dell",
	    sizeof(sc->sc_link->inqdata.vendor)) == 0)
@


1.25
log
@Test for cold and apply relevant flags for all scsi commands.

ok dlg@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.24 2005/08/22 19:24:45 deraadt Exp $ */
d635 1
a635 1
		if (SES_S_DEV_ADDR(slot->sl_stat) == blink->bb_target)
d642 3
a644 3
	/* zero out the config fields */
	slot->sl_stat->f2 = 0x00;
	slot->sl_stat->f3 = 0x00;
d647 2
d652 1
d656 1
a656 5
		SES_C_DEV_IDENT(slot->sl_stat);
		break;

	case BIOC_SBALARM:
		SES_C_DEV_FAULT(slot->sl_stat);
d662 4
@


1.24
log
@check for scsi_autoconf state, spotted by marco; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.23 2005/08/18 21:04:47 marco Exp $ */
d114 1
a114 1
int	ses_read_status(struct ses_softc *, int);
d309 3
a311 3
	if (scsi_autoconf)
		flags |= SCSI_AUTOCONF;

d382 1
a382 1
ses_read_status(struct ses_softc *sc, int autoconf)
d396 1
a396 1
	if (autoconf)
d419 1
a419 1
	if (ses_read_status(sc, 1) != 0)
d529 1
a529 1
	if (ses_read_status(sc, 0) != 0)
d616 3
d631 1
a631 1
	if (ses_read_status(sc, 1) != 0)
@


1.23
log
@Silly dlg did not read my old code careful enough.  Missed 2 bits that are
necessary for the blinkenlight magic.
Also removed some XXX cruft that was misleading.
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.22 2005/08/18 12:26:39 dlg Exp $ */
d308 3
@


1.22
log
@infrastructure to support blinking controlled via /dev/bio ioctls. the
code to do the actual blink is ifdefed out till marco can figure out what
im doing wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.21 2005/08/13 01:38:19 dlg Exp $ */
a150 2
	/* XXX apparently we can match on passthrough devs too? */

a399 2
	/* XXX should we check any values in the status header? */

d606 1
a606 1
	cmd.flags |= SES_DIAG_PCV;
a622 1
#if notyet
a624 1
	/* XXX isnt strictly needed? */
a636 1
	/* XXX previous config is lost */
d640 2
d660 1
a660 1
#endif /* notyet */
@


1.21
log
@let safte match on dell enclosures too. ses takes precedence though

ok marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.20 2005/08/10 10:55:33 dlg Exp $ */
d19 2
d33 4
d64 8
d86 3
d118 6
d184 9
d194 3
d212 3
d221 10
d263 1
a263 2
				printf("%s: error reading enclosure status\n",
				    DEVNAME(sc));
d267 1
a267 2
				printf("%s: reading enclosure status\n",
				    DEVNAME(sc));
d270 1
d412 3
d425 3
d448 16
d509 7
d581 88
@


1.20
log
@use the appropriate flags to scsi_scsi_cmd during autoconf so we dont spin
forever on mp kernels

problem reported by matthieu baptiste
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.19 2005/08/09 11:37:02 dlg Exp $ */
d126 1
a126 1
		return (2);
@


1.19
log
@normalise the fan speed output

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.18 2005/08/08 18:42:08 marco Exp $ */
d97 1
a97 1
int	ses_read_status(struct ses_softc *);
d334 1
a334 1
ses_read_status(struct ses_softc *sc)
d348 2
d370 1
a370 1
	if (ses_read_status(sc) != 0)
d454 1
a454 1
	if (ses_read_status(sc) != 0)
@


1.18
log
@Fill in device structure, bad dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.17 2005/08/05 03:20:26 dlg Exp $ */
d63 5
d101 3
a103 3
void	ses_psu2sensor(struct ses_sensor *);
void	ses_cool2sensor(struct ses_sensor *);
void	ses_temp2sensor(struct ses_sensor *);
d143 6
d484 1
a484 1
			ses_psu2sensor(sensor);
d488 1
a488 1
			ses_cool2sensor(sensor);
d492 1
a492 1
			ses_temp2sensor(sensor);
d505 1
a505 1
ses_psu2sensor(struct ses_sensor *s)
d511 1
a511 1
ses_cool2sensor(struct ses_sensor *s)
d513 20
a532 3
	switch (SES_S_COOL_CODE(s->se_stat)) {
	case SES_S_COOL_C_STOPPED:
		s->se_sensor.value = 0;
d534 21
a554 20
	case SES_S_COOL_C_LOW1:
		s->se_sensor.value = 15000; /* 14.28%*/
		break;
	case SES_S_COOL_C_LOW2:
		s->se_sensor.value = 30000; /* 28.57% */
		break;
	case SES_S_COOL_C_LOW3:
		s->se_sensor.value = 45000; /* 42.85% */
		break;
	case SES_S_COOL_C_INTER:
		s->se_sensor.value = 60000; /* 57.14% */
		break;
	case SES_S_COOL_C_HI3:
		s->se_sensor.value = 75000; /* 71.42% */
		break;
	case SES_S_COOL_C_HI2:
		s->se_sensor.value = 85000; /* 85.71% */
		break;
	case SES_S_COOL_C_HI1:
		s->se_sensor.value = 100000; /* 100.00% */
d560 1
a560 1
ses_temp2sensor(struct ses_sensor *s)
@


1.17
log
@report the fan speed as a percentage since it seems all the enclosures we
fill in the rpm fields.

your call deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.16 2005/08/05 00:34:51 dlg Exp $ */
d136 1
@


1.16
log
@reorder the allocation of bits in attach to make cleaning up on an error
shorter and less prone to mistakes

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.15 2005/08/04 14:31:53 dlg Exp $ */
d387 1
a387 1
				stype = SENSOR_FANRPM;
d501 26
a526 9
	s->se_sensor.value = (int64_t)SES_S_COOL_SPEED(s->se_stat);
	s->se_sensor.value *= SES_S_COOL_FACTOR;

	/* if the fan is on but not showing an rpm then mark as unknown */
	if (SES_S_COOL_CODE(s->se_stat) != SES_S_COOL_C_STOPPED &&
	    s->se_sensor.value == 0)
		s->se_sensor.flags |= SENSOR_FUNKNOWN;
	else
		s->se_sensor.flags &= ~SENSOR_FUNKNOWN;
@


1.15
log
@the generic scsi attach line already says we're an enclosure, so why did
i make it say the second line that says the same thing?
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.14 2005/08/04 14:28:51 dlg Exp $ */
a132 1
	struct ses_sensor		*sensor;
a138 6
	if (ses_read_config(sc) != 0) {
		printf("%s: unable to read enclosure configuration\n",
		    DEVNAME(sc));
		return;
	}

a140 6
		free(sc->sc_buf, M_DEVBUF);
		while (!TAILQ_EMPTY(&sc->sc_sensors)) {
			sensor = TAILQ_FIRST(&sc->sc_sensors);
			TAILQ_REMOVE(&sc->sc_sensors, sensor, se_entry);
			free(sensor, M_DEVBUF);
		}
d145 1
a145 1
	
d149 7
a155 2
	TAILQ_FOREACH(sensor, &sc->sc_sensors, se_entry)
		SENSOR_ADD(&sensor->se_sensor);
d422 2
@


1.14
log
@be nicer to the controller the ses device is attached to by doing the scsi
commands in a kernel thread, not out of softclock with a timeout.

help from pascoe@@ ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.13 2005/08/04 02:14:30 marco Exp $ */
a138 1
	printf("%s: SCSI Enclosure Services\n", DEVNAME(sc));
@


1.13
log
@Add support for dell enclosures that do both SES and SAF-TE.  ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.12 2005/08/03 15:34:13 dlg Exp $ */
d28 1
d58 2
a62 6

	enum {
		SES_ST_NONE,
		SES_ST_OK,
		SES_ST_ERR
	}			sc_state;
d68 1
a68 1
	struct timeout		sc_timeout;
d83 6
d92 1
a92 1
int	ses_read_status(struct ses_softc *, int refresh);
d133 1
d136 1
a136 1
	sc->sc_state = SES_ST_NONE;
d147 15
a161 1
	sc->sc_state = SES_ST_OK;
d163 4
a166 2
	timeout_set(&sc->sc_timeout, ses_refresh, sc);
	timeout_add(&sc->sc_timeout, 10 * hz);
d175 4
a178 2
	if (sc->sc_state != SES_ST_NONE) {
		timeout_del(&sc->sc_timeout);
d181 1
a181 1
		 * We cant free the sensors once theyre in the systems sensor
d194 1
a194 1
ses_refresh(void *arg)
d198 24
a221 9
	if (ses_refresh_sensors(sc) != 0) {
		if (sc->sc_state != SES_ST_ERR)
			printf("%s: error reading enclosure status\n",
			    DEVNAME(sc));
		sc->sc_state = SES_ST_ERR;
	} else {
		if (sc->sc_state != SES_ST_OK)
			printf("%s: reading enclosure status\n", DEVNAME(sc));
		sc->sc_state = SES_ST_OK;
d224 3
a226 1
	timeout_add(&sc->sc_timeout, 10 * hz);
d331 1
a331 1
ses_read_status(struct ses_softc *sc, int refresh)
a344 2
	if (refresh)
		flags |= SCSI_NOSLEEP;
d365 1
a365 1
	if (ses_read_status(sc, 0) != 0)
a430 2
	TAILQ_FOREACH(sensor, &sc->sc_sensors, se_entry)
		SENSOR_ADD(&sensor->se_sensor);
a431 1

d447 1
a447 1
	if (ses_read_status(sc, 1) != 0)
@


1.12
log
@report the state of the power supplies. the value shows if the psu is on
or off, but sysctl doesnt know how to display it (yet).

requested by marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.11 2005/08/03 15:00:26 dlg Exp $ */
d113 5
@


1.11
log
@take advantage of the new ability of the sensors framework to report the
status

ok marco@@ beck@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.10 2005/08/02 03:35:14 dlg Exp $ */
d93 1
d348 5
d439 4
d458 6
@


1.10
log
@read the rpm of the fans
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.9 2005/08/01 23:14:31 dlg Exp $ */
d93 2
a94 2
int64_t	ses_cool2rpm(struct ses_status *);
int64_t	ses_temp2uK(struct ses_status *);
a347 9
				/*
				 * if the fan is on but not showing an rpm
				 * then skip it
				 */
				if ((SES_S_COOL_CODE(status) !=
				    SES_S_COOL_C_STOPPED) &&
				    SES_S_COOL_SPEED(status) == 0)
					continue;

d411 21
d434 1
a434 1
			sensor->se_sensor.value = ses_cool2rpm(sensor->se_stat);
d438 1
a438 1
			sensor->se_sensor.value = ses_temp2uK(sensor->se_stat);
d450 2
a451 2
int64_t
ses_cool2rpm(struct ses_status *status)
d453 2
a454 4
	int64_t				rpm;

	rpm = (int64_t)SES_S_COOL_SPEED(status);
	rpm *= SES_S_COOL_FACTOR;
d456 6
a461 1
	return (rpm);
d464 2
a465 2
int64_t
ses_temp2uK(struct ses_status *status)
d467 4
a470 8
	int64_t				temp;

	temp = (int64_t)SES_S_TEMP(status);
	temp += SES_S_TEMP_OFFSET;
	temp *= 1000000; /* convert to micro (mu) degrees */
	temp += 273150000; /* convert to kelvin */

	return (temp);
@


1.9
log
@a new scsi enclosure services driver. this and safte replace the old ses
driver. rather than relying on its own set of tools, ses reports the
enclosure status via the hw.sensors sysctl tree. so far only temperature
is reported

ok marco@@ deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d93 2
a94 1
int64_t	temp2uK(struct ses_status *);
d347 14
a363 1

d421 4
d426 1
a426 1
			sensor->se_sensor.value = temp2uK(sensor->se_stat);
d439 12
a450 1
temp2uK(struct ses_status *status)
@


1.8
log
@remove the ses driver. it has never been enabled in GENERIC on any arch
in openbsds lifetime so noone is going to miss it.

if you did enable it, it either didnt work or the data was hard to read
and usually wrong.

ok deraadt@@ marco@@
@
text
@d1 2
a2 2
/*	$OpenBSD: ses.c,v 1.7 2004/05/09 04:01:59 krw Exp $ */
/*	$NetBSD: ses.c,v 1.3 2000/01/21 21:19:57 mjacob Exp $ */
d4 1
a4 10
 * Copyright (C) 2000 National Aeronautics & Space Administration
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
d6 11
a16 12
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author:	mjacob@@nas.nasa.gov
a18 5

#ifdef	__NetBSD__
#include "opt_scsi.h"
#endif

a22 3
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
a23 2
#include <sys/buf.h>
#include <sys/uio.h>
a24 1
#include <sys/errno.h>
a25 3
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/proc.h>
d27 2
a28 2
#include <sys/vnode.h>
#include <sys/stdarg.h>
a29 8
#ifdef	__NetBSD__
#include <dev/scsipi/scsipi_all.h>
#include <dev/scsipi/scsi_all.h>
#include <dev/scsipi/scsipi_disk.h>
#include <dev/scsipi/scsi_disk.h>
#include <dev/scsipi/scsiconf.h>
#include <dev/scsipi/ses.h>
#else
d33 1
a34 76
#define	scsipi_link			scsi_link
#define	scsipibus_attach_args		scsibus_attach_args
#define	scsipi_device 			scsi_device
#define sa_inqptr			sa_inqbuf
#define	SCSIPIRETRIES			4
#define	scsipi_generic			scsi_generic
#define	scsipi_command			scsi_scsi_cmd
#define	scsipi_inquiry_data		scsi_inquiry_data
#define	scsipi_do_ioctl			scsi_do_ioctl
#define	scsipi_wait_drain(x)
#define	scsipi_adapter_addref(x)	0
#define	scsipi_adapter_delref(x)
#define	XS_CTL_DATA_IN			SCSI_DATA_IN
#define	XS_CTL_DATA_OUT			SCSI_DATA_OUT
#define	XS_CTL_DISCOVERY		SCSI_AUTOCONF
#define	XS_CTL_SILENT			SCSI_SILENT
#endif

/*
 * Platform Independent Driver Internal Definitions for SES devices.
 */
typedef enum {
	SES_NONE,
	SES_SES_SCSI2,
	SES_SES,
	SES_SES_PASSTHROUGH,
	SES_SEN,
	SES_SAFT
} enctyp;

struct ses_softc;
typedef struct ses_softc ses_softc_t;
typedef struct {
	int (*softc_init)(ses_softc_t *, int);
	int (*init_enc)(ses_softc_t *);
	int (*get_encstat)(ses_softc_t *, int);
	int (*set_encstat)(ses_softc_t *, ses_encstat, int);
	int (*get_objstat)(ses_softc_t *, ses_objstat *, int);
	int (*set_objstat)(ses_softc_t *, ses_objstat *, int);
} encvec;

#define	ENCI_SVALID	0x80

typedef struct {
	uint32_t
		enctype	: 8,		/* enclosure type */
		subenclosure : 8,	/* subenclosure id */
		svalid	: 1,		/* enclosure information valid */
		priv	: 15;		/* private data, per object */
	uint8_t	encstat[4];	/* state && stats */
} encobj;

#define	SEN_ID		"UNISYS           SUN_SEN"
#define	SEN_ID_LEN	24

static enctyp ses_type(void *, int);


/* Forward reference to Enclosure Functions */
static int ses_softc_init(ses_softc_t *, int);
static int ses_init_enc(ses_softc_t *);
static int ses_get_encstat(ses_softc_t *, int);
static int ses_set_encstat(ses_softc_t *, uint8_t, int);
static int ses_get_objstat(ses_softc_t *, ses_objstat *, int);
static int ses_set_objstat(ses_softc_t *, ses_objstat *, int);

static int safte_softc_init(ses_softc_t *, int);
static int safte_init_enc(ses_softc_t *);
static int safte_get_encstat(ses_softc_t *, int);
static int safte_set_encstat(ses_softc_t *, uint8_t, int);
static int safte_get_objstat(ses_softc_t *, ses_objstat *, int);
static int safte_set_objstat(ses_softc_t *, ses_objstat *, int);

/*
 * Platform implementation defines/functions for SES internal kernel stuff
 */
d36 4
a39 10
#define	STRNCMP			strncmp
#define	PRINTF			printf
#define	SES_LOG			ses_log
#if	defined(DEBUG)
#define	SES_DLOG		ses_log
#else
#define	SES_DLOG		if (0) ses_log
#endif
#if	defined(DEBUG) || defined(SCSIDEBUG)
#define	SES_VLOG		ses_log
d41 2
a42 1
#define	SES_VLOG		if (0) ses_log
a43 12
#define	SES_MALLOC(amt)		malloc(amt, M_DEVBUF, M_NOWAIT)
#define	SES_FREE(ptr, amt)	free(ptr, M_DEVBUF)
#define	MEMZERO			bzero
#define	MEMCPY(dest, src, amt)	bcopy(src, dest, amt)
#define	RECEIVE_DIAGNOSTIC	0x1c
#define	SEND_DIAGNOSTIC		0x1d
#define	WRITE_BUFFER		0x3b
#define	READ_BUFFER		0x3c

int sesopen(dev_t, int, int, struct proc *);
int sesclose(dev_t, int, int, struct proc *);
int sesioctl(dev_t, u_long, caddr_t, int, struct proc *);
d45 3
a47 2
static int ses_runcmd(struct ses_softc *, char *, int, char *, int *);
static void ses_log(struct ses_softc *, const char *, ...);
d49 4
a52 3
/*
 * General NetBSD kernel stuff.
 */
d54 1
a54 10
struct ses_softc {
	struct device	sc_device;
	struct scsipi_link *sc_link;
	enctyp		ses_type;	/* type of enclosure */
	encvec		ses_vec;	/* vector to handlers */
	void *		ses_private;	/* per-type private data */
	encobj *	ses_objmap;	/* objects */
	u_int32_t	ses_nobjects;	/* number of objects */
	ses_encstat	ses_encstat;	/* overall status */
	u_int8_t	ses_flags;
a55 3
#define	SES_FLAG_INVALID	0x01
#define	SES_FLAG_OPEN		0x02
#define	SES_FLAG_INITIALIZED	0x04
d57 3
a59 1
#define SESUNIT(x)       (minor((x)))
d61 8
a68 5
#ifdef	__NetBSD__
#define	MATCHTYPE	struct cfdata
#else
#define	MATCHTYPE	void
#endif
d70 3
a72 3
static int ses_match(struct device *, MATCHTYPE *, void *);
static void ses_attach(struct device *, struct device *, void *);
static enctyp ses_device_type(struct scsipibus_attach_args *);
d75 1
a75 1
	sizeof (struct ses_softc), ses_match, ses_attach
a77 3
#ifdef	__NetBSD__
extern struct cfdriver ses_cd;
#else
a80 8
#endif

struct scsipi_device ses_switch = {
	NULL,
	NULL,
	NULL,
	NULL
};
d82 1
d84 1
a84 74
int
ses_match(parent, matcharg, aux)
	struct device *parent;
	MATCHTYPE *matcharg;
	void *aux;
{
	struct scsipibus_attach_args *sa = aux;
	matcharg = matcharg;
	switch (ses_device_type(sa)) {
	case SES_SES:
	case SES_SES_SCSI2:
	case SES_SEN:
	case SES_SAFT:
	case SES_SES_PASSTHROUGH:
		/*
		 * For these devices, it's a perfect match.
		 */
		return (24);
	default:
		return (0);
	}
}


/*
 * Complete the attachment.
 *
 * We have to repeat the rerun of INQUIRY data as above because
 * it's not until the return from the match routine that we have
 * the softc available to set stuff in.
 */
void
ses_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	char *tname;
	struct ses_softc *softc = (void *)self;
	struct scsipibus_attach_args *sa = aux;
	struct scsipi_link *sc_link = sa->sa_sc_link;

	SC_DEBUG(sc_link, SDEV_DB2, ("ssattach:\n"));
	softc->sc_link = sa->sa_sc_link;
	sc_link->device = &ses_switch;
	sc_link->device_softc = softc;
	sc_link->openings = 1;

	softc->ses_type = ses_device_type(sa);
	switch (softc->ses_type) {
	case SES_SES:
	case SES_SES_SCSI2:
	case SES_SES_PASSTHROUGH:
		softc->ses_vec.softc_init = ses_softc_init;
		softc->ses_vec.init_enc = ses_init_enc;
		softc->ses_vec.get_encstat = ses_get_encstat;
		softc->ses_vec.set_encstat = ses_set_encstat;
		softc->ses_vec.get_objstat = ses_get_objstat;
		softc->ses_vec.set_objstat = ses_set_objstat;
		break;
	case SES_SAFT:
		softc->ses_vec.softc_init = safte_softc_init;
		softc->ses_vec.init_enc = safte_init_enc;
		softc->ses_vec.get_encstat = safte_get_encstat;
		softc->ses_vec.set_encstat = safte_set_encstat;
		softc->ses_vec.get_objstat = safte_get_objstat;
		softc->ses_vec.set_objstat = safte_set_objstat;
		break;
	case SES_SEN:
		break;
	case SES_NONE:
	default:
		break;
	}
d86 1
a86 23
	switch (softc->ses_type) {
	default:
	case SES_NONE:
		tname = "No SES device";
		break;
	case SES_SES_SCSI2:
		tname = "SCSI-2 SES Device";
		break;
	case SES_SES:
		tname = "SCSI-3 SES Device";
		break;
	case SES_SES_PASSTHROUGH:
		tname = "SES Passthrough Device";
		break;
	case SES_SEN:
		tname = "UNISYS SEN Device (NOT HANDLED YET)";
		break;
	case SES_SAFT:
		tname = "SAF-TE Compliant Device";
		break;
	}
	printf("\n%s: %s\n", softc->sc_device.dv_xname, tname);
}
d88 4
d93 1
a93 1
#define	NETBSD_SAFTE_END	50
d95 3
a97 34
static enctyp
ses_device_type(sa)
	struct scsipibus_attach_args *sa;
{
	struct scsipi_inquiry_data *inqp = sa->sa_inqptr;
	int length;
 
	if (inqp == NULL)
		return (SES_NONE);

#ifdef	__NetBSD__
	/*
	 * If we can get longer data to check for the
	 * presence of a  SAF-TE device, try and do so.
	 *
	 * Because we do deferred target attach in NetBSD,
	 * we don't have to run this as a polled command.
	 */

	if (inqp->additional_length >= NETBSD_SAFTE_END-4) {
		size_t amt = inqp->additional_length + 4;
		struct scsipi_generic cmd;
		static u_char more[64];

		bzero(&cmd, sizeof(cmd));
		cmd.opcode = INQUIRY;
		cmd.bytes[3] = amt;
		if (scsipi_command(sa->sa_sc_link, &cmd, 6, more, amt,
		    SCSIPIRETRIES, 10000, NULL,
		    XS_CTL_DATA_IN | XS_CTL_DISCOVERY) == 0) {
			length = amt;
			inqp = (struct scsipi_inquiry_data *) more;
		}
	} else
a98 3
		length = sizeof (struct scsipi_inquiry_data);
	return (ses_type(inqp, length));
}
d101 1
a101 5
sesopen(dev, flags, fmt, p)
	dev_t dev;
	int flags;
	int fmt;
	struct proc *p;
d103 2
a104 2
	struct ses_softc *softc;
	int error, unit;
d106 2
a107 22
	unit = SESUNIT(dev);
	if (unit >= ses_cd.cd_ndevs)
		return (ENXIO);
	softc = ses_cd.cd_devs[unit];
	if (softc == NULL)
		return (ENXIO);

	if (softc->ses_flags & SES_FLAG_INVALID) {
		error = ENXIO;
		goto out;
	}
	if (softc->ses_flags & SES_FLAG_OPEN) {
		error = EBUSY;
		goto out;
	}
	if (softc->ses_vec.softc_init == NULL) {
		error = ENXIO;
		goto out;
	}
	error = scsipi_adapter_addref(softc->sc_link);
	if (error != 0)
		goto out;
d109 3
d113 1
a113 8
	softc->ses_flags |= SES_FLAG_OPEN;
	if ((softc->ses_flags & SES_FLAG_INITIALIZED) == 0) {
		error = (*softc->ses_vec.softc_init)(softc, 1);
		if (error)
			softc->ses_flags &= ~SES_FLAG_OPEN;
		else
			softc->ses_flags |= SES_FLAG_INITIALIZED;
	}
a114 24
out:
	return (error);
}

int
sesclose(dev, flags, fmt, p)
	dev_t dev;
	int flags;
	int fmt;
	struct proc *p;
{
	struct ses_softc *softc;
	int unit;

	unit = SESUNIT(dev);
	if (unit >= ses_cd.cd_ndevs)
		return (ENXIO);
	softc = ses_cd.cd_devs[unit];
	if (softc == NULL)
		return (ENXIO);

	scsipi_wait_drain(softc->sc_link);
	scsipi_adapter_delref(softc->sc_link);
	softc->ses_flags &= ~SES_FLAG_OPEN;
d118 2
a119 7
int
sesioctl(dev, cmd, arg_addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t arg_addr;
	int flag;
	struct proc *p;
d121 2
a122 23
	ses_encstat tmp;
	ses_objstat objs;
	ses_object obj, *uobj;
	struct ses_softc *ssc = ses_cd.cd_devs[SESUNIT(dev)];
	void *addr;
	int error, i;


	if (arg_addr)
		addr = *((caddr_t *) arg_addr);
	else
		addr = NULL;

	SC_DEBUG(ssc->sc_link, SDEV_DB2, ("sesioctl 0x%lx\n", cmd));

	/*
	 * Now check to see whether we're initialized or not.
	 */
	if ((ssc->ses_flags & SES_FLAG_INITIALIZED) == 0) {
		return (ENODEV);
	}

	error = 0;
d124 2
a125 15
	/*
	 * If this command can change the device's state,
	 * we must have the device open for writing.
	 */
	switch (cmd) {
	case SESIOC_GETNOBJ:
	case SESIOC_GETOBJMAP:
	case SESIOC_GETENCSTAT:
	case SESIOC_GETOBJSTAT:
		break;
	default:
		if ((flag & FWRITE) == 0) {
			return (EBADF);
		}
	}
d127 2
a128 17
	switch (cmd) {
	case SESIOC_GETNOBJ:
		error = copyout(&ssc->ses_nobjects, addr,
		    sizeof (ssc->ses_nobjects));
		break;
		
	case SESIOC_GETOBJMAP:
		for (uobj = addr, i = 0; i != ssc->ses_nobjects; i++, uobj++) {
			obj.obj_id = i;
			obj.subencid = ssc->ses_objmap[i].subenclosure;
			obj.object_type = ssc->ses_objmap[i].enctype;
			error = copyout(&obj, uobj, sizeof (ses_object));
			if (error) {
				break;
			}
		}
		break;
d130 4
a133 79
	case SESIOC_GETENCSTAT:
		error = (*ssc->ses_vec.get_encstat)(ssc, 1);
		if (error)
			break;
		tmp = ssc->ses_encstat & ~ENCI_SVALID;
		error = copyout(&tmp, addr, sizeof (ses_encstat));
		ssc->ses_encstat = tmp;
		break;

	case SESIOC_SETENCSTAT:
		error = copyin(addr, &tmp, sizeof (ses_encstat));
		if (error)
			break;
		error = (*ssc->ses_vec.set_encstat)(ssc, tmp, 1);
		break;

	case SESIOC_GETOBJSTAT:
		error = copyin(addr, &objs, sizeof (ses_objstat));
		if (error)
			break;
		if (objs.obj_id >= ssc->ses_nobjects) {
			error = EINVAL;
			break;
		}
		error = (*ssc->ses_vec.get_objstat)(ssc, &objs, 1);
		if (error)
			break;
		error = copyout(&objs, addr, sizeof (ses_objstat));
		/*
		 * Always (for now) invalidate entry.
		 */
		ssc->ses_objmap[objs.obj_id].svalid = 0;
		break;

	case SESIOC_SETOBJSTAT:
		error = copyin(addr, &objs, sizeof (ses_objstat));
		if (error)
			break;

		if (objs.obj_id >= ssc->ses_nobjects) {
			error = EINVAL;
			break;
		}
		error = (*ssc->ses_vec.set_objstat)(ssc, &objs, 1);

		/*
		 * Always (for now) invalidate entry.
		 */
		ssc->ses_objmap[objs.obj_id].svalid = 0;
		break;

	case SESIOC_INIT:

		error = (*ssc->ses_vec.init_enc)(ssc);
		break;

	default:
		error = scsipi_do_ioctl(ssc->sc_link, dev, cmd, addr, flag, p);
		break;
	}
	return (error);
}

static int
ses_runcmd(struct ses_softc *ssc, char *cdb, int cdbl, char *dptr, int *dlenp)
{
	struct scsipi_generic sgen;
	int dl, flg, error;

	if (dptr) {
		if ((dl = *dlenp) < 0) {
			dl = -dl;
			flg = XS_CTL_DATA_OUT;
		} else {
			flg = XS_CTL_DATA_IN;
		}
	} else {
		dl = 0;
		flg = 0;
d136 1
a136 12
	if (cdbl > sizeof (struct scsipi_generic)) {
		cdbl = sizeof (struct scsipi_generic);
	}
	bcopy(cdb, &sgen, cdbl);
#ifndef	SCSIDEBUG
	flg |= XS_CTL_SILENT;
#endif
	error = scsipi_command(ssc->sc_link, &sgen, cdbl,
	    (u_char *) dptr, dl, SCSIPIRETRIES, 30000, NULL, flg);

	if (error == 0 && dptr)
		*dlenp = 0;
d138 2
a139 1
	return (error);
d142 2
a143 31
static void
ses_log(struct ses_softc *ssc, const char *fmt, ...)
{
	va_list ap;

	printf("%s: ", ssc->sc_device.dv_xname);
	va_start(ap, fmt);
	vprintf(fmt, ap);
	va_end(ap);
}

/*
 * The code after this point runs on many platforms,
 * so forgive the slightly awkward and nonconforming
 * appearance.
 */

/*
 * Is this a device that supports enclosure services?
 *
 * It's a a pretty simple ruleset- if it is device type 0x0D (13), it's
 * an SES device. If it happens to be an old UNISYS SEN device, we can
 * handle that too.
 */

#define	SAFTE_START	44
#define	SAFTE_END	50
#define	SAFTE_LEN	SAFTE_END-SAFTE_START

static enctyp
ses_type(void *buf, int buflen)
d145 2
a146 1
	unsigned char *iqd = buf;
d148 2
a149 2
	if (buflen < 8+SEN_ID_LEN)
		return (SES_NONE);
a150 13
	if ((iqd[0] & 0x1f) == T_ENCLOSURE) {
		if (STRNCMP(&iqd[8], SEN_ID, SEN_ID_LEN) == 0) {
			return (SES_SEN);
		} else if ((iqd[2] & 0x7) > 2) {
			return (SES_SES);
		} else {
			return (SES_SES_SCSI2);
		}
		return (SES_NONE);
	}

#ifdef	SES_ENABLE_PASSTHROUGH
	if ((iqd[6] & 0x40) && (iqd[2] & 0x7) >= 2) {
d152 2
a153 1
		 * PassThrough Device.
d155 2
a156 181
		return (SES_SES_PASSTHROUGH);
	}
#endif

	/*
	 * The comparison is short for a reason-
	 * some vendors were chopping it short.
	 */

	if (buflen < SAFTE_END - 2) {
		return (SES_NONE);
	}

	if (STRNCMP((char *)&iqd[SAFTE_START], "SAF-TE", SAFTE_LEN - 2) == 0) {
		return (SES_SAFT);
	}
	return (SES_NONE);
}

/*
 * SES Native Type Device Support
 */

/*
 * SES Diagnostic Page Codes
 */

typedef enum {
	SesConfigPage = 0x1,
	SesControlPage,
#define	SesStatusPage SesControlPage
	SesHelpTxt,
	SesStringOut,
#define	SesStringIn	SesStringOut
	SesThresholdOut,
#define	SesThresholdIn SesThresholdOut
	SesArrayControl,
#define	SesArrayStatus	SesArrayControl
	SesElementDescriptor,
	SesShortStatus
} SesDiagPageCodes;

/*
 * minimal amounts
 */

/*
 * Minimum amount of data, starting from byte 0, to have
 * the config header.
 */
#define	SES_CFGHDR_MINLEN	12

/*
 * Minimum amount of data, starting from byte 0, to have
 * the config header and one enclosure header.
 */
#define	SES_ENCHDR_MINLEN	48

/*
 * Take this value, subtract it from VEnclen and you know
 * the length of the vendor unique bytes.
 */
#define	SES_ENCHDR_VMIN		36

/*
 * SES Data Structures
 */

typedef struct {
	uint32_t GenCode;	/* Generation Code */
	uint8_t	Nsubenc;	/* Number of Subenclosures */
} SesCfgHdr;

typedef struct {
	uint8_t	Subencid;	/* SubEnclosure Identifier */
	uint8_t	Ntypes;		/* # of supported types */
	uint8_t	VEnclen;	/* Enclosure Descriptor Length */
} SesEncHdr;

typedef struct {
	uint8_t	encWWN[8];	/* XXX- Not Right Yet */
	uint8_t	encVid[8];
	uint8_t	encPid[16];
	uint8_t	encRev[4];
	uint8_t	encVen[1];
} SesEncDesc;

typedef struct {
	uint8_t	enc_type;		/* type of element */
	uint8_t	enc_maxelt;		/* maximum supported */
	uint8_t	enc_subenc;		/* in SubEnc # N */
	uint8_t	enc_tlen;		/* Type Descriptor Text Length */
} SesThdr;

typedef struct {
	uint8_t	comstatus;
	uint8_t	comstat[3];
} SesComStat;

struct typidx {
	int ses_tidx;
	int ses_oidx;
};

struct sscfg {
	uint8_t ses_ntypes;	/* total number of types supported */

	/*
	 * We need to keep a type index as well as an
	 * object index for each object in an enclosure.
	 */
	struct typidx *ses_typidx;

	/*
	 * We also need to keep track of the number of elements
	 * per type of element. This is needed later so that we
	 * can find precisely in the returned status data the
	 * status for the Nth element of the Kth type.
	 */
	uint8_t *	ses_eltmap;
};


/*
 * (de)canonicalization defines
 */
#define	sbyte(x, byte)		((((uint32_t)(x)) >> (byte * 8)) & 0xff)
#define	sbit(x, bit)		(((uint32_t)(x)) << bit)
#define	sset8(outp, idx, sval)	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 0)

#define	sset16(outp, idx, sval)	\
	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 1), \
	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 0)


#define	sset24(outp, idx, sval)	\
	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 2), \
	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 1), \
	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 0)


#define	sset32(outp, idx, sval)	\
	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 3), \
	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 2), \
	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 1), \
	(((uint8_t *)(outp))[idx++]) = sbyte(sval, 0)

#define	gbyte(x, byte)	((((uint32_t)(x)) & 0xff) << (byte * 8))
#define	gbit(lv, in, idx, shft, mask)	lv = ((in[idx] >> shft) & mask)
#define	sget8(inp, idx, lval)	lval = (((uint8_t *)(inp))[idx++])
#define	gget8(inp, idx, lval)	lval = (((uint8_t *)(inp))[idx])

#define	sget16(inp, idx, lval)	\
	lval = gbyte((((uint8_t *)(inp))[idx]), 1) | \
		(((uint8_t *)(inp))[idx+1]), idx += 2

#define	gget16(inp, idx, lval)	\
	lval = gbyte((((uint8_t *)(inp))[idx]), 1) | \
		(((uint8_t *)(inp))[idx+1])

#define	sget24(inp, idx, lval)	\
	lval = gbyte((((uint8_t *)(inp))[idx]), 2) | \
		gbyte((((uint8_t *)(inp))[idx+1]), 1) | \
			(((uint8_t *)(inp))[idx+2]), idx += 3

#define	gget24(inp, idx, lval)	\
	lval = gbyte((((uint8_t *)(inp))[idx]), 2) | \
		gbyte((((uint8_t *)(inp))[idx+1]), 1) | \
			(((uint8_t *)(inp))[idx+2])

#define	sget32(inp, idx, lval)	\
	lval = gbyte((((uint8_t *)(inp))[idx]), 3) | \
		gbyte((((uint8_t *)(inp))[idx+1]), 2) | \
		gbyte((((uint8_t *)(inp))[idx+2]), 1) | \
			(((uint8_t *)(inp))[idx+3]), idx += 4

#define	gget32(inp, idx, lval)	\
	lval = gbyte((((uint8_t *)(inp))[idx]), 3) | \
		gbyte((((uint8_t *)(inp))[idx+1]), 2) | \
		gbyte((((uint8_t *)(inp))[idx+2]), 1) | \
			(((uint8_t *)(inp))[idx+3])
d158 1
a158 42
#define	SCSZ	0x2000
#define	CFLEN	(256 + SES_ENCHDR_MINLEN)

/*
 * Routines specific && private to SES only
 */

static int ses_getconfig(ses_softc_t *);
static int ses_getputstat(ses_softc_t *, int, SesComStat *, int, int);
static int ses_cfghdr(uint8_t *, int, SesCfgHdr *);
static int ses_enchdr(uint8_t *, int, uint8_t, SesEncHdr *);
static int ses_encdesc(uint8_t *, int, uint8_t, SesEncDesc *);
static int ses_getthdr(uint8_t *, int,  int, SesThdr *);
static int ses_decode(char *, int, uint8_t *, int, int, SesComStat *);
static int ses_encode(char *, int, uint8_t *, int, int, SesComStat *);

static int
ses_softc_init(ses_softc_t *ssc, int doinit)
{
	if (doinit == 0) {
		struct sscfg *cc;
		if (ssc->ses_nobjects) {
			SES_FREE(ssc->ses_objmap,
			    ssc->ses_nobjects * sizeof (encobj));
			ssc->ses_objmap = NULL;
		}
		if ((cc = ssc->ses_private) != NULL) {
			if (cc->ses_eltmap && cc->ses_ntypes) {
				SES_FREE(cc->ses_eltmap, cc->ses_ntypes);
				cc->ses_eltmap = NULL;
				cc->ses_ntypes = 0;
			}
			if (cc->ses_typidx && ssc->ses_nobjects) {
				SES_FREE(cc->ses_typidx,
				    ssc->ses_nobjects * sizeof (struct typidx));
				cc->ses_typidx = NULL;
			}
			SES_FREE(cc, sizeof (struct sscfg));
			ssc->ses_private = NULL;
		}
		ssc->ses_nobjects = 0;
		return (0);
a159 10
	if (ssc->ses_private == NULL) {
		ssc->ses_private = SES_MALLOC(sizeof (struct sscfg));
	}
	if (ssc->ses_private == NULL) {
		return (ENOMEM);
	}
	ssc->ses_nobjects = 0;
	ssc->ses_encstat = 0;
	return (ses_getconfig(ssc));
}
a160 3
static int
ses_init_enc(ses_softc_t *ssc)
{
d164 2
a165 2
static int
ses_get_encstat(ses_softc_t *ssc, int slpflag)
d167 1
a167 2
	SesComStat ComStat;
	int status;
d169 9
a177 2
	if ((status = ses_getputstat(ssc, -1, &ComStat, slpflag, 1)) != 0) {
		return (status);
a178 9
	ssc->ses_encstat = ComStat.comstatus | ENCI_SVALID;
	return (0);
}

static int
ses_set_encstat(ses_softc_t *ssc, uint8_t encstat, int slpflag)
{
	SesComStat ComStat;
	int status;
d180 1
a180 6
	ComStat.comstatus = encstat & 0xf;
	if ((status = ses_getputstat(ssc, -1, &ComStat, slpflag, 0)) != 0) {
		return (status);
	}
	ssc->ses_encstat = encstat & 0xf;	/* note no SVALID set */
	return (0);
d183 2
a184 2
static int
ses_get_objstat(ses_softc_t *ssc, ses_objstat *obp, int slpflag)
d186 2
a187 1
	int i = (int)obp->obj_id;
d189 1
a189 17
	if (ssc->ses_objmap[i].svalid == 0) {
		SesComStat ComStat;
		int err = ses_getputstat(ssc, i, &ComStat, slpflag, 1);
		if (err)
			return (err);
		ssc->ses_objmap[i].encstat[0] = ComStat.comstatus;
		ssc->ses_objmap[i].encstat[1] = ComStat.comstat[0];
		ssc->ses_objmap[i].encstat[2] = ComStat.comstat[1];
		ssc->ses_objmap[i].encstat[3] = ComStat.comstat[2];
		ssc->ses_objmap[i].svalid = 1;
	}
	obp->cstat[0] = ssc->ses_objmap[i].encstat[0];
	obp->cstat[1] = ssc->ses_objmap[i].encstat[1];
	obp->cstat[2] = ssc->ses_objmap[i].encstat[2];
	obp->cstat[3] = ssc->ses_objmap[i].encstat[3];
	return (0);
}
d191 6
a196 38
static int
ses_set_objstat(ses_softc_t *ssc, ses_objstat *obp, int slpflag)
{
	SesComStat ComStat;
	int err;
	/*
	 * If this is clear, we don't do diddly.
	 */
	if ((obp->cstat[0] & SESCTL_CSEL) == 0) {
		return (0);
	}
	ComStat.comstatus = obp->cstat[0];
	ComStat.comstat[0] = obp->cstat[1];
	ComStat.comstat[1] = obp->cstat[2];
	ComStat.comstat[2] = obp->cstat[3];
	err = ses_getputstat(ssc, (int)obp->obj_id, &ComStat, slpflag, 0);
	ssc->ses_objmap[(int)obp->obj_id].svalid = 0;
	return (err);
}

static int
ses_getconfig(ses_softc_t *ssc)
{
	struct sscfg *cc;
	SesCfgHdr cf;
	SesEncHdr hd;
	SesEncDesc *cdp;
	SesThdr thdr;
	int err, amt, i, nobj, ntype, maxima;
	char storage[CFLEN], *sdata;
	static char cdb[6] = {
	    RECEIVE_DIAGNOSTIC, 0x1, SesConfigPage, SCSZ >> 8, SCSZ & 0xff, 0
	};

	cc = ssc->ses_private;
	if (cc == NULL) {
		return (ENXIO);
	}
d198 1
a198 11
	sdata = SES_MALLOC(SCSZ);
	if (sdata == NULL)
		return (ENOMEM);

	amt = SCSZ;
	err = ses_runcmd(ssc, cdb, 6, sdata, &amt);
	if (err) {
		SES_FREE(sdata, SCSZ);
		return (err);
	}
	amt = SCSZ - amt;
d200 3
a202 10
	if (ses_cfghdr((uint8_t *) sdata, amt, &cf)) {
		SES_LOG(ssc, "Unable to parse SES Config Header\n");
		SES_FREE(sdata, SCSZ);
		return (EIO);
	}
	if (amt < SES_ENCHDR_MINLEN) {
		SES_LOG(ssc, "runt enclosure length (%d)\n", amt);
		SES_FREE(sdata, SCSZ);
		return (EIO);
	}
d204 10
a213 1
	SES_VLOG(ssc, "GenCode %x %d Subenclosures\n", cf.GenCode, cf.Nsubenc);
d215 4
a218 173
	/*
	 * Now waltz through all the subenclosures toting up the
	 * number of types available in each. For this, we only
	 * really need the enclosure header. However, we get the
	 * enclosure descriptor for debug purposes, as well
	 * as self-consistency checking purposes.
	 */

	maxima = cf.Nsubenc + 1;
	cdp = (SesEncDesc *) storage;
	for (ntype = i = 0; i < maxima; i++) {
		MEMZERO((caddr_t)cdp, sizeof (*cdp));
		if (ses_enchdr((uint8_t *) sdata, amt, i, &hd)) {
			SES_LOG(ssc, "Cannot Extract Enclosure Header %d\n", i);
			SES_FREE(sdata, SCSZ);
			return (EIO);
		}
		SES_VLOG(ssc, " SubEnclosure ID %d, %d Types With this ID, En"
		    "closure Length %d\n", hd.Subencid, hd.Ntypes, hd.VEnclen);

		if (ses_encdesc((uint8_t *)sdata, amt, i, cdp)) {
			SES_LOG(ssc, "Can't get Enclosure Descriptor %d\n", i);
			SES_FREE(sdata, SCSZ);
			return (EIO);
		}
		SES_VLOG(ssc, " WWN: %02x%02x%02x%02x%02x%02x%02x%02x\n",
		    cdp->encWWN[0], cdp->encWWN[1], cdp->encWWN[2],
		    cdp->encWWN[3], cdp->encWWN[4], cdp->encWWN[5],
		    cdp->encWWN[6], cdp->encWWN[7]);
		ntype += hd.Ntypes;
	}

	/*
	 * Now waltz through all the types that are available, getting
	 * the type header so we can start adding up the number of
	 * objects available.
	 */
	for (nobj = i = 0; i < ntype; i++) {
		if (ses_getthdr((uint8_t *)sdata, amt, i, &thdr)) {
			SES_LOG(ssc, "Can't get Enclosure Type Header %d\n", i);
			SES_FREE(sdata, SCSZ);
			return (EIO);
		}
		SES_LOG(ssc, " Type Desc[%d]: Type 0x%x, MaxElt %d, In Subenc "
		    "%d, Text Length %d\n", i, thdr.enc_type, thdr.enc_maxelt,
		    thdr.enc_subenc, thdr.enc_tlen);
		nobj += thdr.enc_maxelt;
	}


	/*
	 * Now allocate the object array and type map.
	 */

	ssc->ses_objmap = SES_MALLOC(nobj * sizeof (encobj));
	cc->ses_typidx = SES_MALLOC(nobj * sizeof (struct typidx));
	cc->ses_eltmap = SES_MALLOC(ntype);

	if (ssc->ses_objmap == NULL || cc->ses_typidx == NULL ||
	    cc->ses_eltmap == NULL) {
		if (ssc->ses_objmap) {
			SES_FREE(ssc->ses_objmap, (nobj * sizeof (encobj)));
			ssc->ses_objmap = NULL;
		}
		if (cc->ses_typidx) {
			SES_FREE(cc->ses_typidx,
			    (nobj * sizeof (struct typidx)));
			cc->ses_typidx = NULL;
		}
		if (cc->ses_eltmap) {
			SES_FREE(cc->ses_eltmap, ntype);
			cc->ses_eltmap = NULL;
		}
		SES_FREE(sdata, SCSZ);
		return (ENOMEM);
	}
	MEMZERO(ssc->ses_objmap, nobj * sizeof (encobj));
	MEMZERO(cc->ses_typidx, nobj * sizeof (struct typidx));
	MEMZERO(cc->ses_eltmap, ntype);
	cc->ses_ntypes = (uint8_t) ntype;
	ssc->ses_nobjects = nobj;

	/*
	 * Now waltz through the # of types again to fill in the types
	 * (and subenclosure ids) of the allocated objects.
	 */
	nobj = 0;
	for (i = 0; i < ntype; i++) {
		int j;
		if (ses_getthdr((uint8_t *)sdata, amt, i, &thdr)) {
			continue;
		}
		cc->ses_eltmap[i] = thdr.enc_maxelt;
		for (j = 0; j < thdr.enc_maxelt; j++) {
			cc->ses_typidx[nobj].ses_tidx = i;
			cc->ses_typidx[nobj].ses_oidx = j;
			ssc->ses_objmap[nobj].subenclosure = thdr.enc_subenc;
			ssc->ses_objmap[nobj++].enctype = thdr.enc_type;
		}
	}
	SES_FREE(sdata, SCSZ);
	return (0);
}

static int
ses_getputstat(ses_softc_t *ssc, int objid, SesComStat *sp, int slp, int in)
{
	struct sscfg *cc;
	int err, amt, bufsiz, tidx, oidx;
	char cdb[6], *sdata;

	cc = ssc->ses_private;
	if (cc == NULL) {
		return (ENXIO);
	}

	/*
	 * If we're just getting overall enclosure status,
	 * we only need 2 bytes of data storage.
	 *
	 * If we're getting anything else, we know how much
	 * storage we need by noting that starting at offset
	 * 8 in returned data, all object status bytes are 4
	 * bytes long, and are stored in chunks of types(M)
	 * and nth+1 instances of type M.
	 */
	if (objid == -1) {
		bufsiz = 2;
	} else {
		bufsiz = (ssc->ses_nobjects * 4) + (cc->ses_ntypes * 4) + 8;
	}
	sdata = SES_MALLOC(bufsiz);
	if (sdata == NULL)
		return (ENOMEM);

	cdb[0] = RECEIVE_DIAGNOSTIC;
	cdb[1] = 1;
	cdb[2] = SesStatusPage;
	cdb[3] = bufsiz >> 8;
	cdb[4] = bufsiz & 0xff;
	cdb[5] = 0;
	amt = bufsiz;
	err = ses_runcmd(ssc, cdb, 6, sdata, &amt);
	if (err) {
		SES_FREE(sdata, bufsiz);
		return (err);
	}
	amt = bufsiz - amt;

	if (objid == -1) {
		tidx = -1;
		oidx = -1;
	} else {
		tidx = cc->ses_typidx[objid].ses_tidx;
		oidx = cc->ses_typidx[objid].ses_oidx;
	}
	if (in) {
		if (ses_decode(sdata, amt, cc->ses_eltmap, tidx, oidx, sp)) {
			err = ENODEV;
		}
	} else {
		if (ses_encode(sdata, amt, cc->ses_eltmap, tidx, oidx, sp)) {
			err = ENODEV;
		} else {
			cdb[0] = SEND_DIAGNOSTIC;
			cdb[1] = 0x10;
			cdb[2] = 0;
			cdb[3] = bufsiz >> 8;
			cdb[4] = bufsiz & 0xff;
			cdb[5] = 0;
			amt = -bufsiz;
			err = ses_runcmd(ssc, cdb, 6, sdata, &amt);   
		}
a219 9
	SES_FREE(sdata, bufsiz);
	return (0);
}


/*
 * Routines to parse returned SES data structures.
 * Architecture and compiler independent.
 */
d221 4
a224 5
static int
ses_cfghdr(uint8_t *buffer, int buflen, SesCfgHdr *cfp)
{
	if (buflen < SES_CFGHDR_MINLEN) {
		return (-1);
a225 4
	gget8(buffer, 1, cfp->Nsubenc);
	gget32(buffer, 4, cfp->GenCode);
	return (0);
}
d227 2
a228 17
static int
ses_enchdr(uint8_t *buffer, int amt, uint8_t SubEncId, SesEncHdr *chp)
{
	int s, off = 8;
	for (s = 0; s < SubEncId; s++) {
		if (off + 3 > amt)
			return (-1);
		off += buffer[off+3] + 4;
	}
	if (off + 3 > amt) {
		return (-1);
	}
	gget8(buffer, off+1, chp->Subencid);
	gget8(buffer, off+2, chp->Ntypes);
	gget8(buffer, off+3, chp->VEnclen);
	return (0);
}
d230 9
a238 24
static int
ses_encdesc(uint8_t *buffer, int amt, uint8_t SubEncId, SesEncDesc *cdp)
{
	int s, e, enclen, off = 8;
	for (s = 0; s < SubEncId; s++) {
		if (off + 3 > amt)
			return (-1);
		off += buffer[off+3] + 4;
	}
	if (off + 3 > amt) {
		return (-1);
	}
	gget8(buffer, off+3, enclen);
	off += 4;
	if (off  >= amt)
		return (-1);

	e = off + enclen;
	if (e > amt) {
		e = amt;
	}
	MEMCPY(cdp, &buffer[off], e - off);
	return (0);
}
d240 1
a240 4
static int
ses_getthdr(uint8_t *buffer, int amt, int nth, SesThdr *thp)
{
	int s, off = 8;
d242 1
a242 7
	if (amt < SES_CFGHDR_MINLEN) {
		return (-1);
	}
	for (s = 0; s < buffer[1]; s++) {
		if (off + 3 > amt)
			return (-1);
		off += buffer[off+3] + 4;
a243 13
	if (off + 3 > amt) {
		return (-1);
	}
	off += buffer[off+3] + 4 + (nth * 4);
	if (amt < (off + 4))
		return (-1);

	gget8(buffer, off++, thp->enc_type);
	gget8(buffer, off++, thp->enc_maxelt);
	gget8(buffer, off++, thp->enc_subenc);
	gget8(buffer, off, thp->enc_tlen);
	return (0);
}
d245 1
a245 29
/*
 * This function needs a little explanation.
 *
 * The arguments are:
 *
 *
 *	char *b, int amt
 *
 *		These describes the raw input SES status data and length.
 *
 *	uint8_t *ep
 *
 *		This is a map of the number of types for each element type
 *		in the enclosure.
 *
 *	int elt
 *
 *		This is the element type being sought. If elt is -1,
 *		then overall enclosure status is being sought.
 *
 *	int elm
 *
 *		This is the ordinal Mth element of type elt being sought.
 *
 *	SesComStat *sp
 *
 *		This is the output area to store the status for
 *		the Mth element of type Elt.
 */
d247 4
a250 4
static int
ses_decode(char *b, int amt, uint8_t *ep, int elt, int elm, SesComStat *sp)
{
	int idx, i;
d252 1
a252 13
	/*
	 * If it's overall enclosure status being sought, get that.
	 * We need at least 2 bytes of status data to get that.
	 */
	if (elt == -1) {
		if (amt < 2)
			return (-1);
		gget8(b, 1, sp->comstatus);
		sp->comstat[0] = 0;
		sp->comstat[1] = 0;
		sp->comstat[2] = 0;
		return (0);
	}
d254 1
a254 13
	/*
	 * Check to make sure that the Mth element is legal for type Elt.
	 */

	if (elm >= ep[elt])
		return (-1);

	/*
	 * Starting at offset 8, start skipping over the storage
	 * for the element types we're not interested in.
	 */
	for (idx = 8, i = 0; i < elt; i++) {
		idx += ((ep[i] + 1) * 4);
d257 4
a260 40
	/*
	 * Skip over Overall status for this element type.
	 */
	idx += 4;

	/*
	 * And skip to the index for the Mth element that we're going for.
	 */
	idx += (4 * elm);

	/*
	 * Make sure we haven't overflowed the buffer.
	 */
	if (idx+4 > amt)
		return (-1);

	/*
	 * Retrieve the status.
	 */
	gget8(b, idx++, sp->comstatus);
	gget8(b, idx++, sp->comstat[0]);
	gget8(b, idx++, sp->comstat[1]);
	gget8(b, idx++, sp->comstat[2]);
#if	0
	PRINTF("Get Elt 0x%x Elm 0x%x (idx %d)\n", elt, elm, idx-4);
#endif
	return (0);
}

/*
 * This is the mirror function to ses_decode, but we set the 'select'
 * bit for the object which we're interested in. All other objects,
 * after a status fetch, should have that bit off. Hmm. It'd be easy
 * enough to ensure this, so we will.
 */

static int
ses_encode(char *b, int amt, uint8_t *ep, int elt, int elm, SesComStat *sp)
{
	int idx, i;
d262 1
a262 14
	/*
	 * If it's overall enclosure status being sought, get that.
	 * We need at least 2 bytes of status data to get that.
	 */
	if (elt == -1) {
		if (amt < 2)
			return (-1);
		i = 0;
		sset8(b, i, 0);
		sset8(b, i, sp->comstatus & 0xf);
#if	0
		PRINTF("set EncStat %x\n", sp->comstatus);
#endif
		return (0);
d264 1
d266 5
a270 13
	/*
	 * Check to make sure that the Mth element is legal for type Elt.
	 */

	if (elm >= ep[elt])
		return (-1);

	/*
	 * Starting at offset 8, start skipping over the storage
	 * for the element types we're not interested in.
	 */
	for (idx = 8, i = 0; i < elt; i++) {
		idx += ((ep[i] + 1) * 4);
d273 5
a277 37
	/*
	 * Skip over Overall status for this element type.
	 */
	idx += 4;

	/*
	 * And skip to the index for the Mth element that we're going for.
	 */
	idx += (4 * elm);

	/*
	 * Make sure we haven't overflowed the buffer.
	 */
	if (idx+4 > amt)
		return (-1);

	/*
	 * Set the status.
	 */
	sset8(b, idx, sp->comstatus);
	sset8(b, idx, sp->comstat[0]);
	sset8(b, idx, sp->comstat[1]);
	sset8(b, idx, sp->comstat[2]);
	idx -= 4;

#if	0
	PRINTF("Set Elt 0x%x Elm 0x%x (idx %d) with %x %x %x %x\n",
	    elt, elm, idx, sp->comstatus, sp->comstat[0],
	    sp->comstat[1], sp->comstat[2]);
#endif

	/*
	 * Now make sure all other 'Select' bits are off.
	 */
	for (i = 8; i < amt; i += 4) {
		if (i != idx)
			b[i] &= ~0x80;
a278 4
	/*
	 * And make sure the INVOP bit is clear.
	 */
	b[2] &= ~0x10;
d280 1
a283 82
/*
 * SAF-TE Type Device Emulation
 */

static int safte_getconfig(ses_softc_t *);
static int safte_rdstat(ses_softc_t *, int);
static int set_objstat_sel(ses_softc_t *, ses_objstat *, int);
static int wrbuf16(ses_softc_t *, uint8_t, uint8_t, uint8_t, uint8_t, int);
static void wrslot_stat(ses_softc_t *, int);
static int perf_slotop(ses_softc_t *, uint8_t, uint8_t, int);

#define	ALL_ENC_STAT (SES_ENCSTAT_CRITICAL | SES_ENCSTAT_UNRECOV | \
	SES_ENCSTAT_NONCRITICAL | SES_ENCSTAT_INFO)
/*
 * SAF-TE specific defines- Mandatory ones only...
 */

/*
 * READ BUFFER ('get' commands) IDs- placed in offset 2 of cdb
 */
#define	SAFTE_RD_RDCFG	0x00	/* read enclosure configuration */
#define	SAFTE_RD_RDESTS	0x01	/* read enclosure status */
#define	SAFTE_RD_RDDSTS	0x04	/* read drive slot status */

/*
 * WRITE BUFFER ('set' commands) IDs- placed in offset 0 of databuf
 */
#define	SAFTE_WT_DSTAT	0x10	/* write device slot status */
#define	SAFTE_WT_SLTOP	0x12	/* perform slot operation */
#define	SAFTE_WT_FANSPD	0x13	/* set fan speed */
#define	SAFTE_WT_ACTPWS	0x14	/* turn on/off power supply */
#define	SAFTE_WT_GLOBAL	0x15	/* send global command */


#define	SAFT_SCRATCH	64
#define	NPSEUDO_THERM	16
#define	NPSEUDO_ALARM	1
struct scfg {
	/*
	 * Cached Configuration
	 */
	uint8_t	Nfans;		/* Number of Fans */
	uint8_t	Npwr;		/* Number of Power Supplies */
	uint8_t	Nslots;		/* Number of Device Slots */
	uint8_t	DoorLock;	/* Door Lock Installed */
	uint8_t	Ntherm;		/* Number of Temperature Sensors */
	uint8_t	Nspkrs;		/* Number of Speakers */
	uint8_t Nalarm;		/* Number of Alarms (at least one) */
	/*
	 * Cached Flag Bytes for Global Status
	 */
	uint8_t	flag1;
	uint8_t	flag2;
	/*
	 * What object index ID is where various slots start.
	 */
	uint8_t	pwroff;
	uint8_t	slotoff;
#define	SAFT_ALARM_OFFSET(cc)	(cc)->slotoff - 1
};

#define	SAFT_FLG1_ALARM		0x1
#define	SAFT_FLG1_GLOBFAIL	0x2
#define	SAFT_FLG1_GLOBWARN	0x4
#define	SAFT_FLG1_ENCPWROFF	0x8
#define	SAFT_FLG1_ENCFANFAIL	0x10
#define	SAFT_FLG1_ENCPWRFAIL	0x20
#define	SAFT_FLG1_ENCDRVFAIL	0x40
#define	SAFT_FLG1_ENCDRVWARN	0x80

#define	SAFT_FLG2_LOCKDOOR	0x4
#define	SAFT_PRIVATE		sizeof (struct scfg)

static char *safte_2little = "Too Little Data Returned (%d) at line %d\n";
#define	SAFT_BAIL(r, x, k, l)	\
	if (r >= x) { \
		SES_LOG(ssc, safte_2little, x, __LINE__);\
		SES_FREE(k, l); \
		return (EIO); \
	}


d285 1
a285 1
safte_softc_init(ses_softc_t *ssc, int doinit)
d287 2
a288 26
	int err, i, r;
	struct scfg *cc;

	if (doinit == 0) {
		if (ssc->ses_nobjects) {
			if (ssc->ses_objmap) {
				SES_FREE(ssc->ses_objmap,
				    ssc->ses_nobjects * sizeof (encobj));
				ssc->ses_objmap = NULL;
			}
			ssc->ses_nobjects = 0;
		}
		if (ssc->ses_private) {
			SES_FREE(ssc->ses_private, SAFT_PRIVATE);
			ssc->ses_private = NULL;
		}
		return (0);
	}

	if (ssc->ses_private == NULL) {
		ssc->ses_private = SES_MALLOC(SAFT_PRIVATE);
		if (ssc->ses_private == NULL) {
			return (ENOMEM);
		}
		MEMZERO(ssc->ses_private, SAFT_PRIVATE);
	}
d290 15
a304 2
	ssc->ses_nobjects = 0;
	ssc->ses_encstat = 0;
d306 1
a306 18
	if ((err = safte_getconfig(ssc)) != 0) {
		return (err);
	}

	/*
	 * The number of objects here, as well as that reported by the
	 * READ_BUFFER/GET_CONFIG call, are the over-temperature flags (15)
	 * that get reported during READ_BUFFER/READ_ENC_STATUS.
	 */
	cc = ssc->ses_private;
	ssc->ses_nobjects = cc->Nfans + cc->Npwr + cc->Nslots + cc->DoorLock +
	    cc->Ntherm + cc->Nspkrs + NPSEUDO_THERM + NPSEUDO_ALARM;
	ssc->ses_objmap = (encobj *)
	    SES_MALLOC(ssc->ses_nobjects * sizeof (encobj));
	if (ssc->ses_objmap == NULL) {
		return (ENOMEM);
	}
	MEMZERO(ssc->ses_objmap, ssc->ses_nobjects * sizeof (encobj));
a307 22
	r = 0;
	/*
	 * Note that this is all arranged for the convenience
	 * in later fetches of status.
	 */
	for (i = 0; i < cc->Nfans; i++)
		ssc->ses_objmap[r++].enctype = SESTYP_FAN;
	cc->pwroff = (uint8_t) r;
	for (i = 0; i < cc->Npwr; i++)
		ssc->ses_objmap[r++].enctype = SESTYP_POWER;
	for (i = 0; i < cc->DoorLock; i++)
		ssc->ses_objmap[r++].enctype = SESTYP_DOORLOCK;
	for (i = 0; i < cc->Nspkrs; i++)
		ssc->ses_objmap[r++].enctype = SESTYP_ALARM;
	for (i = 0; i < cc->Ntherm; i++)
		ssc->ses_objmap[r++].enctype = SESTYP_THERM;
	for (i = 0; i < NPSEUDO_THERM; i++)
		ssc->ses_objmap[r++].enctype = SESTYP_THERM;
	ssc->ses_objmap[r++].enctype = SESTYP_ALARM;
	cc->slotoff = (uint8_t) r;
	for (i = 0; i < cc->Nslots; i++)
		ssc->ses_objmap[r++].enctype = SESTYP_DEVICE;
d312 1
a312 1
safte_init_enc(ses_softc_t *ssc)
d314 35
a348 2
	int err;
	static char cdb0[6] = { SEND_DIAGNOSTIC };
d350 1
a350 8
	err = ses_runcmd(ssc, cdb0, 6, NULL, 0);
	if (err) {
		return (err);
	}
	DELAY(5000);
	err = wrbuf16(ssc, SAFTE_WT_GLOBAL, 0, 0, 0, 1);
	return (err);
}
d352 3
a354 5
int
safte_get_encstat(ses_softc_t *ssc, int slpflg)
{
	return (safte_rdstat(ssc, slpflg));
}
d356 4
a359 23
int
safte_set_encstat(ses_softc_t *ssc, uint8_t encstat, int slpflg)
{
	struct scfg *cc = ssc->ses_private;
	if (cc == NULL)
		return (0);
	/*
	 * Since SAF-TE devices aren't necessarily sticky in terms
	 * of state, make our soft copy of enclosure status 'sticky'-
	 * that is, things set in enclosure status stay set (as implied
	 * by conditions set in reading object status) until cleared.
	 */
	ssc->ses_encstat &= ~ALL_ENC_STAT;
	ssc->ses_encstat |= (encstat & ALL_ENC_STAT);
	ssc->ses_encstat |= ENCI_SVALID;
	cc->flag1 &= ~(SAFT_FLG1_ALARM|SAFT_FLG1_GLOBFAIL|SAFT_FLG1_GLOBWARN);
	if ((encstat & (SES_ENCSTAT_CRITICAL|SES_ENCSTAT_UNRECOV)) != 0) {
		cc->flag1 |= SAFT_FLG1_ALARM|SAFT_FLG1_GLOBFAIL;
	} else if ((encstat & SES_ENCSTAT_NONCRITICAL) != 0) {
		cc->flag1 |= SAFT_FLG1_GLOBWARN;
	}
	return (wrbuf16(ssc, SAFTE_WT_GLOBAL, cc->flag1, cc->flag2, 0, slpflg));
}
d361 9
a369 4
int
safte_get_objstat(ses_softc_t *ssc, ses_objstat *obp, int slpflg)
{
	int i = (int)obp->obj_id;
d371 2
a372 12
	if ((ssc->ses_encstat & ENCI_SVALID) == 0 ||
	    (ssc->ses_objmap[i].svalid) == 0) {
		int err = safte_rdstat(ssc, slpflg);
		if (err)
			return (err);
	}
	obp->cstat[0] = ssc->ses_objmap[i].encstat[0];
	obp->cstat[1] = ssc->ses_objmap[i].encstat[1];
	obp->cstat[2] = ssc->ses_objmap[i].encstat[2];
	obp->cstat[3] = ssc->ses_objmap[i].encstat[3];
	return (0);
}
d374 2
a375 18

int
safte_set_objstat(ses_softc_t *ssc, ses_objstat *obp, int slp)
{
	int idx, err;
	encobj *ep;
	struct scfg *cc;


	SES_DLOG(ssc, "safte_set_objstat(%d): %x %x %x %x\n",
	    (int)obp->obj_id, obp->cstat[0], obp->cstat[1], obp->cstat[2],
	    obp->cstat[3]);

	/*
	 * If this is clear, we don't do diddly.
	 */
	if ((obp->cstat[0] & SESCTL_CSEL) == 0) {
		return (0);
d378 2
a379 123
	err = 0;
	/*
	 * Check to see if the common bits are set and do them first.
	 */
	if (obp->cstat[0] & ~SESCTL_CSEL) {
		err = set_objstat_sel(ssc, obp, slp);
		if (err)
			return (err);
	}

	cc = ssc->ses_private;
	if (cc == NULL)
		return (0);

	idx = (int)obp->obj_id;
	ep = &ssc->ses_objmap[idx];

	switch (ep->enctype) {
	case SESTYP_DEVICE:
	{
		uint8_t slotop = 0;
		/*
		 * XXX: I should probably cache the previous state
		 * XXX: of SESCTL_DEVOFF so that when it goes from
		 * XXX: true to false I can then set PREPARE FOR OPERATION
		 * XXX: flag in PERFORM SLOT OPERATION write buffer command.
		 */
		if (obp->cstat[2] & (SESCTL_RQSINS|SESCTL_RQSRMV)) {
			slotop |= 0x2;
		}
		if (obp->cstat[2] & SESCTL_RQSID) {
			slotop |= 0x4;
		}
		err = perf_slotop(ssc, (uint8_t) idx - (uint8_t) cc->slotoff,
		    slotop, slp);
		if (err)
			return (err);
		if (obp->cstat[3] & SESCTL_RQSFLT) {
			ep->priv |= 0x2;
		} else {
			ep->priv &= ~0x2;
		}
		if (ep->priv & 0xc6) {
			ep->priv &= ~0x1;
		} else {
			ep->priv |= 0x1;	/* no errors */
		}
		wrslot_stat(ssc, slp);
		break;
	}
	case SESTYP_POWER:
		if (obp->cstat[3] & SESCTL_RQSTFAIL) {
			cc->flag1 |= SAFT_FLG1_ENCPWRFAIL;
		} else {
			cc->flag1 &= ~SAFT_FLG1_ENCPWRFAIL;
		}
		err = wrbuf16(ssc, SAFTE_WT_GLOBAL, cc->flag1,
		    cc->flag2, 0, slp);
		if (err)
			return (err);
		if (obp->cstat[3] & SESCTL_RQSTON) {
			(void) wrbuf16(ssc, SAFTE_WT_ACTPWS,
				idx - cc->pwroff, 0, 0, slp);
		} else {
			(void) wrbuf16(ssc, SAFTE_WT_ACTPWS,
				idx - cc->pwroff, 0, 1, slp);
		}
		break;
	case SESTYP_FAN:
		if (obp->cstat[3] & SESCTL_RQSTFAIL) {
			cc->flag1 |= SAFT_FLG1_ENCFANFAIL;
		} else {
			cc->flag1 &= ~SAFT_FLG1_ENCFANFAIL;
		}
		err = wrbuf16(ssc, SAFTE_WT_GLOBAL, cc->flag1,
		    cc->flag2, 0, slp);
		if (err)
			return (err);
		if (obp->cstat[3] & SESCTL_RQSTON) {
			uint8_t fsp;
			if ((obp->cstat[3] & 0x7) == 7) {
				fsp = 4;
			} else if ((obp->cstat[3] & 0x7) == 6) {
				fsp = 3;
			} else if ((obp->cstat[3] & 0x7) == 4) {
				fsp = 2;
			} else {
				fsp = 1;
			}
			(void) wrbuf16(ssc, SAFTE_WT_FANSPD, idx, fsp, 0, slp);
		} else {
			(void) wrbuf16(ssc, SAFTE_WT_FANSPD, idx, 0, 0, slp);
		}
		break;
	case SESTYP_DOORLOCK:
		if (obp->cstat[3] & 0x1) {
			cc->flag2 &= ~SAFT_FLG2_LOCKDOOR;
		} else {
			cc->flag2 |= SAFT_FLG2_LOCKDOOR;
		}
		(void) wrbuf16(ssc, SAFTE_WT_GLOBAL, cc->flag1,
		    cc->flag2, 0, slp);
		break;
	case SESTYP_ALARM:
		/*
		 * On all nonzero but the 'muted' bit, we turn on the alarm,
		 */
		obp->cstat[3] &= ~0xa;
		if (obp->cstat[3] & 0x40) {
			cc->flag2 &= ~SAFT_FLG1_ALARM;
		} else if (obp->cstat[3] != 0) {
			cc->flag2 |= SAFT_FLG1_ALARM;
		} else {
			cc->flag2 &= ~SAFT_FLG1_ALARM;
		}
		ep->priv = obp->cstat[3];
		(void) wrbuf16(ssc, SAFTE_WT_GLOBAL, cc->flag1,
			cc->flag2, 0, slp);
		break;
	default:
		break;
	}
	ep->svalid = 0;
a380 1
}
d382 5
a386 22
static int
safte_getconfig(ses_softc_t *ssc)
{
	struct scfg *cfg;
	int err, amt;
	char *sdata;
	static char cdb[10] =
	    { READ_BUFFER, 1, SAFTE_RD_RDCFG, 0, 0, 0, 0, 0, SAFT_SCRATCH, 0 };

	cfg = ssc->ses_private;
	if (cfg == NULL)
		return (ENXIO);

	sdata = SES_MALLOC(SAFT_SCRATCH);
	if (sdata == NULL)
		return (ENOMEM);

	amt = SAFT_SCRATCH;
	err = ses_runcmd(ssc, cdb, 10, sdata, &amt);
	if (err) {
		SES_FREE(sdata, SAFT_SCRATCH);
		return (err);
d388 1
a388 17
	amt = SAFT_SCRATCH - amt;
	if (amt < 6) {
		SES_LOG(ssc, "too little data (%d) for configuration\n", amt);
		SES_FREE(sdata, SAFT_SCRATCH);
		return (EIO);
	}
	SES_VLOG(ssc, "Nfans %d Npwr %d Nslots %d Lck %d Ntherm %d Nspkrs %d\n",
	    sdata[0], sdata[1], sdata[2], sdata[3], sdata[4], sdata[5]);
	cfg->Nfans = sdata[0];
	cfg->Npwr = sdata[1];
	cfg->Nslots = sdata[2];
	cfg->DoorLock = sdata[3];
	cfg->Ntherm = sdata[4];
	cfg->Nspkrs = sdata[5];
	cfg->Nalarm = NPSEUDO_ALARM;
	SES_FREE(sdata, SAFT_SCRATCH);
	return (0);
d391 2
a392 2
static int
safte_rdstat(ses_softc_t *ssc, int slpflg)
d394 2
a395 132
	int err, oid, r, i, hiwater, nitems, amt;
	uint16_t tempflags;
	size_t buflen;
	uint8_t status, oencstat;
	char *sdata, cdb[10];
	struct scfg *cc = ssc->ses_private;


	/*
	 * The number of objects overstates things a bit,
	 * both for the bogus 'thermometer' entries and
	 * the drive status (which isn't read at the same
	 * time as the enclosure status), but that's okay.
	 */
	buflen = 4 * cc->Nslots;
	if (ssc->ses_nobjects > buflen)
		buflen = ssc->ses_nobjects;
	sdata = SES_MALLOC(buflen);
	if (sdata == NULL)
		return (ENOMEM);

	cdb[0] = READ_BUFFER;
	cdb[1] = 1;
	cdb[2] = SAFTE_RD_RDESTS;
	cdb[3] = 0;
	cdb[4] = 0;
	cdb[5] = 0;
	cdb[6] = 0;
	cdb[7] = (buflen >> 8) & 0xff;
	cdb[8] = buflen & 0xff;
	cdb[9] = 0;
	amt = buflen;
	err = ses_runcmd(ssc, cdb, 10, sdata, &amt);
	if (err) {
		SES_FREE(sdata, buflen);
		return (err);
	}
	hiwater = buflen - amt;


	/*
	 * invalidate all status bits.
	 */
	for (i = 0; i < ssc->ses_nobjects; i++)
		ssc->ses_objmap[i].svalid = 0;
	oencstat = ssc->ses_encstat & ALL_ENC_STAT;
	ssc->ses_encstat = 0;


	/*
	 * Now parse returned buffer.
	 * If we didn't get enough data back,
	 * that's considered a fatal error.
	 */
	oid = r = 0;

	for (nitems = i = 0; i < cc->Nfans; i++) {
		SAFT_BAIL(r, hiwater, sdata, buflen);
		/*
		 * 0 = Fan Operational
		 * 1 = Fan is malfunctioning
		 * 2 = Fan is not present
		 * 0x80 = Unknown or Not Reportable Status
		 */
		ssc->ses_objmap[oid].encstat[1] = 0;	/* resvd */
		ssc->ses_objmap[oid].encstat[2] = 0;	/* resvd */
		switch ((int)(uint8_t)sdata[r]) {
		case 0:
			nitems++;
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_OK;
			/*
			 * We could get fancier and cache
			 * fan speeds that we have set, but
			 * that isn't done now.
			 */
			ssc->ses_objmap[oid].encstat[3] = 7;
			break;

		case 1:
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_CRIT;
			/*
			 * FAIL and FAN STOPPED synthesized
			 */
			ssc->ses_objmap[oid].encstat[3] = 0x40;
			/*
			 * Enclosure marked with CRITICAL error
			 * if only one fan or no thermometers,
			 * else the NONCRITICAL error is set.
			 */
			if (cc->Nfans == 1 || cc->Ntherm == 0)
				ssc->ses_encstat |= SES_ENCSTAT_CRITICAL;
			else
				ssc->ses_encstat |= SES_ENCSTAT_NONCRITICAL;
			break;
		case 2:
			ssc->ses_objmap[oid].encstat[0] =
			    SES_OBJSTAT_NOTINSTALLED;
			ssc->ses_objmap[oid].encstat[3] = 0;
			/*
			 * Enclosure marked with CRITICAL error
			 * if only one fan or no thermometers,
			 * else the NONCRITICAL error is set.
			 */
			if (cc->Nfans == 1)
				ssc->ses_encstat |= SES_ENCSTAT_CRITICAL;
			else
				ssc->ses_encstat |= SES_ENCSTAT_NONCRITICAL;
			break;
		case 0x80:
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_UNKNOWN;
			ssc->ses_objmap[oid].encstat[3] = 0;
			ssc->ses_encstat |= SES_ENCSTAT_INFO;
			break;
		default:
			ssc->ses_objmap[oid].encstat[0] =
			    SES_OBJSTAT_UNSUPPORTED;
			SES_LOG(ssc, "Unknown fan%d status 0x%x\n", i,
			    sdata[r] & 0xff);
			break;
		}
		ssc->ses_objmap[oid++].svalid = 1;
		r++;
	}

	/*
	 * No matter how you cut it, no cooling elements when there
	 * should be some there is critical.
	 */
	if (cc->Nfans && nitems == 0) {
		ssc->ses_encstat |= SES_ENCSTAT_CRITICAL;
	}

d397 2
a398 20
	for (i = 0; i < cc->Npwr; i++) {
		SAFT_BAIL(r, hiwater, sdata, buflen);
		ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_UNKNOWN;
		ssc->ses_objmap[oid].encstat[1] = 0;	/* resvd */
		ssc->ses_objmap[oid].encstat[2] = 0;	/* resvd */
		ssc->ses_objmap[oid].encstat[3] = 0x20;	/* requested on */
		switch ((uint8_t)sdata[r]) {
		case 0x00:	/* pws operational and on */
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_OK;
			break;
		case 0x01:	/* pws operational and off */
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_OK;
			ssc->ses_objmap[oid].encstat[3] = 0x10;
			ssc->ses_encstat |= SES_ENCSTAT_INFO;
			break;
		case 0x10:	/* pws is malfunctioning and commanded on */
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_CRIT;
			ssc->ses_objmap[oid].encstat[3] = 0x61;
			ssc->ses_encstat |= SES_ENCSTAT_NONCRITICAL;
			break;
d400 9
a408 26
		case 0x11:	/* pws is malfunctioning and commanded off */
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_NONCRIT;
			ssc->ses_objmap[oid].encstat[3] = 0x51;
			ssc->ses_encstat |= SES_ENCSTAT_NONCRITICAL;
			break;
		case 0x20:	/* pws is not present */
			ssc->ses_objmap[oid].encstat[0] =
			    SES_OBJSTAT_NOTINSTALLED;
			ssc->ses_objmap[oid].encstat[3] = 0;
			ssc->ses_encstat |= SES_ENCSTAT_INFO;
			break;
		case 0x21:	/* pws is present */
			/*
			 * This is for enclosures that cannot tell whether the
			 * device is on or malfunctioning, but know that it is
			 * present. Just fall through.
			 */
			/* FALLTHROUGH */
		case 0x80:	/* Unknown or Not Reportable Status */
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_UNKNOWN;
			ssc->ses_objmap[oid].encstat[3] = 0;
			ssc->ses_encstat |= SES_ENCSTAT_INFO;
			break;
		default:
			SES_LOG(ssc, "unknown power supply %d status (0x%x)\n",
			    i, sdata[r] & 0xff);
a409 4
		}
		ssc->ses_objmap[oid++].svalid = 1;
		r++;
	}
a410 32
	/*
	 * Skip over Slot SCSI IDs
	 */
	r += cc->Nslots;

	/*
	 * We always have doorlock status, no matter what,
	 * but we only save the status if we have one.
	 */
	SAFT_BAIL(r, hiwater, sdata, buflen);
	if (cc->DoorLock) {
		/*
		 * 0 = Door Locked
		 * 1 = Door Unlocked, or no Lock Installed
		 * 0x80 = Unknown or Not Reportable Status
		 */
		ssc->ses_objmap[oid].encstat[1] = 0;
		ssc->ses_objmap[oid].encstat[2] = 0;
		switch ((uint8_t)sdata[r]) {
		case 0:
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_OK;
			ssc->ses_objmap[oid].encstat[3] = 0;
			break;
		case 1:
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_OK;
			ssc->ses_objmap[oid].encstat[3] = 1;
			break;
		case 0x80:
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_UNKNOWN;
			ssc->ses_objmap[oid].encstat[3] = 0;
			ssc->ses_encstat |= SES_ENCSTAT_INFO;
			break;
d412 1
a412 4
			ssc->ses_objmap[oid].encstat[0] =
			    SES_OBJSTAT_UNSUPPORTED;
			SES_LOG(ssc, "unknown lock status 0x%x\n",
			    sdata[r] & 0xff);
a414 1
		ssc->ses_objmap[oid++].svalid = 1;
a415 1
	r++;
d417 1
a417 150
	/*
	 * We always have speaker status, no matter what,
	 * but we only save the status if we have one.
	 */
	SAFT_BAIL(r, hiwater, sdata, buflen);
	if (cc->Nspkrs) {
		ssc->ses_objmap[oid].encstat[1] = 0;
		ssc->ses_objmap[oid].encstat[2] = 0;
		if (sdata[r] == 1) {
			/*
			 * We need to cache tone urgency indicators.
			 * Someday.
			 */
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_NONCRIT;
			ssc->ses_objmap[oid].encstat[3] = 0x8;
			ssc->ses_encstat |= SES_ENCSTAT_NONCRITICAL;
		} else if (sdata[r] == 0) {
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_OK;
			ssc->ses_objmap[oid].encstat[3] = 0;
		} else {
			ssc->ses_objmap[oid].encstat[0] =
			    SES_OBJSTAT_UNSUPPORTED;
			ssc->ses_objmap[oid].encstat[3] = 0;
			SES_LOG(ssc, "unknown spkr status 0x%x\n",
			    sdata[r] & 0xff);
		}
		ssc->ses_objmap[oid++].svalid = 1;
	}
	r++;

	for (i = 0; i < cc->Ntherm; i++) {
		SAFT_BAIL(r, hiwater, sdata, buflen);
		/*
		 * Status is a range from -10 to 245 deg Celsius,
		 * which we need to normalize to -20 to -245 according
		 * to the latest SCSI spec, which makes little
		 * sense since this would overflow an 8bit value.
		 * Well, still, the base normalization is -20,
		 * not -10, so we have to adjust.
		 *
		 * So what's over and under temperature?
		 * Hmm- we'll state that 'normal' operating
		 * is 10 to 40 deg Celsius.
		 */
		ssc->ses_objmap[oid].encstat[1] = 0;
		ssc->ses_objmap[oid].encstat[2] =
		    ((unsigned int) sdata[r]) - 10;
		if (sdata[r] < 20) {
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_CRIT;
			/*
			 * Set 'under temperature' failure.
			 */
			ssc->ses_objmap[oid].encstat[3] = 2;
			ssc->ses_encstat |= SES_ENCSTAT_CRITICAL;
		} else if (sdata[r] > 30) {
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_CRIT;
			/*
			 * Set 'over temperature' failure.
			 */
			ssc->ses_objmap[oid].encstat[3] = 8;
			ssc->ses_encstat |= SES_ENCSTAT_CRITICAL;
		} else {
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_OK;
		}
		ssc->ses_objmap[oid++].svalid = 1;
		r++;
	}

	/*
	 * Now, for "pseudo" thermometers, we have two bytes
	 * of information in enclosure status- 16 bits. Actually,
	 * the MSB is a single TEMP ALERT flag indicating whether
	 * any other bits are set, but, thanks to fuzzy thinking,
	 * in the SAF-TE spec, this can also be set even if no
	 * other bits are set, thus making this really another
	 * binary temperature sensor.
	 */

	SAFT_BAIL(r, hiwater, sdata, buflen);
	tempflags = sdata[r++];
	SAFT_BAIL(r, hiwater, sdata, buflen);
	tempflags |= (tempflags << 8) | sdata[r++];

	for (i = 0; i < NPSEUDO_THERM; i++) {
		ssc->ses_objmap[oid].encstat[1] = 0;
		if (tempflags & (1 << (NPSEUDO_THERM - i - 1))) {
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_CRIT;
			ssc->ses_objmap[4].encstat[2] = 0xff;
			/*
			 * Set 'over temperature' failure.
			 */
			ssc->ses_objmap[oid].encstat[3] = 8;
			ssc->ses_encstat |= SES_ENCSTAT_CRITICAL;
		} else {
			/*
			 * We used to say 'not available' and synthesize a
			 * nominal 30 deg (C)- that was wrong. Actually,
			 * Just say 'OK', and use the reserved value of
			 * zero.
			 */
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_OK;
			ssc->ses_objmap[oid].encstat[2] = 0;
			ssc->ses_objmap[oid].encstat[3] = 0;
		}
		ssc->ses_objmap[oid++].svalid = 1;
	}

	/*
	 * Get alarm status.
	 */
	ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_OK;
	ssc->ses_objmap[oid].encstat[3] = ssc->ses_objmap[oid].priv;
	ssc->ses_objmap[oid++].svalid = 1;

	/*
	 * Now get drive slot status
	 */
	cdb[2] = SAFTE_RD_RDDSTS;
	amt = buflen;
	err = ses_runcmd(ssc, cdb, 10, sdata, &amt);
	if (err) {
		SES_FREE(sdata, buflen);
		return (err);
	}
	hiwater = buflen - amt;
	for (r = i = 0; i < cc->Nslots; i++, r += 4) {
		SAFT_BAIL(r+3, hiwater, sdata, buflen);
		ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_UNSUPPORTED;
		ssc->ses_objmap[oid].encstat[1] = (uint8_t) i;
		ssc->ses_objmap[oid].encstat[2] = 0;
		ssc->ses_objmap[oid].encstat[3] = 0;
		status = sdata[r+3];
		if ((status & 0x1) == 0) {	/* no device */
			ssc->ses_objmap[oid].encstat[0] =
			    SES_OBJSTAT_NOTINSTALLED;
		} else {
			ssc->ses_objmap[oid].encstat[0] = SES_OBJSTAT_OK;
		}
		if (status & 0x2) {
			ssc->ses_objmap[oid].encstat[2] = 0x8;
		}
		if ((status & 0x4) == 0) {
			ssc->ses_objmap[oid].encstat[3] = 0x10;
		}
		ssc->ses_objmap[oid++].svalid = 1;
	}
	/* see comment below about sticky enclosure status */
	ssc->ses_encstat |= ENCI_SVALID | oencstat;
	SES_FREE(sdata, buflen);
	return (0);
d420 2
a421 2
static int
set_objstat_sel(ses_softc_t *ssc, ses_objstat *obp, int slp)
d423 1
a423 3
	int idx;
	encobj *ep;
	struct scfg *cc = ssc->ses_private;
d425 4
a428 2
	if (cc == NULL)
		return (0);
d430 1
a430 69
	idx = (int)obp->obj_id;
	ep = &ssc->ses_objmap[idx];

	switch (ep->enctype) {
	case SESTYP_DEVICE:
		if (obp->cstat[0] & SESCTL_PRDFAIL) {
			ep->priv |= 0x40;
		}
		/* SESCTL_RSTSWAP has no correspondence in SAF-TE */
		if (obp->cstat[0] & SESCTL_DISABLE) {
			ep->priv |= 0x80;
			/*
			 * Hmm. Try to set the 'No Drive' flag.
			 * Maybe that will count as a 'disable'.
			 */
		}
		if (ep->priv & 0xc6) {
			ep->priv &= ~0x1;
		} else {
			ep->priv |= 0x1;	/* no errors */
		}
		wrslot_stat(ssc, slp);
		break;
	case SESTYP_POWER:
		/*
		 * Okay- the only one that makes sense here is to
		 * do the 'disable' for a power supply.
		 */
		if (obp->cstat[0] & SESCTL_DISABLE) {
			(void) wrbuf16(ssc, SAFTE_WT_ACTPWS,
				idx - cc->pwroff, 0, 0, slp);
		}
		break;
	case SESTYP_FAN:
		/*
		 * Okay- the only one that makes sense here is to
		 * set fan speed to zero on disable.
		 */
		if (obp->cstat[0] & SESCTL_DISABLE) {
			/* remember- fans are the first items, so idx works */
			(void) wrbuf16(ssc, SAFTE_WT_FANSPD, idx, 0, 0, slp);
		}
		break;
	case SESTYP_DOORLOCK:
		/*
		 * Well, we can 'disable' the lock.
		 */
		if (obp->cstat[0] & SESCTL_DISABLE) {
			cc->flag2 &= ~SAFT_FLG2_LOCKDOOR;
			(void) wrbuf16(ssc, SAFTE_WT_GLOBAL, cc->flag1,
				cc->flag2, 0, slp);
		}
		break;
	case SESTYP_ALARM:
		/*
		 * Well, we can 'disable' the alarm.
		 */
		if (obp->cstat[0] & SESCTL_DISABLE) {
			cc->flag2 &= ~SAFT_FLG1_ALARM;
			ep->priv |= 0x40;	/* Muted */
			(void) wrbuf16(ssc, SAFTE_WT_GLOBAL, cc->flag1,
				cc->flag2, 0, slp);
		}
		break;
	default:
		break;
	}
	ep->svalid = 0;
	return (0);
d433 3
a435 6
/*
 * This function handles all of the 16 byte WRITE BUFFER commands.
 */
static int
wrbuf16(ses_softc_t *ssc, uint8_t op, uint8_t b1, uint8_t b2,
    uint8_t b3, int slp)
d437 1
a437 4
	int err, amt;
	char *sdata;
	struct scfg *cc = ssc->ses_private;
	static char cdb[10] = { WRITE_BUFFER, 1, 0, 0, 0, 0, 0, 0, 16, 0 };
d439 6
a444 2
	if (cc == NULL)
		return (0);
d446 3
a448 16
	sdata = SES_MALLOC(16);
	if (sdata == NULL)
		return (ENOMEM);

	SES_DLOG(ssc, "saf_wrbuf16 %x %x %x %x\n", op, b1, b2, b3);

	sdata[0] = op;
	sdata[1] = b1;
	sdata[2] = b2;
	sdata[3] = b3;
	MEMZERO(&sdata[4], 12);
	amt = -16;
	err = ses_runcmd(ssc, cdb, 10, sdata, &amt);
	SES_FREE(sdata, 16);
	return (err);
}
d450 3
a452 28
/*
 * This function updates the status byte for the device slot described.
 *
 * Since this is an optional SAF-TE command, there's no point in
 * returning an error.
 */
static void
wrslot_stat(ses_softc_t *ssc, int slp)
{
	int i, amt;
	encobj *ep;
	char cdb[10], *sdata;
	struct scfg *cc = ssc->ses_private;

	if (cc == NULL)
		return;

	SES_DLOG(ssc, "saf_wrslot\n");
	cdb[0] = WRITE_BUFFER;
	cdb[1] = 1;
	cdb[2] = 0;
	cdb[3] = 0;
	cdb[4] = 0;
	cdb[5] = 0;
	cdb[6] = 0;
	cdb[7] = 0;
	cdb[8] = cc->Nslots * 3 + 1;
	cdb[9] = 0;
d454 3
a456 14
	sdata = SES_MALLOC(cc->Nslots * 3 + 1);
	if (sdata == NULL)
		return;
	MEMZERO(sdata, cc->Nslots * 3 + 1);

	sdata[0] = SAFTE_WT_DSTAT;
	for (i = 0; i < cc->Nslots; i++) {
		ep = &ssc->ses_objmap[cc->slotoff + i];
		SES_DLOG(ssc, "saf_wrslot %d <- %x\n", i, ep->priv & 0xff);
		sdata[1 + (3 * i)] = ep->priv & 0xff;
	}
	amt = -(cc->Nslots * 3 + 1);
	(void) ses_runcmd(ssc, cdb, 10, sdata, &amt);
	SES_FREE(sdata, cc->Nslots * 3 + 1);
d459 2
a460 5
/*
 * This function issues the "PERFORM SLOT OPERATION" command.
 */
static int
perf_slotop(ses_softc_t *ssc, uint8_t slot, uint8_t opflag, int slp)
d462 1
a462 5
	int err, amt;
	char *sdata;
	struct scfg *cc = ssc->ses_private;
	static char cdb[10] =
	    { WRITE_BUFFER, 1, 0, 0, 0, 0, 0, 0, SAFT_SCRATCH, 0 };
d464 3
a466 2
	if (cc == NULL)
		return (0);
d468 1
a468 13
	sdata = SES_MALLOC(SAFT_SCRATCH);
	if (sdata == NULL)
		return (ENOMEM);
	MEMZERO(sdata, SAFT_SCRATCH);

	sdata[0] = SAFTE_WT_SLTOP;
	sdata[1] = slot;
	sdata[2] = opflag;
	SES_DLOG(ssc, "saf_slotop slot %d op %x\n", slot, opflag);
	amt = -SAFT_SCRATCH;
	err = ses_runcmd(ssc, cdb, 10, sdata, &amt);
	SES_FREE(sdata, SAFT_SCRATCH);
	return (err);
d470 1
@


1.7
log
@Add missing <cr>'s to various SC_DEBUG() calls, along with a few other
SC_DEBUG() spacing tweaks.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.6 2004/01/03 14:08:54 espie Exp $ */
@


1.6
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.5 2003/08/06 21:08:07 millert Exp $ */
d265 1
a265 1
	SC_DEBUG(sc_link, SDEV_DB2, ("ssattach: "));
d455 1
a455 1
	SC_DEBUG(ssc->sc_link, SDEV_DB2, ("sesioctl 0x%lx ", cmd));
@


1.5
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.4 2002/03/15 18:19:53 millert Exp $ */
d52 1
a52 1
#include <machine/stdarg.h>
@


1.4
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.3 2002/03/14 01:27:13 millert Exp $ */
d1458 1
a1458 1
static int safte_rdstat(ses_softc_t *, int);;
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.2 2001/06/22 14:35:43 deraadt Exp $ */
a596 1
#ifdef	__STDC__
a606 15
#else
static void
ses_log(ssc, fmt, va_alist)
	struct ses_softc *ssc;
	char *fmt;
	va_dcl
{
	va_list ap;

	printf("%s: ", ssc->sc_device.dv_xname);
	va_start(ap, fmt);
	vprintf(fmt, ap);
	va_end(ap);
}
#endif
@


1.2
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.1 2000/02/21 08:23:30 mjacob Exp $ */
d99 6
a104 6
	int (*softc_init) 	__P((ses_softc_t *, int));
	int (*init_enc)		__P((ses_softc_t *));
	int (*get_encstat)	__P((ses_softc_t *, int));
	int (*set_encstat)	__P((ses_softc_t *, ses_encstat, int));
	int (*get_objstat)	__P((ses_softc_t *, ses_objstat *, int));
	int (*set_objstat)	__P((ses_softc_t *, ses_objstat *, int));
d121 1
a121 1
static enctyp ses_type __P((void *, int));
d125 13
a137 13
static int ses_softc_init __P((ses_softc_t *, int));
static int ses_init_enc __P((ses_softc_t *));
static int ses_get_encstat __P((ses_softc_t *, int));
static int ses_set_encstat __P((ses_softc_t *, uint8_t, int));
static int ses_get_objstat __P((ses_softc_t *, ses_objstat *, int));
static int ses_set_objstat __P((ses_softc_t *, ses_objstat *, int));

static int safte_softc_init __P((ses_softc_t *, int));
static int safte_init_enc __P((ses_softc_t *));
static int safte_get_encstat __P((ses_softc_t *, int));
static int safte_set_encstat __P((ses_softc_t *, uint8_t, int));
static int safte_get_objstat __P((ses_softc_t *, ses_objstat *, int));
static int safte_set_objstat __P((ses_softc_t *, ses_objstat *, int));
d165 3
a167 3
int sesopen __P((dev_t, int, int, struct proc *));
int sesclose __P((dev_t, int, int, struct proc *));
int sesioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
d169 2
a170 2
static int ses_runcmd	__P((struct ses_softc *, char *, int, char *, int *));
static void ses_log	__P((struct ses_softc *, const char *, ...));
d199 3
a201 3
static int ses_match __P((struct device *, MATCHTYPE *, void *));
static void ses_attach __P((struct device *, struct device *, void *));
static enctyp ses_device_type __P((struct scsipibus_attach_args *));
@


1.2.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.2 2001/06/22 14:35:43 deraadt Exp $ */
d99 6
a104 6
	int (*softc_init)(ses_softc_t *, int);
	int (*init_enc)(ses_softc_t *);
	int (*get_encstat)(ses_softc_t *, int);
	int (*set_encstat)(ses_softc_t *, ses_encstat, int);
	int (*get_objstat)(ses_softc_t *, ses_objstat *, int);
	int (*set_objstat)(ses_softc_t *, ses_objstat *, int);
d121 1
a121 1
static enctyp ses_type(void *, int);
d125 13
a137 13
static int ses_softc_init(ses_softc_t *, int);
static int ses_init_enc(ses_softc_t *);
static int ses_get_encstat(ses_softc_t *, int);
static int ses_set_encstat(ses_softc_t *, uint8_t, int);
static int ses_get_objstat(ses_softc_t *, ses_objstat *, int);
static int ses_set_objstat(ses_softc_t *, ses_objstat *, int);

static int safte_softc_init(ses_softc_t *, int);
static int safte_init_enc(ses_softc_t *);
static int safte_get_encstat(ses_softc_t *, int);
static int safte_set_encstat(ses_softc_t *, uint8_t, int);
static int safte_get_objstat(ses_softc_t *, ses_objstat *, int);
static int safte_set_objstat(ses_softc_t *, ses_objstat *, int);
d165 3
a167 3
int sesopen(dev_t, int, int, struct proc *);
int sesclose(dev_t, int, int, struct proc *);
int sesioctl(dev_t, u_long, caddr_t, int, struct proc *);
d169 2
a170 2
static int ses_runcmd(struct ses_softc *, char *, int, char *, int *);
static void ses_log(struct ses_softc *, const char *, ...);
d199 3
a201 3
static int ses_match(struct device *, MATCHTYPE *, void *);
static void ses_attach(struct device *, struct device *, void *);
static enctyp ses_device_type(struct scsipibus_attach_args *);
d597 1
d608 15
@


1.1
log
@add SES/SAF-TE SCSI device
@
text
@d1 1
a1 1
/*	$OpenBSD: $ */
d275 1
a275 1
        case SES_SES_PASSTHROUGH:
d283 1
a283 1
        case SES_SAFT:
d291 1
a291 1
        case SES_SEN:
d309 1
a309 1
        case SES_SES_PASSTHROUGH:
d312 1
a312 1
        case SES_SEN:
d315 1
a315 1
        case SES_SAFT:
d395 1
a395 1
                goto out;
d439 1
a439 1
	int flag;       
@


1.1.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.1 2000/02/21 08:23:30 mjacob Exp $ */
@


1.1.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ses.c,v 1.1.2.1 2000/02/21 22:29:15 niklas Exp $ */
d275 1
a275 1
	case SES_SES_PASSTHROUGH:
d283 1
a283 1
	case SES_SAFT:
d291 1
a291 1
	case SES_SEN:
d309 1
a309 1
	case SES_SES_PASSTHROUGH:
d312 1
a312 1
	case SES_SEN:
d315 1
a315 1
	case SES_SAFT:
d395 1
a395 1
		goto out;
d439 1
a439 1
	int flag;
@


1.1.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d99 6
a104 6
	int (*softc_init)(ses_softc_t *, int);
	int (*init_enc)(ses_softc_t *);
	int (*get_encstat)(ses_softc_t *, int);
	int (*set_encstat)(ses_softc_t *, ses_encstat, int);
	int (*get_objstat)(ses_softc_t *, ses_objstat *, int);
	int (*set_objstat)(ses_softc_t *, ses_objstat *, int);
d121 1
a121 1
static enctyp ses_type(void *, int);
d125 13
a137 13
static int ses_softc_init(ses_softc_t *, int);
static int ses_init_enc(ses_softc_t *);
static int ses_get_encstat(ses_softc_t *, int);
static int ses_set_encstat(ses_softc_t *, uint8_t, int);
static int ses_get_objstat(ses_softc_t *, ses_objstat *, int);
static int ses_set_objstat(ses_softc_t *, ses_objstat *, int);

static int safte_softc_init(ses_softc_t *, int);
static int safte_init_enc(ses_softc_t *);
static int safte_get_encstat(ses_softc_t *, int);
static int safte_set_encstat(ses_softc_t *, uint8_t, int);
static int safte_get_objstat(ses_softc_t *, ses_objstat *, int);
static int safte_set_objstat(ses_softc_t *, ses_objstat *, int);
d165 3
a167 3
int sesopen(dev_t, int, int, struct proc *);
int sesclose(dev_t, int, int, struct proc *);
int sesioctl(dev_t, u_long, caddr_t, int, struct proc *);
d169 2
a170 2
static int ses_runcmd(struct ses_softc *, char *, int, char *, int *);
static void ses_log(struct ses_softc *, const char *, ...);
d199 3
a201 3
static int ses_match(struct device *, MATCHTYPE *, void *);
static void ses_attach(struct device *, struct device *, void *);
static enctyp ses_device_type(struct scsipibus_attach_args *);
d597 1
d608 15
@


1.1.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d52 1
a52 1
#include <sys/stdarg.h>
d1458 1
a1458 1
static int safte_rdstat(ses_softc_t *, int);
@


1.1.2.5
log
@Merge with the trunk
@
text
@d265 1
a265 1
	SC_DEBUG(sc_link, SDEV_DB2, ("ssattach:\n"));
d455 1
a455 1
	SC_DEBUG(ssc->sc_link, SDEV_DB2, ("sesioctl 0x%lx\n", cmd));
@


