head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.12
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.10
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.6
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.8.0.10
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.8
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.6
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.4
	OPENBSD_5_0:1.8.0.2
	OPENBSD_5_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.21
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.20;
commitid	p4LJxGKbi0BU2cG6;

1.20
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.19;
commitid	uzzBR7hz9ncd4O6G;

1.19
date	2014.04.19.05.05.43;	author jmatthew;	state Exp;
branches;
next	1.18;

1.18
date	2014.04.19.05.00.06;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2014.04.17.06.38.54;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2013.11.23.23.35.02;	author gsoares;	state Exp;
branches;
next	1.14;

1.14
date	2013.08.27.00.57.43;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2013.08.27.00.53.09;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2013.08.27.00.24.03;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2013.08.26.10.13.17;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2013.08.26.07.38.56;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2013.08.26.07.29.45;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.11.01.02.48;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.03.15.47.18;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	2011.06.16.08.42.30;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2011.06.15.01.10.50;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2011.04.28.10.43.36;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.27.09.09.36;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.27.07.14.50;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.05.14.25.42;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: mpath_emc.c,v 1.20 2014/09/14 14:17:26 jsg Exp $ */

/*
 * Copyright (c) 2011 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* EMC CLARiiON AX/CX support for mpath(4) */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/queue.h>
#include <sys/rwlock.h>
#include <sys/pool.h>
#include <sys/ioctl.h>
#include <sys/poll.h>
#include <sys/selinfo.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/mpathvar.h>

#define EMC_VPD_SP_INFO			0xc0

struct emc_vpd_sp_info {
	struct scsi_vpd_hdr	hdr; /* EMC_VPD_SP_INFO */

	u_int8_t		lun_state;
#define EMC_SP_INFO_LUN_STATE_UNBOUND	0x00
#define EMC_SP_INFO_LUN_STATE_BOUND	0x01
#define EMC_SP_INFO_LUN_STATE_OWNED	0x02
	u_int8_t		default_sp;
	u_int8_t		_reserved1[1];
	u_int8_t		port;
	u_int8_t		current_sp;
	u_int8_t		_reserved2[1];
	u_int8_t		unique_id[16];
	u_int8_t		_reserved3[1];
	u_int8_t		type;
	u_int8_t		failover_mode;
	u_int8_t		_reserved4[21];
	u_int8_t		serial[16];
} __packed;

struct emc_softc {
	struct device		sc_dev;
	struct mpath_path	sc_path;
	struct scsi_xshandler   sc_xsh;
	struct emc_vpd_sp_info	*sc_pg;
};
#define DEVNAME(_s) ((_s)->sc_dev.dv_xname)

int		emc_match(struct device *, void *, void *);
void		emc_attach(struct device *, struct device *, void *);
int		emc_detach(struct device *, int);
int		emc_activate(struct device *, int);

struct cfattach emc_ca = {
	sizeof(struct emc_softc),
	emc_match,
	emc_attach,
	emc_detach,
	emc_activate
};

struct cfdriver emc_cd = {
	NULL,
	"emc",
	DV_DULL
};

void		emc_mpath_start(struct scsi_xfer *);
int		emc_mpath_checksense(struct scsi_xfer *);
void		emc_mpath_status(struct scsi_link *);

const struct mpath_ops emc_mpath_ops = {
	"emc",
	emc_mpath_checksense,
	emc_mpath_status
};

struct emc_device {
	char *vendor;
	char *product;
};

void		emc_status(struct scsi_xfer *);
void		emc_status_done(struct scsi_xfer *);

int		emc_sp_info(struct emc_softc *, int *);

struct emc_device emc_devices[] = {
/*	  " vendor "  "     device     " */
/*	  "01234567"  "0123456789012345" */
	{ "DGC     ", "RAID" },
	{ "DGC     ", "DISK" },
	{ "DGC     ", "VRAID" }
};

int
emc_match(struct device *parent, void *match, void *aux)
{
	struct scsi_attach_args *sa = aux;
	struct scsi_inquiry_data *inq = sa->sa_inqbuf;
	struct emc_device *s;
	int i;

	if (mpath_path_probe(sa->sa_sc_link) != 0)
		return (0);

	for (i = 0; i < nitems(emc_devices); i++) {
		s = &emc_devices[i];

		if (bcmp(s->vendor, inq->vendor, strlen(s->vendor)) == 0 &&
		    bcmp(s->product, inq->product, strlen(s->product)) == 0)
			return (8);
	}

	return (0);
}

void
emc_attach(struct device *parent, struct device *self, void *aux)
{
	struct emc_softc *sc = (struct emc_softc *)self;
	struct scsi_attach_args *sa = aux;
	struct scsi_link *link = sa->sa_sc_link;
	int sp;

	printf("\n");

	/* init link */
	link->device_softc = sc;

	/* init path */
	scsi_xsh_set(&sc->sc_path.p_xsh, link, emc_mpath_start);
	sc->sc_path.p_link = link;

	/* init status handler */
	scsi_xsh_set(&sc->sc_xsh, link, emc_status);
	sc->sc_pg = dma_alloc(sizeof(*sc->sc_pg), PR_WAITOK);

	/* let's go */

	if (emc_sp_info(sc, &sp)) {
		printf("%s: unable to get sp info\n", DEVNAME(sc));
		return;
	}

	if (mpath_path_attach(&sc->sc_path, sp, &emc_mpath_ops) != 0)
		printf("%s: unable to attach path\n", DEVNAME(sc));
}

int
emc_detach(struct device *self, int flags)
{
	struct emc_softc *sc = (struct emc_softc *)self;

	dma_free(sc->sc_pg, sizeof(*sc->sc_pg));

	return (0);
}

int
emc_activate(struct device *self, int act)
{
	struct emc_softc *sc = (struct emc_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		if (sc->sc_path.p_group != NULL)
			mpath_path_detach(&sc->sc_path);
		break;
	}
	return (rv);
}

void
emc_mpath_start(struct scsi_xfer *xs)
{
	struct emc_softc *sc = xs->sc_link->device_softc;

	mpath_start(&sc->sc_path, xs);
}

int
emc_mpath_checksense(struct scsi_xfer *xs)
{
	struct scsi_sense_data *sense = &xs->sense;

	if ((sense->error_code & SSD_ERRCODE) == SSD_ERRCODE_CURRENT &&
	    (sense->flags & SSD_KEY) == SKEY_NOT_READY &&
	    ASC_ASCQ(sense) == 0x0403) {
		/* Logical Unit Not Ready, Manual Intervention Required */
		return (MPATH_SENSE_FAILOVER);
	}

	return (MPATH_SENSE_DECLINED);
}

void
emc_mpath_status(struct scsi_link *link)
{
	struct emc_softc *sc = link->device_softc;

	scsi_xsh_add(&sc->sc_xsh);
}

void
emc_status(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct emc_softc *sc = link->device_softc;

	scsi_init_inquiry(xs, SI_EVPD, EMC_VPD_SP_INFO,
	    sc->sc_pg, sizeof(*sc->sc_pg));

	xs->done = emc_status_done;

	scsi_xs_exec(xs);
}

void
emc_status_done(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct emc_softc *sc = link->device_softc;
	struct emc_vpd_sp_info *pg = sc->sc_pg;
	int status = MPATH_S_UNKNOWN;

	if (xs->error == XS_NOERROR) {
		status = (pg->lun_state == EMC_SP_INFO_LUN_STATE_OWNED) ?
		    MPATH_S_ACTIVE : MPATH_S_PASSIVE;
	}

	scsi_xs_put(xs);

	mpath_path_status(&sc->sc_path, status);
}

int
emc_sp_info(struct emc_softc *sc, int *sp)
{
	struct emc_vpd_sp_info *pg = sc->sc_pg;
	int error;

	error = scsi_inquire_vpd(sc->sc_path.p_link, pg, sizeof(*pg),
	    EMC_VPD_SP_INFO, scsi_autoconf);
	if (error != 0)
		return (error);

	*sp = pg->current_sp;

	printf("%s: SP-%c port %d\n", DEVNAME(sc), pg->current_sp + 'A',
	    pg->port);

	return (0);
}
@


1.20
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.19 2014/04/19 05:05:43 jmatthew Exp $ */
a22 1
#include <sys/buf.h>
@


1.19
log
@move scsi_xs_put after checks that use fields in the xs

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.18 2014/04/19 05:00:06 dlg Exp $ */
a26 1
#include <sys/proc.h>
@


1.18
log
@implement emc_mpath_checksense() according to what my cx500 throws.

tested by jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.17 2014/04/17 06:38:54 dlg Exp $ */
a248 2
	scsi_xs_put(xs);

d253 2
@


1.17
log
@rework this to implement the active path checks when mpath asks for
it rather than on attach. just need to implement a sense handler
to detect failover and this is done.

thanks to jmatthew@@ for plugging this together again for me.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.16 2013/12/06 21:03:02 deraadt Exp $ */
d207 9
@


1.16
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.15 2013/11/23 23:35:02 gsoares Exp $ */
d65 2
a66 5
	u_int			sc_flags;
	u_int8_t		sc_sp;
	u_int8_t		sc_port;
	u_int8_t		sc_lun_state;

d104 4
a107 2
int		emc_inquiry(struct emc_softc *, char *, char *);
int		emc_sp_info(struct emc_softc *);
a111 1
	{ "DGC     ", "LUNZ" },
a141 1
	char model[256], serial[256];
d145 1
d156 3
a158 4
	if (emc_sp_info(sc)) {
		printf("%s: unable to get sp info\n", DEVNAME(sc));
		return;
	}
d160 1
a160 4
	if (emc_inquiry(sc, model, serial) != 0) {
		printf("%s: unable to get inquiry data\n", DEVNAME(sc));
		return;
	}
d162 2
a163 5
	printf("%s: %s %s SP-%c port %d\n", DEVNAME(sc), model, serial,
	    sc->sc_sp + 'A', sc->sc_port);

	if (sc->sc_lun_state != EMC_SP_INFO_LUN_STATE_OWNED) {
		/* XXX add failover support */
d167 1
a167 1
	if (mpath_path_attach(&sc->sc_path, sc->sc_sp, &emc_mpath_ops) != 0)
d174 4
d215 1
a215 1
	mpath_path_status(&sc->sc_path, MPATH_S_UNKNOWN);
d218 2
a219 2
int
emc_inquiry(struct emc_softc *sc, char *model, char *serial)
d221 2
a222 5
	u_int8_t *buffer;
	struct scsi_xfer *xs;
	size_t length;
	int error;
	u_int8_t slen, mlen;
d224 2
a225 5
	length = MIN(sc->sc_path.p_link->inqdata.additional_length + 5, 255);
	if (length < 160) {
		printf("%s: FC (Legacy)\n", DEVNAME(sc));
		return (0);
	}
d227 1
a227 1
	buffer = dma_alloc(length, PR_WAITOK);
d229 2
a230 5
	xs = scsi_xs_get(sc->sc_path.p_link, scsi_autoconf);
	if (xs == NULL) {
		error = EBUSY;
		goto done;
	}
d232 7
a238 1
	scsi_init_inquiry(xs, 0, 0, buffer, length);
a239 1
	error = scsi_xs_sync(xs);
d242 3
a244 13
	if (error != 0)
		goto done;

	slen = buffer[160];
	if (slen == 0 || slen + 161 > length) {
		error = EIO;
		goto done;
	}

	mlen = buffer[99];
	if (mlen == 0 || slen + mlen + 161 > length) {
		error = EIO;
		goto done;
d247 1
a247 7
	scsi_strvis(serial, buffer + 161, slen);
	scsi_strvis(model, buffer + 161 + slen, mlen);

	error = 0;
done:
	dma_free(buffer, length);
	return (error);
d251 1
a251 1
emc_sp_info(struct emc_softc *sc)
d253 1
a253 1
	struct emc_vpd_sp_info *pg;
a255 2
	pg = dma_alloc(sizeof(*pg), PR_WAITOK);

d259 3
a261 1
		goto done;
d263 4
a266 8
	sc->sc_sp = pg->current_sp;
	sc->sc_port = pg->port;
	sc->sc_lun_state = pg->lun_state;

	error = 0;
done:
	dma_free(pg, sizeof(*pg));
	return (error);
@


1.15
log
@fix format string; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.14 2013/08/27 00:57:43 dlg Exp $ */
a192 3
	case DVACT_SUSPEND:
	case DVACT_RESUME:
		break;
@


1.14
log
@make path driver match routes return 8 so they will definitely be higher
than the real device drivers. ses returns 3 on some dells, which could be
confusing for autoconf if it has to decide between that and a path driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.13 2013/08/27 00:53:09 dlg Exp $ */
d237 1
a237 1
		printf("%s: FC (Legacy)\n");
@


1.13
log
@get rid of the different path scheduler types, which simplifies the
code that picks the next path. we assume roundrobin within a group
of paths now. the asym sym(4) devices work around this by putting
every path in its own group.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.12 2013/08/27 00:24:03 dlg Exp $ */
d135 1
a135 1
			return (3);
@


1.12
log
@these were forgotten in the change from pointing paths to groups instead
of devices. fixes compilation when theyre enabled.

how embarrassment.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.11 2013/08/26 10:13:17 dlg Exp $ */
d99 1
a99 2
	emc_mpath_status,
	MPATH_ROUNDROBIN
@


1.11
log
@when i first imagined how paths on mpath worked, i thought the
midlayer would be able to call things on paths to explicitely online
or offline them. turns out thats not how the Real World(tm) works,
instead its better to wait for failure and probe for the status of
paths, and pick the active group of paths from that. there's even
evidence that the mechanisms for forcing controllers into active/passive
roles from the scsi initiator are being deprecated. they expect
hosts to be able to cope with arbitrary controller role changes and
failover
accordingly.

this replaces the online and offline function pointers in the path_ops
structure with a status check function pointer. instead of returning a
state, the checker is expected to call mpath_path_status() when its
finished figuring out what the state is.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.10 2013/08/26 07:38:56 dlg Exp $ */
d198 1
a198 1
		if (sc->sc_path.p_dev != NULL)
@


1.10
log
@checksense handlers in path drivers can return MPATH_SENSE_DECLINED
(who can tell ive spent time in web servers) to say they decline
interpreting the sense data, or MPATH_SENSE_FAILOVER to say the
sense data is from the controller saying its failed over.

all path drivers currently decline handling sense data.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.9 2013/08/26 07:29:45 dlg Exp $ */
d94 1
a94 2
int		emc_mpath_online(struct scsi_link *);
int		emc_mpath_offline(struct scsi_link *);
d99 1
a99 2
	emc_mpath_online,
	emc_mpath_offline,
d219 2
a220 2
int
emc_mpath_online(struct scsi_link *link)
d222 1
a222 2
	return (0);
}
d224 1
a224 4
int
emc_mpath_offline(struct scsi_link *link)
{
	return (0);
@


1.9
log
@introduce the idea of groups of paths. mpath had stuff to managed
devices and paths. devices are what mpath presents as targets on
its scsibus, and paths are the things attached to hardware controllers
that are available to shove io down to the actual real target. all
paths were considered usable for handling io on behalf of a device.

this adds groups in between devices and paths. only paths on the
first group in the list will now be used to handle io now.

sym devices will only have one group. asym devices will treat each
path as a different group. rdac, emc, and hds will group paths based
on which controller in the array theyre connected to.

in the future we will intercept sense data from passive controllers
and use that to start running checks to pick a new primary group
so we can handle controller failover situations.

the group id in hds(4) is currently busted, everything else should
be correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.8 2011/07/11 01:02:48 dlg Exp $ */
d218 1
a218 1
	return (0);
@


1.8
log
@support "failover" style access to volumes, ie, only use one active
path when talking to an array until it goes away, then you fail
over to the next active path.

im using this to talk to ses(4) in my dell, and allows us to support
arrays that have multiple controllers but have no way of reporting
which one is active. using the MRU semantic means we can talk to
them without them flipping the active role between its controllers
all the time. claudios transtec iscsi box is like this.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.7 2011/07/03 15:47:18 matthew Exp $ */
d174 3
a176 3
	if (sc->sc_lun_state == EMC_SP_INFO_LUN_STATE_OWNED) {
		if (mpath_path_attach(&sc->sc_path, &emc_mpath_ops) != 0)
			printf("%s: unable to attach path\n", DEVNAME(sc));
d178 3
@


1.7
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.6 2011/06/16 08:42:30 dlg Exp $ */
d97 1
a97 1
struct mpath_ops emc_mpath_ops = {
d102 1
a159 1
	sc->sc_path.p_ops = &emc_mpath_ops;
d175 1
a175 1
		if (mpath_path_attach(&sc->sc_path) != 0)
@


1.6
log
@pass the dma_alloced memory rather than a pointer to its pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.5 2011/06/15 01:10:50 dlg Exp $ */
a192 1
	case DVACT_ACTIVATE:
@


1.5
log
@build inquiry with scsi_init_inquiry().
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.4 2011/04/28 10:43:36 dlg Exp $ */
d291 1
a291 1
	error = scsi_inquire_vpd(sc->sc_path.p_link, &pg, sizeof(pg),
@


1.4
log
@clean up the path ops struct a bit. the path drivers init their xsh with
their start routines, they dont have to pass pointers to them in the
ops struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.3 2011/04/27 09:09:36 dlg Exp $ */
a234 1
	struct scsi_inquiry *cdb;
d254 1
a254 8
	cdb = (struct scsi_inquiry *)xs->cmd;
	cdb->opcode = INQUIRY;
	_lto2b(length, cdb->length);

	xs->cmdlen = sizeof(*cdb);
	xs->flags |= SCSI_DATA_IN;
	xs->data = buffer;
	xs->datalen = length;
@


1.3
log
@whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.2 2011/04/27 07:14:50 dlg Exp $ */
a98 1
	emc_mpath_start,
@


1.2
log
@use dma safe memory when talking to devices. this was written before bigmem
required this.

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_emc.c,v 1.1 2011/04/05 14:25:42 dlg Exp $ */
d24 1
a24 1
#include <sys/kernel.h>  
d196 2
a197 2
        case DVACT_RESUME:
                break;
d203 1
a203 1
        return (rv);
d256 8
a263 8
        cdb = (struct scsi_inquiry *)xs->cmd;
        cdb->opcode = INQUIRY;
        _lto2b(length, cdb->length);

        xs->cmdlen = sizeof(*cdb);
        xs->flags |= SCSI_DATA_IN;
        xs->data = buffer;
        xs->datalen = length;
d265 2
a266 2
        error = scsi_xs_sync(xs);
        scsi_xs_put(xs);
d312 1
a312 1
        return (error);
@


1.1
log
@move forward with scsi multipathing.

the big change is how paths between mpath capable devices and the
kernel are managed.

originally the midlayer would steal the links to the devices and
hide them behind mpath. all the changes an adapter made to a link
(eg activate or detach), the midlayer had to test if it was an mpath
link and then call special mpath code to handle it.

the original code also assumed that all paths behaved the same, but
the reality is that different devices have different command sets
and behaviours. figuring out which behaviour to pick and prioritising
them is basically the same job autoconf does with match and attach.

rather than special casing mpath in the midlayer and reimplimenting
autoconf, this turns paths into actual device drivers with match
and attach routines. after they figure out if the path is active,
they then give it to mpath(4) to use as a backend.

i have written drivers for symmetric access devices (sym(4)) where
all paths to the same logical unit are as good as each other,
lsi/engenio arrays (rdac(4), and emc arrays (emc(4)).

the rdac and emc drivers only detect active paths at attach time,
the do not cope if the controller changes state unless you unplug
the path and plug it in again to retest the active state. they also
do not have support for directing array failover.

operating and hoplugging has been tested with mpii(4), fc and sas
mpi(4), and iscsi via vscsi (claudio did this too).

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d235 1
a235 1
	u_int8_t buffer[255];
d242 1
a242 2
	length = MIN(sc->sc_path.p_link->inqdata.additional_length + 5,
	    sizeof(buffer));
d248 2
d251 4
a254 2
	if (xs == NULL)
		return (EBUSY);
d269 1
a269 1
		return (error);
d272 4
a275 2
	if (slen == 0 || slen + 161 > length)
		return (EIO);
d278 4
a281 2
	if (mlen == 0 || slen + mlen + 161 > length)
		return (EIO);
d286 4
a289 1
	return (0);
d295 1
a295 1
	struct emc_vpd_sp_info pg;
d298 2
d303 1
a303 5
                return (error);

	sc->sc_sp = pg.current_sp;
	sc->sc_port = pg.port;
	sc->sc_lun_state = pg.lun_state;
d305 8
a312 1
        return (0);
@

