head	1.80;
access;
symbols
	OPENBSD_4_7:1.70.0.2
	OPENBSD_4_7_BASE:1.70
	OPENBSD_4_6:1.63.0.6
	OPENBSD_4_6_BASE:1.63
	OPENBSD_4_5:1.63.0.2
	OPENBSD_4_5_BASE:1.63
	OPENBSD_4_4:1.62.0.2
	OPENBSD_4_4_BASE:1.62
	OPENBSD_4_3:1.60.0.2
	OPENBSD_4_3_BASE:1.60
	OPENBSD_4_2:1.58.0.4
	OPENBSD_4_2_BASE:1.58
	OPENBSD_4_1:1.58.0.2
	OPENBSD_4_1_BASE:1.58
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.53.0.2
	OPENBSD_3_9_BASE:1.53
	OPENBSD_3_8:1.51.0.2
	OPENBSD_3_8_BASE:1.51
	OPENBSD_3_7:1.50.0.2
	OPENBSD_3_7_BASE:1.50
	OPENBSD_3_6:1.49.0.2
	OPENBSD_3_6_BASE:1.49
	SMP_SYNC_A:1.49
	SMP_SYNC_B:1.49
	OPENBSD_3_5:1.48.0.4
	OPENBSD_3_5_BASE:1.48
	OPENBSD_3_4:1.48.0.2
	OPENBSD_3_4_BASE:1.48
	UBC_SYNC_A:1.47
	OPENBSD_3_3:1.47.0.2
	OPENBSD_3_3_BASE:1.47
	OPENBSD_3_2:1.46.0.2
	OPENBSD_3_2_BASE:1.46
	OPENBSD_3_1:1.45.0.2
	OPENBSD_3_1_BASE:1.45
	UBC_SYNC_B:1.46
	UBC:1.43.0.4
	UBC_BASE:1.43
	OPENBSD_3_0:1.43.0.2
	OPENBSD_3_0_BASE:1.43
	OPENBSD_2_9_BASE:1.42
	OPENBSD_2_9:1.42.0.2
	OPENBSD_2_8:1.41.0.2
	OPENBSD_2_8_BASE:1.41
	OPENBSD_2_7:1.40.0.6
	OPENBSD_2_7_BASE:1.40
	SMP:1.40.0.4
	SMP_BASE:1.40
	kame_19991208:1.40
	OPENBSD_2_6:1.40.0.2
	OPENBSD_2_6_BASE:1.40
	OPENBSD_2_5:1.36.0.4
	OPENBSD_2_5_BASE:1.36
	OPENBSD_2_4:1.36.0.2
	OPENBSD_2_4_BASE:1.36
	OPENBSD_2_3:1.35.0.2
	OPENBSD_2_3_BASE:1.35
	OPENBSD_2_2:1.34.0.2
	OPENBSD_2_2_BASE:1.34
	OPENBSD_2_1:1.33.0.2
	OPENBSD_2_1_BASE:1.33
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8;
locks; strict;
comment	@ * @;


1.80
date	2010.07.08.00.42.39;	author krw;	state dead;
branches;
next	1.79;

1.79
date	2010.07.01.05.11.18;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2010.07.01.03.01.37;	author matthew;	state Exp;
branches;
next	1.77;

1.77
date	2010.06.30.00.02.00;	author dlg;	state Exp;
branches;
next	1.76;

1.76
date	2010.06.26.23.24.45;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2010.06.26.21.27.55;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2010.06.11.12.02.44;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2010.06.01.15.27.16;	author thib;	state Exp;
branches;
next	1.71;

1.71
date	2010.04.12.09.51.48;	author dlg;	state Exp;
branches;
next	1.70;

1.70
date	2010.01.15.05.50.31;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2010.01.15.05.31.38;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2010.01.12.23.33.57;	author dlg;	state Exp;
branches;
next	1.67;

1.67
date	2010.01.11.08.56.17;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2010.01.09.21.12.06;	author dlg;	state Exp;
branches;
next	1.65;

1.65
date	2010.01.02.23.28.51;	author dlg;	state Exp;
branches;
next	1.64;

1.64
date	2010.01.01.06.30.27;	author dlg;	state Exp;
branches;
next	1.63;

1.63
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2008.06.22.16.32.05;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2008.05.22.21.53.12;	author jasper;	state Exp;
branches;
next	1.60;

1.60
date	2007.11.27.16.22.14;	author martynas;	state Exp;
branches;
next	1.59;

1.59
date	2007.09.16.01.30.24;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2006.12.21.02.05.46;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.56;

1.56
date	2006.10.07.23.40.07;	author beck;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.18.21.27.25;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2005.12.17.20.29.16;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2005.12.10.01.36.01;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2005.04.06.02.51.13;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2004.11.30.19.28.37;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2004.05.09.04.01.59;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.18.16.06.35;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2002.12.30.21.50.29;	author grange;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.09.00.05.57;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2002.03.14.03.16.12;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.22.14.35.43;	author deraadt;	state Exp;
branches
	1.43.4.1;
next	1.42;

1.42
date	2001.03.25.04.23.45;	author fgsch;	state Exp;
branches;
next	1.41;

1.41
date	2000.06.16.21.47.19;	author provos;	state Exp;
branches;
next	1.40;

1.40
date	99.05.11.23.57.44;	author kstailey;	state Exp;
branches
	1.40.4.1;
next	1.39;

1.39
date	99.05.11.23.52.47;	author kstailey;	state Exp;
branches;
next	1.38;

1.38
date	99.05.11.23.41.37;	author kstailey;	state Exp;
branches;
next	1.37;

1.37
date	99.05.11.23.25.43;	author kstailey;	state Exp;
branches;
next	1.36;

1.36
date	98.09.16.15.53.24;	author kstailey;	state Exp;
branches;
next	1.35;

1.35
date	98.02.22.00.49.13;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	97.08.02.21.35.32;	author kstailey;	state Exp;
branches;
next	1.33;

1.33
date	97.04.15.10.51.36;	author tholo;	state Exp;
branches;
next	1.32;

1.32
date	97.04.05.23.34.20;	author kstailey;	state Exp;
branches;
next	1.31;

1.31
date	97.04.05.22.59.13;	author kstailey;	state Exp;
branches;
next	1.30;

1.30
date	97.03.13.12.22.37;	author kstailey;	state Exp;
branches;
next	1.29;

1.29
date	97.03.13.12.19.59;	author kstailey;	state Exp;
branches;
next	1.28;

1.28
date	97.03.11.12.06.48;	author kstailey;	state Exp;
branches;
next	1.27;

1.27
date	97.03.11.04.00.15;	author kstailey;	state Exp;
branches;
next	1.26;

1.26
date	97.03.11.03.40.49;	author kstailey;	state Exp;
branches;
next	1.25;

1.25
date	97.03.11.03.19.16;	author kstailey;	state Exp;
branches;
next	1.24;

1.24
date	97.03.11.00.45.19;	author kstailey;	state Exp;
branches;
next	1.23;

1.23
date	97.03.10.03.20.30;	author kstailey;	state Exp;
branches;
next	1.22;

1.22
date	97.03.10.02.34.42;	author kstailey;	state Exp;
branches;
next	1.21;

1.21
date	97.03.10.02.29.39;	author kstailey;	state Exp;
branches;
next	1.20;

1.20
date	97.03.10.00.56.59;	author kstailey;	state Exp;
branches;
next	1.19;

1.19
date	97.03.09.17.45.01;	author kstailey;	state Exp;
branches;
next	1.18;

1.18
date	97.03.08.22.52.58;	author kstailey;	state Exp;
branches;
next	1.17;

1.17
date	97.03.08.20.51.36;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.03.08.20.43.09;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.03.08.18.59.41;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.03.08.05.39.00;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	97.03.08.02.15.05;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.03.07.12.57.55;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.03.07.03.05.15;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	97.03.06.12.44.41;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.02.27.06.20.23;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.08.11.23.26.05;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.07.30.11.04.08;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.11.16.38.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.10.12.31.39;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.09.34.31;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.31.12;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.16.10.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.02.20.02.28.53;	author briggs;	state Exp;
branches;
next	;

1.40.4.1
date	2001.05.14.22.45.00;	author niklas;	state Exp;
branches;
next	1.40.4.2;

1.40.4.2
date	2001.07.04.11.00.09;	author niklas;	state Exp;
branches;
next	1.40.4.3;

1.40.4.3
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.40.4.4;

1.40.4.4
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.40.4.5;

1.40.4.5
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.40.4.6;

1.40.4.6
date	2004.06.05.23.13.08;	author niklas;	state Exp;
branches;
next	;

1.43.4.1
date	2002.06.11.03.32.14;	author art;	state Exp;
branches;
next	1.43.4.2;

1.43.4.2
date	2003.05.19.22.28.21;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.80
log
@Move ss and friends to the attic.

Enthusiastic huzzahs from many.

"A great day" dlg@@
@
text
@/*	$OpenBSD: ss.c,v 1.79 2010/07/01 05:11:18 krw Exp $	*/
/*	$NetBSD: ss.c,v 1.10 1996/05/05 19:52:55 christos Exp $	*/

/*
 * Copyright (c) 1995, 1997 Kenneth Stailey.  All rights reserved.
 *   modified for configurable scanner support by Joachim Koenig
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Kenneth Stailey.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/fcntl.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/scanio.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_scanner.h>
#include <scsi/scsiconf.h>
#include <scsi/ssvar.h>

#include <scsi/ss_mustek.h>

#define SSMODE(z)	( minor(z)       & 0x03)
#define SSUNIT(z)	((minor(z) >> 4)       )

/*
 * If the mode is 3 (e.g. minor = 3,7,11,15)
 * then the device has been openned to set defaults
 * This mode does NOT ALLOW I/O, only ioctls
 */
#define MODE_REWIND	0
#define MODE_NONREWIND	1
#define MODE_CONTROL	3

struct quirkdata {
	char *name;
	u_int quirks;
#define SS_Q_WINDOW_DESC_LEN	0x0001 /* needs special WDL */
#define SS_Q_BRIGHTNESS		0x0002 /* needs special value for brightness */
#define SS_Q_REV_BRIGHTNESS	0x0004 /* reverse brightness control in s/w */
#define SS_Q_THRESHOLD		0x0008 /* needs special value for threshold */
#define SS_Q_MONO_THRESHOLD	0x0010 /* same as SS_Q_THRESHOLD but only
					* for monochrome image data */
#define SS_Q_CONTRAST		0x0020 /* needs special value for contrast */
#define SS_Q_REV_CONTRAST	0x0040 /* reverse contrast control in s/w */
#define SS_Q_HALFTONE		0x0080 /* uses non-zero halftone */
#define SS_Q_SET_RIF		0x0100 /* set RIF bit */
#define SS_Q_PADDING_TYPE	0x0200 /* does not truncate to byte boundary */
#define SS_Q_BIT_ORDERING	0x0400 /* needs non-zero bit ordering */
	long window_descriptor_length;
	u_int8_t brightness;
	u_int8_t threshold;
	u_int8_t contrast;
	u_int8_t halftone_pattern[2];
	int pad_type;
	long bit_ordering;
	u_int8_t scanner_type;
	/*
	 * To enable additional scanner options, point vendor_unique_sw
	 * at a function that adds more stuff to the SET_WINDOW parameters.
	 */
	int	(*vendor_unique_sw)(struct ss_softc *, struct scan_io *,
					struct scsi_set_window *, void *);
	/*
	 * If the scanner requires use of GET_BUFFER_STATUS before READ
	 * it can be called from ss_minphys().
	 */
	void	(*special_minphys)(struct ss_softc *, struct buf *);

	int	(*compute_sizes)(void);
};

struct ss_quirk_inquiry_pattern {
	struct scsi_inquiry_pattern pattern;
	struct quirkdata quirkdata;
};

struct  quirkdata ss_gen_quirks = {
	"generic", 0, 0, 0, 0, 0,
	{0, 0}, 0, 0, GENERIC_SCSI2,
	NULL, NULL, NULL
};

void    ssstrategy(struct buf *);
void    ssstart(struct scsi_xfer *);
void	ssdone(struct scsi_xfer *);
void	ssminphys(struct buf *);

void	ss_identify_scanner(struct ss_softc *, struct scsi_inquiry_data*);
int	ss_set_window(struct ss_softc *, struct scan_io *);

int	ricoh_is410_sw(struct ss_softc *, struct scan_io *,
			    struct scsi_set_window *, void *);
int	umax_uc630_sw(struct ss_softc *, struct scan_io *,
			   struct scsi_set_window *, void *);
#ifdef NOTYET	/* for ADF support  */
int	fujitsu_m3096g_sw(struct ss_softc *, struct scan_io *,
			       struct scsi_set_window *, void *);
#endif

void	get_buffer_status(struct ss_softc *, struct buf *);

/*
 * WDL:
 *
 *  Ricoh IS-50 & IS-410 insist on 320 (even it transfer len is less.)
 *  Ricoh FS-1 accepts 256 (I haven't tested other values.)
 *  UMAX UC-630 accepts 46 (I haven't tested other values.)
 *  Fujitsu M3096G wants 40 <= x <= 248 (tested OK at 40 & 64.)
 */

const struct ss_quirk_inquiry_pattern ss_quirk_patterns[] = {
	{{T_SCANNER, T_FIXED,
	 "ULTIMA  ", "AT3     1.60    ", "    "}, {
		 "Ultima AT3",
		 SS_Q_HALFTONE |
		 SS_Q_PADDING_TYPE,
		 0, 0, 0, 0, { 3, 0 }, 0, 0,
		 ULTIMA_AT3,
		 NULL, NULL, NULL
	 }},
	{{T_SCANNER, T_FIXED,
	 "ULTIMA  ", "A6000C PLUS     ", "    "}, {
		 "Ultima A6000C",
		 SS_Q_HALFTONE |
		 SS_Q_PADDING_TYPE,
		 0, 0, 0, 0, { 3, 0 }, 0, 0,
		 ULTIMA_AC6000C,
		 NULL, NULL, NULL
	 }},
	{{T_SCANNER, T_FIXED,
	 "RICOH   ", "IS50            ", "    "}, {
		 "Ricoh IS-50",
		 SS_Q_WINDOW_DESC_LEN |
		 SS_Q_REV_BRIGHTNESS |
		 SS_Q_THRESHOLD |
		 SS_Q_REV_CONTRAST |
		 SS_Q_HALFTONE |
		 SS_Q_BIT_ORDERING,
		 320, 0, 0, 0, { 2, 0x0a }, 0, 7,
		 RICOH_IS50,
		 ricoh_is410_sw, get_buffer_status, NULL
	 }},
	{{T_SCANNER, T_FIXED,
	 "RICOH   ", "IS410           ", "    "}, {
		 "Ricoh IS-410",
		 SS_Q_WINDOW_DESC_LEN |
		 SS_Q_THRESHOLD |
		 SS_Q_HALFTONE |
		 SS_Q_BIT_ORDERING,
		 320, 0, 0, 0, { 2, 0x0a }, 0, 7,
		 RICOH_IS410,
		 ricoh_is410_sw, get_buffer_status, NULL
	 }},
	{{T_SCANNER, T_FIXED,	       /* Ricoh IS-410 OEMed by IBM */
	 "IBM     ", "2456-001        ", "    "}, {
		 "IBM 2456",
		 SS_Q_WINDOW_DESC_LEN |
		 SS_Q_THRESHOLD |
		 SS_Q_HALFTONE |
		 SS_Q_BIT_ORDERING,
		 320, 0, 0, 0, { 2, 0x0a }, 0, 7,
		 RICOH_IS410,
		 ricoh_is410_sw, get_buffer_status, NULL
	 }},
	{{T_SCANNER, T_FIXED,
	 "UMAX    ", "UC630           ", "    "}, {
		 "UMAX UC-630",
		 SS_Q_WINDOW_DESC_LEN |
		 SS_Q_HALFTONE,
		 0x2e, 0, 0, 0, { 0, 1 }, 0, 0,
		 UMAX_UC630,
		 umax_uc630_sw, NULL, NULL
	 }},
	{{T_SCANNER, T_FIXED,
	 "UMAX    ", "UG630           ", "    "}, {
		 "UMAX UG-630",
		 SS_Q_WINDOW_DESC_LEN |
		 SS_Q_HALFTONE,
		 0x2e, 0, 0, 0, { 0, 1 }, 0, 0,
		 UMAX_UG630,
		 umax_uc630_sw, NULL, NULL
	 }},
#ifdef NOTYET			/* ADF version */
	{{T_SCANNER, T_FIXED,
	 "FUJITSU ", "M3096Gm         ", "    "}, {
		 "Fujitsu M3096G",
		 SS_Q_WINDOW_DESC_LEN |
		 SS_Q_BRIGHTNESS |
		 SS_Q_MONO_THRESHOLD |
		 SS_Q_HALFTONE |
		 SS_Q_SET_RIF |
		 SS_Q_PADDING_TYPE,
		 64, 0, 0, 0, { 0, 1 }, 0, 0,
		 FUJITSU_M3096G,
		 fujistsu_m3096g_sw, NULL, NULL
	 }},
#else				/* flatbed-only version */
	{{T_SCANNER, T_FIXED,
	 "FUJITSU ", "M3096Gm         ", "    "}, {
		 "Fujitsu M3096G",
		 SS_Q_BRIGHTNESS |
		 SS_Q_MONO_THRESHOLD |
		 SS_Q_CONTRAST |
		 SS_Q_HALFTONE |
		 SS_Q_PADDING_TYPE,
		 0, 0, 0, 0, { 0, 1 }, 0, 0,
		 FUJITSU_M3096G,
		 NULL, NULL, NULL
	 }},
#endif
};


int ssmatch(struct device *, void *, void *);
void ssattach(struct device *, struct device *, void *);

struct cfattach ss_ca = {
	sizeof(struct ss_softc), ssmatch, ssattach
};

struct cfdriver ss_cd = {
	NULL, "ss", DV_DULL
};

const struct scsi_inquiry_pattern ss_patterns[] = {
	{T_SCANNER, T_FIXED,
	 "",         "",                 ""},
	{T_SCANNER, T_REMOV,
	 "",         "",                 ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C1750A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C1790A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C2500A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C2570A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C2520A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C1130A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C5110A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C6290A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C5190A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C7190A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C6270A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C7670A          ", ""},
};

int
ssmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct scsi_attach_args *sa = aux;
	int priority;

	(void)scsi_inqmatch(sa->sa_inqbuf,
	    ss_patterns, sizeof(ss_patterns)/sizeof(ss_patterns[0]),
	    sizeof(ss_patterns[0]), &priority);
	return (priority);
}

/*
 * The routine called by the low level scsi routine when it discovers
 * A device suitable for this driver
 * If it is a know special, call special attach routine to install
 * special handlers into the ss_softc structure
 */
void
ssattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ss_softc *ss = (void *)self;
	struct scsi_attach_args *sa = aux;
	struct scsi_link *sc_link = sa->sa_sc_link;

	SC_DEBUG(sc_link, SDEV_DB2, ("ssattach:\n"));

	/*
	 * Store information needed to contact our base driver
	 */
	ss->sc_link = sc_link;
	sc_link->device_softc = ss;
	sc_link->openings = 1;

	if (!bcmp(sa->sa_inqbuf->vendor, "MUSTEK", 6))
		mustek_attach(ss, sa);
	else if (!bcmp(sa->sa_inqbuf->vendor, "HP      ", 8))
		scanjet_attach(ss, sa);
	else
		ss_identify_scanner(ss, sa->sa_inqbuf);

	/*
	 * populate the scanio struct with legal values
	 */
	ss->sio.scan_width		= 1200;
	ss->sio.scan_height		= 1200;
	ss->sio.scan_x_resolution	= 100;
	ss->sio.scan_y_resolution	= 100;
	ss->sio.scan_x_origin		= 0;
	ss->sio.scan_y_origin		= 0;
	ss->sio.scan_brightness		= 128;
	ss->sio.scan_contrast		= 128;
	ss->sio.scan_quality		= 100;
	ss->sio.scan_image_mode		= SIM_GRAYSCALE;

	/* XXX fill in the rest of the scan_io struct by calling the
	   compute_sizes routine */

	scsi_xsh_set(&ss->xsh, sc_link, ssstart);
	timeout_set(&ss->timeout, (void (*)(void *))scsi_xsh_add, &ss->xsh);

	/* Set up the buf queue for this device. */
	ss->sc_bufq = bufq_init(BUFQ_DEFAULT);
}

void
ss_identify_scanner(ss, inqbuf)
	struct ss_softc *ss;
	struct scsi_inquiry_data *inqbuf;
{
	const struct ss_quirk_inquiry_pattern *finger;
	int priority;
	/*
	 * look for non-standard scanners with help of the quirk table
	 * and install functions for special handling
	 */
	finger = (const struct ss_quirk_inquiry_pattern *)scsi_inqmatch(inqbuf,
	    ss_quirk_patterns,
	    sizeof(ss_quirk_patterns)/sizeof(ss_quirk_patterns[0]),
	    sizeof(ss_quirk_patterns[0]), &priority);
	if (priority != 0) {
		ss->quirkdata = &finger->quirkdata;
		if (ss->quirkdata->special_minphys != NULL) {
			ss->special.minphys = ss->quirkdata->special_minphys;
		}
		ss->sio.scan_scanner_type = ss->quirkdata->scanner_type;
		printf("\n%s: %s\n", ss->sc_dev.dv_xname, ss->quirkdata->name);
	} else {
		printf("\n%s: generic scanner\n", ss->sc_dev.dv_xname);
		bzero(&ss_gen_quirks, sizeof(ss_gen_quirks));
		ss->quirkdata = &ss_gen_quirks;
		ss->sio.scan_scanner_type = GENERIC_SCSI2;
	}
}

/*
 * open the device.
 */
int
ssopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int unit;
	u_int ssmode;
	int error = 0;
	struct ss_softc *ss;
	struct scsi_link *sc_link;

	unit = SSUNIT(dev);
	if (unit >= ss_cd.cd_ndevs)
		return (ENXIO);
	ss = ss_cd.cd_devs[unit];
	if (!ss)
		return (ENXIO);

	ssmode = SSMODE(dev);
	sc_link = ss->sc_link;

	SC_DEBUG(sc_link, SDEV_DB1, ("open: dev=0x%x (unit %d (of %d))\n", dev,
	    unit, ss_cd.cd_ndevs));

	if (sc_link->flags & SDEV_OPEN) {
		printf("%s: already open\n", ss->sc_dev.dv_xname);
		return (EBUSY);
	}

	/*
	 * Catch any unit attention errors.
	 *
	 * SCSI_IGNORE_MEDIA_CHANGE: when you have an ADF, some scanners
	 * consider paper to be a changeable media
	 *
	 */
	error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES,
	    SCSI_IGNORE_MEDIA_CHANGE | SCSI_IGNORE_ILLEGAL_REQUEST |
	    (ssmode == MODE_CONTROL ? SCSI_IGNORE_NOT_READY : 0));
	if (error)
		goto bad;

	sc_link->flags |= SDEV_OPEN;	/* unit attn are now errors */

	/*
	 * If the mode is 3 (e.g. minor = 3,7,11,15)
	 * then the device has been opened to set defaults
	 * This mode does NOT ALLOW I/O, only ioctls
	 */
	if (ssmode == MODE_CONTROL)
		return (0);

	SC_DEBUG(sc_link, SDEV_DB2, ("open complete\n"));
	return (0);

bad:
	sc_link->flags &= ~SDEV_OPEN;
	return (error);
}

/*
 * close the device.. only called if we are the LAST
 * occurrence of an open device
 */
int
ssclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	struct ss_softc *ss = ss_cd.cd_devs[SSUNIT(dev)];
	int error;

	SC_DEBUG(ss->sc_link, SDEV_DB1, ("closing\n"));

	if (SSMODE(dev) == MODE_REWIND) {
		if (ss->special.rewind_scanner) {
			/* call special handler to rewind/abort scan */
			error = (ss->special.rewind_scanner)(ss);
			if (error)
				return (error);
		} else {
			/* XXX add code to restart a SCSI2 scanner, if any */
		}
		ss->sio.scan_window_size = 0;
		ss->flags &= ~SSF_TRIGGERED;
	}
	ss->sc_link->flags &= ~SDEV_OPEN;

	return (0);
}

/*
 * trim the size of the transfer if needed,
 * called by physio
 * basically the smaller of our min and the scsi driver's
 * minphys
 */
void
ssminphys(bp)
	struct buf *bp;
{
	struct ss_softc *ss = ss_cd.cd_devs[SSUNIT(bp->b_dev)];

	(ss->sc_link->adapter->scsi_minphys)(bp, ss->sc_link);

	/*
	 * trim the transfer further for special devices this is
	 * because some scanners only read multiples of a line at a
	 * time, also some cannot disconnect, so the read must be
	 * short enough to happen quickly
	 */
	if (ss->special.minphys)
		(ss->special.minphys)(ss, bp);
}

/*
 * Do a read on a device for a user process.
 * Prime scanner at start of read, check uio values, call ssstrategy
 * via physio for the actual transfer.
 */
int
ssread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct ss_softc *ss = ss_cd.cd_devs[SSUNIT(dev)];
	int error;

	/* if the scanner has not yet been started, do it now */
	if (!(ss->flags & SSF_TRIGGERED)) {
		if (ss->special.trigger_scanner) {
			error = (ss->special.trigger_scanner)(ss);
			if (error)
				return (error);
		} else {
			struct scsi_start_stop trigger_cmd;
			bzero(&trigger_cmd, sizeof(trigger_cmd));
			trigger_cmd.opcode = START_STOP;
			trigger_cmd.how = SSS_START;
			scsi_scsi_cmd(ss->sc_link,
				(struct scsi_generic *)&trigger_cmd,
				sizeof(trigger_cmd), 0, 0, SCSI_RETRIES, 5000,
				NULL, 0);
		}
		ss->flags |= SSF_TRIGGERED;
	}

	return (physio(ssstrategy, NULL, dev, B_READ, ssminphys, uio));
}

/*
 * Actually translate the requested transfer into one the physical
 * driver can understand The transfer is described by a buf and will
 * include only one physical transfer.
 */
void
ssstrategy(bp)
	struct buf *bp;
{
	struct ss_softc *ss;
	int s;

	ss = ss_cd.cd_devs[SSUNIT(bp->b_dev)];
	if (ss == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}

	SC_DEBUG(ss->sc_link, SDEV_DB2, ("ssstrategy: %ld bytes @@ blk %d\n",
	    bp->b_bcount, bp->b_blkno));

	if (bp->b_bcount > ss->sio.scan_window_size)
		bp->b_bcount = ss->sio.scan_window_size;

	/*
	 * If it's a null transfer, return immediately
	 */
	if (bp->b_bcount == 0)
		goto done;

	/*
	 * Place it in the queue of activities for this scanner
	 * at the end (a bit silly because we only have on user..)
	 * (but it could fork() or dup())
	 */
	BUFQ_QUEUE(ss->sc_bufq, bp);

	/*
	 * Tell the device to get going on the transfer if it's
	 * not doing anything, otherwise just wait for completion
	 * (All a bit silly if we're only allowing 1 open but..)
	 */
	scsi_xsh_add(&ss->xsh);

	device_unref(&ss->sc_dev);
	return;

bad:
	bp->b_flags |= B_ERROR;
done:
	/*
	 * Set the buf to indicate no xfer was done.
	 */
	bp->b_resid = bp->b_bcount;
	s = splbio();
	biodone(bp);
	splx(s);
	if (ss != NULL)
		device_unref(&ss->sc_dev);
}

/*
 * ssstart looks to see if there is a buf waiting for the device
 * and that the device is not already busy. If both are true,
 * It dequeues the buf and creates a scsi command to perform the
 * transfer required. The transfer request will call scsi_done
 * on completion, which will in turn call this routine again
 * so that the next queued transfer is performed.
 * The bufs are queued by the strategy routine (ssstrategy)
 *
 * This routine is also called after other non-queued requests
 * have been made of the scsi driver, to ensure that the queue
 * continues to be drained.
 * ssstart() is called at splbio
 */
void
ssstart(struct scsi_xfer *xs)
{
	struct scsi_link *sc_link = xs->sc_link;
	struct ss_softc *ss = sc_link->device_softc;
	struct buf *bp;
	struct scsi_r_scanner *cdb;

	SC_DEBUG(sc_link, SDEV_DB2, ("ssstart\n"));

	bp = BUFQ_DEQUEUE(ss->sc_bufq);
	if (bp == NULL) {
		scsi_xs_put(xs);
		return;
	}

	if (ss->special.read) {
		(ss->special.read)(ss, xs, bp);
	} else {
		cdb = (struct scsi_r_scanner *)xs->cmd;
		xs->cmdlen = sizeof(*cdb);

		cdb->opcode = READ_BIG;
		_lto3b(bp->b_bcount, cdb->len);

		xs->data = bp->b_data;
		xs->datalen = bp->b_bcount;
		xs->flags |= SCSI_DATA_IN;
		xs->retries = 0;
		xs->timeout = 100000;
		xs->done = ssdone;
		xs->cookie = bp;
		xs->bp = bp;

		scsi_xs_exec(xs);
	}

	if (ISSET(ss->flags, SSF_WAITING))
		CLR(ss->flags, SSF_WAITING);
	else if (BUFQ_PEEK(ss->sc_bufq))
		scsi_xsh_add(&ss->xsh);
}

void
ssdone(struct scsi_xfer *xs)
{
	struct ss_softc *ss = xs->sc_link->device_softc;
	struct buf *bp = xs->cookie;
	int error, s;

	switch (xs->error) {
	case XS_NOERROR:
		bp->b_error = 0;
		bp->b_resid = xs->resid;
		break;

	case XS_NO_CCB:
		/* The adapter is busy, requeue the buf and try it later. */
		BUFQ_REQUEUE(ss->sc_bufq, bp);
		scsi_xs_put(xs);
		SET(ss->flags, SSF_WAITING);
		timeout_add(&ss->timeout, 1);
		return;

	case XS_SENSE:
	case XS_SHORTSENSE:
#ifdef SCSIDEBUG
		scsi_sense_print_debug(xs);
#endif
		error = scsi_interpret_sense(xs);
		if (error == 0) {
			bp->b_error = 0;
			bp->b_resid = xs->resid;
			break;
		}
		if (error != ERESTART)
			xs->retries = 0;
		goto retry;

	case XS_BUSY:
		if (xs->retries) {
			if (scsi_delay(xs, 1) != ERESTART)
				xs->retries = 0;
		}
		goto retry;

	case XS_TIMEOUT:
retry:
		if (xs->retries--) {
			scsi_xs_exec(xs);
			return;
		}
		/* FALLTHROUGH */

	default:
		bp->b_error = EIO;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		break;
	}

	s = splbio();
	biodone(bp);
	splx(s);
	scsi_xs_put(xs);
}

/*
 * Perform special action on behalf of the user;
 * knows about the internals of this device
 */
int
ssioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	struct ss_softc *ss = ss_cd.cd_devs[SSUNIT(dev)];
	int error = 0;
	struct scan_io *sio;

	switch (cmd) {
	case SCIOCGET:
		/* call special handler, if any */
		if (ss->special.get_params) {
			error = (ss->special.get_params)(ss);
			if (error)
				return (error);
		}
		bcopy(&ss->sio, addr, sizeof(struct scan_io));
		break;
	case SCIOCSET:
		sio = (struct scan_io *)addr;

		/* call special handler, if any */
		if (ss->special.set_params) {
			error = (ss->special.set_params)(ss, sio);
			if (error)
				return (error);
		} else {
			/* XXX add routine to validate parameters */
			ss_set_window(ss, sio);
		}
		break;
	case SCIOCRESTART:
		/* call special handler, if any */
		if (ss->special.rewind_scanner ) {
			error = (ss->special.rewind_scanner)(ss);
			if (error)
				return (error);
		} else
			/* XXX add code for SCSI2 scanner, if any */
			return (EOPNOTSUPP);
		ss->flags &= ~SSF_TRIGGERED;
		break;
	case SCIOC_USE_ADF:
		/* XXX add Automatic Document Feeder Support */
		return (EOPNOTSUPP);
	default:
		if (SSMODE(dev) != MODE_CONTROL)
			return (ENOTTY);
		return (scsi_do_ioctl(ss->sc_link, cmd, addr, flag));
	}
	return (error);
}

int
ss_set_window(ss, sio)
	struct ss_softc *ss;
	struct scan_io *sio;
{
	struct scsi_set_window	window_cmd;
	struct {
		struct scsi_window_data	window_data;
		/* vendor_unique must provide enough space for worst case
		 * (currently Ricoh IS-410.)  40 + 280 = 320 which is the size
		 * of its window descriptor length
		 */
		u_int8_t vendor_unique[280];
	} wd;
#define window_data   wd.window_data
#define vendor_unique wd.vendor_unique
	struct scsi_link	*sc_link = ss->sc_link;

	/*
	 * The CDB for SET WINDOW goes in here.
	 * The two structures that follow are sent via data out.
	 */
	bzero(&window_cmd, sizeof(window_cmd));
	window_cmd.opcode = SET_WINDOW;
	_lto3l(sizeof(window_data), window_cmd.len);

	bzero(&window_data, sizeof(window_data));
	if (ss->quirkdata->quirks & SS_Q_WINDOW_DESC_LEN)
		_lto2l(ss->quirkdata->window_descriptor_length,
		    window_data.window_desc_len);
	else
		_lto2l(40L, window_data.window_desc_len);

	/* start of SET_WINDOW parameter block */

	/* leave window id at zero */
	/* leave auto bit at zero */
	_lto2l(sio->scan_x_resolution, window_data.x_res);
	_lto2l(sio->scan_y_resolution, window_data.y_res);
	_lto4l(sio->scan_x_origin, window_data.x_org);
	_lto4l(sio->scan_y_origin, window_data.y_org);
	_lto4l(sio->scan_width,  window_data.width);
	_lto4l(sio->scan_height, window_data.length);

	if (ss->quirkdata->quirks & SS_Q_REV_BRIGHTNESS)
		window_data.brightness = 256 - sio->scan_brightness;
	else if (ss->quirkdata->quirks & SS_Q_BRIGHTNESS)
		window_data.brightness = ss->quirkdata->brightness;
	else
		window_data.brightness = sio->scan_brightness;

	/*
	 * threshold: Default is to follow brightness.
	 * If SS_Q_MONO_THRESHOLD is set then the quirkdata contains a special
	 * value to be used instead of default when image data is monochrome.
	 * Otherwise if SS_Q_THRESHOLD is set then the quirkdata contains
	 * the threshold to always use.
	 * Both SS_Q_MONO_THRESHOLD and SS_Q_THRESHOLD should not be set at
	 * the same time.
	 */
	if (ss->quirkdata->quirks & SS_Q_MONO_THRESHOLD) {
		if (sio->scan_image_mode == SIM_BINARY_MONOCHROME ||
		    sio->scan_image_mode == SIM_DITHERED_MONOCHROME)
			window_data.threshold = ss->quirkdata->threshold;
		else
			window_data.threshold = sio->scan_brightness;
	} else if (ss->quirkdata->quirks & SS_Q_THRESHOLD)
		window_data.threshold = ss->quirkdata->threshold;
	else
		window_data.threshold = sio->scan_brightness;

	if (ss->quirkdata->quirks & SS_Q_REV_CONTRAST)
		window_data.contrast = 256 - sio->scan_contrast;
	else if (ss->quirkdata->quirks & SS_Q_CONTRAST)
		window_data.contrast = ss->quirkdata->contrast;
	else
		window_data.contrast = sio->scan_contrast;

	switch (sio->scan_image_mode) {
	case SIM_RED:
	case SIM_GREEN:
	case SIM_BLUE:
		window_data.image_comp = SIM_GRAYSCALE;
		break;
	default:
		window_data.image_comp = sio->scan_image_mode;
	}

	window_data.bits_per_pixel = sio->scan_bits_per_pixel;

	if (ss->quirkdata->quirks & SS_Q_HALFTONE) {
		window_data.halftone_pattern[0] =
			ss->quirkdata->halftone_pattern[0];
		window_data.halftone_pattern[1] = 
			ss->quirkdata->halftone_pattern[1];
	} /* else leave halftone set to zero. */

	if (ss->quirkdata->quirks & SS_Q_SET_RIF)
		window_data.rif = 1;

	if (ss->quirkdata->quirks & SS_Q_PADDING_TYPE)
		window_data.pad_type = ss->quirkdata->pad_type;
	else
		window_data.pad_type = 3; /* 3 = truncate to byte boundary */

	if (ss->quirkdata->quirks & SS_Q_BIT_ORDERING)
		_lto2l(ss->quirkdata->bit_ordering, window_data.bit_ordering);
	/* else leave bit_ordering set to zero. */

	/* leave compression type & argument set to zero. */

#undef window_data

	if (ss->quirkdata->vendor_unique_sw != NULL)
		return ((*ss->quirkdata->vendor_unique_sw)(ss, sio,
		    &window_cmd, (void *)&wd));
	else
		/* send the command to the scanner */
		return (scsi_scsi_cmd(sc_link,
		    (struct scsi_generic *)&window_cmd,
		    sizeof(window_cmd), (u_char *) &wd.window_data,
		    (ss->quirkdata->quirks & SS_Q_WINDOW_DESC_LEN) ?
		    ss->quirkdata->window_descriptor_length : 40,
		    SCSI_RETRIES, 5000, NULL, SCSI_DATA_OUT));
}

int
ricoh_is410_sw(ss, sio, wcmd, vwd)
	struct ss_softc *ss;
	struct scan_io *sio;
	struct scsi_set_window *wcmd;
	void *vwd;
{
	struct ricoh_is410_window_data {
		struct scsi_window_data	window_data;
		u_int8_t res1;
		u_int8_t res2;
		u_int    mrif:1; /* reverse image format (grayscale negative) */
		u_int    filtering:3;
		u_int    gamma_id:4;
	} *rwd = (struct ricoh_is410_window_data*)vwd;
	struct scsi_link *sc_link = ss->sc_link;

	rwd->mrif = 1;		/* force grayscale to match PGM */

	/* send the command to the scanner */
	return (scsi_scsi_cmd(sc_link, (struct scsi_generic *)wcmd,
	    sizeof(struct scsi_set_window), (u_char *)rwd,
	    sizeof(struct ricoh_is410_window_data), SCSI_RETRIES, 5000, NULL,
	    SCSI_DATA_OUT));
}

int
umax_uc630_sw(ss, sio, wcmd, vwd)
	struct ss_softc *ss;
	struct scan_io *sio;
	struct scsi_set_window *wcmd;
	void *vwd;
{
	struct umax_uc630_window_data {
		struct scsi_window_data	window_data;
		u_int8_t speed;
		u_int8_t select_color;
		u_int8_t highlight;
		u_int8_t shadow;
		u_int8_t paper_length[2];
	} *uwd = (struct umax_uc630_window_data*)vwd;
	struct scsi_link *sc_link = ss->sc_link;

	uwd->speed = 1;		/* speed: fastest speed that doesn't smear */
	switch (sio->scan_image_mode) {	/* UMAX has three-pass color. */
	case SIM_RED:			/* This selects which filter to use. */
		uwd->select_color = 0x80;
		break;
	case SIM_GREEN:
		uwd->select_color = 0x40;
		break;
	case SIM_BLUE:
		uwd->select_color = 0x20;
		break;
	}
	uwd->highlight = 50;		/* 50 = highest; 0 = lowest */
	/* leave shadow set to zero. */
	/* XXX paper length is for ADF */

	/* send the command to the scanner */
	return (scsi_scsi_cmd(sc_link, (struct scsi_generic *)wcmd,
	    sizeof(struct scsi_set_window), (u_char *)uwd,
	    sizeof(struct umax_uc630_window_data), SCSI_RETRIES, 5000, NULL,
	    SCSI_DATA_OUT));
}

#ifdef NOTYET /* for ADF support */
int
fujitsu_m3096g_sw(ss, sio, wcmd, vwd)
	struct ss_softc *ss;
	struct scan_io *sio;
	struct scsi_set_window *wcmd;
	void *vwd;
{
	struct fujitsu_m3096g_window_data {
		struct scsi_window_data	window_data;
		u_int8_t id;
		u_int8_t res1;
		u_int8_t outline;
		u_int8_t emphasis;
		u_int8_t mixed;
		u_int8_t mirroring;
		u_int8_t res2[5];
		u_int8_t subwindow_list[2];
		u_int    paper_size_std:2;
		u_int    res3:1;
		u_int    paper_orientaton:1;
		u_int    paper_size_type:4;
/* defines for Paper Size Type: */
#define FUJITSU_PST_A3			0x03
#define FUJITSU_PST_A4			0x04
#define FUJITSU_PST_A5			0x05
#define FUJITSU_PST_DOUBLE_LETTER	0x06
#define FUJITSU_PST_LETTER		0x07
#define FUJITSU_PST_B4			0x0C
#define FUJITSU_PST_B5			0x0D
#define FUJITSU_PST_LEGAL		0x0F
		u_int8_t paper_width_x[4];
		u_int8_t paper_width_y[4];
		u_int8_t res4[2];
	} *fwd = (struct fujitsu_m3096g_window_data*)vwd;
	struct scsi_link *sc_link = ss->sc_link;

	/* send the command to the scanner */
	return (scsi_scsi_cmd(sc_link, (struct scsi_generic *)wcmd,
	    sizeof(struct scsi_set_window), (u_char *)fwd,
	    sizeof(struct fujitsu_m3096g_window_data), SCSI_RETRIES, 5000, NULL,
	    SCSI_DATA_OUT));
}
#endif

void
get_buffer_status(ss, bp)
	struct ss_softc *ss;
	struct buf *bp;
{
	struct scsi_get_buffer_status gbs_cmd;
	struct scsi_link *sc_link = ss->sc_link;
	struct {
		u_int8_t stat_len[3];
		u_int8_t res1;
		u_int8_t window_id;
		u_int8_t res2;
		u_int8_t tgt_accept_buf_len[3];
		u_int8_t tgt_send_buf_len[3];
	} buf_sz_retn;
	int flags;

	bzero(&gbs_cmd, sizeof(gbs_cmd));
	gbs_cmd.opcode = GET_BUFFER_STATUS;
	_lto2b(12, gbs_cmd.len);
	flags = SCSI_DATA_IN;

	if (scsi_scsi_cmd(sc_link, (struct scsi_generic *) &gbs_cmd,
	    sizeof(gbs_cmd), (u_char *) &buf_sz_retn, sizeof(buf_sz_retn),
	    0, 100000, bp, flags | SCSI_NOSLEEP)) {
		printf("%s: not queued\n", ss->sc_dev.dv_xname);
	}
	bp->b_bcount = MIN(_3btol(buf_sz_retn.tgt_send_buf_len), bp->b_bcount);
}

#ifdef NOTYET
int
umax_compute_sizes(ss)
	struct ss_softc *ss;
{
	ss->sio.scan_lines = ;
	ss->sio.scan_window_size = ;
}

int
calc_umax_row_len(dpi, ww)
	int dpi;
	int ww;
{
	int st[301];
	int i;
	int rowB = 0;

	for (i = 1; i <= 300; i++)
		st[i] = 1;

	for (i = 1; i <= 300 - dpi; i++)
		st[i * 300 / (300 - dpi)] = 0;

	for (i = 1; i <= (ww % 1200) / 4; i++) {
		if (st[i])
			rowB++;
	}

	return ((ww / 1200) * dpi + rowB);
}
#endif
@


1.79
log
@Die struct scsi_device! Die! Instead, save a pointer to the routine
to interpret sense errors. This is initialized to the basic
interpretation routine, and specific scsi drivers (sd/st/cd) can
replace this with their own. While here kill EJUSTRETURN dance and
make more specialized interpretation routines directly call the
basic routine if desired.

Fixes by matthew@@ to my first diff. Most original work by dlg@@.

ok matthew@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.78 2010/07/01 03:01:37 matthew Exp $	*/
@


1.78
log
@Restore setting xs->bp; fixes ncr(4) on VAX.

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.77 2010/06/30 00:02:00 dlg Exp $	*/
a254 7
struct scsi_device ss_switch = {
	NULL,
	NULL,
	NULL,
	NULL,
};

a320 1
	sc_link->device = &ss_switch;
d684 3
@


1.77
log
@switch ss over to using xshandlers for queuing io. this brings it into line
with sd/cd/st.

largely a mechanical change, untested due to a complete lack of hardware
anywhere.

ok krw@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.76 2010/06/26 23:24:45 guenther Exp $	*/
d658 1
@


1.76
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.75 2010/06/26 21:27:55 krw Exp $	*/
d114 1
a114 1
void    ssstart(void *);
d257 1
a257 1
	ssstart,
d356 2
a357 3
	mtx_init(&ss->sc_start_mtx, IPL_BIO);

	timeout_set(&ss->timeout, ssstart, ss);
d593 1
a593 1
	ssstart(ss);
d627 1
a627 2
ssstart(v)
	void *v;
d629 2
a630 3
	struct ss_softc *ss = v;
	struct scsi_link *sc_link = ss->sc_link;
	struct scsi_xfer *xs;
d636 3
a638 4
	mtx_enter(&ss->sc_start_mtx);
	ss->sc_start_count++;
	if (ss->sc_start_count > 1) {
		mtx_leave(&ss->sc_start_mtx);
a640 8
	mtx_leave(&ss->sc_start_mtx);
	CLR(ss->flags, SSF_WAITING);
restart:
	while (!ISSET(ss->flags, SSF_WAITING) &&
	    (bp = BUFQ_DEQUEUE(ss->sc_bufq)) != NULL) {
		xs = scsi_xs_get(sc_link, SCSI_NOSLEEP);
		if (xs == NULL)
			break;
d642 5
a646 5
		if (ss->special.read) {
			(ss->special.read)(ss, xs, bp);
		} else {
			cdb = (struct scsi_r_scanner *)xs->cmd;
			xs->cmdlen = sizeof(*cdb);
d648 2
a649 2
			cdb->opcode = READ_BIG;
			_lto3b(bp->b_bcount, cdb->len);
d651 7
a657 7
			xs->data = bp->b_data;
			xs->datalen = bp->b_bcount;
			xs->flags |= SCSI_DATA_IN;
			xs->retries = 0;
			xs->timeout = 100000;
			xs->done = ssdone;
			xs->cookie = bp;
d659 1
a659 2
			scsi_xs_exec(xs);
		}
d661 5
a665 8
	mtx_enter(&ss->sc_start_mtx);
	ss->sc_start_count--;
	if (ss->sc_start_count != 0) {
		ss->sc_start_count = 1;
		mtx_leave(&ss->sc_start_mtx);
		goto restart;
	}
	mtx_leave(&ss->sc_start_mtx);
d685 1
a685 1
		SET(ss->flags, SSF_WAITING); /* break out of cdstart loop */
@


1.75
log
@Not that anyone uses it, but bring ss(4) device referencing into
line with sd/cd/st.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.74 2010/06/15 04:11:34 dlg Exp $	*/
a40 1
#include <sys/user.h>
@


1.74
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.73 2010/06/11 12:02:44 krw Exp $	*/
d562 1
a562 1
	struct ss_softc *ss = ss_cd.cd_devs[SSUNIT(bp->b_dev)];
d565 6
d597 1
d600 2
d604 1
a604 1
	 * Correctly set the buf to indicate a completed xfer
d610 2
@


1.73
log
@Restore an unusual XS_SENSE semantic that inadvertantly got lost
in the great re-write. If the scsi device *_interpret_sense()
function returns 0 that means there was no error.

Fixes restore(8) problems seen on certain tape drives.

Found and fix tested by Percey Piper. Suggestions from Matthew
Dempsky. Thanks!

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.72 2010/06/01 15:27:16 thib Exp $	*/
d791 1
a791 2
		return (scsi_do_ioctl(ss->sc_link, dev, cmd, addr,
		    flag, p));
@


1.72
log
@move cd, st & ss over to bufq's again.

Tested by myself and krw.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.71 2010/04/12 09:51:48 dlg Exp $	*/
d679 1
a679 1
	int s;
d697 7
a703 1
		if (scsi_interpret_sense(xs) != ERESTART)
@


1.71
log
@i snuck fine grained locking into the midlayer as part of all the
other stuff ive been doing in here. everything that needs protection
inside the midlayer and the scsi device drivers (sd, cd, etc) uses
mutexes now.

this pushes splbio out of the midlayer. splbio is only taken before
biodone is called now.

ok beck@@ marco@@ krw@@ deraadt@@. theyre all terrified, but they all
say if we're going to do then now is the right stage of the dev
cycle.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.70 2010/01/15 05:50:31 krw Exp $	*/
a356 1
	mtx_init(&ss->sc_buf_mtx, IPL_BIO);
d361 2
a362 6
	/*
	 * Set up the buf queue for this device
	 */
	ss->sc_buf_queue.b_active = 0;
	ss->sc_buf_queue.b_actf = 0;
	ss->sc_buf_queue.b_actb = &ss->sc_buf_queue.b_actf;
d582 1
a582 1
	scsi_buf_enqueue(&ss->sc_buf_queue, bp, &ss->sc_buf_mtx);
d639 1
a639 2
	    (bp = scsi_buf_dequeue(&ss->sc_buf_queue, &ss->sc_buf_mtx)) != NULL) {

d689 1
a689 1
		scsi_buf_requeue(&ss->sc_buf_queue, bp, &ss->sc_buf_mtx);
@


1.70
log
@Abstract and merge the manual buf queue manipulating functions into
one place for easier debugging and maintenance. No intended functional
changes.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.69 2010/01/15 05:31:38 krw Exp $	*/
d685 1
a685 2

	splassert(IPL_BIO);
d729 1
d731 1
@


1.69
log
@Restore XS_BUSY delay behaviour for buf i/o. Same as for sync path.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.68 2010/01/12 23:33:57 dlg Exp $	*/
d365 3
a367 3
	ss->buf_queue.b_active = 0;
	ss->buf_queue.b_actf = 0;
	ss->buf_queue.b_actb = &ss->buf_queue.b_actf;
d587 1
a587 1
	ss_buf_enqueue(ss, bp);
a607 42
void
ss_buf_enqueue(struct ss_softc *ss, struct buf *bp)
{
	struct buf *dp;

	mtx_enter(&ss->sc_buf_mtx);
	dp = &ss->buf_queue;
	bp->b_actf = NULL;
	bp->b_actb = dp->b_actb;
	*dp->b_actb = bp;
	dp->b_actb = &bp->b_actf;
	mtx_leave(&ss->sc_buf_mtx);
}

struct buf *
ss_buf_dequeue(struct ss_softc *ss)
{
	struct buf *bp;

	mtx_enter(&ss->sc_buf_mtx);
	bp = ss->buf_queue.b_actf;
	if (bp != NULL)
		ss->buf_queue.b_actf = bp->b_actf;
	if (ss->buf_queue.b_actf == NULL)
		ss->buf_queue.b_actb = &ss->buf_queue.b_actf;
	mtx_leave(&ss->sc_buf_mtx);

	return (bp);
}

void
ss_buf_requeue(struct ss_softc *ss, struct buf *bp)
{
	mtx_enter(&ss->sc_buf_mtx);
	bp->b_actf = ss->buf_queue.b_actf;
	ss->buf_queue.b_actf = bp;
	if (bp->b_actf == NULL)
		ss->buf_queue.b_actb = &bp->b_actf;
	mtx_leave(&ss->sc_buf_mtx);
}


d644 1
a644 1
	    (bp = ss_buf_dequeue(ss)) != NULL) {
d696 1
a696 1
		ss_buf_requeue(ss, bp);
@


1.68
log
@bring sd.c r1.180 over to the other drivers now using the antisemaphore,
ie, dont clear the WAITING flag when restarting the xxstart loops.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.67 2010/01/11 08:56:17 krw Exp $	*/
d748 1
a749 1
		/* FALLTHROUGH */
d751 6
d758 1
d763 1
a764 1
		/* FALLTHROUGH */
@


1.67
log
@Bring mutex protections to ststart, cdstart and ssstart, as already
done in sd. Make names consistant across all three.

ok dlg@@ tested (cd) & ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.66 2010/01/09 21:12:06 dlg Exp $	*/
d683 1
a684 1
	CLR(ss->flags, SSF_WAITING);
@


1.66
log
@dont try to prevent multiple concurrent runs of a devices start routine
by setting flags around the loop. there is a race which can prevent
necessary work being completed by any of the currently running instances
of xxstart.

the caveat with the removal of this code is because multiple xxstarts can
be running at the same time they can cause io reordering, but that is less
of a problem than no io.

found by and fix tested by claudio@@
debugged with krw@@ claudio@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.65 2010/01/02 23:28:51 dlg Exp $	*/
d357 2
a358 2
	mtx_init(&ss->queue_mtx, IPL_BIO);
	mtx_init(&ss->start_mtx, IPL_BIO);
d613 1
a613 1
	mtx_enter(&ss->queue_mtx);
d619 1
a619 1
	mtx_leave(&ss->queue_mtx);
d627 1
a627 1
	mtx_enter(&ss->queue_mtx);
d633 1
a633 1
	mtx_leave(&ss->queue_mtx);
d641 1
a641 1
	mtx_enter(&ss->queue_mtx);
d646 1
a646 1
	mtx_leave(&ss->queue_mtx);
d676 8
d712 8
@


1.65
log
@move the buf handling from using scsi_scsi_cmd over to scsi_xs_exec. i
think this is the last chunk of code using a buf pointer in the scsi_xfer
now.

this has not been tested due to a lack of hardware anywhere. if there are
problems please report them as soon as possible.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.64 2010/01/01 06:30:27 dlg Exp $	*/
a675 9
	mtx_enter(&ss->start_mtx);
	if (ISSET(ss->flags, SSF_STARTING)) {
		mtx_leave(&ss->start_mtx);
		return;
	}

	SET(ss->flags, SSF_STARTING);
	mtx_leave(&ss->start_mtx);

a703 3
	mtx_enter(&ss->start_mtx);
	CLR(ss->flags, SSF_STARTING);
	mtx_leave(&ss->start_mtx);
@


1.64
log
@split the flags used in a scsi_link structure to represent its state at
runtime out into a separate state variable. only operate on the state bits
with atomic ops. introduce the DYING state so things that sleep can figure
out if they should keep going or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.62 2008/06/22 16:32:05 krw Exp $	*/
d116 1
d357 5
a567 1
	struct buf *dp;
a581 2
	s = splbio();

d587 1
a587 5
	dp = &ss->buf_queue;
	bp->b_actf = NULL;
	bp->b_actb = dp->b_actb;
	*dp->b_actb = bp;
	dp->b_actb = &bp->b_actf;
a595 1
	splx(s);
d608 42
d670 3
a672 3
	struct buf *bp, *dp;
	struct scsi_r_scanner read_cmd;
	int flags;
a674 14
	/*
	 * See if there is a buf to do and we are not already
	 * doing one
	 */
	while (sc_link->openings > 0) {
		/* if a special awaits, let it proceed first */
		mtx_enter(&sc_link->mtx);
		if (ISSET(sc_link->state, SDEV_S_WAITING)) {
			atomic_clearbits_int(&sc_link->state, SDEV_S_WAITING);
			wakeup((caddr_t)sc_link);
			mtx_leave(&sc_link->mtx);
			return;
		}
		mtx_leave(&sc_link->mtx);
d676 16
a691 11
		/*
		 * See if there is a buf with work for us to do..
		 */
		dp = &ss->buf_queue;
		if ((bp = dp->b_actf) == NULL)
			return;
		if ((dp = bp->b_actf) != NULL)
			dp->b_actb = bp->b_actb;
		else
			ss->buf_queue.b_actb = bp->b_actb;
		*bp->b_actb = dp;
d694 1
a694 1
			(ss->special.read)(ss, bp);
d696 55
a750 12
			/* generic scsi2 scanner read */
			bzero(&read_cmd, sizeof(read_cmd));
			read_cmd.opcode = READ_BIG;
			_lto3b(bp->b_bcount, read_cmd.len);
			flags = SCSI_DATA_IN;
			/*
			 * go ask the adapter to do all this for us
			 */
			if (scsi_scsi_cmd(sc_link, (struct scsi_generic *)
			    &read_cmd, sizeof(read_cmd), (u_char *) bp->b_data,
			    bp->b_bcount, 0, 100000, bp, flags | SCSI_NOSLEEP))
				printf("%s: not queued\n", ss->sc_dev.dv_xname);
d752 7
d760 3
@


1.63
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d641 3
a643 2
		if (sc_link->flags & SDEV_WAITING) {
			sc_link->flags &= ~SDEV_WAITING;
d645 1
d648 1
@


1.62
log
@Replace MUSTEK_RETRIES, SCANJET_RETRIES and ST_RETRIES with SCSI_RETRIES,
all defined to 4. Replace some magic number 4's with SCSI_RETRIES. Fix a
few lines that were now too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.61 2008/05/22 21:53:12 jasper Exp $	*/
d504 1
a504 1
	(ss->sc_link->adapter->scsi_minphys)(bp);
@


1.61
log
@zap useless comment block with no content.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.60 2007/11/27 16:22:14 martynas Exp $	*/
d543 2
a544 1
				sizeof(trigger_cmd), 0, 0, 4, 5000, NULL, 0);
d863 1
a863 1
		    4, 5000, NULL, SCSI_DATA_OUT));
d888 1
a888 1
	    sizeof(struct ricoh_is410_window_data), 4, 5000, NULL,
d928 1
a928 1
	    sizeof(struct umax_uc630_window_data), 4, 5000, NULL,
d972 1
a972 1
	    sizeof(struct fujitsu_m3096g_window_data), 4, 5000, NULL,
@


1.60
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.59 2007/09/16 01:30:24 krw Exp $	*/
a99 3
	/*
	 *
	 */
@


1.59
log
@MALLOC/FREE -> malloc/free, M_ZERO, extraneous casts,
extraneous #include <malloc.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.58 2006/12/21 02:05:46 krw Exp $	*/
d464 1
a464 1
 * occurence of an open device
@


1.58
log
@Fix some comment typos. 'immediatly' -> 'immediately', 'tranfer' ->
'transfer', 'tranfered' -> 'transferred'.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.57 2006/11/28 16:56:50 dlg Exp $	*/
a38 1
#include <sys/malloc.h>
@


1.57
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.56 2006/10/07 23:40:07 beck Exp $	*/
d575 1
a575 1
	 * If it's a null transfer, return immediatly
@


1.56
log
@make cd-roms retry forever while the device indicates that it is
"becoming ready" - this is done in the exact same way that it
was done for tape in st.c. This commit adds a cd specific interpret_sense
routine to cd.c that will catch the becoming ready case and handle it.
This also removes the need to use crazy timeouts to catch this case.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.55 2006/05/18 21:27:25 miod Exp $	*/
d302 1
a302 1
	struct scsibus_attach_args *sa = aux;
d323 1
a323 1
	struct scsibus_attach_args *sa = aux;
@


1.55
log
@paramter -> parameter
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.54 2006/05/11 00:45:59 krw Exp $	*/
d439 1
a439 1
	error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
@


1.54
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.53 2005/12/17 20:29:16 krw Exp $	*/
d716 1
a716 1
			/* XXX add routine to validate paramters */
@


1.53
log
@Kill unreachable code. Found by lint.

ok kettenis@@ deraadt@@ pedro@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.52 2005/12/10 01:36:01 deraadt Exp $	*/
d95 1
a95 1
	/* 
d102 1
a102 1
	 * 
d246 1
a246 1
       
@


1.52
log
@in ansi c, bitfields must be done against int, unsigned int, or _Bool.
so we must start to use u_int; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.51 2005/04/06 02:51:13 krw Exp $	*/
d602 1
a602 1
	bp->b_flags |= B_ERROR;
@


1.51
log
@De-register scsi.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.50 2004/11/30 19:28:37 krw Exp $	*/
d880 3
a882 3
		u_int8_t mrif:1; /* reverse image format (grayscale negative) */
		u_int8_t filtering:3;
		u_int8_t gamma_id:4;
d953 4
a956 4
		u_int8_t paper_size_std:2;
		u_int8_t res3:1;
		u_int8_t paper_orientaton:1;
		u_int8_t paper_size_type:4;
@


1.50
log
@No longer require write permission for read-only SCSI commands
submitted via ioctl. Eliminate scsi_do_safeioctl(), thus permitting
ch, ss and st devices to submit SCSI commands. Return EPERM rather
than EBADF when permissions are inadequate.

Allows more programs to run with fewer permissions. Problem diagnosed
by Nikolay Sturm in mplayer port.

Tested by Nikolay, ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.49 2004/05/09 04:01:59 krw Exp $	*/
d506 1
a506 1
	register struct ss_softc *ss = ss_cd.cd_devs[SSUNIT(bp->b_dev)];
d633 1
a633 1
	register struct buf *bp, *dp;
@


1.49
log
@Add missing <cr>'s to various SC_DEBUG() calls, along with a few other
SC_DEBUG() spacing tweaks.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.48 2003/05/18 16:06:35 mickey Exp $	*/
d737 1
a737 1
		return (scsi_do_safeioctl(ss->sc_link, dev, cmd, addr,
@


1.48
log
@constify the quirck tables and fix the scsi_inqmatch() proto accordingly; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.47 2002/12/30 21:50:29 grange Exp $	*/
d326 1
a326 1
	SC_DEBUG(sc_link, SDEV_DB2, ("ssattach: "));
d568 2
a569 2
	SC_DEBUG(ss->sc_link, SDEV_DB1,
	    ("ssstrategy %ld bytes @@ blk %d\n", bp->b_bcount, bp->b_blkno));
d637 1
a637 1
	SC_DEBUG(sc_link, SDEV_DB2, ("ssstart "));
@


1.47
log
@Add new parameter to scsi_test_unit_ready(): retries number.
Use increased retries number and don't ignore SCSI_IGNORE_NOT_READY
when call scsi_test_unit_ready() for cd-rom, this makes system wait
if drive is loading media.
Tested by millert@@ and fgsch@@; some input and ok from krw@@.
Problem reported by The lord of the CD-writers
Igor Grabin <violent@@death.kiev.ua>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.46 2002/06/09 00:05:57 art Exp $	*/
d145 1
a145 1
struct ss_quirk_inquiry_pattern ss_quirk_patterns[] = {
d266 1
a266 1
struct scsi_inquiry_pattern ss_patterns[] = {
d306 1
a306 1
	    (caddr_t)ss_patterns, sizeof(ss_patterns)/sizeof(ss_patterns[0]),
d373 1
a373 1
	struct ss_quirk_inquiry_pattern *finger;
d379 2
a380 2
	finger = (struct ss_quirk_inquiry_pattern *)scsi_inqmatch(inqbuf,
	    (caddr_t)ss_quirk_patterns,
@


1.46
log
@More (the last round?) of splasserts and splbio around biodone.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.45 2002/03/14 03:16:12 millert Exp $	*/
d439 1
a439 1
	error = scsi_test_unit_ready(sc_link,
@


1.45
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.44 2002/03/14 01:27:13 millert Exp $	*/
d608 1
d610 1
@


1.44
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.43 2001/06/22 14:35:43 deraadt Exp $	*/
d856 1
a856 1
		    &window_cmd, (void*)&wd));
@


1.43
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.42 2001/03/25 04:23:45 fgsch Exp $	*/
d93 2
a94 2
	int	(*vendor_unique_sw)__P((struct ss_softc *, struct scan_io *,
					struct scsi_set_window *, void *));
d99 1
a99 1
	void	(*special_minphys)__P((struct ss_softc *, struct buf *));
d104 1
a104 1
	int	(*compute_sizes)__P((void));
d118 11
a128 11
void    ssstrategy __P((struct buf *));
void    ssstart __P((void *));
void	ssminphys __P((struct buf *));

void	ss_identify_scanner __P((struct ss_softc *, struct scsi_inquiry_data*));
int	ss_set_window __P((struct ss_softc *, struct scan_io *));

int	ricoh_is410_sw __P((struct ss_softc *, struct scan_io *,
			    struct scsi_set_window *, void *));
int	umax_uc630_sw __P((struct ss_softc *, struct scan_io *,
			   struct scsi_set_window *, void *));
d130 2
a131 2
int	fujitsu_m3096g_sw __P((struct ss_softc *, struct scan_io *,
			       struct scsi_set_window *, void *));
d134 1
a134 1
void	get_buffer_status __P((struct ss_softc *, struct buf *));
d248 2
a249 2
int ssmatch __P((struct device *, void *, void *));
void ssattach __P((struct device *, struct device *, void *));
@


1.43.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.43 2001/06/22 14:35:43 deraadt Exp $	*/
d93 2
a94 2
	int	(*vendor_unique_sw)(struct ss_softc *, struct scan_io *,
					struct scsi_set_window *, void *);
d99 1
a99 1
	void	(*special_minphys)(struct ss_softc *, struct buf *);
d104 1
a104 1
	int	(*compute_sizes)(void);
d118 11
a128 11
void    ssstrategy(struct buf *);
void    ssstart(void *);
void	ssminphys(struct buf *);

void	ss_identify_scanner(struct ss_softc *, struct scsi_inquiry_data*);
int	ss_set_window(struct ss_softc *, struct scan_io *);

int	ricoh_is410_sw(struct ss_softc *, struct scan_io *,
			    struct scsi_set_window *, void *);
int	umax_uc630_sw(struct ss_softc *, struct scan_io *,
			   struct scsi_set_window *, void *);
d130 2
a131 2
int	fujitsu_m3096g_sw(struct ss_softc *, struct scan_io *,
			       struct scsi_set_window *, void *);
d134 1
a134 1
void	get_buffer_status(struct ss_softc *, struct buf *);
d248 2
a249 2
int ssmatch(struct device *, void *, void *);
void ssattach(struct device *, struct device *, void *);
a607 1
	s = splbio();
a608 1
	splx(s);
d856 1
a856 1
		    &window_cmd, (void *)&wd));
@


1.43.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d439 1
a439 1
	error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
@


1.42
log
@Support for several HP scanners; from jmartin@@ugrad.cs.ualberta.ca, krw@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.41 2000/06/16 21:47:19 provos Exp $	*/
d770 1
a770 1
		       window_data.window_desc_len);
d860 5
a864 5
		        (struct scsi_generic *)&window_cmd,
			sizeof(window_cmd), (u_char *) &wd.window_data,
			(ss->quirkdata->quirks & SS_Q_WINDOW_DESC_LEN) ?
			ss->quirkdata->window_descriptor_length : 40,
			4, 5000, NULL, SCSI_DATA_OUT));
@


1.41
log
@take MIN/MAX from param.h, okay theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.40 1999/05/11 23:57:44 kstailey Exp $	*/
d278 4
d285 10
@


1.40
log
@clean up
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.39 1999/05/11 23:52:47 kstailey Exp $	*/
a55 2

#define	MIN(a,b) (((a)<(b))?(a):(b))
@


1.40.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.42 2001/03/25 04:23:45 fgsch Exp $	*/
d57 2
a279 4
	 "HP      ", "C2570A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C2520A          ", ""},
	{T_PROCESSOR, T_FIXED,
a282 10
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C6290A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C5190A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C7190A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C6270A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C7670A          ", ""},
@


1.40.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.40.4.1 2001/05/14 22:45:00 niklas Exp $	*/
d770 1
a770 1
		    window_data.window_desc_len);
d860 5
a864 5
		    (struct scsi_generic *)&window_cmd,
		    sizeof(window_cmd), (u_char *) &wd.window_data,
		    (ss->quirkdata->quirks & SS_Q_WINDOW_DESC_LEN) ?
		    ss->quirkdata->window_descriptor_length : 40,
		    4, 5000, NULL, SCSI_DATA_OUT));
@


1.40.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 2
a94 2
	int	(*vendor_unique_sw)(struct ss_softc *, struct scan_io *,
					struct scsi_set_window *, void *);
d99 1
a99 1
	void	(*special_minphys)(struct ss_softc *, struct buf *);
d104 1
a104 1
	int	(*compute_sizes)(void);
d118 11
a128 11
void    ssstrategy(struct buf *);
void    ssstart(void *);
void	ssminphys(struct buf *);

void	ss_identify_scanner(struct ss_softc *, struct scsi_inquiry_data*);
int	ss_set_window(struct ss_softc *, struct scan_io *);

int	ricoh_is410_sw(struct ss_softc *, struct scan_io *,
			    struct scsi_set_window *, void *);
int	umax_uc630_sw(struct ss_softc *, struct scan_io *,
			   struct scsi_set_window *, void *);
d130 2
a131 2
int	fujitsu_m3096g_sw(struct ss_softc *, struct scan_io *,
			       struct scsi_set_window *, void *);
d134 1
a134 1
void	get_buffer_status(struct ss_softc *, struct buf *);
d248 2
a249 2
int ssmatch(struct device *, void *, void *);
void ssattach(struct device *, struct device *, void *);
d856 1
a856 1
		    &window_cmd, (void *)&wd));
@


1.40.4.4
log
@Sync the SMP branch with 3.3
@
text
@d439 1
a439 1
	error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
a607 1
	s = splbio();
a608 1
	splx(s);
@


1.40.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.40.4.4 2003/03/28 00:08:47 niklas Exp $	*/
d145 1
a145 1
const struct ss_quirk_inquiry_pattern ss_quirk_patterns[] = {
d266 1
a266 1
const struct scsi_inquiry_pattern ss_patterns[] = {
d306 1
a306 1
	    ss_patterns, sizeof(ss_patterns)/sizeof(ss_patterns[0]),
d373 1
a373 1
	const struct ss_quirk_inquiry_pattern *finger;
d379 2
a380 2
	finger = (const struct ss_quirk_inquiry_pattern *)scsi_inqmatch(inqbuf,
	    ss_quirk_patterns,
@


1.40.4.6
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d326 1
a326 1
	SC_DEBUG(sc_link, SDEV_DB2, ("ssattach:\n"));
d568 2
a569 2
	SC_DEBUG(ss->sc_link, SDEV_DB2, ("ssstrategy: %ld bytes @@ blk %d\n",
	    bp->b_bcount, bp->b_blkno));
d637 1
a637 1
	SC_DEBUG(sc_link, SDEV_DB2, ("ssstart\n"));
@


1.39
log
@set window descriptor length to actual amount of data
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.38 1999/05/11 23:41:37 kstailey Exp $	*/
d115 1
a115 1
	"generic", 0, 40, 0, 0, 0,
a380 3
#if 0
		ss_gen_quirks.name = "generic";
#endif
@


1.38
log
@initialize generic quirks
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.37 1999/05/11 23:25:43 kstailey Exp $	*/
d853 3
a855 1
			sizeof(wd.window_data), 4, 5000, NULL, SCSI_DATA_OUT));
@


1.37
log
@generic trigger
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.36 1998/09/16 15:53:24 kstailey Exp $	*/
d114 5
a118 1
struct  quirkdata ss_gen_quirks;
@


1.36
log
@add support for HP ScanJet IIp
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.35 1998/02/22 00:49:13 niklas Exp $	*/
d528 7
a534 1
			/* XXX addd code for generic trigger */
d744 1
a744 1
	struct scsi_link	*sc_link = ss->sc_link;;
@


1.35
log
@Please GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.34 1997/08/02 21:35:32 kstailey Exp $	*/
d271 2
@


1.34
log
@add ScanJet 5p, untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.33 1997/04/15 10:51:36 tholo Exp $	*/
d780 1
a780 1
	if (ss->quirkdata->quirks & SS_Q_MONO_THRESHOLD)
d786 1
a786 1
	else if (ss->quirkdata->quirks & SS_Q_THRESHOLD)
@


1.33
log
@Add quirk, type for AT3 scanner (ViewStation 32)
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.32 1997/04/05 23:34:20 kstailey Exp $	*/
d275 2
@


1.32
log
@add quirk table entry for the Ultima A6000C
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.31 1997/04/05 22:59:13 kstailey Exp $	*/
d144 9
@


1.31
log
@fix NULL ptr deref in ss_set_window()
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.30 1997/03/13 12:22:37 kstailey Exp $	*/
d81 1
a81 1
#define SS_Q_PADDING_TYPE	0x0200 /* does not pad to byte boundary */
d145 9
d812 1
a812 1
		window_data.pad_type = 3; /* 3 = pad to byte boundary */
@


1.30
log
@Copy the scanner_type from the quirkdata to the sio for userland to see.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.29 1997/03/13 12:19:59 kstailey Exp $	*/
d114 2
d354 5
d964 33
@


1.29
log
@Add scanner_type and compute_sizes() to quirks.
Adjust attach() messages for scanners with quirk table entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.28 1997/03/11 12:06:48 kstailey Exp $	*/
d348 1
@


1.28
log
@adjust comments
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.27 1997/03/11 04:00:15 kstailey Exp $	*/
d90 1
d101 6
a106 1
	void	(*special_minphys)__P(( struct ss_softc *, struct buf *));
d152 2
a153 1
		 ricoh_is410_sw, get_buffer_status
d163 2
a164 1
		 ricoh_is410_sw, get_buffer_status
d174 2
a175 1
		 ricoh_is410_sw, get_buffer_status
d183 2
a184 1
		 umax_uc630_sw, NULL
d192 2
a193 1
		 umax_uc630_sw, NULL
d206 2
a207 1
		 fujistsu_m3096g_sw, NULL
d219 2
a220 1
		 NULL, NULL
d317 3
d348 1
a348 1
		printf("%s\n", ss->quirkdata->name);
a351 2
		/* XXX fill in the rest of the scan_io struct by
                   calling compute_sizes routine */
@


1.27
log
@Added GENERIC_SCSI2 scanner type.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.26 1997/03/11 03:40:49 kstailey Exp $	*/
d336 2
@


1.26
log
@move init. code to m.i. section
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.25 1997/03/11 03:19:16 kstailey Exp $	*/
d334 2
a335 1
		printf(" generic scanner\n"); /* good luck 8c{)] */
@


1.25
log
@added whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.24 1997/03/11 00:45:19 kstailey Exp $	*/
d289 14
@


1.24
log
@Add comment about generic trigger missing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.23 1997/03/10 03:20:30 kstailey Exp $	*/
d320 1
a320 1
		printf("generic scanner\n"); /* good luck 8c{)] */
d504 2
a505 2
	 * at the end (a bit silly because we only have on user..
	 * (but it could fork()))
@


1.23
log
@Do not increase buffer bp->b_bcount in get_buffer_status().
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.22 1997/03/10 02:34:42 kstailey Exp $	*/
d466 2
d768 1
a769 1
	/* else leave bit_ordering set to zero. */
@


1.22
log
@SCSI 2 scanners use READ_BIG not READ
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.21 1997/03/10 02:29:39 kstailey Exp $	*/
a33 1
#include <sys/types.h>
d57 2
d632 1
a632 1
			/* add routine to validate paramters */
d921 1
a921 1
	bp->b_bcount = _3btol(buf_sz_retn.tgt_send_buf_len);
@


1.21
log
@do GET_BUFFER_STATUS in special minphys
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.20 1997/03/10 00:56:59 kstailey Exp $	*/
d95 4
d582 1
a582 1
			read_cmd.opcode = READ;
@


1.20
log
@Start of generic scanner read().
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.19 1997/03/09 17:45:01 kstailey Exp $	*/
d71 1
a71 1
#define SS_Q_BRIGHTNESS		0x0002 /* use special value for brightness */
d73 1
a73 1
#define SS_Q_THRESHOLD		0x0008 /* use special value for threshold */
d76 1
a76 1
#define SS_Q_CONTRAST		0x0020 /* use special value for contrast */
d81 1
a81 2
#define SS_Q_BIT_ORDERING	0x0400 /* uses non-zero bit ordering */
#define SS_Q_GET_BUFFER_SIZE	0x0800 /* use GET_BUFFER_SIZE while reading */
d89 4
d95 1
d119 1
d141 1
a141 1
		 ricoh_is410_sw
d151 1
a151 1
		 ricoh_is410_sw
d161 1
a161 1
		 ricoh_is410_sw
d169 1
a169 1
		 umax_uc630_sw
d177 1
a177 1
		 umax_uc630_sw
d190 1
a190 1
		 fujistsu_m3096g_sw
d202 1
a202 1
		 NULL
d310 3
d401 1
a401 1
		if (ss->special->rewind_scanner) {
d403 1
a403 1
			error = (ss->special->rewind_scanner)(ss);
d437 2
a438 2
	if (ss->special->minphys)
		(ss->special->minphys)(ss, bp);
d457 2
a458 2
		if (ss->special->trigger_scanner) {
			error = (ss->special->trigger_scanner)(ss);
d545 1
a545 1
	struct scsi_r_scanner cmd;
d573 2
a574 2
		if (ss->special->read) {
			(ss->special->read)(ss, bp);
d577 3
a579 6
			if (ss->quirkdata->quirks & SS_Q_GET_BUFFER_SIZE) {
				/* XXX add GET BUFFER SIZE command */
			}
			bzero(&cmd, sizeof(cmd));
			cmd.opcode = READ;
			_lto3b(bp->b_bcount, cmd.len);
d584 3
a586 3
			if (scsi_scsi_cmd(sc_link, (struct scsi_generic *) &cmd,
			    sizeof(cmd), (u_char *) bp->b_data, bp->b_bcount, 0,
			    100000, bp, flags | SCSI_NOSLEEP))
d611 2
a612 2
		if (ss->special->get_params) {
			error = (ss->special->get_params)(ss);
d622 2
a623 2
		if (ss->special->set_params) {
			error = (ss->special->set_params)(ss, sio);
d633 2
a634 2
		if (ss->special->rewind_scanner ) {
			error = (ss->special->rewind_scanner)(ss);
d888 30
@


1.19
log
@deleted SS_Q_VENDOR_SETWINDOW bit.  Just check for non-NULL vendor_unique_sw
member.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.18 1997/03/08 22:52:58 kstailey Exp $	*/
d537 2
d569 14
a582 1
			/* XXX add code for SCSI2 scanner read */
@


1.18
log
@Smaller names for quirks.

Many changes based on examination of the AIX 3 version of PINT.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.17 1997/03/08 20:51:36 kstailey Exp $	*/
d82 1
a82 2
#define SS_Q_VENDOR_SETWINDOW	0x0800 /* 40 bytes of parms is not enough */
#define SS_Q_GET_BUFFER_SIZE	0x1000 /* use GET_BUFFER_SIZE while reading */
d134 1
a134 2
		 SS_Q_BIT_ORDERING |
		 SS_Q_VENDOR_SETWINDOW,
d144 1
a144 2
		 SS_Q_BIT_ORDERING |
		 SS_Q_VENDOR_SETWINDOW,
d154 1
a154 2
		 SS_Q_BIT_ORDERING |
		 SS_Q_VENDOR_SETWINDOW,
d162 1
a162 2
		 SS_Q_HALFTONE |
		 SS_Q_VENDOR_SETWINDOW,
d170 1
a170 2
		 SS_Q_HALFTONE |
		 SS_Q_VENDOR_SETWINDOW,
d747 1
a747 1
	if (ss->quirkdata->quirks &SS_Q_VENDOR_SETWINDOW)
@


1.17
log
@support for RIF bit as a quirk (currently unused)
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.16 1997/03/08 20:43:09 kstailey Exp $	*/
d70 14
a83 11
#define SS_Q_NEEDS_WINDOW_DESC_LEN	0x0001 /* needs special WDL */
#define SS_Q_USES_HALFTONE		0x0002 /* uses non-zero halftone */
#define SS_Q_NEEDS_RIF_SET		0x0004
#define SS_Q_NEEDS_PADDING_TYPE		0x0008 /* does not pad to byte
						  boundary */
#define SS_Q_USES_BIT_ORDERING		0x0010 /* uses non-zero bit ordering */
#define SS_Q_VENDOR_UNIQUE_SETWINDOW	0x0020 /* 40 bytes of parms is not
						  enough */
#define SS_Q_GET_BUFFER_SIZE		0x0040 /* use GET_BUFFER_SIZE while
						  reading */

d85 3
d128 13
d143 17
a159 5
		 SS_Q_NEEDS_WINDOW_DESC_LEN |
		 SS_Q_USES_HALFTONE |
		 SS_Q_USES_BIT_ORDERING |
		 SS_Q_VENDOR_UNIQUE_SETWINDOW,
		 320, { 2, 0x0a }, 0, 7,
d165 4
a168 4
		 SS_Q_NEEDS_WINDOW_DESC_LEN |
		 SS_Q_USES_HALFTONE |
		 SS_Q_VENDOR_UNIQUE_SETWINDOW,
		 0x2e, { 0, 1 }, 0, 0,
d174 4
a177 4
		 SS_Q_NEEDS_WINDOW_DESC_LEN |
		 SS_Q_USES_HALFTONE |
		 SS_Q_VENDOR_UNIQUE_SETWINDOW,
		 0x2e, { 0, 1 }, 0, 0,
d184 7
a190 5
		 SS_Q_NEEDS_WINDOW_DESC_LEN |
		 SS_Q_USES_HALFTONE |
		 SS_Q_NEEDS_RIF_SET |
		 SS_Q_NEEDS_PADDING_TYPE,
		 64, { 0, 1 }, 0, 0,
d197 6
a202 3
		 SS_Q_USES_HALFTONE |
		 SS_Q_NEEDS_PADDING_TYPE,
		 0, { 0, 1 }, 0, 0,
d667 1
a667 1
	if (ss->quirkdata->quirks & SS_Q_NEEDS_WINDOW_DESC_LEN)
d672 3
d683 35
a717 3
	window_data.brightness     = sio->scan_brightness;
	window_data.threshold      = sio->scan_brightness;
	window_data.contrast       = sio->scan_contrast;
d727 1
d729 2
a730 1
	if (ss->quirkdata->quirks & SS_Q_USES_HALFTONE) {
d736 2
a737 1
	if (ss->quirkdata->quirks & SS_Q_NEEDS_RIF_SET)
d739 2
a740 1
	if (ss->quirkdata->quirks & SS_Q_NEEDS_PADDING_TYPE)
d744 2
a745 1
	if (ss->quirkdata->quirks & SS_Q_USES_BIT_ORDERING)
d747 1
d753 1
a753 1
	if (ss->quirkdata->quirks &SS_Q_VENDOR_UNIQUE_SETWINDOW)
@


1.16
log
@Fujitsu SET_WINDOW support
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.15 1997/03/08 18:59:41 kstailey Exp $	*/
d663 2
a664 1
	/* leave rif set to zero. */
@


1.15
log
@way more generic SET_WINDOW...
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.14 1997/03/08 05:39:00 kstailey Exp $	*/
d73 2
a74 1
#define SS_Q_NEEDS_PADDING_TYPE		0x0008 /* does not pad to byte boundary */
d76 4
a79 2
#define SS_Q_VENDOR_UNIQUE_SETWINDOW	0x0020 /* 40 bytes of parms is not enough */
#define SS_Q_GET_BUFFER_SIZE		0x0040 /* use GET_BUFFER_SIZE while reading */
d98 1
a98 1
void	ss_identify_scanner __P((struct ss_softc *, struct scsi_inquiry_data *));
d105 5
d149 12
a160 1
#ifdef NOTYET
d163 5
d680 2
a681 1
		return (scsi_scsi_cmd(sc_link, (struct scsi_generic *) &window_cmd,
d701 1
a701 1
	struct scsi_link	*sc_link = ss->sc_link;;
a717 1

d727 1
a727 1
	struct scsi_link	*sc_link = ss->sc_link;;
d751 45
@


1.14
log
@generic set_window via quirk table
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.13 1997/03/08 02:15:05 kstailey Exp $	*/
d5 1
a5 1
 * Copyright (c) 1995 Kenneth Stailey.  All rights reserved.
d68 1
d73 1
a73 1
#define SS_Q_NEEDS_PADDING_TYPE		0x0008 /* needs special padding type */
d75 2
a76 1
#define SS_Q_GET_BUFFER_SIZE		0x0020 /* use GET_BUFFER_SIZE while reading */
d82 2
d91 12
d115 1
d118 4
a121 2
		 SS_Q_USES_BIT_ORDERING,
		 320, { 2, 0x0a }, 0, 7
a122 1
#ifdef NOTYET
d124 7
a130 2
	 "FUJITSU ", "M3096Gm         ", "    "}, {
		 SS_Q_
d133 9
a141 1
	 "UMAX    ", "UC630           ", "    "}, {
d143 1
a143 1
	 "UMAX    ", "UG630           ", "    "}, {
a159 7
void    ssstrategy __P((struct buf *));
void    ssstart __P((void *));
void	ssminphys __P((struct buf *));

void	ss_identify_scanner __P((struct ss_softc *, struct scsi_inquiry_data *));
int	ss_set_window __P((struct ss_softc *, struct scan_io *));

d234 23
d536 1
a537 1
			/* call special handler */
d547 1
a548 1
			/* call special handler */
d558 1
a559 1
			/* call special handler */
d568 3
a570 4
#ifdef NOTYET
	case SCAN_USE_ADF:
		break;
#endif
d581 2
a582 2
ss_set_window(sc, sio)
	struct ss_softc *sc;
d586 11
a596 2
	struct scsi_window_data	window_data;
	struct scsi_link	*sc_link;
d607 2
a608 2
	if (sc->quirkdata->quirks & SS_Q_NEEDS_WINDOW_DESC_LEN)
		_lto2l(sc->quirkdata->window_descriptor_length,
d633 1
a633 1
	if (sc->quirkdata->quirks & SS_Q_USES_HALFTONE) {
d635 1
a635 1
			sc->quirkdata->halftone_pattern[0];
d637 1
a637 1
			sc->quirkdata->halftone_pattern[1];
d640 2
a641 2
	if (sc->quirkdata->quirks & SS_Q_NEEDS_PADDING_TYPE)
		window_data.pad_type = sc->quirkdata->pad_type;
d644 2
a645 2
	if (sc->quirkdata->quirks & SS_Q_USES_BIT_ORDERING)
		_lto2l(sc->quirkdata->bit_ordering, window_data.bit_ordering);
d649 30
a678 1
	/* XXX many scanners require a vendor-specific portion */
d681 4
a684 3
	return (scsi_scsi_cmd(sc_link, (struct scsi_generic *) &window_cmd,
	    sizeof(window_cmd), (u_char *) &window_data, sizeof(window_data),
	    4, 5000, NULL, SCSI_DATA_OUT));
d687 2
a688 2
void
ss_identify_scanner(ss, inqbuf)
d690 4
a693 1
	struct scsi_inquiry_data *inqbuf;
d695 31
a725 12
	struct ss_quirk_inquiry_pattern *finger;
	int priority;
	/*
	 * look for non-standard scanners with help of the quirk table
	 * and install functions for special handling
	 */
	finger = (struct ss_quirk_inquiry_pattern *)scsi_inqmatch(inqbuf,
	    (caddr_t)ss_quirk_patterns,
	    sizeof(ss_quirk_patterns)/sizeof(ss_quirk_patterns[0]),
	    sizeof(ss_quirk_patterns[0]), &priority);
	if (priority != 0)
		ss->quirkdata = &finger->quirkdata;
a726 1

@


1.13
log
@fix warning.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.12 1997/03/07 12:57:55 kstailey Exp $	*/
d67 51
d133 2
a134 3
#ifdef NOTYET
static int ss_set_window __P((struct ss_softc *, struct scan_io *));
#endif
a194 5
	/*
	 * look for non-standard scanners with help of the quirk table
	 * and install functions for special handling
	 */
	SC_DEBUG(sc_link, SDEV_DB2, ("ssattach:\n"));
d200 1
a200 4
		printf("\n");
	if (ss->special == NULL) {
		/* XXX add code to restart a SCSI2 scanner, if any */
	}
a505 1
#ifdef NOTYET
a507 3
#else
			return (EOPNOTSUPP);
#endif
d534 1
a534 2
#ifdef NOTYET
static int
d536 2
a537 2
	struct ss_softc *;
	struct scan_io *;
d539 3
a541 3
	struct scsi_set_window		window_cmd;
	struct scsi_window_header	window_header;
	struct scsi_window_data		window_data;
d549 1
a549 1
	_lto3l(sizeof(window_data), window_cmd.length);
d551 50
a600 14
	/*
	 * XXX Window Descriptor Length needs a quirk.
	 * Some scanners have peculiar notions about what the value
	 * should be.
	 *
	 *  In general 40 <= WDL <= sizeof(vendor unique window data)
	 *
	 *  Ricoh IS-50 & IS-410 insist on 320 (even it transfer len is less.)
	 *  Ricoh FS-1 insists on 256.
	 *  UMAX UC-630 accepts 46 (I haven't tested other values.)
	 *  Fujitsu M3096G wants 40 <= x <= 248 (tested OK at 40 & 64.)
	 */
	bzero(&window_header, sizeof(window_header));
	_lto2l(, window_header.len);
d602 7
d610 2
a611 3
	 * The first 40 bytes of the window descriptor block are defined
	 * in the standard.  After that "venor unique" data is limited
	 * only by 16-bit xfer len value.
d613 6
a618 14
	bzero(&window_data, sizeof(window_data));
	/* leave window id at zero */
	/* leave auto bit at zero */
	_lto2l(sio->sio.scan_x_resolution, window_data.x_res);
	_lto2l(sio->sio.scan_y_resolution, window_data.y_res);
	_lto4l(sio->sio.scan_x_origin, window_data.x_org);
	_lto4l(sio->sio.scan_y_origin, window_data.y_org);
	_lto4l(sio->sio.scan_width,  window_data.width);
	_lto4l(sio->sio.scan_height, window_data.length);
	window_data.brightness     = sio->sio.scan_brightness;
	window_data.threshold      = sio->sio.
	window_data.contrast       = sio->sio.scan_contrast;
	window_data.image_comp     = sio->sio.
	window_data.bits_per_pixel = sio->sio.scan_bits_per_pixel;
d620 1
a620 1
#endif
@


1.12
log
@more generic SET WINDOW stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.11 1997/03/07 03:05:15 kstailey Exp $	*/
d82 1
d84 1
@


1.11
log
@more stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.10 1997/03/06 12:44:41 kstailey Exp $	*/
d504 4
d512 12
d527 5
d533 2
d539 1
a539 1
	_lto4l(sio->sio.scan_width, window_data.width);
d541 5
@


1.10
log
@remove stub get_params functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.9 1997/02/27 06:20:23 tholo Exp $	*/
d514 4
a517 2
	_lto2l(sio->, window_data.x_org);
	_lto2l(sio->, window_data.y_org);
@


1.9
log
@When we don't output any extra scanner info, output the newline at the end
of the configuration line that we do output
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.8 1996/08/11 23:26:05 deraadt Exp $	*/
d82 2
a449 3
		} else {
			/* XXX add code for SCSI2 scanner, if any */
			return (EOPNOTSUPP);
d462 4
a465 1
			/* XXX add code for SCSI2 scanner, if any */
d467 1
d493 25
@


1.8
log
@limit ioctl priviledges
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.7 1996/07/30 11:04:08 deraadt Exp $	*/
d148 1
a148 1
	if (!bcmp(sa->sa_inqbuf->vendor, "HP      ", 8))
d150 2
@


1.7
log
@patch for HP scanjet 4p; netbsd pr#2663; kstailey@@dol-esa.gov
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.6 1996/07/11 16:38:35 deraadt Exp $	*/
d483 2
a484 1
		return (scsi_do_ioctl(ss->sc_link, dev, cmd, addr, flag, p));
@


1.6
log
@some MUSTEKs fill with 0xff instead of 0x20; netbsd pr#2617; is@@beverly.rhein.de
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.5 1996/05/10 12:31:39 deraadt Exp $	*/
d98 2
@


1.5
log
@SC_DEBUG cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.3 1996/04/21 22:31:12 deraadt Exp $	*/
d144 1
a144 1
	if (!bcmp(sa->sa_inqbuf->vendor, "MUSTEK  ", 8))
@


1.4
log
@Remove erroneously doubled text (patch can do that when a new file
comes into existence simultaneously from two directions).
@
text
@d2 1
a2 1
/*	$NetBSD: ss.c,v 1.9 1996/03/30 21:47:00 christos Exp $	*/
d323 1
a323 1
	    ("ssstrategy %d bytes @@ blk %d\n", bp->b_bcount, bp->b_blkno));
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: ss.c,v 1.2 1996/04/19 16:10:19 niklas Exp $	*/
a434 477
	struct scan_io *sio;

	switch (cmd) {
	case SCIOCGET:
		if (ss->special->get_params) {
			/* call special handler */
			error = (ss->special->get_params)(ss);
			if (error)
				return (error);
		} else {
			/* XXX add code for SCSI2 scanner, if any */
			return (EOPNOTSUPP);
		}
		bcopy(&ss->sio, addr, sizeof(struct scan_io));
		break;
	case SCIOCSET:
		sio = (struct scan_io *)addr;

		if (ss->special->set_params) {
			/* call special handler */
			error = (ss->special->set_params)(ss, sio);
			if (error)
				return (error);
		} else {
			/* XXX add code for SCSI2 scanner, if any */
			return (EOPNOTSUPP);
		}
		break;
	case SCIOCRESTART:
		if (ss->special->rewind_scanner ) {
			/* call special handler */
			error = (ss->special->rewind_scanner)(ss);
			if (error)
				return (error);
		} else
			/* XXX add code for SCSI2 scanner, if any */
			return (EOPNOTSUPP);
		ss->flags &= ~SSF_TRIGGERED;
		break;
#ifdef NOTYET
	case SCAN_USE_ADF:
		break;
#endif
	default:
		if (SSMODE(dev) != MODE_CONTROL)
			return (ENOTTY);
		return (scsi_do_ioctl(ss->sc_link, dev, cmd, addr, flag, p));
	}
	return (error);
}
/*	$NetBSD: ss.c,v 1.6 1996/02/19 00:06:07 mycroft Exp $	*/

/*
 * Copyright (c) 1995 Kenneth Stailey.  All rights reserved.
 *   modified for configurable scanner support by Joachim Koenig
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Kenneth Stailey.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/fcntl.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/device.h>
#include <sys/conf.h>		/* for cdevsw */
#include <sys/scanio.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_scanner.h>
#include <scsi/scsiconf.h>
#include <scsi/ssvar.h>

#include <scsi/ss_mustek.h>

#define SSMODE(z)	( minor(z)       & 0x03)
#define SSUNIT(z)	((minor(z) >> 4)       )

/*
 * If the mode is 3 (e.g. minor = 3,7,11,15)
 * then the device has been openned to set defaults
 * This mode does NOT ALLOW I/O, only ioctls
 */
#define MODE_REWIND	0
#define MODE_NONREWIND	1
#define MODE_CONTROL	3

int ssmatch __P((struct device *, void *, void *));
void ssattach __P((struct device *, struct device *, void *));

struct cfdriver sscd = {
	NULL, "ss", ssmatch, ssattach, DV_DULL, sizeof(struct ss_softc)
};

void    ssstrategy __P((struct buf *));
void    ssstart __P((void *));

struct scsi_device ss_switch = {
	NULL,
	ssstart,
	NULL,
	NULL,
};

struct scsi_inquiry_pattern ss_patterns[] = {
	{T_SCANNER, T_FIXED,
	 "",         "",                 ""},
	{T_SCANNER, T_REMOV,
	 "",         "",                 ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C1750A          ", ""},
	{T_PROCESSOR, T_FIXED,
	 "HP      ", "C2500A          ", ""},
};

int
ssmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct scsibus_attach_args *sa = aux;
	int priority;

	(void)scsi_inqmatch(sa->sa_inqbuf,
	    (caddr_t)ss_patterns, sizeof(ss_patterns)/sizeof(ss_patterns[0]),
	    sizeof(ss_patterns[0]), &priority);
	return (priority);
}

/*
 * The routine called by the low level scsi routine when it discovers
 * A device suitable for this driver
 * If it is a know special, call special attach routine to install
 * special handlers into the ss_softc structure
 */
void
ssattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ss_softc *ss = (void *)self;
	struct scsibus_attach_args *sa = aux;
	struct scsi_link *sc_link = sa->sa_sc_link;

	SC_DEBUG(sc_link, SDEV_DB2, ("ssattach: "));

	/*
	 * Store information needed to contact our base driver
	 */
	ss->sc_link = sc_link;
	sc_link->device = &ss_switch;
	sc_link->device_softc = ss;
	sc_link->openings = 1;

	/*
	 * look for non-standard scanners with help of the quirk table
	 * and install functions for special handling
	 */
	SC_DEBUG(sc_link, SDEV_DB2, ("ssattach:\n"));
	if (!bcmp(sa->sa_inqbuf->vendor, "MUSTEK  ", 8))
		mustek_attach(ss, sa);
	if (!bcmp(sa->sa_inqbuf->vendor, "HP      ", 8))
		scanjet_attach(ss, sa);
	if (ss->special == NULL) {
		/* XXX add code to restart a SCSI2 scanner, if any */
	}

	/*
	 * Set up the buf queue for this device
	 */
	ss->buf_queue.b_active = 0;
	ss->buf_queue.b_actf = 0;
	ss->buf_queue.b_actb = &ss->buf_queue.b_actf;
}

/*
 * open the device.
 */
int
ssopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
{
	int unit;
	u_int ssmode;
	int error = 0;
	struct ss_softc *ss;
	struct scsi_link *sc_link;

	unit = SSUNIT(dev);
	if (unit >= sscd.cd_ndevs)
		return (ENXIO);
	ss = sscd.cd_devs[unit];
	if (!ss)
		return (ENXIO);

	ssmode = SSMODE(dev);
	sc_link = ss->sc_link;

	SC_DEBUG(sc_link, SDEV_DB1, ("open: dev=0x%x (unit %d (of %d))\n", dev,
	    unit, sscd.cd_ndevs));

	if (sc_link->flags & SDEV_OPEN) {
		printf("%s: already open\n", ss->sc_dev.dv_xname);
		return (EBUSY);
	}

	/*
	 * Catch any unit attention errors.
	 *
	 * SCSI_IGNORE_MEDIA_CHANGE: when you have an ADF, some scanners
	 * consider paper to be a changeable media
	 *
	 */
	error = scsi_test_unit_ready(sc_link,
	    SCSI_IGNORE_MEDIA_CHANGE | SCSI_IGNORE_ILLEGAL_REQUEST |
	    (ssmode == MODE_CONTROL ? SCSI_IGNORE_NOT_READY : 0));
	if (error)
		goto bad;

	sc_link->flags |= SDEV_OPEN;	/* unit attn are now errors */

	/*
	 * If the mode is 3 (e.g. minor = 3,7,11,15)
	 * then the device has been opened to set defaults
	 * This mode does NOT ALLOW I/O, only ioctls
	 */
	if (ssmode == MODE_CONTROL)
		return (0);

	SC_DEBUG(sc_link, SDEV_DB2, ("open complete\n"));
	return (0);

bad:
	sc_link->flags &= ~SDEV_OPEN;
	return (error);
}

/*
 * close the device.. only called if we are the LAST
 * occurence of an open device
 */
int
ssclose(dev)
	dev_t dev;
{
	struct ss_softc *ss = sscd.cd_devs[SSUNIT(dev)];
	int error;

	SC_DEBUG(ss->sc_link, SDEV_DB1, ("closing\n"));

	if (SSMODE(dev) == MODE_REWIND) {
		if (ss->special->rewind_scanner) {
			/* call special handler to rewind/abort scan */
			error = (ss->special->rewind_scanner)(ss);
			if (error)
				return (error);
		} else {
			/* XXX add code to restart a SCSI2 scanner, if any */
		}
		ss->sio.scan_window_size = 0;
		ss->flags &= ~SSF_TRIGGERED;
	}
	ss->sc_link->flags &= ~SDEV_OPEN;

	return (0);
}

/*
 * trim the size of the transfer if needed,
 * called by physio
 * basically the smaller of our min and the scsi driver's
 * minphys
 */
void
ssminphys(bp)
	struct buf *bp;
{
	register struct ss_softc *ss = sscd.cd_devs[SSUNIT(bp->b_dev)];

	(ss->sc_link->adapter->scsi_minphys)(bp);

	/*
	 * trim the transfer further for special devices this is
	 * because some scanners only read multiples of a line at a
	 * time, also some cannot disconnect, so the read must be
	 * short enough to happen quickly
	 */
	if (ss->special->minphys)
		(ss->special->minphys)(ss, bp);
}

/*
 * Do a read on a device for a user process.
 * Prime scanner at start of read, check uio values, call ssstrategy
 * via physio for the actual transfer.
 */
int
ssread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
{
	struct ss_softc *ss = sscd.cd_devs[SSUNIT(dev)];
	int error;

	/* if the scanner has not yet been started, do it now */
	if (!(ss->flags & SSF_TRIGGERED)) {
		if (ss->special->trigger_scanner) {
			error = (ss->special->trigger_scanner)(ss);
			if (error)
				return (error);
		}
		ss->flags |= SSF_TRIGGERED;
	}

	return (physio(ssstrategy, NULL, dev, B_READ, ssminphys, uio));
}

/*
 * Actually translate the requested transfer into one the physical
 * driver can understand The transfer is described by a buf and will
 * include only one physical transfer.
 */
void
ssstrategy(bp)
	struct buf *bp;
{
	struct ss_softc *ss = sscd.cd_devs[SSUNIT(bp->b_dev)];
	struct buf *dp;
	int s;

	SC_DEBUG(ss->sc_link, SDEV_DB1,
	    ("ssstrategy %d bytes @@ blk %d\n", bp->b_bcount, bp->b_blkno));

	if (bp->b_bcount > ss->sio.scan_window_size)
		bp->b_bcount = ss->sio.scan_window_size;

	/*
	 * If it's a null transfer, return immediatly
	 */
	if (bp->b_bcount == 0)
		goto done;

	s = splbio();

	/*
	 * Place it in the queue of activities for this scanner
	 * at the end (a bit silly because we only have on user..
	 * (but it could fork()))
	 */
	dp = &ss->buf_queue;
	bp->b_actf = NULL;
	bp->b_actb = dp->b_actb;
	*dp->b_actb = bp;
	dp->b_actb = &bp->b_actf;

	/*
	 * Tell the device to get going on the transfer if it's
	 * not doing anything, otherwise just wait for completion
	 * (All a bit silly if we're only allowing 1 open but..)
	 */
	ssstart(ss);

	splx(s);
	return;
bad:
	bp->b_flags |= B_ERROR;
done:
	/*
	 * Correctly set the buf to indicate a completed xfer
	 */
	bp->b_resid = bp->b_bcount;
	biodone(bp);
}

/*
 * ssstart looks to see if there is a buf waiting for the device
 * and that the device is not already busy. If both are true,
 * It dequeues the buf and creates a scsi command to perform the
 * transfer required. The transfer request will call scsi_done
 * on completion, which will in turn call this routine again
 * so that the next queued transfer is performed.
 * The bufs are queued by the strategy routine (ssstrategy)
 *
 * This routine is also called after other non-queued requests
 * have been made of the scsi driver, to ensure that the queue
 * continues to be drained.
 * ssstart() is called at splbio
 */
void
ssstart(v)
	void *v;
{
	struct ss_softc *ss = v;
	struct scsi_link *sc_link = ss->sc_link;
	register struct buf *bp, *dp;

	SC_DEBUG(sc_link, SDEV_DB2, ("ssstart "));
	/*
	 * See if there is a buf to do and we are not already
	 * doing one
	 */
	while (sc_link->openings > 0) {
		/* if a special awaits, let it proceed first */
		if (sc_link->flags & SDEV_WAITING) {
			sc_link->flags &= ~SDEV_WAITING;
			wakeup((caddr_t)sc_link);
			return;
		}

		/*
		 * See if there is a buf with work for us to do..
		 */
		dp = &ss->buf_queue;
		if ((bp = dp->b_actf) == NULL)
			return;
		if ((dp = bp->b_actf) != NULL)
			dp->b_actb = bp->b_actb;
		else
			ss->buf_queue.b_actb = bp->b_actb;
		*bp->b_actb = dp;

		if (ss->special->read) {
			(ss->special->read)(ss, bp);
		} else {
			/* generic scsi2 scanner read */
			/* XXX add code for SCSI2 scanner read */
		}
	}
}

/*
 * Perform special action on behalf of the user;
 * knows about the internals of this device
 */
int
ssioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	struct ss_softc *ss = sscd.cd_devs[SSUNIT(dev)];
	int error = 0;
	int unit;
@


1.2
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ss.c,v 1.7 1996/03/05 00:15:18 thorpej Exp $	*/
d45 1
a45 1
#include <sys/conf.h>		/* for cdevsw */
d70 6
a75 2
struct cfdriver sscd = {
	NULL, "ss", ssmatch, ssattach, DV_DULL, sizeof(struct ss_softc)
d80 1
a157 2

	printf("\n");
d177 1
a177 1
	if (unit >= sscd.cd_ndevs)
d179 1
a179 1
	ss = sscd.cd_devs[unit];
d187 1
a187 1
	    unit, sscd.cd_ndevs));
d230 1
a230 1
ssclose(dev)
d232 3
d236 1
a236 1
	struct ss_softc *ss = sscd.cd_devs[SSUNIT(dev)];
d268 1
a268 1
	register struct ss_softc *ss = sscd.cd_devs[SSUNIT(bp->b_dev)];
d293 1
a293 1
	struct ss_softc *ss = sscd.cd_devs[SSUNIT(dev)];
d318 1
a318 1
	struct ss_softc *ss = sscd.cd_devs[SSUNIT(bp->b_dev)];
a355 1
bad:
d433 1
a433 1
	struct ss_softc *ss = sscd.cd_devs[SSUNIT(dev)];
a434 1
	int unit;
@


1.1
log
@Sync. with NetBSD:
- scsi prototypes.
- Add SCSI scanner support by Kenneth Stailey and Joachim Koenig-Baltes,
  hacked a but.  Needs more work.
ss.c:
- Truncate to the window size in ssminphys(), not ssread().
- Missed some prototyping foo.
- Minor tweak; make sure window size is 0 on close.
- Change variable name to avoid GCC warning.
- Handle EOF a little differently.
@
text
@d1 480
@
