head	1.23;
access;
symbols
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.4
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.2
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.4
	UBC:1.2.0.8
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2005.07.02.04.24.54;	author krw;	state dead;
branches;
next	1.22;

1.22
date	2005.06.27.23.50.43;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2005.06.24.23.39.18;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2005.06.24.21.03.36;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2005.06.23.02.26.35;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2005.06.23.00.31.44;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.22.02.49.36;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.15.03.06.47;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.15.02.46.06;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.03.15.50.10;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.28.06.16.33;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.25.20.52.41;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.24.20.48.43;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.23.07.06.16;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.14.00.20.43;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.07.16.24.46;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.05.12.13.16;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.25.02.18.35;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.24.22.42.07;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.09.04.23.07.28;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.05.18.45.42;	author niklas;	state Exp;
branches
	1.2.8.1;
next	1.1;

1.1
date	99.07.25.07.09.19;	author csapuntz;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.05.14.22.44.59;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.02.19.11.01.31;	author niklas;	state Exp;
branches;
next	;

1.2.8.1
date	2002.06.11.03.32.14;	author art;	state Exp;
branches;
next	1.2.8.2;

1.2.8.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Unused files.
@
text
@/*	$OpenBSD: sd_scsi.c,v 1.22 2005/06/27 23:50:43 krw Exp $	*/
/*	$NetBSD: sd_scsi.c,v 1.8 1998/10/08 20:21:13 thorpej Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Originally written by Julian Elischer (julian@@dialix.oz.au)
 * for TRW Financial Systems for use under the MACH(2.5) operating system.
 *
 * TRW Financial Systems, in accordance with their agreement with Carnegie
 * Mellon University, makes this software available to CMU to distribute
 * or use in any manner that they see fit as long as this message is kept with
 * the software. For this reason TFS also grants any other persons or
 * organisations permission to use or modify this software.
 *
 * TFS supplies this software to be publicly redistributed
 * on the understanding that TFS is not responsible for the correct
 * functioning of this software in any circumstances.
 *
 * Ported to run under 386BSD by Julian Elischer (julian@@dialix.oz.au) Sept 1992
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/conf.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>
#include <scsi/sdvar.h>

int	sd_scsibus_get_parms(struct sd_softc *,
	    struct disk_parms *, int);
void	sd_scsibus_flush(struct sd_softc *, int);

const struct sd_ops sd_scsibus_ops = {
	sd_scsibus_get_parms,
	sd_scsibus_flush,
};

/*
 * Fill out the disk parameter structure. Return SDGP_RESULT_OK if the
 * structure is correctly filled in, SDGP_RESULT_OFFLINE otherwise. The caller
 * is responsible for clearing the SDEV_MEDIA_LOADED flag if the structure
 * cannot be completed.
 */
int
sd_scsibus_get_parms(sd, dp, flags)
	struct sd_softc *sd;
	struct disk_parms *dp;
	int flags;
{
	struct scsi_mode_sense_buf buf;
	union scsi_disk_pages *sense_pages = NULL;
	u_int32_t heads = 0, sectors = 0, cyls = 0, blksize;
	u_int16_t rpm = 0;

	dp->disksize = scsi_size(sd->sc_link, flags, &blksize);

	switch (sd->type) {
	case T_OPTICAL:
		/* No more information needed or available. */
		break;

	case T_RDIRECT:
		/* T_RDIRECT only supports RBC Device Parameter Page (6). */
		scsi_do_mode_sense(sd->sc_link, 6, &buf, (void **)&sense_pages,
		    NULL, NULL, &blksize, sizeof(sense_pages->reduced_geometry),
		    flags | SCSI_SILENT, NULL);
		if (sense_pages) {
			if (dp->disksize == 0)
				dp->disksize = _5btol(sense_pages->
				    reduced_geometry.sectors);
			if (blksize == 0)
				blksize = _2btol(sense_pages->
				    reduced_geometry.bytes_s);
		}
		break;

	default:
		/*
		 * For other devices try mode sense page 4 (RIGID GEOMETRY) and
		 * if that doesn't work try page 5 (FLEX GEOMETRY).
		 */
		scsi_do_mode_sense(sd->sc_link, 4, &buf, (void **)&sense_pages,
		    NULL, NULL, &blksize, sizeof(sense_pages->rigid_geometry),
		    flags | SCSI_SILENT, NULL);
		if (sense_pages) { 
			heads = sense_pages->rigid_geometry.nheads;
			cyls = _3btol(sense_pages->rigid_geometry.ncyl);
			rpm = _2btol(sense_pages->rigid_geometry.rpm);
			if (heads * cyls > 0)
				sectors = dp->disksize / (heads * cyls);
		} else {
			scsi_do_mode_sense(sd->sc_link, 5, &buf,
			    (void **)&sense_pages, NULL, NULL, &blksize,
			    sizeof(sense_pages->flex_geometry),
			    flags | SCSI_SILENT, NULL);
			if (sense_pages) {
				sectors = sense_pages->flex_geometry.ph_sec_tr;
				heads = sense_pages->flex_geometry.nheads;
				cyls = _2btol(sense_pages->flex_geometry.ncyl);
				rpm = _2btol(sense_pages->flex_geometry.rpm);
				if (blksize == 0)
					blksize = _2btol(sense_pages->
					    flex_geometry.bytes_s);
				if (dp->disksize == 0)
					dp->disksize = heads * cyls * sectors;
			}	
		}
		break;
	}

	if (dp->disksize == 0)
		return (SDGP_RESULT_OFFLINE);

	/*
	 * Use Adaptec standard geometry values for anything we still don't
	 * know.
	 */

	dp->heads = (heads == 0) ? 64 : heads;
	dp->blksize = (blksize == 0) ? 512 : blksize;
	dp->sectors = (sectors == 0) ? 32 : sectors;
	dp->rot_rate = (rpm == 0) ? 3600 : rpm;

	/*
	 * XXX THINK ABOUT THIS!!  Using values such that sectors * heads *
	 * cyls is <= disk_size can lead to wasted space. We need a more
	 * careful calculation/validation to make everything work out
	 * optimally.
	 */
	dp->cyls = (cyls == 0) ? dp->disksize / (dp->heads * dp->sectors) :
	    cyls;

	return (SDGP_RESULT_OK);
}

void
sd_scsibus_flush(sd, flags)
	struct sd_softc *sd;
	int flags;
{
	struct scsi_link *sc_link = sd->sc_link;
	struct scsi_synchronize_cache sync_cmd;

	/*
	 * If the device is SCSI-2, issue a SYNCHRONIZE CACHE.
	 * We issue with address 0 length 0, which should be
	 * interpreted by the device as "all remaining blocks
	 * starting at address 0".  We ignore ILLEGAL REQUEST
	 * in the event that the command is not supported by
	 * the device, and poll for completion so that we know
	 * that the cache has actually been flushed.
	 *
	 * Unless, that is, the device can't handle the SYNCHRONIZE CACHE
	 * command, as indicated by our quirks flags.
	 *
	 * XXX What about older devices?
	 */
	if ((sc_link->scsi_version & SID_ANSII) >= 2 &&
	    (sc_link->quirks & SDEV_NOSYNCCACHE) == 0) {
		bzero(&sync_cmd, sizeof(sync_cmd));
		sync_cmd.opcode = SYNCHRONIZE_CACHE;

		if (scsi_scsi_cmd(sc_link,
		    (struct scsi_generic *)&sync_cmd, sizeof(sync_cmd),
		    NULL, 0, SDRETRIES, 100000, NULL,
		    flags|SCSI_IGNORE_ILLEGAL_REQUEST))
			printf("%s: WARNING: cache synchronization failed\n",
			    sd->sc_dev.dv_xname);
		else
			sd->flags |= SDF_FLUSHING;
	}
}
@


1.22
log
@Further cleanup and rationalize sd_scsibus_getparms(). No (intended)
functional change.

ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.21 2005/06/24 23:39:18 krw Exp $	*/
@


1.21
log
@Fix botch introduced in r1.12. reduced_geometry.sectors is a 5 byte
field, with reduced_geometry.sectors[0] not being sectors/track. Add
_5btol() to correctly parse entire field. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.20 2005/06/24 21:03:36 krw Exp $	*/
d96 1
a96 1
	u_int32_t blksize;
a97 1
	int error;
a99 1
	dp->rot_rate = 3600;
d101 10
a110 70
	if (sd->type == T_OPTICAL)
		goto fake_it;

	error = scsi_do_mode_sense(sd->sc_link, 4, &buf,
	    (void **)&sense_pages, NULL, NULL, &blksize,
	    sizeof(sense_pages->rigid_geometry), flags | SCSI_SILENT, NULL);
	if (error == 0) {
		if (sense_pages) { 
			/*
			 * KLUDGE!! (for zone recorded disks)
			 * give a number of sectors so that sec * trks * cyls
			 * is <= disk_size
			 * can lead to wasted space! THINK ABOUT THIS !
			 */
			dp->heads = sense_pages->rigid_geometry.nheads;
			dp->cyls = _3btol(sense_pages->rigid_geometry.ncyl);
			rpm = _2btol(sense_pages->rigid_geometry.rpm);
		}	
		if (rpm)
			dp->rot_rate = rpm;

		dp->blksize = (blksize == 0) ? 512 : blksize;

		if (dp->disksize == 0 || dp->heads == 0 || dp->cyls == 0)
			goto fake_it;

		/* XXX dubious on SCSI */
		dp->sectors = dp->disksize / (dp->heads * dp->cyls);

		return (SDGP_RESULT_OK);
	}

	error = scsi_do_mode_sense(sd->sc_link, 5, &buf,
	    (void **)&sense_pages, NULL, NULL, &blksize,
	    sizeof(sense_pages->flex_geometry), flags | SCSI_SILENT, NULL);
	if (error == 0) {
		if (sense_pages) {
			dp->heads = sense_pages->flex_geometry.nheads;
			dp->cyls = _2btol(sense_pages->flex_geometry.ncyl);
			dp->sectors = sense_pages->flex_geometry.ph_sec_tr;
			if (blksize == 0)
				blksize = _2btol(sense_pages->
				    flex_geometry.bytes_s);
			rpm = _2btol(sense_pages->flex_geometry.rpm);
		}	
		if (rpm)
			dp->rot_rate = rpm;

		dp->blksize = (blksize == 0) ? 512 : blksize;

		if (dp->cyls == 0 || dp->heads == 0 || dp->sectors == 0)
			goto fake_it;

		if (dp->disksize == 0)
			/* XXX Why go on if READ CAPACITY failed? */
			dp->disksize = dp->heads * dp->cyls * dp->sectors;
			
		return (SDGP_RESULT_OK);
	}

	/* T_RDIRECT defines page 6. */
	if (sd->type != T_RDIRECT)
		goto fake_it;

	error = scsi_do_mode_sense(sd->sc_link, 6, &buf,
	    (void **)&sense_pages, NULL, NULL, &blksize,
	    sizeof(sense_pages->reduced_geometry), flags | SCSI_SILENT, NULL);
	if (error == 0) {
		dp->heads = 64;
		dp->sectors = 32;
d119 1
a119 1
		dp->blksize = (blksize == 0) ? 512 : blksize;
d121 32
a152 6
		if (dp->disksize == 0 || dp->sectors == 0)
			goto fake_it;

		dp->cyls = dp->disksize / (dp->heads * dp->sectors);

		return (SDGP_RESULT_OK);
a154 1
fake_it:
d158 4
a161 1
	/* Use adaptec standard fictitious geometry. */
d163 1
a163 3
	dp->heads = 64;
	dp->sectors = 32;
	dp->cyls = dp->disksize / (64 * 32);
d165 11
@


1.20
log
@Eliminate sd_scsibus_get_optparms() as unnecessary, instead getting
the blocksize from scsi_size() at the same time as the capacity is
found.  Use the fake geometry already present in
sd_scsibus_get_parms(), which is identical to the one _optparms used.

Eliminates another old mode sense usage and associated struct.

Only affects T_OPTICAL sd devices, which seem extremely rare.  Similar
to what netbsd does, and freebsd as far as I can make out.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.19 2005/06/23 02:26:35 krw Exp $	*/
d175 2
a176 2
				dp->disksize = _4btol(sense_pages->
				    reduced_geometry.sectors+1);
a179 1
		    	dp->sectors = sense_pages->reduced_geometry.sectors[0];
@


1.19
log
@Reword some comments to better reflect reality. Remove some unhelpful
debugging statements. As a result remove an used variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.18 2005/06/23 00:31:44 krw Exp $	*/
a72 6
struct sd_scsibus_mode_sense_data {
	struct scsi_mode_header header;
	struct scsi_blk_desc blk_desc;
	union scsi_disk_pages pages;
};

a74 2
int	sd_scsibus_get_optparms(struct sd_softc *,
	    struct disk_parms *, int);
a81 39
int
sd_scsibus_get_optparms(sd, dp, flags)
	struct sd_softc *sd;
	struct disk_parms *dp;
	int flags;
{
	struct sd_scsibus_mode_sense_data scsi_sense;
	int error;

	dp->blksize = 512;
	if (dp->disksize == 0)
		return (SDGP_RESULT_OFFLINE);		/* XXX? */

	/* XXX
	 * It is better to get the following params from the
	 * mode sense page 6 only (optical device parameter page).
	 * However, there are stupid optical devices which does NOT
	 * support the page 6. Ask for all (0x3f) pages. Ghaa....
	 */
	error = scsi_mode_sense(sd->sc_link, 0, 0x3f,
	    (struct scsi_mode_header *)&scsi_sense, sizeof(scsi_sense), flags,
	    6000);
	if (error != 0)
		return (SDGP_RESULT_OFFLINE);		/* XXX? */

	dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
	if (dp->blksize == 0) 
		dp->blksize = 512;

	/*
	 * Create a pseudo-geometry.
	 */
	dp->heads = 64;
	dp->sectors = 32;
	dp->cyls = dp->disksize / (dp->heads * dp->sectors);

	return (SDGP_RESULT_OK);
}

d104 1
a104 1
		return (sd_scsibus_get_optparms(sd, dp, flags));
@


1.18
log
@Don't discard the blocksize information provided by the READ CAPACITY
command. Return it in a new parameter to scsi_size.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.17 2005/06/22 02:49:36 krw Exp $	*/
d130 4
a133 2
 * Get the scsi driver to send a full inquiry to the * device and use the
 * results to fill out the disk parameter structure.
d145 1
a145 1
	int page, error;
a149 4
	/*
	 * If offline, the SDEV_MEDIA_LOADED flag will be
	 * cleared by the caller if necessary.
	 */
d153 1
a153 1
	error = scsi_do_mode_sense(sd->sc_link, page = 4, &buf,
a157 8
			SC_DEBUG(sd->sc_link, SDEV_DB3,
			    ("%d cyls, %d heads, %d precomp, %d red_write,"
			     " %d land_zone\n",
			    _3btol(sense_pages->rigid_geometry.ncyl),
			    sense_pages->rigid_geometry.nheads,
			    _2btol(sense_pages->rigid_geometry.st_cyl_wp),
			    _2btol(sense_pages->rigid_geometry.st_cyl_rwc),
			    _2btol(sense_pages->rigid_geometry.land_zone)));
d182 1
a182 1
	error = scsi_do_mode_sense(sd->sc_link, page = 5, &buf,
d214 1
a214 1
	error = scsi_do_mode_sense(sd->sc_link, page = 6, &buf,
a241 2
	SC_DEBUG(sd->sc_link, SDEV_DB1, ("error %d on pg %d, fake geometry.\n",
	    error, page));
@


1.17
log
@Get rpm from filled in structure, not unused one. Remove now
unreferenced variable. Fixes rpm value for FLEX GEOMETRY devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.16 2005/06/15 03:06:47 krw Exp $	*/
d145 1
a145 1
	dp->disksize = scsi_size(sd->sc_link, flags);
@


1.16
log
@Use scsi_size() as preferred disk size in all cases. Allow devices
using FLEX GEOMETRY mode sense page to use the existing heads *
sectors * cyls calculation if scsi_size() fails.

Fixes jolan@@'s iPod Shuffle, and presumably other devices lying or
confused about their geometry and it's relation to the number of
blocks.

Also save any supplied rpm and blocksize when faking, as previous
code tried to do.

ok jolan@@ fgsch@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.15 2005/06/15 02:46:06 krw Exp $	*/
a138 1
	struct sd_scsibus_mode_sense_data scsi_sense;
d203 1
a203 1
			rpm = _2btol(scsi_sense.pages.flex_geometry.rpm);
@


1.15
log
@Typo. 'dp->cyls' -> 'dp->sectors'.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.14 2005/06/03 15:50:10 krw Exp $	*/
a99 1
	dp->disksize = scsi_size(sd->sc_link, flags);
d146 1
d179 4
a182 1
		dp->disksize = scsi_size(sd->sc_link, flags);
a189 5
		if (rpm)
			dp->rot_rate = rpm;

		dp->blksize = (blksize == 0) ? 512 : blksize;

d201 3
a203 2
			dp->blksize =
			    _2btol(sense_pages->flex_geometry.bytes_s);
d206 5
d214 3
a216 1
		dp->disksize = dp->heads * dp->cyls * dp->sectors;
a217 8
		if (rpm)
			dp->rot_rate = rpm;

		if (blksize)
			dp->blksize = blksize;
		else if (dp->blksize == 0)
			dp->blksize = 512;

d232 6
a237 4
			dp->disksize =
			    _4btol(sense_pages->reduced_geometry.sectors+1);
			dp->blksize =
			    _2btol(sense_pages->reduced_geometry.bytes_s);
d240 2
a246 6
		if (blksize)
			dp->blksize = blksize;

		if (dp->blksize == 0)
			dp->blksize = 512;

a250 2
	/* If we can get the disk size, fake a geometry. */
	dp->disksize = scsi_size(sd->sc_link, flags);
d261 1
a261 1
	dp->blksize = 512;
@


1.14
log
@Tweak scsi_do_mode_sense(). NetBSD was right and I was wrong. Sigh.
Add 'big' parameter to report which mode sense header type is being
returned. Eliminate icky pointer arithmetic, since it won't work if
only block descriptors are returned by the device.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.13 2005/05/28 06:16:33 krw Exp $	*/
d207 1
a207 1
		if (dp->cyls == 0 || dp->heads == 0 || dp->cyls == 0)
@


1.13
log
@Add _lto8b() and _8btol() to decode nblocks field of
scsi_mode_blk_desc_big. Will be needed to move st to new mode sense
function.

Be a bit more careful with types of parameters to scsi_do_mode_sense,
using u_int32_t instead of int.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.12 2005/05/25 20:52:41 krw Exp $	*/
d158 1
a158 1
	    sizeof(sense_pages->rigid_geometry), flags | SCSI_SILENT);
d197 1
a197 1
	    sizeof(sense_pages->flex_geometry), flags | SCSI_SILENT);
d229 1
a229 1
	    sizeof(sense_pages->reduced_geometry), flags | SCSI_SILENT);
@


1.12
log
@Introduce safer, more general mode sense capability. Transparently use
both 10 byte and 6 byte MODE SENSE commands and just return error
checked values.

Convert sd_scsi.c to use new mechanism for non-optical drives. USB
umass devices will now display actual mode sense info if it is
available via a 10 byte MODE SENSE. Which may mean 0 heads, etc. is
shown until cosmetics are finalized.

ok marco@@ 'that is pretty cool' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.11 2005/05/24 20:48:43 krw Exp $	*/
d143 1
d145 1
a145 1
	int page, error, blksize;
@


1.11
log
@When processing the flex_geometry page, don't use a reduced_geometry
field to get the blocksize.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.10 2005/05/23 07:06:16 krw Exp $	*/
d141 4
a144 3
	union scsi_disk_pages *sense_pages;
	u_int16_t rpm;
	int page, error;
d155 3
a157 3
	error = scsi_mode_sense(sd->sc_link, 0, page = 4,
	    (struct scsi_mode_header *)&scsi_sense, sizeof(scsi_sense),
	    flags | SCSI_SILENT, 6000);
d159 20
a178 27
		sense_pages = (union scsi_disk_pages *)
		    ((char *)&scsi_sense.blk_desc +
		     (size_t)scsi_sense.header.blk_desc_len);
		SC_DEBUG(sd->sc_link, SDEV_DB3,
		    ("%d cyls, %d heads, %d precomp, %d red_write,"
		     " %d land_zone\n",
		    _3btol(sense_pages->rigid_geometry.ncyl),
		    sense_pages->rigid_geometry.nheads,
		    _2btol(sense_pages->rigid_geometry.st_cyl_wp),
		    _2btol(sense_pages->rigid_geometry.st_cyl_rwc),
		    _2btol(sense_pages->rigid_geometry.land_zone)));

		/*
		 * KLUDGE!! (for zone recorded disks)
		 * give a number of sectors so that sec * trks * cyls
		 * is <= disk_size
		 * can lead to wasted space! THINK ABOUT THIS !
		 */
		dp->heads = sense_pages->rigid_geometry.nheads;
		dp->cyls = _3btol(sense_pages->rigid_geometry.ncyl);
		rpm = _2btol(scsi_sense.pages.rigid_geometry.rpm);
		if (rpm)
			dp->rot_rate = rpm;
		if (scsi_sense.header.blk_desc_len >= 8)
			dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
		else
			dp->blksize = 0;
d180 1
a180 1
		if (dp->heads == 0 || dp->cyls == 0)
d183 2
a184 2
		if (dp->blksize == 0)
			dp->blksize = 512;
d186 2
a187 3
		dp->disksize = scsi_size(sd->sc_link, flags);
		if (dp->disksize == 0)
			return (SDGP_RESULT_OFFLINE);
d189 1
a189 2
		/* XXX dubious on SCSI */
		dp->sectors = dp->disksize / (dp->heads * dp->cyls);
d194 3
a196 3
	error = scsi_mode_sense(sd->sc_link, 0, page = 5,
	    (struct scsi_mode_header *)&scsi_sense, sizeof(scsi_sense),
	    flags | SCSI_SILENT, 6000);
d198 4
a201 11
		sense_pages = (union scsi_disk_pages *)
		    ((char *)&scsi_sense.blk_desc +
		     (size_t)scsi_sense.header.blk_desc_len);
		dp->heads = sense_pages->flex_geometry.nheads;
		dp->cyls = _2btol(sense_pages->flex_geometry.ncyl);
		rpm = _2btol(scsi_sense.pages.flex_geometry.rpm);
		if (rpm)
			dp->rot_rate = rpm;
		if (scsi_sense.header.blk_desc_len >= 8)
			dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
		else
d204 5
a208 1
		dp->sectors = sense_pages->flex_geometry.ph_sec_tr;
d210 7
a216 3
		if (dp->disksize == 0)
			goto fake_it;
		if (dp->blksize == 0)
d218 1
d222 7
a228 4
	/* T_RDIRECT define page 6. */
	error = scsi_mode_sense(sd->sc_link, 0, page = 6,
	    (struct scsi_mode_header *)&scsi_sense, sizeof(scsi_sense),
	    flags | SCSI_SILENT, 6000);
a229 3
		sense_pages = (union scsi_disk_pages *)
		    ((char *)&scsi_sense.blk_desc +
		     (size_t)scsi_sense.header.blk_desc_len);
d232 3
a234 6
		dp->disksize =
		    _4btol(sense_pages->reduced_geometry.sectors+1);
		dp->cyls = dp->disksize / (64 * 32);
		if (scsi_sense.header.blk_desc_len >= 8)
			dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
		else
d237 4
d242 4
a245 3
		if (dp->disksize == 0 ||
		    sense_pages->reduced_geometry.sectors[0] != 0)
			goto fake_it;
@


1.10
log
@Don't bzero() data before calling scsi_mode_sense[_big]() since
scsi_mode_sense[_big] bzero()'s it.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.9 2005/05/14 00:20:43 krw Exp $	*/
d218 1
a218 1
			    _2btol(sense_pages->reduced_geometry.bytes_s);
@


1.9
log
@Add scsi_mode_[sense|select]_big() and use it instead of
atapi_mode_[sense|select](). This will allow the removal of
atapi_base.c and atapi_all.h files, and sets the stage for better usb
mode sense handling amoung other things.

Remove cd_scsibus_[get|set]_mode() and
sd_scsibus_mode_sense() shims in favour of scsi_mode_[sense|select]().
Add zero'ing of reserved length field in scsi_mode_select(). Change
some uchar * type parameters to scsi_mode_header *.

No functional changes. Mostly from NetBSD.

ok dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.8 2005/05/07 16:24:46 krw Exp $	*/
a109 1
	bzero(&scsi_sense, sizeof(scsi_sense));
a153 1
	bzero(&scsi_sense, sizeof(scsi_sense));
a201 1
	bzero(&scsi_sense, sizeof(scsi_sense));
a228 1
	bzero(&scsi_sense, sizeof(scsi_sense));
@


1.8
log
@Eliminate 'mode sense (n) returned nonsense' and 'could not mode sense
(4/5)' messages in favour of a single SC_DEBUG() message about the mode
sense error. Less useless verbiage.

As this eliminates the only SDEV_NOMODESENSE use in scsi/*, eliminate
all quirks table entries that used only SDEV_NOMODESENSE. Iomega Zip
tested by miod@@ to ensure this did not break something.

Finally, only fake a geometry if scsi_size() can determine a disk size
to fake from.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.7 2005/04/05 12:13:16 krw Exp $	*/
a78 2
int	sd_scsibus_mode_sense(struct sd_softc *,
	    struct sd_scsibus_mode_sense_data *, int, int);
a90 10
sd_scsibus_mode_sense(sd, scsi_sense, page, flags)
	struct sd_softc *sd;
	struct sd_scsibus_mode_sense_data *scsi_sense;
	int page, flags;
{
	return scsi_mode_sense(sd->sc_link, 0, page, (u_char *)scsi_sense,
	    sizeof(*scsi_sense), flags | SCSI_SILENT, 6000);
}

int
d110 4
a113 2
	error = scsi_mode_sense(sd->sc_link, 0, 0x3f, (u_char *)&scsi_sense,
	    sizeof(scsi_sense), flags, 6000);
d155 5
a159 2
	if ((error = sd_scsibus_mode_sense(sd, &scsi_sense, page = 4,
	    flags)) == 0) {
d204 5
a208 2
	if ((error = sd_scsibus_mode_sense(sd, &scsi_sense, page = 5,
	    flags)) == 0) {
d232 5
a236 2
	if ((error = sd_scsibus_mode_sense(sd, &scsi_sense, page = 6,
	    flags)) == 0) {
@


1.7
log
@Factor out scsi_mode_sense() and scsi_mode_select() like NetBSD does.
Eliminate some duplicate structures and defines along the way. SCSI CD
drives will now pay attention to the 'flags' parameter for MODE SENSE
and MODE SELECT commands. No other functional change.

ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.6 2003/06/25 02:18:35 krw Exp $	*/
d263 1
a263 14
	if ((sd->sc_link->quirks & SDEV_NOMODESENSE) == 0) {
		if (error == 0)
			printf("%s: mode sense (%d) returned nonsense",
			    sd->sc_dev.dv_xname, page);
		else
			printf("%s: could not mode sense (4/5)",
			    sd->sc_dev.dv_xname);
		printf("; using fictitious geometry\n");
	}
	/*
	 * use adaptec standard fictitious geometry
	 * this depends on which controller (e.g. 1542C is
	 * different. but we have to put SOMETHING here..)
	 */
d265 7
a275 3

	if (dp->disksize == 0)
		return (SDGP_RESULT_OFFLINE);
@


1.6
log
@Avoid a divide by zero by

1) Ensuring that both sd_scsi.c and sd_atapi.c report a device as
offline when its disksize cannot be determined.

2) Ensuring blksize is always non-zero, with a default value of 512.

3) Eliminating a couple of unneeded 'sectors' variables, which makes
the code easier for me to read if nothing else.

The bug was introduced when sd_atapi.c was changed to allow
'incomplete' implementations to be reported as online. REALLY
incomplete implementations (i.e. not even the disksize can be
determined) would be reported online with a blksize of zero.

Also fix a couple of knf nits in Mickey's last commit, and add another
check for an rpm of 0.

ok (pre-Mickey diffs) tdeval@@ marc@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.5 2003/06/24 22:42:07 mickey Exp $	*/
d98 2
a99 21
	struct scsi_mode_sense scsi_cmd;

	/*
	 * Make sure the sense buffer is clean before we do
	 * the mode sense, so that checks for bogus values of
	 * 0 will work in case the mode sense fails.
	 */
	bzero(scsi_sense, sizeof(*scsi_sense));

	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MODE_SENSE;
	scsi_cmd.page = page;
	scsi_cmd.length = sizeof(*scsi_sense);
	/*
	 * If the command worked, use the results to fill out
	 * the parameter structure
	 */
	return (scsi_scsi_cmd(sd->sc_link,
	    (struct scsi_generic *)&scsi_cmd, sizeof(scsi_cmd),
	    (u_char *)scsi_sense, sizeof(*scsi_sense),
	    SDRETRIES, 6000, NULL, flags | SCSI_DATA_IN | SCSI_SILENT));
a107 1
	struct scsi_mode_sense scsi_cmd;
d120 1
a120 1
	 * support the page 6. Ghaa....
d122 3
a124 10
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MODE_SENSE;
	scsi_cmd.page = 0x3f;	/* all pages */
	scsi_cmd.length = sizeof(struct scsi_mode_header) +
	    sizeof(struct scsi_blk_desc);

	if ((error = scsi_scsi_cmd(sd->sc_link,  
	    (struct scsi_generic *)&scsi_cmd, sizeof(scsi_cmd),  
	    (u_char *)&scsi_sense, sizeof(scsi_sense), SDRETRIES,
	    6000, NULL, flags | SCSI_DATA_IN)) != 0)
@


1.5
log
@try to devise drive's rpm and default to 3600 should we fail miserably.
derived from pr2815 from Marco Peereboom
krw@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.4 2002/09/04 23:07:28 tdeval Exp $	*/
a128 1
	u_long sectors;
d132 2
a133 1
	if ((sectors = scsi_size(sd->sc_link, flags)) == 0)
d163 1
a163 2
	dp->cyls = sectors / (dp->heads * dp->sectors);
	dp->disksize = sectors;
d180 1
a180 1
	u_long sectors;
a181 1
	u_int16_t rpm;
d228 6
a233 4
		sectors = scsi_size(sd->sc_link, flags);
		dp->disksize = sectors;
		sectors /= (dp->heads * dp->cyls);
		dp->sectors = sectors;	/* XXX dubious on SCSI */
d245 1
a245 1
		rpm  = _2btol(scsi_sense.pages.flex_geometry.rpm);
a256 1

a258 1

d304 1
a304 1
	sectors = scsi_size(sd->sc_link, flags);
d307 1
a307 1
	dp->cyls = sectors / (64 * 32);
d309 3
a311 1
	dp->disksize = sectors;
@


1.4
log
@Add support for RBC (simplified direct) devices.
ok costa@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.3 2002/03/14 01:27:13 millert Exp $	*/
d110 1
a110 1
	scsi_cmd.length = 0x20;
d182 2
a183 2
	int page;
	int error;
d185 1
a185 1
	dp->rot_rate = 3600;		/* XXX any way of getting this? */
d216 3
d245 3
d312 1
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.2 2000/08/05 18:45:42 niklas Exp $	*/
d180 1
d196 3
d200 7
a206 6
		    ("%d cyls, %d heads, %d precomp, %d red_write, %d land_zone\n",
		    _3btol(scsi_sense.pages.rigid_geometry.ncyl),
		    scsi_sense.pages.rigid_geometry.nheads,
		    _2btol(scsi_sense.pages.rigid_geometry.st_cyl_wp),
		    _2btol(scsi_sense.pages.rigid_geometry.st_cyl_rwc),
		    _2btol(scsi_sense.pages.rigid_geometry.land_zone)));
d214 6
a219 3
		dp->heads = scsi_sense.pages.rigid_geometry.nheads;
		dp->cyls = _3btol(scsi_sense.pages.rigid_geometry.ncyl);
		dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
d237 11
a247 4
		dp->heads = scsi_sense.pages.flex_geometry.nheads;
		dp->cyls = _2btol(scsi_sense.pages.flex_geometry.ncyl);
		dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
		dp->sectors = scsi_sense.pages.flex_geometry.ph_sec_tr;
d250 27
@


1.2
log
@remove statics
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.1 1999/07/25 07:09:19 csapuntz Exp $	*/
d79 7
a85 7
int	sd_scsibus_mode_sense __P((struct sd_softc *,
	    struct sd_scsibus_mode_sense_data *, int, int));
int	sd_scsibus_get_parms __P((struct sd_softc *,
	    struct disk_parms *, int));
int	sd_scsibus_get_optparms __P((struct sd_softc *,
	    struct disk_parms *, int));
void	sd_scsibus_flush __P((struct sd_softc *, int));
@


1.2.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.2 2000/08/05 18:45:42 niklas Exp $	*/
d79 7
a85 7
int	sd_scsibus_mode_sense(struct sd_softc *,
	    struct sd_scsibus_mode_sense_data *, int, int);
int	sd_scsibus_get_parms(struct sd_softc *,
	    struct disk_parms *, int);
int	sd_scsibus_get_optparms(struct sd_softc *,
	    struct disk_parms *, int);
void	sd_scsibus_flush(struct sd_softc *, int);
@


1.2.8.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.2.8.1 2002/06/11 03:32:14 art Exp $	*/
a179 1
	union scsi_disk_pages *sense_pages;
a194 3
		sense_pages = (union scsi_disk_pages *)
		    ((char *)&scsi_sense.blk_desc +
		     (size_t)scsi_sense.header.blk_desc_len);
d196 6
a201 7
		    ("%d cyls, %d heads, %d precomp, %d red_write,"
		     " %d land_zone\n",
		    _3btol(sense_pages->rigid_geometry.ncyl),
		    sense_pages->rigid_geometry.nheads,
		    _2btol(sense_pages->rigid_geometry.st_cyl_wp),
		    _2btol(sense_pages->rigid_geometry.st_cyl_rwc),
		    _2btol(sense_pages->rigid_geometry.land_zone)));
d209 3
a211 6
		dp->heads = sense_pages->rigid_geometry.nheads;
		dp->cyls = _3btol(sense_pages->rigid_geometry.ncyl);
		if (scsi_sense.header.blk_desc_len >= 8)
			dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
		else
			dp->blksize = 0;
d229 4
a232 11
		sense_pages = (union scsi_disk_pages *)
		    ((char *)&scsi_sense.blk_desc +
		     (size_t)scsi_sense.header.blk_desc_len);
		dp->heads = sense_pages->flex_geometry.nheads;
		dp->cyls = _2btol(sense_pages->flex_geometry.ncyl);
		if (scsi_sense.header.blk_desc_len >= 8)
			dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
		else
			dp->blksize =
			    _2btol(sense_pages->reduced_geometry.bytes_s);
		dp->sectors = sense_pages->flex_geometry.ph_sec_tr;
a234 27
			goto fake_it;

		if (dp->blksize == 0)
			dp->blksize = 512;

		return (SDGP_RESULT_OK);
	}

	/* T_RDIRECT define page 6. */
	if ((error = sd_scsibus_mode_sense(sd, &scsi_sense, page = 6,
	    flags)) == 0) {
		sense_pages = (union scsi_disk_pages *)
		    ((char *)&scsi_sense.blk_desc +
		     (size_t)scsi_sense.header.blk_desc_len);
		dp->heads = 64;
		dp->sectors = 32;
		dp->disksize =
		    _4btol(sense_pages->reduced_geometry.sectors+1);
		dp->cyls = dp->disksize / (64 * 32);
		if (scsi_sense.header.blk_desc_len >= 8)
			dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
		else
			dp->blksize =
			    _2btol(sense_pages->reduced_geometry.bytes_s);

		if (dp->disksize == 0 ||
		    sense_pages->reduced_geometry.sectors[0] != 0)
@


1.1
log
@

Merge sd stuff from NetBSD-current. Helps with LS-120, ZIP

More SCSI logic from NetBSD-current

Some tape fixes. ATAPI tapes do not work yet for most operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.8 1998/10/08 20:21:13 thorpej Exp $	*/
d79 7
a85 7
static int	sd_scsibus_mode_sense __P((struct sd_softc *,
		    struct sd_scsibus_mode_sense_data *, int, int));
static int	sd_scsibus_get_parms __P((struct sd_softc *,
		    struct disk_parms *, int));
static int	sd_scsibus_get_optparms __P((struct sd_softc *,
		    struct disk_parms *, int));
static void	sd_scsibus_flush __P((struct sd_softc *, int));
d92 1
a92 1
static int
d121 1
a121 1
static int
d173 1
a173 1
static int
d267 1
a267 1
static void
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_scsi.c,v 1.2 2000/08/05 18:45:42 niklas Exp $	*/
d79 7
a85 7
int	sd_scsibus_mode_sense __P((struct sd_softc *,
	    struct sd_scsibus_mode_sense_data *, int, int));
int	sd_scsibus_get_parms __P((struct sd_softc *,
	    struct disk_parms *, int));
int	sd_scsibus_get_optparms __P((struct sd_softc *,
	    struct disk_parms *, int));
void	sd_scsibus_flush __P((struct sd_softc *, int));
d92 1
a92 1
int
d121 1
a121 1
int
d173 1
a173 1
int
d267 1
a267 1
void
@


1.1.4.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 7
a85 7
int	sd_scsibus_mode_sense(struct sd_softc *,
	    struct sd_scsibus_mode_sense_data *, int, int);
int	sd_scsibus_get_parms(struct sd_softc *,
	    struct disk_parms *, int);
int	sd_scsibus_get_optparms(struct sd_softc *,
	    struct disk_parms *, int);
void	sd_scsibus_flush(struct sd_softc *, int);
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@a179 1
	union scsi_disk_pages *sense_pages;
a194 3
		sense_pages = (union scsi_disk_pages *)
		    ((char *)&scsi_sense.blk_desc +
		     (size_t)scsi_sense.header.blk_desc_len);
d196 6
a201 7
		    ("%d cyls, %d heads, %d precomp, %d red_write,"
		     " %d land_zone\n",
		    _3btol(sense_pages->rigid_geometry.ncyl),
		    sense_pages->rigid_geometry.nheads,
		    _2btol(sense_pages->rigid_geometry.st_cyl_wp),
		    _2btol(sense_pages->rigid_geometry.st_cyl_rwc),
		    _2btol(sense_pages->rigid_geometry.land_zone)));
d209 3
a211 6
		dp->heads = sense_pages->rigid_geometry.nheads;
		dp->cyls = _3btol(sense_pages->rigid_geometry.ncyl);
		if (scsi_sense.header.blk_desc_len >= 8)
			dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
		else
			dp->blksize = 0;
d229 4
a232 11
		sense_pages = (union scsi_disk_pages *)
		    ((char *)&scsi_sense.blk_desc +
		     (size_t)scsi_sense.header.blk_desc_len);
		dp->heads = sense_pages->flex_geometry.nheads;
		dp->cyls = _2btol(sense_pages->flex_geometry.ncyl);
		if (scsi_sense.header.blk_desc_len >= 8)
			dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
		else
			dp->blksize =
			    _2btol(sense_pages->reduced_geometry.bytes_s);
		dp->sectors = sense_pages->flex_geometry.ph_sec_tr;
a234 27
			goto fake_it;

		if (dp->blksize == 0)
			dp->blksize = 512;

		return (SDGP_RESULT_OK);
	}

	/* T_RDIRECT define page 6. */
	if ((error = sd_scsibus_mode_sense(sd, &scsi_sense, page = 6,
	    flags)) == 0) {
		sense_pages = (union scsi_disk_pages *)
		    ((char *)&scsi_sense.blk_desc +
		     (size_t)scsi_sense.header.blk_desc_len);
		dp->heads = 64;
		dp->sectors = 32;
		dp->disksize =
		    _4btol(sense_pages->reduced_geometry.sectors+1);
		dp->cyls = dp->disksize / (64 * 32);
		if (scsi_sense.header.blk_desc_len >= 8)
			dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
		else
			dp->blksize =
			    _2btol(sense_pages->reduced_geometry.bytes_s);

		if (dp->disksize == 0 ||
		    sense_pages->reduced_geometry.sectors[0] != 0)
@


1.1.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d110 1
a110 1
	scsi_cmd.length = sizeof(*scsi_sense);
d129 1
d133 1
a133 2
	dp->disksize = scsi_size(sd->sc_link, flags);
	if (dp->disksize == 0)
d163 2
a164 1
	dp->cyls = dp->disksize / (dp->heads * dp->sectors);
d181 3
a183 2
	u_int16_t rpm;
	int page, error;
d185 1
a185 1
	dp->rot_rate = 3600;
a215 3
		rpm = _2btol(scsi_sense.pages.rigid_geometry.rpm);
		if (rpm)
			dp->rot_rate = rpm;
d227 4
a230 6
		dp->disksize = scsi_size(sd->sc_link, flags);
		if (dp->disksize == 0)
			return (SDGP_RESULT_OFFLINE);

		/* XXX dubious on SCSI */
		dp->sectors = dp->disksize / (dp->heads * dp->cyls);
a241 3
		rpm = _2btol(scsi_sense.pages.flex_geometry.rpm);
		if (rpm)
			dp->rot_rate = rpm;
d251 1
d254 1
d300 1
a300 1
	dp->disksize = scsi_size(sd->sc_link, flags);
d303 1
a303 1
	dp->cyls = dp->disksize / (64 * 32);
d305 1
a305 4

	if (dp->disksize == 0)
		return (SDGP_RESULT_OFFLINE);

@


