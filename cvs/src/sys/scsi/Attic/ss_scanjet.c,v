head	1.45;
access;
symbols
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.33.0.8
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.4
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.26.0.4
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.25.0.6
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.24.0.6
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.4
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.24
	UBC:1.23.0.4
	UBC_BASE:1.23
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.21.0.12
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.21.0.10
	OPENBSD_2_7_BASE:1.21
	SMP:1.21.0.8
	SMP_BASE:1.21
	kame_19991208:1.21
	OPENBSD_2_6:1.21.0.6
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.21.0.4
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.20.0.4
	OPENBSD_2_3_BASE:1.20
	OPENBSD_2_2:1.20.0.2
	OPENBSD_2_2_BASE:1.20
	OPENBSD_2_1:1.19.0.2
	OPENBSD_2_1_BASE:1.19
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.45
date	2010.07.08.00.42.39;	author krw;	state dead;
branches;
next	1.44;

1.44
date	2010.07.01.05.11.18;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.01.03.01.37;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.30.00.02.00;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.26.23.24.45;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.11.12.02.44;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.01.15.27.16;	author thib;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.12.09.51.48;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.15.05.50.31;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2010.01.15.05.31.38;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.13.01.51.20;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.02.23.28.51;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.22.16.32.05;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.16.01.30.24;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.01.20.59.04;	author moritz;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.17.20.22.38;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.15.13.49.03;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.28.04.16.14;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.06.23.16.51;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.22.14.35.43;	author deraadt;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2001.03.25.04.23.46;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	98.09.16.15.53.24;	author kstailey;	state Exp;
branches
	1.21.8.1;
next	1.20;

1.20
date	97.08.02.21.35.33;	author kstailey;	state Exp;
branches;
next	1.19;

1.19
date	97.05.05.13.14.18;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	97.03.11.12.06.49;	author kstailey;	state Exp;
branches;
next	1.17;

1.17
date	97.03.11.03.40.50;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.03.10.02.29.40;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.03.06.12.44.42;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	96.12.08.14.25.50;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	96.11.23.06.05.02;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	96.11.23.05.55.58;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	96.11.06.09.36.48;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.11.03.19.09.46;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	96.10.31.02.49.45;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.10.31.01.14.13;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.07.30.11.04.10;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.22.11.58.41;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.10.12.31.41;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.09.34.34;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.31.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.16.10.24;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.02.20.02.28.55;	author briggs;	state Exp;
branches;
next	;

1.21.8.1
date	2001.05.14.22.45.00;	author niklas;	state Exp;
branches;
next	1.21.8.2;

1.21.8.2
date	2001.07.04.11.00.09;	author niklas;	state Exp;
branches;
next	1.21.8.3;

1.21.8.3
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.21.8.4;

1.21.8.4
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	;

1.23.4.1
date	2002.06.11.03.32.14;	author art;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2003.05.19.22.28.21;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Move ss and friends to the attic.

Enthusiastic huzzahs from many.

"A great day" dlg@@
@
text
@/*	$OpenBSD: ss_scanjet.c,v 1.44 2010/07/01 05:11:18 krw Exp $	*/
/*	$NetBSD: ss_scanjet.c,v 1.6 1996/05/18 22:58:01 christos Exp $	*/

/*
 * Copyright (c) 1995 Kenneth Stailey.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Kenneth Stailey.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * special functions for the HP ScanJet IIc and IIcx
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/fcntl.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/device.h>
#include <sys/conf.h>		/* for cdevsw */
#include <sys/scanio.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_scanner.h>
#include <scsi/scsiconf.h>
#include <scsi/ssvar.h>

int scanjet_set_params(struct ss_softc *, struct scan_io *);
int scanjet_trigger_scanner(struct ss_softc *);
int scanjet_read(struct ss_softc *, struct scsi_xfer *, struct buf *);
void scanjet_read_done(struct scsi_xfer *);

/* only used internally */
int scanjet_ctl_write(struct ss_softc *, char *, u_int, int);
int scanjet_ctl_read(struct ss_softc *, char *, u_int, int);
int scanjet_set_window(struct ss_softc *, int);
int scanjet_compute_sizes(struct ss_softc *, int);
/* Maybe move to libkern? */
#define atoi local_atoi
__inline static int atoi(const char *);


/*
 * structure for the special handlers
 */
struct ss_special scanjet_special = {
	scanjet_set_params,
	scanjet_trigger_scanner,
	NULL,
	NULL,			/* no special minphys */
	scanjet_read,		/* scsi 6-byte read */
	NULL,			/* no "rewind" code (yet?) */
	NULL,			/* no adf support right now */
	NULL			/* no adf support right now */
};

/*
 * scanjet_attach: attach special functions to ss
 */
void
scanjet_attach(ss, sa)
	struct ss_softc *ss;
	struct scsi_attach_args *sa;
{
#ifdef SCSIDEBUG
	struct scsi_link *sc_link = sa->sa_sc_link;
#endif
	int error;

	SC_DEBUG(sc_link, SDEV_DB1, ("scanjet_attach: start\n"));
	ss->sio.scan_scanner_type = 0;

	printf("\n%s: ", ss->sc_dev.dv_xname);

	/* first, check the model (which determines nothing yet) */

	if (!bcmp(sa->sa_inqbuf->product, "C1750A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet IIc");
	}
	/* The IIp is a grayscale-only HP SCL scanner */
	if (!bcmp(sa->sa_inqbuf->product, "C1790A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet IIp");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C2500A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet IIcx");
	}
	/* The 3p is a grayscale-only HP SCL scanner */
	if (!bcmp(sa->sa_inqbuf->product, "C2570A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 3p");
	}
	/* The 3c/4c/6100C report as the same? */
	if (!bcmp(sa->sa_inqbuf->product, "C2520A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 3c/4c/6100C");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C1130A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 4p");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C5110A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 5p");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C6290A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 4100C");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C5190A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 5100C");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C7190A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 5200C");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C6270A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 6200C");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C7670A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 6300C");
	}

	SC_DEBUG(sc_link, SDEV_DB1, ("scanjet_attach: scanner_type = %d\n",
	    ss->sio.scan_scanner_type));

	/* now install special handlers */
	ss->special = scanjet_special;

	/*
	 * fill in the rest of the scan_io struct by calling
	 * set_window and compute_sizes routines
	 */
	error = scanjet_set_window(ss, SCSI_POLL);
	if (error) {
		printf(" set_window failed\n");
		return;
	}

	error = scanjet_compute_sizes(ss, SCSI_POLL);
	if (error) {
		printf(" compute_sizes failed\n");
		return;
	}

	printf("\n");
}

/*
 * check the parameters if the scanjet is capable of fulfilling it
 * but don't send the command to the scanner in case the user wants
 * to change parameters by more than one call
 */
int
scanjet_set_params(ss, sio)
	struct ss_softc *ss;
	struct scan_io *sio;
{
	int error;

#if 0
	/*
	 * if the scanner is triggered, then rewind it
	 */
	if (ss->flags & SSF_TRIGGERED) {
		error = scanjet_rewind_scanner(ss);
		if (error)
			return (error);
	}
#endif

	/* size constraints... */
	if (sio->scan_width == 0				 ||
	    sio->scan_x_origin + sio->scan_width > 10200 || /* 8.5" */
	    sio->scan_height == 0				 ||
	    sio->scan_y_origin + sio->scan_height > 16800)  /* 14" */
		return (EINVAL);

	/* resolution (dpi)... */
	if (sio->scan_x_resolution < 100 ||
	    sio->scan_x_resolution > 400 ||
	    sio->scan_y_resolution < 100 ||
	    sio->scan_y_resolution > 400)
		return (EINVAL);

	switch (sio->scan_image_mode) {
	case SIM_BINARY_MONOCHROME:
	case SIM_DITHERED_MONOCHROME:
	case SIM_GRAYSCALE:
	case SIM_COLOR:
		break;
	default:
		return (EINVAL);
	}

	/* change ss_softc to the new values, but save ro-variables */
	sio->scan_scanner_type = ss->sio.scan_scanner_type;
	bcopy(sio, &ss->sio, sizeof(struct scan_io));

	error = scanjet_set_window(ss, 0);
	if (error) {
		uprintf("%s: set_window failed\n", ss->sc_dev.dv_xname);
		return (error);
	}
	error = scanjet_compute_sizes(ss, 0);
	if (error) {
		uprintf("%s: compute_sizes failed\n", ss->sc_dev.dv_xname);
		return (error);
	}

	return (0);
}

/*
 * trigger the scanner to start a scan operation
 * this includes sending the mode- and window-data,
 * and starting the scanner
 */
int
scanjet_trigger_scanner(ss)
	struct ss_softc *ss;
{
	static char *escape_codes = "\033*f0S";
	int error;

	error = scanjet_set_window(ss, 0);
	if (error) {
		uprintf("%s: set_window failed\n", ss->sc_dev.dv_xname);
		return (error);
	}
	error = scanjet_compute_sizes(ss, 0);
	if (error) {
		uprintf("%s: compute_sizes failed\n", ss->sc_dev.dv_xname);
		return (error);
	}

	/* send "trigger" operation */
	error = scanjet_ctl_write(ss, escape_codes, strlen(escape_codes), 0);
	if (error) {
		uprintf("%s: trigger_scanner failed\n", ss->sc_dev.dv_xname);
		return (error);
	}

	return (0);
}

int
scanjet_read(ss, xs, bp)
	struct ss_softc *ss;
	struct scsi_xfer *xs;
	struct buf *bp;
{
	struct scsi_rw_scanner *cdb;

	SC_DEBUG(ss->sc_link, SDEV_DB1, ("scanjet_read: start\n"));

	cdb = (struct scsi_rw_scanner *)xs->cmd;
	xs->cmdlen = sizeof(*cdb);

	cdb->opcode = READ;
	_lto3b(bp->b_bcount, cdb->len);

	xs->data = bp->b_data;
	xs->datalen = bp->b_bcount;
	xs->flags |= SCSI_DATA_IN;
	xs->timeout = 100000;
	xs->done = scanjet_read_done;
	xs->cookie = bp;
	xs->bp = bp;

	scsi_xs_exec(xs);

	return (0);
}

void
scanjet_read_done(struct scsi_xfer *xs)
{
	struct ss_softc *ss = xs->sc_link->device_softc;
	struct buf *bp = xs->cookie;
	int error, s;

	switch (xs->error) {
	case XS_NOERROR:
		if (bp->b_bcount >= ss->sio.scan_window_size)
			ss->sio.scan_window_size = 0;
		else
			ss->sio.scan_window_size -= bp->b_bcount;

		bp->b_error = 0;
		bp->b_resid = xs->resid;
		break;

	case XS_NO_CCB:
		/* The adapter is busy, requeue the buf and try it later. */
		BUFQ_REQUEUE(ss->sc_bufq, bp);
                scsi_xs_put(xs);
		SET(ss->flags, SSF_WAITING);
		timeout_add(&ss->timeout, 1);
		return;

	case XS_SENSE:
	case XS_SHORTSENSE:
#ifdef SCSIDEBUG
		scsi_sense_print_debug(xs);
#endif
		error = scsi_interpret_sense(xs);
		if (error == 0) {
			if (bp->b_bcount >= ss->sio.scan_window_size)
				ss->sio.scan_window_size = 0;
			else
				ss->sio.scan_window_size -= bp->b_bcount;
			bp->b_error = 0;
			bp->b_resid = xs->resid;
			break;
		}
		if (error != ERESTART)
			xs->retries = 0;
		goto retry;

	case XS_BUSY:
		if (xs->retries) {
			if (scsi_delay(xs, 1) != ERESTART)
				xs->retries = 0;
		}
		goto retry;

	case XS_TIMEOUT:
retry:
		if (xs->retries--) {
			scsi_xs_exec(xs);
			return;
		}
		/* FALLTHROUGH */

	default:
		bp->b_error = EIO;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		break;
	}

	s = splbio();
	biodone(bp);
	splx(s);
	scsi_xs_put(xs);
}

/*
 * Do a synchronous write.  Used to send control messages.
 */
int
scanjet_ctl_write(ss, buf, size, flags)
	struct ss_softc *ss;
	char *buf;
	u_int size;
	int flags;
{
	struct scsi_rw_scanner cmd;

	bzero(&cmd, sizeof(cmd));
	cmd.opcode = WRITE;
	_lto3b(size, cmd.len);
	return (scsi_scsi_cmd(ss->sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), (u_char *) buf, size, 0, 100000, NULL,
	    flags | SCSI_DATA_OUT));
}


/*
 * Do a synchronous read.  Used to read responses to control messages.
 */
int
scanjet_ctl_read(ss, buf, size, flags)
	struct ss_softc *ss;
	char *buf;
	u_int size;
	int flags;
{
	struct scsi_rw_scanner cmd;

	bzero(&cmd, sizeof(cmd));
	cmd.opcode = READ;
	_lto3b(size, cmd.len);
	return (scsi_scsi_cmd(ss->sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), (u_char *) buf, size, 0, 100000, NULL,
	    flags | SCSI_DATA_IN));
}


#ifdef SCANJETDEBUG
static void show_es(char *es)
{
	char *p = es;

	while (*p) {
		if (*p == '\033')
			printf("[Esc]");
		else
			printf("%c", *p);
		++p;
	}
	printf("\n");
}
#endif

/*
 * simulate SCSI_SET_WINDOW for ScanJets
 */
int
scanjet_set_window(ss, flags)
	struct ss_softc *ss;
	int flags;
{
	char escape_codes[128];
	size_t len;
	int n;

	snprintf(escape_codes, sizeof escape_codes,
	    "\033*f%ldP\033*f%ldQ\033*f%ldX\033*f%ldY\033*a%dR\033*a%dS",
	    ss->sio.scan_width / 4,
	    ss->sio.scan_height / 4,
	    ss->sio.scan_x_origin / 4,
	    ss->sio.scan_y_origin / 4,
	    ss->sio.scan_x_resolution,
	    ss->sio.scan_y_resolution);

	switch (ss->sio.scan_image_mode) {
	case SIM_BINARY_MONOCHROME:
		ss->sio.scan_bits_per_pixel = 1;
		/*
		 * Use line art mode (\033*aoT) and make image data be
		 * min-is-white ala PBM (\033*a0I).
		 */
		strlcat(escape_codes, "\033*a0T\033*a0I", sizeof escape_codes);
		break;
	case SIM_DITHERED_MONOCHROME:
		ss->sio.scan_bits_per_pixel = 1;
		/* 
		 * Use dithered mode (\033*a3T) and make image data be
		 * min-is-white ala PBM (\033*a0I).
		 */
		strlcat(escape_codes, "\033*a3T\033*a0I", sizeof escape_codes);
		break;
	case SIM_GRAYSCALE:
		ss->sio.scan_bits_per_pixel = 8;
		/*
		 * Use grayscale mode (\033*a4T) and make image data be
		 * min-is-black ala PGM (\033*a1I)
		 */
		strlcat(escape_codes, "\033*a4T\033*a1I", sizeof escape_codes);
		break;
	case SIM_COLOR:
		ss->sio.scan_bits_per_pixel = 24;
		/*
		 * Use RGB color mode (\033*a5T), make image data be
		 * min-is-black ala PPM (\033*a1I) and use pass-through matrix,
		 * i.e. disable NTSC (\033*u2T).
		 */
		strlcat(escape_codes, "\033*a5T\033*a1I\033*u2T",
		    sizeof escape_codes);
		break;
	}

	/*
	 * If the escape sequence has been truncated at this point, appending
	 * the next sequence will also cause truncation, and this time we pay
	 * attention.
	 */
	len = strlen(escape_codes);
	n = snprintf(escape_codes + len, sizeof escape_codes - len,
	    "\033*a%dG\033*a%dL\033*a%dK",
	    ss->sio.scan_bits_per_pixel,
	    (int)(ss->sio.scan_brightness) - 128,
	    (int)(ss->sio.scan_contrast) - 128);

	if (n >= sizeof escape_codes - len)
		return (ENOMEM);
	len += n;

	return (scanjet_ctl_write(ss, escape_codes, len, flags));
}

/* atoi() is from /sys/arch/amiga/dev/ite.c
   and is only used in scanjet_compute_sizes */

__inline static int
atoi(cp)
	const char *cp;
{
	int n;

	for (n = 0; *cp && *cp >= '0' && *cp <= '9'; cp++)
		n = n * 10 + *cp - '0';

	return (n);
}

int
scanjet_compute_sizes(ss, flags)
	struct ss_softc *ss;
	int flags;
{
	int error;
	static char *wfail = "%s: interrogate write failed\n";
	static char *rfail = "%s: interrogate read failed\n";
	static char *dfail = "%s: bad data returned\n";
	static char *mono  = "\033*s1025E"; /* bytes wide  */
	static char *color = "\033*s1024E"; /* pixels wide */
	static char *high  = "\033*s1026E"; /* pixels high */
	char response[20];
	char *p;

	/*
	 * Deal with the fact that the HP ScanJet IIc uses 1/300" not 1/1200"
	 * as its base unit of measurement.  PINT uses 1/1200" (yes I know
	 * ScanJet II's use decipoints as well but 1200 % 720 != 0)
	 */
	ss->sio.scan_width = (ss->sio.scan_width + 3) & 0xfffffffc;
	ss->sio.scan_height = (ss->sio.scan_height + 3) & 0xfffffffc;

	switch (ss->sio.scan_image_mode) {
	case SIM_BINARY_MONOCHROME:
	case SIM_DITHERED_MONOCHROME:
		error = scanjet_ctl_write(ss, mono, strlen(mono), flags);
		break;
	case SIM_GRAYSCALE:
	case SIM_COLOR:
		error = scanjet_ctl_write(ss, color, strlen(color), flags);
		break;
	default:
		error = EIO;
		break;
	}
	if (error) {
		uprintf(wfail, ss->sc_dev.dv_xname);
		return (error);
	}
	error = scanjet_ctl_read(ss, response, 20, flags);
	if (error) {
		uprintf(rfail, ss->sc_dev.dv_xname);
		return (error);
	}
	p = strchr(response, 'd');
	if (p == NULL) {
		uprintf(dfail, ss->sc_dev.dv_xname);
		return (EIO);
	}
	ss->sio.scan_pixels_per_line = atoi(p + 1);
	if (ss->sio.scan_image_mode < SIM_GRAYSCALE)
		ss->sio.scan_pixels_per_line *= 8;

	error = scanjet_ctl_write(ss, high, strlen(high), flags);
	if (error) {
		uprintf(wfail, ss->sc_dev.dv_xname);
		return (error);
	}
	error = scanjet_ctl_read(ss, response, 20, flags);
	if (error) {
		uprintf(rfail, ss->sc_dev.dv_xname);
		return (error);
	}
	p = strchr(response, 'd');
	if (p == NULL) {
		uprintf(dfail, ss->sc_dev.dv_xname);
		return (EIO);
	}
	ss->sio.scan_lines = atoi(p + 1);

	ss->sio.scan_window_size = ss->sio.scan_lines *
	    ((ss->sio.scan_pixels_per_line * ss->sio.scan_bits_per_pixel) / 8);

	return (0);
}
@


1.44
log
@Die struct scsi_device! Die! Instead, save a pointer to the routine
to interpret sense errors. This is initialized to the basic
interpretation routine, and specific scsi drivers (sd/st/cd) can
replace this with their own. While here kill EJUSTRETURN dance and
make more specialized interpretation routines directly call the
basic routine if desired.

Fixes by matthew@@ to my first diff. Most original work by dlg@@.

ok matthew@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.43 2010/07/01 03:01:37 matthew Exp $	*/
@


1.43
log
@Restore setting xs->bp; fixes ncr(4) on VAX.

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.42 2010/06/30 00:02:00 dlg Exp $	*/
d335 3
@


1.42
log
@switch ss over to using xshandlers for queuing io. this brings it into line
with sd/cd/st.

largely a mechanical change, untested due to a complete lack of hardware
anywhere.

ok krw@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.41 2010/06/26 23:24:45 guenther Exp $	*/
d300 1
@


1.41
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.40 2010/06/11 12:02:44 krw Exp $	*/
d328 1
a328 1
		SET(ss->flags, SSF_WAITING); /* break out of cdstart loop */
@


1.40
log
@Restore an unusual XS_SENSE semantic that inadvertantly got lost
in the great re-write. If the scsi device *_interpret_sense()
function returns 0 that means there was no error.

Fixes restore(8) problems seen on certain tape drives.

Found and fix tested by Percey Piper. Suggestions from Matthew
Dempsky. Thanks!

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.39 2010/06/01 15:27:16 thib Exp $	*/
a44 1
#include <sys/user.h>
@


1.39
log
@move cd, st & ss over to bufq's again.

Tested by myself and krw.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.38 2010/04/12 09:51:48 dlg Exp $	*/
d312 1
a312 1
	int s;
d335 11
a345 1
		if (scsi_interpret_sense(xs) != ERESTART)
@


1.38
log
@i snuck fine grained locking into the midlayer as part of all the
other stuff ive been doing in here. everything that needs protection
inside the midlayer and the scsi device drivers (sd, cd, etc) uses
mutexes now.

this pushes splbio out of the midlayer. splbio is only taken before
biodone is called now.

ok beck@@ marco@@ krw@@ deraadt@@. theyre all terrified, but they all
say if we're going to do then now is the right stage of the dev
cycle.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.37 2010/01/15 05:50:31 krw Exp $	*/
d327 1
a327 1
		scsi_buf_requeue(&ss->sc_buf_queue, bp, &ss->sc_buf_mtx);
@


1.37
log
@Abstract and merge the manual buf queue manipulating functions into
one place for easier debugging and maintenance. No intended functional
changes.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.36 2010/01/15 05:31:38 krw Exp $	*/
d312 1
a312 2

	splassert(IPL_BIO);
d361 1
d363 1
@


1.36
log
@Restore XS_BUSY delay behaviour for buf i/o. Same as for sync path.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.35 2010/01/13 01:51:20 krw Exp $	*/
d328 1
a328 1
                ss_buf_requeue(ss, bp);
@


1.35
log
@Fix SCSIDEBUG compiles.

Pointed out and original diff by jcs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.34 2010/01/02 23:28:51 dlg Exp $	*/
d338 1
a339 1
		/* FALLTHROUGH */
d341 6
d348 1
d353 1
a354 1
		/* FALLTHROUGH */
@


1.34
log
@move the buf handling from using scsi_scsi_cmd over to scsi_xs_exec. i
think this is the last chunk of code using a buf pointer in the scsi_xfer
now.

this has not been tested due to a lack of hardware anywhere. if there are
problems please report them as soon as possible.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.33 2008/06/22 16:32:05 krw Exp $	*/
d287 1
a287 1
	SC_DEBUG(sc_link, SDEV_DB1, ("scanjet_read: start\n"));
@


1.33
log
@Replace MUSTEK_RETRIES, SCANJET_RETRIES and ST_RETRIES with SCSI_RETRIES,
all defined to 4. Replace some magic number 4's with SCSI_RETRIES. Fix a
few lines that were now too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.32 2007/09/16 01:30:24 krw Exp $	*/
d57 2
a58 1
int scanjet_read(struct ss_softc *, struct buf *);
d280 1
a280 1
scanjet_read(ss, bp)
d282 1
d285 1
a285 2
	struct scsi_rw_scanner cmd;
	struct scsi_link *sc_link = ss->sc_link;
d287 25
a311 5
	/*
	 *  Fill out the scsi command
	 */
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = READ;
d313 1
a313 5
	/*
	 * Handle "fixed-block-mode" tape drives by using the
	 * block count instead of the length.
	 */
	_lto3b(bp->b_bcount, cmd.len);
d315 2
a316 8
	/*
	 * go ask the adapter to do all this for us
	 */
	if (scsi_scsi_cmd(sc_link, (struct scsi_generic *) &cmd, sizeof(cmd),
	    (u_char *) bp->b_data, bp->b_bcount, SCSI_RETRIES, 100000, bp,
	    SCSI_NOSLEEP | SCSI_DATA_IN) != SUCCESSFULLY_QUEUED)
		printf("%s: not queued\n", ss->sc_dev.dv_xname);
	else {
d321 32
d355 2
a356 1
	return (0);
a357 1

@


1.32
log
@MALLOC/FREE -> malloc/free, M_ZERO, extraneous casts,
extraneous #include <malloc.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.31 2007/06/01 20:59:04 moritz Exp $	*/
a54 2
#define SCANJET_RETRIES 4

d302 1
a302 1
	    (u_char *) bp->b_data, bp->b_bcount, SCANJET_RETRIES, 100000, bp,
@


1.31
log
@Fix snprintf(9) truncation check and skip the check for -1 because
only the libc snprintf(3) could return this.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.30 2006/11/28 16:56:50 dlg Exp $	*/
a42 1
#include <sys/malloc.h>
@


1.30
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.29 2006/05/11 00:45:59 krw Exp $	*/
d447 1
a447 1
	if (n >= sizeof escape_codes || n == -1)
@


1.29
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.28 2006/01/17 20:22:38 miod Exp $	*/
d92 1
a92 1
	struct scsibus_attach_args *sa;
@


1.28
log
@Use strchr() from libkern instead of rolling our own.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.27 2005/12/15 13:49:03 krw Exp $	*/
d164 1
a164 1
	/* 
d277 1
a277 1
	
d322 1
a322 1
int 
d377 1
a377 1
/* 
d401 1
a401 1
		/* 
d403 1
a403 1
		 * min-is-white ala PBM (\033*a0I).		
d417 1
a417 1
		/* 
d439 1
a439 1
	 */ 
@


1.27
log
@A sanity check for an unsigned variable being < 0 after a subtraction
is not useful. Check the value about to be subtracted.

Spotted by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.26 2004/12/28 04:16:14 deraadt Exp $	*/
a68 1
#define strchr local_strchr
a69 1
__inline static char *strchr(/* const */ char *, char);
d454 2
a455 2
/* atoi() and strchr() are from /sys/arch/amiga/dev/ite.c
   and are only used in scanjet_compute_sizes */
a466 13
}

__inline static char *
strchr(cp, ch)
	/*
	 * The const was removed to make -Wcast-qual happy.  I
	 * don't particularily like this solution but what to do?
	 */
	/* const */ char *cp;
	char ch;
{
	while (*cp && *cp != ch) cp++;
	return (*cp ? (char *)cp : 0);
@


1.26
log
@correct snprintf return val mishandling; ok krw marco
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.25 2003/05/06 23:16:51 krw Exp $	*/
d311 1
a311 2
		ss->sio.scan_window_size -= bp->b_bcount;
		if (ss->sio.scan_window_size < 0)
d313 2
@


1.25
log
@String fixes. Scsi now strcpy/strcat/sprintf/strncat free. Some
strncpy still present for manipulating d_packname/d_typename.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.24 2002/03/14 01:27:13 millert Exp $	*/
d386 1
d388 1
a388 1
	char escape_codes[128];
d442 1
a442 1
	len += snprintf(escape_codes + len, sizeof escape_codes - len,
d448 1
a448 1
	if (len >= sizeof escape_codes)
d450 1
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.23 2001/06/22 14:35:43 deraadt Exp $	*/
d259 1
a259 1
	char escape_codes[20];
a273 1
	strcpy(escape_codes, "\033*f0S");
d386 2
a387 1
	char escape_codes[128], *p;
d389 8
a396 8
	p = escape_codes;

	p += sprintf(p, "\033*f%ldP", ss->sio.scan_width / 4);
	p += sprintf(p, "\033*f%ldQ", ss->sio.scan_height / 4);
	p += sprintf(p, "\033*f%ldX", ss->sio.scan_x_origin / 4);
	p += sprintf(p, "\033*f%ldY", ss->sio.scan_y_origin / 4);
	p += sprintf(p, "\033*a%dR", ss->sio.scan_x_resolution);
	p += sprintf(p, "\033*a%dS", ss->sio.scan_y_resolution);
d401 5
a405 6
		/* use "line art" mode */
		strcpy(p, "\033*a0T");
		p += strlen(p);
		/* make image data be "min-is-white ala PBM */
		strcpy(p, "\033*a0I");
		p += strlen(p);
d409 5
a413 6
		/* use dithered mode */
		strcpy(p, "\033*a3T");
		p += strlen(p);
		/* make image data be "min-is-white ala PBM */
		strcpy(p, "\033*a0I");
		p += strlen(p);
d417 5
a421 6
		/* use grayscale mode */
		strcpy(p, "\033*a4T");
		p += strlen(p);
		/* make image data be "min-is-black ala PGM */
		strcpy(p, "\033*a1I");
		p += strlen(p);
d425 7
a431 9
		/* use RGB color mode */
		strcpy(p, "\033*a5T");
		p += strlen(p);
		/* make image data be "min-is-black ala PPM */
		strcpy(p, "\033*a1I");
		p += strlen(p);
		/* use pass-through matrix (disable NTSC) */
		strcpy(p, "\033*u2T");
		p += strlen(p);
d435 14
a448 3
	p += sprintf(p, "\033*a%dG", ss->sio.scan_bits_per_pixel);
	p += sprintf(p, "\033*a%dL", (int)(ss->sio.scan_brightness) - 128);
	p += sprintf(p, "\033*a%dK", (int)(ss->sio.scan_contrast) - 128);
d450 1
a450 1
	return (scanjet_ctl_write(ss, escape_codes, p - escape_codes, flags));
d490 3
a492 1
	char escape_codes[20];
d507 1
a507 1
		strcpy(escape_codes, "\033*s1025E"); /* bytes wide */
d511 4
a514 1
		strcpy(escape_codes, "\033*s1024E"); /* pixels wide */
a516 2
	error = scanjet_ctl_write(ss, escape_codes, strlen(escape_codes),
		flags);
d527 1
a527 1
	if (p == 0) {
d535 1
a535 3
	strcpy(escape_codes, "\033*s1026E"); /* pixels high */
	error = scanjet_ctl_write(ss, escape_codes, strlen(escape_codes),
		flags);
d546 1
a546 1
	if (p == 0) {
@


1.23
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.22 2001/03/25 04:23:46 fgsch Exp $	*/
d58 3
a60 3
int scanjet_set_params __P((struct ss_softc *, struct scan_io *));
int scanjet_trigger_scanner __P((struct ss_softc *));
int scanjet_read __P((struct ss_softc *, struct buf *));
d63 4
a66 4
int scanjet_ctl_write __P((struct ss_softc *, char *, u_int, int));
int scanjet_ctl_read __P((struct ss_softc *, char *, u_int, int));
int scanjet_set_window __P((struct ss_softc *, int));
int scanjet_compute_sizes __P((struct ss_softc *, int));
d70 2
a71 2
__inline static int atoi __P((const char *));
__inline static char *strchr __P((/* const */ char *, char));
@


1.23.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.23 2001/06/22 14:35:43 deraadt Exp $	*/
d58 3
a60 3
int scanjet_set_params(struct ss_softc *, struct scan_io *);
int scanjet_trigger_scanner(struct ss_softc *);
int scanjet_read(struct ss_softc *, struct buf *);
d63 4
a66 4
int scanjet_ctl_write(struct ss_softc *, char *, u_int, int);
int scanjet_ctl_read(struct ss_softc *, char *, u_int, int);
int scanjet_set_window(struct ss_softc *, int);
int scanjet_compute_sizes(struct ss_softc *, int);
d70 2
a71 2
__inline static int atoi(const char *);
__inline static char *strchr(/* const */ char *, char);
@


1.23.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d259 1
a259 1
	static char *escape_codes = "\033*f0S";
d274 1
d387 1
a387 2
	size_t len;
	char escape_codes[128];
d389 8
a396 8
	snprintf(escape_codes, sizeof escape_codes,
	    "\033*f%ldP\033*f%ldQ\033*f%ldX\033*f%ldY\033*a%dR\033*a%dS",
	    ss->sio.scan_width / 4,
	    ss->sio.scan_height / 4,
	    ss->sio.scan_x_origin / 4,
	    ss->sio.scan_y_origin / 4,
	    ss->sio.scan_x_resolution,
	    ss->sio.scan_y_resolution);
d401 6
a406 5
		/* 
		 * Use line art mode (\033*aoT) and make image data be
		 * min-is-white ala PBM (\033*a0I).		
		 */
		strlcat(escape_codes, "\033*a0T\033*a0I", sizeof escape_codes);
d410 6
a415 5
		/* 
		 * Use dithered mode (\033*a3T) and make image data be
		 * min-is-white ala PBM (\033*a0I).
		 */
		strlcat(escape_codes, "\033*a3T\033*a0I", sizeof escape_codes);
d419 6
a424 5
		/* 
		 * Use grayscale mode (\033*a4T) and make image data be
		 * min-is-black ala PGM (\033*a1I)
		 */
		strlcat(escape_codes, "\033*a4T\033*a1I", sizeof escape_codes);
d428 9
a436 7
		/*
		 * Use RGB color mode (\033*a5T), make image data be
		 * min-is-black ala PPM (\033*a1I) and use pass-through matrix,
		 * i.e. disable NTSC (\033*u2T).
		 */
		strlcat(escape_codes, "\033*a5T\033*a1I\033*u2T",
		    sizeof escape_codes);
d440 3
a442 14
	/*
	 * If the escape sequence has been truncated at this point, appending
	 * the next sequence will also cause truncation, and this time we pay
	 * attention.
	 */ 
	len = strlen(escape_codes);
	len += snprintf(escape_codes + len, sizeof escape_codes - len,
	    "\033*a%dG\033*a%dL\033*a%dK",
	    ss->sio.scan_bits_per_pixel,
	    (int)(ss->sio.scan_brightness) - 128,
	    (int)(ss->sio.scan_contrast) - 128);

	if (len >= sizeof escape_codes)
		return (ENOMEM);
d444 1
a444 1
	return (scanjet_ctl_write(ss, escape_codes, len, flags));
d484 1
a484 3
	static char *mono  = "\033*s1025E"; /* bytes wide  */
	static char *color = "\033*s1024E"; /* pixels wide */
	static char *high  = "\033*s1026E"; /* pixels high */
d499 1
a499 1
		error = scanjet_ctl_write(ss, mono, strlen(mono), flags);
d503 1
a503 4
		error = scanjet_ctl_write(ss, color, strlen(color), flags);
		break;
	default:
		error = EIO;
d506 2
d518 1
a518 1
	if (p == NULL) {
d526 3
a528 1
	error = scanjet_ctl_write(ss, high, strlen(high), flags);
d539 1
a539 1
	if (p == NULL) {
@


1.22
log
@Support for several HP scanners; from jmartin@@ugrad.cs.ualberta.ca, krw@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.21 1998/09/16 15:53:24 kstailey Exp $	*/
d366 10
a375 9
  char *p = es;
  while (*p) {
    if (*p == '\033')
      printf("[Esc]");
    else
      printf("%c", *p);
    ++p;
  }
  printf("\n");
d397 1
a397 1
     
@


1.21
log
@add support for HP ScanJet IIp
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.20 1997/08/02 21:35:33 kstailey Exp $	*/
d121 10
d138 20
@


1.21.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.22 2001/03/25 04:23:46 fgsch Exp $	*/
a120 10
	/* The 3p is a grayscale-only HP SCL scanner */
	if (!bcmp(sa->sa_inqbuf->product, "C2570A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 3p");
	}
	/* The 3c/4c/6100C report as the same? */
	if (!bcmp(sa->sa_inqbuf->product, "C2520A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 3c/4c/6100C");
	}
a127 20
	}
	if (!bcmp(sa->sa_inqbuf->product, "C6290A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 4100C");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C5190A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 5100C");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C7190A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 5200C");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C6270A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 6200C");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C7670A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 6300C");
@


1.21.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.21.8.1 2001/05/14 22:45:00 niklas Exp $	*/
d366 9
a374 10
	char *p = es;

	while (*p) {
		if (*p == '\033')
			printf("[Esc]");
		else
			printf("%c", *p);
		++p;
	}
	printf("\n");
d396 1
a396 1

@


1.21.8.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 3
a60 3
int scanjet_set_params(struct ss_softc *, struct scan_io *);
int scanjet_trigger_scanner(struct ss_softc *);
int scanjet_read(struct ss_softc *, struct buf *);
d63 4
a66 4
int scanjet_ctl_write(struct ss_softc *, char *, u_int, int);
int scanjet_ctl_read(struct ss_softc *, char *, u_int, int);
int scanjet_set_window(struct ss_softc *, int);
int scanjet_compute_sizes(struct ss_softc *, int);
d70 2
a71 2
__inline static int atoi(const char *);
__inline static char *strchr(/* const */ char *, char);
@


1.21.8.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.21.8.3 2002/03/28 14:52:01 niklas Exp $	*/
d259 1
a259 1
	static char *escape_codes = "\033*f0S";
d274 1
d387 1
a387 2
	size_t len;
	char escape_codes[128];
d389 8
a396 8
	snprintf(escape_codes, sizeof escape_codes,
	    "\033*f%ldP\033*f%ldQ\033*f%ldX\033*f%ldY\033*a%dR\033*a%dS",
	    ss->sio.scan_width / 4,
	    ss->sio.scan_height / 4,
	    ss->sio.scan_x_origin / 4,
	    ss->sio.scan_y_origin / 4,
	    ss->sio.scan_x_resolution,
	    ss->sio.scan_y_resolution);
d401 6
a406 5
		/* 
		 * Use line art mode (\033*aoT) and make image data be
		 * min-is-white ala PBM (\033*a0I).		
		 */
		strlcat(escape_codes, "\033*a0T\033*a0I", sizeof escape_codes);
d410 6
a415 5
		/* 
		 * Use dithered mode (\033*a3T) and make image data be
		 * min-is-white ala PBM (\033*a0I).
		 */
		strlcat(escape_codes, "\033*a3T\033*a0I", sizeof escape_codes);
d419 6
a424 5
		/* 
		 * Use grayscale mode (\033*a4T) and make image data be
		 * min-is-black ala PGM (\033*a1I)
		 */
		strlcat(escape_codes, "\033*a4T\033*a1I", sizeof escape_codes);
d428 9
a436 7
		/*
		 * Use RGB color mode (\033*a5T), make image data be
		 * min-is-black ala PPM (\033*a1I) and use pass-through matrix,
		 * i.e. disable NTSC (\033*u2T).
		 */
		strlcat(escape_codes, "\033*a5T\033*a1I\033*u2T",
		    sizeof escape_codes);
d440 3
a442 14
	/*
	 * If the escape sequence has been truncated at this point, appending
	 * the next sequence will also cause truncation, and this time we pay
	 * attention.
	 */ 
	len = strlen(escape_codes);
	len += snprintf(escape_codes + len, sizeof escape_codes - len,
	    "\033*a%dG\033*a%dL\033*a%dK",
	    ss->sio.scan_bits_per_pixel,
	    (int)(ss->sio.scan_brightness) - 128,
	    (int)(ss->sio.scan_contrast) - 128);

	if (len >= sizeof escape_codes)
		return (ENOMEM);
d444 1
a444 1
	return (scanjet_ctl_write(ss, escape_codes, len, flags));
d484 1
a484 3
	static char *mono  = "\033*s1025E"; /* bytes wide  */
	static char *color = "\033*s1024E"; /* pixels wide */
	static char *high  = "\033*s1026E"; /* pixels high */
d499 1
a499 1
		error = scanjet_ctl_write(ss, mono, strlen(mono), flags);
d503 1
a503 4
		error = scanjet_ctl_write(ss, color, strlen(color), flags);
		break;
	default:
		error = EIO;
d506 2
d518 1
a518 1
	if (p == NULL) {
d526 3
a528 1
	error = scanjet_ctl_write(ss, high, strlen(high), flags);
d539 1
a539 1
	if (p == NULL) {
@


1.20
log
@add ScanJet 5p, untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.19 1997/05/05 13:14:18 niklas Exp $	*/
d111 5
@


1.19
log
@#define away local versions of atoi & strchr to prevent potential
name clashes with libkern versions
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.18 1997/03/11 12:06:49 kstailey Exp $	*/
d119 4
@


1.18
log
@adjust comments
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.17 1997/03/11 03:40:50 kstailey Exp $	*/
d68 2
@


1.17
log
@move init. code to m.i. section
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.16 1997/03/10 02:29:40 kstailey Exp $	*/
d125 5
a129 2
	error = scanjet_set_window(ss, SCSI_POLL);/* XXX needed? */

d134 1
@


1.16
log
@do GET_BUFFER_STATUS in special minphys
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.15 1997/03/06 12:44:42 kstailey Exp $	*/
d125 1
a125 13
	/*
	 * populate the scanio struct with legal values
	 */
	ss->sio.scan_width		= 1200;
	ss->sio.scan_height		= 1200;
	ss->sio.scan_x_resolution	= 100;
	ss->sio.scan_y_resolution	= 100;
	ss->sio.scan_x_origin		= 0;
	ss->sio.scan_y_origin		= 0;
	ss->sio.scan_brightness		= 128;
	ss->sio.scan_contrast		= 128;
	ss->sio.scan_quality		= 100;
	ss->sio.scan_image_mode		= SIM_GRAYSCALE;
a126 1
	error = scanjet_set_window(ss, SCSI_POLL);
@


1.15
log
@remove stub get_params functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.14 1996/12/08 14:25:50 niklas Exp $	*/
d123 1
a123 1
	ss->special = &scanjet_special;
@


1.14
log
@-Wcast-qual happiness
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.13 1996/11/23 06:05:02 kstailey Exp $	*/
a57 1
int scanjet_get_params __P((struct ss_softc *));
d78 1
a78 1
	scanjet_get_params,
a150 8
}

int
scanjet_get_params(ss)
	struct ss_softc *ss;
{

	return (0);
@


1.13
log
@deleted unnecessary calls to strlen()
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.12 1996/11/23 05:55:58 kstailey Exp $	*/
d70 1
a70 1
__inline static char *strchr __P((const char *, char));
d440 5
a444 1
	const char *cp;
@


1.12
log
@deleted redundant section
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.11 1996/11/06 09:36:48 niklas Exp $	*/
d367 6
a372 12
	sprintf(p, "\033*f%ldP", ss->sio.scan_width / 4);
	p += strlen(p);
	sprintf(p, "\033*f%ldQ", ss->sio.scan_height / 4);
	p += strlen(p);
	sprintf(p, "\033*f%ldX", ss->sio.scan_x_origin / 4);
	p += strlen(p);
	sprintf(p, "\033*f%ldY", ss->sio.scan_y_origin / 4);
	p += strlen(p);
	sprintf(p, "\033*a%dR", ss->sio.scan_x_resolution);
	p += strlen(p);
	sprintf(p, "\033*a%dS", ss->sio.scan_y_resolution);
	p += strlen(p);
d416 3
a418 6
	sprintf(p, "\033*a%dG", ss->sio.scan_bits_per_pixel);
	p += strlen(p);
	sprintf(p, "\033*a%dL", (int)(ss->sio.scan_brightness) - 128);
	p += strlen(p);
	sprintf(p, "\033*a%dK", (int)(ss->sio.scan_contrast) - 128);
	p += strlen(p);
@


1.11
log
@Slight oversight in Ken's latest fix
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.10 1996/11/03 19:09:46 kstailey Exp $	*/
a113 4
	}
	if (!bcmp(sa->sa_inqbuf->product, "C1130A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf("HP ScanJet 4p");
@


1.10
log
@make SCSI_POLL only be set when scanjet_ctl_{read|write} is called from scanjet_attach()
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.9 1996/10/31 02:49:45 deraadt Exp $	*/
d518 1
a518 1
	error = scanjet_ctl_read(ss, response, 20, 0);
@


1.9
log
@hp scanjet 4p support; kstailey@@dol-esa.gov
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.8 1996/10/31 01:14:13 niklas Exp $	*/
d66 2
a67 2
int scanjet_set_window __P((struct ss_softc *));
int scanjet_compute_sizes __P((struct ss_softc *));
d144 1
a144 1
	error = scanjet_set_window(ss);
d149 1
a149 1
	error = scanjet_compute_sizes(ss);
d217 1
a217 1
	error = scanjet_set_window(ss);
d222 1
a222 1
	error = scanjet_compute_sizes(ss);
d243 1
a243 1
	error = scanjet_set_window(ss);
d248 1
a248 1
	error = scanjet_compute_sizes(ss);
d319 1
a319 1
	    flags | SCSI_DATA_OUT | SCSI_POLL));
d340 1
a340 1
	    flags | SCSI_DATA_IN | SCSI_POLL));
d363 1
a363 1
scanjet_set_window(ss)
d365 1
d433 1
a433 1
	return (scanjet_ctl_write(ss, escape_codes, p - escape_codes, 0));
d461 1
a461 1
scanjet_compute_sizes(ss)
d463 1
d491 2
a492 1
	error = scanjet_ctl_write(ss, escape_codes, strlen(escape_codes), 0);
d497 1
a497 1
	error = scanjet_ctl_read(ss, response, 20, 0);
d512 2
a513 1
	error = scanjet_ctl_write(ss, escape_codes, strlen(escape_codes), 0);
@


1.8
log
@Add SCSI_POLL to control read/writes to remove some timing problem
This will be reviewed later in order to find the real culprit.
Workaround from Ken Stailey
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.7 1996/07/30 11:04:10 deraadt Exp $	*/
d114 4
@


1.7
log
@patch for HP scanjet 4p; netbsd pr#2663; kstailey@@dol-esa.gov
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.6 1996/05/22 11:58:41 deraadt Exp $	*/
d315 1
a315 1
	    flags | SCSI_DATA_OUT));
d336 1
a336 1
	    flags | SCSI_DATA_IN));
@


1.6
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.5 1996/05/10 12:31:41 deraadt Exp $	*/
d114 4
@


1.5
log
@SC_DEBUG cleanup
@
text
@d1 2
a2 2
/*	$OpenBSD: ss_scanjet.c,v 1.3 1996/04/21 22:31:17 deraadt Exp $	*/
/*	$NetBSD: ss_scanjet.c,v 1.4 1996/05/05 19:52:58 christos Exp $	*/
d64 8
a71 3
int scanjet_write __P((struct ss_softc *ss, char *buf, u_int size, int flags));
int scanjet_set_window __P((struct ss_softc *ss));
void scanjet_compute_sizes __P((struct ss_softc *));
d98 1
d109 1
a109 1
		printf("HP ScanJet IIc\n");
d113 1
a113 1
		printf("HP ScanJet IIcx\n");
d136 12
a147 1
	scanjet_compute_sizes(ss);
a167 1
#if 0
d170 1
d209 10
a218 1
	scanjet_compute_sizes(ss);
a234 3
	scanjet_compute_sizes(ss);

	/* send parameters */
d237 6
a242 1
		uprintf("set window failed\n");
d248 1
a248 1
	error = scanjet_write(ss, escape_codes, strlen(escape_codes), 0);
d250 1
a250 1
		uprintf("trigger failed\n");
d298 1
a298 1
scanjet_write(ss, buf, size, flags)
a305 5
	/*
	 * If it's a null transfer, return immediatly
	 */
	if (size == 0)
		return (0);
d314 22
d377 1
d386 1
d395 1
d404 1
d414 1
d424 25
a448 1
	return (scanjet_write(ss, escape_codes, p - escape_codes, 0));
d451 1
a451 1
void
d455 7
a461 1
	int r = 0;		/* round up by r 1/1200" */
d474 1
a474 1
		ss->sio.scan_bits_per_pixel = 1;
a476 3
		r = 600;
		ss->sio.scan_bits_per_pixel = 8;
		break;
d478 1
a478 2
		r = 600;
		ss->sio.scan_bits_per_pixel = 24;
d481 18
d500 17
a516 6
	ss->sio.scan_pixels_per_line =
		(ss->sio.scan_width * ss->sio.scan_x_resolution + r) / 1200;
	if (ss->sio.scan_bits_per_pixel == 1)
		/* pad to byte boundary: */
		ss->sio.scan_pixels_per_line =
		    (ss->sio.scan_pixels_per_line + 7) & 0xfffffff8;
a517 2
	ss->sio.scan_lines =
	    (ss->sio.scan_height * ss->sio.scan_y_resolution + r) / 1200;
d520 2
@


1.4
log
@Remove erroneously doubled text (patch can do that when a new file
comes into existence simultaneously from two directions).
@
text
@d2 1
a2 1
/*	$NetBSD: ss_scanjet.c,v 1.3 1996/03/30 21:47:07 christos Exp $	*/
a206 3
#ifdef SCSIDEBUG
	struct scsi_link *sc_link = ss->sc_link;
#endif
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: ss_scanjet.c,v 1.2 1996/04/19 16:10:24 niklas Exp $	*/
a417 410
	ss->sio.scan_window_size = ss->sio.scan_lines *
	    ((ss->sio.scan_pixels_per_line * ss->sio.scan_bits_per_pixel) / 8);
}
/*	$NetBSD: ss_scanjet.c,v 1.1 1996/02/18 20:32:49 mycroft Exp $	*/

/*
 * Copyright (c) 1995 Kenneth Stailey.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Kenneth Stailey.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * special functions for the HP ScanJet IIc and IIcx
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/fcntl.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/device.h>
#include <sys/conf.h>		/* for cdevsw */
#include <sys/scanio.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_scanner.h>
#include <scsi/scsiconf.h>
#include <scsi/ssvar.h>

#define SCANJET_RETRIES 4

int scanjet_get_params __P((struct ss_softc *));
int scanjet_set_params __P((struct ss_softc *, struct scan_io *));
int scanjet_trigger_scanner __P((struct ss_softc *));
int scanjet_read __P((struct ss_softc *, struct buf *));

/* only used internally */
int scanjet_write __P((struct ss_softc *ss, char *buf, u_int size, int flags));
int scanjet_set_window __P((struct ss_softc *ss));
void scanjet_compute_sizes __P((struct ss_softc *));

/*
 * structure for the special handlers
 */
struct ss_special scanjet_special = {
	scanjet_set_params,
	scanjet_trigger_scanner,
	scanjet_get_params,
	NULL,			/* no special minphys */
	scanjet_read,		/* scsi 6-byte read */
	NULL,			/* no "rewind" code (yet?) */
	NULL,			/* no adf support right now */
	NULL			/* no adf support right now */
};

/*
 * scanjet_attach: attach special functions to ss
 */
void
scanjet_attach(ss, sa)
	struct ss_softc *ss;
	struct scsibus_attach_args *sa;
{
	struct scsi_link *sc_link = sa->sa_sc_link;

	SC_DEBUG(sc_link, SDEV_DB1, ("scanjet_attach: start\n"));
	ss->sio.scan_scanner_type = 0;

	/* first, check the model (which determines nothing yet) */

	if (!bcmp(sa->sa_inqbuf->product, "C1750A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf(": HP ScanJet IIc\n");
	}
	if (!bcmp(sa->sa_inqbuf->product, "C2500A", 6)) {
		ss->sio.scan_scanner_type = HP_SCANJET_IIC;
		printf(": HP ScanJet IIcx\n");
	}

	SC_DEBUG(sc_link, SDEV_DB1, ("mustek_attach: scanner_type = %d\n",
	    ss->sio.scan_scanner_type));

	/* now install special handlers */
	ss->special = &scanjet_special;

	/*
	 * populate the scanio struct with legal values
	 */
	ss->sio.scan_width		= 1200;
	ss->sio.scan_height		= 1200;
	ss->sio.scan_x_resolution	= 100;
	ss->sio.scan_y_resolution	= 100;
	ss->sio.scan_x_origin		= 0;
	ss->sio.scan_y_origin		= 0;
	ss->sio.scan_brightness		= 100;
	ss->sio.scan_contrast		= 100;
	ss->sio.scan_quality		= 100;
	ss->sio.scan_image_mode		= SIM_GRAYSCALE;

	scanjet_compute_sizes(ss);
}

int
scanjet_get_params(ss)
	struct ss_softc *ss;
{

	return (0);
}

/*
 * check the parameters if the scanjet is capable of fulfilling it
 * but don't send the command to the scanner in case the user wants
 * to change parameters by more than one call
 */
int
scanjet_set_params(ss, sio)
	struct ss_softc *ss;
	struct scan_io *sio;
{
	int error;

#if 0
	/*
	 * if the scanner is triggered, then rewind it
	 */
	if (ss->flags & SSF_TRIGGERED) {
		error = scanjet_rewind_scanner(ss);
		if (error)
			return (error);
	}
#endif

	/* size constraints... */
	if (sio->scan_width == 0				 ||
	    sio->scan_x_origin + sio->scan_width > 10200 || /* 8.5" */
	    sio->scan_height == 0				 ||
	    sio->scan_y_origin + sio->scan_height > 16800)  /* 14" */
		return (EINVAL);

	/* resolution (dpi)... */
	if (sio->scan_x_resolution < 100 ||
	    sio->scan_x_resolution > 400 ||
	    sio->scan_y_resolution < 100 ||
	    sio->scan_y_resolution > 400)
		return (EINVAL);

	switch (sio->scan_image_mode) {
	case SIM_BINARY_MONOCHROME:
	case SIM_DITHERED_MONOCHROME:
	case SIM_GRAYSCALE:
	case SIM_COLOR:
		break;
	default:
		return (EINVAL);
	}

	/* change ss_softc to the new values, but save ro-variables */
	sio->scan_scanner_type = ss->sio.scan_scanner_type;
	bcopy(sio, &ss->sio, sizeof(struct scan_io));

	scanjet_compute_sizes(ss);

	return (0);
}

/*
 * trigger the scanner to start a scan operation
 * this includes sending the mode- and window-data,
 * and starting the scanner
 */
int
scanjet_trigger_scanner(ss)
	struct ss_softc *ss;
{
	char escape_codes[20];
	struct scsi_link *sc_link = ss->sc_link;
	int error;

	scanjet_compute_sizes(ss);

	/* send parameters */
	error = scanjet_set_window(ss);
	if (error) {
		uprintf("set window failed\n");
		return (error);
	}

	/* send "trigger" operation */
	strcpy(escape_codes, "\033*f0S");
	error = scanjet_write(ss, escape_codes, strlen(escape_codes), 0);
	if (error) {
		uprintf("trigger failed\n");
		return (error);
	}
	
	return (0);
}

int
scanjet_read(ss, bp)
	struct ss_softc *ss;
	struct buf *bp;
{
	struct scsi_rw_scanner cmd;
	struct scsi_link *sc_link = ss->sc_link;

	/*
	 *  Fill out the scsi command
	 */
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = READ;

	/*
	 * Handle "fixed-block-mode" tape drives by using the
	 * block count instead of the length.
	 */
	lto3b(bp->b_bcount, cmd.len);

	/*
	 * go ask the adapter to do all this for us
	 */
	if (scsi_scsi_cmd(sc_link, (struct scsi_generic *) &cmd, sizeof(cmd),
	    (u_char *) bp->b_data, bp->b_bcount, SCANJET_RETRIES, 100000, bp,
	    SCSI_NOSLEEP | SCSI_DATA_IN) != SUCCESSFULLY_QUEUED)
		printf("%s: not queued\n", ss->sc_dev.dv_xname);
	else {
		ss->sio.scan_window_size -= bp->b_bcount;
		if (ss->sio.scan_window_size < 0)
			ss->sio.scan_window_size = 0;
	}

	return (0);
}


/*
 * Do a synchronous write.  Used to send control messages.
 */
int 
scanjet_write(ss, buf, size, flags)
	struct ss_softc *ss;
	char *buf;
	u_int size;
	int flags;
{
	struct scsi_rw_scanner cmd;

	/*
	 * If it's a null transfer, return immediatly
	 */
	if (size == 0)
		return (0);
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = WRITE;
	lto3b(size, cmd.len);
	return (scsi_scsi_cmd(ss->sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), (u_char *) buf, size, 0, 100000, NULL,
	    flags | SCSI_DATA_OUT));
}

#ifdef SCANJETDEBUG
static void show_es(char *es)
{
  char *p = es;
  while (*p) {
    if (*p == '\033')
      printf("[Esc]");
    else
      printf("%c", *p);
    ++p;
  }
  printf("\n");
}
#endif

/* 
 * simulate SCSI_SET_WINDOW for ScanJets
 */
int
scanjet_set_window(ss)
	struct ss_softc *ss;
{
	char escape_codes[128], *p;

	p = escape_codes;

	sprintf(p, "\033*f%dP", ss->sio.scan_width / 4);
	p += strlen(p);
	sprintf(p, "\033*f%dQ", ss->sio.scan_height / 4);
	p += strlen(p);
	sprintf(p, "\033*f%dX", ss->sio.scan_x_origin / 4);
	p += strlen(p);
	sprintf(p, "\033*f%dY", ss->sio.scan_y_origin / 4);
	p += strlen(p);
	sprintf(p, "\033*a%dR", ss->sio.scan_x_resolution);
	p += strlen(p);
	sprintf(p, "\033*a%dS", ss->sio.scan_y_resolution);
	p += strlen(p);
     
	switch (ss->sio.scan_image_mode) {
	case SIM_BINARY_MONOCHROME:
		/* use "line art" mode */
		strcpy(p, "\033*a0T");
		p += strlen(p);
		/* make image data be "min-is-white ala PBM */
		strcpy(p, "\033*a0I");
		p += strlen(p);
		break;
	case SIM_DITHERED_MONOCHROME:
		/* use dithered mode */
		strcpy(p, "\033*a3T");
		p += strlen(p);
		/* make image data be "min-is-white ala PBM */
		strcpy(p, "\033*a0I");
		p += strlen(p);
		break;
	case SIM_GRAYSCALE:
		/* use grayscale mode */
		strcpy(p, "\033*a4T");
		p += strlen(p);
		/* make image data be "min-is-black ala PGM */
		strcpy(p, "\033*a1I");
		p += strlen(p);
		break;
	case SIM_COLOR:
		/* use RGB color mode */
		strcpy(p, "\033*a5T");
		p += strlen(p);
		/* make image data be "min-is-black ala PPM */
		strcpy(p, "\033*a1I");
		p += strlen(p);
		/* use pass-through matrix (disable NTSC) */
		strcpy(p, "\033*u2T");
		p += strlen(p);
	}

	sprintf(p, "\033*a%dG", ss->sio.scan_bits_per_pixel);
	p += strlen(p);
	sprintf(p, "\033*a%dL", (int)(ss->sio.scan_brightness) - 128);
	p += strlen(p);
	sprintf(p, "\033*a%dK", (int)(ss->sio.scan_contrast) - 128);
	p += strlen(p);

	return (scanjet_write(ss, escape_codes, p - escape_codes, 0));
}

void
scanjet_compute_sizes(ss)
	struct ss_softc *ss;
{

	/*
	 * Deal with the fact that the HP ScanJet IIc uses 1/300" not 1/1200"
	 * as its base unit of measurement.  PINT uses 1/1200" (yes I know
	 * ScanJet II's use decipoints as well but 1200 % 720 != 0)
	 */
	ss->sio.scan_width = (ss->sio.scan_width + 3) & 0xfffffffc;
	ss->sio.scan_height = (ss->sio.scan_height + 3) & 0xfffffffc;

	switch (ss->sio.scan_image_mode) {
	case SIM_BINARY_MONOCHROME:
	case SIM_DITHERED_MONOCHROME:
		ss->sio.scan_bits_per_pixel = 1;
		break;
	case SIM_GRAYSCALE:
		ss->sio.scan_bits_per_pixel = 8;
		break;
	case SIM_COLOR:
		ss->sio.scan_bits_per_pixel = 24;
		break;
	}

	ss->sio.scan_pixels_per_line =
	    (ss->sio.scan_width * ss->sio.scan_x_resolution) / 1200;
	if (ss->sio.scan_bits_per_pixel == 1)
		/* pad to byte boundary: */
		ss->sio.scan_pixels_per_line =
		    (ss->sio.scan_pixels_per_line + 7) & 0xfffffff8;

	ss->sio.scan_lines =
	    (ss->sio.scan_height * ss->sio.scan_y_resolution) / 1200;
@


1.2
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ss_scanjet.c,v 1.1 1996/02/18 20:32:49 mycroft Exp $	*/
d90 1
d92 1
d97 2
d103 1
a103 1
		printf(": HP ScanJet IIc\n");
d107 1
a107 1
		printf(": HP ScanJet IIcx\n");
d110 1
a110 1
	SC_DEBUG(sc_link, SDEV_DB1, ("mustek_attach: scanner_type = %d\n",
d125 2
a126 2
	ss->sio.scan_brightness		= 100;
	ss->sio.scan_contrast		= 100;
d151 1
a153 1
#if 0
d207 1
d209 1
d250 1
a250 1
	lto3b(bp->b_bcount, cmd.len);
d288 1
a288 1
	lto3b(size, cmd.len);
d320 1
a320 1
	sprintf(p, "\033*f%dP", ss->sio.scan_width / 4);
d322 1
a322 1
	sprintf(p, "\033*f%dQ", ss->sio.scan_height / 4);
d324 1
a324 1
	sprintf(p, "\033*f%dX", ss->sio.scan_x_origin / 4);
d326 1
a326 1
	sprintf(p, "\033*f%dY", ss->sio.scan_y_origin / 4);
d384 1
d400 1
d404 1
d410 1
a410 1
	    (ss->sio.scan_width * ss->sio.scan_x_resolution) / 1200;
d417 1
a417 1
	    (ss->sio.scan_height * ss->sio.scan_y_resolution) / 1200;
@


1.1
log
@Sync. with NetBSD:
- scsi prototypes.
- Add SCSI scanner support by Kenneth Stailey and Joachim Koenig-Baltes,
  hacked a but.  Needs more work.
ss.c:
- Truncate to the window size in ssminphys(), not ssread().
- Missed some prototyping foo.
- Minor tweak; make sure window size is 0 on close.
- Change variable name to avoid GCC warning.
- Handle EOF a little differently.
@
text
@d1 411
@
