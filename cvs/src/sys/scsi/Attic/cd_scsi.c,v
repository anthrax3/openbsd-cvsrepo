head	1.9;
access;
symbols
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.4.0.10
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.3.0.4
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.9
date	2005.05.27.16.50.31;	author krw;	state dead;
branches;
next	1.8;

1.8
date	2005.05.23.07.06.16;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.14.00.20.43;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.05.12.13.16;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.09.14.08.11;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.22.14.35.42;	author deraadt;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2000.07.18.06.26.29;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	99.07.20.06.21.59;	author csapuntz;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.05.14.22.44.58;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.07.04.11.00.00;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.06.05.23.13.08;	author niklas;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.11.03.32.13;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@No longer used after merge of atapi/scsi cd code.
@
text
@/*	$OpenBSD: cd_scsi.c,v 1.8 2005/05/23 07:06:16 krw Exp $	*/
/*	$NetBSD: cd_scsi.c,v 1.14 1998/08/31 22:28:06 cgd Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Originally written by Julian Elischer (julian@@tfs.com)
 * for TRW Financial Systems for use under the MACH(2.5) operating system.
 *
 * TRW Financial Systems, in accordance with their agreement with Carnegie
 * Mellon University, makes this software available to CMU to distribute
 * or use in any manner that they see fit as long as this message is kept with
 * the software. For this reason TFS also grants any other persons or
 * organisations permission to use or modify this software.
 *
 * TFS supplies this software to be publicly redistributed
 * on the understanding that TFS is not responsible for the correct
 * functioning of this software in any circumstances.
 *
 * Ported to run under 386BSD by Julian Elischer (julian@@tfs.com) Sept 1992
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/buf.h>
#include <sys/conf.h>
#if NRND > 0
#include <sys/rnd.h>
#endif

#include <sys/cdio.h>

#include <scsi/scsi_all.h>
#include <scsi/cd.h>
#include <scsi/scsi_cd.h>
#include <scsi/scsiconf.h>
#include <scsi/cdvar.h>

int	cd_scsibus_setchan(struct cd_softc *, int, int, int, int, int);
int	cd_scsibus_getvol(struct cd_softc *, struct ioc_vol *, int);
int	cd_scsibus_setvol(struct cd_softc *, const struct ioc_vol *,
	    int);
int	cd_scsibus_set_pa_immed(struct cd_softc *, int);
int	cd_scsibus_load_unload(struct cd_softc *, int, int);

const struct cd_ops cd_scsibus_ops = {
	cd_scsibus_setchan,
	cd_scsibus_getvol,
	cd_scsibus_setvol,
	cd_scsibus_set_pa_immed,
	cd_scsibus_load_unload,
};

int
cd_scsibus_set_pa_immed(cd, flags)
	struct cd_softc *cd;
	int flags;
{
	struct scsi_cd_mode_data data;
	int error;

	error = scsi_mode_sense(cd->sc_link, 0, AUDIO_PAGE,
	    (struct scsi_mode_header *)&data, AUDIOPAGESIZE, flags, 20000);
	if (error != 0)
		return (error);

	data.page.audio.flags &= ~CD_PA_SOTC;
	data.page.audio.flags |= CD_PA_IMMED;

	return (scsi_mode_select(cd->sc_link, SMS_PF,
	    (struct scsi_mode_header *)&data, AUDIOPAGESIZE, flags, 20000)); 
}

int
cd_scsibus_setchan(cd, p0, p1, p2, p3, flags)
	struct cd_softc *cd;
	int p0, p1, p2, p3;
	int flags;
{
	struct scsi_cd_mode_data data;
	int error;

	error = scsi_mode_sense(cd->sc_link, 0, AUDIO_PAGE,
	    (struct scsi_mode_header *)&data, AUDIOPAGESIZE, flags, 20000);
	if (error != 0)
		return (error);

	data.page.audio.port[LEFT_PORT].channels = p0;
	data.page.audio.port[RIGHT_PORT].channels = p1;
	data.page.audio.port[2].channels = p2;
	data.page.audio.port[3].channels = p3;

	return (scsi_mode_select(cd->sc_link, SMS_PF,
	    (struct scsi_mode_header *)&data, AUDIOPAGESIZE, flags, 20000)); 
}

int
cd_scsibus_getvol(cd, arg, flags)
	struct cd_softc *cd;
	struct ioc_vol *arg;
	int flags;
{

	struct scsi_cd_mode_data data;
	int error;

	error = scsi_mode_sense(cd->sc_link, 0, AUDIO_PAGE,
	    (struct scsi_mode_header *)&data, AUDIOPAGESIZE, flags, 20000);
	if (error != 0)
		return (error);

	arg->vol[LEFT_PORT] = data.page.audio.port[LEFT_PORT].volume;
	arg->vol[RIGHT_PORT] = data.page.audio.port[RIGHT_PORT].volume;
	arg->vol[2] = data.page.audio.port[2].volume;
	arg->vol[3] = data.page.audio.port[3].volume;

	return (0);
}

int
cd_scsibus_setvol(cd, arg, flags)
	struct cd_softc *cd;
	const struct ioc_vol *arg;
	int flags;
{
	struct scsi_cd_mode_data data;
	int error;

	error = scsi_mode_sense(cd->sc_link, 0, AUDIO_PAGE,
	    (struct scsi_mode_header *)&data, AUDIOPAGESIZE, flags, 20000);
	if (error != 0)
		return (error);

	data.page.audio.port[LEFT_PORT].channels = CHANNEL_0;
	data.page.audio.port[LEFT_PORT].volume = arg->vol[LEFT_PORT];
	data.page.audio.port[RIGHT_PORT].channels = CHANNEL_1;
	data.page.audio.port[RIGHT_PORT].volume = arg->vol[RIGHT_PORT];
	data.page.audio.port[2].volume = arg->vol[2];
	data.page.audio.port[3].volume = arg->vol[3];

	return (scsi_mode_select(cd->sc_link, SMS_PF,
	    (struct scsi_mode_header *)&data, AUDIOPAGESIZE, flags, 20000)); 
}

int
cd_scsibus_load_unload(cd, options, slot)
	struct cd_softc *cd;
	int options, slot;
{
	/*
	 * Not supported on SCSI CDs that we know of (but we'll leave
	 * the hook here Just In Case).
	 */
	return (ENODEV);
}
@


1.8
log
@Don't bzero() data before calling scsi_mode_sense[_big]() since
scsi_mode_sense[_big] bzero()'s it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd_scsi.c,v 1.7 2005/05/14 00:20:43 krw Exp $	*/
@


1.7
log
@Add scsi_mode_[sense|select]_big() and use it instead of
atapi_mode_[sense|select](). This will allow the removal of
atapi_base.c and atapi_all.h files, and sets the stage for better usb
mode sense handling amoung other things.

Remove cd_scsibus_[get|set]_mode() and
sd_scsibus_mode_sense() shims in favour of scsi_mode_[sense|select]().
Add zero'ing of reserved length field in scsi_mode_select(). Change
some uchar * type parameters to scsi_mode_header *.

No functional changes. Mostly from NetBSD.

ok dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd_scsi.c,v 1.6 2005/04/05 12:13:16 krw Exp $	*/
a100 1
	bzero(&data, sizeof(data));
a121 1
	bzero(&data, sizeof(data));
a145 1
	bzero(&data, sizeof(data));
a167 1
	bzero(&data, sizeof(data));
@


1.6
log
@Factor out scsi_mode_sense() and scsi_mode_select() like NetBSD does.
Eliminate some duplicate structures and defines along the way. SCSI CD
drives will now pay attention to the 'flags' parameter for MODE SENSE
and MODE SELECT commands. No other functional change.

ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd_scsi.c,v 1.5 2004/05/09 14:08:11 krw Exp $	*/
a77 5
int	cd_scsibus_get_mode(struct cd_softc *,
	    struct scsi_cd_mode_data *, int, int, int);
int	cd_scsibus_set_mode(struct cd_softc *,
	    struct scsi_cd_mode_data *, int, int);

a92 31
/*
 * Get the requested page into the buffer given
 */
int
cd_scsibus_get_mode(cd, data, page, len, flags)
	struct cd_softc *cd;
	struct scsi_cd_mode_data *data;
	int page, len, flags;
{
	return scsi_mode_sense(cd->sc_link, 0, page, (u_char *)data,
	    len, flags, 20000);
}

/*
 * Get the requested page into the buffer given
 */
int
cd_scsibus_set_mode(cd, data, len, flags)
	struct cd_softc *cd;
	struct scsi_cd_mode_data *data;
	int len, flags;
{
	/* SPC-2 revision 16, section 8.3: Mode parameters
	   When used with the [MODE SELECT command], the data
	   length field is reserved. */
	data->header.data_length = 0;

	return scsi_mode_select(cd->sc_link, SMS_PF, (u_char *)data, len, flags,
	    20000); 
}

d101 4
a104 2
	if ((error = cd_scsibus_get_mode(cd, &data, AUDIO_PAGE,
	    AUDIOPAGESIZE, flags)) != 0)
d106 1
d109 3
a111 1
	return (cd_scsibus_set_mode(cd, &data, AUDIOPAGESIZE, flags));
d123 4
a126 2
	if ((error = cd_scsibus_get_mode(cd, &data, AUDIO_PAGE,
	    AUDIOPAGESIZE, flags)) != 0)
d128 1
d133 3
a135 1
	return (cd_scsibus_set_mode(cd, &data, AUDIOPAGESIZE, flags));
d148 4
a151 2
	if ((error = cd_scsibus_get_mode(cd, &data, AUDIO_PAGE,
	    AUDIOPAGESIZE, flags)) != 0)
d153 1
d158 1
d171 4
a174 2
	if ((error = cd_scsibus_get_mode(cd, &data, AUDIO_PAGE,
	    AUDIOPAGESIZE, flags)) != 0)
d176 1
d183 3
a185 1
	return (cd_scsibus_set_mode(cd, &data, AUDIOPAGESIZE, flags));
@


1.5
log
@Remove some #ifndef __OpenBSD__/#endif sections that were intended to
make sync'ing with NetBSD easier. NetBSD has moved on, most of these
sections have not.

ok marco@@ deraadt@@ grange@@ csapuntz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd_scsi.c,v 1.4 2002/03/14 01:27:13 millert Exp $	*/
d107 2
a108 19
	struct scsi_mode_sense scsi_cmd;

#ifdef DIAGNOSTIC
	if (len == 0 || len > 256) {
		printf ("cd_scsibus_get_mode: Mode page %02x request "
		    "bad size: %d bytes\n", page, len);
		return (EINVAL);
	}
#endif

	bzero(&scsi_cmd, sizeof(scsi_cmd));
	bzero(data, sizeof(*data));
	scsi_cmd.opcode = MODE_SENSE;
	scsi_cmd.page = page;
	scsi_cmd.length = len & 0xff;
	return (scsi_scsi_cmd(cd->sc_link,
	    (struct scsi_generic *)&scsi_cmd, sizeof(scsi_cmd),
	    (u_char *)data, len, CDRETRIES, 20000, NULL,
	    SCSI_DATA_IN));
a119 15
	struct scsi_mode_select scsi_cmd;

#ifdef DIAGNOSTIC
	if (len == 0 || len > 256) {
		printf ("cd_scsibus_set_mode: Set mode request "
		    "bad size: %d bytes\n", len);
		return (EINVAL);
	}
#endif

	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MODE_SELECT;
	scsi_cmd.byte2 |= SMS_PF;
	scsi_cmd.length = len & 0xff;

d125 2
a126 4
	return (scsi_scsi_cmd(cd->sc_link,
	    (struct scsi_generic *)&scsi_cmd, sizeof(scsi_cmd),
	    (u_char *)data, len, CDRETRIES, 20000, NULL,
	    SCSI_DATA_OUT));
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cd_scsi.c,v 1.3 2001/06/22 14:35:42 deraadt Exp $	*/
a55 4

#ifndef __OpenBSD__
#include "rnd.h"
#endif
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cd_scsi.c,v 1.2 2000/07/18 06:26:29 csapuntz Exp $	*/
d82 11
a92 11
int	cd_scsibus_get_mode __P((struct cd_softc *,
	    struct scsi_cd_mode_data *, int, int, int));
int	cd_scsibus_set_mode __P((struct cd_softc *,
	    struct scsi_cd_mode_data *, int, int));

int	cd_scsibus_setchan __P((struct cd_softc *, int, int, int, int, int));
int	cd_scsibus_getvol __P((struct cd_softc *, struct ioc_vol *, int));
int	cd_scsibus_setvol __P((struct cd_softc *, const struct ioc_vol *,
	    int));
int	cd_scsibus_set_pa_immed __P((struct cd_softc *, int));
int	cd_scsibus_load_unload __P((struct cd_softc *, int, int));
@


1.3.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd_scsi.c,v 1.3 2001/06/22 14:35:42 deraadt Exp $	*/
d82 11
a92 11
int	cd_scsibus_get_mode(struct cd_softc *,
	    struct scsi_cd_mode_data *, int, int, int);
int	cd_scsibus_set_mode(struct cd_softc *,
	    struct scsi_cd_mode_data *, int, int);

int	cd_scsibus_setchan(struct cd_softc *, int, int, int, int, int);
int	cd_scsibus_getvol(struct cd_softc *, struct ioc_vol *, int);
int	cd_scsibus_setvol(struct cd_softc *, const struct ioc_vol *,
	    int);
int	cd_scsibus_set_pa_immed(struct cd_softc *, int);
int	cd_scsibus_load_unload(struct cd_softc *, int, int);
@


1.2
log
@

Thanks to miod@@ for finding bug in cd_scsi_{get,set}mode

Pass length of mode page, not length of fixed header
@
text
@d1 1
a1 1
/*	$OpenBSD: cd_scsi.c,v 1.1 1999/07/20 06:21:59 csapuntz Exp $	*/
d113 1
a113 1
#ifdef DIAGNOSTIC       
@


1.1
log
@

Make acd redundant.

Mostly based on NetBSD-current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd_scsi.c,v 1.14 1998/08/31 22:28:06 cgd Exp $	*/
d113 8
d128 1
a128 1
	    (u_char *)data, sizeof(*data), CDRETRIES, 20000, NULL,
d143 8
d155 4
d160 1
d163 1
a163 1
	    (u_char *)data, sizeof(*data), CDRETRIES, 20000, NULL,
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cd_scsi.c,v 1.2 2000/07/18 06:26:29 csapuntz Exp $	*/
a112 8
#ifdef DIAGNOSTIC       
	if (len == 0 || len > 256) {
		printf ("cd_scsibus_get_mode: Mode page %02x request "
		    "bad size: %d bytes\n", page, len);
		return (EINVAL);
	}
#endif

d120 1
a120 1
	    (u_char *)data, len, CDRETRIES, 20000, NULL,
a134 8
#ifdef DIAGNOSTIC
	if (len == 0 || len > 256) {
		printf ("cd_scsibus_set_mode: Set mode request "
		    "bad size: %d bytes\n", len);
		return (EINVAL);
	}
#endif

a138 4

	/* SPC-2 revision 16, section 8.3: Mode parameters
	   When used with the [MODE SELECT command], the data
	   length field is reserved. */
a139 1

d142 1
a142 1
	    (u_char *)data, len, CDRETRIES, 20000, NULL,
@


1.1.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd_scsi.c,v 1.1.4.1 2001/05/14 22:44:58 niklas Exp $	*/
d113 1
a113 1
#ifdef DIAGNOSTIC
@


1.1.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d82 11
a92 11
int	cd_scsibus_get_mode(struct cd_softc *,
	    struct scsi_cd_mode_data *, int, int, int);
int	cd_scsibus_set_mode(struct cd_softc *,
	    struct scsi_cd_mode_data *, int, int);

int	cd_scsibus_setchan(struct cd_softc *, int, int, int, int, int);
int	cd_scsibus_getvol(struct cd_softc *, struct ioc_vol *, int);
int	cd_scsibus_setvol(struct cd_softc *, const struct ioc_vol *,
	    int);
int	cd_scsibus_set_pa_immed(struct cd_softc *, int);
int	cd_scsibus_load_unload(struct cd_softc *, int, int);
@


1.1.4.4
log
@Merge with the trunk
@
text
@d57 4
@


