head	1.11;
access;
symbols
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.1.0.14
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.12
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.10
	OPENBSD_2_8:1.1.0.8
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.6
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.4
	SMP_BASE:1.1
	kame_19991208:1.1
	OPENBSD_2_6:1.1.0.2
	OPENBSD_2_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2005.07.02.04.24.54;	author krw;	state dead;
branches;
next	1.10;

1.10
date	2005.06.19.20.41.28;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2005.06.03.15.50.10;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.26.02.10.14;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.22.21.11.31;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.14.00.20.43;	author krw;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.16.16.41.46;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.25.02.18.35;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.13.00.53.32;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	99.07.25.07.09.19;	author csapuntz;	state Exp;
branches
	1.1.4.1
	1.1.14.1;
next	;

1.1.4.1
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.05.16.00.29.45;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2004.02.19.11.01.31;	author niklas;	state Exp;
branches;
next	;

1.1.14.1
date	2002.06.11.03.32.14;	author art;	state Exp;
branches;
next	1.1.14.2;

1.1.14.2
date	2003.05.19.22.28.21;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Unused files.
@
text
@/*	$OpenBSD: sd_atapi.c,v 1.10 2005/06/19 20:41:28 krw Exp $	*/
/*	$NetBSD: sd_atapi.c,v 1.3 1998/08/31 22:28:07 cgd Exp $	*/

/*
 * Copyright 1998
 * Digital Equipment Corporation. All rights reserved.
 *
 * This software is furnished under license and may be used and
 * copied only in accordance with the following terms and conditions.
 * Subject to these conditions, you may download, copy, install,
 * use, modify and distribute this software in source and/or binary
 * form. No title or ownership is transferred hereby.
 *
 * 1) Any source code used, modified or distributed must reproduce
 *    and retain this copyright notice and list of conditions as
 *    they appear in the source file.
 *
 * 2) No right is granted to use any trade name, trademark, or logo of
 *    Digital Equipment Corporation. Neither the "Digital Equipment
 *    Corporation" name nor any trademark or logo of Digital Equipment
 *    Corporation may be used to endorse or promote products derived
 *    from this software without the prior written permission of
 *    Digital Equipment Corporation.
 *
 * 3) This software is provided "AS-IS" and any express or implied
 *    warranties, including but not limited to, any implied warranties
 *    of merchantability, fitness for a particular purpose, or
 *    non-infringement are disclaimed. In no event shall DIGITAL be
 *    liable for any damages whatsoever, and in particular, DIGITAL
 *    shall not be liable for special, indirect, consequential, or
 *    incidental damages or damages for lost profits, loss of
 *    revenue or loss of use, whether such damages arise in contract,
 *    negligence, tort, under statute, in equity, at law or otherwise,
 *    even if advised of the possibility of such damage.
 */

/*
 * ATAPI disk attachment for the 'sd' driver.
 *
 * Chris Demetriou, January 10, 1998.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/conf.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>
#include <scsi/atapi_disk.h>
#include <scsi/sdvar.h>

static int	sd_atapibus_get_parms(struct sd_softc *,
		    struct disk_parms *, int);

const struct sd_ops sd_atapibus_ops = {
	sd_atapibus_get_parms,
};

static int
sd_atapibus_get_parms(sd, dp, flags)
	struct sd_softc *sd;
	struct disk_parms *dp;
	int flags;
{
	struct atapi_read_format_capacities scsi_cmd;
	struct scsi_direct_blk_desc *descp;
	struct scsi_mode_sense_buf sense_data; 
	union scsi_disk_pages *sense_pages = NULL;
	char capacity_data[ATAPI_CAP_DESC_SIZE(1)];
	u_int16_t rpm;
	int error;

	bzero(&scsi_cmd, sizeof scsi_cmd);
	scsi_cmd.opcode = ATAPI_READ_FORMAT_CAPACITIES;
	_lto2b(ATAPI_CAP_DESC_SIZE(1), scsi_cmd.length);

	error = scsi_scsi_cmd(sd->sc_link,
	    (struct scsi_generic *)&scsi_cmd, sizeof(scsi_cmd),
	    (void *)capacity_data, ATAPI_CAP_DESC_SIZE(1), SDRETRIES, 20000,
	    NULL, flags | SCSI_DATA_IN);
	SC_DEBUG(sd->sc_link, SDEV_DB2,
	    ("sd_atapibus_get_parms: read format capacities error=%d\n",
	    error));
	if (error != 0)
		return (SDGP_RESULT_OFFLINE);

	descp = (struct scsi_direct_blk_desc *)
	    &capacity_data[ATAPI_CAP_DESC_OFFSET_DESC(0)];

	switch (descp->density & ATAPI_CAP_DESC_CODE_MASK) {
	case ATAPI_CAP_DESC_CODE_UNFORMATTED:
		return SDGP_RESULT_UNFORMATTED;

	case ATAPI_CAP_DESC_CODE_FORMATTED:
		break;

	case ATAPI_CAP_DESC_CODE_NONE:
		return SDGP_RESULT_OFFLINE;

	default:
#ifdef DIAGNOSTIC
		printf("%s: strange capacity descriptor density 0x%x\n",
		    sd->sc_dev.dv_xname, (u_int)descp->density);
#endif
		break;
	}

	dp->disksize = _4btol(descp->nblocks);
	if (dp->disksize == 0)
		return (SDGP_RESULT_OFFLINE);

	dp->blksize = _3btol(descp->blklen);

	error = scsi_do_mode_sense(sd->sc_link, ATAPI_FLEX_GEOMETRY_PAGE,
	    &sense_data, (void **)&sense_pages, NULL, NULL, NULL,
	    sizeof(sense_pages->flex_geometry), flags | SCSI_SILENT, NULL);
	if (error == 0 && sense_pages) {
		dp->heads = sense_pages->flex_geometry.nheads;
		dp->sectors = sense_pages->flex_geometry.ph_sec_tr;
		dp->cyls = _2btol(sense_pages->flex_geometry.ncyl);
		if (dp->blksize == 0)
			dp->blksize =
			     _2btol(sense_pages->flex_geometry.bytes_s);
		rpm = _2btol(sense_pages->flex_geometry.rpm);
		if (rpm)
			dp->rot_rate = rpm;
	}
	
	/*
	 * Use standard fake values if MODE SENSE did not provide better ones.
	 */
	if (dp->rot_rate == 0)
		dp->rot_rate = 3600;
	if (dp->blksize == 0)
		dp->blksize = 512;

	if (dp->heads == 0)
		dp->heads = 64;
	if (dp->sectors == 0)
		dp->sectors = 32;
	if (dp->cyls == 0)
		dp->cyls = dp->disksize / (dp->heads * dp->sectors);

	return (SDGP_RESULT_OK);
}
@


1.10
log
@Eradicate unused struct atapi_sd_mode_data. Eradicate struct
atapi_capacity_descriptor in favour of equivalent struct
scsi_direct_blk_desc. No code change. One verbiage adjustment.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_atapi.c,v 1.9 2005/06/03 15:50:10 krw Exp $	*/
@


1.9
log
@Tweak scsi_do_mode_sense(). NetBSD was right and I was wrong. Sigh.
Add 'big' parameter to report which mode sense header type is being
returned. Eliminate icky pointer arithmetic, since it won't work if
only block descriptors are returned by the device.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_atapi.c,v 1.8 2005/05/26 02:10:14 krw Exp $	*/
d74 1
a74 1
	struct atapi_capacity_descriptor *descp;
d95 1
a95 1
	descp = (struct atapi_capacity_descriptor *)
d98 1
a98 1
	switch (descp->byte5 & ATAPI_CAP_DESC_CODE_MASK) {
d110 2
a111 2
		printf("%s: strange capacity descriptor byte5 0x%x\n",
		    sd->sc_dev.dv_xname, (u_int)descp->byte5);
d116 1
a116 1
	dp->disksize = _4btol(descp->nblks);
@


1.8
log
@Use new mode sense mechanism for atapi disks. Make sure that fake
geometry is set even if (as for some USB devices) the MODE SENSE works
but zero values are returned for cylinders/heads/sectors. This fixes
my USB floppy which returns 0/0/0.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_atapi.c,v 1.7 2005/05/22 21:11:31 krw Exp $	*/
d124 1
a124 1
	    sizeof(sense_pages->flex_geometry), flags | SCSI_SILENT);
@


1.7
log
@Remove some superfluous structures, etc. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_atapi.c,v 1.6 2005/05/14 00:20:43 krw Exp $	*/
d75 2
a76 1
	struct atapi_sd_mode_data sense_data;
a115 10
	/*
	 * Try to determine disk size, block size and geometry.  If disk size
	 * (in sectors) can be determined, then fake the rest if necessary.
	 *
	 * XXX Rigid geometry page?
	 */
	dp->rot_rate = 3600;
	dp->blksize = _3btol(descp->blklen);
	if (dp->blksize == 0)
		dp->blksize = 512;
d120 13
a132 11
	bzero(&sense_data, sizeof(sense_data));
	error = scsi_mode_sense_big(sd->sc_link, 0, ATAPI_FLEX_GEOMETRY_PAGE,
	    (struct scsi_mode_header_big *)&sense_data, sizeof(sense_data),
	    flags, 20000);
	SC_DEBUG(sd->sc_link, SDEV_DB2,
	    ("sd_atapibus_get_parms: mode sense (flex) error=%d\n", error));
	if (error == 0) {
		dp->heads = sense_data.pages.flex_geometry.nheads;
		dp->sectors = sense_data.pages.flex_geometry.ph_sec_tr;
		dp->cyls = _2btol(sense_data.pages.flex_geometry.ncyl);
		rpm = _2btol(sense_data.pages.flex_geometry.rpm);
d135 11
a145 1
	} else {
d147 1
d149 3
a151 3
		dp->cyls = dp->disksize / (64 * 32);
	}
	
@


1.6
log
@Add scsi_mode_[sense|select]_big() and use it instead of
atapi_mode_[sense|select](). This will allow the removal of
atapi_base.c and atapi_all.h files, and sets the stage for better usb
mode sense handling amoung other things.

Remove cd_scsibus_[get|set]_mode() and
sd_scsibus_mode_sense() shims in favour of scsi_mode_[sense|select]().
Add zero'ing of reserved length field in scsi_mode_select(). Change
some uchar * type parameters to scsi_mode_header *.

No functional changes. Mostly from NetBSD.

ok dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_atapi.c,v 1.5 2005/04/16 16:41:46 krw Exp $	*/
d131 1
a131 1
	    (struct scsi_mode_header_big *)&sense_data, FLEXGEOMETRYPAGESIZE,
d139 1
a139 1
		rpm = _2btol(sense_data.pages.flex_geometry.rot_rate);
@


1.5
log
@Nuke unused/duplicate structures and defines in favour of scsi ones.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_atapi.c,v 1.4 2003/06/25 02:18:35 krw Exp $	*/
a56 1
#include <scsi/atapi_all.h>
d129 2
a130 1
	error = atapi_mode_sense(sd->sc_link, ATAPI_FLEX_GEOMETRY_PAGE,
d132 1
a132 1
	    flags, SDRETRIES, 20000);
@


1.4
log
@Avoid a divide by zero by

1) Ensuring that both sd_scsi.c and sd_atapi.c report a device as
offline when its disksize cannot be determined.

2) Ensuring blksize is always non-zero, with a default value of 512.

3) Eliminating a couple of unneeded 'sectors' variables, which makes
the code easier for me to read if nothing else.

The bug was introduced when sd_atapi.c was changed to allow
'incomplete' implementations to be reported as online. REALLY
incomplete implementations (i.e. not even the disksize can be
determined) would be reported online with a blksize of zero.

Also fix a couple of knf nits in Mickey's last commit, and add another
check for an rpm of 0.

ok (pre-Mickey diffs) tdeval@@ marc@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_atapi.c,v 1.3 2003/05/13 00:53:32 krw Exp $	*/
d131 1
a131 1
	    (struct atapi_mode_header *)&sense_data, FLEXGEOMETRYPAGESIZE,
@


1.3
log
@Don't report devices with incomplete implementations as OFFLINE.

Fixes frantzen@@'s pentax digital camera.

Suggested by Costa.

ok csapuntz@@ frantzen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_atapi.c,v 1.2 2002/03/14 01:27:13 millert Exp $	*/
d78 1
a115 3
	dp->disksize = _4btol(descp->nblks);
	dp->blksize = _3btol(descp->blklen);

d117 4
a120 1
	 * First, set up standard fictitious geometry, a la sd_scsi.c.
a121 3
	dp->heads = 64;
	dp->sectors = 32;
	dp->cyls = dp->disksize / (64 * 32);
d123 6
a129 6
	/*
	 * Then try to get something better.  If we can't, that's
	 * still OK.
	 *
	 * XXX Rigid geometry page?
	 */
d135 12
a146 7
	if (error != 0)
		return (SDGP_RESULT_OK);

	dp->heads = sense_data.pages.flex_geometry.nheads;
	dp->sectors = sense_data.pages.flex_geometry.ph_sec_tr;
	dp->cyls = _2btol(sense_data.pages.flex_geometry.ncyl);
	dp->rot_rate = _2btol(sense_data.pages.flex_geometry.rot_rate);
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_atapi.c,v 1.1 1999/07/25 07:09:19 csapuntz Exp $	*/
d104 3
d112 1
a112 3
		/* FALLTHROUGH */
	case ATAPI_CAP_DESC_CODE_NONE:
		return SDGP_RESULT_OFFLINE;
@


1.1
log
@

Merge sd stuff from NetBSD-current. Helps with LS-120, ZIP

More SCSI logic from NetBSD-current

Some tape fixes. ATAPI tapes do not work yet for most operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_atapi.c,v 1.3 1998/08/31 22:28:07 cgd Exp $	*/
d61 2
a62 2
static int	sd_atapibus_get_parms __P((struct sd_softc *,
		    struct disk_parms *, int));
@


1.1.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sd_atapi.c,v 1.1 1999/07/25 07:09:19 csapuntz Exp $	*/
d61 2
a62 2
static int	sd_atapibus_get_parms(struct sd_softc *,
		    struct disk_parms *, int);
@


1.1.14.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a103 3
	case ATAPI_CAP_DESC_CODE_NONE:
		return SDGP_RESULT_OFFLINE;

d109 3
a111 1
		break;
@


1.1.4.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 2
a62 2
static int	sd_atapibus_get_parms(struct sd_softc *,
		    struct disk_parms *, int);
@


1.1.4.2
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@a103 3
	case ATAPI_CAP_DESC_CODE_NONE:
		return SDGP_RESULT_OFFLINE;

d109 3
a111 1
		break;
@


1.1.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a77 1
	u_int16_t rpm;
d115 11
d127 2
a128 2
	 * Try to determine disk size, block size and geometry.  If disk size
	 * (in sectors) can be determined, then fake the rest if necessary.
a131 8
	dp->rot_rate = 3600;
	dp->blksize = _3btol(descp->blklen);
	if (dp->blksize == 0)
		dp->blksize = 512;
	dp->disksize = _4btol(descp->nblks);
	if (dp->disksize == 0)
		return (SDGP_RESULT_OFFLINE);

d137 7
a143 12
	if (error == 0) {
		dp->heads = sense_data.pages.flex_geometry.nheads;
		dp->sectors = sense_data.pages.flex_geometry.ph_sec_tr;
		dp->cyls = _2btol(sense_data.pages.flex_geometry.ncyl);
		rpm = _2btol(sense_data.pages.flex_geometry.rot_rate);
		if (rpm)
			dp->rot_rate = rpm;
	} else {
		dp->heads = 64;
		dp->sectors = 32;
		dp->cyls = dp->disksize / (64 * 32);
	}
@


