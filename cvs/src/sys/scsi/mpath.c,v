head	1.41;
access;
symbols
	OPENBSD_6_2:1.41.0.10
	OPENBSD_6_2_BASE:1.41
	OPENBSD_6_1:1.41.0.8
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.41.0.4
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.8
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.6
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.4
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12;
locks; strict;
comment	@ * @;


1.41
date	2015.08.23.01.55.39;	author tedu;	state Exp;
branches;
next	1.40;
commitid	OczmFvlAy5J4Utsq;

1.40
date	2015.06.07.19.13.27;	author krw;	state Exp;
branches;
next	1.39;
commitid	MxUWuiPFtM1nRYxm;

1.39
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.38;
commitid	p4LJxGKbi0BU2cG6;

1.38
date	2015.03.04.23.52.43;	author dlg;	state Exp;
branches;
next	1.37;
commitid	33cM1FrAqarmSIHa;

1.37
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.36;
commitid	uzzBR7hz9ncd4O6G;

1.36
date	2014.07.12.18.50.25;	author tedu;	state Exp;
branches;
next	1.35;
commitid	iN7nvia2fLP712wt;

1.35
date	2014.05.01.10.25.44;	author jsg;	state Exp;
branches;
next	1.34;

1.34
date	2013.09.08.09.47.36;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2013.08.29.02.54.36;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2013.08.27.00.53.09;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2013.08.26.12.20.12;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2013.08.26.10.13.17;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2013.08.26.07.32.24;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2013.08.26.07.29.45;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2013.08.26.06.54.32;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.10.04.12.57;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.11.01.02.48;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.08.22.09.27;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	2011.06.17.07.06.47;	author mk;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.27.05.22.24;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.17.23.18.01;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.05.14.25.42;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.21.21.34.12;	author todd;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.01.03.01.37;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.27.03.34.29;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	2010.05.20.00.55.18;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2010.01.03.01.36.40;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.01.01.40.02;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.12.06.20.27;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.10.10.13.08;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.05.03.33.52;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.23.01.02.29;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.22.11.56.32;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.14.01.33.22;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2009.09.14.00.03.28;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2009.08.09.16.55.02;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.09.16.20.19;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2009.08.09.12.47.23;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.41
log
@add some sizes to free. looked over by deraadt
@
text
@/*	$OpenBSD: mpath.c,v 1.40 2015/06/07 19:13:27 krw Exp $ */

/*
 * Copyright (c) 2009 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/queue.h>
#include <sys/rwlock.h>
#include <sys/ioctl.h>
#include <sys/poll.h>
#include <sys/selinfo.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/mpathvar.h>

#define MPATH_BUSWIDTH 256

int		mpath_match(struct device *, void *, void *);
void		mpath_attach(struct device *, struct device *, void *);
void		mpath_shutdown(void *);

TAILQ_HEAD(mpath_paths, mpath_path);

struct mpath_group {
	TAILQ_ENTRY(mpath_group) g_entry;
	struct mpath_paths	 g_paths;
	struct mpath_dev	*g_dev;
	u_int			 g_id;
};
TAILQ_HEAD(mpath_groups, mpath_group);

struct mpath_dev {
	struct mutex		 d_mtx;

	struct scsi_xfer_list	 d_xfers;
	struct mpath_path	*d_next_path;

	struct mpath_groups	 d_groups;

	struct mpath_group	*d_failover_iter;
	struct timeout		 d_failover_tmo;
	u_int			 d_failover;

	const struct mpath_ops	*d_ops;
	struct devid		*d_id;
};

struct mpath_softc {
	struct device		sc_dev;
	struct scsi_link	sc_link;
	struct scsibus_softc	*sc_scsibus;
	struct mpath_dev	*sc_devs[MPATH_BUSWIDTH];
};
#define DEVNAME(_s) ((_s)->sc_dev.dv_xname)

struct mpath_softc	*mpath;

struct cfattach mpath_ca = {
	sizeof(struct mpath_softc),
	mpath_match,
	mpath_attach
};

struct cfdriver mpath_cd = {
	NULL,
	"mpath",
	DV_DULL
};

void		mpath_cmd(struct scsi_xfer *);
void		mpath_minphys(struct buf *, struct scsi_link *);
int		mpath_probe(struct scsi_link *);

struct mpath_path *mpath_next_path(struct mpath_dev *);
void		mpath_done(struct scsi_xfer *);

void		mpath_failover(struct mpath_dev *);
void		mpath_failover_start(void *);
void		mpath_failover_check(struct mpath_dev *);

struct scsi_adapter mpath_switch = {
	mpath_cmd,
	scsi_minphys,
	mpath_probe
};

void		mpath_xs_stuffup(struct scsi_xfer *);

int
mpath_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

void
mpath_attach(struct device *parent, struct device *self, void *aux)
{
	struct mpath_softc		*sc = (struct mpath_softc *)self;
	struct scsibus_attach_args	saa;

	mpath = sc;

	printf("\n");

	sc->sc_link.adapter = &mpath_switch;
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = MPATH_BUSWIDTH;
	sc->sc_link.adapter_buswidth = MPATH_BUSWIDTH;
	sc->sc_link.luns = 1;
	sc->sc_link.openings = 1024; /* XXX magical */

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	sc->sc_scsibus = (struct scsibus_softc *)config_found(&sc->sc_dev,
	    &saa, scsiprint);
}

void
mpath_xs_stuffup(struct scsi_xfer *xs)
{
	xs->error = XS_DRIVER_STUFFUP;
	scsi_done(xs);
}

int
mpath_probe(struct scsi_link *link)
{
	struct mpath_softc *sc = link->adapter_softc;
	struct mpath_dev *d = sc->sc_devs[link->target];

	if (link->lun != 0 || d == NULL)
		return (ENXIO);

	link->id = devid_copy(d->d_id);

	return (0);
}

struct mpath_path *
mpath_next_path(struct mpath_dev *d)
{
	struct mpath_group *g;
	struct mpath_path *p;

#ifdef DIAGNOSTIC
	if (d == NULL)
		panic("%s: d is NULL", __func__);
#endif

	p = d->d_next_path;
	if (p != NULL) {
		d->d_next_path = TAILQ_NEXT(p, p_entry);
		if (d->d_next_path == NULL &&
		    (g = TAILQ_FIRST(&d->d_groups)) != NULL)
			d->d_next_path = TAILQ_FIRST(&g->g_paths);
	}

	return (p);
}

void
mpath_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct mpath_softc *sc = link->adapter_softc;
	struct mpath_dev *d = sc->sc_devs[link->target];
	struct mpath_path *p;
	struct scsi_xfer *mxs;

#ifdef DIAGNOSTIC
	if (d == NULL)
		panic("mpath_cmd issued against nonexistant device");
#endif

	if (ISSET(xs->flags, SCSI_POLL)) {
		mtx_enter(&d->d_mtx);
		p = mpath_next_path(d);
		mtx_leave(&d->d_mtx);
		if (p == NULL) {
			mpath_xs_stuffup(xs);
			return;
		}

		mxs = scsi_xs_get(p->p_link, xs->flags);
		if (mxs == NULL) {
			mpath_xs_stuffup(xs);
			return;
		}

		memcpy(mxs->cmd, xs->cmd, xs->cmdlen);
		mxs->cmdlen = xs->cmdlen;
		mxs->data = xs->data;
		mxs->datalen = xs->datalen;
		mxs->retries = xs->retries;
		mxs->timeout = xs->timeout;
		mxs->bp = xs->bp;

		scsi_xs_sync(mxs);

		xs->error = mxs->error;
		xs->status = mxs->status;
		xs->resid = mxs->resid;

		memcpy(&xs->sense, &mxs->sense, sizeof(xs->sense));

		scsi_xs_put(mxs);
		scsi_done(xs);
		return;
	}

	mtx_enter(&d->d_mtx);
	SIMPLEQ_INSERT_TAIL(&d->d_xfers, xs, xfer_list);
	p = mpath_next_path(d);
	mtx_leave(&d->d_mtx);

	if (p != NULL)
		scsi_xsh_add(&p->p_xsh);
}

void
mpath_start(struct mpath_path *p, struct scsi_xfer *mxs)
{
	struct mpath_dev *d = p->p_group->g_dev;
	struct scsi_xfer *xs;
	int addxsh = 0;

	if (ISSET(p->p_link->state, SDEV_S_DYING) || d == NULL)
		goto fail;

	mtx_enter(&d->d_mtx);
	xs = SIMPLEQ_FIRST(&d->d_xfers);
	if (xs != NULL) {
		SIMPLEQ_REMOVE_HEAD(&d->d_xfers, xfer_list);
		if (!SIMPLEQ_EMPTY(&d->d_xfers))
			addxsh = 1;
	}
	mtx_leave(&d->d_mtx);

	if (xs == NULL)
		goto fail;

	memcpy(mxs->cmd, xs->cmd, xs->cmdlen);
	mxs->cmdlen = xs->cmdlen;
	mxs->data = xs->data;
	mxs->datalen = xs->datalen;
	mxs->retries = xs->retries;
	mxs->timeout = xs->timeout;
	mxs->bp = xs->bp;
	mxs->flags = xs->flags;

	mxs->cookie = xs;
	mxs->done = mpath_done;

	scsi_xs_exec(mxs);

	if (addxsh)
		scsi_xsh_add(&p->p_xsh);

	return;
fail:
	scsi_xs_put(mxs);
}

void
mpath_done(struct scsi_xfer *mxs)
{
	struct scsi_xfer *xs = mxs->cookie;
	struct scsi_link *link = xs->sc_link;
	struct mpath_softc *sc = link->adapter_softc;
	struct mpath_dev *d = sc->sc_devs[link->target];
	struct mpath_path *p;

	switch (mxs->error) {
	case XS_SELTIMEOUT: /* physical path is gone, try the next */
	case XS_RESET:
		mtx_enter(&d->d_mtx);
		SIMPLEQ_INSERT_HEAD(&d->d_xfers, xs, xfer_list);
		p = mpath_next_path(d);
		mtx_leave(&d->d_mtx);

		scsi_xs_put(mxs);

		if (p != NULL)
			scsi_xsh_add(&p->p_xsh);
		return;
	case XS_SENSE:
		switch (d->d_ops->op_checksense(mxs)) {
		case MPATH_SENSE_FAILOVER:
			mtx_enter(&d->d_mtx);
			SIMPLEQ_INSERT_HEAD(&d->d_xfers, xs, xfer_list);
			p = mpath_next_path(d);
			mtx_leave(&d->d_mtx);

			scsi_xs_put(mxs);

			mpath_failover(d);
			return;
		case MPATH_SENSE_DECLINED:
			break;
#ifdef DIAGNOSTIC
		default:
			panic("unexpected return from checksense");
#endif
		}
		break;
	}

	xs->error = mxs->error;
	xs->status = mxs->status;
	xs->resid = mxs->resid;

	memcpy(&xs->sense, &mxs->sense, sizeof(xs->sense));

	scsi_xs_put(mxs);

	scsi_done(xs);
}

void
mpath_failover(struct mpath_dev *d)
{
	if (!scsi_pending_start(&d->d_mtx, &d->d_failover))
		return;

	mpath_failover_start(d);
}

void
mpath_failover_start(void *xd)
{
	struct mpath_dev *d = xd;

	mtx_enter(&d->d_mtx);
	d->d_failover_iter = TAILQ_FIRST(&d->d_groups);
	mtx_leave(&d->d_mtx);

	mpath_failover_check(d);
}

void
mpath_failover_check(struct mpath_dev *d)
{
	struct mpath_group *g = d->d_failover_iter;
	struct mpath_path *p;

	if (g == NULL)
		timeout_add_sec(&d->d_failover_tmo, 1);
	else {
		p = TAILQ_FIRST(&g->g_paths);
		d->d_ops->op_status(p->p_link);
	}
}

void
mpath_path_status(struct mpath_path *p, int status)
{
	struct mpath_group *g = p->p_group;
	struct mpath_dev *d = g->g_dev;

	mtx_enter(&d->d_mtx);
	if (status == MPATH_S_ACTIVE) {
		TAILQ_REMOVE(&d->d_groups, g, g_entry);
		TAILQ_INSERT_HEAD(&d->d_groups, g, g_entry);
		d->d_next_path = p;
	} else
		d->d_failover_iter = TAILQ_NEXT(d->d_failover_iter, g_entry);
	mtx_leave(&d->d_mtx);

	if (status == MPATH_S_ACTIVE) {
		scsi_xsh_add(&p->p_xsh);
		if (!scsi_pending_finish(&d->d_mtx, &d->d_failover))
			mpath_failover_start(d);
	} else
		mpath_failover_check(d);
}

void
mpath_minphys(struct buf *bp, struct scsi_link *link)
{
	struct mpath_softc *sc = link->adapter_softc;
	struct mpath_dev *d = sc->sc_devs[link->target];
	struct mpath_group *g;
	struct mpath_path *p;

#ifdef DIAGNOSTIC
	if (d == NULL)
		panic("mpath_minphys against nonexistant device");
#endif

	mtx_enter(&d->d_mtx);
	TAILQ_FOREACH(g, &d->d_groups, g_entry) {
		TAILQ_FOREACH(p, &g->g_paths, p_entry) {
			/* XXX crossing layers with mutex held */
			p->p_link->adapter->scsi_minphys(bp, p->p_link);
		}
	}
	mtx_leave(&d->d_mtx);
}

int
mpath_path_probe(struct scsi_link *link)
{
	if (mpath == NULL)
		return (ENXIO);

	if (link->id == NULL)
		return (EINVAL);

	if (ISSET(link->flags, SDEV_UMASS))
		return (EINVAL);

	if (mpath == link->adapter_softc)
		return (ENXIO);

	return (0);
}

int
mpath_path_attach(struct mpath_path *p, u_int g_id, const struct mpath_ops *ops)
{
	struct mpath_softc *sc = mpath;
	struct scsi_link *link = p->p_link;
	struct mpath_dev *d = NULL;
	struct mpath_group *g;
	int newdev = 0, addxsh = 0;
	int target;

#ifdef DIAGNOSTIC
	if (p->p_link == NULL)
		panic("mpath_path_attach: NULL link");
	if (p->p_group != NULL)
		panic("mpath_path_attach: group is not NULL");
#endif

	for (target = 0; target < MPATH_BUSWIDTH; target++) {
		if ((d = sc->sc_devs[target]) == NULL)
			continue;

		if (DEVID_CMP(d->d_id, link->id) && d->d_ops == ops)
			break;

		d = NULL;
	}

	if (d == NULL) {
		for (target = 0; target < MPATH_BUSWIDTH; target++) {
			if (sc->sc_devs[target] == NULL)
				break;
		}
		if (target >= MPATH_BUSWIDTH)
			return (ENXIO);

		d = malloc(sizeof(*d), M_DEVBUF, M_WAITOK | M_CANFAIL | M_ZERO);
		if (d == NULL)
			return (ENOMEM);

		mtx_init(&d->d_mtx, IPL_BIO);
		TAILQ_INIT(&d->d_groups);
		SIMPLEQ_INIT(&d->d_xfers);
		d->d_id = devid_copy(link->id);
		d->d_ops = ops;

		timeout_set(&d->d_failover_tmo, mpath_failover_start, d);

		sc->sc_devs[target] = d;
		newdev = 1;
	} else {
		/*
		 * instead of carrying identical values in different devid
		 * instances, delete the new one and reference the old one in
		 * the new scsi_link.
		 */
		devid_free(link->id);
		link->id = devid_copy(d->d_id);
	}

	TAILQ_FOREACH(g, &d->d_groups, g_entry) {
		if (g->g_id == g_id)
			break;
	}

	if (g == NULL) {
		g = malloc(sizeof(*g),  M_DEVBUF,
		    M_WAITOK | M_CANFAIL | M_ZERO);
		if (g == NULL) {
			if (newdev) {
				free(d, M_DEVBUF, sizeof(*d));
				sc->sc_devs[target] = NULL;
			}

			return (ENOMEM);
		}

		TAILQ_INIT(&g->g_paths);
		g->g_dev = d;
		g->g_id = g_id;

		mtx_enter(&d->d_mtx);
		TAILQ_INSERT_TAIL(&d->d_groups, g, g_entry);
		mtx_leave(&d->d_mtx);
	}

	p->p_group = g;

	mtx_enter(&d->d_mtx);
	TAILQ_INSERT_TAIL(&g->g_paths, p, p_entry);
	if (!SIMPLEQ_EMPTY(&d->d_xfers))
		addxsh = 1;

	if (d->d_next_path == NULL)
		d->d_next_path = p;
	mtx_leave(&d->d_mtx);

	if (newdev)
		scsi_probe_target(mpath->sc_scsibus, target);
	else if (addxsh)
		scsi_xsh_add(&p->p_xsh);

	return (0);
}

int
mpath_path_detach(struct mpath_path *p)
{
	struct mpath_group *g = p->p_group;
	struct mpath_dev *d;
	struct mpath_path *np = NULL;

#ifdef DIAGNOSTIC
	if (g == NULL)
		panic("mpath: detaching a path from a nonexistant bus");
#endif
	d = g->g_dev;
	p->p_group = NULL;

	mtx_enter(&d->d_mtx);
	TAILQ_REMOVE(&g->g_paths, p, p_entry);
	if (d->d_next_path == p)
		d->d_next_path = TAILQ_FIRST(&g->g_paths);

	if (TAILQ_EMPTY(&g->g_paths))
		TAILQ_REMOVE(&d->d_groups, g, g_entry);
	else
		g = NULL;

	if (!SIMPLEQ_EMPTY(&d->d_xfers))
		np = d->d_next_path;
	mtx_leave(&d->d_mtx);

	if (g != NULL)
		free(g, M_DEVBUF, sizeof(*g));

	scsi_xsh_del(&p->p_xsh);

	if (np == NULL)
		mpath_failover(d);
	else
		scsi_xsh_add(&np->p_xsh);

	return (0);
}

struct device *
mpath_bootdv(struct device *dev)
{
	struct mpath_softc *sc = mpath;
	struct mpath_dev *d;
	struct mpath_group *g;
	struct mpath_path *p;
	int target;

	if (sc == NULL)
		return (dev);

	for (target = 0; target < MPATH_BUSWIDTH; target++) {
		if ((d = sc->sc_devs[target]) == NULL)
			continue;

		TAILQ_FOREACH(g, &d->d_groups, g_entry) {
			TAILQ_FOREACH(p, &g->g_paths, p_entry) {
				if (p->p_link->device_softc == dev) {
					return (scsi_get_link(mpath->sc_scsibus,
					    target, 0)->device_softc);
				}
			}
		}
	}

	return (dev);
}
@


1.40
log
@More damned eye searing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.39 2015/03/14 03:38:52 jsg Exp $ */
d507 1
a507 1
				free(d, M_DEVBUF, 0);
d571 1
a571 1
		free(g, M_DEVBUF, 0);
@


1.39
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.38 2015/03/04 23:52:43 dlg Exp $ */
d21 1
a21 1
#include <sys/kernel.h>  
@


1.38
log
@prevent umass devices from being considered for paths.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.37 2014/09/14 14:17:26 jsg Exp $ */
a20 1
#include <sys/buf.h>
@


1.37
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.36 2014/07/12 18:50:25 tedu Exp $ */
d428 3
@


1.36
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.35 2014/05/01 10:25:44 jsg Exp $ */
a24 1
#include <sys/proc.h>
@


1.35
log
@move pointer use to after a NULL pointer check
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.34 2013/09/08 09:47:36 dlg Exp $ */
d506 1
a506 1
				free(d, M_DEVBUF);
d570 1
a570 1
		free(g, M_DEVBUF);
@


1.34
log
@fix next path selection so if the current path is NULL (which can occur if
paths are lost and groups become empty) we dont try and do stuff with it
that causes null derefs and awesome panics.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.33 2013/08/29 02:54:36 dlg Exp $ */
d545 1
a545 1
	struct mpath_dev *d = g->g_dev;
d552 1
@


1.33
log
@rename scsi_sem_{enter,leave} to scsi_pending_{start,finish}. these are
the wrappers around handling of pending work, theyre not semaphores.

names from tedu@@
ok krw@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.32 2013/08/27 00:53:09 dlg Exp $ */
d173 5
a177 4
	d->d_next_path = TAILQ_NEXT(p, p_entry);
	if (d->d_next_path == NULL) {
		g = TAILQ_FIRST(&d->d_groups);
		d->d_next_path = TAILQ_FIRST(&g->g_paths);
@


1.32
log
@get rid of the different path scheduler types, which simplifies the
code that picks the next path. we assume roundrobin within a group
of paths now. the asym sym(4) devices work around this by putting
every path in its own group.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.31 2013/08/26 12:20:12 dlg Exp $ */
d343 1
a343 1
	if (!scsi_sem_enter(&d->d_mtx, &d->d_failover))
d392 1
a392 1
		if (!scsi_sem_leave(&d->d_mtx, &d->d_failover))
@


1.31
log
@implement handling of group failover.

if a controller sends sense data back, the path driver can tell
mpath that its indicating failover which kicks off an iteration
over all the groups until one says its active. if no groups claim
to be active, a timeout fires the process off again after a second.

you can start controller handover on rdac (well, an md3200i is all
i had to test with, others might need more work) and everything
keeps going. ill try to get to emc and hds working when i can poke
hardware again.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.26 2013/06/10 04:12:57 dlg Exp $ */
d95 1
a95 1
struct mpath_path *mpath_next_path(struct mpath_dev *, int);
d162 1
a162 1
mpath_next_path(struct mpath_dev *d, int next)
d167 1
d170 1
d173 4
a176 6
	if (p != NULL && next == MPATH_NEXT) {
		d->d_next_path = TAILQ_NEXT(p, p_entry);
		if (d->d_next_path == NULL) {
			g = TAILQ_FIRST(&d->d_groups);
			d->d_next_path = TAILQ_FIRST(&g->g_paths);
		}
d198 1
a198 1
		p = mpath_next_path(d, d->d_ops->op_schedule);
d234 1
a234 1
	p = mpath_next_path(d, d->d_ops->op_schedule);
a292 1
	int next = d->d_ops->op_schedule;
a295 1
		next = MPATH_NEXT;
d299 1
a299 1
		p = mpath_next_path(d, next);
d312 1
a312 1
			p = mpath_next_path(d, next);
@


1.30
log
@when i first imagined how paths on mpath worked, i thought the
midlayer would be able to call things on paths to explicitely online
or offline them. turns out thats not how the Real World(tm) works,
instead its better to wait for failure and probe for the status of
paths, and pick the active group of paths from that. there's even
evidence that the mechanisms for forcing controllers into active/passive
roles from the scsi initiator are being deprecated. they expect
hosts to be able to cope with arbitrary controller role changes and
failover
accordingly.

this replaces the online and offline function pointers in the path_ops
structure with a status check function pointer. instead of returning a
state, the checker is expected to call mpath_path_status() when its
finished figuring out what the state is.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.29 2013/08/26 07:32:24 dlg Exp $ */
d48 1
d57 2
d60 4
a63 1
	struct mpath_path	*d_next_path;
d98 4
d244 1
a244 1
	struct mpath_dev *d = p->p_dev;
d308 10
d319 10
a328 1
		return;
d343 58
d451 2
a452 2
	if (p->p_dev != NULL)
		panic("mpath_path_attach: dev is not NULL");
d483 2
d515 1
d523 1
a523 1
	p->p_dev = d;
a525 4

	if (d->d_next_path == NULL)
		d->d_next_path = p;

a526 1

d530 2
d545 2
a546 2
	struct mpath_dev *d = p->p_dev;
	struct mpath_group *g;
d550 1
a550 1
	if (d == NULL)
d553 1
a553 1
	p->p_dev = NULL;
a555 2
	g = TAILQ_FIRST(&d->d_groups);

d560 1
a560 1
	if (TAILQ_EMPTY(&g->g_paths)) {
d562 2
a563 2
		free(g, M_DEVBUF);
	}
d569 3
d574 3
a576 1
	if (np != NULL)
a579 6
}

void
mpath_path_status(struct mpath_path *p, int status)
{

@


1.29
log
@free the dev slot on group allocation failure if we're building a new dev.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.28 2013/08/26 07:29:45 dlg Exp $ */
d490 6
@


1.28
log
@introduce the idea of groups of paths. mpath had stuff to managed
devices and paths. devices are what mpath presents as targets on
its scsibus, and paths are the things attached to hardware controllers
that are available to shove io down to the actual real target. all
paths were considered usable for handling io on behalf of a device.

this adds groups in between devices and paths. only paths on the
first group in the list will now be used to handle io now.

sym devices will only have one group. asym devices will treat each
path as a different group. rdac, emc, and hds will group paths based
on which controller in the array theyre connected to.

in the future we will intercept sense data from passive controllers
and use that to start running checks to pick a new primary group
so we can handle controller failover situations.

the group id in hds(4) is currently busted, everything else should
be correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.27 2013/08/26 06:54:32 dlg Exp $ */
d417 1
a417 1
			if (newdev)
d419 2
@


1.27
log
@now that mpath is attached before any hardware, we can simplify the code.

firstly, move the array of targets that mpath presents into the softc.

secondly, when paths call the mpath api we can simply check if the softc
global is not null rather than walk through autoconf data. mpath will either
have already attached or will never attach in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.26 2013/06/10 04:12:57 dlg Exp $ */
d45 7
d56 1
a56 1
	struct mpath_paths	 d_paths;
a58 2
	u_int			 d_path_count;

d154 1
d163 4
a166 2
		if (d->d_next_path == NULL)
			d->d_next_path = TAILQ_FIRST(&d->d_paths);
d318 1
d326 8
a333 2
	TAILQ_FOREACH(p, &d->d_paths, p_entry)
		p->p_link->adapter->scsi_minphys(bp, p->p_link);
d352 1
a352 1
mpath_path_attach(struct mpath_path *p, const struct mpath_ops *ops)
d357 1
d386 1
a386 2
		d = malloc(sizeof(*d), M_DEVBUF,
		    M_WAITOK | M_CANFAIL | M_ZERO);
d391 1
a391 1
		TAILQ_INIT(&d->d_paths);
d408 23
d432 1
d434 2
a435 1
	if (TAILQ_EMPTY(&d->d_paths))
d437 3
a439 2
	TAILQ_INSERT_TAIL(&d->d_paths, p, p_entry);
	d->d_path_count++;
d442 1
d445 1
a445 1
	if (newdev && mpath != NULL)
d457 1
d467 3
a469 1
	TAILQ_REMOVE(&d->d_paths, p, p_entry);
d471 6
a476 1
		d->d_next_path = TAILQ_FIRST(&d->d_paths);
a477 1
	d->d_path_count--;
d495 1
d506 6
a511 4
		TAILQ_FOREACH(p, &d->d_paths, p_entry) {
			if (p->p_link->device_softc == dev) {
				return (scsi_get_link(mpath->sc_scsibus,
				    target, 0)->device_softc);
@


1.26
log
@we dont need mpath ccbs if all theyre used for is storing xfers on a list.
we can just use the SIMPLEQ bits that are in xfers directly. this cuts out
a bunch of pools and iopools goo. less is more.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.25 2011/07/17 22:46:48 matthew Exp $ */
d62 1
a66 1
struct mpath_dev	*mpath_devs[MPATH_BUSWIDTH];
d135 2
a136 1
	struct mpath_dev *d = mpath_devs[link->target];
d168 2
a169 1
	struct mpath_dev *d = mpath_devs[link->target];
d272 2
a273 1
	struct mpath_dev *d = mpath_devs[link->target];
d308 2
a309 1
	struct mpath_dev *d = mpath_devs[link->target];
d324 1
a324 13
	static struct cfdata *cf = NULL;

	if (cf == NULL) {
		for (cf = cfdata; cf->cf_attach != (struct cfattach *)-1;
		    cf++) {
			if (cf->cf_attach == NULL)
				continue;
			if (cf->cf_driver == &mpath_cd)
				break;
		}
	}

	if (cf->cf_fstate == FSTATE_DNOTFOUND || cf->cf_fstate == FSTATE_DSTAR)
d330 1
a330 1
	if (mpath != NULL && mpath == link->adapter_softc)
d339 1
d353 1
a353 1
		if ((d = mpath_devs[target]) == NULL)
d364 1
a364 1
			if (mpath_devs[target] == NULL)
d381 1
a381 1
		mpath_devs[target] = d;
d444 1
d449 1
a449 1
	if (mpath == NULL)
d453 1
a453 1
		if ((d = mpath_devs[target]) == NULL)
@


1.25
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.24 2011/07/11 01:02:48 dlg Exp $ */
a28 1
#include <sys/pool.h>
a44 6
struct mpath_ccb {
	struct scsi_xfer	*c_xs;
	SIMPLEQ_ENTRY(mpath_ccb) c_entry;
};
SIMPLEQ_HEAD(mpath_ccbs, mpath_ccb);

d48 1
a48 1
	struct mpath_ccbs	 d_ccbs;
a60 2
	struct pool		sc_ccb_pool;
	struct scsi_iopool	sc_iopool;
a94 3
void *		mpath_ccb_get(void *);
void		mpath_ccb_put(void *, void *);

a110 6
	pool_init(&sc->sc_ccb_pool, sizeof(struct mpath_ccb), 0, 0, 0,
	    "mpathccb", NULL);
	pool_setipl(&sc->sc_ccb_pool, IPL_BIO);

	scsi_iopool_init(&sc->sc_iopool, sc, mpath_ccb_get, mpath_ccb_put);

a116 1
	sc->sc_link.pool = &sc->sc_iopool;
a167 1
	struct mpath_ccb *ccb = xs->io;
a211 2
	ccb->c_xs = xs;

d213 1
a213 1
	SIMPLEQ_INSERT_TAIL(&d->d_ccbs, ccb, c_entry);
a224 1
	struct mpath_ccb *ccb;
d232 4
a235 4
	ccb = SIMPLEQ_FIRST(&d->d_ccbs);
	if (ccb != NULL) {
		SIMPLEQ_REMOVE_HEAD(&d->d_ccbs, c_entry);
		if (!SIMPLEQ_EMPTY(&d->d_ccbs))
d240 1
a240 1
	if (ccb == NULL)
a242 2
	xs = ccb->c_xs;

a269 1
	struct mpath_ccb *ccb = xs->io;
d279 1
a279 1
		SIMPLEQ_INSERT_HEAD(&d->d_ccbs, ccb, c_entry);
d384 1
a384 1
		SIMPLEQ_INIT(&d->d_ccbs);
d406 1
a406 1
	if (!SIMPLEQ_EMPTY(&d->d_ccbs))
d436 1
a436 1
	if (!SIMPLEQ_EMPTY(&d->d_ccbs))
a445 16
}

void *
mpath_ccb_get(void *cookie)
{
	struct mpath_softc *sc = cookie;

	return (pool_get(&sc->sc_ccb_pool, PR_NOWAIT));
}

void
mpath_ccb_put(void *cookie, void *io)
{
	struct mpath_softc *sc = cookie;

	pool_put(&sc->sc_ccb_pool, io);
@


1.24
log
@support "failover" style access to volumes, ie, only use one active
path when talking to an array until it goes away, then you fail
over to the next active path.

im using this to talk to ses(4) in my dell, and allows us to support
arrays that have multiple controllers but have no way of reporting
which one is active. using the MRU semantic means we can talk to
them without them flipping the active role between its controllers
all the time. claudios transtec iscsi box is like this.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.23 2011/07/08 22:09:27 matthew Exp $ */
d132 2
a138 2
	saa.saa_targets = MPATH_BUSWIDTH;
	saa.saa_luns = 1;
@


1.23
log
@First batch of converting SCSI HBAs from setting saa_targets and
saa_luns instead of adapter_buswidth and luns in the prototype link.

ok dlg@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.22 2011/06/17 07:06:47 mk Exp $ */
d61 1
d93 1
a93 1
struct mpath_path *mpath_next_path(struct mpath_dev *);
d165 1
a165 1
mpath_next_path(struct mpath_dev *d)
d173 1
a173 1
	if (p != NULL) {
d198 1
a198 1
		p = mpath_next_path(d);
d236 1
a236 1
	p = mpath_next_path(d);
d298 1
d300 4
a303 1
	if (mxs->error == XS_RESET || mxs->error == XS_SELTIMEOUT) {
d306 1
a306 1
		p = mpath_next_path(d);
d371 1
a371 1
mpath_path_attach(struct mpath_path *p)
d389 1
a389 1
		if (DEVID_CMP(d->d_id, link->id))
d412 1
@


1.22
log
@M_WAITOK cleanup of two cases:

1) Allocating with M_WAITOK, checking for NULL, and calling panic() is
pointless (malloc() will panic if it can't allocate) so remove the check
and the call.

2) Allocating with M_WAITOK, checking for NULL, and then gracefully
handling failure to allocate is pointless.  Instead also pass M_CANFAIL
so malloc() doesn't panic so we can actually handle it gracefully.

1) was done using Coccinelle.

Input from oga.

ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.21 2011/04/27 05:22:24 dlg Exp $ */
a130 2
	sc->sc_link.adapter_buswidth = MPATH_BUSWIDTH;
	sc->sc_link.luns = 1;
d136 2
@


1.21
log
@if a path returns XS_SELTIMEOUT, retry the io down another path like we
do for XS_RESET. adapters return SELTIMEOUT when the device is gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.20 2011/04/17 23:18:01 dlg Exp $ */
d398 2
a399 1
		d = malloc(sizeof(*d), M_DEVBUF, M_WAITOK | M_ZERO);
@


1.20
log
@if mpath is disabled in config or ukc, then prevent path drivers from
attaching since theyre useless without mpath.

the path drivers ask mpath if its ok to use the device before doing their
own matches (this is so mpath can prevent paths attaching to itself), so
im just adding this check there.

this uses code from miod to walk cfdata for the mpath entry and then checks
its state. this is ok because mpath is only attached in one place, so there
arent multiple cfdata entries for it.

ok krw@@ deraadt@@ miod@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.19 2011/04/05 14:25:42 dlg Exp $ */
d298 1
a298 1
	if (mxs->error == XS_RESET) {
@


1.19
log
@move forward with scsi multipathing.

the big change is how paths between mpath capable devices and the
kernel are managed.

originally the midlayer would steal the links to the devices and
hide them behind mpath. all the changes an adapter made to a link
(eg activate or detach), the midlayer had to test if it was an mpath
link and then call special mpath code to handle it.

the original code also assumed that all paths behaved the same, but
the reality is that different devices have different command sets
and behaviours. figuring out which behaviour to pick and prioritising
them is basically the same job autoconf does with match and attach.

rather than special casing mpath in the midlayer and reimplimenting
autoconf, this turns paths into actual device drivers with match
and attach routines. after they figure out if the path is active,
they then give it to mpath(4) to use as a backend.

i have written drivers for symmetric access devices (sym(4)) where
all paths to the same logical unit are as good as each other,
lsi/engenio arrays (rdac(4), and emc arrays (emc(4)).

the rdac and emc drivers only detect active paths at attach time,
the do not cope if the controller changes state unless you unplug
the path and plug it in again to retest the active state. they also
do not have support for directing array failover.

operating and hoplugging has been tested with mpii(4), fc and sas
mpi(4), and iscsi via vscsi (claudio did this too).

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.18 2010/07/21 21:34:12 todd Exp $ */
d341 15
@


1.18
log
@let mpath build again even though it is disabled
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.17 2010/07/01 03:01:37 matthew Exp $ */
d36 1
d44 5
a48 3
struct mpath_path {
	struct scsi_link	*path_link;
	TAILQ_ENTRY(mpath_path)	 path_entry;
d50 10
a59 1
TAILQ_HEAD(mpath_paths, mpath_path);
d61 1
a61 3
struct mpath_node {
	struct devid		*node_id;
	struct mpath_paths	 node_paths;
d67 2
d71 1
d74 1
a74 3
struct mpath_node	*mpath_nodes[MPATH_BUSWIDTH];

#define DEVNAME(_s) ((_s)->sc_dev.dv_xname)
d92 1
d98 1
a98 2
	mpath_probe,
	NULL
d103 3
d122 6
d132 3
a134 1
	sc->sc_link.openings = 1;
d153 1
a153 1
	struct mpath_node *n = mpath_nodes[link->target];
d155 1
a155 1
	if (link->lun != 0 || n == NULL)
d158 1
a158 1
	link->id = devid_copy(n->node_id);
d163 18
d185 3
a187 2
	struct mpath_node *n = mpath_nodes[link->target];
	struct mpath_path *p = TAILQ_FIRST(&n->node_paths);
d190 38
a227 2
	if (n == NULL || p == NULL) {
		mpath_xs_stuffup(xs);
d231 28
a258 4
	mxs = scsi_xs_get(p->path_link, xs->flags);
	if (mxs == NULL) {
		mpath_xs_stuffup(xs);
		return;
d260 6
d274 1
d280 7
d293 18
a313 1
	xs->flags = mxs->flags;
d326 1
a326 1
	struct mpath_node *n = mpath_nodes[link->target];
d329 17
a345 2
	if (n == NULL)
		return;
d347 1
a347 2
	TAILQ_FOREACH(p, &n->node_paths, path_entry)
		p->path_link->adapter->scsi_minphys(bp, p->path_link);
d351 1
a351 1
mpath_path_attach(struct scsi_link *link)
d353 3
a355 3
	struct mpath_node *n;
	struct mpath_path *p;
	int probe = 0;
d358 6
a363 6
	if (mpath != NULL && link->adapter_softc == mpath)
		return (ENODEV);

	/* XXX this is dumb. should check inq shizz */
	if (ISSET(link->flags, SDEV_VIRTUAL) || link->id == NULL)
		return (ENXIO);
d366 1
a366 1
		if ((n = mpath_nodes[target]) == NULL)
d369 1
a369 1
		if (DEVID_CMP(n->node_id, link->id))
d372 1
a372 1
		n = NULL;
d375 1
a375 1
	if (n == NULL) {
d377 1
a377 1
			if (mpath_nodes[target] == NULL)
d383 8
a390 4
		n = malloc(sizeof(*n), M_DEVBUF, M_WAITOK | M_ZERO);
		TAILQ_INIT(&n->node_paths);

		n->node_id = devid_copy(link->id);
d392 2
a393 2
		mpath_nodes[target] = n;
		probe = 1;
d401 1
a401 1
		link->id = devid_copy(n->node_id);
d404 9
a412 1
	p = malloc(sizeof(*p), M_DEVBUF, M_WAITOK);
d414 1
a414 4
	p->path_link = link;
	TAILQ_INSERT_TAIL(&n->node_paths, p, path_entry);

	if (mpath != NULL && probe)
d416 2
d423 1
a423 1
mpath_path_detach(struct scsi_link *link, int flags)
d425 8
a432 3
	struct mpath_node *n;
	struct mpath_path *p;
	int target;
d434 9
a442 3
	for (target = 0; target < MPATH_BUSWIDTH; target++) {
		if ((n = mpath_nodes[target]) == NULL)
			continue;
d444 1
a444 2
		if (DEVID_CMP(n->node_id, link->id))
			break;
d446 2
a447 2
		n = NULL;
	}
d449 2
a450 2
	if (n == NULL)
		panic("mpath: detaching a path from a nonexistant bus");
d452 4
a455 7
	TAILQ_FOREACH(p, &n->node_paths, path_entry) {
		if (p->path_link == link) {
			TAILQ_REMOVE(&n->node_paths, p, path_entry);
			free(p, M_DEVBUF);
			return (0);
		}
	}
d457 1
a457 1
	panic("mpath: unable to locate path for detach");
d461 1
a461 1
mpath_path_activate(struct scsi_link *link)
d463 1
d465 1
d468 2
a469 2
void
mpath_path_deactivate(struct scsi_link *link)
d471 10
d482 9
a491 1

@


1.17
log
@Restore setting xs->bp; fixes ncr(4) on VAX.

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.16 2010/06/28 18:31:02 krw Exp $ */
a177 1
	int s;
@


1.16
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.15 2010/06/27 03:34:29 matthew Exp $ */
d166 1
@


1.15
log
@"Believe it or not," nothing uses scsi_xfer's req_sense_length field
in any meaningful way, so just get rid of it.

ok krw@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.14 2010/05/20 00:55:18 krw Exp $ */
a89 4
struct scsi_device mpath_dev = {
	NULL, NULL, NULL, NULL
};

a107 1
	sc->sc_link.device = &mpath_dev;
@


1.14
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.13 2010/03/23 01:57:20 krw Exp $ */
a170 1
	mxs->req_sense_length = xs->req_sense_length;
@


1.13
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.12 2010/01/03 01:36:40 dlg Exp $ */
a128 2
	int s;

a129 1
	s = splbio();
a130 1
	splx(s);
a193 1
	s = splbio();
a194 1
	splx(s);
@


1.12
log
@scsi_done sets ITSDONE, we dont have to do it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.11 2009/12/01 01:40:02 dlg Exp $ */
d77 1
a77 1
int		mpath_cmd(struct scsi_xfer *);
d150 1
a150 1
int
d160 1
a160 1
		return (COMPLETE);
d166 1
a166 1
		return (COMPLETE);
a180 2

	return (COMPLETE); /* doesnt matter anymore */
@


1.11
log
@put the midlayer changes back in.

the two issues affecting it last time are gone. the first, mishandling of
TRY_AGAIN_LATER is not relevant now that krw got rid of TRY_AGAIN_LATER.
the second, the misbehaving IBM disk was found to be a problem with siop
using ordered tags on most ops combined with the speed of the new code.

putting this in so we can move forward.

ok krw@@ "commit please" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.10 2009/11/12 06:20:27 dlg Exp $ */
a131 1
	xs->flags |= ITSDONE;
@


1.10
log
@revert midlayer back to it was before i put my big rewrite in. this is
causing a weird problems on an alpha and also appears responsible for
isp(4) weirdness i havent had a chance to examine yet.

sigh, this makes me sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.8 2009/11/05 03:33:52 marco Exp $ */
d50 1
a50 1
	struct devid		 node_id;
d81 2
d141 3
a143 1
	if (link->lun != 0 || mpath_nodes[link->target] == NULL)
d146 2
d157 1
a157 2
	int rv;
	int s;
d164 32
a195 4
	rv = scsi_scsi_cmd(p->path_link, xs->cmd, xs->cmdlen,
	    xs->data, xs->datalen,
	    2, xs->timeout, NULL, SCSI_POLL |
	    (xs->flags & (SCSI_DATA_IN|SCSI_DATA_OUT)));
d197 1
d199 1
a199 10
	xs->flags |= ITSDONE;
	if (rv == 0) {
		xs->error = XS_NOERROR;
		xs->status = SCSI_OK;
		xs->resid = 0;
	} else {
		printf("%s: t%dl%d rv %d cmd %x\n", DEVNAME(mpath),
		    link->target, link->lun, rv, xs->cmd->opcode);
		xs->error = XS_DRIVER_STUFFUP;
	}
a203 2

	return (COMPLETE);
d231 1
a231 1
	if (link->id.d_type == DEVID_NONE)
d238 1
a238 1
		if (DEVID_CMP(&n->node_id, &link->id))
d255 1
a255 4
		n->node_id.d_type = link->id.d_type;
		n->node_id.d_len = link->id.d_len;
		n->node_id.d_id = malloc(n->node_id.d_len, M_DEVBUF, M_DEVBUF);
		memcpy(n->node_id.d_id, link->id.d_id, n->node_id.d_len);
d259 8
d291 1
a291 1
		if (DEVID_CMP(&n->node_id, &link->id))
d310 13
@


1.9
log
@backout the backout marco did of my code because of the NO_CCB breakage.
the fix for the NO_CCB breakage will follow shortly.

tested by krw@@ marco@@ johan@@
ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.6 2009/10/22 11:56:32 dlg Exp $ */
d50 1
a50 1
	struct devid		*node_id;
a80 2
void		mpath_done(struct scsi_xfer *);

d139 1
a139 3
	struct mpath_node *n = mpath_nodes[link->target];

	if (link->lun != 0 || n == NULL)
a141 2
	link->id = devid_copy(n->node_id);

d151 2
a152 1
	struct scsi_xfer *mxs;
d159 4
a162 5
	mxs = scsi_xs_get(p->path_link, xs->flags);
	if (mxs == NULL) {
		mpath_xs_stuffup(xs);
		return (COMPLETE);
	}
a163 7
	memcpy(mxs->cmd, xs->cmd, xs->cmdlen);
	mxs->cmdlen = xs->cmdlen;
	mxs->data = xs->data;
	mxs->datalen = xs->datalen;
	mxs->retries = xs->retries;
	mxs->timeout = xs->timeout;
	mxs->req_sense_length = xs->req_sense_length;
d165 10
a174 22
	mxs->cookie = xs;
	mxs->done = mpath_done;

	scsi_xs_exec(mxs);

	return (COMPLETE); /* doesnt matter anymore */
}

void
mpath_done(struct scsi_xfer *mxs)
{
	struct scsi_xfer *xs = mxs->cookie;
	int s;

	xs->error = mxs->error;
	xs->status = mxs->status;
	xs->flags = mxs->flags;
	xs->resid = mxs->resid;

	memcpy(&xs->sense, &mxs->sense, sizeof(xs->sense));

	scsi_xs_put(mxs);
d179 2
d208 1
a208 1
	if (ISSET(link->flags, SDEV_VIRTUAL) || link->id == NULL)
d215 1
a215 1
		if (DEVID_CMP(n->node_id, link->id))
d232 4
a235 1
		n->node_id = devid_copy(link->id);
a238 8
	} else {
		/*
		 * instead of carrying identical values in different devid
		 * instances, delete the new one and reference the old one in
		 * the new scsi_link.
		 */
		devid_free(link->id);
		link->id = devid_copy(n->node_id);
d263 1
a263 1
		if (DEVID_CMP(n->node_id, link->id))
a281 13

void
mpath_path_activate(struct scsi_link *link)
{

}

void
mpath_path_deactivate(struct scsi_link *link)
{

}

@


1.8
log
@The big diff dlg committed to the midlayer breaks NO_CCB and
TRY_AGAIN_LATER.  NO_CCB is a timer based mechanism that can trivially
be made to fail by running IO to two or more disks simultaneously.  The
TRY_AGAIN_LATER thing is more subtle because it now is a permanent
failure instead of transient however this is much harder to hit because
something must have gone wrong before it hits.

ok deraadt krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.3 2009/08/09 16:55:02 dlg Exp $ */
d50 1
a50 1
	struct devid		 node_id;
d81 2
d141 3
a143 1
	if (link->lun != 0 || mpath_nodes[link->target] == NULL)
d146 2
d157 1
a157 2
	int rv;
	int s;
d164 32
a195 4
	rv = scsi_scsi_cmd(p->path_link, xs->cmd, xs->cmdlen,
	    xs->data, xs->datalen,
	    2, xs->timeout, NULL, SCSI_POLL |
	    (xs->flags & (SCSI_DATA_IN|SCSI_DATA_OUT)));
d197 1
d199 1
a199 10
	xs->flags |= ITSDONE;
	if (rv == 0) {
		xs->error = XS_NOERROR;
		xs->status = SCSI_OK;
		xs->resid = 0;
	} else {
		printf("%s: t%dl%d rv %d cmd %x\n", DEVNAME(mpath),
		    link->target, link->lun, rv, xs->cmd->opcode);
		xs->error = XS_DRIVER_STUFFUP;
	}
a203 2

	return (COMPLETE);
d231 1
a231 1
	if (link->id.d_type == DEVID_NONE)
d238 1
a238 1
		if (DEVID_CMP(&n->node_id, &link->id))
d255 1
a255 4
		n->node_id.d_type = link->id.d_type;
		n->node_id.d_len = link->id.d_len;
		n->node_id.d_id = malloc(n->node_id.d_len, M_DEVBUF, M_DEVBUF);
		memcpy(n->node_id.d_id, link->id.d_id, n->node_id.d_len);
d259 8
d291 1
a291 1
		if (DEVID_CMP(&n->node_id, &link->id))
d310 13
@


1.7
log
@if you're attempting to detach multiple devices (eg, many targets,
many luns, or the entire bus), dont report ENXIO as an error to the
caller. this broke autoconf when it tried to forcefully remove a
bus such as umass and it thought there was a failure.

this introduces a way for scsi hbas to call activate/deactivate on
a device based on its target/lun address via a call to scsi_activate().
they can then schedule the actual detach/attach in a thread later via
scsi_req_probe/detach.

the mpi changes tweak the sas event handling code to use these apis
to properly handle attaches and detaches of disks. event handling
is still disabled till i can make it less chatty.

umass breakage reported by form@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.6 2009/10/22 11:56:32 dlg Exp $ */
d50 1
a50 1
	struct devid		*node_id;
a80 2
void		mpath_done(struct scsi_xfer *);

d139 1
a139 3
	struct mpath_node *n = mpath_nodes[link->target];

	if (link->lun != 0 || n == NULL)
a141 2
	link->id = devid_copy(n->node_id);

d151 2
a152 1
	struct scsi_xfer *mxs;
d159 4
a162 5
	mxs = scsi_xs_get(p->path_link, xs->flags);
	if (mxs == NULL) {
		mpath_xs_stuffup(xs);
		return (COMPLETE);
	}
a163 7
	memcpy(mxs->cmd, xs->cmd, xs->cmdlen);
	mxs->cmdlen = xs->cmdlen;
	mxs->data = xs->data;
	mxs->datalen = xs->datalen;
	mxs->retries = xs->retries;
	mxs->timeout = xs->timeout;
	mxs->req_sense_length = xs->req_sense_length;
d165 10
a174 22
	mxs->cookie = xs;
	mxs->done = mpath_done;

	scsi_xs_exec(mxs);

	return (COMPLETE); /* doesnt matter anymore */
}

void
mpath_done(struct scsi_xfer *mxs)
{
	struct scsi_xfer *xs = mxs->cookie;
	int s;

	xs->error = mxs->error;
	xs->status = mxs->status;
	xs->flags = mxs->flags;
	xs->resid = mxs->resid;

	memcpy(&xs->sense, &mxs->sense, sizeof(xs->sense));

	scsi_xs_put(mxs);
d179 2
d208 1
a208 1
	if (ISSET(link->flags, SDEV_VIRTUAL) || link->id == NULL)
d215 1
a215 1
		if (DEVID_CMP(n->node_id, link->id))
d232 4
a235 1
		n->node_id = devid_copy(link->id);
a238 8
	} else {
		/*
		 * instead of carrying identical values in different devid
		 * instances, delete the new one and reference the old one in
		 * the new scsi_link.
		 */
		devid_free(link->id);
		link->id = devid_copy(n->node_id);
d263 1
a263 1
		if (DEVID_CMP(n->node_id, link->id))
a281 13

void
mpath_path_activate(struct scsi_link *link)
{

}

void
mpath_path_deactivate(struct scsi_link *link)
{

}

@


1.6
log
@devices below the scsibus should all be detached via scsi_detach_lun.
scsibusdetach wasnt doign it properly, so we would be leaking on detach in
some cases.

now, with the introduction of mpath, the scsi_link structures can
represent a path to a mpath node as well as normal devices. this
intercepts the device activate entrypoints and sends them to mpath
if it it in use rather than assuming a device is always there. the
scsibusdetach change ensures that detach always ends up handling
the mpath node case too.

hotplug bus functionality (eg, usb) tested by form@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.5 2009/10/14 01:33:22 dlg Exp $ */
d311 1
a311 1
int
d314 1
a314 1
	return (0);
d317 1
a317 1
int
d320 1
a320 1
	return (0);
@


1.5
log
@rework how devids are handled in the midlayer and mpath.

previously a devid was a structure containing its type, length, and
a pointer to the actual devid value. this has been changed so a
devid is a header followed immediately by the memory making up the
id value. this allows the header and its value to be allocated
together.

devids are now reference counted, so multiple things (eg, the mpath
node handlers and the various scsi_link structures) can share the
same allocation safely. this also frees devids when scsi_links go
away, which was previously not done.

if mpath is enabled, then print the devids out as part of the devices
attach line.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.3 2009/08/09 16:55:02 dlg Exp $ */
d310 13
@


1.4
log
@rework the scsi midlayer to start addressing some problems i have
with it which became extremely annoying with what mpath wants to
do.

the major change is a new interface for submitting scsi commands.
previously the only way for drivers like sd, cd, st, etc to push
commands onto the hardware was via scsi_scsi_cmd(). the problem
with scsi_scsi_cmd is that it doesnt tell the caller if the command
failed, was queued, or completed unless you shoved a buf down with
it. this is important for mpath which wants to know what the physical
path to the device did so it can report it back to the midlayer
which called it.

this provides a new api which lets drivers like cd/sd/st/mpath etc
allocate an xs, fill it in, and provide a completion routine which
the midlayer will call with the state of the command when it is
finished with it. the caller is then responsible for freeing the
xs.

from the hba side of thing, the return code from the scsi_cmd
entrypoint is largely ignored now, and it is now always the
responsibility of the hba driver to call scsi_done when it has
completed the io, rather than returning COMPLETE and expecting the
midlayer to do it for you.

i have emulated scsi_scsi_cmd on top of this new api so existing
users of it will continue to work. sd(4) has been reworked to use
the new api directly to both demonstrate its use and test that the
new api actually does work.

this diff was mostly written in a day at f2k9. thanks to miod for poking
through hba drivers to help mitigate against fallout from the change to
the COMPLETE semantic. this has been reviewed by krw who didnt spot
anything wrong.

thanks to dave del debbio for testing.

ok deraadt@@
@
text
@d50 1
a50 1
	struct devid		 node_id;
d141 3
a143 1
	if (link->lun != 0 || mpath_nodes[link->target] == NULL)
d146 2
d231 1
a231 1
	if (link->id.d_type == DEVID_NONE)
d238 1
a238 1
		if (DEVID_CMP(&n->node_id, &link->id))
d255 1
a255 4
		n->node_id.d_type = link->id.d_type;
		n->node_id.d_len = link->id.d_len;
		n->node_id.d_id = malloc(n->node_id.d_len, M_DEVBUF, M_DEVBUF);
		memcpy(n->node_id.d_id, link->id.d_id, n->node_id.d_len);
d259 8
d291 1
a291 1
		if (DEVID_CMP(&n->node_id, &link->id))
@


1.3
log
@shove a minphys request against mpath down all to the minphys on each path
so we can guarantee that any of the paths we push the io down later will
work.

with help from a discussion from beck and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.2 2009/08/09 16:20:19 dlg Exp $ */
d81 2
d153 1
a153 2
	int rv;
	int s;
d160 27
a186 4
	rv = scsi_scsi_cmd(p->path_link, xs->cmd, xs->cmdlen,
	    xs->data, xs->datalen,
	    2, xs->timeout, NULL, SCSI_POLL |
	    (xs->flags & (SCSI_DATA_IN|SCSI_DATA_OUT)));
d188 4
d193 3
a195 10
	xs->flags |= ITSDONE;
	if (rv == 0) {
		xs->error = XS_NOERROR;
		xs->status = SCSI_OK;
		xs->resid = 0;
	} else {
		printf("%s: t%dl%d rv %d cmd %x\n", DEVNAME(mpath),
		    link->target, link->lun, rv, xs->cmd->opcode);
		xs->error = XS_DRIVER_STUFFUP;
	}
a199 2

	return (COMPLETE);
@


1.2
log
@if a physical path to a device behind mpath goes away, remove the path. it
is worth noting that the device on mpath will persist even if all the paths
behind it have gone away. returning the paths will allow operations to work
against the device again.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.1 2009/08/09 12:47:23 dlg Exp $ */
d78 1
d181 13
@


1.1
log
@add mpath(4), a driver that steals paths to scsi devices if it
thinks they could be available via multiple paths. those stolen
devices are then made available via mpath(4).

this is the minimum amount of code to implement the stealing. it
is generally broken and very brittle, so it is currently disabled.

it is going in so i can work on it in the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d203 2
d241 26
a266 1
	return (0);
@

