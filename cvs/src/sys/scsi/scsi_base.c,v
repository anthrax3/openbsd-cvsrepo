head	1.225;
access;
symbols
	OPENBSD_6_1_BASE:1.225
	OPENBSD_6_0:1.224.0.2
	OPENBSD_6_0_BASE:1.224
	OPENBSD_5_9:1.221.0.2
	OPENBSD_5_9_BASE:1.221
	OPENBSD_5_8:1.221.0.4
	OPENBSD_5_8_BASE:1.221
	OPENBSD_5_7:1.218.0.2
	OPENBSD_5_7_BASE:1.218
	OPENBSD_5_6:1.214.0.4
	OPENBSD_5_6_BASE:1.214
	OPENBSD_5_5:1.210.0.4
	OPENBSD_5_5_BASE:1.210
	OPENBSD_5_4:1.202.0.2
	OPENBSD_5_4_BASE:1.202
	OPENBSD_5_3:1.201.0.4
	OPENBSD_5_3_BASE:1.201
	OPENBSD_5_2:1.201.0.2
	OPENBSD_5_2_BASE:1.201
	OPENBSD_5_1_BASE:1.200
	OPENBSD_5_1:1.200.0.4
	OPENBSD_5_0:1.200.0.2
	OPENBSD_5_0_BASE:1.200
	OPENBSD_4_9:1.197.0.2
	OPENBSD_4_9_BASE:1.197
	OPENBSD_4_8:1.191.0.2
	OPENBSD_4_8_BASE:1.191
	OPENBSD_4_7:1.166.0.2
	OPENBSD_4_7_BASE:1.166
	OPENBSD_4_6:1.132.0.4
	OPENBSD_4_6_BASE:1.132
	OPENBSD_4_5:1.131.0.4
	OPENBSD_4_5_BASE:1.131
	OPENBSD_4_4:1.131.0.2
	OPENBSD_4_4_BASE:1.131
	OPENBSD_4_3:1.124.0.2
	OPENBSD_4_3_BASE:1.124
	OPENBSD_4_2:1.122.0.2
	OPENBSD_4_2_BASE:1.122
	OPENBSD_4_1:1.117.0.2
	OPENBSD_4_1_BASE:1.117
	OPENBSD_4_0:1.112.0.2
	OPENBSD_4_0_BASE:1.112
	OPENBSD_3_9:1.99.0.2
	OPENBSD_3_9_BASE:1.99
	OPENBSD_3_8:1.87.0.2
	OPENBSD_3_8_BASE:1.87
	OPENBSD_3_7:1.62.0.4
	OPENBSD_3_7_BASE:1.62
	OPENBSD_3_6:1.62.0.2
	OPENBSD_3_6_BASE:1.62
	SMP_SYNC_A:1.61
	SMP_SYNC_B:1.61
	OPENBSD_3_5:1.55.0.2
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.43.0.2
	OPENBSD_3_4_BASE:1.43
	UBC_SYNC_A:1.42
	OPENBSD_3_3:1.40.0.2
	OPENBSD_3_3_BASE:1.40
	OPENBSD_3_2:1.37.0.2
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	UBC_SYNC_B:1.37
	UBC:1.31.0.4
	UBC_BASE:1.31
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_8:1.26.0.4
	OPENBSD_2_8_BASE:1.26
	OPENBSD_2_7:1.26.0.2
	OPENBSD_2_7_BASE:1.26
	SMP:1.25.0.4
	SMP_BASE:1.25
	kame_19991208:1.25
	OPENBSD_2_6:1.25.0.2
	OPENBSD_2_6_BASE:1.25
	OPENBSD_2_5:1.23.0.2
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.21.0.4
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.21.0.2
	OPENBSD_2_3_BASE:1.21
	OPENBSD_2_2:1.19.0.2
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.225
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.224;
commitid	RlO92XR575sygHqm;

1.224
date	2016.03.12.15.16.04;	author krw;	state Exp;
branches;
next	1.223;
commitid	zkFngOKA3woPgVlY;

1.223
date	2016.03.10.13.56.14;	author krw;	state Exp;
branches;
next	1.222;
commitid	1lzwtVyYzQ8tyf5s;

1.222
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.221;
commitid	Z6e4eqr6FuYFPnlL;

1.221
date	2015.06.07.19.13.27;	author krw;	state Exp;
branches;
next	1.220;
commitid	MxUWuiPFtM1nRYxm;

1.220
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.219;
commitid	p4LJxGKbi0BU2cG6;

1.219
date	2015.03.08.20.49.38;	author krw;	state Exp;
branches;
next	1.218;
commitid	qI52fpBDSg4oXyc9;

1.218
date	2015.01.27.03.17.37;	author dlg;	state Exp;
branches;
next	1.217;
commitid	MyKPm9Q3dQu92BiX;

1.217
date	2014.09.20.16.18.23;	author kettenis;	state Exp;
branches;
next	1.216;
commitid	VVLM405lBw6ToTSF;

1.216
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.215;
commitid	uzzBR7hz9ncd4O6G;

1.215
date	2014.09.09.05.43.25;	author dlg;	state Exp;
branches;
next	1.214;
commitid	yPQLFxKZLORu1ilD;

1.214
date	2014.07.01.02.31.16;	author dlg;	state Exp;
branches;
next	1.213;
commitid	wP7ZR9dSDMLJDEcw;

1.213
date	2014.07.01.02.11.46;	author dlg;	state Exp;
branches;
next	1.212;
commitid	p72ZE2ktTNaf2z4Z;

1.212
date	2014.07.01.01.56.39;	author dlg;	state Exp;
branches;
next	1.211;
commitid	ZFiF6jwGPzRbvQ08;

1.211
date	2014.04.22.07.29.11;	author dlg;	state Exp;
branches;
next	1.210;

1.210
date	2014.01.27.23.44.40;	author dlg;	state Exp;
branches;
next	1.209;

1.209
date	2014.01.18.02.42.30;	author dlg;	state Exp;
branches;
next	1.208;

1.208
date	2013.10.07.17.54.23;	author miod;	state Exp;
branches;
next	1.207;

1.207
date	2013.09.27.11.43.19;	author krw;	state Exp;
branches;
next	1.206;

1.206
date	2013.08.29.02.54.36;	author dlg;	state Exp;
branches;
next	1.205;

1.205
date	2013.08.27.00.05.36;	author dlg;	state Exp;
branches;
next	1.204;

1.204
date	2013.08.26.01.37.13;	author dlg;	state Exp;
branches;
next	1.203;

1.203
date	2013.08.25.23.31.39;	author dlg;	state Exp;
branches;
next	1.202;

1.202
date	2013.06.11.16.42.17;	author deraadt;	state Exp;
branches;
next	1.201;

1.201
date	2012.07.01.19.32.55;	author miod;	state Exp;
branches;
next	1.200;

1.200
date	2011.06.15.01.10.05;	author dlg;	state Exp;
branches;
next	1.199;

1.199
date	2011.03.17.21.30.24;	author deraadt;	state Exp;
branches;
next	1.198;

1.198
date	2011.03.02.04.38.01;	author krw;	state Exp;
branches;
next	1.197;

1.197
date	2010.09.20.00.19.47;	author dlg;	state Exp;
branches;
next	1.196;

1.196
date	2010.09.17.23.19.02;	author dlg;	state Exp;
branches;
next	1.195;

1.195
date	2010.09.14.01.39.44;	author dlg;	state Exp;
branches;
next	1.194;

1.194
date	2010.09.08.11.04.39;	author dlg;	state Exp;
branches;
next	1.193;

1.193
date	2010.08.30.02.47.56;	author matthew;	state Exp;
branches;
next	1.192;

1.192
date	2010.08.25.00.31.35;	author dlg;	state Exp;
branches;
next	1.191;

1.191
date	2010.08.07.03.50.02;	author krw;	state Exp;
branches;
next	1.190;

1.190
date	2010.07.28.01.53.12;	author krw;	state Exp;
branches;
next	1.189;

1.189
date	2010.07.27.04.41.56;	author matthew;	state Exp;
branches;
next	1.188;

1.188
date	2010.07.27.04.17.10;	author dlg;	state Exp;
branches;
next	1.187;

1.187
date	2010.07.25.15.39.32;	author krw;	state Exp;
branches;
next	1.186;

1.186
date	2010.07.24.04.01.52;	author matthew;	state Exp;
branches;
next	1.185;

1.185
date	2010.07.22.05.21.58;	author matthew;	state Exp;
branches;
next	1.184;

1.184
date	2010.07.22.00.31.06;	author krw;	state Exp;
branches;
next	1.183;

1.183
date	2010.07.06.01.07.28;	author krw;	state Exp;
branches;
next	1.182;

1.182
date	2010.07.03.01.55.28;	author krw;	state Exp;
branches;
next	1.181;

1.181
date	2010.07.02.23.57.46;	author krw;	state Exp;
branches;
next	1.180;

1.180
date	2010.07.02.00.04.11;	author krw;	state Exp;
branches;
next	1.179;

1.179
date	2010.07.01.22.20.01;	author krw;	state Exp;
branches;
next	1.178;

1.178
date	2010.07.01.05.11.18;	author krw;	state Exp;
branches;
next	1.177;

1.177
date	2010.07.01.03.01.37;	author matthew;	state Exp;
branches;
next	1.176;

1.176
date	2010.06.28.09.11.21;	author dlg;	state Exp;
branches;
next	1.175;

1.175
date	2010.06.14.10.03.33;	author thib;	state Exp;
branches;
next	1.174;

1.174
date	2010.06.01.10.11.05;	author dlg;	state Exp;
branches;
next	1.173;

1.173
date	2010.05.24.21.51.49;	author krw;	state Exp;
branches;
next	1.172;

1.172
date	2010.04.17.04.14.52;	author deraadt;	state Exp;
branches;
next	1.171;

1.171
date	2010.04.17.00.51.13;	author dlg;	state Exp;
branches;
next	1.170;

1.170
date	2010.04.16.09.51.30;	author dlg;	state Exp;
branches;
next	1.169;

1.169
date	2010.04.12.09.51.48;	author dlg;	state Exp;
branches;
next	1.168;

1.168
date	2010.04.06.00.58.00;	author dlg;	state Exp;
branches;
next	1.167;

1.167
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.166;

1.166
date	2010.01.15.06.27.12;	author krw;	state Exp;
branches
	1.166.2.1;
next	1.165;

1.165
date	2010.01.15.05.50.31;	author krw;	state Exp;
branches;
next	1.164;

1.164
date	2010.01.14.04.56.08;	author krw;	state Exp;
branches;
next	1.163;

1.163
date	2010.01.14.00.32.46;	author krw;	state Exp;
branches;
next	1.162;

1.162
date	2010.01.13.10.53.11;	author krw;	state Exp;
branches;
next	1.161;

1.161
date	2010.01.13.08.04.39;	author krw;	state Exp;
branches;
next	1.160;

1.160
date	2010.01.13.05.08.55;	author dlg;	state Exp;
branches;
next	1.159;

1.159
date	2010.01.13.03.09.05;	author dlg;	state Exp;
branches;
next	1.158;

1.158
date	2010.01.13.02.46.19;	author krw;	state Exp;
branches;
next	1.157;

1.157
date	2010.01.13.00.49.24;	author jcs;	state Exp;
branches;
next	1.156;

1.156
date	2010.01.10.23.06.43;	author krw;	state Exp;
branches;
next	1.155;

1.155
date	2010.01.10.00.10.23;	author krw;	state Exp;
branches;
next	1.154;

1.154
date	2010.01.09.22.24.34;	author dlg;	state Exp;
branches;
next	1.153;

1.153
date	2010.01.09.21.04.55;	author dlg;	state Exp;
branches;
next	1.152;

1.152
date	2010.01.07.00.11.15;	author dlg;	state Exp;
branches;
next	1.151;

1.151
date	2010.01.04.11.46.17;	author dlg;	state Exp;
branches;
next	1.150;

1.150
date	2010.01.04.00.45.58;	author dlg;	state Exp;
branches;
next	1.149;

1.149
date	2010.01.01.07.06.27;	author dlg;	state Exp;
branches;
next	1.148;

1.148
date	2010.01.01.06.30.27;	author dlg;	state Exp;
branches;
next	1.147;

1.147
date	2009.12.09.21.02.51;	author krw;	state Exp;
branches;
next	1.146;

1.146
date	2009.12.07.00.09.27;	author krw;	state Exp;
branches;
next	1.145;

1.145
date	2009.12.01.01.50.35;	author dlg;	state Exp;
branches;
next	1.144;

1.144
date	2009.12.01.01.40.02;	author dlg;	state Exp;
branches;
next	1.143;

1.143
date	2009.11.22.20.09.53;	author krw;	state Exp;
branches;
next	1.142;

1.142
date	2009.11.12.06.20.27;	author dlg;	state Exp;
branches;
next	1.141;

1.141
date	2009.11.10.10.51.03;	author dlg;	state Exp;
branches;
next	1.140;

1.140
date	2009.11.10.10.18.59;	author dlg;	state Exp;
branches;
next	1.139;

1.139
date	2009.11.10.10.13.08;	author dlg;	state Exp;
branches;
next	1.138;

1.138
date	2009.11.05.03.33.52;	author marco;	state Exp;
branches;
next	1.137;

1.137
date	2009.10.27.11.38.24;	author dlg;	state Exp;
branches;
next	1.136;

1.136
date	2009.09.14.00.03.28;	author dlg;	state Exp;
branches;
next	1.135;

1.135
date	2009.09.02.14.19.50;	author dlg;	state Exp;
branches;
next	1.134;

1.134
date	2009.08.13.21.35.56;	author dlg;	state Exp;
branches;
next	1.133;

1.133
date	2009.08.13.19.49.31;	author dlg;	state Exp;
branches;
next	1.132;

1.132
date	2009.06.02.06.33.04;	author yuo;	state Exp;
branches;
next	1.131;

1.131
date	2008.07.26.18.55.31;	author krw;	state Exp;
branches;
next	1.130;

1.130
date	2008.07.05.16.07.01;	author krw;	state Exp;
branches;
next	1.129;

1.129
date	2008.06.22.16.32.05;	author krw;	state Exp;
branches;
next	1.128;

1.128
date	2008.06.21.21.35.27;	author krw;	state Exp;
branches;
next	1.127;

1.127
date	2008.06.15.00.52.25;	author krw;	state Exp;
branches;
next	1.126;

1.126
date	2008.06.14.01.57.51;	author krw;	state Exp;
branches;
next	1.125;

1.125
date	2008.06.13.04.27.08;	author krw;	state Exp;
branches;
next	1.124;

1.124
date	2007.11.25.22.28.53;	author dlg;	state Exp;
branches;
next	1.123;

1.123
date	2007.09.16.01.30.24;	author krw;	state Exp;
branches;
next	1.122;

1.122
date	2007.06.23.19.19.49;	author krw;	state Exp;
branches;
next	1.121;

1.121
date	2007.05.31.18.21.44;	author dlg;	state Exp;
branches;
next	1.120;

1.120
date	2007.04.10.17.47.56;	author miod;	state Exp;
branches;
next	1.119;

1.119
date	2007.04.03.04.47.59;	author dlg;	state Exp;
branches;
next	1.118;

1.118
date	2007.04.03.04.15.50;	author dlg;	state Exp;
branches;
next	1.117;

1.117
date	2006.12.12.02.44.36;	author krw;	state Exp;
branches;
next	1.116;

1.116
date	2006.11.27.23.14.22;	author beck;	state Exp;
branches;
next	1.115;

1.115
date	2006.11.27.18.24.43;	author beck;	state Exp;
branches;
next	1.114;

1.114
date	2006.11.04.06.03.51;	author dlg;	state Exp;
branches;
next	1.113;

1.113
date	2006.09.22.00.33.41;	author dlg;	state Exp;
branches;
next	1.112;

1.112
date	2006.08.04.21.35.51;	author beck;	state Exp;
branches;
next	1.111;

1.111
date	2006.07.29.02.40.45;	author krw;	state Exp;
branches;
next	1.110;

1.110
date	2006.07.23.14.34.55;	author krw;	state Exp;
branches;
next	1.109;

1.109
date	2006.07.22.18.44.28;	author krw;	state Exp;
branches;
next	1.108;

1.108
date	2006.07.15.00.04.11;	author beck;	state Exp;
branches;
next	1.107;

1.107
date	2006.07.13.11.46.16;	author krw;	state Exp;
branches;
next	1.106;

1.106
date	2006.07.11.13.15.30;	author dlg;	state Exp;
branches;
next	1.105;

1.105
date	2006.07.11.09.12.54;	author dlg;	state Exp;
branches;
next	1.104;

1.104
date	2006.05.28.17.15.23;	author beck;	state Exp;
branches;
next	1.103;

1.103
date	2006.05.13.18.11.03;	author krw;	state Exp;
branches;
next	1.102;

1.102
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.101;

1.101
date	2006.05.07.20.50.21;	author krw;	state Exp;
branches;
next	1.100;

1.100
date	2006.05.07.00.20.05;	author krw;	state Exp;
branches;
next	1.99;

1.99
date	2006.02.06.17.37.28;	author jmc;	state Exp;
branches;
next	1.98;

1.98
date	2005.11.28.16.51.29;	author mickey;	state Exp;
branches;
next	1.97;

1.97
date	2005.11.13.14.29.57;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2005.11.13.03.27.42;	author krw;	state Exp;
branches;
next	1.95;

1.95
date	2005.11.13.02.39.45;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2005.11.07.23.49.32;	author krw;	state Exp;
branches;
next	1.93;

1.93
date	2005.11.02.01.36.05;	author krw;	state Exp;
branches;
next	1.92;

1.92
date	2005.10.22.16.51.28;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2005.10.16.19.16.36;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2005.10.10.20.06.11;	author krw;	state Exp;
branches;
next	1.89;

1.89
date	2005.10.04.20.58.10;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2005.09.11.17.34.27;	author krw;	state Exp;
branches;
next	1.87;

1.87
date	2005.08.29.00.41.44;	author krw;	state Exp;
branches;
next	1.86;

1.86
date	2005.08.01.22.42.50;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2005.06.23.00.31.44;	author krw;	state Exp;
branches;
next	1.84;

1.84
date	2005.06.18.01.09.03;	author krw;	state Exp;
branches;
next	1.83;

1.83
date	2005.06.18.00.52.15;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2005.06.12.21.40.05;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2005.06.09.00.16.09;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2005.06.05.21.27.07;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2005.06.04.01.25.02;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2005.06.03.15.50.10;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2005.06.02.23.49.28;	author krw;	state Exp;
branches;
next	1.76;

1.76
date	2005.05.31.01.15.31;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2005.05.28.23.59.18;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2005.05.28.23.45.06;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2005.05.28.23.32.25;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2005.05.28.23.26.09;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2005.05.28.06.16.33;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2005.05.25.20.52.41;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.22.01.12.47;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2005.05.14.00.20.43;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2005.04.28.10.16.04;	author moritz;	state Exp;
branches;
next	1.66;

1.66
date	2005.04.17.18.55.45;	author tom;	state Exp;
branches;
next	1.65;

1.65
date	2005.04.05.12.13.16;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2005.04.01.23.34.39;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2005.03.24.12.52.01;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2004.07.31.11.31.30;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2004.05.28.23.50.14;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2004.05.17.23.57.51;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2004.05.13.01.56.09;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2004.05.09.05.33.59;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2004.05.09.04.01.59;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2004.04.18.00.49.29;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2004.03.14.22.46.47;	author krw;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2004.02.21.00.47.42;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2004.02.21.00.34.27;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2004.02.17.23.50.46;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2004.02.07.22.39.15;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2004.01.10.09.12.07;	author grange;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.08.17.30.52;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.04.03.25.30;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.02.05.46.09;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2004.01.02.05.30.32;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.24.13.20.05;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.26.21.43.32;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.26.02.00.56;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.16.19.54.05;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.03.02.20.32;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.20.04.02.06;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2002.12.30.21.50.28;	author grange;	state Exp;
branches;
next	1.38;

1.38
date	2002.11.30.18.46.56;	author nate;	state Exp;
branches;
next	1.37;

1.37
date	2002.09.04.23.11.10;	author tdeval;	state Exp;
branches;
next	1.36;

1.36
date	2002.05.22.01.04.06;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.22.00.20.58;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.21.10.42.40;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.23.00.39.48;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.25.19.29.16;	author fgsch;	state Exp;
branches
	1.31.4.1;
next	1.30;

1.30
date	2001.08.19.15.07.34;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.22.14.35.42;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.18.22.38.44;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.22.19.10.13;	author csapuntz;	state Exp;
branches;
next	1.26;

1.26
date	2000.03.01.18.12.04;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	99.07.25.07.09.19;	author csapuntz;	state Exp;
branches
	1.25.4.1;
next	1.24;

1.24
date	99.04.20.19.04.34;	author weingart;	state Exp;
branches;
next	1.23;

1.23
date	99.02.07.00.14.25;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.12.19.01.32.26;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.02.14.08.56.50;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.12.31.01.22.10;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.09.11.21.05.22;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	97.09.05.05.56.49;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	97.09.05.05.19.52;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	97.09.05.04.04.06;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.09.03.17.23.20;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.09.02.17.15.35;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.08.22.04.43.25;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.07.03.17.47.29;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.04.14.04.09.07;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.06.16.03.07.19;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.05.06.11.33.35;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.02.13.17.52;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.30.50;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.02.29.13.12.22;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.02.20.01.46.33;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.01.31.15.04.03;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.01.14.21.44.28;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.01.14.21.34.43;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches;
next	;

1.25.4.1
date	2000.03.02.07.04.47;	author niklas;	state Exp;
branches;
next	1.25.4.2;

1.25.4.2
date	2001.05.14.22.44.59;	author niklas;	state Exp;
branches;
next	1.25.4.3;

1.25.4.3
date	2001.07.04.11.00.03;	author niklas;	state Exp;
branches;
next	1.25.4.4;

1.25.4.4
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.25.4.5;

1.25.4.5
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.25.4.6;

1.25.4.6
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.25.4.7;

1.25.4.7
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.25.4.8;

1.25.4.8
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.25.4.9;

1.25.4.9
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.25.4.10;

1.25.4.10
date	2004.02.19.11.01.30;	author niklas;	state Exp;
branches;
next	1.25.4.11;

1.25.4.11
date	2004.06.05.23.13.08;	author niklas;	state Exp;
branches;
next	;

1.31.4.1
date	2002.01.31.22.55.48;	author niklas;	state Exp;
branches;
next	1.31.4.2;

1.31.4.2
date	2002.06.11.03.32.13;	author art;	state Exp;
branches;
next	1.31.4.3;

1.31.4.3
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.31.4.4;

1.31.4.4
date	2003.05.19.22.28.21;	author tedu;	state Exp;
branches;
next	;

1.55.2.1
date	2004.04.30.22.07.37;	author brad;	state Exp;
branches;
next	;

1.166.2.1
date	2010.08.24.09.10.14;	author stephan;	state Exp;
branches;
next	;


desc
@@


1.225
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@/*	$OpenBSD: scsi_base.c,v 1.224 2016/03/12 15:16:04 krw Exp $	*/
/*	$NetBSD: scsi_base.c,v 1.43 1997/04/02 02:29:36 mycroft Exp $	*/

/*
 * Copyright (c) 1994, 1995, 1997 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Originally written by Julian Elischer (julian@@dialix.oz.au)
 * Detailed SCSI error printing Copyright 1997 by Matthew Jacob.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/uio.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/pool.h>
#include <sys/task.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

static __inline void asc2ascii(u_int8_t, u_int8_t ascq, char *result,
    size_t len);
int	scsi_xs_error(struct scsi_xfer *);
char   *scsi_decode_sense(struct scsi_sense_data *, int);

void	scsi_xs_sync_done(struct scsi_xfer *);

/* Values for flag parameter to scsi_decode_sense. */
#define	DECODE_SENSE_KEY	1
#define	DECODE_ASC_ASCQ		2
#define DECODE_SKSV		3

struct pool		scsi_xfer_pool;
struct pool		scsi_plug_pool;

struct scsi_plug {
	struct task		task;
	struct scsibus_softc	*sb;
	int			target;
	int			lun;
	int			how;
};

void	scsi_plug_probe(void *);
void	scsi_plug_detach(void *);

struct scsi_xfer *	scsi_xs_io(struct scsi_link *, void *, int);

int			scsi_ioh_pending(struct scsi_iopool *);
struct scsi_iohandler *	scsi_ioh_deq(struct scsi_iopool *);

void			scsi_xsh_runqueue(struct scsi_link *);
void			scsi_xsh_ioh(void *, void *);

int			scsi_link_open(struct scsi_link *);
void			scsi_link_close(struct scsi_link *);

void *			scsi_iopool_get(struct scsi_iopool *);
void			scsi_iopool_put(struct scsi_iopool *, void *);

/* ioh/xsh queue state */
#define RUNQ_IDLE	0
#define RUNQ_LINKQ	1
#define RUNQ_POOLQ	2

/* synchronous api for allocating an io. */
struct scsi_io_mover {
	struct mutex mtx;
	void *io;
	u_int done;
};
#define SCSI_IO_MOVER_INITIALIZER { MUTEX_INITIALIZER(IPL_BIO), NULL, 0 }

void scsi_move(struct scsi_io_mover *);
void scsi_move_done(void *, void *);

void scsi_io_get_done(void *, void *);
void scsi_xs_get_done(void *, void *);

/*
 * Called when a scsibus is attached to initialize global data.
 */
void
scsi_init(void)
{
	static int scsi_init_done;

	if (scsi_init_done)
		return;
	scsi_init_done = 1;

#if defined(SCSI_DELAY) && SCSI_DELAY > 0
	/* Historical. Older buses may need a moment to stabilize. */
	delay(1000000 * SCSI_DELAY);
#endif

	/* Initialize the scsi_xfer pool. */
	pool_init(&scsi_xfer_pool, sizeof(struct scsi_xfer), 0, IPL_BIO, 0,
	    "scxspl", NULL);
	pool_init(&scsi_plug_pool, sizeof(struct scsi_plug), 0, IPL_BIO, 0,
	    "scsiplug", NULL);
}

int
scsi_req_probe(struct scsibus_softc *sb, int target, int lun)
{
	struct scsi_plug *p;

	p = pool_get(&scsi_plug_pool, PR_NOWAIT);
	if (p == NULL)
		return (ENOMEM);

	task_set(&p->task, scsi_plug_probe, p);
	p->sb = sb;
	p->target = target;
	p->lun = lun;

	task_add(systq, &p->task);

	return (0);
}

int
scsi_req_detach(struct scsibus_softc *sb, int target, int lun, int how)
{
	struct scsi_plug *p;

	p = pool_get(&scsi_plug_pool, PR_NOWAIT);
	if (p == NULL)
		return (ENOMEM);

	task_set(&p->task, scsi_plug_detach, p);
	p->sb = sb;
	p->target = target;
	p->lun = lun;
	p->how = how;

	task_add(systq, &p->task);

	return (0);
}

void
scsi_plug_probe(void *xp)
{
	struct scsi_plug *p = xp;
	struct scsibus_softc *sb = p->sb;
	int target = p->target, lun = p->lun;

	pool_put(&scsi_plug_pool, p);

	scsi_probe(sb, target, lun);
}

void
scsi_plug_detach(void *xp)
{
	struct scsi_plug *p = xp;
	struct scsibus_softc *sb = p->sb;
	int target = p->target, lun = p->lun;
	int how = p->how;

	pool_put(&scsi_plug_pool, p);

	scsi_detach(sb, target, lun, how);
}

int
scsi_pending_start(struct mutex *mtx, u_int *running)
{
	int rv = 1;

	mtx_enter(mtx);
	(*running)++;
	if ((*running) > 1)
		rv = 0;
	mtx_leave(mtx);

	return (rv);
}

int
scsi_pending_finish(struct mutex *mtx, u_int *running)
{
	int rv = 1;

	mtx_enter(mtx);
	(*running)--;
	if ((*running) > 0) {
		(*running) = 1;
		rv = 0;
	}
	mtx_leave(mtx);

	return (rv);
}

void
scsi_iopool_init(struct scsi_iopool *iopl, void *iocookie,
    void *(*io_get)(void *), void (*io_put)(void *, void *))
{
	iopl->iocookie = iocookie;
	iopl->io_get = io_get;
	iopl->io_put = io_put;

	TAILQ_INIT(&iopl->queue);
	iopl->running = 0;
	mtx_init(&iopl->mtx, IPL_BIO);
}

void *
scsi_iopool_get(struct scsi_iopool *iopl)
{
	void *io;

	KERNEL_LOCK();
	io = iopl->io_get(iopl->iocookie);
	KERNEL_UNLOCK();

	return (io);
}

void
scsi_iopool_put(struct scsi_iopool *iopl, void *io)
{
	KERNEL_LOCK();
	iopl->io_put(iopl->iocookie, io);
	KERNEL_UNLOCK();
}

void
scsi_iopool_destroy(struct scsi_iopool *iopl)
{
	struct scsi_runq sleepers = TAILQ_HEAD_INITIALIZER(sleepers);
	struct scsi_iohandler *ioh = NULL;

	mtx_enter(&iopl->mtx);
	while ((ioh = TAILQ_FIRST(&iopl->queue)) != NULL) {
		TAILQ_REMOVE(&iopl->queue, ioh, q_entry);
		ioh->q_state = RUNQ_IDLE;

		if (ioh->handler == scsi_io_get_done)
			TAILQ_INSERT_TAIL(&sleepers, ioh, q_entry);
#ifdef DIAGNOSTIC
		else
			panic("scsi_iopool_destroy: scsi_iohandler on pool");
#endif
	}
	mtx_leave(&iopl->mtx);

	while ((ioh = TAILQ_FIRST(&sleepers)) != NULL) {
		TAILQ_REMOVE(&sleepers, ioh, q_entry);
		ioh->handler(ioh->cookie, NULL);
	}
}

void *
scsi_default_get(void *iocookie)
{
	return (SCSI_IOPOOL_POISON);
}

void
scsi_default_put(void *iocookie, void *io)
{
#ifdef DIAGNOSTIC
	if (io != SCSI_IOPOOL_POISON)
		panic("unexpected opening returned");
#endif
}

/*
 * public interface to the ioh api.
 */

void
scsi_ioh_set(struct scsi_iohandler *ioh, struct scsi_iopool *iopl,
    void (*handler)(void *, void *), void *cookie)
{
	ioh->q_state = RUNQ_IDLE;
	ioh->pool = iopl;
	ioh->handler = handler;
	ioh->cookie = cookie;
}

int
scsi_ioh_add(struct scsi_iohandler *ioh)
{
	struct scsi_iopool *iopl = ioh->pool;
	int rv = 0;

	mtx_enter(&iopl->mtx);
	switch (ioh->q_state) {
	case RUNQ_IDLE:
		TAILQ_INSERT_TAIL(&iopl->queue, ioh, q_entry);
		ioh->q_state = RUNQ_POOLQ;
		rv = 1;
		break;
#ifdef DIAGNOSTIC
	case RUNQ_POOLQ:
		break;
	default:
		panic("scsi_ioh_add: unexpected state %u", ioh->q_state);
#endif
	}
	mtx_leave(&iopl->mtx);

	/* lets get some io up in the air */
	scsi_iopool_run(iopl);

	return (rv);
}

int
scsi_ioh_del(struct scsi_iohandler *ioh)
{
	struct scsi_iopool *iopl = ioh->pool;
	int rv = 0;

	mtx_enter(&iopl->mtx);
	switch (ioh->q_state) {
	case RUNQ_POOLQ:
		TAILQ_REMOVE(&iopl->queue, ioh, q_entry);
		ioh->q_state = RUNQ_IDLE;
		rv = 1;
		break;
#ifdef DIAGNOSTIC
	case RUNQ_IDLE:
		break;
	default:
		panic("scsi_ioh_del: unexpected state %u", ioh->q_state);
#endif
	}
	mtx_leave(&iopl->mtx);

	return (rv);
}

/*
 * internal iopool runqueue handling.
 */

struct scsi_iohandler *
scsi_ioh_deq(struct scsi_iopool *iopl)
{
	struct scsi_iohandler *ioh = NULL;

	mtx_enter(&iopl->mtx);
	ioh = TAILQ_FIRST(&iopl->queue);
	if (ioh != NULL) {
		TAILQ_REMOVE(&iopl->queue, ioh, q_entry);
		ioh->q_state = RUNQ_IDLE;
	}
	mtx_leave(&iopl->mtx);

	return (ioh);
}

int
scsi_ioh_pending(struct scsi_iopool *iopl)
{
	int rv;

	mtx_enter(&iopl->mtx);
	rv = !TAILQ_EMPTY(&iopl->queue);
	mtx_leave(&iopl->mtx);

	return (rv);
}

void
scsi_iopool_run(struct scsi_iopool *iopl)
{
	struct scsi_iohandler *ioh;
	void *io;

	if (!scsi_pending_start(&iopl->mtx, &iopl->running))
		return;
	do {
		while (scsi_ioh_pending(iopl)) {
			io = scsi_iopool_get(iopl);
			if (io == NULL)
				break;

			ioh = scsi_ioh_deq(iopl);
			if (ioh == NULL) {
				scsi_iopool_put(iopl, io);
				break;
			}

			ioh->handler(ioh->cookie, io);
		}
	} while (!scsi_pending_finish(&iopl->mtx, &iopl->running));
}

/*
 * move an io from a runq to a proc thats waiting for an io.
 */

void
scsi_move(struct scsi_io_mover *m)
{
	mtx_enter(&m->mtx);
	while (!m->done)
		msleep(m, &m->mtx, PRIBIO, "scsiiomv", 0);
	mtx_leave(&m->mtx);
}

void
scsi_move_done(void *cookie, void *io)
{
	struct scsi_io_mover *m = cookie;

	mtx_enter(&m->mtx);
	m->io = io;
	m->done = 1;
	wakeup_one(m);
	mtx_leave(&m->mtx);
}

/*
 * synchronous api for allocating an io.
 */

void *
scsi_io_get(struct scsi_iopool *iopl, int flags)
{
	struct scsi_io_mover m = SCSI_IO_MOVER_INITIALIZER;
	struct scsi_iohandler ioh;
	void *io;

	/* try and sneak an io off the backend immediately */
	io = scsi_iopool_get(iopl);
	if (io != NULL)
		return (io);
	else if (ISSET(flags, SCSI_NOSLEEP))
		return (NULL);

	/* otherwise sleep until we get one */
	scsi_ioh_set(&ioh, iopl, scsi_io_get_done, &m);
	scsi_ioh_add(&ioh);
	scsi_move(&m);

	return (m.io);
}

void
scsi_io_get_done(void *cookie, void *io)
{
	scsi_move_done(cookie, io);
}

void
scsi_io_put(struct scsi_iopool *iopl, void *io)
{
	scsi_iopool_put(iopl, io);
	scsi_iopool_run(iopl);
}

/*
 * public interface to the xsh api.
 */

void
scsi_xsh_set(struct scsi_xshandler *xsh, struct scsi_link *link,
    void (*handler)(struct scsi_xfer *))
{
	scsi_ioh_set(&xsh->ioh, link->pool, scsi_xsh_ioh, xsh);

	xsh->link = link;
	xsh->handler = handler;
}

int
scsi_xsh_add(struct scsi_xshandler *xsh)
{
	struct scsi_link *link = xsh->link;
	int rv = 0;

	if (ISSET(link->state, SDEV_S_DYING))
		return (0);

	mtx_enter(&link->pool->mtx);
	if (xsh->ioh.q_state == RUNQ_IDLE) {
		TAILQ_INSERT_TAIL(&link->queue, &xsh->ioh, q_entry);
		xsh->ioh.q_state = RUNQ_LINKQ;
		rv = 1;
	}
	mtx_leave(&link->pool->mtx);

	/* lets get some io up in the air */
	scsi_xsh_runqueue(link);

	return (rv);
}

int
scsi_xsh_del(struct scsi_xshandler *xsh)
{
	struct scsi_link *link = xsh->link;
	int rv = 1;

	mtx_enter(&link->pool->mtx);
	switch (xsh->ioh.q_state) {
	case RUNQ_IDLE:
		rv = 0;
		break;
	case RUNQ_LINKQ:
		TAILQ_REMOVE(&link->queue, &xsh->ioh, q_entry);
		break;
	case RUNQ_POOLQ:
		TAILQ_REMOVE(&link->pool->queue, &xsh->ioh, q_entry);
		link->pending--;
		if (ISSET(link->state, SDEV_S_DYING) && link->pending == 0)
			wakeup_one(&link->pending);
		break;
	default:
		panic("unexpected xsh state %u", xsh->ioh.q_state);
	}
	xsh->ioh.q_state = RUNQ_IDLE;
	mtx_leave(&link->pool->mtx);

	return (rv);
}

/*
 * internal xs runqueue handling.
 */

void
scsi_xsh_runqueue(struct scsi_link *link)
{
	struct scsi_iohandler *ioh;
	int runq;

	if (!scsi_pending_start(&link->pool->mtx, &link->running))
		return;
	do {
		runq = 0;

		mtx_enter(&link->pool->mtx);
		while (!ISSET(link->state, SDEV_S_DYING) &&
		    link->pending < link->openings &&
		    ((ioh = TAILQ_FIRST(&link->queue)) != NULL)) {
			link->pending++;

			TAILQ_REMOVE(&link->queue, ioh, q_entry);
			TAILQ_INSERT_TAIL(&link->pool->queue, ioh, q_entry);
			ioh->q_state = RUNQ_POOLQ;

			runq = 1;
		}
		mtx_leave(&link->pool->mtx);

		if (runq)
			scsi_iopool_run(link->pool);
	} while (!scsi_pending_finish(&link->pool->mtx, &link->running));
}

void
scsi_xsh_ioh(void *cookie, void *io)
{
	struct scsi_xshandler *xsh = cookie;
	struct scsi_xfer *xs;

	xs = scsi_xs_io(xsh->link, io, SCSI_NOSLEEP);
	if (xs == NULL) {
		/*
		 * in this situation we should queue things waiting for an
		 * xs and then give them xses when they were supposed be to
		 * returned to the pool.
		 */

		printf("scsi_xfer pool exhausted!\n");
		scsi_xsh_add(xsh);
		return;
	}

	xsh->handler(xs);
}

/*
 * Get a scsi transfer structure for the caller.
 * Go to the iopool backend for an "opening" and then attach an xs to it.
 */

struct scsi_xfer *
scsi_xs_get(struct scsi_link *link, int flags)
{
	struct scsi_xshandler xsh;
	struct scsi_io_mover m = SCSI_IO_MOVER_INITIALIZER;

	struct scsi_iopool *iopl = link->pool;
	void *io;

	if (ISSET(link->state, SDEV_S_DYING))
		return (NULL);

	/* really custom xs handler to avoid scsi_xsh_ioh */
	scsi_ioh_set(&xsh.ioh, iopl, scsi_xs_get_done, &m);
	xsh.link = link;

	if (!scsi_link_open(link)) {
		if (ISSET(flags, SCSI_NOSLEEP))
			return (NULL);

		scsi_xsh_add(&xsh);
		scsi_move(&m);
		if (m.io == NULL)
			return (NULL);

		io = m.io;
	} else if ((io = scsi_iopool_get(iopl)) == NULL) {
		if (ISSET(flags, SCSI_NOSLEEP)) {
			scsi_link_close(link);
			return (NULL);
		}

		scsi_ioh_add(&xsh.ioh);
		scsi_move(&m);
		if (m.io == NULL)
			return (NULL);

		io = m.io;
	}

	return (scsi_xs_io(link, io, flags));
}

void
scsi_xs_get_done(void *cookie, void *io)
{
	scsi_move_done(cookie, io);
}

void
scsi_link_shutdown(struct scsi_link *link)
{
	struct scsi_runq sleepers = TAILQ_HEAD_INITIALIZER(sleepers);
	struct scsi_iopool *iopl = link->pool;
	struct scsi_iohandler *ioh;
	struct scsi_xshandler *xsh;

	mtx_enter(&iopl->mtx);
	while ((ioh = TAILQ_FIRST(&link->queue)) != NULL) {
		TAILQ_REMOVE(&link->queue, ioh, q_entry);
		ioh->q_state = RUNQ_IDLE;

		if (ioh->handler == scsi_xs_get_done)
			TAILQ_INSERT_TAIL(&sleepers, ioh, q_entry);
#ifdef DIAGNOSTIC
		else
			panic("scsi_link_shutdown: scsi_xshandler on link");
#endif
	}

	ioh = TAILQ_FIRST(&iopl->queue);
	while (ioh != NULL) {
		xsh = (struct scsi_xshandler *)ioh;
		ioh = TAILQ_NEXT(ioh, q_entry);

#ifdef DIAGNOSTIC
		if (xsh->ioh.handler == scsi_xsh_ioh &&
		    xsh->link == link)
			panic("scsi_link_shutdown: scsi_xshandler on pool");
#endif

		if (xsh->ioh.handler == scsi_xs_get_done &&
		    xsh->link == link) {
			TAILQ_REMOVE(&iopl->queue, &xsh->ioh, q_entry);
			xsh->ioh.q_state = RUNQ_IDLE;
			link->pending--;

			TAILQ_INSERT_TAIL(&sleepers, &xsh->ioh, q_entry);
		}
	}

	while (link->pending > 0)
		msleep(&link->pending, &iopl->mtx, PRIBIO, "pendxs", 0);
	mtx_leave(&iopl->mtx);

	while ((ioh = TAILQ_FIRST(&sleepers)) != NULL) {
		TAILQ_REMOVE(&sleepers, ioh, q_entry);
		ioh->handler(ioh->cookie, NULL);
	}
}

int
scsi_link_open(struct scsi_link *link)
{
	int open = 0;

	mtx_enter(&link->pool->mtx);
	if (link->pending < link->openings) {
		link->pending++;
		open = 1;
	}
	mtx_leave(&link->pool->mtx);

	return (open);
}

void
scsi_link_close(struct scsi_link *link)
{
	mtx_enter(&link->pool->mtx);
	link->pending--;
	if (ISSET(link->state, SDEV_S_DYING) && link->pending == 0)
		wakeup_one(&link->pending);
	mtx_leave(&link->pool->mtx);

	scsi_xsh_runqueue(link);
}

struct scsi_xfer *
scsi_xs_io(struct scsi_link *link, void *io, int flags)
{
	struct scsi_xfer *xs;

	xs = pool_get(&scsi_xfer_pool, PR_ZERO |
	    (ISSET(flags, SCSI_NOSLEEP) ? PR_NOWAIT : PR_WAITOK));
	if (xs == NULL) {
		scsi_io_put(link->pool, io);
		scsi_link_close(link);
	} else {
		xs->flags = flags;
		xs->sc_link = link;
		xs->retries = SCSI_RETRIES;
		xs->timeout = 10000;
		xs->cmd = &xs->cmdstore;
		xs->io = io;
	}

	return (xs);
}

void
scsi_xs_put(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	void *io = xs->io;

	pool_put(&scsi_xfer_pool, xs);

	scsi_io_put(link->pool, io);
	scsi_link_close(link);
}

/*
 * Get scsi driver to send a "are you ready?" command
 */
int
scsi_test_unit_ready(struct scsi_link *link, int retries, int flags)
{
	struct scsi_test_unit_ready *cmd;
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(link, flags);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->retries = retries;
	xs->timeout = 10000;

	cmd = (struct scsi_test_unit_ready *)xs->cmd;
	cmd->opcode = TEST_UNIT_READY;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

void
scsi_init_inquiry(struct scsi_xfer *xs, u_int8_t flags, u_int8_t pagecode,
    void *data, size_t len)
{
	struct scsi_inquiry *cmd;

	cmd = (struct scsi_inquiry *)xs->cmd;
	cmd->opcode = INQUIRY;
	cmd->flags = flags;
	cmd->pagecode = pagecode;
	_lto2b(len, cmd->length);

	xs->cmdlen = sizeof(*cmd);

	xs->flags |= SCSI_DATA_IN;
	xs->data = data;
	xs->datalen = len;
}

/*
 * Do a scsi operation asking a device what it is.
 * Use the scsi_cmd routine in the switch table.
 */
int
scsi_inquire(struct scsi_link *link, struct scsi_inquiry_data *inqbuf,
    int flags)
{
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(link, flags);
	if (xs == NULL)
		return (EBUSY);

	/*
	 * Ask for only the basic 36 bytes of SCSI2 inquiry information. This
	 * avoids problems with devices that choke trying to supply more.
	 */
	scsi_init_inquiry(xs, 0, 0, inqbuf, SID_INQUIRY_HDR + SID_SCSI2_ALEN);

	bzero(inqbuf, sizeof(*inqbuf));
	memset(&inqbuf->vendor, ' ', sizeof inqbuf->vendor);
	memset(&inqbuf->product, ' ', sizeof inqbuf->product);
	memset(&inqbuf->revision, ' ', sizeof inqbuf->revision);
	memset(&inqbuf->extra, ' ', sizeof inqbuf->extra);

	error = scsi_xs_sync(xs);

	scsi_xs_put(xs);

	return (error);
}

/*
 * Query a VPD inquiry page
 */
int
scsi_inquire_vpd(struct scsi_link *link, void *buf, u_int buflen,
    u_int8_t page, int flags)
{
	struct scsi_xfer *xs;
	int error;

	if (link->flags & SDEV_UMASS)
		return (EJUSTRETURN);

	xs = scsi_xs_get(link, flags | SCSI_DATA_IN | SCSI_SILENT);
	if (xs == NULL)
		return (ENOMEM);

	xs->retries = 2;
	xs->timeout = 10000;

	scsi_init_inquiry(xs, SI_EVPD, page, buf, buflen);

	error = scsi_xs_sync(xs);

	scsi_xs_put(xs);

	return (error);
}

/*
 * Prevent or allow the user to remove the media
 */
int
scsi_prevent(struct scsi_link *link, int type, int flags)
{
	struct scsi_prevent *cmd;
	struct scsi_xfer *xs;
	int error;

	if (link->quirks & ADEV_NODOORLOCK)
		return (0);

	xs = scsi_xs_get(link, flags);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->retries = 2;
	xs->timeout = 5000;

	cmd = (struct scsi_prevent *)xs->cmd;
	cmd->opcode = PREVENT_ALLOW;
	cmd->how = type;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

/*
 * Get scsi driver to send a "start up" command
 */
int
scsi_start(struct scsi_link *link, int type, int flags)
{
	struct scsi_start_stop *cmd;
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(link, flags);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->retries = 2;
	xs->timeout = (type == SSS_START) ? 30000 : 10000;

	cmd = (struct scsi_start_stop *)xs->cmd;
	cmd->opcode = START_STOP;
	cmd->how = type;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

int
scsi_mode_sense(struct scsi_link *link, int byte2, int page,
    struct scsi_mode_header *data, size_t len, int flags, int timeout)
{
	struct scsi_mode_sense *cmd;
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(link, flags | SCSI_DATA_IN);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)data;
	xs->datalen = len;
	xs->timeout = timeout;

	/*
	 * Make sure the sense buffer is clean before we do the mode sense, so
	 * that checks for bogus values of 0 will work in case the mode sense
	 * fails.
	 */
	bzero(data, len);

	cmd = (struct scsi_mode_sense *)xs->cmd;
	cmd->opcode = MODE_SENSE;
	cmd->byte2 = byte2;
	cmd->page = page;

	if (len > 0xff)
		len = 0xff;
	cmd->length = len;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	SC_DEBUG(link, SDEV_DB2, ("scsi_mode_sense: page %#x, error = %d\n",
	    page, error));

	return (error);
}

int
scsi_mode_sense_big(struct scsi_link *link, int byte2, int page,
    struct scsi_mode_header_big *data, size_t len, int flags, int timeout)
{
	struct scsi_mode_sense_big *cmd;
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(link, flags | SCSI_DATA_IN);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)data;
	xs->datalen = len;
	xs->timeout = timeout;

	/*
	 * Make sure the sense buffer is clean before we do the mode sense, so
	 * that checks for bogus values of 0 will work in case the mode sense
	 * fails.
	 */
	bzero(data, len);

	cmd = (struct scsi_mode_sense_big *)xs->cmd;
	cmd->opcode = MODE_SENSE_BIG;
	cmd->byte2 = byte2;
	cmd->page = page;

	if (len > 0xffff)
		len = 0xffff;
	_lto2b(len, cmd->length);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	SC_DEBUG(link, SDEV_DB2,
	    ("scsi_mode_sense_big: page %#x, error = %d\n", page, error));

	return (error);
}

void *
scsi_mode_sense_page(struct scsi_mode_header *hdr, const int page_len)
{
	int					total_length, header_length;

	total_length = hdr->data_length + sizeof(hdr->data_length);
	header_length = sizeof(*hdr) + hdr->blk_desc_len;

	if ((total_length - header_length) < page_len)
		return (NULL);

	return ((u_char *)hdr + header_length);
}

void *
scsi_mode_sense_big_page(struct scsi_mode_header_big *hdr, const int page_len)
{
	int					total_length, header_length;

	total_length = _2btol(hdr->data_length) + sizeof(hdr->data_length);
	header_length = sizeof(*hdr) + _2btol(hdr->blk_desc_len);

	if ((total_length - header_length) < page_len)
		return (NULL);

	return ((u_char *)hdr + header_length);
}

int
scsi_do_mode_sense(struct scsi_link *link, int page,
    union scsi_mode_sense_buf *buf, void **page_data, u_int32_t *density,
    u_int64_t *block_count, u_int32_t *block_size, int page_len, int flags,
    int *big)
{
	struct scsi_direct_blk_desc		*direct;
	struct scsi_blk_desc			*general;
	int					error, blk_desc_len, offset;

	*page_data = NULL;

	if (density != NULL)
		*density = 0;
	if (block_count != NULL)
		*block_count = 0;
	if (block_size != NULL)
		*block_size = 0;
	if (big != NULL)
		*big = 0;

	if ((link->flags & SDEV_ATAPI) == 0 ||
	    (link->inqdata.device & SID_TYPE) == T_SEQUENTIAL) {
		/*
		 * Try 6 byte mode sense request first. Some devices don't
		 * distinguish between 6 and 10 byte MODE SENSE commands,
		 * returning 6 byte data for 10 byte requests. ATAPI tape
		 * drives use MODE SENSE (6) even though ATAPI uses 10 byte
		 * everything else. Don't bother with SMS_DBD. Check returned
		 * data length to ensure that at least a header (3 additional
		 * bytes) is returned.
		 */
		error = scsi_mode_sense(link, 0, page, &buf->hdr,
		    sizeof(*buf), flags, 20000);
		if (error == 0) {
			*page_data = scsi_mode_sense_page(&buf->hdr, page_len);
			if (*page_data == NULL) {
				/*
				 * XXX
				 * Page data may be invalid (e.g. all zeros)
				 * but we accept the device's word that this is
				 * the best it can do. Some devices will freak
				 * out if their word is not accepted and
				 * MODE_SENSE_BIG is attempted.
				 */
				return (0);
			}
			offset = sizeof(struct scsi_mode_header);
			blk_desc_len = buf->hdr.blk_desc_len;
			goto blk_desc;
		}
	}

	/*
	 * Try 10 byte mode sense request. Don't bother with SMS_DBD or
	 * SMS_LLBAA. Bail out if the returned information is less than
	 * a big header in size (6 additional bytes).
	 */
	if ((link->flags & (SDEV_ATAPI | SDEV_UMASS)) == 0 &&
	    SCSISPC(link->inqdata.version) < 2) {
		/*
		 * The 10 byte MODE_SENSE request appeared with SCSI-2,
		 * so don't bother trying it on SCSI-1 devices, they are
		 * not supposed to understand it.
		 */
		return (0);
	}
	error = scsi_mode_sense_big(link, 0, page, &buf->hdr_big,
	    sizeof(*buf), flags, 20000);
	if (error != 0)
		return (error);
	if (_2btol(buf->hdr_big.data_length) < 6)
		return (EIO);

	if (big != NULL)
		*big = 1;
	offset = sizeof(struct scsi_mode_header_big);
	*page_data = scsi_mode_sense_big_page(&buf->hdr_big, page_len);
	blk_desc_len = _2btol(buf->hdr_big.blk_desc_len);

blk_desc:
	/* Both scsi_blk_desc and scsi_direct_blk_desc are 8 bytes. */
	if (blk_desc_len == 0 || (blk_desc_len % 8 != 0))
		return (0);

	switch (link->inqdata.device & SID_TYPE) {
	case T_SEQUENTIAL:
		/*
		 * XXX What other device types return general block descriptors?
		 */
		general = (struct scsi_blk_desc *)&buf->buf[offset];
		if (density != NULL)
			*density = general->density;
		if (block_size != NULL)
			*block_size = _3btol(general->blklen);
		if (block_count != NULL)
			*block_count = (u_int64_t)_3btol(general->nblocks);
		break;

	default:
		direct = (struct scsi_direct_blk_desc *)&buf->buf[offset];
		if (density != NULL)
			*density = direct->density;
		if (block_size != NULL)
			*block_size = _3btol(direct->blklen);
		if (block_count != NULL)
			*block_count = (u_int64_t)_4btol(direct->nblocks);
		break;
	}

	return (0);
}

int
scsi_mode_select(struct scsi_link *link, int byte2,
    struct scsi_mode_header *data, int flags, int timeout)
{
	struct scsi_mode_select *cmd;
	struct scsi_xfer *xs;
	u_int32_t len;
	int error;

	len = data->data_length + 1; /* 1 == sizeof(data_length) */

	xs = scsi_xs_get(link, flags | SCSI_DATA_OUT);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)data;
	xs->datalen = len;
	xs->timeout = timeout;

	cmd = (struct scsi_mode_select *)xs->cmd;
	cmd->opcode = MODE_SELECT;
	cmd->byte2 = byte2;
	cmd->length = len;

	/* Length is reserved when doing mode select so zero it. */
	data->data_length = 0;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	SC_DEBUG(link, SDEV_DB2, ("scsi_mode_select: error = %d\n", error));

	return (error);
}

int
scsi_mode_select_big(struct scsi_link *link, int byte2,
    struct scsi_mode_header_big *data, int flags, int timeout)
{
	struct scsi_mode_select_big *cmd;
	struct scsi_xfer *xs;
	u_int32_t len;
	int error;

	len = _2btol(data->data_length) + 2; /* 2 == sizeof data_length */

	xs = scsi_xs_get(link, flags | SCSI_DATA_OUT);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)data;
	xs->datalen = len;
	xs->timeout = timeout;

	cmd = (struct scsi_mode_select_big *)xs->cmd;
	cmd->opcode = MODE_SELECT_BIG;
	cmd->byte2 = byte2;
	_lto2b(len, cmd->length);

	/* Length is reserved when doing mode select so zero it. */
	_lto2b(0, data->data_length);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	SC_DEBUG(link, SDEV_DB2, ("scsi_mode_select_big: error = %d\n",
	    error));

	return (error);
}

int
scsi_report_luns(struct scsi_link *link, int selectreport,
    struct scsi_report_luns_data *data, u_int32_t datalen, int flags,
    int timeout)
{
	struct scsi_report_luns *cmd;
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(link, flags | SCSI_DATA_IN);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)data;
	xs->datalen = datalen;
	xs->timeout = timeout;

	bzero(data, datalen);

	cmd = (struct scsi_report_luns *)xs->cmd;
	cmd->opcode = REPORT_LUNS;
	cmd->selectreport = selectreport;
	_lto4b(datalen, cmd->length);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	SC_DEBUG(link, SDEV_DB2, ("scsi_report_luns: error = %d\n", error));

	return (error);
}

void
scsi_xs_exec(struct scsi_xfer *xs)
{
	xs->error = XS_NOERROR;
	xs->resid = xs->datalen;
	xs->status = 0;
	CLR(xs->flags, ITSDONE);

#ifdef SCSIDEBUG
	if (xs->sc_link->flags & SDEV_DB1) {
		scsi_xs_show(xs);
		if (xs->datalen && (xs->flags & SCSI_DATA_OUT))
			scsi_show_mem(xs->data, min(64, xs->datalen));
	}
#endif

	/* The adapter's scsi_cmd() is responsible for calling scsi_done(). */
	KERNEL_LOCK();
	xs->sc_link->adapter->scsi_cmd(xs);
	KERNEL_UNLOCK();
}

/*
 * This routine is called by the adapter when its xs handling is done.
 */
void
scsi_done(struct scsi_xfer *xs)
{
#ifdef SCSIDEBUG
	if (xs->sc_link->flags & SDEV_DB1) {
		if (xs->datalen && (xs->flags & SCSI_DATA_IN))
			scsi_show_mem(xs->data, min(64, xs->datalen));
	}
#endif /* SCSIDEBUG */

	SET(xs->flags, ITSDONE);
	KERNEL_LOCK();
	xs->done(xs);
	KERNEL_UNLOCK();
}

int
scsi_xs_sync(struct scsi_xfer *xs)
{
	struct mutex cookie = MUTEX_INITIALIZER(IPL_BIO);
	int error;

#ifdef DIAGNOSTIC
	if (xs->cookie != NULL)
		panic("xs->cookie != NULL in scsi_xs_sync");
	if (xs->done != NULL)
		panic("xs->done != NULL in scsi_xs_sync");
#endif

	/*
	 * If we cant sleep while waiting for completion, get the adapter to
	 * complete it for us.
	 */
	if (ISSET(xs->flags, SCSI_NOSLEEP))
		SET(xs->flags, SCSI_POLL);

	xs->done = scsi_xs_sync_done;

	do {
		xs->cookie = &cookie;

		scsi_xs_exec(xs);

		mtx_enter(&cookie);
		while (xs->cookie != NULL)
			msleep(xs, &cookie, PRIBIO, "syncxs", 0);
		mtx_leave(&cookie);

		error = scsi_xs_error(xs);
	} while (error == ERESTART);

	return (error);
}

void
scsi_xs_sync_done(struct scsi_xfer *xs)
{
	struct mutex *cookie = xs->cookie;

	if (cookie == NULL)
		panic("scsi_done called twice on xs(%p)", xs);

	mtx_enter(cookie);
	xs->cookie = NULL;
	if (!ISSET(xs->flags, SCSI_NOSLEEP))
		wakeup_one(xs);
	mtx_leave(cookie);
}

int
scsi_xs_error(struct scsi_xfer *xs)
{
	int error = EIO;

	SC_DEBUG(xs->sc_link, SDEV_DB3, ("scsi_xs_error,err = 0x%x\n",
	    xs->error));

	if (ISSET(xs->sc_link->state, SDEV_S_DYING))
		return (ENXIO);

	switch (xs->error) {
	case XS_NOERROR:	/* nearly always hit this one */
		error = 0;
		break;

	case XS_SENSE:
	case XS_SHORTSENSE:
#ifdef SCSIDEBUG
		scsi_sense_print_debug(xs);
#endif
		error = xs->sc_link->interpret_sense(xs);
		SC_DEBUG(xs->sc_link, SDEV_DB3,
		    ("scsi_interpret_sense returned %#x\n", error));
		break;

	case XS_NO_CCB:
	case XS_BUSY:
		error = scsi_delay(xs, 1);
		break;

	case XS_TIMEOUT:
	case XS_RESET:
		error = ERESTART;
		break;

	case XS_DRIVER_STUFFUP:
	case XS_SELTIMEOUT:
		break;

	default:
		sc_print_addr(xs->sc_link);
		printf("unknown error category (0x%x) from scsi driver\n",
		    xs->error);
		break;
	}

	if (error == ERESTART && xs->retries-- < 1)
		return (EIO);
	else
		return (error);
}

int
scsi_delay(struct scsi_xfer *xs, int seconds)
{
	switch (xs->flags & (SCSI_POLL | SCSI_NOSLEEP)) {
	case SCSI_POLL:
		delay(1000000 * seconds);
		return (ERESTART);
	case SCSI_NOSLEEP:
		/* Retry the command immediately since we can't delay. */
		return (ERESTART);
	case (SCSI_POLL | SCSI_NOSLEEP):
		/* Invalid combination! */
		return (EIO);
	}

	while (seconds-- > 0) {
		if (tsleep(&lbolt, PRIBIO|PCATCH, "scbusy", 0)) {
			/* Signal == abort xs. */
			return (EIO);
		}
	}

	return (ERESTART);
}

#ifdef SCSIDEBUG
/*
 * Print out sense data details.
 */
void
scsi_sense_print_debug(struct scsi_xfer *xs)
{
	struct scsi_sense_data *sense = &xs->sense;
	struct scsi_link *link = xs->sc_link;

	SC_DEBUG(link, SDEV_DB1,
	    ("code:%#x valid:%d key:%#x ili:%d eom:%d fmark:%d extra:%d\n",
	    sense->error_code & SSD_ERRCODE,
	    sense->error_code & SSD_ERRCODE_VALID ? 1 : 0,
	    sense->flags & SSD_KEY,
	    sense->flags & SSD_ILI ? 1 : 0,
	    sense->flags & SSD_EOM ? 1 : 0,
	    sense->flags & SSD_FILEMARK ? 1 : 0,
	    sense->extra_len));

	if (xs->sc_link->flags & SDEV_DB1)
		scsi_show_mem((u_char *)&xs->sense, sizeof(xs->sense));

	scsi_print_sense(xs);
}
#endif

/*
 * Look at the returned sense and act on the error, determining
 * the unix error number to pass back.  (0 = report no error)
 *
 * THIS IS THE DEFAULT ERROR HANDLER
 */
int
scsi_interpret_sense(struct scsi_xfer *xs)
{
	struct scsi_sense_data			*sense = &xs->sense;
	struct scsi_link			*link = xs->sc_link;
	u_int8_t				serr, skey;
	int					error;

	/* Default sense interpretation. */
	serr = sense->error_code & SSD_ERRCODE;
	if (serr != SSD_ERRCODE_CURRENT && serr != SSD_ERRCODE_DEFERRED)
		skey = 0xff;	/* Invalid value, since key is 4 bit value. */
	else
		skey = sense->flags & SSD_KEY;

	/*
	 * Interpret the key/asc/ascq information where appropriate.
	 */
	error = 0;
	switch (skey) {
	case SKEY_NO_SENSE:
	case SKEY_RECOVERED_ERROR:
		if (xs->resid == xs->datalen)
			xs->resid = 0;	/* not short read */
		break;
	case SKEY_BLANK_CHECK:
	case SKEY_EQUAL:
		break;
	case SKEY_NOT_READY:
		if ((xs->flags & SCSI_IGNORE_NOT_READY) != 0)
			return (0);
		error = EIO;
		if (xs->retries) {
			switch (ASC_ASCQ(sense)) {
			case SENSE_NOT_READY_BECOMING_READY:
			case SENSE_NOT_READY_FORMAT:
			case SENSE_NOT_READY_REBUILD:
			case SENSE_NOT_READY_RECALC:
			case SENSE_NOT_READY_INPROGRESS:
			case SENSE_NOT_READY_LONGWRITE:
			case SENSE_NOT_READY_SELFTEST:
			case SENSE_NOT_READY_INIT_REQUIRED:
				SC_DEBUG(link, SDEV_DB1,
				    ("not ready (ASC_ASCQ == %#x)\n",
				    ASC_ASCQ(sense)));
				return (scsi_delay(xs, 1));
			case SENSE_NOMEDIUM:
			case SENSE_NOMEDIUM_TCLOSED:
			case SENSE_NOMEDIUM_TOPEN:
			case SENSE_NOMEDIUM_LOADABLE:
			case SENSE_NOMEDIUM_AUXMEM:
				link->flags &= ~SDEV_MEDIA_LOADED;
				error = ENOMEDIUM;
				break;
			default:
				break;
			}
		}
		break;
	case SKEY_MEDIUM_ERROR:
		switch (ASC_ASCQ(sense)) {
		case SENSE_NOMEDIUM:
		case SENSE_NOMEDIUM_TCLOSED:
		case SENSE_NOMEDIUM_TOPEN:
		case SENSE_NOMEDIUM_LOADABLE:
		case SENSE_NOMEDIUM_AUXMEM:
			link->flags &= ~SDEV_MEDIA_LOADED;
			error = ENOMEDIUM;
			break;
		case SENSE_BAD_MEDIUM:
		case SENSE_NR_MEDIUM_UNKNOWN_FORMAT:
		case SENSE_NR_MEDIUM_INCOMPATIBLE_FORMAT:
		case SENSE_NW_MEDIUM_UNKNOWN_FORMAT:
		case SENSE_NW_MEDIUM_INCOMPATIBLE_FORMAT:
		case SENSE_NF_MEDIUM_INCOMPATIBLE_FORMAT:
		case SENSE_NW_MEDIUM_AC_MISMATCH:
			error = EMEDIUMTYPE;
			break;
		default:
			error = EIO;
			break;
		}
		break;
	case SKEY_ILLEGAL_REQUEST:
		if ((xs->flags & SCSI_IGNORE_ILLEGAL_REQUEST) != 0)
			return (0);
		if (ASC_ASCQ(sense) == SENSE_MEDIUM_REMOVAL_PREVENTED)
			return(EBUSY);
		error = EINVAL;
		break;
	case SKEY_UNIT_ATTENTION:
		switch (ASC_ASCQ(sense)) {
		case SENSE_POWER_RESET_OR_BUS:
		case SENSE_POWER_ON:
		case SENSE_BUS_RESET:
		case SENSE_BUS_DEVICE_RESET:
		case SENSE_DEVICE_INTERNAL_RESET:
		case SENSE_TSC_CHANGE_SE:
		case SENSE_TSC_CHANGE_LVD:
		case SENSE_IT_NEXUS_LOSS:
			return (scsi_delay(xs, 1));
		default:
			break;
		}
		if ((link->flags & SDEV_REMOVABLE) != 0)
			link->flags &= ~SDEV_MEDIA_LOADED;
		if ((xs->flags & SCSI_IGNORE_MEDIA_CHANGE) != 0 ||
		    /* XXX Should reupload any transient state. */
		    (link->flags & SDEV_REMOVABLE) == 0) {
			return (scsi_delay(xs, 1));
		}
		error = EIO;
		break;
	case SKEY_WRITE_PROTECT:
		error = EROFS;
		break;
	case SKEY_ABORTED_COMMAND:
		error = ERESTART;
		break;
	case SKEY_VOLUME_OVERFLOW:
		error = ENOSPC;
		break;
	case SKEY_HARDWARE_ERROR:
		if (ASC_ASCQ(sense) == SENSE_CARTRIDGE_FAULT)
			return(EMEDIUMTYPE);
		error = EIO;
		break;
	default:
		error = EIO;
		break;
	}

#ifndef SCSIDEBUG
	/* SCSIDEBUG would mean it has already been printed. */
	if (skey && (xs->flags & SCSI_SILENT) == 0)
		scsi_print_sense(xs);
#endif /* SCSIDEBUG */

	return (error);
}

/*
 * Utility routines often used in SCSI stuff
 */


/*
 * Print out the scsi_link structure's address info.
 */
void
sc_print_addr(struct scsi_link *link)
{
	struct device *adapter_device = link->bus->sc_dev.dv_parent;

	printf("%s(%s:%d:%d): ",
	    link->device_softc ?
	    ((struct device *)link->device_softc)->dv_xname : "probe",
	    adapter_device->dv_xname,
	    link->target, link->lun);
}

static const char *sense_keys[16] = {
	"No Additional Sense",
	"Soft Error",
	"Not Ready",
	"Media Error",
	"Hardware Error",
	"Illegal Request",
	"Unit Attention",
	"Write Protected",
	"Blank Check",
	"Vendor Unique",
	"Copy Aborted",
	"Aborted Command",
	"Equal Error",
	"Volume Overflow",
	"Miscompare Error",
	"Reserved"
};

#ifdef SCSITERSE
static __inline void
asc2ascii(u_int8_t asc, u_int8_t ascq, char *result, size_t len)
{
	snprintf(result, len, "ASC 0x%02x ASCQ 0x%02x", asc, ascq);
}
#else
static const struct {
	u_int8_t asc, ascq;
	char *description;
} adesc[] = {
	/* www.t10.org/lists/asc-num.txt as of 11/15/10. */
	{ 0x00, 0x00, "No Additional Sense Information" },
	{ 0x00, 0x01, "Filemark Detected" },
	{ 0x00, 0x02, "End-Of-Partition/Medium Detected" },
	{ 0x00, 0x03, "Setmark Detected" },
	{ 0x00, 0x04, "Beginning-Of-Partition/Medium Detected" },
	{ 0x00, 0x05, "End-Of-Data Detected" },
	{ 0x00, 0x06, "I/O Process Terminated" },
	{ 0x00, 0x11, "Audio Play Operation In Progress" },
	{ 0x00, 0x12, "Audio Play Operation Paused" },
	{ 0x00, 0x13, "Audio Play Operation Successfully Completed" },
	{ 0x00, 0x14, "Audio Play Operation Stopped Due to Error" },
	{ 0x00, 0x15, "No Current Audio Status To Return" },
	{ 0x00, 0x16, "Operation In Progress" },
	{ 0x00, 0x17, "Cleaning Requested" },
	{ 0x00, 0x18, "Erase Operation In Progress" },
	{ 0x00, 0x19, "Locate Operation In Progress" },
	{ 0x00, 0x1A, "Rewind Operation In Progress" },
	{ 0x00, 0x1B, "Set Capacity Operation In Progress" },
	{ 0x00, 0x1C, "Verify Operation In Progress" },
	{ 0x01, 0x00, "No Index/Sector Signal" },
	{ 0x02, 0x00, "No Seek Complete" },
	{ 0x03, 0x00, "Peripheral Device Write Fault" },
	{ 0x03, 0x01, "No Write Current" },
	{ 0x03, 0x02, "Excessive Write Errors" },
	{ 0x04, 0x00, "Logical Unit Not Ready, Cause Not Reportable" },
	{ 0x04, 0x01, "Logical Unit Is in Process Of Becoming Ready" },
	{ 0x04, 0x02, "Logical Unit Not Ready, Initialization Command Required" },
	{ 0x04, 0x03, "Logical Unit Not Ready, Manual Intervention Required" },
	{ 0x04, 0x04, "Logical Unit Not Ready, Format In Progress" },
	{ 0x04, 0x05, "Logical Unit Not Ready, Rebuild In Progress" },
	{ 0x04, 0x06, "Logical Unit Not Ready, Recalculation In Progress" },
	{ 0x04, 0x07, "Logical Unit Not Ready, Operation In Progress" },
	{ 0x04, 0x08, "Logical Unit Not Ready, Long Write In Progress" },
	{ 0x04, 0x09, "Logical Unit Not Ready, Self-Test In Progress" },
	{ 0x04, 0x0A, "Logical Unit Not Accessible, Asymmetric Access State Transition" },
	{ 0x04, 0x0B, "Logical Unit Not Accessible, Target Port In Standby State" },
	{ 0x04, 0x0C, "Logical Unit Not Accessible, Target Port In Unavailable State" },
	{ 0x04, 0x0D, "Logical Unit Not Ready, Structure Check Required" },
	{ 0x04, 0x10, "Logical Unit Not Ready, Auxiliary Memory Not Accessible" },
	{ 0x04, 0x11, "Logical Unit Not Ready, Notify (Enable Spinup) Required" },
	{ 0x04, 0x12, "Logical Unit Not Ready, Offline" },
	{ 0x04, 0x13, "Logical Unit Not Ready, SA Creation In Progress" },
	{ 0x04, 0x14, "Logical Unit Not Ready, Space Allocation In Progress" },
	{ 0x04, 0x15, "Logical Unit Not Ready, Robotics Disabled" },
	{ 0x04, 0x16, "Logical Unit Not Ready, Configuration Required" },
	{ 0x04, 0x17, "Logical Unit Not Ready, Calibration Required" },
	{ 0x04, 0x18, "Logical Unit Not Ready, A Door Is Open" },
	{ 0x04, 0x19, "Logical Unit Not Ready, Operating In Sequential Mode" },
	{ 0x04, 0x1A, "Logical Unit Not Ready, Start Stop Unit Command In Progress" },
	{ 0x05, 0x00, "Logical Unit Does Not Respond To Selection" },
	{ 0x06, 0x00, "No Reference Position Found" },
	{ 0x07, 0x00, "Multiple Peripheral Devices Selected" },
	{ 0x08, 0x00, "Logical Unit Communication Failure" },
	{ 0x08, 0x01, "Logical Unit Communication Timeout" },
	{ 0x08, 0x02, "Logical Unit Communication Parity Error" },
	{ 0x08, 0x03, "Logical Unit Communication CRC Error (ULTRA-DMA/32)" },
	{ 0x08, 0x04, "Unreachable Copy Target" },
	{ 0x09, 0x00, "Track Following Error" },
	{ 0x09, 0x01, "Tracking Servo Failure" },
	{ 0x09, 0x02, "Focus Servo Failure" },
	{ 0x09, 0x03, "Spindle Servo Failure" },
	{ 0x09, 0x04, "Head Select Fault" },
	{ 0x0A, 0x00, "Error Log Overflow" },
	{ 0x0B, 0x00, "Warning" },
	{ 0x0B, 0x01, "Warning - Specified Temperature Exceeded" },
	{ 0x0B, 0x02, "Warning - Enclosure Degraded" },
	{ 0x0B, 0x03, "Warning - Background Self-Test Failed" },
	{ 0x0B, 0x04, "Warning - Background Pre-Scan Detected Medium Error" },
	{ 0x0B, 0x05, "Warning - Background Medium Scan Detected Medium Error" },
	{ 0x0B, 0x06, "Warning - Non-Volatile Cache Now Volatile" },
	{ 0x0B, 0x07, "Warning - Degraded Power To Non-Volatile Cache" },
	{ 0x0B, 0x08, "Warning - Power Loss Expected" },
	{ 0x0C, 0x00, "Write Error" },
	{ 0x0C, 0x01, "Write Error Recovered with Auto Reallocation" },
	{ 0x0C, 0x02, "Write Error - Auto Reallocate Failed" },
	{ 0x0C, 0x03, "Write Error - Recommend Reassignment" },
	{ 0x0C, 0x04, "Compression Check Miscompare Error" },
	{ 0x0C, 0x05, "Data Expansion Occurred During Compression" },
	{ 0x0C, 0x06, "Block Not Compressible" },
	{ 0x0C, 0x07, "Write Error - Recovery Needed" },
	{ 0x0C, 0x08, "Write Error - Recovery Failed" },
	{ 0x0C, 0x09, "Write Error - Loss Of Streaming" },
	{ 0x0C, 0x0A, "Write Error - Padding Blocks Added" },
	{ 0x0C, 0x0B, "Auxiliary Memory Write Error" },
	{ 0x0C, 0x0C, "Write Error - Unexpected Unsolicited Data" },
	{ 0x0C, 0x0D, "Write Error - Not Enough Unsolicited Data" },
	{ 0x0C, 0x0F, "Defects In Error Window" },
	{ 0x0D, 0x00, "Error Detected By Third Party Temporary Initiator" },
	{ 0x0D, 0x01, "Third Party Device Failure" },
	{ 0x0D, 0x02, "Copy Target Device Not Reachable" },
	{ 0x0D, 0x03, "Incorrect Copy Target Device Type" },
	{ 0x0D, 0x04, "Copy Target Device Data Underrun" },
	{ 0x0D, 0x05, "Copy Target Device Data Overrun" },
	{ 0x0E, 0x00, "Invalid Information Unit" },
	{ 0x0E, 0x01, "Information Unit Too Short" },
	{ 0x0E, 0x02, "Information Unit Too Long" },
	{ 0x10, 0x00, "ID CRC Or ECC Error" },
	{ 0x10, 0x01, "Logical Block Guard Check Failed" },
	{ 0x10, 0x02, "Logical Block Application Tag Check Failed" },
	{ 0x10, 0x03, "Logical Block Reference Tag Check Failed" },
	{ 0x10, 0x04, "Logical Block Protection Error On Recover Buffered Data" },
	{ 0x10, 0x05, "Logical Block Protection Method Error" },
	{ 0x11, 0x00, "Unrecovered Read Error" },
	{ 0x11, 0x01, "Read Retries Exhausted" },
	{ 0x11, 0x02, "Error Too Long To Correct" },
	{ 0x11, 0x03, "Multiple Read Errors" },
	{ 0x11, 0x04, "Unrecovered Read Error - Auto Reallocate Failed" },
	{ 0x11, 0x05, "L-EC Uncorrectable Error" },
	{ 0x11, 0x06, "CIRC Unrecovered Error" },
	{ 0x11, 0x07, "Data Resynchronization Error" },
	{ 0x11, 0x08, "Incomplete Block Read" },
	{ 0x11, 0x09, "No Gap Found" },
	{ 0x11, 0x0A, "Miscorrected Error" },
	{ 0x11, 0x0B, "Uncorrected Read Error - Recommend Reassignment" },
	{ 0x11, 0x0C, "Uncorrected Read Error - Recommend Rewrite The Data" },
	{ 0x11, 0x0D, "De-Compression CRC Error" },
	{ 0x11, 0x0E, "Cannot Decompress Using Declared Algorithm" },
	{ 0x11, 0x0F, "Error Reading UPC/EAN Number" },
	{ 0x11, 0x10, "Error Reading ISRC Number" },
	{ 0x11, 0x11, "Read Error - Loss Of Streaming" },
	{ 0x11, 0x12, "Auxiliary Memory Read Error" },
	{ 0x11, 0x13, "Read Error - Failed Retransmission Request" },
	{ 0x11, 0x14, "Read Error - LBA Marked Bad By Application Client" },
	{ 0x12, 0x00, "Address Mark Not Found for ID Field" },
	{ 0x13, 0x00, "Address Mark Not Found for Data Field" },
	{ 0x14, 0x00, "Recorded Entity Not Found" },
	{ 0x14, 0x01, "Record Not Found" },
	{ 0x14, 0x02, "Filemark or Setmark Not Found" },
	{ 0x14, 0x03, "End-Of-Data Not Found" },
	{ 0x14, 0x04, "Block Sequence Error" },
	{ 0x14, 0x05, "Record Not Found - Recommend Reassignment" },
	{ 0x14, 0x06, "Record Not Found - Data Auto-Reallocated" },
	{ 0x14, 0x07, "Locate Operation Failure" },
	{ 0x15, 0x00, "Random Positioning Error" },
	{ 0x15, 0x01, "Mechanical Positioning Error" },
	{ 0x15, 0x02, "Positioning Error Detected By Read of Medium" },
	{ 0x16, 0x00, "Data Synchronization Mark Error" },
	{ 0x16, 0x01, "Data Sync Error - Data Rewritten" },
	{ 0x16, 0x02, "Data Sync Error - Recommend Rewrite" },
	{ 0x16, 0x03, "Data Sync Error - Data Auto-Reallocated" },
	{ 0x16, 0x04, "Data Sync Error - Recommend Reassignment" },
	{ 0x17, 0x00, "Recovered Data With No Error Correction Applied" },
	{ 0x17, 0x01, "Recovered Data With Retries" },
	{ 0x17, 0x02, "Recovered Data With Positive Head Offset" },
	{ 0x17, 0x03, "Recovered Data With Negative Head Offset" },
	{ 0x17, 0x04, "Recovered Data With Retries and/or CIRC Applied" },
	{ 0x17, 0x05, "Recovered Data Using Previous Sector ID" },
	{ 0x17, 0x06, "Recovered Data Without ECC - Data Auto-Reallocated" },
	{ 0x17, 0x07, "Recovered Data Without ECC - Recommend Reassignment" },
	{ 0x17, 0x08, "Recovered Data Without ECC - Recommend Rewrite" },
	{ 0x17, 0x09, "Recovered Data Without ECC - Data Rewritten" },
	{ 0x18, 0x00, "Recovered Data With Error Correction Applied" },
	{ 0x18, 0x01, "Recovered Data With Error Correction & Retries Applied" },
	{ 0x18, 0x02, "Recovered Data - Data Auto-Reallocated" },
	{ 0x18, 0x03, "Recovered Data With CIRC" },
	{ 0x18, 0x04, "Recovered Data With L-EC" },
	{ 0x18, 0x05, "Recovered Data - Recommend Reassignment" },
	{ 0x18, 0x06, "Recovered Data - Recommend Rewrite" },
	{ 0x18, 0x07, "Recovered Data With ECC - Data Rewritten" },
	{ 0x18, 0x08, "Recovered Data With Linking" },
	{ 0x19, 0x00, "Defect List Error" },
	{ 0x19, 0x01, "Defect List Not Available" },
	{ 0x19, 0x02, "Defect List Error in Primary List" },
	{ 0x19, 0x03, "Defect List Error in Grown List" },
	{ 0x1A, 0x00, "Parameter List Length Error" },
	{ 0x1B, 0x00, "Synchronous Data Transfer Error" },
	{ 0x1C, 0x00, "Defect List Not Found" },
	{ 0x1C, 0x01, "Primary Defect List Not Found" },
	{ 0x1C, 0x02, "Grown Defect List Not Found" },
	{ 0x1D, 0x00, "Miscompare During Verify Operation" },
	{ 0x1D, 0x01, "Miscompare Verify Of Unmapped Lba" },
	{ 0x1E, 0x00, "Recovered ID with ECC" },
	{ 0x1F, 0x00, "Partial Defect List Transfer" },
	{ 0x20, 0x00, "Invalid Command Operation Code" },
	{ 0x20, 0x01, "Access Denied - Initiator Pending-Enrolled" },
	{ 0x20, 0x02, "Access Denied - No Access rights" },
	{ 0x20, 0x03, "Access Denied - Invalid Mgmt ID Key" },
	{ 0x20, 0x04, "Illegal Command While In Write Capable State" },
	{ 0x20, 0x05, "Obsolete" },
	{ 0x20, 0x06, "Illegal Command While In Explicit Address Mode" },
	{ 0x20, 0x07, "Illegal Command While In Implicit Address Mode" },
	{ 0x20, 0x08, "Access Denied - Enrollment Conflict" },
	{ 0x20, 0x09, "Access Denied - Invalid LU Identifier" },
	{ 0x20, 0x0A, "Access Denied - Invalid Proxy Token" },
	{ 0x20, 0x0B, "Access Denied - ACL LUN Conflict" },
	{ 0x20, 0x0C, "Illegal Command When Not In Append-Only Mode" },
	{ 0x21, 0x00, "Logical Block Address Out of Range" },
	{ 0x21, 0x01, "Invalid Element Address" },
	{ 0x21, 0x02, "Invalid Address For Write" },
	{ 0x21, 0x03, "Invalid Write Crossing Layer Jump" },
	{ 0x22, 0x00, "Illegal Function (Should 20 00, 24 00, or 26 00)" },
	{ 0x24, 0x00, "Illegal Field in CDB" },
	{ 0x24, 0x01, "CDB Decryption Error" },
	{ 0x24, 0x02, "Obsolete" },
	{ 0x24, 0x03, "Obsolete" },
	{ 0x24, 0x04, "Security Audit Value Frozen" },
	{ 0x24, 0x05, "Security Working Key Frozen" },
	{ 0x24, 0x06, "Nonce Not Unique" },
	{ 0x24, 0x07, "Nonce Timestamp Out Of Range" },
	{ 0x24, 0x08, "Invalid XCDB" },
	{ 0x25, 0x00, "Logical Unit Not Supported" },
	{ 0x26, 0x00, "Invalid Field In Parameter List" },
	{ 0x26, 0x01, "Parameter Not Supported" },
	{ 0x26, 0x02, "Parameter Value Invalid" },
	{ 0x26, 0x03, "Threshold Parameters Not Supported" },
	{ 0x26, 0x04, "Invalid Release Of Persistent Reservation" },
	{ 0x26, 0x05, "Data Decryption Error" },
	{ 0x26, 0x06, "Too Many Target Descriptors" },
	{ 0x26, 0x07, "Unsupported Target Descriptor Type Code" },
	{ 0x26, 0x08, "Too Many Segment Descriptors" },
	{ 0x26, 0x09, "Unsupported Segment Descriptor Type Code" },
	{ 0x26, 0x0A, "Unexpected Inexact Segment" },
	{ 0x26, 0x0B, "Inline Data Length Exceeded" },
	{ 0x26, 0x0C, "Invalid Operation For Copy Source Or Destination" },
	{ 0x26, 0x0D, "Copy Segment Granularity Violation" },
	{ 0x26, 0x0E, "Invalid Parameter While Port Is Enabled" },
	{ 0x26, 0x0F, "Invalid Data-Out Buffer Integrity Check Value" },
	{ 0x26, 0x10, "Data Decryption Key Fail Limit Reached" },
	{ 0x26, 0x11, "Incomplete Key-Associated Data Set" },
	{ 0x26, 0x12, "Vendor Specific Key Reference Not Found" },
	{ 0x27, 0x00, "Write Protected" },
	{ 0x27, 0x01, "Hardware Write Protected" },
	{ 0x27, 0x02, "Logical Unit Software Write Protected" },
	{ 0x27, 0x03, "Associated Write Protect" },
	{ 0x27, 0x04, "Persistent Write Protect" },
	{ 0x27, 0x05, "Permanent Write Protect" },
	{ 0x27, 0x06, "Conditional Write Protect" },
	{ 0x27, 0x07, "Space Allocation Failed Write Protect" },
	{ 0x28, 0x00, "Not Ready To Ready Transition (Medium May Have Changed)" },
	{ 0x28, 0x01, "Import Or Export Element Accessed" },
	{ 0x28, 0x02, "Format-Layer May Have Changed" },
	{ 0x28, 0x03, "Import/Export Element Accessed, Medium Changed" },
	{ 0x29, 0x00, "Power On, Reset, or Bus Device Reset Occurred" },
	{ 0x29, 0x01, "Power On Occurred" },
	{ 0x29, 0x02, "SCSI Bus Reset Occurred" },
	{ 0x29, 0x03, "Bus Device Reset Function Occurred" },
	{ 0x29, 0x04, "Device Internal Reset" },
	{ 0x29, 0x05, "Transceiver Mode Changed to Single Ended" },
	{ 0x29, 0x06, "Transceiver Mode Changed to LVD" },
	{ 0x29, 0x07, "I_T Nexus Loss Occurred" },
	{ 0x2A, 0x00, "Parameters Changed" },
	{ 0x2A, 0x01, "Mode Parameters Changed" },
	{ 0x2A, 0x02, "Log Parameters Changed" },
	{ 0x2A, 0x03, "Reservations Preempted" },
	{ 0x2A, 0x04, "Reservations Released" },
	{ 0x2A, 0x05, "Registrations Preempted" },
	{ 0x2A, 0x06, "Asymmetric Access State Changed" },
	{ 0x2A, 0x07, "Implicit Asymmetric Access State Transition Failed" },
	{ 0x2A, 0x08, "Priority Changed" },
	{ 0x2A, 0x09, "Capacity Data Has Changed" },
	{ 0x2A, 0x0A, "Error History I_T Nexus Cleared" },
	{ 0x2A, 0x0B, "Error History Snapshot Released" },
	{ 0x2A, 0x0C, "Error Recovery Attributes Have Changed" },
	{ 0x2A, 0x0D, "Data Encryption Capabilities Changed" },
	{ 0x2A, 0x10, "Timestamp Changed" },
	{ 0x2A, 0x11, "Data Encryption Parameters Changed By Another I_T Nexus" },
	{ 0x2A, 0x12, "Data Encryption Parameters Changed By Vendor Specific Event" },
	{ 0x2A, 0x13, "Data Encryption Key Instance Counter Has Changed" },
	{ 0x2A, 0x14, "SA Creation Capabilities Data Has Changed" },
	{ 0x2B, 0x00, "Copy Cannot Execute Since Host Cannot Disconnect" },
	{ 0x2C, 0x00, "Command Sequence Error" },
	{ 0x2C, 0x01, "Too Many Windows Specified" },
	{ 0x2C, 0x02, "Invalid Combination of Windows Specified" },
	{ 0x2C, 0x03, "Current Program Area Is Not Empty" },
	{ 0x2C, 0x04, "Current Program Area Is Empty" },
	{ 0x2C, 0x05, "Illegal Power Condition Request" },
	{ 0x2C, 0x06, "Persistent Prevent Conflict" },
	{ 0x2C, 0x07, "Previous Busy Status" },
	{ 0x2C, 0x08, "Previous Task Set Full Status" },
	{ 0x2C, 0x09, "Previous Reservation Conflict Status" },
	{ 0x2C, 0x0A, "Partition Or Collection Contains User Objects" },
	{ 0x2C, 0x0B, "Not Reserved" },
	{ 0x2C, 0x0C, "ORWrite Generation Does Not Match" },
	{ 0x2D, 0x00, "Overwrite Error On Update In Place" },
	{ 0x2E, 0x00, "Insufficient Time For Operation" },
	{ 0x2F, 0x00, "Commands Cleared By Another Initiator" },
	{ 0x2F, 0x01, "Commands Cleared By Power Loss Notification" },
	{ 0x2F, 0x02, "Commands Cleared By Device Server" },
	{ 0x30, 0x00, "Incompatible Medium Installed" },
	{ 0x30, 0x01, "Cannot Read Medium - Unknown Format" },
	{ 0x30, 0x02, "Cannot Read Medium - Incompatible Format" },
	{ 0x30, 0x03, "Cleaning Cartridge Installed" },
	{ 0x30, 0x04, "Cannot Write Medium - Unknown Format" },
	{ 0x30, 0x05, "Cannot Write Medium - Incompatible Format" },
	{ 0x30, 0x06, "Cannot Format Medium - Incompatible Medium" },
	{ 0x30, 0x07, "Cleaning Failure" },
	{ 0x30, 0x08, "Cannot Write - Application Code Mismatch" },
	{ 0x30, 0x09, "Current Session Not Fixated For Append" },
	{ 0x30, 0x0A, "Cleaning Request Rejected" },
	{ 0x30, 0x10, "Medium Not Formatted" },
	{ 0x30, 0x11, "Incompatible Volume Type" },
	{ 0x30, 0x12, "Incompatible Volume Qualifier" },
	{ 0x30, 0x13, "Cleaning Volume Expired" },
	{ 0x31, 0x00, "Medium Format Corrupted" },
	{ 0x31, 0x01, "Format Command Failed" },
	{ 0x31, 0x02, "Zoned Formatting Failed Due To Spare Linking" },
	{ 0x32, 0x00, "No Defect Spare Location Available" },
	{ 0x32, 0x01, "Defect List Update Failure" },
	{ 0x33, 0x00, "Tape Length Error" },
	{ 0x34, 0x00, "Enclosure Failure" },
	{ 0x35, 0x00, "Enclosure Services Failure" },
	{ 0x35, 0x01, "Unsupported Enclosure Function" },
	{ 0x35, 0x02, "Enclosure Services Unavailable" },
	{ 0x35, 0x03, "Enclosure Services Transfer Failure" },
	{ 0x35, 0x04, "Enclosure Services Transfer Refused" },
	{ 0x36, 0x00, "Ribbon, Ink, or Toner Failure" },
	{ 0x37, 0x00, "Rounded Parameter" },
	{ 0x38, 0x00, "Event Status Notification" },
	{ 0x38, 0x02, "ESN - Power Management Class Event" },
	{ 0x38, 0x04, "ESN - Media Class Event" },
	{ 0x38, 0x06, "ESN - Device Busy Class Event" },
	{ 0x39, 0x00, "Saving Parameters Not Supported" },
	{ 0x3A, 0x00, "Medium Not Present" },
	{ 0x3A, 0x01, "Medium Not Present - Tray Closed" },
	{ 0x3A, 0x02, "Medium Not Present - Tray Open" },
	{ 0x3A, 0x03, "Medium Not Present - Loadable" },
	{ 0x3A, 0x04, "Medium Not Present - Medium Auxiliary Memory Accessible" },
	{ 0x3B, 0x00, "Sequential Positioning Error" },
	{ 0x3B, 0x01, "Tape Position Error At Beginning-of-Medium" },
	{ 0x3B, 0x02, "Tape Position Error At End-of-Medium" },
	{ 0x3B, 0x03, "Tape or Electronic Vertical Forms Unit Not Ready" },
	{ 0x3B, 0x04, "Slew Failure" },
	{ 0x3B, 0x05, "Paper Jam" },
	{ 0x3B, 0x06, "Failed To Sense Top-Of-Form" },
	{ 0x3B, 0x07, "Failed To Sense Bottom-Of-Form" },
	{ 0x3B, 0x08, "Reposition Error" },
	{ 0x3B, 0x09, "Read Past End Of Medium" },
	{ 0x3B, 0x0A, "Read Past Beginning Of Medium" },
	{ 0x3B, 0x0B, "Position Past End Of Medium" },
	{ 0x3B, 0x0C, "Position Past Beginning Of Medium" },
	{ 0x3B, 0x0D, "Medium Destination Element Full" },
	{ 0x3B, 0x0E, "Medium Source Element Empty" },
	{ 0x3B, 0x0F, "End Of Medium Reached" },
	{ 0x3B, 0x11, "Medium Magazine Not Accessible" },
	{ 0x3B, 0x12, "Medium Magazine Removed" },
	{ 0x3B, 0x13, "Medium Magazine Inserted" },
	{ 0x3B, 0x14, "Medium Magazine Locked" },
	{ 0x3B, 0x15, "Medium Magazine Unlocked" },
	{ 0x3B, 0x16, "Mechanical Positioning Or Changer Error" },
	{ 0x3B, 0x17, "Read Past End Of User Object" },
	{ 0x3B, 0x18, "Element Disabled" },
	{ 0x3B, 0x19, "Element Enabled" },
	{ 0x3B, 0x1A, "Data Transfer Device Removed" },
	{ 0x3B, 0x1B, "Data Transfer Device Inserted" },
	{ 0x3D, 0x00, "Invalid Bits In IDENTIFY Message" },
	{ 0x3E, 0x00, "Logical Unit Has Not Self-Configured Yet" },
	{ 0x3E, 0x01, "Logical Unit Failure" },
	{ 0x3E, 0x02, "Timeout On Logical Unit" },
	{ 0x3E, 0x03, "Logical Unit Failed Self-Test" },
	{ 0x3E, 0x04, "Logical Unit Unable To Update Self-Test Log" },
	{ 0x3F, 0x00, "Target Operating Conditions Have Changed" },
	{ 0x3F, 0x01, "Microcode Has Changed" },
	{ 0x3F, 0x02, "Changed Operating Definition" },
	{ 0x3F, 0x03, "INQUIRY Data Has Changed" },
	{ 0x3F, 0x04, "component Device Attached" },
	{ 0x3F, 0x05, "Device Identifier Changed" },
	{ 0x3F, 0x06, "Redundancy Group Created Or Modified" },
	{ 0x3F, 0x07, "Redundancy Group Deleted" },
	{ 0x3F, 0x08, "Spare Created Or Modified" },
	{ 0x3F, 0x09, "Spare Deleted" },
	{ 0x3F, 0x0A, "Volume Set Created Or Modified" },
	{ 0x3F, 0x0B, "Volume Set Deleted" },
	{ 0x3F, 0x0C, "Volume Set Deassigned" },
	{ 0x3F, 0x0D, "Volume Set Reassigned" },
	{ 0x3F, 0x0E, "Reported LUNs Data Has Changed" },
	{ 0x3F, 0x0F, "Echo Buffer Overwritten" },
	{ 0x3F, 0x10, "Medium Loadable" },
	{ 0x3F, 0x11, "Medium Auxiliary Memory Accessible" },
	{ 0x3F, 0x12, "iSCSI IP Address Added" },
	{ 0x3F, 0x13, "iSCSI IP Address Removed" },
	{ 0x3F, 0x14, "iSCSI IP Address Changed" },
	{ 0x40, 0x00, "RAM FAILURE (Should Use 40 NN)" },
	/*
	 * ASC 0x40 also has an ASCQ range from 0x80 to 0xFF.
	 * 0x40 0xNN DIAGNOSTIC FAILURE ON COMPONENT NN
	 */
	{ 0x41, 0x00, "Data Path FAILURE (Should Use 40 NN)" },
	{ 0x42, 0x00, "Power-On or Self-Test FAILURE (Should Use 40 NN)" },
	{ 0x43, 0x00, "Message Error" },
	{ 0x44, 0x00, "Internal Target Failure" },
	{ 0x44, 0x71, "ATA Device Failed Set Features" },
	{ 0x45, 0x00, "Select Or Reselect Failure" },
	{ 0x46, 0x00, "Unsuccessful Soft Reset" },
	{ 0x47, 0x00, "SCSI Parity Error" },
	{ 0x47, 0x01, "Data Phase CRC Error Detected" },
	{ 0x47, 0x02, "SCSI Parity Error Detected During ST Data Phase" },
	{ 0x47, 0x03, "Information Unit iuCRC Error Detected" },
	{ 0x47, 0x04, "Asynchronous Information Protection Error Detected" },
	{ 0x47, 0x05, "Protocol Service CRC Error" },
	{ 0x47, 0x06, "PHY Test Function In Progress" },
	{ 0x47, 0x7F, "Some Commands Cleared By iSCSI Protocol Event" },
	{ 0x48, 0x00, "Initiator Detected Error Message Received" },
	{ 0x49, 0x00, "Invalid Message Error" },
	{ 0x4A, 0x00, "Command Phase Error" },
	{ 0x4B, 0x00, "Data Phase Error" },
	{ 0x4B, 0x01, "Invalid Target Port Transfer Tag Received" },
	{ 0x4B, 0x02, "Too Much Write Data" },
	{ 0x4B, 0x03, "ACK/NAK Timeout" },
	{ 0x4B, 0x04, "NAK Received" },
	{ 0x4B, 0x05, "Data Offset Error" },
	{ 0x4B, 0x06, "Initiator Response Timeout" },
	{ 0x4B, 0x07, "Connection Lost" },
	{ 0x4C, 0x00, "Logical Unit Failed Self-Configuration" },
	/*
	 * ASC 0x4D has an ASCQ range from 0x00 to 0xFF.
	 * 0x4D 0xNN TAGGED OVERLAPPED COMMANDS (NN = TASK TAG)
	 */
	{ 0x4E, 0x00, "Overlapped Commands Attempted" },
	{ 0x50, 0x00, "Write Append Error" },
	{ 0x50, 0x01, "Write Append Position Error" },
	{ 0x50, 0x02, "Position Error Related To Timing" },
	{ 0x51, 0x00, "Erase Failure" },
	{ 0x51, 0x01, "Erase Failure - Incomplete Erase Operation Detected" },
	{ 0x52, 0x00, "Cartridge Fault" },
	{ 0x53, 0x00, "Media Load or Eject Failed" },
	{ 0x53, 0x01, "Unload Tape Failure" },
	{ 0x53, 0x02, "Medium Removal Prevented" },
	{ 0x53, 0x03, "Medium Removal Prevented By Data Transfer Element" },
	{ 0x53, 0x04, "Medium Thread Or Unthread Failure" },
	{ 0x53, 0x05, "Volume Identifier Invalid" },
	{ 0x53, 0x06, "Volume Identifier Missing" },
	{ 0x53, 0x07, "Duplicate Volume Identifier" },
	{ 0x53, 0x08, "Element Status Unknown" },
	{ 0x54, 0x00, "SCSI To Host System Interface Failure" },
	{ 0x55, 0x00, "System Resource Failure" },
	{ 0x55, 0x01, "System Buffer Full" },
	{ 0x55, 0x02, "Insufficient Reservation Resources" },
	{ 0x55, 0x03, "Insufficient Resources" },
	{ 0x55, 0x04, "Insufficient Registration Resources" },
	{ 0x55, 0x05, "Insufficient Access Control Resources" },
	{ 0x55, 0x06, "Auxiliary Memory Out Of Space" },
	{ 0x55, 0x07, "Quota Error" },
	{ 0x55, 0x08, "Maximum Number Of Supplemental Decryption Keys Exceeded" },
	{ 0x55, 0x09, "Medium Auxiliary Memory Not Accessible" },
	{ 0x55, 0x0A, "Data Currently Unavailable" },
	{ 0x55, 0x0B, "Insufficient Power For Operation" },
	{ 0x57, 0x00, "Unable To Recover Table-Of-Contents" },
	{ 0x58, 0x00, "Generation Does Not Exist" },
	{ 0x59, 0x00, "Updated Block Read" },
	{ 0x5A, 0x00, "Operator Request or State Change Input" },
	{ 0x5A, 0x01, "Operator Medium Removal Requested" },
	{ 0x5A, 0x02, "Operator Selected Write Protect" },
	{ 0x5A, 0x03, "Operator Selected Write Permit" },
	{ 0x5B, 0x00, "Log Exception" },
	{ 0x5B, 0x01, "Threshold Condition Met" },
	{ 0x5B, 0x02, "Log Counter At Maximum" },
	{ 0x5B, 0x03, "Log List Codes Exhausted" },
	{ 0x5C, 0x00, "RPL Status Change" },
	{ 0x5C, 0x01, "Spindles Synchronized" },
	{ 0x5C, 0x02, "Spindles Not Synchronized" },
	{ 0x5D, 0x00, "Failure Prediction Threshold Exceeded" },
	{ 0x5D, 0x01, "Media Failure Prediction Threshold Exceeded" },
	{ 0x5D, 0x02, "Logical Unit Failure Prediction Threshold Exceeded" },
	{ 0x5D, 0x03, "Spare Area Exhaustion Prediction Threshold Exceeded" },
	{ 0x5D, 0x10, "Hardware Impending Failure General Hard Drive Failure" },
	{ 0x5D, 0x11, "Hardware Impending Failure Drive Error Rate Too High" },
	{ 0x5D, 0x12, "Hardware Impending Failure Data Error Rate Too High" },
	{ 0x5D, 0x13, "Hardware Impending Failure Seek Error Rate Too High" },
	{ 0x5D, 0x14, "Hardware Impending Failure Too Many Block Reassigns" },
	{ 0x5D, 0x15, "Hardware Impending Failure Access Times Too High" },
	{ 0x5D, 0x16, "Hardware Impending Failure Start Unit Times Too High" },
	{ 0x5D, 0x17, "Hardware Impending Failure Channel Parametrics" },
	{ 0x5D, 0x18, "Hardware Impending Failure Controller Detected" },
	{ 0x5D, 0x19, "Hardware Impending Failure Throughput Performance" },
	{ 0x5D, 0x1A, "Hardware Impending Failure Seek Time Performance" },
	{ 0x5D, 0x1B, "Hardware Impending Failure Spin-Up Retry Count" },
	{ 0x5D, 0x1C, "Hardware Impending Failure Drive Calibration Retry Count" },
	{ 0x5D, 0x20, "Controller Impending Failure General Hard Drive Failure" },
	{ 0x5D, 0x21, "Controller Impending Failure Drive Error Rate Too High" },
	{ 0x5D, 0x22, "Controller Impending Failure Data Error Rate Too High" },
	{ 0x5D, 0x23, "Controller Impending Failure Seek Error Rate Too High" },
	{ 0x5D, 0x24, "Controller Impending Failure Too Many Block Reassigns" },
	{ 0x5D, 0x25, "Controller Impending Failure Access Times Too High" },
	{ 0x5D, 0x26, "Controller Impending Failure Start Unit Times Too High" },
	{ 0x5D, 0x27, "Controller Impending Failure Channel Parametrics" },
	{ 0x5D, 0x28, "Controller Impending Failure Controller Detected" },
	{ 0x5D, 0x29, "Controller Impending Failure Throughput Performance" },
	{ 0x5D, 0x2A, "Controller Impending Failure Seek Time Performance" },
	{ 0x5D, 0x2B, "Controller Impending Failure Spin-Up Retry Count" },
	{ 0x5D, 0x2C, "Controller Impending Failure Drive Calibration Retry Count" },
	{ 0x5D, 0x30, "Data Channel Impending Failure General Hard Drive Failure" },
	{ 0x5D, 0x31, "Data Channel Impending Failure Drive Error Rate Too High" },
	{ 0x5D, 0x32, "Data Channel Impending Failure Data Error Rate Too High" },
	{ 0x5D, 0x33, "Data Channel Impending Failure Seek Error Rate Too High" },
	{ 0x5D, 0x34, "Data Channel Impending Failure Too Many Block Reassigns" },
	{ 0x5D, 0x35, "Data Channel Impending Failure Access Times Too High" },
	{ 0x5D, 0x36, "Data Channel Impending Failure Start Unit Times Too High" },
	{ 0x5D, 0x37, "Data Channel Impending Failure Channel Parametrics" },
	{ 0x5D, 0x38, "Data Channel Impending Failure Controller Detected" },
	{ 0x5D, 0x39, "Data Channel Impending Failure Throughput Performance" },
	{ 0x5D, 0x3A, "Data Channel Impending Failure Seek Time Performance" },
	{ 0x5D, 0x3B, "Data Channel Impending Failure Spin-Up Retry Count" },
	{ 0x5D, 0x3C, "Data Channel Impending Failure Drive Calibration Retry Count" },
	{ 0x5D, 0x40, "Servo Impending Failure General Hard Drive Failure" },
	{ 0x5D, 0x41, "Servo Impending Failure Drive Error Rate Too High" },
	{ 0x5D, 0x42, "Servo Impending Failure Data Error Rate Too High" },
	{ 0x5D, 0x43, "Servo Impending Failure Seek Error Rate Too High" },
	{ 0x5D, 0x44, "Servo Impending Failure Too Many Block Reassigns" },
	{ 0x5D, 0x45, "Servo Impending Failure Access Times Too High" },
	{ 0x5D, 0x46, "Servo Impending Failure Start Unit Times Too High" },
	{ 0x5D, 0x47, "Servo Impending Failure Channel Parametrics" },
	{ 0x5D, 0x48, "Servo Impending Failure Controller Detected" },
	{ 0x5D, 0x49, "Servo Impending Failure Throughput Performance" },
	{ 0x5D, 0x4A, "Servo Impending Failure Seek Time Performance" },
	{ 0x5D, 0x4B, "Servo Impending Failure Spin-Up Retry Count" },
	{ 0x5D, 0x4C, "Servo Impending Failure Drive Calibration Retry Count" },
	{ 0x5D, 0x50, "Spindle Impending Failure General Hard Drive Failure" },
	{ 0x5D, 0x51, "Spindle Impending Failure Drive Error Rate Too High" },
	{ 0x5D, 0x52, "Spindle Impending Failure Data Error Rate Too High" },
	{ 0x5D, 0x53, "Spindle Impending Failure Seek Error Rate Too High" },
	{ 0x5D, 0x54, "Spindle Impending Failure Too Many Block Reassigns" },
	{ 0x5D, 0x55, "Spindle Impending Failure Access Times Too High" },
	{ 0x5D, 0x56, "Spindle Impending Failure Start Unit Times Too High" },
	{ 0x5D, 0x57, "Spindle Impending Failure Channel Parametrics" },
	{ 0x5D, 0x58, "Spindle Impending Failure Controller Detected" },
	{ 0x5D, 0x59, "Spindle Impending Failure Throughput Performance" },
	{ 0x5D, 0x5A, "Spindle Impending Failure Seek Time Performance" },
	{ 0x5D, 0x5B, "Spindle Impending Failure Spin-Up Retry Count" },
	{ 0x5D, 0x5C, "Spindle Impending Failure Drive Calibration Retry Count" },
	{ 0x5D, 0x60, "Firmware Impending Failure General Hard Drive Failure" },
	{ 0x5D, 0x61, "Firmware Impending Failure Drive Error Rate Too High" },
	{ 0x5D, 0x62, "Firmware Impending Failure Data Error Rate Too High" },
	{ 0x5D, 0x63, "Firmware Impending Failure Seek Error Rate Too High" },
	{ 0x5D, 0x64, "Firmware Impending Failure Too Many Block Reassigns" },
	{ 0x5D, 0x65, "Firmware Impending Failure Access Times Too High" },
	{ 0x5D, 0x66, "Firmware Impending Failure Start Unit Times Too High" },
	{ 0x5D, 0x67, "Firmware Impending Failure Channel Parametrics" },
	{ 0x5D, 0x68, "Firmware Impending Failure Controller Detected" },
	{ 0x5D, 0x69, "Firmware Impending Failure Throughput Performance" },
	{ 0x5D, 0x6A, "Firmware Impending Failure Seek Time Performance" },
	{ 0x5D, 0x6B, "Firmware Impending Failure Spin-Up Retry Count" },
	{ 0x5D, 0x6C, "Firmware Impending Failure Drive Calibration Retry Count" },
	{ 0x5D, 0xFF, "Failure Prediction Threshold Exceeded (false)" },
	{ 0x5E, 0x00, "Low Power Condition On" },
	{ 0x5E, 0x01, "Idle Condition Activated By Timer" },
	{ 0x5E, 0x02, "Standby Condition Activated By Timer" },
	{ 0x5E, 0x03, "Idle Condition Activated By Command" },
	{ 0x5E, 0x04, "Standby Condition Activated By Command" },
	{ 0x5E, 0x05, "IDLE_B Condition Activated By Timer" },
	{ 0x5E, 0x06, "IDLE_B Condition Activated By Command" },
	{ 0x5E, 0x07, "IDLE_C Condition Activated By Timer" },
	{ 0x5E, 0x08, "IDLE_C Condition Activated By Command" },
	{ 0x5E, 0x09, "STANDBY_Y Condition Activated By Timer" },
	{ 0x5E, 0x0A, "STANDBY_Y Condition Activated By Command" },
	{ 0x5E, 0x41, "Power State Change To Active" },
	{ 0x5E, 0x42, "Power State Change To Idle" },
	{ 0x5E, 0x43, "Power State Change To Standby" },
	{ 0x5E, 0x45, "Power State Change To Sleep" },
	{ 0x5E, 0x47, "Power State Change To Device Control" },
	{ 0x60, 0x00, "Lamp Failure" },
	{ 0x61, 0x00, "Video Acquisition Error" },
	{ 0x61, 0x01, "Unable To Acquire Video" },
	{ 0x61, 0x02, "Out Of Focus" },
	{ 0x62, 0x00, "Scan Head Positioning Error" },
	{ 0x63, 0x00, "End Of User Area Encountered On This Track" },
	{ 0x63, 0x01, "Packet Does Not Fit In Available Space" },
	{ 0x64, 0x00, "Illegal Mode For This Track" },
	{ 0x64, 0x01, "Invalid Packet Size" },
	{ 0x65, 0x00, "Voltage Fault" },
	{ 0x66, 0x00, "Automatic Document Feeder Cover Up" },
	{ 0x66, 0x01, "Automatic Document Feeder Lift Up" },
	{ 0x66, 0x02, "Document Jam In Automatic Document Feeder" },
	{ 0x66, 0x03, "Document Miss Feed Automatic In Document Feeder" },
	{ 0x67, 0x00, "Configuration Failure" },
	{ 0x67, 0x01, "Configuration Of Incapable Logical Units Failed" },
	{ 0x67, 0x02, "Add Logical Unit Failed" },
	{ 0x67, 0x03, "Modification Of Logical Unit Failed" },
	{ 0x67, 0x04, "Exchange Of Logical Unit Failed" },
	{ 0x67, 0x05, "Remove Of Logical Unit Failed" },
	{ 0x67, 0x06, "Attachment Of Logical Unit Failed" },
	{ 0x67, 0x07, "Creation Of Logical Unit Failed" },
	{ 0x67, 0x08, "Assign Failure Occurred" },
	{ 0x67, 0x09, "Multiply Assigned Logical Unit" },
	{ 0x67, 0x0A, "Set Target Port Groups Command Failed" },
	{ 0x67, 0x0B, "ATA Device Feature Not Enabled" },
	{ 0x68, 0x00, "Logical Unit Not Configured" },
	{ 0x69, 0x00, "Data Loss On Logical Unit" },
	{ 0x69, 0x01, "Multiple Logical Unit Failures" },
	{ 0x69, 0x02, "Parity/Data Mismatch" },
	{ 0x6A, 0x00, "Informational, Refer To Log" },
	{ 0x6B, 0x00, "State Change Has Occurred" },
	{ 0x6B, 0x01, "Redundancy Level Got Better" },
	{ 0x6B, 0x02, "Redundancy Level Got Worse" },
	{ 0x6C, 0x00, "Rebuild Failure Occurred" },
	{ 0x6D, 0x00, "Recalculate Failure Occurred" },
	{ 0x6E, 0x00, "Command To Logical Unit Failed" },
	{ 0x6F, 0x00, "Copy Protection Key Exchange Failure - Authentication Failure" },
	{ 0x6F, 0x01, "Copy Protection Key Exchange Failure - Key Not Present" },
	{ 0x6F, 0x02, "Copy Protection Key Exchange Failure - Key Not Established" },
	{ 0x6F, 0x03, "Read Of Scrambled Sector Without Authentication" },
	{ 0x6F, 0x04, "Media Region Code Is Mismatched To Logical Unit Region" },
	{ 0x6F, 0x05, "Drive Region Must Be Permanent/Region Reset Count Error" },
	/*
	 * ASC 0x70 has an ASCQ range from 0x00 to 0xFF.
	 * 0x70 0xNN DECOMPRESSION EXCEPTION SHORT ALGORITHM ID Of NN
	 */
	{ 0x71, 0x00, "Decompression Exception Long Algorithm ID" },
	{ 0x72, 0x00, "Session Fixation Error" },
	{ 0x72, 0x01, "Session Fixation Error Writing Lead-In" },
	{ 0x72, 0x02, "Session Fixation Error Writing Lead-Out" },
	{ 0x72, 0x03, "Session Fixation Error - Incomplete Track In Session" },
	{ 0x72, 0x04, "Empty Or Partially Written Reserved Track" },
	{ 0x72, 0x05, "No More Track Reservations Allowed" },
	{ 0x72, 0x06, "RMZ Extension Is Not Allowed" },
	{ 0x72, 0x07, "No More Test Zone Extensions Are Allowed" },
	{ 0x73, 0x00, "CD Control Error" },
	{ 0x73, 0x01, "Power Calibration Area Almost Full" },
	{ 0x73, 0x02, "Power Calibration Area Is Full" },
	{ 0x73, 0x03, "Power Calibration Area Error" },
	{ 0x73, 0x04, "Program Memory Area Update Failure" },
	{ 0x73, 0x05, "Program Memory Area Is Full" },
	{ 0x73, 0x06, "RMA/PMA Is Almost Full" },
	{ 0x73, 0x10, "Current Power Calibration Area Almost Full" },
	{ 0x73, 0x11, "Current Power Calibration Area Is Full" },
	{ 0x73, 0x17, "RDZ Is Full" },
	{ 0x74, 0x00, "Security Error" },
	{ 0x74, 0x01, "Unable To Decrypt Data" },
	{ 0x74, 0x02, "Unencrypted Data Encountered While Decrypting" },
	{ 0x74, 0x03, "Incorrect Data Encryption Key" },
	{ 0x74, 0x04, "Cryptographic Integrity Validation Failed" },
	{ 0x74, 0x05, "Error Decrypting Data" },
	{ 0x74, 0x06, "Unknown Signature Verification Key" },
	{ 0x74, 0x07, "Encryption Parameters Not Useable" },
	{ 0x74, 0x08, "Digital Signature Validation Failure" },
	{ 0x74, 0x09, "Encryption Mode Mismatch On Read" },
	{ 0x74, 0x0A, "Encrypted Block Not Raw Read Enabled" },
	{ 0x74, 0x0B, "Incorrect Encryption Parameters" },
	{ 0x74, 0x0C, "Unable To Decrypt Parameter List" },
	{ 0x74, 0x0D, "Encryption Algorithm Disabled" },
	{ 0x74, 0x10, "SA Creation Parameter Value Invalid" },
	{ 0x74, 0x11, "SA Creation Parameter Value Rejected" },
	{ 0x74, 0x12, "Invalid SA Usage" },
	{ 0x74, 0x21, "Data Encryption Configuration Prevented" },
	{ 0x74, 0x30, "SA Creation Parameter Not Supported" },
	{ 0x74, 0x40, "Authentication Failed" },
	{ 0x74, 0x61, "External Data Encryption Key Manager Access Error" },
	{ 0x74, 0x62, "External Data Encryption Key Manager Error" },
	{ 0x74, 0x63, "External Data Encryption Key Not Found" },
	{ 0x74, 0x64, "External Data Encryption Request Not Authorized" },
	{ 0x74, 0x6E, "External Data Encryption Control Timeout" },
	{ 0x74, 0x6F, "External Data Encryption Control Error" },
	{ 0x74, 0x71, "Logical Unit Access Not Authorized" },
	{ 0x74, 0x79, "Security Conflict In Translated Device" },
	{ 0x00, 0x00, NULL }
};

static __inline void
asc2ascii(u_int8_t asc, u_int8_t ascq, char *result, size_t len)
{
	int					i;

	/* Check for a dynamically built description. */
	switch (asc) {
	case 0x40:
		if (ascq >= 0x80) {
			snprintf(result, len,
		            "Diagnostic Failure on Component 0x%02x", ascq);
			return;
		}
		break;
	case 0x4d:
		snprintf(result, len,
		    "Tagged Overlapped Commands (0x%02x = TASK TAG)", ascq);
		return;
	case 0x70:
		snprintf(result, len,
		    "Decompression Exception Short Algorithm ID OF 0x%02x",
		    ascq);
		return;
	default:
		break;
	}

	/* Check for a fixed description. */
	for (i = 0; adesc[i].description != NULL; i++) {
		if (adesc[i].asc == asc && adesc[i].ascq == ascq) {
			strlcpy(result, adesc[i].description, len);
			return;
		}
	}

	/* Just print out the ASC and ASCQ values as a description. */
	snprintf(result, len, "ASC 0x%02x ASCQ 0x%02x", asc, ascq);
}
#endif /* SCSITERSE */

void
scsi_print_sense(struct scsi_xfer *xs)
{
	struct scsi_sense_data			*sense = &xs->sense;
	u_int8_t				serr = sense->error_code &
						    SSD_ERRCODE;
	int32_t					info;
	char					*sbs;

	sc_print_addr(xs->sc_link);

	/* XXX For error 0x71, current opcode is not the relevant one. */
	printf("%sCheck Condition (error %#x) on opcode 0x%x\n",
	    (serr == SSD_ERRCODE_DEFERRED) ? "DEFERRED " : "", serr,
	    xs->cmd->opcode);

	if (serr != SSD_ERRCODE_CURRENT && serr != SSD_ERRCODE_DEFERRED) {
		if ((sense->error_code & SSD_ERRCODE_VALID) != 0) {
			struct scsi_sense_data_unextended *usense =
			    (struct scsi_sense_data_unextended *)sense;
			printf("   AT BLOCK #: %d (decimal)",
			    _3btol(usense->block));
		}
		return;
	}

	printf("    SENSE KEY: %s\n", scsi_decode_sense(sense,
	    DECODE_SENSE_KEY));

	if (sense->flags & (SSD_FILEMARK | SSD_EOM | SSD_ILI)) {
		char pad = ' ';

		printf("             ");
		if (sense->flags & SSD_FILEMARK) {
			printf("%c Filemark Detected", pad);
			pad = ',';
		}
		if (sense->flags & SSD_EOM) {
			printf("%c EOM Detected", pad);
			pad = ',';
		}
		if (sense->flags & SSD_ILI)
			printf("%c Incorrect Length Indicator Set", pad);
		printf("\n");
	}

	/*
	 * It is inconvenient to use device type to figure out how to
	 * format the info fields. So print them as 32 bit integers.
	 */
	info = _4btol(&sense->info[0]);
	if (info)
		printf("         INFO: 0x%x (VALID flag %s)\n", info,
		    sense->error_code & SSD_ERRCODE_VALID ? "on" : "off");

	if (sense->extra_len < 4)
		return;

	info = _4btol(&sense->cmd_spec_info[0]);
	if (info)
		printf(" COMMAND INFO: 0x%x\n", info);
	sbs = scsi_decode_sense(sense, DECODE_ASC_ASCQ);
	if (strlen(sbs) > 0)
		printf("     ASC/ASCQ: %s\n", sbs);
	if (sense->fru != 0)
		printf("     FRU CODE: 0x%x\n", sense->fru);
	sbs = scsi_decode_sense(sense, DECODE_SKSV);
	if (strlen(sbs) > 0)
		printf("         SKSV: %s\n", sbs);
}

char *
scsi_decode_sense(struct scsi_sense_data *sense, int flag)
{
	static char				rqsbuf[132];
	u_int16_t				count;
	u_int8_t				skey, spec_1;
	int					len;

	bzero(rqsbuf, sizeof(rqsbuf));

	skey = sense->flags & SSD_KEY;
	spec_1 = sense->sense_key_spec_1;
	count = _2btol(&sense->sense_key_spec_2);

	switch (flag) {
	case DECODE_SENSE_KEY:
		strlcpy(rqsbuf, sense_keys[skey], sizeof(rqsbuf));
		break;
	case DECODE_ASC_ASCQ:
		asc2ascii(sense->add_sense_code, sense->add_sense_code_qual,
		    rqsbuf, sizeof(rqsbuf));
		break;
	case DECODE_SKSV:
		if (sense->extra_len < 9 || ((spec_1 & SSD_SCS_VALID) == 0))
			break;
		switch (skey) {
		case SKEY_ILLEGAL_REQUEST:
			len = snprintf(rqsbuf, sizeof rqsbuf,
			    "Error in %s, Offset %d",
			    (spec_1 & SSD_SCS_CDB_ERROR) ? "CDB" : "Parameters",
			    count);
			if ((len != -1 && len < sizeof rqsbuf) &&
			    (spec_1 & SSD_SCS_VALID_BIT_INDEX))
				snprintf(rqsbuf+len, sizeof rqsbuf - len,
				    ", bit %d", spec_1 & SSD_SCS_BIT_INDEX);
			break;
		case SKEY_RECOVERED_ERROR:
		case SKEY_MEDIUM_ERROR:
		case SKEY_HARDWARE_ERROR:
			snprintf(rqsbuf, sizeof rqsbuf,
			    "Actual Retry Count: %d", count);
			break;
		case SKEY_NOT_READY:
			snprintf(rqsbuf, sizeof rqsbuf,
			    "Progress Indicator: %d", count);
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}

	return (rqsbuf);
}

#ifdef SCSIDEBUG
/*
 * Given a scsi_xfer, dump the request, in all its glory
 */
void
scsi_xs_show(struct scsi_xfer *xs)
{
	u_char *b = (u_char *)xs->cmd;
	int i = 0;

	sc_print_addr(xs->sc_link);
	printf("xs  (%p): ", xs);

	printf("flg(0x%x)", xs->flags);
	printf("link(%p)", xs->sc_link);
	printf("retr(0x%x)", xs->retries);
	printf("timo(0x%x)", xs->timeout);
	printf("data(%p)", xs->data);
	printf("res(0x%zx)", xs->resid);
	printf("err(0x%x)", xs->error);
	printf("bp(%p)\n", xs->bp);

	sc_print_addr(xs->sc_link);
	printf("cmd (%p): ", xs->cmd);

	if ((xs->flags & SCSI_RESET) == 0) {
		while (i < xs->cmdlen) {
			if (i)
				printf(",");
			printf("%x", b[i++]);
		}
		printf("-[%d bytes]\n", xs->datalen);
	} else
		printf("-RESET-\n");
}

void
scsi_show_mem(u_char *address, int num)
{
	int x;

	printf("------------------------------");
	for (x = 0; x < num; x++) {
		if ((x % 16) == 0)
			printf("\n%03d: ", x);
		printf("%02x ", *address++);
	}
	printf("\n------------------------------\n");
}
#endif /* SCSIDEBUG */

void
scsi_cmd_rw_decode(struct scsi_generic *cmd, u_int64_t *blkno,
    u_int32_t *nblks)
{
	switch (cmd->opcode) {
	case READ_COMMAND:
	case WRITE_COMMAND: {
		struct scsi_rw *rw = (struct scsi_rw *)cmd;
		*blkno = _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);
		*nblks = rw->length ? rw->length : 0x100;
		break;
	}
	case READ_BIG:
	case WRITE_BIG: {
		struct scsi_rw_big *rwb = (struct scsi_rw_big *)cmd;
		*blkno = _4btol(rwb->addr);
		*nblks = _2btol(rwb->length);
		break;
	}
	case READ_12:
	case WRITE_12: {
		struct scsi_rw_12 *rw12 = (struct scsi_rw_12 *)cmd;
		*blkno = _4btol(rw12->addr);
		*nblks = _4btol(rw12->length);
		break;
	}
	case READ_16:
	case WRITE_16: {
		struct scsi_rw_16 *rw16 = (struct scsi_rw_16 *)cmd;
		*blkno = _8btol(rw16->addr);
		*nblks = _4btol(rw16->length);
		break;
	}
	default:
		panic("scsi_cmd_rw_decode: bad opcode 0x%02x", cmd->opcode);
	}
}
@


1.224
log
@Standardize on calling local scsi_link variables 'link' instead of
'sc_link'. 'sc_link' is a field in the various device *_softc
structures, where the sc_ prefix was for 'softc'. Reduces potential
mental confusion. Newer code from down under was already using
'link'.

No functional change.

Prompted by bluhm@@'s adventures in scsi. ok dlg@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.223 2016/03/10 13:56:14 krw Exp $	*/
d129 4
a132 7
	pool_init(&scsi_xfer_pool, sizeof(struct scsi_xfer), 0,
	    0, 0, "scxspl", NULL);
	pool_setipl(&scsi_xfer_pool, IPL_BIO);
	/* Initialize the scsi_plug pool */
	pool_init(&scsi_plug_pool, sizeof(struct scsi_plug), 0,
	    0, 0, "scsiplug", NULL);
	pool_setipl(&scsi_plug_pool, IPL_BIO);
@


1.223
log
@Enforce some naming sanity. Stop using 'sc_link' to mean two different
things by renaming the field 'SLIST_HEAD(, scsi_link) sc_link' to
'sc_link_list' in struct scsibus_softc.  Use 'sb' as the short name
for scsibus_softc variables.

Impetus from & ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.222 2016/03/07 18:44:00 naddy Exp $	*/
d787 1
a787 1
scsi_test_unit_ready(struct scsi_link *sc_link, int retries, int flags)
d793 1
a793 1
	xs = scsi_xs_get(sc_link, flags);
d866 1
a866 1
scsi_inquire_vpd(struct scsi_link *sc_link, void *buf, u_int buflen,
d872 1
a872 1
	if (sc_link->flags & SDEV_UMASS)
d875 1
a875 1
	xs = scsi_xs_get(sc_link, flags | SCSI_DATA_IN | SCSI_SILENT);
d895 1
a895 1
scsi_prevent(struct scsi_link *sc_link, int type, int flags)
d901 1
a901 1
	if (sc_link->quirks & ADEV_NODOORLOCK)
d904 1
a904 1
	xs = scsi_xs_get(sc_link, flags);
d925 1
a925 1
scsi_start(struct scsi_link *sc_link, int type, int flags)
d931 1
a931 1
	xs = scsi_xs_get(sc_link, flags);
d949 1
a949 1
scsi_mode_sense(struct scsi_link *sc_link, int byte2, int page,
d956 1
a956 1
	xs = scsi_xs_get(sc_link, flags | SCSI_DATA_IN);
d983 1
a983 1
	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_mode_sense: page %#x, error = %d\n",
d990 1
a990 1
scsi_mode_sense_big(struct scsi_link *sc_link, int byte2, int page,
d997 1
a997 1
	xs = scsi_xs_get(sc_link, flags | SCSI_DATA_IN);
d1024 1
a1024 1
	SC_DEBUG(sc_link, SDEV_DB2,
d1059 1
a1059 1
scsi_do_mode_sense(struct scsi_link *sc_link, int page,
d1079 2
a1080 2
	if ((sc_link->flags & SDEV_ATAPI) == 0 ||
	    (sc_link->inqdata.device & SID_TYPE) == T_SEQUENTIAL) {
d1090 1
a1090 1
		error = scsi_mode_sense(sc_link, 0, page, &buf->hdr,
d1116 2
a1117 2
	if ((sc_link->flags & (SDEV_ATAPI | SDEV_UMASS)) == 0 &&
	    SCSISPC(sc_link->inqdata.version) < 2) {
d1125 1
a1125 1
	error = scsi_mode_sense_big(sc_link, 0, page, &buf->hdr_big,
d1143 1
a1143 1
	switch (sc_link->inqdata.device & SID_TYPE) {
d1172 1
a1172 1
scsi_mode_select(struct scsi_link *sc_link, int byte2,
d1182 1
a1182 1
	xs = scsi_xs_get(sc_link, flags | SCSI_DATA_OUT);
d1201 1
a1201 1
	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_mode_select: error = %d\n", error));
d1207 1
a1207 1
scsi_mode_select_big(struct scsi_link *sc_link, int byte2,
d1217 1
a1217 1
	xs = scsi_xs_get(sc_link, flags | SCSI_DATA_OUT);
d1236 1
a1236 1
	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_mode_select_big: error = %d\n",
d1243 1
a1243 1
scsi_report_luns(struct scsi_link *sc_link, int selectreport,
d1251 1
a1251 1
	xs = scsi_xs_get(sc_link, flags | SCSI_DATA_IN);
d1269 1
a1269 1
	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_report_luns: error = %d\n", error));
d1454 1
a1454 1
	struct scsi_link *sc_link = xs->sc_link;
d1456 1
a1456 1
	SC_DEBUG(sc_link, SDEV_DB1,
d1483 1
a1483 1
	struct scsi_link			*sc_link = xs->sc_link;
d1521 1
a1521 1
				SC_DEBUG(sc_link, SDEV_DB1,
d1530 1
a1530 1
				sc_link->flags &= ~SDEV_MEDIA_LOADED;
d1545 1
a1545 1
			sc_link->flags &= ~SDEV_MEDIA_LOADED;
d1583 2
a1584 2
		if ((sc_link->flags & SDEV_REMOVABLE) != 0)
			sc_link->flags &= ~SDEV_MEDIA_LOADED;
d1587 1
a1587 1
		    (sc_link->flags & SDEV_REMOVABLE) == 0) {
d1629 1
a1629 1
sc_print_addr(struct scsi_link *sc_link)
d1631 1
a1631 1
	struct device *adapter_device = sc_link->bus->sc_dev.dv_parent;
d1634 2
a1635 2
	    sc_link->device_softc ?
	    ((struct device *)sc_link->device_softc)->dv_xname : "probe",
d1637 1
a1637 1
	    sc_link->target, sc_link->lun);
d2499 1
a2499 1
	printf("sc_link(%p)", xs->sc_link);
@


1.222
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.221 2015/06/07 19:13:27 krw Exp $	*/
d69 1
a69 1
	struct scsibus_softc	*sc;
d139 1
a139 1
scsi_req_probe(struct scsibus_softc *sc, int target, int lun)
d148 1
a148 1
	p->sc = sc;
d158 1
a158 1
scsi_req_detach(struct scsibus_softc *sc, int target, int lun, int how)
d167 1
a167 1
	p->sc = sc;
d181 1
a181 1
	struct scsibus_softc *sc = p->sc;
d186 1
a186 1
	scsi_probe(sc, target, lun);
d193 1
a193 1
	struct scsibus_softc *sc = p->sc;
d199 1
a199 1
	scsi_detach(sc, target, lun, how);
@


1.221
log
@More damned eye searing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.220 2015/03/14 03:38:52 jsg Exp $	*/
d115 1
a115 1
scsi_init()
@


1.220
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.219 2015/03/08 20:49:38 krw Exp $	*/
d323 1
a323 1
	struct scsi_iopool *iopl = ioh->pool;	
d1100 1
a1100 1
				 * out if their word is not accepted and 
d1516 1
a1516 1
			case SENSE_NOT_READY_RECALC:		
d1522 1
a1522 1
		    		    ("not ready (ASC_ASCQ == %#x)\n",
d2333 1
a2333 1
	 	    "Tagged Overlapped Commands (0x%02x = TASK TAG)", ascq);
@


1.219
log
@Fix some format specifiers in debug code.

Pointed out by Kor son of Rynar (sic) when trying to test
some debug code.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.218 2015/01/27 03:17:37 dlg Exp $	*/
a41 1
#include <sys/buf.h>
@


1.218
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.217 2014/09/20 16:18:23 kettenis Exp $	*/
d2504 1
a2504 1
	printf("res(0x%x)", xs->resid);
@


1.217
log
@Fix bug in taskq conversion that would lead to a null pointer dereference.

ok krw@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.216 2014/09/14 14:17:26 jsg Exp $	*/
d76 2
a77 2
void	scsi_plug_probe(void *, void *);
void	scsi_plug_detach(void *, void *);
d148 1
a148 1
	task_set(&p->task, scsi_plug_probe, p, NULL);
d167 1
a167 1
	task_set(&p->task, scsi_plug_detach, p, NULL);
d179 1
a179 1
scsi_plug_probe(void *xp, void *null)
d191 1
a191 1
scsi_plug_detach(void *xp, void *null)
@


1.216
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.215 2014/09/09 05:43:25 dlg Exp $	*/
d191 1
a191 1
scsi_plug_detach(void *xsc, void *xp)
@


1.215
log
@rework the hotplug requests to use tasks rather than workqs.

tested on mpi(4) sas.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.214 2014/07/01 02:31:16 dlg Exp $	*/
a45 1
#include <sys/proc.h>
@


1.214
log
@take the biglock before calling the xs completion handler.

should be safe to call the midlayer io path without the biglock now.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.213 2014/07/01 02:11:46 dlg Exp $	*/
d48 1
d70 2
a71 1
	struct workq_task	wqt;
d149 2
d154 1
a154 1
	workq_queue_task(NULL, &p->wqt, 0, scsi_plug_probe, sc, p);
d168 2
d174 1
a174 1
	workq_queue_task(NULL, &p->wqt, 0, scsi_plug_detach, sc, p);
d180 1
a180 1
scsi_plug_probe(void *xsc, void *xp)
a181 1
	struct scsibus_softc *sc = xsc;
d183 1
a193 1
	struct scsibus_softc *sc = xsc;
d195 1
@


1.213
log
@take the biglock when calling an adapters scsi_cmd handler.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.212 2014/07/01 01:56:39 dlg Exp $	*/
d1306 1
d1308 1
@


1.212
log
@start on being able to safely run io through the midlayer without
the kernel biglock. the plan is to have the midlayer assume its
running without the biglock, but that it cant call adapters or
devices without taking the biglock first.

this diff just wraps the calls to the adapter iopool get and put
handlers up in the biglock.

this is safe now because of kettenis' commit to src/sys/kern/init_main.c
r1.120. ive been running this in various places since early 2011.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.211 2014/04/22 07:29:11 dlg Exp $	*/
d1287 1
d1289 1
@


1.211
log
@factor out the code that figures out whether you're probing or detaching
a whole bus, a target, or a specific lun on a target from the bioctl
and scsi_req paths.

i want to reuse this factored code for something claudio wants.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.210 2014/01/27 23:44:40 dlg Exp $	*/
d89 3
d241 20
d411 1
a411 1
			io = iopl->io_get(iopl->iocookie);
d417 1
a417 1
				iopl->io_put(iopl->iocookie, io);
d463 1
a463 1
	io = iopl->io_get(iopl->iocookie);
d486 1
a486 1
	iopl->io_put(iopl->iocookie, io);
d643 1
a643 1
	} else if ((io = iopl->io_get(iopl->iocookie)) == NULL) {
@


1.210
log
@poison the io "allocated" by the default pool allocator so any attempt to
use it should cause a fault.

based on discussion with miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.209 2014/01/18 02:42:30 dlg Exp $	*/
d179 1
a179 11
	if (target == -1 && lun == -1)
		scsi_probe_bus(sc);

	/* specific lun and wildcard target is bad */
	if (target == -1)
		return;

	if (lun == -1)
		scsi_probe_target(sc, target);

	scsi_probe_lun(sc, target, lun);
d192 1
a192 11
	if (target == -1 && lun == -1)
		scsi_detach_bus(sc, how);

	/* specific lun and wildcard target is bad */
	if (target == -1)
		return;

	if (lun == -1)
		scsi_detach_target(sc, target, how);

	scsi_detach_lun(sc, target, lun, how);
@


1.209
log
@rename scsi_ioh_runqueue to scsi_iopool_run, and make it available
outside scsi_base.c.

this will allow adapters to restrict access to iopool resources
based on some state, and then kick the pending requests on the pool
when the state comes good again.

ive been avoiding this for a long time, but it is the least worst
way to deal with some uses of XS_NO_CCB.

discussion with kettenis@@ helped me decide this was right.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.208 2013/10/07 17:54:23 miod Exp $	*/
d287 1
a287 1
	return (iocookie);
d294 1
a294 1
	if (iocookie != io)
@


1.208
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.207 2013/09/27 11:43:19 krw Exp $	*/
a81 1
void			scsi_ioh_runqueue(struct scsi_iopool *);
d336 1
a336 1
	scsi_ioh_runqueue(iopl);
d399 1
a399 1
scsi_ioh_runqueue(struct scsi_iopool *iopl)
d484 1
a484 1
	scsi_ioh_runqueue(iopl);
d583 1
a583 1
			scsi_ioh_runqueue(link->pool);
@


1.207
log
@scsi_size() is now used only by cd(4). So move it from scsi_base.c
to cd.c and call it cd_size(), like sd_size() lives in sd.c.

Tweak some daddr_t variables to u_int64_t on the way, when they are
for disk sector numbers, not 512-byte block numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.206 2013/08/29 02:54:36 dlg Exp $	*/
d1284 1
a1284 1
	/* The adapter's scsi_cmd() is responsible for callng scsi_done(). */
@


1.206
log
@rename scsi_sem_{enter,leave} to scsi_pending_{start,finish}. these are
the wrappers around handling of pending work, theyre not semaphores.

names from tedu@@
ok krw@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.205 2013/08/27 00:05:36 dlg Exp $	*/
a774 108
}

/*
 * Find out from the device what its capacity is.
 */
daddr_t
scsi_size(struct scsi_link *sc_link, int flags, u_int32_t *blksize)
{
	struct scsi_read_cap_data_16 *rdcap16;
	struct scsi_read_capacity_16 *cmd;
	struct scsi_read_cap_data *rdcap;
	struct scsi_read_capacity *cmd10;
	struct scsi_xfer *xs;
	daddr_t max_addr;
	int error;

	if (blksize != NULL)
		*blksize = 0;

	CLR(flags, SCSI_IGNORE_ILLEGAL_REQUEST);

	/*
	 * Start with a READ CAPACITY(10).
	 */
	rdcap = dma_alloc(sizeof(*rdcap), ((flags & SCSI_NOSLEEP) ?
	    PR_NOWAIT : PR_WAITOK) | PR_ZERO);
	if (rdcap == NULL)
		return (0);

	xs = scsi_xs_get(sc_link, flags | SCSI_DATA_IN | SCSI_SILENT);
	if (xs == NULL) {
		dma_free(rdcap, sizeof(*rdcap));
		return (0);
	}
	xs->cmdlen = sizeof(*cmd10);
	xs->data = (void *)rdcap;
	xs->datalen = sizeof(*rdcap);
	xs->timeout = 20000;

	cmd10 = (struct scsi_read_capacity *)xs->cmd;
	cmd10->opcode = READ_CAPACITY;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error) {
		SC_DEBUG(sc_link, SDEV_DB1, ("READ CAPACITY error (%#x)\n",
		    error));
		dma_free(rdcap, sizeof(*rdcap));
		return (0);
	}

	max_addr = _4btol(rdcap->addr);
	if (blksize != NULL)
		*blksize = _4btol(rdcap->length);
	dma_free(rdcap, sizeof(*rdcap));

	if (SCSISPC(sc_link->inqdata.version) < 3 && max_addr != 0xffffffff)
		goto exit;

	/*
	 * SCSI-3 devices, or devices reporting more than 2^32-1 sectors can
	 * try READ CAPACITY(16).
	 */
	rdcap16 = dma_alloc(sizeof(*rdcap16), ((flags & SCSI_NOSLEEP) ?
	    PR_NOWAIT : PR_WAITOK) | PR_ZERO);
	if (rdcap16 == NULL)
		goto exit;

	xs = scsi_xs_get(sc_link, flags | SCSI_DATA_IN | SCSI_SILENT);
	if (xs == NULL) {
		dma_free(rdcap16, sizeof(*rdcap16));
		goto exit;
	}
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)rdcap16;
	xs->datalen = sizeof(*rdcap16);
	xs->timeout = 20000;

	cmd = (struct scsi_read_capacity_16 *)xs->cmd;
	cmd->opcode = READ_CAPACITY_16;
	cmd->byte2 = SRC16_SERVICE_ACTION;
	_lto4b(sizeof(*rdcap16), cmd->length);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);
	if (error) {
		SC_DEBUG(sc_link, SDEV_DB1, ("READ CAPACITY 16 error (%#x)\n",
		    error));
		dma_free(rdcap16, sizeof(*rdcap16));
		goto exit;
	}

	max_addr = _8btol(rdcap16->addr);
	if (blksize != NULL)
		*blksize = _4btol(rdcap16->length);
	/* XXX The other READ CAPACITY(16) info could be stored away. */
	dma_free(rdcap16, sizeof(*rdcap16));

	return (max_addr + 1);

exit:
	/* Return READ CAPACITY 10 values. */
	if (max_addr != 0xffffffff)
		return (max_addr + 1);
	else if (blksize != NULL)
		*blksize = 0;
	return (0);
@


1.205
log
@make scsi_sem_leave only run again once, no matter how many times
other things scsi_sem_enter. the things protected by this do as
much work as they can, so they only need to be told to try again
once.

this isnt a semaphore anymore (and probably never was) so there's
a name change coming too.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.204 2013/08/26 01:37:13 dlg Exp $	*/
d217 1
a217 1
scsi_sem_enter(struct mutex *mtx, u_int *running)
d231 1
a231 1
scsi_sem_leave(struct mutex *mtx, u_int *running)
d405 1
a405 1
	if (!scsi_sem_enter(&iopl->mtx, &iopl->running))
d421 1
a421 1
	} while (!scsi_sem_leave(&iopl->mtx, &iopl->running));
d564 1
a564 1
	if (!scsi_sem_enter(&link->pool->mtx, &link->running))
d585 1
a585 1
	} while (!scsi_sem_leave(&link->pool->mtx, &link->running));
@


1.204
log
@make scsi_{xsh,ioh}_{add,del} return whether they moved something
on or off the queues so things calling them can tell if something
is or isnt going to happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.203 2013/08/25 23:31:39 dlg Exp $	*/
d237 2
a238 1
	if ((*running) > 0)
d240 1
@


1.203
log
@move the prototypes of scsi_sem_{enter,leave} into a header so things
other than scsi_base.c can use them.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.202 2013/06/11 16:42:17 deraadt Exp $	*/
d312 1
a312 1
void
d315 2
a316 1
	struct scsi_iopool *iopl = ioh->pool;
d323 1
d336 2
d340 1
a340 1
void
d344 1
d351 1
d360 1
d362 1
a362 1
	mtx_leave(&iopl->mtx);
d500 1
a500 1
void
d504 1
d507 1
a507 1
		return;
d513 1
d519 2
d523 1
a523 1
void
d527 1
d532 1
d548 2
@


1.202
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.201 2012/07/01 19:32:55 miod Exp $	*/
a88 3

int			scsi_sem_enter(struct mutex *, u_int *);
int			scsi_sem_leave(struct mutex *, u_int *);
@


1.201
log
@Do not try to send a 10 byte MODE_SENSE request to non-ATAPI non-UMASS
devices which advertize themselves as non-SCSI2-aware, since this command
appeared in the SCSI-2 specification.
This makes the Insite Floptical work when connected to a controller which
correctly handles spontaneous deselection (which happens when a non-zero
lun on said floptical device is addressed), such an esp(4) but not wdsc(4).
This is step one of getting Floptical devices working on SGI systems.

feedback and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.200 2011/06/15 01:10:05 dlg Exp $	*/
d766 1
a766 1
daddr64_t
d774 1
a774 1
	daddr64_t max_addr;
@


1.200
log
@factor the common bits out of code that builds scsi inquiry commands into
scsi_init_inquiry(). cut the compiled INQUIRY code over to it.

ok and tweaks from krw@@
ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.199 2011/03/17 21:30:24 deraadt Exp $	*/
d1204 9
@


1.199
log
@use dma_alloc/dma_free instead of malloc to allocate buffers which need
to be in the right address space.
help from matthew and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.198 2011/03/02 04:38:01 krw Exp $	*/
d897 19
a923 1
	struct scsi_inquiry *cmd;
a924 1
	size_t length;
d935 1
a935 11
	length = SID_INQUIRY_HDR + SID_SCSI2_ALEN;

	cmd = (struct scsi_inquiry *)xs->cmd;
	cmd->opcode = INQUIRY;
	_lto2b(length, cmd->length);

	xs->cmdlen = sizeof(*cmd);

	xs->flags |= SCSI_DATA_IN;
	xs->data = (void *)inqbuf;
	xs->datalen = length;
a956 1
	struct scsi_inquiry *cmd;
d966 1
a966 3
	xs->cmdlen = sizeof(*cmd);
	xs->data = buf;
	xs->datalen = buflen;
d970 1
a970 5
	cmd = (struct scsi_inquiry *)xs->cmd;
	cmd->opcode = INQUIRY;
	cmd->flags = SI_EVPD;
	cmd->pagecode = page;
	_lto2b(buflen, cmd->length);
d973 1
@


1.198
log
@Sync ASC/ASCQ errors with www.t10.org/lists/asc-num.txt of 11/15/10.
Prompted by dlg@@'s tape library trying to report a failure to thread
a media (0x53, 0x04).
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.197 2010/09/20 00:19:47 dlg Exp $	*/
a43 1
#include <sys/malloc.h>
d785 2
a786 2
	rdcap = malloc(sizeof(*rdcap), M_TEMP, ((flags & SCSI_NOSLEEP) ?
	    M_NOWAIT : M_WAITOK) | M_ZERO);
d792 1
a792 1
		free(rdcap, M_TEMP);
d809 1
a809 1
		free(rdcap, M_TEMP);
d816 1
a816 1
	free(rdcap, M_TEMP);
d825 2
a826 2
	rdcap16 = malloc(sizeof(*rdcap16), M_TEMP, ((flags & SCSI_NOSLEEP) ?
	    M_NOWAIT : M_WAITOK) | M_ZERO);
d832 1
a832 1
		free(rdcap16, M_TEMP);
d850 1
a850 1
		free(rdcap16, M_TEMP);
d858 1
a858 1
	free(rdcap16, M_TEMP);
a952 2

	bzero(buf, buflen);
@


1.197
log
@bring back scsi_base.c r1.195 and scsiconf.h r1.138 now that
src/sys/dev/ata/atascsi.c r1.92 solves the problem that my scsi_link
change tickled.

tested by josh elsasser who reported the problem in pr6470
deraadt@@ is letting it in again so it can get widespread testing
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.196 2010/09/17 23:19:02 dlg Exp $	*/
d1747 1
d1785 1
d1788 9
d1814 6
d1834 1
d1845 5
d1870 1
d1918 1
d1933 1
d1937 1
d1947 1
d1964 4
d1975 1
d1978 2
d1996 11
d2019 2
d2024 2
d2038 3
d2043 1
d2087 5
d2116 3
d2128 1
d2137 1
d2149 1
d2165 6
d2179 5
d2286 6
d2322 1
d2351 2
d2360 31
@


1.196
log
@revert scsi_base.c r1.195 and scsiconf.h r1.138 as it screws up with some
disks in atascsi.

as reported in pr6470
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.194 2010/09/08 11:04:39 dlg Exp $	*/
d530 3
a532 1
		link->openings++;
d557 2
a558 1
		while (!ISSET(link->state, SDEV_S_DYING) && link->openings &&
d560 1
a560 1
			link->openings--;
d687 1
a687 1
			link->openings++;
d692 3
d709 2
a710 2
	if (link->openings) {
		link->openings--;
d722 3
a724 1
	link->openings++;
@


1.195
log
@the openings member of scsi_link is the maximum number of commands that a
scsi device can have in flight. instead of counting users of openings on
the bus by taking away from the openings value, count the number of
pending commands on the bus in a new pending variable.

this lets us know how many outstanding commands there are. we can then use
that to make sure that all commands a device has generated get completed
before detaching the device. this helps avoid resource leaks and use after
frees.

tested by me on pci ehci/umass, fc mpi, and sas mpi.
tested by jakemsr on cardbus ohci umass.
it found issues in sas mpi which were fixed as a result of this diff.
ok krw@@
@
text
@d530 1
a530 3
		link->pending--;
		if (ISSET(link->state, SDEV_S_DYING) && link->pending == 0)
			wakeup_one(&link->pending);
d555 1
a555 2
		while (!ISSET(link->state, SDEV_S_DYING) &&
		    link->pending < link->openings &&
d557 1
a557 1
			link->pending++;
d684 1
a684 1
			link->pending--;
a688 3

	while (link->pending > 0)
		msleep(&link->pending, &iopl->mtx, PRIBIO, "pendxs", 0);
d703 2
a704 2
	if (link->pending < link->openings) {
		link->pending++;
d716 1
a716 3
	link->pending--;
	if (ISSET(link->state, SDEV_S_DYING) && link->pending == 0)
		wakeup_one(&link->pending);
@


1.194
log
@let things request the detach of everything on the whole bus, rather than
just a target/lun.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.193 2010/08/30 02:47:56 matthew Exp $	*/
d530 3
a532 1
		link->openings++;
d557 2
a558 1
		while (!ISSET(link->state, SDEV_S_DYING) && link->openings &&
d560 1
a560 1
			link->openings--;
d687 1
a687 1
			link->openings++;
d692 3
d709 2
a710 2
	if (link->openings) {
		link->openings--;
d722 3
a724 1
	link->openings++;
@


1.193
log
@Avoid possible aliasing-related compiler issues by always writing to
cmd->opcode through the type casted command pointer rather than
through xs->cmd->opcode.

Requested by deraadt@@; ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.192 2010/08/25 00:31:35 dlg Exp $	*/
d180 1
d182 11
a192 4
	if (p->lun == -1)
		scsi_probe_target(sc, p->target);
	else
		scsi_probe_lun(sc, p->target, p->lun);
d194 1
a194 1
	pool_put(&scsi_plug_pool, p);
d202 2
d205 11
a215 4
	if (p->lun == -1)
		scsi_detach_target(sc, p->target, p->how);
	else
		scsi_detach_lun(sc, p->target, p->lun, p->how);
d217 1
a217 1
	pool_put(&scsi_plug_pool, p);
@


1.192
log
@add scsi_iopool_destroy and scsi_link_shutdown. when a link or
device are going away, this will walk the pool and link queues and
wake up processes that are sleeping while waiting for an io or xs.
they will return NULL to the scsi_{xs,io}_get callers, which should
then check if they device is still alive. all other handlers that
are registered on the queues should be removed by their owners
before the destroy/shutdown funcs are called.

lots of help and discussion with matthew@@
ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.191 2010/08/07 03:50:02 krw Exp $	*/
a770 1
	xs->cmd->opcode = READ_CAPACITY;
d776 3
a810 1
	xs->cmd->opcode = READ_CAPACITY_16;
d817 1
a859 1
	xs->cmd->opcode = TEST_UNIT_READY;
d864 3
a937 1
	xs->cmd->opcode = INQUIRY;
d945 1
a971 1
	xs->cmd->opcode = PREVENT_ALLOW;
d977 1
a998 1
	xs->cmd->opcode = START_STOP;
d1004 1
a1023 1
	xs->cmd->opcode = MODE_SENSE;
d1037 1
a1064 1
	xs->cmd->opcode = MODE_SENSE_BIG;
d1078 1
a1240 1
	xs->cmd->opcode = MODE_SELECT;
d1247 1
a1275 1
	xs->cmd->opcode = MODE_SELECT_BIG;
d1282 1
a1309 1
	xs->cmd->opcode = REPORT_LUNS;
d1318 1
@


1.191
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.190 2010/07/28 01:53:12 krw Exp $	*/
d95 3
a97 3
#define RUNQ_IDLE       0
#define RUNQ_LINKQ      1
#define RUNQ_POOLQ      2
d103 1
d105 4
d111 1
d244 26
d403 25
d434 1
a434 1
	struct scsi_io_mover m = { MUTEX_INITIALIZER(IPL_BIO), NULL };
d448 1
a448 5

	mtx_enter(&m.mtx);
	while (m.io == NULL)
		msleep(&m, &m.mtx, PRIBIO, "scsiio", 0);
	mtx_leave(&m.mtx);
d456 1
a456 6
	struct scsi_io_mover *m = cookie;

	mtx_enter(&m->mtx);
	m->io = io;
	wakeup_one(m);
	mtx_leave(&m->mtx);
d485 3
d538 1
a538 1
		while (link->openings &&
d586 3
a588 1
	struct scsi_io_mover m = { MUTEX_INITIALIZER(IPL_BIO), NULL };
d591 8
a598 7
	if (scsi_link_open(link)) {
		io = scsi_io_get(link->pool, flags);
		if (io == NULL) {
			scsi_link_close(link);
			return (NULL);
		}
	} else {
a601 3
		/* really custom xs handler to avoid scsi_xsh_ioh */
		scsi_ioh_set(&xsh.ioh, link->pool, scsi_io_get_done, &m);
		xsh.link = link;
d603 10
d614 4
a617 4
		mtx_enter(&m.mtx);
		while (m.io == NULL)
			msleep(&m, &m.mtx, PRIBIO, "scsixs", 0);
		mtx_leave(&m.mtx);
d623 55
@


1.190
log
@No need to bzero() malloc'd memory if we used M_ZERO.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.189 2010/07/27 04:41:56 matthew Exp $	*/
d1255 1
a1255 1
		panic("xs->cookie != NULL in scsi_xs_sync\n");
d1257 1
a1257 1
		panic("xs->done != NULL in scsi_xs_sync\n");
@


1.189
log
@Add scsi_cmd_rw_decode() for decoding any SCSI READ or WRITE command,
and update atascsi(4) to make use of it.  (Other HBAs will be updated
post-release.)  Should allow for use of SATA drives with >2^32 LBAs.

ok deraadt@@, dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.188 2010/07/27 04:17:10 dlg Exp $	*/
a660 2
	bzero(rdcap, sizeof(*rdcap));

a697 2

	bzero(rdcap16, sizeof(*rdcap16));
@


1.188
log
@the queue entry and state variables in the xsh and ioh structs are part
of a separate struct which the ioh struct includes for no good reason
anymore. just put the vars directly in the ioh.

this removes this useless abstraction.

ok krw@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.187 2010/07/25 15:39:32 krw Exp $	*/
d2356 37
@


1.187
log
@Restore previous behaviour of always bzero()'ing the buf passed to
scsi_inquire_vpd(). scsi_inquire_vpd() oddness noted by jsg@@ after
report of macppc problems by kili@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.186 2010/07/24 04:01:52 matthew Exp $	*/
d94 5
d261 1
a261 1
	ioh->entry.state = RUNQ_IDLE;
d273 1
a273 1
	switch (ioh->entry.state) {
d275 2
a276 2
		TAILQ_INSERT_TAIL(&iopl->queue, &ioh->entry, e);
		ioh->entry.state = RUNQ_POOLQ;
d282 1
a282 1
		panic("scsi_ioh_add: unexpected state %u", ioh->entry.state);
d297 1
a297 1
	switch (ioh->entry.state) {
d299 2
a300 2
		TAILQ_REMOVE(&iopl->queue, &ioh->entry, e);
		ioh->entry.state = RUNQ_IDLE;
d306 1
a306 1
		panic("scsi_ioh_del: unexpected state %u", ioh->entry.state);
d323 1
a323 1
	ioh = (struct scsi_iohandler *)TAILQ_FIRST(&iopl->queue);
d325 2
a326 2
		TAILQ_REMOVE(&iopl->queue, &ioh->entry, e);
		ioh->entry.state = RUNQ_IDLE;
d438 3
a440 3
	if (xsh->ioh.entry.state == RUNQ_IDLE) {
		TAILQ_INSERT_TAIL(&link->queue, &xsh->ioh.entry, e);
		xsh->ioh.entry.state = RUNQ_LINKQ;
d454 1
a454 1
	switch (xsh->ioh.entry.state) {
d458 1
a458 1
		TAILQ_REMOVE(&link->queue, &xsh->ioh.entry, e);
d461 1
a461 1
		TAILQ_REMOVE(&link->pool->queue, &xsh->ioh.entry, e);
d465 1
a465 1
		panic("unexpected xsh state %u", xsh->ioh.entry.state);
d467 1
a467 1
	xsh->ioh.entry.state = RUNQ_IDLE;
d478 1
a478 1
	struct scsi_runq_entry *entry;
d488 1
a488 1
		    ((entry = TAILQ_FIRST(&link->queue)) != NULL)) {
d491 3
a493 3
			TAILQ_REMOVE(&link->queue, entry, e);
			TAILQ_INSERT_TAIL(&link->pool->queue, entry, e);
			entry->state = RUNQ_POOLQ;
@


1.186
log
@Get rid of scsi_deinit(), and change scsi_init() back to a one-time
initialization strategy, rather than pretending to do user reference
counting.  Previously, we would re-initialize the SCSI pool(9)s, which
had the fun consequence of causing sysctl(kern.pool.npools) to
infinite loop at IPL_VM.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.185 2010/07/22 05:21:58 matthew Exp $	*/
d809 2
a827 2

	bzero(buf, buflen);
@


1.185
log
@In scsi_inquire_vpd(), actually just return EJUSTRETURN when dealing
with UMASS devices.  Fixes scsi_scsi_cmd() removal regression.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.184 2010/07/22 00:31:06 krw Exp $	*/
a65 1
int			scsi_running = 0;
d108 3
a110 1
	if (scsi_running++)
d112 1
a189 7
}

void
scsi_deinit()
{
	if (--scsi_running)
		return;
@


1.184
log
@Eliminate scsi_scsi_cmd() now that ss(4) is gone and with it the
last bastardized sync and buf call through scsi_scsi_cmd(). Flatten
code to call scsi_xs_sync() directly for all commands.

Airplane typos shaken out by various.

ok dlg@@ matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.183 2010/07/06 01:07:28 krw Exp $	*/
d815 1
a815 1
		error = EJUSTRETURN;
@


1.183
log
@Fix monumental cock-up with SCSI_SILENT and SCSI_IGNORE_ILLEGAL_REQUEST
flags which I perpetrated when I paid insufficient attention to
dlg@@'s original diff.

Belatedly tested by marco@@ and myself. Bad marco@@. Bad krw@@.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.182 2010/07/03 01:55:28 krw Exp $	*/
a628 2
	struct scsi_read_capacity_16 rc16;
	struct scsi_read_capacity rc;
d630 1
d632 2
a644 4
	bzero(&rc, sizeof(rc));
	bzero(&rdcap, sizeof(rdcap));
	rc.opcode = READ_CAPACITY;

d649 17
a665 3
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&rc, sizeof(rc),
	    (u_char *)rdcap, sizeof(*rdcap), SCSI_RETRIES, 20000, NULL,
	    flags | SCSI_DATA_IN | SCSI_SILENT);
d682 2
a683 2
	 * SCSI-3 devices, or devices reporting more than 2^32-1 sectors can try
	 * READ CAPACITY(16).
a684 6
	 bzero(&rc16, sizeof(rc16));
	 bzero(&rdcap16, sizeof(rdcap16));
	 rc16.opcode = READ_CAPACITY_16;
	 rc16.byte2 = SRC16_SERVICE_ACTION;
	 _lto4b(sizeof(*rdcap16), rc16.length);

d689 20
a708 3
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&rc16,
	    sizeof(rc16), (u_char *)rdcap16, sizeof(*rdcap16), SCSI_RETRIES,
	    20000, NULL, flags | SCSI_DATA_IN | SCSI_SILENT);
d739 11
a749 1
	struct scsi_test_unit_ready		scsi_cmd;
d751 2
a752 2
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = TEST_UNIT_READY;
d754 1
a754 2
	return (scsi_scsi_cmd(sc_link, (struct scsi_generic *) &scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, retries, 10000, NULL, flags));
d765 1
a766 1
	struct scsi_inquiry *cdb;
d780 3
a782 3
	cdb = (struct scsi_inquiry *)xs->cmd;
	cdb->opcode = INQUIRY;
	_lto2b(length, cdb->length);
d784 1
a784 1
	xs->cmdlen = sizeof(*cdb);
d810 2
a811 1
	struct scsi_inquiry scsi_cmd;
d814 17
a830 5
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = INQUIRY;
	scsi_cmd.flags = SI_EVPD;
	scsi_cmd.pagecode = page;
	_lto2b(buflen, scsi_cmd.length);
d834 4
a837 10
	if (sc_link->flags & SDEV_UMASS) {
		/* do nothing, just return */
		error = EJUSTRETURN;
	} else
		error = scsi_scsi_cmd(sc_link,
			(struct scsi_generic *)&scsi_cmd,
	    		sizeof(scsi_cmd), buf, buflen, 2, 10000, NULL,
 	    		SCSI_DATA_IN | SCSI_SILENT | flags);
 
 	return (error);
d846 3
a848 1
	struct scsi_prevent			scsi_cmd;
d853 13
a865 3
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = PREVENT_ALLOW;
	scsi_cmd.how = type;
d867 1
a867 2
	return (scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, 2, 5000, NULL, flags));
d876 17
a892 1
	struct scsi_start_stop			scsi_cmd;
d894 1
a894 8
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = START_STOP;
	scsi_cmd.byte2 = 0x00;
	scsi_cmd.how = type;

	return (scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, 2,
	    type == SSS_START ? 30000 : 10000, NULL, flags));
d901 12
a912 2
	struct scsi_mode_sense			scsi_cmd;
	int					error;
d921 3
a923 4
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MODE_SENSE;
	scsi_cmd.byte2 = byte2;
	scsi_cmd.page = page;
d927 1
a927 1
	scsi_cmd.length = len;
d929 2
a930 3
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)data, len, SCSI_RETRIES, timeout, NULL,
	    flags | SCSI_DATA_IN);
d942 12
a953 2
	struct scsi_mode_sense_big		scsi_cmd;
	int					error;
d962 3
a964 4
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MODE_SENSE_BIG;
	scsi_cmd.byte2 = byte2;
	scsi_cmd.page = page;
d968 1
a968 1
	_lto2b(len, scsi_cmd.length);
d970 2
a971 3
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)data, len, SCSI_RETRIES, timeout, NULL,
	    flags | SCSI_DATA_IN);
d1115 15
a1129 2
	struct scsi_mode_select			scsi_cmd;
	int					error;
d1131 3
a1133 4
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MODE_SELECT;
	scsi_cmd.byte2 = byte2;
	scsi_cmd.length = data->data_length + 1; /* 1 == sizeof(data_length) */
d1138 2
a1139 3
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)data, scsi_cmd.length, SCSI_RETRIES,
	    timeout, NULL, flags | SCSI_DATA_OUT);
d1150 19
a1168 10
	struct scsi_mode_select_big		scsi_cmd;
	u_int32_t				len;
	int					error;

	len = _2btol(data->data_length) + 2; /* 2 == sizeof data->data_length */

	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MODE_SELECT_BIG;
	scsi_cmd.byte2 = byte2;
	_lto2b(len, scsi_cmd.length);
d1173 2
a1174 3
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)data, len, SCSI_RETRIES, timeout, NULL,
	    flags | SCSI_DATA_OUT);
d1187 2
a1188 1
	struct scsi_report_luns scsi_cmd;
d1191 9
a1199 1
	bzero(&scsi_cmd, sizeof(scsi_cmd));
d1202 6
a1207 7
	scsi_cmd.opcode = REPORT_LUNS;
	scsi_cmd.selectreport = selectreport;
	_lto4b(datalen, scsi_cmd.length);

	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)data, datalen, SCSI_RETRIES, timeout,
	    NULL, flags | SCSI_DATA_IN);
a1301 53
}

/*
 * ask the scsi driver to perform a command for us.
 * tell it where to read/write the data, and how
 * long the data is supposed to be. If we have  a buf
 * to associate with the transfer, we need that too.
 */
int
scsi_scsi_cmd(struct scsi_link *link, struct scsi_generic *scsi_cmd,
    int cmdlen, u_char *data_addr, int datalen, int retries, int timeout,
    struct buf *bp, int flags)
{
	struct scsi_xfer *xs;
	int error;
	int s;

#ifdef DIAGNOSTIC
	if (bp != NULL && (flags & SCSI_NOSLEEP) == 0)
		panic("scsi_scsi_cmd: buffer without nosleep");
#endif

	xs = scsi_xs_get(link, flags);
	if (xs == NULL)
		return (ENOMEM);

	memcpy(xs->cmd, scsi_cmd, cmdlen);
	xs->cmdlen = cmdlen;
	xs->data = data_addr;
	xs->datalen = datalen;
	xs->retries = retries;
	xs->timeout = timeout;
	xs->bp = bp;

	error = scsi_xs_sync(xs);

	if (bp != NULL) {
		bp->b_error = error;
		if (bp->b_error) {
			SET(bp->b_flags, B_ERROR);
			bp->b_resid = bp->b_bcount;
		} else {
			CLR(bp->b_flags, B_ERROR);
			bp->b_resid = xs->resid;
		}
		s = splbio();
		biodone(bp);
		splx(s);
	}

	scsi_xs_put(xs);

	return (error);
@


1.182
log
@Get rid of EAGAIN, retry scsi_xs_sync() commands (after a scsi_delay())
that get XS_NO_CCB until retry limit exceeded. On to getting rid
of XS_NO_CCB.

ok matthew@@ "so be it" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.181 2010/07/02 23:57:46 krw Exp $	*/
d639 2
d654 1
a654 1
	    flags | SCSI_DATA_IN);
d686 1
a686 1
	    20000, NULL, flags | SCSI_DATA_IN);
d697 1
a697 1
	/* XXX The other READ CAPACITY(16) info could be stored away somewhere. */
@


1.181
log
@Always try READ CAPACITY(16) on SCSI-3 devices. If it fails, return
the READ CAPACITY(10) values already retrieved. Creates the possibility
to look at other interesting READ CAPACITY(16) data for future
consideration.

ok matthew@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.180 2010/07/02 00:04:11 krw Exp $	*/
d1235 8
a1242 14
	if (error != EAGAIN) {
		if (bp != NULL) {
			if (error) {
				bp->b_error = error;
				bp->b_flags |= B_ERROR;
				bp->b_resid = bp->b_bcount;
			} else {  
				bp->b_error = 0;
				bp->b_resid = xs->resid;
			}
	
			s = splbio();
			biodone(bp);
			splx(s);
d1244 3
a1269 4
	case XS_NO_CCB:
		error = EAGAIN;
		break;

d1280 1
@


1.180
log
@Use M_NOWAIT only if SCSI_NOSLEEP is set, as is the usual idiom. From
matthew@@ who won't be home until late.

ok matthew@@ & tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.179 2010/07/01 22:20:01 krw Exp $	*/
d640 1
a640 1
	 * make up a scsi command and ask the scsi driver to do it for you.
d646 2
a647 6
	/*
	 * If the command works, interpret the result as a 4 byte
	 * number of blocks
	 */
	rdcap = malloc(sizeof(*rdcap), M_TEMP, ((flags & SCSI_NOSLEEP) ? M_NOWAIT :
	    M_WAITOK) | M_ZERO);
d665 2
a666 2
	if (max_addr != 0xffffffff)
		return (max_addr + 1);
d669 2
a670 1
	 * The device has more than 2^32-1 sectors. Use 16-byte READ CAPACITY.
d681 1
a681 1
		return (0);
d689 1
a689 1
		return (0);
d695 1
d699 8
@


1.179
log
@Move rdcap/rdcap16 structs used to get info about disk size off of
stack and malloc/free them instead. First stirrings of the tide of
de-stacking to come.

Feedback, fixes and ok matthew@@ & tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.178 2010/07/01 05:11:18 krw Exp $	*/
d631 2
a632 2
	struct scsi_read_cap_data_16 *rdcap16 = NULL;
	struct scsi_read_cap_data *rdcap = NULL;
d650 2
a651 1
	rdcap = malloc(sizeof(*rdcap), M_TEMP, M_NOWAIT|M_ZERO);
d681 2
a682 1
	rdcap16 = malloc(sizeof(*rdcap16), M_TEMP, M_NOWAIT|M_ZERO);
@


1.178
log
@Die struct scsi_device! Die! Instead, save a pointer to the routine
to interpret sense errors. This is initialized to the basic
interpretation routine, and specific scsi drivers (sd/st/cd) can
replace this with their own. While here kill EJUSTRETURN dance and
make more specialized interpretation routines directly call the
basic routine if desired.

Fixes by matthew@@ to my first diff. Most original work by dlg@@.

ok matthew@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.177 2010/07/01 03:01:37 matthew Exp $	*/
d44 1
a628 1
	struct scsi_read_cap_data_16 rdcap16;
a629 1
	struct scsi_read_cap_data rdcap;
d631 2
d650 3
d654 1
a654 1
	    (u_char *)&rdcap, sizeof(rdcap), SCSI_RETRIES, 20000, NULL,
d659 1
d663 1
a663 1
	max_addr = _4btol(rdcap.addr);
d665 2
a666 1
		*blksize = _4btol(rdcap.length);
d678 1
a678 1
	 _lto4b(sizeof(rdcap16), rc16.length);
d680 3
d684 1
a684 1
	    sizeof(rc16), (u_char *)&rdcap16, sizeof(rdcap16), SCSI_RETRIES,
d689 1
d693 1
a693 1
	max_addr = _8btol(rdcap16.addr);
d695 2
a696 1
		*blksize = _4btol(rdcap16.length);
@


1.177
log
@Restore setting xs->bp; fixes ncr(4) on VAX.

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.176 2010/06/28 09:11:21 dlg Exp $	*/
a619 3

	if (link->device->start)
		link->device->start(link->device_softc);
a1230 10

		if (link->device->done) {
			/*
			 * Tell the device the operation is actually complete.
			 * No more will happen with this xfer.  This for
			 * notification of the upper-level driver only; they
			 * won't be returning any meaningful information to us.
			 */
			link->device->done(xs);
		}
d1260 4
a1263 1
		error = scsi_interpret_sense(xs);
d1319 1
d1321 1
a1321 4
 * Look at the returned sense and act on the error, determining
 * the unix error number to pass back.  (0 = report no error)
 *
 * THIS IS THE DEFAULT ERROR HANDLER
d1323 2
a1324 2
int
scsi_interpret_sense(struct scsi_xfer *xs)
d1326 2
a1327 4
	struct scsi_sense_data			*sense = &xs->sense;
	struct scsi_link			*sc_link = xs->sc_link;
	u_int8_t				serr, skey;
	int					error;
a1338 1
#ifdef SCSIDEBUG
d1341 1
d1343 2
a1344 1
#endif /* SCSIDEBUG */
d1346 13
a1358 12
	/*
	 * If the device has its own error handler, call it first.
	 * If it returns a legit error value, return that, otherwise
	 * it wants us to continue with normal error processing.
	 */
	if (sc_link->device->err_handler) {
		SC_DEBUG(sc_link, SDEV_DB2,
		    ("calling private err_handler()\n"));
		error = (*sc_link->device->err_handler) (xs);
		if (error != EJUSTRETURN)
			return (error); /* error >= 0  better ? */
	}
@


1.176
log
@remove a lonely remnant from some debug code that snuck in.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.175 2010/06/14 10:03:33 thib Exp $	*/
d1215 1
@


1.175
log
@remove the scsi_buf_* functions as these have been
replaced by BUFQ's.

OK krw@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.174 2010/06/01 10:11:05 dlg Exp $	*/
a314 2

u_int line;
@


1.174
log
@if we're going to set ITSDONE when an xfer is done cos the adapter expects
it, we should clear it before we issue it to the adapter too. retried
commands would have ITSDONE still set otherwise.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.173 2010/05/24 21:51:49 krw Exp $	*/
a2252 68
}

void
scsi_buf_enqueue(struct buf *head, struct buf *bp, struct mutex *mtx)
{
	struct buf *dp;

	mtx_enter(mtx);
	dp = head;
	bp->b_actf = NULL;
	bp->b_actb = dp->b_actb;
	*dp->b_actb = bp;
	dp->b_actb = &bp->b_actf;
	mtx_leave(mtx);
}

struct buf *
scsi_buf_dequeue(struct buf *head, struct mutex *mtx)
{
	struct buf *bp;

	mtx_enter(mtx);
	bp = head->b_actf;
	if (bp != NULL)
		head->b_actf = bp->b_actf;
	if (head->b_actf == NULL)
		head->b_actb = &head->b_actf;
	mtx_leave(mtx);

	return (bp);
}

void
scsi_buf_requeue(struct buf *head, struct buf *bp, struct mutex *mtx)
{
	mtx_enter(mtx);
	bp->b_actf = head->b_actf;
	head->b_actf = bp;
	if (bp->b_actf == NULL)
		head->b_actb = &bp->b_actf;
	mtx_leave(mtx);
}

int
scsi_buf_canqueue(struct buf *head, struct mutex *mtx)
{
	int rv;

	mtx_enter(mtx);
	rv = (head->b_actf != NULL);
	mtx_leave(mtx);

	return (rv);
}

void
scsi_buf_killqueue(struct buf *head, struct mutex *mtx)
{
	struct buf *bp;
	int s;

	while ((bp = scsi_buf_dequeue(head, mtx)) != NULL) {
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		s = splbio();
		biodone(bp);
		splx(s);
	}
@


1.173
log
@"scsi_ioh_add:" -> "scsi_ioh_del:" in scsi_ioh_del() panic msg.

Spotted by Matthew Dempsky. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.172 2010/04/17 04:14:52 deraadt Exp $	*/
d1103 1
@


1.172
log
@ramdisks need to compile; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.171 2010/04/17 00:51:13 dlg Exp $	*/
d305 1
a305 1
		panic("scsi_ioh_add: unexpected state %u", ioh->entry.state);
@


1.171
log
@use the iopools mutex to protect the semaphore wrapping the openings
runqueue. less is more sometimes.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.170 2010/04/16 09:51:30 dlg Exp $	*/
d282 1
a283 1
#endif
d306 1
d308 1
a308 1
#endif
@


1.170
log
@fix an fatal flaw with iopools.

an xshandler gets put on a series of lists as it allocates different
resources, and uses the same tailq entry on each of these lists as
its only supposed to be on one of them at a time. however, it was
possible for the xshandler to be added to both at the same time,
therefore corrupting the lists and leading to a panic.

this diff moves from using separate flags for each queue an xshandler
could be on to having a single state variable that shows which one
it is on (or not on). this prevents an xshandler on the io runqueue
from being added to the openings runqueue, which in turn prevents
the list corruption.

some operations have been reordered to avoid races and complexity
in this little state machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.169 2010/04/12 09:51:48 dlg Exp $	*/
d481 1
a481 1
	if (!scsi_sem_enter(&link->mtx, &link->running))
d501 1
a501 1
	} while (!scsi_sem_leave(&link->mtx, &link->running));
@


1.169
log
@i snuck fine grained locking into the midlayer as part of all the
other stuff ive been doing in here. everything that needs protection
inside the midlayer and the scsi device drivers (sd, cd, etc) uses
mutexes now.

this pushes splbio out of the midlayer. splbio is only taken before
biodone is called now.

ok beck@@ marco@@ krw@@ deraadt@@. theyre all terrified, but they all
say if we're going to do then now is the right stage of the dev
cycle.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.168 2010/04/06 00:58:00 dlg Exp $	*/
d81 1
a82 2
void			scsi_ioh_req(struct scsi_iopool *,
			    struct scsi_iohandler *);
d85 1
a86 2
void			scsi_xsh_runqueue(struct scsi_link *);
struct scsi_xshandler *	scsi_xsh_deq(struct scsi_link *);
d260 1
a260 1
	ioh->onq = 0;
d272 2
a273 1
	if (!ioh->onq) {
d275 7
a281 1
		ioh->onq = 1;
d283 1
d296 2
a297 1
	if (ioh->onq) {
d299 7
a305 1
		ioh->onq = 0;
d307 1
d315 2
d326 1
a326 1
		ioh->onq = 0;
d333 2
a334 2
void
scsi_ioh_req(struct scsi_iopool *iopl, struct scsi_iohandler *ioh)
d336 2
d339 1
a339 4
	if (!ioh->onq) {
		TAILQ_INSERT_HEAD(&iopl->queue, &ioh->entry, e);
		ioh->onq = 1;
	}
d341 2
d354 3
a356 3
		for (;;) {
			ioh = scsi_ioh_deq(iopl);
			if (ioh == NULL)
d359 3
a361 3
			io = iopl->io_get(iopl->iocookie);
			if (io == NULL) {
				scsi_ioh_req(iopl, ioh);
a427 1
	xsh->onq = 0;
d437 2
a438 2
	mtx_enter(&link->mtx);
	if (!xsh->onq) {
d440 1
a440 1
		xsh->onq = 1;
d442 1
a442 1
	mtx_leave(&link->mtx);
d453 5
a457 2
	mtx_enter(&link->mtx);
	if (xsh->onq) {
d459 7
a465 1
		xsh->onq = 0;
d467 2
a468 1
	mtx_leave(&link->mtx);
a474 20
struct scsi_xshandler *
scsi_xsh_deq(struct scsi_link *link)
{
	struct scsi_runq_entry *entry;
	struct scsi_xshandler *xsh = NULL;

	mtx_enter(&link->mtx);
	if (link->openings && ((entry = TAILQ_FIRST(&link->queue)) != NULL)) {
		TAILQ_REMOVE(&link->queue, entry, e);

		xsh = (struct scsi_xshandler *)entry;
		xsh->onq = 0;

		link->openings--;
	}
	mtx_leave(&link->mtx);

	return (xsh);
}

d478 2
a479 1
	struct scsi_xshandler *xsh;
d484 10
a493 4
		for (;;) {
			xsh = scsi_xsh_deq(link);
			if (xsh == NULL)
				break;
d495 1
a495 1
			scsi_ioh_add(&xsh->ioh);
d497 4
a549 1
		xsh.onq = 0;
d569 1
a569 1
	mtx_enter(&link->mtx);
d574 1
a574 1
	mtx_leave(&link->mtx);
d582 1
a582 1
	mtx_enter(&link->mtx);
d584 1
a584 1
	mtx_leave(&link->mtx);
@


1.168
log
@implement a new mechanism for allocating resources on the bus.

instead of optimistically trying to use a resource by executing an
xs and then failing when there's no room for it, this puts things
that want to use the hardware on a runqueue. as resources become
available on the bus then consumers on the runqueue are popped off
and guaranteed access to the resource.

the resources are generally "ccbs" in adapter drivers, so this
abstracts a way for the midlayer to get access to them into something
called iopools.

it also provides a callback api for consumers of resources to use:
the scsi_ioh api for things that want direct access to the ccbs,
and the scsi_xsh api for things that want to issue a scsi_xfer on
the bus. these apis have been modelled on the timeout api.

scsi_xs_get and therefore scsi_scs_cmd have been cut over to using these
apis internally, so if they are allowed to sleep then can wait on the
runqueue for a resource to become available and therefore guarantee that
when executed on an adapter providing an iopool that they will succeed.

ok krw@@ beck@@ marco@@
tested by many including krw@@ beck@@ mk@@ okan@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.167 2010/03/23 01:57:20 krw Exp $	*/
a1104 2
	splassert(IPL_BIO);

@


1.167
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.166 2010/01/15 06:27:12 krw Exp $	*/
d79 25
d198 311
d510 2
a511 8
 * Get a scsi transfer structure for the caller. Charge the structure
 * to the device that is referenced by the sc_link structure. If the
 * sc_link structure has no 'credits' then the device already has the
 * maximum number or outstanding operations under way. In this stage,
 * wait on the structure so that when one is freed, we are awoken again
 * If the SCSI_NOSLEEP flag is set, then do not wait, but rather, return
 * a NULL pointer, signifying that no slots were available
 * Note in the link structure, that we are waiting on it.
d517 8
a524 6
	struct scsi_xfer *xs;

	mtx_enter(&link->mtx);
	while (link->openings == 0) {
		if (ISSET(flags, SCSI_NOSLEEP)) {
			mtx_leave(&link->mtx);
d527 3
d531 26
a556 2
		atomic_setbits_int(&link->state, SDEV_S_WAITING);
		msleep(link, &link->mtx, PRIBIO, "getxs", 0);
a557 1
	link->openings--;
d560 18
a577 1
	/* pool is shared, link mtx is not */
d581 2
a582 3
		mtx_enter(&link->mtx);
		link->openings++;
		mtx_leave(&link->mtx);
d589 1
a594 5
/*
 * Given a scsi_xfer struct, and a device (referenced through sc_link)
 * return the struct to the free pool and credit the device with it
 * If another process is waiting for an xs, do a wakeup, let it proceed
 */
d599 1
a599 1
	int start = 1;
d603 2
a604 10
	mtx_enter(&link->mtx);
	link->openings++;

	/* If someone is waiting for scsi_xfer, wake them up. */
	if (ISSET(link->state, SDEV_S_WAITING)) {
		atomic_clearbits_int(&link->state, SDEV_S_WAITING);
		wakeup(link);
		start = 0;
	}
	mtx_leave(&link->mtx);
d606 1
a606 1
	if (start && link->device->start)
d2278 12
@


1.166
log
@Oops. Respect the various IGNORE flags when not in SCSIDEBUG mode.
Should quieten booting again.

And thus ends n2k10.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.165 2010/01/15 05:50:31 krw Exp $	*/
a720 2
	int s;

d731 1
a731 8
#endif /* SCSIDEBUG */

	/*
	 * scsi_xs_exec() guarantees that scsi_done() will be called on the xs
	 * it was given. The adapter is responsible for calling scsi_done()
	 * except if its scsi_cmd() routine returns NO_CCB.
	 * In those cases we must call scsi_done() for it.
	 */
d733 2
a734 10
	if (xs->sc_link->adapter->scsi_cmd(xs) == NO_CCB) {
		/*
		 * Give the xs back to the device driver to retry on its own.
		 */

		xs->error = XS_NO_CCB;
		s = splbio();
		scsi_done(xs);
		splx(s);
	}
@


1.166.2.1
log
@MFC, original commit from dlg:
--------------------------------------------------------------------------
if we're going to set ITSDONE when an xfer is done cos the adapter expects
it, we should clear it before we issue it to the adapter too. retried
commands would have ITSDONE still set otherwise.
--------------------------------------------------------------------------

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.166 2010/01/15 06:27:12 krw Exp $	*/
a725 1
	CLR(xs->flags, ITSDONE);
@


1.165
log
@Abstract and merge the manual buf queue manipulating functions into
one place for easier debugging and maintenance. No intended functional
changes.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.164 2010/01/14 04:56:08 krw Exp $	*/
d996 1
a998 12
	serr = sense->error_code & SSD_ERRCODE;
	if (serr != SSD_ERRCODE_CURRENT && serr != SSD_ERRCODE_DEFERRED)
		skey = 0xff;	/* Invalid value, since key is 4 bit value. */
	else
		skey = sense->flags & SSD_KEY;

#ifndef SCSIDEBUG
	/* If not SCSIDEBUG, only print sense in some cases. */
	if (skey && (xs->flags & SCSI_SILENT) == 0)
#endif /* SCSIDEBUG */
		scsi_print_sense(xs);

d1012 7
a1019 2
	 * Default sense interpretation.
	 *
d1135 6
@


1.164
log
@Print sense data during SCSIDEBUG again. Always print the decoded
data when SCSIDEBUG is set, irrespective of SCSI_SILENT. Tweak
output a bit.

Noticed in output generated by todd@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.163 2010/01/14 00:32:46 krw Exp $	*/
d1892 56
@


1.163
log
@Tweak names a bit. show_mem -> scsi_show_mem, show_scsi_xs ->
scsi_xs_show.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.162 2010/01/13 10:53:11 krw Exp $	*/
a765 2
		if (xs->status == XS_SENSE || xs->status == XS_SHORTSENSE)
			scsi_show_mem((u_char *)&xs->sense, sizeof(xs->sense));
d993 17
a1022 7
	/* Default sense interpretation. */
	serr = sense->error_code & SSD_ERRCODE;
	if (serr != SSD_ERRCODE_CURRENT && serr != SSD_ERRCODE_DEFERRED)
		skey = 0xff;	/* Invalid value, since key is 4 bit value. */
	else
		skey = sense->flags & SSD_KEY;

d1024 2
a1141 3
	if (skey && (xs->flags & SCSI_SILENT) == 0)
		scsi_print_sense(xs);

d1905 1
a1905 2

	printf("xs(%p): ", xs);
a1910 2
	printf("cmd(%p)", xs->cmd);
	printf("len(0x%x)", xs->cmdlen);
a1911 1
	printf("len(0x%x)", xs->datalen);
d1916 2
a1917 1
	printf("command: ");
@


1.162
log
@Get new xs's with PR_ZERO to ensure all shiny new fields get
initialized. Bring back panics on non-NULL done and cookie fields,
but put inside DIAGNOSTIC.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.161 2010/01/13 08:04:39 krw Exp $	*/
d729 1
a729 1
		show_scsi_xs(xs);
d731 1
a731 1
			show_mem(xs->data, min(64, xs->datalen));
d765 1
a765 1
			show_mem(xs->data, min(64, xs->datalen));
d767 1
a767 1
			show_mem((u_char *)&xs->sense, sizeof(xs->sense));
d1892 1
a1892 1
show_scsi_xs(struct scsi_xfer *xs)
d1927 1
a1927 1
show_mem(u_char *address, int num)
@


1.161
log
@Cookie or done is set on entry to scsi_xs_sync(). Take panic() out
until we figure out why.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.160 2010/01/13 05:08:55 dlg Exp $	*/
d203 2
a204 2
	xs = pool_get(&scsi_xfer_pool,
	    ISSET(flags, SCSI_NOSLEEP) ? PR_NOWAIT : PR_WAITOK);
a213 1
		bzero(&xs->cmdstore, sizeof(xs->cmdstore));
a214 5
		xs->cmdlen = 0;
		xs->data = NULL;
		xs->datalen = 0;
		xs->resid = 0;
		xs->bp = NULL;
d780 7
@


1.160
log
@when checking an xs for errors, first check if the device the xs is for
is dying. if so, return ENXIO.

this should make detach of devices during scsi attaches less dangerous.

idea (and the first version of this diff) ok deraadt@@
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.159 2010/01/13 03:09:05 dlg Exp $	*/
a785 3

	if (xs->done != NULL || xs->cookie != NULL)
		panic("scsi_xs_sync: xs done or cookie is set!");
@


1.159
log
@scsi_xs_sync uses the xs cookie and done pointers, so users of scsi_xs_sync
cannot. panic if theyre set before scsi_xs_sync is called.

question raised by and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.158 2010/01/13 02:46:19 krw Exp $	*/
d902 3
@


1.158
log
@Oops. Restore decrement of xs->retries I optimized away. Not everything
is dlg@@'s fault.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.157 2010/01/13 00:49:24 jcs Exp $	*/
d786 3
@


1.157
log
@typo in panic message
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.156 2010/01/10 23:06:43 krw Exp $	*/
d936 1
a936 1
	if (error == ERESTART && xs->retries < 1)
@


1.156
log
@Restore delay on XS_BUSY result, just in case it is needed somewhere. Polish
logic to eliminate FALLTHROUGH craziness.

ok marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.155 2010/01/10 00:10:23 krw Exp $	*/
d818 1
a818 1
		panic("scsi_done calle twice on xs(%p)", xs);
@


1.155
log
@Set ITSDONE in scsi_done() and zap trivial instances of setting it
in the drivers just before calling scsi_done().

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.154 2010/01/09 22:24:34 dlg Exp $	*/
d902 1
a902 1
		return (0);
d906 1
a906 1
		return (EAGAIN);
d914 1
d916 3
a918 2
		if (error != ERESTART)
			xs->retries = 0;
a919 2
		/* FALLTHROUGH */
	case XS_BUSY:
d922 2
a923 2
		if (xs->retries--)
			return (ERESTART);
a924 1
		/* FALLTHROUGH */
d936 4
a939 1
	return (error);
@


1.154
log
@panic with a nice message if scsi_xs_sync_done gets called twice
rather than generating a fluffy printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.153 2010/01/09 21:04:55 dlg Exp $	*/
d777 1
@


1.153
log
@always try to restart io on a device when an opening is made available from
scsi_xs_put.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.151 2010/01/04 11:46:17 dlg Exp $	*/
d816 2
a817 7
	if (cookie == NULL) {
#ifdef DIAGNOSTIC
		sc_print_addr(xs->sc_link);
		printf("scsi_done already called on xs(%p)\n", xs);
#endif
		return;
	}
@


1.152
log
@warn if scsi_done has been called twice on an xs in the scsi_xs_sync path
rather than panic.

ok krw@@
@
text
@d235 1
d246 1
d249 3
@


1.151
log
@nothing in the midlayer cares about ITSDONE anymore. if a command is done,
the adapter will call scsi_done on it.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.149 2010/01/01 07:06:27 dlg Exp $	*/
d810 8
@


1.150
log
@introduce scsi_xs_sync. this will synchronously execute a scsi_xfer
and do the appropriate sleeps, retries, error processing, and finally
returns an errno style value to the caller.

this cuts scsi_scsi_cmd, the ioctl code, sd_flush, and scsi_inquiry over
to scsi_xs_sync.

ok krw@@
@
text
@a723 1
	xs->flags &= ~ITSDONE;
a761 2

	xs->flags |= ITSDONE;
@


1.149
log
@deck chair shuffling
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.148 2010/01/01 06:30:27 dlg Exp $	*/
d55 1
a55 1
int	sc_err1(struct scsi_xfer *);
d58 1
a58 1
void	scsi_xs_done(struct scsi_xfer *);
d213 1
a213 1
		xs->timeout = 0;
d337 1
a337 1
scsi_inquire(struct scsi_link *sc_link, struct scsi_inquiry_data *inqbuf,
d340 14
a353 3
	struct scsi_inquiry			scsi_cmd;
	int					length;
	int					error;
d355 9
a363 2
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = INQUIRY;
a365 1

d371 3
a373 9
	/*
	 * Ask for only the basic 36 bytes of SCSI2 inquiry information. This
	 * avoids problems with devices that choke trying to supply more.
	 */
	length = SID_INQUIRY_HDR + SID_SCSI2_ALEN;
	_lto2b(length, scsi_cmd.length);
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)inqbuf, length, 2, 10000, NULL,
	    SCSI_DATA_IN | flags);
d778 43
d852 1
a852 13
	xs->done = scsi_xs_done;

	do {
		scsi_xs_exec(xs);
		if (!ISSET(xs->flags, SCSI_POLL)) {
			s = splbio();
			while (!ISSET(xs->flags, ITSDONE))
				tsleep(xs, PRIBIO, "scsicmd", 0);
			splx(s);
		}

		error = sc_err1(xs);
	} while (error == ERESTART);
a885 7
void
scsi_xs_done(struct scsi_xfer *xs)
{
	if (!ISSET(xs->flags, SCSI_POLL))
		wakeup_one(xs);
}

d887 1
a887 1
sc_err1(struct scsi_xfer *xs)
d889 1
a889 1
	int					error;
d891 2
a892 1
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("sc_err1,err = 0x%x\n", xs->error));
a893 7
	/*
	 * If it has a buf, we might be working with
	 * a request from the buffer cache or some other
	 * piece of code that requires us to process
	 * errors at interrupt time. We have probably
	 * been called by scsi_done()
	 */
d896 5
a900 1
		error = 0;
d905 1
a905 2
		if ((error = scsi_interpret_sense(xs)) == ERESTART)
			goto retry;
a907 1
		break;
d909 4
a913 5
		if (xs->retries) {
			if ((error = scsi_delay(xs, 1)) == EIO)
				goto lose;
		}
		/* FALLTHROUGH */
d915 4
a918 6
	retry:
		if (xs->retries--) {
			xs->error = XS_NOERROR;
			xs->flags &= ~ITSDONE;
			return ERESTART;
		}
a920 4
	lose:
		error = EIO;
		break;

a921 15
		/* XXX Disable device? */
		error = EIO;
		break;

	case XS_RESET:
		if (xs->retries) {
			SC_DEBUG(xs->sc_link, SDEV_DB3,
			    ("restarting command destroyed by reset\n"));
			goto retry;
		}
		error = EIO;
		break;

	case XS_NO_CCB:
		error = EAGAIN;
a927 1
		error = EIO;
@


1.148
log
@split the flags used in a scsi_link structure to represent its state at
runtime out into a separate state variable. only operate on the state bits
with atomic ops. introduce the DYING state so things that sleep can figure
out if they should keep going or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.147 2009/12/09 21:02:51 krw Exp $	*/
a710 1
	int rv;
d733 1
a733 2
	rv = xs->sc_link->adapter->scsi_cmd(xs);
	if (rv == NO_CCB) {
a742 4

	/*
	 * The adapter has called or will call scsi_done().
	 */
@


1.147
log
@Nuke stray comment referencing deceased TRY_AGAIN_LATER that dlg@@
snuck back in.

Noticed by kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.146 2009/12/07 00:09:27 krw Exp $	*/
d196 1
a196 1
		SET(link->flags, SDEV_WAITING);
d242 2
a243 2
	if (ISSET(link->flags, SDEV_WAITING)) {
		CLR(link->flags, SDEV_WAITING);
@


1.146
log
@Re-enable SCSIDEBUG display of commands and data. Original diff
from dlg@@, tweaking by me to make it compile.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.145 2009/12/01 01:50:35 dlg Exp $	*/
d730 1
a730 1
	 * except if its scsi_cmd() routine returns NO_CCB or TRY_AGAIN_LATER.
@


1.145
log
@properly handle all xs states that can be returned by an adapter in sd.

requested by krw@@ after spending a week munging through my code.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.144 2009/12/01 01:40:02 dlg Exp $	*/
d719 8
d761 9
d1872 55
@


1.144
log
@put the midlayer changes back in.

the two issues affecting it last time are gone. the first, mishandling of
TRY_AGAIN_LATER is not relevant now that krw got rid of TRY_AGAIN_LATER.
the second, the misbehaving IBM disk was found to be a problem with siop
using ordered tags on most ops combined with the speed of the new code.

putting this in so we can move forward.

ok krw@@ "commit please" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.143 2009/11/22 20:09:53 krw Exp $	*/
a55 1
int	scsi_interpret_sense(struct scsi_xfer *);
@


1.143
log
@Nuke TRY_AGAIN_LATER now that no driver returns it.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.142 2009/11/12 06:20:27 dlg Exp $	*/
a52 3
static __inline struct scsi_xfer *scsi_make_xs(struct scsi_link *,
    struct scsi_generic *, int cmdlen, u_char *data_addr,
    int datalen, int retries, int timeout, struct buf *, int flags);
d59 2
d97 1
d186 1
a186 1
scsi_get_xs(struct scsi_link *sc_link, int flags)
d188 1
a188 4
	struct scsi_xfer		*xs;
	int				s;

	SC_DEBUG(sc_link, SDEV_DB3, ("scsi_get_xs\n"));
d190 4
a193 12
	s = splbio();
	while (sc_link->openings == 0) {
		SC_DEBUG(sc_link, SDEV_DB3, ("sleeping\n"));
		if ((flags & SCSI_NOSLEEP) != 0) {
			splx(s);
			return (NULL);
		}
		sc_link->flags |= SDEV_WAITING;
		if (tsleep(sc_link, PRIBIO|PCATCH, "getxs", 0)) {
			/* Bail out on getting a signal. */
			sc_link->flags &= ~SDEV_WAITING;
			splx(s);
d196 3
d200 4
a203 1
	SC_DEBUG(sc_link, SDEV_DB3, ("calling pool_get\n"));
d205 6
a210 4
	    ((flags & SCSI_NOSLEEP) != 0 ? PR_NOWAIT : PR_WAITOK));
	if (xs != NULL) {
		bzero(xs, sizeof(*xs));
		sc_link->openings--;
d212 10
a221 3
	} else {
		sc_print_addr(sc_link);
		printf("cannot allocate scsi xs\n");
a222 3
	splx(s);

	SC_DEBUG(sc_link, SDEV_DB3, ("returning\n"));
d233 1
a233 1
scsi_free_xs(struct scsi_xfer *xs, int start)
d235 1
a235 1
	struct scsi_link *sc_link = xs->sc_link;
d237 1
a237 1
	splassert(IPL_BIO);
d239 2
a240 4
	SC_DEBUG(sc_link, SDEV_DB3, ("scsi_free_xs\n"));

	pool_put(&scsi_xfer_pool, xs);
	sc_link->openings++;
d243 3
a245 7
	if ((sc_link->flags & SDEV_WAITING) != 0) {
		sc_link->flags &= ~SDEV_WAITING;
		wakeup(sc_link);
	} else if (start && sc_link->device->start) {
		SC_DEBUG(sc_link, SDEV_DB2,
		    ("calling private start()\n"));
		(*(sc_link->device->start)) (sc_link->device_softc);
d247 1
a247 49
}

/*
 * Make a scsi_xfer, and return a pointer to it.
 */
static __inline struct scsi_xfer *
scsi_make_xs(struct scsi_link *sc_link, struct scsi_generic *scsi_cmd,
    int cmdlen, u_char *data_addr, int datalen, int retries, int timeout,
    struct buf *bp, int flags)
{
	struct scsi_xfer		*xs;

	if ((xs = scsi_get_xs(sc_link, flags)) == NULL)
		return (NULL);

	/*
	 * Fill out the scsi_xfer structure.  We don't know whose context
	 * the cmd is in, so copy it.
	 */
	xs->sc_link = sc_link;
	bcopy(scsi_cmd, &xs->cmdstore, cmdlen);
	xs->cmd = &xs->cmdstore;
	xs->cmdlen = cmdlen;
	xs->data = data_addr;
	xs->datalen = datalen;
	xs->retries = retries;
	xs->timeout = timeout;
	xs->bp = bp;

	/*
	 * Set the LUN in the CDB if it fits in the three bits available. This
	 * may only be needed if we have an older device.  However, we also set
	 * it for more modern SCSI devices "just in case".  The old code
	 * assumed everything newer than SCSI-2 would not need it, but why risk
	 * it?  This was the old conditional:
	 *
	 * if ((SCSISPC(sc_link->inqdata.version) <= 2))
	 */
	xs->cmd->bytes[0] &= ~SCSI_CMD_LUN_MASK;
	if (sc_link->lun < 8)
		xs->cmd->bytes[0] |= ((sc_link->lun << SCSI_CMD_LUN_SHIFT) &
		    SCSI_CMD_LUN_MASK);

#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		show_scsi_xs(xs);
#endif /* SCSIDEBUG */

	return (xs);
a708 3
/*
 * This routine is called by the scsi interrupt when the transfer is complete.
 */
d710 1
a710 1
scsi_done(struct scsi_xfer *xs)
d712 2
a713 3
	struct scsi_link			*sc_link = xs->sc_link;
	struct buf				*bp;
	int					error;
d715 4
a718 5
	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_done\n"));

	splassert(IPL_BIO);

	xs->flags |= ITSDONE;
d721 5
a725 13
 	 * If it's a user level request, bypass all usual completion processing,
 	 * let the user work it out.. We take reponsibility for freeing the
 	 * xs when the user returns (and restarting the device's queue).
 	 */
	if ((xs->flags & SCSI_USER) != 0) {
		SC_DEBUG(sc_link, SDEV_DB3, ("calling user done()\n"));
		scsi_user_done(xs); /* to take a copy of the sense etc. */
		SC_DEBUG(sc_link, SDEV_DB3, ("returned from user done()\n"));

		scsi_free_xs(xs, 1); /* restarts queue too */
		SC_DEBUG(sc_link, SDEV_DB3, ("returning to adapter\n"));
		return;
	}
d727 2
a728 1
	if (!((xs->flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP)) {
d730 1
a730 3
		 * if it's a normal upper level request, then ask
		 * the upper level code to handle error checking
		 * rather than doing it here at interrupt time
d732 5
a736 2
		wakeup(xs);
		return;
d740 1
a740 2
	 * Go and handle errors now.
	 * If it returns ERESTART then we should RETRY
a741 36
retry:
	error = sc_err1(xs);
	if (error == ERESTART) {
		switch ((*(sc_link->adapter->scsi_cmd)) (xs)) {
		case SUCCESSFULLY_QUEUED:
			return;

		case COMPLETE:
			goto retry;
		}
	}

	bp = xs->bp;
	if (bp != NULL) {
		if (error) {
			bp->b_error = error;
			bp->b_flags |= B_ERROR;
			bp->b_resid = bp->b_bcount;
		} else {
			bp->b_error = 0;
			bp->b_resid = xs->resid;
		}
	}

	if (sc_link->device->done) {
		/*
		 * Tell the device the operation is actually complete.
		 * No more will happen with this xfer.  This for
		 * notification of the upper-level driver only; they
		 * won't be returning any meaningful information to us.
		 */
		(*sc_link->device->done)(xs);
	}
	scsi_free_xs(xs, 1);
	if (bp != NULL)
		biodone(bp);
d744 5
a748 2
int
scsi_execute_xs(struct scsi_xfer *xs)
d750 1
a750 1
	int					error, flags, rslt, s;
d752 1
a752 72
	xs->flags &= ~ITSDONE;
	xs->error = XS_NOERROR;
	xs->resid = xs->datalen;
	xs->status = 0;

	/*
	 * Do the transfer. If we are polling we will return:
	 * COMPLETE.
	 *
	 * if under full steam (interrupts) it will return:
	 * SUCCESSFULLY_QUEUED, will do a wakeup when complete.
	 * After the wakeup, we must still check if it succeeded
	 *
	 * If we have a SCSI_NOSLEEP (typically because we have a buf)
	 * we just return.  All the error processing and the buffer
	 * code both expect us to return straight to them, so as soon
	 * as the command is queued, return.
	 */

	/*
	 * We save the flags here because the xs structure may already
	 * be freed by scsi_done by the time adapter->scsi_cmd returns.
	 *
	 * scsi_done is responsible for freeing the xs if either
	 * (flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP
	 * -or-
	 * (flags & SCSI_USER) != 0
	 *
	 * Note: SCSI_USER must always be called with SCSI_NOSLEEP
	 * and never with SCSI_POLL, so the second expression should be
	 * is equivalent to the first.
	 */

	flags = xs->flags;
#ifdef DIAGNOSTIC
	if ((flags & (SCSI_USER | SCSI_NOSLEEP)) == SCSI_USER)
		panic("scsi_execute_xs: USER without NOSLEEP");
	if ((flags & (SCSI_USER | SCSI_POLL)) == (SCSI_USER | SCSI_POLL))
		panic("scsi_execute_xs: USER with POLL");
#endif
retry:
	rslt = (*(xs->sc_link->adapter->scsi_cmd))(xs);
	switch (rslt) {
	case SUCCESSFULLY_QUEUED:
		if ((flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP)
			return (EJUSTRETURN);
#ifdef DIAGNOSTIC
		if (flags & SCSI_NOSLEEP)
			panic("scsi_execute_xs: NOSLEEP and POLL");
#endif
		s = splbio();
		/* Since the xs is active we can't bail out on a signal. */
		while ((xs->flags & ITSDONE) == 0)
			tsleep(xs, PRIBIO + 1, "scsicmd", 0);
		splx(s);
		/* FALLTHROUGH */
	case COMPLETE:		/* Polling command completed ok */
		if ((flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP)
			return (EJUSTRETURN);
		if (xs->bp)
			return (EJUSTRETURN);
		SC_DEBUG(xs->sc_link, SDEV_DB3, ("back in cmd()\n"));
		if ((error = sc_err1(xs)) != ERESTART)
			return (error);
		goto retry;

	case NO_CCB:
		return (EAGAIN);

	default:
		panic("scsi_execute_xs: invalid return code (%#x)", rslt);
	}
d754 1
a754 4
#ifdef DIAGNOSTIC
	panic("scsi_execute_xs: impossible");
#endif
	return (EINVAL);
d764 1
a764 1
scsi_scsi_cmd(struct scsi_link *sc_link, struct scsi_generic *scsi_cmd,
d768 3
a770 5
	struct scsi_xfer			*xs;
	int					error;
	int					s;

	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_cmd\n"));
d777 2
a778 2
	if ((xs = scsi_make_xs(sc_link, scsi_cmd, cmdlen, data_addr, datalen,
	    retries, timeout, bp, flags)) == NULL)
d781 17
a797 13
#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		if (xs->datalen && (xs->flags & SCSI_DATA_OUT))
			show_mem(xs->data, min(64, xs->datalen));
#endif	/* SCSIDEBUG */

	error = scsi_execute_xs(xs);

#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		if (xs->datalen && (xs->flags & SCSI_DATA_IN))
			show_mem(xs->data, min(64, xs->datalen));
#endif	/* SCSIDEBUG */
d799 2
a800 2
	if (error == EJUSTRETURN)
		return (0);
d802 15
a816 1
	s = splbio();
d818 10
a827 4
	if (error == EAGAIN)
		scsi_free_xs(xs, 0); /* Don't restart queue. */
	else
		scsi_free_xs(xs, 1);
d829 1
a829 1
	splx(s);
d834 7
d901 4
a963 4
#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		show_mem((u_char *)&xs->sense, sizeof xs->sense);
#endif	/* SCSIDEBUG */
a1855 54

#ifdef SCSIDEBUG
/*
 * Given a scsi_xfer, dump the request, in all its glory
 */
void
show_scsi_xs(struct scsi_xfer *xs)
{
	u_char *b = (u_char *) xs->cmd;
	int i = 0;

	sc_print_addr(xs->sc_link);

	printf("xs(%p): ", xs);

	printf("flg(0x%x)", xs->flags);
	printf("sc_link(%p)", xs->sc_link);
	printf("retr(0x%x)", xs->retries);
	printf("timo(0x%x)", xs->timeout);
	printf("cmd(%p)", xs->cmd);
	printf("len(0x%x)", xs->cmdlen);
	printf("data(%p)", xs->data);
	printf("len(0x%x)", xs->datalen);
	printf("res(0x%x)", xs->resid);
	printf("err(0x%x)", xs->error);
	printf("bp(%p)\n", xs->bp);

	printf("command: ");

	if ((xs->flags & SCSI_RESET) == 0) {
		while (i < xs->cmdlen) {
			if (i)
				printf(",");
			printf("%x", b[i++]);
		}
		printf("-[%d bytes]\n", xs->datalen);
	} else
		printf("-RESET-\n");
}

void
show_mem(u_char *address, int num)
{
	int					x;

	printf("------------------------------");
	for (x = 0; x < num; x++) {
		if ((x % 16) == 0)
			printf("\n%03d: ", x);
		printf("%02x ", *address++);
	}
	printf("\n------------------------------\n");
}
#endif /* SCSIDEBUG */
@


1.142
log
@revert midlayer back to it was before i put my big rewrite in. this is
causing a weird problems on an alpha and also appears responsible for
isp(4) weirdness i havent had a chance to examine yet.

sigh, this makes me sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.138 2009/11/05 03:33:52 marco Exp $	*/
a813 3
		case TRY_AGAIN_LATER:
			xs->error = XS_BUSY;
			/* FALLTHROUGH */
d857 1
a857 2
	 * COMPLETE,  Was poll, and scsi_done has been called
	 * TRY_AGAIN_LATER, Adapter short resources, try again
d860 1
a860 2
	 * SUCCESSFULLY_QUEUED, will do a wakeup when complete
	 * TRY_AGAIN_LATER, (as for polling)
a910 1
	doit:
a914 4

	case TRY_AGAIN_LATER:	/* adapter resource shortage */
		xs->error = XS_BUSY;
		goto doit;
@


1.141
log
@remove a stale comment from a previous revision of the diff i
committed. i hate comments. i read and change the code and then
forget about the comments.

pointed out by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.140 2009/11/10 10:18:59 dlg Exp $	*/
d53 3
a61 2
void	scsi_xs_done(struct scsi_xfer *);

a97 1
	pool_setipl(&scsi_xfer_pool, IPL_BIO);
d186 1
a186 1
scsi_xs_get(struct scsi_link *link, int flags)
d188 4
a191 1
	struct scsi_xfer *xs;
d193 12
a204 4
	mtx_enter(&link->mtx);
	while (link->openings == 0) {
		if (ISSET(flags, SCSI_NOSLEEP)) {
			mtx_leave(&link->mtx);
a206 3

		SET(link->flags, SDEV_WAITING);
		msleep(link, &link->mtx, PRIBIO, "getxs", 0);
d208 1
a208 4
	link->openings--;
	mtx_leave(&link->mtx);

	/* pool is shared, link mtx is not */
d210 5
a214 5
	    ISSET(flags, SCSI_NOSLEEP) ? PR_NOWAIT : PR_WAITOK);
	if (xs == NULL) {
		mtx_enter(&link->mtx);
		link->openings++;
		mtx_leave(&link->mtx);
d216 2
a217 11
		xs->flags = flags;
		xs->sc_link = link;
		xs->retries = SCSI_RETRIES;
		xs->timeout = 0;
		bzero(&xs->cmdstore, sizeof(xs->cmdstore));
		xs->cmd = &xs->cmdstore;
		xs->cmdlen = 0;
		xs->data = NULL;
		xs->datalen = 0;
		xs->resid = 0;
		xs->bp = NULL;
d219 3
d232 1
a232 1
scsi_xs_put(struct scsi_xfer *xs)
d234 5
a238 1
	struct scsi_link *link = xs->sc_link;
d241 1
a241 3

	mtx_enter(&link->mtx);
	link->openings++;
d244 7
a250 3
	if (ISSET(link->flags, SDEV_WAITING)) {
		CLR(link->flags, SDEV_WAITING);
		wakeup(link);
d252 49
a300 1
	mtx_leave(&link->mtx);
d762 3
d766 1
a766 1
scsi_xs_exec(struct scsi_xfer *xs)
d768 3
a770 2
	int rv;
	int s;
d772 5
a776 4
	xs->flags &= ~ITSDONE;
	xs->error = XS_NOERROR;
	xs->resid = xs->datalen;
	xs->status = 0;
d779 13
a791 5
	 * scsi_xs_exec() guarantees that scsi_done() will be called on the xs
	 * it was given. The adapter is responsible for calling scsi_done()
	 * except if its scsi_cmd() routine returns NO_CCB or TRY_AGAIN_LATER.
	 * In those cases we must call scsi_done().
	 */
d793 1
a793 4
retry:
	rv = xs->sc_link->adapter->scsi_cmd(xs);
	switch (rv) {
	case NO_CCB:
d795 3
a797 1
		 * Give the xs back to the device driver to retry on its own.
d799 3
d803 10
a812 2
		xs->error = XS_NO_CCB;
		break;
d814 7
a820 8
	case TRY_AGAIN_LATER:
		/*
		 * We delay or sleep a bit and then try to shove the xs onto
		 * the adapter again.
		 *
		 * This must be done here because scsi_xs_exec() guarantees
		 * that scsi_done() will be called.
		 */
d822 9
a830 15
		if (xs->retries-- > 0) {
			switch (xs->flags & (SCSI_POLL | SCSI_NOSLEEP)) {
			case SCSI_POLL:
				delay(1000000);
				/* FALLTHROUGH */
			case SCSI_NOSLEEP:
				/* We can't sleep, try again immediately */
				goto retry;
			case (SCSI_POLL | SCSI_NOSLEEP):
				panic("POLL and NOSLEEP specific on an xs");
			}
			if (tsleep(&lbolt, PRIBIO|PCATCH, "scbusy", 0) == 0) {
				/* if we waited, retry */
				goto retry;
			}
d832 1
a832 2
		xs->error = XS_BUSY;
		break;
d834 1
a834 1
	default:
d836 4
a839 1
		 * The adapter has already called scsi_done(), nothing to do.
d841 1
a841 2

		return;
d843 3
a845 4

	s = splbio();
	scsi_done(xs);
	splx(s);
d848 2
a849 5
/*
 * This routine is called by the adapter when its xs handling is done.
 */
void
scsi_done(struct scsi_xfer *xs)
d851 77
a927 1
	splassert(IPL_BIO);
d929 3
a931 1
	xs->flags |= ITSDONE;
d933 4
a936 1
	xs->done(xs);
d946 1
a946 1
scsi_scsi_cmd(struct scsi_link *link, struct scsi_generic *scsi_cmd,
d950 5
a954 3
	struct scsi_xfer *xs;
	int error;
	int s;
d961 2
a962 2
	xs = scsi_xs_get(link, flags);
	if (xs == NULL)
d965 13
a977 8
	memcpy(xs->cmd, scsi_cmd, cmdlen);
	xs->cmdlen = cmdlen;
	xs->data = data_addr;
	xs->datalen = datalen;
	xs->retries = retries;
	xs->timeout = timeout;

	xs->done = scsi_xs_done;
d979 2
a980 8
	do {
		scsi_xs_exec(xs);
		if (!ISSET(xs->flags, SCSI_POLL)) {
			s = splbio();
			while (!ISSET(xs->flags, ITSDONE))
				tsleep(xs, PRIBIO, "scsicmd", 0);
			splx(s);
		}
d982 1
a982 2
		error = sc_err1(xs);
	} while (error == ERESTART);
d984 4
a987 15
	if (error != EAGAIN) {
		if (bp != NULL) {
			if (error) {
				bp->b_error = error;
				bp->b_flags |= B_ERROR;
				bp->b_resid = bp->b_bcount;
			} else {  
				bp->b_error = 0;
				bp->b_resid = xs->resid;
			}
	
			s = splbio();
			biodone(bp);
			splx(s);
		}
d989 1
a989 12
		if (link->device->done) {
			/*
			 * Tell the device the operation is actually complete.
			 * No more will happen with this xfer.  This for
			 * notification of the upper-level driver only; they
			 * won't be returning any meaningful information to us.
			 */
			link->device->done(xs);
		}
	}

	scsi_xs_put(xs);
a993 7
void
scsi_xs_done(struct scsi_xfer *xs)
{
	if (!ISSET(xs->flags, SCSI_POLL))
		wakeup_one(xs);
}

a1053 4
	case XS_NO_CCB:
		error = EAGAIN;
		break;

d1113 4
d2009 54
@


1.140
log
@fix the NO_CCB handling i broke when working on simplifying the midlayer.

marco@@ discovered my rewrite retried commands rejected by an adapter
from a timeout, which was trivially starved by normal io going to
disks. this diff allows an xs to be marked as XS_NO_CCB, which will
cause it to be returned to the device driver to be retried as part
of the normal io queue.

tested by krw@@ marco@@ johan@@
ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.137 2009/10/27 11:38:24 dlg Exp $	*/
a732 1
		 * Setting retries to 0 prevents the midlayer retrying for us.
@


1.139
log
@backout the backout marco did of my code because of the NO_CCB breakage.
the fix for the NO_CCB breakage will follow shortly.

tested by krw@@ marco@@ johan@@
ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.136 2009/09/14 00:03:28 dlg Exp $	*/
d720 8
d731 8
a738 7
		if (!ISSET(xs->flags, SCSI_POLL) && xs->retries-- > 0) {
			timeout_set(&xs->stimeout,
			    (void (*)(void *))scsi_xs_exec, xs);
			timeout_add(&xs->stimeout, 1);
			break;
		}
		/* FALLTHROUGH */
d740 7
a746 1
		/* hahaha, sif... */
d748 17
a764 4
		xs->error = XS_DRIVER_STUFFUP;
		s = splbio();
		scsi_done(xs);
		splx(s);
d766 7
d774 4
d838 14
a851 8
	if (bp != NULL) {
		if (error) {
			bp->b_error = error;
			bp->b_flags |= B_ERROR;
			bp->b_resid = bp->b_bcount;
		} else {  
			bp->b_error = 0;
			bp->b_resid = xs->resid;
d854 9
a862 13
		s = splbio();
		biodone(bp);
		splx(s);
	}

	if (link->device->done) {
		/*
		 * Tell the device the operation is actually complete.
		 * No more will happen with this xfer.  This for
		 * notification of the upper-level driver only; they
		 * won't be returning any meaningful information to us.
		 */
		link->device->done(xs);
d935 4
@


1.138
log
@The big diff dlg committed to the midlayer breaks NO_CCB and
TRY_AGAIN_LATER.  NO_CCB is a timer based mechanism that can trivially
be made to fail by running IO to two or more disks simultaneously.  The
TRY_AGAIN_LATER thing is more subtle because it now is a permanent
failure instead of transient however this is much harder to hit because
something must have gone wrong before it hits.

ok deraadt krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.135 2009/09/02 14:19:50 dlg Exp $	*/
a52 3
static __inline struct scsi_xfer *scsi_make_xs(struct scsi_link *,
    struct scsi_generic *, int cmdlen, u_char *data_addr,
    int datalen, int retries, int timeout, struct buf *, int flags);
d59 2
d97 1
d186 1
a186 1
scsi_get_xs(struct scsi_link *sc_link, int flags)
d188 1
a188 4
	struct scsi_xfer		*xs;
	int				s;

	SC_DEBUG(sc_link, SDEV_DB3, ("scsi_get_xs\n"));
d190 4
a193 12
	s = splbio();
	while (sc_link->openings == 0) {
		SC_DEBUG(sc_link, SDEV_DB3, ("sleeping\n"));
		if ((flags & SCSI_NOSLEEP) != 0) {
			splx(s);
			return (NULL);
		}
		sc_link->flags |= SDEV_WAITING;
		if (tsleep(sc_link, PRIBIO|PCATCH, "getxs", 0)) {
			/* Bail out on getting a signal. */
			sc_link->flags &= ~SDEV_WAITING;
			splx(s);
d196 3
d200 4
a203 1
	SC_DEBUG(sc_link, SDEV_DB3, ("calling pool_get\n"));
d205 6
a210 4
	    ((flags & SCSI_NOSLEEP) != 0 ? PR_NOWAIT : PR_WAITOK));
	if (xs != NULL) {
		bzero(xs, sizeof(*xs));
		sc_link->openings--;
d212 10
a221 3
	} else {
		sc_print_addr(sc_link);
		printf("cannot allocate scsi xs\n");
a222 3
	splx(s);

	SC_DEBUG(sc_link, SDEV_DB3, ("returning\n"));
d233 1
a233 1
scsi_free_xs(struct scsi_xfer *xs, int start)
d235 1
a235 1
	struct scsi_link *sc_link = xs->sc_link;
d237 1
a237 3
	splassert(IPL_BIO);

	SC_DEBUG(sc_link, SDEV_DB3, ("scsi_free_xs\n"));
d239 2
a240 2
	pool_put(&scsi_xfer_pool, xs);
	sc_link->openings++;
d243 3
a245 7
	if ((sc_link->flags & SDEV_WAITING) != 0) {
		sc_link->flags &= ~SDEV_WAITING;
		wakeup(sc_link);
	} else if (start && sc_link->device->start) {
		SC_DEBUG(sc_link, SDEV_DB2,
		    ("calling private start()\n"));
		(*(sc_link->device->start)) (sc_link->device_softc);
d247 1
a247 49
}

/*
 * Make a scsi_xfer, and return a pointer to it.
 */
static __inline struct scsi_xfer *
scsi_make_xs(struct scsi_link *sc_link, struct scsi_generic *scsi_cmd,
    int cmdlen, u_char *data_addr, int datalen, int retries, int timeout,
    struct buf *bp, int flags)
{
	struct scsi_xfer		*xs;

	if ((xs = scsi_get_xs(sc_link, flags)) == NULL)
		return (NULL);

	/*
	 * Fill out the scsi_xfer structure.  We don't know whose context
	 * the cmd is in, so copy it.
	 */
	xs->sc_link = sc_link;
	bcopy(scsi_cmd, &xs->cmdstore, cmdlen);
	xs->cmd = &xs->cmdstore;
	xs->cmdlen = cmdlen;
	xs->data = data_addr;
	xs->datalen = datalen;
	xs->retries = retries;
	xs->timeout = timeout;
	xs->bp = bp;

	/*
	 * Set the LUN in the CDB if it fits in the three bits available. This
	 * may only be needed if we have an older device.  However, we also set
	 * it for more modern SCSI devices "just in case".  The old code
	 * assumed everything newer than SCSI-2 would not need it, but why risk
	 * it?  This was the old conditional:
	 *
	 * if ((SCSISPC(sc_link->inqdata.version) <= 2))
	 */
	xs->cmd->bytes[0] &= ~SCSI_CMD_LUN_MASK;
	if (sc_link->lun < 8)
		xs->cmd->bytes[0] |= ((sc_link->lun << SCSI_CMD_LUN_SHIFT) &
		    SCSI_CMD_LUN_MASK);

#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		show_scsi_xs(xs);
#endif /* SCSIDEBUG */

	return (xs);
a708 3
/*
 * This routine is called by the scsi interrupt when the transfer is complete.
 */
d710 1
a710 84
scsi_done(struct scsi_xfer *xs)
{
	struct scsi_link			*sc_link = xs->sc_link;
	struct buf				*bp;
	int					error;

	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_done\n"));

	splassert(IPL_BIO);

	xs->flags |= ITSDONE;

	/*
 	 * If it's a user level request, bypass all usual completion processing,
 	 * let the user work it out.. We take reponsibility for freeing the
 	 * xs when the user returns (and restarting the device's queue).
 	 */
	if ((xs->flags & SCSI_USER) != 0) {
		SC_DEBUG(sc_link, SDEV_DB3, ("calling user done()\n"));
		scsi_user_done(xs); /* to take a copy of the sense etc. */
		SC_DEBUG(sc_link, SDEV_DB3, ("returned from user done()\n"));

		scsi_free_xs(xs, 1); /* restarts queue too */
		SC_DEBUG(sc_link, SDEV_DB3, ("returning to adapter\n"));
		return;
	}

	if (!((xs->flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP)) {
		/*
		 * if it's a normal upper level request, then ask
		 * the upper level code to handle error checking
		 * rather than doing it here at interrupt time
		 */
		wakeup(xs);
		return;
	}

	/*
	 * Go and handle errors now.
	 * If it returns ERESTART then we should RETRY
	 */
retry:
	error = sc_err1(xs);
	if (error == ERESTART) {
		switch ((*(sc_link->adapter->scsi_cmd)) (xs)) {
		case SUCCESSFULLY_QUEUED:
			return;

		case TRY_AGAIN_LATER:
			xs->error = XS_BUSY;
			/* FALLTHROUGH */
		case COMPLETE:
			goto retry;
		}
	}

	bp = xs->bp;
	if (bp != NULL) {
		if (error) {
			bp->b_error = error;
			bp->b_flags |= B_ERROR;
			bp->b_resid = bp->b_bcount;
		} else {
			bp->b_error = 0;
			bp->b_resid = xs->resid;
		}
	}

	if (sc_link->device->done) {
		/*
		 * Tell the device the operation is actually complete.
		 * No more will happen with this xfer.  This for
		 * notification of the upper-level driver only; they
		 * won't be returning any meaningful information to us.
		 */
		(*sc_link->device->done)(xs);
	}
	scsi_free_xs(xs, 1);
	if (bp != NULL)
		biodone(bp);
}

int
scsi_execute_xs(struct scsi_xfer *xs)
d712 2
a713 1
	int					error, flags, rslt, s;
d720 12
a731 29
	/*
	 * Do the transfer. If we are polling we will return:
	 * COMPLETE,  Was poll, and scsi_done has been called
	 * TRY_AGAIN_LATER, Adapter short resources, try again
	 *
	 * if under full steam (interrupts) it will return:
	 * SUCCESSFULLY_QUEUED, will do a wakeup when complete
	 * TRY_AGAIN_LATER, (as for polling)
	 * After the wakeup, we must still check if it succeeded
	 *
	 * If we have a SCSI_NOSLEEP (typically because we have a buf)
	 * we just return.  All the error processing and the buffer
	 * code both expect us to return straight to them, so as soon
	 * as the command is queued, return.
	 */

	/*
	 * We save the flags here because the xs structure may already
	 * be freed by scsi_done by the time adapter->scsi_cmd returns.
	 *
	 * scsi_done is responsible for freeing the xs if either
	 * (flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP
	 * -or-
	 * (flags & SCSI_USER) != 0
	 *
	 * Note: SCSI_USER must always be called with SCSI_NOSLEEP
	 * and never with SCSI_POLL, so the second expression should be
	 * is equivalent to the first.
	 */
d733 1
a733 17
	flags = xs->flags;
#ifdef DIAGNOSTIC
	if ((flags & (SCSI_USER | SCSI_NOSLEEP)) == SCSI_USER)
		panic("scsi_execute_xs: USER without NOSLEEP");
	if ((flags & (SCSI_USER | SCSI_POLL)) == (SCSI_USER | SCSI_POLL))
		panic("scsi_execute_xs: USER with POLL");
#endif
retry:
	rslt = (*(xs->sc_link->adapter->scsi_cmd))(xs);
	switch (rslt) {
	case SUCCESSFULLY_QUEUED:
		if ((flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP)
			return (EJUSTRETURN);
#ifdef DIAGNOSTIC
		if (flags & SCSI_NOSLEEP)
			panic("scsi_execute_xs: NOSLEEP and POLL");
#endif
d735 1
a735 3
		/* Since the xs is active we can't bail out on a signal. */
		while ((xs->flags & ITSDONE) == 0)
			tsleep(xs, PRIBIO + 1, "scsicmd", 0);
d737 3
a739 15
		/* FALLTHROUGH */
	case COMPLETE:		/* Polling command completed ok */
		if ((flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP)
			return (EJUSTRETURN);
		if (xs->bp)
			return (EJUSTRETURN);
	doit:
		SC_DEBUG(xs->sc_link, SDEV_DB3, ("back in cmd()\n"));
		if ((error = sc_err1(xs)) != ERESTART)
			return (error);
		goto retry;

	case TRY_AGAIN_LATER:	/* adapter resource shortage */
		xs->error = XS_BUSY;
		goto doit;
d741 7
a747 2
	case NO_CCB:
		return (EAGAIN);
d749 1
a749 3
	default:
		panic("scsi_execute_xs: invalid return code (%#x)", rslt);
	}
d751 1
a751 4
#ifdef DIAGNOSTIC
	panic("scsi_execute_xs: impossible");
#endif
	return (EINVAL);
d761 1
a761 1
scsi_scsi_cmd(struct scsi_link *sc_link, struct scsi_generic *scsi_cmd,
d765 3
a767 5
	struct scsi_xfer			*xs;
	int					error;
	int					s;

	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_cmd\n"));
d774 2
a775 2
	if ((xs = scsi_make_xs(sc_link, scsi_cmd, cmdlen, data_addr, datalen,
	    retries, timeout, bp, flags)) == NULL)
d778 20
a797 13
#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		if (xs->datalen && (xs->flags & SCSI_DATA_OUT))
			show_mem(xs->data, min(64, xs->datalen));
#endif	/* SCSIDEBUG */

	error = scsi_execute_xs(xs);

#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		if (xs->datalen && (xs->flags & SCSI_DATA_IN))
			show_mem(xs->data, min(64, xs->datalen));
#endif	/* SCSIDEBUG */
d799 9
a807 2
	if (error == EJUSTRETURN)
		return (0);
d809 4
a812 1
	s = splbio();
d814 9
a822 4
	if (error == EAGAIN)
		scsi_free_xs(xs, 0); /* Don't restart queue. */
	else
		scsi_free_xs(xs, 1);
d824 1
a824 1
	splx(s);
d829 7
a954 4
#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		show_mem((u_char *)&xs->sense, sizeof xs->sense);
#endif	/* SCSIDEBUG */
a1846 54

#ifdef SCSIDEBUG
/*
 * Given a scsi_xfer, dump the request, in all its glory
 */
void
show_scsi_xs(struct scsi_xfer *xs)
{
	u_char *b = (u_char *) xs->cmd;
	int i = 0;

	sc_print_addr(xs->sc_link);

	printf("xs(%p): ", xs);

	printf("flg(0x%x)", xs->flags);
	printf("sc_link(%p)", xs->sc_link);
	printf("retr(0x%x)", xs->retries);
	printf("timo(0x%x)", xs->timeout);
	printf("cmd(%p)", xs->cmd);
	printf("len(0x%x)", xs->cmdlen);
	printf("data(%p)", xs->data);
	printf("len(0x%x)", xs->datalen);
	printf("res(0x%x)", xs->resid);
	printf("err(0x%x)", xs->error);
	printf("bp(%p)\n", xs->bp);

	printf("command: ");

	if ((xs->flags & SCSI_RESET) == 0) {
		while (i < xs->cmdlen) {
			if (i)
				printf(",");
			printf("%x", b[i++]);
		}
		printf("-[%d bytes]\n", xs->datalen);
	} else
		printf("-RESET-\n");
}

void
show_mem(u_char *address, int num)
{
	int					x;

	printf("------------------------------");
	for (x = 0; x < num; x++) {
		if ((x % 16) == 0)
			printf("\n%03d: ", x);
		printf("%02x ", *address++);
	}
	printf("\n------------------------------\n");
}
#endif /* SCSIDEBUG */
@


1.137
log
@if (!ISSET(flags, SCSI_NOSLEEP)) return; else sleep(); is wrong.

found with krw while looking at #6247. tested locally with iogen and
scsi(8). this fixes a null deref in the ioctl path where there shouldnt be
one.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.136 2009/09/14 00:03:28 dlg Exp $	*/
d53 3
a61 2
void	scsi_xs_done(struct scsi_xfer *);

a97 1
	pool_setipl(&scsi_xfer_pool, IPL_BIO);
d186 1
a186 1
scsi_xs_get(struct scsi_link *link, int flags)
d188 4
a191 1
	struct scsi_xfer *xs;
d193 12
a204 4
	mtx_enter(&link->mtx);
	while (link->openings == 0) {
		if (ISSET(flags, SCSI_NOSLEEP)) {
			mtx_leave(&link->mtx);
a206 3

		SET(link->flags, SDEV_WAITING);
		msleep(link, &link->mtx, PRIBIO, "getxs", 0);
d208 1
a208 4
	link->openings--;
	mtx_leave(&link->mtx);

	/* pool is shared, link mtx is not */
d210 5
a214 5
	    ISSET(flags, SCSI_NOSLEEP) ? PR_NOWAIT : PR_WAITOK);
	if (xs == NULL) {
		mtx_enter(&link->mtx);
		link->openings++;
		mtx_leave(&link->mtx);
d216 2
a217 11
		xs->flags = flags;
		xs->sc_link = link;
		xs->retries = SCSI_RETRIES;
		xs->timeout = 0;
		bzero(&xs->cmdstore, sizeof(xs->cmdstore));
		xs->cmd = &xs->cmdstore;
		xs->cmdlen = 0;
		xs->data = NULL;
		xs->datalen = 0;
		xs->resid = 0;
		xs->bp = NULL;
d219 3
d232 1
a232 1
scsi_xs_put(struct scsi_xfer *xs)
d234 5
a238 1
	struct scsi_link *link = xs->sc_link;
d241 1
a241 3

	mtx_enter(&link->mtx);
	link->openings++;
d244 7
a250 3
	if (ISSET(link->flags, SDEV_WAITING)) {
		CLR(link->flags, SDEV_WAITING);
		wakeup(link);
d252 49
a300 1
	mtx_leave(&link->mtx);
d762 3
d766 84
a849 1
scsi_xs_exec(struct scsi_xfer *xs)
d851 1
a851 2
	int rv;
	int s;
d858 29
a886 12
	rv = xs->sc_link->adapter->scsi_cmd(xs);
	switch (rv) {
	case NO_CCB:
		if (!ISSET(xs->flags, SCSI_POLL) && xs->retries-- > 0) {
			timeout_set(&xs->stimeout,
			    (void (*)(void *))scsi_xs_exec, xs);
			timeout_add(&xs->stimeout, 1);
			break;
		}
		/* FALLTHROUGH */
	case TRY_AGAIN_LATER:
		/* hahaha, sif... */
d888 17
a904 1
		xs->error = XS_DRIVER_STUFFUP;
d906 3
a908 1
		scsi_done(xs);
d910 15
a924 3
		break;
	}
}
d926 2
a927 7
/*
 * This routine is called by the adapter when its xs handling is done.
 */
void
scsi_done(struct scsi_xfer *xs)
{
	splassert(IPL_BIO);
d929 3
a931 1
	xs->flags |= ITSDONE;
d933 4
a936 1
	xs->done(xs);
d946 1
a946 1
scsi_scsi_cmd(struct scsi_link *link, struct scsi_generic *scsi_cmd,
d950 5
a954 3
	struct scsi_xfer *xs;
	int error;
	int s;
d961 2
a962 2
	xs = scsi_xs_get(link, flags);
	if (xs == NULL)
d965 13
a977 6
	memcpy(xs->cmd, scsi_cmd, cmdlen);
	xs->cmdlen = cmdlen;
	xs->data = data_addr;
	xs->datalen = datalen;
	xs->retries = retries;
	xs->timeout = timeout;
d979 2
a980 1
	xs->done = scsi_xs_done;
d982 1
a982 8
	do {
		scsi_xs_exec(xs);
		if (!ISSET(xs->flags, SCSI_POLL)) {
			s = splbio();
			while (!ISSET(xs->flags, ITSDONE))
				tsleep(xs, PRIBIO, "scsicmd", 0);
			splx(s);
		}
d984 4
a987 2
		error = sc_err1(xs);
	} while (error == ERESTART);
d989 1
a989 26
	if (bp != NULL) {
		if (error) {
			bp->b_error = error;
			bp->b_flags |= B_ERROR;
			bp->b_resid = bp->b_bcount;
		} else {  
			bp->b_error = 0;
			bp->b_resid = xs->resid;
		}

		s = splbio();
		biodone(bp);
		splx(s);
	}

	if (link->device->done) {
		/*
		 * Tell the device the operation is actually complete.
		 * No more will happen with this xfer.  This for
		 * notification of the upper-level driver only; they
		 * won't be returning any meaningful information to us.
		 */
		link->device->done(xs);
	}

	scsi_xs_put(xs);
a993 7
void
scsi_xs_done(struct scsi_xfer *xs)
{
	if (!ISSET(xs->flags, SCSI_POLL))
		wakeup_one(xs);
}

d1113 4
d2009 54
@


1.136
log
@rework the scsi midlayer to start addressing some problems i have
with it which became extremely annoying with what mpath wants to
do.

the major change is a new interface for submitting scsi commands.
previously the only way for drivers like sd, cd, st, etc to push
commands onto the hardware was via scsi_scsi_cmd(). the problem
with scsi_scsi_cmd is that it doesnt tell the caller if the command
failed, was queued, or completed unless you shoved a buf down with
it. this is important for mpath which wants to know what the physical
path to the device did so it can report it back to the midlayer
which called it.

this provides a new api which lets drivers like cd/sd/st/mpath etc
allocate an xs, fill it in, and provide a completion routine which
the midlayer will call with the state of the command when it is
finished with it. the caller is then responsible for freeing the
xs.

from the hba side of thing, the return code from the scsi_cmd
entrypoint is largely ignored now, and it is now always the
responsibility of the hba driver to call scsi_done when it has
completed the io, rather than returning COMPLETE and expecting the
midlayer to do it for you.

i have emulated scsi_scsi_cmd on top of this new api so existing
users of it will continue to work. sd(4) has been reworked to use
the new api directly to both demonstrate its use and test that the
new api actually does work.

this diff was mostly written in a day at f2k9. thanks to miod for poking
through hba drivers to help mitigate against fallout from the change to
the COMPLETE semantic. this has been reviewed by krw who didnt spot
anything wrong.

thanks to dave del debbio for testing.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.134 2009/08/13 21:35:56 dlg Exp $	*/
d192 1
a192 1
		if (!ISSET(flags, SCSI_NOSLEEP)) {
@


1.135
log
@take advantage of workq_queue_task.
@
text
@a52 3
static __inline struct scsi_xfer *scsi_make_xs(struct scsi_link *,
    struct scsi_generic *, int cmdlen, u_char *data_addr,
    int datalen, int retries, int timeout, struct buf *, int flags);
d59 2
d97 1
d186 1
a186 1
scsi_get_xs(struct scsi_link *sc_link, int flags)
d188 1
a188 4
	struct scsi_xfer		*xs;
	int				s;

	SC_DEBUG(sc_link, SDEV_DB3, ("scsi_get_xs\n"));
d190 4
a193 12
	s = splbio();
	while (sc_link->openings == 0) {
		SC_DEBUG(sc_link, SDEV_DB3, ("sleeping\n"));
		if ((flags & SCSI_NOSLEEP) != 0) {
			splx(s);
			return (NULL);
		}
		sc_link->flags |= SDEV_WAITING;
		if (tsleep(sc_link, PRIBIO|PCATCH, "getxs", 0)) {
			/* Bail out on getting a signal. */
			sc_link->flags &= ~SDEV_WAITING;
			splx(s);
d196 3
d200 4
a203 1
	SC_DEBUG(sc_link, SDEV_DB3, ("calling pool_get\n"));
d205 6
a210 4
	    ((flags & SCSI_NOSLEEP) != 0 ? PR_NOWAIT : PR_WAITOK));
	if (xs != NULL) {
		bzero(xs, sizeof(*xs));
		sc_link->openings--;
d212 10
a221 3
	} else {
		sc_print_addr(sc_link);
		printf("cannot allocate scsi xs\n");
a222 3
	splx(s);

	SC_DEBUG(sc_link, SDEV_DB3, ("returning\n"));
d233 1
a233 1
scsi_free_xs(struct scsi_xfer *xs, int start)
d235 1
a235 1
	struct scsi_link *sc_link = xs->sc_link;
d237 1
a237 3
	splassert(IPL_BIO);

	SC_DEBUG(sc_link, SDEV_DB3, ("scsi_free_xs\n"));
d239 2
a240 2
	pool_put(&scsi_xfer_pool, xs);
	sc_link->openings++;
d243 3
a245 7
	if ((sc_link->flags & SDEV_WAITING) != 0) {
		sc_link->flags &= ~SDEV_WAITING;
		wakeup(sc_link);
	} else if (start && sc_link->device->start) {
		SC_DEBUG(sc_link, SDEV_DB2,
		    ("calling private start()\n"));
		(*(sc_link->device->start)) (sc_link->device_softc);
d247 1
a247 49
}

/*
 * Make a scsi_xfer, and return a pointer to it.
 */
static __inline struct scsi_xfer *
scsi_make_xs(struct scsi_link *sc_link, struct scsi_generic *scsi_cmd,
    int cmdlen, u_char *data_addr, int datalen, int retries, int timeout,
    struct buf *bp, int flags)
{
	struct scsi_xfer		*xs;

	if ((xs = scsi_get_xs(sc_link, flags)) == NULL)
		return (NULL);

	/*
	 * Fill out the scsi_xfer structure.  We don't know whose context
	 * the cmd is in, so copy it.
	 */
	xs->sc_link = sc_link;
	bcopy(scsi_cmd, &xs->cmdstore, cmdlen);
	xs->cmd = &xs->cmdstore;
	xs->cmdlen = cmdlen;
	xs->data = data_addr;
	xs->datalen = datalen;
	xs->retries = retries;
	xs->timeout = timeout;
	xs->bp = bp;

	/*
	 * Set the LUN in the CDB if it fits in the three bits available. This
	 * may only be needed if we have an older device.  However, we also set
	 * it for more modern SCSI devices "just in case".  The old code
	 * assumed everything newer than SCSI-2 would not need it, but why risk
	 * it?  This was the old conditional:
	 *
	 * if ((SCSISPC(sc_link->inqdata.version) <= 2))
	 */
	xs->cmd->bytes[0] &= ~SCSI_CMD_LUN_MASK;
	if (sc_link->lun < 8)
		xs->cmd->bytes[0] |= ((sc_link->lun << SCSI_CMD_LUN_SHIFT) &
		    SCSI_CMD_LUN_MASK);

#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		show_scsi_xs(xs);
#endif /* SCSIDEBUG */

	return (xs);
a708 3
/*
 * This routine is called by the scsi interrupt when the transfer is complete.
 */
d710 1
a710 84
scsi_done(struct scsi_xfer *xs)
{
	struct scsi_link			*sc_link = xs->sc_link;
	struct buf				*bp;
	int					error;

	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_done\n"));

	splassert(IPL_BIO);

	xs->flags |= ITSDONE;

	/*
 	 * If it's a user level request, bypass all usual completion processing,
 	 * let the user work it out.. We take reponsibility for freeing the
 	 * xs when the user returns (and restarting the device's queue).
 	 */
	if ((xs->flags & SCSI_USER) != 0) {
		SC_DEBUG(sc_link, SDEV_DB3, ("calling user done()\n"));
		scsi_user_done(xs); /* to take a copy of the sense etc. */
		SC_DEBUG(sc_link, SDEV_DB3, ("returned from user done()\n"));

		scsi_free_xs(xs, 1); /* restarts queue too */
		SC_DEBUG(sc_link, SDEV_DB3, ("returning to adapter\n"));
		return;
	}

	if (!((xs->flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP)) {
		/*
		 * if it's a normal upper level request, then ask
		 * the upper level code to handle error checking
		 * rather than doing it here at interrupt time
		 */
		wakeup(xs);
		return;
	}

	/*
	 * Go and handle errors now.
	 * If it returns ERESTART then we should RETRY
	 */
retry:
	error = sc_err1(xs);
	if (error == ERESTART) {
		switch ((*(sc_link->adapter->scsi_cmd)) (xs)) {
		case SUCCESSFULLY_QUEUED:
			return;

		case TRY_AGAIN_LATER:
			xs->error = XS_BUSY;
			/* FALLTHROUGH */
		case COMPLETE:
			goto retry;
		}
	}

	bp = xs->bp;
	if (bp != NULL) {
		if (error) {
			bp->b_error = error;
			bp->b_flags |= B_ERROR;
			bp->b_resid = bp->b_bcount;
		} else {
			bp->b_error = 0;
			bp->b_resid = xs->resid;
		}
	}

	if (sc_link->device->done) {
		/*
		 * Tell the device the operation is actually complete.
		 * No more will happen with this xfer.  This for
		 * notification of the upper-level driver only; they
		 * won't be returning any meaningful information to us.
		 */
		(*sc_link->device->done)(xs);
	}
	scsi_free_xs(xs, 1);
	if (bp != NULL)
		biodone(bp);
}

int
scsi_execute_xs(struct scsi_xfer *xs)
d712 2
a713 1
	int					error, flags, rslt, s;
d720 12
a731 29
	/*
	 * Do the transfer. If we are polling we will return:
	 * COMPLETE,  Was poll, and scsi_done has been called
	 * TRY_AGAIN_LATER, Adapter short resources, try again
	 *
	 * if under full steam (interrupts) it will return:
	 * SUCCESSFULLY_QUEUED, will do a wakeup when complete
	 * TRY_AGAIN_LATER, (as for polling)
	 * After the wakeup, we must still check if it succeeded
	 *
	 * If we have a SCSI_NOSLEEP (typically because we have a buf)
	 * we just return.  All the error processing and the buffer
	 * code both expect us to return straight to them, so as soon
	 * as the command is queued, return.
	 */

	/*
	 * We save the flags here because the xs structure may already
	 * be freed by scsi_done by the time adapter->scsi_cmd returns.
	 *
	 * scsi_done is responsible for freeing the xs if either
	 * (flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP
	 * -or-
	 * (flags & SCSI_USER) != 0
	 *
	 * Note: SCSI_USER must always be called with SCSI_NOSLEEP
	 * and never with SCSI_POLL, so the second expression should be
	 * is equivalent to the first.
	 */
d733 1
a733 17
	flags = xs->flags;
#ifdef DIAGNOSTIC
	if ((flags & (SCSI_USER | SCSI_NOSLEEP)) == SCSI_USER)
		panic("scsi_execute_xs: USER without NOSLEEP");
	if ((flags & (SCSI_USER | SCSI_POLL)) == (SCSI_USER | SCSI_POLL))
		panic("scsi_execute_xs: USER with POLL");
#endif
retry:
	rslt = (*(xs->sc_link->adapter->scsi_cmd))(xs);
	switch (rslt) {
	case SUCCESSFULLY_QUEUED:
		if ((flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP)
			return (EJUSTRETURN);
#ifdef DIAGNOSTIC
		if (flags & SCSI_NOSLEEP)
			panic("scsi_execute_xs: NOSLEEP and POLL");
#endif
d735 1
a735 3
		/* Since the xs is active we can't bail out on a signal. */
		while ((xs->flags & ITSDONE) == 0)
			tsleep(xs, PRIBIO + 1, "scsicmd", 0);
d737 3
a739 15
		/* FALLTHROUGH */
	case COMPLETE:		/* Polling command completed ok */
		if ((flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP)
			return (EJUSTRETURN);
		if (xs->bp)
			return (EJUSTRETURN);
	doit:
		SC_DEBUG(xs->sc_link, SDEV_DB3, ("back in cmd()\n"));
		if ((error = sc_err1(xs)) != ERESTART)
			return (error);
		goto retry;

	case TRY_AGAIN_LATER:	/* adapter resource shortage */
		xs->error = XS_BUSY;
		goto doit;
d741 7
a747 2
	case NO_CCB:
		return (EAGAIN);
d749 1
a749 3
	default:
		panic("scsi_execute_xs: invalid return code (%#x)", rslt);
	}
d751 1
a751 4
#ifdef DIAGNOSTIC
	panic("scsi_execute_xs: impossible");
#endif
	return (EINVAL);
d761 1
a761 1
scsi_scsi_cmd(struct scsi_link *sc_link, struct scsi_generic *scsi_cmd,
d765 3
a767 5
	struct scsi_xfer			*xs;
	int					error;
	int					s;

	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_cmd\n"));
d774 2
a775 2
	if ((xs = scsi_make_xs(sc_link, scsi_cmd, cmdlen, data_addr, datalen,
	    retries, timeout, bp, flags)) == NULL)
d778 20
a797 13
#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		if (xs->datalen && (xs->flags & SCSI_DATA_OUT))
			show_mem(xs->data, min(64, xs->datalen));
#endif	/* SCSIDEBUG */

	error = scsi_execute_xs(xs);

#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		if (xs->datalen && (xs->flags & SCSI_DATA_IN))
			show_mem(xs->data, min(64, xs->datalen));
#endif	/* SCSIDEBUG */
d799 9
a807 2
	if (error == EJUSTRETURN)
		return (0);
d809 4
a812 1
	s = splbio();
d814 9
a822 4
	if (error == EAGAIN)
		scsi_free_xs(xs, 0); /* Don't restart queue. */
	else
		scsi_free_xs(xs, 1);
d824 1
a824 1
	splx(s);
d829 7
a954 4
#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		show_mem((u_char *)&xs->sense, sizeof xs->sense);
#endif	/* SCSIDEBUG */
a1846 54

#ifdef SCSIDEBUG
/*
 * Given a scsi_xfer, dump the request, in all its glory
 */
void
show_scsi_xs(struct scsi_xfer *xs)
{
	u_char *b = (u_char *) xs->cmd;
	int i = 0;

	sc_print_addr(xs->sc_link);

	printf("xs(%p): ", xs);

	printf("flg(0x%x)", xs->flags);
	printf("sc_link(%p)", xs->sc_link);
	printf("retr(0x%x)", xs->retries);
	printf("timo(0x%x)", xs->timeout);
	printf("cmd(%p)", xs->cmd);
	printf("len(0x%x)", xs->cmdlen);
	printf("data(%p)", xs->data);
	printf("len(0x%x)", xs->datalen);
	printf("res(0x%x)", xs->resid);
	printf("err(0x%x)", xs->error);
	printf("bp(%p)\n", xs->bp);

	printf("command: ");

	if ((xs->flags & SCSI_RESET) == 0) {
		while (i < xs->cmdlen) {
			if (i)
				printf(",");
			printf("%x", b[i++]);
		}
		printf("-[%d bytes]\n", xs->datalen);
	} else
		printf("-RESET-\n");
}

void
show_mem(u_char *address, int num)
{
	int					x;

	printf("------------------------------");
	for (x = 0; x < num; x++) {
		if ((x % 16) == 0)
			printf("\n%03d: ", x);
		printf("%02x ", *address++);
	}
	printf("\n------------------------------\n");
}
#endif /* SCSIDEBUG */
@


1.134
log
@make scsi_done set ITSDONE on the xs. this means hba drivers dont have to
do it (but doesnt preclude them using it internally).

discussed with krw@@ miod@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.133 2009/08/13 19:49:31 dlg Exp $	*/
d72 4
a75 3
	int		target;
	int		lun;
	int		how;
a107 1
	int rv;
d116 1
a116 3
	rv = workq_add_task(NULL, 0, scsi_plug_probe, sc, p);
	if (rv != 0)
		pool_put(&scsi_plug_pool, p);
d118 1
a118 1
	return (rv);
a124 1
	int rv;
d134 1
a134 3
	rv = workq_add_task(NULL, 0, scsi_plug_detach, sc, p);
	if (rv != 0)
		pool_put(&scsi_plug_pool, p);
d136 1
a136 1
	return (rv);
@


1.133
log
@provide an api for an interrupt (or something like it) to notify the
midlayer that a scsi device has appeared or dissapeared. the midlayer will
queue an event and run it in the system workq (which has process context)
to handle the attach or detach.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.132 2009/06/02 06:33:04 yuo Exp $	*/
d777 2
d781 1
a781 1
	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_done\n"));
@


1.132
log
@did not issue scsi_inquire with EVPD flag for USB mass strage class
device, as some devices will be stalled by the request.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.131 2008/07/26 18:55:31 krw Exp $	*/
d69 10
d97 73
@


1.131
log
@Silence scsi_inquire_vpd() so devices that don't understand the necessary
INQUIRY options don't spam dmesg during probe. Seen by miod@@ and kettenis@@
for SCSI CD's.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.130 2008/07/05 16:07:01 krw Exp $	*/
d361 8
a368 3
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), buf, buflen, 2, 10000, NULL,
 	    SCSI_DATA_IN | SCSI_SILENT | flags);
@


1.130
log
@When SCSIDEBUG'ing, print data about to be written (for commands
flagged SCSI_DATA_OUT) and data that has been returned (for commands
flagged SCSI_DATA_IN). This is better than just printing the data
buffer before the command is issued since that does not include any
data that has been read. e.g. INQUIRY data, as thib@@ and I discovered.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.129 2008/06/22 16:32:05 krw Exp $	*/
d363 1
a363 1
 	    SCSI_DATA_IN | flags);
@


1.129
log
@Replace MUSTEK_RETRIES, SCANJET_RETRIES and ST_RETRIES with SCSI_RETRIES,
all defined to 4. Replace some magic number 4's with SCSI_RETRIES. Fix a
few lines that were now too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.128 2008/06/21 21:35:27 krw Exp $	*/
d880 15
a894 1
	if ((error = scsi_execute_xs(xs)) == EJUSTRETURN)
a1959 2
		if (xs->datalen)
			show_mem(xs->data, min(64, xs->datalen));
@


1.128
log
@Oops. Forgot to actually change the retries in scsi_size() to SCSI_RETRIES.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.127 2008/06/15 00:52:25 krw Exp $	*/
d429 1
a429 1
	    sizeof(scsi_cmd), (u_char *)data, len, 4, timeout, NULL,
d462 1
a462 1
	    sizeof(scsi_cmd), (u_char *)data, len, 4, timeout, NULL,
d619 2
a620 2
	    sizeof(scsi_cmd), (u_char *)data, scsi_cmd.length, 4, timeout, NULL,
	    flags | SCSI_DATA_OUT);
d646 1
a646 1
	    sizeof(scsi_cmd), (u_char *)data, len, 4, timeout, NULL,
d671 2
a672 2
	    sizeof(scsi_cmd), (u_char *)data, datalen, 4, timeout, NULL,
	    flags | SCSI_DATA_IN);
@


1.127
log
@Treat SENSE_NOT_READY_INIT_REQUIRED sense errors the same as
SENSE_NOT_READY_BECOMING_READY sense errors. Some devices such as USB
Zip250 drives return the former when they mean the latter. Give the
first TEST UNIT READY command three times the usual retries so more
devices have time to get ready. This allows more removable devices to
detect media details and avoid issuing 'drive offline' messages.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.126 2008/06/14 01:57:51 krw Exp $	*/
d253 1
a253 1
	    (u_char *)&rdcap, sizeof(rdcap), 2, 20000, NULL,
d278 2
a279 2
	    sizeof(rc16), (u_char *)&rdcap16, sizeof(rdcap16), 2, 20000, NULL,
	    flags | SCSI_DATA_IN);
@


1.126
log
@Nuke ADEV_NOTUR, always issue TEST UNIT READY to clear out power-up
errors before issuing INQUIRY. Fixes Sony YE-Data floppy drive and
probably other devices at the cost of possibly breaking some 10 year
old CD-ROM drives. Un-special cases mvme68k which was forcing these
initial TURs.

Now wait for the inevitable weird USB device that breaks to surface.

ok marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.125 2008/06/13 04:27:08 krw Exp $	*/
d1065 1
d1067 2
a1068 2
		    		    ("not ready: busy (%#x)\n",
				    sense->add_sense_code_qual));
@


1.125
log
@Merge show_scsi_xs() and show_scsi_cmd() and move invocation so the
debug output shows the xs/command before it's issued rather than
displaying it on command completion. Some commands don't come back
and it would be nice to see their details.

While here nuke invocations of scsi_show* in umass. If you want SCSI
debug output use SCSI debug options.

Only affects SCSI debug output.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.124 2007/11/25 22:28:53 dlg Exp $	*/
a299 3

	if (sc_link->quirks & ADEV_NOTUR)
		return (0);
@


1.124
log
@dont use the adapter_softc member of scsi_link as a softc anymore. the
"adapter_softc" is simply a way for the adapter to determine what scsibus
it is now dealing with, not a pointer back to the adapters device struct.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.123 2007/09/16 01:30:24 krw Exp $	*/
d217 5
a694 4
#ifdef	SCSIDEBUG
	if ((sc_link->flags & SDEV_DB1) != 0)
		show_scsi_cmd(xs);
#endif /* SCSIDEBUG */
d1920 5
d1926 1
d1937 1
a1937 3
	printf("bp(%p)", xs->bp);
	show_scsi_cmd(xs);
}
a1938 7
void
show_scsi_cmd(struct scsi_xfer *xs)
{
	u_char					*b = (u_char *) xs->cmd;
	int					i = 0;

	sc_print_addr(xs->sc_link);
@


1.123
log
@MALLOC/FREE -> malloc/free, M_ZERO, extraneous casts,
extraneous #include <malloc.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.122 2007/06/23 19:19:49 krw Exp $	*/
d1174 2
d1179 1
a1179 1
	    ((struct device *)sc_link->adapter_softc)->dv_xname,
@


1.122
log
@Implement disk sizes > 2^32-1. Code modelled on NetBSD.

Tested, tweaked and ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.121 2007/05/31 18:21:44 dlg Exp $	*/
a43 1
#include <sys/malloc.h>
@


1.121
log
@remove the scsi task thread, and replace it with the system workq.

"just :wq and do it" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.120 2007/04/10 17:47:56 miod Exp $	*/
d224 1
a224 1
u_long
d227 6
a232 4
	struct scsi_read_capacity	scsi_cmd;
	struct scsi_read_cap_data	rdcap;
	u_long				max_addr;
	int				error;
d240 3
a242 2
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = READ_CAPACITY;
d248 2
a249 2
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)&rdcap, sizeof(rdcap), 2, 20000, NULL,
d261 19
a279 9
	if (max_addr == 0xffffffffUL) {
		/*
		 * The device is reporting it has more than 2^32-1 sectors. The
		 * 16-byte READ CAPACITY command must be issued to get full
		 * capacity.
		 */
		sc_print_addr(sc_link);
		printf("only the first 4,294,967,295 sectors will be used.\n");
		return (0xffffffffUL);
d281 4
@


1.120
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.119 2007/04/03 04:47:59 dlg Exp $	*/
a48 2
#include <sys/kthread.h>
#include <sys/queue.h>
a53 12
struct scsi_task {
	void			(*func)(void *, void *);
	void			*sc;
	void			*arg;

	TAILQ_ENTRY(scsi_task)	entry;
};

void	scsi_create_task_thread(void *);
void	scsi_create_task(void *);
void	scsi_task_thread(void *);

d68 1
a69 3
struct pool		scsi_task_pool;
TAILQ_HEAD(, scsi_task)	scsi_task_list;
volatile int		scsi_running = 0;
a87 8

	/* Initialize the scsi_task pool. */
	pool_init(&scsi_task_pool, sizeof(struct scsi_task), 0,
	    0, 0, "sctkpl", NULL);

	/* Get the creation of the task thread underway. */
	TAILQ_INIT(&scsi_task_list);
	kthread_create_deferred(scsi_create_task_thread, NULL);
a94 58

	wakeup(&scsi_task_list);
}

void
scsi_create_task_thread(void *arg)
{
	if (kthread_create(scsi_task_thread, NULL, NULL, "scsi") != 0)
		panic("unable to create scsi task thread");
}

void
scsi_task_thread(void *arg)
{
	struct scsi_task		*task;
	int				s;

	s = splbio();
	while (scsi_running) {
		while ((task = TAILQ_FIRST(&scsi_task_list)) != NULL) {
			TAILQ_REMOVE(&scsi_task_list, task, entry);
			splx(s);

			task->func(task->sc, task->arg);

			s = splbio();
			pool_put(&scsi_task_pool, task);
		}
		tsleep(&scsi_task_list, PWAIT, "slacking", 10 * hz);
	}

	if (!TAILQ_EMPTY(&scsi_task_list))
		panic("outstanding scsi tasks");
	splx(s);

	kthread_exit(0);
}

/*
 * Must be called at splbio.
 */
int
scsi_task(void (*func)(void *, void *), void *sc, void *arg, int nosleep)
{
	struct scsi_task		*task;

	task = pool_get(&scsi_task_pool, nosleep ? PR_NOWAIT : PR_WAITOK);
	if (task == NULL)
		return (ENOMEM);

	task->func = func;
	task->sc = sc;
	task->arg = arg;

	TAILQ_INSERT_TAIL(&scsi_task_list, task, entry);
	wakeup(&scsi_task_list);

	return (0);
@


1.119
log
@add a wrapper for querying vpd inquiry pages
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.118 2007/04/03 04:15:50 dlg Exp $	*/
d1088 1
a1088 1
	 * If the device has it's own error handler, call it first.
d1978 1
a1978 1
 * Given a scsi_xfer, dump the request, in all it's glory
@


1.118
log
@modernise scsi_inquiry. the length field has grown and now theres pages to
query.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.117 2006/12/12 02:44:36 krw Exp $	*/
d405 25
@


1.117
log
@Give the SCSI layer the ability to requeue i/o's rejected by a driver
using the new NO_CCB result. Currently a no-op since no driver produces
that result.

ok dlg@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.116 2006/11/27 23:14:22 beck Exp $	*/
d381 1
d398 2
a399 1
	scsi_cmd.length = SID_INQUIRY_HDR + SID_SCSI2_ALEN;
d401 1
a401 1
	    sizeof(scsi_cmd), (u_char *)inqbuf, scsi_cmd.length, 2, 10000, NULL,
@


1.116
log
@more magic removal
ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.115 2006/11/27 18:24:43 beck Exp $	*/
d237 1
a237 1
scsi_free_xs(struct scsi_xfer *xs)
d239 1
a239 1
	struct scsi_link		*sc_link = xs->sc_link;
d246 1
d248 1
a248 2
	/* if was 0 and someone waits, wake them up */
	sc_link->openings++;
d252 4
a255 6
	} else {
		if (sc_link->device->start) {
			SC_DEBUG(sc_link, SDEV_DB2,
			    ("calling private start()\n"));
			(*(sc_link->device->start)) (sc_link->device_softc);
		}
d744 1
a744 1
		scsi_free_xs(xs); /* restarts queue too */
d789 1
d799 1
a799 1
	scsi_free_xs(xs);
d882 3
d925 6
a930 5
	/*
	 * we have finished with the xfer struct, free it and
	 * check if anyone else needs to be started up.
	 */
	scsi_free_xs(xs);
@


1.115
log
@rework asc/ascq handling to get rid of "magic" 0x values in the code, changes
asc/ascq handling to deal with the pair together rather than seperately, since
modern scsi has long since polluted the "categories" of asc enough that you
pretty much need to always look as ascq.

ok krw@@ deraadt@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.114 2006/11/04 06:03:51 dlg Exp $	*/
d1072 1
a1072 1
	if (serr != 0x70 && serr != 0x71)
d1831 2
a1832 1
	    (serr == 0x71) ? "DEFERRED " : "", serr, xs->cmd->opcode);
d1834 1
a1834 1
	if (serr != 0x70 && serr != 0x71) {
@


1.114
log
@kthread_create returns an int, not a pointer. compare the return value to
0, not NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.113 2006/09/22 00:33:41 dlg Exp $	*/
d1095 17
a1111 17
			switch (sense->add_sense_code) {
			case 0x04:	/* LUN not ready */
				switch (sense->add_sense_code_qual) {
				case 0x01: /* Becoming Ready */
				case 0x04: /* Format In Progress */
				case 0x05: /* Rebuild In Progress */
				case 0x06: /* Recalculation In Progress */
				case 0x07: /* Operation In Progress */
				case 0x08: /* Long Write In Progress */
				case 0x09: /* Self-Test In Progress */
					SC_DEBUG(sc_link, SDEV_DB1,
		    			    ("not ready: busy (%#x)\n",
					    sense->add_sense_code_qual));
					return (scsi_delay(xs, 1));
				}
				break;
			case 0x3a:	/* Medium not present */
d1115 2
d1121 21
a1141 21
		switch (sense->add_sense_code) {
			case 0x3a:	/* Medium not present */
				sc_link->flags &= ~SDEV_MEDIA_LOADED;
				error = ENOMEDIUM;
				break;
			case 0x30:	/* Medium issues */
				switch (sense->add_sense_code_qual) {
				case 0x01: /* (Read) Unknown Format */
				case 0x02: /* (Read) Incompatible Medium */
				case 0x04: /* (Write) Unknown Format */
				case 0x05: /* (Write) Incompatible Medium */
				case 0x06: /* (Format) Incompatible Medium */
				case 0x08: /* (Write/CD) Can't Write Media */
					error = EMEDIUMTYPE;
				default:
					error = EIO;
				}
				break;
			default:
				error = EIO;
				break;
d1147 2
a1148 3
		if (sense->add_sense_code == 0x53 &&
		    sense->add_sense_code_qual == 0x02)
			return(EBUSY);	/* Medium Removal Prevented */
d1152 9
a1160 1
		if (sense->add_sense_code == 0x29) /* device or bus reset */
d1162 3
d1184 2
a1185 3
		if (sense->add_sense_code == 0x52 &&
		    sense->add_sense_code_qual == 0x00)
			return(EMEDIUMTYPE);	/* Cartridge Fault */
@


1.113
log
@implement a kernel thread that can be used by the midlayer or scsi drivers
when they need a process context to do something. the most obvious task
that springs to mind is attaches and detaches of devices on scsibus.

ok krw@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.112 2006/08/04 21:35:51 beck Exp $	*/
d126 1
a126 1
	if (kthread_create(scsi_task_thread, NULL, NULL, "scsi") != NULL)
@


1.112
log
@Add ENOMEDIUM and EMEDIUMTYPE to report medium errors to userland programs
when using removable media devices, along with changes to scsi_base to
detect such cases in tapes other devices. This makes tar, dd, and friends
report a semi useful error message instead of nonsense when there is nothing
in the device.

Includes libc minor bump, and will require the corresponding sets change.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.111 2006/07/29 02:40:45 krw Exp $	*/
d49 2
d56 12
d82 4
a85 1
struct pool scsi_xfer_pool;
d93 1
a93 3
	static int			scsi_init_done;

	if (scsi_init_done)
a94 1
	scsi_init_done = 1;
d104 73
@


1.111
log
@The version field of scsi_inquiry_data is not a simple numeric value
that specifies the version of SCSI being supported. Even the ANSI part
that we use is complex. 4 means 2, 5 means 3 and 6 means 4. Translate
and use the value correctly. Fixes SCSI5 and SCSI6 in dmesg. And
properly protects SCSI2 devices from getting SCSI3 commands.

"seems like an elegant solution to me" millert@@ ok dlg@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.110 2006/07/23 14:34:55 krw Exp $	*/
d1026 1
a1026 1
				error = ENODEV;
d1031 24
d1083 6
@


1.110
log
@Use REPORT LUNS to get the list of LUNs to probe. If such a list is
obtained probe the LUNs given without checking for duplicate INQUIRY
data.

For non-USB, non-ATAPI, devices claiming to be SCSI-3 compliant. And
the target must have something attached at LUN 0.

If REPORT LUNS can't be used or isn't supported, the old scan process
is used.

Fixes Fibre Channel and SCSI enclosure devices that provide identical
INQUIRY data for all LUNs and were thus being misprobed as having
only LUN 0.

Tested by Bob Kitella, dlg@@, beck@@. Suggestions from deraadt@@.

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.109 2006/07/22 18:44:28 krw Exp $	*/
d208 1
a208 1
	 * if ((sc_link->inqdata.version & SID_ANSII) <= 2)
@


1.109
log
@If the LUN is > 7, don't try to stuff it into the three bits available
in the CDB for pre-IDENTIFY device LUNs.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.108 2006/07/15 00:04:11 beck Exp $	*/
d603 24
@


1.108
log
@catch "Media Removal Prevented" for devices that are capable of telling us
when we're not allowed to yank things out of them.  Instead of returning a
generic EIO and having the kernel printf a scsi sense to the console,
we now return EBUSY to userland and avoid the dmesg spewing.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.107 2006/07/13 11:46:16 krw Exp $	*/
d202 5
a206 5
	 * Set the LUN in the CDB.  This may only be needed if we have an
	 * older device.  However, we also set it for more modern SCSI
	 * devices "just in case".  The old code assumed everything newer
	 * than SCSI-2 would not need it, but why risk it?  This was the
	 * old conditional:
d211 3
a213 2
	xs->cmd->bytes[0] |=
	    ((sc_link->lun << SCSI_CMD_LUN_SHIFT) & SCSI_CMD_LUN_MASK);
@


1.107
log
@Eliminate scsi_link field 'scsi_version' and just use the INQUIRY data
stored in scsi_link. That's where the value came from anyway. Move 'luns'
field to where 'scsi_version' used to be to preserve alignment.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.106 2006/07/11 13:15:30 dlg Exp $	*/
d1009 3
@


1.106
log
@scsi_get_xs raises splbio, but didnt lower it on error. tsk tsk.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.105 2006/07/11 09:12:54 dlg Exp $	*/
d208 1
a208 1
	 * if ((sc_link->scsi_version & SID_ANSII) <= 2)
@


1.105
log
@knf and ansi. no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.104 2006/05/28 17:15:23 beck Exp $	*/
d122 1
d908 1
a908 1
		if (tsleep(&lbolt, PRIBIO|PCATCH, "scbusy", 0))
d911 1
@


1.104
log
@
Add PCATCH to tsleep flags when a scsi command is waiting for an opening
or is waiting to be retried, abort it when a signal interrupts the tsleep().

This fixes what was commited in version 1.92 to work properly.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.103 2006/05/13 18:11:03 krw Exp $	*/
d76 1
a76 1
	static int scsi_init_done;
d104 1
a104 3
scsi_get_xs(sc_link, flags)
	struct scsi_link *sc_link;	/* who to charge the xs to */
	int flags;			/* if this call can sleep */
d106 2
a107 2
	struct scsi_xfer *xs;
	int s;
d129 1
a129 1
		bzero(xs, sizeof *xs);
d149 1
a149 2
scsi_free_xs(xs)
	struct scsi_xfer *xs;
d151 1
a151 1
	struct scsi_link *sc_link = xs->sc_link;
d177 3
a179 11
scsi_make_xs(sc_link, scsi_cmd, cmdlen, data_addr, datalen,
    retries, timeout, bp, flags)
	struct scsi_link *sc_link;
	struct scsi_generic *scsi_cmd;
	int cmdlen;
	u_char *data_addr;
	int datalen;
	int retries;
	int timeout;
	struct buf *bp;
	int flags;
d181 1
a181 1
	struct scsi_xfer *xs;
d184 1
a184 1
		return NULL;
d213 1
a213 1
	return xs;
d220 6
a225 9
scsi_size(sc_link, flags, blksize)
	struct scsi_link *sc_link;
	int flags;
	u_int32_t *blksize;
{
	struct scsi_read_capacity scsi_cmd;
	struct scsi_read_cap_data rdcap;
	u_long max_addr;
	int error;
d227 1
a227 1
	if (blksize)
d231 1
a231 2
	 * make up a scsi command and ask the scsi driver to do
	 * it for you.
d250 1
a250 1
	if (blksize)
d271 1
a271 4
scsi_test_unit_ready(sc_link, retries, flags)
	struct scsi_link *sc_link;
	int retries;
	int flags;
d273 1
a273 1
	struct scsi_test_unit_ready scsi_cmd;
d276 1
a276 1
		return 0;
d281 2
a282 2
	return scsi_scsi_cmd(sc_link, (struct scsi_generic *) &scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, retries, 10000, NULL, flags);
d290 2
a291 4
scsi_inquire(sc_link, inqbuf, flags)
	struct scsi_link *sc_link;
	struct scsi_inquiry_data *inqbuf;
	int flags;
d293 2
a294 2
	struct scsi_inquiry scsi_cmd;
	int error;
d296 1
a296 1
	bzero(&scsi_cmd, sizeof scsi_cmd);
d299 1
a299 1
	bzero(inqbuf, sizeof *inqbuf);
d322 1
a322 3
scsi_prevent(sc_link, type, flags)
	struct scsi_link *sc_link;
	int type, flags;
d324 1
a324 1
	struct scsi_prevent scsi_cmd;
d327 1
a327 1
		return 0;
d332 3
a334 2
	return scsi_scsi_cmd(sc_link, (struct scsi_generic *) &scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, 2, 5000, NULL, flags);
d341 1
a341 3
scsi_start(sc_link, type, flags)
	struct scsi_link *sc_link;
	int type, flags;
d343 1
a343 1
	struct scsi_start_stop scsi_cmd;
d349 2
a350 1
	return scsi_scsi_cmd(sc_link, (struct scsi_generic *) &scsi_cmd,
d352 1
a352 1
	    type == SSS_START ? 30000 : 10000, NULL, flags);
d356 2
a357 5
scsi_mode_sense(sc_link, byte2, page, data, len, flags, timeout)
	struct scsi_link *sc_link;
	int byte2, page, flags, timeout;
	size_t len;
	struct scsi_mode_header *data;
d359 2
a360 2
	struct scsi_mode_sense scsi_cmd;
	int error;
d389 2
a390 5
scsi_mode_sense_big(sc_link, byte2, page, data, len, flags, timeout)
	struct scsi_link *sc_link;
	int byte2, page, flags, timeout;
	size_t len;
	struct scsi_mode_header_big *data;
d392 2
a393 2
	struct scsi_mode_sense_big scsi_cmd;
	int error;
d422 1
a422 3
scsi_mode_sense_page(hdr, page_len)
	struct scsi_mode_header *hdr;
	const int page_len;
d424 1
a424 1
	int total_length, header_length;
d436 1
a436 3
scsi_mode_sense_big_page(hdr, page_len)
	struct scsi_mode_header_big *hdr;
	const int page_len;
d438 1
a438 1
	int total_length, header_length;
d450 8
a457 12
scsi_do_mode_sense(sc_link, page, buf, page_data, density, block_count,
    block_size, page_len, flags, big)
	struct scsi_link *sc_link;
	union scsi_mode_sense_buf *buf;
	int page, page_len, flags, *big;
	u_int32_t *density, *block_size;
	u_int64_t *block_count;
	void **page_data;
{
	struct scsi_direct_blk_desc *direct;
	struct scsi_blk_desc *general;
	int error, blk_desc_len, offset;
d461 1
a461 1
	if (density)
d463 1
a463 1
	if (block_count)
d465 1
a465 1
	if (block_size)
d467 1
a467 1
	if (big)
d485 1
a485 1
			if (*page_data == NULL)
d495 1
d514 1
a514 1
	if (big)
d531 1
a531 1
		if (density)
d533 1
a533 1
		if (block_size)
d535 1
a535 1
		if (block_count)
d541 1
a541 1
		if (density)
d543 1
a543 1
		if (block_size)
d545 1
a545 1
		if (block_count)
d554 2
a555 4
scsi_mode_select(sc_link, byte2, data, flags, timeout)
	struct scsi_link *sc_link;
	int byte2, flags, timeout;
	struct scsi_mode_header *data;
d557 2
a558 2
	struct scsi_mode_select scsi_cmd;
	int error;
d578 6
a583 8
scsi_mode_select_big(sc_link, byte2, data, flags, timeout)
	struct scsi_link *sc_link;
	int byte2, flags, timeout;
	struct scsi_mode_header_big *data;
{
	struct scsi_mode_select_big scsi_cmd;
	u_int32_t len;
	int error;
d609 1
a609 2
scsi_done(xs)
	struct scsi_xfer *xs;
d611 3
a613 3
	struct scsi_link *sc_link = xs->sc_link;
	struct buf *bp;
	int error;
d626 1
a626 1
 	 * xs when the user returns. (and restarting the device's queue).
d668 1
a668 1
	if (bp) {
d688 1
a688 1
	if (bp)
d693 1
a693 2
scsi_execute_xs(xs)
	struct scsi_xfer *xs;
d695 1
a695 1
	int error, flags, rslt, s;
d744 1
a744 1
			return EJUSTRETURN;
d757 1
a757 1
			return EJUSTRETURN;
d759 1
a759 1
			return EJUSTRETURN;
d763 1
a763 1
			return error;
d777 1
a777 1
	return EINVAL;
d787 7
a793 15
scsi_scsi_cmd(sc_link, scsi_cmd, cmdlen, data_addr, datalen,
    retries, timeout, bp, flags)
	struct scsi_link *sc_link;
	struct scsi_generic *scsi_cmd;
	int cmdlen;
	u_char *data_addr;
	int datalen;
	int retries;
	int timeout;
	struct buf *bp;
	int flags;
{
	struct scsi_xfer *xs;
	int error;
	int s;
d798 1
a798 1
	if (bp != 0 && (flags & SCSI_NOSLEEP) == 0)
d804 1
a804 1
		return ENOMEM;
d807 1
a807 1
		return 0;
d816 2
a817 1
	return error;
d821 1
a821 2
sc_err1(xs)
	struct scsi_xfer *xs;
d823 1
a823 1
	int error;
d888 1
a888 1
	return error;
d892 1
a892 3
scsi_delay(xs, seconds)
	struct scsi_xfer *xs;
	int seconds;
d922 1
a922 2
scsi_interpret_sense(xs)
	struct scsi_xfer *xs;
d924 4
a927 4
	struct scsi_sense_data *sense = &xs->sense;
	struct scsi_link *sc_link = xs->sc_link;
	u_int8_t serr, skey;
	int error;
d949 2
a950 1
		SC_DEBUG(sc_link, SDEV_DB2, ("calling private err_handler()\n"));
d953 1
a953 1
			return error;		/* error >= 0  better ? */
d1006 1
a1006 1
			return 0;
d1010 1
a1010 1
		if (sense->add_sense_code == 0x29 /* device or bus reset */)
d1038 1
a1038 1
	return error;
d1050 1
a1050 2
sc_print_addr(sc_link)
	struct scsi_link *sc_link;
a1051 1

d1080 1
a1080 4
asc2ascii(asc, ascq, result, len)
	u_int8_t asc, ascq;
	char *result;
	size_t len;
d1621 1
a1621 4
asc2ascii(asc, ascq, result, len)
	u_int8_t asc, ascq;
	char *result;
	size_t len;
d1623 1
a1623 1
	int i;
d1648 1
a1648 1
	for (i = 0; adesc[i].description != NULL; i++)
d1653 1
d1661 1
a1661 2
scsi_print_sense(xs)
	struct scsi_xfer *xs;
d1663 5
a1667 4
	struct scsi_sense_data *sense = &xs->sense;
	u_int8_t serr = sense->error_code & SSD_ERRCODE;
	int32_t info;
	char *sbs;
d1731 6
a1736 8
scsi_decode_sense(sense, flag)
	struct scsi_sense_data *sense;
	int flag;
{
	static char rqsbuf[132];
	u_int16_t count;
	u_int8_t skey, spec_1;
	int len;
d1738 1
a1738 1
	bzero(rqsbuf, sizeof rqsbuf);
d1746 1
a1746 1
		strlcpy(rqsbuf, sense_keys[skey], sizeof rqsbuf);
d1750 1
a1750 1
		    rqsbuf, sizeof rqsbuf);
d1787 1
a1787 1
#ifdef	SCSIDEBUG
d1792 1
a1792 2
show_scsi_xs(xs)
	struct scsi_xfer *xs;
d1810 1
a1810 2
show_scsi_cmd(xs)
	struct scsi_xfer *xs;
d1812 2
a1813 2
	u_char *b = (u_char *) xs->cmd;
	int	i = 0;
d1832 1
a1832 3
show_mem(address, num)
	u_char *address;
	int num;
d1834 1
a1834 1
	int x;
@


1.103
log
@When SCSIDEBUG'ing, display the return value of scsi_interpret_sense()
in hex. This makes it consistant with the display of the same value in
other messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.102 2006/05/11 00:45:59 krw Exp $	*/
d121 1
a121 1
		if (tsleep(sc_link, PRIBIO, "getxs", 0)) {
d957 2
a958 2
	while (seconds-- > 0)
		if (tsleep(&lbolt, PRIBIO, "scbusy", 0))
d961 1
@


1.102
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.101 2006/05/07 20:50:21 krw Exp $	*/
d893 1
a893 1
		    ("scsi_interpret_sense returned %d\n", error));
@


1.101
log
@If a device says a MODE SENSE command worked fine, do *not* try a MODE
SENSE BIG command even if no page data was returned.  Just accept the
fact that the device does not have any such page data.

This is more in line with the spec, and unbreaks devices (like the
Neodio 8-in-1 USB Card Reader donated by Manuel Pata) which freak out
when getting a MODE SENSE BIG.

Should not break any 'working' device.

ok pedro@@ dlg@@ marco@@ 'Looks correct.' miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.100 2006/05/07 00:20:05 krw Exp $	*/
d67 1
a67 1
 
d150 1
a150 1
void 
d262 1
a262 1
	}	
d278 1
a278 1
	
d285 1
a285 1
int 
d461 1
a461 1
		
d956 1
a956 1
	
@


1.100
log
@Zap a bunch of trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.99 2006/02/06 17:37:28 jmc Exp $	*/
d519 1
a519 1
		if (error == 0 && buf->hdr.data_length > 2) {
d521 10
@


1.99
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.98 2005/11/28 16:51:29 mickey Exp $	*/
d94 1
a94 1
 * to the device that is referenced by the sc_link structure. If the 
d125 1
a125 1
		}	
d307 1
a307 1
int 
d341 1
a341 1
int 
d361 1
a361 1
int 
d399 1
a399 1
	if (len > 0xff) 
d462 1
a462 1
	return ((u_char *)hdr + header_length);	
d494 1
a494 1
	
d506 1
a506 1
	if ((sc_link->flags & SDEV_ATAPI) == 0 || 
d524 2
a525 2
		}	
	}	
d555 1
a555 1
		general = (struct scsi_blk_desc *)&buf->buf[offset];	
d637 1
a637 1
void 
d737 1
a737 1
	 * 
d742 1
a742 1
	 * 
d749 1
a749 1
	/* 
d817 1
a817 1
int 
d858 1
a858 1
int 
d939 1
a939 1
	case SCSI_NOSLEEP:	
d947 1
a947 1
	while (seconds-- > 0)	
d952 1
a952 1
	return (ERESTART);		
d961 1
a961 1
int 
d1035 1
a1035 1
				}	
d1098 1
a1098 1
	    sc_link->target, sc_link->lun);		
d1445 1
a1445 1
	/* 
d1473 1
a1473 1
	/* 
d1475 1
a1475 1
	 * 0x4D 0xNN TAGGED OVERLAPPED COMMANDS (NN = TASK TAG) 
d1644 1
a1644 1
	/* 
d1672 1
a1672 1
	
d1684 1
a1684 1
	 	    "Tagged Overlapped Commands (0x%02x = TASK TAG)", ascq); 
d1722 1
a1722 1
	if (serr != 0x70 && serr != 0x71) {	
@


1.98
log
@fix month-old breakage found by genududes (after henning's breakage)
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.97 2005/11/13 14:29:57 krw Exp $	*/
d850 1
a850 1
	 * we have finished with the xfer stuct, free it and
@


1.97
log
@ATAPI Tape drives need 6 byte MODE SENSE commands according to at
least one spec. Unlike other ATAPI devices.

Fixes PR #4611.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.96 2005/11/13 03:27:42 krw Exp $	*/
d888 1
a888 1
			if ((error = scsi_delay(xs, 1)) == EIO) ;
@


1.96
log
@Use SCSI_DELAY only once. Document it. Default to no delay.

Fixes two second system 'freeze' when umass device plugged in. Speeds
up boot by not waiting for a minimum of 2 seconds at each scsi bus.

ok jmc@@ pedro@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.95 2005/11/13 02:39:45 krw Exp $	*/
d506 2
a507 1
	if ((sc_link->flags & SDEV_ATAPI) == 0) {
d511 5
a515 3
		 * returning 6 byte data for 10 byte requests. Don't bother
		 * with SMS_DBD. Check returned data length to ensure that
		 * at least a header (3 additional bytes) is returned.
@


1.95
log
@Use scsi_delay() instead of delay() when waiting for scsi disk to
become ready. Make verbiage SC_DEBUG().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.94 2005/11/07 23:49:32 krw Exp $	*/
d81 5
@


1.94
log
@Death to superfluous verbiage. Suppress errors when getting the parameters
for a raw partition like we suppress errors for the other operations on raw
partitions. Replace 'could not get size' with more specific and informative
SC_DEBUG() output. Silences a usb card reader that fgsch@@ found. Now attach
message is only 'sdX: drive offline'.

Tested & ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.93 2005/11/02 01:36:05 krw Exp $	*/
a60 1
int	scsi_delay(struct scsi_xfer *, int);
@


1.93
log
@Abstract delay code out and call it directly from XX_interpret_sense.
Makes the logic simpler by eliminating the XS_BUSY dance in xs->error,
and will allow individual device types to delay different lengths on
certain conditions.

Allow SCSI_NOSLEEP commands to be retried without waiting. Who knows,
they may work even without a delay.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.92 2005/10/22 16:51:28 krw Exp $	*/
d235 1
d251 6
a256 5
	if (scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
			  sizeof(scsi_cmd), (u_char *)&rdcap, sizeof(rdcap),
			  2, 20000, NULL, flags | SCSI_DATA_IN) != 0) {
		sc_print_addr(sc_link);
		printf("could not get size\n");
d258 1
a258 1
	}
@


1.92
log
@When a scsi command is waiting for an opening or is waiting to be retried,
abort it when a signal interrupts the tsleep().

Suggested by deraadt@@.

"I really like this" deraadt@@ "I like this" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.91 2005/10/16 19:16:36 krw Exp $	*/
d61 1
d871 1
a871 5
		if ((error = scsi_interpret_sense(xs)) == ERESTART) {
			if (xs->error == XS_BUSY) {
				xs->error = XS_SENSE;
				goto sense_retry;
			}
a872 1
		}
a877 1
	sense_retry:
d879 1
a879 7
			if ((xs->flags & SCSI_POLL) != 0)
				delay(1000000);
			else if ((xs->flags & SCSI_NOSLEEP) == 0) {
				if (tsleep(&lbolt, PRIBIO, "scbusy", 0))
					/* Bail out on getting a signal. */
					goto lose;
			} else
d921 25
d1022 5
a1026 3
					xs->error = XS_BUSY; /* wait & retry */
					return (ERESTART);
				}
d1041 2
a1042 4
		if (sense->add_sense_code == 0x29) {
			xs->error = XS_BUSY; /* wait & retry */
			return (ERESTART); /* device or bus reset */
		}
d1048 1
a1048 2
			xs->error = XS_BUSY; /* wait & retry */
			return (ERESTART);
@


1.91
log
@Don't pound UNIT ATTENTION retries in as fast as possible. If we are
going to retry the command, pause for a second to let the condition
clear. Just as we do for certain NOT READY conditions.

Found with the help of, and fixes Ed Wandasiewicz's IBM USB Memory
key.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.90 2005/10/10 20:06:11 krw Exp $	*/
d116 5
a120 1
		(void) tsleep(sc_link, PRIBIO, "getxs", 0);
d771 1
d887 3
a889 1
				tsleep(&lbolt, PRIBIO, "scbusy", 0);
@


1.90
log
@Make some panic messages more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.89 2005/10/04 20:58:10 deraadt Exp $	*/
d1018 2
a1019 1
		if (sense->add_sense_code == 0x29)
d1021 1
d1026 4
a1029 2
		    (sc_link->flags & SDEV_REMOVABLE) == 0)
			return ERESTART;
@


1.89
log
@shorter name for wait channel
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.88 2005/09/11 17:34:27 krw Exp $	*/
d712 1
a712 3
	int error;
	int s;
	int flags;
d757 2
a758 1
	switch ((*(xs->sc_link->adapter->scsi_cmd)) (xs)) {
d787 1
a787 1
		panic("scsi_execute_xs: invalid return code");
@


1.88
log
@Simplify code by changing struct scsi_mode_sense_buf{ union {}
headers; } to just union scsi_mode_sense_buf {}. No functional change.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.87 2005/08/29 00:41:44 krw Exp $	*/
d769 1
a769 1
			tsleep(xs, PRIBIO + 1, "scsi_scsi_cmd", 0);
@


1.87
log
@If a buffer larger than the max allowed is offered to scsi_mode_sense()
or scsi_mode_sense_big(), use as much of it as is allowed. Don't justi
mask off the higher bits and possibly leave yourself with 0 space.

Fixes problem aoyama@@ found on luna88k tape drive.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.86 2005/08/01 22:42:50 krw Exp $	*/
d474 1
a474 1
	struct scsi_mode_sense_buf *buf;
d503 1
a503 1
		error = scsi_mode_sense(sc_link, 0, page, &buf->headers.hdr,
d505 2
a506 3
		if (error == 0 && buf->headers.hdr.data_length > 2) {
			*page_data = scsi_mode_sense_page(&buf->headers.hdr,
			    page_len);
d508 1
a508 1
			blk_desc_len = buf->headers.hdr.blk_desc_len;
d518 1
a518 1
	error = scsi_mode_sense_big(sc_link, 0, page, &buf->headers.hdr_big,
d522 1
a522 1
	if (_2btol(buf->headers.hdr_big.data_length) < 6)
d528 2
a529 2
	*page_data = scsi_mode_sense_big_page(&buf->headers.hdr_big, page_len);
	blk_desc_len = _2btol(buf->headers.hdr_big.blk_desc_len);
d541 1
a541 1
		general = (struct scsi_blk_desc *)&buf->headers.buf[offset];	
d551 1
a551 2
		direct = (struct scsi_direct_blk_desc *)&buf->
		    headers.buf[offset];
@


1.86
log
@Return 0 as the block size when READ_CAPACITY fails in scsi_size().
Prevents garbage being used as ssblksize in sd_get_parms(). Perhaps
another nail in the coffin for PR4313.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.85 2005/06/23 00:31:44 krw Exp $	*/
d387 4
a390 1
	scsi_cmd.length = len & 0xff;
d423 3
@


1.85
log
@Don't discard the blocksize information provided by the READ CAPACITY
command. Return it in a new parameter to scsi_size.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.84 2005/06/18 01:09:03 krw Exp $	*/
d230 3
@


1.84
log
@Shorten a couple of structure names:

scsi_mode_direct_blk_desc -> scsi_direct_blk_desc
scsi_mode_blk_desc_big -> scsi_blk_desc_big
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.83 2005/06/18 00:52:15 krw Exp $	*/
d222 1
a222 1
scsi_size(sc_link, flags)
d225 1
d251 3
@


1.83
log
@Switch to trying 6 byte MODE SENSE commands (for non ATAPI devices at
least) before 10 byte MODE SENSE. Some older devices can't/won't
distinguish between the two and return 6 byte MODE SENSE data for 10
byte requests.

Check that at least a full header was returned.

Tested by miod@@ hshoexer@@ and Ed Wandasiewisz on troublesome devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.82 2005/06/12 21:40:05 krw Exp $	*/
d467 1
a467 1
	struct scsi_mode_direct_blk_desc *direct;
d520 1
a520 1
	/* Both scsi_blk_desc and scsi_mode_direct_blk_desc are 8 bytes. */
d539 1
a539 1
		direct = (struct scsi_mode_direct_blk_desc *)&buf->
@


1.82
log
@It turns out you need to ask for 16 byte block descriptors. We don't,
so eliminate code dealing with 16 byte block descriptors. No one else
seems to use them anyway. Add define for appropriate permission bit in
case we ever need it.

Simplify and clean up scsi_do_mode_sense() code as a result.

Strengthen check to ensure block descriptor data is a valid by
checking if it is a multiple of 8 bytes rather than just > 8 bytes.

Moves code to closer to what it was before scsi_do_mode_sense().
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.81 2005/06/09 00:16:09 krw Exp $	*/
d482 19
d503 2
a504 1
	 * SMS_LLBAA.
d508 4
d513 5
a517 23
	if (error == 0 && _2btol(buf->headers.hdr_big.data_length) > 0) {
		if (big)
			*big = 1;
		offset = sizeof(struct scsi_mode_header_big);
		*page_data = scsi_mode_sense_big_page(&buf->headers.hdr_big,
		    page_len);
		blk_desc_len = _2btol(buf->headers.hdr_big.blk_desc_len);
	} else {
		/*
		 * Try 6 byte mode sense request. Don't bother with SMS_DBD.
		 */
		if (sc_link->flags & SDEV_ONLYBIG)
			return (EIO);
		error = scsi_mode_sense(sc_link, 0, page, &buf->headers.hdr,
		    sizeof(*buf), flags, 20000);
		if (error != 0)
			return (error);
		if (buf->headers.hdr.data_length == 0)
			return (EIO);
		offset = sizeof(struct scsi_mode_header);
		*page_data = scsi_mode_sense_page(&buf->headers.hdr, page_len);
		blk_desc_len = buf->headers.hdr.blk_desc_len;
	}
d519 1
@


1.81
log
@Fix typo in ASC/ASQ messages: DEnied -> Denied.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.80 2005/06/05 21:27:07 krw Exp $	*/
a466 1
	struct scsi_mode_blk_desc_big *desc_big;
a467 2
	struct scsi_mode_header_big *hdr_big;
	struct scsi_mode_header *hdr;
d469 1
a469 2
	u_char *cbuf = (u_char *)buf;
	int error, blk_desc_len;
d482 4
a485 1
	/* Try 10 byte mode sense request. Don't bother with SMS_DBD. */
d488 2
a489 2
	hdr_big = &buf->headers.hdr_big;
	if (error == 0 && _2btol(hdr_big->data_length) > 0) {
d492 19
a510 16
		cbuf += sizeof(struct scsi_mode_header_big);
		*page_data = scsi_mode_sense_big_page(hdr_big, page_len);
		blk_desc_len = _2btol(hdr_big->blk_desc_len);
		if ((hdr_big->reserved & LONGLBA) == 0)
			goto eight_byte;
		/* 16 byte block descriptors. */
		if (blk_desc_len < sizeof(struct scsi_mode_blk_desc_big))
			return (0);
		desc_big = (struct scsi_mode_blk_desc_big *)cbuf;
		if (density)
			*density = desc_big->density;
		if (block_size)
			*block_size = _4btol(desc_big->blklen);
		if (block_count)
			*block_count = _8btol(desc_big->nblocks);
		return (0);
a512 18
	if (sc_link->flags & SDEV_ONLYBIG)
		return (EIO);

	/* Try 6 byte mode sense request. Don't bother with SMS_DBD. */
	error = scsi_mode_sense(sc_link, 0, page, &buf->headers.hdr,
	    sizeof(*buf), flags, 20000);
	if (error != 0)
		return (error);

	hdr = &buf->headers.hdr;
	if (hdr->data_length == 0)
		return (EIO);
		
	cbuf += sizeof(struct scsi_mode_header);
	*page_data = scsi_mode_sense_page(hdr, page_len);
	blk_desc_len = hdr->blk_desc_len;

eight_byte:			
d514 1
a514 1
	if (blk_desc_len < sizeof(struct scsi_mode_direct_blk_desc))
d520 1
a520 2
		 * XXX What other device types will return general block
		 * descriptors other than tape drives?
d522 1
a522 1
		general = (struct scsi_blk_desc *)cbuf;	
d532 2
a533 1
		direct = (struct scsi_mode_direct_blk_desc *)cbuf;	
@


1.80
log
@Fix scsi_mode_select() and scsi_mode_select_big() to send just the
required number of bytes, rather than a full scsi_mode_sense_buf. Some
devices (e.g. my HP SureStore DAT/24) decline to accept such oversized
transfers. Instead, force callers to fill in the data_length field in
the header and use that information to set the size of the transfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.79 2005/06/04 01:25:02 krw Exp $	*/
d1260 1
a1260 1
	{ 0x20, 0x0B, "Access DEnied - ACL LUN Conflict" },
@


1.79
log
@Make scsi_do_mode_sense() aware of the difference between the 8 byte
general block descriptor and the 8 byte direct block descriptor, and
return the correct values for density, block_count and block_size
based on the type of the device.  First cut has T_SEQUENTIAL (i.e.
tape devices) as the only device type using general block descriptors,
so the behaviour change is minimal.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.78 2005/06/03 15:50:10 krw Exp $	*/
d563 1
a563 1
scsi_mode_select(sc_link, byte2, data, len, flags, timeout)
a565 1
	size_t len;
d574 1
a574 1
	scsi_cmd.length = len & 0xff;
d580 1
a580 1
	    sizeof(scsi_cmd), (u_char *)data, len, 4, timeout, NULL,
d589 1
a589 1
scsi_mode_select_big(sc_link, byte2, data, len, flags, timeout)
a591 1
	size_t len;
d595 1
d597 2
@


1.78
log
@Tweak scsi_do_mode_sense(). NetBSD was right and I was wrong. Sigh.
Add 'big' parameter to report which mode sense header type is being
returned. Eliminate icky pointer arithmetic, since it won't work if
only block descriptors are returned by the device.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.77 2005/06/02 23:49:28 krw Exp $	*/
d468 1
a468 1
	struct scsi_mode_direct_blk_desc *desc;
d471 1
d529 1
d533 25
a557 7
	desc = (struct scsi_mode_direct_blk_desc *)cbuf;	
	if (density)
		*density = desc->density;
	if (block_size)
		*block_size = _3btol(desc->blklen);
	if (block_count)
		*block_count = (u_int64_t)_4btol(desc->nblocks);
@


1.77
log
@Fix pasto - use correct pointer to extract block count from 8 byte
block descriptors. Not that we actually use this information anywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.76 2005/05/31 01:15:31 krw Exp $	*/
d459 1
a459 1
    block_size, page_len, flags)
d462 1
a462 1
	int page, page_len, flags;
d482 2
d490 2
@


1.76
log
@Remove unused sc_err1() parameter 'async'. Lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.75 2005/05/28 23:59:18 krw Exp $	*/
d533 1
a533 1
		*block_count = (u_int64_t)_4btol(desc_big->nblocks);
@


1.75
log
@Sprinkle some /* FALLTHROUGH */'s as suggested by lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.74 2005/05/28 23:45:06 krw Exp $	*/
d59 1
a59 1
int	sc_err1(struct scsi_xfer *, int);
d642 1
a642 1
	error = sc_err1(xs, 1);
d752 1
a752 1
		if ((error = sc_err1(xs, 0)) != ERESTART)
d818 1
a818 1
sc_err1(xs, async)
a819 1
	int async;
@


1.74
log
@'openings' is u_int16_t, so 'openings <= 0' is wrong. Lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.73 2005/05/28 23:32:25 krw Exp $	*/
d650 1
d744 1
d861 1
d869 1
@


1.73
log
@Forgot to specify parameter type. Lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.72 2005/05/28 23:26:09 krw Exp $	*/
d109 1
a109 1
	while (sc_link->openings <= 0) {
@


1.72
log
@snprintf returns int not size_t. Thank you lint.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.71 2005/05/28 06:16:33 krw Exp $	*/
d462 1
a462 1
	int page, page_len;
@


1.71
log
@Add _lto8b() and _8btol() to decode nblocks field of
scsi_mode_blk_desc_big. Will be needed to move st to new mode sense
function.

Be a bit more careful with types of parameters to scsi_do_mode_sense,
using u_int32_t instead of int.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.70 2005/05/25 20:52:41 krw Exp $	*/
d1723 1
a1723 1
	size_t len;
@


1.70
log
@Introduce safer, more general mode sense capability. Transparently use
both 10 byte and 6 byte MODE SENSE commands and just return error
checked values.

Convert sd_scsi.c to use new mechanism for non-optical drives. USB
umass devices will now display actual mode sense info if it is
available via a 10 byte MODE SENSE. Which may mean 0 heads, etc. is
shown until cosmetics are finalized.

ok marco@@ 'that is pretty cool' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.69 2005/05/22 01:12:47 krw Exp $	*/
d462 3
a464 1
	int page, page_len, *density, *block_count, *block_size;
a478 1
		/* XXX We don't do block_count at this time. */
d501 2
d532 2
@


1.69
log
@Check if the scsi_request has been released in the COMPLETE case as
was already done in the SUCCESSFULLY_QUEUED case. Shouldn't happen,
but better safe than sorry if some driver completes it's io
immediately.

Also don't recompute saved flags if the request is retried.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.68 2005/05/14 00:20:43 krw Exp $	*/
d423 108
@


1.68
log
@Add scsi_mode_[sense|select]_big() and use it instead of
atapi_mode_[sense|select](). This will allow the removal of
atapi_base.c and atapi_all.h files, and sets the stage for better usb
mode sense handling amoung other things.

Remove cd_scsibus_[get|set]_mode() and
sd_scsibus_mode_sense() shims in favour of scsi_mode_[sense|select]().
Add zero'ing of reserved length field in scsi_mode_select(). Change
some uchar * type parameters to scsi_mode_header *.

No functional changes. Mostly from NetBSD.

ok dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.67 2005/04/28 10:16:04 moritz Exp $	*/
a579 1
retry:
d617 1
a617 1

d631 2
@


1.67
log
@more snprintf error checking. ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.66 2005/04/17 18:55:45 tom Exp $	*/
d364 1
a364 1
	u_char *data;
d383 1
a383 1
	    sizeof(scsi_cmd), data, len, 4, timeout, NULL,
d393 33
d430 1
a430 1
	u_char *data;
d440 3
d444 1
a444 1
	    sizeof(scsi_cmd), data, len, 4, timeout, NULL,
d448 28
@


1.66
log
@Fix typo

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.64 2005/04/01 23:34:39 krw Exp $	*/
d1570 1
a1570 1
			if ((len < sizeof rqsbuf) &&
@


1.65
log
@Factor out scsi_mode_sense() and scsi_mode_select() like NetBSD does.
Eliminate some duplicate structures and defines along the way. SCSI CD
drives will now pay attention to the 'flags' parameter for MODE SENSE
and MODE SELECT commands. No other functional change.

ok tdeval@@
@
text
@d1168 1
a1168 1
	{ 0x3B, 0x0A, "Read Past Begining Of Medium" },
@


1.64
log
@Cleanup SKEY_NOT_READY logic. Only retry command if it's likely the
condition is going to clear up, which speeds up boot by avoiding
delays in disk matching. Return ENODEV if media is not present, which
avoids trying to spin up disks that are not present. Use ENODEV in
amd64/i386 dkcsum.c to filter failure reports.

Mostly from NetBSD.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.63 2005/03/24 12:52:01 krw Exp $	*/
d357 57
@


1.63
log
@If READ CAPACITY(10) says there are more than 0xffffffff sectors,
report 0xffffffff and print a message. READ CAPACITY(16) is needed to
get the actual size in this case.

ok tdeval@@ (a while ago) marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.62 2004/07/31 11:31:30 krw Exp $	*/
a722 2
		if ((sc_link->flags & SDEV_REMOVABLE) != 0)
			sc_link->flags &= ~SDEV_MEDIA_LOADED;
d724 22
a745 5
			return 0;
		if (xs->retries && sense->add_sense_code == 0x04 &&
		    sense->add_sense_code_qual == 0x01) {
			xs->error = XS_BUSY;	/* ie. sense_retry */
			return ERESTART;
a746 5
		if (xs->retries && !(sc_link->flags & SDEV_REMOVABLE)) {
			delay(1000000);
			return ERESTART;
		}
		error = EIO;
@


1.62
log
@Remove scsi_change_def() and related command structure. Its only use
in the tree is #ifdef'd out and is fundamentally wrong anyway - it
tries to force *all* devices to SCSI-2. Also recent SCSI specs seem to
have marked the command as obsolete. Bonus - eliminates another
undocumented option (SCSI_2_DEF).

Found in a list of unused kernel functions posted to tech-kern@@netbsd
by Krister Walfridsson in 2002.

ok marco@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.61 2004/05/28 23:50:14 krw Exp $	*/
d226 1
d228 1
a228 1
	struct scsi_read_capacity scsi_cmd;
d246 1
a246 1
		return 0;
d249 13
a261 1
	return _4btol(rdcap.addr) + 1;
@


1.61
log
@Clean up sense error logic and printing a bit, partly inspired by
NetBSD. Try to limit special handling of sense errors in sd and st to
a minimum.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.60 2004/05/17 23:57:51 krw Exp $	*/
a269 18
}

/*
 * Do a scsi operation, asking a device to run as SCSI-II if it can.
 */
int 
scsi_change_def(sc_link, flags)
	struct scsi_link *sc_link;
	int flags;
{
	struct scsi_changedef scsi_cmd;

	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = CHANGE_DEFINITION;
	scsi_cmd.how = SC_SCSI_2;

	return scsi_scsi_cmd(sc_link, (struct scsi_generic *) &scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, 2, 100000, NULL, flags);
@


1.60
log
@Elminate SCSIRET_* synonyms for EJUSTRETURN and ERESTART by using
EJUSTRETURN and ERESTART instead. Delete unused SCSIRET_RETRY define.
From NetBSD.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.59 2004/05/13 01:56:09 krw Exp $	*/
d706 2
a707 1
	/* otherwise use the default */
d709 4
a712 72
	skey = sense->flags & SSD_KEY;
	switch (serr) {
		/*
		 * If it's code 70, use the extended stuff and interpret the key
		 */
	case 0x71:		/* delayed error */
		sc_print_addr(sc_link);
		printf(" DEFERRED ERROR, key = 0x%x\n", skey);
		/* FALLTHROUGH */
	case 0x70:
		switch (skey) {
		case SKEY_NO_SENSE:
		case SKEY_RECOVERED_ERROR:
			if (xs->resid == xs->datalen)
				xs->resid = 0;	/* not short read */
			/* FALLTHROUGH */
		case SKEY_EQUAL:
			error = 0;
			break;
		case SKEY_NOT_READY:
			if ((sc_link->flags & SDEV_REMOVABLE) != 0)
				sc_link->flags &= ~SDEV_MEDIA_LOADED;
			if ((xs->flags & SCSI_IGNORE_NOT_READY) != 0)
				return 0;
			if (xs->retries && sense->add_sense_code == 0x04 &&
			    sense->add_sense_code_qual == 0x01) {
				xs->error = XS_BUSY;	/* ie. sense_retry */
				return ERESTART;
			}
			if (xs->retries && !(sc_link->flags & SDEV_REMOVABLE)) {
				delay(1000000);
				return ERESTART;
			}
			error = EIO;
			break;
		case SKEY_ILLEGAL_REQUEST:
			if ((xs->flags & SCSI_IGNORE_ILLEGAL_REQUEST) != 0)
				return 0;
			error = EINVAL;
			break;
		case SKEY_UNIT_ATTENTION:
			if (sense->add_sense_code == 0x29)
				return (ERESTART); /* device or bus reset */
			if ((sc_link->flags & SDEV_REMOVABLE) != 0)
				sc_link->flags &= ~SDEV_MEDIA_LOADED;
			if ((xs->flags & SCSI_IGNORE_MEDIA_CHANGE) != 0 ||
			    /* XXX Should reupload any transient state. */
			    (sc_link->flags & SDEV_REMOVABLE) == 0)
				return ERESTART;
			error = EIO;
			break;
		case SKEY_WRITE_PROTECT:
			error = EROFS;
			break;
		case SKEY_BLANK_CHECK:
			error = 0;
			break;
		case SKEY_ABORTED_COMMAND:
			error = ERESTART;
			break;
		case SKEY_VOLUME_OVERFLOW:
			error = ENOSPC;
			break;
		default:
			error = EIO;
			break;
		}

		if (skey && (xs->flags & SCSI_SILENT) == 0)
			scsi_print_sense(xs);

		return error;
d715 1
a715 1
	 * Not code 70, just report it
d717 51
d769 2
a770 10
		sc_print_addr(sc_link);
		printf("Sense Error Code %d", serr);
		if ((sense->error_code & SSD_ERRCODE_VALID) != 0) {
			struct scsi_sense_data_unextended *usense =
			    (struct scsi_sense_data_unextended *)sense;
			printf(" at block no. %d (decimal)",
			    _3btol(usense->block));
		}
		printf("\n");
		return EIO;
d772 5
d1410 1
d1417 13
a1429 1
	printf("Check Condition on opcode 0x%x\n", xs->cmd->opcode);
@


1.59
log
@More cleanup of SCSI sense printing. Better output, more readable code.

ok millert@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.58 2004/05/09 05:33:59 krw Exp $	*/
d703 1
a703 1
		if (error != SCSIRET_CONTINUE)
@


1.58
log
@Eliminate verbosity parameter to scsi_print_sense and the associated
chunk of code. It was never executed unless you were debugging a
mvmex8k 'vs' device.

ok miod@@ (mvmex8k bits) marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.57 2004/05/09 04:01:59 krw Exp $	*/
d61 1
a61 1
char   *scsi_decode_sense(void *, int);
d676 1
a676 1
	struct scsi_sense_data *sense;
d678 1
a678 2
	u_int8_t key;
	u_int32_t info;
d681 9
a689 1
	sense = &xs->sense;
d691 2
a692 22
	if ((sc_link->flags & SDEV_DB1) != 0) {
		int count;
		printf("code%x valid%x ",
		    sense->error_code & SSD_ERRCODE,
		    sense->error_code & SSD_ERRCODE_VALID ? 1 : 0);
		printf("seg%x key%x ili%x eom%x fmark%x\n",
		    sense->segment,
		    sense->flags & SSD_KEY,
		    sense->flags & SSD_ILI ? 1 : 0,
		    sense->flags & SSD_EOM ? 1 : 0,
		    sense->flags & SSD_FILEMARK ? 1 : 0);
		printf("info: %x %x %x %x followed by %d extra bytes\n",
		    sense->info[0],
		    sense->info[1],
		    sense->info[2],
		    sense->info[3],
		    sense->extra_len);
		printf("extra: ");
		for (count = 0; count < sense->extra_len; count++)
			printf("%x ", sense->cmd_spec_info[count]);
		printf("\n");
	}
d694 1
d707 3
a709 1
	switch (sense->error_code & SSD_ERRCODE) {
d715 1
a715 2
		key = sense->flags & SSD_KEY;
		printf(" DEFERRED ERROR, key = 0x%x\n", key);
d718 1
a718 7
		if ((sense->error_code & SSD_ERRCODE_VALID) != 0)
			info = _4btol(sense->info);
		else
			info = 0;
		key = sense->flags & SSD_KEY;

		switch (key) {
d723 1
d776 1
a776 1
		if (key && (xs->flags & SCSI_SILENT) == 0)
d786 1
a786 2
		printf("Sense Error Code %d",
		    sense->error_code & SSD_ERRCODE);
d1428 1
d1430 1
a1430 1
	char *sbs, *s;
d1433 2
a1434 1
	s = (char *) &xs->sense;
d1436 2
d1439 1
a1439 9
	/*
	 * Basics- print out SENSE KEY
	 */
	printf("    SENSE KEY: %s\n", scsi_decode_sense(s, DECODE_SENSE_KEY));

	/*
 	 * Print out, unqualified but aligned, FMK, EOM and ILI status.
	 */
	if (s[2] & 0xe0) {
d1443 1
a1443 1
		if (s[2] & SSD_FILEMARK) {
d1447 1
a1447 1
		if (s[2] & SSD_EOM) {
d1451 1
a1451 1
		if (s[2] & SSD_ILI)
d1455 1
d1457 2
a1458 4
	 * Now we should figure out, based upon device type, how
	 * to format the information field. Unfortunately, that's
	 * not convenient here, so we'll print it as a signed
	 * 32 bit integer.
d1460 1
a1460 1
	info = _4btol(&s[3]);
d1462 2
a1463 1
		printf("   INFO FIELD: %u\n", info);
d1465 2
a1466 4
	/*
	 * Now we check additional length to see whether there is
	 * more information to extract.
	 */
d1468 1
a1468 4
	/* enough for command specific information? */
	if (s[7] < 4)
		return;
	info = _4btol(&s[8]);
d1470 2
a1471 7
		printf(" COMMAND INFO: %d (0x%x)\n", info, info);

	/*
	 * Decode ASC && ASCQ info, plus FRU, plus the rest...
	 */

	sbs = scsi_decode_sense(s, DECODE_ASC_ASCQ);
d1474 3
a1476 3
	if (s[14] != 0)
		printf("     FRU CODE: 0x%x\n", s[14] & 0xff);
	sbs = scsi_decode_sense(s, DECODE_SKSV);
d1482 2
a1483 2
scsi_decode_sense(sinfo, flag)
	void *sinfo;
a1485 1
	struct scsi_sense_data *sense = sinfo;
@


1.57
log
@Add missing <cr>'s to various SC_DEBUG() calls, along with a few other
SC_DEBUG() spacing tweaks.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.56 2004/04/18 00:49:29 krw Exp $	*/
d793 1
a793 1
			scsi_print_sense(xs, 0);
d1442 1
a1442 1
scsi_print_sense(xs, verbosity)
a1443 1
	int verbosity;
a1445 1
	register int i, j, k;
a1509 46
	if (verbosity == 0)
		return;

	/*
	 * Now figure whether we should print any additional informtion.
	 *
	 * Where should we start from? If we had SKSV data,
	 * start from offset 18, else from offset 15.
	 *
	 * From that point until the end of the buffer, check for any
	 * nonzero data. If we have some, go back and print the lot,
	 * otherwise we're done.
	 */
	if (strlen(sbs) > 0)
		i = 18;
	else
		i = 15;

	for (j = i; j < sizeof (xs->sense); j++)
		if (s[j])
			break;
	if (j == sizeof (xs->sense))
		return;

	printf(" Additional Sense Information (byte %d out...):\n", i);
	if (i == 15) {
		printf("        %2d:", i);
		k = 7;
	} else {
		printf("        %2d:", i);
		k = 2;
		j -= 2;
	}
	while (j > 0) {
		if (i >= sizeof (xs->sense))
			break;
		if (k == 8) {
			k = 0;
			printf("\n        %2d:", i);
		}
		printf(" 0x%02x", s[i] & 0xff);
		k++;
		j--;
		i++;
	}
	printf("\n");
@


1.56
log
@Restore siop's (and possibly others) ability to negotiate tags/wide/sync by
reverting to a single (short) INQUIRY command during probe. Compensate in siop
by trying PPR on all targets on SCSI-3 buses and falling back to WDTR/SDTR if
PPR rejected.

Problem found by mickey@@. Tested on a wide variety of devices by Marco.

ok marco@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.55 2004/03/14 22:46:47 krw Exp $	*/
d391 1
a391 1
		SC_DEBUG(sc_link, SDEV_DB3, ("returned from user done()\n "));
d592 1
a592 1
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("sc_err1,err = 0x%x \n", xs->error));
@


1.55
log
@Last pre-3.5 tweak: restore bus scanning to full speed by not performing
double INQURY commands on LUNs that will be skipped anyway.

From Marco Peereboom.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.54 2004/02/21 00:47:42 krw Exp $	*/
d314 1
a314 1
	 * First try for the basic 36 bytes of SCSI2 inquiry information. This
a320 25

	/*
	 * If the device can supply more information, ask for as much
	 * as we can handle or as much as it has, whichever is less.
	 */
	if (!error && inqbuf->additional_length > SID_SCSI2_ALEN) {
		switch (inqbuf->device & SID_QUAL) {
		case SID_QUAL_RSVD:
		case SID_QUAL_BAD_LU:
		case SID_QUAL_LU_OFFLINE:
			return (0);
		case SID_QUAL_LU_OK:
			if ((inqbuf->device & SID_TYPE) == T_NODEVICE)
				return (0);
			break;
		default:
			break;
		}

		scsi_cmd.length = min(sizeof(struct scsi_inquiry_data),
		    SID_INQUIRY_HDR + inqbuf->additional_length);
		error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
		    sizeof(scsi_cmd), (u_char *)inqbuf, scsi_cmd.length, 2,
		    10000, NULL, SCSI_DATA_IN | flags);
	}
@


1.55.2.1
log
@MFC:
Fix by krw@@

Restore siop's (and possibly others) ability to negotiate tags/wide/sync by
reverting to a single (short) INQUIRY command during probe. Compensate in siop
by trying PPR on all targets on SCSI-3 buses and falling back to WDTR/SDTR if
PPR rejected.

Problem found by mickey@@. Tested on a wide variety of devices by Marco.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.55 2004/03/14 22:46:47 krw Exp $	*/
d314 1
a314 1
	 * Ask for only the basic 36 bytes of SCSI2 inquiry information. This
d321 25
@


1.54
log
@Eliminate the quirks SDEV_NOSTARTUNIT, UMASS_QUIRK_NO_START_STOP, and
UMASS_QUIRK_FORCE_SHORT_INQUIRY. Fixes a bunch of USB devices. Based
on work by Mycroft in NetBSD.

ok tdeval@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.53 2004/02/21 00:34:27 krw Exp $	*/
d327 13
@


1.53
log
@Fix a race. scsi_done() can free a scsi_xfer, so relying on the values
of fields in the scsi_xfer after scsi_done() could have been called is
bad.

cdrecord can now safely burn cd's at high speeds.

Found by grange@@, original diff by costa@@, cleaned up by grange@@ and
further polished by me following input from deraadt@@.

ok grange@@ costa@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.52 2004/02/17 23:50:46 krw Exp $	*/
d301 1
a304 1
	scsi_cmd.length = sizeof *inqbuf;
d313 7
a319 3
	return scsi_scsi_cmd(sc_link, (struct scsi_generic *) &scsi_cmd,
	    sizeof(scsi_cmd), (u_char *) inqbuf,
	    sizeof(struct scsi_inquiry_data), 2, 10000, NULL,
d321 14
a365 3

	if ((sc_link->quirks & SDEV_NOSTARTUNIT) == SDEV_NOSTARTUNIT)
		return 0;
@


1.52
log
@bzero scsi_xfer's as they come out of the pool to ensure there is no
leakage from one use to the next. There is no such thing as too much
paranoia.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.51 2004/02/07 22:39:15 krw Exp $	*/
d454 1
d477 23
d502 1
a502 1
		if ((xs->flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP)
d505 1
a505 1
		if (xs->flags & SCSI_NOSLEEP)
@


1.51
log
@If scsi_probe_bus() is called with a particular lun, ensure that lun 0
information is available to make the new lun validation logic work.
i.e. don't find phantom luns just because the user asks about them.

Also ensure the lun value given does not exceed the maximum valid lun
for a bus, rather than assuming the maximum valid lun is 7.

ok tdeval@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.50 2004/01/10 09:12:07 grange Exp $	*/
d122 1
a200 1
	xs->req_sense_length = 0;	/* XXX - not used by scsi internals */
@


1.50
log
@Print sense info only for valid key; from NetBSD.
ok tdeval@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.49 2004/01/08 17:30:52 krw Exp $	*/
d302 1
a302 1
	bzero(&scsi_cmd, sizeof(scsi_cmd));
d304 8
a311 1
	scsi_cmd.length = sizeof(struct scsi_inquiry_data);
@


1.49
log
@More sense message improvements from Marco Peereboom.

Clarify some logic and make type usage more consistant.

ok tdeval@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.48 2004/01/04 03:25:30 krw Exp $	*/
d758 1
a758 1
		if ((xs->flags & SCSI_SILENT) == 0)
@


1.48
log
@Rewrite scsi_decode_sense() to clean up code; eliminate many magic
numbers; fix passing a NULL to %s under some circumstances; fix the
bit index mask; etc.

No change in output.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.47 2004/01/02 05:46:09 krw Exp $	*/
d57 1
a57 1
static __inline void asc2ascii(u_char asc, u_char ascq, char *result,
d819 11
a829 1
#ifndef SCSITERSE
d831 1
a831 1
	u_char asc, ascq;
d1146 2
a1147 3
	 * FIXME
	 * There is a range from 0x01 to 0xFF on this message
	 * 0x40 0xNN Diagnostic Failure On Component NN (80H-FFH)
d1174 1
a1174 2
	 * FIXME
	 * There is a range from 0x00 to 0xFF on this message
d1345 2
a1346 3
	 * FIXME
	 * There is a range from 0x00 to 0xFF on this message
	 * 0x70 0xNN Decompression Exception Short Algorithm ID Of NN 
d1367 1
a1367 1
	u_char asc, ascq;
d1371 9
a1379 15
	register int i = 0;

	while (adesc[i].description != NULL) {
		if (adesc[i].asc == asc && adesc[i].ascq == ascq)
			break;
		i++;
	}
	if (adesc[i].description == NULL) {
		if (asc == 0x40 && ascq != 0) {
			(void) snprintf(result, len,
			    "Diagnostic Failure on Component 0x%02x",
			    ascq & 0xff);
		} else {
			(void) snprintf(result, len, "ASC 0x%02x ASCQ 0x%02x",
			    asc & 0xff, ascq & 0xff);
d1381 12
a1392 2
	} else {
		(void) strlcpy(result, adesc[i].description, len);
a1393 1
}
d1395 6
a1400 1
#else
d1402 2
a1403 8
static __inline void
asc2ascii(asc, ascq, result, len)
	u_char asc, ascq;
	char *result;
	size_t len;
{
	(void) snprintf(result, len, "ASC 0x%02x ASCQ 0x%02x", asc & 0xff,
	    ascq & 0xff);
@


1.47
log
@Treat all commands returning a sense data ASC of 0x29 as having
suffered a reset condition. Newer devices return a variety of ASCQ
values now (0x00 -> 0x07) rather than just 0x00. Such commands will
now be retried rather than returning EIO.

Started off when Marco Peereboom's SCSI analyzer saw some ASC/ASCQ
results of 0x29/0x02.

ok miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.46 2004/01/02 05:30:32 krw Exp $	*/
d63 5
d1414 1
a1414 1
	printf("    SENSE KEY: %s\n", scsi_decode_sense(s, 0));
d1461 2
a1462 2
	sbs = scsi_decode_sense(s, 1);
	if (sbs)
d1466 2
a1467 2
	sbs = scsi_decode_sense(s, 3);
	if (sbs)
d1482 1
a1482 1
	if (sbs)
d1522 1
a1522 1
	u_char *snsbuf, skey;
d1524 2
d1528 1
a1528 1
	skey = 0;
d1530 15
a1544 21
	snsbuf = (u_char *) sinfo;
	if (flag == 0 || flag == 2 || flag == 3) {
		skey = snsbuf[2] & 0xf;
	}
	if (flag == 0) {		/* Sense Key Only */
		(void) strlcpy(rqsbuf, sense_keys[skey], sizeof rqsbuf);
		return (rqsbuf);
	} else if (flag == 1) {		/* ASC/ASCQ Only */
		asc2ascii(snsbuf[12], snsbuf[13], rqsbuf, sizeof rqsbuf);
		return (rqsbuf);
	} else  if (flag == 2) {	/* Sense Key && ASC/ASCQ */
		len = snprintf(rqsbuf, sizeof rqsbuf, "%s, ",
		    sense_keys[skey]);
		if (len < sizeof rqsbuf)
			asc2ascii(snsbuf[12], snsbuf[13], rqsbuf + len,
			    sizeof rqsbuf - len); 	
		return (rqsbuf);
	} else if (flag == 3  && snsbuf[7] >= 9 && (snsbuf[15] & 0x80)) {
		/*
		 * SKSV Data
		 */
d1546 20
a1565 27
		case 0x5:	/* Illegal Request */
			if (snsbuf[15] & 0x8) {
				(void) snprintf(rqsbuf, sizeof rqsbuf,
				    "Error in %s, Offset %d, bit %d",
				    (snsbuf[15] & 0x40)? "CDB" : "Parameters",
				    (snsbuf[16] & 0xff) << 8 |
				    (snsbuf[17] & 0xff), snsbuf[15] & 0xf);
			} else {
				(void) snprintf(rqsbuf, sizeof rqsbuf,
				    "Error in %s, Offset %d",
				    (snsbuf[15] & 0x40)? "CDB" : "Parameters",
				    (snsbuf[16] & 0xff) << 8 |
				    (snsbuf[17] & 0xff));
			}
			return (rqsbuf);
		case 0x1:
		case 0x3:
		case 0x4:
			(void) snprintf(rqsbuf, sizeof rqsbuf,
			    "Actual Retry Count: %d",
			    (snsbuf[16] & 0xff) << 8 | (snsbuf[17] & 0xff));
			return (rqsbuf);
		case 0x2:
			(void) snprintf(rqsbuf, sizeof rqsbuf,
			    "Progress Indicator: %d",
			    (snsbuf[16] & 0xff) << 8 | (snsbuf[17] & 0xff));
			return (rqsbuf);
d1569 3
d1573 2
a1574 1
	return (NULL);
@


1.46
log
@Add in missing ASC/ASCQ descriptions for non-RAMDISK (i.e.
non-SCSITERSE) kernels. Brings the list up to SCSI-3.

From Marco Peereboom (marco at peereboom dot us).

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.45 2003/12/24 13:20:05 krw Exp $	*/
d726 1
a726 2
			if (sense->add_sense_code == 0x29 &&
			    sense->add_sense_code_qual == 0x00)
@


1.45
log
@Make error message more informative by showing bad value that caused
the error to be emitted.

ok miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.44 2003/09/26 21:43:32 miod Exp $	*/
d832 7
d849 10
d865 2
d871 1
d873 3
d879 20
d901 1
a901 1
	{ 0x11, 0x01, "Read Retried Exhausted" },
d908 1
a908 1
	{ 0x11, 0x08, "Incomplete Block Found" },
d912 8
a919 1
	{ 0x11, 0x0C, "Uncorrected Read Error - Recommend Rewrite the Data" },
d927 3
d934 4
d947 1
d952 1
a952 1
	{ 0x18, 0x04, "Recovered Data With LEC" },
d955 2
d968 1
d970 11
d983 1
d986 7
d998 11
d1010 6
d1019 7
d1029 5
d1038 8
d1047 1
d1053 8
d1066 6
d1074 4
d1080 5
a1084 1
	{ 0x3B, 0x00, "Positioning Error" },
d1099 8
a1106 1
	{ 0x3D, 0x00, "Invalid Bits In IDENTFY Message" },
d1108 4
d1116 14
d1131 5
d1143 7
a1149 1
	{ 0x48, 0x00, "INITIATOR DETECTED ERROR Message Received" },
d1153 6
d1160 5
d1170 1
d1177 6
d1186 1
a1186 1
	{ 0x5A, 0x00, "Operator Request or State Change Input (Unspecified)" },
d1197 93
d1296 1
d1298 53
@


1.44
log
@Typos: defintion -> definition, proccess -> process

There are more occurences hiding in binutils, lynx and afs but I am too
lazy to report them upstream at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.43 2003/06/26 02:00:56 krw Exp $	*/
d618 2
a619 1
		printf("unknown error category from scsi driver\n");
@


1.43
log
@Simplify code a bit by eliminating a few early returns in the sense
key case statement and let the common code after the case do the right
thing.

Return EINVAL for sense key SKEY_ILLEGAL_REQUEST whether SCSI_SILENT
is set or not.

ok tdeval@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.42 2003/05/16 19:54:05 krw Exp $	*/
d460 1
a460 1
	 * we just return.  All the error proccessing and the buffer
@


1.42
log
@Provide most if not all the support required for the usb changes Nate
is trying to bring in.

1) Change name of SDEV_NOCDB6 to SDEV_ONLYBIG to align it with the
same quirk in NetBSD, and make it more clear what it is trying to do.
i.e. force the use of READ_BIG/WRITE_BIG commands, not suppress all
use of 6 byte CDB's.

2) Check SDEV_ONLYBIG in cd.c as well as sd.c. i.e. both places where
a choice is made to use the 6 or 10 byte versions of READ/WRITE.

3) Actually make use of the ADEV_NOTUR (No TEST UNIT READY) quirk to
suppress the emission of TEST UNIT READY commands.

4) Add some explanatory comments from NetBSD to scsiconf.h so that the
use of the quirks is made clear.

ok miod@@ tdeval@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.41 2003/05/03 02:20:32 krw Exp $	*/
a716 2
			if ((xs->flags & SCSI_SILENT) != 0)
				return EIO;
a721 2
			if ((xs->flags & SCSI_SILENT) != 0)
				return EIO;
a733 2
			if ((xs->flags & SCSI_SILENT) != 0)
				return EIO;
@


1.41
log
@sprintf -> snprintf.

Almost identical to a previously submitted diff from tedu@@.

ok tedu@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.40 2003/02/20 04:02:06 krw Exp $	*/
d256 3
@


1.40
log
@Eliminate unused parameter to scsi_free_xs().

ok deraadt@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.39 2002/12/30 21:50:28 grange Exp $	*/
d57 2
a58 1
static __inline void asc2ascii(u_char asc, u_char ascq, char *result);
d1016 1
a1016 1
asc2ascii(asc, ascq, result)
d1019 1
d1030 1
a1030 1
			(void) sprintf(result,
d1034 1
a1034 1
			(void) sprintf(result, "ASC 0x%02x ASCQ 0x%02x",
d1038 1
a1038 1
		(void) strcpy(result, adesc[i].description);
d1045 1
a1045 1
asc2ascii(asc, ascq, result)
d1048 1
d1050 1
a1050 1
	(void) sprintf(result, "ASC 0x%02x ASCQ 0x%02x", asc & 0xff,
d1181 1
d1190 1
a1190 1
		(void) strcpy(rqsbuf, sense_keys[skey]);
d1193 1
a1193 1
		asc2ascii(snsbuf[12], snsbuf[13], rqsbuf);
d1196 5
a1200 2
		asc2ascii(snsbuf[12], snsbuf[13],
		    rqsbuf + sprintf(rqsbuf, "%s, ", sense_keys[skey]));
d1209 1
a1209 1
				(void) sprintf(rqsbuf,
d1215 1
a1215 1
				(void) sprintf(rqsbuf,
d1225 2
a1226 1
			(void) sprintf(rqsbuf, "Actual Retry Count: %d",
d1230 2
a1231 1
			(void) sprintf(rqsbuf, "Progress Indicator: %d",
@


1.39
log
@Add new parameter to scsi_test_unit_ready(): retries number.
Use increased retries number and don't ignore SCSI_IGNORE_NOT_READY
when call scsi_test_unit_ready() for cd-rom, this makes system wait
if drive is loading media.
Tested by millert@@ and fgsch@@; some input and ok from krw@@.
Problem reported by The lord of the CD-writers
Igor Grabin <violent@@death.kiev.ua>.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.38 2002/11/30 18:46:56 nate Exp $	*/
d135 1
a135 1
scsi_free_xs(xs, flags)
a136 1
	int flags;
d374 1
a374 1
		scsi_free_xs(xs, SCSI_NOSLEEP); /* restarts queue too */
d427 1
a427 1
	scsi_free_xs(xs, SCSI_NOSLEEP);
d537 1
a537 1
	scsi_free_xs(xs, flags);
@


1.38
log
@Actually implement the NODOORLOCK quirk
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.37 2002/09/04 23:11:10 tdeval Exp $	*/
d250 1
a250 1
scsi_test_unit_ready(sc_link, flags)
d252 1
d261 1
a261 1
	    sizeof(scsi_cmd), 0, 0, 5, 10000, NULL, flags);
@


1.37
log
@Write sentences.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.36 2002/05/22 01:04:06 art Exp $	*/
d312 3
@


1.36
log
@Eh, mark scsi_free_xs with splassert(IPL_BIO) too.
I know it's called the right way _now_, but that can change.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.35 2002/05/22 00:20:58 art Exp $	*/
d282 1
a282 1
 * Do a scsi operation asking a device what it is
@


1.35
log
@splassert(IPL_BIO) in scsi_done (its children have this assumption).
protect scsi_free_xs in scsi_scsi_cmd with splbio.
ok by deraadt@@ and krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.34 2002/04/21 10:42:40 art Exp $	*/
d140 2
@


1.34
log
@Use PR_, not M_ flags to pool_get.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.33 2002/03/14 01:27:13 millert Exp $	*/
d351 2
d511 1
d527 1
d533 1
@


1.33
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.32 2002/01/23 00:39:48 art Exp $	*/
d114 1
a114 1
	    ((flags & SCSI_NOSLEEP) != 0 ? M_NOWAIT : M_WAITOK));
@


1.32
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.31 2001/08/25 19:29:16 fgsch Exp $	*/
d54 1
a54 1
static __inline struct scsi_xfer *scsi_make_xs __P((struct scsi_link *,
d56 5
a60 5
    int datalen, int retries, int timeout, struct buf *, int flags));
static __inline void asc2ascii __P((u_char asc, u_char ascq, char *result));
int	sc_err1 __P((struct scsi_xfer *, int));
int	scsi_interpret_sense __P((struct scsi_xfer *));
char   *scsi_decode_sense __P((void *, int));
@


1.31
log
@Change scsi_[free|get]_xs to use pool(9); art@@ krw@@ miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.30 2001/08/19 15:07:34 miod Exp $	*/
d78 1
a78 1
	    0, 0, "scxspl", 0, NULL, NULL, M_DEVBUF);
@


1.31.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.32 2002/01/23 00:39:48 art Exp $	*/
d78 1
a78 1
	    0, 0, "scxspl", NULL);
@


1.31.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.31.4.1 2002/01/31 22:55:48 niklas Exp $	*/
d54 1
a54 1
static __inline struct scsi_xfer *scsi_make_xs(struct scsi_link *,
d56 5
a60 5
    int datalen, int retries, int timeout, struct buf *, int flags);
static __inline void asc2ascii(u_char asc, u_char ascq, char *result);
int	sc_err1(struct scsi_xfer *, int);
int	scsi_interpret_sense(struct scsi_xfer *);
char   *scsi_decode_sense(void *, int);
d114 1
a114 1
	    ((flags & SCSI_NOSLEEP) != 0 ? PR_NOWAIT : PR_WAITOK));
a140 2
	splassert(IPL_BIO);

a350 2
	splassert(IPL_BIO);

a508 1
	int s;
a523 1
	s = splbio();
a528 1
	splx(s);
@


1.31.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.31.4.2 2002/06/11 03:32:13 art Exp $	*/
d282 1
a282 1
 * Do a scsi operation asking a device what it is.
@


1.31.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
a57 2
static __inline void asc2ascii(u_char asc, u_char ascq, char *result,
    size_t len);
d135 1
a135 1
scsi_free_xs(xs)
d137 1
d250 1
a250 1
scsi_test_unit_ready(sc_link, retries, flags)
a251 1
	int retries;
a255 3
	if (sc_link->quirks & ADEV_NOTUR)
		return 0;

d260 1
a260 1
	    sizeof(scsi_cmd), 0, 0, retries, 10000, NULL, flags);
a312 3
	if (sc_link->quirks & ADEV_NODOORLOCK)
		return 0;

d371 1
a371 1
		scsi_free_xs(xs); /* restarts queue too */
d424 1
a424 1
	scsi_free_xs(xs);
d534 1
a534 1
	scsi_free_xs(xs);
d1012 1
a1012 1
asc2ascii(asc, ascq, result, len)
a1014 1
	size_t len;
d1025 1
a1025 1
			(void) snprintf(result, len,
d1029 1
a1029 1
			(void) snprintf(result, len, "ASC 0x%02x ASCQ 0x%02x",
d1033 1
a1033 1
		(void) strlcpy(result, adesc[i].description, len);
d1040 1
a1040 1
asc2ascii(asc, ascq, result, len)
a1042 1
	size_t len;
d1044 1
a1044 1
	(void) snprintf(result, len, "ASC 0x%02x ASCQ 0x%02x", asc & 0xff,
a1174 1
	size_t len;
d1183 1
a1183 1
		(void) strlcpy(rqsbuf, sense_keys[skey], sizeof rqsbuf);
d1186 1
a1186 1
		asc2ascii(snsbuf[12], snsbuf[13], rqsbuf, sizeof rqsbuf);
d1189 2
a1190 5
		len = snprintf(rqsbuf, sizeof rqsbuf, "%s, ",
		    sense_keys[skey]);
		if (len < sizeof rqsbuf)
			asc2ascii(snsbuf[12], snsbuf[13], rqsbuf + len,
			    sizeof rqsbuf - len); 	
d1199 1
a1199 1
				(void) snprintf(rqsbuf, sizeof rqsbuf,
d1205 1
a1205 1
				(void) snprintf(rqsbuf, sizeof rqsbuf,
d1215 1
a1215 2
			(void) snprintf(rqsbuf, sizeof rqsbuf,
			    "Actual Retry Count: %d",
d1219 1
a1219 2
			(void) snprintf(rqsbuf, sizeof rqsbuf,
			    "Progress Indicator: %d",
@


1.30
log
@More old timeouts removal, mainly affected unused/unmaintained code.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.29 2001/06/22 14:35:42 deraadt Exp $	*/
d48 1
a53 2
LIST_HEAD(xs_free_list, scsi_xfer) xs_free_list;

d58 22
a79 3
int sc_err1 __P((struct scsi_xfer *, int));
int scsi_interpret_sense __P((struct scsi_xfer *));
char *scsi_decode_sense __P((void *, int));
d101 1
d107 1
a107 1
			return 0;
d112 6
a117 4
	sc_link->openings--;
	if ((xs = xs_free_list.lh_first) != NULL) {
		LIST_REMOVE(xs, free_list);
		splx(s);
d119 2
a120 9
		splx(s);
		SC_DEBUG(sc_link, SDEV_DB3, ("making\n"));
		xs = malloc(sizeof(*xs), M_DEVBUF,
		    ((flags & SCSI_NOSLEEP) != 0 ? M_NOWAIT : M_WAITOK));
		if (!xs) {
			sc_print_addr(sc_link);
			printf("cannot allocate scsi xs\n");
			return 0;
		}
d122 1
d125 2
a126 2
	xs->flags = INUSE | flags;
	return xs;
d141 3
a143 2
	xs->flags &= ~INUSE;
	LIST_INSERT_HEAD(&xs_free_list, xs, free_list);
a144 1
	SC_DEBUG(sc_link, SDEV_DB3, ("scsi_free_xs\n"));
d152 2
a153 1
			SC_DEBUG(sc_link, SDEV_DB2, ("calling private start()\n"));
@


1.29
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.28 2001/02/18 22:38:44 fgsch Exp $	*/
a557 3
#if 0
				timeout(scsi_requeue, xs, hz);
#else
a558 1
#endif
@


1.28
log
@In scsi_print_sense, add 0x when printing the opcode to clarify it's
base 16; suggested by Quentin Barnes <qbarnes@@urbana.css.mot.com>, ok
by costa@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.27 2001/01/22 19:10:13 csapuntz Exp $	*/
d148 1
a148 1
	     retries, timeout, bp, flags)
d242 1
a242 1
			     sizeof(scsi_cmd), 0, 0, 5, 10000, NULL, flags);
d260 1
a260 1
			     sizeof(scsi_cmd), 0, 0, 2, 100000, NULL, flags);
d280 3
a282 3
			     sizeof(scsi_cmd), (u_char *) inqbuf,
			     sizeof(struct scsi_inquiry_data), 2, 10000, NULL,
			     SCSI_DATA_IN | flags);
d299 1
a299 1
			     sizeof(scsi_cmd), 0, 0, 2, 5000, NULL, flags);
d320 2
a321 2
			     sizeof(scsi_cmd), 0, 0, 2,
			     type == SSS_START ? 30000 : 10000, NULL, flags);
d581 8
a588 8
        case XS_RESET:
                if (xs->retries) {
                        SC_DEBUG(xs->sc_link, SDEV_DB3,
                            ("restarting command destroyed by reset\n"));
                        goto retry;
                }
                error = EIO;
                break;
d704 2
a705 2
                            sense->add_sense_code_qual == 0x00)
                                return (ERESTART); /* device or bus reset */
d1238 1
a1238 1
	int     i = 0;
@


1.27
log
@

Reduce # of retries on scsi_test_unit_ready to 5. This means that devices
that don't support it will only hang the system in boot-up for 50 seconds
as opposed to 500 seconds.

Return 0 from scsi_start if the device doesn't support START/STOP unit.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.26 2000/03/01 18:12:04 millert Exp $	*/
d1041 1
a1041 1
	printf("Check Condition on opcode %x\n", xs->cmd->opcode);
@


1.26
log
@Initialize xs->req_sense_length to 0.  This is not used by many
scsi drivers, other than dev/pci/ncr.c, but if req_sense_length is
not zero (either explicitly or through chance) the ncr driver will
fail during initialization.  This fixes the occasionaly ncr driver
init problems; thorpej@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.25 1999/07/25 07:09:19 csapuntz Exp $	*/
d242 1
a242 1
			     sizeof(scsi_cmd), 0, 0, 50, 10000, NULL, flags);
d311 3
@


1.25
log
@

Merge sd stuff from NetBSD-current. Helps with LS-120, ZIP

More SCSI logic from NetBSD-current

Some tape fixes. ATAPI tapes do not work yet for most operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.24 1999/04/20 19:04:34 weingart Exp $	*/
d177 1
@


1.25.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a176 1
	xs->req_sense_length = 0;	/* XXX - not used by scsi internals */
@


1.25.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.28 2001/02/18 22:38:44 fgsch Exp $	*/
d242 1
a242 1
			     sizeof(scsi_cmd), 0, 0, 5, 10000, NULL, flags);
a311 3
	if ((sc_link->quirks & SDEV_NOSTARTUNIT) == SDEV_NOSTARTUNIT)
		return 0;

d1038 1
a1038 1
	printf("Check Condition on opcode 0x%x\n", xs->cmd->opcode);
@


1.25.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.25.4.2 2001/05/14 22:44:59 niklas Exp $	*/
d148 1
a148 1
    retries, timeout, bp, flags)
d242 1
a242 1
	    sizeof(scsi_cmd), 0, 0, 5, 10000, NULL, flags);
d260 1
a260 1
	    sizeof(scsi_cmd), 0, 0, 2, 100000, NULL, flags);
d280 3
a282 3
	    sizeof(scsi_cmd), (u_char *) inqbuf,
	    sizeof(struct scsi_inquiry_data), 2, 10000, NULL,
	    SCSI_DATA_IN | flags);
d299 1
a299 1
	    sizeof(scsi_cmd), 0, 0, 2, 5000, NULL, flags);
d320 2
a321 2
	    sizeof(scsi_cmd), 0, 0, 2,
	    type == SSS_START ? 30000 : 10000, NULL, flags);
d581 8
a588 8
	case XS_RESET:
		if (xs->retries) {
			SC_DEBUG(xs->sc_link, SDEV_DB3,
			    ("restarting command destroyed by reset\n"));
			goto retry;
		}
		error = EIO;
		break;
d704 2
a705 2
			    sense->add_sense_code_qual == 0x00)
				return (ERESTART); /* device or bus reset */
d1238 1
a1238 1
	int	i = 0;
@


1.25.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.25.4.3 2001/07/04 11:00:03 niklas Exp $	*/
a47 1
#include <sys/pool.h>
d53 2
d59 3
a61 22
int	sc_err1 __P((struct scsi_xfer *, int));
int	scsi_interpret_sense __P((struct scsi_xfer *));
char   *scsi_decode_sense __P((void *, int));

struct pool scsi_xfer_pool;

/*
 * Called when a scsibus is attached to initialize global data.
 */
void
scsi_init()
{
	static int scsi_init_done;

	if (scsi_init_done)
		return;
	scsi_init_done = 1;

	/* Initialize the scsi_xfer pool. */
	pool_init(&scsi_xfer_pool, sizeof(struct scsi_xfer), 0,
	    0, 0, "scxspl", 0, NULL, NULL, M_DEVBUF);
}
a82 1

d88 1
a88 1
			return (NULL);
d93 4
a96 6
	SC_DEBUG(sc_link, SDEV_DB3, ("calling pool_get\n"));
	xs = pool_get(&scsi_xfer_pool,
	    ((flags & SCSI_NOSLEEP) != 0 ? M_NOWAIT : M_WAITOK));
	if (xs != NULL) {
		sc_link->openings--;
		xs->flags = flags;
d98 9
a106 2
		sc_print_addr(sc_link);
		printf("cannot allocate scsi xs\n");
a107 1
	splx(s);
d110 2
a111 2

	return (xs);
d126 3
a129 3

	pool_put(&scsi_xfer_pool, xs);

d137 1
a137 2
			SC_DEBUG(sc_link, SDEV_DB2,
			    ("calling private start()\n"));
d558 3
d562 1
@


1.25.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 1
a78 1
	    0, 0, "scxspl", NULL);
@


1.25.4.6
log
@Merge in -current from roughly a week ago
@
text
@d54 1
a54 1
static __inline struct scsi_xfer *scsi_make_xs(struct scsi_link *,
d56 5
a60 5
    int datalen, int retries, int timeout, struct buf *, int flags);
static __inline void asc2ascii(u_char asc, u_char ascq, char *result);
int	sc_err1(struct scsi_xfer *, int);
int	scsi_interpret_sense(struct scsi_xfer *);
char   *scsi_decode_sense(void *, int);
@


1.25.4.7
log
@Sync the SMP branch with 3.3
@
text
@d114 1
a114 1
	    ((flags & SCSI_NOSLEEP) != 0 ? PR_NOWAIT : PR_WAITOK));
d135 1
a135 1
scsi_free_xs(xs)
d137 1
a140 2
	splassert(IPL_BIO);

d248 1
a248 1
scsi_test_unit_ready(sc_link, retries, flags)
a249 1
	int retries;
d258 1
a258 1
	    sizeof(scsi_cmd), 0, 0, retries, 10000, NULL, flags);
d280 1
a280 1
 * Do a scsi operation asking a device what it is.
a310 3
	if (sc_link->quirks & ADEV_NODOORLOCK)
		return 0;

a350 2
	splassert(IPL_BIO);

d367 1
a367 1
		scsi_free_xs(xs); /* restarts queue too */
d420 1
a420 1
	scsi_free_xs(xs);
a508 1
	int s;
a523 1
	s = splbio();
d528 1
a528 2
	scsi_free_xs(xs);
	splx(s);
@


1.25.4.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.25.4.7 2003/03/28 00:08:47 niklas Exp $	*/
d57 1
a57 2
static __inline void asc2ascii(u_char asc, u_char ascq, char *result,
    size_t len);
d1015 1
a1015 1
asc2ascii(asc, ascq, result, len)
a1017 1
	size_t len;
d1028 1
a1028 1
			(void) snprintf(result, len,
d1032 1
a1032 1
			(void) snprintf(result, len, "ASC 0x%02x ASCQ 0x%02x",
d1036 1
a1036 1
		(void) strlcpy(result, adesc[i].description, len);
d1043 1
a1043 1
asc2ascii(asc, ascq, result, len)
a1045 1
	size_t len;
d1047 1
a1047 1
	(void) snprintf(result, len, "ASC 0x%02x ASCQ 0x%02x", asc & 0xff,
a1177 1
	size_t len;
d1186 1
a1186 1
		(void) strlcpy(rqsbuf, sense_keys[skey], sizeof rqsbuf);
d1189 1
a1189 1
		asc2ascii(snsbuf[12], snsbuf[13], rqsbuf, sizeof rqsbuf);
d1192 2
a1193 5
		len = snprintf(rqsbuf, sizeof rqsbuf, "%s, ",
		    sense_keys[skey]);
		if (len < sizeof rqsbuf)
			asc2ascii(snsbuf[12], snsbuf[13], rqsbuf + len,
			    sizeof rqsbuf - len); 	
d1202 1
a1202 1
				(void) snprintf(rqsbuf, sizeof rqsbuf,
d1208 1
a1208 1
				(void) snprintf(rqsbuf, sizeof rqsbuf,
d1218 1
a1218 2
			(void) snprintf(rqsbuf, sizeof rqsbuf,
			    "Actual Retry Count: %d",
d1222 1
a1222 2
			(void) snprintf(rqsbuf, sizeof rqsbuf,
			    "Progress Indicator: %d",
@


1.25.4.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.25.4.8 2003/05/13 19:36:57 ho Exp $	*/
a255 3

	if (sc_link->quirks & ADEV_NOTUR)
		return 0;
@


1.25.4.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
a57 1
static __inline void asc2ascii(u_int8_t, u_int8_t ascq, char *result,
a62 5
/* Values for flag parameter to scsi_decode_sense. */
#define	DECODE_SENSE_KEY	1
#define	DECODE_ASC_ASCQ		2
#define DECODE_SKSV		3
 
d460 1
a460 1
	 * we just return.  All the error processing and the buffer
d618 1
a618 2
		printf("unknown error category (0x%x) from scsi driver\n",
		    xs->error);
d717 2
d724 2
d729 2
a730 1
			if (sense->add_sense_code == 0x29)
d738 2
d759 1
a759 1
		if (key && (xs->flags & SCSI_SILENT) == 0)
d820 1
a820 11

#ifdef SCSITERSE
static __inline void
asc2ascii(asc, ascq, result, len)
	u_int8_t asc, ascq;
	char *result;
	size_t len;
{
	snprintf(result, len, "ASC 0x%02x ASCQ 0x%02x", asc, ascq);
}
#else
d822 1
a822 1
	u_int8_t asc, ascq;
a836 7
	{ 0x00, 0x16, "Operation In Progress" },
	{ 0x00, 0x17, "Cleaning Requested" },
	{ 0x00, 0x18, "Erase Operation In Progress" },
	{ 0x00, 0x19, "Locate Operation In Progress" },
	{ 0x00, 0x1A, "Rewind Operation In Progress" },
	{ 0x00, 0x1B, "Set Capacity Operation In Progress" },
	{ 0x00, 0x1C, "Verify Operation In Progress" },
a846 10
	{ 0x04, 0x05, "Logical Unit Not Ready, Rebuild In Progress" },
	{ 0x04, 0x06, "Logical Unit Not Ready, Recalculation In Progress" },
	{ 0x04, 0x07, "Logical Unit Not Ready, Operation In Progress" },
	{ 0x04, 0x08, "Logical Unit Not Ready, Long Write In Progress" },
	{ 0x04, 0x09, "Logical Unit Not Ready, Self-Test In Progress" },
	{ 0x04, 0x0A, "Logical Unit Not Accessible, Asymmetric Access State Transition" },
	{ 0x04, 0x0B, "Logical Unit Not Accessible, Target Port In Standby State" },
	{ 0x04, 0x0C, "Logical Unit Not Accessible, Target Port In Unavailable State" },
	{ 0x04, 0x10, "Logical Unit Not Ready, Auxiliary Memory Not Accessible" },
	{ 0x04, 0x11, "Logical Unit Not Ready, Notify (Enable Spinup) Required" },
a852 2
	{ 0x08, 0x03, "Logical Unit Communication CRC Error (ULTRA-DMA/32)" },
	{ 0x08, 0x04, "Unreachable Copy Target" },
a856 1
	{ 0x09, 0x04, "Head Select Fault" },
a857 3
	{ 0x0B, 0x00, "Warning" },
	{ 0x0B, 0x01, "Warning - Specified Temperature Exceeded" },
	{ 0x0B, 0x02, "Warning - Enclosure Degraded" },
a860 20
	{ 0x0C, 0x03, "Write Error - Recommend Reassignment" },
	{ 0x0C, 0x04, "Compression Check Miscompare Error" },
	{ 0x0C, 0x05, "Data Expansion Occurred During Compression" },
	{ 0x0C, 0x06, "Block Not Compressible" },
	{ 0x0C, 0x07, "Write Error - Recovery Needed" },
	{ 0x0C, 0x08, "Write Error - Recovery Failed" },
	{ 0x0C, 0x09, "Write Error - Loss Of Streaming" },
	{ 0x0C, 0x0A, "Write Error - Padding Blocks Added" },
	{ 0x0C, 0x0B, "Auxiliary Memory Write Error" },
	{ 0x0C, 0x0C, "Write Error - Unexpected Unsolicited Data" },
	{ 0x0C, 0x0D, "Write Error - Not Enough Unsolicited Data" },
	{ 0x0D, 0x00, "Error Detected By Third Party Temporary Initiator" },
	{ 0x0D, 0x01, "Third Party Device Failure" },
	{ 0x0D, 0x02, "Copy Target Device Not Reachable" },
	{ 0x0D, 0x03, "Incorrect Copy Target Device Type" },
	{ 0x0D, 0x04, "Copy Target Device Data Underrun" },
	{ 0x0D, 0x05, "Copy Target Device Data Overrun" },
	{ 0x0E, 0x00, "Invalid Information Unit" },
	{ 0x0E, 0x01, "Information Unit Too Short" },
	{ 0x0E, 0x02, "Information Unit Too Long" },
d863 1
a863 1
	{ 0x11, 0x01, "Read Retries Exhausted" },
d870 1
a870 1
	{ 0x11, 0x08, "Incomplete Block Read" },
d874 1
a874 8
	{ 0x11, 0x0C, "Uncorrected Read Error - Recommend Rewrite The Data" },
	{ 0x11, 0x0D, "De-Compression CRC Error" },
	{ 0x11, 0x0E, "Cannot Decompress Using Declared Algorithm" },
	{ 0x11, 0x0F, "Error Reading UPC/EAN Number" },
	{ 0x11, 0x10, "Error Reading ISRC Number" },
	{ 0x11, 0x11, "Read Error - Loss Of Streaming" },
	{ 0x11, 0x12, "Auxiliary Memory Read Error" },
	{ 0x11, 0x13, "Read Error - Failed Retransmission Request" },
a881 3
	{ 0x14, 0x05, "Record Not Found - Recommend Reassignment" },
	{ 0x14, 0x06, "Record Not Found - Data Auto-Reallocated" },
	{ 0x14, 0x07, "Locate Operation Failure" },
a885 4
	{ 0x16, 0x01, "Data Sync Error - Data Rewritten" },
	{ 0x16, 0x02, "Data Sync Error - Recommend Rewrite" },
	{ 0x16, 0x03, "Data Sync Error - Data Auto-Reallocated" },
	{ 0x16, 0x04, "Data Sync Error - Recommend Reassignment" },
a894 1
	{ 0x17, 0x09, "Recovered Data Without ECC - Data Rewritten" },
d899 1
a899 1
	{ 0x18, 0x04, "Recovered Data With L-EC" },
a901 2
	{ 0x18, 0x07, "Recovered Data With ECC - Data Rewritten" },
	{ 0x18, 0x08, "Recovered Data With Linking" },
a912 1
	{ 0x1F, 0x00, "Partial Defect List Transfer" },
a913 11
	{ 0x20, 0x01, "Access Denied - Initiator Pending-Enrolled" },
	{ 0x20, 0x02, "Access Denied - No Access rights" },
	{ 0x20, 0x03, "Access Denied - Invalid Mgmt ID Key" },
	{ 0x20, 0x04, "Illegal Command While In Write Capable State" },
	{ 0x20, 0x05, "Obsolete" },
	{ 0x20, 0x06, "Illegal Command While In Explicit Address Mode" },
	{ 0x20, 0x07, "Illegal Command While In Implicit Address Mode" },
	{ 0x20, 0x08, "Access Denied - Enrollment Conflict" },
	{ 0x20, 0x09, "Access Denied - Invalid LU Identifier" },
	{ 0x20, 0x0A, "Access Denied - Invalid Proxy Token" },
	{ 0x20, 0x0B, "Access DEnied - ACL LUN Conflict" },
a915 1
	{ 0x21, 0x02, "Invalid Address For Write" },
a917 7
	{ 0x24, 0x01, "CDB Decryption Error" },
	{ 0x24, 0x02, "Obsolete" },
	{ 0x24, 0x03, "Obsolete" },
	{ 0x24, 0x04, "Security Audit Value Frozen" },
	{ 0x24, 0x05, "Security Working Key Frozen" },
	{ 0x24, 0x06, "Nonce Not Unique" },
	{ 0x24, 0x07, "Nonce Timestamp Out Of Range" },
a922 11
	{ 0x26, 0x04, "Invalid Release Of Persistent Reservation" },
	{ 0x26, 0x05, "Data Decryption Error" },
	{ 0x26, 0x06, "Too Many Target Descriptors" },
	{ 0x26, 0x07, "Unsupported Target Descriptor Type Code" },
	{ 0x26, 0x08, "Too Many Segment Descriptors" },
	{ 0x26, 0x09, "Unsupported Segment Descriptor Type Code" },
	{ 0x26, 0x0A, "Unexpected Inexact Segment" },
	{ 0x26, 0x0B, "Inline Data Length Exceeded" },
	{ 0x26, 0x0C, "Invalid Operation For Copy Source Or Destination" },
	{ 0x26, 0x0D, "Copy Segment Granularity Violation" },
	{ 0x26, 0x0E, "Invalid Parameter While Port Is Enabled" },
a923 6
	{ 0x27, 0x01, "Hardware Write Protected" },
	{ 0x27, 0x02, "Logical Unit Software Write Protected" },
	{ 0x27, 0x03, "Associated Write Protect" },
	{ 0x27, 0x04, "Persistent Write Protect" },
	{ 0x27, 0x05, "Permanent Write Protect" },
	{ 0x27, 0x06, "Conditional Write Protect" },
a926 7
	{ 0x29, 0x01, "Power On Occurred" },
	{ 0x29, 0x02, "SCSI Bus Reset Occurred" },
	{ 0x29, 0x03, "Bus Device Reset Function Occurred" },
	{ 0x29, 0x04, "Device Internal Reset" },
	{ 0x29, 0x05, "Transceiver Mode Changed to Single Ended" },
	{ 0x29, 0x06, "Transceiver Mode Changed to LVD" },
	{ 0x29, 0x07, "I_T Nexus Loss Occurred" },
a929 5
	{ 0x2A, 0x03, "Reservations Preempted" },
	{ 0x2A, 0x04, "Reservations Released" },
	{ 0x2A, 0x05, "Registrations Preempted" },
	{ 0x2A, 0x06, "Asymmetric Access State Changed" },
	{ 0x2A, 0x07, "Implicit Asymmetric Access State Transition Failed" },
a933 8
	{ 0x2C, 0x03, "Current Program Area Is Not Empty" },
	{ 0x2C, 0x04, "Current Program Area Is Empty" },
	{ 0x2C, 0x05, "Illegal Power Condition Request" },
	{ 0x2C, 0x06, "Persistent Prevent Conflict" },
	{ 0x2C, 0x07, "Previous Busy Status" },
	{ 0x2C, 0x08, "Previous Task Set Full Status" },
	{ 0x2C, 0x09, "Previous Reservation Conflict Status" },
	{ 0x2C, 0x0A, "Partition Or Collection Contains User Objects" },
a934 1
	{ 0x2E, 0x00, "Insufficient Time For Operation" },
a939 8
	{ 0x30, 0x04, "Cannot Write Medium - Unknown Format" },
	{ 0x30, 0x05, "Cannot Write Medium - Incompatible Format" },
	{ 0x30, 0x06, "Cannot Format Medium - Incompatible Medium" },
	{ 0x30, 0x07, "Cleaning Failure" },
	{ 0x30, 0x08, "Cannot Write - Application Code Mismatch" },
	{ 0x30, 0x09, "Current Session Not Fixated For Append" },
	{ 0x30, 0x0A, "Cleaning Request Rejected" },
	{ 0x30, 0x10, "Medium Not Formatted" },
a944 6
	{ 0x34, 0x00, "Enclosure Failure" },
	{ 0x35, 0x00, "Enclosure Services Failure" },
	{ 0x35, 0x01, "Unsupported Enclosure Function" },
	{ 0x35, 0x02, "Enclosure Services Unavailable" },
	{ 0x35, 0x03, "Enclosure Services Transfer Failure" },
	{ 0x35, 0x04, "Enclosure Services Transfer Refused" },
a946 4
	{ 0x38, 0x00, "Event Status Notification" },
	{ 0x38, 0x02, "ESN - Power Management Class Event" },
	{ 0x38, 0x04, "ESN - Media Class Event" },
	{ 0x38, 0x06, "ESN - Device Busy Class Event" },
d949 1
a949 5
	{ 0x3A, 0x01, "Medium Not Present - Tray Closed" },
	{ 0x3A, 0x02, "Medium Not Present - Tray Open" },
	{ 0x3A, 0x03, "Medium Not Present - Loadable" },
	{ 0x3A, 0x04, "Medium Not Present - Medium Auxiliary Memory Accessible" },
	{ 0x3B, 0x00, "Sequential Positioning Error" },
d964 1
a964 8
	{ 0x3B, 0x0F, "End Of Medium Reached" },
	{ 0x3B, 0x11, "Medium Magazine Not Accessible" },
	{ 0x3B, 0x12, "Medium Magazine Removed" },
	{ 0x3B, 0x13, "Medium Magazine Inserted" },
	{ 0x3B, 0x14, "Medium Magazine Locked" },
	{ 0x3B, 0x15, "Medium Magazine Unlocked" },
	{ 0x3B, 0x16, "Mechanical Positioning Or Changer Error" },
	{ 0x3D, 0x00, "Invalid Bits In IDENTIFY Message" },
a965 4
	{ 0x3E, 0x01, "Logical Unit Failure" },
	{ 0x3E, 0x02, "Timeout On Logical Unit" },
	{ 0x3E, 0x03, "Logical Unit Failed Self-Test" },
	{ 0x3E, 0x04, "Logical Unit Unable To Update Self-Test Log" },
a969 14
	{ 0x3F, 0x04, "component Device Attached" },
	{ 0x3F, 0x05, "Device Identifier Changed" },
	{ 0x3F, 0x06, "Redundancy Group Created Or Modified" },
	{ 0x3F, 0x07, "Redundancy Group Deleted" },
	{ 0x3F, 0x08, "Spare Created Or Modified" },
	{ 0x3F, 0x09, "Spare Deleted" },
	{ 0x3F, 0x0A, "Volume Set Created Or Modified" },
	{ 0x3F, 0x0B, "Volume Set Deleted" },
	{ 0x3F, 0x0C, "Volume Set Deassigned" },
	{ 0x3F, 0x0D, "Volume Set Reassigned" },
	{ 0x3F, 0x0E, "Reported LUNs Data Has Changed" },
	{ 0x3F, 0x0F, "Echo Buffer Overwritten" },
	{ 0x3F, 0x10, "Medium Loadable" },
	{ 0x3F, 0x11, "Medium Auxiliary Memory Accessible" },
a970 4
	/* 
	 * ASC 0x40 also has an ASCQ range from 0x80 to 0xFF.
	 * 0x40 0xNN DIAGNOSTIC FAILURE ON COMPONENT NN
	 */
d978 1
a978 7
	{ 0x47, 0x01, "Data Phase CRC Error Detected" },
	{ 0x47, 0x02, "SCSI Parity Error Detected During ST Data Phase" },
	{ 0x47, 0x03, "Information Unit iuCRC Error Detected" },
	{ 0x47, 0x04, "Asynchronous Information Protection Error Detected" },
	{ 0x47, 0x05, "Protocol Service CRC Error" },
	{ 0x47, 0x7F, "Some Commands Cleared By iSCSI Protocol Event" },
	{ 0x48, 0x00, "Initiator Detected Error Message Received" },
a981 6
	{ 0x4B, 0x01, "Invalid Target Port Transfer Tag Received" },
	{ 0x4B, 0x02, "Too Much Write Data" },
	{ 0x4B, 0x03, "ACK/NAK Timeout" },
	{ 0x4B, 0x04, "NAK Received" },
	{ 0x4B, 0x05, "Data Offset Error" },
	{ 0x4B, 0x06, "Initiator Response Timeout" },
a982 4
	/* 
	 * ASC 0x4D has an ASCQ range from 0x00 to 0xFF.
	 * 0x4D 0xNN TAGGED OVERLAPPED COMMANDS (NN = TASK TAG) 
	 */
a987 1
	{ 0x51, 0x01, "Erase Failure - Incomplete Erase Operation Detected" },
a993 6
	{ 0x55, 0x01, "System Buffer Full" },
	{ 0x55, 0x02, "Insufficient Reservation Resources" },
	{ 0x55, 0x03, "Insufficient Resources" },
	{ 0x55, 0x04, "Insufficient Registration Resources" },
	{ 0x55, 0x05, "Insufficient Access Control Resources" },
	{ 0x55, 0x06, "Auxiliary Memory Out Of Space" },
d997 1
a997 1
	{ 0x5A, 0x00, "Operator Request or State Change Input" },
a1007 93
	{ 0x5D, 0x00, "Failure Prediction Threshold Exceeded" },
	{ 0x5D, 0x01, "Media Failure Prediction Threshold Exceeded" },
	{ 0x5D, 0x02, "Logical Unit Failure Prediction Threshold Exceeded" },
	{ 0x5D, 0x03, "Spare Area Exhaustion Prediction Threshold Exceeded" },
	{ 0x5D, 0x10, "Hardware Impending Failure General Hard Drive Failure" },
	{ 0x5D, 0x11, "Hardware Impending Failure Drive Error Rate Too High" },
	{ 0x5D, 0x12, "Hardware Impending Failure Data Error Rate Too High" },
	{ 0x5D, 0x13, "Hardware Impending Failure Seek Error Rate Too High" },
	{ 0x5D, 0x14, "Hardware Impending Failure Too Many Block Reassigns" },
	{ 0x5D, 0x15, "Hardware Impending Failure Access Times Too High" },
	{ 0x5D, 0x16, "Hardware Impending Failure Start Unit Times Too High" },
	{ 0x5D, 0x17, "Hardware Impending Failure Channel Parametrics" },
	{ 0x5D, 0x18, "Hardware Impending Failure Controller Detected" },
	{ 0x5D, 0x19, "Hardware Impending Failure Throughput Performance" },
	{ 0x5D, 0x1A, "Hardware Impending Failure Seek Time Performance" },
	{ 0x5D, 0x1B, "Hardware Impending Failure Spin-Up Retry Count" },
	{ 0x5D, 0x1C, "Hardware Impending Failure Drive Calibration Retry Count" },
	{ 0x5D, 0x20, "Controller Impending Failure General Hard Drive Failure" },
	{ 0x5D, 0x21, "Controller Impending Failure Drive Error Rate Too High" },
	{ 0x5D, 0x22, "Controller Impending Failure Data Error Rate Too High" },
	{ 0x5D, 0x23, "Controller Impending Failure Seek Error Rate Too High" },
	{ 0x5D, 0x24, "Controller Impending Failure Too Many Block Reassigns" },
	{ 0x5D, 0x25, "Controller Impending Failure Access Times Too High" },
	{ 0x5D, 0x26, "Controller Impending Failure Start Unit Times Too High" },
	{ 0x5D, 0x27, "Controller Impending Failure Channel Parametrics" },
	{ 0x5D, 0x28, "Controller Impending Failure Controller Detected" },
	{ 0x5D, 0x29, "Controller Impending Failure Throughput Performance" },
	{ 0x5D, 0x2A, "Controller Impending Failure Seek Time Performance" },
	{ 0x5D, 0x2B, "Controller Impending Failure Spin-Up Retry Count" },
	{ 0x5D, 0x2C, "Controller Impending Failure Drive Calibration Retry Count" },
	{ 0x5D, 0x30, "Data Channel Impending Failure General Hard Drive Failure" },
	{ 0x5D, 0x31, "Data Channel Impending Failure Drive Error Rate Too High" },
	{ 0x5D, 0x32, "Data Channel Impending Failure Data Error Rate Too High" },
	{ 0x5D, 0x33, "Data Channel Impending Failure Seek Error Rate Too High" },
	{ 0x5D, 0x34, "Data Channel Impending Failure Too Many Block Reassigns" },
	{ 0x5D, 0x35, "Data Channel Impending Failure Access Times Too High" },
	{ 0x5D, 0x36, "Data Channel Impending Failure Start Unit Times Too High" },
	{ 0x5D, 0x37, "Data Channel Impending Failure Channel Parametrics" },
	{ 0x5D, 0x38, "Data Channel Impending Failure Controller Detected" },
	{ 0x5D, 0x39, "Data Channel Impending Failure Throughput Performance" },
	{ 0x5D, 0x3A, "Data Channel Impending Failure Seek Time Performance" },
	{ 0x5D, 0x3B, "Data Channel Impending Failure Spin-Up Retry Count" },
	{ 0x5D, 0x3C, "Data Channel Impending Failure Drive Calibration Retry Count" },
	{ 0x5D, 0x40, "Servo Impending Failure General Hard Drive Failure" },
	{ 0x5D, 0x41, "Servo Impending Failure Drive Error Rate Too High" },
	{ 0x5D, 0x42, "Servo Impending Failure Data Error Rate Too High" },
	{ 0x5D, 0x43, "Servo Impending Failure Seek Error Rate Too High" },
	{ 0x5D, 0x44, "Servo Impending Failure Too Many Block Reassigns" },
	{ 0x5D, 0x45, "Servo Impending Failure Access Times Too High" },
	{ 0x5D, 0x46, "Servo Impending Failure Start Unit Times Too High" },
	{ 0x5D, 0x47, "Servo Impending Failure Channel Parametrics" },
	{ 0x5D, 0x48, "Servo Impending Failure Controller Detected" },
	{ 0x5D, 0x49, "Servo Impending Failure Throughput Performance" },
	{ 0x5D, 0x4A, "Servo Impending Failure Seek Time Performance" },
	{ 0x5D, 0x4B, "Servo Impending Failure Spin-Up Retry Count" },
	{ 0x5D, 0x4C, "Servo Impending Failure Drive Calibration Retry Count" },
	{ 0x5D, 0x50, "Spindle Impending Failure General Hard Drive Failure" },
	{ 0x5D, 0x51, "Spindle Impending Failure Drive Error Rate Too High" },
	{ 0x5D, 0x52, "Spindle Impending Failure Data Error Rate Too High" },
	{ 0x5D, 0x53, "Spindle Impending Failure Seek Error Rate Too High" },
	{ 0x5D, 0x54, "Spindle Impending Failure Too Many Block Reassigns" },
	{ 0x5D, 0x55, "Spindle Impending Failure Access Times Too High" },
	{ 0x5D, 0x56, "Spindle Impending Failure Start Unit Times Too High" },
	{ 0x5D, 0x57, "Spindle Impending Failure Channel Parametrics" },
	{ 0x5D, 0x58, "Spindle Impending Failure Controller Detected" },
	{ 0x5D, 0x59, "Spindle Impending Failure Throughput Performance" },
	{ 0x5D, 0x5A, "Spindle Impending Failure Seek Time Performance" },
	{ 0x5D, 0x5B, "Spindle Impending Failure Spin-Up Retry Count" },
	{ 0x5D, 0x5C, "Spindle Impending Failure Drive Calibration Retry Count" },
	{ 0x5D, 0x60, "Firmware Impending Failure General Hard Drive Failure" },
	{ 0x5D, 0x61, "Firmware Impending Failure Drive Error Rate Too High" },
	{ 0x5D, 0x62, "Firmware Impending Failure Data Error Rate Too High" },
	{ 0x5D, 0x63, "Firmware Impending Failure Seek Error Rate Too High" },
	{ 0x5D, 0x64, "Firmware Impending Failure Too Many Block Reassigns" },
	{ 0x5D, 0x65, "Firmware Impending Failure Access Times Too High" },
	{ 0x5D, 0x66, "Firmware Impending Failure Start Unit Times Too High" },
	{ 0x5D, 0x67, "Firmware Impending Failure Channel Parametrics" },
	{ 0x5D, 0x68, "Firmware Impending Failure Controller Detected" },
	{ 0x5D, 0x69, "Firmware Impending Failure Throughput Performance" },
	{ 0x5D, 0x6A, "Firmware Impending Failure Seek Time Performance" },
	{ 0x5D, 0x6B, "Firmware Impending Failure Spin-Up Retry Count" },
	{ 0x5D, 0x6C, "Firmware Impending Failure Drive Calibration Retry Count" },
	{ 0x5D, 0xFF, "Failure Prediction Threshold Exceeded (false)" },
	{ 0x5E, 0x00, "Low Power Condition On" },
	{ 0x5E, 0x01, "Idle Condition Activated By Timer" },
	{ 0x5E, 0x02, "Standby Condition Activated By Timer" },
	{ 0x5E, 0x03, "Idle Condition Activated By Command" },
	{ 0x5E, 0x04, "Standby Condition Activated By Command" },
	{ 0x5E, 0x41, "Power State Change To Active" },
	{ 0x5E, 0x42, "Power State Change To Idle" },
	{ 0x5E, 0x43, "Power State Change To Standby" },
	{ 0x5E, 0x45, "Power State Change To Sleep" },
	{ 0x5E, 0x47, "Power State Change To Device Control" },
a1013 1
	{ 0x63, 0x01, "Packet Does Not Fit In Available Space" },
a1014 52
	{ 0x64, 0x01, "Invalid Packet Size" },
	{ 0x65, 0x00, "Voltage Fault" },
	{ 0x66, 0x00, "Automatic Document Feeder Cover Up" },
	{ 0x66, 0x01, "Automatic Document Feeder Lift Up" },
	{ 0x66, 0x02, "Document Jam In Automatic Document Feeder" },
	{ 0x66, 0x03, "Document Miss Feed Automatic In Document Feeder" },
	{ 0x67, 0x00, "Configuration Failure" },
	{ 0x67, 0x01, "Configuration Of Incapable Logical Units Failed" },
	{ 0x67, 0x02, "Add Logical Unit Failed" },
	{ 0x67, 0x03, "Modification Of Logical Unit Failed" },
	{ 0x67, 0x04, "Exchange Of Logical Unit Failed" },
	{ 0x67, 0x05, "Remove Of Logical Unit Failed" },
	{ 0x67, 0x06, "Attachment Of Logical Unit Failed" },
	{ 0x67, 0x07, "Creation Of Logical Unit Failed" },
	{ 0x67, 0x08, "Assign Failure Occurred" },
	{ 0x67, 0x09, "Multiply Assigned Logical Unit" },
	{ 0x67, 0x0A, "Set Target Port Groups Command Failed" },
	{ 0x68, 0x00, "Logical Unit Not Configured" },
	{ 0x69, 0x00, "Data Loss On Logical Unit" },
	{ 0x69, 0x01, "Multiple Logical Unit Failures" },
	{ 0x69, 0x02, "Parity/Data Mismatch" },
	{ 0x6A, 0x00, "Informational, Refer To Log" },
	{ 0x6B, 0x00, "State Change Has Occurred" },
	{ 0x6B, 0x01, "Redundancy Level Got Better" },
	{ 0x6B, 0x02, "Redundancy Level Got Worse" },
	{ 0x6C, 0x00, "Rebuild Failure Occurred" },
	{ 0x6D, 0x00, "Recalculate Failure Occurred" },
	{ 0x6E, 0x00, "Command To Logical Unit Failed" },
	{ 0x6F, 0x00, "Copy Protection Key Exchange Failure - Authentication Failure" },
	{ 0x6F, 0x01, "Copy Protection Key Exchange Failure - Key Not Present" },
	{ 0x6F, 0x02, "Copy Protection Key Exchange Failure - Key Not Established" },
	{ 0x6F, 0x03, "Read Of Scrambled Sector Without Authentication" },
	{ 0x6F, 0x04, "Media Region Code Is Mismatched To Logical Unit Region" },
	{ 0x6F, 0x05, "Drive Region Must Be Permanent/Region Reset Count Error" },
	/* 
	 * ASC 0x70 has an ASCQ range from 0x00 to 0xFF.
	 * 0x70 0xNN DECOMPRESSION EXCEPTION SHORT ALGORITHM ID Of NN
	 */
	{ 0x71, 0x00, "Decompression Exception Long Algorithm ID" },
	{ 0x72, 0x00, "Session Fixation Error" },
	{ 0x72, 0x01, "Session Fixation Error Writing Lead-In" },
	{ 0x72, 0x02, "Session Fixation Error Writing Lead-Out" },
	{ 0x72, 0x03, "Session Fixation Error - Incomplete Track In Session" },
	{ 0x72, 0x04, "Empty Or Partially Written Reserved Track" },
	{ 0x72, 0x05, "No More Track Reservations Allowed" },
	{ 0x73, 0x00, "CD Control Error" },
	{ 0x73, 0x01, "Power Calibration Area Almost Full" },
	{ 0x73, 0x02, "Power Calibration Area Is Full" },
	{ 0x73, 0x03, "Power Calibration Area Error" },
	{ 0x73, 0x04, "Program Memory Area Update Failure" },
	{ 0x73, 0x05, "Program Memory Area Is Full" },
	{ 0x73, 0x06, "RMA/PMA Is Almost Full" },
d1020 1
a1020 1
	u_int8_t asc, ascq;
d1024 15
a1038 9
	int i;
	
	/* Check for a dynamically built description. */
	switch (asc) {
	case 0x40:
		if (ascq >= 0x80) {
			snprintf(result, len,
		            "Diagnostic Failure on Component 0x%02x", ascq);
			return;
d1040 2
a1041 12
		break;
	case 0x4d:
		snprintf(result, len,
	 	    "Tagged Overlapped Commands (0x%02x = TASK TAG)", ascq); 
		return;
	case 0x70:
		snprintf(result, len,
		    "Decompression Exception Short Algorithm ID OF 0x%02x",
		    ascq);
		return;
	default:
		break;
d1043 1
d1045 1
a1045 6
	/* Check for a fixed description. */
	for (i = 0; adesc[i].description != NULL; i++)
		if (adesc[i].asc == asc && adesc[i].ascq == ascq) {
			strlcpy(result, adesc[i].description, len);
			return;
		}
d1047 8
a1054 2
	/* Just print out the ASC and ASCQ values as a description. */
	snprintf(result, len, "ASC 0x%02x ASCQ 0x%02x", asc, ascq);
d1074 1
a1074 1
	printf("    SENSE KEY: %s\n", scsi_decode_sense(s, DECODE_SENSE_KEY));
d1121 2
a1122 2
	sbs = scsi_decode_sense(s, DECODE_ASC_ASCQ);
	if (strlen(sbs) > 0)
d1126 2
a1127 2
	sbs = scsi_decode_sense(s, DECODE_SKSV);
	if (strlen(sbs) > 0)
d1142 1
a1142 1
	if (strlen(sbs) > 0)
d1182 1
a1182 1
	struct scsi_sense_data *sense = sinfo;
a1183 2
	u_int16_t count;
	u_int8_t skey, spec_1;
d1186 1
a1186 1
	bzero(rqsbuf, sizeof rqsbuf);
d1188 21
a1208 15
	skey = sense->flags & SSD_KEY;
	spec_1 = sense->sense_key_spec_1;
	count = _2btol(&sense->sense_key_spec_2);

	switch (flag) {
	case DECODE_SENSE_KEY:
		strlcpy(rqsbuf, sense_keys[skey], sizeof rqsbuf);
		break;
	case DECODE_ASC_ASCQ:
		asc2ascii(sense->add_sense_code, sense->add_sense_code_qual,
		    rqsbuf, sizeof rqsbuf);
		break;
	case DECODE_SKSV:
		if (sense->extra_len < 9 || ((spec_1 & SSD_SCS_VALID) == 0))
			break;
d1210 27
a1236 20
		case SKEY_ILLEGAL_REQUEST:
			len = snprintf(rqsbuf, sizeof rqsbuf,
			    "Error in %s, Offset %d",
			    (spec_1 & SSD_SCS_CDB_ERROR) ? "CDB" : "Parameters",
			    count);
			if ((len < sizeof rqsbuf) &&
			    (spec_1 & SSD_SCS_VALID_BIT_INDEX))
				snprintf(rqsbuf+len, sizeof rqsbuf - len,
				    ", bit %d", spec_1 & SSD_SCS_BIT_INDEX);
			break;
		case SKEY_RECOVERED_ERROR:
		case SKEY_MEDIUM_ERROR:
		case SKEY_HARDWARE_ERROR:
			snprintf(rqsbuf, sizeof rqsbuf,
			    "Actual Retry Count: %d", count);
			break;
		case SKEY_NOT_READY:
			snprintf(rqsbuf, sizeof rqsbuf,
			    "Progress Indicator: %d", count);
			break;
a1239 3
		break;
	default:
		break;
d1241 1
a1241 2

	return (rqsbuf);
@


1.25.4.11
log
@Merge with the trunk
@
text
@d61 1
a61 1
char   *scsi_decode_sense(struct scsi_sense_data *, int);
a121 1
		bzero(xs, sizeof *xs);
d200 1
a300 1
	int error;
d302 1
a302 1
	bzero(&scsi_cmd, sizeof scsi_cmd);
d304 1
d306 3
a308 14
	bzero(inqbuf, sizeof *inqbuf);

	memset(&inqbuf->vendor, ' ', sizeof inqbuf->vendor);
	memset(&inqbuf->product, ' ', sizeof inqbuf->product);
	memset(&inqbuf->revision, ' ', sizeof inqbuf->revision);
	memset(&inqbuf->extra, ' ', sizeof inqbuf->extra);

	/*
	 * Ask for only the basic 36 bytes of SCSI2 inquiry information. This
	 * avoids problems with devices that choke trying to supply more.
	 */
	scsi_cmd.length = SID_INQUIRY_HDR + SID_SCSI2_ALEN;
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)inqbuf, scsi_cmd.length, 2, 10000, NULL,
a309 2

	return (error);
d342 3
d381 1
a381 1
		SC_DEBUG(sc_link, SDEV_DB3, ("returned from user done()\n"));
a446 1
	int flags;
a468 23

	/* 
	 * We save the flags here because the xs structure may already
	 * be freed by scsi_done by the time adapter->scsi_cmd returns.
	 *
	 * scsi_done is responsible for freeing the xs if either
	 * (flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP
	 * -or-
	 * (flags & SCSI_USER) != 0
	 *
	 * Note: SCSI_USER must always be called with SCSI_NOSLEEP
	 * and never with SCSI_POLL, so the second expression should be
	 * is equivalent to the first.
	 */

	flags = xs->flags;
#ifdef DIAGNOSTIC
	if ((flags & (SCSI_USER | SCSI_NOSLEEP)) == SCSI_USER)
		panic("scsi_execute_xs: USER without NOSLEEP");
	if ((flags & (SCSI_USER | SCSI_POLL)) == (SCSI_USER | SCSI_POLL))
		panic("scsi_execute_xs: USER with POLL");
#endif

d471 1
a471 1
		if ((flags & (SCSI_NOSLEEP | SCSI_POLL)) == SCSI_NOSLEEP)
d474 1
a474 1
		if (flags & SCSI_NOSLEEP)
d558 1
a558 1
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("sc_err1,err = 0x%x\n", xs->error));
d642 1
a642 1
	struct scsi_sense_data *sense = &xs->sense;
d644 2
a645 1
	u_int8_t serr, skey;
d648 1
a648 9
	SC_DEBUG(sc_link, SDEV_DB1,
	    ("code:%#x valid:%d key:%#x ili:%d eom:%d fmark:%d extra:%d\n",
	    sense->error_code & SSD_ERRCODE,
	    sense->error_code & SSD_ERRCODE_VALID ? 1 : 0,
	    sense->flags & SSD_KEY,
	    sense->flags & SSD_ILI ? 1 : 0,
	    sense->flags & SSD_EOM ? 1 : 0,
	    sense->flags & SSD_FILEMARK ? 1 : 0,
	    sense->extra_len));
d650 22
a671 2
	if ((sc_link->flags & SDEV_DB1) != 0)
		show_mem((u_char *)&xs->sense, sizeof xs->sense);
a672 1

d681 1
a681 1
		if (error != EJUSTRETURN)
d684 76
d761 1
a761 6
	/* Default sense interpretation. */
	serr = sense->error_code & SSD_ERRCODE;
	if (serr != 0x70 && serr != 0x71)
		skey = 0xff;	/* Invalid value, since key is 4 bit value. */
	else
		skey = sense->flags & SSD_KEY;
d764 1
a764 1
	 * Interpret the key/asc/ascq information where appropriate.
d766 9
a774 19
	error = 0;
	switch (skey) {
	case SKEY_NO_SENSE:
	case SKEY_RECOVERED_ERROR:
		if (xs->resid == xs->datalen)
			xs->resid = 0;	/* not short read */
		break;
	case SKEY_BLANK_CHECK:
	case SKEY_EQUAL:
		break;
	case SKEY_NOT_READY:
		if ((sc_link->flags & SDEV_REMOVABLE) != 0)
			sc_link->flags &= ~SDEV_MEDIA_LOADED;
		if ((xs->flags & SCSI_IGNORE_NOT_READY) != 0)
			return 0;
		if (xs->retries && sense->add_sense_code == 0x04 &&
		    sense->add_sense_code_qual == 0x01) {
			xs->error = XS_BUSY;	/* ie. sense_retry */
			return ERESTART;
d776 2
a777 34
		if (xs->retries && !(sc_link->flags & SDEV_REMOVABLE)) {
			delay(1000000);
			return ERESTART;
		}
		error = EIO;
		break;
	case SKEY_ILLEGAL_REQUEST:
		if ((xs->flags & SCSI_IGNORE_ILLEGAL_REQUEST) != 0)
			return 0;
		error = EINVAL;
		break;
	case SKEY_UNIT_ATTENTION:
		if (sense->add_sense_code == 0x29)
			return (ERESTART); /* device or bus reset */
		if ((sc_link->flags & SDEV_REMOVABLE) != 0)
			sc_link->flags &= ~SDEV_MEDIA_LOADED;
		if ((xs->flags & SCSI_IGNORE_MEDIA_CHANGE) != 0 ||
		    /* XXX Should reupload any transient state. */
		    (sc_link->flags & SDEV_REMOVABLE) == 0)
			return ERESTART;
		error = EIO;
		break;
	case SKEY_WRITE_PROTECT:
		error = EROFS;
		break;
	case SKEY_ABORTED_COMMAND:
		error = ERESTART;
		break;
	case SKEY_VOLUME_OVERFLOW:
		error = ENOSPC;
		break;
	default:
		error = EIO;
		break;
a778 5

	if (skey && (xs->flags & SCSI_SILENT) == 0)
		scsi_print_sense(xs);

	return error;
d1408 1
a1408 1
scsi_print_sense(xs)
d1410 1
a1411 2
	struct scsi_sense_data *sense = &xs->sense;
	u_int8_t serr = sense->error_code & SSD_ERRCODE;
d1413 2
a1414 1
	char *sbs;
d1417 2
d1420 4
a1423 3
	/* XXX For error 0x71, current opcode is not the relevant one. */
	printf("%sCheck Condition (error %#x) on opcode 0x%x\n",
	    (serr == 0x71) ? "DEFERRED " : "", serr, xs->cmd->opcode);
d1425 4
a1428 14
	if (serr != 0x70 && serr != 0x71) {	
		if ((sense->error_code & SSD_ERRCODE_VALID) != 0) {
			struct scsi_sense_data_unextended *usense =
			    (struct scsi_sense_data_unextended *)sense;
			printf("   AT BLOCK #: %d (decimal)",
			    _3btol(usense->block));
		}
		return;
	}

	printf("    SENSE KEY: %s\n", scsi_decode_sense(sense,
	    DECODE_SENSE_KEY));

	if (sense->flags & (SSD_FILEMARK | SSD_EOM | SSD_ILI)) {
d1432 1
a1432 1
		if (sense->flags & SSD_FILEMARK) {
d1436 1
a1436 1
		if (sense->flags & SSD_EOM) {
d1440 1
a1440 1
		if (sense->flags & SSD_ILI)
d1444 9
d1455 2
a1456 2
	 * It is inconvenient to use device type to figure out how to
	 * format the info fields. So print them as 32 bit integers.
d1458 5
a1462 1
	info = _4btol(&sense->info[0]);
d1464 1
a1464 2
		printf("         INFO: 0x%x (VALID flag %s)\n", info,
		    sense->error_code & SSD_ERRCODE_VALID ? "on" : "off");
d1466 3
a1468 2
	if (sense->extra_len < 4)
		return;
d1470 1
a1470 4
	info = _4btol(&sense->cmd_spec_info[0]);
	if (info)
		printf(" COMMAND INFO: 0x%x\n", info);
	sbs = scsi_decode_sense(sense, DECODE_ASC_ASCQ);
d1473 3
a1475 3
	if (sense->fru != 0)
		printf("     FRU CODE: 0x%x\n", sense->fru);
	sbs = scsi_decode_sense(sense, DECODE_SKSV);
d1478 46
d1527 2
a1528 2
scsi_decode_sense(sense, flag)
	struct scsi_sense_data *sense;
d1531 1
@


1.24
log
@Spelling error in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.23 1999/02/07 00:14:25 deraadt Exp $	*/
d534 1
d577 9
d645 1
a645 1
		if (error != -1)
d666 2
a667 2
		case 0x0:	/* NO SENSE */
		case 0x1:	/* RECOVERED ERROR */
d670 1
a670 1
		case 0xc:	/* EQUAL */
d673 1
a673 1
		case 0x2:	/* NOT READY */
d691 1
a691 1
		case 0x5:	/* ILLEGAL REQUEST */
d698 4
a701 1
		case 0x6:	/* UNIT ATTENTION */
d712 1
a712 1
		case 0x7:	/* DATA PROTECT */
d715 1
a715 1
		case 0x8:	/* BLANK CHECK */
d718 1
a718 1
		case 0xb:	/* COMMAND ABORTED */
d721 1
a721 1
		case 0xd:	/* VOLUME OVERFLOW */
d728 3
a730 1
		scsi_print_sense(xs, 0);
d739 1
a739 1
		printf("error code %d",
@


1.23
log
@print INFO FIELD as unsigned
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.22 1998/12/19 01:32:26 deraadt Exp $	*/
d525 1
a525 1
	 * errors at inetrrupt time. We have probably
@


1.22
log
@for sense code "Logical Unit Is in Process Of Becoming Ready", make
the sense code evaluation function return ERESTART with xs->error = XS_BUSY;
then higher up catch this case and drop into the scbusy tsleep code.
For exabyte 8500 units, this makes st opening reprobe repeatedly, rather
than fail with an EIO while the tape is being loaded.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.21 1998/02/14 08:56:50 deraadt Exp $	*/
d1056 1
a1056 1
		printf("   INFO FIELD: %d\n", info);
@


1.21
log
@clear scsi_xfer's status byte before executing or re-executing the command.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.20 1997/12/31 01:22:10 deraadt Exp $	*/
d241 1
a241 1
			     sizeof(scsi_cmd), 0, 0, 2, 10000, NULL, flags);
d534 5
a538 1
		if ((error = scsi_interpret_sense(xs)) == ERESTART)
d540 1
d546 1
d550 1
a550 1
			else if ((xs->flags & SCSI_NOSLEEP) == 0)
d552 1
a552 1
			else
d668 5
@


1.20
log
@return EROFS for write protect; is
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.19 1997/09/11 21:05:22 niklas Exp $	*/
d415 1
@


1.19
log
@Fix setting up of the LUN field of the CDB
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.18 1997/09/05 05:56:49 millert Exp $	*/
d688 1
a688 1
			error = EACCES;
@


1.18
log
@Add SCSITERSE option which omits the (large) ASC/ASCQ table.
Old scsi error printing code is now gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.17 1997/09/05 05:19:52 millert Exp $	*/
d179 7
a185 2
	 * Set the LUN in the CDB if we have an older device.  We also
	 * set it for more modern SCSI-II devices "just in case".
d187 3
a189 3
	if ((sc_link->scsi_version & SID_ANSII) <= 2)
		xs->cmd->bytes[0] |=
		    ((sc_link->lun << SCSI_CMD_LUN_SHIFT) & SCSI_CMD_LUN_MASK);
@


1.17
log
@fix compilation problem when SCSIVERBOSE=0
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.16 1997/09/05 04:04:06 deraadt Exp $	*/
a33 5
 * Additions for detail SCSI error printing are
 * Copyright (c) 1997 by Matthew Jacob.
 */

/*
d35 1
d58 1
a60 2
#if	SCSIVERBOSE
static inline void asc2ascii __P((u_char asc, u_char ascq, char *result));
a61 1
#endif
a588 12
#if	!SCSIVERBOSE
	static char *error_mes[] = {
		"soft error (corrected)",
		"not ready", "medium error",
		"non-media hardware failure", "illegal request",
		"unit attention", "readonly device",
		"no data found", "vendor unique",
		"copy aborted", "command aborted",
		"search returned equal", "volume overflow",
		"verify miscompare", "unknown error key"
	};
#endif
d698 1
a699 37

#if	SCSIVERBOSE
		scsi_print_sense(xs, 0);
#else
		if (key) {
			sc_print_addr(sc_link);
			printf("%s", error_mes[key - 1]);
			if ((sense->error_code & SSD_ERRCODE_VALID) != 0) {
				switch (key) {
				case 0x2:	/* NOT READY */
				case 0x5:	/* ILLEGAL REQUEST */
				case 0x6:	/* UNIT ATTENTION */
				case 0x7:	/* DATA PROTECT */
					break;
				case 0x8:	/* BLANK CHECK */
					printf(", requested size: %d (decimal)",
					    info);
					break;
				case 0xb:	/* COMMAND ABORTED */
					if (xs->retries)
						printf(", retrying");
					printf(", cmd 0x%x, info 0x%x",
						xs->cmd->opcode, info);
					break;
				default:
					printf(", info = %d (decimal)", info);
				}
			}
			if (sense->extra_len != 0) {
				int n;
				printf(", data =");
				for (n = 0; n < sense->extra_len; n++)
					printf(" %02x", sense->extra_bytes[n]);
			}
			printf("\n");
		}
#endif
a739 1
#if	SCSIVERBOSE
d758 1
d956 1
a956 2

static inline void
d982 12
d1134 2
a1135 3
		auto char localbuf[64];
		asc2ascii(snsbuf[12], snsbuf[13], localbuf);
		(void) sprintf(rqsbuf, "%s, %s", sense_keys[skey], localbuf);
a1173 1
#endif
d1235 1
a1235 1
#endif /*SCSIDEBUG */
@


1.16
log
@clean up sense info printing further
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.15 1997/09/03 17:23:20 deraadt Exp $	*/
a61 1
static inline void asc2ascii __P((u_char asc, u_char ascq, char *result));
d65 1
@


1.15
log
@simplify verbose error reporting
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.14 1997/09/02 17:15:35 deraadt Exp $	*/
d60 3
a62 9
						    struct scsi_generic *,
						    int cmdlen,
						    u_char *data_addr,
						    int datalen,
						    int retries,
						    int timeout,
						    struct buf *,
						    int flags));

d814 1
a814 2
	unsigned char asc;
	unsigned char ascq;
d1010 1
d1012 3
a1014 1
asc2ascii(unsigned char asc, unsigned char ascq, char *result)
d1048 1
a1048 1
	printf(" Check Condition on opcode %x\n", xs->cmd->opcode);
d1053 1
a1053 1
	printf("    SENSE KEY:  %s", scsi_decode_sense(s, 0));
d1059 3
a1061 3
		char pad;
		printf("\n              ");
		pad = ' ';
d1072 1
a1073 1

d1082 1
a1082 1
		printf("\n   INFO FIELD:  %d", info);
d1090 1
a1090 2
	if (s[7] < 4) {
		printf("\n");
a1091 1
	}
d1094 1
a1094 1
		printf("\n COMMAND INFO:  %d (0x%x)", info, info);
d1102 1
a1102 1
		printf("\n     ASC/ASCQ:  %s", sbs);
d1104 1
a1104 1
		printf("\n     FRU CODE:  0x%x", s[14] & 0xff);
d1107 2
a1108 3
		printf("\n         SKSV:  %s", sbs);
	if (verbosity == 0) {
		printf("\n");
a1109 1
	}
d1132 1
a1132 1
	printf("\n Additional Sense Information (byte %d out...):\n", i);
d1134 1
a1134 1
		printf("\t%2d:", i);
d1137 1
a1137 1
		printf("\t%2d:", i);
d1146 1
a1146 1
			printf("\n\t%2d:", i);
d1157 3
a1159 1
scsi_decode_sense(void *sinfo, int flag)
d1161 1
a1161 2
	unsigned char *snsbuf;
	unsigned char skey;
d1166 1
a1166 1
	snsbuf = (unsigned char *) sinfo;
@


1.14
log
@delete extra \n
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.13 1997/08/22 04:43:25 millert Exp $	*/
d824 191
a1014 191
{ 0x00, 0x00, "No Additional Sense Information" },
{ 0x00, 0x01, "Filemark Detected" },
{ 0x00, 0x02, "End-Of-Partition/Medium Detected" },
{ 0x00, 0x03, "Setmark Detected" },
{ 0x00, 0x04, "Beginning-Of-Partition/Medium Detected" },
{ 0x00, 0x05, "End-Of-Data Detected" },
{ 0x00, 0x06, "I/O Process Terminated" },
{ 0x00, 0x11, "Audio Play Operation In Progress" },
{ 0x00, 0x12, "Audio Play Operation Paused" },
{ 0x00, 0x13, "Audio Play Operation Successfully Completed" },
{ 0x00, 0x14, "Audio Play Operation Stopped Due to Error" },
{ 0x00, 0x15, "No Current Audio Status To Return" },
{ 0x01, 0x00, "No Index/Sector Signal" },
{ 0x02, 0x00, "No Seek Complete" },
{ 0x03, 0x00, "Peripheral Device Write Fault" },
{ 0x03, 0x01, "No Write Current" },
{ 0x03, 0x02, "Excessive Write Errors" },
{ 0x04, 0x00, "Logical Unit Not Ready, Cause Not Reportable" },
{ 0x04, 0x01, "Logical Unit Is in Process Of Becoming Ready" },
{ 0x04, 0x02, "Logical Unit Not Ready, Initialization Command Required" },
{ 0x04, 0x03, "Logical Unit Not Ready, Manual Intervention Required" },
{ 0x04, 0x04, "Logical Unit Not Ready, Format In Progress" },
{ 0x05, 0x00, "Logical Unit Does Not Respond To Selection" },
{ 0x06, 0x00, "No Reference Position Found" },
{ 0x07, 0x00, "Multiple Peripheral Devices Selected" },
{ 0x08, 0x00, "Logical Unit Communication Failure" },
{ 0x08, 0x01, "Logical Unit Communication Timeout" },
{ 0x08, 0x02, "Logical Unit Communication Parity Error" },
{ 0x09, 0x00, "Track Following Error" },
{ 0x09, 0x01, "Tracking Servo Failure" },
{ 0x09, 0x02, "Focus Servo Failure" },
{ 0x09, 0x03, "Spindle Servo Failure" },
{ 0x0A, 0x00, "Error Log Overflow" },
{ 0x0C, 0x00, "Write Error" },
{ 0x0C, 0x01, "Write Error Recovered with Auto Reallocation" },
{ 0x0C, 0x02, "Write Error - Auto Reallocate Failed" },
{ 0x10, 0x00, "ID CRC Or ECC Error" },
{ 0x11, 0x00, "Unrecovered Read Error" },
{ 0x11, 0x01, "Read Retried Exhausted" },
{ 0x11, 0x02, "Error Too Long To Correct" },
{ 0x11, 0x03, "Multiple Read Errors" },
{ 0x11, 0x04, "Unrecovered Read Error - Auto Reallocate Failed" },
{ 0x11, 0x05, "L-EC Uncorrectable Error" },
{ 0x11, 0x06, "CIRC Unrecovered Error" },
{ 0x11, 0x07, "Data Resynchronization Error" },
{ 0x11, 0x08, "Incomplete Block Found" },
{ 0x11, 0x09, "No Gap Found" },
{ 0x11, 0x0A, "Miscorrected Error" },
{ 0x11, 0x0B, "Uncorrected Read Error - Recommend Reassignment" },
{ 0x11, 0x0C, "Uncorrected Read Error - Recommend Rewrite the Data" },
{ 0x12, 0x00, "Address Mark Not Found for ID Field" },
{ 0x13, 0x00, "Address Mark Not Found for Data Field" },
{ 0x14, 0x00, "Recorded Entity Not Found" },
{ 0x14, 0x01, "Record Not Found" },
{ 0x14, 0x02, "Filemark or Setmark Not Found" },
{ 0x14, 0x03, "End-Of-Data Not Found" },
{ 0x14, 0x04, "Block Sequence Error" },
{ 0x15, 0x00, "Random Positioning Error" },
{ 0x15, 0x01, "Mechanical Positioning Error" },
{ 0x15, 0x02, "Positioning Error Detected By Read of Medium" },
{ 0x16, 0x00, "Data Synchronization Mark Error" },
{ 0x17, 0x00, "Recovered Data With No Error Correction Applied" },
{ 0x17, 0x01, "Recovered Data With Retries" },
{ 0x17, 0x02, "Recovered Data With Positive Head Offset" },
{ 0x17, 0x03, "Recovered Data With Negative Head Offset" },
{ 0x17, 0x04, "Recovered Data With Retries and/or CIRC Applied" },
{ 0x17, 0x05, "Recovered Data Using Previous Sector ID" },
{ 0x17, 0x06, "Recovered Data Without ECC - Data Auto-Reallocated" },
{ 0x17, 0x07, "Recovered Data Without ECC - Recommend Reassignment" },
{ 0x17, 0x08, "Recovered Data Without ECC - Recommend Rewrite" },
{ 0x18, 0x00, "Recovered Data With Error Correction Applied" },
{ 0x18, 0x01, "Recovered Data With Error Correction & Retries Applied" },
{ 0x18, 0x02, "Recovered Data - Data Auto-Reallocated" },
{ 0x18, 0x03, "Recovered Data With CIRC" },
{ 0x18, 0x04, "Recovered Data With LEC" },
{ 0x18, 0x05, "Recovered Data - Recommend Reassignment" },
{ 0x18, 0x06, "Recovered Data - Recommend Rewrite" },
{ 0x19, 0x00, "Defect List Error" },
{ 0x19, 0x01, "Defect List Not Available" },
{ 0x19, 0x02, "Defect List Error in Primary List" },
{ 0x19, 0x03, "Defect List Error in Grown List" },
{ 0x1A, 0x00, "Parameter List Length Error" },
{ 0x1B, 0x00, "Synchronous Data Transfer Error" },
{ 0x1C, 0x00, "Defect List Not Found" },
{ 0x1C, 0x01, "Primary Defect List Not Found" },
{ 0x1C, 0x02, "Grown Defect List Not Found" },
{ 0x1D, 0x00, "Miscompare During Verify Operation" },
{ 0x1E, 0x00, "Recovered ID with ECC" },
{ 0x20, 0x00, "Invalid Command Operation Code" },
{ 0x21, 0x00, "Logical Block Address Out of Range" },
{ 0x21, 0x01, "Invalid Element Address" },
{ 0x22, 0x00, "Illegal Function (Should 20 00, 24 00, or 26 00)" },
{ 0x24, 0x00, "Illegal Field in CDB" },
{ 0x25, 0x00, "Logical Unit Not Supported" },
{ 0x26, 0x00, "Invalid Field In Parameter List" },
{ 0x26, 0x01, "Parameter Not Supported" },
{ 0x26, 0x02, "Parameter Value Invalid" },
{ 0x26, 0x03, "Threshold Parameters Not Supported" },
{ 0x27, 0x00, "Write Protected" },
{ 0x28, 0x00, "Not Ready To Ready Transition (Medium May Have Changed)" },
{ 0x28, 0x01, "Import Or Export Element Accessed" },
{ 0x29, 0x00, "Power On, Reset, or Bus Device Reset Occurred" },
{ 0x2A, 0x00, "Parameters Changed" },
{ 0x2A, 0x01, "Mode Parameters Changed" },
{ 0x2A, 0x02, "Log Parameters Changed" },
{ 0x2B, 0x00, "Copy Cannot Execute Since Host Cannot Disconnect" },
{ 0x2C, 0x00, "Command Sequence Error" },
{ 0x2C, 0x01, "Too Many Windows Specified" },
{ 0x2C, 0x02, "Invalid Combination of Windows Specified" },
{ 0x2D, 0x00, "Overwrite Error On Update In Place" },
{ 0x2F, 0x00, "Commands Cleared By Another Initiator" },
{ 0x30, 0x00, "Incompatible Medium Installed" },
{ 0x30, 0x01, "Cannot Read Medium - Unknown Format" },
{ 0x30, 0x02, "Cannot Read Medium - Incompatible Format" },
{ 0x30, 0x03, "Cleaning Cartridge Installed" },
{ 0x31, 0x00, "Medium Format Corrupted" },
{ 0x31, 0x01, "Format Command Failed" },
{ 0x32, 0x00, "No Defect Spare Location Available" },
{ 0x32, 0x01, "Defect List Update Failure" },
{ 0x33, 0x00, "Tape Length Error" },
{ 0x36, 0x00, "Ribbon, Ink, or Toner Failure" },
{ 0x37, 0x00, "Rounded Parameter" },
{ 0x39, 0x00, "Saving Parameters Not Supported" },
{ 0x3A, 0x00, "Medium Not Present" },
{ 0x3B, 0x00, "Positioning Error" },
{ 0x3B, 0x01, "Tape Position Error At Beginning-of-Medium" },
{ 0x3B, 0x02, "Tape Position Error At End-of-Medium" },
{ 0x3B, 0x03, "Tape or Electronic Vertical Forms Unit Not Ready" },
{ 0x3B, 0x04, "Slew Failure" },
{ 0x3B, 0x05, "Paper Jam" },
{ 0x3B, 0x06, "Failed To Sense Top-Of-Form" },
{ 0x3B, 0x07, "Failed To Sense Bottom-Of-Form" },
{ 0x3B, 0x08, "Reposition Error" },
{ 0x3B, 0x09, "Read Past End Of Medium" },
{ 0x3B, 0x0A, "Read Past Begining Of Medium" },
{ 0x3B, 0x0B, "Position Past End Of Medium" },
{ 0x3B, 0x0C, "Position Past Beginning Of Medium" },
{ 0x3B, 0x0D, "Medium Destination Element Full" },
{ 0x3B, 0x0E, "Medium Source Element Empty" },
{ 0x3D, 0x00, "Invalid Bits In IDENTFY Message" },
{ 0x3E, 0x00, "Logical Unit Has Not Self-Configured Yet" },
{ 0x3F, 0x00, "Target Operating Conditions Have Changed" },
{ 0x3F, 0x01, "Microcode Has Changed" },
{ 0x3F, 0x02, "Changed Operating Definition" },
{ 0x3F, 0x03, "INQUIRY Data Has Changed" },
{ 0x40, 0x00, "RAM FAILURE (Should Use 40 NN)" },
{ 0x41, 0x00, "Data Path FAILURE (Should Use 40 NN)" },
{ 0x42, 0x00, "Power-On or Self-Test FAILURE (Should Use 40 NN)" },
{ 0x43, 0x00, "Message Error" },
{ 0x44, 0x00, "Internal Target Failure" },
{ 0x45, 0x00, "Select Or Reselect Failure" },
{ 0x46, 0x00, "Unsuccessful Soft Reset" },
{ 0x47, 0x00, "SCSI Parity Error" },
{ 0x48, 0x00, "INITIATOR DETECTED ERROR Message Received" },
{ 0x49, 0x00, "Invalid Message Error" },
{ 0x4A, 0x00, "Command Phase Error" },
{ 0x4B, 0x00, "Data Phase Error" },
{ 0x4C, 0x00, "Logical Unit Failed Self-Configuration" },
{ 0x4E, 0x00, "Overlapped Commands Attempted" },
{ 0x50, 0x00, "Write Append Error" },
{ 0x50, 0x01, "Write Append Position Error" },
{ 0x50, 0x02, "Position Error Related To Timing" },
{ 0x51, 0x00, "Erase Failure" },
{ 0x52, 0x00, "Cartridge Fault" },
{ 0x53, 0x00, "Media Load or Eject Failed" },
{ 0x53, 0x01, "Unload Tape Failure" },
{ 0x53, 0x02, "Medium Removal Prevented" },
{ 0x54, 0x00, "SCSI To Host System Interface Failure" },
{ 0x55, 0x00, "System Resource Failure" },
{ 0x57, 0x00, "Unable To Recover Table-Of-Contents" },
{ 0x58, 0x00, "Generation Does Not Exist" },
{ 0x59, 0x00, "Updated Block Read" },
{ 0x5A, 0x00, "Operator Request or State Change Input (Unspecified)" },
{ 0x5A, 0x01, "Operator Medium Removal Requested" },
{ 0x5A, 0x02, "Operator Selected Write Protect" },
{ 0x5A, 0x03, "Operator Selected Write Permit" },
{ 0x5B, 0x00, "Log Exception" },
{ 0x5B, 0x01, "Threshold Condition Met" },
{ 0x5B, 0x02, "Log Counter At Maximum" },
{ 0x5B, 0x03, "Log List Codes Exhausted" },
{ 0x5C, 0x00, "RPL Status Change" },
{ 0x5C, 0x01, "Spindles Synchronized" },
{ 0x5C, 0x02, "Spindles Not Synchronized" },
{ 0x60, 0x00, "Lamp Failure" },
{ 0x61, 0x00, "Video Acquisition Error" },
{ 0x61, 0x01, "Unable To Acquire Video" },
{ 0x61, 0x02, "Out Of Focus" },
{ 0x62, 0x00, "Scan Head Positioning Error" },
{ 0x63, 0x00, "End Of User Area Encountered On This Track" },
{ 0x64, 0x00, "Illegal Mode For This Track" },
{ 0x00, 0x00, (char *) 0 }
d1022 2
a1023 2
	while (adesc[i].description != (char *) 0) {
		if (adesc[i].asc == asc && adesc[i].ascq == ascq) {
a1024 1
		}
d1027 1
a1027 1
	if (adesc[i].description == (char *) 0) {
d1074 1
a1074 1
		if (s[2] & SSD_ILI) {
a1075 1
		}
d1085 1
a1085 1
	if (info) {
a1086 1
	}
d1099 1
a1099 1
	if (info) {
a1100 1
	}
d1107 1
a1107 1
	if (sbs) {
d1109 1
a1109 2
	}
	if (s[14] != 0) {
a1110 1
	}
d1112 1
a1112 1
	if (sbs) {
a1113 1
	}
d1129 1
a1129 1
	if (sbs) {
d1131 1
a1131 1
	} else {
d1133 2
a1134 2
	}
	for (j = i; j < sizeof (xs->sense); j++) {
a1136 1
	}
d1142 1
a1142 1
		printf("\n\t%2d:", i);
d1145 1
a1145 1
		printf("\n\t%2d:", i);
d1161 1
a1161 1
	printf("\n\n");
d1222 1
a1222 1
	return ((char *) 0);
@


1.13
log
@Add more detailed SCSI error printing by Matthew Jacob.  Enabled by
default.  Use "option SCSIVERBOSE=0" to turn off (only added 8Kb to my kernel).
From the NetBSD commit message:
    Add in more detailed SCSI error printing, based off of final SCSI-2 spec.
    This will also print out things like progress indicator errors, and will
    also dump out additional sense bytes that haven't been decoded.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.12 1997/07/03 17:47:29 deraadt Exp $	*/
d1115 1
a1115 1
		printf("\n     FRU CODE:  0x%x\n", s[14] & 0xff);
a1120 1
	printf("\n");
@


1.12
log
@print correct sense bytes
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.11 1997/04/14 04:09:07 downsj Exp $	*/
d34 5
d71 3
d601 1
a601 1

d612 1
d638 1
a638 1
#endif	/*SCSIDEBUG */
d658 2
a659 1
		printf(" DELAYED ERROR, key = 0x%x\n", key);
d723 4
d759 1
d800 435
@


1.11
log
@Merge in various pieces of current NetBSD scsi code, including but not limited
to:

* New changer driver.
* Better optical support.
* Different `done' semantics.
* New quirks for SCSI QIC tape driver, SCSI floppy drives.
* Better support for SCSI-I devices.

Everybody needs to test this.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.10 1996/06/16 03:07:19 downsj Exp $	*/
d626 1
a626 1
			printf("%x ", sense->extra_bytes[count]);
@


1.10
log
@NetBSD PR#2535: add mode sense 5 and floppy support in our framework.
@
text
@d1 2
a2 2
/*	$OpenBSD: scsi_base.c,v 1.9 1996/05/06 11:33:35 deraadt Exp $	*/
/*	$NetBSD: scsi_base.c,v 1.36 1996/05/03 19:48:20 christos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1994, 1995 Charles Hannum.  All rights reserved.
d17 1
a17 1
 *	This product includes software developed by Charles Hannum.
a51 2
void scsi_error __P((struct scsi_xfer *, int));

d182 8
d327 1
d351 1
a351 17
	/*
	 * If the device has it's own done routine, call it first.
	 * If it returns a legit error value, return that, otherwise
	 * it wants us to continue with normal processing.
	 *
	 * Make sure the upper-level driver knows that this might not
	 * actually be the last time they hear from us.  We need to get
	 * status back.
	 */
	if (sc_link->device->done) {
		SC_DEBUG(sc_link, SDEV_DB2, ("calling private done()\n"));
		error = (*sc_link->device->done)(xs, 0);
		if (error == EJUSTRETURN)
			goto done;
		SC_DEBUG(sc_link, SDEV_DB3, ("continuing with generic done()\n"));
	}
	if (xs->bp == NULL) {
d360 1
d366 2
a367 1
	if (sc_err1(xs, 1) == ERESTART) {
d378 12
a389 1
done:
d397 1
a397 1
		(void)(*sc_link->device->done)(xs, 1);
d400 2
d426 4
a429 3
	 * If we have a bp however, all the error processing
	 * and the buffer code both expect us to return straight
	 * to them, so as soon as the command is queued, return
d433 1
a433 1
		if (xs->bp)
d435 4
a574 1
	scsi_error(xs, error);
a575 20
}

void
scsi_error(xs, error)
	struct scsi_xfer *xs;
	int error;
{
	struct buf *bp = xs->bp;

	if (bp) {
		if (error) {
			bp->b_error = error;
			bp->b_flags |= B_ERROR;
			bp->b_resid = bp->b_bcount;
		} else {
			bp->b_error = 0;
			bp->b_resid = xs->resid;
		}
		biodone(bp);
	}
@


1.9
log
@from netbsd; SCSIDEBUG printf() fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_base.c,v 1.7 1996/04/21 22:30:50 deraadt Exp $	*/
d691 2
@


1.8
log
@no sys/cpu.h, fix bugs in ch
@
text
@d2 1
a2 1
/*	$NetBSD: scsi_base.c,v 1.35 1996/04/22 01:46:05 christos Exp $	*/
d801 1
a801 1
	printf("xs(0x%x): ", xs);
d803 1
a803 1
	printf("sc_link(0x%x)", xs->sc_link);
d806 1
a806 1
	printf("cmd(0x%x)", xs->cmd);
d808 1
a808 1
	printf("data(0x%x)", xs->data);
d812 1
a812 1
	printf("bp(0x%x)", xs->bp);
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: scsi_base.c,v 1.6 1996/02/29 13:12:22 niklas Exp $	*/
/*	$NetBSD: scsi_base.c,v 1.34 1996/03/19 03:06:28 mycroft Exp $	*/
a46 1
#include <sys/cpu.h>
@


1.6
log
@Fix typo in comment
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: scsi_base.c,v 1.33 1996/02/14 21:47:14 christos Exp $	*/
a197 1
	u_long size;
a215 5
	} else {
		size = rdcap.addr_0 + 1;
		size += rdcap.addr_1 << 8;
		size += rdcap.addr_2 << 16;
		size += rdcap.addr_3 << 24;
d217 2
a218 1
	return size;
d624 5
a628 5
		    sense->extended_segment,
		    sense->extended_flags & SSD_KEY,
		    sense->extended_flags & SSD_ILI ? 1 : 0,
		    sense->extended_flags & SSD_EOM ? 1 : 0,
		    sense->extended_flags & SSD_FILEMARK ? 1 : 0);
d630 5
a634 5
		    sense->extended_info[0],
		    sense->extended_info[1],
		    sense->extended_info[2],
		    sense->extended_info[3],
		    sense->extended_extra_len);
d636 2
a637 2
		for (count = 0; count < sense->extended_extra_len; count++)
			printf("%x ", sense->extended_extra_bytes[count]);
d659 1
a659 1
		key = sense->extended_flags & SSD_KEY;
d662 3
a664 4
		if ((sense->error_code & SSD_ERRCODE_VALID) != 0) {
			bcopy(sense->extended_info, &info, sizeof info);
			info = ntohl(info);
		} else
d666 1
a666 1
		key = sense->extended_flags & SSD_KEY;
d746 1
a746 1
			if (sense->extended_extra_len != 0) {
d749 2
a750 2
				for (n = 0; n < sense->extended_extra_len; n++)
					printf(" %02x", sense->extended_extra_bytes[n]);
d764 2
d767 1
a767 3
			    (sense->XXX_unextended_blockhi << 16) +
			    (sense->XXX_unextended_blockmed << 8) +
			    (sense->XXX_unextended_blocklow));
a777 30
/*
 * convert a physical address to 3 bytes, 
 * MSB at the lowest address,
 * LSB at the highest.
 */
void
lto3b(val, bytes)
	u_int32_t val;
	u_int8_t *bytes;
{

	*bytes++ = (val >> 16) & 0xff;
	*bytes++ = (val >> 8) & 0xff;
	*bytes = val & 0xff;
}

/*
 * The reverse of lto3b
 */
u_int32_t
_3btol(bytes)
	u_int8_t *bytes;
{
	u_int32_t rc;

	rc = (*bytes++ << 16);
	rc += (*bytes++ << 8);
	rc += *bytes;
	return (rc);
}
@


1.5
log
@Sync. w/ NetBSD: scsi prototypes.
@
text
@d1 1
d426 1
a426 1
	 * If we have a bp however, all the error proccessing
@


1.4
log
@COMMAND ABORTED sense key is 0xb, not 0xa.  Also clean up diagnostic message.
@
text
@d1 1
a1 1
/*	$NetBSD: scsi_base.c,v 1.31 1996/01/12 22:43:29 thorpej Exp $	*/
d45 2
d56 13
d100 1
a100 1
	if (xs = xs_free_list.lh_first) {
d154 1
a154 1
    retries, timeout, bp, flags)
d457 1
d686 4
@


1.3
log
@From NetBSD: (required for last change to scsi_base.c in case we get
	      "command aborted" status)
Handle cases like the following:
        - controller calls scsi_done() with error XS_TIMEOUT
        - scsi_done() calls sddone()
        - sddone() calls disk_unbusy()
        - scsi_done() calls controller to retry command (missing the
          call to disk_busy())
        - controller calls scsi_done()
        - scsi_done() calls sddone()
        - sddone() calls disk_busy(), which panics because of the imbalance.
Bug noticed by Leo Weppleman, who also suggested this fix; pass an additional
boolean argument ("complete") to the device's "done" routine, with a
value of `0' passed from the previous call to "done", and add an additional
call to "done" when the xfer resources are freed.
@
text
@d696 1
a696 1
		case 0xa:	/* COMMAND ABORTED */
d721 6
a726 3
				case 0xa:	/* COMMAND ABORTED */
					printf(", cmd %x, attempting retry",
						xs->cmd->opcode);
@


1.2
log
@Retry a command when we get a command aborted message for it.
This might be a transient error.  Do complain about it, though.
@
text
@d1 1
a1 1
/*	$NetBSD: scsi_base.c,v 1.30 1995/09/26 19:26:55 thorpej Exp $	*/
d338 4
d345 1
a345 1
		error = (*sc_link->device->done) (xs);
d376 9
@


1.1
log
@Initial revision
@
text
@d683 3
d708 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
