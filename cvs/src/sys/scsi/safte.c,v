head	1.53;
access;
symbols
	OPENBSD_6_0:1.53.0.4
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.50.0.4
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.48.0.14
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.48.0.10
	OPENBSD_5_4_BASE:1.48
	OPENBSD_5_3:1.48.0.8
	OPENBSD_5_3_BASE:1.48
	OPENBSD_5_2:1.48.0.6
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.4
	OPENBSD_5_0:1.48.0.2
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.46.0.2
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.44.0.2
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.40.0.4
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.40.0.6
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.40.0.2
	OPENBSD_4_5_BASE:1.40
	OPENBSD_4_4:1.39.0.4
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16;
locks; strict;
comment	@ * @;


1.53
date	2015.08.23.01.55.39;	author tedu;	state Exp;
branches;
next	1.52;
commitid	OczmFvlAy5J4Utsq;

1.52
date	2015.06.07.19.13.27;	author krw;	state Exp;
branches;
next	1.51;
commitid	MxUWuiPFtM1nRYxm;

1.51
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.50;
commitid	uzzBR7hz9ncd4O6G;

1.50
date	2014.07.13.17.34.25;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	jkrwuhojUhzJkdOy;

1.49
date	2014.07.12.18.50.25;	author tedu;	state Exp;
branches;
next	1.48;
commitid	iN7nvia2fLP712wt;

1.48
date	2011.06.15.01.10.05;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2011.03.17.21.30.24;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2010.09.27.19.49.43;	author thib;	state Exp;
branches;
next	1.45;

1.45
date	2010.08.30.02.47.56;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.22.15.59.47;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.22.05.21.02;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.22.04.59.31;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	2010.07.22.00.31.06;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2009.01.20.21.46.42;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.16.01.30.24;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.07.16.15.49;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.01.22.58.50;	author cnst;	state Exp;
branches;
next	1.35;

1.35
date	2007.04.03.04.15.50;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.02.21.22.37.38;	author deanna;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.01.10.42.18;	author grange;	state Exp;
branches;
next	1.29;

1.29
date	2006.07.29.02.40.45;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.21.03.10.49;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.09.05.51.54;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.19.17.08.40;	author grange;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.11.08.21.21;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.02.04.23.17;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.13.02.26.48;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.12.15.12.10;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.11.01.19.47;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.10.22.27.03;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.10.13.24.51;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.10.08.36.37;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.24.03.39.52;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.23.05.29.42;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.22.19.24.45;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.21.23.28.59;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.18.09.51.05;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.17.00.07.08;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.15.21.48.03;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.13.01.38.19;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.12.08.50.08;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.10.10.55.33;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.08.18.43.09;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2005.08.05.01.06.15;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2005.08.05.01.03.13;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.05.00.31.04;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.05.00.17.02;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2005.08.05.00.08.58;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.53
log
@add some sizes to free. looked over by deraadt
@
text
@/*	$OpenBSD: safte.c,v 1.52 2015/06/07 19:13:27 krw Exp $ */

/*
 * Copyright (c) 2005 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/scsiio.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/rwlock.h>
#include <sys/queue.h>
#include <sys/sensors.h>

#if NBIO > 0
#include <dev/biovar.h>
#endif

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <scsi/safte.h>

#ifdef SAFTE_DEBUG
#define DPRINTF(x)	do { if (safte_debug) printf x ; } while (0)
int	safte_debug = 1;
#else
#define DPRINTF(x)	/* x */
#endif


int	safte_match(struct device *, void *, void *);
void	safte_attach(struct device *, struct device *, void *);
int	safte_detach(struct device *, int);

struct safte_sensor {
	struct ksensor		se_sensor;
	enum {
		SAFTE_T_FAN,
		SAFTE_T_PWRSUP,
		SAFTE_T_DOORLOCK,
		SAFTE_T_ALARM,
		SAFTE_T_TEMP
	}			se_type;
	u_int8_t		*se_field;
};

struct safte_softc {
	struct device		sc_dev;
	struct scsi_link	 *sc_link;
	struct rwlock		sc_lock;

	u_int			sc_encbuflen;
	u_char			*sc_encbuf;

	int			sc_nsensors;
	struct safte_sensor	*sc_sensors;
	struct ksensordev	sc_sensordev;
	struct sensor_task	*sc_sensortask;

	int			sc_celsius;
	int			sc_ntemps;
	struct safte_sensor	*sc_temps;
	u_int8_t		*sc_temperrs;

#if NBIO > 0
	int			sc_nslots;
	u_int8_t		*sc_slots;
#endif
};

struct cfattach safte_ca = {
	sizeof(struct safte_softc), safte_match, safte_attach, safte_detach
};

struct cfdriver safte_cd = {
	NULL, "safte", DV_DULL
};

#define DEVNAME(s)	((s)->sc_dev.dv_xname)

int	safte_read_config(struct safte_softc *);
void	safte_read_encstat(void *);

#if NBIO > 0
int	safte_ioctl(struct device *, u_long, caddr_t);
int	safte_bio_blink(struct safte_softc *, struct bioc_blink *);
#endif

int64_t	safte_temp2uK(u_int8_t, int);

int
safte_match(struct device *parent, void *match, void *aux)
{
	struct scsi_inquiry_data *inqbuf;
	struct scsi_attach_args	*sa = aux;
	struct scsi_inquiry_data *inq = sa->sa_inqbuf;
	struct scsi_xfer *xs;
	struct safte_inq *si;
	int error, flags = 0, length;

	if (inq == NULL)
		return (0);

	/* match on dell enclosures */
	if ((inq->device & SID_TYPE) == T_PROCESSOR &&
	    SCSISPC(inq->version) == 3)
		return (2);

	if ((inq->device & SID_TYPE) != T_PROCESSOR ||
	    SCSISPC(inq->version) != 2 ||
	    (inq->response_format & SID_ANSII) != 2)
		return (0);

	length = inq->additional_length + SAFTE_EXTRA_OFFSET;
	if (length < SAFTE_INQ_LEN)
		return (0);
	if (length > sizeof(*inqbuf))
		length = sizeof(*inqbuf);

	inqbuf = dma_alloc(sizeof(*inqbuf), PR_NOWAIT | PR_ZERO);
	if (inqbuf == NULL)
		return (0);

	memset(inqbuf->extra, ' ', sizeof(inqbuf->extra));

	if (cold)
		flags |= SCSI_AUTOCONF;
	xs = scsi_xs_get(sa->sa_sc_link, flags | SCSI_DATA_IN);
	if (xs == NULL)
		goto fail;

	xs->retries = 2;
	xs->timeout = 10000;

	scsi_init_inquiry(xs, 0, 0, inqbuf, length);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error)
		goto fail;

	si = (struct safte_inq *)&inqbuf->extra;
	if (memcmp(si->ident, SAFTE_IDENT, sizeof(si->ident)) == 0) {
		dma_free(inqbuf, sizeof(*inqbuf));
		return (2);
	}

fail:
	dma_free(inqbuf, sizeof(*inqbuf));
	return (0);
}

void
safte_attach(struct device *parent, struct device *self, void *aux)
{
	struct safte_softc		*sc = (struct safte_softc *)self;
	struct scsi_attach_args		*sa = aux;
	int				i = 0;

	sc->sc_link = sa->sa_sc_link;
	sa->sa_sc_link->device_softc = sc;
	rw_init(&sc->sc_lock, DEVNAME(sc));

	printf("\n");

	sc->sc_encbuf = NULL;
	sc->sc_nsensors = 0;
#if NBIO > 0
	sc->sc_nslots = 0;
#endif

	if (safte_read_config(sc) != 0) {
		printf("%s: unable to read enclosure configuration\n",
		    DEVNAME(sc));
		return;
	}

	if (sc->sc_nsensors > 0) {
		sc->sc_sensortask = sensor_task_register(sc,
		    safte_read_encstat, 10);
		if (sc->sc_sensortask == NULL) {
			printf("%s: unable to register update task\n",
			    DEVNAME(sc));
			free(sc->sc_sensors, M_DEVBUF,
			    sc->sc_nsensors * sizeof(struct safte_sensor));
			sc->sc_nsensors = sc->sc_ntemps = 0;
		} else {
			for (i = 0; i < sc->sc_nsensors; i++)
				sensor_attach(&sc->sc_sensordev,
				    &sc->sc_sensors[i].se_sensor);
			sensordev_install(&sc->sc_sensordev);
		}
	}

#if NBIO > 0
	if (sc->sc_nslots > 0 &&
	    bio_register(self, safte_ioctl) != 0) {
		printf("%s: unable to register ioctl with bio\n", DEVNAME(sc));
		sc->sc_nslots = 0;
	} else
		i++;
#endif

	if (i) /* if we're doing something, then preinit encbuf and sensors */
		safte_read_encstat(sc);
	else {
		dma_free(sc->sc_encbuf, sc->sc_encbuflen);
		sc->sc_encbuf = NULL;
	}
}

int
safte_detach(struct device *self, int flags)
{
	struct safte_softc		*sc = (struct safte_softc *)self;
	int				i;

	rw_enter_write(&sc->sc_lock);

#if NBIO > 0
	if (sc->sc_nslots > 0)
		bio_unregister(self);
#endif

	if (sc->sc_nsensors > 0) {
		sensordev_deinstall(&sc->sc_sensordev);
		sensor_task_unregister(sc->sc_sensortask);

		for (i = 0; i < sc->sc_nsensors; i++)
			sensor_detach(&sc->sc_sensordev,
			    &sc->sc_sensors[i].se_sensor);
		free(sc->sc_sensors, M_DEVBUF,
		    sc->sc_nsensors * sizeof(struct safte_sensor));
	}

	if (sc->sc_encbuf != NULL)
		dma_free(sc->sc_encbuf, sc->sc_encbuflen);

	rw_exit_write(&sc->sc_lock);

	return (0);
}

int
safte_read_config(struct safte_softc *sc)
{
	struct safte_config *config = NULL;
	struct safte_readbuf_cmd *cmd;
	struct safte_sensor *s;
	struct scsi_xfer *xs;
	int error = 0, flags = 0, i, j;

	config = dma_alloc(sizeof(*config), PR_NOWAIT);
	if (config == NULL)
		return (1);

	if (cold)
		flags |= SCSI_AUTOCONF;
	xs = scsi_xs_get(sc->sc_link, flags | SCSI_DATA_IN | SCSI_SILENT);
	if (xs == NULL) {
		error = 1;
		goto done;
	}
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)config;
	xs->datalen = sizeof(*config);
	xs->retries = 2;
	xs->timeout = 30000;

	cmd = (struct safte_readbuf_cmd *)xs->cmd;
	cmd->opcode = READ_BUFFER;
	cmd->flags |= SAFTE_RD_MODE;
	cmd->bufferid = SAFTE_RD_CONFIG;
	cmd->length = htobe16(sizeof(*config));

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error != 0) {
		error = 1;
		goto done;
	}

	DPRINTF(("%s: nfans: %d npwrsup: %d nslots: %d doorlock: %d ntemps: %d"
	    " alarm: %d celsius: %d ntherm: %d\n", DEVNAME(sc), config->nfans,
	    config->npwrsup, config->nslots, config->doorlock, config->ntemps,
	    config->alarm, SAFTE_CFG_CELSIUS(config->therm),
	    SAFTE_CFG_NTHERM(config->therm)));

	sc->sc_encbuflen = config->nfans * sizeof(u_int8_t) + /* fan status */
	    config->npwrsup * sizeof(u_int8_t) + /* power supply status */
	    config->nslots * sizeof(u_int8_t) + /* device scsi id (lun) */
	    sizeof(u_int8_t) + /* door lock status */
	    sizeof(u_int8_t) + /* speaker status */
	    config->ntemps * sizeof(u_int8_t) + /* temp sensors */
	    sizeof(u_int16_t); /* temp out of range sensors */

	sc->sc_encbuf = dma_alloc(sc->sc_encbuflen, PR_NOWAIT);
	if (sc->sc_encbuf == NULL) {
		error = 1;
		goto done;
	}

	sc->sc_nsensors = config->nfans + config->npwrsup + config->ntemps +
		(config->doorlock ? 1 : 0) + (config->alarm ? 1 : 0);

	sc->sc_sensors = mallocarray(sc->sc_nsensors, sizeof(struct safte_sensor),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sc_sensors == NULL) {
		dma_free(sc->sc_encbuf, sc->sc_encbuflen);
		sc->sc_encbuf = NULL;
		sc->sc_nsensors = 0;
		error = 1;
		goto done;
	}

	strlcpy(sc->sc_sensordev.xname, DEVNAME(sc),
	    sizeof(sc->sc_sensordev.xname));

	s = sc->sc_sensors;

	for (i = 0; i < config->nfans; i++) {
		s->se_type = SAFTE_T_FAN;
		s->se_field = (u_int8_t *)(sc->sc_encbuf + i);
		s->se_sensor.type = SENSOR_INDICATOR;
		snprintf(s->se_sensor.desc, sizeof(s->se_sensor.desc),
		    "Fan%d", i);

		s++;
	}
	j = config->nfans;

	for (i = 0; i < config->npwrsup; i++) {
		s->se_type = SAFTE_T_PWRSUP;
		s->se_field = (u_int8_t *)(sc->sc_encbuf + j + i);
		s->se_sensor.type = SENSOR_INDICATOR;
		snprintf(s->se_sensor.desc, sizeof(s->se_sensor.desc),
		    "PSU%d", i);

		s++;
	}
	j += config->npwrsup;

#if NBIO > 0
	sc->sc_nslots = config->nslots;
	sc->sc_slots = (u_int8_t *)(sc->sc_encbuf + j);
#endif
	j += config->nslots;

	if (config->doorlock) {
		s->se_type = SAFTE_T_DOORLOCK;
		s->se_field = (u_int8_t *)(sc->sc_encbuf + j);
		s->se_sensor.type = SENSOR_INDICATOR;
		strlcpy(s->se_sensor.desc, "doorlock",
		    sizeof(s->se_sensor.desc));

		s++;
	}
	j++;

	if (config->alarm) {
		s->se_type = SAFTE_T_ALARM;
		s->se_field = (u_int8_t *)(sc->sc_encbuf + j);
		s->se_sensor.type = SENSOR_INDICATOR;
		strlcpy(s->se_sensor.desc, "alarm", sizeof(s->se_sensor.desc));

		s++;
	}
	j++;

	/*
	 * stash the temp info so we can get out of range status. limit the
	 * number so the out of temp checks cant go into memory it doesnt own
	 */
	sc->sc_ntemps = (config->ntemps > 15) ? 15 : config->ntemps;
	sc->sc_temps = s;
	sc->sc_celsius = SAFTE_CFG_CELSIUS(config->therm);
	for (i = 0; i < config->ntemps; i++) {
		s->se_type = SAFTE_T_TEMP;
		s->se_field = (u_int8_t *)(sc->sc_encbuf + j + i);
		s->se_sensor.type = SENSOR_TEMP;

		s++;
	}
	j += config->ntemps;

	sc->sc_temperrs = (u_int8_t *)(sc->sc_encbuf + j);
done:
	dma_free(config, sizeof(*config));
	return (error);
}

void
safte_read_encstat(void *arg)
{
	struct safte_readbuf_cmd *cmd;
	struct safte_sensor *s;
	struct safte_softc *sc = (struct safte_softc *)arg;
	struct scsi_xfer *xs;
	int error, i, flags = 0;
	u_int16_t oot;

	rw_enter_write(&sc->sc_lock);

	if (cold)
		flags |= SCSI_AUTOCONF;
	xs = scsi_xs_get(sc->sc_link, flags | SCSI_DATA_IN | SCSI_SILENT);
	if (xs == NULL) {
		rw_exit_write(&sc->sc_lock);
		return;
	}
	xs->cmdlen = sizeof(*cmd);
	xs->data = sc->sc_encbuf;
	xs->datalen = sc->sc_encbuflen;
	xs->retries = 2;
	xs->timeout = 30000;

	cmd = (struct safte_readbuf_cmd *)xs->cmd;
	cmd->opcode = READ_BUFFER;
	cmd->flags |= SAFTE_RD_MODE;
	cmd->bufferid = SAFTE_RD_ENCSTAT;
	cmd->length = htobe16(sc->sc_encbuflen);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error != 0) {
		rw_exit_write(&sc->sc_lock);
		return;
	}

	for (i = 0; i < sc->sc_nsensors; i++) {
		s = &sc->sc_sensors[i];
		s->se_sensor.flags &= ~SENSOR_FUNKNOWN;

		DPRINTF(("%s: %d type: %d field: 0x%02x\n", DEVNAME(sc), i,
		    s->se_type, *s->se_field));

		switch (s->se_type) {
		case SAFTE_T_FAN:
			switch (*s->se_field) {
			case SAFTE_FAN_OP:
				s->se_sensor.value = 1;
				s->se_sensor.status = SENSOR_S_OK;
				break;
			case SAFTE_FAN_MF:
				s->se_sensor.value = 0;
				s->se_sensor.status = SENSOR_S_CRIT;
				break;
			case SAFTE_FAN_NOTINST:
			case SAFTE_FAN_UNKNOWN:
			default:
				s->se_sensor.value = 0;
				s->se_sensor.status = SENSOR_S_UNKNOWN;
				s->se_sensor.flags |= SENSOR_FUNKNOWN;
				break;
			}
			break;

		case SAFTE_T_PWRSUP:
			switch (*s->se_field) {
			case SAFTE_PWR_OP_ON:
				s->se_sensor.value = 1;
				s->se_sensor.status = SENSOR_S_OK;
				break;
			case SAFTE_PWR_OP_OFF:
				s->se_sensor.value = 0;
				s->se_sensor.status = SENSOR_S_OK;
				break;
			case SAFTE_PWR_MF_ON:
				s->se_sensor.value = 1;
				s->se_sensor.status = SENSOR_S_CRIT;
				break;
			case SAFTE_PWR_MF_OFF:
				s->se_sensor.value = 0;
				s->se_sensor.status = SENSOR_S_CRIT;
				break;
			case SAFTE_PWR_NOTINST:
			case SAFTE_PWR_PRESENT:
			case SAFTE_PWR_UNKNOWN:
				s->se_sensor.value = 0;
				s->se_sensor.status = SENSOR_S_UNKNOWN;
				s->se_sensor.flags |= SENSOR_FUNKNOWN;
				break;
			}
			break;

		case SAFTE_T_DOORLOCK:
			switch (*s->se_field) {
			case SAFTE_DOOR_LOCKED:
				s->se_sensor.value = 1;
				s->se_sensor.status = SENSOR_S_OK;
				break;
			case SAFTE_DOOR_UNLOCKED:
				s->se_sensor.value = 0;
				s->se_sensor.status = SENSOR_S_CRIT;
				break;
			case SAFTE_DOOR_UNKNOWN:
				s->se_sensor.value = 0;
				s->se_sensor.status = SENSOR_S_CRIT;
				s->se_sensor.flags |= SENSOR_FUNKNOWN;
				break;
			}
			break;

		case SAFTE_T_ALARM:
			switch (*s->se_field) {
			case SAFTE_SPKR_OFF:
				s->se_sensor.value = 0;
				s->se_sensor.status = SENSOR_S_OK;
				break;
			case SAFTE_SPKR_ON:
				s->se_sensor.value = 1;
				s->se_sensor.status = SENSOR_S_CRIT;
				break;
			}
			break;

		case SAFTE_T_TEMP:
			s->se_sensor.value = safte_temp2uK(*s->se_field,
			    sc->sc_celsius);
			break;
		}
	}

	oot = _2btol(sc->sc_temperrs);
	for (i = 0; i < sc->sc_ntemps; i++)
		sc->sc_temps[i].se_sensor.status =
		    (oot & (1 << i)) ? SENSOR_S_CRIT : SENSOR_S_OK;

	rw_exit_write(&sc->sc_lock);
}

#if NBIO > 0
int
safte_ioctl(struct device *dev, u_long cmd, caddr_t addr)
{
	struct safte_softc		*sc = (struct safte_softc *)dev;
	int				error = 0;

	switch (cmd) {
	case BIOCBLINK:
		error = safte_bio_blink(sc, (struct bioc_blink *)addr);
		break;

	default:
		error = EINVAL;
		break;
	}

	return (error);
}

int
safte_bio_blink(struct safte_softc *sc, struct bioc_blink *blink)
{
	struct safte_writebuf_cmd *cmd;
	struct safte_slotop *op;
	struct scsi_xfer *xs;
	int error, slot, flags = 0, wantblink;

	switch (blink->bb_status) {
	case BIOC_SBBLINK:
		wantblink = 1;
		break;
	case BIOC_SBUNBLINK:
		wantblink = 0;
		break;
	default:
		return (EINVAL);
	}

	rw_enter_read(&sc->sc_lock);
	for (slot = 0; slot < sc->sc_nslots; slot++) {
		if (sc->sc_slots[slot] == blink->bb_target)
			break;
	}
	rw_exit_read(&sc->sc_lock);

	if (slot >= sc->sc_nslots)
		return (ENODEV);

	op = dma_alloc(sizeof(*op), PR_WAITOK | PR_ZERO);

	op->opcode = SAFTE_WRITE_SLOTOP;
	op->slot = slot;
	op->flags |= wantblink ? SAFTE_SLOTOP_IDENTIFY : 0;

	if (cold)
		flags |= SCSI_AUTOCONF;
	xs = scsi_xs_get(sc->sc_link, flags | SCSI_DATA_OUT | SCSI_SILENT);
	if (xs == NULL) {
		dma_free(op, sizeof(*op));
		return (ENOMEM);
	}
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)op;
	xs->datalen = sizeof(*op);
	xs->retries = 2;
	xs->timeout = 30000;

	cmd = (struct safte_writebuf_cmd *)xs->cmd;
	cmd->opcode = WRITE_BUFFER;
	cmd->flags |= SAFTE_WR_MODE;
	cmd->length = htobe16(sizeof(struct safte_slotop));

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error != 0) {
		error = EIO;
	}
	dma_free(op, sizeof(*op));

	return (error);
}
#endif /* NBIO > 0 */

int64_t
safte_temp2uK(u_int8_t measured, int celsius)
{
	int64_t				temp;

	temp = (int64_t)measured;
	temp += SAFTE_TEMP_OFFSET;
	temp *= 1000000; /* convert to micro (mu) degrees */
	if (!celsius)
		temp = ((temp - 32000000) * 5) / 9; /* convert to Celsius */

	temp += 273150000; /* convert to kelvin */

	return (temp);
}
@


1.52
log
@More damned eye searing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.51 2014/09/14 14:17:26 jsg Exp $ */
d202 2
a204 1
			free(sc->sc_sensors, M_DEVBUF, 0);
d250 2
a251 1
		free(sc->sc_sensors, M_DEVBUF, 0);
@


1.51
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.50 2014/07/13 17:34:25 deraadt Exp $ */
d126 1
a126 1
 	if ((inq->device & SID_TYPE) != T_PROCESSOR ||
d206 1
a206 1
				sensor_attach(&sc->sc_sensordev, 
d247 1
a247 1
			sensor_detach(&sc->sc_sensordev, 
d320 1
a320 1
	sc->sc_nsensors = config->nfans + config->npwrsup + config->ntemps + 
d544 1
a544 1
		sc->sc_temps[i].se_sensor.status = 
d615 1
a615 1
	xs->retries = 2; 
@


1.50
log
@use mallocarray where arguments are multiplied; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.49 2014/07/12 18:50:25 tedu Exp $ */
a26 1
#include <sys/proc.h>
@


1.49
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.48 2011/06/15 01:10:05 dlg Exp $ */
d324 1
a324 1
	sc->sc_sensors = malloc(sc->sc_nsensors * sizeof(struct safte_sensor),
@


1.48
log
@factor the common bits out of code that builds scsi inquiry commands into
scsi_init_inquiry(). cut the compiled INQUIRY code over to it.

ok and tweaks from krw@@
ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.47 2011/03/17 21:30:24 deraadt Exp $ */
d204 1
a204 1
			free(sc->sc_sensors, M_DEVBUF);
d250 1
a250 1
		free(sc->sc_sensors, M_DEVBUF);
@


1.47
log
@use dma_alloc/dma_free instead of malloc to allocate buffers which need
to be in the right address space.
help from matthew and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.46 2010/09/27 19:49:43 thib Exp $ */
a114 1
	struct scsi_inquiry *cmd;
d149 1
a149 3
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)inqbuf;
	xs->datalen = length;
d153 1
a153 3
	cmd = (struct scsi_inquiry *)xs->cmd;
	cmd->opcode = INQUIRY;
	_lto2b(length, cmd->length);
@


1.46
log
@A few M_ZEROs without any M_WAITOK/M_NOWAITs.
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.45 2010/08/30 02:47:56 matthew Exp $ */
d26 1
d112 1
a112 1
	struct scsi_inquiry_data inqbuf;
a119 2
	si = (struct safte_inq *)&inqbuf.extra;

d128 1
a128 1
	if ((inq->device & SID_TYPE) != T_PROCESSOR ||
d136 8
a143 2
	if (length > sizeof(inqbuf))
		length = sizeof(inqbuf);
d149 1
a149 1
		return (0);
d151 1
a151 1
	xs->data = (void *)&inqbuf;
a159 3
	memset(&inqbuf, 0, sizeof(inqbuf));
	memset(&inqbuf.extra, ' ', sizeof(inqbuf.extra));

d164 1
a164 1
		return (0);
d166 3
a168 1
	if (memcmp(si->ident, SAFTE_IDENT, sizeof(si->ident)) == 0)
d170 1
d172 2
d230 1
a230 1
		free(sc->sc_encbuf, M_DEVBUF);
d259 1
a259 1
		free(sc->sc_encbuf, M_DEVBUF);
d269 1
a269 1
	struct safte_config config;
d273 5
a277 1
	int error, flags = 0, i, j;
d282 4
a285 2
	if (xs == NULL)
		return (1);
d287 2
a288 2
	xs->data = (void *)&config;
	xs->datalen = sizeof(config);
d296 1
a296 1
	cmd->length = htobe16(sizeof(config));
d301 4
a304 2
	if (error != 0)
		return (1);
d307 8
a314 8
	    " alarm: %d celsius: %d ntherm: %d\n", DEVNAME(sc), config.nfans,
	    config.npwrsup, config.nslots, config.doorlock, config.ntemps,
	    config.alarm, SAFTE_CFG_CELSIUS(config.therm),
	    SAFTE_CFG_NTHERM(config.therm)));

	sc->sc_encbuflen = config.nfans * sizeof(u_int8_t) + /* fan status */
	    config.npwrsup * sizeof(u_int8_t) + /* power supply status */
	    config.nslots * sizeof(u_int8_t) + /* device scsi id (lun) */
d317 1
a317 1
	    config.ntemps * sizeof(u_int8_t) + /* temp sensors */
d320 5
a324 3
	sc->sc_encbuf = malloc(sc->sc_encbuflen, M_DEVBUF, M_NOWAIT);
	if (sc->sc_encbuf == NULL)
		return (1);
d326 2
a327 2
	sc->sc_nsensors = config.nfans + config.npwrsup + config.ntemps + 
		(config.doorlock ? 1 : 0) + (config.alarm ? 1 : 0);
d332 1
a332 1
		free(sc->sc_encbuf, M_DEVBUF);
d335 2
a336 1
		return (1);
d344 1
a344 1
	for (i = 0; i < config.nfans; i++) {
d353 1
a353 1
	j = config.nfans;
d355 1
a355 1
	for (i = 0; i < config.npwrsup; i++) {
d364 1
a364 1
	j += config.npwrsup;
d367 1
a367 1
	sc->sc_nslots = config.nslots;
d370 1
a370 1
	j += config.nslots;
d372 1
a372 1
	if (config.doorlock) {
d383 1
a383 1
	if (config.alarm) {
d397 1
a397 1
	sc->sc_ntemps = (config.ntemps > 15) ? 15 : config.ntemps;
d399 2
a400 2
	sc->sc_celsius = SAFTE_CFG_CELSIUS(config.therm);
	for (i = 0; i < config.ntemps; i++) {
d407 1
a407 1
	j += config.ntemps;
d410 3
a412 2

	return (0);
d605 1
a605 1
	op = malloc(sizeof(*op), M_TEMP, M_WAITOK|M_ZERO);
d615 1
a615 1
		free(op, M_TEMP);
d635 1
a635 1
	free(op, M_TEMP);
@


1.45
log
@Avoid possible aliasing-related compiler issues by always writing to
cmd->opcode through the type casted command pointer rather than
through xs->cmd->opcode.

Requested by deraadt@@; ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.44 2010/07/22 15:59:47 matthew Exp $ */
d586 1
a586 1
	op = malloc(sizeof(*op), M_TEMP, M_ZERO);
@


1.44
log
@Fix a few more scsi_scsi_cmd() removal regressions, caught by
-Wuninitialized.

Silly typo in my first diff noticed by oga@@ and krw@@; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.43 2010/07/22 05:21:02 matthew Exp $ */
a144 1
	xs->cmd->opcode = INQUIRY;
d152 1
a272 1
	xs->cmd->opcode = READ_BUFFER;
d280 1
a414 1
	xs->cmd->opcode = READ_BUFFER;
d422 1
a598 1
	xs->cmd->opcode = WRITE_BUFFER;
d606 1
@


1.43
log
@style(9) fix and release rwlock(9) if scsi_xs_get() returns NULL,
which should never happen anyway.  Fixes scsi_scsi_cmd() removal
regression.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.42 2010/07/22 04:59:31 matthew Exp $ */
d606 1
@


1.42
log
@In safte_match(), return 0 on SCSI errors, not an errno value.  Fixes
regression from scsi_scsi_cmd() removal.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.41 2010/07/22 00:31:06 krw Exp $ */
d400 1
a400 1
	struct safte_sensor*s;
d411 2
a412 1
	if (xs == NULL)
d414 1
@


1.41
log
@Eliminate scsi_scsi_cmd() now that ss(4) is gone and with it the
last bastardized sync and buf call through scsi_scsi_cmd(). Flatten
code to call scsi_xs_sync() directly for all commands.

Airplane typos shaken out by various.

ok dlg@@ matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.40 2009/01/20 21:46:42 kettenis Exp $ */
d144 1
a144 1
		return (ENOMEM);
d161 5
a165 4
	if (error == 0) {
		if (memcmp(si->ident, SAFTE_IDENT, sizeof(si->ident)) == 0)
			return (2);
	}
d167 1
a167 1
	return (error);
@


1.40
log
@Prevent unaligned access.

ok miod@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.39 2007/09/16 01:30:24 krw Exp $ */
d111 9
a119 6
	struct scsi_attach_args		*sa = aux;
	struct scsi_inquiry_data	*inq = sa->sa_inqbuf;
	struct scsi_inquiry_data	inqbuf;
	struct scsi_inquiry		cmd;
	struct safte_inq		*si = (struct safte_inq *)&inqbuf.extra;
	int				length, flags;
d140 14
a153 3
	memset(&cmd, 0, sizeof(cmd));
	cmd.opcode = INQUIRY;
	_lto2b(length, cmd.length);
d158 2
a159 8
	flags = SCSI_DATA_IN;
	if (cold)
		flags |= SCSI_AUTOCONF;

	if (scsi_scsi_cmd(sa->sa_sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), (u_char *)&inqbuf, length, 2, 10000, NULL,
	    flags) != 0)
		return (0);
d161 4
a164 2
	if (memcmp(si->ident, SAFTE_IDENT, sizeof(si->ident)) == 0)
		return (2);
d166 1
a166 1
	return (0);
d261 5
a265 14
	struct safte_readbuf_cmd	cmd;
	struct safte_config		config;
	struct safte_sensor		*s;
	int				flags, i, j;

	memset(&cmd, 0, sizeof(cmd));
	cmd.opcode = READ_BUFFER;
	cmd.flags |= SAFTE_RD_MODE;
	cmd.bufferid = SAFTE_RD_CONFIG;
	cmd.length = htobe16(sizeof(config));
	flags = SCSI_DATA_IN;
#ifndef SCSIDEBUG
	flags |= SCSI_SILENT;
#endif
d269 17
d287 1
a287 3
	if (scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), (u_char *)&config, sizeof(config), 2, 30000, NULL,
	    flags) != 0)
d398 6
a403 5
	struct safte_softc		*sc = (struct safte_softc *)arg;
	struct safte_readbuf_cmd	cmd;
	int				flags, i;
	struct safte_sensor		*s;
	u_int16_t			oot;
a406 10
	memset(&cmd, 0, sizeof(cmd));
	cmd.opcode = READ_BUFFER;
	cmd.flags |= SAFTE_RD_MODE;
	cmd.bufferid = SAFTE_RD_ENCSTAT;
	cmd.length = htobe16(sc->sc_encbuflen);
	flags = SCSI_DATA_IN;
#ifndef SCSIDEBUG
	flags |= SCSI_SILENT;
#endif

d409 17
d427 1
a427 3
	if (scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), sc->sc_encbuf, sc->sc_encbuflen, 2, 30000, NULL,
	    flags) != 0) {
d557 4
a560 5
	struct safte_writebuf_cmd	cmd;
	struct safte_slotop		*op;
	int				slot;
	int				flags;
	int				wantblink;
a588 8
	memset(&cmd, 0, sizeof(cmd));
	cmd.opcode = WRITE_BUFFER;
	cmd.flags |= SAFTE_WR_MODE;
	cmd.length = htobe16(sizeof(struct safte_slotop));
	flags = SCSI_DATA_OUT;
#ifndef SCSIDEBUG
	flags |= SCSI_SILENT;
#endif
d591 2
a592 4

	if (scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), (u_char *)op, sizeof(struct safte_slotop),
	    2, 30000, NULL, flags) != 0) {
d594 1
a594 1
		return (EIO);
d596 12
d609 3
d614 1
a614 1
	return (0);
@


1.39
log
@MALLOC/FREE -> malloc/free, M_ZERO, extraneous casts,
extraneous #include <malloc.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.38 2007/09/07 16:15:49 krw Exp $ */
d80 1
a80 1
	u_int16_t		*sc_temperrs;
d374 1
a374 1
	sc->sc_temperrs = (u_int16_t *)(sc->sc_encbuf + j);
d504 1
a504 1
	oot = betoh16(*sc->sc_temperrs);
@


1.38
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.37 2007/06/24 05:34:35 dlg Exp $ */
d562 1
a562 1
	op = malloc(sizeof(struct safte_slotop), M_TEMP, M_ZERO);
@


1.37
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.36 2007/06/01 22:58:50 cnst Exp $ */
d296 1
a296 1
	    M_DEVBUF, M_NOWAIT);
a306 2
	memset(sc->sc_sensors, 0,
	    sc->sc_nsensors * sizeof(struct safte_sensor));
d562 1
a562 1
	op = malloc(sizeof(struct safte_slotop), M_TEMP, 0);
a563 1
	memset(op, 0, sizeof(struct safte_slotop));
@


1.36
log
@backout r1.33: temperature sensor description was removed on purpose,
because it started to be part of the sysctl variable name

ok deanna@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.35 2007/04/03 04:15:50 dlg Exp $ */
d75 1
d184 14
a197 10
	if (sc->sc_nsensors > 0 &&
	    sensor_task_register(sc, safte_read_encstat, 10) != 0) {
		printf("%s: unable to register update task\n", DEVNAME(sc));
		sc->sc_nsensors = sc->sc_ntemps = 0;
		free(sc->sc_sensors, M_DEVBUF);
	} else {
		for (i = 0; i < sc->sc_nsensors; i++)
			sensor_attach(&sc->sc_sensordev, 
			    &sc->sc_sensors[i].se_sensor);
		sensordev_install(&sc->sc_sensordev);
d232 1
a232 1
		sensor_task_unregister(sc);
@


1.35
log
@modernise scsi_inquiry. the length field has grown and now theres pages to
query.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.34 2007/03/22 16:55:31 deraadt Exp $ */
a365 2
		snprintf(s->se_sensor.desc, sizeof(s->se_sensor.desc),
		    "Temp%d", i);
@


1.34
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.33 2007/02/21 22:37:38 deanna Exp $ */
d115 1
a115 1
	int				flags;
d130 6
d138 1
a138 6
	cmd.length = inq->additional_length + SAFTE_EXTRA_OFFSET;
	if (cmd.length < SAFTE_INQ_LEN)
		return (0);

	if (cmd.length > sizeof(inqbuf))
		cmd.length = sizeof(inqbuf);
d148 1
a148 1
	    sizeof(cmd), (u_char *)&inqbuf, cmd.length, 2, 10000, NULL,
@


1.33
log
@Add missing sensor description for temperature.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.32 2006/12/23 17:46:39 deraadt Exp $ */
d53 1
a53 1
	struct sensor		se_sensor;
d74 1
a74 1
	struct sensordev	sc_sensordev;
@


1.32
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.31 2006/11/28 16:56:50 dlg Exp $ */
d365 2
@


1.31
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.30 2006/10/01 10:42:18 grange Exp $ */
d74 1
d189 3
a191 1
			sensor_add(&sc->sc_sensors[i].se_sensor);
d225 1
d229 2
a230 1
			sensor_del(&sc->sc_sensors[i].se_sensor);
d298 3
a364 2
		snprintf(s->se_sensor.desc, sizeof(s->se_sensor.desc),
		    "Temp%d", i);
a370 4

	for (i = 0; i < sc->sc_nsensors; i++)
		strlcpy(sc->sc_sensors[i].se_sensor.device, DEVNAME(sc),
		    sizeof(sc->sc_sensors[i].se_sensor.device));
@


1.30
log
@Free sensors on detach.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.29 2006/07/29 02:40:45 krw Exp $ */
d109 1
a109 1
	struct scsibus_attach_args	*sa = aux;
d160 1
a160 1
	struct scsibus_attach_args	*sa = aux;
@


1.29
log
@The version field of scsi_inquiry_data is not a simple numeric value
that specifies the version of SCSI being supported. Even the ANSI part
that we use is complex. 4 means 2, 5 means 3 and 6 means 4. Translate
and use the value correctly. Fixes SCSI5 and SCSI6 in dmesg. And
properly protects SCSI2 devices from getting SCSI3 commands.

"seems like an elegant solution to me" millert@@ ok dlg@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.28 2006/05/21 03:10:49 dlg Exp $ */
a223 4
		/*
		 * we can't free the sensors since there is no mechanism to
		 * take them out of the sensor list. mark them invalid instead.
		 */
d225 2
a226 1
			sc->sc_sensors[i].se_sensor.flags |= SENSOR_FINVALID;
@


1.28
log
@replace lockmgr with rwlock.
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.27 2006/05/09 05:51:54 deraadt Exp $ */
d121 1
a121 1
	    (inq->version & SID_ANSII) == SID_ANSII_SCSI3)
d125 2
a126 2
	    (inq->version & SID_ANSII) != SID_ANSII_SCSI2 ||
	    (inq->response_format & SID_ANSII) != SID_ANSII_SCSI2)
@


1.27
log
@make sensor names look more normal; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.26 2006/01/19 17:08:40 grange Exp $ */
d27 1
a27 1
#include <sys/lock.h>
d67 1
a67 1
	struct lock		sc_lock;
d165 1
a165 1
	lockinit(&sc->sc_lock, PZERO, DEVNAME(sc), 0, 0);
d214 1
a214 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d235 1
a235 2
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
	lockmgr(&sc->sc_lock, LK_DRAIN, NULL);
d385 1
a385 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d403 1
a403 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d506 1
a506 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
d549 1
a549 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL);
d554 1
a554 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
@


1.26
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.25 2006/01/11 08:21:21 dlg Exp $ */
d306 1
a306 1
		    "fan%d", i);
d317 1
a317 1
		    "psu%d", i);
d362 1
a362 1
		    "temp%d", i);
@


1.25
log
@dont print anything if we're unable to read the status page

requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.24 2005/12/02 04:23:17 krw Exp $ */
d188 1
a188 1
			SENSOR_ADD(&sc->sc_sensors[i].se_sensor);
@


1.24
log
@Missing 'break;'. Spotted by lint.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.23 2005/11/19 02:18:01 pedro Exp $ */
a404 1
		printf("%s: unable to read enclosure status\n", DEVNAME(sc));
@


1.23
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.22 2005/11/13 02:26:48 dlg Exp $ */
d494 1
@


1.22
log
@lock updates to the buffer with the enclosure status in it so that one
process cant read from it while another one is fetching it from the scsi
device.

looks ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.20 2005/11/11 01:19:47 fgsch Exp $ */
d214 1
a214 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);
d235 2
a236 2
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
	lockmgr(&sc->sc_lock, LK_DRAIN, NULL, curproc);
d386 1
a386 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);
d404 1
a404 1
		lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d507 1
a507 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d550 1
a550 1
	lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);
d555 1
a555 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
@


1.21
log
@there are two things that safte does: update sensors and blink lights. if
attach figures out that we cant do either of them, then free up all the
resources.
@
text
@d26 2
d67 1
d165 1
d214 2
d235 3
d386 2
d404 1
d506 2
d550 1
d555 1
@


1.20
log
@include sys/device.h. builds on sparc. dlg@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.19 2005/11/10 22:27:03 dlg Exp $ */
d158 1
a158 1
	int				i;
d180 2
a181 1
		sc->sc_nsensors = 0;
d192 9
a201 1
#endif
a208 1

@


1.19
log
@remove half the includes since they seem to be unnecessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.18 2005/11/10 13:24:51 dlg Exp $ */
d23 1
@


1.18
log
@i am a stupid head. unbreak kernels that done have the bio(4) device.

reported and fixed by Michael Knudsen.
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.17 2005/11/10 08:36:37 dlg Exp $ */
a20 1
#include <sys/types.h>
a22 2
#include <sys/kernel.h>
#include <sys/stat.h>
a23 1
#include <sys/uio.h>
a24 2
#include <sys/device.h>
#include <sys/conf.h>
a25 1
#include <sys/kthread.h>
a32 1
#include <scsi/scsi_disk.h>
@


1.17
log
@cut safte over to using the generic sensors kthread.
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.16 2005/08/24 03:39:52 dlg Exp $ */
d174 1
d176 1
@


1.16
log
@dont reject safte devices that have more inquiry information than the
space we want to store it in. thanks to mtu for providing access to
hardware for this.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.15 2005/08/23 05:29:42 marco Exp $ */
a68 2
struct safte_thread;

a87 2

	struct safte_thread	*sc_thread;
a99 7
struct safte_thread {
	struct safte_softc	*sc;
	volatile int		running;
};

void	safte_create_thread(void *);
void	safte_refresh(void *);
d101 1
a101 1
int	safte_read_encstat(struct safte_softc *);
d165 1
d172 6
a177 3
	sc->sc_thread = malloc(sizeof(struct safte_thread), M_DEVBUF, M_NOWAIT);
	if (sc->sc_thread == NULL) {
		printf("%s: unable to allocate thread information\n",
d182 8
a189 2
	sc->sc_thread->sc = sc;
	sc->sc_thread->running = 1;
d192 2
a193 2
	if (bio_register(self, safte_ioctl) != 0) {
		free(sc->sc_thread, M_DEVBUF);
d195 1
a195 1
		return;
a197 13

	if (safte_read_config(sc) != 0) {
#if NBIO > 0
		bio_unregister(self);
#endif
		free(sc->sc_thread, M_DEVBUF);
		sc->sc_thread = NULL;
		printf("%s: unable to read enclosure configuration\n",
		    DEVNAME(sc));
		return;
	}

	kthread_create_deferred(safte_create_thread, sc);
a205 4
	if (sc->sc_thread != NULL) {
		sc->sc_thread->running = 0;
		wakeup(sc->sc_thread);
		sc->sc_thread = NULL;
d208 1
d212 3
d221 1
d223 1
a224 1
	}
a228 37
void
safte_create_thread(void *arg)
{
	struct safte_softc		*sc = arg;

	if (kthread_create(safte_refresh, sc->sc_thread, NULL,
	    DEVNAME(sc)) != 0)
		panic("safte thread");
}

void
safte_refresh(void *arg)
{
	struct safte_thread		*thread = arg;
	struct safte_softc		*sc = thread->sc;
	int				ok = 1;

	while (thread->running) {
		if (safte_read_encstat(sc) != 0) {
			if (ok)
				printf("%s: error getting enclosure status\n",
				    DEVNAME(sc));
			ok = 0;
		} else {
			if (!ok)
				printf("%s: enclosure back online\n",
				    DEVNAME(sc));
			ok = 1;
		}
		tsleep(thread, PWAIT, "timeout", 10 * hz);
	}

	free(thread, M_DEVBUF);

	kthread_exit(0);
}

d280 2
d358 1
a358 1
	for (i = 0; i < sc->sc_nsensors; i++) {
a360 2
		SENSOR_ADD(&sc->sc_sensors[i].se_sensor);
	}
d365 2
a366 2
int
safte_read_encstat(struct safte_softc *sc)
d368 1
d389 4
a392 2
	    flags) != 0)
		return (1);
a490 2

	return(0);
@


1.15
log
@Test for cold and apply relevant flags for all scsi commands.

ok dlg@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.14 2005/08/22 19:24:45 deraadt Exp $ */
d147 5
a151 2
	if (cmd.length > sizeof(inqbuf) || cmd.length < SAFTE_INQ_LEN)
		return(0);
@


1.14
log
@check for scsi_autoconf state, spotted by marco; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.13 2005/08/21 23:28:59 deraadt Exp $ */
d129 1
d153 4
d159 1
a159 1
	    SCSI_DATA_IN|SCSI_AUTOCONF) != 0)
d289 1
a289 1
	flags = SCSI_DATA_IN | SCSI_AUTOCONF;
d294 1
a294 1
	if (scsi_autoconf)
d430 3
d602 2
@


1.13
log
@handle the unblink request; ok dlg marco krw
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.12 2005/08/18 09:51:05 dlg Exp $ */
d288 3
@


1.12
log
@das blinkenlighten! uses /dev/bio to allow an ioctl to turn identify on
for a particular target
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.11 2005/08/17 00:07:08 dlg Exp $ */
d555 1
d557 8
a564 1
	if (blink->bb_status != BIOC_SBBLINK)
d566 1
d581 1
a581 1
	op->flags |= SAFTE_SLOTOP_IDENTIFY;
@


1.11
log
@dont increment the offset both in and out of the loop while reading the
config

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.10 2005/08/15 21:48:03 dlg Exp $ */
d19 2
d35 4
d86 5
d114 5
d184 8
d193 3
a202 1

d217 4
d346 7
a352 1
	j += config.npwrsup + config.nslots; /* skip the slots for now */
d527 68
@


1.10
log
@free the right buffer on error

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.9 2005/08/13 01:38:19 dlg Exp $ */
d309 1
a309 1
		s->se_field = (u_int8_t *)(sc->sc_encbuf + j++ + i);
@


1.9
log
@let safte match on dell enclosures too. ses takes precedence though

ok marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.8 2005/08/12 08:50:08 dlg Exp $ */
d288 1
a288 1
		free(sc->sc_sensors, M_DEVBUF);
@


1.8
log
@rewrite the reading of the status page, which in turn adds support for
monitoring the fans, powersupplies, doorlock, and  alarm as well the temps.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.7 2005/08/10 10:55:33 dlg Exp $ */
d117 5
d142 1
a142 1
		return (24);
@


1.7
log
@use the appropriate flags to scsi_scsi_cmd during autoconf so we dont spin
forever on mp kernels

problem reported by matthieu baptiste
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.6 2005/08/08 18:43:09 marco Exp $ */
d51 12
d66 5
a70 2
	struct device	sc_dev;
	struct scsi_link *sc_link;
d72 9
a80 15
	u_int		sc_nfans;
	u_int		sc_npwrsup;
	u_int		sc_nslots;
	u_int		sc_ntemps;
	u_int		sc_ntherm;
	int		sc_flags;
#define SAFTE_FL_DOORLOCK	(1<<0)
#define SAFTE_FL_ALARM		(1<<1)
#define SAFTE_FL_CELSIUS	(1<<2)
	size_t		sc_encstatlen;
	u_char		*sc_encbuf;

	int		sc_nsensors;
	struct sensor	*sc_sensors;
	struct safte_thread *sc_thread;
d94 2
a95 2
	struct safte_softc *sc;
	volatile int	running;
d101 1
a101 1
int	safte_read_encstat(struct safte_softc *, int);
a147 2
	int				i;

a170 55
	sc->sc_nsensors = sc->sc_ntemps; /* XXX we could do more than temp */
	if (sc->sc_nsensors == 0) {
		free(sc->sc_thread, M_DEVBUF);
		sc->sc_thread = NULL;
		return;
	}

	sc->sc_sensors = malloc(sc->sc_nsensors * sizeof(struct sensor),
	    M_DEVBUF, M_NOWAIT);
	if (sc->sc_sensors == NULL) {
		free(sc->sc_thread, M_DEVBUF);
		sc->sc_thread = NULL;
		printf("%s: unable to allocate sensor storage\n", DEVNAME(sc));
		return;
	}
	memset(sc->sc_sensors, 0, sc->sc_nsensors * sizeof(struct sensor));

	for (i = 0; i < sc->sc_ntemps; i++) {
		sc->sc_sensors[i].type = SENSOR_TEMP;
		snprintf(sc->sc_sensors[i].desc,
		    sizeof(sc->sc_sensors[i].desc), "temp%d", i);
	}

	sc->sc_encstatlen = sc->sc_nfans * sizeof(u_int8_t) + /* fan status */
	    sc->sc_npwrsup * sizeof(u_int8_t) + /* power supply status */
	    sc->sc_nslots * sizeof(u_int8_t) + /* device scsi id (lun) */
	    sizeof(u_int8_t) + /* door lock status */
	    sizeof(u_int8_t) + /* speaker status */
	    sc->sc_ntemps * sizeof(u_int8_t) + /* temp sensors */
	    sizeof(u_int16_t); /* temp out of range sensors */

	sc->sc_encbuf = malloc(sc->sc_encstatlen, M_DEVBUF, M_NOWAIT);
	if (sc->sc_encbuf == NULL) {
		free(sc->sc_sensors, M_DEVBUF);
		free(sc->sc_thread, M_DEVBUF);
		sc->sc_thread = NULL;
		printf("%s: unable to allocate enclosure status buffer\n",
		    DEVNAME(sc));
		return;
	}

	if (safte_read_encstat(sc, 1) != 0) {
		free(sc->sc_encbuf, M_DEVBUF);
		free(sc->sc_sensors, M_DEVBUF);
		free(sc->sc_thread, M_DEVBUF);
		sc->sc_thread = NULL;
		printf("%s: unable to read enclosure status\n", DEVNAME(sc));
		return;
	}

	for (i = 0; i < sc->sc_nsensors; i++) {
		strlcpy(sc->sc_sensors[i].device, DEVNAME(sc),
		    sizeof(sc->sc_sensors[i].device));
		SENSOR_ADD(&sc->sc_sensors[i]);
	}
d191 1
a191 1
			sc->sc_sensors[i].flags |= SENSOR_FINVALID;
d217 1
a217 1
		if (safte_read_encstat(sc, 0) != 0) {
d241 2
a242 1
	int				flags;
d265 94
a358 8
	sc->sc_nfans = config.nfans;
	sc->sc_npwrsup = config.npwrsup;
	sc->sc_nslots = config.nslots;
	sc->sc_ntemps = config.ntemps;
	sc->sc_ntherm = SAFTE_CFG_NTHERM(config.therm);
	sc->sc_flags = (config.doorlock ? SAFTE_FL_DOORLOCK : 0) |
	    (config.alarm ? SAFTE_FL_ALARM : 0) |
	    (SAFTE_CFG_CELSIUS(config.therm) ? SAFTE_FL_CELSIUS : 0);
d364 1
a364 1
safte_read_encstat(struct safte_softc *sc, int autoconf)
d368 2
a369 2
	u_int8_t			*p = sc->sc_encbuf;
	struct sensor			*s = sc->sc_sensors;
d375 1
a375 1
	cmd.length = htobe16(sc->sc_encstatlen);
a379 2
	if (autoconf)
		flags |= SCSI_AUTOCONF;
d382 1
a382 1
	    sizeof(cmd), sc->sc_encbuf, sc->sc_encstatlen, 2, 30000, NULL,
d386 3
a388 11
	i = 0;
	while (i < sc->sc_nfans) {
		i++;
		p++;
	}

	i = 0;
	while (i < sc->sc_npwrsup) {
		i++;
		p++;
	}
d390 2
a391 5
	i = 0;
	while (i < sc->sc_nslots) {
		i++;
		p++;
	}
d393 84
a476 11
	/* doorlock */
	p++;
	/* alarm */
	p++;

	i = 0;
	while (i < sc->sc_ntemps) {
		s->value = safte_temp2uK(*p, sc->sc_flags & SAFTE_FL_CELSIUS);
		i++;
		s++;
		p++;
d479 4
a482 1
	/* temp over threshold (u_int16_t) */
@


1.6
log
@Fill in device structure, bad dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.5 2005/08/05 01:06:15 dlg Exp $ */
d92 1
a92 1
int	safte_read_encstat(struct safte_softc *);
d124 1
a124 1
	    SCSI_DATA_IN) != 0)
d205 1
a205 1
	if (safte_read_encstat(sc) != 0) {
d265 1
a265 1
		if (safte_read_encstat(sc) != 0) {
d296 1
a296 1
	flags = SCSI_DATA_IN;
d325 1
a325 1
safte_read_encstat(struct safte_softc *sc)
d341 2
@


1.5
log
@dont do an inquiry in attach just to print the safte revision number. it
is window dressing.

zap it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.3 2005/08/05 00:31:04 dlg Exp $ */
d142 1
@


1.4
log
@switch safte from using a scsi cmd at softclock to doing the commands
in a kernel thread. very similair to the same change in ses.c.

ok marco@@ beck@@ deraadt@@
@
text
@a138 4
	struct scsi_inquiry		cmd;
	struct scsi_inquiry_data	inq;
	struct safte_inq		*si = (struct safte_inq *)&inq.extra;
	char				rev[5]; /* sizeof(si->revision) + 1 */
a141 1
	sc->sc_thread = NULL;
d143 1
a143 16
	memset(&cmd, 0, sizeof(cmd));
	cmd.opcode = INQUIRY;
	cmd.length = SAFTE_INQ_LEN;
	memset(&inq, 0, sizeof(inq));
	memset(&inq.extra, ' ', sizeof(inq.extra));
	if (scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), (u_char *)&inq, cmd.length, 2, 10000, NULL,
	    SCSI_DATA_IN) != 0) {
		printf(": unable to get inquiry information\n");
		return;
	}

	memset(rev, 0, sizeof(rev));
	memcpy(rev, si->revision, sizeof(si->revision));

	printf(": rev %s\n", rev);
@


1.3
log
@READ BUFFER is a generic opcode, so dont define our own
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.2 2005/08/05 00:17:02 deraadt Exp $ */
d30 1
d51 1
a56 6
	enum {
		SAFTE_ST_NONE,
		SAFTE_ST_INIT,
		SAFTE_ST_ERR
	}		sc_state;

d71 1
a71 1
	struct timeout	sc_timeout;
d84 6
d92 1
a92 1
int	safte_read_encstat(struct safte_softc *, int refresh);
d146 1
a146 1
	sc->sc_state = SAFTE_ST_NONE;
d165 10
d176 2
d184 3
a186 1
	if (sc->sc_nsensors == 0)
d188 1
d193 2
d216 3
a220 1
		free(sc->sc_sensors, M_DEVBUF);
d224 1
a224 2
	if (safte_read_encstat(sc, 0) != 0) {
		printf("%s: unable to read enclosure status\n", DEVNAME(sc));
d227 3
a232 2
	sc->sc_state = SAFTE_ST_INIT;

d239 1
a239 2
	timeout_set(&sc->sc_timeout, safte_refresh, sc);
	timeout_add(&sc->sc_timeout, 10 * hz);
d248 4
a251 2
	if (sc->sc_state != SAFTE_ST_NONE) {
		timeout_del(&sc->sc_timeout);
a260 2

		sc->sc_state = SAFTE_ST_NONE;
d267 1
a267 1
safte_refresh(void *arg)
d271 25
a295 9
	if (safte_read_encstat(sc, 1) != 0) {
		if (sc->sc_state != SAFTE_ST_ERR)
			printf("%s: error getting enclosure status\n",
			    DEVNAME(sc));
		sc->sc_state = SAFTE_ST_ERR;
	} else {
		if (sc->sc_state != SAFTE_ST_INIT)
			printf("%s: enclosure back online\n", DEVNAME(sc));
		sc->sc_state = SAFTE_ST_INIT;
d297 4
a300 2
			
	timeout_add(&sc->sc_timeout, 10 * hz);
d344 1
a344 1
safte_read_encstat(struct safte_softc *sc, int refresh)
a359 2
	if (refresh)
		flags |= SCSI_NOSLEEP;
@


1.2
log
@shorten dmesg output
@
text
@d1 1
a1 1
/*	$OpenBSD: safte.c,v 1.1 2005/08/05 00:08:58 dlg Exp $ */
d273 1
a273 1
	cmd.opcode = SAFTE_RD_OPCODE;
d314 1
a314 1
	cmd.opcode = SAFTE_RD_OPCODE;
@


1.1
log
@make the naming of the safte files consisten with the rest of the scsi
drivers

ok krw@@ deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsi_safte.c,v 1.6 2005/07/28 10:11:30 dlg Exp $ */
a145 2
	printf("\n");

d154 1
a154 1
		printf("%s: unable to get inquiry information\n", DEVNAME(sc));
d161 1
a161 2
	printf("%s: SCSI Accessed Fault-Tolerant Enclosure rev %s\n",
	    DEVNAME(sc), rev);
@

