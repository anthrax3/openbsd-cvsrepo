head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.10
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.6
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.6.0.10
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.8
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.6
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.19
date	2015.06.07.19.13.27;	author krw;	state Exp;
branches;
next	1.18;
commitid	MxUWuiPFtM1nRYxm;

1.18
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.17;
commitid	p4LJxGKbi0BU2cG6;

1.17
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.16;
commitid	uzzBR7hz9ncd4O6G;

1.16
date	2014.04.20.00.50.18;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2014.04.03.04.02.50;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2013.11.23.23.35.02;	author gsoares;	state Exp;
branches;
next	1.12;

1.12
date	2013.08.27.00.57.44;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2013.08.27.00.53.10;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2013.08.27.00.24.03;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2013.08.26.10.13.17;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2013.08.26.07.38.56;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2013.08.26.07.29.45;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2011.07.11.01.02.48;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.03.15.47.18;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	2011.06.15.01.44.14;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2011.06.15.01.23.25;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.28.10.43.36;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.27.11.36.20;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.19
log
@More damned eye searing whitespace.
@
text
@/*	$OpenBSD: mpath_hds.c,v 1.18 2015/03/14 03:38:52 jsg Exp $ */

/*
 * Copyright (c) 2011 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Hitachi Modular Storage support for mpath(4) */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/queue.h>
#include <sys/rwlock.h>
#include <sys/pool.h>
#include <sys/ioctl.h>
#include <sys/poll.h>
#include <sys/selinfo.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/mpathvar.h>

#define HDS_INQ_LDEV_OFFSET	44
#define HDS_INQ_LDEV_LEN	4
#define HDS_INQ_CTRL_OFFSET	49
#define HDS_INQ_PORT_OFFSET	50
#define HDS_INQ_TYPE_OFFSET	128
#define HDS_INQ_TYPE		0x44463030 /* "DF00" */

#define HDS_VPD			0xe0

struct hds_vpd {
	struct scsi_vpd_hdr	hdr; /* HDS_VPD */
	u_int8_t		state;
#define HDS_VPD_VALID			0x80
#define HDS_VPD_PREFERRED		0x40

	/* followed by lots of unknown stuff */
};

#define HDS_SYMMETRIC		0
#define HDS_ASYMMETRIC		1

struct hds_softc {
	struct device		sc_dev;
	struct mpath_path	sc_path;
	struct scsi_xshandler	sc_xsh;
	struct hds_vpd		*sc_vpd;
	int			sc_mode;
	int			sc_ctrl;
};
#define DEVNAME(_s) ((_s)->sc_dev.dv_xname)

int		hds_match(struct device *, void *, void *);
void		hds_attach(struct device *, struct device *, void *);
int		hds_detach(struct device *, int);
int		hds_activate(struct device *, int);

struct cfattach hds_ca = {
	sizeof(struct hds_softc),
	hds_match,
	hds_attach,
	hds_detach,
	hds_activate
};

struct cfdriver hds_cd = {
	NULL,
	"hds",
	DV_DULL
};

void		hds_mpath_start(struct scsi_xfer *);
int		hds_mpath_checksense(struct scsi_xfer *);
void		hds_mpath_status(struct scsi_link *);

const struct mpath_ops hds_mpath_ops = {
	"hds",
	hds_mpath_checksense,
	hds_mpath_status
};

struct hds_device {
	char *vendor;
	char *product;
};

int		hds_inquiry(struct scsi_link *, int *);
int		hds_info(struct hds_softc *);

void		hds_status(struct scsi_xfer *);
void		hds_status_done(struct scsi_xfer *);

struct hds_device hds_devices[] = {
/*	  " vendor "  "     device     " */
/*	  "01234567"  "0123456789012345" */
	{ "HITACHI ", "DF600F          " },
	{ "HITACHI ", "DF600F-CM       " }
};

int
hds_match(struct device *parent, void *match, void *aux)
{
	struct scsi_attach_args *sa = aux;
	struct scsi_inquiry_data *inq = sa->sa_inqbuf;
	struct scsi_link *link = sa->sa_sc_link;
	struct hds_device *s;
	int i, mode;

	if (mpath_path_probe(sa->sa_sc_link) != 0)
		return (0);

	for (i = 0; i < nitems(hds_devices); i++) {
		s = &hds_devices[i];

		if (bcmp(s->vendor, inq->vendor, strlen(s->vendor)) == 0 &&
		    bcmp(s->product, inq->product, strlen(s->product)) == 0 &&
		    hds_inquiry(link, &mode) == 0)
			return (8);
	}

	return (0);
}

void
hds_attach(struct device *parent, struct device *self, void *aux)
{
	struct hds_softc *sc = (struct hds_softc *)self;
	struct scsi_attach_args *sa = aux;
	struct scsi_link *link = sa->sa_sc_link;

	printf("\n");

	/* init link */
	link->device_softc = sc;

	/* init path */
	scsi_xsh_set(&sc->sc_path.p_xsh, link, hds_mpath_start);
	sc->sc_path.p_link = link;

	/* init status handler */
	scsi_xsh_set(&sc->sc_xsh, link, hds_status);
	sc->sc_vpd = dma_alloc(sizeof(*sc->sc_vpd), PR_WAITOK);

	if (hds_inquiry(link, &sc->sc_mode) != 0) {
		printf("%s: unable to query controller mode\n", DEVNAME(sc));
		return;
	}

	if (hds_info(sc) != 0) {
		printf("%s: unable to query path info\n", DEVNAME(sc));
		return;
	}

	if (mpath_path_attach(&sc->sc_path,
	    (sc->sc_mode == HDS_SYMMETRIC) ? 0 : sc->sc_ctrl,
	    &hds_mpath_ops) != 0)
		printf("%s: unable to attach path\n", DEVNAME(sc));
}

int
hds_detach(struct device *self, int flags)
{
	struct hds_softc *sc = (struct hds_softc *)self;

	dma_free(sc->sc_vpd, sizeof(*sc->sc_vpd));

	return (0);
}

int
hds_activate(struct device *self, int act)
{
	struct hds_softc *sc = (struct hds_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		if (sc->sc_path.p_group != NULL)
			mpath_path_detach(&sc->sc_path);
		break;
	}
	return (rv);
}

void
hds_mpath_start(struct scsi_xfer *xs)
{
	struct hds_softc *sc = xs->sc_link->device_softc;

	mpath_start(&sc->sc_path, xs);
}

int
hds_mpath_checksense(struct scsi_xfer *xs)
{
	return (MPATH_SENSE_DECLINED);
}

void
hds_mpath_status(struct scsi_link *link)
{
	struct hds_softc *sc = link->device_softc;

	if (sc->sc_mode == HDS_SYMMETRIC)
		mpath_path_status(&sc->sc_path, MPATH_S_ACTIVE);
	else
		scsi_xsh_add(&sc->sc_xsh);
}

void
hds_status(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct hds_softc *sc = link->device_softc;

	scsi_init_inquiry(xs, SI_EVPD, HDS_VPD,
	    sc->sc_vpd, sizeof(*sc->sc_vpd));

	xs->done = hds_status_done;

	scsi_xs_exec(xs);
}

void
hds_status_done(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct hds_softc *sc = link->device_softc;
	struct hds_vpd *vpd = sc->sc_vpd;
	int status = MPATH_S_UNKNOWN;

	if (xs->error == XS_NOERROR &&
	    _2btol(vpd->hdr.page_length) >= sizeof(vpd->state) &&
	    ISSET(vpd->state, HDS_VPD_VALID)) {
		status = ISSET(vpd->state, HDS_VPD_PREFERRED) ?
		    MPATH_S_ACTIVE : MPATH_S_PASSIVE;
	}

	scsi_xs_put(xs);

	mpath_path_status(&sc->sc_path, status);
}

int
hds_inquiry(struct scsi_link *link, int *mode)
{
	struct scsi_xfer *xs;
	u_int8_t *buf;
	size_t len = link->inqdata.additional_length + 5;
	int error;

	if (len < HDS_INQ_TYPE_OFFSET + sizeof(int))
		return (ENXIO);

	xs = scsi_xs_get(link, scsi_autoconf);
	if (xs == NULL)
		return (ENOMEM);

	buf = dma_alloc(len, PR_WAITOK);
	scsi_init_inquiry(xs, 0, 0, buf, len);
	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);
	if (error)
		goto done;

	if (buf[128] == '\0')
		*mode = HDS_ASYMMETRIC;
	else if (_4btol(&buf[HDS_INQ_TYPE_OFFSET]) == HDS_INQ_TYPE)
		*mode = HDS_SYMMETRIC;
	else
		error = ENXIO;

done:
	dma_free(buf, len);
	return (error);
}

int
hds_info(struct hds_softc *sc)
{
	struct scsi_link *link = sc->sc_path.p_link;
	struct scsi_xfer *xs;
	u_int8_t *buf;
	size_t len = link->inqdata.additional_length + 5;
	char ldev[9], ctrl, port;
	int error;

	xs = scsi_xs_get(link, scsi_autoconf);
	if (xs == NULL)
		return (ENOMEM);

	buf = dma_alloc(len, PR_WAITOK);
	scsi_init_inquiry(xs, 0, 0, buf, len);
	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);
	if (error)
		goto done;

	bzero(ldev, sizeof(ldev));
	scsi_strvis(ldev, &buf[HDS_INQ_LDEV_OFFSET], HDS_INQ_LDEV_LEN);
	ctrl = buf[HDS_INQ_CTRL_OFFSET];
	port = buf[HDS_INQ_PORT_OFFSET];

	if (ctrl >= '0' && ctrl <= '9' && port >= 'A' && port <= 'B') {
		printf("%s: ldev %s, controller %c, port %c, %s\n",
		    DEVNAME(sc), ldev, ctrl, port,
		    sc->sc_mode == HDS_SYMMETRIC ? "symmetric" : "asymmetric");

		sc->sc_ctrl = ctrl;
	} else
		error = ENXIO;

done:
	dma_free(buf, len);
	return (error);
}
@


1.18
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.17 2014/09/14 14:17:26 jsg Exp $ */
d23 1
a23 1
#include <sys/kernel.h>  
@


1.17
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.16 2014/04/20 00:50:18 dlg Exp $ */
a22 1
#include <sys/buf.h>
@


1.16
log
@make the status handler more like rdac and emc. the big functional change
is to check xs->status on completion to make sure it worked.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.15 2014/04/03 04:02:50 dlg Exp $ */
a26 1
#include <sys/proc.h>
@


1.15
log
@massage the preferred path detection to happen when mpath asks for
a paths status, rather than on attach. the status it returns depends
on the type of device you have. hds provides two types of arrays,
symmetric and asymmetric.

on a symmetric device you can shove io down any path to any port
on any controller and it will work. on symmetric devices we say all
paths are part of the same group, and unconditionally return active
path status to any check request.

on asymmetric devices we group paths by which controller in teh
array they connect to. the controllers return whether theyre providing
a preferred path via a couple of status bits in a hds specific vpd
page, so we query that and return the state of the bits.

unfortunately hds arrays dont report change of lun ownership in any
way, so we dont currently have any way of failing over at the moment.
ill have to think about the least worst way to handle that.

tested by deraadt@@ on hppa
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.14 2013/12/06 21:03:02 deraadt Exp $ */
d248 8
a255 1
	int status;
a257 8

	if (_2btol(vpd->hdr.page_length) < sizeof(vpd->state) ||
	    !ISSET(vpd->state, HDS_VPD_VALID))
		status = MPATH_S_UNKNOWN;
	else if (ISSET(vpd->state, HDS_VPD_PREFERRED))
		status = MPATH_S_ACTIVE;
	else
		status = MPATH_S_PASSIVE;
@


1.14
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.13 2013/11/23 23:35:02 gsoares Exp $ */
d50 1
a50 1
        struct scsi_vpd_hdr	hdr; /* HDS_VPD */
d64 2
d67 1
d107 3
a109 1
int		hds_preferred(struct hds_softc *, int *);
a147 1
	int preferred = 1;
d158 4
d172 3
a174 10
	if (hds_preferred(sc, &preferred) != 0) {
		printf("%s: unable to query preferred path\n", DEVNAME(sc));
		return;
	}

	if (!preferred)
		return;

	/* XXX id isnt real, needs to come from hds_info */
	if (mpath_path_attach(&sc->sc_path, 0, &hds_mpath_ops) != 0)
d181 4
d222 39
a260 1
	mpath_path_status(&sc->sc_path, MPATH_S_UNKNOWN);
d327 2
a333 31
	return (error);
}

int
hds_preferred(struct hds_softc *sc, int *preferred)
{
	struct scsi_link *link = sc->sc_path.p_link;
	struct hds_vpd *pg;
	int error;

	if (sc->sc_mode == HDS_SYMMETRIC) {
		*preferred = 1;
		return (0);
	}

	pg = dma_alloc(sizeof(*pg), PR_WAITOK);

	error = scsi_inquire_vpd(link, pg, sizeof(*pg), HDS_VPD, scsi_autoconf);
	if (error)
		goto done;

	if (_2btol(pg->hdr.page_length) < sizeof(pg->state) ||
	     !ISSET(pg->state, HDS_VPD_VALID)) {
		error = ENXIO;
		goto done;
	}

	*preferred = ISSET(pg->state, HDS_VPD_PREFERRED);

done:
	dma_free(pg, sizeof(*pg));
@


1.13
log
@fix format string; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.12 2013/08/27 00:57:44 dlg Exp $ */
a189 3
	case DVACT_SUSPEND:
	case DVACT_RESUME:
		break;
@


1.12
log
@make path driver match routes return 8 so they will definitely be higher
than the real device drivers. ses returns 3 on some dells, which could be
confusing for autoconf if it has to decide between that and a path driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.11 2013/08/27 00:53:10 dlg Exp $ */
d155 1
a155 1
		printf("%s: unable to query controller mode\n");
d160 1
a160 1
		printf("%s: unable to query path info\n");
@


1.11
log
@get rid of the different path scheduler types, which simplifies the
code that picks the next path. we assume roundrobin within a group
of paths now. the asym sym(4) devices work around this by putting
every path in its own group.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.10 2013/08/27 00:24:03 dlg Exp $ */
d131 1
a131 1
			return (3);
@


1.10
log
@these were forgotten in the change from pointing paths to groups instead
of devices. fixes compilation when theyre enabled.

how embarrassment.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.9 2013/08/26 10:13:17 dlg Exp $ */
d94 1
a94 2
	hds_mpath_status,
	MPATH_ROUNDROBIN
@


1.9
log
@when i first imagined how paths on mpath worked, i thought the
midlayer would be able to call things on paths to explicitely online
or offline them. turns out thats not how the Real World(tm) works,
instead its better to wait for failure and probe for the status of
paths, and pick the active group of paths from that. there's even
evidence that the mechanisms for forcing controllers into active/passive
roles from the scsi initiator are being deprecated. they expect
hosts to be able to cope with arbitrary controller role changes and
failover
accordingly.

this replaces the online and offline function pointers in the path_ops
structure with a status check function pointer. instead of returning a
state, the checker is expected to call mpath_path_status() when its
finished figuring out what the state is.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.8 2013/08/26 07:38:56 dlg Exp $ */
d195 1
a195 1
		if (sc->sc_path.p_dev != NULL)
@


1.8
log
@checksense handlers in path drivers can return MPATH_SENSE_DECLINED
(who can tell ive spent time in web servers) to say they decline
interpreting the sense data, or MPATH_SENSE_FAILOVER to say the
sense data is from the controller saying its failed over.

all path drivers currently decline handling sense data.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.7 2013/08/26 07:29:45 dlg Exp $ */
d89 1
a89 2
int		hds_mpath_online(struct scsi_link *);
int		hds_mpath_offline(struct scsi_link *);
d94 1
a94 2
	hds_mpath_online,
	hds_mpath_offline,
d216 2
a217 2
int
hds_mpath_online(struct scsi_link *link)
d219 1
a219 2
	return (0);
}
d221 1
a221 4
int
hds_mpath_offline(struct scsi_link *link)
{
	return (0);
@


1.7
log
@introduce the idea of groups of paths. mpath had stuff to managed
devices and paths. devices are what mpath presents as targets on
its scsibus, and paths are the things attached to hardware controllers
that are available to shove io down to the actual real target. all
paths were considered usable for handling io on behalf of a device.

this adds groups in between devices and paths. only paths on the
first group in the list will now be used to handle io now.

sym devices will only have one group. asym devices will treat each
path as a different group. rdac, emc, and hds will group paths based
on which controller in the array theyre connected to.

in the future we will intercept sense data from passive controllers
and use that to start running checks to pick a new primary group
so we can handle controller failover situations.

the group id in hds(4) is currently busted, everything else should
be correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.6 2011/07/11 01:02:48 dlg Exp $ */
d215 1
a215 1
	return (0);
@


1.6
log
@support "failover" style access to volumes, ie, only use one active
path when talking to an array until it goes away, then you fail
over to the next active path.

im using this to talk to ses(4) in my dell, and allows us to support
arrays that have multiple controllers but have no way of reporting
which one is active. using the MRU semantic means we can talk to
them without them flipping the active role between its controllers
all the time. claudios transtec iscsi box is like this.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.5 2011/07/03 15:47:18 matthew Exp $ */
d175 2
a176 1
	if (mpath_path_attach(&sc->sc_path, &hds_mpath_ops) != 0)
@


1.5
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.4 2011/06/15 01:44:14 dlg Exp $ */
d92 1
a92 1
struct mpath_ops hds_mpath_ops = {
d96 2
a97 1
	hds_mpath_offline
a155 1
	sc->sc_path.p_ops = &hds_mpath_ops;
d175 1
a175 1
	if (mpath_path_attach(&sc->sc_path) != 0)
@


1.4
log
@print which ldev, controller, port, and whether we're asymmetric or
symmetric.

dont leak bufs on xs failure and make sure we free the buf back to the
right dma pool.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.3 2011/06/15 01:23:25 dlg Exp $ */
a191 1
	case DVACT_ACTIVATE:
@


1.3
log
@check the preferred path ownership bit rather than assuming that odd luns
like to be talked to on odd paths, and even luns like being talked to
on even paths.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.2 2011/04/28 10:43:36 dlg Exp $ */
d40 4
d105 1
d162 5
a240 2
	buf = dma_alloc(len, PR_WAITOK);

d245 1
a248 1

d260 39
a298 1
	dma_free(buf, 128);
@


1.2
log
@clean up the path ops struct a bit. the path drivers init their xsh with
their start routines, they dont have to pass pointers to them in the
ops struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_hds.c,v 1.1 2011/04/27 11:36:20 dlg Exp $ */
d40 17
d60 1
a60 1
	int			sc_active;
d100 2
a101 1
int		hds_priority(struct hds_softc *);
d115 1
d117 1
a117 1
	int i;
d126 2
a127 1
		    bcmp(s->product, inq->product, strlen(s->product)) == 0)
d140 1
d152 2
a153 1
	if (hds_priority(sc) != 0)
d155 1
d157 6
a162 1
	if (!sc->sc_active)
d221 1
a221 1
hds_priority(struct hds_softc *sc)
a222 2
	u_int8_t *buffer;
	struct scsi_inquiry *cdb;
d224 2
a225 5
	size_t length;
	u_int8_t ldev[9];
	u_int8_t ctrl;
	u_int8_t port;
	int p, c;
d228 4
a231 11
	length = MIN(sc->sc_path.p_link->inqdata.additional_length + 5, 255);
	if (length < 51)
		return (EIO);

	buffer = dma_alloc(length, PR_WAITOK);

	xs = scsi_xs_get(sc->sc_path.p_link, scsi_autoconf);
	if (xs == NULL) {
		error = EBUSY;
		goto done;
	}
d233 3
a235 8
	cdb = (struct scsi_inquiry *)xs->cmd;
	cdb->opcode = INQUIRY;
	_lto2b(length, cdb->length);

	xs->cmdlen = sizeof(*cdb);
	xs->flags |= SCSI_DATA_IN;
	xs->data = buffer;
	xs->datalen = length;
d237 1
d241 1
a241 1
	if (error != 0)
d244 33
a276 10
	/* XXX magical */
	bzero(ldev, sizeof(ldev));
	scsi_strvis(ldev, buffer + 44, 4);
	ctrl = buffer[49];
	port = buffer[50];

	if (strlen(ldev) > 4 || ldev[3] < '0' || ldev[3] > 'F' ||
	    ctrl < '0' || ctrl > '9' ||
	    port < 'A' || port > 'B') {
		error = EIO;
d280 1
a280 7
	c = ctrl - '0';
	p = port - 'A';
	if ((c & 0x1) == (p & 0x1))
		sc->sc_active = 1;

	printf("%s: ldev %s, controller %c, port %c\n", DEVNAME(sc), ldev,
	    ctrl, port);
a281 1
	error = 0;
d283 1
a283 1
	dma_free(buffer, length);
@


1.1
log
@hds(4) is a path driver that knows how to talk to some hitachi modular
storage arrays.

at the moment it makes a naive decision about which controller in an array
to talk to. it does work, but a smarter version is being worked on.

tested by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a72 1
	hds_mpath_start,
@

