head	1.269;
access;
symbols
	OPENBSD_6_1:1.269.0.6
	OPENBSD_6_1_BASE:1.269
	OPENBSD_6_0:1.269.0.2
	OPENBSD_6_0_BASE:1.269
	OPENBSD_5_9:1.263.0.2
	OPENBSD_5_9_BASE:1.263
	OPENBSD_5_8:1.261.0.4
	OPENBSD_5_8_BASE:1.261
	OPENBSD_5_7:1.258.0.2
	OPENBSD_5_7_BASE:1.258
	OPENBSD_5_6:1.255.0.4
	OPENBSD_5_6_BASE:1.255
	OPENBSD_5_5:1.253.0.4
	OPENBSD_5_5_BASE:1.253
	OPENBSD_5_4:1.246.0.2
	OPENBSD_5_4_BASE:1.246
	OPENBSD_5_3:1.245.0.2
	OPENBSD_5_3_BASE:1.245
	OPENBSD_5_2:1.242.0.2
	OPENBSD_5_2_BASE:1.242
	OPENBSD_5_1_BASE:1.239
	OPENBSD_5_1:1.239.0.2
	OPENBSD_5_0:1.238.0.2
	OPENBSD_5_0_BASE:1.238
	OPENBSD_4_9:1.220.0.2
	OPENBSD_4_9_BASE:1.220
	OPENBSD_4_8:1.205.0.2
	OPENBSD_4_8_BASE:1.205
	OPENBSD_4_7:1.182.0.2
	OPENBSD_4_7_BASE:1.182
	OPENBSD_4_6:1.156.0.4
	OPENBSD_4_6_BASE:1.156
	OPENBSD_4_5:1.154.0.2
	OPENBSD_4_5_BASE:1.154
	OPENBSD_4_4:1.152.0.2
	OPENBSD_4_4_BASE:1.152
	OPENBSD_4_3:1.141.0.2
	OPENBSD_4_3_BASE:1.141
	OPENBSD_4_2:1.136.0.2
	OPENBSD_4_2_BASE:1.136
	OPENBSD_4_1:1.119.0.2
	OPENBSD_4_1_BASE:1.119
	OPENBSD_4_0:1.110.0.2
	OPENBSD_4_0_BASE:1.110
	OPENBSD_3_9:1.101.0.2
	OPENBSD_3_9_BASE:1.101
	OPENBSD_3_8:1.90.0.2
	OPENBSD_3_8_BASE:1.90
	OPENBSD_3_7:1.71.0.2
	OPENBSD_3_7_BASE:1.71
	OPENBSD_3_6:1.70.0.2
	OPENBSD_3_6_BASE:1.70
	SMP_SYNC_A:1.70
	SMP_SYNC_B:1.70
	OPENBSD_3_5:1.67.0.2
	OPENBSD_3_5_BASE:1.67
	OPENBSD_3_4:1.62.0.2
	OPENBSD_3_4_BASE:1.62
	UBC_SYNC_A:1.59
	OPENBSD_3_3:1.56.0.2
	OPENBSD_3_3_BASE:1.56
	OPENBSD_3_2:1.55.0.2
	OPENBSD_3_2_BASE:1.55
	OPENBSD_3_1:1.52.0.2
	OPENBSD_3_1_BASE:1.52
	UBC_SYNC_B:1.55
	UBC:1.51.0.4
	UBC_BASE:1.51
	OPENBSD_3_0:1.51.0.2
	OPENBSD_3_0_BASE:1.51
	OPENBSD_2_9_BASE:1.47
	OPENBSD_2_9:1.47.0.2
	OPENBSD_2_8:1.46.0.2
	OPENBSD_2_8_BASE:1.46
	OPENBSD_2_7:1.43.0.2
	OPENBSD_2_7_BASE:1.43
	SMP:1.41.0.2
	SMP_BASE:1.41
	kame_19991208:1.41
	OPENBSD_2_6:1.40.0.2
	OPENBSD_2_6_BASE:1.40
	OPENBSD_2_5:1.32.0.4
	OPENBSD_2_5_BASE:1.32
	OPENBSD_2_4:1.32.0.2
	OPENBSD_2_4_BASE:1.32
	OPENBSD_2_3:1.27.0.2
	OPENBSD_2_3_BASE:1.27
	OPENBSD_2_2:1.26.0.2
	OPENBSD_2_2_BASE:1.26
	OPENBSD_2_1:1.23.0.2
	OPENBSD_2_1_BASE:1.23
	OPENBSD_2_0:1.18.0.2
	OPENBSD_2_0_BASE:1.18
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.269
date	2016.03.19.15.37.33;	author bluhm;	state Exp;
branches;
next	1.268;
commitid	T7yMgzyjenWkl34H;

1.268
date	2016.03.18.18.12.37;	author bluhm;	state Exp;
branches;
next	1.267;
commitid	zICztEvFICZQsPHS;

1.267
date	2016.03.17.18.05.39;	author bluhm;	state Exp;
branches;
next	1.266;
commitid	eVyuy2G3m3SE1BSv;

1.266
date	2016.03.16.15.01.55;	author bluhm;	state Exp;
branches;
next	1.265;
commitid	tOHK46fQILH5dSRP;

1.265
date	2016.03.12.15.16.04;	author krw;	state Exp;
branches;
next	1.264;
commitid	zkFngOKA3woPgVlY;

1.264
date	2016.03.12.00.48.44;	author bluhm;	state Exp;
branches;
next	1.263;
commitid	6pMQcrHJI9kVm30s;

1.263
date	2016.02.03.21.42.12;	author bluhm;	state Exp;
branches;
next	1.262;
commitid	praG8gYxZNFkmoxc;

1.262
date	2016.02.03.15.16.33;	author bluhm;	state Exp;
branches;
next	1.261;
commitid	PrGTttpm7HDfqylw;

1.261
date	2015.06.07.19.13.27;	author krw;	state Exp;
branches;
next	1.260;
commitid	MxUWuiPFtM1nRYxm;

1.260
date	2015.04.02.14.24.02;	author jasper;	state Exp;
branches;
next	1.259;
commitid	yz8AKMooAJP4DTxN;

1.259
date	2015.03.08.20.49.38;	author krw;	state Exp;
branches;
next	1.258;
commitid	qI52fpBDSg4oXyc9;

1.258
date	2014.12.15.02.11.57;	author tedu;	state Exp;
branches;
next	1.257;
commitid	idrzCI81iA9oSrel;

1.257
date	2014.09.18.18.47.29;	author kettenis;	state Exp;
branches;
next	1.256;
commitid	2cVxuqTv8h9h8Pqo;

1.256
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.255;
commitid	uzzBR7hz9ncd4O6G;

1.255
date	2014.07.12.18.50.25;	author tedu;	state Exp;
branches;
next	1.254;
commitid	iN7nvia2fLP712wt;

1.254
date	2014.07.10.19.13.55;	author mpi;	state Exp;
branches;
next	1.253;
commitid	PW5ksQ693VWA2nOP;

1.253
date	2014.02.19.10.15.35;	author mpi;	state Exp;
branches;
next	1.252;

1.252
date	2014.02.13.05.51.06;	author halex;	state Exp;
branches;
next	1.251;

1.251
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.250;

1.250
date	2013.10.03.14.07.42;	author krw;	state Exp;
branches;
next	1.249;

1.249
date	2013.10.02.18.59.04;	author krw;	state Exp;
branches;
next	1.248;

1.248
date	2013.09.19.19.26.16;	author krw;	state Exp;
branches;
next	1.247;

1.247
date	2013.09.15.14.35.50;	author krw;	state Exp;
branches;
next	1.246;

1.246
date	2013.06.11.16.42.17;	author deraadt;	state Exp;
branches;
next	1.245;

1.245
date	2012.12.19.19.52.11;	author kettenis;	state Exp;
branches;
next	1.244;

1.244
date	2012.10.15.16.29.07;	author deraadt;	state Exp;
branches;
next	1.243;

1.243
date	2012.10.08.21.47.51;	author deraadt;	state Exp;
branches;
next	1.242;

1.242
date	2012.07.09.12.58.01;	author krw;	state Exp;
branches;
next	1.241;

1.241
date	2012.07.08.14.30.59;	author krw;	state Exp;
branches;
next	1.240;

1.240
date	2012.06.10.21.29.04;	author krw;	state Exp;
branches;
next	1.239;

1.239
date	2011.10.10.20.39.20;	author kettenis;	state Exp;
branches;
next	1.238;

1.238
date	2011.07.18.00.13.16;	author matthew;	state Exp;
branches;
next	1.237;

1.237
date	2011.07.12.04.25.49;	author dlg;	state Exp;
branches;
next	1.236;

1.236
date	2011.07.12.00.41.43;	author dlg;	state Exp;
branches;
next	1.235;

1.235
date	2011.07.11.06.26.09;	author dlg;	state Exp;
branches;
next	1.234;

1.234
date	2011.07.11.00.22.15;	author dlg;	state Exp;
branches;
next	1.233;

1.233
date	2011.07.06.04.49.36;	author matthew;	state Exp;
branches;
next	1.232;

1.232
date	2011.07.03.15.47.18;	author matthew;	state Exp;
branches;
next	1.231;

1.231
date	2011.06.30.16.28.05;	author matthew;	state Exp;
branches;
next	1.230;

1.230
date	2011.06.19.04.55.34;	author deraadt;	state Exp;
branches;
next	1.229;

1.229
date	2011.06.19.04.35.06;	author deraadt;	state Exp;
branches;
next	1.228;

1.228
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.227;

1.227
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.226;

1.226
date	2011.05.31.17.35.35;	author matthew;	state Exp;
branches;
next	1.225;

1.225
date	2011.04.08.10.37.39;	author krw;	state Exp;
branches;
next	1.224;

1.224
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.223;

1.223
date	2011.04.07.00.05.18;	author krw;	state Exp;
branches;
next	1.222;

1.222
date	2011.03.31.18.42.48;	author jasper;	state Exp;
branches;
next	1.221;

1.221
date	2011.03.17.21.30.24;	author deraadt;	state Exp;
branches;
next	1.220;

1.220
date	2011.02.21.20.51.02;	author krw;	state Exp;
branches;
next	1.219;

1.219
date	2010.12.24.02.45.33;	author krw;	state Exp;
branches;
next	1.218;

1.218
date	2010.09.24.01.41.34;	author dlg;	state Exp;
branches;
next	1.217;

1.217
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.216;

1.216
date	2010.09.21.12.20.53;	author krw;	state Exp;
branches;
next	1.215;

1.215
date	2010.09.20.02.51.52;	author deraadt;	state Exp;
branches;
next	1.214;

1.214
date	2010.09.12.02.05.54;	author krw;	state Exp;
branches;
next	1.213;

1.213
date	2010.09.11.22.40.10;	author krw;	state Exp;
branches;
next	1.212;

1.212
date	2010.09.10.04.46.24;	author dlg;	state Exp;
branches;
next	1.211;

1.211
date	2010.09.08.15.16.22;	author jsing;	state Exp;
branches;
next	1.210;

1.210
date	2010.09.08.14.47.12;	author jsing;	state Exp;
branches;
next	1.209;

1.209
date	2010.09.01.04.51.24;	author miod;	state Exp;
branches;
next	1.208;

1.208
date	2010.09.01.01.38.12;	author dlg;	state Exp;
branches;
next	1.207;

1.207
date	2010.08.31.16.34.38;	author deraadt;	state Exp;
branches;
next	1.206;

1.206
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.205;

1.205
date	2010.08.03.19.37.17;	author krw;	state Exp;
branches;
next	1.204;

1.204
date	2010.07.07.03.53.07;	author marco;	state Exp;
branches;
next	1.203;

1.203
date	2010.07.06.16.16.48;	author marco;	state Exp;
branches;
next	1.202;

1.202
date	2010.07.03.01.40.12;	author kettenis;	state Exp;
branches;
next	1.201;

1.201
date	2010.07.01.05.11.18;	author krw;	state Exp;
branches;
next	1.200;

1.200
date	2010.07.01.03.01.37;	author matthew;	state Exp;
branches;
next	1.199;

1.199
date	2010.06.30.19.06.29;	author kettenis;	state Exp;
branches;
next	1.198;

1.198
date	2010.06.28.08.35.46;	author jsing;	state Exp;
branches;
next	1.197;

1.197
date	2010.06.24.10.05.18;	author dlg;	state Exp;
branches;
next	1.196;

1.196
date	2010.06.16.02.58.02;	author krw;	state Exp;
branches;
next	1.195;

1.195
date	2010.06.15.04.31.46;	author dlg;	state Exp;
branches;
next	1.194;

1.194
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.193;

1.193
date	2010.06.11.12.02.44;	author krw;	state Exp;
branches;
next	1.192;

1.192
date	2010.06.02.13.32.13;	author dlg;	state Exp;
branches;
next	1.191;

1.191
date	2010.05.26.16.38.20;	author thib;	state Exp;
branches;
next	1.190;

1.190
date	2010.05.20.00.04.38;	author krw;	state Exp;
branches;
next	1.189;

1.189
date	2010.05.19.05.50.50;	author dlg;	state Exp;
branches;
next	1.188;

1.188
date	2010.05.19.05.29.14;	author dlg;	state Exp;
branches;
next	1.187;

1.187
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.186;

1.186
date	2010.04.30.02.17.06;	author dlg;	state Exp;
branches;
next	1.185;

1.185
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.184;

1.184
date	2010.04.12.09.51.48;	author dlg;	state Exp;
branches;
next	1.183;

1.183
date	2010.04.06.00.59.50;	author dlg;	state Exp;
branches;
next	1.182;

1.182
date	2010.01.15.05.50.31;	author krw;	state Exp;
branches
	1.182.2.1;
next	1.181;

1.181
date	2010.01.15.05.31.38;	author krw;	state Exp;
branches;
next	1.180;

1.180
date	2010.01.12.08.33.19;	author dlg;	state Exp;
branches;
next	1.179;

1.179
date	2010.01.11.11.16.38;	author krw;	state Exp;
branches;
next	1.178;

1.178
date	2010.01.11.00.44.40;	author krw;	state Exp;
branches;
next	1.177;

1.177
date	2010.01.11.00.14.52;	author beck;	state Exp;
branches;
next	1.176;

1.176
date	2010.01.09.21.12.06;	author dlg;	state Exp;
branches;
next	1.175;

1.175
date	2010.01.05.01.21.34;	author dlg;	state Exp;
branches;
next	1.174;

1.174
date	2010.01.04.00.45.58;	author dlg;	state Exp;
branches;
next	1.173;

1.173
date	2009.12.07.00.09.27;	author krw;	state Exp;
branches;
next	1.172;

1.172
date	2009.12.06.17.24.28;	author krw;	state Exp;
branches;
next	1.171;

1.171
date	2009.12.06.07.26.35;	author dlg;	state Exp;
branches;
next	1.170;

1.170
date	2009.12.06.03.35.27;	author dlg;	state Exp;
branches;
next	1.169;

1.169
date	2009.12.03.14.31.03;	author dlg;	state Exp;
branches;
next	1.168;

1.168
date	2009.12.03.06.09.30;	author dlg;	state Exp;
branches;
next	1.167;

1.167
date	2009.12.01.03.43.17;	author krw;	state Exp;
branches;
next	1.166;

1.166
date	2009.12.01.01.50.35;	author dlg;	state Exp;
branches;
next	1.165;

1.165
date	2009.12.01.01.40.02;	author dlg;	state Exp;
branches;
next	1.164;

1.164
date	2009.11.12.06.20.27;	author dlg;	state Exp;
branches;
next	1.163;

1.163
date	2009.11.10.10.18.59;	author dlg;	state Exp;
branches;
next	1.162;

1.162
date	2009.11.10.10.13.08;	author dlg;	state Exp;
branches;
next	1.161;

1.161
date	2009.11.05.03.33.52;	author marco;	state Exp;
branches;
next	1.160;

1.160
date	2009.10.21.20.32.02;	author marco;	state Exp;
branches;
next	1.159;

1.159
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.158;

1.158
date	2009.09.14.00.03.28;	author dlg;	state Exp;
branches;
next	1.157;

1.157
date	2009.08.13.15.23.11;	author deraadt;	state Exp;
branches;
next	1.156;

1.156
date	2009.06.17.01.30.30;	author thib;	state Exp;
branches;
next	1.155;

1.155
date	2009.06.03.22.09.30;	author thib;	state Exp;
branches;
next	1.154;

1.154
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.153;

1.153
date	2008.08.24.09.08.49;	author dlg;	state Exp;
branches;
next	1.152;

1.152
date	2008.08.01.01.44.20;	author dlg;	state Exp;
branches;
next	1.151;

1.151
date	2008.07.08.12.17.48;	author dlg;	state Exp;
branches;
next	1.150;

1.150
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.149;

1.149
date	2008.06.21.21.11.34;	author krw;	state Exp;
branches;
next	1.148;

1.148
date	2008.06.15.00.52.25;	author krw;	state Exp;
branches;
next	1.147;

1.147
date	2008.06.15.00.36.41;	author krw;	state Exp;
branches;
next	1.146;

1.146
date	2008.06.10.04.46.07;	author krw;	state Exp;
branches;
next	1.145;

1.145
date	2008.06.02.17.01.13;	author krw;	state Exp;
branches;
next	1.144;

1.144
date	2008.05.24.18.53.46;	author krw;	state Exp;
branches;
next	1.143;

1.143
date	2008.05.09.06.19.33;	author krw;	state Exp;
branches;
next	1.142;

1.142
date	2008.03.21.19.57.44;	author krw;	state Exp;
branches;
next	1.141;

1.141
date	2007.12.28.16.19.15;	author dlg;	state Exp;
branches;
next	1.140;

1.140
date	2007.11.23.14.44.59;	author dlg;	state Exp;
branches;
next	1.139;

1.139
date	2007.11.11.16.46.51;	author krw;	state Exp;
branches;
next	1.138;

1.138
date	2007.11.06.02.49.19;	author krw;	state Exp;
branches;
next	1.137;

1.137
date	2007.09.15.19.22.18;	author bluhm;	state Exp;
branches;
next	1.136;

1.136
date	2007.06.23.19.19.49;	author krw;	state Exp;
branches;
next	1.135;

1.135
date	2007.06.20.18.15.47;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2007.06.18.20.55.52;	author deraadt;	state Exp;
branches;
next	1.133;

1.133
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2007.06.07.05.29.44;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2007.06.06.17.15.14;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2007.06.05.00.38.23;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2007.06.01.00.07.48;	author krw;	state Exp;
branches;
next	1.128;

1.128
date	2007.05.31.18.07.18;	author krw;	state Exp;
branches;
next	1.127;

1.127
date	2007.04.28.02.24.21;	author krw;	state Exp;
branches;
next	1.126;

1.126
date	2007.04.26.11.18.54;	author krw;	state Exp;
branches;
next	1.125;

1.125
date	2007.04.14.16.32.30;	author krw;	state Exp;
branches;
next	1.124;

1.124
date	2007.04.13.18.56.26;	author krw;	state Exp;
branches;
next	1.123;

1.123
date	2007.04.11.10.54.57;	author bluhm;	state Exp;
branches;
next	1.122;

1.122
date	2007.04.10.16.41.45;	author bluhm;	state Exp;
branches;
next	1.121;

1.121
date	2007.04.04.12.44.17;	author dlg;	state Exp;
branches;
next	1.120;

1.120
date	2007.04.03.04.58.21;	author dlg;	state Exp;
branches;
next	1.119;

1.119
date	2007.02.21.01.32.21;	author krw;	state Exp;
branches;
next	1.118;

1.118
date	2007.02.12.00.30.17;	author krw;	state Exp;
branches;
next	1.117;

1.117
date	2007.02.03.23.47.18;	author bluhm;	state Exp;
branches;
next	1.116;

1.116
date	2006.12.21.02.05.46;	author krw;	state Exp;
branches;
next	1.115;

1.115
date	2006.12.12.02.44.36;	author krw;	state Exp;
branches;
next	1.114;

1.114
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.113;

1.113
date	2006.11.27.23.14.22;	author beck;	state Exp;
branches;
next	1.112;

1.112
date	2006.11.27.20.15.09;	author beck;	state Exp;
branches;
next	1.111;

1.111
date	2006.10.07.23.40.07;	author beck;	state Exp;
branches;
next	1.110;

1.110
date	2006.07.29.02.40.46;	author krw;	state Exp;
branches;
next	1.109;

1.109
date	2006.07.23.02.50.20;	author dlg;	state Exp;
branches;
next	1.108;

1.108
date	2006.07.13.11.46.16;	author krw;	state Exp;
branches;
next	1.107;

1.107
date	2006.07.11.21.55.46;	author dlg;	state Exp;
branches;
next	1.106;

1.106
date	2006.05.18.00.10.05;	author krw;	state Exp;
branches;
next	1.105;

1.105
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.104;

1.104
date	2006.03.15.20.20.42;	author miod;	state Exp;
branches;
next	1.103;

1.103
date	2006.03.05.14.58.10;	author krw;	state Exp;
branches;
next	1.102;

1.102
date	2006.03.04.19.33.22;	author miod;	state Exp;
branches;
next	1.101;

1.101
date	2006.01.21.12.18.49;	author miod;	state Exp;
branches;
next	1.100;

1.100
date	2005.11.17.23.58.41;	author miod;	state Exp;
branches;
next	1.99;

1.99
date	2005.11.17.21.25.58;	author krw;	state Exp;
branches;
next	1.98;

1.98
date	2005.11.13.16.10.05;	author krw;	state Exp;
branches;
next	1.97;

1.97
date	2005.11.13.02.39.45;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2005.11.07.23.49.32;	author krw;	state Exp;
branches;
next	1.95;

1.95
date	2005.10.10.20.06.12;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2005.09.19.04.25.00;	author krw;	state Exp;
branches;
next	1.93;

1.93
date	2005.09.11.17.34.27;	author krw;	state Exp;
branches;
next	1.92;

1.92
date	2005.09.11.17.18.53;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2005.09.08.03.33.55;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2005.08.27.03.50.04;	author krw;	state Exp;
branches;
next	1.89;

1.89
date	2005.08.24.01.19.47;	author krw;	state Exp;
branches;
next	1.88;

1.88
date	2005.08.23.23.38.00;	author krw;	state Exp;
branches;
next	1.87;

1.87
date	2005.08.23.23.31.04;	author krw;	state Exp;
branches;
next	1.86;

1.86
date	2005.08.21.16.25.52;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2005.08.18.22.59.21;	author krw;	state Exp;
branches;
next	1.84;

1.84
date	2005.08.17.02.17.51;	author krw;	state Exp;
branches;
next	1.83;

1.83
date	2005.08.12.01.49.08;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2005.07.30.15.54.45;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2005.07.05.00.55.25;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2005.07.02.15.39.55;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2005.07.02.14.32.17;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2005.07.02.03.49.47;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2005.05.03.00.29.16;	author krw;	state Exp;
branches;
next	1.76;

1.76
date	2005.05.01.19.29.17;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2005.04.06.02.51.13;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2005.04.05.02.01.50;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2005.03.30.02.40.42;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2005.03.25.05.07.43;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2005.02.27.01.12.11;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2004.05.28.23.50.15;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2004.05.17.23.57.51;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2004.05.09.04.01.59;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2004.02.21.00.47.42;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2004.02.15.02.45.47;	author tedu;	state Exp;
branches;
next	1.65;

1.65
date	2004.01.25.21.51.18;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.25.00.52.49;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.05.02.57.01;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.24.22.42.07;	author mickey;	state Exp;
branches;
next	1.61;

1.61
date	2003.05.21.23.43.58;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.18.16.06.35;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.16.19.54.05;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2003.05.06.11.40.34;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2003.04.06.03.02.44;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2002.12.30.21.50.29;	author grange;	state Exp;
branches;
next	1.55;

1.55
date	2002.09.04.23.07.28;	author tdeval;	state Exp;
branches;
next	1.54;

1.54
date	2002.08.12.06.59.46;	author fgsch;	state Exp;
branches;
next	1.53;

1.53
date	2002.06.09.00.05.57;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2001.10.08.01.50.48;	author drahn;	state Exp;
branches
	1.51.4.1;
next	1.50;

1.50
date	2001.08.26.00.45.08;	author fgsch;	state Exp;
branches;
next	1.49;

1.49
date	2001.08.06.20.50.25;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.22.14.35.43;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2000.12.13.15.33.24;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2000.10.13.17.55.00;	author mickey;	state Exp;
branches;
next	1.45;

1.45
date	2000.09.21.17.57.19;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2000.09.20.00.58.03;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2000.04.18.05.53.17;	author csapuntz;	state Exp;
branches;
next	1.42;

1.42
date	2000.04.08.19.19.33;	author csapuntz;	state Exp;
branches;
next	1.41;

1.41
date	99.12.05.02.49.17;	author deraadt;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	99.08.24.01.20.22;	author csapuntz;	state Exp;
branches;
next	1.39;

1.39
date	99.08.10.23.09.49;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	99.07.25.11.13.08;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	99.07.25.11.12.32;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	99.07.25.07.09.19;	author csapuntz;	state Exp;
branches;
next	1.35;

1.35
date	99.07.23.06.17.09;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	99.07.22.23.06.51;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	99.05.09.20.41.48;	author weingart;	state Exp;
branches;
next	1.32;

1.32
date	98.10.04.01.37.55;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	98.10.03.21.19.01;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	98.10.01.05.11.11;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	98.05.02.16.48.21;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	98.04.25.00.38.13;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	98.03.27.18.40.53;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	97.10.18.10.37.19;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	97.08.08.21.47.06;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	97.07.26.21.07.36;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	97.04.14.04.09.16;	author downsj;	state Exp;
branches;
next	1.22;

1.22
date	97.01.04.08.50.21;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	96.12.11.19.08.18;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	96.12.03.08.08.00;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	96.10.31.01.09.25;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	96.08.07.00.09.17;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	96.07.12.08.57.57;	author pefo;	state Exp;
branches;
next	1.16;

1.16
date	96.07.11.22.17.46;	author pefo;	state Exp;
branches;
next	1.15;

1.15
date	96.06.16.03.07.21;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	96.06.10.07.31.20;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.06.10.00.44.00;	author downsj;	state Exp;
branches;
next	1.12;

1.12
date	96.06.01.09.35.03;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.05.22.11.57.30;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.10.12.31.39;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.06.11.33.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.02.13.17.55;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.31.10;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.19.16.10.17;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.02.20.01.50.58;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.01.14.21.44.30;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.20.21.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.56.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches;
next	;

1.41.2.1
date	2001.05.14.22.44.59;	author niklas;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2001.07.04.11.00.07;	author niklas;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.41.2.6;

1.41.2.6
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.41.2.7;

1.41.2.7
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.41.2.8;

1.41.2.8
date	2004.02.19.11.01.30;	author niklas;	state Exp;
branches;
next	1.41.2.9;

1.41.2.9
date	2004.06.05.23.13.08;	author niklas;	state Exp;
branches;
next	;

1.51.4.1
date	2002.06.11.03.32.14;	author art;	state Exp;
branches;
next	1.51.4.2;

1.51.4.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.51.4.3;

1.51.4.3
date	2003.05.19.22.28.21;	author tedu;	state Exp;
branches;
next	;

1.182.2.1
date	2010.07.06.08.48.50;	author stephan;	state Exp;
branches;
next	;


desc
@@


1.269
log
@Do not run into sdgetdisklabel() when scsi disk is dying.  Add
special error handling in sdopen() as temporary hack.
OK krw@@
@
text
@/*	$OpenBSD: sd.c,v 1.268 2016/03/18 18:12:37 bluhm Exp $	*/
/*	$NetBSD: sd.c,v 1.111 1997/04/02 02:29:41 mycroft Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Originally written by Julian Elischer (julian@@dialix.oz.au)
 * for TRW Financial Systems for use under the MACH(2.5) operating system.
 *
 * TRW Financial Systems, in accordance with their agreement with Carnegie
 * Mellon University, makes this software available to CMU to distribute
 * or use in any manner that they see fit as long as this message is kept with
 * the software. For this reason TFS also grants any other persons or
 * organisations permission to use or modify this software.
 *
 * TFS supplies this software to be publicly redistributed
 * on the understanding that TFS is not responsible for the correct
 * functioning of this software in any circumstances.
 *
 * Ported to run under 386BSD by Julian Elischer (julian@@dialix.oz.au) Sept 1992
 */

#include <sys/stdint.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/mtio.h>
#include <sys/mutex.h>
#include <sys/buf.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/conf.h>
#include <sys/scsiio.h>
#include <sys/dkio.h>
#include <sys/reboot.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>
#include <scsi/sdvar.h>

#include <ufs/ffs/fs.h>			/* for BBSIZE and SBSIZE */

#include <sys/vnode.h>

int	sdmatch(struct device *, void *, void *);
void	sdattach(struct device *, struct device *, void *);
int	sdactivate(struct device *, int);
int	sddetach(struct device *, int);

void	sdminphys(struct buf *);
int	sdgetdisklabel(dev_t, struct sd_softc *, struct disklabel *, int);
void	sdstart(struct scsi_xfer *);
int	sd_interpret_sense(struct scsi_xfer *);
int	sd_read_cap_10(struct sd_softc *, int);
int	sd_read_cap_16(struct sd_softc *, int);
int	sd_size(struct sd_softc *, int);
int	sd_thin_pages(struct sd_softc *, int);
int	sd_vpd_block_limits(struct sd_softc *, int);
int	sd_vpd_thin(struct sd_softc *, int);
int	sd_thin_params(struct sd_softc *, int);
int	sd_get_parms(struct sd_softc *, struct disk_parms *, int);
void	sd_flush(struct sd_softc *, int);

void	viscpy(u_char *, u_char *, int);

int	sd_ioctl_inquiry(struct sd_softc *, struct dk_inquiry *);
int	sd_ioctl_cache(struct sd_softc *, long, struct dk_cache *);

void	sd_cmd_rw6(struct scsi_xfer *, int, u_int64_t, u_int);
void	sd_cmd_rw10(struct scsi_xfer *, int, u_int64_t, u_int);
void	sd_cmd_rw12(struct scsi_xfer *, int, u_int64_t, u_int);
void	sd_cmd_rw16(struct scsi_xfer *, int, u_int64_t, u_int);

void	sd_buf_done(struct scsi_xfer *);

struct cfattach sd_ca = {
	sizeof(struct sd_softc), sdmatch, sdattach,
	sddetach, sdactivate
};

struct cfdriver sd_cd = {
	NULL, "sd", DV_DISK
};

const struct scsi_inquiry_pattern sd_patterns[] = {
	{T_DIRECT, T_FIXED,
	 "",         "",                 ""},
	{T_DIRECT, T_REMOV,
	 "",         "",                 ""},
	{T_RDIRECT, T_FIXED,
	 "",         "",                 ""},
	{T_RDIRECT, T_REMOV,
	 "",         "",                 ""},
	{T_OPTICAL, T_FIXED,
	 "",         "",                 ""},
	{T_OPTICAL, T_REMOV,
	 "",         "",                 ""},
};

#define sdlookup(unit) (struct sd_softc *)disk_lookup(&sd_cd, (unit))

int
sdmatch(struct device *parent, void *match, void *aux)
{
	struct scsi_attach_args *sa = aux;
	int priority;

	(void)scsi_inqmatch(sa->sa_inqbuf,
	    sd_patterns, nitems(sd_patterns),
	    sizeof(sd_patterns[0]), &priority);

	return (priority);
}

/*
 * The routine called by the low level scsi routine when it discovers
 * a device suitable for this driver.
 */
void
sdattach(struct device *parent, struct device *self, void *aux)
{
	struct sd_softc *sc = (struct sd_softc *)self;
	struct scsi_attach_args *sa = aux;
	struct disk_parms *dp = &sc->params;
	struct scsi_link *link = sa->sa_sc_link;
	int sd_autoconf = scsi_autoconf | SCSI_SILENT |
	    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE;
	struct dk_cache dkc;
	int error, result, sortby = BUFQ_DEFAULT;

	SC_DEBUG(link, SDEV_DB2, ("sdattach:\n"));

	/*
	 * Store information needed to contact our base driver
	 */
	sc->sc_link = link;
	link->interpret_sense = sd_interpret_sense;
	link->device_softc = sc;

	if ((link->flags & SDEV_ATAPI) && (link->flags & SDEV_REMOVABLE))
		link->quirks |= SDEV_NOSYNCCACHE;

	if (!(link->inqdata.flags & SID_RelAdr))
		link->quirks |= SDEV_ONLYBIG;

	/*
	 * Note if this device is ancient.  This is used in sdminphys().
	 */
	if (!(link->flags & SDEV_ATAPI) &&
	    SCSISPC(sa->sa_inqbuf->version) == 0)
		sc->flags |= SDF_ANCIENT;

	/*
	 * Use the subdriver to request information regarding
	 * the drive. We cannot use interrupts yet, so the
	 * request must specify this.
	 */
	printf("\n");

	scsi_xsh_set(&sc->sc_xsh, link, sdstart);
	timeout_set(&sc->sc_timeout, (void (*)(void *))scsi_xsh_add,
	    &sc->sc_xsh);

	/* Spin up non-UMASS devices ready or not. */
	if ((link->flags & SDEV_UMASS) == 0)
		scsi_start(link, SSS_START, sd_autoconf);

	/*
	 * Some devices (e.g. BlackBerry Pearl) won't admit they have
	 * media loaded unless its been locked in.
	 */
	if ((link->flags & SDEV_REMOVABLE) != 0)
		scsi_prevent(link, PR_PREVENT, sd_autoconf);

	/* Check that it is still responding and ok. */
	error = scsi_test_unit_ready(sc->sc_link, TEST_READY_RETRIES * 3,
	    sd_autoconf);

	if (error)
		result = SDGP_RESULT_OFFLINE;
	else
		result = sd_get_parms(sc, &sc->params, sd_autoconf);

	if ((link->flags & SDEV_REMOVABLE) != 0)
		scsi_prevent(link, PR_ALLOW, sd_autoconf);

	switch (result) {
	case SDGP_RESULT_OK:
		printf("%s: %lluMB, %lu bytes/sector, %llu sectors",
		    sc->sc_dev.dv_xname,
		    dp->disksize / (1048576 / dp->secsize), dp->secsize,
		    dp->disksize);
		if (ISSET(sc->flags, SDF_THIN)) {
			sortby = BUFQ_FIFO;
			printf(", thin");
		}
		if (ISSET(link->flags, SDEV_READONLY)) {
			printf(", readonly");
		}
		printf("\n");
		break;

	case SDGP_RESULT_OFFLINE:
		break;

#ifdef DIAGNOSTIC
	default:
		panic("sdattach: unknown result (%#x) from get_parms", result);
		break;
#endif
	}

	/*
	 * Initialize disk structures.
	 */
	sc->sc_dk.dk_name = sc->sc_dev.dv_xname;
	bufq_init(&sc->sc_bufq, sortby);

	/*
	 * Enable write cache by default.
	 */
	memset(&dkc, 0, sizeof(dkc));
	if (sd_ioctl_cache(sc, DIOCGCACHE, &dkc) == 0 && dkc.wrcache == 0) {
		dkc.wrcache = 1;
		sd_ioctl_cache(sc, DIOCSCACHE, &dkc);
	}

	/* Attach disk. */
	disk_attach(&sc->sc_dev, &sc->sc_dk);
}

int
sdactivate(struct device *self, int act)
{
	struct scsi_link *link;
	struct sd_softc *sc = (struct sd_softc *)self;

	if (sc->flags & SDF_DYING)
		return (ENXIO);
	link = sc->sc_link;

	switch (act) {
	case DVACT_SUSPEND:
		/*
		 * We flush the cache, since we our next step before
		 * DVACT_POWERDOWN might be a hibernate operation.
		 */
		if ((sc->flags & SDF_DIRTY) != 0)
			sd_flush(sc, SCSI_AUTOCONF);
		break;
	case DVACT_POWERDOWN:
		/*
		 * Stop the disk.  Stopping the disk should flush the
		 * cache, but we are paranoid so we flush the cache
		 * first.  We're cold at this point, so we poll for
		 * completion.
		 */
		if ((sc->flags & SDF_DIRTY) != 0)
			sd_flush(sc, SCSI_AUTOCONF);
		if (boothowto & RB_POWERDOWN)
			scsi_start(link, SSS_STOP,
			    SCSI_IGNORE_ILLEGAL_REQUEST |
			    SCSI_IGNORE_NOT_READY | SCSI_AUTOCONF);
		break;
	case DVACT_RESUME:
		scsi_start(link, SSS_START,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_AUTOCONF);
		break;
	case DVACT_DEACTIVATE:
		sc->flags |= SDF_DYING;
		timeout_del(&sc->sc_timeout);
		scsi_xsh_del(&sc->sc_xsh);
		break;
	}
	return (0);
}

int
sddetach(struct device *self, int flags)
{
	struct sd_softc *sc = (struct sd_softc *)self;

	bufq_drain(&sc->sc_bufq);

	disk_gone(sdopen, self->dv_unit);

	/* Detach disk. */
	bufq_destroy(&sc->sc_bufq);
	disk_detach(&sc->sc_dk);

	return (0);
}

/*
 * Open the device. Make sure the partition info is as up-to-date as can be.
 */
int
sdopen(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct scsi_link *link;
	struct sd_softc *sc;
	int error = 0, part, rawopen, unit;

	unit = DISKUNIT(dev);
	part = DISKPART(dev);

	rawopen = (part == RAW_PART) && (fmt == S_IFCHR);

	sc = sdlookup(unit);
	if (sc == NULL)
		return (ENXIO);
	if (sc->flags & SDF_DYING) {
		device_unref(&sc->sc_dev);
		return (ENXIO);
	}
	link = sc->sc_link;

	if (ISSET(flag, FWRITE) && ISSET(link->flags, SDEV_READONLY)) {
		device_unref(&sc->sc_dev);
		return (EACCES);
	}

	SC_DEBUG(link, SDEV_DB1,
	    ("sdopen: dev=0x%x (unit %d (of %d), partition %d)\n", dev, unit,
	    sd_cd.cd_ndevs, part));

	if ((error = disk_lock(&sc->sc_dk)) != 0) {
		device_unref(&sc->sc_dev);
		return (error);
	}

	if (sc->sc_dk.dk_openmask != 0) {
		/*
		 * If any partition is open, but the disk has been invalidated,
		 * disallow further opens of non-raw partition.
		 */
		if (sc->flags & SDF_DYING) {
			error = ENXIO;
			goto die;
		}
		if ((link->flags & SDEV_MEDIA_LOADED) == 0) {
			if (rawopen)
				goto out;
			error = EIO;
			goto bad;
		}
	} else {
		/* Spin up non-UMASS devices ready or not. */
		if (sc->flags & SDF_DYING) {
			error = ENXIO;
			goto die;
		}
		if ((link->flags & SDEV_UMASS) == 0)
			scsi_start(link, SSS_START, (rawopen ? SCSI_SILENT :
			    0) | SCSI_IGNORE_ILLEGAL_REQUEST |
			    SCSI_IGNORE_MEDIA_CHANGE);

		/* Use sd_interpret_sense() for sense errors.
		 *
		 * But only after spinning the disk up! Just in case a broken
		 * device returns "Initialization command required." and causes
		 * a loop of scsi_start() calls.
		 */
		if (sc->flags & SDF_DYING) {
			error = ENXIO;
			goto die;
		}
		link->flags |= SDEV_OPEN;

		/*
		 * Try to prevent the unloading of a removable device while
		 * it's open. But allow the open to proceed if the device can't
		 * be locked in.
		 */
		if ((link->flags & SDEV_REMOVABLE) != 0) {
			scsi_prevent(link, PR_PREVENT, SCSI_SILENT |
			    SCSI_IGNORE_ILLEGAL_REQUEST |
			    SCSI_IGNORE_MEDIA_CHANGE);
		}

		/* Check that it is still responding and ok. */
		if (sc->flags & SDF_DYING) {
			error = ENXIO;
			goto die;
		}
		error = scsi_test_unit_ready(link,
		    TEST_READY_RETRIES, SCSI_SILENT |
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
		if (error) {
			if (rawopen) {
				error = 0;
				goto out;
			} else
				goto bad;
		}

		/* Load the physical device parameters. */
		if (sc->flags & SDF_DYING) {
			error = ENXIO;
			goto die;
		}
		link->flags |= SDEV_MEDIA_LOADED;
		if (sd_get_parms(sc, &sc->params, (rawopen ? SCSI_SILENT : 0))
		    == SDGP_RESULT_OFFLINE) {
			if (sc->flags & SDF_DYING) {
				error = ENXIO;
				goto die;
			}
			link->flags &= ~SDEV_MEDIA_LOADED;
			error = ENXIO;
			goto bad;
		}
		SC_DEBUG(link, SDEV_DB3, ("Params loaded\n"));

		/* Load the partition info if not already loaded. */
		error = sdgetdisklabel(dev, sc, sc->sc_dk.dk_label, 0);
		if (error == EIO || error == ENXIO)
			goto bad;
		SC_DEBUG(link, SDEV_DB3, ("Disklabel loaded\n"));
	}

out:
	if ((error = disk_openpart(&sc->sc_dk, part, fmt, 1)) != 0)
		goto bad;

	SC_DEBUG(link, SDEV_DB3, ("open complete\n"));

	/* It's OK to fall through because dk_openmask is now non-zero. */
bad:
	if (sc->sc_dk.dk_openmask == 0) {
		if (sc->flags & SDF_DYING) {
			error = ENXIO;
			goto die;
		}
		if ((link->flags & SDEV_REMOVABLE) != 0)
			scsi_prevent(link, PR_ALLOW, SCSI_SILENT |
			    SCSI_IGNORE_ILLEGAL_REQUEST |
			    SCSI_IGNORE_MEDIA_CHANGE);
		if (sc->flags & SDF_DYING) {
			error = ENXIO;
			goto die;
		}
		link->flags &= ~(SDEV_OPEN | SDEV_MEDIA_LOADED);
	}

die:
	disk_unlock(&sc->sc_dk);
	device_unref(&sc->sc_dev);
	return (error);
}

/*
 * Close the device. Only called if we are the last occurrence of an open
 * device.  Convenient now but usually a pain.
 */
int
sdclose(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct scsi_link *link;
	struct sd_softc *sc;
	int part = DISKPART(dev);
	int error = 0;

	sc = sdlookup(DISKUNIT(dev));
	if (sc == NULL)
		return (ENXIO);
	if (sc->flags & SDF_DYING) {
		device_unref(&sc->sc_dev);
		return (ENXIO);
	}
	link = sc->sc_link;

	disk_lock_nointr(&sc->sc_dk);

	disk_closepart(&sc->sc_dk, part, fmt);

	if (sc->sc_dk.dk_openmask == 0) {
		if ((sc->flags & SDF_DIRTY) != 0)
			sd_flush(sc, 0);

		if (sc->flags & SDF_DYING) {
			error = ENXIO;
			goto die;
		}
		if ((link->flags & SDEV_REMOVABLE) != 0)
			scsi_prevent(link, PR_ALLOW,
			    SCSI_IGNORE_ILLEGAL_REQUEST |
			    SCSI_IGNORE_NOT_READY | SCSI_SILENT);
		if (sc->flags & SDF_DYING) {
			error = ENXIO;
			goto die;
		}
		link->flags &= ~(SDEV_OPEN | SDEV_MEDIA_LOADED);

		if (link->flags & SDEV_EJECTING) {
			scsi_start(link, SSS_STOP|SSS_LOEJ, 0);
			if (sc->flags & SDF_DYING) {
				error = ENXIO;
				goto die;
			}
			link->flags &= ~SDEV_EJECTING;
		}

		timeout_del(&sc->sc_timeout);
		scsi_xsh_del(&sc->sc_xsh);
	}

die:
	disk_unlock(&sc->sc_dk);
	device_unref(&sc->sc_dev);
	return (error);
}

/*
 * Actually translate the requested transfer into one the physical driver
 * can understand.  The transfer is described by a buf and will include
 * only one physical transfer.
 */
void
sdstrategy(struct buf *bp)
{
	struct scsi_link *link;
	struct sd_softc *sc;
	int s;

	sc = sdlookup(DISKUNIT(bp->b_dev));
	if (sc == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}
	if (sc->flags & SDF_DYING) {
		bp->b_error = ENXIO;
		goto bad;
	}
	link = sc->sc_link;

	SC_DEBUG(link, SDEV_DB2, ("sdstrategy: %ld bytes @@ blk %lld\n",
	    bp->b_bcount, (long long)bp->b_blkno));
	/*
	 * If the device has been made invalid, error out
	 */
	if ((link->flags & SDEV_MEDIA_LOADED) == 0) {
		if (link->flags & SDEV_OPEN)
			bp->b_error = EIO;
		else
			bp->b_error = ENODEV;
		goto bad;
	}

	/* Validate the request. */
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label) == -1)
		goto done;

	/* Place it in the queue of disk activities for this disk. */
	bufq_queue(&sc->sc_bufq, bp);

	/*
	 * Tell the device to get going on the transfer if it's
	 * not doing anything, otherwise just wait for completion
	 */
	scsi_xsh_add(&sc->sc_xsh);

	device_unref(&sc->sc_dev);
	return;

 bad:
	bp->b_flags |= B_ERROR;
	bp->b_resid = bp->b_bcount;
 done:
	s = splbio();
	biodone(bp);
	splx(s);
	if (sc != NULL)
		device_unref(&sc->sc_dev);
}

void
sd_cmd_rw6(struct scsi_xfer *xs, int read, u_int64_t secno, u_int nsecs)
{
	struct scsi_rw *cmd = (struct scsi_rw *)xs->cmd;

	cmd->opcode = read ? READ_COMMAND : WRITE_COMMAND;
	_lto3b(secno, cmd->addr);
	cmd->length = nsecs;

	xs->cmdlen = sizeof(*cmd);
}

void
sd_cmd_rw10(struct scsi_xfer *xs, int read, u_int64_t secno, u_int nsecs)
{
	struct scsi_rw_big *cmd = (struct scsi_rw_big *)xs->cmd;

	cmd->opcode = read ? READ_BIG : WRITE_BIG;
	_lto4b(secno, cmd->addr);
	_lto2b(nsecs, cmd->length);

	xs->cmdlen = sizeof(*cmd);
}

void
sd_cmd_rw12(struct scsi_xfer *xs, int read, u_int64_t secno, u_int nsecs)
{
	struct scsi_rw_12 *cmd = (struct scsi_rw_12 *)xs->cmd;

	cmd->opcode = read ? READ_12 : WRITE_12;
	_lto4b(secno, cmd->addr);
	_lto4b(nsecs, cmd->length);

	xs->cmdlen = sizeof(*cmd);
}

void
sd_cmd_rw16(struct scsi_xfer *xs, int read, u_int64_t secno, u_int nsecs)
{
	struct scsi_rw_16 *cmd = (struct scsi_rw_16 *)xs->cmd;

	cmd->opcode = read ? READ_16 : WRITE_16;
	_lto8b(secno, cmd->addr);
	_lto4b(nsecs, cmd->length);

	xs->cmdlen = sizeof(*cmd);
}

/*
 * sdstart looks to see if there is a buf waiting for the device
 * and that the device is not already busy. If both are true,
 * It dequeues the buf and creates a scsi command to perform the
 * transfer in the buf. The transfer request will call scsi_done
 * on completion, which will in turn call this routine again
 * so that the next queued transfer is performed.
 * The bufs are queued by the strategy routine (sdstrategy)
 *
 * This routine is also called after other non-queued requests
 * have been made of the scsi driver, to ensure that the queue
 * continues to be drained.
 */
void
sdstart(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct sd_softc *sc = link->device_softc;
	struct buf *bp;
	u_int64_t secno;
	int nsecs;
	int read;
	struct partition *p;

	if (sc->flags & SDF_DYING) {
		scsi_xs_put(xs);
		return;
	}
	if ((link->flags & SDEV_MEDIA_LOADED) == 0) {
		bufq_drain(&sc->sc_bufq);
		scsi_xs_put(xs);
		return;
	}

	bp = bufq_dequeue(&sc->sc_bufq);
	if (bp == NULL) {
		scsi_xs_put(xs);
		return;
	}

	secno = DL_BLKTOSEC(sc->sc_dk.dk_label, bp->b_blkno);

	p = &sc->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
	secno += DL_GETPOFFSET(p);
	nsecs = howmany(bp->b_bcount, sc->sc_dk.dk_label->d_secsize);
	read = bp->b_flags & B_READ;

	/*
	 *  Fill out the scsi command.  If the transfer will
	 *  fit in a "small" cdb, use it.
	 */
	if (!(link->flags & SDEV_ATAPI) &&
	    !(link->quirks & SDEV_ONLYBIG) &&
	    ((secno & 0x1fffff) == secno) &&
	    ((nsecs & 0xff) == nsecs))
		sd_cmd_rw6(xs, read, secno, nsecs);
	else if (((secno & 0xffffffff) == secno) &&
	    ((nsecs & 0xffff) == nsecs))
		sd_cmd_rw10(xs, read, secno, nsecs);
	else if (((secno & 0xffffffff) == secno) &&
	    ((nsecs & 0xffffffff) == nsecs))
		sd_cmd_rw12(xs, read, secno, nsecs);
	else
		sd_cmd_rw16(xs, read, secno, nsecs);

	xs->flags |= (read ? SCSI_DATA_IN : SCSI_DATA_OUT);
	xs->timeout = 60000;
	xs->data = bp->b_data;
	xs->datalen = bp->b_bcount;

	xs->done = sd_buf_done;
	xs->cookie = bp;
	xs->bp = bp;

	/* Instrumentation. */
	disk_busy(&sc->sc_dk);

	/* Mark disk as dirty. */
	if (!read)
		sc->flags |= SDF_DIRTY;

	scsi_xs_exec(xs);

	/* move onto the next io */
	if (ISSET(sc->flags, SDF_WAITING))
		CLR(sc->flags, SDF_WAITING);
	else if (bufq_peek(&sc->sc_bufq))
		scsi_xsh_add(&sc->sc_xsh);
}

void
sd_buf_done(struct scsi_xfer *xs)
{
	struct sd_softc *sc = xs->sc_link->device_softc;
	struct buf *bp = xs->cookie;
	int error, s;

	switch (xs->error) {
	case XS_NOERROR:
		bp->b_error = 0;
		bp->b_resid = xs->resid;
		break;

	case XS_NO_CCB:
		/* The adapter is busy, requeue the buf and try it later. */
		disk_unbusy(&sc->sc_dk, bp->b_bcount - xs->resid,
		    bp->b_flags & B_READ);
		bufq_requeue(&sc->sc_bufq, bp);
		scsi_xs_put(xs);
		SET(sc->flags, SDF_WAITING);
		timeout_add(&sc->sc_timeout, 1);
		return;

	case XS_SENSE:
	case XS_SHORTSENSE:
#ifdef SCSIDEBUG
		scsi_sense_print_debug(xs);
#endif
		error = sd_interpret_sense(xs);
		if (error == 0) {
			bp->b_error = 0;
			bp->b_resid = xs->resid;
			break;
		}
		if (error != ERESTART) {
			bp->b_error = error;
			xs->retries = 0;
		}
		goto retry;

	case XS_BUSY:
		if (xs->retries) {
			if (scsi_delay(xs, 1) != ERESTART)
				xs->retries = 0;
		}
		goto retry;

	case XS_TIMEOUT:
retry:
		if (xs->retries--) {
			scsi_xs_exec(xs);
			return;
		}
		/* FALLTHROUGH */

	default:
		if (bp->b_error == 0)
			bp->b_error = EIO;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		break;
	}

	disk_unbusy(&sc->sc_dk, bp->b_bcount - xs->resid,
	    bp->b_flags & B_READ);

	s = splbio();
	biodone(bp);
	splx(s);
	scsi_xs_put(xs);
}

void
sdminphys(struct buf *bp)
{
	struct scsi_link *link;
	struct sd_softc *sc;
	long max;

	sc = sdlookup(DISKUNIT(bp->b_dev));
	if (sc == NULL)
		return;  /* XXX - right way to fail this? */
	if (sc->flags & SDF_DYING) {
		device_unref(&sc->sc_dev);
		return;
	}
	link = sc->sc_link;

	/*
	 * If the device is ancient, we want to make sure that
	 * the transfer fits into a 6-byte cdb.
	 *
	 * XXX Note that the SCSI-I spec says that 256-block transfers
	 * are allowed in a 6-byte read/write, and are specified
	 * by setting the "length" to 0.  However, we're conservative
	 * here, allowing only 255-block transfers in case an
	 * ancient device gets confused by length == 0.  A length of 0
	 * in a 10-byte read/write actually means 0 blocks.
	 */
	if (sc->flags & SDF_ANCIENT) {
		max = sc->sc_dk.dk_label->d_secsize * 0xff;

		if (bp->b_bcount > max)
			bp->b_bcount = max;
	}

	(*link->adapter->scsi_minphys)(bp, link);

	device_unref(&sc->sc_dev);
}

int
sdread(dev_t dev, struct uio *uio, int ioflag)
{
	return (physio(sdstrategy, dev, B_READ, sdminphys, uio));
}

int
sdwrite(dev_t dev, struct uio *uio, int ioflag)
{
	return (physio(sdstrategy, dev, B_WRITE, sdminphys, uio));
}

/*
 * Perform special action on behalf of the user
 * Knows about the internals of this device
 */
int
sdioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	struct scsi_link *link;
	struct sd_softc *sc;
	struct disklabel *lp;
	int error = 0;
	int part = DISKPART(dev);

	sc = sdlookup(DISKUNIT(dev));
	if (sc == NULL)
		return (ENXIO);
	if (sc->flags & SDF_DYING) {
		device_unref(&sc->sc_dev);
		return (ENXIO);
	}
	link = sc->sc_link;

	SC_DEBUG(link, SDEV_DB2, ("sdioctl 0x%lx\n", cmd));

	/*
	 * If the device is not valid.. abandon ship
	 */
	if ((link->flags & SDEV_MEDIA_LOADED) == 0) {
		switch (cmd) {
		case DIOCLOCK:
		case DIOCEJECT:
		case SCIOCIDENTIFY:
		case SCIOCCOMMAND:
		case SCIOCDEBUG:
			if (part == RAW_PART)
				break;
		/* FALLTHROUGH */
		default:
			if ((link->flags & SDEV_OPEN) == 0) {
				error = ENODEV;
				goto exit;
			} else {
				error = EIO;
				goto exit;
			}
		}
	}

	switch (cmd) {
	case DIOCRLDINFO:
		lp = malloc(sizeof(*lp), M_TEMP, M_WAITOK);
		sdgetdisklabel(dev, sc, lp, 0);
		memcpy(sc->sc_dk.dk_label, lp, sizeof(*lp));
		free(lp, M_TEMP, sizeof(*lp));
		goto exit;

	case DIOCGPDINFO:
		sdgetdisklabel(dev, sc, (struct disklabel *)addr, 1);
		goto exit;

	case DIOCGDINFO:
		*(struct disklabel *)addr = *(sc->sc_dk.dk_label);
		goto exit;

	case DIOCGPART:
		((struct partinfo *)addr)->disklab = sc->sc_dk.dk_label;
		((struct partinfo *)addr)->part =
		    &sc->sc_dk.dk_label->d_partitions[DISKPART(dev)];
		goto exit;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}

		if ((error = disk_lock(&sc->sc_dk)) != 0)
			goto exit;

		error = setdisklabel(sc->sc_dk.dk_label,
		    (struct disklabel *)addr, sc->sc_dk.dk_openmask);
		if (error == 0) {
			if (cmd == DIOCWDINFO)
				error = writedisklabel(DISKLABELDEV(dev),
				    sdstrategy, sc->sc_dk.dk_label);
		}

		disk_unlock(&sc->sc_dk);
		goto exit;

	case DIOCLOCK:
		error = scsi_prevent(link,
		    (*(int *)addr) ? PR_PREVENT : PR_ALLOW, 0);
		goto exit;

	case MTIOCTOP:
		if (((struct mtop *)addr)->mt_op != MTOFFL) {
			error = EIO;
			goto exit;
		}
		/* FALLTHROUGH */
	case DIOCEJECT:
		if ((link->flags & SDEV_REMOVABLE) == 0) {
			error = ENOTTY;
			goto exit;
		}
		link->flags |= SDEV_EJECTING;
		goto exit;

	case DIOCINQ:
		error = scsi_do_ioctl(link, cmd, addr, flag);
		if (error == ENOTTY)
			error = sd_ioctl_inquiry(sc,
			    (struct dk_inquiry *)addr);
		goto exit;

	case DIOCSCACHE:
		if (!ISSET(flag, FWRITE)) {
			error = EBADF;
			goto exit;
		}
		/* FALLTHROUGH */
	case DIOCGCACHE:
		error = sd_ioctl_cache(sc, cmd, (struct dk_cache *)addr);
		goto exit;

	default:
		if (part != RAW_PART) {
			error = ENOTTY;
			goto exit;
		}
		error = scsi_do_ioctl(link, cmd, addr, flag);
	}

 exit:
	device_unref(&sc->sc_dev);
	return (error);
}

int
sd_ioctl_inquiry(struct sd_softc *sc, struct dk_inquiry *di)
{
	struct scsi_link *link;
	struct scsi_vpd_serial *vpd;

	vpd = dma_alloc(sizeof(*vpd), PR_WAITOK | PR_ZERO);

	if (sc->flags & SDF_DYING) {
		dma_free(vpd, sizeof(*vpd));
		return (ENXIO);
	}
	link = sc->sc_link;

	bzero(di, sizeof(struct dk_inquiry));
	scsi_strvis(di->vendor, link->inqdata.vendor,
	    sizeof(link->inqdata.vendor));
	scsi_strvis(di->product, link->inqdata.product,
	    sizeof(link->inqdata.product));
	scsi_strvis(di->revision, link->inqdata.revision,
	    sizeof(link->inqdata.revision));

	/* the serial vpd page is optional */
	if (scsi_inquire_vpd(link, vpd, sizeof(*vpd), SI_PG_SERIAL, 0) == 0)
		scsi_strvis(di->serial, vpd->serial, sizeof(vpd->serial));
	else
		strlcpy(di->serial, "(unknown)", sizeof(vpd->serial));

	dma_free(vpd, sizeof(*vpd));
	return (0);
}

int
sd_ioctl_cache(struct sd_softc *sc, long cmd, struct dk_cache *dkc)
{
	struct scsi_link *link;
	union scsi_mode_sense_buf *buf;
	struct page_caching_mode *mode = NULL;
	u_int wrcache, rdcache;
	int big;
	int rv;

	if (sc->flags & SDF_DYING)
		return (ENXIO);
	link = sc->sc_link;

	if (ISSET(link->flags, SDEV_UMASS))
		return (EOPNOTSUPP);

	/* see if the adapter has special handling */
	rv = scsi_do_ioctl(link, cmd, (caddr_t)dkc, 0);
	if (rv != ENOTTY)
		return (rv);

	buf = dma_alloc(sizeof(*buf), PR_WAITOK);
	if (buf == NULL)
		return (ENOMEM);

	if (sc->flags & SDF_DYING) {
		rv = ENXIO;
		goto done;
	}
	rv = scsi_do_mode_sense(link, PAGE_CACHING_MODE,
	    buf, (void **)&mode, NULL, NULL, NULL,
	    sizeof(*mode) - 4, scsi_autoconf | SCSI_SILENT, &big);
	if (rv != 0)
		goto done;

	if ((mode == NULL) || (!DISK_PGCODE(mode, PAGE_CACHING_MODE))) {
		rv = EIO;
		goto done;
	}

	wrcache = (ISSET(mode->flags, PG_CACHE_FL_WCE) ? 1 : 0);
	rdcache = (ISSET(mode->flags, PG_CACHE_FL_RCD) ? 0 : 1);

	switch (cmd) {
	case DIOCGCACHE:
		dkc->wrcache = wrcache;
		dkc->rdcache = rdcache;
		break;

	case DIOCSCACHE:
		if (dkc->wrcache == wrcache && dkc->rdcache == rdcache)
			break;

		if (dkc->wrcache)
			SET(mode->flags, PG_CACHE_FL_WCE);
		else
			CLR(mode->flags, PG_CACHE_FL_WCE);

		if (dkc->rdcache)
			CLR(mode->flags, PG_CACHE_FL_RCD);
		else
			SET(mode->flags, PG_CACHE_FL_RCD);

		if (sc->flags & SDF_DYING) {
			rv = ENXIO;
			goto done;
		}
		if (big) {
			rv = scsi_mode_select_big(link, SMS_PF,
			    &buf->hdr_big, scsi_autoconf | SCSI_SILENT, 20000);
		} else {
			rv = scsi_mode_select(link, SMS_PF,
			    &buf->hdr, scsi_autoconf | SCSI_SILENT, 20000);
		}
		break;
	}

done:
	dma_free(buf, sizeof(*buf));
	return (rv);
}

/*
 * Load the label information on the named device
 */
int
sdgetdisklabel(dev_t dev, struct sd_softc *sc, struct disklabel *lp,
    int spoofonly)
{
	struct scsi_link *link;
	size_t len;
	char packname[sizeof(lp->d_packname) + 1];
	char product[17], vendor[9];

	if (sc->flags & SDF_DYING)
		return (ENXIO);
	link = sc->sc_link;

	bzero(lp, sizeof(struct disklabel));

	lp->d_secsize = sc->params.secsize;
	lp->d_ntracks = sc->params.heads;
	lp->d_nsectors = sc->params.sectors;
	lp->d_ncylinders = sc->params.cyls;
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
	if (lp->d_secpercyl == 0) {
		lp->d_secpercyl = 100;
		/* as long as it's not 0 - readdisklabel divides by it */
	}

	lp->d_type = DTYPE_SCSI;
	if ((link->inqdata.device & SID_TYPE) == T_OPTICAL)
		strncpy(lp->d_typename, "SCSI optical",
		    sizeof(lp->d_typename));
	else
		strncpy(lp->d_typename, "SCSI disk",
		    sizeof(lp->d_typename));

	/*
	 * Try to fit '<vendor> <product>' into d_packname. If that doesn't fit
	 * then leave out '<vendor> ' and use only as much of '<product>' as
	 * does fit.
	 */
	viscpy(vendor, link->inqdata.vendor, 8);
	viscpy(product, link->inqdata.product, 16);
	len = snprintf(packname, sizeof(packname), "%s %s", vendor, product);
	if (len > sizeof(lp->d_packname)) {
		strlcpy(packname, product, sizeof(packname));
		len = strlen(packname);
	}
	/*
	 * It is safe to use len as the count of characters to copy because
	 * packname is sizeof(lp->d_packname)+1, the string in packname is
	 * always null terminated and len does not count the terminating null.
	 * d_packname is not a null terminated string.
	 */
	memcpy(lp->d_packname, packname, len);

	DL_SETDSIZE(lp, sc->params.disksize);
	lp->d_version = 1;
	lp->d_flags = 0;

	/* XXX - these values for BBSIZE and SBSIZE assume ffs */
	lp->d_bbsize = BBSIZE;
	lp->d_sbsize = SBSIZE;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	/*
	 * Call the generic disklabel extraction routine
	 */
	return readdisklabel(DISKLABELDEV(dev), sdstrategy, lp, spoofonly);
}


/*
 * Check Errors
 */
int
sd_interpret_sense(struct scsi_xfer *xs)
{
	struct scsi_sense_data *sense = &xs->sense;
	struct scsi_link *link = xs->sc_link;
	u_int8_t serr = sense->error_code & SSD_ERRCODE;
	int retval;

	/*
	 * Let the generic code handle everything except a few categories of
	 * LUN not ready errors on open devices.
	 */
	if (((link->flags & SDEV_OPEN) == 0) ||
	    (serr != SSD_ERRCODE_CURRENT && serr != SSD_ERRCODE_DEFERRED) ||
	    ((sense->flags & SSD_KEY) != SKEY_NOT_READY) ||
	    (sense->extra_len < 6))
		return (scsi_interpret_sense(xs));

	if ((xs->flags & SCSI_IGNORE_NOT_READY) != 0)
		return (0);

	switch (ASC_ASCQ(sense)) {
	case SENSE_NOT_READY_BECOMING_READY:
		SC_DEBUG(link, SDEV_DB1, ("becoming ready.\n"));
		retval = scsi_delay(xs, 5);
		break;

	case SENSE_NOT_READY_INIT_REQUIRED:
		SC_DEBUG(link, SDEV_DB1, ("spinning up\n"));
		retval = scsi_start(link, SSS_START,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_NOSLEEP);
		if (retval == 0)
			retval = ERESTART;
		else if (retval == ENOMEM)
			/* Can't issue the command. Fall back on a delay. */
			retval = scsi_delay(xs, 5);
		else
			SC_DEBUG(link, SDEV_DB1, ("spin up failed (%#x)\n",
			    retval));
		break;

	default:
		retval = scsi_interpret_sense(xs);
		break;
	}

	return (retval);
}

daddr_t
sdsize(dev_t dev)
{
	struct disklabel *lp;
	struct sd_softc *sc;
	int part, omask;
	daddr_t size;

	sc = sdlookup(DISKUNIT(dev));
	if (sc == NULL)
		return -1;
	if (sc->flags & SDF_DYING) {
		size = -1;
		goto exit;
	}

	part = DISKPART(dev);
	omask = sc->sc_dk.dk_openmask & (1 << part);

	if (omask == 0 && sdopen(dev, 0, S_IFBLK, NULL) != 0) {
		size = -1;
		goto exit;
	}

	lp = sc->sc_dk.dk_label;
	if (sc->flags & SDF_DYING) {
		size = -1;
		goto exit;
	}
	if ((sc->sc_link->flags & SDEV_MEDIA_LOADED) == 0)
		size = -1;
	else if (lp->d_partitions[part].p_fstype != FS_SWAP)
		size = -1;
	else
		size = DL_SECTOBLK(lp, DL_GETPSIZE(&lp->d_partitions[part]));
	if (omask == 0 && sdclose(dev, 0, S_IFBLK, NULL) != 0)
		size = -1;

 exit:
	device_unref(&sc->sc_dev);
	return size;
}

/* #define SD_DUMP_NOT_TRUSTED if you just want to watch */
static int sddoingadump;

/*
 * dump all of physical memory into the partition specified, starting
 * at offset 'dumplo' into the partition.
 */
int
sddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
{
	struct sd_softc *sc;	/* disk unit to do the I/O */
	struct disklabel *lp;	/* disk's disklabel */
	int	unit, part;
	u_int32_t sectorsize;	/* size of a disk sector */
	u_int64_t nsects;	/* number of sectors in partition */
	u_int64_t sectoff;	/* sector offset of partition */
	u_int64_t totwrt;	/* total number of sectors left to write */
	u_int32_t nwrt;		/* current number of sectors to write */
	struct scsi_xfer *xs;	/* ... convenience */
	int rv;

	/* Check if recursive dump; if so, punt. */
	if (sddoingadump)
		return EFAULT;
	if (blkno < 0)
		return EINVAL;

	/* Mark as active early. */
	sddoingadump = 1;

	unit = DISKUNIT(dev);	/* Decompose unit & partition. */
	part = DISKPART(dev);

	/* Check for acceptable drive number. */
	if (unit >= sd_cd.cd_ndevs || (sc = sd_cd.cd_devs[unit]) == NULL)
		return ENXIO;

	/*
	 * XXX Can't do this check, since the media might have been
	 * XXX marked `invalid' by successful unmounting of all
	 * XXX filesystems.
	 */
#if 0
	/* Make sure it was initialized. */
	if ((sc->sc_link->flags & SDEV_MEDIA_LOADED) != SDEV_MEDIA_LOADED)
		return ENXIO;
#endif

	/* Convert to disk sectors.  Request must be a multiple of size. */
	lp = sc->sc_dk.dk_label;
	sectorsize = lp->d_secsize;
	if ((size % sectorsize) != 0)
		return EFAULT;
	if ((blkno % DL_BLKSPERSEC(lp)) != 0)
		return EFAULT;
	totwrt = size / sectorsize;
	blkno = DL_BLKTOSEC(lp, blkno);

	nsects = DL_GETPSIZE(&lp->d_partitions[part]);
	sectoff = DL_GETPOFFSET(&lp->d_partitions[part]);

	/* Check transfer bounds against partition size. */
	if ((blkno + totwrt) > nsects)
		return EINVAL;

	/* Offset block number to start of partition. */
	blkno += sectoff;

	while (totwrt > 0) {
		if (totwrt > UINT32_MAX)
			nwrt = UINT32_MAX;
		else
			nwrt = totwrt;

#ifndef	SD_DUMP_NOT_TRUSTED
		xs = scsi_xs_get(sc->sc_link, SCSI_NOSLEEP);
		if (xs == NULL)
			return (ENOMEM);

		xs->timeout = 10000;
		xs->flags |= SCSI_DATA_OUT;
		xs->data = va;
		xs->datalen = nwrt * sectorsize;

		sd_cmd_rw10(xs, 0, blkno, nwrt); /* XXX */

		rv = scsi_xs_sync(xs);
		scsi_xs_put(xs);
		if (rv != 0)
			return (ENXIO);
#else	/* SD_DUMP_NOT_TRUSTED */
		/* Let's just talk about this first... */
		printf("sd%d: dump addr 0x%x, blk %lld\n", unit, va,
		    (long long)blkno);
		delay(500 * 1000);	/* half a second */
#endif	/* SD_DUMP_NOT_TRUSTED */

		/* update block count */
		totwrt -= nwrt;
		blkno += nwrt;
		va += sectorsize * nwrt;
	}

	sddoingadump = 0;

	return (0);
}

/*
 * Copy up to len chars from src to dst, ignoring non-printables.
 * Must be room for len+1 chars in dst so we can write the NUL.
 * Does not assume src is NUL-terminated.
 */
void
viscpy(u_char *dst, u_char *src, int len)
{
	while (len > 0 && *src != '\0') {
		if (*src < 0x20 || *src >= 0x80) {
			src++;
			continue;
		}
		*dst++ = *src++;
		len--;
	}
	*dst = '\0';
}

int
sd_read_cap_10(struct sd_softc *sc, int flags)
{
	struct scsi_read_capacity cdb;
	struct scsi_read_cap_data *rdcap;
	struct scsi_xfer *xs;
	int rv = ENOMEM;

	CLR(flags, SCSI_IGNORE_ILLEGAL_REQUEST);

	rdcap = dma_alloc(sizeof(*rdcap), (ISSET(flags, SCSI_NOSLEEP) ?
	    PR_NOWAIT : PR_WAITOK) | PR_ZERO);
	if (rdcap == NULL)
		return (ENOMEM);

	if (sc->flags & SDF_DYING) {
		rv = ENXIO;
		goto done;
	}
	xs = scsi_xs_get(sc->sc_link, flags | SCSI_DATA_IN | SCSI_SILENT);
	if (xs == NULL)
		goto done;

	bzero(&cdb, sizeof(cdb));
	cdb.opcode = READ_CAPACITY;

	memcpy(xs->cmd, &cdb, sizeof(cdb));
	xs->cmdlen = sizeof(cdb);
	xs->data = (void *)rdcap;
	xs->datalen = sizeof(*rdcap);
	xs->timeout = 20000;

	rv = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (rv == 0) {
		sc->params.disksize = _4btol(rdcap->addr) + 1ll;
		sc->params.secsize = _4btol(rdcap->length);
		CLR(sc->flags, SDF_THIN);
	}

 done:
	dma_free(rdcap, sizeof(*rdcap));
	return (rv);
}

int
sd_read_cap_16(struct sd_softc *sc, int flags)
{
	struct scsi_read_capacity_16 cdb;
	struct scsi_read_cap_data_16 *rdcap;
	struct scsi_xfer *xs;
	int rv = ENOMEM;

	CLR(flags, SCSI_IGNORE_ILLEGAL_REQUEST);

	rdcap = dma_alloc(sizeof(*rdcap), (ISSET(flags, SCSI_NOSLEEP) ?
	    PR_NOWAIT : PR_WAITOK) | PR_ZERO);
	if (rdcap == NULL)
		return (ENOMEM);

	if (sc->flags & SDF_DYING) {
		rv = ENXIO;
		goto done;
	}
	xs = scsi_xs_get(sc->sc_link, flags | SCSI_DATA_IN | SCSI_SILENT);
	if (xs == NULL)
		goto done;

	bzero(&cdb, sizeof(cdb));
	cdb.opcode = READ_CAPACITY_16;
	cdb.byte2 = SRC16_SERVICE_ACTION;
	_lto4b(sizeof(*rdcap), cdb.length);

	memcpy(xs->cmd, &cdb, sizeof(cdb));
	xs->cmdlen = sizeof(cdb);
	xs->data = (void *)rdcap;
	xs->datalen = sizeof(*rdcap);
	xs->timeout = 20000;

	rv = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (rv == 0) {
		if (_8btol(rdcap->addr) == 0) {
			rv = EIO;
			goto done;
		}

		sc->params.disksize = _8btol(rdcap->addr) + 1;
		sc->params.secsize = _4btol(rdcap->length);
		if (ISSET(_2btol(rdcap->lowest_aligned), READ_CAP_16_TPE))
			SET(sc->flags, SDF_THIN);
		else
			CLR(sc->flags, SDF_THIN);
	}

 done:
	dma_free(rdcap, sizeof(*rdcap));
	return (rv);
}

int
sd_size(struct sd_softc *sc, int flags)
{
	int rv;

	if (sc->flags & SDF_DYING)
		return (ENXIO);
	if (SCSISPC(sc->sc_link->inqdata.version) >= 3) {
		rv = sd_read_cap_16(sc, flags);
		if (rv != 0)
			rv = sd_read_cap_10(sc, flags);
	} else {
		rv = sd_read_cap_10(sc, flags);
		if (rv == 0 && sc->params.disksize == 0x100000000ll)
			rv = sd_read_cap_16(sc, flags);
	}

	return (rv);
}

int
sd_thin_pages(struct sd_softc *sc, int flags)
{
	struct scsi_vpd_hdr *pg;
	size_t len = 0;
	u_int8_t *pages;
	int i, score = 0;
	int rv;

	pg = dma_alloc(sizeof(*pg), (ISSET(flags, SCSI_NOSLEEP) ?
	    PR_NOWAIT : PR_WAITOK) | PR_ZERO);
	if (pg == NULL)
		return (ENOMEM);

	if (sc->flags & SDF_DYING) {
		rv = ENXIO;
		goto done;
	}
	rv = scsi_inquire_vpd(sc->sc_link, pg, sizeof(*pg),
	    SI_PG_SUPPORTED, flags);
	if (rv != 0)
		goto done;

	len = _2btol(pg->page_length);

	dma_free(pg, sizeof(*pg));
	pg = dma_alloc(sizeof(*pg) + len, (ISSET(flags, SCSI_NOSLEEP) ?
	    PR_NOWAIT : PR_WAITOK) | PR_ZERO);
	if (pg == NULL)
		return (ENOMEM);

	if (sc->flags & SDF_DYING) {
		rv = ENXIO;
		goto done;
	}
	rv = scsi_inquire_vpd(sc->sc_link, pg, sizeof(*pg) + len,
	    SI_PG_SUPPORTED, flags);
	if (rv != 0)
		goto done;

	pages = (u_int8_t *)(pg + 1);
	if (pages[0] != SI_PG_SUPPORTED) {
		rv = EIO;
		goto done;
	}

	for (i = 1; i < len; i++) {
		switch (pages[i]) {
		case SI_PG_DISK_LIMITS:
		case SI_PG_DISK_THIN:
			score++;
			break;
		}
	}

	if (score < 2)
		rv = EOPNOTSUPP;

 done:
	dma_free(pg, sizeof(*pg) + len);
	return (rv);
}

int
sd_vpd_block_limits(struct sd_softc *sc, int flags)
{
	struct scsi_vpd_disk_limits *pg;
	int rv;

	pg = dma_alloc(sizeof(*pg), (ISSET(flags, SCSI_NOSLEEP) ?
	    PR_NOWAIT : PR_WAITOK) | PR_ZERO);
	if (pg == NULL)
		return (ENOMEM);

	if (sc->flags & SDF_DYING) {
		rv = ENXIO;
		goto done;
	}
	rv = scsi_inquire_vpd(sc->sc_link, pg, sizeof(*pg),
	    SI_PG_DISK_LIMITS, flags);
	if (rv != 0)
		goto done;

	if (_2btol(pg->hdr.page_length) == SI_PG_DISK_LIMITS_LEN_THIN) {
		sc->params.unmap_sectors = _4btol(pg->max_unmap_lba_count);
		sc->params.unmap_descs = _4btol(pg->max_unmap_desc_count);
	} else
		rv = EOPNOTSUPP;

 done:
	dma_free(pg, sizeof(*pg));
	return (rv);
}

int
sd_vpd_thin(struct sd_softc *sc, int flags)
{
	struct scsi_vpd_disk_thin *pg;
	int rv;

	pg = dma_alloc(sizeof(*pg), (ISSET(flags, SCSI_NOSLEEP) ?
	    PR_NOWAIT : PR_WAITOK) | PR_ZERO);
	if (pg == NULL)
		return (ENOMEM);

	if (sc->flags & SDF_DYING) {
		rv = ENXIO;
		goto done;
	}
	rv = scsi_inquire_vpd(sc->sc_link, pg, sizeof(*pg),
	    SI_PG_DISK_THIN, flags);
	if (rv != 0)
		goto done;

#ifdef notyet
	if (ISSET(pg->flags, VPD_DISK_THIN_TPU))
		sc->sc_delete = sd_unmap;
	else if (ISSET(pg->flags, VPD_DISK_THIN_TPWS)) {
		sc->sc_delete = sd_write_same_16;
		sc->params.unmap_descs = 1; /* WRITE SAME 16 only does one */
	} else
		rv = EOPNOTSUPP;
#endif

 done:
	dma_free(pg, sizeof(*pg));
	return (rv);
}

int
sd_thin_params(struct sd_softc *sc, int flags)
{
	int rv;

	rv = sd_thin_pages(sc, flags);
	if (rv != 0)
		return (rv);

	rv = sd_vpd_block_limits(sc, flags);
	if (rv != 0)
		return (rv);

	rv = sd_vpd_thin(sc, flags);
	if (rv != 0)
		return (rv);

	return (0);
}

/*
 * Fill out the disk parameter structure. Return SDGP_RESULT_OK if the
 * structure is correctly filled in, SDGP_RESULT_OFFLINE otherwise. The caller
 * is responsible for clearing the SDEV_MEDIA_LOADED flag if the structure
 * cannot be completed.
 */
int
sd_get_parms(struct sd_softc *sc, struct disk_parms *dp, int flags)
{
	struct scsi_link *link;
	union scsi_mode_sense_buf *buf = NULL;
	struct page_rigid_geometry *rigid = NULL;
	struct page_flex_geometry *flex = NULL;
	struct page_reduced_geometry *reduced = NULL;
	u_char *page0 = NULL;
	u_int32_t heads = 0, sectors = 0, cyls = 0, secsize = 0;
	int err = 0, big;

	if (sd_size(sc, flags) != 0)
		return (SDGP_RESULT_OFFLINE);

	if (ISSET(sc->flags, SDF_THIN) && sd_thin_params(sc, flags) != 0) {
		/* we dont know the unmap limits, so we cant use thin shizz */
		CLR(sc->flags, SDF_THIN);
	}

	buf = dma_alloc(sizeof(*buf), PR_NOWAIT);
	if (buf == NULL)
		goto validate;

	if (sc->flags & SDF_DYING)
		goto die;
	link = sc->sc_link;

	/*
	 * Ask for page 0 (vendor specific) mode sense data to find
	 * READONLY info. The only thing USB devices will ask for.
	 */
	err = scsi_do_mode_sense(link, 0, buf, (void **)&page0,
	    NULL, NULL, NULL, 1, flags | SCSI_SILENT, &big);
	if (sc->flags & SDF_DYING)
		goto die;
	if (err == 0) {
		if (big && buf->hdr_big.dev_spec & SMH_DSP_WRITE_PROT)
			SET(link->flags, SDEV_READONLY);
		else if (!big && buf->hdr.dev_spec & SMH_DSP_WRITE_PROT)
			SET(link->flags, SDEV_READONLY);
		else
			CLR(link->flags, SDEV_READONLY);
	}

	/*
	 * Many UMASS devices choke when asked about their geometry. Most
	 * don't have a meaningful geometry anyway, so just fake it if
	 * scsi_size() worked.
	 */
	if ((link->flags & SDEV_UMASS) && (dp->disksize > 0))
		goto validate;

	switch (link->inqdata.device & SID_TYPE) {
	case T_OPTICAL:
		/* No more information needed or available. */
		break;

	case T_RDIRECT:
		/* T_RDIRECT supports only PAGE_REDUCED_GEOMETRY (6). */
		err = scsi_do_mode_sense(link, PAGE_REDUCED_GEOMETRY,
		    buf, (void **)&reduced, NULL, NULL, &secsize,
		    sizeof(*reduced), flags | SCSI_SILENT, NULL);
		if (!err && reduced &&
		    DISK_PGCODE(reduced, PAGE_REDUCED_GEOMETRY)) {
			if (dp->disksize == 0)
				dp->disksize = _5btol(reduced->sectors);
			if (secsize == 0)
				secsize = _2btol(reduced->bytes_s);
		}
		break;

	default:
		/*
		 * NOTE: Some devices leave off the last four bytes of
		 * PAGE_RIGID_GEOMETRY and PAGE_FLEX_GEOMETRY mode sense pages.
		 * The only information in those four bytes is RPM information
		 * so accept the page. The extra bytes will be zero and RPM will
		 * end up with the default value of 3600.
		 */
		if (((link->flags & SDEV_ATAPI) == 0) ||
		    ((link->flags & SDEV_REMOVABLE) == 0))
			err = scsi_do_mode_sense(link,
			    PAGE_RIGID_GEOMETRY, buf, (void **)&rigid, NULL,
			    NULL, &secsize, sizeof(*rigid) - 4,
			    flags | SCSI_SILENT, NULL);
		if (!err && rigid && DISK_PGCODE(rigid, PAGE_RIGID_GEOMETRY)) {
			heads = rigid->nheads;
			cyls = _3btol(rigid->ncyl);
			if (heads * cyls > 0)
				sectors = dp->disksize / (heads * cyls);
		} else {
			if (sc->flags & SDF_DYING)
				goto die;
			err = scsi_do_mode_sense(link,
			    PAGE_FLEX_GEOMETRY, buf, (void **)&flex, NULL, NULL,
			    &secsize, sizeof(*flex) - 4,
			    flags | SCSI_SILENT, NULL);
			if (!err && flex &&
			    DISK_PGCODE(flex, PAGE_FLEX_GEOMETRY)) {
				sectors = flex->ph_sec_tr;
				heads = flex->nheads;
				cyls = _2btol(flex->ncyl);
				if (secsize == 0)
					secsize = _2btol(flex->bytes_s);
				if (dp->disksize == 0)
					dp->disksize = heads * cyls * sectors;
			}
		}
		break;
	}

validate:
	if (buf)
		dma_free(buf, sizeof(*buf));

	if (dp->disksize == 0)
		return (SDGP_RESULT_OFFLINE);

	if (dp->secsize == 0)
		dp->secsize = (secsize == 0) ? 512 : secsize;

	/*
	 * Restrict secsize values to powers of two between 512 and 64k.
	 */
	switch (dp->secsize) {
	case 0x200:	/* == 512, == DEV_BSIZE on all architectures. */
	case 0x400:
	case 0x800:
	case 0x1000:
	case 0x2000:
	case 0x4000:
	case 0x8000:
	case 0x10000:
		break;
	default:
		SC_DEBUG(sc->sc_link, SDEV_DB1,
		    ("sd_get_parms: bad secsize: %#lx\n", dp->secsize));
		return (SDGP_RESULT_OFFLINE);
	}

	/*
	 * XXX THINK ABOUT THIS!!  Using values such that sectors * heads *
	 * cyls is <= disk_size can lead to wasted space. We need a more
	 * careful calculation/validation to make everything work out
	 * optimally.
	 */
	if (dp->disksize > 0xffffffff && (dp->heads * dp->sectors) < 0xffff) {
		dp->heads = 511;
		dp->sectors = 255;
		cyls = 0;
	} else {
		/*
		 * Use standard geometry values for anything we still don't
		 * know.
		 */
		dp->heads = (heads == 0) ? 255 : heads;
		dp->sectors = (sectors == 0) ? 63 : sectors;
	}

	dp->cyls = (cyls == 0) ? dp->disksize / (dp->heads * dp->sectors) :
	    cyls;

	if (dp->cyls == 0) {
		dp->heads = dp->cyls = 1;
		dp->sectors = dp->disksize;
	}

	return (SDGP_RESULT_OK);

die:
	dma_free(buf, sizeof(*buf));
	return (SDGP_RESULT_OFFLINE);
}

void
sd_flush(struct sd_softc *sc, int flags)
{
	struct scsi_link *link;
	struct scsi_xfer *xs;
	struct scsi_synchronize_cache *cmd;

	if (sc->flags & SDF_DYING)
		return;
	link = sc->sc_link;

	if (link->quirks & SDEV_NOSYNCCACHE)
		return;

	/*
	 * Issue a SYNCHRONIZE CACHE. Address 0, length 0 means "all remaining
	 * blocks starting at address 0". Ignore ILLEGAL REQUEST in the event
	 * that the command is not supported by the device.
	 */

	xs = scsi_xs_get(link, flags);
	if (xs == NULL) {
		SC_DEBUG(link, SDEV_DB1, ("cache sync failed to get xs\n"));
		return;
	}

	cmd = (struct scsi_synchronize_cache *)xs->cmd;
	cmd->opcode = SYNCHRONIZE_CACHE;

	xs->cmdlen = sizeof(*cmd);
	xs->timeout = 100000;
	xs->flags |= SCSI_IGNORE_ILLEGAL_REQUEST;

	if (scsi_xs_sync(xs) == 0)
		sc->flags &= ~SDF_DIRTY;
	else
		SC_DEBUG(link, SDEV_DB1, ("cache sync failed\n"));

	scsi_xs_put(xs);
}
@


1.268
log
@After sleeping and before accessing sc_link, check that scsi disk
is not dying.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.267 2016/03/17 18:05:39 bluhm Exp $	*/
d453 2
a454 2
		if (sdgetdisklabel(dev, sc, sc->sc_dk.dk_label, 0) == EIO) {
			error = EIO;
a455 1
		}
d1142 2
@


1.267
log
@Do not access the scsi link structure in sdclose() if the disk
device is already dying.  Delete the sc_timeout when setting the
SDF_DYING flag as the timeout delete in sdclose() may not be reached.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.266 2016/03/16 15:01:55 bluhm Exp $	*/
d1024 4
d1074 4
d1112 4
d1281 4
d1441 4
d1487 4
d1562 4
d1579 4
d1622 4
d1653 4
d1727 2
d1737 2
d1795 2
d1872 4
@


1.266
log
@Add SDF_DYING checks to more functions in scsi disk, to prevent an
use after free of the scsi link structure during detach.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.265 2016/03/12 15:16:04 krw Exp $	*/
d308 1
d500 1
d519 4
d527 4
d535 4
d546 1
d549 1
a549 1
	return 0;
@


1.265
log
@Standardize on calling local scsi_link variables 'link' instead of
'sc_link'. 'sc_link' is a field in the various device *_softc
structures, where the sc_ prefix was for 'softc'. Reduces potential
mental confusion. Newer code from down under was already using
'link'.

No functional change.

Prompted by bluhm@@'s adventures in scsi. ok dlg@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.264 2016/03/12 00:48:44 bluhm Exp $	*/
d272 1
d274 4
a277 1
	int rv = 0;
d298 1
a298 1
			scsi_start(sc->sc_link, SSS_STOP,
d303 1
a303 1
		scsi_start(sc->sc_link, SSS_START,
d311 1
a311 1
	return (rv);
d1039 2
d1494 2
d1820 2
@


1.264
log
@When unplugging an USB umass stick, the kernel could panic because
of a use after free.  In sdopen() the scsi link pointer is taken
from the scsi disk struct.  While the scsi disk memory is refcounted
by autoconf, the scsi link may be detached and freed during sleep.
The solution is to check wether the disk is dying after every sleep.
The SDF_DYING flag is set before scsi bus and scsi disk are detached,
so without this flag the link must be valid.
input and OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.263 2016/02/03 21:42:12 bluhm Exp $	*/
d162 1
a162 1
	struct scsi_link *sc_link = sa->sa_sc_link;
d168 1
a168 1
	SC_DEBUG(sc_link, SDEV_DB2, ("sdattach:\n"));
d173 3
a175 3
	sc->sc_link = sc_link;
	sc_link->interpret_sense = sd_interpret_sense;
	sc_link->device_softc = sc;
d177 2
a178 2
	if ((sc_link->flags & SDEV_ATAPI) && (sc_link->flags & SDEV_REMOVABLE))
		sc_link->quirks |= SDEV_NOSYNCCACHE;
d180 2
a181 2
	if (!(sc_link->inqdata.flags & SID_RelAdr))
		sc_link->quirks |= SDEV_ONLYBIG;
d186 1
a186 1
	if (!(sc_link->flags & SDEV_ATAPI) &&
d197 1
a197 1
	scsi_xsh_set(&sc->sc_xsh, sc_link, sdstart);
d202 2
a203 2
	if ((sc_link->flags & SDEV_UMASS) == 0)
		scsi_start(sc_link, SSS_START, sd_autoconf);
d209 2
a210 2
	if ((sc_link->flags & SDEV_REMOVABLE) != 0)
		scsi_prevent(sc_link, PR_PREVENT, sd_autoconf);
d221 2
a222 2
	if ((sc_link->flags & SDEV_REMOVABLE) != 0)
		scsi_prevent(sc_link, PR_ALLOW, sd_autoconf);
d234 1
a234 1
		if (ISSET(sc_link->flags, SDEV_READONLY)) {
d332 1
a332 1
	struct scsi_link *sc_link;
d348 1
a348 1
	sc_link = sc->sc_link;
d350 1
a350 1
	if (ISSET(flag, FWRITE) && ISSET(sc_link->flags, SDEV_READONLY)) {
d355 1
a355 1
	SC_DEBUG(sc_link, SDEV_DB1,
d373 1
a373 1
		if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
d385 2
a386 2
		if ((sc_link->flags & SDEV_UMASS) == 0)
			scsi_start(sc_link, SSS_START, (rawopen ? SCSI_SILENT :
d400 1
a400 1
		sc_link->flags |= SDEV_OPEN;
d407 2
a408 2
		if ((sc_link->flags & SDEV_REMOVABLE) != 0) {
			scsi_prevent(sc_link, PR_PREVENT, SCSI_SILENT |
d418 1
a418 1
		error = scsi_test_unit_ready(sc_link,
d434 1
a434 1
		sc_link->flags |= SDEV_MEDIA_LOADED;
d441 1
a441 1
			sc_link->flags &= ~SDEV_MEDIA_LOADED;
d445 1
a445 1
		SC_DEBUG(sc_link, SDEV_DB3, ("Params loaded\n"));
d452 1
a452 1
		SC_DEBUG(sc_link, SDEV_DB3, ("Disklabel loaded\n"));
d459 1
a459 1
	SC_DEBUG(sc_link, SDEV_DB3, ("open complete\n"));
d468 2
a469 2
		if ((sc_link->flags & SDEV_REMOVABLE) != 0)
			scsi_prevent(sc_link, PR_ALLOW, SCSI_SILENT |
d476 1
a476 1
		sc_link->flags &= ~(SDEV_OPEN | SDEV_MEDIA_LOADED);
d492 1
a492 1
	struct scsi_link *sc_link;
d503 1
a503 1
	sc_link = sc->sc_link;
d513 2
a514 2
		if ((sc_link->flags & SDEV_REMOVABLE) != 0)
			scsi_prevent(sc_link, PR_ALLOW,
d517 1
a517 1
		sc_link->flags &= ~(SDEV_OPEN | SDEV_MEDIA_LOADED);
d519 3
a521 3
		if (sc_link->flags & SDEV_EJECTING) {
			scsi_start(sc_link, SSS_STOP|SSS_LOEJ, 0);
			sc_link->flags &= ~SDEV_EJECTING;
d541 1
a541 1
	struct scsi_link *sc_link;
d554 1
a554 1
	sc_link = sc->sc_link;
d556 1
a556 1
	SC_DEBUG(sc_link, SDEV_DB2, ("sdstrategy: %ld bytes @@ blk %lld\n",
d561 2
a562 2
	if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
		if (sc_link->flags & SDEV_OPEN)
d809 1
a809 1
	struct scsi_link *sc_link;
d820 1
a820 1
	sc_link = sc->sc_link;
d840 1
a840 1
	(*sc_link->adapter->scsi_minphys)(bp, sc_link);
d864 1
a864 1
	struct scsi_link *sc_link;
d877 1
a877 1
	sc_link = sc->sc_link;
d879 1
a879 1
	SC_DEBUG(sc_link, SDEV_DB2, ("sdioctl 0x%lx\n", cmd));
d884 1
a884 1
	if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
d895 1
a895 1
			if ((sc_link->flags & SDEV_OPEN) == 0) {
d949 1
a949 1
		error = scsi_prevent(sc_link,
d960 1
a960 1
		if ((sc_link->flags & SDEV_REMOVABLE) == 0) {
d964 1
a964 1
		sc_link->flags |= SDEV_EJECTING;
d968 1
a968 1
		error = scsi_do_ioctl(sc_link, cmd, addr, flag);
d989 1
a989 1
		error = scsi_do_ioctl(sc_link, cmd, addr, flag);
d1000 1
a1000 1
	struct scsi_link *sc_link;
d1005 1
a1005 1
	sc_link = sc->sc_link;
d1008 6
a1013 6
	scsi_strvis(di->vendor, sc_link->inqdata.vendor,
	    sizeof(sc_link->inqdata.vendor));
	scsi_strvis(di->product, sc_link->inqdata.product,
	    sizeof(sc_link->inqdata.product));
	scsi_strvis(di->revision, sc_link->inqdata.revision,
	    sizeof(sc_link->inqdata.revision));
d1016 1
a1016 1
	if (scsi_inquire_vpd(sc_link, vpd, sizeof(*vpd), SI_PG_SERIAL, 0) == 0)
d1028 1
a1028 1
	struct scsi_link *sc_link;
d1035 1
a1035 1
	sc_link = sc->sc_link;
d1037 1
a1037 1
	if (ISSET(sc_link->flags, SDEV_UMASS))
d1041 1
a1041 1
	rv = scsi_do_ioctl(sc_link, cmd, (caddr_t)dkc, 0);
d1049 1
a1049 1
	rv = scsi_do_mode_sense(sc_link, PAGE_CACHING_MODE,
d1084 1
a1084 1
			rv = scsi_mode_select_big(sc_link, SMS_PF,
d1087 1
a1087 1
			rv = scsi_mode_select(sc_link, SMS_PF,
d1105 1
a1105 1
	struct scsi_link *sc_link;
d1110 1
a1110 1
	sc_link = sc->sc_link;
d1125 1
a1125 1
	if ((sc_link->inqdata.device & SID_TYPE) == T_OPTICAL)
d1137 2
a1138 2
	viscpy(vendor, sc_link->inqdata.vendor, 8);
	viscpy(product, sc_link->inqdata.product, 16);
d1643 1
a1643 1
	struct scsi_link *sc_link;
d1664 1
a1664 1
	sc_link = sc->sc_link;
d1670 1
a1670 1
	err = scsi_do_mode_sense(sc_link, 0, buf, (void **)&page0,
d1674 1
a1674 1
			SET(sc_link->flags, SDEV_READONLY);
d1676 1
a1676 1
			SET(sc_link->flags, SDEV_READONLY);
d1678 1
a1678 1
			CLR(sc_link->flags, SDEV_READONLY);
d1686 1
a1686 1
	if ((sc_link->flags & SDEV_UMASS) && (dp->disksize > 0))
d1689 1
a1689 1
	switch (sc_link->inqdata.device & SID_TYPE) {
d1696 1
a1696 1
		err = scsi_do_mode_sense(sc_link, PAGE_REDUCED_GEOMETRY,
d1716 3
a1718 3
		if (((sc_link->flags & SDEV_ATAPI) == 0) ||
		    ((sc_link->flags & SDEV_REMOVABLE) == 0))
			err = scsi_do_mode_sense(sc_link,
d1728 1
a1728 1
			err = scsi_do_mode_sense(sc_link,
d1808 1
a1808 1
	struct scsi_link *sc_link;
d1812 1
a1812 1
	sc_link = sc->sc_link;
d1814 1
a1814 1
	if (sc_link->quirks & SDEV_NOSYNCCACHE)
d1823 1
a1823 1
	xs = scsi_xs_get(sc_link, flags);
d1825 1
a1825 1
		SC_DEBUG(sc_link, SDEV_DB1, ("cache sync failed to get xs\n"));
d1839 1
a1839 1
		SC_DEBUG(sc_link, SDEV_DB1, ("cache sync failed\n"));
@


1.263
log
@Do not access the scsi link of the disk at the beginning of sdopen()
and sdminphys() if the scsi disk is dying.  The memory of the link
may have been freed already.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.262 2016/02/03 15:16:33 bluhm Exp $	*/
d369 4
d381 4
d396 4
d414 4
a420 1

d430 4
d437 4
d464 4
d472 4
d479 1
@


1.262
log
@When accessing the scsi link of a scsi disk, use a variable "sc_link"
everywhere.  This is the first step to fix a use after free of the
sc_link when the disk detaches.  If a function gets a scsi transfer,
the scsi link is always valid.  Call this variable "link" consistently.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.261 2015/06/07 19:13:27 krw Exp $	*/
a343 2
	sc_link = sc->sc_link;

d348 2
d784 4
@


1.261
log
@More damned eye searing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.260 2015/04/02 14:24:02 jasper Exp $	*/
d202 1
a202 1
	if ((sc->sc_link->flags & SDEV_UMASS) == 0)
d377 1
a377 1
		if ((sc->sc_link->flags & SDEV_UMASS) == 0)
d441 1
a441 1
		if ((sc->sc_link->flags & SDEV_REMOVABLE) != 0)
d460 1
d471 1
d481 2
a482 2
		if ((sc->sc_link->flags & SDEV_REMOVABLE) != 0)
			scsi_prevent(sc->sc_link, PR_ALLOW,
d485 1
a485 1
		sc->sc_link->flags &= ~(SDEV_OPEN | SDEV_MEDIA_LOADED);
d487 3
a489 3
		if (sc->sc_link->flags & SDEV_EJECTING) {
			scsi_start(sc->sc_link, SSS_STOP|SSS_LOEJ, 0);
			sc->sc_link->flags &= ~SDEV_EJECTING;
d509 1
d522 1
d524 1
a524 1
	SC_DEBUG(sc->sc_link, SDEV_DB2, ("sdstrategy: %ld bytes @@ blk %lld\n",
d529 2
a530 2
	if ((sc->sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
		if (sc->sc_link->flags & SDEV_OPEN)
d777 1
d784 1
d804 1
a804 1
	(*sc->sc_link->adapter->scsi_minphys)(bp, sc->sc_link);
d828 1
d841 1
d843 1
a843 1
	SC_DEBUG(sc->sc_link, SDEV_DB2, ("sdioctl 0x%lx\n", cmd));
d848 1
a848 1
	if ((sc->sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
d859 1
a859 1
			if ((sc->sc_link->flags & SDEV_OPEN) == 0) {
d913 1
a913 1
		error = scsi_prevent(sc->sc_link,
d924 1
a924 1
		if ((sc->sc_link->flags & SDEV_REMOVABLE) == 0) {
d928 1
a928 1
		sc->sc_link->flags |= SDEV_EJECTING;
d932 1
a932 1
		error = scsi_do_ioctl(sc->sc_link, cmd, addr, flag);
d953 1
a953 1
		error = scsi_do_ioctl(sc->sc_link, cmd, addr, flag);
d964 1
d969 2
d972 6
a977 6
	scsi_strvis(di->vendor, sc->sc_link->inqdata.vendor,
	    sizeof(sc->sc_link->inqdata.vendor));
	scsi_strvis(di->product, sc->sc_link->inqdata.product,
	    sizeof(sc->sc_link->inqdata.product));
	scsi_strvis(di->revision, sc->sc_link->inqdata.revision,
	    sizeof(sc->sc_link->inqdata.revision));
d980 1
a980 2
	if (scsi_inquire_vpd(sc->sc_link, vpd, sizeof(*vpd),
	    SI_PG_SERIAL, 0) == 0)
d992 1
d999 3
a1001 1
	if (ISSET(sc->sc_link->flags, SDEV_UMASS))
d1005 1
a1005 1
	rv = scsi_do_ioctl(sc->sc_link, cmd, (caddr_t)dkc, 0);
d1013 1
a1013 1
	rv = scsi_do_mode_sense(sc->sc_link, PAGE_CACHING_MODE,
d1048 1
a1048 1
			rv = scsi_mode_select_big(sc->sc_link, SMS_PF,
d1051 1
a1051 1
			rv = scsi_mode_select(sc->sc_link, SMS_PF,
d1069 1
d1074 2
d1089 1
a1089 1
	if ((sc->sc_link->inqdata.device & SID_TYPE) == T_OPTICAL)
d1101 2
a1102 2
	viscpy(vendor, sc->sc_link->inqdata.vendor, 8);
	viscpy(product, sc->sc_link->inqdata.product, 16);
d1142 1
a1142 2
	struct scsi_link *sc_link = xs->sc_link;
	struct sd_softc *sc = sc_link->device_softc;
d1150 1
a1150 1
	if (((sc_link->flags & SDEV_OPEN) == 0) ||
d1161 1
a1161 1
		SC_DEBUG(sc_link, SDEV_DB1, ("becoming ready.\n"));
d1166 2
a1167 2
		SC_DEBUG(sc_link, SDEV_DB1, ("spinning up\n"));
		retval = scsi_start(sc->sc_link, SSS_START,
d1175 1
a1175 1
			SC_DEBUG(sc_link, SDEV_DB1, ("spin up failed (%#x)\n",
d1607 1
d1628 2
d1634 1
a1634 1
	err = scsi_do_mode_sense(sc->sc_link, 0, buf, (void **)&page0,
d1638 1
a1638 1
			SET(sc->sc_link->flags, SDEV_READONLY);
d1640 1
a1640 1
			SET(sc->sc_link->flags, SDEV_READONLY);
d1642 1
a1642 1
			CLR(sc->sc_link->flags, SDEV_READONLY);
d1650 1
a1650 1
	if ((sc->sc_link->flags & SDEV_UMASS) && (dp->disksize > 0))
d1653 1
a1653 1
	switch (sc->sc_link->inqdata.device & SID_TYPE) {
d1660 1
a1660 1
		err = scsi_do_mode_sense(sc->sc_link, PAGE_REDUCED_GEOMETRY,
d1680 3
a1682 3
		if (((sc->sc_link->flags & SDEV_ATAPI) == 0) ||
		    ((sc->sc_link->flags & SDEV_REMOVABLE) == 0))
			err = scsi_do_mode_sense(sc->sc_link,
d1692 1
a1692 1
			err = scsi_do_mode_sense(sc->sc_link,
d1772 1
a1772 1
	struct scsi_link *link = sc->sc_link;
d1776 3
a1778 1
	if (link->quirks & SDEV_NOSYNCCACHE)
d1787 1
a1787 1
	xs = scsi_xs_get(link, flags);
d1789 1
a1789 1
		SC_DEBUG(link, SDEV_DB1, ("cache sync failed to get xs\n"));
d1803 1
a1803 1
		SC_DEBUG(link, SDEV_DB1, ("cache sync failed\n"));
@


1.260
log
@use correct capitalization of 'BlackBerry'

"sure" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.259 2015/03/08 20:49:38 krw Exp $	*/
d289 1
a289 1
	 	 * completion.
d1614 1
a1614 1
	 * READONLY info. The only thing USB devices will ask for. 
d1656 1
a1656 1
		 * NOTE: Some devices leave off the last four bytes of 
@


1.259
log
@Fix some format specifiers in debug code.

Pointed out by Kor son of Rynar (sic) when trying to test
some debug code.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.258 2014/12/15 02:11:57 tedu Exp $	*/
d206 1
a206 1
	 * Some devices (e.g. Blackberry Pearl) won't admit they have
@


1.258
log
@convert bcopy to memcpy. ok dlg krw
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.257 2014/09/18 18:47:29 kettenis Exp $	*/
d1717 1
a1717 1
		    ("sd_get_parms: bad secsize: %#x\n", dp->secsize));
@


1.257
log
@Some disks, such as the Seagate Cheetah 73LP FC with Sun firmware
(ST373405FSUN72G) respond to a START STOP UNIT command that spins down the
disk with a "Logical Unit Not Ready, Initialization Command Required".
Besides causing some dmesg spam, our sd(4) driver responds to such a response
by spinning the disk back up.  Prevent this from happening by respecting
the SCSI_IGNORE_NOT_READY flag and using that flag when spinning down the
disk.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.256 2014/09/14 14:17:26 jsg Exp $	*/
d865 2
a866 2
		bcopy(lp, sc->sc_dk.dk_label, sizeof(*lp));
		free(lp, M_TEMP, 0);
d1098 1
a1098 1
	bcopy(packname, lp->d_packname, len);
@


1.256
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.255 2014/07/12 18:50:25 tedu Exp $	*/
d295 2
a296 1
			    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_AUTOCONF);
d1140 3
@


1.255
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.254 2014/07/10 19:13:55 mpi Exp $	*/
a67 1
#include <sys/proc.h>
@


1.254
log
@Now that sd(4) drives under softraid0 have their cache flushed when
DVACT_POWERDOWN is propagated in this subtree, there is no need for
this shutdown hook anymore. RIP.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.253 2014/02/19 10:15:35 mpi Exp $	*/
d866 1
a866 1
		free(lp, M_TEMP);
@


1.253
log
@If a disk returns a size of 0, treat it as an error to let the
driver re-probe for its capacity.

Allow to fully recognized Lexar JumpDrive S33 USB 3.0 sticks.

ok krw@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.252 2014/02/13 05:51:06 halex Exp $	*/
a90 1
void	sd_shutdown(void *);
a265 13
	/*
	 * Establish a shutdown hook so that we can ensure that
	 * our data has actually made it onto the platter at
	 * shutdown time.  Note that this relies on the fact
	 * that the shutdown hook code puts us at the head of
	 * the list (thus guaranteeing that our hook runs before
	 * our ancestors').
	 */
	if ((sc->sc_sdhook =
	    shutdownhook_establish(sd_shutdown, sc)) == NULL)
		printf("%s: WARNING: unable to establish shutdown hook\n",
		    sc->sc_dev.dv_xname);

d289 2
a290 1
		 * first.
a318 4
	/* Get rid of the shutdown hook. */
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);

a1117 14

void
sd_shutdown(void *arg)
{
	struct sd_softc *sc = (struct sd_softc *)arg;

	/*
	 * If the disk cache needs to be flushed, and the disk supports
	 * it, flush it.  We're cold at this point, so we poll for
	 * completion.
	 */
	if ((sc->flags & SDF_DIRTY) != 0)
		sd_flush(sc, SCSI_AUTOCONF);
}
@


1.252
log
@if an attached sd(4) is readonly, make sure it's noticable in the
dmesg, or write operations just fail with EACCES for no obvious reason

ok krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.251 2013/11/01 17:36:19 krw Exp $	*/
d1442 5
@


1.251
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.250 2013/10/03 14:07:42 krw Exp $	*/
d235 3
@


1.250
log
@Print daddr_t variables with %lld, u_int64_t variables with %llu.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.249 2013/10/02 18:59:04 krw Exp $	*/
d535 1
a535 1
	    bp->b_bcount, bp->b_blkno));
d1328 2
a1329 1
		printf("sd%d: dump addr 0x%x, blk %lld\n", unit, va, blkno);
@


1.249
log
@Use u_int64_t instead of daddr_t parameters to sd_cmd_rw*() functions.
Ditto disksize field of sd_softc and a couple of local calculation
variables.

scsi/* now daddr_t clean except where they really are 512-byte
blocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.248 2013/09/19 19:26:16 krw Exp $	*/
d228 1
a228 1
		printf("%s: %lldMB, %lu bytes/sector, %lld sectors",
d534 1
a534 1
	SC_DEBUG(sc->sc_link, SDEV_DB2, ("sdstrategy: %ld bytes @@ blk %d\n",
d1328 1
a1328 1
		printf("sd%d: dump addr 0x%x, blk %d\n", unit, va, blkno);
@


1.248
log
@Tweak types to keep daddr_t address and sector address separate.
Prefer DL_ macros over handrolling. Fix the loop to allow for bigger
(highly unlikely) bunches of bits to be broken up into rw_10 sized
(<= UINT32_MAX sectors) chunks. Add check to make sure i/o request
starts at a sector address.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.247 2013/09/15 14:35:50 krw Exp $	*/
d108 4
a111 4
void	sd_cmd_rw6(struct scsi_xfer *, int, daddr_t, u_int);
void	sd_cmd_rw10(struct scsi_xfer *, int, daddr_t, u_int);
void	sd_cmd_rw12(struct scsi_xfer *, int, daddr_t, u_int);
void	sd_cmd_rw16(struct scsi_xfer *, int, daddr_t, u_int);
d575 1
a575 1
sd_cmd_rw6(struct scsi_xfer *xs, int read, daddr_t secno, u_int nsecs)
d587 1
a587 1
sd_cmd_rw10(struct scsi_xfer *xs, int read, daddr_t secno, u_int nsecs)
d599 1
a599 1
sd_cmd_rw12(struct scsi_xfer *xs, int read, daddr_t secno, u_int nsecs)
d611 1
a611 1
sd_cmd_rw16(struct scsi_xfer *xs, int read, daddr_t secno, u_int nsecs)
d641 1
a641 1
	daddr_t secno;
@


1.247
log
@Use DL_SECTOBLK() and DL_BLKTOSEC() to clarify code and remove
repeated handrolling of same code. Use daddr_t variable to
calculate daddr_t return values, and u_int64_t variables to
calculate disk sector values.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.246 2013/06/11 16:42:17 deraadt Exp $	*/
d50 1
d1249 5
a1253 5
	int	sectorsize;	/* size of a disk sector */
	daddr_t	nsects;		/* number of sectors in partition */
	daddr_t	sectoff;	/* sector offset of partition */
	int	totwrt;		/* total number of sectors left to write */
	int	nwrt;		/* current number of sectors to write */
d1260 2
d1289 2
d1292 1
a1292 1
	blkno = dbtob(blkno) / sectorsize;	/* blkno in DEV_BSIZE units */
d1298 1
a1298 1
	if ((blkno < 0) || ((blkno + totwrt) > nsects))
d1305 4
a1308 1
		nwrt = totwrt;		/* XXX */
@


1.246
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.245 2012/12/19 19:52:11 kettenis Exp $	*/
d661 2
a662 1
	secno = bp->b_blkno / (sc->sc_dk.dk_label->d_secsize / DEV_BSIZE);
d1199 1
d1202 1
a1202 1
	int64_t size;
d1219 2
d1223 1
a1223 1
	else if (sc->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)
d1226 1
a1226 2
		size = DL_GETPSIZE(&sc->sc_dk.dk_label->d_partitions[part]) *
			(sc->sc_dk.dk_label->d_secsize / DEV_BSIZE);
@


1.245
log
@Temporarily bring back the shutdown hook, but only use it to flush the disk
cache.  This shouldn't interfere with the hibernate code and makes sure we
still flush the cache for controller that don't pass DVACT_POWRDOWN down to
their children yet.  This will be removed when the autoconf subsystem gets
changed to do that for us by default.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.244 2012/10/15 16:29:07 deraadt Exp $	*/
d107 4
a110 4
void	sd_cmd_rw6(struct scsi_xfer *, int, daddr64_t, u_int);
void	sd_cmd_rw10(struct scsi_xfer *, int, daddr64_t, u_int);
void	sd_cmd_rw12(struct scsi_xfer *, int, daddr64_t, u_int);
void	sd_cmd_rw16(struct scsi_xfer *, int, daddr64_t, u_int);
d574 1
a574 1
sd_cmd_rw6(struct scsi_xfer *xs, int read, daddr64_t secno, u_int nsecs)
d586 1
a586 1
sd_cmd_rw10(struct scsi_xfer *xs, int read, daddr64_t secno, u_int nsecs)
d598 1
a598 1
sd_cmd_rw12(struct scsi_xfer *xs, int read, daddr64_t secno, u_int nsecs)
d610 1
a610 1
sd_cmd_rw16(struct scsi_xfer *xs, int read, daddr64_t secno, u_int nsecs)
d640 1
a640 1
	daddr64_t secno;
d1195 1
a1195 1
daddr64_t
d1240 1
a1240 1
sddump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
d1246 2
a1247 2
	daddr64_t	nsects;		/* number of sectors in partition */
	daddr64_t	sectoff;	/* sector offset of partition */
@


1.244
log
@In DVACT_SUSPEND, do a flush of the disk. We do this in DVACT_POWERDOWN
as well, but it might be wise to flush before a hibernate operation, in
case hiberate looks at blocks which are in the buffer cache.
ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.243 2012/10/08 21:47:51 deraadt Exp $	*/
d90 1
d263 13
d328 4
d1128 15
@


1.243
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.242 2012/07/09 12:58:01 krw Exp $	*/
d274 6
@


1.242
log
@Revert previous.

The standards gpds are jealous gods. kettenis@@ and beck@@ have shown
EROFS is the wrong thing to return. So revert to EACCES until a
better error code is decided on.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.241 2012/07/08 14:30:59 krw Exp $	*/
a89 1
void	sd_shutdown(void *);
a261 13
	/*
	 * Establish a shutdown hook so that we can ensure that
	 * our data has actually made it onto the platter at
	 * shutdown time.  Note that this relies on the fact
	 * that the shutdown hook code puts us at the head of
	 * the list (thus guaranteeing that our hook runs before
	 * our ancestors').
	 */
	if ((sc->sc_sdhook =
	    shutdownhook_establish(sd_shutdown, sc)) == NULL)
		printf("%s: WARNING: unable to establish shutdown hook\n",
		    sc->sc_dev.dv_xname);

d274 2
d283 3
a285 2
		scsi_start(sc->sc_link, SSS_STOP,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_AUTOCONF);
a307 4
	/* Get rid of the shutdown hook. */
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);

a1103 25
}


void
sd_shutdown(void *arg)
{
	struct sd_softc *sc = (struct sd_softc *)arg;

	/*
	 * If the disk cache needs to be flushed, and the disk supports
	 * it, flush it.  We're cold at this point, so we poll for
	 * completion.
	 */
	if ((sc->flags & SDF_DIRTY) != 0)
		sd_flush(sc, SCSI_AUTOCONF);
	if (boothowto & RB_POWERDOWN)
		scsi_start(sc->sc_link, SSS_STOP,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_AUTOCONF);

	/*
	 * There should be no outstanding IO at this point, but lets stop
	 * it just in case.
	 */
	timeout_del(&sc->sc_timeout);
	scsi_xsh_del(&sc->sc_xsh);
@


1.241
log
@Return EROFS when a read-write mount of a read-only sd(4) device
is attempted. This is instead of the current EACCES and is intended
to result in better error messages from mount(8).

Tweak default EROFS error text to mention fsck'ing in mount_ext2fs
and mount_msdos since they both have fsck's like ffs.

ok deraadt@@ aja@@ ian@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.240 2012/06/10 21:29:04 krw Exp $	*/
d356 1
a356 1
		return (EROFS);
@


1.240
log
@Do NOT make all check condition results report EIO. Only use EIO
when b_error has not already been set to something more informative,
e.g. EROFS.

DO check the result of ffs_sbupdate() and error out of a mount()
call when ffs_sbupdate() reports EROFS while attempting a rw mount.

Letting RW mounts proceed regardless of EROFS led to crashes and
usb problems for Oliver Seufer while using the RW/RO switches on
some usb devices. Fix developed using devices kindly supplied by
Oliver & Co.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.239 2011/10/10 20:39:20 kettenis Exp $	*/
d356 1
a356 1
		return (EACCES);
@


1.239
log
@Put the drive in standby mode when we're powering down the machine.

tested by dcoppa@@, ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.238 2011/07/18 00:13:16 matthew Exp $	*/
d735 2
a736 1
		if (error != ERESTART)
d738 1
d757 2
a758 1
		bp->b_error = EIO;
@


1.238
log
@Fix an off-by-1 error and a 32-bit integer arithmetic overflow bug
that caused large disks to appear offline.

Discovered and tested by mlarkin@@; ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.237 2011/07/12 04:25:49 dlg Exp $	*/
d71 1
d1131 3
@


1.237
log
@fix some notyet code
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.236 2011/07/12 00:41:43 dlg Exp $	*/
d1377 1
a1377 1
		sc->params.disksize = _4btol(rdcap->addr) + 1;
d1445 1
a1445 1
		if (rv == 0 && sc->params.disksize == 0xffffffff)
@


1.236
log
@now that we know if a disk is thin provisioned (or an ssd), we can choose
to use the fifo bufq sorting on such disks. there's no point ordering io
if the real blocks arent in the order we think they are.

ok krw@@ tedu@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.235 2011/07/11 06:26:09 dlg Exp $	*/
d1551 1
a1551 1
	if (ISSET(pg->flags, VPD_DISK_THIN_TPU)
d1553 1
a1553 1
	else if (ISSET(pg->flags, VPD_DISK_THIN_TPWS) {
@


1.235
log
@ask the disk about unmap (read trim) parameters. check if we have the
required vpd pages, then read them for the values we want.

we look for the max blocks per unmap, the max descriptors per unmap, and
which scsi command to use for unmapping (unmap will be preferred).

two fixes and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.234 2011/07/11 00:22:15 dlg Exp $	*/
d166 1
a166 1
	int error, result;
a176 6
	/*
	 * Initialize disk structures.
	 */
	sc->sc_dk.dk_name = sc->sc_dev.dv_xname;
	bufq_init(&sc->sc_bufq, BUFQ_DEFAULT);

d230 2
a231 1
		if (ISSET(sc->flags, SDF_THIN))
d233 1
d247 9
@


1.234
log
@disks report trim^Wunmap^Wif theyre thin provisioned via a bit in
the read cap 16 data. move the read cap code into sd.c so i can get
at this bit without much contorting, and to make it trivial to get
at the other interesting things in there later.

thin disks report themselves as "thin" in dmesg along with their
size now.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.233 2011/07/06 04:49:36 matthew Exp $	*/
d94 4
d1447 133
d1597 1
a1597 2
	err = sd_size(sc, flags);
	if (err != 0)
d1599 5
@


1.233
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.232 2011/07/03 15:47:18 matthew Exp $	*/
d91 3
d228 1
a228 1
		printf("%s: %lldMB, %lu bytes/sec, %lld sec total\n",
d232 3
d1336 107
d1457 1
a1457 1
	u_int32_t heads = 0, sectors = 0, cyls = 0, secsize = 0, sssecsize;
d1460 3
a1462 1
	dp->disksize = scsi_size(sc->sc_link, flags, &sssecsize);
d1555 1
a1555 3
	if (sssecsize > 0)
		dp->secsize = sssecsize;
	else
@


1.232
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.231 2011/06/30 16:28:05 matthew Exp $	*/
a519 5
	/*
	 * If it's a null transfer, return immediately
	 */
	if (bp->b_bcount == 0)
		goto done;
d521 2
a522 12
	/*
	 * The transfer must be a whole number of sectors.
	 */
	if ((bp->b_bcount % sc->sc_dk.dk_label->d_secsize) != 0) {
		bp->b_error = EINVAL;
		goto bad;
	}
	/*
	 * Do bounds checking, adjust transfer. if error, process.
	 * If end of partition, just return.
	 */
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label) <= 0)
d537 1
a537 1
bad:
a538 4
done:
	/*
	 * Correctly set the buf to indicate a completed xfer
	 */
d540 1
@


1.231
log
@Refactor some common open/close/detach disk driver code into
subr_disk.c.  For now just the MI disk drivers.

ok deraadt@@, krw@@; jsing@@ liked the approach too
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.230 2011/06/19 04:55:34 deraadt Exp $	*/
a270 2
	case DVACT_ACTIVATE:
		break;
@


1.230
log
@Use disk_lock_nointr() in the xxclose() routines so that they cannot
be interrupted.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.229 2011/06/19 04:35:06 deraadt Exp $	*/
a299 1
	int bmaj, cmaj, mn;
d303 1
a303 9
	/* Locate the lowest minor number to be detached. */
	mn = DISKMINOR(self->dv_unit, 0);

	for (bmaj = 0; bmaj < nblkdev; bmaj++)
		if (bdevsw[bmaj].d_open == sdopen)
			vdevgone(bmaj, mn, mn + MAXPARTITIONS - 1, VBLK);
	for (cmaj = 0; cmaj < nchrdev; cmaj++)
		if (cdevsw[cmaj].d_open == sdopen)
			vdevgone(cmaj, mn, mn + MAXPARTITIONS - 1, VCHR);
d422 2
a423 5
	/* Check that the partition exists. */
	if (part != RAW_PART &&
	    (part >= sc->sc_dk.dk_label->d_npartitions ||
	    sc->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
		error = ENXIO;
a424 1
	}
a425 10
out:	/* Insure only one open at a time. */
	switch (fmt) {
	case S_IFCHR:
		sc->sc_dk.dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		sc->sc_dk.dk_bopenmask |= (1 << part);
		break;
	}
	sc->sc_dk.dk_openmask = sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;
d463 1
a463 9
	switch (fmt) {
	case S_IFCHR:
		sc->sc_dk.dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		sc->sc_dk.dk_bopenmask &= ~(1 << part);
		break;
	}
	sc->sc_dk.dk_openmask = sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;
@


1.229
log
@Use disk_lock/disk_unlock directly and in the same way in these drivers,
rather than using various wrappings.  Convert vnd to using the sc_dk
rwlock instead of using one of its own.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.228 2011/06/05 18:40:33 matthew Exp $	*/
a474 1
	int error;
d484 1
a484 4
	if ((error = disk_lock(&sc->sc_dk)) != 0) {
		device_unref(&sc->sc_dev);
		return (error);
	}
@


1.228
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.227 2011/06/03 21:14:11 matthew Exp $	*/
a129 2
#define sdlock(softc)   disk_lock(&(softc)->sc_dk)
#define sdunlock(softc) disk_unlock(&(softc)->sc_dk)
d358 1
a358 1
	if ((error = sdlock(sc)) != 0) {
d461 1
a461 1
	sdunlock(sc);
d485 1
a485 1
	if ((error = sdlock(sc)) != 0) {
d519 1
a519 1
	sdunlock(sc);
d929 1
a929 1
		if ((error = sdlock(sc)) != 0)
d940 1
a940 1
		sdunlock(sc);
@


1.227
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.226 2011/05/31 17:35:35 matthew Exp $	*/
a882 1
		case DIOCWLABEL:
a932 1
		sc->flags |= SDF_LABELLING;
a941 1
		sc->flags &= ~SDF_LABELLING;
a942 11
		goto exit;

	case DIOCWLABEL:
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}
		if (*(int *)addr)
			sc->flags |= SDF_WLABEL;
		else
			sc->flags &= ~SDF_WLABEL;
@


1.226
log
@Change a few of the more common disk drivers (sd, cd, wd, rd, and vnd)
to return EBUSY if the user tries to modify an open partition's offset
or size.  Only sadness can result if a user tries this, and rejecting
it prevents a race between sdstart() and sdstrategy().

Curiously, there was already code in the kernel and in disklabel(8) to
detect/handle this, but it was effectively disabled because the disk
drivers always used something like "/* sc->sc_dk.dk_openmask */ 0",
and this commented out code has existed since even r1.1 in NetBSD.

I had no problems building a release and messing around with
disklabel(8) for a bit with this diff.  Canarying the more common MI
disk drivers until we gain confidence that there aren't any
regressions, then we can switch the remaining drivers.

"I am surprised you got me convinced that this stuff is safe" deraadt@@
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.225 2011/04/08 10:37:39 krw Exp $	*/
d576 1
a576 2
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label,
	    (sc->flags & (SDF_WLABEL|SDF_LABELLING)) != 0) <= 0)
@


1.225
log
@Since we don't print "drive offline" anymore, there is no need to
print the "sdN:" at the start of the now empty line. Noted by
miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.224 2011/04/07 15:30:16 miod Exp $	*/
d938 1
a938 1
		    (struct disklabel *)addr, /*sd->sc_dk.dk_openmask : */0);
@


1.224
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.223 2011/04/07 00:05:18 krw Exp $	*/
a224 1
	printf("%s: ", sc->sc_dev.dv_xname);
d227 2
a228 1
		printf("%lldMB, %lu bytes/sec, %lld sec total",
a241 1
	printf("\n");
@


1.223
log
@'disk offline' is not helpful. Silence is golden.

Prodded repeatedly by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.222 2011/03/31 18:42:48 jasper Exp $	*/
d740 1
a740 1
	else if (bufq_peek(&sc->sc_bufq) != NULL)
@


1.222
log
@- use nitems(); no binary change.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.221 2011/03/17 21:30:24 deraadt Exp $	*/
a233 1
		printf("drive offline");
@


1.221
log
@use dma_alloc/dma_free instead of malloc to allocate buffers which need
to be in the right address space.
help from matthew and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.220 2011/02/21 20:51:02 krw Exp $	*/
d141 1
a141 1
	    sd_patterns, sizeof(sd_patterns)/sizeof(sd_patterns[0]),
@


1.220
log
@If a spin up command can't be started becaause of a lack of openings,
delay and retry the original command rather than immediately erroring
out.

Fixes USB drives that spin themselves down due to inactivity, as
confirmed by pirofti@@ and jsg@@.

ok miod@@, rough agreement pending more general solution dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.219 2010/12/24 02:45:33 krw Exp $	*/
d62 1
d1014 3
a1016 1
	struct scsi_vpd_serial vpd;
d1027 1
a1027 1
	if (scsi_inquire_vpd(sc->sc_link, &vpd, sizeof(vpd),
d1029 1
a1029 1
		scsi_strvis(di->serial, vpd.serial, sizeof(vpd.serial));
d1031 1
a1031 1
		strlcpy(di->serial, "(unknown)", sizeof(vpd.serial));
d1033 1
d1051 1
a1051 1
	if (rv != ENOTTY) {
a1052 1
	}
d1054 1
a1054 1
	buf = malloc(sizeof(*buf), M_TEMP, M_WAITOK|M_CANFAIL);
d1103 1
a1103 1
	free(buf, M_TEMP);
d1423 1
a1423 1
	buf = malloc(sizeof(*buf), M_TEMP, M_NOWAIT);
d1509 1
a1509 1
		free(buf, M_TEMP);
@


1.219
log
@Have sd(4) devices check for and respect read-only information the
way st(4) does. Have both decline to open read-only devices for
anything but read-only access.

Suggestion to fail opens rather than individual i/o's from deraadt@@.

Problem USB device found and donated by chefren, who also tested
diffs. Thanks!

ok dlg@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.218 2010/09/24 01:41:34 dlg Exp $	*/
d1229 3
@


1.218
log
@init err to 0 in sd_get_parms to avoid confusion when checking rigid
geometry. it doesnt matter waht the value there is cos rigid will be NULL,
but this is clearer.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.217 2010/09/22 01:18:57 matthew Exp $	*/
d346 2
d352 4
a356 1
	sc_link = sc->sc_link;
d1411 1
d1413 1
a1413 1
	int err = 0;
d1417 19
a1441 4
		goto validate;	 /* N.B. buf will be NULL at validate. */

	buf = malloc(sizeof(*buf), M_TEMP, M_NOWAIT);
	if (buf == NULL)
@


1.217
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.216 2010/09/21 12:20:53 krw Exp $	*/
d1407 1
a1407 1
	int err;
@


1.216
log
@Add a real DIOCGPDINFO, allowing access to the physical information
about the device rather than the contents of whichever disklabel
was read. Tweak whitespace in sd.c to make the code appearance
consistant.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.215 2010/09/20 02:51:52 deraadt Exp $	*/
d844 1
a844 1
	return (physio(sdstrategy, NULL, dev, B_READ, sdminphys, uio));
d850 1
a850 1
	return (physio(sdstrategy, NULL, dev, B_WRITE, sdminphys, uio));
@


1.215
log
@bufq_drain() does not need to be done in deactivate; we only need
to deactivate transactions we are currently doing.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.214 2010/09/12 02:05:54 krw Exp $	*/
d907 1
@


1.214
log
@Garbage collect rot_rate from disk_parms. No longer in disk label so no
need to calculate and save. Not used anywhere in tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.213 2010/09/11 22:40:10 krw Exp $	*/
a292 1
		bufq_drain(&sc->sc_bufq);
@


1.213
log
@Be more ruthlessly consistent in variable names for blk/block ==
512 == DEV_BSIZE units and variable-sized physical device 'sectors'.
I hope this reduces confusion a bit more. No change to .o files.

ok for intent miod@@, with tweak.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.212 2010/09/10 04:46:24 dlg Exp $	*/
a1406 1
	u_int16_t rpm = 0;
a1458 1
			rpm = _2btol(rigid->rpm);
a1470 1
				rpm = _2btol(flex->rpm);
a1527 1
		dp->rot_rate = (rpm == 0) ? 3600 : rpm;
@


1.212
log
@scsi_xsh_del the io handler in deactivate to prevent it from being run on
a device thats now gone, or from being on the list of pending io when
the device is actually detached.

found and fix tested by jakemsr@@
"go for it" jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.211 2010/09/08 15:16:22 jsing Exp $	*/
d228 1
a228 1
		    dp->disksize / (1048576 / dp->blksize), dp->blksize,
d604 1
a604 1
sd_cmd_rw6(struct scsi_xfer *xs, int read, daddr64_t blkno, u_int nblks)
d609 2
a610 2
	_lto3b(blkno, cmd->addr);
	cmd->length = nblks;
d616 1
a616 1
sd_cmd_rw10(struct scsi_xfer *xs, int read, daddr64_t blkno, u_int nblks)
d621 2
a622 2
	_lto4b(blkno, cmd->addr);
	_lto2b(nblks, cmd->length);
d628 1
a628 1
sd_cmd_rw12(struct scsi_xfer *xs, int read, daddr64_t blkno, u_int nblks)
d633 2
a634 2
	_lto4b(blkno, cmd->addr);
	_lto4b(nblks, cmd->length);
d640 1
a640 1
sd_cmd_rw16(struct scsi_xfer *xs, int read, daddr64_t blkno, u_int nblks)
d645 2
a646 2
	_lto8b(blkno, cmd->addr);
	_lto4b(nblks, cmd->length);
d670 2
a671 2
	daddr64_t blkno;
	int nblks;
d691 1
a691 1
	blkno = bp->b_blkno / (sc->sc_dk.dk_label->d_secsize / DEV_BSIZE);
d693 2
a694 2
	blkno += DL_GETPOFFSET(p);
	nblks = howmany(bp->b_bcount, sc->sc_dk.dk_label->d_secsize);
d703 9
a711 9
	    ((blkno & 0x1fffff) == blkno) &&
	    ((nblks & 0xff) == nblks))
		sd_cmd_rw6(xs, read, blkno, nblks);
	else if (((blkno & 0xffffffff) == blkno) &&
	    ((nblks & 0xffff) == nblks))
		sd_cmd_rw10(xs, read, blkno, nblks);
	else if (((blkno & 0xffffffff) == blkno) &&
	    ((nblks & 0xffffffff) == nblks))
		sd_cmd_rw12(xs, read, blkno, nblks);
d713 1
a713 1
		sd_cmd_rw16(xs, read, blkno, nblks);
d1112 1
a1112 1
	lp->d_secsize = sc->params.blksize;
d1406 1
a1406 1
	u_int32_t heads = 0, sectors = 0, cyls = 0, blksize = 0, ssblksize;
d1410 1
a1410 1
	dp->disksize = scsi_size(sc->sc_link, flags, &ssblksize);
d1432 1
a1432 1
		    buf, (void **)&reduced, NULL, NULL, &blksize,
d1438 2
a1439 2
			if (blksize == 0)
				blksize = _2btol(reduced->bytes_s);
d1455 1
a1455 1
			    NULL, &blksize, sizeof(*rigid) - 4,
d1466 1
a1466 1
			    &blksize, sizeof(*flex) - 4,
d1474 2
a1475 2
				if (blksize == 0)
					blksize = _2btol(flex->bytes_s);
d1490 2
a1491 2
	if (ssblksize > 0)
		dp->blksize = ssblksize;
d1493 1
a1493 1
		dp->blksize = (blksize == 0) ? 512 : blksize;
d1496 1
a1496 1
	 * Restrict blksize values to powers of two between 512 and 64k.
d1498 1
a1498 1
	switch (dp->blksize) {
d1510 1
a1510 1
		    ("sd_get_parms: bad blksize: %#x\n", dp->blksize));
@


1.211
log
@Introduce a disk_lookup() function which calls device_lookup(), before
verifying that the resulting device is present on the disklist. This
avoids a race whereby the disk driver can be accessed as soon as the
softc has been allocated, but before the disk has completed
initialisation and has called disk_attach() (up until this point
dk_label is still a null pointer).

Cut cd(4), sd(4) and wd(4) across to disk_lookup(). All callers of
disk_attach() need to be tested and cut over in due course.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.210 2010/09/08 14:47:12 jsing Exp $	*/
d294 1
@


1.210
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.208 2010/09/01 01:38:12 dlg Exp $	*/
d131 1
a131 1
#define sdlookup(unit) (struct sd_softc *)device_lookup(&sd_cd, (unit))
@


1.209
log
@Restore compilability after bufq changes
@
text
@d264 1
a264 1
	disk_attach(&sc->sc_dk);
@


1.208
log
@make struct bufq a member of the softc for devices that use it,
rather than it being a pointer to something that needs to be allocated
at attach. since all these devices need a bufq to operate, it makes
sense to have it allocated as part of the softc and get bufq_init
to just initialise all its fields. it also gets rid of the possibility
that you wont be able to allocate the bufq struct during attach,
which is something you dont want to happen.

secondly, it consistently implements a split between wrapper functions
and the per discipline implementation of the bufq handlers. it
consistently does the locking in the wrappers rather than doing
half in the wrappers and the other half in the implementations.

it also consistently handles the outstanding bufq bq pointer in the
wrappers.

this hides most of the implementation inside kern_bufq.c. the only
stuff left in buf.h is for the bits each implementation needs to
put inside struct buf.

tested by thib@@ krw@@ and me
ok thib@@ matthew@@
no objection from krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.207 2010/08/31 16:34:38 deraadt Exp $	*/
d293 1
a293 1
		bufq_drain(sc->sc_bufq);
@


1.207
log
@in the activate function, order the DVACT_ functions in the order they
can expect to be used
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.206 2010/08/28 20:23:22 matthew Exp $	*/
d175 1
a175 1
	sc->sc_bufq = bufq_init(BUFQ_DEFAULT);
d305 1
a305 1
	bufq_drain(sc->sc_bufq);
d322 1
a322 1
	bufq_destroy(sc->sc_bufq);
d577 1
a577 1
	BUFQ_QUEUE(sc->sc_bufq, bp);
d679 1
a679 1
		bufq_drain(sc->sc_bufq);
d684 1
a684 1
	bp = BUFQ_DEQUEUE(sc->sc_bufq);
d735 1
a735 1
	else if (BUFQ_PEEK(sc->sc_bufq) != NULL)
d756 1
a756 1
		BUFQ_REQUEUE(sc->sc_bufq, bp);
@


1.206
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.205 2010/08/03 19:37:17 krw Exp $	*/
a275 6

	case DVACT_DEACTIVATE:
		sc->flags |= SDF_DYING;
		bufq_drain(sc->sc_bufq);
		break;

a286 1

d291 4
a295 1

@


1.205
log
@Don't attempt to set the read or write caches on usb disks. It
breaks at least one previously working device, as discovered by
naddy@@. dlg@@ confirmed other kernels also avoid attempting this
operation on usb disks.

ok dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.204 2010/07/07 03:53:07 marco Exp $	*/
a113 2
struct dkdriver sddkdriver = { sdstrategy };

a173 1
	sc->sc_dk.dk_driver = &sddkdriver;
@


1.204
log
@Pull out disk sort.  I committed the wrong version of the diff and it
wasn't ok deraadt & dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.202 2010/07/03 01:40:12 kettenis Exp $	*/
d1042 3
@


1.203
log
@Enable FIFO IO for sd devices.  This time committed against the actual tree.

Tested by lots of people during c2k10

ok phessler krw thib
@
text
@d178 1
a178 5

	if (SCSISPC(sc_link->inqdata.version) >= 2)
		sc->sc_bufq = bufq_init(BUFQ_FIFO);
	else
		sc->sc_bufq = bufq_init(BUFQ_DEFAULT);
@


1.202
log
@Stop disk on suspend and start it again upon resume.  Gets rid of the loud
click upon suspend that my laptop with ahci(4) has.

ok dlg@@, ok marco@@ on an earlier iteration of this diff
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.201 2010/07/01 05:11:18 krw Exp $	*/
d178 5
a182 1
	sc->sc_bufq = bufq_init(BUFQ_DEFAULT);
@


1.201
log
@Die struct scsi_device! Die! Instead, save a pointer to the routine
to interpret sense errors. This is initialized to the basic
interpretation routine, and specific scsi drivers (sd/st/cd) can
replace this with their own. While here kill EJUSTRETURN dance and
make more specialized interpretation routines directly call the
basic routine if desired.

Fixes by matthew@@ to my first diff. Most original work by dlg@@.

ok matthew@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.200 2010/07/01 03:01:37 matthew Exp $	*/
d284 1
d287 3
a289 3
		 * If the disk cache needs to be flushed, and the disk
		 * supports it, flush it.  We're cold at this point,
		 * so we poll for completion.
d293 2
d296 1
d298 2
a304 1

@


1.200
log
@Restore setting xs->bp; fixes ncr(4) on VAX.

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.199 2010/06/30 19:06:29 kettenis Exp $	*/
a115 7
struct scsi_device sd_switch = {
	sd_interpret_sense,	/* check out error handler first */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* have no done handler */
};

d170 1
a170 1
	sc_link->device = &sd_switch;
d766 4
a769 1
		error = scsi_interpret_sense(xs);
d1208 1
a1208 1
		return (EJUSTRETURN);
d1228 1
a1228 1
		retval = EJUSTRETURN;
@


1.199
log
@Flush cache before suspend.

ok krw@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.198 2010/06/28 08:35:46 jsing Exp $	*/
d730 1
@


1.198
log
@Move disk_attach() to the end of the attach functions, at which point the
disk is now ready to handle I/O.

ok krw@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.197 2010/06/24 10:05:18 dlg Exp $	*/
d290 11
@


1.197
log
@we cant rely on being able to sleep when dumping, so dont lose the
SCSI_NOSLEEP flag on the xs when setting extra flags by oring them in
rather than assigning them.

from matthew dempsky
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.196 2010/06/16 02:58:02 krw Exp $	*/
d181 1
a181 1
	 * Initialize and attach the disk structure.
a185 1
	disk_attach(&sc->sc_dk);
d272 3
@


1.196
log
@Always check both the return value of scsi_do_mode_sense() and the
NULL'ness of the pointer to the actual page data. Fixes a NULL deref
when trying to set caching on my ASUS eeePC 1000HE's SD slot.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.195 2010/06/15 04:31:46 dlg Exp $	*/
d1335 1
a1335 1
		xs->flags = SCSI_POLL | SCSI_DATA_OUT;
@


1.195
log
@enable the write cache on disks during attach.

requested by deraadt@@
ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.193 2010/06/11 12:02:44 krw Exp $	*/
d1044 1
a1044 1
	if (!DISK_PGCODE(mode, PAGE_CACHING_MODE)) {
d1391 3
a1393 3
	struct page_rigid_geometry *rigid;
	struct page_flex_geometry *flex;
	struct page_reduced_geometry *reduced;
d1396 1
d1419 5
a1423 4
		scsi_do_mode_sense(sc->sc_link, PAGE_REDUCED_GEOMETRY, buf,
		    (void **)&reduced, NULL, NULL, &blksize, sizeof(*reduced),
		    flags | SCSI_SILENT, NULL);
		if (DISK_PGCODE(reduced, PAGE_REDUCED_GEOMETRY)) {
a1438 1
		rigid = NULL;
d1441 5
a1445 4
			scsi_do_mode_sense(sc->sc_link, PAGE_RIGID_GEOMETRY,
			    buf, (void **)&rigid, NULL, NULL, &blksize,
			    sizeof(*rigid) - 4, flags | SCSI_SILENT, NULL);
		if (DISK_PGCODE(rigid, PAGE_RIGID_GEOMETRY)) {
d1452 6
a1457 4
			scsi_do_mode_sense(sc->sc_link, PAGE_FLEX_GEOMETRY,
			    buf, (void **)&flex, NULL, NULL, &blksize,
			    sizeof(*flex) - 4, flags | SCSI_SILENT, NULL);
			if (DISK_PGCODE(flex, PAGE_FLEX_GEOMETRY)) {
@


1.194
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d168 1
d255 6
d973 6
d980 1
a980 5
	case DIOCSCACHE:
		error = scsi_do_ioctl(sc->sc_link, cmd, addr, flag);
		if (error == ENOTTY)
			error = sd_ioctl_cache(sc, cmd,
			    (struct dk_cache *)addr);
d1028 6
d1040 1
a1040 1
	    sizeof(*mode) - 4, SCSI_SILENT, &big);
d1074 1
a1074 1
			    &buf->hdr_big, SCSI_SILENT, 20000);
d1077 1
a1077 1
			    &buf->hdr, SCSI_SILENT, 20000);
@


1.193
log
@Restore an unusual XS_SENSE semantic that inadvertantly got lost
in the great re-write. If the scsi device *_interpret_sense()
function returns 0 that means there was no error.

Fixes restore(8) problems seen on certain tape drives.

Found and fix tested by Percey Piper. Suggestions from Matthew
Dempsky. Thanks!

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.192 2010/06/02 13:32:13 dlg Exp $	*/
d960 1
a960 1
		error = scsi_do_ioctl(sc->sc_link, dev, cmd, addr, flag, p);
d968 1
a968 1
		error = scsi_do_ioctl(sc->sc_link, dev, cmd, addr, flag, p);
d979 1
a979 1
		error = scsi_do_ioctl(sc->sc_link, dev, cmd, addr, flag, p);
@


1.192
log
@bring back the SDF_WAITING waiting flag while adapters still implement
NO_CCB.

if sd_buf_done is told that the adapter has no more ccbs via NO_CCB, this
sets a flag so sdstart doesnt try and queue more io straight away.

this fixes the lockups on ciss that halex and okan were experiencing after
the iopools code went in. it will fix any other hba that returns NO_CCB
too.

tested by me@@, okan@@, and halex@@
ok krw@@ okan@@ halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.191 2010/05/26 16:38:20 thib Exp $	*/
d732 1
a732 1
	int s;
d752 7
a758 1
		if (scsi_interpret_sense(xs) != ERESTART)
@


1.191
log
@Trying this again. Mixing anoncvs with cvs is _not_ a good idea.

Reintroduce bufqs. A few changes since it was backed out after some good
comments from dlg@@.

No need for a separate bufq.h, keep all of in buf.h; As requested by kittens
and deraadt.

Only sd(4) and wd(4) for now. The rest of the drivers will be converted soon,
also other goodies like heuristics for sd(4) for selecting the bufq type and
the death of disksort() are forthcoming.

Tested on: i386, amd64, sparc64, macppc, loongson and alpha by myself and
phessler.

OK art@@, beck@@, kettenis@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.190 2010/05/20 00:04:38 krw Exp $	*/
d721 3
a723 1
	if (BUFQ_PEEK(sc->sc_bufq) != NULL)
d746 1
@


1.190
log
@Simplify new disk cache code so simpler people can understand it.
No functional change.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.189 2010/05/19 05:50:50 dlg Exp $	*/
d58 1
a171 2
	mtx_init(&sc->sc_buf_mtx, IPL_BIO);

d184 1
d280 1
a280 1
		scsi_buf_killqueue(&sc->sc_buf_queue, &sc->sc_buf_mtx);
d294 1
a294 1
	scsi_buf_killqueue(&sc->sc_buf_queue, &sc->sc_buf_mtx);
d311 1
d565 2
a566 6
	/*
	 * Place it in the queue of disk activities for this disk
	 */
	mtx_enter(&sc->sc_buf_mtx);
	disksort(&sc->sc_buf_queue, bp);
	mtx_leave(&sc->sc_buf_mtx);
d668 1
a668 1
		scsi_buf_killqueue(&sc->sc_buf_queue, &sc->sc_buf_mtx);
d673 1
a673 1
	bp = scsi_buf_dequeue(&sc->sc_buf_queue, &sc->sc_buf_mtx);
d721 1
a721 1
	if (scsi_buf_canqueue(&sc->sc_buf_queue, &sc->sc_buf_mtx))
d742 1
a742 1
		scsi_buf_requeue(&sc->sc_buf_queue, bp, &sc->sc_buf_mtx);
@


1.189
log
@remove unused flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.188 2010/05/19 05:29:14 dlg Exp $	*/
d1009 1
a1009 1
	int set = 0;
d1028 3
d1033 2
a1034 2
		dkc->wrcache = (ISSET(mode->flags, PG_CACHE_FL_WCE) ? 1 : 0);
		dkc->rdcache = (ISSET(mode->flags, PG_CACHE_FL_RCD) ? 0 : 1);
d1038 2
a1039 6
		if ((dkc->wrcache ? 1 : 0) != 
		    (ISSET(mode->flags, PG_CACHE_FL_WCE) ? 1 : 0)) {
			if (dkc->wrcache)
				SET(mode->flags, PG_CACHE_FL_WCE);
			else
				CLR(mode->flags, PG_CACHE_FL_WCE);
d1041 4
a1044 2
			set = 1;
		}
d1046 4
a1049 12
		if ((dkc->rdcache ? 1 : 0) != 
		    (ISSET(mode->flags, PG_CACHE_FL_RCD) ? 0 : 1)) {
			if (dkc->rdcache)
				CLR(mode->flags, PG_CACHE_FL_RCD);
			else
				SET(mode->flags, PG_CACHE_FL_RCD);

			set = 1;
		}

		if (!set)
			break;
@


1.188
log
@add an ioctl that allows userland to get or set a disks read and write
caches, and implement handling of these ioctls on vanilla scsi disks.

discussed with krw@@, marco@@, miod@@, kettenis@@.
krw@@ has a diff to make the sd.c code prettier coming shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.187 2010/05/18 04:41:14 dlg Exp $	*/
a746 1
		SET(sc->flags, SDF_WAITING); /* break out of sdstart loop */
@


1.187
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.186 2010/04/30 02:17:06 dlg Exp $	*/
d95 1
d961 8
d1003 69
@


1.186
log
@unbreak dumps on scsi disks.

discovered by oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.185 2010/04/23 15:25:21 jsing Exp $	*/
d68 1
@


1.185
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.183 2010/04/06 00:59:50 dlg Exp $	*/
d1189 1
d1243 1
a1243 1
		xs->flags = SCSI_POLL | SCSI_NOSLEEP | SCSI_DATA_OUT;
d1249 3
a1251 2
		scsi_xs_exec(xs);
		if (xs->error != XS_NOERROR)
a1252 1
		scsi_xs_put(xs);
@


1.184
log
@i snuck fine grained locking into the midlayer as part of all the
other stuff ive been doing in here. everything that needs protection
inside the midlayer and the scsi device drivers (sd, cd, etc) uses
mutexes now.

this pushes splbio out of the midlayer. splbio is only taken before
biodone is called now.

ok beck@@ marco@@ krw@@ deraadt@@. theyre all terrified, but they all
say if we're going to do then now is the right stage of the dev
cycle.
@
text
@a1046 2
	lp->d_rpm = sc->params.rot_rate;
	lp->d_interleave = 1;
@


1.183
log
@cut sd over to using the new shiny scsi_xsh api. instead of pushing io onto
the disk as soon as it gets any from the block layer, this now registers
a callback for when a resource becomes available on the bus.

ok krw@@ beck@@ marco@@
tested by many including krw@@ beck@@ mk@@ okan@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.182 2010/01/15 05:50:31 krw Exp $	*/
d731 1
a731 2

	splassert(IPL_BIO);
d780 1
d782 1
@


1.182
log
@Abstract and merge the manual buf queue manipulating functions into
one place for easier debugging and maintenance. No intended functional
changes.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.181 2010/01/15 05:31:38 krw Exp $	*/
d85 1
a85 1
void	sdstart(void *);
d115 1
a115 1
	sdstart,		/* have a queue, served by this */
a169 1
	mtx_init(&sc->sc_start_mtx, IPL_BIO);
d205 3
a207 1
	timeout_set(&sc->sc_timeout, sdstart, sc);
d500 1
d573 1
a573 1
	sdstart(sc);
d654 1
a654 1
sdstart(void *v)
d656 2
a657 3
	struct sd_softc *sc = (struct sd_softc *)v;
	struct scsi_link *link = sc->sc_link;
	struct scsi_xfer *xs;
a662 1
	int s;
d664 7
a670 1
	if (sc->flags & SDF_DYING)
d672 1
d674 3
a676 6
	SC_DEBUG(link, SDEV_DB2, ("sdstart\n"));

	mtx_enter(&sc->sc_start_mtx);
	sc->sc_start_count++;
	if (sc->sc_start_count > 1) {
		mtx_leave(&sc->sc_start_mtx);
a678 19
	mtx_leave(&sc->sc_start_mtx);
	CLR(sc->flags, SDF_WAITING);
restart:
	while (!ISSET(sc->flags, SDF_WAITING) &&
	    (bp = scsi_buf_dequeue(&sc->sc_buf_queue, &sc->sc_buf_mtx)) != NULL) {
		/*
		 * If the device has become invalid, abort all the
		 * reads and writes until all files have been closed and
		 * re-opened
		 */
		if ((link->flags & SDEV_MEDIA_LOADED) == 0) {
			bp->b_error = EIO;
			bp->b_flags |= B_ERROR;
			bp->b_resid = bp->b_bcount;
			s = splbio();
			biodone(bp);
			splx(s);
			continue;
		}
d680 5
a684 5
		xs = scsi_xs_get(link, SCSI_NOSLEEP);
		if (xs == NULL) {
			scsi_buf_requeue(&sc->sc_buf_queue, bp, &sc->sc_buf_mtx);
			break;
		}
d686 17
a702 6
		blkno =
		    bp->b_blkno / (sc->sc_dk.dk_label->d_secsize / DEV_BSIZE);
		p = &sc->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
		blkno += DL_GETPOFFSET(p);
		nblks = howmany(bp->b_bcount, sc->sc_dk.dk_label->d_secsize);
		read = bp->b_flags & B_READ;
d704 4
a707 17
		/*
		 *  Fill out the scsi command.  If the transfer will
		 *  fit in a "small" cdb, use it.
		 */
		if (!(link->flags & SDEV_ATAPI) &&
		    !(link->quirks & SDEV_ONLYBIG) &&
		    ((blkno & 0x1fffff) == blkno) &&
		    ((nblks & 0xff) == nblks))
			sd_cmd_rw6(xs, read, blkno, nblks);
		else if (((blkno & 0xffffffff) == blkno) &&
		    ((nblks & 0xffff) == nblks))
			sd_cmd_rw10(xs, read, blkno, nblks);
		else if (((blkno & 0xffffffff) == blkno) &&
		    ((nblks & 0xffffffff) == nblks))
			sd_cmd_rw12(xs, read, blkno, nblks);
		else
			sd_cmd_rw16(xs, read, blkno, nblks);
d709 2
a710 4
		xs->flags |= (read ? SCSI_DATA_IN : SCSI_DATA_OUT);
		xs->timeout = 60000;
		xs->data = bp->b_data;
		xs->datalen = bp->b_bcount;
d712 2
a713 2
		xs->done = sd_buf_done;
		xs->cookie = bp;
d715 3
a717 2
		/* Instrumentation. */
		disk_busy(&sc->sc_dk);
d719 1
a719 3
		/* Mark disk as dirty. */
		if ((bp->b_flags & B_READ) == 0)
			sc->flags |= SDF_DIRTY;
d721 3
a723 10
		scsi_xs_exec(xs);
	}
	mtx_enter(&sc->sc_start_mtx);
	sc->sc_start_count--;
	if (sc->sc_start_count != 0) {
		sc->sc_start_count = 1;
		mtx_leave(&sc->sc_start_mtx);
		goto restart;
	}
	mtx_leave(&sc->sc_start_mtx);
a782 1
	sdstart(sc); /* restart io */
d1079 4
d1084 1
@


1.182.2.1
log
@MFC, original commit from krw@@:
----------------------------
Restore an unusual XS_SENSE semantic that inadvertantly got lost
in the great re-write. If the scsi device *_interpret_sense()
function returns 0 that means there was no error.

Fixes restore(8) problems seen on certain tape drives.

Found and fix tested by Percey Piper. Suggestions from Matthew
Dempsky. Thanks!

ok dlg@@
----------------------------

ok krw@@ and dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.182 2010/01/15 05:50:31 krw Exp $	*/
a757 1
	int error;
d779 1
a779 7
		error = scsi_interpret_sense(xs);
		if (error == 0) {
			bp->b_error = 0;
			bp->b_resid = xs->resid;
			break;
		}
		if (error != ERESTART)
@


1.181
log
@Restore XS_BUSY delay behaviour for buf i/o. Same as for sync path.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.180 2010/01/12 08:33:19 dlg Exp $	*/
a89 1
void	sd_kill_buffers(struct sd_softc *);
a94 3
struct buf *sd_buf_dequeue(struct sd_softc *);
void	sd_buf_requeue(struct sd_softc *, struct buf *);

d277 1
a277 1
		sd_kill_buffers(sc);
d291 1
a291 1
	sd_kill_buffers(sc);
a589 27
struct buf *
sd_buf_dequeue(struct sd_softc *sc)
{
	struct buf *bp;

	mtx_enter(&sc->sc_buf_mtx);
	bp = sc->sc_buf_queue.b_actf;
	if (bp != NULL)
		sc->sc_buf_queue.b_actf = bp->b_actf;
	if (sc->sc_buf_queue.b_actf == NULL)
		sc->sc_buf_queue.b_actb = &sc->sc_buf_queue.b_actf;
	mtx_leave(&sc->sc_buf_mtx);

	return (bp);
}

void
sd_buf_requeue(struct sd_softc *sc, struct buf *bp)
{
	mtx_enter(&sc->sc_buf_mtx);
	bp->b_actf = sc->sc_buf_queue.b_actf;
	sc->sc_buf_queue.b_actf = bp;
	if (bp->b_actf == NULL)
		sc->sc_buf_queue.b_actb = &bp->b_actf;
	mtx_leave(&sc->sc_buf_mtx);
}

d679 1
a679 1
	    (bp = sd_buf_dequeue(sc)) != NULL) {
d697 1
a697 1
			sd_buf_requeue(sc, bp);
d771 1
a771 1
		sd_buf_requeue(sc, bp);
a1494 18
}

/*
 * Remove unprocessed buffers from queue.
 */
void
sd_kill_buffers(struct sd_softc *sc)
{
	struct buf *bp;
	int s;

	while ((bp = sd_buf_dequeue(sc)) != NULL) {
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		s = splbio();
		biodone(bp);
		splx(s);
	}
@


1.180
log
@dont let the antisemaphore clear the WAITING flag so NO_CCB doesnt cause
us to loop forever.

follow sdstart through to to an adapters scsi_cmd handler and assume that
handler returns NO_CCB to enjoy the bug in full.

ok kettenis@@ krw@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.179 2010/01/11 11:16:38 krw Exp $	*/
d812 1
a813 1
		/* FALLTHROUGH */
d815 6
d822 1
d827 1
a828 1
		/* FALLTHROUGH */
@


1.179
log
@dlg@@ lost the SCSI_IGNORE_ILLEGAL_REQUEST flag on all SYNCHRONIZE_CACHE
commands.

Noticed & fix tested by halex@@.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.178 2010/01/11 00:44:40 krw Exp $	*/
d707 1
a708 1
	CLR(sc->flags, SDF_WAITING);
@


1.178
log
@Be as careful with sd/cd buf queue manipulations as was found necessary for
st's queue manipulations. i.e. ensure b_actb is correctly updated as the
queue becomes empty or has an i/o requeued on it.

Tested on claudio@@'s backup crashing box.

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.177 2010/01/11 00:14:52 beck Exp $	*/
d1511 1
@


1.177
log
@Add mutex around work consuming loop in sdstart - this ensures that only
one thread will be grabbing xs's at a time and dequeuing work, but avoids
a race between notification there is work to do and exiting the loop
releasing the xs's.

Fixes problem noticed by claudio where usb disks would hang with the new
minty dlg midlayer.

ok krw@@, dlg@@, tested by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.176 2010/01/09 21:12:06 dlg Exp $	*/
d603 2
d616 2
@


1.176
log
@dont try to prevent multiple concurrent runs of a devices start routine
by setting flags around the loop. there is a race which can prevent
necessary work being completed by any of the currently running instances
of xxstart.

the caveat with the removal of this code is because multiple xxstarts can
be running at the same time they can cause io reordering, but that is less
of a problem than no io.

found by and fix tested by claudio@@
debugged with krw@@ claudio@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.175 2010/01/05 01:21:34 dlg Exp $	*/
d696 8
d770 8
@


1.175
log
@only call disk_unbusy when we're finished with the io (or we're requeuing
it when we hit NO_CCB). retried io would call unbusy twice before this
change.

noticed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.173 2009/12/07 00:09:27 krw Exp $	*/
a695 9
	mtx_enter(&sc->sc_start_mtx);
	if (ISSET(sc->flags, SDF_STARTING)) {
		mtx_leave(&sc->sc_start_mtx);
		return;
	}

	SET(sc->flags, SDF_STARTING);
	mtx_leave(&sc->sc_start_mtx);

a761 4

	mtx_enter(&sc->sc_start_mtx);
	CLR(sc->flags, SDF_STARTING);
	mtx_leave(&sc->sc_start_mtx);
@


1.174
log
@introduce scsi_xs_sync. this will synchronously execute a scsi_xfer
and do the appropriate sleeps, retries, error processing, and finally
returns an errno style value to the caller.

this cuts scsi_scsi_cmd, the ioctl code, sd_flush, and scsi_inquiry over
to scsi_xs_sync.

ok krw@@
@
text
@a784 3
	disk_unbusy(&sc->sc_dk, bp->b_bcount - xs->resid,
	    bp->b_flags & B_READ);

d793 2
d821 3
@


1.173
log
@Re-enable SCSIDEBUG display of commands and data. Original diff
from dlg@@, tweaking by me to make it compile.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.172 2009/12/06 17:24:28 krw Exp $	*/
a1473 2
void
sd_flush_done(struct scsi_xfer *xs);
d1503 1
a1503 11
	xs->done = sd_flush_done;

	do {
		scsi_xs_exec(xs);
		if (!ISSET(xs->flags, SCSI_POLL)) {
			while (!ISSET(xs->flags, ITSDONE))
				tsleep(xs, PRIBIO, "sdflush", 0);
		}
	} while (xs->status == XS_NO_CCB);

	if (xs->error == XS_NOERROR)
a1508 7
}

void
sd_flush_done(struct scsi_xfer *xs)
{
	if (!ISSET(xs->flags, SCSI_POLL))
		wakeup_one(xs);
@


1.172
log
@Nuke SCSI_URGENT after removing its only use, in ncr53c9x.c. That use
was to try to play dangerous games with tagged queuing.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.171 2009/12/06 07:26:35 dlg Exp $	*/
d694 1
a694 1
	SC_DEBUG(sc_link, SDEV_DB2, ("sdstart\n"));
d1495 1
a1495 1
		SC_DEBUG(sc_link, SDEV_DB1, ("cache sync failed to get xs\n"));
d1515 2
a1516 2
	if (xs->error != XS_NOERROR)
		SC_DEBUG(sc_link, SDEV_DB1, ("cache sync failed\n"));
d1518 1
a1518 1
		sc->flags &= ~SDF_DIRTY;
@


1.171
log
@consistently refer to the softc pointer as sc, not sd.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.170 2009/12/06 03:35:27 dlg Exp $	*/
d1156 1
a1156 1
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_URGENT | SCSI_NOSLEEP);
@


1.170
log
@biodone must be called at splbio.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.169 2009/12/03 14:31:03 dlg Exp $	*/
d163 1
a163 3
	int error, result;
	struct sd_softc *sd = (struct sd_softc *)self;
	struct disk_parms *dp = &sd->params;
d165 1
d169 1
d173 2
a174 2
	mtx_init(&sd->sc_buf_mtx, IPL_BIO);
	mtx_init(&sd->sc_start_mtx, IPL_BIO);
d179 1
a179 1
	sd->sc_link = sc_link;
d181 1
a181 1
	sc_link->device_softc = sd;
d186 3
a188 3
	sd->sc_dk.dk_driver = &sddkdriver;
	sd->sc_dk.dk_name = sd->sc_dev.dv_xname;
	disk_attach(&sd->sc_dk);
d201 1
a201 1
		sd->flags |= SDF_ANCIENT;
d210 1
a210 1
	timeout_set(&sd->sc_timeout, sdstart, sd);
d213 1
a213 1
	if ((sd->sc_link->flags & SDEV_UMASS) == 0)
d224 1
a224 1
	error = scsi_test_unit_ready(sd->sc_link, TEST_READY_RETRIES * 3,
d230 1
a230 1
		result = sd_get_parms(sd, &sd->params, sd_autoconf);
d235 1
a235 1
	printf("%s: ", sd->sc_dev.dv_xname);
d263 2
a264 2
	if ((sd->sc_sdhook =
	    shutdownhook_establish(sd_shutdown, sd)) == NULL)
d266 1
a266 1
		    sd->sc_dev.dv_xname);
d272 1
a272 1
	struct sd_softc *sd = (struct sd_softc *)self;
d280 2
a281 2
		sd->flags |= SDF_DYING;
		sd_kill_buffers(sd);
d292 1
a292 1
	struct sd_softc *sd = (struct sd_softc *)self;
d295 1
a295 1
	sd_kill_buffers(sd);
d308 2
a309 2
	if (sd->sc_sdhook != NULL)
		shutdownhook_disestablish(sd->sc_sdhook);
d312 1
a312 1
	disk_detach(&sd->sc_dk);
d324 1
a324 1
	struct sd_softc *sd;
d332 2
a333 2
	sd = sdlookup(unit);
	if (sd == NULL)
d335 2
a336 2
	if (sd->flags & SDF_DYING) {
		device_unref(&sd->sc_dev);
d340 1
a340 1
	sc_link = sd->sc_link;
d345 2
a346 2
	if ((error = sdlock(sd)) != 0) {
		device_unref(&sd->sc_dev);
d350 1
a350 1
	if (sd->sc_dk.dk_openmask != 0) {
d363 1
a363 1
		if ((sd->sc_link->flags & SDEV_UMASS) == 0)
d402 1
a402 1
		if (sd_get_parms(sd, &sd->params, (rawopen ? SCSI_SILENT : 0))
d411 1
a411 1
		if (sdgetdisklabel(dev, sd, sd->sc_dk.dk_label, 0) == EIO) {
d420 2
a421 2
	    (part >= sd->sc_dk.dk_label->d_npartitions ||
	    sd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
d429 1
a429 1
		sd->sc_dk.dk_copenmask |= (1 << part);
d432 1
a432 1
		sd->sc_dk.dk_bopenmask |= (1 << part);
d435 1
a435 1
	sd->sc_dk.dk_openmask = sd->sc_dk.dk_copenmask | sd->sc_dk.dk_bopenmask;
d440 2
a441 2
	if (sd->sc_dk.dk_openmask == 0) {
		if ((sd->sc_link->flags & SDEV_REMOVABLE) != 0)
d448 2
a449 2
	sdunlock(sd);
	device_unref(&sd->sc_dev);
d460 1
a460 1
	struct sd_softc *sd;
d464 2
a465 2
	sd = sdlookup(DISKUNIT(dev));
	if (sd == NULL)
d467 2
a468 2
	if (sd->flags & SDF_DYING) {
		device_unref(&sd->sc_dev);
d472 2
a473 2
	if ((error = sdlock(sd)) != 0) {
		device_unref(&sd->sc_dev);
d479 1
a479 1
		sd->sc_dk.dk_copenmask &= ~(1 << part);
d482 1
a482 1
		sd->sc_dk.dk_bopenmask &= ~(1 << part);
d485 1
a485 1
	sd->sc_dk.dk_openmask = sd->sc_dk.dk_copenmask | sd->sc_dk.dk_bopenmask;
d487 3
a489 3
	if (sd->sc_dk.dk_openmask == 0) {
		if ((sd->flags & SDF_DIRTY) != 0)
			sd_flush(sd, 0);
d491 2
a492 2
		if ((sd->sc_link->flags & SDEV_REMOVABLE) != 0)
			scsi_prevent(sd->sc_link, PR_ALLOW,
d495 1
a495 1
		sd->sc_link->flags &= ~(SDEV_OPEN | SDEV_MEDIA_LOADED);
d497 3
a499 3
		if (sd->sc_link->flags & SDEV_EJECTING) {
			scsi_start(sd->sc_link, SSS_STOP|SSS_LOEJ, 0);
			sd->sc_link->flags &= ~SDEV_EJECTING;
d502 1
a502 1
		timeout_del(&sd->sc_timeout);
d505 2
a506 2
	sdunlock(sd);
	device_unref(&sd->sc_dev);
d518 1
a518 1
	struct sd_softc *sd;
d521 2
a522 2
	sd = sdlookup(DISKUNIT(bp->b_dev));
	if (sd == NULL) {
d526 1
a526 1
	if (sd->flags & SDF_DYING) {
d531 1
a531 1
	SC_DEBUG(sd->sc_link, SDEV_DB2, ("sdstrategy: %ld bytes @@ blk %d\n",
d536 2
a537 2
	if ((sd->sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
		if (sd->sc_link->flags & SDEV_OPEN)
d552 1
a552 1
	if ((bp->b_bcount % sd->sc_dk.dk_label->d_secsize) != 0) {
d560 2
a561 2
	if (bounds_check_with_label(bp, sd->sc_dk.dk_label,
	    (sd->flags & (SDF_WLABEL|SDF_LABELLING)) != 0) <= 0)
d567 3
a569 3
	mtx_enter(&sd->sc_buf_mtx);
	disksort(&sd->sc_buf_queue, bp);
	mtx_leave(&sd->sc_buf_mtx);
d575 1
a575 1
	sdstart(sd);
d577 1
a577 1
	device_unref(&sd->sc_dev);
d590 2
a591 2
	if (sd != NULL)
		device_unref(&sd->sc_dev);
d831 1
a831 1
	struct sd_softc *sd;
d834 2
a835 2
	sd = sdlookup(DISKUNIT(bp->b_dev));
	if (sd == NULL)
d849 2
a850 2
	if (sd->flags & SDF_ANCIENT) {
		max = sd->sc_dk.dk_label->d_secsize * 0xff;
d856 1
a856 1
	(*sd->sc_link->adapter->scsi_minphys)(bp, sd->sc_link);
d858 1
a858 1
	device_unref(&sd->sc_dev);
d880 1
a880 1
	struct sd_softc *sd;
d885 2
a886 2
	sd = sdlookup(DISKUNIT(dev));
	if (sd == NULL)
d888 2
a889 2
	if (sd->flags & SDF_DYING) {
		device_unref(&sd->sc_dev);
d893 1
a893 1
	SC_DEBUG(sd->sc_link, SDEV_DB2, ("sdioctl 0x%lx\n", cmd));
d898 1
a898 1
	if ((sd->sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
d910 1
a910 1
			if ((sd->sc_link->flags & SDEV_OPEN) == 0) {
d923 2
a924 2
		sdgetdisklabel(dev, sd, lp, 0);
		bcopy(lp, sd->sc_dk.dk_label, sizeof(*lp));
d928 1
a928 1
		sdgetdisklabel(dev, sd, (struct disklabel *)addr, 1);
d932 1
a932 1
		*(struct disklabel *)addr = *(sd->sc_dk.dk_label);
d936 1
a936 1
		((struct partinfo *)addr)->disklab = sd->sc_dk.dk_label;
d938 1
a938 1
		    &sd->sc_dk.dk_label->d_partitions[DISKPART(dev)];
d948 1
a948 1
		if ((error = sdlock(sd)) != 0)
d950 1
a950 1
		sd->flags |= SDF_LABELLING;
d952 1
a952 1
		error = setdisklabel(sd->sc_dk.dk_label,
d957 1
a957 1
				    sdstrategy, sd->sc_dk.dk_label);
d960 2
a961 2
		sd->flags &= ~SDF_LABELLING;
		sdunlock(sd);
d970 1
a970 1
			sd->flags |= SDF_WLABEL;
d972 1
a972 1
			sd->flags &= ~SDF_WLABEL;
d976 1
a976 1
		error = scsi_prevent(sd->sc_link,
d987 1
a987 1
		if ((sd->sc_link->flags & SDEV_REMOVABLE) == 0) {
d991 1
a991 1
		sd->sc_link->flags |= SDEV_EJECTING;
d995 1
a995 1
		error = scsi_do_ioctl(sd->sc_link, dev, cmd, addr, flag, p);
d997 1
a997 1
			error = sd_ioctl_inquiry(sd,
d1006 1
a1006 1
		error = scsi_do_ioctl(sd->sc_link, dev, cmd, addr, flag, p);
d1010 1
a1010 1
	device_unref(&sd->sc_dev);
d1015 1
a1015 1
sd_ioctl_inquiry(struct sd_softc *sd, struct dk_inquiry *di)
d1020 6
a1025 6
	scsi_strvis(di->vendor, sd->sc_link->inqdata.vendor,
	    sizeof(sd->sc_link->inqdata.vendor));
	scsi_strvis(di->product, sd->sc_link->inqdata.product,
	    sizeof(sd->sc_link->inqdata.product));
	scsi_strvis(di->revision, sd->sc_link->inqdata.revision,
	    sizeof(sd->sc_link->inqdata.revision));
d1028 1
a1028 1
	if (scsi_inquire_vpd(sd->sc_link, &vpd, sizeof(vpd),
d1041 1
a1041 1
sdgetdisklabel(dev_t dev, struct sd_softc *sd, struct disklabel *lp,
d1050 4
a1053 4
	lp->d_secsize = sd->params.blksize;
	lp->d_ntracks = sd->params.heads;
	lp->d_nsectors = sd->params.sectors;
	lp->d_ncylinders = sd->params.cyls;
d1061 1
a1061 1
	if ((sd->sc_link->inqdata.device & SID_TYPE) == T_OPTICAL)
d1073 2
a1074 2
	viscpy(vendor, sd->sc_link->inqdata.vendor, 8);
	viscpy(product, sd->sc_link->inqdata.product, 16);
d1088 2
a1089 2
	DL_SETDSIZE(lp, sd->params.disksize);
	lp->d_rpm = sd->params.rot_rate;
d1112 1
a1112 1
	struct sd_softc *sd = (struct sd_softc *)arg;
d1119 2
a1120 2
	if ((sd->flags & SDF_DIRTY) != 0)
		sd_flush(sd, SCSI_AUTOCONF);
d1122 1
a1122 1
	timeout_del(&sd->sc_timeout);
d1133 1
a1133 1
	struct sd_softc *sd = sc_link->device_softc;
d1155 1
a1155 1
		retval = scsi_start(sd->sc_link, SSS_START,
d1175 1
a1175 1
	struct sd_softc *sd;
d1179 2
a1180 2
	sd = sdlookup(DISKUNIT(dev));
	if (sd == NULL)
d1182 1
a1182 1
	if (sd->flags & SDF_DYING) {
d1188 1
a1188 1
	omask = sd->sc_dk.dk_openmask & (1 << part);
d1194 1
a1194 1
	if ((sd->sc_link->flags & SDEV_MEDIA_LOADED) == 0)
d1196 1
a1196 1
	else if (sd->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)
d1199 2
a1200 2
		size = DL_GETPSIZE(&sd->sc_dk.dk_label->d_partitions[part]) *
			(sd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
d1205 1
a1205 1
	device_unref(&sd->sc_dev);
d1334 1
a1334 1
sd_get_parms(struct sd_softc *sd, struct disk_parms *dp, int flags)
d1343 1
a1343 1
	dp->disksize = scsi_size(sd->sc_link, flags, &ssblksize);
d1350 1
a1350 1
	if ((sd->sc_link->flags & SDEV_UMASS) && (dp->disksize > 0))
d1357 1
a1357 1
	switch (sd->sc_link->inqdata.device & SID_TYPE) {
d1364 1
a1364 1
		scsi_do_mode_sense(sd->sc_link, PAGE_REDUCED_GEOMETRY, buf,
d1384 3
a1386 3
		if (((sd->sc_link->flags & SDEV_ATAPI) == 0) ||
		    ((sd->sc_link->flags & SDEV_REMOVABLE) == 0))
			scsi_do_mode_sense(sd->sc_link, PAGE_RIGID_GEOMETRY,
d1396 1
a1396 1
			scsi_do_mode_sense(sd->sc_link, PAGE_FLEX_GEOMETRY,
d1439 1
a1439 1
		SC_DEBUG(sd->sc_link, SDEV_DB1,
d1534 1
a1534 1
sd_kill_buffers(struct sd_softc *sd)
d1539 1
a1539 1
	while ((bp = sd_buf_dequeue(sd)) != NULL) {
@


1.169
log
@prevent a completion interrupt pulling io of the buf queue and shoving it
down to the disk while a process is doing the same thing. this will avoid
some relatively minor io reordering from occurring.

discovered by krw@@ during his long dark trek through the code. requested
by marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.168 2009/12/03 06:09:30 dlg Exp $	*/
d689 1
d717 1
d719 1
d1537 1
d1542 1
d1544 1
@


1.168
log
@set the length of the cdb when synchronising cache.

noticed by deraadt@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.167 2009/12/01 03:43:17 krw Exp $	*/
d174 1
d695 9
d723 1
a723 1
			return;
d768 4
@


1.167
log
@Mark disk as dirty when starting a write to it. Restores issuing of
SYNCHRONIZE_CACHE commands on device close.

ok dlg@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.166 2009/12/01 01:50:35 dlg Exp $	*/
d1485 1
@


1.166
log
@properly handle all xs states that can be returned by an adapter in sd.

requested by krw@@ after spending a week munging through my code.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.165 2009/12/01 01:40:02 dlg Exp $	*/
d751 5
@


1.165
log
@put the midlayer changes back in.

the two issues affecting it last time are gone. the first, mishandling of
TRY_AGAIN_LATER is not relevant now that krw got rid of TRY_AGAIN_LATER.
the second, the misbehaving IBM disk was found to be a problem with siop
using ordered tags on most ops combined with the speed of the new code.

putting this in so we can move forward.

ok krw@@ "commit please" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.164 2009/11/12 06:20:27 dlg Exp $	*/
d773 1
a773 1
		/* The hardware is busy, requeue the buf and try it later. */
d780 14
@


1.164
log
@revert midlayer back to it was before i put my big rewrite in. this is
causing a weird problems on an alpha and also appears responsible for
isp(4) weirdness i havent had a chance to examine yet.

sigh, this makes me sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.161 2009/11/05 03:33:52 marco Exp $	*/
a85 2
void	sdrestart(void *);
void	sddone(struct scsi_xfer *);
a86 1
int	sd_reassign_blocks(struct sd_softc *, u_long);
d96 10
d121 1
a121 1
	sddone,			/* deal with stats at interrupt time */
d173 2
d209 1
a209 1
	timeout_set(&sd->sc_timeout, sdrestart, sd);
a562 2
	s = splbio();

d566 3
a568 1
	disksort(&sd->buf_queue, bp);
a575 2
	splx(s);

d593 71
a675 3
 *
 * must be called at the correct (highish) spl level
 * sdstart() is called at splbio from sdstrategy, sdrestart and scsi_done
d680 4
a683 9
	struct sd_softc *sd = (struct sd_softc *)v;
	struct scsi_link *sc_link = sd->sc_link;
	struct buf *bp = 0;
	struct buf *dp;
	struct scsi_rw_big cmd_big;
	struct scsi_rw_12 cmd_12;
	struct scsi_rw_16 cmd_16;
	struct scsi_rw cmd_small;
	struct scsi_generic *cmdp;
d685 2
a686 1
	int nblks, cmdlen, error;
d689 1
a689 1
	if (sd->flags & SDF_DYING)
d694 3
a696 25
	splassert(IPL_BIO);

	/*
	 * Check if the device has room for another command
	 */
	while (sc_link->openings > 0) {
		/*
		 * there is excess capacity, but a special waits
		 * It'll need the adapter as soon as we clear out of the
		 * way and let it run (user level wait).
		 */
		if (sc_link->flags & SDEV_WAITING) {
			sc_link->flags &= ~SDEV_WAITING;
			wakeup((caddr_t)sc_link);
			return;
		}

		/*
		 * See if there is a buf with work for us to do..
		 */
		dp = &sd->buf_queue;
		if ((bp = dp->b_actf) == NULL)	/* yes, an assign */
			return;
		dp->b_actf = bp->b_actf;

d702 1
a702 1
		if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
d710 6
a715 6
		/*
		 * We have a buf, now we should make a command
		 *
		 * First, translate the block to absolute and put it in terms
		 * of the logical blocksize of the device.
		 */
d717 2
a718 2
		    bp->b_blkno / (sd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
		p = &sd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
d720 2
a721 1
		nblks = howmany(bp->b_bcount, sd->sc_dk.dk_label->d_secsize);
d727 2
a728 2
		if (!(sc_link->flags & SDEV_ATAPI) &&
		    !(sc_link->quirks & SDEV_ONLYBIG) &&
d730 18
a747 47
		    ((nblks & 0xff) == nblks)) {
			/*
			 * We can fit in a 6 byte cdb.
			 */
			bzero(&cmd_small, sizeof(cmd_small));
			cmd_small.opcode = (bp->b_flags & B_READ) ?
			    READ_COMMAND : WRITE_COMMAND;
			_lto3b(blkno, cmd_small.addr);
			cmd_small.length = nblks;
			cmdlen = sizeof(cmd_small);
			cmdp = (struct scsi_generic *)&cmd_small;
		} else if (((blkno & 0xffffffff) == blkno) &&
		    ((nblks & 0xffff) == nblks)) {
			/*
			 * We can fit in a 10 byte cdb.
			 */
			bzero(&cmd_big, sizeof(cmd_big));
			cmd_big.opcode = (bp->b_flags & B_READ) ?
			    READ_BIG : WRITE_BIG;
			_lto4b(blkno, cmd_big.addr);
			_lto2b(nblks, cmd_big.length);
			cmdlen = sizeof(cmd_big);
			cmdp = (struct scsi_generic *)&cmd_big;
		} else if (((blkno & 0xffffffff) == blkno) &&
		    ((nblks & 0xffffffff) == nblks)) {
			/*
			 * We can fit in a 12 byte cdb.
			 */
			bzero(&cmd_12, sizeof(cmd_12));
			cmd_12.opcode = (bp->b_flags & B_READ) ?
			    READ_12 : WRITE_12;
			_lto4b(blkno, cmd_12.addr);
			_lto4b(nblks, cmd_12.length);
			cmdlen = sizeof(cmd_12);
			cmdp = (struct scsi_generic *)&cmd_12;
		} else {
			/*
			 * Need a 16 byte cdb. There's nothing bigger.
			 */
			bzero(&cmd_16, sizeof(cmd_16));
			cmd_16.opcode = (bp->b_flags & B_READ) ?
			    READ_16 : WRITE_16;
			_lto8b(blkno, cmd_16.addr);
			_lto4b(nblks, cmd_16.length);
			cmdlen = sizeof(cmd_16);
			cmdp = (struct scsi_generic *)&cmd_16;
		}
d750 2
a751 34
		disk_busy(&sd->sc_dk);

		/*
		 * Call the routine that chats with the adapter.
		 * Note: we cannot sleep as we may be an interrupt
		 */
		error = scsi_scsi_cmd(sc_link, cmdp, cmdlen,
		    (u_char *)bp->b_data, bp->b_bcount,
		    SCSI_RETRIES, 60000, bp, SCSI_NOSLEEP |
		    ((bp->b_flags & B_READ) ? SCSI_DATA_IN : SCSI_DATA_OUT));
		switch (error) {
		case 0:
			/*
			 * Mark the disk dirty so that the cache will be
			 * flushed on close.
			 */
			if ((bp->b_flags & B_READ) == 0)
				sd->flags |= SDF_DIRTY;
			timeout_del(&sd->sc_timeout);
			break;
		case EAGAIN:
			/*
			 * The device can't start another i/o. Try again later.
			 */
			dp->b_actf = bp;
			disk_unbusy(&sd->sc_dk, 0, 0);
			timeout_add(&sd->sc_timeout, 1);
			return;
		default:
			disk_unbusy(&sd->sc_dk, 0, 0);
			printf("%s: not queued, error %d\n",
			    sd->sc_dev.dv_xname, error);
			break;
		}
d756 1
a756 1
sdrestart(void *v)
d758 13
a770 1
	int s;
d772 7
a778 4
	s = splbio();
	sdstart(v);
	splx(s);
}
d780 6
a785 4
void
sddone(struct scsi_xfer *xs)
{
	struct sd_softc *sd = xs->sc_link->device_softc;
d787 3
a789 3
	if (xs->bp != NULL)
		disk_unbusy(&sd->sc_dk, (xs->bp->b_bcount - xs->bp->b_resid),
		    (xs->bp->b_flags & B_READ));
a1089 21
 * Tell the device to map out a defective block
 */
int
sd_reassign_blocks(struct sd_softc *sd, u_long blkno)
{
	struct scsi_reassign_blocks scsi_cmd;
	struct scsi_reassign_blocks_data rbdata;

	bzero(&scsi_cmd, sizeof(scsi_cmd));
	bzero(&rbdata, sizeof(rbdata));
	scsi_cmd.opcode = REASSIGN_BLOCKS;

	_lto2b(sizeof(rbdata.defect_descriptor[0]), rbdata.length);
	_lto4b(blkno, rbdata.defect_descriptor[0].dlbaddr);

	return scsi_scsi_cmd(sd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)&rbdata, sizeof(rbdata), SCSI_RETRIES,
	    5000, NULL, SCSI_DATA_OUT);
}

/*
a1173 1
static struct scsi_xfer sx;
d1183 1
a1183 1
	struct sd_softc *sd;	/* disk unit to do the I/O */
a1190 1
	struct scsi_rw_big cmd;	/* write command */
a1191 1
	int	retval;
d1204 1
a1204 1
	if (unit >= sd_cd.cd_ndevs || (sd = sd_cd.cd_devs[unit]) == NULL)
d1214 1
a1214 1
	if ((sd->sc_link->flags & SDEV_MEDIA_LOADED) != SDEV_MEDIA_LOADED)
d1219 1
a1219 1
	lp = sd->sc_dk.dk_label;
a1235 2
	xs = &sx;

d1238 1
d1240 6
a1245 23
		/*
		 *  Fill out the scsi command
		 */
		bzero(&cmd, sizeof(cmd));
		cmd.opcode = WRITE_BIG;
		_lto4b(blkno, cmd.addr);
		_lto2b(nwrt, cmd.length);
		/*
		 * Fill out the scsi_xfer structure
		 *    Note: we cannot sleep as we may be an interrupt
		 * don't use scsi_scsi_cmd() as it may want
		 * to wait for an xs.
		 */
		bzero(xs, sizeof(sx));
		xs->flags |= SCSI_AUTOCONF | SCSI_DATA_OUT;
		xs->sc_link = sd->sc_link;
		xs->retries = SCSI_RETRIES;
		xs->timeout = 10000;	/* 10000 millisecs for a disk ! */
		xs->cmd = (struct scsi_generic *)&cmd;
		xs->cmdlen = sizeof(cmd);
		xs->resid = nwrt * sectorsize;
		xs->error = XS_NOERROR;
		xs->bp = NULL;
d1249 6
a1254 6
		/*
		 * Pass all this info to the scsi driver.
		 */
		retval = (*(sd->sc_link->adapter->scsi_cmd)) (xs);
		if (retval != COMPLETE)
			return ENXIO;
d1266 1
d1268 2
a1269 1
	return 0;
d1438 2
d1442 1
a1442 1
sd_flush(struct sd_softc *sd, int flags)
d1444 3
a1446 2
	struct scsi_link *sc_link = sd->sc_link;
	struct scsi_synchronize_cache cmd;
d1448 1
a1448 1
	if (sc_link->quirks & SDEV_NOSYNCCACHE)
d1457 22
a1478 6
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = SYNCHRONIZE_CACHE;
		
	if (scsi_scsi_cmd(sc_link, (struct scsi_generic *)&cmd, sizeof(cmd),
	    NULL, 0, SCSI_RETRIES, 100000, NULL,
	    flags | SCSI_IGNORE_ILLEGAL_REQUEST)) {
d1480 11
a1490 2
	} else
		sd->flags &= ~SDF_DIRTY;
d1499 1
a1499 6
	struct buf *dp, *bp;
	int s;

	s = splbio();
	for (dp = &sd->buf_queue; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;
d1501 1
a1505 1
	splx(s);
@


1.163
log
@fix the NO_CCB handling i broke when working on simplifying the midlayer.

marco@@ discovered my rewrite retried commands rejected by an adapter
from a timeout, which was trivially starved by normal io going to
disks. this diff allows an xs to be marked as XS_NO_CCB, which will
cause it to be returned to the device driver to be retried as part
of the normal io queue.

tested by krw@@ marco@@ johan@@
ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.160 2009/10/21 20:32:02 marco Exp $	*/
d86 2
d89 1
a98 10
struct buf *sd_buf_dequeue(struct sd_softc *);
void	sd_buf_requeue(struct sd_softc *, struct buf *);

void	sd_cmd_rw6(struct scsi_xfer *, int, daddr64_t, u_int);
void	sd_cmd_rw10(struct scsi_xfer *, int, daddr64_t, u_int);
void	sd_cmd_rw12(struct scsi_xfer *, int, daddr64_t, u_int);
void	sd_cmd_rw16(struct scsi_xfer *, int, daddr64_t, u_int);

void	sd_buf_done(struct scsi_xfer *);

d114 1
a114 1
	NULL,			/* have no done handler */
a165 2
	mtx_init(&sd->sc_buf_mtx, IPL_BIO);

d200 1
a200 1
	timeout_set(&sd->sc_timeout, sdstart, sd);
d554 2
d559 1
a559 3
	mtx_enter(&sd->sc_buf_mtx);
	disksort(&sd->sc_buf_queue, bp);
	mtx_leave(&sd->sc_buf_mtx);
d567 2
a585 71
struct buf *
sd_buf_dequeue(struct sd_softc *sc)
{
	struct buf *bp;

	mtx_enter(&sc->sc_buf_mtx);
	bp = sc->sc_buf_queue.b_actf;
	if (bp != NULL)
		sc->sc_buf_queue.b_actf = bp->b_actf;
	mtx_leave(&sc->sc_buf_mtx);

	return (bp);
}

void
sd_buf_requeue(struct sd_softc *sc, struct buf *bp)
{
	mtx_enter(&sc->sc_buf_mtx);
	bp->b_actf = sc->sc_buf_queue.b_actf;
	sc->sc_buf_queue.b_actf = bp;
	mtx_leave(&sc->sc_buf_mtx);
}

void
sd_cmd_rw6(struct scsi_xfer *xs, int read, daddr64_t blkno, u_int nblks)
{
	struct scsi_rw *cmd = (struct scsi_rw *)xs->cmd;

	cmd->opcode = read ? READ_COMMAND : WRITE_COMMAND;
	_lto3b(blkno, cmd->addr);
	cmd->length = nblks;

	xs->cmdlen = sizeof(*cmd);
}

void
sd_cmd_rw10(struct scsi_xfer *xs, int read, daddr64_t blkno, u_int nblks)
{
	struct scsi_rw_big *cmd = (struct scsi_rw_big *)xs->cmd;

	cmd->opcode = read ? READ_BIG : WRITE_BIG;
	_lto4b(blkno, cmd->addr);
	_lto2b(nblks, cmd->length);

	xs->cmdlen = sizeof(*cmd);
}

void
sd_cmd_rw12(struct scsi_xfer *xs, int read, daddr64_t blkno, u_int nblks)
{
	struct scsi_rw_12 *cmd = (struct scsi_rw_12 *)xs->cmd;

	cmd->opcode = read ? READ_12 : WRITE_12;
	_lto4b(blkno, cmd->addr);
	_lto4b(nblks, cmd->length);

	xs->cmdlen = sizeof(*cmd);
}

void
sd_cmd_rw16(struct scsi_xfer *xs, int read, daddr64_t blkno, u_int nblks)
{
	struct scsi_rw_16 *cmd = (struct scsi_rw_16 *)xs->cmd;

	cmd->opcode = read ? READ_16 : WRITE_16;
	_lto8b(blkno, cmd->addr);
	_lto4b(nblks, cmd->length);

	xs->cmdlen = sizeof(*cmd);
}

d598 3
d605 9
a613 4
	struct sd_softc *sc = (struct sd_softc *)v;
	struct scsi_link *link = sc->sc_link;
	struct scsi_xfer *xs;
	struct buf *bp;
d615 1
a615 2
	int nblks;
	int read;
d618 1
a618 1
	if (sc->flags & SDF_DYING)
d623 25
a647 3
	CLR(sc->flags, SDF_WAITING);
	while (!ISSET(sc->flags, SDF_WAITING) &&
	    (bp = sd_buf_dequeue(sc)) != NULL) {
d653 1
a653 1
		if ((link->flags & SDEV_MEDIA_LOADED) == 0) {
d661 6
a666 6
		xs = scsi_xs_get(link, SCSI_NOSLEEP);
		if (xs == NULL) {
			sd_buf_requeue(sc, bp);
			return;
		}

d668 2
a669 2
		    bp->b_blkno / (sc->sc_dk.dk_label->d_secsize / DEV_BSIZE);
		p = &sc->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
d671 1
a671 2
		nblks = howmany(bp->b_bcount, sc->sc_dk.dk_label->d_secsize);
		read = bp->b_flags & B_READ;
d677 2
a678 2
		if (!(link->flags & SDEV_ATAPI) &&
		    !(link->quirks & SDEV_ONLYBIG) &&
d680 47
a726 10
		    ((nblks & 0xff) == nblks))
			sd_cmd_rw6(xs, read, blkno, nblks);
		else if (((blkno & 0xffffffff) == blkno) &&
		    ((nblks & 0xffff) == nblks))
			sd_cmd_rw10(xs, read, blkno, nblks);
		else if (((blkno & 0xffffffff) == blkno) &&
		    ((nblks & 0xffffffff) == nblks))
			sd_cmd_rw12(xs, read, blkno, nblks);
		else
			sd_cmd_rw16(xs, read, blkno, nblks);
d728 2
a729 4
		xs->flags |= (read ? SCSI_DATA_IN : SCSI_DATA_OUT);
		xs->timeout = 60000;
		xs->data = bp->b_data;
		xs->datalen = bp->b_bcount;
d731 32
a762 6
		xs->done = sd_buf_done;
		xs->cookie = bp;

		/* Instrumentation. */
		disk_busy(&sc->sc_dk);
		scsi_xs_exec(xs);
d767 1
a767 1
sd_buf_done(struct scsi_xfer *xs)
d769 1
a769 2
	struct sd_softc *sc = xs->sc_link->device_softc;
	struct buf *bp = xs->cookie;
d771 4
a774 1
	splassert(IPL_BIO);
d776 4
a779 8
	disk_unbusy(&sc->sc_dk, bp->b_bcount - xs->resid,
	    bp->b_flags & B_READ);

	switch (xs->error) {
	case XS_NOERROR:
		bp->b_error = 0;
		bp->b_resid = xs->resid;
		break;
d781 3
a783 18
	case XS_NO_CCB:
		/* The hardware is busy, requeue the buf and try it later. */
		sd_buf_requeue(sc, bp);
		scsi_xs_put(xs);
		SET(sc->flags, SDF_WAITING); /* break out of sdstart loop */
		timeout_add(&sc->sc_timeout, 1);
		return;

	default:
		bp->b_error = EIO;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		break;
	}

	biodone(bp);
	scsi_xs_put(xs);
	sdstart(sc); /* restart io */
d1084 21
d1189 1
d1199 1
a1199 1
	struct sd_softc *sc;	/* disk unit to do the I/O */
d1207 1
d1209 1
d1222 1
a1222 1
	if (unit >= sd_cd.cd_ndevs || (sc = sd_cd.cd_devs[unit]) == NULL)
d1232 1
a1232 1
	if ((sc->sc_link->flags & SDEV_MEDIA_LOADED) != SDEV_MEDIA_LOADED)
d1237 1
a1237 1
	lp = sc->sc_dk.dk_label;
d1254 2
a1257 1

d1259 23
a1281 6
		xs = scsi_xs_get(sc->sc_link, SCSI_NOSLEEP);
		if (xs == NULL)
			return (ENOMEM);

		xs->timeout = 10000;
		xs->flags = SCSI_POLL | SCSI_NOSLEEP | SCSI_DATA_OUT;
d1285 6
a1290 6
		sd_cmd_rw10(xs, 0, blkno, nwrt); /* XXX */

		scsi_xs_exec(xs);
		if (xs->error != XS_NOERROR)
			return (ENXIO);
		scsi_xs_put(xs);
a1301 1

d1303 1
a1303 2

	return (0);
a1471 2
void
sd_flush_done(struct scsi_xfer *xs);
d1474 1
a1474 1
sd_flush(struct sd_softc *sc, int flags)
d1476 2
a1477 3
	struct scsi_link *link = sc->sc_link;
	struct scsi_xfer *xs;
	struct scsi_synchronize_cache *cmd;
d1479 1
a1479 1
	if (link->quirks & SDEV_NOSYNCCACHE)
d1488 6
a1493 22
	xs = scsi_xs_get(link, flags);
	if (xs == NULL) {
		SC_DEBUG(sc_link, SDEV_DB1, ("cache sync failed to get xs\n"));
		return;
	}

	cmd = (struct scsi_synchronize_cache *)xs->cmd;
	cmd->opcode = SYNCHRONIZE_CACHE;

	xs->timeout = 100000;

	xs->done = sd_flush_done;

	do {
		scsi_xs_exec(xs);
		if (!ISSET(xs->flags, SCSI_POLL)) {
			while (!ISSET(xs->flags, ITSDONE))
				tsleep(xs, PRIBIO, "sdflush", 0);
		}
	} while (xs->status == XS_NO_CCB);

	if (xs->error != XS_NOERROR)
d1495 2
a1496 11
	else
		sc->flags &= ~SDF_DIRTY;

	scsi_xs_put(xs);
}

void
sd_flush_done(struct scsi_xfer *xs)
{
	if (!ISSET(xs->flags, SCSI_POLL))
		wakeup_one(xs);
d1505 6
a1510 1
	struct buf *bp;
a1511 1
	while ((bp = sd_buf_dequeue(sd)) != NULL) {
d1516 1
@


1.162
log
@backout the backout marco did of my code because of the NO_CCB breakage.
the fix for the NO_CCB breakage will follow shortly.

tested by krw@@ marco@@ johan@@
ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.159 2009/10/13 19:33:19 pirofti Exp $	*/
d694 3
a696 1
	while ((bp = sd_buf_dequeue(sc)) != NULL) {
a759 1
	int s;
d761 3
a763 1
	disk_unbusy(&sc->sc_dk, bp->b_bcount - bp->b_resid,
d766 2
a767 1
	if (xs->error == XS_NOERROR) {
d770 11
a780 1
	} else {
d784 1
a786 1
	s = splbio();
a787 2
	splx(s);

d789 1
a789 2

	sdstart(sc); /* XXX */
d1470 7
a1476 5
	scsi_xs_exec(xs);
	if (!ISSET(xs->flags, SCSI_POLL)) {
		while (!ISSET(xs->flags, ITSDONE))
			tsleep(xs, PRIBIO, "sdflush", 0);
	}
@


1.161
log
@The big diff dlg committed to the midlayer breaks NO_CCB and
TRY_AGAIN_LATER.  NO_CCB is a timer based mechanism that can trivially
be made to fail by running IO to two or more disks simultaneously.  The
TRY_AGAIN_LATER thing is more subtle because it now is a permanent
failure instead of transient however this is much harder to hit because
something must have gone wrong before it hits.

ok deraadt krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.157 2009/08/13 15:23:11 deraadt Exp $	*/
a85 2
void	sdrestart(void *);
void	sddone(struct scsi_xfer *);
a86 1
int	sd_reassign_blocks(struct sd_softc *, u_long);
d96 10
d121 1
a121 1
	sddone,			/* deal with stats at interrupt time */
d173 2
d209 1
a209 1
	timeout_set(&sd->sc_timeout, sdrestart, sd);
a562 2
	s = splbio();

d566 3
a568 1
	disksort(&sd->buf_queue, bp);
a575 2
	splx(s);

d593 71
a675 3
 *
 * must be called at the correct (highish) spl level
 * sdstart() is called at splbio from sdstrategy, sdrestart and scsi_done
d680 4
a683 9
	struct sd_softc *sd = (struct sd_softc *)v;
	struct scsi_link *sc_link = sd->sc_link;
	struct buf *bp = 0;
	struct buf *dp;
	struct scsi_rw_big cmd_big;
	struct scsi_rw_12 cmd_12;
	struct scsi_rw_16 cmd_16;
	struct scsi_rw cmd_small;
	struct scsi_generic *cmdp;
d685 2
a686 1
	int nblks, cmdlen, error;
d689 1
a689 1
	if (sd->flags & SDF_DYING)
d694 1
a694 25
	splassert(IPL_BIO);

	/*
	 * Check if the device has room for another command
	 */
	while (sc_link->openings > 0) {
		/*
		 * there is excess capacity, but a special waits
		 * It'll need the adapter as soon as we clear out of the
		 * way and let it run (user level wait).
		 */
		if (sc_link->flags & SDEV_WAITING) {
			sc_link->flags &= ~SDEV_WAITING;
			wakeup((caddr_t)sc_link);
			return;
		}

		/*
		 * See if there is a buf with work for us to do..
		 */
		dp = &sd->buf_queue;
		if ((bp = dp->b_actf) == NULL)	/* yes, an assign */
			return;
		dp->b_actf = bp->b_actf;

d700 1
a700 1
		if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
d708 6
a713 6
		/*
		 * We have a buf, now we should make a command
		 *
		 * First, translate the block to absolute and put it in terms
		 * of the logical blocksize of the device.
		 */
d715 2
a716 2
		    bp->b_blkno / (sd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
		p = &sd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
d718 2
a719 1
		nblks = howmany(bp->b_bcount, sd->sc_dk.dk_label->d_secsize);
d725 2
a726 2
		if (!(sc_link->flags & SDEV_ATAPI) &&
		    !(sc_link->quirks & SDEV_ONLYBIG) &&
d728 18
a745 47
		    ((nblks & 0xff) == nblks)) {
			/*
			 * We can fit in a 6 byte cdb.
			 */
			bzero(&cmd_small, sizeof(cmd_small));
			cmd_small.opcode = (bp->b_flags & B_READ) ?
			    READ_COMMAND : WRITE_COMMAND;
			_lto3b(blkno, cmd_small.addr);
			cmd_small.length = nblks;
			cmdlen = sizeof(cmd_small);
			cmdp = (struct scsi_generic *)&cmd_small;
		} else if (((blkno & 0xffffffff) == blkno) &&
		    ((nblks & 0xffff) == nblks)) {
			/*
			 * We can fit in a 10 byte cdb.
			 */
			bzero(&cmd_big, sizeof(cmd_big));
			cmd_big.opcode = (bp->b_flags & B_READ) ?
			    READ_BIG : WRITE_BIG;
			_lto4b(blkno, cmd_big.addr);
			_lto2b(nblks, cmd_big.length);
			cmdlen = sizeof(cmd_big);
			cmdp = (struct scsi_generic *)&cmd_big;
		} else if (((blkno & 0xffffffff) == blkno) &&
		    ((nblks & 0xffffffff) == nblks)) {
			/*
			 * We can fit in a 12 byte cdb.
			 */
			bzero(&cmd_12, sizeof(cmd_12));
			cmd_12.opcode = (bp->b_flags & B_READ) ?
			    READ_12 : WRITE_12;
			_lto4b(blkno, cmd_12.addr);
			_lto4b(nblks, cmd_12.length);
			cmdlen = sizeof(cmd_12);
			cmdp = (struct scsi_generic *)&cmd_12;
		} else {
			/*
			 * Need a 16 byte cdb. There's nothing bigger.
			 */
			bzero(&cmd_16, sizeof(cmd_16));
			cmd_16.opcode = (bp->b_flags & B_READ) ?
			    READ_16 : WRITE_16;
			_lto8b(blkno, cmd_16.addr);
			_lto4b(nblks, cmd_16.length);
			cmdlen = sizeof(cmd_16);
			cmdp = (struct scsi_generic *)&cmd_16;
		}
d748 2
a749 34
		disk_busy(&sd->sc_dk);

		/*
		 * Call the routine that chats with the adapter.
		 * Note: we cannot sleep as we may be an interrupt
		 */
		error = scsi_scsi_cmd(sc_link, cmdp, cmdlen,
		    (u_char *)bp->b_data, bp->b_bcount,
		    SCSI_RETRIES, 60000, bp, SCSI_NOSLEEP |
		    ((bp->b_flags & B_READ) ? SCSI_DATA_IN : SCSI_DATA_OUT));
		switch (error) {
		case 0:
			/*
			 * Mark the disk dirty so that the cache will be
			 * flushed on close.
			 */
			if ((bp->b_flags & B_READ) == 0)
				sd->flags |= SDF_DIRTY;
			timeout_del(&sd->sc_timeout);
			break;
		case EAGAIN:
			/*
			 * The device can't start another i/o. Try again later.
			 */
			dp->b_actf = bp;
			disk_unbusy(&sd->sc_dk, 0, 0);
			timeout_add(&sd->sc_timeout, 1);
			return;
		default:
			disk_unbusy(&sd->sc_dk, 0, 0);
			printf("%s: not queued, error %d\n",
			    sd->sc_dev.dv_xname, error);
			break;
		}
d754 1
a754 1
sdrestart(void *v)
d756 2
d760 12
d773 1
a773 1
	sdstart(v);
a774 1
}
d776 1
a776 4
void
sddone(struct scsi_xfer *xs)
{
	struct sd_softc *sd = xs->sc_link->device_softc;
d778 1
a778 3
	if (xs->bp != NULL)
		disk_unbusy(&sd->sc_dk, (xs->bp->b_bcount - xs->bp->b_resid),
		    (xs->bp->b_flags & B_READ));
a1078 21
 * Tell the device to map out a defective block
 */
int
sd_reassign_blocks(struct sd_softc *sd, u_long blkno)
{
	struct scsi_reassign_blocks scsi_cmd;
	struct scsi_reassign_blocks_data rbdata;

	bzero(&scsi_cmd, sizeof(scsi_cmd));
	bzero(&rbdata, sizeof(rbdata));
	scsi_cmd.opcode = REASSIGN_BLOCKS;

	_lto2b(sizeof(rbdata.defect_descriptor[0]), rbdata.length);
	_lto4b(blkno, rbdata.defect_descriptor[0].dlbaddr);

	return scsi_scsi_cmd(sd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)&rbdata, sizeof(rbdata), SCSI_RETRIES,
	    5000, NULL, SCSI_DATA_OUT);
}

/*
a1162 1
static struct scsi_xfer sx;
d1172 1
a1172 1
	struct sd_softc *sd;	/* disk unit to do the I/O */
a1179 1
	struct scsi_rw_big cmd;	/* write command */
a1180 1
	int	retval;
d1193 1
a1193 1
	if (unit >= sd_cd.cd_ndevs || (sd = sd_cd.cd_devs[unit]) == NULL)
d1203 1
a1203 1
	if ((sd->sc_link->flags & SDEV_MEDIA_LOADED) != SDEV_MEDIA_LOADED)
d1208 1
a1208 1
	lp = sd->sc_dk.dk_label;
a1224 2
	xs = &sx;

d1227 1
d1229 6
a1234 23
		/*
		 *  Fill out the scsi command
		 */
		bzero(&cmd, sizeof(cmd));
		cmd.opcode = WRITE_BIG;
		_lto4b(blkno, cmd.addr);
		_lto2b(nwrt, cmd.length);
		/*
		 * Fill out the scsi_xfer structure
		 *    Note: we cannot sleep as we may be an interrupt
		 * don't use scsi_scsi_cmd() as it may want
		 * to wait for an xs.
		 */
		bzero(xs, sizeof(sx));
		xs->flags |= SCSI_AUTOCONF | SCSI_DATA_OUT;
		xs->sc_link = sd->sc_link;
		xs->retries = SCSI_RETRIES;
		xs->timeout = 10000;	/* 10000 millisecs for a disk ! */
		xs->cmd = (struct scsi_generic *)&cmd;
		xs->cmdlen = sizeof(cmd);
		xs->resid = nwrt * sectorsize;
		xs->error = XS_NOERROR;
		xs->bp = NULL;
d1238 6
a1243 6
		/*
		 * Pass all this info to the scsi driver.
		 */
		retval = (*(sd->sc_link->adapter->scsi_cmd)) (xs);
		if (retval != COMPLETE)
			return ENXIO;
d1255 1
d1257 2
a1258 1
	return 0;
d1427 2
d1431 1
a1431 1
sd_flush(struct sd_softc *sd, int flags)
d1433 3
a1435 2
	struct scsi_link *sc_link = sd->sc_link;
	struct scsi_synchronize_cache cmd;
d1437 1
a1437 1
	if (sc_link->quirks & SDEV_NOSYNCCACHE)
d1446 20
a1465 6
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = SYNCHRONIZE_CACHE;
		
	if (scsi_scsi_cmd(sc_link, (struct scsi_generic *)&cmd, sizeof(cmd),
	    NULL, 0, SCSI_RETRIES, 100000, NULL,
	    flags | SCSI_IGNORE_ILLEGAL_REQUEST)) {
d1467 11
a1477 2
	} else
		sd->flags &= ~SDF_DIRTY;
d1486 1
a1486 6
	struct buf *dp, *bp;
	int s;

	s = splbio();
	for (dp = &sd->buf_queue; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;
d1488 1
a1492 1
	splx(s);
@


1.160
log
@use _lto8b to calculate 64 bit address.  Fixes issue ckuethe saw at 2TB
boundary.

miod "go for it."
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.159 2009/10/13 19:33:19 pirofti Exp $	*/
d86 2
d89 1
a98 10
struct buf *sd_buf_dequeue(struct sd_softc *);
void	sd_buf_requeue(struct sd_softc *, struct buf *);

void	sd_cmd_rw6(struct scsi_xfer *, int, daddr64_t, u_int);
void	sd_cmd_rw10(struct scsi_xfer *, int, daddr64_t, u_int);
void	sd_cmd_rw12(struct scsi_xfer *, int, daddr64_t, u_int);
void	sd_cmd_rw16(struct scsi_xfer *, int, daddr64_t, u_int);

void	sd_buf_done(struct scsi_xfer *);

d114 1
a114 1
	NULL,			/* have no done handler */
a165 2
	mtx_init(&sd->sc_buf_mtx, IPL_BIO);

d200 1
a200 1
	timeout_set(&sd->sc_timeout, sdstart, sd);
d554 2
d559 1
a559 3
	mtx_enter(&sd->sc_buf_mtx);
	disksort(&sd->sc_buf_queue, bp);
	mtx_leave(&sd->sc_buf_mtx);
d567 2
a585 71
struct buf *
sd_buf_dequeue(struct sd_softc *sc)
{
	struct buf *bp;

	mtx_enter(&sc->sc_buf_mtx);
	bp = sc->sc_buf_queue.b_actf;
	if (bp != NULL)
		sc->sc_buf_queue.b_actf = bp->b_actf;
	mtx_leave(&sc->sc_buf_mtx);

	return (bp);
}

void
sd_buf_requeue(struct sd_softc *sc, struct buf *bp)
{
	mtx_enter(&sc->sc_buf_mtx);
	bp->b_actf = sc->sc_buf_queue.b_actf;
	sc->sc_buf_queue.b_actf = bp;
	mtx_leave(&sc->sc_buf_mtx);
}

void
sd_cmd_rw6(struct scsi_xfer *xs, int read, daddr64_t blkno, u_int nblks)
{
	struct scsi_rw *cmd = (struct scsi_rw *)xs->cmd;

	cmd->opcode = read ? READ_COMMAND : WRITE_COMMAND;
	_lto3b(blkno, cmd->addr);
	cmd->length = nblks;

	xs->cmdlen = sizeof(*cmd);
}

void
sd_cmd_rw10(struct scsi_xfer *xs, int read, daddr64_t blkno, u_int nblks)
{
	struct scsi_rw_big *cmd = (struct scsi_rw_big *)xs->cmd;

	cmd->opcode = read ? READ_BIG : WRITE_BIG;
	_lto4b(blkno, cmd->addr);
	_lto2b(nblks, cmd->length);

	xs->cmdlen = sizeof(*cmd);
}

void
sd_cmd_rw12(struct scsi_xfer *xs, int read, daddr64_t blkno, u_int nblks)
{
	struct scsi_rw_12 *cmd = (struct scsi_rw_12 *)xs->cmd;

	cmd->opcode = read ? READ_12 : WRITE_12;
	_lto4b(blkno, cmd->addr);
	_lto4b(nblks, cmd->length);

	xs->cmdlen = sizeof(*cmd);
}

void
sd_cmd_rw16(struct scsi_xfer *xs, int read, daddr64_t blkno, u_int nblks)
{
	struct scsi_rw_16 *cmd = (struct scsi_rw_16 *)xs->cmd;

	cmd->opcode = read ? READ_16 : WRITE_16;
	_lto8b(blkno, cmd->addr);
	_lto4b(nblks, cmd->length);

	xs->cmdlen = sizeof(*cmd);
}

d598 3
d605 9
a613 4
	struct sd_softc *sc = (struct sd_softc *)v;
	struct scsi_link *link = sc->sc_link;
	struct scsi_xfer *xs;
	struct buf *bp;
d615 1
a615 2
	int nblks;
	int read;
d618 1
a618 1
	if (sc->flags & SDF_DYING)
d623 25
a647 1
	while ((bp = sd_buf_dequeue(sc)) != NULL) {
d653 1
a653 1
		if ((link->flags & SDEV_MEDIA_LOADED) == 0) {
d661 6
a666 6
		xs = scsi_xs_get(link, SCSI_NOSLEEP);
		if (xs == NULL) {
			sd_buf_requeue(sc, bp);
			return;
		}

d668 2
a669 2
		    bp->b_blkno / (sc->sc_dk.dk_label->d_secsize / DEV_BSIZE);
		p = &sc->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
d671 1
a671 2
		nblks = howmany(bp->b_bcount, sc->sc_dk.dk_label->d_secsize);
		read = bp->b_flags & B_READ;
d677 2
a678 2
		if (!(link->flags & SDEV_ATAPI) &&
		    !(link->quirks & SDEV_ONLYBIG) &&
d680 47
a726 10
		    ((nblks & 0xff) == nblks))
			sd_cmd_rw6(xs, read, blkno, nblks);
		else if (((blkno & 0xffffffff) == blkno) &&
		    ((nblks & 0xffff) == nblks))
			sd_cmd_rw10(xs, read, blkno, nblks);
		else if (((blkno & 0xffffffff) == blkno) &&
		    ((nblks & 0xffffffff) == nblks))
			sd_cmd_rw12(xs, read, blkno, nblks);
		else
			sd_cmd_rw16(xs, read, blkno, nblks);
d728 2
a729 4
		xs->flags |= (read ? SCSI_DATA_IN : SCSI_DATA_OUT);
		xs->timeout = 60000;
		xs->data = bp->b_data;
		xs->datalen = bp->b_bcount;
d731 32
a762 6
		xs->done = sd_buf_done;
		xs->cookie = bp;

		/* Instrumentation. */
		disk_busy(&sc->sc_dk);
		scsi_xs_exec(xs);
d767 1
a767 1
sd_buf_done(struct scsi_xfer *xs)
a768 2
	struct sd_softc *sc = xs->sc_link->device_softc;
	struct buf *bp = xs->cookie;
a770 12
	disk_unbusy(&sc->sc_dk, bp->b_bcount - bp->b_resid,
	    bp->b_flags & B_READ);

	if (xs->error == XS_NOERROR) {
		bp->b_error = 0;
		bp->b_resid = xs->resid;
	} else {
		bp->b_error = EIO;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
	}

d772 1
a772 1
	biodone(bp);
d774 1
d776 4
a779 1
	scsi_xs_put(xs);
d781 3
a783 1
	sdstart(sc); /* XXX */
d1084 21
d1189 1
d1199 1
a1199 1
	struct sd_softc *sc;	/* disk unit to do the I/O */
d1207 1
d1209 1
d1222 1
a1222 1
	if (unit >= sd_cd.cd_ndevs || (sc = sd_cd.cd_devs[unit]) == NULL)
d1232 1
a1232 1
	if ((sc->sc_link->flags & SDEV_MEDIA_LOADED) != SDEV_MEDIA_LOADED)
d1237 1
a1237 1
	lp = sc->sc_dk.dk_label;
d1254 2
a1257 1

d1259 23
a1281 6
		xs = scsi_xs_get(sc->sc_link, SCSI_NOSLEEP);
		if (xs == NULL)
			return (ENOMEM);

		xs->timeout = 10000;
		xs->flags = SCSI_POLL | SCSI_NOSLEEP | SCSI_DATA_OUT;
d1285 6
a1290 6
		sd_cmd_rw10(xs, 0, blkno, nwrt); /* XXX */

		scsi_xs_exec(xs);
		if (xs->error != XS_NOERROR)
			return (ENXIO);
		scsi_xs_put(xs);
a1301 1

d1303 1
a1303 2

	return (0);
a1471 2
void
sd_flush_done(struct scsi_xfer *xs);
d1474 1
a1474 1
sd_flush(struct sd_softc *sc, int flags)
d1476 2
a1477 3
	struct scsi_link *link = sc->sc_link;
	struct scsi_xfer *xs;
	struct scsi_synchronize_cache *cmd;
d1479 1
a1479 1
	if (link->quirks & SDEV_NOSYNCCACHE)
d1488 6
a1493 20
	xs = scsi_xs_get(link, flags);
	if (xs == NULL) {
		SC_DEBUG(sc_link, SDEV_DB1, ("cache sync failed to get xs\n"));
		return;
	}

	cmd = (struct scsi_synchronize_cache *)xs->cmd;
	cmd->opcode = SYNCHRONIZE_CACHE;

	xs->timeout = 100000;

	xs->done = sd_flush_done;

	scsi_xs_exec(xs);
	if (!ISSET(xs->flags, SCSI_POLL)) {
		while (!ISSET(xs->flags, ITSDONE))
			tsleep(xs, PRIBIO, "sdflush", 0);
	}

	if (xs->error != XS_NOERROR)
d1495 2
a1496 11
	else
		sc->flags &= ~SDF_DIRTY;

	scsi_xs_put(xs);
}

void
sd_flush_done(struct scsi_xfer *xs)
{
	if (!ISSET(xs->flags, SCSI_POLL))
		wakeup_one(xs);
d1505 6
a1510 1
	struct buf *bp;
a1511 1
	while ((bp = sd_buf_dequeue(sd)) != NULL) {
d1516 1
@


1.159
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.158 2009/09/14 00:03:28 dlg Exp $	*/
d658 1
a658 1
	_lto4b(blkno, cmd->addr);
@


1.158
log
@rework the scsi midlayer to start addressing some problems i have
with it which became extremely annoying with what mpath wants to
do.

the major change is a new interface for submitting scsi commands.
previously the only way for drivers like sd, cd, st, etc to push
commands onto the hardware was via scsi_scsi_cmd(). the problem
with scsi_scsi_cmd is that it doesnt tell the caller if the command
failed, was queued, or completed unless you shoved a buf down with
it. this is important for mpath which wants to know what the physical
path to the device did so it can report it back to the midlayer
which called it.

this provides a new api which lets drivers like cd/sd/st/mpath etc
allocate an xs, fill it in, and provide a completion routine which
the midlayer will call with the state of the command when it is
finished with it. the caller is then responsible for freeing the
xs.

from the hba side of thing, the return code from the scsi_cmd
entrypoint is largely ignored now, and it is now always the
responsibility of the hba driver to call scsi_done when it has
completed the io, rather than returning COMPLETE and expecting the
midlayer to do it for you.

i have emulated scsi_scsi_cmd on top of this new api so existing
users of it will continue to work. sd(4) has been reworked to use
the new api directly to both demonstrate its use and test that the
new api actually does work.

this diff was mostly written in a day at f2k9. thanks to miod for poking
through hba drivers to help mitigate against fallout from the change to
the COMPLETE semantic. this has been reviewed by krw who didnt spot
anything wrong.

thanks to dave del debbio for testing.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.157 2009/08/13 15:23:11 deraadt Exp $	*/
d80 1
a80 1
int	sdactivate(struct device *, enum devact);
d269 1
a269 1
sdactivate(struct device *self, enum devact act)
@


1.157
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.156 2009/06/17 01:30:30 thib Exp $	*/
a85 2
void	sdrestart(void *);
void	sddone(struct scsi_xfer *);
a86 1
int	sd_reassign_blocks(struct sd_softc *, u_long);
d96 10
d121 1
a121 1
	sddone,			/* deal with stats at interrupt time */
d173 2
d209 1
a209 1
	timeout_set(&sd->sc_timeout, sdrestart, sd);
a562 2
	s = splbio();

d566 3
a568 1
	disksort(&sd->buf_queue, bp);
a575 2
	splx(s);

d593 71
a675 3
 *
 * must be called at the correct (highish) spl level
 * sdstart() is called at splbio from sdstrategy, sdrestart and scsi_done
d680 4
a683 9
	struct sd_softc *sd = (struct sd_softc *)v;
	struct scsi_link *sc_link = sd->sc_link;
	struct buf *bp = 0;
	struct buf *dp;
	struct scsi_rw_big cmd_big;
	struct scsi_rw_12 cmd_12;
	struct scsi_rw_16 cmd_16;
	struct scsi_rw cmd_small;
	struct scsi_generic *cmdp;
d685 2
a686 1
	int nblks, cmdlen, error;
d689 1
a689 1
	if (sd->flags & SDF_DYING)
d694 1
a694 25
	splassert(IPL_BIO);

	/*
	 * Check if the device has room for another command
	 */
	while (sc_link->openings > 0) {
		/*
		 * there is excess capacity, but a special waits
		 * It'll need the adapter as soon as we clear out of the
		 * way and let it run (user level wait).
		 */
		if (sc_link->flags & SDEV_WAITING) {
			sc_link->flags &= ~SDEV_WAITING;
			wakeup((caddr_t)sc_link);
			return;
		}

		/*
		 * See if there is a buf with work for us to do..
		 */
		dp = &sd->buf_queue;
		if ((bp = dp->b_actf) == NULL)	/* yes, an assign */
			return;
		dp->b_actf = bp->b_actf;

d700 1
a700 1
		if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
d708 6
a713 6
		/*
		 * We have a buf, now we should make a command
		 *
		 * First, translate the block to absolute and put it in terms
		 * of the logical blocksize of the device.
		 */
d715 2
a716 2
		    bp->b_blkno / (sd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
		p = &sd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
d718 2
a719 1
		nblks = howmany(bp->b_bcount, sd->sc_dk.dk_label->d_secsize);
d725 2
a726 2
		if (!(sc_link->flags & SDEV_ATAPI) &&
		    !(sc_link->quirks & SDEV_ONLYBIG) &&
d728 18
a745 47
		    ((nblks & 0xff) == nblks)) {
			/*
			 * We can fit in a 6 byte cdb.
			 */
			bzero(&cmd_small, sizeof(cmd_small));
			cmd_small.opcode = (bp->b_flags & B_READ) ?
			    READ_COMMAND : WRITE_COMMAND;
			_lto3b(blkno, cmd_small.addr);
			cmd_small.length = nblks;
			cmdlen = sizeof(cmd_small);
			cmdp = (struct scsi_generic *)&cmd_small;
		} else if (((blkno & 0xffffffff) == blkno) &&
		    ((nblks & 0xffff) == nblks)) {
			/*
			 * We can fit in a 10 byte cdb.
			 */
			bzero(&cmd_big, sizeof(cmd_big));
			cmd_big.opcode = (bp->b_flags & B_READ) ?
			    READ_BIG : WRITE_BIG;
			_lto4b(blkno, cmd_big.addr);
			_lto2b(nblks, cmd_big.length);
			cmdlen = sizeof(cmd_big);
			cmdp = (struct scsi_generic *)&cmd_big;
		} else if (((blkno & 0xffffffff) == blkno) &&
		    ((nblks & 0xffffffff) == nblks)) {
			/*
			 * We can fit in a 12 byte cdb.
			 */
			bzero(&cmd_12, sizeof(cmd_12));
			cmd_12.opcode = (bp->b_flags & B_READ) ?
			    READ_12 : WRITE_12;
			_lto4b(blkno, cmd_12.addr);
			_lto4b(nblks, cmd_12.length);
			cmdlen = sizeof(cmd_12);
			cmdp = (struct scsi_generic *)&cmd_12;
		} else {
			/*
			 * Need a 16 byte cdb. There's nothing bigger.
			 */
			bzero(&cmd_16, sizeof(cmd_16));
			cmd_16.opcode = (bp->b_flags & B_READ) ?
			    READ_16 : WRITE_16;
			_lto8b(blkno, cmd_16.addr);
			_lto4b(nblks, cmd_16.length);
			cmdlen = sizeof(cmd_16);
			cmdp = (struct scsi_generic *)&cmd_16;
		}
d748 2
a749 34
		disk_busy(&sd->sc_dk);

		/*
		 * Call the routine that chats with the adapter.
		 * Note: we cannot sleep as we may be an interrupt
		 */
		error = scsi_scsi_cmd(sc_link, cmdp, cmdlen,
		    (u_char *)bp->b_data, bp->b_bcount,
		    SCSI_RETRIES, 60000, bp, SCSI_NOSLEEP |
		    ((bp->b_flags & B_READ) ? SCSI_DATA_IN : SCSI_DATA_OUT));
		switch (error) {
		case 0:
			/*
			 * Mark the disk dirty so that the cache will be
			 * flushed on close.
			 */
			if ((bp->b_flags & B_READ) == 0)
				sd->flags |= SDF_DIRTY;
			timeout_del(&sd->sc_timeout);
			break;
		case EAGAIN:
			/*
			 * The device can't start another i/o. Try again later.
			 */
			dp->b_actf = bp;
			disk_unbusy(&sd->sc_dk, 0, 0);
			timeout_add(&sd->sc_timeout, 1);
			return;
		default:
			disk_unbusy(&sd->sc_dk, 0, 0);
			printf("%s: not queued, error %d\n",
			    sd->sc_dev.dv_xname, error);
			break;
		}
d754 1
a754 1
sdrestart(void *v)
d756 2
d760 12
d773 1
a773 1
	sdstart(v);
a774 1
}
d776 1
a776 4
void
sddone(struct scsi_xfer *xs)
{
	struct sd_softc *sd = xs->sc_link->device_softc;
d778 1
a778 3
	if (xs->bp != NULL)
		disk_unbusy(&sd->sc_dk, (xs->bp->b_bcount - xs->bp->b_resid),
		    (xs->bp->b_flags & B_READ));
a1078 21
 * Tell the device to map out a defective block
 */
int
sd_reassign_blocks(struct sd_softc *sd, u_long blkno)
{
	struct scsi_reassign_blocks scsi_cmd;
	struct scsi_reassign_blocks_data rbdata;

	bzero(&scsi_cmd, sizeof(scsi_cmd));
	bzero(&rbdata, sizeof(rbdata));
	scsi_cmd.opcode = REASSIGN_BLOCKS;

	_lto2b(sizeof(rbdata.defect_descriptor[0]), rbdata.length);
	_lto4b(blkno, rbdata.defect_descriptor[0].dlbaddr);

	return scsi_scsi_cmd(sd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)&rbdata, sizeof(rbdata), SCSI_RETRIES,
	    5000, NULL, SCSI_DATA_OUT);
}

/*
a1162 1
static struct scsi_xfer sx;
d1172 1
a1172 1
	struct sd_softc *sd;	/* disk unit to do the I/O */
a1179 1
	struct scsi_rw_big cmd;	/* write command */
a1180 1
	int	retval;
d1193 1
a1193 1
	if (unit >= sd_cd.cd_ndevs || (sd = sd_cd.cd_devs[unit]) == NULL)
d1203 1
a1203 1
	if ((sd->sc_link->flags & SDEV_MEDIA_LOADED) != SDEV_MEDIA_LOADED)
d1208 1
a1208 1
	lp = sd->sc_dk.dk_label;
a1224 2
	xs = &sx;

d1227 1
d1229 6
a1234 23
		/*
		 *  Fill out the scsi command
		 */
		bzero(&cmd, sizeof(cmd));
		cmd.opcode = WRITE_BIG;
		_lto4b(blkno, cmd.addr);
		_lto2b(nwrt, cmd.length);
		/*
		 * Fill out the scsi_xfer structure
		 *    Note: we cannot sleep as we may be an interrupt
		 * don't use scsi_scsi_cmd() as it may want
		 * to wait for an xs.
		 */
		bzero(xs, sizeof(sx));
		xs->flags |= SCSI_AUTOCONF | SCSI_DATA_OUT;
		xs->sc_link = sd->sc_link;
		xs->retries = SCSI_RETRIES;
		xs->timeout = 10000;	/* 10000 millisecs for a disk ! */
		xs->cmd = (struct scsi_generic *)&cmd;
		xs->cmdlen = sizeof(cmd);
		xs->resid = nwrt * sectorsize;
		xs->error = XS_NOERROR;
		xs->bp = NULL;
d1238 6
a1243 6
		/*
		 * Pass all this info to the scsi driver.
		 */
		retval = (*(sd->sc_link->adapter->scsi_cmd)) (xs);
		if (retval != COMPLETE)
			return ENXIO;
d1255 1
d1257 2
a1258 1
	return 0;
d1427 2
d1431 1
a1431 1
sd_flush(struct sd_softc *sd, int flags)
d1433 3
a1435 2
	struct scsi_link *sc_link = sd->sc_link;
	struct scsi_synchronize_cache cmd;
d1437 1
a1437 1
	if (sc_link->quirks & SDEV_NOSYNCCACHE)
d1446 20
a1465 6
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = SYNCHRONIZE_CACHE;
		
	if (scsi_scsi_cmd(sc_link, (struct scsi_generic *)&cmd, sizeof(cmd),
	    NULL, 0, SCSI_RETRIES, 100000, NULL,
	    flags | SCSI_IGNORE_ILLEGAL_REQUEST)) {
d1467 11
a1477 2
	} else
		sd->flags &= ~SDF_DIRTY;
d1486 1
a1486 6
	struct buf *dp, *bp;
	int s;

	s = splbio();
	for (dp = &sd->buf_queue; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;
d1488 1
a1492 1
	splx(s);
@


1.156
log
@Revert bufq's. this is inline with the major midlayer reverts that
have been going on. this appears to bring us back to stable state.

lots of testing by oga and ariane and my self.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.155 2009/06/03 22:09:30 thib Exp $	*/
d84 1
a84 1
void	sdgetdisklabel(dev_t, struct sd_softc *, struct disklabel *, int);
d401 4
a404 1
		sdgetdisklabel(dev, sd, sd->sc_dk.dk_label, 0);
d998 1
a998 1
void
d1003 1
a1003 1
	char *errstring, packname[sizeof(lp->d_packname) + 1];
d1063 1
a1063 4
	errstring = readdisklabel(DISKLABELDEV(dev), sdstrategy, lp, spoofonly);
	if (errstring) {
		/*printf("%s: %s\n", sd->sc_dev.dv_xname, errstring);*/
	}
@


1.155
log
@add a flexible buffer queue (bufq) api, based on the never used
one by tedu@@. It doesn't do anything smart yet, it just uses
plain old disksort. we also keep the old method of queueing bufs
since some miods have crazy MD drivers that need some love.

ok beck@@, art@@
tested by many on many archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.153 2008/08/24 09:08:49 dlg Exp $	*/
d93 1
d271 1
a271 1
		bufq_drain(sd->sc_dk.dk_bufq);
d285 1
a285 1
	bufq_drain(sd->sc_dk.dk_bufq);
d553 4
a556 2
	/* Place it in the queue of disk activities for this disk */
	BUFQ_ADD(sd->sc_dk.dk_bufq, bp);
d605 1
d640 2
a641 1
		if ((bp = BUFQ_GET(sd->sc_dk.dk_bufq)) == NULL)
d643 1
d750 1
a750 1
			BUFQ_ADD(sd->sc_dk.dk_bufq, bp);
d1497 20
@


1.154
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@a92 1
void	sd_kill_buffers(struct sd_softc *);
d270 1
a270 1
		sd_kill_buffers(sd);
d284 1
a284 1
	sd_kill_buffers(sd);
d552 2
a553 4
	/*
	 * Place it in the queue of disk activities for this disk
	 */
	disksort(&sd->buf_queue, bp);
a601 1
	struct buf *dp;
d636 1
a636 2
		dp = &sd->buf_queue;
		if ((bp = dp->b_actf) == NULL)	/* yes, an assign */
a637 1
		dp->b_actf = bp->b_actf;
d744 1
a744 1
			dp->b_actf = bp;
a1490 20
}

/*
 * Remove unprocessed buffers from queue.
 */
void
sd_kill_buffers(struct sd_softc *sd)
{
	struct buf *dp, *bp;
	int s;

	s = splbio();
	for (dp = &sd->buf_queue; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;

		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		biodone(bp);
	}
	splx(s);
@


1.153
log
@dont display disk geometry (cyls/heads/sectors) since it mostly lies these
days. if you really want it still you can fetch it via disklabel(8).

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.151 2008/07/08 12:17:48 dlg Exp $	*/
d811 1
a811 1
	(*sd->sc_link->adapter->scsi_minphys)(bp);
@


1.152
log
@silence failures to run scsi_prevent. dmesg spam sucks.

ok krw@@ marco@@ miod@@ deraadt@@
@
text
@d228 3
a230 3
		printf("%lldMB, %lu cyl, %lu head, %lu sec, %lu bytes/sec, %lld sec total",
		    dp->disksize / (1048576 / dp->blksize), dp->cyls,
		    dp->heads, dp->sectors, dp->blksize, dp->disksize);
@


1.151
log
@this makes the code in sdattach less dense by collapsing the flags we pass
to all the scsi midlayer code into a local variable.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.149 2008/06/21 21:11:34 krw Exp $	*/
d371 2
a372 2
		if ((sc_link->flags & SDEV_REMOVABLE) != 0)
			scsi_prevent(sc_link, PR_PREVENT,
d375 1
d379 1
a379 1
		    TEST_READY_RETRIES, (rawopen ? SCSI_SILENT : 0) |
d429 1
a429 1
			scsi_prevent(sc_link, PR_ALLOW,
d481 1
a481 1
			    SCSI_IGNORE_NOT_READY);
@


1.150
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d161 2
d204 1
a204 2
		scsi_start(sc_link, SSS_START, scsi_autoconf | SCSI_SILENT |
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
d211 1
a211 3
		scsi_prevent(sc_link, PR_PREVENT, scsi_autoconf |
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE |
		    SCSI_SILENT);
d215 1
a215 2
	    scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST |
	    SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT);
d220 1
a220 2
		result = sd_get_parms(sd, &sd->params,
		    scsi_autoconf | SCSI_SILENT | SCSI_IGNORE_MEDIA_CHANGE);
d223 1
a223 3
		scsi_prevent(sc_link, PR_ALLOW, scsi_autoconf |
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE |
		    SCSI_SILENT);
@


1.149
log
@fgsch@@ points out my last commit changed the retry limit for CD capacity
commands. Bump limit back to the standard 4, and at the same time eliminate
SDRETRIES and CDRETRIES (both defined to 4) in favour of a new define,
SCSI_RETRIES, also defined to 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.148 2008/06/15 00:52:25 krw Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.148
log
@Treat SENSE_NOT_READY_INIT_REQUIRED sense errors the same as
SENSE_NOT_READY_BECOMING_READY sense errors. Some devices such as USB
Zip250 drives return the former when they mean the latter. Give the
first TEST UNIT READY command three times the usual retries so more
devices have time to get ready. This allows more removable devices to
detect media details and avoid issuing 'drive offline' messages.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.147 2008/06/15 00:36:41 krw Exp $	*/
d745 1
a745 1
		    SDRETRIES, 60000, bp, SCSI_NOSLEEP |
d1111 1
a1111 1
	    sizeof(scsi_cmd), (u_char *)&rbdata, sizeof(rbdata), SDRETRIES,
d1286 1
a1286 1
		xs->retries = SDRETRIES;
d1503 1
a1503 1
	    NULL, 0, SDRETRIES, 100000, NULL,
@


1.147
log
@Don't bypass partition bounds check for RAW_PART. We now guarantee that
RAW_PART will always be 0 -> disksize, so the bounds check will always
pass for i/o's to valid addresses. Now the i/o will be properly truncated
if it goes past the end of the device. This prevents various adverse
impacts of issuing i/o's for data past the end of the device.

Repeatedly requested by todd@@.

ok weingart@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.146 2008/06/10 04:46:07 krw Exp $	*/
d222 1
a222 1
	error = scsi_test_unit_ready(sd->sc_link, TEST_READY_RETRIES,
@


1.146
log
@When copying stuff from code that runs with interrupts enabled to code
that may run without interrupts, don't forget to add scsi_autoconf
to the flags and POLL for the result rather than wait for an interrupt that
will never come. Fixes Dale's Iomega Jazz drive on the ahc here, and no
doubt many other device combinations.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.145 2008/06/02 17:01:13 krw Exp $	*/
d558 1
a558 2
	if (DISKPART(bp->b_dev) != RAW_PART &&
	    bounds_check_with_label(bp, sd->sc_dk.dk_label,
@


1.145
log
@Don't spew sense errors (e.g. 'media not present') when probing a
device. Fallout from doing better PREVENT ALLOW dance.

Prodded by marco@@ as a result of a report from Andreas Kahari on tech@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.144 2008/05/24 18:53:46 krw Exp $	*/
d217 3
a219 2
		scsi_prevent(sc_link, PR_PREVENT, SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT);
d233 3
a235 2
		scsi_prevent(sc_link, PR_ALLOW, SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT);
@


1.144
log
@SDEV_UMASS devices skip the mode page dance to set blksize. So initialize
blksize to 0 to avoid confusing garbage values with useful info.

Noticed by jolan@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.143 2008/05/09 06:19:33 krw Exp $	*/
d218 1
a218 1
		    SCSI_IGNORE_MEDIA_CHANGE);
d232 2
a233 3
		scsi_prevent(sc_link, PR_ALLOW,
		    SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE);
@


1.143
log
@Lock in removable media while trying to determine the disk parameters. This
should fix a number of 'drive offline' situations where the device claims
it has no media loaded until the lock in occurs. Like a Blackberry Pearl
Todd Fries found and probably other USB devices. Move the lock in during
device open to before the test unit ready to eliminate similar spurious
rejections of the device.

Feedback from marco@@, tests by todd@@ and miod@@.

ok deraadt@@ beck@@ dlg@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.142 2008/03/21 19:57:44 krw Exp $	*/
d1349 1
a1349 1
	u_int32_t heads = 0, sectors = 0, cyls = 0, blksize, ssblksize;
@


1.142
log
@USB Floppies are umass devices so we always use the default 63/255
geometry.  But 63 * 255 > 2880 and the cylinder count becomes 0.  So
if we end up with a valid disksize but 0 cylinders, set heads =
cylinders = 1 and sectors-per-track = disksize.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.141 2007/12/28 16:19:15 dlg Exp $	*/
d212 8
d231 5
d377 10
a398 10

		/*
		 * Try to prevent the unloading of a removable device while
		 * it's open. But allow the open to proceed if the device can't
		 * be locked in.
		 */
		if ((sc_link->flags & SDEV_REMOVABLE) != 0)
			scsi_prevent(sc_link, PR_PREVENT,
			    SCSI_IGNORE_ILLEGAL_REQUEST |
			    SCSI_IGNORE_MEDIA_CHANGE);
@


1.141
log
@massage the way vpds are defined. rename the page used for the devices
serial number and split the vpd header out for use in other places. while
here define the device identification page bits too.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.140 2007/11/23 14:44:59 dlg Exp $	*/
d1462 5
@


1.140
log
@if we cant fetch the serial then fill it with "(unknown)".
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.139 2007/11/11 16:46:51 krw Exp $	*/
d970 1
a970 1
	struct scsi_inquiry_vpd vpd;
@


1.139
log
@Revert useless textual optimization that resulted in 16 bytes being
sent to the adapter instead of the 10 bytes the scsi_sychronize_cache
command actually occupies. This freaked out the ahc on jsing@@'s SGI
and probably others.

Found, isolated, fix tested, and ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.138 2007/11/06 02:49:19 krw Exp $	*/
d984 2
@


1.138
log
@Fix SDF_DIRTY handling, eliminate useless SDF_FLUSHING. The sd_flush()
called from the last sdclose() on a device will now reset SDF_DIRTY
after submitting the SYNCHRONIZE CACHE command. sddone() need not
worry about SDF_DIRTY since it was never called for the SYNCHRONIZE
CACHE command anyway.

This eliminates a spurious SYNCHRONIZE CACHE command being issued for
every sd device from sd_shutdown().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.137 2007/09/15 19:22:18 bluhm Exp $	*/
d1468 1
a1468 1
	struct scsi_generic cmd;
d1482 3
a1484 2
	if (scsi_scsi_cmd(sc_link, &cmd, sizeof(cmd), NULL, 0, SDRETRIES,
	    100000, NULL, flags | SCSI_IGNORE_ILLEGAL_REQUEST)) {
@


1.137
log
@Allow to pull out an usb stick with ffs filesystem while mounted
and a file is written onto the stick.  Without these fixes the
machine panics or hangs.
The usb fix calls the callback when the stick is pulled out to free
the associated buffers.  Otherwise we have busy buffers for ever
and the automatic unmount will panic.
The change in the scsi layer prevents passing down further dirty
buffers to usb after the stick has been deactivated.
In vfs the automatic unmount has moved from the function vgonel()
to vop_generic_revoke().  Both are called when the sd device's vnode
is removed.  In vgonel() the VXLOCK is already held which can cause
a deadlock.  So call dounmount() earlier.

ok krw@@, I like this marco@@, tested by ian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.136 2007/06/23 19:19:49 krw Exp $	*/
a775 5
	if (sd->flags & SDF_FLUSHING) {
		/* Flush completed, no longer dirty. */
		sd->flags &= ~(SDF_FLUSHING|SDF_DIRTY);
	}

d1468 4
a1471 1
	struct scsi_synchronize_cache sync_cmd;
d1474 3
a1476 12
	 * If the device is SCSI-2, issue a SYNCHRONIZE CACHE.
	 * We issue with address 0 length 0, which should be
	 * interpreted by the device as "all remaining blocks
	 * starting at address 0".  We ignore ILLEGAL REQUEST
	 * in the event that the command is not supported by
	 * the device, and poll for completion so that we know
	 * that the cache has actually been flushed.
	 *
	 * Unless, that is, the device can't handle the SYNCHRONIZE CACHE
	 * command, as indicated by our quirks flags.
	 *
	 * XXX What about older devices?
d1478 9
a1486 14
	if (SCSISPC(sc_link->inqdata.version) >= 2 &&
	    (sc_link->quirks & SDEV_NOSYNCCACHE) == 0) {
		bzero(&sync_cmd, sizeof(sync_cmd));
		sync_cmd.opcode = SYNCHRONIZE_CACHE;

		if (scsi_scsi_cmd(sc_link,
		    (struct scsi_generic *)&sync_cmd, sizeof(sync_cmd),
		    NULL, 0, SDRETRIES, 100000, NULL,
		    flags|SCSI_IGNORE_ILLEGAL_REQUEST))
			printf("%s: WARNING: cache synchronization failed\n",
			    sd->sc_dev.dv_xname);
		else
			sd->flags |= SDF_FLUSHING;
	}
@


1.136
log
@Implement disk sizes > 2^32-1. Code modelled on NetBSD.

Tested, tweaked and ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.135 2007/06/20 18:15:47 deraadt Exp $	*/
d260 1
d268 2
a269 3
		/*
		 * Nothing to do; we key off the device's DVF_ACTIVATE.
		 */
d323 4
d450 5
a454 1
		return ENXIO;
d510 4
d613 3
d845 5
a849 1
		return ENXIO;
d1162 4
@


1.135
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.134 2007/06/18 20:55:52 deraadt Exp $	*/
d226 1
a226 1
		printf("%luMB, %lu cyl, %lu head, %lu sec, %lu bytes/sec, %lu sec total",
a1420 8
	 * Use standard geometry values for anything we still don't know.
	 */

	dp->heads = (heads == 0) ? 255 : heads;
	dp->sectors = (sectors == 0) ? 63 : sectors;
	dp->rot_rate = (rpm == 0) ? 3600 : rpm;

	/*
d1426 14
@


1.134
log
@avoid modification race in DIOCRLDINFO; ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.133 2007/06/08 05:27:58 deraadt Exp $	*/
d91 1
a91 2
void	sdgetdisklabel(dev_t, struct sd_softc *, struct disklabel *,
			    struct cpu_disklabel *, int);
d394 1
a394 2
		sdgetdisklabel(dev, sd, sd->sc_dk.dk_label,
		    sd->sc_dk.dk_cpulabel, 0);
a533 1
	    sd->sc_dk.dk_cpulabel,
d862 1
a862 1
		sdgetdisklabel(dev, sd, lp, sd->sc_dk.dk_cpulabel, 0);
d866 3
a868 7
	case DIOCGPDINFO: {
			struct cpu_disklabel osdep;

			sdgetdisklabel(dev, sd, (struct disklabel *)addr,
			    &osdep, 1);
			goto exit;
		}
d892 1
a892 2
		    (struct disklabel *)addr, /*sd->sc_dk.dk_openmask : */0,
		    sd->sc_dk.dk_cpulabel);
d896 1
a896 2
				    sdstrategy, sd->sc_dk.dk_label,
				    sd->sc_dk.dk_cpulabel);
d979 1
a979 1
    struct cpu_disklabel *clp, int spoofonly)
a985 1
	bzero(clp, sizeof(struct cpu_disklabel));
d1042 1
a1042 2
	errstring = readdisklabel(DISKLABELDEV(dev), sdstrategy, lp, clp,
	    spoofonly);
@


1.133
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.132 2007/06/07 05:29:44 deraadt Exp $	*/
d827 1
d864 4
a867 2
		sdgetdisklabel(dev, sd, sd->sc_dk.dk_label,
		    sd->sc_dk.dk_cpulabel, 0);
@


1.132
log
@in OpenBSD as all old BSD unix, RAW_PART always starts at 0, so no
need for special case code; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.131 2007/06/06 17:15:14 deraadt Exp $	*/
d1035 1
@


1.131
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.130 2007/06/05 00:38:23 deraadt Exp $	*/
d600 1
a600 1
	int64_t blkno;
d652 2
a653 4
		if (DISKPART(bp->b_dev) != RAW_PART) {
			p = &sd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
			blkno += DL_GETPOFFSET(p);
		}
@


1.130
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.129 2007/06/01 00:07:48 krw Exp $	*/
d600 2
a601 1
	int blkno, nblks, cmdlen, error;
d1142 1
a1142 1
int
d1147 1
a1147 1
	int size;
d1184 1
a1184 1
sddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
d1190 2
a1191 2
	int	nsects;		/* number of sectors in partition */
	int	sectoff;	/* sector offset of partition */
@


1.129
log
@Don't initialize d_partitions[RAW_DISK] just before calling
readdisklabel(), since all readdisklabel()'s do that already.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.128 2007/05/31 18:07:18 krw Exp $	*/
d653 1
a653 1
			blkno += p->p_offset;
d1033 1
a1033 1
	lp->d_secperunit = sd->params.disksize;
d1164 1
a1164 1
		size = sd->sc_dk.dk_label->d_partitions[part].p_size *
d1230 2
a1231 2
	nsects = lp->d_partitions[part].p_size;
	sectoff = lp->d_partitions[part].p_offset;
@


1.128
log
@Use 12 and 16 byte read/write commands as required by the size/length
of the I/O being attempted. Throw in a comment typo fix to properly
refer to sectors and not blocks.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.127 2007/04/28 02:24:21 krw Exp $	*/
a1040 5

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;
@


1.127
log
@Fix comments above DISKMINOR uses. DISKMINOR provides minor not major
number (wd.c), and the uses are to find the minimum minor to be
detached.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.126 2007/04/26 11:18:54 krw Exp $	*/
d524 1
a524 1
	 * The transfer must be a whole number of blocks.
d596 2
d666 1
a666 1
			 * We can fit in a small cdb.
d672 1
a672 1
			cmd_small.length = nblks & 0xff;
d675 2
a676 1
		} else {
d678 1
a678 1
			 * Need a large cdb.
d687 23
@


1.126
log
@Use the standard DISKPART/DISKUNIT/etc. defines rather than identical
but differently named SD/CD ones. No change to .o files.

ok deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.125 2007/04/14 16:32:30 krw Exp $	*/
d286 1
a286 1
	/* locate the minor number */
@


1.125
log
@For devices unwilling or unable to report geometry, change the 'fake'
geometry used to 255 heads and 63 sectors/track from 64 heads and 32
sectors. 255/63 makes the cylinders as large as PC/BIOS compatibility
allows, increasing the size of devices that can be supported.

ok pedro@@ (long ago) marco@@ millert@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.124 2007/04/13 18:56:26 krw Exp $	*/
a84 7
#define	SDUNIT(dev)			DISKUNIT(dev)
#define	SDMINOR(unit, part)		DISKMINOR(unit, part)
#define	SDPART(dev)			DISKPART(dev)
#define	MAKESDDEV(maj, unit, part)	MAKEDISKDEV(maj, unit, part)

#define	SDLABELDEV(dev)	(MAKESDDEV(major(dev), SDUNIT(dev), RAW_PART))

d287 1
a287 1
	mn = SDMINOR(self->dv_unit, 0);
d316 2
a317 2
	unit = SDUNIT(dev);
	part = SDPART(dev);
d443 1
a443 1
	int part = SDPART(dev);
d446 1
a446 1
	sd = sdlookup(SDUNIT(dev));
d499 1
a499 1
	sd = sdlookup(SDUNIT(bp->b_dev));
d534 1
a534 1
	if (SDPART(bp->b_dev) != RAW_PART &&
d649 2
a650 2
		if (SDPART(bp->b_dev) != RAW_PART) {
			p = &sd->sc_dk.dk_label->d_partitions[SDPART(bp->b_dev)];
d755 1
a755 1
	sd = sdlookup(SDUNIT(bp->b_dev));
d803 1
a803 1
	int part = SDPART(dev);
d805 1
a805 1
	sd = sdlookup(SDUNIT(dev));
d856 1
a856 1
		    &sd->sc_dk.dk_label->d_partitions[SDPART(dev)];
d875 1
a875 1
				error = writedisklabel(SDLABELDEV(dev),
d1028 1
a1028 1
	errstring = readdisklabel(SDLABELDEV(dev), sdstrategy, lp, clp,
d1127 1
a1127 1
	sd = sdlookup(SDUNIT(dev));
d1131 1
a1131 1
	part = SDPART(dev);
d1183 2
a1184 2
	unit = SDUNIT(dev);	/* Decompose unit & partition. */
	part = SDPART(dev);
@


1.124
log
@If a removable device refuses to process PREVENT_ALLOW to lock the
media in while the device is open, allow the open anyway. Fixes some
USB devices which do odd things when presented by PREVENT_ALLOW.

Suggestion from mickey@@.

ok millert@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.123 2007/04/11 10:54:57 bluhm Exp $	*/
d1415 1
a1415 2
	 * Use Adaptec standard geometry values for anything we still don't
	 * know.
d1418 2
a1419 2
	dp->heads = (heads == 0) ? 64 : heads;
	dp->sectors = (sectors == 0) ? 32 : sectors;
@


1.123
log
@Use a separate function to remove the buffers in sddetach.
No functional change.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.122 2007/04/10 16:41:45 bluhm Exp $	*/
d381 7
a387 3
		/* Lock the pack in. */
		if ((sc_link->flags & SDEV_REMOVABLE) != 0) {
			error = scsi_prevent(sc_link, PR_PREVENT,
d390 1
a390 3
			if (error)
				goto bad;
		}
@


1.122
log
@Name and cast all struct sd_softc *sd the same way.  No binary change.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.121 2007/04/04 12:44:17 dlg Exp $	*/
d108 1
d289 1
a289 2
	struct buf *dp, *bp;
	int s, bmaj, cmaj, mn;
d291 1
a291 10
	/* Remove unprocessed buffers from queue */
	s = splbio();
	for (dp = &sd->buf_queue; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;

		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		biodone(bp);
	}
	splx(s);
d1467 20
@


1.121
log
@sprinkle some ansification around.

no binary change, and ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.120 2007/04/03 04:58:21 dlg Exp $	*/
d171 1
a171 1
	struct sd_softc *sd = (void *)self;
d287 1
a287 1
	struct sd_softc *sc = (struct sd_softc *)self;
d293 1
a293 1
	for (dp = &sc->buf_queue; (bp = dp->b_actf) != NULL; ) {
d313 2
a314 2
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
d317 1
a317 1
	disk_detach(&sc->sc_dk);
d605 1
a605 1
	struct sd_softc *sd = v;
d1053 1
a1053 1
	struct sd_softc *sd = arg;
@


1.120
log
@implement the DK INFO ioctl so userland can query the disks product,
vendor, etc details.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.119 2007/02/21 01:32:21 krw Exp $	*/
d151 1
a151 3
sdmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d159 1
d168 1
a168 3
sdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d265 1
a265 3
sdactivate(self, act)
	struct device *self;
	enum devact act;
d279 1
d285 1
a285 3
sddetach(self, flags)
	struct device *self;
	int flags;
d326 1
a326 4
sdopen(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
d454 1
a454 4
sdclose(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
d508 1
a508 2
sdstrategy(bp)
	struct buf *bp;
d603 1
a603 2
sdstart(v)
	void *v;
d606 1
a606 1
	struct	scsi_link *sc_link = sd->sc_link;
d739 1
a739 2
sdrestart(v)
	void *v;
d749 1
a749 2
sddone(xs)
	struct scsi_xfer *xs;
d764 1
a764 2
sdminphys(bp)
	struct buf *bp;
d797 1
a797 4
sdread(dev, uio, ioflag)
	dev_t dev;
	struct uio *uio;
	int ioflag;
a798 1

d803 1
a803 4
sdwrite(dev, uio, ioflag)
	dev_t dev;
	struct uio *uio;
	int ioflag;
a804 1

d813 1
a813 6
sdioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
d973 2
a974 6
sdgetdisklabel(dev, sd, lp, clp, spoofonly)
	dev_t dev;
	struct sd_softc *sd;
	struct disklabel *lp;
	struct cpu_disklabel *clp;
	int spoofonly;
d1051 1
a1051 2
sd_shutdown(arg)
	void *arg;
d1070 1
a1070 3
sd_reassign_blocks(sd, blkno)
	struct sd_softc *sd;
	u_long blkno;
d1091 1
a1091 2
sd_interpret_sense(xs)
	struct scsi_xfer *xs;
d1135 1
a1135 2
sdsize(dev)
	dev_t dev;
d1176 1
a1176 5
sddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
d1291 1
a1291 4
viscpy(dst, src, len)
	u_char *dst;
	u_char *src;
	int len;
d1311 1
a1311 4
sd_get_parms(sd, dp, flags)
	struct sd_softc *sd;
	struct disk_parms *dp;
	int flags;
d1443 1
a1443 3
sd_flush(sd, flags)
	struct sd_softc *sd;
	int flags;
@


1.119
log
@Don't unconditionally spin up SDEV_UMASS devices. They almost
certainly don't need it, or are capable of reporting themselves in
need of a spin up.  Feedback from various agreeing it is unlikely such
devices exist.

Fixes devices found by Markus Bergkvist and Johan M:son Lindman.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.118 2007/02/12 00:30:17 krw Exp $	*/
d111 2
d958 7
d976 21
@


1.118
log
@Don't need a 'return' just before exiting a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.117 2007/02/03 23:47:18 bluhm Exp $	*/
d215 4
a218 3
	/* Spin up the unit ready or not. */
	scsi_start(sc_link, SSS_START, scsi_autoconf | SCSI_SILENT |
	    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
d370 5
a374 3
		/* Spin up the unit, ready or not. */
		scsi_start(sc_link, SSS_START, (rawopen ? SCSI_SILENT : 0) |
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
a500 1

@


1.117
log
@Make comment match code.  ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.116 2006/12/21 02:05:46 krw Exp $	*/
a1047 1
		return;
@


1.116
log
@Fix some comment typos. 'immediatly' -> 'immediately', 'tranfer' ->
'transfer', 'tranfered' -> 'transferred'.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.115 2006/12/12 02:44:36 krw Exp $	*/
d305 1
a305 1
	/* locate the major number */
@


1.115
log
@Give the SCSI layer the ability to requeue i/o's rejected by a driver
using the new NO_CCB result. Currently a no-op since no driver produces
that result.

ok dlg@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.114 2006/11/28 16:56:50 dlg Exp $	*/
d541 1
a541 1
	 * If it's a null transfer, return immediatly
@


1.114
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.113 2006/11/27 23:14:22 beck Exp $	*/
d60 1
a60 1
#include <sys/kernel.h>
d101 1
d213 2
d501 2
d609 1
a609 1
 * sdstart() is called at splbio from sdstrategy and scsi_done
a713 8
		 * Mark the disk dirty so that the cache will be
		 * flushed on close.
		 */
		if ((bp->b_flags & B_READ) == 0)
			sd->flags |= SDF_DIRTY;


		/*
d721 19
a739 1
		if (error) {
d743 1
d749 11
d1066 2
@


1.113
log
@more magic removal
ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.112 2006/11/27 20:15:09 beck Exp $	*/
d152 1
a152 1
	struct scsibus_attach_args *sa = aux;
d173 1
a173 1
	struct scsibus_attach_args *sa = aux;
@


1.112
log
@get rid of the rest of the asc/ascq magic codes in scsi
ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.111 2006/10/07 23:40:07 beck Exp $	*/
d1082 1
a1082 1
	    (serr != 0x70 && serr != 0x71) ||
@


1.111
log
@make cd-roms retry forever while the device indicates that it is
"becoming ready" - this is done in the exact same way that it
was done for tape in st.c. This commit adds a cd specific interpret_sense
routine to cd.c that will catch the becoming ready case and handle it.
This also removes the need to use crazy timeouts to catch this case.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.110 2006/07/29 02:40:46 krw Exp $	*/
d1084 1
a1084 2
	    (sense->extra_len < 6) ||
	    (sense->add_sense_code != 0x04))
d1087 2
a1088 2
	switch (sense->add_sense_code_qual) {
	case 0x01: /* In process of becoming ready. */
d1093 1
a1093 1
	case 0x02: /* Initialization command required. */
@


1.110
log
@The version field of scsi_inquiry_data is not a simple numeric value
that specifies the version of SCSI being supported. Even the ANSI part
that we use is complex. 4 means 2, 5 means 3 and 6 means 4. Translate
and use the value correctly. Fixes SCSI5 and SCSI6 in dmesg. And
properly protects SCSI2 devices from getting SCSI3 commands.

"seems like an elegant solution to me" millert@@ ok dlg@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.109 2006/07/23 02:50:20 dlg Exp $	*/
d217 1
a217 1
	error = scsi_test_unit_ready(sd->sc_link, TEST_READY_RETRIES_DEFAULT,
d380 1
a380 1
		    TEST_READY_RETRIES_DEFAULT, (rawopen ? SCSI_SILENT : 0) |
@


1.109
log
@remove some scsi ioctls, most importantly the ones that can reprobe the
bus. supporting these complicates the midlayer unnecessarily.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.108 2006/07/13 11:46:16 krw Exp $	*/
d202 1
a202 1
	    (sa->sa_inqbuf->version & SID_ANSII) == 0)
d1454 1
a1454 1
	if ((sc_link->inqdata.version & SID_ANSII) >= 2 &&
@


1.108
log
@Eliminate scsi_link field 'scsi_version' and just use the INQUIRY data
stored in scsi_link. That's where the value came from anyway. Move 'luns'
field to where 'scsi_version' used to be to preserve alignment.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.107 2006/07/11 21:55:46 dlg Exp $	*/
a832 1
		case OSCIOCIDENTIFY:
a924 8
		goto exit;

	case SCIOCREASSIGN:
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}
		error = sd_reassign_blocks(sd, (*(int *)addr));
@


1.107
log
@the scsi_link structure contained a copy of the inquiry flags and the whole
inquiry. this removes the flags member and makes all its users refer to the
whole inquiry now.

ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.106 2006/05/18 00:10:05 krw Exp $	*/
d1463 1
a1463 1
	if ((sc_link->scsi_version & SID_ANSII) >= 2 &&
@


1.106
log
@Test the state of a disk *after* spinning it up and not before. This
prevents the issuing of sizing inquiries to non-existant or non-responsive
devices like empty slots on a USB card reader.

Also try to avoid *extremely* unlikely loop of scsi_start() commands, by
not using sd_interpret_sense() until after the disk is spinning.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.105 2006/05/11 00:45:59 krw Exp $	*/
d195 1
a195 1
	if (!(sc_link->inquiry_flags & SID_RelAdr))
@


1.105
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.104 2006/03/15 20:20:42 miod Exp $	*/
d212 5
a220 4
	/* Spin up the unit ready or not. */
	error = scsi_start(sc_link, SSS_START, scsi_autoconf | SCSI_SILENT |
	    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);

d366 10
a375 1
		/* Use sd_interpret_sense() for sense errors. */
a381 5

		/* Spin up the unit, ready or not. */
		error = scsi_start(sc_link, SSS_START,
		    (rawopen ? SCSI_SILENT : 0) | SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE);
@


1.104
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.103 2006/03/05 14:58:10 krw Exp $	*/
d674 1
a674 1
		    !(sc_link->quirks & SDEV_ONLYBIG) && 
d1379 1
a1379 1
			}	
d1384 1
a1384 1
validate:	
@


1.103
log
@Remove NetBSDism NRND. Pointed out by Mickey.

ok miod@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.102 2006/03/04 19:33:22 miod Exp $	*/
a190 2

	dk_establish(&sd->sc_dk, &sd->sc_dev);
@


1.102
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.101 2006/01/21 12:18:49 miod Exp $	*/
a318 5

#if NRND > 0
	/* Unhook the entropy source. */
	rnd_detach_source(&sc->rnd_source);
#endif
@


1.101
log
@Invoke disk_detach() and related cleanup work in detach(), rather than
zeroref() - just to be on the safe side, should we mess up our ref count.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.100 2005/11/17 23:58:41 miod Exp $	*/
d767 1
a767 1
	 * by settng the "length" to 0.  However, we're conservative
@


1.100
log
@Don't forget to device_unref() in sdclose() if sdlock() fails; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.99 2005/11/17 21:25:58 krw Exp $	*/
a95 1
void	sdzeroref(struct device *);
d112 1
a112 1
	sddetach, sdactivate, sdzeroref
d317 3
a325 10
}

void
sdzeroref(self)
	struct device *self;
{
	struct sd_softc *sd = (struct sd_softc *)self;

	/* Detach disk. */
	disk_detach(&sd->sc_dk);
@


1.99
log
@Use sectors as the size units for the RAW_PART (i.e. 'c') partition in
spoofed sd disklabels. Sectors are the partition size units used and
documented everywhere else in the tree. sd ensures a sector will
always be a multiple of 512.

Fixes disklabel(8) error messages and partition size display for sd
devices that have no OpenBSD disklabel and a sectorsize > 512. Noted
by Robert Szasz on his Sony Hi-MD device.

ok pedro@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.98 2005/11/13 16:10:05 krw Exp $	*/
d478 4
a481 2
	if ((error = sdlock(sd)) != 0)
		return error;
@


1.98
log
@Allow removable disks to be spun up if they ask for initialization
after being opened.  Use SC_DEBUG() to suppress some verbiage during
spin up. Return actual errors encountered during attempt to spin up,
rather than always returning EIO.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.97 2005/11/13 02:39:45 krw Exp $	*/
d1023 1
a1023 2
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
@


1.97
log
@Use scsi_delay() instead of delay() when waiting for scsi disk to
become ready. Make verbiage SC_DEBUG().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.96 2005/11/07 23:49:32 krw Exp $	*/
d1111 1
d1113 8
a1120 17
		if (sd->sc_link->flags & SDEV_REMOVABLE) {
			printf("%s: removable disk stopped - not restarting\n",
			    sd->sc_dev.dv_xname);
			retval = EIO;
		} else {
			printf("%s: respinning up disk\n", sd->sc_dev.dv_xname);
			retval = scsi_start(sd->sc_link, SSS_START,
		    	    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_URGENT |
			    SCSI_NOSLEEP);
			if (retval != 0) {
				printf("%s: respin of disk failed - %d\n",
				    sd->sc_dev.dv_xname, retval);
				retval = EIO;
			} else {
				retval = ERESTART;
			}
		}
d1122 1
@


1.96
log
@Death to superfluous verbiage. Suppress errors when getting the parameters
for a raw partition like we suppress errors for the other operations on raw
partitions. Replace 'could not get size' with more specific and informative
SC_DEBUG() output. Silences a usb card reader that fgsch@@ found. Now attach
message is only 'sdX: drive offline'.

Tested & ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.95 2005/10/10 20:06:12 krw Exp $	*/
d1107 3
a1109 7
	case 0x01:
		printf("%s: ..is spinning up...waiting\n", sd->sc_dev.dv_xname);
		/*
		 * I really need a sdrestart function I can call here.
		 */
		delay(1000000 * 5);	/* 5 seconds */
		retval = ERESTART;
d1111 1
a1111 1
	case 0x02:
@


1.95
log
@Make some panic messages more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.94 2005/09/19 04:25:00 krw Exp $	*/
d411 2
a412 1
		if (sd_get_parms(sd, &sd->params, 0) == SDGP_RESULT_OFFLINE) {
@


1.94
log
@Use variable to eliminate repeated calculation. More readable. No
functional change.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.93 2005/09/11 17:34:27 krw Exp $	*/
d243 1
a243 1
		panic("sdattach: unknown result from get_parms");
@


1.93
log
@Simplify code by changing struct scsi_mode_sense_buf{ union {}
headers; } to just union scsi_mode_sense_buf {}. No functional change.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.92 2005/09/11 17:18:53 krw Exp $	*/
d347 1
a347 2
	int unit, part;
	int error = 0;
d352 2
d374 1
a374 1
			if (part == RAW_PART && fmt == S_IFCHR)
d385 1
a385 2
		    TEST_READY_RETRIES_DEFAULT,
		    ((part == RAW_PART && fmt == S_IFCHR) ? SCSI_SILENT : 0) |
d390 2
a391 2
		    ((part == RAW_PART && fmt == S_IFCHR) ? SCSI_SILENT : 0) |
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
d394 1
a394 1
			if (part == RAW_PART && fmt == S_IFCHR) {
@


1.92
log
@Some UMASS devices blow up if MODE SENSE buffer length is 0 (aka 256).
Some blow up if buffer length is not 0. Just fake geometry for all
UMASS devices since it's almost always fictitious anyway. One step on
the road to eliminate geometry entirely.

Fixes Ed Wandasiewicz's 2nd gen iPod mini and Sebastiaan Indesteege's
UBest Technology device.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.91 2005/09/08 03:33:55 krw Exp $	*/
d1331 1
a1331 1
	struct scsi_mode_sense_buf *buf = NULL;
@


1.91
log
@free(NULL, ...) is not safe in the kernel. So check for NULL'ness
before free()'ing buf in sd_get_parms(). Tweak code so there is only
one free(buf, ...) to worry about.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.90 2005/08/27 03:50:04 krw Exp $	*/
d1331 1
a1331 1
	struct scsi_mode_sense_buf *buf;
d1340 9
a1348 1
	buf = malloc(sizeof(*buf) ,M_TEMP, M_NOWAIT);
@


1.90
log
@Put in missing parenthesis and thus always pass
SCSI_IGNORE_ILLEGAL_REQUEST and SCSI_IGNORE_MEDIA_CHANGE flags to
scsi_test_unit_ready() and scsi_start() during sdopen(). Re-enables
use of devices that don't support START_STOP or TEST_UNIT_READY
commands.

Noted by and fix tested by Jason Crawford on VMWare disks.

ok dlg@@ henning@@, supportive comments from miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.89 2005/08/24 01:19:47 krw Exp $	*/
d1401 1
a1401 1
	if (dp->disksize == 0) {
d1403 2
d1406 1
a1406 1
	}
a1427 1
		free(buf, M_TEMP);
a1448 1
	free(buf, M_TEMP);
@


1.89
log
@Test xs->bp before de-referencing it. Initialize it to NULL, not 0.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.88 2005/08/23 23:38:00 krw Exp $	*/
d385 1
a385 1
		    (part == RAW_PART && fmt == S_IFCHR) ? SCSI_SILENT : 0 |
d390 1
a390 1
		    (part == RAW_PART && fmt == S_IFCHR) ? SCSI_SILENT : 0 |
@


1.88
log
@Move uses of struct scsi_mode_sense_buf (255 bytes each) from the
stack into malloc'd memory.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.87 2005/08/23 23:31:04 krw Exp $	*/
d1272 1
a1272 1
		xs->bp = 0;
@


1.87
log
@Spin up sd units even if TEST_UNIT_READY says they're ready.

Use consistant scsi_autoconf and SCSI_SILENT flags in
scsi_test_unit()/scsi_start() pairs.

Fixes some hppa, vax, sparc systems that do not spin up disks
automatically. Keeps USB card readers and such reasonably quiet.

Noted by millert@@ (hppa), henning@@ (sparc) and hshoexer@@ (vax).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.86 2005/08/21 16:25:52 krw Exp $	*/
d1331 4
a1334 4
	struct scsi_mode_sense_buf buf;
	struct page_rigid_geometry	*rigid;
	struct page_flex_geometry	*flex;
	struct page_reduced_geometry	*reduced;
d1340 4
d1351 1
a1351 1
		scsi_do_mode_sense(sd->sc_link, PAGE_REDUCED_GEOMETRY, &buf,
d1374 1
a1374 1
			    &buf, (void **)&rigid, NULL, NULL, &blksize,
d1384 1
a1384 1
			    &buf, (void **)&flex, NULL, NULL, &blksize,
d1400 3
a1402 1
	if (dp->disksize == 0)
d1404 1
d1426 1
d1448 1
@


1.86
log
@Some devices go berserk when asked for mode sense pages they don't
have. Some devices return four bytes less information than requested
for the PAGE_RIGID_GEOMETRY page. Put the two together and older
Conner drives don't work because we rejected the short page and asked
for the PAGE_FLEX_GEOMETY page. Noted by hshoexer@@ and kettenis@@.

Also should fix the problems with a device miod@@ reported that did a
similar short PAGE_FLEX_GEOMETRY.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.85 2005/08/18 22:59:21 krw Exp $	*/
d219 3
a221 4
	/* Try to start the unit if it wasn't ready. */
	if (error == EIO)
		error = scsi_start(sc_link, SSS_START,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
d388 4
a391 5
		/* Try to start the unit if it wasn't ready. */
		if (error == EIO)
			error = scsi_start(sc_link, SSS_START,
			    SCSI_IGNORE_ILLEGAL_REQUEST |
			    SCSI_IGNORE_MEDIA_CHANGE);
@


1.85
log
@Only allow blocksizes that are powers of 2 between 512 and 64K. An sd
device that returns any other value via READ CAPACITY or MODE SENSE
will be marked 'drive offline'. Prevents divide by zero when
calculating disk size in MB, amoung other interesting possibilities.

ok mickey@@ dlg@@ deraadt@@ millert@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.84 2005/08/17 02:17:51 krw Exp $	*/
d1361 7
d1373 1
a1373 1
			    sizeof(*rigid), flags | SCSI_SILENT, NULL);
d1383 1
a1383 1
			    sizeof(*flex), flags | SCSI_SILENT, NULL);
@


1.84
log
@Use defines for disk mode page codes. Check returned mode pages to
ensure they are the ones requested. No functional change unless
garbage was being returned.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.83 2005/08/12 01:49:08 krw Exp $	*/
d1397 19
@


1.83
log
@Move disk mode page structure declarations out of scsi_disk_pages
union declaration to allow pointers to individual page types. Simplify
sd.c code by using individual page type pointers. No functional
change.

ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.82 2005/07/30 15:54:45 krw Exp $	*/
d1348 5
a1352 5
		/* T_RDIRECT only supports RBC Device Parameter Page (6). */
		scsi_do_mode_sense(sd->sc_link, 6, &buf, (void **)&reduced,
		    NULL, NULL, &blksize, sizeof(*reduced), flags | SCSI_SILENT,
		    NULL);
		if (reduced) {
d1364 2
a1365 3
			/* Try mode sense page 4 (RIGID GEOMETRY). */
			scsi_do_mode_sense(sd->sc_link, 4, &buf,
			    (void **)&rigid, NULL, NULL, &blksize,
d1367 1
a1367 1
		if (rigid) { 
d1374 4
a1377 5
			/* * Try page 5 (FLEX GEOMETRY). */
			scsi_do_mode_sense(sd->sc_link, 5, &buf, (void **)&flex,
			    NULL, NULL, &blksize, sizeof(*flex),
			    flags | SCSI_SILENT, NULL);
			if (flex) {
@


1.82
log
@Use the blocksize returned from scsi_size() in preference to all
other values as was intended. As opposed to overwriting it with
scsi_do_mode_sense() calls.

May help PR4313.

ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.81 2005/07/05 00:55:25 krw Exp $	*/
d1334 3
a1336 1
	union scsi_disk_pages *sense_pages;
d1349 4
a1352 4
		scsi_do_mode_sense(sd->sc_link, 6, &buf, (void **)&sense_pages,
		    NULL, NULL, &blksize, sizeof(sense_pages->reduced_geometry),
		    flags | SCSI_SILENT, NULL);
		if (sense_pages) {
d1354 1
a1354 2
				dp->disksize = _5btol(sense_pages->
				    reduced_geometry.sectors);
d1356 1
a1356 2
				blksize = _2btol(sense_pages->
				    reduced_geometry.bytes_s);
d1361 1
a1361 1
		sense_pages = NULL;
d1366 6
a1371 7
			    (void **)&sense_pages, NULL, NULL, &blksize,
			    sizeof(sense_pages->rigid_geometry),
			    flags | SCSI_SILENT, NULL);
		if (sense_pages) { 
			heads = sense_pages->rigid_geometry.nheads;
			cyls = _3btol(sense_pages->rigid_geometry.ncyl);
			rpm = _2btol(sense_pages->rigid_geometry.rpm);
d1376 2
a1377 3
			scsi_do_mode_sense(sd->sc_link, 5, &buf,
			    (void **)&sense_pages, NULL, NULL, &blksize,
			    sizeof(sense_pages->flex_geometry),
d1379 5
a1383 5
			if (sense_pages) {
				sectors = sense_pages->flex_geometry.ph_sec_tr;
				heads = sense_pages->flex_geometry.nheads;
				cyls = _2btol(sense_pages->flex_geometry.ncyl);
				rpm = _2btol(sense_pages->flex_geometry.rpm);
d1385 1
a1385 2
					blksize = _2btol(sense_pages->
					    flex_geometry.bytes_s);
a1398 1

@


1.81
log
@Since scsi_link now includes a copy of the INQUIRY data, don't keep a
copy of the vendor/product/revision fields in sd_softc. Just use the
INQUIRY data to build the disklabel 'label' when required. No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.80 2005/07/02 15:39:55 krw Exp $	*/
d1335 1
a1335 1
	u_int32_t heads = 0, sectors = 0, cyls = 0, blksize;
d1338 1
a1338 1
	dp->disksize = scsi_size(sd->sc_link, flags, &blksize);
d1398 5
a1409 1
	dp->blksize = (blksize == 0) ? 512 : blksize;
@


1.80
log
@Remove unused cd_softc.name field. Use the saved INQUIRY data in
scsi_link to determine device type, rather than keeping a copy in
sd_softc.type. Remove unused sd_softc.type field.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.79 2005/07/02 14:32:17 krw Exp $	*/
a223 5
	/* Fill in name struct for spoofed label */
	viscpy(sd->name.vendor, sa->sa_inqbuf->vendor, 8);
	viscpy(sd->name.product, sa->sa_inqbuf->product, 16);
	viscpy(sd->name.revision, sa->sa_inqbuf->revision, 4);

d971 1
d999 3
a1001 2
	len = snprintf(packname, sizeof(packname), "%s %s",
	    sd->name.vendor, sd->name.product);
d1003 1
a1003 1
		strlcpy(packname, sd->name.product, sizeof(packname));
@


1.79
log
@Remove unused struct sd_ops.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.78 2005/07/02 03:49:47 krw Exp $	*/
a182 1
	sd->type = (sa->sa_inqbuf->device & SID_TYPE);
d991 1
a991 1
	if (sd->type == T_OPTICAL)
d1343 1
a1343 1
	switch (sd->type) {
@


1.78
log
@Don't use READ FORMAT CAPACITIES to determine the size of ATAPI sd
devices. Use READ CAPACITY like NetBSD, FreeBSD, Linux and OpenSolaris
do. Well, NetBSD keeps READ FORMAT CAPACITIES as a backup. Fixes
problems with devices (such as my IBM USB Memory Key) which return
block counts that are off by one for READ FORMAT CAPACITIES.

This eliminates the significant difference between sd_atapi.c and
sd_scsi.c so merge sd_scsi.c into sd.c and just be careful to mark
ATAPI removable devices as both SDEV_NOSYNCCACHE and unable to return
MODE SENSE page 4 info.

All geometry faking is now in one place. Where it can be 'improved'.

sd_scsi.c, sd_atapi.c and atapi_disk.h will be removed as a result.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.77 2005/05/03 00:29:16 krw Exp $	*/
a142 3

extern struct sd_ops sd_scsibus_ops;
extern struct sd_ops sd_atapibus_ops;
@


1.77
log
@sdstrategy() shouldn't use values in disklabel until SDEV_MEDIA_LOADED
is checked.  Fixes crash during boot when a device has no media
loaded. e.g. a usb card reader with empty slots. From NetBSD. Problem
was introduced by last commit to allow RAW_PART+S_IFCHAR opens to
always succeed.

ok millert@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.76 2005/05/01 19:29:17 krw Exp $	*/
d106 2
d199 2
a200 6
	if (sc_link->flags & SDEV_ATAPI &&
	    (sc_link->flags & SDEV_REMOVABLE)) {
		sd->sc_ops = &sd_atapibus_ops;
	} else {
		sd->sc_ops = &sd_scsibus_ops;
	}
d236 1
a236 1
		result = (*sd->sc_ops->sdo_get_parms)(sd, &sd->params,
a250 4
	case SDGP_RESULT_UNFORMATTED:
		printf("unformatted media");
		break;

d422 1
a422 2
		if ((*sd->sc_ops->sdo_get_parms)(sd, &sd->params, 0) ==
		    SDGP_RESULT_OFFLINE) {
d502 2
a503 3
		if ((sd->flags & SDF_DIRTY) != 0 &&
		    sd->sc_ops->sdo_flush != NULL)
			(*sd->sc_ops->sdo_flush)(sd, 0);
d1063 2
a1064 2
	if ((sd->flags & SDF_DIRTY) != 0 && sd->sc_ops->sdo_flush != NULL)
		(*sd->sc_ops->sdo_flush)(sd, SCSI_AUTOCONF);
d1326 138
@


1.76
log
@Allow RAW_PART+S_IFCHR device opens to succeed even if media not
present. A successful open is required for ioctl's to work.  Mostly
from NetBSD, partly correcting previous code cleanup error.

From deraadt@@, treat MTIOCTOP+MTRETEN as CDIOCCLOSE for cd devices
(i.e. close the cd drawer).

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.75 2005/04/06 02:51:13 krw Exp $	*/
a551 7
	 * The transfer must be a whole number of blocks.
	 */
	if ((bp->b_bcount % sd->sc_dk.dk_label->d_secsize) != 0) {
		bp->b_error = EINVAL;
		goto bad;
	}
	/*
d567 7
@


1.75
log
@De-register scsi.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.74 2005/04/05 02:01:50 krw Exp $	*/
d386 1
a386 1
		 * disallow further opens.
d389 2
d410 7
a416 2
		if (error)
			goto bad;
d450 1
a450 1
	/* Insure only one open at a time. */
@


1.74
log
@Clean up some logic. Use better error handling for sd devices. Be
quiet if raw partition access tried. Be more careful with
SDEV_MEDIA_LOADED. Inspired by some NetBSD changes.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.73 2005/03/30 02:40:42 krw Exp $	*/
d627 1
a627 1
	register void *v;
d629 2
a630 2
	register struct sd_softc *sd = v;
	register struct	scsi_link *sc_link = sd->sc_link;
@


1.73
log
@Comment typo, minor knf. No code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.72 2005/03/25 05:07:43 krw Exp $	*/
d361 1
a362 1
	struct scsi_link *sc_link;
d364 1
a364 1
	int error;
d367 2
a373 2
	part = SDPART(dev);

d390 1
a390 1
			goto bad3;
d393 3
d398 3
a400 2
		    TEST_READY_RETRIES_DEFAULT, SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE);
d409 1
a409 3
			goto bad3;

		sc_link->flags |= SDEV_OPEN;
d419 9
d429 4
a432 16
		if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
			sc_link->flags |= SDEV_MEDIA_LOADED;

			/* Load the physical device parameters. */
			if ((*sd->sc_ops->sdo_get_parms)(sd, &sd->params,
			    0) == SDGP_RESULT_OFFLINE) {
				error = ENXIO;
				goto bad2;
			}
			SC_DEBUG(sc_link, SDEV_DB3, ("Params loaded\n"));

			/* Load the partition info if not already loaded. */
			sdgetdisklabel(dev, sd, sd->sc_dk.dk_label,
			    sd->sc_dk.dk_cpulabel, 0);
			SC_DEBUG(sc_link, SDEV_DB3, ("Disklabel loaded\n"));
		}
a452 1

a453 6
	sdunlock(sd);
	device_unref(&sd->sc_dev);
	return (0);

bad2:
	sc_link->flags &= ~SDEV_MEDIA_LOADED;
d455 1
d462 1
a462 1
		sc_link->flags &= ~SDEV_OPEN;
a464 1
bad3:
d471 1
a471 1
 * close the device.. only called if we are the LAST occurence of an open
d508 3
a510 2
			    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY);
		sd->sc_link->flags &= ~(SDEV_OPEN|SDEV_MEDIA_LOADED);
@


1.72
log
@Since START_STOP is an optional command that a device need not
support, don't penalize devices that don't support it. May help some
usb devices.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.71 2005/02/27 01:12:11 krw Exp $	*/
d353 1
a353 1
 * open the device. Make sure the partition info is a up-to-date as can be.
d369 1
a369 1
		return ENXIO;
d380 1
a380 1
		return error;
d395 1
a395 2
		    TEST_READY_RETRIES_DEFAULT,
		    SCSI_IGNORE_ILLEGAL_REQUEST |
d413 1
a413 1
			        SCSI_IGNORE_MEDIA_CHANGE);
d458 1
a458 1
	return 0;
d465 5
a469 5
	    if ((sd->sc_link->flags & SDEV_REMOVABLE) != 0)
		scsi_prevent(sc_link, PR_ALLOW,
		    SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE);
	    sc_link->flags &= ~SDEV_OPEN;
d475 1
a475 1
	return error;
@


1.71
log
@If test_unit_ready() in sdattach() returns EIO, try to spin up unit
exactly as is done in sdopen(). This improves the chances of getting
valid geometry/size and avoiding 'drive offline' errors, without
subjecting the device to anything it won't see anyway.

No impact on devices that already work. Fixes problem with Jim Rees'
Hitachi DK23DA in an Archos Multimedia Jukebox. Without adding quirks!

Tested by Jim Rees. ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.70 2004/05/28 23:50:15 krw Exp $	*/
d225 1
a225 1
	/* Start the pack spinning if necessary. */
d227 2
a228 1
		error = scsi_start(sc_link, SSS_START, 0);
d399 1
a399 1
		/* Start the pack spinning if necessary. */
d401 3
a403 1
			error = scsi_start(sc_link, SSS_START, 0);
d1140 2
a1141 1
			    SCSI_URGENT | SCSI_NOSLEEP);
@


1.70
log
@Clean up sense error logic and printing a bit, partly inspired by
NetBSD. Try to limit special handling of sense errors in sd and st to
a minimum.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.69 2004/05/17 23:57:51 krw Exp $	*/
d224 4
@


1.69
log
@Elminate SCSIRET_* synonyms for EJUSTRETURN and ERESTART by using
EJUSTRETURN and ERESTART instead. Delete unused SCSIRET_RETRY define.
From NetBSD.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.68 2004/05/09 04:01:59 krw Exp $	*/
d1099 1
a1100 1
	struct scsi_sense_data *sense = &xs->sense;
d1102 2
a1103 1
	int retval = EJUSTRETURN;
d1106 2
a1107 1
	 * If the device is not open yet, let the generic code handle it.
d1109 19
a1127 17
	if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
		return (retval);
	}

	/*
	 * If it isn't a extended or extended/deferred error, let
	 * the generic code handle it.
	 */
	if ((sense->error_code & SSD_ERRCODE) != 0x70 &&
	    (sense->error_code & SSD_ERRCODE) != 0x71) {	/* DEFFERRED */
		return (retval);
	}

	if ((sense->flags & SSD_KEY) == SKEY_NOT_READY &&
	    sense->add_sense_code == 0x4) {
		if (sense->add_sense_code_qual == 0x01)	{
			printf("%s: ..is spinning up...waiting\n",
d1129 8
a1136 10
			/*
			 * I really need a sdrestart function I can call here.
			 */
			delay(1000000 * 5);	/* 5 seconds */
			retval = ERESTART;
		} else if (sense->add_sense_code_qual == 0x2) {
			if (sd->sc_link->flags & SDEV_REMOVABLE) {
				printf(
				"%s: removable disk stopped - not restarting\n",
				    sd->sc_dev.dv_xname);
d1139 1
a1139 12
				printf("%s: respinning up disk\n",
				    sd->sc_dev.dv_xname);
				retval = scsi_start(sd->sc_link, SSS_START,
				    SCSI_URGENT | SCSI_NOSLEEP);
				if (retval != 0) {
					printf(
					    "%s: respin of disk failed - %d\n",
					    sd->sc_dev.dv_xname, retval);
					retval = EIO;
				} else {
					retval = ERESTART;
				}
d1142 4
d1147 1
@


1.68
log
@Add missing <cr>'s to various SC_DEBUG() calls, along with a few other
SC_DEBUG() spacing tweaks.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.67 2004/02/21 00:47:42 krw Exp $	*/
d1102 1
a1102 1
	int retval = SCSIRET_CONTINUE;
d1129 1
a1129 1
			retval = SCSIRET_RETRY;
d1147 1
a1147 1
					retval = SCSIRET_RETRY;
@


1.67
log
@Eliminate the quirks SDEV_NOSTARTUNIT, UMASS_QUIRK_NO_START_STOP, and
UMASS_QUIRK_FORCE_SHORT_INQUIRY. Fixes a bunch of USB devices. Based
on work by Mycroft in NetBSD.

ok tdeval@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.66 2004/02/15 02:45:47 tedu Exp $	*/
d178 1
a178 1
	SC_DEBUG(sc_link, SDEV_DB2, ("sdattach: "));
d421 1
a421 1
			SC_DEBUG(sc_link, SDEV_DB3, ("Params loaded "));
d426 1
a426 1
			SC_DEBUG(sc_link, SDEV_DB3, ("Disklabel loaded "));
d543 2
a544 3
	SC_DEBUG(sd->sc_link, SDEV_DB2, ("sdstrategy "));
	SC_DEBUG(sd->sc_link, SDEV_DB1,
	    ("%ld bytes @@ blk %d\n", bp->b_bcount, bp->b_blkno));
d640 1
a640 1
	SC_DEBUG(sc_link, SDEV_DB2, ("sdstart "));
d842 1
a842 1
	SC_DEBUG(sd->sc_link, SDEV_DB2, ("sdioctl 0x%lx ", cmd));
@


1.66
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.65 2004/01/25 21:51:18 krw Exp $	*/
d221 3
a223 6
	if ((sd->sc_link->quirks & SDEV_NOSTARTUNIT) == 0) {
		error = scsi_start(sd->sc_link, SSS_START,
				   scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST |
				   SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT);
	} else
		error = 0;
d392 6
a397 2
		    SCSI_IGNORE_MEDIA_CHANGE |
		    SCSI_IGNORE_NOT_READY);
a400 9
		/* Start the pack spinning if necessary. */
		if ((sc_link->quirks & SDEV_NOSTARTUNIT) == 0) {
			error = scsi_start(sc_link, SSS_START,
			    SCSI_IGNORE_ILLEGAL_REQUEST |
			    SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT);
			if (error)
				goto bad3;
		}

d1131 1
a1131 2
		} else if ((sense->add_sense_code_qual == 0x2) &&
		    (sd->sc_link->quirks & SDEV_NOSTARTUNIT) == 0) {
@


1.65
log
@Be less verbose in sdattach() by suppressing the display of detailed
sense information when attempting to discover the disk size.

USB 6-in-1 readers have a bunch of LUNs and otherwise produce many
'Medium Not Present' details everytime they are plugged in. Noticed
by grange@@.

Requested by and ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.64 2004/01/25 00:52:49 krw Exp $	*/
d754 1
a754 1
			disk_unbusy(&sd->sc_dk, 0);
d773 2
a774 1
		disk_unbusy(&sd->sc_dk, (xs->bp->b_bcount - xs->bp->b_resid));
@


1.64
log
@Use %lu to print u_long values, not %d or %ld. Fixes display of
negative number of sectors for very large (i.e. RAID) disks. Noticed
by Marco Peereboom.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.63 2004/01/05 02:57:01 krw Exp $	*/
d237 1
a237 1
		    scsi_autoconf | SCSI_IGNORE_MEDIA_CHANGE);
@


1.63
log
@Don't issue PREVENT_ALLOW commands to disk devices during sdopen() or
sdclose() unless they identified themselves as removable.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.62 2003/06/24 22:42:07 mickey Exp $	*/
d242 1
a242 1
		printf("%ldMB, %d cyl, %d head, %d sec, %d bytes/sec, %ld sec total",
@


1.62
log
@try to devise drive's rpm and default to 3600 should we fail miserably.
derived from pr2815 from Marco Peereboom
krw@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.61 2003/05/21 23:43:58 krw Exp $	*/
d412 7
a418 4
		error = scsi_prevent(sc_link, PR_PREVENT,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
		if (error)
			goto bad;
d467 1
d469 3
a471 2
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
		sc_link->flags &= ~SDEV_OPEN;
d516 3
a518 2
		scsi_prevent(sd->sc_link, PR_ALLOW,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY);
@


1.61
log
@Make sure that the first scsi command issued to a device during
sdattach() has the flag SCSI_IGNORE_MEDIA_CHANGE set. This was not
true for devices with the quirk SDEV_NOSTARTUNIT, such as some umass
devices.

This fixes the display of the disk parameters for any loaded media.
Previously the displayed parameters would show 0 size, 0 sectors and a
faked number of cylinders, etc. By ignoring the error generated by
devices trying to tell us the media may have changed since the last
command the SCSI command completes correctly and valid values are
obtained/displayed. We are interested in the current values and
unconcerned about any previous ones.

Tested by drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.60 2003/05/18 16:06:35 mickey Exp $	*/
d1026 1
a1026 1
	lp->d_rpm = 3600;
@


1.60
log
@constify the quirck tables and fix the scsi_inqmatch() proto accordingly; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.59 2003/05/16 19:54:05 krw Exp $	*/
d237 1
a237 1
		    scsi_autoconf);
@


1.59
log
@Provide most if not all the support required for the usb changes Nate
is trying to bring in.

1) Change name of SDEV_NOCDB6 to SDEV_ONLYBIG to align it with the
same quirk in NetBSD, and make it more clear what it is trying to do.
i.e. force the use of READ_BIG/WRITE_BIG commands, not suppress all
use of 6 byte CDB's.

2) Check SDEV_ONLYBIG in cd.c as well as sd.c. i.e. both places where
a choice is made to use the 6 or 10 byte versions of READ/WRITE.

3) Actually make use of the ADEV_NOTUR (No TEST UNIT READY) quirk to
suppress the emission of TEST UNIT READY commands.

4) Add some explanatory comments from NetBSD to scsiconf.h so that the
use of the quirks is made clear.

ok miod@@ tdeval@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.58 2003/05/06 11:40:34 krw Exp $	*/
d127 1
a127 1
struct scsi_inquiry_pattern sd_patterns[] = {
d158 1
a158 1
	    (caddr_t)sd_patterns, sizeof(sd_patterns)/sizeof(sd_patterns[0]),
@


1.58
log
@sprintf -> snprintf. strncpy -> bcopy since d_packname is not really a
string.

Ensure that all of d_packname is used by not null-terminating string
that is put in it.

Suggestions and motivation to remove strncpy() from deraadt@@.

ok deraadt@@ tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.57 2003/04/06 03:02:44 krw Exp $	*/
d205 1
a205 1
		sc_link->quirks |= SDEV_NOCDB6;
d702 1
a702 1
		    !(sc_link->quirks & SDEV_NOCDB6) && 
@


1.57
log
@The disklabel fields d_packname and d_typename are not null terminated strings
and should not be created or used as such.

This fixes some instances of both behaviours, and sets the stage for some
strcpy -> strncpy fixup.

ok tdeval@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.56 2002/12/30 21:50:29 grange Exp $	*/
d982 2
a983 1
	char *errstring;
d1006 18
a1023 7
	if (strlen(sd->name.vendor) + strlen(sd->name.product) + 1 <
	    sizeof(lp->d_packname))
		sprintf(lp->d_packname, "%s %s", sd->name.vendor,
		    sd->name.product);
	else
		strncpy(lp->d_packname, sd->name.product,
		    sizeof(lp->d_packname));
@


1.56
log
@Add new parameter to scsi_test_unit_ready(): retries number.
Use increased retries number and don't ignore SCSI_IGNORE_NOT_READY
when call scsi_test_unit_ready() for cd-rom, this makes system wait
if drive is loading media.
Tested by millert@@ and fgsch@@; some input and ok from krw@@.
Problem reported by The lord of the CD-writers
Igor Grabin <violent@@death.kiev.ua>.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.55 2002/09/04 23:07:28 tdeval Exp $	*/
d1000 1
a1000 1
		    sizeof(lp->d_typename) - 1);
d1003 1
a1003 1
		    sizeof(lp->d_typename) - 1);
d1011 1
a1011 1
		    sizeof(lp->d_packname) - 1);
@


1.55
log
@Add support for RBC (simplified direct) devices.
ok costa@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.54 2002/08/12 06:59:46 fgsch Exp $	*/
d393 1
@


1.54
log
@initialize part earlier in case of debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.53 2002/06/09 00:05:57 art Exp $	*/
d132 4
d203 3
@


1.53
log
@More (the last round?) of splasserts and splbio around biodone.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.52 2002/03/14 01:27:13 millert Exp $	*/
d363 1
a425 2

	part = SDPART(dev);
@


1.52
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.51 2001/10/08 01:50:48 drahn Exp $	*/
d599 1
d601 1
a601 1

d637 3
@


1.51
log
@Add a new quirk type, SDEV_NOCDB6, some USB devices like ATAPI
do not support 6 byte CDBs.
This quirk is used for OLYMPUS USB cameras.
Loosely based on code in FreeBSD.
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.50 2001/08/26 00:45:08 fgsch Exp $	*/
d92 14
a105 14
int	sdmatch __P((struct device *, void *, void *));
void	sdattach __P((struct device *, struct device *, void *));
int	sdactivate __P((struct device *, enum devact));
int	sddetach __P((struct device *, int));
void	sdzeroref __P((struct device *));

void	sdminphys __P((struct buf *));
void	sdgetdisklabel __P((dev_t, struct sd_softc *, struct disklabel *,
			    struct cpu_disklabel *, int));
void	sdstart __P((void *));
void	sddone __P((struct scsi_xfer *));
void	sd_shutdown __P((void *));
int	sd_reassign_blocks __P((struct sd_softc *, u_long));
int	sd_interpret_sense __P((struct scsi_xfer *));
d107 1
a107 1
void	viscpy __P((u_char *, u_char *, int));
@


1.51.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.51 2001/10/08 01:50:48 drahn Exp $	*/
d92 14
a105 14
int	sdmatch(struct device *, void *, void *);
void	sdattach(struct device *, struct device *, void *);
int	sdactivate(struct device *, enum devact);
int	sddetach(struct device *, int);
void	sdzeroref(struct device *);

void	sdminphys(struct buf *);
void	sdgetdisklabel(dev_t, struct sd_softc *, struct disklabel *,
			    struct cpu_disklabel *, int);
void	sdstart(void *);
void	sddone(struct scsi_xfer *);
void	sd_shutdown(void *);
int	sd_reassign_blocks(struct sd_softc *, u_long);
int	sd_interpret_sense(struct scsi_xfer *);
d107 1
a107 1
void	viscpy(u_char *, u_char *, int);
a598 1
	s = splbio();
d600 1
a600 1
	splx(s);
a635 3

	splassert(IPL_BIO);

@


1.51.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.51.4.1 2002/06/11 03:32:14 art Exp $	*/
a131 4
	{T_RDIRECT, T_FIXED,
	 "",         "",                 ""},
	{T_RDIRECT, T_REMOV,
	 "",         "",                 ""},
a199 3
	if (!(sc_link->inquiry_flags & SID_RelAdr))
		sc_link->quirks |= SDEV_NOCDB6;

a362 1
	part = SDPART(dev);
d425 2
@


1.51.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d205 1
a205 1
		sc_link->quirks |= SDEV_ONLYBIG;
a392 1
		    TEST_READY_RETRIES_DEFAULT,
d701 1
a701 1
		    !(sc_link->quirks & SDEV_ONLYBIG) && 
d981 1
a981 2
	size_t len;
	char *errstring, packname[sizeof(lp->d_packname) + 1];
d999 1
a999 1
		    sizeof(lp->d_typename));
d1002 1
a1002 1
		    sizeof(lp->d_typename));
d1004 7
a1010 18
	/*
	 * Try to fit '<vendor> <product>' into d_packname. If that doesn't fit
	 * then leave out '<vendor> ' and use only as much of '<product>' as
	 * does fit.
	 */
	len = snprintf(packname, sizeof(packname), "%s %s",
	    sd->name.vendor, sd->name.product);
	if (len > sizeof(lp->d_packname)) {
		strlcpy(packname, sd->name.product, sizeof(packname));
		len = strlen(packname);
	}
	/*
	 * It is safe to use len as the count of characters to copy because
	 * packname is sizeof(lp->d_packname)+1, the string in packname is
	 * always null terminated and len does not count the terminating null.
	 * d_packname is not a null terminated string.
	 */
	bcopy(packname, lp->d_packname, len);
@


1.50
log
@remove useless INUSE references from scsi_xfer->flags; art@@ miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.49 2001/08/06 20:50:25 miod Exp $	*/
d691 1
@


1.49
log
@Remove legacy __BDEVSW_DUMP_OLD_TYPE code.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.48 2001/06/22 14:35:43 deraadt Exp $	*/
d1257 1
a1257 1
		xs->flags |= SCSI_AUTOCONF | INUSE | SCSI_DATA_OUT;
@


1.48
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.47 2000/12/13 15:33:24 mickey Exp $	*/
a1167 1
#ifndef __BDEVSW_DUMP_OLD_TYPE
a1288 13
#else	/* __BDEVSW_DUMP_OLD_TYPE */
int
sddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{

	/* Not implemented. */
	return ENXIO;
}
#endif	/* __BDEVSW_DUMP_OLD_TYPE */
@


1.47
log
@move back to unlimitted openings
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.46 2000/10/13 17:55:00 mickey Exp $	*/
d385 3
a387 3
					     SCSI_IGNORE_ILLEGAL_REQUEST |
					     SCSI_IGNORE_MEDIA_CHANGE |
					     SCSI_IGNORE_NOT_READY);
d394 2
a395 3
					   SCSI_IGNORE_ILLEGAL_REQUEST |
					   SCSI_IGNORE_MEDIA_CHANGE |
					   SCSI_SILENT);
d404 1
a404 2
				     SCSI_IGNORE_ILLEGAL_REQUEST |
				     SCSI_IGNORE_MEDIA_CHANGE);
d431 1
a431 1
	     sd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
d681 2
a682 2
		     p = &sd->sc_dk.dk_label->d_partitions[SDPART(bp->b_dev)];
		     blkno += p->p_offset;
@


1.46
log
@Matthew Jacob <mjacob@@feral.com>:
Mickey did the right thing, but we'll have to figure out what that broke as
well.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.45 2000/09/21 17:57:19 mickey Exp $	*/
a84 4
#ifndef	SDOUTSTANDING
#define	SDOUTSTANDING	4
#endif

a182 2
	if (sc_link->openings > SDOUTSTANDING)
		sc_link->openings = SDOUTSTANDING;
@


1.45
log
@do not limit openings to defined SDOUTSTANDING value of 4, since many controllers can do more; presumably all the cotrollers initialize openings to the right value; also replace some spaces w/ tabs
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.44 2000/09/20 00:58:03 mickey Exp $	*/
d85 4
d187 2
@


1.44
log
@make SDOUTSTANDING redefinable, since some controller can handle more than 4 xfers simultaneously; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.43 2000/04/18 05:53:17 csapuntz Exp $	*/
a84 4
#ifndef	SDOUTSTANDING
#define	SDOUTSTANDING	4
#endif

d86 1
a86 1
#define SDMINOR(unit, part)             DISKMINOR(unit, part)
d94 3
a96 3
int     sdactivate __P((struct device *, enum devact));
int     sddetach __P((struct device *, int));
void    sdzeroref __P((struct device *));
d103 1
a103 1
void    sd_shutdown __P((void *));
a182 2
	if (sc_link->openings > SDOUTSTANDING)
		sc_link->openings = SDOUTSTANDING;
d203 1
a203 1
	if (!(sc_link->flags & SDEV_ATAPI) && 
d235 3
a237 3
                printf("%ldMB, %d cyl, %d head, %d sec, %d bytes/sec, %ld sec total",
                    dp->disksize / (1048576 / dp->blksize), dp->cyls,
                    dp->heads, dp->sectors, dp->blksize, dp->disksize);
d272 2
a273 2
        struct device *self;
        enum devact act;
d275 5
a279 1
        int rv = 0;
d281 7
a287 11
        switch (act) {
        case DVACT_ACTIVATE:
                break;

        case DVACT_DEACTIVATE:
                /*
                 * Nothing to do; we key off the device's DVF_ACTIVATE.
                 */
                break;
        }
        return (rv);
d293 2
a294 2
        struct device *self;
        int flags;
d296 3
a298 3
        struct sd_softc *sc = (struct sd_softc *)self;
        struct buf *dp, *bp;
        int s, bmaj, cmaj, mn;
d304 1
a304 1
		
d311 2
a312 2
        /* locate the major number */
        mn = SDMINOR(self->dv_unit, 0);
d314 2
a315 2
        for (bmaj = 0; bmaj < nblkdev; bmaj++)
                if (bdevsw[bmaj].d_open == sdopen)
d317 2
a318 2
        for (cmaj = 0; cmaj < nchrdev; cmaj++)
                if (cdevsw[cmaj].d_open == sdopen)
d326 2
a327 2
        /* Unhook the entropy source. */
        rnd_detach_source(&sc->rnd_source);
d330 1
a330 1
        return (0);
d335 1
a335 1
        struct device *self;
d337 1
a337 1
        struct sd_softc *sd = (struct sd_softc *)self;
d339 2
a340 2
        /* Detach disk. */
        disk_detach(&sd->sc_dk);
d474 1
a474 1
int 
d511 1
a511 1
		    scsi_start(sd->sc_link, SSS_STOP|SSS_LOEJ, 0);
d513 1
a513 1
		    sd->sc_link->flags &= ~SDEV_EJECTING;
d623 1
a623 1
void 
@


1.43
log
@

sd and scsibus detach

cdlock/cdunlock now through disk_lock/disk_unlock
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.42 2000/04/08 19:19:33 csapuntz Exp $	*/
d85 1
d87 1
@


1.42
log
@

These days, attach can occur outside the tsleep-restricted world of
BSD autoconf.

Don't use POLL & NOSLEEP mode if attaching after autoconf
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.41 1999/12/05 02:49:17 deraadt Exp $	*/
d83 2
d88 1
d96 4
a99 2
int	sdlock __P((struct sd_softc *));
void	sdunlock __P((struct sd_softc *));
d112 2
a113 1
	sizeof(struct sd_softc), sdmatch, sdattach
d143 4
a259 1
#ifdef notyet
a271 1
#endif
a273 6
/*
 * Wait interruptibly for an exclusive lock.
 *
 * XXX
 * Several drivers do this; it should be abstracted and made MP-safe.
 */
d275 24
a298 2
sdlock(sd)
	struct sd_softc *sd;
d300 3
a302 1
	int error;
d304 8
a311 4
	while ((sd->flags & SDF_LOCKED) != 0) {
		sd->flags |= SDF_WANTED;
		if ((error = tsleep(sd, PRIBIO | PCATCH, "sdlck", 0)) != 0)
			return error;
d313 22
a334 2
	sd->flags |= SDF_LOCKED;
	return 0;
a336 3
/*
 * Unlock and wake up any waiters.
 */
d338 2
a339 2
sdunlock(sd)
	struct sd_softc *sd;
d341 1
d343 2
a344 5
	sd->flags &= ~SDF_LOCKED;
	if ((sd->flags & SDF_WANTED) != 0) {
		sd->flags &= ~SDF_WANTED;
		wakeup(sd);
	}
d362 2
a363 4
	if (unit >= sd_cd.cd_ndevs)
		return ENXIO;
	sd = sd_cd.cd_devs[unit];
	if (!sd)
d372 2
a373 1
	if ((error = sdlock(sd)) != 0)
d375 1
d455 1
d470 1
d484 1
a484 1
	struct sd_softc *sd = sd_cd.cd_devs[SDUNIT(dev)];
d488 4
d522 1
d535 1
a535 1
	struct sd_softc *sd = sd_cd.cd_devs[SDUNIT(bp->b_dev)];
d538 6
d594 2
d606 3
d768 1
a768 1
	struct sd_softc *sd = sd_cd.cd_devs[SDUNIT(bp->b_dev)];
d771 4
d794 2
d830 2
a831 2
	struct sd_softc *sd = sd_cd.cd_devs[SDUNIT(dev)];
	int error;
d834 4
d856 7
a862 4
			if ((sd->sc_link->flags & SDEV_OPEN) == 0)
				return (ENODEV);
			else
				return (EIO);
d870 1
a870 1
		return 0;
d876 1
a876 1
			return 0;
d881 1
a881 1
		return 0;
d887 1
a887 1
		return 0;
d891 4
a894 2
		if ((flag & FWRITE) == 0)
			return EBADF;
d897 1
a897 1
			return error;
d912 1
a912 1
		return error;
d915 4
a918 2
		if ((flag & FWRITE) == 0)
			return EBADF;
d923 1
a923 1
		return 0;
d926 1
a926 1
		return scsi_prevent(sd->sc_link,
d928 1
d931 4
a934 2
		if (((struct mtop *)addr)->mt_op != MTOFFL)
			return EIO;
d937 4
a940 2
		if ((sd->sc_link->flags & SDEV_REMOVABLE) == 0)
			return ENOTTY;
d942 1
a942 1
		return 0;
d945 4
a948 2
		if ((flag & FWRITE) == 0)
			return EBADF;
d950 1
a950 1
		return error;
d953 5
a957 3
		if (part != RAW_PART)
			return ENOTTY;
		return scsi_do_ioctl(sd->sc_link, dev, cmd, addr, flag, p);
d960 3
a962 3
#ifdef DIAGNOSTIC
	panic("sdioctl: impossible");
#endif
d1145 1
a1145 1
	int part, unit, omask;
d1148 1
a1148 4
	unit = SDUNIT(dev);
	if (unit >= sd_cd.cd_ndevs)
		return -1;
	sd = sd_cd.cd_devs[unit];
d1155 4
a1158 2
	if (omask == 0 && sdopen(dev, 0, S_IFBLK, NULL) != 0)
		return -1;
d1167 4
a1170 1
		return -1;
@


1.41
log
@correct printout labels
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.40 1999/08/24 01:20:22 csapuntz Exp $	*/
d210 1
a210 1
				   SCSI_AUTOCONF | SCSI_IGNORE_ILLEGAL_REQUEST |
d224 1
a224 1
		    SCSI_AUTOCONF);
@


1.41.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.47 2000/12/13 15:33:24 mickey Exp $	*/
d83 1
a83 1
#include <sys/vnode.h>
a85 1
#define	SDMINOR(unit, part)		DISKMINOR(unit, part)
d93 2
a94 4
int	sdactivate __P((struct device *, enum devact));
int	sddetach __P((struct device *, int));
void	sdzeroref __P((struct device *));

d100 1
a100 1
void	sd_shutdown __P((void *));
d107 1
a107 2
	sizeof(struct sd_softc), sdmatch, sdattach,
	sddetach, sdactivate, sdzeroref
a136 4
#define sdlock(softc)   disk_lock(&(softc)->sc_dk)
#define sdunlock(softc) disk_unlock(&(softc)->sc_dk)
#define sdlookup(unit) (struct sd_softc *)device_lookup(&sd_cd, (unit))

d175 2
d197 1
a197 1
	if (!(sc_link->flags & SDEV_ATAPI) &&
d210 1
a210 1
				   scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST |
d224 1
a224 1
		    scsi_autoconf);
d229 3
a231 3
		printf("%ldMB, %d cyl, %d head, %d sec, %d bytes/sec, %ld sec total",
		    dp->disksize / (1048576 / dp->blksize), dp->cyls,
		    dp->heads, dp->sectors, dp->blksize, dp->disksize);
d250 1
d263 1
d266 6
d273 2
a274 3
sdactivate(self, act)
	struct device *self;
	enum devact act;
d276 1
a276 5
	int rv = 0;

	switch (act) {
	case DVACT_ACTIVATE:
		break;
d278 4
a281 5
	case DVACT_DEACTIVATE:
		/*
		 * Nothing to do; we key off the device's DVF_ACTIVATE.
		 */
		break;
d283 2
a284 1
	return (rv);
d287 6
a292 5

int
sddetach(self, flags)
	struct device *self;
	int flags;
a293 3
	struct sd_softc *sc = (struct sd_softc *)self;
	struct buf *dp, *bp;
	int s, bmaj, cmaj, mn;
d295 4
a298 8
	/* Remove unprocessed buffers from queue */
	s = splbio();
	for (dp = &sc->buf_queue; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;

		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		biodone(bp);
a299 32
	splx(s);

	/* locate the major number */
	mn = SDMINOR(self->dv_unit, 0);

	for (bmaj = 0; bmaj < nblkdev; bmaj++)
		if (bdevsw[bmaj].d_open == sdopen)
			vdevgone(bmaj, mn, mn + MAXPARTITIONS - 1, VBLK);
	for (cmaj = 0; cmaj < nchrdev; cmaj++)
		if (cdevsw[cmaj].d_open == sdopen)
			vdevgone(cmaj, mn, mn + MAXPARTITIONS - 1, VCHR);

	/* Get rid of the shutdown hook. */
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);

#if NRND > 0
	/* Unhook the entropy source. */
	rnd_detach_source(&sc->rnd_source);
#endif

	return (0);
}

void
sdzeroref(self)
	struct device *self;
{
	struct sd_softc *sd = (struct sd_softc *)self;

	/* Detach disk. */
	disk_detach(&sd->sc_dk);
d317 4
a320 2
	sd = sdlookup(unit);
	if (sd == NULL)
d329 1
a329 2
	if ((error = sdlock(sd)) != 0) {
		device_unref(&sd->sc_dev);
a330 1
	}
a409 1
	device_unref(&sd->sc_dev);
a423 1
	device_unref(&sd->sc_dev);
d431 1
a431 1
int
d437 1
a437 1
	struct sd_softc *sd;
a440 4
	sd = sdlookup(SDUNIT(dev));
	if (sd == NULL)
		return ENXIO;

d464 1
a464 1
			scsi_start(sd->sc_link, SSS_STOP|SSS_LOEJ, 0);
d466 1
a466 1
			sd->sc_link->flags &= ~SDEV_EJECTING;
a470 1
	device_unref(&sd->sc_dev);
d483 1
a483 1
	struct sd_softc *sd;
a485 6
	sd = sdlookup(SDUNIT(bp->b_dev));
	if (sd == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}

a535 2

	device_unref(&sd->sc_dev);
a545 3

	if (sd != NULL)
		device_unref(&sd->sc_dev);
d564 1
a564 1
void
d705 1
a705 1
	struct sd_softc *sd;
a707 4
	sd = sdlookup(SDUNIT(bp->b_dev));
	if (sd == NULL)
		return;  /* XXX - right way to fail this? */

a726 2

	device_unref(&sd->sc_dev);
d761 2
a762 2
	struct sd_softc *sd;
	int error = 0;
a764 4
	sd = sdlookup(SDUNIT(dev));
	if (sd == NULL)
		return ENXIO;

d783 4
a786 7
			if ((sd->sc_link->flags & SDEV_OPEN) == 0) {
				error = ENODEV;
				goto exit;
			} else {
				error = EIO;
				goto exit;
			}
d794 1
a794 1
		goto exit;
d800 1
a800 1
			goto exit;
d805 1
a805 1
		goto exit;
d811 1
a811 1
		goto exit;
d815 2
a816 4
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}
d819 1
a819 1
			goto exit;
d834 1
a834 1
		goto exit;
d837 2
a838 4
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}
d843 1
a843 1
		goto exit;
d846 1
a846 1
		error = scsi_prevent(sd->sc_link,
a847 1
		goto exit;
d850 2
a851 4
		if (((struct mtop *)addr)->mt_op != MTOFFL) {
			error = EIO;
			goto exit;
		}
d854 2
a855 4
		if ((sd->sc_link->flags & SDEV_REMOVABLE) == 0) {
			error = ENOTTY;
			goto exit;
		}
d857 1
a857 1
		goto exit;
d860 2
a861 4
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			goto exit;
		}
d863 1
a863 1
		goto exit;
d866 3
a868 5
		if (part != RAW_PART) {
			error = ENOTTY;
			goto exit;
		}
		error = scsi_do_ioctl(sd->sc_link, dev, cmd, addr, flag, p);
d871 3
a873 3
 exit:
	device_unref(&sd->sc_dev);
	return (error);
d1056 1
a1056 1
	int part, omask;
d1059 4
a1062 1
	sd = sdlookup(SDUNIT(dev));
d1069 2
a1070 4
	if (omask == 0 && sdopen(dev, 0, S_IFBLK, NULL) != 0) {
		size = -1;
		goto exit;
	}
d1079 1
a1079 4
		size = -1;

 exit:
	device_unref(&sd->sc_dev);
@


1.41.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.41.2.1 2001/05/14 22:44:59 niklas Exp $	*/
d385 3
a387 3
		    SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE |
		    SCSI_IGNORE_NOT_READY);
d394 3
a396 2
			    SCSI_IGNORE_ILLEGAL_REQUEST |
			    SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT);
d405 2
a406 1
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
d433 1
a433 1
	    sd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
d683 2
a684 2
			p = &sd->sc_dk.dk_label->d_partitions[SDPART(bp->b_dev)];
			blkno += p->p_offset;
@


1.41.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.41.2.2 2001/07/04 11:00:07 niklas Exp $	*/
a690 1
		    !(sc_link->quirks & SDEV_NOCDB6) && 
d1168 1
d1258 1
a1258 1
		xs->flags |= SCSI_AUTOCONF | SCSI_DATA_OUT;
d1290 13
@


1.41.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 14
a105 14
int	sdmatch(struct device *, void *, void *);
void	sdattach(struct device *, struct device *, void *);
int	sdactivate(struct device *, enum devact);
int	sddetach(struct device *, int);
void	sdzeroref(struct device *);

void	sdminphys(struct buf *);
void	sdgetdisklabel(dev_t, struct sd_softc *, struct disklabel *,
			    struct cpu_disklabel *, int);
void	sdstart(void *);
void	sddone(struct scsi_xfer *);
void	sd_shutdown(void *);
int	sd_reassign_blocks(struct sd_softc *, u_long);
int	sd_interpret_sense(struct scsi_xfer *);
d107 1
a107 1
void	viscpy(u_char *, u_char *, int);
@


1.41.2.5
log
@Sync the SMP branch with 3.3
@
text
@a131 4
	{T_RDIRECT, T_FIXED,
	 "",         "",                 ""},
	{T_RDIRECT, T_REMOV,
	 "",         "",                 ""},
a199 3
	if (!(sc_link->inquiry_flags & SID_RelAdr))
		sc_link->quirks |= SDEV_NOCDB6;

a362 1
	part = SDPART(dev);
a384 1
		    TEST_READY_RETRIES_DEFAULT,
d426 2
a598 1
	s = splbio();
d600 1
a600 1
	splx(s);
a635 3

	splassert(IPL_BIO);

@


1.41.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.41.2.5 2003/03/28 00:08:47 niklas Exp $	*/
d982 1
a982 2
	size_t len;
	char *errstring, packname[sizeof(lp->d_packname) + 1];
d1000 1
a1000 1
		    sizeof(lp->d_typename));
d1003 1
a1003 1
		    sizeof(lp->d_typename));
d1005 7
a1011 18
	/*
	 * Try to fit '<vendor> <product>' into d_packname. If that doesn't fit
	 * then leave out '<vendor> ' and use only as much of '<product>' as
	 * does fit.
	 */
	len = snprintf(packname, sizeof(packname), "%s %s",
	    sd->name.vendor, sd->name.product);
	if (len > sizeof(lp->d_packname)) {
		strlcpy(packname, sd->name.product, sizeof(packname));
		len = strlen(packname);
	}
	/*
	 * It is safe to use len as the count of characters to copy because
	 * packname is sizeof(lp->d_packname)+1, the string in packname is
	 * always null terminated and len does not count the terminating null.
	 * d_packname is not a null terminated string.
	 */
	bcopy(packname, lp->d_packname, len);
@


1.41.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.41.2.6 2003/05/13 19:36:57 ho Exp $	*/
d127 1
a127 1
const struct scsi_inquiry_pattern sd_patterns[] = {
d158 1
a158 1
	    sd_patterns, sizeof(sd_patterns)/sizeof(sd_patterns[0]),
d205 1
a205 1
		sc_link->quirks |= SDEV_ONLYBIG;
d237 1
a237 1
		    scsi_autoconf | SCSI_IGNORE_MEDIA_CHANGE);
d702 1
a702 1
		    !(sc_link->quirks & SDEV_ONLYBIG) && 
@


1.41.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d237 1
a237 1
		    scsi_autoconf | SCSI_SILENT | SCSI_IGNORE_MEDIA_CHANGE);
d242 1
a242 1
		printf("%luMB, %lu cyl, %lu head, %lu sec, %lu bytes/sec, %lu sec total",
d412 4
a415 7
		if ((sc_link->flags & SDEV_REMOVABLE) != 0) {
			error = scsi_prevent(sc_link, PR_PREVENT,
			    SCSI_IGNORE_ILLEGAL_REQUEST |
			        SCSI_IGNORE_MEDIA_CHANGE);
			if (error)
				goto bad;
		}
a463 1
	    if ((sd->sc_link->flags & SDEV_REMOVABLE) != 0)
d465 2
a466 3
		    SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE);
	    sc_link->flags &= ~SDEV_OPEN;
d511 2
a512 3
		if ((sd->sc_link->flags & SDEV_REMOVABLE) != 0)
			scsi_prevent(sd->sc_link, PR_ALLOW,
			    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY);
d1026 1
a1026 1
	lp->d_rpm = sd->params.rot_rate;
@


1.41.2.9
log
@Merge with the trunk
@
text
@d178 1
a178 1
	SC_DEBUG(sc_link, SDEV_DB2, ("sdattach:\n"));
d221 6
a226 3
	error = scsi_test_unit_ready(sd->sc_link, TEST_READY_RETRIES_DEFAULT,
	    scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST |
	    SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT);
d395 4
a398 1
		    SCSI_IGNORE_MEDIA_CHANGE);
d401 7
a407 5
		if (error == EIO)
			error = scsi_start(sc_link, SSS_START, 0);

		if (error)
			goto bad3;
d429 1
a429 1
			SC_DEBUG(sc_link, SDEV_DB3, ("Params loaded\n"));
d434 1
a434 1
			SC_DEBUG(sc_link, SDEV_DB3, ("Disklabel loaded\n"));
d551 3
a553 2
	SC_DEBUG(sd->sc_link, SDEV_DB2, ("sdstrategy: %ld bytes @@ blk %d\n",
	    bp->b_bcount, bp->b_blkno));
d649 1
a649 1
	SC_DEBUG(sc_link, SDEV_DB2, ("sdstart\n"));
d754 1
a754 1
			disk_unbusy(&sd->sc_dk, 0, 0);
d773 1
a773 2
		disk_unbusy(&sd->sc_dk, (xs->bp->b_bcount - xs->bp->b_resid),
		    (xs->bp->b_flags & B_READ));
d850 1
a850 1
	SC_DEBUG(sd->sc_link, SDEV_DB2, ("sdioctl 0x%lx\n", cmd));
d1107 1
a1108 1
	struct scsi_link *sc_link = xs->sc_link;
d1110 1
a1110 2
	u_int8_t serr = sense->error_code & SSD_ERRCODE;
	int retval;
d1113 1
a1113 2
	 * Let the generic code handle everything except a few categories of
	 * LUN not ready errors on open devices.
d1115 17
a1131 19
	if (((sc_link->flags & SDEV_OPEN) == 0) ||
	    (serr != 0x70 && serr != 0x71) ||
	    ((sense->flags & SSD_KEY) != SKEY_NOT_READY) ||
	    (sense->extra_len < 6) ||
	    (sense->add_sense_code != 0x04))
		return (EJUSTRETURN);

	switch (sense->add_sense_code_qual) {
	case 0x01:
		printf("%s: ..is spinning up...waiting\n", sd->sc_dev.dv_xname);
		/*
		 * I really need a sdrestart function I can call here.
		 */
		delay(1000000 * 5);	/* 5 seconds */
		retval = ERESTART;
		break;
	case 0x02:
		if (sd->sc_link->flags & SDEV_REMOVABLE) {
			printf("%s: removable disk stopped - not restarting\n",
d1133 11
a1143 8
			retval = EIO;
		} else {
			printf("%s: respinning up disk\n", sd->sc_dev.dv_xname);
			retval = scsi_start(sd->sc_link, SSS_START,
			    SCSI_URGENT | SCSI_NOSLEEP);
			if (retval != 0) {
				printf("%s: respin of disk failed - %d\n",
				    sd->sc_dev.dv_xname, retval);
d1146 12
a1157 1
				retval = ERESTART;
a1159 4
		break;
	default:
		retval = EJUSTRETURN;
		break;
a1160 1

@


1.40
log
@

Added type field to scsi_addr to reflect bus/device type (ATAPI or SCSI).
Updated ioctls to match

Minor patches in anticipation of wd->sd translation layer
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.39 1999/08/10 23:09:49 deraadt Exp $	*/
a206 1
	printf("%s: ", sd->sc_dev.dv_xname);
d226 1
@


1.39
log
@support DIOCRLDINFO
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.38 1999/07/25 11:13:08 deraadt Exp $	*/
d187 2
a188 1
	if (sc_link->flags & SDEV_ATAPI) {
d776 1
@


1.38
log
@gets even worse..
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.37 1999/07/25 11:12:32 deraadt Exp $	*/
d789 4
@


1.37
log
@another costa bug.. erk
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.36 1999/07/25 07:09:19 csapuntz Exp $	*/
d228 1
a228 1
                printf("%ldMB, %d cyl, %d head, %d sec, %d bytes/sec, %ld sec total\n",
a230 1

@


1.36
log
@

Merge sd stuff from NetBSD-current. Helps with LS-120, ZIP

More SCSI logic from NetBSD-current

Some tape fixes. ATAPI tapes do not work yet for most operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.35 1999/07/23 06:17:09 deraadt Exp $	*/
d228 1
a228 2
                printf("%ldMB, %d cyl, %d head, %d sec, %d bytes/sec, %ld sec to
tal\n",
@


1.35
log
@use READ_BIG for atapi; LS-120 works now
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.34 1999/07/22 23:06:51 deraadt Exp $	*/
d4 6
a9 2
/*
 * Copyright (c) 1994, 1995, 1997 Charles M. Hannum.  All rights reserved.
d21 5
a25 3
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d27 11
a37 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d79 1
a83 1
#define	SDRETRIES	4
a90 33
struct sd_softc {
	struct device sc_dev;
	struct disk sc_dk;

	int flags;
#define	SDF_LOCKED	0x01
#define	SDF_WANTED	0x02
#define	SDF_WLABEL	0x04		/* label is writable */
#define	SDF_LABELLING	0x08		/* writing label */
#define	SDF_ANCIENT	0x10		/* disk is ancient; for minphys */
	struct scsi_link *sc_link;	/* contains our targ, lun, etc. */
	struct disk_parms {
		u_char heads;		/* number of heads */
		u_short cyls;		/* number of cylinders */
		u_char sectors;		/* number of sectors/track */
		int blksize;		/* number of bytes/sector */
		u_long disksize;	/* total number sectors */
	} params;
	struct disk_name {
		char vendor[9];		/* disk vendor/manufacturer */
		char product[17];	/* disk product model */
		char revision[5];	/* drive/firmware revision */
	} name;
	struct buf buf_queue;
	u_int8_t type;
};

struct scsi_mode_sense_data {
	struct scsi_mode_header header;
	struct scsi_blk_desc blk_desc;
	union disk_pages pages;
};

d100 1
d102 2
a103 4
int	sd_get_optparms __P((struct sd_softc *, int, struct disk_parms *));
int	sd_get_parms __P((struct sd_softc *, int));
static	int sd_mode_sense __P((struct sd_softc *, struct scsi_mode_sense_data *,
			      int, int));
d117 1
a117 1
	NULL,			/* Use default error handler */
d134 3
d160 1
a160 1
	int error;
d187 6
d196 2
a197 1
	if ((sa->sa_inqbuf->version & SID_ANSII) == 0)
d220 28
a247 11
	if (error || sd_get_parms(sd, SCSI_AUTOCONF) != 0)
		printf("drive offline\n");
	else {
	        printf("%ld", dp->disksize / (1048576 / dp->blksize));
		if (dp->disksize < 11520)
		        printf(".%2ld",
			    dp->disksize / (1024*10 / dp->blksize) -
			    dp->disksize / (1048576 / dp->blksize) * 100);
		printf("MB, %d cyl, %d head, %d sec, %d bytes/sec, %ld sec total\n",
		    dp->cyls,
		    dp->heads, dp->sectors, dp->blksize, dp->disksize);
d249 16
d328 1
a328 1
	    sd_cd.cd_ndevs, SDPART(dev)));
d374 2
a375 1
			if (sd_get_parms(sd, 0) != 0) {
d456 3
a458 1
		/* XXX Must wait for I/O to complete! */
d501 4
a504 1
		bp->b_error = EIO;
d664 8
d693 5
d764 1
d771 18
a788 2
	if ((sd->sc_link->flags & SDEV_MEDIA_LOADED) == 0)
		return EIO;
d862 1
a862 1
		if (SDPART(dev) != RAW_PART)
d944 16
d983 6
a988 6

static int
sd_mode_sense(sd, scsi_sense, page, flags)
	struct sd_softc *sd;
	struct scsi_mode_sense_data *scsi_sense;
	int page, flags;
d990 4
a993 1
	struct scsi_mode_sense scsi_cmd;
d996 1
a996 3
	 * Make sure the sense buffer is clean before we do
	 * the mode sense, so that checks for bogus values of
	 * 0 will work in case the mode sense fails.
d998 3
a1000 1
	bzero(scsi_sense, sizeof(*scsi_sense));
a1001 4
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MODE_SENSE;
	scsi_cmd.page = page;
	scsi_cmd.length = 0x20;
d1003 2
a1004 32
	 * If the command worked, use the results to fill out
	 * the parameter structure
	 */
	return scsi_scsi_cmd(sd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)scsi_sense, sizeof(*scsi_sense),
	    SDRETRIES, 6000, NULL, flags | SCSI_DATA_IN | SCSI_SILENT);
}

int
sd_get_optparms(sd, flags, dp)
	struct sd_softc *sd;
	int flags;
	struct disk_parms *dp;
{
	struct scsi_mode_sense scsi_cmd;
	struct scsi_mode_sense_data {
		struct scsi_mode_header header;
		struct scsi_blk_desc blk_desc;
		union disk_pages pages;
	} scsi_sense;
	u_long sectors;
	int error;

	dp->blksize = DEV_BSIZE;
	if ((sectors = scsi_size(sd->sc_link, flags)) == 0)
		return 1;

	/* XXX
	 * It is better to get the following params from the
	 * mode sense page 6 only (optical device parameter page).
	 * However, there are stupid optical devices which does NOT
	 * support the page 6. Ghaa....
d1006 3
a1008 79
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MODE_SENSE;
	scsi_cmd.page = 0x3f;	/* all pages */
	scsi_cmd.length = sizeof(struct scsi_mode_header) +
	    sizeof(struct scsi_blk_desc);

	if ((error = scsi_scsi_cmd(sd->sc_link,  
	    (struct scsi_generic *)&scsi_cmd, sizeof(scsi_cmd),  
	    (u_char *)&scsi_sense, sizeof(scsi_sense), SDRETRIES,
	    6000, NULL, flags | SCSI_DATA_IN)) != 0)
		return error;

	dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
	if (dp->blksize == 0) 
		dp->blksize = DEV_BSIZE;

	/*
	 * Create a pseudo-geometry.
	 */
	dp->heads = 64;
	dp->sectors = 32;
	dp->cyls = sectors / (dp->heads * dp->sectors);
	dp->disksize = sectors;

	return 0;
}

/*
 * Get the scsi driver to send a full inquiry to the * device and use the
 * results to fill out the disk parameter structure.
 */
int
sd_get_parms(sd, flags)
	struct sd_softc *sd;
	int flags;
{
	struct disk_parms *dp = &sd->params;
	struct scsi_mode_sense_data scsi_sense;
	u_long sectors;
	int page;
	int error;

	if (sd->type == T_OPTICAL) {
		if ((error = sd_get_optparms(sd, flags, dp)) != 0)
			sd->sc_link->flags &= ~SDEV_MEDIA_LOADED;
		return error;
	}

	if ((error = sd_mode_sense(sd, &scsi_sense, page = 4, flags)) == 0) {
		SC_DEBUG(sd->sc_link, SDEV_DB3,
		    ("%d cyls, %d heads, %d precomp, %d red_write, %d land_zone\n",
		    _3btol(scsi_sense.pages.rigid_geometry.ncyl),
		    scsi_sense.pages.rigid_geometry.nheads,
		    _2btol(scsi_sense.pages.rigid_geometry.st_cyl_wp),
		    _2btol(scsi_sense.pages.rigid_geometry.st_cyl_rwc),
		    _2btol(scsi_sense.pages.rigid_geometry.land_zone)));

		/*
		 * KLUDGE!! (for zone recorded disks)
		 * give a number of sectors so that sec * trks * cyls
		 * is <= disk_size
		 * can lead to wasted space! THINK ABOUT THIS !
		 */
		dp->heads = scsi_sense.pages.rigid_geometry.nheads;
		dp->cyls = _3btol(scsi_sense.pages.rigid_geometry.ncyl);
		dp->blksize = _3btol(scsi_sense.blk_desc.blklen);

		if (dp->heads == 0 || dp->cyls == 0)
			goto fake_it;

		if (dp->blksize == 0)
			dp->blksize = DEV_BSIZE;

		sectors = scsi_size(sd->sc_link, flags);
		dp->disksize = sectors;
		sectors /= (dp->heads * dp->cyls);
		dp->sectors = sectors;	/* XXX dubious on SCSI */

		return 0;
d1011 4
a1014 22
	if ((error = sd_mode_sense(sd, &scsi_sense, page = 5, flags)) == 0) {
		dp->heads = scsi_sense.pages.flex_geometry.nheads;
		dp->cyls = _2btol(scsi_sense.pages.flex_geometry.ncyl);
		dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
		dp->sectors = scsi_sense.pages.flex_geometry.ph_sec_tr;
		dp->disksize = dp->heads * dp->cyls * dp->sectors;
		if (dp->disksize == 0)
			goto fake_it;

		if (dp->blksize == 0)
			dp->blksize = DEV_BSIZE;

		return 0;
	}

fake_it:
	if ((sd->sc_link->quirks & SDEV_NOMODESENSE) == 0) {
		if (error == 0)
			printf("%s: mode sense (%d) returned nonsense",
			    sd->sc_dev.dv_xname, page);
		else
			printf("%s: could not mode sense (4/5)",
d1016 27
a1042 1
		printf("; using fictitious geometry\n");
d1044 1
a1044 12
	/*
	 * use adaptec standard fictitious geometry
	 * this depends on which controller (e.g. 1542C is
	 * different. but we have to put SOMETHING here..)
	 */
	sectors = scsi_size(sd->sc_link, flags);
	dp->heads = 64;
	dp->sectors = 32;
	dp->cyls = sectors / (64 * 32);
	dp->blksize = DEV_BSIZE;
	dp->disksize = sectors;
	return 0;
@


1.34
log
@for drives <10MB of so, print #.##MB for the size
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.33 1999/05/09 20:41:48 weingart Exp $	*/
d612 2
a613 1
		if (((blkno & 0x1fffff) == blkno) &&
@


1.33
log
@Fix sdsize() to not call sdopen()/sdclose() unless it is needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.32 1998/10/04 01:37:55 millert Exp $	*/
d239 8
a246 3
	else
	        printf("%ldMB, %d cyl, %d head, %d sec, %d bytes/sec, %ld sec total\n",
		    dp->disksize / (1048576 / dp->blksize), dp->cyls,
d248 1
@


1.32
log
@Add DIOCGPDINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.31 1998/10/03 21:19:01 millert Exp $	*/
d1087 1
a1087 1
	int part;
d1090 2
a1091 1
	if (sdopen(dev, 0, S_IFBLK, NULL) != 0)
d1093 4
a1096 1
	sd = sd_cd.cd_devs[SDUNIT(dev)];
d1098 7
a1104 1
	if (sd->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)
d1107 3
a1109 2
		size = sd->sc_dk.dk_label->d_partitions[part].p_size;
	if (sdclose(dev, 0, S_IFBLK, NULL) != 0)
@


1.31
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.30 1998/10/01 05:11:11 millert Exp $	*/
d122 2
a123 1
void	sdgetdisklabel __P((dev_t, struct sd_softc *));
d359 2
a360 1
			sdgetdisklabel(dev, sd);
d732 8
d817 1
a817 1
sdgetdisklabel(dev, sd)
d820 3
a823 1
	struct disklabel *lp = sd->sc_dk.dk_label;
d827 1
a827 1
	bzero(sd->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));
d836 1
a836 1
		/* as long as it's not 0 - readdisklabel divides by it (?) */
d877 2
a878 2
	errstring = readdisklabel(SDLABELDEV(dev), sdstrategy, lp,
	    sd->sc_dk.dk_cpulabel, 0);
d1240 1
a1240 1
 * Copy up to len chars from src to dst, ignoring non-printables. 
d1247 1
a1247 1
	u_char *src; 
@


1.30
log
@Put vendor + model in spoofed label, not 'fictious'
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.29 1998/05/02 16:48:21 millert Exp $	*/
d866 1
a866 1
	    sd->sc_dk.dk_cpulabel);
@


1.29
log
@Set blksize to DEV_BSIZE, not 512.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.28 1998/04/25 00:38:13 millert Exp $	*/
d102 5
d128 1
a128 1
static int sd_mode_sense __P((struct sd_softc *, struct scsi_mode_sense_data *,
d130 1
d231 5
d834 9
a842 1
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname) - 1);
d1226 22
@


1.28
log
@set d_bbsize and d_sbsize in spoofed label to values correct for ffs
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.27 1998/03/27 18:40:53 millert Exp $	*/
d921 1
a921 1
	dp->blksize = 512;
d945 1
a945 1
		dp->blksize = 512;
d1002 1
a1002 1
			dp->blksize = 512;
d1022 1
a1022 1
			dp->blksize = 512;
d1046 1
a1046 1
	dp->blksize = 512;
@


1.27
log
@Fix strncpy usage and call a cdrom a cdrom in the fake label
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.26 1997/10/18 10:37:19 deraadt Exp $	*/
d73 2
d420 1
a420 1
		/* XXXX Must wait for I/O to complete! */
d828 4
@


1.26
log
@avoid "no disklabel" error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.25 1997/08/08 21:47:06 niklas Exp $	*/
d814 1
d816 2
a817 1
		strncpy(lp->d_typename, "SCSI optical", 16);
d819 3
a821 3
		strncpy(lp->d_typename, "SCSI disk", 16);
	lp->d_type = DTYPE_SCSI;
	strncpy(lp->d_packname, "fictitious", 16);
@


1.25
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.24 1997/07/26 21:07:36 millert Exp $	*/
d841 1
a841 1
		printf("%s: %s\n", sd->sc_dev.dv_xname, errstring);
@


1.24
log
@Report total number of blocks for a scsi disk since on modern drives
total sectors > cyl * head * sec/head.  Inspired by der Mouse
<mouse@@rodents.montreal.qc.ca>
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.23 1997/04/14 04:09:16 downsj Exp $	*/
d476 1
@


1.23
log
@Merge in various pieces of current NetBSD scsi code, including but not limited
to:

* New changer driver.
* Better optical support.
* Different `done' semantics.
* New quirks for SCSI QIC tape driver, SCSI floppy drives.
* Better support for SCSI-I devices.

Everybody needs to test this.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.22 1997/01/04 08:50:21 deraadt Exp $	*/
d226 1
a226 1
	        printf("%ldMB, %d cyl, %d head, %d sec, %d bytes/sec\n",
d228 1
a228 1
		    dp->heads, dp->sectors, dp->blksize);
@


1.22
log
@readdisklabel() with correct dev_t
@
text
@d1 2
a2 2
/*	$OpenBSD: sd.c,v 1.21 1996/12/11 19:08:18 deraadt Exp $	*/
/*	$NetBSD: sd.c,v 1.100.4.1 1996/06/04 23:14:08 thorpej Exp $	*/
d5 1
a5 1
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
d101 7
d117 1
a117 1
int	sddone __P((struct scsi_xfer *, int));
d119 1
d121 2
d175 1
d187 1
d215 9
a223 3
	if (scsi_start(sd->sc_link, SSS_START,
	    SCSI_AUTOCONF | SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT) ||
	    sd_get_parms(sd, SCSI_AUTOCONF) != 0)
d316 8
a323 5
		error = scsi_start(sc_link, SSS_START,
				   SCSI_IGNORE_ILLEGAL_REQUEST |
				   SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT);
		if (error)
			goto bad3;
d624 1
a624 1
		    SDRETRIES, 10000, bp, SCSI_NOSLEEP |
d634 2
a635 2
int
sddone(xs, complete)
a636 1
	int complete;
d640 1
a640 1
	if (complete && (xs->bp != NULL))
a641 2

	return (0);
d813 4
a816 1
	strncpy(lp->d_typename, "SCSI disk", 16);
d868 29
a896 4
/*
 * Get the scsi driver to send a full inquiry to the * device and use the
 * results to fill out the disk parameter structure.
 */
d898 1
a898 1
sd_get_parms(sd, flags)
d901 1
a902 1
	struct disk_parms *dp = &sd->params;
d910 1
d912 9
a920 5
	if ((sd->sc_link->quirks & SDEV_NOMODESENSE) != 0)
		goto fake_it;

	/*
	 * do a "mode sense page 4"
a921 1
	bzero(&scsi_sense, sizeof(scsi_sense));
d924 13
a936 2
	scsi_cmd.page = 4;
	scsi_cmd.length = 0x20;
d939 1
a939 2
	 * If the command worked, use the results to fill out
	 * the parameter structure
d941 30
a970 3
	if (scsi_scsi_cmd(sd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)&scsi_sense, sizeof(scsi_sense),
	    SDRETRIES, 6000, NULL, flags | SCSI_DATA_IN) == 0) {
d989 1
a989 3
		if (dp->heads == 0 || dp->cyls == 0) {
			printf("%s: mode sense (4) returned nonsense",
			    sd->sc_dev.dv_xname);
a990 1
		}
d999 1
d1001 10
a1010 24
	} else {
		/*
		 * do a "mode sense page 5"
		 */
		scsi_cmd.opcode = MODE_SENSE;
		scsi_cmd.page = 5;
		scsi_cmd.length = 0x20;
		if (scsi_scsi_cmd(sd->sc_link, (struct scsi_generic *)&scsi_cmd,
		    sizeof(scsi_cmd), (u_char *)&scsi_sense, sizeof(scsi_sense),
		    SDRETRIES, 6000, NULL,
		    flags | SCSI_DATA_IN | SCSI_SILENT) == 0) {
			dp->heads = scsi_sense.pages.flex_geometry.nheads;
			dp->cyls =
			    scsi_sense.pages.flex_geometry.ncyl_1 * 256 +
			    scsi_sense.pages.flex_geometry.ncyl_0;
			dp->blksize = _3btol(scsi_sense.blk_desc.blklen);
			dp->sectors = scsi_sense.pages.flex_geometry.ph_sec_t;
			dp->disksize = dp->heads * dp->cyls * dp->sectors;
			if (dp->heads == 0 || dp->cyls == 0
			    || dp->sectors == 0) {
				printf("%s: mode sense (5) returned nonsense",
				    sd->sc_dev.dv_xname);
				goto fake_it;
			}
d1012 2
a1013 2
			if (dp->blksize == 0)
				dp->blksize = 512;
d1015 1
a1015 3
			return 0;
		} else
			printf("%s: could not mode sense (4/5)", sd->sc_dev.dv_xname);
d1019 9
a1032 2
	if ((sd->sc_link->quirks & SDEV_NOMODESENSE) == 0)
		printf("; using fictitious geometry\n");
@


1.21
log
@b_resid cleanups, pointed out by minoura@@kw.netlaputa.or.jp in netbsd pr#3007
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.20 1996/12/03 08:08:00 deraadt Exp $	*/
d108 1
a108 1
void	sdgetdisklabel __P((struct sd_softc *));
d324 1
a324 1
			sdgetdisklabel(sd);
d775 2
a776 1
sdgetdisklabel(sd)
d816 2
a817 2
	errstring = readdisklabel(MAKESDDEV(0, sd->sc_dev.dv_unit, RAW_PART),
				  sdstrategy, lp, sd->sc_dk.dk_cpulabel);
@


1.20
log
@clear sense buffer for mode sense 4, dms@@celtech.com
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.19 1996/10/31 01:09:25 niklas Exp $	*/
d546 1
@


1.19
log
@$OpenBSD RCSIDs + comment fix in sd.c
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.18 1996/08/07 00:09:17 deraadt Exp $	*/
d869 1
@


1.18
log
@disk_unbusy if op failed to enqueue
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.17 1996/07/12 08:57:57 pefo Exp $	*/
d1106 1
a1106 1
#else	/* __BDEVSW_DUMP_NEW_TYPE */
d1118 1
a1118 1
#endif	/* __BDEVSW_DUMP_NEW_TYPE */
@


1.17
log
@Fixed wrong type of argument passing for SCIOCREASSIGN.
(thanks Theo).
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.16 1996/07/11 22:17:46 pefo Exp $	*/
d604 2
a605 1
		if (error)
d608 1
@


1.16
log
@Make use of existing SCSI block reassign code.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.15 1996/06/16 03:07:21 downsj Exp $	*/
d754 1
a754 1
		error = sd_reassign_blocks(sd, *(*(int **)addr));
@


1.15
log
@NetBSD PR#2535: add mode sense 5 and floppy support in our framework.
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.14 1996/06/10 07:31:20 deraadt Exp $	*/
d67 1
d750 6
@


1.14
log
@do not check SDEV_MEDIA_LOADED because it does not matter
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.13 1996/06/10 00:44:00 downsj Exp $	*/
d904 31
a935 3
	else
		printf("%s: could not mode sense (4)", sd->sc_dev.dv_xname);

@


1.13
log
@Several changes:
	* Implemented NetBSD PR#2529, adding ZIP 100.
	* Added MTIOCTOP support to acd, cd, and sd.
	* Implemented eject on close for acd, cd, and sd.

`mt -f /dev/rcd0d offline' now ejects a mounted {acd|cd|sd} when it is
unmounted.
@
text
@d1 2
a2 2
/*	$OpenBSD: sd.c,v 1.11 1996/05/22 11:57:30 deraadt Exp $	*/
/*	$NetBSD: sd.c,v 1.100 1996/05/14 10:38:47 leo Exp $	*/
d989 6
d998 1
@


1.12
log
@all ports have dk_establish
@
text
@d57 1
d401 6
d740 4
d745 4
a748 2
		return ((sd->sc_link->flags & SDEV_REMOVABLE) == 0 ? ENOTTY :
		    scsi_start(sd->sc_link, SSS_STOP|SSS_LOEJ, 0));
d854 3
d864 1
d871 1
a871 16
	    SDRETRIES, 6000, NULL, flags | SCSI_DATA_IN) != 0) {
		printf("%s: could not mode sense (4)", sd->sc_dev.dv_xname);
	fake_it:
		printf("; using fictitious geometry\n");
		/*
		 * use adaptec standard fictitious geometry
		 * this depends on which controller (e.g. 1542C is
		 * different. but we have to put SOMETHING here..)
		 */
		sectors = scsi_size(sd->sc_link, flags);
		dp->heads = 64;
		dp->sectors = 32;
		dp->cyls = sectors / (64 * 32);
		dp->blksize = 512;
		dp->disksize = sectors;
	} else {
d903 1
d905 3
d909 14
@


1.11
log
@unload after last close
@
text
@d1 1
a1 1
/*	$OpenBSD: sd.c,v 1.10 1996/05/10 12:31:39 deraadt Exp $	*/
d186 1
a186 3
#if !defined(i386)
	dk_establish(&sd->sc_dk, &sd->sc_dev);		/* XXX */
#endif
@


1.10
log
@SC_DEBUG cleanup
@
text
@d1 2
a2 2
/*	$OpenBSD: sd.c,v 1.7 1996/04/21 22:31:10 deraadt Exp $	*/
/*	$NetBSD: sd.c,v 1.98 1996/05/05 19:52:53 christos Exp $	*/
d401 1
a401 1
		sd->sc_link->flags &= ~SDEV_OPEN;
d505 1
a505 1
	int blkno, nblks, cmdlen;
d594 1
a594 1
		if (scsi_scsi_cmd(sc_link, cmdp, cmdlen,
d597 4
a600 2
		    ((bp->b_flags & B_READ) ? SCSI_DATA_IN : SCSI_DATA_OUT)))
			printf("%s: not queued", sd->sc_dev.dv_xname);
@


1.9
log
@from netbsd; SCSIDEBUG printf() fixes
@
text
@d2 1
a2 1
/*	$NetBSD: sd.c,v 1.97 1996/05/03 19:48:22 christos Exp $	*/
d273 2
a274 2
	    ("sdopen: dev=0x%x (unit %d (of %d))\n", dev, unit,
	    sd_cd.cd_ndevs));
@


1.8
log
@no sys/cpu.h, fix bugs in ch
@
text
@d2 1
a2 1
/*	$NetBSD: sd.c,v 1.96 1996/04/22 01:46:14 christos Exp $	*/
d273 2
a274 2
	    ("sdopen: dev=0x%x (unit %d (of %d), partition %d)\n", dev, unit,
	    sd_cd.cd_ndevs, part));
d422 1
a422 1
	    ("%d bytes @@ blk %d\n", bp->b_bcount, bp->b_blkno));
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: sd.c,v 1.6 1996/04/19 16:10:17 niklas Exp $	*/
/*	$NetBSD: sd.c,v 1.95 1996/03/30 21:45:14 christos Exp $	*/
a64 1
#include <sys/cpu.h>
@


1.6
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: sd.c,v 1.88 1996/03/05 00:15:15 thorpej Exp $	*/
d66 1
a70 1
#include <scsi/scsi_conf.h>
d72 1
a72 1
#define	SDOUTSTANDING	2
a109 1
u_long	sd_size __P((struct sd_softc *, int));
d113 6
a118 2
struct cfdriver sdcd = {
	NULL, "sd", sdmatch, sdattach, DV_DISK, sizeof(struct sd_softc)
d187 1
a187 2
	sd->sc_dk.dk_driver = &sddkdriver;
#if !defined(i386) || defined(NEWCONFIG)
d209 1
a209 1
	        printf("%dMB, %d cyl, %d head, %d sec, %d bytes/sec\n",
d265 1
a265 1
	if (unit >= sdcd.cd_ndevs)
d267 1
a267 1
	sd = sdcd.cd_devs[unit];
d275 1
a275 1
	    sdcd.cd_ndevs, part));
d380 1
a380 1
	struct sd_softc *sd = sdcd.cd_devs[SDUNIT(dev)];
d418 1
a418 1
	struct sd_softc *sd = sdcd.cd_devs[SDUNIT(bp->b_dev)];
d571 1
a571 3
			cmd_small.addr_2 = (blkno >> 16) & 0x1f;
			cmd_small.addr_1 = (blkno >> 8) & 0xff;
			cmd_small.addr_0 = blkno & 0xff;
d582 2
a583 6
			cmd_big.addr_3 = (blkno >> 24) & 0xff;
			cmd_big.addr_2 = (blkno >> 16) & 0xff;
			cmd_big.addr_1 = (blkno >> 8) & 0xff;
			cmd_big.addr_0 = blkno & 0xff;
			cmd_big.length2 = (nblks >> 8) & 0xff;
			cmd_big.length1 = nblks & 0xff;
d620 1
a620 1
	struct sd_softc *sd = sdcd.cd_devs[SDUNIT(bp->b_dev)];
d676 1
a676 1
	struct sd_softc *sd = sdcd.cd_devs[SDUNIT(dev)];
d735 1
a735 1
		return ((sd->sc_link->flags & SDEV_REMOVABLE == 0) ? ENOTTY :
a801 34
 * Find out from the device what it's capacity is
 */
u_long
sd_size(sd, flags)
	struct sd_softc *sd;
	int flags;
{
	struct scsi_read_cap_data rdcap;
	struct scsi_read_capacity scsi_cmd;
	u_long size;

	/*
	 * make up a scsi command and ask the scsi driver to do
	 * it for you.
	 */
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = READ_CAPACITY;

	/*
	 * If the command works, interpret the result as a 4 byte
	 * number of blocks
	 */
	if (scsi_scsi_cmd(sd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)&rdcap, sizeof(rdcap), SDRETRIES,
	    2000, NULL, flags | SCSI_DATA_IN) != 0)
		return 0;

	size = (rdcap.addr_3 << 24) + (rdcap.addr_2 << 16) +
	    (rdcap.addr_1 << 8) + rdcap.addr_0 + 1;

	return size;
}

/*
d805 1
a805 1
sd_reassign_blocks(sd, block)
d807 1
a807 1
	u_long block;
d816 2
a817 6
	rbdata.length_msb = 0;
	rbdata.length_lsb = sizeof(rbdata.defect_descriptor[0]);
	rbdata.defect_descriptor[0].dlbaddr_3 = (block >> 24) & 0xff;
	rbdata.defect_descriptor[0].dlbaddr_2 = (block >> 16) & 0xff;
	rbdata.defect_descriptor[0].dlbaddr_1 = (block >> 8) & 0xff;
	rbdata.defect_descriptor[0].dlbaddr_0 = block & 0xff;
a823 2
#define b2tol(a)	(((unsigned)(a##_1) << 8) + (unsigned)a##_0 )

d864 1
a864 1
		sectors = sd_size(sd, flags);
d873 1
a873 1
		    _3btol(&scsi_sense.pages.rigid_geometry.ncyl_2),
d875 3
a877 3
		    b2tol(scsi_sense.pages.rigid_geometry.st_cyl_wp),
		    b2tol(scsi_sense.pages.rigid_geometry.st_cyl_rwc),
		    b2tol(scsi_sense.pages.rigid_geometry.land_zone)));
d886 1
a886 2
		dp->cyls =
		    _3btol(&scsi_sense.pages.rigid_geometry.ncyl_2);
d898 1
a898 1
		sectors = sd_size(sd, flags);
d917 1
a917 1
	sd = sdcd.cd_devs[SDUNIT(dev)];
d967 1
a967 1
	if (unit >= sdcd.cd_ndevs || (sd = sdcd.cd_devs[unit]) == NULL)
d971 1
a971 1
	if (sd->sc_link->flags & SDEV_MEDIA_LOADED != SDEV_MEDIA_LOADED)
d1002 2
a1003 6
		cmd.addr_3 = (blkno >> 24) & 0xff;
		cmd.addr_2 = (blkno >> 16) & 0xff;
		cmd.addr_1 = (blkno >> 8) & 0xff;
		cmd.addr_0 = blkno & 0xff;
		cmd.length2 = (nwrt >> 8) & 0xff;
		cmd.length1 = nwrt & 0xff;
@


1.5
log
@Sync w/ NetBSD:
- Implement DIOCLOCK and DIOCEJECT.  DIOCEJECT is limited to removable
  media.  Fixes PR #1975.
- scsi prototypes
@
text
@d1 2
a2 1
/*	$NetBSD: sd.c,v 1.87 1996/02/14 21:47:40 christos Exp $	*/
d200 2
d205 1
a205 1
		printf(": drive offline\n");
d207 1
a207 1
	        printf(": %dMB, %d cyl, %d head, %d sec, %d bytes/sec\n",
@


1.4
log
@From NetBSD: (required for last change to scsi_base.c in case we get
	      "command aborted" status)
Handle cases like the following:
        - controller calls scsi_done() with error XS_TIMEOUT
        - scsi_done() calls sddone()
        - sddone() calls disk_unbusy()
        - scsi_done() calls controller to retry command (missing the
          call to disk_busy())
        - controller calls scsi_done()
        - scsi_done() calls sddone()
        - sddone() calls disk_busy(), which panics because of the imbalance.
Bug noticed by Leo Weppleman, who also suggested this fix; pass an additional
boolean argument ("complete") to the device's "done" routine, with a
value of `0' passed from the previous call to "done", and add an additional
call to "done" when the xfer resources are freed.
@
text
@d1 1
a1 1
/*	$NetBSD: sd.c,v 1.85 1996/01/12 22:43:33 thorpej Exp $	*/
a52 1
#include <sys/conf.h>
d63 2
d69 1
d101 11
a111 2
int sdmatch __P((struct device *, void *, void *));
void sdattach __P((struct device *, struct device *, void *));
a116 7
void sdgetdisklabel __P((struct sd_softc *));
int sd_get_parms __P((struct sd_softc *, int));
void sdstrategy __P((struct buf *));
void sdstart __P((struct sd_softc *));
int sddone __P((struct scsi_xfer *, int));
void sdminphys __P((struct buf *));

a141 1
	struct cfdata *cf = match;
d249 1
a249 1
sdopen(dev, flag, fmt)
d252 1
d272 1
a272 1
	if (error = sdlock(sd))
d286 5
a290 2
		if (error = scsi_test_unit_ready(sc_link,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE | SCSI_IGNORE_NOT_READY))
d294 4
a297 2
		if (error = scsi_start(sc_link, SSS_START,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT))
d303 4
a306 2
		if (error = scsi_prevent(sc_link, PR_PREVENT,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE))
d369 2
a370 2
int
sdclose(dev, flag, fmt)
d373 1
d379 1
a379 1
	if (error = sdlock(sd))
d490 3
a492 3
void
sdstart(sd)
	register struct sd_softc *sd;
d494 1
d646 1
a646 1
sdread(dev, uio)
d649 1
d656 1
a656 1
sdwrite(dev, uio)
d659 1
d704 1
a704 1
		if (error = sdlock(sd))
d731 8
d794 3
a796 2
	if (errstring = readdisklabel(MAKESDDEV(0, sd->sc_dev.dv_unit,
	    RAW_PART), sdstrategy, lp, sd->sc_dk.dk_cpulabel)) {
d957 1
a957 1
	if (sdopen(dev, 0, S_IFBLK) != 0)
d965 1
a965 1
	if (sdclose(dev, 0, S_IFBLK) != 0)
@


1.3
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 1
a1 1
/*	$NetBSD: sd.c,v 1.84 1996/01/07 22:04:02 thorpej Exp $	*/
d110 1
a110 1
int sddone __P((struct scsi_xfer *));
d592 1
a592 1
sddone(xs)
d594 1
d598 1
a598 1
	if (xs->bp != NULL)
@


1.2
log
@from netbsd:
If the read or write request can fit into a 6-byte cdb, then
use a 6-byte cdb, otherwise use the 10-byte as before.
In sdattach(), make a note if the device is "ancient" (i.e.
inqbuf.version & SID_ANSII == 0).
Implement sdminphys(): if the device is "ancient", shorten the
transfer so it will fit into a 6-byte cdb.

In sdminphys(), add a comment about the semantics of the "length" field
in a 6-byte read/write cdb (namely, length == 0 really means 256), and
that we handle this conservatively by limiting the transfer to 255 blocks.
*sigh* One just never knows how a pre-scsi-1 device is going to behave.

Remove a couple of now unneeded assignments.
@
text
@d1 1
a1 1
/*	$NetBSD: sd.c,v 1.83 1995/12/07 21:54:24 thorpej Exp $	*/
d80 1
a80 1
	struct dkdevice sc_dk;
d110 1
d119 1
a119 1
	NULL,			/* Use default 'done' routine */
d174 1
a174 1
	 * Note if this device is ancient.  This is used in sdminphys().
d176 3
a178 2
	if ((sa->sa_inqbuf->version & SID_ANSII) == 0)
		sd->flags |= SDF_ANCIENT;
d182 1
a182 1
	dk_establish(&sd->sc_dk, &sd->sc_dev);
d186 6
d318 2
a319 2
	    (part >= sd->sc_dk.dk_label.d_npartitions ||
	     sd->sc_dk.dk_label.d_partitions[part].p_fstype == FS_UNUSED)) {
d410 1
a410 1
	if ((bp->b_bcount % sd->sc_dk.dk_label.d_secsize) != 0) {
d432 1
a432 1
	    bounds_check_with_label(bp, &sd->sc_dk.dk_label,
d534 1
a534 1
		    bp->b_blkno / (sd->sc_dk.dk_label.d_secsize / DEV_BSIZE);
d536 2
a537 2
			p = &sd->sc_dk.dk_label.d_partitions[SDPART(bp->b_dev)];
			blkno += p->p_offset;
d539 1
a539 1
		nblks = howmany(bp->b_bcount, sd->sc_dk.dk_label.d_secsize);
d576 3
d591 12
d622 1
a622 1
		max = sd->sc_dk.dk_label.d_secsize * 0xff;
d674 1
a674 1
		*(struct disklabel *)addr = sd->sc_dk.dk_label;
d678 1
a678 1
		((struct partinfo *)addr)->disklab = &sd->sc_dk.dk_label;
d680 1
a680 1
		    &sd->sc_dk.dk_label.d_partitions[SDPART(dev)];
d692 1
a692 1
		error = setdisklabel(&sd->sc_dk.dk_label,
d694 1
a694 1
		    &sd->sc_dk.dk_cpulabel);
d698 2
a699 2
				    sdstrategy, &sd->sc_dk.dk_label,
				    &sd->sc_dk.dk_cpulabel);
d733 1
a733 1
	struct disklabel *lp = &sd->sc_dk.dk_label;
d737 1
a737 1
	bzero(&sd->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));
d771 1
a771 1
	    RAW_PART), sdstrategy, lp, &sd->sc_dk.dk_cpulabel)) {
d936 1
a936 1
	if (sd->sc_dk.dk_label.d_partitions[part].p_fstype != FS_SWAP)
d939 1
a939 1
		size = sd->sc_dk.dk_label.d_partitions[part].p_size;
d992 1
a992 1
	lp = &sd->sc_dk.dk_label;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: sd.c,v 1.80 1995/10/10 02:53:01 mycroft Exp $	*/
d87 1
d110 1
d172 6
d477 4
a480 2
	struct scsi_rw_big cmd;
	int blkno, nblks;
d534 2
a535 1
		 *  Fill out the scsi command
d537 30
a566 8
		bzero(&cmd, sizeof(cmd));
		cmd.opcode = (bp->b_flags & B_READ) ? READ_BIG : WRITE_BIG;
		cmd.addr_3 = (blkno >> 24) & 0xff;
		cmd.addr_2 = (blkno >> 16) & 0xff;
		cmd.addr_1 = (blkno >> 8) & 0xff;
		cmd.addr_0 = blkno & 0xff;
		cmd.length2 = (nblks >> 8) & 0xff;
		cmd.length1 = nblks & 0xff;
d572 2
a573 2
		if (scsi_scsi_cmd(sc_link, (struct scsi_generic *)&cmd,
		    sizeof(cmd), (u_char *)bp->b_data, bp->b_bcount,
d580 28
a612 1
	struct sd_softc *sd = sdcd.cd_devs[SDUNIT(dev)];
d614 1
a614 2
	return (physio(sdstrategy, NULL, dev, B_READ,
		       sd->sc_link->adapter->scsi_minphys, uio));
a621 1
	struct sd_softc *sd = sdcd.cd_devs[SDUNIT(dev)];
d623 1
a623 2
	return (physio(sdstrategy, NULL, dev, B_WRITE,
		       sd->sc_link->adapter->scsi_minphys, uio));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
