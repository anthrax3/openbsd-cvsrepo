head	1.23;
access;
symbols
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.23.0.10
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.6
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.23
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.22;
commitid	p4LJxGKbi0BU2cG6;

1.22
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.21;
commitid	uzzBR7hz9ncd4O6G;

1.21
date	2014.01.31.02.55.46;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2014.01.30.05.53.38;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2013.09.03.06.39.04;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2013.08.27.00.57.44;	author dlg;	state Exp;
branches;
next	1.16;

1.16
date	2013.08.27.00.53.10;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2013.08.26.12.20.12;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2013.08.26.10.50.15;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2013.08.26.10.48.58;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2013.08.26.10.13.17;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2013.08.26.07.38.56;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2013.08.26.07.29.45;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.10.03.56.43;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2013.02.04.01.27.55;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2012.03.23.13.46.47;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2011.07.11.01.02.48;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.03.15.47.18;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	2011.06.15.01.51.44;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2011.04.28.10.43.36;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.27.09.09.36;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.05.14.25.42;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: mpath_sym.c,v 1.22 2014/09/14 14:17:26 jsg Exp $ */

/*
 * Copyright (c) 2010 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/queue.h>
#include <sys/rwlock.h>
#include <sys/pool.h>
#include <sys/ioctl.h>
#include <sys/poll.h>
#include <sys/selinfo.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/mpathvar.h>

struct sym_softc {
	struct device		sc_dev;
	struct mpath_path	sc_path;
};
#define DEVNAME(_s) ((_s)->sc_dev.dv_xname)

int		sym_match(struct device *, void *, void *);
void		sym_attach(struct device *, struct device *, void *);
int		sym_detach(struct device *, int);
int		sym_activate(struct device *, int);

struct cfattach sym_ca = {
	sizeof(struct sym_softc),
	sym_match,
	sym_attach,
	sym_detach,
	sym_activate
};

struct cfdriver sym_cd = {
	NULL,
	"sym",
	DV_DULL
};

void		sym_mpath_start(struct scsi_xfer *);
int		sym_mpath_checksense(struct scsi_xfer *);
void		sym_mpath_status(struct scsi_link *);

const struct mpath_ops sym_mpath_sym_ops = {
	"sym",
	sym_mpath_checksense,
	sym_mpath_status
};

const struct mpath_ops sym_mpath_asym_ops = {
	"sym",
	sym_mpath_checksense,
	sym_mpath_status
};

struct sym_device {
	char *vendor;
	char *product;
};

struct sym_device sym_devices[] = {
/*	  " vendor "  "     device     " */
/*	  "01234567"  "0123456789012345" */
	{ "TOSHIBA ", "MBF" },
	{ "SEAGATE ", "ST" },
	{ "SGI     ", "ST" },
	{ "FUJITSU ", "MBD" },
	{ "FUJITSU ", "MA" }
};

struct sym_device asym_devices[] = {
/*	  " vendor "  "     device     " */
/*	  "01234567"  "0123456789012345" */
	{ "DELL    ", "MD1220          " },
	{ "DELL    ", "MD3060e         " },
	{ "SUN     ", "StorEdge 3510F D" },
	{ "SUNW    ", "SUNWGS INT FCBPL" },
	{ "Transtec", "PROVIGO1100" },
	{ "NetBSD", "NetBSD iSCSI" }
};

int
sym_match(struct device *parent, void *match, void *aux)
{
	struct scsi_attach_args *sa = aux;
	struct scsi_inquiry_data *inq = sa->sa_inqbuf;
	struct sym_device *s;
	int i;

	if (mpath_path_probe(sa->sa_sc_link) != 0)
		return (0);

	for (i = 0; i < nitems(sym_devices); i++) {
		s = &sym_devices[i];

		if (bcmp(s->vendor, inq->vendor, strlen(s->vendor)) == 0 &&
		    bcmp(s->product, inq->product, strlen(s->product)) == 0)
			return (8);
	}
	for (i = 0; i < nitems(asym_devices); i++) {
		s = &asym_devices[i];

		if (bcmp(s->vendor, inq->vendor, strlen(s->vendor)) == 0 &&
		    bcmp(s->product, inq->product, strlen(s->product)) == 0)
			return (8);
	}

	return (0);
}

void
sym_attach(struct device *parent, struct device *self, void *aux)
{
	struct sym_softc *sc = (struct sym_softc *)self;
	struct scsi_attach_args *sa = aux;
	struct scsi_link *link = sa->sa_sc_link;
	struct scsi_inquiry_data *inq = sa->sa_inqbuf;
	const struct mpath_ops *ops = &sym_mpath_sym_ops;
	struct sym_device *s;
	u_int id = 0;
	int i;

	printf("\n");

	/* check if we're an assymetric access device */
	for (i = 0; i < nitems(asym_devices); i++) {
		s = &asym_devices[i];

		if (bcmp(s->vendor, inq->vendor, strlen(s->vendor)) == 0 &&
		    bcmp(s->product, inq->product, strlen(s->product)) == 0) {
			ops = &sym_mpath_asym_ops;
			id = sc->sc_dev.dv_unit;
			break;
		}
	}

	/* init link */
	link->device_softc = sc;

	/* init path */
	scsi_xsh_set(&sc->sc_path.p_xsh, link, sym_mpath_start);
	sc->sc_path.p_link = link;

	if (mpath_path_attach(&sc->sc_path, id, ops) != 0)
		printf("%s: unable to attach path\n", DEVNAME(sc));
}

int
sym_detach(struct device *self, int flags)
{
	return (0);
}

int
sym_activate(struct device *self, int act)
{
	struct sym_softc *sc = (struct sym_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		if (sc->sc_path.p_group != NULL)
			mpath_path_detach(&sc->sc_path);
		break;
	}
	return (rv);
}

void
sym_mpath_start(struct scsi_xfer *xs)
{
	struct sym_softc *sc = xs->sc_link->device_softc;

	mpath_start(&sc->sc_path, xs);
}

int
sym_mpath_checksense(struct scsi_xfer *xs)
{
	return (MPATH_SENSE_DECLINED);
}

void
sym_mpath_status(struct scsi_link *link)
{
	struct sym_softc *sc = link->device_softc;

	mpath_path_status(&sc->sc_path, MPATH_S_ACTIVE);
}
@


1.22
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.21 2014/01/31 02:55:46 dlg Exp $ */
a20 1
#include <sys/buf.h>
@


1.21
log
@SUNW SUNWGS INT FCBPL can be considered an asym device now we can uniquely
identify them over multiple paths using their wwnn.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.20 2014/01/30 05:53:38 dlg Exp $ */
a24 1
#include <sys/proc.h>
@


1.20
log
@SGI branded seagate disks work fine
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.19 2013/12/06 21:03:02 deraadt Exp $ */
d100 1
@


1.19
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.18 2013/09/03 06:39:04 dlg Exp $ */
d89 1
@


1.18
log
@DELL MD3060e works
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.17 2013/08/27 00:57:44 dlg Exp $ */
a181 3
	case DVACT_SUSPEND:
	case DVACT_RESUME:
		break;
@


1.17
log
@make path driver match routes return 8 so they will definitely be higher
than the real device drivers. ses returns 3 on some dells, which could be
confusing for autoconf if it has to decide between that and a path driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.16 2013/08/27 00:53:10 dlg Exp $ */
d97 1
@


1.16
log
@get rid of the different path scheduler types, which simplifies the
code that picks the next path. we assume roundrobin within a group
of paths now. the asym sym(4) devices work around this by putting
every path in its own group.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.15 2013/08/26 12:20:12 dlg Exp $ */
d118 1
a118 1
			return (3);
d125 1
a125 1
			return (3);
@


1.15
log
@implement handling of group failover.

if a controller sends sense data back, the path driver can tell
mpath that its indicating failover which kicks off an iteration
over all the groups until one says its active. if no groups claim
to be active, a timeout fires the process off again after a second.

you can start controller handover on rdac (well, an md3200i is all
i had to test with, others might need more work) and everything
keeps going. ill try to get to emc and hds working when i can poke
hardware again.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.9 2013/06/10 03:56:43 dlg Exp $ */
d70 1
a70 2
	sym_mpath_status,
	MPATH_ROUNDROBIN
d76 1
a76 2
	sym_mpath_status,
	MPATH_MRU
@


1.14
log
@all paths are considered active, not in some unknown state.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.13 2013/08/26 10:48:58 dlg Exp $ */
d187 1
a187 1
		if (sc->sc_path.p_dev != NULL)
@


1.13
log
@all FUJITSU MA disks ive found seem ok with being behind mpath.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.12 2013/08/26 10:13:17 dlg Exp $ */
d213 1
a213 1
	mpath_path_status(&sc->sc_path, MPATH_S_UNKNOWN);
@


1.12
log
@when i first imagined how paths on mpath worked, i thought the
midlayer would be able to call things on paths to explicitely online
or offline them. turns out thats not how the Real World(tm) works,
instead its better to wait for failure and probe for the status of
paths, and pick the active group of paths from that. there's even
evidence that the mechanisms for forcing controllers into active/passive
roles from the scsi initiator are being deprecated. they expect
hosts to be able to cope with arbitrary controller role changes and
failover
accordingly.

this replaces the online and offline function pointers in the path_ops
structure with a status check function pointer. instead of returning a
state, the checker is expected to call mpath_path_status() when its
finished figuring out what the state is.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.11 2013/08/26 07:38:56 dlg Exp $ */
d92 1
a92 1
	{ "FUJITSU ", "MAP" }
@


1.11
log
@checksense handlers in path drivers can return MPATH_SENSE_DECLINED
(who can tell ive spent time in web servers) to say they decline
interpreting the sense data, or MPATH_SENSE_FAILOVER to say the
sense data is from the controller saying its failed over.

all path drivers currently decline handling sense data.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.10 2013/08/26 07:29:45 dlg Exp $ */
d65 1
a65 2
int		sym_mpath_online(struct scsi_link *);
int		sym_mpath_offline(struct scsi_link *);
d70 1
a70 2
	sym_mpath_online,
	sym_mpath_offline,
d77 1
a77 2
	sym_mpath_online,
	sym_mpath_offline,
d208 2
a209 2
int
sym_mpath_online(struct scsi_link *link)
d211 1
a211 2
	return (0);
}
d213 1
a213 4
int
sym_mpath_offline(struct scsi_link *link)
{
	return (0);
@


1.10
log
@introduce the idea of groups of paths. mpath had stuff to managed
devices and paths. devices are what mpath presents as targets on
its scsibus, and paths are the things attached to hardware controllers
that are available to shove io down to the actual real target. all
paths were considered usable for handling io on behalf of a device.

this adds groups in between devices and paths. only paths on the
first group in the list will now be used to handle io now.

sym devices will only have one group. asym devices will treat each
path as a different group. rdac, emc, and hds will group paths based
on which controller in the array theyre connected to.

in the future we will intercept sense data from passive controllers
and use that to start running checks to pick a new primary group
so we can handle controller failover situations.

the group id in hds(4) is currently busted, everything else should
be correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.9 2013/06/10 03:56:43 dlg Exp $ */
d208 1
a208 1
	return (0);
@


1.9
log
@toshiba disks in an md1220 work fine
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.8 2013/02/04 01:27:55 dlg Exp $ */
d145 1
d157 1
d169 1
a169 1
	if (mpath_path_attach(&sc->sc_path, ops) != 0)
@


1.8
log
@some stuff i found in old storedge 3500 disk trays seem to work fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.7 2012/03/23 13:46:47 claudio Exp $ */
d92 1
@


1.7
log
@Add an entry to the asym list for the NetBSD iSCSI target.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.6 2011/07/11 01:02:48 dlg Exp $ */
d93 2
a94 1
	{ "FUJITSU ", "MBD" }
d101 1
@


1.6
log
@support "failover" style access to volumes, ie, only use one active
path when talking to an array until it goes away, then you fail
over to the next active path.

im using this to talk to ses(4) in my dell, and allows us to support
arrays that have multiple controllers but have no way of reporting
which one is active. using the MRU semantic means we can talk to
them without them flipping the active role between its controllers
all the time. claudios transtec iscsi box is like this.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.5 2011/07/03 15:47:18 matthew Exp $ */
d100 2
a101 1
	{ "Transtec", "PROVIGO1100" }
@


1.5
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.4 2011/06/15 01:51:44 dlg Exp $ */
d68 1
a68 1
struct mpath_ops sym_mpath_ops = {
d72 10
a81 1
	sym_mpath_offline
d96 7
d121 7
d138 4
d145 11
a161 1
	sc->sc_path.p_ops = &sym_mpath_ops;
d163 1
a163 1
	if (mpath_path_attach(&sc->sc_path) != 0)
@


1.4
log
@FUJITSU MBD drives seem ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.3 2011/04/28 10:43:36 dlg Exp $ */
a142 1
	case DVACT_ACTIVATE:
@


1.3
log
@clean up the path ops struct a bit. the path drivers init their xsh with
their start routines, they dont have to pass pointers to them in the
ops struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.2 2011/04/27 09:09:36 dlg Exp $ */
d83 2
a84 1
	{ "SEAGATE ", "ST" }
@


1.2
log
@whitespace fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath_sym.c,v 1.1 2011/04/05 14:25:42 dlg Exp $ */
a69 1
	sym_mpath_start,
@


1.1
log
@move forward with scsi multipathing.

the big change is how paths between mpath capable devices and the
kernel are managed.

originally the midlayer would steal the links to the devices and
hide them behind mpath. all the changes an adapter made to a link
(eg activate or detach), the midlayer had to test if it was an mpath
link and then call special mpath code to handle it.

the original code also assumed that all paths behaved the same, but
the reality is that different devices have different command sets
and behaviours. figuring out which behaviour to pick and prioritising
them is basically the same job autoconf does with match and attach.

rather than special casing mpath in the midlayer and reimplimenting
autoconf, this turns paths into actual device drivers with match
and attach routines. after they figure out if the path is active,
they then give it to mpath(4) to use as a backend.

i have written drivers for symmetric access devices (sym(4)) where
all paths to the same logical unit are as good as each other,
lsi/engenio arrays (rdac(4), and emc arrays (emc(4)).

the rdac and emc drivers only detect active paths at attach time,
the do not cope if the controller changes state unless you unplug
the path and plug it in again to retest the active state. they also
do not have support for directing array failover.

operating and hoplugging has been tested with mpii(4), fc and sas
mpi(4), and iscsi via vscsi (claudio did this too).

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpath.c,v 1.18 2010/07/21 21:34:12 todd Exp $ */
d22 1
a22 1
#include <sys/kernel.h>  
d166 1
a166 1
        return (0);
d172 1
a172 1
        return (0);
d178 1
a178 1
        return (0);
@

