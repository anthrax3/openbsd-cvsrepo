head	1.19;
access;
symbols
	OPENBSD_6_1:1.18.0.6
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.2
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.17.0.18
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.20
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.17.0.12
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.16
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.14
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.15.0.4
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.13.0.8
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.10
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.6
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.4
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.12.0.4
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.2
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.14
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.12
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.22
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.20
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.18
	OPENBSD_2_8:1.6.0.16
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.14
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.12
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2017.09.08.05.36.53;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	uRv5pa9QDlZaYgwD;

1.18
date	2016.03.12.15.16.04;	author krw;	state Exp;
branches;
next	1.17;
commitid	zkFngOKA3woPgVlY;

1.17
date	2011.06.01.17.47.31;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2011.03.18.02.11.38;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.01.05.11.18;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.27.16.22.14;	author martynas;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.11.21.18.12;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2006.07.11.08.16.06;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.06.02.51.13;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.08.31.07.41.53;	author downsj;	state Exp;
branches
	1.6.12.1
	1.6.22.1;
next	1.5;

1.5
date	96.10.04.17.58.45;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.08.11.23.26.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.31.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.16.10.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.25;	author deraadt;	state Exp;
branches;
next	;

1.6.12.1
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	;

1.6.22.1
date	2002.06.11.03.32.14;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: uk.c,v 1.18 2016/03/12 15:16:04 krw Exp $	*/
/*	$NetBSD: uk.c,v 1.15 1996/03/17 00:59:57 thorpej Exp $	*/

/*
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Dummy driver for a device we can't identify.
 * Originally by Julian Elischer (julian@@tfs.com)
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/vnode.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#define	UKUNIT(z)	(minor(z))

struct uk_softc {
	struct device		sc_dev;
	struct scsi_link	*sc_link; /* all the inter level info */
};

int	ukmatch(struct device *, void *, void *);
void	ukattach(struct device *, struct device *, void *);
int	ukdetach(struct device *, int);

struct cfattach uk_ca = {
	sizeof(struct uk_softc), ukmatch, ukattach, ukdetach
};

struct cfdriver uk_cd = {
	NULL, "uk", DV_DULL
};

#define uklookup(unit) (struct uk_softc *)device_lookup(&uk_cd, (unit))

int
ukmatch(struct device *parent, void *match, void *aux)
{
	return (1);
}

/*
 * The routine called by the low level scsi routine when it discovers
 * a device suitable for this driver.
 */
void
ukattach(struct device *parent, struct device *self, void *aux)
{
	struct uk_softc			*sc = (void *)self;
	struct scsi_attach_args		*sa = aux;
	struct scsi_link		*link = sa->sa_sc_link;

	SC_DEBUG(link, SDEV_DB2, ("ukattach: "));

	/* Store information needed to contact our base driver */
	sc->sc_link = link;
	link->device_softc = sc;
	link->openings = 1;

	printf("\n");
}

int
ukdetach(struct device *self, int flags)
{
	int bmaj, cmaj, mn;

	mn = self->dv_unit;

	for (bmaj = 0; bmaj < nblkdev; bmaj++)
		if (bdevsw[bmaj].d_open == ukopen)
			vdevgone(bmaj, mn, mn, VBLK);
	for (cmaj = 0; cmaj < nchrdev; cmaj++)
		if (cdevsw[cmaj].d_open == ukopen)
			vdevgone(cmaj, mn, mn, VCHR);

	return (0);
}

/*
 * open the device.
 */
int
ukopen(dev_t dev, int flag, int fmt, struct proc *p)
{
	int				unit;
	struct uk_softc			*sc;
	struct scsi_link		*link;

	unit = UKUNIT(dev);
	sc = uklookup(unit);
	if (sc == NULL)
		return (ENXIO);

	link = sc->sc_link;

	SC_DEBUG(link, SDEV_DB1, ("ukopen: dev=0x%x (unit %d (of %d))\n",
	    dev, unit, uk_cd.cd_ndevs));

	/* Only allow one at a time */
	if (link->flags & SDEV_OPEN) {
		device_unref(&sc->sc_dev);
		return (EBUSY);
	}

	link->flags |= SDEV_OPEN;

	SC_DEBUG(link, SDEV_DB3, ("open complete\n"));

	device_unref(&sc->sc_dev);
	return (0);
}

/*
 * close the device.. only called if we are the LAST
 * occurrence of an open device
 */
int
ukclose(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct uk_softc			*sc;

	sc = uklookup(UKUNIT(dev));
	if (sc == NULL)
		return (ENXIO);

	SC_DEBUG(sc->sc_link, SDEV_DB1, ("closing\n"));
	sc->sc_link->flags &= ~SDEV_OPEN;

	device_unref(&sc->sc_dev);
	return (0);
}

/*
 * Perform special action on behalf of the user
 * Only does generic scsi ioctls.
 */
int
ukioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	int				rv;
	struct uk_softc			*sc;

	sc = uklookup(UKUNIT(dev));
	if (sc == NULL)
		return (ENXIO);

	rv = scsi_do_ioctl(sc->sc_link, cmd, addr, flag);

	device_unref(&sc->sc_dev);
	return (rv);
}
@


1.18
log
@Standardize on calling local scsi_link variables 'link' instead of
'sc_link'. 'sc_link' is a field in the various device *_softc
structures, where the sc_ prefix was for 'softc'. Reduces potential
mental confusion. Newer code from down under was already using
'link'.

No functional change.

Prompted by bluhm@@'s adventures in scsi. ok dlg@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.17 2011/06/01 17:47:31 matthew Exp $	*/
a37 1
#include <sys/types.h>
@


1.17
log
@Make uk(4) look more like sd(4) and cd(4) by adding a uklookup()
wrapper for device_lookup(), and renaming the uk local variables to
sc.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.16 2011/03/18 02:11:38 matthew Exp $	*/
d86 1
a86 1
	struct scsi_link		*sc_link = sa->sa_sc_link;
d88 1
a88 1
	SC_DEBUG(sc_link, SDEV_DB2, ("ukattach: "));
d91 3
a93 3
	sc->sc_link = sc_link;
	sc_link->device_softc = sc;
	sc_link->openings = 1;
d123 1
a123 1
	struct scsi_link		*sc_link;
d130 1
a130 1
	sc_link = sc->sc_link;
d132 1
a132 1
	SC_DEBUG(sc_link, SDEV_DB1, ("ukopen: dev=0x%x (unit %d (of %d))\n",
d136 1
a136 1
	if (sc_link->flags & SDEV_OPEN) {
d141 1
a141 1
	sc_link->flags |= SDEV_OPEN;
d143 1
a143 1
	SC_DEBUG(sc_link, SDEV_DB3, ("open complete\n"));
@


1.16
log
@Add ukdetach() so that detaching an unknown SCSI device doesn't result
in a kernel panic.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.15 2010/07/01 05:11:18 krw Exp $	*/
d69 2
d84 1
a84 1
	struct uk_softc			*uk = (void *)self;
d91 2
a92 2
	uk->sc_link = sc_link;
	sc_link->device_softc = uk;
d122 1
a122 1
	struct uk_softc			*uk;
d126 2
a127 5
	if (unit >= uk_cd.cd_ndevs)
		return (ENXIO);

	uk = uk_cd.cd_devs[unit];
	if (uk == NULL)
d130 1
a130 1
	sc_link = uk->sc_link;
d136 2
a137 1
	if (sc_link->flags & SDEV_OPEN)
d139 1
d145 1
d156 5
a160 1
	struct uk_softc			*uk = uk_cd.cd_devs[UKUNIT(dev)];
d162 2
a163 2
	SC_DEBUG(uk->sc_link, SDEV_DB1, ("closing\n"));
	uk->sc_link->flags &= ~SDEV_OPEN;
d165 1
d176 8
a183 1
	struct uk_softc			*uk = uk_cd.cd_devs[UKUNIT(dev)];
d185 2
a186 1
	return (scsi_do_ioctl(uk->sc_link, cmd, addr, flag));
@


1.15
log
@Die struct scsi_device! Die! Instead, save a pointer to the routine
to interpret sense errors. This is initialized to the basic
interpretation routine, and specific scsi drivers (sd/st/cd) can
replace this with their own. While here kill EJUSTRETURN dance and
make more specialized interpretation routines directly call the
basic routine if desired.

Fixes by matthew@@ to my first diff. Most original work by dlg@@.

ok matthew@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.14 2010/06/15 04:11:34 dlg Exp $	*/
d45 1
d59 1
d62 1
a62 1
	sizeof(struct uk_softc), ukmatch, ukattach
d94 17
@


1.14
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.13 2007/11/27 16:22:14 martynas Exp $	*/
a66 10
/*
 * This driver is so simple it uses all the default services
 */
struct scsi_device uk_switch = {
	NULL,
	NULL,
	NULL,
	NULL,
};

a87 1
	sc_link->device = &uk_switch;
@


1.13
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.12 2006/11/28 16:56:50 dlg Exp $	*/
d163 1
a163 1
	return (scsi_do_ioctl(uk->sc_link, dev, cmd, addr, flag, p));
@


1.12
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.11 2006/07/11 21:18:12 dlg Exp $	*/
d141 1
a141 1
 * occurence of an open device
@


1.11
log
@get rid of useless printfs that just clutter dmesg.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.10 2006/07/11 08:16:06 dlg Exp $	*/
d91 1
a91 1
	struct scsibus_attach_args	*sa = aux;
@


1.10
log
@ansi and knf. no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.9 2006/05/11 00:45:59 krw Exp $	*/
a102 1
	printf("%s: unknown device\n", uk->sc_dev.dv_xname);
d129 2
a130 4
	if (sc_link->flags & SDEV_OPEN) {
		printf("%s: already open\n", uk->sc_dev.dv_xname);
		return EBUSY;
	}
@


1.9
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.8 2005/04/06 02:51:13 krw Exp $	*/
d52 2
a53 3
	struct device sc_dev;

	struct scsi_link *sc_link;	/* all the inter level info */
d56 2
a57 2
int ukmatch(struct device *, void *, void *);
void ukattach(struct device *, struct device *, void *);
d78 1
a78 3
ukmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d80 1
a80 2

	return 1;
d88 1
a88 3
ukattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d90 3
a92 3
	struct uk_softc *uk = (void *)self;
	struct scsibus_attach_args *sa = aux;
	struct scsi_link *sc_link = sa->sa_sc_link;
d96 1
a96 3
	/*
	 * Store information needed to contact our base driver
	 */
d110 1
a110 4
ukopen(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
d112 3
a114 3
	int unit;
	struct uk_softc *uk;
	struct scsi_link *sc_link;
d118 2
a119 1
		return ENXIO;
d121 2
a122 2
	if (!uk)
		return ENXIO;
d126 2
a127 2
	SC_DEBUG(sc_link, SDEV_DB1,
	    ("ukopen: dev=0x%x (unit %d (of %d))\n", dev, unit, uk_cd.cd_ndevs));
d129 1
a129 3
	/*
	 * Only allow one at a time
	 */
d138 2
a139 1
	return 0;
d147 1
a147 4
ukclose(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
d149 1
a149 1
	struct uk_softc *uk = uk_cd.cd_devs[UKUNIT(dev)];
d154 1
a154 1
	return 0;
d162 1
a162 6
ukioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
d164 1
a164 1
	struct uk_softc *uk = uk_cd.cd_devs[UKUNIT(dev)];
d166 1
a166 1
	return scsi_do_ioctl(uk->sc_link, dev, cmd, addr, flag, p);
@


1.8
log
@De-register scsi.
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.7 2002/03/14 01:27:13 millert Exp $	*/
d33 1
a33 1
/* 
d133 1
a133 1
		
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.6 1997/08/31 07:41:53 downsj Exp $	*/
d183 1
a183 1
	register struct uk_softc *uk = uk_cd.cd_devs[UKUNIT(dev)];
@


1.6
log
@* Make scsi_do_ioctl() sane again.
* Use scsi_do_ioctl() in cd.c and uk.c again.
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.5 1996/10/04 17:58:45 niklas Exp $	*/
d57 2
a58 2
int ukmatch __P((struct device *, void *, void *));
void ukattach __P((struct device *, struct device *, void *));
@


1.6.22.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.6 1997/08/31 07:41:53 downsj Exp $	*/
d57 2
a58 2
int ukmatch(struct device *, void *, void *);
void ukattach(struct device *, struct device *, void *);
@


1.6.12.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 2
a58 2
int ukmatch(struct device *, void *, void *);
void ukattach(struct device *, struct device *, void *);
@


1.5
log
@Fixed prototype errors, reviewed & approved by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.4 1996/08/11 23:26:08 deraadt Exp $	*/
d185 1
a185 1
	return scsi_do_safeioctl(uk->sc_link, dev, cmd, addr, flag, p);
@


1.4
log
@limit ioctl priviledges
@
text
@d1 1
a1 1
/*	$OpenBSD: uk.c,v 1.2 1996/04/19 16:10:30 niklas Exp $	*/
d40 1
d43 1
d118 1
a118 1
ukopen(dev)
d120 2
d158 1
a158 1
ukclose(dev)
d160 2
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d179 1
a179 1
	return scsi_do_ioctl(uk->sc_link, dev, cmd, addr, flag, p);
@


1.2
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uk.c,v 1.14 1996/03/05 00:15:33 thorpej Exp $	*/
d58 6
a63 2
struct cfdriver ukcd = {
	NULL, "uk", ukmatch, ukattach, DV_DULL, sizeof(struct uk_softc)
d124 1
a124 1
	if (unit >= ukcd.cd_ndevs)
d126 1
a126 1
	uk = ukcd.cd_devs[unit];
d133 1
a133 1
	    ("ukopen: dev=0x%x (unit %d (of %d))\n", dev, unit, ukcd.cd_ndevs));
d157 1
a157 1
	struct uk_softc *uk = ukcd.cd_devs[UKUNIT(dev)];
d177 1
a177 1
	register struct uk_softc *uk = ukcd.cd_devs[UKUNIT(dev)];
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: uk.c,v 1.13 1995/03/24 20:17:15 glass Exp $	*/
d104 2
a105 1
	printf(": unknown device\n");
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
