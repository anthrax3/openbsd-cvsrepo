head	1.221;
access;
symbols
	OPENBSD_6_2_BASE:1.221
	OPENBSD_6_1:1.218.0.6
	OPENBSD_6_1_BASE:1.218
	OPENBSD_6_0:1.218.0.2
	OPENBSD_6_0_BASE:1.218
	OPENBSD_5_9:1.217.0.2
	OPENBSD_5_9_BASE:1.217
	OPENBSD_5_8:1.217.0.4
	OPENBSD_5_8_BASE:1.217
	OPENBSD_5_7:1.216.0.2
	OPENBSD_5_7_BASE:1.216
	OPENBSD_5_6:1.214.0.4
	OPENBSD_5_6_BASE:1.214
	OPENBSD_5_5:1.213.0.4
	OPENBSD_5_5_BASE:1.213
	OPENBSD_5_4:1.208.0.2
	OPENBSD_5_4_BASE:1.208
	OPENBSD_5_3:1.207.0.8
	OPENBSD_5_3_BASE:1.207
	OPENBSD_5_2:1.207.0.6
	OPENBSD_5_2_BASE:1.207
	OPENBSD_5_1_BASE:1.207
	OPENBSD_5_1:1.207.0.4
	OPENBSD_5_0:1.207.0.2
	OPENBSD_5_0_BASE:1.207
	OPENBSD_4_9:1.197.0.2
	OPENBSD_4_9_BASE:1.197
	OPENBSD_4_8:1.181.0.2
	OPENBSD_4_8_BASE:1.181
	OPENBSD_4_7:1.164.0.2
	OPENBSD_4_7_BASE:1.164
	OPENBSD_4_6:1.148.0.4
	OPENBSD_4_6_BASE:1.148
	OPENBSD_4_5:1.146.0.2
	OPENBSD_4_5_BASE:1.146
	OPENBSD_4_4:1.144.0.2
	OPENBSD_4_4_BASE:1.144
	OPENBSD_4_3:1.134.0.2
	OPENBSD_4_3_BASE:1.134
	OPENBSD_4_2:1.132.0.2
	OPENBSD_4_2_BASE:1.132
	OPENBSD_4_1:1.119.0.2
	OPENBSD_4_1_BASE:1.119
	OPENBSD_4_0:1.110.0.2
	OPENBSD_4_0_BASE:1.110
	OPENBSD_3_9:1.104.0.2
	OPENBSD_3_9_BASE:1.104
	OPENBSD_3_8:1.87.0.2
	OPENBSD_3_8_BASE:1.87
	OPENBSD_3_7:1.75.0.4
	OPENBSD_3_7_BASE:1.75
	OPENBSD_3_6:1.75.0.2
	OPENBSD_3_6_BASE:1.75
	SMP_SYNC_A:1.75
	SMP_SYNC_B:1.75
	OPENBSD_3_5:1.74.0.2
	OPENBSD_3_5_BASE:1.74
	OPENBSD_3_4:1.72.0.2
	OPENBSD_3_4_BASE:1.72
	UBC_SYNC_A:1.69
	OPENBSD_3_3:1.67.0.2
	OPENBSD_3_3_BASE:1.67
	OPENBSD_3_2:1.64.0.2
	OPENBSD_3_2_BASE:1.64
	OPENBSD_3_1:1.60.0.2
	OPENBSD_3_1_BASE:1.60
	UBC_SYNC_B:1.64
	UBC:1.57.0.2
	UBC_BASE:1.57
	OPENBSD_3_0:1.56.0.2
	OPENBSD_3_0_BASE:1.56
	OPENBSD_2_9_BASE:1.55
	OPENBSD_2_9:1.55.0.4
	OPENBSD_2_8:1.55.0.2
	OPENBSD_2_8_BASE:1.55
	OPENBSD_2_7:1.54.0.2
	OPENBSD_2_7_BASE:1.54
	SMP:1.51.0.2
	SMP_BASE:1.51
	kame_19991208:1.51
	OPENBSD_2_6:1.46.0.2
	OPENBSD_2_6_BASE:1.46
	OPENBSD_2_5:1.36.0.2
	OPENBSD_2_5_BASE:1.36
	OPENBSD_2_4:1.35.0.2
	OPENBSD_2_4_BASE:1.35
	OPENBSD_2_3:1.30.0.2
	OPENBSD_2_3_BASE:1.30
	OPENBSD_2_2:1.28.0.2
	OPENBSD_2_2_BASE:1.28
	OPENBSD_2_1:1.23.0.2
	OPENBSD_2_1_BASE:1.23
	OPENBSD_2_0:1.15.0.2
	OPENBSD_2_0_BASE:1.15
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.221
date	2017.09.08.05.36.53;	author deraadt;	state Exp;
branches;
next	1.220;
commitid	uRv5pa9QDlZaYgwD;

1.220
date	2017.05.29.07.47.13;	author krw;	state Exp;
branches;
next	1.219;
commitid	3I8Q1rP34XsL9VJl;

1.219
date	2017.05.04.22.47.27;	author deraadt;	state Exp;
branches;
next	1.218;
commitid	h72QEcy0gESNuyF9;

1.218
date	2016.03.12.15.16.04;	author krw;	state Exp;
branches;
next	1.217;
commitid	zkFngOKA3woPgVlY;

1.217
date	2015.06.07.19.13.27;	author krw;	state Exp;
branches;
next	1.216;
commitid	MxUWuiPFtM1nRYxm;

1.216
date	2014.12.15.02.11.57;	author tedu;	state Exp;
branches;
next	1.215;
commitid	idrzCI81iA9oSrel;

1.215
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.214;
commitid	uzzBR7hz9ncd4O6G;

1.214
date	2014.07.12.18.50.25;	author tedu;	state Exp;
branches;
next	1.213;
commitid	iN7nvia2fLP712wt;

1.213
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.212;

1.212
date	2013.10.03.14.07.41;	author krw;	state Exp;
branches;
next	1.211;

1.211
date	2013.09.27.11.43.19;	author krw;	state Exp;
branches;
next	1.210;

1.210
date	2013.09.15.16.54.52;	author krw;	state Exp;
branches;
next	1.209;

1.209
date	2013.09.15.14.35.50;	author krw;	state Exp;
branches;
next	1.208;

1.208
date	2013.06.11.16.42.17;	author deraadt;	state Exp;
branches;
next	1.207;

1.207
date	2011.07.06.04.49.36;	author matthew;	state Exp;
branches;
next	1.206;

1.206
date	2011.07.03.15.47.18;	author matthew;	state Exp;
branches;
next	1.205;

1.205
date	2011.06.30.16.28.05;	author matthew;	state Exp;
branches;
next	1.204;

1.204
date	2011.06.19.04.55.34;	author deraadt;	state Exp;
branches;
next	1.203;

1.203
date	2011.06.19.04.35.06;	author deraadt;	state Exp;
branches;
next	1.202;

1.202
date	2011.06.06.01.59.49;	author matthew;	state Exp;
branches;
next	1.201;

1.201
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.200;

1.200
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.199;

1.199
date	2011.05.31.17.35.35;	author matthew;	state Exp;
branches;
next	1.198;

1.198
date	2011.03.17.21.30.24;	author deraadt;	state Exp;
branches;
next	1.197;

1.197
date	2010.11.22.12.21.46;	author krw;	state Exp;
branches;
next	1.196;

1.196
date	2010.09.23.13.11.38;	author jsing;	state Exp;
branches;
next	1.195;

1.195
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.194;

1.194
date	2010.09.21.12.20.53;	author krw;	state Exp;
branches;
next	1.193;

1.193
date	2010.09.20.02.51.52;	author deraadt;	state Exp;
branches;
next	1.192;

1.192
date	2010.09.14.04.02.43;	author dlg;	state Exp;
branches;
next	1.191;

1.191
date	2010.09.12.01.54.48;	author krw;	state Exp;
branches;
next	1.190;

1.190
date	2010.09.11.22.40.10;	author krw;	state Exp;
branches;
next	1.189;

1.189
date	2010.09.08.15.16.22;	author jsing;	state Exp;
branches;
next	1.188;

1.188
date	2010.09.08.14.47.12;	author jsing;	state Exp;
branches;
next	1.187;

1.187
date	2010.09.07.16.21.47;	author deraadt;	state Exp;
branches;
next	1.186;

1.186
date	2010.09.07.04.42.15;	author deraadt;	state Exp;
branches;
next	1.185;

1.185
date	2010.09.01.01.38.12;	author dlg;	state Exp;
branches;
next	1.184;

1.184
date	2010.08.31.16.41.24;	author deraadt;	state Exp;
branches;
next	1.183;

1.183
date	2010.08.30.02.47.56;	author matthew;	state Exp;
branches;
next	1.182;

1.182
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.181;

1.181
date	2010.07.28.23.47.43;	author krw;	state Exp;
branches;
next	1.180;

1.180
date	2010.07.25.16.34.41;	author krw;	state Exp;
branches;
next	1.179;

1.179
date	2010.07.25.05.35.42;	author krw;	state Exp;
branches;
next	1.178;

1.178
date	2010.07.22.15.59.46;	author matthew;	state Exp;
branches;
next	1.177;

1.177
date	2010.07.22.04.54.24;	author matthew;	state Exp;
branches;
next	1.176;

1.176
date	2010.07.22.00.31.06;	author krw;	state Exp;
branches;
next	1.175;

1.175
date	2010.07.01.05.11.18;	author krw;	state Exp;
branches;
next	1.174;

1.174
date	2010.07.01.03.01.37;	author matthew;	state Exp;
branches;
next	1.173;

1.173
date	2010.06.30.17.38.03;	author krw;	state Exp;
branches;
next	1.172;

1.172
date	2010.06.28.08.35.46;	author jsing;	state Exp;
branches;
next	1.171;

1.171
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.170;

1.170
date	2010.06.11.12.02.44;	author krw;	state Exp;
branches;
next	1.169;

1.169
date	2010.06.03.11.58.20;	author dlg;	state Exp;
branches;
next	1.168;

1.168
date	2010.06.01.15.27.16;	author thib;	state Exp;
branches;
next	1.167;

1.167
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.166;

1.166
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.165;

1.165
date	2010.04.12.09.51.48;	author dlg;	state Exp;
branches;
next	1.164;

1.164
date	2010.02.28.21.17.00;	author krw;	state Exp;
branches
	1.164.2.1;
next	1.163;

1.163
date	2010.01.15.05.50.31;	author krw;	state Exp;
branches;
next	1.162;

1.162
date	2010.01.15.05.31.38;	author krw;	state Exp;
branches;
next	1.161;

1.161
date	2010.01.12.23.33.57;	author dlg;	state Exp;
branches;
next	1.160;

1.160
date	2010.01.11.08.56.17;	author krw;	state Exp;
branches;
next	1.159;

1.159
date	2010.01.11.00.44.40;	author krw;	state Exp;
branches;
next	1.158;

1.158
date	2010.01.09.21.12.06;	author dlg;	state Exp;
branches;
next	1.157;

1.157
date	2009.12.16.10.51.28;	author dlg;	state Exp;
branches;
next	1.156;

1.156
date	2009.12.13.03.29.01;	author dlg;	state Exp;
branches;
next	1.155;

1.155
date	2009.12.13.01.20.14;	author dlg;	state Exp;
branches;
next	1.154;

1.154
date	2009.12.12.13.03.56;	author dlg;	state Exp;
branches;
next	1.153;

1.153
date	2009.12.06.01.12.52;	author dlg;	state Exp;
branches;
next	1.152;

1.152
date	2009.12.06.01.11.44;	author dlg;	state Exp;
branches;
next	1.151;

1.151
date	2009.12.06.01.05.14;	author dlg;	state Exp;
branches;
next	1.150;

1.150
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.149;

1.149
date	2009.08.13.15.23.11;	author deraadt;	state Exp;
branches;
next	1.148;

1.148
date	2009.06.17.01.30.30;	author thib;	state Exp;
branches;
next	1.147;

1.147
date	2009.06.03.22.09.30;	author thib;	state Exp;
branches;
next	1.146;

1.146
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.145;

1.145
date	2009.01.10.18.00.59;	author robert;	state Exp;
branches;
next	1.144;

1.144
date	2008.08.01.01.44.20;	author dlg;	state Exp;
branches;
next	1.143;

1.143
date	2008.07.26.04.39.51;	author krw;	state Exp;
branches;
next	1.142;

1.142
date	2008.06.22.16.32.05;	author krw;	state Exp;
branches;
next	1.141;

1.141
date	2008.06.21.21.11.34;	author krw;	state Exp;
branches;
next	1.140;

1.140
date	2008.06.21.18.50.24;	author krw;	state Exp;
branches;
next	1.139;

1.139
date	2008.06.17.01.32.49;	author krw;	state Exp;
branches;
next	1.138;

1.138
date	2008.06.15.00.36.41;	author krw;	state Exp;
branches;
next	1.137;

1.137
date	2008.06.10.20.27.31;	author art;	state Exp;
branches;
next	1.136;

1.136
date	2008.06.10.20.14.37;	author beck;	state Exp;
branches;
next	1.135;

1.135
date	2008.05.27.11.39.22;	author fgsch;	state Exp;
branches;
next	1.134;

1.134
date	2007.09.16.01.30.24;	author krw;	state Exp;
branches;
next	1.133;

1.133
date	2007.09.07.16.15.48;	author krw;	state Exp;
branches;
next	1.132;

1.132
date	2007.06.20.18.15.47;	author deraadt;	state Exp;
branches;
next	1.131;

1.131
date	2007.06.18.20.55.52;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2007.06.07.05.29.44;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2007.06.06.17.15.14;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2007.06.05.00.38.23;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2007.06.01.00.07.48;	author krw;	state Exp;
branches;
next	1.125;

1.125
date	2007.05.25.05.37.16;	author krw;	state Exp;
branches;
next	1.124;

1.124
date	2007.04.28.02.24.21;	author krw;	state Exp;
branches;
next	1.123;

1.123
date	2007.04.26.11.18.54;	author krw;	state Exp;
branches;
next	1.122;

1.122
date	2007.04.12.11.33.13;	author krw;	state Exp;
branches;
next	1.121;

1.121
date	2007.04.10.17.47.56;	author miod;	state Exp;
branches;
next	1.120;

1.120
date	2007.04.10.10.48.57;	author krw;	state Exp;
branches;
next	1.119;

1.119
date	2007.02.03.23.47.18;	author bluhm;	state Exp;
branches;
next	1.118;

1.118
date	2006.12.23.17.35.35;	author krw;	state Exp;
branches;
next	1.117;

1.117
date	2006.12.12.02.44.36;	author krw;	state Exp;
branches;
next	1.116;

1.116
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.115;

1.115
date	2006.11.27.23.14.22;	author beck;	state Exp;
branches;
next	1.114;

1.114
date	2006.11.27.20.15.09;	author beck;	state Exp;
branches;
next	1.113;

1.113
date	2006.10.08.02.29.24;	author beck;	state Exp;
branches;
next	1.112;

1.112
date	2006.10.07.23.40.07;	author beck;	state Exp;
branches;
next	1.111;

1.111
date	2006.09.26.23.33.04;	author krw;	state Exp;
branches;
next	1.110;

1.110
date	2006.07.29.02.40.45;	author krw;	state Exp;
branches;
next	1.109;

1.109
date	2006.07.23.02.50.20;	author dlg;	state Exp;
branches;
next	1.108;

1.108
date	2006.07.19.01.21.28;	author krw;	state Exp;
branches;
next	1.107;

1.107
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.106;

1.106
date	2006.03.15.20.20.42;	author miod;	state Exp;
branches;
next	1.105;

1.105
date	2006.03.04.19.33.22;	author miod;	state Exp;
branches;
next	1.104;

1.104
date	2006.01.21.12.18.49;	author miod;	state Exp;
branches;
next	1.103;

1.103
date	2006.01.17.20.22.22;	author miod;	state Exp;
branches;
next	1.102;

1.102
date	2006.01.12.01.06.27;	author krw;	state Exp;
branches;
next	1.101;

1.101
date	2005.12.25.20.01.11;	author krw;	state Exp;
branches;
next	1.100;

1.100
date	2005.12.23.16.18.19;	author krw;	state Exp;
branches;
next	1.99;

1.99
date	2005.12.22.23.06.23;	author krw;	state Exp;
branches;
next	1.98;

1.98
date	2005.12.22.03.21.57;	author krw;	state Exp;
branches;
next	1.97;

1.97
date	2005.10.15.18.18.36;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2005.10.14.23.53.29;	author krw;	state Exp;
branches;
next	1.95;

1.95
date	2005.10.11.14.19.21;	author hshoexer;	state Exp;
branches;
next	1.94;

1.94
date	2005.10.11.11.31.43;	author krw;	state Exp;
branches;
next	1.93;

1.93
date	2005.10.10.23.10.38;	author krw;	state Exp;
branches;
next	1.92;

1.92
date	2005.09.29.01.19.53;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2005.09.26.22.52.49;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2005.09.21.03.36.07;	author krw;	state Exp;
branches;
next	1.89;

1.89
date	2005.09.21.03.10.57;	author krw;	state Exp;
branches;
next	1.88;

1.88
date	2005.09.11.17.34.27;	author krw;	state Exp;
branches;
next	1.87;

1.87
date	2005.08.23.23.38.00;	author krw;	state Exp;
branches;
next	1.86;

1.86
date	2005.08.03.23.37.07;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2005.06.11.14.49.54;	author krw;	state Exp;
branches;
next	1.84;

1.84
date	2005.06.05.21.27.07;	author krw;	state Exp;
branches;
next	1.83;

1.83
date	2005.06.03.17.29.55;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2005.06.03.15.50.10;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2005.05.27.23.51.53;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2005.05.27.16.07.51;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2005.05.01.19.29.17;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2005.04.06.02.51.13;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2005.04.05.02.01.50;	author krw;	state Exp;
branches;
next	1.76;

1.76
date	2005.03.30.02.40.42;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2004.05.09.04.01.59;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2004.02.15.02.45.47;	author tedu;	state Exp;
branches;
next	1.73;

1.73
date	2003.11.07.10.16.46;	author jmc;	state Exp;
branches;
next	1.72;

1.72
date	2003.07.30.16.57.54;	author tedu;	state Exp;
branches;
next	1.71;

1.71
date	2003.05.18.16.06.35;	author mickey;	state Exp;
branches;
next	1.70;

1.70
date	2003.05.17.16.55.45;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2003.05.16.19.54.05;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2003.04.06.03.02.44;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2003.01.17.04.30.06;	author jason;	state Exp;
branches;
next	1.66;

1.66
date	2003.01.05.22.33.23;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2002.12.30.21.50.28;	author grange;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.09.00.01.49;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.08.23.59.47;	author art;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.08.23.58.12;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.23.20.29.07;	author csapuntz;	state Exp;
branches;
next	1.60;

1.60
date	2002.03.14.03.16.12;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2002.02.01.10.06.18;	author hin;	state Exp;
branches;
next	1.57;

1.57
date	2001.10.25.12.59.21;	author drahn;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2001.06.22.14.35.42;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2000.07.18.06.09.00;	author csapuntz;	state Exp;
branches;
next	1.54;

1.54
date	2000.04.18.06.34.18;	author csapuntz;	state Exp;
branches;
next	1.53;

1.53
date	2000.04.18.05.53.17;	author csapuntz;	state Exp;
branches;
next	1.52;

1.52
date	2000.04.09.07.09.03;	author csapuntz;	state Exp;
branches;
next	1.51;

1.51
date	99.11.12.05.52.58;	author angelos;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	99.11.11.19.15.19;	author csapuntz;	state Exp;
branches;
next	1.49;

1.49
date	99.11.09.23.14.19;	author angelos;	state Exp;
branches;
next	1.48;

1.48
date	99.11.03.21.20.22;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	99.11.03.20.11.58;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	99.10.16.19.30.18;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	99.10.14.05.23.02;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	99.09.25.03.28.48;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	99.09.21.04.37.59;	author csapuntz;	state Exp;
branches;
next	1.42;

1.42
date	99.09.21.04.14.30;	author csapuntz;	state Exp;
branches;
next	1.41;

1.41
date	99.08.24.01.20.22;	author csapuntz;	state Exp;
branches;
next	1.40;

1.40
date	99.08.10.23.09.49;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	99.07.21.05.58.25;	author csapuntz;	state Exp;
branches;
next	1.38;

1.38
date	99.07.20.09.41.41;	author csapuntz;	state Exp;
branches;
next	1.37;

1.37
date	99.07.20.06.21.59;	author csapuntz;	state Exp;
branches;
next	1.36;

1.36
date	99.04.01.01.46.51;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	98.10.05.00.39.27;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	98.10.04.01.37.55;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	98.10.03.21.19.01;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	98.07.13.00.21.16;	author csapuntz;	state Exp;
branches;
next	1.31;

1.31
date	98.07.12.01.20.18;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	98.03.27.18.40.54;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	97.12.05.00.09.50;	author provos;	state Exp;
branches;
next	1.28;

1.28
date	97.10.18.10.37.16;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	97.10.15.09.35.00;	author provos;	state Exp;
branches;
next	1.26;

1.26
date	97.09.11.11.20.43;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	97.08.31.07.41.51;	author downsj;	state Exp;
branches;
next	1.24;

1.24
date	97.08.08.21.47.05;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	97.04.14.04.09.03;	author downsj;	state Exp;
branches;
next	1.22;

1.22
date	97.03.29.23.54.20;	author briggs;	state Exp;
branches;
next	1.21;

1.21
date	97.03.26.01.53.48;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.01.04.08.50.20;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	96.12.24.01.33.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.12.11.19.08.14;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	96.12.05.13.10.24;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.10.31.01.09.20;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	96.10.05.07.16.59;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	96.08.16.22.26.03;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.08.07.00.09.16;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.06.10.00.43.58;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	96.06.01.09.35.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.16.09.28.55;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.05.10.12.31.38;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.02.13.17.48;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.30.42;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.02.20.01.36.57;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.01.14.21.44.26;	author briggs;	state Exp;
branches;
next	1.4;

1.4
date	96.01.12.20.21.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.05.55.20;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.21.14.24.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.23;	author deraadt;	state Exp;
branches;
next	;

1.51.2.1
date	2001.05.14.22.44.58;	author niklas;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2001.07.04.10.59.59;	author niklas;	state Exp;
branches;
next	1.51.2.3;

1.51.2.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.51.2.4;

1.51.2.4
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.51.2.5;

1.51.2.5
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.51.2.6;

1.51.2.6
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.51.2.7;

1.51.2.7
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.51.2.8;

1.51.2.8
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.51.2.9;

1.51.2.9
date	2004.02.19.11.01.30;	author niklas;	state Exp;
branches;
next	1.51.2.10;

1.51.2.10
date	2004.06.05.23.13.08;	author niklas;	state Exp;
branches;
next	;

1.57.2.1
date	2002.06.11.03.32.13;	author art;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	2003.05.19.22.28.21;	author tedu;	state Exp;
branches;
next	;

1.164.2.1
date	2010.07.06.08.48.50;	author stephan;	state Exp;
branches;
next	;


desc
@@


1.221
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: cd.c,v 1.220 2017/05/29 07:47:13 krw Exp $	*/
/*	$NetBSD: cd.c,v 1.100 1997/04/02 02:29:30 mycroft Exp $	*/

/*
 * Copyright (c) 1994, 1995, 1997 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Originally written by Julian Elischer (julian@@tfs.com)
 * for TRW Financial Systems for use under the MACH(2.5) operating system.
 *
 * TRW Financial Systems, in accordance with their agreement with Carnegie
 * Mellon University, makes this software available to CMU to distribute
 * or use in any manner that they see fit as long as this message is kept with
 * the software. For this reason TFS also grants any other persons or
 * organisations permission to use or modify this software.
 *
 * TFS supplies this software to be publicly redistributed
 * on the understanding that TFS is not responsible for the correct
 * functioning of this software in any circumstances.
 *
 * Ported to run under 386BSD by Julian Elischer (julian@@tfs.com) Sept 1992
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/mtio.h>
#include <sys/buf.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/cdio.h>
#include <sys/conf.h>
#include <sys/scsiio.h>
#include <sys/dkio.h>
#include <sys/vnode.h>

#include <scsi/scsi_all.h>
#include <scsi/cd.h>
#include <scsi/scsi_disk.h>	/* rw_big and start_stop come from there */
#include <scsi/scsiconf.h>


#include <ufs/ffs/fs.h>		/* for BBSIZE and SBSIZE */

#define	CDOUTSTANDING	4

#define MAXTRACK	99
#define CD_FRAMES	75
#define CD_SECS		60

struct cd_toc {
	struct ioc_toc_header header;
	struct cd_toc_entry entries[MAXTRACK+1]; /* One extra for the */
						 /* leadout */
};

int	cdmatch(struct device *, void *, void *);
void	cdattach(struct device *, struct device *, void *);
int	cdactivate(struct device *, int);
int	cddetach(struct device *, int);

struct cd_softc {
	struct device sc_dev;
	struct disk sc_dk;

	int sc_flags;
#define	CDF_ANCIENT	0x10		/* disk is ancient; for minphys */
#define	CDF_DYING	0x40		/* dying, when deactivated */
#define CDF_WAITING	0x100
	struct scsi_link *sc_link;	/* contains our targ, lun, etc. */
	struct cd_parms {
		u_int32_t secsize;
		u_int64_t disksize;	/* total number sectors */
	} params;
	struct bufq	sc_bufq;
	struct scsi_xshandler sc_xsh;
	struct timeout sc_timeout;
};

void	cdstart(struct scsi_xfer *);
void	cd_buf_done(struct scsi_xfer *);
void	cdminphys(struct buf *);
int	cdgetdisklabel(dev_t, struct cd_softc *, struct disklabel *, int);
int	cd_setchan(struct cd_softc *, int, int, int, int, int);
int	cd_getvol(struct cd_softc *cd, struct ioc_vol *, int);
int	cd_setvol(struct cd_softc *, const struct ioc_vol *, int);
int	cd_load_unload(struct cd_softc *, int, int);
int	cd_set_pa_immed(struct cd_softc *, int);
int	cd_play(struct cd_softc *, int, int);
int	cd_play_tracks(struct cd_softc *, int, int, int, int);
int	cd_play_msf(struct cd_softc *, int, int, int, int, int, int);
int	cd_pause(struct cd_softc *, int);
int	cd_reset(struct cd_softc *);
int	cd_read_subchannel(struct cd_softc *, int, int, int,
	    struct cd_sub_channel_info *, int );
int	cd_read_toc(struct cd_softc *, int, int, void *, int, int);
int	cd_get_parms(struct cd_softc *, int);
int	cd_load_toc(struct cd_softc *, struct cd_toc *, int);
int	cd_interpret_sense(struct scsi_xfer *);
u_int64_t cd_size(struct scsi_link *, int, u_int32_t *);

int	dvd_auth(struct cd_softc *, union dvd_authinfo *);
int	dvd_read_physical(struct cd_softc *, union dvd_struct *);
int	dvd_read_copyright(struct cd_softc *, union dvd_struct *);
int	dvd_read_disckey(struct cd_softc *, union dvd_struct *);
int	dvd_read_bca(struct cd_softc *, union dvd_struct *);
int	dvd_read_manufact(struct cd_softc *, union dvd_struct *);
int	dvd_read_struct(struct cd_softc *, union dvd_struct *);

#if defined(__macppc__)
int	cd_eject(void);
#endif

struct cfattach cd_ca = {
	sizeof(struct cd_softc), cdmatch, cdattach,
	cddetach, cdactivate
};

struct cfdriver cd_cd = {
	NULL, "cd", DV_DISK
};

const struct scsi_inquiry_pattern cd_patterns[] = {
	{T_CDROM, T_REMOV,
	 "",         "",                 ""},
	{T_CDROM, T_FIXED,
	 "",         "",                 ""},
	{T_WORM, T_REMOV,
	 "",         "",                 ""},
	{T_WORM, T_FIXED,
	 "",         "",                 ""},
	{T_DIRECT, T_REMOV,
	 "NEC                 CD-ROM DRIVE:260", "", ""},
#if 0
	{T_CDROM, T_REMOV, /* more luns */
	 "PIONEER ", "CD-ROM DRM-600  ", ""},
#endif
};

#define cdlookup(unit) (struct cd_softc *)disk_lookup(&cd_cd, (unit))

int
cdmatch(struct device *parent, void *match, void *aux)
{
	struct scsi_attach_args *sa = aux;
	int priority;

	scsi_inqmatch(sa->sa_inqbuf, cd_patterns, nitems(cd_patterns),
	    sizeof(cd_patterns[0]), &priority);

	return (priority);
}

/*
 * The routine called by the low level scsi routine when it discovers
 * A device suitable for this driver
 */
void
cdattach(struct device *parent, struct device *self, void *aux)
{
	struct cd_softc *sc = (struct cd_softc *)self;
	struct scsi_attach_args *sa = aux;
	struct scsi_link *link = sa->sa_sc_link;

	SC_DEBUG(link, SDEV_DB2, ("cdattach:\n"));

	/*
	 * Store information needed to contact our base driver
	 */
	sc->sc_link = link;
	link->interpret_sense = cd_interpret_sense;
	link->device_softc = sc;
	if (link->openings > CDOUTSTANDING)
		link->openings = CDOUTSTANDING;

	/*
	 * Initialize disk structures.
	 */
	sc->sc_dk.dk_name = sc->sc_dev.dv_xname;
	bufq_init(&sc->sc_bufq, BUFQ_DEFAULT);

	/*
	 * Note if this device is ancient.  This is used in cdminphys().
	 */
	if (!(link->flags & SDEV_ATAPI) &&
	    SCSISPC(sa->sa_inqbuf->version) == 0)
		sc->sc_flags |= CDF_ANCIENT;

	printf("\n");

	scsi_xsh_set(&sc->sc_xsh, link, cdstart);
	timeout_set(&sc->sc_timeout, (void (*)(void *))scsi_xsh_add,
	    &sc->sc_xsh);

	/* Attach disk. */
	sc->sc_dk.dk_flags = DKF_NOLABELREAD;
	disk_attach(&sc->sc_dev, &sc->sc_dk);
}


int
cdactivate(struct device *self, int act)
{
	struct cd_softc *sc = (struct cd_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_RESUME:
		/*
		 * When resuming, hardware may have forgotten we locked it. So if
		 * there are any open partitions, lock the CD.
		 */
		if (sc->sc_dk.dk_openmask != 0)
			scsi_prevent(sc->sc_link, PR_PREVENT,
			    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE |
			    SCSI_SILENT | SCSI_AUTOCONF);
		break;
	case DVACT_DEACTIVATE:
		sc->sc_flags |= CDF_DYING;
		scsi_xsh_del(&sc->sc_xsh);
		break;
	}
	return (rv);
}

int
cddetach(struct device *self, int flags)
{
	struct cd_softc *sc = (struct cd_softc *)self;

	bufq_drain(&sc->sc_bufq);

	disk_gone(cdopen, self->dv_unit);

	/* Detach disk. */
	bufq_destroy(&sc->sc_bufq);
	disk_detach(&sc->sc_dk);

	return (0);
}

/*
 * Open the device. Make sure the partition info is as up-to-date as can be.
 */
int
cdopen(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct scsi_link *link;
	struct cd_softc *sc;
	int error = 0, part, rawopen, unit;

	unit = DISKUNIT(dev);
	part = DISKPART(dev);

	rawopen = (part == RAW_PART) && (fmt == S_IFCHR);

	sc = cdlookup(unit);
	if (sc == NULL)
		return (ENXIO);
	if (sc->sc_flags & CDF_DYING) {
		device_unref(&sc->sc_dev);
		return (ENXIO);
	}

	link = sc->sc_link;
	SC_DEBUG(link, SDEV_DB1,
	    ("cdopen: dev=0x%x (unit %d (of %d), partition %d)\n", dev, unit,
	    cd_cd.cd_ndevs, part));

	if ((error = disk_lock(&sc->sc_dk)) != 0) {
		device_unref(&sc->sc_dev);
		return (error);
	}

	if (sc->sc_dk.dk_openmask != 0) {
		/*
		 * If any partition is open, but the disk has been invalidated,
		 * disallow further opens.
		 */
		if ((link->flags & SDEV_MEDIA_LOADED) == 0) {
			if (rawopen)
				goto out;
			error = EIO;
			goto bad;
		}
	} else {
		/*
		 * Check that it is still responding and ok.  Drive can be in
		 * progress of loading media so use increased retries number
		 * and don't ignore NOT_READY.
		 */

		/* Use cd_interpret_sense() now. */
		link->flags |= SDEV_OPEN;

		error = scsi_test_unit_ready(link, TEST_READY_RETRIES,
		    (rawopen ? SCSI_SILENT : 0) | SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE);

		/* Start the cd spinning if necessary. */
		if (error == EIO)
			error = scsi_start(link, SSS_START,
			    SCSI_IGNORE_ILLEGAL_REQUEST |
			    SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT);

		if (error) {
			if (rawopen) {
				error = 0;
				goto out;
			} else
				goto bad;
		}

		/* Lock the cd in. */
		error = scsi_prevent(link, PR_PREVENT,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE |
		    SCSI_SILENT);
		if (error)
			goto bad;

		/* Load the physical device parameters. */
		link->flags |= SDEV_MEDIA_LOADED;
		if (cd_get_parms(sc, (rawopen ? SCSI_SILENT : 0) |
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE)) {
			link->flags &= ~SDEV_MEDIA_LOADED;
			error = ENXIO;
			goto bad;
		}
		SC_DEBUG(link, SDEV_DB3, ("Params loaded\n"));

		/* Fabricate a disk label. */
		cdgetdisklabel(dev, sc, sc->sc_dk.dk_label, 0);
		SC_DEBUG(link, SDEV_DB3, ("Disklabel fabricated\n"));
	}

out:
	if ((error = disk_openpart(&sc->sc_dk, part, fmt, 1)) != 0)
		goto bad;

	link->flags |= SDEV_OPEN;
	SC_DEBUG(link, SDEV_DB3, ("open complete\n"));

	/* It's OK to fall through because dk_openmask is now non-zero. */
bad:
	if (sc->sc_dk.dk_openmask == 0) {
		scsi_prevent(link, PR_ALLOW,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE |
		    SCSI_SILENT);
		link->flags &= ~(SDEV_OPEN | SDEV_MEDIA_LOADED);
	}

	disk_unlock(&sc->sc_dk);
	device_unref(&sc->sc_dev);
	return (error);
}

/*
 * Close the device. Only called if we are the last occurrence of an open
 * device.
 */
int
cdclose(dev_t dev, int flag, int fmt, struct proc *p)
{
	struct cd_softc *sc;
	int part = DISKPART(dev);

	sc = cdlookup(DISKUNIT(dev));
	if (sc == NULL)
		return ENXIO;
	if (sc->sc_flags & CDF_DYING) {
		device_unref(&sc->sc_dev);
		return (ENXIO);
	}

	disk_lock_nointr(&sc->sc_dk);

	disk_closepart(&sc->sc_dk, part, fmt);

	if (sc->sc_dk.dk_openmask == 0) {
		/* XXXX Must wait for I/O to complete! */

		scsi_prevent(sc->sc_link, PR_ALLOW,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY |
		    SCSI_SILENT);
		sc->sc_link->flags &= ~(SDEV_OPEN | SDEV_MEDIA_LOADED);

		if (sc->sc_link->flags & SDEV_EJECTING) {
			scsi_start(sc->sc_link, SSS_STOP|SSS_LOEJ, 0);

			sc->sc_link->flags &= ~SDEV_EJECTING;
		}

		timeout_del(&sc->sc_timeout);
		scsi_xsh_del(&sc->sc_xsh);
	}

	disk_unlock(&sc->sc_dk);

	device_unref(&sc->sc_dev);
	return 0;
}

/*
 * Actually translate the requested transfer into one the physical driver can
 * understand.  The transfer is described by a buf and will include only one
 * physical transfer.
 */
void
cdstrategy(struct buf *bp)
{
	struct cd_softc *sc;
	int s;

	sc = cdlookup(DISKUNIT(bp->b_dev));
	if (sc == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}
	if (sc->sc_flags & CDF_DYING) {
		bp->b_error = ENXIO;
		goto bad;
	}

	SC_DEBUG(sc->sc_link, SDEV_DB2, ("cdstrategy: %ld bytes @@ blk %lld\n",
	    bp->b_bcount, (long long)bp->b_blkno));
	/*
	 * If the device has been made invalid, error out
	 * maybe the media changed, or no media loaded
	 */
	if ((sc->sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
		bp->b_error = EIO;
		goto bad;
	}

	/* Validate the request. */
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label) == -1)
		goto done;

	/* Place it in the queue of disk activities for this disk. */
	bufq_queue(&sc->sc_bufq, bp);

	/*
	 * Tell the device to get going on the transfer if it's
	 * not doing anything, otherwise just wait for completion
	 */
	scsi_xsh_add(&sc->sc_xsh);

	device_unref(&sc->sc_dev);
	return;

 bad:
	bp->b_flags |= B_ERROR;
	bp->b_resid = bp->b_bcount;
 done:
	s = splbio();
	biodone(bp);
	splx(s);
	if (sc != NULL)
		device_unref(&sc->sc_dev);
}

/*
 * cdstart looks to see if there is a buf waiting for the device
 * and that the device is not already busy. If both are true,
 * It deques the buf and creates a scsi command to perform the
 * transfer in the buf. The transfer request will call scsi_done
 * on completion, which will in turn call this routine again
 * so that the next queued transfer is performed.
 * The bufs are queued by the strategy routine (cdstrategy)
 *
 * This routine is also called after other non-queued requests
 * have been made of the scsi driver, to ensure that the queue
 * continues to be drained.
 *
 * must be called at the correct (highish) spl level
 * cdstart() is called at splbio from cdstrategy and scsi_done
 */
void
cdstart(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct cd_softc *sc = link->device_softc;
	struct buf *bp;
	struct scsi_rw_big *cmd_big;
	struct scsi_rw *cmd_small;
	u_int64_t secno, nsecs;
	struct partition *p;
	int read;

	SC_DEBUG(link, SDEV_DB2, ("cdstart\n"));

	if (sc->sc_flags & CDF_DYING) {
		scsi_xs_put(xs);
		return;
	}

	/*
	 * If the device has become invalid, abort all the
	 * reads and writes until all files have been closed and
	 * re-opened
	 */
	if ((link->flags & SDEV_MEDIA_LOADED) == 0) {
		bufq_drain(&sc->sc_bufq);
		scsi_xs_put(xs);
		return;
	}

	bp = bufq_dequeue(&sc->sc_bufq);
	if (bp == NULL) {
		scsi_xs_put(xs);
		return;
	}

	/*
	 * We have a buf, now we should make a command
	 *
	 * First, translate the block to absolute and put it in terms
	 * of the logical blocksize of the device.
	 */
	secno = DL_BLKTOSEC(sc->sc_dk.dk_label, bp->b_blkno);
	p = &sc->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
	secno += DL_GETPOFFSET(p);
	nsecs = howmany(bp->b_bcount, sc->sc_dk.dk_label->d_secsize);

	read = (bp->b_flags & B_READ);

	/*
	 *  Fill out the scsi command.  If the transfer will
	 *  fit in a "small" cdb, use it.
	 */
	if (!(link->flags & SDEV_ATAPI) &&
	    !(link->quirks & SDEV_ONLYBIG) &&
	    ((secno & 0x1fffff) == secno) &&
	    ((nsecs & 0xff) == nsecs)) {
		/*
		 * We can fit in a small cdb.
		 */
		cmd_small = (struct scsi_rw *)xs->cmd;
		cmd_small->opcode = read ?
		    READ_COMMAND : WRITE_COMMAND;
		_lto3b(secno, cmd_small->addr);
		cmd_small->length = nsecs & 0xff;
		xs->cmdlen = sizeof(*cmd_small);
	} else {
		/*
		 * Need a large cdb.
		 */
		cmd_big = (struct scsi_rw_big *)xs->cmd;
		cmd_big->opcode = read ?
		    READ_BIG : WRITE_BIG;
		_lto4b(secno, cmd_big->addr);
		_lto2b(nsecs, cmd_big->length);
		xs->cmdlen = sizeof(*cmd_big);
	}

	xs->flags |= (read ? SCSI_DATA_IN : SCSI_DATA_OUT);
	xs->timeout = 30000;
	xs->data = bp->b_data;
	xs->datalen = bp->b_bcount;
	xs->done = cd_buf_done;
	xs->cookie = bp;
	xs->bp = bp;

	/* Instrumentation. */
	disk_busy(&sc->sc_dk);

	scsi_xs_exec(xs);

	if (ISSET(sc->sc_flags, CDF_WAITING))
		CLR(sc->sc_flags, CDF_WAITING);
	else if (bufq_peek(&sc->sc_bufq))
		scsi_xsh_add(&sc->sc_xsh);
}

void
cd_buf_done(struct scsi_xfer *xs)
{
	struct cd_softc *sc = xs->sc_link->device_softc;
	struct buf *bp = xs->cookie;
	int error, s;

	switch (xs->error) {
	case XS_NOERROR:
		bp->b_error = 0;
		bp->b_resid = xs->resid;
		break;

	case XS_SENSE:
	case XS_SHORTSENSE:
#ifdef SCSIDEBUG
		scsi_sense_print_debug(xs);
#endif
		error = cd_interpret_sense(xs);
		if (error == 0) {
			bp->b_error = 0;
			bp->b_resid = xs->resid;
			break;
		}
		if (error != ERESTART)
			xs->retries = 0;
		goto retry;

	case XS_BUSY:
		if (xs->retries) {
			if (scsi_delay(xs, 1) != ERESTART)
				xs->retries = 0;
		}
		goto retry;

	case XS_TIMEOUT:
retry:
		if (xs->retries--) {
			scsi_xs_exec(xs);
			return;
		}
		/* FALLTHROUGH */

	default:
		bp->b_error = EIO;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		break;
	}

	disk_unbusy(&sc->sc_dk, bp->b_bcount - xs->resid, bp->b_blkno,
	    bp->b_flags & B_READ);

	s = splbio();
	biodone(bp);
	splx(s);
	scsi_xs_put(xs);
}

void
cdminphys(struct buf *bp)
{
	struct cd_softc *sc;
	long max;

	sc = cdlookup(DISKUNIT(bp->b_dev));
	if (sc == NULL)
		return;

	/*
	 * If the device is ancient, we want to make sure that
	 * the transfer fits into a 6-byte cdb.
	 *
	 * XXX Note that the SCSI-I spec says that 256-block transfers
	 * are allowed in a 6-byte read/write, and are specified
	 * by setting the "length" to 0.  However, we're conservative
	 * here, allowing only 255-block transfers in case an
	 * ancient device gets confused by length == 0.  A length of 0
	 * in a 10-byte read/write actually means 0 blocks.
	 */
	if (sc->sc_flags & CDF_ANCIENT) {
		max = sc->sc_dk.dk_label->d_secsize * 0xff;

		if (bp->b_bcount > max)
			bp->b_bcount = max;
	}

	(*sc->sc_link->adapter->scsi_minphys)(bp, sc->sc_link);

	device_unref(&sc->sc_dev);
}

int
cdread(dev_t dev, struct uio *uio, int ioflag)
{

	return (physio(cdstrategy, dev, B_READ, cdminphys, uio));
}

int
cdwrite(dev_t dev, struct uio *uio, int ioflag)
{

	return (physio(cdstrategy, dev, B_WRITE, cdminphys, uio));
}

/*
 * Perform special action on behalf of the user.
 * Knows about the internals of this device
 */
int
cdioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	struct cd_softc *sc;
	struct disklabel *lp;
	int part = DISKPART(dev);
	int error = 0;

	sc = cdlookup(DISKUNIT(dev));
	if (sc == NULL)
		return ENXIO;
	if (sc->sc_flags & CDF_DYING) {
		device_unref(&sc->sc_dev);
		return (ENXIO);
	}

	SC_DEBUG(sc->sc_link, SDEV_DB2, ("cdioctl 0x%lx\n", cmd));

	/*
	 * If the device is not valid.. abandon ship
	 */
	if ((sc->sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
		switch (cmd) {
		case DIOCLOCK:
		case DIOCEJECT:
		case SCIOCIDENTIFY:
		case SCIOCCOMMAND:
		case SCIOCDEBUG:
		case CDIOCLOADUNLOAD:
		case SCIOCRESET:
		case CDIOCGETVOL:
		case CDIOCSETVOL:
		case CDIOCSETMONO:
		case CDIOCSETSTEREO:
		case CDIOCSETMUTE:
		case CDIOCSETLEFT:
		case CDIOCSETRIGHT:
		case CDIOCCLOSE:
		case CDIOCEJECT:
		case CDIOCALLOW:
		case CDIOCPREVENT:
		case CDIOCSETDEBUG:
		case CDIOCCLRDEBUG:
		case CDIOCRESET:
		case DVD_AUTH:
		case DVD_READ_STRUCT:
		case MTIOCTOP:
			if (part == RAW_PART)
				break;
		/* FALLTHROUGH */
		default:
			if ((sc->sc_link->flags & SDEV_OPEN) == 0)
				error = ENODEV;
			else
				error = EIO;
			goto exit;
		}
	}

	switch (cmd) {
	case DIOCRLDINFO:
		lp = malloc(sizeof(*lp), M_TEMP, M_WAITOK);
		cdgetdisklabel(dev, sc, lp, 0);
		memcpy(sc->sc_dk.dk_label, lp, sizeof(*lp));
		free(lp, M_TEMP, sizeof(*lp));
		break;

	case DIOCGPDINFO:
		cdgetdisklabel(dev, sc, (struct disklabel *)addr, 1);
		break;

	case DIOCGDINFO:
		*(struct disklabel *)addr = *(sc->sc_dk.dk_label);
		break;

	case DIOCGPART:
		((struct partinfo *)addr)->disklab = sc->sc_dk.dk_label;
		((struct partinfo *)addr)->part =
		    &sc->sc_dk.dk_label->d_partitions[DISKPART(dev)];
		break;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			break;
		}

		if ((error = disk_lock(&sc->sc_dk)) != 0)
			break;

		error = setdisklabel(sc->sc_dk.dk_label,
		    (struct disklabel *)addr, sc->sc_dk.dk_openmask);
		if (error == 0) {
		}

		disk_unlock(&sc->sc_dk);
		break;

	case CDIOCPLAYTRACKS: {
		struct ioc_play_track *args = (struct ioc_play_track *)addr;

		if ((error = cd_set_pa_immed(sc, 0)) != 0)
			break;
		error = cd_play_tracks(sc, args->start_track,
		    args->start_index, args->end_track, args->end_index);
		break;
	}
	case CDIOCPLAYMSF: {
		struct ioc_play_msf *args = (struct ioc_play_msf *)addr;

		if ((error = cd_set_pa_immed(sc, 0)) != 0)
			break;
		error = cd_play_msf(sc, args->start_m, args->start_s,
		    args->start_f, args->end_m, args->end_s, args->end_f);
		break;
	}
	case CDIOCPLAYBLOCKS: {
		struct ioc_play_blocks *args = (struct ioc_play_blocks *)addr;

		if ((error = cd_set_pa_immed(sc, 0)) != 0)
			break;
		error = cd_play(sc, args->blk, args->len);
		break;
	}
	case CDIOCREADSUBCHANNEL: {
		struct ioc_read_subchannel *args =
		    (struct ioc_read_subchannel *)addr;
		struct cd_sub_channel_info *data;
		int len = args->data_len;

		if (len > sizeof(*data) ||
		    len < sizeof(struct cd_sub_channel_header)) {
			error = EINVAL;
			break;
		}
		data = dma_alloc(sizeof(*data), PR_WAITOK);
		error = cd_read_subchannel(sc, args->address_format,
		    args->data_format, args->track, data, len);
		if (error) {
			dma_free(data, sizeof(*data));
			break;
		}
		len = min(len, _2btol(data->header.data_len) +
		    sizeof(struct cd_sub_channel_header));
		error = copyout(data, args->data, len);
		dma_free(data, sizeof(*data));
		break;
	}
	case CDIOREADTOCHEADER: {
		struct ioc_toc_header *th;

		th = dma_alloc(sizeof(*th), PR_WAITOK);
		if ((error = cd_read_toc(sc, 0, 0, th, sizeof(*th), 0)) != 0) {
			dma_free(th, sizeof(*th));
			break;
		}
		if (sc->sc_link->quirks & ADEV_LITTLETOC)
			th->len = letoh16(th->len);
		else
			th->len = betoh16(th->len);
		if (th->len > 0)
			memcpy(addr, th, sizeof(*th));
		else
			error = EIO;
		dma_free(th, sizeof(*th));
		break;
	}
	case CDIOREADTOCENTRYS: {
		struct cd_toc *toc;
		struct ioc_read_toc_entry *te =
		    (struct ioc_read_toc_entry *)addr;
		struct ioc_toc_header *th;
		struct cd_toc_entry *cte;
		int len = te->data_len;
		int ntracks;

		toc = dma_alloc(sizeof(*toc), PR_WAITOK | PR_ZERO);

		th = &toc->header;

		if (len > sizeof(toc->entries) ||
		    len < sizeof(struct cd_toc_entry)) {
			dma_free(toc, sizeof(*toc));
			error = EINVAL;
			break;
		}
		error = cd_read_toc(sc, te->address_format, te->starting_track,
		    toc, len + sizeof(struct ioc_toc_header), 0);
		if (error) {
			dma_free(toc, sizeof(*toc));
			break;
		}
		if (te->address_format == CD_LBA_FORMAT)
			for (ntracks =
			    th->ending_track - th->starting_track + 1;
			    ntracks >= 0; ntracks--) {
				cte = &toc->entries[ntracks];
				cte->addr_type = CD_LBA_FORMAT;
				if (sc->sc_link->quirks & ADEV_LITTLETOC) {
#if BYTE_ORDER == BIG_ENDIAN
					swap16_multi((u_int16_t *)&cte->addr,
					    sizeof(cte->addr) / 2);
#endif
				} else
					cte->addr.lba = betoh32(cte->addr.lba);
			}
		if (sc->sc_link->quirks & ADEV_LITTLETOC) {
			th->len = letoh16(th->len);
		} else
			th->len = betoh16(th->len);
		len = min(len, th->len - (sizeof(th->starting_track) +
		    sizeof(th->ending_track)));

		error = copyout(toc->entries, te->data, len);
		dma_free(toc, sizeof(*toc));
		break;
	}
	case CDIOREADMSADDR: {
		struct cd_toc *toc;
		int sessno = *(int *)addr;
		struct cd_toc_entry *cte;

		if (sessno != 0) {
			error = EINVAL;
			break;
		}

		toc = dma_alloc(sizeof(*toc), PR_WAITOK | PR_ZERO);

		error = cd_read_toc(sc, 0, 0, toc,
		    sizeof(struct ioc_toc_header) + sizeof(struct cd_toc_entry),
		    0x40 /* control word for "get MS info" */);

		if (error) {
			dma_free(toc, sizeof(*toc));
			break;
		}

		cte = &toc->entries[0];
		if (sc->sc_link->quirks & ADEV_LITTLETOC) {
#if BYTE_ORDER == BIG_ENDIAN
			swap16_multi((u_int16_t *)&cte->addr,
			    sizeof(cte->addr) / 2);
#endif
		} else
			cte->addr.lba = betoh32(cte->addr.lba);
		if (sc->sc_link->quirks & ADEV_LITTLETOC)
			toc->header.len = letoh16(toc->header.len);
		else
			toc->header.len = betoh16(toc->header.len);

		*(int *)addr = (toc->header.len >= 10 && cte->track > 1) ?
			cte->addr.lba : 0;
		dma_free(toc, sizeof(*toc));
		break;
	}
	case CDIOCSETPATCH: {
		struct ioc_patch *arg = (struct ioc_patch *)addr;

		error = cd_setchan(sc, arg->patch[0], arg->patch[1],
		    arg->patch[2], arg->patch[3], 0);
		break;
	}
	case CDIOCGETVOL: {
		struct ioc_vol *arg = (struct ioc_vol *)addr;

		error = cd_getvol(sc, arg, 0);
		break;
	}
	case CDIOCSETVOL: {
		struct ioc_vol *arg = (struct ioc_vol *)addr;

		error = cd_setvol(sc, arg, 0);
		break;
	}

	case CDIOCSETMONO:
		error = cd_setchan(sc, BOTH_CHANNEL, BOTH_CHANNEL, MUTE_CHANNEL,
		    MUTE_CHANNEL, 0);
		break;

	case CDIOCSETSTEREO:
		error = cd_setchan(sc, LEFT_CHANNEL, RIGHT_CHANNEL,
		    MUTE_CHANNEL, MUTE_CHANNEL, 0);
		break;

	case CDIOCSETMUTE:
		error = cd_setchan(sc, MUTE_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL,
		    MUTE_CHANNEL, 0);
		break;

	case CDIOCSETLEFT:
		error = cd_setchan(sc, LEFT_CHANNEL, LEFT_CHANNEL, MUTE_CHANNEL,
		    MUTE_CHANNEL, 0);
		break;

	case CDIOCSETRIGHT:
		error = cd_setchan(sc, RIGHT_CHANNEL, RIGHT_CHANNEL,
		    MUTE_CHANNEL, MUTE_CHANNEL, 0);
		break;

	case CDIOCRESUME:
		error = cd_pause(sc, 1);
		break;

	case CDIOCPAUSE:
		error = cd_pause(sc, 0);
		break;
	case CDIOCSTART:
		error = scsi_start(sc->sc_link, SSS_START, 0);
		break;

	case CDIOCSTOP:
		error = scsi_start(sc->sc_link, SSS_STOP, 0);
		break;

	close_tray:
	case CDIOCCLOSE:
		error = scsi_start(sc->sc_link, SSS_START|SSS_LOEJ,
		    SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);
		break;

	case MTIOCTOP:
		if (((struct mtop *)addr)->mt_op == MTRETEN)
			goto close_tray;
		if (((struct mtop *)addr)->mt_op != MTOFFL) {
			error = EIO;
			break;
		}
		/* FALLTHROUGH */
	case CDIOCEJECT: /* FALLTHROUGH */
	case DIOCEJECT:
		sc->sc_link->flags |= SDEV_EJECTING;
		break;
	case CDIOCALLOW:
		error = scsi_prevent(sc->sc_link, PR_ALLOW, 0);
		break;
	case CDIOCPREVENT:
		error = scsi_prevent(sc->sc_link, PR_PREVENT, 0);
		break;
	case DIOCLOCK:
		error = scsi_prevent(sc->sc_link,
		    (*(int *)addr) ? PR_PREVENT : PR_ALLOW, 0);
		break;
	case CDIOCSETDEBUG:
		sc->sc_link->flags |= (SDEV_DB1 | SDEV_DB2);
		break;
	case CDIOCCLRDEBUG:
		sc->sc_link->flags &= ~(SDEV_DB1 | SDEV_DB2);
		break;
	case CDIOCRESET:
	case SCIOCRESET:
		error = cd_reset(sc);
		break;
	case CDIOCLOADUNLOAD: {
		struct ioc_load_unload *args = (struct ioc_load_unload *)addr;

		error = cd_load_unload(sc, args->options, args->slot);
		break;
	}

	case DVD_AUTH:
		error = dvd_auth(sc, (union dvd_authinfo *)addr);
		break;
	case DVD_READ_STRUCT:
		error = dvd_read_struct(sc, (union dvd_struct *)addr);
		break;
	default:
		if (DISKPART(dev) != RAW_PART) {
			error = ENOTTY;
			break;
		}
		error = scsi_do_ioctl(sc->sc_link, cmd, addr, flag);
		break;
	}

 exit:

	device_unref(&sc->sc_dev);
	return (error);
}

/*
 * Load the label information on the named device
 * Actually fabricate a disklabel
 *
 * EVENTUALLY take information about different
 * data tracks from the TOC and put it in the disklabel
 */
int
cdgetdisklabel(dev_t dev, struct cd_softc *sc, struct disklabel *lp,
    int spoofonly)
{
	struct cd_toc *toc;
	int tocidx, n, audioonly = 1;

	bzero(lp, sizeof(struct disklabel));

	lp->d_secsize = sc->params.secsize;
	lp->d_ntracks = 1;
	lp->d_nsectors = 100;
	lp->d_secpercyl = 100;
	lp->d_ncylinders = (sc->params.disksize / 100) + 1;

	if (sc->sc_link->flags & SDEV_ATAPI) {
		strncpy(lp->d_typename, "ATAPI CD-ROM", sizeof(lp->d_typename));
		lp->d_type = DTYPE_ATAPI;
	} else {
		strncpy(lp->d_typename, "SCSI CD-ROM", sizeof(lp->d_typename));
		lp->d_type = DTYPE_SCSI;
	}

	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
	DL_SETDSIZE(lp, sc->params.disksize);
	lp->d_version = 1;

	/* XXX - these values for BBSIZE and SBSIZE assume ffs */
	lp->d_bbsize = BBSIZE;
	lp->d_sbsize = SBSIZE;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	toc = dma_alloc(sizeof(*toc), PR_WAITOK | PR_ZERO);
	if (cd_load_toc(sc, toc, CD_LBA_FORMAT)) {
		audioonly = 0; /* No valid TOC found == not an audio CD. */
		goto done;
	}

	n = toc->header.ending_track - toc->header.starting_track + 1;
	for (tocidx = 0; tocidx < n; tocidx++)
		if (toc->entries[tocidx].control & 4) {
			audioonly = 0; /* Found a non-audio track. */
			goto done;
		}

done:
	dma_free(toc, sizeof(*toc));

	if (audioonly)
		return (0);
	return readdisklabel(DISKLABELDEV(dev), cdstrategy, lp, spoofonly);
}

int
cd_setchan(struct cd_softc *sc, int p0, int p1, int p2, int p3, int flags)
{
	union scsi_mode_sense_buf *data;
	struct cd_audio_page *audio = NULL;
	int error, big;

	data = dma_alloc(sizeof(*data), PR_NOWAIT);
	if (data == NULL)
		return (ENOMEM);

	error = scsi_do_mode_sense(sc->sc_link, AUDIO_PAGE, data,
	    (void **)&audio, NULL, NULL, NULL, sizeof(*audio), flags, &big);
	if (error == 0 && audio == NULL)
		error = EIO;

	if (error == 0) {
		audio->port[LEFT_PORT].channels = p0;
		audio->port[RIGHT_PORT].channels = p1;
		audio->port[2].channels = p2;
		audio->port[3].channels = p3;
		if (big)
			error = scsi_mode_select_big(sc->sc_link, SMS_PF,
			    &data->hdr_big, flags, 20000);
		else
			error = scsi_mode_select(sc->sc_link, SMS_PF,
			    &data->hdr, flags, 20000);
	}

	dma_free(data, sizeof(*data));
	return (error);
}

int
cd_getvol(struct cd_softc *sc, struct ioc_vol *arg, int flags)
{
	union scsi_mode_sense_buf *data;
	struct cd_audio_page *audio = NULL;
	int error;

	data = dma_alloc(sizeof(*data), PR_NOWAIT);
	if (data == NULL)
		return (ENOMEM);

	error = scsi_do_mode_sense(sc->sc_link, AUDIO_PAGE, data,
	    (void **)&audio, NULL, NULL, NULL, sizeof(*audio), flags, NULL);
	if (error == 0 && audio == NULL)
		error = EIO;

	if (error == 0) {
		arg->vol[0] = audio->port[0].volume;
		arg->vol[1] = audio->port[1].volume;
		arg->vol[2] = audio->port[2].volume;
		arg->vol[3] = audio->port[3].volume;
	}

	dma_free(data, sizeof(*data));
	return (0);
}

int
cd_setvol(struct cd_softc *sc, const struct ioc_vol *arg, int flags)
{
	union scsi_mode_sense_buf *data;
	struct cd_audio_page *audio = NULL;
	u_int8_t mask_volume[4];
	int error, big;

	data = dma_alloc(sizeof(*data), PR_NOWAIT);
	if (data == NULL)
		return (ENOMEM);

	error = scsi_do_mode_sense(sc->sc_link,
	    AUDIO_PAGE | SMS_PAGE_CTRL_CHANGEABLE, data, (void **)&audio, NULL,
	    NULL, NULL, sizeof(*audio), flags, NULL);
	if (error == 0 && audio == NULL)
		error = EIO;
	if (error != 0) {
		dma_free(data, sizeof(*data));
		return (error);
	}

	mask_volume[0] = audio->port[0].volume;
	mask_volume[1] = audio->port[1].volume;
	mask_volume[2] = audio->port[2].volume;
	mask_volume[3] = audio->port[3].volume;

	error = scsi_do_mode_sense(sc->sc_link, AUDIO_PAGE, data,
	    (void **)&audio, NULL, NULL, NULL, sizeof(*audio), flags, &big);
	if (error == 0 && audio == NULL)
		error = EIO;
	if (error != 0) {
		dma_free(data, sizeof(*data));
		return (error);
	}

	audio->port[0].volume = arg->vol[0] & mask_volume[0];
	audio->port[1].volume = arg->vol[1] & mask_volume[1];
	audio->port[2].volume = arg->vol[2] & mask_volume[2];
	audio->port[3].volume = arg->vol[3] & mask_volume[3];

	if (big)
		error = scsi_mode_select_big(sc->sc_link, SMS_PF,
		    &data->hdr_big, flags, 20000);
	else
		error = scsi_mode_select(sc->sc_link, SMS_PF,
		    &data->hdr, flags, 20000);

	dma_free(data, sizeof(*data));
	return (error);
}

int
cd_load_unload(struct cd_softc *sc, int options, int slot)
{
	struct scsi_load_unload *cmd;
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(sc->sc_link, 0);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->timeout = 200000;

	cmd = (struct scsi_load_unload *)xs->cmd;
	cmd->opcode = LOAD_UNLOAD;
	cmd->options = options;    /* ioctl uses ATAPI values */
	cmd->slot = slot;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

int
cd_set_pa_immed(struct cd_softc *sc, int flags)
{
	union scsi_mode_sense_buf *data;
	struct cd_audio_page *audio = NULL;
	int error, oflags, big;

	if (sc->sc_link->flags & SDEV_ATAPI)
		/* XXX Noop? */
		return (0);

	data = dma_alloc(sizeof(*data), PR_NOWAIT);
	if (data == NULL)
		return (ENOMEM);

	error = scsi_do_mode_sense(sc->sc_link, AUDIO_PAGE, data,
	    (void **)&audio, NULL, NULL, NULL, sizeof(*audio), flags, &big);
	if (error == 0 && audio == NULL)
		error = EIO;

	if (error == 0) {
		oflags = audio->flags;
		audio->flags &= ~CD_PA_SOTC;
		audio->flags |= CD_PA_IMMED;
		if (audio->flags != oflags) {
			if (big)
				error = scsi_mode_select_big(sc->sc_link,
				    SMS_PF, &data->hdr_big, flags, 20000);
			else
				error = scsi_mode_select(sc->sc_link, SMS_PF,
				    &data->hdr, flags, 20000);
		}
	}

	dma_free(data, sizeof(*data));
	return (error);
}

/*
 * Get scsi driver to send a "start playing" command
 */
int
cd_play(struct cd_softc *sc, int secno, int nsecs)
{
	struct scsi_play *cmd;
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(sc->sc_link, 0);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->timeout = 200000;

	cmd = (struct scsi_play *)xs->cmd;
	cmd->opcode = PLAY;
	_lto4b(secno, cmd->blk_addr);
	_lto2b(nsecs, cmd->xfer_len);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

/*
 * Get scsi driver to send a "start playing" command
 */
int
cd_play_tracks(struct cd_softc *sc, int strack, int sindex, int etrack,
    int eindex)
{
	struct cd_toc *toc;
	u_char endf, ends, endm;
	int error;

	if (!etrack)
		return (EIO);
	if (strack > etrack)
		return (EINVAL);

	toc = dma_alloc(sizeof(*toc), PR_WAITOK | PR_ZERO);

	if ((error = cd_load_toc(sc, toc, CD_MSF_FORMAT)) != 0)
		goto done;

	if (++etrack > (toc->header.ending_track+1))
		etrack = toc->header.ending_track+1;

	strack -= toc->header.starting_track;
	etrack -= toc->header.starting_track;
	if (strack < 0) {
		error = EINVAL;
		goto done;
	}

	/*
	 * The track ends one frame before the next begins.  The last track
	 * is taken care of by the leadoff track.
	 */
	endm = toc->entries[etrack].addr.msf.minute;
	ends = toc->entries[etrack].addr.msf.second;
	endf = toc->entries[etrack].addr.msf.frame;
	if (endf-- == 0) {
		endf = CD_FRAMES - 1;
		if (ends-- == 0) {
			ends = CD_SECS - 1;
			if (endm-- == 0) {
				error = EINVAL;
				goto done;
			}
		}
	}

	error = cd_play_msf(sc, toc->entries[strack].addr.msf.minute,
	    toc->entries[strack].addr.msf.second,
	    toc->entries[strack].addr.msf.frame,
	    endm, ends, endf);

done:
	dma_free(toc, sizeof(*toc));
	return (error);
}

/*
 * Get scsi driver to send a "play msf" command
 */
int
cd_play_msf(struct cd_softc *sc, int startm, int starts, int startf, int endm,
    int ends, int endf)
{
	struct scsi_play_msf *cmd;
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(sc->sc_link, 0);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->timeout = 20000;

	cmd = (struct scsi_play_msf *)xs->cmd;
	cmd->opcode = PLAY_MSF;
	cmd->start_m = startm;
	cmd->start_s = starts;
	cmd->start_f = startf;
	cmd->end_m = endm;
	cmd->end_s = ends;
	cmd->end_f = endf;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

/*
 * Get scsi driver to send a "start up" command
 */
int
cd_pause(struct cd_softc *sc, int go)
{
	struct scsi_pause *cmd;
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(sc->sc_link, 0);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->timeout = 2000;

	cmd = (struct scsi_pause *)xs->cmd;
	cmd->opcode = PAUSE;
	cmd->resume = go;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

/*
 * Get scsi driver to send a "RESET" command
 */
int
cd_reset(struct cd_softc *sc)
{
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(sc->sc_link, SCSI_RESET);
	if (xs == NULL)
		return (ENOMEM);

	xs->timeout = 2000;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

/*
 * Read subchannel
 */
int
cd_read_subchannel(struct cd_softc *sc, int mode, int format, int track,
    struct cd_sub_channel_info *data, int len)
{
	struct scsi_read_subchannel *cmd;
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(sc->sc_link, SCSI_DATA_IN | SCSI_SILENT);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)data;
	xs->datalen = len;
	xs->timeout = 5000;

	cmd = (struct scsi_read_subchannel *)xs->cmd;
	cmd->opcode = READ_SUBCHANNEL;
	if (mode == CD_MSF_FORMAT)
		cmd->byte2 |= CD_MSF;
	cmd->byte3 = SRS_SUBQ;
	cmd->subchan_format = format;
	cmd->track = track;
	_lto2b(len, cmd->data_len);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

/*
 * Read table of contents
 */
int
cd_read_toc(struct cd_softc *sc, int mode, int start, void *data, int len,
    int control)
{
	struct scsi_read_toc *cmd;
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(sc->sc_link, SCSI_DATA_IN |
	    SCSI_IGNORE_ILLEGAL_REQUEST);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->data = data;
	xs->datalen = len;
	xs->timeout = 5000;

	bzero(data, len);

	cmd = (struct scsi_read_toc *)xs->cmd;
	cmd->opcode = READ_TOC;

	if (mode == CD_MSF_FORMAT)
		cmd->byte2 |= CD_MSF;
	cmd->from_track = start;
	_lto2b(len, cmd->data_len);
	cmd->control = control;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

int
cd_load_toc(struct cd_softc *sc, struct cd_toc *toc, int fmt)
{
	int n, len, error;

	error = cd_read_toc(sc, 0, 0, toc, sizeof(toc->header), 0);

	if (error == 0) {
		if (toc->header.ending_track < toc->header.starting_track)
			return (EIO);
		/* +2 to account for leading out track. */
		n = toc->header.ending_track - toc->header.starting_track + 2;
		len = n * sizeof(struct cd_toc_entry) + sizeof(toc->header);
		error = cd_read_toc(sc, fmt, 0, toc, len, 0);
	}

	return (error);
}


/*
 * Get the scsi driver to send a full inquiry to the device and use the
 * results to fill out the disk parameter structure.
 */
int
cd_get_parms(struct cd_softc *sc, int flags)
{
	/* Reasonable defaults for drives that don't support READ_CAPACITY */
	sc->params.secsize = 2048;
	sc->params.disksize = 400000;

	if (sc->sc_link->quirks & ADEV_NOCAPACITY)
		return (0);

	sc->params.disksize = cd_size(sc->sc_link, flags, &sc->params.secsize);

	if ((sc->params.secsize < 512) ||
	    ((sc->params.secsize & 511) != 0))
		sc->params.secsize = 2048;	/* some drives lie ! */

	if (sc->params.disksize < 100)
		sc->params.disksize = 400000;

	return (0);
}

daddr_t
cdsize(dev_t dev)
{

	/* CD-ROMs are read-only. */
	return -1;
}

int
cddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
{
	/* Not implemented. */
	return ENXIO;
}

#define	dvd_copy_key(dst, src)		memcpy((dst), (src), DVD_KEY_SIZE)
#define	dvd_copy_challenge(dst, src)	memcpy((dst), (src), DVD_CHALLENGE_SIZE)

#define DVD_AUTH_BUFSIZE		20

int
dvd_auth(struct cd_softc *sc, union dvd_authinfo *a)
{
	struct scsi_generic *cmd;
	struct scsi_xfer *xs;
	u_int8_t *buf;
	int error;

	buf = dma_alloc(DVD_AUTH_BUFSIZE, PR_WAITOK | PR_ZERO);
	if (buf == NULL)
		return (ENOMEM);

	xs = scsi_xs_get(sc->sc_link, 0);
	if (xs == NULL) {
		error = ENOMEM;
		goto done;
	}
	xs->cmdlen = sizeof(*cmd);
	xs->timeout = 30000;
	xs->data = buf;

	cmd = xs->cmd;

	switch (a->type) {
	case DVD_LU_SEND_AGID:
		cmd->opcode = GPCMD_REPORT_KEY;
		cmd->bytes[8] = 8;
		cmd->bytes[9] = 0 | (0 << 6);
		xs->datalen = 8;
		xs->flags |= SCSI_DATA_IN;

		error = scsi_xs_sync(xs);
		scsi_xs_put(xs);

		if (error == 0)
			a->lsa.agid = buf[7] >> 6;
		break;

	case DVD_LU_SEND_CHALLENGE:
		cmd->opcode = GPCMD_REPORT_KEY;
		cmd->bytes[8] = 16;
		cmd->bytes[9] = 1 | (a->lsc.agid << 6);
		xs->datalen = 16;
		xs->flags |= SCSI_DATA_IN;

		error = scsi_xs_sync(xs);
		scsi_xs_put(xs);
		if (error == 0)
			dvd_copy_challenge(a->lsc.chal, &buf[4]);
		break;

	case DVD_LU_SEND_KEY1:
		cmd->opcode = GPCMD_REPORT_KEY;
		cmd->bytes[8] = 12;
		cmd->bytes[9] = 2 | (a->lsk.agid << 6);
		xs->datalen = 12;
		xs->flags |= SCSI_DATA_IN;

		error = scsi_xs_sync(xs);
		scsi_xs_put(xs);

		if (error == 0)
			dvd_copy_key(a->lsk.key, &buf[4]);
		break;

	case DVD_LU_SEND_TITLE_KEY:
		cmd->opcode = GPCMD_REPORT_KEY;
		_lto4b(a->lstk.lba, &cmd->bytes[1]);
		cmd->bytes[8] = 12;
		cmd->bytes[9] = 4 | (a->lstk.agid << 6);
		xs->datalen = 12;
		xs->flags |= SCSI_DATA_IN;

		error = scsi_xs_sync(xs);
		scsi_xs_put(xs);

		if (error == 0) {
			a->lstk.cpm = (buf[4] >> 7) & 1;
			a->lstk.cp_sec = (buf[4] >> 6) & 1;
			a->lstk.cgms = (buf[4] >> 4) & 3;
			dvd_copy_key(a->lstk.title_key, &buf[5]);
		}
		break;

	case DVD_LU_SEND_ASF:
		cmd->opcode = GPCMD_REPORT_KEY;
		cmd->bytes[8] = 8;
		cmd->bytes[9] = 5 | (a->lsasf.agid << 6);
		xs->datalen = 8;
		xs->flags |= SCSI_DATA_IN;

		error = scsi_xs_sync(xs);
		scsi_xs_put(xs);

		if (error == 0)
			a->lsasf.asf = buf[7] & 1;
		break;

	case DVD_HOST_SEND_CHALLENGE:
		cmd->opcode = GPCMD_SEND_KEY;
		cmd->bytes[8] = 16;
		cmd->bytes[9] = 1 | (a->hsc.agid << 6);
		buf[1] = 14;
		dvd_copy_challenge(&buf[4], a->hsc.chal);
		xs->datalen = 16;
		xs->flags |= SCSI_DATA_OUT;

		error = scsi_xs_sync(xs);
		scsi_xs_put(xs);

		if (error == 0)
			a->type = DVD_LU_SEND_KEY1;
		break;

	case DVD_HOST_SEND_KEY2:
		cmd->opcode = GPCMD_SEND_KEY;
		cmd->bytes[8] = 12;
		cmd->bytes[9] = 3 | (a->hsk.agid << 6);
		buf[1] = 10;
		dvd_copy_key(&buf[4], a->hsk.key);
		xs->datalen = 12;
		xs->flags |= SCSI_DATA_OUT;

		error = scsi_xs_sync(xs);
		scsi_xs_put(xs);

		if (error == 0)
			a->type = DVD_AUTH_ESTABLISHED;
		else
			a->type = DVD_AUTH_FAILURE;
		break;

	case DVD_INVALIDATE_AGID:
		cmd->opcode = GPCMD_REPORT_KEY;
		cmd->bytes[9] = 0x3f | (a->lsa.agid << 6);
		xs->data = NULL;

		error = scsi_xs_sync(xs);
		scsi_xs_put(xs);
		break;

	case DVD_LU_SEND_RPC_STATE:
		cmd->opcode = GPCMD_REPORT_KEY;
		cmd->bytes[8] = 8;
		cmd->bytes[9] = 8 | (0 << 6);
		xs->datalen = 8;
		xs->flags |= SCSI_DATA_IN;

		error = scsi_xs_sync(xs);
		scsi_xs_put(xs);

		if (error == 0) {
			a->lrpcs.type = (buf[4] >> 6) & 3;
			a->lrpcs.vra = (buf[4] >> 3) & 7;
			a->lrpcs.ucca = (buf[4]) & 7;
			a->lrpcs.region_mask = buf[5];
			a->lrpcs.rpc_scheme = buf[6];
		}
		break;

	case DVD_HOST_SEND_RPC_STATE:
		cmd->opcode = GPCMD_SEND_KEY;
		cmd->bytes[8] = 8;
		cmd->bytes[9] = 6 | (0 << 6);
		buf[1] = 6;
		buf[4] = a->hrpcs.pdrc;
		xs->datalen = 8;
		xs->flags |= SCSI_DATA_OUT;

		error = scsi_xs_sync(xs);
		scsi_xs_put(xs);
		break;

	default:
		scsi_xs_put(xs);
		error = ENOTTY;
		break;
	}
done:
	dma_free(buf, DVD_AUTH_BUFSIZE);
	return (error);
}

#define DVD_READ_PHYSICAL_BUFSIZE (4 + 4 * 20)
int
dvd_read_physical(struct cd_softc *sc, union dvd_struct *s)
{
	struct scsi_generic *cmd;
	struct dvd_layer *layer;
	struct scsi_xfer *xs;
	u_int8_t *buf, *bufp;
	int error, i;

	buf = dma_alloc(DVD_READ_PHYSICAL_BUFSIZE, PR_WAITOK | PR_ZERO);
	if (buf == NULL)
		return (ENOMEM);

	xs = scsi_xs_get(sc->sc_link, SCSI_DATA_IN);
	if (xs == NULL) {
		error = ENOMEM;
		goto done;
	}
	xs->cmdlen = sizeof(*cmd);
	xs->data = buf;
	xs->datalen = DVD_READ_PHYSICAL_BUFSIZE;
	xs->timeout = 30000;

	cmd = xs->cmd;
	cmd->opcode = GPCMD_READ_DVD_STRUCTURE;
	cmd->bytes[6] = s->type;
	_lto2b(xs->datalen, &cmd->bytes[7]);

	cmd->bytes[5] = s->physical.layer_num;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error == 0) {
		for (i = 0, bufp = &buf[4], layer = &s->physical.layer[0];
		    i < 4; i++, bufp += 20, layer++) {
			bzero(layer, sizeof(*layer));
			layer->book_version = bufp[0] & 0xf;
			layer->book_type = bufp[0] >> 4;
			layer->min_rate = bufp[1] & 0xf;
			layer->disc_size = bufp[1] >> 4;
			layer->layer_type = bufp[2] & 0xf;
			layer->track_path = (bufp[2] >> 4) & 1;
			layer->nlayers = (bufp[2] >> 5) & 3;
			layer->track_density = bufp[3] & 0xf;
			layer->linear_density = bufp[3] >> 4;
			layer->start_sector = _4btol(&bufp[4]);
			layer->end_sector = _4btol(&bufp[8]);
			layer->end_sector_l0 = _4btol(&bufp[12]);
			layer->bca = bufp[16] >> 7;
		}
	}
done:
	dma_free(buf, DVD_READ_PHYSICAL_BUFSIZE);
	return (error);
}

#define DVD_READ_COPYRIGHT_BUFSIZE	8
int
dvd_read_copyright(struct cd_softc *sc, union dvd_struct *s)
{
	struct scsi_generic *cmd;
	struct scsi_xfer *xs;
	u_int8_t *buf;
	int error;

	buf = dma_alloc(DVD_READ_COPYRIGHT_BUFSIZE, PR_WAITOK | PR_ZERO);
	if (buf == NULL)
		return (ENOMEM);

	xs = scsi_xs_get(sc->sc_link, SCSI_DATA_IN);
	if (xs == NULL) {
		error = ENOMEM;
		goto done;
	}
	xs->cmdlen = sizeof(*cmd);
	xs->data = buf;
	xs->datalen = DVD_READ_COPYRIGHT_BUFSIZE;
	xs->timeout = 30000;

	cmd = xs->cmd;
	cmd->opcode = GPCMD_READ_DVD_STRUCTURE;
	cmd->bytes[6] = s->type;
	_lto2b(xs->datalen, &cmd->bytes[7]);

	cmd->bytes[5] = s->copyright.layer_num;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error == 0) {
		s->copyright.cpst = buf[4];
		s->copyright.rmi = buf[5];
	}
done:
	dma_free(buf, DVD_READ_COPYRIGHT_BUFSIZE);
	return (error);
}

int
dvd_read_disckey(struct cd_softc *sc, union dvd_struct *s)
{
	struct scsi_read_dvd_structure_data *buf;
	struct scsi_read_dvd_structure *cmd;
	struct scsi_xfer *xs;
	int error;

	buf = dma_alloc(sizeof(*buf), PR_WAITOK | PR_ZERO);
	if (buf == NULL)
		return (ENOMEM);

	xs = scsi_xs_get(sc->sc_link, SCSI_DATA_IN);
	if (xs == NULL) {
		error = ENOMEM;
		goto done;
	}
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)buf;
	xs->datalen = sizeof(*buf);
	xs->timeout = 30000;

	cmd = (struct scsi_read_dvd_structure *)xs->cmd;
	cmd->opcode = GPCMD_READ_DVD_STRUCTURE;
	cmd->format = s->type;
	cmd->agid = s->disckey.agid << 6;
	_lto2b(xs->datalen, cmd->length);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error == 0)
		memcpy(s->disckey.value, buf->data, sizeof(s->disckey.value));
done:
	dma_free(buf, sizeof(*buf));
	return (error);
}

#define DVD_READ_BCA_BUFLEN (4 + 188)

int
dvd_read_bca(struct cd_softc *sc, union dvd_struct *s)
{
	struct scsi_generic *cmd;
	struct scsi_xfer *xs;
	u_int8_t *buf;
	int error;

	buf = dma_alloc(DVD_READ_BCA_BUFLEN, PR_WAITOK | PR_ZERO);
	if (buf == NULL)
		return (ENOMEM);

	xs = scsi_xs_get(sc->sc_link, SCSI_DATA_IN);
	if (xs == NULL) {
		error = ENOMEM;
		goto done;
	}
	xs->cmdlen = sizeof(*cmd);
	xs->data = buf;
	xs->datalen = DVD_READ_BCA_BUFLEN;
	xs->timeout = 30000;

	cmd = xs->cmd;
	cmd->opcode = GPCMD_READ_DVD_STRUCTURE;
	cmd->bytes[6] = s->type;
	_lto2b(xs->datalen, &cmd->bytes[7]);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error == 0) {
		s->bca.len = _2btol(&buf[0]);
		if (s->bca.len < 12 || s->bca.len > 188)
			return (EIO);
		memcpy(s->bca.value, &buf[4], s->bca.len);
	}
done:
	dma_free(buf, DVD_READ_BCA_BUFLEN);
	return (error);
}

int
dvd_read_manufact(struct cd_softc *sc, union dvd_struct *s)
{
	struct scsi_read_dvd_structure_data *buf;
	struct scsi_read_dvd_structure *cmd;
	struct scsi_xfer *xs;
	int error;

	buf = dma_alloc(sizeof(*buf), PR_WAITOK | PR_ZERO);
	if (buf == NULL)
		return (ENOMEM);

	xs = scsi_xs_get(sc->sc_link, SCSI_DATA_IN);
	if (xs == NULL) {
		error = ENOMEM;
		goto done;
	}
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)buf;
	xs->datalen = sizeof(*buf);
	xs->timeout = 30000;

	cmd = (struct scsi_read_dvd_structure *)xs->cmd;
	cmd->opcode = GPCMD_READ_DVD_STRUCTURE;
	cmd->format = s->type;
	_lto2b(xs->datalen, cmd->length);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error == 0) {
		s->manufact.len = _2btol(buf->len);
		if (s->manufact.len >= 0 && s->manufact.len <= 2048)
			memcpy(s->manufact.value, buf->data, s->manufact.len);
		else
			error = EIO;
	}
done:
	dma_free(buf, sizeof(*buf));
	return (error);
}

int
dvd_read_struct(struct cd_softc *sc, union dvd_struct *s)
{

	switch (s->type) {
	case DVD_STRUCT_PHYSICAL:
		return (dvd_read_physical(sc, s));
	case DVD_STRUCT_COPYRIGHT:
		return (dvd_read_copyright(sc, s));
	case DVD_STRUCT_DISCKEY:
		return (dvd_read_disckey(sc, s));
	case DVD_STRUCT_BCA:
		return (dvd_read_bca(sc, s));
	case DVD_STRUCT_MANUFACT:
		return (dvd_read_manufact(sc, s));
	default:
		return (EINVAL);
	}
}

int
cd_interpret_sense(struct scsi_xfer *xs)
{
	struct scsi_sense_data *sense = &xs->sense;
	struct scsi_link *link = xs->sc_link;
	u_int8_t skey = sense->flags & SSD_KEY;
	u_int8_t serr = sense->error_code & SSD_ERRCODE;

	if (((link->flags & SDEV_OPEN) == 0) ||
	    (serr != SSD_ERRCODE_CURRENT && serr != SSD_ERRCODE_DEFERRED))
		return (scsi_interpret_sense(xs));

	/*
	 * We do custom processing in cd for the unit becoming ready
	 * case.  We do not allow xs->retries to be decremented on the
	 * "Unit Becoming Ready" case. This is because CD drives
	 * report "Unit Becoming Ready" when loading media and can
	 * take a long time.  Rather than having a massive timeout for
	 * all operations (which would cause other problems), we allow
	 * operations to wait (but be interruptable with Ctrl-C)
	 * forever as long as the drive is reporting that it is
	 * becoming ready.  All other cases of not being ready are
	 * handled by the default handler.
	 */
	switch(skey) {
	case SKEY_NOT_READY:
		if ((xs->flags & SCSI_IGNORE_NOT_READY) != 0)
			return (0);
		if (ASC_ASCQ(sense) == SENSE_NOT_READY_BECOMING_READY) {
			SC_DEBUG(link, SDEV_DB1, ("not ready: busy (%#x)\n",
			    sense->add_sense_code_qual));
			/* don't count this as a retry */
			xs->retries++;
			return (scsi_delay(xs, 1));
		}
		break;
	/* XXX more to come here for a few other cases */
	default:
		break;
	}
	return (scsi_interpret_sense(xs));
}

/*
 * Find out from the device what its capacity is.
 */
u_int64_t
cd_size(struct scsi_link *link, int flags, u_int32_t *blksize)
{
	struct scsi_read_cap_data_16 *rdcap16;
	struct scsi_read_capacity_16 *cmd;
	struct scsi_read_cap_data *rdcap;
	struct scsi_read_capacity *cmd10;
	struct scsi_xfer *xs;
	u_int64_t max_addr;
	int error;

	if (blksize != NULL)
		*blksize = 0;

	CLR(flags, SCSI_IGNORE_ILLEGAL_REQUEST);

	/*
	 * Start with a READ CAPACITY(10).
	 */
	rdcap = dma_alloc(sizeof(*rdcap), ((flags & SCSI_NOSLEEP) ?
	    PR_NOWAIT : PR_WAITOK) | PR_ZERO);
	if (rdcap == NULL)
		return (0);

	xs = scsi_xs_get(link, flags | SCSI_DATA_IN | SCSI_SILENT);
	if (xs == NULL) {
		dma_free(rdcap, sizeof(*rdcap));
		return (0);
	}
	xs->cmdlen = sizeof(*cmd10);
	xs->data = (void *)rdcap;
	xs->datalen = sizeof(*rdcap);
	xs->timeout = 20000;

	cmd10 = (struct scsi_read_capacity *)xs->cmd;
	cmd10->opcode = READ_CAPACITY;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error) {
		SC_DEBUG(link, SDEV_DB1, ("READ CAPACITY error (%#x)\n",
		    error));
		dma_free(rdcap, sizeof(*rdcap));
		return (0);
	}

	max_addr = _4btol(rdcap->addr);
	if (blksize != NULL)
		*blksize = _4btol(rdcap->length);
	dma_free(rdcap, sizeof(*rdcap));

	if (SCSISPC(link->inqdata.version) < 3 && max_addr != 0xffffffff)
		goto exit;

	/*
	 * SCSI-3 devices, or devices reporting more than 2^32-1 sectors can
	 * try READ CAPACITY(16).
	 */
	rdcap16 = dma_alloc(sizeof(*rdcap16), ((flags & SCSI_NOSLEEP) ?
	    PR_NOWAIT : PR_WAITOK) | PR_ZERO);
	if (rdcap16 == NULL)
		goto exit;

	xs = scsi_xs_get(link, flags | SCSI_DATA_IN | SCSI_SILENT);
	if (xs == NULL) {
		dma_free(rdcap16, sizeof(*rdcap16));
		goto exit;
	}
	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)rdcap16;
	xs->datalen = sizeof(*rdcap16);
	xs->timeout = 20000;

	cmd = (struct scsi_read_capacity_16 *)xs->cmd;
	cmd->opcode = READ_CAPACITY_16;
	cmd->byte2 = SRC16_SERVICE_ACTION;
	_lto4b(sizeof(*rdcap16), cmd->length);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);
	if (error) {
		SC_DEBUG(link, SDEV_DB1, ("READ CAPACITY 16 error (%#x)\n",
		    error));
		dma_free(rdcap16, sizeof(*rdcap16));
		goto exit;
	}

	max_addr = _8btol(rdcap16->addr);
	if (blksize != NULL)
		*blksize = _4btol(rdcap16->length);
	/* XXX The other READ CAPACITY(16) info could be stored away. */
	dma_free(rdcap16, sizeof(*rdcap16));

	return (max_addr + 1);

exit:
	/* Return READ CAPACITY 10 values. */
	if (max_addr != 0xffffffff)
		return (max_addr + 1);
	else if (blksize != NULL)
		*blksize = 0;
	return (0);
}

#if defined(__macppc__)
int
cd_eject(void)
{
	struct cd_softc *sc;
	int error = 0;

	if (cd_cd.cd_ndevs == 0 || (sc = cd_cd.cd_devs[0]) == NULL)
		return (ENXIO);

	if ((error = disk_lock(&sc->sc_dk)) != 0)
		return (error);

	if (sc->sc_dk.dk_openmask == 0) {
		sc->sc_link->flags |= SDEV_EJECTING;

		scsi_prevent(sc->sc_link, PR_ALLOW,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY |
		    SCSI_SILENT | SCSI_IGNORE_MEDIA_CHANGE);
		sc->sc_link->flags &= ~SDEV_MEDIA_LOADED;

		scsi_start(sc->sc_link, SSS_STOP|SSS_LOEJ, 0);

		sc->sc_link->flags &= ~SDEV_EJECTING;
	}
	disk_unlock(&sc->sc_dk);

	return (error);
}
#endif
@


1.220
log
@To prevent anyone else from stumbling on this (now) archaic bit of
history, nuke all mentions of XS_NO_CCB and the #define.

2006 - 2017. R.I.P.

ok kettenis@@ inferred ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.219 2017/05/04 22:47:27 deraadt Exp $	*/
a49 1
#include <sys/types.h>
@


1.219
log
@Also pass the blk offset to disk_unbusy(), so that it can pass it to
the random subsystem as entropy.  This value is pretty much unknown,
and anyways our entropy input ring does not saturate from knowns.
ok mikeb djm
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.218 2016/03/12 15:16:04 krw Exp $	*/
a621 10

	case XS_NO_CCB:
		/* The adapter is busy, requeue the buf and try it later. */
		disk_unbusy(&sc->sc_dk, bp->b_bcount - xs->resid, bp->b_blkno,
		    bp->b_flags & B_READ);
		bufq_requeue(&sc->sc_bufq, bp);
		scsi_xs_put(xs);
		SET(sc->sc_flags, CDF_WAITING);
		timeout_add(&sc->sc_timeout, 1);
		return;
@


1.218
log
@Standardize on calling local scsi_link variables 'link' instead of
'sc_link'. 'sc_link' is a field in the various device *_softc
structures, where the sc_ prefix was for 'softc'. Reduces potential
mental confusion. Newer code from down under was already using
'link'.

No functional change.

Prompted by bluhm@@'s adventures in scsi. ok dlg@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.217 2015/06/07 19:13:27 krw Exp $	*/
d625 1
a625 1
		disk_unbusy(&sc->sc_dk, bp->b_bcount - xs->resid,
d670 1
a670 1
	disk_unbusy(&sc->sc_dk, bp->b_bcount - xs->resid,
@


1.217
log
@More damned eye searing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.216 2014/12/15 02:11:57 tedu Exp $	*/
d198 1
a198 1
	struct scsi_link *sc_link = sa->sa_sc_link;
d200 1
a200 1
	SC_DEBUG(sc_link, SDEV_DB2, ("cdattach:\n"));
d205 5
a209 5
	sc->sc_link = sc_link;
	sc_link->interpret_sense = cd_interpret_sense;
	sc_link->device_softc = sc;
	if (sc_link->openings > CDOUTSTANDING)
		sc_link->openings = CDOUTSTANDING;
d220 1
a220 1
	if (!(sc_link->flags & SDEV_ATAPI) &&
d226 1
a226 1
	scsi_xsh_set(&sc->sc_xsh, sc_link, cdstart);
d283 1
a283 1
	struct scsi_link *sc_link;
d300 2
a301 2
	sc_link = sc->sc_link;
	SC_DEBUG(sc_link, SDEV_DB1,
d315 1
a315 1
		if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
d329 1
a329 1
		sc_link->flags |= SDEV_OPEN;
d331 1
a331 1
		error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES,
d337 1
a337 1
			error = scsi_start(sc_link, SSS_START,
d350 1
a350 1
		error = scsi_prevent(sc_link, PR_PREVENT,
d357 1
a357 1
		sc_link->flags |= SDEV_MEDIA_LOADED;
d360 1
a360 1
			sc_link->flags &= ~SDEV_MEDIA_LOADED;
d364 1
a364 1
		SC_DEBUG(sc_link, SDEV_DB3, ("Params loaded\n"));
d368 1
a368 1
		SC_DEBUG(sc_link, SDEV_DB3, ("Disklabel fabricated\n"));
d375 2
a376 2
	sc_link->flags |= SDEV_OPEN;
	SC_DEBUG(sc_link, SDEV_DB3, ("open complete\n"));
d381 1
a381 1
		scsi_prevent(sc_link, PR_ALLOW,
d384 1
a384 1
		sc_link->flags &= ~(SDEV_OPEN | SDEV_MEDIA_LOADED);
d516 2
a517 2
	struct scsi_link *sc_link = xs->sc_link;
	struct cd_softc *sc = sc_link->device_softc;
d525 1
a525 1
	SC_DEBUG(sc_link, SDEV_DB2, ("cdstart\n"));
d537 1
a537 1
	if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
d566 2
a567 2
	if (!(sc_link->flags & SDEV_ATAPI) &&
	    !(sc_link->quirks & SDEV_ONLYBIG) &&
d2082 1
a2082 1
	struct scsi_link *sc_link = xs->sc_link;
d2086 1
a2086 1
	if (((sc_link->flags & SDEV_OPEN) == 0) ||
d2107 1
a2107 1
			SC_DEBUG(sc_link, SDEV_DB1, ("not ready: busy (%#x)\n",
d2125 1
a2125 1
cd_size(struct scsi_link *sc_link, int flags, u_int32_t *blksize)
d2148 1
a2148 1
	xs = scsi_xs_get(sc_link, flags | SCSI_DATA_IN | SCSI_SILENT);
d2165 1
a2165 1
		SC_DEBUG(sc_link, SDEV_DB1, ("READ CAPACITY error (%#x)\n",
d2176 1
a2176 1
	if (SCSISPC(sc_link->inqdata.version) < 3 && max_addr != 0xffffffff)
d2188 1
a2188 1
	xs = scsi_xs_get(sc_link, flags | SCSI_DATA_IN | SCSI_SILENT);
d2206 1
a2206 1
		SC_DEBUG(sc_link, SDEV_DB1, ("READ CAPACITY 16 error (%#x)\n",
@


1.216
log
@convert bcopy to memcpy. ok dlg krw
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.215 2014/09/14 14:17:26 jsg Exp $	*/
d252 1
a252 1
		break;			
d475 1
a475 1
	bufq_queue(&sc->sc_bufq, bp);	
d546 2
a547 2
 		return;
 	}
d567 1
a567 1
	    !(sc_link->quirks & SDEV_ONLYBIG) && 
d2235 1
a2235 1
	
@


1.215
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.214 2014/07/12 18:50:25 tedu Exp $	*/
d793 2
a794 2
		bcopy(lp, sc->sc_dk.dk_label, sizeof(*lp));
		free(lp, M_TEMP, 0);
d892 1
a892 1
			bcopy(th, addr, sizeof(*th));
d1647 2
a1648 2
#define	dvd_copy_key(dst, src)		bcopy((src), (dst), DVD_KEY_SIZE)
#define	dvd_copy_challenge(dst, src)	bcopy((src), (dst), DVD_CHALLENGE_SIZE)
d1967 1
a1967 1
		bcopy(buf->data, s->disckey.value, sizeof(s->disckey.value));
d2009 1
a2009 1
		bcopy(&buf[4], s->bca.value, s->bca.len);
d2049 1
a2049 1
			bcopy(buf->data, s->manufact.value, s->manufact.len);
@


1.214
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.213 2013/11/01 17:36:19 krw Exp $	*/
a66 1
#include <sys/proc.h>
@


1.213
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.212 2013/10/03 14:07:41 krw Exp $	*/
d795 1
a795 1
		free(lp, M_TEMP);
@


1.212
log
@Print daddr_t variables with %lld, u_int64_t variables with %llu.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.211 2013/09/27 11:43:19 krw Exp $	*/
d461 1
a461 1
	    bp->b_bcount, bp->b_blkno));
@


1.211
log
@scsi_size() is now used only by cd(4). So move it from scsi_base.c
to cd.c and call it cd_size(), like sd_size() lives in sd.c.

Tweak some daddr_t variables to u_int64_t on the way, when they are
for disk sector numbers, not 512-byte block numbers.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.210 2013/09/15 16:54:52 krw Exp $	*/
d460 1
a460 1
	SC_DEBUG(sc->sc_link, SDEV_DB2, ("cdstrategy: %ld bytes @@ blk %d\n",
@


1.210
log
@cddump() takes a daddr_t parameter. Call that parameter 'blkno' and not
'secno'. This is what sddump() already does and consistant is good.
No function change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.209 2013/09/15 14:35:50 krw Exp $	*/
d109 1
a109 1
		daddr_t disksize;	/* total number sectors */
d136 1
d1621 1
a1621 2
	sc->params.disksize = scsi_size(sc->sc_link, flags,
	    &sc->params.secsize);
d2120 108
@


1.209
log
@Use DL_SECTOBLK() and DL_BLKTOSEC() to clarify code and remove
repeated handrolling of same code. Use daddr_t variable to
calculate daddr_t return values, and u_int64_t variables to
calculate disk sector values.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.208 2013/06/11 16:42:17 deraadt Exp $	*/
d1642 1
a1642 1
cddump(dev_t dev, daddr_t secno, caddr_t va, size_t size)
@


1.208
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.207 2011/07/06 04:49:36 matthew Exp $	*/
d521 1
a521 1
	int secno, nsecs;
d555 1
a555 2
	secno =
	    bp->b_blkno / (sc->sc_dk.dk_label->d_secsize / DEV_BSIZE);
@


1.207
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.206 2011/07/03 15:47:18 matthew Exp $	*/
d109 1
a109 1
		daddr64_t disksize;	/* total number sectors */
d1634 1
a1634 1
daddr64_t
d1643 1
a1643 1
cddump(dev_t dev, daddr64_t secno, caddr_t va, size_t size)
@


1.206
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.205 2011/06/30 16:28:05 matthew Exp $	*/
a468 12
	/*
	 * The transfer must be a whole number of blocks.
	 */
	if ((bp->b_bcount % sc->sc_dk.dk_label->d_secsize) != 0) {
		bp->b_error = EINVAL;
		goto bad;
	}
	/*
	 * If it's a null transfer, return immediately
	 */
	if (bp->b_bcount == 0)
		goto done;
d470 2
a471 5
	/*
	 * Do bounds checking, adjust transfer. if error, process.
	 * If end of partition, just return.
	 */
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label) <= 0)
d486 1
a486 1
bad:
a487 4
done:
	/*
	 * Set the buf to indicate no xfer was done.
	 */
d489 1
@


1.205
log
@Refactor some common open/close/detach disk driver code into
subr_disk.c.  For now just the MI disk drivers.

ok deraadt@@, krw@@; jsing@@ liked the approach too
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.204 2011/06/19 04:55:34 deraadt Exp $	*/
a242 2
	case DVACT_ACTIVATE:
		break;
@


1.204
log
@Use disk_lock_nointr() in the xxclose() routines so that they cannot
be interrupted.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.203 2011/06/19 04:35:06 deraadt Exp $	*/
a266 1
	int bmaj, cmaj, mn;
d270 1
a270 9
	/* Locate the lowest minor number to be detached. */
	mn = DISKMINOR(self->dv_unit, 0);

	for (bmaj = 0; bmaj < nblkdev; bmaj++)
		if (bdevsw[bmaj].d_open == cdopen)
			vdevgone(bmaj, mn, mn + MAXPARTITIONS - 1, VBLK);
	for (cmaj = 0; cmaj < nchrdev; cmaj++)
		if (cdevsw[cmaj].d_open == cdopen)
			vdevgone(cmaj, mn, mn + MAXPARTITIONS - 1, VCHR);
d373 2
a374 4
	/* Check that the partition exists. */
	if (part != RAW_PART && (part >= sc->sc_dk.dk_label->d_npartitions ||
	    sc->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
		error = ENXIO;
a375 1
	}
a376 10
out:	/* Insure only one open at a time. */
	switch (fmt) {
	case S_IFCHR:
		sc->sc_dk.dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		sc->sc_dk.dk_bopenmask |= (1 << part);
		break;
	}
	sc->sc_dk.dk_openmask = sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;
d414 1
a414 9
	switch (fmt) {
	case S_IFCHR:
		sc->sc_dk.dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		sc->sc_dk.dk_bopenmask &= ~(1 << part);
		break;
	}
	sc->sc_dk.dk_openmask = sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;
@


1.203
log
@Use disk_lock/disk_unlock directly and in the same way in these drivers,
rather than using various wrappings.  Convert vnd to using the sc_dk
rwlock instead of using one of its own.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.202 2011/06/06 01:59:49 matthew Exp $	*/
a424 1
	int error;
d434 1
a434 4
	if ((error = disk_lock(&sc->sc_dk)) != 0) {
		device_unref(&sc->sc_dev);
		return error;
	}
@


1.202
log
@Delete the long dead LOCKED and WANTED flags from cd(4), sd(4), and
wd(4).  They haven't been used for 10+ years, since the drivers were
switched to use disk_lock() and disk_unlock() instead.

No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.201 2011/06/05 18:40:33 matthew Exp $	*/
a174 2
#define cdlock(softc)   disk_lock(&(softc)->sc_dk)
#define cdunlock(softc) disk_unlock(&(softc)->sc_dk)
d316 1
a316 1
	if ((error = cdlock(sc)) != 0) {
d411 1
a411 1
	cdunlock(sc);
d435 1
a435 1
	if ((error = cdlock(sc)) != 0) {
d468 1
a468 1
	cdunlock(sc);
d873 1
a873 1
		if ((error = cdlock(sc)) != 0)
d881 1
a881 1
		cdunlock(sc);
d2187 1
a2187 1
	if ((error = cdlock(sc)) != 0)
d2202 1
a2202 1
	cdunlock(sc);
@


1.201
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.200 2011/06/03 21:14:11 matthew Exp $	*/
a102 2
#define	CDF_LOCKED	0x01
#define	CDF_WANTED	0x02
@


1.200
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.199 2011/05/31 17:35:35 matthew Exp $	*/
a104 2
#define	CDF_WLABEL	0x04		/* label is writable */
#define	CDF_LABELLING	0x08		/* writing label */
a811 1
		case DIOCWLABEL:
a879 2
		sc->sc_flags |= CDF_LABELLING;

a884 1
		sc->sc_flags &= ~CDF_LABELLING;
a885 4
		break;

	case DIOCWLABEL:
		error = EBADF;
@


1.199
log
@Change a few of the more common disk drivers (sd, cd, wd, rd, and vnd)
to return EBUSY if the user tries to modify an open partition's offset
or size.  Only sadness can result if a user tries this, and rejecting
it prevents a race between sdstart() and sdstrategy().

Curiously, there was already code in the kernel and in disklabel(8) to
detect/handle this, but it was effectively disabled because the disk
drivers always used something like "/* sc->sc_dk.dk_openmask */ 0",
and this commented out code has existed since even r1.1 in NetBSD.

I had no problems building a release and messing around with
disklabel(8) for a bit with this diff.  Canarying the more common MI
disk drivers until we gain confidence that there aren't any
regressions, then we can switch the remaining drivers.

"I am surprised you got me convinced that this stuff is safe" deraadt@@
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.198 2011/03/17 21:30:24 deraadt Exp $	*/
d528 1
a528 2
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label,
	    (sc->sc_flags & (CDF_WLABEL|CDF_LABELLING)) != 0) <= 0)
@


1.198
log
@use dma_alloc/dma_free instead of malloc to allocate buffers which need
to be in the right address space.
help from matthew and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.197 2010/11/22 12:21:46 krw Exp $	*/
d887 1
a887 1
		    (struct disklabel *)addr, /*cd->sc_dk.dk_openmask : */0);
@


1.197
log
@SCSI devices are assumed to be T_FIXED unless they say otherwise.
cd(4) did not believe any T_FIXED device was its responsibility.
Thus when a USB CD forgot to mention that it is T_REMOV, it appeared
as uk(4).

Make cd(4) accept even T_FIXED devices that claim to be T_CDROM or
T_WORM.

Noticed and fix tested by Rene Maroufi. Closes PR #6513.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.196 2010/09/23 13:11:38 jsing Exp $	*/
d61 1
d926 3
a928 3
		struct ioc_read_subchannel *args
		= (struct ioc_read_subchannel *)addr;
		struct cd_sub_channel_info data;
d930 2
a931 1
		if (len > sizeof(data) ||
d936 1
d938 3
a940 2
		    args->data_format, args->track, &data, len);
		if (error)
d942 2
a943 1
		len = min(len, _2btol(data.header.data_len) +
d945 2
a946 1
		error = copyout(&data, args->data, len);
d950 1
a950 1
		struct ioc_toc_header th;
d952 3
a954 1
		if ((error = cd_read_toc(sc, 0, 0, &th, sizeof(th), 0)) != 0)
d956 1
d958 1
a958 1
			th.len = letoh16(th.len);
d960 3
a962 3
			th.len = betoh16(th.len);
		if (th.len > 0)
			bcopy(&th, addr, sizeof(th));
d965 1
d977 1
a977 1
		toc = malloc(sizeof(*toc), M_TEMP, M_WAITOK | M_ZERO);
d983 1
a983 1
			free(toc, M_TEMP);
d990 1
a990 1
			free(toc, M_TEMP);
d1015 1
a1015 1
		free(toc, M_TEMP);
d1028 1
a1028 1
		toc = malloc(sizeof(*toc), M_TEMP, M_WAITOK | M_ZERO);
d1035 1
a1035 1
			free(toc, M_TEMP);
d1054 1
a1054 1
		free(toc, M_TEMP);
a1198 2
	toc = malloc(sizeof(*toc), M_TEMP, M_WAITOK | M_ZERO);

d1225 1
d1239 1
a1239 1
	free(toc, M_TEMP);
d1253 1
a1253 1
	data = malloc(sizeof(*data), M_TEMP, M_NOWAIT);
d1275 1
a1275 1
	free(data, M_TEMP);
d1286 1
a1286 1
	data = malloc(sizeof(*data), M_TEMP, M_NOWAIT);
d1302 1
a1302 1
	free(data, M_TEMP);
d1314 1
a1314 1
	data = malloc(sizeof(*data), M_TEMP, M_NOWAIT);
d1324 1
a1324 1
		free(data, M_TEMP);
d1338 1
a1338 1
		free(data, M_TEMP);
d1354 1
a1354 1
	free(data, M_TEMP);
d1393 1
a1393 1
	data = malloc(sizeof(*data), M_TEMP, M_NOWAIT);
d1416 1
a1416 1
	free(data, M_TEMP);
d1463 1
a1463 1
	toc = malloc(sizeof(*toc), M_TEMP, M_WAITOK | M_ZERO);
d1502 1
a1502 1
	free(toc, M_TEMP);
d1721 2
d1728 1
a1728 1
	u_int8_t buf[20];
d1731 4
d1736 4
a1739 2
	if (xs == NULL)
		return (ENOMEM);
d1742 1
a1742 3
	xs->data = (void *)&buf;

	bzero(buf, sizeof(buf));
d1759 1
a1759 1
		return (error);
d1772 1
a1772 1
		return (error);
d1786 1
a1786 1
		return (error);
d1805 1
a1805 1
		return (error);
d1819 1
a1819 1
		return (error);
d1835 1
a1835 1
		return (error);
d1853 1
a1853 1
		return (error);
d1862 1
a1862 2

		return (error);
d1881 1
a1881 1
		return (error);
d1894 1
a1894 2

		return (error);
d1898 2
a1899 1
		return (ENOTTY);
d1901 3
d1906 1
d1913 1
a1913 1
	u_int8_t buf[4 + 4 * 20], *bufp;
d1916 4
d1921 4
a1924 2
	if (xs == NULL)
		return (ENOMEM);
d1927 1
a1927 1
	xs->datalen = sizeof(buf);
a1929 2
	bzero(buf, sizeof(buf));

d1933 1
a1933 1
	_lto2b(sizeof(buf), &cmd->bytes[7]);
d1959 2
d1964 1
d1970 1
a1970 1
	u_int8_t buf[8];
d1973 4
d1978 4
a1981 2
	if (xs == NULL)
		return (ENOMEM);
d1984 1
a1984 1
	xs->datalen = sizeof(buf);
a1986 2
	bzero(buf, sizeof(buf));

d1990 1
a1990 1
	_lto2b(sizeof(buf), &cmd->bytes[7]);
d2001 2
a2002 1

d2014 1
a2014 1
	buf = malloc(sizeof(*buf), M_TEMP, M_WAITOK | M_ZERO);
d2020 2
a2021 2
		free(buf, M_TEMP);
		return (ENOMEM);
d2032 1
a2032 1
	_lto2b(sizeof(*buf), cmd->length);
d2039 2
a2040 2

	free(buf, M_TEMP);
d2044 2
d2051 1
a2051 1
	u_int8_t buf[4 + 188];
d2054 4
d2059 4
a2062 2
	if (xs == NULL)
		return (ENOMEM);
d2065 1
a2065 1
	xs->datalen = sizeof(buf);
a2067 2
	bzero(buf, sizeof(buf));

d2071 1
a2071 1
	_lto2b(sizeof(buf), &cmd->bytes[7]);
d2082 2
d2095 1
a2095 1
	buf = malloc(sizeof(*buf), M_TEMP, M_WAITOK | M_ZERO);
d2101 2
a2102 2
		free(buf, M_TEMP);
		return (ENOMEM);
d2112 1
a2112 1
	_lto2b(sizeof(*buf), cmd->length);
d2124 2
a2125 2

	free(buf, M_TEMP);
@


1.196
log
@Introduce a DKF_NOLABELREAD flag, which is used by a device to prevent
automatic reading of disklabel on attach.

ok deraadt@@ miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.194 2010/09/21 12:20:53 krw Exp $	*/
d164 2
d167 2
@


1.195
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d232 1
@


1.194
log
@Add a real DIOCGPDINFO, allowing access to the physical information
about the device rather than the contents of whichever disklabel
was read. Tweak whitespace in sd.c to make the code appearance
consistant.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.193 2010/09/20 02:51:52 deraadt Exp $	*/
d772 1
a772 1
	return (physio(cdstrategy, NULL, dev, B_READ, cdminphys, uio));
d779 1
a779 1
	return (physio(cdstrategy, NULL, dev, B_WRITE, cdminphys, uio));
@


1.193
log
@bufq_drain() does not need to be done in deactivate; we only need
to deactivate transactions we are currently doing.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.192 2010/09/14 04:02:43 dlg Exp $	*/
d853 5
a858 1
	case DIOCGPDINFO:
@


1.192
log
@scsi_xsh_del the xs handler on DEACTIVATE.

same change as sd.c r1.212. matthew@@ pointed out that cd(4) and
st(4) would need the same change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.191 2010/09/12 01:54:48 krw Exp $	*/
a256 1
		bufq_drain(&sc->sc_bufq);
@


1.191
log
@Make cd the same as sd by calling the cd_parms member of the softc 'params'
rather than 'sc_params'. No change to .o file.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.190 2010/09/11 22:40:10 krw Exp $	*/
d258 1
@


1.190
log
@Be more ruthlessly consistent in variable names for blk/block ==
512 == DEV_BSIZE units and variable-sized physical device 'sectors'.
I hope this reduces confusion a bit more. No change to .o files.

ok for intent miod@@, with tweak.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.189 2010/09/08 15:16:22 jsing Exp $	*/
d113 1
a113 1
	} sc_params;
d1182 1
a1182 1
	lp->d_secsize = sc->sc_params.secsize;
d1186 1
a1186 1
	lp->d_ncylinders = (sc->sc_params.disksize / 100) + 1;
d1197 1
a1197 1
	DL_SETDSIZE(lp, sc->sc_params.disksize);
d1666 2
a1667 2
	sc->sc_params.secsize = 2048;
	sc->sc_params.disksize = 400000;
d1672 2
a1673 2
	sc->sc_params.disksize = scsi_size(sc->sc_link, flags,
	    &sc->sc_params.secsize);
d1675 3
a1677 3
	if ((sc->sc_params.secsize < 512) ||
	    ((sc->sc_params.secsize & 511) != 0))
		sc->sc_params.secsize = 2048;	/* some drives lie ! */
d1679 2
a1680 2
	if (sc->sc_params.disksize < 100)
		sc->sc_params.disksize = 400000;
@


1.189
log
@Introduce a disk_lookup() function which calls device_lookup(), before
verifying that the resulting device is present on the disklist. This
avoids a race whereby the disk driver can be accessed as soon as the
softc has been allocated, but before the disk has completed
initialisation and has called disk_attach() (up until this point
dk_label is still a null pointer).

Cut cd(4), sd(4) and wd(4) across to disk_lookup(). All callers of
disk_attach() need to be tested and cut over in due course.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.188 2010/09/08 14:47:12 jsing Exp $	*/
d111 1
a111 1
		u_int32_t blksize;
d576 1
a576 1
	int blkno, nblks;
d610 1
a610 1
	blkno =
d613 2
a614 2
	blkno += DL_GETPOFFSET(p);
	nblks = howmany(bp->b_bcount, sc->sc_dk.dk_label->d_secsize);
d624 2
a625 2
	    ((blkno & 0x1fffff) == blkno) &&
	    ((nblks & 0xff) == nblks)) {
d632 2
a633 2
		_lto3b(blkno, cmd_small->addr);
		cmd_small->length = nblks & 0xff;
d642 2
a643 2
		_lto4b(blkno, cmd_big->addr);
		_lto2b(nblks, cmd_big->length);
d1182 1
a1182 1
	lp->d_secsize = sc->sc_params.blksize;
d1406 1
a1406 1
cd_play(struct cd_softc *sc, int blkno, int nblks)
d1420 2
a1421 2
	_lto4b(blkno, cmd->blk_addr);
	_lto2b(nblks, cmd->xfer_len);
d1666 1
a1666 1
	sc->sc_params.blksize = 2048;
d1673 1
a1673 1
	    &sc->sc_params.blksize);
d1675 3
a1677 3
	if ((sc->sc_params.blksize < 512) ||
	    ((sc->sc_params.blksize & 511) != 0))
		sc->sc_params.blksize = 2048;	/* some drives lie ! */
d1694 1
a1694 1
cddump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
@


1.188
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.186 2010/09/07 04:42:15 deraadt Exp $	*/
d176 1
a176 1
#define cdlookup(unit) (struct cd_softc *)device_lookup(&cd_cd, (unit))
@


1.187
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d232 1
a232 1
	disk_attach(&sc->sc_dk);
@


1.186
log
@rely on SCSI_AUTOCONF for cd_resume instead of wrapping it in a workq
(which creates a potential race against cd detach)
discussed with krw and dlg seperately
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.185 2010/09/01 01:38:12 dlg Exp $	*/
a116 1
	void *sc_cdpwrhook;		/* our power hook */
a147 3
void	cd_powerhook(int why, void *arg);
void	cd_resume(struct cd_softc *);

a230 4
	if ((sc->sc_cdpwrhook = powerhook_establish(cd_powerhook, sc)) == NULL)
		printf("%s: WARNING: unable to establish power hook\n",
		    sc->sc_dev.dv_xname);

d251 3
a253 1
			cd_resume(sc);
a262 17
void
cd_resume(struct cd_softc *sc)
{
	scsi_prevent(sc->sc_link, PR_PREVENT,
	    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE |
	    SCSI_SILENT | SCSI_AUTOCONF);
}

void
cd_powerhook(int why, void *arg)
{
	struct cd_softc *sc = arg;

	if (why == DVACT_RESUME && sc->sc_dk.dk_openmask != 0)
		cd_resume(sc);
}

a279 4

	/* Get rid of the power hook. */
	if (sc->sc_cdpwrhook != NULL)
		powerhook_disestablish(sc->sc_cdpwrhook);
@


1.185
log
@make struct bufq a member of the softc for devices that use it,
rather than it being a pointer to something that needs to be allocated
at attach. since all these devices need a bufq to operate, it makes
sense to have it allocated as part of the softc and get bufq_init
to just initialise all its fields. it also gets rid of the possibility
that you wont be able to allocate the bufq struct during attach,
which is something you dont want to happen.

secondly, it consistently implements a split between wrapper functions
and the per discipline implementation of the bufq handlers. it
consistently does the locking in the wrappers rather than doing
half in the wrappers and the other half in the implementations.

it also consistently handles the outstanding bufq bq pointer in the
wrappers.

this hides most of the implementation inside kern_bufq.c. the only
stuff left in buf.h is for the bits each implementation needs to
put inside struct buf.

tested by thib@@ krw@@ and me
ok thib@@ matthew@@
no objection from krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.184 2010/08/31 16:41:24 deraadt Exp $	*/
a117 2

	struct workq_task sc_resume_wqt;
d150 1
a150 1
void	cd_resume(void *, void *);
d259 1
a259 2
			workq_queue_task(NULL, &sc->sc_resume_wqt, 0,
			    cd_resume, sc, NULL);
d270 1
a270 1
cd_resume(void *arg1, void *arg2)
a271 2
	struct cd_softc *sc = arg1;

d274 1
a274 1
	    SCSI_SILENT);
d283 1
a283 1
		cd_resume(sc, NULL);
@


1.184
log
@Change the powerhook into an activation routine.  It has to use a workq.
There is a bit of concern that this workq can race against a detach
happening... any solutions from the peanut gallery?
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.183 2010/08/30 02:47:56 matthew Exp $	*/
d114 1
a114 1
	struct bufq	*sc_bufq;
d222 1
a222 1
	sc->sc_bufq = bufq_init(BUFQ_DEFAULT);
d266 1
a266 1
		bufq_drain(sc->sc_bufq);
d297 1
a297 1
	bufq_drain(sc->sc_bufq);
d314 1
a314 1
	bufq_destroy(sc->sc_bufq);
d559 1
a559 1
	BUFQ_QUEUE(sc->sc_bufq, bp);	
d625 1
a625 1
		bufq_drain(sc->sc_bufq);
d630 1
a630 1
	bp = BUFQ_DEQUEUE(sc->sc_bufq);
d694 1
a694 1
	else if (BUFQ_PEEK(sc->sc_bufq))
d715 1
a715 1
		BUFQ_REQUEUE(sc->sc_bufq, bp);
@


1.183
log
@Avoid possible aliasing-related compiler issues by always writing to
cmd->opcode through the type casted command pointer rather than
through xs->cmd->opcode.

Requested by deraadt@@; ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.182 2010/08/28 20:23:22 matthew Exp $	*/
d118 2
d152 1
d255 9
a263 1

d272 18
a2131 15
}

void
cd_powerhook(int why, void *arg)
{
	struct cd_softc *sc = arg;

	/*
	 * When resuming, hardware may have forgotten we locked it. So if
	 * there are any open partitions, lock the CD.
	 */
	if (why == PWR_RESUME && sc->sc_dk.dk_openmask != 0)
		scsi_prevent(sc->sc_link, PR_PREVENT,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE |
		    SCSI_SILENT);
@


1.182
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.181 2010/07/28 23:47:43 krw Exp $	*/
a1352 1
	xs->cmd->opcode = LOAD_UNLOAD;
d1357 1
a1417 1
	xs->cmd->opcode = PLAY;
d1422 1
a1504 1
	xs->cmd->opcode = PLAY_MSF;
d1509 1
a1535 1
	xs->cmd->opcode = PAUSE;
d1540 1
a1583 1
	xs->cmd->opcode = READ_SUBCHANNEL;
d1590 1
a1618 1
	xs->cmd->opcode = READ_TOC;
d1627 1
d1723 2
d1727 3
a1729 3
		xs->cmd->opcode = GPCMD_REPORT_KEY;
		xs->cmd->bytes[8] = 8;
		xs->cmd->bytes[9] = 0 | (0 << 6);
d1741 3
a1743 3
		xs->cmd->opcode = GPCMD_REPORT_KEY;
		xs->cmd->bytes[8] = 16;
		xs->cmd->bytes[9] = 1 | (a->lsc.agid << 6);
d1754 3
a1756 3
		xs->cmd->opcode = GPCMD_REPORT_KEY;
		xs->cmd->bytes[8] = 12;
		xs->cmd->bytes[9] = 2 | (a->lsk.agid << 6);
d1768 4
a1771 4
		xs->cmd->opcode = GPCMD_REPORT_KEY;
		_lto4b(a->lstk.lba, &xs->cmd->bytes[1]);
		xs->cmd->bytes[8] = 12;
		xs->cmd->bytes[9] = 4 | (a->lstk.agid << 6);
d1787 3
a1789 3
		xs->cmd->opcode = GPCMD_REPORT_KEY;
		xs->cmd->bytes[8] = 8;
		xs->cmd->bytes[9] = 5 | (a->lsasf.agid << 6);
d1801 3
a1803 3
		xs->cmd->opcode = GPCMD_SEND_KEY;
		xs->cmd->bytes[8] = 16;
		xs->cmd->bytes[9] = 1 | (a->hsc.agid << 6);
d1817 3
a1819 3
		xs->cmd->opcode = GPCMD_SEND_KEY;
		xs->cmd->bytes[8] = 12;
		xs->cmd->bytes[9] = 3 | (a->hsk.agid << 6);
d1835 2
a1836 2
		xs->cmd->opcode = GPCMD_REPORT_KEY;
		xs->cmd->bytes[9] = 0x3f | (a->lsa.agid << 6);
d1845 3
a1847 3
		xs->cmd->opcode = GPCMD_REPORT_KEY;
		xs->cmd->bytes[8] = 8;
		xs->cmd->bytes[9] = 8 | (0 << 6);
d1864 3
a1866 3
		xs->cmd->opcode = GPCMD_SEND_KEY;
		xs->cmd->bytes[8] = 8;
		xs->cmd->bytes[9] = 6 | (0 << 6);
a1894 1
	xs->cmd->opcode = GPCMD_READ_DVD_STRUCTURE;
d1902 4
a1905 2
	xs->cmd->bytes[6] = s->type;
	_lto2b(sizeof(buf), &xs->cmd->bytes[7]);
d1907 1
a1907 1
	xs->cmd->bytes[5] = s->physical.layer_num;
a1944 1
	xs->cmd->opcode = GPCMD_READ_DVD_STRUCTURE;
d1952 4
a1955 2
	xs->cmd->bytes[6] = s->type;
	_lto2b(sizeof(buf), &xs->cmd->bytes[7]);
d1957 1
a1957 1
	xs->cmd->bytes[5] = s->copyright.layer_num;
a1986 1
	xs->cmd->opcode = GPCMD_READ_DVD_STRUCTURE;
d1993 1
a2018 1
	xs->cmd->opcode = GPCMD_READ_DVD_STRUCTURE;
d2026 4
a2029 2
	xs->cmd->bytes[6] = s->type;
	_lto2b(sizeof(buf), &xs->cmd->bytes[7]);
a2059 1
	xs->cmd->opcode = GPCMD_READ_DVD_STRUCTURE;
d2066 1
@


1.181
log
@DVD_INVALIDATE_AGID is a 'no payload' operation, so don't set
xs->datalen and reset xs->data to NULL. This prevents a spurious
attempt to setup (dma map, etc) and possibly attempt data tranfser.

In line with what Linux and FreeBSD do as far as I can tell.

Reduces the delay before my DVD starts playing its movie.

Idea to also set xs->data to NULL from matthew@@.

"No objection" matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.180 2010/07/25 16:34:41 krw Exp $	*/
a163 2
struct dkdriver cddkdriver = { cdstrategy };

a217 1
	sc->sc_dk.dk_driver = &cddkdriver;
@


1.180
log
@Missing SCSI_DATA_IN flag in dvd_read_copyright() caused
confusion. Fixes at least my usb DVD reader and The Blue Tick.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.179 2010/07/25 05:35:42 krw Exp $	*/
d1838 1
a1838 1
		xs->datalen = 16;
@


1.179
log
@Let DVD's play again. Logic reversal prevented copyright reading.

Symptoms noted by oga@@. actual bug spotted by dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.178 2010/07/22 15:59:46 matthew Exp $	*/
d1942 1
a1942 1
	xs = scsi_xs_get(sc->sc_link, 0);
@


1.178
log
@Fix a few more scsi_scsi_cmd() removal regressions, caught by
-Wuninitialized.

Silly typo in my first diff noticed by oga@@ and krw@@; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.177 2010/07/22 04:54:24 matthew Exp $	*/
d1961 1
a1961 1
	if (error) {
@


1.177
log
@Appropriately set SCSI_DATA_IN or SCSI_DATA_OUT depending on type of
dvd_auth command.  Fixes regression from scsi_scsi_cmd() removal.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.176 2010/07/22 00:31:06 krw Exp $	*/
d1593 1
d1893 1
a1893 1
	xs = scsi_xs_get(xs->sc_link, SCSI_DATA_IN);
d1977 4
d1982 2
a1983 1
	if (xs == NULL)
d1985 1
d1992 1
a1992 6
	buf = malloc(sizeof(*buf), M_TEMP, M_WAITOK | M_ZERO);
	if (buf == NULL) {
		scsi_xs_put(xs);
		return (ENOMEM);
	}

d2049 4
d2054 2
a2055 1
	if (xs == NULL)
d2057 1
a2062 6

	buf = malloc(sizeof(*buf), M_TEMP, M_WAITOK | M_ZERO);
	if (buf == NULL) {
		scsi_xs_put(xs);
		return (ENOMEM);
	}
@


1.176
log
@Eliminate scsi_scsi_cmd() now that ss(4) is gone and with it the
last bastardized sync and buf call through scsi_scsi_cmd(). Flatten
code to call scsi_xs_sync() directly for all commands.

Airplane typos shaken out by various.

ok dlg@@ matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.175 2010/07/01 05:11:18 krw Exp $	*/
d1716 1
a1716 1
	xs = scsi_xs_get(sc->sc_link, SCSI_DATA_IN);
d1731 1
d1745 1
d1758 1
d1773 1
d1791 1
d1807 1
d1823 1
d1849 1
d1870 1
@


1.175
log
@Die struct scsi_device! Die! Instead, save a pointer to the routine
to interpret sense errors. This is initialized to the basic
interpretation routine, and specific scsi drivers (sd/st/cd) can
replace this with their own. While here kill EJUSTRETURN dance and
make more specialized interpretation routines directly call the
basic routine if desired.

Fixes by matthew@@ to my first diff. Most original work by dlg@@.

ok matthew@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.174 2010/07/01 03:01:37 matthew Exp $	*/
d1349 14
a1362 1
	struct scsi_load_unload cmd;
d1364 2
a1365 4
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = LOAD_UNLOAD;
	cmd.options = options;    /* ioctl uses ATAPI values */
	cmd.slot = slot;
d1367 1
a1367 2
	return (scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), 0, 0, SCSI_RETRIES, 200000, NULL, 0));
d1414 3
a1416 1
	struct scsi_play scsi_cmd;
d1418 15
a1432 7
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = PLAY;
	_lto4b(blkno, scsi_cmd.blk_addr);
	_lto2b(nblks, scsi_cmd.xfer_len);
	return (scsi_scsi_cmd(sc->sc_link,
	    (struct scsi_generic *)&scsi_cmd, sizeof(scsi_cmd),
	    0, 0, SCSI_RETRIES, 200000, NULL, 0));
d1501 18
a1518 1
	struct scsi_play_msf scsi_cmd;
d1520 4
a1523 11
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = PLAY_MSF;
	scsi_cmd.start_m = startm;
	scsi_cmd.start_s = starts;
	scsi_cmd.start_f = startf;
	scsi_cmd.end_m = endm;
	scsi_cmd.end_s = ends;
	scsi_cmd.end_f = endf;
	return (scsi_scsi_cmd(sc->sc_link,
	    (struct scsi_generic *)&scsi_cmd, sizeof(scsi_cmd),
	    0, 0, SCSI_RETRIES, 20000, NULL, 0));
d1532 16
a1547 1
	struct scsi_pause scsi_cmd;
d1549 1
a1549 5
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = PAUSE;
	scsi_cmd.resume = go;
	return scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, SCSI_RETRIES, 2000, NULL, 0);
d1558 13
a1570 2
	return scsi_scsi_cmd(sc->sc_link, 0, 0, 0, 0, SCSI_RETRIES, 2000, NULL,
	    SCSI_RESET);
d1580 12
a1591 1
	struct scsi_read_subchannel scsi_cmd;
a1592 2
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = READ_SUBCHANNEL;
d1594 10
a1603 8
		scsi_cmd.byte2 |= CD_MSF;
	scsi_cmd.byte3 = SRS_SUBQ;
	scsi_cmd.subchan_format = format;
	scsi_cmd.track = track;
	_lto2b(len, scsi_cmd.data_len);
	return scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(struct scsi_read_subchannel), (u_char *)data, len,
	    SCSI_RETRIES, 5000, NULL, SCSI_DATA_IN|SCSI_SILENT);
d1613 13
a1625 1
	struct scsi_read_toc scsi_cmd;
a1626 1
	bzero(&scsi_cmd, sizeof(scsi_cmd));
d1629 2
a1630 1
	scsi_cmd.opcode = READ_TOC;
d1632 9
a1640 8
		scsi_cmd.byte2 |= CD_MSF;
	scsi_cmd.from_track = start;
	_lto2b(len, scsi_cmd.data_len);
	scsi_cmd.control = control;

	return scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(struct scsi_read_toc), (u_char *)data, len, SCSI_RETRIES,
	    5000, NULL, SCSI_DATA_IN | SCSI_IGNORE_ILLEGAL_REQUEST);
d1711 2
a1712 1
	struct scsi_generic cmd;
d1716 7
a1722 1
	bzero(cmd.bytes, sizeof(cmd.bytes));
d1727 11
a1737 9
		cmd.opcode = GPCMD_REPORT_KEY;
		cmd.bytes[8] = 8;
		cmd.bytes[9] = 0 | (0 << 6);
		error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, 8,
		    SCSI_RETRIES, 30000, NULL, SCSI_DATA_IN);
		if (error)
			return (error);
		a->lsa.agid = buf[7] >> 6;
		return (0);
d1740 10
a1749 9
		cmd.opcode = GPCMD_REPORT_KEY;
		cmd.bytes[8] = 16;
		cmd.bytes[9] = 1 | (a->lsc.agid << 6);
		error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, 16,
		    SCSI_RETRIES, 30000, NULL, SCSI_DATA_IN);
		if (error)
			return (error);
		dvd_copy_challenge(a->lsc.chal, &buf[4]);
		return (0);
d1752 11
a1762 9
		cmd.opcode = GPCMD_REPORT_KEY;
		cmd.bytes[8] = 12;
		cmd.bytes[9] = 2 | (a->lsk.agid << 6);
		error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, 12,
		    SCSI_RETRIES, 30000, NULL, SCSI_DATA_IN);
		if (error)
			return (error);
		dvd_copy_key(a->lsk.key, &buf[4]);
		return (0);
d1765 16
a1780 13
		cmd.opcode = GPCMD_REPORT_KEY;
		_lto4b(a->lstk.lba, &cmd.bytes[1]);
		cmd.bytes[8] = 12;
		cmd.bytes[9] = 4 | (a->lstk.agid << 6);
		error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, 12,
		    SCSI_RETRIES, 30000, NULL, SCSI_DATA_IN);
		if (error)
			return (error);
		a->lstk.cpm = (buf[4] >> 7) & 1;
		a->lstk.cp_sec = (buf[4] >> 6) & 1;
		a->lstk.cgms = (buf[4] >> 4) & 3;
		dvd_copy_key(a->lstk.title_key, &buf[5]);
		return (0);
d1783 11
a1793 9
		cmd.opcode = GPCMD_REPORT_KEY;
		cmd.bytes[8] = 8;
		cmd.bytes[9] = 5 | (a->lsasf.agid << 6);
		error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, 8,
		    SCSI_RETRIES, 30000, NULL, SCSI_DATA_IN);
		if (error)
			return (error);
		a->lsasf.asf = buf[7] & 1;
		return (0);
d1796 3
a1798 3
		cmd.opcode = GPCMD_SEND_KEY;
		cmd.bytes[8] = 16;
		cmd.bytes[9] = 1 | (a->hsc.agid << 6);
d1801 8
a1808 6
		error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, 16,
		    SCSI_RETRIES, 30000, NULL, SCSI_DATA_OUT);
		if (error)
			return (error);
		a->type = DVD_LU_SEND_KEY1;
		return (0);
d1811 3
a1813 3
		cmd.opcode = GPCMD_SEND_KEY;
		cmd.bytes[8] = 12;
		cmd.bytes[9] = 3 | (a->hsk.agid << 6);
d1816 8
a1823 3
		error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, 12,
		    SCSI_RETRIES, 30000, NULL, SCSI_DATA_OUT);
		if (error) {
d1825 1
a1825 4
			return (error);
		}
		a->type = DVD_AUTH_ESTABLISHED;
		return (0);
d1828 8
a1835 7
		cmd.opcode = GPCMD_REPORT_KEY;
		cmd.bytes[9] = 0x3f | (a->lsa.agid << 6);
		error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, 16,
		    SCSI_RETRIES, 30000, NULL, 0);
		if (error)
			return (error);
		return (0);
d1838 16
a1853 13
		cmd.opcode = GPCMD_REPORT_KEY;
		cmd.bytes[8] = 8;
		cmd.bytes[9] = 8 | (0 << 6);
		error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, 8,
		    SCSI_RETRIES, 30000, NULL, SCSI_DATA_IN);
		if (error)
			return (error);
		a->lrpcs.type = (buf[4] >> 6) & 3;
		a->lrpcs.vra = (buf[4] >> 3) & 7;
		a->lrpcs.ucca = (buf[4]) & 7;
		a->lrpcs.region_mask = buf[5];
		a->lrpcs.rpc_scheme = buf[6];
		return (0);
d1856 3
a1858 3
		cmd.opcode = GPCMD_SEND_KEY;
		cmd.bytes[8] = 8;
		cmd.bytes[9] = 6 | (0 << 6);
d1861 6
a1866 5
		error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, 8,
		    SCSI_RETRIES, 30000, NULL, SCSI_DATA_OUT);
		if (error)
			return (error);
		return (0);
d1869 1
d1877 3
a1879 1
	struct scsi_generic cmd;
d1881 10
a1890 3
	int error;
	struct dvd_layer *layer;
	int i;
a1891 1
	bzero(cmd.bytes, sizeof(cmd.bytes));
d1893 27
a1919 25
	cmd.opcode = GPCMD_READ_DVD_STRUCTURE;
	cmd.bytes[6] = s->type;
	_lto2b(sizeof(buf), &cmd.bytes[7]);

	cmd.bytes[5] = s->physical.layer_num;
	error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, sizeof(buf),
	    SCSI_RETRIES, 30000, NULL, SCSI_DATA_IN);
	if (error)
		return (error);
	for (i = 0, bufp = &buf[4], layer = &s->physical.layer[0]; i < 4;
	    i++, bufp += 20, layer++) {
		bzero(layer, sizeof(*layer));
		layer->book_version = bufp[0] & 0xf;
		layer->book_type = bufp[0] >> 4;
		layer->min_rate = bufp[1] & 0xf;
		layer->disc_size = bufp[1] >> 4;
		layer->layer_type = bufp[2] & 0xf;
		layer->track_path = (bufp[2] >> 4) & 1;
		layer->nlayers = (bufp[2] >> 5) & 3;
		layer->track_density = bufp[3] & 0xf;
		layer->linear_density = bufp[3] >> 4;
		layer->start_sector = _4btol(&bufp[4]);
		layer->end_sector = _4btol(&bufp[8]);
		layer->end_sector_l0 = _4btol(&bufp[12]);
		layer->bca = bufp[16] >> 7;
d1921 1
a1921 1
	return (0);
d1927 2
a1928 1
	struct scsi_generic cmd;
d1932 9
a1940 1
	bzero(cmd.bytes, sizeof(cmd.bytes));
d1942 15
a1956 12
	cmd.opcode = GPCMD_READ_DVD_STRUCTURE;
	cmd.bytes[6] = s->type;
	_lto2b(sizeof(buf), &cmd.bytes[7]);

	cmd.bytes[5] = s->copyright.layer_num;
	error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, sizeof(buf),
	    SCSI_RETRIES, 30000, NULL, SCSI_DATA_IN);
	if (error)
		return (error);
	s->copyright.cpst = buf[4];
	s->copyright.rmi = buf[5];
	return (0);
a1961 1
	struct scsi_read_dvd_structure cmd;
d1963 2
d1967 9
d1977 2
a1978 1
	if (buf == NULL)
d1980 8
a1988 9
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = GPCMD_READ_DVD_STRUCTURE;
	cmd.format = s->type;
	cmd.agid = s->disckey.agid << 6;
	_lto2b(sizeof(*buf), cmd.length);

	error = scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), (u_char *)buf, sizeof(*buf), SCSI_RETRIES, 30000, NULL,
	    SCSI_DATA_IN);
d1999 2
a2000 1
	struct scsi_generic cmd;
d2004 9
a2012 1
	bzero(cmd.bytes, sizeof(cmd.bytes));
d2014 14
a2027 13
	cmd.opcode = GPCMD_READ_DVD_STRUCTURE;
	cmd.bytes[6] = s->type;
	_lto2b(sizeof(buf), &cmd.bytes[7]);

	error = scsi_scsi_cmd(sc->sc_link, &cmd, sizeof(cmd), buf, sizeof(buf),
	    SCSI_RETRIES, 30000, NULL, SCSI_DATA_IN);
	if (error)
		return (error);
	s->bca.len = _2btol(&buf[0]);
	if (s->bca.len < 12 || s->bca.len > 188)
		return (EIO);
	bcopy(&buf[4], s->bca.value, s->bca.len);
	return (0);
a2032 1
	struct scsi_read_dvd_structure cmd;
d2034 2
d2038 9
d2048 2
a2049 1
	if (buf == NULL)
d2051 8
a2059 8
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = GPCMD_READ_DVD_STRUCTURE;
	cmd.format = s->type;
	_lto2b(sizeof(*buf), cmd.length);

	error = scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), (u_char *)buf, sizeof(*buf), SCSI_RETRIES, 30000, NULL,
	    SCSI_DATA_IN);
@


1.174
log
@Restore setting xs->bp; fixes ncr(4) on VAX.

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.173 2010/06/30 17:38:03 krw Exp $	*/
a165 7
struct scsi_device cd_switch = {
	cd_interpret_sense,
	NULL,			/* we have a queue, which is started by this */
	NULL,			/* we do not have an async handler */
	NULL,			/* no per driver cddone */
};

d212 1
a212 1
	sc_link->device = &cd_switch;
d697 4
a700 1
		error = scsi_interpret_sense(xs);
d1961 1
a1961 1
		return (EJUSTRETURN); /* let the generic code handle it */
d1991 1
a1991 1
	return (EJUSTRETURN); /* use generic handler in scsi_base */
@


1.173
log
@Bring cd(4) into line with sd(4) and st(4) by implementing CDF_DYING
to better handle detaching.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.172 2010/06/28 08:35:46 jsing Exp $	*/
d666 1
@


1.172
log
@Move disk_attach() to the end of the attach functions, at which point the
disk is now ready to handle I/O.

ok krw@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.170 2010/06/11 12:02:44 krw Exp $	*/
d107 1
d256 1
d264 2
a265 3
		/*
		 * Nothing to do; we key off the device's DVF_ACTIVATE.
		 */
d319 4
d443 4
d498 6
a503 1
	if ((sc = cdlookup(DISKUNIT(bp->b_dev))) == NULL) {
d555 1
a555 1
	 * Correctly set the buf to indicate a completed xfer
d595 5
d806 4
@


1.171
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d224 1
a224 1
	 * Initialize and attach the disk structure.
a228 1
	disk_attach(&sc->sc_dk);
d246 3
@


1.170
log
@Restore an unusual XS_SENSE semantic that inadvertantly got lost
in the great re-write. If the scsi device *_interpret_sense()
function returns 0 that means there was no error.

Fixes restore(8) problems seen on certain tape drives.

Found and fix tested by Percey Piper. Suggestions from Matthew
Dempsky. Thanks!

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.169 2010/06/03 11:58:20 dlg Exp $	*/
d1138 1
a1138 1
		error = scsi_do_ioctl(sc->sc_link, dev, cmd, addr, flag, p);
@


1.169
log
@cut cd(4) over to use xshandlers. based on the sd(4) diff and includes the
WAITING fix.

tested by sthen@@ thib@@ sobrado@@ krw@@ on atapiscsi, atascsi, and real scsi
ok krw@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.168 2010/06/01 15:27:16 thib Exp $	*/
d662 1
a662 1
	int s;
d682 7
a688 1
		if (scsi_interpret_sense(xs) != ERESTART)
@


1.168
log
@move cd, st & ss over to bufq's again.

Tested by myself and krw.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.167 2010/05/18 04:41:14 dlg Exp $	*/
d114 1
a114 2
	struct mutex sc_start_mtx;
	u_int sc_start_count;
d119 1
a119 1
void	cdstart(void *);
d167 1
a167 1
	cdstart,		/* we have a queue, which is started by this */
a213 2
	mtx_init(&sc->sc_start_mtx, IPL_BIO);

d240 3
a242 1
	timeout_set(&sc->sc_timeout, cdstart, sc);
d467 1
d530 1
a530 1
	cdstart(sc);
d566 1
a566 1
cdstart(void *v)
d568 2
a569 2
	struct cd_softc *sc = v;
	struct scsi_link *sc_link = sc->sc_link;
a574 1
	struct scsi_xfer *xs;
a575 1
	int s;
d579 8
a586 4
	mtx_enter(&sc->sc_start_mtx);
	sc->sc_start_count++;
	if (sc->sc_start_count > 1) {
		mtx_leave(&sc->sc_start_mtx);
a588 19
	mtx_leave(&sc->sc_start_mtx);
	CLR(sc->sc_flags, CDF_WAITING);
restart:
	while (!ISSET(sc->sc_flags, CDF_WAITING) &&
	    (bp = BUFQ_DEQUEUE(sc->sc_bufq)) != NULL) {
		/*
		 * If the device has become invalid, abort all the
		 * reads and writes until all files have been closed and
		 * re-opened
		 */
		if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
			bp->b_error = EIO;
			bp->b_flags |= B_ERROR;
			bp->b_resid = bp->b_bcount;
			s = splbio();
			biodone(bp);
			splx(s);
			continue;
		}
d590 19
a608 5
		xs = scsi_xs_get(sc_link, SCSI_NOSLEEP);
		if (xs == NULL) {
			BUFQ_REQUEUE(sc->sc_bufq, bp);
			break;
		}
d610 8
d619 1
a619 4
		 * We have a buf, now we should make a command
		 *
		 * First, translate the block to absolute and put it in terms
		 * of the logical blocksize of the device.
d621 7
a627 8
		blkno =
		    bp->b_blkno / (sc->sc_dk.dk_label->d_secsize / DEV_BSIZE);
		p = &sc->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
		blkno += DL_GETPOFFSET(p);
		nblks = howmany(bp->b_bcount, sc->sc_dk.dk_label->d_secsize);

		read = (bp->b_flags & B_READ);

d629 1
a629 2
		 *  Fill out the scsi command.  If the transfer will
		 *  fit in a "small" cdb, use it.
d631 24
a654 45
		if (!(sc_link->flags & SDEV_ATAPI) &&
		    !(sc_link->quirks & SDEV_ONLYBIG) && 
		    ((blkno & 0x1fffff) == blkno) &&
		    ((nblks & 0xff) == nblks)) {
			/*
			 * We can fit in a small cdb.
			 */
			cmd_small = (struct scsi_rw *)xs->cmd;
			cmd_small->opcode = read ?
			    READ_COMMAND : WRITE_COMMAND;
			_lto3b(blkno, cmd_small->addr);
			cmd_small->length = nblks & 0xff;
			xs->cmdlen = sizeof(*cmd_small);
		} else {
			/*
			 * Need a large cdb.
			 */
			cmd_big = (struct scsi_rw_big *)xs->cmd;
			cmd_big->opcode = read ?
			    READ_BIG : WRITE_BIG;
			_lto4b(blkno, cmd_big->addr);
			_lto2b(nblks, cmd_big->length);
			xs->cmdlen = sizeof(*cmd_big);
		}

		xs->flags |= (read ? SCSI_DATA_IN : SCSI_DATA_OUT);
		xs->timeout = 30000;
		xs->data = bp->b_data;
		xs->datalen = bp->b_bcount;
		xs->done = cd_buf_done;
		xs->cookie = bp;

		/* Instrumentation. */
		disk_busy(&sc->sc_dk);

		scsi_xs_exec(xs);
	}
	mtx_enter(&sc->sc_start_mtx);
	sc->sc_start_count--;
	if (sc->sc_start_count != 0) {
		sc->sc_start_count = 1;
		mtx_leave(&sc->sc_start_mtx);
		goto restart;
	}
	mtx_leave(&sc->sc_start_mtx);
d676 1
a676 1
		SET(sc->sc_flags, CDF_WAITING); /* break out of cdstart loop */
a714 1
	cdstart(sc); /* restart io */
@


1.167
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.166 2010/04/23 15:25:21 jsing Exp $	*/
d113 1
a113 2
	struct buf sc_buf_queue;
	struct mutex sc_buf_mtx;
a214 1
	mtx_init(&sc->sc_buf_mtx, IPL_BIO);
d231 1
d276 1
a276 1
	scsi_buf_killqueue(&sc->sc_buf_queue, &sc->sc_buf_mtx);
d293 1
d523 2
a524 6
	/*
	 * Place it in the queue of disk activities for this disk
	 */
	mtx_enter(&sc->sc_buf_mtx);
	disksort(&sc->sc_buf_queue, bp);
	mtx_leave(&sc->sc_buf_mtx);
d591 1
a591 1
	    (bp = scsi_buf_dequeue(&sc->sc_buf_queue, &sc->sc_buf_mtx)) != NULL) {
d609 1
a609 1
			scsi_buf_requeue(&sc->sc_buf_queue, bp, &sc->sc_buf_mtx);
d695 1
a695 1
		scsi_buf_requeue(&sc->sc_buf_queue, bp, &sc->sc_buf_mtx);
@


1.166
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.164 2010/02/28 21:17:00 krw Exp $	*/
d69 1
@


1.165
log
@i snuck fine grained locking into the midlayer as part of all the
other stuff ive been doing in here. everything that needs protection
inside the midlayer and the scsi device drivers (sd, cd, etc) uses
mutexes now.

this pushes splbio out of the midlayer. splbio is only taken before
biodone is called now.

ok beck@@ marco@@ krw@@ deraadt@@. theyre all terrified, but they all
say if we're going to do then now is the right stage of the dev
cycle.
@
text
@a1200 2
	lp->d_rpm = 300;
	lp->d_interleave = 1;
@


1.164
log
@If no TOC header is read, report EIO. Even if the command finished
ok.

Stops cdio(1) from printing bogus TOC info.

ok marco@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.163 2010/01/15 05:50:31 krw Exp $	*/
d686 1
a687 2
	splassert(IPL_BIO);
         
d735 1
d737 1
@


1.164.2.1
log
@MFC, original commit from krw@@:
----------------------------
Restore an unusual XS_SENSE semantic that inadvertantly got lost
in the great re-write. If the scsi device *_interpret_sense()
function returns 0 that means there was no error.

Fixes restore(8) problems seen on certain tape drives.

Found and fix tested by Percey Piper. Suggestions from Matthew
Dempsky. Thanks!

ok dlg@@
----------------------------

ok krw@@ and dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.164 2010/02/28 21:17:00 krw Exp $	*/
a685 1
	int error;
d707 1
a707 7
		error = scsi_interpret_sense(xs);
		if (error == 0) {
			bp->b_error = 0;
			bp->b_resid = xs->resid;
			break;
		}
		if (error != ERESTART)
@


1.163
log
@Abstract and merge the manual buf queue manipulating functions into
one place for easier debugging and maintenance. No intended functional
changes.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.162 2010/01/15 05:31:38 krw Exp $	*/
d945 4
a948 1
		bcopy(&th, addr, sizeof(th));
@


1.162
log
@Restore XS_BUSY delay behaviour for buf i/o. Same as for sync path.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.161 2010/01/12 23:33:57 dlg Exp $	*/
a123 1
void	cd_kill_buffers(struct cd_softc *);
a140 3
struct buf *cd_buf_dequeue(struct cd_softc *);
void	cd_buf_requeue(struct cd_softc *, struct buf *);

d276 1
a276 1
	cd_kill_buffers(sc);
a551 27
struct buf *
cd_buf_dequeue(struct cd_softc *sc)
{
	struct buf *bp;

	mtx_enter(&sc->sc_buf_mtx);
	bp = sc->sc_buf_queue.b_actf;
	if (bp != NULL)
		sc->sc_buf_queue.b_actf = bp->b_actf;
	if (sc->sc_buf_queue.b_actf == NULL)
		sc->sc_buf_queue.b_actb = &sc->sc_buf_queue.b_actf;
	mtx_leave(&sc->sc_buf_mtx);

	return (bp);
}

void
cd_buf_requeue(struct cd_softc *sc, struct buf *bp)
{
	mtx_enter(&sc->sc_buf_mtx);
	bp->b_actf = sc->sc_buf_queue.b_actf;
	sc->sc_buf_queue.b_actf = bp;
	if (bp->b_actf == NULL)
		sc->sc_buf_queue.b_actb = &bp->b_actf;
	mtx_leave(&sc->sc_buf_mtx);
}

d594 1
a594 2
	    (bp = cd_buf_dequeue(sc)) != NULL) {

d612 1
a612 1
			cd_buf_requeue(sc, bp);
d699 1
a699 1
		cd_buf_requeue(sc, bp);
a1986 18
}

/*
 * Remove unprocessed buffers from queue.
 */
void
cd_kill_buffers(struct cd_softc *sc)
{
	struct buf *bp;
	int s;

	while ((bp = cd_buf_dequeue(sc)) != NULL) {
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		s = splbio();
		biodone(bp);
		splx(s);
	}
@


1.161
log
@bring sd.c r1.180 over to the other drivers now using the antisemaphore,
ie, dont clear the WAITING flag when restarting the xxstart loops.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.160 2010/01/11 08:56:17 krw Exp $	*/
d741 1
a742 1
		/* FALLTHROUGH */
d744 6
d751 1
d756 1
a757 1
		/* FALLTHROUGH */
@


1.160
log
@Bring mutex protections to ststart, cdstart and ssstart, as already
done in sd. Make names consistant across all three.

ok dlg@@ tested (cd) & ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.159 2010/01/11 00:44:40 krw Exp $	*/
d622 1
a623 1
	CLR(sc->sc_flags, CDF_WAITING);
@


1.159
log
@Be as careful with sd/cd buf queue manipulations as was found necessary for
st's queue manipulations. i.e. ensure b_actb is correctly updated as the
queue becomes empty or has an i/o requeued on it.

Tested on claudio@@'s backup crashing box.

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.158 2010/01/09 21:12:06 dlg Exp $	*/
d113 1
a113 1
	struct mutex sc_queue_mtx;
d115 1
d219 1
a219 1
	mtx_init(&sc->sc_queue_mtx, IPL_BIO);
d529 1
a529 1
	mtx_enter(&sc->sc_queue_mtx);
d531 1
a531 1
	mtx_leave(&sc->sc_queue_mtx);
d561 1
a561 1
	mtx_enter(&sc->sc_queue_mtx);
d567 1
a567 1
	mtx_leave(&sc->sc_queue_mtx);
d575 1
a575 1
	mtx_enter(&sc->sc_queue_mtx);
d580 1
a580 1
	mtx_leave(&sc->sc_queue_mtx);
a613 3
	/*
	 * Check if the device has room for another command
	 */
d615 8
d703 8
@


1.158
log
@dont try to prevent multiple concurrent runs of a devices start routine
by setting flags around the loop. there is a race which can prevent
necessary work being completed by any of the currently running instances
of xxstart.

the caveat with the removal of this code is because multiple xxstarts can
be running at the same time they can cause io reordering, but that is less
of a problem than no io.

found by and fix tested by claudio@@
debugged with krw@@ claudio@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.156 2009/12/13 03:29:01 dlg Exp $	*/
d564 2
d577 2
@


1.157
log
@nothing needs to see cd_softc except the driver, so move it into cd.c

ok marco@@ guenther@@
@
text
@a106 1
#define CDF_STARTING	0x200
a612 9
	mtx_enter(&sc->sc_start_mtx);
	if (ISSET(sc->sc_flags, CDF_STARTING)) {
		mtx_leave(&sc->sc_start_mtx);
		return;
	}

	SET(sc->sc_flags, CDF_STARTING);
	mtx_leave(&sc->sc_start_mtx);

a692 3
	mtx_enter(&sc->sc_start_mtx);
	CLR(sc->sc_flags, CDF_STARTING);
	mtx_leave(&sc->sc_start_mtx);
@


1.156
log
@prefix all softc members with sc_, not just most of them.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.155 2009/12/13 01:20:14 dlg Exp $	*/
d95 24
@


1.155
log
@use sc consistently as the name of the pointer to the softc variable, not
cd.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.154 2009/12/12 13:03:56 dlg Exp $	*/
d219 1
a219 1
		sc->flags |= CDF_ANCIENT;
d499 1
a499 1
	    (sc->flags & (CDF_WLABEL|CDF_LABELLING)) != 0) <= 0)
d506 1
a506 1
	disksort(&sc->buf_queue, bp);
d538 1
a538 1
	bp = sc->buf_queue.b_actf;
d540 1
a540 1
		sc->buf_queue.b_actf = bp->b_actf;
d550 2
a551 2
	bp->b_actf = sc->buf_queue.b_actf;
	sc->buf_queue.b_actf = bp;
d591 1
a591 1
	if (ISSET(sc->flags, CDF_STARTING)) {
d596 1
a596 1
	SET(sc->flags, CDF_STARTING);
d599 2
a600 2
	CLR(sc->flags, CDF_WAITING);
	while (!ISSET(sc->flags, CDF_WAITING) &&
d680 1
a680 1
	CLR(sc->flags, CDF_STARTING);
d704 1
a704 1
		SET(sc->flags, CDF_WAITING); /* break out of cdstart loop */
d758 1
a758 1
	if (sc->flags & CDF_ANCIENT) {
d872 1
a872 1
		sc->flags |= CDF_LABELLING;
d879 1
a879 1
		sc->flags &= ~CDF_LABELLING;
d1177 1
a1177 1
	lp->d_secsize = sc->params.blksize;
d1181 1
a1181 1
	lp->d_ncylinders = (sc->params.disksize / 100) + 1;
d1192 1
a1192 1
	DL_SETDSIZE(lp, sc->params.disksize);
d1586 2
a1587 2
	sc->params.blksize = 2048;
	sc->params.disksize = 400000;
d1592 2
a1593 2
	sc->params.disksize = scsi_size(sc->sc_link, flags,
	    &sc->params.blksize);
d1595 3
a1597 2
	if ((sc->params.blksize < 512) || ((sc->params.blksize & 511) != 0))
		sc->params.blksize = 2048;	/* some drives lie ! */
d1599 2
a1600 2
	if (sc->params.disksize < 100)
		sc->params.disksize = 400000;
@


1.154
log
@move cd(4) from using scsi_scsi_cmd over to scsi_xs_exec for doing io.
this brings it in line with the new midlayer changes.

mostly borrowed from sd(4) changes.

tested by krw@@ and me
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.153 2009/12/06 01:12:52 dlg Exp $	*/
d189 1
a191 1
	struct cd_softc *cd = (struct cd_softc *)self;
d195 2
a196 2
	mtx_init(&cd->sc_queue_mtx, IPL_BIO);
	mtx_init(&cd->sc_start_mtx, IPL_BIO);
d201 1
a201 1
	cd->sc_link = sc_link;
d203 1
a203 1
	sc_link->device_softc = cd;
d210 3
a212 3
	cd->sc_dk.dk_driver = &cddkdriver;
	cd->sc_dk.dk_name = cd->sc_dev.dv_xname;
	disk_attach(&cd->sc_dk);
d219 1
a219 1
		cd->flags |= CDF_ANCIENT;
d223 1
a223 1
	timeout_set(&cd->sc_timeout, cdstart, cd);
d225 1
a225 1
	if ((cd->sc_cdpwrhook = powerhook_establish(cd_powerhook, cd)) == NULL)
d227 1
a227 1
		    cd->sc_dev.dv_xname);
d253 1
a253 1
	struct cd_softc *cd = (struct cd_softc *)self;
d256 1
a256 1
	cd_kill_buffers(cd);
d269 2
a270 2
	if (cd->sc_cdpwrhook != NULL)
		powerhook_disestablish(cd->sc_cdpwrhook);
d273 1
a273 1
	disk_detach(&cd->sc_dk);
d285 1
a285 1
	struct cd_softc *cd;
d293 2
a294 2
	cd = cdlookup(unit);
	if (cd == NULL)
d297 1
a297 1
	sc_link = cd->sc_link;
d302 2
a303 2
	if ((error = cdlock(cd)) != 0) {
		device_unref(&cd->sc_dev);
d307 1
a307 1
	if (cd->sc_dk.dk_openmask != 0) {
d355 1
a355 1
		if (cd_get_parms(cd, (rawopen ? SCSI_SILENT : 0) |
d364 1
a364 1
		cdgetdisklabel(dev, cd, cd->sc_dk.dk_label, 0);
d369 2
a370 2
	if (part != RAW_PART && (part >= cd->sc_dk.dk_label->d_npartitions ||
	    cd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
d378 1
a378 1
		cd->sc_dk.dk_copenmask |= (1 << part);
d381 1
a381 1
		cd->sc_dk.dk_bopenmask |= (1 << part);
d384 1
a384 1
	cd->sc_dk.dk_openmask = cd->sc_dk.dk_copenmask | cd->sc_dk.dk_bopenmask;
d390 1
a390 1
	if (cd->sc_dk.dk_openmask == 0) {
d397 2
a398 2
	cdunlock(cd);
	device_unref(&cd->sc_dev);
d409 1
a409 1
	struct cd_softc *cd;
d413 2
a414 2
	cd = cdlookup(DISKUNIT(dev));
	if (cd == NULL)
d417 2
a418 2
	if ((error = cdlock(cd)) != 0) {
		device_unref(&cd->sc_dev);
d424 1
a424 1
		cd->sc_dk.dk_copenmask &= ~(1 << part);
d427 1
a427 1
		cd->sc_dk.dk_bopenmask &= ~(1 << part);
d430 1
a430 1
	cd->sc_dk.dk_openmask = cd->sc_dk.dk_copenmask | cd->sc_dk.dk_bopenmask;
d432 1
a432 1
	if (cd->sc_dk.dk_openmask == 0) {
d435 1
a435 1
		scsi_prevent(cd->sc_link, PR_ALLOW,
d438 1
a438 1
		cd->sc_link->flags &= ~(SDEV_OPEN | SDEV_MEDIA_LOADED);
d440 2
a441 2
		if (cd->sc_link->flags & SDEV_EJECTING) {
			scsi_start(cd->sc_link, SSS_STOP|SSS_LOEJ, 0);
d443 1
a443 1
			cd->sc_link->flags &= ~SDEV_EJECTING;
d446 1
a446 1
		timeout_del(&cd->sc_timeout);
d449 1
a449 1
	cdunlock(cd);
d451 1
a451 1
	device_unref(&cd->sc_dev);
d463 1
a463 1
	struct cd_softc *cd;
d466 1
a466 1
	if ((cd = cdlookup(DISKUNIT(bp->b_dev))) == NULL) {
d471 1
a471 1
	SC_DEBUG(cd->sc_link, SDEV_DB2, ("cdstrategy: %ld bytes @@ blk %d\n",
d477 1
a477 1
	if ((cd->sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
d484 1
a484 1
	if ((bp->b_bcount % cd->sc_dk.dk_label->d_secsize) != 0) {
d498 2
a499 2
	if (bounds_check_with_label(bp, cd->sc_dk.dk_label,
	    (cd->flags & (CDF_WLABEL|CDF_LABELLING)) != 0) <= 0)
d505 3
a507 3
	mtx_enter(&cd->sc_queue_mtx);
	disksort(&cd->buf_queue, bp);
	mtx_leave(&cd->sc_queue_mtx);
d513 1
a513 1
	cdstart(cd);
d515 1
a515 1
	device_unref(&cd->sc_dev);
d528 2
a529 2
	if (cd != NULL)
		device_unref(&cd->sc_dev);
d574 2
a575 2
	struct cd_softc *cd = v;
	struct scsi_link *sc_link = cd->sc_link;
d590 3
a592 3
	mtx_enter(&cd->sc_start_mtx);
	if (ISSET(cd->flags, CDF_STARTING)) {
		mtx_leave(&cd->sc_start_mtx);
d596 2
a597 2
	SET(cd->flags, CDF_STARTING);
	mtx_leave(&cd->sc_start_mtx);
d599 3
a601 3
	CLR(cd->flags, CDF_WAITING);
	while (!ISSET(cd->flags, CDF_WAITING) &&
	    (bp = cd_buf_dequeue(cd)) != NULL) {
d620 1
a620 1
			cd_buf_requeue(cd, bp);
d631 2
a632 2
		    bp->b_blkno / (cd->sc_dk.dk_label->d_secsize / DEV_BSIZE);
		p = &cd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
d634 1
a634 1
		nblks = howmany(bp->b_bcount, cd->sc_dk.dk_label->d_secsize);
d675 1
a675 1
		disk_busy(&cd->sc_dk);
d679 3
a681 3
	mtx_enter(&cd->sc_start_mtx);
	CLR(cd->flags, CDF_STARTING);
	mtx_leave(&cd->sc_start_mtx);
d740 1
a740 1
	struct cd_softc *cd;
d743 2
a744 2
	cd = cdlookup(DISKUNIT(bp->b_dev));
	if (cd == NULL)
d758 2
a759 2
	if (cd->flags & CDF_ANCIENT) {
		max = cd->sc_dk.dk_label->d_secsize * 0xff;
d765 1
a765 1
	(*cd->sc_link->adapter->scsi_minphys)(bp, cd->sc_link);
d767 1
a767 1
	device_unref(&cd->sc_dev);
d791 1
a791 1
	struct cd_softc *cd;
d796 2
a797 2
	cd = cdlookup(DISKUNIT(dev));
	if (cd == NULL)
d800 1
a800 1
	SC_DEBUG(cd->sc_link, SDEV_DB2, ("cdioctl 0x%lx\n", cmd));
d805 1
a805 1
	if ((cd->sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
d836 1
a836 1
			if ((cd->sc_link->flags & SDEV_OPEN) == 0)
d847 2
a848 2
		cdgetdisklabel(dev, cd, lp, 0);
		bcopy(lp, cd->sc_dk.dk_label, sizeof(*lp));
d853 1
a853 1
		*(struct disklabel *)addr = *(cd->sc_dk.dk_label);
d857 1
a857 1
		((struct partinfo *)addr)->disklab = cd->sc_dk.dk_label;
d859 1
a859 1
		    &cd->sc_dk.dk_label->d_partitions[DISKPART(dev)];
d869 1
a869 1
		if ((error = cdlock(cd)) != 0)
d872 1
a872 1
		cd->flags |= CDF_LABELLING;
d874 1
a874 1
		error = setdisklabel(cd->sc_dk.dk_label,
d879 2
a880 2
		cd->flags &= ~CDF_LABELLING;
		cdunlock(cd);
d890 1
a890 1
		if ((error = cd_set_pa_immed(cd, 0)) != 0)
d892 1
a892 1
		error = cd_play_tracks(cd, args->start_track,
d899 1
a899 1
		if ((error = cd_set_pa_immed(cd, 0)) != 0)
d901 1
a901 1
		error = cd_play_msf(cd, args->start_m, args->start_s,
d908 1
a908 1
		if ((error = cd_set_pa_immed(cd, 0)) != 0)
d910 1
a910 1
		error = cd_play(cd, args->blk, args->len);
d923 1
a923 1
		error = cd_read_subchannel(cd, args->address_format,
d935 1
a935 1
		if ((error = cd_read_toc(cd, 0, 0, &th, sizeof(th), 0)) != 0)
d937 1
a937 1
		if (cd->sc_link->quirks & ADEV_LITTLETOC)
d963 1
a963 1
		error = cd_read_toc(cd, te->address_format, te->starting_track,
d975 1
a975 1
				if (cd->sc_link->quirks & ADEV_LITTLETOC) {
d983 1
a983 1
		if (cd->sc_link->quirks & ADEV_LITTLETOC) {
d1006 1
a1006 1
		error = cd_read_toc(cd, 0, 0, toc,
d1016 1
a1016 1
		if (cd->sc_link->quirks & ADEV_LITTLETOC) {
d1023 1
a1023 1
		if (cd->sc_link->quirks & ADEV_LITTLETOC)
d1036 1
a1036 1
		error = cd_setchan(cd, arg->patch[0], arg->patch[1],
d1043 1
a1043 1
		error = cd_getvol(cd, arg, 0);
d1049 1
a1049 1
		error = cd_setvol(cd, arg, 0);
d1054 1
a1054 1
		error = cd_setchan(cd, BOTH_CHANNEL, BOTH_CHANNEL, MUTE_CHANNEL,
d1059 1
a1059 1
		error = cd_setchan(cd, LEFT_CHANNEL, RIGHT_CHANNEL,
d1064 1
a1064 1
		error = cd_setchan(cd, MUTE_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL,
d1069 1
a1069 1
		error = cd_setchan(cd, LEFT_CHANNEL, LEFT_CHANNEL, MUTE_CHANNEL,
d1074 1
a1074 1
		error = cd_setchan(cd, RIGHT_CHANNEL, RIGHT_CHANNEL,
d1079 1
a1079 1
		error = cd_pause(cd, 1);
d1083 1
a1083 1
		error = cd_pause(cd, 0);
d1086 1
a1086 1
		error = scsi_start(cd->sc_link, SSS_START, 0);
d1090 1
a1090 1
		error = scsi_start(cd->sc_link, SSS_STOP, 0);
d1095 1
a1095 1
		error = scsi_start(cd->sc_link, SSS_START|SSS_LOEJ,
d1109 1
a1109 1
		cd->sc_link->flags |= SDEV_EJECTING;
d1112 1
a1112 1
		error = scsi_prevent(cd->sc_link, PR_ALLOW, 0);
d1115 1
a1115 1
		error = scsi_prevent(cd->sc_link, PR_PREVENT, 0);
d1118 1
a1118 1
		error = scsi_prevent(cd->sc_link,
d1122 1
a1122 1
		cd->sc_link->flags |= (SDEV_DB1 | SDEV_DB2);
d1125 1
a1125 1
		cd->sc_link->flags &= ~(SDEV_DB1 | SDEV_DB2);
d1129 1
a1129 1
		error = cd_reset(cd);
d1134 1
a1134 1
		error = cd_load_unload(cd, args->options, args->slot);
d1139 1
a1139 1
		error = dvd_auth(cd, (union dvd_authinfo *)addr);
d1142 1
a1142 1
		error = dvd_read_struct(cd, (union dvd_struct *)addr);
d1149 1
a1149 1
		error = scsi_do_ioctl(cd->sc_link, dev, cmd, addr, flag, p);
d1155 1
a1155 1
	device_unref(&cd->sc_dev);
d1167 1
a1167 1
cdgetdisklabel(dev_t dev, struct cd_softc *cd, struct disklabel *lp,
d1177 1
a1177 1
	lp->d_secsize = cd->params.blksize;
d1181 1
a1181 1
	lp->d_ncylinders = (cd->params.disksize / 100) + 1;
d1183 1
a1183 1
	if (cd->sc_link->flags & SDEV_ATAPI) {
d1192 1
a1192 1
	DL_SETDSIZE(lp, cd->params.disksize);
d1205 1
a1205 1
	if (cd_load_toc(cd, toc, CD_LBA_FORMAT)) {
d1226 1
a1226 1
cd_setchan(struct cd_softc *cd, int p0, int p1, int p2, int p3, int flags)
d1236 1
a1236 1
	error = scsi_do_mode_sense(cd->sc_link, AUDIO_PAGE, data,
d1247 1
a1247 1
			error = scsi_mode_select_big(cd->sc_link, SMS_PF,
d1250 1
a1250 1
			error = scsi_mode_select(cd->sc_link, SMS_PF,
d1259 1
a1259 1
cd_getvol(struct cd_softc *cd, struct ioc_vol *arg, int flags)
d1269 1
a1269 1
	error = scsi_do_mode_sense(cd->sc_link, AUDIO_PAGE, data,
d1286 1
a1286 1
cd_setvol(struct cd_softc *cd, const struct ioc_vol *arg, int flags)
d1297 1
a1297 1
	error = scsi_do_mode_sense(cd->sc_link,
d1312 1
a1312 1
	error = scsi_do_mode_sense(cd->sc_link, AUDIO_PAGE, data,
d1327 1
a1327 1
		error = scsi_mode_select_big(cd->sc_link, SMS_PF,
d1330 1
a1330 1
		error = scsi_mode_select(cd->sc_link, SMS_PF,
d1338 1
a1338 1
cd_load_unload(struct cd_softc *cd, int options, int slot)
d1347 1
a1347 1
	return (scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&cmd,
d1352 1
a1352 1
cd_set_pa_immed(struct cd_softc *cd, int flags)
d1358 1
a1358 1
	if (cd->sc_link->flags & SDEV_ATAPI)
d1366 1
a1366 1
	error = scsi_do_mode_sense(cd->sc_link, AUDIO_PAGE, data,
d1377 1
a1377 1
				error = scsi_mode_select_big(cd->sc_link,
d1380 1
a1380 1
				error = scsi_mode_select(cd->sc_link, SMS_PF,
d1393 1
a1393 1
cd_play(struct cd_softc *cd, int blkno, int nblks)
d1401 1
a1401 1
	return (scsi_scsi_cmd(cd->sc_link,
d1410 1
a1410 1
cd_play_tracks(struct cd_softc *cd, int strack, int sindex, int etrack,
d1424 1
a1424 1
	if ((error = cd_load_toc(cd, toc, CD_MSF_FORMAT)) != 0)
d1455 1
a1455 1
	error = cd_play_msf(cd, toc->entries[strack].addr.msf.minute,
d1469 1
a1469 1
cd_play_msf(struct cd_softc *cd, int startm, int starts, int startf, int endm,
d1482 1
a1482 1
	return (scsi_scsi_cmd(cd->sc_link,
d1491 1
a1491 1
cd_pause(struct cd_softc *cd, int go)
d1498 1
a1498 1
	return scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&scsi_cmd,
d1506 1
a1506 1
cd_reset(struct cd_softc *cd)
d1508 1
a1508 1
	return scsi_scsi_cmd(cd->sc_link, 0, 0, 0, 0, SCSI_RETRIES, 2000, NULL,
d1516 1
a1516 1
cd_read_subchannel(struct cd_softc *cd, int mode, int format, int track,
d1529 1
a1529 1
	return scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&scsi_cmd,
d1538 1
a1538 1
cd_read_toc(struct cd_softc *cd, int mode, int start, void *data, int len,
d1553 1
a1553 1
	return scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&scsi_cmd,
d1559 1
a1559 1
cd_load_toc(struct cd_softc *cd, struct cd_toc *toc, int fmt)
d1563 1
a1563 1
	error = cd_read_toc(cd, 0, 0, toc, sizeof(toc->header), 0);
d1571 1
a1571 1
		error = cd_read_toc(cd, fmt, 0, toc, len, 0);
d1583 1
a1583 1
cd_get_parms(struct cd_softc *cd, int flags)
d1586 2
a1587 2
	cd->params.blksize = 2048;
	cd->params.disksize = 400000;
d1589 1
a1589 1
	if (cd->sc_link->quirks & ADEV_NOCAPACITY)
d1592 2
a1593 2
	cd->params.disksize = scsi_size(cd->sc_link, flags,
	    &cd->params.blksize);
d1595 2
a1596 2
	if ((cd->params.blksize < 512) || ((cd->params.blksize & 511) != 0))
		cd->params.blksize = 2048;	/* some drives lie ! */
d1598 2
a1599 2
	if (cd->params.disksize < 100)
		cd->params.disksize = 400000;
d1623 1
a1623 1
dvd_auth(struct cd_softc *cd, union dvd_authinfo *a)
d1637 1
a1637 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, 8,
d1648 1
a1648 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, 16,
d1659 1
a1659 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, 12,
d1671 1
a1671 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, 12,
d1685 1
a1685 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, 8,
d1698 1
a1698 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, 16,
d1711 1
a1711 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, 12,
d1723 1
a1723 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, 16,
d1733 1
a1733 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, 8,
d1750 1
a1750 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, 8,
d1762 1
a1762 1
dvd_read_physical(struct cd_softc *cd, union dvd_struct *s)
d1777 1
a1777 1
	error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, sizeof(buf),
d1802 1
a1802 1
dvd_read_copyright(struct cd_softc *cd, union dvd_struct *s)
d1815 1
a1815 1
	error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, sizeof(buf),
d1825 1
a1825 1
dvd_read_disckey(struct cd_softc *cd, union dvd_struct *s)
d1841 1
a1841 1
	error = scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&cmd,
d1852 1
a1852 1
dvd_read_bca(struct cd_softc *cd, union dvd_struct *s)
d1864 1
a1864 1
	error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, sizeof(buf),
d1876 1
a1876 1
dvd_read_manufact(struct cd_softc *cd, union dvd_struct *s)
d1891 1
a1891 1
	error = scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&cmd,
d1907 1
a1907 1
dvd_read_struct(struct cd_softc *cd, union dvd_struct *s)
d1912 1
a1912 1
		return (dvd_read_physical(cd, s));
d1914 1
a1914 1
		return (dvd_read_copyright(cd, s));
d1916 1
a1916 1
		return (dvd_read_disckey(cd, s));
d1918 1
a1918 1
		return (dvd_read_bca(cd, s));
d1920 1
a1920 1
		return (dvd_read_manufact(cd, s));
d1929 1
a1929 1
	struct cd_softc *cd = arg;
d1935 2
a1936 2
	if (why == PWR_RESUME && cd->sc_dk.dk_openmask != 0)
		scsi_prevent(cd->sc_link, PR_PREVENT,
d1988 1
a1988 1
cd_kill_buffers(struct cd_softc *cd)
d1993 1
a1993 1
	while ((bp = cd_buf_dequeue(cd)) != NULL) {
d2006 1
a2006 1
	struct cd_softc *cd;
d2009 1
a2009 1
	if (cd_cd.cd_ndevs == 0 || (cd = cd_cd.cd_devs[0]) == NULL)
d2012 1
a2012 1
	if ((error = cdlock(cd)) != 0)
d2015 2
a2016 2
	if (cd->sc_dk.dk_openmask == 0) {
		cd->sc_link->flags |= SDEV_EJECTING;
d2018 1
a2018 1
		scsi_prevent(cd->sc_link, PR_ALLOW,
d2021 1
a2021 1
		cd->sc_link->flags &= ~SDEV_MEDIA_LOADED;
d2023 1
a2023 1
		scsi_start(cd->sc_link, SSS_STOP|SSS_LOEJ, 0);
d2025 1
a2025 1
		cd->sc_link->flags &= ~SDEV_EJECTING;
d2027 1
a2027 1
	cdunlock(cd);
@


1.153
log
@nitems(array) is prettier than sizeof(array)/sizeof(array[0])
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.152 2009/12/06 01:11:44 dlg Exp $	*/
d97 1
a97 1
void	cdrestart(void *);
a99 1
void	cddone(struct scsi_xfer *);
d118 3
d150 1
a150 1
	cddone,			/* deal with stats at interrupt time */
d195 3
d223 1
a223 1
	timeout_set(&cd->sc_timeout, cdrestart, cd);
a501 2
	s = splbio();

d505 1
d507 1
a515 1
	splx(s);
d532 23
d569 1
a569 1
 * cdstart() is called at splbio from cdstrategy, cdrestart and scsi_done
d576 4
a579 6
	struct buf *bp = 0;
	struct buf *dp;
	struct scsi_rw_big cmd_big;
	struct scsi_rw cmd_small;
	struct scsi_generic *cmdp;
	int blkno, nblks, cmdlen, error;
d581 3
a583 2

	splassert(IPL_BIO);
a588 11
	while (sc_link->openings > 0) {
		/*
		 * there is excess capacity, but a special waits
		 * It'll need the adapter as soon as we clear out of the
		 * way and let it run (user level wait).
		 */
		if (sc_link->flags & SDEV_WAITING) {
			sc_link->flags &= ~SDEV_WAITING;
			wakeup((caddr_t)sc_link);
			return;
		}
d590 12
a601 7
		/*
		 * See if there is a buf with work for us to do..
		 */
		dp = &cd->buf_queue;
		if ((bp = dp->b_actf) == NULL)	/* yes, an assign */
			return;
		dp->b_actf = bp->b_actf;
d612 1
d614 1
d618 6
d636 2
d649 2
a650 2
			bzero(&cmd_small, sizeof(cmd_small));
			cmd_small.opcode = (bp->b_flags & B_READ) ?
d652 3
a654 4
			_lto3b(blkno, cmd_small.addr);
			cmd_small.length = nblks & 0xff;
			cmdlen = sizeof(cmd_small);
			cmdp = (struct scsi_generic *)&cmd_small;
d659 2
a660 2
			bzero(&cmd_big, sizeof(cmd_big));
			cmd_big.opcode = (bp->b_flags & B_READ) ?
d662 3
a664 4
			_lto4b(blkno, cmd_big.addr);
			_lto2b(nblks, cmd_big.length);
			cmdlen = sizeof(cmd_big);
			cmdp = (struct scsi_generic *)&cmd_big;
d667 7
d677 1
a677 26
		/*
		 * Call the routine that chats with the adapter.
		 * Note: we cannot sleep as we may be an interrupt
		 */
		error = scsi_scsi_cmd(sc_link, cmdp, cmdlen,
		    (u_char *) bp->b_data, bp->b_bcount, SCSI_RETRIES, 30000,
		    bp, SCSI_NOSLEEP | ((bp->b_flags & B_READ) ? SCSI_DATA_IN :
		    SCSI_DATA_OUT));
		switch (error) {
		case 0:
			timeout_del(&cd->sc_timeout);
			break;
		case EAGAIN:
			/*
			 * The device can't start another i/o. Try again later.
			 */
			dp->b_actf = bp;
			disk_unbusy(&cd->sc_dk, 0, 0);
			timeout_add(&cd->sc_timeout, 1);
			return;
		default:
			disk_unbusy(&cd->sc_dk, 0, 0);
			printf("%s: not queued, error %d\n",
			    cd->sc_dev.dv_xname, error);
			break;
		}
d679 3
d685 1
a685 1
cdrestart(void *v)
d687 33
a719 1
	int s;
d721 7
a727 4
	s = splbio();
	cdstart(v);
	splx(s);
}
d729 2
a730 4
void
cddone(struct scsi_xfer *xs)
{
	struct cd_softc *cd = xs->sc_link->device_softc;
d732 3
a734 3
	if (xs->bp != NULL)
		disk_unbusy(&cd->sc_dk, xs->bp->b_bcount - xs->bp->b_resid,
		    (xs->bp->b_flags & B_READ));
d1990 1
a1990 1
	struct buf *dp, *bp;
d1993 1
a1993 4
	s = splbio();
	for (dp = &cd->buf_queue; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;

d1996 1
d1998 1
a1999 1
	splx(s);
@


1.152
log
@whitespace tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.151 2009/12/06 01:05:14 dlg Exp $	*/
d174 3
a176 3
	scsi_inqmatch(sa->sa_inqbuf, cd_patterns,
	    sizeof(cd_patterns)/sizeof(cd_patterns[0]), sizeof(cd_patterns[0]),
	    &priority);
@


1.151
log
@ansify dvd functions a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.150 2009/10/13 19:33:19 pirofti Exp $	*/
d119 7
a125 7
int    dvd_auth(struct cd_softc *, union dvd_authinfo *);
int    dvd_read_physical(struct cd_softc *, union dvd_struct *);
int    dvd_read_copyright(struct cd_softc *, union dvd_struct *);
int    dvd_read_disckey(struct cd_softc *, union dvd_struct *);
int    dvd_read_bca(struct cd_softc *, union dvd_struct *);
int    dvd_read_manufact(struct cd_softc *, union dvd_struct *);
int    dvd_read_struct(struct cd_softc *, union dvd_struct *);
d205 1
a205 1
  	cd->sc_dk.dk_driver = &cddkdriver;
d878 1
a878 2
					   args->data_format, args->track,
					   &data, len);
d898 1
a898 1
	case CDIOREADTOCENTRYS:  {
d961 2
a962 2
		  sizeof(struct ioc_toc_header) + sizeof(struct cd_toc_entry),
		  0x40 /* control word for "get MS info" */);
d1332 1
a1332 2
				    SMS_PF, &data->hdr_big, flags,
				    20000);
d1924 1
a1924 1
		    	SC_DEBUG(sc_link, SDEV_DB1, ("not ready: busy (%#x)\n",
@


1.150
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.149 2009/08/13 15:23:11 deraadt Exp $	*/
d1718 1
a1718 3
dvd_read_physical(cd, s)
	struct cd_softc *cd;
	union dvd_struct *s;
d1758 1
a1758 3
dvd_read_copyright(cd, s)
	struct cd_softc *cd;
	union dvd_struct *s;
d1781 1
a1781 3
dvd_read_disckey(cd, s)
	struct cd_softc *cd;
	union dvd_struct *s;
d1808 1
a1808 3
dvd_read_bca(cd, s)
	struct cd_softc *cd;
	union dvd_struct *s;
d1832 1
a1832 3
dvd_read_manufact(cd, s)
	struct cd_softc *cd;
	union dvd_struct *s;
d1863 1
a1863 3
dvd_read_struct(cd, s)
	struct cd_softc *cd;
	union dvd_struct *s;
@


1.149
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.148 2009/06/17 01:30:30 thib Exp $	*/
d93 1
a93 1
int	cdactivate(struct device *, enum devact);
d227 1
a227 1
cdactivate(struct device *self, enum devact act)
@


1.148
log
@Revert bufq's. this is inline with the major midlayer reverts that
have been going on. this appears to bring us back to stable state.

lots of testing by oga and ariane and my self.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.147 2009/06/03 22:09:30 thib Exp $	*/
d99 1
a99 1
void	cdgetdisklabel(dev_t, struct cd_softc *, struct disklabel *, int);
d1121 1
a1121 1
void
a1125 1
	char *errstring;
d1175 3
a1177 6
	if (!audioonly) {
		errstring = readdisklabel(DISKLABELDEV(dev), cdstrategy, lp,
		    spoofonly);
		/*if (errstring)
			printf("%s: %s\n", cd->sc_dev.dv_xname, errstring);*/
	}
@


1.147
log
@add a flexible buffer queue (bufq) api, based on the never used
one by tedu@@. It doesn't do anything smart yet, it just uses
plain old disksort. we also keep the old method of queueing bufs
since some miods have crazy MD drivers that need some love.

ok beck@@, art@@
tested by many on many archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.145 2009/01/10 18:00:59 robert Exp $	*/
d101 1
d251 1
a251 1
	bufq_drain(cd->sc_dk.dk_bufq);
d502 1
a502 1
	BUFQ_ADD(cd->sc_dk.dk_bufq, bp);
d549 2
a550 1
	struct buf *bp = NULL;
d575 5
a579 2
		/* See if there is a buf with work for us to do..*/
		if ((bp = BUFQ_GET(cd->sc_dk.dk_bufq)) == NULL)
d581 1
d658 1
a658 1
			BUFQ_ADD(cd->sc_dk.dk_bufq, bp);
d1954 20
@


1.146
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@a100 1
void	cd_kill_buffers(struct cd_softc *);
d250 1
a250 1
	cd_kill_buffers(cd);
d501 1
a501 1
	disksort(&cd->buf_queue, bp);
d548 1
a548 2
	struct buf *bp = 0;
	struct buf *dp;
d573 2
a574 5
		/*
		 * See if there is a buf with work for us to do..
		 */
		dp = &cd->buf_queue;
		if ((bp = dp->b_actf) == NULL)	/* yes, an assign */
a575 1
		dp->b_actf = bp->b_actf;
d652 1
a652 1
			dp->b_actf = bp;
a1947 20
}

/*
 * Remove unprocessed buffers from queue.
 */
void
cd_kill_buffers(struct cd_softc *cd)
{
	struct buf *dp, *bp;
	int s;

	s = splbio();
	for (dp = &cd->buf_queue; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;

		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		biodone(bp);
	}
	splx(s);
@


1.145
log
@Add support for the volume buttons and for the eject button found
on apple laptops.
The eject button will only eject the disc when it's not used by
anything.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.144 2008/08/01 01:44:20 dlg Exp $	*/
d719 1
a719 1
	(*cd->sc_link->adapter->scsi_minphys)(bp);
@


1.144
log
@silence failures to run scsi_prevent. dmesg spam sucks.

ok krw@@ marco@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.143 2008/07/26 04:39:51 krw Exp $	*/
d77 1
a77 1
#include <ufs/ffs/fs.h>			/* for BBSIZE and SBSIZE */
d129 4
d1975 31
@


1.143
log
@deivce -> device typo fix in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.142 2008/06/22 16:32:05 krw Exp $	*/
d339 2
a340 1
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
d383 2
a384 1
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
d427 2
a428 1
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY);
d1905 2
a1906 1
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
@


1.142
log
@Replace MUSTEK_RETRIES, SCANJET_RETRIES and ST_RETRIES with SCSI_RETRIES,
all defined to 4. Replace some magic number 4's with SCSI_RETRIES. Fix a
few lines that were now too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.141 2008/06/21 21:11:34 krw Exp $	*/
d577 1
a577 1
		 * If the deivce has become invalid, abort all the
@


1.141
log
@fgsch@@ points out my last commit changed the retry limit for CD capacity
commands. Bump limit back to the standard 4, and at the same time eliminate
SDRETRIES and CDRETRIES (both defined to 4) in favour of a new define,
SCSI_RETRIES, also defined to 4.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.140 2008/06/21 18:50:24 krw Exp $	*/
d640 2
a641 2
		    (u_char *) bp->b_data, bp->b_bcount, SCSI_RETRIES, 30000, bp,
		    SCSI_NOSLEEP | ((bp->b_flags & B_READ) ? SCSI_DATA_IN :
@


1.140
log
@Eliminate cd_size() and use scsi_size() + tweaked cd_get_params()
instead. We do not make use of the PMI and RELADDR bits in the
READ CAPACITY command, and thus there is no difference between
cd and sd capacity handling. Brings cd and sd more into line,
shrinks code and makes things easier to understand.

Make types for blocksize and disksize consistant and MI.

Make cdopen() as silent as sdopen().

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.139 2008/06/17 01:32:49 krw Exp $	*/
d640 1
a640 1
		    (u_char *) bp->b_data, bp->b_bcount, CDRETRIES, 30000, bp,
d1300 1
a1300 1
	    sizeof(cmd), 0, 0, CDRETRIES, 200000, NULL, 0));
d1356 1
a1356 1
	    0, 0, CDRETRIES, 200000, NULL, 0));
d1437 1
a1437 1
	    0, 0, CDRETRIES, 20000, NULL, 0));
d1452 1
a1452 1
	    sizeof(scsi_cmd), 0, 0, CDRETRIES, 2000, NULL, 0);
d1461 1
a1461 1
	return scsi_scsi_cmd(cd->sc_link, 0, 0, 0, 0, CDRETRIES, 2000, NULL,
d1484 1
a1484 1
	    CDRETRIES, 5000, NULL, SCSI_DATA_IN|SCSI_SILENT);
d1507 1
a1507 1
	    sizeof(struct scsi_read_toc), (u_char *)data, len, CDRETRIES,
d1591 1
a1591 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1602 1
a1602 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1613 1
a1613 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1625 1
a1625 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1639 1
a1639 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1652 1
a1652 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_OUT);
d1665 1
a1665 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_OUT);
d1677 1
a1677 1
		    CDRETRIES, 30000, NULL, 0);
d1687 1
a1687 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1704 1
a1704 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_OUT);
d1733 1
a1733 1
	    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1773 1
a1773 1
	    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1801 1
a1801 1
	    sizeof(cmd), (u_char *)buf, sizeof(*buf), CDRETRIES, 30000, NULL,
d1826 1
a1826 1
	    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1855 1
a1855 1
	    sizeof(cmd), (u_char *)buf, sizeof(*buf), CDRETRIES, 30000, NULL,
@


1.139
log
@Nuke unnecessary re-definition of READ_CAPACITY, scsi_read_capacity, and
scsi_read_cap_data as READ_CD_CAPACITY, scsi_read_cd_capacity and
scsi_read_cd_cap_data respectively. No functional change as all were
identical to their counterparts.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.138 2008/06/15 00:36:41 krw Exp $	*/
a100 1
u_long	cd_size(struct cd_softc *, int);
d345 2
a346 1
		if (cd_get_parms(cd, 0) != 0) {
a1176 50
/*
 * Find out from the device what its capacity is
 */
u_long
cd_size(struct cd_softc *cd, int flags)
{
	struct scsi_read_cap_data rdcap;
	struct scsi_read_capacity scsi_cmd;
	u_long size;
	int blksize;

	/* Reasonable defaults for drives that don't support READ_CAPACITY */
	cd->params.blksize = 2048;
	cd->params.disksize = 400000;

	if (cd->sc_link->quirks & ADEV_NOCAPACITY)
		goto exit;

	/*
	 * make up a scsi command and ask the scsi driver to do
	 * it for you.
	 */
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = READ_CAPACITY;

	/*
	 * If the command works, interpret the result as a 4 byte
	 * number of blocks and a blocksize
	 */
	if (scsi_scsi_cmd(cd->sc_link,
	    (struct scsi_generic *)&scsi_cmd, sizeof(scsi_cmd),
	    (u_char *)&rdcap, sizeof(rdcap), CDRETRIES, 20000, NULL,
	    flags | SCSI_DATA_IN) != 0)
		goto exit;

	blksize = _4btol(rdcap.length);
	if ((blksize < 512) || ((blksize & 511) != 0))
		blksize = 2048;	/* some drives lie ! */
	cd->params.blksize = blksize;

	size = _4btol(rdcap.addr) + 1;
	if (size < 100)
		size = 400000;	/* ditto */
	cd->params.disksize = size;

 exit:
	SC_DEBUG(cd->sc_link, SDEV_DB2, ("cd_size: %d %ld\n", blksize, size));
	return (cd->params.disksize);
}

d1538 16
a1553 6
	/*
	 * give a number of sectors so that sec * trks * cyls
	 * is <= disk_size
	 */
	if (cd_size(cd, flags) == 0)
		return (ENXIO);
@


1.138
log
@Don't bypass partition bounds check for RAW_PART. We now guarantee that
RAW_PART will always be 0 -> disksize, so the bounds check will always
pass for i/o's to valid addresses. Now the i/o will be properly truncated
if it goes past the end of the device. This prevents various adverse
impacts of issuing i/o's for data past the end of the device.

Repeatedly requested by todd@@.

ok weingart@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.137 2008/06/10 20:27:31 art Exp $	*/
d1183 2
a1184 2
	struct scsi_read_cd_cap_data rdcap;
	struct scsi_read_cd_capacity scsi_cmd;
d1188 1
a1188 2
	/* Reasonable defaults for drives that don't support
	   READ_CD_CAPACITY */
d1200 1
a1200 1
	scsi_cmd.opcode = READ_CD_CAPACITY;
@


1.137
log
@Accidental commit. Clean up.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.135 2008/05/27 11:39:22 fgsch Exp $	*/
d486 1
a486 2
	if (DISKPART(bp->b_dev) != RAW_PART &&
	    bounds_check_with_label(bp, cd->sc_dk.dk_label,
@


1.136
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@a84 2
#define CD_LOCKED	0x0800

@


1.135
log
@nuke unused lba2msf and msf2lba functions. krw@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.134 2007/09/16 01:30:24 krw Exp $	*/
d84 2
@


1.134
log
@MALLOC/FREE -> malloc/free, M_ZERO, extraneous casts,
extraneous #include <malloc.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.133 2007/09/07 16:15:48 krw Exp $	*/
a81 1
#define CD_BLOCK_OFFSET	150
a102 2
void	lba2msf(u_long, u_char *, u_char *, u_char *);
u_long	msf2lba(u_char, u_char, u_char);
a730 28

/*
 * conversion between minute-seconde-frame and logical block address
 * addresses format
 */
void
lba2msf (lba, m, s, f)
	u_long lba;
	u_char *m, *s, *f;
{
	u_long tmp;

	tmp = lba + CD_BLOCK_OFFSET;	/* offset of first logical frame */
	tmp &= 0xffffff;		/* negative lbas use only 24 bits */
	*m = tmp / (CD_SECS * CD_FRAMES);
	tmp %= (CD_SECS * CD_FRAMES);
	*s = tmp / CD_FRAMES;
	*f = tmp % CD_FRAMES;
}

u_long
msf2lba (m, s, f)
	u_char m, s, f;
{

	return ((((m * CD_SECS) + s) * CD_FRAMES + f) - CD_BLOCK_OFFSET);
}

@


1.133
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.132 2007/06/20 18:15:47 deraadt Exp $	*/
d933 1
a933 3
		MALLOC(toc, struct cd_toc *, sizeof(struct cd_toc), M_TEMP,
		    M_WAITOK);
		bzero(toc, sizeof(*toc));
d939 1
a939 1
			FREE(toc, M_TEMP);
d946 1
a946 1
			FREE(toc, M_TEMP);
d971 1
a971 1
		FREE(toc, M_TEMP);
d984 1
a984 3
		MALLOC(toc, struct cd_toc *, sizeof(struct cd_toc), M_TEMP,
		    M_WAITOK);
		bzero(toc, sizeof(*toc));
d991 1
a991 1
			FREE(toc, M_TEMP);
d1010 1
a1010 1
		FREE(toc, M_TEMP);
d1156 1
a1156 2
	MALLOC(toc, struct cd_toc *, sizeof(struct cd_toc), M_TEMP, M_WAITOK);
	bzero(toc, sizeof(*toc));
d1458 1
a1458 2
	MALLOC(toc, struct cd_toc *, sizeof(struct cd_toc), M_TEMP, M_WAITOK);
	bzero(toc, sizeof(*toc));
d1497 1
a1497 1
	FREE(toc, M_TEMP);
@


1.132
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.131 2007/06/18 20:55:52 deraadt Exp $	*/
d1869 1
a1869 1
	buf = malloc(sizeof(*buf), M_TEMP, M_WAITOK);
a1871 1
	bzero(buf, sizeof(*buf));
d1924 1
a1924 1
	buf = malloc(sizeof(*buf), M_TEMP, M_WAITOK);
a1926 1
	bzero(buf, sizeof(*buf));
@


1.131
log
@avoid modification race in DIOCRLDINFO; ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.130 2007/06/08 05:27:58 deraadt Exp $	*/
d100 1
a100 2
void	cdgetdisklabel(dev_t, struct cd_softc *, struct disklabel *,
			    struct cpu_disklabel *, int);
d357 1
a357 2
		cdgetdisklabel(dev, cd, cd->sc_dk.dk_label,
		    cd->sc_dk.dk_cpulabel, 0);
a490 1
	    cd->sc_dk.dk_cpulabel,
d826 1
a826 1
		cdgetdisklabel(dev, cd, lp, cd->sc_dk.dk_cpulabel, 0);
d854 1
a854 2
		    (struct disklabel *)addr, /*cd->sc_dk.dk_openmask : */0,
		    cd->sc_dk.dk_cpulabel);
d1152 1
a1152 1
    struct cpu_disklabel *clp, int spoofonly)
a1158 1
	bzero(clp, sizeof(struct cpu_disklabel));
d1208 1
a1208 1
		    clp, spoofonly);
@


1.130
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.129 2007/06/07 05:29:44 deraadt Exp $	*/
d774 1
d828 4
a831 2
		cdgetdisklabel(dev, cd, cd->sc_dk.dk_label,
		    cd->sc_dk.dk_cpulabel, 0);
@


1.129
log
@in OpenBSD as all old BSD unix, RAW_PART always starts at 0, so no
need for special case code; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.128 2007/06/06 17:15:14 deraadt Exp $	*/
d1183 1
@


1.128
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.127 2007/06/05 00:38:23 deraadt Exp $	*/
d604 2
a605 4
		if (DISKPART(bp->b_dev) != RAW_PART) {
			p = &cd->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
			blkno += DL_GETPOFFSET(p);
		}
@


1.127
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.126 2007/06/01 00:07:48 krw Exp $	*/
d1639 1
a1639 1
int
d1648 1
a1648 1
cddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
@


1.126
log
@Don't initialize d_partitions[RAW_DISK] just before calling
readdisklabel(), since all readdisklabel()'s do that already.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.125 2007/05/25 05:37:16 krw Exp $	*/
d606 1
a606 1
			blkno += p->p_offset;
d1182 1
a1182 1
	lp->d_secperunit = cd->params.disksize;
@


1.125
log
@ANSI-fication, minor KNF. No code change. My plane had power outlets
this time!
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.124 2007/04/28 02:24:21 krw Exp $	*/
a1192 6

	/* The raw partition is special.  */
	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;
@


1.124
log
@Fix comments above DISKMINOR uses. DISKMINOR provides minor not major
number (wd.c), and the uses are to find the minimum minor to be
detached.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.123 2007/04/26 11:18:54 krw Exp $	*/
d170 1
a170 3
cdmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d175 3
a177 3
	(void)scsi_inqmatch(sa->sa_inqbuf,
	    cd_patterns, sizeof(cd_patterns)/sizeof(cd_patterns[0]),
	    sizeof(cd_patterns[0]), &priority);
d186 1
a186 3
cdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a187 1
	struct cd_softc *cd = (struct cd_softc *)self;
d190 1
d228 1
a228 3
cdactivate(self, act)
	struct device *self;
	enum devact act;
d247 1
a247 3
cddetach(self, flags)
	struct device *self;
	int flags;
d278 1
a278 4
cdopen(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
d401 1
a401 4
cdclose(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
d454 1
a454 2
cdstrategy(bp)
	struct buf *bp;
d545 1
a545 2
cdstart(v)
	void *v;
d674 1
a674 2
cdrestart(v)
	void *v;
d684 1
a684 2
cddone(xs)
	struct scsi_xfer *xs;
d694 1
a694 2
cdminphys(bp)
	struct buf *bp;
d727 1
a727 4
cdread(dev, uio, ioflag)
	dev_t dev;
	struct uio *uio;
	int ioflag;
d734 1
a734 4
cdwrite(dev, uio, ioflag)
	dev_t dev;
	struct uio *uio;
	int ioflag;
d773 1
a773 6
cdioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
d1154 2
a1155 6
cdgetdisklabel(dev, cd, lp, clp, spoofonly)
	dev_t dev;
	struct cd_softc *cd;
	struct disklabel *lp;
	struct cpu_disklabel *clp;
	int spoofonly;
d1227 1
a1227 3
cd_size(cd, flags)
	struct cd_softc *cd;
	int flags;
d1231 1
a1232 1
	u_long size;
d1275 1
a1275 3
cd_setchan(cd, p0, p1, p2, p3, flags)
	struct cd_softc *cd;
	int p0, p1, p2, p3, flags;
d1308 1
a1308 4
cd_getvol(cd, arg, flags)
	struct cd_softc *cd;
	struct ioc_vol *arg;
	int flags;
d1335 1
a1335 4
cd_setvol(cd, arg, flags)
	struct cd_softc *cd;
	const struct ioc_vol *arg;
	int flags;
d1387 1
a1387 3
cd_load_unload(cd, options, slot)
	struct cd_softc *cd;
	int options, slot;
d1401 1
a1401 3
cd_set_pa_immed(cd, flags)
	struct cd_softc *cd;
	int flags;
d1443 1
a1443 3
cd_play(cd, blkno, nblks)
	struct cd_softc *cd;
	int blkno, nblks;
d1460 2
a1461 3
cd_play_tracks(cd, strack, sindex, etrack, eindex)
	struct cd_softc *cd;
	int strack, sindex, etrack, eindex;
d1520 2
a1521 3
cd_play_msf(cd, startm, starts, startf, endm, ends, endf)
	struct cd_softc *cd;
	int startm, starts, startf, endm, ends, endf;
d1542 1
a1542 3
cd_pause(cd, go)
	struct cd_softc *cd;
	int go;
d1557 1
a1557 2
cd_reset(cd)
	struct cd_softc *cd;
a1558 1

d1567 2
a1568 4
cd_read_subchannel(cd, mode, format, track, data, len)
	struct cd_softc *cd;
	int mode, format, track, len;
	struct cd_sub_channel_info *data;
d1589 2
a1590 4
cd_read_toc(cd, mode, start, data, len, control)
	struct cd_softc *cd;
	int mode, start, len, control;
	void *data;
d1610 1
a1610 4
cd_load_toc(cd, toc, fmt)
	struct cd_softc *cd;
	struct cd_toc *toc;
	int fmt;
d1634 1
a1634 3
cd_get_parms(cd, flags)
	struct cd_softc *cd;
	int flags;
d1646 1
a1646 2
cdsize(dev)
	dev_t dev;
d1654 1
a1654 5
cddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
a1655 1

d1664 1
a1664 3
dvd_auth(cd, a)
	struct cd_softc *cd;
	union dvd_authinfo *a;
d1996 1
a1996 2
cd_interpret_sense(xs)
	struct scsi_xfer *xs;
@


1.123
log
@Use the standard DISKPART/DISKUNIT/etc. defines rather than identical
but differently named SD/CD ones. No change to .o files.

ok deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.122 2007/04/12 11:33:13 krw Exp $	*/
d262 1
a262 1
	/* locate the minor number */
@


1.122
log
@Add cd_kill_buffers() as a separate function, like sd_kill_buffers()
and for the same reason of preparing for safer handling of users
yanking usb devices out. No functional change.

Copied from bluhm@@'s change to sd.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.121 2007/04/10 17:47:56 miod Exp $	*/
a80 5
#define	CDUNIT(z)			DISKUNIT(z)
#define	CDMINOR(unit, part)		DISKMINOR(unit, part)
#define	CDPART(z)			DISKPART(z)
#define	MAKECDDEV(maj, unit, part)	MAKEDISKDEV(maj, unit, part)

a91 2
#define	CDLABELDEV(dev)	(MAKECDDEV(major(dev), CDUNIT(dev), RAW_PART))

d263 1
a263 1
	mn = CDMINOR(self->dv_unit, 0);
d295 2
a296 2
	unit = CDUNIT(dev);
	part = CDPART(dev);
d418 1
a418 1
	int part = CDPART(dev);
d421 1
a421 1
	cd = cdlookup(CDUNIT(dev));
d474 1
a474 1
	if ((cd = cdlookup(CDUNIT(bp->b_dev))) == NULL) {
d506 1
a506 1
	if (CDPART(bp->b_dev) != RAW_PART &&
d620 2
a621 2
		if (CDPART(bp->b_dev) != RAW_PART) {
			p = &cd->sc_dk.dk_label->d_partitions[CDPART(bp->b_dev)];
d718 1
a718 1
	cd = cdlookup(CDUNIT(bp->b_dev));
d806 1
a806 1
	int part = CDPART(dev);
d809 1
a809 1
	cd = cdlookup(CDUNIT(dev));
d870 1
a870 1
		    &cd->sc_dk.dk_label->d_partitions[CDPART(dev)];
d1162 1
a1162 1
		if (CDPART(dev) != RAW_PART) {
d1250 2
a1251 2
		errstring = readdisklabel(CDLABELDEV(dev), cdstrategy, lp, clp,
		    spoofonly);
@


1.121
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.120 2007/04/10 10:48:57 krw Exp $	*/
d111 1
d265 1
a265 2
	struct buf *dp, *bp;
	int s, bmaj, cmaj, mn;
d267 1
a267 10
	/* Remove unprocessed buffers from queue */
	s = splbio();
	for (dp = &cd->buf_queue; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;
		
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		biodone(bp);
	}
	splx(s);
d2117 20
@


1.120
log
@Always use idiom 'struct cd_softc *cd = (struct cd_softc *)self'. Spotted
by bluhm@@ for sd. No change to cd.o.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.119 2007/02/03 23:47:18 bluhm Exp $	*/
d1274 1
a1274 1
 * Find out from the device what it's capacity is
@


1.119
log
@Make comment match code.  ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.118 2006/12/23 17:35:35 krw Exp $	*/
d198 1
a198 1
	struct cd_softc *cd = (void *)self;
d263 1
a263 1
	struct cd_softc *sc = (struct cd_softc *)self;
d269 1
a269 1
	for (dp = &sc->buf_queue; (bp = dp->b_actf) != NULL; ) {
d289 2
a290 2
	if (sc->sc_cdpwrhook != NULL)
		powerhook_disestablish(sc->sc_cdpwrhook);
d293 1
a293 1
	disk_detach(&sc->sc_dk);
@


1.118
log
@Add the ability to issue GPCMD_REPORT_KEY and GPCMD_SEND_KEY scsi
commands via the DVD_LU_SEND_RPC_STATE and DVD_HOST_SEND_RPC_STATE
ioctls respectively.

Thus allowing any region protected DVDs mistakenly delivered by Santa
to the wrong region to be viewed on recalcitrant DVD drives (with the
aid of an appropriate utility like regionset).

No change to any current functions.

Found in my hackers@@ folder from August.

From netbsd -> Kurt Miller -> jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.117 2006/12/12 02:44:36 krw Exp $	*/
d278 1
a278 1
	/* locate the major number */
@


1.117
log
@Give the SCSI layer the ability to requeue i/o's rejected by a driver
using the new NO_CCB result. Currently a no-op since no driver produces
that result.

ok dlg@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.116 2006/11/28 16:56:50 dlg Exp $	*/
d1855 27
@


1.116
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.115 2006/11/27 23:14:22 beck Exp $	*/
d53 1
a53 1
#include <sys/kernel.h>
d105 1
d229 2
d468 2
d573 1
a573 1
 * cdstart() is called at splbio from cdstrategy and scsi_done
d586 1
a586 1
	int blkno, nblks, cmdlen;
d680 13
a692 4
		if (scsi_scsi_cmd(sc_link, cmdp, cmdlen,
		    (u_char *) bp->b_data, bp->b_bcount,
		    CDRETRIES, 30000, bp, SCSI_NOSLEEP |
		    ((bp->b_flags & B_READ) ? SCSI_DATA_IN : SCSI_DATA_OUT))) {
d694 7
a700 1
			printf("%s: not queued", cd->sc_dev.dv_xname);
d703 11
@


1.115
log
@more magic removal
ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.114 2006/11/27 20:15:09 beck Exp $	*/
d179 1
a179 1
	struct scsibus_attach_args *sa = aux;
d198 1
a198 1
	struct scsibus_attach_args *sa = aux;
@


1.114
log
@get rid of the rest of the asc/ascq magic codes in scsi
ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.113 2006/10/08 02:29:24 beck Exp $	*/
d2036 1
a2036 1
	    (serr != 0x70 && serr != 0x71))
@


1.113
log
@Something more closely resembling english in this comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.112 2006/10/07 23:40:07 beck Exp $	*/
d2055 2
a2056 3
		if (sense->add_sense_code == 0x04 &&   /* Not ready */
		    sense->add_sense_code_qual == 0x01) { /* Becoming ready */
			SC_DEBUG(sc_link, SDEV_DB1, ("not ready: busy (%#x)\n",
@


1.112
log
@make cd-roms retry forever while the device indicates that it is
"becoming ready" - this is done in the exact same way that it
was done for tape in st.c. This commit adds a cd specific interpret_sense
routine to cd.c that will catch the becoming ready case and handle it.
This also removes the need to use crazy timeouts to catch this case.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.111 2006/09/26 23:33:04 krw Exp $	*/
d2040 10
a2049 9
	 * We do custom processing in cd for the unit becoming ready case.
	 * in this case we do not allow xs->retries to be decremented
	 * only on the "Unit Becoming Ready" case. This is because CD
	 * drives report "Unit Becoming Ready" when loading media, etc.
	 * and can take a long time.  Rather than having a massive timeout 
	 * for all operations (which would cause other problems) we allow
	 * operations to wait (but be interruptable with Ctrl-C) forever
	 * as long as the drive is reporting that it is becoming ready.
	 * all other cases of not being ready are handled as per the default.
@


1.111
log
@Zap D_REMOVABLE flag from disklabel. If you didn't already know that
floppies and cd's were removable, displaying that fact in disklabel
output was unlikely to help. And the display in disklabel was the only
use of D_REMOVABLE in the tree.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.110 2006/07/29 02:40:45 krw Exp $	*/
d127 1
d151 1
a151 1
	NULL,			/* use default error handler */
d344 5
a348 1
		error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_CD,
d2024 44
@


1.110
log
@The version field of scsi_inquiry_data is not a simple numeric value
that specifies the version of SCSI being supported. Even the ANSI part
that we use is complex. 4 means 2, 5 means 3 and 6 means 4. Translate
and use the value correctly. Fixes SCSI5 and SCSI6 in dmesg. And
properly protects SCSI2 devices from getting SCSI3 commands.

"seems like an elegant solution to me" millert@@ ok dlg@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.109 2006/07/23 02:50:20 dlg Exp $	*/
a1198 1
	lp->d_flags = D_REMOVABLE;
@


1.109
log
@remove some scsi ioctls, most importantly the ones that can reprobe the
bus. supporting these complicates the midlayer unnecessarily.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.108 2006/07/19 01:21:28 krw Exp $	*/
d222 1
a222 1
	    (sa->sa_inqbuf->version & SID_ANSII) == 0)
@


1.108
log
@Add cd_powerhook(). Use it to lock CD drives having open partitions
when PWR_RESUME occurs. The drives may have forgotten they were
locked.

Noted and original diff by Alexey Vatchenko.

"I agree with the intent." miod@@ "Looks acceptable." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.107 2006/05/11 00:45:59 krw Exp $	*/
a803 1
		case OSCIOCIDENTIFY:
@


1.107
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.106 2006/03/15 20:20:42 miod Exp $	*/
d136 2
d226 4
d284 4
d2007 14
@


1.106
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.105 2006/03/04 19:33:22 miod Exp $	*/
d287 1
a287 1
int 
d336 1
a336 1
			
d392 1
a392 1
	/* It's OK to fall through because dk_openmask is now non-zero. */	
d409 1
a409 1
int 
d520 1
a520 1
	
d555 1
a555 1
void 
d743 1
a743 1
{   
d814 1
a814 1
		case DVD_READ_STRUCT:	
d865 1
a865 1
		
d921 1
a921 1
		if (cd->sc_link->quirks & ADEV_LITTLETOC) 
d1083 1
a1083 1
		error = scsi_start(cd->sc_link, SSS_START|SSS_LOEJ, 
d1241 1
a1241 1
	
d1311 1
a1311 1
	}	
d1341 1
a1341 1
	}		
d1370 1
a1370 1
	}	
d1384 1
a1384 1
	}	
d1413 1
a1413 1
	
d1895 1
a1895 1
	
d1951 1
a1951 1
	
d1971 1
a1971 1
	}	
@


1.105
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.104 2006/01/21 12:18:49 miod Exp $	*/
a215 2
	dk_establish(&cd->sc_dk, &cd->sc_dev);
  
@


1.104
log
@Invoke disk_detach() and related cleanup work in detach(), rather than
zeroref() - just to be on the safe side, should we mess up our ref count.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.103 2006/01/17 20:22:22 miod Exp $	*/
d700 1
a700 1
	 * by settng the "length" to 0.  However, we're conservative
@


1.103
log
@Need to device_unreg() the implicit device_ref() done by cdlookup() in
cdminphys().
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.102 2006/01/12 01:06:27 krw Exp $	*/
a102 1
void    cdzeroref(struct device *);
d138 1
a138 1
	cddetach, cdactivate, cdzeroref
a278 2
	return (0);
}
d280 2
a281 5
void
cdzeroref(self)
	struct device *self;
{
	struct cd_softc *cd = (struct cd_softc *)self;
d283 1
a283 2
	/* Detach disk. */
	disk_detach(&cd->sc_dk);
a284 1

@


1.102
log
@Don't populate the fabricated disklabel's partition info from track
information in the TOC. The partition info is just overwritten or
rendered incomplete by readdisklabel().

Just examine the TOC to determine if the cd is audio only, i.e. it has
a valid TOC but no data tracks. In this case don't call
readdisklabel(). Much simpler code. No functional change for single
data track CD's like the install media.

ok pedro@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.101 2005/12/25 20:01:11 krw Exp $	*/
d721 2
@


1.101
log
@Cleanup/fix cdgetdisklabel() by

1) Using cd_load_toc() instead of replicating code.

2) Using struct cd_toc and betoh32() like other parts of cd.c.

3) Restoring pre-Sept. 26 behaviour of trying to read usable disklabel
info if there is no TOC. i.e. avoid readdisklabel() only when it is an
audio-only CD. Stop abusing spoofonly.

Tested by mjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.100 2005/12/23 16:18:19 krw Exp $	*/
a1170 1
	u_int32_t lba, nlba;
d1172 1
a1172 1
	int tocidx, n, data_track = 0;
a1213 6
	/*
	 * Read the TOC and loop through the individual tracks laying them
	 * out in our disklabel.
	 *
	 * XXX should we move all data tracks up front before any other tracks?
	 */
d1215 1
a1215 1
		n = 0; /* No valid TOC found. */
d1219 5
a1223 21
	/* +2 to account for leading out track. */
	n = toc->header.ending_track - toc->header.starting_track + 2;

	/* Create the partition table.  */
	/* Probably should sanity-check the drive's values */
	lba = betoh32(toc->entries[0].addr.lba);
	if (cd->sc_link->quirks & ADEV_LITTLETOC)
		lba = swap32(lba);

	for (tocidx = 1; tocidx < n && data_track < MAXPARTITIONS; tocidx++) {
		nlba = betoh32(toc->entries[tocidx].addr.lba);
		if (cd->sc_link->quirks & ADEV_LITTLETOC)
			nlba = swap32(nlba);

		if (toc->entries[tocidx - 1].control & 4) { 
			lp->d_partitions[data_track].p_fstype = FS_UNUSED;
			lp->d_partitions[data_track].p_offset = lba;
			lp->d_partitions[data_track].p_size = nlba - lba;
			data_track++;
			if (data_track == RAW_PART)
				data_track++;
a1225 5
		lba = nlba;
	}

	lp->d_npartitions = max((RAW_PART + 1), data_track);

d1229 1
a1229 5
	/*
	 * If there was no valid TOC found or the TOC says we have a data track
	 * then look for a real disklabel.
	 */
	if (n == 0 || data_track > 0) {
@


1.100
log
@Make cd_load_toc() take an address mode parameter, clean up a bit.
Add a check for ending_track < starting_track before calculating size
of TOC to read.

Tested by mjc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.99 2005/12/22 23:06:23 krw Exp $	*/
a90 11
#define TOC_HEADER_LEN			0
#define TOC_HEADER_STARTING_TRACK	2
#define TOC_HEADER_ENDING_TRACK		3
#define TOC_HEADER_SZ			4

#define TOC_ENTRY_CONTROL_ADDR_TYPE	1
#define TOC_ENTRY_TRACK			2
#define TOC_ENTRY_MSF_LBA		4
#define TOC_ENTRY_SZ			8


d1170 1
a1171 1
	u_int8_t hdr[TOC_HEADER_SZ], *ent, *toc = NULL;
d1173 1
a1173 1
	int tocidx, n, len, is_data, data_track = 0;
d1178 3
a1214 3
	if (spoofonly)
		goto done;

d1216 4
a1219 4
	 * Read the TOC and loop through the individual tracks and lay them
	 * out in our disklabel.  If there is a data track, call the generic
	 * disklabel read routine.  XXX should we move all data tracks up front
	 * before any other tracks?
d1221 2
a1222 1
	if (cd_read_toc(cd, 0, 0, hdr, TOC_HEADER_SZ, 0))
d1224 1
d1226 2
a1227 10
	n = hdr[TOC_HEADER_ENDING_TRACK] - hdr[TOC_HEADER_STARTING_TRACK] + 1;

	if (n <= 0)
		goto done;

	/* n + 1 because of leadout track */
	len = TOC_HEADER_SZ + (n + 1) * TOC_ENTRY_SZ;
	toc = malloc(len, M_TEMP, M_WAITOK);
	if (cd_read_toc (cd, CD_LBA_FORMAT, 0, toc, len, 0))
		goto done;
d1231 1
a1231 2
	ent = toc + TOC_HEADER_SZ;
	lba = _4btol(&ent[TOC_ENTRY_MSF_LBA]);
d1235 2
a1236 4
	for (tocidx = 1; tocidx <= n && data_track < MAXPARTITIONS; tocidx++) {
		is_data = ent[TOC_ENTRY_CONTROL_ADDR_TYPE] & 4;
		ent += TOC_ENTRY_SZ;
		nlba = _4btol(&ent[TOC_ENTRY_MSF_LBA]);
d1240 1
a1240 1
		if (is_data) { 
d1255 1
a1255 2
	if (toc)
		free(toc, M_TEMP);
d1257 10
a1266 7
	/* If we have a data track, look for a real disklabel. */
	if (data_track == 0)
		spoofonly = 1;
	errstring = readdisklabel(CDLABELDEV(dev), cdstrategy, lp, clp,
	    spoofonly);
	/*if (errstring)
		printf("%s: %s\n", cd->sc_dev.dv_xname, errstring);*/
@


1.99
log
@Move a struct cd_toc (800 bytes) from the stack to malloc'ed memory.

bzero() all malloc'ed cd_toc structs because cd_read_toc() will only
zero as much as it is trying to read.

malloc M_TEMP memory instead of M_DEVBUF memory for the cd_toc
structs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.98 2005/12/22 03:21:57 krw Exp $	*/
d138 1
a138 1
int	cd_load_toc(struct cd_softc *, struct cd_toc *);
d1556 1
a1556 1
	if ((error = cd_load_toc(cd, toc)) != 0)
d1700 1
a1700 1
cd_load_toc(cd, toc)
d1703 1
d1705 1
a1705 1
	int ntracks, len, error;
d1707 10
a1716 2
	if ((error = cd_read_toc(cd, 0, 0, toc, sizeof(toc->header), 0)) != 0)
		return (error);
d1718 1
a1718 6
	ntracks = toc->header.ending_track - toc->header.starting_track + 1;
	len = (ntracks + 1) * sizeof(struct cd_toc_entry) +
	    sizeof(toc->header);
	if ((error = cd_read_toc(cd, CD_MSF_FORMAT, 0, toc, len, 0)) != 0)
		return (error);
	return (0);
@


1.98
log
@Initialize data_track before a 'goto done;' could lead to it being
used.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.97 2005/10/15 18:18:36 krw Exp $	*/
d956 3
a958 2
		MALLOC (toc, struct cd_toc *, sizeof (struct cd_toc),
			M_DEVBUF, M_WAITOK);
d964 1
a964 1
			FREE(toc, M_DEVBUF);
d971 1
a971 1
			FREE(toc, M_DEVBUF);
d996 1
a996 1
		FREE(toc, M_DEVBUF);
d1009 3
a1011 2
		MALLOC (toc, struct cd_toc *, sizeof (struct cd_toc),
			M_DEVBUF, M_WAITOK);
d1018 1
a1018 1
			FREE(toc, M_DEVBUF);
d1037 1
a1037 1
		FREE(toc, M_DEVBUF);
d1544 1
a1544 1
	struct cd_toc toc;
d1553 5
a1557 2
	if ((error = cd_load_toc(cd, &toc)) != 0)
		return (error);
d1559 2
a1560 2
	if (++etrack > (toc.header.ending_track+1))
		etrack = toc.header.ending_track+1;
d1562 6
a1567 4
	strack -= toc.header.starting_track;
	etrack -= toc.header.starting_track;
	if (strack < 0)
		return (EINVAL);
d1573 3
a1575 3
	endm = toc.entries[etrack].addr.msf.minute;
	ends = toc.entries[etrack].addr.msf.second;
	endf = toc.entries[etrack].addr.msf.frame;
d1580 4
a1583 2
			if (endm-- == 0)
				return (EINVAL);
d1587 8
a1594 4
	return (cd_play_msf(cd, toc.entries[strack].addr.msf.minute,
	    toc.entries[strack].addr.msf.second,
	    toc.entries[strack].addr.msf.frame,
	    endm, ends, endf));
@


1.97
log
@Eliminate unnecessary bzero() by only writing valid information.
Eliminate separate check/break from for() loop.

No functional change.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.96 2005/10/14 23:53:29 krw Exp $	*/
d1182 1
a1182 1
	int tocidx, n, len, is_data, data_track;
a1250 1
	data_track = 0;
@


1.96
log
@Eliminate uneeded variable 'i' and use under utilized 'data_track'
instead.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.95 2005/10/11 14:19:21 hshoexer Exp $	*/
d1252 1
a1252 1
	for (tocidx = 1; tocidx <= n; tocidx++) {
a1258 6
		lp->d_partitions[data_track].p_fstype =
			is_data ? FS_UNUSED : FS_OTHER;
		lp->d_partitions[data_track].p_offset = lba;
		lp->d_partitions[data_track].p_size = nlba - lba;
		lba = nlba;

d1260 3
d1266 1
d1268 1
a1268 3
			if (data_track >= MAXPARTITIONS)
				break;
		}
a1269 4

	if (data_track < MAXPARTITIONS)
		bzero(&lp->d_partitions[data_track],
		    sizeof(lp->d_partitions[data_track]));
@


1.95
log
@use [bl]etohXX instead of ntoh[sl], makes the code more consistent and
better readable.  actually no binary change.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.94 2005/10/11 11:31:43 krw Exp $	*/
d1182 1
a1182 1
	int tocidx, i, n, len, is_data, data_track = -1;
d1251 1
a1251 1
	i = 0;
d1259 1
a1259 1
		lp->d_partitions[i].p_fstype =
d1261 2
a1262 2
		lp->d_partitions[i].p_offset = lba;
		lp->d_partitions[i].p_size = nlba - lba;
d1266 3
a1268 2
			if (data_track == -1)
				data_track = i;
d1270 1
a1270 5
			i++;
			if (i == RAW_PART)
				i++;

			if (i >= MAXPARTITIONS)
d1275 3
a1277 2
	if (i < MAXPARTITIONS)
		bzero(&lp->d_partitions[i], sizeof(lp->d_partitions[i]));
d1279 1
a1279 1
	lp->d_npartitions = max((RAW_PART + 1), i);
d1286 1
a1286 1
	if (data_track == -1)
@


1.94
log
@Change some byte shifting to _4btol() and swap32() calls.

ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.93 2005/10/10 23:10:38 krw Exp $	*/
d943 1
a943 1
			th.len = ntohs(th.len);
d985 1
a985 1
					cte->addr.lba = ntohl(cte->addr.lba);
d990 1
a990 1
			th->len = ntohs(th->len);
d1027 1
a1027 1
			cte->addr.lba = ntohl(cte->addr.lba);
d1031 1
a1031 1
			toc->header.len = ntohs(toc->header.len);
@


1.93
log
@Some KNF. malloc/free instead of MALLOC/FREE since it's a variable
sized allocation. Remove some dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.92 2005/09/29 01:19:53 krw Exp $	*/
d1247 3
a1249 6
	lba = ((cd->sc_link->quirks & ADEV_LITTLETOC) ?
	    ent[TOC_ENTRY_MSF_LBA] | ent[TOC_ENTRY_MSF_LBA + 1] << 8 |
	    ent[TOC_ENTRY_MSF_LBA + 2] << 16 |
	    ent[TOC_ENTRY_MSF_LBA + 3] << 24 :
	    ent[TOC_ENTRY_MSF_LBA] << 24 | ent[TOC_ENTRY_MSF_LBA + 1] << 16 |
	    ent[TOC_ENTRY_MSF_LBA + 2] << 8 | ent[TOC_ENTRY_MSF_LBA + 3]);
d1255 3
a1257 9
		nlba = ((cd->sc_link->quirks & ADEV_LITTLETOC) ?
			ent[TOC_ENTRY_MSF_LBA] |
			ent[TOC_ENTRY_MSF_LBA + 1] << 8 |
			ent[TOC_ENTRY_MSF_LBA + 2] << 16 |
			ent[TOC_ENTRY_MSF_LBA + 3] << 24 :
			ent[TOC_ENTRY_MSF_LBA] << 24 |
			ent[TOC_ENTRY_MSF_LBA + 1] << 16 |
			ent[TOC_ENTRY_MSF_LBA + 2] << 8 |
			ent[TOC_ENTRY_MSF_LBA + 3]);
@


1.92
log
@Clear SDEV_MEDIA_LOADED for cd media on the last close of a device, as
sd does. Prevents spurious label information from being seen on
devices that return NOT READY/UNABLE TO RECOVER TABLE-OF-CONTENTS
error (or other sense errors) for blank media. Burning cd's still
works.

ok marco@@ dlg@@ fgsch@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.91 2005/09/26 22:52:49 krw Exp $	*/
d1179 2
a1181 2
	u_int8_t hdr[TOC_HEADER_SZ],  *ent, *toc = NULL;
	u_int32_t lba, nlba;
d1190 1
a1191 5
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
	if (lp->d_secpercyl == 0) {
		lp->d_secpercyl = 100;
		/* as long as it's not 0 - readdisklabel divides by it */
	}
d1240 1
a1240 1
	MALLOC(toc, u_int8_t *, len, M_TEMP, M_WAITOK);
d1294 1
a1294 1
		FREE(toc, M_TEMP);
@


1.91
log
@Use SCSI_IGNORE_ILLEGAL_REQUEST when reading a cd's table of contents.
ILLEGAL REQUEST is correctly reported for blank media, as an
informative FreeBSD comment pointed out. Ensure the returned table of
contents is always initialized to zero. Call readdisklabel with
spoofonly = 1 when no data tracks are found.

Don't try to read the DOS label from the device if spoofonly is 1.
Only done for amd64 here. More archs to follow.

Eliminates scsi error messages when attempting to open a cd containing
blank media, as pointed out by Michael Coulter.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.90 2005/09/21 03:36:07 krw Exp $	*/
d464 1
a464 1
		cd->sc_link->flags &= ~SDEV_OPEN;
@


1.90
log
@Improve readability by using a variable instead of repeated
calculations. Same as sd.c r1.94.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.89 2005/09/21 03:10:57 krw Exp $	*/
d136 1
a136 2
int	cd_read_toc(struct cd_softc *, int, int, void *,
			 int, int );
a1182 1
	int toc_valid = 0;
d1225 3
a1233 1
	bzero(hdr, sizeof(hdr));
a1249 1
	toc_valid = 1;  
d1300 7
a1306 7
	/* We have a data track, look in there for a real disklabel.  */
	if (data_track != -1 || !toc_valid) {
		errstring = readdisklabel(CDLABELDEV(dev),
		    cdstrategy, lp, clp, spoofonly);
		/*if (errstring)
			printf("%s: %s\n", cd->sc_dev.dv_xname, errstring);*/
	}
a1693 1
	int ntoc;
d1696 2
a1697 6
#if 0
	if (len!=sizeof(struct ioc_toc_header))
		ntoc=((len)-sizeof(struct ioc_toc_header))/sizeof(struct cd_toc_entry);
	else 
#endif
	ntoc = len;
d1702 1
a1702 1
	_lto2b(ntoc, scsi_cmd.data_len);
d1707 1
a1707 1
	    5000, NULL, SCSI_DATA_IN);
@


1.89
log
@Missing parenthesis. Same problem was addressed in sd.c r1.90. Could
fix devices not supporting TEST UNIT READY.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.88 2005/09/11 17:34:27 krw Exp $	*/
d317 1
a317 2
	int unit, part;
	int error = 0;
d322 2
d344 1
a344 1
			if (part == RAW_PART && fmt == S_IFCHR)
d356 2
a357 2
		    ((part == RAW_PART && fmt == S_IFCHR) ? SCSI_SILENT : 0) |
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
d366 1
a366 1
			if (part == RAW_PART && fmt == S_IFCHR) {
@


1.88
log
@Simplify code by changing struct scsi_mode_sense_buf{ union {}
headers; } to just union scsi_mode_sense_buf {}. No functional change.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.87 2005/08/23 23:38:00 krw Exp $	*/
d355 1
a355 1
		    (part == RAW_PART && fmt == S_IFCHR) ? SCSI_SILENT : 0 |
@


1.87
log
@Move uses of struct scsi_mode_sense_buf (255 bytes each) from the
stack into malloc'd memory.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.86 2005/08/03 23:37:07 krw Exp $	*/
d1367 1
a1367 1
	struct scsi_mode_sense_buf *data;
d1387 1
a1387 1
			    &data->headers.hdr_big, flags, 20000);
d1390 1
a1390 1
			    &data->headers.hdr, flags, 20000);
d1403 1
a1403 1
	struct scsi_mode_sense_buf *data;
d1433 1
a1433 1
	struct scsi_mode_sense_buf *data;
d1473 1
a1473 1
		    &data->headers.hdr_big, flags, 20000);
d1476 1
a1476 1
		    &data->headers.hdr, flags, 20000);
d1503 1
a1503 1
	struct scsi_mode_sense_buf *data;
d1527 1
a1527 1
				    SMS_PF, &data->headers.hdr_big, flags,
d1531 1
a1531 1
				    &data->headers.hdr, flags, 20000);
@


1.86
log
@Move a couple of 2048+4 byte structures from the stack to the heap.
Create structures to eliminate 2048+4 magic number everywhere. Mostly
adapted from NetBSD.

tested by sturm@@, beck@@. ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.85 2005/06/11 14:49:54 krw Exp $	*/
d1367 1
a1367 1
	struct scsi_mode_sense_buf data;
d1371 5
a1375 1
	error = scsi_do_mode_sense(cd->sc_link, AUDIO_PAGE, &data,
d1377 2
a1378 4
	if (error != 0)
		return (error);
	if (audio == NULL)
		return (EIO);
d1380 12
a1391 11
	audio->port[LEFT_PORT].channels = p0;
	audio->port[RIGHT_PORT].channels = p1;
	audio->port[2].channels = p2;
	audio->port[3].channels = p3;

	if (big)
		error = scsi_mode_select_big(cd->sc_link, SMS_PF,
		    &data.headers.hdr_big, flags, 20000);
	else
		error = scsi_mode_select(cd->sc_link, SMS_PF, &data.headers.hdr,
		    flags, 20000);
d1393 1
d1403 1
a1403 1
	struct scsi_mode_sense_buf data;
d1407 5
a1411 1
	error = scsi_do_mode_sense(cd->sc_link, AUDIO_PAGE, &data,
d1413 9
a1421 9
	if (error != 0)
		return (error);
	if (audio == NULL)
		return (EIO);
		
	arg->vol[0] = audio->port[0].volume;
	arg->vol[1] = audio->port[1].volume;
	arg->vol[2] = audio->port[2].volume;
	arg->vol[3] = audio->port[3].volume;
d1423 1
d1433 1
a1433 1
	struct scsi_mode_sense_buf data;
d1438 4
d1443 1
a1443 1
	    AUDIO_PAGE | SMS_PAGE_CTRL_CHANGEABLE, &data, (void **)&audio, NULL,
d1445 4
a1448 1
	if (error != 0)
d1450 1
a1450 2
	if (audio == NULL)
		return (EIO);
d1457 1
a1457 1
	error = scsi_do_mode_sense(cd->sc_link, AUDIO_PAGE, &data,
d1459 4
a1462 1
	if (error != 0)
d1464 1
a1464 2
	if (audio == NULL)
		return (EIO);
d1473 1
a1473 1
		    &data.headers.hdr_big, flags, 20000);
d1475 2
a1476 2
		error = scsi_mode_select(cd->sc_link, SMS_PF, &data.headers.hdr,
		    flags, 20000);
d1478 1
d1503 1
a1503 1
	struct scsi_mode_sense_buf data;
d1511 5
a1515 1
	error = scsi_do_mode_sense(cd->sc_link, AUDIO_PAGE, &data,
d1517 2
a1518 10
	if (error != 0)
		return (error);
	if (audio == NULL)
		return (EIO);
		
	oflags = audio->flags;
	audio->flags &= ~CD_PA_SOTC;
	audio->flags |= CD_PA_IMMED;
	if (audio->flags == oflags)
		return (0);
d1520 14
a1533 6
	if (big)
		error = scsi_mode_select_big(cd->sc_link, SMS_PF,
		    &data.headers.hdr_big, flags, 20000);
	else
		error = scsi_mode_select(cd->sc_link, SMS_PF, &data.headers.hdr,
		    flags, 20000);
d1535 1
@


1.85
log
@Elminate a few unnecessary casts by using union field names, bit of KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.84 2005/06/05 21:27:07 krw Exp $	*/
d1939 2
a1940 2
	struct scsi_generic cmd;
	u_int8_t buf[4 + 2048];
d1942 5
d1948 1
a1948 2
	bzero(cmd.bytes, sizeof(cmd.bytes));
	bzero(buf, sizeof(buf));
d1950 9
a1958 2
	cmd.bytes[6] = s->type;
	_lto2b(sizeof(buf), &cmd.bytes[7]);
d1960 2
a1961 7
	cmd.bytes[9] = s->disckey.agid << 6;
	error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, sizeof(buf),
	    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
	if (error)
		return (error);
	bcopy(&buf[4], s->disckey.value, 2048);
	return (0);
d1995 2
a1996 2
	struct scsi_generic cmd;
	u_int8_t buf[4 + 2048];
d1998 5
d2004 1
a2004 2
	bzero(cmd.bytes, sizeof(cmd.bytes));
	bzero(buf, sizeof(buf));
d2006 13
a2018 2
	cmd.bytes[6] = s->type;
	_lto2b(sizeof(buf), &cmd.bytes[7]);
d2020 2
a2021 9
	error = scsi_scsi_cmd(cd->sc_link, &cmd, sizeof(cmd), buf, sizeof(buf),
	    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
	if (error)
		return (error);
	s->manufact.len = _2btol(&buf[0]);
	if (s->manufact.len < 0 || s->manufact.len > 2048)
		return (EIO);
	bcopy(&buf[4], s->manufact.value, s->manufact.len);
	return (0);
@


1.84
log
@Fix scsi_mode_select() and scsi_mode_select_big() to send just the
required number of bytes, rather than a full scsi_mode_sense_buf. Some
devices (e.g. my HP SureStore DAT/24) decline to accept such oversized
transfers. Instead, force callers to fill in the data_length field in
the header and use that information to set the size of the transfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.83 2005/06/03 17:29:55 krw Exp $	*/
d1385 1
a1385 1
		    (struct scsi_mode_header_big *)&data, flags, 20000);
d1387 2
a1388 2
		error = scsi_mode_select(cd->sc_link, SMS_PF,
		    (struct scsi_mode_header *)&data, flags, 20000);
d1431 1
a1431 1
	       NULL, NULL, sizeof(*audio), flags, NULL);
d1436 1
a1436 1
		
d1456 1
a1456 1
		    (struct scsi_mode_header_big *)&data, flags, 20000);
d1458 2
a1459 2
		error = scsi_mode_select(cd->sc_link, SMS_PF,
		    (struct scsi_mode_header *)&data, flags, 20000);
d1508 1
a1508 1
		    (struct scsi_mode_header_big *)&data, flags, 20000);
d1510 2
a1511 2
		error = scsi_mode_select(cd->sc_link, SMS_PF,
		    (struct scsi_mode_header *)&data, flags, 20000);
@


1.83
log
@Move definitions of struct cd_softc{} and CDRETRIES from cdvar.h into
cd.h. Remove include of cdvar.h from cd.c. cdvar.h becomes expendable.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.82 2005/06/03 15:50:10 krw Exp $	*/
d1385 1
a1385 2
		    (struct scsi_mode_header_big *)&data, sizeof(data), flags,
		    20000);
d1388 1
a1388 2
		    (struct scsi_mode_header *)&data, sizeof(data), flags,
		    20000);
d1456 1
a1456 2
		    (struct scsi_mode_header_big *)&data, sizeof(data), flags,
		    20000);
d1459 1
a1459 2
		    (struct scsi_mode_header *)&data, sizeof(data), flags,
		    20000);
d1508 1
a1508 2
		    (struct scsi_mode_header_big *)&data, sizeof(data), flags,
		    20000);
d1511 1
a1511 2
		    (struct scsi_mode_header *)&data, sizeof(data), flags,
		    20000);
@


1.82
log
@Tweak scsi_do_mode_sense(). NetBSD was right and I was wrong. Sigh.
Add 'big' parameter to report which mode sense header type is being
returned. Eliminate icky pointer arithmetic, since it won't work if
only block descriptors are returned by the device.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.81 2005/05/27 23:51:53 krw Exp $	*/
a77 2

#include "cdvar.h"
@


1.81
log
@Don't bother issuing a MODE SELECT in cd_set_pa_immed() if we aren't
going to change anything. From NetBSD.

Fixes playing music cd in ATAPI drive in USB enclosure pascoe@@ is
using.

ok pascoe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.80 2005/05/27 16:07:51 krw Exp $	*/
d1371 1
a1371 1
	int error;
d1374 1
a1374 1
	    (void **)&audio, NULL, NULL, NULL, sizeof(*audio), flags);
d1385 1
a1385 1
	if (MODE_HEADER_IS_BIG(&data, audio))
d1408 1
a1408 1
	    (void **)&audio, NULL, NULL, NULL, sizeof(*audio), flags);
d1431 1
a1431 1
	int error;
d1435 1
a1435 1
	       NULL, NULL, sizeof(*audio), flags);
d1447 1
a1447 1
	    (void **)&audio, NULL, NULL, NULL, sizeof(*audio), flags);
d1458 1
a1458 1
	if (MODE_HEADER_IS_BIG(&data, audio))
d1493 1
a1493 1
	int error, oflags;
d1500 1
a1500 1
	    (void **)&audio, NULL, NULL, NULL, sizeof(*audio), flags);
d1512 1
a1512 1
	if (MODE_HEADER_IS_BIG(&data, audio))
@


1.80
log
@Convert cd code to new mode sense framework. Merge cd_scsi and
cd_atapi into cd since code is now almost identical, and only affects
volume adjusting ioctl's. Minor side effect of allowing
cd_load_unload() attempts to scsi cd's as NetBSD does.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.79 2005/05/01 19:29:17 krw Exp $	*/
d1493 1
a1493 1
	int error;
d1506 1
d1509 2
@


1.79
log
@Allow RAW_PART+S_IFCHR device opens to succeed even if media not
present. A successful open is required for ioctl's to work.  Mostly
from NetBSD, partly correcting previous code cleanup error.

From deraadt@@, treat MTIOCTOP+MTRETEN as CDIOCCLOSE for cd devices
(i.e. close the cd drawer).

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.78 2005/04/06 02:51:13 krw Exp $	*/
a72 1
#include <scsi/scsi_cd.h>
d126 5
a181 3
extern struct cd_ops cd_atapibus_ops;
extern struct cd_ops cd_scsibus_ops;

a239 6
	if (sc_link->flags & SDEV_ATAPI) {
		cd->sc_ops = &cd_atapibus_ops;
	} else {
		cd->sc_ops = &cd_scsibus_ops;
	}

d894 1
a894 1
		if ((error = (*cd->sc_ops->cdo_set_pa_immed)(cd, 0)) != 0)
d903 1
a903 1
		if ((error = (*cd->sc_ops->cdo_set_pa_immed)(cd, 0)) != 0)
d912 1
a912 1
		if ((error = (*cd->sc_ops->cdo_set_pa_immed)(cd, 0)) != 0)
d1043 2
a1044 2
		error = (*cd->sc_ops->cdo_setchan)(cd, arg->patch[0],
		    arg->patch[1], arg->patch[2], arg->patch[3], 0);
d1050 1
a1050 1
		error = (*cd->sc_ops->cdo_getvol)(cd, arg, 0);
d1056 1
a1056 1
		error = (*cd->sc_ops->cdo_setvol)(cd, arg, 0);
d1061 2
a1062 2
		error = (*cd->sc_ops->cdo_setchan)(cd, BOTH_CHANNEL,
		    BOTH_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0);
d1066 2
a1067 2
		error = (*cd->sc_ops->cdo_setchan)(cd, LEFT_CHANNEL,
		    RIGHT_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0);
d1071 2
a1072 2
		error = (*cd->sc_ops->cdo_setchan)(cd, MUTE_CHANNEL,
		    MUTE_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0);
d1076 2
a1077 2
		error = (*cd->sc_ops->cdo_setchan)(cd, LEFT_CHANNEL,
		    LEFT_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0);
d1081 2
a1082 2
		error = (*cd->sc_ops->cdo_setchan)(cd, RIGHT_CHANNEL,
		    RIGHT_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0);
d1141 1
a1141 2
		error = (*cd->sc_ops->cdo_load_unload)(cd, args->options,
			args->slot);
d1364 156
@


1.78
log
@De-register scsi.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.77 2005/04/05 02:01:50 krw Exp $	*/
d362 1
d372 2
a373 1
			if (part == RAW_PART && fmt == S_IFCHR)
d375 1
a375 1
			else
d1105 1
d1112 2
@


1.77
log
@Clean up some logic. Use better error handling for sd devices. Be
quiet if raw partition access tried. Be more careful with
SDEV_MEDIA_LOADED. Inspired by some NetBSD changes.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.76 2005/03/30 02:40:42 krw Exp $	*/
d583 1
a583 1
	register void *v;
d585 2
a586 2
	register struct cd_softc *cd = v;
	register struct scsi_link *sc_link = cd->sc_link;
@


1.76
log
@Comment typo, minor knf. No code change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.75 2004/05/09 04:01:59 krw Exp $	*/
d314 1
a314 1
 * open the device. Make sure the partition info is a up-to-date as can be.
d322 1
a323 1
	struct scsi_link *sc_link;
d325 1
a325 1
	int error;
d328 2
a334 1

d337 1
a337 1
	    cd_cd.cd_ndevs, CDPART(dev)));
a343 2
	part = CDPART(dev);

d353 1
a353 1
			goto bad3;
a362 6
		if (error) {
			if (part == RAW_PART && fmt == S_IFCHR)
				goto out;
			else
				goto bad3;
		}
d364 5
a368 4
		/* Start the pack spinning if necessary. */
		error = scsi_start(sc_link, SSS_START,
		    SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT);
d374 1
a374 1
				goto bad3;
d377 1
a377 3
		sc_link->flags |= SDEV_OPEN;

		/* Lock the pack in. */
d383 8
a390 2
		if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
			sc_link->flags |= SDEV_MEDIA_LOADED;
d392 4
a395 12
			/* Load the physical device parameters. */
			if (cd_get_parms(cd, 0) != 0) {
				error = ENXIO;
				goto bad2;
			}
			SC_DEBUG(sc_link, SDEV_DB3, ("Params loaded\n"));

			/* Fabricate a disk label. */
			cdgetdisklabel(dev, cd, cd->sc_dk.dk_label,
			    cd->sc_dk.dk_cpulabel, 0);
			SC_DEBUG(sc_link, SDEV_DB3, ("Disklabel fabricated\n"));
		}
d399 1
a399 2
	if (part != RAW_PART &&
	    (part >= cd->sc_dk.dk_label->d_npartitions ||
d415 1
a415 1

a416 6
	cdunlock(cd);
	device_unref(&cd->sc_dev);
	return (0);

bad2:
	sc_link->flags &= ~SDEV_MEDIA_LOADED;
d418 1
d423 1
a423 1
		sc_link->flags &= ~SDEV_OPEN;
a425 1
bad3:
d432 2
a433 2
 * close the device.. only called if we are the LAST
 * occurence of an open device
@


1.75
log
@Add missing <cr>'s to various SC_DEBUG() calls, along with a few other
SC_DEBUG() spacing tweaks.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.74 2004/02/15 02:45:47 tedu Exp $	*/
d330 1
a330 1
		return ENXIO;
d340 1
a340 1
		return error;
d358 3
a360 3
		 * Check that it is still responding and ok.
		 * Drive can be in progress of loading media so use
		 * increased retries number and don't ignore NOT_READY.
d430 1
a430 1
	return 0;
d445 1
a445 1
	return error;
@


1.74
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.73 2003/11/07 10:16:46 jmc Exp $	*/
d212 1
a212 1
	SC_DEBUG(sc_link, SDEV_DB2, ("cdattach: "));
d399 1
a399 1
			SC_DEBUG(sc_link, SDEV_DB3, ("Params loaded "));
d404 1
a404 1
			SC_DEBUG(sc_link, SDEV_DB3, ("Disklabel fabricated "));
d518 2
a519 3
	SC_DEBUG(cd->sc_link, SDEV_DB2, ("cdstrategy "));
	SC_DEBUG(cd->sc_link, SDEV_DB1,
	    ("%ld bytes @@ blk %d\n", bp->b_bcount, bp->b_blkno));
d614 1
a614 1
	SC_DEBUG(sc_link, SDEV_DB2, ("cdstart "));
d824 1
a824 1
	SC_DEBUG(cd->sc_link, SDEV_DB2, ("cdioctl 0x%lx ", cmd));
@


1.73
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.72 2003/07/30 16:57:54 tedu Exp $	*/
d708 1
a708 1
			disk_unbusy(&cd->sc_dk, 0);
d721 2
a722 1
		disk_unbusy(&cd->sc_dk, xs->bp->b_bcount - xs->bp->b_resid);
@


1.72
log
@reverse booleans so it's clear what we're looking for. ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.71 2003/05/18 16:06:35 mickey Exp $	*/
d777 2
a778 2
 * conversion between minute-seconde-frame and logical block adress
 * adresses format
@


1.71
log
@constify the quirck tables and fix the scsi_inqmatch() proto accordingly; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.70 2003/05/17 16:55:45 krw Exp $	*/
d350 3
a352 2
		if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0 &&
		    (part != RAW_PART || fmt != S_IFCHR)) {
d365 3
a367 1
			if (part != RAW_PART || fmt != S_IFCHR)
a368 2
			else
				goto out;
d377 3
a379 1
			if (part != RAW_PART || fmt != S_IFCHR)
a380 2
			else
				goto out;
@


1.70
log
@READ_CD_CAPCITY -> READ_CD_CAPACITY in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.69 2003/05/16 19:54:05 krw Exp $	*/
d165 1
a165 1
struct scsi_inquiry_pattern cd_patterns[] = {
d194 1
a194 1
	    (caddr_t)cd_patterns, sizeof(cd_patterns)/sizeof(cd_patterns[0]),
@


1.69
log
@Provide most if not all the support required for the usb changes Nate
is trying to bring in.

1) Change name of SDEV_NOCDB6 to SDEV_ONLYBIG to align it with the
same quirk in NetBSD, and make it more clear what it is trying to do.
i.e. force the use of READ_BIG/WRITE_BIG commands, not suppress all
use of 6 byte CDB's.

2) Check SDEV_ONLYBIG in cd.c as well as sd.c. i.e. both places where
a choice is made to use the 6 or 10 byte versions of READ/WRITE.

3) Actually make use of the ADEV_NOTUR (No TEST UNIT READY) quirk to
suppress the emission of TEST UNIT READY commands.

4) Add some explanatory comments from NetBSD to scsiconf.h so that the
use of the quirks is made clear.

ok miod@@ tdeval@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.68 2003/04/06 03:02:44 krw Exp $	*/
d1342 1
a1342 1
	   READ_CD_CAPCITY */
@


1.68
log
@The disklabel fields d_packname and d_typename are not null terminated strings
and should not be created or used as such.

This fixes some instances of both behaviours, and sets the stage for some
strcpy -> strncpy fixup.

ok tdeval@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.67 2003/01/17 04:30:06 jason Exp $	*/
d670 1
@


1.67
log
@The end of the track is one frame before the first frame of the next track
(and right before the leadout track in the case of the last track).  Some
CDROM's are evidentally picky about being asked to play the first frame
of the leadout.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.66 2003/01/05 22:33:23 deraadt Exp $	*/
d1217 1
a1217 1
		strncpy(lp->d_typename, "ATAPI CD-ROM", sizeof(lp->d_typename) - 1);
d1220 1
a1220 1
		strncpy(lp->d_typename, "SCSI CD-ROM", sizeof(lp->d_typename) - 1);
d1224 1
a1224 1
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname) - 1);
@


1.66
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.65 2002/12/30 21:50:28 grange Exp $	*/
d1409 1
d1428 16
d1447 1
a1447 3
	    toc.entries[etrack].addr.msf.minute,
	    toc.entries[etrack].addr.msf.second,
	    toc.entries[etrack].addr.msf.frame));
@


1.65
log
@Add new parameter to scsi_test_unit_ready(): retries number.
Use increased retries number and don't ignore SCSI_IGNORE_NOT_READY
when call scsi_test_unit_ready() for cd-rom, this makes system wait
if drive is loading media.
Tested by millert@@ and fgsch@@; some input and ok from krw@@.
Problem reported by The lord of the CD-writers
Igor Grabin <violent@@death.kiev.ua>.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.64 2002/06/09 00:01:49 art Exp $	*/
d1245 1
a1245 1
	 * Read the TOC and loop throught the individual tracks and lay them
@


1.64
log
@splassert a splbio assumption.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.63 2002/06/08 23:59:47 art Exp $	*/
d356 7
a362 4
		/* Check that it is still responding and ok. */
		error = scsi_test_unit_ready(sc_link,
		    SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE | SCSI_IGNORE_NOT_READY);
@


1.63
log
@KISS. the spl variable doesn't have to be called s, but it make the code less confusing.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.62 2002/06/08 23:58:12 art Exp $	*/
d608 2
@


1.62
log
@splbio around biodone
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.61 2002/05/23 20:29:07 csapuntz Exp $	*/
d507 1
a507 1
	int opri;
d548 1
a548 1
	opri = splbio();
d562 1
a562 1
	splx(opri);
d572 1
a572 1
	opri = splbio();
d574 1
a574 1
	splx(opri);
@


1.61
log
@Signed/unsigned int bug caused lp->d_npartitions to be set to zero.

Should fix disklabel warnings on disks with no data track.

The old code was unnecessary complex too.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.60 2002/03/14 03:16:12 millert Exp $	*/
d572 1
d574 1
@


1.60
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.59 2002/03/14 01:27:13 millert Exp $	*/
d1305 1
a1305 1
	lp->d_npartitions = max(RAW_PART, i - 1) + 1;
@


1.59
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.58 2002/02/01 10:06:18 hin Exp $	*/
d1013 1
a1013 1
		int sessno = *(int*)addr;
d1046 1
a1046 1
		*(int*)addr = (toc->header.len >= 10 && cte->track > 1) ?
@


1.58
log
@cdstrategy(): check that media is loaded before doing anything with the
cd.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.57 2001/10/25 12:59:21 drahn Exp $	*/
d113 33
a145 33
int	cdmatch __P((struct device *, void *, void *));
void	cdattach __P((struct device *, struct device *, void *));
int	cdactivate __P((struct device *, enum devact));
int	cddetach __P((struct device *, int));
void    cdzeroref __P((struct device *));

void	cdstart __P((void *));
void	cdminphys __P((struct buf *));
void	cdgetdisklabel __P((dev_t, struct cd_softc *, struct disklabel *,
			    struct cpu_disklabel *, int));
void	cddone __P((struct scsi_xfer *));
u_long	cd_size __P((struct cd_softc *, int));
void	lba2msf __P((u_long, u_char *, u_char *, u_char *));
u_long	msf2lba __P((u_char, u_char, u_char));
int	cd_play __P((struct cd_softc *, int, int));
int	cd_play_tracks __P((struct cd_softc *, int, int, int, int));
int	cd_play_msf __P((struct cd_softc *, int, int, int, int, int, int));
int	cd_pause __P((struct cd_softc *, int));
int	cd_reset __P((struct cd_softc *));
int	cd_read_subchannel __P((struct cd_softc *, int, int, int,
	    struct cd_sub_channel_info *, int ));
int	cd_read_toc __P((struct cd_softc *, int, int, void *,
			 int, int ));
int	cd_get_parms __P((struct cd_softc *, int));
int	cd_load_toc __P((struct cd_softc *, struct cd_toc *));

int    dvd_auth __P((struct cd_softc *, union dvd_authinfo *));
int    dvd_read_physical __P((struct cd_softc *, union dvd_struct *));
int    dvd_read_copyright __P((struct cd_softc *, union dvd_struct *));
int    dvd_read_disckey __P((struct cd_softc *, union dvd_struct *));
int    dvd_read_bca __P((struct cd_softc *, union dvd_struct *));
int    dvd_read_manufact __P((struct cd_softc *, union dvd_struct *));
int    dvd_read_struct __P((struct cd_softc *, union dvd_struct *));
@


1.57
log
@Allow an empty cd to be opened (raw device/whole disk) primarily to
allow empty CD caddies to be ejected.
Original diff from Alexander Guy. "pretty much straight from NetBSD"
Addition to allow eject (mt) to eject an empty tray.
ok csapuntz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.56 2001/06/22 14:35:42 deraadt Exp $	*/
d518 2
a519 1
	 * The transfer must be a whole number of blocks.
d521 2
a522 2
	if ((bp->b_bcount % cd->sc_dk.dk_label->d_secsize) != 0) {
		bp->b_error = EINVAL;
d526 1
a526 2
	 * If the device has been made invalid, error out
	 * maybe the media changed
d528 2
a529 2
	if ((cd->sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
		bp->b_error = EIO;
@


1.57.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.57 2001/10/25 12:59:21 drahn Exp $	*/
d113 33
a145 33
int	cdmatch(struct device *, void *, void *);
void	cdattach(struct device *, struct device *, void *);
int	cdactivate(struct device *, enum devact);
int	cddetach(struct device *, int);
void    cdzeroref(struct device *);

void	cdstart(void *);
void	cdminphys(struct buf *);
void	cdgetdisklabel(dev_t, struct cd_softc *, struct disklabel *,
			    struct cpu_disklabel *, int);
void	cddone(struct scsi_xfer *);
u_long	cd_size(struct cd_softc *, int);
void	lba2msf(u_long, u_char *, u_char *, u_char *);
u_long	msf2lba(u_char, u_char, u_char);
int	cd_play(struct cd_softc *, int, int);
int	cd_play_tracks(struct cd_softc *, int, int, int, int);
int	cd_play_msf(struct cd_softc *, int, int, int, int, int, int);
int	cd_pause(struct cd_softc *, int);
int	cd_reset(struct cd_softc *);
int	cd_read_subchannel(struct cd_softc *, int, int, int,
	    struct cd_sub_channel_info *, int );
int	cd_read_toc(struct cd_softc *, int, int, void *,
			 int, int );
int	cd_get_parms(struct cd_softc *, int);
int	cd_load_toc(struct cd_softc *, struct cd_toc *);

int    dvd_auth(struct cd_softc *, union dvd_authinfo *);
int    dvd_read_physical(struct cd_softc *, union dvd_struct *);
int    dvd_read_copyright(struct cd_softc *, union dvd_struct *);
int    dvd_read_disckey(struct cd_softc *, union dvd_struct *);
int    dvd_read_bca(struct cd_softc *, union dvd_struct *);
int    dvd_read_manufact(struct cd_softc *, union dvd_struct *);
int    dvd_read_struct(struct cd_softc *, union dvd_struct *);
d507 1
a507 1
	int s;
d518 1
a518 2
	 * If the device has been made invalid, error out
	 * maybe the media changed, or no media loaded
d520 2
a521 2
	if ((cd->sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
		bp->b_error = EIO;
d525 2
a526 1
	 * The transfer must be a whole number of blocks.
d528 2
a529 2
	if ((bp->b_bcount % cd->sc_dk.dk_label->d_secsize) != 0) {
		bp->b_error = EINVAL;
d548 1
a548 1
	s = splbio();
d562 1
a562 1
	splx(s);
a571 1
	s = splbio();
a572 1
	splx(s);
a606 2
	splassert(IPL_BIO);

d1013 1
a1013 1
		int sessno = *(int *)addr;
d1046 1
a1046 1
		*(int *)addr = (toc->header.len >= 10 && cte->track > 1) ?
d1305 1
a1305 1
	lp->d_npartitions = max((RAW_PART + 1), i);
@


1.57.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d356 4
a359 7
		/*
		 * Check that it is still responding and ok.
		 * Drive can be in progress of loading media so use
		 * increased retries number and don't ignore NOT_READY.
		 */
		error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_CD,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
a666 1
		    !(sc_link->quirks & SDEV_ONLYBIG) && 
d1214 1
a1214 1
		strncpy(lp->d_typename, "ATAPI CD-ROM", sizeof(lp->d_typename));
d1217 1
a1217 1
		strncpy(lp->d_typename, "SCSI CD-ROM", sizeof(lp->d_typename));
d1221 1
a1221 1
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
d1242 1
a1242 1
	 * Read the TOC and loop through the individual tracks and lay them
a1405 1
	u_char endf, ends, endm;
a1423 16
	/*
	 * The track ends one frame before the next begins.  The last track
	 * is taken care of by the leadoff track.
	 */
	endm = toc.entries[etrack].addr.msf.minute;
	ends = toc.entries[etrack].addr.msf.second;
	endf = toc.entries[etrack].addr.msf.frame;
	if (endf-- == 0) {
		endf = CD_FRAMES - 1;
		if (ends-- == 0) {
			ends = CD_SECS - 1;
			if (endm-- == 0)
				return (EINVAL);
		}
	}

d1427 3
a1429 1
	    endm, ends, endf));
@


1.56
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.55 2000/07/18 06:09:00 csapuntz Exp $	*/
d343 2
d350 2
a351 1
		if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
d360 7
a366 3
		if (error)
			goto bad3;

d371 7
a377 2
		if (error)
			goto bad3;
a403 2
	part = CDPART(dev);

d412 1
a412 1
	/* Insure only one open at a time. */
d847 1
@


1.55
log
@

Update cd_size to handle failure of READ_CD_CAPACITY by returning
some default values
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.54 2000/04/18 06:34:18 csapuntz Exp $	*/
d85 1
a85 1
#define	CDMINOR(unit, part)	       	DISKMINOR(unit, part)
d115 2
a116 2
int     cdactivate __P((struct device *, enum devact));
int     cddetach __P((struct device *, int));
d133 1
a133 1
			        struct cd_sub_channel_info *, int ));
d251 2
a252 2
        struct device *self;
        enum devact act;
d254 1
a254 1
        int rv = 0;
d256 11
a266 11
        switch (act) {
        case DVACT_ACTIVATE:
                break;

        case DVACT_DEACTIVATE:
                /*
                 * Nothing to do; we key off the device's DVF_ACTIVATE.
                 */
                break;
        }
        return (rv);
d272 2
a273 2
        struct device *self;
        int flags;
d275 3
a277 3
        struct cd_softc *sc = (struct cd_softc *)self;
        struct buf *dp, *bp;
        int s, bmaj, cmaj, mn;
d290 2
a291 2
        /* locate the major number */
        mn = CDMINOR(self->dv_unit, 0);
d293 2
a294 2
        for (bmaj = 0; bmaj < nblkdev; bmaj++)
                if (bdevsw[bmaj].d_open == cdopen)
d296 2
a297 2
        for (cmaj = 0; cmaj < nchrdev; cmaj++)
                if (cdevsw[cmaj].d_open == cdopen)
d299 1
a299 1
        return (0);
d304 1
a304 1
        struct device *self;
d306 1
a306 1
        struct cd_softc *cd = (struct cd_softc *)self;
d308 2
a309 2
        /* Detach disk. */
        disk_detach(&cd->sc_dk);
d355 2
a356 3
					     SCSI_IGNORE_ILLEGAL_REQUEST |
					     SCSI_IGNORE_MEDIA_CHANGE |
					     SCSI_IGNORE_NOT_READY);
d362 2
a363 2
				   SCSI_IGNORE_ILLEGAL_REQUEST |
				   SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT);
d371 1
a371 2
				     SCSI_IGNORE_ILLEGAL_REQUEST |
				     SCSI_IGNORE_MEDIA_CHANGE);
d397 1
a397 1
	     cd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
d643 2
a644 2
		      p = &cd->sc_dk.dk_label->d_partitions[CDPART(bp->b_dev)];
		      blkno += p->p_offset;
d960 1
a960 1
			       
d984 1
a984 1
						     sizeof(cte->addr) / 2);
d1026 1
a1026 1
				     sizeof(cte->addr) / 2);
d1248 1
a1248 1
        /* Probably should sanity-check the drive's values */
d1603 1
a1603 1
				      CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1614 1
a1614 1
				      CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1625 1
a1625 1
				      CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1637 1
a1637 1
				      CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1651 1
a1651 1
				      CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1664 1
a1664 2
				      CDRETRIES, 30000, NULL,
				      SCSI_DATA_OUT);
d1677 1
a1677 2
				      CDRETRIES, 30000, NULL,
				      SCSI_DATA_OUT);
d1689 1
a1689 1
				      CDRETRIES, 30000, NULL, 0);
d1718 1
a1718 1
			      CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1722 15
a1736 15
	     i++, bufp += 20, layer++) {
	        bzero(layer, sizeof(*layer));
                layer->book_version = bufp[0] & 0xf;
                layer->book_type = bufp[0] >> 4;
                layer->min_rate = bufp[1] & 0xf;
                layer->disc_size = bufp[1] >> 4;
                layer->layer_type = bufp[2] & 0xf;
                layer->track_path = (bufp[2] >> 4) & 1;
                layer->nlayers = (bufp[2] >> 5) & 3;
                layer->track_density = bufp[3] & 0xf;
                layer->linear_density = bufp[3] >> 4;
                layer->start_sector = _4btol(&bufp[4]);
                layer->end_sector = _4btol(&bufp[8]);
                layer->end_sector_l0 = _4btol(&bufp[12]);
                layer->bca = bufp[16] >> 7;
d1758 1
a1758 1
			      CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1783 1
a1783 1
			      CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1806 1
a1806 1
			      CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1832 1
a1832 1
			      CDRETRIES, 30000, NULL, SCSI_DATA_IN);
@


1.54
log
@

cd detach
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.53 2000/04/18 05:53:17 csapuntz Exp $	*/
d1323 5
d1329 2
a1330 9
	if (cd->sc_link->quirks & ADEV_NOCAPACITY) {
		/*
		 * the drive doesn't support the READ_CD_CAPACITY command
		 * use a fake size
		 */
		cd->params.blksize = 2048;
		cd->params.disksize = 400000;
		return (400000);
	}
d1347 1
a1347 1
		return (0);
d1359 1
d1361 1
a1361 1
	return (size);
@


1.53
log
@

sd and scsibus detach

cdlock/cdunlock now through disk_lock/disk_unlock
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.52 2000/04/09 07:09:03 csapuntz Exp $	*/
d69 1
d85 1
d115 4
d148 2
a149 1
	sizeof(struct cd_softc), cdmatch, cdattach
d183 1
d248 65
d328 2
a329 4
	if (unit >= cd_cd.cd_ndevs)
		return ENXIO;
	cd = cd_cd.cd_devs[unit];
	if (!cd)
d338 2
a339 1
	if ((error = cdlock(cd)) != 0)
d341 1
a341 12

#ifdef CDDA
	/*
	 * We can't open the block device if the drive is in CDDA
	 * mode.  If we allow such opens, either the drive will get
	 * quite unhappy about undersized I/O or the BSD I/O subsystem
	 * will start trashing memory with disk transfers overrunning
	 * the end of their buffers.  Either way, it's Bad.
	 */
	if (cd->flags & CDF_CDDAMODE && fmt == S_IFBLK)
		return EBUSY;
#endif
a351 10
#ifdef CDDA
		/*
		 * If it's in CDDA mode, process may only open the
		 * raw partition
		 */
		if (cd->flags & CDF_CDDAMODE && part != RAW_PART) {
			error = EBUSY;
			goto bad3;
		}
#endif
d417 1
d432 1
d446 1
a446 1
	struct cd_softc *cd = cd_cd.cd_devs[CDUNIT(dev)];
d450 6
a455 1
	if ((error = cdlock(cd)) != 0)
d457 1
d484 2
d498 1
a498 1
	struct cd_softc *cd = cd_cd.cd_devs[CDUNIT(bp->b_dev)];
d501 5
a529 12
#ifdef CDDA
	/*
	 * If in CDDA mode, return immediately (the user must issue
	 * SCSI read commands directly using SCIOCCOMMAND).  The BSD
	 * I/O subsystem just can't deal with bizzare block sizes like
	 * those used for CD-DA frames.
	 */
	if (cd->flags & CDF_CDDAMODE) {
		bp->b_error = EIO;
		goto bad;
	}
#endif
d552 2
a553 1

d565 2
d711 1
a711 1
	struct cd_softc *cd = cd_cd.cd_devs[CDUNIT(bp->b_dev)];
d714 4
d799 1
a799 1
	struct cd_softc *cd = cd_cd.cd_devs[CDUNIT(dev)];
d801 5
a805 1
	int error;
d844 1
a844 1
				return (ENODEV);
d846 2
a847 1
				return (EIO);
d855 1
a855 1
		return 0;
d859 1
a859 1
		return 0;
d865 1
a865 1
		return 0;
d869 4
a872 2
		if ((flag & FWRITE) == 0)
			return EBADF;
d875 2
a876 1
			return error;
d887 2
a888 2
		return error;

d890 2
a891 1
		return EBADF;
d897 4
a900 3
			return (error);
		return (cd_play_tracks(cd, args->start_track,
		    args->start_index, args->end_track, args->end_index));
d906 4
a909 3
			return (error);
		return (cd_play_msf(cd, args->start_m, args->start_s,
		    args->start_f, args->end_m, args->end_s, args->end_f));
d915 3
a917 2
			return (error);
		return (cd_play(cd, args->blk, args->len));
d925 4
a928 2
		    len < sizeof(struct cd_sub_channel_header))
			return EINVAL;
d933 1
a933 1
			return error;
d936 2
a937 1
		return copyout(&data, args->data, len);
d943 2
a944 2
			return (error);
		if (cd->sc_link->quirks & ADEV_LITTLETOC) {
d946 1
a946 1
		} else
d949 1
a949 1
		return (0);
a958 1
		int res;
d968 2
a969 1
			return (EINVAL);
d975 1
a975 1
			return (error);
d998 1
a998 1
		res = copyout(toc->entries, te->data, len);
d1000 1
a1000 2

		return (res);
d1007 4
a1010 2
		if (sessno != 0)
			return (EINVAL);
d1021 1
a1021 1
			return (error);
d1032 1
a1032 1
		if (cd->sc_link->quirks & ADEV_LITTLETOC) {
d1034 1
a1034 1
		} else
d1040 1
a1040 1
		return 0;
d1045 3
a1047 2
		return ((*cd->sc_ops->cdo_setchan)(cd, arg->patch[0],
		    arg->patch[1], arg->patch[2], arg->patch[3], 0));
d1052 2
a1053 1
		return ((*cd->sc_ops->cdo_getvol)(cd, arg, 0));
d1058 2
a1059 1
		return ((*cd->sc_ops->cdo_setvol)(cd, arg, 0));
d1063 3
a1065 2
		return ((*cd->sc_ops->cdo_setchan)(cd, BOTH_CHANNEL,
		    BOTH_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0));
d1068 3
a1070 2
		return ((*cd->sc_ops->cdo_setchan)(cd, LEFT_CHANNEL,
		    RIGHT_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0));
d1073 3
a1075 2
		return ((*cd->sc_ops->cdo_setchan)(cd, MUTE_CHANNEL,
		    MUTE_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0));
d1078 3
a1080 2
		return ((*cd->sc_ops->cdo_setchan)(cd, LEFT_CHANNEL,
		    LEFT_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0));
d1083 4
a1086 2
		return ((*cd->sc_ops->cdo_setchan)(cd, RIGHT_CHANNEL,
		    RIGHT_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0));
d1088 3
a1090 1
		return cd_pause(cd, 1);
d1092 2
a1093 1
		return cd_pause(cd, 0);
d1095 3
a1097 1
		return scsi_start(cd->sc_link, SSS_START, 0);
d1099 3
a1101 1
		return scsi_start(cd->sc_link, SSS_STOP, 0);
d1103 3
a1105 2
		return (scsi_start(cd->sc_link, SSS_START|SSS_LOEJ, 
		    SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE));
d1108 4
a1111 2
		if (((struct mtop *)addr)->mt_op != MTOFFL)
			return EIO;
d1116 1
a1116 1
		return 0;
d1118 2
a1119 1
		return scsi_prevent(cd->sc_link, PR_ALLOW, 0);
d1121 2
a1122 1
		return scsi_prevent(cd->sc_link, PR_PREVENT, 0);
d1124 1
a1124 1
		return scsi_prevent(cd->sc_link,
d1126 1
d1129 1
a1129 1
		return 0;
d1132 1
a1132 62
		return 0;
#ifdef CDDA
	case CDIOCSETCDDA: {
		int onoff = *(int *)addr;
		/* select CD-DA mode */
		struct scsi_cd_mode_data data;

		if (CDPART(dev) != RAW_PART)
			return ENOTTY;
		if ((error = cd_get_mode(cd, &data, AUDIO_PAGE)) != 0)
			return error;
		if (onoff) {
			/* turn it on */
			if (cd->flags & CDF_CDDAMODE)
				return EALREADY;
			/*
			 * do not permit changing of block size if the block
			 * device is open, or if some other partition (not
			 * a raw partition) is open.
			 */
			if (cd->sc_dk.dk_bopenmask ||
			    (cd->sc_dk.dk_copenmask & ~(1 << RAW_PART)))
				return EBUSY;

			data.blk_desc.density = CD_DA_DENSITY_CODE;
			data.blk_desc.blklen[0] = (CD_DA_BLKSIZ >> 16) & 0xff;
			data.blk_desc.blklen[1] = (CD_DA_BLKSIZ >> 8) & 0xff;
			data.blk_desc.blklen[2] = CD_DA_BLKSIZ & 0xff;

			if (cd_set_mode(cd, &data) != 0) 
				return EIO;

			cd->orig_params = cd->params;
			cd->flags |= CDF_CDDAMODE;
		} else {
			if (!(cd->flags & CDF_CDDAMODE))
				return EALREADY;
			/* turn it off */
			data.blk_desc.density = CD_NORMAL_DENSITY_CODE;
			data.blk_desc.blklen[0] = (cd->orig_params.blksize >> 16) & 0xff;
			data.blk_desc.blklen[1] = (cd->orig_params.blksize >> 8) & 0xff;
			data.blk_desc.blklen[2] = (cd->orig_params.blksize) & 0xff;

			if (cd_set_mode(cd, &data) != 0)
				return EIO;

			cd->flags &= ~CDF_CDDAMODE;
			cd->params = cd->orig_params;
		}
		if (cd_get_parms(cd, 0) != 0) {
			data.blk_desc.density = CD_NORMAL_DENSITY_CODE;
			data.blk_desc.blklen[0] = (cd->orig_params.blksize >> 16) & 0xff;
			data.blk_desc.blklen[1] = (cd->orig_params.blksize >> 8) & 0xff;
			data.blk_desc.blklen[2] = (cd->orig_params.blksize) & 0xff;
			(void) cd_set_mode(cd, &data); /* it better work...! */
			cd->params = cd->orig_params;
			return EIO;
		}
		return 0;
	}
#endif

d1135 2
a1136 1
		return (cd_reset(cd));
d1140 3
a1142 2
		return ((*cd->sc_ops->cdo_load_unload)(cd, args->options,
			args->slot));
d1146 2
a1147 2
		return (dvd_auth(cd, (union dvd_authinfo *)addr));

d1149 2
a1150 2
		return (dvd_read_struct(cd, (union dvd_struct *)addr));
	
d1152 6
a1157 3
		if (CDPART(dev) != RAW_PART)
			return ENOTTY;
		return scsi_do_ioctl(cd->sc_link, dev, cmd, addr, flag, p);
d1160 4
a1163 3
#ifdef DIAGNOSTIC
	panic("cdioctl: impossible");
#endif
@


1.52
log
@

Don't trust the TOC coming from the drive so much.

Be better about handling failures of SCSI CD READ TOC command.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.51 1999/11/12 05:52:58 angelos Exp $	*/
a112 2
int	cdlock __P((struct cd_softc *));
void	cdunlock __P((struct cd_softc *));
d174 3
a237 36
}

/*
 * Wait interruptibly for an exclusive lock.
 *
 * XXX
 * Several drivers do this; it should be abstracted and made MP-safe.
 */
int
cdlock(cd)
	struct cd_softc *cd;
{
	int error;

	while ((cd->flags & CDF_LOCKED) != 0) {
		cd->flags |= CDF_WANTED;
		if ((error = tsleep(cd, PRIBIO | PCATCH, "cdlck", 0)) != 0)
			return error;
	}
	cd->flags |= CDF_LOCKED;
	return 0;
}

/*
 * Unlock and wake up any waiters.
 */
void
cdunlock(cd)
	struct cd_softc *cd;
{

	cd->flags &= ~CDF_LOCKED;
	if ((cd->flags & CDF_WANTED) != 0) {
		cd->flags &= ~CDF_WANTED;
		wakeup(cd);
	}
@


1.51
log
@Use cdio.h instead of dvdio.h
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.50 1999/11/11 19:15:19 csapuntz Exp $	*/
d1176 1
d1225 1
d1227 2
a1228 1
		return;
d1230 4
d1241 2
d1252 1
a1252 3
	for (tocidx = hdr[TOC_HEADER_STARTING_TRACK]; 
	     tocidx <= hdr[TOC_HEADER_ENDING_TRACK]; 
	     tocidx++) {
d1294 1
a1294 6
	if (data_track != -1) {
#if 0
		/* This might not necessarily work */
		errstring = readdisklabel(MAKECDDEV(major(dev), CDUNIT(dev), 
		    data_track), cdstrategy, lp, clp, spoofonly);
#else
a1296 1
#endif
d1512 1
@


1.51.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.55 2000/07/18 06:09:00 csapuntz Exp $	*/
a68 1
#include <sys/vnode.h>
a83 1
#define	CDMINOR(unit, part)	       	DISKMINOR(unit, part)
d113 2
a114 4
int     cdactivate __P((struct device *, enum devact));
int     cddetach __P((struct device *, int));
void    cdzeroref __P((struct device *));

d144 1
a144 2
	sizeof(struct cd_softc), cdmatch, cdattach,
	cddetach, cdactivate, cdzeroref
a175 4
#define cdlock(softc)   disk_lock(&(softc)->sc_dk)
#define cdunlock(softc) disk_unlock(&(softc)->sc_dk)
#define cdlookup(unit) (struct cd_softc *)device_lookup(&cd_cd, (unit))

d239 6
a244 1

d246 4
a249 18
cdactivate(self, act)
        struct device *self;
        enum devact act;
{
        int rv = 0;

        switch (act) {
        case DVACT_ACTIVATE:
                break;

        case DVACT_DEACTIVATE:
                /*
                 * Nothing to do; we key off the device's DVF_ACTIVATE.
                 */
                break;
        }
        return (rv);
}
d251 7
a257 31

int
cddetach(self, flags)
        struct device *self;
        int flags;
{
        struct cd_softc *sc = (struct cd_softc *)self;
        struct buf *dp, *bp;
        int s, bmaj, cmaj, mn;

	/* Remove unprocessed buffers from queue */
	s = splbio();
	for (dp = &sc->buf_queue; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;
		
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		biodone(bp);
	}
	splx(s);

        /* locate the major number */
        mn = CDMINOR(self->dv_unit, 0);

        for (bmaj = 0; bmaj < nblkdev; bmaj++)
                if (bdevsw[bmaj].d_open == cdopen)
			vdevgone(bmaj, mn, mn + MAXPARTITIONS - 1, VBLK);
        for (cmaj = 0; cmaj < nchrdev; cmaj++)
                if (cdevsw[cmaj].d_open == cdopen)
			vdevgone(cmaj, mn, mn + MAXPARTITIONS - 1, VCHR);
        return (0);
d260 3
d264 2
a265 2
cdzeroref(self)
        struct device *self;
a266 1
        struct cd_softc *cd = (struct cd_softc *)self;
d268 5
a272 2
        /* Detach disk. */
        disk_detach(&cd->sc_dk);
a274 1

d290 4
a293 2
	cd = cdlookup(unit);
	if (cd == NULL)
d302 1
a302 2
	if ((error = cdlock(cd)) != 0) {
		device_unref(&cd->sc_dev);
d304 12
a315 1
	}
d326 10
a400 1
	device_unref(&cd->sc_dev);
a414 1
	device_unref(&cd->sc_dev);
d428 1
a428 1
	struct cd_softc *cd;
d432 1
a432 6
	cd = cdlookup(CDUNIT(dev));
	if (cd == NULL)
		return ENXIO;

	if ((error = cdlock(cd)) != 0) {
		device_unref(&cd->sc_dev);
a433 1
	}
a459 2

	device_unref(&cd->sc_dev);
d472 1
a472 1
	struct cd_softc *cd;
a474 5
	if ((cd = cdlookup(CDUNIT(bp->b_dev))) == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}

d499 12
d533 1
a533 2
	
	device_unref(&cd->sc_dev);
a544 2
	if (cd != NULL)
		device_unref(&cd->sc_dev);
d689 1
a689 1
	struct cd_softc *cd;
a691 4
	cd = cdlookup(CDUNIT(bp->b_dev));
	if (cd == NULL)
		return;

d773 1
a773 1
	struct cd_softc *cd;
d775 1
a775 5
	int error = 0;

	cd = cdlookup(CDUNIT(dev));
	if (cd == NULL)
		return ENXIO;
d814 1
a814 1
				error = ENODEV;
d816 1
a816 2
				error = EIO;
			goto exit;
d824 1
a824 1
		break;
d828 1
a828 1
		break;
d834 1
a834 1
		break;
d838 2
a839 4
		if ((flag & FWRITE) == 0) {
			error = EBADF;
			break;
		}
d842 1
a842 2
			break;

d853 2
a854 2
		break;
		
d856 1
a856 2
		error = EBADF;
		break;
d862 3
a864 4
			break;
		error = cd_play_tracks(cd, args->start_track,
		    args->start_index, args->end_track, args->end_index);
		break;
d870 3
a872 4
			break;
		error = cd_play_msf(cd, args->start_m, args->start_s,
		    args->start_f, args->end_m, args->end_s, args->end_f);
		break;
d878 2
a879 3
			break;
		error = cd_play(cd, args->blk, args->len);
		break;
d887 2
a888 4
		    len < sizeof(struct cd_sub_channel_header)) {
			error = EINVAL;
			break;
		}
d893 1
a893 1
			break;
d896 1
a896 2
		error = copyout(&data, args->data, len);
		break;
d902 2
a903 2
			break;
		if (cd->sc_link->quirks & ADEV_LITTLETOC) 
d905 1
a905 1
		else
d908 1
a908 1
		break;
d918 1
d928 1
a928 2
			error = EINVAL;
			break;
d934 1
a934 1
			break;
d957 1
a957 1
		error = copyout(toc->entries, te->data, len);
d959 2
a960 1
		break;
d967 2
a968 4
		if (sessno != 0) {
			error = EINVAL;
			break;
		}
d979 1
a979 1
			break;
d990 1
a990 1
		if (cd->sc_link->quirks & ADEV_LITTLETOC)
d992 1
a992 1
		else
d998 1
a998 1
		break;
d1003 2
a1004 3
		error = (*cd->sc_ops->cdo_setchan)(cd, arg->patch[0],
		    arg->patch[1], arg->patch[2], arg->patch[3], 0);
		break;
d1009 1
a1009 2
		error = (*cd->sc_ops->cdo_getvol)(cd, arg, 0);
		break;
d1014 1
a1014 2
		error = (*cd->sc_ops->cdo_setvol)(cd, arg, 0);
		break;
d1018 2
a1019 3
		error = (*cd->sc_ops->cdo_setchan)(cd, BOTH_CHANNEL,
		    BOTH_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0);
		break;
d1022 2
a1023 3
		error = (*cd->sc_ops->cdo_setchan)(cd, LEFT_CHANNEL,
		    RIGHT_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0);
		break;
d1026 2
a1027 3
		error = (*cd->sc_ops->cdo_setchan)(cd, MUTE_CHANNEL,
		    MUTE_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0);
		break;
d1030 2
a1031 3
		error = (*cd->sc_ops->cdo_setchan)(cd, LEFT_CHANNEL,
		    LEFT_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0);
		break;
d1034 2
a1035 4
		error = (*cd->sc_ops->cdo_setchan)(cd, RIGHT_CHANNEL,
		    RIGHT_CHANNEL, MUTE_CHANNEL, MUTE_CHANNEL, 0);
		break;

d1037 1
a1037 3
		error = cd_pause(cd, 1);
		break;

d1039 1
a1039 2
		error = cd_pause(cd, 0);
		break;
d1041 1
a1041 3
		error = scsi_start(cd->sc_link, SSS_START, 0);
		break;

d1043 1
a1043 3
		error = scsi_start(cd->sc_link, SSS_STOP, 0);
		break;

d1045 2
a1046 3
		error = scsi_start(cd->sc_link, SSS_START|SSS_LOEJ, 
		    SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);
		break;
d1049 2
a1050 4
		if (((struct mtop *)addr)->mt_op != MTOFFL) {
			error = EIO;
			break;
		}
d1055 1
a1055 1
		break;
d1057 1
a1057 2
		error = scsi_prevent(cd->sc_link, PR_ALLOW, 0);
		break;
d1059 1
a1059 2
		error = scsi_prevent(cd->sc_link, PR_PREVENT, 0);
		break;
d1061 1
a1061 1
		error = scsi_prevent(cd->sc_link,
a1062 1
		break;
d1065 1
a1065 1
		break;
d1068 62
a1129 1
		break;
d1132 1
a1132 2
		error = cd_reset(cd);
		break;
d1136 2
a1137 3
		error = (*cd->sc_ops->cdo_load_unload)(cd, args->options,
			args->slot);
		break;
d1141 2
a1142 2
		error = dvd_auth(cd, (union dvd_authinfo *)addr);
		break;
d1144 2
a1145 2
		error = dvd_read_struct(cd, (union dvd_struct *)addr);
		break;
d1147 3
a1149 6
		if (CDPART(dev) != RAW_PART) {
			error = ENOTTY;
			break;
		}
		error = scsi_do_ioctl(cd->sc_link, dev, cmd, addr, flag, p);
		break;
d1152 3
a1154 4
 exit:

	device_unref(&cd->sc_dev);
	return (error);
a1175 1
	int toc_valid = 0;
a1223 1
	bzero(hdr, sizeof(hdr));
d1225 1
a1225 2
		goto done;

a1226 4

	if (n <= 0)
		goto done;

a1233 2
        /* Probably should sanity-check the drive's values */
	toc_valid = 1;  
d1243 3
a1245 1
	for (tocidx = 1; tocidx <= n; tocidx++) {
d1287 6
a1292 1
	if (data_track != -1 || !toc_valid) {
d1295 1
a1312 5
	
	/* Reasonable defaults for drives that don't support
	   READ_CD_CAPCITY */
	cd->params.blksize = 2048;
	cd->params.disksize = 400000;
d1314 9
a1322 2
	if (cd->sc_link->quirks & ADEV_NOCAPACITY)
		goto exit;
d1339 1
a1339 1
		goto exit;
a1350 1
 exit:
d1352 1
a1352 1
	return (cd->params.disksize);
a1510 1

@


1.51.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.51.2.1 2001/05/14 22:44:58 niklas Exp $	*/
d85 1
a85 1
#define	CDMINOR(unit, part)		DISKMINOR(unit, part)
d115 2
a116 2
int	cdactivate __P((struct device *, enum devact));
int	cddetach __P((struct device *, int));
d133 1
a133 1
	    struct cd_sub_channel_info *, int ));
d251 2
a252 2
	struct device *self;
	enum devact act;
d254 1
a254 1
	int rv = 0;
d256 11
a266 11
	switch (act) {
	case DVACT_ACTIVATE:
		break;

	case DVACT_DEACTIVATE:
		/*
		 * Nothing to do; we key off the device's DVF_ACTIVATE.
		 */
		break;
	}
	return (rv);
d272 2
a273 2
	struct device *self;
	int flags;
d275 3
a277 3
	struct cd_softc *sc = (struct cd_softc *)self;
	struct buf *dp, *bp;
	int s, bmaj, cmaj, mn;
d290 2
a291 2
	/* locate the major number */
	mn = CDMINOR(self->dv_unit, 0);
d293 2
a294 2
	for (bmaj = 0; bmaj < nblkdev; bmaj++)
		if (bdevsw[bmaj].d_open == cdopen)
d296 2
a297 2
	for (cmaj = 0; cmaj < nchrdev; cmaj++)
		if (cdevsw[cmaj].d_open == cdopen)
d299 1
a299 1
	return (0);
d304 1
a304 1
	struct device *self;
d306 1
a306 1
	struct cd_softc *cd = (struct cd_softc *)self;
d308 2
a309 2
	/* Detach disk. */
	disk_detach(&cd->sc_dk);
d355 3
a357 2
		    SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE | SCSI_IGNORE_NOT_READY);
d363 2
a364 2
		    SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT);
d372 2
a373 1
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
d399 1
a399 1
	    cd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
d645 2
a646 2
			p = &cd->sc_dk.dk_label->d_partitions[CDPART(bp->b_dev)];
			blkno += p->p_offset;
d962 1
a962 1

d986 1
a986 1
					    sizeof(cte->addr) / 2);
d1028 1
a1028 1
			    sizeof(cte->addr) / 2);
d1250 1
a1250 1
	/* Probably should sanity-check the drive's values */
d1605 1
a1605 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1616 1
a1616 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1627 1
a1627 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1639 1
a1639 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1653 1
a1653 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1666 2
a1667 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_OUT);
d1680 2
a1681 1
		    CDRETRIES, 30000, NULL, SCSI_DATA_OUT);
d1693 1
a1693 1
		    CDRETRIES, 30000, NULL, 0);
d1722 1
a1722 1
	    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1726 15
a1740 15
	    i++, bufp += 20, layer++) {
		bzero(layer, sizeof(*layer));
		layer->book_version = bufp[0] & 0xf;
		layer->book_type = bufp[0] >> 4;
		layer->min_rate = bufp[1] & 0xf;
		layer->disc_size = bufp[1] >> 4;
		layer->layer_type = bufp[2] & 0xf;
		layer->track_path = (bufp[2] >> 4) & 1;
		layer->nlayers = (bufp[2] >> 5) & 3;
		layer->track_density = bufp[3] & 0xf;
		layer->linear_density = bufp[3] >> 4;
		layer->start_sector = _4btol(&bufp[4]);
		layer->end_sector = _4btol(&bufp[8]);
		layer->end_sector_l0 = _4btol(&bufp[12]);
		layer->bca = bufp[16] >> 7;
d1762 1
a1762 1
	    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1787 1
a1787 1
	    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1810 1
a1810 1
	    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
d1836 1
a1836 1
	    CDRETRIES, 30000, NULL, SCSI_DATA_IN);
@


1.51.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.51.2.2 2001/07/04 10:59:59 niklas Exp $	*/
a342 2
	part = CDPART(dev);

d348 1
a348 2
		if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0 &&
		    (part != RAW_PART || fmt != S_IFCHR)) {
d357 3
a359 7
		if (error) {
			if (part != RAW_PART || fmt != S_IFCHR)
				goto bad3;
			else
				goto out;
		}
			
d364 2
a365 7

		if (error) {
			if (part != RAW_PART || fmt != S_IFCHR)
				goto bad3;
			else
				goto out;
		}
d392 2
d402 1
a402 1
out:	/* Insure only one open at a time. */
a836 1
		case MTIOCTOP:
@


1.51.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d518 1
a518 2
	 * If the device has been made invalid, error out
	 * maybe the media changed, or no media loaded
d520 2
a521 2
	if ((cd->sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
		bp->b_error = EIO;
d525 2
a526 1
	 * The transfer must be a whole number of blocks.
d528 2
a529 2
	if ((bp->b_bcount % cd->sc_dk.dk_label->d_secsize) != 0) {
		bp->b_error = EINVAL;
@


1.51.2.5
log
@Merge in -current from roughly a week ago
@
text
@d113 33
a145 33
int	cdmatch(struct device *, void *, void *);
void	cdattach(struct device *, struct device *, void *);
int	cdactivate(struct device *, enum devact);
int	cddetach(struct device *, int);
void    cdzeroref(struct device *);

void	cdstart(void *);
void	cdminphys(struct buf *);
void	cdgetdisklabel(dev_t, struct cd_softc *, struct disklabel *,
			    struct cpu_disklabel *, int);
void	cddone(struct scsi_xfer *);
u_long	cd_size(struct cd_softc *, int);
void	lba2msf(u_long, u_char *, u_char *, u_char *);
u_long	msf2lba(u_char, u_char, u_char);
int	cd_play(struct cd_softc *, int, int);
int	cd_play_tracks(struct cd_softc *, int, int, int, int);
int	cd_play_msf(struct cd_softc *, int, int, int, int, int, int);
int	cd_pause(struct cd_softc *, int);
int	cd_reset(struct cd_softc *);
int	cd_read_subchannel(struct cd_softc *, int, int, int,
	    struct cd_sub_channel_info *, int );
int	cd_read_toc(struct cd_softc *, int, int, void *,
			 int, int );
int	cd_get_parms(struct cd_softc *, int);
int	cd_load_toc(struct cd_softc *, struct cd_toc *);

int    dvd_auth(struct cd_softc *, union dvd_authinfo *);
int    dvd_read_physical(struct cd_softc *, union dvd_struct *);
int    dvd_read_copyright(struct cd_softc *, union dvd_struct *);
int    dvd_read_disckey(struct cd_softc *, union dvd_struct *);
int    dvd_read_bca(struct cd_softc *, union dvd_struct *);
int    dvd_read_manufact(struct cd_softc *, union dvd_struct *);
int    dvd_read_struct(struct cd_softc *, union dvd_struct *);
d1013 1
a1013 1
		int sessno = *(int *)addr;
d1046 1
a1046 1
		*(int *)addr = (toc->header.len >= 10 && cte->track > 1) ?
@


1.51.2.6
log
@Sync the SMP branch with 3.3
@
text
@d356 4
a359 7
		/*
		 * Check that it is still responding and ok.
		 * Drive can be in progress of loading media so use
		 * increased retries number and don't ignore NOT_READY.
		 */
		error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_CD,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
d507 1
a507 1
	int s;
d548 1
a548 1
	s = splbio();
d562 1
a562 1
	splx(s);
a571 1
	s = splbio();
a572 1
	splx(s);
a606 2
	splassert(IPL_BIO);

d1238 1
a1238 1
	 * Read the TOC and loop through the individual tracks and lay them
d1305 1
a1305 1
	lp->d_npartitions = max((RAW_PART + 1), i);
a1401 1
	u_char endf, ends, endm;
a1419 16
	/*
	 * The track ends one frame before the next begins.  The last track
	 * is taken care of by the leadoff track.
	 */
	endm = toc.entries[etrack].addr.msf.minute;
	ends = toc.entries[etrack].addr.msf.second;
	endf = toc.entries[etrack].addr.msf.frame;
	if (endf-- == 0) {
		endf = CD_FRAMES - 1;
		if (ends-- == 0) {
			ends = CD_SECS - 1;
			if (endm-- == 0)
				return (EINVAL);
		}
	}

d1423 3
a1425 1
	    endm, ends, endf));
@


1.51.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.51.2.6 2003/03/28 00:08:47 niklas Exp $	*/
d1217 1
a1217 1
		strncpy(lp->d_typename, "ATAPI CD-ROM", sizeof(lp->d_typename));
d1220 1
a1220 1
		strncpy(lp->d_typename, "SCSI CD-ROM", sizeof(lp->d_typename));
d1224 1
a1224 1
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
@


1.51.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.51.2.7 2003/05/13 19:36:57 ho Exp $	*/
d165 1
a165 1
const struct scsi_inquiry_pattern cd_patterns[] = {
d194 1
a194 1
	    cd_patterns, sizeof(cd_patterns)/sizeof(cd_patterns[0]),
a669 1
		    !(sc_link->quirks & SDEV_ONLYBIG) && 
d1341 1
a1341 1
	   READ_CD_CAPACITY */
@


1.51.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d350 2
a351 3
		if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0) {
			if (part == RAW_PART && fmt == S_IFCHR)
				goto out;
d364 3
a366 1
			if (part == RAW_PART && fmt == S_IFCHR)
a367 2
			else
				goto bad3;
d376 3
a378 1
			if (part == RAW_PART && fmt == S_IFCHR)
a379 2
			else
				goto bad3;
d776 2
a777 2
 * conversion between minute-seconde-frame and logical block address
 * addresses format
@


1.51.2.10
log
@Merge with the trunk
@
text
@d212 1
a212 1
	SC_DEBUG(sc_link, SDEV_DB2, ("cdattach:\n"));
d399 1
a399 1
			SC_DEBUG(sc_link, SDEV_DB3, ("Params loaded\n"));
d404 1
a404 1
			SC_DEBUG(sc_link, SDEV_DB3, ("Disklabel fabricated\n"));
d518 3
a520 2
	SC_DEBUG(cd->sc_link, SDEV_DB2, ("cdstrategy: %ld bytes @@ blk %d\n",
	    bp->b_bcount, bp->b_blkno));
d615 1
a615 1
	SC_DEBUG(sc_link, SDEV_DB2, ("cdstart\n"));
d708 1
a708 1
			disk_unbusy(&cd->sc_dk, 0, 0);
d721 1
a721 2
		disk_unbusy(&cd->sc_dk, xs->bp->b_bcount - xs->bp->b_resid,
		    (xs->bp->b_flags & B_READ));
d824 1
a824 1
	SC_DEBUG(cd->sc_link, SDEV_DB2, ("cdioctl 0x%lx\n", cmd));
@


1.50
log
@

SCSI commands do not send data in both directions in the data phase.

Fixes DMA bug Angelos was seeing with DVD stuff.

Happy ripping!
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.49 1999/11/09 23:14:19 angelos Exp $	*/
a68 1
#include <sys/dvdio.h>
d135 7
a141 7
int    dvd_auth __P((struct cd_softc *, dvd_authinfo *));
int    dvd_read_physical __P((struct cd_softc *, dvd_struct *));
int    dvd_read_copyright __P((struct cd_softc *, dvd_struct *));
int    dvd_read_disckey __P((struct cd_softc *, dvd_struct *));
int    dvd_read_bca __P((struct cd_softc *, dvd_struct *));
int    dvd_read_manufact __P((struct cd_softc *, dvd_struct *));
int    dvd_read_struct __P((struct cd_softc *, dvd_struct *));
d1141 1
a1141 1
		return (dvd_auth(cd, (dvd_authinfo *)addr));
d1144 1
a1144 1
		return (dvd_read_struct(cd, (dvd_struct *)addr));
d1574 2
a1575 2
#define	dvd_copy_key(dst, src)		bcopy((src), (dst), sizeof(dvd_key))
#define	dvd_copy_challenge(dst, src)	bcopy((src), (dst), sizeof(dvd_challenge))
d1580 1
a1580 1
	dvd_authinfo *a;
d1696 1
a1696 1
	dvd_struct *s;
d1738 1
a1738 1
	dvd_struct *s;
d1763 1
a1763 1
	dvd_struct *s;
d1787 1
a1787 1
	dvd_struct *s;
d1813 1
a1813 1
	dvd_struct *s;
d1839 1
a1839 1
	dvd_struct *s;
@


1.49
log
@Fix lengths of scsi cmds
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.48 1999/11/03 21:20:22 angelos Exp $	*/
d1658 1
a1658 1
				      SCSI_DATA_OUT|SCSI_DATA_IN);
d1672 1
a1672 1
				      SCSI_DATA_OUT|SCSI_DATA_IN);
@


1.48
log
@bzero the right amount of memory; I think NetBSD has this problem too.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.47 1999/11/03 20:11:58 angelos Exp $	*/
d1595 1
a1595 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, 8,
d1606 1
a1606 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, 16,
d1617 1
a1617 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, 12,
d1629 1
a1629 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, 12,
d1643 1
a1643 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, 8,
d1656 1
a1656 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, 16,
d1670 1
a1670 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, 12,
d1683 1
a1683 1
		error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, 16,
d1712 1
a1712 1
	error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, sizeof(buf),
d1752 1
a1752 1
	error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, sizeof(buf),
d1777 1
a1777 1
	error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, sizeof(buf),
d1800 1
a1800 1
	error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, sizeof(buf),
d1826 1
a1826 1
	error = scsi_scsi_cmd(cd->sc_link, &cmd, 16, buf, sizeof(buf),
@


1.47
log
@Some DVD support, from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.46 1999/10/16 19:30:18 deraadt Exp $	*/
d1587 1
a1587 1
	bzero(cmd.bytes, 15);
d1705 1
a1705 1
	bzero(cmd.bytes, 15);
d1745 1
a1745 1
	bzero(cmd.bytes, 15);
d1770 1
a1770 1
	bzero(cmd.bytes, 15);
d1794 1
a1794 1
	bzero(cmd.bytes, 15);
d1820 1
a1820 1
	bzero(cmd.bytes, 15);
@


1.46
log
@another fix form csapuntz
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.45 1999/10/14 05:23:02 deraadt Exp $	*/
d69 1
d136 8
d808 2
d1141 6
d1573 284
@


1.45
log
@read disklabels only from CDs that have a data track, spoofed labels from
the audio CDs could do with a bit more work, but this makes audio cd
playing not generate disklabel read-failure messages on first open; csapuntz
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.44 1999/09/25 03:28:48 deraadt Exp $	*/
d1230 1
a1240 1
		is_data = ent[TOC_ENTRY_CONTROL_ADDR_TYPE] & 4;
@


1.44
log
@sorry, but the last two changes completely broke disklabel spoofing, which we need for the release
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.43 1999/09/21 04:37:59 csapuntz Exp $	*/
d92 11
d1157 3
d1192 5
d1198 1
a1198 2
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
a1201 4
	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

d1203 4
a1206 1
	 * Call the generic disklabel extraction routine
d1208 1
a1208 4
	errstring = readdisklabel(CDLABELDEV(dev), cdstrategy, lp, clp,
	    spoofonly);
	if (errstring) {
		/*printf("%s: %s\n", cd->sc_dev.dv_xname, errstring);*/
d1210 72
@


1.43
log
@

Bug in the disklabel calculations fixed. Offsets were calculated in
terms of 512-unit sectors, yet the disklabel said that the sector size
was 2048.

Enabled code that tries to read disklabel from first data track. I guess
this will be useful for those combination music/BSD install cds.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.42 1999/09/21 04:14:30 csapuntz Exp $	*/
a99 10
#define TOC_HEADER_LEN			0
#define TOC_HEADER_STARTING_TRACK	2
#define TOC_HEADER_ENDING_TRACK		3
#define TOC_HEADER_SZ			4

#define TOC_ENTRY_CONTROL_ADDR_TYPE	1
#define TOC_ENTRY_TRACK			2
#define TOC_ENTRY_MSF_LBA		4
#define TOC_ENTRY_SZ			8

a1145 3
	u_int8_t hdr[TOC_HEADER_SZ], *toc, *ent;
	u_int32_t lba, nlba;
	int i, n, len, is_data, data_track = -1;
d1174 10
d1189 1
a1189 4
	 * Read the TOC and loop throught the individual tracks and lay them
	 * out in our disklabel.  If there is a data track, call the generic
	 * disklabel read routine.  XXX should we move all data tracks up front
	 * before any other tracks?
d1191 4
a1194 1
	if (cd_read_toc(cd, 0, 0, hdr, TOC_HEADER_SZ, 0))
a1195 60
	n = min(hdr[TOC_HEADER_ENDING_TRACK] - hdr[TOC_HEADER_STARTING_TRACK] +
	   1, MAXPARTITIONS);
	len = TOC_HEADER_SZ + (n + 1) * TOC_ENTRY_SZ;
	MALLOC(toc, u_int8_t *, len, M_TEMP, M_WAITOK);
	if (cd_read_toc (cd, CD_LBA_FORMAT, 0, toc, len, 0))
		goto done;

	/* The raw partition is special.  */
	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;

	/* Create the partition table.  */
	/* XXX - some drives return BCD numbers */
	lp->d_npartitions = max(RAW_PART, n) + 1;
	ent = toc + TOC_HEADER_SZ;
	lba = ((cd->sc_link->quirks & ADEV_LITTLETOC) ?
	    ent[TOC_ENTRY_MSF_LBA] | ent[TOC_ENTRY_MSF_LBA + 1] << 8 |
	    ent[TOC_ENTRY_MSF_LBA + 2] << 16 |
	    ent[TOC_ENTRY_MSF_LBA + 3] << 24 :
	    ent[TOC_ENTRY_MSF_LBA] << 24 | ent[TOC_ENTRY_MSF_LBA + 1] << 16 |
	    ent[TOC_ENTRY_MSF_LBA + 2] << 8 | ent[TOC_ENTRY_MSF_LBA + 3]);

	for (i = 0; i < (n > RAW_PART + 1 ? n + 1 : n); i++) {
		/* The raw partition was specially handled above.  */
		if (i != RAW_PART) {
			is_data = toc[TOC_HEADER_SZ +
			    TOC_ENTRY_CONTROL_ADDR_TYPE] & 4;
			lp->d_partitions[i].p_fstype =
			    is_data ? FS_UNUSED : FS_OTHER;
			if (is_data && data_track == -1)
				data_track = i;
			ent += TOC_ENTRY_SZ;
			nlba = ((cd->sc_link->quirks & ADEV_LITTLETOC) ?
			    ent[TOC_ENTRY_MSF_LBA] |
			    ent[TOC_ENTRY_MSF_LBA + 1] << 8 |
			    ent[TOC_ENTRY_MSF_LBA + 2] << 16 |
			    ent[TOC_ENTRY_MSF_LBA + 3] << 24 :
			    ent[TOC_ENTRY_MSF_LBA] << 24 |
			    ent[TOC_ENTRY_MSF_LBA + 1] << 16 |
			    ent[TOC_ENTRY_MSF_LBA + 2] << 8 |
			    ent[TOC_ENTRY_MSF_LBA + 3]);
			lp->d_partitions[i].p_offset = lba;
			lp->d_partitions[i].p_size = nlba - lba;
			lba = nlba;
		}
	}

	/* We have a data track, look in there for a real disklabel.  */
	if (data_track != -1) {
#if 1
		/* This might not necessarily work */
		errstring = readdisklabel(MAKECDDEV(major(dev), CDUNIT(dev), 
		    data_track), cdstrategy, lp, clp, spoofonly);
#else
		errstring = readdisklabel(CDLABELDEV(dev),
		    cdstrategy, lp, clp, spoofonly);
#endif
		/*if (errstring)
			printf("%s: %s\n", cd->sc_dev.dv_xname, errstring);*/
a1196 3

done:
	FREE(toc, M_TEMP);
@


1.42
log
@

For some reason unbeknownst to me, the old acd driver had a more advanced
disklabel logic than the cd driver. This patch integrates that logic into
the SCSI cd driver.

Bug fixed - we no longer try to read disklabels off of audio CDs. No more
SCSI errors when you hit play the first time on an audio CD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.41 1999/08/24 01:20:22 csapuntz Exp $	*/
a1155 1

d1208 1
a1208 2
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * lp->d_secsize / DEV_BSIZE;
d1220 1
a1220 2
	    ent[TOC_ENTRY_MSF_LBA + 2] << 8 | ent[TOC_ENTRY_MSF_LBA + 3]) *
	    lp->d_secsize / DEV_BSIZE;
d1240 1
a1240 2
			    ent[TOC_ENTRY_MSF_LBA + 3]) * lp->d_secsize /
			    DEV_BSIZE;
d1249 4
a1252 7
#ifdef notyet
		/*
		 * Reading a disklabel inside the track we setup above
		 * does not yet work, for unknown reasons.
		 */
		errstring = readdisklabel(MAKECDDEV(0, cd->sc_dev.dv_unit,
		    data_track), cdstrategy, lp, cd->sc_dk.dk_cpulabel, 0);
d1255 1
a1255 1
		    cdstrategy, lp, cd->sc_dk.dk_cpulabel, 0);
@


1.41
log
@

Added type field to scsi_addr to reflect bus/device type (ATAPI or SCSI).
Updated ioctls to match

Minor patches in anticipation of wd->sd translation layer
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.40 1999/08/10 23:09:49 deraadt Exp $	*/
d100 10
d1157 4
d1174 8
a1181 2
	strncpy(lp->d_typename, "SCSI CD-ROM", sizeof(lp->d_typename) - 1);
	lp->d_type = DTYPE_SCSI;
a1187 10
	/* XXX - these values for BBSIZE and SBSIZE assume ffs */
	lp->d_bbsize = BBSIZE;
	lp->d_sbsize = SBSIZE;

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;

d1193 4
a1196 1
	 * Call the generic disklabel extraction routine
d1198 1
a1198 4
	errstring = readdisklabel(CDLABELDEV(dev), cdstrategy, lp, clp,
	    spoofonly);
	if (errstring) {
		/*printf("%s: %s\n", cd->sc_dev.dv_xname, errstring);*/
d1200 66
d1267 3
@


1.40
log
@support DIOCRLDINFO
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.39 1999/07/21 05:58:25 csapuntz Exp $	*/
d769 1
@


1.39
log
@

swap16_multi by niklas@@cvs.openbsd.org

Fix cd.c so it compiles on big-endian platforms
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.38 1999/07/20 09:41:41 csapuntz Exp $	*/
d799 4
@


1.38
log
@

Be more generous with timeout on cd_play_msf
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.37 1999/07/20 06:21:59 csapuntz Exp $	*/
d878 1
a878 3
#if BYTE_ORDER == BIG_ENDIAN
			bswap((u_int8_t *)&th.len, sizeof(th.len));
#endif
d918 2
a919 2
					bswap((u_int8_t*)&cte->addr,
					    sizeof(cte->addr));
d925 1
a925 3
#if BYTE_ORDER == BIG_ENDIAN
			bswap((u_int8_t*)&th->len, sizeof(th->len));
#endif
d959 2
a960 1
			bswap((u_int8_t*)&cte->addr, sizeof(cte->addr));
d965 1
a965 3
#if BYTE_ORDER == BIG_ENDIAN
			bswap((u_int8_t*)&toc->header.len, sizeof(toc->header.len));
#endif
@


1.37
log
@

Make acd redundant.

Mostly based on NetBSD-current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.36 1999/04/01 01:46:51 millert Exp $	*/
d1322 1
a1322 1
	    0, 0, CDRETRIES, 2000, NULL, 0));
@


1.36
log
@If READ_CD_CAPACITY fails, just use the 2048/400000 defaults since some CDR drives don't support READ_CD_CAPACITY on blank media ; downsj with modifications by me
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.35 1998/10/05 00:39:27 millert Exp $	*/
d68 1
d71 1
d76 1
d79 2
a81 1
#define	CDRETRIES	1
d87 11
a99 24
struct cd_softc {
	struct device sc_dev;
	struct disk sc_dk;

	int flags;
#define	CDF_LOCKED	0x01
#define	CDF_WANTED	0x02
#define	CDF_WLABEL	0x04		/* label is writable */
#define	CDF_LABELLING	0x08		/* writing label */
#define	CDF_ANCIENT	0x10		/* disk is ancient; for minphys */
#ifdef CDDA
#define CDF_CDDAMODE	0x08
#endif
	struct scsi_link *sc_link;	/* contains our targ, lun, etc. */
	struct cd_parms {
		int blksize;
		u_long disksize;	/* total number sectors */
	} params;
#ifdef CDDA
	struct cd_parms orig_params;    /* filled in when CD-DA mode starts */
#endif
	struct buf buf_queue;
};

d109 6
a114 5
int	cd_get_mode __P((struct cd_softc *, struct cd_mode_data *, int));
int	cd_set_mode __P((struct cd_softc *, struct cd_mode_data *));
int	cd_play_big __P((struct cd_softc *, int, int ));
int	cd_play_tracks __P((struct cd_softc *, int, int, int, int ));
int	cd_play_msf __P((struct cd_softc *, int, int, int, int, int, int ));
d119 2
a120 2
int	cd_read_toc __P((struct cd_softc *, int, int, struct cd_toc_entry *,
			 int ));
d122 1
d144 4
d154 3
d207 2
a208 1
	if ((sa->sa_inqbuf->version & SID_ANSII) == 0)
d211 6
d613 2
a614 1
		if (((blkno & 0x1fffff) == blkno) &&
d715 28
d755 1
d763 34
a796 2
	if ((cd->sc_link->flags & SDEV_MEDIA_LOADED) == 0)
		return EIO;
d834 5
a838 10
		struct cd_mode_data data;
		if ((error = cd_get_mode(cd, &data, AUDIO_PAGE)) != 0)
			return error;
		data.page.audio.flags &= ~CD_PA_SOTC;
		data.page.audio.flags |= CD_PA_IMMED;
		if ((error = cd_set_mode(cd, &data)) != 0)
			return error;
		return cd_play_tracks(cd, args->start_track,
				      args->start_index, args->end_track,
				      args->end_index);
d842 5
a846 10
		struct cd_mode_data data;
		if ((error = cd_get_mode(cd, &data, AUDIO_PAGE)) != 0)
			return error;
		data.page.audio.flags &= ~CD_PA_SOTC;
		data.page.audio.flags |= CD_PA_IMMED;
		if ((error = cd_set_mode(cd, &data)) != 0)
			return error;
		return cd_play_msf(cd, args->start_m, args->start_s,
				   args->start_f, args->end_m, args->end_s,
				   args->end_f);
d850 4
a853 8
		struct cd_mode_data data;
		if ((error = cd_get_mode(cd, &data, AUDIO_PAGE)) != 0)
			return error;
		data.page.audio.flags &= ~CD_PA_SOTC;
		data.page.audio.flags |= CD_PA_IMMED;
		if ((error = cd_set_mode(cd, &data)) != 0)
			return error;
		return cd_play_big(cd, args->blk, args->len);
d874 9
a882 5
		if ((error = cd_read_toc(cd, 0, 0, 
					 (struct cd_toc_entry *) &th,
					 sizeof(th))) != 0)
			return error;
		th.len = ntohs(th.len);
d884 1
a884 1
		return 0;
d886 2
a887 5
	case CDIOREADTOCENTRYS: {
		struct cd_toc {
			struct ioc_toc_header header;
			struct cd_toc_entry entries[100];
		} * data;
d889 1
a889 1
		(struct ioc_read_toc_entry *)addr;
d891 1
d893 1
d896 1
a896 5
		if (len > sizeof(data->entries) ||
		    len < sizeof(struct cd_toc_entry))
			return EINVAL;

		MALLOC (data, struct cd_toc *, sizeof (struct cd_toc),
d899 1
a899 1
		th = &data->header;
d901 7
a907 4
		error = cd_read_toc(cd, te->address_format,
				    te->starting_track,
				    (struct cd_toc_entry *)data,
				    len + sizeof(struct ioc_toc_header));
d909 2
a910 2
			FREE(data, M_DEVBUF);
			return error;
d912 26
a937 4
		len = min(len, ntohs(th->len) - (sizeof(th->starting_track) +
			       sizeof(th->ending_track)));
		res = copyout(data->entries, te->data, len);
		FREE(data, M_DEVBUF);
d940 39
d981 3
a983 8
		struct cd_mode_data data;
		if ((error = cd_get_mode(cd, &data, AUDIO_PAGE)) != 0)
			return error;
		data.page.audio.port[LEFT_PORT].channels = arg->patch[0];
		data.page.audio.port[RIGHT_PORT].channels = arg->patch[1];
		data.page.audio.port[2].channels = arg->patch[2];
		data.page.audio.port[3].channels = arg->patch[3];
		return cd_set_mode(cd, &data);
d987 2
a988 8
		struct cd_mode_data data;
		if ((error = cd_get_mode(cd, &data, AUDIO_PAGE)) != 0)
			return error;
		arg->vol[LEFT_PORT] = data.page.audio.port[LEFT_PORT].volume;
		arg->vol[RIGHT_PORT] = data.page.audio.port[RIGHT_PORT].volume;
		arg->vol[2] = data.page.audio.port[2].volume;
		arg->vol[3] = data.page.audio.port[3].volume;
		return 0;
d992 2
a993 62
		struct cd_mode_data data;
		if ((error = cd_get_mode(cd, &data, AUDIO_PAGE)) != 0)
			return error;
		data.page.audio.port[LEFT_PORT].channels = CHANNEL_0;
		data.page.audio.port[LEFT_PORT].volume = arg->vol[LEFT_PORT];
		data.page.audio.port[RIGHT_PORT].channels = CHANNEL_1;
		data.page.audio.port[RIGHT_PORT].volume = arg->vol[RIGHT_PORT];
		data.page.audio.port[2].volume = arg->vol[2];
		data.page.audio.port[3].volume = arg->vol[3];
		return cd_set_mode(cd, &data);
	}
	case CDIOCSETMONO: {
		struct cd_mode_data data;
		if ((error = cd_get_mode(cd, &data, AUDIO_PAGE)) != 0)
			return error;
		data.page.audio.port[LEFT_PORT].channels =
		    LEFT_CHANNEL | RIGHT_CHANNEL | 4 | 8;
		data.page.audio.port[RIGHT_PORT].channels =
		    LEFT_CHANNEL | RIGHT_CHANNEL;
		data.page.audio.port[2].channels = 0;
		data.page.audio.port[3].channels = 0;
		return cd_set_mode(cd, &data);
	}
	case CDIOCSETSTEREO: {
		struct cd_mode_data data;
		if ((error = cd_get_mode(cd, &data, AUDIO_PAGE)) != 0)
			return error;
		data.page.audio.port[LEFT_PORT].channels = LEFT_CHANNEL;
		data.page.audio.port[RIGHT_PORT].channels = RIGHT_CHANNEL;
		data.page.audio.port[2].channels = 0;
		data.page.audio.port[3].channels = 0;
		return cd_set_mode(cd, &data);
	}
	case CDIOCSETMUTE: {
		struct cd_mode_data data;
		if ((error = cd_get_mode(cd, &data, AUDIO_PAGE)) != 0)
			return error;
		data.page.audio.port[LEFT_PORT].channels = 0;
		data.page.audio.port[RIGHT_PORT].channels = 0;
		data.page.audio.port[2].channels = 0;
		data.page.audio.port[3].channels = 0;
		return cd_set_mode(cd, &data);
	}
	case CDIOCSETLEFT: {
		struct cd_mode_data data;
		if ((error = cd_get_mode(cd, &data, AUDIO_PAGE)) != 0)
			return error;
		data.page.audio.port[LEFT_PORT].channels = LEFT_CHANNEL;
		data.page.audio.port[RIGHT_PORT].channels = LEFT_CHANNEL;
		data.page.audio.port[2].channels = 0;
		data.page.audio.port[3].channels = 0;
		return cd_set_mode(cd, &data);
	}
	case CDIOCSETRIGHT: {
		struct cd_mode_data data;
		if ((error = cd_get_mode(cd, &data, AUDIO_PAGE)) != 0)
			return error;
		data.page.audio.port[LEFT_PORT].channels = RIGHT_CHANNEL;
		data.page.audio.port[RIGHT_PORT].channels = RIGHT_CHANNEL;
		data.page.audio.port[2].channels = 0;
		data.page.audio.port[3].channels = 0;
		return cd_set_mode(cd, &data);
d995 20
d1023 4
a1047 2
	case CDIOCRESET:
		return cd_reset(cd);
d1052 1
a1052 1
		struct cd_mode_data data;
d1109 10
d1194 1
a1194 1
 * Get the requested page into the buffer given
d1196 2
a1197 2
int
cd_get_mode(cd, data, page)
d1199 1
a1199 2
	struct cd_mode_data *data;
	int page;
d1201 14
a1214 1
	struct scsi_mode_sense scsi_cmd;
d1216 4
d1221 16
a1236 8
	bzero(data, sizeof(*data));
	scsi_cmd.opcode = MODE_SENSE;
	scsi_cmd.page = page;
	scsi_cmd.length = sizeof(*data) & 0xff;
	return scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)data, sizeof(*data), CDRETRIES, 20000,
	    NULL, SCSI_DATA_IN);
}
d1238 4
a1241 9
/*
 * Get the requested page into the buffer given
 */
int
cd_set_mode(cd, data)
	struct cd_softc *cd;
	struct cd_mode_data *data;
{
	struct scsi_mode_select scsi_cmd;
d1243 2
a1244 8
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MODE_SELECT;
	scsi_cmd.byte2 |= SMS_PF;
	scsi_cmd.length = sizeof(*data) & 0xff;
	data->header.data_length = 0;
	return scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)data, sizeof(*data), CDRETRIES, 20000,
	    NULL, SCSI_DATA_OUT);
d1247 1
d1252 1
a1252 1
cd_play_big(cd, blkno, nblks)
d1256 1
a1256 1
	struct scsi_play_big scsi_cmd;
d1259 1
a1259 1
	scsi_cmd.opcode = PLAY_BIG;
d1261 4
a1264 3
	_lto4b(nblks, scsi_cmd.xfer_len);
	return scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, CDRETRIES, 20000, NULL, 0);
d1275 2
a1276 1
	struct scsi_play_track scsi_cmd;
d1278 22
a1299 8
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = PLAY_TRACK;
	scsi_cmd.start_track = strack;
	scsi_cmd.start_index = sindex;
	scsi_cmd.end_track = etrack;
	scsi_cmd.end_index = eindex;
	return scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, CDRETRIES, 20000, NULL, 0);
d1320 3
a1322 2
	return scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, CDRETRIES, 2000, NULL, 0);
d1382 1
a1382 1
cd_read_toc(cd, mode, start, data, len)
d1384 2
a1385 2
	int mode, start, len;
	struct cd_toc_entry *data;
d1391 5
a1395 3
	/*if (len!=sizeof(struct ioc_toc_header))
	 * ntoc=((len)-sizeof(struct ioc_toc_header))/sizeof(struct cd_toc_entry);
	 * else */
d1402 1
d1408 19
a1435 12
	struct scsi_read_cd_cap_data rdcap;
	struct scsi_read_cd_capacity scsi_cmd;
	int blksize;
	u_long size;

	/*
	 * make up a scsi command and ask the scsi driver to do
	 * it for you.
	 */
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = READ_CD_CAPACITY;

d1437 2
a1438 2
	 * If the command works, interpret the result as a 4 byte
	 * number of blocks and a blocksize
d1440 3
a1442 27
	if (scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)&rdcap, sizeof(rdcap), CDRETRIES,
	    20000, NULL, flags | SCSI_DATA_IN) != 0) {
		/*
		 * Some CD-R devices and such will fail READ_CD_CAPACITY
		 * when blank media is loaded.  We still want to be able
		 * to open them, however.
		 *
		 * scsi_scsi_cmd() will log failure of the command; just use
		 * the defaults.
		 */
		cd->params.blksize = 2048;
		cd->params.disksize = 400000;
		return 0;
	}

	blksize = _4btol(rdcap.length);
	if (blksize < 512 || blksize > 2048)
		blksize = 2048;	/* some drives lie ! */
	cd->params.blksize = blksize;

	size = _4btol(rdcap.addr) + 1;
	if (size < 100)
		size = 400000;	/* ditto */
	cd->params.disksize = size;

	return 0;
@


1.35
log
@make DIOCGPDINFO equivalent to DIOCGDINFO for cd's
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.34 1998/10/04 01:37:55 millert Exp $	*/
a117 1
u_long	cd_size __P((struct cd_softc *, int));
a1114 42
 * Find out from the device what it's capacity is
 */
u_long
cd_size(cd, flags)
	struct cd_softc *cd;
	int flags;
{
	struct scsi_read_cd_cap_data rdcap;
	struct scsi_read_cd_capacity scsi_cmd;
	int blksize;
	u_long size;

	/*
	 * make up a scsi command and ask the scsi driver to do
	 * it for you.
	 */
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = READ_CD_CAPACITY;

	/*
	 * If the command works, interpret the result as a 4 byte
	 * number of blocks and a blocksize
	 */
	if (scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), (u_char *)&rdcap, sizeof(rdcap), CDRETRIES,
	    20000, NULL, flags | SCSI_DATA_IN) != 0)
		return 0;

	blksize = _4btol(rdcap.length);
	if (blksize < 512 || blksize > 2048)
		blksize = 2048;	/* some drives lie ! */
	cd->params.blksize = blksize;

	size = _4btol(rdcap.addr) + 1;
	if (size < 100)
		size = 400000;	/* ditto */
	cd->params.disksize = size;

	return size;
}

/*
d1304 4
d1310 2
a1311 2
	 * give a number of sectors so that sec * trks * cyls
	 * is <= disk_size
d1313 32
a1344 2
	if (cd_size(cd, flags) == 0)
		return ENXIO;
@


1.34
log
@Add DIOCGPDINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.33 1998/10/03 21:19:01 millert Exp $	*/
a730 8
	case DIOCGPDINFO: {
			struct cpu_disklabel osdep;

			cdgetdisklabel(dev, cd, (struct disklabel *)addr,
			    &osdep, 1);
			return 0;
		}

d732 1
@


1.33
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.32 1998/07/13 00:21:16 csapuntz Exp $	*/
d115 2
a116 1
void	cdgetdisklabel __P((dev_t, struct cd_softc *));
d347 2
a348 1
			cdgetdisklabel(dev, cd);
d731 8
d1067 1
a1067 1
cdgetdisklabel(dev, cd)
d1070 3
a1073 1
	struct disklabel *lp = cd->sc_dk.dk_label;
d1077 1
a1077 1
	bzero(cd->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));
d1086 1
a1086 1
		/* as long as it's not 0 - readdisklabel divides by it (?) */
d1114 2
a1115 2
	errstring = readdisklabel(CDLABELDEV(dev), cdstrategy, lp,
	    cd->sc_dk.dk_cpulabel, 0);
@


1.32
log
@

CDs can have up to 99 tracks, not 65 tracks. Use kernel heap instead of stack
for temporary storage of CD table of contents
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.31 1998/07/12 01:20:18 deraadt Exp $	*/
d1103 1
a1103 1
	    cd->sc_dk.dk_cpulabel);
@


1.31
log
@fill in d_bbsize and d_sbsize
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.30 1998/03/27 18:40:54 millert Exp $	*/
d828 2
a829 2
			struct cd_toc_entry entries[65];
		} data;
d834 1
a834 1
		th = &data.header;
d836 1
a836 1
		if (len > sizeof(data.entries) ||
d839 6
d847 1
a847 1
				    (struct cd_toc_entry *)&data,
d849 2
a850 1
		if (error)
d852 1
d855 3
a857 1
		return copyout(data.entries, te->data, len);
@


1.30
log
@Fix strncpy usage and call a cdrom a cdrom in the fake label
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.29 1997/12/05 00:09:50 provos Exp $	*/
d74 2
d1074 4
@


1.29
log
@argh. this darn little bugger made CDIOCREADSUBCHANNEL unuseable, this
should also fix some cdio problems with SCSI cdroms.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.28 1997/10/18 10:37:16 deraadt Exp $	*/
d1065 1
a1065 1
	strncpy(lp->d_typename, "SCSI disk", 16);
d1067 1
a1067 1
	strncpy(lp->d_packname, "fictitious", 16);
@


1.28
log
@avoid "no disklabel" error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.27 1997/10/15 09:35:00 provos Exp $	*/
d1287 1
a1287 1
	    CDRETRIES, 5000, NULL, SCSI_DATA_IN||SCSI_SILENT);
@


1.27
log
@make it compile
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.26 1997/09/11 11:20:43 deraadt Exp $	*/
d1089 1
a1089 1
		printf("%s: %s\n", cd->sc_dev.dv_xname, errstring);
@


1.26
log
@cd_play/acd_play() were replaced a while back
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.25 1997/08/31 07:41:51 downsj Exp $	*/
d973 1
a973 1
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
@


1.25
log
@* Make scsi_do_ioctl() sane again.
* Use scsi_do_ioctl() in cd.c and uk.c again.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.24 1997/08/08 21:47:05 niklas Exp $	*/
a117 1
int	cd_play __P((struct cd_softc *, int, int ));
a1174 18
}

/*
 * Get scsi driver to send a "start playing" command
 */
int
cd_play(cd, blkno, nblks)
	struct cd_softc *cd;
	int blkno, nblks;
{
	struct scsi_play scsi_cmd;

	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = PLAY;
	_lto4b(blkno, scsi_cmd.blk_addr);
	_lto2b(nblks, scsi_cmd.xfer_len);
	return scsi_scsi_cmd(cd->sc_link, (struct scsi_generic *)&scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, CDRETRIES, 200000, NULL, 0);
@


1.24
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.23 1997/04/14 04:09:03 downsj Exp $	*/
d1030 1
a1030 1
		return scsi_do_safeioctl(cd->sc_link, dev, cmd, addr, flag, p);
@


1.23
log
@Merge in various pieces of current NetBSD scsi code, including but not limited
to:

* New changer driver.
* Better optical support.
* Different `done' semantics.
* New quirks for SCSI QIC tape driver, SCSI floppy drives.
* Better support for SCSI-I devices.

Everybody needs to test this.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.22 1997/03/29 23:54:20 briggs Exp $	*/
d489 1
@


1.22
log
@Increase timeout by a factor of ten in cd_size().
NetBSD PR#3409 from Koji Imada <koji@@imada.math.human.nagoya-u.ac.jp>
@
text
@d1 2
a2 2
/*	$OpenBSD: cd.c,v 1.21 1997/03/26 01:53:48 deraadt Exp $	*/
/*	$NetBSD: cd.c,v 1.92 1996/05/05 19:52:50 christos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
d114 1
a114 1
int	cddone __P((struct scsi_xfer *, int));
d645 2
a646 2
int
cddone(xs, complete)
a647 1
	int complete;
d651 2
a652 4
	if (complete && (xs->bp != NULL))
		disk_unbusy(&cd->sc_dk, (xs->bp->b_bcount - xs->bp->b_resid));

	return (0);
d1305 1
a1305 1
	    CDRETRIES, 5000, NULL, SCSI_DATA_IN);
@


1.21
log
@deal with CD drives that indicate 2352 bytes per block...
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.20 1997/01/04 08:50:20 deraadt Exp $	*/
d1123 1
a1123 1
	    2000, NULL, flags | SCSI_DATA_IN) != 0)
@


1.20
log
@readdisklabel() with correct dev_t
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.19 1996/12/24 01:33:33 deraadt Exp $	*/
a1058 2
	if (lp->d_secsize > 2048)
		lp->d_secsize = 2048;
d1127 1
a1127 1
	if (blksize < 512)
@


1.19
log
@deal with the 2340 lie in the right place, i think
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.17 1996/12/05 13:10:24 deraadt Exp $	*/
d81 2
d113 1
a113 1
void	cdgetdisklabel __P((struct cd_softc *));
d345 1
a345 1
			cdgetdisklabel(cd);
d1048 2
a1049 1
cdgetdisklabel(cd)
d1091 2
a1092 2
	errstring = readdisklabel(MAKECDDEV(0, cd->sc_dev.dv_unit, RAW_PART),
	    cdstrategy, lp, cd->sc_dk.dk_cpulabel);
@


1.18
log
@b_resid cleanups, pointed out by minoura@@kw.netlaputa.or.jp in netbsd pr#3007
@
text
@d1056 2
@


1.17
log
@call readdisklabel() in the same fashion as sd.c does
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.16 1996/10/31 01:09:20 niklas Exp $	*/
d578 1
@


1.16
log
@$OpenBSD RCSIDs + comment fix in sd.c
@
text
@d1 1
a1 1
/*	$OpenBSD: cd.c,v 1.92 1996/05/05 19:52:50 christos Exp $	*/
d1049 1
d1059 4
d1064 1
a1064 1
	strncpy(lp->d_typename, "SCSI CD-ROM", 16);
a1071 4
	lp->d_partitions[0].p_offset = 0;
	lp->d_partitions[0].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
	lp->d_partitions[0].p_fstype = FS_ISO9660;
d1075 1
a1075 1
	lp->d_partitions[RAW_PART].p_fstype = FS_ISO9660;
d1081 10
@


1.15
log
@[a]cd_play -> [a]cd_play_big.  Say hello to cdio(1).
@
text
@d1 1
@


1.14
log
@only safe ioctl
@
text
@d793 1
a793 1
		return cd_play(cd, args->blk, args->len);
@


1.13
log
@disk_unbusy if op failed to enqueue
@
text
@d1028 1
a1028 1
		return scsi_do_ioctl(cd->sc_link, dev, cmd, addr, flag, p);
@


1.12
log
@Several changes:
	* Implemented NetBSD PR#2529, adding ZIP 100.
	* Added MTIOCTOP support to acd, cd, and sd.
	* Implemented eject on close for acd, cd, and sd.

`mt -f /dev/rcd0d offline' now ejects a mounted {acd|cd|sd} when it is
unmounted.
@
text
@d634 2
a635 1
		    ((bp->b_flags & B_READ) ? SCSI_DATA_IN : SCSI_DATA_OUT)))
d637 1
@


1.11
log
@all ports have dk_establish
@
text
@d56 1
d420 6
d939 4
d945 2
a946 1
		return scsi_start(cd->sc_link, SSS_STOP|SSS_LOEJ, 0);
@


1.10
log
@from NetBSD PR#812:
allow CDDA disks to be read.
not tested, anyone w/ SCSI CD is ought to.
here is the test program (not tested too ;):


#define CDDA


#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/scsiio.h>
#include <sys/cdio.h>
#include <scsi/scsi_all.h>
#include <scsi/scsi_cd.h>
#include <scsi/scsi_disk.h>


extern int errno;


void
usage()
{
    fprintf(stderr, "usage: cdda -d device -b blkcnt -o offset >output\n");
    exit(1);
}


char databuf[CD_DA_BLKSIZ];


main(int argc, char *argv[])
{
    int ch;
    int fd;
    off_t offset = 0;
    int cnt = 0;
    char *dev = 0;
    struct scsi_rw_big read_cmd;
    struct scsi_mode_sense sense_cmd;
    struct cd_mode_data bdesc;
    scsireq_t req;


    while ((ch = getopt(argc, argv, "d:b:o:")) != -1) {
        switch (ch) {
        case 'd':
            dev = optarg;
            break;
        case 'b':
            cnt = atoi(optarg);
            if (cnt <= 0)
                usage();
            break;
        case 'o':
            offset = atoi(optarg);
            break;
        case '?':
        default:
            usage();
        }
    }
    if (dev == NULL || cnt == 0)
        usage();
    fd = open(dev, O_RDONLY);
    if (fd == -1)
        err(1,"can't open device %s", dev);
#ifdef DEBUG
    ch = SC_DB_FLOW;
    ioctl(fd, SCIOCDEBUG, &ch);
#endif
    ch = 1;
    if (ioctl(fd, CDIOCSETCDDA, &ch) == -1)
        warn("can't set CDDA mode");


    read_cmd.opcode = READ_BIG;         /* READ10 */
    read_cmd.byte2 = 0;                 /* no relative */
    read_cmd.reserved = 0;
    read_cmd.length2 = 0;
    read_cmd.length1 = 1;               /* read one block at a time.
                                           hope it caches! */
    read_cmd.control = 0;               /* LBA mode, leave flag & link zero */


    for (; cnt > 0; cnt--, offset++) {
        read_cmd.addr_3 = (offset >> 24) & 0xff;
        read_cmd.addr_2 = (offset >> 16) & 0xff;
        read_cmd.addr_1 = (offset >> 8) & 0xff;
        read_cmd.addr_0 = offset & 0xff;
        memset(&req, 0, sizeof(req));
        req.flags = SCCMD_READ;
        /* timeout is in milliseconds--not that it's obvious from the
           include files!  */
        req.timeout = 10000;            /* 10 sec */


        bcopy(&read_cmd, req.cmd, sizeof(read_cmd));
        req.cmdlen = sizeof(read_cmd);
        req.databuf = databuf;
        req.datalen = sizeof(databuf);
        req.senselen = sizeof(req.sense); /* XXX */
        if (ioctl(fd, SCIOCCOMMAND, &req) == -1) {
            fprintf(stderr, "bad ioctl: %d\n", errno);
            ch = 0;
            ioctl(fd, CDIOCSETCDDA, &ch);
#ifdef DEBUG
            ioctl(fd, SCIOCDEBUG, &ch);
#endif
            exit(1);
        }
        if (req.retsts != 0 || req.error != 0) {
            ch = 0;
            ioctl(fd, CDIOCSETCDDA, &ch);
#ifdef DEBUG
            ioctl(fd, SCIOCDEBUG, &ch);
#endif
            errx(1,"return status %d, error %d\n", req.retsts, req.error);
        }
        if (req.datalen_used != sizeof(databuf)) {
            ch = 0;
            ioctl(fd, CDIOCSETCDDA, &ch);
#ifdef DEBUG
            ioctl(fd, SCIOCDEBUG, &ch);
#endif
            errx(1,"didn't get full buffer back (%x)", req.datalen_used);
        }
        write(1, databuf, sizeof(databuf));
    }
    ch = 0;
    if (ioctl(fd, CDIOCSETCDDA, &ch) == -1)
        warn("can't reset CDDA mode");
#ifdef DEBUG
    ioctl(fd, SCIOCDEBUG, &ch);
#endif
    close(fd);
    exit(0);
}
@
text
@d197 1
a197 3
#if !defined(i386)
	dk_establish(&cd->sc_dk, &cd->sc_dev);		/* XXX */
#endif
@


1.9
log
@SC_DEBUG cleanup
@
text
@d89 3
d97 3
d276 12
d297 10
d463 12
d952 60
@


1.8
log
@no sys/cpu.h, fix bugs in ch
@
text
@d1 1
a1 1
/*	$NetBSD: cd.c,v 1.91 1996/04/22 01:46:00 christos Exp $	*/
d265 1
a265 1
	    cd_cd.cd_ndevs, part));
d413 1
a413 1
	    ("%d bytes @@ blk %d\n", bp->b_bcount, bp->b_blkno));
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$NetBSD: cd.c,v 1.90 1996/03/30 21:44:50 christos Exp $	*/
a64 1
#include <sys/cpu.h>
@


1.6
log
@Sync w/ NetBSD:
- Accept DIOCEJECT as a synonym for CDIOCEJECT.  Implement DIOCLOCK
  separately from CDIOCALLOW and CDIOCPREVENT, even though they perform
  basically the same function (with a different interface XXX).
- scsi prototypes
@
text
@d1 1
a1 1
/*	$NetBSD: cd.c,v 1.82 1996/02/14 21:46:52 christos Exp $	*/
d66 1
a71 1
#include <scsi/scsi_conf.h>
d73 1
a73 1
#define	CDOUTSTANDING	2
d89 1
d121 6
a126 2
struct cfdriver cdcd = {
	NULL, "cd", cdmatch, cdattach, DV_DISK, sizeof(struct cd_softc)
d192 1
a192 1
#if !defined(i386) || defined(NEWCONFIG)
d196 6
d256 1
a256 1
	if (unit >= cdcd.cd_ndevs)
d258 1
a258 1
	cd = cdcd.cd_devs[unit];
d266 1
a266 1
	    cdcd.cd_ndevs, part));
d371 1
a371 1
	struct cd_softc *cd = cdcd.cd_devs[CDUNIT(dev)];
d409 1
a409 1
	struct cd_softc *cd = cdcd.cd_devs[CDUNIT(bp->b_dev)];
d563 1
a563 3
			cmd_small.addr_2 = (blkno >> 16) & 0x1f;
			cmd_small.addr_1 = (blkno >> 8) & 0xff;
			cmd_small.addr_0 = blkno & 0xff;
d574 2
a575 6
			cmd_big.addr_3 = (blkno >> 24) & 0xff;
			cmd_big.addr_2 = (blkno >> 16) & 0xff;
			cmd_big.addr_1 = (blkno >> 8) & 0xff;
			cmd_big.addr_0 = blkno & 0xff;
			cmd_big.length2 = (nblks >> 8) & 0xff;
			cmd_big.length1 = nblks & 0xff;
d608 28
a641 1
	struct cd_softc *cd = cdcd.cd_devs[CDUNIT(dev)];
d643 1
a643 2
	return (physio(cdstrategy, NULL, dev, B_READ,
		       cd->sc_link->adapter->scsi_minphys, uio));
a651 1
	struct cd_softc *cd = cdcd.cd_devs[CDUNIT(dev)];
d653 1
a653 2
	return (physio(cdstrategy, NULL, dev, B_WRITE,
		       cd->sc_link->adapter->scsi_minphys, uio));
d668 1
a668 1
	struct cd_softc *cd = cdcd.cd_devs[CDUNIT(dev)];
d762 2
a763 3
		len = min(len, ((data.header.data_len[0] << 8) +
		    data.header.data_len[1] +
		    sizeof(struct cd_sub_channel_header)));
d999 1
a999 2
	blksize = (rdcap.length_3 << 24) + (rdcap.length_2 << 16) +
	    (rdcap.length_1 << 8) + rdcap.length_0;
d1004 1
a1004 2
	size = (rdcap.addr_3 << 24) + (rdcap.addr_2 << 16) +
	    (rdcap.addr_1 << 8) + rdcap.addr_0 + 1;
d1065 2
a1066 6
	scsi_cmd.blk_addr[0] = (blkno >> 24) & 0xff;
	scsi_cmd.blk_addr[1] = (blkno >> 16) & 0xff;
	scsi_cmd.blk_addr[2] = (blkno >> 8) & 0xff;
	scsi_cmd.blk_addr[3] = blkno & 0xff;
	scsi_cmd.xfer_len[0] = (nblks >> 8) & 0xff;
	scsi_cmd.xfer_len[1] = nblks & 0xff;
d1083 2
a1084 8
	scsi_cmd.blk_addr[0] = (blkno >> 24) & 0xff;
	scsi_cmd.blk_addr[1] = (blkno >> 16) & 0xff;
	scsi_cmd.blk_addr[2] = (blkno >> 8) & 0xff;
	scsi_cmd.blk_addr[3] = blkno & 0xff;
	scsi_cmd.xfer_len[0] = (nblks >> 24) & 0xff;
	scsi_cmd.xfer_len[1] = (nblks >> 16) & 0xff;
	scsi_cmd.xfer_len[2] = (nblks >> 8) & 0xff;
	scsi_cmd.xfer_len[3] = nblks & 0xff;
d1178 1
a1178 2
	scsi_cmd.data_len[0] = (len >> 8) & 0xff;
	scsi_cmd.data_len[1] = len & 0xff;
d1205 1
a1205 2
	scsi_cmd.data_len[0] = (ntoc >> 8) & 0xff;
	scsi_cmd.data_len[1] = ntoc & 0xff;
@


1.5
log
@From NetBSD: (required for last change to scsi_base.c in case we get
	      "command aborted" status)
Handle cases like the following:
        - controller calls scsi_done() with error XS_TIMEOUT
        - scsi_done() calls sddone()
        - sddone() calls disk_unbusy()
        - scsi_done() calls controller to retry command (missing the
          call to disk_busy())
        - controller calls scsi_done()
        - scsi_done() calls sddone()
        - sddone() calls disk_busy(), which panics because of the imbalance.
Bug noticed by Leo Weppleman, who also suggested this fix; pass an additional
boolean argument ("complete") to the device's "done" routine, with a
value of `0' passed from the previous call to "done", and add an additional
call to "done" when the xfer resources are freed.
@
text
@d1 1
a1 1
/*	$NetBSD: cd.c,v 1.80 1996/01/12 22:43:26 thorpej Exp $	*/
a52 1
#include <sys/conf.h>
d64 2
d71 1
d97 22
a118 2
int cdmatch __P((struct device *, void *, void *));
void cdattach __P((struct device *, struct device *, void *));
a123 6
void cdgetdisklabel __P((struct cd_softc *));
int cd_get_parms __P((struct cd_softc *, int));
void cdstrategy __P((struct buf *));
void cdstart __P((struct cd_softc *));
int cddone __P((struct scsi_xfer *, int));

a146 1
	struct cfdata *cf = match;
a165 1
	struct cd_parms *dp = &cd->params;
d183 1
a183 1
	cd->sc_dk.dk_driver = &cddkdriver;
d190 1
a190 1

d233 2
a234 2
int
cdopen(dev, flag, fmt)
d237 1
d257 1
a257 1
	if (error = cdlock(cd))
d271 5
a275 2
		if (error = scsi_test_unit_ready(sc_link,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE | SCSI_IGNORE_NOT_READY))
d279 4
a282 2
		if (error = scsi_start(sc_link, SSS_START,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT))
d288 4
a291 2
		if (error = scsi_prevent(sc_link, PR_PREVENT,
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE))
d354 2
a355 2
int
cdclose(dev, flag, fmt)
d358 1
d364 1
a364 1
	if (error = cdlock(cd))
d476 3
a478 3
void
cdstart(cd)
	register struct cd_softc *cd;
d480 1
d604 1
a604 1
cdread(dev, uio)
d607 1
d616 1
a616 1
cdwrite(dev, uio)
d619 1
d666 1
a666 1
		if (error = cdlock(cd))
d686 1
a686 1
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
d690 1
a690 1
		if (error = cd_set_mode(cd, &data))
d692 3
a694 2
		return cd_play_tracks(cd, args->start_track, args->start_index,
		    args->end_track, args->end_index);
d697 1
a697 2
		struct ioc_play_msf *args
		= (struct ioc_play_msf *)addr;
d699 1
a699 1
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
d703 1
a703 1
		if (error = cd_set_mode(cd, &data))
d706 2
a707 1
		    args->start_f, args->end_m, args->end_s, args->end_f);
d710 1
a710 2
		struct ioc_play_blocks *args
		= (struct ioc_play_blocks *)addr;
d712 1
a712 1
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
d716 1
a716 1
		if (error = cd_set_mode(cd, &data))
d728 4
a731 2
		if (error = cd_read_subchannel(cd, args->address_format,
		    args->data_format, args->track, &data, len))
d740 3
a742 1
		if (error = cd_read_toc(cd, 0, 0, &th, sizeof(th)))
d762 5
a766 3
		if (error = cd_read_toc(cd, te->address_format,
		    te->starting_track, (struct cd_toc_entry *)&data,
		    len + sizeof(struct ioc_toc_header)))
d769 1
a769 1
		    sizeof(th->ending_track)));
d775 1
a775 1
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
d786 1
a786 1
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
d797 1
a797 1
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
a807 1
		struct ioc_vol *arg = (struct ioc_vol *)addr;
d809 1
a809 1
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
a819 1
		struct ioc_vol *arg = (struct ioc_vol *)addr;
d821 1
a821 1
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
a829 1
		struct ioc_vol *arg = (struct ioc_vol *)addr;
d831 1
a831 1
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
a839 1
		struct ioc_vol *arg = (struct ioc_vol *)addr;
d841 1
a841 1
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
a849 1
		struct ioc_vol *arg = (struct ioc_vol *)addr;
d851 1
a851 1
		if (error = cd_get_mode(cd, &data, AUDIO_PAGE))
d867 2
a868 1
	case CDIOCEJECT:
d874 3
a995 1
	int error;
d1150 1
a1150 1
	int mode, format, len;
@


1.4
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 1
a1 1
/*	$NetBSD: cd.c,v 1.79 1996/01/07 22:03:58 thorpej Exp $	*/
d106 1
a106 1
int cddone __P((struct scsi_xfer *));
d567 1
a567 1
cddone(xs)
d569 1
d573 1
a573 1
	if (xs->bp != NULL)
@


1.3
log
@from netbsd:
If the read or write request can fit into a 6-byte cdb, then
use a 6-byte cdb, otherwise use the 10-byte as before.
@
text
@d1 1
a1 1
/*	$NetBSD: cd.c,v 1.78 1995/12/07 19:11:32 thorpej Exp $	*/
a56 1
#include <sys/mtio.h>
d80 1
a80 1
	struct dkdevice sc_dk;
d106 1
d114 1
a114 1
	NULL,			/* use default 'done' routine */
d166 3
d170 3
d174 1
a174 1
	dk_establish(&cd->sc_dk, &cd->sc_dev);
d257 1
a257 2
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE |
		    SCSI_IGNORE_NOT_READY))
d262 1
a262 2
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE |
		    SCSI_SILENT))
d292 2
a293 2
	    (part >= cd->sc_dk.dk_label.d_npartitions ||
	     cd->sc_dk.dk_label.d_partitions[part].p_fstype == FS_UNUSED)) {
d384 1
a384 1
	if ((bp->b_bcount % cd->sc_dk.dk_label.d_secsize) != 0) {
d407 1
a407 1
	    bounds_check_with_label(bp, &cd->sc_dk.dk_label,
d509 1
a509 1
		    bp->b_blkno / (cd->sc_dk.dk_label.d_secsize / DEV_BSIZE);
d511 2
a512 2
			p = &cd->sc_dk.dk_label.d_partitions[CDPART(bp->b_dev)];
			blkno += p->p_offset;
d514 1
a514 1
		nblks = howmany(bp->b_bcount, cd->sc_dk.dk_label.d_secsize);
d551 3
d567 12
d625 1
a625 1
		*(struct disklabel *)addr = cd->sc_dk.dk_label;
d629 1
a629 1
		((struct partinfo *)addr)->disklab = &cd->sc_dk.dk_label;
d631 1
a631 1
		    &cd->sc_dk.dk_label.d_partitions[CDPART(dev)];
d643 1
a643 1
		error = setdisklabel(&cd->sc_dk.dk_label,
d645 1
a645 1
		    &cd->sc_dk.dk_cpulabel);
a838 3
	case MTIOCTOP:
		if (((struct mtop *)addr)->mt_op != MTOFFL)
			return EIO;
d876 1
a876 1
	struct disklabel *lp = &cd->sc_dk.dk_label;
d879 1
a879 1
	bzero(&cd->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));
@


1.2
log
@mt -f /dev/rcd* offline support
@
text
@d1 1
a1 1
/*	$NetBSD: cd.c,v 1.76 1995/10/10 02:52:56 mycroft Exp $	*/
d171 1
a171 12
	/*
	 * Use the subdriver to request information regarding
	 * the drive. We cannot use interrupts yet, so the
	 * request must specify this.
	 */
	if (scsi_start(cd->sc_link, SSS_START,
	    SCSI_AUTOCONF | SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT) ||
	    cd_get_parms(cd, SCSI_AUTOCONF) != 0)
		printf(": drive empty\n");
	else
		printf(": cd present, %d x %d byte records\n",
		    cd->params.disksize, cd->params.blksize);
d251 2
a252 1
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE | SCSI_IGNORE_NOT_READY))
d257 2
a258 1
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE | SCSI_SILENT))
d456 4
a459 2
	struct scsi_rw_big cmd;
	int blkno, nblks;
d513 2
a514 1
		 *  Fill out the scsi command
d516 30
a545 8
		bzero(&cmd, sizeof(cmd));
		cmd.opcode = (bp->b_flags & B_READ) ? READ_BIG : WRITE_BIG;
		cmd.addr_3 = (blkno >> 24) & 0xff;
		cmd.addr_2 = (blkno >> 16) & 0xff;
		cmd.addr_1 = (blkno >> 8) & 0xff;
		cmd.addr_0 = blkno & 0xff;
		cmd.length2 = (nblks >> 8) & 0xff;
		cmd.length1 = nblks & 0xff;
d551 2
a552 2
		if (scsi_scsi_cmd(sc_link, (struct scsi_generic *)&cmd,
		    sizeof(cmd), (u_char *) bp->b_data, bp->b_bcount,
@


1.1
log
@Initial revision
@
text
@d57 1
d804 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
