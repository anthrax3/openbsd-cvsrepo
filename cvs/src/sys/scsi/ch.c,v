head	1.52;
access;
symbols
	OPENBSD_6_2:1.52.0.8
	OPENBSD_6_2_BASE:1.52
	OPENBSD_6_1:1.52.0.6
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.52.0.2
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.48.0.4
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.46.0.14
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.10
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.8
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.46.0.6
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.4
	OPENBSD_5_0:1.46.0.2
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.43.0.2
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.37.0.4
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.37.0.6
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.32.0.4
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.13
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.8.0.10
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.8
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.6
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.52
date	2016.03.12.15.16.04;	author krw;	state Exp;
branches;
next	1.51;
commitid	zkFngOKA3woPgVlY;

1.51
date	2015.08.23.01.55.39;	author tedu;	state Exp;
branches;
next	1.50;
commitid	OczmFvlAy5J4Utsq;

1.50
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.49;
commitid	p4LJxGKbi0BU2cG6;

1.49
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.48;
commitid	uzzBR7hz9ncd4O6G;

1.48
date	2014.07.13.17.34.25;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	jkrwuhojUhzJkdOy;

1.47
date	2014.07.12.18.50.25;	author tedu;	state Exp;
branches;
next	1.46;
commitid	iN7nvia2fLP712wt;

1.46
date	2011.06.17.00.00.51;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	2011.03.31.18.42.48;	author jasper;	state Exp;
branches;
next	1.44;

1.44
date	2011.03.17.21.30.24;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2010.08.30.02.47.56;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	2010.07.22.15.59.47;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	2010.07.22.00.31.06;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.01.05.11.18;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.26.23.24.45;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.10.21.36.49;	author beck;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.10.00.15.54;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.22.16.32.05;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.16.01.30.24;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.07.16.15.49;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.27.23.14.22;	author beck;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.27.18.24.43;	author beck;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.07.23.40.07;	author beck;	state Exp;
branches;
next	1.28;

1.28
date	2006.06.15.15.02.31;	author beck;	state Exp;
branches;
next	1.27;

1.27
date	2006.05.31.03.38.01;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.31.03.01.44;	author beck;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.28.17.24.43;	author beck;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.11.17.34.27;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.23.23.38.00;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.13.17.56.34;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.23.07.06.16;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.14.00.20.43;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.05.12.13.16;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.30.19.28.36;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.18.16.06.35;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.28.11.42.28;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.30.21.50.28;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2002.10.17.17.47.24;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.22.14.35.42;	author deraadt;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.03.15.20.08.43;	author mjacob;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.08.19.19.33;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	98.03.22.20.19.59;	author tholo;	state Exp;
branches
	1.8.10.1;
next	1.7;

1.7
date	97.04.14.04.09.05;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.08.12.10.21.41;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.02.13.17.50;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.30.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.19.16.10.12;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.20.01.42.01;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches;
next	;

1.8.10.1
date	2001.05.14.22.44.59;	author niklas;	state Exp;
branches;
next	1.8.10.2;

1.8.10.2
date	2001.07.04.11.00.01;	author niklas;	state Exp;
branches;
next	1.8.10.3;

1.8.10.3
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.8.10.4;

1.8.10.4
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.8.10.5;

1.8.10.5
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.8.10.6;

1.8.10.6
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.32.13;	author art;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.11.4.3;

1.11.4.3
date	2003.05.19.22.28.21;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.52
log
@Standardize on calling local scsi_link variables 'link' instead of
'sc_link'. 'sc_link' is a field in the various device *_softc
structures, where the sc_ prefix was for 'softc'. Reduces potential
mental confusion. Newer code from down under was already using
'link'.

No functional change.

Prompted by bluhm@@'s adventures in scsi. ok dlg@@ jmatthew@@
@
text
@/*	$OpenBSD: ch.c,v 1.51 2015/08/23 01:55:39 tedu Exp $	*/
/*	$NetBSD: ch.c,v 1.26 1997/02/21 22:06:52 thorpej Exp $	*/

/*
 * Copyright (c) 1996, 1997 Jason R. Thorpe <thorpej@@and.com>
 * All rights reserved.
 *
 * Partially based on an autochanger driver written by Stefan Grefen
 * and on an autochanger driver written by the Systems Programming Group
 * at the University of Utah Computer Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by Jason R. Thorpe
 *	for And Communications, http://www.and.com/
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/chio.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/conf.h>
#include <sys/fcntl.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_changer.h>
#include <scsi/scsiconf.h>

#define CHRETRIES	2
#define CHUNIT(x)	(minor((x)))

struct ch_softc {
	struct device	sc_dev;		/* generic device info */
	struct scsi_link *sc_link;	/* link in the SCSI bus */

	int		sc_picker;	/* current picker */

	/*
	 * The following information is obtained from the
	 * element address assignment page.
	 */
	int		sc_firsts[4];	/* firsts, indexed by CHET_* */
	int		sc_counts[4];	/* counts, indexed by CHET_* */

	/*
	 * The following mask defines the legal combinations
	 * of elements for the MOVE MEDIUM command.
	 */
	u_int8_t	sc_movemask[4];

	/*
	 * As above, but for EXCHANGE MEDIUM.
	 */
	u_int8_t	sc_exchangemask[4];

	int		flags;		/* misc. info */

	/*
	 * Quirks; see below.
	 */
	int		sc_settledelay; /* delay for settle */

};

/* sc_flags */
#define CHF_ROTATE	0x01		/* picker can rotate */

/* Autoconfiguration glue */
int	chmatch(struct device *, void *, void *);
void	chattach(struct device *, struct device *, void *);

struct cfattach ch_ca = {
	sizeof(struct ch_softc), chmatch, chattach
};

struct cfdriver ch_cd = {
	NULL, "ch", DV_DULL
};

const struct scsi_inquiry_pattern ch_patterns[] = {
	{T_CHANGER, T_REMOV,
	 "",		"",		""},
};

int	ch_move(struct ch_softc *, struct changer_move *);
int	ch_exchange(struct ch_softc *, struct changer_exchange *);
int	ch_position(struct ch_softc *, struct changer_position *);
int	ch_usergetelemstatus(struct ch_softc *,
    struct changer_element_status_request *);
int	ch_getelemstatus(struct ch_softc *, int, int, caddr_t, size_t, int);
int	ch_get_params(struct ch_softc *, int);
int	ch_interpret_sense(struct scsi_xfer *xs);
void	ch_get_quirks(struct ch_softc *, struct scsi_inquiry_data *);

/*
 * SCSI changer quirks.
 */
struct chquirk {
	struct	scsi_inquiry_pattern cq_match; /* device id pattern */
	int	cq_settledelay;	/* settle delay, in seconds */
};

struct chquirk chquirks[] = {
	{{T_CHANGER, T_REMOV,
	  "SPECTRA",	"9000",		"0200"},
	 75},
};

int
chmatch(struct device *parent, void *match, void *aux)
{
	struct scsi_attach_args *sa = aux;
	int priority;

	(void)scsi_inqmatch(sa->sa_inqbuf,
	    ch_patterns, nitems(ch_patterns),
	    sizeof(ch_patterns[0]), &priority);

	return (priority);
}

void
chattach(struct device *parent, struct device *self, void *aux)
{
	struct ch_softc *sc = (struct ch_softc *)self;
	struct scsi_attach_args *sa = aux;
	struct scsi_link *link = sa->sa_sc_link;

	/* Glue into the SCSI bus */
	sc->sc_link = link;
	link->interpret_sense = ch_interpret_sense;
	link->device_softc = sc;
	link->openings = 1;

	printf("\n");

	/*
	 * Store our our device's quirks.
	 */
	ch_get_quirks(sc, sa->sa_inqbuf);

}

int
chopen(dev_t dev, int flags, int fmt, struct proc *p)
{
	struct ch_softc *sc;
	int oldcounts[4];
	int i, unit, error = 0;

	unit = CHUNIT(dev);
	if ((unit >= ch_cd.cd_ndevs) ||
	    ((sc = ch_cd.cd_devs[unit]) == NULL))
		return (ENXIO);

	/*
	 * Only allow one open at a time.
	 */
	if (sc->sc_link->flags & SDEV_OPEN)
		return (EBUSY);

	sc->sc_link->flags |= SDEV_OPEN;

	/*
	 * Absorb any unit attention errors. We must notice
	 * "Not ready" errors as a changer will report "In the
	 * process of getting ready" any time it must rescan
	 * itself to determine the state of the changer.
	 */
	error = scsi_test_unit_ready(sc->sc_link, TEST_READY_RETRIES,
	    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_MEDIA_CHANGE);
	if (error)
		goto bad;

	/*
	 * Get information about the device. Save old information
	 * so we can decide whether to be verbose about new parameters.
	 */
	for (i = 0; i < 4; i++) {
		oldcounts[i] = sc->sc_counts[i];
	}
	error = ch_get_params(sc, scsi_autoconf);
	if (error)
		goto bad;

	for (i = 0; i < 4; i++) {
		if (oldcounts[i] != sc->sc_counts[i]) {
			break;
		}
	}
	if (i < 4) {
#ifdef CHANGER_DEBUG
#define PLURAL(c)	(c) == 1 ? "" : "s"
		printf("%s: %d slot%s, %d drive%s, %d picker%s, %d portal%s\n",
		    sc->sc_dev.dv_xname,
		    sc->sc_counts[CHET_ST], PLURAL(sc->sc_counts[CHET_ST]),
		    sc->sc_counts[CHET_DT], PLURAL(sc->sc_counts[CHET_DT]),
		    sc->sc_counts[CHET_MT], PLURAL(sc->sc_counts[CHET_MT]),
		    sc->sc_counts[CHET_IE], PLURAL(sc->sc_counts[CHET_IE]));
#undef PLURAL
		printf("%s: move mask: 0x%x 0x%x 0x%x 0x%x\n",
		    sc->sc_dev.dv_xname,
		    sc->sc_movemask[CHET_MT], sc->sc_movemask[CHET_ST],
		    sc->sc_movemask[CHET_IE], sc->sc_movemask[CHET_DT]);
		printf("%s: exchange mask: 0x%x 0x%x 0x%x 0x%x\n",
		    sc->sc_dev.dv_xname,
		    sc->sc_exchangemask[CHET_MT], sc->sc_exchangemask[CHET_ST],
		    sc->sc_exchangemask[CHET_IE], sc->sc_exchangemask[CHET_DT]);
#endif /* CHANGER_DEBUG */
	}

	/* Default the current picker. */
	sc->sc_picker = sc->sc_firsts[CHET_MT];

	return (0);

 bad:
	sc->sc_link->flags &= ~SDEV_OPEN;
	return (error);
}

int
chclose(dev_t dev, int flags, int fmt, struct proc *p)
{
	struct ch_softc *sc = ch_cd.cd_devs[CHUNIT(dev)];

	sc->sc_link->flags &= ~SDEV_OPEN;
	return (0);
}

int
chioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	struct ch_softc *sc = ch_cd.cd_devs[CHUNIT(dev)];
	int error = 0;

	/*
	 * If this command can change the device's state, we must
	 * have the device open for writing.
	 */
	switch (cmd) {
	case CHIOGPICKER:
	case CHIOGPARAMS:
	case CHIOGSTATUS:
		break;

	default:
		if ((flags & FWRITE) == 0)
			return (EBADF);
	}

	switch (cmd) {
	case CHIOMOVE:
		error = ch_move(sc, (struct changer_move *)data);
		break;

	case CHIOEXCHANGE:
		error = ch_exchange(sc, (struct changer_exchange *)data);
		break;

	case CHIOPOSITION:
		error = ch_position(sc, (struct changer_position *)data);
		break;

	case CHIOGPICKER:
		*(int *)data = sc->sc_picker - sc->sc_firsts[CHET_MT];
		break;

	case CHIOSPICKER:	{
		int new_picker = *(int *)data;

		if (new_picker > (sc->sc_counts[CHET_MT] - 1))
			return (EINVAL);
		sc->sc_picker = sc->sc_firsts[CHET_MT] + new_picker;
		break;		}

	case CHIOGPARAMS:	{
		struct changer_params *cp = (struct changer_params *)data;

		cp->cp_curpicker = sc->sc_picker - sc->sc_firsts[CHET_MT];
		cp->cp_npickers = sc->sc_counts[CHET_MT];
		cp->cp_nslots = sc->sc_counts[CHET_ST];
		cp->cp_nportals = sc->sc_counts[CHET_IE];
		cp->cp_ndrives = sc->sc_counts[CHET_DT];
		break;		}

	case CHIOGSTATUS:	{
		struct changer_element_status_request *cesr =
		    (struct changer_element_status_request *)data;

		error = ch_usergetelemstatus(sc, cesr);
		break;		}

	/* Implement prevent/allow? */

	default:
		error = scsi_do_ioctl(sc->sc_link, cmd, data, flags);
		break;
	}

	return (error);
}

int
ch_move(struct ch_softc *sc, struct changer_move *cm)
{
	struct scsi_move_medium *cmd;
	struct scsi_xfer *xs;
	int error;
	u_int16_t fromelem, toelem;

	/*
	 * Check arguments.
	 */
	if ((cm->cm_fromtype > CHET_DT) || (cm->cm_totype > CHET_DT))
		return (EINVAL);
	if ((cm->cm_fromunit > (sc->sc_counts[cm->cm_fromtype] - 1)) ||
	    (cm->cm_tounit > (sc->sc_counts[cm->cm_totype] - 1)))
		return (ENODEV);

	/*
	 * Check the request against the changer's capabilities.
	 */
	if ((sc->sc_movemask[cm->cm_fromtype] & (1 << cm->cm_totype)) == 0)
		return (EINVAL);

	/*
	 * Calculate the source and destination elements.
	 */
	fromelem = sc->sc_firsts[cm->cm_fromtype] + cm->cm_fromunit;
	toelem = sc->sc_firsts[cm->cm_totype] + cm->cm_tounit;

	/*
	 * Build the SCSI command.
	 */
	xs = scsi_xs_get(sc->sc_link, 0);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->retries = CHRETRIES;
	xs->timeout = 100000;

	cmd = (struct scsi_move_medium *)xs->cmd;
	cmd->opcode = MOVE_MEDIUM;
	_lto2b(sc->sc_picker, cmd->tea);
	_lto2b(fromelem, cmd->src);
	_lto2b(toelem, cmd->dst);
	if (cm->cm_flags & CM_INVERT)
		cmd->flags |= MOVE_MEDIUM_INVERT;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

int
ch_exchange(struct ch_softc *sc, struct changer_exchange *ce)
{
	struct scsi_exchange_medium *cmd;
	struct scsi_xfer *xs;
	int error;
	u_int16_t src, dst1, dst2;

	/*
	 * Check arguments.
	 */
	if ((ce->ce_srctype > CHET_DT) || (ce->ce_fdsttype > CHET_DT) ||
	    (ce->ce_sdsttype > CHET_DT))
		return (EINVAL);
	if ((ce->ce_srcunit > (sc->sc_counts[ce->ce_srctype] - 1)) ||
	    (ce->ce_fdstunit > (sc->sc_counts[ce->ce_fdsttype] - 1)) ||
	    (ce->ce_sdstunit > (sc->sc_counts[ce->ce_sdsttype] - 1)))
		return (ENODEV);

	/*
	 * Check the request against the changer's capabilities.
	 */
	if (((sc->sc_exchangemask[ce->ce_srctype] &
	    (1 << ce->ce_fdsttype)) == 0) ||
	    ((sc->sc_exchangemask[ce->ce_fdsttype] &
	    (1 << ce->ce_sdsttype)) == 0))
		return (EINVAL);

	/*
	 * Calculate the source and destination elements.
	 */
	src = sc->sc_firsts[ce->ce_srctype] + ce->ce_srcunit;
	dst1 = sc->sc_firsts[ce->ce_fdsttype] + ce->ce_fdstunit;
	dst2 = sc->sc_firsts[ce->ce_sdsttype] + ce->ce_sdstunit;

	/*
	 * Build the SCSI command.
	 */
	xs = scsi_xs_get(sc->sc_link, 0);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->retries = CHRETRIES;
	xs->timeout = 100000;

	cmd = (struct scsi_exchange_medium *)xs->cmd;
	cmd->opcode = EXCHANGE_MEDIUM;
	_lto2b(sc->sc_picker, cmd->tea);
	_lto2b(src, cmd->src);
	_lto2b(dst1, cmd->fdst);
	_lto2b(dst2, cmd->sdst);
	if (ce->ce_flags & CE_INVERT1)
		cmd->flags |= EXCHANGE_MEDIUM_INV1;
	if (ce->ce_flags & CE_INVERT2)
		cmd->flags |= EXCHANGE_MEDIUM_INV2;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

int
ch_position(struct ch_softc *sc, struct changer_position *cp)
{
	struct scsi_position_to_element *cmd;
	struct scsi_xfer *xs;
	int error;
	u_int16_t dst;

	/*
	 * Check arguments.
	 */
	if (cp->cp_type > CHET_DT)
		return (EINVAL);
	if (cp->cp_unit > (sc->sc_counts[cp->cp_type] - 1))
		return (ENODEV);

	/*
	 * Calculate the destination element.
	 */
	dst = sc->sc_firsts[cp->cp_type] + cp->cp_unit;

	/*
	 * Build the SCSI command.
	 */
	xs = scsi_xs_get(sc->sc_link, 0);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->retries = CHRETRIES;
	xs->timeout = 100000;

	cmd = (struct scsi_position_to_element *)xs->cmd;
	cmd->opcode = POSITION_TO_ELEMENT;
	_lto2b(sc->sc_picker, cmd->tea);
	_lto2b(dst, cmd->dst);
	if (cp->cp_flags & CP_INVERT)
		cmd->flags |= POSITION_TO_ELEMENT_INVERT;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

/*
 * Copy a volume tag to a volume_tag struct, converting SCSI byte order
 * to host native byte order in the volume serial number.  The volume
 * label as returned by the changer is transferred to user mode as
 * nul-terminated string.  Volume labels are truncated at the first
 * space, as suggested by SCSI-2.
 */
static  void
copy_voltag(struct changer_voltag *uvoltag, struct volume_tag *voltag)
{
	int i;

	for (i=0; i<CH_VOLTAG_MAXLEN; i++) {
		char c = voltag->vif[i];
		if (c && c != ' ')
			uvoltag->cv_volid[i] = c;
		else
			break;
	}
	uvoltag->cv_volid[i] = '\0';
	uvoltag->cv_serial = _2btol(voltag->vsn);
}

/*
 * Copy an an element status descriptor to a user-mode
 * changer_element_status structure.
 */
static void
copy_element_status(int flags,	struct read_element_status_descriptor *desc,
    struct changer_element_status *ces)
{
	ces->ces_flags = desc->flags1;

	if (flags & READ_ELEMENT_STATUS_PVOLTAG)
		copy_voltag(&ces->ces_pvoltag, &desc->pvoltag);
	if (flags & READ_ELEMENT_STATUS_AVOLTAG)
		copy_voltag(&ces->ces_avoltag, &desc->avoltag);
}

/*
 * Perform a READ ELEMENT STATUS on behalf of the user, and return to
 * the user only the data the user is interested in (i.e. an array of
 * changer_element_status structures)
 */
int
ch_usergetelemstatus(struct ch_softc *sc,
    struct changer_element_status_request *cesr)
{
	struct changer_element_status *user_data = NULL;
	struct read_element_status_header *st_hdr;
	struct read_element_status_page_header *pg_hdr;
	caddr_t desc;
	caddr_t data = NULL;
	size_t size, desclen, udsize;
	int chet = cesr->cesr_type;
	int avail, i, error = 0;
	int want_voltags = (cesr->cesr_flags & CESR_VOLTAGS) ? 1 : 0;

	/*
	 * If there are no elements of the requested type in the changer,
	 * the request is invalid.
	 */
	if (sc->sc_counts[chet] == 0)
		return (EINVAL);

	/*
	 * Request one descriptor for the given element type.  This
	 * is used to determine the size of the descriptor so that
	 * we can allocate enough storage for all of them.  We assume
	 * that the first one can fit into 1k.
	 */
	size = 1024;
	data = dma_alloc(size, PR_WAITOK);
	error = ch_getelemstatus(sc, sc->sc_firsts[chet], 1, data, size,
	    want_voltags);
	if (error)
		goto done;

	st_hdr = (struct read_element_status_header *)data;
	pg_hdr = (struct read_element_status_page_header *) (st_hdr + 1);
	desclen = _2btol(pg_hdr->edl);

	dma_free(data, size);

	/*
	 * Reallocate storage for descriptors and get them from the
	 * device.
	 */
	size = sizeof(struct read_element_status_header) +
	    sizeof(struct read_element_status_page_header) +
	    (desclen * sc->sc_counts[chet]);
	data = dma_alloc(size, PR_WAITOK);
	error = ch_getelemstatus(sc, sc->sc_firsts[chet],
	    sc->sc_counts[chet], data, size, want_voltags);
	if (error)
		goto done;

	/*
	 * Fill in the user status array.
	 */
	st_hdr = (struct read_element_status_header *)data;
	pg_hdr = (struct read_element_status_page_header *) (st_hdr + 1);

	avail = _2btol(st_hdr->count);
	if (avail != sc->sc_counts[chet]) {
		error = EINVAL;
		goto done;
	}

	user_data = mallocarray(avail, sizeof(struct changer_element_status),
	    M_DEVBUF, M_WAITOK | M_ZERO);
	udsize = avail * sizeof(struct changer_element_status);

	desc = (caddr_t)(pg_hdr + 1);
	for (i = 0; i < avail; ++i) {
		struct changer_element_status *ces = &(user_data[i]);
		copy_element_status(pg_hdr->flags,
		    (struct read_element_status_descriptor *)desc, ces);
		desc += desclen;
	}

	/* Copy array out to userspace. */
	error = copyout(user_data, cesr->cesr_data, udsize);

 done:
	if (data != NULL)
		dma_free(data, size);
	if (user_data != NULL)
		free(user_data, M_DEVBUF, udsize);
	return (error);
}

int
ch_getelemstatus(struct ch_softc *sc, int first, int count, caddr_t data,
    size_t datalen, int voltag)
{
	struct scsi_read_element_status *cmd;
	struct scsi_xfer *xs;
	int error;

	/*
	 * Build SCSI command.
	 */
	xs = scsi_xs_get(sc->sc_link, SCSI_DATA_IN);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->data = data;
	xs->datalen = datalen;
	xs->retries = CHRETRIES;
	xs->timeout = 100000;

	cmd = (struct scsi_read_element_status *)xs->cmd;
	cmd->opcode = READ_ELEMENT_STATUS;
	_lto2b(first, cmd->sea);
	_lto2b(count, cmd->count);
	_lto3b(datalen, cmd->len);
	if (voltag)
		cmd->byte2 |= READ_ELEMENT_STATUS_VOLTAG;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

/*
 * Ask the device about itself and fill in the parameters in our
 * softc.
 */
int
ch_get_params(struct ch_softc *sc, int flags)
{
	union scsi_mode_sense_buf *data;
	struct page_element_address_assignment *ea;
	struct page_device_capabilities *cap;
	int error, from;
	u_int8_t *moves, *exchanges;

	data = dma_alloc(sizeof(*data), PR_NOWAIT);
	if (data == NULL)
		return (ENOMEM);

	/*
	 * Grab info from the element address assignment page (0x1d).
	 */
	error = scsi_do_mode_sense(sc->sc_link, 0x1d, data,
	    (void **)&ea, NULL, NULL, NULL, sizeof(*ea), flags, NULL);
	if (error == 0 && ea == NULL)
		error = EIO;
	if (error != 0) {
#ifdef CHANGER_DEBUG
		printf("%s: could not sense element address page\n",
		    sc->sc_dev.dv_xname);
#endif
		dma_free(data, sizeof(*data));
		return (error);
	}

	sc->sc_firsts[CHET_MT] = _2btol(ea->mtea);
	sc->sc_counts[CHET_MT] = _2btol(ea->nmte);
	sc->sc_firsts[CHET_ST] = _2btol(ea->fsea);
	sc->sc_counts[CHET_ST] = _2btol(ea->nse);
	sc->sc_firsts[CHET_IE] = _2btol(ea->fieea);
	sc->sc_counts[CHET_IE] = _2btol(ea->niee);
	sc->sc_firsts[CHET_DT] = _2btol(ea->fdtea);
	sc->sc_counts[CHET_DT] = _2btol(ea->ndte);

	/* XXX Ask for transport geometry page. */

	/*
	 * Grab info from the capabilities page (0x1f).
	 */
	error = scsi_do_mode_sense(sc->sc_link, 0x1f, data,
	    (void **)&cap, NULL, NULL, NULL, sizeof(*cap), flags, NULL);
	if (cap == NULL)
		error = EIO;
	if (error != 0) {
#ifdef CHANGER_DEBUG
		printf("%s: could not sense capabilities page\n",
		    sc->sc_dev.dv_xname);
#endif
		dma_free(data, sizeof(*data));
		return (error);
	}

	bzero(sc->sc_movemask, sizeof(sc->sc_movemask));
	bzero(sc->sc_exchangemask, sizeof(sc->sc_exchangemask));
	moves = &cap->move_from_mt;
	exchanges = &cap->exchange_with_mt;
	for (from = CHET_MT; from <= CHET_DT; ++from) {
		sc->sc_movemask[from] = moves[from];
		sc->sc_exchangemask[from] = exchanges[from];
	}

	sc->sc_link->flags |= SDEV_MEDIA_LOADED;
	dma_free(data, sizeof(*data));
	return (0);
}

void
ch_get_quirks(struct ch_softc *sc, struct scsi_inquiry_data *inqbuf)
{
	const struct chquirk *match;
	int priority;

	sc->sc_settledelay = 0;

	match = (const struct chquirk *)scsi_inqmatch(inqbuf,
	    (caddr_t)chquirks,
	    sizeof(chquirks) / sizeof(chquirks[0]),
	    sizeof(chquirks[0]), &priority);
	if (priority != 0) {
		sc->sc_settledelay = match->cq_settledelay;
	}
}

/*
 * Look at the returned sense and act on the error and detirmine
 * The unix error number to pass back... (0 = report no error)
 *                            (-1 = continue processing)
 */
int
ch_interpret_sense(struct scsi_xfer *xs)
{
	struct scsi_sense_data *sense = &xs->sense;
	struct scsi_link *link = xs->sc_link;
	u_int8_t serr = sense->error_code & SSD_ERRCODE;
	u_int8_t skey = sense->flags & SSD_KEY;

	if (((link->flags & SDEV_OPEN) == 0) ||
	    (serr != SSD_ERRCODE_CURRENT && serr != SSD_ERRCODE_DEFERRED))
		return (scsi_interpret_sense(xs));

	switch (skey) {

	/*
	 * We do custom processing in ch for the unit becoming ready case.
	 * in this case we do not allow xs->retries to be decremented
	 * only on the "Unit Becoming Ready" case. This is because tape
	 * changers report "Unit Becoming Ready" when they rescan their
	 * state (i.e. when the door got opened) and can take a long time
	 * for large units. Rather than having a massive timeout for
	 * all operations (which would cause other problems) we allow
	 * changers to wait (but be interruptable with Ctrl-C) forever
	 * as long as they are reporting that they are becoming ready.
	 * all other cases are handled as per the default.
	 */
	case SKEY_NOT_READY:
		if ((xs->flags & SCSI_IGNORE_NOT_READY) != 0)
			return (0);
		switch (ASC_ASCQ(sense)) {
		case SENSE_NOT_READY_BECOMING_READY:
			SC_DEBUG(link, SDEV_DB1, ("not ready: busy (%#x)\n",
			    sense->add_sense_code_qual));
			/* don't count this as a retry */
			xs->retries++;
			return (scsi_delay(xs, 1));
		default:
			return (scsi_interpret_sense(xs));
	}
	default:
		return (scsi_interpret_sense(xs));
	}
}
@


1.51
log
@add some sizes to free. looked over by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.50 2015/03/14 03:38:52 jsg Exp $	*/
d755 1
a755 1
	struct scsi_link *sc_link = xs->sc_link;
d759 1
a759 1
	if (((sc_link->flags & SDEV_OPEN) == 0) ||
d782 1
a782 1
			SC_DEBUG(sc_link, SDEV_DB1, ("not ready: busy (%#x)\n",
@


1.50
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.49 2014/09/14 14:17:26 jsg Exp $	*/
d617 1
a617 1
		free(user_data, M_DEVBUF, 0);
@


1.49
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.48 2014/07/13 17:34:25 deraadt Exp $	*/
a43 1
#include <sys/buf.h>
@


1.48
log
@use mallocarray where arguments are multiplied; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.47 2014/07/12 18:50:25 tedu Exp $	*/
a44 1
#include <sys/proc.h>
@


1.47
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.46 2011/06/17 00:00:51 matthew Exp $	*/
d599 3
a602 2

	user_data = malloc(udsize, M_DEVBUF, M_WAITOK | M_ZERO);
@


1.46
log
@Update ch(4) to use ISO C style function definitions to avoid
confusing Coccinelle.

No binary change.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.45 2011/03/31 18:42:48 jasper Exp $	*/
d618 1
a618 1
		free(user_data, M_DEVBUF);
@


1.45
log
@- use nitems(); no binary change.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.44 2011/03/17 21:30:24 deraadt Exp $	*/
d138 1
a138 3
chmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d151 1
a151 3
chattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d173 1
a173 4
chopen(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct proc *p;
d251 1
a251 4
chclose(dev, flags, fmt, p)
	dev_t dev;
	int flags, fmt;
	struct proc *p;
d260 1
a260 6
chioctl(dev, cmd, data, flags, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flags;
	struct proc *p;
d333 1
a333 3
ch_move(sc, cm)
	struct ch_softc *sc;
	struct changer_move *cm;
d386 1
a386 3
ch_exchange(sc, ce)
	struct ch_softc *sc;
	struct changer_exchange *ce;
d448 1
a448 3
ch_position(sc, cp)
	struct ch_softc *sc;
	struct changer_position *cp;
d536 2
a537 3
ch_usergetelemstatus(sc, cesr)
	struct ch_softc *sc;
	struct changer_element_status_request *cesr;
d623 2
a624 7
ch_getelemstatus(sc, first, count, data, datalen, voltag)
	struct ch_softc *sc;
	int first;
	int count;
	caddr_t data;
	size_t datalen;
	int voltag;
d661 1
a661 3
ch_get_params(sc, flags)
	struct ch_softc *sc;
	int flags;
d731 1
a731 3
ch_get_quirks(sc, inqbuf)
	struct ch_softc *sc;
	struct scsi_inquiry_data *inqbuf;
d753 1
a753 2
ch_interpret_sense(xs)
	struct scsi_xfer *xs;
@


1.44
log
@use dma_alloc/dma_free instead of malloc to allocate buffers which need
to be in the right address space.
help from matthew and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.43 2010/08/30 02:47:56 matthew Exp $	*/
d146 1
a146 1
	    ch_patterns, sizeof(ch_patterns)/sizeof(ch_patterns[0]),
@


1.43
log
@Avoid possible aliasing-related compiler issues by always writing to
cmd->opcode through the type casted command pointer rather than
through xs->cmd->opcode.

Requested by deraadt@@; ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.42 2010/07/22 15:59:47 matthew Exp $	*/
d49 1
d584 3
a586 2
	data = malloc(1024, M_DEVBUF, M_WAITOK);
	error = ch_getelemstatus(sc, sc->sc_firsts[chet], 1, data, 1024,
d595 1
a595 3
	size = sizeof(struct read_element_status_header) +
	    sizeof(struct read_element_status_page_header) +
	    (desclen * sc->sc_counts[chet]);
d601 4
a604 2
	free(data, M_DEVBUF);
	data = malloc(size, M_DEVBUF, M_WAITOK);
d638 1
a638 1
		free(data, M_DEVBUF);
d698 1
a698 1
	data = malloc(sizeof(*data), M_TEMP, M_NOWAIT);
d714 1
a714 1
		free(data, M_TEMP);
d741 1
a741 1
		free(data, M_TEMP);
d755 1
a755 1
	free(data, M_TEMP);
@


1.42
log
@Fix a few more scsi_scsi_cmd() removal regressions, caught by
-Wuninitialized.

Silly typo in my first diff noticed by oga@@ and krw@@; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.41 2010/07/22 00:31:06 krw Exp $	*/
a382 1
	xs->cmd->opcode = MOVE_MEDIUM;
d388 1
a443 1
	xs->cmd->opcode = EXCHANGE_MEDIUM;
d449 1
a493 1
	xs->cmd->opcode = POSITION_TO_ELEMENT;
d499 1
a660 1
	xs->cmd->opcode = READ_ELEMENT_STATUS;
d668 1
@


1.41
log
@Eliminate scsi_scsi_cmd() now that ss(4) is gone and with it the
last bastardized sync and buf call through scsi_scsi_cmd(). Flatten
code to call scsi_xs_sync() directly for all commands.

Airplane typos shaken out by various.

ok dlg@@ matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.40 2010/07/01 05:11:18 krw Exp $	*/
d388 1
d449 1
d499 1
@


1.40
log
@Die struct scsi_device! Die! Instead, save a pointer to the routine
to interpret sense errors. This is initialized to the basic
interpretation routine, and specific scsi drivers (sd/st/cd) can
replace this with their own. While here kill EJUSTRETURN dance and
make more specialized interpretation routines directly call the
basic routine if desired.

Fixes by matthew@@ to my first diff. Most original work by dlg@@.

ok matthew@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.39 2010/06/26 23:24:45 guenther Exp $	*/
d351 3
a353 1
	struct scsi_move_medium cmd;
d380 11
a390 5
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = MOVE_MEDIUM;
	_lto2b(sc->sc_picker, cmd.tea);
	_lto2b(fromelem, cmd.src);
	_lto2b(toelem, cmd.dst);
d392 1
a392 1
		cmd.flags |= MOVE_MEDIUM_INVERT;
d394 4
a397 5
	/*
	 * Send command to changer.
	 */
	return (scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), NULL, 0, CHRETRIES, 100000, NULL, 0));
d405 3
a407 1
	struct scsi_exchange_medium cmd;
d440 12
a451 6
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = EXCHANGE_MEDIUM;
	_lto2b(sc->sc_picker, cmd.tea);
	_lto2b(src, cmd.src);
	_lto2b(dst1, cmd.fdst);
	_lto2b(dst2, cmd.sdst);
d453 1
a453 1
		cmd.flags |= EXCHANGE_MEDIUM_INV1;
d455 4
a458 1
		cmd.flags |= EXCHANGE_MEDIUM_INV2;
d460 1
a460 5
	/*
	 * Send command to changer.
	 */
	return (scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), NULL, 0, CHRETRIES, 100000, NULL, 0));
d468 3
a470 1
	struct scsi_position_to_element cmd;
d489 10
a498 4
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = POSITION_TO_ELEMENT;
	_lto2b(sc->sc_picker, cmd.tea);
	_lto2b(dst, cmd.dst);
d500 1
a500 1
		cmd.flags |= POSITION_TO_ELEMENT_INVERT;
d502 4
a505 5
	/*
	 * Send command to changer.
	 */
	return (scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), NULL, 0, CHRETRIES, 100000, NULL, 0));
d648 3
a650 1
	struct scsi_read_element_status cmd;
d655 14
a668 5
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = READ_ELEMENT_STATUS;
	_lto2b(first, cmd.sea);
	_lto2b(count, cmd.count);
	_lto3b(datalen, cmd.len);
d670 4
a673 1
		cmd.byte2 |= READ_ELEMENT_STATUS_VOLTAG;
d675 1
a675 6
	/*
	 * Send command to changer.
	 */
	return (scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), (u_char *)data, datalen, CHRETRIES, 100000, NULL,
	    SCSI_DATA_IN));
a676 1

@


1.39
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.38 2010/06/15 04:11:34 dlg Exp $	*/
a121 8
/* SCSI glue */
struct scsi_device ch_switch = {
	ch_interpret_sense,
	NULL,
	NULL,
	NULL
};

d162 1
a162 1
	link->device = &ch_switch;
d760 1
a760 1
		return (EJUSTRETURN); /* let the generic code handle it */
d787 1
a787 1
			return (EJUSTRETURN);
d790 1
a790 1
		return (EJUSTRETURN);
@


1.38
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.37 2009/01/10 21:36:49 beck Exp $	*/
a45 1
#include <sys/user.h>
@


1.37
log
@Get rid of eye-bleeding horror of casting pointers to u_long to add
a size to them, because the original author of this stuff obviously
didn't grok pointer arithmatic.
ok krw@@, tedu@@, marco@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.36 2009/01/10 00:15:54 jsg Exp $	*/
d348 1
a348 2
		error = scsi_do_ioctl(sc->sc_link, dev, cmd, data,
		    flags, p);
@


1.36
log
@Don't try to cast an lvalue which is forbidden and something pcc, lint,
and newer versions of gcc all object to.

ok miod@@ krw@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.35 2008/06/22 16:32:05 krw Exp $	*/
d499 1
a499 1
 * to host native byte order in the volume serial number.  The volume          
d529 1
a529 1
	
d549 1
a549 1
	struct read_element_status_descriptor *desc;
d576 1
a576 2
	pg_hdr = (struct read_element_status_page_header *)((u_long)st_hdr +
	    sizeof(struct read_element_status_header));
d598 1
a598 2
	pg_hdr = (struct read_element_status_page_header *)((u_long)data +
	    sizeof(struct read_element_status_header));
d609 1
a609 3
	desc = (struct read_element_status_descriptor *)((u_long)data +
	    sizeof(struct read_element_status_header) +
	    sizeof(struct read_element_status_page_header));
d612 3
a614 3
		copy_element_status(pg_hdr->flags, desc, ces);
		desc = (struct read_element_status_descriptor *)((u_long)desc +
		    desclen);
@


1.35
log
@Replace MUSTEK_RETRIES, SCANJET_RETRIES and ST_RETRIES with SCSI_RETRIES,
all defined to 4. Replace some magic number 4's with SCSI_RETRIES. Fix a
few lines that were now too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.34 2007/09/16 01:30:24 krw Exp $	*/
d617 2
a618 1
		(u_long)desc += desclen;
@


1.34
log
@MALLOC/FREE -> malloc/free, M_ZERO, extraneous casts,
extraneous #include <malloc.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.33 2007/09/07 16:15:49 krw Exp $	*/
d657 2
a658 1
	    sizeof(cmd), (u_char *)data, datalen, CHRETRIES, 100000, NULL, SCSI_DATA_IN));
@


1.33
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.32 2006/11/28 16:56:50 dlg Exp $	*/
d569 1
a569 1
	data = (caddr_t)malloc(1024, M_DEVBUF, M_WAITOK);
d589 1
a589 1
	data = (caddr_t)malloc(size, M_DEVBUF, M_WAITOK);
@


1.32
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.31 2006/11/27 23:14:22 beck Exp $	*/
d609 1
a609 2
	user_data = malloc(udsize, M_DEVBUF, M_WAITOK);
	bzero(user_data, udsize);
@


1.31
log
@more magic removal
ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.30 2006/11/27 18:24:43 beck Exp $	*/
d150 1
a150 1
	struct scsibus_attach_args *sa = aux;
d166 1
a166 1
	struct scsibus_attach_args *sa = aux;
@


1.30
log
@rework asc/ascq handling to get rid of "magic" 0x values in the code, changes
asc/ascq handling to deal with the pair together rather than seperately, since
modern scsi has long since polluted the "categories" of asc enough that you
pretty much need to always look as ascq.

ok krw@@ deraadt@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.29 2006/10/07 23:40:07 beck Exp $	*/
d772 1
a772 1
	    (serr != 0x70 && serr != 0x71))
@


1.29
log
@make cd-roms retry forever while the device indicates that it is
"becoming ready" - this is done in the exact same way that it
was done for tape in st.c. This commit adds a cd specific interpret_sense
routine to cd.c that will catch the becoming ready case and handle it.
This also removes the need to use crazy timeouts to catch this case.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.28 2006/06/15 15:02:31 beck Exp $	*/
d792 7
a798 14
		switch (sense->add_sense_code) {
		case 0x04:	/* LUN not ready */
			switch (sense->add_sense_code_qual) {
				case 0x01: /* Becoming Ready */
					SC_DEBUG(sc_link, SDEV_DB1,
		    			    ("not ready: busy (%#x)\n",
					    sense->add_sense_code_qual));
					/* don't count this as a retry */
					xs->retries++;
					return (scsi_delay(xs, 1));
				default:
					return (EJUSTRETURN);
			}
			break;
@


1.28
log
@	Quell dmesg spewage from ch(4) - this diff moves much of the
diagnostic type printf spew that is useful into #ifdef CHANGER_DEBUG,
removes some that is pretty much useless, and changes one instance
of using kernel printf to indicate the truncation of a result due to the
provided buffer being too small into a return of EINVAL back to the caller.

tested by me and mbalmer@@
ok krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.27 2006/05/31 03:38:01 deraadt Exp $	*/
d213 1
a213 2
	error = scsi_test_unit_ready(sc->sc_link,
	    TEST_READY_RETRIES_TAPE,
@


1.27
log
@fix tree
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.26 2006/05/31 03:01:44 beck Exp $	*/
d227 1
a227 2
	if (error) {
		printf("%s: offline\n", sc->sc_dev.dv_xname);
a228 1
	}
d236 1
a244 1
#ifdef CHANGER_DEBUG
d604 4
a607 3
	if (avail != sc->sc_counts[chet])
		printf("%s: warning, READ ELEMENT STATUS avail != count\n",
		    sc->sc_dev.dv_xname);
d690 1
d693 1
d717 1
d720 1
@


1.26
log
@
	Add support for primary and alternate volume tags to ch(4) - borrowed
and adapted from FreeBSD. This adds the ability for status requests to ask
for the volume tags (usually bar codes, on changers with a bar code reader)
on media inthe library.

ok deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.25 2006/05/28 17:24:43 beck Exp $	*/
d573 1
a573 1
	error = ch_getelemstatus(sc, sc->sc_firsts[chet], 1, data,
@


1.25
log
@
Fix open(2) semantics for ch(4) to not be completely on fresh minty crack:

1) Don't use SCSI_IGNORE_NOT_READY when doing test_unit ready to wait for
the device to come up.

2) use SCSI_IGNORE_ILLEGAL_REQUEST when doing test_unit_ready to wait for
the device to come up (just as is done in st(4))

3) add a ch_interpret_sense routing to perform special handling of
the case where the unit is in the process of becoming ready. Hope springs
eternal, that if the device tells us it is trying to become ready, then
we should wait for it to do so, however long it takes (and on tape library
scans this can take a while - i.e. a few minutes for large libraries).
The custom handler ensures that the retry count is not decremented in
this case and this case only.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.24 2006/05/11 00:45:59 krw Exp $	*/
d116 3
a118 2
int	ch_usergetelemstatus(struct ch_softc *, int, u_int8_t *);
int	ch_getelemstatus(struct ch_softc *, int, int, caddr_t, size_t);
d210 1
a210 1
	 * process of getting ready" any time it must rescan 
d342 2
a343 2
		struct changer_element_status *ces =
		    (struct changer_element_status *)data;
d345 1
a345 1
		error = ch_usergetelemstatus(sc, ces->ces_type, ces->ces_data);
d501 39
d542 1
a542 1
 * flags bytes).
d545 1
a545 1
ch_usergetelemstatus(sc, chet, uptr)
d547 1
a547 2
	int chet;
	u_int8_t *uptr;
d549 1
d554 2
a555 1
	size_t size, desclen;
d557 1
a557 1
	u_int8_t *user_data = NULL;
d573 2
a574 1
	error = ch_getelemstatus(sc, sc->sc_firsts[chet], 1, data, 1024);
d594 1
a594 1
	    sc->sc_counts[chet], data, size);
d602 3
d609 1
d611 2
a612 1
	user_data = (u_int8_t *)malloc(avail, M_DEVBUF, M_WAITOK);
d618 2
a619 1
		user_data[i] = desc->flags1;
d623 2
a624 2
	/* Copy flags array out to userspace. */
	error = copyout(user_data, uptr, avail);
d635 1
a635 1
ch_getelemstatus(sc, first, count, data, datalen)
d637 2
a638 1
	int first, count;
d641 1
d653 2
d781 1
a781 1
	 * for large units. Rather than having a massive timeout for 
@


1.24
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.23 2005/09/11 17:34:27 krw Exp $	*/
a112 5
/* SCSI glue */
struct scsi_device ch_switch = {
	NULL, NULL, NULL, NULL
};

d119 1
d122 8
d207 4
a210 3
	 * Absorb any unit attention errors.  Ignore "not ready"
	 * since this might occur if e.g. a tape isn't actually
	 * loaded in the drive.
d213 2
a214 2
	    TEST_READY_RETRIES_DEFAULT,
	    SCSI_IGNORE_NOT_READY|SCSI_IGNORE_MEDIA_CHANGE);
d700 57
@


1.23
log
@Simplify code by changing struct scsi_mode_sense_buf{ union {}
headers; } to just union scsi_mode_sense_buf {}. No functional change.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.22 2005/08/23 23:38:00 krw Exp $	*/
d47 1
a47 1
#include <sys/chio.h> 
@


1.22
log
@Move uses of struct scsi_mode_sense_buf (255 bytes each) from the
stack into malloc'd memory.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.21 2005/08/13 17:56:34 krw Exp $	*/
d616 1
a616 1
	struct scsi_mode_sense_buf *data;
@


1.21
log
@Use scsi_do_mode_sense(). Testing on beck@@'s new LTO changer.

ok tdeval@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.20 2005/05/23 07:06:16 krw Exp $	*/
d616 1
a616 1
	struct scsi_mode_sense_buf data;
d622 4
d629 1
a629 1
	error = scsi_do_mode_sense(sc->sc_link, 0x1d, &data,
d631 1
a631 1
	if (ea == NULL)
d636 1
d654 1
a654 1
	error = scsi_do_mode_sense(sc->sc_link, 0x1f, &data,
d661 1
d675 1
@


1.20
log
@Don't bzero() data before calling scsi_mode_sense[_big]() since
scsi_mode_sense[_big] bzero()'s it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.19 2005/05/14 00:20:43 krw Exp $	*/
d616 3
a618 8
	struct scsi_mode_sense_data {
		struct scsi_mode_header header;
		union {
			struct page_element_address_assignment ea;
			struct page_transport_geometry_parameters tg;
			struct page_device_capabilities cap;
		} pages;
	} sense_data;
d625 5
a629 4
	error = scsi_mode_sense(sc->sc_link, SMS_DBD, 0x1d,
	    (struct scsi_mode_header *)&sense_data, sizeof(sense_data), flags,
	    6000);
	if (error) {
d635 8
a642 8
	sc->sc_firsts[CHET_MT] = _2btol(sense_data.pages.ea.mtea);
	sc->sc_counts[CHET_MT] = _2btol(sense_data.pages.ea.nmte);
	sc->sc_firsts[CHET_ST] = _2btol(sense_data.pages.ea.fsea);
	sc->sc_counts[CHET_ST] = _2btol(sense_data.pages.ea.nse);
	sc->sc_firsts[CHET_IE] = _2btol(sense_data.pages.ea.fieea);
	sc->sc_counts[CHET_IE] = _2btol(sense_data.pages.ea.niee);
	sc->sc_firsts[CHET_DT] = _2btol(sense_data.pages.ea.fdtea);
	sc->sc_counts[CHET_DT] = _2btol(sense_data.pages.ea.ndte);
d644 1
a644 1
	/* XXX ask for page trasport geom */
d649 5
a653 4
	error = scsi_mode_sense(sc->sc_link, SMS_DBD, 0x1f,
	    (struct scsi_mode_header *)&sense_data, sizeof(sense_data), flags,
	    6000);
	if (error) {
d661 2
a662 2
	moves = &sense_data.pages.cap.move_from_mt;
	exchanges = &sense_data.pages.cap.exchange_with_mt;
@


1.19
log
@Add scsi_mode_[sense|select]_big() and use it instead of
atapi_mode_[sense|select](). This will allow the removal of
atapi_base.c and atapi_all.h files, and sets the stage for better usb
mode sense handling amoung other things.

Remove cd_scsibus_[get|set]_mode() and
sd_scsibus_mode_sense() shims in favour of scsi_mode_[sense|select]().
Add zero'ing of reserved length field in scsi_mode_select(). Change
some uchar * type parameters to scsi_mode_header *.

No functional changes. Mostly from NetBSD.

ok dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.18 2005/04/05 12:13:16 krw Exp $	*/
a629 1
	bzero(&sense_data, sizeof(sense_data));
a652 1
	bzero(&sense_data, sizeof(sense_data));
@


1.18
log
@Factor out scsi_mode_sense() and scsi_mode_select() like NetBSD does.
Eliminate some duplicate structures and defines along the way. SCSI CD
drives will now pay attention to the 'flags' parameter for MODE SENSE
and MODE SELECT commands. No other functional change.

ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.17 2004/11/30 19:28:36 krw Exp $	*/
d630 1
d632 2
a633 1
	    (u_char *)&sense_data, sizeof(sense_data), flags, 6000);
d654 1
d656 2
a657 1
	    (u_char *)&sense_data, sizeof(sense_data), flags, 6000);
@


1.17
log
@No longer require write permission for read-only SCSI commands
submitted via ioctl. Eliminate scsi_do_safeioctl(), thus permitting
ch, ss and st devices to submit SCSI commands. Return EPERM rather
than EBADF when permissions are inadequate.

Allows more programs to run with fewer permissions. Problem diagnosed
by Nikolay Sturm in mplayer port.

Tested by Nikolay, ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.16 2003/05/18 16:06:35 mickey Exp $	*/
d612 1
a612 1
ch_get_params(sc, scsiflags)
d614 1
a614 1
	int scsiflags;
a615 1
	struct scsi_mode_sense cmd;
d628 1
a628 1
	 * Grab info from the element address assignment page.
d630 2
a631 9
	bzero(&cmd, sizeof(cmd));
	bzero(&sense_data, sizeof(sense_data));
	cmd.opcode = MODE_SENSE;
	cmd.byte2 |= 0x08;	/* disable block descriptors */
	cmd.page = 0x1d;
	cmd.length = (sizeof(sense_data) & 0xff);
	error = scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), (u_char *)&sense_data, sizeof(sense_data), CHRETRIES,
	    6000, NULL, scsiflags | SCSI_DATA_IN);
d650 1
a650 1
	 * Grab info from the capabilities page.
d652 2
a653 9
	bzero(&cmd, sizeof(cmd));
	bzero(&sense_data, sizeof(sense_data));
	cmd.opcode = MODE_SENSE;
	cmd.byte2 |= 0x08;	/* disable block descriptors */
	cmd.page = 0x1f;
	cmd.length = (sizeof(sense_data) & 0xff);
	error = scsi_scsi_cmd(sc->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), (u_char *)&sense_data, sizeof(sense_data), CHRETRIES,
	    6000, NULL, scsiflags | SCSI_DATA_IN);
@


1.16
log
@constify the quirck tables and fix the scsi_inqmatch() proto accordingly; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.15 2003/03/28 11:42:28 mickey Exp $	*/
d345 1
a345 1
		error = scsi_do_safeioctl(sc->sc_link, dev, cmd, data,
@


1.15
log
@OCHIO* dies horrible death by dd; as per renaming done before
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.14 2002/12/30 21:50:28 grange Exp $	*/
d108 1
a108 1
struct scsi_inquiry_pattern ch_patterns[] = {
d149 1
a149 1
	    (caddr_t)ch_patterns, sizeof(ch_patterns)/sizeof(ch_patterns[0]),
d693 1
a693 1
	struct chquirk *match;
d698 1
a698 1
	match = (struct chquirk *)scsi_inqmatch(inqbuf,
@


1.14
log
@Add new parameter to scsi_test_unit_ready(): retries number.
Use increased retries number and don't ignore SCSI_IGNORE_NOT_READY
when call scsi_test_unit_ready() for cd-rom, this makes system wait
if drive is loading media.
Tested by millert@@ and fgsch@@; some input and ok from krw@@.
Problem reported by The lord of the CD-writers
Igor Grabin <violent@@death.kiev.ua>.
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.13 2002/10/17 17:47:24 mickey Exp $	*/
a289 1
	case OCHIOGPICKER:
a290 1
	case OCHIOGPARAMS:
a291 1
	case OCHIOGSTATUS:
a300 1
	case OCHIOMOVE:
a304 1
	case OCHIOEXCHANGE:
a308 1
	case OCHIOPOSITION:
a312 1
	case OCHIOGPICKER:
a316 1
	case OCHIOSPICKER:
a324 1
	case OCHIOGPARAMS:
a334 1
	case OCHIOGSTATUS:
@


1.13
log
@renumber the CHIO* since they clash w/ the CDIO, keep the old ones as OCHIO, EOL set to post 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.12 2002/03/14 01:27:13 millert Exp $	*/
d208 1
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.11 2001/06/22 14:35:42 deraadt Exp $	*/
d289 1
d291 1
d293 1
d303 1
d308 1
d313 1
d318 1
d323 1
d332 1
d343 1
@


1.11
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.10 2001/03/15 20:08:43 mjacob Exp $	*/
d97 2
a98 2
int	chmatch __P((struct device *, void *, void *));
void	chattach __P((struct device *, struct device *, void *));
d118 7
a124 7
int	ch_move __P((struct ch_softc *, struct changer_move *));
int	ch_exchange __P((struct ch_softc *, struct changer_exchange *));
int	ch_position __P((struct ch_softc *, struct changer_position *));
int	ch_usergetelemstatus __P((struct ch_softc *, int, u_int8_t *));
int	ch_getelemstatus __P((struct ch_softc *, int, int, caddr_t, size_t));
int	ch_get_params __P((struct ch_softc *, int));
void	ch_get_quirks __P((struct ch_softc *, struct scsi_inquiry_data *));
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.11 2001/06/22 14:35:42 deraadt Exp $	*/
d97 2
a98 2
int	chmatch(struct device *, void *, void *);
void	chattach(struct device *, struct device *, void *);
d118 7
a124 7
int	ch_move(struct ch_softc *, struct changer_move *);
int	ch_exchange(struct ch_softc *, struct changer_exchange *);
int	ch_position(struct ch_softc *, struct changer_position *);
int	ch_usergetelemstatus(struct ch_softc *, int, u_int8_t *);
int	ch_getelemstatus(struct ch_softc *, int, int, caddr_t, size_t);
int	ch_get_params(struct ch_softc *, int);
void	ch_get_quirks(struct ch_softc *, struct scsi_inquiry_data *);
@


1.11.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.11.4.1 2002/06/11 03:32:13 art Exp $	*/
a288 1
	case OCHIOGPICKER:
a289 1
	case OCHIOGPARAMS:
a290 1
	case OCHIOGSTATUS:
a299 1
	case OCHIOMOVE:
a303 1
	case OCHIOEXCHANGE:
a307 1
	case OCHIOPOSITION:
a311 1
	case OCHIOGPICKER:
a315 1
	case OCHIOSPICKER:
a323 1
	case OCHIOGPARAMS:
a333 1
	case OCHIOGSTATUS:
@


1.11.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a207 1
	    TEST_READY_RETRIES_DEFAULT,
d289 1
d291 1
d293 1
d303 1
d308 1
d313 1
d318 1
d323 1
d332 1
d343 1
@


1.10
log
@Move status reads to chopen- there's no need to hang up the boot
process finding out the changer parameters.

Print out changer parameters only if they're changed from the last
read of changer parameters. This works for the first time, and for
99.9% of all other cases will be silent ever after. The only time
this will then be chatty afterwards is if you change something
within the changer (add a drive, etc.).
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.9 2000/04/08 19:19:33 csapuntz Exp $	*/
d89 1
a89 1
	int             sc_settledelay; /* delay for settle */
d422 1
a422 1
	     (1 << ce->ce_fdsttype)) == 0) ||
d424 1
a424 1
	     (1 << ce->ce_sdsttype)) == 0))
@


1.9
log
@

These days, attach can occur outside the tsleep-restricted world of
BSD autoconf.

Don't use POLL & NOSLEEP mode if attaching after autoconf
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.8 1998/03/22 20:19:59 tholo Exp $	*/
d89 1
a89 1
	int		sc_settledelay;	/* delay for settle */
d173 1
a173 1
	 * Find out our device's quirks.
a176 39
	/*
	 * Some changers require a long time to settle out, to do
	 * tape inventory, for instance.
	 */
	if (sc->sc_settledelay) {
		printf("%s: waiting %d seconds for changer to settle...\n",
		    sc->sc_dev.dv_xname, sc->sc_settledelay);
		delay(1000000 * sc->sc_settledelay);
	}

	/*
	 * Get information about the device.  Note we can't use
	 * interrupts yet.
	 */
	if (ch_get_params(sc, scsi_autoconf))
		printf("%s: offline\n", sc->sc_dev.dv_xname);
	else {
#define PLURAL(c)	(c) == 1 ? "" : "s"
		printf("%s: %d slot%s, %d drive%s, %d picker%s, %d portal%s\n",
		    sc->sc_dev.dv_xname,
		    sc->sc_counts[CHET_ST], PLURAL(sc->sc_counts[CHET_ST]),
		    sc->sc_counts[CHET_DT], PLURAL(sc->sc_counts[CHET_DT]),
		    sc->sc_counts[CHET_MT], PLURAL(sc->sc_counts[CHET_MT]),
		    sc->sc_counts[CHET_IE], PLURAL(sc->sc_counts[CHET_IE]));
#undef PLURAL
#ifdef CHANGER_DEBUG
		printf("%s: move mask: 0x%x 0x%x 0x%x 0x%x\n",
		    sc->sc_dev.dv_xname,
		    sc->sc_movemask[CHET_MT], sc->sc_movemask[CHET_ST],
		    sc->sc_movemask[CHET_IE], sc->sc_movemask[CHET_DT]);
		printf("%s: exchange mask: 0x%x 0x%x 0x%x 0x%x\n",
		    sc->sc_dev.dv_xname,
		    sc->sc_exchangemask[CHET_MT], sc->sc_exchangemask[CHET_ST],
		    sc->sc_exchangemask[CHET_IE], sc->sc_exchangemask[CHET_DT]);
#endif /* CHANGER_DEBUG */
	}

	/* Default the current picker. */
	sc->sc_picker = sc->sc_firsts[CHET_MT];
d186 2
a187 1
	int unit, error = 0;
d213 2
a214 1
	 * Make sure our parameters are up to date.
d216 6
a221 1
	if ((error = ch_get_params(sc, 0)) != 0)
d223 30
@


1.8
log
@Tell the SCSI driver that we expect data in from the changer device when we
request status; makes it work properly on NCR controllers (and probably on
some others as well).
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.7 1997/04/14 04:09:05 downsj Exp $	*/
d191 1
a191 1
	if (ch_get_params(sc, SCSI_AUTOCONF))
@


1.8.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.10 2001/03/15 20:08:43 mjacob Exp $	*/
d89 1
a89 1
	int             sc_settledelay; /* delay for settle */
d173 1
a173 1
	 * Store our our device's quirks.
d177 39
d225 1
a225 2
	int oldcounts[4];
	int i, unit, error = 0;
d251 1
a251 2
	 * Get information about the device. Save old information
	 * so we can decide whether to be verbose about new parameters.
d253 1
a253 6
	for (i = 0; i < 4; i++) {
		oldcounts[i] = sc->sc_counts[i];
	}
	error = ch_get_params(sc, scsi_autoconf);
	if (error) {
		printf("%s: offline\n", sc->sc_dev.dv_xname);
a254 30
	}

	for (i = 0; i < 4; i++) {
		if (oldcounts[i] != sc->sc_counts[i]) {
			break;
		}
	}
	if (i < 4) {
#define PLURAL(c)	(c) == 1 ? "" : "s"
		printf("%s: %d slot%s, %d drive%s, %d picker%s, %d portal%s\n",
		    sc->sc_dev.dv_xname,
		    sc->sc_counts[CHET_ST], PLURAL(sc->sc_counts[CHET_ST]),
		    sc->sc_counts[CHET_DT], PLURAL(sc->sc_counts[CHET_DT]),
		    sc->sc_counts[CHET_MT], PLURAL(sc->sc_counts[CHET_MT]),
		    sc->sc_counts[CHET_IE], PLURAL(sc->sc_counts[CHET_IE]));
#undef PLURAL
#ifdef CHANGER_DEBUG
		printf("%s: move mask: 0x%x 0x%x 0x%x 0x%x\n",
		    sc->sc_dev.dv_xname,
		    sc->sc_movemask[CHET_MT], sc->sc_movemask[CHET_ST],
		    sc->sc_movemask[CHET_IE], sc->sc_movemask[CHET_DT]);
		printf("%s: exchange mask: 0x%x 0x%x 0x%x 0x%x\n",
		    sc->sc_dev.dv_xname,
		    sc->sc_exchangemask[CHET_MT], sc->sc_exchangemask[CHET_ST],
		    sc->sc_exchangemask[CHET_IE], sc->sc_exchangemask[CHET_DT]);
#endif /* CHANGER_DEBUG */
	}

	/* Default the current picker. */
	sc->sc_picker = sc->sc_firsts[CHET_MT];
@


1.8.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.8.10.1 2001/05/14 22:44:59 niklas Exp $	*/
d89 1
a89 1
	int		sc_settledelay; /* delay for settle */
d422 1
a422 1
	    (1 << ce->ce_fdsttype)) == 0) ||
d424 1
a424 1
	    (1 << ce->ce_sdsttype)) == 0))
@


1.8.10.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 2
a98 2
int	chmatch(struct device *, void *, void *);
void	chattach(struct device *, struct device *, void *);
d118 7
a124 7
int	ch_move(struct ch_softc *, struct changer_move *);
int	ch_exchange(struct ch_softc *, struct changer_exchange *);
int	ch_position(struct ch_softc *, struct changer_position *);
int	ch_usergetelemstatus(struct ch_softc *, int, u_int8_t *);
int	ch_getelemstatus(struct ch_softc *, int, int, caddr_t, size_t);
int	ch_get_params(struct ch_softc *, int);
void	ch_get_quirks(struct ch_softc *, struct scsi_inquiry_data *);
@


1.8.10.4
log
@Sync the SMP branch with 3.3
@
text
@a207 1
	    TEST_READY_RETRIES_DEFAULT,
a288 1
	case OCHIOGPICKER:
a289 1
	case OCHIOGPARAMS:
a290 1
	case OCHIOGSTATUS:
a299 1
	case OCHIOMOVE:
a303 1
	case OCHIOEXCHANGE:
a307 1
	case OCHIOPOSITION:
a311 1
	case OCHIOGPICKER:
a315 1
	case OCHIOSPICKER:
a323 1
	case OCHIOGPARAMS:
a333 1
	case OCHIOGSTATUS:
@


1.8.10.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.8.10.4 2003/03/28 00:08:47 niklas Exp $	*/
d290 1
d292 1
d294 1
d304 1
d309 1
d314 1
d319 1
d324 1
d333 1
d344 1
@


1.8.10.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.8.10.5 2003/05/13 19:36:57 ho Exp $	*/
d108 1
a108 1
const struct scsi_inquiry_pattern ch_patterns[] = {
d149 1
a149 1
	    ch_patterns, sizeof(ch_patterns)/sizeof(ch_patterns[0]),
d693 1
a693 1
	const struct chquirk *match;
d698 1
a698 1
	match = (const struct chquirk *)scsi_inqmatch(inqbuf,
@


1.7
log
@Merge in various pieces of current NetBSD scsi code, including but not limited
to:

* New changer driver.
* Better optical support.
* Different `done' semantics.
* New quirks for SCSI QIC tape driver, SCSI floppy drives.
* Better support for SCSI-I devices.

Everybody needs to test this.
@
text
@d1 1
a1 1
/*	$OpenBSD: ch.c,v 1.6 1996/08/12 10:21:41 deraadt Exp $	*/
d604 1
a604 1
	    sizeof(cmd), (u_char *)data, datalen, CHRETRIES, 100000, NULL, 0));
@


1.6
log
@safe ioctl only
@
text
@d1 2
a2 2
/*	$OpenBSD: ch.c,v 1.4 1996/04/21 22:30:45 deraadt Exp $	*/
/*	$NetBSD: ch.c,v 1.21 1996/04/19 00:02:29 christos Exp $	*/
d5 1
a5 1
 * Copyright (c) 1996 Jason R. Thorpe <thorpej@@and.com>
d51 1
d85 6
d124 15
d173 15
d194 2
a195 1
		printf("%s: %d slot%s, %d drive%s, %d picker%s",
d197 5
a201 10
		    sc->sc_counts[CHET_ST], (sc->sc_counts[CHET_ST] > 1) ?
		    "s" : "",
		    sc->sc_counts[CHET_DT], (sc->sc_counts[CHET_DT] > 1) ?
		    "s" : "",
		    sc->sc_counts[CHET_MT], (sc->sc_counts[CHET_MT] > 1) ?
		    "s" : "");
		if (sc->sc_counts[CHET_IE])
			printf(", %d portal%s", sc->sc_counts[CHET_IE],
			    (sc->sc_counts[CHET_IE] > 1) ? "s" : "");
		printf("\n");
d286 15
d687 19
@


1.5
log
@no sys/cpu.h, fix bugs in ch
@
text
@d298 2
a299 1
		error = scsi_do_ioctl(sc->sc_link, dev, cmd, data, flags, p);
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: ch.c,v 1.3 1996/04/19 16:10:12 niklas Exp $	*/
/*	$NetBSD: ch.c,v 1.20 1996/04/03 00:25:39 thorpej Exp $	*/
d50 1
d212 3
a214 2
	if (error = scsi_test_unit_ready(sc->sc_link,
	    SCSI_IGNORE_NOT_READY|SCSI_IGNORE_MEDIA_CHANGE))
d220 1
a220 1
	if (error = ch_get_params(sc, 0))
a250 1
	caddr_t elemdata;
d479 2
a480 1
	if (error = ch_getelemstatus(sc, sc->sc_firsts[chet], 1, data, 1024))
d498 3
a500 2
	if (error = ch_getelemstatus(sc, sc->sc_firsts[chet],
	    sc->sc_counts[chet], data, size))
d593 2
a594 1
		printf("%s: could not sense element address page\n");
d622 2
a623 1
		printf("%s: could not sense capabilities page\n");
@


1.3
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ch.c,v 1.16 1996/03/05 00:15:09 thorpej Exp $	*/
d5 6
a10 1
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
d21 3
a23 2
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
d31 7
a37 11
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* 
 * Originally written by grefen@@?????
 * Based on scsi drivers by Julian Elischer (julian@@tfs.com)
a39 1
#include <sys/types.h>
d47 1
a47 1
#include <sys/chio.h>
d49 1
a53 1
#include <scsi/scsi_conf.h>
d55 15
a69 1
#define	CHRETRIES	2
d71 5
a75 2
#define CHMODE(z)	(minor(z) & 0x0f)
#define CHUNIT(z)	(minor(z) >> 4)
d77 4
a80 2
struct ch_softc {
	struct device sc_dev;
d82 1
a82 13
	struct scsi_link *sc_link;	/* all the inter level info */
	u_int16_t chmo;			/* Offset of first CHM */
	u_int16_t chms;			/* No. of CHM */
	u_int16_t slots;		/* No. of Storage Elements */
	u_int16_t sloto;		/* Offset of first SE */
	u_int16_t imexs;		/* No. of Import/Export Slots */
	u_int16_t imexo;		/* Offset of first IM/EX */
	u_int16_t drives;		/* No. of CTS */
	u_int16_t driveo;		/* Offset of first CTS */
	u_int16_t rot;			/* CHM can rotate */
	u_long  op_matrix;		/* possible operations */
	u_int16_t lsterr;		/* details of lasterror */
	u_char  stor;			/* posible Storage locations */
d85 4
a90 4
int	ch_getelem __P((struct ch_softc *, short *, int, int , char *, int));
int	ch_move __P((struct ch_softc *, short *, int, int , int , int ));
int	ch_position __P((struct ch_softc *, short *, int, int , int ));
int	ch_mode_sense __P((struct ch_softc *, int));
d92 2
a93 2
struct cfdriver chcd = {
	NULL, "ch", chmatch, chattach, DV_DULL, sizeof(struct ch_softc)
d96 2
a97 8
/*
 * This driver is so simple it uses all the default services
 */
struct scsi_device ch_switch = {
	NULL,
	NULL,
	NULL,
	NULL,
d102 1
a102 1
	 "",         "",                 ""},
d105 12
d128 1
d132 1
a132 5
/*
 * The routine called by the low level scsi routine when it discovers
 * a device suitable for this driver.
 */
void 
d137 1
a137 1
	struct ch_softc *ch = (void *)self;
d139 1
a139 1
	struct scsi_link *sc_link = sa->sa_sc_link;
d141 7
a147 1
	SC_DEBUG(sc_link, SDEV_DB2, ("chattach: "));
d150 2
a151 1
	 * Store information needed to contact our base driver
d153 26
a178 4
	ch->sc_link = sc_link;
	sc_link->device = &ch_switch;
	sc_link->device_softc = ch;
	sc_link->openings = 1;
d180 2
a181 12
	/*
	 * Use the subdriver to request information regarding
	 * the drive. We cannot use interrupts yet, so the
	 * request must specify this.
	 */
	printf("\n");
	printf("%s: ", ch->sc_dev.dv_xname);
	if (ch_mode_sense(ch, SCSI_AUTOCONF) != 0)
		printf("offline\n");
	else
		printf("%d slot(s), %d drive(s), %d arm(s), %d i/e-slot(s)\n",
		    ch->slots, ch->drives, ch->chms, ch->imexs);
d184 2
a185 5
/*
 *    open the device.
 */
int 
chopen(dev, flags, mode, p)
d187 1
a187 2
	int flags;
	int mode;
d190 2
a191 4
	int error = 0;
	int unit;
	struct ch_softc *ch;
	struct scsi_link *sc_link;
d194 3
a196 10
	if (unit >= chcd.cd_ndevs)
		return ENXIO;
	ch = chcd.cd_devs[unit];
	if (!ch)
		return ENXIO;

	sc_link = ch->sc_link;

	SC_DEBUG(sc_link, SDEV_DB1,
	    ("chopen: dev=0x%x (unit %d (of %d))\n", dev, unit, chcd.cd_ndevs));
d199 1
a199 1
	 * Only allow one at a time
d201 4
a204 4
	if (sc_link->flags & SDEV_OPEN) {
		printf("%s: already open\n", ch->sc_dev.dv_xname);
		return EBUSY;
	}
d207 3
a209 1
	 * Catch any unit attention errors.
d211 2
a212 2
	error = scsi_test_unit_ready(sc_link, SCSI_IGNORE_MEDIA_CHANGE);
	if (error)
a214 2
	sc_link->flags |= SDEV_OPEN;	/* unit attn are now errors */

d216 1
a216 1
	 * Make sure data is loaded
d218 1
a218 2
	if ((error = ch_mode_sense(ch, 0)) != 0) {
		printf("%s: offline\n", ch->sc_dev.dv_xname);
a219 1
	}
d221 1
a221 2
	SC_DEBUG(sc_link, SDEV_DB3, ("open complete\n"));
	return 0;
d223 3
a225 3
bad:
	sc_link->flags &= ~SDEV_OPEN;
	return error;
d228 2
a229 6
/*
 * close the device.. only called if we are the LAST
 * occurence of an open device
 */
int 
chclose(dev, flags, mode, p)
d231 1
a231 2
	int flags;
	int mode;
d234 1
a234 4
	struct ch_softc *ch = chcd.cd_devs[CHUNIT(dev)];

	SC_DEBUG(ch->sc_link, SDEV_DB1, ("closing\n"));
	ch->sc_link->flags &= ~SDEV_OPEN;
d236 2
a237 1
	return 0;
d240 2
a241 6
/*
 * Perform special action on behalf of the user
 * Knows about the internals of this device
 */
int 
chioctl(dev, cmd, arg, mode, p)
d244 2
a245 2
	caddr_t arg;
	int mode;
d248 45
a292 3
	struct ch_softc *ch = chcd.cd_devs[CHUNIT(dev)];
	struct scsi_link *sc_link = ch->sc_link;
	int flags;
d294 1
a294 4
	/*
	 * Find the device that the user is talking about
	 */
	flags = 0;		/* give error messages, act on errors etc. */
a295 35
	switch (cmd) {
	case CHIOOP: {
		struct chop *chop = (struct chop *) arg;
		SC_DEBUG(sc_link, SDEV_DB2, ("[chtape_chop: %x]\n",
		    chop->ch_op));

		switch (chop->ch_op) {
		case CHGETPARAM:
			chop->u.getparam.chmo = ch->chmo;
			chop->u.getparam.chms = ch->chms;
			chop->u.getparam.sloto = ch->sloto;
			chop->u.getparam.slots = ch->slots;
			chop->u.getparam.imexo = ch->imexo;
			chop->u.getparam.imexs = ch->imexs;
			chop->u.getparam.driveo = ch->driveo;
			chop->u.getparam.drives = ch->drives;
			chop->u.getparam.rot = ch->rot;
			chop->result = 0;
			return 0;
			break;
		case CHPOSITION:
			return ch_position(ch, &chop->result,
			    chop->u.position.chm, chop->u.position.to, flags);
		case CHMOVE:
			return ch_move(ch, &chop->result, chop->u.position.chm,
			    chop->u.move.from, chop->u.move.to, flags);
		case CHGETELEM:
			return ch_getelem(ch, &chop->result,
			    chop->u.get_elem_stat.type,
			    chop->u.get_elem_stat.from,
			    (char *) &chop->u.get_elem_stat.elem_data, flags);
		default:
			return EINVAL;
		}
	}
d297 2
a298 1
		return scsi_do_ioctl(sc_link, dev, cmd, arg, mode, p);
d300 2
a301 3
#ifdef DIAGNOSTIC
	panic("chioctl: impossible");
#endif
d304 4
a307 7
int 
ch_getelem(ch, stat, type, from, data, flags)
	struct ch_softc *ch;
	short *stat;
	int type, from;
	char *data;
	int flags;
d309 40
a348 21
	struct scsi_read_element_status scsi_cmd;
	char elbuf[32];
	int error;

	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = READ_ELEMENT_STATUS;
	scsi_cmd.byte2 = type;
	scsi_cmd.starting_element_addr[0] = (from >> 8) & 0xff;
	scsi_cmd.starting_element_addr[1] = from & 0xff;
	scsi_cmd.number_of_elements[1] = 1;
	scsi_cmd.allocation_length[2] = 32;

	error = scsi_scsi_cmd(ch->sc_link, (struct scsi_generic *) &scsi_cmd,
	    sizeof(scsi_cmd), (u_char *) elbuf, 32, CHRETRIES, 100000, NULL,
	    SCSI_DATA_IN | flags);
	if (error)
		*stat = ch->lsterr;
	else
		*stat = 0;
	bcopy(elbuf + 16, data, 16);
	return error;
d351 54
a404 25
int 
ch_move(ch, stat, chm, from, to, flags)
	struct ch_softc *ch;
	short *stat;
	int chm, from, to, flags;
{
	struct scsi_move_medium scsi_cmd;
	int error;

	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MOVE_MEDIUM;
	scsi_cmd.transport_element_address[0] = (chm >> 8) & 0xff;
	scsi_cmd.transport_element_address[1] = chm & 0xff;
	scsi_cmd.source_address[0] = (from >> 8) & 0xff;
	scsi_cmd.source_address[1] = from & 0xff;
	scsi_cmd.destination_address[0] = (to >> 8) & 0xff;
	scsi_cmd.destination_address[1] = to & 0xff;
	scsi_cmd.invert = (chm & CH_INVERT) ? 1 : 0;
	error = scsi_scsi_cmd(ch->sc_link, (struct scsi_generic *) &scsi_cmd,
	    sizeof(scsi_cmd), NULL, 0, CHRETRIES, 100000, NULL, flags);
	if (error)
		*stat = ch->lsterr;
	else
		*stat = 0;
	return error;
d407 36
a442 23
int 
ch_position(ch, stat, chm, to, flags)
	struct ch_softc *ch;
	short *stat;
	int chm, to, flags;
{
	struct scsi_position_to_element scsi_cmd;
	int error;

	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = POSITION_TO_ELEMENT;
	scsi_cmd.transport_element_address[0] = (chm >> 8) & 0xff;
	scsi_cmd.transport_element_address[1] = chm & 0xff;
	scsi_cmd.source_address[0] = (to >> 8) & 0xff;
	scsi_cmd.source_address[1] = to & 0xff;
	scsi_cmd.invert = (chm & CH_INVERT) ? 1 : 0;
	error = scsi_scsi_cmd(ch->sc_link, (struct scsi_generic *) &scsi_cmd,
	    sizeof(scsi_cmd), NULL, 0, CHRETRIES, 100000, NULL, flags);
	if (error)
		*stat = ch->lsterr;
	else
		*stat = 0;
	return error;
d446 3
a448 3
 * Get the scsi driver to send a full inquiry to the
 * device and use the results to fill out the global 
 * parameter structure.
d450 86
a535 4
int 
ch_mode_sense(ch, flags)
	struct ch_softc *ch;
	int flags;
d537 1
a537 8
	struct scsi_mode_sense scsi_cmd;
	u_char scsi_sense[128];	/* Can't use scsi_mode_sense_data because of
				 * missing block descriptor.
				 */
	u_char *b;
	int i, l;
	int error;
	struct scsi_link *sc_link = ch->sc_link;
d540 1
a540 1
	 * First check if we have it all loaded
d542 5
a546 2
	if (sc_link->flags & SDEV_MEDIA_LOADED)
		return 0;
d549 1
a549 1
	 * First do a mode sense 
d551 25
a575 5
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = MODE_SENSE;
	scsi_cmd.byte2 = SMS_DBD;
	scsi_cmd.page = 0x3f;	/* All Pages */
	scsi_cmd.length = sizeof(scsi_sense);
d578 1
a578 1
	 * Read in the pages
d580 9
a588 4
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *) &scsi_cmd,
			      sizeof(scsi_cmd), (u_char *) &scsi_sense,
			      sizeof(scsi_sense), CHRETRIES, 5000, NULL,
			      flags | SCSI_DATA_IN);
d590 2
a591 2
		printf("%s: could not mode sense\n", ch->sc_dev.dv_xname);
		return error;
d594 10
a603 3
	sc_link->flags |= SDEV_MEDIA_LOADED;
	l = scsi_sense[0] - 3;
	b = &scsi_sense[4];
d606 23
a628 39
	 * To avoid alignment problems
	 */
/* XXXX - FIX THIS FOR MSB */
#define p2copy(valp)	 (valp[1] | (valp[0]<<8)); valp+=2
#define p4copy(valp)	 (valp[3] | (valp[2]<<8) | (valp[1]<<16) | (valp[0]<<24)); valp+=4
#if 0
	printf("\nmode_sense %d\n", l);
	for (i = 0; i < l + 4; i++)
		printf("%x%c", scsi_sense[i], i % 8 == 7 ? '\n' : ':');
	printf("\n");
#endif
	for (i = 0; i < l;) {
		u_char pc = (*b++) & 0x3f;
		u_char pl = *b++;
		u_char *bb = b;
		switch (pc) {
		case 0x1d:
			ch->chmo = p2copy(bb);
			ch->chms = p2copy(bb);
			ch->sloto = p2copy(bb);
			ch->slots = p2copy(bb);
			ch->imexo = p2copy(bb);
			ch->imexs = p2copy(bb);
			ch->driveo = p2copy(bb);
			ch->drives = p2copy(bb);
			break;
		case 0x1e:
			ch->rot = *b & 0x1;
			break;
		case 0x1f:
			ch->stor = *b & 0xf;
			bb += 2;
			ch->stor = p4copy(bb);
			break;
		default:
			break;
		}
		b += pl;
		i += pl + 2;
d630 3
a632 5
	SC_DEBUG(sc_link, SDEV_DB2,
	    (" cht(%d-%d)slot(%d-%d)imex(%d-%d)cts(%d-%d) %s rotate\n",
	    ch->chmo, ch->chms, ch->sloto, ch->slots, ch->imexo, ch->imexs,
	    ch->driveo, ch->drives, ch->rot ? "can" : "can't"));
	return 0;
@


1.2
log
@Sync w/ NetBSD: scsi prototypes.
@
text
@d1 2
a2 1
/*	$NetBSD: ch.c,v 1.14 1995/01/16 21:31:38 mycroft Exp $	*/
d145 2
d148 1
a148 1
		printf(": offline\n");
d150 1
a150 1
		printf(": %d slot(s), %d drive(s), %d arm(s), %d i/e-slot(s)\n",
@


1.1
log
@Initial revision
@
text
@d51 1
d76 6
a81 2
int chmatch __P((struct device *, void *, void *));
void chattach __P((struct device *, struct device *, void *));
a106 1
	struct cfdata *cf = match;
d155 1
a155 1
chopen(dev)
d157 3
d162 1
a162 1
	int unit, mode;
a172 1
	mode = CHMODE(dev);
d189 2
a190 1
	if (error = scsi_test_unit_ready(sc_link, SCSI_IGNORE_MEDIA_CHANGE))
d198 1
a198 1
	if (error = ch_mode_sense(ch, 0)) {
d216 1
a216 1
chclose(dev)
d218 3
a243 1
	int number;
d281 1
a281 1
			    &chop->u.get_elem_stat.elem_data, flags);
d414 5
a418 3
	if (error = scsi_scsi_cmd(sc_link, (struct scsi_generic *) &scsi_cmd,
	    sizeof(scsi_cmd), (u_char *) &scsi_sense, sizeof(scsi_sense),
	    CHRETRIES, 5000, NULL, flags | SCSI_DATA_IN)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
