head	1.48;
access;
symbols
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.46.0.24
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.46.0.20
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.46.0.18
	OPENBSD_4_4_BASE:1.46
	OPENBSD_4_3:1.46.0.16
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.46.0.14
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.46.0.12
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.46.0.10
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.46.0.8
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.46.0.6
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.46.0.4
	OPENBSD_3_7_BASE:1.46
	OPENBSD_3_6:1.46.0.2
	OPENBSD_3_6_BASE:1.46
	SMP_SYNC_A:1.43
	SMP_SYNC_B:1.43
	OPENBSD_3_5:1.43.0.4
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.43.0.2
	OPENBSD_3_4_BASE:1.43
	UBC_SYNC_A:1.41
	OPENBSD_3_3:1.41.0.4
	OPENBSD_3_3_BASE:1.41
	OPENBSD_3_2:1.41.0.2
	OPENBSD_3_2_BASE:1.41
	OPENBSD_3_1:1.37.0.2
	OPENBSD_3_1_BASE:1.37
	UBC_SYNC_B:1.41
	UBC:1.30.0.2
	UBC_BASE:1.30
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_8:1.23.0.4
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	SMP:1.22.0.2
	SMP_BASE:1.22
	kame_19991208:1.21
	OPENBSD_2_6:1.21.0.4
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.21.0.2
	OPENBSD_2_5_BASE:1.21
	OPENBSD_2_4:1.20.0.4
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.20.0.2
	OPENBSD_2_3_BASE:1.20
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.48
date	2010.07.02.19.57.53;	author tedu;	state dead;
branches;
next	1.47;

1.47
date	2009.07.09.22.29.55;	author thib;	state Exp;
branches;
next	1.46;

1.46
date	2004.06.24.19.35.23;	author tholo;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.22.23.52.18;	author jfb;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.22.20.45.33;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2003.08.15.20.32.16;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.02.23.28.00;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.08.23.22.21.44;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2002.08.23.15.39.31;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2002.08.23.01.13.09;	author pvalchev;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.25.22.18.27;	author nordin;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.14.01.26.50;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2002.03.14.00.42.25;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.13.19.08.06;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.12.18.41.21;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.12.13.05.31;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.02.16.05.58;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.10.31.10.56.10;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.10.26.12.03.27;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.16.12.50.20;	author ho;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.05.21.26.42;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.26.05.30.18;	author marc;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.23.05.48.04;	author csapuntz;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.21.15.50.21;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2000.01.22.23.06.34;	author millert;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	99.02.10.00.16.12;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	98.03.23.07.12.39;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	98.03.23.06.54.10;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.11.30.21.40.30;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.11.14.22.59.20;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.11.13.18.35.28;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.11.06.22.15.51;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.11.06.05.58.05;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	97.10.06.20.19.33;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.10.06.15.05.45;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.07.28.09.53.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.06.17.11.11.11;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.01.15.23.00.00;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	96.08.25.12.19.57;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.02.20.20.31;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.05.02.13.07.19;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.18.21.21.45;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.01.06.17.28.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.15.15.39.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.04.05.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.22;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.22;	author deraadt;	state Exp;
branches;
next	;

1.22.2.1
date	2001.05.14.22.05.21;	author niklas;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2001.07.04.10.39.41;	author niklas;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.22.2.7;

1.22.2.7
date	2003.03.27.23.53.48;	author niklas;	state Exp;
branches;
next	1.22.2.8;

1.22.2.8
date	2003.06.07.11.00.37;	author ho;	state Exp;
branches;
next	1.22.2.9;

1.22.2.9
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	;

1.30.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2002.10.29.00.30.52;	author art;	state Exp;
branches;
next	;


desc
@@


1.48
log
@remove sunos compat files
@
text
@/*	$OpenBSD: sunos_misc.c,v 1.47 2009/07/09 22:29:55 thib Exp $	*/
/*	$NetBSD: sunos_misc.c,v 1.65 1996/04/22 01:44:31 christos Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)sunos_misc.c	8.1 (Berkeley) 6/18/93
 *
 *	Header: sunos_misc.c,v 1.16 93/04/07 02:46:27 torek Exp 
 */

/*
 * SunOS compatibility module.
 *
 * SunOS system calls that are implemented differently in BSD are
 * handled here.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/dirent.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/reboot.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/ptrace.h>
#include <sys/resource.h>
#include <sys/resourcevar.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/socket.h>
#include <sys/tty.h>
#include <sys/vnode.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/unistd.h>
#include <sys/syscallargs.h>
#include <sys/conf.h>
#include <sys/socketvar.h>
#include <sys/times.h>

#include <compat/sunos/sunos.h>
#include <compat/sunos/sunos_syscallargs.h>
#include <compat/sunos/sunos_util.h>
#include <compat/sunos/sunos_dirent.h>

#include <compat/common/compat_dir.h>

#include <netinet/in.h>

#include <miscfs/specfs/specdev.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>

#include <uvm/uvm_extern.h>

#ifdef sun3
# include <machine/machdep.h>	/* for prototype of reboot2() */
#endif

static int sunstatfs(struct statfs *, caddr_t);

int
sunos_sys_wait4(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_wait4_args *uap = v;
	if (SCARG(uap, pid) == 0)
		SCARG(uap, pid) = WAIT_ANY;
	return (sys_wait4(p, uap, retval));
}

int
sunos_sys_creat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_creat_args *uap = v;
	struct sys_open_args ouap;

	caddr_t sg = stackgap_init(p->p_emul);
	SUNOS_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&ouap, path) = SCARG(uap, path);
	SCARG(&ouap, flags) = O_WRONLY | O_CREAT | O_TRUNC;
	SCARG(&ouap, mode) = SCARG(uap, mode);

	return (sys_open(p, &ouap, retval));
}

int
sunos_sys_access(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_access_args *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);
	SUNOS_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return (sys_access(p, uap, retval));
}

int
sunos_sys_stat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_stat_args *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);
	SUNOS_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return (compat_43_sys_stat(p, uap, retval));
}

int
sunos_sys_lstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_lstat_args *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);
	SUNOS_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return (compat_43_sys_lstat(p, uap, retval));
}

int
sunos_sys_execve(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_execve_args /* {
		syscallarg(char *) path;
		syscallarg(char **) argv;
		syscallarg(char **) envp;
        } */ *uap = v;
	struct sys_execve_args ap;
	caddr_t sg;

	sg = stackgap_init(p->p_emul);
	SUNOS_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&ap, path) = SCARG(uap, path);
	SCARG(&ap, argp) = SCARG(uap, argp);
	SCARG(&ap, envp) = SCARG(uap, envp);

	return (sys_execve(p, &ap, retval));
}

int
sunos_sys_execv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_execv_args *uap = v;
	struct sys_execve_args ouap;

	caddr_t sg = stackgap_init(p->p_emul);
	SUNOS_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&ouap, path) = SCARG(uap, path);
	SCARG(&ouap, argp) = SCARG(uap, argp);
	SCARG(&ouap, envp) = NULL;

	return (sys_execve(p, &ouap, retval));
}

int
sunos_sys_unmount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_unmount_args *uap = v;
	struct sys_unmount_args ouap;

	SCARG(&ouap, path) = SCARG(uap, path);
	SCARG(&ouap, flags) = 0;

	return (sys_unmount(p, &ouap, retval));
}

/*
 * Conversion table for SunOS NFS mount flags.
 */
static struct {
	int	sun_flg;
	int	bsd_flg;
} sunnfs_flgtab[] = {
	{ SUNNFS_SOFT,		NFSMNT_SOFT },
	{ SUNNFS_WSIZE,		NFSMNT_WSIZE },
	{ SUNNFS_RSIZE,		NFSMNT_RSIZE },
	{ SUNNFS_TIMEO,		NFSMNT_TIMEO },
	{ SUNNFS_RETRANS,	NFSMNT_RETRANS },
	{ SUNNFS_HOSTNAME,	0 },			/* Ignored */
	{ SUNNFS_INT,		NFSMNT_INT },
	{ SUNNFS_NOAC,		0 },			/* Ignored */
	{ SUNNFS_ACREGMIN,	0 },			/* Ignored */
	{ SUNNFS_ACREGMAX,	0 },			/* Ignored */
	{ SUNNFS_ACDIRMIN,	0 },			/* Ignored */
	{ SUNNFS_ACDIRMAX,	0 },			/* Ignored */
	{ SUNNFS_SECURE,	0 },			/* Ignored */
	{ SUNNFS_NOCTO,		0 },			/* Ignored */
	{ SUNNFS_POSIX,		0 }			/* Ignored */
};

int
sunos_sys_mount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_mount_args *uap = v;
	int oflags = SCARG(uap, flags), nflags, error;
	char fsname[MFSNAMELEN];
	caddr_t sg = stackgap_init(p->p_emul);

	if (oflags & (SUNM_NOSUB | SUNM_SYS5))
		return (EINVAL);
	if ((oflags & SUNM_NEWTYPE) == 0)
		return (EINVAL);
	nflags = 0;
	if (oflags & SUNM_RDONLY)
		nflags |= MNT_RDONLY;
	if (oflags & SUNM_NOSUID)
		nflags |= MNT_NOSUID;
	if (oflags & SUNM_REMOUNT)
		nflags |= MNT_UPDATE;
	SCARG(uap, flags) = nflags;

	error = copyinstr((caddr_t)SCARG(uap, type), fsname,
	    sizeof fsname, (size_t *)0);
	if (error)
		return (error);

	if (strncmp(fsname, "4.2", sizeof fsname) == 0) {
		SCARG(uap, type) = stackgap_alloc(&sg, sizeof("ffs"));
		error = copyout("ffs", SCARG(uap, type), sizeof("ffs"));
		if (error)
			return (error);
	} else if (strncmp(fsname, "nfs", sizeof fsname) == 0) {
		struct sunos_nfs_args sna;
		struct sockaddr_in sain;
		struct nfs_args na;
		struct sockaddr sa;
		int n;

		error = copyin(SCARG(uap, data), &sna, sizeof sna);
		if (error)
			return (error);
		error = copyin(sna.addr, &sain, sizeof sain);
		if (error)
			return (error);
		bcopy(&sain, &sa, sizeof sa);
		sa.sa_len = sizeof(sain);
		SCARG(uap, data) = stackgap_alloc(&sg, sizeof(na));
		na.version = NFS_ARGSVERSION;
		na.addr = stackgap_alloc(&sg, sizeof(struct sockaddr));
		na.addrlen = sizeof(struct sockaddr);
		na.sotype = SOCK_DGRAM;
		na.proto = IPPROTO_UDP;
		na.fh = (void *)sna.fh;
		na.fhsize = NFSX_V2FH;
		na.flags = 0;
		n = sizeof(sunnfs_flgtab) / sizeof(sunnfs_flgtab[0]);
		while (--n >= 0)
			if (sna.flags & sunnfs_flgtab[n].sun_flg)
				na.flags |= sunnfs_flgtab[n].bsd_flg;
		na.wsize = sna.wsize;
		na.rsize = sna.rsize;
		if (na.flags & NFSMNT_RSIZE) {
			na.flags |= NFSMNT_READDIRSIZE;
			na.readdirsize = na.rsize;
		}
		na.timeo = sna.timeo;
		na.retrans = sna.retrans;
		na.hostname = sna.hostname;

		error = copyout(&sa, na.addr, sizeof sa);
		if (error)
			return (error);
		error = copyout(&na, SCARG(uap, data), sizeof na);
		if (error)
			return (error);
	}
	return (sys_mount(p, (struct sys_mount_args *)uap, retval));
}

#if defined(NFSCLIENT)
int
async_daemon(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_nfssvc_args ouap;

	SCARG(&ouap, flag) = NFSSVC_BIOD;
	SCARG(&ouap, argp) = NULL;

	return (sys_nfssvc(p, &ouap, retval));
}
#endif /* NFSCLIENT */

int
sunos_sys_sigpending(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_sigpending_args *uap = v;
	int mask = p->p_siglist & p->p_sigmask;

	return (copyout((caddr_t)&mask, (caddr_t)SCARG(uap, mask), sizeof(int)));
}

/*
 * Read Sun-style directory entries.  We suck them into kernel space so
 * that they can be massaged before being copied out to user code.  Like
 * SunOS, we squish out `empty' entries.
 *
 * This is quite ugly, but what do you expect from compatibility code?
 */
int sunos_readdir_callback(void *, struct dirent *, off_t);

struct sunos_readdir_callback_args {
	caddr_t outp;
	int     resid;
};

int
sunos_readdir_callback(arg, bdp, cookie)
	void *arg;
	struct dirent *bdp;
	off_t cookie;
{
	struct sunos_dirent idb;
	struct sunos_readdir_callback_args *cb = arg; 
	int sunos_reclen;
	int error;

	sunos_reclen = SUNOS_RECLEN(&idb, bdp->d_namlen);
	if (cb->resid < sunos_reclen)
		return (ENOMEM);
	
	idb.d_fileno = bdp->d_fileno;
	idb.d_off = cookie;
	idb.d_reclen = sunos_reclen;
	idb.d_namlen = bdp->d_namlen;
	strlcpy(idb.d_name, bdp->d_name, sizeof(idb.d_name));

	if ((error = copyout((caddr_t)&idb, cb->outp, sunos_reclen)))
		return (error);

	cb->outp += sunos_reclen;
	cb->resid -= sunos_reclen;

	return (0);
}

int
sunos_sys_getdents(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_getdents_args /* {
		syscallarg(int) fd;
		syscallarg(char *) buf;
		syscallarg(int) nbytes;
	} */ *uap = v;
	struct vnode *vp;
	struct file *fp;
	int error;
	struct sunos_readdir_callback_args args;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	vp = (struct vnode *)fp->f_data;
	/* SunOS returns ENOTDIR here, BSD would use EINVAL */
	if (vp->v_type != VDIR) {
		error = ENOTDIR;
		goto bad;
	}

	args.resid = SCARG(uap, nbytes);
	args.outp = (caddr_t)SCARG(uap, buf);

	error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    sunos_readdir_callback, &args);
bad:
	FRELE(fp);
	if (error)
		return (error);

	*retval = SCARG(uap, nbytes) - args.resid;

	return (0);
}


#define	SUNOS__MAP_NEW	0x80000000	/* if not, old mmap & cannot handle */

int
sunos_sys_mmap(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_mmap_args *uap = v;
	struct sys_mmap_args ouap;

	/*
	 * Verify the arguments.
	 */
	if (SCARG(uap, prot) & ~(PROT_READ|PROT_WRITE|PROT_EXEC))
		return (EINVAL);			/* XXX still needed? */

	if ((SCARG(uap, flags) & SUNOS__MAP_NEW) == 0)
		return (EINVAL);

	SCARG(&ouap, flags) = SCARG(uap, flags) & ~SUNOS__MAP_NEW;
	SCARG(&ouap, addr) = SCARG(uap, addr);

	if ((SCARG(&ouap, flags) & MAP_FIXED) == 0 &&
	    SCARG(&ouap, addr) != 0 &&
	    SCARG(&ouap, addr) < (void *)round_page((vaddr_t)p->p_vmspace->vm_daddr+MAXDSIZ))
		SCARG(&ouap, addr) = (void *)round_page((vaddr_t)p->p_vmspace->vm_daddr+MAXDSIZ);

	SCARG(&ouap, len) = SCARG(uap, len);
	SCARG(&ouap, prot) = SCARG(uap, prot);
	SCARG(&ouap, fd) = SCARG(uap, fd);
	SCARG(&ouap, pos) = SCARG(uap, pos);

	return (sys_mmap(p, &ouap, retval));
}

#define	MC_SYNC		1
#define	MC_LOCK		2
#define	MC_UNLOCK	3
#define	MC_ADVISE	4
#define	MC_LOCKAS	5
#define	MC_UNLOCKAS	6

int
sunos_sys_mctl(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sunos_sys_mctl_args *uap = v;

	switch (SCARG(uap, func)) {
	case MC_ADVISE:		/* ignore for now */
		return (0);
	case MC_SYNC:		/* translate to msync */
		return (sys_msync(p, uap, retval));
	default:
		return (EINVAL);
	}
}

int
sunos_sys_setsockopt(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_setsockopt_args *uap = v;
	struct file *fp;
	struct mbuf *m = NULL;
	int error;

	if ((error = getsock(p->p_fd, SCARG(uap, s), &fp)) != 0)
		return (error);
#define	SO_DONTLINGER (~SO_LINGER)
	if (SCARG(uap, name) == SO_DONTLINGER) {
		m = m_get(M_WAIT, MT_SOOPTS);
		mtod(m, struct linger *)->l_onoff = 0;
		m->m_len = sizeof(struct linger);
		error = (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
		    SO_LINGER, m));
		goto bad;
	}
	if (SCARG(uap, level) == IPPROTO_IP) {
#define		SUNOS_IP_MULTICAST_IF		2
#define		SUNOS_IP_MULTICAST_TTL		3
#define		SUNOS_IP_MULTICAST_LOOP		4
#define		SUNOS_IP_ADD_MEMBERSHIP		5
#define		SUNOS_IP_DROP_MEMBERSHIP	6
		static int ipoptxlat[] = {
			IP_MULTICAST_IF,
			IP_MULTICAST_TTL,
			IP_MULTICAST_LOOP,
			IP_ADD_MEMBERSHIP,
			IP_DROP_MEMBERSHIP
		};
		if (SCARG(uap, name) >= SUNOS_IP_MULTICAST_IF &&
		    SCARG(uap, name) <= SUNOS_IP_DROP_MEMBERSHIP) {
			SCARG(uap, name) =
			    ipoptxlat[SCARG(uap, name) - SUNOS_IP_MULTICAST_IF];
		}
	}
	if (SCARG(uap, valsize) > MLEN) {
		error = EINVAL;
		goto bad;
	}
	if (SCARG(uap, val)) {
		m = m_get(M_WAIT, MT_SOOPTS);
		error = copyin(SCARG(uap, val), mtod(m, caddr_t),
		    (u_int)SCARG(uap, valsize));
		if (error) {
			(void) m_free(m);
			goto bad;
		}
		m->m_len = SCARG(uap, valsize);
	}
	error = (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), m));
bad:
	FRELE(fp);
	return (error);
}

int
sunos_sys_fchroot(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sunos_sys_fchroot_args *uap = v;
	register struct filedesc *fdp = p->p_fd;
	register struct vnode *vp;
	struct file *fp;
	int error;

	if ((error = suser(p, 0)) != 0)
		return (error);
	if ((error = getvnode(fdp, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = (struct vnode *)fp->f_data;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_type != VDIR)
		error = ENOTDIR;
	else
		error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p);
	VOP_UNLOCK(vp, 0, p);
	if (error) {
		FRELE(fp);
		return (error);
	}
	vref(vp);
	if (fdp->fd_rdir != NULL)
		vrele(fdp->fd_rdir);
	fdp->fd_rdir = vp;
	FRELE(fp);
	return (0);
}

/*
 * XXX: This needs cleaning up.
 */
int
sunos_sys_auditsys(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	return 0;
}

int
sunos_sys_uname(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_uname_args *uap = v;
	struct sunos_utsname sut;
	extern char machine[];

	bzero(&sut, sizeof(sut));

	bcopy(ostype, sut.sysname, sizeof(sut.sysname) - 1);
	bcopy(hostname, sut.nodename, sizeof(sut.nodename));
	sut.nodename[sizeof(sut.nodename)-1] = '\0';
	bcopy(osrelease, sut.release, sizeof(sut.release) - 1);
	strlcpy(sut.version, "1", sizeof(sut.version));
	bcopy(machine, sut.machine, sizeof(sut.machine) - 1);

	return copyout((caddr_t)&sut, (caddr_t)SCARG(uap, name),
	    sizeof(struct sunos_utsname));
}

int
sunos_sys_setpgrp(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_setpgrp_args *uap = v;

	/*
	 * difference to our setpgid call is to include backwards
	 * compatibility to pre-setsid() binaries. Do setsid()
	 * instead of setpgid() in those cases where the process
	 * tries to create a new session the old way.
	 */
	if (!SCARG(uap, pgid) &&
	    (!SCARG(uap, pid) || SCARG(uap, pid) == p->p_pid))
		return sys_setsid(p, uap, retval);
	else
		return sys_setpgid(p, uap, retval);
}

int
sunos_sys_open(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_open_args *uap = v;
	int l, r;
	int noctty;
	int ret;
	
	caddr_t sg = stackgap_init(p->p_emul);
	SUNOS_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	/* convert mode into NetBSD mode */
	l = SCARG(uap, flags);
	noctty = l & 0x8000;
	r =	(l & (0x0001 | 0x0002 | 0x0008 | 0x0040 | 0x0200 | 0x0400 | 0x0800));
	r |=	((l & (0x0004 | 0x1000 | 0x4000)) ? O_NONBLOCK : 0);
	r |=	((l & 0x0080) ? O_SHLOCK : 0);
	r |=	((l & 0x0100) ? O_EXLOCK : 0);
	r |=	((l & 0x2000) ? O_SYNC : 0);

	SCARG(uap, flags) = r;
	ret = sys_open(p, (struct sys_open_args *)uap, retval);

	if (!ret && !noctty && SESS_LEADER(p) && !(p->p_flag & P_CONTROLT)) {
		struct filedesc *fdp = p->p_fd;
		struct file *fp;

		if ((fp = fd_getfile(fdp, *retval)) == NULL)
			return (EBADF);
		FREF(fp);
		/* ignore any error, just give it a try */
		if (fp->f_type == DTYPE_VNODE)
			(fp->f_ops->fo_ioctl)(fp, TIOCSCTTY, (caddr_t)0, p);
		FRELE(fp);
	}
	return ret;
}

#if defined (NFSSERVER)
int
sunos_sys_nfssvc(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#if 0
	struct sunos_sys_nfssvc_args *uap = v;
	struct emul *e = p->p_emul;
	struct sys_nfssvc_args outuap;
	struct sockaddr sa;
	int error;

	bzero(&outuap, sizeof outuap);
	SCARG(&outuap, fd) = SCARG(uap, fd);
	SCARG(&outuap, mskval) = STACKGAPBASE;
	SCARG(&outuap, msklen) = sizeof sa;
	SCARG(&outuap, mtchval) = SCARG(&outuap, mskval) + sizeof sa;
	SCARG(&outuap, mtchlen) = sizeof sa;

	bzero(&sa, sizeof sa);
	if (error = copyout(&sa, SCARG(&outuap, mskval), SCARG(&outuap, msklen)))
		return (error);
	if (error = copyout(&sa, SCARG(&outuap, mtchval), SCARG(&outuap, mtchlen)))
		return (error);

	return nfssvc(p, &outuap, retval);
#else
	return (ENOSYS);
#endif
}
#endif /* NFSSERVER */

int
sunos_sys_ustat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_ustat_args *uap = v;
	struct sunos_ustat us;
	int error;

	bzero(&us, sizeof us);

	/*
	 * XXX: should set f_tfree and f_tinode at least
	 * How do we translate dev -> fstat? (and then to sunos_ustat)
	 */

	if ((error = copyout(&us, SCARG(uap, buf), sizeof us)) != 0)
		return (error);
	return 0;
}

int
sunos_sys_quotactl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	return EINVAL;
}

int
sunos_sys_vhangup(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct session *sp = p->p_session;

	if (sp->s_ttyvp == 0)
		return 0;

	if (sp->s_ttyp && sp->s_ttyp->t_session == sp && sp->s_ttyp->t_pgrp)
		pgsignal(sp->s_ttyp->t_pgrp, SIGHUP, 1);

	(void) ttywait(sp->s_ttyp);
	if (sp->s_ttyvp)
		VOP_REVOKE(sp->s_ttyvp, REVOKEALL);
	if (sp->s_ttyvp)
		vrele(sp->s_ttyvp);
	sp->s_ttyvp = NULL;

	return 0;
}

static int
sunstatfs(sp, buf)
	struct statfs *sp;
	caddr_t buf;
{
	struct sunos_statfs ssfs;

	bzero(&ssfs, sizeof ssfs);
	ssfs.f_type = 0;
	ssfs.f_bsize = sp->f_bsize;
	ssfs.f_blocks = sp->f_blocks;
	ssfs.f_bfree = sp->f_bfree;
	ssfs.f_bavail = sp->f_bavail;
	ssfs.f_files = sp->f_files;
	ssfs.f_ffree = sp->f_ffree;
	ssfs.f_fsid = sp->f_fsid;
	return copyout((caddr_t)&ssfs, buf, sizeof ssfs);
}	

int
sunos_sys_statfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_statfs_args *uap = v;
	register struct mount *mp;
	register struct statfs *sp;
	int error;
	struct nameidata nd;

	caddr_t sg = stackgap_init(p->p_emul);
	SUNOS_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	mp = nd.ni_vp->v_mount;
	sp = &mp->mnt_stat;
	vrele(nd.ni_vp);
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
	return sunstatfs(sp, (caddr_t)SCARG(uap, buf));
}

int
sunos_sys_fstatfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_fstatfs_args *uap = v;
	struct file *fp;
	struct mount *mp;
	struct statfs *sp;
	int error;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	mp = ((struct vnode *)fp->f_data)->v_mount;
	sp = &mp->mnt_stat;
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp);
	if (error)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
	return sunstatfs(sp, (caddr_t)SCARG(uap, buf));
}

int
sunos_sys_exportfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	/*
	 * XXX: should perhaps translate into a mount(2)
	 * with MOUNT_EXPORT?
	 */
	return 0;
}

int
sunos_sys_mknod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_mknod_args *uap = v;

	caddr_t sg = stackgap_init(p->p_emul);
	SUNOS_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	if (S_ISFIFO(SCARG(uap, mode)))
		return sys_mkfifo(p, uap, retval);

	return sys_mknod(p, (struct sys_mknod_args *)uap, retval);
}

#define SUNOS_SC_ARG_MAX	1
#define SUNOS_SC_CHILD_MAX	2
#define SUNOS_SC_CLK_TCK	3
#define SUNOS_SC_NGROUPS_MAX	4
#define SUNOS_SC_OPEN_MAX	5
#define SUNOS_SC_JOB_CONTROL	6
#define SUNOS_SC_SAVED_IDS	7
#define SUNOS_SC_VERSION	8

int
sunos_sys_sysconf(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_sysconf_args *uap = v;
	extern int maxfiles;

	switch(SCARG(uap, name)) {
	case SUNOS_SC_ARG_MAX:
		*retval = ARG_MAX;
		break;
	case SUNOS_SC_CHILD_MAX:
		*retval = maxproc;
		break;
	case SUNOS_SC_CLK_TCK:
		*retval = 60;		/* should this be `hz', ie. 100? */
		break;
	case SUNOS_SC_NGROUPS_MAX:
		*retval = NGROUPS_MAX;
		break;
	case SUNOS_SC_OPEN_MAX:
		*retval = maxfiles;
		break;
	case SUNOS_SC_JOB_CONTROL:
		*retval = 1;
		break;
	case SUNOS_SC_SAVED_IDS:
#ifdef _POSIX_SAVED_IDS
		*retval = 1;
#else
		*retval = 0;
#endif
		break;
	case SUNOS_SC_VERSION:
		*retval = 198808;
		break;
	default:
		return EINVAL;
	}
	return 0;
}

#define SUNOS_RLIMIT_NOFILE	6	/* Other RLIMIT_* are the same */
#define SUNOS_RLIM_NLIMITS	7

int
sunos_sys_getrlimit(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_getrlimit_args *uap = v;

	if (SCARG(uap, which) >= SUNOS_RLIM_NLIMITS)
		return EINVAL;

	if (SCARG(uap, which) == SUNOS_RLIMIT_NOFILE)
		SCARG(uap, which) = RLIMIT_NOFILE;

	return compat_43_sys_getrlimit(p, uap, retval);
}

int
sunos_sys_setrlimit(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_getrlimit_args *uap = v;

	if (SCARG(uap, which) >= SUNOS_RLIM_NLIMITS)
		return EINVAL;

	if (SCARG(uap, which) == SUNOS_RLIMIT_NOFILE)
		SCARG(uap, which) = RLIMIT_NOFILE;

	return compat_43_sys_setrlimit(p, uap, retval);
}

#ifdef PTRACE

static int sreq2breq[] = {
	PT_TRACE_ME,    PT_READ_I,      PT_READ_D,      -1,
	PT_WRITE_I,     PT_WRITE_D,     -1,             PT_CONTINUE,
	PT_KILL,        -1,             PT_ATTACH,      PT_DETACH,
	PT_GETREGS,     PT_SETREGS,     PT_GETFPREGS,   PT_SETFPREGS
};
static int nreqs = sizeof(sreq2breq) / sizeof(sreq2breq[0]);

int
sunos_sys_ptrace(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_ptrace_args *uap = v;
	struct sys_ptrace_args pa;
	int req;

	req = SCARG(uap, req);

	if (req < 0 || req >= nreqs)
		return (EINVAL);

	req = sreq2breq[req];
	if (req == -1)
		return (EINVAL);

	SCARG(&pa, req) = req;
	SCARG(&pa, pid) = (pid_t)SCARG(uap, pid);
	SCARG(&pa, addr) = (caddr_t)SCARG(uap, addr);
	SCARG(&pa, data) = SCARG(uap, data);

	return sys_ptrace(p, &pa, retval);
}

#endif	/* PTRACE */

/*
 * SunOS reboot system call (for compatibility).
 * Sun lets you pass in a boot string which the PROM
 * saves and provides to the next boot program.
 */
static struct sunos_howto_conv {
	int sun_howto;
	int bsd_howto;
} sunos_howto_conv[] = {
	{ 0x001,	RB_ASKNAME },
	{ 0x002,	RB_SINGLE },
	{ 0x004,	RB_NOSYNC },
	{ 0x008,	RB_HALT },
	{ 0x080,	RB_DUMP },
	{ 0x000,	0 },
};
#define	SUNOS_RB_STRING	0x200

int
sunos_sys_reboot(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_reboot_args *uap = v;
	struct sunos_howto_conv *convp;
	int error, bsd_howto, sun_howto;

	if ((error = suser(p, 0)) != 0)
		return (error);

	/*
	 * Convert howto bits to BSD format.
	 */
	sun_howto = SCARG(uap, howto);
	bsd_howto = 0;
	convp = sunos_howto_conv;
	while (convp->sun_howto) {
		if (sun_howto &  convp->sun_howto)
			bsd_howto |= convp->bsd_howto;
		convp++;
	}

#ifdef sun3
	/*
	 * Sun RB_STRING (Get user supplied bootstring.)
	 * If the machine supports passing a string to the
	 * next booted kernel, add the machine name above
	 * and provide a reboot2() function (see sun3).
	 */
	if (sun_howto & SUNOS_RB_STRING) {
		char bs[128];

		error = copyinstr(SCARG(uap, bootstr), bs, sizeof(bs), 0);
		if (error)
			return error;

		return (reboot2(bsd_howto, bs));
	}
#endif	/* sun3 */

	boot(bsd_howto);
	return 0;
}

/*
 * Generalized interface signal handler, 4.3-compatible.
 */
/* ARGSUSED */
int
sunos_sys_sigvec(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sunos_sys_sigvec_args /* {
		syscallarg(int) signum;
		syscallarg(struct sigvec *) nsv;
		syscallarg(struct sigvec *) osv;
	} */ *uap = v;
	struct sigvec vec;
	register struct sigacts *ps = p->p_sigacts;
	register struct sigvec *sv;
	register int signum;
	int bit, error;

	signum = SCARG(uap, signum);
	if (signum <= 0 || signum >= NSIG ||
	    signum == SIGKILL || signum == SIGSTOP)
		return (EINVAL);
	sv = &vec;
	if (SCARG(uap, osv)) {
		*(sig_t *)&sv->sv_handler = ps->ps_sigact[signum];
		sv->sv_mask = ps->ps_catchmask[signum];
		bit = sigmask(signum);
		sv->sv_flags = 0;
		if ((ps->ps_sigonstack & bit) != 0)
			sv->sv_flags |= SV_ONSTACK;
		if ((ps->ps_sigintr & bit) != 0)
			sv->sv_flags |= SV_INTERRUPT;
		if ((ps->ps_sigreset & bit) != 0)
			sv->sv_flags |= SA_RESETHAND;
		sv->sv_mask &= ~bit;
		error = copyout((caddr_t)sv, (caddr_t)SCARG(uap, osv),
		    sizeof (vec));
		if (error)
			return (error);
	}
	if (SCARG(uap, nsv)) {
		error = copyin((caddr_t)SCARG(uap, nsv), (caddr_t)sv,
		    sizeof (vec));
		if (error)
			return (error);
		/*
		 * SunOS uses the mask 0x0004 as SV_RESETHAND
		 * meaning: `reset to SIG_DFL on delivery'.
		 * We support only the bits in: 0xF
		 * (those bits are the same as ours)
		 */
		if (sv->sv_flags & ~0xF)
			return (EINVAL);
		/* SunOS binaries have a user-mode trampoline. */
		sv->sv_flags |= SA_USERTRAMP;
		/* Convert sigvec:SV_INTERRUPT to sigaction:SA_RESTART */
		sv->sv_flags ^= SA_RESTART;	/* same bit, inverted */
		setsigvec(p, signum, (struct sigaction *)sv);
	}
	return (0);
}

int
sunos_sys_ostime(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_ostime_args /* {
		syscallarg(int) time;
	} */ *uap = v;
	struct timespec ts;
	int error;

	if ((error = suser(p, 0)) != 0)
		return (error);

	ts.tv_sec = SCARG(uap, time);
	ts.tv_nsec = 0;
	error = settime(&ts);
	return (error);
}

/*
 * This code is partly stolen from src/lib/libc/gen/times.c
 * XXX - CLK_TCK isn't declared in /sys, just in <time.h>, done here
 */

#define	CLK_TCK	100
#define	CONVTCK(r)	(r.tv_sec * CLK_TCK + r.tv_usec / (1000000 / CLK_TCK))

int
sunos_sys_otimes(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_otimes_args /* {
		syscallarg(struct tms *) tp;
	} */ *uap = v;
	struct tms tms;
	struct rusage ru, *rup;

	/* RUSAGE_SELF */
	calcru(p, &ru.ru_utime, &ru.ru_stime, NULL);
	tms.tms_utime = CONVTCK(ru.ru_utime);
	tms.tms_stime = CONVTCK(ru.ru_stime);

	/* RUSAGE_CHILDREN */
	rup = &p->p_stats->p_cru;
	tms.tms_cutime = CONVTCK(rup->ru_utime);
	tms.tms_cstime = CONVTCK(rup->ru_stime);

	return copyout(&tms, SCARG(uap, tp), sizeof(*(SCARG(uap, tp))));
}
@


1.47
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.45 2004/06/22 23:52:18 jfb Exp $	*/
@


1.46
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d606 1
a606 1
	VREF(vp);
@


1.45
log
@Replace a whole bunch of scary uses of strncpy() with strlcpy() and
use compat-specific MAXNAMLEN values where appropriate

ok millert@@, pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.44 2004/06/22 20:45:33 deraadt Exp $	*/
d1169 1
a1169 1
	struct timeval tv;
d1175 3
a1177 3
	tv.tv_sec = SCARG(uap, time);
	tv.tv_usec = 0;
	error = settime(&tv);
@


1.44
log
@do not bcopy wrong stuff there
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.43 2003/08/15 20:32:16 tedu Exp $	*/
d403 1
a403 1
	strlcpy(idb.d_name, bdp->d_name, SUNOS_MAXNAMLEN+1);
@


1.43
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.42 2003/06/02 23:28:00 millert Exp $	*/
d642 1
a642 1
	bcopy("1", sut.version, sizeof(sut.version) - 1);
@


1.42
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.41 2002/08/23 22:21:44 art Exp $	*/
d591 1
a591 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d1058 1
a1058 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d1172 1
a1172 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.41
log
@Just like getvnode, make getsock FREF the file so that we can't get away
with not refing it.

Eyeballed by lurene@@daemonkitty.net, fries@@, nordin@@ and fries@@
Some additional cleanups by nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.40 2002/08/23 15:39:31 art Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.40
log
@Cleanup change. Since almost all callers (except one) of getvnode did a FREF
on the returned file, do the FREF inside getvnode so that people can't
get away with avoiding FREF and FRELE.

Eyeballed by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.39 2002/08/23 01:13:09 pvalchev Exp $	*/
a533 1
	FREF(fp);
@


1.39
log
@FREF/FRELE cleanup/simplification, no functional changes; ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.38 2002/07/25 22:18:27 nordin Exp $	*/
d439 4
a442 2
	if (vp->v_type != VDIR)
		return (ENOTDIR);
a446 1
	FREF(fp);
d449 1
a600 1
	FREF(fp);
a867 1
	FREF(fp);
@


1.38
log
@Avoid time wrap at securelevel 2. ok millert@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.37 2002/03/14 20:31:31 mickey Exp $	*/
d540 1
a540 2
		FRELE(fp);
		return (error);
d562 2
a563 2
		FRELE(fp);
		return (EINVAL);
a569 1
			FRELE(fp);
d571 1
a571 1
			return (error);
d577 1
@


1.37
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.36 2002/03/14 01:26:50 millert Exp $	*/
a1171 4
	/*
	 * XXX - settime() is private to kern_time.c so we just lie.
	 */
#if 0
d1183 2
a1184 5
	settime(&tv);
	return(0);
#else
	return(EPERM);
#endif
@


1.36
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.35 2002/03/14 00:42:25 miod Exp $	*/
d639 1
a639 1
	extern char ostype[], machine[], osrelease[];
@


1.35
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.34 2002/02/13 19:08:06 art Exp $	*/
d110 1
a110 1
static int sunstatfs __P((struct statfs *, caddr_t));
d381 1
a381 1
int sunos_readdir_callback __P((void *, struct dirent *, off_t));
@


1.34
log
@More FREF/FRELE on relevant places. Now, only sys_mmap and a bunch of ioctl functions in sys/compat are left.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.33 2002/02/12 18:41:21 art Exp $	*/
d997 1
a997 7
/* for the m68k machines */
#ifndef PT_GETFPREGS
#define PT_GETFPREGS -1
#endif
#ifndef PT_SETFPREGS
#define PT_SETFPREGS -1
#endif
d1033 2
@


1.33
log
@More FREF/FRELE protection. This time all users of getvnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.32 2002/02/12 13:05:31 art Exp $	*/
d707 1
d711 1
@


1.32
log
@Fix all users of getsock to use FREF/FRELE properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.31 2002/02/02 16:05:58 art Exp $	*/
d444 6
a449 3
	
	if ((error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    sunos_readdir_callback, &args)) != 0)
d600 1
d607 2
a608 1
	if (error)
d610 1
d615 1
d859 1
a859 1
	register struct statfs *sp;
d866 4
a869 1
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
@


1.31
log
@Be more consistent about using fd_getfile where it matters.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.30 2001/11/06 19:53:17 miod Exp $	*/
d522 1
a522 1
	register struct sunos_sys_setsockopt_args *uap = v;
d529 1
d535 1
a535 1
		return (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
d537 2
d559 2
a560 1
	if (SCARG(uap, valsize) > MLEN)
d562 1
d568 1
d574 1
a574 1
	return (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
d576 2
@


1.30
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.29 2001/10/31 10:56:10 art Exp $	*/
d688 1
a688 1
		struct file *fp = fdp->fd_ofiles[*retval];
d690 2
@


1.30.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.30 2001/11/06 19:53:17 miod Exp $	*/
d110 1
a110 1
static int sunstatfs(struct statfs *, caddr_t);
d381 1
a381 1
int sunos_readdir_callback(void *, struct dirent *, off_t);
d444 3
a446 6

	FREF(fp);
	error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    sunos_readdir_callback, &args);
	FRELE(fp);
	if (error)
d522 1
a522 1
	struct sunos_sys_setsockopt_args *uap = v;
a528 1
	FREF(fp);
d534 1
a534 1
		error = (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
a535 2
		FRELE(fp);
		return (error);
d556 1
a556 2
	if (SCARG(uap, valsize) > MLEN) {
		FRELE(fp);
a557 1
	}
a562 1
			FRELE(fp);
d568 1
a568 1
	error = (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
a569 2
	FRELE(fp);
	return (error);
a588 1
	FREF(fp);
d595 1
a595 2
	if (error) {
		FRELE(fp);
a596 1
	}
a600 1
	FRELE(fp);
d624 1
a624 1
	extern char machine[];
d688 1
a688 1
		struct file *fp;
a689 3
		if ((fp = fd_getfile(fdp, *retval)) == NULL)
			return (EBADF);
		FREF(fp);
a692 1
		FRELE(fp);
d842 1
a842 1
	struct statfs *sp;
d849 1
a849 4
	FREF(fp);
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp);
	if (error)
d975 7
a981 1
#ifdef PTRACE
a1016 2

#endif	/* PTRACE */
@


1.30.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.30.2.1 2002/06/11 03:28:08 art Exp $	*/
d439 2
a440 4
	if (vp->v_type != VDIR) {
		error = ENOTDIR;
		goto bad;
	}
d445 1
a447 1
bad:
d532 1
d540 2
a541 1
		goto bad;
d563 2
a564 2
		error = EINVAL;
		goto bad;
d571 1
d573 1
a573 1
			goto bad;
a578 1
bad:
d600 1
d868 1
d1172 4
d1187 5
a1191 2
	error = settime(&tv);
	return (error);
@


1.29
log
@There is no need to fake handling of /dev/zero here. The vm system ultrix/ultrix_misc.c sunos/sunos_misc.c
does this automagically (and has done it for ages).
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.28 2001/10/26 12:03:27 art Exp $	*/
d104 1
a104 1
#include <vm/vm.h>
@


1.28
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.27 2001/05/16 12:50:20 ho Exp $	*/
d459 1
a459 1
	register struct proc *p;
d463 1
a463 1
	register struct sunos_sys_mmap_args *uap = v;
a464 3
	register struct filedesc *fdp;
	register struct file *fp;
	register struct vnode *vp;
a486 14

	/*
	 * Special case: if fd refers to /dev/zero, map as MAP_ANON.  (XXX)
	 * XXXART - this is probably completly unnecessary. mmap deals with
	 * XXXART - this just fine.
	 */
	fdp = p->p_fd;
	if ((fp = fd_getfile(fdp, SCARG(&ouap, fd))) != NULL &&		/*XXX*/
	    fp->f_type == DTYPE_VNODE &&				/*XXX*/
	    (vp = (struct vnode *)fp->f_data)->v_type == VCHR &&	/*XXX*/
	    iszerodev(vp->v_rdev)) {					/*XXX*/
		SCARG(&ouap, flags) |= MAP_ANON;
		SCARG(&ouap, fd) = -1;
	}
@


1.27
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.26 2001/05/05 21:26:42 art Exp $	*/
d493 2
d497 1
a497 2
	if ((unsigned)SCARG(&ouap, fd) < fdp->fd_nfiles &&		/*XXX*/
	    (fp = fdp->fd_ofiles[SCARG(&ouap, fd)]) != NULL &&		/*XXX*/
@


1.26
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.25 2001/01/26 05:30:18 marc Exp $	*/
a547 2
		if (m == NULL)
			return (ENOBUFS);
a575 2
		if (m == NULL)
			return (ENOBUFS);
@


1.25
log
@fix compile error by including compat_dir.h
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.24 2001/01/23 05:48:04 csapuntz Exp $	*/
d483 2
a484 2
	    SCARG(&ouap, addr) < (void *)round_page(p->p_vmspace->vm_daddr+MAXDSIZ))
		SCARG(&ouap, addr) = (void *)round_page(p->p_vmspace->vm_daddr+MAXDSIZ);
@


1.24
log
@

SunOS, IBCS2, Linux, and SVR4 all require translations of directory entries
from OpenBSD format to their respective native formats.

A lot of common code here for interfacing with OpenBSD VOP_READDIR. Most
of this code and logic has been moved to common/compat_dir.c

When reading a portion of the directory, the compatibility layer registers
a callback which is passed an OpenBSD-style dirent and the cookie/offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.23 2000/04/21 15:50:21 millert Exp $	*/
d93 2
@


1.23
log
@O_FYNC -> O_SYNC
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.22 2000/01/22 23:06:34 millert Exp $	*/
d379 37
a426 1
	struct dirent *bdp;
a427 4
	caddr_t inp, buf;	/* BSD-format */
	int len, reclen;	/* BSD-format */
	caddr_t outp;		/* Sun-format */
	int resid, sunos_reclen;/* Sun-format */
d429 2
a430 7
	struct uio auio;
	struct iovec aiov;
	struct sunos_dirent idb;
	off_t off;			/* true file offset */
	int buflen, error, eofflag;
	u_long *cookiebuf = NULL, *cookie;
	int ncookies;
d434 1
a434 2
	if ((fp->f_flag & FREAD) == 0)
		return (EBADF);
a435 1

a438 2
	if (SCARG(uap, nbytes) < sizeof(struct sunos_dirent))
		return (EINVAL);
d440 6
a445 26
	buflen = min(MAXBSIZE, SCARG(uap, nbytes));
	buf = malloc(buflen, M_TEMP, M_WAITOK);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	off = fp->f_offset;
again:
	aiov.iov_base = buf;
	aiov.iov_len = buflen;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_procp = p;
	auio.uio_resid = buflen;
	auio.uio_offset = off;
	/*
	 * First we read into the malloc'ed buffer, then
	 * we massage it into user space, one record at a time.
	 */
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, 
	    &ncookies, &cookiebuf);
	if (error)
		goto out;
	if (!cookiebuf) {
		error = EPERM;
		goto out;
	}
d447 1
a447 41
	inp = buf;
	outp = SCARG(uap, buf);
	resid = SCARG(uap, nbytes);
	if ((len = buflen - auio.uio_resid) == 0)
		goto eof;

	for (cookie = cookiebuf; len > 0; len -= reclen) {
		bdp = (struct dirent *)inp;
		reclen = bdp->d_reclen;
		if (reclen & 3)
			panic("sunos_getdents: bad reclen");
		if (bdp->d_fileno == 0) {
			inp += reclen;	/* it is a hole; squish it out */
			off = *cookie++;
			continue;
		}
		sunos_reclen = SUNOS_RECLEN(&idb, bdp->d_namlen);
		if (reclen > len || resid < sunos_reclen) {
			/* entry too big for buffer, so just stop */
			outp++;
			break;
		}
		off = *cookie++;	/* each entry points to next */
		/*
		 * Massage in place to make a Sun-shaped dirent (otherwise
		 * we have to worry about touching user memory outside of
		 * the copyout() call).
		 */
		idb.d_fileno = bdp->d_fileno;
		idb.d_off = off;
		idb.d_reclen = sunos_reclen;
		idb.d_namlen = bdp->d_namlen;
		strcpy(idb.d_name, bdp->d_name);
		if ((error = copyout((caddr_t)&idb, outp, sunos_reclen)) != 0)
			goto out;
		/* advance past this real entry */
		inp += reclen;
		/* advance output past Sun-shaped entry */
		outp += sunos_reclen;
		resid -= sunos_reclen;
	}
d449 1
a449 13
	/* if we squished out the whole block, try again */
	if (outp == SCARG(uap, buf))
		goto again;
	fp->f_offset = off;		/* update the vnode offset */

eof:
	*retval = SCARG(uap, nbytes) - resid;
out:
	VOP_UNLOCK(vp, 0, p);
	if (cookiebuf)
		free(cookiebuf, M_TEMP);
	free(buf, M_TEMP);
	return (error);
d451 1
@


1.22
log
@minor getdents cleanup:
o return ENOTDIR, not EINVAL for v_type != VDIR (SunOS behavior)
o return EINVAL for values of nbytes too small to hold a single dir entry
o remove a redundant check for error != 0
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.21 1999/02/10 00:16:12 niklas Exp $	*/
d747 1
a747 1
	r |=	((l & 0x2000) ? O_FSYNC : 0);
@


1.22.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.25 2001/01/26 05:30:18 marc Exp $	*/
a93 2
#include <compat/common/compat_dir.h>

a378 37
int sunos_readdir_callback __P((void *, struct dirent *, off_t));

struct sunos_readdir_callback_args {
	caddr_t outp;
	int     resid;
};

int
sunos_readdir_callback(arg, bdp, cookie)
	void *arg;
	struct dirent *bdp;
	off_t cookie;
{
	struct sunos_dirent idb;
	struct sunos_readdir_callback_args *cb = arg; 
	int sunos_reclen;
	int error;

	sunos_reclen = SUNOS_RECLEN(&idb, bdp->d_namlen);
	if (cb->resid < sunos_reclen)
		return (ENOMEM);
	
	idb.d_fileno = bdp->d_fileno;
	idb.d_off = cookie;
	idb.d_reclen = sunos_reclen;
	idb.d_namlen = bdp->d_namlen;
	strlcpy(idb.d_name, bdp->d_name, SUNOS_MAXNAMLEN+1);

	if ((error = copyout((caddr_t)&idb, cb->outp, sunos_reclen)))
		return (error);

	cb->outp += sunos_reclen;
	cb->resid -= sunos_reclen;

	return (0);
}

d390 1
d392 4
d397 7
a403 2
	int error;
	struct sunos_readdir_callback_args args;
d407 3
a410 1
	vp = (struct vnode *)fp->f_data;
d414 2
d417 26
a442 6
	args.resid = SCARG(uap, nbytes);
	args.outp = (caddr_t)SCARG(uap, buf);
	
	if ((error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    sunos_readdir_callback, &args)) != 0)
		return (error);
d444 41
a484 1
	*retval = SCARG(uap, nbytes) - args.resid;
d486 13
a498 1
	return (0);
a500 1

d747 1
a747 1
	r |=	((l & 0x2000) ? O_SYNC : 0);
@


1.22.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.22.2.1 2001/05/14 22:05:21 niklas Exp $	*/
d483 2
a484 2
	    SCARG(&ouap, addr) < (void *)round_page((vaddr_t)p->p_vmspace->vm_daddr+MAXDSIZ))
		SCARG(&ouap, addr) = (void *)round_page((vaddr_t)p->p_vmspace->vm_daddr+MAXDSIZ);
d548 2
d578 2
@


1.22.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.22.2.2 2001/07/04 10:39:41 niklas Exp $	*/
a492 2
	 * XXXART - this is probably completly unnecessary. mmap deals with
	 * XXXART - this just fine.
d495 2
a496 1
	if ((fp = fd_getfile(fdp, SCARG(&ouap, fd))) != NULL &&		/*XXX*/
@


1.22.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d104 1
a104 1
#include <uvm/uvm_extern.h>
d459 1
a459 1
	struct proc *p;
d463 1
a463 1
	struct sunos_sys_mmap_args *uap = v;
d465 3
d490 14
@


1.22.2.5
log
@Merge in trunk
@
text
@d444 3
a446 6

	FREF(fp);
	error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    sunos_readdir_callback, &args);
	FRELE(fp);
	if (error)
d522 1
a522 1
	struct sunos_sys_setsockopt_args *uap = v;
a528 1
	FREF(fp);
d534 1
a534 1
		error = (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
a535 2
		FRELE(fp);
		return (error);
d556 1
a556 2
	if (SCARG(uap, valsize) > MLEN) {
		FRELE(fp);
a557 1
	}
a562 1
			FRELE(fp);
d568 1
a568 1
	error = (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
a569 2
	FRELE(fp);
	return (error);
a588 1
	FREF(fp);
d595 1
a595 2
	if (error) {
		FRELE(fp);
a596 1
	}
a600 1
	FRELE(fp);
d688 1
a688 1
		struct file *fp;
a689 3
		if ((fp = fd_getfile(fdp, *retval)) == NULL)
			return (EBADF);
		FREF(fp);
a692 1
		FRELE(fp);
d842 1
a842 1
	struct statfs *sp;
d849 1
a849 4
	FREF(fp);
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp);
	if (error)
@


1.22.2.6
log
@Merge in -current from about a week ago
@
text
@d110 1
a110 1
static int sunstatfs(struct statfs *, caddr_t);
d381 1
a381 1
int sunos_readdir_callback(void *, struct dirent *, off_t);
d639 1
a639 1
	extern char machine[];
d997 7
a1003 1
#ifdef PTRACE
a1038 2

#endif	/* PTRACE */
@


1.22.2.7
log
@Sync the SMP branch with 3.3
@
text
@d439 2
a440 4
	if (vp->v_type != VDIR) {
		error = ENOTDIR;
		goto bad;
	}
d445 1
a447 1
bad:
d532 1
d540 2
a541 1
		goto bad;
d563 2
a564 2
		error = EINVAL;
		goto bad;
d571 1
d573 1
a573 1
			goto bad;
a578 1
bad:
d600 1
d868 1
d1172 4
d1187 5
a1191 2
	error = settime(&tv);
	return (error);
@


1.22.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.22.2.7 2003/03/27 23:53:48 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.22.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d591 1
a591 1
	if ((error = suser(p, 0)) != 0)
d1058 1
a1058 1
	if ((error = suser(p, 0)) != 0)
d1172 1
a1172 1
	if ((error = suser(p, 0)) != 0)
@


1.21
log
@Correct directory entry reads, big directories lost entries as it were.
Also, fix the NCR SVR4 rdebug syscall emulation.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.20 1998/03/23 07:12:39 millert Exp $	*/
d385 5
a389 1
	struct sunos_sys_getdents_args *uap = v;
a406 1

a408 1

d411 4
a414 1
	if (vp->v_type != VDIR)	/* XXX  vnode readdir op should do this */
d439 1
a439 2
	
	if (!error && !cookiebuf) {
@


1.20
log
@Emulated version of SunOS ostime(2) wass totally wrong.  For now
we will just return EPERM.  Correct code is #if 0'd out as it needs
to call settime() which is static to kern_time.c (and it's not
clear that we really want to be setting the clock from an emulated
program anyway).
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.19 1998/03/23 06:54:10 millert Exp $	*/
d450 1
a450 2
			panic("sunos_getdents");
		off = *cookie++;	/* each entry points to next */
d453 1
d462 1
@


1.19
log
@Emulate otimes(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.18 1997/11/30 21:40:30 deraadt Exp $	*/
d1210 1
a1210 1
sunos_sys_stime(p, v, retval)
d1215 6
a1220 2
	struct sunos_sys_stime_args /* {
		time_t		*tp;
d1223 1
d1225 10
a1234 3
	*retval = 0;
	microtime(&tv);
	return copyout(&tv.tv_sec, SCARG(uap, tp), sizeof(*(SCARG(uap, tp))));
@


1.18
log
@use stackgap macros
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.17 1997/11/14 22:59:20 deraadt Exp $	*/
d87 1
d1223 33
@


1.17
log
@mmap() takes void *
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.16 1997/11/13 18:35:28 deraadt Exp $	*/
a267 1
	struct emul *e = p->p_emul;
d270 1
d291 1
a291 1
		SCARG(uap, type) = STACKGAPBASE;
d310 1
a310 1
		SCARG(uap, data) = STACKGAPBASE;
d312 1
a312 2
		na.addr = (struct sockaddr *)
			  ((int)SCARG(uap, data) + sizeof na);
@


1.16
log
@make msync() have 3 args
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.15 1997/11/06 22:15:51 millert Exp $	*/
d524 2
a525 2
	    SCARG(&ouap, addr) < (caddr_t)round_page(p->p_vmspace->vm_daddr+MAXDSIZ))
		SCARG(&ouap, addr) = (caddr_t)round_page(p->p_vmspace->vm_daddr+MAXDSIZ);
@


1.15
log
@Use lite2 vfs interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.14 1997/11/06 05:58:05 csapuntz Exp $	*/
a219 17
}

int
sunos_sys_omsync(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_omsync_args *uap = v;
	struct sys_msync_args ouap;

	if (SCARG(uap, flags))
		return (EINVAL);
	SCARG(&ouap, addr) = SCARG(uap, addr);
	SCARG(&ouap, len) = SCARG(uap, len);

	return (sys_msync(p, &ouap, retval));
@


1.14
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.13 1997/10/06 20:19:33 deraadt Exp $	*/
d431 1
a431 1
	VOP_LOCK(vp);
d506 1
a506 1
	VOP_UNLOCK(vp);
d667 1
a667 1
	VOP_LOCK(vp);
d672 1
a672 1
	VOP_UNLOCK(vp);
d857 1
a857 1
		vgoneall(sp->s_ttyvp);
@


1.13
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.11 1997/07/28 09:53:12 deraadt Exp $	*/
d415 1
a415 1
	u_long *cookiebuf, *cookie;
a430 2
	ncookies = buflen / 16;
	cookiebuf = malloc(ncookies * sizeof(*cookiebuf), M_TEMP, M_WAITOK);
d447 2
a448 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, cookiebuf,
	    ncookies);
d451 5
d507 2
a508 1
	free(cookiebuf, M_TEMP);
@


1.12
log
@VFS Lite2 Changes
@
text
@d415 1
a415 1
	u_long *cookiebuf = NULL, *cookie;
d431 2
d449 2
a450 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, 
	    &ncookies, &cookiebuf);
a452 5
	
	if (!error && !cookiebuf) {
		error = EPERM;
		goto out;
	}
d504 1
a504 2
	if (cookiebuf)
		free(cookiebuf, M_TEMP);
@


1.11
log
@stime; christos
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.10 1997/06/17 11:11:11 deraadt Exp $	*/
d415 1
a415 1
	u_long *cookiebuf, *cookie;
a430 2
	ncookies = buflen / 16;
	cookiebuf = malloc(ncookies * sizeof(*cookiebuf), M_TEMP, M_WAITOK);
d447 2
a448 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, cookiebuf,
	    ncookies);
d451 5
d507 2
a508 1
	free(cookiebuf, M_TEMP);
@


1.10
log
@careful with stackgap handling in execve()
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.9 1997/01/15 23:00:00 kstailey Exp $	*/
d1220 16
@


1.9
log
@add prototype of reboot2() via machdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.8 1996/08/25 12:19:57 deraadt Exp $	*/
d185 7
a191 1
	struct sunos_sys_execve_args *uap = v;
d193 1
a193 1
	caddr_t sg = stackgap_init(p->p_emul);
d196 5
a200 1
	return (sys_execve(p, (struct sys_execve_args *)&uap, retval));
@


1.8
log
@route execve via compat filename translation
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.7 1996/08/02 20:20:31 niklas Exp $	*/
d102 4
@


1.7
log
@Make emulations use our native poll(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: sunos_misc.c,v 1.5 1996/04/18 21:21:45 niklas Exp $	*/
d173 14
@


1.6
log
@no sys/cpu.h
@
text
@d104 1
a104 2
static void sunos_pollscan __P((struct proc *, struct sunos_pollfd *, 
				int, register_t *));
a1061 128
}

static void
sunos_pollscan(p, pl, nfd, retval)
	struct proc *p;
	struct sunos_pollfd *pl;
	int nfd;
	register_t *retval;
{
	register struct filedesc *fdp = p->p_fd;
	register int msk, i;
	struct file *fp;
	int n = 0;
	static int flag[3] = { FREAD, FWRITE, 0 };
	static int pflag[3] = { SUNOS_POLLIN|SUNOS_POLLRDNORM, 
				SUNOS_POLLOUT, SUNOS_POLLERR };

	/* 
	 * XXX: We need to implement the rest of the flags.
	 */
	for (i = 0; i < nfd; i++) {
		fp = fdp->fd_ofiles[pl[i].fd];
		if (fp == NULL) {
			if (pl[i].events & SUNOS_POLLNVAL) {
				pl[i].revents |= SUNOS_POLLNVAL;
				n++;
			}
			continue;
		}
		for (msk = 0; msk < 3; msk++) {
			if (pl[i].events & pflag[msk]) {
				if ((*fp->f_ops->fo_select)(fp, flag[msk], p)) {
					pl[i].revents |= 
					    pflag[msk] & pl[i].events;
					n++;
				}
			}
		}
	}
	*retval = n;
}


/*
 * We are using the same mechanism as select only we encode/decode args
 * differently.
 */
int
sunos_sys_poll(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sunos_sys_poll_args *uap = v;
	int i, s;
	int error, error2;
	size_t sz = sizeof(struct sunos_pollfd) * SCARG(uap, nfds);
	struct sunos_pollfd *pl;
	int msec = SCARG(uap, timeout);
	struct timeval atv;
	int timo;
	int ncoll;
	extern int nselcoll, selwait;

	pl = (struct sunos_pollfd *) malloc(sz, M_TEMP, M_WAITOK);

	if ((error = copyin(SCARG(uap, fds), pl, sz)) != 0)
		goto bad;

	for (i = 0; i < SCARG(uap, nfds); i++)
		pl[i].revents = 0;

	if (msec != -1) {
		atv.tv_sec = msec / 1000;
		atv.tv_usec = (msec - (atv.tv_sec * 1000)) * 1000;

		if (itimerfix(&atv)) {
			error = EINVAL;
			goto done;
		}
		s = splclock();
		timeradd(&atv, &time, &atv);
		timo = hzto(&atv);
		/*
		 * Avoid inadvertently sleeping forever.
		 */
		if (timo == 0)
			timo = 1;
		splx(s);
	} else
		timo = 0;

retry:
	ncoll = nselcoll;
	p->p_flag |= P_SELECT;
	sunos_pollscan(p, pl, SCARG(uap, nfds), retval);
	if (*retval)
		goto done;
	s = splhigh();
	if (timo && timercmp(&time, &atv, >=)) {
		splx(s);
		goto done;
	}
	if ((p->p_flag & P_SELECT) == 0 || nselcoll != ncoll) {
		splx(s);
		goto retry;
	}
	p->p_flag &= ~P_SELECT;
	error = tsleep((caddr_t)&selwait, PSOCK | PCATCH, "sunos_poll", timo);
	splx(s);
	if (error == 0)
		goto retry;

done:
	p->p_flag &= ~P_SELECT;
	/* poll is not restarted after signals... */
	if (error == ERESTART)
		error = EINTR;
	if (error == EWOULDBLOCK)
		error = 0;

	if ((error2 = copyout(pl, SCARG(uap, fds), sz)) != 0)
		error = error2;

bad:
	free((char *) pl, M_TEMP);

	return (error);
@


1.5
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: sunos_misc.c,v 1.64 1996/03/14 19:33:47 christos Exp $	*/
a86 1
#include <sys/cpu.h>
@


1.4
log
@from netbsd:
Implement vhangup(); more or less as suggested in PR#1560 (matthew green).
I'm vrele'ing s_ttyvp here too, so sys_exit() won't have to go over it again.
@
text
@d1 2
a2 1
/*	$NetBSD: sunos_misc.c,v 1.60 1996/01/05 16:53:14 pk Exp $	*/
d61 1
a61 1
#include <sys/dir.h>
d85 3
d99 1
a99 1
#include <nfs/nfsv2.h>
d104 3
d228 24
d276 3
a278 2
	if (error = copyinstr((caddr_t)SCARG(uap, type), fsname,
	    sizeof fsname, (size_t *)0))
d283 2
a284 1
		if (error = copyout("ffs", SCARG(uap, type), sizeof("ffs")))
d291 1
d293 2
a294 1
		if (error = copyin(SCARG(uap, data), &sna, sizeof sna))
d296 2
a297 1
		if (error = copyin(sna.addr, &sain, sizeof sain))
d302 3
a304 1
		na.addr = (struct sockaddr *)((int)SCARG(uap, data) + sizeof na);
d308 7
a314 2
		na.fh = (nfsv2fh_t *)sna.fh;
		na.flags = sna.flags;
d317 4
d325 2
a326 1
		if (error = copyout(&sa, na.addr, sizeof sa))
d328 2
a329 1
		if (error = copyout(&na, SCARG(uap, data), sizeof na))
d571 1
a571 1
	if (error = getsock(p->p_fd, SCARG(uap, s), &fp))
d608 3
a610 2
		if (error = copyin(SCARG(uap, val), mtod(m, caddr_t),
		    (u_int)SCARG(uap, valsize))) {
d752 1
a758 1
#if 0
d796 1
a796 1
	if (error = copyout(&us, SCARG(uap, buf), sizeof us))
a806 1
	struct sunos_sys_quotactl_args *uap = v;
a816 1
	struct sunos_vhangup_args *uap = v;
d835 1
a835 1
static
d870 1
a870 1
	if (error = namei(&nd))
d875 1
a875 1
	if (error = VFS_STATFS(mp, sp, p))
d893 1
a893 1
	if (error = getvnode(p->p_fd, SCARG(uap, fd), &fp))
d897 1
a897 1
	if (error = VFS_STATFS(mp, sp, p))
a908 2
	struct sunos_sys_exportfs_args *uap = v;

d1039 1
a1124 1
	u_int ni;
d1130 1
a1130 1
	if (error = copyin(SCARG(uap, fds), pl, sz))
d1185 1
a1185 1
	if (error2 = copyout(pl, SCARG(uap, fds), sz))
d1222 1
a1222 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d1255 2
a1256 1
	return (boot(bsd_howto));
d1297 3
a1299 2
		if (error = copyout((caddr_t)sv, (caddr_t)SCARG(uap, osv),
		    sizeof (vec)))
d1303 3
a1305 2
		if (error = copyin((caddr_t)SCARG(uap, nsv), (caddr_t)sv,
		    sizeof (vec)))
@


1.3
log
@from ghudson; system now provides cookies, no need to fake them
@
text
@d1 1
a1 1
/*	$NetBSD: sunos_misc.c,v 1.59 1995/12/14 18:44:44 ghudson Exp $	*/
d77 1
d768 15
@


1.2
log
@ufs ==> ffs
@
text
@d1 1
a1 1
/*	$NetBSD: sunos_misc.c,v 1.56.2.1 1995/10/13 19:57:44 pk Exp $	*/
d375 2
a376 24
	if (error) {
		off_t coff;

		if (error != EINVAL)
			goto out;
		error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, 0, 0);
		if (error)
			goto out;

		/* Fake the cookies */
		error = 0;
		inp = buf;
		len = buflen - auio.uio_resid;
		coff = off;
		cookie = cookiebuf;
		for (; len > 0; len -= reclen) {
			reclen = ((struct dirent *)inp)->d_reclen;
			if (reclen & 3)
				panic("sunos_getdents");
			coff += reclen;		/* each entry points to next */
			*cookie++ = coff;
			inp += reclen;
		}
	}
@


1.1
log
@Initial revision
@
text
@d250 1
a250 1
		if (error = copyout("ufs", SCARG(uap, type), sizeof("ufs")))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
