head	1.12;
access;
symbols
	OPENBSD_4_7:1.11.0.14
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.16
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.12
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.10.0.4
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.12
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.10
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.5.0.8
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.14
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2010.06.30.20.39.28;	author tedu;	state dead;
branches;
next	1.11;

1.11
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.07.03.20.13.59;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.23.15.39.31;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.50;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.22.20.37.45;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.12.18.41.20;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.04.15.47.55;	author ericj;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	96.10.30.16.37.20;	author niklas;	state Exp;
branches
	1.4.14.1;
next	1.3;

1.3
date	96.08.23.11.48.48;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.21.21.41;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.20;	author deraadt;	state Exp;
branches;
next	;

1.4.14.1
date	2001.05.14.22.05.10;	author niklas;	state Exp;
branches;
next	1.4.14.2;

1.4.14.2
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.4.14.3;

1.4.14.3
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.4.14.4;

1.4.14.4
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	;

1.5.8.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2002.10.29.00.30.51;	author art;	state Exp;
branches;
next	;


desc
@@


1.12
log
@delete osf1 compat files
@
text
@/* 	$OpenBSD: osf1_mount.c,v 1.11 2006/03/05 21:48:56 miod Exp $ */
/*	$NetBSD: osf1_mount.c,v 1.14 1999/05/05 01:51:34 cgd Exp $	*/

/*
 * Copyright (c) 1999 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/kernel.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/syscallargs.h>

#include <compat/osf1/osf1.h>
#include <compat/osf1/osf1_syscallargs.h>
#include <compat/osf1/osf1_util.h>
#include <compat/osf1/osf1_cvt.h>

#include <net/if.h>
#include <netinet/in.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>
#include <nfs/nfsmount.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/ufsmount.h>

#include <machine/vmparam.h>

#define	OSF1_MNT_WAIT		0x1
#define	OSF1_MNT_NOWAIT		0x2

#define	OSF1_MNT_FORCE		0x1
#define	OSF1_MNT_NOFORCE	0x2

/* acceptable flags for various calls */
#define	OSF1_GETFSSTAT_FLAGS	(OSF1_MNT_WAIT|OSF1_MNT_NOWAIT)
#define	OSF1_MOUNT_FLAGS	0xffffffff			/* XXX */
#define	OSF1_UNMOUNT_FLAGS	(OSF1_MNT_FORCE|OSF1_MNT_NOFORCE)


static int	osf1_mount_mfs(struct proc *,
		    struct osf1_sys_mount_args *, struct sys_mount_args *);
static int	osf1_mount_nfs(struct proc *,
		    struct osf1_sys_mount_args *, struct sys_mount_args *);

int
osf1_sys_fstatfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_fstatfs_args *uap = v;
	struct file *fp;
	struct mount *mp;
	struct statfs *sp;
	struct osf1_statfs osfs;
	int error;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)))
		return (error);
	mp = ((struct vnode *)fp->f_data)->v_mount;
	sp = &mp->mnt_stat;
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp);
	if (error)
		goto out;
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
	osf1_cvt_statfs_from_native(sp, &osfs);
	error = copyout(&osfs, SCARG(uap, buf), min(sizeof osfs,
	    SCARG(uap, len)));
 out:
	return (error);
}

int
osf1_sys_getfsstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_getfsstat_args *uap = v;
	struct mount *mp, *nmp;
	struct statfs *sp;
	struct osf1_statfs osfs;
	caddr_t osf_sfsp;
	long count, maxcount, error;

	if (SCARG(uap, flags) & ~OSF1_GETFSSTAT_FLAGS)
		return (EINVAL);

	maxcount = SCARG(uap, bufsize) / sizeof(struct osf1_statfs);
	osf_sfsp = (caddr_t)SCARG(uap, buf);
	count = 0;
	for (mp = CIRCLEQ_FIRST(&mountlist); mp != CIRCLEQ_END(&mountlist);
	    mp = nmp) {
		nmp = CIRCLEQ_NEXT(mp, mnt_list);
		if (osf_sfsp && count < maxcount) {
			sp = &mp->mnt_stat;
			/*
			 * If OSF1_MNT_NOWAIT is specified, do not refresh the
			 * fsstat cache.  OSF1_MNT_WAIT overrides
			 * OSF1_MNT_NOWAIT.
			 */
			if (((SCARG(uap, flags) & OSF1_MNT_NOWAIT) == 0 ||
			    (SCARG(uap, flags) & OSF1_MNT_WAIT)) &&
			    (error = VFS_STATFS(mp, sp, p)))
				continue;
			sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
			osf1_cvt_statfs_from_native(sp, &osfs);
			if ((error = copyout(&osfs, osf_sfsp,
			    sizeof (struct osf1_statfs))))
				return (error);
			osf_sfsp += sizeof (struct osf1_statfs);
		}
		count++;
	}
	if (osf_sfsp && count > maxcount)
		*retval = maxcount;
	else
		*retval = count;
	return (0);
}

int
osf1_sys_mount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_mount_args *uap = v;
	struct sys_mount_args a;
	int error;

	SCARG(&a, path) = SCARG(uap, path);

	if (SCARG(uap, flags) & ~OSF1_MOUNT_FLAGS)
		return (EINVAL);
	SCARG(&a, flags) = SCARG(uap, flags);		/* XXX - xlate */

	switch (SCARG(uap, type)) {
	case OSF1_MOUNT_NFS:
		if ((error = osf1_mount_nfs(p, uap, &a)))
			return error;
		break;

	case OSF1_MOUNT_MFS:
		if ((error = osf1_mount_mfs(p, uap, &a)))
			return error;
		break;

	default:
		return (EINVAL);
	}

	return sys_mount(p, &a, retval);
}

int
osf1_sys_statfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_statfs_args *uap = v;
	struct mount *mp;
	struct statfs *sp;
	struct osf1_statfs osfs;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)))
		return (error);
	mp = nd.ni_vp->v_mount;
	sp = &mp->mnt_stat;
	vrele(nd.ni_vp);
	if ((error = VFS_STATFS(mp, sp, p)))
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
	osf1_cvt_statfs_from_native(sp, &osfs);
	return copyout(&osfs, SCARG(uap, buf), min(sizeof osfs,
	    SCARG(uap, len)));
}

int
osf1_sys_unmount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_unmount_args *uap = v;
	struct sys_unmount_args a;

	SCARG(&a, path) = SCARG(uap, path);

	if (SCARG(uap, flags) & ~OSF1_UNMOUNT_FLAGS)
		return (EINVAL);
	SCARG(&a, flags) = 0;
	if ((SCARG(uap, flags) & OSF1_MNT_FORCE) &&
	    (SCARG(uap, flags) & OSF1_MNT_NOFORCE) == 0)
		SCARG(&a, flags) |= MNT_FORCE;

	return sys_unmount(p, &a, retval);
}

static int
osf1_mount_mfs(p, osf_argp, bsd_argp)
	struct proc *p;
	struct osf1_sys_mount_args *osf_argp;
	struct sys_mount_args *bsd_argp;
{
	struct osf1_mfs_args osf_ma;
	struct mfs_args bsd_ma;
	caddr_t sg = stackgap_init(p->p_emul);
	int error, len;
	static const char mfs_name[] = MOUNT_MFS;

	if ((error = copyin(SCARG(osf_argp, data), &osf_ma, sizeof osf_ma)))
		return error;

	memset(&bsd_ma, 0, sizeof bsd_ma);
	bsd_ma.fspec = osf_ma.name;
	/* XXX export args */
	bsd_ma.base = osf_ma.base;
	bsd_ma.size = osf_ma.size;

	SCARG(bsd_argp, data) = stackgap_alloc(&sg, sizeof bsd_ma);
	if ((error = copyout(&bsd_ma, SCARG(bsd_argp, data), sizeof bsd_ma)))
		return error;

	len = strlen(mfs_name) + 1;
	SCARG(bsd_argp, type) = stackgap_alloc(&sg, len);
	if ((error = copyout(mfs_name, (void *)SCARG(bsd_argp, type), len)))
		return error;

	return 0;
}

static int
osf1_mount_nfs(p, osf_argp, bsd_argp)
	struct proc *p;
	struct osf1_sys_mount_args *osf_argp;
	struct sys_mount_args *bsd_argp;
{
	struct osf1_nfs_args osf_na;
	struct nfs_args bsd_na;
	caddr_t sg = stackgap_init(p->p_emul);
	int error, len;
	static const char nfs_name[] = MOUNT_NFS;
	unsigned long leftovers;

	if ((error = copyin(SCARG(osf_argp, data), &osf_na, sizeof osf_na)))
		return error;

	memset(&bsd_na, 0, sizeof bsd_na);
	bsd_na.addr = (struct sockaddr *)osf_na.addr;
	bsd_na.addrlen = sizeof (struct sockaddr_in);
	bsd_na.fh = osf_na.fh;

        /* translate flags */
        bsd_na.flags = emul_flags_translate(osf1_nfs_mount_flags_xtab,
            osf_na.flags, &leftovers);
	if (leftovers & OSF1_NFSMNT_HOSTNAME) {
		leftovers &= ~OSF1_NFSMNT_HOSTNAME;
		bsd_na.hostname = osf_na.hostname;
	} else {
		/* XXX FILL IN HOST NAME WITH IPADDR? */
	}
	if (leftovers & OSF1_NFSMNT_TCP) {
		leftovers &= ~OSF1_NFSMNT_TCP;
		bsd_na.sotype = SOCK_DGRAM; 
		bsd_na.proto = 0; 
	} else {
		bsd_na.sotype = SOCK_STREAM; 
		bsd_na.proto = 0; 
	}
        if (leftovers != 0)
                return (EINVAL);

	/* copy structure elements based on flags */
	if (bsd_na.flags & NFSMNT_WSIZE)
		bsd_na.wsize = osf_na.wsize;
	if (bsd_na.flags & NFSMNT_RSIZE)
		bsd_na.rsize = osf_na.rsize;
	if (bsd_na.flags & NFSMNT_TIMEO)
		bsd_na.timeo = osf_na.timeo;
	if (bsd_na.flags & NFSMNT_RETRANS)
		bsd_na.retrans = osf_na.retrans;

	SCARG(bsd_argp, data) = stackgap_alloc(&sg, sizeof bsd_na);
	if ((error = copyout(&bsd_na, SCARG(bsd_argp, data), sizeof bsd_na)))
		return error;

	len = strlen(nfs_name) + 1;
	SCARG(bsd_argp, type) = stackgap_alloc(&sg, len);
	if ((error = copyout(MOUNT_NFS, (void *)SCARG(bsd_argp, type), len)))
		return error;

	return 0;
}
@


1.11
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: osf1_mount.c,v 1.10 2005/07/03 20:13:59 drahn Exp $ */
@


1.10
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/* 	$OpenBSD: osf1_mount.c,v 1.9 2002/08/23 15:39:31 art Exp $ */
d154 2
a155 1
	for (count = 0, mp = mountlist.cqh_first; mp != (void *)&mountlist;
d157 1
a157 1
		nmp = mp->mnt_list.cqe_next;
@


1.9
log
@Cleanup change. Since almost all callers (except one) of getvnode did a FREF
on the returned file, do the FREF inside getvnode so that people can't
get away with avoiding FREF and FRELE.

Eyeballed by various people.
@
text
@d1 1
a1 1
/* 	$OpenBSD: osf1_mount.c,v 1.8 2002/03/14 01:26:50 millert Exp $ */
a85 1
#include <ufs/ufs/extattr.h>
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* 	$OpenBSD: osf1_mount.c,v 1.7 2002/02/22 20:37:45 drahn Exp $ */
a124 1
	FREF(fp);
@


1.7
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: osf1_mount.c,v 1.5 2000/08/04 15:47:55 ericj Exp $ */
d103 4
a106 4
static int	osf1_mount_mfs __P((struct proc *,
		    struct osf1_sys_mount_args *, struct sys_mount_args *));
static int	osf1_mount_nfs __P((struct proc *,
		    struct osf1_sys_mount_args *, struct sys_mount_args *));
@


1.6
log
@More FREF/FRELE protection. This time all users of getvnode.
@
text
@d86 1
@


1.5
log
@
Merge in NetBSD changes. This now works for most statically compiled osf1
bins. Shared osf1 libs don't work quite yet.
@
text
@d1 1
a1 1
/* 	$OpenBSD$ */
a119 1
	/* getvnode() will use the descriptor for us */
d124 4
a127 1
	if ((error = VFS_STATFS(mp, sp, p)))
@


1.5.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* 	$OpenBSD: osf1_mount.c,v 1.5 2000/08/04 15:47:55 ericj Exp $ */
a85 1
#include <ufs/ufs/extattr.h>
d102 4
a105 4
static int	osf1_mount_mfs(struct proc *,
		    struct osf1_sys_mount_args *, struct sys_mount_args *);
static int	osf1_mount_nfs(struct proc *,
		    struct osf1_sys_mount_args *, struct sys_mount_args *);
d120 1
d125 1
a125 4
	FREF(fp);
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp);
	if (error)
@


1.5.8.2
log
@sync to -current
@
text
@d1 1
a1 1
/* 	$OpenBSD: osf1_mount.c,v 1.5.8.1 2002/06/11 03:28:08 art Exp $ */
d125 1
@


1.4
log
@More -Wall happiness
@
text
@d1 32
a32 2
/*	$OpenBSD: osf1_mount.c,v 1.3 1996/08/23 11:48:48 niklas Exp $	*/
/*	$NetBSD: osf1_mount.c,v 1.6 1996/02/17 23:08:36 jtk Exp $	*/
d66 1
d72 1
d75 1
d80 1
d82 5
a89 18
/* File system type numbers. */
#define	OSF1_MOUNT_NONE		0
#define	OSF1_MOUNT_UFS		1
#define	OSF1_MOUNT_NFS		2
#define	OSF1_MOUNT_MFS		3
#define	OSF1_MOUNT_PC		4
#define	OSF1_MOUNT_S5FS		5
#define	OSF1_MOUNT_CDFS		6
#define	OSF1_MOUNT_DFS		7
#define	OSF1_MOUNT_EFS		8
#define	OSF1_MOUNT_PROCFS	9
#define	OSF1_MOUNT_MSFS		10
#define	OSF1_MOUNT_FFM		11
#define	OSF1_MOUNT_FDFS		12
#define	OSF1_MOUNT_ADDON	13
#define	OSF1_MOUNT_NFSV3	14
#define	OSF1_MOUNT_MAXTYPE	15

a100 134
struct osf1_statfs {
	int16_t	f_type;				/*   0 */
	int16_t	f_flags;			/*   2 */
	int32_t	f_fsize;			/*   4 */
	int32_t	f_bsize;			/*   8 */
	int32_t	f_blocks;			/*  12 */
	int32_t	f_bfree;			/*  16 */
	int32_t	f_bavail;			/*  20 */
	int32_t	f_files;			/*  24 */
	int32_t	f_ffree;			/*  28 */
	int64_t	f_fsid;				/*  32 */
	int32_t	f_spare[9];			/*  40 (36 bytes) */
	char	f_mntonname[90];		/*  76 (90 bytes) */
	char	f_mntfromname[90];		/* 166 (90 bytes) */
	char	f_xxx[80];			/* 256 (80 bytes) XXX */
};

/* Arguments to mount() for various FS types. */
#ifdef notyet /* XXX */
struct osf1_ufs_args {
	char		*fspec;
	int32_t		exflags;
	u_int32_t	exroot;
};

struct osf1_cdfs_args {
	char		*fspec;
	int32_t		exflags;
	u_int32_t	exroot;
	int32_t		flags;
};
#endif

struct osf1_mfs_args {
	char		*name;
	caddr_t		base;
	u_int		size;
};

struct osf1_nfs_args {
	struct sockaddr_in	*addr;
	caddr_t			fh;
	int32_t			flags;
	int32_t			wsize;
	int32_t			rsize;
	int32_t			timeo;
	int32_t			retrans;
	char			*hostname;
	int32_t			acregmin;
	int32_t			acregmax;
	int32_t			acdirmin;
	int32_t			acdirmax;
	char			*netname;
	void			*pathconf;
};

#define	OSF1_NFSMNT_SOFT	0x00001
#define	OSF1_NFSMNT_WSIZE	0x00002
#define	OSF1_NFSMNT_RSIZE	0x00004
#define	OSF1_NFSMNT_TIMEO	0x00008
#define	OSF1_NFSMNT_RETRANS	0x00010
#define	OSF1_NFSMNT_HOSTNAME	0x00020
#define	OSF1_NFSMNT_INT		0x00040
#define	OSF1_NFSMNT_NOCONN	0x00080
#define	OSF1_NFSMNT_NOAC	0x00100			/* ??? */
#define	OSF1_NFSMNT_ACREGMIN	0x00200			/* ??? */
#define	OSF1_NFSMNT_ACREGMAX	0x00400			/* ??? */
#define	OSF1_NFSMNT_ACDIRMIN	0x00800			/* ??? */
#define	OSF1_NFSMNT_ACDIRMAX	0x01000			/* ??? */
#define	OSF1_NFSMNT_NOCTO	0x02000			/* ??? */
#define	OSF1_NFSMNT_POSIX	0x04000			/* ??? */
#define	OSF1_NFSMNT_AUTO	0x08000			/* ??? */

#define OSF1_NFSMNT_FLAGS						\
	(OSF1_NFSMNT_SOFT|OSF1_NFSMNT_WSIZE|OSF1_NFSMNT_RSIZE|		\
	OSF1_NFSMNT_TIMEO|OSF1_NFSMNT_RETRANS|OSF1_NFSMNT_HOSTNAME|	\
	OSF1_NFSMNT_INT|OSF1_NFSMNT_NOCONN)

void bsd2osf_statfs __P((struct statfs *, struct osf1_statfs *));
int osf1_mount_mfs __P((struct proc *, struct osf1_sys_mount_args *,
    struct sys_mount_args *));
int osf1_mount_nfs __P((struct proc *, struct osf1_sys_mount_args *,
   struct sys_mount_args *));

void
bsd2osf_statfs(bsfs, osfs)
	struct statfs *bsfs;
	struct osf1_statfs *osfs;
{

	bzero(osfs, sizeof (struct osf1_statfs));
	if (!strncmp(MOUNT_FFS, bsfs->f_fstypename, MFSNAMELEN))
		osfs->f_type = OSF1_MOUNT_UFS;
	else if (!strncmp(MOUNT_NFS, bsfs->f_fstypename, MFSNAMELEN))
		osfs->f_type = OSF1_MOUNT_NFS;
	else if (!strncmp(MOUNT_MFS, bsfs->f_fstypename, MFSNAMELEN))
		osfs->f_type = OSF1_MOUNT_MFS;
	else
		/* uh oh...  XXX = PC, CDFS, PROCFS, etc. */
		osfs->f_type = OSF1_MOUNT_ADDON;
	osfs->f_flags = bsfs->f_flags;		/* XXX translate */
	osfs->f_fsize = bsfs->f_bsize;
	osfs->f_bsize = bsfs->f_iosize;
	osfs->f_blocks = bsfs->f_blocks;
	osfs->f_bfree = bsfs->f_bfree;
	osfs->f_bavail = bsfs->f_bavail;
	osfs->f_files = bsfs->f_files;
	osfs->f_ffree = bsfs->f_ffree;
	bcopy(&bsfs->f_fsid, &osfs->f_fsid,
	    max(sizeof bsfs->f_fsid, sizeof osfs->f_fsid));
	/* osfs->f_spare zeroed above */
	bcopy(bsfs->f_mntonname, osfs->f_mntonname,
	    max(sizeof bsfs->f_mntonname, sizeof osfs->f_mntonname));
	bcopy(bsfs->f_mntfromname, osfs->f_mntfromname,
	    max(sizeof bsfs->f_mntfromname, sizeof osfs->f_mntfromname));
	/* XXX osfs->f_xxx should be filled in... */
}

int
osf1_sys_statfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_statfs_args /* {
		syscallarg(char *) path;
		syscallarg(struct osf1_statfs *) buf;
		syscallarg(int) len;
	} */ *uap = v;
	struct mount *mp;
	struct statfs *sp;
	struct osf1_statfs osfs;
	int error;
	struct nameidata nd;
d102 4
a105 13
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	mp = nd.ni_vp->v_mount;
	sp = &mp->mnt_stat;
	vrele(nd.ni_vp);
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
	bsd2osf_statfs(sp, &osfs);
	return copyout(&osfs, SCARG(uap, buf), min(sizeof osfs,
	    SCARG(uap, len)));
}
d113 1
a113 5
	struct osf1_sys_fstatfs_args /* {
		syscallarg(int) fd;
		syscallarg(struct osf1_statfs *) buf;   
		syscallarg(int) len;
	} */ *uap = v;
d120 2
a121 1
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
d125 2
a126 2
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
		return (error);
d128 2
a129 2
	bsd2osf_statfs(sp, &osfs);
	return copyout(&osfs, SCARG(uap, buf), min(sizeof osfs,
d131 2
d141 1
a141 5
	register struct osf1_sys_getfsstat_args /* {
		syscallarg(struct osf1_statfs *) buf;
		syscallarg(long) bufsize;
		syscallarg(int) flags;
	} */ *uap = v;
d156 1
a156 2
		if (osf_sfsp && count < maxcount &&
		    ((mp->mnt_flag & MNT_MLOCK) == 0)) {
d168 1
a168 1
			bsd2osf_statfs(sp, &osfs);
d170 1
a170 1
			    sizeof (struct osf1_statfs))) != 0)
a183 24
osf1_sys_unmount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_unmount_args /* {
		syscallarg(char *) path;
		syscallarg(int) flags;
	} */ *uap = v;
	struct sys_unmount_args a;

	SCARG(&a, path) = SCARG(uap, path);

	if (SCARG(uap, flags) & ~OSF1_UNMOUNT_FLAGS)
		return (EINVAL);
	SCARG(&a, flags) = 0;
	if ((SCARG(uap, flags) & OSF1_MNT_FORCE) &&
	    (SCARG(uap, flags) & OSF1_MNT_NOFORCE) == 0)
		SCARG(&a, flags) |= MNT_FORCE;

	return sys_unmount(p, &a, retval);
}

int
d189 1
a189 6
	struct osf1_sys_mount_args /* {
		syscallarg(int) type;
		syscallarg(char *) path;
		syscallarg(int) flags;
		syscallarg(caddr_t) data;
	} */ *uap = v;
d200 2
a201 6
	case OSF1_MOUNT_UFS:				/* XXX */
		return (EINVAL);
		break;

	case OSF1_MOUNT_NFS:				/* XXX */
		if ((error = osf1_mount_nfs(p, uap, &a)) != 0)
d205 2
a206 2
	case OSF1_MOUNT_MFS:				/* XXX */
		if ((error = osf1_mount_mfs(p, uap, &a)) != 0)
a209 17
	case OSF1_MOUNT_CDFS:				/* XXX */
		return (EINVAL);
		break;

	case OSF1_MOUNT_PROCFS:				/* XXX */
		return (EINVAL);
		break;

	case OSF1_MOUNT_NONE:
	case OSF1_MOUNT_PC:
	case OSF1_MOUNT_S5FS:
	case OSF1_MOUNT_DFS:
	case OSF1_MOUNT_EFS:
	case OSF1_MOUNT_MSFS:
	case OSF1_MOUNT_FFM:
	case OSF1_MOUNT_FDFS:
	case OSF1_MOUNT_ADDON:
d218 48
a270 1
	struct emul *e = p->p_emul;
d273 3
a275 2
	caddr_t cp;
	int error;
d277 1
a277 2
	error = copyin(SCARG(osf_argp, data), &osf_ma, sizeof osf_ma);
	if (error)
d280 1
a280 1
	bzero(&bsd_ma, sizeof bsd_ma);
d286 2
a287 3
	cp = STACKGAPBASE;
	SCARG(bsd_argp, data) = cp;
	if ((error = copyout(&bsd_ma, cp, sizeof bsd_ma)) != 0)
a288 1
	cp += ALIGN(sizeof bsd_ma);
d290 3
a292 2
	SCARG(bsd_argp, type) = cp;
	if ((error = copyout(MOUNT_MFS, cp, strlen(MOUNT_MFS) + 1)) != 0)
d298 1
a298 1
int
a303 1
	struct emul *e = p->p_emul;
d306 4
a309 2
	caddr_t cp;
	int error;
d311 1
a311 2
	error = copyin(SCARG(osf_argp, data), &osf_na, sizeof osf_na);
	if (error)
d314 1
a314 2
	bzero(&bsd_na, sizeof bsd_na);
	bsd_na.version = 2;
d317 24
a340 9
	bsd_na.sotype = SOCK_DGRAM; 
	bsd_na.proto = 0; 
	bsd_na.fh = (char *)osf_na.fh;

	if (osf_na.flags & ~OSF1_NFSMNT_FLAGS)
		return EINVAL;
	if (osf_na.flags & OSF1_NFSMNT_SOFT)
		bsd_na.flags |= NFSMNT_SOFT;
	if (osf_na.flags & OSF1_NFSMNT_WSIZE) {
d342 1
a342 3
		bsd_na.flags |= NFSMNT_WSIZE;
	}
	if (osf_na.flags & OSF1_NFSMNT_RSIZE) {
d344 1
a344 3
		bsd_na.flags |= NFSMNT_RSIZE;
	}
	if (osf_na.flags & OSF1_NFSMNT_TIMEO) {
d346 1
a346 3
		bsd_na.flags |= NFSMNT_TIMEO;
	}
	if (osf_na.flags & OSF1_NFSMNT_RETRANS) {
d348 3
a350 12
		bsd_na.flags |= NFSMNT_RETRANS;
	}
	if (osf_na.flags & OSF1_NFSMNT_HOSTNAME)
		bsd_na.hostname = osf_na.hostname;
	if (osf_na.flags & OSF1_NFSMNT_INT)
		bsd_na.flags |= NFSMNT_INT;
	if (osf_na.flags & OSF1_NFSMNT_NOCONN)
		bsd_na.flags |= NFSMNT_NOCONN;

	cp = STACKGAPBASE;
	SCARG(bsd_argp, data) = cp;
	if ((error = copyout(&bsd_na, cp, sizeof bsd_na)) != 0)
a351 1
	cp += ALIGN(sizeof bsd_na);
d353 3
a355 2
	SCARG(bsd_argp, type) = cp;
	if ((error = copyout(MOUNT_NFS, cp, strlen(MOUNT_NFS) + 1)) != 0)
@


1.4.14.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 32
/* 	$OpenBSD: osf1_mount.c,v 1.5 2000/08/04 15:47:55 ericj Exp $ */
/*	$NetBSD: osf1_mount.c,v 1.14 1999/05/05 01:51:34 cgd Exp $	*/

/*
 * Copyright (c) 1999 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
a35 1
#include <sys/filedesc.h>
a40 1
#include <compat/osf1/osf1.h>
a42 1
#include <compat/osf1/osf1_cvt.h>
a46 1
#include <nfs/rpcv2.h>
a47 2
#include <nfs/nfs.h>
#include <nfs/nfsmount.h>
d49 1
a49 2
#include <ufs/ufs/quota.h>
#include <ufs/ufs/ufsmount.h>
d51 17
a67 1
#include <machine/vmparam.h>
d80 134
d215 13
a227 4
static int	osf1_mount_mfs __P((struct proc *,
		    struct osf1_sys_mount_args *, struct sys_mount_args *));
static int	osf1_mount_nfs __P((struct proc *,
		    struct osf1_sys_mount_args *, struct sys_mount_args *));
d235 5
a239 1
	struct osf1_sys_fstatfs_args *uap = v;
d246 1
a246 2
	/* getvnode() will use the descriptor for us */
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)))
d250 2
a251 2
	if ((error = VFS_STATFS(mp, sp, p)))
		goto out;
d253 2
a254 2
	osf1_cvt_statfs_from_native(sp, &osfs);
	error = copyout(&osfs, SCARG(uap, buf), min(sizeof osfs,
a255 2
 out:
	return (error);
d264 5
a268 1
	struct osf1_sys_getfsstat_args *uap = v;
d283 2
a284 1
		if (osf_sfsp && count < maxcount) {
d296 1
a296 1
			osf1_cvt_statfs_from_native(sp, &osfs);
d298 1
a298 1
			    sizeof (struct osf1_statfs))))
d312 24
d341 6
a346 1
	struct osf1_sys_mount_args *uap = v;
d357 6
a362 2
	case OSF1_MOUNT_NFS:
		if ((error = osf1_mount_nfs(p, uap, &a)))
d366 2
a367 2
	case OSF1_MOUNT_MFS:
		if ((error = osf1_mount_mfs(p, uap, &a)))
d371 17
a395 48
osf1_sys_statfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_statfs_args *uap = v;
	struct mount *mp;
	struct statfs *sp;
	struct osf1_statfs osfs;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)))
		return (error);
	mp = nd.ni_vp->v_mount;
	sp = &mp->mnt_stat;
	vrele(nd.ni_vp);
	if ((error = VFS_STATFS(mp, sp, p)))
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
	osf1_cvt_statfs_from_native(sp, &osfs);
	return copyout(&osfs, SCARG(uap, buf), min(sizeof osfs,
	    SCARG(uap, len)));
}

int
osf1_sys_unmount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_unmount_args *uap = v;
	struct sys_unmount_args a;

	SCARG(&a, path) = SCARG(uap, path);

	if (SCARG(uap, flags) & ~OSF1_UNMOUNT_FLAGS)
		return (EINVAL);
	SCARG(&a, flags) = 0;
	if ((SCARG(uap, flags) & OSF1_MNT_FORCE) &&
	    (SCARG(uap, flags) & OSF1_MNT_NOFORCE) == 0)
		SCARG(&a, flags) |= MNT_FORCE;

	return sys_unmount(p, &a, retval);
}

static int
d401 1
d404 2
a405 3
	caddr_t sg = stackgap_init(p->p_emul);
	int error, len;
	static const char mfs_name[] = MOUNT_MFS;
d407 2
a408 1
	if ((error = copyin(SCARG(osf_argp, data), &osf_ma, sizeof osf_ma)))
d411 1
a411 1
	memset(&bsd_ma, 0, sizeof bsd_ma);
d417 3
a419 2
	SCARG(bsd_argp, data) = stackgap_alloc(&sg, sizeof bsd_ma);
	if ((error = copyout(&bsd_ma, SCARG(bsd_argp, data), sizeof bsd_ma)))
d421 1
d423 2
a424 3
	len = strlen(mfs_name) + 1;
	SCARG(bsd_argp, type) = stackgap_alloc(&sg, len);
	if ((error = copyout(mfs_name, (void *)SCARG(bsd_argp, type), len)))
d430 1
a430 1
static int
d436 1
d439 2
a440 4
	caddr_t sg = stackgap_init(p->p_emul);
	int error, len;
	static const char nfs_name[] = MOUNT_NFS;
	unsigned long leftovers;
d442 2
a443 1
	if ((error = copyin(SCARG(osf_argp, data), &osf_na, sizeof osf_na)))
d446 2
a447 1
	memset(&bsd_na, 0, sizeof bsd_na);
d450 11
a460 10
	bsd_na.fh = osf_na.fh;

        /* translate flags */
        bsd_na.flags = emul_flags_translate(osf1_nfs_mount_flags_xtab,
            osf_na.flags, &leftovers);
	if (leftovers & OSF1_NFSMNT_HOSTNAME) {
		leftovers &= ~OSF1_NFSMNT_HOSTNAME;
		bsd_na.hostname = osf_na.hostname;
	} else {
		/* XXX FILL IN HOST NAME WITH IPADDR? */
d462 3
a464 7
	if (leftovers & OSF1_NFSMNT_TCP) {
		leftovers &= ~OSF1_NFSMNT_TCP;
		bsd_na.sotype = SOCK_DGRAM; 
		bsd_na.proto = 0; 
	} else {
		bsd_na.sotype = SOCK_STREAM; 
		bsd_na.proto = 0; 
d466 1
a466 9
        if (leftovers != 0)
                return (EINVAL);

	/* copy structure elements based on flags */
	if (bsd_na.flags & NFSMNT_WSIZE)
		bsd_na.wsize = osf_na.wsize;
	if (bsd_na.flags & NFSMNT_RSIZE)
		bsd_na.rsize = osf_na.rsize;
	if (bsd_na.flags & NFSMNT_TIMEO)
d468 3
a470 1
	if (bsd_na.flags & NFSMNT_RETRANS)
d472 12
a483 3

	SCARG(bsd_argp, data) = stackgap_alloc(&sg, sizeof bsd_na);
	if ((error = copyout(&bsd_na, SCARG(bsd_argp, data), sizeof bsd_na)))
d485 1
d487 2
a488 3
	len = strlen(nfs_name) + 1;
	SCARG(bsd_argp, type) = stackgap_alloc(&sg, len);
	if ((error = copyout(MOUNT_NFS, (void *)SCARG(bsd_argp, type), len)))
@


1.4.14.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/* 	$OpenBSD$ */
a85 1
#include <ufs/ufs/extattr.h>
d120 1
d125 1
a125 4
	FREF(fp);
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp);
	if (error)
@


1.4.14.3
log
@Merge in -current from about a week ago
@
text
@d103 4
a106 4
static int	osf1_mount_mfs(struct proc *,
		    struct osf1_sys_mount_args *, struct sys_mount_args *);
static int	osf1_mount_nfs(struct proc *,
		    struct osf1_sys_mount_args *, struct sys_mount_args *);
@


1.4.14.4
log
@Sync the SMP branch with 3.3
@
text
@d125 1
@


1.3
log
@It is clear noone even tried to compile OSF/1 emulation lately.
Made it compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d158 6
d216 1
a216 1
	if (error = namei(&nd))
d221 1
a221 1
	if (error = VFS_STATFS(mp, sp, p))
d246 1
a246 1
	if (error = getvnode(p->p_fd, SCARG(uap, fd), &fp))
d250 1
a250 1
	if (error = VFS_STATFS(mp, sp, p))
d297 2
a298 2
			if (error = copyout(&osfs, osf_sfsp,
			    sizeof (struct osf1_statfs)))
d362 1
a362 1
		if (error = osf1_mount_nfs(p, uap, &a))
d367 1
a367 1
		if (error = osf1_mount_mfs(p, uap, &a))
d407 2
a408 1
	if (error = copyin(SCARG(osf_argp, data), &osf_ma, sizeof osf_ma))
d419 1
a419 1
	if (error = copyout(&bsd_ma, cp, sizeof bsd_ma))
d424 1
a424 1
	if (error = copyout(MOUNT_MFS, cp, strlen(MOUNT_MFS) + 1))
d442 2
a443 1
	if (error = copyin(SCARG(osf_argp, data), &osf_na, sizeof osf_na))
d483 1
a483 1
	if (error = copyout(&bsd_na, cp, sizeof bsd_na))
d488 1
a488 1
	if (error = copyout(MOUNT_NFS, cp, strlen(MOUNT_NFS) + 1))
@


1.2
log
@Merge of NetBSD 960317
@
text
@d47 2
d66 2
a67 1
#define	OSF1_MOUNT_MAXTYPE	OSF1_MOUNT_ADDON
d121 1
a121 1
	nfsv2fh_t		*fh;
d240 1
a240 1
	if (error = getvnode(p->p_fd, uap->fd, &fp))
d439 1
d444 1
a444 1
	bsd_na.fh = osf_na.fh;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: osf1_mount.c,v 1.5 1995/10/07 06:27:24 mycroft Exp $	*/
d162 1
a162 1
	if (!strncmp(MOUNT_UFS, bsfs->f_fstypename, MFSNAMELEN))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
