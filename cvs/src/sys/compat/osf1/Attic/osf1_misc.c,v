head	1.19;
access;
symbols
	OPENBSD_4_7:1.18.0.8
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.10
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.14
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.12
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.10
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.10
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.8
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.13.0.8
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.6
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.4
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.11.0.4
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.10.0.8
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2010.06.30.20.39.28;	author tedu;	state dead;
branches;
next	1.18;

1.18
date	2007.09.15.10.10.37;	author martin;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.25.16.28.51;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.24.19.35.23;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.22.23.52.18;	author jfb;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.12.20.46.42;	author ericj;	state Exp;
branches
	1.13.8.1;
next	1.12;

1.12
date	2000.08.04.15.47.55;	author ericj;	state Exp;
branches;
next	1.11;

1.11
date	99.11.10.15.55.23;	author mickey;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	98.03.01.17.00.22;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	98.02.17.01.48.07;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.10.30.16.37.19;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.10.17.19.15.49;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.10.12.15.45.03;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.08.31.09.24.03;	author pefo;	state Exp;
branches;
next	1.4;

1.4
date	96.08.25.12.19.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.23.11.46.51;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.08.02.20.20.29;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.20;	author deraadt;	state Exp;
branches;
next	;

1.11.2.1
date	2001.05.14.22.05.08;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	;

1.13.8.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@delete osf1 compat files
@
text
@/* $OpenBSD: osf1_misc.c,v 1.18 2007/09/15 10:10:37 martin Exp $ */
/* $NetBSD: osf1_misc.c,v 1.55 2000/06/28 15:39:33 mrg Exp $ */

/*
 * Copyright (c) 1999 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/filedesc.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/reboot.h>
#include <sys/syscallargs.h>
#include <sys/exec.h>
#include <sys/vnode.h>
#include <sys/socketvar.h>
#include <sys/resource.h>
#include <sys/resourcevar.h>
#include <sys/wait.h>

#include <compat/osf1/osf1.h>
#include <compat/osf1/osf1_syscallargs.h>
#include <compat/osf1/osf1_util.h>
#include <compat/osf1/osf1_cvt.h>

#ifdef SYSCALL_DEBUG
extern int scdebug;
#endif

const char osf1_emul_path[] = "/emul/osf1";

int
osf1_sys_classcntl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	/* XXX */
	return (ENOSYS);
}

int
osf1_sys_reboot(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_reboot_args *uap = v;
	struct sys_reboot_args a;
	unsigned long leftovers;

	/* translate opt */
	SCARG(&a, opt) = emul_flags_translate(osf1_reboot_opt_xtab,
	    SCARG(uap, opt), &leftovers);
	if (leftovers != 0)
		return (EINVAL);

	/* SCARG(&a, bootstr) = NULL; */

	return sys_reboot(p, &a, retval);
}

int
osf1_sys_set_program_attributes(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_set_program_attributes_args *uap = v;
	segsz_t tsize, dsize;

	tsize = atop(SCARG(uap, tsize));
	dsize = atop(SCARG(uap, dsize));

	if (dsize > p->p_rlimit[RLIMIT_DATA].rlim_cur)
		return (ENOMEM);
	if (tsize > MAXTSIZ)
		return (ENOMEM);

	p->p_vmspace->vm_taddr = SCARG(uap, taddr);
	p->p_vmspace->vm_tsize = tsize;
	p->p_vmspace->vm_daddr = SCARG(uap, daddr);
	p->p_vmspace->vm_dsize = dsize;

	return (0);
}

int
osf1_sys_setsysinfo(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	/* XXX */
	return (0);
}

int
osf1_sys_sysinfo(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_sysinfo_args *uap = v;
	const char *string;
	int error;

	error = 0;
	switch (SCARG(uap, cmd)) {
	case OSF1_SI_SYSNAME:
		goto should_handle;
		/* string = ostype; */
		break;

	case OSF1_SI_HOSTNAME:
		string = hostname;
		break;

	case OSF1_SI_RELEASE:
		string = version;
		break;

	case OSF1_SI_VERSION:
		goto should_handle;

	case OSF1_SI_MACHINE:
		string = MACHINE;
		break;

	case OSF1_SI_ARCHITECTURE:
		string = MACHINE_ARCH;
		break;

	case OSF1_SI_HW_SERIAL:
		string = "666";			/* OSF/1 emulation?  YES! */
		break;

	case OSF1_SI_HW_PROVIDER:
		string = "unknown";
		break;

	case OSF1_SI_SRPC_DOMAIN:
		goto dont_care;

	case OSF1_SI_SET_HOSTNAME:
		goto should_handle;

	case OSF1_SI_SET_SYSNAME:
		goto should_handle;

	case OSF1_SI_SET_SRPC_DOMAIN:
		goto dont_care;

	default:
should_handle:
		printf("osf1_sys_sysinfo(%d, %p, 0x%lx)\n", SCARG(uap, cmd),
		    SCARG(uap, buf), SCARG(uap,len));
dont_care:
		error = EINVAL;
		break;
	};

	if (error == 0)
		error = copyoutstr(string, SCARG(uap, buf), SCARG(uap, len),
		    NULL);

	return (error);
}

int
osf1_sys_uname(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_uname_args *uap = v;
        struct osf1_utsname u;
        const char *cp;
	extern char hostname[], machine[];
        char *dp, *ep;

	/* XXX would use stackgap, but our struct utsname is too big! */

	bzero(&u, sizeof(u));
	strlcpy(u.sysname, ostype, sizeof(u.sysname));
	strlcpy(u.nodename, hostname, sizeof(u.nodename));
	strlcpy(u.release, osrelease, sizeof(u.release));

        dp = u.version;
        ep = &u.version[sizeof(u.version) - 1];
        for (cp = version; *cp && *cp != '('; cp++)
                ;
        for (cp++; *cp && *cp != ')' && dp < ep; cp++)
                *dp++ = *cp;
        for (; *cp && *cp != '#'; cp++)
                ;
        for (; *cp && *cp != ':' && dp < ep; cp++)
                *dp++ = *cp;
        *dp = '\0';

	strlcpy(u.machine, machine, sizeof(u.machine));

        return (copyout((caddr_t)&u, (caddr_t)SCARG(uap, name), sizeof u));
}

int
osf1_sys_usleep_thread(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_usleep_thread_args *uap = v;
	struct osf1_timeval otv, endotv;
	struct timeval tv, endtv;
	u_long ticks;
	int error;

	if ((error = copyin(SCARG(uap, sleep), &otv, sizeof otv)))
		return (error);
	tv.tv_sec = otv.tv_sec;
	tv.tv_usec = otv.tv_usec;

	ticks = howmany((u_long)tv.tv_sec * 1000000 + tv.tv_usec, tick);
	if (ticks == 0)
		ticks = 1;

	getmicrotime(&tv);

	tsleep(p, PUSER|PCATCH, "uslpthrd", ticks);	/* XXX */

	if (SCARG(uap, slept) != NULL) {
		struct timeval tv2;

		getmicrotime(&tv2);
		timersub(&tv2, &tv, &endtv);

		if (endtv.tv_sec < 0 || endtv.tv_usec < 0)
			endtv.tv_sec = endtv.tv_usec = 0;

		endotv.tv_sec = endtv.tv_sec;
		endotv.tv_usec = endtv.tv_usec;
		error = copyout(&endotv, SCARG(uap, slept), sizeof endotv);
	}
	return (error);
}

int
osf1_sys_wait4(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_wait4_args *uap = v;
	struct sys_wait4_args a;
	struct osf1_rusage osf1_rusage;
	struct rusage netbsd_rusage;
	unsigned long leftovers;
	caddr_t sg;
	int error;

	SCARG(&a, pid) = SCARG(uap, pid);
	SCARG(&a, status) = SCARG(uap, status);

	/* translate options */
	SCARG(&a, options) = emul_flags_translate(osf1_wait_options_xtab,
	    SCARG(uap, options), &leftovers);
	if (leftovers != 0)
		return (EINVAL);

	if (SCARG(uap, rusage) == NULL)
		SCARG(&a, rusage) = NULL;
	else {
		sg = stackgap_init(p->p_emul);
		SCARG(&a, rusage) = stackgap_alloc(&sg, sizeof netbsd_rusage);
	}

	error = sys_wait4(p, &a, retval);

	if (error == 0 && SCARG(&a, rusage) != NULL) {
		error = copyin((caddr_t)SCARG(&a, rusage),
		    (caddr_t)&netbsd_rusage, sizeof netbsd_rusage);
		if (error == 0) {
			osf1_cvt_rusage_from_native(&netbsd_rusage,
			    &osf1_rusage);
			error = copyout((caddr_t)&osf1_rusage,
			    (caddr_t)SCARG(uap, rusage), sizeof osf1_rusage);
		}
	}

	return (error);
}
@


1.18
log
@replace ctob and btoc with ptoa and atop respectively

help and ok miod@@ thib@@
@
text
@d1 1
a1 1
/* $OpenBSD: osf1_misc.c,v 1.17 2004/06/25 16:28:51 deraadt Exp $ */
@


1.17
log
@typo
@
text
@d1 1
a1 1
/* $OpenBSD: osf1_misc.c,v 1.16 2004/06/24 19:35:23 tholo Exp $ */
d135 2
a136 2
	tsize = btoc(SCARG(uap, tsize));
	dsize = btoc(SCARG(uap, dsize));
@


1.16
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: osf1_misc.c,v 1.15 2004/06/22 23:52:18 jfb Exp $ */
d296 1
a296 1
		struct timval tv2;
@


1.15
log
@Replace a whole bunch of scary uses of strncpy() with strlcpy() and
use compat-specific MAXNAMLEN values where appropriate

ok millert@@, pedro@@
@
text
@d1 1
a1 1
/* $OpenBSD: osf1_misc.c,v 1.14 2002/03/14 20:31:31 mickey Exp $ */
d280 1
a280 1
	int error, s;
d291 1
a291 3
	s = splclock();
	tv = time;
	splx(s);
d296 5
a300 3
		s = splclock();
		timersub(&time, &tv, &endtv);
		splx(s);
@


1.14
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/* $OpenBSD: osf1_misc.c,v 1.13 2000/08/12 20:46:42 ericj Exp $ */
d249 3
a251 9
	
        strncpy(u.sysname, ostype, sizeof(u.sysname));
	u.sysname[sizeof(u.sysname) - 1] = '\0';

        strncpy(u.nodename, hostname, sizeof(u.nodename));
	u.nodename[sizeof(u.nodename) - 1] = '\0';

        strncpy(u.release, osrelease, sizeof(u.release));
	u.release[sizeof(u.release) - 1] = '\0';
d265 1
a265 2
        strncpy(u.machine, machine, sizeof(u.machine));
	u.machine[sizeof(u.machine) - 1] = '\0';
@


1.13
log
@emulate uname correctly
@
text
@d1 1
a1 1
/* $OpenBSD: osf1_misc.c,v 1.12 2000/08/04 15:47:55 ericj Exp $ */
d243 1
a243 1
	extern char ostype[], hostname[], osrelease[], version[], machine[];
@


1.13.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: osf1_misc.c,v 1.13 2000/08/12 20:46:42 ericj Exp $ */
d243 1
a243 1
	extern char hostname[], machine[];
@


1.12
log
@
Merge in NetBSD changes. This now works for most statically compiled osf1
bins. Shared osf1 libs don't work quite yet.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d243 1
d247 6
a252 4
	/*
         * strncpy(u.sysname, ostype, sizeof(u.sysname));
         */
	strncpy(u.sysname, "OpenBSD", sizeof(u.sysname));
d254 5
a258 1
        strncpy(u.release, version, sizeof(u.release));
d270 4
a273 1
        strncpy(u.machine, MACHINE, sizeof(u.machine));
@


1.11
log
@include syscallnames only if compiling w/ SYSCALL_DEBUG.
was already so for native and sunos, the rest was just
wasting space on it. niels@@ millert@@ ok
@
text
@d1 32
a32 2
/*	$OpenBSD: osf1_misc.c,v 1.10 1998/03/01 17:00:22 niklas Exp $	*/
/*	$NetBSD: osf1_misc.c,v 1.7 1995/10/07 06:53:04 mycroft Exp $	*/
a73 1
#include <sys/socketvar.h>
d76 1
d78 4
d83 1
a83 1
#include <compat/osf1/osf1_syscall.h>
d86 1
a86 2

#include <vm/vm.h>
a89 1
extern char *osf1_syscallnames[];
d92 1
a92 27
extern struct sysent osf1_sysent[];
extern void cpu_exec_ecoff_setregs __P((struct proc *, struct exec_package *,
					u_long, register_t *));

extern char sigcode[], esigcode[];

void cvtstat2osf1 __P((struct stat *, struct osf1_stat *));

struct emul emul_osf1 = {
	"osf1",
	NULL,
	sendsig,
	OSF1_SYS_syscall,
	OSF1_SYS_MAXSYSCALL,
	osf1_sysent,
#ifdef SYSCALL_DEBUG
	osf1_syscallnames,
#else
	NULL,
#endif
	0,
	copyargs,
	cpu_exec_ecoff_setregs,
	NULL,
	sigcode,
	esigcode,
};
d95 1
a95 1
osf1_sys_open(p, v, retval)
a99 12
	struct osf1_sys_open_args /* {
		syscallarg(char *) path;
		syscallarg(int) flags;
		syscallarg(int) mode;
	} */ *uap = v;
	struct sys_open_args /* {
		syscallarg(char *) path;
		syscallarg(int) flags;
		syscallarg(int) mode;
	} */ a;
#ifdef SYSCALL_DEBUG
	char pnbuf[1024];
d101 2
a102 10
	if (scdebug &&
	    copyinstr(SCARG(uap, path), pnbuf, sizeof pnbuf, NULL) == 0)
		printf("osf1_open: open: %s\n", pnbuf);
#endif

	SCARG(&a, path) = SCARG(uap, path);
	SCARG(&a, flags) = SCARG(uap, flags);		/* XXX translate */
	SCARG(&a, mode) = SCARG(uap, mode);

	return sys_open(p, &a, retval);
d106 1
a106 1
osf1_sys_setsysinfo(p, v, retval)
d111 3
a113 9
#if 0
	struct osf1_setsysinfo_args /* {
		syscallarg(u_long) op;
		syscallarg(caddr_t) buffer;
		syscallarg(u_long) nbytes;
		syscallarg(caddr_t) arg;
		syscallarg(u_long) flag;
	} */ *uap = v;
#endif;
d115 4
a118 23
	return (0);
}

#define OSF1_RLIMIT_LASTCOMMON	5		/* last one that's common */
#define OSF1_RLIMIT_NOFILE	6		/* OSF1's RLIMIT_NOFILE */
#define OSF1_RLIMIT_NLIMITS	8		/* Number of OSF1 rlimits */

int
osf1_sys_getrlimit(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_getrlimit_args /* { 
		syscallarg(u_int) which;
		syscallarg(struct rlimit *) rlp;
	} */ *uap = v;
	struct sys_getrlimit_args /* {
		syscallarg(u_int) which;
		syscallarg(struct rlimit *) rlp;
	} */ a;

	if (SCARG(uap, which) >= OSF1_RLIMIT_NLIMITS)
d121 1
a121 7
	if (SCARG(uap, which) <= OSF1_RLIMIT_LASTCOMMON)
		SCARG(&a, which) = SCARG(uap, which);
	else if (SCARG(uap, which) == OSF1_RLIMIT_NOFILE)
		SCARG(&a, which) = RLIMIT_NOFILE;
	else
		return (0);
	SCARG(&a, rlp) = SCARG(uap, rlp);
d123 1
a123 1
	return sys_getrlimit(p, &a, retval);
d127 1
a127 1
osf1_sys_setrlimit(p, v, retval)
d132 2
a133 11
	struct osf1_sys_setrlimit_args /* {
		syscallarg(u_int) which;
		syscallarg(struct rlimit *) rlp;
	} */ *uap = v;
	struct sys_setrlimit_args /* {
		syscallarg(u_int) which;
		syscallarg(struct rlimit *) rlp;
	} */ a;

	if (SCARG(uap, which) >= OSF1_RLIMIT_NLIMITS)
		return (EINVAL);
d135 2
a136 7
	if (SCARG(uap, which) <= OSF1_RLIMIT_LASTCOMMON)
		SCARG(&a, which) = SCARG(uap, which);
	else if (SCARG(uap, which) == OSF1_RLIMIT_NOFILE)
		SCARG(&a, which) = RLIMIT_NOFILE;
	else
		return (0);
	SCARG(&a, rlp) = SCARG(uap, rlp);
d138 4
a141 2
	return sys_setrlimit(p, &a, retval);
}
d143 4
a146 9
#define	OSF1_MAP_SHARED		0x001
#define OSF1_MAP_PRIVATE	0x002
#define	OSF1_MAP_ANONYMOUS	0x010
#define	OSF1_MAP_FILE		0x000
#define OSF1_MAP_TYPE		0x0f0
#define	OSF1_MAP_FIXED		0x100
#define	OSF1_MAP_HASSEMAPHORE	0x200
#define	OSF1_MAP_INHERIT	0x400
#define	OSF1_MAP_UNALIGNED	0x800
d148 1
a148 56
int
osf1_sys_mmap(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_mmap_args /* {
		syscallarg(caddr_t) addr;
		syscallarg(size_t) len;
		syscallarg(int) prot;
		syscallarg(int) flags;
		syscallarg(int) fd;
		syscallarg(off_t) pos;  
	} */ *uap = v;
	struct sys_mmap_args /* {
		syscallarg(caddr_t) addr;
		syscallarg(size_t) len;
		syscallarg(int) prot;
		syscallarg(int) flags;
		syscallarg(int) fd;
		syscallarg(long) pad;
		syscallarg(off_t) pos;
	} */ a;

	SCARG(&a, addr) = SCARG(uap, addr);
	SCARG(&a, len) = SCARG(uap, len);
	SCARG(&a, prot) = SCARG(uap, prot);
	SCARG(&a, fd) = SCARG(uap, fd);
	SCARG(&a, pad) = 0;
	SCARG(&a, pos) = SCARG(uap, pos);

	SCARG(&a, flags) = 0;
	if (SCARG(uap, flags) & OSF1_MAP_SHARED)
		SCARG(&a, flags) |= MAP_SHARED;
	if (SCARG(uap, flags) & OSF1_MAP_PRIVATE)
		SCARG(&a, flags) |= MAP_PRIVATE;
	switch (SCARG(uap, flags) & OSF1_MAP_TYPE) {
	case OSF1_MAP_ANONYMOUS:
		SCARG(&a, flags) |= MAP_ANON;
		break;
	case OSF1_MAP_FILE:
		SCARG(&a, flags) |= MAP_FILE;
		break;
	default:
		return (EINVAL);
	}
	if (SCARG(uap, flags) & OSF1_MAP_FIXED)
		SCARG(&a, flags) |= MAP_FIXED;
	if (SCARG(uap, flags) & OSF1_MAP_HASSEMAPHORE)
		SCARG(&a, flags) |= MAP_HASSEMAPHORE;
	if (SCARG(uap, flags) & OSF1_MAP_INHERIT)
		SCARG(&a, flags) |= MAP_INHERIT;
	if (SCARG(uap, flags) & OSF1_MAP_UNALIGNED)
		return (EINVAL);

	return sys_mmap(p, &a, retval);
d152 1
a152 1
osf1_sys_usleep_thread(p, v, retval)
a156 7
	struct osf1_sys_usleep_thread_args /* {
		syscallarg(struct timeval *) sleep;
		syscallarg(struct timeval *) slept;
	} */ *uap = v;
	struct timeval tv, endtv;
	u_long ticks;
	int error, s;
d158 2
a159 20
	if ((error = copyin(SCARG(uap, sleep), &tv, sizeof tv)) != 0)
		return (error);

	ticks = ((u_long)tv.tv_sec * 1000000 + tv.tv_usec) / tick;
	s = splclock();
	tv = time;
	splx(s);

	tsleep(p, PUSER|PCATCH, "OSF/1", ticks);	/* XXX */

	if (SCARG(uap, slept) != NULL) {
		s = splclock();
		timersub(&time, &tv, &endtv);
		splx(s);
		if (tv.tv_sec < 0 || tv.tv_usec < 0)
			tv.tv_sec = tv.tv_usec = 0;

		error = copyout(&endtv, SCARG(uap, slept), sizeof endtv);
	}
	return (error);
a161 25
struct osf1_stat {
	int32_t		st_dev;
	u_int32_t	st_ino;
	u_int32_t	st_mode;
	u_int16_t	st_nlink;
	u_int32_t	st_uid;
	u_int32_t	st_gid;
	int32_t		st_rdev;
	u_int64_t	st_size;
	int32_t		st_atime_sec;
	int32_t		st_spare1;
	int32_t		st_mtime_sec;
	int32_t		st_spare2;
	int32_t		st_ctime_sec;
	int32_t		st_spare3;
	u_int32_t	st_blksize;
	int32_t		st_blocks;
	u_int32_t	st_flags;
	u_int32_t	st_gen;
};

/*
 * Get file status; this version follows links.
 */
/* ARGSUSED */
d163 1
a163 1
osf1_sys_stat(p, v, retval)
d168 2
a169 6
	register struct osf1_sys_stat_args /* {
		syscallarg(char *) path;
		syscallarg(struct osf1_stat *) ub;
	} */ *uap = v;
	struct stat sb;
	struct osf1_stat osb;
a170 1
	struct nameidata nd;
d172 6
a177 31
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	error = vn_stat(nd.ni_vp, &sb, p);
	vput(nd.ni_vp);
	if (error)
		return (error);
	cvtstat2osf1(&sb, &osb);
	error = copyout((caddr_t)&osb, (caddr_t)SCARG(uap, ub), sizeof (osb));
	return (error);
}

/*
 * Get file status; this version does not follow links.
 */
/* ARGSUSED */
int
osf1_sys_lstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct osf1_sys_lstat_args /* {
		syscallarg(char *) path;
		syscallarg(struct osf1_stat *) ub;
	} */ *uap = v;
	struct stat sb;
	struct osf1_stat osb;
	int error;
	struct nameidata nd;
d179 2
a180 39
	NDINIT(&nd, LOOKUP, NOFOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	error = vn_stat(nd.ni_vp, &sb, p);
	vput(nd.ni_vp);
	if (error)
		return (error);
	cvtstat2osf1(&sb, &osb);
	error = copyout((caddr_t)&osb, (caddr_t)SCARG(uap, ub), sizeof (osb));
	return (error);
}

/*
 * Return status information about a file descriptor.
 */
int
osf1_sys_fstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct osf1_sys_fstat_args /* {
		syscallarg(int) fd;
		syscallarg(struct osf1_stat *) sb;
	} */ *uap = v;
	register struct filedesc *fdp = p->p_fd;
	register struct file *fp;
	struct stat ub;
	struct osf1_stat oub;
	int error;

	if ((unsigned)SCARG(uap, fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
		return (EBADF);
	switch (fp->f_type) {

	case DTYPE_VNODE:
		error = vn_stat((struct vnode *)fp->f_data, &ub, p);
d183 2
a184 2
	case DTYPE_SOCKET:
		error = soo_stat((struct socket *)fp->f_data, &ub);
d187 2
a188 73
	default:
		panic("ofstat");
		/*NOTREACHED*/
	}
	cvtstat2osf1(&ub, &oub);
	if (error == 0)
		error = copyout((caddr_t)&oub, (caddr_t)SCARG(uap, sb),
		    sizeof (oub));
	return (error);
}

#define	bsd2osf_dev(dev)	(major(dev) << 20 | minor(dev))
#define	osf2bsd_dev(dev)	makedev((dev >> 20) & 0xfff, dev & 0xfffff)

/*
 * Convert from a stat structure to an osf1 stat structure.
 */
void
cvtstat2osf1(st, ost)
	struct stat *st;
	struct osf1_stat *ost;
{

	ost->st_dev = bsd2osf_dev(st->st_dev);
	ost->st_ino = st->st_ino;
	ost->st_mode = st->st_mode;
	ost->st_nlink = st->st_nlink;
	ost->st_uid = st->st_uid == -2 ? (u_int16_t) -2 : st->st_uid;
	ost->st_gid = st->st_gid == -2 ? (u_int16_t) -2 : st->st_gid;
	ost->st_rdev = bsd2osf_dev(st->st_rdev);
	ost->st_size = st->st_size;
	ost->st_atime_sec = st->st_atime;
	ost->st_spare1 = 0;
	ost->st_mtime_sec = st->st_mtime;
	ost->st_spare2 = 0;
	ost->st_ctime_sec = st->st_ctime;
	ost->st_spare3 = 0;
	ost->st_blksize = st->st_blksize;
	ost->st_blocks = st->st_blocks;
	ost->st_flags = st->st_flags;
	ost->st_gen = st->st_gen;
}

int
osf1_sys_mknod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_mknod_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
		syscallarg(int) dev;
	} */ *uap = v;
	struct sys_mknod_args a;

	SCARG(&a, path) = SCARG(uap, path);
	SCARG(&a, mode) = SCARG(uap, mode);
	SCARG(&a, dev) = osf2bsd_dev(SCARG(uap, dev));

	return sys_mknod(p, &a, retval);
}

#define OSF1_F_DUPFD	0
#define	OSF1_F_GETFD	1
#define	OSF1_F_SETFD	2
#define	OSF1_F_GETFL	3
#define	OSF1_F_SETFL	4

#define	OSF1_FAPPEND	0x00008		/* XXX OSF1_O_APPEND */
#define	OSF1_FNONBLOCK	0x00004		/* XXX OSF1_O_NONBLOCK */
#define	OSF1_FASYNC	0x00040
#define	OSF1_FSYNC	0x04000		/* XXX OSF1_O_SYNC */
d190 2
a191 21
int
osf1_sys_fcntl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_fcntl_args /* {
		syscallarg(int) fd;
		syscallarg(int) cmd;
		syscallarg(void *) arg;
	} */ *uap = v;
	struct sys_fcntl_args a;
	long tmp;
	int error;

	SCARG(&a, fd) = SCARG(uap, fd);

	switch (SCARG(uap, cmd)) {
	case OSF1_F_DUPFD:
		SCARG(&a, cmd) = F_DUPFD;
		SCARG(&a, arg) = SCARG(uap, arg);
d194 2
a195 3
	case OSF1_F_GETFD:
		SCARG(&a, cmd) = F_GETFD;
		SCARG(&a, arg) = SCARG(uap, arg);
d198 2
a199 3
	case OSF1_F_SETFD:
		SCARG(&a, cmd) = F_SETFD;
		SCARG(&a, arg) = SCARG(uap, arg);
d202 2
a203 3
	case OSF1_F_GETFL:
		SCARG(&a, cmd) = F_GETFL;
		SCARG(&a, arg) = SCARG(uap, arg);		/* ignored */
d206 2
a207 13
	case OSF1_F_SETFL:
		SCARG(&a, cmd) = F_SETFL;
		tmp = 0;
		if ((long)SCARG(uap, arg) & OSF1_FAPPEND)
			tmp |= FAPPEND;
		if ((long)SCARG(uap, arg) & OSF1_FNONBLOCK)
			tmp |= FNONBLOCK;
		if ((long)SCARG(uap, arg) & OSF1_FASYNC)
			tmp |= FASYNC;
		if ((long)SCARG(uap, arg) & OSF1_FSYNC)
			tmp |= FFSYNC;
		SCARG(&a, arg) = (void *)tmp;
		break;
d209 2
a210 3
	default:					/* XXX other cases */
		return (EINVAL);
	}
d212 2
a213 1
	error = sys_fcntl(p, &a, retval);
d215 2
a216 2
	if (error)
		return error;
d218 6
a223 3
	switch (SCARG(uap, cmd)) {
	case OSF1_F_GETFL:
		/* XXX */
d225 1
a225 1
	}
d227 3
a229 2
	return error;
}
d231 1
a231 18
int
osf1_sys_poll(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct osf1_sys_poll_args /* {
		syscallarg(struct pollfd *) fds;
		syscallarg(unsigned int) nfds;
		syscallarg(int) timeout;
	} */ *uap = v;
	struct sys_poll_args a;

	SCARG(&a, fds) = SCARG(uap, fds);
	SCARG(&a, nfds) = SCARG(uap, nfds);
	SCARG(&a, timeout) = SCARG(uap, timeout);

	return sys_poll(p, &a, retval);
d235 1
a235 1
osf1_sys_socket(p, v, retval)
d240 25
a264 15
	register struct osf1_sys_socket_args /* {
		syscallarg(int) domain;
		syscallarg(int) type;
		syscallarg(int) protocol;
	} */ *uap = v;
	struct sys_socket_args a;

	if (SCARG(uap, type) > AF_LINK)
		return (EINVAL);	/* XXX After AF_LINK, divergence. */

	SCARG(&a, domain) = SCARG(uap, domain);
	SCARG(&a, type) = SCARG(uap, type);
	SCARG(&a, protocol) = SCARG(uap, protocol);

	return sys_socket(p, &a, retval);
d268 1
a268 1
osf1_sys_sendto(p, v, retval)
d273 5
a277 9
	register struct osf1_sys_sendto_args /* {
		syscallarg(int) s;
		syscallarg(const void *) buf;
		syscallarg(size_t) len;
		syscallarg(int) flags;
		syscallarg(const struct sockaddr *) to;
		syscallarg(int) tolen;
	} */ *uap = v;
	struct sys_sendto_args a;
d279 4
a282 2
	if (SCARG(uap, flags) & ~0x7f)		/* unsupported flags */
		return (EINVAL);
d284 3
a286 6
	SCARG(&a, s) = SCARG(uap, s);
	SCARG(&a, buf) = SCARG(uap, buf);
	SCARG(&a, len) = SCARG(uap, len);
	SCARG(&a, flags) = SCARG(uap, flags);
	SCARG(&a, to) = SCARG(uap, to);
	SCARG(&a, tolen) = SCARG(uap, tolen);
d288 3
a290 2
	return sys_sendto(p, &a, retval);
}
d292 1
a292 9
#define	OSF1_RB_ASKNAME		0x001
#define	OSF1_RB_SINGLE		0x002
#define	OSF1_RB_NOSYNC		0x004
#define	OSF1_RB_HALT		0x008
#define	OSF1_RB_INITNAME	0x010
#define	OSF1_RB_DFLTROOT	0x020
#define	OSF1_RB_ALTBOOT		0x040
#define	OSF1_RB_UNIPROC		0x080
#define	OSF1_RB_ALLFLAGS	0x0ff		/* all of the above */
d294 6
a299 83
int
osf1_sys_reboot(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_reboot_args /* {
		syscallarg(int) opt;
	} */ *uap = v;
	struct sys_reboot_args a;

	if (SCARG(uap, opt) & ~OSF1_RB_ALLFLAGS &&
	    SCARG(uap, opt) & (OSF1_RB_ALTBOOT|OSF1_RB_UNIPROC))
		return (EINVAL);

	SCARG(&a, opt) = 0;
	if (SCARG(uap, opt) & OSF1_RB_ASKNAME)
		SCARG(&a, opt) |= RB_ASKNAME;
	if (SCARG(uap, opt) & OSF1_RB_SINGLE)
		SCARG(&a, opt) |= RB_SINGLE;
	if (SCARG(uap, opt) & OSF1_RB_NOSYNC)
		SCARG(&a, opt) |= RB_NOSYNC;
	if (SCARG(uap, opt) & OSF1_RB_HALT)
		SCARG(&a, opt) |= RB_HALT;
	if (SCARG(uap, opt) & OSF1_RB_INITNAME)
		SCARG(&a, opt) |= RB_INITNAME;
	if (SCARG(uap, opt) & OSF1_RB_DFLTROOT)
		SCARG(&a, opt) |= RB_DFLTROOT;

	return sys_reboot(p, &a, retval);
}

int
osf1_sys_lseek(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_lseek_args /* {  
		syscallarg(int) fd;  
		syscallarg(off_t) offset;
		syscallarg(int) whence;
	} */ *uap = v;
	struct sys_lseek_args a;

	SCARG(&a, fd) = SCARG(uap, fd);
	SCARG(&a, pad) = 0;
	SCARG(&a, offset) = SCARG(uap, offset);
	SCARG(&a, whence) = SCARG(uap, whence);

	return sys_lseek(p, &a, retval);
}

/*
 * OSF/1 defines _POSIX_SAVED_IDS, which means that our normal
 * setuid() won't work.
 *
 * Instead, by P1003.1b-1993, setuid() is supposed to work like:
 *	If the process has appropriate [super-user] priviledges, the
 *	    setuid() function sets the real user ID, effective user
 *	    ID, and the saved set-user-ID to uid.
 *	If the process does not have appropriate priviledges, but uid
 *	    is equal to the real user ID or the saved set-user-ID, the
 *	    setuid() function sets the effective user ID to uid; the
 *	    real user ID and saved set-user-ID remain unchanged by
 *	    this function call.
 */
int
osf1_sys_setuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_setuid_args /* { 
		syscallargs(uid_t) uid;
	} */ *uap = v;
	register struct pcred *pc = p->p_cred;
	uid_t uid = SCARG(uap, uid);
	int error;

	if ((error = suser(pc->pc_ucred, &p->p_acflag)) != 0 &&
	    uid != pc->p_ruid && uid != pc->p_svuid)
		return (error);
d301 3
a303 7
	pc->pc_ucred = crcopy(pc->pc_ucred);
	pc->pc_ucred->cr_uid = uid;
	if (error == 0) {
	        (void)chgproccnt(pc->p_ruid, -1);
	        (void)chgproccnt(uid, 1);
		pc->p_ruid = uid;
		pc->p_svuid = uid;
d305 1
a305 2
	p->p_flag |= P_SUGID;
	return (0);
a307 7
/*
 * OSF/1 defines _POSIX_SAVED_IDS, which means that our normal
 * setgid() won't work.
 *
 * If you change "uid" to "gid" in the discussion, above, about
 * setuid(), you'll get a correct description of setgid().
 */
d309 1
a309 1
osf1_sys_setgid(p, v, retval)
d314 6
a319 5
	struct osf1_sys_setgid_args /* {
		syscallargs(gid_t) gid;
	} */ *uap = v;
	register struct pcred *pc = p->p_cred;
	gid_t gid = SCARG(uap, gid);
d322 2
a323 3
	if ((error = suser(pc->pc_ucred, &p->p_acflag)) != 0 &&
	    gid != pc->p_rgid && gid != pc->p_svgid)
		return (error);
d325 4
a328 41
	pc->pc_ucred = crcopy(pc->pc_ucred);
	pc->pc_ucred->cr_gid = gid;
	if (error == 0) {
		pc->p_rgid = gid;
		pc->p_svgid = gid;
	}
	p->p_flag |= P_SUGID;
	return (0);
}

/*
 * The structures end up being the same... but we can't be sure that
 * the other word of our iov_len is zero!
 */
struct osf1_iovec {
	char	*iov_base;
	int	iov_len;
};

int
osf1_sys_readv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_readv_args /* {
		syscallarg(int) fd;
		syscallarg(struct osf1_iovec *) iovp;
		syscallarg(u_int) iovcnt;
	} */ *uap = v;
	struct sys_readv_args /* {
		syscallarg(int) fd;
		syscallarg(struct iovec *) iovp;
		syscallarg(u_int) iovcnt;
	} */ a;
	struct emul *e = p->p_emul;
	struct osf1_iovec *oio;
	struct iovec *nio;
	int error, i;

	if (SCARG(uap, iovcnt) > (STACKGAPLEN / sizeof (struct iovec)))
d331 5
a335 13
	oio = (struct osf1_iovec *)
	    malloc(SCARG(uap, iovcnt)*sizeof (struct osf1_iovec),
	    M_TEMP, M_WAITOK);
	nio = (struct iovec *)malloc(SCARG(uap, iovcnt)*sizeof (struct iovec),
	    M_TEMP, M_WAITOK);

	error = 0;
	if ((error = copyin(SCARG(uap, iovp), oio,
	    SCARG(uap, iovcnt) * sizeof (struct osf1_iovec))) != 0)
		goto punt;
	for (i = 0; i < SCARG(uap, iovcnt); i++) {
		nio[i].iov_base = oio[i].iov_base;
		nio[i].iov_len = oio[i].iov_len;
d338 1
a338 38
	SCARG(&a, fd) = SCARG(uap, fd);
	SCARG(&a, iovp) = (struct iovec *)STACKGAPBASE;
	SCARG(&a, iovcnt) = SCARG(uap, iovcnt);

	if ((error = copyout(nio, (caddr_t)SCARG(&a, iovp),
	    SCARG(uap, iovcnt) * sizeof (struct iovec))) != 0)
		goto punt;
	error = sys_readv(p, &a, retval);

punt:
	free(oio, M_TEMP);
	free(nio, M_TEMP);
	return (error);
}

int
osf1_sys_writev(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_writev_args /* {
		syscallarg(int) fd;
		syscallarg(struct osf1_iovec *) iovp;
		syscallarg(u_int) iovcnt;
	} */ *uap = v;
	struct sys_writev_args /* {
		syscallarg(int) fd;
		syscallarg(struct iovec *) iovp;
		syscallarg(u_int) iovcnt;
	} */ a;
	struct emul *e = p->p_emul;
	struct osf1_iovec *oio;
	struct iovec *nio;
	int error, i;

	if (SCARG(uap, iovcnt) > (STACKGAPLEN / sizeof (struct iovec)))
		return (EINVAL);
d340 9
a348 13
	oio = (struct osf1_iovec *)
	    malloc(SCARG(uap, iovcnt)*sizeof (struct osf1_iovec),
	    M_TEMP, M_WAITOK);
	nio = (struct iovec *)malloc(SCARG(uap, iovcnt)*sizeof (struct iovec),
	    M_TEMP, M_WAITOK);

	error = 0;
	if ((error = copyin(SCARG(uap, iovp), oio,
	    SCARG(uap, iovcnt) * sizeof (struct osf1_iovec))) != 0)
		goto punt;
	for (i = 0; i < SCARG(uap, iovcnt); i++) {
		nio[i].iov_base = oio[i].iov_base;
		nio[i].iov_len = oio[i].iov_len;
a350 12
	SCARG(&a, fd) = SCARG(uap, fd);
	SCARG(&a, iovp) = (struct iovec *)STACKGAPBASE;
	SCARG(&a, iovcnt) = SCARG(uap, iovcnt);

	if ((error = copyout(nio, (caddr_t)SCARG(&a, iovp),
	    SCARG(uap, iovcnt) * sizeof (struct iovec))) != 0)
		goto punt;
	error = sys_writev(p, &a, retval);

punt:
	free(oio, M_TEMP);
	free(nio, M_TEMP);
a351 97
}

/* More of the stupid off_t padding! */
int
osf1_sys_truncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_truncate_args /* {
		syscallarg(char *) path;
		syscallarg(off_t) length;
	} */ *uap = v;
	struct sys_truncate_args a;

	SCARG(&a, path) = SCARG(uap, path);
	SCARG(&a, pad) = 0;
	SCARG(&a, length) = SCARG(uap, length);

	return sys_truncate(p, &a, retval);
}

int
osf1_sys_ftruncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_ftruncate_args /* {
		syscallarg(int) fd;
		syscallarg(off_t) length;
	} */ *uap = v;
	struct sys_ftruncate_args a;

	SCARG(&a, fd) = SCARG(uap, fd);
	SCARG(&a, pad) = 0;
	SCARG(&a, length) = SCARG(uap, length);

	return sys_ftruncate(p, &a, retval);
}

int
osf1_sys_getsid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_getsid_args /* {  
		syscallarg(pid_t) pid;  
	} */ *uap = v;
	struct proc *t;

	if (SCARG(uap, pid) == 0)
		t = p;
	else if ((t = pfind(SCARG(uap, pid))) == NULL)
		return (ESRCH);

	*retval = t->p_session->s_leader->p_pid;
	return (0);
}

int
osf1_sys_getrusage(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	/* XXX */
	return EINVAL;
}

int
osf1_sys_madvise(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	/* XXX */
	return EINVAL;
}

int
osf1_sys_execve(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct osf1_sys_execve_args *uap = v;
#if 0
	caddr_t sg = stackgap_init(p->p_emul);

	OSF1_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
#endif

	return (sys_execve(p, (struct sys_execve_args *)&uap, retval));
@


1.11.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 32
/* $OpenBSD: osf1_misc.c,v 1.13 2000/08/12 20:46:42 ericj Exp $ */
/* $NetBSD: osf1_misc.c,v 1.55 2000/06/28 15:39:33 mrg Exp $ */

/*
 * Copyright (c) 1999 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
d44 1
a46 1
#include <sys/exec.h>
a47 4
#include <sys/socketvar.h>
#include <sys/resource.h>
#include <sys/resourcevar.h>
#include <sys/wait.h>
d49 1
a49 1
#include <compat/osf1/osf1.h>
d52 2
a53 1
#include <compat/osf1/osf1_cvt.h>
d57 1
d60 27
a86 1
const char osf1_emul_path[] = "/emul/osf1";
d89 1
a89 1
osf1_sys_classcntl(p, v, retval)
d94 65
d160 9
a168 2
	/* XXX */
	return (ENOSYS);
d172 1
a172 1
osf1_sys_reboot(p, v, retval)
d177 8
a184 3
	struct osf1_sys_reboot_args *uap = v;
	struct sys_reboot_args a;
	unsigned long leftovers;
d186 1
a186 4
	/* translate opt */
	SCARG(&a, opt) = emul_flags_translate(osf1_reboot_opt_xtab,
	    SCARG(uap, opt), &leftovers);
	if (leftovers != 0)
d189 75
a263 1
	/* SCARG(&a, bootstr) = NULL; */
d265 1
a265 1
	return sys_reboot(p, &a, retval);
d269 1
a269 1
osf1_sys_set_program_attributes(p, v, retval)
d274 7
a280 2
	struct osf1_sys_set_program_attributes_args *uap = v;
	segsz_t tsize, dsize;
d282 2
a283 2
	tsize = btoc(SCARG(uap, tsize));
	dsize = btoc(SCARG(uap, dsize));
d285 4
a288 4
	if (dsize > p->p_rlimit[RLIMIT_DATA].rlim_cur)
		return (ENOMEM);
	if (tsize > MAXTSIZ)
		return (ENOMEM);
d290 8
a297 4
	p->p_vmspace->vm_taddr = SCARG(uap, taddr);
	p->p_vmspace->vm_tsize = tsize;
	p->p_vmspace->vm_daddr = SCARG(uap, daddr);
	p->p_vmspace->vm_dsize = dsize;
d299 56
a354 1
	return (0);
d357 4
d362 1
a362 1
osf1_sys_setsysinfo(p, v, retval)
d367 8
d376 11
a386 2
	/* XXX */
	return (0);
d389 3
d393 1
a393 1
osf1_sys_sysinfo(p, v, retval)
d398 8
a405 2
	struct osf1_sys_sysinfo_args *uap = v;
	const char *string;
d408 7
a414 5
	error = 0;
	switch (SCARG(uap, cmd)) {
	case OSF1_SI_SYSNAME:
		goto should_handle;
		/* string = ostype; */
d417 2
a418 2
	case OSF1_SI_HOSTNAME:
		string = hostname;
d421 88
a508 3
	case OSF1_SI_RELEASE:
		string = version;
		break;
d510 1
a510 2
	case OSF1_SI_VERSION:
		goto should_handle;
d512 4
a515 2
	case OSF1_SI_MACHINE:
		string = MACHINE;
d518 3
a520 2
	case OSF1_SI_ARCHITECTURE:
		string = MACHINE_ARCH;
d523 3
a525 2
	case OSF1_SI_HW_SERIAL:
		string = "666";			/* OSF/1 emulation?  YES! */
d528 3
a530 2
	case OSF1_SI_HW_PROVIDER:
		string = "unknown";
d533 13
a545 2
	case OSF1_SI_SRPC_DOMAIN:
		goto dont_care;
d547 3
a549 2
	case OSF1_SI_SET_HOSTNAME:
		goto should_handle;
d551 1
a551 2
	case OSF1_SI_SET_SYSNAME:
		goto should_handle;
d553 2
a554 2
	case OSF1_SI_SET_SRPC_DOMAIN:
		goto dont_care;
d556 3
a558 6
	default:
should_handle:
		printf("osf1_sys_sysinfo(%d, %p, 0x%lx)\n", SCARG(uap, cmd),
		    SCARG(uap, buf), SCARG(uap,len));
dont_care:
		error = EINVAL;
d560 1
a560 5
	};

	if (error == 0)
		error = copyoutstr(string, SCARG(uap, buf), SCARG(uap, len),
		    NULL);
d562 1
a562 1
	return (error);
d566 1
a566 1
osf1_sys_uname(p, v, retval)
d571 10
a580 5
	struct osf1_sys_uname_args *uap = v;
        struct osf1_utsname u;
        const char *cp;
	extern char ostype[], hostname[], osrelease[], version[], machine[];
        char *dp, *ep;
d582 2
a583 1
	/* XXX would use stackgap, but our struct utsname is too big! */
d585 19
a603 4
	bzero(&u, sizeof(u));
	
        strncpy(u.sysname, ostype, sizeof(u.sysname));
	u.sysname[sizeof(u.sysname) - 1] = '\0';
d605 2
a606 2
        strncpy(u.nodename, hostname, sizeof(u.nodename));
	u.nodename[sizeof(u.nodename) - 1] = '\0';
d608 15
a622 2
        strncpy(u.release, osrelease, sizeof(u.release));
	u.release[sizeof(u.release) - 1] = '\0';
d624 2
a625 11
        dp = u.version;
        ep = &u.version[sizeof(u.version) - 1];
        for (cp = version; *cp && *cp != '('; cp++)
                ;
        for (cp++; *cp && *cp != ')' && dp < ep; cp++)
                *dp++ = *cp;
        for (; *cp && *cp != '#'; cp++)
                ;
        for (; *cp && *cp != ':' && dp < ep; cp++)
                *dp++ = *cp;
        *dp = '\0';
d627 6
a632 2
        strncpy(u.machine, machine, sizeof(u.machine));
	u.machine[sizeof(u.machine) - 1] = '\0';
d634 1
a634 1
        return (copyout((caddr_t)&u, (caddr_t)SCARG(uap, name), sizeof u));
d637 10
d648 1
a648 1
osf1_sys_usleep_thread(p, v, retval)
d653 22
a674 5
	struct osf1_sys_usleep_thread_args *uap = v;
	struct osf1_timeval otv, endotv;
	struct timeval tv, endtv;
	u_long ticks;
	int error, s;
d676 2
a677 4
	if ((error = copyin(SCARG(uap, sleep), &otv, sizeof otv)))
		return (error);
	tv.tv_sec = otv.tv_sec;
	tv.tv_usec = otv.tv_usec;
d679 17
a695 3
	ticks = howmany((u_long)tv.tv_sec * 1000000 + tv.tv_usec, tick);
	if (ticks == 0)
		ticks = 1;
d697 2
a698 3
	s = splclock();
	tv = time;
	splx(s);
d700 26
a725 1
	tsleep(p, PUSER|PCATCH, "uslpthrd", ticks);	/* XXX */
d727 3
a729 6
	if (SCARG(uap, slept) != NULL) {
		s = splclock();
		timersub(&time, &tv, &endtv);
		splx(s);
		if (endtv.tv_sec < 0 || endtv.tv_usec < 0)
			endtv.tv_sec = endtv.tv_usec = 0;
d731 7
a737 3
		endotv.tv_sec = endtv.tv_sec;
		endotv.tv_usec = endtv.tv_usec;
		error = copyout(&endotv, SCARG(uap, slept), sizeof endotv);
d739 2
a740 1
	return (error);
d743 7
d751 1
a751 1
osf1_sys_wait4(p, v, retval)
d756 5
a760 6
	struct osf1_sys_wait4_args *uap = v;
	struct sys_wait4_args a;
	struct osf1_rusage osf1_rusage;
	struct rusage netbsd_rusage;
	unsigned long leftovers;
	caddr_t sg;
d763 13
a775 2
	SCARG(&a, pid) = SCARG(uap, pid);
	SCARG(&a, status) = SCARG(uap, status);
d777 31
a807 4
	/* translate options */
	SCARG(&a, options) = emul_flags_translate(osf1_wait_options_xtab,
	    SCARG(uap, options), &leftovers);
	if (leftovers != 0)
d810 13
a822 5
	if (SCARG(uap, rusage) == NULL)
		SCARG(&a, rusage) = NULL;
	else {
		sg = stackgap_init(p->p_emul);
		SCARG(&a, rusage) = stackgap_alloc(&sg, sizeof netbsd_rusage);
d825 14
a838 1
	error = sys_wait4(p, &a, retval);
d840 37
a876 9
	if (error == 0 && SCARG(&a, rusage) != NULL) {
		error = copyin((caddr_t)SCARG(&a, rusage),
		    (caddr_t)&netbsd_rusage, sizeof netbsd_rusage);
		if (error == 0) {
			osf1_cvt_rusage_from_native(&netbsd_rusage,
			    &osf1_rusage);
			error = copyout((caddr_t)&osf1_rusage,
			    (caddr_t)SCARG(uap, rusage), sizeof osf1_rusage);
		}
d879 12
d892 97
@


1.11.2.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d243 1
a243 1
	extern char hostname[], machine[];
@


1.10
log
@remove unnecessary decls
@
text
@d1 1
a1 1
/*	$OpenBSD: osf1_misc.c,v 1.9 1998/02/17 01:48:07 millert Exp $	*/
d57 1
a60 1
extern char *osf1_syscallnames[];
d75 1
d77 3
@


1.9
log
@make COMPAT_OSF1 compile again
@
text
@d1 1
a1 1
/*	$OpenBSD: osf1_misc.c,v 1.8 1996/10/30 16:37:19 niklas Exp $	*/
a801 1
	extern char sigcode[], esigcode[];
a855 1
	extern char sigcode[], esigcode[];
@


1.8
log
@More -Wall happiness
@
text
@d1 1
a1 1
/*	$OpenBSD: osf1_misc.c,v 1.7 1996/10/17 19:15:49 niklas Exp $	*/
d612 1
a612 1
		syscallarg(caddr_t) buf;
d615 1
a615 1
		syscallarg(caddr_t) to;
@


1.7
log
@Contextual goo for -Wall, and remove some stasic specifiers
@
text
@d1 1
a1 1
/*	$OpenBSD: osf1_misc.c,v 1.5 1996/08/31 09:24:03 pefo Exp $	*/
d44 1
d47 1
d66 2
d121 1
d129 1
d138 1
d167 1
d278 1
a278 1
	if (error = copyin(SCARG(uap, sleep), &tv, sizeof tv))
d325 1
d342 1
a342 1
	if (error = namei(&nd))
d357 1
d374 1
a374 1
	if (error = namei(&nd))
d388 1
d434 1
d814 2
a815 2
	if (error = copyin(SCARG(uap, iovp), oio,
	    SCARG(uap, iovcnt) * sizeof (struct osf1_iovec)))
d826 2
a827 2
	if (error = copyout(nio, (caddr_t)SCARG(&a, iovp),
	    SCARG(uap, iovcnt) * sizeof (struct iovec)))
d869 2
a870 2
	if (error = copyin(SCARG(uap, iovp), oio,
	    SCARG(uap, iovcnt) * sizeof (struct osf1_iovec)))
d881 2
a882 2
	if (error = copyout(nio, (caddr_t)SCARG(&a, iovp),
	    SCARG(uap, iovcnt) * sizeof (struct iovec)))
d980 2
a982 2
	caddr_t sg = stackgap_init(p->p_emul);
#if 0
@


1.6
log
@Argh, fix a stupid typo
@
text
@d970 1
d972 1
@


1.5
log
@Cleanup exec
@
text
@d1 1
a1 1
2/*	$OpenBSD: osf1_misc.c,v 1.4 1996/08/25 12:19:53 deraadt Exp $	*/
@


1.4
log
@route execve via compat filename translation
@
text
@d1 1
a1 1
2/*	$OpenBSD: osf1_misc.c,v 1.3 1996/08/23 11:46:51 niklas Exp $	*/
d75 1
@


1.3
log
@Fix sys_poll wrapper so it compiles
@
text
@d1 1
a1 1
/*	$OpenBSD: osf1_misc.c,v 1.2 1996/08/02 20:20:29 niklas Exp $	*/
d958 14
@


1.2
log
@Make emulations use our native poll(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: osf1_misc.c,v 1.7 1995/10/07 06:53:04 mycroft Exp $	*/
d561 3
a563 3
	SCARG(&a, fds) = fds;
	SCARG(&a, nfds) = nfds;
	SCARG(&a, timeout) = timeout;
d565 1
a565 1
	return sys_poll(p, a, retval);
@


1.1
log
@Initial revision
@
text
@d1 1
d546 20
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

