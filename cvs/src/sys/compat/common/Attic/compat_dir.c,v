head	1.12;
access;
symbols
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.5.0.20
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.18
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.16
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.14
	OPENBSD_5_0:1.5.0.12
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.10
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.8
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.4
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.4.0.22
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.20
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.18
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.16
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.14
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.12
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.10
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.8
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.6
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.2.0.8
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.12
date	2016.03.02.15.41.47;	author naddy;	state dead;
branches;
next	1.11;
commitid	ZfNt0OHZhMg52abA;

1.11
date	2014.12.16.21.25.28;	author tedu;	state Exp;
branches;
next	1.10;
commitid	tl2Y0qUSzXA2wuay;

1.10
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.9;
commitid	uzzBR7hz9ncd4O6G;

1.9
date	2014.07.12.18.50.00;	author tedu;	state Exp;
branches;
next	1.8;
commitid	C8XZQyreqTUCeixA;

1.8
date	2014.01.15.05.31.51;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2013.10.31.09.53.56;	author pirofti;	state Exp;
branches;
next	1.6;

1.6
date	2013.08.13.05.52.21;	author guenther;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.19.09.49.50;	author pedro;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.14.16.55.24;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.49;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.10.17.35.40;	author csapuntz;	state Exp;
branches
	1.2.4.1
	1.2.8.1;
next	1.1;

1.1
date	2001.01.23.05.48.04;	author csapuntz;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.22.04.17;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.28.11.28.05;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2004.02.19.10.51.28;	author niklas;	state Exp;
branches;
next	;

1.2.8.1
date	2002.06.11.03.28.07;	author art;	state Exp;
branches;
next	;


desc
@@


1.12
log
@remove the Linux emulation code, no longer referenced by anything
@
text
@/* 	$OpenBSD: compat_dir.c,v 1.11 2014/12/16 21:25:28 tedu Exp $	*/

/*
 * Copyright (c) 2000 Constantine Sapuntzakis
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/dirent.h>

#include <compat/common/compat_dir.h>

int
readdir_with_callback(struct file *fp, off_t *off, u_long nbytes,
    int (*appendfunc)(void *, struct dirent *), void *arg)
{
	struct dirent *bdp;
	caddr_t inp, buf;
	int buflen;
	struct uio auio;
	struct iovec aiov;
	int eofflag = 0;
	int error, len, reclen;
	off_t newoff = *off;
	struct vnode *vp;
	struct vattr va;
		
	if ((fp->f_flag & FREAD) == 0)
		return (EBADF);

	vp = (struct vnode *)fp->f_data;

	if (vp->v_type != VDIR)
		return (EINVAL);

	if ((error = VOP_GETATTR(vp, &va, fp->f_cred, curproc)) != 0)
		return (error);

	buflen = min(MAXBSIZE, nbytes);
	buflen = max(buflen, va.va_blocksize);
	buf = malloc(buflen, M_TEMP, M_WAITOK);
	error = vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, curproc);
	if (error) {
		free(buf, M_TEMP, 0);
		return (error);
	}

again:
	aiov.iov_base = buf;
	aiov.iov_len = buflen;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_procp = curproc;
	auio.uio_resid = buflen;
	auio.uio_offset = newoff;

	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag);
	*off = auio.uio_offset;
	if (error)
		goto out;

	if ((len = buflen - auio.uio_resid) <= 0)
		goto eof;	

	inp = buf;

	for (; len > 0; len -= reclen, inp += reclen) {
		bdp = (struct dirent *)inp;
		reclen = bdp->d_reclen;

		if (len < reclen)
			break;

		if (reclen & 3) {
			error = EFAULT;
			goto out;
		}

		/* Skip holes */
		if (bdp->d_fileno != 0) {
			if ((error = (*appendfunc) (arg, bdp)) != 0) {
				if (error == ENOMEM)
					error = 0;
				break;
			}
		}
	}

	if (len <= 0 && !eofflag)
		goto again;

eof:
out:
	VOP_UNLOCK(vp, 0, curproc);
	free(buf, M_TEMP, 0);
	return (error);
}
@


1.11
log
@must include lock.h to play with locks
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_dir.c,v 1.10 2014/09/14 14:17:23 jsg Exp $	*/
@


1.10
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_dir.c,v 1.9 2014/07/12 18:50:00 tedu Exp $	*/
d38 1
@


1.9
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_dir.c,v 1.8 2014/01/15 05:31:51 deraadt Exp $	*/
a30 1
#include <sys/proc.h>
@


1.8
log
@remove functions that were uses by other (non-linux) compat; and
convert to ANSI protos while here
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_dir.c,v 1.7 2013/10/31 09:53:56 pirofti Exp $	*/
d74 1
a74 1
		free(buf, M_TEMP);
d127 1
a127 1
	free(buf, M_TEMP);
@


1.7
log
@Fix readdir_with_callback() after cookies removal.

The non-cookie path was probably always broken and never used.

The file descriptor offset was never updated after a read so glibc and
other syscall consumers would end-up in an infinite loop.

Tested with the syscalls regression suite from IBM and with opera.
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_dir.c,v 1.6 2013/08/13 05:52:21 guenther Exp $	*/
d44 2
a45 6
readdir_with_callback(fp, off, nbytes, appendfunc, arg)
	struct file *fp;
	off_t *off;
	u_long nbytes;
	int (*appendfunc)(void *, struct dirent *);
	void *arg;
@


1.6
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_dir.c,v 1.5 2008/08/19 09:49:50 pedro Exp $	*/
d94 1
a129 3
	if (error == 0)
		*off = newoff;

@


1.5
log
@When failing to acquire the vnode lock in readdir_with_callback(), don't
try to release it before returning, okay fgsch@@ and tedu@@.
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_dir.c,v 1.4 2003/08/14 16:55:24 fgsch Exp $	*/
d48 1
a48 1
	int (*appendfunc)(void *, struct dirent *, off_t);
a56 2
	u_long *cookies = NULL, *cookiep;
	int ncookies = 0;
d93 1
a93 7
	if (cookies) {
		free(cookies, M_TEMP);
		cookies = NULL;
	}

	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, &ncookies,
	    &cookies);
a99 1
	cookiep = cookies;
a101 17
	if (cookies) {
		/*
		 * When using cookies, the vfs has the option of reading from
		 * a different offset than that supplied (UFS truncates the
		 * offset to a block boundary to make sure that it never reads
		 * partway through a directory entry, even if the directory
		 * has been compacted).
		 */
		while (len > 0 && ncookies > 0 && *cookiep <= newoff) {
			bdp = (struct dirent *)inp;
			len -= bdp->d_reclen;
			inp += bdp->d_reclen;
			cookiep++;
			ncookies--;
		}
	}

a102 3
		if (cookiep && ncookies == 0)
			break;

d116 1
a116 2
			if ((error = (*appendfunc) (arg, bdp,
			    (cookiep) ? *cookiep : (newoff + reclen))) != 0) {
a121 6

		if (cookiep) {
			newoff = *cookiep++;
			ncookies--;
		} else
			newoff += reclen;
a130 3

	if (cookies)
		free(cookies, M_TEMP);
@


1.4
log
@in some fs (ie. procfs), readdir won't return a cookie, so calculate
it based on the offset and reclen. with this, a emulated ls binary
(ie. linux) correctly list the files in such filesystems.  also plug some
memory leak and remove a unneeded panic.
adapted from FreeBSD.
henning@@ tedu@@ ok. some other people ok'ed this in the past as well.
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_dir.c,v 1.3 2002/03/14 01:26:49 millert Exp $	*/
d79 4
a82 2
	if (error)
		goto out;
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_dir.c,v 1.2 2001/04/10 17:35:40 csapuntz Exp $	*/
d51 1
d57 1
a57 1
	u_long *cookiebuf = NULL, *cookie;
d69 1
a69 1
	if (vp->v_type != VDIR)	/* XXX  vnode readdir op should do this */
d92 6
a97 1
	
d99 1
a99 1
	    &cookiebuf);
d103 1
a103 1
	if ((len = buflen - auio.uio_resid) == 0)
d106 18
a123 3
	if (cookiebuf == NULL) {
		error = EPERM;
		goto out;
d126 3
a128 2
	cookie = cookiebuf;
	inp = buf;
d130 1
a130 4
	for (;
	     len > 0;
	     len -= reclen, inp += reclen, ++cookie) {
		struct dirent *bdp = (struct dirent *)inp;
d133 7
a139 3
		if (len < reclen) break;
		if (reclen & 3)
			panic("readdir_with_callback: bad reclen");
d143 2
a144 2
			if ((error = (*appendfunc) (arg, bdp, *cookie)) 
			    != 0) {
d151 5
a155 1
		newoff = *cookie;
d161 3
a163 3
 eof:
 out:
	if (error == 0) 
d166 3
a169 2
	if (cookiebuf)
		free(cookiebuf, M_TEMP);
@


1.2
log
@

Don't seg-fault on file systems that don't support cookies. Thanks to
Jason Ish for finding this one.
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_dir.c,v 1.1 2001/01/23 05:48:04 csapuntz Exp $	*/
d48 1
a48 1
	int (*appendfunc) __P((void *, struct dirent *, off_t));
@


1.2.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_dir.c,v 1.2 2001/04/10 17:35:40 csapuntz Exp $	*/
d48 1
a48 1
	int (*appendfunc)(void *, struct dirent *, off_t);
@


1.2.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_dir.c,v 1.2 2001/04/10 17:35:40 csapuntz Exp $	*/
@


1.2.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* 	$OpenBSD$	*/
d48 1
a48 1
	int (*appendfunc)(void *, struct dirent *, off_t);
@


1.2.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a50 1
	struct dirent *bdp;
d56 1
a56 1
	u_long *cookies = NULL, *cookiep;
d68 1
a68 1
	if (vp->v_type != VDIR)
d91 1
a91 6

	if (cookies) {
		free(cookies, M_TEMP);
		cookies = NULL;
	}

d93 1
a93 1
	    &cookies);
d97 1
a97 1
	if ((len = buflen - auio.uio_resid) <= 0)
d100 3
a102 18
	cookiep = cookies;
	inp = buf;

	if (cookies) {
		/*
		 * When using cookies, the vfs has the option of reading from
		 * a different offset than that supplied (UFS truncates the
		 * offset to a block boundary to make sure that it never reads
		 * partway through a directory entry, even if the directory
		 * has been compacted).
		 */
		while (len > 0 && ncookies > 0 && *cookiep <= newoff) {
			bdp = (struct dirent *)inp;
			len -= bdp->d_reclen;
			inp += bdp->d_reclen;
			cookiep++;
			ncookies--;
		}
d105 2
a106 3
	for (; len > 0; len -= reclen, inp += reclen) {
		if (cookiep && ncookies == 0)
			break;
d108 4
a111 1
		bdp = (struct dirent *)inp;
d114 3
a116 7
		if (len < reclen)
			break;

		if (reclen & 3) {
			error = EFAULT;
			goto out;
		}
d120 2
a121 2
			if ((error = (*appendfunc) (arg, bdp,
			    (cookiep) ? *cookiep : (newoff + reclen))) != 0) {
d128 1
a128 5
		if (cookiep) {
			newoff = *cookiep++;
			ncookies--;
		} else
			newoff += reclen;
d134 3
a136 3
eof:
out:
	if (error == 0)
a138 3
	if (cookies)
		free(cookies, M_TEMP);

d140 2
@


1.1
log
@

SunOS, IBCS2, Linux, and SVR4 all require translations of directory entries
from OpenBSD format to their respective native formats.

A lot of common code here for interfacing with OpenBSD VOP_READDIR. Most
of this code and logic has been moved to common/compat_dir.c

When reading a portion of the directory, the compatibility layer registers
a callback which is passed an OpenBSD-style dirent and the cookie/offset.
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.8 2000/10/16 20:10:50 jasoni Exp $	*/
d55 1
a55 1
	int eofflag;
d97 4
a100 1
	if (!cookiebuf && !eofflag) {
a104 3
	if ((len = buflen - auio.uio_resid) == 0)
		goto eof;
	
@

