head	1.12;
access;
symbols
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.12
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.10
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.8
	OPENBSD_5_0:1.10.0.6
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.4
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.2
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.9.0.20
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.22
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.18
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.16
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.14
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.5.0.24
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.22
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.20
	OPENBSD_2_8:1.5.0.18
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.14
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.12
date	2013.12.13.19.55.12;	author naddy;	state dead;
branches;
next	1.11;

1.11
date	2013.04.09.02.56.50;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.19.21.34.42;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.23.27.59;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.49;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.30.20.45.34;	author nordin;	state Exp;
branches;
next	1.5;

1.5
date	96.12.16.20.04.52;	author tholo;	state Exp;
branches
	1.5.14.1
	1.5.24.1;
next	1.4;

1.4
date	96.05.23.08.32.23;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.12.01.46;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.21.21.34;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.02.26.23.26.53;	author niklas;	state Exp;
branches;
next	;

1.5.14.1
date	2002.03.06.02.07.07;	author niklas;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2002.03.28.11.28.05;	author niklas;	state Exp;
branches;
next	1.5.14.3;

1.5.14.3
date	2003.06.07.11.00.36;	author ho;	state Exp;
branches;
next	;

1.5.24.1
date	2002.01.31.22.55.28;	author niklas;	state Exp;
branches;
next	1.5.24.2;

1.5.24.2
date	2002.06.11.03.28.07;	author art;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Remove the 4.3BSD tty(4) compatibility shims.  RIP.  ok millert@@
@
text
@/*	$OpenBSD: tty_43.c,v 1.11 2013/04/09 02:56:50 tedu Exp $	*/
/*	$NetBSD: tty_43.c,v 1.5 1996/05/20 14:29:17 mark Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tty_compat.c	8.1 (Berkeley) 6/10/93
 */

/*
 * mapping routines for old line discipline (yuck)
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/termios.h>
#include <sys/file.h>
#include <sys/conf.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/ioctl_compat.h>

/*
 * XXX libcompat files should be included with config attributes
 */
#ifdef COMPAT_OLDTTY

int ttydebug = 0;

static const struct speedtab compatspeeds[] = {
#define MAX_SPEED	17
	{ 115200, 17 },
	{ 57600, 16 },
	{ 38400, 15 },
	{ 19200, 14 },
	{ 9600,	13 },
	{ 4800,	12 },
	{ 2400,	11 },
	{ 1800,	10 },
	{ 1200,	9 },
	{ 600,	8 },
	{ 300,	7 },
	{ 200,	6 },
	{ 150,	5 },
	{ 134,	4 },
	{ 110,	3 },
	{ 75,	2 },
	{ 50,	1 },
	{ 0,	0 },
	{ -1,	-1 },
};
static const int compatspcodes[] = {
	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200,
	1800, 2400, 4800, 9600, 19200, 38400, 57600, 115200
};

int ttcompatgetflags(struct tty *);
void ttcompatsetflags(struct tty *, struct termios *);
void ttcompatsetlflags(struct tty *, struct termios *);

/*ARGSUSED*/
int
ttcompat(struct tty *tp, u_long com, caddr_t data, int flag, struct proc *p)
{

	switch (com) {
	case TIOCGETP: {
		struct sgttyb *sg = (struct sgttyb *)data;
		u_char *cc = tp->t_cc;
		int speed;

		speed = ttspeedtab(tp->t_ospeed, compatspeeds);
		sg->sg_ospeed = (speed == -1) ? MAX_SPEED : speed;
		if (tp->t_ispeed == 0)
			sg->sg_ispeed = sg->sg_ospeed;
		else {
			speed = ttspeedtab(tp->t_ispeed, compatspeeds);
			sg->sg_ispeed = (speed == -1) ? MAX_SPEED : speed;
		}
		sg->sg_erase = cc[VERASE];
		sg->sg_kill = cc[VKILL];
		sg->sg_flags = ttcompatgetflags(tp);
		break;
	}

	case TIOCSETP:
	case TIOCSETN: {
		struct sgttyb *sg = (struct sgttyb *)data;
		struct termios term;
		int speed;

		term = tp->t_termios;
		if ((speed = sg->sg_ispeed) > MAX_SPEED || speed < 0)
			term.c_ispeed = speed;
		else
			term.c_ispeed = compatspcodes[speed];
		if ((speed = sg->sg_ospeed) > MAX_SPEED || speed < 0)
			term.c_ospeed = speed;
		else
			term.c_ospeed = compatspcodes[speed];
		term.c_cc[VERASE] = sg->sg_erase;
		term.c_cc[VKILL] = sg->sg_kill;
		tp->t_flags = (ttcompatgetflags(tp) & 0xffff0000) |
		    (sg->sg_flags & 0xffff);
		ttcompatsetflags(tp, &term);
		return (ttioctl(tp, com == TIOCSETP ? TIOCSETAF : TIOCSETA,
		    (caddr_t)&term, flag, p));
	}

	case TIOCGETC: {
		struct tchars *tc = (struct tchars *)data;
		u_char *cc = tp->t_cc;

		tc->t_intrc = cc[VINTR];
		tc->t_quitc = cc[VQUIT];
		tc->t_startc = cc[VSTART];
		tc->t_stopc = cc[VSTOP];
		tc->t_eofc = cc[VEOF];
		tc->t_brkc = cc[VEOL];
		break;
	}
	case TIOCSETC: {
		struct tchars *tc = (struct tchars *)data;
		u_char *cc = tp->t_cc;

		cc[VINTR] = tc->t_intrc;
		cc[VQUIT] = tc->t_quitc;
		cc[VSTART] = tc->t_startc;
		cc[VSTOP] = tc->t_stopc;
		cc[VEOF] = tc->t_eofc;
		cc[VEOL] = tc->t_brkc;
		if (tc->t_brkc == (char)-1)
			cc[VEOL2] = _POSIX_VDISABLE;
		break;
	}
	case TIOCSLTC: {
		struct ltchars *ltc = (struct ltchars *)data;
		u_char *cc = tp->t_cc;

		cc[VSUSP] = ltc->t_suspc;
		cc[VDSUSP] = ltc->t_dsuspc;
		cc[VREPRINT] = ltc->t_rprntc;
		cc[VDISCARD] = ltc->t_flushc;
		cc[VWERASE] = ltc->t_werasc;
		cc[VLNEXT] = ltc->t_lnextc;
		break;
	}
	case TIOCGLTC: {
		struct ltchars *ltc = (struct ltchars *)data;
		u_char *cc = tp->t_cc;

		ltc->t_suspc = cc[VSUSP];
		ltc->t_dsuspc = cc[VDSUSP];
		ltc->t_rprntc = cc[VREPRINT];
		ltc->t_flushc = cc[VDISCARD];
		ltc->t_werasc = cc[VWERASE];
		ltc->t_lnextc = cc[VLNEXT];
		break;
	}
	case TIOCLBIS:
	case TIOCLBIC:
	case TIOCLSET: {
		struct termios term;
		int flags;

		term = tp->t_termios;
		flags = ttcompatgetflags(tp);
		switch (com) {
		case TIOCLSET:
			tp->t_flags = (flags & 0xffff) | (*(int *)data << 16);
			break;
		case TIOCLBIS:
			tp->t_flags = flags | (*(int *)data << 16);
			break;
		case TIOCLBIC:
			tp->t_flags = flags & ~(*(int *)data << 16);
			break;
		}
		ttcompatsetlflags(tp, &term);
		return (ttioctl(tp, TIOCSETA, (caddr_t)&term, flag, p));
	}
	case TIOCLGET:
		*(int *)data = ttcompatgetflags(tp) >> 16;
		if (ttydebug)
			printf("CLGET: returning %x\n", *(int *)data);
		break;

	case OTIOCGETD:
		*(int *)data = tp->t_line ? tp->t_line : 2;
		break;

	case OTIOCSETD: {
		int ldisczero = 0;

		return (ttioctl(tp, TIOCSETD,
		    *(int *)data == 2 ? (caddr_t)&ldisczero : data, flag, p));
	}
	case OTIOCCONS:
		*(int *)data = 1;
		return (ttioctl(tp, TIOCCONS, data, flag, p));

	case TIOCHPCL:
		SET(tp->t_cflag, HUPCL);
		break;

	case TIOCGSID:
		if (tp->t_session == NULL)
			return (ENOTTY);

		if (tp->t_session->s_leader == NULL)
			return (ENOTTY);

		*(int *)data = tp->t_session->s_leader->ps_pid;
		break;

	default:
		return (-1);
	}
	return (0);
}

int
ttcompatgetflags(struct tty *tp)
{
	tcflag_t iflag = tp->t_iflag;
	tcflag_t lflag = tp->t_lflag;
	tcflag_t oflag = tp->t_oflag;
	tcflag_t cflag = tp->t_cflag;
	int flags = 0;

	if (ISSET(iflag, IXOFF))
		SET(flags, TANDEM);
	if (ISSET(iflag, ICRNL) || ISSET(oflag, ONLCR))
		SET(flags, CRMOD);
	if (ISSET(cflag, PARENB)) {
		if (ISSET(iflag, INPCK)) {
			if (ISSET(cflag, PARODD))
				SET(flags, ODDP);
			else
				SET(flags, EVENP);
		} else
			SET(flags, ANYP);
	}

	if (!ISSET(lflag, ICANON)) {
		/* fudge */
		if (ISSET(iflag, IXON) || ISSET(lflag, ISIG|IEXTEN) ||
		    ISSET(cflag, PARENB))
			SET(flags, CBREAK);
		else
			SET(flags, RAW);
	}

	if (ISSET(flags, RAW))
		SET(flags, ISSET(tp->t_flags, LITOUT|PASS8));
	else if (ISSET(cflag, CSIZE) == CS8) {
		if (!ISSET(oflag, OPOST))
			SET(flags, LITOUT);
		if (!ISSET(iflag, ISTRIP))
			SET(flags, PASS8);
	}

	if (ISSET(cflag, MDMBUF))
		SET(flags, MDMBUF);
	if (!ISSET(cflag, HUPCL))
		SET(flags, NOHANG);
	if (ISSET(cflag, XCASE) && ISSET(iflag, IUCLC) && ISSET(oflag, OLCUC))
		SET(flags, LCASE);
	if (ISSET(oflag, OXTABS))
		SET(flags, XTABS);
	if (ISSET(lflag, ECHOE))
		SET(flags, CRTERA|CRTBS);
	if (ISSET(lflag, ECHOKE))
		SET(flags, CRTKIL|CRTBS);
	if (ISSET(lflag, ECHOPRT))
		SET(flags, PRTERA);
	if (ISSET(lflag, ECHOCTL))
		SET(flags, CTLECH);
	if (!ISSET(iflag, IXANY))
		SET(flags, DECCTQ);
	SET(flags, ISSET(lflag, ECHO|TOSTOP|FLUSHO|PENDIN|NOFLSH));
	if (ttydebug)
		printf("getflags: %x\n", flags);
	return (flags);
}

void
ttcompatsetflags(struct tty *tp, struct termios *t)
{
	int flags = tp->t_flags;
	tcflag_t iflag = t->c_iflag;
	tcflag_t oflag = t->c_oflag;
	tcflag_t lflag = t->c_lflag;
	tcflag_t cflag = t->c_cflag;

	if (ISSET(flags, TANDEM))
		SET(iflag, IXOFF);
	else
		CLR(iflag, IXOFF);
	if (ISSET(flags, ECHO))
		SET(lflag, ECHO);
	else
		CLR(lflag, ECHO);
	if (ISSET(flags, CRMOD)) {
		SET(iflag, ICRNL);
		SET(oflag, ONLCR);
	} else {
		CLR(iflag, ICRNL);
		CLR(oflag, ONLCR);
	}
	if (ISSET(flags, XTABS))
		SET(oflag, OXTABS);
	else
		CLR(oflag, OXTABS);
	if (ISSET(flags, LCASE)) {
		SET(iflag, IUCLC);
		SET(oflag, OLCUC);
		SET(cflag, XCASE);
	}
	else {
		CLR(iflag, IUCLC);
		CLR(oflag, OLCUC);
		CLR(cflag, XCASE);
	}

	if (ISSET(flags, RAW)) {
		iflag &= IXOFF|IXANY;
		CLR(lflag, ISIG|ICANON|IEXTEN);
		CLR(cflag, PARENB);
	} else {
		SET(iflag, BRKINT|IXON|IMAXBEL);
		SET(lflag, ISIG|IEXTEN);
		if (ISSET(flags, CBREAK))
			CLR(lflag, ICANON);
		else
			SET(lflag, ICANON);
		switch (ISSET(flags, ANYP)) {
		case 0:
			CLR(cflag, PARENB);
			break;
		case ANYP:
			SET(cflag, PARENB);
			CLR(iflag, INPCK);
			break;
		case EVENP:
			SET(cflag, PARENB);
			SET(iflag, INPCK);
			CLR(cflag, PARODD);
			break;
		case ODDP:
			SET(cflag, PARENB);
			SET(iflag, INPCK);
			SET(cflag, PARODD);
			break;
		}
	}

	if (ISSET(flags, RAW|LITOUT|PASS8)) {
		CLR(cflag, CSIZE|XCASE);
		SET(cflag, CS8);
		if (!ISSET(flags, RAW|PASS8))
			SET(iflag, ISTRIP);
		else
			CLR(iflag, ISTRIP);
		if (!ISSET(flags, RAW|LITOUT))
			SET(oflag, OPOST);
		else
			CLR(oflag, OPOST);
	} else {
		CLR(cflag, CSIZE);
		SET(cflag, CS7);
		if (ISSET(iflag, IUCLC) && ISSET(oflag, OLCUC))
			SET(cflag, XCASE);
		SET(iflag, ISTRIP);
		SET(oflag, OPOST);
	}

	t->c_iflag = iflag;
	t->c_oflag = oflag;
	t->c_lflag = lflag;
	t->c_cflag = cflag;
}

void
ttcompatsetlflags(struct tty *tp, struct termios *t)
{
	int flags = tp->t_flags;
	tcflag_t iflag = t->c_iflag;
	tcflag_t oflag = t->c_oflag;
	tcflag_t lflag = t->c_lflag;
	tcflag_t cflag = t->c_cflag;

	/* Nothing we can do with CRTBS. */
	if (ISSET(flags, PRTERA))
		SET(lflag, ECHOPRT);
	else
		CLR(lflag, ECHOPRT);
	if (ISSET(flags, CRTERA))
		SET(lflag, ECHOE);
	else
		CLR(lflag, ECHOE);
	/* Nothing we can do with TILDE. */
	if (ISSET(flags, MDMBUF))
		SET(cflag, MDMBUF);
	else
		CLR(cflag, MDMBUF);
	if (ISSET(flags, NOHANG))
		CLR(cflag, HUPCL);
	else
		SET(cflag, HUPCL);
	if (ISSET(flags, CRTKIL))
		SET(lflag, ECHOKE);
	else
		CLR(lflag, ECHOKE);
	if (ISSET(flags, CTLECH))
		SET(lflag, ECHOCTL);
	else
		CLR(lflag, ECHOCTL);
	if (!ISSET(flags, DECCTQ))
		SET(iflag, IXANY);
	else
		CLR(iflag, IXANY);
	if (ISSET(flags, LCASE)) {
		SET(oflag, OLCUC);
		SET(iflag, IUCLC);
		SET(cflag, XCASE);
	}
	CLR(lflag, TOSTOP|FLUSHO|PENDIN|NOFLSH);
	SET(lflag, ISSET(flags, TOSTOP|FLUSHO|PENDIN|NOFLSH));

	if (ISSET(flags, RAW|LITOUT|PASS8)) {
		CLR(cflag, CSIZE);
		SET(cflag, CS8);
		if (!ISSET(flags, RAW|PASS8))
			SET(iflag, ISTRIP);
		else
			CLR(iflag, ISTRIP);
		if (!ISSET(flags, RAW|LITOUT))
			SET(oflag, OPOST);
		else {
			CLR(oflag, OPOST);
			CLR(cflag, XCASE);
		}
	} else {
		CLR(cflag, CSIZE);
		SET(cflag, CS7);
		SET(iflag, ISTRIP);
		SET(oflag, OPOST);
		if (ISSET(oflag, OLCUC) && ISSET(iflag, IUCLC))
			SET(cflag, XCASE);
	}

	t->c_iflag = iflag;
	t->c_oflag = oflag;
	t->c_lflag = lflag;
	t->c_cflag = cflag;
}
#endif /* COMPAT_OLDTTY */
@


1.11
log
@knf. even old ttys need love.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_43.c,v 1.10 2010/07/26 01:56:27 guenther Exp $	*/
@


1.10
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_43.c,v 1.9 2004/09/19 21:34:42 mickey Exp $	*/
d90 1
a90 6
ttcompat(tp, com, data, flag, p)
	register struct tty *tp;
	u_long com;
	caddr_t data;
	int flag;
	struct proc *p;
d95 3
a97 3
		register struct sgttyb *sg = (struct sgttyb *)data;
		register u_char *cc = tp->t_cc;
		register int speed;
d115 1
a115 1
		register struct sgttyb *sg = (struct sgttyb *)data;
d130 2
a131 1
		tp->t_flags = (ttcompatgetflags(tp)&0xffff0000) | (sg->sg_flags&0xffff);
d134 1
a134 1
			(caddr_t)&term, flag, p));
d139 1
a139 1
		register u_char *cc = tp->t_cc;
d151 1
a151 1
		register u_char *cc = tp->t_cc;
d165 1
a165 1
		register u_char *cc = tp->t_cc;
d177 1
a177 1
		register u_char *cc = tp->t_cc;
d197 1
a197 1
			tp->t_flags = (flags&0xffff) | (*(int *)data<<16);
d200 1
a200 1
			tp->t_flags = flags | (*(int *)data<<16);
d203 1
a203 1
			tp->t_flags = flags & ~(*(int *)data<<16);
d210 1
a210 1
		*(int *)data = ttcompatgetflags(tp)>>16;
d223 2
a224 4
			*(int *)data == 2 ? (caddr_t)&ldisczero : data, flag,
			p));
	    }

d235 1
a235 1
			return ENOTTY;
d238 1
a238 1
			return ENOTTY;
d240 1
a240 1
		*(int *) data =  tp->t_session->s_leader->ps_pid;
d250 1
a250 2
ttcompatgetflags(tp)
	register struct tty *tp;
d252 5
a256 5
	register tcflag_t iflag = tp->t_iflag;
	register tcflag_t lflag = tp->t_lflag;
	register tcflag_t oflag = tp->t_oflag;
	register tcflag_t cflag = tp->t_cflag;
	register int flags = 0;
d315 1
a315 3
ttcompatsetflags(tp, t)
	register struct tty *tp;
	register struct termios *t;
d317 5
a321 5
	register int flags = tp->t_flags;
	register tcflag_t iflag = t->c_iflag;
	register tcflag_t oflag = t->c_oflag;
	register tcflag_t lflag = t->c_lflag;
	register tcflag_t cflag = t->c_cflag;
a352 1

d412 1
a412 3
ttcompatsetlflags(tp, t)
	register struct tty *tp;
	register struct termios *t;
d414 5
a418 5
	register int flags = tp->t_flags;
	register tcflag_t iflag = t->c_iflag;
	register tcflag_t oflag = t->c_oflag;
	register tcflag_t lflag = t->c_lflag;
	register tcflag_t cflag = t->c_cflag;
a484 1

@


1.9
log
@constify speedtabs and make ttspeedtab() take a const struct speedtab *
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_43.c,v 1.8 2003/06/02 23:27:59 millert Exp $	*/
d246 1
a246 1
		*(int *) data =  tp->t_session->s_leader->p_pid;
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_43.c,v 1.7 2002/03/14 01:26:49 millert Exp $	*/
d57 1
a57 1
static struct speedtab compatspeeds[] = {
d79 1
a79 1
static int compatspcodes[] = {
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_43.c,v 1.6 2002/01/30 20:45:34 nordin Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_43.c,v 1.5 1996/12/16 20:04:52 tholo Exp $	*/
d88 3
a90 3
int ttcompatgetflags __P((struct tty *));
void ttcompatsetflags __P((struct tty *, struct termios *));
void ttcompatsetlflags __P((struct tty *, struct termios *));
@


1.5
log
@Implement more tty flags for better portability from other systems:

	XCASE - canonical input/output processing
	IUCLC - translate uppercase to lowercase on input
	OLCUC - translate lowercase to uppercase on output
	OCRNL - translate carriage return to newline on output
	ONOCR - do not output carriage return at column 0
	ONLRET - newline performs carriage return function

In addition the tty compatibility interface supports LCASE properly.

Look at termios(4) for a more complete description of the above flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_43.c,v 1.4 1996/05/23 08:32:23 deraadt Exp $	*/
a86 5

/* Macros to clear/set/test flags. */
#define	SET(t, f)	(t) |= (f)
#define	CLR(t, f)	(t) &= ~(f)
#define	ISSET(t, f)	((t) & (f))
@


1.5.14.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 5
@


1.5.14.2
log
@Merge in -current from about a week ago
@
text
@d88 3
a90 3
int ttcompatgetflags(struct tty *);
void ttcompatsetflags(struct tty *, struct termios *);
void ttcompatsetlflags(struct tty *, struct termios *);
@


1.5.14.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_43.c,v 1.5.14.2 2002/03/28 11:28:05 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5.24.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_43.c,v 1.6 2002/01/30 20:45:34 nordin Exp $	*/
d87 5
@


1.5.24.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_43.c,v 1.5.24.1 2002/01/31 22:55:28 niklas Exp $	*/
d88 3
a90 3
int ttcompatgetflags(struct tty *);
void ttcompatsetflags(struct tty *, struct termios *);
void ttcompatsetlflags(struct tty *, struct termios *);
@


1.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_43.c,v 1.3 1996/05/22 12:01:46 deraadt Exp $	*/
d310 2
d360 10
d373 1
a373 1
		iflag &= IXOFF;
d405 1
a405 1
		CLR(cflag, CSIZE);
d418 2
d471 5
d488 1
a488 1
		else
d490 2
d497 2
@


1.3
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD: tty_43.c,v 1.1 1996/02/26 23:26:53 niklas Exp $	*/
/*	$NetBSD: tty_43.c,v 1.4 1996/05/18 22:17:49 veego Exp $	*/
d172 1
a172 1
		if (tc->t_brkc == -1)
@


1.2
log
@Merge of NetBSD 960317
@
text
@d2 1
a2 1
/*	$NetBSD: tty_43.c,v 1.3 1996/03/14 19:31:49 christos Exp $	*/
d54 5
d483 2
@


1.1
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: tty_43.c,v 1.2 1996/02/10 00:12:44 christos Exp $	*/
d88 4
d93 1
d323 1
d411 1
@
