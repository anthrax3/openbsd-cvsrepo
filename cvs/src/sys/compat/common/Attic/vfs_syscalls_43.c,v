head	1.29;
access;
symbols
	OPENBSD_4_9:1.28.0.14
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.12
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.8
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.10
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.6
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.4
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.27.0.10
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.8
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.6
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.4
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.25.0.4
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.21
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.14
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.12
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.10
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2011.07.07.01.23.56;	author tedu;	state dead;
branches;
next	1.28;

1.28
date	2007.10.30.18.13.45;	author chl;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.26.01.15.12;	author pedro;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.26.00.33.45;	author pedro;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.14.18.57.57;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.09.23.52.02;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.27.59;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.03.00.07.20;	author nordin;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.23.15.39.31;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.26.49;	author millert;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2002.02.13.19.08.06;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.12.18.41.20;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.10.26.12.03.27;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.14.13.28.22;	author art;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.05.14.12.11.53;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.14.11.04.04;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.14.10.51.26;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.23.07.06.23;	author csapuntz;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	97.11.06.22.15.52;	author millert;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	97.11.06.05.58.02;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.20.19.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.14.56.58;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.06.06.22.19.18;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.02.12.20.42;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.09.06.10.37.48;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.21.21.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.12;	author deraadt;	state Exp;
branches;
next	;

1.9.10.1
date	2001.05.14.22.04.19;	author niklas;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2001.07.04.10.39.16;	author niklas;	state Exp;
branches;
next	1.9.10.3;

1.9.10.3
date	2001.10.31.03.11.45;	author nate;	state Exp;
branches;
next	1.9.10.4;

1.9.10.4
date	2001.11.13.21.05.47;	author niklas;	state Exp;
branches;
next	1.9.10.5;

1.9.10.5
date	2002.03.06.02.07.07;	author niklas;	state Exp;
branches;
next	1.9.10.6;

1.9.10.6
date	2002.03.28.11.28.05;	author niklas;	state Exp;
branches;
next	1.9.10.7;

1.9.10.7
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	1.9.10.8;

1.9.10.8
date	2003.06.07.11.00.36;	author ho;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.31.05.08.32;	author jason;	state Exp;
branches;
next	;

1.14.2.1
date	2002.10.13.20.56.34;	author miod;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.28.07;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.10.29.00.30.51;	author art;	state Exp;
branches;
next	;

1.19.2.1
date	2002.10.13.20.54.52;	author miod;	state Exp;
branches;
next	;


desc
@@


1.29
log
@remove old files
@
text
@/*	$OpenBSD: vfs_syscalls_43.c,v 1.28 2007/10/30 18:13:45 chl Exp $	*/
/*	$NetBSD: vfs_syscalls_43.c,v 1.4 1996/03/14 19:31:52 christos Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vfs_syscalls.c	8.28 (Berkeley) 12/10/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/filedesc.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/vnode.h>
#include <sys/namei.h>
#include <sys/dirent.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/malloc.h>
#include <sys/syslog.h>
#include <sys/unistd.h>
#include <sys/resourcevar.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

#include <sys/pipe.h>

static void cvtstat(struct stat *, struct stat43 *);

/*
 * Convert from a new to an old stat structure.
 */
static void
cvtstat(st, ost)
	struct stat *st;
	struct stat43 *ost;
{

	ost->st_dev = st->st_dev;
	ost->st_ino = st->st_ino;
	ost->st_mode = st->st_mode;
	ost->st_nlink = st->st_nlink;
	ost->st_uid = st->st_uid;
	ost->st_gid = st->st_gid;
	ost->st_rdev = st->st_rdev;
	if (st->st_size < (quad_t)1 << 32)
		ost->st_size = st->st_size;
	else
		ost->st_size = -2;
	ost->st_atime = st->st_atime;
	ost->st_mtime = st->st_mtime;
	ost->st_ctime = st->st_ctime;
	ost->st_blksize = st->st_blksize;
	ost->st_blocks = st->st_blocks;
	ost->st_flags = st->st_flags;
	ost->st_gen = st->st_gen;
}

/*
 * Get file status; this version follows links.
 */
/* ARGSUSED */
int
compat_43_sys_stat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct compat_43_sys_stat_args /* {
		syscallarg(char *) path;
		syscallarg(struct stat43 *) ub;
	} */ *uap = v;
	struct stat sb;
	struct stat43 osb;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	error = vn_stat(nd.ni_vp, &sb, p);
	vput(nd.ni_vp);
	if (error)
		return (error);
	/* Don't let non-root see generation numbers (for NFS security) */
	if (suser(p, 0))
		sb.st_gen = 0;
	cvtstat(&sb, &osb);
	error = copyout(&osb, SCARG(uap, ub), sizeof(osb));
	return (error);
}


/*
 * Get file status; this version does not follow links.
 */
/* ARGSUSED */
int
compat_43_sys_lstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct compat_43_sys_lstat_args /* {
		syscallarg(char *) path;
		syscallarg(struct stat43 *) ub;
	} */ *uap = v;
	struct stat sb;
	struct stat43 osb;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, NOFOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	error = vn_stat(nd.ni_vp, &sb, p);
	vput(nd.ni_vp);
	if (error)
		return (error);
	/* Don't let non-root see generation numbers (for NFS security) */
	if (suser(p, 0))
		sb.st_gen = 0;
	cvtstat(&sb, &osb);
	error = copyout(&osb, SCARG(uap, ub), sizeof(osb));
	return (error);
}

/*
 * Return status information about a file descriptor.
 */
/* ARGSUSED */
int
compat_43_sys_fstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct compat_43_sys_fstat_args /* {
		syscallarg(int) fd;
		syscallarg(struct stat43 *) sb;
	} */ *uap = v;
	int fd = SCARG(uap, fd);
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct stat ub;
	struct stat43 oub;
	int error;

	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	FREF(fp);
	error = (*fp->f_ops->fo_stat)(fp, &ub, p);
	FRELE(fp);
	if (error == 0) {
		/* Don't let non-root see generation numbers
		   (for NFS security) */
		if (suser(p, 0))
			ub.st_gen = 0;
		cvtstat(&ub, &oub);
		error = copyout(&oub, SCARG(uap, sb), sizeof(oub));
	}
	return (error);
}

/*
 * Truncate a file given a file descriptor.
 */
/* ARGSUSED */
int
compat_43_sys_ftruncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct compat_43_sys_ftruncate_args /* {
		syscallarg(int) fd;
		syscallarg(long) length;
	} */ *uap = v;
	struct sys_ftruncate_args /* {
		syscallarg(int) fd;
		syscallarg(int) pad;
		syscallarg(off_t) length;
	} */ nuap;

	SCARG(&nuap, fd) = SCARG(uap, fd);
	SCARG(&nuap, length) = SCARG(uap, length);
	return (sys_ftruncate(p, &nuap, retval));
}

/*
 * Truncate a file given its path name.
 */
/* ARGSUSED */
int
compat_43_sys_truncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct compat_43_sys_truncate_args /* {
		syscallarg(char *) path;
		syscallarg(long) length;
	} */ *uap = v;
	struct sys_truncate_args /* {
		syscallarg(char *) path;
		syscallarg(int) pad;
		syscallarg(off_t) length;
	} */ nuap;

	SCARG(&nuap, path) = SCARG(uap, path);
	SCARG(&nuap, length) = SCARG(uap, length);
	return (sys_truncate(p, &nuap, retval));
}


/*
 * Reposition read/write file offset.
 */
int
compat_43_sys_lseek(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct compat_43_sys_lseek_args /* {
		syscallarg(int) fd;
		syscallarg(long) offset;
		syscallarg(int) whence;
	} */ *uap = v;
	struct sys_lseek_args /* {
		syscallarg(int) fd;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
		syscallarg(int) whence;
	} */ nuap;
	off_t qret;
	int error;

	SCARG(&nuap, fd) = SCARG(uap, fd);
	SCARG(&nuap, offset) = SCARG(uap, offset);
	SCARG(&nuap, whence) = SCARG(uap, whence);
	error = sys_lseek(p, &nuap, (register_t *)&qret);
	*(long *)retval = qret;
	return (error);
}


/*
 * Create a file.
 */
int
compat_43_sys_creat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct compat_43_sys_creat_args /* {
		syscallarg(char *) path;
		syscallarg(mode_t) mode;
	} */ *uap = v;
	struct sys_open_args /* {
		syscallarg(char *) path;
		syscallarg(int) flags;
		syscallarg(mode_t) mode;
	} */ nuap;

	SCARG(&nuap, path) = SCARG(uap, path);
	SCARG(&nuap, mode) = SCARG(uap, mode);
	SCARG(&nuap, flags) = O_WRONLY | O_CREAT | O_TRUNC;
	return (sys_open(p, &nuap, retval));
}

/*ARGSUSED*/
int
compat_43_sys_quota(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	return (ENOSYS);
}


/*
 * Read a block of directory entries in a file system independent format.
 */
int
compat_43_sys_getdirentries(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct compat_43_sys_getdirentries_args /* {
		syscallarg(int) fd;
		syscallarg(char *) buf;
		syscallarg(int) count;
		syscallarg(long *) basep;
	} */ *uap = v;
	struct vnode *vp;
	struct file *fp;
	struct uio auio, kuio;
	struct iovec aiov, kiov;
	struct dirent *dp, *edp;
	caddr_t dirbuf;
	int error, eofflag, readcnt;
	long loff;

	if (SCARG(uap, count) < 0)
		return EINVAL;
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	if ((fp->f_flag & FREAD) == 0) {
		error = EBADF;
		goto bad;
	}
	vp = (struct vnode *)fp->f_data;
	if (vp->v_type != VDIR) {
		error = EINVAL;
		goto bad;
	}
	aiov.iov_base = SCARG(uap, buf);
	aiov.iov_len = SCARG(uap, count);
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;
	auio.uio_resid = SCARG(uap, count);
       
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	loff = auio.uio_offset = fp->f_offset;
#	if (BYTE_ORDER != LITTLE_ENDIAN)
		if (vp->v_mount->mnt_maxsymlinklen <= 0) {
			error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag,
			    (int *)0, (u_long **)0);
			fp->f_offset = auio.uio_offset;
		} else
#	endif
	{
		u_int  nbytes = SCARG(uap, count);

		nbytes = min(nbytes, MAXBSIZE);

		kuio = auio;
		kuio.uio_iov = &kiov;
		kuio.uio_segflg = UIO_SYSSPACE;
		kiov.iov_len = nbytes;
		dirbuf = (caddr_t)malloc(nbytes, M_TEMP, M_WAITOK);
		kiov.iov_base = dirbuf;

		error = VOP_READDIR(vp, &kuio, fp->f_cred, &eofflag,
				    0, 0);
		fp->f_offset = kuio.uio_offset;
		if (error == 0) {
			readcnt = nbytes - kuio.uio_resid;
			edp = (struct dirent *)&dirbuf[readcnt];
			for (dp = (struct dirent *)dirbuf; dp < edp; ) {
#				if (BYTE_ORDER == LITTLE_ENDIAN)
					/*
					 * The expected low byte of
					 * dp->d_namlen is our dp->d_type.
					 * The high MBZ byte of dp->d_namlen
					 * is our dp->d_namlen.
					 */
					dp->d_type = dp->d_namlen;
					dp->d_namlen = 0;
#				else
					/*
					 * The dp->d_type is the high byte
					 * of the expected dp->d_namlen,
					 * so must be zero'ed.
					 */
					dp->d_type = 0;
#				endif
				if (dp->d_reclen > 0) {
					dp = (struct dirent *)
					    ((char *)dp + dp->d_reclen);
				} else {
					error = EIO;
					break;
				}
			}
			if (dp >= edp)
				error = uiomove(dirbuf, readcnt, &auio);
		}
		free(dirbuf, M_TEMP);
	}
	VOP_UNLOCK(vp, 0, p);
	if (error)
		goto bad;
	error = copyout((caddr_t)&loff, (caddr_t)SCARG(uap, basep),
	    sizeof(long));
	*retval = SCARG(uap, count) - auio.uio_resid;
bad:
	FRELE(fp);
	return (error);
}
@


1.28
log
@MALLOC/FREE -> malloc/free

These are the latest ones needed to build a kernel (on amd64)
without the MALLOC/FREE definitions in src/sys/sys/malloc.h

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.27 2005/05/26 01:15:12 pedro Exp $	*/
@


1.27
log
@fix little nonsense introduced by my last commit here
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.26 2005/05/26 00:33:45 pedro Exp $	*/
d427 1
a427 1
		FREE(dirbuf, M_TEMP);
@


1.26
log
@RIP stackable filesystems, ok marius@@ tedu@@, discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.25 2004/07/14 18:57:57 millert Exp $	*/
a429 2
	if (error)
		goto bad;
@


1.25
log
@Zero out st_gen for non-root in *stat().  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.24 2004/07/13 21:04:29 millert Exp $	*/
a68 11
 * Redirection info so we don't have to include the union fs routines in 
 * the kernel directly.  This way, we can build unionfs as an LKM.  The
 * pointer gets replaced later, when we modload the LKM, or when the
 * compiled-in unionfs code gets initialized.  Initial, stub routine
 * value is compiled in from kern/vfs_syscalls.c
 */

extern int (*union_check_p)(struct proc *, struct vnode **, 
				   struct file *, struct uio, int *);

/*
a357 1
unionread:
a431 4
	if ((SCARG(uap, count) == auio.uio_resid) &&
	    union_check_p &&
	    (union_check_p(p, &vp, fp, auio, &error) != 0))
		goto unionread;
a433 12

	if ((SCARG(uap, count) == auio.uio_resid) &&
	    (vp->v_flag & VROOT) &&
	    (vp->v_mount->mnt_flag & MNT_UNION)) {
		struct vnode *tvp = vp;
		vp = vp->v_mount->mnt_vnodecovered;
		VREF(vp);
		fp->f_data = (caddr_t) vp;
		fp->f_offset = 0;
		vrele(tvp);
		goto unionread;
	}
@


1.24
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.23 2004/07/09 23:52:02 millert Exp $	*/
d135 3
d139 1
a139 1
	error = copyout((caddr_t)&osb, (caddr_t)SCARG(uap, ub), sizeof (osb));
d171 3
d175 1
a175 1
	error = copyout(&osb, SCARG(uap, ub), sizeof (osb));
a178 1

d205 8
a212 4
	cvtstat(&ub, &oub);
	if (error == 0)
		error = copyout((caddr_t)&oub, (caddr_t)SCARG(uap, sb),
		    sizeof (oub));
a214 1

@


1.23
log
@Rename ostat -> stat43 to disambiguate from upcoming struct stat changes.
Idea from NetBSD, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.22 2003/06/02 23:27:59 millert Exp $	*/
d80 1
a80 1
 * Convert from an old to a new stat structure.
d302 1
a302 1
		syscallarg(int) mode;
d307 1
a307 1
		syscallarg(int) mode;
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.21 2002/10/03 00:07:20 nordin Exp $	*/
d66 1
a66 1
static void cvtstat(struct stat *, struct ostat *);
d85 1
a85 1
	struct ostat *ost;
d120 1
a120 1
		syscallarg(struct ostat *) ub;
d123 1
a123 1
	struct ostat osb;
d153 1
a153 1
		syscallarg(struct ostat *) ub;
d156 1
a156 1
	struct ostat osb;
d186 1
a186 1
		syscallarg(struct ostat *) sb;
d192 1
a192 1
	struct ostat oub;
@


1.21
log
@Check for negative values here too. "makes sense" mickey@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.20 2002/08/23 15:39:31 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.20
log
@Cleanup change. Since almost all callers (except one) of getvnode did a FREF
on the returned file, do the FREF inside getvnode so that people can't
get away with avoiding FREF and FRELE.

Eyeballed by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.19 2002/03/14 01:26:49 millert Exp $	*/
d344 1
a344 1
		syscallarg(u_int) count;
d356 2
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.18 2002/02/13 19:08:06 art Exp $	*/
d358 4
a361 3
	if ((fp->f_flag & FREAD) == 0)
		return (EBADF);
	FREF(fp);
@


1.19.2.1
log
@MFC (nordin):
Check for negative values. Inspiration from tedu <grendel@@zeitbombe.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.19 2002/03/14 01:26:49 millert Exp $	*/
d344 1
a344 1
		syscallarg(int) count;
a355 2
	if (SCARG(uap, count) < 0)
		return EINVAL;
@


1.18
log
@More FREF/FRELE on relevant places. Now, only sys_mmap and a bunch of ioctl functions in sys/compat are left.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.17 2002/02/12 18:41:20 art Exp $	*/
d70 1
a70 1
static void cvtstat __P((struct stat *, struct ostat *));
d80 2
a81 2
extern int (*union_check_p)  __P((struct proc *, struct vnode **, 
				   struct file *, struct uio, int *));
@


1.17
log
@More FREF/FRELE protection. This time all users of getvnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.16 2001/11/06 19:53:17 miod Exp $	*/
d188 1
a188 1
	register struct compat_43_sys_fstat_args /* {
d193 2
a194 2
	register struct filedesc *fdp = p->p_fd;
	register struct file *fp;
d201 1
d203 1
@


1.16
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.15 2001/10/26 12:03:27 art Exp $	*/
d358 1
d361 4
a364 2
	if (vp->v_type != VDIR)
		return (EINVAL);
d434 1
a434 1
		return (error);
d440 1
a440 1
		return (error);
d456 2
@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.16 2001/11/06 19:53:17 miod Exp $	*/
d70 1
a70 1
static void cvtstat(struct stat *, struct ostat *);
d80 2
a81 2
extern int (*union_check_p)(struct proc *, struct vnode **, 
				   struct file *, struct uio, int *);
d188 1
a188 1
	struct compat_43_sys_fstat_args /* {
d193 2
a194 2
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
a200 1
	FREF(fp);
a201 1
	FRELE(fp);
a357 1
	FREF(fp);
d360 2
a361 4
	if (vp->v_type != VDIR) {
		error = EINVAL;
		goto bad;
	}
d431 1
a431 1
		goto bad;
d437 1
a437 1
		goto bad;
a452 2
bad:
	FRELE(fp);
@


1.16.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.16.2.1 2002/06/11 03:28:07 art Exp $	*/
d344 1
a344 1
		syscallarg(int) count;
a355 2
	if (SCARG(uap, count) < 0)
		return EINVAL;
d358 3
a360 4
	if ((fp->f_flag & FREAD) == 0) {
		error = EBADF;
		goto bad;
	}
@


1.15
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.14 2001/05/14 13:28:22 art Exp $	*/
d66 1
a66 1
#include <vm/vm.h>
@


1.14
log
@use fo_stat in fileops instead of huge switch statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.13 2001/05/14 12:11:53 art Exp $	*/
d199 1
a199 2
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL)
@


1.14.2.1
log
@MFC (nordin):
Check for negative values. Inspiration from tedu <grendel@@zeitbombe.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.14 2001/05/14 13:28:22 art Exp $	*/
d343 1
a343 1
		syscallarg(int) count;
a354 2
	if (SCARG(uap, count) < 0)
		return EINVAL;
@


1.13
log
@Implement a wrapper round vn_stat that takes the same arguments
as soo_stat and pipe_stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.12 2001/05/14 11:04:04 art Exp $	*/
d202 1
a202 20
	switch (fp->f_type) {

	case DTYPE_VNODE:
		error = vn_statfile(fp, &ub, p);
		break;

	case DTYPE_SOCKET:
		error = soo_stat(fp, &ub, p);
		break;

#ifndef OLD_PIPE
	case DTYPE_PIPE:
		error = pipe_stat(fp, &ub, p);
		break;
#endif

	default:
		panic("ofstat");
		/*NOTREACHED*/
	}
@


1.12
log
@More generic arguments to soo_stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.11 2001/05/14 10:51:26 art Exp $	*/
d205 1
a205 1
		error = vn_stat((struct vnode *)fp->f_data, &ub, p);
@


1.11
log
@More generic arguments to pipe_stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.10 2001/01/23 07:06:23 csapuntz Exp $	*/
d209 1
a209 1
		error = soo_stat((struct socket *)fp->f_data, &ub);
@


1.10
log
@

Clamp malloc in compat_43_sys_getdirentries to 64k

We should really get rid of all mallocs in the compat and VOP_READDIRs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.9 1997/11/06 22:15:52 millert Exp $	*/
d214 1
a214 1
		error = pipe_stat((struct pipe *)fp->f_data, &ub);
@


1.10.2.1
log
@Fix (art):
don't panic on kqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.10 2001/01/23 07:06:23 csapuntz Exp $	*/
d219 2
a220 1
		return (EOPNOTSUPP);
@


1.9
log
@Use lite2 vfs interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.8 1997/11/06 05:58:02 csapuntz Exp $	*/
d401 4
d408 2
a409 2
		kiov.iov_len = SCARG(uap, count);
		MALLOC(dirbuf, caddr_t, SCARG(uap, count), M_TEMP, M_WAITOK);
d411 1
d416 1
a416 1
			readcnt = SCARG(uap, count) - kuio.uio_resid;
@


1.9.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.10 2001/01/23 07:06:23 csapuntz Exp $	*/
a400 4
		u_int  nbytes = SCARG(uap, count);

		nbytes = min(nbytes, MAXBSIZE);

d404 2
a405 2
		kiov.iov_len = nbytes;
		dirbuf = (caddr_t)malloc(nbytes, M_TEMP, M_WAITOK);
a406 1

d411 1
a411 1
			readcnt = nbytes - kuio.uio_resid;
@


1.9.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.9.10.1 2001/05/14 22:04:19 niklas Exp $	*/
d202 20
a221 1
	error = (*fp->f_ops->fo_stat)(fp, &ub, p);
@


1.9.10.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.9.10.2 2001/07/04 10:39:16 niklas Exp $	*/
d199 2
a200 1
	if ((fp = fd_getfile(fdp, fd)) == NULL)
@


1.9.10.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 1
a66 1
#include <uvm/uvm_extern.h>
@


1.9.10.5
log
@Merge in trunk
@
text
@d188 1
a188 1
	struct compat_43_sys_fstat_args /* {
d193 2
a194 2
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
a200 1
	FREF(fp);
a201 1
	FRELE(fp);
a357 1
	FREF(fp);
d360 2
a361 4
	if (vp->v_type != VDIR) {
		error = EINVAL;
		goto bad;
	}
d431 1
a431 1
		goto bad;
d437 1
a437 1
		goto bad;
a452 2
bad:
	FRELE(fp);
@


1.9.10.6
log
@Merge in -current from about a week ago
@
text
@d70 1
a70 1
static void cvtstat(struct stat *, struct ostat *);
d80 2
a81 2
extern int (*union_check_p)(struct proc *, struct vnode **, 
				   struct file *, struct uio, int *);
@


1.9.10.7
log
@Sync the SMP branch with 3.3
@
text
@d344 1
a344 1
		syscallarg(int) count;
a355 2
	if (SCARG(uap, count) < 0)
		return EINVAL;
d358 3
a360 4
	if ((fp->f_flag & FREAD) == 0) {
		error = EBADF;
		goto bad;
	}
@


1.9.10.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.9.10.7 2003/03/27 23:53:47 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.7 1997/10/06 20:19:27 deraadt Exp $	*/
d396 1
a396 1
			    (u_long *)0, 0);
@


1.7
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.5 1997/06/06 22:19:18 deraadt Exp $	*/
d390 2
a391 1
	VOP_LOCK(vp);
d408 1
a408 1
			    (u_long *)0, 0);
d444 1
a444 1
	VOP_UNLOCK(vp);
@


1.6
log
@VFS Lite 2 Changes
@
text
@d390 1
a390 2
       
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d407 1
a407 1
				    0, 0);
d443 1
a443 1
	VOP_UNLOCK(vp, 0, p);
@


1.5
log
@symlinks have inodes again; arnej@@math.ntnu.no
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.4 1997/01/02 12:20:42 mickey Exp $	*/
d390 2
a391 1
	VOP_LOCK(vp);
d408 1
a408 1
			    (u_long *)0, 0);
d444 1
a444 1
	VOP_UNLOCK(vp);
@


1.4
log
@pulled out the duplicated, conditional code from both kern/vfs_syscalls.c
and compat/common/vfs_syscalls_43.c and placed a single copy of that code
into miscfs/union/union_subr.c (seemed like a good place to put it, since
it's union-fs related).
as a side effect you can build unionfs in lkm.
(netbsd pr#2950, Paul Goyette <paul@@pgoyette.bdt.com>)
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.3 1996/09/06 10:37:48 niklas Exp $	*/
d159 1
a159 2
	struct vnode *vp, *dvp;
	struct stat sb, sb1;
d164 1
a164 1
	NDINIT(&nd, LOOKUP, NOFOLLOW | LOCKLEAF | LOCKPARENT, UIO_USERSPACE,
d168 4
a171 32
	/*
	 * For symbolic links, always return the attributes of its
	 * containing directory, except for mode, size, and links.
	 */
	vp = nd.ni_vp;
	dvp = nd.ni_dvp;
	if (vp->v_type != VLNK) {
		if (dvp == vp)
			vrele(dvp);
		else
			vput(dvp);
		error = vn_stat(vp, &sb, p);
		vput(vp);
		if (error)
			return (error);
	} else {
		error = vn_stat(dvp, &sb, p);
		vput(dvp);
		if (error) {
			vput(vp);
			return (error);
		}
		error = vn_stat(vp, &sb1, p);
		vput(vp);
		if (error)
			return (error);
		sb.st_mode &= ~S_IFDIR;
		sb.st_mode |= S_IFLNK;
		sb.st_nlink = sb1.st_nlink;
		sb.st_size = sb1.st_size;
		sb.st_blocks = sb1.st_blocks;
	}
d173 1
a173 1
	error = copyout((caddr_t)&osb, (caddr_t)SCARG(uap, ub), sizeof (osb));
@


1.3
log
@Deal with the new pipes gracefully
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls_43.c,v 1.2 1996/04/18 21:21:36 niklas Exp $	*/
d73 11
d394 1
a394 1
	register struct vnode *vp;
a474 6

#ifdef UNION
{
	extern int (**union_vnodeop_p) __P((void *));
	extern struct vnode *union_dircache __P((struct vnode *));

d476 5
a480 37
	    (vp->v_op == union_vnodeop_p)) {
		struct vnode *lvp;

		lvp = union_dircache(vp);
		if (lvp != NULLVP) {
			struct vattr va;

			/*
			 * If the directory is opaque,
			 * then don't show lower entries
			 */
			error = VOP_GETATTR(vp, &va, fp->f_cred, p);
			if (va.va_flags & OPAQUE) {
				vput(lvp);
				lvp = NULL;
			}
		}
		
		if (lvp != NULLVP) {
			error = VOP_OPEN(lvp, FREAD, fp->f_cred, p);
			VOP_UNLOCK(lvp);

			if (error) {
				vrele(lvp);
				return (error);
			}
			fp->f_data = (caddr_t) lvp;
			fp->f_offset = 0;
			error = vn_close(vp, FREAD, fp->f_cred, p);
			if (error)
				return (error);
			vp = lvp;
			goto unionread;
		}
	}
}
#endif /* UNION */
@


1.2
log
@Merge of NetBSD 960317
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 4
d229 6
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: vfs_syscalls_43.c,v 1.3 1995/10/07 06:26:31 mycroft Exp $	*/
d66 2
d71 1
a71 1
static int
d118 1
a118 1
	if (error = namei(&nd))
d152 1
a152 1
	if (error = namei(&nd))
d196 1
d382 1
a382 1
	if (error = getvnode(p->p_fd, SCARG(uap, fd), &fp))
d457 1
a457 1
	extern int (**union_vnodeop_p)();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
