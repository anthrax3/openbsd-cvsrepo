head	1.5;
access;
symbols
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.3.0.26
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.22
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.24
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.20
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.18
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.16
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.14
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.12
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.10
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.8
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.5
date	2011.06.30.13.45.00;	author tedu;	state dead;
branches;
next	1.4;

1.4
date	2011.01.03.23.08.07;	author guenther;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.15.11.00.12;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.14.23.45.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.03.17.38.48;	author millert;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.06.05.23.12.34;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove compat_35 files
@
text
@/*	$OpenBSD: kern_ipc_35.c,v 1.4 2011/01/03 23:08:07 guenther Exp $	*/

/*
 * Copyright (c) 2004 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

/*
 * Old-style (OpenBSD 3.5 and earlier) structures, where ipc_perm
 * used a 16bit int for 'mode'.
 */
struct ipc_perm35 {
	uid_t		cuid;	/* creator user id */
	gid_t		cgid;	/* creator group id */
	uid_t		uid;	/* user id */
	gid_t		gid;	/* group id */
	u_int16_t	mode;	/* r/w permission */
	unsigned short	seq;	/* sequence # (to generate unique id) */
	key_t		key;	/* user specified msg/sem/shm key */
};

struct msqid_ds35 {
	struct ipc_perm35 msg_perm;	/* msg queue permission bits */
	struct msg	  *msg_first;	/* first message in the queue */
	struct msg	  *msg_last;	/* last message in the queue */
	unsigned long	  msg_cbytes;	/* number of bytes in use on queue */
	unsigned long	  msg_qnum;	/* number of msgs in the queue */
	unsigned long	  msg_qbytes;	/* max # of bytes on the queue */
	pid_t		  msg_lspid;	/* pid of last msgsnd() */
	pid_t		  msg_lrpid;	/* pid of last msgrcv() */
	time_t		  msg_stime;	/* time of last msgsnd() */
	long		  msg_pad1;
	time_t		  msg_rtime;	/* time of last msgrcv() */
	long		  msg_pad2;
	time_t		  msg_ctime;	/* time of last msgctl() */
	long		  msg_pad3;
	long		  msg_pad4[4];
};

struct semid_ds35 {
	struct ipc_perm35 sem_perm;	/* operation permission struct */
	struct sem	  *sem_base;	/* pointer to first semaphore in set */
	unsigned short	  sem_nsems;	/* number of sems in set */
	time_t		  sem_otime;	/* last operation time */
	long		  sem_pad1;	/* SVABI/386 says I need this here */
	time_t		  sem_ctime;	/* last change time */
	    				/* Times measured in secs since */
	    				/* 00:00:00 GMT, Jan. 1, 1970 */
	long		  sem_pad2;	/* SVABI/386 says I need this here */
	long		  sem_pad3[4];	/* SVABI/386 says I need this here */
};

struct shmid_ds35 {
	struct ipc_perm35 shm_perm;	/* operation permission structure */
	int		  shm_segsz;	/* size of segment in bytes */
	pid_t		  shm_lpid;	/* process ID of last shm op */
	pid_t		  shm_cpid;	/* process ID of creator */
	shmatt_t	  shm_nattch;	/* number of current attaches */
	time_t		  shm_atime;	/* time of last shmat() */
	time_t		  shm_dtime;	/* time of last shmdt() */
	time_t		  shm_ctime;	/* time of last change by shmctl() */
	void		  *shm_internal;/* implementation specific data */
};

#ifdef SYSVMSG
/*
 * Old-style shmget(2) used int for the size parameter, we now use size_t.
 */
int
compat_35_sys_shmget(struct proc *p, void *v, register_t *retval)
{
	struct compat_35_sys_shmget_args /* {
		syscallarg(key_t) key;
		syscallarg(int) size;
		syscallarg(int) shmflg;
	} */ *uap = v;
	struct sys_shmget_args /* {
		syscallarg(key_t) key;
		syscallarg(size_t) size;
		syscallarg(int) shmflg;
	} */ shmget_args;

	SCARG(&shmget_args, key) = SCARG(uap, key);
	SCARG(&shmget_args, size) = (size_t)SCARG(uap, size);
	SCARG(&shmget_args, shmflg) = SCARG(uap, shmflg);

	return (sys_shmget(p, &shmget_args, retval));
}
#endif

#ifdef SYSVSEM
/*
 * Old-style shmget(2) used u_int for the nsops parameter, we now use size_t.
 */
int
compat_35_sys_semop(struct proc *p, void *v, register_t *retval)
{
	struct compat_35_sys_semop_args /* {
		syscallarg(int) semid;
		syscallarg(struct sembuf *) sops;
		syscallarg(u_int) nsops;
	} */ *uap = v;
	struct sys_semop_args /* {
		syscallarg(int) semid;
		syscallarg(struct sembuf *) sops;
		syscallarg(size_t) nsops;
	} */ semop_args;

	SCARG(&semop_args, semid) = SCARG(uap, semid);
	SCARG(&semop_args, sops) = SCARG(uap, sops);
	SCARG(&semop_args, nsops) = (size_t)SCARG(uap, nsops);

	return (sys_semop(p, &semop_args, retval));
}
#endif

/*
 * Convert between new and old struct {msq,sem,shm}id_ds (both ways)
 */
#if defined(SYSVMSG) || defined(SYSVSEM) || defined(SYSVSHM)
#define cvt_ds(to, from, type, base) do {				\
	(to)->type##_perm.cuid = (from)->type##_perm.cuid;		\
	(to)->type##_perm.cgid = (from)->type##_perm.cgid;		\
	(to)->type##_perm.uid = (from)->type##_perm.uid;		\
	(to)->type##_perm.gid = (from)->type##_perm.gid;		\
	(to)->type##_perm.mode = (from)->type##_perm.mode & 0xffffU;	\
	(to)->type##_perm.seq = (from)->type##_perm.seq;		\
	(to)->type##_perm.key = (from)->type##_perm.key;		\
	bcopy((caddr_t)&(from)->base, (caddr_t)&(to)->base,		\
	    sizeof(*(to)) - ((caddr_t)&(to)->base - (caddr_t)to));	\
} while (0)
#endif /* SYSVMSG || SYSVSEM || SYSVSHM */

#ifdef SYSVMSG
/*
 * Copy a struct msqid_ds35 from userland and convert to struct msqid_ds
 */
static int
msqid_copyin(const void *uaddr, void *kaddr, size_t len)
{
	struct msqid_ds *msqbuf = kaddr;
	struct msqid_ds35 omsqbuf;
	int error;

	if (len != sizeof(struct msqid_ds))
		return (EFAULT);
	if ((error = copyin(uaddr, &omsqbuf, sizeof(omsqbuf))) == 0)
		cvt_ds(msqbuf, &omsqbuf, msg, msg_first);
	return (error);
}

/*
 * Convert a struct msqid_ds to struct msqid_ds35 and copy to userland
 */
static int
msqid_copyout(const void *kaddr, void *uaddr, size_t len)
{
	const struct msqid_ds *msqbuf = kaddr;
	struct msqid_ds35 omsqbuf;

	if (len != sizeof(struct msqid_ds))
		return (EFAULT);
	cvt_ds(&omsqbuf, msqbuf, msg, msg_first);
	return (copyout(&omsqbuf, uaddr, sizeof(omsqbuf)));
}

/*
 * OpenBSD 3.5 msgctl(2) with 16bit mode_t in struct ipcperm.
 */
int
compat_35_sys_msgctl(struct proc *p, void *v, register_t *retval)
{
	struct compat_35_sys_msgctl_args /* {
		syscallarg(int) msqid;
		syscallarg(int) cmd;
		syscallarg(struct msqid_ds35 *) buf;
	} */ *uap = v;

	return (msgctl1(p, SCARG(uap, msqid), SCARG(uap, cmd),
	    (caddr_t)SCARG(uap, buf), msqid_copyin, msqid_copyout));
}
#endif /* SYSVMSG */

#ifdef SYSVSEM
/*
 * Copy a struct semid_ds35 from userland and convert to struct semid_ds
 */
static int
semid_copyin(const void *uaddr, void *kaddr, size_t len)
{
	struct semid_ds *sembuf = kaddr;
	struct semid_ds35 osembuf;
	int error;

	if (len != sizeof(struct semid_ds))
		return (EFAULT);
	if ((error = copyin(uaddr, &osembuf, sizeof(osembuf))) == 0)
		cvt_ds(sembuf, &osembuf, sem, sem_base);
	return (error);
}

/*
 * Convert a struct semid_ds to struct semid_ds35 and copy to userland
 */
static int
semid_copyout(const void *kaddr, void *uaddr, size_t len)
{
	const struct semid_ds *sembuf = kaddr;
	struct semid_ds35 osembuf;

	if (len != sizeof(struct semid_ds))
		return (EFAULT);
	cvt_ds(&osembuf, sembuf, sem, sem_base);
	return (copyout(&osembuf, uaddr, sizeof(osembuf)));
}

/*
 * OpenBSD 3.5 semctl(2) with 16bit mode_t in struct ipcperm.
 */
int
compat_35_sys___semctl(struct proc *p, void *v, register_t *retval)
{
	struct compat_35_sys___semctl_args /* {
		syscallarg(int) semid;
		syscallarg(int) semnum;
		syscallarg(int) cmd;
		syscallarg(union semun *) arg;
	} */ *uap = v;
	union semun arg;
	int error = 0, cmd = SCARG(uap, cmd);

	switch (cmd) {
	case IPC_SET:
	case IPC_STAT:
	case GETALL:
	case SETVAL:
	case SETALL:
		error = copyin(SCARG(uap, arg), &arg, sizeof(arg));
		break;
	}
	if (error == 0) {
		error = semctl1(p, SCARG(uap, semid), SCARG(uap, semnum),
		    cmd, &arg, retval, semid_copyin, semid_copyout);
	}
	return (error);
}
#endif /* SYSVSEM */

#ifdef SYSVSHM
/*
 * Copy a struct shmid_ds35 from userland and convert to struct shmid_ds
 */
static int
shmid_copyin(const void *uaddr, void *kaddr, size_t len)
{
	struct shmid_ds *shmbuf = kaddr;
	struct shmid_ds35 oshmbuf;
	int error;

	if (len != sizeof(struct shmid_ds))
		return (EFAULT);
	if ((error = copyin(uaddr, &oshmbuf, sizeof(oshmbuf))) == 0)
		cvt_ds(shmbuf, &oshmbuf, shm, shm_segsz);
	return (error);
}

/*
 * Convert a struct shmid_ds to struct shmid_ds35 and copy to userland
 */
static int
shmid_copyout(const void *kaddr, void *uaddr, size_t len)
{
	const struct shmid_ds *shmbuf = kaddr;
	struct shmid_ds35 oshmbuf;

	if (len != sizeof(struct shmid_ds))
		return (EFAULT);
	cvt_ds(&oshmbuf, shmbuf, shm, shm_segsz);
	return (copyout(&oshmbuf, uaddr, sizeof(oshmbuf)));
}

/*
 * OpenBSD 3.5 shmctl(2) with 16bit mode_t in struct ipcperm.
 */
int
compat_35_sys_shmctl(struct proc *p, void *v, register_t *retval)
{
	struct compat_35_sys_shmctl_args /* {
		syscallarg(int) shmid;
		syscallarg(int) cmd;
		syscallarg(struct shmid_ds35 *) buf;
	} */ *uap = v;

	return (shmctl1(p, SCARG(uap, shmid), SCARG(uap, cmd),
	    (caddr_t)SCARG(uap, buf), shmid_copyin, shmid_copyout));
}
#endif /* SYSVSHM */
@


1.4
log
@Remove the old COMPAT_23 SysV IPC structures and the never implemented
semconfig() declaration.  Move the COMPAT_35 SysV IPC structures into
the only source files that uses them

ok millert@@, kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ipc_35.c,v 1.3 2004/07/15 11:00:12 millert Exp $	*/
@


1.3
log
@In cvt_ds, copy from the address of the first element past the
struct ipc_perm instead of using sizeof to figure out the offset.
Might make a difference for architectures with strict alignment if
someone changes this from bcopy to memcpy and gcc inlines it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ipc_35.c,v 1.2 2004/07/14 23:45:11 millert Exp $	*/
d29 57
@


1.2
log
@Because mode_t is used in struct ipc_perm we need new versions of
the msgctl, semctl, and shmctl system calls.  This moves the old
versions to COMPAT_35 and adds new ones.

WARNING: While this fixes things like shared memory in the X server
for old (pre-mode_t change) binaries, it will break binaries that
use shared memory built between the time of the mode_t change (Jul
13th) and now.  If you rebuild X during that interval you will need
to do it again after updating the rest of userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ipc_35.c,v 1.1 2004/05/03 17:38:48 millert Exp $	*/
d86 1
a86 1
#define cvt_ds(to, from, type) do {					\
d94 2
a95 3
	bcopy((caddr_t)(from) + sizeof((from)->type##_perm),		\
	    (caddr_t)(to) + sizeof((to)->type##_perm),			\
	    sizeof(*(to)) - sizeof((to)->type##_perm));			\
d113 1
a113 1
		cvt_ds(msqbuf, &omsqbuf, msg);
d128 1
a128 1
	cvt_ds(&omsqbuf, msqbuf, msg);
d163 1
a163 1
		cvt_ds(sembuf, &osembuf, sem);
d178 1
a178 1
	cvt_ds(&osembuf, sembuf, sem);
d228 1
a228 1
		cvt_ds(shmbuf, &oshmbuf, shm);
d243 1
a243 1
	cvt_ds(&oshmbuf, shmbuf, shm);
@


1.1
log
@POSIX says the length parameter for semop(2) and shmget(2) should be size_t.
Create new syscalls with the correct parameters and add compat versions
for the old ones under COMPAT_35.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d23 1
d81 183
@


1.1.2.1
log
@Merge with the trunk
@
text
@@

