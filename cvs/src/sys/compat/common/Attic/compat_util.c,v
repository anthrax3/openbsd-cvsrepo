head	1.19;
access;
symbols
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.38
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.36
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.34
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.32
	OPENBSD_5_0:1.10.0.30
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.28
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.26
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.22
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.24
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.20
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.18
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.16
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.14
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.12
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.10
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.10
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.8.0.8
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.6
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.5.0.16
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.14
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.12
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.10
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.8
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2016.03.02.15.41.47;	author naddy;	state dead;
branches;
next	1.18;
commitid	ZfNt0OHZhMg52abA;

1.18
date	2015.11.07.08.02.29;	author semarie;	state Exp;
branches;
next	1.17;
commitid	C1nHPNeHv86EYHiY;

1.17
date	2015.11.05.23.43.33;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	seRu5jL84GvqoPxT;

1.16
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.15;
commitid	p4LJxGKbi0BU2cG6;

1.15
date	2015.01.26.22.51.37;	author kettenis;	state Exp;
branches;
next	1.14;
commitid	4sRCDm8befLIJUvK;

1.14
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.13;
commitid	P6Av4XGqOi3rFasL;

1.13
date	2014.07.12.18.50.00;	author tedu;	state Exp;
branches;
next	1.12;
commitid	C8XZQyreqTUCeixA;

1.12
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2014.01.15.05.31.51;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.01.06.22.28;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.20.19.24.57;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.16.20.10.50;	author jasoni;	state Exp;
branches
	1.8.8.1;
next	1.7;

1.7
date	2000.09.07.17.56.39;	author ericj;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.27.18.32.35;	author ericj;	state Exp;
branches;
next	1.5;

1.5
date	96.12.08.14.25.46;	author niklas;	state Exp;
branches
	1.5.14.1;
next	1.4;

1.4
date	96.04.18.21.21.32;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.04.46.59;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.26.01.28.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.12;	author deraadt;	state Exp;
branches;
next	;

1.5.14.1
date	2001.05.14.22.04.18;	author niklas;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	;

1.8.8.1
date	2002.10.29.00.30.51;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@remove the Linux emulation code, no longer referenced by anything
@
text
@/* 	$OpenBSD: compat_util.c,v 1.18 2015/11/07 08:02:29 semarie Exp $	*/
/* 	$NetBSD: compat_util.c,v 1.4 1996/03/14 19:31:45 christos Exp $	*/

/*
 * Copyright (c) 1994 Christos Zoulas
 * Copyright (c) 1995 Frank van der Linden
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/stat.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/signalvar.h>
#include <sys/vnode.h>
#include <sys/pledge.h>

#include <uvm/uvm_extern.h>

#include <compat/common/compat_util.h>

/*
 * Search an alternate path before passing pathname arguments on
 * to system calls. Useful for keeping a separate 'emulation tree'.
 *
 * If cflag is set, we check if an attempt can be made to create
 * the named file, i.e. we check if the directory it should
 * be in exists.
 */
int
emul_find(struct proc *p, caddr_t *sgp, const char *prefix,
    char *path, char **pbuf, int cflag)
{
	struct nameidata	 nd;
	struct nameidata	 ndroot;
	struct vattr		 vat;
	struct vattr		 vatroot;
	int			 error;
	char			*ptr, *buf, *cp;
	const char		*pr;
	size_t			 sz, len;

	buf = (char *) malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
	*pbuf = path;

	for (ptr = buf, pr = prefix; (*ptr = *pr) != '\0'; ptr++, pr++)
		continue;

	sz = MAXPATHLEN - (ptr - buf);

	/* 
	 * If sgp is not given then the path is already in kernel space
	 */
	if (sgp == NULL)
		error = copystr(path, ptr, sz, &len);
	else
		error = copyinstr(path, ptr, sz, &len);

	if (error)
		goto bad;

	if (*ptr != '/') {
		error = EINVAL;
		goto bad;
	}

	/*
	 * We know that there is a / somewhere in this pathname.
	 * Search backwards for it, to find the file's parent dir
	 * to see if it exists in the alternate tree. If it does,
	 * and we want to create a file (cflag is set). We don't
	 * need to worry about the root comparison in this case.
	 */

	if (cflag) {
		for (cp = &ptr[len] - 1; *cp != '/'; cp--)
			;
		*cp = '\0';

		NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, buf, p);
		nd.ni_pledge = PLEDGE_EXEC;

		if ((error = namei(&nd)) != 0)
			goto bad;

		*cp = '/';
	} else {
		NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, buf, p);
		nd.ni_pledge = PLEDGE_EXEC;

		if ((error = namei(&nd)) != 0)
			goto bad;

		/*
		 * We now compare the vnode of the emulation root to the one
		 * vnode asked. If they resolve to be the same, then we
		 * ignore the match so that the real root gets used.
		 * This avoids the problem of traversing "../.." to find the
		 * root directory and never finding it, because "/" resolves
		 * to the emulation root directory. This is expensive :-(
		 */
		/* XXX: prototype should have const here for NDINIT */
		NDINIT(&ndroot, LOOKUP, FOLLOW, UIO_SYSSPACE, prefix, p);
		ndroot.ni_pledge = PLEDGE_EXEC;

		if ((error = namei(&ndroot)) != 0)
			goto bad2;

		if ((error = VOP_GETATTR(nd.ni_vp, &vat, p->p_ucred, p)) != 0)
			goto bad3;

		if ((error = VOP_GETATTR(ndroot.ni_vp, &vatroot, p->p_ucred, p))
		    != 0)
			goto bad3;

		if (vat.va_fsid == vatroot.va_fsid &&
		    vat.va_fileid == vatroot.va_fileid) {
			error = ENOENT;
			goto bad3;
		}
	}
	if (sgp == NULL)
		*pbuf = buf;
	else {
		sz = &ptr[len] - buf;
		*pbuf = stackgap_alloc(sgp, sz + 1);
		if (*pbuf == NULL) {
			error = ENAMETOOLONG;
			goto bad;
		}
		if ((error = copyout(buf, *pbuf, sz)) != 0) {
			*pbuf = path;
			goto bad;
		}
		free(buf, M_TEMP, 0);
	}

	vrele(nd.ni_vp);
	if (!cflag)
		vrele(ndroot.ni_vp);
	return error;

bad3:
	vrele(ndroot.ni_vp);
bad2:
	vrele(nd.ni_vp);
bad:
	free(buf, M_TEMP, 0);
	return error;
}

caddr_t  
stackgap_init(struct proc *p)
{
	struct process *pr = p->p_p;

	if (pr->ps_stackgap == 0) {
		if (uvm_map(&pr->ps_vmspace->vm_map, &pr->ps_stackgap,
		    round_page(STACKGAPLEN), NULL, 0, 0,
		    UVM_MAPFLAG(PROT_READ | PROT_WRITE, PROT_READ | PROT_WRITE,
		    MAP_INHERIT_COPY, MADV_RANDOM, UVM_FLAG_COPYONW)))
			sigexit(p, SIGILL);
	}

        return (caddr_t)pr->ps_stackgap;
}

void *          
stackgap_alloc(caddr_t *sgp, size_t sz)
{
	void *n = (void *) *sgp;
	caddr_t nsgp;

	sz = ALIGN(sz);
	nsgp = *sgp + sz;
	if (nsgp > (caddr_t)trunc_page((vaddr_t)n) + STACKGAPLEN)
		return NULL;
	*sgp = nsgp;
	return n;
}
@


1.18
log
@typo in nd variable used for adding ni_pledge note

ok deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.17 2015/11/05 23:43:33 deraadt Exp $	*/
@


1.17
log
@These NDINIT run out of the context of the process doing execve,
so PS_PLEDGE is active.  PLEDGE_EXEC must be noted for the namei
operations, so that the action is understood by the namei check code.
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.16 2015/03/14 03:38:46 jsg Exp $	*/
d132 1
a132 1
		nd.ni_pledge = PLEDGE_EXEC;
@


1.16
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.15 2015/01/26 22:51:37 kettenis Exp $	*/
d44 1
d109 1
d117 1
d132 1
@


1.15
log
@Move the "stackgap" from the stack into its own page at a random address.
This allows us the unmap the initial part of the stack, such that it can't
be used as a staging area for ROP (or other) attacks.

ok guenther@@, tedu@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.14 2014/12/16 18:30:03 tedu Exp $	*/
a36 1
#include <sys/file.h>
@


1.14
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.13 2014/07/12 18:50:00 tedu Exp $	*/
d43 1
d180 11
a190 1
        return STACKGAPBASE;
d192 1
a192 1
 
d198 1
a198 1
	
d201 1
a201 5
#ifdef MACHINE_STACK_GROWS_UP
	if (nsgp > ((caddr_t)PS_STRINGS) + STACKGAPLEN)
		return NULL;
#else
	if (nsgp > ((caddr_t)PS_STRINGS))
a202 1
#endif
@


1.13
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.12 2014/03/26 05:23:42 guenther Exp $	*/
d44 2
@


1.12
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.11 2014/01/15 05:31:51 deraadt Exp $	*/
d157 1
a157 1
		free(buf, M_TEMP);
d170 1
a170 1
	free(buf, M_TEMP);
@


1.11
log
@remove functions that were uses by other (non-linux) compat; and
convert to ANSI protos while here
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.10 2004/08/01 06:22:28 mickey Exp $	*/
d175 1
a175 1
stackgap_init(struct emul *e)
@


1.10
log
@proper check for the end of stackgap on growinupperstacks
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.9 2002/07/20 19:24:57 art Exp $	*/
d56 2
a57 7
emul_find(p, sgp, prefix, path, pbuf, cflag)
	struct proc	 *p;
	caddr_t		 *sgp;		/* Pointer to stackgap memory */
	const char	 *prefix;
	char		 *path;
	char		**pbuf;
	int		  cflag;
d111 1
a111 2
	}
	else {
a173 24
/*
 * Translate one set of flags to another, based on the entries in
 * the given table.  If 'leftover' is specified, it is filled in
 * with any flags which could not be translated.
 */
unsigned long
emul_flags_translate(tab, in, leftover)
	const struct emul_flags_xtab *tab;
	unsigned long in;
	unsigned long *leftover;
{
        unsigned long out;
                 
        for (out = 0; tab->omask != 0; tab++) {
                if ((in & tab->omask) == tab->oval) {
                        in &= ~tab->omask;
                        out |= tab->nval;
                }
        }               
        if (leftover != NULL)
                *leftover = in;
        return (out);
}

d175 1
a175 2
stackgap_init(e) 
        struct emul *e;
d181 1
a181 3
stackgap_alloc(sgp, sz)
        caddr_t *sgp;
        size_t sz;
@


1.9
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.8 2000/10/16 20:10:50 jasoni Exp $	*/
d221 4
d227 1
@


1.8
log
@- Fix for some linux apps that broke with recent changes; from NetBSD
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.7 2000/09/07 17:56:39 ericj Exp $	*/
a207 1
#define szsigcode ((caddr_t)(e->e_esigcode - e->e_sigcode))
a208 1
#undef szsigcode
a217 3
	struct proc *p = curproc;		/* XXX */
	struct emul *e = p->p_emul;
	int sigsize = e->e_esigcode - e->e_sigcode;
d221 1
a221 1
	if (nsgp > ((caddr_t)PS_STRINGS - sigsize))
@


1.8.8.1
log
@sync to -current
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.8 2000/10/16 20:10:50 jasoni Exp $	*/
d208 1
d210 1
d220 3
d226 1
a226 1
	if (nsgp > ((caddr_t)PS_STRINGS))
@


1.7
log
@
Add bounds checking to stackgap_alloc and return NULL if space cant be
given. Make emul_find() check for this situation as well.

Changes based partly on FreeBSD and NetBSD changes.
aaron@@ ok
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.6 2000/07/27 18:32:35 ericj Exp $	*/
d218 1
d220 2
a221 2

	struct emul *e = curproc->p_emul;	/* XXX */
d223 4
a226 3

	nsgp = *sgp + ALIGN(sz);
	if (nsgp > (((caddr_t)PS_STRINGS) - sigsize))
d228 2
a229 1
	return (void *)nsgp;
@


1.6
log
@
some cleanup and add the emul_flags_translate from netbsd to translate
flags. deraadt@@ OK
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.5 1996/12/08 14:25:46 niklas Exp $	*/
d155 8
a162 1
		error = copyout(buf, *pbuf, sz);
d218 4
a221 1
        void *p = (void *) *sgp;
d223 4
a226 2
        *sgp += ALIGN(sz);
        return p;
@


1.5
log
@-Wcast-qual happiness
@
text
@d1 1
a1 1
/* 	$OpenBSD$	*/
d171 44
@


1.5.14.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* 	$OpenBSD: compat_util.c,v 1.8 2000/10/16 20:10:50 jasoni Exp $	*/
d155 1
a155 8
		if (*pbuf == NULL) {
			error = ENAMETOOLONG;
			goto bad;
		}
		if ((error = copyout(buf, *pbuf, sz)) != 0) {
			*pbuf = path;
			goto bad;
		}
a170 52
}

/*
 * Translate one set of flags to another, based on the entries in
 * the given table.  If 'leftover' is specified, it is filled in
 * with any flags which could not be translated.
 */
unsigned long
emul_flags_translate(tab, in, leftover)
	const struct emul_flags_xtab *tab;
	unsigned long in;
	unsigned long *leftover;
{
        unsigned long out;
                 
        for (out = 0; tab->omask != 0; tab++) {
                if ((in & tab->omask) == tab->oval) {
                        in &= ~tab->omask;
                        out |= tab->nval;
                }
        }               
        if (leftover != NULL)
                *leftover = in;
        return (out);
}

caddr_t  
stackgap_init(e) 
        struct emul *e;
{
#define szsigcode ((caddr_t)(e->e_esigcode - e->e_sigcode))
        return STACKGAPBASE;
#undef szsigcode
}
 
void *          
stackgap_alloc(sgp, sz)
        caddr_t *sgp;
        size_t sz;
{
	void *n = (void *) *sgp;
	caddr_t nsgp;
	struct proc *p = curproc;		/* XXX */
	struct emul *e = p->p_emul;
	int sigsize = e->e_esigcode - e->e_sigcode;
	
	sz = ALIGN(sz);
	nsgp = *sgp + sz;
	if (nsgp > ((caddr_t)PS_STRINGS - sigsize))
		return NULL;
	*sgp = nsgp;
	return n;
@


1.5.14.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/* 	$OpenBSD$	*/
d208 1
d210 1
d220 3
d226 1
a226 1
	if (nsgp > ((caddr_t)PS_STRINGS))
@


1.4
log
@Merge of NetBSD 960317
@
text
@d132 1
a132 2
		NDINIT(&ndroot, LOOKUP, FOLLOW, UIO_SYSSPACE, 
		       (char *) prefix, p);
@


1.3
log
@update from netbsd
@
text
@d1 2
a2 1
/* 	$NetBSD: compat_util.c,v 1.3 1995/10/22 08:20:44 mycroft Exp $	*/
a159 1
done:
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/* 	$NetBSD: compat_util.c,v 1.2.2.1 1995/10/22 08:22:47 mycroft Exp $	*/
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* 	$NetBSD: compat_util.c,v 1.2 1995/06/26 19:27:17 christos Exp $	*/
d88 2
a89 4
	if (error) {
		free(buf, M_TEMP);
		return error;
	}
d92 2
a93 2
		free(buf, M_TEMP);
		return EINVAL;
d105 2
a106 1
		for (cp = &ptr[len] - 1; *cp != '/'; cp--);
d111 2
a112 4
		if ((error = namei(&nd)) != 0) {
			free(buf, M_TEMP);
			return error;
		}
d119 2
a120 4
		if ((error = namei(&nd)) != 0) {
			free(buf, M_TEMP);
			return error;
		}
d134 2
a135 6
		if ((error = namei(&ndroot)) != 0) {
			/* Cannot happen! */
			free(buf, M_TEMP);
			vrele(nd.ni_vp);
			return error;
		}
d137 2
a138 3
		if ((error = VOP_GETATTR(nd.ni_vp, &vat, p->p_ucred, p)) != 0) {
			goto done;
		}
d141 2
a142 3
		    != 0) {
			goto done;
		}
d147 1
a147 1
			goto done;
a148 1

a158 1

d163 8
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
