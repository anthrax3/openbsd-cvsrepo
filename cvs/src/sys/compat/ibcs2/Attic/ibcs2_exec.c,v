head	1.21;
access;
symbols
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.18.0.10
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.8
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.6
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.12
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.10
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.8
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.10.0.10
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.8
	OPENBSD_2_8:1.10.0.6
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2010.07.01.17.30.27;	author tedu;	state dead;
branches;
next	1.20;

1.20
date	2009.06.01.20.11.38;	author weingart;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.05.19.52.23;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.18.06.26.15;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.17.16.18.28;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.03.19.58.22;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2002.08.22.22.04.42;	author art;	state Exp;
branches
	1.14.4.1
	1.14.6.1;
next	1.13;

1.13
date	2002.03.14.01.26.50;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.15.06.22.29;	author art;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	99.11.10.15.55.21;	author mickey;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.01.11.05.12.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.07.28.00.13.24;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.02.01.21.49.48;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.27.22.48.30;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.23.16.12.16;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.08.31.09.24.02;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.20.35.04;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.05.07.08.48.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.15;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2001.11.13.21.05.47;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.12.05.00.43.28;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.10.29.00.30.51;	author art;	state Exp;
branches;
next	;

1.14.4.1
date	2003.11.03.22.07.49;	author margarida;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2003.11.17.22.50.16;	author margarida;	state Exp;
branches;
next	;

1.14.6.1
date	2003.11.03.23.23.50;	author brad;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2003.11.17.16.41.19;	author brad;	state Exp;
branches;
next	;


desc
@@


1.21
log
@another day, another compat gets removed.  today is ibcs2's turn
@
text
@/*	$OpenBSD: ibcs2_exec.c,v 1.20 2009/06/01 20:11:38 weingart Exp $	*/
/*	$NetBSD: ibcs2_exec.c,v 1.12 1996/10/12 02:13:52 thorpej Exp $	*/

/*
 * Copyright (c) 1994, 1995 Scott Bartram
 * Copyright (c) 1994 Adam Glass
 * Copyright (c) 1993, 1994 Christopher G. Demetriou
 * All rights reserved.
 *
 * originally from kern/exec_ecoff.c
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Scott Bartram.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/core.h>
#include <sys/exec.h>
#include <sys/malloc.h>
#include <sys/vnode.h>
#include <sys/resourcevar.h>
#include <sys/namei.h>
#include <uvm/uvm_extern.h>

#include <compat/ibcs2/ibcs2_types.h>
#include <compat/ibcs2/ibcs2_exec.h>
#include <compat/ibcs2/ibcs2_util.h>
#include <compat/ibcs2/ibcs2_signal.h>
#include <compat/ibcs2/ibcs2_syscall.h>

int exec_ibcs2_coff_prep_omagic(struct proc *, struct exec_package *,
				     struct coff_filehdr *, 
				     struct coff_aouthdr *);
int exec_ibcs2_coff_prep_nmagic(struct proc *, struct exec_package *,
				     struct coff_filehdr *, 
				     struct coff_aouthdr *);
int exec_ibcs2_coff_prep_zmagic(struct proc *, struct exec_package *,
				     struct coff_filehdr *, 
				     struct coff_aouthdr *);
int exec_ibcs2_coff_setup_stack(struct proc *, struct exec_package *);
void cpu_exec_ibcs2_coff_setup(int, struct proc *, struct exec_package *,
				    void *);

int exec_ibcs2_xout_prep_nmagic(struct proc *, struct exec_package *,
				     struct xexec *, struct xext *);
int exec_ibcs2_xout_prep_zmagic(struct proc *, struct exec_package *,
				     struct xexec *, struct xext *);
int exec_ibcs2_xout_setup_stack(struct proc *, struct exec_package *);
int coff_load_shlib(struct proc *, char *, struct exec_package *);
static int coff_find_section(struct proc *, struct vnode *, 
				  struct coff_filehdr *, struct coff_scnhdr *,
				  int);
	

extern int bsd2ibcs_errno[];
extern struct sysent ibcs2_sysent[];
#ifdef SYSCALL_DEBUG
extern char *ibcs2_syscallnames[];
#endif
extern char sigcode[], esigcode[];

const char ibcs2_emul_path[] = "/emul/ibcs2";

struct emul emul_ibcs2 = {
	"ibcs2",
	bsd2ibcs_errno,
	ibcs2_sendsig,
	0,
	IBCS2_SYS_MAXSYSCALL,
	ibcs2_sysent,
#ifdef SYSCALL_DEBUG
	ibcs2_syscallnames,
#else
	NULL,
#endif
	0,
	copyargs,
	setregs,
	NULL,
	coredump_trad,
	sigcode,
	esigcode,
};

/*
 * exec_ibcs2_coff_makecmds(): Check if it's an coff-format executable.
 *
 * Given a proc pointer and an exec package pointer, see if the referent
 * of the epp is in coff format.  Check 'standard' magic numbers for
 * this architecture.  If that fails, return failure.
 *
 * This function is  responsible for creating a set of vmcmds which can be
 * used to build the process's vm space and inserting them into the exec
 * package.
 */

int
exec_ibcs2_coff_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	int error;
	struct coff_filehdr *fp = epp->ep_hdr;
	struct coff_aouthdr *ap;

	if (epp->ep_hdrvalid < COFF_HDR_SIZE)
		return ENOEXEC;

	if (COFF_BADMAG(fp))
		return ENOEXEC;
	
	ap = (struct coff_aouthdr *)((char *)epp->ep_hdr +
	    sizeof(struct coff_filehdr));
	switch (ap->a_magic) {
	case COFF_OMAGIC:
		error = exec_ibcs2_coff_prep_omagic(p, epp, fp, ap);
		break;
	case COFF_NMAGIC:
		error = exec_ibcs2_coff_prep_nmagic(p, epp, fp, ap);
		break;
	case COFF_ZMAGIC:
		error = exec_ibcs2_coff_prep_zmagic(p, epp, fp, ap);
		break;
	default:
		return ENOEXEC;
	}

	if (error == 0)
		epp->ep_emul = &emul_ibcs2;

	if (error)
		kill_vmcmds(&epp->ep_vmcmds);

	return error;
}

/*
 * exec_ibcs2_coff_setup_stack(): Set up the stack segment for a coff
 * executable.
 *
 * Note that the ep_ssize parameter must be set to be the current stack
 * limit; this is adjusted in the body of execve() to yield the
 * appropriate stack segment usage once the argument length is
 * calculated.
 *
 * This function returns an int for uniformity with other (future) formats'
 * stack setup functions.  They might have errors to return.
 */

int
exec_ibcs2_coff_setup_stack(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	/* DPRINTF(("enter exec_ibcs2_coff_setup_stack\n")); */

	epp->ep_maxsaddr = USRSTACK - MAXSSIZ;
	epp->ep_minsaddr = USRSTACK;
	epp->ep_ssize = p->p_rlimit[RLIMIT_STACK].rlim_cur;

	/*
	 * set up commands for stack.  note that this takes *two*, one to
	 * map the part of the stack which we can access, and one to map
	 * the part which we can't.
	 *
	 * arguably, it could be made into one, but that would require the
	 * addition of another mapping proc, which is unnecessary
	 *
	 * note that in memory, things assumed to be: 0 ....... ep_maxsaddr
	 * <stack> ep_minsaddr
	 */
	/* DPRINTF(("VMCMD: addr %x size %d\n", epp->ep_maxsaddr,
		 (epp->ep_minsaddr - epp->ep_ssize) - epp->ep_maxsaddr)); */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero,
		  ((epp->ep_minsaddr - epp->ep_ssize) - epp->ep_maxsaddr),
		  epp->ep_maxsaddr, NULLVP, 0, VM_PROT_NONE);
	/* DPRINTF(("VMCMD: addr %x size %d\n",
		 epp->ep_minsaddr - epp->ep_ssize,
		 epp->ep_ssize)); */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, epp->ep_ssize,
		  (epp->ep_minsaddr - epp->ep_ssize), NULLVP, 0,
		  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return 0;
}


/*
 * exec_ibcs2_coff_prep_omagic(): Prepare a COFF OMAGIC binary's exec package
 */

int
exec_ibcs2_coff_prep_omagic(p, epp, fp, ap)
	struct proc *p;
	struct exec_package *epp;
	struct coff_filehdr *fp;
	struct coff_aouthdr *ap;
{
	epp->ep_taddr = COFF_SEGMENT_ALIGN(ap, ap->a_tstart);
	epp->ep_tsize = ap->a_tsize;
	epp->ep_daddr = COFF_SEGMENT_ALIGN(ap, ap->a_dstart);
	epp->ep_dsize = ap->a_dsize;
	epp->ep_entry = ap->a_entry;

	/* set up command for text and data segments */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn,
		  ap->a_tsize + ap->a_dsize, epp->ep_taddr, epp->ep_vp,
		  COFF_TXTOFF(fp, ap),
		  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	if (ap->a_bsize > 0)
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, ap->a_bsize,
			  COFF_SEGMENT_ALIGN(ap, ap->a_dstart + ap->a_dsize),
			  NULLVP, 0,
			  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
	
	return exec_ibcs2_coff_setup_stack(p, epp);
}

/*
 * exec_ibcs2_coff_prep_nmagic(): Prepare a 'native' NMAGIC COFF binary's exec
 *                          package.
 */

int
exec_ibcs2_coff_prep_nmagic(p, epp, fp, ap)
	struct proc *p;
	struct exec_package *epp;
	struct coff_filehdr *fp;
	struct coff_aouthdr *ap;
{
	epp->ep_taddr = COFF_SEGMENT_ALIGN(ap, ap->a_tstart);
	epp->ep_tsize = ap->a_tsize;
	epp->ep_daddr = COFF_ROUND(ap->a_dstart, COFF_LDPGSZ);
	epp->ep_dsize = ap->a_dsize;
	epp->ep_entry = ap->a_entry;

	/* set up command for text segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, epp->ep_tsize,
		  epp->ep_taddr, epp->ep_vp, COFF_TXTOFF(fp, ap),
		  VM_PROT_READ|VM_PROT_EXECUTE);

	/* set up command for data segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, epp->ep_dsize,
		  epp->ep_daddr, epp->ep_vp, COFF_DATOFF(fp, ap),
		  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	if (ap->a_bsize > 0)
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, ap->a_bsize,
			  COFF_SEGMENT_ALIGN(ap, ap->a_dstart + ap->a_dsize),
			  NULLVP, 0,
			  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return exec_ibcs2_coff_setup_stack(p, epp);
}

/*
 * coff_find_section - load specified section header
 *
 * TODO - optimize by reading all section headers in at once
 */

static int
coff_find_section(p, vp, fp, sh, s_type)
	struct proc *p;
	struct vnode *vp;
	struct coff_filehdr *fp;
	struct coff_scnhdr *sh;
	int s_type;
{
	int i, pos, error;
	size_t siz, resid;
	
	pos = COFF_HDR_SIZE;
	for (i = 0; i < fp->f_nscns; i++, pos += sizeof(struct coff_scnhdr)) {
		siz = sizeof(struct coff_scnhdr);
		error = vn_rdwr(UIO_READ, vp, (caddr_t) sh,
		    siz, pos, UIO_SYSSPACE, 0, p->p_ucred,
		    &resid, p);
		if (error) {
			DPRINTF(("section hdr %d read error %d\n", i, error));
			return error;
		}
		siz -= resid;
		if (siz != sizeof(struct coff_scnhdr)) {
			DPRINTF(("incomplete read: hdr %d ask=%d, rem=%u got %u\n",
				 s_type, sizeof(struct coff_scnhdr),
				 resid, siz));
			return ENOEXEC;
		}
		/* DPRINTF(("found section: %x\n", sh->s_flags)); */
		if (sh->s_flags == s_type)
			return 0;
	}
	return ENOEXEC;
}

/*
 * exec_ibcs2_coff_prep_zmagic(): Prepare a COFF ZMAGIC binary's exec package
 *
 * First, set the various offsets/lengths in the exec package.
 *
 * Then, mark the text image busy (so it can be demand paged) or error
 * out if this is not possible.  Finally, set up vmcmds for the
 * text, data, bss, and stack segments.
 */

int
exec_ibcs2_coff_prep_zmagic(p, epp, fp, ap)
	struct proc *p;
	struct exec_package *epp;
	struct coff_filehdr *fp;
	struct coff_aouthdr *ap;
{
	int error;
	u_long offset;
	long dsize, baddr, bsize;
	struct coff_scnhdr sh;
	
	/* DPRINTF(("enter exec_ibcs2_coff_prep_zmagic\n")); */

	/* set up command for text segment */
	error = coff_find_section(p, epp->ep_vp, fp, &sh, COFF_STYP_TEXT);
	if (error) {		
		DPRINTF(("can't find text section: %d\n", error));
		return error;
	}
	/* DPRINTF(("COFF text addr %x size %d offset %d\n", sh.s_vaddr,
		 sh.s_size, sh.s_scnptr)); */
	epp->ep_taddr = COFF_ALIGN(sh.s_vaddr);
	offset = sh.s_scnptr - (sh.s_vaddr - epp->ep_taddr);
	epp->ep_tsize = sh.s_size + (sh.s_vaddr - epp->ep_taddr);

#ifdef notyet
	/*
	 * check if vnode is in open for writing, because we want to
	 * demand-page out of it.  if it is, don't do it, for various
	 * reasons
n	 */
	if ((ap->a_tsize != 0 || ap->a_dsize != 0) &&
	    epp->ep_vp->v_writecount != 0) {
#ifdef DIAGNOSTIC
		if (epp->ep_vp->v_flag & VTEXT)
			panic("exec: a VTEXT vnode has writecount != 0");
#endif
		return ETXTBSY;
	}
	vn_marktext(epp->ep_vp);
#endif
	
	/* DPRINTF(("VMCMD: addr %x size %d offset %d\n", epp->ep_taddr,
		 epp->ep_tsize, offset)); */
#ifdef notyet
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, epp->ep_tsize,
		  epp->ep_taddr, epp->ep_vp, offset,
		  VM_PROT_READ|VM_PROT_EXECUTE);
#else
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, epp->ep_tsize,
		  epp->ep_taddr, epp->ep_vp, offset,
		  VM_PROT_READ|VM_PROT_EXECUTE);
#endif

	/* set up command for data segment */
	error = coff_find_section(p, epp->ep_vp, fp, &sh, COFF_STYP_DATA);
	if (error) {
		DPRINTF(("can't find data section: %d\n", error));
		return error;
	}
	/* DPRINTF(("COFF data addr %x size %d offset %d\n", sh.s_vaddr,
		 sh.s_size, sh.s_scnptr)); */
	epp->ep_daddr = COFF_ALIGN(sh.s_vaddr);
	offset = sh.s_scnptr - (sh.s_vaddr - epp->ep_daddr);
	dsize = sh.s_size + (sh.s_vaddr - epp->ep_daddr);
	epp->ep_dsize = dsize + ap->a_bsize;

	/* DPRINTF(("VMCMD: addr %x size %d offset %d\n", epp->ep_daddr,
		 dsize, offset)); */
#ifdef notyet
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, dsize,
		  epp->ep_daddr, epp->ep_vp, offset,
		  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
#else
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn,
		  dsize, epp->ep_daddr, epp->ep_vp, offset,
		  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
#endif

	/* set up command for bss segment */
	baddr = round_page(epp->ep_daddr + dsize);
	bsize = epp->ep_daddr + epp->ep_dsize - baddr;
	if (bsize > 0) {
		/* DPRINTF(("VMCMD: addr %x size %d offset %d\n",
			 baddr, bsize, 0)); */
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero,
			  bsize, baddr, NULLVP, 0,
			  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
	}

	/* load any shared libraries */
	error = coff_find_section(p, epp->ep_vp, fp, &sh, COFF_STYP_SHLIB);
	if (!error) {
		size_t resid;
		struct coff_slhdr *slhdr;
		char buf[128], *bufp;	/* FIXME */
		unsigned int len = sh.s_size, entry_len;
		
		/* DPRINTF(("COFF shlib size %d offset %d\n",
			 sh.s_size, sh.s_scnptr)); */

		if (len > sizeof(buf))
			return (ENOEXEC);

		error = vn_rdwr(UIO_READ, epp->ep_vp, (caddr_t) buf,
				len, sh.s_scnptr,
				UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred,
				&resid, p);
		if (error) {
			DPRINTF(("shlib section read error %d\n", error));
			return ENOEXEC;
		}
		bufp = buf;
		while (len) {
			slhdr = (struct coff_slhdr *)bufp;
#ifdef notyet
			path_index = slhdr->path_index * sizeof(long);
#endif
			entry_len = slhdr->entry_len * sizeof(long);

			/* DPRINTF(("path_index: %d entry_len: %d name: %s\n",
				 path_index, entry_len, slhdr->sl_name)); */

			if (entry_len > len)
				return (ENOEXEC);

			error = coff_load_shlib(p, slhdr->sl_name, epp);
			if (error)
				return ENOEXEC;
			bufp += entry_len;
			len -= entry_len;
		}
	}
		
	/* set up entry point */
	epp->ep_entry = ap->a_entry;

#if 0
	DPRINTF(("text addr: %x size: %d data addr: %x size: %d entry: %x\n",
		 epp->ep_taddr, epp->ep_tsize,
		 epp->ep_daddr, epp->ep_dsize,
		 epp->ep_entry));
#endif
	
	return exec_ibcs2_coff_setup_stack(p, epp);
}

int
coff_load_shlib(p, path, epp)
	struct proc *p;
	char *path;
	struct exec_package *epp;
{
	int error, taddr, tsize, daddr, dsize, offset;
	size_t siz, resid;
	struct nameidata nd;
	struct coff_filehdr fh, *fhp = &fh;
	struct coff_scnhdr sh, *shp = &sh;
	caddr_t sg = stackgap_init(p->p_emul);

	/*
	 * 1. open shlib file
	 * 2. read filehdr
	 * 3. map text, data, and bss out of it using VM_*
	 */
	IBCS2_CHECK_ALT_EXIST(p, &sg, path);
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, path, p);
	/* first get the vnode */
	if ((error = namei(&nd)) != 0) {
		DPRINTF(("coff_load_shlib: can't find library %s\n", path));
		return error;
	}

	siz = sizeof(struct coff_filehdr);
	error = vn_rdwr(UIO_READ, nd.ni_vp, (caddr_t) fhp, siz, 0,
	    UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred, &resid, p);
	if (error) {
	    DPRINTF(("filehdr read error %d\n", error));
	    vrele(nd.ni_vp);
	    return error;
	}
	siz -= resid;
	if (siz != sizeof(struct coff_filehdr)) {
	    DPRINTF(("coff_load_shlib: incomplete read: ask=%d, rem=%u got %u\n",
		     sizeof(struct coff_filehdr), resid, siz));
	    vrele(nd.ni_vp);
	    return ENOEXEC;
	}

	/* load text */
	error = coff_find_section(p, nd.ni_vp, fhp, shp, COFF_STYP_TEXT);
	if (error) {
	    DPRINTF(("can't find shlib text section\n"));
	    vrele(nd.ni_vp);
	    return error;
	}
	/* DPRINTF(("COFF text addr %x size %d offset %d\n", sh.s_vaddr,
		 sh.s_size, sh.s_scnptr)); */
	taddr = COFF_ALIGN(shp->s_vaddr);
	offset = shp->s_scnptr - (shp->s_vaddr - taddr);
	tsize = shp->s_size + (shp->s_vaddr - taddr);
	/* DPRINTF(("VMCMD: addr %x size %d offset %d\n", taddr, tsize, offset)); */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, tsize, taddr,
		  nd.ni_vp, offset,
		  VM_PROT_READ|VM_PROT_EXECUTE);

	/* load data */
	error = coff_find_section(p, nd.ni_vp, fhp, shp, COFF_STYP_DATA);
	if (error) {
	    DPRINTF(("can't find shlib data section\n"));
	    vrele(nd.ni_vp);
	    return error;
	}
	/* DPRINTF(("COFF data addr %x size %d offset %d\n", shp->s_vaddr,
		 shp->s_size, shp->s_scnptr)); */
	daddr = COFF_ALIGN(shp->s_vaddr);
	offset = shp->s_scnptr - (shp->s_vaddr - daddr);
	dsize = shp->s_size + (shp->s_vaddr - daddr);
	/* epp->ep_dsize = dsize + ap->a_bsize; */

	/* DPRINTF(("VMCMD: addr %x size %d offset %d\n", daddr, dsize, offset)); */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn,
		  dsize, daddr, nd.ni_vp, offset,
		  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* load bss */
	error = coff_find_section(p, nd.ni_vp, fhp, shp, COFF_STYP_BSS);
	if (!error) {
		int baddr = round_page(daddr + dsize);
		int bsize = daddr + dsize + shp->s_size - baddr;
		if (bsize > 0) {
			/* DPRINTF(("VMCMD: addr %x size %d offset %d\n",
			   baddr, bsize, 0)); */
			NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero,
				  bsize, baddr, NULLVP, 0,
				  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
	    }
	}
	vrele(nd.ni_vp);

	return 0;
}

int
exec_ibcs2_xout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	int error;
	struct xexec *xp = epp->ep_hdr;
	struct xext *xep;

	if (epp->ep_hdrvalid < XOUT_HDR_SIZE)
		return ENOEXEC;

	if ((xp->x_magic != XOUT_MAGIC) || (xp->x_cpu != XC_386))
		return ENOEXEC;
	if ((xp->x_renv & (XE_ABS | XE_VMOD)) || !(xp->x_renv & XE_EXEC))
		return ENOEXEC;

	xep = (struct xext *)((char *)epp->ep_hdr + sizeof(struct xexec));
#ifdef notyet
	if (xp->x_renv & XE_PURE)
		error = exec_ibcs2_xout_prep_zmagic(p, epp, xp, xep);
	else
#endif
		error = exec_ibcs2_xout_prep_nmagic(p, epp, xp, xep);

	if (error == 0)
		epp->ep_emul = &emul_ibcs2;

	if (error)
		kill_vmcmds(&epp->ep_vmcmds);

	return error;
}

/*
 * exec_ibcs2_xout_prep_nmagic(): Prepare a pure x.out binary's exec package
 *
 */

int
exec_ibcs2_xout_prep_nmagic(p, epp, xp, xep)
	struct proc *p;
	struct exec_package *epp;
	struct xexec *xp;
	struct xext *xep;
{
	int error, nseg, i;
	size_t resid;
	long baddr, bsize;
	struct xseg *xs;

	/* read in segment table */
	if (xep->xe_segsize > 16 * sizeof(*xs))
		return (ENOEXEC);
	xs = (struct xseg *)malloc(xep->xe_segsize, M_TEMP, M_WAITOK);
	error = vn_rdwr(UIO_READ, epp->ep_vp, (caddr_t)xs,
			xep->xe_segsize, xep->xe_segpos,
			UIO_SYSSPACE, 0, p->p_ucred,
			&resid, p);
	if (error) {
		DPRINTF(("segment table read error %d\n", error));
		free(xs, M_TEMP);
		return ENOEXEC;
	}

	for (nseg = xep->xe_segsize / sizeof(*xs), i = 0; i < nseg; i++) {
		switch (xs[i].xs_type) {
		case XS_TTEXT:	/* text segment */

			DPRINTF(("text addr %x psize %d vsize %d off %d\n",
				 xs[i].xs_rbase, xs[i].xs_psize,
				 xs[i].xs_vsize, xs[i].xs_filpos));

			epp->ep_taddr = xs[i].xs_rbase;	/* XXX - align ??? */
			epp->ep_tsize = xs[i].xs_vsize;

			DPRINTF(("VMCMD: addr %x size %d offset %d\n",
				 epp->ep_taddr, epp->ep_tsize,
				 xs[i].xs_filpos));
			NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn,
				  epp->ep_tsize, epp->ep_taddr,
				  epp->ep_vp, xs[i].xs_filpos,
				  VM_PROT_READ|VM_PROT_EXECUTE);
			break;

		case XS_TDATA:	/* data segment */

			DPRINTF(("data addr %x psize %d vsize %d off %d\n",
				 xs[i].xs_rbase, xs[i].xs_psize,
				 xs[i].xs_vsize, xs[i].xs_filpos));

			epp->ep_daddr = xs[i].xs_rbase;	/* XXX - align ??? */
			epp->ep_dsize = xs[i].xs_vsize;

			DPRINTF(("VMCMD: addr %x size %d offset %d\n",
				 epp->ep_daddr, xs[i].xs_psize,
				 xs[i].xs_filpos));
			NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn,
				  xs[i].xs_psize, epp->ep_daddr,
				  epp->ep_vp, xs[i].xs_filpos,
				  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

			/* set up command for bss segment */
			baddr = round_page(epp->ep_daddr + xs[i].xs_psize);
			bsize = epp->ep_daddr + epp->ep_dsize - baddr;
			if (bsize > 0) {
				DPRINTF(("VMCMD: bss addr %x size %d off %d\n",
					 baddr, bsize, 0));
				NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero,
					  bsize, baddr, NULLVP, 0,
					  VM_PROT_READ|VM_PROT_WRITE|
					  VM_PROT_EXECUTE);
			}
			break;

		default:
			break;
		}
	}

	/* set up entry point */
	epp->ep_entry = xp->x_entry;

	DPRINTF(("text addr: %x size: %d data addr: %x size: %d entry: %x\n",
		 epp->ep_taddr, epp->ep_tsize,
		 epp->ep_daddr, epp->ep_dsize,
		 epp->ep_entry));
	
	free(xs, M_TEMP);
	return exec_ibcs2_xout_setup_stack(p, epp);
}

/*
 * exec_ibcs2_xout_setup_stack(): Set up the stack segment for a x.out
 * executable.
 *
 * Note that the ep_ssize parameter must be set to be the current stack
 * limit; this is adjusted in the body of execve() to yield the
 * appropriate stack segment usage once the argument length is
 * calculated.
 *
 * This function returns an int for uniformity with other (future) formats'
 * stack setup functions.  They might have errors to return.
 */

int
exec_ibcs2_xout_setup_stack(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	epp->ep_maxsaddr = USRSTACK - MAXSSIZ;
	epp->ep_minsaddr = USRSTACK;
	epp->ep_ssize = p->p_rlimit[RLIMIT_STACK].rlim_cur;

	/*
	 * set up commands for stack.  note that this takes *two*, one to
	 * map the part of the stack which we can access, and one to map
	 * the part which we can't.
	 *
	 * arguably, it could be made into one, but that would require the
	 * addition of another mapping proc, which is unnecessary
	 *
	 * note that in memory, things assumed to be: 0 ....... ep_maxsaddr
	 * <stack> ep_minsaddr
	 */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero,
		  ((epp->ep_minsaddr - epp->ep_ssize) - epp->ep_maxsaddr),
		  epp->ep_maxsaddr, NULLVP, 0, VM_PROT_NONE);
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, epp->ep_ssize,
		  (epp->ep_minsaddr - epp->ep_ssize), NULLVP, 0,
		  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return 0;
}
@


1.20
log
@Move ibcs2_sendsig into compat.  Quit poluting machdep.

Ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.19 2009/03/05 19:52:23 kettenis Exp $	*/
@


1.19
log
@Make ELF platforms generate ELF core dumps.  Somewhat based on code from
NetBSD.

ok kurt@@, drahn@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.18 2006/12/29 13:04:37 pedro Exp $	*/
d52 1
a83 1
extern void ibcs2_sendsig(sig_t, int, int, u_long, int, union sigval);
@


1.18
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.17 2003/11/18 06:26:15 tedu Exp $	*/
d41 1
d104 1
@


1.17
log
@path_index isn't used for anything, so comment it out.  idea millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.16 2003/11/17 16:18:28 tedu Exp $	*/
d134 2
a135 1
	ap = epp->ep_hdr + sizeof(struct coff_filehdr);
d593 1
a593 1
	xep = epp->ep_hdr + sizeof(struct xexec);
@


1.16
log
@add a missing bounds check that allowed a stack overrun. reported by
Georgi Guninski.  also prevent an int overflow.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.15 2003/11/03 19:58:22 tedu Exp $	*/
d428 1
a428 1
		unsigned int len = sh.s_size, path_index, entry_len;
d447 1
d449 1
@


1.15
log
@verify exec headers before attempting malloc.  reported by Georgi Guninski.
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.14 2002/08/22 22:04:42 art Exp $	*/
d428 1
a428 1
		int len = sh.s_size, path_index, entry_len;
d433 3
d452 3
@


1.14
log
@Change the vnode locking in exec to not keep the vnode locked almost all
the time.

This could lead to problems when a process wants to do an exec on the same
vnode it's being run from and needs to copy in arguments from an uncached
page in the data segment. When that happens uvm detects a vnode deadlock
and returns an error causing execve() return EFAULT.

This fixes the regress test in regress/sys/kern/exec_self

Also, initialize scriptvp early in exec_script because it could be
used uninitialized in a failure case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.13 2002/03/14 01:26:50 millert Exp $	*/
d619 2
@


1.14.6.1
log
@MFC:
Fix by tedu@@

verify exec headers before attempting malloc.  reported by Georgi Guninski.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.14 2002/08/22 22:04:42 art Exp $	*/
a618 2
	if (xep->xe_segsize > 16 * sizeof(*xs))
		return (ENOEXEC);
@


1.14.6.2
log
@MFC:
Fix by tedu@@

add a missing bounds check that allowed a stack overrun. reported by
Georgi Guninski.  also prevent an int overflow.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.14.6.1 2003/11/03 23:23:50 brad Exp $	*/
d428 1
a428 1
		unsigned int len = sh.s_size, path_index, entry_len;
a432 3
		if (len > sizeof(buf))
			return (ENOEXEC);

a448 3

			if (entry_len > len)
				return (ENOEXEC);
@


1.14.4.1
log
@Pull patch from -current:
Fixed by tedu@@

verify exec headers before attempting malloc.  reported by Georgi Guninski.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.14 2002/08/22 22:04:42 art Exp $	*/
a618 2
	if (xep->xe_segsize > 16 * sizeof(*xs))
		return (ENOEXEC);
@


1.14.4.2
log
@Pull patch from -current:
Fix by tedu@@

add a missing bounds check that allowed a stack overrun. reported by
Georgi Guninski.  also prevent an int overflow.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.14.4.1 2003/11/03 22:07:49 margarida Exp $	*/
d428 1
a428 1
		unsigned int len = sh.s_size, path_index, entry_len;
a432 3
		if (len > sizeof(buf))
			return (ENOEXEC);

a448 3

			if (entry_len > len)
				return (ENOEXEC);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.12 2001/11/15 06:22:29 art Exp $	*/
d301 1
a301 1
		    siz, pos, UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred,
d622 1
a622 1
			UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred,
@


1.12
log
@New function vn_marktext - mark a vnode as executing a text image.
Use where VTEXT was set in vnode flags before. Doesn't do anything else (yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.11 2001/11/06 19:53:17 miod Exp $	*/
d53 1
a53 1
int exec_ibcs2_coff_prep_omagic __P((struct proc *, struct exec_package *,
d55 2
a56 2
				     struct coff_aouthdr *));
int exec_ibcs2_coff_prep_nmagic __P((struct proc *, struct exec_package *,
d58 2
a59 2
				     struct coff_aouthdr *));
int exec_ibcs2_coff_prep_zmagic __P((struct proc *, struct exec_package *,
d61 12
a72 12
				     struct coff_aouthdr *));
int exec_ibcs2_coff_setup_stack __P((struct proc *, struct exec_package *));
void cpu_exec_ibcs2_coff_setup __P((int, struct proc *, struct exec_package *,
				    void *));

int exec_ibcs2_xout_prep_nmagic __P((struct proc *, struct exec_package *,
				     struct xexec *, struct xext *));
int exec_ibcs2_xout_prep_zmagic __P((struct proc *, struct exec_package *,
				     struct xexec *, struct xext *));
int exec_ibcs2_xout_setup_stack __P((struct proc *, struct exec_package *));
int coff_load_shlib __P((struct proc *, char *, struct exec_package *));
static int coff_find_section __P((struct proc *, struct vnode *, 
d74 1
a74 1
				  int));
d82 1
a82 1
extern void ibcs2_sendsig __P((sig_t, int, int, u_long, int, union sigval));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.12 2001/11/15 06:22:29 art Exp $	*/
d53 1
a53 1
int exec_ibcs2_coff_prep_omagic(struct proc *, struct exec_package *,
d55 2
a56 2
				     struct coff_aouthdr *);
int exec_ibcs2_coff_prep_nmagic(struct proc *, struct exec_package *,
d58 2
a59 2
				     struct coff_aouthdr *);
int exec_ibcs2_coff_prep_zmagic(struct proc *, struct exec_package *,
d61 12
a72 12
				     struct coff_aouthdr *);
int exec_ibcs2_coff_setup_stack(struct proc *, struct exec_package *);
void cpu_exec_ibcs2_coff_setup(int, struct proc *, struct exec_package *,
				    void *);

int exec_ibcs2_xout_prep_nmagic(struct proc *, struct exec_package *,
				     struct xexec *, struct xext *);
int exec_ibcs2_xout_prep_zmagic(struct proc *, struct exec_package *,
				     struct xexec *, struct xext *);
int exec_ibcs2_xout_setup_stack(struct proc *, struct exec_package *);
int coff_load_shlib(struct proc *, char *, struct exec_package *);
static int coff_find_section(struct proc *, struct vnode *, 
d74 1
a74 1
				  int);
d82 1
a82 1
extern void ibcs2_sendsig(sig_t, int, int, u_long, int, union sigval);
@


1.12.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.12.2.1 2002/06/11 03:28:08 art Exp $	*/
d301 1
a301 1
		    siz, pos, UIO_SYSSPACE, 0, p->p_ucred,
d622 1
a622 1
			UIO_SYSSPACE, 0, p->p_ucred,
@


1.11
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.10 1999/11/10 15:55:21 mickey Exp $	*/
d371 1
a371 1
	epp->ep_vp->v_flag |= VTEXT;
@


1.10
log
@include syscallnames only if compiling w/ SYSCALL_DEBUG.
was already so for native and sunos, the rest was just
wasting space on it. niels@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.9 1999/01/11 05:12:12 millert Exp $	*/
d46 1
a46 1
#include <vm/vm.h>
@


1.10.2.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a46 1
#include <uvm/uvm_extern.h>
@


1.10.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.10.2.1 2001/11/13 21:05:47 niklas Exp $	*/
d371 1
a371 1
	vn_marktext(epp->ep_vp);
@


1.10.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
a53 1
int exec_ibcs2_coff_prep_omagic(struct proc *, struct exec_package *,
d55 2
a56 2
				     struct coff_aouthdr *);
int exec_ibcs2_coff_prep_nmagic(struct proc *, struct exec_package *,
d58 2
a59 2
				     struct coff_aouthdr *);
int exec_ibcs2_coff_prep_zmagic(struct proc *, struct exec_package *,
d61 12
a72 12
				     struct coff_aouthdr *);
int exec_ibcs2_coff_setup_stack(struct proc *, struct exec_package *);
void cpu_exec_ibcs2_coff_setup(int, struct proc *, struct exec_package *,
				    void *);

int exec_ibcs2_xout_prep_nmagic(struct proc *, struct exec_package *,
				     struct xexec *, struct xext *);
int exec_ibcs2_xout_prep_zmagic(struct proc *, struct exec_package *,
				     struct xexec *, struct xext *);
int exec_ibcs2_xout_setup_stack(struct proc *, struct exec_package *);
int coff_load_shlib(struct proc *, char *, struct exec_package *);
static int coff_find_section(struct proc *, struct vnode *, 
d74 1
a74 1
				  int);
d82 1
a82 1
extern void ibcs2_sendsig(sig_t, int, int, u_long, int, union sigval);
@


1.10.2.4
log
@Sync the SMP branch with 3.3
@
text
@d301 1
a301 1
		    siz, pos, UIO_SYSSPACE, 0, p->p_ucred,
d622 1
a622 1
			UIO_SYSSPACE, 0, p->p_ucred,
@


1.10.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d428 1
a428 1
		unsigned int len = sh.s_size, entry_len;
a432 3
		if (len > sizeof(buf))
			return (ENOEXEC);

a443 1
#ifdef notyet
a444 1
#endif
a449 3
			if (entry_len > len)
				return (ENOEXEC);

a618 2
	if (xep->xe_segsize > 16 * sizeof(*xs))
		return (ENOEXEC);
@


1.9
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.8 1998/07/28 00:13:24 millert Exp $	*/
d79 1
d81 1
d94 1
d96 3
@


1.8
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.7 1997/02/01 21:49:48 deraadt Exp $	*/
d361 1
a361 1
			panic("exec: a VTEXT vnode has writecount != 0\n");
@


1.7
log
@add type & union sigval args to sendsig/trapsignal
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.6 1997/01/27 22:48:30 deraadt Exp $	*/
d288 2
a289 1
	int i, pos, resid, siz, error;
d303 1
a303 1
			DPRINTF(("incomplete read: hdr %d ask=%d, rem=%d got %d\n",
d419 1
a419 1
		int resid;
d471 2
a472 2
	int error, siz, resid;
	int taddr, tsize, daddr, dsize, offset;
d501 1
a501 1
	    DPRINTF(("coff_load_shlib: incomplete read: ask=%d, rem=%d got %d\n",
d607 2
a608 1
	int error, resid, nseg, i;
@


1.6
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.5 1997/01/23 16:12:16 niklas Exp $	*/
d80 1
a80 1
extern void ibcs2_sendsig __P((sig_t, int, int, u_long, caddr_t));
@


1.5
log
@Sync with NetBSD 970118
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.4 1996/08/31 09:24:02 pefo Exp $	*/
d80 1
a80 1
extern void ibcs2_sendsig __P((sig_t, int, int, u_long));
@


1.4
log
@Cleanup exec
@
text
@d1 2
a2 2
/*	$OpenBSD: ibcs2_exec.c,v 1.3 1996/08/02 20:35:04 niklas Exp $	*/
/*	$NetBSD: ibcs2_exec.c,v 1.11 1996/05/03 17:05:19 christos Exp $	*/
d41 1
@


1.3
log
@Added Makefiles to build stuff from syscalls.master in some emulations.
Regenerated derived files from various syscalls.master files. Added $OpenBSD$.
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_exec.c,v 1.11 1996/05/03 17:05:19 christos Exp $	*/
d95 1
@


1.2
log
@sync with 0504; mostly proto changes (some svr4 ioctl changes)
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ibcs2_exec.c,v 1.10 1995/06/24 20:18:55 christos Exp $	*/
d70 4
a114 2
	u_long midmag, magic;
	u_short mid;
a145 1
bad:
d290 4
a293 4
		if (error = vn_rdwr(UIO_READ, vp, (caddr_t) sh,
				    siz, pos,
				    UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred,
				    &resid, p)) {
d482 1
a482 1
	if (error = namei(&nd)) {
d488 3
a490 3
	if (error = vn_rdwr(UIO_READ, nd.ni_vp, (caddr_t) fhp, siz, 0,
			    UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred,
			    &resid, p)) {
a561 2
	u_long midmag, magic;
	u_short mid;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
