head	1.31;
access;
symbols
	OPENBSD_4_7:1.30.0.2
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.29.0.10
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.6
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.4
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.28.0.14
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.12
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.10
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.8
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.6
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.4
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.25
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	SMP:1.14.0.6
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.4
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2010.07.01.17.30.27;	author tedu;	state dead;
branches;
next	1.30;

1.30
date	2009.09.05.10.28.41;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.01.15.14.44;	author martin;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.22.23.52.18;	author jfb;	state Exp;
branches;
next	1.27;

1.27
date	2003.08.15.20.32.15;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.23.28.00;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.23.15.39.31;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.25.21.01.41;	author espie;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.03.16.03;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.50;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.12.22.14.00;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.12.18.41.20;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.07.10.11.07.25;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.23.05.48.05;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.07.17.52.23;	author ericj;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.05.20.32.13;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.02.10.00.16.11;	author niklas;	state Exp;
branches
	1.14.6.1;
next	1.13;

1.13
date	97.11.06.05.58.03;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	97.10.06.20.19.29;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.10.06.14.57.24;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.09.11.10.48.14;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.06.17.11.11.09;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.01.23.16.12.18;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.08.10.12.09.22;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.02.20.20.27;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.05.07.08.48.55;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.08.19.31.06;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.06.17.22.41;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.04.06.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.16;	author deraadt;	state Exp;
branches;
next	;

1.14.6.1
date	2000.03.24.09.09.02;	author niklas;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2001.05.14.22.04.31;	author niklas;	state Exp;
branches;
next	1.14.6.3;

1.14.6.3
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.14.6.4;

1.14.6.4
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.14.6.5;

1.14.6.5
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.14.6.6;

1.14.6.6
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.14.6.7;

1.14.6.7
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	1.14.6.8;

1.14.6.8
date	2003.06.07.11.00.36;	author ho;	state Exp;
branches;
next	1.14.6.9;

1.14.6.9
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.10.29.00.30.51;	author art;	state Exp;
branches;
next	;


desc
@@


1.31
log
@another day, another compat gets removed.  today is ibcs2's turn
@
text
@/*	$OpenBSD: ibcs2_misc.c,v 1.30 2009/09/05 10:28:41 miod Exp $	*/
/*	$NetBSD: ibcs2_misc.c,v 1.23 1997/01/15 01:37:49 perry Exp $	*/

/*
 * Copyright (c) 1994, 1995 Scott Bartram
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Header: sun_misc.c,v 1.16 93/04/07 02:46:27 torek Exp 
 *
 *	@@(#)sun_misc.c	8.1 (Berkeley) 6/18/93
 */

/*
 * IBCS2 compatibility module.
 *
 * IBCS2 system calls that are implemented differently in BSD are
 * handled here.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/dirent.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/reboot.h>
#include <sys/resource.h>
#include <sys/resourcevar.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/vnode.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/unistd.h>

#include <netinet/in.h>
#include <sys/syscallargs.h>

#include <miscfs/specfs/specdev.h>

#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>		/* must be included after vm.h */

#include <i386/include/reg.h>

#include <compat/ibcs2/ibcs2_types.h>
#include <compat/ibcs2/ibcs2_dirent.h>
#include <compat/ibcs2/ibcs2_fcntl.h>
#include <compat/ibcs2/ibcs2_time.h>
#include <compat/ibcs2/ibcs2_signal.h>
#include <compat/ibcs2/ibcs2_timeb.h>
#include <compat/ibcs2/ibcs2_unistd.h>
#include <compat/ibcs2/ibcs2_utsname.h>
#include <compat/ibcs2/ibcs2_util.h>
#include <compat/ibcs2/ibcs2_utime.h>
#include <compat/ibcs2/ibcs2_syscallargs.h>
#include <compat/ibcs2/ibcs2_sysi86.h>

#include <compat/common/compat_dir.h>

int
ibcs2_sys_ulimit(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_ulimit_args /* {
		syscallarg(int) cmd;
		syscallarg(int) newlimit;
	} */ *uap = v;
#ifdef notyet
	int error;
	struct rlimit rl;
	struct sys_setrlimit_args sra;
#endif
#define IBCS2_GETFSIZE		1
#define IBCS2_SETFSIZE		2
#define IBCS2_GETPSIZE		3
#define IBCS2_GETDTABLESIZE	4
	
	switch (SCARG(uap, cmd)) {
	case IBCS2_GETFSIZE:
		*retval = p->p_rlimit[RLIMIT_FSIZE].rlim_cur;
		return 0;
	case IBCS2_SETFSIZE:	/* XXX - fix this */
#ifdef notyet
		rl.rlim_cur = SCARG(uap, newlimit);
		SCARG(&sra, which) = RLIMIT_FSIZE;
		SCARG(&sra, rlp) = &rl;
		error = setrlimit(p, &sra, retval);
		if (!error)
			*retval = p->p_rlimit[RLIMIT_FSIZE].rlim_cur;
		else
			DPRINTF(("failed "));
		return error;
#else
		*retval = SCARG(uap, newlimit);
		return 0;
#endif
	case IBCS2_GETPSIZE:
		*retval = p->p_rlimit[RLIMIT_RSS].rlim_cur; /* XXX */
		return 0;
	case IBCS2_GETDTABLESIZE:
		SCARG(uap, cmd) = IBCS2_SC_OPEN_MAX;
		return ibcs2_sys_sysconf(p, uap, retval);
	default:
		return ENOSYS;
	}
}

int
ibcs2_sys_waitsys(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_waitsys_args /* {
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
	} */ *uap = v;
	int error;
	struct sys_wait4_args w4;
#define WAITPID_EFLAGS	0x8c4	/* OF, SF, ZF, PF */
	
	SCARG(&w4, rusage) = NULL;
	if ((p->p_md.md_regs->tf_eflags & WAITPID_EFLAGS) == WAITPID_EFLAGS) {
		/* waitpid */
		SCARG(&w4, pid) = SCARG(uap, a1);
		SCARG(&w4, status) = (int *)SCARG(uap, a2);
		SCARG(&w4, options) = SCARG(uap, a3);
	} else {
		/* wait */
		SCARG(&w4, pid) = WAIT_ANY;
		SCARG(&w4, status) = (int *)SCARG(uap, a1);
		SCARG(&w4, options) = 0;
	}
	if ((error = sys_wait4(p, &w4, retval)) != 0)
		return error;
	if (SCARG(&w4, status))		/* this is real iBCS brain-damage */
		return copyin((caddr_t)SCARG(&w4, status), (caddr_t)&retval[1],
			      sizeof(SCARG(&w4, status)));
	return 0;
}

int
ibcs2_sys_execv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_execv_args /* {
		syscallarg(char *) path;
		syscallarg(char **) argp;
	} */ *uap = v;
	struct sys_execve_args ap;
	caddr_t sg;

	sg = stackgap_init(p->p_emul);
        IBCS2_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&ap, path) = SCARG(uap, path);
	SCARG(&ap, argp) = SCARG(uap, argp);
	SCARG(&ap, envp) = NULL;

	return sys_execve(p, &ap, retval);
}

int
ibcs2_sys_execve(p, v, retval) 
        struct proc *p;
	void *v;
        register_t *retval;
{
	struct ibcs2_sys_execve_args /* {
		syscallarg(char *) path;
		syscallarg(char **) argv;
		syscallarg(char **) envp;
        } */ *uap = v;
	struct sys_execve_args ap;
	caddr_t sg;

	sg = stackgap_init(p->p_emul);
	IBCS2_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&ap, path) = SCARG(uap, path);
	SCARG(&ap, argp) = SCARG(uap, argp);
	SCARG(&ap, envp) = SCARG(uap, envp);

	return sys_execve(p, &ap, retval);
}

int
ibcs2_sys_umount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_umount_args /* {
		syscallarg(char *) name;
	} */ *uap = v;
	struct sys_unmount_args um;

	SCARG(&um, path) = SCARG(uap, name);
	SCARG(&um, flags) = 0;
	return sys_unmount(p, &um, retval);
}

int
ibcs2_sys_mount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#ifdef notyet
	struct ibcs2_sys_mount_args /* {
		syscallarg(char *) special;
		syscallarg(char *) dir;
		syscallarg(int) flags;
		syscallarg(int) fstype;
		syscallarg(char *) data;
		syscallarg(int) len;
	} */ *uap = v;
	int oflags = SCARG(uap, flags), nflags, error;
	char fsname[MFSNAMELEN];

	if (oflags & (IBCS2_MS_NOSUB | IBCS2_MS_SYS5))
		return (EINVAL);
	if ((oflags & IBCS2_MS_NEWTYPE) == 0)
		return (EINVAL);
	nflags = 0;
	if (oflags & IBCS2_MS_RDONLY)
		nflags |= MNT_RDONLY;
	if (oflags & IBCS2_MS_NOSUID)
		nflags |= MNT_NOSUID;
	if (oflags & IBCS2_MS_REMOUNT)
		nflags |= MNT_UPDATE;
	SCARG(uap, flags) = nflags;

	if (error = copyinstr((caddr_t)SCARG(uap, type), fsname, sizeof fsname,
			      (u_int *)0))
		return (error);

	if (strncmp(fsname, "4.2", sizeof fsname) == 0) {
		SCARG(uap, type) = (caddr_t)STACK_ALLOC();
		if (error = copyout("ffs", SCARG(uap, type), sizeof("ffs")))
			return (error);
	} else if (strncmp(fsname, "nfs", sizeof fsname) == 0) {
		struct ibcs2_nfs_args sna;
		struct sockaddr_in sain;
		struct nfs_args na;
		struct sockaddr sa;

		if (error = copyin(SCARG(uap, data), &sna, sizeof sna))
			return (error);
		if (error = copyin(sna.addr, &sain, sizeof sain))
			return (error);
		bcopy(&sain, &sa, sizeof sa);
		sa.sa_len = sizeof(sain);
		SCARG(uap, data) = (caddr_t)STACK_ALLOC();
		na.addr = (struct sockaddr *)((int)SCARG(uap, data) + sizeof na);
		na.sotype = SOCK_DGRAM;
		na.proto = IPPROTO_UDP;
		na.fh = (nfsv2fh_t *)sna.fh;
		na.flags = sna.flags;
		na.wsize = sna.wsize;
		na.rsize = sna.rsize;
		na.timeo = sna.timeo;
		na.retrans = sna.retrans;
		na.hostname = sna.hostname;

		if (error = copyout(&sa, na.addr, sizeof sa))
			return (error);
		if (error = copyout(&na, SCARG(uap, data), sizeof na))
			return (error);
	}
	return (sys_mount(p, uap, retval));
#else
	return EINVAL;
#endif
}

/*
 * Read iBCS2-style directory entries.  We suck them into kernel space so
 * that they can be massaged before being copied out to user code.  Like
 * SunOS, we squish out `empty' entries.
 *
 * This is quite ugly, but what do you expect from compatibility code?
 */

int ibcs2_readdir_callback(void *, struct dirent *, off_t);
int ibcs2_classicread_callback(void *, struct dirent *, off_t);

struct ibcs2_readdir_callback_args {
	caddr_t outp;
	int     resid;
};

int
ibcs2_readdir_callback(arg, bdp, cookie)
	void *arg;
	struct dirent *bdp;
	off_t cookie;
{
	struct ibcs2_dirent idb;
	struct ibcs2_readdir_callback_args *cb = arg; 
	int ibcs2_reclen;
	int error;

	ibcs2_reclen = IBCS2_RECLEN(&idb, bdp->d_namlen);
	if (cb->resid < ibcs2_reclen)
		return (ENOMEM);

	/*
	 * Massage in place to make a iBCS2-shaped dirent (otherwise
	 * we have to worry about touching user memory outside of
	 * the copyout() call).
	 */
	idb.d_ino = (ibcs2_ino_t)bdp->d_fileno;
	idb.d_pad = 0;
	idb.d_off = (ibcs2_off_t)cookie;
	idb.d_reclen = (u_short)ibcs2_reclen;
	strlcpy(idb.d_name, bdp->d_name, sizeof(idb.d_name));
	error = copyout((caddr_t)&idb, cb->outp, ibcs2_reclen);
	if (error)
		return (error);

	/* advance output past iBCS2-shaped entry */
	cb->outp += ibcs2_reclen;
	cb->resid -= ibcs2_reclen;

	return (0);
}

int
ibcs2_classicread_callback(arg, bdp, cookie)
	void *arg;
	struct dirent *bdp;
	off_t cookie;
{
	struct ibcs2_direct {
		ibcs2_ino_t ino;
		char name[14];
	} idb;
	struct ibcs2_readdir_callback_args *cb = arg; 
	int ibcs2_reclen;
	int error;
	
	ibcs2_reclen = 16;
	if (cb->resid < ibcs2_reclen)
		return (ENOMEM);

	/*
	 * TODO: if length(filename) > 14 then break filename into
	 * multiple entries and set inode = 0xffff except last
	 */
	idb.ino = (bdp->d_fileno > 0xfffe) ? 0xfffe : bdp->d_fileno;
	bzero(&idb.name, sizeof(idb.name));
	strncpy(idb.name, bdp->d_name, 14);
	error = copyout(&idb, cb->outp, ibcs2_reclen);
	if (error)
		return (error);

	/* advance output past iBCS2-shaped entry */
	cb->outp += ibcs2_reclen;
	cb->resid -= ibcs2_reclen;

	return (0);
}

int
ibcs2_sys_getdents(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct ibcs2_sys_getdents_args /* {
		syscallarg(int) fd;
		syscallarg(char *) buf;
		syscallarg(int) nbytes;
	} */ *uap = v;
	struct ibcs2_readdir_callback_args args;
	struct file *fp;
	int error;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	args.resid = SCARG(uap, nbytes);
	args.outp = (caddr_t)SCARG(uap, buf);
	error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    ibcs2_readdir_callback, &args);
	FRELE(fp);
	if (error)
		return (error);

	*retval = SCARG(uap, nbytes) - args.resid;
	return (0);
}

int
ibcs2_sys_read(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_read_args /* {
		syscallarg(int) fd;
		syscallarg(char *) buf;
		syscallarg(u_int) nbytes;
	} */ *uap = v;
	struct vnode *vp;
	struct ibcs2_readdir_callback_args args;
	struct file *fp;
	int error;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0) {
		if (error == EINVAL)
			return sys_read(p, uap, retval);
		else
			return error;
	}
	if ((fp->f_flag & FREAD) == 0) {
		error = EBADF;
		goto bad;
	}
	vp = (struct vnode *)fp->f_data;
	if (vp->v_type != VDIR) {
		FRELE(fp);
		return sys_read(p, uap, retval);
	}

	args.resid = SCARG(uap, nbytes);
	args.outp = (caddr_t)SCARG(uap, buf);

	error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    ibcs2_classicread_callback, &args);
bad:
	FRELE(fp);
	if (error)
		return (error);

	*retval = SCARG(uap, nbytes) - args.resid;	
	return (0);
}

int
ibcs2_sys_mknod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_mknod_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
		syscallarg(int) dev;
	} */ *uap = v;
        caddr_t sg = stackgap_init(p->p_emul);

        IBCS2_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));
	if (S_ISFIFO(SCARG(uap, mode))) {
                struct sys_mkfifo_args ap;
                SCARG(&ap, path) = SCARG(uap, path);
                SCARG(&ap, mode) = SCARG(uap, mode);
		return sys_mkfifo(p, uap, retval);
	} else {
                struct sys_mknod_args ap;
                SCARG(&ap, path) = SCARG(uap, path);
                SCARG(&ap, mode) = SCARG(uap, mode);
                SCARG(&ap, dev) = SCARG(uap, dev);
                return sys_mknod(p, &ap, retval);
	}
}

int
ibcs2_sys_getgroups(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_getgroups_args /* {
		syscallarg(int) gidsetsize;
		syscallarg(ibcs2_gid_t *) gidset;
	} */ *uap = v;
	int error, i;
	ibcs2_gid_t *iset = NULL;
	struct sys_getgroups_args sa;
	gid_t *gp;
	caddr_t sg = stackgap_init(p->p_emul);

	SCARG(&sa, gidsetsize) = SCARG(uap, gidsetsize);
	if (SCARG(uap, gidsetsize)) {
		SCARG(&sa, gidset) = stackgap_alloc(&sg, NGROUPS_MAX *
						    sizeof(gid_t));
		iset = stackgap_alloc(&sg, SCARG(uap, gidsetsize) *
				      sizeof(ibcs2_gid_t));
	}
	if ((error = sys_getgroups(p, &sa, retval)) != 0)
		return error;
	if (iset) {
		for (i = 0, gp = SCARG(&sa, gidset); i < retval[0]; i++)
			iset[i] = (ibcs2_gid_t)*gp++;
		if (retval[0] && (error = copyout((caddr_t)iset,
		    (caddr_t)SCARG(uap, gidset),
		    sizeof(ibcs2_gid_t) * retval[0])))
			return error;
	}
	return 0;
}

int
ibcs2_sys_setgroups(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_setgroups_args /* {
		syscallarg(int) gidsetsize;
		syscallarg(ibcs2_gid_t *) gidset;
	} */ *uap = v;
	int error, i;
	ibcs2_gid_t *iset;
	struct sys_setgroups_args sa;
	gid_t *gp;
	caddr_t sg = stackgap_init(p->p_emul);

	SCARG(&sa, gidsetsize) = SCARG(uap, gidsetsize);
	gp = stackgap_alloc(&sg, SCARG(&sa, gidsetsize) * sizeof(gid_t));
	iset = stackgap_alloc(&sg, SCARG(&sa, gidsetsize) *
			      sizeof(ibcs2_gid_t));
	if (SCARG(&sa, gidsetsize)) {
		error = copyin((caddr_t)SCARG(uap, gidset), (caddr_t)iset, 
		    sizeof(ibcs2_gid_t) * SCARG(uap, gidsetsize));
		if (error)
			return error;
	}
	for (i = 0; i < SCARG(&sa, gidsetsize); i++)
		gp[i]= (gid_t)iset[i];
	SCARG(&sa, gidset) = gp;
	return sys_setgroups(p, &sa, retval);
}

int
ibcs2_sys_setuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_setuid_args /* {
		syscallarg(int) uid;
	} */ *uap = v;
	struct sys_setuid_args sa;

	SCARG(&sa, uid) = (uid_t)SCARG(uap, uid);
	return sys_setuid(p, &sa, retval);
}

int
ibcs2_sys_setgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_setgid_args /* {
		syscallarg(int) gid;
	} */ *uap = v;
	struct sys_setgid_args sa;

	SCARG(&sa, gid) = (gid_t)SCARG(uap, gid);
	return sys_setgid(p, &sa, retval);
}

int
xenix_sys_ftime(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct xenix_sys_ftime_args /* {
		syscallarg(struct xenix_timeb *) tp;
	} */ *uap = v;
	struct timeval tv;
	extern struct timezone tz;
	struct xenix_timeb itb;

	microtime(&tv);
	itb.time = tv.tv_sec;
	itb.millitm = (tv.tv_usec / 1000);
	itb.timezone = tz.tz_minuteswest;
	itb.dstflag = tz.tz_dsttime;
	return copyout((caddr_t)&itb, (caddr_t)SCARG(uap, tp),
	    xenix_timeb_len);
}

int
ibcs2_sys_time(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_time_args /* {
		syscallarg(ibcs2_time_t *) tp;
	} */ *uap = v;
	struct timeval tv;

	microtime(&tv);
	*retval = tv.tv_sec;
	if (SCARG(uap, tp))
		return copyout((caddr_t)&tv.tv_sec, (caddr_t)SCARG(uap, tp),
			       sizeof(ibcs2_time_t));
	else
		return 0;
}

int
ibcs2_sys_pathconf(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_pathconf_args /* {
		syscallarg(char *) path;
		syscallarg(int) name;
	} */ *uap = v;
	SCARG(uap, name)++;	/* iBCS2 _PC_* defines are offset by one */
        return sys_pathconf(p, uap, retval);
}

int
ibcs2_sys_fpathconf(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_fpathconf_args /* {
		syscallarg(int) fd;
		syscallarg(int) name;
	} */ *uap = v;
	SCARG(uap, name)++;	/* iBCS2 _PC_* defines are offset by one */
        return sys_fpathconf(p, uap, retval);
}

int
ibcs2_sys_sysconf(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_sysconf_args /* {
		syscallarg(int) name;
	} */ *uap = v;
	int mib[2], value, error;
	size_t len;
	struct sys___sysctl_args sa;
	struct sys_getrlimit_args ga;

	switch(SCARG(uap, name)) {
	case IBCS2_SC_ARG_MAX:
		mib[1] = KERN_ARGMAX;
		break;

	case IBCS2_SC_CHILD_MAX:
	    {
		caddr_t sg = stackgap_init(p->p_emul);

		SCARG(&ga, which) = RLIMIT_NPROC;
		SCARG(&ga, rlp) = stackgap_alloc(&sg, sizeof(struct rlimit));
		if ((error = sys_getrlimit(p, &ga, retval)) != 0)
			return error;
		*retval = SCARG(&ga, rlp)->rlim_cur;
		return 0;
	    }

	case IBCS2_SC_CLK_TCK:
		*retval = hz;
		return 0;

	case IBCS2_SC_NGROUPS_MAX:
		mib[1] = KERN_NGROUPS;
		break;

	case IBCS2_SC_OPEN_MAX:
	    {
		caddr_t sg = stackgap_init(p->p_emul);

		SCARG(&ga, which) = RLIMIT_NOFILE;
		SCARG(&ga, rlp) = stackgap_alloc(&sg, sizeof(struct rlimit));
		if ((error = sys_getrlimit(p, &ga, retval)) != 0)
			return error;
		*retval = SCARG(&ga, rlp)->rlim_cur;
		return 0;
	    }
		
	case IBCS2_SC_JOB_CONTROL:
		mib[1] = KERN_JOB_CONTROL;
		break;
		
	case IBCS2_SC_SAVED_IDS:
		mib[1] = KERN_SAVED_IDS;
		break;
		
	case IBCS2_SC_VERSION:
		mib[1] = KERN_POSIX1;
		break;
		
	case IBCS2_SC_PASS_MAX:
		*retval = 128;		/* XXX - should we create PASS_MAX ? */
		return 0;

	case IBCS2_SC_XOPEN_VERSION:
		*retval = 2;		/* XXX: What should that be? */
		return 0;
		
	default:
		return EINVAL;
	}

	mib[0] = CTL_KERN;
	len = sizeof(value);
	SCARG(&sa, name) = mib;
	SCARG(&sa, namelen) = 2;
	SCARG(&sa, old) = &value;
	SCARG(&sa, oldlenp) = &len;
	SCARG(&sa, new) = NULL;
	SCARG(&sa, newlen) = 0;
	if ((error = sys___sysctl(p, &sa, retval)) != 0)
		return error;
	*retval = value;
	return 0;
}

int
ibcs2_sys_alarm(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_alarm_args /* {
		syscallarg(unsigned) sec;
	} */ *uap = v;
	int error;
        struct itimerval *itp, *oitp;
	struct sys_setitimer_args sa;
	caddr_t sg = stackgap_init(p->p_emul);

        itp = stackgap_alloc(&sg, sizeof(*itp));
	oitp = stackgap_alloc(&sg, sizeof(*oitp));
        timerclear(&itp->it_interval);
        itp->it_value.tv_sec = SCARG(uap, sec);
        itp->it_value.tv_usec = 0;

	SCARG(&sa, which) = ITIMER_REAL;
	SCARG(&sa, itv) = itp;
	SCARG(&sa, oitv) = oitp;
        error = sys_setitimer(p, &sa, retval);
	if (error)
		return error;
        if (oitp->it_value.tv_usec)
                oitp->it_value.tv_sec++;
        *retval = oitp->it_value.tv_sec;
        return 0;
}

int
ibcs2_sys_getmsg(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#ifdef notyet
	struct ibcs2_sys_getmsg_args /* {
		syscallarg(int) fd;
		syscallarg(struct ibcs2_stropts *) ctl;
		syscallarg(struct ibcs2_stropts *) dat;
		syscallarg(int *) flags;
	} */ *uap = v;
#endif

	return 0;
}

int
ibcs2_sys_putmsg(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#ifdef notyet
	struct ibcs2_sys_putmsg_args /* {
		syscallarg(int) fd;
		syscallarg(struct ibcs2_stropts *) ctl;
		syscallarg(struct ibcs2_stropts *) dat;
		syscallarg(int) flags;
	} */ *uap = v;
#endif

	return 0;
}

int
ibcs2_sys_times(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_times_args /* {
		syscallarg(struct tms *) tp;
	} */ *uap = v;
	int error;
	struct sys_getrusage_args ga;
	struct tms tms;
        struct timeval t;
	caddr_t sg = stackgap_init(p->p_emul);
        struct rusage *ru = stackgap_alloc(&sg, sizeof(*ru));
#define CONVTCK(r)      (r.tv_sec * hz + r.tv_usec / (1000000 / hz))

	SCARG(&ga, who) = RUSAGE_SELF;
	SCARG(&ga, rusage) = ru;
	error = sys_getrusage(p, &ga, retval);
	if (error)
                return error;
        tms.tms_utime = CONVTCK(ru->ru_utime);
        tms.tms_stime = CONVTCK(ru->ru_stime);

	SCARG(&ga, who) = RUSAGE_CHILDREN;
        error = sys_getrusage(p, &ga, retval);
	if (error)
		return error;
        tms.tms_cutime = CONVTCK(ru->ru_utime);
        tms.tms_cstime = CONVTCK(ru->ru_stime);

	microtime(&t);
        *retval = CONVTCK(t);
	
	return copyout((caddr_t)&tms, (caddr_t)SCARG(uap, tp),
		       sizeof(struct tms));
}

int
ibcs2_sys_stime(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_stime_args /* {
		syscallarg(long *) timep;
	} */ *uap = v;
	int error;
	struct sys_settimeofday_args sa;
	caddr_t sg = stackgap_init(p->p_emul);
	struct timeval *tvp;

	tvp = stackgap_alloc(&sg, sizeof(*SCARG(&sa, tv)));
	SCARG(&sa, tzp) = NULL;
	error = copyin((caddr_t)SCARG(uap, timep), (void *)&tvp->tv_sec,
	    sizeof(long));
	if (error)
		return error;
	tvp->tv_usec = 0;
	SCARG(&sa, tv) = tvp;
	if ((error = sys_settimeofday(p, &sa, retval)) != 0)
		return EPERM;
	return 0;
}

int
ibcs2_sys_utime(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_utime_args /* {
		syscallarg(char *) path;
		syscallarg(struct ibcs2_utimbuf *) buf;
	} */ *uap = v;
	int error;
	struct sys_utimes_args sa;
	struct timeval *tp;
	caddr_t sg = stackgap_init(p->p_emul);

	tp = stackgap_alloc(&sg, 2 * sizeof(struct timeval));
        IBCS2_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	SCARG(&sa, path) = SCARG(uap, path);
	if (SCARG(uap, buf)) {
		struct ibcs2_utimbuf ubuf;

		error = copyin((caddr_t)SCARG(uap, buf), (caddr_t)&ubuf,
		    sizeof(ubuf));
		if (error)
			return error;
		tp[0].tv_sec = ubuf.actime;
		tp[0].tv_usec = 0;
		tp[1].tv_sec = ubuf.modtime;
		tp[1].tv_usec = 0;
		SCARG(&sa, tptr) = tp;
	} else
		SCARG(&sa, tptr) = NULL;
	return sys_utimes(p, &sa, retval);
}

int
ibcs2_sys_nice(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_nice_args /* {
		syscallarg(int) incr;
	} */ *uap = v;
	int error;
	struct sys_setpriority_args sa;

	SCARG(&sa, which) = PRIO_PROCESS;
	SCARG(&sa, who) = 0;
	SCARG(&sa, prio) = p->p_nice - PZERO + SCARG(uap, incr);
	if ((error = sys_setpriority(p, &sa, retval)) != 0)
		return EPERM;
	*retval = p->p_nice - PZERO;
	return 0;
}

/*
 * iBCS2 getpgrp, setpgrp, setsid, and setpgid
 */

int
ibcs2_sys_pgrpsys(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_pgrpsys_args /* {
		syscallarg(int) type;
		syscallarg(caddr_t) dummy;
		syscallarg(int) pid;
		syscallarg(int) pgid;
	} */ *uap = v;
	switch (SCARG(uap, type)) {
	case 0:			/* getpgrp */
		*retval = p->p_pgrp->pg_id;
		return 0;

	case 1:			/* setpgrp */
	    {
		struct sys_setpgid_args sa;

		SCARG(&sa, pid) = 0;
		SCARG(&sa, pgid) = 0;
		sys_setpgid(p, &sa, retval);
		*retval = p->p_pgrp->pg_id;
		return 0;
	    }

	case 2:			/* setpgid */
	    {
		struct sys_setpgid_args sa;

		SCARG(&sa, pid) = SCARG(uap, pid);
		SCARG(&sa, pgid) = SCARG(uap, pgid);
		return sys_setpgid(p, &sa, retval);
	    }

	case 3:			/* setsid */
		return sys_setsid(p, NULL, retval);

	default:
		return EINVAL;
	}
}

/*
 * XXX - need to check for nested calls
 */

int
ibcs2_sys_plock(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_plock_args /* {
		syscallarg(int) cmd;
	} */ *uap = v;
	int error;
#define IBCS2_UNLOCK	0
#define IBCS2_PROCLOCK	1
#define IBCS2_TEXTLOCK	2
#define IBCS2_DATALOCK	4

	
        if ((error = suser(p, 0)) != 0)
                return EPERM;
	switch(SCARG(uap, cmd)) {
	case IBCS2_UNLOCK:
	case IBCS2_PROCLOCK:
	case IBCS2_TEXTLOCK:
	case IBCS2_DATALOCK:
		return 0;	/* XXX - TODO */
	}
	return EINVAL;
}

int
ibcs2_sys_uadmin(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_uadmin_args /* {
		syscallarg(int) cmd;
		syscallarg(int) func;
		syscallarg(caddr_t) data;
	} */ *uap = v;
	int error;

#define SCO_A_REBOOT        1
#define SCO_A_SHUTDOWN      2
#define SCO_A_REMOUNT       4
#define SCO_A_CLOCK         8
#define SCO_A_SETCONFIG     128
#define SCO_A_GETDEV        130

#define SCO_AD_HALT         0
#define SCO_AD_BOOT         1
#define SCO_AD_IBOOT        2
#define SCO_AD_PWRDOWN      3
#define SCO_AD_PWRNAP       4

#define SCO_AD_PANICBOOT    1

#define SCO_AD_GETBMAJ      0
#define SCO_AD_GETCMAJ      1

	/* XXX: is this the right place for this call? */
	if ((error = suser(p, 0)) != 0)
		return (error);

	switch(SCARG(uap, cmd)) {
	case SCO_A_REBOOT:
	case SCO_A_SHUTDOWN:
		switch(SCARG(uap, func)) {
		case SCO_AD_HALT:
		case SCO_AD_PWRDOWN:
		case SCO_AD_PWRNAP:
			boot(RB_HALT);
		case SCO_AD_BOOT:
		case SCO_AD_IBOOT:
			boot(RB_AUTOBOOT);
		}
		return EINVAL;
	case SCO_A_REMOUNT:
	case SCO_A_CLOCK:
	case SCO_A_SETCONFIG:
		return 0;
	case SCO_A_GETDEV:
		return EINVAL;	/* XXX - TODO */
	}
	return EINVAL;
}

int
ibcs2_sys_sysfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_sysfs_args /* {
		syscallarg(int) cmd;
		syscallarg(caddr_t) d1;
		syscallarg(char *) buf;
	} */ *uap = v;

#define IBCS2_GETFSIND        1
#define IBCS2_GETFSTYP        2
#define IBCS2_GETNFSTYP       3

	switch(SCARG(uap, cmd)) {
	case IBCS2_GETFSIND:
	case IBCS2_GETFSTYP:
	case IBCS2_GETNFSTYP:
		break;
	}
	return EINVAL;		/* XXX - TODO */
}

int
xenix_sys_rdchk(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct xenix_sys_rdchk_args /* {
		syscallarg(int) fd;
	} */ *uap = v;
	int error;
	struct sys_ioctl_args sa;
	caddr_t sg = stackgap_init(p->p_emul);

	SCARG(&sa, fd) = SCARG(uap, fd);
	SCARG(&sa, com) = FIONREAD;
	SCARG(&sa, data) = stackgap_alloc(&sg, sizeof(int));
	if ((error = sys_ioctl(p, &sa, retval)) != 0)
		return error;
	*retval = (*((int *)SCARG(&sa, data))) ? 1 : 0;
	return 0;
}

int
xenix_sys_chsize(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct xenix_sys_chsize_args /* {
		syscallarg(int) fd;
		syscallarg(long) size;
	} */ *uap = v;
	struct sys_ftruncate_args sa;

	SCARG(&sa, fd) = SCARG(uap, fd);
	SCARG(&sa, pad) = 0;
	SCARG(&sa, length) = SCARG(uap, size);
	return sys_ftruncate(p, &sa, retval);
}

int
xenix_sys_nap(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#ifdef notyet
	struct xenix_sys_nap_args /* {
		syscallarg(int) millisec;
	} */ *uap = v;
#endif

	return ENOSYS;
}

int
ibcs2_sys_unlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_unlink_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
        caddr_t sg = stackgap_init(p->p_emul);

	IBCS2_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_unlink(p, uap, retval);
}

int
ibcs2_sys_chdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_chdir_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
        caddr_t sg = stackgap_init(p->p_emul);

	IBCS2_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_chdir(p, uap, retval);
}

int
ibcs2_sys_chmod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_chmod_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
	} */ *uap = v;
        caddr_t sg = stackgap_init(p->p_emul);

	IBCS2_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_chmod(p, uap, retval);
}

int
ibcs2_sys_chown(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_chown_args /* {
		syscallarg(char *) path;
		syscallarg(int) uid;
		syscallarg(int) gid;
	} */ *uap = v;
        caddr_t sg = stackgap_init(p->p_emul);

	IBCS2_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_chown(p, uap, retval);
}

int
ibcs2_sys_rmdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_rmdir_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
        caddr_t sg = stackgap_init(p->p_emul);

	IBCS2_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_rmdir(p, uap, retval);
}

int
ibcs2_sys_mkdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_mkdir_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
	} */ *uap = v;
        caddr_t sg = stackgap_init(p->p_emul);

	IBCS2_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));
	return sys_mkdir(p, uap, retval);
}

int
ibcs2_sys_symlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_symlink_args /* {
		syscallarg(char *) path;
		syscallarg(char *) link;
	} */ *uap = v;
        caddr_t sg = stackgap_init(p->p_emul);

	IBCS2_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	IBCS2_CHECK_ALT_CREAT(p, &sg, SCARG(uap, link));
	return sys_symlink(p, uap, retval);
}

int
ibcs2_sys_rename(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_rename_args /* {
		syscallarg(char *) from;
		syscallarg(char *) to;
	} */ *uap = v;
        caddr_t sg = stackgap_init(p->p_emul);

	IBCS2_CHECK_ALT_EXIST(p, &sg, SCARG(uap, from));
	IBCS2_CHECK_ALT_CREAT(p, &sg, SCARG(uap, to));
	return sys_rename(p, uap, retval);
}

int
ibcs2_sys_readlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_readlink_args /* {
		syscallarg(char *) path;
		syscallarg(char *) buf;
		syscallarg(int) count;
	} */ *uap = v;
        caddr_t sg = stackgap_init(p->p_emul);

	IBCS2_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_readlink(p, uap, retval);
}

int
ibcs2_sys_sysi86(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ibcs2_sys_sysi86_args /* {
		syscallarg(int) cmd;
		syscallarg(int) arg;
	} */ *uap = v;
	int val, error;

	switch (SCARG(uap, cmd)) {
	case IBCS2_SI86FPHW:
		val = IBCS2_FP_NO;
#ifdef MATH_EMULATE
		val = IBCS2_FP_SW;
#else
		val = IBCS2_FP_387;		/* a real coprocessor */
#endif
		if ((error = copyout((caddr_t)&val, (caddr_t)SCARG(uap, arg),
				     sizeof(val))))
			return error;
		break;

	case IBCS2_SI86STIME:		/* XXX - not used much, if at all */
	case IBCS2_SI86SETNAME:
		return EINVAL;

	case IBCS2_SI86PHYSMEM:
                *retval = ptoa(physmem);
		break;

	default:
		return EINVAL;
	}
	return 0;
}
@


1.30
log
@Fix various cases of stackgap_alloc() size arguments not being computed
correctly, usually yielding the right value on 32 bit machines because
sizeof int == sizeof pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.29 2007/09/01 15:14:44 martin Exp $	*/
@


1.29
log
@replace the machine dependant bytes-to-clicks macro by the MI ptoa()
version for i386

more architectures and ctob() replacement is being worked on

prodded by and ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.28 2004/06/22 23:52:18 jfb Exp $	*/
d538 1
a538 1
						    sizeof(gid_t *));
d572 1
a572 1
	gp = stackgap_alloc(&sg, SCARG(&sa, gidsetsize) * sizeof(gid_t *));
d574 1
a574 1
			      sizeof(ibcs2_gid_t *));
d577 1
a577 1
		    sizeof(ibcs2_gid_t *) * SCARG(uap, gidsetsize));
d711 1
a711 1
		SCARG(&ga, rlp) = stackgap_alloc(&sg, sizeof(struct rlimit *));
d731 1
a731 1
		SCARG(&ga, rlp) = stackgap_alloc(&sg, sizeof(struct rlimit *));
d925 1
a925 1
	tp = stackgap_alloc(&sg, 2 * sizeof(struct timeval *));
@


1.28
log
@Replace a whole bunch of scary uses of strncpy() with strlcpy() and
use compat-specific MAXNAMLEN values where appropriate

ok millert@@, pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.27 2003/08/15 20:32:15 tedu Exp $	*/
d1360 1
a1360 1
                *retval = ctob(physmem);
@


1.27
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.26 2003/06/02 23:28:00 millert Exp $	*/
d367 1
a367 1
	strlcpy(idb.d_name, bdp->d_name, IBCS2_MAXNAMLEN+1);
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.25 2002/08/23 15:39:31 art Exp $	*/
d1035 1
a1035 1
        if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d1079 1
a1079 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.25
log
@Cleanup change. Since almost all callers (except one) of getvnode did a FREF
on the returned file, do the FREF inside getvnode so that people can't
get away with avoiding FREF and FRELE.

Eyeballed by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.24 2002/04/25 21:01:41 espie Exp $	*/
d26 1
a26 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.24
log
@unfudge size_t vs. unsigned int parameters.
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.23 2002/03/14 03:16:03 millert Exp $	*/
a436 1
	FREF(fp);
d471 4
a474 2
	if ((fp->f_flag & FREAD) == 0)
		return (EBADF);
d476 2
a477 1
	if (vp->v_type != VDIR)
d479 1
a480 1
	FREF(fp);
d486 1
@


1.23
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.22 2002/03/14 01:26:50 millert Exp $	*/
d697 2
a698 1
	int mib[2], value, len, error;
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.21 2002/02/12 22:14:00 deraadt Exp $	*/
d1148 1
a1148 1
	*retval = (*((int*)SCARG(&sa, data))) ? 1 : 0;
@


1.21
log
@test before commit
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.20 2002/02/12 18:41:20 art Exp $	*/
d339 2
a340 2
int ibcs2_readdir_callback __P((void *, struct dirent *, off_t));
int ibcs2_classicread_callback __P((void *, struct dirent *, off_t));
@


1.20
log
@More FREF/FRELE protection. This time all users of getvnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.19 2001/11/06 19:53:17 miod Exp $	*/
d441 1
a441 1
	    ibcs2_readdir_callback, &args)
@


1.19
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.18 2001/07/10 11:07:25 espie Exp $	*/
d437 1
d440 4
a443 3
	
	if ((error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    ibcs2_readdir_callback, &args)) != 0)
a446 1

d478 1
d481 5
a485 3
	
	if ((error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    ibcs2_classicread_callback, &args)) != 0)
d487 2
a488 3
	
	*retval = SCARG(uap, nbytes) - args.resid;
	
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.19 2001/11/06 19:53:17 miod Exp $	*/
d339 2
a340 2
int ibcs2_readdir_callback(void *, struct dirent *, off_t);
int ibcs2_classicread_callback(void *, struct dirent *, off_t);
a436 1
	FREF(fp);
d439 3
a441 4
	error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    ibcs2_readdir_callback, &args);
	FRELE(fp);
	if (error)
d445 1
a476 1
	FREF(fp);
d479 3
a481 5

	error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    ibcs2_classicread_callback, &args);
	FRELE(fp);
	if (error)
d483 3
a485 2

	*retval = SCARG(uap, nbytes) - args.resid;	
d694 1
a694 2
	int mib[2], value, error;
	size_t len;
d1145 1
a1145 1
	*retval = (*((int *)SCARG(&sa, data))) ? 1 : 0;
@


1.19.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.19.2.1 2002/06/11 03:28:08 art Exp $	*/
d437 1
d472 2
a473 4
	if ((fp->f_flag & FREAD) == 0) {
		error = EBADF;
		goto bad;
	}
d475 1
a475 2
	if (vp->v_type != VDIR) {
		FRELE(fp);
a476 1
	}
d478 1
a483 1
bad:
@


1.18
log
@ANSI C does not like labels: without a statement after that.
Restore missing breaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.17 2001/01/23 05:48:05 csapuntz Exp $	*/
d89 1
a89 1
#include <vm/vm.h>
@


1.17
log
@

SunOS, IBCS2, Linux, and SVR4 all require translations of directory entries
from OpenBSD format to their respective native formats.

A lot of common code here for interfacing with OpenBSD VOP_READDIR. Most
of this code and logic has been moved to common/compat_dir.c

When reading a portion of the directory, the compatibility layer registers
a callback which is passed an OpenBSD-style dirent and the cookie/offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.16 2000/09/07 17:52:23 ericj Exp $	*/
d1122 1
@


1.16
log
@common/compat_util.c
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.15 2000/03/05 20:32:13 deraadt Exp $	*/
d107 1
d339 80
d430 1
a430 6
	register struct dirent *bdp;
	struct vnode *vp;
	caddr_t inp, buf;	/* BSD-format */
	int len, reclen;	/* BSD-format */
	caddr_t outp;		/* iBCS2-format */
	int resid, ibcs2_reclen;/* iBCS2-format */
d432 1
a432 7
	struct uio auio;
	struct iovec aiov;
	struct ibcs2_dirent idb;
	off_t off;			/* true file offset */
	int buflen, error, eofflag;
	u_long *cookiebuf = NULL, *cookie;
	int ncookies = 0;
d437 6
a442 2
	if ((fp->f_flag & FREAD) == 0)
		return (EBADF);
d444 1
a444 1
	vp = (struct vnode *)fp->f_data;
d446 1
a446 89
	if (vp->v_type != VDIR)	/* XXX  vnode readdir op should do this */
		return (EINVAL);

	buflen = min(MAXBSIZE, SCARG(uap, nbytes));
	buf = malloc(buflen, M_TEMP, M_WAITOK);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	off = fp->f_offset;
again:
	aiov.iov_base = buf;
	aiov.iov_len = buflen;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_procp = p;
	auio.uio_resid = buflen;
	auio.uio_offset = off;
	/*
	 * First we read into the malloc'ed buffer, then
	 * we massage it into user space, one record at a time.
	 */
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, &ncookies,
	    &cookiebuf);
	if (error)
		goto out;

	if (!error && !cookiebuf && !eofflag) {
		error = EPERM;
		goto out;
	}

	inp = buf;
	outp = SCARG(uap, buf);
	resid = SCARG(uap, nbytes);
	if ((len = buflen - auio.uio_resid) == 0)
		goto eof;

	for (cookie = cookiebuf; len > 0; len -= reclen) {
		bdp = (struct dirent *)inp;
		reclen = bdp->d_reclen;
		if (reclen & 3)
			panic("ibcs2_getdents: bad reclen");
		if (bdp->d_fileno == 0) {
			inp += reclen;	/* it is a hole; squish it out */
			off = *cookie++;
			continue;
		}
		ibcs2_reclen = IBCS2_RECLEN(&idb, bdp->d_namlen);
		if (reclen > len || resid < ibcs2_reclen) {
			/* entry too big for buffer, so just stop */
			outp++;
			break;
		}
		off = *cookie++;	/* each entry points to the next */

		/*
		 * Massage in place to make a iBCS2-shaped dirent (otherwise
		 * we have to worry about touching user memory outside of
		 * the copyout() call).
		 */
		idb.d_ino = (ibcs2_ino_t)bdp->d_fileno;
		idb.d_off = (ibcs2_off_t)off;
		idb.d_reclen = (u_short)ibcs2_reclen;
		strcpy(idb.d_name, bdp->d_name);
		error = copyout((caddr_t)&idb, outp, ibcs2_reclen);
		if (error)
			goto out;

		/* advance past this real entry */
		inp += reclen;

		/* advance output past iBCS2-shaped entry */
		outp += ibcs2_reclen;
		resid -= ibcs2_reclen;
	}

	/* if we squished out the whole block, try again */
	if (outp == SCARG(uap, buf))
		goto again;
	fp->f_offset = off;	/* update the vnode offset */

eof:
	*retval = SCARG(uap, nbytes) - resid;
out:
	VOP_UNLOCK(vp, 0, p);
	if (cookiebuf)
		free(cookiebuf, M_TEMP);
	free(buf, M_TEMP);
	return (error);
a459 1
	register struct dirent *bdp;
d461 1
a461 4
	caddr_t inp, buf;	/* BSD-format */
	int len, reclen;	/* BSD-format */
	caddr_t outp;		/* iBCS2-format */
	int resid, ibcs2_reclen;/* iBCS2-format */
d463 1
a463 10
	struct uio auio;
	struct iovec aiov;
	struct ibcs2_direct {
		ibcs2_ino_t ino;
		char name[14];
	} idb;
	off_t off;			/* true file offset */
	int buflen, error, eofflag, size;
	u_long *cookiebuf = NULL, *cookie;
	int ncookies = 0;
a475 23
	DPRINTF(("ibcs2_read: read directory\n"));
	buflen = max(MAXBSIZE, SCARG(uap, nbytes));
	buf = malloc(buflen, M_TEMP, M_WAITOK);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	off = fp->f_offset;
again:
	aiov.iov_base = buf;
	aiov.iov_len = buflen;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_procp = p;
	auio.uio_resid = buflen;
	auio.uio_offset = off;
	/*
	 * First we read into the malloc'ed buffer, then
	 * we massage it into user space, one record at a time.
	 */
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, &ncookies,
	    &cookiebuf);
	if (error)
		goto out;
d477 10
a486 59
	if (!error && !cookiebuf && !eofflag) {
		error = EPERM;
		goto out;
	}

	inp = buf;
	outp = SCARG(uap, buf);
	resid = SCARG(uap, nbytes);
	if ((len = buflen - auio.uio_resid) == 0)
		goto eof;
	for (cookie = cookiebuf; len > 0 && resid > 0; len -= reclen) {
		bdp = (struct dirent *)inp;
		reclen = bdp->d_reclen;
		if (reclen & 3)
			panic("ibcs2_read: bad reclen");
		if (bdp->d_fileno == 0) {
			inp += reclen;	/* it is a hole; squish it out */
			off = *cookie++;
			continue;
		}
		ibcs2_reclen = 16;
		if (reclen > len || resid < ibcs2_reclen) {
			/* entry too big for buffer, so just stop */
			outp++;
			break;
		}
		off = *cookie++;	/* each entry points to the next */
		/*
		 * Massage in place to make a iBCS2-shaped dirent (otherwise
		 * we have to worry about touching user memory outside of
		 * the copyout() call).
		 *
		 * TODO: if length(filename) > 14, then break filename into
		 * multiple entries and set inode = 0xffff except last
		 */
		idb.ino = (bdp->d_fileno > 0xfffe) ? 0xfffe : bdp->d_fileno;
		(void)copystr(bdp->d_name, idb.name, 14, &size);
		bzero(idb.name + size, 14 - size);
		error = copyout(&idb, outp, ibcs2_reclen);
		if (error)
			goto out;
		/* advance past this real entry */
		inp += reclen;
		/* advance output past iBCS2-shaped entry */
		outp += ibcs2_reclen;
		resid -= ibcs2_reclen;
	}
	/* if we squished out the whole block, try again */
	if (outp == SCARG(uap, buf))
		goto again;
	fp->f_offset = off;		/* update the vnode offset */
eof:
	*retval = SCARG(uap, nbytes) - resid;
out:
	VOP_UNLOCK(vp, 0, p);
	if (cookiebuf)
		free(cookiebuf, M_TEMP);
	free(buf, M_TEMP);
	return (error);
@


1.15
log
@fix size check case for getgroups; pbucich@@sion.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.14 1999/02/10 00:16:11 niklas Exp $	*/
d1021 1
a1030 1
		tp = stackgap_alloc(&sg, 2 * sizeof(struct timeval *));
@


1.14
log
@Correct directory entry reads, big directories lost entries as it were.
Also, fix the NCR SVR4 rdebug syscall emulation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.13 1997/11/06 05:58:03 csapuntz Exp $	*/
d641 9
a649 7
	for (i = 0, gp = SCARG(&sa, gidset); i < retval[0]; i++)
		iset[i] = (ibcs2_gid_t)*gp++;
	if (retval[0] && (error = copyout((caddr_t)iset,
					  (caddr_t)SCARG(uap, gidset),
					  sizeof(ibcs2_gid_t) * retval[0])))
		return error;
        return 0;
@


1.14.6.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d641 7
a647 9
	if (iset) {
		for (i = 0, gp = SCARG(&sa, gidset); i < retval[0]; i++)
			iset[i] = (ibcs2_gid_t)*gp++;
		if (retval[0] && (error = copyout((caddr_t)iset,
		    (caddr_t)SCARG(uap, gidset),
		    sizeof(ibcs2_gid_t) * retval[0])))
			return error;
	}
	return 0;
@


1.14.6.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.17 2001/01/23 05:48:05 csapuntz Exp $	*/
a106 1
#include <compat/common/compat_dir.h>
a337 80
int ibcs2_readdir_callback __P((void *, struct dirent *, off_t));
int ibcs2_classicread_callback __P((void *, struct dirent *, off_t));

struct ibcs2_readdir_callback_args {
	caddr_t outp;
	int     resid;
};

int
ibcs2_readdir_callback(arg, bdp, cookie)
	void *arg;
	struct dirent *bdp;
	off_t cookie;
{
	struct ibcs2_dirent idb;
	struct ibcs2_readdir_callback_args *cb = arg; 
	int ibcs2_reclen;
	int error;

	ibcs2_reclen = IBCS2_RECLEN(&idb, bdp->d_namlen);
	if (cb->resid < ibcs2_reclen)
		return (ENOMEM);

	/*
	 * Massage in place to make a iBCS2-shaped dirent (otherwise
	 * we have to worry about touching user memory outside of
	 * the copyout() call).
	 */
	idb.d_ino = (ibcs2_ino_t)bdp->d_fileno;
	idb.d_pad = 0;
	idb.d_off = (ibcs2_off_t)cookie;
	idb.d_reclen = (u_short)ibcs2_reclen;
	strlcpy(idb.d_name, bdp->d_name, IBCS2_MAXNAMLEN+1);
	error = copyout((caddr_t)&idb, cb->outp, ibcs2_reclen);
	if (error)
		return (error);

	/* advance output past iBCS2-shaped entry */
	cb->outp += ibcs2_reclen;
	cb->resid -= ibcs2_reclen;

	return (0);
}

int
ibcs2_classicread_callback(arg, bdp, cookie)
	void *arg;
	struct dirent *bdp;
	off_t cookie;
{
	struct ibcs2_direct {
		ibcs2_ino_t ino;
		char name[14];
	} idb;
	struct ibcs2_readdir_callback_args *cb = arg; 
	int ibcs2_reclen;
	int error;
	
	ibcs2_reclen = 16;
	if (cb->resid < ibcs2_reclen)
		return (ENOMEM);

	/*
	 * TODO: if length(filename) > 14 then break filename into
	 * multiple entries and set inode = 0xffff except last
	 */
	idb.ino = (bdp->d_fileno > 0xfffe) ? 0xfffe : bdp->d_fileno;
	bzero(&idb.name, sizeof(idb.name));
	strncpy(idb.name, bdp->d_name, 14);
	error = copyout(&idb, cb->outp, ibcs2_reclen);
	if (error)
		return (error);

	/* advance output past iBCS2-shaped entry */
	cb->outp += ibcs2_reclen;
	cb->resid -= ibcs2_reclen;

	return (0);
}

d349 6
a354 1
	struct ibcs2_readdir_callback_args args;
d356 7
a362 1
	int error;
d367 72
a438 6
	args.resid = SCARG(uap, nbytes);
	args.outp = (caddr_t)SCARG(uap, buf);
	
	if ((error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    ibcs2_readdir_callback, &args)) != 0)
		return (error);
d440 2
a441 1
	*retval = SCARG(uap, nbytes) - args.resid;
d443 18
a460 1
	return (0);
d474 1
d476 4
a479 1
	struct ibcs2_readdir_callback_args args;
d481 10
a490 1
	int error;
d503 23
d527 59
a585 10
	args.resid = SCARG(uap, nbytes);
	args.outp = (caddr_t)SCARG(uap, buf);
	
	if ((error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    ibcs2_classicread_callback, &args)) != 0)
		return (error);
	
	*retval = SCARG(uap, nbytes) - args.resid;
	
	return (0);
a1020 1
	tp = stackgap_alloc(&sg, 2 * sizeof(struct timeval *));
d1030 1
@


1.14.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.14.6.2 2001/05/14 22:04:31 niklas Exp $	*/
a1121 1
		break;
@


1.14.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 1
a89 1
#include <uvm/uvm_extern.h>
@


1.14.6.5
log
@Merge in trunk
@
text
@a436 1
	FREF(fp);
d439 3
a441 4
	error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    ibcs2_readdir_callback, &args);
	FRELE(fp);
	if (error)
d445 1
a476 1
	FREF(fp);
d479 3
a481 5

	error = readdir_with_callback(fp, &fp->f_offset, args.resid,
	    ibcs2_classicread_callback, &args);
	FRELE(fp);
	if (error)
d483 3
a485 2

	*retval = SCARG(uap, nbytes) - args.resid;	
@


1.14.6.6
log
@Merge in -current from about a week ago
@
text
@d339 2
a340 2
int ibcs2_readdir_callback(void *, struct dirent *, off_t);
int ibcs2_classicread_callback(void *, struct dirent *, off_t);
d1148 1
a1148 1
	*retval = (*((int *)SCARG(&sa, data))) ? 1 : 0;
@


1.14.6.7
log
@Sync the SMP branch with 3.3
@
text
@d437 1
d472 2
a473 4
	if ((fp->f_flag & FREAD) == 0) {
		error = EBADF;
		goto bad;
	}
d475 1
a475 2
	if (vp->v_type != VDIR) {
		FRELE(fp);
a476 1
	}
d478 1
a483 1
bad:
d697 1
a697 2
	int mib[2], value, error;
	size_t len;
@


1.14.6.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.14.6.7 2003/03/27 23:53:47 niklas Exp $	*/
d26 5
a30 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.14.6.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1035 1
a1035 1
        if ((error = suser(p, 0)) != 0)
d1079 1
a1079 1
	if ((error = suser(p, 0)) != 0)
@


1.13
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.12 1997/10/06 20:19:29 deraadt Exp $	*/
d398 1
a398 1
	if (!error && !cookiebuf) {
d413 1
a413 2
			panic("ibcs2_getdents");
		off = *cookie++;	/* each entry points to the next */
d416 1
d425 2
d439 1
d442 1
d527 1
a527 1
	if (!error && !cookiebuf) {
d541 1
a541 2
			panic("ibcs2_read");
		off = *cookie++;	/* each entry points to the next */
d544 1
d553 1
@


1.12
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.10 1997/09/11 10:48:14 deraadt Exp $	*/
d361 2
a362 2
	u_long *cookiebuf, *cookie;
	int ncookies;
d377 1
a377 3
	ncookies = buflen / 16;
	cookiebuf = malloc(ncookies * sizeof(*cookiebuf), M_TEMP, M_WAITOK);
	VOP_LOCK(vp);
d393 2
a394 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, cookiebuf,
	    ncookies);
d398 5
d452 3
a454 2
	VOP_UNLOCK(vp);
	free(cookiebuf, M_TEMP);
d485 2
a486 2
	u_long *cookiebuf, *cookie;
	int ncookies;
d502 1
a502 3
	ncookies = buflen / 16;
	cookiebuf = malloc(ncookies * sizeof(*cookiebuf), M_TEMP, M_WAITOK);
	VOP_LOCK(vp);
d518 2
a519 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, cookiebuf,
	    ncookies);
d522 6
d576 3
a578 1
	VOP_UNLOCK(vp);
@


1.11
log
@VFS Lite 2 Changes
@
text
@d361 2
a362 2
	u_long *cookiebuf = NULL, *cookie;
	int ncookies = 0;
d377 3
a379 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d395 2
a396 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, &ncookies,
	    &cookiebuf);
a399 5
	if (!error && !cookiebuf) {
		error = EPERM;
		goto out;
	}

d449 2
a450 3
	VOP_UNLOCK(vp, 0, p);
	if (cookiebuf)
		free(cookiebuf, M_TEMP);
d481 2
a482 2
	u_long *cookiebuf = NULL, *cookie;
	int ncookies = 0;
d498 3
a500 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d516 2
a517 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, &ncookies,
	    &cookiebuf);
a519 6

	if (!error && !cookiebuf) {
		error = EPERM;
		goto out;
	}

d568 1
a568 3
	VOP_UNLOCK(vp, 0, p);
	if (cookiebuf)
		free(cookiebuf, M_TEMP);
@


1.10
log
@sync with netbsd; missing SCARG() macros
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.9 1997/06/17 11:11:09 deraadt Exp $	*/
d361 2
a362 2
	u_long *cookiebuf, *cookie;
	int ncookies;
d377 1
a377 3
	ncookies = buflen / 16;
	cookiebuf = malloc(ncookies * sizeof(*cookiebuf), M_TEMP, M_WAITOK);
	VOP_LOCK(vp);
d393 2
a394 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, cookiebuf,
	    ncookies);
d398 5
d452 3
a454 2
	VOP_UNLOCK(vp);
	free(cookiebuf, M_TEMP);
d485 2
a486 2
	u_long *cookiebuf, *cookie;
	int ncookies;
d502 1
a502 3
	ncookies = buflen / 16;
	cookiebuf = malloc(ncookies * sizeof(*cookiebuf), M_TEMP, M_WAITOK);
	VOP_LOCK(vp);
d518 2
a519 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, cookiebuf,
	    ncookies);
d522 6
d576 3
a578 1
	VOP_UNLOCK(vp);
@


1.9
log
@careful with stackgap handling in execve()
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.8 1997/01/23 16:12:18 niklas Exp $	*/
d135 2
a136 2
		sra.which = RLIMIT_FSIZE;
		sra.rlp = &rl;
d151 1
a151 1
		uap->cmd = IBCS2_SC_OPEN_MAX;
@


1.8
log
@Sync with NetBSD 970118
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.7 1996/08/10 12:09:22 deraadt Exp $	*/
d203 2
a204 2
	struct sys_execve_args ea;
	caddr_t sg = stackgap_init(p->p_emul);
d206 1
d208 6
a213 4
	SCARG(&ea, path) = SCARG(uap, path);
	SCARG(&ea, argp) = SCARG(uap, argp);
	SCARG(&ea, envp) = NULL;
	return sys_execve(p, &ea, retval);
d222 1
a222 1
	struct sys_execve_args /* {
d224 1
a224 1
		syscallarg(char **) argp;
d226 10
a235 2
	} */ *uap = v;
        caddr_t sg = stackgap_init(p->p_emul);
d237 1
a237 2
        IBCS2_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
        return sys_execve(p, uap, retval);
@


1.7
log
@sys/dirent.h
@
text
@d1 2
a2 2
/*	$OpenBSD: ibcs2_misc.c,v 1.6 1996/08/02 20:20:27 niklas Exp $	*/
/*	$NetBSD: ibcs2_misc.c,v 1.15 1996/05/03 17:05:25 christos Exp $	*/
d421 2
a422 1
		if ((error = copyout((caddr_t)&idb, outp, ibcs2_reclen)))
d457 5
a461 5
	register struct vnode *vp;
	register caddr_t inp, buf;	/* BSD-format */
	register int len, reclen;	/* BSD-format */
	register caddr_t outp;		/* iBCS2-format */
	register int resid;		/* iBCS2-format */
d508 1
a508 2
	if (error) {
		DPRINTF(("VOP_READDIR failed: %d\n", error));
d510 1
a510 3
	}
	inp = buf + off;
	buflen -= off;
d520 1
a522 1
			off = *cookie++;
d525 2
a526 1
		if (reclen > len || resid < sizeof(struct ibcs2_direct)) {
d542 1
a542 1
		error = copyout(&idb, outp, sizeof(struct ibcs2_direct));
a545 1
		off = *cookie++;	/* each entry points to the next */
d548 2
a549 2
		outp += sizeof(struct ibcs2_direct);
		resid -= sizeof(struct ibcs2_direct);
d642 1
a642 2
	SCARG(&sa, gidset) = stackgap_alloc(&sg, SCARG(&sa, gidsetsize) *
					    sizeof(gid_t *));
d651 3
a653 2
	for (i = 0, gp = SCARG(&sa, gidset); i < SCARG(&sa, gidsetsize); i++)
		*gp++ = (gid_t)iset[i];
d705 2
a706 1
	return copyout((caddr_t)&itb, (caddr_t)SCARG(uap, tp), xenix_timeb_len);
d964 1
d966 1
a966 1
	SCARG(&sa, tv) = stackgap_alloc(&sg, sizeof(*SCARG(&sa, tv)));
d968 2
a969 2
	error = copyin((caddr_t)SCARG(uap, timep),
	    &(SCARG(&sa, tv)->tv_sec), sizeof(long));
d972 2
a973 1
	SCARG(&sa, tv)->tv_usec = 0;
d1003 6
a1008 8
		SCARG(&sa, tptr) = stackgap_alloc(&sg,
						  2 * sizeof(struct timeval *));
		tp = (struct timeval *)SCARG(&sa, tptr);
		tp->tv_sec = ubuf.actime;
		tp->tv_usec = 0;
		tp++;
		tp->tv_sec = ubuf.modtime;
		tp->tv_usec = 0;
d1028 1
a1028 1
	SCARG(&sa, prio) = p->p_nice + SCARG(uap, incr);
d1031 1
a1031 1
	*retval = p->p_nice;
@


1.6
log
@Make emulations use our native poll(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: ibcs2_misc.c,v 1.15 1996/05/03 17:05:25 christos Exp $	*/
d61 1
a61 1
#include <sys/dir.h>
@


1.5
log
@sync with 0504; mostly proto changes (some svr4 ioctl changes)
@
text
@d1 1
a1195 17
	return EINVAL;		/* XXX - TODO */
}

int
ibcs2_sys_poll(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#ifdef notyet
	struct ibcs2_sys_poll_args /* {
		syscallarg(struct ibcs2_pollfd *) fds;
		syscallarg(long) nfds;
		syscallarg(int) timeout;
	} */ *uap = v;
#endif

@


1.4
log
@from netbsd; Correct name of sysi86 function
@
text
@d1 1
a1 1
/*	$NetBSD: ibcs2_misc.c,v 1.14 1996/01/07 06:11:13 mycroft Exp $	*/
d117 1
d121 1
d168 1
a168 1
	int error, status;
d251 1
a259 1
#ifdef notyet
d472 1
a472 1
	if (error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) {
d504 3
a506 2
	if (error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, cookiebuf,
				ncookies)) {
d542 2
a543 1
		if (error = copyout(&idb, outp, sizeof(struct ibcs2_direct)))
d603 1
a603 1
	ibcs2_gid_t igid, *iset;
d615 1
a615 1
	if (error = sys_getgroups(p, &sa, retval))
d637 1
a637 1
	ibcs2_gid_t igid, *iset;
d648 3
a650 3
		if (error = copyin((caddr_t)SCARG(uap, gidset), (caddr_t)iset, 
				   sizeof(ibcs2_gid_t *) *
				   SCARG(uap, gidsetsize)))
d781 1
a781 1
		if (error = sys_getrlimit(p, &ga, retval))
d801 1
a801 1
		if (error = sys_getrlimit(p, &ga, retval))
d839 1
a839 1
	if (error = sys___sysctl(p, &sa, retval))
d883 1
d890 1
d901 1
d908 1
d967 3
a969 2
	if (error = copyin((caddr_t)SCARG(uap, timep),
			   &(SCARG(&sa, tv)->tv_sec), sizeof(long)))
d972 1
a972 1
	if (error = sys_settimeofday(p, &sa, retval))
d997 3
a999 2
		if (error = copyin((caddr_t)SCARG(uap, buf), (caddr_t)&ubuf,
				   sizeof(ubuf)))
d1023 1
a1023 1
	int error, cur_nice = p->p_nice;
d1029 1
a1029 1
	if (error = sys_setpriority(p, &sa, retval))
d1104 1
a1104 1
        if (error = suser(p->p_ucred, &p->p_acflag))
d1148 1
a1148 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d1204 1
d1210 1
d1231 1
a1231 1
	if (error = sys_ioctl(p, &sa, retval))
d1261 1
d1265 1
@


1.3
log
@from netbsd; Added support for sysi86 and eaccess syscalls
@
text
@d1 1
a1 1
/*	$NetBSD: ibcs2_misc.c,v 1.13 1996/01/06 03:23:49 scottb Exp $	*/
d1402 1
a1402 1
ibcs2_sysi86(p, v, retval)
d1407 1
a1407 1
	struct ibcs2_sysi86_args /* {
@


1.2
log
@ufs ==> ffs
@
text
@d1 1
a1 1
/*	$NetBSD: ibcs2_misc.c,v 1.11 1995/10/09 11:24:01 mycroft Exp $	*/
d104 1
d1399 39
@


1.1
log
@Initial revision
@
text
@d279 1
a279 1
		if (error = copyout("ufs", SCARG(uap, type), sizeof("ufs")))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
