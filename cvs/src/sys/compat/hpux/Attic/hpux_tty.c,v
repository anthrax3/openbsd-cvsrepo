head	1.13;
access;
symbols
	OPENBSD_4_7:1.12.0.20
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.22
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.18
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.16
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.14
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.12
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.10
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.8
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.22
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.20
	OPENBSD_2_8:1.4.0.18
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.16
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.14
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.12
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.10
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2010.06.29.20.30.32;	author guenther;	state dead;
branches;
next	1.12;

1.12
date	2004.09.19.21.58.41;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.10.22.37.33;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.09.21.33.45;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.28.00;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.13.19.08.06;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.02.16.05.58;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.26.12.03.27;	author art;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	97.04.16.09.18.17;	author downsj;	state Exp;
branches
	1.4.14.1;
next	1.3;

1.3
date	96.08.02.20.35.00;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.47.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.15;	author deraadt;	state Exp;
branches;
next	;

1.4.14.1
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.4.14.2;

1.4.14.2
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.4.14.3;

1.4.14.3
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.4.14.4;

1.4.14.4
date	2003.06.07.11.00.36;	author ho;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@/*	$OpenBSD: hpux_tty.c,v 1.12 2004/09/19 21:58:41 mickey Exp $	*/
/*	$NetBSD: hpux_tty.c,v 1.14 1997/04/01 19:59:05 scottr Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: hpux_tty.c 1.14 93/08/05$
 *
 *	@@(#)hpux_tty.c	8.3 (Berkeley) 1/12/94
 */

/*
 * stty/gtty/termio emulation stuff
 */

#ifndef COMPAT_43
#define COMPAT_43
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/conf.h>
#include <sys/buf.h>
#include <sys/kernel.h>

#include <compat/hpux/hpux.h>
#include <compat/hpux/hpux_termio.h>
#include <compat/hpux/hpux_syscallargs.h>

/*
 * Map BSD/POSIX style termios info to and from SYS5 style termio stuff.
 */
int
hpux_termio(fd, com, data, p)
	int fd, com;
	caddr_t data;
	struct proc *p;
{
	struct file *fp;
	struct termios tios;
	struct hpux_termios htios;
	int line, error;
	int newi = 0;
	int (*ioctlrout)(struct file *fp, u_long com,
	    caddr_t data, struct proc *p);

	if ((fp = fd_getfile(p->p_fd, fd)) == NULL)
		return (EBADF);
	FREF(fp);
	ioctlrout = fp->f_ops->fo_ioctl;
	switch (com) {
	case HPUXTCGETATTR:
		newi = 1;
		/* fall into ... */
	case HPUXTCGETA:
		/*
		 * Get BSD terminal state
		 */
		if ((error = (*ioctlrout)(fp, TIOCGETA, (caddr_t)&tios, p)))
			break;
		bzero((char *)&htios, sizeof htios);
		/*
		 * Set iflag.
		 * Same through ICRNL, no BSD equivs for IUCLC, IENQAK
		 */
		htios.c_iflag = tios.c_iflag & 0x1ff;
		if (tios.c_iflag & IXON)
			htios.c_iflag |= TIO_IXON;
		if (tios.c_iflag & IXOFF)
			htios.c_iflag |= TIO_IXOFF;
		if (tios.c_iflag & IXANY)
			htios.c_iflag |= TIO_IXANY;
		/*
		 * Set oflag.
		 * No BSD equivs for OLCUC/OCRNL/ONOCR/ONLRET/OFILL/OFDEL
		 * or any of the delays.
		 */
		if (tios.c_oflag & OPOST)
			htios.c_oflag |= TIO_OPOST;
		if (tios.c_oflag & ONLCR)
			htios.c_oflag |= TIO_ONLCR;
		if (tios.c_oflag & OXTABS)
			htios.c_oflag |= TIO_TAB3;
		/*
		 * Set cflag.
		 * Baud from ospeed, rest from cflag.
		 */
		htios.c_cflag = bsdtohpuxbaud(tios.c_ospeed);
		switch (tios.c_cflag & CSIZE) {
		case CS5:
			htios.c_cflag |= TIO_CS5; break;
		case CS6:
			htios.c_cflag |= TIO_CS6; break;
		case CS7:
			htios.c_cflag |= TIO_CS7; break;
		case CS8:
			htios.c_cflag |= TIO_CS8; break;
		}
		if (tios.c_cflag & CSTOPB)
			htios.c_cflag |= TIO_CSTOPB;
		if (tios.c_cflag & CREAD)
			htios.c_cflag |= TIO_CREAD;
		if (tios.c_cflag & PARENB)
			htios.c_cflag |= TIO_PARENB;
		if (tios.c_cflag & PARODD)
			htios.c_cflag |= TIO_PARODD;
		if (tios.c_cflag & HUPCL)
			htios.c_cflag |= TIO_HUPCL;
		if (tios.c_cflag & CLOCAL)
			htios.c_cflag |= TIO_CLOCAL;
		/*
		 * Set lflag.
		 * No BSD equiv for XCASE.
		 */
		if (tios.c_lflag & ECHOE)
			htios.c_lflag |= TIO_ECHOE;
		if (tios.c_lflag & ECHOK)
			htios.c_lflag |= TIO_ECHOK;
		if (tios.c_lflag & ECHO)
			htios.c_lflag |= TIO_ECHO;
		if (tios.c_lflag & ECHONL)
			htios.c_lflag |= TIO_ECHONL;
		if (tios.c_lflag & ISIG)
			htios.c_lflag |= TIO_ISIG;
		if (tios.c_lflag & ICANON)
			htios.c_lflag |= TIO_ICANON;
		if (tios.c_lflag & NOFLSH)
			htios.c_lflag |= TIO_NOFLSH;
		/*
		 * Line discipline
		 */
		if (!newi) {
			line = 0;
			(void) (*ioctlrout)(fp, TIOCGETD, (caddr_t)&line, p);
			htios.c_reserved = line;
		}
		/*
		 * Set editing chars.
		 * No BSD equiv for VSWTCH.
		 */
		htios.c_cc[HPUXVINTR] = tios.c_cc[VINTR];
		htios.c_cc[HPUXVQUIT] = tios.c_cc[VQUIT];
		htios.c_cc[HPUXVERASE] = tios.c_cc[VERASE];
		htios.c_cc[HPUXVKILL] = tios.c_cc[VKILL];
		htios.c_cc[HPUXVEOF] = tios.c_cc[VEOF];
		htios.c_cc[HPUXVEOL] = tios.c_cc[VEOL];
		htios.c_cc[HPUXVEOL2] = tios.c_cc[VEOL2];
		htios.c_cc[HPUXVSWTCH] = 0;
#if 1
		/*
		 * XXX since VMIN and VTIME are not implemented,
		 * we need to return something reasonable.
		 * Otherwise a GETA/SETA combo would always put
		 * the tty in non-blocking mode (since VMIN == VTIME == 0).
		 */
		if (fp->f_flag & FNONBLOCK) {
			htios.c_cc[HPUXVMINS] = 0;
			htios.c_cc[HPUXVTIMES] = 0;
		} else {
			htios.c_cc[HPUXVMINS] = 6;
			htios.c_cc[HPUXVTIMES] = 1;
		}
#else
		htios.c_cc[HPUXVMINS] = tios.c_cc[VMIN];
		htios.c_cc[HPUXVTIMES] = tios.c_cc[VTIME];
#endif
		htios.c_cc[HPUXVSUSP] = tios.c_cc[VSUSP];
		htios.c_cc[HPUXVSTART] = tios.c_cc[VSTART];
		htios.c_cc[HPUXVSTOP] = tios.c_cc[VSTOP];
		if (newi)
			bcopy((char *)&htios, data, sizeof htios);
		else
			termiostotermio(&htios, (struct hpux_termio *)data);
		break;

	case HPUXTCSETATTR:
	case HPUXTCSETATTRD:
	case HPUXTCSETATTRF:
		newi = 1;
		/* fall into ... */
	case HPUXTCSETA:
	case HPUXTCSETAW:
	case HPUXTCSETAF:
		/*
		 * Get old characteristics and determine if we are a tty.
		 */
		if ((error = (*ioctlrout)(fp, TIOCGETA, (caddr_t)&tios, p)))
			break;
		if (newi)
			bcopy(data, (char *)&htios, sizeof htios);
		else
			termiototermios((struct hpux_termio *)data,
			    &htios, &tios);
		/*
		 * Set iflag.
		 * Same through ICRNL, no HP-UX equiv for IMAXBEL
		 */
		tios.c_iflag &= ~(IXON|IXOFF|IXANY|0x1ff);
		tios.c_iflag |= htios.c_iflag & 0x1ff;
		if (htios.c_iflag & TIO_IXON)
			tios.c_iflag |= IXON;
		if (htios.c_iflag & TIO_IXOFF)
			tios.c_iflag |= IXOFF;
		if (htios.c_iflag & TIO_IXANY)
			tios.c_iflag |= IXANY;
		/*
		 * Set oflag.
		 * No HP-UX equiv for ONOEOT
		 */
		tios.c_oflag &= ~(OPOST|ONLCR|OXTABS);
		if (htios.c_oflag & TIO_OPOST)
			tios.c_oflag |= OPOST;
		if (htios.c_oflag & TIO_ONLCR)
			tios.c_oflag |= ONLCR;
		if (htios.c_oflag & TIO_TAB3)
			tios.c_oflag |= OXTABS;
		/*
		 * Set cflag.
		 * No HP-UX equiv for CCTS_OFLOW/CCTS_IFLOW/MDMBUF
		 */
		tios.c_cflag &=
			~(CSIZE|CSTOPB|CREAD|PARENB|PARODD|HUPCL|CLOCAL);
		switch (htios.c_cflag & TIO_CSIZE) {
		case TIO_CS5:
			tios.c_cflag |= CS5; break;
		case TIO_CS6:
			tios.c_cflag |= CS6; break;
		case TIO_CS7:
			tios.c_cflag |= CS7; break;
		case TIO_CS8:
			tios.c_cflag |= CS8; break;
		}
		if (htios.c_cflag & TIO_CSTOPB)
			tios.c_cflag |= CSTOPB;
		if (htios.c_cflag & TIO_CREAD)
			tios.c_cflag |= CREAD;
		if (htios.c_cflag & TIO_PARENB)
			tios.c_cflag |= PARENB;
		if (htios.c_cflag & TIO_PARODD)
			tios.c_cflag |= PARODD;
		if (htios.c_cflag & TIO_HUPCL)
			tios.c_cflag |= HUPCL;
		if (htios.c_cflag & TIO_CLOCAL)
			tios.c_cflag |= CLOCAL;
		/*
		 * Set lflag.
		 * No HP-UX equiv for ECHOKE/ECHOPRT/ECHOCTL
		 * IEXTEN treated as part of ICANON
		 */
		tios.c_lflag &= ~(ECHOE|ECHOK|ECHO|ISIG|ICANON|IEXTEN|NOFLSH);
		if (htios.c_lflag & TIO_ECHOE)
			tios.c_lflag |= ECHOE;
		if (htios.c_lflag & TIO_ECHOK)
			tios.c_lflag |= ECHOK;
		if (htios.c_lflag & TIO_ECHO)
			tios.c_lflag |= ECHO;
		if (htios.c_lflag & TIO_ECHONL)
			tios.c_lflag |= ECHONL;
		if (htios.c_lflag & TIO_ISIG)
			tios.c_lflag |= ISIG;
		if (htios.c_lflag & TIO_ICANON)
			tios.c_lflag |= (ICANON|IEXTEN);
		if (htios.c_lflag & TIO_NOFLSH)
			tios.c_lflag |= NOFLSH;
		/*
		 * Set editing chars.
		 * No HP-UX equivs of VWERASE/VREPRINT/VDSUSP/VLNEXT
		 * /VDISCARD/VSTATUS/VERASE2
		 */
		tios.c_cc[VINTR] = htios.c_cc[HPUXVINTR];
		tios.c_cc[VQUIT] = htios.c_cc[HPUXVQUIT];
		tios.c_cc[VERASE] = htios.c_cc[HPUXVERASE];
		tios.c_cc[VKILL] = htios.c_cc[HPUXVKILL];
		tios.c_cc[VEOF] = htios.c_cc[HPUXVEOF];
		tios.c_cc[VEOL] = htios.c_cc[HPUXVEOL];
		tios.c_cc[VEOL2] = htios.c_cc[HPUXVEOL2];
		tios.c_cc[VMIN] = htios.c_cc[HPUXVMINS];
		tios.c_cc[VTIME] = htios.c_cc[HPUXVTIMES];
		tios.c_cc[VSUSP] = htios.c_cc[HPUXVSUSP];
		tios.c_cc[VSTART] = htios.c_cc[HPUXVSTART];
		tios.c_cc[VSTOP] = htios.c_cc[HPUXVSTOP];

		/*
		 * Set the new stuff
		 */
		if (com == HPUXTCSETA || com == HPUXTCSETATTR)
			com = TIOCSETA;
		else if (com == HPUXTCSETAW || com == HPUXTCSETATTRD)
			com = TIOCSETAW;
		else
			com = TIOCSETAF;
		error = (*ioctlrout)(fp, com, (caddr_t)&tios, p);
		if (error == 0) {
			/*
			 * Set line discipline
			 */
			if (!newi) {
				line = htios.c_reserved;
				(void) (*ioctlrout)(fp, TIOCSETD,
						    (caddr_t)&line, p);
			}
			/*
			 * Set non-blocking IO if VMIN == VTIME == 0, clear
			 * if not.  Should handle the other cases as well.
			 * Note it isn't correct to just turn NBIO off like
			 * we do as it could be on as the result of a fcntl
			 * operation.
			 *
			 * XXX - wouldn't need to do this at all if VMIN/VTIME
			 * were implemented.
			 */
			{
				struct hpux_sys_fcntl_args {
					int fdes, cmd, arg;
				} args;
				int flags, nbio;

				nbio = (htios.c_cc[HPUXVMINS] == 0 &&
					htios.c_cc[HPUXVTIMES] == 0);
				if ((nbio && (fp->f_flag & FNONBLOCK) == 0) ||
				    (!nbio && (fp->f_flag & FNONBLOCK))) {
					args.fdes = fd;
					args.cmd = F_GETFL;
					args.arg = 0;
					(void) hpux_sys_fcntl(p, &args, &flags);
					if (nbio)
						flags |= HPUXNDELAY;
					else
						flags &= ~HPUXNDELAY;
					args.cmd = F_SETFL;
					args.arg = flags;
					(void) hpux_sys_fcntl(p, &args, &flags);
				}
			}
		}
		break;

	default:
		error = EINVAL;
		break;
	}
	FRELE(fp);
	return(error);
}

void
termiototermios(tio, tios, bsdtios)
	struct hpux_termio *tio;
	struct hpux_termios *tios;
	struct termios *bsdtios;
{
	int i;

	bzero((char *)tios, sizeof *tios);
	tios->c_iflag = tio->c_iflag;
	tios->c_oflag = tio->c_oflag;
	tios->c_cflag = tio->c_cflag;
	tios->c_lflag = tio->c_lflag;
	tios->c_reserved = tio->c_line;
	for (i = 0; i <= HPUXVSWTCH; i++)
		tios->c_cc[i] = tio->c_cc[i];
	if (tios->c_lflag & TIO_ICANON) {
		tios->c_cc[HPUXVEOF] = tio->c_cc[HPUXVEOF];
		tios->c_cc[HPUXVEOL] = tio->c_cc[HPUXVEOL];
		tios->c_cc[HPUXVMINS] = 0;
		tios->c_cc[HPUXVTIMES] = 0;
	} else {
		tios->c_cc[HPUXVEOF] = 0;
		tios->c_cc[HPUXVEOL] = 0;
		tios->c_cc[HPUXVMINS] = tio->c_cc[HPUXVMIN];
		tios->c_cc[HPUXVTIMES] = tio->c_cc[HPUXVTIME];
	}
	tios->c_cc[HPUXVSUSP] = bsdtios->c_cc[VSUSP];
	tios->c_cc[HPUXVSTART] = bsdtios->c_cc[VSTART];
	tios->c_cc[HPUXVSTOP] = bsdtios->c_cc[VSTOP];
}

void
termiostotermio(tios, tio)
	struct hpux_termios *tios;
	struct hpux_termio *tio;
{
	int i;

	tio->c_iflag = tios->c_iflag;
	tio->c_oflag = tios->c_oflag;
	tio->c_cflag = tios->c_cflag;
	tio->c_lflag = tios->c_lflag;
	tio->c_line = tios->c_reserved;
	for (i = 0; i <= HPUXVSWTCH; i++)
		tio->c_cc[i] = tios->c_cc[i];
	if (tios->c_lflag & TIO_ICANON) {
		tio->c_cc[HPUXVEOF] = tios->c_cc[HPUXVEOF];
		tio->c_cc[HPUXVEOL] = tios->c_cc[HPUXVEOL];
	} else {
		tio->c_cc[HPUXVMIN] = tios->c_cc[HPUXVMINS];
		tio->c_cc[HPUXVTIME] = tios->c_cc[HPUXVTIMES];
	}
}

int
bsdtohpuxbaud(bsdspeed)
	long bsdspeed;
{
	switch (bsdspeed) {
	case B0:     return(TIO_B0);
	case B50:    return(TIO_B50);
	case B75:    return(TIO_B75);
	case B110:   return(TIO_B110);
	case B134:   return(TIO_B134);
	case B150:   return(TIO_B150);
	case B200:   return(TIO_B200);
	case B300:   return(TIO_B300);
	case B600:   return(TIO_B600);
	case B1200:  return(TIO_B1200);
	case B1800:  return(TIO_B1800);
	case B2400:  return(TIO_B2400);
	case B4800:  return(TIO_B4800);
	case B9600:  return(TIO_B9600);
	case B19200: return(TIO_B19200);
	case B38400: return(TIO_B38400);
	default:     return(TIO_B0);
	}
}

int
hpuxtobsdbaud(hpux_speed)
	int hpux_speed;
{
	static const int hpuxtobsdbaudtab[32] = {
		B0,	B50,	B75,	B110,	B134,	B150,	B200,	B300,
		B600,	B0,	B1200,	B1800,	B2400,	B0,	B4800,	B0,
		B9600,	B19200,	B38400,	B0,	B0,	B0,	B0,	B0,
		B0,	B0,	B0,	B0,	B0,	B0,	EXTA,	EXTB
	};

	return(hpuxtobsdbaudtab[hpux_speed & TIO_CBAUD]);
}

int
hpux_sys_stty_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_stty_6x_args /* {
		syscallarg(int) fd;
		syscallarg(caddr_t) arg;
	} */ *uap = v;

	return (getsettty(p, SCARG(uap, fd), HPUXTIOCGETP, SCARG(uap, arg)));
}

int
hpux_sys_gtty_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_gtty_6x_args /* {
		syscallarg(int) fd;
		syscallarg(caddr_t) arg;
	} */ *uap = v;

	return (getsettty(p, SCARG(uap, fd), HPUXTIOCSETP, SCARG(uap, arg)));
}

/*
 * Simplified version of ioctl() for use by
 * gtty/stty and TIOCGETP/TIOCSETP.
 */
int
getsettty(p, fdes, com, cmarg)
	struct proc *p;
	int fdes, com;
	caddr_t cmarg;
{
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct hpux_sgttyb hsb;
	struct sgttyb sb;
	int error;

	if ((fp = fd_getfile(fdp, fdes)) == NULL)
		return (EBADF);
	if ((fp->f_flag & (FREAD|FWRITE)) == 0)
		return (EBADF);
	FREF(fp);
	if (com == HPUXTIOCSETP) {
		if ((error = copyin(cmarg, (caddr_t)&hsb, sizeof hsb)))
			goto bad;
		sb.sg_ispeed = hsb.sg_ispeed;
		sb.sg_ospeed = hsb.sg_ospeed;
		sb.sg_erase = hsb.sg_erase;
		sb.sg_kill = hsb.sg_kill;
		sb.sg_flags = hsb.sg_flags & ~(V7_HUPCL|V7_XTABS|V7_NOAL);
		if (hsb.sg_flags & V7_XTABS)
			sb.sg_flags |= XTABS;
		if (hsb.sg_flags & V7_HUPCL)
			(void)(*fp->f_ops->fo_ioctl)
				(fp, TIOCHPCL, (caddr_t)0, p);
		com = TIOCSETP;
	} else {
		bzero((caddr_t)&hsb, sizeof hsb);
		com = TIOCGETP;
	}
	error = (*fp->f_ops->fo_ioctl)(fp, com, (caddr_t)&sb, p);
	if (error == 0 && com == TIOCGETP) {
		hsb.sg_ispeed = sb.sg_ispeed;
		hsb.sg_ospeed = sb.sg_ospeed;
		hsb.sg_erase = sb.sg_erase;
		hsb.sg_kill = sb.sg_kill;
		hsb.sg_flags = sb.sg_flags & ~(V7_HUPCL|V7_XTABS|V7_NOAL);
		if (sb.sg_flags & XTABS)
			hsb.sg_flags |= V7_XTABS;
		error = copyout((caddr_t)&hsb, cmarg, sizeof hsb);
	}
bad:
	FRELE(fp);
	return (error);
}
@


1.12
log
@const this speedtab too
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_tty.c,v 1.11 2004/07/10 22:37:33 mickey Exp $	*/
@


1.11
log
@enable stty/gtty on hppa as well
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_tty.c,v 1.10 2004/07/09 21:33:45 mickey Exp $	*/
d465 1
a465 1
	static int hpuxtobsdbaudtab[32] = {
@


1.10
log
@split off the m68k-specific parts
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_tty.c,v 1.9 2003/06/02 23:28:00 millert Exp $	*/
a474 1
#ifndef __hppa__
a501 1
#endif
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_tty.c,v 1.8 2002/03/14 01:26:49 millert Exp $	*/
d475 1
d503 1
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_tty.c,v 1.7 2002/02/13 19:08:06 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@More FREF/FRELE on relevant places. Now, only sys_mmap and a bunch of ioctl functions in sys/compat are left.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_tty.c,v 1.6 2002/02/02 16:05:58 art Exp $	*/
d83 2
a84 2
	int (*ioctlrout) __P((struct file *fp, u_long com,
	    caddr_t data, struct proc *p));
@


1.6
log
@Be more consistent about using fd_getfile where it matters.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_tty.c,v 1.5 2001/10/26 12:03:27 art Exp $	*/
d88 1
d381 1
d527 1
d530 1
a530 1
			return (error);
d557 2
@


1.5
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_tty.c,v 1.4 1997/04/16 09:18:17 downsj Exp $	*/
d86 2
a87 2

	fp = p->p_fd->fd_ofiles[fd];
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_tty.c,v 1.5 2001/10/26 12:03:27 art Exp $	*/
d83 2
a84 2
	int (*ioctlrout)(struct file *fp, u_long com,
	    caddr_t data, struct proc *p);
d86 2
a87 3
	if ((fp = fd_getfile(p->p_fd, fd)) == NULL)
		return (EBADF);
	FREF(fp);
a379 1
	FRELE(fp);
a524 1
	FREF(fp);
d527 1
a527 1
			goto bad;
a553 2
bad:
	FRELE(fp);
@


1.4
log
@Changes up to NetBSD 970415.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_tty.c,v 1.3 1996/08/02 20:35:00 niklas Exp $	*/
d521 1
a521 2
	if (((unsigned)fdes) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fdes]) == NULL)
@


1.4.14.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_tty.c,v 1.4 1997/04/16 09:18:17 downsj Exp $	*/
d521 2
a522 1
	if ((fp = fd_getfile(fdp, fdes)) == NULL)
@


1.4.14.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 2
a87 3
	if ((fp = fd_getfile(p->p_fd, fd)) == NULL)
		return (EBADF);
	FREF(fp);
a379 1
	FRELE(fp);
a524 1
	FREF(fp);
d527 1
a527 1
			goto bad;
a553 2
bad:
	FRELE(fp);
@


1.4.14.3
log
@Merge in -current from about a week ago
@
text
@d83 2
a84 2
	int (*ioctlrout)(struct file *fp, u_long com,
	    caddr_t data, struct proc *p);
@


1.4.14.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_tty.c,v 1.4.14.3 2002/03/28 11:28:06 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3
log
@Added Makefiles to build stuff from syscalls.master in some emulations.
Regenerated derived files from various syscalls.master files. Added $OpenBSD$.
@
text
@d1 2
a2 2
/*	$OpenBSD: hpux_tty.c,v 1.13 1995/12/11 16:32:46 thorpej Exp $	*/
/*	$NetBSD: hpux_tty.c,v 1.13 1995/12/11 16:32:46 thorpej Exp $	*/
d81 1
a81 1
	int line, error, (*ioctlrout)();
d83 3
d97 1
a97 1
		if (error = (*ioctlrout)(fp, TIOCGETA, (caddr_t)&tios, p))
d225 1
a225 1
		if (error = (*ioctlrout)(fp, TIOCGETA, (caddr_t)&tios, p))
d230 2
a231 1
			termiototermios((struct termio *)data, &htios, &tios);
d358 2
a359 2
				if (nbio && (fp->f_flag & FNONBLOCK) == 0 ||
				    !nbio && (fp->f_flag & FNONBLOCK)) {
d383 1
a383 1
int
d415 1
a415 1
int
d515 2
a516 2
	register struct filedesc *fdp = p->p_fd;
	register struct file *fp;
d527 1
a527 1
		if (error = copyin(cmarg, (caddr_t)&hsb, sizeof hsb))
@


1.2
log
@update from netbsd
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: hpux_tty.c,v 1.11 1995/10/07 06:26:40 mycroft Exp $	*/
d462 1
a462 1
	static char hpuxtobsdbaudtab[32] = {
a471 2
#ifdef COMPAT_HPUX_6X

d473 1
a473 1
compat_hpux_6x_sys_gtty(p, v, retval)
d478 4
a481 1
	struct compat_hpux_6x_sys_gtty_args *uap = v;
d487 1
a487 1
compat_hpux_6x_sys_stty(p, v, retval)
d492 4
a495 1
	struct compat_hpux_6x_sys_stty_args *uap = v;
a551 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
