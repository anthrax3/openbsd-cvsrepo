head	1.11;
access;
symbols
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.14
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2004.07.09.21.33.44;	author mickey;	state dead;
branches;
next	1.10;

1.10
date	2003.06.02.23.28.00;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.08.23.22.21.43;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.12.13.05.31;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.26.06.25.10;	author deraadt;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.05.16.12.50.20;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.10.18.15.44;	author art;	state Exp;
branches;
next	1.3;

1.3
date	97.04.16.09.18.07;	author downsj;	state Exp;
branches
	1.3.14.1;
next	1.2;

1.2
date	96.08.02.20.34.56;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.14;	author deraadt;	state Exp;
branches;
next	;

1.3.14.1
date	2001.05.14.22.04.30;	author niklas;	state Exp;
branches;
next	1.3.14.2;

1.3.14.2
date	2001.07.04.10.39.17;	author niklas;	state Exp;
branches;
next	1.3.14.3;

1.3.14.3
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.3.14.4;

1.3.14.4
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.3.14.5;

1.3.14.5
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.3.14.6;

1.3.14.6
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	1.3.14.7;

1.3.14.7
date	2003.06.07.11.00.36;	author ho;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.10.29.00.30.51;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@split off the m68k-specific parts
@
text
@/*	$OpenBSD: hpux_net.c,v 1.10 2003/06/02 23:28:00 millert Exp $	*/
/*	$NetBSD: hpux_net.c,v 1.14 1997/04/01 19:59:02 scottr Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: hpux_net.c 1.8 93/08/02$
 *
 *	@@(#)hpux_net.c	8.2 (Berkeley) 9/9/93
 */

/*
 * Network related HP-UX compatibility routines
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/time.h>
#include <sys/errno.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/mbuf.h>
#include <sys/mount.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/uio.h>
#include <sys/ktrace.h>
#include <sys/syscallargs.h>

#include <compat/hpux/hpux.h>
#include <compat/hpux/hpux_syscallargs.h>
#include <compat/hpux/hpux_util.h>

struct hpux_sys_setsockopt_args {
	syscallarg(int) s;
	syscallarg(int) level;
	syscallarg(int) name;
	syscallarg(caddr_t) val;
	syscallarg(int) valsize;
};

struct hpux_sys_getsockopt_args {
	syscallarg(int) s;
	syscallarg(int) level;
	syscallarg(int) name;
	syscallarg(caddr_t) val;
	syscallarg(int *) avalsize;
};

int	hpux_sys_setsockopt(struct proc *, void *, register_t *);
int	hpux_sys_getsockopt(struct proc *, void *, register_t *);

void	socksetsize(int, struct mbuf *);


#define MINBSDIPCCODE	0x3EE
#define NUMBSDIPC	32

/*
 * HPUX netioctl() to BSD syscall map.
 * Indexed by callno - MINBSDIPCCODE
 */

struct hpuxtobsdipc {
	int (*rout)(struct proc *, void *, register_t *);
	int nargs;
} hpuxtobsdipc[NUMBSDIPC] = {
	{ sys_socket,			3 }, /* 3ee */
	{ sys_listen,			2 }, /* 3ef */
	{ sys_bind,			3 }, /* 3f0 */
	{ compat_43_sys_accept,		3 }, /* 3f1 */
	{ sys_connect,			3 }, /* 3f2 */
	{ compat_43_sys_recv,		4 }, /* 3f3 */
	{ compat_43_sys_send,		4 }, /* 3f4 */
	{ sys_shutdown,			2 }, /* 3f5 */
	{ compat_43_sys_getsockname,	3 }, /* 3f6 */
	{ hpux_sys_setsockopt,		5 }, /* 3f7 */
	{ sys_sendto,			6 }, /* 3f8 */
	{ compat_43_sys_recvfrom,	6 }, /* 3f9 */
	{ compat_43_sys_getpeername,	3 }, /* 3fa */
	{ NULL,				0 }, /* 3fb */
	{ NULL,				0 }, /* 3fc */
	{ NULL,				0 }, /* 3fd */
	{ NULL,				0 }, /* 3fe */
	{ NULL,				0 }, /* 3ff */
	{ NULL,				0 }, /* 400 */
	{ NULL,				0 }, /* 401 */
	{ NULL,				0 }, /* 402 */
	{ NULL,				0 }, /* 403 */
	{ NULL,				0 }, /* 404 */
	{ NULL,				0 }, /* 405 */
	{ NULL,				0 }, /* 406 */
	{ NULL,				0 }, /* 407 */
	{ NULL,				0 }, /* 408 */
	{ NULL,				0 }, /* 409 */
	{ NULL,				0 }, /* 40a */
	{ hpux_sys_getsockopt,		5 }, /* 40b */
	{ NULL,				0 }, /* 40c */
	{ NULL,				0 }, /* 40d */
};

/*
 * Single system call entry to BSD style IPC.
 * Gleened from disassembled libbsdipc.a syscall entries.
 */
int
hpux_sys_netioctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_netioctl_args *uap = v;
	int *args, i;
	int code;
	int error;

	args = SCARG(uap, args);
	code = SCARG(uap, call) - MINBSDIPCCODE;
	if (code < 0 || code >= NUMBSDIPC || hpuxtobsdipc[code].rout == NULL)
		return (EINVAL);
	if ((i = hpuxtobsdipc[code].nargs * sizeof (int)) &&
	    (error = copyin((caddr_t)args, (caddr_t)uap, (u_int)i))) {
#ifdef KTRACE
                if (KTRPOINT(p, KTR_SYSCALL))
                        ktrsyscall(p, code + MINBSDIPCCODE,
				   hpuxtobsdipc[code].nargs,
				   (register_t *)uap);
#endif
		return (error);
	}
#ifdef KTRACE
        if (KTRPOINT(p, KTR_SYSCALL))
                ktrsyscall(p, code + MINBSDIPCCODE,
			   hpuxtobsdipc[code].nargs,
			   (register_t *)uap);
#endif
	return ((*hpuxtobsdipc[code].rout)(p, uap, retval));
}

void
socksetsize(size, m)
	int size;
	struct mbuf *m;
{
	int tmp;

	if (size < sizeof(int)) {
		switch(size) {
	    	case 1:
			tmp = (int) *mtod(m, char *);
			break;
	    	case 2:
			tmp = (int) *mtod(m, short *);
			break;
	    	case 3:
		default:	/* XXX uh, what if sizeof(int) > 4? */
			tmp = (((int) *mtod(m, int *)) >> 8) & 0xffffff;
			break;
		}
		*mtod(m, int *) = tmp;
		m->m_len = sizeof(int);
	} else {
		m->m_len = size;
	}
}

/* ARGSUSED */
int
hpux_sys_setsockopt(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_setsockopt_args *uap = v;
	struct file *fp;
	struct mbuf *m = NULL;
	int tmp, error;

	if ((error = getsock(p->p_fd, SCARG(uap, s), &fp)))
		return (error);
	if (SCARG(uap, valsize) > MLEN) {
		error = EINVAL;
		goto bad;
	}
	if (SCARG(uap, val)) {
		m = m_get(M_WAIT, MT_SOOPTS);
		if ((error = copyin(SCARG(uap, val), mtod(m, caddr_t),
		    (u_int)SCARG(uap, valsize)))) {
			(void) m_free(m);
			goto bad;
		}
		if (SCARG(uap, name) == SO_LINGER) {
			tmp = *mtod(m, int *);
			mtod(m, struct linger *)->l_onoff = 1;
			mtod(m, struct linger *)->l_linger = tmp;
			m->m_len = sizeof(struct linger);
		} else
			socksetsize(SCARG(uap, valsize), m);
	} else if (SCARG(uap, name) == ~SO_LINGER) {
		m = m_get(M_WAIT, MT_SOOPTS);
		SCARG(uap, name) = SO_LINGER;
		mtod(m, struct linger *)->l_onoff = 0;
		m->m_len = sizeof(struct linger);
	}
	error = sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), m);
bad:
	FRELE(fp);
	return (error);
}

/* ARGSUSED */
int
hpux_sys_setsockopt2(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_setsockopt2_args *uap = v;
	struct file *fp;
	struct mbuf *m = NULL;
	int error;

	if ((error = getsock(p->p_fd, SCARG(uap, s), &fp)))
		return (error);
	if (SCARG(uap, valsize) > MLEN) {
		error = EINVAL;
		goto bad;
	}
	if (SCARG(uap, val)) {
		m = m_get(M_WAIT, MT_SOOPTS);
		if ((error = copyin(SCARG(uap, val), mtod(m, caddr_t),
		    (u_int)SCARG(uap, valsize)))) {
			m_free(m);
			goto bad;
		}
		socksetsize(SCARG(uap, valsize), m);
	}
	error = sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), m);
bad:
	FRELE(fp);
	return (error);
}

int
hpux_sys_getsockopt(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_getsockopt_args *uap = v;
	struct file *fp;
	struct mbuf *m = NULL;
	int valsize, error;

	if ((error = getsock(p->p_fd, SCARG(uap, s), &fp)))
		return (error);
	if (SCARG(uap, val)) {
		if ((error = copyin((caddr_t)SCARG(uap, avalsize),
		    (caddr_t)&valsize, sizeof (valsize)))) {
			goto bad;
		}
	} else
		valsize = 0;
	if ((error = sogetopt((struct socket *)fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), &m)))
		goto bad;
	if (SCARG(uap, val) && valsize && m != NULL) {
		if (SCARG(uap, name) == SO_LINGER) {
			if (mtod(m, struct linger *)->l_onoff)
				*mtod(m, int *) = mtod(m, struct linger *)->l_linger;
			else
				*mtod(m, int *) = 0;
			m->m_len = sizeof(int);
		}
		if (valsize > m->m_len)
			valsize = m->m_len;
		error = copyout(mtod(m, caddr_t), SCARG(uap, val),
		    (u_int)valsize);
		if (error == 0)
			error = copyout((caddr_t)&valsize,
			    (caddr_t)SCARG(uap, avalsize), sizeof (valsize));
	}
bad:
	FRELE(fp);
	if (m != NULL)
		m_free(m);
	return (error);
}
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.9 2002/08/23 22:21:43 art Exp $	*/
@


1.9
log
@Just like getvnode, make getsock FREF the file so that we can't get away
with not refing it.

Eyeballed by lurene@@daemonkitty.net, fries@@, nordin@@ and fries@@
Some additional cleanups by nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.8 2002/03/14 01:26:49 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.7 2002/02/12 13:05:31 art Exp $	*/
d217 4
a220 3
	if (SCARG(uap, valsize) > MLEN)
		return (EINVAL);
	FREF(fp);
a224 1
			FRELE(fp);
d226 1
a226 1
			return (error);
d243 1
d262 4
a265 3
	if (SCARG(uap, valsize) > MLEN)
		return (EINVAL);
	FREF(fp);
d270 2
a271 3
			FRELE(fp);
			(void) m_free(m);
			return (error);
d277 1
a294 1
	FREF(fp);
d298 1
a298 2
			FRELE(fp);
			return (error);
d324 1
a324 1
		(void) m_free(m);
@


1.7
log
@Fix all users of getsock to use FREF/FRELE properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.6 2001/08/26 06:25:10 deraadt Exp $	*/
d86 2
a87 2
int	hpux_sys_setsockopt	__P((struct proc *, void *, register_t *));
int	hpux_sys_getsockopt	__P((struct proc *, void *, register_t *));
d89 1
a89 1
void	socksetsize __P((int, struct mbuf *));
d101 1
a101 1
	int (*rout) __P((struct proc *, void *, register_t *));
@


1.6
log
@remove duplicate syscallargs() macros
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.5 2001/05/16 12:50:20 ho Exp $	*/
d219 1
d224 1
d241 4
a244 2
	return (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), m));
d263 1
d268 1
d274 4
a277 2
	return (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), m));
d293 1
d296 2
a297 1
		    (caddr_t)&valsize, sizeof (valsize))))
d299 1
d322 1
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.6 2001/08/26 06:25:10 deraadt Exp $	*/
d86 2
a87 2
int	hpux_sys_setsockopt(struct proc *, void *, register_t *);
int	hpux_sys_getsockopt(struct proc *, void *, register_t *);
d89 1
a89 1
void	socksetsize(int, struct mbuf *);
d101 1
a101 1
	int (*rout)(struct proc *, void *, register_t *);
a218 1
	FREF(fp);
a222 1
			FRELE(fp);
d239 2
a240 4
	error = sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), m);
	FRELE(fp);
	return (error);
a258 1
	FREF(fp);
a262 1
			FRELE(fp);
d268 2
a269 4
	error = sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), m);
	FRELE(fp);
	return (error);
a284 1
	FREF(fp);
d287 1
a287 2
		    (caddr_t)&valsize, sizeof (valsize)))) {
			FRELE(fp);
a288 1
		}
a310 1
	FRELE(fp);
@


1.6.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.6.4.1 2002/06/11 03:28:08 art Exp $	*/
d217 3
a219 4
	if (SCARG(uap, valsize) > MLEN) {
		error = EINVAL;
		goto bad;
	}
d224 1
d226 1
a226 1
			goto bad;
a242 1
bad:
d261 3
a263 4
	if (SCARG(uap, valsize) > MLEN) {
		error = EINVAL;
		goto bad;
	}
d268 3
a270 2
			m_free(m);
			goto bad;
a275 1
bad:
d293 1
d297 2
a298 1
			goto bad;
d324 1
a324 1
		m_free(m);
@


1.5
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.4 2000/11/10 18:15:44 art Exp $	*/
a68 3


#define syscallarg(x)   union { x datum; register_t pad; }
@


1.4
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.3 1997/04/16 09:18:07 downsj Exp $	*/
a223 2
		if (m == NULL)
			return (ENOBUFS);
d238 3
a240 5
		if (m) {
			SCARG(uap, name) = SO_LINGER;
			mtod(m, struct linger *)->l_onoff = 0;
			m->m_len = sizeof(struct linger);
		}
a263 2
		if (m == NULL)
			return (ENOBUFS);
@


1.3
log
@Changes up to NetBSD 970415.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.2 1996/08/02 20:34:56 niklas Exp $	*/
d164 1
a164 1
                        ktrsyscall(p->p_tracep, code + MINBSDIPCCODE,
d172 1
a172 1
                ktrsyscall(p->p_tracep, code + MINBSDIPCCODE,
@


1.3.14.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.4 2000/11/10 18:15:44 art Exp $	*/
d164 1
a164 1
                        ktrsyscall(p, code + MINBSDIPCCODE,
d172 1
a172 1
                ktrsyscall(p, code + MINBSDIPCCODE,
@


1.3.14.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.3.14.1 2001/05/14 22:04:30 niklas Exp $	*/
d224 2
d240 5
a244 3
		SCARG(uap, name) = SO_LINGER;
		mtod(m, struct linger *)->l_onoff = 0;
		m->m_len = sizeof(struct linger);
d268 2
@


1.3.14.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.3.14.2 2001/07/04 10:39:17 niklas Exp $	*/
d69 3
@


1.3.14.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a218 1
	FREF(fp);
a222 1
			FRELE(fp);
d239 2
a240 4
	error = sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), m);
	FRELE(fp);
	return (error);
a258 1
	FREF(fp);
a262 1
			FRELE(fp);
d268 2
a269 4
	error = sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), m);
	FRELE(fp);
	return (error);
a284 1
	FREF(fp);
d287 1
a287 2
		    (caddr_t)&valsize, sizeof (valsize)))) {
			FRELE(fp);
a288 1
		}
a310 1
	FRELE(fp);
@


1.3.14.5
log
@Merge in -current from about a week ago
@
text
@d86 2
a87 2
int	hpux_sys_setsockopt(struct proc *, void *, register_t *);
int	hpux_sys_getsockopt(struct proc *, void *, register_t *);
d89 1
a89 1
void	socksetsize(int, struct mbuf *);
d101 1
a101 1
	int (*rout)(struct proc *, void *, register_t *);
@


1.3.14.6
log
@Sync the SMP branch with 3.3
@
text
@d217 3
a219 4
	if (SCARG(uap, valsize) > MLEN) {
		error = EINVAL;
		goto bad;
	}
d224 1
d226 1
a226 1
			goto bad;
a242 1
bad:
d261 3
a263 4
	if (SCARG(uap, valsize) > MLEN) {
		error = EINVAL;
		goto bad;
	}
d268 3
a270 2
			m_free(m);
			goto bad;
a275 1
bad:
d293 1
d297 2
a298 1
			goto bad;
d324 1
a324 1
		m_free(m);
@


1.3.14.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_net.c,v 1.3.14.6 2003/03/27 23:53:47 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2
log
@Added Makefiles to build stuff from syscalls.master in some emulations.
Regenerated derived files from various syscalls.master files. Added $OpenBSD$.
@
text
@d1 2
a2 2
/*	$OpenBSD: hpux_net.c,v 1.12 1995/10/07 06:26:37 mycroft Exp $	*/
/*	$NetBSD: hpux_net.c,v 1.12 1995/10/07 06:26:37 mycroft Exp $	*/
d57 1
d92 2
d104 1
a104 1
	int (*rout)();
d153 1
a153 1
	register int code;
d179 1
a179 1
int
d184 1
a184 1
	register int tmp;
d195 1
d207 1
d218 1
a218 1
	if (error = getsock(p->p_fd, SCARG(uap, s), &fp))
d226 2
a227 2
		if (error = copyin(SCARG(uap, val), mtod(m, caddr_t),
		    (u_int)SCARG(uap, valsize))) {
d257 1
a257 1
	register struct hpux_sys_setsockopt2_args *uap = v;
d262 1
a262 1
	if (error = getsock(p->p_fd, SCARG(uap, s), &fp))
d270 2
a271 2
		if (error = copyin(SCARG(uap, val), mtod(m, caddr_t),
		    (u_int)SCARG(uap, valsize))) {
d292 1
a292 1
	if (error = getsock(p->p_fd, SCARG(uap, s), &fp))
d295 2
a296 2
		if (error = copyin((caddr_t)SCARG(uap, avalsize),
		    (caddr_t)&valsize, sizeof (valsize)))
d300 2
a301 2
	if (error = sogetopt((struct socket *)fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), &m))
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
