head	1.21;
access;
symbols
	OPENBSD_4_7:1.19.0.4
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.6
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.18.0.6
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.16.0.8
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.7.0.6
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.4
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.14
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.12
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.21
date	2010.06.29.20.30.32;	author guenther;	state dead;
branches;
next	1.20;

1.20
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.19.12.24.55;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2006.09.25.07.12.57;	author otto;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.15.21.12.44;	author aaron;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.09.21.33.44;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.19.23.53.12;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.28.00;	author millert;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2002.03.14.01.26.49;	author millert;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	2002.02.16.15.45.04;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.14.22.57.18;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.05.19.48.22;	author art;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.10.26.12.03.27;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.07.17.52.22;	author ericj;	state Exp;
branches;
next	1.6;

1.6
date	97.07.06.07.27.59;	author downsj;	state Exp;
branches
	1.6.12.1;
next	1.5;

1.5
date	97.04.16.09.18.05;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	97.01.27.00.18.36;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.20.34.55;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.07.13.53.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.12.14.04.47.12;	author deraadt;	state Exp;
branches;
next	;

1.6.12.1
date	2001.05.14.22.04.29;	author niklas;	state Exp;
branches;
next	1.6.12.2;

1.6.12.2
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.6.12.3;

1.6.12.3
date	2001.11.13.21.05.47;	author niklas;	state Exp;
branches;
next	1.6.12.4;

1.6.12.4
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.6.12.5;

1.6.12.5
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.6.12.6;

1.6.12.6
date	2003.06.07.11.00.36;	author ho;	state Exp;
branches;
next	1.6.12.7;

1.6.12.7
date	2004.02.19.10.51.28;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	;

1.12.6.1
date	2003.12.20.20.46.26;	author margarida;	state Exp;
branches;
next	;

1.13.2.1
date	2003.12.23.01.54.40;	author brad;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@/*	$OpenBSD: hpux_file.c,v 1.20 2010/06/26 23:24:44 guenther Exp $	*/
/*	$NetBSD: hpux_file.c,v 1.5 1997/04/27 21:40:48 thorpej Exp $	*/

/*
 * Copyright (c) 1995, 1997 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: hpux_compat.c 1.64 93/08/05$
 *
 *	@@(#)hpux_compat.c	8.4 (Berkeley) 2/13/94
 */

/*
 * File-related routines for HP-UX binary compatibility.  Partially
 * modeled after sys/compat/linux/linux_file.c
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/filedesc.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/wait.h>
#include <sys/file.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/ioctl.h>
#include <sys/ptrace.h>
#include <sys/stat.h>
#include <sys/syslog.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/ipc.h>
#include <sys/mman.h>

#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/psl.h>
#include <machine/vmparam.h>

#include <sys/syscallargs.h>

#include <compat/hpux/hpux.h>
#include <compat/hpux/hpux_util.h>
#include <compat/hpux/hpux_termio.h>
#include <compat/hpux/hpux_syscall.h>
#include <compat/hpux/hpux_syscallargs.h>

#include <machine/hpux_machdep.h>

int	hpux_stat1(struct proc *, void *, register_t *, int);
void	bsd_to_hpux_stat(struct stat *, struct hpux_stat *);
void	bsd_to_hpux_ostat(struct stat *, struct hpux_ostat *);

/*
 * HP-UX creat(2) system call.
 *
 * Just call open(2) with the TRUNC, CREAT and WRONLY flags.
 */
int
hpux_sys_creat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_creat_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
	} */ *uap = v;

	struct sys_open_args oa;
	caddr_t sg;

	sg = stackgap_init(p->p_emul);
	HPUX_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));

	SCARG(&oa, path) = SCARG(uap, path);
	SCARG(&oa, flags) = O_CREAT | O_TRUNC | O_WRONLY;
	SCARG(&oa, mode) = SCARG(uap, mode);

	return sys_open(p, &oa, retval);
}

/*
 * HP-UX open(2) system call.
 *
 * We need to remap some of the bits in the mode mask:
 *
 *	- O_CREAT, O_TRUNC, and O_EXCL must me remapped.
 *	- O_NONBLOCK is remapped and remembered.
 *	- O_FNDELAY is remembered.
 *	- O_SYNCIO is removed entirely.
 */
int
hpux_sys_open(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_open_args /* {
		syscallarg(char *) path;
		syscallarg(int) flags;
		syscallarg(int) mode;
	} */ *uap = v;
	struct sys_open_args oa;
	int flags, nflags, error;
	caddr_t sg;

	sg = stackgap_init(p->p_emul);

	/*
	 * Deal with the mode flags first, since they will affect
	 * how we check for the alternate path.
	 */
	flags = SCARG(uap, flags);
	nflags =
	   flags & ~(HPUXNONBLOCK|HPUXFSYNCIO|HPUXFEXCL|HPUXFTRUNC|HPUXFCREAT);
	if (flags & HPUXFCREAT) {
		/*
		 * Simulate the pre-NFS behavior that opening a
		 * file for READ+CREATE ignores the CREATE (unless
		 * EXCL is set in which case we will return the
		 * proper error).
		 */
		if ((flags & HPUXFEXCL) || (FFLAGS(flags) & FWRITE))
			nflags |= O_CREAT;
	}
	if (flags & HPUXFTRUNC)
		nflags |= O_TRUNC;
	if (flags & HPUXFEXCL)
		nflags |= O_EXCL;
	if (flags & HPUXNONBLOCK)
		nflags |= O_NDELAY;

	/*
	 * Do the alternate pathname check.
	 */
	if (SCARG(&oa, flags) & O_CREAT)
		HPUX_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));
	else
		HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	/*
	 * Fill in the new arguments and call the NetBSD open(2).
	 */
	SCARG(&oa, path) = SCARG(uap, path);
	SCARG(&oa, flags) = nflags;
	SCARG(&oa, mode) =  SCARG(uap, mode);

	error = sys_open(p, &oa, retval);

	/*
	 * Record non-blocking mode for fcntl, read, write, etc.
	 */
	if ((error == 0) && (nflags & O_NDELAY))
		p->p_fd->fd_ofileflags[*retval] |=
		    (flags & HPUXNONBLOCK) ?
		        HPUX_UF_NONBLOCK_ON : HPUX_UF_FNDELAY_ON;

	return (error);
}

/*
 * HP-UX fcntl(2) system call.
 */
int
hpux_sys_fcntl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_fcntl_args /* {
		syscallarg(int) fd;
		syscallarg(int) cmd;
		syscallarg(int) arg;
	} */ *uap = v;
	int arg, mode, error, flg = F_POSIX;
	struct file *fp;
	char *pop;
	struct hpux_flock hfl;
	struct flock fl;
	struct vnode *vp;
	struct sys_fcntl_args fa;
	struct filedesc *fdp = p->p_fd;

	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return (EBADF);
	FREF(fp);

	pop = &p->p_fd->fd_ofileflags[SCARG(uap, fd)];
	arg = SCARG(uap, arg);

	switch (SCARG(uap, cmd)) {
	case F_SETFL:
		if (arg & HPUXNONBLOCK)
			*pop |= HPUX_UF_NONBLOCK_ON;
		else
			*pop &= ~HPUX_UF_NONBLOCK_ON;

		if (arg & HPUXNDELAY)
			*pop |= HPUX_UF_FNDELAY_ON;
		else
			*pop &= ~HPUX_UF_FNDELAY_ON;
		
		if (*pop & (HPUX_UF_NONBLOCK_ON|HPUX_UF_FNDELAY_ON|HPUX_UF_FIONBIO_ON))
			arg |= FNONBLOCK;
		else
			arg &= ~FNONBLOCK;

		arg &= ~(HPUXNONBLOCK|HPUXFSYNCIO|HPUXFREMOTE);
		break;

	case F_GETFL:
	case F_DUPFD:
	case F_GETFD:
	case F_SETFD:
		break;

	case HPUXF_SETLKW:
		flg |= F_WAIT;
		/* Fall into F_SETLK */

	case HPUXF_SETLK:
		if (fp->f_type != DTYPE_VNODE) {
			error = EBADF;
			goto out;
		}

		vp = (struct vnode *)fp->f_data;

		/* Copy in the lock structure */
		error = copyin((caddr_t)SCARG(uap, arg), (caddr_t)&hfl,
		    sizeof (hfl));
		if (error)
			goto out;

		fl.l_start = hfl.hl_start;
		fl.l_len = hfl.hl_len;
		fl.l_pid = hfl.hl_pid;
		fl.l_type = hfl.hl_type;
		fl.l_whence = hfl.hl_whence;
		if (fl.l_whence == SEEK_CUR)
			fl.l_start += fp->f_offset;

		switch (fl.l_type) {
		case F_RDLCK:
			if ((fp->f_flag & FREAD) == 0) {
				error = EBADF;
				goto out;
			}

			atomic_setbits_int(&fdp->fd_flags, FD_ADVLOCK);
			error = VOP_ADVLOCK(vp, fdp, F_SETLK, &fl, flg);
			goto out;

		case F_WRLCK:
			if ((fp->f_flag & FWRITE) == 0) {
				error = EBADF;
				goto out;
			}
			atomic_setbits_int(&fdp->fd_flags, FD_ADVLOCK);
			error = VOP_ADVLOCK(vp, fdp, F_SETLK, &fl, flg);
			goto out;

		case F_UNLCK:
			error = VOP_ADVLOCK(vp, fdp, F_UNLCK, &fl, F_POSIX);
			goto out;

		default:
			error = EINVAL;
			goto out;
		}
		/* NOTREACHED */

	case F_GETLK:
		if (fp->f_type != DTYPE_VNODE) {
			error = EBADF;
			goto out;
		}

		vp = (struct vnode *)fp->f_data;

		/* Copy in the lock structure */
		error = copyin((caddr_t)SCARG(uap, arg), (caddr_t)&hfl,
		    sizeof (hfl));
		if (error)
			goto out;

		fl.l_start = hfl.hl_start;
		fl.l_len = hfl.hl_len;
		fl.l_pid = hfl.hl_pid;
		fl.l_type = hfl.hl_type;
		fl.l_whence = hfl.hl_whence;
		if (fl.l_whence == SEEK_CUR)
			fl.l_start += fp->f_offset;

		if ((error = VOP_ADVLOCK(vp, fdp, F_GETLK, &fl, F_POSIX)))
			goto out;

		hfl.hl_start = fl.l_start;
		hfl.hl_len = fl.l_len;
		hfl.hl_pid = fl.l_pid;
		hfl.hl_type = fl.l_type;
		hfl.hl_whence = fl.l_whence;
		error = copyout((caddr_t)&hfl, (caddr_t)SCARG(uap, arg),
		    sizeof (hfl));
		goto out;

	default:
		error = EINVAL;
		goto out;
	}

	/*
	 * Pass whatever's left on to the NetBSD fcntl(2).
	 */
	SCARG(&fa, fd) = SCARG(uap, fd);
	SCARG(&fa, cmd) = SCARG(uap, cmd);
	SCARG(&fa, arg) = (void *)arg;

	error = sys_fcntl(p, &fa, retval);

	if ((error == 0) && (SCARG(&fa, cmd) == F_GETFL)) {
		mode = *retval;
		*retval &= ~(O_CREAT|O_TRUNC|O_EXCL);
		if (mode & FNONBLOCK) {
			if (*pop & HPUX_UF_NONBLOCK_ON)
				*retval |= HPUXNONBLOCK;

			if ((*pop & HPUX_UF_FNDELAY_ON) == 0)
				*retval &= ~HPUXNDELAY;
		}
		if (mode & O_CREAT)
			*retval |= HPUXFCREAT;

		if (mode & O_TRUNC)
			*retval |= HPUXFTRUNC;

		if (mode & O_EXCL)
			*retval |= HPUXFEXCL;
	}
out:
	FRELE(fp);
	return (error);
}

/*
 * HP-UX fstat(2) system call.
 */
int
hpux_sys_fstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_fstat_args /* {
		syscallarg(int) fd;
		syscallarg(struct hpux_stat *) sb;
	} */ *uap = v;
	struct sys_fstat_args fsa;
	struct hpux_stat tmphst;
	struct stat *st, tmpst;
	caddr_t sg;
	int error;

	sg = stackgap_init(p->p_emul);

	st = stackgap_alloc(&sg, sizeof (struct stat));

	SCARG(&fsa, fd) = SCARG(uap, fd);
	SCARG(&fsa, sb) = st;

	if ((error = sys_fstat(p, &fsa, retval)))
		return (error);

	if ((error = copyin(st, &tmpst, sizeof(tmpst))))
		return (error);

	bsd_to_hpux_stat(&tmpst, &tmphst);

	return (copyout(&tmphst, SCARG(uap, sb), sizeof(struct hpux_stat)));
}

/*
 * HP-UX stat(2) system call.
 */
int
hpux_sys_stat(p, v, retval)
	struct proc *p; 
	void *v;
	register_t *retval;
{

	return (hpux_stat1(p, v, retval, 0));
}

/*
 * HP-UX lstat(2) system call.
 */
int
hpux_sys_lstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	return (hpux_stat1(p, v, retval, 1));
}

/*
 * Do the meat of stat(2) and lstat(2).
 */
int
hpux_stat1(p, v, retval, dolstat)
	struct proc *p;
	void *v;
	register_t *retval;
	int dolstat;
{
	struct hpux_sys_stat_args /* {
		syscallarg(char *) path;
		syscallarg(struct hpux_stat *) sb;
	} */ *uap = v;
	struct sys_stat_args sa;
	struct hpux_stat tmphst;
	struct stat *st, tmpst;
	caddr_t sg;
	int error;

	sg = stackgap_init(p->p_emul);

	st = stackgap_alloc(&sg, sizeof (struct stat));
	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&sa, ub) = st;
	SCARG(&sa, path) = SCARG(uap, path);

	if (dolstat)
		error = sys_lstat(p, &sa, retval);
	else
		error = sys_stat(p, &sa, retval);

	if (error)
		return (error);

	if ((error = copyin(st, &tmpst, sizeof(tmpst))))
		return (error);

	bsd_to_hpux_stat(&tmpst, &tmphst);

	return (copyout(&tmphst, SCARG(uap, sb), sizeof(struct hpux_stat)));
}

#ifndef __hppa__
/*
 * The old HP-UX fstat(2) system call.
 */
int
hpux_sys_fstat_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_fstat_6x_args /* {
		syscallarg(int) fd;
		syscallarg(struct hpux_ostat *) sb;
	} */ *uap = v;
	struct sys_fstat_args fsa;
	struct hpux_ostat tmphst;
	struct stat *st, tmpst;
	caddr_t sg;
	int error;

	sg = stackgap_init(p->p_emul);

	st = stackgap_alloc(&sg, sizeof (struct stat));

	SCARG(&fsa, fd) = SCARG(uap, fd);
	SCARG(&fsa, sb) = st;

	if ((error = sys_fstat(p, &fsa, retval)))
		return (error);

	if ((error = copyin(st, &tmpst, sizeof(tmpst))))
		return (error);

	bsd_to_hpux_ostat(&tmpst, &tmphst);

	return (copyout(&tmphst, SCARG(uap, sb), sizeof(struct hpux_ostat)));
}

/*
 * The old HP-UX stat(2) system call.
 */
int
hpux_sys_stat_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_stat_6x_args /* {
		syscallarg(char *) path;
		syscallarg(struct hpux_ostat *) sb;
	} */ *uap = v;
	struct sys_stat_args sa;
	struct hpux_ostat tmphst;
	struct stat *st, tmpst;
	caddr_t sg;
	int error;

	sg = stackgap_init(p->p_emul);

	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	st = stackgap_alloc(&sg, sizeof (struct stat));
	SCARG(&sa, ub) = st;
	SCARG(&sa, path) = SCARG(uap, path);

	if ((error = sys_stat(p, &sa, retval)))
		return (error);

	if ((error = copyin(st, &tmpst, sizeof(tmpst))))
		return (error);

	bsd_to_hpux_ostat(&tmpst, &tmphst);

	return (copyout(&tmphst, SCARG(uap, sb), sizeof(struct hpux_ostat)));
}

/*
 * Convert a NetBSD stat structure to an old-style HP-UX stat structure.
 */
void
bsd_to_hpux_ostat(sb, hsb)
	struct stat *sb;
	struct hpux_ostat *hsb;
{

	bzero(hsb, sizeof(struct hpux_ostat));
	hsb->hst_dev = (u_short)sb->st_dev;
	hsb->hst_ino = (u_short)sb->st_ino;
	hsb->hst_mode = (u_short)sb->st_mode;
	hsb->hst_nlink = (u_short)sb->st_nlink;
	hsb->hst_uid = (u_short)sb->st_uid;
	hsb->hst_gid = (u_short)sb->st_gid;
	hsb->hst_rdev = (u_short)sb->st_rdev;
	if (sb->st_size < (off_t)(((off_t)1) << 32))
		hsb->hst_size = (int)sb->st_size;
	else
		hsb->hst_size = -2;
	hsb->hst_atime = (int)sb->st_atime;
	hsb->hst_mtime = (int)sb->st_mtime;
	hsb->hst_ctime = (int)sb->st_ctime;
}
#endif

/*
 * Convert a NetBSD stat structure to an HP-UX stat structure.
 */
void
bsd_to_hpux_stat(sb, hsb)
	struct stat *sb;
	struct hpux_stat *hsb;
{

	bzero((caddr_t)hsb, sizeof(struct hpux_stat));
	hsb->hst_dev = (long)sb->st_dev;
	hsb->hst_ino = (u_long)sb->st_ino;
	hsb->hst_mode = (u_short)sb->st_mode;
	hsb->hst_nlink = (u_short)sb->st_nlink;
	hsb->hst_uid = (u_long)sb->st_uid;
	hsb->hst_gid = (u_long)sb->st_gid;
	hsb->hst_rdev = (long)bsdtohpuxdev(sb->st_rdev);
	/*
	 * XXX Let's just hope that the old binary doesn't lose.
	 */
	hsb->hst_old_uid = (u_short)sb->st_uid;
	hsb->hst_old_gid = (u_short)sb->st_gid;

	if (sb->st_size < (off_t)(((off_t)1) << 32))
		hsb->hst_size = (long)sb->st_size;
	else
		hsb->hst_size = -2;
	hsb->hst_atime = (long)sb->st_atime;
	hsb->hst_mtime = (long)sb->st_mtime;
	hsb->hst_ctime = (long)sb->st_ctime;
	hsb->hst_blksize = (long)sb->st_blksize;
	hsb->hst_blocks = (long)sb->st_blocks;
}

/*
 * HP-UX access(2) system call.
 */
int
hpux_sys_access(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_access_args /* {
		syscallarg(char *) path;
		syscallarg(int) flags;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return (sys_access(p, uap, retval));
}

/*
 * HP-UX unlink(2) system call.
 */
int
hpux_sys_unlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_unlink_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return (sys_unlink(p, uap, retval));
}

/*
 * HP-UX chdir(2) system call.
 */
int
hpux_sys_chdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_chdir_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return (sys_chdir(p, uap, retval));
}

/*
 * HP-UX mknod(2) system call.
 */
int
hpux_sys_mknod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_mknod_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
		syscallarf(int) dev;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);
	struct sys_mkfifo_args bma;

	HPUX_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));

	/*
	 * BSD handles FIFOs separately.
	 */
	if (S_ISFIFO(SCARG(uap, mode))) {
		SCARG(&bma, path) = SCARG(uap, path);
		SCARG(&bma, mode) = SCARG(uap, mode);
		return (sys_mkfifo(p, uap, retval));
	} else
		return (sys_mknod(p, uap, retval));
}

/*
 * HP-UX chmod(2) system call.
 */
int
hpux_sys_chmod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_chmod_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode; 
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return (sys_chmod(p, uap, retval));
}

/*
 * HP-UX chown(2) system call.
 */
int
hpux_sys_chown(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_chown_args /* {
		syscallarg(char *) path;
		syscallarg(int) uid;
		syscallarg(int) gid;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	/* XXX What about older HP-UX executables? */

	return (sys_lchown(p, uap, retval));
}

/*
 * HP-UX rename(2) system call.
 */
int
hpux_sys_rename(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_rename_args /* {
		syscallarg(char *) from;
		syscallarg(char *) to;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, from));
	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, to));

	return (sys_rename(p, uap, retval));
}

/*
 * HP-UX mkdir(2) system call.
 */
int
hpux_sys_mkdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_mkdir_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	HPUX_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));

	return (sys_mkdir(p, uap, retval));
}

/*
 * HP-UX rmdir(2) system call.
 */
int
hpux_sys_rmdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_rmdir_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return (sys_rmdir(p, uap, retval));
}

/*
 * HP-UX symlink(2) system call.
 */
int
hpux_sys_symlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_symlink_args /* {
		syscallarg(char *) path;
		syscallarg(char *) link;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	HPUX_CHECK_ALT_CREAT(p, &sg, SCARG(uap, link));

	return (sys_symlink(p, uap, retval));
}

/*
 * HP-UX readlink(2) system call.
 */
int
hpux_sys_readlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_readlink_args /* {
		syscallarg(char *) path;
		syscallarg(char *) buf;
		syscallarg(int) count;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return (sys_readlink(p, uap, retval));
}

/*
 * HP-UX truncate(2) system call.
 */
int
hpux_sys_truncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_truncate_args /* {
		syscallarg(char *) path;
		syscallarg(long) length;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	HPUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return (compat_43_sys_truncate(p, uap, retval));
}
@


1.20
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.19 2008/09/19 12:24:55 art Exp $	*/
@


1.19
log
@Fix a bunch of problems and races with posix file locking.

- file descriptor table becomes the owner of the lock instead of the proc.
- When grabbing the lock, we check if the fd hasn't changed under our
  feet, this is more or less impossible to solve without a hack like
  this. I've banged my head against the wall, I figured out a solution,
  but implementing it correctly would cost me 12 gray hairs. Screw it,
  this is ugly, but it works.
- Wait until usecount drains before releasing the posix lock in closef.
- Add missing FREF/FRELE to sys_flock
- keep the pid in the flock struct instead of abusing the fact that we
  used to use the proc as the lock owner.

Pointed out by and discussed with Al Viro, big thanks.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.18 2007/03/15 10:22:30 art Exp $	*/
a65 1
#include <sys/user.h>
@


1.18
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.17 2006/09/25 07:12:57 otto Exp $	*/
d285 2
a286 2
			atomic_setbits_int(&p->p_flag, P_ADVLOCK);
			error = VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg);
d294 2
a295 2
			atomic_setbits_int(&p->p_flag, P_ADVLOCK);
			error = VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg);
d299 1
a299 2
			error = VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &fl,
			    F_POSIX);
d330 1
a330 2
		if ((error =
		    VOP_ADVLOCK(vp, (caddr_t)p, F_GETLK, &fl, F_POSIX)))
@


1.17
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which lead to surprising results. Spotted by
from Paul Stoeber, more to come. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.16 2005/02/15 21:12:44 aaron Exp $	*/
d285 1
a285 1
			p->p_flag |= P_ADVLOCK;
d294 1
a294 1
			p->p_flag |= P_ADVLOCK;
@


1.16
log
@Fix HPUX fcntl() F_GETLK compatibility.  Broken since r1.10 by FREF/FRELE
fixes.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.15 2004/07/09 21:33:44 mickey Exp $	*/
d706 1
a706 1
	if (SCARG(uap, mode) & S_IFIFO) {
@


1.15
log
@split off the m68k-specific parts
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.14 2003/12/19 23:53:12 miod Exp $	*/
d310 4
a313 3
		if (fp->f_type != DTYPE_VNODE)
		error = EBADF;
		goto out;
@


1.14
log
@Make sure hpux fcntl() operates on the proper file.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.13 2003/06/02 23:28:00 millert Exp $	*/
d84 3
a86 3
static int	hpux_stat1(struct proc *, void *, register_t *, int);
static void	bsd_to_hpux_stat(struct stat *, struct hpux_stat *);
static void	bsd_to_hpux_ostat(struct stat *, struct hpux_ostat *);
d447 1
a447 1
static int
d488 1
d565 27
d594 1
a594 1
static void
a622 26
}

/*
 * Convert a NetBSD stat structure to an old-style HP-UX stat structure.
 */
static void
bsd_to_hpux_ostat(sb, hsb)
	struct stat *sb;
	struct hpux_ostat *hsb;
{

	bzero(hsb, sizeof(struct hpux_ostat));
	hsb->hst_dev = (u_short)sb->st_dev;
	hsb->hst_ino = (u_short)sb->st_ino;
	hsb->hst_mode = (u_short)sb->st_mode;
	hsb->hst_nlink = (u_short)sb->st_nlink;
	hsb->hst_uid = (u_short)sb->st_uid;
	hsb->hst_gid = (u_short)sb->st_gid;
	hsb->hst_rdev = (u_short)sb->st_rdev;
	if (sb->st_size < (off_t)(((off_t)1) << 32))
		hsb->hst_size = (int)sb->st_size;
	else
		hsb->hst_size = -2;
	hsb->hst_atime = (int)sb->st_atime;
	hsb->hst_mtime = (int)sb->st_mtime;
	hsb->hst_ctime = (int)sb->st_ctime;
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.12 2002/03/14 01:26:49 millert Exp $	*/
d217 1
a217 1
	struct filedesc *fdp;
@


1.13.2.1
log
@MFC:
Fix by miod@@

Make sure hpux fcntl() operates on the proper file.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.13 2003/06/02 23:28:00 millert Exp $	*/
d217 1
a217 1
	struct filedesc *fdp = p->p_fd;
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.11 2002/02/16 15:45:04 miod Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12.6.1
log
@Pull patch from -current:
Fix by miod@@

Make sure hpux fcntl() operates on the proper file.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.12 2002/03/14 01:26:49 millert Exp $	*/
d221 1
a221 1
	struct filedesc *fdp = p->p_fd;
@


1.11
log
@Make this compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.10 2002/02/14 22:57:18 pvalchev Exp $	*/
d88 3
a90 3
static int	hpux_stat1 __P((struct proc *, void *, register_t *, int));
static void	bsd_to_hpux_stat __P((struct stat *, struct hpux_stat *));
static void	bsd_to_hpux_ostat __P((struct stat *, struct hpux_ostat *));
@


1.10
log
@More FREF/FRELE fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.9 2001/11/05 19:48:22 art Exp $	*/
d263 1
a263 1
			goto aout;
d272 1
a272 1
			goto bad;
d324 1
a324 1
			goto bad;
d336 1
a336 1
			goto bad;
d380 1
a380 1
bad:
@


1.9
log
@More fallout from the fd_getfile changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.8 2001/10/26 12:03:27 art Exp $	*/
d225 1
d261 4
a264 2
		if (fp->f_type != DTYPE_VNODE)
			return (EBADF);
d272 1
a272 1
			return (error);
d284 4
a287 2
			if ((fp->f_flag & FREAD) == 0)
				return (EBADF);
d290 2
a291 1
			return (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg));
d294 4
a297 2
			if ((fp->f_flag & FWRITE) == 0)
				return (EBADF);
d299 2
a300 1
			return (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg));
d303 3
a305 2
			return (VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &fl,
			    F_POSIX));
d308 2
a309 1
			return (EINVAL);
d315 2
a316 1
		return (EBADF);
d324 1
a324 1
			return (error);
d336 1
a336 1
			return (error);
d343 3
a345 2
		return (copyout((caddr_t)&hfl, (caddr_t)SCARG(uap, arg),
		    sizeof (hfl)));
d348 2
a349 1
		return (EINVAL);
d380 2
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.9 2001/11/05 19:48:22 art Exp $	*/
d88 3
a90 3
static int	hpux_stat1(struct proc *, void *, register_t *, int);
static void	bsd_to_hpux_stat(struct stat *, struct hpux_stat *);
static void	bsd_to_hpux_ostat(struct stat *, struct hpux_ostat *);
a224 1
	FREF(fp);
d260 2
a261 4
		if (fp->f_type != DTYPE_VNODE) {
			error = EBADF;
			goto out;
		}
d269 1
a269 1
			goto out;
d281 2
a282 4
			if ((fp->f_flag & FREAD) == 0) {
				error = EBADF;
				goto out;
			}
d285 1
a285 2
			error = VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg);
			goto out;
d288 2
a289 4
			if ((fp->f_flag & FWRITE) == 0) {
				error = EBADF;
				goto out;
			}
d291 1
a291 2
			error = VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg);
			goto out;
d294 2
a295 3
			error = VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &fl,
			    F_POSIX);
			goto out;
d298 1
a298 2
			error = EINVAL;
			goto out;
d304 1
a304 2
		error = EBADF;
		goto out;
d312 1
a312 1
			goto out;
d324 1
a324 1
			goto out;
d331 2
a332 3
		error = copyout((caddr_t)&hfl, (caddr_t)SCARG(uap, arg),
		    sizeof (hfl));
		goto out;
d335 1
a335 2
		error = EINVAL;
		goto out;
a365 2
out:
	FRELE(fp);
@


1.8
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.7 2000/09/07 17:52:22 ericj Exp $	*/
d221 1
d223 1
a223 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd)) == NULL)
@


1.7
log
@common/compat_util.c
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.6 1997/07/06 07:27:59 downsj Exp $	*/
d222 1
a222 2
	if ((u_int)SCARG(uap, fd) > p->p_fd->fd_nfiles ||
	    (fp = p->p_fd->fd_ofiles[SCARG(uap, fd)]) == NULL)
@


1.6
log
@sync with NetBSD, 970705.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.5 1997/04/16 09:18:05 downsj Exp $	*/
d454 1
a456 1
	st = stackgap_alloc(&sg, sizeof (struct stat));
@


1.6.12.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.7 2000/09/07 17:52:22 ericj Exp $	*/
a453 1
	st = stackgap_alloc(&sg, sizeof (struct stat));
d456 1
@


1.6.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.6.12.1 2001/05/14 22:04:29 niklas Exp $	*/
d222 2
a223 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd)) == NULL)
@


1.6.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a220 1
	struct filedesc *fdp;
d222 1
a222 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
@


1.6.12.4
log
@Merge in trunk
@
text
@a224 1
	FREF(fp);
d260 2
a261 4
		if (fp->f_type != DTYPE_VNODE) {
			error = EBADF;
			goto out;
		}
d269 1
a269 1
			goto out;
d281 2
a282 4
			if ((fp->f_flag & FREAD) == 0) {
				error = EBADF;
				goto out;
			}
d285 1
a285 2
			error = VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg);
			goto out;
d288 2
a289 4
			if ((fp->f_flag & FWRITE) == 0) {
				error = EBADF;
				goto out;
			}
d291 1
a291 2
			error = VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg);
			goto out;
d294 2
a295 3
			error = VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &fl,
			    F_POSIX);
			goto out;
d298 1
a298 2
			error = EINVAL;
			goto out;
d304 1
a304 2
		error = EBADF;
		goto out;
d312 1
a312 1
			goto out;
d324 1
a324 1
			goto out;
d331 2
a332 3
		error = copyout((caddr_t)&hfl, (caddr_t)SCARG(uap, arg),
		    sizeof (hfl));
		goto out;
d335 1
a335 2
		error = EINVAL;
		goto out;
a365 2
out:
	FRELE(fp);
@


1.6.12.5
log
@Merge in -current from about a week ago
@
text
@d88 3
a90 3
static int	hpux_stat1(struct proc *, void *, register_t *, int);
static void	bsd_to_hpux_stat(struct stat *, struct hpux_stat *);
static void	bsd_to_hpux_ostat(struct stat *, struct hpux_ostat *);
@


1.6.12.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.6.12.5 2002/03/28 11:28:06 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.12.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d217 1
a217 1
	struct filedesc *fdp = p->p_fd;
@


1.5
log
@Changes up to NetBSD 970415.
@
text
@d1 2
a2 2
/*	$OpenBSD: hpux_file.c,v 1.4 1997/01/27 00:18:36 downsj Exp $	*/
/*	$NetBSD: hpux_file.c,v 1.4 1997/04/01 19:59:01 scottr Exp $	*/
d5 1
a5 1
 * Copyright (c) 1995 Jason R. Thorpe.  All rights reserved.
a572 6

	/*
	 * Call machine-dependent stat conversion.  Is it just me
	 * who thinks HP-UX device semantics are strange?!
	 */
	hpux_cpu_bsd_to_hpux_stat(sb, hsb);
@


1.4
log
@Use lchown(2) instead.
@
text
@d1 2
a2 2
/*	$OpenBSD: hpux_file.c,v 1.3 1996/08/02 20:34:55 niklas Exp $	*/
/*	$NetBSD: hpux_file.c,v 1.3 1996/01/06 12:44:14 thorpej Exp $	*/
d86 5
a90 3
static	int hpux_stat1 __P((struct proc *, void *, register_t *, int));
static	void bsd_to_hpux_stat __P((struct stat *, struct hpux_stat *));
static	void bsd_to_hpux_ostat __P((struct stat *, struct hpux_ostat *));
d322 2
a323 1
		if (error = VOP_ADVLOCK(vp, (caddr_t)p, F_GETLK, &fl, F_POSIX))
@


1.3
log
@Added Makefiles to build stuff from syscalls.master in some emulations.
Regenerated derived files from various syscalls.master files. Added $OpenBSD$.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_file.c,v 1.3 1996/01/06 12:44:14 thorpej Exp $	*/
d742 1
a742 1
	return (sys_chown(p, uap, retval));
@


1.2
log
@from netbsd:
Move the obviously machine-dependent HP-UX compat code to hpux_machdep.{c,h}.
A fair bit of this, the m68k core dump and exec goo, can probably be
made into a generic m68k hpux module, eventually.
@
text
@d1 1
@


1.1
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: hpux_file.c,v 1.2 1995/12/08 07:54:53 thorpej Exp $	*/
a546 16
/* XXX: Set up a machdep callback. */
#ifdef hp300
#include "grf.h"
#define	NHIL	1	/* XXX */
#endif

#if NGRF > 0
extern int grfopen __P((dev_t dev, int oflags, int devtype, struct proc *p));
#endif

#if NHIL > 0
extern int hilopen __P((dev_t dev, int oflags, int devtype, struct proc *p));
#endif

#include <sys/conf.h>

d570 5
a574 16
	/* MACHDEP CALLBACK SHOULD GO HERE! */
	/* XXX: I don't want to talk about it... */
	if ((sb->st_mode & S_IFMT) == S_IFCHR) {
#if NGRF > 0
		if (cdevsw[major(sb->st_rdev)].d_open == grfopen) {
			hsb->hst_rdev = grfdevno(sb->st_rdev);
			goto xxx_out;
		}
#endif
#if NHIL > 0
		if (cdevsw[major(sb->st_rdev)].d_open == hilopen) {
			hsb->hst_rdev = hildevno(sb->st_rdev);
			goto xxx_out;
		}
#endif
	}
a575 1
 xxx_out:
@
