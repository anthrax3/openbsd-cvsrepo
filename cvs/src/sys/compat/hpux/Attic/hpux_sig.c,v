head	1.13;
access;
symbols
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.8
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.28
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.26
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.24
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.6.0.22
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.20
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.18
	OPENBSD_2_8:1.6.0.16
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.14
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.12
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.10
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2010.06.29.20.30.32;	author guenther;	state dead;
branches;
next	1.12;

1.12
date	2009.12.09.16.29.56;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.01.11.53.26;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.20.16.41.43;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.19.21.56.18;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.09.21.33.44;	author mickey;	state dead;
branches;
next	1.7;

1.7
date	2003.06.02.23.28.00;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.09.15.06.05.52;	author millert;	state Exp;
branches
	1.6.12.1;
next	1.5;

1.5
date	97.07.27.09.10.39;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.04.16.09.18.09;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.20.34.56;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.47.13;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.14;	author deraadt;	state Exp;
branches;
next	;

1.6.12.1
date	2003.06.07.11.00.36;	author ho;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@/*	$OpenBSD: hpux_sig.c,v 1.12 2009/12/09 16:29:56 jsg Exp $	*/
/*	$NetBSD: hpux_sig.c,v 1.16 1997/04/01 19:59:02 scottr Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: hpux_sig.c 1.4 92/01/20$
 *
 *	@@(#)hpux_sig.c	8.2 (Berkeley) 9/23/93
 */

/*
 * Signal related HPUX compatibility routines
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/syscallargs.h>

#include <compat/hpux/hpux.h>
#include <compat/hpux/hpux_sig.h>
#include <compat/hpux/hpux_syscallargs.h>

/* indexed by HPUX signal number - 1 */
char hpuxtobsdsigmap[NSIG] = {
/*01*/	SIGHUP,  SIGINT, SIGQUIT, SIGILL,   SIGTRAP, SIGIOT,  SIGEMT,   SIGFPE,
/*09*/  SIGKILL, SIGBUS, SIGSEGV, SIGSYS,   SIGPIPE, SIGALRM, SIGTERM,  SIGUSR1,
/*17*/  SIGUSR2, SIGCHLD, 0,      SIGVTALRM,SIGPROF, SIGIO,   SIGWINCH, SIGSTOP,
/*25*/	SIGTSTP, SIGCONT,SIGTTIN, SIGTTOU,  SIGURG,  0,       0,        0,
/*33*/	0
};

/* indexed by BSD signal number - 1 */
char bsdtohpuxsigmap[NSIG] = {
/*01*/	 1,  2,  3,  4,  5,  6,  7,  8,
/*09*/   9, 10, 11, 12, 13, 14, 15, 29,
/*17*/  24, 25, 26, 18, 27, 28, 22,  0,
/*25*/	 0, 20, 21, 23,  0, 16, 17,  0,
/*33*/	 0
};

/*
 * XXX: In addition to mapping the signal number we also have
 * to see if the "old" style signal mechinism is needed.
 * If so, we set the OUSIG flag.  This is not really correct
 * as under HP-UX "old" style handling can be set on a per
 * signal basis and we are setting it for all signals in one
 * swell foop.  I suspect we can get away with this since I
 * doubt any program of interest mixes the two semantics.
 */
int
hpux_sys_sigvec(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_sigvec_args *uap = v;
	struct sigvec vec;
	struct sigacts *ps = p->p_sigacts;
	struct sigvec *sv;
	int sig;
	int bit, error;

	sig = hpuxtobsdsig(SCARG(uap, signo));
	if (sig <= 0 || sig >= NSIG || sig == SIGKILL || sig == SIGSTOP)
		return (EINVAL);
	sv = &vec;
	if (SCARG(uap, osv)) {
		sv->sv_handler = ps->ps_sigact[sig];
		sv->sv_mask = ps->ps_catchmask[sig];
		bit = sigmask(sig);
		sv->sv_flags = 0;
		if ((ps->ps_sigonstack & bit) != 0)
			sv->sv_flags |= SV_ONSTACK;
		if ((ps->ps_sigintr & bit) != 0)
			sv->sv_flags |= SV_INTERRUPT;
		if ((ps->ps_sigreset & bit) != 0)
			sv->sv_flags |= HPUXSV_RESET;
		sv->sv_mask &= ~bit;
		error = copyout((caddr_t)sv, (caddr_t)SCARG(uap, osv),
		    sizeof (vec));
		if (error)
			return (error);
	}
	if (SCARG(uap, nsv)) {
		error = copyin((caddr_t)SCARG(uap, nsv), (caddr_t)sv,
		    sizeof (vec));
		if (error)
			return (error);
		if (sig == SIGCONT && sv->sv_handler == SIG_IGN)
			return (EINVAL);
		sv->sv_flags ^= SA_RESTART;
		setsigvec(p, sig, (struct sigaction *)sv);
#if 0
/* XXX -- SOUSIG no longer exists, do something here */
		if (sv->sv_flags & HPUXSV_RESET)
			p->p_flag |= SOUSIG;		/* XXX */
#endif
	}
	return (0);
}

int
hpux_sys_sigblock(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_sigblock_args *uap = v;
	int s;

	s = splhigh();
	*retval = bsdtohpuxmask(p->p_sigmask);
	p->p_sigmask |= hpuxtobsdmask(SCARG(uap, mask)) &~ sigcantmask;
	splx(s);
	return (0);
}

int
hpux_sys_sigsetmask(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_sigsetmask_args *uap = v;
	int s;

	s = splhigh();
	*retval = bsdtohpuxmask(p->p_sigmask);
	p->p_sigmask = hpuxtobsdmask(SCARG(uap, mask)) &~ sigcantmask;
	splx(s);
	return (0);
}

int
hpux_sys_sigpause(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_sigpause_args *uap = v;

	SCARG(uap, mask) = hpuxtobsdmask(SCARG(uap, mask));
	return (sys_sigsuspend(p, uap, retval));
}

/* not totally correct, but close enough */
int
hpux_sys_kill(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_kill_args *uap = v;

	if (SCARG(uap, signo)) {
		SCARG(uap, signo) = hpuxtobsdsig(SCARG(uap, signo));
		if (SCARG(uap, signo) == 0)
			SCARG(uap, signo) = NSIG;
	}
	return (sys_kill(p, uap, retval));
}

/*
 * The following (sigprocmask, sigpending, sigsuspend, sigaction are
 * POSIX calls.  Under BSD, the library routine dereferences the sigset_t
 * pointers before traping.  Not so under HP-UX.
 */

/*
 * Manipulate signal mask.
 * Note that we receive new mask, not pointer,
 * and return old mask as return value;
 * the library stub does the rest.
 */
int
hpux_sys_sigprocmask(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_sigprocmask_args *uap = v;
	int mask, error = 0;
	hpux_sigset_t sigset;
	int s;

	/*
	 * Copy out old mask first to ensure no errors.
	 * (proc sigmask should not be changed if call fails for any reason)
	 */
	if (SCARG(uap, oset)) {
		bzero((caddr_t)&sigset, sizeof(sigset));
		sigset.sigset[0] = bsdtohpuxmask(p->p_sigmask);
		if (copyout((caddr_t)&sigset, (caddr_t)SCARG(uap, oset),
		    sizeof(sigset)))
			return (EFAULT);
	}
	if (SCARG(uap, set)) {
		if (copyin((caddr_t)SCARG(uap, set), (caddr_t)&sigset,
		    sizeof(sigset)))
			return (EFAULT);
		mask = hpuxtobsdmask(sigset.sigset[0]);
		s = splhigh();
		switch (SCARG(uap, how)) {
		case HPUXSIG_BLOCK:
			p->p_sigmask |= mask &~ sigcantmask;
			break;
		case HPUXSIG_UNBLOCK:
			p->p_sigmask &= ~mask;
			break;
		case HPUXSIG_SETMASK:
			p->p_sigmask = mask &~ sigcantmask;
			break;
		default:
			error = EINVAL;
			break;
		}
		splx(s);
	}
	return (error);
}

int
hpux_sys_sigpending(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_sigpending_args *uap = v;
	hpux_sigset_t sigset;

	sigset.sigset[0] = bsdtohpuxmask(p->p_siglist);
	return (copyout((caddr_t)&sigset, (caddr_t)SCARG(uap, set),
	    sizeof(sigset)));
}

int
hpux_sys_sigsuspend(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_sigsuspend_args *uap = v;
	struct sigacts *ps = p->p_sigacts;
	hpux_sigset_t sigset;
	int mask;

	if (copyin((caddr_t)SCARG(uap, set), (caddr_t)&sigset, sizeof(sigset)))
		return (EFAULT);
	mask = hpuxtobsdmask(sigset.sigset[0]);
	ps->ps_oldmask = p->p_sigmask;
	ps->ps_flags |= SAS_OLDMASK;
	p->p_sigmask = mask &~ sigcantmask;
	(void) tsleep((caddr_t)ps, PPAUSE | PCATCH, "pause", 0);
	/* always return EINTR rather than ERESTART... */
	return (EINTR);
}

int
hpux_sys_sigaction(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_sigaction_args *uap = v;
	struct hpux_sigaction action;
	struct sigacts *ps = p->p_sigacts;
	struct hpux_sigaction *sa;
	int sig;
	int bit;

	sig = hpuxtobsdsig(SCARG(uap, signo));
	if (sig <= 0 || sig >= NSIG || sig == SIGKILL || sig == SIGSTOP)
		return (EINVAL);

	sa = &action;
	if (SCARG(uap, osa)) {
		sa->sa__handler = ps->ps_sigact[sig];
		bzero((caddr_t)&sa->sa_mask, sizeof(sa->sa_mask));
		sa->sa_mask.sigset[0] = bsdtohpuxmask(ps->ps_catchmask[sig]);
		bit = sigmask(sig);
		sa->sa_flags = 0;
		if ((ps->ps_sigonstack & bit) != 0)
			sa->sa_flags |= HPUXSA_ONSTACK;
		if ((ps->ps_sigreset & bit) != 0)
			sa->sa_flags |= HPUXSA_RESETHAND;
		if (p->p_flag & P_NOCLDSTOP)
			sa->sa_flags |= HPUXSA_NOCLDSTOP;
		if (p->p_flag & P_NOCLDWAIT)
			sa->sa_flags |= HPUXSA_NOCLDWAIT;
		if (copyout((caddr_t)sa, (caddr_t)SCARG(uap, osa),
		    sizeof (action)))
			return (EFAULT);
	}
	if (SCARG(uap, nsa)) {
		struct sigaction act;

		if (copyin((caddr_t)SCARG(uap, nsa), (caddr_t)sa,
		    sizeof (action)))
			return (EFAULT);
		if (sig == SIGCONT && sa->sa__handler == SIG_IGN)
			return (EINVAL);
		/*
		 * Create a sigaction struct for setsigvec
		 */
		act.sa_handler = sa->sa__handler;
		act.sa_mask = hpuxtobsdmask(sa->sa_mask.sigset[0]);
		act.sa_flags = SA_RESTART;
		if (sa->sa_flags & HPUXSA_ONSTACK)
			act.sa_flags |= SA_ONSTACK;
		if (sa->sa_flags & HPUXSA_NOCLDSTOP)
			act.sa_flags |= SA_NOCLDSTOP;
		if (sa->sa_flags & HPUXSA_NOCLDWAIT)
			act.sa_flags |= SA_NOCLDWAIT;
		setsigvec(p, sig, &act);
#if 0
/* XXX -- SOUSIG no longer exists, do something here */
		if (sa->sa_flags & HPUXSA_RESETHAND)
			p->p_flag |= SOUSIG;		/* XXX */
#endif
	}
	return (0);
}

/* signal numbers: convert from HPUX to BSD */
int
hpuxtobsdsig(sig)
	int sig;
{
	if (--sig < 0 || sig >= NSIG)
		return(0);
	return((int)hpuxtobsdsigmap[sig]);
}

/* signal numbers: convert from BSD to HPUX */
int
bsdtohpuxsig(sig)
	int sig;
{
	if (--sig < 0 || sig >= NSIG)
		return(0);
	return((int)bsdtohpuxsigmap[sig]);
}

/* signal masks: convert from HPUX to BSD (not pretty or fast) */
int
hpuxtobsdmask(mask)
	int mask;
{
	int nmask, sig, nsig;

	if (mask == 0 || mask == -1)
		return(mask);
	nmask = 0;
	for (sig = 1; sig < NSIG; sig++)
		if ((mask & sigmask(sig)) && (nsig = hpuxtobsdsig(sig)))
			nmask |= sigmask(nsig);
	return(nmask);
}

int
bsdtohpuxmask(mask)
	int mask;
{
	int nmask, sig, nsig;

	if (mask == 0 || mask == -1)
		return(mask);
	nmask = 0;
	for (sig = 1; sig < NSIG; sig++)
		if ((mask & sigmask(sig)) && (nsig = bsdtohpuxsig(sig)))
			nmask |= sigmask(nsig);
	return(nmask);
}
@


1.12
log
@Add entries in compat signal mapping arrays for SIGTHR.
Prompted by parfait noticing overflows in ibcs2/svr4 which
are now changed to being NSIG sized like the others as
suggested by tedu.

ok tedu@@ miod@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_sig.c,v 1.11 2008/05/01 11:53:26 miod Exp $	*/
@


1.11
log
@spl0() is not your friend, use splx() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_sig.c,v 1.10 2007/10/20 16:41:43 miod Exp $	*/
d63 2
a64 1
/*25*/	SIGTSTP, SIGCONT,SIGTTIN, SIGTTOU,  SIGURG,  0,       0,        0
d72 2
a73 1
/*25*/	 0, 20, 21, 23,  0, 16, 17,  0
@


1.10
log
@enuf -> enough
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_sig.c,v 1.9 2004/09/19 21:56:18 mickey Exp $	*/
d142 1
d144 1
a144 1
	(void) splhigh();
d147 1
a147 1
	(void) spl0();
d158 1
d160 1
a160 1
	(void) splhigh();
d163 1
a163 1
	(void) spl0();
d217 1
d235 1
a235 1
		(void) splhigh();
d250 1
a250 1
		(void) spl0();
@


1.9
log
@ressurect hpux_sig.c and implement just the different parts in arch/hpux_sig2.c
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_sig.c,v 1.1 2004/07/09 21:33:45 mickey Exp $	*/
d177 1
a177 1
/* not totally correct, but close enuf' */
@


1.8
log
@split off the m68k-specific parts
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_sig.c,v 1.7 2003/06/02 23:28:00 millert Exp $	*/
a350 39
	return (0);
}

int
hpux_sys_ssig_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_ssig_6x_args /* {
		syscallarg(int) signo;
		syscallarg(sig_t) fun;
	} */ *uap = v;
	int a;
	struct sigaction vec;
	struct sigaction *sa = &vec;

	a = hpuxtobsdsig(SCARG(uap, signo));
	sa->sa_handler = SCARG(uap, fun);
	/*
	 * Kill processes trying to use job control facilities
	 * (this'll help us find any vestiges of the old stuff).
	 */
	if ((a &~ 0377) ||
	    (sa->sa_handler != SIG_DFL && sa->sa_handler != SIG_IGN &&
	     ((int)sa->sa_handler) & 1)) {
		psignal(p, SIGSYS);
		return (0);
	}
	if (a <= 0 || a >= NSIG || a == SIGKILL || a == SIGSTOP ||
	    (a == SIGCONT && sa->sa_handler == SIG_IGN))
		return (EINVAL);
	sa->sa_mask = 0;
	sa->sa_flags = 0;
	*retval = (int)p->p_sigacts->ps_sigact[a];
	setsigvec(p, a, sa);
#if 0
	p->p_flag |= SOUSIG;		/* mark as simulating old stuff */
#endif
@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_sig.c,v 1.6 1997/09/15 06:05:52 millert Exp $	*/
@


1.6
log
@SA_NOCLDWAIT
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_sig.c,v 1.5 1997/07/27 09:10:39 deraadt Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6.12.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_sig.c,v 1.6 1997/09/15 06:05:52 millert Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5
log
@sa__handler to avoid sa_handler stuff coming before 2000....
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_sig.c,v 1.4 1997/04/16 09:18:09 downsj Exp $	*/
d322 2
d346 2
@


1.4
log
@Changes up to NetBSD 970415.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_sig.c,v 1.3 1996/08/02 20:34:56 niklas Exp $	*/
d311 1
a311 1
		sa->sa_handler = ps->ps_sigact[sig];
d332 1
a332 1
		if (sig == SIGCONT && sa->sa_handler == SIG_IGN)
d337 1
a337 1
		act.sa_handler = sa->sa_handler;
@


1.3
log
@Added Makefiles to build stuff from syscalls.master in some emulations.
Regenerated derived files from various syscalls.master files. Added $OpenBSD$.
@
text
@d1 2
a2 2
/*	$OpenBSD: hpux_sig.c,v 1.15 1995/11/28 08:39:50 thorpej Exp $	*/
/*	$NetBSD: hpux_sig.c,v 1.15 1995/11/28 08:39:50 thorpej Exp $	*/
d53 1
d56 1
d59 1
d93 1
a93 1
	register struct hpux_sys_sigvec_args *uap = v;
d95 3
a97 3
	register struct sigacts *ps = p->p_sigacts;
	register struct sigvec *sv;
	register int sig;
d141 1
a141 1
	register struct proc *p;
d212 1
a212 1
	register struct proc *p;
d258 1
a258 1
	register struct proc *p;
d272 1
a272 1
	register struct proc *p;
d277 1
a277 1
	register struct sigacts *ps = p->p_sigacts;
d298 1
a298 1
	register struct hpux_sys_sigaction_args *uap = v;
d300 3
a302 3
	register struct sigacts *ps = p->p_sigacts;
	register struct hpux_sigaction *sa;
	register int sig;
d339 1
a339 1
		act.sa_flags == SA_RESTART;
d364 1
a364 1
	register int a;
d366 1
a366 1
	register struct sigaction *sa = &vec;
d381 1
a381 1
	    a == SIGCONT && sa->sa_handler == SIG_IGN)
d396 1
a396 1
	register int sig;
d406 1
a406 1
	register int sig;
d416 1
a416 1
	register int mask;
d418 1
a418 1
	register int nmask, sig, nsig;
d431 1
a431 1
	register int mask;
d433 1
a433 1
	register int nmask, sig, nsig;
@


1.2
log
@update from netbsd
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: hpux_sig.c,v 1.14 1995/10/07 06:26:38 mycroft Exp $	*/
a349 1
#ifdef COMPAT_HPUX_6X
d351 1
a351 1
compat_hpux_6x_sys_ssig(p, v, retval)
d356 4
a359 1
	struct compat_hpux_6x_sys_ssig_args *uap = v;
a387 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
