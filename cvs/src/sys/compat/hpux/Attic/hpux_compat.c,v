head	1.34;
access;
symbols
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.30.0.6
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.29.0.4
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.28.0.14
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.12
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.10
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.8
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.6
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.20
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.10.0.14
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.12
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.10
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.8
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.6
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2010.06.29.20.30.32;	author guenther;	state dead;
branches;
next	1.33;

1.33
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.28.19.59.07;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2010.01.28.19.23.06;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2008.11.01.05.59.21;	author deraadt;	state Exp;
branches
	1.30.2.1
	1.30.6.1;
next	1.29;

1.29
date	2007.09.22.09.57.40;	author martin;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.09.21.33.44;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.24.19.35.23;	author tholo;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.22.23.52.17;	author jfb;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.21.23.50.35;	author tholo;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.15.20.32.15;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.28.00;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.09.22.27.11;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.30.20.10.48;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.02.18.06.25;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.49;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.00.42.25;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.13.19.08.06;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.05.19.47.03;	author art;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.10.26.12.03.27;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.10.23.43.44;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.24.10.41.51;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.26.16.22.11;	author art;	state Exp;
branches;
next	1.10;

1.10
date	97.07.06.07.27.59;	author downsj;	state Exp;
branches
	1.10.12.1;
next	1.9;

1.9
date	97.04.16.09.18.02;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	97.03.26.08.11.04;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.02.23.21.40.55;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	97.01.27.00.00.03;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.08.02.20.34.53;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.04.19.43.35;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.07.13.53.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.47.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.14;	author deraadt;	state Exp;
branches;
next	;

1.10.12.1
date	2001.05.14.22.04.29;	author niklas;	state Exp;
branches;
next	1.10.12.2;

1.10.12.2
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.10.12.3;

1.10.12.3
date	2001.11.13.21.05.47;	author niklas;	state Exp;
branches;
next	1.10.12.4;

1.10.12.4
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.10.12.5;

1.10.12.5
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.10.12.6;

1.10.12.6
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	1.10.12.7;

1.10.12.7
date	2003.06.07.11.00.36;	author ho;	state Exp;
branches;
next	1.10.12.8;

1.10.12.8
date	2004.02.19.10.51.28;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.28.07;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.30.51;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2003.05.19.21.52.09;	author tedu;	state Exp;
branches;
next	;

1.30.2.1
date	2010.01.29.21.33.30;	author sthen;	state Exp;
branches;
next	;

1.30.6.1
date	2010.01.29.21.33.13;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@/*	$OpenBSD: hpux_compat.c,v 1.33 2010/06/26 23:24:44 guenther Exp $	*/
/*	$NetBSD: hpux_compat.c,v 1.35 1997/05/08 16:19:48 mycroft Exp $	*/

/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Utah $Hdr: hpux_compat.c 1.64 93/08/05$
 *
 *	@@(#)hpux_compat.c	8.4 (Berkeley) 2/13/94
 */

/*
 * Various HP-UX compatibility routines
 */

#ifndef COMPAT_43
#define COMPAT_43
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signalvar.h>
#include <sys/kernel.h>
#include <sys/filedesc.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/wait.h>
#include <sys/file.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/ioctl.h>
#include <sys/ptrace.h>
#include <sys/stat.h>
#include <sys/syslog.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/mount.h>
#include <sys/ipc.h>
#include <sys/sysctl.h>
#include <sys/mman.h>

#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/psl.h>
#include <machine/vmparam.h>

#include <sys/syscallargs.h>

#include <compat/hpux/hpux.h>
#include <compat/hpux/hpux_sig.h>
#include <compat/hpux/hpux_util.h>
#include <compat/hpux/hpux_termio.h>
#include <compat/hpux/hpux_syscall.h>
#include <compat/hpux/hpux_syscallargs.h>

#include <machine/hpux_machdep.h>

#ifdef DEBUG
int unimpresponse = 0;
#endif

#define NERR	83
#define BERR	1000

/* indexed by BSD errno */
int bsdtohpuxerrnomap[NERR] = {
/*00*/	  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
/*10*/	 10,  45,  12,  13,  14,  15,  16,  17,  18,  19,
/*20*/	 20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
/*30*/	 30,  31,  32,  33,  34, 246, 245, 244, 216, 217,
/*40*/	218, 219, 220, 221, 222, 223, 224, 225, 226, 227,
/*50*/	228, 229, 230, 231, 232, 233, 234, 235, 236, 237,
/*60*/	238, 239, 249, 248, 241, 242, 247,BERR,BERR,BERR,
/*70*/   70,  71,BERR,BERR,BERR,BERR,BERR,  46, 251,BERR,
/*80*/ BERR,BERR,  11
};

extern char sigcode[], esigcode[];
extern struct sysent hpux_sysent[];
extern char *hpux_syscallnames[];

int	hpux_shmctl1(struct proc *, struct hpux_sys_shmctl_args *,
	    register_t *, int);
int	hpuxtobsdioctl(u_long);

static int	hpux_scale(struct timeval *);

/*
 * HP-UX fork and vfork need to map the EAGAIN return value appropriately.
 */
int
hpux_sys_fork(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	/* struct hpux_sys_fork_args *uap = v; */
	int error;

	error = sys_fork(p, v, retval);
	if (error == EAGAIN)
		error = OEAGAIN;
	return (error);
}

int
hpux_sys_vfork(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	/* struct hpux_sys_vfork_args *uap = v; */
	int error;

	error = sys_vfork(p, v, retval);
	if (error == EAGAIN)
		error = OEAGAIN;
	return (error);
}

/*
 * HP-UX versions of wait and wait3 actually pass the parameters
 * (status pointer, options, rusage) into the kernel rather than
 * handling it in the C library stub.  We also need to map any
 * termination signal from BSD to HP-UX.
 */
int
hpux_sys_wait3(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_wait3_args *uap = v;

	/* rusage pointer must be zero */
	if (SCARG(uap, rusage))
		return (EINVAL);
#ifdef m68k
	p->p_md.md_regs[PS] = PSL_ALLCC;
	p->p_md.md_regs[R0] = SCARG(uap, options);
	p->p_md.md_regs[R1] = SCARG(uap, rusage);
#endif

	return (hpux_sys_wait(p, uap, retval));
}

int
hpux_sys_wait(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_wait_args *uap = v;
	struct sys_wait4_args w4;
	int error;
	int sig;
	size_t sz = sizeof(*SCARG(&w4, status));
	int status;

	SCARG(&w4, rusage) = NULL;
	SCARG(&w4, options) = 0;

	if (SCARG(uap, status) == NULL) {
		caddr_t sg = stackgap_init(p->p_emul);
		SCARG(&w4, status) = stackgap_alloc(&sg, sz);
	}
	else
		SCARG(&w4, status) = SCARG(uap, status);

	SCARG(&w4, pid) = WAIT_ANY;

	error = sys_wait4(p, &w4, retval);
	/*
	 * HP-UX wait always returns EINTR when interrupted by a signal
	 * (well, unless its emulating a BSD process, but we don't bother...)
	 */
	if (error == ERESTART)
		error = EINTR;
	if (error)
		return error;

	if ((error = copyin(SCARG(&w4, status), &status, sizeof(status))) != 0)
		return error;

	sig = status & 0xFF;
	if (sig == WSTOPPED) {
		sig = (status >> 8) & 0xFF;
		retval[1] = (bsdtohpuxsig(sig) << 8) | WSTOPPED;
	} else if (sig)
		retval[1] = (status & 0xFF00) |
			bsdtohpuxsig(sig & 0x7F) | (sig & 0x80);

	if (SCARG(uap, status) == NULL)
		return error;
	else
		return copyout(&retval[1], 
			       SCARG(uap, status), sizeof(retval[1]));
}

int
hpux_sys_waitpid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_waitpid_args *uap = v;
	int rv, sig, xstat, error;

	SCARG(uap, rusage) = 0;
	error = sys_wait4(p, uap, retval);
	/*
	 * HP-UX wait always returns EINTR when interrupted by a signal
	 * (well, unless its emulating a BSD process, but we don't bother...)
	 */
	if (error == ERESTART)
		error = EINTR;
	if (error)
		return (error);

	if (SCARG(uap, status)) {
		/*
		 * Wait4 already wrote the status out to user space,
		 * pull it back, change the signal portion, and write
		 * it back out.
		 */
		if ((error = copyin((caddr_t)SCARG(uap, status), &rv,
		    sizeof(int))) != 0)
			return error;

		if (WIFSTOPPED(rv)) {
			sig = WSTOPSIG(rv);
			rv = W_STOPCODE(bsdtohpuxsig(sig));
		} else if (WIFSIGNALED(rv)) {
			sig = WTERMSIG(rv);
			xstat = WEXITSTATUS(rv);
			rv = W_EXITCODE(xstat, bsdtohpuxsig(sig)) |
				WCOREDUMP(rv);
		}
		error = copyout(&rv, (caddr_t)SCARG(uap, status), sizeof(int));
	}
	return (error);
}

/*
 * Read and write calls.  Same as BSD except for non-blocking behavior.
 * There are three types of non-blocking reads/writes in HP-UX checked
 * in the following order:
 *
 *	O_NONBLOCK: return -1 and errno == EAGAIN
 *	O_NDELAY:   return 0
 *	FIOSNBIO:   return -1 and errno == EWOULDBLOCK
 */
int
hpux_sys_read(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_read_args *uap = v;
	int error;

	error = sys_read(p, (struct sys_read_args *) uap, retval);
	if (error == EWOULDBLOCK) {
		char *fp = &p->p_fd->fd_ofileflags[SCARG(uap, fd)];

		if (*fp & HPUX_UF_NONBLOCK_ON) {
			*retval = -1;
			error = OEAGAIN;
		} else if (*fp & HPUX_UF_FNDELAY_ON) {
			*retval = 0;
			error = 0;
		}
	}
	return (error);
}

int
hpux_sys_write(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_write_args *uap = v;
	int error;

	error = sys_write(p, (struct sys_write_args *) uap, retval);
	if (error == EWOULDBLOCK) {
		char *fp = &p->p_fd->fd_ofileflags[SCARG(uap, fd)];

		if (*fp & HPUX_UF_NONBLOCK_ON) {
			*retval = -1;
			error = OEAGAIN;
		} else if (*fp & HPUX_UF_FNDELAY_ON) {
			*retval = 0;
			error = 0;
		}
	}
	return (error);
}

int
hpux_sys_readv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_readv_args *uap = v;
	int error;

	error = sys_readv(p, (struct sys_readv_args *) uap, retval);
	if (error == EWOULDBLOCK) {
		char *fp = &p->p_fd->fd_ofileflags[SCARG(uap, fd)];

		if (*fp & HPUX_UF_NONBLOCK_ON) {
			*retval = -1;
			error = OEAGAIN;
		} else if (*fp & HPUX_UF_FNDELAY_ON) {
			*retval = 0;
			error = 0;
		}
	}
	return (error);
}

int
hpux_sys_writev(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_writev_args *uap = v;
	int error;

	error = sys_writev(p, (struct sys_writev_args *) uap, retval);
	if (error == EWOULDBLOCK) {
		char *fp = &p->p_fd->fd_ofileflags[SCARG(uap, fd)];

		if (*fp & HPUX_UF_NONBLOCK_ON) {
			*retval = -1;
			error = OEAGAIN;
		} else if (*fp & HPUX_UF_FNDELAY_ON) {
			*retval = 0;
			error = 0;
		}
	}
	return (error);
}

int
hpux_sys_utssys(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_utssys_args *uap = v;
	int i;
	int error;
	struct hpux_utsname	ut;
	extern char hostname[], machine[];

	switch (SCARG(uap, request)) {
	/* uname */
	case 0:
		bzero(&ut, sizeof(ut));

		strlcpy(ut.sysname, ostype, sizeof(ut.sysname));

		/* copy hostname (sans domain) to nodename */
		for (i = 0; i < 8 && hostname[i] != '.'; i++)
			ut.nodename[i] = hostname[i];
		ut.nodename[i] = '\0';

		strlcpy(ut.release, osrelease, sizeof(ut.release));
		strlcpy(ut.version, version, sizeof(ut.version));
		strlcpy(ut.machine, machine, sizeof(ut.machine));

		error = copyout((caddr_t)&ut,
		    (caddr_t)SCARG(uap, uts), sizeof(ut));
		break;

	/* gethostname */
	case 5:
		/* SCARG(uap, dev) is length */
		i = SCARG(uap, dev);
		if (i < 0) {
			error = EINVAL;
			break;
		}
		if (i > hostnamelen + 1)
			i = hostnamelen + 1;
		error = copyout((caddr_t)hostname, (caddr_t)SCARG(uap, uts), i);
		break;

	case 1:	/* ?? */
	case 2:	/* ustat */
	case 3:	/* ?? */
	case 4:	/* sethostname */
	default:
		error = EINVAL;
		break;
	}
	return (error);
}

int
hpux_sys_sysconf(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_sysconf_args *uap = v;
	switch (SCARG(uap, name)) {

	/* clock ticks per second */
	case HPUX_SYSCONF_CLKTICK:
		*retval = hz;
		break;

	/* open files */
	case HPUX_SYSCONF_OPENMAX:
		*retval = NOFILE;
		break;

	/* architecture */
	case HPUX_SYSCONF_CPUTYPE:
		*retval = hpux_cpu_sysconf_arch();
		break;
	default:
		/* XXX */
		uprintf("HP-UX sysconf(%d) not implemented\n",
		    SCARG(uap, name));
		return (EINVAL);
	}
	return (0);
}

int
hpux_sys_ulimit(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_ulimit_args *uap = v;
	struct rlimit *limp;
	int error = 0;

	limp = &p->p_rlimit[RLIMIT_FSIZE];
	switch (SCARG(uap, cmd)) {
	case 2:
		SCARG(uap, newlimit) *= 512;
		if (SCARG(uap, newlimit) > limp->rlim_max &&
		    (error = suser(p, 0)))
			break;
		limp->rlim_cur = limp->rlim_max = SCARG(uap, newlimit);
		/* else fall into... */

	case 1:
		*retval = limp->rlim_max / 512;
		break;

	case 3:
		limp = &p->p_rlimit[RLIMIT_DATA];
		*retval = ptoa(p->p_vmspace->vm_tsize) + limp->rlim_max;
		break;

	default:
		error = EINVAL;
		break;
	}
	return (error);
}

/*
 * Map "real time" priorities 0 (high) thru 127 (low) into nice
 * values -16 (high) thru -1 (low).
 */
int
hpux_sys_rtprio(cp, v, retval)
	struct proc *cp;
	void *v;
	register_t *retval;
{
	struct hpux_sys_rtprio_args *uap = v;
	struct proc *p;
	int nice, error;

	if (SCARG(uap, prio) < RTPRIO_MIN && SCARG(uap, prio) > RTPRIO_MAX &&
	    SCARG(uap, prio) != RTPRIO_NOCHG &&
	    SCARG(uap, prio) != RTPRIO_RTOFF)
		return (EINVAL);
	if (SCARG(uap, pid) == 0)
		p = cp;
	else if ((p = pfind(SCARG(uap, pid))) == 0)
		return (ESRCH);
	nice = p->p_nice;
	if (nice < NZERO)
		*retval = (nice + 16) << 3;
	else
		*retval = RTPRIO_RTOFF;
	switch (SCARG(uap, prio)) {

	case RTPRIO_NOCHG:
		return (0);

	case RTPRIO_RTOFF:
		if (nice >= NZERO)
			return (0);
		nice = NZERO;
		break;

	default:
		nice = (SCARG(uap, prio) >> 3) - 16;
		break;
	}
	error = donice(cp, p, nice);
	if (error == EACCES)
		error = EPERM;
	return (error);
}

/* hpux_sys_advise() is found in hpux_machdep.c */

#ifdef PTRACE

int
hpux_sys_ptrace(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_ptrace_args *uap = v;
	int error;
#if defined(PT_READ_U) || defined(PT_WRITE_U)
	int isps = 0;
	struct proc *cp;
#endif

	switch (SCARG(uap, req)) {
	/* map signal */
#if defined(PT_STEP) || defined(PT_CONTINUE)
# ifdef PT_STEP
	case PT_STEP:
# endif
# ifdef PT_CONTINUE
	case PT_CONTINUE:
# endif
		if (SCARG(uap, data)) {
			SCARG(uap, data) = hpuxtobsdsig(SCARG(uap, data));
			if (SCARG(uap, data) == 0)
				SCARG(uap, data) = NSIG;
		}
		break;
#endif
	/* map u-area offset */
#if defined(PT_READ_U) || defined(PT_WRITE_U)
# ifdef PT_READ_U
	case PT_READ_U:
# endif
# ifdef PT_WRITE_U
	case PT_WRITE_U:
# endif
		/*
		 * Big, cheezy hack: hpux_to_bsd_uoff is really intended
		 * to be called in the child context (procxmt) but we
		 * do it here in the parent context to avoid hacks in
		 * the MI sys_process.c file.  This works only because
		 * we can access the child's md_regs pointer and it
		 * has the correct value (the child has already trapped
		 * into the kernel).
		 */
		if ((cp = pfind(SCARG(uap, pid))) == 0)
			return (ESRCH);
		SCARG(uap, addr) =
		    (int *)hpux_to_bsd_uoff(SCARG(uap, addr), &isps, cp);

		/*
		 * Since HP-UX PS is only 16-bits in ar0, requests
		 * to write PS actually contain the PS in the high word
		 * and the high half of the PC (the following register)
		 * in the low word.  Move the PS value to where BSD
		 * expects it.
		 */
		if (isps && SCARG(uap, req) == PT_WRITE_U)
			SCARG(uap, data) >>= 16;
		break;
#endif
	}

	error = sys_ptrace(p, uap, retval);
	/*
	 * Align PS as HP-UX expects it (see WRITE_U comment above).
	 * Note that we do not return the high part of PC like HP-UX
	 * would, but the HP-UX debuggers don't require it.
	 */
#ifdef PT_READ_U
	if (isps && error == 0 && SCARG(uap, req) == PT_READ_U)
		*retval <<= 16;
#endif
	return (error);
}

#endif	/* PTRACE */

#ifdef SYSVSHM
#include <sys/shm.h>

int
hpux_sys_shmctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_shmctl_args *uap = v;

	return (hpux_shmctl1(p, (struct hpux_sys_shmctl_args *)uap, retval, 0));
}

int
hpux_sys_nshmctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;	/* struct hpux_nshmctl_args * */
{
	struct hpux_sys_nshmctl_args *uap = v;

	return (hpux_shmctl1(p, (struct hpux_sys_shmctl_args *)uap, retval, 1));
}

/*
 * Handle HP-UX specific commands.
 */
int
hpux_shmctl1(p, uap, retval, isnew)
	struct proc *p;
	struct hpux_sys_shmctl_args *uap;
	register_t *retval;
	int isnew;
{
	struct shmid_ds *shp;
	struct ucred *cred = p->p_ucred;
	struct hpux_shmid_ds sbuf;
	int error;
	extern struct shmid_ds *shm_find_segment_by_shmid(int);

	if ((shp = shm_find_segment_by_shmid(SCARG(uap, shmid))) == NULL)
		return EINVAL;

	switch (SCARG(uap, cmd)) {
	case SHM_LOCK:
	case SHM_UNLOCK:
		/* don't really do anything, but make them think we did */
		if (cred->cr_uid && cred->cr_uid != shp->shm_perm.uid &&
		    cred->cr_uid != shp->shm_perm.cuid)
			return (EPERM);
		return (0);

	case IPC_STAT:
		if (!isnew)
			break;
		error = ipcperm(cred, &shp->shm_perm, IPC_R);
		if (error == 0) {
			sbuf.shm_perm.uid = shp->shm_perm.uid;
			sbuf.shm_perm.gid = shp->shm_perm.gid;
			sbuf.shm_perm.cuid = shp->shm_perm.cuid;
			sbuf.shm_perm.cgid = shp->shm_perm.cgid;
			sbuf.shm_perm.mode = shp->shm_perm.mode;
			sbuf.shm_perm.seq = shp->shm_perm.seq;
			sbuf.shm_perm.key = shp->shm_perm.key;
			sbuf.shm_segsz = shp->shm_segsz;
			sbuf.shm_ptbl = shp->shm_internal;	/* XXX */
			sbuf.shm_lpid = shp->shm_lpid;
			sbuf.shm_cpid = shp->shm_cpid;
			sbuf.shm_nattch = shp->shm_nattch;
			sbuf.shm_cnattch = shp->shm_nattch;	/* XXX */
			sbuf.shm_atime = shp->shm_atime;
			sbuf.shm_dtime = shp->shm_dtime;
			sbuf.shm_ctime = shp->shm_ctime;
			error = copyout((caddr_t)&sbuf, SCARG(uap, buf),
			    sizeof sbuf);
		}
		return (error);

	case IPC_SET:
		if (!isnew)
			break;
		if (cred->cr_uid && cred->cr_uid != shp->shm_perm.uid &&
		    cred->cr_uid != shp->shm_perm.cuid) {
			return (EPERM);
		}
		error = copyin(SCARG(uap, buf), (caddr_t)&sbuf, sizeof sbuf);
		if (error == 0) {
			shp->shm_perm.uid = sbuf.shm_perm.uid;
			shp->shm_perm.gid = sbuf.shm_perm.gid;
			shp->shm_perm.mode = (shp->shm_perm.mode & ~0777)
				| (sbuf.shm_perm.mode & 0777);
			shp->shm_ctime = time_second;
		}
		return (error);
	}
	return (sys_shmctl(p, uap, retval));
}
#endif

/*
 * HP-UX mmap() emulation (mainly for shared library support).
 */
int
hpux_sys_mmap(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_mmap_args *uap = v;
	struct sys_mmap_args /* {
		syscallarg(caddr_t) addr;
		syscallarg(size_t) len;
		syscallarg(int) prot;
		syscallarg(int) flags;
		syscallarg(int) fd;
		syscallarg(long) pad;
		syscallarg(off_t) pos;
	} */ nargs;

	SCARG(&nargs, addr) = SCARG(uap, addr);
	SCARG(&nargs, len) = SCARG(uap, len);
	SCARG(&nargs, prot) = SCARG(uap, prot);
	SCARG(&nargs, flags) = SCARG(uap, flags) &
		~(HPUXMAP_FIXED|HPUXMAP_REPLACE|HPUXMAP_ANON);
	if (SCARG(uap, flags) & HPUXMAP_FIXED)
		SCARG(&nargs, flags) |= MAP_FIXED;
	if (SCARG(uap, flags) & HPUXMAP_ANON)
		SCARG(&nargs, flags) |= MAP_ANON;
	SCARG(&nargs, fd) = (SCARG(&nargs, flags) & MAP_ANON) ? -1 : SCARG(uap, fd);
	SCARG(&nargs, pos) = SCARG(uap, pos);

	return (sys_mmap(p, &nargs, retval));
}

int
hpuxtobsdioctl(com)
	u_long com;
{
	switch (com) {
	case HPUXTIOCSLTC:
		com = TIOCSLTC; break;
	case HPUXTIOCGLTC:
		com = TIOCGLTC; break;
	case HPUXTIOCSPGRP:
		com = TIOCSPGRP; break;
	case HPUXTIOCGPGRP:
		com = TIOCGPGRP; break;
	case HPUXTIOCLBIS:
		com = TIOCLBIS; break;
	case HPUXTIOCLBIC:
		com = TIOCLBIC; break;
	case HPUXTIOCLSET:
		com = TIOCLSET; break;
	case HPUXTIOCLGET:
		com = TIOCLGET; break;
	case HPUXTIOCGWINSZ:
		com = TIOCGWINSZ; break;
	case HPUXTIOCSWINSZ:
		com = TIOCSWINSZ; break;
	}
	return(com);
}

/*
 * HP-UX ioctl system call.  The differences here are:
 *	IOC_IN also means IOC_VOID if the size portion is zero.
 *	no FIOCLEX/FIONCLEX/FIOASYNC/FIOGETOWN/FIOSETOWN
 *	the sgttyb struct is 2 bytes longer
 */
int
hpux_sys_ioctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_ioctl_args /* {
		syscallarg(int) fd;
		syscallarg(int) com;
		syscallarg(caddr_t) data;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	int com, error = 0;
	u_int size;
	caddr_t memp = 0;
#define STK_PARAMS	128
	char stkbuf[STK_PARAMS];
	caddr_t dt = stkbuf;

	com = SCARG(uap, com);

	/* XXX */
	if (com == HPUXTIOCGETP || com == HPUXTIOCSETP)
		return (getsettty(p, SCARG(uap, fd), com, SCARG(uap, data)));

	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return (EBADF);
	if ((fp->f_flag & (FREAD|FWRITE)) == 0)
		return (EBADF);

	/*
	 * Interpret high order word to find
	 * amount of data to be copied to/from the
	 * user's address space.
	 */
	size = IOCPARM_LEN(com);
	if (size > IOCPARM_MAX)
		return (ENOTTY);
	FREF(fp);
	if (size > sizeof (stkbuf)) {
		memp = (caddr_t)malloc((u_long)size, M_IOCTLOPS, M_WAITOK);
		dt = memp;
	}
	if (com&IOC_IN) {
		if (size) {
			error = copyin(SCARG(uap, data), dt, (u_int)size);
			if (error) {
				goto out;
			}
		} else
			*(caddr_t *)dt = SCARG(uap, data);
	} else if ((com&IOC_OUT) && size)
		/*
		 * Zero the buffer so the user always
		 * gets back something deterministic.
		 */
		bzero(dt, size);
	else if (com&IOC_VOID)
		*(caddr_t *)dt = SCARG(uap, data);

	switch (com) {

	case HPUXFIOSNBIO:
	{
		char *ofp = &fdp->fd_ofileflags[SCARG(uap, fd)];
		int tmp;

		if (*(int *)dt)
			*ofp |= HPUX_UF_FIONBIO_ON;
		else
			*ofp &= ~HPUX_UF_FIONBIO_ON;
		/*
		 * Only set/clear if O_NONBLOCK/FNDELAY not in effect
		 */
		if ((*ofp & (HPUX_UF_NONBLOCK_ON|HPUX_UF_FNDELAY_ON)) == 0) {
			tmp = *ofp & HPUX_UF_FIONBIO_ON;
			error = (*fp->f_ops->fo_ioctl)(fp, FIONBIO,
						       (caddr_t)&tmp, p);
		}
		break;
	}

	case HPUXTIOCCONS:
		*(int *)dt = 1;
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCCONS, dt, p);
		break;

	/* BSD-style job control ioctls */
	case HPUXTIOCLBIS:
	case HPUXTIOCLBIC:
	case HPUXTIOCLSET:
		*(int *)dt &= HPUXLTOSTOP;
		if (*(int *)dt & HPUXLTOSTOP)
			*(int *)dt = LTOSTOP;
		/* fall into */

	/* simple mapping cases */
	case HPUXTIOCLGET:
	case HPUXTIOCSLTC:
	case HPUXTIOCGLTC:
	case HPUXTIOCSPGRP:
	case HPUXTIOCGPGRP:
	case HPUXTIOCGWINSZ:
	case HPUXTIOCSWINSZ:
		error = (*fp->f_ops->fo_ioctl)
			(fp, hpuxtobsdioctl(com), dt, p);
		if (error == 0 && com == HPUXTIOCLGET) {
			*(int *)dt &= LTOSTOP;
			if (*(int *)dt & LTOSTOP)
				*(int *)dt = HPUXLTOSTOP;
		}
		break;

	/* SYS 5 termio and POSIX termios */
	case HPUXTCGETA:
	case HPUXTCSETA:
	case HPUXTCSETAW:
	case HPUXTCSETAF:
	case HPUXTCGETATTR:
	case HPUXTCSETATTR:
	case HPUXTCSETATTRD:
	case HPUXTCSETATTRF:
		error = hpux_termio(SCARG(uap, fd), com, dt, p);
		break;

	default:
		error = (*fp->f_ops->fo_ioctl)(fp, com, dt, p);
		break;
	}
	/*
	 * Copy any data to user, size was
	 * already set and checked above.
	 */
	if (error == 0 && (com&IOC_OUT) && size)
		error = copyout(dt, SCARG(uap, data), (u_int)size);

out:
	FRELE(fp);
	if (memp)
		free(memp, M_IOCTLOPS);
	return (error);
}

/* hpux_sys_getcontext() is found in hpux_machdep.c */

/*
 * This is the equivalent of BSD setpgrp but with more restrictions.
 * Note we do not check the real uid or "saved" uid or pgrp.
 */
int
hpux_sys_setpgrp2(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_setpgrp2_args *uap = v;

	/* empirically determined */
	if (SCARG(uap, pgid) < 0 || SCARG(uap, pgid) >= 30000)
		return (EINVAL);
	return (sys_setpgid(p, uap, retval));
}

int
hpux_sys_getrlimit(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_getrlimit_args *uap = v;
	struct compat_43_sys_getrlimit_args ap;

	if (SCARG(uap, which) > HPUXRLIMIT_NOFILE)
		return (EINVAL);
	if (SCARG(uap, which) == HPUXRLIMIT_NOFILE)
		SCARG(uap, which) = RLIMIT_NOFILE;

	SCARG(&ap, which) = SCARG(uap, which);
	SCARG(&ap, rlp) = SCARG(uap, rlp);

	return (compat_43_sys_getrlimit(p, uap, retval));
}

int
hpux_sys_setrlimit(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_setrlimit_args *uap = v;
	struct compat_43_sys_setrlimit_args ap;

	if (SCARG(uap, which) > HPUXRLIMIT_NOFILE)
		return (EINVAL);
	if (SCARG(uap, which) == HPUXRLIMIT_NOFILE)
		SCARG(uap, which) = RLIMIT_NOFILE;

	SCARG(&ap, which) = SCARG(uap, which);
	SCARG(&ap, rlp) = SCARG(uap, rlp);

	return (compat_43_sys_setrlimit(p, uap, retval));
}

/*
 * XXX: simple recognition hack to see if we can make grmd work.
 */
int
hpux_sys_lockf(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	/* struct hpux_sys_lockf_args *uap = v; */

	return (0);
}


#ifndef __hppa__
int
hpux_sys_getaccess(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_getaccess_args *uap = v;
	int lgroups[NGROUPS];
	int error = 0;
	struct ucred *cred;
	struct vnode *vp;
	struct nameidata nd;

	/*
	 * Build an appropriate credential structure
	 */
	cred = crdup(p->p_ucred);
	switch (SCARG(uap, uid)) {
	case 65502:	/* UID_EUID */
		break;
	case 65503:	/* UID_RUID */
		cred->cr_uid = p->p_cred->p_ruid;
		break;
	case 65504:	/* UID_SUID */
		error = EINVAL;
		break;
	default:
		if (SCARG(uap, uid) > 65504)
			error = EINVAL;
		cred->cr_uid = SCARG(uap, uid);
		break;
	}
	switch (SCARG(uap, ngroups)) {
	case -1:	/* NGROUPS_EGID */
		cred->cr_ngroups = 1;
		break;
	case -5:	/* NGROUPS_EGID_SUPP */
		break;
	case -2:	/* NGROUPS_RGID */
		cred->cr_ngroups = 1;
		cred->cr_gid = p->p_cred->p_rgid;
		break;
	case -6:	/* NGROUPS_RGID_SUPP */
		cred->cr_gid = p->p_cred->p_rgid;
		break;
	case -3:	/* NGROUPS_SGID */
	case -7:	/* NGROUPS_SGID_SUPP */
		error = EINVAL;
		break;
	case -4:	/* NGROUPS_SUPP */
		if (cred->cr_ngroups > 1)
			cred->cr_gid = cred->cr_groups[1];
		else
			error = EINVAL;
		break;
	default:
		if (SCARG(uap, ngroups) > 0 && SCARG(uap, ngroups) <= NGROUPS)
			error = copyin((caddr_t)SCARG(uap, gidset),
				       (caddr_t)&lgroups[0],
				       SCARG(uap, ngroups) *
					   sizeof(lgroups[0]));
		else
			error = EINVAL;
		if (error == 0) {
			int gid;

			for (gid = 0; gid < SCARG(uap, ngroups); gid++)
				cred->cr_groups[gid] = lgroups[gid];
			cred->cr_ngroups = SCARG(uap, ngroups);
		}
		break;
	}
	/*
	 * Lookup file using caller's effective IDs.
	 */
	if (error == 0) {
		NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
			SCARG(uap, path), p);
		error = namei(&nd);
	}
	if (error) {
		crfree(cred);
		return (error);
	}
	/*
	 * Use the constructed credentials for access checks.
	 */
	vp = nd.ni_vp;
	*retval = 0;
	if (VOP_ACCESS(vp, VREAD, cred, p) == 0)
		*retval |= R_OK;
	if (vn_writechk(vp) == 0 && VOP_ACCESS(vp, VWRITE, cred, p) == 0)
		*retval |= W_OK;
	if (VOP_ACCESS(vp, VEXEC, cred, p) == 0)
		*retval |= X_OK;
	vput(vp);
	crfree(cred);
	return (error);
}
#endif

/*
 * Ancient HP-UX system calls.  Some 9.x executables even use them!
 */
#define HPUX_HZ	50

#include <sys/times.h>


/*
 * SYS V style setpgrp()
 */
int
hpux_sys_setpgrp_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct pgrp *npgrp;

	npgrp = pool_get(&pgrp_pool, PR_WAITOK);

	if (p->p_pid != p->p_pgid)
		enterpgrp(p, p->p_pid, npgrp, NULL);
	*retval = p->p_pgid;
	return (0);
}

int
hpux_sys_time_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_time_6x_args /* {
		syscallarg(time_t *) t;
	} */ *uap = v;
	int error = 0;
	struct timeval tv;

	microtime(&tv);
        if (SCARG(uap, t) != NULL)
		error = copyout(&tv.tv_sec, SCARG(uap, t), sizeof(time_t));

	*retval = (register_t)tv.tv_sec;
	return (error);
}

int
hpux_sys_stime_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_stime_6x_args /* {
		syscallarg(int) time;
	} */ *uap = v;
	struct timespec ts;
	int error;

	ts.tv_sec = SCARG(uap, time);
	ts.tv_nsec = 0;
	if ((error = suser(p, 0)))
		return (error);

	settime(&ts);

	return (0);
}

int
hpux_sys_ftime_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_ftime_6x_args /* {
		syscallarg(struct hpux_timeb *) tp;
	} */ *uap = v;
	struct hpux_otimeb tb;
	struct timeval tv;

	microtime(&tv);
	tb.time = tv.tv_sec;
	tb.millitm = tv.tv_usec / 1000;
	tb.timezone = tz.tz_minuteswest;
	tb.dstflag = tz.tz_dsttime;
	return (copyout((caddr_t)&tb, (caddr_t)SCARG(uap, tp), sizeof (tb)));
}

int
hpux_sys_alarm_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_alarm_6x_args /* {
		syscallarg(int) deltat;
	} */ *uap = v;
	int timo;
	struct timeval tv, atv;

	timeout_del(&p->p_realit_to);
	timerclear(&p->p_realtimer.it_interval);
	*retval = 0;
	getmicrouptime(&tv);
	if (timerisset(&p->p_realtimer.it_value) &&
	    timercmp(&p->p_realtimer.it_value, &tv, >))
		*retval = p->p_realtimer.it_value.tv_sec - tv.tv_sec;
	if (SCARG(uap, deltat) == 0) {
		timerclear(&p->p_realtimer.it_value);
		return (0);
	}
	atv.tv_sec = SCARG(uap, deltat);
	atv.tv_usec = 0;
	p->p_realtimer.it_value = tv;
	p->p_realtimer.it_value.tv_sec += SCARG(uap, deltat);
	timo = tvtohz(&atv);
	if (timo <= 0)
		timo = 1;
	timeout_add(&p->p_realit_to, timo);
	return (0);
}

int
hpux_sys_nice_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_nice_6x_args /* {
		syscallarg(int) nval;
	} */ *uap = v;
	int error;

	error = donice(p, p, (p->p_nice-NZERO)+SCARG(uap, nval));
	if (error == 0)
		*retval = p->p_nice - NZERO;
	return (error);
}

int
hpux_sys_times_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_times_6x_args /* {
		syscallarg(struct tms *) tms;
	} */ *uap = v;
	struct timeval ru, rs;
	struct tms atms;
	int error;

	calcru(p, &ru, &rs, NULL);
	atms.tms_utime = hpux_scale(&ru);
	atms.tms_stime = hpux_scale(&rs);
	atms.tms_cutime = hpux_scale(&p->p_stats->p_cru.ru_utime);
	atms.tms_cstime = hpux_scale(&p->p_stats->p_cru.ru_stime);
	error = copyout((caddr_t)&atms, (caddr_t)SCARG(uap, tms),
	    sizeof (atms));
	if (error == 0) {
		struct timeval tv;
		getmicrouptime(&tv);
		*(time_t *)retval = hpux_scale(&tv);
	}
	return (error);
}

/*
 * Doesn't exactly do what the documentation says.
 * What we really do is return 1/HPUX_HZ-th of a second since that
 * is what HP-UX returns.
 */
static int
hpux_scale(tvp)
	struct timeval *tvp;
{
	return (tvp->tv_sec * HPUX_HZ + tvp->tv_usec * HPUX_HZ / 1000000);
}

/*
 * Set IUPD and IACC times on file.
 * Can't set ICHG.
 */
int
hpux_sys_utime_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_utime_6x_args /* {
		syscallarg(char *) fname;
		syscallarg(time_t *) tptr;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	time_t tv[2];
	int error;
	struct nameidata nd;

	if (SCARG(uap, tptr)) {
		error = copyin((caddr_t)SCARG(uap, tptr), (caddr_t)tv,
		    sizeof (tv));
		if (error)
			return (error);
	} else
		tv[0] = tv[1] = time_second;
	vattr_null(&vattr);
	vattr.va_atime.tv_sec = tv[0];
	vattr.va_atime.tv_nsec = 0;
	vattr.va_mtime.tv_sec = tv[1];
	vattr.va_mtime.tv_nsec = 0;
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, fname), p);
	if ((error = namei(&nd)))
		return (error);
	vp = nd.ni_vp;
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else
		error = VOP_SETATTR(vp, &vattr, nd.ni_cnd.cn_cred, p);
	vput(vp);
	return (error);
}

int
hpux_sys_pause_6x(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_sigsuspend_args bsa;

	SCARG(&bsa, mask) = p->p_sigmask;
	return (sys_sigsuspend(p, &bsa, retval));
}
@


1.33
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.32 2010/01/28 19:59:07 miod Exp $	*/
@


1.32
log
@HP-UX getpgrp2() is documented as returning the same value than getpgid(),
with the same error conditions. So reimplement it as the real thing.
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.31 2010/01/28 19:23:06 guenther Exp $	*/
d69 1
a69 1
#include <sys/user.h>
@


1.31
log
@Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.30 2008/11/01 05:59:21 deraadt Exp $	*/
a948 31

/*
 * This is the equivalent of BSD getpgrp but with more restrictions.
 * XXX Need to verify the differences between this and sys_getpgid()
 */
int
hpux_sys_getpgrp2(cp, v, retval)
	struct proc *cp;
	void *v;
	register_t *retval;
{
	struct hpux_sys_getpgrp2_args *uap = v;
	struct proc *p;

	/* If zero, the call applies to the calling process */
	if (SCARG(uap, pid) == 0)
		p = cp;
	else
		p = pfind(SCARG(uap, pid));
	if (p == NULL)
		return (ESRCH);
	/* Skip exiting processes. */
	if (p->p_pgrp->pg_session->s_leader == NULL)
		return (ESRCH);
	/* Both processes need to be in the same session. */
	if (cp != p && cp->p_pgrp->pg_session->s_leader->p_pid !=
	    p->p_pgrp->pg_session->s_leader->p_pid)
		return (EPERM);
	*retval = p->p_pgid;
	return (0);
}
@


1.30
log
@change all callers of enterpgrp() to pre-allocate a pgrp or session if
it might be needed later -- before calling pfind(), so that enterpgrp()
can operate without sleeping
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.29 2007/09/22 09:57:40 martin Exp $	*/
d952 1
a952 1
 * Note we do not check the real uid or "saved" uid.
d963 1
d965 7
a971 3
		SCARG(uap, pid) = cp->p_pid;
	p = pfind(SCARG(uap, pid));
	if (p == 0)
d973 3
a975 2
	if (cp->p_ucred->cr_uid && p->p_ucred->cr_uid != cp->p_ucred->cr_uid &&
	    !inferior(p))
@


1.30.2.1
log
@Merge from -current:

----
Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
----

Requested by guenther@@. The hpux_compat change here is more
conservative than committed to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.30 2008/11/01 05:59:21 deraadt Exp $	*/
d969 1
a969 1
	    !inferior(p, cp))
@


1.30.6.1
log
@Merge from -current:

----
Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
----

Requested by guenther@@. The hpux_compat change here is more
conservative than committed to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.30 2008/11/01 05:59:21 deraadt Exp $	*/
d969 1
a969 1
	    !inferior(p, cp))
@


1.29
log
@replace even more ctob and btoc with ptoa and atop respectively plus
uvm_extern.h where needed
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.28 2004/07/09 21:33:44 mickey Exp $	*/
d66 1
d1167 3
d1172 1
a1172 1
		enterpgrp(p, p->p_pid, 0);
@


1.28
log
@split off the m68k-specific parts
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.27 2004/06/24 19:35:23 tholo Exp $	*/
d492 1
a492 1
		*retval = ctob(p->p_vmspace->vm_tsize) + limp->rlim_max;
@


1.27
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.26 2004/06/22 23:52:17 jfb Exp $	*/
d1046 2
d1147 1
a1147 2

/* hpux_to_bsd_uoff() is found in hpux_machdep.c */
@


1.26
log
@Replace a whole bunch of scary uses of strncpy() with strlcpy() and
use compat-specific MAXNAMLEN values where appropriate

ok millert@@, pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.25 2004/06/21 23:50:35 tholo Exp $	*/
d1201 2
a1202 2
	struct timeval tv;
	int s, error;
d1204 2
a1205 2
	tv.tv_sec = SCARG(uap, time);
	tv.tv_usec = 0;
d1209 2
a1210 4
	/* WHAT DO WE DO ABOUT PENDING REAL-TIME TIMEOUTS??? */
	boottime.tv_sec += tv.tv_sec - time.tv_sec;
	s = splhigh(); time = tv; splx(s);
	resettodr();
d1224 1
a1224 1
	int s;
d1226 3
a1228 4
	s = splhigh();
	tb.time = time.tv_sec;
	tb.millitm = time.tv_usec / 1000;
	splx(s);
a1242 1
	int s = splhigh();
d1244 1
d1249 1
d1251 2
a1252 2
	    timercmp(&p->p_realtimer.it_value, &time, >))
		*retval = p->p_realtimer.it_value.tv_sec - time.tv_sec;
a1254 1
		splx(s);
d1257 3
a1259 1
	p->p_realtimer.it_value = time;
d1261 1
a1261 1
	timo = hzto(&p->p_realtimer.it_value);
a1264 1
	splx(s);
d1305 5
a1309 3
	if (error == 0)
		*(time_t *)retval = hpux_scale((struct timeval *)&time) -
		    hpux_scale(&boottime);
@


1.25
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.24 2003/08/15 20:32:15 tedu Exp $	*/
d395 1
a395 2
		strncpy(ut.sysname, ostype, sizeof(ut.sysname));
		ut.sysname[sizeof(ut.sysname) - 1] = '\0';
d402 3
a404 8
		strncpy(ut.release, osrelease, sizeof(ut.release));
		ut.release[sizeof(ut.release) - 1] = '\0';

		strncpy(ut.version, version, sizeof(ut.version));
		ut.version[sizeof(ut.version) - 1] = '\0';

		strncpy(ut.machine, machine, sizeof(ut.machine));
		ut.machine[sizeof(ut.machine) - 1] = '\0';
@


1.24
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.23 2003/06/02 23:28:00 millert Exp $	*/
d731 1
a731 1
			shp->shm_ctime = time.tv_sec;
d1357 1
a1357 1
		tv[0] = tv[1] = time.tv_sec;
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.22 2003/01/09 22:27:11 miod Exp $	*/
d487 1
a487 1
		    (error = suser(p->p_ucred, &p->p_acflag)))
d1212 1
a1212 1
	if ((error = suser(p->p_ucred, &p->p_acflag)))
@


1.22
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.21 2002/10/30 20:10:48 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.21
log
@Now that we have [gs]etres[ug]id() as a native system call, use it
for HP-UX, FreeBSD, and Linux emulations.  Note that Linux has two
versions of these system calls.  One for 16bit uids and another for
32bit uids.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.20 2002/08/02 18:06:25 millert Exp $	*/
d259 4
a262 1
		rv = fuword((caddr_t)SCARG(uap, status));
d272 1
a272 1
		(void)suword((caddr_t)SCARG(uap, status), rv);
@


1.20
log
@More possible int overflows found by Silvio Cesare.
ibcs2_stat.c one OK by provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.19 2002/03/14 20:31:31 mickey Exp $	*/
a996 25
}

/*
 * XXX Same as BSD setre[ug]id right now.  Need to consider saved ids.
 */
int
hpux_sys_setresuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_setresuid_args *uap = v;

	return (compat_43_sys_setreuid(p, uap, retval));
}

int
hpux_sys_setresgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_setresgid_args *uap = v;

	return (compat_43_sys_setregid(p, uap, retval));
@


1.19
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.18 2002/03/14 01:26:49 millert Exp $	*/
d420 8
a427 4
		if (SCARG(uap, dev) > hostnamelen + 1)
			SCARG(uap, dev) = hostnamelen + 1;
		error = copyout((caddr_t)hostname, (caddr_t)SCARG(uap, uts),
				SCARG(uap, dev));
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.17 2002/03/14 00:42:25 miod Exp $	*/
d389 1
a389 2
	extern char ostype[], hostname[], osrelease[], version[];
	extern char machine[];
@


1.17
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.16 2002/02/13 19:08:06 art Exp $	*/
d115 3
a117 3
int	hpux_shmctl1 __P((struct proc *, struct hpux_sys_shmctl_args *,
	    register_t *, int));
int	hpuxtobsdioctl __P((u_long));
d119 1
a119 1
static int	hpux_scale __P((struct timeval *));
d676 1
a676 1
	extern struct shmid_ds *shm_find_segment_by_shmid __P((int));
@


1.16
log
@More FREF/FRELE on relevant places. Now, only sys_mmap and a bunch of ioctl functions in sys/compat are left.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.15 2001/11/05 19:47:03 art Exp $	*/
d556 2
d634 2
@


1.15
log
@blink-matching-paren should be default in mg
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.14 2001/10/26 12:03:27 art Exp $	*/
d842 1
d851 1
a851 3
				if (memp)
					free(memp, M_IOCTLOPS);
				return (error);
d939 3
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.15 2001/11/05 19:47:03 art Exp $	*/
d115 3
a117 3
int	hpux_shmctl1(struct proc *, struct hpux_sys_shmctl_args *,
	    register_t *, int);
int	hpuxtobsdioctl(u_long);
d119 1
a119 1
static int	hpux_scale(struct timeval *);
d389 2
a390 1
	extern char hostname[], machine[];
a555 2
#ifdef PTRACE

a632 2
#endif	/* PTRACE */

d672 1
a672 1
	extern struct shmid_ds *shm_find_segment_by_shmid(int);
a841 1
	FREF(fp);
d850 3
a852 1
				goto out;
a939 3

out:
	FRELE(fp);
@


1.15.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.15.2.1 2002/06/11 03:28:07 art Exp $	*/
d420 4
a423 8
		i = SCARG(uap, dev);
		if (i < 0) {
			error = EINVAL;
			break;
		}
		if (i > hostnamelen + 1)
			i = hostnamelen + 1;
		error = copyout((caddr_t)hostname, (caddr_t)SCARG(uap, uts), i);
@


1.15.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d259 1
a259 4
		if ((error = copyin((caddr_t)SCARG(uap, status), &rv,
		    sizeof(int))) != 0)
			return error;

d269 1
a269 1
		error = copyout(&rv, (caddr_t)SCARG(uap, status), sizeof(int));
d997 25
@


1.14
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.13 2001/10/10 23:43:44 art Exp $	*/
d829 1
a829 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd)) == NULL)
@


1.13
log
@Don't roll our own dup, we cen use the standard one.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.12 2000/08/24 10:41:51 art Exp $	*/
d829 1
a829 2
	if (((unsigned)SCARG(uap, fd)) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
@


1.12
log
@Be careful about hzto returning <= 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.11 2000/06/26 16:22:11 art Exp $	*/
a376 30
}

/*
 * 4.3bsd dup allows dup2 to come in on the same syscall entry
 * and hence allows two arguments.  HP-UX dup has only one arg.
 */
int
hpux_sys_dup(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_dup_args *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	int fd, error;

	if (((unsigned)SCARG(uap, fd)) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
		return (EBADF);
	if ((error = fdalloc(p, 0, &fd)))
		return (error);
	fdp->fd_ofiles[fd] = fp;
	fdp->fd_ofileflags[fd] =
	    fdp->fd_ofileflags[SCARG(uap, fd)] &~ UF_EXCLOSE;
	fp->f_count++;
	if (fd > fdp->fd_lastfile)
		fdp->fd_lastfile = fd;
	*retval = fd;
	return (0);
@


1.11
log
@use new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.10 1997/07/06 07:27:59 downsj Exp $	*/
d1301 1
d1316 4
a1319 1
	timeout_add(&p->p_realit_to, hzto(&p->p_realtimer.it_value));
@


1.10
log
@sync with NetBSD, 970705.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.9 1997/04/16 09:18:02 downsj Exp $	*/
d1302 1
a1302 1
	untimeout(realitexpire, (caddr_t)p);
d1315 1
a1315 1
	timeout(realitexpire, (caddr_t)p, hzto(&p->p_realtimer.it_value));
@


1.10.12.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.12 2000/08/24 10:41:51 art Exp $	*/
a1300 1
	int timo;
d1302 1
a1302 1
	timeout_del(&p->p_realit_to);
d1315 1
a1315 4
	timo = hzto(&p->p_realtimer.it_value);
	if (timo <= 0)
		timo = 1;
	timeout_add(&p->p_realit_to, timo);
@


1.10.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.10.12.1 2001/05/14 22:04:29 niklas Exp $	*/
d379 30
d859 2
a860 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd)) == NULL)
@


1.10.12.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d829 1
a829 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
@


1.10.12.4
log
@Merge in trunk
@
text
@a841 1
	FREF(fp);
d850 3
a852 1
				goto out;
a939 3

out:
	FRELE(fp);
@


1.10.12.5
log
@Merge in -current from about a week ago
@
text
@d115 3
a117 3
int	hpux_shmctl1(struct proc *, struct hpux_sys_shmctl_args *,
	    register_t *, int);
int	hpuxtobsdioctl(u_long);
d119 1
a119 1
static int	hpux_scale(struct timeval *);
d389 2
a390 1
	extern char hostname[], machine[];
a555 2
#ifdef PTRACE

a632 2
#endif	/* PTRACE */

d672 1
a672 1
	extern struct shmid_ds *shm_find_segment_by_shmid(int);
@


1.10.12.6
log
@Sync the SMP branch with 3.3
@
text
@d259 1
a259 4
		if ((error = copyin((caddr_t)SCARG(uap, status), &rv,
		    sizeof(int))) != 0)
			return error;

d269 1
a269 1
		error = copyout(&rv, (caddr_t)SCARG(uap, status), sizeof(int));
d420 4
a423 8
		i = SCARG(uap, dev);
		if (i < 0) {
			error = EINVAL;
			break;
		}
		if (i > hostnamelen + 1)
			i = hostnamelen + 1;
		error = copyout((caddr_t)hostname, (caddr_t)SCARG(uap, uts), i);
d993 25
@


1.10.12.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.10.12.6 2003/03/27 23:53:47 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10.12.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d487 1
a487 1
		    (error = suser(p, 0)))
d1212 1
a1212 1
	if ((error = suser(p, 0)))
@


1.9
log
@Changes up to NetBSD 970415.
@
text
@d1 2
a2 2
/*	$OpenBSD: hpux_compat.c,v 1.8 1997/03/26 08:11:04 downsj Exp $	*/
/*	$NetBSD: hpux_compat.c,v 1.31 1997/04/01 19:58:59 scottr Exp $	*/
d420 1
d441 2
a442 2
		/* Fill in machine-dependent part of uname. */
		hpux_cpu_uname(&ut);
a1192 1
	/* XXX we return X_OK for root on VREG even if not */
@


1.8
log
@Merge in NetBSD changes as if 3/19/97, undo some of ours.
@
text
@d1 2
a2 2
/*	$OpenBSD: hpux_compat.c,v 1.7 1997/02/23 21:40:55 downsj Exp $	*/
/*	$NetBSD: hpux_compat.c,v 1.30 1997/03/16 10:13:12 thorpej Exp $	*/
d83 1
d115 5
a119 1
static	int hpux_scale __P((struct timeval *));
d130 1
a130 1
	struct hpux_sys_fork_args *uap = v;
d145 1
a145 1
	struct hpux_sys_vfork_args *uap = v;
d182 1
a182 1
	register struct proc *p;
d186 1
a186 1
	register struct hpux_sys_wait_args *uap = v;
d389 2
a390 2
	register struct hpux_sys_dup_args *uap = v;
	register struct filedesc *fdp = p->p_fd;
d397 1
a397 1
	if (error = fdalloc(p, 0, &fd))
d415 2
a416 2
	register struct hpux_sys_utssys_args *uap = v;
	register int i;
d419 1
a419 1
	extern char ostype[], hostname[], osrelease[], version[], machine[];
d505 1
a505 1
	register struct hpux_sys_ulimit_args *uap = v;
d545 1
a545 1
	register struct hpux_sys_rtprio_args *uap = v;
d592 3
a594 1
	int error, isps = 0;
d596 1
d673 1
a673 1
	return (hpux_shmctl1(p, (struct hpux_shmctl_args *) uap, retval, 0));
d684 1
a684 1
	return (hpux_shmctl1(p, (struct hpux_shmctl_args *) uap, retval, 1));
d697 2
a698 2
	register struct shmid_ds *shp;
	register struct ucred *cred = p->p_ucred;
d838 1
a838 1
	register struct hpux_sys_ioctl_args /* {
d843 4
a846 4
	register struct filedesc *fdp = p->p_fd;
	register struct file *fp;
	register int com, error;
	register u_int size;
d987 2
a988 2
	register struct hpux_sys_getpgrp2_args *uap = v;
	register struct proc *p;
d1094 1
a1094 1
	struct hpux_sys_lockf_args *uap = v;
d1101 1
a1101 1
	register struct proc *p;
d1105 1
a1105 1
	register struct hpux_sys_getaccess_args *uap = v;
d1108 2
a1109 2
	register struct ucred *cred;
	register struct vnode *vp;
d1215 1
a1215 1
	register struct proc *p;
d1260 1
a1260 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d1293 1
a1293 1
	register struct proc *p;
d1322 1
a1322 1
	register struct proc *p;
d1370 1
a1370 1
	register struct timeval *tvp;
d1389 1
a1389 1
	register struct vnode *vp;
d1409 1
a1409 1
	if (error = namei(&nd))
@


1.7
log
@sigcode -> hpux_sigcode
@
text
@d1 2
a2 2
/*	$OpenBSD: hpux_compat.c,v 1.6 1997/01/27 00:00:03 downsj Exp $	*/
/*	$NetBSD: hpux_compat.c,v 1.23 1996/01/06 12:44:11 thorpej Exp $	*/
d110 1
a110 1
extern char hpux_sigcode[], hpux_esigcode[];
a1192 2

/* hpux_dumpu() is found in hpux_machdep.c */
@


1.6
log
@__mc68k__ -> m68k
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.5 1996/08/02 20:34:53 niklas Exp $	*/
d110 1
a110 1
extern char sigcode[], esigcode[];
@


1.5
log
@Added Makefiles to build stuff from syscalls.master in some emulations.
Regenerated derived files from various syscalls.master files. Added $OpenBSD$.
@
text
@d1 1
a1 1
/*	$OpenBSD: hpux_compat.c,v 1.23 1996/01/06 12:44:11 thorpej Exp $	*/
d166 1
a166 1
#if __mc68k__
@


1.4
log
@s/ts_/tv_/g again.
@
text
@d1 1
@


1.3
log
@from netbsd:
Move the obviously machine-dependent HP-UX compat code to hpux_machdep.{c,h}.
A fair bit of this, the m68k core dump and exec goo, can probably be
made into a generic m68k hpux module, eventually.
@
text
@d1396 4
a1399 4
	vattr.va_atime.ts_sec = tv[0];
	vattr.va_atime.ts_nsec = 0;
	vattr.va_mtime.ts_sec = tv[1];
	vattr.va_mtime.ts_nsec = 0;
@


1.2
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: hpux_compat.c,v 1.22 1995/12/09 04:05:52 mycroft Exp $	*/
d87 2
a92 13
/* 6.0 and later style context */
#if defined(HP380)
char hpux_040context[] =
    "standalone HP-MC68040 HP-MC68881 HP-MC68020 HP-MC68010 localroot default";
#endif
#ifdef FPCOPROC
char hpux_context[] =
	"standalone HP-MC68881 HP-MC68020 HP-MC68010 localroot default";
#else
char hpux_context[] =
	"standalone HP-MC68020 HP-MC68010 localroot default";
#endif

a402 3
/*
 * XXX: This belongs in hpux_machdep.c !!
 */
d434 2
a435 41
		strncpy(ut.machine, "9000/3?0", sizeof(ut.machine));
		ut.machine[sizeof(ut.machine) - 1] = '\0';

		/* fill in machine type */
#ifdef HP_320
		switch (machineid) {
		case HP_320:
			ut.machine[6] = '2';
			break;
		/* includes 318 and 319 */
		case HP_330:
			ut.machine[6] = '3';
			break;
		case HP_340:
			ut.machine[6] = '4';
			break;
		case HP_350:
			ut.machine[6] = '5';
			break;
		case HP_360:
			ut.machine[6] = '6';
			break;
		case HP_370:
			ut.machine[6] = '7';
			break;
		/* includes 345 */
		case HP_375:
			ut.machine[6] = '7';
			ut.machine[7] = '5';
			break;
		/* includes 425 */
		case HP_380:
			ut.machine[6] = '8';
			break;
		case HP_433:
			ut.machine[5] = '4';
			ut.machine[6] = '3';
			ut.machine[7] = '3';
			break;
		}
#endif
a460 3
/*
 * XXX: This belongs in hpux_machdep.c !!
 */
d482 1
a482 21
#ifdef HP_320
		switch (machineid) {
		case HP_320:
		case HP_330:
		case HP_350:
			*retval = HPUX_SYSCONF_CPUM020;
			break;
		case HP_340:
		case HP_360:
		case HP_370:
		case HP_375:
			*retval = HPUX_SYSCONF_CPUM030;
			break;
		case HP_380:
		case HP_433:
			*retval = HPUX_SYSCONF_CPUM040;
			break;
		}
#else
		*retval = HPUX_SYSCONF_CPUM020;
#endif
d485 1
d577 1
a577 30
/*
 * XXX: This belongs in hpux_machdep.c !!
 */
int
hpux_sys_advise(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_advise_args *uap = v;
	int error = 0;

#ifdef hp300
	switch (SCARG(uap, arg)) {
	case 0:
		p->p_md.md_flags |= MDP_HPUXMMAP;
		break;
	case 1:
		ICIA();
		break;
	case 2:
		DCIA();
		break;
	default:
		error = EINVAL;
		break;
	}
#endif
	return (error);
}
d614 1
a614 1
		 * Big, cheezy hack: hpuxtobsduoff is really intended
d625 1
a625 1
		    (int *)hpuxtobsduoff(SCARG(uap, addr), &isps, cp);
d829 5
a833 1
	register struct hpux_sys_ioctl_args *uap = v;
a844 1
#ifdef COMPAT_HPUX_6X
a847 1
#endif
d966 1
a966 33
/*
 * XXX: This should be in hpux_machdep.c !!
 */
/*
 * Man page lies, behaviour here is based on observed behaviour.
 */
int
hpux_sys_getcontext(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_getcontext_args *uap = v;
	int error = 0;
	register int len;

#ifdef HP380
	if (machineid == HP_380) {
		len = min(SCARG(uap, len), sizeof(hpux_040context));
		if (len)
			error = copyout(hpux_040context, SCARG(uap, buf), len);
		if (error == 0)
			*retval = sizeof(hpux_040context);
		return (error);
	}
#endif
	len = min(SCARG(uap, len), sizeof(hpux_context));
	if (len)
		error = copyout(hpux_context, SCARG(uap, buf), (u_int)len);
	if (error == 0)
		*retval = sizeof(hpux_context);
	return (error);
}
d1191 1
a1191 113
/*
 * XXX: This needs to be in hpux_machdep.c !!
 */
#define UOFF(f)		((int)&((struct user *)0)->f)
#define HPUOFF(f)	((int)&((struct hpux_user *)0)->f)

/* simplified FP structure */
struct bsdfp {
	int save[54];
	int reg[24];
	int ctrl[3];
};

/*
 * Brutal hack!  Map HP-UX u-area offsets into BSD k-stack offsets.
 *
 * XXX move to hpux_machdep.c
 */
int
hpuxtobsduoff(off, isps, p)
	int *off, *isps;
	struct proc *p;
{
#ifdef hp300
	register int *ar0 = p->p_md.md_regs;
	struct hpux_fp *hp;
	struct bsdfp *bp;
	register u_int raddr;

	*isps = 0;

	/* u_ar0 field; procxmt puts in U_ar0 */
	if ((int)off == HPUOFF(hpuxu_ar0))
		return(UOFF(U_ar0));

#ifdef FPCOPROC
	/* FP registers from PCB */
	hp = (struct hpux_fp *)HPUOFF(hpuxu_fp);
	bp = (struct bsdfp *)UOFF(u_pcb.pcb_fpregs);
	if (off >= hp->hpfp_ctrl && off < &hp->hpfp_ctrl[3])
		return((int)&bp->ctrl[off - hp->hpfp_ctrl]);
	if (off >= hp->hpfp_reg && off < &hp->hpfp_reg[24])
		return((int)&bp->reg[off - hp->hpfp_reg]);
#endif

	/*
	 * Everything else we recognize comes from the kernel stack,
	 * so we convert off to an absolute address (if not already)
	 * for simplicity.
	 */
	if (off < (int *)ctob(UPAGES))
		off = (int *)((u_int)off + (u_int)p->p_addr);	/* XXX */

	/*
	 * General registers.
	 * We know that the HP-UX registers are in the same order as ours.
	 * The only difference is that their PS is 2 bytes instead of a
	 * padded 4 like ours throwing the alignment off.
	 */
	if (off >= ar0 && off < &ar0[18]) {
		/*
		 * PS: return low word and high word of PC as HP-UX would
		 * (e.g. &u.u_ar0[16.5]).
		 *
		 * XXX we don't do this since HP-UX adb doesn't rely on
		 * it and passing such an offset to procxmt will cause
		 * it to fail anyway.  Instead, we just set the offset
		 * to PS and let hpux_ptrace() shift up the value returned.
		 */
		if (off == &ar0[PS]) {
#if 0
			raddr = (u_int) &((short *)ar0)[PS*2+1];
#else
			raddr = (u_int) &ar0[(int)(off - ar0)];
#endif
			*isps = 1;
		}
		/*
		 * PC: off will be &u.u_ar0[16.5] since HP-UX saved PS
		 * is only 16 bits.
		 */
		else if (off == (int *)&(((short *)ar0)[PS*2+1]))
			raddr = (u_int) &ar0[PC];
		/*
		 * D0-D7, A0-A7: easy
		 */
		else
			raddr = (u_int) &ar0[(int)(off - ar0)];
		return((int)(raddr - (u_int)p->p_addr));	/* XXX */
	}
#endif
	/* everything else */
	return(-1);
}

/*
 * Kludge up a uarea dump so that HP-UX debuggers can find out
 * what they need.  IMPORTANT NOTE: we do not EVEN attempt to
 * convert the entire user struct.
 *
 * XXX move to hpux_machdep.c
 */
int
hpux_dumpu(vp, cred)
	struct vnode *vp;
	struct ucred *cred;
{
	int error = 0;
#ifdef hp300
	struct proc *p = curproc;
	struct hpux_user *faku;
	struct bsdfp *bp;
	short *foop;
d1193 1
a1193 65
	faku = (struct hpux_user *)malloc((u_long)ctob(1), M_TEMP, M_WAITOK);
	/*
	 * Make sure there is no mistake about this
	 * being a real user structure.
	 */
	bzero((caddr_t)faku, ctob(1));
	/*
	 * Fill in the process sizes.
	 */
	faku->hpuxu_tsize = p->p_vmspace->vm_tsize;
	faku->hpuxu_dsize = p->p_vmspace->vm_dsize;
	faku->hpuxu_ssize = p->p_vmspace->vm_ssize;
	/*
	 * Fill in the exec header for CDB.
	 * This was saved back in exec().  As far as I can tell CDB
	 * only uses this information to verify that a particular
	 * core file goes with a particular binary.
	 */
	bcopy((caddr_t)p->p_addr->u_md.md_exec,
	      (caddr_t)&faku->hpuxu_exdata, sizeof (struct hpux_exec));
	/*
	 * Adjust user's saved registers (on kernel stack) to reflect
	 * HP-UX order.  Note that HP-UX saves the SR as 2 bytes not 4
	 * so we have to move it up.
	 */
	faku->hpuxu_ar0 = p->p_md.md_regs;
	foop = (short *) p->p_md.md_regs;
	foop[32] = foop[33];
	foop[33] = foop[34];
	foop[34] = foop[35];
#ifdef FPCOPROC
	/*
	 * Copy 68881 registers from our PCB format to HP-UX format
	 */
	bp = (struct bsdfp *) &p->p_addr->u_pcb.pcb_fpregs;
	bcopy((caddr_t)bp->save, (caddr_t)faku->hpuxu_fp.hpfp_save,
	      sizeof(bp->save));
	bcopy((caddr_t)bp->ctrl, (caddr_t)faku->hpuxu_fp.hpfp_ctrl,
	      sizeof(bp->ctrl));
	bcopy((caddr_t)bp->reg, (caddr_t)faku->hpuxu_fp.hpfp_reg,
	      sizeof(bp->reg));
#endif
	/*
	 * Slay the dragon
	 */
	faku->hpuxu_dragon = -1;
	/*
	 * Dump this artfully constructed page in place of the
	 * user struct page.
	 */
	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)faku, ctob(1), (off_t)0,
			UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred,
			(int *)NULL, p);
	/*
	 * Dump the remaining UPAGES-1 pages normally
	 * XXX Spot the wild guess.
	 */
	if (!error) 
		error = vn_rdwr(UIO_WRITE, vp, (caddr_t)p->p_addr + ctob(1),
				ctob(UPAGES-1), (off_t)ctob(1), UIO_SYSSPACE,
				IO_NODELOCKED|IO_UNIT, cred, (int *)NULL, p);
	free((caddr_t)faku, M_TEMP);
#endif
	return(error);
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: hpux_compat.c,v 1.19 1995/10/07 06:26:34 mycroft Exp $	*/
d124 1
a124 14
struct emul emul_hpux = {
	"hpux",
	bsdtohpuxerrnomap,
	sendsig,
	HPUX_SYS_syscall,
	HPUX_SYS_MAXSYSCALL,
	hpux_sysent,
	hpux_syscallnames,
	0,
	copyargs,
	setregs,
	sigcode,
	esigcode,
};
d138 1
a138 1
	error = sys_fork(p, (struct fork_args *) uap, retval);
d153 1
a153 1
	error = sys_vfork(p, (struct vfork_args *) uap, retval);
a158 16
int
hpux_sys_execv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_execv_args *uap = v;
	struct sys_execve_args ap;

	SCARG(&ap, path) = SCARG(uap, path);
	SCARG(&ap, argp) = SCARG(uap, argp);
	SCARG(&ap, envp) = NULL;

	return sys_execve(p, &ap, retval);
}

a279 203
 * Old creat system call.
 */
int
hpux_sys_creat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct hpux_sys_creat_args *uap = v;
	struct sys_open_args oap;

	SCARG(&oap, path) = SCARG(uap, path);
	SCARG(&oap, flags) = O_WRONLY | O_CREAT | O_TRUNC;
	SCARG(&oap, mode) = SCARG(uap, mode);

	return sys_open(p, &oap, retval);
}

/*
 * XXX extensions to the fd_ofileflags flags.
 * Hate to put this there, but they do need to be per-file.
 */
#define UF_NONBLOCK_ON	0x10
#define	UF_FNDELAY_ON	0x20
#define	UF_FIONBIO_ON	0x40

/*
 * Must remap some bits in the mode mask.
 * O_CREAT, O_TRUNC, and O_EXCL must be remapped,
 * O_NONBLOCK is remapped and remembered,
 * O_FNDELAY is remembered,
 * O_SYNCIO is removed entirely.
 */
int
hpux_sys_open(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct hpux_sys_open_args *uap = v;
	int mode, error;

	mode = SCARG(uap, mode);
	SCARG(uap, mode) &=
		~(HPUXNONBLOCK|HPUXFSYNCIO|HPUXFEXCL|HPUXFTRUNC|HPUXFCREAT);
	if (mode & HPUXFCREAT) {
		/*
		 * simulate the pre-NFS behavior that opening a
		 * file for READ+CREATE ignores the CREATE (unless
		 * EXCL is set in which case we will return the
		 * proper error).
		 */
		if ((mode & HPUXFEXCL) || (FFLAGS(mode) & FWRITE))
			SCARG(uap, mode) |= O_CREAT;
	}
	if (mode & HPUXFTRUNC)
		SCARG(uap, mode) |= O_TRUNC;
	if (mode & HPUXFEXCL)
		SCARG(uap, mode) |= O_EXCL;
	if (mode & HPUXNONBLOCK)
		SCARG(uap, mode) |= O_NDELAY;
	error = sys_open(p, (struct open_args *) uap, retval);
	/*
	 * Record non-blocking mode for fcntl, read, write, etc.
	 */
	if (error == 0 && (SCARG(uap, mode) & O_NDELAY))
		p->p_fd->fd_ofileflags[*retval] |=
			(mode & HPUXNONBLOCK) ? UF_NONBLOCK_ON : UF_FNDELAY_ON;
	return (error);
}

int
hpux_sys_fcntl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct hpux_sys_fcntl_args *uap = v;
	int mode, error, flg = F_POSIX;
	struct file *fp;
	char *pop;
	struct hpux_flock hfl;
	struct flock fl;
	struct vnode *vp;

	if ((unsigned)SCARG(uap, fd) >= p->p_fd->fd_nfiles ||
	    (fp = p->p_fd->fd_ofiles[SCARG(uap, fd)]) == NULL)
		return (EBADF);
	pop = &p->p_fd->fd_ofileflags[SCARG(uap, fd)];
	switch (SCARG(uap, cmd)) {
	case F_SETFL:
		if (SCARG(uap, arg) & HPUXNONBLOCK)
			*pop |= UF_NONBLOCK_ON;
		else
			*pop &= ~UF_NONBLOCK_ON;
		if (SCARG(uap, arg) & HPUXNDELAY)
			*pop |= UF_FNDELAY_ON;
		else
			*pop &= ~UF_FNDELAY_ON;
		if (*pop & (UF_NONBLOCK_ON|UF_FNDELAY_ON|UF_FIONBIO_ON))
			SCARG(uap, arg) |= FNONBLOCK;
		else
			SCARG(uap, arg) &= ~FNONBLOCK;
		SCARG(uap, arg) &= ~(HPUXNONBLOCK|HPUXFSYNCIO|HPUXFREMOTE);
		break;
	case F_GETFL:
	case F_DUPFD:
	case F_GETFD:
	case F_SETFD:
		break;

	case HPUXF_SETLKW:
		flg |= F_WAIT;
		/* Fall into F_SETLK */

	case HPUXF_SETLK:
		if (fp->f_type != DTYPE_VNODE)
			return (EBADF);
		vp = (struct vnode *)fp->f_data;
		/* Copy in the lock structure */
		error = copyin((caddr_t)SCARG(uap, arg), (caddr_t)&hfl,
		    sizeof (hfl));
		if (error)
			return (error);
		fl.l_start = hfl.hl_start;
		fl.l_len = hfl.hl_len;
		fl.l_pid = hfl.hl_pid;
		fl.l_type = hfl.hl_type;
		fl.l_whence = hfl.hl_whence;
		if (fl.l_whence == SEEK_CUR)
			fl.l_start += fp->f_offset;
		switch (fl.l_type) {

		case F_RDLCK:
			if ((fp->f_flag & FREAD) == 0)
				return (EBADF);
			p->p_flag |= P_ADVLOCK;
			return (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg));

		case F_WRLCK:
			if ((fp->f_flag & FWRITE) == 0)
				return (EBADF);
			p->p_flag |= P_ADVLOCK;
			return (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg));

		case F_UNLCK:
			return (VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &fl,
				F_POSIX));

		default:
			return (EINVAL);
		}

	case F_GETLK:
		if (fp->f_type != DTYPE_VNODE)
			return (EBADF);
		vp = (struct vnode *)fp->f_data;
		/* Copy in the lock structure */
		error = copyin((caddr_t)SCARG(uap, arg), (caddr_t)&hfl,
		    sizeof (hfl));
		if (error)
			return (error);
		fl.l_start = hfl.hl_start;
		fl.l_len = hfl.hl_len;
		fl.l_pid = hfl.hl_pid;
		fl.l_type = hfl.hl_type;
		fl.l_whence = hfl.hl_whence;
		if (fl.l_whence == SEEK_CUR)
			fl.l_start += fp->f_offset;
		if (error = VOP_ADVLOCK(vp, (caddr_t)p, F_GETLK, &fl, F_POSIX))
			return (error);
		hfl.hl_start = fl.l_start;
		hfl.hl_len = fl.l_len;
		hfl.hl_pid = fl.l_pid;
		hfl.hl_type = fl.l_type;
		hfl.hl_whence = fl.l_whence;
		return (copyout((caddr_t)&hfl, (caddr_t)SCARG(uap, arg),
		    sizeof (hfl)));

	default:
		return (EINVAL);
	}
	error = sys_fcntl(p, uap, retval);
	if (error == 0 && SCARG(uap, cmd) == F_GETFL) {
		mode = *retval;
		*retval &= ~(O_CREAT|O_TRUNC|O_EXCL);
		if (mode & FNONBLOCK) {
			if (*pop & UF_NONBLOCK_ON)
				*retval |= HPUXNONBLOCK;
			if ((*pop & UF_FNDELAY_ON) == 0)
				*retval &= ~HPUXNDELAY;
		}
		if (mode & O_CREAT)
			*retval |= HPUXFCREAT;
		if (mode & O_TRUNC)
			*retval |= HPUXFTRUNC;
		if (mode & O_EXCL)
			*retval |= HPUXFEXCL;
	}
	return (error);
}

/*
d301 1
a301 1
		if (*fp & UF_NONBLOCK_ON) {
d304 1
a304 1
		} else if (*fp & UF_FNDELAY_ON) {
d325 1
a325 1
		if (*fp & UF_NONBLOCK_ON) {
d328 1
a328 1
		} else if (*fp & UF_FNDELAY_ON) {
d349 1
a349 1
		if (*fp & UF_NONBLOCK_ON) {
d352 1
a352 1
		} else if (*fp & UF_FNDELAY_ON) {
d373 1
a373 1
		if (*fp & UF_NONBLOCK_ON) {
d376 1
a376 1
		} else if (*fp & UF_FNDELAY_ON) {
a568 58
hpux_sys_stat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_stat_args *uap = v;

	return (hpux_stat1(SCARG(uap, path), SCARG(uap, sb), FOLLOW, p));
}

int
hpux_sys_lstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct hpux_sys_lstat_args *uap = v;

	return (hpux_stat1(SCARG(uap, path), SCARG(uap, sb), NOFOLLOW, p));
}

int
hpux_sys_fstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct hpux_sys_fstat_args *uap = v;
	register struct filedesc *fdp = p->p_fd;
	register struct file *fp;
	struct stat sb;
	int error;

	if (((unsigned)SCARG(uap, fd)) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
		return (EBADF);

	switch (fp->f_type) {

	case DTYPE_VNODE:
		error = vn_stat((struct vnode *)fp->f_data, &sb, p);
		break;

	case DTYPE_SOCKET:
		error = soo_stat((struct socket *)fp->f_data, &sb, p);
		break;

	default:
		panic("fstat");
		/*NOTREACHED*/
	}
	/* is this right for sockets?? */
	if (error == 0)
		error = bsdtohpuxstat(&sb, SCARG(uap, sb));
	return (error);
}

int
a891 75
hpux_stat1(fname, hsb, follow, p)
	char *fname;
	struct hpux_stat *hsb;
	int follow;
	struct proc *p;
{
	int error;
	struct stat sb;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, follow | LOCKLEAF, UIO_USERSPACE, fname, p);
	if (error = namei(&nd))
		return (error);
	error = vn_stat(nd.ni_vp, &sb, p);
	vput(nd.ni_vp);
	if (error == 0)
		error = bsdtohpuxstat(&sb, hsb);
	return (error);
}

#ifdef hp300
#include "grf.h"
#define	NHIL	1	/* XXX */
#endif

#if NGRF > 0
extern int grfopen __P((dev_t dev, int oflags, int devtype, struct proc *p));
#endif

#if NHIL > 0
extern int hilopen __P((dev_t dev, int oflags, int devtype, struct proc *p));
#endif

#include <sys/conf.h>

int
bsdtohpuxstat(sb, hsb)
	struct stat *sb;
	struct hpux_stat *hsb;
{
	struct hpux_stat ds;

	bzero((caddr_t)&ds, sizeof(ds));
	ds.hst_dev = (u_short)sb->st_dev;
	ds.hst_ino = (u_long)sb->st_ino;
	ds.hst_mode = sb->st_mode;
	ds.hst_nlink = sb->st_nlink;
	ds.hst_uid = (u_short)sb->st_uid;
	ds.hst_gid = (u_short)sb->st_gid;
	ds.hst_rdev = bsdtohpuxdev(sb->st_rdev);

	/* XXX: I don't want to talk about it... */
	if ((sb->st_mode & S_IFMT) == S_IFCHR)
#if NGRF > 0
		if (cdevsw[major(sb->st_rdev)].d_open == grfopen)
			ds.hst_rdev = grfdevno(sb->st_rdev);
		else
#endif
#if NHIL > 0
			if (cdevsw[major(sb->st_rdev)].d_open == hilopen)
				ds.hst_rdev = hildevno(sb->st_rdev);
#endif

	if (sb->st_size < (quad_t)1 << 32)
		ds.hst_size = (long)sb->st_size;
	else
		ds.hst_size = -2;
	ds.hst_atime = sb->st_atime;
	ds.hst_mtime = sb->st_mtime;
	ds.hst_ctime = sb->st_ctime;
	ds.hst_blksize = sb->st_blksize;
	ds.hst_blocks = sb->st_blocks;
	return(copyout((caddr_t)&ds, (caddr_t)hsb, sizeof(ds)));
}

d996 1
a996 1
			*ofp |= UF_FIONBIO_ON;
d998 1
a998 1
			*ofp &= ~UF_FIONBIO_ON;
d1002 2
a1003 2
		if ((*ofp & (UF_NONBLOCK_ON|UF_FNDELAY_ON)) == 0) {
			tmp = *ofp & UF_FIONBIO_ON;
a1327 1
extern char kstack[];
d1340 2
d1343 1
d1376 1
a1376 1
		off = (int *)((u_int)off + (u_int)kstack);
d1413 1
a1413 1
		return((int)(raddr - (u_int)kstack));
d1424 2
d1494 1
d1497 1
a1497 1
		error = vn_rdwr(UIO_WRITE, vp, kstack + ctob(1),
d1506 1
a1506 6
 * The remaining routines are essentially the same as those in kern_xxx.c
 * and vfs_xxx.c as defined under "#ifdef COMPAT".  We replicate them here
 * to avoid COMPAT_HPUX dependencies in those files and to make sure that
 * HP-UX compatibility still works even when COMPAT is not defined.
 *
 * These are still needed as of HP-UX 7.05.
a1507 2
#ifdef COMPAT_HPUX_6X

d1510 1
a1510 1
#include "sys/times.h"
d1517 1
a1517 1
compat_hpux_6x_sys_setpgrp(p, v, retval)
a1521 1
	struct compat_hpux_6x_sys_setpgrp_args *uap = v;
d1530 1
a1530 1
compat_hpux_6x_sys_time(p, v, retval)
d1535 3
a1537 2
	register struct compat_hpux_6x_sys_time_args *uap = v;

d1542 2
a1543 3
        if (SCARG(uap, t))
		error = copyout(&tv.tv_sec, SCARG(uap, t),
				sizeof(*(SCARG(uap, t))));
d1545 2
a1546 2
	*retval = (int) tv.tv_sec;
	return error;
d1550 1
a1550 1
compat_hpux_6x_sys_stime(p, v, retval)
d1555 3
a1557 1
	register struct compat_hpux_6x_sys_stime_args *uap = v;
d1574 1
a1574 1
compat_hpux_6x_sys_ftime(p, v, retval)
d1579 3
a1581 1
	register struct compat_hpux_6x_sys_ftime_args *uap = v;
d1595 1
a1595 1
compat_hpux_6x_sys_alarm(p, v, retval)
d1600 3
a1602 1
	register struct compat_hpux_6x_sys_alarm_args *uap = v;
d1624 1
a1624 1
compat_hpux_6x_sys_nice(p, v, retval)
d1629 3
a1631 1
	register struct compat_hpux_6x_sys_nice_args *uap = v;
d1641 1
a1641 1
compat_hpux_6x_sys_times(p, v, retval)
d1646 3
a1648 1
	register struct compat_hpux_6x_sys_times_args *uap = v;
d1661 2
a1662 1
		*(time_t *)retval = hpux_scale(&time) - hpux_scale(&boottime);
d1671 1
a1671 1
int
d1683 1
a1683 1
compat_hpux_6x_sys_utime(p, v, retval)
d1688 4
a1691 1
	register struct compat_hpux_6x_sys_utime_args *uap = v;
d1724 1
a1724 39
compat_hpux_6x_sys_pause(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct compat_hpux_6x_sys_pause_args *uap = v;

	(void) tsleep(kstack, PPAUSE | PCATCH, "pause", 0);
	/* always return EINTR rather than ERESTART... */
	return (EINTR);
}

/*
 * The old fstat system call.
 */
int
compat_hpux_6x_sys_fstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct compat_hpux_6x_sys_fstat_args *uap = v;
	register struct filedesc *fdp = p->p_fd;
	struct file *fp;

	if (((unsigned)SCARG(uap, fd)) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
		return (EBADF);
	if (fp->f_type != DTYPE_VNODE)
		return (EINVAL);
	return (compat_hpux_6x_stat1((struct vnode *)fp->f_data,
				      SCARG(uap, sb), p));
}

/*
 * Old stat system call.  This version follows links.
 */
int
compat_hpux_6x_sys_stat(p, v, retval)
d1729 1
a1729 26
	register struct compat_hpux_6x_sys_stat_args *uap = v;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if (error = namei(&nd))
		return (error);
	error = compat_hpux_6x_stat1(nd.ni_vp, SCARG(uap, sb), p);
	vput(nd.ni_vp);
	return (error);
}

int
compat_hpux_6x_stat1(vp, ub, p)
	struct vnode *vp;
	struct hpux_ostat *ub;
	struct proc *p;
{
	struct hpux_ostat ohsb;
	struct stat sb;
	int error;

	error = vn_stat(vp, &sb, p);
	if (error)
		return (error);
d1731 2
a1732 15
	ohsb.hst_dev = sb.st_dev;
	ohsb.hst_ino = sb.st_ino;
	ohsb.hst_mode = sb.st_mode;
	ohsb.hst_nlink = sb.st_nlink;
	ohsb.hst_uid = sb.st_uid;
	ohsb.hst_gid = sb.st_gid;
	ohsb.hst_rdev = sb.st_rdev;
	if (sb.st_size < (quad_t)1 << 32)
		ohsb.hst_size = sb.st_size;
	else
		ohsb.hst_size = -2;
	ohsb.hst_atime = sb.st_atime;
	ohsb.hst_mtime = sb.st_mtime;
	ohsb.hst_ctime = sb.st_ctime;
	return (copyout((caddr_t)&ohsb, (caddr_t)ub, sizeof(ohsb)));
a1733 1
#endif
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
