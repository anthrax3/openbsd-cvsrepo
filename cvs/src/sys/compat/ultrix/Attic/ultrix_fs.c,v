head	1.16;
access;
symbols
	OPENBSD_4_7:1.15.0.8
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.8
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.11
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.18
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.16
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.10
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.16
date	2010.06.29.18.47.47;	author tedu;	state dead;
branches;
next	1.15;

1.15
date	2007.10.30.12.09.22;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.10.11.45.43;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.22.23.52.18;	author jfb;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.20.19.24.57;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.12.14.02.23;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.03.12.04.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.03.16.03;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	98.02.13.14.38.24;	author deraadt;	state Exp;
branches
	1.5.10.1;
next	1.4;

1.4
date	97.04.12.21.21.29;	author graichen;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.18.45;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.18.21.21.49;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.12.26.20.23.37;	author deraadt;	state Exp;
branches;
next	;

1.5.10.1
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.5.10.2;

1.5.10.2
date	2002.03.28.11.28.07;	author niklas;	state Exp;
branches;
next	1.5.10.3;

1.5.10.3
date	2003.03.27.23.53.48;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.28.09;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.10.29.00.30.52;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@and the ultrix files go into the attic.  ok deraadt miod
@
text
@/*	$OpenBSD: ultrix_fs.c,v 1.15 2007/10/30 12:09:22 gilles Exp $	*/
/*	$NetBSD: ultrix_fs.c,v 1.4 1996/04/07 17:23:06 jonathan Exp $	*/

/*
 * Copyright (c) 1995
 *	Jonathan Stone (hereinafter referred to as the author)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/exec.h>
#include <sys/namei.h>
#include <sys/mount.h>
#include <net/if.h>
#include <netinet/in.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>

#include <sys/syscallargs.h>
#include <compat/ultrix/ultrix_syscallargs.h>

#include <uvm/uvm_extern.h>

#define	ULTRIX_MAXPATHLEN	1024

/**
 ** Ultrix filesystem operations: mount(), getmnt().
 ** These are included purely so one can place an (ECOFF or ELF)
 ** NetBSD/pmax kernel in an Ultrix root filesystem, boot it,
 ** and over-write the Ultrix root parition with NetBSD binaries.
 **/

/*
 * Ultrix file system data structure, as modified by
 * Ultrix getmntent(). This  structure is padded to 2560 bytes, for
 * compatibility with the size the Ultrix kernel and user apps expect.
 */
struct ultrix_fs_data {
	u_int32_t	ufsd_flags;	/* how mounted */
	u_int32_t	ufsd_mtsize;	/* max transfer size in bytes */
	u_int32_t	ufsd_otsize;	/* optimal transfer size in bytes */
	u_int32_t	ufsd_bsize;	/* fs block size (bytes) for vm code */
	u_int32_t	ufsd_fstype;	/* see ../h/fs_types.h  */
	u_int32_t	ufsd_gtot;	/* total number of gnodes */
	u_int32_t	ufsd_gfree;	/* # of free gnodes */
	u_int32_t	ufsd_btot;	/* total number of 1K blocks */
	u_int32_t	ufsd_bfree;	/* # of free 1K blocks */
	u_int32_t	ufsd_bfreen;	/* user consumable 1K blocks */
	u_int32_t	ufsd_pgthresh;	/* min size in bytes before paging*/
	int32_t		ufsd_uid;	/* uid that mounted me */
	int16_t		ufsd_dev;	/* major/minor of fs */
	int16_t		ufsd_exroot;	/* root mapping from exports */
	char		ufsd_devname[ULTRIX_MAXPATHLEN + 4]; /* name of dev */
	char		ufsd_path[ULTRIX_MAXPATHLEN + 4]; /* name of mnt point */
	u_int32_t	ufsd_nupdate;	/* number of writes */
	u_int32_t	ufsd_pad[112];	/* pad to 2560 bytes. */
};

/*
 * Get statistics on mounted filesystems.
 */
#if 0
struct ultrix_getmnt_args {
	int32_t *start;
	struct ultrix_fs_data *buf;
	int32_t bufsize;
	int32_t mode;
	char *path;
};

#endif
/*
 * Ultrix getmnt() flags.
 * The operation getmnt() should perform is incoded in the flag
 * argument.  There are two independent attributes.
 *
 * ULTRIX_NOSTAT_xxx will never hang, but it may not return
 * up-to-date statistics. (For NFS clients, it returns whatever is
 * in the cache.) ULTRIX_STAT_xxx returns up-to-date info but may
 * hang (e.g., on dead NFS servers).
 *
 * ULTRIX_xxSTAT_ONE returns statistics on just one filesystem, determined
 * by the parth argument.  ULTRIX_xxSTAT_MANY ignores the path argument and
 * returns info on as many  filesystems fit in the structure.
 * the start argument, which should be zero on the first call,
 * can be used to iterate over all filesystems.
 *
 */
#define	ULTRIX_NOSTAT_MANY	1
#define	ULTRIX_STAT_MANY	2
#define	ULTRIX_STAT_ONE		3
#define	ULTRIX_NOSTAT_ONE	4

/*
 * Ultrix gnode-layer  filesystem codes.
 */
#define ULTRIX_FSTYPE_UNKNOWN	0x0
#define ULTRIX_FSTYPE_ULTRIX	0x1	/*  Ultrix UFS: basically 4.2bsd FFS */
#define ULTRIX_FSTYPE_NFS	0x5	/*  NFS v2 */

/*
 * Ultrix mount(2) options
 */
#define ULTRIX_NM_RONLY    0x0001  /* mount read-only */
#define ULTRIX_NM_SOFT     0x0002  /* soft mount (hard is default) */
#define ULTRIX_NM_WSIZE    0x0004  /* set write size */
#define ULTRIX_NM_RSIZE    0x0008  /* set read size */
#define ULTRIX_NM_TIMEO    0x0010  /* set initial timeout */
#define ULTRIX_NM_RETRANS  0x0020  /* set number of request retries */
#define ULTRIX_NM_HOSTNAME 0x0040  /* set hostname for error printf */
#define ULTRIX_NM_PGTHRESH 0x0080  /* set page threshold for exec */
#define ULTRIX_NM_INT      0x0100  /* allow hard mount keyboard interrupts */
#define ULTRIX_NM_NOAC     0x0200  /* don't cache attributes */
									

/*
 * Construct an Ultrix getmnt() ultrix_fs_data from the native NetBSD
 * struct statfs.
 */
static void
make_ultrix_mntent(sp, tem)
	register struct statfs *sp;
	register struct ultrix_fs_data *tem;
{

	bzero(tem, sizeof (*tem));

	tem->ufsd_flags = sp->f_flags;		/* XXX translate */
	tem->ufsd_mtsize = sp->f_bsize;		/* XXX max transfer size */
	tem->ufsd_otsize = sp->f_iosize;
	tem->ufsd_bsize = sp->f_bsize;
	/*
	 * Translate file system type. NetBSD/1.1 has f_type zero,
	 * and uses an fstype string instead.
	 * For now, map types not in Ultrix (kernfs, null, procfs...)
	 * to UFS, since Ultrix mout will try and call mount_unknown
	 * for ULTRIX_FSTYPE_UNKNOWN, but lacks a mount_unknown binary.
	 */
	tem->ufsd_fstype = ULTRIX_FSTYPE_NFS;
	if (strcmp(sp->f_fstypename, "ffs") == 0)
		tem->ufsd_fstype = ULTRIX_FSTYPE_ULTRIX;

	tem->ufsd_gtot = sp->f_files;		/* total "gnodes" */
	tem->ufsd_gfree = sp->f_ffree;		/* free "gnodes" */
	tem->ufsd_btot = sp->f_blocks;		/* total 1k blocks */
#ifdef needsmorethought	/* XXX */
	/* tem->ufsd_bfree = sp->f_bfree; */	/* free 1k blocks */
	/* tem->ufsd_bfree = sp->f_bavail; */	/* free 1k blocks */
#endif

	tem->ufsd_bfreen = sp->f_bavail;	/* blocks available to users */
	tem->ufsd_pgthresh = 0;			/* not relevant */
	tem->ufsd_uid = 0;			/* XXX kept where ?*/
	tem->ufsd_dev = 0;			/* ?? */
	tem->ufsd_exroot  = 0;			/* ?? */
	strlcpy(tem->ufsd_path, sp->f_mntonname, sizeof(tem->ufsd_path));
	strlcpy(tem->ufsd_devname, sp->f_mntfromname,
	    sizeof(tem->ufsd_devname));
#if 0
	/* In NetBSD-1.1, filesystem type is unused and always 0 */
	printf("mntent: %s type %d\n", tem->ufsd_devname, tem->ufsd_fstype);
	printf("mntent: %s tot %d free %d user%d\n",
	 tem->ufsd_devname, sp->f_blocks, sp->f_bfree, sp->f_bavail);
#endif
}

int
ultrix_sys_getmnt(p, v, retval)
	struct proc *p;
	void *v;
	int *retval;
{
	struct ultrix_sys_getmnt_args *uap = v;
	struct mount *mp, *nmp;
	struct statfs *sp;
	struct ultrix_fs_data *sfsp;
	char *path;
	int mntflags;
	int skip;
	int start;
	long count, maxcount;
	int error = 0;

	path = NULL;
	error = 0;
	maxcount = SCARG(uap, bufsize) / sizeof(struct ultrix_fs_data);
	sfsp = SCARG(uap, buf);

	if (SCARG(uap, mode) == ULTRIX_STAT_ONE ||
	    SCARG(uap, mode) == ULTRIX_STAT_MANY)
		mntflags = MNT_WAIT;
	else
		mntflags = MNT_NOWAIT;

	if (SCARG(uap, mode) == ULTRIX_STAT_ONE || SCARG(uap, mode) == ULTRIX_NOSTAT_ONE) {
		/*
		 * Only get info on mountpoints that matches the path
		 * provided.
		 */
		path = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
		if ((error = copyinstr(SCARG(uap, path), path,
				       MAXPATHLEN, NULL)) != 0)
			goto bad;
		maxcount = 1;
	} else {
		/*
		 * Get info on any mountpoints, somewhat like readdir().
		 * Find out how many mount list entries to skip, and skip
		 * them.
		 */
		if ((error = copyin((caddr_t)SCARG(uap, start), &start,
				    sizeof(*SCARG(uap, start))))  != 0)
			goto bad;
		for (skip = start, mp = CIRCLEQ_FIRST(&mountlist);
		    mp != CIRCLEQ_END(&mountlist) && skip-- > 0; mp = nmp)
			nmp = CIRCLEQ_NEXT(mp, mnt_list);
	}

	for (count = 0, mp = CIRCLEQ_FIRST(&mountlist);
	    mp != CIRCLEQ_END(&mountlist) && count < maxcount; mp = nmp) {
		nmp = CIRCLEQ_NEXT(mp, mnt_list);
		if (sfsp != NULL) {
			struct ultrix_fs_data tem;
			sp = &mp->mnt_stat;

			/*
			 * If requested, refresh the fsstat cache.
			 */
			if ((mntflags & MNT_WAIT) != 0 &&
			    (error = VFS_STATFS(mp, sp, p)) != 0)
				continue;

			/*
			 * XXX what does this do? -- cgd
			 */
			sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
			if (path == NULL ||
			    strcmp(path, sp->f_mntonname) == 0) {
				make_ultrix_mntent(sp, &tem);
				if ((error = copyout((caddr_t)&tem, sfsp,
						     sizeof(tem))) != 0)
					goto bad;
				sfsp++;
				count++;
			}
		}
	}

	if (sfsp != NULL && count > maxcount)
		*retval = maxcount;
	else
		*retval = count;

bad:
	if (path)
		free(path, M_TEMP);
	return (error);
}



/* Old-style inet sockaddr (no len field) as passed to Ultrix mount(2) */
struct osockaddr_in {
	short   sin_family;
	u_short sin_port;
	struct  in_addr sin_addr;
	char    sin_zero[8];
};


/*
 * fstype-dependent structure passed to Ultrix mount(2) when
 * mounting NFS filesystems
 */
struct	ultrix_nfs_args {
	struct	osockaddr_in *addr;	/* file server address */
	void	*fh;			/* file handle to be mounted */
	int	flags;			/* flags */
	int	wsize;			/* write size in bytes */
	int	rsize;			/* read size in bytes */
	int	timeo;			/* initial timeout in .1 secs */
	int	retrans;		/* times to retry send */
	char	*hostname;		/* server's hostname */
	char	*optstr;		/* string of nfs mount options*/
	int	gfs_flags;		/* gnode flags (ugh) */
	int	pg_thresh;		/* paging threshold ? */
};


/*
 * fstype-dependent structure passed to Ultrix mount(2) when
 * mounting local (4.2bsd FFS) filesystems
 */
struct ultrix_ufs_args {
	u_long ufs_flags;		/* mount flags?*/
	u_long ufs_pgthresh;		/* minimum file size to page */
};

int
ultrix_sys_mount(p, v, retval)
	struct proc *p;
	void *v;
	int *retval;
{
	struct ultrix_sys_mount_args *uap = v;

	int error;
	int otype = SCARG(uap, type);
	char fsname[MFSNAMELEN];
	char * fstype;
	struct sys_mount_args nuap;
	caddr_t sg = stackgap_init(p->p_emul);
	caddr_t usp = stackgap_alloc(&sg, 1024 /* XXX */);

	bzero(&nuap, sizeof(nuap));
	SCARG(&nuap, flags) = 0;

	/*
	 * Translate Ultrix integer mount codes for UFS and NFS to
	 * NetBSD fstype strings.  Other Ultrix filesystem types
	 *  (msdos, DEC ods-2) are not supported.
	 */
	if (otype == ULTRIX_FSTYPE_ULTRIX)
		fstype = "ufs";
	else if (otype == ULTRIX_FSTYPE_NFS)
		fstype = "nfs";
	else
		return (EINVAL);

	/* Translate the Ultrix mount-readonly option parameter */
	if (SCARG(uap, rdonly))
		SCARG(&nuap, flags) |= MNT_RDONLY;

	/* Copy string-ified version of mount type back out to user space */
	SCARG(&nuap, type) = (char *)usp;
	if ((error = copyout(fstype, (void *)SCARG(&nuap, type),
			    strlen(fstype)+1)) != 0) {
		return (error);
	}
	usp += strlen(fstype)+1;

#ifdef later
	parse ultrix mount option string and set NetBSD flags
#endif
	SCARG(&nuap, path) = SCARG(uap, dir);

	if (otype == ULTRIX_FSTYPE_ULTRIX) {
		/* attempt to mount a native, rather than 4.2bsd, ffs */
		struct ufs_args ua;

		ua.fspec = SCARG(uap, special);
		bzero(&ua.export_info, sizeof(ua.export_info));
		SCARG(&nuap, data) = usp;
	
		if ((error = copyout(&ua, SCARG(&nuap, data),
				     sizeof ua)) !=0) {
			return(error);
		}
		/*
		 * Ultrix mount has no MNT_UPDATE flag.
		 * Attempt to see if this is the root we're mounting,
		 * and if so, set MNT_UPDATE so we can mount / read-write.
		 */
		fsname[0] = 0;
		if ((error = copyinstr((caddr_t)SCARG(&nuap, path), fsname,
				      sizeof fsname, (u_int *)0)) != 0)
			return(error);
		if (strcmp(fsname, "/") == 0) {
			SCARG(&nuap, flags) |= MNT_UPDATE;
			printf("COMPAT_ULTRIX: mount with MNT_UPDATE on %s\n",
			       fsname);
		}
	} else if (otype == ULTRIX_FSTYPE_NFS) {
		struct ultrix_nfs_args una;
		struct nfs_args na;
		struct osockaddr_in osa;
		struct sockaddr_in *sap = (struct sockaddr_in *)& osa;

		bzero(&osa, sizeof(osa));
		bzero(&una, sizeof(una));
		if ((error = copyin(SCARG(uap, data), &una, sizeof una)) !=0) {
			return (error);
		}
		/*
		 * This is the only syscall boundary the
		 * address of the server passes, so do backwards
		 * compatibility on 4.3style sockaddrs here.
		 */
		if ((error = copyin(una.addr, &osa, sizeof osa)) != 0) {
			printf("ultrix_mount: nfs copyin osa\n");
			return (error);
		}
		sap->sin_family = (u_char)osa.sin_family;
		sap->sin_len = sizeof(*sap);
		/* allocate space above caller's stack for nfs_args */
		SCARG(&nuap, data) = usp;
		usp +=  sizeof (na);
		/* allocate space above caller's stack for server sockaddr */
		na.version = NFS_ARGSVERSION;
		na.addr = (struct sockaddr *)usp;
		usp += sizeof(*sap);
		na.addrlen = sap->sin_len;
		na.sotype = SOCK_DGRAM;
		na.proto = IPPROTO_UDP;
		na.fh = una.fh;
		na.fhsize = NFSX_V2FH;
		na.flags = /*una.flags;*/ NFSMNT_NOCONN;
		na.wsize = una.wsize;
		na.rsize = una.rsize;
		na.timeo = una.timeo;
		na.retrans = una.retrans;
		na.hostname = una.hostname;
		if ((error = copyout(sap, na.addr, sizeof (*sap) )) != 0)
			return (error);
		if ((error = copyout(&na, SCARG(&nuap, data), sizeof na)) != 0)
			return (error);
	}
	return (sys_mount(p, &nuap, retval));
}
@


1.15
log
@- replace the remaining MALLOC/FREE -> malloc/free in sys/compat

ok krw@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.14 2006/03/05 21:48:56 miod Exp $	*/
@


1.14
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.13 2005/12/10 11:45:43 miod Exp $	*/
d226 1
a226 1
		MALLOC(path, char *, MAXPATHLEN, M_TEMP, M_WAITOK);
d282 1
a282 1
		FREE(path, M_TEMP);
@


1.13
log
@{en,re}trys -> {en,re}tries; eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.12 2004/06/22 23:52:18 jfb Exp $	*/
d240 3
a242 3
		for (skip = start, mp = mountlist.cqh_first;
		    mp != (void *)&mountlist && skip-- > 0; mp = nmp)
			nmp = mp->mnt_list.cqe_next;
d245 3
a247 3
	for (count = 0, mp = mountlist.cqh_first;
	    mp != (void *)&mountlist && count < maxcount; mp = nmp) {
		nmp = mp->mnt_list.cqe_next;
@


1.12
log
@Replace a whole bunch of scary uses of strncpy() with strlcpy() and
use compat-specific MAXNAMLEN values where appropriate

ok millert@@, pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.11 2002/07/20 19:24:57 art Exp $	*/
d135 1
a135 1
#define ULTRIX_NM_RETRANS  0x0020  /* set number of request retrys */
@


1.11
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.10 2002/07/12 14:02:23 art Exp $	*/
d182 3
a184 2
	strncpy(tem->ufsd_path, sp->f_mntonname, ULTRIX_MAXPATHLEN);
	strncpy(tem->ufsd_devname, sp->f_mntfromname, ULTRIX_MAXPATHLEN);
@


1.10
log
@Change the locking on the mountpoint slightly. Instead of using mnt_lock
to get shared locks for lookup and get the exclusive lock only with
LK_DRAIN on unmount and do the real exclusive locking with flags in
mnt_flags, we now use shared locks for lookup and an exclusive lock for
unmount.

This is accomplished by slightly changing the semantics of vfs_busy.
Old vfs_busy behavior:
 - with LK_NOWAIT set in flags, a shared lock was obtained if the
   mountpoint wasn't being unmounted, otherwise we just returned an error.
 - with no flags, a shared lock was obtained if the mountpoint was being
   unmounted, otherwise we slept until the unmount was done and returned
   an error.
LK_NOWAIT was used for sync(2) and some statistics code where it isn't really
critical that we get the correct results.
0 was used in fchdir and lookup where it's critical that we get the right
directory vnode for the filesystem root.

After this change vfs_busy keeps the same behavior for no flags and LK_NOWAIT.
But if some other flags are passed into it, they are passed directly
into lockmgr (actually LK_SLEEPFAIL is always added to those flags because
if we sleep for the lock, that means someone was holding the exclusive lock
and the exclusive lock is only held when the filesystem is being unmounted.

More changes:
 dounmount must now be called with the exclusive lock held. (before this
 the caller was supposed to hold the vfs_busy lock, but that wasn't always
 true).
 Zap some (now) unused mount flags.
And the highlight of this change:
 Add some vfs_busy calls to match some vfs_unbusy calls, especially in
 sys_mount. (lockmgr doesn't detect the case where we release a lock noone
 holds (it will do that soon)).

If you've seen hangs on reboot with mfs this should solve it (I repeat this
for the fourth time now, but this time I spent two months fixing and
redesigning this and reading the code so this time I must have gotten
this right).
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.9 2002/06/03 12:04:08 deraadt Exp $	*/
a333 1
	extern char sigcode[], esigcode[];
d337 2
a338 3

#define	szsigcode	(esigcode - sigcode)
	caddr_t usp = (caddr_t)ALIGN(PS_STRINGS - szsigcode - STACKGAPLEN);
@


1.9
log
@compatiblity -> compatibility
decriptor -> descriptor
authentciated -> authenticated
transmition -> transmission
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.8 2002/04/23 18:54:12 espie Exp $	*/
d247 1
a247 1
		if (sfsp != NULL && (mp->mnt_flag & MNT_MLOCK) == 0) {
@


1.8
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.7 2002/03/14 03:16:03 millert Exp $	*/
d62 1
a62 1
 * compatiblity with the size the Ultrix kernel and user apps expect.
@


1.7
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.6 2001/11/06 19:53:18 miod Exp $	*/
d379 1
a379 1
		bzero(&ua.export, sizeof(ua.export));
@


1.6
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.5 1998/02/13 14:38:24 deraadt Exp $	*/
d240 1
a240 1
		    mp != (void*)&mountlist && skip-- > 0; mp = nmp)
d245 1
a245 1
	    mp != (void*)&mountlist && count < maxcount; mp = nmp) {
d393 1
a393 1
				      sizeof fsname, (u_int*)0)) != 0)
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.6 2001/11/06 19:53:18 miod Exp $	*/
d62 1
a62 1
 * compatibility with the size the Ultrix kernel and user apps expect.
d240 1
a240 1
		    mp != (void *)&mountlist && skip-- > 0; mp = nmp)
d245 1
a245 1
	    mp != (void *)&mountlist && count < maxcount; mp = nmp) {
d379 1
a379 1
		bzero(&ua.export_info, sizeof(ua.export_info));
d393 1
a393 1
				      sizeof fsname, (u_int *)0)) != 0)
@


1.6.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.6.2.1 2002/06/11 03:28:09 art Exp $	*/
d247 1
a247 1
		if (sfsp != NULL) {
d334 1
d338 3
a340 2
	caddr_t sg = stackgap_init(p->p_emul);
	caddr_t usp = stackgap_alloc(&sg, 1024 /* XXX */);
@


1.5
log
@type botch
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.4 1997/04/12 21:21:29 graichen Exp $	*/
d48 1
a48 1
#include <vm/vm.h>
@


1.5.10.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
#include <uvm/uvm_extern.h>
@


1.5.10.2
log
@Merge in -current from about a week ago
@
text
@d240 1
a240 1
		    mp != (void *)&mountlist && skip-- > 0; mp = nmp)
d245 1
a245 1
	    mp != (void *)&mountlist && count < maxcount; mp = nmp) {
d393 1
a393 1
				      sizeof fsname, (u_int *)0)) != 0)
@


1.5.10.3
log
@Sync the SMP branch with 3.3
@
text
@d62 1
a62 1
 * compatibility with the size the Ultrix kernel and user apps expect.
d247 1
a247 1
		if (sfsp != NULL) {
d334 1
d338 3
a340 2
	caddr_t sg = stackgap_init(p->p_emul);
	caddr_t usp = stackgap_alloc(&sg, 1024 /* XXX */);
d379 1
a379 1
		bzero(&ua.export_info, sizeof(ua.export_info));
@


1.4
log
@we don't need NFSMNT_RESVPORT inside of the kernel (pointed out by theo)
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.3 1996/04/21 22:18:45 deraadt Exp $	*/
d363 1
a363 1
	if ((error = copyout(fstype, SCARG(&nuap, type),
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_fs.c,v 1.2 1996/04/18 21:21:49 niklas Exp $	*/
d434 1
a434 1
		na.flags = /*una.flags;*/ NFSMNT_NOCONN | NFSMNT_RESVPORT;
@


1.2
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ultrix_fs.c,v 1.3 1996/02/19 15:41:39 pk Exp $	*/
d170 1
a170 1
	tem->ufsd_gfree = sp->f_ffree;		/* free "gnodes"/
d172 5
a176 2
	/*tem->ufsd_bfree = sp->f_bfree;	/* free 1k blocks */
	/*tem->ufsd_bfree = sp->f_bavail;	/* free 1k blocks */
d226 2
a227 1
		if (error = copyinstr(SCARG(uap, path), path, MAXPATHLEN, NULL))
d236 2
a237 3
		if (error =
		    copyin((caddr_t)SCARG(uap, start), &start,
					  sizeof(*SCARG(uap, start))))
d265 2
a266 2
				if (error =
				    copyout((caddr_t)&tem, sfsp, sizeof(tem)))
d363 2
a364 1
	if (error = copyout(fstype, SCARG(&nuap, type), strlen(fstype)+1)) {
a376 1
		struct nameidata nd;
d382 2
a383 1
		if (error = copyout(&ua, SCARG(&nuap, data), sizeof ua)) {
d392 2
a393 2
		if (error = copyinstr((caddr_t)SCARG(&nuap, path), fsname,
				      sizeof fsname, (u_int*)0))
d408 1
a408 1
		if (error = copyin(SCARG(uap, data), &una, sizeof una)) {
d416 1
a416 1
		if (error = copyin(una.addr, &osa, sizeof osa)) {
d440 1
a440 1
		if (error = copyout(sap, na.addr, sizeof (*sap) ))
d442 1
a442 1
		if (error = copyout(&na, SCARG(&nuap, data), sizeof na))
@


1.1
log
@from netbsd:
Add emulation of Ultrix select: before calling native sys_select(),
limit the number of FDs to select on to the maximum supported by NetBSD --
which is as many FDs as the emul_ultrix process can have open, anyway.
Add emulation of Ultrix getmnt(2) in ultrix_fs.c
Add partial emulation of Ultrix tty ioctl()s in ultrix_ioctl.c, derived
from compat/sunos/sunos_ioctl.c.  Ultrix libc's ``isatty()'' now works
in compat_emul processes.
Fix ultrix_sys_select() entry.
Add emulation of ultrix mount(2). Sufficient to NFS-mount filesystems
using a NetBSD kernel in an ultrix root filesystem.
Move wait emulation to the old (v7) wait syscall number, as that's
what the  Ultrix ufs_mount binary uses.
@
text
@d1 2
a2 1
/*	$NetBSD: ultrix_fs.c,v 1.2 1995/12/26 10:06:14 jonathan Exp $	*/
d41 3
d299 1
a299 1
	nfsv2fh_t *fh;			/* file handle to be mounted */
d422 1
d429 1
@
