head	1.32;
access;
symbols
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.4
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.30.0.8
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.6
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.16
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.14
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.29.0.12
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.10
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.8
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.29.0.6
	OPENBSD_3_6_BASE:1.29
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.29.0.4
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.28.0.4
	OPENBSD_3_3_BASE:1.28
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.28
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.15.0.6
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.4
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.2
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.6
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2010.06.29.18.47.47;	author tedu;	state dead;
branches;
next	1.31;

1.31
date	2009.03.05.19.52.24;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.02.23.28.01;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.23.22.21.44;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2002.08.23.01.13.09;	author pvalchev;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.03.16.03;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.02.12.13.05.31;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.10.31.10.56.11;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.10.26.12.03.27;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.07.27.21.29.53;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.16.12.50.21;	author ho;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.05.21.26.44;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2000.12.28.22.38.18;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	99.11.10.15.55.24;	author mickey;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	99.06.01.17.54.32;	author pefo;	state Exp;
branches;
next	1.13;

1.13
date	98.01.05.03.15.22;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.06.17.11.11.13;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.04.12.19.58.02;	author graichen;	state Exp;
branches;
next	1.10;

1.10
date	96.08.31.09.24.06;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	96.08.25.12.20.02;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.08.10.12.09.24;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.18.48;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.18.21.21.50;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.01.08.19.30.23;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.05.13.40.53;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.26.20.23.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.10.26.01.28.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.26;	author deraadt;	state Exp;
branches;
next	;

1.15.2.1
date	2001.05.14.22.05.33;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2001.07.04.10.39.49;	author niklas;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.15.2.5;

1.15.2.5
date	2002.03.06.02.07.09;	author niklas;	state Exp;
branches;
next	1.15.2.6;

1.15.2.6
date	2002.03.28.11.28.07;	author niklas;	state Exp;
branches;
next	1.15.2.7;

1.15.2.7
date	2003.03.27.23.53.48;	author niklas;	state Exp;
branches;
next	1.15.2.8;

1.15.2.8
date	2003.06.07.11.00.37;	author ho;	state Exp;
branches;
next	;

1.22.2.1
date	2002.06.11.03.28.09;	author art;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.10.29.00.30.52;	author art;	state Exp;
branches;
next	;


desc
@@


1.32
log
@and the ultrix files go into the attic.  ok deraadt miod
@
text
@/*	$OpenBSD: ultrix_misc.c,v 1.31 2009/03/05 19:52:24 kettenis Exp $	*/
/*	$NetBSD: ultrix_misc.c,v 1.23 1996/04/07 17:23:04 jonathan Exp $	*/

/*
 * Copyright (c) 1995
 *	Jonathan Stone (hereinafter referred to as the author)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *
 *	@@(#)sun_misc.c	8.1 (Berkeley) 6/18/93
 *
 * from: Header: sun_misc.c,v 1.16 93/04/07 02:46:27 torek Exp 
 */

/*
 * SunOS compatibility module.
 *
 * SunOS system calls that are implemented differently in BSD are
 * handled here.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/dirent.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/filedesc.h>
/*#include <sys/stat.h>*/
/*#include <sys/ioctl.h>*/
#include <sys/kernel.h>
#include <sys/core.h>
#include <sys/exec.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/resource.h>
#include <sys/resourcevar.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/socket.h>
#include <sys/vnode.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/unistd.h>

#include <sys/syscallargs.h>

#include <compat/ultrix/ultrix_syscall.h>
#include <compat/ultrix/ultrix_syscallargs.h>
#include <compat/ultrix/ultrix_util.h>

#include <netinet/in.h>

#include <miscfs/specfs/specdev.h>

#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs.h>

#include <uvm/uvm_extern.h>

#include <sys/conf.h>					/* iszerodev() */
#include <sys/socketvar.h>				/* sosetopt() */

extern struct sysent ultrix_sysent[];
#ifdef SYSCALL_DEBUG
extern char *ultrix_syscallnames[];
#endif

/*
 * Select the appropriate setregs callback for the target architecture.
 */
#ifdef __mips__
#define ULTRIX_EXEC_SETREGS cpu_exec_ecoff_setregs
#endif /* __mips__ */

#ifdef __vax__
#define ULTRIX_EXEC_SETREGS setregs
#endif /* __vax__ */


extern void ULTRIX_EXEC_SETREGS(struct proc *, struct exec_package *,
					u_long, register_t *);
extern char sigcode[], esigcode[];

struct emul emul_ultrix = {
	"ultrix",
	NULL,
	sendsig,
	ULTRIX_SYS_syscall,
	ULTRIX_SYS_MAXSYSCALL,
	ultrix_sysent,
#ifdef SYSCALL_DEBUG
	ultrix_syscallnames,
#else
	NULL,
#endif
	0,
	copyargs,
	ULTRIX_EXEC_SETREGS,
	NULL,
	coredump_trad,
	sigcode,
	esigcode,
};

#define GSI_PROG_ENV 1

int
ultrix_sys_getsysinfo(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_getsysinfo_args *uap = v;
	static short progenv = 0;

	switch (SCARG(uap, op)) {
		/* operations implemented: */
	case GSI_PROG_ENV:
		if (SCARG(uap, nbytes) < sizeof(short))
			return EINVAL;
		*retval = 1;
		return (copyout(&progenv, SCARG(uap, buffer), sizeof(short)));
	default:
		*retval = 0; /* info unavail */
		return 0;
	}
}

int
ultrix_sys_setsysinfo(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

#ifdef notyet
	struct ultrix_sys_setsysinfo_args *uap = v;
#endif

	*retval = 0;
	return 0;
}

int
ultrix_sys_waitpid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_waitpid_args *uap = v;
	struct sys_wait4_args ua;

	SCARG(&ua, pid) = SCARG(uap, pid);
	SCARG(&ua, status) = SCARG(uap, status);
	SCARG(&ua, options) = SCARG(uap, options);
	SCARG(&ua, rusage) = 0;

	return (sys_wait4(p, &ua, retval));
}

int
ultrix_sys_wait3(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_wait3_args *uap = v;
	struct sys_wait4_args ua;

	SCARG(&ua, pid) = -1;
	SCARG(&ua, status) = SCARG(uap, status);
	SCARG(&ua, options) = SCARG(uap, options);
	SCARG(&ua, rusage) = SCARG(uap, rusage);

	return (sys_wait4(p, &ua, retval));
}

/*
 * Ultrix binaries pass in FD_MAX as the first arg to select().
 * On Ultrix, FD_MAX is 4096, which is more than the NetBSD sys_select()
 * can handle.
 * Since we can't have more than the (native) FD_MAX descriptors open, 
 * limit nfds to at most FD_MAX.
 */
int
ultrix_sys_select(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_select_args *uap = v;
	struct timeval atv;
	int error;

	/* Limit number of FDs selected on to the native maximum */

	if (SCARG(uap, nd) > FD_SETSIZE)
		SCARG(uap, nd) = FD_SETSIZE;

	/* Check for negative timeval */
	if (SCARG(uap, tv)) {
		error = copyin((caddr_t)SCARG(uap, tv), (caddr_t)&atv,
			       sizeof(atv));
		if (error)
			goto done;
#ifdef DEBUG
		/* Ultrix clients sometimes give negative timeouts? */
		if (atv.tv_sec < 0 || atv.tv_usec < 0)
			printf("ultrix select( %ld, %ld): negative timeout\n",
			       atv.tv_sec, atv.tv_usec);
		/*tvp = (timeval *)STACKGAPBASE;*/
#endif

	}
	error = sys_select(p, (void *) uap, retval);
	if (error == EINVAL)
		printf("ultrix select: bad args?\n");

done:
	return error;
}

#if defined(NFSCLIENT)
int
async_daemon(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_nfssvc_args ouap;

	SCARG(&ouap, flag) = NFSSVC_BIOD;
	SCARG(&ouap, argp) = NULL;

	return (sys_nfssvc(p, &ouap, retval));
}
#endif /* NFSCLIENT */


#define	SUN__MAP_NEW	0x80000000	/* if not, old mmap & cannot handle */

int
ultrix_sys_mmap(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_mmap_args *uap = v;
	struct sys_mmap_args ouap;

	/*
	 * Verify the arguments.
	 */
	if (SCARG(uap, prot) & ~(PROT_READ|PROT_WRITE|PROT_EXEC))
		return (EINVAL);			/* XXX still needed? */

	if ((SCARG(uap, flags) & SUN__MAP_NEW) == 0)
		return (EINVAL);

	SCARG(&ouap, flags) = SCARG(uap, flags) & ~SUN__MAP_NEW;
	SCARG(&ouap, addr) = SCARG(uap, addr);

	if ((SCARG(&ouap, flags) & MAP_FIXED) == 0 &&
	    SCARG(&ouap, addr) != 0 &&
	    SCARG(&ouap, addr) < (void *)round_page((vaddr_t)p->p_vmspace->vm_daddr+MAXDSIZ))
		SCARG(&ouap, addr) = (void *)round_page((vaddr_t)p->p_vmspace->vm_daddr+MAXDSIZ);

	SCARG(&ouap, len) = SCARG(uap, len);
	SCARG(&ouap, prot) = SCARG(uap, prot);
	SCARG(&ouap, fd) = SCARG(uap, fd);
	SCARG(&ouap, pos) = SCARG(uap, pos);

	return (sys_mmap(p, &ouap, retval));
}

int
ultrix_sys_setsockopt(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct ultrix_sys_setsockopt_args *uap = v;
	struct file *fp;
	struct mbuf *m = NULL;
	int error;

	if ((error = getsock(p->p_fd, SCARG(uap, s), &fp))  != 0)
		return (error);
#define	SO_DONTLINGER (~SO_LINGER)
	if (SCARG(uap, name) == SO_DONTLINGER) {
		m = m_get(M_WAIT, MT_SOOPTS);
		mtod(m, struct linger *)->l_onoff = 0;
		m->m_len = sizeof(struct linger);
		error = (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
		    SO_LINGER, m));
		goto bad;
	}
	if (SCARG(uap, valsize) > MLEN) {
		error = EINVAL;
		goto bad;
	}
	if (SCARG(uap, val)) {
		m = m_get(M_WAIT, MT_SOOPTS);
		if ((error = copyin(SCARG(uap, val), mtod(m, caddr_t),
				    (u_int)SCARG(uap, valsize))) != 0) {
			(void) m_free(m);
			goto bad;
		}
		m->m_len = SCARG(uap, valsize);
	}
	error = (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), m));
bad:
	FRELE(fp);
	return (error);
}

struct ultrix_utsname {
	char    sysname[9];
	char    nodename[9];
	char    nodeext[65-9];
	char    release[9];
	char    version[9];
	char    machine[9];
};

int
ultrix_sys_uname(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_uname_args *uap = v;
	struct ultrix_utsname sut;
	extern char machine[];

	bzero(&sut, sizeof(sut));

	bcopy(ostype, sut.sysname, sizeof(sut.sysname) - 1);
	bcopy(hostname, sut.nodename, sizeof(sut.nodename));
	sut.nodename[sizeof(sut.nodename)-1] = '\0';
	bcopy(osrelease, sut.release, sizeof(sut.release) - 1);
	bcopy("1", sut.version, sizeof(sut.version) - 1);
	bcopy(machine, sut.machine, sizeof(sut.machine) - 1);

	return copyout((caddr_t)&sut, (caddr_t)SCARG(uap, name),
	    sizeof(struct ultrix_utsname));
}

int
ultrix_sys_setpgrp(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_setpgrp_args *uap = v;

	/*
	 * difference to our setpgid call is to include backwards
	 * compatibility to pre-setsid() binaries. Do setsid()
	 * instead of setpgid() in those cases where the process
	 * tries to create a new session the old way.
	 */
	if (!SCARG(uap, pgid) &&
	    (!SCARG(uap, pid) || SCARG(uap, pid) == p->p_pid))
		return sys_setsid(p, uap, retval);
	else
		return sys_setpgid(p, uap, retval);
}

#if defined (NFSSERVER)
int
ultrix_sys_nfssvc(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

#if 0	/* XXX */
	struct ultrix_sys_nfssvc_args *uap = v;
	struct emul *e = p->p_emul;
	struct sys_nfssvc_args outuap;
	struct sockaddr sa;
	int error;

	bzero(&outuap, sizeof outuap);
	SCARG(&outuap, fd) = SCARG(uap, fd);
	SCARG(&outuap, mskval) = STACKGAPBASE;
	SCARG(&outuap, msklen) = sizeof sa;
	SCARG(&outuap, mtchval) = outuap.mskval + sizeof sa;
	SCARG(&outuap, mtchlen) = sizeof sa;

	bzero(&sa, sizeof sa);
	if (error = copyout(&sa, SCARG(&outuap, mskval), SCARG(&outuap, msklen)))
		return (error);
	if (error = copyout(&sa, SCARG(&outuap, mtchval), SCARG(&outuap, mtchlen)))
		return (error);

	return nfssvc(p, &outuap, retval);
#else
	return (ENOSYS);
#endif
}
#endif /* NFSSERVER */

struct ultrix_ustat {
	int32_t	f_tfree;	/* total free */
	ino_t	f_tinode;	/* total inodes free */
	char	f_fname[6];	/* filsys name */
	char	f_fpack[6];	/* filsys pack name */
};

int
ultrix_sys_ustat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_ustat_args *uap = v;
	struct ultrix_ustat us;
	int error;

	bzero(&us, sizeof us);

	/*
	 * XXX: should set f_tfree and f_tinode at least
	 * How do we translate dev -> fstat? (and then to ultrix_ustat)
	 */

	if ((error = copyout(&us, SCARG(uap, buf), sizeof us)) != 0)
		return (error);
	return 0;
}

int
ultrix_sys_quotactl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

#ifdef notyet
	struct ultrix_sys_quotactl_args *uap = v;
#endif

	return EINVAL;
}

int
ultrix_sys_vhangup(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	return 0;
}

int
ultrix_sys_exportfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#ifdef notyet
	struct ultrix_sys_exportfs_args *uap = v;
#endif

	/*
	 * XXX: should perhaps translate into a mount(2)
	 * with MOUNT_EXPORT?
	 */
	return 0;
}

int
ultrix_sys_sigpending(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_sigpending_args *uap = v;
	int mask = p->p_siglist & p->p_sigmask;

	return (copyout((caddr_t)&mask, (caddr_t)SCARG(uap, mask), sizeof(int)));
}

int
ultrix_sys_sigcleanup(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_sigcleanup_args *uap = v;

	return sys_sigreturn(p, (struct sys_sigreturn_args *)uap, retval);
}

int
ultrix_sys_sigreturn(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_sigcleanup_args *uap = v;

#ifdef DEBUG
	printf("ultrix sigreturn\n");
#endif
	return sys_sigreturn(p, (struct sys_sigreturn_args  *)uap, retval);
}

int
ultrix_sys_execve(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_execve_args /* {
		syscallarg(char *) path;
		syscallarg(char **) argv;
		syscallarg(char **) envp;
        } */ *uap = v;
	struct sys_execve_args ap;
	caddr_t sg;

	sg = stackgap_init(p->p_emul);
	ULTRIX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&ap, path) = SCARG(uap, path);
	SCARG(&ap, argp) = SCARG(uap, argp);
	SCARG(&ap, envp) = SCARG(uap, envp);

	return (sys_execve(p, &ap, retval));
}
@


1.31
log
@Make ELF platforms generate ELF core dumps.  Somewhat based on code from
NetBSD.

ok kurt@@, drahn@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.30 2007/06/06 17:15:13 deraadt Exp $	*/
@


1.30
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.29 2003/06/02 23:28:01 millert Exp $	*/
d92 1
d165 1
@


1.29
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.28 2002/08/23 22:21:44 art Exp $	*/
d470 1
a470 1
	daddr_t	f_tfree;	/* total free */
@


1.28
log
@Just like getvnode, make getsock FREF the file so that we can't get away
with not refing it.

Eyeballed by lurene@@daemonkitty.net, fries@@, nordin@@ and fries@@
Some additional cleanups by nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.27 2002/08/23 01:13:09 pvalchev Exp $	*/
d53 1
a53 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.27
log
@FREF/FRELE cleanup/simplification, no functional changes; ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.26 2002/03/14 20:31:31 mickey Exp $	*/
a355 1
	FREF(fp);
@


1.26
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.25 2002/03/14 03:16:03 millert Exp $	*/
d364 1
a364 2
		FRELE(fp);
		return (error);
d367 2
a368 2
		FRELE(fp);
		return (EINVAL);
a373 1
			FRELE(fp);
d375 1
a375 1
			return (error);
d381 1
@


1.25
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.24 2002/03/14 01:26:51 millert Exp $	*/
d404 1
a404 1
	extern char ostype[], machine[], osrelease[];
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.23 2002/02/12 13:05:31 art Exp $	*/
d282 1
a282 1
	error = sys_select(p, (void*) uap, retval);
@


1.23
log
@Fix all users of getsock to use FREF/FRELE properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.22 2001/11/06 19:53:18 miod Exp $	*/
d148 2
a149 2
extern void ULTRIX_EXEC_SETREGS __P((struct proc *, struct exec_package *,
					u_long, register_t *));
@


1.22
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.21 2001/10/31 10:56:11 art Exp $	*/
d356 1
d362 1
a362 1
		return (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
d364 2
d367 2
a368 1
	if (SCARG(uap, valsize) > MLEN)
d370 1
d375 1
d381 1
a381 1
	return (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
d383 2
@


1.22.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.22 2001/11/06 19:53:18 miod Exp $	*/
d148 2
a149 2
extern void ULTRIX_EXEC_SETREGS(struct proc *, struct exec_package *,
					u_long, register_t *);
d282 1
a282 1
	error = sys_select(p, (void *) uap, retval);
a355 1
	FREF(fp);
d361 1
a361 1
		error = (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
a362 2
		FRELE(fp);
		return (error);
d364 1
a364 2
	if (SCARG(uap, valsize) > MLEN) {
		FRELE(fp);
a365 1
	}
a369 1
			FRELE(fp);
d375 1
a375 1
	error = (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
a376 2
	FRELE(fp);
	return (error);
d396 1
a396 1
	extern char machine[];
@


1.22.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.22.2.1 2002/06/11 03:28:09 art Exp $	*/
d356 1
d364 2
a365 1
		goto bad;
d368 2
a369 2
		error = EINVAL;
		goto bad;
d375 1
d377 1
a377 1
			goto bad;
a382 1
bad:
@


1.21
log
@There is no need to fake handling of /dev/zero here. The vm system ultrix/ultrix_misc.c sunos/sunos_misc.c
does this automagically (and has done it for ages).
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.20 2001/10/26 12:03:27 art Exp $	*/
d126 1
a126 1
#include <vm/vm.h>
@


1.20
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.19 2001/07/27 21:29:53 miod Exp $	*/
d311 1
a311 1
	register struct proc *p;
d315 1
a315 1
	register struct ultrix_sys_mmap_args *uap = v;
a316 3
	register struct filedesc *fdp;
	register struct file *fp;
	register struct vnode *vp;
a338 12

	/*
	 * Special case: if fd refers to /dev/zero, map as MAP_ANON.  (XXX)
	 */
	fdp = p->p_fd;
	if ((fp = fd_getfile(fdp, SCARG(&ouap, fd))) != NULL &&		/*XXX*/
	    fp->f_type == DTYPE_VNODE &&				/*XXX*/
	    (vp = (struct vnode *)fp->f_data)->v_type == VCHR &&	/*XXX*/
	    iszerodev(vp->v_rdev)) {					/*XXX*/
		SCARG(&ouap, flags) |= MAP_ANON;
		SCARG(&ouap, fd) = -1;
	}
@


1.19
log
@#ifdef vax -> #ifdef __vax__
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.18 2001/05/16 12:50:21 ho Exp $	*/
d347 1
a347 2
	if ((unsigned)SCARG(&ouap, fd) < fdp->fd_nfiles &&		/*XXX*/
	    (fp = fdp->fd_ofiles[SCARG(&ouap, fd)]) != NULL &&		/*XXX*/
@


1.18
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.17 2001/05/05 21:26:44 art Exp $	*/
d143 1
a143 1
#ifdef vax
d145 1
a145 1
#endif /* mips */
@


1.17
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.16 2000/12/28 22:38:18 miod Exp $	*/
a374 2
		if (m == NULL)
			return (ENOBUFS);
a383 2
		if (m == NULL)
			return (ENOBUFS);
@


1.16
log
@Typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.15 1999/11/10 15:55:24 mickey Exp $	*/
d335 2
a336 2
	    SCARG(&ouap, addr) < (void *)round_page(p->p_vmspace->vm_daddr+MAXDSIZ))
		SCARG(&ouap, addr) = (void *)round_page(p->p_vmspace->vm_daddr+MAXDSIZ);
@


1.15
log
@include syscallnames only if compiling w/ SYSCALL_DEBUG.
was already so for native and sunos, the rest was just
wasting space on it. niels@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.14 1999/06/01 17:54:32 pefo Exp $	*/
d162 1
a162 1
	NULL
@


1.15.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.16 2000/12/28 22:38:18 miod Exp $	*/
d162 1
a162 1
	NULL,
@


1.15.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.15.2.1 2001/05/14 22:05:33 niklas Exp $	*/
d335 2
a336 2
	    SCARG(&ouap, addr) < (void *)round_page((vaddr_t)p->p_vmspace->vm_daddr+MAXDSIZ))
		SCARG(&ouap, addr) = (void *)round_page((vaddr_t)p->p_vmspace->vm_daddr+MAXDSIZ);
d375 2
d386 2
@


1.15.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.15.2.2 2001/07/04 10:39:49 niklas Exp $	*/
d143 1
a143 1
#ifdef __vax__
d145 1
a145 1
#endif /* __vax__ */
d347 2
a348 1
	if ((fp = fd_getfile(fdp, SCARG(&ouap, fd))) != NULL &&		/*XXX*/
@


1.15.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d126 1
a126 1
#include <uvm/uvm_extern.h>
d311 1
a311 1
	struct proc *p;
d315 1
a315 1
	struct ultrix_sys_mmap_args *uap = v;
d317 3
d342 12
@


1.15.2.5
log
@Merge in trunk
@
text
@a355 1
	FREF(fp);
d361 1
a361 1
		error = (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
a362 2
		FRELE(fp);
		return (error);
d364 1
a364 2
	if (SCARG(uap, valsize) > MLEN) {
		FRELE(fp);
a365 1
	}
a369 1
			FRELE(fp);
d375 1
a375 1
	error = (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
a376 2
	FRELE(fp);
	return (error);
@


1.15.2.6
log
@Merge in -current from about a week ago
@
text
@d148 2
a149 2
extern void ULTRIX_EXEC_SETREGS(struct proc *, struct exec_package *,
					u_long, register_t *);
d282 1
a282 1
	error = sys_select(p, (void *) uap, retval);
d404 1
a404 1
	extern char machine[];
@


1.15.2.7
log
@Sync the SMP branch with 3.3
@
text
@d356 1
d364 2
a365 1
		goto bad;
d368 2
a369 2
		error = EINVAL;
		goto bad;
d375 1
d377 1
a377 1
			goto bad;
a382 1
bad:
@


1.15.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.15.2.7 2003/03/27 23:53:48 niklas Exp $	*/
d53 5
a57 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.14
log
@Fix some mips -> __mips__ stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.13 1998/01/05 03:15:22 deraadt Exp $	*/
d132 1
d134 1
d159 1
d161 3
@


1.13
log
@type repair; nino@@well.ox.ac.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.12 1997/06/17 11:11:13 deraadt Exp $	*/
d137 1
a137 1
#ifdef mips
d139 1
a139 1
#endif /* mips */
@


1.12
log
@careful with stackgap handling in execve()
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.11 1997/04/12 19:58:02 graichen Exp $	*/
d329 2
a330 2
	    SCARG(&ouap, addr) < (caddr_t)round_page(p->p_vmspace->vm_daddr+MAXDSIZ))
		SCARG(&ouap, addr) = (caddr_t)round_page(p->p_vmspace->vm_daddr+MAXDSIZ);
@


1.11
log
@make it compile (missing include of ultrix_util.h - the other
one is a bit unclear)
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.10 1996/08/31 09:24:06 pefo Exp $	*/
d594 7
a600 1
	struct ultrix_sys_execve_args *uap = v;
d602 1
a602 1
	caddr_t sg = stackgap_init(p->p_emul);
d605 5
a609 1
	return (sys_execve(p, (struct sys_execve_args *)&uap, retval));
@


1.10
log
@Cleanup exec
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.9 1996/08/25 12:20:02 deraadt Exp $	*/
d116 1
@


1.9
log
@route execve via compat filename translation
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.8 1996/08/10 12:09:24 deraadt Exp $	*/
d160 1
@


1.8
log
@sys/dirent.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ultrix_misc.c,v 1.6 1996/04/18 21:21:50 niklas Exp $	*/
d584 14
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d89 1
a89 1
#include <sys/dir.h>
@


1.6
log
@Merge of NetBSD 960317
@
text
@d1 30
a30 2
/*	$OpenBSD$	*/
/*	$NetBSD: ultrix_misc.c,v 1.21 1996/02/19 15:41:38 pk Exp $	*/
d127 3
d132 14
a145 1
extern void cpu_exec_ecoff_setregs __P((struct proc *, struct exec_package *,
d159 1
a159 1
	cpu_exec_ecoff_setregs,
d166 1
d188 1
d194 2
d197 2
d203 1
d220 1
d239 1
a239 1
 * On Ultrix, that is 4096, which is more than the NetBSD sys_select()
d241 2
d244 1
d251 1
a251 1
	struct timeval atv, *tvp;
d268 1
a268 1
			printf("ultrix select( %d, %d)\n",
d283 1
a297 9
#if 0
/* XXX: Temporary until sys/dir.h, include/dirent.h and sys/dirent.h are fixed */
struct dirent {
	u_long	d_fileno;		/* file number of entry */
	u_short	d_reclen;		/* length of this record */
	u_short	d_namlen;		/* length of string in d_name */
	char	d_name[255 + 1];	/* name must be no longer than this */
};
#endif
d351 1
d362 1
a362 1
	if (error = getsock(p->p_fd, SCARG(uap, s), &fp))
d380 2
a381 2
		if (error = copyin(SCARG(uap, val), mtod(m, caddr_t),
		    (u_int)SCARG(uap, valsize))) {
d451 2
a458 1
#if 0
d503 1
a503 1
	if (error = copyout(&us, SCARG(uap, buf), sizeof us))
d514 2
d517 1
d538 1
d540 1
@


1.5
log
@from netbsd:
Add '/emul/ultrix' pathname processing to Ultrix emulation, and move
Ultrix syscalls that require that processing out of ultrix_misc.c
to ultrix_pathname.c.
@
text
@d1 2
a2 1
/*	$NetBSD: ultrix_misc.c,v 1.20 1996/01/07 13:38:51 jonathan Exp $	*/
d94 1
a94 1
#include <nfs/nfsv2.h>
@


1.4
log
@from netbsd:
Add sigcode and esigcode to emul_ultrix, so that signal trampoline
code is set up for emul_ultrix processes.
@
text
@d1 1
a1 1
/*	$NetBSD: ultrix_misc.c,v 1.19 1996/01/03 21:07:33 jonathan Exp $	*/
a62 1
#include <sys/stat.h>
d64 2
a65 1
#include <sys/ioctl.h>
d82 1
a114 1
	/* 0, 0, */
d184 5
a188 15
ultrix_sys_execv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_execv_args *uap = v;
	struct sys_execve_args ouap;

	SCARG(&ouap, path) = SCARG(uap, path);
	SCARG(&ouap, argp) = SCARG(uap, argp);
	SCARG(&ouap, envp) = NULL;

	return (sys_execve(p, &ouap, retval));
}

d253 1
d351 1
a394 33
ultrix_sys_open(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_open_args *uap = v;
	int l, r;
	int noctty;
	int ret;
	
	/* convert open flags into NetBSD flags */
	l = SCARG(uap, flags);
	noctty = l & 0x8000;
	r =	(l & (0x0001 | 0x0002 | 0x0008 | 0x0040 | 0x0200 | 0x0400 | 0x0800));
	r |=	((l & (0x0004 | 0x1000 | 0x4000)) ? O_NONBLOCK : 0);
	r |=	((l & 0x0080) ? O_SHLOCK : 0);
	r |=	((l & 0x0100) ? O_EXLOCK : 0);
	r |=	((l & 0x2000) ? O_FSYNC : 0);

	SCARG(uap, flags) = r;
	ret = sys_open(p, (struct sys_open_args *)uap, retval);

	if (!ret && !noctty && SESS_LEADER(p) && !(p->p_flag & P_CONTROLT)) {
		struct filedesc *fdp = p->p_fd;
		struct file *fp = fdp->fd_ofiles[*retval];

		/* ignore any error, just give it a try */
		if (fp->f_type == DTYPE_VNODE)
			(fp->f_ops->fo_ioctl)(fp, TIOCSCTTY, (caddr_t)0, p);
	}
	return ret;
}

d396 1
d436 1
d458 1
d469 1
d479 1
a479 75
struct ultrix_statfs {
	long	f_type;		/* type of info, zero for now */
	long	f_bsize;	/* fundamental file system block size */
	long	f_blocks;	/* total blocks in file system */
	long	f_bfree;	/* free blocks */
	long	f_bavail;	/* free blocks available to non-super-user */
	long	f_files;	/* total file nodes in file system */
	long	f_ffree;	/* free file nodes in fs */
	fsid_t	f_fsid;		/* file system id */
	long	f_spare[7];	/* spare for later */
};

static
sunstatfs(sp, buf)
	struct statfs *sp;
	caddr_t buf;
{
	struct ultrix_statfs ssfs;

	bzero(&ssfs, sizeof ssfs);
	ssfs.f_type = 0;
	ssfs.f_bsize = sp->f_bsize;
	ssfs.f_blocks = sp->f_blocks;
	ssfs.f_bfree = sp->f_bfree;
	ssfs.f_bavail = sp->f_bavail;
	ssfs.f_files = sp->f_files;
	ssfs.f_ffree = sp->f_ffree;
	ssfs.f_fsid = sp->f_fsid;
	return copyout((caddr_t)&ssfs, buf, sizeof ssfs);
}	

ultrix_sys_statfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_statfs_args *uap = v;
	register struct mount *mp;
	register struct statfs *sp;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if (error = namei(&nd))
		return (error);
	mp = nd.ni_vp->v_mount;
	sp = &mp->mnt_stat;
	vrele(nd.ni_vp);
	if (error = VFS_STATFS(mp, sp, p))
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
	return sunstatfs(sp, (caddr_t)SCARG(uap, buf));
}

ultrix_sys_fstatfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_fstatfs_args *uap = v;
	struct file *fp;
	struct mount *mp;
	register struct statfs *sp;
	int error;

	if (error = getvnode(p->p_fd, SCARG(uap, fd), &fp))
		return (error);
	mp = ((struct vnode *)fp->f_data)->v_mount;
	sp = &mp->mnt_stat;
	if (error = VFS_STATFS(mp, sp, p))
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
	return sunstatfs(sp, (caddr_t)SCARG(uap, buf));
}

a491 14
}

int
ultrix_sys_mknod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_mknod_args *uap = v;

	if (S_ISFIFO(SCARG(uap, mode)))
		return sys_mkfifo(p, uap, retval);

	return sys_mknod(p, (struct sys_mknod_args *)uap, retval);
@


1.3
log
@from netbsd:
Add emulation of Ultrix select: before calling native sys_select(),
limit the number of FDs to select on to the maximum supported by NetBSD --
which is as many FDs as the emul_ultrix process can have open, anyway.
Add emulation of Ultrix getmnt(2) in ultrix_fs.c
Add partial emulation of Ultrix tty ioctl()s in ultrix_ioctl.c, derived
from compat/sunos/sunos_ioctl.c.  Ultrix libc's ``isatty()'' now works
in compat_emul processes.
Fix ultrix_sys_select() entry.
Add emulation of ultrix mount(2). Sufficient to NFS-mount filesystems
using a NetBSD kernel in an ultrix root filesystem.
Move wait emulation to the old (v7) wait syscall number, as that's
what the  Ultrix ufs_mount binary uses.
@
text
@d1 1
a1 1
/*	$NetBSD: ultrix_misc.c,v 1.18 1995/12/26 04:23:14 jonathan Exp $	*/
d101 2
d114 3
a116 2
	0,
	0,
a250 11
ultrix_sys_sigpending(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct ultrix_sys_sigpending_args *uap = v;
	int mask = p->p_siglist & p->p_sigmask;

	return (copyout((caddr_t)&mask, (caddr_t)SCARG(uap, mask), sizeof(int)));
}

d605 1
d620 12
d640 14
@


1.2
log
@update to netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: ultrix_misc.c,v 1.16.2.1 1995/10/18 06:46:14 jonathan Exp $	*/
d194 37
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ultrix_misc.c,v 1.16 1995/10/07 06:28:02 mycroft Exp $	*/
d384 2
a385 2
	/* convert mode into NetBSD mode */
	l = SCARG(uap, mode);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
