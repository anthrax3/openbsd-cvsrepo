head	1.18;
access;
symbols
	OPENBSD_5_7:1.16.0.4
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.8
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.14.0.4
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.16
	OPENBSD_5_0:1.13.0.14
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.12
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.10
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.11.0.10
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.8
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.8.0.16
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.14
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.12
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.10
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.2.0.12
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.10
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.8
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.6
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.4
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2
	OSSAUDIO10:1.1.1.1
	OSSAUDIO:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2015.04.22.20.29.56;	author ratchov;	state dead;
branches;
next	1.17;
commitid	esXugUjr2iRPCC8W;

1.17
date	2015.04.19.08.37.32;	author ratchov;	state Exp;
branches;
next	1.16;
commitid	unw3OnGpzw8vZhb9;

1.16
date	2013.03.28.03.45.32;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.26.16.40.34;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.14;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.12.22.53.20;	author jakemsr;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.17.17.49.53;	author jolan;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.25.21.29.25;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2006.01.21.17.39.59;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.50;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.14.22.57.18;	author pvalchev;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.26.12.03.27;	author art;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.05.24.04.21.02;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.11.01.30.24;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.09.18.44.10;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.04.26.22.15.42;	author provos;	state Exp;
branches
	1.2.8.1;
next	1.1;

1.1
date	98.04.26.21.39.10;	author provos;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	98.04.26.21.39.10;	author provos;	state Exp;
branches;
next	;

1.2.8.1
date	2001.05.14.22.05.18;	author niklas;	state Exp;
branches;
next	1.2.8.2;

1.2.8.2
date	2001.07.04.10.39.39;	author niklas;	state Exp;
branches;
next	1.2.8.3;

1.2.8.3
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.2.8.4;

1.2.8.4
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.2.8.5;

1.2.8.5
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Remove forgotten empty files, from miod, thanks
@
text
@@


1.17
log
@Remove emulation of oss audio ioctls from linux emulation.

ok armani, guenther, sthen
@
text
@@


1.16
log
@it is believed that the comment is referring to the define below.
all thinking performed by tim van der molen
@
text
@a0 852
/*	$OpenBSD: ossaudio.c,v 1.15 2013/03/26 16:40:34 tedu Exp $	*/
/*	$NetBSD: ossaudio.c,v 1.23 1997/10/19 07:41:52 augustss Exp $	*/

/*
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/file.h>
#include <sys/vnode.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/audioio.h>

#include <sys/syscallargs.h>

#include <compat/ossaudio/ossaudio.h>
#include <compat/ossaudio/ossaudiovar.h>

#ifdef AUDIO_DEBUG
#define DPRINTF(x) if (ossdebug) printf x
int ossdebug = 0;
#else
#define DPRINTF(x)
#endif

#define TO_OSSVOL(x) ((x) * 100 / 255)
#define FROM_OSSVOL(x) ((x) * 255 / 100)

static struct audiodevinfo *getdevinfo(struct file *, struct proc *);

static void setblocksize(struct file *, struct audio_info *, struct proc *);


int
oss_ioctl_audio(p, uap, retval)
	struct proc *p;
	struct oss_sys_ioctl_args /* {
		syscallarg(int) fd;
		syscallarg(u_long) com;
		syscallarg(caddr_t) data;
	} */ *uap;
	register_t *retval;
{	       
	struct file *fp;
	struct filedesc *fdp;
	u_long com;
	struct audio_info tmpinfo;
	struct audio_offset tmpoffs;
	struct oss_audio_buf_info bufinfo;
	struct oss_count_info cntinfo;
	struct audio_encoding tmpenc;
	struct audio_bufinfo tmpab;
	u_long ldat;
	u_int u;
	int idat, idata;
	int error = 0, tmperr = 0;
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *);

	fdp = p->p_fd;
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return (EBADF);
	FREF(fp);

	if ((fp->f_flag & (FREAD | FWRITE)) == 0) {
		FRELE(fp, p);
		return (EBADF);
	}

	ioctlf = fp->f_ops->fo_ioctl;

	com = SCARG(uap, com);
	retval[0] = 0;

	DPRINTF(("oss_sys_ioctl: com=%08lx\n", com));
	switch (com) {
	case OSS_SNDCTL_DSP_RESET:
		error = ioctlf(fp, AUDIO_FLUSH, (caddr_t)0, p);
		break;
	case OSS_SNDCTL_DSP_SYNC:
		error = ioctlf(fp, AUDIO_DRAIN, (caddr_t)0, p);
		break;
	case OSS_SNDCTL_DSP_POST:
		break;
	case OSS_SNDCTL_DSP_SPEED:
		AUDIO_INITINFO(&tmpinfo);
		error = copyin(SCARG(uap, data), &idat, sizeof idat);
		if (error)
			break;
		tmpinfo.play.sample_rate =
		tmpinfo.record.sample_rate = idat;
		error = ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
		DPRINTF(("oss_sys_ioctl: SNDCTL_DSP_SPEED %d = %d\n",
			 idat, error));
		/* FALLTHRU */
	case OSS_SOUND_PCM_READ_RATE:
		tmperr = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error >= 0)
			error = tmperr;
		idat = tmpinfo.play.sample_rate;
		tmperr = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SNDCTL_DSP_STEREO:
		AUDIO_INITINFO(&tmpinfo);
		error = copyin(SCARG(uap, data), &idat, sizeof idat);
		if (error)
			break;
		tmpinfo.play.channels =
		tmpinfo.record.channels = idat ? 2 : 1;
		error = ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
		tmperr = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error >= 0)
			error = tmperr;
		idat = tmpinfo.play.channels - 1;
		tmperr = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SNDCTL_DSP_GETBLKSIZE:
		error = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		setblocksize(fp, &tmpinfo, p);
		idat = tmpinfo.blocksize;
		tmperr = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SNDCTL_DSP_SETFMT:
		AUDIO_INITINFO(&tmpinfo);
		error = copyin(SCARG(uap, data), &idat, sizeof idat);
		if (error)
			break;
		switch (idat) {
		case OSS_AFMT_MU_LAW:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 8;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_ULAW;
			break;
		case OSS_AFMT_A_LAW:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 8;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_ALAW;
			break;
		case OSS_AFMT_U8:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 8;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_ULINEAR;
			break;
		case OSS_AFMT_S8:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 8;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_SLINEAR;
			break;
		case OSS_AFMT_S16_LE:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 16;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_SLINEAR_LE;
			break;
		case OSS_AFMT_S16_BE:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 16;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_SLINEAR_BE;
			break;
		case OSS_AFMT_U16_LE:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 16;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_ULINEAR_LE;
			break;
		case OSS_AFMT_U16_BE:
			tmpinfo.play.precision =
			tmpinfo.record.precision = 16;
			tmpinfo.play.encoding =
			tmpinfo.record.encoding = AUDIO_ENCODING_ULINEAR_BE;
			break;
		default:
			error = EINVAL;
			break;
		}
		if (error)
			break;
		else
			error = ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
		/* FALLTHRU */
	case OSS_SOUND_PCM_READ_BITS:
		tmperr = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error >= 0)
			error = tmperr;
		switch (tmpinfo.play.encoding) {
		case AUDIO_ENCODING_ULAW:
			idat = OSS_AFMT_MU_LAW;
			break;
		case AUDIO_ENCODING_ALAW:
			idat = OSS_AFMT_A_LAW;
			break;
		case AUDIO_ENCODING_SLINEAR_LE:
			if (tmpinfo.play.precision == 16)
				idat = OSS_AFMT_S16_LE;
			else
				idat = OSS_AFMT_S8;
			break;
		case AUDIO_ENCODING_SLINEAR_BE:
			if (tmpinfo.play.precision == 16)
				idat = OSS_AFMT_S16_BE;
			else
				idat = OSS_AFMT_S8;
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (tmpinfo.play.precision == 16)
				idat = OSS_AFMT_U16_LE;
			else
				idat = OSS_AFMT_U8;
			break;
		case AUDIO_ENCODING_ULINEAR_BE:
			if (tmpinfo.play.precision == 16)
				idat = OSS_AFMT_U16_BE;
			else
				idat = OSS_AFMT_U8;
			break;
		case AUDIO_ENCODING_ADPCM:
			idat = OSS_AFMT_IMA_ADPCM;
			break;
		default:
			idat = OSS_AFMT_MU_LAW;  /* XXX default encoding */
			break;
		}
		tmperr = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SNDCTL_DSP_CHANNELS:
		AUDIO_INITINFO(&tmpinfo);
		error = copyin(SCARG(uap, data), &idat, sizeof idat);
		if (error)
			break;
		tmpinfo.play.channels =
		tmpinfo.record.channels = idat;
		error = ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
		/* FALLTHRU */
	case OSS_SOUND_PCM_READ_CHANNELS:
		tmperr = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error >= 0)
			error = tmperr;
		idat = tmpinfo.play.channels;
		tmperr = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SOUND_PCM_WRITE_FILTER:
	case OSS_SOUND_PCM_READ_FILTER:
		error = EINVAL; /* XXX unimplemented */
		break;
	case OSS_SNDCTL_DSP_SUBDIVIDE:
		error = copyin(SCARG(uap, data), &idat, sizeof idat);
		if (error)
			break;
		error = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		setblocksize(fp, &tmpinfo, p);
		if (error)
			break;
		if (idat == 0)
			idat = tmpinfo.play.buffer_size / tmpinfo.blocksize;
		idat = (tmpinfo.play.buffer_size / idat) & -4;
		AUDIO_INITINFO(&tmpinfo);
		tmpinfo.blocksize = idat;
		error = ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
		if (error)
			break;
		idat = tmpinfo.play.buffer_size / tmpinfo.blocksize;
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error)
			break;
		break;
	case OSS_SNDCTL_DSP_SETFRAGMENT:
		AUDIO_INITINFO(&tmpinfo);
		error = copyin(SCARG(uap, data), &idat, sizeof idat);
		if (error)
			break;
		if ((idat & 0xffff) < 4 || (idat & 0xffff) > 17) {
			error = EINVAL;
			break;
		}
		tmpinfo.blocksize = 1 << (idat & 0xffff);
		tmpinfo.hiwat = (idat >> 16) & 0x7fff;
		DPRINTF(("oss_audio: SETFRAGMENT blksize=%d, hiwat=%d\n",
			 tmpinfo.blocksize, tmpinfo.hiwat));
		if (tmpinfo.hiwat == 0)	/* 0 means set to max */
			tmpinfo.hiwat = 65536;
		error = ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
		tmperr = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error >= 0)
			error = tmperr;
		u = tmpinfo.blocksize;
		for(idat = 0; u > 1; idat++, u >>= 1)
			;
		idat |= (tmpinfo.hiwat & 0x7fff) << 16;
		tmperr = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SNDCTL_DSP_GETFMTS:
		for(idat = 0, tmpenc.index = 0; 
		    ioctlf(fp, AUDIO_GETENC, (caddr_t)&tmpenc, p) == 0; 
		    tmpenc.index++) {
			switch(tmpenc.encoding) {
			case AUDIO_ENCODING_ULAW:
				idat |= OSS_AFMT_MU_LAW;
				break;
			case AUDIO_ENCODING_ALAW:
				idat |= OSS_AFMT_A_LAW;
				break;
			case AUDIO_ENCODING_SLINEAR:
				idat |= OSS_AFMT_S8;
				break;
			case AUDIO_ENCODING_SLINEAR_LE:
				if (tmpenc.precision == 16)
					idat |= OSS_AFMT_S16_LE;
				else
					idat |= OSS_AFMT_S8;
				break;
			case AUDIO_ENCODING_SLINEAR_BE:
				if (tmpenc.precision == 16)
					idat |= OSS_AFMT_S16_BE;
				else
					idat |= OSS_AFMT_S8;
				break;
			case AUDIO_ENCODING_ULINEAR:
				idat |= OSS_AFMT_U8;
				break;
			case AUDIO_ENCODING_ULINEAR_LE:
				if (tmpenc.precision == 16)
					idat |= OSS_AFMT_U16_LE;
				else
					idat |= OSS_AFMT_U8;
				break;
			case AUDIO_ENCODING_ULINEAR_BE:
				if (tmpenc.precision == 16)
					idat |= OSS_AFMT_U16_BE;
				else
					idat |= OSS_AFMT_U8;
				break;
			case AUDIO_ENCODING_ADPCM:
				idat |= OSS_AFMT_IMA_ADPCM;
				break;
			default:
				break;
			}
		}
		DPRINTF(("oss_sys_ioctl: SNDCTL_DSP_GETFMTS = %x\n", idat));
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		break;
	case OSS_SNDCTL_DSP_GETOSPACE:
		error = ioctlf(fp, AUDIO_GETPRINFO, (caddr_t)&tmpab, p);
		bufinfo.fragsize = tmpab.blksize;
		bufinfo.fragstotal = tmpab.hiwat;
		bufinfo.bytes = tmpab.hiwat * tmpab.blksize - tmpab.seek;
		if (tmpab.blksize != 0)
			bufinfo.fragments = bufinfo.bytes / tmpab.blksize;
		else
			bufinfo.fragments = 0;
		tmperr = copyout(&bufinfo, SCARG(uap, data), sizeof bufinfo);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SNDCTL_DSP_GETISPACE:
		error = ioctlf(fp, AUDIO_GETRRINFO, (caddr_t)&tmpab, p);
		bufinfo.fragsize = tmpab.blksize;
		bufinfo.fragstotal = tmpab.hiwat;
		bufinfo.bytes = tmpab.seek;
		if (tmpab.blksize != 0)
			bufinfo.fragments = bufinfo.bytes / tmpab.blksize;
		else
			bufinfo.fragments = 0;
		DPRINTF(("oss_sys_ioctl: SNDCTL_DSP_GETxSPACE = %d %d %d %d\n",
			 bufinfo.fragsize, bufinfo.fragments, 
			 bufinfo.fragstotal, bufinfo.bytes));
		tmperr = copyout(&bufinfo, SCARG(uap, data), sizeof bufinfo);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SNDCTL_DSP_NONBLOCK:
		idat = 1;
		error = ioctlf(fp, FIONBIO, (caddr_t)&idat, p);
		break;
	case OSS_SNDCTL_DSP_GETCAPS:
		error = ioctlf(fp, AUDIO_GETPROPS, (caddr_t)&idata, p);
		idat = OSS_DSP_CAP_TRIGGER;
		if (idata & AUDIO_PROP_FULLDUPLEX)
			idat |= OSS_DSP_CAP_DUPLEX;
		if (idata & AUDIO_PROP_MMAP)
			idat |= OSS_DSP_CAP_MMAP;
		DPRINTF(("oss_sys_ioctl: SNDCTL_DSP_GETCAPS = %x\n", idat));
		tmperr = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SNDCTL_DSP_SETTRIGGER:
		error = copyin(SCARG(uap, data), &idat, sizeof idat);
		if (error)
			break;
		AUDIO_INITINFO(&tmpinfo);
		if (idat & OSS_PCM_ENABLE_OUTPUT)
			tmpinfo.play.pause = 0;
		if (idat & OSS_PCM_ENABLE_INPUT)
			tmpinfo.record.pause = 0;
		error = ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
		tmperr = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error >= 0)
			error = tmperr;
		/* FALLTHRU */
	case OSS_SNDCTL_DSP_GETTRIGGER:
		tmperr = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error >= 0)
			error = tmperr;
		idat = (tmpinfo.play.pause ? 0 : OSS_PCM_ENABLE_OUTPUT) |
		       (tmpinfo.record.pause ? 0 : OSS_PCM_ENABLE_INPUT);
		tmperr = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SNDCTL_DSP_GETIPTR:
		error = ioctlf(fp, AUDIO_GETIOFFS, (caddr_t)&tmpoffs, p);
		cntinfo.bytes = tmpoffs.samples;
		cntinfo.blocks = tmpoffs.deltablks;
		cntinfo.ptr = tmpoffs.offset;
		tmperr = copyout(&cntinfo, SCARG(uap, data), sizeof cntinfo);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SNDCTL_DSP_GETOPTR:
		error = ioctlf(fp, AUDIO_GETOOFFS, (caddr_t)&tmpoffs, p);
		cntinfo.bytes = tmpoffs.samples;
		cntinfo.blocks = tmpoffs.deltablks;
		cntinfo.ptr = tmpoffs.offset;
		tmperr = copyout(&cntinfo, SCARG(uap, data), sizeof cntinfo);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SNDCTL_DSP_SETDUPLEX:
		idat = 1;
		error = ioctlf(fp, AUDIO_SETFD, (caddr_t)&idat, p);
		break;
	case OSS_SNDCTL_DSP_GETODELAY:
		error = ioctlf(fp, AUDIO_WSEEK, (caddr_t)&ldat, p);
		idat = (int)ldat;
		tmperr = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error >= 0)
			error = tmperr;
		break;
	case OSS_SNDCTL_DSP_MAPINBUF:
	case OSS_SNDCTL_DSP_MAPOUTBUF:
	case OSS_SNDCTL_DSP_SETSYNCRO:
	case OSS_SNDCTL_DSP_PROFILE:
		error = EINVAL; /* XXX unimplemented */
		break;
	default:
		error = EINVAL;
		break;
	}

	FRELE(fp, p);
	return (error);
}

/* If the mixer device should have more than MAX_MIXER_DEVS devices
 * some will not be available to Linux */
#define MAX_MIXER_DEVS 64
struct audiodevinfo {
	int done;
	dev_t dev;
	int16_t devmap[OSS_SOUND_MIXER_NRDEVICES], 
	        rdevmap[MAX_MIXER_DEVS];
        u_long devmask, recmask, stereomask;
	u_long caps, source;
};

/* 
 * Collect the audio device information to allow faster
 * emulation of the Linux mixer ioctls.  Cache the information
 * to eliminate the overhead of repeating all the ioctls needed
 * to collect the information.
 */
static struct audiodevinfo *
getdevinfo(fp, p)
	struct file *fp;
	struct proc *p;
{
	mixer_devinfo_t mi;
	int i;
	static const struct oss_devs {
		const char *name;
		int code;
	} devs[] = {
		{ AudioNmicrophone,	OSS_SOUND_MIXER_MIC },
		{ AudioNline,		OSS_SOUND_MIXER_LINE },
		{ AudioNcd,		OSS_SOUND_MIXER_CD },
		{ AudioNdac,		OSS_SOUND_MIXER_PCM },
		{ AudioNrecord,		OSS_SOUND_MIXER_IMIX },
		{ AudioNmaster,		OSS_SOUND_MIXER_VOLUME },
		{ AudioNtreble,		OSS_SOUND_MIXER_TREBLE },
		{ AudioNbass,		OSS_SOUND_MIXER_BASS },
		{ AudioNspeaker,	OSS_SOUND_MIXER_SPEAKER },
		{ AudioNoutput,		OSS_SOUND_MIXER_OGAIN },
		{ AudioNinput,		OSS_SOUND_MIXER_IGAIN },
		{ AudioNfmsynth,	OSS_SOUND_MIXER_SYNTH },
		{ AudioNmidi,		OSS_SOUND_MIXER_SYNTH },
		{ 0, -1 }
	};
	register const struct oss_devs *dp;
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *) =
	    fp->f_ops->fo_ioctl;
	struct vnode *vp;
	struct vattr va;
	static struct audiodevinfo devcache = { 0 };
	register struct audiodevinfo *di = &devcache;

	/* Figure out what device it is so we can check if the
	 * cached data is valid.
	 */
	vp = (struct vnode *)fp->f_data;
	if (vp->v_type != VCHR)
		return 0;
	if (VOP_GETATTR(vp, &va, p->p_ucred, p))
		return 0;
	if (di->done && di->dev == va.va_rdev)
		return di;

	di->done = 1;
	di->dev = va.va_rdev;
	di->devmask = 0;
	di->recmask = 0;
	di->stereomask = 0;
	di->source = -1;
	di->caps = 0;
	for(i = 0; i < OSS_SOUND_MIXER_NRDEVICES; i++)
		di->devmap[i] = -1;
	for(i = 0; i < MAX_MIXER_DEVS; i++)
		di->rdevmap[i] = -1;
	for(i = 0; i < MAX_MIXER_DEVS; i++) {
		mi.index = i;
		if (ioctlf(fp, AUDIO_MIXER_DEVINFO, (caddr_t)&mi, p) < 0)
			break;
		switch(mi.type) {
		case AUDIO_MIXER_VALUE:
			for(dp = devs; dp->name; dp++)
		    		if (strcmp(dp->name, mi.label.name) == 0)
					break;
			if (dp->code >= 0) {
				di->devmap[dp->code] = i;
				di->rdevmap[i] = dp->code;
				di->devmask |= 1 << dp->code;
				if (mi.un.v.num_channels == 2)
					di->stereomask |= 1 << dp->code;
			}
			break;
		case AUDIO_MIXER_ENUM:
			if (strcmp(mi.label.name, AudioNsource) == 0) {
				int j;
				di->source = i;
				for(j = 0; j < mi.un.e.num_mem; j++)
					di->recmask |= 1 << di->rdevmap[mi.un.e.member[j].ord];
				di->caps = OSS_SOUND_CAP_EXCL_INPUT;
			}
			break;
		case AUDIO_MIXER_SET:
			if (strcmp(mi.label.name, AudioNsource) == 0) {
				int j;
				di->source = i;
				for(j = 0; j < mi.un.s.num_mem; j++) {
					int k, mask = mi.un.s.member[j].mask;
					if (mask) {
						for(k = 0; !(mask & 1); mask >>= 1, k++)
							;
						di->recmask |= 1 << di->rdevmap[k];
					}
				}
			}
			break;
		}
	}
	return di;
}

int
oss_ioctl_mixer(p, uap, retval)
	struct proc *p;
	struct oss_sys_ioctl_args /* {
		syscallarg(int) fd;
		syscallarg(u_long) com;
		syscallarg(caddr_t) data;
	} */ *uap;
	register_t *retval;
{	       
	struct file *fp;
	struct filedesc *fdp;
	u_long com;
	struct audiodevinfo *di;
	mixer_ctrl_t mc;
	int idat;
	int i;
	int error;
	int l, r, n;
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *);

	fdp = p->p_fd;
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return (EBADF);
	FREF(fp);

	if ((fp->f_flag & (FREAD | FWRITE)) == 0) {
		error = EBADF;
		goto out;
	}

	com = SCARG(uap, com);
	retval[0] = 0;

	di = getdevinfo(fp, p);
	if (di == 0) {
		error = EINVAL;
		goto out;
	}

	ioctlf = fp->f_ops->fo_ioctl;
	switch (com) {
	case OSS_SOUND_MIXER_READ_RECSRC:
		if (di->source == -1) {
			error = EINVAL;
			goto out;
		}
		mc.dev = di->source;
		if (di->caps & OSS_SOUND_CAP_EXCL_INPUT) {
			mc.type = AUDIO_MIXER_ENUM;
			error = ioctlf(fp, AUDIO_MIXER_READ, (caddr_t)&mc, p);
			if (error)
				goto out;
			idat = 1 << di->rdevmap[mc.un.ord];
		} else {
			int k;
			unsigned int mask;
			mc.type = AUDIO_MIXER_SET;
			error = ioctlf(fp, AUDIO_MIXER_READ, (caddr_t)&mc, p);
			if (error)
				goto out;
			idat = 0;
			for(mask = mc.un.mask, k = 0; mask; mask >>= 1, k++)
				if (mask & 1)
					idat |= 1 << di->rdevmap[k];
		}
		break;
	case OSS_SOUND_MIXER_READ_DEVMASK:
		idat = di->devmask;
		break;
	case OSS_SOUND_MIXER_READ_RECMASK:
		idat = di->recmask;
		break;
	case OSS_SOUND_MIXER_READ_STEREODEVS:
		idat = di->stereomask;
		break;
	case OSS_SOUND_MIXER_READ_CAPS:
		idat = di->caps;
		break;
	case OSS_SOUND_MIXER_WRITE_RECSRC:
	case OSS_SOUND_MIXER_WRITE_R_RECSRC:
		if (di->source == -1) {
			error = EINVAL;
			goto out;
		}
		mc.dev = di->source;
		error = copyin(SCARG(uap, data), &idat, sizeof idat);
		if (error)
			goto out;
		if (di->caps & OSS_SOUND_CAP_EXCL_INPUT) {
			mc.type = AUDIO_MIXER_ENUM;
			for(i = 0; i < OSS_SOUND_MIXER_NRDEVICES; i++)
				if (idat & (1 << i))
					break;
			if (i >= OSS_SOUND_MIXER_NRDEVICES ||
			    di->devmap[i] == -1) {
				error = EINVAL;
				goto out;
			}
			mc.un.ord = di->devmap[i];
		} else {
			mc.type = AUDIO_MIXER_SET;
			mc.un.mask = 0;
			for(i = 0; i < OSS_SOUND_MIXER_NRDEVICES; i++) {
				if (idat & (1 << i)) {
					if (di->devmap[i] == -1) {
						error = EINVAL;
						goto out;
					}
					mc.un.mask |= 1 << di->devmap[i];
				}
			}
		}
		error = ioctlf(fp, AUDIO_MIXER_WRITE, (caddr_t)&mc, p);
		goto out;
	default:
		if (OSS_MIXER_READ(OSS_SOUND_MIXER_FIRST) <= com &&
		    com < OSS_MIXER_READ(OSS_SOUND_MIXER_NRDEVICES)) {
			n = OSS_GET_DEV(com);
			if (di->devmap[n] == -1) {
				error = EINVAL;
				goto out;
			}
		    doread:
			mc.dev = di->devmap[n];
			mc.type = AUDIO_MIXER_VALUE;
			mc.un.value.num_channels = di->stereomask & (1<<n) ? 2 : 1;
			error = ioctlf(fp, AUDIO_MIXER_READ, (caddr_t)&mc, p);
			if (error)
				goto out;
			if (mc.un.value.num_channels != 2) {
				l = r = mc.un.value.level[AUDIO_MIXER_LEVEL_MONO];
			} else {
				l = mc.un.value.level[AUDIO_MIXER_LEVEL_LEFT];
				r = mc.un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
			}
			idat = TO_OSSVOL(l) | (TO_OSSVOL(r) << 8);
			DPRINTF(("OSS_MIXER_READ  n=%d (dev=%d) l=%d, r=%d, idat=%04x\n", 
				 n, di->devmap[n], l, r, idat));
			break;
		} else if ((OSS_MIXER_WRITE_R(OSS_SOUND_MIXER_FIRST) <= com &&
			   com < OSS_MIXER_WRITE_R(OSS_SOUND_MIXER_NRDEVICES)) ||
			   (OSS_MIXER_WRITE(OSS_SOUND_MIXER_FIRST) <= com &&
			   com < OSS_MIXER_WRITE(OSS_SOUND_MIXER_NRDEVICES))) {
			n = OSS_GET_DEV(com);
			if (di->devmap[n] == -1) {
				error = EINVAL;
				goto out;
			}
			error = copyin(SCARG(uap, data), &idat, sizeof idat);
			if (error)
				goto out;
			l = FROM_OSSVOL( idat       & 0xff);
			r = FROM_OSSVOL((idat >> 8) & 0xff);
			mc.dev = di->devmap[n];
			mc.type = AUDIO_MIXER_VALUE;
			if (di->stereomask & (1<<n)) {
				mc.un.value.num_channels = 2;
				mc.un.value.level[AUDIO_MIXER_LEVEL_LEFT] = l;
				mc.un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = r;
			} else {
				mc.un.value.num_channels = 1;
				mc.un.value.level[AUDIO_MIXER_LEVEL_MONO] = (l+r)/2;
			}
			DPRINTF(("OSS_MIXER_WRITE n=%d (dev=%d) l=%d, r=%d, idat=%04x\n", 
				 n, di->devmap[n], l, r, idat));
			error = ioctlf(fp, AUDIO_MIXER_WRITE, (caddr_t)&mc, p);
			if (error)
				goto out;
			if (OSS_MIXER_WRITE(OSS_SOUND_MIXER_FIRST) <= com &&
			   com < OSS_MIXER_WRITE(OSS_SOUND_MIXER_NRDEVICES)) {
				error = 0;
				goto out;
			}
			goto doread;
		} else {
#ifdef AUDIO_DEBUG
			printf("oss_audio: unknown mixer ioctl %04lx\n", com);
#endif
			error = EINVAL;
			goto out;
		}
	}
	error = copyout(&idat, SCARG(uap, data), sizeof idat);

out:
	FRELE(fp, p);
	return (error);
}

/* XXX hook for sequencer emulation */
int
oss_ioctl_sequencer(p, uap, retval)
	struct proc *p;
	struct oss_sys_ioctl_args /* {
		syscallarg(int) fd;
		syscallarg(u_long) com;
		syscallarg(caddr_t) data;
	} */ *uap;
	register_t *retval;
{	       
	struct file *fp;
	struct filedesc *fdp;

	fdp = p->p_fd;
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return (EBADF);

	if ((fp->f_flag & (FREAD | FWRITE)) == 0)
		return (EBADF);

	retval[0] = 0;

	return EINVAL;
}

/*
 * Check that the blocksize is a power of 2 as OSS wants.
 * If not, set it to be.
 */
static void setblocksize(fp, info, p)
	struct file *fp;
	struct audio_info *info;
	struct proc *p;
{
	struct audio_info set;
	int s;

	if (info->blocksize & (info->blocksize-1)) {
		for(s = 32; s < info->blocksize; s <<= 1)
			;
		AUDIO_INITINFO(&set);
		set.blocksize = s;
		fp->f_ops->fo_ioctl(fp, AUDIO_SETINFO, (caddr_t)&set, p);
		fp->f_ops->fo_ioctl(fp, AUDIO_GETINFO, (caddr_t)info, p);
	}
}
@


1.15
log
@update define name to reflect fact this is openbsd. kill dead code.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.14 2012/04/22 05:43:14 guenther Exp $	*/
d497 1
a497 1
/* If the mixer device should have more than 32 devices
@


1.14
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.13 2008/06/26 05:42:14 ray Exp $	*/
d497 1
a497 1
/* If the NetBSD mixer device should have more than 32 devices
d499 1
a499 1
#define NETBSD_MAXDEVS 64
d504 1
a504 1
	        rdevmap[NETBSD_MAXDEVS];
a534 1
/*		{ AudioNheadphone,	?? },*/
a536 3
/*		{ AudioNmaster,		OSS_SOUND_MIXER_SPEAKER },*/
/*		{ AudioNstereo,		?? },*/
/*		{ AudioNmono,		?? },*/
a537 1
/*		{ AudioNwave,		OSS_SOUND_MIXER_PCM },*/
a538 1
/*		{ AudioNmixerout,	?? },*/
d569 1
a569 1
	for(i = 0; i < NETBSD_MAXDEVS; i++)
d571 1
a571 1
	for(i = 0; i < NETBSD_MAXDEVS; i++) {
a818 5
#if 0
	u_long com;
	int idat;
	int error;
#endif
a826 3
#if 0
	com = SCARG(uap, com);
#endif
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.12 2008/04/12 22:53:20 jakemsr Exp $	*/
d91 1
a91 1
		FRELE(fp);
d493 1
a493 1
	FRELE(fp);
d808 1
a808 1
	FRELE(fp);
@


1.12
log
@bring in changes as found in libossaudio

ok ratchov@@, brad@@ a while ago (except SETTRIGGER parts, which changed
recently in libossaudio)
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.11 2006/02/17 17:49:53 jolan Exp $	*/
a15 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@espie@@ backed out the library part of brad's commit which broke stuff,
but not the kernel part.  now sound in opera via the flashplugin works
again.
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.9 2006/01/21 17:39:59 brad Exp $	*/
d85 2
d89 1
a89 1
	int error;
d98 2
a99 2
		error = EBADF;
		goto out;
a110 2
		if (error)
			goto out;
d113 2
a115 3
		error = ioctlf(fp, AUDIO_DRAIN, (caddr_t)0, p);
		if (error)
			goto out;
d121 1
a121 1
			goto out;
d127 1
a127 3
		if (error)
			goto out;
		/* fall into ... */
d129 3
a131 3
		error = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error)
			goto out;
d133 3
a135 3
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error)
			goto out;
d141 1
a141 1
			goto out;
d144 4
a147 4
		(void) ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
		error = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error)
			goto out;
d149 3
a151 3
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error)
			goto out;
a154 2
		if (error)
			goto out;
d157 3
a159 3
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error)
			goto out;
d165 1
a165 1
			goto out;
d217 1
a217 1
			goto out;
d219 5
a223 2
		(void) ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
		/* fall into ... */
d225 3
a227 3
		error = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error)
			goto out;
d262 3
d266 3
a268 3
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error)
			goto out;
d274 1
a274 1
			goto out;
d277 2
a278 2
		(void) ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
		/* fall into ... */
d280 3
a282 3
		error = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error)
			goto out;
d284 3
a286 3
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error)
			goto out;
d291 1
a291 1
		goto out;
d295 1
a295 1
			goto out;
d299 1
a299 1
			goto out;
d307 1
a307 1
			goto out;
d311 1
a311 1
			goto out;
d317 1
a317 1
			goto out;
d320 1
a320 1
			goto out;
d328 4
a331 4
		(void) ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
		error = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error)
			goto out;
d336 3
a338 3
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error)
			goto out;
a343 2
			if (tmpenc.flags & AUDIO_ENCODINGFLAG_EMULATED)
				continue; /* Don't report emulated modes */
a389 2
		if (error)
			goto out;
d392 11
a402 14
		error = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error)
			goto out;
		setblocksize(fp, &tmpinfo, p);
		bufinfo.fragsize = tmpinfo.blocksize;
		bufinfo.fragments = tmpinfo.hiwat -
		    (tmpinfo.play.seek + tmpinfo.blocksize - 1) /
		    tmpinfo.blocksize;
		bufinfo.fragstotal = tmpinfo.hiwat;
		bufinfo.bytes =
		    tmpinfo.hiwat * tmpinfo.blocksize - tmpinfo.play.seek;
		error = copyout(&bufinfo, SCARG(uap, data), sizeof bufinfo);
		if (error)
			goto out;
d405 8
a412 11
		error = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error)
			goto out;
		setblocksize(fp, &tmpinfo, p);
		bufinfo.fragsize = tmpinfo.blocksize;
		bufinfo.fragments = tmpinfo.hiwat -
		    (tmpinfo.record.seek + tmpinfo.blocksize - 1) /
		    tmpinfo.blocksize;
		bufinfo.fragstotal = tmpinfo.hiwat;
		bufinfo.bytes =
		    tmpinfo.hiwat * tmpinfo.blocksize - tmpinfo.record.seek;
d416 3
a418 3
		error = copyout(&bufinfo, SCARG(uap, data), sizeof bufinfo);
		if (error)
			goto out;
a422 2
		if (error)
			goto out;
d426 1
a426 3
		if (error)
			goto out;
		idat = OSS_DSP_CAP_TRIGGER; /* pretend we have trigger */
d432 6
a437 1
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
d439 11
a449 3
			goto out;
		break;
#if 0
d451 3
a453 3
		error = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error)
			goto out;
d456 3
a458 15
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error)
			goto out;
		break;
	case OSS_SNDCTL_DSP_SETTRIGGER:
		AUDIO_INITINFO(&tmpinfo);
		error = copyin(SCARG(uap, data), &idat, sizeof idat);
		if (error)
			goto out;
		tmpinfo.play.pause = (idat & OSS_PCM_ENABLE_OUTPUT) == 0;
		tmpinfo.record.pause = (idat & OSS_PCM_ENABLE_INPUT) == 0;
		(void) ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		if (error)
			goto out;
a459 8
#else
	case OSS_SNDCTL_DSP_GETTRIGGER:
	case OSS_SNDCTL_DSP_SETTRIGGER:
		/* XXX Do nothing for now. */
		idat = OSS_PCM_ENABLE_OUTPUT;
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		goto out;
#endif
a461 2
		if (error)
			goto out;
d465 3
a467 3
		error = copyout(&cntinfo, SCARG(uap, data), sizeof cntinfo);
		if (error)
			goto out;
a470 2
		if (error)
			goto out;
d474 3
a476 3
		error = copyout(&cntinfo, SCARG(uap, data), sizeof cntinfo);
		if (error)
			goto out;
d481 8
a488 1
		goto out;
d494 1
a494 1
		goto out;
d497 1
a497 1
		goto out;
a499 3
	error = 0;

out:
@


1.10
log
@Fix problem in ioctl() handling in OSS audio emulation which caused
unintentional changes of the audio settings e.g. when running "kphone".

From NetBSD

ok jakemsr@@
@
text
@d119 1
a119 1
		(void) ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
d141 1
a141 1
		(void) ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
d167 1
a167 1
		(void) ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
d270 1
a270 1
		(void) ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
d302 1
a302 1
		(void) ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
d313 1
a313 1
		(void) ioctlf(fp, AUDIO_SETINFO, (caddr_t)&tmpinfo, p);
d461 1
a461 1
		(void) ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
d888 1
a888 1
		(void) fp->f_ops->fo_ioctl(fp, AUDIO_GETINFO, (caddr_t)&set, p);
@


1.9
log
@add support for SNDCTL_DSP_SETDUPLEX ioctl

From NetBSD in PR 4984
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.8 2002/03/14 01:26:50 millert Exp $	*/
d119 1
a119 1
		AUDIO_INITINFO(&tmpinfo);
d141 1
a141 1
		AUDIO_INITINFO(&tmpinfo);
d167 1
a167 1
		AUDIO_INITINFO(&tmpinfo);
d270 1
a270 1
		AUDIO_INITINFO(&tmpinfo);
d302 1
a302 1
		AUDIO_INITINFO(&tmpinfo);
d313 1
a313 1
		AUDIO_INITINFO(&tmpinfo);
d461 1
a461 1
		AUDIO_INITINFO(&tmpinfo);
d888 1
a888 1
		AUDIO_INITINFO(&set);
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.7 2002/02/14 22:57:18 pvalchev Exp $	*/
d502 4
a508 1
	case OSS_SNDCTL_DSP_SETDUPLEX:
@


1.7
log
@More FREF/FRELE fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.6 2001/10/26 12:03:27 art Exp $	*/
d62 1
a62 1
static struct audiodevinfo *getdevinfo __P((struct file *, struct proc *));
d64 1
a64 1
static void setblocksize __P((struct file *, struct audio_info *, struct proc *));
d88 1
a88 1
	int (*ioctlf) __P((struct file *, u_long, caddr_t, struct proc *));
d572 1
a572 1
	int (*ioctlf) __P((struct file *, u_long, caddr_t, struct proc *)) =
d665 1
a665 1
	int (*ioctlf) __P((struct file *, u_long, caddr_t, struct proc *));
@


1.6
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.5 2001/05/24 04:21:02 aaron Exp $	*/
d93 1
d95 4
a98 2
	if ((fp->f_flag & (FREAD | FWRITE)) == 0)
		return (EBADF);
d110 1
a110 1
			return error;
d116 1
a116 1
			return error;
d122 1
a122 1
			return error;
d129 1
a129 1
			return error;
d134 1
a134 1
			return error;
d138 1
a138 1
			return error;
d144 1
a144 1
			return error;
d150 1
a150 1
			return error;
d154 1
a154 1
			return error;
d159 1
a159 1
			return error;
d164 1
a164 1
			return error;
d170 1
a170 1
			return error;
d221 2
a222 1
			return EINVAL;
d229 1
a229 1
			return error;
d267 1
a267 1
			return error;
d273 1
a273 1
			return error;
d281 1
a281 1
			return error;
d285 1
a285 1
			return error;
d289 2
a290 1
		return EINVAL; /* XXX unimplemented */
d294 1
a294 1
			return error;
d298 1
a298 1
			return error;
d306 1
a306 1
			return error;
d310 1
a310 1
			return error;
d316 5
a320 3
			return error;
		if ((idat & 0xffff) < 4 || (idat & 0xffff) > 17)
			return EINVAL;
d330 1
a330 1
			return error;
d337 1
a337 1
			return error;
d392 1
a392 1
			return error;
d397 1
a397 1
			return error;
d408 1
a408 1
			return error;
d413 1
a413 1
			return error;
d427 1
a427 1
			return error;
d433 1
a433 1
			return error;
d438 1
a438 1
			return error;
d447 1
a447 1
			return error;
d453 1
a453 1
			return error;
d458 1
a458 1
			return error;
d464 1
a464 1
			return error;
d470 1
a470 1
			return error;
d477 2
a478 1
		return copyout(&idat, SCARG(uap, data), sizeof idat);
d483 1
a483 1
			return error;
d489 1
a489 1
			return error;
d494 1
a494 1
			return error;
d500 1
a500 1
			return error;
d507 2
a508 1
		return EINVAL; /* XXX unimplemented */
d510 2
a511 1
		return EINVAL;
d514 5
a518 1
	return 0;
d670 1
d672 4
a675 2
	if ((fp->f_flag & (FREAD | FWRITE)) == 0)
		return (EBADF);
d681 4
a684 2
	if (di == 0)
		return EINVAL;
d689 4
a692 2
		if (di->source == -1)
			return EINVAL;
d698 1
a698 1
				return error;
d706 1
a706 1
				return error;
d727 4
a730 2
		if (di->source == -1)
			return EINVAL;
d734 1
a734 1
			return error;
d741 4
a744 2
			    di->devmap[i] == -1)
				return EINVAL;
d751 4
a754 2
					if (di->devmap[i] == -1)
						return EINVAL;
d759 2
a760 1
		return ioctlf(fp, AUDIO_MIXER_WRITE, (caddr_t)&mc, p);
d765 4
a768 2
			if (di->devmap[n] == -1)
				return EINVAL;
d775 1
a775 1
				return error;
d791 4
a794 2
			if (di->devmap[n] == -1)
				return EINVAL;
d797 1
a797 1
				return error;
d814 1
a814 1
				return error;
d816 4
a819 2
			   com < OSS_MIXER_WRITE(OSS_SOUND_MIXER_NRDEVICES))
				return 0;
d825 2
a826 1
			return EINVAL;
d829 5
a833 1
	return copyout(&idat, SCARG(uap, data), sizeof idat);
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.6 2001/10/26 12:03:27 art Exp $	*/
d62 1
a62 1
static struct audiodevinfo *getdevinfo(struct file *, struct proc *);
d64 1
a64 1
static void setblocksize(struct file *, struct audio_info *, struct proc *);
d88 1
a88 1
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *);
a92 1
	FREF(fp);
d94 2
a95 4
	if ((fp->f_flag & (FREAD | FWRITE)) == 0) {
		error = EBADF;
		goto out;
	}
d107 1
a107 1
			goto out;
d113 1
a113 1
			goto out;
d119 1
a119 1
			goto out;
d126 1
a126 1
			goto out;
d131 1
a131 1
			goto out;
d135 1
a135 1
			goto out;
d141 1
a141 1
			goto out;
d147 1
a147 1
			goto out;
d151 1
a151 1
			goto out;
d156 1
a156 1
			goto out;
d161 1
a161 1
			goto out;
d167 1
a167 1
			goto out;
d218 1
a218 2
			error = EINVAL;
			goto out;
d225 1
a225 1
			goto out;
d263 1
a263 1
			goto out;
d269 1
a269 1
			goto out;
d277 1
a277 1
			goto out;
d281 1
a281 1
			goto out;
d285 1
a285 2
		error = EINVAL; /* XXX unimplemented */
		goto out;
d289 1
a289 1
			goto out;
d293 1
a293 1
			goto out;
d301 1
a301 1
			goto out;
d305 1
a305 1
			goto out;
d311 3
a313 5
			goto out;
		if ((idat & 0xffff) < 4 || (idat & 0xffff) > 17) {
			error = EINVAL;
			goto out;
		}
d323 1
a323 1
			goto out;
d330 1
a330 1
			goto out;
d385 1
a385 1
			goto out;
d390 1
a390 1
			goto out;
d401 1
a401 1
			goto out;
d406 1
a406 1
			goto out;
d420 1
a420 1
			goto out;
d426 1
a426 1
			goto out;
d431 1
a431 1
			goto out;
d440 1
a440 1
			goto out;
d446 1
a446 1
			goto out;
d451 1
a451 1
			goto out;
d457 1
a457 1
			goto out;
d463 1
a463 1
			goto out;
d470 1
a470 2
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		goto out;
d475 1
a475 1
			goto out;
d481 1
a481 1
			goto out;
d486 1
a486 1
			goto out;
d492 1
a492 1
			goto out;
d499 1
a499 2
		error = EINVAL; /* XXX unimplemented */
		goto out;
d501 1
a501 2
		error = EINVAL;
		goto out;
d504 1
a504 5
	error = 0;

out:
	FRELE(fp);
	return (error);
d558 1
a558 1
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *) =
d651 1
a651 1
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *);
a655 1
	FREF(fp);
d657 2
a658 4
	if ((fp->f_flag & (FREAD | FWRITE)) == 0) {
		error = EBADF;
		goto out;
	}
d664 2
a665 4
	if (di == 0) {
		error = EINVAL;
		goto out;
	}
d670 2
a671 4
		if (di->source == -1) {
			error = EINVAL;
			goto out;
		}
d677 1
a677 1
				goto out;
d685 1
a685 1
				goto out;
d706 2
a707 4
		if (di->source == -1) {
			error = EINVAL;
			goto out;
		}
d711 1
a711 1
			goto out;
d718 2
a719 4
			    di->devmap[i] == -1) {
				error = EINVAL;
				goto out;
			}
d726 2
a727 4
					if (di->devmap[i] == -1) {
						error = EINVAL;
						goto out;
					}
d732 1
a732 2
		error = ioctlf(fp, AUDIO_MIXER_WRITE, (caddr_t)&mc, p);
		goto out;
d737 2
a738 4
			if (di->devmap[n] == -1) {
				error = EINVAL;
				goto out;
			}
d745 1
a745 1
				goto out;
d761 2
a762 4
			if (di->devmap[n] == -1) {
				error = EINVAL;
				goto out;
			}
d765 1
a765 1
				goto out;
d782 1
a782 1
				goto out;
d784 2
a785 4
			   com < OSS_MIXER_WRITE(OSS_SOUND_MIXER_NRDEVICES)) {
				error = 0;
				goto out;
			}
d791 1
a791 2
			error = EINVAL;
			goto out;
d794 1
a794 5
	error = copyout(&idat, SCARG(uap, data), sizeof idat);

out:
	FRELE(fp);
	return (error);
@


1.5
log
@Fix fragment handling for SNDCTL_DSP_GETxSPACE ioctls; per NetBSD PR/12796.
The kernel part of this fixes sound emulation for version 1.37c of the Linux
binary of Snes9x (Super Nintendo emulator). The userland equivalent fix should
allow espie to remove his local audio hacks in the squeak port.
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.4 2001/04/11 01:30:24 aaron Exp $	*/
d91 1
a91 2
	if ((u_int)SCARG(uap, fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
d654 1
a654 2
	if ((u_int)SCARG(uap, fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
d817 1
a817 2
	if ((u_int)SCARG(uap, fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
@


1.4
log
@Fix an off-by-one error. Also, SETFRAGMENT ignores the high bit; from NetBSD.
Now the sound from the Linux binary of VGB (Virtual Gameboy) is emulated
correctly, although only with sound cards whose drivers' aren't picky about
rounding blocksizes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.3 2001/02/09 18:44:10 mickey Exp $	*/
d389 15
d410 6
a415 3
		bufinfo.fragments = /* XXX */
		bufinfo.fragstotal = tmpinfo.play.buffer_size / bufinfo.fragsize;
		bufinfo.bytes = tmpinfo.play.buffer_size;
@


1.3
log
@constify static data
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.2 1998/04/26 22:15:42 provos Exp $	*/
d316 1
a316 1
		tmpinfo.hiwat = (idat >> 16) & 0xffff;
d326 1
a326 1
		for(idat = 0; u; idat++, u >>= 1)
d328 1
a328 1
		idat |= (tmpinfo.hiwat & 0xffff) << 16;
@


1.2
log
@$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d515 2
a516 2
	static struct {
		char *name;
d518 1
a518 1
	} *dp, devs[] = {
d540 1
d546 1
a546 1
	struct audiodevinfo *di = &devcache;
@


1.2.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.4 2001/04/11 01:30:24 aaron Exp $	*/
d316 1
a316 1
		tmpinfo.hiwat = (idat >> 16) & 0x7fff;
d326 1
a326 1
		for(idat = 0; u > 1; idat++, u >>= 1)
d328 1
a328 1
		idat |= (tmpinfo.hiwat & 0x7fff) << 16;
d515 2
a516 2
	static const struct oss_devs {
		const char *name;
d518 1
a518 1
	} devs[] = {
a539 1
	register const struct oss_devs *dp;
d545 1
a545 1
	register struct audiodevinfo *di = &devcache;
@


1.2.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.2.8.1 2001/05/14 22:05:18 niklas Exp $	*/
a388 15
		error = ioctlf(fp, AUDIO_GETINFO, (caddr_t)&tmpinfo, p);
		if (error)
			return error;
		setblocksize(fp, &tmpinfo, p);
		bufinfo.fragsize = tmpinfo.blocksize;
		bufinfo.fragments = tmpinfo.hiwat -
		    (tmpinfo.play.seek + tmpinfo.blocksize - 1) /
		    tmpinfo.blocksize;
		bufinfo.fragstotal = tmpinfo.hiwat;
		bufinfo.bytes =
		    tmpinfo.hiwat * tmpinfo.blocksize - tmpinfo.play.seek;
		error = copyout(&bufinfo, SCARG(uap, data), sizeof bufinfo);
		if (error)
			return error;
		break;
d395 3
a397 6
		bufinfo.fragments = tmpinfo.hiwat -
		    (tmpinfo.record.seek + tmpinfo.blocksize - 1) /
		    tmpinfo.blocksize;
		bufinfo.fragstotal = tmpinfo.hiwat;
		bufinfo.bytes =
		    tmpinfo.hiwat * tmpinfo.blocksize - tmpinfo.record.seek;
@


1.2.8.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ossaudio.c,v 1.2.8.2 2001/07/04 10:39:39 niklas Exp $	*/
d91 2
a92 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
d655 2
a656 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
d819 2
a820 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
@


1.2.8.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a92 1
	FREF(fp);
d94 2
a95 4
	if ((fp->f_flag & (FREAD | FWRITE)) == 0) {
		error = EBADF;
		goto out;
	}
d107 1
a107 1
			goto out;
d113 1
a113 1
			goto out;
d119 1
a119 1
			goto out;
d126 1
a126 1
			goto out;
d131 1
a131 1
			goto out;
d135 1
a135 1
			goto out;
d141 1
a141 1
			goto out;
d147 1
a147 1
			goto out;
d151 1
a151 1
			goto out;
d156 1
a156 1
			goto out;
d161 1
a161 1
			goto out;
d167 1
a167 1
			goto out;
d218 1
a218 2
			error = EINVAL;
			goto out;
d225 1
a225 1
			goto out;
d263 1
a263 1
			goto out;
d269 1
a269 1
			goto out;
d277 1
a277 1
			goto out;
d281 1
a281 1
			goto out;
d285 1
a285 2
		error = EINVAL; /* XXX unimplemented */
		goto out;
d289 1
a289 1
			goto out;
d293 1
a293 1
			goto out;
d301 1
a301 1
			goto out;
d305 1
a305 1
			goto out;
d311 3
a313 5
			goto out;
		if ((idat & 0xffff) < 4 || (idat & 0xffff) > 17) {
			error = EINVAL;
			goto out;
		}
d323 1
a323 1
			goto out;
d330 1
a330 1
			goto out;
d385 1
a385 1
			goto out;
d390 1
a390 1
			goto out;
d401 1
a401 1
			goto out;
d406 1
a406 1
			goto out;
d420 1
a420 1
			goto out;
d426 1
a426 1
			goto out;
d431 1
a431 1
			goto out;
d440 1
a440 1
			goto out;
d446 1
a446 1
			goto out;
d451 1
a451 1
			goto out;
d457 1
a457 1
			goto out;
d463 1
a463 1
			goto out;
d470 1
a470 2
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		goto out;
d475 1
a475 1
			goto out;
d481 1
a481 1
			goto out;
d486 1
a486 1
			goto out;
d492 1
a492 1
			goto out;
d499 1
a499 2
		error = EINVAL; /* XXX unimplemented */
		goto out;
d501 1
a501 2
		error = EINVAL;
		goto out;
d504 1
a504 5
	error = 0;

out:
	FRELE(fp);
	return (error);
a655 1
	FREF(fp);
d657 2
a658 4
	if ((fp->f_flag & (FREAD | FWRITE)) == 0) {
		error = EBADF;
		goto out;
	}
d664 2
a665 4
	if (di == 0) {
		error = EINVAL;
		goto out;
	}
d670 2
a671 4
		if (di->source == -1) {
			error = EINVAL;
			goto out;
		}
d677 1
a677 1
				goto out;
d685 1
a685 1
				goto out;
d706 2
a707 4
		if (di->source == -1) {
			error = EINVAL;
			goto out;
		}
d711 1
a711 1
			goto out;
d718 2
a719 4
			    di->devmap[i] == -1) {
				error = EINVAL;
				goto out;
			}
d726 2
a727 4
					if (di->devmap[i] == -1) {
						error = EINVAL;
						goto out;
					}
d732 1
a732 2
		error = ioctlf(fp, AUDIO_MIXER_WRITE, (caddr_t)&mc, p);
		goto out;
d737 2
a738 4
			if (di->devmap[n] == -1) {
				error = EINVAL;
				goto out;
			}
d745 1
a745 1
				goto out;
d761 2
a762 4
			if (di->devmap[n] == -1) {
				error = EINVAL;
				goto out;
			}
d765 1
a765 1
				goto out;
d782 1
a782 1
				goto out;
d784 2
a785 4
			   com < OSS_MIXER_WRITE(OSS_SOUND_MIXER_NRDEVICES)) {
				error = 0;
				goto out;
			}
d791 1
a791 2
			error = EINVAL;
			goto out;
d794 1
a794 5
	error = copyout(&idat, SCARG(uap, data), sizeof idat);

out:
	FRELE(fp);
	return (error);
@


1.2.8.5
log
@Merge in -current from about a week ago
@
text
@d62 1
a62 1
static struct audiodevinfo *getdevinfo(struct file *, struct proc *);
d64 1
a64 1
static void setblocksize(struct file *, struct audio_info *, struct proc *);
d88 1
a88 1
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *);
d572 1
a572 1
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *) =
d665 1
a665 1
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *);
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@2nd try: compat ossaudio from NetBSD mostly by
Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@@
