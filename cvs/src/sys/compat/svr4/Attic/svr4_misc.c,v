head	1.58;
access;
symbols
	OPENBSD_4_9:1.56.0.2
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.55.0.2
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.51.0.2
	OPENBSD_4_7_BASE:1.51
	OPENBSD_4_6:1.49.0.10
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.49.0.6
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.49.0.4
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.49.0.2
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.47.0.2
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.46.0.4
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.46.0.2
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.44.0.8
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.44.0.6
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.44.0.4
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.44.0.2
	OPENBSD_3_6_BASE:1.44
	SMP_SYNC_A:1.43
	SMP_SYNC_B:1.43
	OPENBSD_3_5:1.43.0.4
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.43.0.2
	OPENBSD_3_4_BASE:1.43
	UBC_SYNC_A:1.42
	OPENBSD_3_3:1.42.0.4
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.42.0.2
	OPENBSD_3_2_BASE:1.42
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	UBC_SYNC_B:1.42
	UBC:1.38.0.2
	UBC_BASE:1.38
	OPENBSD_3_0:1.35.0.2
	OPENBSD_3_0_BASE:1.35
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.2
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.25.0.6
	OPENBSD_2_7_BASE:1.25
	SMP:1.25.0.4
	SMP_BASE:1.25
	kame_19991208:1.25
	OPENBSD_2_6:1.25.0.2
	OPENBSD_2_6_BASE:1.25
	OPENBSD_2_5:1.22.0.2
	OPENBSD_2_5_BASE:1.22
	OPENBSD_2_4:1.20.0.4
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.20.0.2
	OPENBSD_2_3_BASE:1.20
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.58
date	2011.07.04.23.01.33;	author tedu;	state dead;
branches;
next	1.57;

1.57
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2010.12.15.04.59.52;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2010.05.25.16.39.15;	author thib;	state Exp;
branches;
next	1.53;

1.53
date	2010.05.25.15.25.17;	author millert;	state Exp;
branches;
next	1.52;

1.52
date	2010.04.28.21.31.59;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2009.12.20.23.36.04;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2009.07.09.22.29.55;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2007.10.01.12.10.55;	author martin;	state Exp;
branches;
next	1.48;

1.48
date	2007.09.01.15.14.44;	author martin;	state Exp;
branches;
next	1.47;

1.47
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.23.20.34.22;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.22.23.52.18;	author jfb;	state Exp;
branches;
next	1.43;

1.43
date	2003.08.15.20.32.16;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2002.08.23.15.39.31;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.12.22.13.22;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2002.02.12.18.41.21;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.28.13.47.39;	author art;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2001.11.07.01.18.01;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2001.08.28.18.25.14;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.26.06.25.10;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.22.10.29.42;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.27.04.58.42;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.21.13.08.15;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.05.21.26.43;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.01.23.05.48.04;	author csapuntz;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.10.18.15.46;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.28.23.48.15;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.24.21.00.30;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	99.10.07.17.23.53;	author brad;	state Exp;
branches
	1.25.4.1;
next	1.24;

1.24
date	99.10.07.16.14.28;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	99.09.11.00.03.16;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	99.02.26.04.12.00;	author art;	state Exp;
branches;
next	1.21;

1.21
date	99.02.10.00.16.12;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	98.03.06.21.58.09;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	97.12.12.06.22.51;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.12.02.00.07.04;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.11.14.21.22.52;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.11.13.06.23.05;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.11.13.06.21.31;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.11.06.05.58.06;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	97.10.06.20.19.35;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.10.06.15.06.25;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.09.11.10.48.12;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.06.17.11.11.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.03.28.22.03.46;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.02.13.19.45.19;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.01.27.01.16.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.03.15.29.32;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.01.00.50.53;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.04.17.05.24.18;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.02.26.23.31.57;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.47.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.23;	author deraadt;	state Exp;
branches;
next	;

1.25.4.1
date	2001.05.14.22.05.26;	author niklas;	state Exp;
branches;
next	1.25.4.2;

1.25.4.2
date	2001.07.04.10.39.45;	author niklas;	state Exp;
branches;
next	1.25.4.3;

1.25.4.3
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.25.4.4;

1.25.4.4
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.25.4.5;

1.25.4.5
date	2001.12.05.00.43.28;	author niklas;	state Exp;
branches;
next	1.25.4.6;

1.25.4.6
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.25.4.7;

1.25.4.7
date	2002.03.28.11.28.07;	author niklas;	state Exp;
branches;
next	1.25.4.8;

1.25.4.8
date	2003.03.27.23.53.48;	author niklas;	state Exp;
branches;
next	1.25.4.9;

1.25.4.9
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	;

1.38.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2002.10.29.00.30.52;	author art;	state Exp;
branches;
next	;


desc
@@


1.58
log
@remove all the compat svr4 files
@
text
@/*	$OpenBSD: svr4_misc.c,v 1.57 2011/07/04 20:35:35 deraadt Exp $	 */
/*	$NetBSD: svr4_misc.c,v 1.42 1996/12/06 03:22:34 christos Exp $	 */

/*
 * Copyright (c) 1994 Christos Zoulas
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * SVR4 compatibility module.
 *
 * SVR4 system calls that are implemented differently in BSD are
 * handled here.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/exec.h>
#include <sys/exec_olf.h>
#include <sys/namei.h>
#include <sys/dirent.h>
#include <sys/proc.h>
#include <sys/sched.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/ktrace.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/pool.h>
#include <sys/resource.h>
#include <sys/resourcevar.h>
#include <sys/socket.h>
#include <sys/vnode.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/unistd.h>
#include <sys/times.h>
#include <sys/sem.h>
#include <sys/msg.h>
#include <sys/ptrace.h>
#include <sys/signalvar.h>
#include <sys/specdev.h>

#include <netinet/in.h>
#include <sys/syscallargs.h>

#include <compat/svr4/svr4_types.h>
#include <compat/svr4/svr4_signal.h>
#include <compat/svr4/svr4_syscallargs.h>
#include <compat/svr4/svr4_util.h>
#include <compat/svr4/svr4_time.h>
#include <compat/svr4/svr4_dirent.h>
#include <compat/svr4/svr4_ulimit.h>
#include <compat/svr4/svr4_hrt.h>
#include <compat/svr4/svr4_wait.h>
#include <compat/svr4/svr4_statvfs.h>
#include <compat/svr4/svr4_sysconfig.h>
#include <compat/svr4/svr4_acl.h>

#include <compat/common/compat_dir.h>

#include <uvm/uvm_extern.h>

static __inline clock_t timeval_to_clock_t(struct timeval *);
static int svr4_setinfo(struct proc *, int, svr4_siginfo_t *);

struct svr4_hrtcntl_args;
static int svr4_hrtcntl(struct proc *, struct svr4_hrtcntl_args *,
    register_t *);
static void bsd_statfs_to_svr4_statvfs(const struct statfs *,
    struct svr4_statvfs *);
static void bsd_statfs_to_svr4_statvfs64(const struct statfs *,
    struct svr4_statvfs64 *);
static struct process *svr4_prfind(pid_t pid);

static int svr4_mknod(struct proc *, register_t *, char *,
			   svr4_mode_t, svr4_dev_t);

int
svr4_sys_wait(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_wait_args *uap = v;
	struct sys_wait4_args w4;
	int error;
	size_t sz = sizeof(*SCARG(&w4, status));

	SCARG(&w4, rusage) = NULL;
	SCARG(&w4, options) = 0;

	if (SCARG(uap, status) == NULL) {
		caddr_t sg = stackgap_init(p->p_emul);
		SCARG(&w4, status) = stackgap_alloc(&sg, sz);
	}
	else
		SCARG(&w4, status) = SCARG(uap, status);

	SCARG(&w4, pid) = WAIT_ANY;

	if ((error = sys_wait4(p, &w4, retval)) != 0)
		return error;

	/*
	 * It looks like wait(2) on svr4/solaris/2.4 returns
	 * the status in retval[1], and the pid on retval[0].
	 * NB: this can break if register_t stops being an int.
	 */
	return copyin(SCARG(&w4, status), &retval[1], sz);
}


int
svr4_sys_execv(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_execv_args /* {
		syscallarg(char *) path;
		syscallarg(char **) argv;
	} */ *uap = v;
	struct sys_execve_args ap;
	caddr_t sg;

	sg = stackgap_init(p->p_emul);
	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&ap, path) = SCARG(uap, path);
	SCARG(&ap, argp) = SCARG(uap, argp);
	SCARG(&ap, envp) = NULL;

	return sys_execve(p, &ap, retval);
}


int
svr4_sys_execve(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_execve_args /* {
		syscallarg(char *) path;
		syscallarg(char **) argv;
		syscallarg(char **) envp;
        } */ *uap = v;
	struct sys_execve_args ap;
	caddr_t sg;

	sg = stackgap_init(p->p_emul);
	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&ap, path) = SCARG(uap, path);
	SCARG(&ap, argp) = SCARG(uap, argp);
	SCARG(&ap, envp) = SCARG(uap, envp);

	return sys_execve(p, &ap, retval);
}


int
svr4_sys_time(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_time_args *uap = v;
	int error = 0;
	struct timeval tv;

	microtime(&tv);
	if (SCARG(uap, t))
		error = copyout(&tv.tv_sec, SCARG(uap, t),
				sizeof(*(SCARG(uap, t))));
	*retval = (int) tv.tv_sec;

	return error;
}


/*
 * Read SVR4-style directory entries.  We suck them into kernel space so
 * that they can be massaged before being copied out to user code.  Like
 * SunOS, we squish out `empty' entries.
 *
 * This is quite ugly, but what do you expect from compatibility code?
 */

int svr4_readdir_callback(void *, struct dirent *, off_t);
int svr4_readdir64_callback(void *, struct dirent *, off_t);

struct svr4_readdir_callback_args {
	caddr_t outp;
	int     resid;
};

int
svr4_readdir_callback(arg, bdp, cookie)
	void *arg;
	struct dirent *bdp;
	off_t cookie;
{
	struct svr4_dirent idb;
	struct svr4_readdir_callback_args *cb = arg; 
	int svr4_reclen;
	int error;

	svr4_reclen = SVR4_RECLEN(&idb, bdp->d_namlen);
	if (cb->resid < svr4_reclen)
		return (ENOMEM);

	idb.d_ino = (svr4_ino_t)bdp->d_fileno;
	idb.d_off = (svr4_off_t)cookie;
	idb.d_reclen = (u_short)svr4_reclen;
	strlcpy(idb.d_name, bdp->d_name, sizeof(idb.d_name));
	if ((error = copyout((caddr_t)&idb, cb->outp, svr4_reclen)))
		return (error);

	cb->outp += svr4_reclen;
	cb->resid -= svr4_reclen;

	return (0);
}

int
svr4_readdir64_callback(arg, bdp, cookie)
	void *arg;
	struct dirent *bdp;
	off_t cookie;
{
	struct svr4_dirent64 idb;
	struct svr4_readdir_callback_args *cb = arg; 
	int svr4_reclen;
	int error;

	svr4_reclen = SVR4_RECLEN(&idb, bdp->d_namlen);
	if (cb->resid < svr4_reclen)
		return (ENOMEM);

	/*
	 * Massage in place to make a SVR4-shaped dirent (otherwise
	 * we have to worry about touching user memory outside of
	 * the copyout() call).
	 */
	idb.d_ino = (svr4_ino64_t)bdp->d_fileno;
	idb.d_off = (svr4_off64_t)cookie;
	idb.d_reclen = (u_short)svr4_reclen;
	strlcpy(idb.d_name, bdp->d_name, sizeof(idb.d_name));
	if ((error = copyout((caddr_t)&idb, cb->outp, svr4_reclen)))
		return (error);

	cb->outp += svr4_reclen;
	cb->resid -= svr4_reclen;

	return (0);
}


int
svr4_sys_getdents(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_getdents_args *uap = v;
	struct svr4_readdir_callback_args args;
	struct file *fp;
	int error;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	args.resid = SCARG(uap, nbytes);
	args.outp = (caddr_t)SCARG(uap, buf);

	error = readdir_with_callback(fp, &fp->f_offset, SCARG(uap, nbytes),
	    svr4_readdir_callback, &args);
	FRELE(fp);
	if (error)
		return (error);

	*retval = SCARG(uap, nbytes) - args.resid;

	return (0);
}

int
svr4_sys_getdents64(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_getdents64_args *uap = v;
	struct svr4_readdir_callback_args args;
	struct file *fp;
	int error;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	args.resid = SCARG(uap, nbytes);
	args.outp = (caddr_t)SCARG(uap, dp);

	error = readdir_with_callback(fp, &fp->f_offset, SCARG(uap, nbytes),
	    svr4_readdir64_callback, &args);
	FRELE(fp);
	if (error)
		return (error);

	*retval = SCARG(uap, nbytes) - args.resid;

	return (0);
}

int
svr4_sys_mmap(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_mmap_args	*uap = v;
	struct sys_mmap_args	 mm;
	void			*rp;
#define _MAP_NEW	0x80000000
	/*
         * Verify the arguments.
         */
	if (SCARG(uap, prot) & ~(PROT_READ | PROT_WRITE | PROT_EXEC))
		return EINVAL;	/* XXX still needed? */

	if (SCARG(uap, len) == 0)
		return EINVAL;

	SCARG(&mm, prot) = SCARG(uap, prot);
	SCARG(&mm, len) = SCARG(uap, len);
	SCARG(&mm, flags) = SCARG(uap, flags) & ~_MAP_NEW;
	SCARG(&mm, fd) = SCARG(uap, fd);
	SCARG(&mm, addr) = SCARG(uap, addr);
	SCARG(&mm, pos) = SCARG(uap, pos);

	rp = (void *) round_page((vaddr_t)p->p_vmspace->vm_daddr + BRKSIZ);
	if ((SCARG(&mm, flags) & MAP_FIXED) == 0 &&
	    SCARG(&mm, addr) != 0 && SCARG(&mm, addr) < rp)
		SCARG(&mm, addr) = rp;

	return sys_mmap(p, &mm, retval);
}

int
svr4_sys_mmap64(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_mmap64_args	*uap = v;
	struct sys_mmap_args	 mm;
	void			*rp;
#define _MAP_NEW	0x80000000
	/*
         * Verify the arguments.
         */
	if (SCARG(uap, prot) & ~(PROT_READ | PROT_WRITE | PROT_EXEC))
		return EINVAL;	/* XXX still needed? */

	if (SCARG(uap, len) == 0)
		return EINVAL;

	SCARG(&mm, prot) = SCARG(uap, prot);
	SCARG(&mm, len) = SCARG(uap, len);
	SCARG(&mm, flags) = SCARG(uap, flags) & ~_MAP_NEW;
	SCARG(&mm, fd) = SCARG(uap, fd);
	SCARG(&mm, addr) = SCARG(uap, addr);
	SCARG(&mm, pos) = SCARG(uap, pos);

	rp = (void *) round_page((vaddr_t)p->p_vmspace->vm_daddr + BRKSIZ);
	if ((SCARG(&mm, flags) & MAP_FIXED) == 0 &&
	    SCARG(&mm, addr) != 0 && SCARG(&mm, addr) < rp)
		SCARG(&mm, addr) = rp;

	return sys_mmap(p, &mm, retval);
}

int
svr4_sys_fchroot(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_fchroot_args *uap = v;
	struct filedesc	*fdp = p->p_fd;
	struct vnode	*vp;
	struct file	*fp;
	int		 error;

	if ((error = suser(p, 0)) != 0)
		return error;
	if ((error = getvnode(fdp, SCARG(uap, fd), &fp)) != 0)
		return error;

	vp = (struct vnode *) fp->f_data;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_type != VDIR)
		error = ENOTDIR;
	else
		error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p);
	VOP_UNLOCK(vp, 0, p);
	if (error) {
		FRELE(fp);
		return error;
	}
	vref(vp);
	if (fdp->fd_rdir != NULL)
		vrele(fdp->fd_rdir);
	fdp->fd_rdir = vp;
	FRELE(fp);
	return 0;
}

static int
svr4_mknod(p, retval, path, mode, dev)
	struct proc *p;
	register_t *retval;
	char *path;
	svr4_mode_t mode;
	svr4_dev_t dev;
{
	caddr_t sg = stackgap_init(p->p_emul);

	SVR4_CHECK_ALT_EXIST(p, &sg, path);

	if (S_ISFIFO(mode)) {
		struct sys_mkfifo_args ap;
		SCARG(&ap, path) = path;
		SCARG(&ap, mode) = mode;
		return sys_mkfifo(p, &ap, retval);
	} else {
		struct sys_mknod_args ap;
		SCARG(&ap, path) = path;
		SCARG(&ap, mode) = mode;
		SCARG(&ap, dev) = dev;
		return sys_mknod(p, &ap, retval);
	}
}


int
svr4_sys_mknod(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_mknod_args *uap = v;
	return svr4_mknod(p, retval,
			  SCARG(uap, path), SCARG(uap, mode),
			  svr4_to_bsd_odev_t(SCARG(uap, dev)));
}


int
svr4_sys_xmknod(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_xmknod_args *uap = v;
	return svr4_mknod(p, retval,
			  SCARG(uap, path), SCARG(uap, mode),
			  svr4_to_bsd_dev_t(SCARG(uap, dev)));
}


int
svr4_sys_vhangup(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	return 0;
}


int
svr4_sys_sysconfig(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_sysconfig_args *uap = v;
	extern int	maxfiles;

	switch (SCARG(uap, name)) {
	case SVR4_CONFIG_UNUSED:
		*retval = 0;
		break;
	case SVR4_CONFIG_NGROUPS:
		*retval = NGROUPS_MAX;
		break;
	case SVR4_CONFIG_CHILD_MAX:
		*retval = maxproc;
		break;
	case SVR4_CONFIG_OPEN_FILES:
		*retval = maxfiles;
		break;
	case SVR4_CONFIG_POSIX_VER:
		*retval = 198808;
		break;
	case SVR4_CONFIG_PAGESIZE:
		*retval = NBPG;
		break;
	case SVR4_CONFIG_CLK_TCK:
		*retval = 60;	/* should this be `hz', ie. 100? */
		break;
	case SVR4_CONFIG_XOPEN_VER:
		*retval = 2;	/* XXX: What should that be? */
		break;
	case SVR4_CONFIG_PROF_TCK:
		*retval = 60;	/* XXX: What should that be? */
		break;
	case SVR4_CONFIG_NPROC_CONF:
		*retval = 1;	/* Only one processor for now */
		break;
	case SVR4_CONFIG_NPROC_ONLN:
		*retval = 1;	/* And it better be online */
		break;
	case SVR4_CONFIG_AIO_LISTIO_MAX:
	case SVR4_CONFIG_AIO_MAX:
	case SVR4_CONFIG_AIO_PRIO_DELTA_MAX:
		*retval = 0;	/* No aio support */
		break;
	case SVR4_CONFIG_DELAYTIMER_MAX:
		*retval = 0;	/* No delaytimer support */
		break;
#ifdef SYSVMSG
	case SVR4_CONFIG_MQ_OPEN_MAX:
		*retval = msginfo.msgmni;
		break;
#endif
	case SVR4_CONFIG_MQ_PRIO_MAX:
		*retval = 0;	/* XXX: Don't know */
		break;
	case SVR4_CONFIG_RTSIG_MAX:
		*retval = 0;
		break;
#ifdef SYSVSEM
	case SVR4_CONFIG_SEM_NSEMS_MAX:
		*retval = seminfo.semmni;
		break;
	case SVR4_CONFIG_SEM_VALUE_MAX:
		*retval = seminfo.semvmx;
		break;
#endif
	case SVR4_CONFIG_SIGQUEUE_MAX:
		*retval = 0;	/* XXX: Don't know */
		break;
	case SVR4_CONFIG_SIGRT_MIN:
	case SVR4_CONFIG_SIGRT_MAX:
		*retval = 0;	/* No real time signals */
		break;
	case SVR4_CONFIG_TIMER_MAX:
		*retval = 3;	/* XXX: real, virtual, profiling */
		break;
	case SVR4_CONFIG_PHYS_PAGES:
		*retval = uvmexp.npages;
		break;
	case SVR4_CONFIG_AVPHYS_PAGES:
		*retval = uvmexp.active;	/* XXX: active instead of avg */
		break;
	default:
		return EINVAL;
	}
	return 0;
}

#define SVR4_RLIMIT_NOFILE	5	/* Other RLIMIT_* are the same */
#define SVR4_RLIMIT_VMEM	6	/* Other RLIMIT_* are the same */
#define SVR4_RLIM_NLIMITS	7

int
svr4_sys_getrlimit(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_getrlimit_args *uap = v;
	struct compat_43_sys_getrlimit_args ap;

	if (SCARG(uap, which) >= SVR4_RLIM_NLIMITS)
		return EINVAL;

	if (SCARG(uap, which) == SVR4_RLIMIT_NOFILE)
		SCARG(uap, which) = RLIMIT_NOFILE;
	if (SCARG(uap, which) == SVR4_RLIMIT_VMEM)
		SCARG(uap, which) = RLIMIT_RSS;

	SCARG(&ap, which) = SCARG(uap, which);
	SCARG(&ap, rlp) = SCARG(uap, rlp);

	return compat_43_sys_getrlimit(p, &ap, retval);
}

int
svr4_sys_setrlimit(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_setrlimit_args *uap = v;
	struct compat_43_sys_setrlimit_args ap;

	if (SCARG(uap, which) >= SVR4_RLIM_NLIMITS)
		return EINVAL;

	if (SCARG(uap, which) == SVR4_RLIMIT_NOFILE)
		SCARG(uap, which) = RLIMIT_NOFILE;
	if (SCARG(uap, which) == SVR4_RLIMIT_VMEM)
		SCARG(uap, which) = RLIMIT_RSS;

	SCARG(&ap, which) = SCARG(uap, which);
	SCARG(&ap, rlp) = SCARG(uap, rlp);

	return compat_43_sys_setrlimit(p, uap, retval);
}


/* ARGSUSED */
int
svr4_sys_break(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_break_args *uap = v;
	register struct vmspace *vm = p->p_vmspace;
	vaddr_t		new, old;
	int             error;
	register int    diff;

	old = (vaddr_t) vm->vm_daddr;
	new = round_page((vaddr_t)SCARG(uap, nsize));
	diff = new - old;

	DPRINTF(("break(1): old %lx new %lx diff %x\n", old, new, diff));

	if (diff > p->p_rlimit[RLIMIT_DATA].rlim_cur)
		return ENOMEM;

	old = round_page(old + ptoa(vm->vm_dsize));
	DPRINTF(("break(2): dsize = %x ptoa %x\n",
		 vm->vm_dsize, ptoa(vm->vm_dsize)));

	diff = new - old;
	DPRINTF(("break(3): old %lx new %lx diff %x\n", old, new, diff));

	if (diff > 0) {
		error = uvm_map(&vm->vm_map, &old, diff, NULL, UVM_UNKNOWN_OFFSET,
			0, UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_COPY,
				    UVM_ADV_NORMAL,
				    UVM_FLAG_AMAPPAD|UVM_FLAG_FIXED|
				    UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW));
		if (error) {
			uprintf("sbrk: grow failed, return = %d\n", error);
			return error;
		}
		vm->vm_dsize += atop(diff);
	} else if (diff < 0) {
		diff = -diff;
		uvm_deallocate(&vm->vm_map, new, diff);
		vm->vm_dsize -= atop(diff);
	}
	return 0;
}

static __inline clock_t
timeval_to_clock_t(tv)
	struct timeval *tv;
{
	return tv->tv_sec * hz + tv->tv_usec / (1000000 / hz);
}

int
svr4_sys_times(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_times_args *uap = v;
	int			 error;
	struct tms		 tms;
	struct timeval		 t;
	struct rusage		*ru;
	struct rusage		 r;
	struct sys_getrusage_args 	 ga;

	caddr_t sg = stackgap_init(p->p_emul);
	ru = stackgap_alloc(&sg, sizeof(struct rusage));

	SCARG(&ga, who) = RUSAGE_SELF;
	SCARG(&ga, rusage) = ru;

	error = sys_getrusage(p, &ga, retval);
	if (error)
		return error;

	if ((error = copyin(ru, &r, sizeof r)) != 0)
		return error;

	tms.tms_utime = timeval_to_clock_t(&r.ru_utime);
	tms.tms_stime = timeval_to_clock_t(&r.ru_stime);

	SCARG(&ga, who) = RUSAGE_CHILDREN;
	error = sys_getrusage(p, &ga, retval);
	if (error)
		return error;

	if ((error = copyin(ru, &r, sizeof r)) != 0)
		return error;

	tms.tms_cutime = timeval_to_clock_t(&r.ru_utime);
	tms.tms_cstime = timeval_to_clock_t(&r.ru_stime);

	microtime(&t);
	*retval = timeval_to_clock_t(&t);

	return copyout(&tms, SCARG(uap, tp), sizeof(tms));
}


int
svr4_sys_ulimit(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_ulimit_args *uap = v;

	switch (SCARG(uap, cmd)) {
	case SVR4_GFILLIM:
		*retval = p->p_rlimit[RLIMIT_FSIZE].rlim_cur / 512;
		return 0;

	case SVR4_SFILLIM:
		{
			int error;
			struct sys_setrlimit_args srl;
			struct rlimit krl;
			caddr_t sg = stackgap_init(p->p_emul);
			struct rlimit *url = (struct rlimit *) 
				stackgap_alloc(&sg, sizeof *url);

			krl.rlim_cur = SCARG(uap, newlimit) * 512;
			krl.rlim_max = p->p_rlimit[RLIMIT_FSIZE].rlim_max;

			error = copyout(&krl, url, sizeof(*url));
			if (error)
				return error;

			SCARG(&srl, which) = RLIMIT_FSIZE;
			SCARG(&srl, rlp) = url;

			error = sys_setrlimit(p, &srl, retval);
			if (error)
				return error;

			*retval = p->p_rlimit[RLIMIT_FSIZE].rlim_cur;
			return 0;
		}

	case SVR4_GMEMLIM:
		{
			struct vmspace *vm = p->p_vmspace;
			*retval = (long) vm->vm_daddr +
				  p->p_rlimit[RLIMIT_DATA].rlim_cur;
			return 0;
		}

	case SVR4_GDESLIM:
		*retval = p->p_rlimit[RLIMIT_NOFILE].rlim_cur;
		return 0;

	default:
		return EINVAL;
	}
}


static struct process *
svr4_prfind(pid_t pid)
{
	struct process *pr;
	struct proc *p;

	/* look in the live processes */
	if ((pr = prfind(pid)) != NULL)
		return pr;

	/* look in the zombies */
	LIST_FOREACH(p, &zombproc, p_list)
		if (p->p_pid == pid)
			return p->p_flag & P_THREAD ? NULL : p->p_p;

	return NULL;
}


int
svr4_sys_pgrpsys(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_pgrpsys_args *uap = v;
	struct process *pr = p->p_p;
	int error;

	switch (SCARG(uap, cmd)) {
	case 0:			/* getpgrp() */
		*retval = pr->ps_pgrp->pg_id;
		return 0;

	case 1:			/* setpgrp() */
		{
			struct sys_setpgid_args sa;

			SCARG(&sa, pid) = 0;
			SCARG(&sa, pgid) = 0;
			if ((error = sys_setpgid(p, &sa, retval)) != 0)
				return error;
			*retval = pr->ps_pgrp->pg_id;
			return 0;
		}

	case 2:			/* getsid(pid) */
		if (SCARG(uap, pid) != 0 &&
		    (pr = svr4_prfind(SCARG(uap, pid))) == NULL)
			return ESRCH;
		/* 
		 * we return the pid of the session leader for this
		 * process
		 */
		*retval = (register_t)pr->ps_session->s_leader->ps_pid;
		return 0;

	case 3:			/* setsid() */
		return sys_setsid(p, NULL, retval);

	case 4:			/* getpgid(pid) */

		if (SCARG(uap, pid) != 0 &&
		    (pr = svr4_prfind(SCARG(uap, pid))) == NULL)
			return ESRCH;

		*retval = (int)pr->ps_pgrp->pg_id;
		return 0;

	case 5:			/* setpgid(pid, pgid); */
		{
			struct sys_setpgid_args sa;

			SCARG(&sa, pid) = SCARG(uap, pid);
			SCARG(&sa, pgid) = SCARG(uap, pgid);
			return sys_setpgid(p, &sa, retval);
		}

	default:
		return EINVAL;
	}
}

struct svr4_hrtcntl_args {
	syscallarg(int) 			cmd;
	syscallarg(int) 			fun;
	syscallarg(int) 			clk;
	syscallarg(svr4_hrt_interval_t *)	iv;
	syscallarg(svr4_hrt_time_t *)		ti;
};

static int
svr4_hrtcntl(p, uap, retval)
	register struct proc *p;
	register struct svr4_hrtcntl_args *uap;
	register_t *retval;
{
	switch (SCARG(uap, fun)) {
	case SVR4_HRT_CNTL_RES:
		DPRINTF(("htrcntl(RES)\n"));
		*retval = SVR4_HRT_USEC;
		return 0;

	case SVR4_HRT_CNTL_TOFD:
		DPRINTF(("htrcntl(TOFD)\n"));
		{
			struct timeval tv;
			svr4_hrt_time_t t;
			if (SCARG(uap, clk) != SVR4_HRT_CLK_STD) {
				DPRINTF(("clk == %d\n", SCARG(uap, clk)));
				return EINVAL;
			}
			if (SCARG(uap, ti) == NULL) {
				DPRINTF(("ti NULL\n"));
				return EINVAL;
			}
			microtime(&tv);
			t.h_sec = tv.tv_sec;
			t.h_rem = tv.tv_usec;
			t.h_res = SVR4_HRT_USEC;
			return copyout(&t, SCARG(uap, ti), sizeof(t));
		}

	case SVR4_HRT_CNTL_START:
		DPRINTF(("htrcntl(START)\n"));
		return ENOSYS;

	case SVR4_HRT_CNTL_GET:
		DPRINTF(("htrcntl(GET)\n"));
		return ENOSYS;
	default:
		DPRINTF(("Bad htrcntl command %d\n", SCARG(uap, fun)));
		return ENOSYS;
	}
}

int
svr4_sys_hrtsys(p, v, retval) 
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_hrtsys_args *uap = v;

	switch (SCARG(uap, cmd)) {
	case SVR4_HRT_CNTL:
		return svr4_hrtcntl(p, (struct svr4_hrtcntl_args *) uap,
				    retval);

	case SVR4_HRT_ALRM:
		DPRINTF(("hrtalarm\n"));
		return ENOSYS;

	case SVR4_HRT_SLP:
		DPRINTF(("hrtsleep\n"));
		return ENOSYS;

	case SVR4_HRT_CAN:
		DPRINTF(("hrtcancel\n"));
		return ENOSYS;

	default:
		DPRINTF(("Bad hrtsys command %d\n", SCARG(uap, cmd)));
		return EINVAL;
	}
}

static int
svr4_setinfo(p, st, s)
	struct proc *p;
	int st;
	svr4_siginfo_t *s;
{
	svr4_siginfo_t i;

	bzero(&i, sizeof(i));

	i.svr4_si_signo = SVR4_SIGCHLD;
	i.svr4_si_errno = 0;	/* XXX? */

	if (p) {
		i.svr4_si_pid = p->p_pid;
		if (p->p_stat == SZOMB) {
			i.svr4_si_stime = p->p_ru->ru_stime.tv_sec;
			i.svr4_si_utime = p->p_ru->ru_utime.tv_sec;
		} else {
			i.svr4_si_stime = p->p_stats->p_ru.ru_stime.tv_sec;
			i.svr4_si_utime = p->p_stats->p_ru.ru_utime.tv_sec;
		}
	}

	if (WIFEXITED(st)) {
		i.svr4_si_status = WEXITSTATUS(st);
		i.svr4_si_code = SVR4_CLD_EXITED;
	}
	else if (WIFSTOPPED(st)) {
		i.svr4_si_status = bsd_to_svr4_sig[WSTOPSIG(st)];

		if (i.svr4_si_status == SVR4_SIGCONT)
			i.svr4_si_code = SVR4_CLD_CONTINUED;
		else
			i.svr4_si_code = SVR4_CLD_STOPPED;
	} else {
		i.svr4_si_status = bsd_to_svr4_sig[WTERMSIG(st)];

		if (WCOREDUMP(st))
			i.svr4_si_code = SVR4_CLD_DUMPED;
		else
			i.svr4_si_code = SVR4_CLD_KILLED;
	}

	DPRINTF(("siginfo [pid %ld signo %d code %d errno %d status %d]\n",
		 i.svr4_si_pid, i.svr4_si_signo, i.svr4_si_code,
		 i.svr4_si_errno, i.svr4_si_status));

	return copyout(&i, s, sizeof(i));
}


int
svr4_sys_waitsys(q, v, retval) 
	struct proc *q;
	void *v;
	register_t *retval;
{
	struct svr4_sys_waitsys_args *uap = v;
	int nfound;
	int error;
	struct process *pr;
	struct proc *p;

	switch (SCARG(uap, grp)) {
	case SVR4_P_PID:	
		break;

	case SVR4_P_PGID:
		SCARG(uap, id) = -q->p_p->ps_pgid;
		break;

	case SVR4_P_ALL:
		SCARG(uap, id) = WAIT_ANY;
		break;

	default:
		return (EINVAL);
	}

	DPRINTF(("waitsys(%d, %d, %p, %x)\n", SCARG(uap, grp), SCARG(uap, id),
	    SCARG(uap, info), SCARG(uap, options)));

loop:
	nfound = 0;
	LIST_FOREACH(pr, &q->p_p->ps_children, ps_sibling) {
		p = pr->ps_mainproc;
		if (SCARG(uap, id) != WAIT_ANY &&
		    p->p_pid != SCARG(uap, id) &&
		    pr->ps_pgid != -SCARG(uap, id)) {
			DPRINTF(("pid %d pgid %d != %d\n", p->p_pid,
				 pr->ps_pgid, SCARG(uap, id)));
			continue;
		}
		nfound++;
		if (p->p_stat == SZOMB && 
		    ((SCARG(uap, options) & (SVR4_WEXITED|SVR4_WTRAPPED)))) {
			*retval = 0;
			DPRINTF(("found %d\n", p->p_pid));
			error = svr4_setinfo(p, p->p_xstat, SCARG(uap, info));
			if (error)
				return (error);

			if ((SCARG(uap, options) & SVR4_WNOWAIT)) {
				DPRINTF(("Don't wait\n"));
				return (0);
			}
			proc_finish_wait(q, p);
			return (0);
		}
		if (p->p_stat == SSTOP && (p->p_flag & P_WAITED) == 0 &&
		    (p->p_flag & P_TRACED ||
		    (SCARG(uap, options) & (SVR4_WSTOPPED|SVR4_WCONTINUED)))) {
			DPRINTF(("jobcontrol %d\n", p->p_pid));
			if (((SCARG(uap, options) & SVR4_WNOWAIT)) == 0)
				atomic_setbits_int(&p->p_flag, P_WAITED);
			*retval = 0;
			return (svr4_setinfo(p, W_STOPCODE(p->p_xstat),
			   SCARG(uap, info)));
		}
	}

	if (nfound == 0)
		return (ECHILD);

	if (SCARG(uap, options) & SVR4_WNOHANG) {
		*retval = 0;
		if ((error = svr4_setinfo(NULL, 0, SCARG(uap, info))) != 0)
			return (error);
		return (0);
	}

	if ((error = tsleep((caddr_t)q, PWAIT | PCATCH, "svr4_wait", 0)) != 0)
		return (error);
	goto loop;
}

static void
bsd_statfs_to_svr4_statvfs(bfs, sfs)
	const struct statfs *bfs;
	struct svr4_statvfs *sfs;
{
	bzero(sfs, sizeof(*sfs));
	sfs->f_bsize = bfs->f_iosize; /* XXX */
	sfs->f_frsize = bfs->f_bsize;
	sfs->f_blocks = bfs->f_blocks;
	sfs->f_bfree = bfs->f_bfree;
	sfs->f_bavail = bfs->f_bavail;
	sfs->f_files = bfs->f_files;
	sfs->f_ffree = bfs->f_ffree;
	sfs->f_favail = bfs->f_ffree;
	sfs->f_fsid = bfs->f_fsid.val[0];
	bcopy(bfs->f_fstypename, sfs->f_basetype, sizeof(sfs->f_basetype));
	if (bfs->f_flags & MNT_RDONLY)
		sfs->f_flag |= SVR4_ST_RDONLY;
	if (bfs->f_flags & MNT_NOSUID)
		sfs->f_flag |= SVR4_ST_NOSUID;
	sfs->f_namemax = MAXNAMLEN;
	bcopy(bfs->f_fstypename, sfs->f_fstr,
	    MIN(sizeof(bfs->f_fstypename), sizeof(sfs->f_fstr)));
}


static void
bsd_statfs_to_svr4_statvfs64(bfs, sfs)
	const struct statfs *bfs;
	struct svr4_statvfs64 *sfs; 
{
	bzero(sfs, sizeof(*sfs));
	sfs->f_bsize = bfs->f_iosize; /* XXX */
	sfs->f_frsize = bfs->f_bsize;
	sfs->f_blocks = bfs->f_blocks;
	sfs->f_bfree = bfs->f_bfree;
	sfs->f_bavail = bfs->f_bavail;
	sfs->f_files = bfs->f_files;
	sfs->f_ffree = bfs->f_ffree;  
	sfs->f_favail = bfs->f_ffree;
	sfs->f_fsid = bfs->f_fsid.val[0];
	bcopy(bfs->f_fstypename, sfs->f_basetype, sizeof(sfs->f_basetype));
	if (bfs->f_flags & MNT_RDONLY)
		sfs->f_flag |= SVR4_ST_RDONLY;
	if (bfs->f_flags & MNT_NOSUID)
		sfs->f_flag |= SVR4_ST_NOSUID;
	sfs->f_namemax = MAXNAMLEN;   
	bcopy(bfs->f_fstypename, sfs->f_fstr,
	    MIN(sizeof(bfs->f_fstypename), sizeof(sfs->f_fstr)));
}


int
svr4_sys_statvfs(p, v, retval) 
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_statvfs_args *uap = v;
	struct sys_statfs_args	fs_args;
	caddr_t sg = stackgap_init(p->p_emul);
	struct statfs *fs = stackgap_alloc(&sg, sizeof(struct statfs));
	struct statfs bfs;
	struct svr4_statvfs sfs;
	int error;

	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	SCARG(&fs_args, path) = SCARG(uap, path);
	SCARG(&fs_args, buf) = fs;

	if ((error = sys_statfs(p, &fs_args, retval)) != 0)
		return error;

	if ((error = copyin(fs, &bfs, sizeof(bfs))) != 0)
		return error;

	bsd_statfs_to_svr4_statvfs(&bfs, &sfs);

	return copyout(&sfs, SCARG(uap, fs), sizeof(sfs));
}


int
svr4_sys_fstatvfs(p, v, retval) 
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_fstatvfs_args *uap = v;
	struct sys_fstatfs_args	fs_args;
	caddr_t sg = stackgap_init(p->p_emul);
	struct statfs *fs = stackgap_alloc(&sg, sizeof(struct statfs));
	struct statfs bfs;
	struct svr4_statvfs sfs;
	int error;

	SCARG(&fs_args, fd) = SCARG(uap, fd);
	SCARG(&fs_args, buf) = fs;

	if ((error = sys_fstatfs(p, &fs_args, retval)) != 0)
		return error;

	if ((error = copyin(fs, &bfs, sizeof(bfs))) != 0)
		return error;

	bsd_statfs_to_svr4_statvfs(&bfs, &sfs);

	return copyout(&sfs, SCARG(uap, fs), sizeof(sfs));
}


int
svr4_sys_fstatvfs64(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_fstatvfs64_args *uap = v;
	struct sys_fstatfs_args fs_args;
	caddr_t sg = stackgap_init(p->p_emul);
	struct statfs *fs = stackgap_alloc(&sg, sizeof(struct statfs));
	struct statfs bfs;
	struct svr4_statvfs64 sfs;
	int error;

	SCARG(&fs_args, fd) = SCARG(uap, fd);
	SCARG(&fs_args, buf) = fs;

	if ((error = sys_fstatfs(p, &fs_args, retval)) != 0)
		return error;

	if ((error = copyin(fs, &bfs, sizeof(bfs))) != 0)
		return error;

	bsd_statfs_to_svr4_statvfs64(&bfs, &sfs);

	return copyout(&sfs, SCARG(uap, fs), sizeof(sfs));
}


int
svr4_sys_alarm(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_alarm_args *uap = v;
	int error;
        struct itimerval *ntp, *otp, tp;
	struct sys_setitimer_args sa;
	caddr_t sg = stackgap_init(p->p_emul);

        ntp = stackgap_alloc(&sg, sizeof(struct itimerval));
        otp = stackgap_alloc(&sg, sizeof(struct itimerval));

        timerclear(&tp.it_interval);
        tp.it_value.tv_sec = SCARG(uap, sec);
        tp.it_value.tv_usec = 0;

	if ((error = copyout(&tp, ntp, sizeof(tp))) != 0)
		return error;

	SCARG(&sa, which) = ITIMER_REAL;
	SCARG(&sa, itv) = ntp;
	SCARG(&sa, oitv) = otp;

        if ((error = sys_setitimer(p, &sa, retval)) != 0)
		return error;

	if ((error = copyin(otp, &tp, sizeof(tp))) != 0)
		return error;

        if (tp.it_value.tv_usec)
                tp.it_value.tv_sec++;

        *retval = (register_t) tp.it_value.tv_sec;

        return 0;
}


int
svr4_sys_gettimeofday(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_gettimeofday_args *uap = v;

	if (SCARG(uap, tp)) {
		struct timeval atv;

		microtime(&atv);
		return copyout(&atv, SCARG(uap, tp), sizeof (atv));
	}

	return 0;
}

int
svr4_sys_facl(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_facl_args *uap = v;

	*retval = 0;

	switch (SCARG(uap, cmd)) {
	case SVR4_SYS_SETACL:
		/* We don't support acls on any filesystem */
		return ENOSYS;

	case SVR4_SYS_GETACL:
		return copyout(retval, &SCARG(uap, num),
		    sizeof(SCARG(uap, num)));

	case SVR4_SYS_GETACLCNT:
		return 0;

	default:
		return EINVAL;
	}
}

int
svr4_sys_acl(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	return svr4_sys_facl(p, v, retval);	/* XXX: for now the same */
}

int
svr4_sys_auditsys(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	/*
	 * XXX: Big brother is *not* watching.
	 */
	return 0;
}

int
svr4_sys_memcntl(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_memcntl_args *uap = v;
	struct sys_mprotect_args ap;

	SCARG(&ap, addr) = SCARG(uap, addr);
	SCARG(&ap, len) = SCARG(uap, len);
	SCARG(&ap, prot) = SCARG(uap, attr);

	/* XXX: no locking, invalidating, or syncing supported */
	return sys_mprotect(p, &ap, retval);
}

int
svr4_sys_nice(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_nice_args *uap = v;
	struct sys_setpriority_args ap;
	int error;

	SCARG(&ap, which) = PRIO_PROCESS;
	SCARG(&ap, who) = 0;
	SCARG(&ap, prio) = SCARG(uap, prio);

	if ((error = sys_setpriority(p, &ap, retval)) != 0)
		return error;

	if ((error = sys_getpriority(p, &ap, retval)) != 0)
		return error;

	return 0;
}

/* ARGSUSED */
int
svr4_sys_setegid(p, v, retval)
        struct proc *p;
        void *v;
        register_t *retval;
{
        struct sys_setegid_args /* {
		syscallarg(gid_t) egid;
        } */ *uap = v;

#if defined(COMPAT_LINUX) && defined(__i386__)
	if (SCARG(uap, egid) > 60000) {
		/*
		 * One great fuckup deserves another.  The Linux people
		 * made this their personality system call.  But we can't
		 * tell if a binary is SVR4 or Linux until they do that
		 * system call, in some cases.  So when we get it, and the
		 * value is out of some magical range, switch to Linux
		 * emulation and pray.
		 */
		extern struct emul emul_linux_elf;

		p->p_emul = &emul_linux_elf;
		p->p_os = OOS_LINUX;
#ifdef KTRACE
		if (KTRPOINT(p, KTR_EMUL))
			ktremul(p, p->p_emul->e_name);
#endif
		return (0);
	}
#else
	(void)uap;
#endif
        return (sys_setegid(p, v, retval));
}

int
svr4_sys_rdebug(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#ifdef COMPAT_SVR4_NCR
	return (ENXIO);
#else
	return (p->p_os == OOS_NCR ? ENXIO : sys_nosys(p, v, retval));
#endif
}
@


1.57
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.56 2010/12/15 04:59:52 tedu Exp $	 */
@


1.56
log
@add a BRKSIZ define and use it for the heap gap constant, decoupling
heap gap from max data size.  nothing else changes yet.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.55 2010/07/26 01:56:27 guenther Exp $	 */
d71 1
a74 2

#include <miscfs/specfs/specdev.h>
@


1.55
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.54 2010/05/25 16:39:15 thib Exp $	 */
d373 1
a373 1
	rp = (void *) round_page((vaddr_t)p->p_vmspace->vm_daddr + MAXDSIZ);
d407 1
a407 1
	rp = (void *) round_page((vaddr_t)p->p_vmspace->vm_daddr + MAXDSIZ);
@


1.54
log
@Fix previous. s/sfs->f_typename/bfs->fs_typename and
add a missing ')'.

i386 can now build kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.53 2010/05/25 15:25:17 millert Exp $	 */
d104 1
a104 1
static struct proc *svr4_pfind(pid_t pid);
d818 2
a819 3
static struct proc *
svr4_pfind(pid)
	pid_t pid;
d821 1
d825 2
a826 2
	if ((p = pfind(pid)) != NULL)
		return p;
d831 1
a831 1
			return p;
d844 1
d849 1
a849 1
		*retval = p->p_pgrp->pg_id;
d860 1
a860 1
			*retval = p->p_pgrp->pg_id;
d866 1
a866 1
		    (p = svr4_pfind(SCARG(uap, pid))) == NULL)
d872 1
a872 1
		*retval = (register_t) p->p_session->s_leader->p_pid;
d881 1
a881 1
		    (p = svr4_pfind(SCARG(uap, pid))) == NULL)
d884 1
a884 1
		*retval = (int) p->p_pgrp->pg_id;
d1046 1
d1054 1
a1054 1
		SCARG(uap, id) = -q->p_pgid;
d1070 2
a1071 1
	LIST_FOREACH(p, &q->p_children, p_sibling) {
d1074 1
a1074 1
		    p->p_pgid != -SCARG(uap, id)) {
d1076 1
a1076 1
				 p->p_pgid, SCARG(uap, id)));
@


1.53
log
@Zero out svr4_statvfs and svr4_statvfs64 before using and copy the
correct number of bytes into f_fstr.  OK kettenis@@ deraadt@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.52 2010/04/28 21:31:59 kettenis Exp $	 */
d1141 1
a1141 1
	    MIN(sizeof(sfs->f_fstypename), sizeof(sfs->f_fstr));
d1167 1
a1167 1
	    MIN(sizeof(sfs->f_fstypename), sizeof(sfs->f_fstr));
@


1.52
log
@s/i386/__i386__/, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.51 2009/12/20 23:36:04 guenther Exp $	 */
d1124 1
a1134 1
	sfs->f_flag = 0;
d1140 2
a1141 2
	bcopy(bfs->f_fstypename, sfs->f_fstr, sizeof(sfs->f_fstr)); /* XXX */
	bzero(sfs->f_filler, sizeof(sfs->f_filler));
d1150 1
a1160 1
	sfs->f_flag = 0;
d1166 2
a1167 2
	bcopy(bfs->f_fstypename, sfs->f_fstr, sizeof(sfs->f_fstr)); /* XXX */
	bzero(sfs->f_filler, sizeof(sfs->f_filler));
@


1.51
log
@svr4_sys_waitsys() was seemingly implemented by copying sys_wait4()
and hacking on it.  Since then, some of the details of finishing a
wait have changed (p_exitsig handling), so factor out the common
bit into into proc_finish_wait() and have both sys_wait4() and
svr4_sys_waitsys() call that to kill the divergence.

"looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.50 2009/07/09 22:29:55 thib Exp $	 */
d1417 1
a1417 1
#if defined(COMPAT_LINUX) && defined(i386)
@


1.50
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.48 2007/09/01 15:14:44 martin Exp $	 */
d1045 1
a1045 1
	struct proc *p, *t;
d1089 1
a1089 18

			/*
			 * If we got the child via a ptrace 'attach',
			 * we need to give it back to the old parent.
			 */
			if (p->p_oppid && (t = pfind(p->p_oppid))) {
				p->p_oppid = 0;
				proc_reparent(p, t);
				psignal(t, SIGCHLD);
				wakeup((caddr_t)t);
				return (0);
			}

			scheduler_wait_hook(q, p);
			p->p_xstat = 0;
			ruadd(&q->p_stats->p_cru, p->p_ru);

			proc_zap(p);
@


1.49
log
@more btoc -> atop
@
text
@d443 1
a443 1
	VREF(vp);
@


1.48
log
@replace the machine dependant bytes-to-clicks macro by the MI ptoa()
version for i386

more architectures and ctob() replacement is being worked on

prodded by and ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.47 2007/03/15 10:22:30 art Exp $	 */
d696 1
a696 1
		vm->vm_dsize += btoc(diff);
d700 1
a700 1
		vm->vm_dsize -= btoc(diff);
@


1.47
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.46 2006/05/23 20:34:22 miod Exp $	 */
d679 3
a681 3
	old = round_page(old + ctob(vm->vm_dsize));
	DPRINTF(("break(2): dsize = %x ctob %x\n",
		 vm->vm_dsize, ctob(vm->vm_dsize)));
@


1.46
log
@Compile if no option SYSVMSG.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.45 2006/03/05 21:48:56 miod Exp $	 */
d1114 1
a1114 1
				p->p_flag |= P_WAITED;
@


1.45
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.44 2004/06/22 23:52:18 jfb Exp $	 */
d565 1
d569 1
@


1.44
log
@Replace a whole bunch of scary uses of strncpy() with strlcpy() and
use compat-specific MAXNAMLEN values where appropriate

ok millert@@, pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.43 2003/08/15 20:32:16 tedu Exp $	 */
d827 1
a827 1
	for (p = zombproc.lh_first; p != 0; p = p->p_list.le_next)
d1066 1
a1066 1
	for (p = q->p_children.lh_first; p != 0; p = p->p_sibling.le_next) {
@


1.43
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.42 2002/08/23 15:39:31 art Exp $	 */
d247 1
a247 1
	strlcpy(idb.d_name, bdp->d_name, SVR4_MAXNAMLEN+1);
d280 1
a280 1
	strlcpy(idb.d_name, bdp->d_name, SVR4_MAXNAMLEN+1);
@


1.42
log
@Cleanup change. Since almost all callers (except one) of getvnode did a FREF
on the returned file, do the FREF inside getvnode so that people can't
get away with avoiding FREF and FRELE.

Eyeballed by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.41 2002/03/14 01:26:51 millert Exp $	 */
d427 1
a427 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.41
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.40 2002/02/12 22:13:22 deraadt Exp $	 */
a307 1
	FREF(fp);
a335 1
	FREF(fp);
d431 1
a431 1
	FREF(fp);
@


1.40
log
@test before commit
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.39 2002/02/12 18:41:21 art Exp $	 */
d94 2
a95 2
static __inline clock_t timeval_to_clock_t __P((struct timeval *));
static int svr4_setinfo	__P((struct proc *, int, svr4_siginfo_t *));
d98 7
a104 7
static int svr4_hrtcntl	__P((struct proc *, struct svr4_hrtcntl_args *,
    register_t *));
static void bsd_statfs_to_svr4_statvfs __P((const struct statfs *,
    struct svr4_statvfs *));
static void bsd_statfs_to_svr4_statvfs64 __P((const struct statfs *,
    struct svr4_statvfs64 *));
static struct proc *svr4_pfind __P((pid_t pid));
d106 2
a107 2
static int svr4_mknod __P((struct proc *, register_t *, char *,
			   svr4_mode_t, svr4_dev_t));
d221 2
a222 2
int svr4_readdir_callback __P((void *, struct dirent *, off_t));
int svr4_readdir64_callback __P((void *, struct dirent *, off_t));
@


1.39
log
@More FREF/FRELE protection. This time all users of getvnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.38 2001/11/28 13:47:39 art Exp $	 */
d339 1
a339 1
	    svr4_readdir64_callback, &args)) != 0)
@


1.38
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.37 2001/11/07 01:18:01 art Exp $	 */
d307 6
a312 3
	
	if ((error = readdir_with_callback(fp, &fp->f_offset, SCARG(uap, nbytes),
	    svr4_readdir_callback, &args)) != 0)
d336 3
a338 2
	
	if ((error = readdir_with_callback(fp, &fp->f_offset, SCARG(uap, nbytes),
d340 2
d433 1
d441 2
a442 1
	if (error)
d444 1
d449 1
@


1.38.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.38 2001/11/28 13:47:39 art Exp $	 */
d94 2
a95 2
static __inline clock_t timeval_to_clock_t(struct timeval *);
static int svr4_setinfo(struct proc *, int, svr4_siginfo_t *);
d98 7
a104 7
static int svr4_hrtcntl(struct proc *, struct svr4_hrtcntl_args *,
    register_t *);
static void bsd_statfs_to_svr4_statvfs(const struct statfs *,
    struct svr4_statvfs *);
static void bsd_statfs_to_svr4_statvfs64(const struct statfs *,
    struct svr4_statvfs64 *);
static struct proc *svr4_pfind(pid_t pid);
d106 2
a107 2
static int svr4_mknod(struct proc *, register_t *, char *,
			   svr4_mode_t, svr4_dev_t);
d221 2
a222 2
int svr4_readdir_callback(void *, struct dirent *, off_t);
int svr4_readdir64_callback(void *, struct dirent *, off_t);
d307 3
a309 6

	FREF(fp);
	error = readdir_with_callback(fp, &fp->f_offset, SCARG(uap, nbytes),
	    svr4_readdir_callback, &args);
	FRELE(fp);
	if (error)
d333 3
a335 6

	FREF(fp);
	error = readdir_with_callback(fp, &fp->f_offset, SCARG(uap, nbytes),
	    svr4_readdir64_callback, &args);
	FRELE(fp);
	if (error)
a426 1
	FREF(fp);
d434 1
a434 2
	if (error) {
		FRELE(fp);
a435 1
	}
a439 1
	FRELE(fp);
@


1.38.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.38.2.1 2002/06/11 03:28:08 art Exp $	 */
d308 1
d337 1
d433 1
a433 1

@


1.37
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.36 2001/11/06 19:53:18 miod Exp $	 */
d657 1
a657 1
	int             rv;
d677 1
a677 1
		rv = uvm_map(&vm->vm_map, &old, diff, NULL, UVM_UNKNOWN_OFFSET,
d682 3
a684 3
		if (rv != KERN_SUCCESS) {
			uprintf("sbrk: grow failed, return = %d\n", rv);
			return ENOMEM;
d689 1
a689 5
		rv = uvm_deallocate(&vm->vm_map, new, diff);
		if (rv != KERN_SUCCESS) {
			uprintf("sbrk: shrink failed, return = %d\n", rv);
			return ENOMEM;
		}
@


1.36
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.35 2001/08/28 18:25:14 jason Exp $	 */
d678 1
a678 1
			UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_COPY,
@


1.35
log
@don't reference seminfo if SYSVSEM isn't defined
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.34 2001/08/26 06:25:10 deraadt Exp $	 */
a90 2

#include <vm/vm.h>
@


1.34
log
@remove duplicate syscallargs() macros
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.33 2001/08/22 10:29:42 niklas Exp $	 */
d568 1
d575 1
@


1.33
log
@Consolidate svr4_waitsys with our wait4.  Fixes gdt_get_slot panic, due to a double
cpu_wait invocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.32 2001/06/27 04:58:42 art Exp $	 */
a892 2

#define syscallarg(x)   union { x datum; register_t pad; }
@


1.32
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.31 2001/06/21 13:08:15 niklas Exp $	 */
d45 1
d1033 2
a1034 2
svr4_sys_waitsys(p, v, retval) 
	register struct proc *p;
d1041 1
a1041 2
	struct proc *q, *t;

d1048 1
a1048 1
		SCARG(uap, id) = -p->p_pgid;
d1056 1
a1056 1
		return EINVAL;
d1059 2
a1060 3
	DPRINTF(("waitsys(%d, %d, %p, %x)\n", 
	         SCARG(uap, grp), SCARG(uap, id),
		 SCARG(uap, info), SCARG(uap, options)));
d1064 1
a1064 1
	for (q = p->p_children.lh_first; q != 0; q = q->p_sibling.le_next) {
d1066 4
a1069 4
		    q->p_pid != SCARG(uap, id) &&
		    q->p_pgid != -SCARG(uap, id)) {
			DPRINTF(("pid %d pgid %d != %d\n", q->p_pid,
				 q->p_pgid, SCARG(uap, id)));
d1073 1
a1073 1
		if (q->p_stat == SZOMB && 
d1076 4
a1079 5
			DPRINTF(("found %d\n", q->p_pid));
			if ((error = svr4_setinfo(q, q->p_xstat,
						  SCARG(uap, info))) != 0)
				return error;

d1081 1
a1081 1
		        if ((SCARG(uap, options) & SVR4_WNOWAIT)) {
d1083 1
a1083 1
				return 0;
d1090 3
a1092 3
			if (q->p_oppid && (t = pfind(q->p_oppid))) {
				q->p_oppid = 0;
				proc_reparent(q, t);
d1095 1
a1095 1
				return 0;
a1096 3
			q->p_xstat = 0;
			ruadd(&p->p_stats->p_cru, q->p_ru);
			FREE(q->p_ru, M_ZOMBIE);
d1098 3
a1100 12
			/*
			 * Decrement the count of procs running with this uid.
			 */
			(void)chgproccnt(q->p_cred->p_ruid, -1);

			/*
			 * Free up credentials.
			 */
			if (--q->p_cred->p_refcnt == 0) {
				crfree(q->p_cred->pc_ucred);
				FREE(q->p_cred, M_SUBPROC);
			}
d1102 2
a1103 23
			/*
			 * Release reference to text vnode
			 */
			if (q->p_textvp)
				vrele(q->p_textvp);

			/*
			 * Finally finished with old proc entry.
			 * Unlink it from its process group and free it.
			 */
			leavepgrp(q);
			LIST_REMOVE(q, p_list);	/* off zombproc */
			LIST_REMOVE(q, p_sibling);

			/*
			 * Give machine-dependent layer a chance
			 * to free anything that cpu_exit couldn't
			 * release while still running in process context.
			 */
			cpu_wait(q);
			pool_put(&proc_pool, q);
			nprocs--;
			return 0;
d1105 6
a1110 6
		if (q->p_stat == SSTOP && (q->p_flag & P_WAITED) == 0 &&
		    (q->p_flag & P_TRACED ||
		     (SCARG(uap, options) & (SVR4_WSTOPPED|SVR4_WCONTINUED)))) {
			DPRINTF(("jobcontrol %d\n", q->p_pid));
		        if (((SCARG(uap, options) & SVR4_WNOWAIT)) == 0)
				q->p_flag |= P_WAITED;
d1112 2
a1113 2
			return svr4_setinfo(q, W_STOPCODE(q->p_xstat),
					    SCARG(uap, info));
d1118 1
a1118 1
		return ECHILD;
d1123 2
a1124 2
			return error;
		return 0;
d1127 2
a1128 2
	if ((error = tsleep((caddr_t)p, PWAIT | PCATCH, "svr4_wait", 0)) != 0)
		return error;
a1130 1

@


1.31
log
@Do not FREE() stuff allocated in a pool
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.30 2001/05/05 21:26:43 art Exp $	 */
a92 1
#if defined(UVM)
a93 1
#endif
a583 1
#if defined(UVM)
a584 3
#else
		*retval = cnt.v_free_count;	/* XXX: free instead of total */
#endif
a586 1
#if defined(UVM)
a587 3
#else
		*retval = cnt.v_active_count;	/* XXX: active instead of avg */
#endif
a675 1
#if defined(UVM)
a680 3
#else
		rv = vm_allocate(&vm->vm_map, &old, diff, FALSE);
#endif
a687 1
#if defined(UVM)
a688 3
#else
		rv = vm_deallocate(&vm->vm_map, new, diff);
#endif
@


1.30
log
@Remove the (vaddr_t) casts inside the round_page and trunc_page macros.
We might want to use them on types that are bigger than vaddr_t.

Fix all callers that pass pointers without casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.29 2001/01/23 05:48:04 csapuntz Exp $	 */
d56 1
d1154 1
a1154 1
			FREE(q, M_PROC);
@


1.29
log
@

SunOS, IBCS2, Linux, and SVR4 all require translations of directory entries
from OpenBSD format to their respective native formats.

A lot of common code here for interfacing with OpenBSD VOP_READDIR. Most
of this code and logic has been moved to common/compat_dir.c

When reading a portion of the directory, the compatibility layer registers
a callback which is passed an OpenBSD-style dirent and the cookie/offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.28 2000/11/10 18:15:46 art Exp $	 */
d371 1
a371 1
	rp = (void *) round_page(p->p_vmspace->vm_daddr + MAXDSIZ);
d405 1
a405 1
	rp = (void *) round_page(p->p_vmspace->vm_daddr + MAXDSIZ);
d669 1
a669 1
	new = round_page(SCARG(uap, nsize));
@


1.28
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.27 2000/06/28 23:48:15 fgsch Exp $	 */
d88 2
d222 71
d300 1
a300 6
	register struct dirent *bdp;
	struct vnode *vp;
	caddr_t inp, buf;	/* BSD-format */
	int len, reclen;	/* BSD-format */
	caddr_t outp;		/* SVR4-format */
	int resid, svr4_reclen;	/* SVR4-format */
d302 1
a302 7
	struct uio auio;
	struct iovec aiov;
	struct svr4_dirent idb;
	off_t off;		/* true file offset */
	int buflen, error, eofflag;
	u_long *cookiebuf = NULL, *cookie;
	int ncookies = 0;
d307 6
a312 35
	if ((fp->f_flag & FREAD) == 0)
		return (EBADF);

	vp = (struct vnode *)fp->f_data;

	if (vp->v_type != VDIR)	/* XXX  vnode readdir op should do this */
		return (EINVAL);

	buflen = min(MAXBSIZE, SCARG(uap, nbytes));
	buf = malloc(buflen, M_TEMP, M_WAITOK);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	off = fp->f_offset;
again:
	aiov.iov_base = buf;
	aiov.iov_len = buflen;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_procp = p;
	auio.uio_resid = buflen;
	auio.uio_offset = off;
	/*
         * First we read into the malloc'ed buffer, then
         * we massage it into user space, one record at a time.
         */
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, &ncookies,
	    &cookiebuf);
	if (error)
		goto out;

	if (!error && !cookiebuf && !eofflag) {
		error = EPERM;
		goto out;
	}
d314 1
a314 43
	inp = buf;
	outp = SCARG(uap, buf);
	resid = SCARG(uap, nbytes);
	if ((len = buflen - auio.uio_resid) == 0)
		goto eof;

	for (cookie = cookiebuf; len > 0; len -= reclen) {
		bdp = (struct dirent *)inp;
		reclen = bdp->d_reclen;
		if (reclen & 3)
			panic("svr4_getdents: bad reclen");
		if (bdp->d_fileno == 0) {
			inp += reclen;	/* it is a hole; squish it out */
			off = *cookie++;
			continue;
		}
		svr4_reclen = SVR4_RECLEN(&idb, bdp->d_namlen);
		if (reclen > len || resid < svr4_reclen) {
			/* entry too big for buffer, so just stop */
			outp++;
			break;
		}
		off = *cookie++;	/* each entry points to the next */

		/*
		 * Massage in place to make a SVR4-shaped dirent (otherwise
		 * we have to worry about touching user memory outside of
		 * the copyout() call).
		 */
		idb.d_ino = (svr4_ino_t)bdp->d_fileno;
		idb.d_off = (svr4_off_t)off;
		idb.d_reclen = (u_short)svr4_reclen;
		strcpy(idb.d_name, bdp->d_name);
		if ((error = copyout((caddr_t)&idb, outp, svr4_reclen)))
			goto out;

		/* advance past this real entry */
		inp += reclen;

		/* advance output past SVR4-shaped entry */
		outp += svr4_reclen;
		resid -= svr4_reclen;
	}
d316 1
a316 13
	/* if we squished out the whole block, try again */
	if (outp == SCARG(uap, buf))
		goto again;
	fp->f_offset = off;	/* update the vnode offset */

eof:
	*retval = SCARG(uap, nbytes) - resid;
out:
	VOP_UNLOCK(vp, 0, p);
	if (cookiebuf)
		free(cookiebuf, M_TEMP);
	free(buf, M_TEMP);
	return error;
d326 1
a326 6
	register struct dirent *bdp;
	struct vnode *vp;
	caddr_t inp, buf;	/* BSD-format */
	int len, reclen;	/* BSD-format */
	caddr_t outp;		/* SVR4-format */
	int resid, svr4_reclen;	/* SVR4-format */
d328 1
a328 7
	struct uio auio;
	struct iovec aiov;
	struct svr4_dirent64 idb;
	off_t off;		/* true file offset */
	int buflen, error, eofflag;
	u_long *cookiebuf = NULL, *cookie;
	int ncookies = 0;
d333 6
a338 4
	if ((fp->f_flag & FREAD) == 0)
		return (EBADF);

	vp = (struct vnode *)fp->f_data;
d340 1
a340 2
	if (vp->v_type != VDIR)	/* XXX  vnode readdir op should do this */
		return (EINVAL);
d342 1
a342 85
	buflen = min(MAXBSIZE, SCARG(uap, nbytes));
	buf = malloc(buflen, M_TEMP, M_WAITOK);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	off = fp->f_offset;
again:
	aiov.iov_base = buf;
	aiov.iov_len = buflen;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_procp = p;
	auio.uio_resid = buflen;
	auio.uio_offset = off;
	/*
         * First we read into the malloc'ed buffer, then
         * we massage it into user space, one record at a time.
         */
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, &ncookies,
	    &cookiebuf);
	if (error)
		goto out;

	if (!error && !cookiebuf && !eofflag) {
		error = EPERM;
		goto out;
	}

	inp = buf;
	outp = (char *) SCARG(uap, dp);
	resid = SCARG(uap, nbytes);
	if ((len = buflen - auio.uio_resid) == 0)
		goto eof;

	for (cookie = cookiebuf; len > 0; len -= reclen) {
		bdp = (struct dirent *)inp;
		reclen = bdp->d_reclen;
		if (reclen & 3)
			panic("svr4_getdents64: bad reclen");
		if (bdp->d_fileno == 0) {
			inp += reclen;	/* it is a hole; squish it out */
			off = *cookie++;
			continue;
		}
		svr4_reclen = SVR4_RECLEN(&idb, bdp->d_namlen);
		if (reclen > len || resid < svr4_reclen) {
			/* entry too big for buffer, so just stop */
			outp++;
			break;
		}
		off = *cookie++;	/* each entry points to the next */

		/*
		 * Massage in place to make a SVR4-shaped dirent (otherwise
		 * we have to worry about touching user memory outside of
		 * the copyout() call).
		 */
		idb.d_ino = (svr4_ino64_t)bdp->d_fileno;
		idb.d_off = (svr4_off64_t)off;
		idb.d_reclen = (u_short)svr4_reclen;
		strcpy(idb.d_name, bdp->d_name);
		if ((error = copyout((caddr_t)&idb, outp, svr4_reclen)))
			goto out;

		/* advance past this real entry */
		inp += reclen;

		/* advance output past SVR4-shaped entry */
		outp += svr4_reclen;
		resid -= svr4_reclen;
	}

	/* if we squished out the whole block, try again */
	if (outp == (char *) SCARG(uap, dp))
		goto again;
	fp->f_offset = off;	/* update the vnode offset */

eof:
	*retval = SCARG(uap, nbytes) - resid;
out:
	VOP_UNLOCK(vp, 0, p);
	if (cookiebuf)
		free(cookiebuf, M_TEMP);
	free(buf, M_TEMP);
	return error;
@


1.27
log
@add creat64 and mmap64.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.26 2000/06/24 21:00:30 fgsch Exp $	 */
d1614 1
a1614 1
			ktremul(p->p_tracep, p->p_emul->e_name);
@


1.26
log
@Implement getdents64, lstat64 and stat64, basically the same functions of
the existing ones using 64bit vars. This makes netscape-solaris works on
sparc.

Particular note to those who want to try netscape:
- netscape 4.73 was used for testing on a ss5 with -current.
- apparently solaris uses pipes for communicating with the X server. I've
  checked the libraries I've installed from a solaris 2.6 box, and although
  there are references to X11-unix, it fails when it tries to open
  X11-pipe/X0, so in order to test it you need to specify -display <box ip>:0
  or it won't start.
- i got some errors when starting, but besides that, it works fine.
- it's not slow, but you better have all the requiered files in the correct
  paths, or it'll take some time to start.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.25 1999/10/07 17:23:53 brad Exp $	 */
d467 34
@


1.25
log
@- fix typo in previous commit
- Implement fstatvfs64 system call
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.24 1999/10/07 16:14:28 brad Exp $	 */
d327 120
@


1.25.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.29 2001/01/23 05:48:04 csapuntz Exp $	 */
a87 2
#include <compat/common/compat_dir.h>

a219 71

int svr4_readdir_callback __P((void *, struct dirent *, off_t));
int svr4_readdir64_callback __P((void *, struct dirent *, off_t));

struct svr4_readdir_callback_args {
	caddr_t outp;
	int     resid;
};

int
svr4_readdir_callback(arg, bdp, cookie)
	void *arg;
	struct dirent *bdp;
	off_t cookie;
{
	struct svr4_dirent idb;
	struct svr4_readdir_callback_args *cb = arg; 
	int svr4_reclen;
	int error;

	svr4_reclen = SVR4_RECLEN(&idb, bdp->d_namlen);
	if (cb->resid < svr4_reclen)
		return (ENOMEM);

	idb.d_ino = (svr4_ino_t)bdp->d_fileno;
	idb.d_off = (svr4_off_t)cookie;
	idb.d_reclen = (u_short)svr4_reclen;
	strlcpy(idb.d_name, bdp->d_name, SVR4_MAXNAMLEN+1);
	if ((error = copyout((caddr_t)&idb, cb->outp, svr4_reclen)))
		return (error);

	cb->outp += svr4_reclen;
	cb->resid -= svr4_reclen;

	return (0);
}

int
svr4_readdir64_callback(arg, bdp, cookie)
	void *arg;
	struct dirent *bdp;
	off_t cookie;
{
	struct svr4_dirent64 idb;
	struct svr4_readdir_callback_args *cb = arg; 
	int svr4_reclen;
	int error;

	svr4_reclen = SVR4_RECLEN(&idb, bdp->d_namlen);
	if (cb->resid < svr4_reclen)
		return (ENOMEM);

	/*
	 * Massage in place to make a SVR4-shaped dirent (otherwise
	 * we have to worry about touching user memory outside of
	 * the copyout() call).
	 */
	idb.d_ino = (svr4_ino64_t)bdp->d_fileno;
	idb.d_off = (svr4_off64_t)cookie;
	idb.d_reclen = (u_short)svr4_reclen;
	strlcpy(idb.d_name, bdp->d_name, SVR4_MAXNAMLEN+1);
	if ((error = copyout((caddr_t)&idb, cb->outp, svr4_reclen)))
		return (error);

	cb->outp += svr4_reclen;
	cb->resid -= svr4_reclen;

	return (0);
}


d227 6
a232 1
	struct svr4_readdir_callback_args args;
d234 7
a240 1
	int error;
d245 2
a246 6
	args.resid = SCARG(uap, nbytes);
	args.outp = (caddr_t)SCARG(uap, buf);
	
	if ((error = readdir_with_callback(fp, &fp->f_offset, SCARG(uap, nbytes),
	    svr4_readdir_callback, &args)) != 0)
		return (error);
d248 1
a248 1
	*retval = SCARG(uap, nbytes) - args.resid;
d250 2
a251 2
	return (0);
}
d253 22
a274 10
int
svr4_sys_getdents64(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_getdents64_args *uap = v;
	struct svr4_readdir_callback_args args;
	struct file *fp;
	int error;
d276 4
a279 2
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
d281 23
a303 6
	args.resid = SCARG(uap, nbytes);
	args.outp = (caddr_t)SCARG(uap, dp);
	
	if ((error = readdir_with_callback(fp, &fp->f_offset, SCARG(uap, nbytes),
	    svr4_readdir64_callback, &args)) != 0)
		return (error);
d305 19
a323 1
	*retval = SCARG(uap, nbytes) - args.resid;
d325 13
a337 1
	return (0);
a374 34
svr4_sys_mmap64(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_mmap64_args	*uap = v;
	struct sys_mmap_args	 mm;
	void			*rp;
#define _MAP_NEW	0x80000000
	/*
         * Verify the arguments.
         */
	if (SCARG(uap, prot) & ~(PROT_READ | PROT_WRITE | PROT_EXEC))
		return EINVAL;	/* XXX still needed? */

	if (SCARG(uap, len) == 0)
		return EINVAL;

	SCARG(&mm, prot) = SCARG(uap, prot);
	SCARG(&mm, len) = SCARG(uap, len);
	SCARG(&mm, flags) = SCARG(uap, flags) & ~_MAP_NEW;
	SCARG(&mm, fd) = SCARG(uap, fd);
	SCARG(&mm, addr) = SCARG(uap, addr);
	SCARG(&mm, pos) = SCARG(uap, pos);

	rp = (void *) round_page(p->p_vmspace->vm_daddr + MAXDSIZ);
	if ((SCARG(&mm, flags) & MAP_FIXED) == 0 &&
	    SCARG(&mm, addr) != 0 && SCARG(&mm, addr) < rp)
		SCARG(&mm, addr) = rp;

	return sys_mmap(p, &mm, retval);
}

int
d1460 1
a1460 1
			ktremul(p, p->p_emul->e_name);
@


1.25.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.25.4.1 2001/05/14 22:05:26 niklas Exp $	 */
a55 1
#include <sys/pool.h>
d92 1
d94 1
d371 1
a371 1
	rp = (void *) round_page((vaddr_t)p->p_vmspace->vm_daddr + MAXDSIZ);
d405 1
a405 1
	rp = (void *) round_page((vaddr_t)p->p_vmspace->vm_daddr + MAXDSIZ);
d585 1
d587 3
d592 1
d594 3
d669 1
a669 1
	new = round_page((vaddr_t)SCARG(uap, nsize));
d685 1
d691 3
d701 1
d703 3
d1153 1
a1153 1
			pool_put(&proc_pool, q);
@


1.25.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.25.4.2 2001/07/04 10:39:45 niklas Exp $	 */
a44 1
#include <sys/sched.h>
a566 1
#ifdef SYSVSEM
a572 1
#endif
d893 2
d1032 2
a1033 2
svr4_sys_waitsys(q, v, retval) 
	struct proc *q;
d1040 2
a1041 1
	struct proc *p, *t;
d1048 1
a1048 1
		SCARG(uap, id) = -q->p_pgid;
d1056 1
a1056 1
		return (EINVAL);
d1059 3
a1061 2
	DPRINTF(("waitsys(%d, %d, %p, %x)\n", SCARG(uap, grp), SCARG(uap, id),
	    SCARG(uap, info), SCARG(uap, options)));
d1065 1
a1065 1
	for (p = q->p_children.lh_first; p != 0; p = p->p_sibling.le_next) {
d1067 4
a1070 4
		    p->p_pid != SCARG(uap, id) &&
		    p->p_pgid != -SCARG(uap, id)) {
			DPRINTF(("pid %d pgid %d != %d\n", p->p_pid,
				 p->p_pgid, SCARG(uap, id)));
d1074 1
a1074 1
		if (p->p_stat == SZOMB && 
d1077 5
a1081 4
			DPRINTF(("found %d\n", p->p_pid));
			error = svr4_setinfo(p, p->p_xstat, SCARG(uap, info));
			if (error)
				return (error);
d1083 1
a1083 1
			if ((SCARG(uap, options) & SVR4_WNOWAIT)) {
d1085 1
a1085 1
				return (0);
d1092 3
a1094 3
			if (p->p_oppid && (t = pfind(p->p_oppid))) {
				p->p_oppid = 0;
				proc_reparent(p, t);
d1097 17
a1113 1
				return (0);
d1116 5
a1120 3
			scheduler_wait_hook(q, p);
			p->p_xstat = 0;
			ruadd(&q->p_stats->p_cru, p->p_ru);
d1122 17
a1138 2
			proc_zap(p);
			return (0);
d1140 6
a1145 6
		if (p->p_stat == SSTOP && (p->p_flag & P_WAITED) == 0 &&
		    (p->p_flag & P_TRACED ||
		    (SCARG(uap, options) & (SVR4_WSTOPPED|SVR4_WCONTINUED)))) {
			DPRINTF(("jobcontrol %d\n", p->p_pid));
			if (((SCARG(uap, options) & SVR4_WNOWAIT)) == 0)
				p->p_flag |= P_WAITED;
d1147 2
a1148 2
			return (svr4_setinfo(p, W_STOPCODE(p->p_xstat),
			   SCARG(uap, info)));
d1153 1
a1153 1
		return (ECHILD);
d1158 2
a1159 2
			return (error);
		return (0);
d1162 2
a1163 2
	if ((error = tsleep((caddr_t)q, PWAIT | PCATCH, "svr4_wait", 0)) != 0)
		return (error);
d1166 1
@


1.25.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	 */
d92 2
d680 1
a680 1
			0, UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_COPY,
@


1.25.4.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.25.4.4 2001/11/13 21:05:48 niklas Exp $	 */
d657 1
a657 1
	int             error;
d677 1
a677 1
		error = uvm_map(&vm->vm_map, &old, diff, NULL, UVM_UNKNOWN_OFFSET,
d682 3
a684 3
		if (error) {
			uprintf("sbrk: grow failed, return = %d\n", error);
			return error;
d689 5
a693 1
		uvm_deallocate(&vm->vm_map, new, diff);
@


1.25.4.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	 */
d307 3
a309 6

	FREF(fp);
	error = readdir_with_callback(fp, &fp->f_offset, SCARG(uap, nbytes),
	    svr4_readdir_callback, &args);
	FRELE(fp);
	if (error)
d333 3
a335 6

	FREF(fp);
	error = readdir_with_callback(fp, &fp->f_offset, SCARG(uap, nbytes),
	    svr4_readdir64_callback, &args);
	FRELE(fp);
	if (error)
a426 1
	FREF(fp);
d434 1
a434 2
	if (error) {
		FRELE(fp);
a435 1
	}
a439 1
	FRELE(fp);
@


1.25.4.7
log
@Merge in -current from about a week ago
@
text
@d94 2
a95 2
static __inline clock_t timeval_to_clock_t(struct timeval *);
static int svr4_setinfo(struct proc *, int, svr4_siginfo_t *);
d98 7
a104 7
static int svr4_hrtcntl(struct proc *, struct svr4_hrtcntl_args *,
    register_t *);
static void bsd_statfs_to_svr4_statvfs(const struct statfs *,
    struct svr4_statvfs *);
static void bsd_statfs_to_svr4_statvfs64(const struct statfs *,
    struct svr4_statvfs64 *);
static struct proc *svr4_pfind(pid_t pid);
d106 2
a107 2
static int svr4_mknod(struct proc *, register_t *, char *,
			   svr4_mode_t, svr4_dev_t);
d221 2
a222 2
int svr4_readdir_callback(void *, struct dirent *, off_t);
int svr4_readdir64_callback(void *, struct dirent *, off_t);
@


1.25.4.8
log
@Sync the SMP branch with 3.3
@
text
@d308 1
d337 1
d433 1
a433 1

@


1.25.4.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d427 1
a427 1
	if ((error = suser(p, 0)) != 0)
@


1.24
log
@- Fix stat and mknod syscalls to properly disassemble and reassemble
  dev_t values to/from emulation dev_t's
- Implement fstat64, llseek and open64 system calls; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.23 1999/09/11 00:03:16 mickey Exp $	 */
d99 1
a99 1
			     register_t *));
d101 3
a103 1
					    struct svr4_statvfs *));
d455 1
a455 1
			  svr4_to_bsd_odev_t(SCARG(uap, dev)));
d1172 26
d1255 30
@


1.23
log
@s/vm_offset_t/vaddr_t/g
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.22 1999/02/26 04:12:00 art Exp $	 */
d439 2
a440 1
			  SCARG(uap, path), SCARG(uap, mode), SCARG(uap, dev));
d452 2
a453 1
			  SCARG(uap, path), SCARG(uap, mode), SCARG(uap, dev));
@


1.22
log
@cnt is called uvmexp in uvm and the names of the members have changed.
Different allocation and deallocation for uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.21 1999/02/10 00:16:12 niklas Exp $	 */
d621 1
a621 1
	vm_offset_t     new, old;
d625 1
a625 1
	old = (vm_offset_t) vm->vm_daddr;
@


1.21
log
@Correct directory entry reads, big directories lost entries as it were.
Also, fix the NCR SVR4 rdebug syscall emulation.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.20 1998/03/06 21:58:09 niklas Exp $	 */
d90 4
d542 3
d546 1
d549 3
d553 1
d642 7
d650 1
d658 3
d662 1
@


1.20
log
@Make NCR rdebug behaviour dependent on p_os field
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.19 1997/12/12 06:22:51 deraadt Exp $	 */
d270 1
a270 1
	if (!error && !cookiebuf) {
d285 1
a285 2
			panic("svr4_getdents");
		off = *cookie++;	/* each entry points to the next */
d288 1
d297 2
d310 1
d313 1
d1392 1
a1392 1
#ifdef SVR4_COMPAT_NCR
@


1.19
log
@fix non-i386 case
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.18 1997/12/02 00:07:04 deraadt Exp $	 */
d40 2
d1369 1
d1377 15
a1391 1
	(void) uap;
a1392 1
        return sys_setegid(p, v, retval);
@


1.18
log
@If i386, and COMPAT_LINUX is enabled, if setegid() is called with an out
of range value recognize it as the Linux personality() system call, and
switch into Linux emulation mode.... At least they could have picked an
unused system call number!
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.17 1997/11/14 21:22:52 deraadt Exp $	 */
d1351 1
a1351 1
                syscallarg(gid_t) egid;
d1373 2
@


1.17
log
@void * change to mmap()
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.16 1997/11/13 06:23:05 deraadt Exp $	 */
d51 1
d1341 34
@


1.16
log
@fake auditsys()
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.15 1997/11/13 06:21:31 deraadt Exp $	 */
d335 1
a335 1
	caddr_t 		 rp;
d353 1
a353 1
	rp = (caddr_t) round_page(p->p_vmspace->vm_daddr + MAXDSIZ);
@


1.15
log
@make svr4_sys_ulimit() return EINVAL for bad commands
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.14 1997/11/06 05:58:06 csapuntz Exp $	 */
d1288 12
@


1.14
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.13 1997/10/06 20:19:35 deraadt Exp $	 */
d749 1
a749 1
		return ENOSYS;
@


1.13
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.11 1997/09/11 10:48:12 deraadt Exp $	 */
d230 2
a231 2
	u_long *cookiebuf, *cookie;
	int ncookies;
d246 1
a246 3
	ncookies = buflen / 16;
	cookiebuf = malloc(ncookies * sizeof(*cookiebuf), M_TEMP, M_WAITOK);
	VOP_LOCK(vp);
d262 2
a263 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, cookiebuf,
	    ncookies);
d267 5
d320 3
a322 2
	VOP_UNLOCK(vp);
	free(cookiebuf, M_TEMP);
d378 1
a378 1
	VOP_LOCK(vp);
d383 1
a383 1
	VOP_UNLOCK(vp);
@


1.12
log
@VFS Lite2 Changes
@
text
@d230 2
a231 2
	u_long *cookiebuf = NULL, *cookie;
	int ncookies = 0;
d246 3
a248 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d264 2
a265 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, &ncookies,
	    &cookiebuf);
a268 5
	if (!error && !cookiebuf) {
		error = EPERM;
		goto out;
	}

d317 2
a318 3
	VOP_UNLOCK(vp, 0, p);
	if (cookiebuf)
		free(cookiebuf, M_TEMP);
d374 1
a374 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d379 1
a379 1
	VOP_UNLOCK(vp, 0, p);
@


1.11
log
@sync with netbsd; missing SCARG() macros
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.10 1997/06/17 11:11:12 deraadt Exp $	 */
d230 2
a231 2
	u_long *cookiebuf, *cookie;
	int ncookies;
d246 1
a246 3
	ncookies = buflen / 16;
	cookiebuf = malloc(ncookies * sizeof(*cookiebuf), M_TEMP, M_WAITOK);
	VOP_LOCK(vp);
d262 2
a263 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, cookiebuf,
	    ncookies);
d267 5
d320 3
a322 2
	VOP_UNLOCK(vp);
	free(cookiebuf, M_TEMP);
d378 1
a378 1
	VOP_LOCK(vp);
d383 1
a383 1
	VOP_UNLOCK(vp);
@


1.10
log
@careful with stackgap handling in execve()
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.9 1997/03/28 22:03:46 kstailey Exp $	 */
d721 2
a722 2
			srl.which = RLIMIT_FSIZE;
			srl.rlp = url;
@


1.9
log
@added 34 - nice
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.8 1997/02/13 19:45:19 niklas Exp $	 */
d146 1
a146 1
	caddr_t sg = stackgap_init(p->p_emul);
d148 1
d165 1
a165 1
	struct sys_execve_args /* {
d169 3
a171 2
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);
d173 1
d176 5
a180 1
	return sys_execve(p, uap, retval);
@


1.8
log
@Merge of NetBSD 970211
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.7 1997/01/27 01:16:51 deraadt Exp $	 */
d1294 23
@


1.7
log
@do not conflict against generic siginfo!
@
text
@d1 2
a2 2
/*	$OpenBSD: svr4_misc.c,v 1.6 1996/08/03 15:29:32 deraadt Exp $	 */
/*	$NetBSD: svr4_misc.c,v 1.36 1996/03/30 22:38:02 christos Exp $	 */
d83 1
d141 6
a146 2
	struct svr4_sys_execv_args *uap = v;
	struct sys_execve_args ex;
a147 1
	caddr_t sg = stackgap_init(p->p_emul);
d150 3
a152 3
	SCARG(&ex, path) = SCARG(uap, path);
	SCARG(&ex, argp) = SCARG(uap, argp);
	SCARG(&ex, envp) = NULL;
d154 1
a154 1
	return sys_execve(p, &ex, retval);
d164 5
a168 1
	struct sys_execve_args *uap = v;
d170 1
d332 3
d1105 2
a1106 2
	sfs->f_bsize = bfs->f_bsize;
	sfs->f_frsize = bfs->f_bsize / 8; /* XXX */
d1241 53
@


1.6
log
@sys/dirent.h not sys/dir.h; netbsd pr#2599; jonathan@@DSG.Stanford.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.5 1996/08/01 00:50:53 niklas Exp $	 */
d909 2
a910 2
	i.si_signo = SVR4_SIGCHLD;
	i.si_errno = 0;	/* XXX? */
d913 1
a913 1
		i.si_pid = p->p_pid;
d915 2
a916 2
			i.si_stime = p->p_ru->ru_stime.tv_sec;
			i.si_utime = p->p_ru->ru_utime.tv_sec;
d918 2
a919 2
			i.si_stime = p->p_stats->p_ru.ru_stime.tv_sec;
			i.si_utime = p->p_stats->p_ru.ru_utime.tv_sec;
d924 2
a925 2
		i.si_status = WEXITSTATUS(st);
		i.si_code = SVR4_CLD_EXITED;
d928 1
a928 1
		i.si_status = bsd_to_svr4_sig[WSTOPSIG(st)];
d930 2
a931 2
		if (i.si_status == SVR4_SIGCONT)
			i.si_code = SVR4_CLD_CONTINUED;
d933 1
a933 1
			i.si_code = SVR4_CLD_STOPPED;
d935 1
a935 1
		i.si_status = bsd_to_svr4_sig[WTERMSIG(st)];
d938 1
a938 1
			i.si_code = SVR4_CLD_DUMPED;
d940 1
a940 1
			i.si_code = SVR4_CLD_KILLED;
d944 2
a945 1
		 i.si_pid, i.si_signo, i.si_code, i.si_errno, i.si_status));
@


1.5
log
@Merge of NetBSD 0722
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.4 1996/04/17 05:24:18 mickey Exp $	 */
d41 1
a41 1
#include <sys/dir.h>
@


1.4
log
@Good fixes and changes from latest Net.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_misc.c,v 1.3 1996/02/26 23:31:57 niklas Exp $	 */
d914 7
a920 2
		i.si_stime = p->p_ru->ru_stime.tv_sec;
		i.si_utime = p->p_ru->ru_utime.tv_sec;
@


1.3
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	 */
/*	$NetBSD: svr4_misc.c,v 1.35 1996/02/10 17:12:31 christos Exp $	 */
d587 1
a587 1
	DPRINTF(("break(1): old %x new %x diff %x\n", old, new, diff));
d597 1
a597 1
	DPRINTF(("break(3): old %x new %x diff %x\n", old, new, diff));
d938 1
a938 1
	DPRINTF(("siginfo [pid %d signo %d code %d errno %d status %d]\n",
@


1.2
log
@update from netbsd
@
text
@d1 2
a2 1
/*	$NetBSD: svr4_misc.c,v 1.29 1995/10/14 20:24:35 christos Exp $	 */
d96 3
d370 3
a372 5

int
svr4_sys_mknod(p, v, retval)
	register struct proc *p;
	void *v;
d374 3
a377 1
	struct svr4_sys_mknod_args *uap = v;
a378 1
	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
d380 3
a382 1
	if (S_ISFIFO(SCARG(uap, mode))) {
d384 2
a385 2
		SCARG(&ap, path) = SCARG(uap, path);
		SCARG(&ap, mode) = SCARG(uap, mode);
d389 3
a391 3
		SCARG(&ap, path) = SCARG(uap, path);
		SCARG(&ap, mode) = SCARG(uap, mode);
		SCARG(&ap, dev) = SCARG(uap, dev);
d396 25
a874 2
	int error;
	struct timeval tv;
d973 1
a973 1
	DPRINTF(("waitsys(%d, %d, %x, %x)\n", 
d975 1
a975 2
		 (unsigned int) SCARG(uap, info),
	         SCARG(uap, options)));
a1059 2
			else
				DPRINTF(("Don't wait\n"));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: svr4_misc.c,v 1.28 1995/10/09 11:24:17 mycroft Exp $	 */
d63 2
a83 1
/* XXX */ extern struct proc *pfind();
a309 3
	struct filedesc		*fdp;
	struct file		*fp;
	struct vnode		*vp;
d619 1
a619 1
	if (error = copyin(ru, &r, sizeof r))
d630 1
a630 1
	if (error = copyin(ru, &r, sizeof r))
d946 2
a947 1
	         SCARG(uap, grp), SCARG(uap, id), SCARG(uap, info),
d1051 1
a1051 1
	if (error = tsleep((caddr_t)p, PWAIT | PCATCH, "svr4_wait", 0))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

