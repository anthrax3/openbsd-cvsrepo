head	1.8;
access;
symbols
	OPENBSD_4_9:1.7.0.38
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.36
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.32
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.34
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.30
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.28
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.26
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.24
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.22
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.20
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.18
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.16
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.14
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.12
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.8
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.18
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.16
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.14
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.12
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.8
date	2011.07.04.23.01.33;	author tedu;	state dead;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.29.02.22.14;	author brad;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	96.08.01.00.50.56;	author niklas;	state Exp;
branches
	1.5.16.1;
next	1.4;

1.4
date	96.04.21.22.18.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.17.05.24.24;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.47.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.25;	author deraadt;	state Exp;
branches;
next	;

1.5.16.1
date	2001.05.14.22.05.30;	author niklas;	state Exp;
branches;
next	1.5.16.2;

1.5.16.2
date	2002.03.28.11.28.07;	author niklas;	state Exp;
branches;
next	;

1.6.8.1
date	2002.06.11.03.28.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.8
log
@remove all the compat svr4 files
@
text
@/*	$OpenBSD: svr4_ttold.c,v 1.7 2002/03/14 01:26:51 millert Exp $	 */
/*	$NetBSD: svr4_ttold.c,v 1.9 1996/04/11 12:54:45 christos Exp $	 */

/*
 * Copyright (c) 1994 Christos Zoulas
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/termios.h>
#include <sys/tty.h>
#include <sys/socket.h>
#include <sys/mount.h>
#include <net/if.h>
#include <sys/malloc.h>

#include <sys/syscallargs.h>

#include <compat/svr4/svr4_types.h>
#include <compat/svr4/svr4_util.h>
#include <compat/svr4/svr4_signal.h>
#include <compat/svr4/svr4_syscallargs.h>
#include <compat/svr4/svr4_stropts.h>
#include <compat/svr4/svr4_ttold.h>
#include <compat/svr4/svr4_ioctl.h>

static void svr4_tchars_to_bsd_tchars(const struct svr4_tchars *st,
					   struct tchars *bt);
static void bsd_tchars_to_svr4_tchars(const struct tchars *bt,
					   struct svr4_tchars *st);
static void svr4_sgttyb_to_bsd_sgttyb(const struct svr4_sgttyb *ss,
					   struct sgttyb *bs);
static void bsd_sgttyb_to_svr4_sgttyb(const struct sgttyb *bs,
					   struct svr4_sgttyb *ss);
static void svr4_ltchars_to_bsd_ltchars(const struct svr4_ltchars *sl,
					     struct ltchars *bl);
static void bsd_ltchars_to_svr4_ltchars(const struct ltchars *bl,
					     struct svr4_ltchars *sl);

#ifdef DEBUG_SVR4
static void print_svr4_sgttyb(const char *, struct svr4_sgttyb *);
static void print_svr4_tchars(const char *, struct svr4_tchars *);
static void print_svr4_ltchars(const char *, struct svr4_ltchars *);

static void
print_svr4_sgttyb(str, ss)
	const char *str;
	struct svr4_sgttyb *ss;
{
	uprintf("%s\nispeed=%o ospeed=%o ", str, ss->sg_ispeed, ss->sg_ospeed);
	uprintf("erase=%o kill=%o flags=%o\n", ss->sg_erase, ss->sg_kill,
	    ss->sg_flags);
}

static void
print_svr4_tchars(str, st)
	const char *str;
	struct svr4_tchars *st;
{
	uprintf("%s\nintrc=%o quitc=%o ", str, st->t_intrc, st->t_quitc);
	uprintf("startc=%o stopc=%o eofc=%o brkc=%o\n", st->t_startc,
	    st->t_stopc, st->t_eofc, st->t_brkc);
}

static void
print_svr4_ltchars(str, sl)
	const char *str;
	struct svr4_ltchars *sl;
{
	uprintf("%s\nsuspc=%o dsuspc=%o ", str, sl->t_suspc, sl->t_dsuspc);
	uprintf("rprntc=%o flushc=%o werasc=%o lnextc=%o\n", sl->t_rprntc,
	    sl->t_flushc, sl->t_werasc, sl->t_lnextc);
}
#endif /* DEBUG_SVR4 */

static void
svr4_tchars_to_bsd_tchars(st, bt)
	const struct svr4_tchars	*st;
	struct tchars			*bt;
{
	bt->t_intrc  = st->t_intrc;
	bt->t_quitc  = st->t_quitc;
	bt->t_startc = st->t_startc;
	bt->t_stopc  = st->t_stopc;
	bt->t_eofc   = st->t_eofc;
	bt->t_brkc   = st->t_brkc;
}


static void
bsd_tchars_to_svr4_tchars(bt, st)
	const struct tchars	*bt;
	struct svr4_tchars	*st;
{
	st->t_intrc  = bt->t_intrc;
	st->t_quitc  = bt->t_quitc;
	st->t_startc = bt->t_startc;
	st->t_stopc  = bt->t_stopc;
	st->t_eofc   = bt->t_eofc;
	st->t_brkc   = bt->t_brkc;
}


static void
svr4_sgttyb_to_bsd_sgttyb(ss, bs)
	const struct svr4_sgttyb	*ss;
	struct sgttyb			*bs;
{
	bs->sg_ispeed = ss->sg_ispeed;
	bs->sg_ospeed = ss->sg_ospeed;
	bs->sg_erase  =	ss->sg_erase;	
	bs->sg_kill   = ss->sg_kill;
	bs->sg_flags  = ss->sg_flags;
};


static void
bsd_sgttyb_to_svr4_sgttyb(bs, ss)
	const struct sgttyb	*bs;
	struct svr4_sgttyb	*ss;
{
	ss->sg_ispeed = bs->sg_ispeed;
	ss->sg_ospeed = bs->sg_ospeed;
	ss->sg_erase  =	bs->sg_erase;	
	ss->sg_kill   = bs->sg_kill;
	ss->sg_flags  = bs->sg_flags;
}


static void
svr4_ltchars_to_bsd_ltchars(sl, bl)
	const struct svr4_ltchars	*sl;
	struct ltchars			*bl;
{
	bl->t_suspc  = sl->t_suspc;
	bl->t_dsuspc = sl->t_dsuspc;
	bl->t_rprntc = sl->t_rprntc;
	bl->t_flushc = sl->t_flushc;
	bl->t_werasc = sl->t_werasc;
	bl->t_lnextc = sl->t_lnextc;
}


static void
bsd_ltchars_to_svr4_ltchars(bl, sl)
	const struct ltchars	*bl;
	struct svr4_ltchars	*sl;
{
	sl->t_suspc  = bl->t_suspc;
	sl->t_dsuspc = bl->t_dsuspc;
	sl->t_rprntc = bl->t_rprntc;
	sl->t_flushc = bl->t_flushc;
	sl->t_werasc = bl->t_werasc;
	sl->t_lnextc = bl->t_lnextc;
}


int
svr4_ttold_ioctl(fp, p, retval, fd, cmd, data)
	struct file *fp;
	struct proc *p;
	register_t *retval;
	int fd;
	u_long cmd;
	caddr_t data;
{
	int			error;
	int (*ctl)(struct file *, u_long,  caddr_t, struct proc *) =
			fp->f_ops->fo_ioctl;

	*retval = 0;

	switch (cmd) {
	case SVR4_TIOCGPGRP:
		{
			pid_t pid;

			if ((error = (*ctl)(fp, TIOCGPGRP,
					    (caddr_t) &pid, p)) != 0)
			    return error;

			DPRINTF(("TIOCGPGRP %d\n", pid));

			if ((error = copyout(&pid, data, sizeof(pid))) != 0)
				return error;

		}

	case SVR4_TIOCSPGRP:
		{
			pid_t pid;

			if ((error = copyin(data, &pid, sizeof(pid))) != 0)
				return error;

			DPRINTF(("TIOCSPGRP %d\n", pid));

			return (*ctl)(fp, TIOCSPGRP, (caddr_t) &pid, p);
		}

	case SVR4_TIOCGSID:
		{
			pid_t pid;

			if ((error = (*ctl)(fp, TIOCGSID,
					    (caddr_t) &pid, p)) != 0)
				return error;

			DPRINTF(("TIOCGSID %d\n", pid));

			return copyout(&pid, data, sizeof(pid));
		}

	case SVR4_TIOCGETP:
		{
			struct sgttyb bs;
			struct svr4_sgttyb ss;

			error = (*ctl)(fp, TIOCGETP, (caddr_t) &bs, p);
			if (error)
				return error;

			bsd_sgttyb_to_svr4_sgttyb(&bs, &ss);
#ifdef DEBUG_SVR4
			print_svr4_sgttyb("SVR4_TIOCGETP", &ss);
#endif /* DEBUG_SVR4 */
			return copyout(&ss, data, sizeof(ss));
		}

	case SVR4_TIOCSETP:
	case SVR4_TIOCSETN:
		{
			struct sgttyb bs;
			struct svr4_sgttyb ss;

			if ((error = copyin(data, &ss, sizeof(ss))) != 0)
				return error;

			svr4_sgttyb_to_bsd_sgttyb(&ss, &bs);
#ifdef DEBUG_SVR4
			print_svr4_sgttyb("SVR4_TIOCSET{P,N}", &ss);
#endif /* DEBUG_SVR4 */
			cmd = (cmd == SVR4_TIOCSETP) ? TIOCSETP : TIOCSETN;
			return (*ctl)(fp, cmd, (caddr_t) &bs, p);
		}

	case SVR4_TIOCGETC:
		{
			struct tchars bt;
			struct svr4_tchars st;

			error = (*ctl)(fp, TIOCGETC, (caddr_t) &bt, p);
			if (error)
				return error;

			bsd_tchars_to_svr4_tchars(&bt, &st);
#ifdef DEBUG_SVR4
			print_svr4_tchars("SVR4_TIOCGETC", &st);
#endif /* DEBUG_SVR4 */
			return copyout(&st, data, sizeof(st));
		}

	case SVR4_TIOCSETC:
		{
			struct tchars bt;
			struct svr4_tchars st;

			if ((error = copyin(data, &st, sizeof(st))) != 0)
				return error;

			svr4_tchars_to_bsd_tchars(&st, &bt);
#ifdef DEBUG_SVR4
			print_svr4_tchars("SVR4_TIOCSETC", &st);
#endif /* DEBUG_SVR4 */
			return (*ctl)(fp, TIOCSETC, (caddr_t) &bt, p);
		}

	case SVR4_TIOCGLTC:
		{
			struct ltchars bl;
			struct svr4_ltchars sl;

			error = (*ctl)(fp, TIOCGLTC, (caddr_t) &bl, p);
			if (error)
				return error;

			bsd_ltchars_to_svr4_ltchars(&bl, &sl);
#ifdef DEBUG_SVR4
			print_svr4_ltchars("SVR4_TIOCGLTC", &sl);
#endif /* DEBUG_SVR4 */
			return copyout(&sl, data, sizeof(sl));
		}

	case SVR4_TIOCSLTC:
		{
			struct ltchars bl;
			struct svr4_ltchars sl;

			if ((error = copyin(data, &sl, sizeof(sl))) != 0)
				return error;

			svr4_ltchars_to_bsd_ltchars(&sl, &bl);
#ifdef DEBUG_SVR4
			print_svr4_ltchars("SVR4_TIOCSLTC", &sl);
#endif /* DEBUG_SVR4 */
			return (*ctl)(fp, TIOCSLTC, (caddr_t) &bl, p);
		}

	case SVR4_TIOCLGET:
		{
			int flags;
			if ((error = (*ctl)(fp, cmd, (caddr_t) &flags, p)) !=
			    0)
				return error;
			DPRINTF(("SVR4_TIOCLGET %o\n", flags));
			return copyout(&flags, data, sizeof(flags));
		}

	case SVR4_TIOCLSET:
	case SVR4_TIOCLBIS:
	case SVR4_TIOCLBIC:
		{
			int flags;

			if ((error = copyin(data, &flags, sizeof(flags))) != 0)
				return error;

			switch (cmd) {
			case SVR4_TIOCLSET:
				cmd = TIOCLSET;
				break;
			case SVR4_TIOCLBIS:
				cmd = TIOCLBIS;
				break;
			case SVR4_TIOCLBIC:
				cmd = TIOCLBIC;
				break;
			}

			DPRINTF(("SVR4_TIOCL{SET,BIS,BIC} %o\n", flags));
			return (*ctl)(fp, cmd, (caddr_t) &flags, p);
		}

	default:
		DPRINTF(("Unknown svr4 ttold %lx\n", cmd));
		return 0;	/* ENOSYS really */
	}
}
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_ttold.c,v 1.6 2000/08/29 02:22:14 brad Exp $	 */
@


1.6
log
@remove duplicate inclusion of sys/ioctl.h
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_ttold.c,v 1.5 1996/08/01 00:50:56 niklas Exp $	 */
d54 12
a65 12
static void svr4_tchars_to_bsd_tchars __P((const struct svr4_tchars *st,
					   struct tchars *bt));
static void bsd_tchars_to_svr4_tchars __P((const struct tchars *bt,
					   struct svr4_tchars *st));
static void svr4_sgttyb_to_bsd_sgttyb __P((const struct svr4_sgttyb *ss,
					   struct sgttyb *bs));
static void bsd_sgttyb_to_svr4_sgttyb __P((const struct sgttyb *bs,
					   struct svr4_sgttyb *ss));
static void svr4_ltchars_to_bsd_ltchars __P((const struct svr4_ltchars *sl,
					     struct ltchars *bl));
static void bsd_ltchars_to_svr4_ltchars __P((const struct ltchars *bl,
					     struct svr4_ltchars *sl));
d68 3
a70 3
static void print_svr4_sgttyb __P((const char *, struct svr4_sgttyb *));
static void print_svr4_tchars __P((const char *, struct svr4_tchars *));
static void print_svr4_ltchars __P((const char *, struct svr4_ltchars *));
d195 1
a195 1
	int (*ctl) __P((struct file *, u_long,  caddr_t, struct proc *)) =
@


1.6.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_ttold.c,v 1.6 2000/08/29 02:22:14 brad Exp $	 */
d54 12
a65 12
static void svr4_tchars_to_bsd_tchars(const struct svr4_tchars *st,
					   struct tchars *bt);
static void bsd_tchars_to_svr4_tchars(const struct tchars *bt,
					   struct svr4_tchars *st);
static void svr4_sgttyb_to_bsd_sgttyb(const struct svr4_sgttyb *ss,
					   struct sgttyb *bs);
static void bsd_sgttyb_to_svr4_sgttyb(const struct sgttyb *bs,
					   struct svr4_sgttyb *ss);
static void svr4_ltchars_to_bsd_ltchars(const struct svr4_ltchars *sl,
					     struct ltchars *bl);
static void bsd_ltchars_to_svr4_ltchars(const struct ltchars *bl,
					     struct svr4_ltchars *sl);
d68 3
a70 3
static void print_svr4_sgttyb(const char *, struct svr4_sgttyb *);
static void print_svr4_tchars(const char *, struct svr4_tchars *);
static void print_svr4_ltchars(const char *, struct svr4_ltchars *);
d195 1
a195 1
	int (*ctl)(struct file *, u_long,  caddr_t, struct proc *) =
@


1.5
log
@Merge of NetBSD 0722
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_ttold.c,v 1.4 1996/04/21 22:18:40 deraadt Exp $	 */
a39 1
#include <sys/ioctl.h>
@


1.5.16.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_ttold.c,v 1.6 2000/08/29 02:22:14 brad Exp $	 */
d40 1
@


1.5.16.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	 */
d54 12
a65 12
static void svr4_tchars_to_bsd_tchars(const struct svr4_tchars *st,
					   struct tchars *bt);
static void bsd_tchars_to_svr4_tchars(const struct tchars *bt,
					   struct svr4_tchars *st);
static void svr4_sgttyb_to_bsd_sgttyb(const struct svr4_sgttyb *ss,
					   struct sgttyb *bs);
static void bsd_sgttyb_to_svr4_sgttyb(const struct sgttyb *bs,
					   struct svr4_sgttyb *ss);
static void svr4_ltchars_to_bsd_ltchars(const struct svr4_ltchars *sl,
					     struct ltchars *bl);
static void bsd_ltchars_to_svr4_ltchars(const struct ltchars *bl,
					     struct svr4_ltchars *sl);
d68 3
a70 3
static void print_svr4_sgttyb(const char *, struct svr4_sgttyb *);
static void print_svr4_tchars(const char *, struct svr4_tchars *);
static void print_svr4_ltchars(const char *, struct svr4_ltchars *);
d195 1
a195 1
	int (*ctl)(struct file *, u_long,  caddr_t, struct proc *) =
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD$	 */
d68 36
d210 1
a210 1
			DPRINTF(("TIOCGPGRP %d", pid));
d224 1
a224 1
			DPRINTF(("TIOCSPGRP %d", pid));
d237 1
a237 1
			DPRINTF(("TIOCGSID %d", pid));
d252 3
d268 3
a270 1

d285 3
d300 3
a302 1

d316 3
d331 15
d347 23
a369 1
			return (*ctl)(fp, TIOCSLTC, (caddr_t) &bl, p);
@


1.3
log
@Good fixes and changes from latest Net.
@
text
@d1 2
a2 1
/*	$NetBSD: svr4_ttold.c,v 1.8 1996/03/30 22:38:27 christos Exp $	 */
d151 1
a151 1
svr4_ttoldioctl(fp, cmd, data, p, retval)
d153 3
a157 2
	struct proc *p;
	register_t *retval;
@


1.2
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: svr4_ttold.c,v 1.7 1995/10/14 20:25:01 christos Exp $	 */
d285 1
a285 1
		DPRINTF(("Unknown svr4 ttold %x\n", cmd));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: svr4_ttold.c,v 1.6 1995/10/07 06:27:56 mycroft Exp $	 */
d52 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
