head	1.29;
access;
symbols
	OPENBSD_4_9:1.28.0.10
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.8
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.4
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.6
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.27.0.14
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.12
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.10
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.8
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.6
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.27.0.4
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.26.0.4
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.22
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.19.0.6
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.4
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.17.0.6
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.4
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.11.0.6
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.4
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.4
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2011.07.04.23.01.33;	author tedu;	state dead;
branches;
next	1.28;

1.28
date	2009.01.29.22.08.45;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.07.00.18.33;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.22.23.52.18;	author jfb;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.15.20.32.16;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.07.22.16.26;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.09.22.27.11;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2000.09.07.17.52.24;	author ericj;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.24.21.00.30;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	99.10.07.16.14.28;	author brad;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	99.07.15.19.26.37;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	99.07.14.23.15.50;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.07.02.19.16.32;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.06.30.20.47.14;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.06.06.15.38.51;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.02.09.04.32.13;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	97.11.13.06.16.27;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.10.08.14.57.31;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	96.05.02.13.06.33;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.18.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.02.26.23.32.01;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	95.12.21.14.39.36;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.21.00.52.54;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.19.15.40.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.47.37;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.24;	author deraadt;	state Exp;
branches;
next	;

1.17.4.1
date	2001.05.14.22.05.27;	author niklas;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2002.03.28.11.28.07;	author niklas;	state Exp;
branches;
next	1.17.4.4;

1.17.4.4
date	2003.03.27.23.53.48;	author niklas;	state Exp;
branches;
next	1.17.4.5;

1.17.4.5
date	2003.05.13.19.21.27;	author ho;	state Exp;
branches;
next	1.17.4.6;

1.17.4.6
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.11.03.28.09;	author art;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2003.05.19.21.52.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@remove all the compat svr4 files
@
text
@/*	$OpenBSD: svr4_stat.c,v 1.28 2009/01/29 22:08:45 guenther Exp $	 */
/*	$NetBSD: svr4_stat.c,v 1.21 1996/04/22 01:16:07 christos Exp $	 */

/*
 * Copyright (c) 1994 Christos Zoulas
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/mount.h>
#include <sys/malloc.h>
#include <sys/unistd.h>

#include <sys/time.h>
#include <sys/ucred.h>
#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>

#include <sys/syscallargs.h>

#include <compat/svr4/svr4_types.h>
#include <compat/svr4/svr4_signal.h>
#include <compat/svr4/svr4_syscallargs.h>
#include <compat/svr4/svr4_util.h>
#include <compat/svr4/svr4_stat.h>
#include <compat/svr4/svr4_ustat.h>
#include <compat/svr4/svr4_fuser.h>
#include <compat/svr4/svr4_utsname.h>
#include <compat/svr4/svr4_systeminfo.h>
#include <compat/svr4/svr4_time.h>
#include <compat/svr4/svr4_socket.h>

#ifdef __sparc__
/* 
 * Solaris-2.4 on the sparc has the old stat call using the new
 * stat data structure...
 */
# define SVR4_NO_OSTAT
#endif

static void bsd_to_svr4_xstat(struct stat *, struct svr4_xstat *);
static void bsd_to_svr4_stat64(struct stat *, struct svr4_stat64 *);
int svr4_ustat(struct proc *, void *, register_t *);
static int svr4_to_bsd_pathconf(int);

/*
 * SVR4 uses named pipes as named sockets, so we tell programs
 * that sockets are named pipes with mode 0
 */
#define BSD_TO_SVR4_MODE(mode) (S_ISSOCK(mode) ? S_IFIFO : (mode))


#ifndef SVR4_NO_OSTAT
static void bsd_to_svr4_stat(struct stat *, struct svr4_stat *);

static void
bsd_to_svr4_stat(st, st4)
	struct stat		*st;
	struct svr4_stat 	*st4;
{
	bzero(st4, sizeof(*st4));
	st4->st_dev = bsd_to_svr4_odev_t(st->st_dev);
	st4->st_ino = st->st_ino;
	st4->st_mode = BSD_TO_SVR4_MODE(st->st_mode);
	st4->st_nlink = st->st_nlink;
	st4->st_uid = st->st_uid;
	st4->st_gid = st->st_gid;
	st4->st_rdev = bsd_to_svr4_odev_t(st->st_rdev);
	st4->st_size = st->st_size;
	st4->st_atim = st->st_atime;
	st4->st_mtim = st->st_mtime;
	st4->st_ctim = st->st_ctime;
}
#endif


static void
bsd_to_svr4_xstat(st, st4)
	struct stat		*st;
	struct svr4_xstat	*st4;
{
	bzero(st4, sizeof(*st4));
	st4->st_dev = bsd_to_svr4_dev_t(st->st_dev);
	st4->st_ino = st->st_ino;
	st4->st_mode = BSD_TO_SVR4_MODE(st->st_mode);
	st4->st_nlink = st->st_nlink;
	st4->st_uid = st->st_uid;
	st4->st_gid = st->st_gid;
	st4->st_rdev = bsd_to_svr4_dev_t(st->st_rdev);
	st4->st_size = st->st_size;
	st4->st_atim = st->st_atim;
	st4->st_mtim = st->st_mtim;
	st4->st_ctim = st->st_ctim;
	st4->st_blksize = st->st_blksize;
	st4->st_blocks = st->st_blocks;
	strlcpy(st4->st_fstype, "unknown", sizeof st4->st_fstype);
}

static void
bsd_to_svr4_stat64(st, st4)
	struct stat		*st;
	struct svr4_stat64	*st4;
{
	bzero(st4, sizeof(*st4));
	st4->st_dev = bsd_to_svr4_dev_t(st->st_dev);
	st4->st_ino = st->st_ino;
	st4->st_mode = BSD_TO_SVR4_MODE(st->st_mode); 
	st4->st_nlink = st->st_nlink;
	st4->st_uid = st->st_uid;
	st4->st_gid = st->st_gid;
	st4->st_rdev = bsd_to_svr4_dev_t(st->st_rdev);
	st4->st_size = st->st_size;
	st4->st_atim = st->st_atim;
	st4->st_mtim = st->st_mtim;  
	st4->st_ctim = st->st_ctim;
	st4->st_blksize = st->st_blksize;
	st4->st_blocks = st->st_blocks;
	strlcpy(st4->st_fstype, "unknown", sizeof st4->st_fstype);
}


int
svr4_sys_stat(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_stat_args *uap = v;
#ifdef SVR4_NO_OSTAT
	struct svr4_sys_xstat_args cup;

	SCARG(&cup, two) = 2;
	SCARG(&cup, path) = SCARG(uap, path);
	SCARG(&cup, ub) = (struct svr4_xstat *) SCARG(uap, ub);
	return svr4_sys_xstat(p, &cup, retval);
#else
	struct stat		st;
	struct svr4_stat	svr4_st;
	struct sys_stat_args	cup;
	int			error;

	caddr_t sg = stackgap_init(p->p_emul);
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));
	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&cup, path) = SCARG(uap, path);


	if ((error = sys_stat(p, &cup, retval)) != 0)
		return error;

	if ((error = copyin(SCARG(&cup, ub), &st, sizeof st)) != 0)
		return error;

	bsd_to_svr4_stat(&st, &svr4_st);

	if (S_ISSOCK(st.st_mode))
		(void) svr4_add_socket(p, SCARG(uap, path), &st);

	if ((error = copyout(&svr4_st, SCARG(uap, ub), sizeof svr4_st)) != 0)
		return error;

	return 0;
#endif
}

int
svr4_sys_lstat(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_lstat_args *uap = v;
#ifdef SVR4_NO_OSTAT
	struct svr4_sys_lxstat_args cup;

	SCARG(&cup, two) = 2;
	SCARG(&cup, path) = SCARG(uap, path);
	SCARG(&cup, ub) = (struct svr4_xstat *) SCARG(uap, ub);
	return svr4_sys_lxstat(p, &cup, retval);
#else
	struct stat		st;
	struct svr4_stat	svr4_st;
	struct sys_lstat_args	cup;
	int			error;

	caddr_t sg = stackgap_init(p->p_emul);
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));
	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&cup, path) = SCARG(uap, path);

	if ((error = sys_lstat(p, &cup, retval)) != 0)
		return error;

	if ((error = copyin(SCARG(&cup, ub), &st, sizeof st)) != 0)
		return error;

	bsd_to_svr4_stat(&st, &svr4_st);

	if (S_ISSOCK(st.st_mode))
		(void) svr4_add_socket(p, SCARG(uap, path), &st);

	if ((error = copyout(&svr4_st, SCARG(uap, ub), sizeof svr4_st)) != 0)
		return error;

	return 0;
#endif
}

int
svr4_sys_fstat(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_fstat_args *uap = v;
#ifdef SVR4_NO_OSTAT
	struct svr4_sys_fxstat_args cup;

	SCARG(&cup, two) = 2;
	SCARG(&cup, fd) = SCARG(uap, fd);
	SCARG(&cup, sb) = (struct svr4_xstat *) SCARG(uap, sb);
	return svr4_sys_fxstat(p, &cup, retval);
#else
	struct stat		st;
	struct svr4_stat	svr4_st;
	struct sys_fstat_args	cup;
	int			error;

	caddr_t sg = stackgap_init(p->p_emul);

	SCARG(&cup, fd) = SCARG(uap, fd);
	SCARG(&cup, sb) = stackgap_alloc(&sg, sizeof(struct stat));

	if ((error = sys_fstat(p, &cup, retval)) != 0)
		return error;

	if ((error = copyin(SCARG(&cup, sb), &st, sizeof st)) != 0)
		return error;

	bsd_to_svr4_stat(&st, &svr4_st);

	if ((error = copyout(&svr4_st, SCARG(uap, sb), sizeof svr4_st)) != 0)
		return error;

	return 0;
#endif
}


int
svr4_sys_xstat(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_xstat_args *uap = v;
	struct stat		st;
	struct svr4_xstat	svr4_st;
	struct sys_stat_args	cup;
	int			error;

	caddr_t sg = stackgap_init(p->p_emul);
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));
	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&cup, path) = SCARG(uap, path);

	if ((error = sys_stat(p, &cup, retval)) != 0)
		return error;

	if ((error = copyin(SCARG(&cup, ub), &st, sizeof st)) != 0)
		return error;

	bsd_to_svr4_xstat(&st, &svr4_st);

	if (S_ISSOCK(st.st_mode))
		(void) svr4_add_socket(p, SCARG(uap, path), &st);

	if ((error = copyout(&svr4_st, SCARG(uap, ub), sizeof svr4_st)) != 0)
		return error;

	return 0;
}

int
svr4_sys_lxstat(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_lxstat_args *uap = v;
	struct stat		st;
	struct svr4_xstat	svr4_st;
	struct sys_lstat_args	cup;
	int			error;

	caddr_t sg = stackgap_init(p->p_emul);
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));
	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&cup, path) = SCARG(uap, path);

	if ((error = sys_lstat(p, &cup, retval)) != 0)
		return error;

	if ((error = copyin(SCARG(&cup, ub), &st, sizeof st)) != 0)
		return error;

	bsd_to_svr4_xstat(&st, &svr4_st);

	if (S_ISSOCK(st.st_mode))
		(void) svr4_add_socket(p, SCARG(uap, path), &st);

	if ((error = copyout(&svr4_st, SCARG(uap, ub), sizeof svr4_st)) != 0)
		return error;

	return 0;
}

int
svr4_sys_fxstat(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_fxstat_args *uap = v;
	struct stat		st;
	struct svr4_xstat	svr4_st;
	struct sys_fstat_args	cup;
	int			error;

	caddr_t sg = stackgap_init(p->p_emul);

	SCARG(&cup, fd) = SCARG(uap, fd);
	SCARG(&cup, sb) = stackgap_alloc(&sg, sizeof(struct stat));

	if ((error = sys_fstat(p, &cup, retval)) != 0)
		return error;

	if ((error = copyin(SCARG(&cup, sb), &st, sizeof st)) != 0)
		return error;

	bsd_to_svr4_xstat(&st, &svr4_st);

	if ((error = copyout(&svr4_st, SCARG(uap, sb), sizeof svr4_st)) != 0)
		return error;

	return 0;
}


int
svr4_sys_stat64(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_stat64_args *uap = v;
	struct stat		st;
	struct svr4_stat64	svr4_st;
	struct sys_stat_args	cup;
	int			error;

	caddr_t sg = stackgap_init(p->p_emul);

	SCARG(&cup, path) = SCARG(uap, path);
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));

	if ((error = sys_stat(p, &cup, retval)) != 0)
		return error;

	if ((error = copyin(SCARG(&cup, ub), &st, sizeof st)) != 0)
		return error;

	bsd_to_svr4_stat64(&st, &svr4_st);

	if (S_ISSOCK(st.st_mode))
		(void) svr4_add_socket(p, SCARG(uap, path), &st);

	if ((error = copyout(&svr4_st, SCARG(uap, sb), sizeof svr4_st)) != 0)
		return error;

	return 0;
}


int
svr4_sys_lstat64(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_lstat64_args *uap = v;
	struct stat		st;
	struct svr4_stat64	svr4_st;
	struct sys_lstat_args	cup;
	int			error;

	caddr_t sg = stackgap_init(p->p_emul);

	SCARG(&cup, path) = SCARG(uap, path);
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));

	if ((error = sys_lstat(p, &cup, retval)) != 0)
		return error;

	if ((error = copyin(SCARG(&cup, ub), &st, sizeof st)) != 0)
		return error;

	bsd_to_svr4_stat64(&st, &svr4_st);

	if (S_ISSOCK(st.st_mode))
		(void) svr4_add_socket(p, SCARG(uap, path), &st);

	if ((error = copyout(&svr4_st, SCARG(uap, sb), sizeof svr4_st)) != 0)
		return error;

	return 0;
}


int
svr4_sys_fstat64(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_fstat64_args *uap = v;
	struct stat		st;
	struct svr4_stat64	svr4_st;
	struct sys_fstat_args	cup;
	int			error;

	caddr_t sg = stackgap_init(p->p_emul);

	SCARG(&cup, fd) = SCARG(uap, fd);
	SCARG(&cup, sb) = stackgap_alloc(&sg, sizeof(struct stat));

	if ((error = sys_fstat(p, &cup, retval)) != 0)
		return error;

	if ((error = copyin(SCARG(&cup, sb), &st, sizeof st)) != 0)
		return error;   

	bsd_to_svr4_stat64(&st, &svr4_st);

	if ((error = copyout(&svr4_st, SCARG(uap, sb), sizeof svr4_st)) != 0)
		return error;

	return 0;
}


struct svr4_ustat_args {
	syscallarg(svr4_dev_t)		dev;
	syscallarg(struct svr4_ustat *) name;
};

int
svr4_ustat(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_ustat_args /* {
		syscallarg(svr4_dev_t)		dev;
		syscallarg(struct svr4_ustat *) name;
	} */ *uap = v;
	struct svr4_ustat	us;
	int			error;

	bzero(&us, sizeof us);

	/*
	 * XXX: should set f_tfree and f_tinode at least
	 * How do we translate dev -> fstat? (and then to svr4_ustat)
	 */
	if ((error = copyout(&us, SCARG(uap, name), sizeof us)) != 0)
		return (error);

	return 0;
}



int
svr4_sys_uname(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_uname_args *uap = v;
	struct svr4_utsname	*sut;
	extern char hostname[], machine[];
	const char *cp;
	char *dp, *ep;
	int error;

	sut = malloc(sizeof(*sut), M_TEMP, M_WAITOK); 
	bzero(sut, sizeof(*sut));
	strlcpy(sut->sysname, ostype, sizeof(sut->sysname));
	strlcpy(sut->nodename, hostname, sizeof(sut->nodename));
	strlcpy(sut->release, osrelease, sizeof(sut->release));

	dp = sut->version;
	ep = &sut->version[sizeof(sut->version) - 1];
	for (cp = version; *cp && *cp != '('; cp++)
		;
	for (cp++; *cp && *cp != ')' && dp < ep; cp++)
		*dp++ = *cp;
	for (; *cp && *cp != '#'; cp++)
		;
	for (; *cp && *cp != ':' && dp < ep; cp++)
		*dp++ = *cp;
	*dp = '\0';

	strlcpy(sut->machine, machine, sizeof(sut->machine));

	error = copyout(sut, SCARG(uap, name), sizeof(struct svr4_utsname));
	free(sut, M_TEMP);
	return (error);
}

int
svr4_sys_systeminfo(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_systeminfo_args *uap = v;
	const char *str;
	int name;
	int error;
	long len;
	extern char hostname[], machine[], domainname[];
#ifdef __sparc__
	extern char *cpu_class;
#endif

	u_int rlen = SCARG(uap, len);

	switch (SCARG(uap, what)) {
	case SVR4_SI_SYSNAME:
		str = ostype;
		break;

	case SVR4_SI_HOSTNAME:
		str = hostname;
		break;

	case SVR4_SI_RELEASE:
		str = osrelease;
		break;

	case SVR4_SI_VERSION:
		str = version;
		break;

	case SVR4_SI_MACHINE:
		str = machine;
		break;

	case SVR4_SI_ARCHITECTURE:
		str = machine;
		break;

	case SVR4_SI_HW_SERIAL:
		str = "0";
		break;

	case SVR4_SI_HW_PROVIDER:
		str = ostype;
		break;

	case SVR4_SI_SRPC_DOMAIN:
		str = domainname;
		break;

	case SVR4_SI_PLATFORM:
#ifdef __sparc__
		str = cpu_class;
#else
		str = machine;
#endif
		break;

	case SVR4_SI_KERB_REALM:
		str = "unsupported";
		break;

	case SVR4_SI_SET_HOSTNAME:
		if ((error = suser(p, 0)) != 0)
			return error;
		name = KERN_HOSTNAME;
		return kern_sysctl(&name, 1, 0, 0, SCARG(uap, buf), rlen, p);

	case SVR4_SI_SET_SRPC_DOMAIN:
		if ((error = suser(p, 0)) != 0)
			return error;
		name = KERN_DOMAINNAME;
		return kern_sysctl(&name, 1, 0, 0, SCARG(uap, buf), rlen, p);

	case SVR4_SI_SET_KERB_REALM:
		return 0;

	default:
		DPRINTF(("Bad systeminfo command %d\n", SCARG(uap, what)));
		return ENOSYS;
	}

	/* on success, sysinfo() returns byte count including \0 */
	/* result is not diminished if user buffer was too small */
	len = strlen(str) + 1;
	*retval = len;

	/* nothing to copy if user buffer is empty */
	if (rlen == 0)
		return 0;

	if (len > rlen) {
		char nul = 0;

		/* if str overruns buffer, put NUL in last place */
		len = rlen - 1;
		if (copyout(&nul, SCARG(uap, buf), sizeof(char)) != 0)
			return EFAULT;
	}

	return copyout(str, SCARG(uap, buf), len);
}


int
svr4_sys_utssys(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_utssys_args *uap = v;

	switch (SCARG(uap, sel)) {
	case 0:		/* uname(2)  */
		{
			struct svr4_sys_uname_args ua;
			SCARG(&ua, name) = SCARG(uap, a1);
			return svr4_sys_uname(p, &ua, retval);
		}

	case 2:		/* ustat(2)  */
		{
			struct svr4_ustat_args ua;
			SCARG(&ua, dev) = (svr4_dev_t) SCARG(uap, a2);
			SCARG(&ua, name) = SCARG(uap, a1);
			return svr4_ustat(p, &ua, retval);
		}

	case 3:		/* fusers(2) */
		return ENOSYS;

	default:
		return ENOSYS;
	}
	return ENOSYS;
}


int
svr4_sys_utime(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_utime_args *uap = v;
	struct svr4_utimbuf ub;
	struct timeval tbuf[2];
	struct sys_utimes_args ap;
	int error;
	caddr_t sg = stackgap_init(p->p_emul);

	SCARG(&ap, tptr) = stackgap_alloc(&sg, sizeof(tbuf));
	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	SCARG(&ap, path) = SCARG(uap, path);
	if (SCARG(uap, ubuf) != NULL) {
		if ((error = copyin(SCARG(uap, ubuf), &ub, sizeof(ub))) != 0)
			return error;
		tbuf[0].tv_sec = ub.actime;
		tbuf[0].tv_usec = 0;
		tbuf[1].tv_sec = ub.modtime;
		tbuf[1].tv_usec = 0;
		error = copyout(tbuf, (struct timeval *)SCARG(&ap, tptr), sizeof(tbuf));
		if (error)
			return error;
	}
	else
		SCARG(&ap, tptr) = NULL;
	return sys_utimes(p, &ap, retval);
}


int
svr4_sys_utimes(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_utimes_args *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);
	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_utimes(p, uap, retval);
}


static int
svr4_to_bsd_pathconf(name)
	int name;
{
	switch (name) {
	case SVR4_PC_LINK_MAX:
	    	return _PC_LINK_MAX;

	case SVR4_PC_MAX_CANON:
		return _PC_MAX_CANON;

	case SVR4_PC_MAX_INPUT:
		return _PC_MAX_INPUT;

	case SVR4_PC_NAME_MAX:
		return _PC_NAME_MAX;

	case SVR4_PC_PATH_MAX:
		return _PC_PATH_MAX;

	case SVR4_PC_PIPE_BUF:
		return _PC_PIPE_BUF;

	case SVR4_PC_NO_TRUNC:
		return _PC_NO_TRUNC;

	case SVR4_PC_VDISABLE:
		return _PC_VDISABLE;

	case SVR4_PC_CHOWN_RESTRICTED:
		return _PC_CHOWN_RESTRICTED;

	case SVR4_PC_ASYNC_IO:
	case SVR4_PC_PRIO_IO:
	case SVR4_PC_SYNC_IO:
		/* Not supported */
		return 0;

	default:
		/* Invalid */
		return -1;
	}
}


int
svr4_sys_pathconf(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_pathconf_args *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(uap, name) = svr4_to_bsd_pathconf(SCARG(uap, name));

	switch (SCARG(uap, name)) {
	case -1:
		*retval = -1;
		return EINVAL;
	case 0:
		*retval = 0;
		return 0;
	default:
		return sys_pathconf(p, uap, retval);
	}
}

int
svr4_sys_fpathconf(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_fpathconf_args *uap = v;

	SCARG(uap, name) = svr4_to_bsd_pathconf(SCARG(uap, name));

	switch (SCARG(uap, name)) {
	case -1:
		*retval = -1;
		return EINVAL;
	case 0:
		*retval = 0;
		return 0;
	default:
		return sys_fpathconf(p, uap, retval);
	}
}
@


1.28
log
@Switch struct stat's timespec members to the names standardized in
POSIX 1003.1-2008, with compatibility macros for the names used in
previous version of OpenBSD.  Update all the references in the
kernel to use the new, standard member names.

ok'ed by miod@@, otto@@; ports build test by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.27 2005/08/07 00:18:33 deraadt Exp $	 */
@


1.27
log
@malloc svr4_utsname struct as needed instead of on stack; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.26 2004/06/22 23:52:18 jfb Exp $	 */
d100 3
a102 3
	st4->st_atim = st->st_atimespec.tv_sec;
	st4->st_mtim = st->st_mtimespec.tv_sec;
	st4->st_ctim = st->st_ctimespec.tv_sec;
d121 3
a123 3
	st4->st_atim = st->st_atimespec;
	st4->st_mtim = st->st_mtimespec;
	st4->st_ctim = st->st_ctimespec;
d143 3
a145 3
	st4->st_atim = st->st_atimespec;
	st4->st_mtim = st->st_mtimespec;  
	st4->st_ctim = st->st_ctimespec;
@


1.26
log
@Replace a whole bunch of scary uses of strncpy() with strlcpy() and
use compat-specific MAXNAMLEN values where appropriate

ok millert@@, pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.25 2003/08/15 20:32:16 tedu Exp $	 */
d525 1
a525 1
	struct svr4_utsname	sut;
d529 1
d531 5
a535 4
	bzero(&sut, sizeof(sut));
	strlcpy(sut.sysname, ostype, sizeof(sut.sysname));
	strlcpy(sut.nodename, hostname, sizeof(sut.nodename));
	strlcpy(sut.release, osrelease, sizeof(sut.release));
d537 2
a538 2
	dp = sut.version;
	ep = &sut.version[sizeof(sut.version) - 1];
d549 1
a549 1
	strlcpy(sut.machine, machine, sizeof(sut.machine));
d551 3
a553 2
	return copyout((caddr_t) &sut, (caddr_t) SCARG(uap, name),
		       sizeof(struct svr4_utsname));
@


1.25
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.24 2003/05/07 22:16:26 deraadt Exp $	 */
d531 3
a533 9

	strncpy(sut.sysname, ostype, sizeof(sut.sysname)-1);
	sut.sysname[sizeof(sut.sysname) - 1] = '\0';

	strncpy(sut.nodename, hostname, sizeof(sut.nodename)-1);
	sut.nodename[sizeof(sut.nodename) - 1] = '\0';

	strncpy(sut.release, osrelease, sizeof(sut.release)-1);
	sut.release[sizeof(sut.release) - 1] = '\0';
d547 1
a547 2
	strncpy(sut.machine, machine, sizeof(sut.machine)-1);
	sut.machine[sizeof(sut.machine) - 1] = '\0';
@


1.24
log
@string cleaning; ok art tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.23 2003/01/09 22:27:11 miod Exp $	 */
d628 1
a628 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d634 1
a634 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.23
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.22 2002/03/14 20:31:31 mickey Exp $	 */
d126 1
a126 1
	strcpy(st4->st_fstype, "unknown");
d135 14
a148 14
        st4->st_dev = bsd_to_svr4_dev_t(st->st_dev);
        st4->st_ino = st->st_ino;
        st4->st_mode = BSD_TO_SVR4_MODE(st->st_mode); 
        st4->st_nlink = st->st_nlink;
        st4->st_uid = st->st_uid;
        st4->st_gid = st->st_gid;
        st4->st_rdev = bsd_to_svr4_dev_t(st->st_rdev);
        st4->st_size = st->st_size;
        st4->st_atim = st->st_atimespec;
        st4->st_mtim = st->st_mtimespec;  
        st4->st_ctim = st->st_ctimespec;
        st4->st_blksize = st->st_blksize;
        st4->st_blocks = st->st_blocks;
        strcpy(st4->st_fstype, "unknown");
d507 3
a509 3
         * XXX: should set f_tfree and f_tinode at least
         * How do we translate dev -> fstat? (and then to svr4_ustat)
         */
@


1.22
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.21 2002/03/14 01:26:51 millert Exp $	 */
d657 2
d661 1
a661 1
		if (subyte(SCARG(uap, buf) + len, 0) < 0)
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.20 2001/11/06 19:53:18 miod Exp $	 */
d526 3
a528 2
	extern char ostype[], hostname[], osrelease[], version[], machine[];
	char *cp, *dp, *ep;
d567 1
a567 1
	char *str;
d571 1
a571 2
	extern char ostype[], hostname[], osrelease[],
		    version[], machine[], domainname[];
@


1.20
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.19 2000/09/07 17:52:24 ericj Exp $	 */
d71 4
a74 4
static void bsd_to_svr4_xstat __P((struct stat *, struct svr4_xstat *));
static void bsd_to_svr4_stat64 __P((struct stat *, struct svr4_stat64 *));
int svr4_ustat __P((struct proc *, void *, register_t *));
static int svr4_to_bsd_pathconf __P((int));
d84 1
a84 1
static void bsd_to_svr4_stat __P((struct stat *, struct svr4_stat *));
@


1.20.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.20 2001/11/06 19:53:18 miod Exp $	 */
d71 4
a74 4
static void bsd_to_svr4_xstat(struct stat *, struct svr4_xstat *);
static void bsd_to_svr4_stat64(struct stat *, struct svr4_stat64 *);
int svr4_ustat(struct proc *, void *, register_t *);
static int svr4_to_bsd_pathconf(int);
d84 1
a84 1
static void bsd_to_svr4_stat(struct stat *, struct svr4_stat *);
d526 2
a527 3
	extern char hostname[], machine[];
	const char *cp;
	char *dp, *ep;
d566 1
a566 1
	const char *str;
d570 2
a571 1
	extern char hostname[], machine[], domainname[];
@


1.20.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	 */
d126 1
a126 1
	strlcpy(st4->st_fstype, "unknown", sizeof st4->st_fstype);
d135 14
a148 14
	st4->st_dev = bsd_to_svr4_dev_t(st->st_dev);
	st4->st_ino = st->st_ino;
	st4->st_mode = BSD_TO_SVR4_MODE(st->st_mode); 
	st4->st_nlink = st->st_nlink;
	st4->st_uid = st->st_uid;
	st4->st_gid = st->st_gid;
	st4->st_rdev = bsd_to_svr4_dev_t(st->st_rdev);
	st4->st_size = st->st_size;
	st4->st_atim = st->st_atimespec;
	st4->st_mtim = st->st_mtimespec;  
	st4->st_ctim = st->st_ctimespec;
	st4->st_blksize = st->st_blksize;
	st4->st_blocks = st->st_blocks;
	strlcpy(st4->st_fstype, "unknown", sizeof st4->st_fstype);
d507 3
a509 3
	 * XXX: should set f_tfree and f_tinode at least
	 * How do we translate dev -> fstat? (and then to svr4_ustat)
	 */
a656 2
		char nul = 0;

d659 1
a659 1
		if (copyout(&nul, SCARG(uap, buf), sizeof(char)) != 0)
@


1.19
log
@common/compat_util.c
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.18 2000/06/24 21:00:30 fgsch Exp $	 */
d46 1
a46 1
#include <vm/vm.h>
@


1.18
log
@Implement getdents64, lstat64 and stat64, basically the same functions of
the existing ones using 64bit vars. This makes netscape-solaris works on
sparc.

Particular note to those who want to try netscape:
- netscape 4.73 was used for testing on a ss5 with -current.
- apparently solaris uses pipes for communicating with the X server. I've
  checked the libraries I've installed from a solaris 2.6 box, and although
  there are references to X11-unix, it fails when it tries to open
  X11-pipe/X0, so in order to test it you need to specify -display <box ip>:0
  or it won't start.
- i got some errors when starting, but besides that, it works fine.
- it's not slow, but you better have all the requiered files in the correct
  paths, or it'll take some time to start.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.17 1999/10/07 16:14:28 brad Exp $	 */
d173 1
a176 1
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));
d218 1
a221 1
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));
d295 1
a298 1
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));
d330 1
a333 1
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));
d714 1
a723 1
		SCARG(&ap, tptr) = stackgap_alloc(&sg, sizeof(tbuf));
@


1.17
log
@- Fix stat and mknod syscalls to properly disassemble and reassemble
  dev_t values to/from emulation dev_t's
- Implement fstat64, llseek and open64 system calls; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.16 1999/07/15 19:26:37 deraadt Exp $	 */
d376 70
@


1.17.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.19 2000/09/07 17:52:24 ericj Exp $	 */
a172 1
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));
d176 1
a217 1
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));
d221 1
a294 1
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));
d298 1
a329 1
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));
d333 1
a384 70
svr4_sys_stat64(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_stat64_args *uap = v;
	struct stat		st;
	struct svr4_stat64	svr4_st;
	struct sys_stat_args	cup;
	int			error;

	caddr_t sg = stackgap_init(p->p_emul);

	SCARG(&cup, path) = SCARG(uap, path);
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));

	if ((error = sys_stat(p, &cup, retval)) != 0)
		return error;

	if ((error = copyin(SCARG(&cup, ub), &st, sizeof st)) != 0)
		return error;

	bsd_to_svr4_stat64(&st, &svr4_st);

	if (S_ISSOCK(st.st_mode))
		(void) svr4_add_socket(p, SCARG(uap, path), &st);

	if ((error = copyout(&svr4_st, SCARG(uap, sb), sizeof svr4_st)) != 0)
		return error;

	return 0;
}


int
svr4_sys_lstat64(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_lstat64_args *uap = v;
	struct stat		st;
	struct svr4_stat64	svr4_st;
	struct sys_lstat_args	cup;
	int			error;

	caddr_t sg = stackgap_init(p->p_emul);

	SCARG(&cup, path) = SCARG(uap, path);
	SCARG(&cup, ub) = stackgap_alloc(&sg, sizeof(struct stat));

	if ((error = sys_lstat(p, &cup, retval)) != 0)
		return error;

	if ((error = copyin(SCARG(&cup, ub), &st, sizeof st)) != 0)
		return error;

	bsd_to_svr4_stat64(&st, &svr4_st);

	if (S_ISSOCK(st.st_mode))
		(void) svr4_add_socket(p, SCARG(uap, path), &st);

	if ((error = copyout(&svr4_st, SCARG(uap, sb), sizeof svr4_st)) != 0)
		return error;

	return 0;
}


int
a643 1
	SCARG(&ap, tptr) = stackgap_alloc(&sg, sizeof(tbuf));
d653 1
@


1.17.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	 */
d46 1
a46 1
#include <uvm/uvm_extern.h>
@


1.17.4.3
log
@Merge in -current from about a week ago
@
text
@d71 4
a74 4
static void bsd_to_svr4_xstat(struct stat *, struct svr4_xstat *);
static void bsd_to_svr4_stat64(struct stat *, struct svr4_stat64 *);
int svr4_ustat(struct proc *, void *, register_t *);
static int svr4_to_bsd_pathconf(int);
d84 1
a84 1
static void bsd_to_svr4_stat(struct stat *, struct svr4_stat *);
d526 2
a527 3
	extern char hostname[], machine[];
	const char *cp;
	char *dp, *ep;
d566 1
a566 1
	const char *str;
d570 2
a571 1
	extern char hostname[], machine[], domainname[];
@


1.17.4.4
log
@Sync the SMP branch with 3.3
@
text
@a656 2
		char nul = 0;

d659 1
a659 1
		if (copyout(&nul, SCARG(uap, buf), sizeof(char)) != 0)
@


1.17.4.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.17.4.4 2003/03/27 23:53:48 niklas Exp $	 */
d126 1
a126 1
	strlcpy(st4->st_fstype, "unknown", sizeof st4->st_fstype);
d135 14
a148 14
	st4->st_dev = bsd_to_svr4_dev_t(st->st_dev);
	st4->st_ino = st->st_ino;
	st4->st_mode = BSD_TO_SVR4_MODE(st->st_mode); 
	st4->st_nlink = st->st_nlink;
	st4->st_uid = st->st_uid;
	st4->st_gid = st->st_gid;
	st4->st_rdev = bsd_to_svr4_dev_t(st->st_rdev);
	st4->st_size = st->st_size;
	st4->st_atim = st->st_atimespec;
	st4->st_mtim = st->st_mtimespec;  
	st4->st_ctim = st->st_ctimespec;
	st4->st_blksize = st->st_blksize;
	st4->st_blocks = st->st_blocks;
	strlcpy(st4->st_fstype, "unknown", sizeof st4->st_fstype);
d507 3
a509 3
	 * XXX: should set f_tfree and f_tinode at least
	 * How do we translate dev -> fstat? (and then to svr4_ustat)
	 */
@


1.17.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	 */
d628 1
a628 1
		if ((error = suser(p, 0)) != 0)
d634 1
a634 1
		if ((error = suser(p, 0)) != 0)
@


1.16
log
@oops, wrong type for cpu_class
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.15 1999/07/14 23:15:50 deraadt Exp $	 */
d72 1
d92 1
a92 1
	st4->st_dev = st->st_dev;
d98 1
a98 1
	st4->st_rdev = st->st_rdev;
a106 1

d113 1
a113 1
	st4->st_dev = st->st_dev;
d119 1
a119 1
	st4->st_rdev = st->st_rdev;
d129 22
d382 33
@


1.15
log
@put sub-class of architecture in SVR4_SI_PLATFORM
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.14 1999/07/02 19:16:32 deraadt Exp $	 */
d448 1
a448 1
	extern char cpu_class[];
@


1.14
log
@more systeminfo() fixes; hal@@sdsi.com
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.11 1998/02/09 04:32:13 tholo Exp $	 */
d406 1
a406 1
	strncpy(sut.sysname, ostype, sizeof(sut.sysname));
d409 1
a409 1
	strncpy(sut.nodename, hostname, sizeof(sut.nodename));
d412 1
a412 1
	strncpy(sut.release, osrelease, sizeof(sut.release));
d427 1
a427 1
	strncpy(sut.machine, machine, sizeof(sut.machine));
d447 3
d491 3
d495 1
@


1.13
log
@put non-space names in systeminfo(SI_PLATFORM); hal_snyder@@sdsi.com
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.12 1999/06/06 15:38:51 deraadt Exp $	 */
d515 2
d518 5
a522 2
	if (len > rlen)
		len = rlen;
d524 6
a529 2
	/* on success, sysinfo() returns byte count including \0 */
	*retval = len;
@


1.12
log
@use __sparc__
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.11 1998/02/09 04:32:13 tholo Exp $	 */
d446 1
a446 1
		    version[], machine[], domainname[], cpu_model[];
d488 1
a488 1
		str = cpu_model;
d518 3
@


1.11
log
@Missed one
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.10 1997/11/13 06:16:27 deraadt Exp $	 */
d63 1
a63 1
#ifdef sparc
@


1.10
log
@Fix test for NULL arg in svr4_utime() (PR#4418); pk
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.9 1997/10/08 14:57:31 kstailey Exp $	 */
d580 1
a580 1
		error = copyout(tbuf, SCARG(&ap, tptr), sizeof(tbuf));
@


1.9
log
@use shorter uname version string
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stat.c,v 1.7 1996/04/21 22:18:27 deraadt Exp $	 */
d572 1
a572 1
	if (SCARG(uap, ubuf) == NULL) {
@


1.8
log
@Add SI_SYSTEMINFO from Solaris-2.5
@
text
@d402 1
a402 1

d415 11
a425 2
	strncpy(sut.version, version, sizeof(sut.version));
	sut.version[sizeof(sut.version) - 1] = '\0';
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: svr4_stat.c,v 1.6 1996/02/26 23:32:01 niklas Exp $	 */
/*	$NetBSD: svr4_stat.c,v 1.20 1996/04/11 12:46:41 christos Exp $	 */
d437 1
a437 1
		    version[], machine[], domainname[];
d478 8
d497 3
@


1.6
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	 */
/*	$NetBSD: svr4_stat.c,v 1.19 1996/02/10 17:12:36 christos Exp $	 */
d61 1
d75 6
d93 1
a93 1
	st4->st_mode = st->st_mode;
d115 1
a115 1
	st4->st_mode = st->st_mode;
d165 3
d209 3
d286 3
d320 3
@


1.5
log
@from netbsd; do not declare private copy of syscallarg
@
text
@d1 2
a2 1
/*	$NetBSD: svr4_stat.c,v 1.16 1995/12/19 18:27:02 christos Exp $	 */
d42 1
d71 2
d92 3
a94 3
	st4->st_atim = st->st_atimespec.ts_sec;
	st4->st_mtim = st->st_mtimespec.ts_sec;
	st4->st_ctim = st->st_ctimespec.ts_sec;
d348 1
a348 1
svr4_ustat(p, uap, retval)
d350 3
d356 1
a356 3
	} */ *uap;
	register_t *retval;
{
d541 2
a542 1
		if (error = copyout(tbuf, SCARG(&ap, tptr), sizeof(tbuf)) != 0)
d561 93
@


1.4
log
@pull in svr4_time.h
@
text
@d1 1
a1 1
/*	$NetBSD: svr4_stat.c,v 1.15 1995/12/19 07:12:53 christos Exp $	 */
a53 1
#include <compat/svr4/svr4_time.h>
d58 1
a58 2

#define syscallarg(x)	union { x datum; register_t pad; }
@


1.3
log
@from christos; add utime() and utimes()
@
text
@d54 1
@


1.2
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: svr4_stat.c,v 1.14 1995/10/14 20:24:43 christos Exp $	 */
d511 45
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: svr4_stat.c,v 1.13 1995/10/07 06:27:49 mycroft Exp $	 */
d69 6
d93 2
d362 1
a362 1
	if (error = copyout(&us, SCARG(uap, name), sizeof us))
d456 1
a456 1
		if (error = suser(p->p_ucred, &p->p_acflag))
d459 1
a459 1
		return kern_sysctl(&name, 1, 0, 0, SCARG(uap, buf), rlen);
d462 1
a462 1
		if (error = suser(p->p_ucred, &p->p_acflag))
d465 1
a465 1
		return kern_sysctl(&name, 1, 0, 0, SCARG(uap, buf), rlen);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
