head	1.20;
access;
symbols
	OPENBSD_4_9:1.19.0.22
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.20
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.16
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.18
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.14
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.12
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.10
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.8
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.6
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.4
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.8
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.6
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.8
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.12
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.10
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.8
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2011.07.04.23.01.33;	author tedu;	state dead;
branches;
next	1.19;

1.19
date	2005.11.21.18.16.38;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.23.17.14.21;	author avsm;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.14.22.57.18;	author pvalchev;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.13.19.08.06;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.26.12.03.27;	author art;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.10.02.17.40.20;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.18.09.06.42;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.30.04.17.41;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	98.02.09.06.29.08;	author tholo;	state Exp;
branches
	1.10.10.1;
next	1.9;

1.9
date	97.09.11.10.48.13;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.08.07.09.16.21;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.02.13.19.45.24;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.08.01.00.50.54;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.05.22.11.45.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.18.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.17.05.24.22;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.26.23.32.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.24;	author deraadt;	state Exp;
branches;
next	;

1.10.10.1
date	2001.05.14.22.05.28;	author niklas;	state Exp;
branches;
next	1.10.10.2;

1.10.10.2
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.10.10.3;

1.10.10.3
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.10.10.4;

1.10.10.4
date	2002.03.28.11.28.07;	author niklas;	state Exp;
branches;
next	1.10.10.5;

1.10.10.5
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.06.11.03.28.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@remove all the compat svr4 files
@
text
@/*	$OpenBSD: svr4_stream.c,v 1.19 2005/11/21 18:16:38 millert Exp $	 */
/*	$NetBSD: svr4_stream.c,v 1.19 1996/12/22 23:00:03 fvdl Exp $	 */

/*
 * Copyright (c) 1994, 1996 Christos Zoulas.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Christos Zoulas.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Pretend that we have streams...
 * Yes, this is gross.
 *
 * ToDo: The state machine for getmsg needs re-thinking
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/selinfo.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/un.h>
#include <net/if.h>
#include <netinet/in.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/device.h>
#include <sys/stat.h>

#include <sys/syscallargs.h>

#include <compat/svr4/svr4_types.h>
#include <compat/svr4/svr4_util.h>
#include <compat/svr4/svr4_signal.h>
#include <compat/svr4/svr4_syscallargs.h>
#include <compat/svr4/svr4_stropts.h>
#include <compat/svr4/svr4_timod.h>
#include <compat/svr4/svr4_sockmod.h>
#include <compat/svr4/svr4_ioctl.h>
#include <compat/svr4/svr4_socket.h>

/* Utils */
static int clean_pipe(struct proc *, const char *);
static void getparm(struct file *, struct svr4_si_sockparms *);

/* Address Conversions */
static void sockaddr_to_netaddr_in(struct svr4_strmcmd *,
					const struct sockaddr_in *);
static void sockaddr_to_netaddr_un(struct svr4_strmcmd *,
					const struct sockaddr_un *);
static void netaddr_to_sockaddr_in(struct sockaddr_in *,
					const struct svr4_strmcmd *);
static void netaddr_to_sockaddr_un(struct sockaddr_un *,
					const struct svr4_strmcmd *);

/* stream ioctls */
static int i_nread(struct file *, struct proc *, register_t *, int,
			u_long, caddr_t);
static int i_fdinsert(struct file *, struct proc *, register_t *, int,
			   u_long, caddr_t);
static int i_str(struct file *, struct proc *, register_t *, int,
			u_long, caddr_t);
static int _i_bind_rsvd(struct file *, struct proc *, register_t *, int,
			     u_long, caddr_t);
static int _i_rele_rsvd(struct file *, struct proc *, register_t *, int,
			     u_long, caddr_t);

/* i_str sockmod calls */
static int sockmod(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_listen(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_ogetudata(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_sockparams(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_shutdown(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_getudata(struct file *, int, struct svr4_strioctl *,
			      struct proc *);

/* i_str timod calls */
static int timod(struct file *, int, struct svr4_strioctl *,
		              struct proc *);
static int ti_getinfo(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int ti_bind(struct file *, int, struct svr4_strioctl *,
			      struct proc *);

#ifdef DEBUG_SVR4
static void bufprint(u_char *, size_t);
static int show_ioc(const char *, struct svr4_strioctl *);
static int show_strbuf(struct svr4_strbuf *);
static void show_msg(const char *, int, struct svr4_strbuf *, 
			  struct svr4_strbuf *, int);

static void
bufprint(buf, len)
	u_char *buf;
	size_t len;
{
	size_t i;

	uprintf("\n\t");
	for (i = 0; i < len; i++) {
		uprintf("%x ", buf[i]);
		if (i && (i % 16) == 0) 
			uprintf("\n\t");
	}
}

static int
show_ioc(str, ioc)
	const char		*str;
	struct svr4_strioctl	*ioc;
{
	u_char *ptr;
	int error;
	int len;

	len = ioc->len;
	if (len > 1024)
		len = 1024;

	if (len <= 0)
		return 0;

	ptr = (u_char *) malloc(len, M_TEMP, M_WAITOK);	
	uprintf("%s cmd = %ld, timeout = %d, len = %d, buf = %p { ",
	    str, ioc->cmd, ioc->timeout, ioc->len, ioc->buf);

	if ((error = copyin(ioc->buf, ptr, len)) != 0) {
		free((char *) ptr, M_TEMP);
		return error;
	}

	bufprint(ptr, len);

	uprintf("}\n");

	free((char *) ptr, M_TEMP);
	return 0;
}


static int
show_strbuf(str)
	struct svr4_strbuf *str;
{
	int error;
	u_char *ptr = NULL;
	int maxlen = str->maxlen;
	int len = str->len;

	if (maxlen > 8192)
		maxlen = 8192;

	if (maxlen < 0)
		maxlen = 0;

	if (len >= maxlen)
		len = maxlen;

	if (len > 0) {
	    ptr = (u_char *)malloc(len, M_TEMP, M_WAITOK);

	    if ((error = copyin(str->buf, ptr, len)) != 0) {
		    free((char *) ptr, M_TEMP);
		    return error;
	    }
	}

	uprintf(", { %d, %d, %p=[ ", str->maxlen, str->len, str->buf);

	if (ptr)
		bufprint(ptr, len);

	uprintf("]}");

	if (ptr)
		free((char *) ptr, M_TEMP);

	return 0;
}


static void
show_msg(str, fd, ctl, dat, flags)
	const char		*str;
	int			 fd;
	struct svr4_strbuf	*ctl;
	struct svr4_strbuf	*dat;
	int			 flags;
{
	struct svr4_strbuf	buf;
	int error;

	uprintf("%s(%d", str, fd);
	if (ctl != NULL) {
		if ((error = copyin(ctl, &buf, sizeof(buf))) != 0)
			return;
		show_strbuf(&buf);
	}
	else 
		uprintf(", NULL");

	if (dat != NULL) {
		if ((error = copyin(dat, &buf, sizeof(buf))) != 0)
			return;
		show_strbuf(&buf);
	}
	else 
		uprintf(", NULL");

	uprintf(", %x);\n", flags);
}
#endif /* DEBUG_SVR4 */

/*
 * We are faced with an interesting situation. On svr4 unix sockets
 * are really pipes. But we really have sockets, and we might as
 * well use them. At the point where svr4 calls TI_BIND, it has
 * already created a named pipe for the socket using mknod(2).
 * We need to create a socket with the same name when we bind,
 * so we need to remove the pipe before, otherwise we'll get address
 * already in use. So we *carefully* remove the pipe, to avoid
 * using this as a random file removal tool. We use system calls
 * to avoid code duplication.
 */
static int
clean_pipe(p, path)
	struct proc *p;
	const char *path;
{
	struct sys_lstat_args la;
	struct sys_unlink_args ua;
	register_t retval;
	struct stat st;
	int error;
	caddr_t sg = stackgap_init(p->p_emul);
	size_t l = strlen(path) + 1;

	SCARG(&la, path) = stackgap_alloc(&sg, l);
	SCARG(&la, ub) = stackgap_alloc(&sg, sizeof(struct stat));

	if ((error = copyout((char *) path, (char *) SCARG(&la, path), l)) != 0)
		return error;

	if ((error = sys_lstat(p, &la, &retval)) != 0)
		return 0;

	if ((error = copyin(SCARG(&la, ub), &st, sizeof(st))) != 0)
		return 0;

	/*
	 * Make sure we are dealing with a mode 0 named pipe.
	 */
	if ((st.st_mode & S_IFMT) != S_IFIFO)
		return 0;

	if ((st.st_mode & ALLPERMS) != 0)
		return 0;

	SCARG(&ua, path) = SCARG(&la, path);

	if ((error = sys_unlink(p, &ua, &retval)) != 0) {
		DPRINTF(("clean_pipe: unlink failed %d\n", error));
		return error;
	}

	return 0;
}


static void
sockaddr_to_netaddr_in(sc, sain)
	struct svr4_strmcmd *sc;
	const struct sockaddr_in *sain;
{
	struct svr4_netaddr_in *na;
	na = SVR4_ADDROF(sc);

	na->family = sain->sin_family;
	na->port = sain->sin_port;
	na->addr = sain->sin_addr.s_addr;
	DPRINTF(("sockaddr_in -> netaddr %d %d %lx\n", na->family, na->port,
		 na->addr));
}


static void
sockaddr_to_netaddr_un(sc, saun)
	struct svr4_strmcmd *sc;
	const struct sockaddr_un *saun;
{
	struct svr4_netaddr_un *na;
	char *dst, *edst = ((char *) sc) + sc->offs + sizeof(na->family) + 1  -
	    sizeof(*sc);
	const char *src;

	na = SVR4_ADDROF(sc);
	na->family = saun->sun_family;
	for (src = saun->sun_path, dst = na->path; (*dst++ = *src++) != '\0'; )
		if (dst == edst)
			break;
	DPRINTF(("sockaddr_un -> netaddr %d %s\n", na->family, na->path));
}


static void
netaddr_to_sockaddr_in(sain, sc)
	struct sockaddr_in *sain;
	const struct svr4_strmcmd *sc;
{
	const struct svr4_netaddr_in *na;


	na = SVR4_ADDROF(sc);
	bzero(sain, sizeof(*sain));
	sain->sin_len = sizeof(*sain);
	sain->sin_family = na->family;
	sain->sin_port = na->port;
	sain->sin_addr.s_addr = na->addr;
	DPRINTF(("netaddr -> sockaddr_in %d %d %x\n", sain->sin_family,
		 sain->sin_port, sain->sin_addr.s_addr));
}


static void
netaddr_to_sockaddr_un(saun, sc)
	struct sockaddr_un *saun;
	const struct svr4_strmcmd *sc;
{
	const struct svr4_netaddr_un *na;
	char *dst, *edst = &saun->sun_path[sizeof(saun->sun_path) - 1];
	const char *src;

	na = SVR4_ADDROF(sc);
	bzero(saun, sizeof(*saun));
	saun->sun_family = na->family;
	for (src = na->path, dst = saun->sun_path; (*dst++ = *src++) != '\0'; )
		if (dst == edst)
			break;
	saun->sun_len = dst - saun->sun_path;
	DPRINTF(("netaddr -> sockaddr_un %d %s\n", saun->sun_family,
		 saun->sun_path));
}


static void
getparm(fp, pa)
	struct file *fp;
	struct svr4_si_sockparms *pa;
{
	struct svr4_strm *st = svr4_stream_get(fp);
	struct socket *so = (struct socket *) fp->f_data;

	if (st == NULL)
		return;

	pa->family = st->s_family;

	switch (so->so_type) {
	case SOCK_DGRAM:
		pa->type = SVR4_SOCK_DGRAM;
		pa->protocol = IPPROTO_UDP;
		return;

	case SOCK_STREAM:
		pa->type = SVR4_SOCK_STREAM;
		pa->protocol = IPPROTO_IP;
		return;

	case SOCK_RAW:
		pa->type = SVR4_SOCK_RAW;
		pa->protocol = IPPROTO_RAW;
		return;

	default:
		pa->type = 0;
		pa->protocol = 0;
		return;
	}
}


static int
si_ogetudata(fp, fd, ioc, p)
	struct file		*fp;
	int 			 fd;
	struct svr4_strioctl	*ioc;
	struct proc		*p;
{
	int error;
	struct svr4_si_oudata ud;
	struct svr4_si_sockparms pa;

	if (ioc->len != sizeof(ud) && ioc->len != sizeof(ud) - sizeof(int)) {
		DPRINTF(("SI_OGETUDATA: Wrong size %d != %d\n",
			 sizeof(ud), ioc->len));
		return EINVAL;
	}

	if ((error = copyin(ioc->buf, &ud, sizeof(ud))) != 0)
		return error;

	getparm(fp, &pa);

	switch (pa.family) {
	case AF_INET:
	    ud.tidusize = 16384;
	    ud.addrsize = sizeof(struct sockaddr_in);
	    if (pa.type == SVR4_SOCK_STREAM) 
		    ud.etsdusize = 1;
	    else
		    ud.etsdusize = 0;
	    break;

	case AF_UNIX:
	    ud.tidusize = 65536;
	    ud.addrsize = 128;
	    ud.etsdusize = 128;
	    break;

	default:
	    DPRINTF(("SI_OGETUDATA: Unsupported address family %d\n",
		     pa.family));
	    return ENOSYS;
	}

	/* I have no idea what these should be! */
	ud.optsize = 128;
	ud.tsdusize = 128;
	ud.servtype = pa.type;

	/* XXX: Fixme */
	ud.so_state = 0;
	ud.so_options = 0;
	return copyout(&ud, ioc->buf, ioc->len);
}


static int
si_sockparams(fp, fd, ioc, p)
	struct file		*fp;
	int 			 fd;
	struct svr4_strioctl	*ioc;
	struct proc		*p;
{
	struct svr4_si_sockparms pa;

	getparm(fp, &pa);
	return copyout(&pa, ioc->buf, sizeof(pa));
}


static int
si_listen(fp, fd, ioc, p)
	struct file		*fp;
	int 			 fd;
	struct svr4_strioctl	*ioc;
	struct proc		*p;
{
	int error;
	struct svr4_strm *st = svr4_stream_get(fp);
	register_t retval;
	struct svr4_strmcmd lst;
	struct sys_listen_args la;

	if (st == NULL)
		return EINVAL;

	if (ioc->len > sizeof(lst))
		return EINVAL;

	if ((error = copyin(ioc->buf, &lst, ioc->len)) != 0)
		return error;

	if (lst.cmd != SVR4_TI_BIND_REQUEST) {
		DPRINTF(("si_listen: bad request %ld\n", lst.cmd));
		return EINVAL;
	}

	/*
	 * We are making assumptions again...
	 */
	SCARG(&la, s) = fd;
	DPRINTF(("SI_LISTEN: fileno %d backlog = %d\n", fd, 5));
	SCARG(&la, backlog) = 5;

	if ((error = sys_listen(p, &la, &retval)) != 0) {
		DPRINTF(("SI_LISTEN: listen failed %d\n", error));
		return error;
	}

	st->s_cmd = SVR4_TI__ACCEPT_WAIT;
	lst.cmd = SVR4_TI_BIND_REPLY;

	switch (st->s_family) {
	case AF_INET:
		/* XXX: Fill the length here */
		break;

	case AF_UNIX:
		lst.len = 140;
		lst.pad[28] = 0x00000000;	/* magic again */
		lst.pad[29] = 0x00000800;	/* magic again */
		lst.pad[30] = 0x80001400;	/* magic again */
		break;

	default:
		DPRINTF(("SI_LISTEN: Unsupported address family %d\n",
			 st->s_family));
		return ENOSYS;
	}


	if ((error = copyout(&lst, ioc->buf, ioc->len)) != 0)
		return error;

	return 0;
}


static int
si_getudata(fp, fd, ioc, p)
	struct file		*fp;
	int 			 fd;
	struct svr4_strioctl	*ioc;
	struct proc		*p;
{
	int error;
	struct svr4_si_udata ud;

	if (sizeof(ud) != ioc->len) {
		DPRINTF(("SI_GETUDATA: Wrong size %d != %d\n",
			 sizeof(ud), ioc->len));
		return EINVAL;
	}

	if ((error = copyin(ioc->buf, &ud, sizeof(ud))) != 0)
		return error;

	getparm(fp, &ud.sockparms);

	switch (ud.sockparms.family) {
	case AF_INET:
	    ud.tidusize = 16384;
	    ud.tsdusize = 16384;
	    ud.addrsize = sizeof(struct sockaddr_in);
	    if (ud.sockparms.type == SVR4_SOCK_STREAM) 
		    ud.etsdusize = 1;
	    else
		    ud.etsdusize = 0;
	    ud.optsize = 0;
	    break;

	case AF_UNIX:
	    ud.tidusize = 65536;
	    ud.tsdusize = 128;
	    ud.addrsize = 128;
	    ud.etsdusize = 128;
	    ud.optsize = 128;
	    break;

	default:
	    DPRINTF(("SI_GETUDATA: Unsupported address family %d\n",
		     ud.sockparms.family));
	    return ENOSYS;
	}

	ud.servtype = ud.sockparms.type;

	/* XXX: Fixme */
	ud.so_state = 0;
	ud.so_options = 0;
	return copyout(&ud, ioc->buf, sizeof(ud));
}


static int
si_shutdown(fp, fd, ioc, p)
	struct file		*fp;
	int 			 fd;
	struct svr4_strioctl	*ioc;
	struct proc		*p;
{
	int error;
	struct sys_shutdown_args ap;
	register_t retval;

	if (ioc->len != sizeof(SCARG(&ap, how))) {
		DPRINTF(("SI_SHUTDOWN: Wrong size %d != %d\n",
			 sizeof(SCARG(&ap, how)), ioc->len));
		return EINVAL;
	}

	if ((error = copyin(ioc->buf, &SCARG(&ap, how), ioc->len)) != 0)
		return error;

	SCARG(&ap, s) = fd;

	return sys_shutdown(p, &ap, &retval);
}

static int
sockmod(fp, fd, ioc, p)
	struct file		*fp;
	int			 fd;
	struct svr4_strioctl	*ioc;
	struct proc		*p;
{
	switch (ioc->cmd) {
	case SVR4_SI_OGETUDATA:
		DPRINTF(("SI_OGETUDATA\n"));
		return si_ogetudata(fp, fd, ioc, p);

	case SVR4_SI_SHUTDOWN:
		DPRINTF(("SI_SHUTDOWN\n"));
		return si_shutdown(fp, fd, ioc, p);

	case SVR4_SI_LISTEN:
		DPRINTF(("SI_LISTEN\n"));
		return si_listen(fp, fd, ioc, p);

	case SVR4_SI_SETMYNAME:
		DPRINTF(("SI_SETMYNAME\n"));
		return 0;

	case SVR4_SI_SETPEERNAME:
		DPRINTF(("SI_SETPEERNAME\n"));
		return 0;

	case SVR4_SI_GETINTRANSIT:
		DPRINTF(("SI_GETINTRANSIT\n"));
		return 0;

	case SVR4_SI_TCL_LINK:
		DPRINTF(("SI_TCL_LINK\n"));
		return 0;

	case SVR4_SI_TCL_UNLINK:
		DPRINTF(("SI_TCL_UNLINK\n"));
		return 0;

	case SVR4_SI_SOCKPARAMS:
		DPRINTF(("SI_SOCKPARAMS\n"));
		return si_sockparams(fp, fd, ioc, p);

	case SVR4_SI_GETUDATA:
		DPRINTF(("SI_GETUDATA\n"));
		return si_getudata(fp, fd, ioc, p);

	default:
		DPRINTF(("Unknown sockmod ioctl %lx\n", ioc->cmd));
		return 0;

	}
}


static int
ti_getinfo(fp, fd, ioc, p)
	struct file		*fp;
	int 			 fd;
	struct svr4_strioctl	*ioc;
	struct proc		*p;
{
	int error;
	struct svr4_infocmd info;

	bzero(&info, sizeof(info));

	if (ioc->len > sizeof(info))
		return EINVAL;

	if ((error = copyin(ioc->buf, &info, ioc->len)) != 0)
		return error;

	if (info.cmd != SVR4_TI_INFO_REQUEST)
		return EINVAL;

	info.cmd = SVR4_TI_INFO_REPLY;
	info.tsdu = 0;
	info.etsdu = 1;
	info.cdata = -2;
	info.ddata = -2;
	info.addr = 16;
	info.opt = -1;
	info.tidu = 16384;
	info.serv = 2;
	info.current = 0;
	info.provider = 2;

	ioc->len = sizeof(info);
	if ((error = copyout(&info, ioc->buf, ioc->len)) != 0)
		return error;

	return 0;
}


static int
ti_bind(fp, fd, ioc, p)
	struct file		*fp;
	int 			 fd;
	struct svr4_strioctl	*ioc;
	struct proc		*p;
{
	int error;
	struct svr4_strm *st = svr4_stream_get(fp);
	struct sockaddr_in sain;
	struct sockaddr_un saun;
	register_t retval;
	caddr_t sg;
	void *skp, *sup = NULL;
	int sasize;
	struct svr4_strmcmd bnd;
	struct sys_bind_args ba;

	if (st == NULL) {
		DPRINTF(("ti_bind: bad file descriptor\n"));
		return EINVAL;
	}

	if (ioc->len > sizeof(bnd))
		return EINVAL;

	if ((error = copyin(ioc->buf, &bnd, ioc->len)) != 0)
		return error;

	if (bnd.cmd != SVR4_TI_BIND_REQUEST) {
		DPRINTF(("ti_bind: bad request %ld\n", bnd.cmd));
		return EINVAL;
	}

	switch (st->s_family) {
	case AF_INET:
		skp = &sain;
		sasize = sizeof(sain);

		if (bnd.offs == 0)
			goto reply;

		netaddr_to_sockaddr_in(&sain, &bnd);

		DPRINTF(("TI_BIND: fam %d, port %d, addr %x\n",
			 sain.sin_family, sain.sin_port,
			 sain.sin_addr.s_addr));
		break;

	case AF_UNIX:
		skp = &saun;
		sasize = sizeof(saun);
		if (bnd.offs == 0)
			goto reply;

		netaddr_to_sockaddr_un(&saun, &bnd);

		if (saun.sun_path[0] == '\0')
			goto reply;

		DPRINTF(("TI_BIND: fam %d, path %s\n",
			 saun.sun_family, saun.sun_path));

		if ((error = clean_pipe(p, saun.sun_path)) != 0)
			return error;

		bnd.pad[28] = 0x00001000;	/* magic again */
		break;

	default:
		DPRINTF(("TI_BIND: Unsupported address family %d\n",
			 st->s_family));
		return ENOSYS;
	}

	sg = stackgap_init(p->p_emul);
	sup = stackgap_alloc(&sg, sasize);

	if ((error = copyout(skp, sup, sasize)) != 0)
		return error;

	SCARG(&ba, s) = fd;
	DPRINTF(("TI_BIND: fileno %d\n", fd));
	SCARG(&ba, name) = (void *)sup;
	SCARG(&ba, namelen) = sasize;

	if ((error = sys_bind(p, &ba, &retval)) != 0) {
		DPRINTF(("TI_BIND: bind failed %d\n", error));
		return error;
	}

reply:
	if (sup == NULL) {
		bzero(&bnd, sizeof(bnd));
		bnd.len = sasize + 4;
		bnd.offs = 0x10;	/* XXX */
	}

	bnd.cmd = SVR4_TI_BIND_REPLY;

	if ((error = copyout(&bnd, ioc->buf, ioc->len)) != 0)
		return error;

	return 0;
}


static int
timod(fp, fd, ioc, p)
	struct file		*fp;
	int			 fd;
	struct svr4_strioctl	*ioc;
	struct proc		*p;
{
	switch (ioc->cmd) {
	case SVR4_TI_GETINFO:
		DPRINTF(("TI_GETINFO\n"));
		return ti_getinfo(fp, fd, ioc, p);

	case SVR4_TI_OPTMGMT:
		DPRINTF(("TI_OPTMGMT\n"));
		return 0;

	case SVR4_TI_BIND:
		DPRINTF(("TI_BIND\n"));
		return ti_bind(fp, fd, ioc, p);

	case SVR4_TI_UNBIND:
		DPRINTF(("TI_UNBIND\n"));
		return 0;

	default:
		DPRINTF(("Unknown timod ioctl %lx\n", ioc->cmd));
		return 0;
	}
}


int
svr4_stream_ti_ioctl(fp, p, retval, fd, cmd, dat)
	struct file *fp;
	struct proc *p;
	register_t *retval;
	int fd;
	u_long cmd;
	caddr_t dat;
{
	struct svr4_strbuf skb, *sub = (struct svr4_strbuf *) dat;
	struct svr4_strm *st = svr4_stream_get(fp);
	int error;
	void *skp, *sup;
	struct sockaddr_in sain;
	struct sockaddr_un saun;
	struct svr4_strmcmd sc;
	socklen_t sasize, samax;
	caddr_t sg;
	int *lenp;

	if (st == NULL)
		return EINVAL;

	sc.offs = 0x10;
	
	switch (st->s_family) {
	case AF_INET:
		skp = &sain;
		samax = sizeof(sain);
		break;

	case AF_UNIX:
		skp = &saun;
		samax = sizeof(saun);
		break;

	default:
		DPRINTF(("ti_ioctl: Unsupported address family %d\n",
			 st->s_family));
		return ENOSYS;
	}

	sg = stackgap_init(p->p_emul);
	sup = stackgap_alloc(&sg, samax);
	lenp = stackgap_alloc(&sg, sizeof(*lenp));

	if ((error = copyout(&samax, lenp, sizeof(*lenp))) != 0) {
		DPRINTF(("ti_ioctl: error copying out lenp\n"));
		return error;
	}

	switch (cmd) {
	case SVR4_TI_GETMYNAME:
		DPRINTF(("TI_GETMYNAME\n"));
		{
			struct sys_getsockname_args ap;
			SCARG(&ap, fdes) = fd;
			SCARG(&ap, asa) = sup;
			SCARG(&ap, alen) = lenp;
			if ((error = sys_getsockname(p, &ap, retval)) != 0) {
				DPRINTF(("ti_ioctl: getsockname error\n"));
				return error;
			}
		}
		break;

	case SVR4_TI_GETPEERNAME:
		DPRINTF(("TI_GETPEERNAME\n"));
		{
			struct sys_getpeername_args ap;
			SCARG(&ap, fdes) = fd;
			SCARG(&ap, asa) = sup;
			SCARG(&ap, alen) = lenp;
			if ((error = sys_getpeername(p, &ap, retval)) != 0) {
				DPRINTF(("ti_ioctl: getpeername error\n"));
				return error;
			}
		}
		break;

	case SVR4_TI_SETMYNAME:
		DPRINTF(("TI_SETMYNAME\n"));
		return 0;

	case SVR4_TI_SETPEERNAME:
		DPRINTF(("TI_SETPEERNAME\n"));
		return 0;
	default:
		DPRINTF(("ti_ioctl: Unknown ioctl %lx\n", cmd));
		return ENOSYS;
	}

	if ((error = copyin(sup, skp, samax)) != 0) {
		DPRINTF(("ti_ioctl: error copying in socket data\n"));
		return error;
	}

	if ((error = copyin(lenp, &sasize, sizeof(*lenp))) != 0) {
		DPRINTF(("ti_ioctl: error copying in socket size\n"));
		return error;
	}

	if (sasize < 0 || sasize > samax) {
		DPRINTF(("ti_ioctl: invalid socklen on stack\n"));
		error = EINVAL;
		return error;
	}

	if ((error = copyin(sub, &skb, sizeof(skb))) != 0) {
		DPRINTF(("ti_ioctl: error copying in strbuf\n"));
		return error;
	}

	switch (st->s_family) {
	case AF_INET:
		sockaddr_to_netaddr_in(&sc, &sain);
		skb.len = sasize;
		break;

	case AF_UNIX:
		sockaddr_to_netaddr_un(&sc, &saun);
		skb.len = sasize + 4;
		break;

	default:
		return ENOSYS;
	}

	if ((error = copyout(SVR4_ADDROF(&sc), skb.buf, sasize)) != 0) {
		DPRINTF(("ti_ioctl: error copying out socket data\n"));
		return error;
	}

	if ((error = copyout(&skb, sub, sizeof(skb))) != 0) {
		DPRINTF(("ti_ioctl: error copying out strbuf\n"));
		return error;
	}

	return error;
}

static int
i_nread(fp, p, retval, fd, cmd, dat)
	struct file *fp;
	struct proc *p;
	register_t *retval;
	int fd;
	u_long cmd;
	caddr_t dat;
{
	int error;
	int nread = 0;	

	/*
	 * We are supposed to return the message length in nread, and the
	 * number of messages in retval. We don't have the notion of number
	 * of stream messages, so we just find out if we have any bytes waiting
	 * for us, and if we do, then we assume that we have at least one
	 * message waiting for us.
	 */
	if ((error = (*fp->f_ops->fo_ioctl)(fp, FIONREAD,
	    (caddr_t) &nread, p)) != 0)
		return error;

	if (nread != 0)
		*retval = 1;
	else
		*retval = 0;

	return copyout(&nread, dat, sizeof(nread));
}

static int
i_fdinsert(fp, p, retval, fd, cmd, dat)
	struct file *fp;
	struct proc *p;
	register_t *retval;
	int fd;
	u_long cmd;
	caddr_t dat;
{
	/*
	 * Major hack again here. We assume that we are using this to
	 * implement accept(2). If that is the case, we have already
	 * called accept, and we have stored the file descriptor in
	 * afd. We find the file descriptor that the code wants to use
	 * in fd insert, and then we dup2() our accepted file descriptor
	 * to it.
	 */
	int error;
	struct svr4_strm *st = svr4_stream_get(fp);
	struct svr4_strfdinsert fdi;
	struct sys_dup2_args d2p;
	struct sys_close_args clp;

	if (st == NULL) {
		DPRINTF(("fdinsert: bad file type\n"));
		return EINVAL;
	}

	if (st->s_afd == -1) {
		DPRINTF(("fdinsert: accept fd not found\n"));
		return ENOENT;
	}

	if ((error = copyin(dat, &fdi, sizeof(fdi))) != 0) {
		DPRINTF(("fdinsert: copyin failed %d\n", error));
		return error;
	}

	SCARG(&d2p, from) = st->s_afd;
	SCARG(&d2p, to) = fdi.fd;

	if ((error = sys_dup2(p, &d2p, retval)) != 0) {
		DPRINTF(("fdinsert: dup2(%d, %d) failed %d\n", 
		    st->s_afd, fdi.fd, error));
		return error;
	}

	SCARG(&clp, fd) = st->s_afd;

	if ((error = sys_close(p, &clp, retval)) != 0) {
		DPRINTF(("fdinsert: close(%d) failed %d\n", 
		    st->s_afd, error));
		return error;
	}

	st->s_afd = -1;

	*retval = 0;
	return 0;
}


static int
_i_bind_rsvd(fp, p, retval, fd, cmd, dat)
	struct file *fp;
	struct proc *p;
	register_t *retval;
	int fd;
	u_long cmd;
	caddr_t dat;
{
	struct sys_mknod_args ap;

	/*
	 * This is a supposed to be a kernel and library only ioctl.
	 * It gets called before ti_bind, when we have a unix 
	 * socket, to physically create the socket transport and
	 * ``reserve'' it. I don't know how this get reserved inside
	 * the kernel, but we are going to create it nevertheless.
	 */
	SCARG(&ap, path) = dat;
	SCARG(&ap, mode) = S_IFIFO;

	return sys_mkfifo(p, &ap, retval);
}

static int
_i_rele_rsvd(fp, p, retval, fd, cmd, dat)
	struct file *fp;
	struct proc *p;
	register_t *retval;
	int fd;
	u_long cmd;
	caddr_t dat;
{
	struct sys_unlink_args ap;

	/*
	 * This is a supposed to be a kernel and library only ioctl.
	 * I guess it is supposed to release the socket.
	 */
	SCARG(&ap, path) = dat;

	return sys_unlink(p, &ap, retval);
}

static int
i_str(fp, p, retval, fd, cmd, dat)
	struct file *fp;
	struct proc *p;
	register_t *retval;
	int fd;
	u_long cmd;
	caddr_t dat;
{
	int			 error;
	struct svr4_strioctl	 ioc;

	if ((error = copyin(dat, &ioc, sizeof(ioc))) != 0)
		return error;

#ifdef DEBUG_SVR4
	if ((error = show_ioc(">", &ioc)) != 0)
		return error;
#endif /* DEBUG_SVR4 */

	switch (ioc.cmd & 0xff00) {
	case SVR4_SIMOD:
		if ((error = sockmod(fp, fd, &ioc, p)) != 0)
			return error;
		break;

	case SVR4_TIMOD:
		if ((error = timod(fp, fd, &ioc, p)) != 0)
			return error;
		break;

	default:
		DPRINTF(("Unimplemented module %c %ld\n",
			 (char) (cmd >> 8), cmd & 0xff));
		return 0;
	}

#ifdef DEBUG_SVR4
	if ((error = show_ioc("<", &ioc)) != 0)
		return error;
#endif /* DEBUG_SVR4 */
	return copyout(&ioc, dat, sizeof(ioc));
}


int
svr4_stream_ioctl(fp, p, retval, fd, cmd, dat)
	struct file *fp;
	struct proc *p;
	register_t *retval;
	int fd;
	u_long cmd;
	caddr_t dat;
{
	*retval = 0;

	/*
	 * All the following stuff assumes "sockmod" is pushed...
	 */
	switch (cmd) {
	case SVR4_I_NREAD:
		DPRINTF(("I_NREAD\n"));
		return i_nread(fp, p, retval, fd, cmd, dat);

	case SVR4_I_PUSH:
		DPRINTF(("I_PUSH\n"));
		return 0;

	case SVR4_I_POP:
		DPRINTF(("I_POP\n"));
		return 0;

	case SVR4_I_LOOK:
		DPRINTF(("I_LOOK\n"));
		return 0;

	case SVR4_I_FLUSH:
		DPRINTF(("I_FLUSH\n"));
		return 0;

	case SVR4_I_SRDOPT:
		DPRINTF(("I_SRDOPT\n"));
		return 0;

	case SVR4_I_GRDOPT:
		DPRINTF(("I_GRDOPT\n"));
		return 0;

	case SVR4_I_STR:
		DPRINTF(("I_STR\n"));
		return i_str(fp, p, retval, fd, cmd, dat);

	case SVR4_I_SETSIG:
		DPRINTF(("I_SETSIG\n"));
		/* 
		 * This is the best we can do for now; we cannot generate
		 * signals only for specific events so the signal mask gets
		 * ignored.
		 *
		 * We alse have to fix the O_ASYNC fcntl bit, so the
		 * process will get SIGPOLLs. */
		{
			struct sys_fcntl_args fa;
			int error;
			register_t oflags, flags;

			/* get old status flags */
			SCARG(&fa, fd) = fd;
			SCARG(&fa, cmd) = F_GETFL;
			if ((error = sys_fcntl(p, &fa, &oflags)) != 0)
				return error;

			/* update the flags */
			if ((long) dat != 0)
				flags = oflags | O_ASYNC;
			else
				flags = oflags & ~O_ASYNC;

			/* set the new flags, if changed */
			if (flags != oflags) {
				SCARG(&fa, cmd) = F_SETFL;
				SCARG(&fa, arg) = (void *) flags;
				if ((error = sys_fcntl(p, &fa, &flags)) != 0)
					return error;
			}

			/* set up SIGIO receiver if needed */
			if ((long) dat != 0) {
				SCARG(&fa, cmd) = F_SETOWN;
				SCARG(&fa, arg) = (void *) p->p_pid;
				return sys_fcntl(p, &fa, retval);
			}
		}

	case SVR4_I_GETSIG:
		DPRINTF(("I_GETSIG\n"));
		return EINVAL;

	case SVR4_I_FIND:
		DPRINTF(("I_FIND\n"));
		/*
		 * Here we are not pushing modules really, we just
		 * pretend all are present
		 */
		*retval = 1;
		return 0;

	case SVR4_I_LINK:
		DPRINTF(("I_LINK\n"));
		return 0;

	case SVR4_I_UNLINK:
		DPRINTF(("I_UNLINK\n"));
		return 0;

	case SVR4_I_ERECVFD:
		DPRINTF(("I_ERECVFD\n"));
		return 0;

	case SVR4_I_PEEK:
		DPRINTF(("I_PEEK\n"));
		return 0;

	case SVR4_I_FDINSERT:
		DPRINTF(("I_FDINSERT\n"));
		return i_fdinsert(fp, p, retval, fd, cmd, dat);

	case SVR4_I_SENDFD:
		DPRINTF(("I_SENDFD\n"));
		return 0;

	case SVR4_I_RECVFD:
		DPRINTF(("I_RECVFD\n"));
		return 0;

	case SVR4_I_SWROPT:
		DPRINTF(("I_SWROPT\n"));
		return 0;

	case SVR4_I_GWROPT:
		DPRINTF(("I_GWROPT\n"));
		return 0;

	case SVR4_I_LIST:
		DPRINTF(("I_LIST\n"));
		return 0;

	case SVR4_I_PLINK:
		DPRINTF(("I_PLINK\n"));
		return 0;

	case SVR4_I_PUNLINK:
		DPRINTF(("I_PUNLINK\n"));
		return 0;

	case SVR4_I_SETEV:
		DPRINTF(("I_SETEV\n"));
		return 0;

	case SVR4_I_GETEV:
		DPRINTF(("I_GETEV\n"));
		return 0;

	case SVR4_I_STREV:
		DPRINTF(("I_STREV\n"));
		return 0;

	case SVR4_I_UNSTREV:
		DPRINTF(("I_UNSTREV\n"));
		return 0;

	case SVR4_I_FLUSHBAND:
		DPRINTF(("I_FLUSHBAND\n"));
		return 0;

	case SVR4_I_CKBAND:
		DPRINTF(("I_CKBAND\n"));
		return 0;

	case SVR4_I_GETBAND:
		DPRINTF(("I_GETBANK\n"));
		return 0;

	case SVR4_I_ATMARK:
		DPRINTF(("I_ATMARK\n"));
		return 0;

	case SVR4_I_SETCLTIME:
		DPRINTF(("I_SETCLTIME\n"));
		return 0;

	case SVR4_I_GETCLTIME:
		DPRINTF(("I_GETCLTIME\n"));
		return 0;

	case SVR4_I_CANPUT:
		DPRINTF(("I_CANPUT\n"));
		return 0;

	case SVR4__I_BIND_RSVD:
		DPRINTF(("_I_BIND_RSVD\n"));
		return _i_bind_rsvd(fp, p, retval, fd, cmd, dat);

	case SVR4__I_RELE_RSVD:
		DPRINTF(("_I_RELE_RSVD\n"));
		return _i_rele_rsvd(fp, p, retval, fd, cmd, dat);

	default:
		DPRINTF(("unimpl cmd = %lx\n", cmd));
		break;
	}

	return 0;
}




int
svr4_sys_putmsg(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_putmsg_args *uap = v;
	struct filedesc	*fdp = p->p_fd;
	struct file	*fp;
	struct svr4_strbuf dat, ctl;
	struct svr4_strmcmd sc;
	struct sockaddr_in sain;
	struct sockaddr_un saun;
	void *skp, *sup;
	int sasize;
	struct svr4_strm *st;
	int error;
	caddr_t sg;

#ifdef DEBUG_SVR4
	show_msg(">putmsg", SCARG(uap, fd), SCARG(uap, ctl),
		 SCARG(uap, dat), SCARG(uap, flags));
#endif /* DEBUG_SVR4 */

	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return EBADF;
	FREF(fp);

	if (SCARG(uap, ctl) != NULL) {
		if ((error = copyin(SCARG(uap, ctl), &ctl, sizeof(ctl))) != 0)
			goto out;
	}
	else
		ctl.len = -1;

	if (SCARG(uap, dat) != NULL) {
	    	if ((error = copyin(SCARG(uap, dat), &dat, sizeof(dat))) != 0)
			goto out;
	}
	else
		dat.len = -1;

	/*
	 * Only for sockets for now.
	 */
	if ((st = svr4_stream_get(fp)) == NULL) {
		DPRINTF(("putmsg: bad file type\n"));
		error = EINVAL;
		goto out;
	}

	if (ctl.len > sizeof(sc)) {
		DPRINTF(("putmsg: Bad control size %d != %d\n", ctl.len,
			 sizeof(struct svr4_strmcmd)));
		error = EINVAL;
		goto out;
	}

	if ((error = copyin(ctl.buf, &sc, ctl.len)) != 0)
		goto out;

	switch (st->s_family) {
	case AF_INET:
		if (sc.len != sizeof(sain)) {
			DPRINTF(("putmsg: Invalid inet length %ld\n", sc.len));
			error = ENOSYS;
			goto out;
		}
		netaddr_to_sockaddr_in(&sain, &sc);
		skp = &sain;
		sasize = sizeof(sain);
		error = sain.sin_family != st->s_family;
		break;

	case AF_UNIX:
		if (ctl.len == 8) {
			/* We are doing an accept; succeed */
			DPRINTF(("putmsg: Do nothing\n"));
			*retval = 0;
			error = 0;
			goto out;
		} else {
			/* Maybe we've been given a device/inode pair */
			dev_t *dev = SVR4_ADDROF(&sc);
			ino_t *ino = (ino_t *) &dev[1];
			skp = svr4_find_socket(p, fp, *dev, *ino);
			if (skp == NULL) {
				skp = &saun;
				/* I guess we have it by name */
				netaddr_to_sockaddr_un(skp, &sc);
			}
			sasize = sizeof(saun);
		}
		break;

	default:
		DPRINTF(("putmsg: Unsupported address family %d\n",
			 st->s_family));
		error = ENOSYS;
		goto out;
	}

	sg = stackgap_init(p->p_emul);
	sup = stackgap_alloc(&sg, sasize);

	if ((error = copyout(skp, sup, sasize)) != 0)
		goto out;

	switch (st->s_cmd = sc.cmd) {
	case SVR4_TI_CONNECT_REQUEST:	/* connect 	*/
		{
			struct sys_connect_args co;

			SCARG(&co, s) = SCARG(uap, fd);
			SCARG(&co, name) = (void *)sup;
			SCARG(&co, namelen) = (int)sasize;
			error = sys_connect(p, &co, retval);
			goto out;
		}

	case SVR4_TI_SENDTO_REQUEST:	/* sendto 	*/
		{
			struct msghdr msg;
			struct iovec aiov;

			msg.msg_name = (caddr_t) sup;
			msg.msg_namelen = sasize;
			msg.msg_iov = &aiov;
			msg.msg_iovlen = 1;
			msg.msg_control = 0;
			msg.msg_flags = 0;
			aiov.iov_base = dat.buf;
			aiov.iov_len = dat.len;
			error = sendit(p, SCARG(uap, fd), &msg,
				       SCARG(uap, flags), retval);

			*retval = 0;
			goto out;
		}

	default:
		DPRINTF(("putmsg: Unimplemented command %lx\n", sc.cmd));
		error = ENOSYS;
		goto out;
	}

out:
	FRELE(fp);
	return (error);
}


int
svr4_sys_getmsg(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_getmsg_args *uap = v;
	struct filedesc	*fdp = p->p_fd;
	struct file	*fp;
	struct sys_getpeername_args ga;
	struct sys_accept_args aa;
	struct svr4_strbuf dat, ctl;
	struct svr4_strmcmd sc;
	int error;
	struct msghdr msg;
	struct iovec aiov;
	struct sockaddr_in sain;
	struct sockaddr_un saun;
	void *skp, *sup;
	int sasize;
	struct svr4_strm *st;
	int *flen;
	int fl;
	caddr_t sg;

	bzero(&sc, sizeof(sc));

#ifdef DEBUG_SVR4
	show_msg(">getmsg", SCARG(uap, fd), SCARG(uap, ctl),
		 SCARG(uap, dat), 0);
#endif /* DEBUG_SVR4 */
			
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return EBADF;
	FREF(fp);

	if (SCARG(uap, ctl) != NULL) {
		if ((error = copyin(SCARG(uap, ctl), &ctl, sizeof(ctl))) != 0)
			goto out;
	}
	else {
		ctl.len = -1;
		ctl.maxlen = 0;
	}

	if (SCARG(uap, dat) != NULL) {
	    	if ((error = copyin(SCARG(uap, dat), &dat, sizeof(dat))) != 0)
			goto out;
	}
	else {
		dat.len = -1;
		dat.maxlen = 0;
	}

	/*
	 * Only for sockets for now.
	 */
	if ((st = svr4_stream_get(fp)) == NULL) {
		DPRINTF(("getmsg: bad file type\n"));
		error = EINVAL;
		goto out;
	}

	if (ctl.maxlen == -1 || dat.maxlen == -1) {
		DPRINTF(("getmsg: Cannot handle -1 maxlen (yet)\n"));
		error = ENOSYS;
		goto out;
	}

	switch (st->s_family) {
	case AF_INET:
		skp = &sain;
		sasize = sizeof(sain);
		break;

	case AF_UNIX:
		skp = &saun;
		sasize = sizeof(saun);
		break;

	default:
		DPRINTF(("getmsg: Unsupported address family %d\n",
			 st->s_family));
		error = ENOSYS;
		goto out;
	}

	sg = stackgap_init(p->p_emul);
	sup = stackgap_alloc(&sg, sasize);
	flen = (int *) stackgap_alloc(&sg, sizeof(*flen));

	fl = sasize;
	if ((error = copyout(&fl, flen, sizeof(fl))) != 0)
		goto out;

	switch (st->s_cmd) {
	case SVR4_TI_CONNECT_REQUEST:
		DPRINTF(("getmsg: TI_CONNECT_REQUEST\n"));
		/*
		 * We do the connect in one step, so the putmsg should
		 * have gotten the error.
		 */
		sc.cmd = SVR4_TI_OK_REPLY;
		sc.len = 0;

		ctl.len = 8;
		dat.len = -1;
		fl = 1;
		st->s_cmd = sc.cmd;
		break;

	case SVR4_TI_OK_REPLY:
		DPRINTF(("getmsg: TI_OK_REPLY\n"));

		/*
		 * We are immediately after a connect reply, so we send
		 * a connect verification.
		 */
		SCARG(&ga, fdes) = SCARG(uap, fd);
		SCARG(&ga, asa) = (void *)sup;
		SCARG(&ga, alen) = flen;
		
		if ((error = sys_getpeername(p, &ga, retval)) != 0) {
			DPRINTF(("getmsg: getpeername failed %d\n", error));
			goto out;
		}

		if ((error = copyin(sup, skp, sasize)) != 0)
			goto out;
		
		sc.cmd = SVR4_TI_CONNECT_REPLY;
		sc.pad[0] = 0x4;
		sc.offs = 0x18;
		sc.pad[1] = 0x14;
		sc.pad[2] = 0x04000402;

		switch (st->s_family) {
		case AF_INET:
			sc.len = sasize;
			sockaddr_to_netaddr_in(&sc, &sain);
			break;

		case AF_UNIX:
			sc.len = sasize + 4;
			sockaddr_to_netaddr_un(&sc, &saun);
			break;

		default:
			error = ENOSYS;
			goto out;
		}

		ctl.len = 40;
		dat.len = -1;
		fl = 0;
		st->s_cmd = sc.cmd;
		break;

	case SVR4_TI__ACCEPT_OK:
		DPRINTF(("getmsg: TI__ACCEPT_OK\n"));
		/*
		 * We do the connect in one step, so the putmsg should
		 * have gotten the error.
		 */
		sc.cmd = SVR4_TI_OK_REPLY;
		sc.len = 1;

		ctl.len = 8;
		dat.len = -1;
		fl = 1;
		st->s_cmd = SVR4_TI__ACCEPT_WAIT;
		break;

	case SVR4_TI__ACCEPT_WAIT:
		DPRINTF(("getmsg: TI__ACCEPT_WAIT\n"));
		/*
		 * We are after a listen, so we try to accept...
		 */
		SCARG(&aa, s) = SCARG(uap, fd);
		SCARG(&aa, name) = (void *)sup;
		SCARG(&aa, anamelen) = flen;
		
		if ((error = sys_accept(p, &aa, retval)) != 0) {
			DPRINTF(("getmsg: accept failed %d\n", error));
			goto out;
		}

		st->s_afd = *retval;

		DPRINTF(("getmsg: Accept fd = %d\n", st->s_afd));

		if ((error = copyin(sup, skp, sasize)) != 0)
			goto out;
		
		sc.cmd = SVR4_TI_ACCEPT_REPLY;
		sc.len = sasize;
		sc.offs = 0x18;
		sc.pad[0] = 0x0;
		sc.pad[1] = 0x28;
		sc.pad[2] = 0x3;

		switch (st->s_family) {
		case AF_INET:
			sc.pad[1] = 0x28;
			sockaddr_to_netaddr_in(&sc, &sain);
			ctl.len = 40;
			sc.len = sasize;
			break;

		case AF_UNIX:
			sc.pad[1] = 0x00010000;
			sc.pad[2] = 0xf6bcdaa0;	/* I don't know what that is */
			sc.pad[3] = 0x00010000;
			ctl.len = 134;
			sc.len = sasize + 4;
			break;

		default:
			error = ENOSYS;
			goto out;
		}

		ctl.len = 40;
		dat.len = -1;
		fl = 0;
		st->s_cmd = SVR4_TI__ACCEPT_OK;
		break;

	case SVR4_TI_SENDTO_REQUEST:
		DPRINTF(("getmsg: TI_SENDTO_REQUEST\n"));
		if (ctl.maxlen > 36 && ctl.len < 36)
			ctl.len = 36;

		if (ctl.len > sizeof(sc))
			ctl.len = sizeof(sc);

		if ((error = copyin(ctl.buf, &sc, ctl.len)) != 0)
			goto out;

		switch (st->s_family) {
		case AF_INET:
			sockaddr_to_netaddr_in(&sc, &sain);
			break;

		case AF_UNIX:
			sockaddr_to_netaddr_un(&sc, &saun);
			break;

		default:
			error = ENOSYS;
			goto out;
		}

		msg.msg_name = (caddr_t) sup;
		msg.msg_namelen = sasize;
		msg.msg_iov = &aiov;
		msg.msg_iovlen = 1;
		msg.msg_control = 0;
		aiov.iov_base = dat.buf;
		aiov.iov_len = dat.maxlen;
		msg.msg_flags = 0;

		error = recvit(p, SCARG(uap, fd), &msg, (caddr_t) flen, retval);

		if (error) {
			DPRINTF(("getmsg: recvit failed %d\n", error));
			goto out;
		}

		if ((error = copyin(msg.msg_name, skp, sasize)) != 0)
			goto out;

		sc.cmd = SVR4_TI_RECVFROM_REPLY;

		switch (st->s_family) {
		case AF_INET:
			sc.len = sasize;
			sockaddr_to_netaddr_in(&sc, &sain);
			break;

		case AF_UNIX:
			sc.len = sasize + 4;
			sockaddr_to_netaddr_un(&sc, &saun);
			break;

		default:
			error = ENOSYS;
			goto out;
		}

		dat.len = *retval;
		fl = 0;
		st->s_cmd = sc.cmd;
		break;

	default:
		st->s_cmd = sc.cmd;
		DPRINTF(("getmsg: Unknown state %x\n", st->s_cmd));
		error = EINVAL;
		goto out;
	}

	if (SCARG(uap, ctl)) {
		if (ctl.len != -1)
			if ((error = copyout(&sc, ctl.buf, ctl.len)) != 0)
				goto out;

		if ((error = copyout(&ctl, SCARG(uap, ctl), sizeof(ctl))) != 0)
			goto out;
	}

	if (SCARG(uap, dat)) {
		if ((error = copyout(&dat, SCARG(uap, dat), sizeof(dat))) != 0)
			goto out;
	}

	if (SCARG(uap, flags)) { /* XXX: Need translation */
		if ((error = copyout(&fl, SCARG(uap, flags), sizeof(fl))) != 0)
			goto out;
	}

	*retval = 0;

#ifdef DEBUG_SVR4
	show_msg("<getmsg", SCARG(uap, fd), SCARG(uap, ctl),
		 SCARG(uap, dat), fl);
#endif /* DEBUG_SVR4 */
out:
	FRELE(fp);
	return error;
}
@


1.19
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.18 2003/11/23 17:14:21 avsm Exp $	 */
@


1.18
log
@check for too-small length in stream debug code
discussed with grange@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.17 2002/03/14 01:26:51 millert Exp $	 */
d49 1
a49 1
#include <sys/select.h>
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.16 2002/02/14 22:57:18 pvalchev Exp $	 */
d155 3
@


1.16
log
@More FREF/FRELE fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.15 2002/02/13 19:08:06 art Exp $	 */
d74 2
a75 2
static int clean_pipe __P((struct proc *, const char *));
static void getparm __P((struct file *, struct svr4_si_sockparms *));
d78 8
a85 8
static void sockaddr_to_netaddr_in __P((struct svr4_strmcmd *,
					const struct sockaddr_in *));
static void sockaddr_to_netaddr_un __P((struct svr4_strmcmd *,
					const struct sockaddr_un *));
static void netaddr_to_sockaddr_in __P((struct sockaddr_in *,
					const struct svr4_strmcmd *));
static void netaddr_to_sockaddr_un __P((struct sockaddr_un *,
					const struct svr4_strmcmd *));
d88 10
a97 10
static int i_nread __P((struct file *, struct proc *, register_t *, int,
			u_long, caddr_t));
static int i_fdinsert __P((struct file *, struct proc *, register_t *, int,
			   u_long, caddr_t));
static int i_str   __P((struct file *, struct proc *, register_t *, int,
			u_long, caddr_t));
static int _i_bind_rsvd __P((struct file *, struct proc *, register_t *, int,
			     u_long, caddr_t));
static int _i_rele_rsvd __P((struct file *, struct proc *, register_t *, int,
			     u_long, caddr_t));
d100 12
a111 12
static int sockmod       __P((struct file *, int, struct svr4_strioctl *,
			      struct proc *));
static int si_listen     __P((struct file *, int, struct svr4_strioctl *,
			      struct proc *));
static int si_ogetudata  __P((struct file *, int, struct svr4_strioctl *,
			      struct proc *));
static int si_sockparams __P((struct file *, int, struct svr4_strioctl *,
			      struct proc *));
static int si_shutdown	 __P((struct file *, int, struct svr4_strioctl *,
			      struct proc *));
static int si_getudata   __P((struct file *, int, struct svr4_strioctl *,
			      struct proc *));
d114 6
a119 6
static int timod         __P((struct file *, int, struct svr4_strioctl *,
		              struct proc *));
static int ti_getinfo    __P((struct file *, int, struct svr4_strioctl *,
			      struct proc *));
static int ti_bind       __P((struct file *, int, struct svr4_strioctl *,
			      struct proc *));
d122 5
a126 5
static void bufprint __P((u_char *, size_t));
static int show_ioc __P((const char *, struct svr4_strioctl *));
static int show_strbuf __P((struct svr4_strbuf *));
static void show_msg __P((const char *, int, struct svr4_strbuf *, 
			  struct svr4_strbuf *, int));
@


1.15
log
@More FREF/FRELE on relevant places. Now, only sys_mmap and a bunch of ioctl functions in sys/compat are left.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.14 2001/10/26 12:03:27 art Exp $	 */
d1431 1
d1435 1
a1435 1
			return error;
d1442 1
a1442 1
			return error;
d1452 2
a1453 1
		return EINVAL;
d1459 2
a1460 1
		return EINVAL;
d1464 1
a1464 1
		return error;
d1470 2
a1471 1
			return ENOSYS;
d1484 2
a1485 1
			return 0;
d1503 2
a1504 1
		return ENOSYS;
d1511 1
a1511 1
		return error;
d1521 2
a1522 1
			return sys_connect(p, &co, retval);
d1542 1
a1542 1
			return error;
d1547 2
a1548 1
		return ENOSYS;
d1550 4
d1591 1
d1595 1
a1595 1
			return error;
d1604 1
a1604 1
			return error;
d1616 2
a1617 1
		return EINVAL;
d1622 2
a1623 1
		return ENOSYS;
d1640 2
a1641 1
		return ENOSYS;
d1650 1
a1650 1
		return error;
d1681 1
a1681 1
			return error;
d1685 1
a1685 1
			return error;
d1705 2
a1706 1
			return ENOSYS;
d1741 1
a1741 1
			return error;
d1749 1
a1749 1
			return error;
d1775 2
a1776 1
			return ENOSYS;
d1794 1
a1794 1
			return error;
d1806 2
a1807 1
			return ENOSYS;
d1823 1
a1823 1
			return error;
d1827 1
a1827 1
			return error;
d1843 2
a1844 1
			return ENOSYS;
d1855 2
a1856 1
		return EINVAL;
d1862 1
a1862 1
				return error;
d1865 1
a1865 1
			return error;
d1870 1
a1870 1
			return error;
d1875 1
a1875 1
			return error;
d1884 2
@


1.14
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.13 2001/10/02 17:40:20 csapuntz Exp $	 */
a1423 3
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return EBADF;

a1568 3

	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return EBADF;
@


1.14.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.14 2001/10/26 12:03:27 art Exp $	 */
d74 2
a75 2
static int clean_pipe(struct proc *, const char *);
static void getparm(struct file *, struct svr4_si_sockparms *);
d78 8
a85 8
static void sockaddr_to_netaddr_in(struct svr4_strmcmd *,
					const struct sockaddr_in *);
static void sockaddr_to_netaddr_un(struct svr4_strmcmd *,
					const struct sockaddr_un *);
static void netaddr_to_sockaddr_in(struct sockaddr_in *,
					const struct svr4_strmcmd *);
static void netaddr_to_sockaddr_un(struct sockaddr_un *,
					const struct svr4_strmcmd *);
d88 10
a97 10
static int i_nread(struct file *, struct proc *, register_t *, int,
			u_long, caddr_t);
static int i_fdinsert(struct file *, struct proc *, register_t *, int,
			   u_long, caddr_t);
static int i_str(struct file *, struct proc *, register_t *, int,
			u_long, caddr_t);
static int _i_bind_rsvd(struct file *, struct proc *, register_t *, int,
			     u_long, caddr_t);
static int _i_rele_rsvd(struct file *, struct proc *, register_t *, int,
			     u_long, caddr_t);
d100 12
a111 12
static int sockmod(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_listen(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_ogetudata(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_sockparams(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_shutdown(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_getudata(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
d114 6
a119 6
static int timod(struct file *, int, struct svr4_strioctl *,
		              struct proc *);
static int ti_getinfo(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int ti_bind(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
d122 5
a126 5
static void bufprint(u_char *, size_t);
static int show_ioc(const char *, struct svr4_strioctl *);
static int show_strbuf(struct svr4_strbuf *);
static void show_msg(const char *, int, struct svr4_strbuf *, 
			  struct svr4_strbuf *, int);
d1424 3
a1433 1
	FREF(fp);
d1437 1
a1437 1
			goto out;
d1444 1
a1444 1
			goto out;
d1454 1
a1454 2
		error = EINVAL;
		goto out;
d1460 1
a1460 2
		error = EINVAL;
		goto out;
d1464 1
a1464 1
		goto out;
d1470 1
a1470 2
			error = ENOSYS;
			goto out;
d1483 1
a1483 2
			error = 0;
			goto out;
d1501 1
a1501 2
		error = ENOSYS;
		goto out;
d1508 1
a1508 1
		goto out;
d1518 1
a1518 2
			error = sys_connect(p, &co, retval);
			goto out;
d1538 1
a1538 1
			goto out;
d1543 1
a1543 2
		error = ENOSYS;
		goto out;
a1544 4

out:
	FRELE(fp);
	return (error);
d1573 3
a1584 1
	FREF(fp);
d1588 1
a1588 1
			goto out;
d1597 1
a1597 1
			goto out;
d1609 1
a1609 2
		error = EINVAL;
		goto out;
d1614 1
a1614 2
		error = ENOSYS;
		goto out;
d1631 1
a1631 2
		error = ENOSYS;
		goto out;
d1640 1
a1640 1
		goto out;
d1671 1
a1671 1
			goto out;
d1675 1
a1675 1
			goto out;
d1695 1
a1695 2
			error = ENOSYS;
			goto out;
d1730 1
a1730 1
			goto out;
d1738 1
a1738 1
			goto out;
d1764 1
a1764 2
			error = ENOSYS;
			goto out;
d1782 1
a1782 1
			goto out;
d1794 1
a1794 2
			error = ENOSYS;
			goto out;
d1810 1
a1810 1
			goto out;
d1814 1
a1814 1
			goto out;
d1830 1
a1830 2
			error = ENOSYS;
			goto out;
d1841 1
a1841 2
		error = EINVAL;
		goto out;
d1847 1
a1847 1
				goto out;
d1850 1
a1850 1
			goto out;
d1855 1
a1855 1
			goto out;
d1860 1
a1860 1
			goto out;
a1868 2
out:
	FRELE(fp);
@


1.13
log
@

Values coming from userland should be bounds checked, even if we put them
there just a couple calls ago. Thanks to Ken Ashcraft of Stanford for finding
this bug.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.12 2001/04/18 09:06:42 niklas Exp $	 */
d1424 1
a1424 2
	if ((u_int)SCARG(uap, fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
d1432 1
a1432 2
	if ((u_int)SCARG(uap, fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
d1573 1
a1573 2
	if ((u_int)SCARG(uap, fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
d1583 1
a1583 2
	if ((u_int)SCARG(uap, fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
@


1.12
log
@Declare undeclared variable in #ifdef DEBUG_SVR4
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.11 2000/08/30 04:17:41 brad Exp $	 */
d885 1
a885 1
	int sasize;
a893 5
	if ((error = copyin(sub, &skb, sizeof(skb))) != 0) {
		DPRINTF(("ti_ioctl: error copying in strbuf\n"));
		return error;
	}

d897 1
a897 1
		sasize = sizeof(sain);
d902 1
a902 1
		sasize = sizeof(saun);
d912 1
a912 1
	sup = stackgap_alloc(&sg, sasize);
d915 1
a915 1
	if ((error = copyout(&sasize, lenp, sizeof(*lenp))) != 0) {
d961 1
a961 1
	if ((error = copyin(sup, skp, sasize)) != 0) {
d968 11
@


1.11
log
@additional range checking; From: NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.10 1998/02/09 06:29:08 tholo Exp $	 */
d150 1
@


1.10
log
@More missing type changes; pointed out by deraadt@@OpenBSD.org
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.9 1997/09/11 10:48:13 deraadt Exp $	 */
d148 1
a148 1
	u_char *ptr = (u_char *)malloc(ioc->len, M_TEMP, M_WAITOK);
d151 5
d159 1
a159 1
	if ((error = copyin(ioc->buf, ptr, ioc->len)) != 0) {
d164 1
a164 1
	bufprint(ptr, ioc->len);
d182 3
d500 3
d505 1
d701 3
d753 3
d1773 4
a1776 1
		    ctl.len = 36;
@


1.10.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.12 2001/04/18 09:06:42 niklas Exp $	 */
d148 1
a148 1
	u_char *ptr;
a149 1
	int len;
a150 5
	len = ioc->len;
	if (len > 1024)
		len = 1024;

	ptr = (u_char *) malloc(len, M_TEMP, M_WAITOK);	
d154 1
a154 1
	if ((error = copyin(ioc->buf, ptr, len)) != 0) {
d159 1
a159 1
	bufprint(ptr, len);
a176 3
	if (maxlen > 8192)
		maxlen = 8192;

a491 3
	if (ioc->len > sizeof(lst))
		return EINVAL;

a493 1

a688 3
	if (ioc->len > sizeof(info))
		return EINVAL;

a737 3
	if (ioc->len > sizeof(bnd))
		return EINVAL;

d1755 1
a1755 4
			ctl.len = 36;

		if (ctl.len > sizeof(sc))
			ctl.len = sizeof(sc);
@


1.10.10.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.10.10.1 2001/05/14 22:05:28 niklas Exp $	 */
d885 1
a885 1
	socklen_t sasize, samax;
d894 5
d902 1
a902 1
		samax = sizeof(sain);
d907 1
a907 1
		samax = sizeof(saun);
d917 1
a917 1
	sup = stackgap_alloc(&sg, samax);
d920 1
a920 1
	if ((error = copyout(&samax, lenp, sizeof(*lenp))) != 0) {
d966 1
a966 1
	if ((error = copyin(sup, skp, samax)) != 0) {
a975 11
	if (sasize < 0 || sasize > samax) {
		DPRINTF(("ti_ioctl: invalid socklen on stack\n"));
		error = EINVAL;
		return error;
	}

	if ((error = copyin(sub, &skb, sizeof(skb))) != 0) {
		DPRINTF(("ti_ioctl: error copying in strbuf\n"));
		return error;
	}

d1418 2
a1419 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
d1427 2
a1428 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
d1569 2
a1570 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
d1580 2
a1581 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
@


1.10.10.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	 */
d1424 3
a1433 1
	FREF(fp);
d1437 1
a1437 1
			goto out;
d1444 1
a1444 1
			goto out;
d1454 1
a1454 2
		error = EINVAL;
		goto out;
d1460 1
a1460 2
		error = EINVAL;
		goto out;
d1464 1
a1464 1
		goto out;
d1470 1
a1470 2
			error = ENOSYS;
			goto out;
d1483 1
a1483 2
			error = 0;
			goto out;
d1501 1
a1501 2
		error = ENOSYS;
		goto out;
d1508 1
a1508 1
		goto out;
d1518 1
a1518 2
			error = sys_connect(p, &co, retval);
			goto out;
d1538 1
a1538 1
			goto out;
d1543 1
a1543 2
		error = ENOSYS;
		goto out;
a1544 4

out:
	FRELE(fp);
	return (error);
d1573 3
a1584 1
	FREF(fp);
d1588 1
a1588 1
			goto out;
d1597 1
a1597 1
			goto out;
d1609 1
a1609 2
		error = EINVAL;
		goto out;
d1614 1
a1614 2
		error = ENOSYS;
		goto out;
d1631 1
a1631 2
		error = ENOSYS;
		goto out;
d1640 1
a1640 1
		goto out;
d1671 1
a1671 1
			goto out;
d1675 1
a1675 1
			goto out;
d1695 1
a1695 2
			error = ENOSYS;
			goto out;
d1730 1
a1730 1
			goto out;
d1738 1
a1738 1
			goto out;
d1764 1
a1764 2
			error = ENOSYS;
			goto out;
d1782 1
a1782 1
			goto out;
d1794 1
a1794 2
			error = ENOSYS;
			goto out;
d1810 1
a1810 1
			goto out;
d1814 1
a1814 1
			goto out;
d1830 1
a1830 2
			error = ENOSYS;
			goto out;
d1841 1
a1841 2
		error = EINVAL;
		goto out;
d1847 1
a1847 1
				goto out;
d1850 1
a1850 1
			goto out;
d1855 1
a1855 1
			goto out;
d1860 1
a1860 1
			goto out;
a1868 2
out:
	FRELE(fp);
@


1.10.10.4
log
@Merge in -current from about a week ago
@
text
@d74 2
a75 2
static int clean_pipe(struct proc *, const char *);
static void getparm(struct file *, struct svr4_si_sockparms *);
d78 8
a85 8
static void sockaddr_to_netaddr_in(struct svr4_strmcmd *,
					const struct sockaddr_in *);
static void sockaddr_to_netaddr_un(struct svr4_strmcmd *,
					const struct sockaddr_un *);
static void netaddr_to_sockaddr_in(struct sockaddr_in *,
					const struct svr4_strmcmd *);
static void netaddr_to_sockaddr_un(struct sockaddr_un *,
					const struct svr4_strmcmd *);
d88 10
a97 10
static int i_nread(struct file *, struct proc *, register_t *, int,
			u_long, caddr_t);
static int i_fdinsert(struct file *, struct proc *, register_t *, int,
			   u_long, caddr_t);
static int i_str(struct file *, struct proc *, register_t *, int,
			u_long, caddr_t);
static int _i_bind_rsvd(struct file *, struct proc *, register_t *, int,
			     u_long, caddr_t);
static int _i_rele_rsvd(struct file *, struct proc *, register_t *, int,
			     u_long, caddr_t);
d100 12
a111 12
static int sockmod(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_listen(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_ogetudata(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_sockparams(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_shutdown(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int si_getudata(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
d114 6
a119 6
static int timod(struct file *, int, struct svr4_strioctl *,
		              struct proc *);
static int ti_getinfo(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
static int ti_bind(struct file *, int, struct svr4_strioctl *,
			      struct proc *);
d122 5
a126 5
static void bufprint(u_char *, size_t);
static int show_ioc(const char *, struct svr4_strioctl *);
static int show_strbuf(struct svr4_strbuf *);
static void show_msg(const char *, int, struct svr4_strbuf *, 
			  struct svr4_strbuf *, int);
@


1.10.10.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a155 3
	if (len <= 0)
		return 0;

@


1.9
log
@sync with netbsd; missing SCARG() macros
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.8 1997/08/07 09:16:21 niklas Exp $	 */
d265 1
a265 1
	if ((error = copyout((char *) path, SCARG(&la, path), l)) != 0)
@


1.8
log
@O_ASYNC handling from NetBSD...
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.7 1997/02/13 19:45:24 niklas Exp $	 */
d1492 3
a1494 3
			co.s = SCARG(uap, fd);
			co.name = (void *)sup;
			co.namelen = (int)sasize;
d1502 1
d1517 1
@


1.7
log
@Merge of NetBSD 970211
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.6 1996/08/01 00:50:54 niklas Exp $	 */
d1219 4
a1222 2
		 * ignored
		 */
d1225 2
d1228 1
d1230 24
a1253 3
			SCARG(&fa, cmd) = F_SETOWN;
			SCARG(&fa, arg) = (void *) p->p_pid;
			return sys_fcntl(p, &fa, retval);
@


1.6
log
@Merge of NetBSD 0722
@
text
@d1 3
a3 2
/*	$OpenBSD: svr4_stream.c,v 1.5 1996/05/22 11:45:00 deraadt Exp $	 */
/*	$NetBSD: svr4_stream.c,v 1.14 1996/05/13 16:57:50 christos Exp $	 */
d32 1
a37 1
 *       We really need I_FDINSERT and it is going to be a pain.
d90 2
d94 4
d108 2
d122 1
d127 15
a141 1
static void show_strmcmd __P((const char *, struct svr4_strmcmd *));
d148 1
a148 1
	char *ptr = (char *) malloc(ioc->len, M_TEMP, M_WAITOK);
a149 1
	int i;
d159 1
a159 2
	for (i = 0; i < ioc->len; i++)
		uprintf("%x ", (unsigned char) ptr[i]);
d173 1
a173 2
	int i;
	char *ptr = NULL;
d180 1
a180 1
	if (len >= maxlen || len <= 0)
d183 2
a184 2
	if (len != 0) {
	    ptr = malloc(len, M_TEMP, M_WAITOK);
d194 2
a195 2
	for (i = 0; i < len; i++)
		uprintf("%x ", (unsigned char) ptr[i]);
a235 17


static void
show_strmcmd(str, cmd)
	const char		*str;
	struct svr4_strmcmd	*cmd;
{
	int i;

	uprintf("%s cmd = %ld, len = %ld, offs = %ld { ",
	    str, cmd->cmd, cmd->len, cmd->offs);

	for (i = 0; i < sizeof(cmd->pad) / sizeof(cmd->pad[0]); i++)
		uprintf("%lx ", cmd->pad[i]);

	uprintf("}\n");
}
a237 1

d390 1
a390 1
		pa->protocol = IPPROTO_TCP;
d430 1
d432 4
d439 3
a441 1
	    ud.addrsize = sizeof(struct sockaddr_un);
a450 1
	ud.tidusize = 16384;
d452 1
a452 8
	if (ioc->len == sizeof(ud))
	    ud.tsdusize = 128;

	if (pa.type == SVR4_SOCK_STREAM) 
		ud.etsdusize = 1;
	else
		ud.etsdusize = 0;

a485 7
#if 0
	struct sockaddr_in sain;
	struct sockaddr_un saun;
	caddr_t sg;
	void *skp, *sup;
	int sasize;
#endif
d494 16
d511 2
a512 3
#ifdef DEBUG_SVR4
	show_strmcmd(">si_listen", &lst);
#endif
a513 1
#if 0
d516 1
a516 11
		skp = &sain;
		sasize = sizeof(sain);

		if (lst.offs == 0)
			goto reply;

		netaddr_to_sockaddr_in(&sain, &lst);

		DPRINTF(("SI_LISTEN: fam %d, port %d, addr %x\n",
			 sain.sin_family, sain.sin_port,
			 sain.sin_addr.s_addr));
d520 4
a523 15
		skp = &saun;
		sasize = sizeof(saun);
		if (lst.offs == 0)
			goto reply;

		netaddr_to_sockaddr_un(&saun, &lst);

		if (saun.sun_path[0] == '\0')
			goto reply;

		DPRINTF(("SI_LISTEN: fam %d, path %s\n",
			 saun.sun_family, saun.sun_path));

		if ((error = clean_pipe(p, saun.sun_path)) != 0)
			return error;
a531 17
	sg = stackgap_init(p->p_emul);
	sup = stackgap_alloc(&sg, sasize);

	if ((error = copyout(skp, sup, sasize)) != 0)
		return error;
#endif

	SCARG(&la, s) = fd;
	DPRINTF(("SI_LISTEN: fileno %d backlog = %d\n", fd, 5));
	SCARG(&la, backlog) = 5;

	if ((error = sys_listen(p, &la, &retval)) != 0) {
		DPRINTF(("SI_LISTEN: listen failed %d\n", error));
		return error;
	}

	st->s_cmd = SVR4_TI_ACCEPT_REPLY;
a532 10
	return 0;

#if 0
reply:
	bzero(&lst, sizeof(lst));
	lst.cmd = SVR4_TI_BIND_REPLY;
	lst.len = sasize;
	lst.offs = 0x10;	/* XXX */

	ioc->len = 32;
a536 1
#endif
d563 2
d566 5
d574 5
a578 1
	    ud.addrsize = sizeof(struct sockaddr_un);
a586 11
	/* I have no idea what these should be! */
	ud.tidusize = 16384;
	ud.optsize = 128;
	ud.tsdusize = 16384;


	if (ud.sockparms.type == SVR4_SOCK_STREAM) 
		ud.etsdusize = 1;
	else
		ud.etsdusize = 0;

d597 25
d635 1
a635 1
		return 0;
d733 2
a734 1
	if (st == NULL)
d736 1
d741 2
a742 1
	if (bnd.cmd != SVR4_TI_BIND_REQUEST)
d744 1
d777 2
d795 1
a795 1
	SCARG(&ba, name) = (caddr_t) sup;
d806 1
a806 1
		bnd.len = sasize;
d960 1
d965 1
a971 2
	skb.len = sasize;

a984 3



d1016 105
d1216 13
a1228 1
		return 0;
d1261 1
a1261 1
		return 0;
d1335 8
d1430 7
a1436 2
		{
			/* We've been given a device/inode pair */
d1439 6
a1444 2
			if ((skp = svr4_find_socket(p, fp, *dev, *ino)) == NULL)
				return ENOENT;
d1467 2
a1468 2
			co.name = (caddr_t) sup;
			co.namelen = (int) sasize;
d1595 1
d1606 1
d1610 2
d1614 1
a1614 1
		 * an connect verification.
d1617 1
a1617 1
		SCARG(&ga, asa) = (caddr_t) sup;
d1629 1
a1629 1
		sc.len = sasize;
a1630 1
		sc.pad[0] = 0x4;
d1636 1
d1641 1
d1652 16
d1670 2
a1671 1
	case SVR4_TI_ACCEPT_REPLY:
d1676 1
a1676 1
		SCARG(&aa, name) = (caddr_t) sup;
d1680 1
a1680 1
			DPRINTF(("getmsg: getpeername failed %d\n", error));
d1684 4
d1700 1
d1702 2
d1707 5
a1711 1
			sockaddr_to_netaddr_un(&sc, &saun);
d1721 1
d1725 1
a1764 1
		sc.len = sasize;
d1768 1
d1773 1
d1783 1
d1787 1
a1791 1
	st->s_cmd = sc.cmd;
@


1.5
log
@Fix OGETUDATA for Solaris-2.3 (From Greg Hudson)
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_stream.c,v 1.3 1996/04/17 05:24:22 mickey Exp $	 */
d74 1
a74 1
static void getparm __P((struct socket *, struct svr4_si_sockparms *));
d128 2
a129 2
	printf("%s cmd = %ld, timeout = %d, len = %d, buf = %p { ",
	       str, ioc->cmd, ioc->timeout, ioc->len, ioc->buf);
d137 1
a137 1
		printf("%x ", (unsigned char) ptr[i]);
d139 1
a139 1
	printf("}\n");
d171 1
a171 1
	printf(", { %d, %d, %p=[ ", str->maxlen, str->len, str->buf);
d174 1
a174 1
		printf("%x ", (unsigned char) ptr[i]);
d176 1
a176 1
	printf("]}");
d196 1
a196 1
	printf("%s(%d", str, fd);
d203 1
a203 1
		printf(", NULL");
d211 1
a211 1
		printf(", NULL");
d213 1
a213 1
	printf(", %x);\n", flags);
d224 2
a225 2
	printf("%s cmd = %ld, len = %ld, offs = %ld { ",
	       str, cmd->cmd, cmd->len, cmd->offs);
d228 1
a228 1
		printf("%lx ", cmd->pad[i]);
d230 1
a230 1
	printf("}\n");
d367 2
a368 2
getparm(so, pa)
	struct socket *so;
d371 6
a376 1
	struct svr4_strm *st = (struct svr4_strm *) so->so_internal;
a412 1
	struct socket *so = (struct socket *) fp->f_data;
d423 1
a423 1
	getparm(so, &pa);
a466 1
	struct socket *so = (struct socket *) fp->f_data;
d469 1
a469 1
	getparm(so, &pa);
d482 1
a482 2
	struct socket *so = (struct socket *) fp->f_data;
	struct svr4_strm *st = (struct svr4_strm *) so->so_internal;
d494 3
a588 1
	struct socket *so = (struct socket *) fp->f_data;
d599 1
a599 1
	getparm(so, &ud.sockparms);
d738 1
a738 2
	struct socket *so = (struct socket *) fp->f_data;
	struct svr4_strm *st = (struct svr4_strm *) so->so_internal;
d748 3
d869 1
a869 2
	struct socket *so = (struct socket *) fp->f_data;
	struct svr4_strm *st = (struct svr4_strm *) so->so_internal;
d879 3
a1255 1
	struct socket *so;
d1290 1
a1290 1
	if (fp == NULL || fp->f_type != DTYPE_SOCKET) {
a1294 4
	so = (struct socket *)  fp->f_data;
	st = (struct svr4_strm *) so->so_internal;


a1394 1
	struct socket *so;
d1436 1
a1436 1
	if (fp == NULL || fp->f_type != DTYPE_SOCKET) {
a1439 3

	so = (struct socket *)  fp->f_data;
	st = (struct svr4_strm *) so->so_internal;
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: svr4_stream.c,v 1.13 1996/04/11 12:49:13 christos Exp $	 */
d410 1
a410 1
	if (sizeof(ud) != ioc->len) {
d439 2
a440 1

d452 1
a452 1
	return copyout(&ud, ioc->buf, sizeof(ud));
@


1.3
log
@Good fixes and changes from latest Net.
@
text
@d1 2
a2 3
/*	$OpenBSD: svr4_stream.c,v 1.2 1996/02/26 23:32:03 niklas Exp $	 */
/*	$NetBSD: svr4_stream.c,v 1.12 1996/03/30 22:38:19 christos Exp $	 */

d4 1
a4 2
 * Copyright (c) 1994 Christos Zoulas
 * All rights reserved.
d14 5
a18 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
a30 1

d33 4
d51 1
d58 1
d70 41
a111 5
static void svr4_getparm __P((struct socket *, struct svr4_si_sockparms *));
static int svr4_sockmod __P((struct file *, struct svr4_strioctl *,
			     struct proc *));
static int svr4_timod __P((struct file *, struct svr4_strioctl *,
			   struct proc *));
d113 119
a231 4
static int svr4_showioc __P((const char *, struct svr4_strioctl *));
static int svr4_getstrbuf __P((struct svr4_strbuf *));
static void svr4_showmsg __P((const char *, int, struct svr4_strbuf *, 
			      struct svr4_strbuf *, int));
d235 110
d346 22
a367 1
svr4_getparm(so, pa)
d371 2
a372 1
	pa->family = AF_INET;
d399 177
a575 1
svr4_sockmod(fp, ioc, p)
d577 1
d582 2
d585 53
d641 1
a641 33
		{
			struct svr4_si_oudata ud;
			struct svr4_si_sockparms pa;
			struct socket *so = (struct socket *) fp->f_data;

			if (sizeof(ud) != ioc->len) {
				DPRINTF(("Wrong size %d != %d\n", 
					 sizeof(ud), ioc->len));
				return EINVAL;
			}

			if ((error = copyin(ioc->buf, &ud, sizeof(ud))) != 0)
				return error;

			/* I have no idea what these should be! */
			ud.tidusize = 16384;
			ud.addrsize = sizeof(struct sockaddr_in);
			ud.optsize = 128;

			svr4_getparm(so, &pa);

			if (pa.type == SVR4_SOCK_STREAM) 
				ud.etsdusize = 1;
			else
				ud.etsdusize = 0;

			ud.servtype = pa.type;

			/* XXX: Fixme */
			ud.so_state = 0;
			ud.so_options = 0;
			return copyout(&ud, ioc->buf, sizeof(ud));
		}
d649 1
a649 1
		return 0;
d673 1
a673 8
		{
			struct socket *so = (struct socket *) fp->f_data;
			struct svr4_si_sockparms pa;

			svr4_getparm(so, &pa);
			return copyout(&pa, ioc->buf, sizeof(pa));
		}
		return 0;
d677 1
a677 34
		{
			struct svr4_si_udata ud;
			struct socket *so = (struct socket *) fp->f_data;

			if (sizeof(ud) != ioc->len) {
				DPRINTF(("Wrong size %d != %d\n", 
					 sizeof(ud), ioc->len));
				return EINVAL;
			}

			if ((error = copyin(ioc->buf, &ud, sizeof(ud))) != 0)
				return error;

			/* I have no idea what these should be! */
			ud.tidusize = 16384;
			ud.addrsize = sizeof(struct sockaddr_in);
			ud.optsize = 128;
			ud.tsdusize = 16384;

			svr4_getparm(so, &ud.sockparms);

			if (ud.sockparms.type == SVR4_SOCK_STREAM) 
				ud.etsdusize = 1;
			else
				ud.etsdusize = 0;

			ud.servtype = ud.sockparms.type;

			/* XXX: Fixme */
			ud.so_state = 0;
			ud.so_options = 0;
			return copyout(&ud, ioc->buf, sizeof(ud));
		}
		return 0;
d686 39
d726 1
a726 1
svr4_timod(fp, ioc, p)
d728 1
d733 37
d771 40
a810 5
	switch (ioc->cmd) {
	case SVR4_TI_GETINFO:
		DPRINTF(("TI_GETINFO\n"));
		{
			struct svr4_infocmd info;
d812 1
a812 1
			bzero(&info, sizeof(info));
d814 2
a815 2
			if ((error = copyin(ioc->buf, &info, ioc->len)) != 0)
				return error;
d817 2
a818 2
			if (info.cmd != SVR4_TI_INFO_REQUEST)
				return EINVAL;
a819 11
			info.cmd = SVR4_TI_INFO_REPLY;
			info.tsdu = 0;
			info.etsdu = 1;
			info.cdata = -2;
			info.ddata = -2;
			info.addr = 16;
			info.opt = -1;
			info.tidu = 16384;
			info.serv = 2;
			info.current = 0;
			info.provider = 2;
d821 11
a831 5
			ioc->len = sizeof(info);
			if ((error = copyout(&info, ioc->buf, ioc->len)) != 0)
				return error;
		}
		return 0;
d839 12
a850 3
		{
			struct svr4_strmcmd bnd;
			bzero(&bnd, sizeof(bnd));
d852 20
a871 2
			if ((error = copyin(ioc->buf, &bnd, ioc->len)) != 0)
				return error;
d873 6
a878 2
			if (bnd.cmd != SVR4_TI_BIND_REQUEST)
				return EINVAL;
d880 5
a884 1
			ioc->len = 32;
d886 4
a889 1
			bzero(&bnd, sizeof(bnd));
d891 5
a895 3
			bnd.cmd = SVR4_TI_BIND_REPLY;
			bnd.len = sizeof(struct sockaddr_in);
			bnd.offs = 0x10;
d897 3
a899 4
			if ((error = copyout(&bnd, ioc->buf, ioc->len)) != 0)
				return error;
		}
		return 0;
d901 4
a904 3
	case SVR4_TI_UNBIND:
		DPRINTF(("TI_UNBIND\n"));
		return 0;
d906 1
d909 11
a919 1
		return 0;
d923 11
a933 1
		return 0;
d942 23
d967 13
a979 2
		DPRINTF(("Unknown timod ioctl %lx\n", ioc->cmd));
		return 0;
d981 2
d986 2
a987 1
#ifdef DEBUG_SVR4
d989 7
a995 3
svr4_showioc(str, ioc)
	const char		*str;
	struct svr4_strioctl	*ioc;
a996 1
	char *ptr = (char *) malloc(ioc->len, M_TEMP, M_WAITOK);
d998 33
a1030 1
	int i;
d1032 2
a1033 2
	printf("%s cmd = %ld, timeout = %d, len = %d, buf = %p { ",
	       str, ioc->cmd, ioc->timeout, ioc->len, ioc->buf);
d1035 2
a1036 2
	if ((error = copyin(ioc->buf, ptr, ioc->len)) != 0) {
		free((char *) ptr, M_TEMP);
d1038 7
a1044 1
	}
d1046 4
a1049 2
	for (i = 0; i < ioc->len; i++)
		printf("%x ", (unsigned char) ptr[i]);
d1051 5
a1055 1
	printf("}\n");
d1057 5
a1061 2
	free((char *) ptr, M_TEMP);
	return 0;
a1062 1
#endif /* DEBUG_SVR4 */
d1066 1
a1066 1
svr4_streamioctl(fp, cmd, dat, p, retval)
d1068 3
a1072 2
	struct proc *p;
	register_t *retval;
a1073 3
	struct svr4_strioctl	 ioc;
	int			 error;

d1082 1
a1082 6
		{
		    int nread = 0;	/* XXX: is that FIONREAD? */
		    if ((error = copyout(&nread, dat, sizeof(nread))) != 0)
			    return error;
		}
		return 0;
d1110 1
a1110 29
		if ((error = copyin(dat, &ioc, sizeof(ioc))) != 0)
			return error;

#ifdef DEBUG_SVR4
		if ((error = svr4_showioc(">", &ioc)) != 0)
			return error;
#endif /* DEBUG_SVR4 */
		switch (ioc.cmd & 0xff00) {
		case SVR4_SIMOD:
			if ((error = svr4_sockmod(fp, &ioc, p)) != 0)
				return error;
			break;

		case SVR4_TIMOD:
			if ((error = svr4_timod(fp, &ioc, p)) != 0)
				return error;
			break;

		default:
			DPRINTF(("Unimplemented module %c %ld\n",
				 (char) (cmd >> 8), cmd & 0xff));
			return 0;
		}

#ifdef DEBUG_SVR4
		if ((error = svr4_showioc("<", &ioc)) != 0)
			return error;
#endif /* DEBUG_SVR4 */
		return copyout(&ioc, dat, sizeof(ioc));
a1229 74
#ifdef DEBUG_SVR4
static int
svr4_getstrbuf(str)
	struct svr4_strbuf *str;
{
	int error;
	int i;
	char *ptr = NULL;
	int maxlen = str->maxlen;
	int len = str->len;

	if (maxlen < 0)
		maxlen = 0;

	if (len >= maxlen || len <= 0)
		len = maxlen;

	if (len != 0) {
	    ptr = malloc(len, M_TEMP, M_WAITOK);

	    if ((error = copyin(str->buf, ptr, len)) != 0) {
		    free((char *) ptr, M_TEMP);
		    return error;
	    }
	}

	printf(", { %d, %d, %p=[ ", str->maxlen, str->len, str->buf);
	for (i = 0; i < len; i++) {
		printf("%x ", (unsigned char) ptr[i]);
		if (i > 20) {
			printf("...");
			break;
		}
	}
	printf("]}");

	if (ptr)
		free((char *) ptr, M_TEMP);

	return 0;
}


static void
svr4_showmsg(str, fd, ctl, dat, flags)
	const char		*str;
	int			 fd;
	struct svr4_strbuf	*ctl;
	struct svr4_strbuf	*dat;
	int			 flags;
{
	struct svr4_strbuf	buf;
	int error;

	printf("%s(%d", str, fd);
	if (ctl != NULL) {
		if ((error = copyin(ctl, &buf, sizeof(buf))) != 0)
			return;
		svr4_getstrbuf(&buf);
	}
	else 
		printf(", NULL");

	if (dat != NULL) {
		if ((error = copyin(dat, &buf, sizeof(buf))) != 0)
			return;
		svr4_getstrbuf(&buf);
	}
	else 
		printf(", NULL");

	printf(", %x);\n", flags);
}
#endif /* DEBUG_SVR4 */
d1243 4
a1246 1
	struct svr4_netaddr *na;
a1249 1
	struct sockaddr_in sa, *sap;
d1257 2
a1258 2
	svr4_showmsg(">putmsg", SCARG(uap, fd), SCARG(uap, ctl),
		     SCARG(uap, dat), SCARG(uap, flags));
d1300 26
a1325 2
	if (sc.len != sizeof(sa)) {
		DPRINTF(("putmsg: Cannot handle variable address lengths\n"));
a1328 6
	na = SVR4_ADDROF(&sc);
	bzero(&sa, sizeof(sa));
	sa.sin_family = na->family;
	sa.sin_port = na->port;
	sa.sin_addr.s_addr = na->addr;

d1330 1
a1330 2
	sap = (struct sockaddr_in *) stackgap_alloc(&sg,
						    sizeof(struct sockaddr_in));
d1332 1
a1332 1
	if ((error = copyout(&sa, sap, sizeof(sa))) != 0)
d1341 2
a1342 2
			co.name = (caddr_t) sap;
			co.namelen = (int) sizeof(sa);
d1350 2
a1351 2
			msg.msg_name = (caddr_t) sap;
			msg.msg_namelen = sizeof(sa);
a1354 1
#ifdef COMPAT_OLDSOCK
a1355 1
#endif /* COMPAT_OLDSOCK */
d1381 1
a1383 1
	struct svr4_netaddr *na;
d1387 4
a1390 1
	struct sockaddr_in sa, *sap;
d1404 2
a1405 2
	svr4_showmsg(">getmsg", SCARG(uap, fd), SCARG(uap, ctl),
		     SCARG(uap, dat), 0);
d1446 17
d1464 1
a1464 2
	sap = (struct sockaddr_in *) stackgap_alloc(&sg,
						    sizeof(struct sockaddr_in));
d1467 1
a1467 1
	fl = sizeof(sa);
a1470 1

d1491 1
a1491 1
		SCARG(&ga, asa) = (caddr_t) sap;
d1499 1
a1499 1
		if ((error = copyin(sap, &sa, sizeof(sa))) != 0)
d1503 1
a1503 1
		sc.len = sizeof(struct sockaddr_in);
a1507 1
		na = SVR4_ADDROF(&sc);
d1509 53
a1561 3
		na->family = sa.sin_family;
		na->port = sa.sin_port;
		na->addr = sa.sin_addr.s_addr;
d1575 4
d1580 3
a1582 1
		na = SVR4_ADDROF(&sc);
d1584 3
a1586 7
		bzero(&sa, sizeof(sa));
		sa.sin_family = na->family;
		sa.sin_port = na->port;
		sa.sin_addr.s_addr = na->addr;

		if ((error = copyout(&sa, sap, sizeof(sa))) != 0)
			return error;
d1588 2
a1589 2
		msg.msg_name = (caddr_t) sap;
		msg.msg_namelen = sizeof(sa);
d1600 1
a1600 1
			DPRINTF(("getmsg: recvit failed %d\n", error))
d1604 1
a1604 2

		if ((error = copyin(msg.msg_name, &sa, sizeof(sa))) != 0)
d1608 10
a1617 1
		sc.len = sizeof(sa);
d1619 3
a1621 3
		na->family = sa.sin_family;
		na->port = sa.sin_port;
		na->addr = sa.sin_addr.s_addr;
a1631 1

d1655 2
a1656 2
	svr4_showmsg("<getmsg", SCARG(uap, fd), SCARG(uap, ctl),
		     SCARG(uap, dat), fl);
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	 */
/*	$NetBSD: svr4_stream.c,v 1.11 1996/02/10 00:48:12 christos Exp $	 */
d231 1
a231 1
		DPRINTF(("Unknown sockmod ioctl %x\n", ioc->cmd));
d327 1
a327 1
		DPRINTF(("Unknown timod ioctl %x\n", ioc->cmd));
d343 1
a343 1
	printf("%s cmd = %d, timeout = %d, len = %d, buf = %p { ",
d433 1
a433 1
			DPRINTF(("Unimplemented module %c %d\n",
d554 1
a554 1
		DPRINTF(("unimpl cmd = %x\n", cmd));
d754 1
a754 1
		DPRINTF(("putmsg: Unimplemented command %x\n", sc.cmd));
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: svr4_stream.c,v 1.9 1995/10/07 06:27:52 mycroft Exp $	 */
d343 1
a343 1
	printf("%s cmd = %d, timeout = %d, len = %d, buf = %x { ",
d588 1
a588 1
	printf(", { %d, %d, %x=[ ", str->maxlen, str->len, str->buf);
d692 1
a692 1
	st = (struct svr4_strm *) so->so_tpcb;
d825 1
a825 1
	st = (struct svr4_strm *) so->so_tpcb;
d917 1
a917 1
		error = recvit(p, SCARG(uap, fd), &msg, flen, retval);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
