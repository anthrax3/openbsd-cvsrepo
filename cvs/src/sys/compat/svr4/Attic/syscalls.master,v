head	1.34;
access;
symbols
	OPENBSD_4_9:1.33.0.34
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.32
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.28
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.30
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.26
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.24
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.22
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.20
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.18
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.33.0.16
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.33.0.14
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.33.0.12
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.33.0.10
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.33.0.8
	OPENBSD_3_6_BASE:1.33
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	OPENBSD_3_5:1.33.0.6
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.33.0.4
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	UBC_SYNC_B:1.32
	UBC:1.30.0.8
	UBC_BASE:1.30
	OPENBSD_3_0:1.30.0.6
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9_BASE:1.30
	OPENBSD_2_9:1.30.0.4
	OPENBSD_2_8:1.30.0.2
	OPENBSD_2_8_BASE:1.30
	OPENBSD_2_7:1.26.0.6
	OPENBSD_2_7_BASE:1.26
	SMP:1.26.0.4
	SMP_BASE:1.26
	kame_19991208:1.26
	OPENBSD_2_6:1.26.0.2
	OPENBSD_2_6_BASE:1.26
	OPENBSD_2_5:1.23.0.6
	OPENBSD_2_5_BASE:1.23
	OPENBSD_2_4:1.23.0.4
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.23.0.2
	OPENBSD_2_3_BASE:1.23
	OPENBSD_2_2:1.18.0.2
	OPENBSD_2_2_BASE:1.18
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.34
date	2011.07.04.23.01.33;	author tedu;	state dead;
branches;
next	1.33;

1.33
date	2003.01.30.03.29.49;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.06.19.14.20;	author nordin;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.03.16.03;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.23.19.31.35;	author fgsch;	state Exp;
branches
	1.30.8.1;
next	1.29;

1.29
date	2000.06.28.23.48.15;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.24.21.00.30;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.15.05.28.30;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	99.10.07.17.23.53;	author brad;	state Exp;
branches
	1.26.4.1;
next	1.25;

1.25
date	99.10.07.16.14.28;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	99.06.07.07.17.48;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.03.06.21.58.10;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	98.02.10.13.41.55;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	97.12.09.10.59.50;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.12.02.00.07.05;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.11.13.06.23.06;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.08.29.20.44.26;	author kstailey;	state Exp;
branches;
next	1.17;

1.17
date	97.08.29.20.36.13;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	97.08.29.20.15.07;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.08.29.19.55.57;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.08.29.19.35.20;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	97.08.29.18.45.52;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	97.03.28.22.03.49;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.02.13.19.45.27;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.01.26.23.02.24;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.01.11.17.57.31;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.08.02.21.55.24;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.08.02.20.20.33;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.04.25.10.20.18;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.18.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.02.26.23.32.08;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	95.12.19.15.40.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.47.44;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.25;	author deraadt;	state Exp;
branches;
next	;

1.26.4.1
date	2001.05.14.22.05.32;	author niklas;	state Exp;
branches;
next	1.26.4.2;

1.26.4.2
date	2002.03.28.11.28.07;	author niklas;	state Exp;
branches;
next	1.26.4.3;

1.26.4.3
date	2003.03.27.23.53.48;	author niklas;	state Exp;
branches;
next	;

1.30.8.1
date	2002.06.11.03.28.09;	author art;	state Exp;
branches;
next	1.30.8.2;

1.30.8.2
date	2002.10.29.00.30.52;	author art;	state Exp;
branches;
next	1.30.8.3;

1.30.8.3
date	2003.05.19.21.52.10;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.34
log
@remove all the compat svr4 files
@
text
@	$OpenBSD: syscalls.master,v 1.33 2003/01/30 03:29:49 millert Exp $
;	$NetBSD: syscalls.master,v 1.17 1996/02/10 17:12:51 christos Exp $

;	@@(#)syscalls.master	8.1 (Berkeley) 7/19/93

; OpenBSD COMPAT_SVR4 system call name/number "master" file.
; (See syscalls.conf to see what it is processed into.)
;
; Fields: number type [type-dependent ...]
;	number	system call number, must be in order
;	type	one of STD, OBSOL, UNIMPL, NODEF, NOARGS, or one of
;		the compatibility options defined in syscalls.conf.
;
; types:
;	STD	always included
;	OBSOL	obsolete, not included in system
;	UNIMPL	unimplemented, not included in system
;	NODEF	included, but don't define the syscall number
;	NOARGS	included, but don't define the syscall args structure
;
; The compat options are defined in the syscalls.conf file, and the
; compat option name is prefixed to the syscall name.  Other than
; that, they're like NODEF (for 'compat' options), or STD (for
; 'libcompat' options).
;
; The type-dependent arguments are as follows:
; For STD, NODEF, NOARGS, and compat syscalls:
;	{ pseudo-proto } [alias]
; For other syscalls:
;	[comment]
;
; #ifdef's, etc. may be included, and are copied to the output files.
; #include's are copied to the syscall switch definition file only.

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signal.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <compat/svr4/svr4_types.h>
#include <compat/svr4/svr4_time.h>
#include <compat/svr4/svr4_signal.h>
#include <compat/svr4/svr4_ucontext.h>
#include <compat/svr4/svr4_syscallargs.h>
#include <compat/svr4/svr4_statvfs.h>
#include <compat/svr4/svr4_acl.h>

0	NOARGS		{ int sys_nosys(void); } syscall
1	NOARGS		{ int sys_exit(int rval); }
2	NOARGS		{ int sys_fork(void); }
3	NOARGS		{ int sys_read(int fd, char *buf, u_int nbyte); }
4	NOARGS		{ int sys_write(int fd, char *buf, u_int nbyte); }
5	STD		{ int svr4_sys_open(char *path, int flags, int mode); }
6	NOARGS		{ int sys_close(int fd); }
7	STD		{ int svr4_sys_wait(int *status); }
8	STD		{ int svr4_sys_creat(char *path, int mode); }
9	NOARGS		{ int sys_link(char *path, char *link); }
10	NOARGS		{ int sys_unlink(char *path); }
11	STD		{ int svr4_sys_execv(char *path, char **argp); }
12	NOARGS		{ int sys_chdir(char *path); }
13	STD		{ int svr4_sys_time(svr4_time_t *t); }
14	STD		{ int svr4_sys_mknod(char *path, int mode, int dev); }
15	NOARGS		{ int sys_chmod(char *path, int mode); }
16	NOARGS		{ int sys_chown(char *path, int uid, int gid); }
17	STD		{ int svr4_sys_break(caddr_t nsize); }
18	STD		{ int svr4_sys_stat(char *path, struct svr4_stat* ub); }
19	NOARGS		{ long compat_43_sys_lseek(int fd, long offset, \
			    int whence); }
20	NOARGS		{ pid_t sys_getpid(void); }
21	UNIMPL		old_mount
22	UNIMPL		System V umount
23	NOARGS		{ int sys_setuid(uid_t uid); }
24	NOARGS		{ uid_t sys_getuid(void); }
25	UNIMPL		stime
26	UNIMPL		ptrace
27	STD		{ int svr4_sys_alarm(unsigned sec); }
28	STD		{ int svr4_sys_fstat(int fd, struct svr4_stat *sb); }
29	STD		{ int svr4_sys_pause(void); }
30	STD		{ int svr4_sys_utime(char *path, \
					     struct svr4_utimbuf *ubuf); }
31	UNIMPL		was stty
32	UNIMPL		was gtty
33	STD		{ int svr4_sys_access(char *path, int flags); }
34	STD		{ int svr4_sys_nice(int prio); }
35	UNIMPL		statfs
36	NOARGS		{ int sys_sync(void); }
37	STD		{ int svr4_sys_kill(int pid, int signum); }
38	UNIMPL		fstatfs
39	STD		{ int svr4_sys_pgrpsys(int cmd, int pid, int pgid); }
40	UNIMPL		xenix
41	NOARGS		{ int sys_dup(u_int fd); }
42	NOARGS		{ int sys_opipe(void); }
43	STD		{ int svr4_sys_times(struct tms *tp); }
44	UNIMPL		profil
45	UNIMPL		plock
46	NOARGS		{ int sys_setgid(gid_t gid); }
47	NOARGS		{ gid_t sys_getgid(void); }
48	STD		{ int svr4_sys_signal(int signum, svr4_sig_t handler); }
#ifdef SYSVMSG
49	STD		{ int svr4_sys_msgsys(int what, int a2, int a3, \
					      int a4, int a5); }
#else
49	UNIMPL		msgsys
#endif
50	STD		{ int svr4_sys_sysarch(int op, void *a1); }
51	UNIMPL		acct
#ifdef SYSVSHM
52	STD		{ int svr4_sys_shmsys(int what, int a2, int a3, \
					      int a4); }
#else
52	UNIMPL		shmsys
#endif
#ifdef SYSVSEM
53	STD		{ int svr4_sys_semsys(int what, int a2, int a3, \
					      int a4, int a5); }
#else
53	UNIMPL		semsys
#endif
54	STD		{ int svr4_sys_ioctl(int fd, u_long com, \
			    caddr_t data); }
55	UNIMPL		uadmin
56	UNIMPL		exch
57	STD		{ int svr4_sys_utssys(void *a1, void *a2, int sel, \
			    void *a3); }
58	NOARGS		{ int sys_fsync(int fd); }
59	STD		{ int svr4_sys_execve(char *path, char **argp, \
			    char **envp); }
60	NOARGS		{ int sys_umask(int newmask); }
61	NOARGS		{ int sys_chroot(char *path); }
62	STD		{ int svr4_sys_fcntl(int fd, int cmd, char *arg); }
63	STD		{ long svr4_sys_ulimit(int cmd, long newlimit); }
64	UNIMPL		reserved for unix/pc
65	UNIMPL		reserved for unix/pc
66	UNIMPL		reserved for unix/pc
67	UNIMPL		reserved for unix/pc
68	UNIMPL		reserved for unix/pc
69	UNIMPL		reserved for unix/pc
70	OBSOL		advfs
71	OBSOL		unadvfs
72	OBSOL		rmount
73	OBSOL		rumount
74	OBSOL		rfstart
75	OBSOL		sigret
76	STD		{ int svr4_sys_rdebug(void); }
77	OBSOL		rfstop
78	UNIMPL		rfsys
79	NOARGS		{ int sys_rmdir(char *path); }
80	NOARGS		{ int sys_mkdir(char *path, int mode); }
81	STD		{ int svr4_sys_getdents(int fd, char *buf, \
			    int nbytes); }
82	OBSOL		libattach
83	OBSOL		libdetach
84	UNIMPL		sysfs
85	STD		{ int svr4_sys_getmsg(int fd, struct svr4_strbuf *ctl, \
			    struct svr4_strbuf *dat, int *flags); }
86	STD		{ int svr4_sys_putmsg(int fd, struct svr4_strbuf *ctl, \
			    struct svr4_strbuf *dat, int flags); }
87	NOARGS		{ int sys_poll(struct pollfd *fds, u_long nfds, \
			    int timeout); }
88	STD		{ int svr4_sys_lstat(char *path, \
			    struct svr4_stat *ub); }
89	NOARGS		{ int sys_symlink(char *path, char *link); }
90	NOARGS		{ int sys_readlink(char *path, char *buf, int count); }
91	NOARGS		{ int sys_getgroups(u_int gidsetsize, gid_t *gidset); }
92	NOARGS		{ int sys_setgroups(u_int gidsetsize, gid_t *gidset); }
93	NOARGS		{ int sys_fchmod(int fd, int mode); }
94	NOARGS		{ int sys_fchown(int fd, int uid, int gid); }
95	STD		{ int svr4_sys_sigprocmask(int how, \
			    svr4_sigset_t *set, svr4_sigset_t *oset); }
96	STD		{ int svr4_sys_sigsuspend(svr4_sigset_t *ss); }
97	STD		{ int svr4_sys_sigaltstack( \
			    struct svr4_sigaltstack *nss, \
			    struct svr4_sigaltstack *oss); }
98	STD		{ int svr4_sys_sigaction(int signum, \
			    struct svr4_sigaction *nsa, \
			    struct svr4_sigaction *osa); }
99	STD		{ int svr4_sys_sigpending(int what, \
			    svr4_sigset_t *mask); }
100	STD		{ int svr4_sys_context(int func, \
			    struct svr4_ucontext *uc); }
101	UNIMPL		evsys
102	UNIMPL		evtrapret
103	STD		{ int svr4_sys_statvfs(char *path, \
			    struct svr4_statvfs *fs); }
104	STD		{ int svr4_sys_fstatvfs(int fd, \
			    struct svr4_statvfs *fs); }
105	UNIMPL
106	UNIMPL		nfssvc
107	STD		{ int svr4_sys_waitsys(int grp, int id, \
			    union svr4_siginfo *info, int options); }
108	UNIMPL		sigsendsys
109	STD		{ int svr4_sys_hrtsys(int cmd, int fun, int sub, \
			    void *rv1, void *rv2); }
110	UNIMPL		acancel
111	UNIMPL		async
112	UNIMPL		priocntlsys
113	STD		{ int svr4_sys_pathconf(char *path, int name); }
114	NOARGS		{ int sys_mincore(caddr_t addr, int len, char *vec); }
115	STD		{ int svr4_sys_mmap(svr4_caddr_t addr, \
			    svr4_size_t len, int prot, int flags, int fd, \
			    svr4_off_t pos); }
116	NOARGS		{ int sys_mprotect(caddr_t addr, int len, int prot); }
117	NOARGS		{ int sys_munmap(caddr_t addr, int len); }
118	STD		{ int svr4_sys_fpathconf(int fd, int name); }
119	NOARGS		{ int sys_vfork(void); }
120	NOARGS		{ int sys_fchdir(int fd); }
121	NOARGS		{ int sys_readv(int fd, struct iovec *iovp, u_int iovcnt); }
122	NOARGS		{ int sys_writev(int fd, struct iovec *iovp, \
			    u_int iovcnt); }
123	STD		{ int svr4_sys_xstat(int two, char *path, \
			    struct svr4_xstat *ub); }
124	STD		{ int svr4_sys_lxstat(int two, char *path, \
			    struct svr4_xstat *ub); }
125	STD		{ int svr4_sys_fxstat(int two, int fd, \
			    struct svr4_xstat *sb); }
126	STD		{ int svr4_sys_xmknod(int two, char *path, \
			    svr4_mode_t mode, svr4_dev_t dev); }
127	UNIMPL		clocal
128	STD		{ int svr4_sys_setrlimit(int which, \
			    struct ogetrlimit *rlp); }
129	STD		{ int svr4_sys_getrlimit(int which, \
			    struct ogetrlimit *rlp); }
130	NOARGS		{ int sys_lchown(char *path, int uid, int gid); }
131	STD		{ int svr4_sys_memcntl(svr4_caddr_t addr, \
			    svr4_size_t len, int cmd, svr4_caddr_t arg, \
			    int attr, int mask); }
132	UNIMPL		getpmsg
133	UNIMPL		putpmsg
134	NOARGS		{ int sys_rename(char *from, char *to); }
135	STD		{ int svr4_sys_uname(struct svr4_utsname* name, \
			    int dummy); }
136	STD		{ int svr4_sys_setegid(gid_t egid); }
137	STD		{ int svr4_sys_sysconfig(int name); }
138	NOARGS		{ int sys_adjtime(struct timeval *delta, \
			    struct timeval *olddelta); }
139	STD		{ long svr4_sys_systeminfo(int what, char *buf, \
			    long len); }
140	UNIMPL
141	NOARGS		{ int sys_seteuid(uid_t euid); }
142	UNIMPL		vtrace
143	UNIMPL		fork1
144	UNIMPL		sigtimedwait
145	UNIMPL		lwp_info
146	UNIMPL		yield
147	UNIMPL		lwp_sema_wait
148	UNIMPL		lwp_sema_post
149	UNIMPL		lwp_sema_trywait
150	UNIMPL
151	UNIMPL
152	UNIMPL		modctl
153	STD		{ int svr4_sys_fchroot(int fd); }
154	STD		{ int svr4_sys_utimes(char *path, \
					      struct timeval *tptr); }
155	STD		{ int svr4_sys_vhangup(void); }
156	STD		{ int svr4_sys_gettimeofday(struct timeval *tp); }
157	NOARGS		{ int sys_getitimer(u_int which, \
			    struct itimerval *itv); }
158	NOARGS		{ int sys_setitimer(u_int which, \
			    struct itimerval *itv, struct itimerval *oitv); }
159	UNIMPL		lwp_create
160	UNIMPL		lwp_exit
161	UNIMPL		lwp_suspend
162	UNIMPL		lwp_continue
163	UNIMPL		lwp_kill
164	UNIMPL		lwp_self
165	UNIMPL		lwp_getprivate
166	UNIMPL		lwp_setprivate
167	UNIMPL		lwp_wait
168	UNIMPL		lwp_mutex_unlock
169	UNIMPL		lwp_mutex_lock
170	UNIMPL		lwp_cond_wait
171	UNIMPL		lwp_cond_signal
172	UNIMPL		lwp_cond_broadcast
173	STD		{ ssize_t svr4_sys_pread(int fd, void *buf, \
			    size_t nbyte, svr4_off_t off); }
174	STD		{ ssize_t svr4_sys_pwrite(int fd, const void *buf, \
			    size_t nbyte, svr4_off_t off); }
175	STD		{ svr4_off64_t svr4_sys_llseek(int fd, \
			    long offset1, long offset2, int whence); }
176	UNIMPL		inst_sync
177	UNIMPL
178	UNIMPL		kaio
179	UNIMPL
180	UNIMPL
181	UNIMPL
182	UNIMPL
183	UNIMPL
184	UNIMPL		tsolsys
185	STD		{ int svr4_sys_acl(char *path, int cmd, int num, \
			    struct svr4_aclent *buf); }
186	STD		{ int svr4_sys_auditsys(int code, int a1, int a2, \
			    int a3, int a4, int a5); }
187	UNIMPL		processor_bind
188	UNIMPL		processor_info
189	UNIMPL		p_online
190	UNIMPL		sigqueue
191	NOARGS		{ int sys_clock_gettime(clockid_t clock_id, \
			    struct timespec *tp); }
192	NOARGS		{ int sys_clock_settime(clockid_t clock_id, \
			    const struct timespec *tp); }
193	NOARGS		{ int sys_clock_getres(clockid_t clock_id, \
			    struct timespec *tp); }
194	UNIMPL		timer_create
195	UNIMPL		timer_delete
196	UNIMPL		timer_settime
197	UNIMPL		timer_gettime
198	UNIMPL		timer_getoverrun
199	NOARGS		{ int sys_nanosleep(const struct timespec *rqtp, \
			    struct timespec *rmtp); }
200	STD		{ int svr4_sys_facl(int fd, int cmd, int num, \
			    struct svr4_aclent *buf); }
201	UNIMPL		door
202	NOARGS		{ int sys_setreuid(uid_t ruid, uid_t euid); }
203	NOARGS		{ int sys_setregid(gid_t rgid, gid_t egid); }
204	UNIMPL		install_utrap
205	UNIMPL		signotify
206	UNIMPL		schedctl
207	UNIMPL		pset
208	UNIMPL
209	UNIMPL		resolvepath
210	UNIMPL		signotifywait
211	UNIMPL		lwp_sigredirect
212	UNIMPL		lwp_alarm
213	STD		{ int svr4_sys_getdents64(int fd, \
			    struct svr4_dirent64 *dp, \
			    int nbytes); }
214 	STD		{ int svr4_sys_mmap64(svr4_caddr_t addr, \
			    svr4_size_t len, int prot, int flags, int fd, \
			    svr4_off64_t pos); }
215	STD		{ int svr4_sys_stat64(const char *path, \
			    struct svr4_stat64 *sb); }
216	STD		{ int svr4_sys_lstat64(const char *path, \
			    struct svr4_stat64 *sb); }
217	STD		{ int svr4_sys_fstat64(int fd, \
			    struct svr4_stat64 *sb); }
218	UNIMPL		statvfs64
219     STD             { int svr4_sys_fstatvfs64(int fd, \
                            struct svr4_statvfs64 *fs); }
220	UNIMPL		setrlimit64
221	UNIMPL		getrlimit64
222	STD		{ ssize_t svr4_sys_pread64(int fd, void *buf, \
			    size_t nbyte, svr4_off64_t off); }
223	STD		{ ssize_t svr4_sys_pwrite64(int fd, const void *buf, \
			    size_t nbyte, svr4_off64_t off); }
224 	STD		{ int svr4_sys_creat64(char *path, int mode); }
225	STD		{ int svr4_sys_open64(char *path, int flags, \
			    int mode); }
226	UNIMPL		rpcsys
227	UNIMPL
228	UNIMPL
229	UNIMPL
230	STD		{ int svr4_sys_socket(int domain, int type, \
			    int protocol); }
231	NOARGS		{ int sys_socketpair(int domain, int type, \
			    int protocol, int *rsv); }
232	NOARGS		{ int sys_bind(int s, const struct sockaddr *name, \
			    int namelen); }
233	NOARGS		{ int sys_listen(int s, int backlog); }
234	NOARGS		{ int compat_43_sys_accept(int s, \
			    struct sockaddr *name, int *anamelen); }
235	NOARGS		{ int sys_connect(int s, const struct sockaddr *name, \
			    int namelen); }
236	NOARGS		{ int sys_shutdown(int s, int how); }
237	NOARGS		{ int compat_43_sys_recv(int s, caddr_t buf, int len, \
			    int flags); }
238	NOARGS		{ ssize_t compat_43_sys_recvfrom(int s, void *buf, \
			    size_t len, int flags, struct sockaddr *from, \
			    int *fromlenaddr); }
239	NOARGS		{ ssize_t compat_43_sys_recvmsg(int s, \
			    struct msghdr *msg, int flags); }
240	NOARGS		{ int compat_43_sys_send(int s, caddr_t buf, int len, \
			    int flags); }
241	NOARGS		{ ssize_t compat_43_sys_sendmsg(int s, \
			    const struct msghdr *msg, int flags); }
242	NOARGS		{ ssize_t sys_sendto(int s, const void *buf, \
			    size_t len, int flags, const struct sockaddr *to, \
			    int tolen); }
243	NOARGS		{ int compat_43_sys_getpeername(int fdes, \
			    struct sockaddr *asa, int *alen); }
244	NOARGS		{ int compat_43_sys_getsockname(int fdes, \
			    struct sockaddr *asa, int *alen); }
245	NOARGS		{ int sys_getsockopt(int s, int level, int name, \
			    void *val, int *avalsize); }
246	NOARGS		{ int sys_setsockopt(int s, int level, int name, \
			    const void *val, int valsize); }
247	UNIMPL		sockconfig
248	UNIMPL		ntp_gettime
249	UNIMPL		ntp_adjtime
@


1.33
log
@Bring back setreuid(2) and setregid(2) as first class syscalls
(but still implemented via setres[ug]id(2)).  Basically this just
moves them from COMPAT_43 into kern_prot.c.  Also fixes a typo in my
old implementation.  The userland portion will follow in a few days.
deraadt@@ OK
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.32 2002/07/06 19:14:20 nordin Exp $
@


1.32
log
@Remove kernel support for NTP. ok deraadt@@ and tholo@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.31 2002/03/14 03:16:03 millert Exp $
d314 2
a315 2
202	NOARGS		{ int compat_43_sys_setreuid(int ruid, int euid); }
203	NOARGS		{ int compat_43_sys_setregid(int rgid, int egid); }
@


1.31
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.30 2000/08/23 19:31:35 fgsch Exp $
a387 4
#ifdef NTP
248	NOARGS		{ int sys_ntp_gettime(struct ntptimeval *ntvp); }
249	NOARGS		{ int sys_ntp_adjtime(struct timex *tp); }
#else
a389 1
#endif
@


1.30
log
@- Simplify pread and pwrite now that we have a native implementation.
- Implement pread/pwrite 64.
- Add DUP2FD fcntl command, which is nothing else than dup2 (according
to solaris manpage). This solves the dup error and the freezing problem
on netscape-solaris (DNS still not working, tho). code from NetBSD.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.29 2000/06/28 23:48:15 fgsch Exp $
d63 1
a63 1
14	STD		{ int svr4_sys_mknod(char* path, int mode, int dev); }
d67 1
a67 1
18	STD		{ int svr4_sys_stat(char* path, struct svr4_stat* ub); }
@


1.30.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.30 2000/08/23 19:31:35 fgsch Exp $
d63 1
a63 1
14	STD		{ int svr4_sys_mknod(char *path, int mode, int dev); }
d67 1
a67 1
18	STD		{ int svr4_sys_stat(char *path, struct svr4_stat* ub); }
@


1.30.8.2
log
@sync to -current
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.30.8.1 2002/06/11 03:28:09 art Exp $
d388 4
d394 1
@


1.30.8.3
log
@sync
@
text
@d1 1
a1 1
	$OpenBSD$
d314 2
a315 2
202	NOARGS		{ int sys_setreuid(uid_t ruid, uid_t euid); }
203	NOARGS		{ int sys_setregid(gid_t rgid, gid_t egid); }
@


1.29
log
@add creat64 and mmap64.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.28 2000/06/24 21:00:30 fgsch Exp $
d342 4
a345 2
222	UNIMPL		pread64
223	UNIMPL		pwrite64
@


1.28
log
@Implement getdents64, lstat64 and stat64, basically the same functions of
the existing ones using 64bit vars. This makes netscape-solaris works on
sparc.

Particular note to those who want to try netscape:
- netscape 4.73 was used for testing on a ss5 with -current.
- apparently solaris uses pipes for communicating with the X server. I've
  checked the libraries I've installed from a solaris 2.6 box, and although
  there are references to X11-unix, it fails when it tries to open
  X11-pipe/X0, so in order to test it you need to specify -display <box ip>:0
  or it won't start.
- i got some errors when starting, but besides that, it works fine.
- it's not slow, but you better have all the requiered files in the correct
  paths, or it'll take some time to start.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.27 2000/06/15 05:28:30 brad Exp $
d328 3
a330 1
214	UNIMPL		mmap64
d344 1
a344 1
224	UNIMPL		creat64
@


1.27
log
@add more unimplemented syscall name placeholders, from NetBSD.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.26 1999/10/07 17:23:53 brad Exp $
d325 3
a327 1
213	UNIMPL		getdents64
d329 4
a332 2
215	UNIMPL		stat64
216	UNIMPL		lstat64
@


1.26
log
@- fix typo in previous commit
- Implement fstatvfs64 system call
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.25 1999/10/07 16:14:28 brad Exp $
d248 1
a248 1
149	UNIMPL
d321 1
a321 1
209	UNIMPL
@


1.26.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.30 2000/08/23 19:31:35 fgsch Exp $
d248 1
a248 1
149	UNIMPL		lwp_sema_trywait
d321 1
a321 1
209	UNIMPL		resolvepath
d325 4
a328 10
213	STD		{ int svr4_sys_getdents64(int fd, \
			    struct svr4_dirent64 *dp, \
			    int nbytes); }
214 	STD		{ int svr4_sys_mmap64(svr4_caddr_t addr, \
			    svr4_size_t len, int prot, int flags, int fd, \
			    svr4_off64_t pos); }
215	STD		{ int svr4_sys_stat64(const char *path, \
			    struct svr4_stat64 *sb); }
216	STD		{ int svr4_sys_lstat64(const char *path, \
			    struct svr4_stat64 *sb); }
d336 3
a338 5
222	STD		{ ssize_t svr4_sys_pread64(int fd, void *buf, \
			    size_t nbyte, svr4_off64_t off); }
223	STD		{ ssize_t svr4_sys_pwrite64(int fd, const void *buf, \
			    size_t nbyte, svr4_off64_t off); }
224 	STD		{ int svr4_sys_creat64(char *path, int mode); }
@


1.26.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
	$OpenBSD$
d63 1
a63 1
14	STD		{ int svr4_sys_mknod(char *path, int mode, int dev); }
d67 1
a67 1
18	STD		{ int svr4_sys_stat(char *path, struct svr4_stat* ub); }
@


1.26.4.3
log
@Sync the SMP branch with 3.3
@
text
@d314 2
a315 2
202	NOARGS		{ int sys_setreuid(uid_t ruid, uid_t euid); }
203	NOARGS		{ int sys_setregid(gid_t rgid, gid_t egid); }
d388 4
d394 1
@


1.25
log
@- Fix stat and mknod syscalls to properly disassemble and reassemble
  dev_t values to/from emulation dev_t's
- Implement fstat64, llseek and open64 system calls; from NetBSD
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.24 1999/06/07 07:17:48 deraadt Exp $
d332 2
a333 1
219	UNIMPL		fstatvfs64
@


1.24
log
@replacement pipe() system call; copies data into place inside kernel, so
that EFAULT return value is possible
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.23 1998/03/06 21:58:10 niklas Exp $
d279 2
a280 1
175	UNIMPL		llseek
d329 2
a330 1
217	UNIMPL		fstat64
d338 2
a339 1
225	UNIMPL		open64
@


1.23
log
@Make NCR rdebug behaviour dependent on p_os field
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.22 1998/02/10 13:41:55 niklas Exp $
d93 1
a93 1
42	NOARGS		{ int sys_pipe(void); }
@


1.22
log
@fake rdebug proto
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.21 1997/12/09 10:59:50 deraadt Exp $
d145 1
a145 5
#ifdef COMPAT_SVR4_NCR
76	STD		{ int svr4_ncr_sys_rdebug(void); }
#else
76	OBSOL		rdebug
#endif
@


1.21
log
@eol
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.20 1997/12/02 00:07:05 deraadt Exp $
d146 1
a146 1
76	STD		{ int svr4_ncr_sys_rdebug(); }
@


1.20
log
@If i386, and COMPAT_LINUX is enabled, if setegid() is called with an out
of range value recognize it as the Linux personality() system call, and
switch into Linux emulation mode.... At least they could have picked an
unused system call number!
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.19 1997/11/13 06:23:06 deraadt Exp $
d386 1
a386 1
#endif@


1.19
log
@fake auditsys()
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.18 1997/08/29 20:44:26 kstailey Exp $
d237 1
a237 1
136	NOARGS		{ int sys_setegid(gid_t egid); }
@


1.18
log
@prefix ntp system calls with sys_ like other system calls
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.17 1997/08/29 20:36:13 kstailey Exp $
d295 2
a296 1
186	UNIMPL		auditsys
@


1.17
log
@ntp_gettime(2), ntp_adjtime(2)
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.16 1997/08/29 20:15:07 kstailey Exp $
d380 2
a381 2
248	NOARGS		{ int ntp_gettime(struct ntptimeval *ntvp); }
249	NOARGS		{ int ntp_adjtime(struct timex *tp); }
@


1.16
log
@clock_gettime(2), clock_settime(2), clock_getres(2), microsleep(2)
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.15 1997/08/29 19:55:57 kstailey Exp $
d379 4
d385 1
@


1.15
log
@s/UNIMPL/STD/ for svr4_sys_socket()
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.14 1997/08/29 19:35:20 kstailey Exp $
d300 6
a305 3
191	UNIMPL		clock_gettime
192	UNIMPL		clock_settime
193	UNIMPL		clock_getres
d311 2
a312 1
199	UNIMPL		nanosleep
@


1.14
log
@add support for sockets.
add names to some UNIMPL's.
split up some lines to fit in 80 cols.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.13 1997/08/29 18:45:52 kstailey Exp $
d340 1
a340 1
230	UNIMPL		{ int svr4_sys_socket(int domain, int type, \
@


1.13
log
@pread(2) / pwrite(2)
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.12 1997/03/28 22:03:49 kstailey Exp $
d154 2
a155 1
81	STD		{ int svr4_sys_getdents(int fd, char *buf, int nbytes); }
d176 2
a177 1
97	STD		{ int svr4_sys_sigaltstack(struct svr4_sigaltstack *nss, \
d314 4
a317 4
204	UNIMPL
205	UNIMPL
206	UNIMPL
207	UNIMPL
d323 54
@


1.12
log
@added 34 - nice
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.11 1997/02/13 19:45:27 niklas Exp $
d277 4
a280 2
173	UNIMPL		pread
174	UNIMPL		pwrite
@


1.11
log
@Merge of NetBSD 970211
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.10 1997/01/26 23:02:24 downsj Exp $
d85 1
a85 1
34	UNIMPL		nice
@


1.10
log
@We can do lchown(2) now.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.9 1997/01/11 17:57:31 mickey Exp $
d40 1
d47 1
d79 1
a79 1
29	UNIMPL		pause
d162 2
a163 2
87	NOARGS		{ int sys_poll(struct pollfd *fds, \
			    unsigned long nfds, int timeout); }
d227 3
a229 1
131	UNIMPL		memcntl
d289 2
a290 1
185	UNIMPL		acl
d305 2
a306 1
200	UNIMPL		facl
d308 2
a309 2
202	UNIMPL		setreuid
203	UNIMPL		setregid
@


1.9
log
@implement mincore syscall, just like sunos & ultrix compat do.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.8 1996/08/02 21:55:24 niklas Exp $
d224 1
a224 1
130	UNIMPL		lchown
@


1.8
log
@/sys_poll/s/STD/NOARGS/
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.7 1996/08/02 20:20:33 niklas Exp $
d199 1
a199 1
114	UNIMPL		mincore
@


1.7
log
@Make emulations use our native poll(2)
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.5 1996/04/21 22:18:42 deraadt Exp $
d160 1
a160 1
87	STD		{ int sys_poll(struct pollfd *fds, \
@


1.6
log
@Add COMPAT_SVR4_NCR support for making the SVR4 emulation behave as
NCR SVR4, currently this means that syscall#76 (rdebug) should return
ENXIO instead of issueing a SIGSYS.  Also removed svr4_conf.h no
longer used.
@
text
@d160 2
a161 2
87	STD		{ int svr4_sys_poll(struct svr4_pollfd *fds, \
			    long nfds, int timeout); }
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.4 1996/02/26 23:32:08 niklas Exp $
d6 1
a6 1
; NetBSD COMPAT_SVR4 system call name/number "master" file.
d143 3
d147 1
@


1.4
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
	$OpenBSD$
	$NetBSD: syscalls.master,v 1.17 1996/02/10 17:12:51 christos Exp $
@


1.3
log
@from christos; add utime() and utimes()
@
text
@d1 2
a2 1
	$NetBSD: syscalls.master,v 1.15 1995/12/19 07:13:27 christos Exp $
d194 1
a194 1
113	UNIMPL		pathconf
d201 1
a201 1
118	NOARGS		{ int sys_fpathconf(int fd, int name); }
d213 2
a214 1
126	UNIMPL		xmknod
d237 1
a237 1
144	UNIMPL		sigwait
d240 2
a241 2
147	UNIMPL		lwp_sema_p
148	UNIMPL		lwp_sema_v
d274 1
a274 1
178	UNIMPL
d280 2
a281 2
184	UNIMPL
185	UNIMPL
d283 26
@


1.2
log
@update from netbsd
@
text
@d1 1
a1 1
	$NetBSD: syscalls.master,v 1.14 1995/10/14 20:25:06 christos Exp $
d40 1
d77 2
a78 1
30	UNIMPL		utime
d245 2
a246 1
154	UNIMPL		utimes
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
	$NetBSD: syscalls.master,v 1.13 1995/10/07 06:27:57 mycroft Exp $
d96 2
a97 2
49	UNIMPL		{ int sys_msgsys(int which, int a2, int a3, int a4, \
			    int a5, int a6); }
d104 2
a105 1
52	UNIMPL		{ int sys_shmsys(int which, int a2, int a3, int a4); }
d110 2
a111 2
53	UNIMPL		{ int sys_semsys(int which, int a2, int a3, int a4, \
			    int a5); }
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

