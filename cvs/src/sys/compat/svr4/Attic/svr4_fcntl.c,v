head	1.24;
access;
symbols
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.32
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.34
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.30
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.28
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.26
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.24
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.22
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.20
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.18
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.16
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.14
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.12
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.10
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.8
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.22.0.6
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.22
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.18.0.4
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	SMP:1.14.0.4
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.6
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2011.07.04.23.01.33;	author tedu;	state dead;
branches;
next	1.23;

1.23
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.13.19.08.06;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.02.16.05.58;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.10.26.12.03.27;	author art;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.03.25.05.20.01;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.23.19.31.34;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.28.23.48.15;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.21.15.50.21;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.10.07.16.14.28;	author brad;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	97.12.20.16.32.08;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.12.17.07.25.51;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.12.17.03.30.40;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.08.29.19.14.53;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	97.08.29.18.55.56;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.08.29.18.46.31;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	97.08.29.17.59.51;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.08.07.09.16.20;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.01.19.00.43.43;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.01.08.13.04.57;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.08.02.20.20.32;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.47.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.23;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.23;	author deraadt;	state Exp;
branches;
next	;

1.14.4.1
date	2001.05.14.22.05.25;	author niklas;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2002.03.28.11.28.07;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@remove all the compat svr4 files
@
text
@/*	$OpenBSD: svr4_fcntl.c,v 1.23 2010/07/26 01:56:27 guenther Exp $	 */
/*	$NetBSD: svr4_fcntl.c,v 1.14 1995/10/14 20:24:24 christos Exp $	 */

/*
 * Copyright (c) 1997 Theo de Raadt
 * Copyright (c) 1994 Christos Zoulas
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/vnode.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/mount.h>
#include <sys/malloc.h>
#include <sys/poll.h>
#include <sys/syscallargs.h>

#include <compat/svr4/svr4_types.h>
#include <compat/svr4/svr4_signal.h>
#include <compat/svr4/svr4_syscallargs.h>
#include <compat/svr4/svr4_util.h>
#include <compat/svr4/svr4_fcntl.h>

static u_long svr4_to_bsd_cmd(u_long);
static int svr4_to_bsd_flags(int);
static int bsd_to_svr4_flags(int);
static void bsd_to_svr4_flock(struct flock *, struct svr4_flock *);
static void svr4_to_bsd_flock(struct svr4_flock *, struct flock *);
static void bsd_to_svr3_flock(struct flock *, struct svr4_flock_svr3 *);
static void svr3_to_bsd_flock(struct svr4_flock_svr3 *, struct flock *);
static int fd_truncate(struct proc *, int, struct flock *, register_t *);

static u_long
svr4_to_bsd_cmd(cmd)
	u_long	cmd;
{
	switch (cmd) {
	case SVR4_F_DUPFD:
		return F_DUPFD;
	case SVR4_F_GETFD:
		return F_GETFD;
	case SVR4_F_SETFD:
		return F_SETFD;
	case SVR4_F_GETFL:
		return F_GETFL;
	case SVR4_F_SETFL:
		return F_SETFL;
	case SVR4_F_GETLK:
	case SVR4_F_GETLK_SVR3:
		return F_GETLK;
	case SVR4_F_SETLK:
		return F_SETLK;
	case SVR4_F_SETLKW:
		return F_SETLKW;
	default:
		return -1;
	}
}


static int
svr4_to_bsd_flags(l)
	int	l;
{
	int	r = 0;
	r |= (l & SVR4_O_RDONLY) ? O_RDONLY : 0;
	r |= (l & SVR4_O_WRONLY) ? O_WRONLY : 0;
	r |= (l & SVR4_O_RDWR) ? O_RDWR : 0;
	r |= (l & SVR4_O_NDELAY) ? O_NONBLOCK : 0;
	r |= (l & SVR4_O_APPEND) ? O_APPEND : 0;
#if 0
	/* Dellism ??? */
	r |= (l & SVR4_O_RAIOSIG) ? O_ASYNC : 0;
#endif
	r |= (l & SVR4_O_SYNC) ? O_FSYNC : 0;
	r |= (l & SVR4_O_RSYNC) ? O_RSYNC : 0;
	r |= (l & SVR4_O_DSYNC) ? O_DSYNC : 0;
	r |= (l & SVR4_O_NONBLOCK) ? O_NONBLOCK : 0;
	r |= (l & SVR4_O_PRIV) ? O_EXLOCK : 0;
	r |= (l & SVR4_O_CREAT) ? O_CREAT : 0;
	r |= (l & SVR4_O_TRUNC) ? O_TRUNC : 0;
	r |= (l & SVR4_O_EXCL) ? O_EXCL : 0;
	r |= (l & SVR4_O_NOCTTY) ? O_NOCTTY : 0;
	return r;
}


static int
bsd_to_svr4_flags(l)
	int	l;
{
	int	r = 0;
	r |= (l & O_RDONLY) ? SVR4_O_RDONLY : 0;
	r |= (l & O_WRONLY) ? SVR4_O_WRONLY : 0;
	r |= (l & O_RDWR) ? SVR4_O_RDWR : 0;
	r |= (l & O_NDELAY) ? SVR4_O_NONBLOCK : 0;
	r |= (l & O_APPEND) ? SVR4_O_APPEND : 0;
#if 0
	/* Dellism ??? */
	r |= (l & O_ASYNC) ? SVR4_O_RAIOSIG : 0;
#endif
	r |= (l & O_FSYNC) ? SVR4_O_SYNC : 0;
	r |= (l & O_RSYNC) ? SVR4_O_RSYNC : 0;
	r |= (l & O_DSYNC) ? SVR4_O_DSYNC : 0;
	r |= (l & O_NONBLOCK) ? SVR4_O_NONBLOCK : 0;
	r |= (l & O_EXLOCK) ? SVR4_O_PRIV : 0;
	r |= (l & O_CREAT) ? SVR4_O_CREAT : 0;
	r |= (l & O_TRUNC) ? SVR4_O_TRUNC : 0;
	r |= (l & O_EXCL) ? SVR4_O_EXCL : 0;
	r |= (l & O_NOCTTY) ? SVR4_O_NOCTTY : 0;
	return r;
}

static void
bsd_to_svr4_flock(iflp, oflp)
	struct flock		*iflp;
	struct svr4_flock	*oflp;
{
	switch (iflp->l_type) {
	case F_RDLCK:
		oflp->l_type = SVR4_F_RDLCK;
		break;
	case F_WRLCK:
		oflp->l_type = SVR4_F_WRLCK;
		break;
	case F_UNLCK:
		oflp->l_type = SVR4_F_UNLCK;
		break;
	default:
		oflp->l_type = -1;
		break;
	}

	oflp->l_whence = (short) iflp->l_whence;
	oflp->l_start = (svr4_off_t) iflp->l_start;
	oflp->l_len = (svr4_off_t) iflp->l_len;
	oflp->l_sysid = 0;
	oflp->l_pid = (svr4_pid_t) iflp->l_pid;
}

static void
svr4_to_bsd_flock(iflp, oflp)
	struct svr4_flock	*iflp;
	struct flock		*oflp;
{
	switch (iflp->l_type) {
	case SVR4_F_RDLCK:
		oflp->l_type = F_RDLCK;
		break;
	case SVR4_F_WRLCK:
		oflp->l_type = F_WRLCK;
		break;
	case SVR4_F_UNLCK:
		oflp->l_type = F_UNLCK;
		break;
	default:
		oflp->l_type = -1;
		break;
	}

	oflp->l_whence = iflp->l_whence;
	oflp->l_start = (off_t) iflp->l_start;
	oflp->l_len = (off_t) iflp->l_len;
	oflp->l_pid = (pid_t) iflp->l_pid;
}

static void
bsd_to_svr3_flock(iflp, oflp)
	struct flock		*iflp;
	struct svr4_flock_svr3	*oflp;
{
	switch (iflp->l_type) {
	case F_RDLCK:
		oflp->l_type = SVR4_F_RDLCK;
		break;
	case F_WRLCK:
		oflp->l_type = SVR4_F_WRLCK;
		break;
	case F_UNLCK:
		oflp->l_type = SVR4_F_UNLCK;
		break;
	default:
		oflp->l_type = -1;
		break;
	}

	oflp->l_whence = (short) iflp->l_whence;
	oflp->l_start = (svr4_off_t) iflp->l_start;
	oflp->l_len = (svr4_off_t) iflp->l_len;
	oflp->l_sysid = 0;
	oflp->l_pid = (svr4_pid_t) iflp->l_pid;
}


static void
svr3_to_bsd_flock(iflp, oflp)
	struct svr4_flock_svr3	*iflp;
	struct flock		*oflp;
{
	switch (iflp->l_type) {
	case SVR4_F_RDLCK:
		oflp->l_type = F_RDLCK;
		break;
	case SVR4_F_WRLCK:
		oflp->l_type = F_WRLCK;
		break;
	case SVR4_F_UNLCK:
		oflp->l_type = F_UNLCK;
		break;
	default:
		oflp->l_type = -1;
		break;
	}

	oflp->l_whence = iflp->l_whence;
	oflp->l_start = (off_t) iflp->l_start;
	oflp->l_len = (off_t) iflp->l_len;
	oflp->l_pid = (pid_t) iflp->l_pid;
}

static int
fd_truncate(p, fd, flp, retval)
	struct proc *p;
	int fd;
	struct flock *flp;
	register_t *retval;
{
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	off_t start, length;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct sys_ftruncate_args ft;

	/*
	 * We only support truncating the file.
	 */
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return EBADF;

	vp = (struct vnode *)fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO)
		return ESPIPE;

	FREF(fp);

	if ((error = VOP_GETATTR(vp, &vattr, p->p_ucred, p)) != 0)
		goto out;

	length = vattr.va_size;

	switch (flp->l_whence) {
	case SEEK_CUR:
		start = fp->f_offset + flp->l_start;
		break;

	case SEEK_END:
		start = flp->l_start + length;
		break;

	case SEEK_SET:
		start = flp->l_start;
		break;

	default:
		error = EINVAL;
		goto out;
	}

	if (start + flp->l_len < length) {
		/* We don't support free'ing in the middle of the file */
		error = EINVAL;
		goto out;
	}

	SCARG(&ft, fd) = fd;
	SCARG(&ft, length) = start;

	error = sys_ftruncate(p, &ft, retval);
out:
	FRELE(fp);
	return (error);
}

int
svr4_sys_open(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_open_args	*uap = v;
	int			error;
	struct sys_open_args	cup;

	caddr_t sg = stackgap_init(p->p_emul);

	SCARG(&cup, flags) = svr4_to_bsd_flags(SCARG(uap, flags));

	if (SCARG(&cup, flags) & O_CREAT)
		SVR4_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));
	else
		SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&cup, path) = SCARG(uap, path);
	SCARG(&cup, mode) = SCARG(uap, mode);
	error = sys_open(p, &cup, retval);

	if (error)
		return error;

	if (!(SCARG(&cup, flags) & O_NOCTTY) && SESS_LEADER(p->p_p) &&
	    !(p->p_p->ps_flags & PS_CONTROLT)) {
		struct filedesc	*fdp = p->p_fd;
		struct file	*fp;

		if ((fp = fd_getfile(fdp, *retval)) == NULL)
			return (EBADF);
		FREF(fp);
		/* ignore any error, just give it a try */
		if (fp->f_type == DTYPE_VNODE)
			(fp->f_ops->fo_ioctl) (fp, TIOCSCTTY, (caddr_t) 0, p);
		FRELE(fp);
	}
	return 0;
}

int
svr4_sys_open64(p, v, retval)
	register struct proc *p;
	void *v;  
	register_t *retval;  
{
	return svr4_sys_open(p, v, retval);
}

int
svr4_sys_creat(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_creat_args *uap = v;
	struct sys_open_args cup;

	caddr_t sg = stackgap_init(p->p_emul);
	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&cup, path) = SCARG(uap, path);
	SCARG(&cup, mode) = SCARG(uap, mode);
	SCARG(&cup, flags) = O_WRONLY | O_CREAT | O_TRUNC;

	return sys_open(p, &cup, retval);
}

int
svr4_sys_creat64(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	return (svr4_sys_creat(p, v, retval));
}

int             
svr4_sys_llseek(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_llseek_args *uap = v;
	struct sys_lseek_args ap;
                
	SCARG(&ap, fd) = SCARG(uap, fd);

#if BYTE_ORDER == BIG_ENDIAN
	SCARG(&ap, offset) = (((long long) SCARG(uap, offset1)) << 32) |
		SCARG(uap, offset2);
#else   
	SCARG(&ap, offset) = (((long long) SCARG(uap, offset2)) << 32) |
		SCARG(uap, offset1);
#endif  
	SCARG(&ap, whence) = SCARG(uap, whence);
   
	return sys_lseek(p, &ap, retval);
}

int
svr4_sys_access(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_access_args *uap = v;
	struct sys_access_args cup;

	caddr_t sg = stackgap_init(p->p_emul);
	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&cup, path) = SCARG(uap, path);
	SCARG(&cup, flags) = SCARG(uap, flags);

	return sys_access(p, &cup, retval);
}

int
svr4_sys_pread(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_pread_args *uap = v;
	struct sys_pread_args pra;

	SCARG(&pra, fd) = SCARG(uap, fd);
	SCARG(&pra, buf) = SCARG(uap, buf);
	SCARG(&pra, nbyte) = SCARG(uap, nbyte);
	SCARG(&pra, offset) = SCARG(uap, off);

	return (sys_pread(p, &pra, retval));
}

int
svr4_sys_pread64(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_pread64_args *uap = v;
	struct sys_pread_args pra;

	SCARG(&pra, fd) = SCARG(uap, fd);
	SCARG(&pra, buf) = SCARG(uap, buf);
	SCARG(&pra, nbyte) = SCARG(uap, nbyte);
	SCARG(&pra, offset) = SCARG(uap, off);

	return (sys_pread(p, &pra, retval));
}

int
svr4_sys_pwrite(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_pwrite_args *uap = v;
	struct sys_pwrite_args pwa;

	SCARG(&pwa, fd) = SCARG(uap, fd);
	SCARG(&pwa, buf) = SCARG(uap, buf);
	SCARG(&pwa, nbyte) = SCARG(uap, nbyte);
	SCARG(&pwa, offset) = SCARG(uap, off);

	return (sys_pwrite(p, &pwa, retval));
}

int
svr4_sys_pwrite64(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_pwrite64_args *uap = v;
	struct sys_pwrite_args pwa;

	SCARG(&pwa, fd) = SCARG(uap, fd);
	SCARG(&pwa, buf) = SCARG(uap, buf);
	SCARG(&pwa, nbyte) = SCARG(uap, nbyte);
	SCARG(&pwa, offset) = SCARG(uap, off);

	return (sys_pwrite(p, &pwa, retval));
}

int
svr4_sys_fcntl(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_fcntl_args	*uap = v;
	int				error;
	struct sys_fcntl_args		fa;

	SCARG(&fa, fd) = SCARG(uap, fd);
	SCARG(&fa, cmd) = svr4_to_bsd_cmd(SCARG(uap, cmd));

	switch (SCARG(&fa, cmd)) {
	case F_DUPFD:
	case F_GETFD:
	case F_SETFD:
		SCARG(&fa, arg) = SCARG(uap, arg);
		return sys_fcntl(p, &fa, retval);

	case F_GETFL:
		SCARG(&fa, arg) = SCARG(uap, arg);
		error = sys_fcntl(p, &fa, retval);
		if (error)
			return error;
		*retval = bsd_to_svr4_flags(*retval);
		return error;

	case F_SETFL:
		{
			/*
			 * we must save the O_ASYNC flag, as that is
			 * handled by ioctl(_, I_SETSIG, _) emulation.
			 */
			register_t flags;
			int cmd;

			cmd = SCARG(&fa, cmd); /* save it for a while */

			SCARG(&fa, cmd) = F_GETFL;
			if ((error = sys_fcntl(p, &fa, &flags)) != 0)
				return error;
			flags &= O_ASYNC;
			flags |= svr4_to_bsd_flags((u_long) SCARG(uap, arg));
			SCARG(&fa, cmd) = cmd;
			SCARG(&fa, arg) = (void *) flags;
			return sys_fcntl(p, &fa, retval);
		}

	case F_GETLK:
		if (SCARG(uap, cmd) == SVR4_F_GETLK_SVR3)		{
			struct svr4_flock_svr3	ifl;
			struct flock		*flp, fl;
			caddr_t			sg = stackgap_init(p->p_emul);

			flp = stackgap_alloc(&sg, sizeof(*flp));
			error = copyin((caddr_t)SCARG(uap, arg), (caddr_t)&ifl,
			    sizeof ifl);
			if (error)
				return error;
			svr3_to_bsd_flock(&ifl, &fl);

			error = copyout(&fl, flp, sizeof fl);
			if (error)
				return error;

			SCARG(&fa, fd) = SCARG(uap, fd);
			SCARG(&fa, cmd) = F_GETLK;
			SCARG(&fa, arg) = (void *)flp;
			error = sys_fcntl(p, &fa, retval);
			if (error)
				return error;

			error = copyin(flp, &fl, sizeof fl);
			if (error)
				return error;

			bsd_to_svr3_flock(&fl, &ifl);

			return copyout((caddr_t)&ifl, (caddr_t)SCARG(uap, arg),
			    sizeof ifl);
		}
		/*FALLTHROUGH*/
	case F_SETLK:
	case F_SETLKW:
		{
			struct svr4_flock	ifl;
			struct flock		*flp, fl;
			caddr_t			sg = stackgap_init(p->p_emul);

			flp = stackgap_alloc(&sg, sizeof(struct flock));
			SCARG(&fa, arg) = (void *) flp;

			error = copyin(SCARG(uap, arg), &ifl, sizeof ifl);
			if (error)
				return error;

			svr4_to_bsd_flock(&ifl, &fl);

			error = copyout(&fl, flp, sizeof fl);
			if (error)
				return error;

			error = sys_fcntl(p, &fa, retval);
			if (error || SCARG(&fa, cmd) != F_GETLK)
				return error;

			error = copyin(flp, &fl, sizeof fl);
			if (error)
				return error;

			bsd_to_svr4_flock(&fl, &ifl);

			return copyout(&ifl, SCARG(uap, arg), sizeof ifl);
		}
	case -1:
		switch (SCARG(uap, cmd)) {
		case SVR4_F_DUP2FD:
			{
				struct sys_dup2_args du;

				SCARG(&du, from) = SCARG(uap, fd);
				SCARG(&du, to) = (int)SCARG(uap, arg);
				error = sys_dup2(p, &du, retval);
				if (error)
					return error;
				*retval = SCARG(&du, to);
				return 0;
			}
		case SVR4_F_FREESP:
			{
				struct svr4_flock       ifl;
				struct flock		fl;

				error = copyin(SCARG(uap, arg), &ifl,
				    sizeof ifl);
				if (error)
					return error;
				svr4_to_bsd_flock(&ifl, &fl);
				return fd_truncate(p, SCARG(uap, fd), &fl,
				    retval);
			}

		default:
			return ENOSYS;
		}

	default:
		return ENOSYS;
	}
}
@


1.23
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.22 2002/03/14 01:26:51 millert Exp $	 */
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.21 2002/02/13 19:08:06 art Exp $	 */
d341 2
a342 2
	if (!(SCARG(&cup, flags) & O_NOCTTY) && SESS_LEADER(p) &&
	    !(p->p_flag & P_CONTROLT)) {
@


1.21
log
@More FREF/FRELE on relevant places. Now, only sys_mmap and a bunch of ioctl functions in sys/compat are left.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.20 2002/02/02 16:05:58 art Exp $	 */
d53 8
a60 8
static u_long svr4_to_bsd_cmd __P((u_long));
static int svr4_to_bsd_flags __P((int));
static int bsd_to_svr4_flags __P((int));
static void bsd_to_svr4_flock __P((struct flock *, struct svr4_flock *));
static void svr4_to_bsd_flock __P((struct svr4_flock *, struct flock *));
static void bsd_to_svr3_flock __P((struct flock *, struct svr4_flock_svr3 *));
static void svr3_to_bsd_flock __P((struct svr4_flock_svr3 *, struct flock *));
static int fd_truncate __P((struct proc *, int, struct flock *, register_t *));
@


1.20
log
@Be more consistent about using fd_getfile where it matters.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.19 2001/10/26 12:03:27 art Exp $	 */
d275 2
d278 1
a278 1
		return error;
d296 2
a297 1
		return EINVAL;
d302 2
a303 1
		return EINVAL;
d309 4
a312 1
	return sys_ftruncate(p, &ft, retval);
d348 1
d352 1
@


1.19
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.18 2001/03/25 05:20:01 csapuntz Exp $	 */
d337 1
a337 1
		struct file	*fp = fdp->fd_ofiles[*retval];
d339 2
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.19 2001/10/26 12:03:27 art Exp $	 */
d53 8
a60 8
static u_long svr4_to_bsd_cmd(u_long);
static int svr4_to_bsd_flags(int);
static int bsd_to_svr4_flags(int);
static void bsd_to_svr4_flock(struct flock *, struct svr4_flock *);
static void svr4_to_bsd_flock(struct svr4_flock *, struct flock *);
static void bsd_to_svr3_flock(struct flock *, struct svr4_flock_svr3 *);
static void svr3_to_bsd_flock(struct svr4_flock_svr3 *, struct flock *);
static int fd_truncate(struct proc *, int, struct flock *, register_t *);
a274 2
	FREF(fp);

d276 1
a276 1
		goto out;
d294 1
a294 2
		error = EINVAL;
		goto out;
d299 1
a299 2
		error = EINVAL;
		goto out;
d305 1
a305 4
	error = sys_ftruncate(p, &ft, retval);
out:
	FRELE(fp);
	return (error);
d337 1
a337 1
		struct file	*fp;
a338 3
		if ((fp = fd_getfile(fdp, *retval)) == NULL)
			return (EBADF);
		FREF(fp);
a341 1
		FRELE(fp);
@


1.18
log
@Don't access user space pointer directly. Thanks to dawson and team
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.17 2000/08/23 19:31:34 fgsch Exp $	 */
d268 1
a268 1
	if ((u_int)fd >= fdp->fd_nfiles || (fp = fdp->fd_ofiles[fd]) == NULL)
@


1.17
log
@- Simplify pread and pwrite now that we have a native implementation.
- Implement pread/pwrite 64.
- Add DUP2FD fcntl command, which is nothing else than dup2 (according
to solaris manpage). This solves the dup error and the freezing problem
on netscape-solaris (DNS still not working, tho). code from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.16 2000/06/28 23:48:15 fgsch Exp $	 */
d542 1
a542 2
		if (SCARG(uap, cmd) == SVR4_F_GETLK_SVR3)
		{
d544 1
a544 1
			struct flock		*flp;
d552 6
a557 1
			svr3_to_bsd_flock(&ifl, flp);
d564 7
a570 1
			bsd_to_svr3_flock(flp, &ifl);
@


1.16
log
@add creat64 and mmap64.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.15 2000/04/21 15:50:21 millert Exp $	 */
d38 1
d60 1
a99 1
	r |= (l & SVR4_O_SYNC) ? O_SYNC : 0;
d104 3
a126 1
	r |= (l & O_SYNC) ? SVR4_O_SYNC : 0;
d131 3
d250 58
d319 7
a325 1
	SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
a327 1
	SCARG(&cup, flags) = svr4_to_bsd_flags(SCARG(uap, flags));
d431 6
a436 3
	struct sys_lseek_args lap;
	struct sys_read_args rap;
	int error;
d438 2
a439 3
	SCARG(&lap, fd) = SCARG(uap, fd);
	SCARG(&lap, offset) = SCARG(uap, off);
	SCARG(&lap, whence) = SEEK_CUR;
d441 8
a448 2
	if ((error = sys_lseek(p, &lap, retval)) != 0)
		return error;
d450 4
a453 3
	SCARG(&rap, fd) = SCARG(uap, fd);
	SCARG(&rap, buf) = SCARG(uap, buf);
	SCARG(&rap, nbyte) = SCARG(uap, nbyte);
d455 1
a455 1
	return sys_read(p, &rap, retval);
d465 1
a465 3
	struct sys_lseek_args lap;
	struct sys_write_args wap;
	int error;
d467 4
a470 3
	SCARG(&lap, fd) = SCARG(uap, fd);
	SCARG(&lap, offset) = SCARG(uap, off);
	SCARG(&lap, whence) = SEEK_CUR;
d472 11
a482 2
	if ((error = sys_lseek(p, &lap, retval)) != 0)
		return error;
d484 4
a487 4
	SCARG(&wap, fd) = SCARG(uap, fd);
	SCARG(&wap, buf) = (char *)SCARG(uap, buf); /* XXX until sys_write_args
						       is fixed */
	SCARG(&wap, nbyte) = SCARG(uap, nbyte);
d489 1
a489 1
	return sys_write(p, &wap, retval);
a502 56

	if (SCARG(uap, cmd) == SVR4_F_FREESP) {
		struct svr4_flock	ifl;
		off_t			off, cur;
		caddr_t			sg = stackgap_init(p->p_emul);
		struct sys_fstat_args	ofst;
		struct stat		ost;
		struct sys_lseek_args	ols;
		struct sys_ftruncate_args /* {
			syscallarg(int) fd;
			syscallarg(int) pad;
			syscallarg(off_t) length;
		} */ nuap;

		error = copyin(SCARG(uap, arg), &ifl, sizeof ifl);
		if (error)
			return error;

		SCARG(&ofst, fd) = SCARG(uap, fd);
		SCARG(&ofst, sb) = stackgap_alloc(&sg,
		    sizeof(struct stat));
		if ((error = sys_fstat(p, &ofst, retval)) != 0)
			return error;
		if ((error = copyin(SCARG(&ofst, sb), &ost,
		    sizeof ost)) != 0)
			return error;

		SCARG(&ols, fd) = SCARG(uap, fd);
		SCARG(&ols, whence) = SEEK_CUR;
		SCARG(&ols, offset) = 0;
		if ((error = sys_lseek(p, &ols, (register_t *)&cur)) != 0)
			return error;

		off = (off_t)ifl.l_start;
		switch (ifl.l_whence) {
		case 0:
			off = (off_t)ifl.l_start;
			break;
		case 1:
			off = ost.st_size + (off_t)ifl.l_start;
			break;
		case 2:
			off = cur - (off_t)ifl.l_start;
			break;
		default:
			return EINVAL;
		}

		if (ifl.l_len != 0 && off + ifl.l_len != ost.st_size)
			return EINVAL;	/* Sorry, cannot truncate in middle */

		SCARG(&nuap, fd) = SCARG(uap, fd);
		SCARG(&nuap, length) = off;
		return (sys_ftruncate(p, &nuap, retval));
	}

d526 2
a527 1
			int cmd, flags;
d573 1
a573 1
			SCARG(&fa, arg) = (void *)flp;
d597 32
@


1.15
log
@O_FYNC -> O_SYNC
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.14 1999/10/07 16:14:28 brad Exp $	 */
d303 9
@


1.14
log
@- Fix stat and mknod syscalls to properly disassemble and reassemble
  dev_t values to/from emulation dev_t's
- Implement fstat64, llseek and open64 system calls; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.13 1997/12/20 16:32:08 deraadt Exp $	 */
d98 1
a98 1
	r |= (l & SVR4_O_SYNC) ? O_FSYNC : 0;
d123 1
a123 1
	r |= (l & O_FSYNC) ? SVR4_O_SYNC : 0;
@


1.14.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.18 2001/03/25 05:20:01 csapuntz Exp $	 */
a37 1
#include <sys/vnode.h>
a58 1
static int fd_truncate __P((struct proc *, int, struct flock *, register_t *));
d98 1
a102 3
	r |= (l & SVR4_O_SYNC) ? O_FSYNC : 0;
	r |= (l & SVR4_O_RSYNC) ? O_RSYNC : 0;
	r |= (l & SVR4_O_DSYNC) ? O_DSYNC : 0;
d123 1
a127 3
	r |= (l & O_FSYNC) ? SVR4_O_SYNC : 0;
	r |= (l & O_RSYNC) ? SVR4_O_RSYNC : 0;
	r |= (l & O_DSYNC) ? SVR4_O_DSYNC : 0;
a243 58
static int
fd_truncate(p, fd, flp, retval)
	struct proc *p;
	int fd;
	struct flock *flp;
	register_t *retval;
{
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	off_t start, length;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct sys_ftruncate_args ft;

	/*
	 * We only support truncating the file.
	 */
	if ((u_int)fd >= fdp->fd_nfiles || (fp = fdp->fd_ofiles[fd]) == NULL)
		return EBADF;

	vp = (struct vnode *)fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO)
		return ESPIPE;

	if ((error = VOP_GETATTR(vp, &vattr, p->p_ucred, p)) != 0)
		return error;

	length = vattr.va_size;

	switch (flp->l_whence) {
	case SEEK_CUR:
		start = fp->f_offset + flp->l_start;
		break;

	case SEEK_END:
		start = flp->l_start + length;
		break;

	case SEEK_SET:
		start = flp->l_start;
		break;

	default:
		return EINVAL;
	}

	if (start + flp->l_len < length) {
		/* We don't support free'ing in the middle of the file */
		return EINVAL;
	}

	SCARG(&ft, fd) = fd;
	SCARG(&ft, length) = start;

	return sys_ftruncate(p, &ft, retval);
}

d255 1
d257 1
a258 7

	if (SCARG(&cup, flags) & O_CREAT)
		SVR4_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));
	else
		SVR4_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&cup, path) = SCARG(uap, path);
a304 9
int
svr4_sys_creat64(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	return (svr4_sys_creat(p, v, retval));
}

d353 3
a355 1
	struct sys_pread_args pra;
d357 3
a359 4
	SCARG(&pra, fd) = SCARG(uap, fd);
	SCARG(&pra, buf) = SCARG(uap, buf);
	SCARG(&pra, nbyte) = SCARG(uap, nbyte);
	SCARG(&pra, offset) = SCARG(uap, off);
d361 2
a362 2
	return (sys_pread(p, &pra, retval));
}
d364 3
a366 13
int
svr4_sys_pread64(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_pread64_args *uap = v;
	struct sys_pread_args pra;

	SCARG(&pra, fd) = SCARG(uap, fd);
	SCARG(&pra, buf) = SCARG(uap, buf);
	SCARG(&pra, nbyte) = SCARG(uap, nbyte);
	SCARG(&pra, offset) = SCARG(uap, off);
d368 1
a368 1
	return (sys_pread(p, &pra, retval));
d378 3
a380 1
	struct sys_pwrite_args pwa;
d382 3
a384 4
	SCARG(&pwa, fd) = SCARG(uap, fd);
	SCARG(&pwa, buf) = SCARG(uap, buf);
	SCARG(&pwa, nbyte) = SCARG(uap, nbyte);
	SCARG(&pwa, offset) = SCARG(uap, off);
d386 2
a387 11
	return (sys_pwrite(p, &pwa, retval));
}

int
svr4_sys_pwrite64(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_pwrite64_args *uap = v;
	struct sys_pwrite_args pwa;
d389 4
a392 4
	SCARG(&pwa, fd) = SCARG(uap, fd);
	SCARG(&pwa, buf) = SCARG(uap, buf);
	SCARG(&pwa, nbyte) = SCARG(uap, nbyte);
	SCARG(&pwa, offset) = SCARG(uap, off);
d394 1
a394 1
	return (sys_pwrite(p, &pwa, retval));
d408 56
d487 1
a487 2
			register_t flags;
			int cmd;
d502 2
a503 1
		if (SCARG(uap, cmd) == SVR4_F_GETLK_SVR3)		{
d505 1
a505 1
			struct flock		*flp, fl;
d513 1
a513 6
			svr3_to_bsd_flock(&ifl, &fl);

			error = copyout(&fl, flp, sizeof fl);
			if (error)
				return error;

d520 1
a520 7

			error = copyin(flp, &fl, sizeof fl);
			if (error)
				return error;

			bsd_to_svr3_flock(&fl, &ifl);

d533 1
a533 1
			SCARG(&fa, arg) = (void *) flp;
a556 32
	case -1:
		switch (SCARG(uap, cmd)) {
		case SVR4_F_DUP2FD:
			{
				struct sys_dup2_args du;

				SCARG(&du, from) = SCARG(uap, fd);
				SCARG(&du, to) = (int)SCARG(uap, arg);
				error = sys_dup2(p, &du, retval);
				if (error)
					return error;
				*retval = SCARG(&du, to);
				return 0;
			}
		case SVR4_F_FREESP:
			{
				struct svr4_flock       ifl;
				struct flock		fl;

				error = copyin(SCARG(uap, arg), &ifl,
				    sizeof ifl);
				if (error)
					return error;
				svr4_to_bsd_flock(&ifl, &fl);
				return fd_truncate(p, SCARG(uap, fd), &fl,
				    retval);
			}

		default:
			return ENOSYS;
		}

@


1.14.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.14.4.1 2001/05/14 22:05:25 niklas Exp $	 */
d268 1
a268 1
	if ((fp = fd_getfile(fdp, fd)) == NULL)
@


1.14.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	 */
a274 2
	FREF(fp);

d276 1
a276 1
		goto out;
d294 1
a294 2
		error = EINVAL;
		goto out;
d299 1
a299 2
		error = EINVAL;
		goto out;
d305 1
a305 4
	error = sys_ftruncate(p, &ft, retval);
out:
	FRELE(fp);
	return (error);
d337 1
a337 1
		struct file	*fp;
a338 3
		if ((fp = fd_getfile(fdp, *retval)) == NULL)
			return (EBADF);
		FREF(fp);
a341 1
		FRELE(fp);
@


1.14.4.4
log
@Merge in -current from about a week ago
@
text
@d53 8
a60 8
static u_long svr4_to_bsd_cmd(u_long);
static int svr4_to_bsd_flags(int);
static int bsd_to_svr4_flags(int);
static void bsd_to_svr4_flock(struct flock *, struct svr4_flock *);
static void svr4_to_bsd_flock(struct svr4_flock *, struct flock *);
static void bsd_to_svr3_flock(struct flock *, struct svr4_flock_svr3 *);
static void svr3_to_bsd_flock(struct svr4_flock_svr3 *, struct flock *);
static int fd_truncate(struct proc *, int, struct flock *, register_t *);
@


1.13
log
@clone my F_FREESP stuff to ibcs2
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.12 1997/12/17 07:25:51 deraadt Exp $	 */
d278 9
d303 23
@


1.12
log
@improve F_FREESP; now it might work
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.11 1997/12/17 03:30:40 deraadt Exp $	 */
d5 1
@


1.11
log
@first cut at F_FREESP; does ibcs2 need this too? This really needs testing!
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.10 1997/08/29 19:14:53 kstailey Exp $	 */
d393 15
a413 8
			SCARG(&ofst, fd) = SCARG(uap, fd);
			SCARG(&ofst, sb) = stackgap_alloc(&sg,
			    sizeof(struct stat));
			if ((error = sys_fstat(p, &ofst, retval)) != 0)
				return error;
			if ((error = copyin(SCARG(&ofst, sb), &ost,
			    sizeof ost)) != 0)
				return error;
a416 5
			SCARG(&ols, fd) = SCARG(uap, fd);
			SCARG(&ols, whence) = SEEK_CUR;
			SCARG(&ols, offset) = 0;
			if ((error = sys_lseek(p, &ols, (register_t *)&cur)) != 0)
				return error;
d422 3
@


1.10
log
@write(2)'s buf arg is externally a "const void *", but interally a "char *".
Cast around it until it gets fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.9 1997/08/29 18:55:56 kstailey Exp $	 */
d375 51
@


1.9
log
@patch to avoid warning while I figure out what the deal with SCARG() is.
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.8 1997/08/29 18:46:31 kstailey Exp $	 */
d357 2
a358 1
	SCARG(&wap, buf) = (void *)SCARG(uap, buf);
@


1.8
log
@pread(2) / pwrite(2), regen
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.7 1997/08/29 17:59:51 kstailey Exp $	 */
d357 1
a357 1
	SCARG(&wap, buf) = SCARG(uap, buf);
@


1.7
log
@if O_NOCTTY is supplied to open(2) do *not* aquire a controlling tty
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.6 1997/08/07 09:16:20 niklas Exp $	 */
d311 50
@


1.6
log
@O_ASYNC handling from NetBSD...
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.5 1997/01/19 00:43:43 niklas Exp $	 */
d264 1
a264 1
	if ((SCARG(&cup, flags) & O_NOCTTY) && SESS_LEADER(p) &&
@


1.5
log
@Do the F_GETLK_SVR3 support not depending on ibcs2, as sparc does not look
there
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.4 1997/01/08 13:04:57 niklas Exp $	 */
d98 2
d101 1
d123 2
d126 1
d342 18
a359 3
		SCARG(&fa, arg) =
			(void *) svr4_to_bsd_flags((u_long) SCARG(uap, arg));
		return sys_fcntl(p, &fa, retval);
@


1.4
log
@svr4 should support the svr3 style fcntl-cmd name F_GETLK_SVR3
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.3 1996/08/02 20:20:32 niklas Exp $	 */
a50 4
#include <compat/ibcs2/ibcs2_types.h>
#include <compat/ibcs2/ibcs2_signal.h>
#include <compat/ibcs2/ibcs2_syscallargs.h>

d56 2
d75 1
a156 1

d181 28
d210 25
a269 1

a288 1

a306 1

a316 3
	if (SCARG(uap, cmd) == SVR4_F_GETLK_SVR3)
		return ibcs2_sys_fcntl(p, v, retval);

d341 23
d367 1
a367 1
			struct svr4_flock	 ifl;
d369 1
a369 1
			caddr_t sg = stackgap_init(p->p_emul);
d372 1
a372 1
			SCARG(&fa, arg) = (void *) flp;
@


1.3
log
@Make emulations use our native poll(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: svr4_fcntl.c,v 1.14 1995/10/14 20:24:24 christos Exp $	 */
d51 4
d268 3
@


1.2
log
@update from netbsd
@
text
@d1 1
d42 1
a42 1

a49 1
#include <compat/svr4/svr4_poll.h>
a55 2
static void svr4_pollscan __P((struct proc *, struct svr4_pollfd *, int,
			       register_t *));
a323 131
}


static void
svr4_pollscan(p, pl, nfd, retval)
	struct proc *p;
	struct svr4_pollfd *pl;
	int nfd;
	register_t *retval;
{
	register struct filedesc *fdp = p->p_fd;
	register int msk, i;
	struct file *fp;
	int n = 0;
	static int flag[3] = { FREAD, FWRITE, 0 };
	static int pflag[3] = { SVR4_POLLIN|SVR4_POLLRDNORM, 
				SVR4_POLLOUT, SVR4_POLLERR };

	/* 
	 * XXX: We need to implement the rest of the flags.
	 */
	for (i = 0; i < nfd; i++) {
		fp = fdp->fd_ofiles[pl[i].fd];
		if (fp == NULL) {
			if (pl[i].events & SVR4_POLLNVAL) {
			    pl[i].revents |= SVR4_POLLNVAL;
			    n++;
			}
			continue;
		}
		for (msk = 0; msk < 3; msk++) {
			if (pl[i].events & pflag[msk]) {
				if ((*fp->f_ops->fo_select)(fp, flag[msk], p)) {
					pl[i].revents |= 
						pflag[msk] & pl[i].events;
					n++;
				}
			}
		}
	}
	*retval = n;
}


/*
 * We are using the same mechanism as select only we encode/decode args
 * differently.
 */
int
svr4_sys_poll(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct svr4_sys_poll_args *uap = v;
	int i, s;
	int error, error2;
	size_t sz = sizeof(struct svr4_pollfd) * SCARG(uap, nfds);
	struct svr4_pollfd *pl;
	int msec = SCARG(uap, timeout);
	struct timeval atv;
	int timo;
	int ncoll;
	extern int nselcoll, selwait;

	pl = (struct svr4_pollfd *) malloc(sz, M_TEMP, M_WAITOK);

	if ((error = copyin(SCARG(uap, fds), pl, sz)) != 0)
		goto bad;

	for (i = 0; i < SCARG(uap, nfds); i++) {
		DPRINTF(("pollfd %d, %x\n", pl[i].fd, pl[i].events));
		pl[i].revents = 0;
	}

	if (msec != -1) {
		atv.tv_sec = msec / 1000;
		atv.tv_usec = (msec - (atv.tv_sec * 1000)) * 1000;

		if (itimerfix(&atv)) {
			error = EINVAL;
			goto done;
		}
		s = splclock();
		timeradd(&atv, &time, &atv);
		timo = hzto(&atv);
		/*
		 * Avoid inadvertently sleeping forever.
		 */
		if (timo == 0)
			timo = 1;
		splx(s);
	} else
		timo = 0;

retry:
	ncoll = nselcoll;
	p->p_flag |= P_SELECT;
	svr4_pollscan(p, pl, SCARG(uap, nfds), retval);
	if (*retval)
		goto done;
	s = splhigh();
	if (timo && timercmp(&time, &atv, >=)) {
		splx(s);
		goto done;
	}
	if ((p->p_flag & P_SELECT) == 0 || nselcoll != ncoll) {
		splx(s);
		goto retry;
	}
	p->p_flag &= ~P_SELECT;
	error = tsleep((caddr_t)&selwait, PSOCK | PCATCH, "svr4_poll", timo);
	splx(s);
	if (error == 0)
		goto retry;

done:
	p->p_flag &= ~P_SELECT;
	/* poll is not restarted after signals... */
	if (error == ERESTART)
		error = EINTR;
	if (error == EWOULDBLOCK)
		error = 0;

	if ((error2 = copyout(pl, SCARG(uap, fds), sz)) != 0)
		error = error2;

bad:
	free((char *) pl, M_TEMP);

	return (error);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: svr4_fcntl.c,v 1.13 1995/10/09 23:56:17 thorpej Exp $	 */
d51 8
d61 1
a61 1
	u_long cmd;
a62 1

d286 2
a287 1
		SCARG(&fa, arg) = (void *) svr4_to_bsd_flags(SCARG(uap, arg));
a387 1
	u_int ni;
d393 1
a393 1
	if (error = copyin(SCARG(uap, fds), pl, sz))
d450 1
a450 1
	if (error2 = copyout(pl, SCARG(uap, fds), sz))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
