head	1.27;
access;
symbols
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.16
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.12
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.10
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.8
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.6
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.16
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.8
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.6
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2011.04.05.12.50.15;	author guenther;	state dead;
branches;
next	1.26;

1.26
date	2009.12.15.20.26.21;	author jasper;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.25.15.01.53;	author sturm;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.14.20.01.50;	author sturm;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.30.14.20.07;	author sturm;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.19.11.55.55;	author pedro;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.30.10.35.07;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.09.23.52.02;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.15.20.32.15;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.23.15.39.31;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.49;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.13.21.32.03;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.13.19.08.06;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.12.18.41.20;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.26.12.03.27;	author art;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.02.03.02.45.31;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.01.19.14.23;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.10.27.07.32.55;	author niklas;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.05.31.17.34.44;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.06.17.11.11.07;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.08.02.20.34.45;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.08.48.26;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.04.47.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.13.04.06.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.13;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.04.21;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.03.06.02.07.07;	author niklas;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2002.03.28.11.28.05;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2004.02.19.10.51.28;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.28.07;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.29.00.30.51;	author art;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Push COMPAT_FREEBSD in front of a whale.  Buggy, out of date, no
one has been weeding it, and it makes life harder.

Toasts of Brennivin for its passing from many; diff ok henning@@
@
text
@/*	$OpenBSD: freebsd_file.c,v 1.26 2009/12/15 20:26:21 jasper Exp $	*/
/*	$NetBSD: freebsd_file.c,v 1.3 1996/05/03 17:03:09 christos Exp $	*/

/*
 * Copyright (c) 1995 Frank van der Linden
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project
 *      by Frank van der Linden
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	from: linux_file.c,v 1.3 1995/04/04 04:21:30 mycroft Exp
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/malloc.h>

#include <sys/syscallargs.h>

#include <compat/freebsd/freebsd_signal.h>
#include <compat/freebsd/freebsd_syscallargs.h>
#include <compat/freebsd/freebsd_util.h>

const char freebsd_emul_path[] = "/emul/freebsd";

static char * convert_from_freebsd_mount_type(int);
void statfs_to_freebsd_statfs(struct proc *, struct mount *, struct statfs *, struct freebsd_statfs *);

struct freebsd_statfs {
	long	f_spare2;		/* placeholder */
	long	f_bsize;		/* fundamental file system block size */
	long	f_iosize;		/* optimal transfer block size */
	long	f_blocks;		/* total data blocks in file system */
	long	f_bfree;		/* free blocks in fs */
	long	f_bavail;		/* free blocks avail to non-superuser */
	long	f_files;		/* total file nodes in file system */
	long	f_ffree;		/* free file nodes in fs */
	fsid_t	f_fsid;			/* file system id */
	uid_t	f_owner;		/* user that mounted the filesystem */
	int	f_type;			/* type of filesystem */
	int	f_flags;		/* copy of mount exported flags */
	long    f_syncwrites;		/* count of sync writes since mount */
	long    f_asyncwrites;		/* count of async writes since mount */
	char	f_fstypename[MFSNAMELEN]; /* fs type name */
	char	f_mntonname[MNAMELEN];	/* directory on which mounted */
	char	f_mntfromname[MNAMELEN];/* mounted filesystem */
};

static char *
convert_from_freebsd_mount_type(type)
	int type;
{
	static char *freebsd_mount_type[] = {
		NULL,     /*  0 = MOUNT_NONE */
		"ffs",	  /*  1 = "Fast" Filesystem */
		"nfs",	  /*  2 = Network Filesystem */
		"mfs",	  /*  3 = Memory Filesystem */
		"msdos",  /*  4 = MSDOS Filesystem */
		"lfs",	  /*  5 = Log-based Filesystem */
		"lofs",	  /*  6 = Loopback filesystem */
		"fdesc",  /*  7 = File Descriptor Filesystem */
		"portal", /*  8 = Portal Filesystem */
		"null",	  /*  9 = Minimal Filesystem Layer */
		"umap",	  /* 10 = User/Group Identifier Remapping Filesystem */
		"kernfs", /* 11 = Kernel Information Filesystem */
		"procfs", /* 12 = /proc Filesystem */
		"afs",	  /* 13 = Andrew Filesystem */
		"cd9660", /* 14 = ISO9660 (aka CDROM) Filesystem */
		"union",  /* 15 = Union (translucent) Filesystem */
		NULL,     /* 16 = "devfs" - existing device Filesystem */
#if 0 /* These filesystems don't exist in FreeBSD */
		"adosfs", /* ?? = AmigaDOS Filesystem */
#endif
	};

	if (type < 0 || type >= nitems(freebsd_mount_type))
		return (NULL);
	return (freebsd_mount_type[type]);
}

int
freebsd_sys_mount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_mount_args /* {
		syscallarg(int) type;
		syscallarg(char *) path;
		syscallarg(int) flags;
		syscallarg(caddr_t) data;
	} */ *uap = v;
	int error;
	char *type, *s;
	caddr_t sg = stackgap_init(p->p_emul);
	struct sys_mount_args bma;

	if ((type = convert_from_freebsd_mount_type(SCARG(uap, type))) == NULL)
		return ENODEV;
	s = stackgap_alloc(&sg, MFSNAMELEN + 1);
	if ((error = copyout(type, s, strlen(type) + 1)) != 0)
		return error;
	SCARG(&bma, type) = s;
	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	SCARG(&bma, path) = SCARG(uap, path);
	SCARG(&bma, flags) = SCARG(uap, flags);
	SCARG(&bma, data) = SCARG(uap, data);
	return sys_mount(p, &bma, retval);
}

/*
 * The following syscalls are only here because of the alternate path check.
 */

/* XXX - UNIX domain: int freebsd_sys_bind(int s, caddr_t name, int namelen); */
/* XXX - UNIX domain: int freebsd_sys_connect(int s, caddr_t name, int namelen); */


int
freebsd_sys_open(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_open_args /* {
		syscallarg(char *) path;
		syscallarg(int) flags;
		syscallarg(int) mode;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	if (SCARG(uap, flags) & O_CREAT)
		FREEBSD_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));
	else
		FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_open(p, uap, retval);
}

int
compat_43_freebsd_sys_creat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct compat_43_freebsd_sys_creat_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
	} */ *uap = v;
	caddr_t sg  = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));
	return compat_43_sys_creat(p, uap, retval);
}

int
freebsd_sys_link(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_link_args /* {
		syscallarg(char *) path;
		syscallarg(char *) link;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	FREEBSD_CHECK_ALT_CREAT(p, &sg, SCARG(uap, link));
	return sys_link(p, uap, retval);
}

int
freebsd_sys_unlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_unlink_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_unlink(p, uap, retval);
}

int
freebsd_sys_chdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_chdir_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_chdir(p, uap, retval);
}

int
freebsd_sys_mknod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_mknod_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
		syscallarg(int) dev;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));
	return sys_mknod(p, uap, retval);
}

int
freebsd_sys_chmod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_chmod_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_chmod(p, uap, retval);
}

int
freebsd_sys_chown(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_chown_args /* {
		syscallarg(char *) path;
		syscallarg(int) uid;
		syscallarg(int) gid;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_chown(p, uap, retval);
}

int
freebsd_sys_unmount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_unmount_args /* {
		syscallarg(char *) path;
		syscallarg(int) flags;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_unmount(p, uap, retval);
}

int
freebsd_sys_access(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_access_args /* {
		syscallarg(char *) path;
		syscallarg(int) flags;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_access(p, uap, retval);
}

int
freebsd_sys_chflags(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_chflags_args /* {
		syscallarg(char *) path;
		syscallarg(int) flags;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_chflags(p, uap, retval);
}

int
compat_43_freebsd_sys_stat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct compat_43_freebsd_sys_stat_args /* {
		syscallarg(char *) path;
		syscallarg(struct stat43 *) ub;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return compat_43_sys_stat(p, uap, retval);
}

int
compat_43_freebsd_sys_lstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct compat_43_freebsd_sys_lstat_args /* {
		syscallarg(char *) path;
		syscallarg(struct stat43 *) ub;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return compat_43_sys_lstat(p, uap, retval);
}

int
freebsd_sys_revoke(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_revoke_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_revoke(p, uap, retval);
}

int
freebsd_sys_symlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_symlink_args /* {
		syscallarg(char *) path;
		syscallarg(char *) link;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	FREEBSD_CHECK_ALT_CREAT(p, &sg, SCARG(uap, link));
	return sys_symlink(p, uap, retval);
}

int
freebsd_sys_readlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_readlink_args /* {
		syscallarg(char *) path;
		syscallarg(char *) buf;
		syscallarg(int) count;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_readlink(p, uap, retval);
}

int
freebsd_sys_execve(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_execve_args /* {
		syscallarg(char *) path;
		syscallarg(char **) argp;
		syscallarg(char **) envp;
	} */ *uap = v;
	struct sys_execve_args ap;
	caddr_t sg;

	sg = stackgap_init(p->p_emul);
	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&ap, path) = SCARG(uap, path);
	SCARG(&ap, argp) = SCARG(uap, argp);
	SCARG(&ap, envp) = SCARG(uap, envp);

	return sys_execve(p, &ap, retval);
}

int
freebsd_sys_chroot(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_chroot_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_chroot(p, uap, retval);
}

int
freebsd_sys_rename(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_rename_args /* {
		syscallarg(char *) from;
		syscallarg(char *) to;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, from));
	FREEBSD_CHECK_ALT_CREAT(p, &sg, SCARG(uap, to));
	return sys_rename(p, uap, retval);
}

int
compat_43_freebsd_sys_truncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct compat_43_freebsd_sys_truncate_args /* {
		syscallarg(char *) path;
		syscallarg(long) length;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return compat_43_sys_truncate(p, uap, retval);
}

int
freebsd_sys_mkfifo(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_mkfifo_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));
	return sys_mkfifo(p, uap, retval);
}

int
freebsd_sys_mkdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_mkdir_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));
	return sys_mkdir(p, uap, retval);
}

int
freebsd_sys_rmdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_rmdir_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_rmdir(p, uap, retval);
}

/*
 * Convert struct statfs -> struct freebsd_statfs
 */
void
statfs_to_freebsd_statfs(p, mp, sp, fsp)
	struct proc *p;
	struct mount *mp;
	struct statfs *sp;
	struct freebsd_statfs *fsp;
{
	fsp->f_bsize = sp->f_bsize;
	fsp->f_iosize = sp->f_iosize;
	fsp->f_blocks = sp->f_blocks;
	fsp->f_bfree = sp->f_bfree;
	fsp->f_bavail = sp->f_bavail;
	fsp->f_files = sp->f_files;
	fsp->f_ffree = sp->f_ffree;
	/* Don't let non-root see filesystem id (for NFS security) */
	if (suser(p, 0))
		fsp->f_fsid.val[0] = fsp->f_fsid.val[1] = 0;
	else
		bcopy(&sp->f_fsid, &fsp->f_fsid, sizeof(fsp->f_fsid));
	fsp->f_owner = sp->f_owner;
	fsp->f_type = mp->mnt_vfc->vfc_typenum;
	fsp->f_flags = sp->f_flags;
	fsp->f_syncwrites = sp->f_syncwrites;
	fsp->f_asyncwrites = sp->f_asyncwrites;
	bcopy(sp->f_fstypename, fsp->f_fstypename, MFSNAMELEN);
	bcopy(sp->f_mntonname, fsp->f_mntonname, MNAMELEN);
	bcopy(sp->f_mntfromname, fsp->f_mntfromname, MNAMELEN);
}

/*
 * Get filesystem statistics.
 */
/* ARGSUSED */
int
freebsd_sys_statfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct freebsd_sys_statfs_args /* {
		syscallarg(char *) path;
		syscallarg(struct freebsd_statfs *) buf;
	} */ *uap = v;
	register struct mount *mp;
	register struct statfs *sp;
	struct freebsd_statfs fsb;
	int error;
	struct nameidata nd;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	mp = nd.ni_vp->v_mount;
	sp = &mp->mnt_stat;
	vrele(nd.ni_vp);
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;

	statfs_to_freebsd_statfs(p, mp, sp, &fsb);
	return (copyout((caddr_t)&fsb, (caddr_t)SCARG(uap, buf), sizeof(fsb)));
}

/*
 * Get filesystem statistics.
 */
/* ARGSUSED */
int
freebsd_sys_fstatfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct freebsd_sys_fstatfs_args /* {
		syscallarg(int) fd;
		syscallarg(struct freebsd_statfs *) buf;
	} */ *uap = v;
	struct file *fp;
	struct mount *mp;
	register struct statfs *sp;
	struct freebsd_statfs fsb;
	int error;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	mp = ((struct vnode *)fp->f_data)->v_mount;
	sp = &mp->mnt_stat;
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp);
	if (error)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;

	statfs_to_freebsd_statfs(p, mp, sp, &fsb);
	return (copyout((caddr_t)&fsb, (caddr_t)SCARG(uap, buf), sizeof(fsb)));
}

/*
 * Get statistics on all filesystems.
 */
int
freebsd_sys_getfsstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct freebsd_sys_getfsstat_args /* {
		syscallarg(struct freebsd_statfs *) buf;
		syscallarg(long) bufsize;
		syscallarg(int) flags;
	} */ *uap = v;
	register struct mount *mp, *nmp;
	register struct statfs *sp;
	struct freebsd_statfs fsb;
	caddr_t sfsp;
	long count, maxcount;
	int error, flags = SCARG(uap, flags);

	maxcount = SCARG(uap, bufsize) / sizeof(struct freebsd_statfs);
	sfsp = (caddr_t)SCARG(uap, buf);
	count = 0;

	for (mp = CIRCLEQ_FIRST(&mountlist); mp != CIRCLEQ_END(&mountlist);
	    mp = nmp) {
		if (vfs_busy(mp, VB_READ|VB_NOWAIT)) {
			nmp = CIRCLEQ_NEXT(mp, mnt_list);
			continue;
		}
		if (sfsp && count < maxcount) {
			sp = &mp->mnt_stat;

			/* Refresh stats unless MNT_NOWAIT is specified */
			if (flags != MNT_NOWAIT &&
			    flags != MNT_LAZY &&
			    (flags == MNT_WAIT ||
			     flags == 0) &&
			    (error = VFS_STATFS(mp, sp, p))) {
				nmp = CIRCLEQ_NEXT(mp, mnt_list);
				vfs_unbusy(mp);
 				continue;
			}
			sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;

			statfs_to_freebsd_statfs(p, mp, sp, &fsb);
			error = copyout((caddr_t)&fsb, sfsp, sizeof(fsb));
			if (error) {
				vfs_unbusy(mp);
				return (error);
			}
			sfsp += sizeof(fsb);
		}
		count++;
		nmp = CIRCLEQ_NEXT(mp, mnt_list);
		vfs_unbusy(mp);
	}

	if (sfsp && count > maxcount)
		*retval = maxcount;
	else
		*retval = count;

	return (0);
}

#ifdef NFSCLIENT
int
freebsd_sys_getfh(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_getfh_args /* {
		syscallarg(char *) fname;
		syscallarg(fhandle_t *) fhp;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, fname));
	return sys_getfh(p, uap, retval);
}
#endif /* NFSCLIENT */

int
freebsd_sys_stat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_stat_args /* {
		syscallarg(char *) path;
		syscallarg(struct stat35 *) ub;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return compat_35_sys_stat(p, uap, retval);
}

int
freebsd_sys_lstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_lstat_args /* {
		syscallarg(char *) path;
		syscallarg(struct stat35 *) ub;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return compat_35_sys_lstat(p, uap, retval);
}

int
freebsd_sys_pathconf(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_pathconf_args /* {
		syscallarg(char *) path;
		syscallarg(int) name;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_pathconf(p, uap, retval);
}

int
freebsd_sys_truncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_truncate_args /* {
		syscallarg(char *) path;
		syscallarg(int) pad;
		syscallarg(off_t) length;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p->p_emul);

	FREEBSD_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	return sys_truncate(p, uap, retval);
}

/*
 * Just pass on everything to our fcntl, except for F_[GS]ETOWN on pipes,
 * where we translate to SIOC[GS]PGRP.
 */
int
freebsd_sys_fcntl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct freebsd_sys_fcntl_args /* {
		syscallarg(int) fd;
		syscallarg(int) cmd;
		syscallarg(void *) arg;
	} */ *uap = v;
	int fd, cmd, error;
	struct filedesc *fdp;
	struct file *fp;

	fd = SCARG(uap, fd);
	cmd = SCARG(uap, cmd);

	switch (cmd) {
	case F_GETOWN:
	case F_SETOWN:
		/* Our pipes does not understand F_[GS]ETOWN.  */ 
		fdp = p->p_fd;
		if ((fp = fd_getfile(fdp, fd)) == NULL)
			return (EBADF);
		if (fp->f_type == DTYPE_PIPE) {
			FREF(fp);
			error = (*fp->f_ops->fo_ioctl)(fp,
			    cmd == F_GETOWN ? SIOCGPGRP : SIOCSPGRP,
			    (caddr_t)&SCARG(uap, arg), p);
			FRELE(fp);
			return (error);
		}
		break;
	}

	return (sys_fcntl(p, uap, retval));
}

@


1.26
log
@- instead of rolling a macro that is functional equivalent to nitems(),
just use nitems(). (this leaves NENTS() alone for now)

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.25 2006/06/25 15:01:53 sturm Exp $	*/
@


1.25
log
@rename vfs_busy() flags VB_UMIGNORE/VB_UMWAIT to VB_NOWAIT/VB_WAIT

requested by and ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.24 2006/06/14 20:01:50 sturm Exp $	*/
a55 2
#define	ARRAY_LENGTH(array)	(sizeof(array)/sizeof(array[0]))

d108 1
a108 1
	if (type < 0 || type >= ARRAY_LENGTH(freebsd_mount_type))
@


1.24
log
@move vfs_busy() to rwlocks and properly hide the locking api from vfs

ok tedu, pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.23 2006/04/30 14:20:07 sturm Exp $	*/
d663 1
a663 1
		if (vfs_busy(mp, VB_READ|VB_UMIGNORE)) {
@


1.23
log
@remove the simplelock argument from vfs_busy() which is currently not
used and will never be used this way in VFS

requested by and ok pedro, ok krw, biorn
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.22 2006/04/19 11:55:55 pedro Exp $	*/
d663 1
a663 1
		if (vfs_busy(mp, LK_NOWAIT)) {
@


1.22
log
@Remove unused mount list simple_lock() goo
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.21 2006/03/05 21:48:56 miod Exp $	*/
d663 1
a663 1
		if (vfs_busy(mp, LK_NOWAIT, NULL)) {
@


1.21
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.20 2005/11/30 10:35:07 pedro Exp $	*/
d660 1
a660 1
	simple_lock(&mountlist_slock);
d663 1
a663 1
		if (vfs_busy(mp, LK_NOWAIT, &mountlist_slock)) {
a675 1
				simple_lock(&mountlist_slock);
a690 1
		simple_lock(&mountlist_slock);
d694 1
a694 1
	simple_unlock(&mountlist_slock);
d699 1
@


1.20
log
@No need for vfs_busy() and vfs_unbusy() to take a process pointer
anymore. Testing by jolan@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.19 2004/07/13 21:04:29 millert Exp $	*/
d661 2
a662 1
	for (mp = mountlist.cqh_first; mp != (void *)&mountlist; mp = nmp) {
d664 1
a664 1
			nmp = mp->mnt_list.cqe_next;
d677 1
a677 1
				nmp = mp->mnt_list.cqe_next;
d693 1
a693 1
		nmp = mp->mnt_list.cqe_next;
@


1.19
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.18 2004/07/09 23:52:02 millert Exp $	*/
d662 1
a662 1
		if (vfs_busy(mp, LK_NOWAIT, &mountlist_slock, p)) {
d677 1
a677 1
				vfs_unbusy(mp, p);
d685 1
a685 1
				vfs_unbusy(mp, p);
d693 1
a693 1
		vfs_unbusy(mp, p);
@


1.18
log
@Rename ostat -> stat43 to disambiguate from upcoming struct stat changes.
Idea from NetBSD, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.17 2003/08/15 20:32:15 tedu Exp $	*/
d729 1
a729 1
		syscallarg(struct stat *) ub;
d734 1
a734 1
	return sys_stat(p, uap, retval);
d745 1
a745 1
		syscallarg(struct stat *) ub;
d750 1
a750 1
	return sys_lstat(p, uap, retval);
@


1.17
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.16 2002/08/23 15:39:31 art Exp $	*/
d342 1
a342 1
		syscallarg(struct ostat *) ub;
d358 1
a358 1
		syscallarg(struct ostat *) ub;
@


1.16
log
@Cleanup change. Since almost all callers (except one) of getvnode did a FREF
on the returned file, do the FREF inside getvnode so that people can't
get away with avoiding FREF and FRELE.

Eyeballed by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.15 2002/03/14 01:26:49 millert Exp $	*/
d552 1
a552 1
	if (suser(p->p_ucred, &p->p_acflag))
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.14 2002/02/13 21:32:03 art Exp $	*/
a625 1
	FREF(fp);
@


1.14
log
@Ooops. unbreak after last.
noted by pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.13 2002/02/13 19:08:06 art Exp $	*/
d60 2
a61 2
static char * convert_from_freebsd_mount_type __P((int));
void statfs_to_freebsd_statfs __P((struct proc *, struct mount *, struct statfs *, struct freebsd_statfs *));
@


1.13
log
@More FREF/FRELE on relevant places. Now, only sys_mmap and a bunch of ioctl functions in sys/compat are left.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.12 2002/02/12 18:41:20 art Exp $	*/
d822 1
@


1.12
log
@More FREF/FRELE protection. This time all users of getvnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.11 2001/10/26 12:03:27 art Exp $	*/
d802 1
a802 1
	int fd, cmd;
d816 3
a818 2
		if (fp->f_type == DTYPE_PIPE)
			return ((*fp->f_ops->fo_ioctl)(fp,
d820 3
a822 1
			    (caddr_t)&SCARG(uap, arg), p));
@


1.11
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.10 2001/02/03 02:45:31 mickey Exp $	*/
d626 4
a629 1
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.11 2001/10/26 12:03:27 art Exp $	*/
d60 2
a61 2
static char * convert_from_freebsd_mount_type(int);
void statfs_to_freebsd_statfs(struct proc *, struct mount *, struct statfs *, struct freebsd_statfs *);
d626 1
a626 4
	FREF(fp);
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp);
	if (error)
d799 1
a799 1
	int fd, cmd, error;
d813 2
a814 3
		if (fp->f_type == DTYPE_PIPE) {
			FREF(fp);
			error = (*fp->f_ops->fo_ioctl)(fp,
d816 1
a816 4
			    (caddr_t)&SCARG(uap, arg), p);
			FRELE(fp);
			return (error);
		}
@


1.11.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.11.2.1 2002/06/11 03:28:07 art Exp $	*/
d626 1
@


1.10
log
@make it compile
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.9 2000/05/01 19:14:23 millert Exp $	*/
d811 1
a811 2
		if ((u_int)fd >= fdp->fd_nfiles ||
		    (fp = fdp->fd_ofiles[fd]) == NULL)
@


1.9
log
@s/netbsd_mount_type/freebsd_mount_type/g
Cosmetic only; theo@@ ok'd
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.8 1999/10/27 07:32:55 niklas Exp $	*/
d52 1
@


1.8
log
@Provide FreeBSD fcntl emulation that handles F[GS]ETOWN on pipes.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.7 1999/05/31 17:34:44 millert Exp $	*/
d86 1
a86 1
	static char *netbsd_mount_type[] = {
d109 1
a109 1
	if (type < 0 || type >= ARRAY_LENGTH(netbsd_mount_type))
d111 1
a111 1
	return (netbsd_mount_type[type]);
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.10 2001/02/03 02:45:31 mickey Exp $	*/
a51 1
#include <compat/freebsd/freebsd_signal.h>
d86 1
a86 1
	static char *freebsd_mount_type[] = {
d109 1
a109 1
	if (type < 0 || type >= ARRAY_LENGTH(freebsd_mount_type))
d111 1
a111 1
	return (freebsd_mount_type[type]);
@


1.8.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.8.2.1 2001/05/14 22:04:21 niklas Exp $	*/
d811 2
a812 1
		if ((fp = fd_getfile(fdp, fd)) == NULL)
@


1.8.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d626 1
a626 4
	FREF(fp);
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp);
	if (error)
d799 1
a799 1
	int fd, cmd, error;
d813 2
a814 3
		if (fp->f_type == DTYPE_PIPE) {
			FREF(fp);
			error = (*fp->f_ops->fo_ioctl)(fp,
d816 1
a816 4
			    (caddr_t)&SCARG(uap, arg), p);
			FRELE(fp);
			return (error);
		}
@


1.8.2.4
log
@Merge in -current from about a week ago
@
text
@d60 2
a61 2
static char * convert_from_freebsd_mount_type(int);
void statfs_to_freebsd_statfs(struct proc *, struct mount *, struct statfs *, struct freebsd_statfs *);
@


1.8.2.5
log
@Sync the SMP branch with 3.3
@
text
@d626 1
@


1.8.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d552 1
a552 1
	if (suser(p, 0))
@


1.7
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.6 1997/06/17 11:11:07 deraadt Exp $	*/
d782 41
@


1.6
log
@careful with stackgap handling in execve()
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.5 1996/08/02 20:34:45 niklas Exp $	*/
d46 1
d60 21
d533 36
d575 1
a575 1
	struct freebsd_sys_stat_args /* {
d577 1
a577 1
		syscallarg(struct statfs *) buf;
d579 5
d587 111
a697 1
	return sys_statfs(p, uap, retval);
@


1.5
log
@Added Makefiles to build stuff from syscalls.master in some emulations.
Regenerated derived files from various syscalls.master files. Added $OpenBSD$.
@
text
@d1 1
a1 1
/*	$OpenBSD: freebsd_file.c,v 1.3 1996/05/03 17:03:09 christos Exp $	*/
d403 2
a404 1
	caddr_t sg = stackgap_init(p->p_emul);
d406 1
d408 6
a413 1
	return sys_execve(p, uap, retval);
@


1.4
log
@sync with 0504; mostly proto changes (some svr4 ioctl changes)
@
text
@d1 1
@


1.3
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: freebsd_file.c,v 1.2 1995/11/07 22:27:21 gwr Exp $	*/
d57 2
d111 1
a111 1
	if (error = copyout(type, s, strlen(type) + 1))
@


1.2
log
@ufs ==> ffs
@
text
@d1 1
a1 1
/*	$NetBSD: freebsd_file.c,v 1.1 1995/10/10 01:19:30 mycroft Exp $	*/
@


1.1
log
@Initial revision
@
text
@d63 1
a63 1
		"ufs",	  /*  1 = UNIX "Fast" Filesystem */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
