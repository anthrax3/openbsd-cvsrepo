head	1.19;
access;
symbols
	OPENBSD_5_9:1.18.0.6
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.8
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.14.0.6
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.4
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.2
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.4
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.6.0.8
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.4
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.14
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.12
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.10
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.12
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.10
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.8
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.2
	UBC_BASE:1.3
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.19
date	2016.03.02.15.41.48;	author naddy;	state dead;
branches;
next	1.18;
commitid	ZfNt0OHZhMg52abA;

1.18
date	2014.07.09.14.42.53;	author guenther;	state Exp;
branches;
next	1.17;
commitid	bOqnAamLHtyhMfNP;

1.17
date	2014.03.30.21.54.49;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2014.02.12.05.47.36;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2014.01.20.21.19.28;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2012.05.25.04.39.40;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2012.05.24.01.19.16;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2012.04.12.15.42.52;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2011.08.03.16.11.31;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2011.04.05.15.44.40;	author pirofti;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.04.23.24.58;	author pirofti;	state Exp;
branches;
next	1.8;

1.8
date	2010.01.04.19.27.21;	author guenther;	state Exp;
branches;
next	1.7;

1.7
date	2009.12.28.02.54.24;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.26.05.42.14;	author ray;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.23.19.08.52;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.13.21.49.23;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.15.09.34.44;	author jasoni;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.02.21.43.11;	author niklas;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.05.14.22.04.48;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.07.04.10.39.25;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.06.05.17.19.55;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.19
log
@remove the Linux emulation code, no longer referenced by anything
@
text
@/*	$OpenBSD: linux_sched.c,v 1.18 2014/07/09 14:42:53 guenther Exp $	*/
/*	$NetBSD: linux_sched.c,v 1.6 2000/05/28 05:49:05 thorpej Exp $	*/

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center; by Matthias Scheler.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Linux compatibility module. Try to deal with scheduler related syscalls.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/syscallargs.h>
#include <sys/signalvar.h>

#include <machine/cpu.h>
#include <machine/pcb.h>
#include <machine/linux_machdep.h>

#include <compat/linux/linux_emuldata.h>
#include <compat/linux/linux_types.h>
#include <compat/linux/linux_sched.h>
#include <compat/linux/linux_signal.h>
#include <compat/linux/linux_syscallargs.h>

void linux_child_return(void *);

int
linux_sys_clone(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_clone_args *uap = v;
	struct linux_emuldata *emul = p->p_emuldata;
	int cflags = SCARG(uap, flags);
	int flags = FORK_TFORK;
	int error = 0;

	/*
	 * We only support certain bits.  The Linux crew keep adding more,
	 * so let's test for anything outside of what we support and complain
	 * about them.  Not everything in this list is completely supported,
	 * they just aren't _always_ an error.
	 */
	if (cflags & ~(LINUX_CLONE_CSIGNAL | LINUX_CLONE_VM | LINUX_CLONE_FS |
	    LINUX_CLONE_FILES | LINUX_CLONE_SIGHAND | LINUX_CLONE_VFORK |
	    LINUX_CLONE_PARENT | LINUX_CLONE_THREAD | LINUX_CLONE_SYSVSEM |
	    LINUX_CLONE_DETACHED | LINUX_CLONE_UNTRACED | LINUX_CLONE_SETTLS |
	    LINUX_CLONE_PARENT_SETTID | LINUX_CLONE_CHILD_CLEARTID |
	    LINUX_CLONE_CHILD_SETTID))
		return (EINVAL);

	if (cflags & LINUX_CLONE_VM)
		flags |= FORK_SHAREVM;
	if (cflags & LINUX_CLONE_FILES)
		flags |= FORK_SHAREFILES;
	if (cflags & LINUX_CLONE_SIGHAND) {
		/* According to Linux, CLONE_SIGHAND requires CLONE_VM */
		if ((cflags & LINUX_CLONE_VM) == 0)
			return (EINVAL);
		flags |= FORK_SIGHAND;
	}
	if (cflags & LINUX_CLONE_VFORK)
		flags |= FORK_PPWAIT;
	if (cflags & LINUX_CLONE_THREAD) {
		/*
		 * Linux agrees with us: CLONE_THREAD requires
		 * CLONE_SIGHAND.  Unlike Linux, we also also require
		 * CLONE_FS and CLONE_SYSVSEM.  Also, we decree it
		 * to be incompatible with CLONE_VFORK, as I don't
		 * want to work out whether that's 100% safe.
		 * Requires CLONE_FILES so that the rest of the kernel
		 * can assume that threads share an fd table.
		 */
#define REQUIRED	\
	( LINUX_CLONE_SIGHAND \
	| LINUX_CLONE_FS \
	| LINUX_CLONE_SYSVSEM \
	| LINUX_CLONE_FILES \
	)
#define BANNED		\
	LINUX_CLONE_VFORK
		if ((cflags & (REQUIRED | BANNED)) != REQUIRED)
			return (EINVAL);
		flags |= FORK_THREAD;
	} else {
		/*
		 * These are only supported with CLONE_THREAD.  Arguably,
		 * CLONE_FS should be in this list, because we don't
		 * support sharing of working directory and root directory
		 * (chdir + chroot) except via threads.  On the other
		 * hand, we tie the sharing of umask to the sharing of
		 * files, so a process that doesn't request CLONE_FS but
		 * does ask for CLONE_FILES is going to get some of the
		 * former's effect.  Some programs (e.g., Opera) at least
		 * _seem_ to work if we let it through, so we'll just
		 * cross our fingers for now and silently ignore it if
		 * CLONE_FILES was also requested.
		 */
		if (cflags & (LINUX_CLONE_PARENT | LINUX_CLONE_SYSVSEM))
			return (EINVAL);
		if ((cflags & (LINUX_CLONE_FS | LINUX_CLONE_FILES)) ==
		    LINUX_CLONE_FS)
			return (EINVAL);

		/* We don't support alternate exit signals. */
		if ((cflags & LINUX_CLONE_CSIGNAL) != LINUX_SIGCHLD)
			return (EINVAL);
	}
	/*
	 * Since we don't support CLONE_PTRACE, the CLONE_UNTRACED
	 * flag can be silently ignored.  CLONE_DETACHED is always
	 * ignored by Linux.
	 */
	if (cflags & LINUX_CLONE_CHILD_SETTID)
		emul->child_set_tid = SCARG(uap, child_tidptr);
	else
		emul->child_set_tid = NULL;

	if (cflags & LINUX_CLONE_CHILD_CLEARTID)
		emul->child_clear_tid = SCARG(uap, child_tidptr);
	else
		emul->child_clear_tid = NULL;

	if (cflags & LINUX_CLONE_PARENT_SETTID)
		if (SCARG(uap, parent_tidptr) == NULL)
			return (EINVAL);

	if (cflags & LINUX_CLONE_SETTLS) {
		struct l_segment_descriptor ldesc;

		error = copyin(SCARG(uap, tls), &ldesc, sizeof(ldesc));
		if (error)
			return (error);

		if (ldesc.entry_number != GUGS_SEL)
			return (EINVAL);
		emul->child_tls_base = ldesc.base_addr;
		emul->set_tls_base = 1;
	}
	else
		emul->set_tls_base = 0;

	error = fork1(p, flags, SCARG(uap, stack), 0, linux_child_return,
	    NULL, retval, NULL);
	if (error)
		return error;

	if (cflags & LINUX_CLONE_PARENT_SETTID) {
		pid_t pid = retval[0];

		error = copyout(&pid, SCARG(uap, parent_tidptr), sizeof(pid));
	}
	return (error);
}

int
linux_sys_sched_setparam(struct proc *cp, void *v, register_t *retval)
{
	struct linux_sys_sched_setparam_args /* {
		syscallarg(linux_pid_t) pid;
		syscallarg(const struct linux_sched_param *) sp;
	} */ *uap = v;
	int error;
	struct linux_sched_param lp;
	struct proc *p;

	/*
	 * We only check for valid parameters and return afterwards.
	 */

	if (SCARG(uap, pid) < 0 || SCARG(uap, sp) == NULL)
		return (EINVAL);

	error = copyin(SCARG(uap, sp), &lp, sizeof(lp));
	if (error)
		return (error);

	if (SCARG(uap, pid) != 0) {
		struct ucred *uc = cp->p_ucred;

		if ((p = pfind(SCARG(uap, pid))) == NULL)
			return (ESRCH);
		if (!(cp == p ||
		      uc->cr_uid == 0 ||
		      uc->cr_ruid == p->p_ucred->cr_ruid ||
		      uc->cr_uid == p->p_ucred->cr_ruid ||
		      uc->cr_ruid == p->p_ucred->cr_uid ||
		      uc->cr_uid == p->p_ucred->cr_uid))
			return (EPERM);
	}

	return (0);
}

int
linux_sys_sched_getparam(struct proc *cp, void *v, register_t *retval)
{
	struct linux_sys_sched_getparam_args /* {
		syscallarg(linux_pid_t) pid;
		syscallarg(struct linux_sched_param *) sp;
	} */ *uap = v;
	struct proc *p;
	struct linux_sched_param lp;

	/*
	 * We only check for valid parameters and return a dummy priority
	 * afterwards.
	 */
	if (SCARG(uap, pid) < 0 || SCARG(uap, sp) == NULL)
		return (EINVAL);

	if (SCARG(uap, pid) != 0) {
		struct ucred *uc = cp->p_ucred;

		if ((p = pfind(SCARG(uap, pid))) == NULL)
			return (ESRCH);
		if (!(cp == p ||
		      uc->cr_uid == 0 ||
		      uc->cr_ruid == p->p_ucred->cr_ruid ||
		      uc->cr_uid == p->p_ucred->cr_ruid ||
		      uc->cr_ruid == p->p_ucred->cr_uid ||
		      uc->cr_uid == p->p_ucred->cr_uid))
			return (EPERM);
	}

	lp.sched_priority = 0;
	return (copyout(&lp, SCARG(uap, sp), sizeof lp));
}

int
linux_sys_sched_setscheduler(struct proc *cp, void *v, register_t *retval)
{
	struct linux_sys_sched_setscheduler_args /* {
		syscallarg(linux_pid_t) pid;
		syscallarg(int) policy;
		syscallarg(cont struct linux_sched_scheduler *) sp;
	} */ *uap = v;
	int error;
	struct linux_sched_param lp;
	struct proc *p;

	/*
	 * We only check for valid parameters and return afterwards.
	 */

	if (SCARG(uap, pid) < 0 || SCARG(uap, sp) == NULL)
		return (EINVAL);

	error = copyin(SCARG(uap, sp), &lp, sizeof(lp));
	if (error)
		return (error);

	if (SCARG(uap, pid) != 0) {
		struct ucred *uc = cp->p_ucred;

		if ((p = pfind(SCARG(uap, pid))) == NULL)
			return (ESRCH);
		if (!(cp == p ||
		      uc->cr_uid == 0 ||
		      uc->cr_ruid == p->p_ucred->cr_ruid ||
		      uc->cr_uid == p->p_ucred->cr_ruid ||
		      uc->cr_ruid == p->p_ucred->cr_uid ||
		      uc->cr_uid == p->p_ucred->cr_uid))
			return (EPERM);
	}

	/*
	 * We can't emulate anything but the default scheduling policy.
	 */
	if (SCARG(uap, policy) != LINUX_SCHED_OTHER || lp.sched_priority != 0)
		return (EINVAL);

	return (0);
}

int
linux_sys_sched_getscheduler(struct proc *cp, void *v, register_t *retval)
{
	struct linux_sys_sched_getscheduler_args /* {
		syscallarg(linux_pid_t) pid;
	} */ *uap = v;
	struct proc *p;

	*retval = -1;

	/*
	 * We only check for valid parameters and return afterwards.
	 */

	if (SCARG(uap, pid) != 0) {
		struct ucred *uc = cp->p_ucred;

		if ((p = pfind(SCARG(uap, pid))) == NULL)
			return (ESRCH);
		if (!(cp == p ||
		      uc->cr_uid == 0 ||
		      uc->cr_ruid == p->p_ucred->cr_ruid ||
		      uc->cr_uid == p->p_ucred->cr_ruid ||
		      uc->cr_ruid == p->p_ucred->cr_uid ||
		      uc->cr_uid == p->p_ucred->cr_uid))
			return (EPERM);
	}

	/*
	 * We can't emulate anything but the default scheduling policy.
	 */
	*retval = LINUX_SCHED_OTHER;
	return (0);
}

int
linux_sys_sched_yield(struct proc *cp, void *v, register_t *retval)
{
	need_resched(curcpu());
	return (0);
}

int
linux_sys_sched_get_priority_max(struct proc *cp, void *v, register_t *retval)
{
	struct linux_sys_sched_get_priority_max_args /* {
		syscallarg(int) policy;
	} */ *uap = v;

	/*
	 * We can't emulate anything but the default scheduling policy.
	 */
	if (SCARG(uap, policy) != LINUX_SCHED_OTHER) {
		*retval = -1;
		return (EINVAL);
	}

	*retval = 0;
	return (0);
}

int
linux_sys_sched_get_priority_min(struct proc *cp, void *v, register_t *retval)
{
	struct linux_sys_sched_get_priority_min_args /* {
		syscallarg(int) policy;
	} */ *uap = v;

	/*
	 * We can't emulate anything but the default scheduling policy.
	 */
	if (SCARG(uap, policy) != LINUX_SCHED_OTHER) {
		*retval = -1;
		return (EINVAL);
	}

	*retval = 0;
	return (0);
}

int
linux_sys_set_tid_address(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_set_tid_address_args *uap = v;
	struct linux_emuldata *emul = p->p_emuldata;

	emul->my_clear_tid = SCARG(uap, tidptr);

	*retval = p->p_p->ps_pid;
	return 0;
}

void
linux_child_return(void *arg)
{
	struct proc *p = (struct proc *)arg;
	struct linux_emuldata *emul = p->p_emuldata;

	if (emul->set_tls_base)
		i386_set_threadbase(p, emul->my_tls_base, TSEG_GS);

	if (emul->my_set_tid) {
		pid_t pid = p->p_pid + THREAD_PID_OFFSET;

		if (copyout(&pid, emul->my_set_tid, sizeof(pid)))
			psignal(p, SIGSEGV);
	}

	child_return(p);
}
@


1.18
log
@Delete an obsolete comment
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.17 2014/03/30 21:54:49 guenther Exp $	*/
@


1.17
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.16 2014/02/12 05:47:36 guenther Exp $	*/
a171 6
	/*
	 * Note that Linux does not provide a portable way of specifying
	 * the stack area; the caller must know if the stack grows up
	 * or down.  So, we pass a stack size of 0, so that the code
	 * that makes this adjustment is a noop.
	 */
@


1.16
log
@Eliminate the exit sig handling, which was only invokable via the
Linux-compat clone() syscall when *not* using CLONE_THREAD.  pirofti@@
confirms Opera runs in compat without this, so out it goes; one less hair
to choke on in kern_exit.c

ok tedu@@ pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.15 2014/01/20 21:19:28 guenther Exp $	*/
d214 1
a214 1
		struct pcred *pc = cp->p_cred;
d219 5
a223 5
		      pc->pc_ucred->cr_uid == 0 ||
		      pc->p_ruid == p->p_cred->p_ruid ||
		      pc->pc_ucred->cr_uid == p->p_cred->p_ruid ||
		      pc->p_ruid == p->p_ucred->cr_uid ||
		      pc->pc_ucred->cr_uid == p->p_ucred->cr_uid))
d248 1
a248 1
		struct pcred *pc = cp->p_cred;
d253 5
a257 5
		      pc->pc_ucred->cr_uid == 0 ||
		      pc->p_ruid == p->p_cred->p_ruid ||
		      pc->pc_ucred->cr_uid == p->p_cred->p_ruid ||
		      pc->p_ruid == p->p_ucred->cr_uid ||
		      pc->pc_ucred->cr_uid == p->p_ucred->cr_uid))
d289 1
a289 1
		struct pcred *pc = cp->p_cred;
d294 5
a298 5
		      pc->pc_ucred->cr_uid == 0 ||
		      pc->p_ruid == p->p_cred->p_ruid ||
		      pc->pc_ucred->cr_uid == p->p_cred->p_ruid ||
		      pc->p_ruid == p->p_ucred->cr_uid ||
		      pc->pc_ucred->cr_uid == p->p_ucred->cr_uid))
d326 1
a326 1
		struct pcred *pc = cp->p_cred;
d331 5
a335 5
		      pc->pc_ucred->cr_uid == 0 ||
		      pc->p_ruid == p->p_cred->p_ruid ||
		      pc->pc_ucred->cr_uid == p->p_cred->p_ruid ||
		      pc->p_ruid == p->p_ucred->cr_uid ||
		      pc->pc_ucred->cr_uid == p->p_ucred->cr_uid))
@


1.15
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.14 2012/05/25 04:39:40 guenther Exp $	*/
d64 1
a64 1
	int flags = FORK_TFORK, sig;
d133 4
a142 6

	sig = cflags & LINUX_CLONE_CSIGNAL;
	if (sig < 0 || sig >= LINUX__NSIG)
		return (EINVAL);
	sig = linux_to_bsd_sig[sig];

d178 1
a178 1
	error = fork1(p, sig, flags, SCARG(uap, stack), 0, linux_child_return,
@


1.14
log
@Change the KERN_FILE_BYPID and KERN_FILE_BYUID modes of the KERN_FILE2
sysctl() to be per-process instead of per-thread.  This means the
filedesc table has to really be per-process instead of per-thread,
so make it an error for the linux clone() emulation to try to do
otherwise.  This removes pointless duplication in fstat's output.

requested by jsing@@ and deraadt@@, ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.13 2012/05/24 01:19:16 guenther Exp $	*/
d113 1
a113 7
		/*
		 * Linux says that CLONE_THREAD means no signal
		 * will be sent on exit (even if a non-standard
		 * signal is requested via CLONE_CSIGNAL), so pass
		 * FORK_NOZOMBIE too.
		 */
		flags |= FORK_THREAD | FORK_NOZOMBIE;
@


1.13
log
@If LINUX_CLONE_SETTLS isn't set, then the clone()d child should inherit
the TCB value from the parent instead of having it zeroed.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.12 2012/04/12 15:42:52 guenther Exp $	*/
d100 2
d104 5
a108 1
	(LINUX_CLONE_SIGHAND | LINUX_CLONE_FS | LINUX_CLONE_SYSVSEM)
@


1.12
log
@rfork cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.11 2011/08/03 16:11:31 guenther Exp $	*/
d169 1
d172 1
a172 1
		emul->child_tls_base = 0;
d411 2
a412 1
	i386_set_threadbase(p, emul->my_tls_base, TSEG_GS);
@


1.11
log
@Fix linux compat breakage: can't copyin() from kernel-space, so
move that out of i386_set_threadbase(), and have clone() pass NULL
to fork1() for the child func argument so that it gets the child
proc pointer.

Report and verification by pirofti@@, heavy lifting by matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.10 2011/04/05 15:44:40 pirofti Exp $	*/
d64 1
a64 1
	int flags = FORK_RFORK, sig;
@


1.10
log
@Add set_tid_address() syscall. Lots of help from and okay guenther@@.

This is more than a simple syscall.This expands TLS support quite a bit.
Also linux_sys_clone() handles CLONE_CHILD_CLEARTID, CLONE_CHILD_SETTID,
CLONE_PARENT_SETTID flags as well as the CLONE_SETTLS by doing what
set_thread_area() is doing.

Next on the list is futex support which should allow compat to cope with
newer Linux kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.9 2011/04/04 23:24:58 pirofti Exp $	*/
d180 1
a180 1
	    p, retval, NULL);
d410 1
a410 2
	if (i386_set_threadbase(p, &emul->my_tls_base, TSEG_GS))
		return;
@


1.9
log
@Fix function argument list -- 1989 is long gone!
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.8 2010/01/04 19:27:21 guenther Exp $	*/
d44 1
d47 2
d50 1
d56 2
d61 2
a62 4
	struct linux_sys_clone_args /* {
		syscallarg(int) flags;
		syscallarg(void *) stack;
	} */ *uap = v;
d65 1
a71 2
	 * To make nptl threads work we need to add support for at least
	 * CLONE_SETTLS, CLONE_PARENT_SETTID, and CLONE_CHILD_CLEARTID.
d76 3
a78 1
	    LINUX_CLONE_DETACHED | LINUX_CLONE_UNTRACED))
d145 28
d179 11
a189 2
	return (fork1(p, sig, flags, SCARG(uap, stack), 0, NULL, NULL, retval,
	    NULL));
d390 31
@


1.8
log
@Previous commit was too restrictive: just ignore the CLONE_FS flag
when not doing CLONE_THREAD, like we did before, instead of treating
it as an error.  This unbreaks Opera running in linux compat.

Also, Linux completely ignores CLONE_DETACHED, so do that too, and
consistently refer to the flags in comment via their Linux names
without trying to abbreviate them further.

Problem found and fix confirmed by sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.7 2009/12/28 02:54:24 guenther Exp $	*/
d53 1
a53 4
linux_sys_clone(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d151 1
a151 4
linux_sys_sched_setparam(cp, v, retval)
	struct proc *cp;
	void *v;
	register_t *retval;
d190 1
a190 4
linux_sys_sched_getparam(cp, v, retval)
	struct proc *cp;
	void *v;
	register_t *retval;
d225 1
a225 4
linux_sys_sched_setscheduler(cp, v, retval)
	struct proc *cp;
	void *v;
	register_t *retval;
d271 1
a271 4
linux_sys_sched_getscheduler(cp, v, retval)
	struct proc *cp;
	void *v;
	register_t *retval;
d306 1
a306 4
linux_sys_sched_yield(cp, v, retval)
	struct proc *cp;
	void *v;
	register_t *retval;
d313 1
a313 4
linux_sys_sched_get_priority_max(cp, v, retval)
	struct proc *cp;
	void *v;
	register_t *retval;
d332 1
a332 4
linux_sys_sched_get_priority_min(cp, v, retval)
	struct proc *cp;
	void *v;
	register_t *retval;
@


1.7
log
@Sanity check flags in fork1(), banning some combos we don't support
and catching FORK_THREAD when RTHREADS wasn't compiled in.  Simplify
sys_rfork() based on that.

Flesh out the Linux clone support with more flags, but stricter
checks for missing support or bad combos.  Still not enough for
NPTL to work, mind you.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.6 2008/06/26 05:42:14 ray Exp $	*/
d76 1
a76 1
	    LINUX_CLONE_UNTRACED))
d84 1
a84 1
		/* According to Linux, SIGHAND requires VM */
d93 5
a97 4
		 * Linux agrees with us: THREAD requires SIGHAND.
		 * Unlike Linux, we also also require FS and SYSVSEM.
		 * Also, we decree it to be incompatible with VFORK, as
		 * I don't want to work out whether that's 100% safe.
d106 3
a108 3
		 * Linux says that THREAD means no signal will be
		 * sent on exit (even if a non-standard signal is
		 * requested via LINUX_CLONE_CSIGNAL), so pass
d113 17
a129 3
		/* only supported with THREAD */
		if (cflags & (LINUX_CLONE_FS | LINUX_CLONE_PARENT |
		    LINUX_CLONE_SYSVSEM))
d134 2
a135 1
	 * flag can be silently ignored.
@


1.6
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.5 2004/11/23 19:08:52 miod Exp $	*/
d62 1
d66 6
a71 1
	 * We don't support the Linux CLONE_PID or CLONE_PTRACE flags.
d73 4
a76 1
	if (SCARG(uap, flags) & (LINUX_CLONE_PID | LINUX_CLONE_PTRACE))
d79 1
a79 1
	if (SCARG(uap, flags) & LINUX_CLONE_VM)
d81 1
a81 2
	/* XXX We pretend to support CLONE_FS for the moment.  */
	if (SCARG(uap, flags) & LINUX_CLONE_FILES)
d83 4
a86 1
	if (SCARG(uap, flags) & LINUX_CLONE_SIGHAND)
d88 2
a89 1
	if (SCARG(uap, flags) & LINUX_CLONE_VFORK) {
d91 25
d117 4
d122 1
a122 1
	sig = SCARG(uap, flags) & LINUX_CLONE_CSIGNAL;
@


1.5
log
@Create the init process earlier, before the root filesystem is mounted,
and have it stall on a semaphore. This allows all kthread creations which
could have been requested during autoconf to be processed before root
is mounted as well.

This causes umass devices attached to any usb with flags 1 (such as on macppc)
to configure properly instead of panicing the kernel at mountroot time.

From NetBSD; tested by various.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.4 2004/06/13 21:49:23 niklas Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.4
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d99 2
a100 1
	return (fork1(p, sig, flags, SCARG(uap, stack), 0, NULL, NULL, retval));
@


1.3
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.2 2001/05/15 09:34:44 jasoni Exp $	*/
d275 1
a275 1
	need_resched();
@


1.2
log
@typos
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.1 2001/04/02 21:43:11 niklas Exp $	*/
d99 1
a99 1
	return (fork1(p, sig, flags, SCARG(uap, stack), 0, retval));
@


1.1
log
@On popular demand, the Linux-compatibility clone(2) implementation based
on NetBSD's code, as well as some faked Posix RT extensions by me.  This makes
at least simple linuxthreads tests work.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.6 2000/05/28 05:49:05 thorpej Exp $	*/
d223 1
a223 1
	 * We can't emulate anything put the default scheduling policy.
d263 1
a263 1
	 * We can't emulate anything put the default scheduling policy.
d290 1
a290 1
	 * We can't emulate anything put the default scheduling policy.
d312 1
a312 1
	 * We can't emulate anything put the default scheduling policy.
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.1 2001/04/02 21:43:11 niklas Exp $	*/
@


1.1.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.1.4.1 2001/05/14 22:04:48 niklas Exp $	*/
d223 1
a223 1
	 * We can't emulate anything but the default scheduling policy.
d263 1
a263 1
	 * We can't emulate anything but the default scheduling policy.
d290 1
a290 1
	 * We can't emulate anything but the default scheduling policy.
d312 1
a312 1
	 * We can't emulate anything but the default scheduling policy.
@


1.1.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d99 1
a99 1
	return (fork1(p, sig, flags, SCARG(uap, stack), 0, NULL, NULL, retval));
@


1.1.4.4
log
@Make a few scheduling globals per-cpu, mostly NetBSD code
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_sched.c,v 1.1.4.3 2001/11/13 21:05:48 niklas Exp $	*/
d275 1
a275 1
	need_resched(curcpu());
@


