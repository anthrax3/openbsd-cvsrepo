head	1.44;
access;
symbols
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.37.0.4
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.2
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.2
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.31.0.8
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.6
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.4
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.30.0.4
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.2
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.25.0.8
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.6
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.4
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.23.0.6
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.6
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.4
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.20
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.13.0.6
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.13.0.4
	OPENBSD_2_7_BASE:1.13
	SMP:1.13.0.2
	SMP_BASE:1.13
	kame_19991208:1.13
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2016.03.02.15.41.48;	author naddy;	state dead;
branches;
next	1.43;
commitid	ZfNt0OHZhMg52abA;

1.43
date	2015.05.05.02.13.47;	author guenther;	state Exp;
branches;
next	1.42;
commitid	dNPv28CJI5BxtRGW;

1.42
date	2014.07.12.18.50.00;	author tedu;	state Exp;
branches;
next	1.41;
commitid	C8XZQyreqTUCeixA;

1.41
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2013.12.02.19.47.28;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2013.12.02.19.47.04;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2013.11.03.13.52.44;	author pirofti;	state Exp;
branches;
next	1.37;

1.37
date	2012.09.11.15.44.19;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2012.06.20.11.37.21;	author pirofti;	state Exp;
branches;
next	1.35;

1.35
date	2011.09.18.02.23.18;	author pirofti;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.20.19.14.34;	author pirofti;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.05.15.44.40;	author pirofti;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.05.01.41.03;	author pirofti;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.05.19.52.24;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.26.05.42.14;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.12.22.04.55;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.12.04.32.59;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.30.12.09.22;	author gilles;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.01.15.14.44;	author martin;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.19.17.54.52;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.30.19.46.55;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.15.00.22.42;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.21.18.56.07;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.21.00.42.58;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.26.50;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.15.06.22.30;	author art;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.19.13.28.43;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.11.23.21.14;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.01.21.30.33;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.10.15.33.09;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	99.11.26.16.44.28;	author art;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	99.11.10.15.55.22;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	99.09.10.20.27.40;	author art;	state Exp;
branches;
next	1.10;

1.10
date	99.02.10.08.07.20;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	99.01.11.05.12.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.07.28.00.13.23;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.03.06.22.14.01;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	98.02.22.01.07.56;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.06.17.11.11.10;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.12.23.02.56.49;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.31.09.24.02;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	96.04.17.05.23.46;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.18;	author deraadt;	state Exp;
branches;
next	;

1.13.2.1
date	2001.05.14.22.04.37;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2001.12.05.00.43.28;	author niklas;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	1.13.2.7;

1.13.2.7
date	2004.06.05.23.12.34;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.44
log
@remove the Linux emulation code, no longer referenced by anything
@
text
@/*	$OpenBSD: linux_exec.c,v 1.43 2015/05/05 02:13:47 guenther Exp $	*/
/*	$NetBSD: linux_exec.c,v 1.13 1996/04/05 00:01:10 christos Exp $	*/

/*-
 * Copyright (c) 1994, 1995, 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Christos Zoulas, Frank van der Linden, Eric Haszlakiewicz and
 * Thor Lancelot Simon.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/exec.h>
#include <sys/exec_elf.h>

#include <sys/mman.h>
#include <sys/syscallargs.h>
#include <sys/signalvar.h>

#include <uvm/uvm_extern.h>

#include <machine/cpu.h>
#include <machine/reg.h>
#include <machine/linux_machdep.h>

#include <compat/linux/linux_types.h>
#include <compat/linux/linux_syscall.h>
#include <compat/linux/linux_signal.h>
#include <compat/linux/linux_syscallargs.h>
#include <compat/linux/linux_util.h>
#include <compat/linux/linux_exec.h>
#include <compat/linux/linux_emuldata.h>

#define LINUX_ELF_AUX_ARGSIZ (sizeof(AuxInfo) * 8 / sizeof(char *))


const char linux_emul_path[] = "/emul/linux";
extern int linux_error[];
extern char linux_sigcode[], linux_esigcode[];
extern struct sysent linux_sysent[];
#ifdef SYSCALL_DEBUG
extern char *linux_syscallnames[];
#endif

extern struct mutex futex_lock;
extern void futex_pool_init(void);

void linux_e_proc_exec(struct proc *, struct exec_package *);
void linux_e_proc_fork(struct proc *, struct proc *);
void linux_e_proc_exit(struct proc *);
void linux_e_proc_init(struct proc *, struct vmspace *);

struct emul emul_linux_elf = {
	"linux",
	linux_error,
	linux_sendsig,
	LINUX_SYS_syscall,
	LINUX_SYS_MAXSYSCALL,
	linux_sysent,
#ifdef SYSCALL_DEBUG
	linux_syscallnames,
#else
	NULL,
#endif
	LINUX_ELF_AUX_ARGSIZ,
	elf32_copyargs,
	setregs,
	exec_elf32_fixup,
	NULL,			/* coredump */
	linux_sigcode,
	linux_esigcode,
	0,
	NULL,
	linux_e_proc_exec,
	linux_e_proc_fork,
	linux_e_proc_exit,
};

/*
 * Allocate per-process structures. Called when executing Linux
 * process. We can reuse the old emuldata - if it's not null,
 * the executed process is of same emulation as original forked one.
 */
void
linux_e_proc_init(struct proc *p, struct vmspace *vmspace)
{
	if (!p->p_emuldata) {
		/* allocate new Linux emuldata */
		p->p_emuldata = malloc(sizeof(struct linux_emuldata),
		    M_EMULDATA, M_WAITOK|M_ZERO);
	}
	else {
		memset(p->p_emuldata, '\0', sizeof(struct linux_emuldata));
	}

	/* Set the process idea of the break to the real value */
	((struct linux_emuldata *)(p->p_emuldata))->p_break = 
	    vmspace->vm_daddr + ptoa(vmspace->vm_dsize);
}

void
linux_e_proc_exec(struct proc *p, struct exec_package *epp)
{
	/* exec, use our vmspace */
	linux_e_proc_init(p, p->p_vmspace);
}

/*
 * Emulation per-process exit hook.
 */
void
linux_e_proc_exit(struct proc *p)
{
	struct linux_emuldata *emul = p->p_emuldata;

	if (emul->my_clear_tid) {
		pid_t zero = 0;

		if (copyout(&zero, emul->my_clear_tid, sizeof(zero)))
			psignal(p, SIGSEGV);
		/* 
		 * not yet: futex(my_clear_tid, FUTEX_WAKE, 1, NULL, NULL, 0)
		 */
	}

	/* free Linux emuldata and set the pointer to null */
	free(p->p_emuldata, M_EMULDATA, 0);
	p->p_emuldata = NULL;
}

/*
 * Emulation fork hook.
 */
void
linux_e_proc_fork(struct proc *p, struct proc *parent)
{
	struct linux_emuldata *emul;
	struct linux_emuldata *parent_emul;

	/* Allocate new emuldata for the new process. */
	p->p_emuldata = NULL;

	/* fork, use parent's vmspace (our vmspace may not be setup yet) */
	linux_e_proc_init(p, parent->p_vmspace);

	emul = p->p_emuldata;
	parent_emul = parent->p_emuldata;

	emul->my_set_tid = parent_emul->child_set_tid;
	emul->my_clear_tid = parent_emul->child_clear_tid;
	emul->my_tls_base = parent_emul->child_tls_base;
	emul->set_tls_base = parent_emul->set_tls_base;
}

int
exec_linux_elf32_makecmds(struct proc *p, struct exec_package *epp)
{
	if (!(emul_linux_elf.e_flags & EMUL_ENABLED))
		return (ENOEXEC);

	return exec_elf32_makecmds(p, epp);
}

int
linux_elf_probe(struct proc *p, struct exec_package *epp, char *itp,
    u_long *pos)
{
	Elf32_Ehdr *eh = epp->ep_hdr;
	char *bp, *brand;
	int error;
	size_t len;

	if (!(emul_linux_elf.e_flags & EMUL_ENABLED))
		return (ENOEXEC);

	/*
	 * Modern Linux binaries carry an identification note.
	 */
	if (ELFNAME(os_pt_note)(p, epp, epp->ep_hdr, "GNU", 4, 0x10) == 0) {
		goto recognized;
	}

	brand = elf32_check_brand(eh);
	if (brand != NULL && strcmp(brand, "Linux") != 0)
		return (EINVAL);

	/*
	 * If this is a static binary, do not allow it to run, as it
	 * has not been identified. We'll give non-static binaries a
	 * chance to run, as the Linux ld.so name is usually unique
	 * enough to clear any ambiguity.
	 */
	if (itp == NULL)
		return (EINVAL);

recognized:
	if (itp) {
		if ((error = emul_find(p, NULL, linux_emul_path, itp, &bp, 0)))
			return (error);
		error = copystr(bp, itp, MAXPATHLEN, &len);
		free(bp, M_TEMP, 0);
		if (error)
			return (error);
	}
	epp->ep_emul = &emul_linux_elf;
	*pos = ELF32_NO_ADDR;

	mtx_init(&futex_lock, IPL_NONE);
	futex_pool_init();

	return (0);
}

/*
 * Execve(2). Just check the alternate emulation path, and pass it on
 * to the regular execve().
 */
int
linux_sys_execve(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_execve_args /* {
		syscallarg(char *) path;
		syscallarg(char **) argv;
		syscallarg(char **) envp;
        } */ *uap = v;
	struct sys_execve_args ap;
	caddr_t sg;

	sg = stackgap_init(p);
	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&ap, path) = SCARG(uap, path);
	SCARG(&ap, argp) = SCARG(uap, argp);
	SCARG(&ap, envp) = SCARG(uap, envp);

	return (sys_execve(p, &ap, retval));
}
@


1.43
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.42 2014/07/12 18:50:00 tedu Exp $	*/
@


1.42
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.41 2014/03/26 05:23:42 guenther Exp $	*/
a41 1
#include <sys/core.h>
d98 1
a98 1
	coredump_trad,
@


1.41
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.40 2013/12/02 19:47:28 deraadt Exp $	*/
d157 1
a157 1
	free(p->p_emuldata, M_EMULDATA);
d231 1
a231 1
		free(bp, M_TEMP);
@


1.40
log
@spelling; from Maxime Villard
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.39 2013/12/02 19:47:04 deraadt Exp $	*/
d168 1
a168 1
	struct linux_emuldata *p_emul;
d177 1
a177 1
	p_emul = parent->p_emuldata;
d179 4
a182 4
	emul->my_set_tid = p_emul->child_set_tid;
	emul->my_clear_tid = p_emul->child_clear_tid;
	emul->my_tls_base = p_emul->child_tls_base;
	emul->set_tls_base = p_emul->set_tls_base;
d259 1
a259 1
	sg = stackgap_init(p->p_emul);
@


1.39
log
@memory leak if copystr() fails, from Maxime Villard
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.38 2013/11/03 13:52:44 pirofti Exp $	*/
d221 1
a221 1
	 * enough to clear any amibiguity.
@


1.38
log
@Remove a.out support from compat_linux(8).

Tested with the syscall regression test suite from IBM and Opera.

Requested by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.37 2012/09/11 15:44:19 deraadt Exp $	*/
d230 3
a232 1
		if ((error = copystr(bp, itp, MAXPATHLEN, &len)))
a233 1
		free(bp, M_TEMP);
@


1.37
log
@Remove the 'OLF method' used for the transition from a.out to ELF and
for all the compat layers which are now gone.  Linux compat still works
because it always used another method in any case, and nothing looks at
p_os anymore.
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.36 2012/06/20 11:37:21 pirofti Exp $	*/
a63 4
static void *linux_aout_copyargs(struct exec_package *,
	struct ps_strings *, void *, void *);

#define	LINUX_AOUT_AUX_ARGSIZ	2
a77 5
int exec_linux_aout_prep_zmagic(struct proc *, struct exec_package *);
int exec_linux_aout_prep_nmagic(struct proc *, struct exec_package *);
int exec_linux_aout_prep_omagic(struct proc *, struct exec_package *);
int exec_linux_aout_prep_qmagic(struct proc *, struct exec_package *);

a82 26
struct emul emul_linux_aout = {
	"linux",
	linux_error,
	linux_sendsig,
	LINUX_SYS_syscall,
	LINUX_SYS_MAXSYSCALL,
	linux_sysent,
#ifdef SYSCALL_DEBUG
	linux_syscallnames,
#else
	NULL,
#endif
	LINUX_AOUT_AUX_ARGSIZ,
	linux_aout_copyargs,
	setregs,
	NULL,
	coredump_trad,
	linux_sigcode,
	linux_esigcode,
	0,
	NULL,
	linux_e_proc_exec,
	linux_e_proc_fork,
	linux_e_proc_exit,
};

a184 244
static void *
linux_aout_copyargs(struct exec_package *pack, struct ps_strings *arginfo,
    void *stack, void *argp)
{
	char **cpp = stack;
	char **stk = stack;
	char *dp, *sp;
	size_t len;
	void *nullp = NULL;
	int argc = arginfo->ps_nargvstr;
	int envc = arginfo->ps_nenvstr;

	if (copyout(&argc, cpp++, sizeof(argc)))
		return (NULL);

	/* leave room for envp and argv */
	cpp += 2;
	if (copyout(&cpp, &stk[1], sizeof (cpp)))
		return (NULL);

	dp = (char *)(cpp + argc + envc + 2);
	sp = argp;

	/* XXX don't copy them out, remap them! */
	arginfo->ps_argvstr = cpp; /* remember location of argv for later */

	for (; --argc >= 0; sp += len, dp += len)
		if (copyout(&dp, cpp++, sizeof(dp)) ||
		    copyoutstr(sp, dp, ARG_MAX, &len))
			return (NULL);

	if (copyout(&nullp, cpp++, sizeof(nullp)))
		return (NULL);

	if (copyout(&cpp, &stk[2], sizeof (cpp)))
		return (NULL);

	arginfo->ps_envstr = cpp; /* remember location of envp for later */

	for (; --envc >= 0; sp += len, dp += len)
		if (copyout(&dp, cpp++, sizeof(dp)) ||
		    copyoutstr(sp, dp, ARG_MAX, &len))
			return (NULL);

	if (copyout(&nullp, cpp++, sizeof(nullp)))
		return (NULL);

	return (cpp);
}

int
exec_linux_aout_makecmds(struct proc *p, struct exec_package *epp)
{
	struct exec *linux_ep = epp->ep_hdr;
	int machtype, magic;
	int error = ENOEXEC;

	if (epp->ep_hdrvalid < sizeof(struct exec))
		return (ENOEXEC);

	magic = LINUX_N_MAGIC(linux_ep);
	machtype = LINUX_N_MACHTYPE(linux_ep);


	if (machtype != LINUX_MID_MACHINE)
		return (ENOEXEC);

	switch (magic) {
	case QMAGIC:
		error = exec_linux_aout_prep_qmagic(p, epp);
		break;
	case ZMAGIC:
		error = exec_linux_aout_prep_zmagic(p, epp);
		break;
	case NMAGIC:
		error = exec_linux_aout_prep_nmagic(p, epp);
		break;
	case OMAGIC:
		error = exec_linux_aout_prep_omagic(p, epp);
		break;
	}
	if (error == 0)
		epp->ep_emul = &emul_linux_aout;
	return (error);
}

/*
 * Since text starts at 0x400 in Linux ZMAGIC executables, and 0x400
 * is very likely not page aligned on most architectures, it is treated
 * as an NMAGIC here. XXX
 */

int
exec_linux_aout_prep_zmagic(struct proc *p, struct exec_package *epp)
{
	struct exec *execp = epp->ep_hdr;

	epp->ep_taddr = LINUX_N_TXTADDR(*execp, ZMAGIC);
	epp->ep_tsize = execp->a_text;
	epp->ep_daddr = LINUX_N_DATADDR(*execp, ZMAGIC);
	epp->ep_dsize = execp->a_data + execp->a_bss;
	epp->ep_entry = execp->a_entry;

	/* set up command for text segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, execp->a_text,
	    epp->ep_taddr, epp->ep_vp, LINUX_N_TXTOFF(*execp, ZMAGIC),
	    VM_PROT_READ|VM_PROT_EXECUTE);

	/* set up command for data segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, execp->a_data,
	    epp->ep_daddr, epp->ep_vp, LINUX_N_DATOFF(*execp, ZMAGIC),
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, execp->a_bss,
	    epp->ep_daddr + execp->a_data, NULLVP, 0,
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return (exec_setup_stack(p, epp));
}

/*
 * exec_aout_prep_nmagic(): Prepare Linux NMAGIC package.
 * Not different from the normal stuff.
 */

int
exec_linux_aout_prep_nmagic(struct proc *p, struct exec_package *epp)
{
	struct exec *execp = epp->ep_hdr;
	long bsize, baddr;

	epp->ep_taddr = LINUX_N_TXTADDR(*execp, NMAGIC);
	epp->ep_tsize = execp->a_text;
	epp->ep_daddr = LINUX_N_DATADDR(*execp, NMAGIC);
	epp->ep_dsize = execp->a_data + execp->a_bss;
	epp->ep_entry = execp->a_entry;

	/* set up command for text segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, execp->a_text,
	    epp->ep_taddr, epp->ep_vp, LINUX_N_TXTOFF(*execp, NMAGIC),
	    VM_PROT_READ|VM_PROT_EXECUTE);

	/* set up command for data segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, execp->a_data,
	    epp->ep_daddr, epp->ep_vp, LINUX_N_DATOFF(*execp, NMAGIC),
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	baddr = round_page(epp->ep_daddr + execp->a_data);
	bsize = epp->ep_daddr + epp->ep_dsize - baddr;
	if (bsize > 0)
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, bsize, baddr,
		    NULLVP, 0, VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return (exec_setup_stack(p, epp));
}

/*
 * exec_aout_prep_omagic(): Prepare Linux OMAGIC package.
 * Business as usual.
 */

int
exec_linux_aout_prep_omagic(struct proc *p, struct exec_package *epp)
{
	struct exec *execp = epp->ep_hdr;
	long dsize, bsize, baddr;

	epp->ep_taddr = LINUX_N_TXTADDR(*execp, OMAGIC);
	epp->ep_tsize = execp->a_text;
	epp->ep_daddr = LINUX_N_DATADDR(*execp, OMAGIC);
	epp->ep_dsize = execp->a_data + execp->a_bss;
	epp->ep_entry = execp->a_entry;

	/* set up command for text and data segments */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn,
	    execp->a_text + execp->a_data, epp->ep_taddr, epp->ep_vp,
	    LINUX_N_TXTOFF(*execp, OMAGIC), VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	baddr = round_page(epp->ep_daddr + execp->a_data);
	bsize = epp->ep_daddr + epp->ep_dsize - baddr;
	if (bsize > 0)
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, bsize, baddr,
		    NULLVP, 0, VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/*
	 * Make sure (# of pages) mapped above equals (vm_tsize + vm_dsize);
	 * obreak(2) relies on this fact. Both `vm_tsize' and `vm_dsize' are
	 * computed (in execve(2)) by rounding *up* `ep_tsize' and `ep_dsize'
	 * respectively to page boundaries.
	 * Compensate `ep_dsize' for the amount of data covered by the last
	 * text page. 
	 */
	dsize = epp->ep_dsize + execp->a_text - round_page(execp->a_text);
	epp->ep_dsize = (dsize > 0) ? dsize : 0;
	return (exec_setup_stack(p, epp));
}

int
exec_linux_aout_prep_qmagic(struct proc *p, struct exec_package *epp)
{
	struct exec *execp = epp->ep_hdr;

	epp->ep_taddr = LINUX_N_TXTADDR(*execp, QMAGIC);
	epp->ep_tsize = execp->a_text;
	epp->ep_daddr = LINUX_N_DATADDR(*execp, QMAGIC);
	epp->ep_dsize = execp->a_data + execp->a_bss;
	epp->ep_entry = execp->a_entry;

	/*
	 * check if vnode is in open for writing, because we want to
	 * demand-page out of it.  if it is, don't do it, for various
	 * reasons
	 */
	if ((execp->a_text != 0 || execp->a_data != 0) &&
	    epp->ep_vp->v_writecount != 0) {
#ifdef DIAGNOSTIC
		if (epp->ep_vp->v_flag & VTEXT)
			panic("exec: a VTEXT vnode has writecount != 0");
#endif
		return (ETXTBSY);
	}
	vn_marktext(epp->ep_vp);

	/* set up command for text segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, execp->a_text,
	    epp->ep_taddr, epp->ep_vp, LINUX_N_TXTOFF(*execp, QMAGIC),
	    VM_PROT_READ|VM_PROT_EXECUTE);

	/* set up command for data segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, execp->a_data,
	    epp->ep_daddr, epp->ep_vp, LINUX_N_DATOFF(*execp, QMAGIC),
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, execp->a_bss,
	    epp->ep_daddr + execp->a_data, NULLVP, 0,
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return (exec_setup_stack(p, epp));
}

a240 97
}

/*
 * The Linux system call to load shared libraries, a.out version. The
 * a.out shared libs are just files that are mapped onto a fixed
 * address in the process' address space. The address is given in
 * a_entry. Read in the header, set up some VM commands and run them.
 *
 * Yes, both text and data are mapped at once, so we're left with
 * writeable text for the shared libs. The Linux crt0 seemed to break
 * sometimes when data was mapped separately. It munmapped a uselib()
 * of ld.so by hand, which failed with shared text and data for ld.so
 * Yuck.
 *
 * Because of the problem with ZMAGIC executables (text starts
 * at 0x400 in the file, but needs to be mapped at 0), ZMAGIC
 * shared libs are not handled very efficiently :-(
 */

int
linux_sys_uselib(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_uselib_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
	caddr_t sg;
	long bsize, dsize, tsize, taddr, baddr, daddr;
	struct nameidata ni;
	struct vnode *vp;
	struct exec hdr;
	struct exec_vmcmd_set vcset;
	int i, magic, error;
	size_t rem;

	sg = stackgap_init(p->p_emul);
	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	NDINIT(&ni, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);

	if ((error = namei(&ni)))
		return (error);

	vp = ni.ni_vp;

	if ((error = vn_rdwr(UIO_READ, vp, (caddr_t) &hdr, LINUX_AOUT_HDR_SIZE,
			     0, UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred,
			     &rem, p))) {
		vrele(vp);
		return (error);
	}

	if (rem != 0) {
		vrele(vp);
		return (ENOEXEC);
	}

	if (LINUX_N_MACHTYPE(&hdr) != LINUX_MID_MACHINE)
		return (ENOEXEC);

	magic = LINUX_N_MAGIC(&hdr);
	taddr = trunc_page(hdr.a_entry);
	tsize = hdr.a_text;
	daddr = taddr + tsize;
	dsize = hdr.a_data + hdr.a_bss;

	if ((hdr.a_text != 0 || hdr.a_data != 0) && vp->v_writecount != 0) {
		vrele(vp);
                return (ETXTBSY);
        }
	vn_marktext(vp);

	VMCMDSET_INIT(&vcset);

	NEW_VMCMD(
	    &vcset, magic == ZMAGIC ? vmcmd_map_readvn : vmcmd_map_pagedvn,
	    hdr.a_text + hdr.a_data, taddr, vp, LINUX_N_TXTOFF(hdr, magic),
	    VM_PROT_READ|VM_PROT_EXECUTE|VM_PROT_WRITE);

	baddr = round_page(daddr + hdr.a_data);
	bsize = daddr + dsize - baddr;
        if (bsize > 0) {
                NEW_VMCMD(&vcset, vmcmd_map_zero, bsize, baddr,
                    NULLVP, 0, VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
	}

	for (i = 0; i < vcset.evs_used && !error; i++) {
		struct exec_vmcmd *vcp;

		vcp = &vcset.evs_cmds[i];
		error = (*vcp->ev_proc)(p, vcp);
	}

	kill_vmcmds(&vcset);

	vrele(vp);

	return (error);
@


1.36
log
@Copy the set_tls_base flag when forking.

This enables the linux_child_return bits that set the TLS base in the
newly forked process.

Before this, processes that had the flag set would get a null pointer and
segfault when trying to access the TLS area.

Chased down and fixed by me. Turned into a proper one line diff by guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.35 2011/09/18 02:23:18 pirofti Exp $	*/
a44 1
#include <sys/exec_olf.h>
d475 1
a475 1
    u_long *pos, u_int8_t *os)
a514 2
	if (*os == OOS_NULL)
		*os = OOS_LINUX;
@


1.35
log
@Add futex support for compat/linux.

Based on Emmanuel Dreyfus work with additions, tricks and adaptations by me.

Lots of help and reviewing by guenther@@ and oga@@.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.34 2011/04/20 19:14:34 pirofti Exp $	*/
d218 1
@


1.34
log
@Fix possible NULL dereference for emul data. Okay miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.33 2011/04/05 15:44:40 pirofti Exp $	*/
d80 3
d469 1
d517 4
@


1.33
log
@Add set_tid_address() syscall. Lots of help from and okay guenther@@.

This is more than a simple syscall.This expands TLS support quite a bit.
Also linux_sys_clone() handles CLONE_CHILD_CLEARTID, CLONE_CHILD_SETTID,
CLONE_PARENT_SETTID flags as well as the CLONE_SETTLS by doing what
set_thread_area() is doing.

Next on the list is futex support which should allow compat to cope with
newer Linux kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.32 2011/04/05 01:41:03 pirofti Exp $	*/
d200 2
a201 2
	struct linux_emuldata *emul = p->p_emuldata;
	struct linux_emuldata *p_emul = parent->p_emuldata;
d208 3
@


1.32
log
@Fix function argument list.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.31 2009/03/05 19:52:24 kettenis Exp $	*/
d49 1
d177 12
d200 4
a203 5
	/*
	 * It could be desirable to copy some stuff from parent's
	 * emuldata. We don't need anything like that for now.
	 * So just allocate new emuldata for the new process.
	 */
d208 4
@


1.31
log
@Make ELF platforms generate ELF core dumps.  Somewhat based on code from
NetBSD.

ok kurt@@, drahn@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.30 2008/06/26 05:42:14 ray Exp $	*/
d147 1
a147 3
linux_e_proc_init(p, vmspace)
	struct proc *p;
	struct vmspace *vmspace;
d164 1
a164 3
linux_e_proc_exec(p, epp)
	struct proc *p;
	struct exec_package *epp;
d174 1
a174 2
linux_e_proc_exit(p)
	struct proc *p;
d185 1
a185 2
linux_e_proc_fork(p, parent)
	struct proc *p, *parent;
d199 2
a200 5
linux_aout_copyargs(pack, arginfo, stack, argp)
	struct exec_package *pack;
	struct ps_strings *arginfo;
	void *stack;
	void *argp;
d249 1
a249 3
exec_linux_aout_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
d291 1
a291 3
exec_linux_aout_prep_zmagic(p, epp)
	struct proc *p;
	struct exec_package *epp;
d325 1
a325 3
exec_linux_aout_prep_nmagic(p, epp)
	struct proc *p;
	struct exec_package *epp;
d362 1
a362 3
exec_linux_aout_prep_omagic(p, epp)
	struct proc *p;
	struct exec_package *epp;
d399 1
a399 3
exec_linux_aout_prep_qmagic(p, epp)
	struct proc *p;
	struct exec_package *epp;
d451 2
a452 6
linux_elf_probe(p, epp, itp, pos, os)
	struct proc *p;
	struct exec_package *epp;
	char *itp;
	u_long *pos;
	u_int8_t *os;
d515 1
a515 4
linux_sys_uselib(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d599 1
a599 4
linux_sys_execve(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
@


1.30
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.29 2008/06/12 22:04:55 miod Exp $	*/
d42 1
d105 1
d131 1
@


1.29
log
@Be more permissive and try to run non-branded non-static binaries if we can
find their interpreter, as the linux ld.so name is unique and not likely to
be found in another /emul/foo hierarchy; allows Opera to run again. Noticed
by sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.28 2008/06/12 04:32:59 miod Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.28
log
@Do not attempt to recognize foreign ELF binaries if emulation is disabled;
also recognize modern Linux binaries without branding, but with a ``GNU''
ABI note.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.27 2007/10/30 12:09:22 gilles Exp $	*/
d497 10
a506 1
	if (brand == NULL || strcmp(brand, "Linux") != 0)
@


1.27
log
@- replace the remaining MALLOC/FREE -> malloc/free in sys/compat

ok krw@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.26 2007/09/01 15:14:44 martin Exp $	*/
d486 10
d497 1
a497 1
	if (brand && strcmp(brand, "Linux"))
d499 2
@


1.26
log
@replace the machine dependant bytes-to-clicks macro by the MI ptoa()
version for i386

more architectures and ctob() replacement is being worked on

prodded by and ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.25 2006/01/19 17:54:52 mickey Exp $	*/
d157 5
a161 2
		MALLOC(p->p_emuldata, void *, sizeof(struct linux_emuldata),
		    M_EMULDATA, M_WAITOK);
a163 2
	memset(p->p_emuldata, '\0', sizeof(struct linux_emuldata));

d186 1
a186 1
	FREE(p->p_emuldata, M_EMULDATA);
@


1.25
log
@redo (w/ proper changes everywhere ;):
take interp[MAXPATHLEN] off the stack.  from mickey, ok otto
while here, switch above from malloc to pool, remove stupid casts
tedu@@ miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.24 2005/12/30 19:46:55 miod Exp $	*/
d165 1
a165 1
	    vmspace->vm_daddr + ctob(vmspace->vm_dsize);
@


1.24
log
@Missing or incorrect header sizes bounds check; ``looks ok'' mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.23 2004/04/15 00:22:42 tedu Exp $	*/
d488 1
a488 1
	if (itp[0]) {
@


1.23
log
@rework access to emulations slightly in an effort to both merge and
separate exec format from emulation.  consistent naming of freebsd emuls.
not much in the way of functional changes yet.
testing and ok deraadt@@ and others along the way.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.22 2003/08/21 18:56:07 tedu Exp $	*/
d268 3
@


1.22
log
@emulation is now controlled by sysctl.  changes:
add e_flags to struct emul.  this stores on/off and native flags.
check for emul enabled in check_exec().  gather all the emuls into a
emulsw so a sysctl can find them.  create sysctl.  move maxhdrsiz calcualation
into init_main so it cleans up sys_execve codepath.  teach sysctl utility
to grok kern.emul hierarchy.
requested and ok deraadt@@  some comments from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.21 2003/06/21 00:42:58 tedu Exp $	*/
d459 8
@


1.21
log
@add exec/fork/exit hooks per process for compat emulations.
use them to correctly emulate linux brk.
update to TNF copyright in linux_exec.c.

from netbsd, mostly from a diff by Kurt Miller in pr3318.
this should fix java.  no regressions in testing by kurt and sturm@@.
be prepared for "proc size mismatch" -- recompile ps and friends.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.20 2002/03/14 01:26:50 millert Exp $	*/
d113 1
d138 1
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.19 2001/11/15 06:22:30 art Exp $	*/
d4 2
a5 3
/*
 * Copyright (c) 1995 Frank van der Linden
 * Copyright (c) 1994 Christos Zoulas
d8 4
d20 7
a26 2
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
d28 11
a38 12
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * based on exec_aout.c, sunos_exec.c and svr4_exec.c
d68 1
d90 5
d113 4
d137 4
d143 61
@


1.19
log
@New function vn_marktext - mark a vnode as executing a text image.
Use where VTEXT was set in vnode flags before. Doesn't do anything else (yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.18 2001/11/06 19:53:17 miod Exp $	*/
d62 2
a63 2
static void *linux_aout_copyargs __P((struct exec_package *,
	struct ps_strings *, void *, void *));
d77 4
a80 4
int exec_linux_aout_prep_zmagic __P((struct proc *, struct exec_package *));
int exec_linux_aout_prep_nmagic __P((struct proc *, struct exec_package *));
int exec_linux_aout_prep_omagic __P((struct proc *, struct exec_package *));
int exec_linux_aout_prep_qmagic __P((struct proc *, struct exec_package *));
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.19 2001/11/15 06:22:30 art Exp $	*/
d62 2
a63 2
static void *linux_aout_copyargs(struct exec_package *,
	struct ps_strings *, void *, void *);
d77 4
a80 4
int exec_linux_aout_prep_zmagic(struct proc *, struct exec_package *);
int exec_linux_aout_prep_nmagic(struct proc *, struct exec_package *);
int exec_linux_aout_prep_omagic(struct proc *, struct exec_package *);
int exec_linux_aout_prep_qmagic(struct proc *, struct exec_package *);
@


1.18
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.17 2001/09/19 13:28:43 art Exp $	*/
d357 1
a357 1
	epp->ep_vp->v_flag |= VTEXT;
d477 1
a477 1
	vp->v_flag |= VTEXT;
@


1.17
log
@Unify elf32 and elf64 code with macros. This forced a renaming
of a few functions from elf32.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.16 2001/08/11 23:21:14 art Exp $	*/
d49 1
a49 1
#include <vm/vm.h>
@


1.16
log
@Unnecessary and redundant includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.15 2001/04/01 21:30:33 art Exp $	*/
d115 1
a115 1
	elf_copyargs,
d117 1
a117 1
	exec_elf_fixup,
d390 1
a390 1
	brand = elf_check_brand(eh);
@


1.15
log
@Add a macro to initialize the contents of a vmcmd set.
Correctly initialize the vmcmds in linux_exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.14 2000/11/10 15:33:09 provos Exp $	*/
a49 2
#include <vm/vm_param.h>
#include <vm/vm_map.h>
@


1.14
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.13 1999/11/26 16:44:28 art Exp $	*/
d481 1
a481 2
	vcset.evs_cnt = 0;
	vcset.evs_used = 0;
@


1.13
log
@Use round_page(X) instead of roundup(X, NBPG), use PAGE_SIZE instead of NBPG.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.12 1999/11/10 15:55:22 mickey Exp $	*/
d417 1
a417 1
 * sometimes when data was mapped seperately. It munmapped a uselib()
@


1.13.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.15 2001/04/01 21:30:33 art Exp $	*/
d417 1
a417 1
 * sometimes when data was mapped separately. It munmapped a uselib()
d481 2
a482 1
	VMCMDSET_INIT(&vcset);
@


1.13.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.13.2.1 2001/05/14 22:04:37 niklas Exp $	*/
d50 2
d117 1
a117 1
	elf32_copyargs,
d119 1
a119 1
	exec_elf32_fixup,
d392 1
a392 1
	brand = elf32_check_brand(eh);
@


1.13.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 1
a49 1
#include <uvm/uvm_extern.h>
@


1.13.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.13.2.3 2001/11/13 21:05:48 niklas Exp $	*/
d357 1
a357 1
	vn_marktext(epp->ep_vp);
d477 1
a477 1
	vn_marktext(vp);
@


1.13.2.5
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 2
a63 2
static void *linux_aout_copyargs(struct exec_package *,
	struct ps_strings *, void *, void *);
d77 4
a80 4
int exec_linux_aout_prep_zmagic(struct proc *, struct exec_package *);
int exec_linux_aout_prep_nmagic(struct proc *, struct exec_package *);
int exec_linux_aout_prep_omagic(struct proc *, struct exec_package *);
int exec_linux_aout_prep_qmagic(struct proc *, struct exec_package *);
@


1.13.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d4 3
a6 2
/*-
 * Copyright (c) 1994, 1995, 1998, 2000 The NetBSD Foundation, Inc.
a8 4
 * This code is derived from software contributed to The NetBSD Foundation
 * by Christos Zoulas, Frank van der Linden, Eric Haszlakiewicz and
 * Thor Lancelot Simon.
 *
d17 2
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d20 12
a31 11
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
a60 1
#include <compat/linux/linux_emuldata.h>
a81 5
void linux_e_proc_exec(struct proc *, struct exec_package *);
void linux_e_proc_fork(struct proc *, struct proc *);
void linux_e_proc_exit(struct proc *);
void linux_e_proc_init(struct proc *, struct vmspace *);

a99 5
	0,
	NULL,
	linux_e_proc_exec,
	linux_e_proc_fork,
	linux_e_proc_exit,
a119 5
	0,
	NULL,
	linux_e_proc_exec,
	linux_e_proc_fork,
	linux_e_proc_exit,
a121 61
/*
 * Allocate per-process structures. Called when executing Linux
 * process. We can reuse the old emuldata - if it's not null,
 * the executed process is of same emulation as original forked one.
 */
void
linux_e_proc_init(p, vmspace)
	struct proc *p;
	struct vmspace *vmspace;
{
	if (!p->p_emuldata) {
		/* allocate new Linux emuldata */
		MALLOC(p->p_emuldata, void *, sizeof(struct linux_emuldata),
		    M_EMULDATA, M_WAITOK);
	}

	memset(p->p_emuldata, '\0', sizeof(struct linux_emuldata));

	/* Set the process idea of the break to the real value */
	((struct linux_emuldata *)(p->p_emuldata))->p_break = 
	    vmspace->vm_daddr + ctob(vmspace->vm_dsize);
}

void
linux_e_proc_exec(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	/* exec, use our vmspace */
	linux_e_proc_init(p, p->p_vmspace);
}

/*
 * Emulation per-process exit hook.
 */
void
linux_e_proc_exit(p)
	struct proc *p;
{
	/* free Linux emuldata and set the pointer to null */
	FREE(p->p_emuldata, M_EMULDATA);
	p->p_emuldata = NULL;
}

/*
 * Emulation fork hook.
 */
void
linux_e_proc_fork(p, parent)
	struct proc *p, *parent;
{
	/*
	 * It could be desirable to copy some stuff from parent's
	 * emuldata. We don't need anything like that for now.
	 * So just allocate new emuldata for the new process.
	 */
	p->p_emuldata = NULL;

	/* fork, use parent's vmspace (our vmspace may not be setup yet) */
	linux_e_proc_init(p, parent->p_vmspace);
}
@


1.13.2.7
log
@Merge with the trunk
@
text
@a461 8
exec_linux_elf32_makecmds(struct proc *p, struct exec_package *epp)
{
	if (!(emul_linux_elf.e_flags & EMUL_ENABLED))
		return (ENOEXEC);
	return exec_elf32_makecmds(p, epp);
}

int
@


1.12
log
@include syscallnames only if compiling w/ SYSCALL_DEBUG.
was already so for native and sunos, the rest was just
wasting space on it. niels@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.11 1999/09/10 20:27:40 art Exp $	*/
d280 1
a280 1
	baddr = roundup(epp->ep_daddr + execp->a_data, NBPG);
d314 1
a314 1
	baddr = roundup(epp->ep_daddr + execp->a_data, NBPG);
d328 1
a328 1
	dsize = epp->ep_dsize + execp->a_text - roundup(execp->a_text, NBPG);
d470 1
a470 1
	taddr = hdr.a_entry & (~(NBPG - 1));
d489 1
a489 1
	baddr = roundup(daddr + hdr.a_data, NBPG);
@


1.11
log
@include sys/exec.h before sys/exec_elf.h
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.10 1999/02/10 08:07:20 deraadt Exp $	*/
d75 1
d77 1
d91 1
d93 3
d111 1
d113 3
@


1.10
log
@branding support and freebsd elf
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.9 1999/01/11 05:12:12 millert Exp $	*/
d42 1
a54 1
#include <machine/exec.h>
@


1.9
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.8 1998/07/28 00:13:23 millert Exp $	*/
d377 2
a378 1
	char *bp;
d382 3
@


1.8
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.7 1998/03/06 22:14:01 niklas Exp $	*/
d345 1
a345 1
			panic("exec: a VTEXT vnode has writecount != 0\n");
@


1.7
log
@Just alter the tag if it is not already set
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.6 1998/02/22 01:07:56 niklas Exp $	*/
d427 2
a428 1
	int rem, i, magic, error;
@


1.6
log
@Remember OS tag when running Linux or SVR4 ELF files.  KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.5 1997/06/17 11:11:10 deraadt Exp $	*/
d390 2
a391 1
	*os = OOS_LINUX;
@


1.5
log
@careful with stackgap handling in execve()
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.4 1996/12/23 02:56:49 deraadt Exp $	*/
d43 1
d131 1
a131 1
		return NULL;
d136 1
a136 1
		return NULL;
d138 1
a138 1
	dp = (char *) (cpp + argc + envc + 2);
d147 1
a147 1
			return NULL;
d150 1
a150 1
		return NULL;
d153 1
a153 1
		return NULL;
d160 1
a160 1
			return NULL;
d163 1
a163 1
		return NULL;
d165 1
a165 1
	return cpp;
d200 1
a200 1
	return error;
d237 1
a237 1
	return exec_setup_stack(p, epp);
d276 1
a276 1
	return exec_setup_stack(p, epp);
d320 1
a320 1
	return exec_setup_stack(p, epp);
d347 1
a347 1
		return ETXTBSY;
d366 1
a366 1
	return exec_setup_stack(p, epp);
d370 1
a370 1
linux_elf_probe(p, epp, itp, pos)
d375 1
d383 1
a383 1
			return error;
d385 1
a385 1
			return error;
d390 2
a391 1
	return 0;
d434 1
a434 1
		return error;
d442 1
a442 1
		return error;
d447 1
a447 1
		return ENOEXEC;
d451 1
a451 1
		return ENOEXEC;
d461 1
a461 1
                return ETXTBSY;
d468 4
a471 5
	NEW_VMCMD(&vcset,
		  magic == ZMAGIC ? vmcmd_map_readvn : vmcmd_map_pagedvn,
		  hdr.a_text + hdr.a_data, taddr,
		  vp, LINUX_N_TXTOFF(hdr, magic),
		  VM_PROT_READ|VM_PROT_EXECUTE|VM_PROT_WRITE);
d491 1
a491 1
	return error;
d519 1
a519 1
	return sys_execve(p, &ap, retval);
@


1.4
log
@use _{NLIST,KERN}_DO_{AOUT,ELF,ECOFF} to select binary types
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_exec.c,v 1.3 1996/08/31 09:24:02 pefo Exp $	*/
d494 1
a494 1
 * to the NetBSD execve().
d506 2
a507 1
	} */ *uap = v;
d513 5
a517 1
	return sys_execve(p, uap, retval);
@


1.3
log
@Cleanup exec
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d236 1
a236 1
	return exec_aout_setup_stack(p, epp);
d275 1
a275 1
	return exec_aout_setup_stack(p, epp);
d319 1
a319 1
	return exec_aout_setup_stack(p, epp);
d365 1
a365 1
	return exec_aout_setup_stack(p, epp);
@


1.2
log
@Good fixes and changes from latest Net.
@
text
@d92 1
d108 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: linux_exec.c,v 1.12 1995/10/07 06:27:00 mycroft Exp $	*/
d41 1
d45 2
d75 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

