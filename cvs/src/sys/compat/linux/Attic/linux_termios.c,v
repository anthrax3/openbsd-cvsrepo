head	1.19;
access;
symbols
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.10
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.6
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.4
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.36
	OPENBSD_5_0:1.15.0.34
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.32
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.30
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.26
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.28
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.24
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.22
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.20
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.18
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.16
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.14
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.12
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.8
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.6
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.14
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.4
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.19
date	2016.03.02.15.41.48;	author naddy;	state dead;
branches;
next	1.18;
commitid	ZfNt0OHZhMg52abA;

1.18
date	2015.04.30.09.20.51;	author mpi;	state Exp;
branches;
next	1.17;
commitid	ngMdImGL4WWFm6gy;

1.17
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.05.20.30.18;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.07.20.31.17;	author jasoni;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.07.20.23.42;	author jasoni;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.50;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.13.20.43.42;	author jasoni;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.26.12.03.27;	author art;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.05.24.06.00.09;	author jasoni;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.18.17.40.24;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.18.14.56.59;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	99.07.18.00.12.04;	author deraadt;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	97.12.10.13.35.53;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.12.25.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.18.21.21.39;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.04.17.05.24.08;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.03.08.23.43.07;	author mickey;	state Exp;
branches;
next	;

1.6.4.1
date	2001.05.14.22.04.53;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.07.04.10.39.30;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2003.05.13.19.21.26;	author ho;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2003.05.19.21.52.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@remove the Linux emulation code, no longer referenced by anything
@
text
@/*	$OpenBSD: linux_termios.c,v 1.18 2015/04/30 09:20:51 mpi Exp $	*/
/*	$NetBSD: linux_termios.c,v 1.3 1996/04/05 00:01:54 christos Exp $	*/

/*
 * Copyright (c) 1995 Frank van der Linden
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project
 *      by Frank van der Linden
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/termios.h>

#include <sys/syscallargs.h>

#include <compat/linux/linux_types.h>
#include <compat/linux/linux_ioctl.h>
#include <compat/linux/linux_signal.h>
#include <compat/linux/linux_syscallargs.h>
#include <compat/linux/linux_util.h>
#include <compat/linux/linux_termios.h>

static speed_t linux_speeds[] = {
	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800,
	9600, 19200, 38400, 57600, 115200, 230400
};

static const int linux_spmasks[] = {
	LINUX_B0, LINUX_B50, LINUX_B75, LINUX_B110, LINUX_B134, LINUX_B150,
	LINUX_B200, LINUX_B300, LINUX_B600, LINUX_B1200, LINUX_B1800,
	LINUX_B2400, LINUX_B4800, LINUX_B9600, LINUX_B19200, LINUX_B38400,
	LINUX_B57600, LINUX_B115200, LINUX_B230400
};

static void linux_termio_to_bsd_termios(struct linux_termio *,
    struct termios *);
static void bsd_termios_to_linux_termio(struct termios *,
    struct linux_termio *);
static void linux_termios_to_bsd_termios(struct linux_termios *,
    struct termios *);
static void bsd_termios_to_linux_termios(struct termios *,
    struct linux_termios *);

/*
 * Deal with termio ioctl cruft. This doesn't look very good..
 * XXX too much code duplication, obviously..
 *
 * The conversion routines between Linux and BSD structures assume
 * that the fields are already filled with the current values,
 * so that fields present in BSD but not in Linux keep their current
 * values.
 */

static void
linux_termio_to_bsd_termios(lt, bts)
	struct linux_termio *lt;
	struct termios *bts;
{
	int index;

	bts->c_iflag = 0;
	bts->c_iflag |= cvtto_bsd_mask(lt->c_iflag, LINUX_IGNBRK, IGNBRK);
	bts->c_iflag |= cvtto_bsd_mask(lt->c_iflag, LINUX_BRKINT, BRKINT);
	bts->c_iflag |= cvtto_bsd_mask(lt->c_iflag, LINUX_IGNPAR, IGNPAR);
	bts->c_iflag |= cvtto_bsd_mask(lt->c_iflag, LINUX_INPCK, INPCK);
	bts->c_iflag |= cvtto_bsd_mask(lt->c_iflag, LINUX_ISTRIP, ISTRIP);
	bts->c_iflag |= cvtto_bsd_mask(lt->c_iflag, LINUX_INLCR, INLCR);
	bts->c_iflag |= cvtto_bsd_mask(lt->c_iflag, LINUX_IGNCR, IGNCR);
	bts->c_iflag |= cvtto_bsd_mask(lt->c_iflag, LINUX_ICRNL, ICRNL);
	bts->c_iflag |= cvtto_bsd_mask(lt->c_iflag, LINUX_IXON, IXON);
	bts->c_iflag |= cvtto_bsd_mask(lt->c_iflag, LINUX_IXANY, IXANY);
	bts->c_iflag |= cvtto_bsd_mask(lt->c_iflag, LINUX_IXOFF, IXOFF);
	bts->c_iflag |= cvtto_bsd_mask(lt->c_iflag, LINUX_IMAXBEL, IMAXBEL);

	bts->c_oflag = 0;
	bts->c_oflag |= cvtto_bsd_mask(lt->c_oflag, LINUX_OPOST, OPOST);
	bts->c_oflag |= cvtto_bsd_mask(lt->c_oflag, LINUX_ONLCR, ONLCR);
	bts->c_oflag |= cvtto_bsd_mask(lt->c_oflag, LINUX_XTABS, OXTABS);

	/*
	 * This could have been:
	 * bts->c_cflag = (lt->c_flag & LINUX_CSIZE) << 4
	 * But who knows, those values might perhaps change one day.
	 */
	switch (lt->c_cflag & LINUX_CSIZE) {
	case LINUX_CS5:
		bts->c_cflag = CS5;
		break;
	case LINUX_CS6:
		bts->c_cflag = CS6;
		break;
	case LINUX_CS7:
		bts->c_cflag = CS7;
		break;
	case LINUX_CS8:
		bts->c_cflag = CS8;
		break;
	}
	bts->c_cflag |= cvtto_bsd_mask(lt->c_cflag, LINUX_CSTOPB, CSTOPB);
	bts->c_cflag |= cvtto_bsd_mask(lt->c_cflag, LINUX_CREAD, CREAD);
	bts->c_cflag |= cvtto_bsd_mask(lt->c_cflag, LINUX_PARENB, PARENB);
	bts->c_cflag |= cvtto_bsd_mask(lt->c_cflag, LINUX_PARODD, PARODD);
	bts->c_cflag |= cvtto_bsd_mask(lt->c_cflag, LINUX_HUPCL, HUPCL);
	bts->c_cflag |= cvtto_bsd_mask(lt->c_cflag, LINUX_CLOCAL, CLOCAL);
	bts->c_cflag |= cvtto_bsd_mask(lt->c_cflag, LINUX_CRTSCTS, CRTSCTS);

	bts->c_lflag = 0;
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_ISIG, ISIG);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_ICANON, ICANON);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_ECHO, ECHO);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_ECHOE, ECHOE);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_ECHOK, ECHOK);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_ECHONL, ECHONL);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_NOFLSH, NOFLSH);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_TOSTOP, TOSTOP);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_ECHOCTL, ECHOCTL);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_ECHOPRT, ECHOPRT);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_ECHOKE, ECHOKE);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_FLUSHO, FLUSHO);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_PENDIN, PENDIN);
	bts->c_lflag |= cvtto_bsd_mask(lt->c_lflag, LINUX_IEXTEN, IEXTEN);

	index = lt->c_cflag & LINUX_CBAUD;
	if (index & LINUX_CBAUDEX)
		index = (index & ~LINUX_CBAUDEX) + LINUX_NSPEEDS - 1;
	bts->c_ispeed = bts->c_ospeed = linux_speeds[index];

	bts->c_cc[VINTR] = lt->c_cc[LINUX_VINTR];
	bts->c_cc[VQUIT] = lt->c_cc[LINUX_VQUIT];
	bts->c_cc[VERASE] = lt->c_cc[LINUX_VERASE];
	bts->c_cc[VKILL] = lt->c_cc[LINUX_VKILL];
	bts->c_cc[VEOF] = lt->c_cc[LINUX_VEOF];
	bts->c_cc[VTIME] = lt->c_cc[LINUX_VTIME];
	bts->c_cc[VMIN] = lt->c_cc[LINUX_VMIN];
}

static void
bsd_termios_to_linux_termio(bts, lt)
	struct termios *bts;
	struct linux_termio *lt;
{
	int i, mask;

	lt->c_iflag = 0;
	lt->c_iflag |= cvtto_linux_mask(bts->c_iflag, IGNBRK, LINUX_IGNBRK);
	lt->c_iflag |= cvtto_linux_mask(bts->c_iflag, BRKINT, LINUX_BRKINT);
	lt->c_iflag |= cvtto_linux_mask(bts->c_iflag, IGNPAR, LINUX_IGNPAR);
	lt->c_iflag |= cvtto_linux_mask(bts->c_iflag, INPCK, LINUX_INPCK);
	lt->c_iflag |= cvtto_linux_mask(bts->c_iflag, ISTRIP, LINUX_ISTRIP);
	lt->c_iflag |= cvtto_linux_mask(bts->c_iflag, INLCR, LINUX_INLCR);
	lt->c_iflag |= cvtto_linux_mask(bts->c_iflag, IGNCR, LINUX_IGNCR);
	lt->c_iflag |= cvtto_linux_mask(bts->c_iflag, ICRNL, LINUX_ICRNL);
	lt->c_iflag |= cvtto_linux_mask(bts->c_iflag, IXON, LINUX_IXON);
	lt->c_iflag |= cvtto_linux_mask(bts->c_iflag, IXANY, LINUX_IXANY);
	lt->c_iflag |= cvtto_linux_mask(bts->c_iflag, IXOFF, LINUX_IXOFF);
	lt->c_iflag |= cvtto_linux_mask(bts->c_iflag, IMAXBEL, LINUX_IMAXBEL);

	lt->c_oflag = 0;
	lt->c_oflag |= cvtto_linux_mask(bts->c_oflag, OPOST, LINUX_OPOST);
	lt->c_oflag |= cvtto_linux_mask(bts->c_oflag, ONLCR, LINUX_ONLCR);
	lt->c_oflag |= cvtto_linux_mask(bts->c_oflag, OXTABS, LINUX_XTABS);

	switch (bts->c_cflag & CSIZE) {
	case CS5:
		lt->c_cflag = LINUX_CS5;
		break;
	case CS6:
		lt->c_cflag = LINUX_CS6;
		break;
	case CS7:
		lt->c_cflag = LINUX_CS7;
		break;
	case CS8:
		lt->c_cflag = LINUX_CS8;
		break;
	}
	lt->c_cflag |= cvtto_linux_mask(bts->c_cflag, CSTOPB, LINUX_CSTOPB);
	lt->c_cflag |= cvtto_linux_mask(bts->c_cflag, CREAD, LINUX_CREAD);
	lt->c_cflag |= cvtto_linux_mask(bts->c_cflag, PARENB, LINUX_PARENB);
	lt->c_cflag |= cvtto_linux_mask(bts->c_cflag, PARODD, LINUX_PARODD);
	lt->c_cflag |= cvtto_linux_mask(bts->c_cflag, HUPCL, LINUX_HUPCL);
	lt->c_cflag |= cvtto_linux_mask(bts->c_cflag, CLOCAL, LINUX_CLOCAL);
	lt->c_cflag |= cvtto_linux_mask(bts->c_cflag, CRTSCTS, LINUX_CRTSCTS);

	lt->c_lflag = 0;
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, ISIG, LINUX_ISIG);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, ICANON, LINUX_ICANON);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHO, LINUX_ECHO);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHOE, LINUX_ECHOE);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHOK, LINUX_ECHOK);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHONL, LINUX_ECHONL);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, NOFLSH, LINUX_NOFLSH);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, TOSTOP, LINUX_TOSTOP);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHOCTL, LINUX_ECHOCTL);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHOPRT, LINUX_ECHOPRT);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHOKE, LINUX_ECHOKE);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, FLUSHO, LINUX_FLUSHO);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, PENDIN, LINUX_PENDIN);
	lt->c_lflag |= cvtto_linux_mask(bts->c_lflag, IEXTEN, LINUX_IEXTEN);

	mask = LINUX_B9600;	/* XXX default value should this be 0? */
	for (i = 0; i < sizeof (linux_speeds) / sizeof (speed_t); i++) {
		if (bts->c_ospeed == linux_speeds[i]) {
			mask = linux_spmasks[i];
			break;
		}
	}
	lt->c_cflag |= mask;

	lt->c_cc[LINUX_VINTR] = bts->c_cc[VINTR];
	lt->c_cc[LINUX_VQUIT] = bts->c_cc[VQUIT];
	lt->c_cc[LINUX_VERASE] = bts->c_cc[VERASE];
	lt->c_cc[LINUX_VKILL] = bts->c_cc[VKILL];
	lt->c_cc[LINUX_VEOF] = bts->c_cc[VEOF];
	lt->c_cc[LINUX_VTIME] = bts->c_cc[VTIME];
	lt->c_cc[LINUX_VMIN] = bts->c_cc[VMIN];
	lt->c_cc[LINUX_VSWTC] = 0;

	/* XXX should be fixed someday */
	lt->c_line = 0;
}

static void
linux_termios_to_bsd_termios(lts, bts)
	struct linux_termios *lts;
	struct termios *bts;
{
	int index;

	bts->c_iflag = 0;
	bts->c_iflag |= cvtto_bsd_mask(lts->c_iflag, LINUX_IGNBRK, IGNBRK);
	bts->c_iflag |= cvtto_bsd_mask(lts->c_iflag, LINUX_BRKINT, BRKINT);
	bts->c_iflag |= cvtto_bsd_mask(lts->c_iflag, LINUX_IGNPAR, IGNPAR);
	bts->c_iflag |= cvtto_bsd_mask(lts->c_iflag, LINUX_INPCK, INPCK);
	bts->c_iflag |= cvtto_bsd_mask(lts->c_iflag, LINUX_ISTRIP, ISTRIP);
	bts->c_iflag |= cvtto_bsd_mask(lts->c_iflag, LINUX_INLCR, INLCR);
	bts->c_iflag |= cvtto_bsd_mask(lts->c_iflag, LINUX_IGNCR, IGNCR);
	bts->c_iflag |= cvtto_bsd_mask(lts->c_iflag, LINUX_ICRNL, ICRNL);
	bts->c_iflag |= cvtto_bsd_mask(lts->c_iflag, LINUX_IXON, IXON);
	bts->c_iflag |= cvtto_bsd_mask(lts->c_iflag, LINUX_IXANY, IXANY);
	bts->c_iflag |= cvtto_bsd_mask(lts->c_iflag, LINUX_IXOFF, IXOFF);
	bts->c_iflag |= cvtto_bsd_mask(lts->c_iflag, LINUX_IMAXBEL, IMAXBEL);

	bts->c_oflag = 0;
	bts->c_oflag |= cvtto_bsd_mask(lts->c_oflag, LINUX_OPOST, OPOST);
	bts->c_oflag |= cvtto_bsd_mask(lts->c_oflag, LINUX_ONLCR, ONLCR);
	bts->c_oflag |= cvtto_bsd_mask(lts->c_oflag, LINUX_XTABS, OXTABS);

	bts->c_cflag = 0;
	switch (lts->c_cflag & LINUX_CSIZE) {
	case LINUX_CS5:
		bts->c_cflag = CS5;
		break;
	case LINUX_CS6:
		bts->c_cflag = CS6;
		break;
	case LINUX_CS7:
		bts->c_cflag = CS7;
		break;
	case LINUX_CS8:
		bts->c_cflag = CS8;
		break;
	}
	bts->c_cflag |= cvtto_bsd_mask(lts->c_cflag, LINUX_CSTOPB, CSTOPB);
	bts->c_cflag |= cvtto_bsd_mask(lts->c_cflag, LINUX_CREAD, CREAD);
	bts->c_cflag |= cvtto_bsd_mask(lts->c_cflag, LINUX_PARENB, PARENB);
	bts->c_cflag |= cvtto_bsd_mask(lts->c_cflag, LINUX_PARODD, PARODD);
	bts->c_cflag |= cvtto_bsd_mask(lts->c_cflag, LINUX_HUPCL, HUPCL);
	bts->c_cflag |= cvtto_bsd_mask(lts->c_cflag, LINUX_CLOCAL, CLOCAL);
	bts->c_cflag |= cvtto_bsd_mask(lts->c_cflag, LINUX_CRTSCTS, CRTSCTS);

	bts->c_lflag = 0;
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_ISIG, ISIG);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_ICANON, ICANON);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_ECHO, ECHO);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_ECHOE, ECHOE);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_ECHOK, ECHOK);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_ECHONL, ECHONL);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_NOFLSH, NOFLSH);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_TOSTOP, TOSTOP);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_ECHOCTL, ECHOCTL);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_ECHOPRT, ECHOPRT);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_ECHOKE, ECHOKE);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_FLUSHO, FLUSHO);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_PENDIN, PENDIN);
	bts->c_lflag |= cvtto_bsd_mask(lts->c_lflag, LINUX_IEXTEN, IEXTEN);

	index = lts->c_cflag & LINUX_CBAUD;
	if (index & LINUX_CBAUDEX)
		index = (index & ~LINUX_CBAUDEX) + LINUX_NSPEEDS - 1;
	bts->c_ispeed = bts->c_ospeed = linux_speeds[index];

	bts->c_cc[VINTR] = lts->c_cc[LINUX_VINTR];
	bts->c_cc[VQUIT] = lts->c_cc[LINUX_VQUIT];
	bts->c_cc[VERASE] = lts->c_cc[LINUX_VERASE];
	bts->c_cc[VKILL] = lts->c_cc[LINUX_VKILL];
	bts->c_cc[VEOF] = lts->c_cc[LINUX_VEOF];
	bts->c_cc[VTIME] = lts->c_cc[LINUX_VTIME];
	bts->c_cc[VMIN] = lts->c_cc[LINUX_VMIN];
	bts->c_cc[VEOL] = lts->c_cc[LINUX_VEOL];
	bts->c_cc[VEOL2] = lts->c_cc[LINUX_VEOL2];
	bts->c_cc[VWERASE] = lts->c_cc[LINUX_VWERASE];
	bts->c_cc[VSUSP] = lts->c_cc[LINUX_VSUSP];
	bts->c_cc[VSTART] = lts->c_cc[LINUX_VSTART];
	bts->c_cc[VSTOP] = lts->c_cc[LINUX_VSTOP];
	bts->c_cc[VLNEXT] = lts->c_cc[LINUX_VLNEXT];
	bts->c_cc[VDISCARD] = lts->c_cc[LINUX_VDISCARD];
	bts->c_cc[VREPRINT] = lts->c_cc[LINUX_VREPRINT];
}

static void
bsd_termios_to_linux_termios(bts, lts)
	struct termios *bts;
	struct linux_termios *lts;
{
	int i, mask;

	lts->c_iflag = 0;
	lts->c_iflag |= cvtto_linux_mask(bts->c_iflag, IGNBRK, LINUX_IGNBRK);
	lts->c_iflag |= cvtto_linux_mask(bts->c_iflag, BRKINT, LINUX_BRKINT);
	lts->c_iflag |= cvtto_linux_mask(bts->c_iflag, IGNPAR, LINUX_IGNPAR);
	lts->c_iflag |= cvtto_linux_mask(bts->c_iflag, INPCK, LINUX_INPCK);
	lts->c_iflag |= cvtto_linux_mask(bts->c_iflag, ISTRIP, LINUX_ISTRIP);
	lts->c_iflag |= cvtto_linux_mask(bts->c_iflag, INLCR, LINUX_INLCR);
	lts->c_iflag |= cvtto_linux_mask(bts->c_iflag, IGNCR, LINUX_IGNCR);
	lts->c_iflag |= cvtto_linux_mask(bts->c_iflag, ICRNL, LINUX_ICRNL);
	lts->c_iflag |= cvtto_linux_mask(bts->c_iflag, IXON, LINUX_IXON);
	lts->c_iflag |= cvtto_linux_mask(bts->c_iflag, IXANY, LINUX_IXANY);
	lts->c_iflag |= cvtto_linux_mask(bts->c_iflag, IXOFF, LINUX_IXOFF);
	lts->c_iflag |= cvtto_linux_mask(bts->c_iflag, IMAXBEL, LINUX_IMAXBEL);

	lts->c_oflag = 0;
	lts->c_oflag |= cvtto_linux_mask(bts->c_oflag, OPOST, LINUX_OPOST);
	lts->c_oflag |= cvtto_linux_mask(bts->c_oflag, ONLCR, LINUX_ONLCR);
	lts->c_oflag |= cvtto_linux_mask(bts->c_oflag, OXTABS, LINUX_XTABS);

	switch (bts->c_cflag & CSIZE) {
	case CS5:
		lts->c_cflag = LINUX_CS5;
		break;
	case CS6:
		lts->c_cflag = LINUX_CS6;
		break;
	case CS7:
		lts->c_cflag = LINUX_CS7;
		break;
	case CS8:
		lts->c_cflag = LINUX_CS8;
		break;
	}
	lts->c_cflag |= cvtto_linux_mask(bts->c_cflag, CS5, LINUX_CS5);
	lts->c_cflag |= cvtto_linux_mask(bts->c_cflag, CS6, LINUX_CS6);
	lts->c_cflag |= cvtto_linux_mask(bts->c_cflag, CS7, LINUX_CS7);
	lts->c_cflag |= cvtto_linux_mask(bts->c_cflag, CS8, LINUX_CS8);
	lts->c_cflag |= cvtto_linux_mask(bts->c_cflag, CSTOPB, LINUX_CSTOPB);
	lts->c_cflag |= cvtto_linux_mask(bts->c_cflag, CREAD, LINUX_CREAD);
	lts->c_cflag |= cvtto_linux_mask(bts->c_cflag, PARENB, LINUX_PARENB);
	lts->c_cflag |= cvtto_linux_mask(bts->c_cflag, PARODD, LINUX_PARODD);
	lts->c_cflag |= cvtto_linux_mask(bts->c_cflag, HUPCL, LINUX_HUPCL);
	lts->c_cflag |= cvtto_linux_mask(bts->c_cflag, CLOCAL, LINUX_CLOCAL);
	lts->c_cflag |= cvtto_linux_mask(bts->c_cflag, CRTSCTS, LINUX_CRTSCTS);

	lts->c_lflag = 0;
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, ISIG, LINUX_ISIG);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, ICANON, LINUX_ICANON);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHO, LINUX_ECHO);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHOE, LINUX_ECHOE);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHOK, LINUX_ECHOK);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHONL, LINUX_ECHONL);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, NOFLSH, LINUX_NOFLSH);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, TOSTOP, LINUX_TOSTOP);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHOCTL, LINUX_ECHOCTL);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHOPRT, LINUX_ECHOPRT);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, ECHOKE, LINUX_ECHOKE);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, FLUSHO, LINUX_FLUSHO);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, PENDIN, LINUX_PENDIN);
	lts->c_lflag |= cvtto_linux_mask(bts->c_lflag, IEXTEN, LINUX_IEXTEN);

	mask = LINUX_B9600;	/* XXX default value */
	for (i = 0; i < sizeof (linux_speeds) / sizeof (speed_t); i++) {
		if (bts->c_ospeed == linux_speeds[i]) {
			mask = linux_spmasks[i];
			break;
		}
	}
	lts->c_cflag |= mask;

	lts->c_cc[LINUX_VINTR] = bts->c_cc[VINTR];
	lts->c_cc[LINUX_VQUIT] = bts->c_cc[VQUIT];
	lts->c_cc[LINUX_VERASE] = bts->c_cc[VERASE];
	lts->c_cc[LINUX_VKILL] = bts->c_cc[VKILL];
	lts->c_cc[LINUX_VEOF] = bts->c_cc[VEOF];
	lts->c_cc[LINUX_VTIME] = bts->c_cc[VTIME];
	lts->c_cc[LINUX_VMIN] = bts->c_cc[VMIN];
	lts->c_cc[LINUX_VEOL] = bts->c_cc[VEOL];
	lts->c_cc[LINUX_VEOL2] = bts->c_cc[VEOL2];
	lts->c_cc[LINUX_VWERASE] = bts->c_cc[VWERASE];
	lts->c_cc[LINUX_VSUSP] = bts->c_cc[VSUSP];
	lts->c_cc[LINUX_VSTART] = bts->c_cc[VSTART];
	lts->c_cc[LINUX_VSTOP] = bts->c_cc[VSTOP];
	lts->c_cc[LINUX_VLNEXT] = bts->c_cc[VLNEXT];
	lts->c_cc[LINUX_VDISCARD] = bts->c_cc[VDISCARD];
	lts->c_cc[LINUX_VREPRINT] = bts->c_cc[VREPRINT];
	lts->c_cc[LINUX_VSWTC] = 0;

	/* XXX should be fixed someday */
	lts->c_line = 0;
}

int
linux_ioctl_termios(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ioctl_args /* {
		syscallarg(int) fd;
		syscallarg(u_long) com;
		syscallarg(caddr_t) data;
	} */ *uap = v;
	struct file *fp;
	struct filedesc *fdp;
	u_long com;
	struct linux_termio tmplt;
	struct linux_termios tmplts;
	struct termios tmpbts;
	caddr_t sg;
	int idat;
	struct sys_ioctl_args ia;
	char tioclinux;
	int error = 0;

	fdp = p->p_fd;
	if ((fp = fd_getfile_mode(fdp, SCARG(uap, fd), FREAD|FWRITE)) == NULL)
		return (EBADF);
	FREF(fp);

	com = SCARG(uap, com);
	retval[0] = 0;
                
	switch (com) {
	case LINUX_TCGETS:
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts,
		    p);
		if (error)
			goto out;
		bsd_termios_to_linux_termios(&tmpbts, &tmplts);
		error = copyout(&tmplts, SCARG(uap, data), sizeof tmplts);
		goto out;
	case LINUX_TCSETS:
	case LINUX_TCSETSW:
	case LINUX_TCSETSF:
		/*
		 * First fill in all fields, so that we keep the current
		 * values for fields that Linux doesn't know about.
		 */
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts,
		    p);
		if (error)
			goto out;
		error = copyin(SCARG(uap, data), &tmplts, sizeof tmplts);
		if (error)
			goto out;
		linux_termios_to_bsd_termios(&tmplts, &tmpbts);
		switch (com) {
		case LINUX_TCSETS:
			com = TIOCSETA;
			break;
		case LINUX_TCSETSW:
			com = TIOCSETAW;
			break;
		case LINUX_TCSETSF:
			com = TIOCSETAF;
			break;
		}
		error = (*fp->f_ops->fo_ioctl)(fp, com, (caddr_t)&tmpbts, p);
		goto out;
	case LINUX_TCGETA:
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts,
		    p);
		if (error)
			goto out;
		bsd_termios_to_linux_termio(&tmpbts, &tmplt);
		error = copyout(&tmplt, SCARG(uap, data), sizeof tmplt);
		goto out;
	case LINUX_TCSETA:
	case LINUX_TCSETAW:
	case LINUX_TCSETAF:
		/*
		 * First fill in all fields, so that we keep the current
		 * values for fields that Linux doesn't know about.
		 */
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts,
		    p);
		if (error)
			goto out;
		error = copyin(SCARG(uap, data), &tmplt, sizeof tmplt);
		if (error)
			goto out;
		linux_termio_to_bsd_termios(&tmplt, &tmpbts);
		switch (com) {
		case LINUX_TCSETA:
			com = TIOCSETA;
			break;
		case LINUX_TCSETAW:
			com = TIOCSETAW;
			break;
		case LINUX_TCSETAF:
			com = TIOCSETAF;
			break;
		}
		error = (*fp->f_ops->fo_ioctl)(fp, com, (caddr_t)&tmpbts, p);
		goto out;
	case LINUX_TIOCGETD:
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETD, (caddr_t)&idat, p);
		if (error)
			goto out;
		switch (idat) {
		case TTYDISC:
			idat = LINUX_N_TTY;
			break;
		case SLIPDISC:
			idat = LINUX_N_SLIP;
			break;
		case PPPDISC:
			idat = LINUX_N_PPP;
			break;
		/*
		 * Linux does not have the tablet line discipline.
		 */
		case TABLDISC:
		default:
			idat = -1;	/* XXX What should this be? */
			break;
		}
		error = copyout(&idat, SCARG(uap, data), sizeof idat);
		goto out;
	case LINUX_TIOCSETD:
		error = copyin(SCARG(uap, data), &idat, sizeof idat);
		if (error)
			goto out;
		switch (idat) {
		case LINUX_N_TTY:
			idat = TTYDISC;
			break;
		case LINUX_N_SLIP:
			idat = SLIPDISC;
			break;
		case LINUX_N_PPP:
			idat = PPPDISC;
			break;
		/*
		 * We can't handle the mouse line discipline Linux has.
		 */
		case LINUX_N_MOUSE:
		default:
			error = EINVAL;
			goto out;
		}
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCSETD, (caddr_t)&idat, p);
		goto out;
	case LINUX_TIOCLINUX:
		error = copyin(SCARG(uap, data), &tioclinux, sizeof tioclinux);
		if (error != 0)
			goto out;
		switch (tioclinux) {
		case LINUX_TIOCLINUX_KERNMSG:
			/*
			 * XXX needed to not fail for some things. Could
			 * try to use TIOCCONS, but the char argument
			 * specifies the VT #, not an fd.
			 */
			goto out;
		case LINUX_TIOCLINUX_COPY:
		case LINUX_TIOCLINUX_PASTE:
		case LINUX_TIOCLINUX_UNBLANK:
		case LINUX_TIOCLINUX_LOADLUT:
		case LINUX_TIOCLINUX_READSHIFT:
		case LINUX_TIOCLINUX_READMOUSE:
		case LINUX_TIOCLINUX_VESABLANK:
		case LINUX_TIOCLINUX_CURCONS:	/* could use VT_GETACTIVE */
			error = EINVAL;
			goto out;
		}
		break;
	case LINUX_TIOCGWINSZ:
		SCARG(&ia, com) = TIOCGWINSZ;
		break;
	case LINUX_TIOCSWINSZ:
		SCARG(&ia, com) = TIOCSWINSZ;
		break;
	case LINUX_TIOCMGET:
		SCARG(&ia, com) = TIOCMGET;
		break;
	case LINUX_TIOCMBIS:
		SCARG(&ia, com) = TIOCMBIS;
		break;
	case LINUX_TIOCMBIC:
		SCARG(&ia, com) = TIOCMBIC;
		break;
	case LINUX_TIOCMSET:
		SCARG(&ia, com) = TIOCMSET;
		break;
	case LINUX_TIOCGPGRP:
		SCARG(&ia, com) = TIOCGPGRP;
		break;
	case LINUX_TIOCSPGRP:
		SCARG(&ia, com) = TIOCSPGRP;
		break;
	case LINUX_FIONREAD:
		SCARG(&ia, com) = FIONREAD;
		break;
	case LINUX_FIONBIO:
		SCARG(&ia, com) = FIONBIO;
		break;
	case LINUX_FIOASYNC:
		SCARG(&ia, com) = FIOASYNC;
		break;
	case LINUX_TIOCEXCL:
		SCARG(&ia, com) = TIOCEXCL;
		break;
	case LINUX_TIOCNXCL:
		SCARG(&ia, com) = TIOCNXCL;
		break;
	case LINUX_TIOCSCTTY:
		SCARG(&ia, com) = TIOCSCTTY;
		break;
	case LINUX_TIOCCONS:
		SCARG(&ia, com) = TIOCCONS;
		break;
	case LINUX_TIOCNOTTY:
		SCARG(&ia, com) = TIOCNOTTY;
		break;
	case LINUX_TCSBRK:
		SCARG(&ia, com) = SCARG(uap, data) ? TIOCDRAIN : TIOCSBRK;
		break;
	case LINUX_TCXONC:
		switch ((int)SCARG(uap, data)) {
		case LINUX_TCOOFF:
			SCARG(&ia, com) = TIOCSTOP;
			break;
		case LINUX_TCOON:
			SCARG(&ia, com) = TIOCSTART;
			break;
		case LINUX_TCIOFF:
		case LINUX_TCION: {
			u_char c, *cp;
			struct sys_write_args wa;

			error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA,
			    (caddr_t)&tmpbts, p);
			if (error)
				goto out;
			if ((int)SCARG(uap, data) == LINUX_TCIOFF)
				c = tmpbts.c_cc[VSTOP];
			else
				c = tmpbts.c_cc[VSTART];
			if (c == _POSIX_VDISABLE)
				goto out;

			sg = stackgap_init(p);
			cp = (char *) stackgap_alloc(&sg, 1);
			if ((error = copyout(&c, cp, 1)))
				goto out;

			SCARG(&wa, fd) = SCARG(uap, fd);
			SCARG(&wa, buf) = cp;
			SCARG(&wa, nbyte) = 1;
			error = sys_write(p, &wa, retval);
			goto out;
		    }
		default:
			error = EINVAL;
			goto out;
		}
		SCARG(uap, data) = 0;
		break;
	default:
		error = EINVAL;
		goto out;
	}

	SCARG(&ia, fd) = SCARG(uap, fd);
	SCARG(&ia, data) = SCARG(uap, data);
	error = sys_ioctl(p, &ia, retval);

out:
	FRELE(fp, p);
	return (error);
}
@


1.18
log
@Indroduce fd_getfile_mode() and use it were fd_getfile() is directly
followed by a mode check.  This will simplify the ref/unref dance as
soon as fd_getfile() will increment fp's reference counter.

Idea from and ok guenther@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.17 2014/03/26 05:23:42 guenther Exp $	*/
@


1.17
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.16 2012/04/22 05:43:14 guenther Exp $	*/
d464 1
a464 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
a466 5

	if ((fp->f_flag & (FREAD | FWRITE)) == 0) {
		error = EBADF;
		goto out;
	}
@


1.16
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.15 2003/04/05 20:30:18 millert Exp $	*/
d696 1
a696 1
			sg = stackgap_init(p->p_emul);
@


1.15
log
@Add missing 230400 to linux_speeds array to match linux_spmasks.
Also make linux_spmasks const, since it is.  deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.14 2002/05/07 20:31:17 jasoni Exp $	*/
d723 1
a723 1
	FRELE(fp);
@


1.14
log
@minor style.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.13 2002/05/07 20:23:42 jasoni Exp $	*/
d55 1
a55 1
	9600, 19200, 38400, 57600, 115200
d58 1
a58 1
static int linux_spmasks[] = {
@


1.13
log
@support TIOCLINUX ioctl
- from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.12 2002/03/14 01:26:50 millert Exp $	*/
d66 1
a66 1
	struct termios *);
d68 1
a68 1
	struct linux_termio *);
d70 1
a70 1
	struct termios *);
d72 1
a72 1
	struct linux_termios *);
d478 2
a479 1
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts, p);
d492 2
a493 1
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts, p);
d514 2
a515 1
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts, p);
d528 2
a529 1
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts, p);
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.11 2002/02/13 20:43:42 jasoni Exp $	*/
d460 1
d593 24
@


1.11
log
@FREF/FRELE where required due to fd_getfile.
- ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.10 2001/10/26 12:03:27 art Exp $	*/
d65 8
a72 8
static void linux_termio_to_bsd_termios __P((struct linux_termio *,
	struct termios *));
static void bsd_termios_to_linux_termio __P((struct termios *,
	struct linux_termio *));
static void linux_termios_to_bsd_termios __P((struct linux_termios *,
	struct termios *));
static void bsd_termios_to_linux_termios __P((struct termios *,
	struct linux_termios *));
@


1.10
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.9 2001/05/24 06:00:09 jasoni Exp $	*/
d86 2
a87 2
	register struct linux_termio *lt;
	register struct termios *bts;
d169 2
a170 2
	register struct termios *bts;
	register struct linux_termio *lt;
d255 2
a256 2
	register struct linux_termios *lts;
	register struct termios *bts;
d343 2
a344 2
	register struct termios *bts;
	register struct linux_termios *lts;
d442 1
a442 1
	register struct proc *p;
d446 1
a446 1
	register struct linux_sys_ioctl_args /* {
d451 2
a452 2
	register struct file *fp;
	register struct filedesc *fdp;
d460 1
a460 1
	int error;
d465 1
d467 4
a470 2
	if ((fp->f_flag & (FREAD | FWRITE)) == 0)
		return (EBADF);
d479 1
a479 1
			return error;
d482 1
a482 3
		if (error)
			return error;
		return 0;
d492 1
a492 1
			return error;
d495 1
a495 1
			return error;
d509 1
a509 3
		if (error)
			return error;
		return 0;
d513 1
a513 1
			return error;
d516 1
a516 3
		if (error)
			return error;
		return 0;
d526 1
a526 1
			return error;
d529 1
a529 1
			return error;
d543 1
a543 3
		if (error)
			return error;
		return 0;
d547 1
a547 1
			return error;
d567 1
a567 3
		if (error)
			return error;
		return 0;
d571 1
a571 1
			return error;
d587 2
a588 1
			return EINVAL;
d591 1
a591 3
		if (error)
			return error;
		return 0;
d659 1
a659 1
				return error;
d665 1
a665 1
				return 0;
d670 1
a670 1
				return error;
d675 2
a676 1
			return sys_write(p, &wa, retval);
d679 2
a680 1
			return EINVAL;
d685 2
a686 1
		return EINVAL;
d691 5
a695 1
	return sys_ioctl(p, &ia, retval);
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.10 2001/10/26 12:03:27 art Exp $	*/
d65 8
a72 8
static void linux_termio_to_bsd_termios(struct linux_termio *,
    struct termios *);
static void bsd_termios_to_linux_termio(struct termios *,
    struct linux_termio *);
static void linux_termios_to_bsd_termios(struct linux_termios *,
    struct termios *);
static void bsd_termios_to_linux_termios(struct termios *,
    struct linux_termios *);
d86 2
a87 2
	struct linux_termio *lt;
	struct termios *bts;
d169 2
a170 2
	struct termios *bts;
	struct linux_termio *lt;
d255 2
a256 2
	struct linux_termios *lts;
	struct termios *bts;
d343 2
a344 2
	struct termios *bts;
	struct linux_termios *lts;
d442 1
a442 1
	struct proc *p;
d446 1
a446 1
	struct linux_sys_ioctl_args /* {
d451 2
a452 2
	struct file *fp;
	struct filedesc *fdp;
d460 1
a460 2
	char tioclinux;
	int error = 0;
a464 1
	FREF(fp);
d466 2
a467 4
	if ((fp->f_flag & (FREAD | FWRITE)) == 0) {
		error = EBADF;
		goto out;
	}
d474 1
a474 2
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts,
		    p);
d476 1
a476 1
			goto out;
d479 3
a481 1
		goto out;
d489 1
a489 2
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts,
		    p);
d491 1
a491 1
			goto out;
d494 1
a494 1
			goto out;
d508 3
a510 1
		goto out;
d512 1
a512 2
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts,
		    p);
d514 1
a514 1
			goto out;
d517 3
a519 1
		goto out;
d527 1
a527 2
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts,
		    p);
d529 1
a529 1
			goto out;
d532 1
a532 1
			goto out;
d546 3
a548 1
		goto out;
d552 1
a552 1
			goto out;
d572 3
a574 1
		goto out;
d578 1
a578 1
			goto out;
d594 1
a594 2
			error = EINVAL;
			goto out;
d597 3
a599 25
		goto out;
	case LINUX_TIOCLINUX:
		error = copyin(SCARG(uap, data), &tioclinux, sizeof tioclinux);
		if (error != 0)
			goto out;
		switch (tioclinux) {
		case LINUX_TIOCLINUX_KERNMSG:
			/*
			 * XXX needed to not fail for some things. Could
			 * try to use TIOCCONS, but the char argument
			 * specifies the VT #, not an fd.
			 */
			goto out;
		case LINUX_TIOCLINUX_COPY:
		case LINUX_TIOCLINUX_PASTE:
		case LINUX_TIOCLINUX_UNBLANK:
		case LINUX_TIOCLINUX_LOADLUT:
		case LINUX_TIOCLINUX_READSHIFT:
		case LINUX_TIOCLINUX_READMOUSE:
		case LINUX_TIOCLINUX_VESABLANK:
		case LINUX_TIOCLINUX_CURCONS:	/* could use VT_GETACTIVE */
			error = EINVAL;
			goto out;
		}
		break;
d667 1
a667 1
				goto out;
d673 1
a673 1
				goto out;
d678 1
a678 1
				goto out;
d683 1
a683 2
			error = sys_write(p, &wa, retval);
			goto out;
d686 1
a686 2
			error = EINVAL;
			goto out;
d691 1
a691 2
		error = EINVAL;
		goto out;
d696 1
a696 5
	error = sys_ioctl(p, &ia, retval);

out:
	FRELE(fp);
	return (error);
@


1.10.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 1
a55 1
	9600, 19200, 38400, 57600, 115200, 230400
d58 1
a58 1
static const int linux_spmasks[] = {
@


1.9
log
@style/cleanup (of function headers)
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.8 2000/08/18 17:40:24 niklas Exp $	*/
d463 1
a463 2
	if ((u_int)SCARG(uap, fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
@


1.8
log
@Stupid Linux redefined SBRK semantics
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.7 2000/08/18 14:56:59 niklas Exp $	*/
d441 1
a441 1
linux_ioctl_termios(p, uap, retval)
d443 3
d450 1
a450 3
	} */ *uap;
	register_t *retval;
{
@


1.7
log
@Add TCSBRK emulation.  bug reported by sparud@@crt.se
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.6 1999/07/18 00:12:04 deraadt Exp $	*/
d649 1
a649 1
		SCARG(&ia, com) = TIOCSBRK;
@


1.6
log
@TIOCM{GET,SET,BIS,BIC}, and TCXONC support
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.5 1997/12/10 13:35:53 provos Exp $	*/
d647 3
@


1.6.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.8 2000/08/18 17:40:24 niklas Exp $	*/
a646 3
		break;
	case LINUX_TCSBRK:
		SCARG(&ia, com) = SCARG(uap, data) ? TIOCDRAIN : TIOCSBRK;
@


1.6.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.6.4.1 2001/05/14 22:04:53 niklas Exp $	*/
d441 1
a441 1
linux_ioctl_termios(p, v, retval)
a442 3
	void *v;
	register_t *retval;
{
d447 3
a449 1
	} */ *uap = v;
@


1.6.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.6.4.2 2001/07/04 10:39:30 niklas Exp $	*/
d463 2
a464 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
@


1.6.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 2
a87 2
	struct linux_termio *lt;
	struct termios *bts;
d169 2
a170 2
	struct termios *bts;
	struct linux_termio *lt;
d255 2
a256 2
	struct linux_termios *lts;
	struct termios *bts;
d343 2
a344 2
	struct termios *bts;
	struct linux_termios *lts;
d442 1
a442 1
	struct proc *p;
d446 1
a446 1
	struct linux_sys_ioctl_args /* {
d451 2
a452 2
	struct file *fp;
	struct filedesc *fdp;
d460 1
a460 1
	int error = 0;
a464 1
	FREF(fp);
d466 2
a467 4
	if ((fp->f_flag & (FREAD | FWRITE)) == 0) {
		error = EBADF;
		goto out;
	}
d476 1
a476 1
			goto out;
d479 3
a481 1
		goto out;
d491 1
a491 1
			goto out;
d494 1
a494 1
			goto out;
d508 3
a510 1
		goto out;
d514 1
a514 1
			goto out;
d517 3
a519 1
		goto out;
d529 1
a529 1
			goto out;
d532 1
a532 1
			goto out;
d546 3
a548 1
		goto out;
d552 1
a552 1
			goto out;
d572 3
a574 1
		goto out;
d578 1
a578 1
			goto out;
d594 1
a594 2
			error = EINVAL;
			goto out;
d597 3
a599 1
		goto out;
d667 1
a667 1
				goto out;
d673 1
a673 1
				goto out;
d678 1
a678 1
				goto out;
d683 1
a683 2
			error = sys_write(p, &wa, retval);
			goto out;
d686 1
a686 2
			error = EINVAL;
			goto out;
d691 1
a691 2
		error = EINVAL;
		goto out;
d696 1
a696 5
	error = sys_ioctl(p, &ia, retval);

out:
	FRELE(fp);
	return (error);
@


1.6.4.5
log
@Merge in -current from about a week ago
@
text
@d65 8
a72 8
static void linux_termio_to_bsd_termios(struct linux_termio *,
	struct termios *);
static void bsd_termios_to_linux_termio(struct termios *,
	struct linux_termio *);
static void linux_termios_to_bsd_termios(struct linux_termios *,
	struct termios *);
static void bsd_termios_to_linux_termios(struct termios *,
	struct linux_termios *);
@


1.6.4.6
log
@Sync the SMP branch with 3.3
@
text
@d66 1
a66 1
    struct termios *);
d68 1
a68 1
    struct linux_termio *);
d70 1
a70 1
    struct termios *);
d72 1
a72 1
    struct linux_termios *);
a459 1
	char tioclinux;
d477 1
a477 2
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts,
		    p);
d490 1
a490 2
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts,
		    p);
d511 1
a511 2
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts,
		    p);
d524 1
a524 2
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGETA, (caddr_t)&tmpbts,
		    p);
a591 24
	case LINUX_TIOCLINUX:
		error = copyin(SCARG(uap, data), &tioclinux, sizeof tioclinux);
		if (error != 0)
			goto out;
		switch (tioclinux) {
		case LINUX_TIOCLINUX_KERNMSG:
			/*
			 * XXX needed to not fail for some things. Could
			 * try to use TIOCCONS, but the char argument
			 * specifies the VT #, not an fd.
			 */
			goto out;
		case LINUX_TIOCLINUX_COPY:
		case LINUX_TIOCLINUX_PASTE:
		case LINUX_TIOCLINUX_UNBLANK:
		case LINUX_TIOCLINUX_LOADLUT:
		case LINUX_TIOCLINUX_READSHIFT:
		case LINUX_TIOCLINUX_READMOUSE:
		case LINUX_TIOCLINUX_VESABLANK:
		case LINUX_TIOCLINUX_CURCONS:	/* could use VT_GETACTIVE */
			error = EINVAL;
			goto out;
		}
		break;
@


1.6.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.6.4.6 2003/03/27 23:53:47 niklas Exp $	*/
d55 1
a55 1
	9600, 19200, 38400, 57600, 115200, 230400
d58 1
a58 1
static const int linux_spmasks[] = {
@


1.5
log
@emulate set controlling tty ioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.4 1996/10/16 12:25:37 deraadt Exp $	*/
d456 1
d606 12
d647 39
@


1.4
log
@proto
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.3 1996/04/18 21:21:39 niklas Exp $	*/
d625 3
@


1.3
log
@Merge of NetBSD 960317
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_termios.c,v 1.2 1996/04/17 05:24:08 mickey Exp $	*/
d64 9
@


1.2
log
@Good fixes and changes from latest Net.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a63 10


static void linux_termio_to_bsd_termios __P((struct linux_termio *,
					     struct termios *));
static void bsd_termios_to_linux_termio __P((struct termios *,
					     struct linux_termio *));
static void linux_termios_to_bsd_termios __P((struct linux_termios *,
					      struct termios *));
static void bsd_termios_to_linux_termios __P((struct termios *,
					      struct linux_termios *));
@


1.1
log
@From NetBSD:
linux compatibility changes.
@
text
@d1 2
a2 1
/*	$NetBSD: linux_termios.c,v 1.1 1996/03/08 04:56:08 mycroft Exp $	*/
d65 10
d85 1
a85 1
static int
d168 1
a168 1
static int
d254 1
a254 1
static int
d342 1
a342 1
static int
@
