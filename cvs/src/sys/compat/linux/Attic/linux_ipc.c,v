head	1.19;
access;
symbols
	OPENBSD_5_9:1.18.0.4
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.6
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.6
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.4
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.2
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.12
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.8
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.14
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.12
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.10
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.10
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.8
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2016.03.02.15.41.48;	author naddy;	state dead;
branches;
next	1.18;
commitid	ZfNt0OHZhMg52abA;

1.18
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.17;
commitid	uzzBR7hz9ncd4O6G;

1.17
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2013.05.10.10.31.16;	author pirofti;	state Exp;
branches;
next	1.15;

1.15
date	2011.10.27.07.56.28;	author robert;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.19.23.35.22;	author pirofti;	state Exp;
branches;
next	1.13;

1.13
date	2011.09.19.23.28.12;	author pirofti;	state Exp;
branches;
next	1.12;

1.12
date	2011.09.19.22.49.37;	author pirofti;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.05.10.28.43;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.29.10.44.29;	author sturm;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.12.23.44.39;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.50;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.24.06.00.09;	author jasoni;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.03.13.08.19.41;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.23.22.35.38;	author jasoni;	state Exp;
branches;
next	1.4;

1.4
date	97.11.26.09.17.41;	author deraadt;	state Exp;
branches
	1.4.10.1;
next	1.3;

1.3
date	96.10.17.19.15.48;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.04.17.05.23.52;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.18;	author deraadt;	state Exp;
branches;
next	;

1.4.10.1
date	2001.05.14.22.04.44;	author niklas;	state Exp;
branches;
next	1.4.10.2;

1.4.10.2
date	2001.07.04.10.39.24;	author niklas;	state Exp;
branches;
next	1.4.10.3;

1.4.10.3
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.4.10.4;

1.4.10.4
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@remove the Linux emulation code, no longer referenced by anything
@
text
@/*	$OpenBSD: linux_ipc.c,v 1.18 2014/09/14 14:17:23 jsg Exp $	*/
/*	$NetBSD: linux_ipc.c,v 1.10 1996/04/05 00:01:44 christos Exp $	*/

/*
 * Copyright (c) 1995 Frank van der Linden
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project
 *      by Frank van der Linden
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <sys/msg.h>
#include <sys/uio.h>
#include <sys/time.h>
#include <sys/malloc.h>
#include <sys/mman.h>
#include <sys/systm.h>
#include <sys/stat.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <compat/linux/linux_types.h>
#include <compat/linux/linux_signal.h>
#include <compat/linux/linux_syscallargs.h>
#include <compat/linux/linux_util.h>
#include <compat/linux/linux_ipc.h>
#include <compat/linux/linux_msg.h>
#include <compat/linux/linux_shm.h>
#include <compat/linux/linux_sem.h>
#include <compat/linux/linux_ipccall.h>

/*
 * Stuff to deal with the SysV ipc/shm/semaphore interface in Linux.
 * The main difference is, that Linux handles it all via one
 * system call, which has the usual maximum amount of 5 arguments.
 * This results in a kludge for calls that take 6 of them.
 *
 * The SYSVXXXX options have to be enabled to get the appropriate
 * functions to work.
 */

#ifdef SYSVSEM
int linux_semop(struct proc *, void *, register_t *);
int linux_semget(struct proc *, void *, register_t *);
int linux_semctl(struct proc *, void *, register_t *);
int bsd_to_linux_semid_ds(struct semid_ds *, struct linux_semid_ds *);
void linux_to_bsd_semid_ds(struct linux_semid_ds *, struct semid_ds *);
#endif

#ifdef SYSVMSG
int linux_msgsnd(struct proc *, void *, register_t *);
int linux_msgrcv(struct proc *, void *, register_t *);
int linux_msgget(struct proc *, void *, register_t *);
int linux_msgctl(struct proc *, void *, register_t *);
void linux_to_bsd_msqid_ds(struct linux_msqid_ds *, struct msqid_ds *);
int bsd_to_linux_msqid_ds(struct msqid_ds *, struct linux_msqid_ds *);
#endif

#ifdef SYSVSHM
int linux_shmat(struct proc *, void *, register_t *);
int linux_shmdt(struct proc *, void *, register_t *);
int linux_shmget(struct proc *, void *, register_t *);
int linux_shmctl(struct proc *, void *, register_t *);
void linux_to_bsd_shmid_ds(struct linux_shmid_ds *, struct shmid_ds *);
int bsd_to_linux_shmid_ds(struct shmid_ds *, struct linux_shmid_ds *);
#endif

#if defined(SYSVMSG) || defined(SYSVSEM) || defined(SYSVSHM)
void linux_to_bsd_ipc_perm(struct linux_ipc_perm *, struct ipc_perm *);
void bsd_to_linux_ipc_perm(struct ipc_perm *, struct linux_ipc_perm *);
#endif

int
linux_sys_ipc(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ipc_args /* {
		syscallarg(int) what;
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
		syscallarg(caddr_t) ptr;
	} */ *uap = v;

	switch (SCARG(uap, what)) {
#ifdef SYSVSEM
	case LINUX_SYS_semop:
		return linux_semop(p, uap, retval);
	case LINUX_SYS_semget:
		return linux_semget(p, uap, retval);
	case LINUX_SYS_semctl:
		return linux_semctl(p, uap, retval);
#endif
#ifdef SYSVMSG
	case LINUX_SYS_msgsnd:
		return linux_msgsnd(p, uap, retval);
	case LINUX_SYS_msgrcv:
		return linux_msgrcv(p, uap, retval);
	case LINUX_SYS_msgget:
		return linux_msgget(p, uap, retval);
	case LINUX_SYS_msgctl:
		return linux_msgctl(p, uap, retval);
#endif
#ifdef SYSVSHM
	case LINUX_SYS_shmat:
		return linux_shmat(p, uap, retval);
	case LINUX_SYS_shmdt:
		return linux_shmdt(p, uap, retval);
	case LINUX_SYS_shmget:
		return linux_shmget(p, uap, retval);
	case LINUX_SYS_shmctl:
		return linux_shmctl(p, uap, retval);
#endif
	default:
		return ENOSYS;
	}
}

#if defined(SYSVMSG) || defined(SYSVSEM) || defined(SYSVSHM)
/*
 * Convert between Linux and OpenBSD ipc_perm structures. Only the
 * order of the fields is different.
 */
void
linux_to_bsd_ipc_perm(lpp, bpp)
	struct linux_ipc_perm *lpp;
	struct ipc_perm *bpp;
{

	bpp->key = lpp->l_key;
	bpp->uid = lpp->l_uid;
	bpp->gid = lpp->l_gid;
	bpp->cuid = lpp->l_cuid;
	bpp->cgid = lpp->l_cgid;
	bpp->mode = lpp->l_mode;
	bpp->seq = lpp->l_seq;
}

void
bsd_to_linux_ipc_perm(bpp, lpp)
	struct ipc_perm *bpp;
	struct linux_ipc_perm *lpp;
{

	lpp->l_key = bpp->key;
	lpp->l_uid = bpp->uid;
	lpp->l_gid = bpp->gid;
	lpp->l_cuid = bpp->cuid;
	lpp->l_cgid = bpp->cgid;
	lpp->l_mode = bpp->mode;
	lpp->l_seq = bpp->seq;
}
#endif

#ifdef SYSVSEM
/*
 * Semaphore operations. Most constants and structures are the same on
 * both systems. Only semctl() needs some extra work.
 */

/*
 * Convert between Linux and OpenBSD semid_ds structures.
 */
int
bsd_to_linux_semid_ds(bs, ls)
	struct semid_ds *bs;
	struct linux_semid_ds *ls;
{

	bsd_to_linux_ipc_perm(&bs->sem_perm, &ls->l_sem_perm);
	if (bs->sem_otime > LINUX_TIME_MAX)
		return EOVERFLOW;
	ls->l_sem_otime = (linux_time_t)bs->sem_otime;
	if (bs->sem_ctime > LINUX_TIME_MAX)
		return EOVERFLOW;
	ls->l_sem_ctime = (linux_time_t)bs->sem_ctime;
	ls->l_sem_nsems = bs->sem_nsems;
	ls->l_sem_base = bs->sem_base;

	return 0;
}

void
linux_to_bsd_semid_ds(ls, bs)
	struct linux_semid_ds *ls;
	struct semid_ds *bs;
{

	linux_to_bsd_ipc_perm(&ls->l_sem_perm, &bs->sem_perm);
	bs->sem_otime = ls->l_sem_otime;
	bs->sem_ctime = ls->l_sem_ctime;
	bs->sem_nsems = ls->l_sem_nsems;
	bs->sem_base = ls->l_sem_base;
}

int
linux_semop(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ipc_args /* {
		syscallarg(int) what;
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
		syscallarg(caddr_t) ptr;
	} */ *uap = v;
	struct sys_semop_args bsa;

	SCARG(&bsa, semid) = SCARG(uap, a1);
	SCARG(&bsa, sops) = (struct sembuf *)SCARG(uap, ptr);
	SCARG(&bsa, nsops) = SCARG(uap, a2);

	return sys_semop(p, &bsa, retval);
}

int
linux_semget(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ipc_args /* {
		syscallarg(int) what;
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
		syscallarg(caddr_t) ptr;
	} */ *uap = v;
	struct sys_semget_args bsa;

	SCARG(&bsa, key) = (key_t)SCARG(uap, a1);
	SCARG(&bsa, nsems) = SCARG(uap, a2);
	SCARG(&bsa, semflg) = SCARG(uap, a3);

	return sys_semget(p, &bsa, retval);
}

/*
 * Most of this can be handled by directly passing the arguments on,
 * buf IPC_* require a lot of copy{in,out} because of the extra indirection
 * (we are passed a pointer to a union cointaining a pointer to a semid_ds
 * structure.
 */
int
linux_semctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ipc_args /* {
		syscallarg(int) what;
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
		syscallarg(caddr_t) ptr;
	} */ *uap = v;
	caddr_t sg, unptr, dsp, ldsp;
	int error, cmd;
	struct sys___semctl_args bsa;
	struct linux_semid_ds lm;
	struct semid_ds bm;

	SCARG(&bsa, semid) = SCARG(uap, a1);
	SCARG(&bsa, semnum) = SCARG(uap, a2);
	SCARG(&bsa, cmd) = SCARG(uap, a3);
	SCARG(&bsa, arg) = (union semun *)SCARG(uap, ptr);
	switch(SCARG(uap, a3)) {
	case LINUX_GETVAL:
		cmd = GETVAL;
		break;
	case LINUX_GETPID:
		cmd = GETPID;
		break;
	case LINUX_GETNCNT:
		cmd = GETNCNT;
		break;
	case LINUX_GETZCNT:
		cmd = GETZCNT;
		break;
	case LINUX_SETVAL:
		cmd = SETVAL;
		break;
	case LINUX_IPC_RMID:
		cmd = IPC_RMID;
		break;
	case LINUX_IPC_SET:
		if ((error = copyin(SCARG(uap, ptr), &ldsp, sizeof ldsp)))
			return error;
		if ((error = copyin(ldsp, (caddr_t)&lm, sizeof lm)))
			return error;
		linux_to_bsd_semid_ds(&lm, &bm);
		sg = stackgap_init(p);
		unptr = stackgap_alloc(&sg, sizeof (union semun));
		dsp = stackgap_alloc(&sg, sizeof (struct semid_ds));
		if ((error = copyout((caddr_t)&bm, dsp, sizeof bm)))
			return error;
		if ((error = copyout((caddr_t)&dsp, unptr, sizeof dsp)))
			return error;
		SCARG(&bsa, arg) = (union semun *)unptr;
		return sys___semctl(p, &bsa, retval);
	case LINUX_IPC_STAT:
		sg = stackgap_init(p);
		unptr = stackgap_alloc(&sg, sizeof (union semun));
		dsp = stackgap_alloc(&sg, sizeof (struct semid_ds));
		if ((error = copyout((caddr_t)&dsp, unptr, sizeof dsp)))
			return error;
		SCARG(&bsa, arg) = (union semun *)unptr;
		if ((error = sys___semctl(p, &bsa, retval)))
			return error;
		if ((error = copyin(dsp, (caddr_t)&bm, sizeof bm)))
			return error;
		if ((error = bsd_to_linux_semid_ds(&bm, &lm)))
			return error;
		if ((error = copyin(SCARG(uap, ptr), &ldsp, sizeof ldsp)))
			return error;
		return copyout((caddr_t)&lm, ldsp, sizeof lm);
	default:
		return EINVAL;
	}
	SCARG(&bsa, cmd) = cmd;

	return sys___semctl(p, &bsa, retval);
}
#endif /* SYSVSEM */

#ifdef SYSVMSG

void
linux_to_bsd_msqid_ds(lmp, bmp)
	struct linux_msqid_ds *lmp;
	struct msqid_ds *bmp;
{

	linux_to_bsd_ipc_perm(&lmp->l_msg_perm, &bmp->msg_perm);
	bmp->msg_first = lmp->l_msg_first;
	bmp->msg_last = lmp->l_msg_last;
	bmp->msg_cbytes = lmp->l_msg_cbytes;
	bmp->msg_qnum = lmp->l_msg_qnum;
	bmp->msg_qbytes = lmp->l_msg_qbytes;
	bmp->msg_lspid = lmp->l_msg_lspid;
	bmp->msg_lrpid = lmp->l_msg_lrpid;
	bmp->msg_stime = lmp->l_msg_stime;
	bmp->msg_rtime = lmp->l_msg_rtime;
	bmp->msg_ctime = lmp->l_msg_ctime;
}

int
bsd_to_linux_msqid_ds(bmp, lmp)
	struct msqid_ds *bmp;
	struct linux_msqid_ds *lmp;
{

	bsd_to_linux_ipc_perm(&bmp->msg_perm, &lmp->l_msg_perm);
	lmp->l_msg_first = bmp->msg_first;
	lmp->l_msg_last = bmp->msg_last;
	lmp->l_msg_cbytes = bmp->msg_cbytes;
	lmp->l_msg_qnum = bmp->msg_qnum;
	lmp->l_msg_qbytes = bmp->msg_qbytes;
	lmp->l_msg_lspid = bmp->msg_lspid;
	lmp->l_msg_lrpid = bmp->msg_lrpid;

	if (bmp->msg_stime > LINUX_TIME_MAX)
		return EOVERFLOW;
	lmp->l_msg_stime = (linux_time_t)bmp->msg_stime;
	if (bmp->msg_rtime > LINUX_TIME_MAX)
		return EOVERFLOW;
	lmp->l_msg_rtime = (linux_time_t)bmp->msg_rtime;
	if (bmp->msg_ctime > LINUX_TIME_MAX)
		return EOVERFLOW;
	lmp->l_msg_ctime = (linux_time_t)bmp->msg_ctime;

	return 0;
}

int
linux_msgsnd(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ipc_args /* {
		syscallarg(int) what;
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
		syscallarg(caddr_t) ptr;
	} */ *uap = v;
	struct sys_msgsnd_args bma;

	SCARG(&bma, msqid) = SCARG(uap, a1);
	SCARG(&bma, msgp) = SCARG(uap, ptr);
	SCARG(&bma, msgsz) = SCARG(uap, a2);
	SCARG(&bma, msgflg) = SCARG(uap, a3);

	return sys_msgsnd(p, &bma, retval);
}

int
linux_msgrcv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ipc_args /* {
		syscallarg(int) what;
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
		syscallarg(caddr_t) ptr;
	} */ *uap = v;
	struct sys_msgrcv_args bma;
	struct linux_msgrcv_msgarg kluge;
	int error;

	if ((error = copyin(SCARG(uap, ptr), &kluge, sizeof kluge)))
		return error;

	SCARG(&bma, msqid) = SCARG(uap, a1);
	SCARG(&bma, msgp) = kluge.msg;
	SCARG(&bma, msgsz) = SCARG(uap, a2);
	SCARG(&bma, msgtyp) = kluge.type;
	SCARG(&bma, msgflg) = SCARG(uap, a3);

	return sys_msgrcv(p, &bma, retval);
}

int
linux_msgget(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ipc_args /* {
		syscallarg(int) what;
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
		syscallarg(caddr_t) ptr;
	} */ *uap = v;
	struct sys_msgget_args bma;

	SCARG(&bma, key) = (key_t)SCARG(uap, a1);
	SCARG(&bma, msgflg) = SCARG(uap, a2);

	return sys_msgget(p, &bma, retval);
}

int
linux_msgctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ipc_args /* {
		syscallarg(int) what;
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
		syscallarg(caddr_t) ptr;
	} */ *uap = v;
	struct sys_msgctl_args bma;
	caddr_t umsgptr, sg;
	struct linux_msqid_ds lm;
	struct msqid_ds bm;
	int error;

	SCARG(&bma, msqid) = SCARG(uap, a1);
	SCARG(&bma, cmd) = SCARG(uap, a2);
	switch (SCARG(uap, a2)) {
	case LINUX_IPC_RMID:
		return sys_msgctl(p, &bma, retval);
	case LINUX_IPC_SET:
		if ((error = copyin(SCARG(uap, ptr), (caddr_t)&lm, sizeof lm)))
			return error;
		linux_to_bsd_msqid_ds(&lm, &bm);
		sg = stackgap_init(p);
		umsgptr = stackgap_alloc(&sg, sizeof bm);
		if ((error = copyout((caddr_t)&bm, umsgptr, sizeof bm)))
			return error;
		SCARG(&bma, buf) = (struct msqid_ds *)umsgptr;
		return sys_msgctl(p, &bma, retval);
	case LINUX_IPC_STAT:
		sg = stackgap_init(p);
		umsgptr = stackgap_alloc(&sg, sizeof (struct msqid_ds));
		SCARG(&bma, buf) = (struct msqid_ds *)umsgptr;
		if ((error = sys_msgctl(p, &bma, retval)))
			return error;
		if ((error = copyin(umsgptr, (caddr_t)&bm, sizeof bm)))
			return error;
		if ((error = bsd_to_linux_msqid_ds(&bm, &lm)))
			return error;
		return copyout((caddr_t)&lm, SCARG(uap, ptr), sizeof lm);
	}
	return EINVAL;
}
#endif /* SYSVMSG */

#ifdef SYSVSHM
/*
 * shmat(2). Very straightforward, except that Linux passes a pointer
 * in which the return value is to be passed. This is subsequently
 * handled by libc, apparently.
 */
int
linux_shmat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ipc_args /* {
		syscallarg(int) what;
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
		syscallarg(caddr_t) ptr;
	} */ *uap = v;
	struct sys_shmat_args bsa;
	int error;

	SCARG(&bsa, shmid) = SCARG(uap, a1);
	SCARG(&bsa, shmaddr) = SCARG(uap, ptr);
	SCARG(&bsa, shmflg) = SCARG(uap, a2);

	if ((error = sys_shmat(p, &bsa, retval)))
		return error;

	if ((error = copyout(&retval[0], (caddr_t) SCARG(uap, a3),
	     sizeof retval[0])))
		return error;

	retval[0] = 0;
	return 0;
}

/*
 * shmdt(): this could have been mapped directly, if it wasn't for
 * the extra indirection by the linux_ipc system call.
 */
int
linux_shmdt(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ipc_args /* {
		syscallarg(int) what;
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
		syscallarg(caddr_t) ptr;
	} */ *uap = v;
	struct sys_shmdt_args bsa;

	SCARG(&bsa, shmaddr) = SCARG(uap, ptr);

	return sys_shmdt(p, &bsa, retval);
}

/*
 * Same story as shmdt.
 */
int
linux_shmget(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ipc_args /* {
		syscallarg(int) what;
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
		syscallarg(caddr_t) ptr;
	} */ *uap = v;
	struct sys_shmget_args bsa;

	SCARG(&bsa, key) = SCARG(uap, a1);
	SCARG(&bsa, size) = SCARG(uap, a2);
	SCARG(&bsa, shmflg) = SCARG(uap, a3);

	return sys_shmget(p, &bsa, retval);
}

/*
 * Convert between Linux and OpenBSD shmid_ds structures.
 * The order of the fields is once again the difference, and
 * we also need a place to store the internal data pointer
 * in, which is unfortunately stored in this structure.
 *
 * We abuse a Linux internal field for that.
 */
void
linux_to_bsd_shmid_ds(lsp, bsp)
	struct linux_shmid_ds *lsp;
	struct shmid_ds *bsp;
{

	linux_to_bsd_ipc_perm(&lsp->l_shm_perm, &bsp->shm_perm);
	bsp->shm_segsz = lsp->l_shm_segsz;
	bsp->shm_lpid = lsp->l_shm_lpid;
	bsp->shm_cpid = lsp->l_shm_cpid;
	bsp->shm_nattch = lsp->l_shm_nattch;
	bsp->shm_atime = lsp->l_shm_atime;
	bsp->shm_dtime = lsp->l_shm_dtime;
	bsp->shm_ctime = lsp->l_shm_ctime;
	bsp->shm_internal = lsp->l_private2;	/* XXX Oh well. */
}

int
bsd_to_linux_shmid_ds(bsp, lsp)
	struct shmid_ds *bsp;
	struct linux_shmid_ds *lsp;
{

	bsd_to_linux_ipc_perm(&bsp->shm_perm, &lsp->l_shm_perm);
	lsp->l_shm_segsz = bsp->shm_segsz;
	lsp->l_shm_lpid = bsp->shm_lpid;
	lsp->l_shm_cpid = bsp->shm_cpid;
	lsp->l_shm_nattch = bsp->shm_nattch;
	if (bsp->shm_atime > LINUX_TIME_MAX)
		return EOVERFLOW;
	lsp->l_shm_atime = (linux_time_t)bsp->shm_atime;
	if (bsp->shm_dtime > LINUX_TIME_MAX)
		return EOVERFLOW;
	lsp->l_shm_dtime = (linux_time_t)bsp->shm_dtime;
	if (bsp->shm_ctime > LINUX_TIME_MAX)
		return EOVERFLOW;
	lsp->l_shm_ctime = (linux_time_t)bsp->shm_ctime;
	lsp->l_private2 = bsp->shm_internal;	/* XXX */

	return 0;
}

/*
 * shmctl. Not implemented (for now): IPC_INFO, SHM_INFO, SHM_STAT
 * SHM_LOCK and SHM_UNLOCK are passed on, but currently not implemented
 * by OpenBSD itself.
 *
 * The usual structure conversion and massaging is done.
 */
int
linux_shmctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ipc_args /* {
		syscallarg(int) what;
		syscallarg(int) a1;
		syscallarg(int) a2;
		syscallarg(int) a3;
		syscallarg(caddr_t) ptr;
	} */ *uap = v;
	int error;
	caddr_t sg;
	struct sys_shmctl_args bsa;
	struct shmid_ds *bsp, bs;
	struct linux_shmid_ds lseg;

	switch (SCARG(uap, a2)) {
	case LINUX_IPC_STAT:
		sg = stackgap_init(p);
		bsp = stackgap_alloc(&sg, sizeof (struct shmid_ds));
		SCARG(&bsa, shmid) = SCARG(uap, a1);
		SCARG(&bsa, cmd) = IPC_STAT;
		SCARG(&bsa, buf) = bsp;
		if ((error = sys_shmctl(p, &bsa, retval)))
			return error;
		if ((error = copyin((caddr_t) bsp, (caddr_t) &bs, sizeof bs)))
			return error;
		if ((error = bsd_to_linux_shmid_ds(&bs, &lseg)))
			return error;
		return copyout((caddr_t) &lseg, SCARG(uap, ptr), sizeof lseg);
	case LINUX_IPC_SET:
		if ((error = copyin(SCARG(uap, ptr), (caddr_t) &lseg,
		     sizeof lseg)))
			return error;
		linux_to_bsd_shmid_ds(&lseg, &bs);
		sg = stackgap_init(p);
		bsp = stackgap_alloc(&sg, sizeof (struct shmid_ds));
		if ((error = copyout((caddr_t) &bs, (caddr_t) bsp, sizeof bs)))
			return error;
		SCARG(&bsa, shmid) = SCARG(uap, a1);
		SCARG(&bsa, cmd) = IPC_SET;
		SCARG(&bsa, buf) = bsp;
		return sys_shmctl(p, &bsa, retval);
	case LINUX_IPC_RMID:
	case LINUX_SHM_LOCK:
	case LINUX_SHM_UNLOCK:
		SCARG(&bsa, shmid) = SCARG(uap, a1);
		switch (SCARG(uap, a2)) {
		case LINUX_IPC_RMID:
			SCARG(&bsa, cmd) = IPC_RMID;
			break;
		case LINUX_SHM_LOCK:
			SCARG(&bsa, cmd) = SHM_LOCK;
			break;
		case LINUX_SHM_UNLOCK:
			SCARG(&bsa, cmd) = SHM_UNLOCK;
			break;
		}
		SCARG(&bsa, buf) = NULL;
		return sys_shmctl(p, &bsa, retval);
	case LINUX_IPC_INFO:
	case LINUX_SHM_STAT:
	case LINUX_SHM_INFO:
	default:
		return EINVAL;
	}
}
#endif /* SYSVSHM */

int
linux_sys_pipe2(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_pipe2_args *uap = v;
	struct sys_pipe_args pargs;

	/*
	 * We don't really support pipe2, but glibc falls back to pipe
	 * if we signal that.
	 */
	if (SCARG(uap, flags) != 0)
		return ENOSYS;

	/* If no flag is set then this is a plain pipe call. */
	SCARG(&pargs, fdp) = SCARG(uap, fdp);
	return sys_pipe(p, &pargs, retval);
}
@


1.18
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.17 2014/03/26 05:23:42 guenther Exp $	*/
@


1.17
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.16 2013/05/10 10:31:16 pirofti Exp $	*/
a40 1
#include <sys/proc.h>
@


1.16
log
@compat_linux: Add support for future time_t and ino_t size enlargements.

Reviewed by guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.15 2011/10/27 07:56:28 robert Exp $	*/
d326 1
a326 1
		sg = stackgap_init(p->p_emul);
d336 1
a336 1
		sg = stackgap_init(p->p_emul);
d510 1
a510 1
		sg = stackgap_init(p->p_emul);
d517 1
a517 1
		sg = stackgap_init(p->p_emul);
d696 1
a696 1
		sg = stackgap_init(p->p_emul);
d713 1
a713 1
		sg = stackgap_init(p->p_emul);
@


1.15
log
@Allow segments to be used even after they were marked for deletion with
the IPC_RMID flag.
This is permitted as an extension beyond the standards and this is similar
to what other operating systems like linux do.

Because compat_linux(8) was emulating this already, remove that code
since now this is the default.

input from oga@@, guenther@@, jmc@@, deraadt@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.14 2011/09/19 23:35:22 pirofti Exp $	*/
d76 1
a76 1
void bsd_to_linux_semid_ds(struct semid_ds *, struct linux_semid_ds *);
d86 1
a86 1
void bsd_to_linux_msqid_ds(struct msqid_ds *, struct linux_msqid_ds *);
d95 1
a95 1
void bsd_to_linux_shmid_ds(struct shmid_ds *, struct linux_shmid_ds *);
d196 1
a196 1
void
d203 6
a208 2
	ls->l_sem_otime = bs->sem_otime;
	ls->l_sem_ctime = bs->sem_ctime;
d211 2
d346 2
a347 1
		bsd_to_linux_semid_ds(&bm, &lm);
d381 1
a381 1
void
d395 12
a406 3
	lmp->l_msg_stime = bmp->msg_stime;
	lmp->l_msg_rtime = bmp->msg_rtime;
	lmp->l_msg_ctime = bmp->msg_ctime;
d524 2
a525 1
		bsd_to_linux_msqid_ds(&bm, &lm);
d643 1
a643 1
void
d654 9
a662 3
	lsp->l_shm_atime = bsp->shm_atime;
	lsp->l_shm_dtime = bsp->shm_dtime;
	lsp->l_shm_ctime = bsp->shm_ctime;
d664 2
d705 2
a706 1
		bsd_to_linux_shmid_ds(&bs, &lseg);
@


1.14
log
@Gah, no cookie for me.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.13 2011/09/19 23:28:12 pirofti Exp $	*/
a596 2

	SCARG(&bsa, shmflg) |= _SHM_RMLINGER;
@


1.13
log
@Fix comments, they really made sense before splitting them.

Noticed by fgs@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.12 2011/09/19 22:49:37 pirofti Exp $	*/
d732 1
a732 1
	 * /
@


1.12
log
@Add pipe2. Okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.11 2009/09/05 10:28:43 miod Exp $	*/
d731 1
a731 1
	 * we return signal that.
d736 1
a736 1
	/* If no flag is set then the this is a plain pipe call. */
@


1.11
log
@Fix various cases of stackgap_alloc() size arguments not being computed
correctly, usually yielding the right value on 32 bit machines because
sizeof int == sizeof pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.10 2007/05/29 10:44:29 sturm Exp $	*/
d722 18
@


1.10
log
@adapt from netbsd:
fold sys_shmat1() back into sys_shmat(), instead add flag for shmget(2)
to specify that later shmat(2) for the shared memory segment should succeed
even if the segment would be marked removed; use this to implement the
Linux-compatible semantics of shmat(2)

this fixes current opera with shm

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.9 2003/10/12 23:44:39 millert Exp $	*/
d331 1
a331 1
		unptr = stackgap_alloc(&sg, sizeof (union semun *));
@


1.9
log
@Linux shmat allows lookup of segments that are marked as removed so
our Linux compat should too.  From marius aamodt eriksen
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.8 2002/03/14 01:26:50 millert Exp $	*/
d541 1
a541 1
	if ((error = sys_shmat1(p, &bsa, retval, 1)))
d597 2
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.7 2001/05/24 06:00:09 jasoni Exp $	*/
d541 1
a541 1
	if ((error = sys_shmat(p, &bsa, retval)))
@


1.7
log
@style/cleanup (of function headers)
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.6 2001/03/13 08:19:41 csapuntz Exp $	*/
d73 5
a77 5
int linux_semop __P((struct proc *, void *, register_t *));
int linux_semget __P((struct proc *, void *, register_t *));
int linux_semctl __P((struct proc *, void *, register_t *));
void bsd_to_linux_semid_ds __P((struct semid_ds *, struct linux_semid_ds *));
void linux_to_bsd_semid_ds __P((struct linux_semid_ds *, struct semid_ds *));
d81 6
a86 6
int linux_msgsnd __P((struct proc *, void *, register_t *));
int linux_msgrcv __P((struct proc *, void *, register_t *));
int linux_msgget __P((struct proc *, void *, register_t *));
int linux_msgctl __P((struct proc *, void *, register_t *));
void linux_to_bsd_msqid_ds __P((struct linux_msqid_ds *, struct msqid_ds *));
void bsd_to_linux_msqid_ds __P((struct msqid_ds *, struct linux_msqid_ds *));
d90 6
a95 6
int linux_shmat __P((struct proc *, void *, register_t *));
int linux_shmdt __P((struct proc *, void *, register_t *));
int linux_shmget __P((struct proc *, void *, register_t *));
int linux_shmctl __P((struct proc *, void *, register_t *));
void linux_to_bsd_shmid_ds __P((struct linux_shmid_ds *, struct shmid_ds *));
void bsd_to_linux_shmid_ds __P((struct shmid_ds *, struct linux_shmid_ds *));
d99 2
a100 2
void linux_to_bsd_ipc_perm __P((struct linux_ipc_perm *, struct ipc_perm *));
void bsd_to_linux_ipc_perm __P((struct ipc_perm *, struct linux_ipc_perm *));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.7 2001/05/24 06:00:09 jasoni Exp $	*/
d73 5
a77 5
int linux_semop(struct proc *, void *, register_t *);
int linux_semget(struct proc *, void *, register_t *);
int linux_semctl(struct proc *, void *, register_t *);
void bsd_to_linux_semid_ds(struct semid_ds *, struct linux_semid_ds *);
void linux_to_bsd_semid_ds(struct linux_semid_ds *, struct semid_ds *);
d81 6
a86 6
int linux_msgsnd(struct proc *, void *, register_t *);
int linux_msgrcv(struct proc *, void *, register_t *);
int linux_msgget(struct proc *, void *, register_t *);
int linux_msgctl(struct proc *, void *, register_t *);
void linux_to_bsd_msqid_ds(struct linux_msqid_ds *, struct msqid_ds *);
void bsd_to_linux_msqid_ds(struct msqid_ds *, struct linux_msqid_ds *);
d90 6
a95 6
int linux_shmat(struct proc *, void *, register_t *);
int linux_shmdt(struct proc *, void *, register_t *);
int linux_shmget(struct proc *, void *, register_t *);
int linux_shmctl(struct proc *, void *, register_t *);
void linux_to_bsd_shmid_ds(struct linux_shmid_ds *, struct shmid_ds *);
void bsd_to_linux_shmid_ds(struct shmid_ds *, struct linux_shmid_ds *);
d99 2
a100 2
void linux_to_bsd_ipc_perm(struct linux_ipc_perm *, struct ipc_perm *);
void bsd_to_linux_ipc_perm(struct ipc_perm *, struct linux_ipc_perm *);
@


1.6
log
@

Fix copyout bug in LINUX_IPC_SET. Thanks to Dawson Engler & team at Stanford.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.5 2000/07/23 22:35:38 jasoni Exp $	*/
d73 3
a75 6
int linux_semop __P((struct proc *, struct linux_sys_ipc_args *,
    register_t *));
int linux_semget __P((struct proc *, struct linux_sys_ipc_args *,
    register_t *));
int linux_semctl __P((struct proc *, struct linux_sys_ipc_args *,
    register_t *));
d81 4
a84 8
int linux_msgsnd __P((struct proc *, struct linux_sys_ipc_args *,
    register_t *));
int linux_msgrcv __P((struct proc *, struct linux_sys_ipc_args *,
    register_t *));
int linux_msgget __P((struct proc *, struct linux_sys_ipc_args *,
    register_t *));
int linux_msgctl __P((struct proc *, struct linux_sys_ipc_args *,
    register_t *));
d90 4
a93 8
int linux_shmat __P((struct proc *, struct linux_sys_ipc_args *,
    register_t *));
int linux_shmdt __P((struct proc *, struct linux_sys_ipc_args *,
    register_t *));
int linux_shmget __P((struct proc *, struct linux_sys_ipc_args *,
    register_t *));
int linux_shmctl __P((struct proc *, struct linux_sys_ipc_args *,
    register_t *));
d223 1
a223 1
linux_semop(p, uap, retval)
d225 3
d234 1
a234 3
	} */ *uap;
	register_t *retval;
{
d245 1
a245 1
linux_semget(p, uap, retval)
d247 3
d256 1
a256 3
	} */ *uap;
	register_t *retval;
{
d273 1
a273 1
linux_semctl(p, uap, retval)
d275 3
d284 1
a284 3
	} */ *uap;
	register_t *retval;
{
d394 1
a394 1
linux_msgsnd(p, uap, retval)
d396 3
d405 1
a405 3
	} */ *uap;
	register_t *retval;
{
d417 1
a417 1
linux_msgrcv(p, uap, retval)
d419 3
d428 1
a428 3
	} */ *uap;
	register_t *retval;
{
d446 1
a446 1
linux_msgget(p, uap, retval)
d448 3
d457 1
a457 3
	} */ *uap;
	register_t *retval;
{
d467 1
a467 1
linux_msgctl(p, uap, retval)
d469 3
d478 1
a478 3
	} */ *uap;
	register_t *retval;
{
d522 1
a522 1
linux_shmat(p, uap, retval)
d524 3
d533 1
a533 3
	} */ *uap;
	register_t *retval;
{
d557 1
a557 1
linux_shmdt(p, uap, retval)
d559 3
d568 1
a568 3
	} */ *uap;
	register_t *retval;
{
d580 1
a580 1
linux_shmget(p, uap, retval)
d582 3
d591 1
a591 3
	} */ *uap;
	register_t *retval;
{
d651 1
a651 1
linux_shmctl(p, uap, retval)
d653 3
d662 1
a662 3
	} */ *uap;
	register_t *retval;
{
@


1.5
log
@OpenBSD -> NetBSD where previously missed.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.4 1997/11/26 09:17:41 deraadt Exp $	*/
d689 1
a689 1
		if ((error = copyout((caddr_t) bsp, (caddr_t) &bs, sizeof bs)))
@


1.4
log
@fix shmctl IPC_STAT
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.3 1996/10/17 19:15:48 niklas Exp $	*/
d164 1
a164 1
 * Convert between Linux and NetBSD ipc_perm structures. Only the
d205 1
a205 1
 * Convert between Linux and NetBSD semid_ds structures.
d603 1
a603 1
 * Convert between Linux and NetBSD shmid_ds structures.
d647 1
a647 1
 * by NetBSD itself.
@


1.4.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.6 2001/03/13 08:19:41 csapuntz Exp $	*/
d164 1
a164 1
 * Convert between Linux and OpenBSD ipc_perm structures. Only the
d205 1
a205 1
 * Convert between Linux and OpenBSD semid_ds structures.
d603 1
a603 1
 * Convert between Linux and OpenBSD shmid_ds structures.
d647 1
a647 1
 * by OpenBSD itself.
d689 1
a689 1
		if ((error = copyout((caddr_t) &bs, (caddr_t) bsp, sizeof bs)))
@


1.4.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.4.10.1 2001/05/14 22:04:44 niklas Exp $	*/
d73 6
a78 3
int linux_semop __P((struct proc *, void *, register_t *));
int linux_semget __P((struct proc *, void *, register_t *));
int linux_semctl __P((struct proc *, void *, register_t *));
d84 8
a91 4
int linux_msgsnd __P((struct proc *, void *, register_t *));
int linux_msgrcv __P((struct proc *, void *, register_t *));
int linux_msgget __P((struct proc *, void *, register_t *));
int linux_msgctl __P((struct proc *, void *, register_t *));
d97 8
a104 4
int linux_shmat __P((struct proc *, void *, register_t *));
int linux_shmdt __P((struct proc *, void *, register_t *));
int linux_shmget __P((struct proc *, void *, register_t *));
int linux_shmctl __P((struct proc *, void *, register_t *));
d234 1
a234 1
linux_semop(p, v, retval)
a235 3
	void *v;
	register_t *retval;
{
d242 3
a244 1
	} */ *uap = v;
d255 1
a255 1
linux_semget(p, v, retval)
a256 3
	void *v;
	register_t *retval;
{
d263 3
a265 1
	} */ *uap = v;
d282 1
a282 1
linux_semctl(p, v, retval)
a283 3
	void *v;
	register_t *retval;
{
d290 3
a292 1
	} */ *uap = v;
d402 1
a402 1
linux_msgsnd(p, v, retval)
a403 3
	void *v;
	register_t *retval;
{
d410 3
a412 1
	} */ *uap = v;
d424 1
a424 1
linux_msgrcv(p, v, retval)
a425 3
	void *v;
	register_t *retval;
{
d432 3
a434 1
	} */ *uap = v;
d452 1
a452 1
linux_msgget(p, v, retval)
a453 3
	void *v;
	register_t *retval;
{
d460 3
a462 1
	} */ *uap = v;
d472 1
a472 1
linux_msgctl(p, v, retval)
a473 3
	void *v;
	register_t *retval;
{
d480 3
a482 1
	} */ *uap = v;
d526 1
a526 1
linux_shmat(p, v, retval)
a527 3
	void *v;
	register_t *retval;
{
d534 3
a536 1
	} */ *uap = v;
d560 1
a560 1
linux_shmdt(p, v, retval)
a561 3
	void *v;
	register_t *retval;
{
d568 3
a570 1
	} */ *uap = v;
d582 1
a582 1
linux_shmget(p, v, retval)
a583 3
	void *v;
	register_t *retval;
{
d590 3
a592 1
	} */ *uap = v;
d652 1
a652 1
linux_shmctl(p, v, retval)
a653 3
	void *v;
	register_t *retval;
{
d660 3
a662 1
	} */ *uap = v;
@


1.4.10.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 5
a77 5
int linux_semop(struct proc *, void *, register_t *);
int linux_semget(struct proc *, void *, register_t *);
int linux_semctl(struct proc *, void *, register_t *);
void bsd_to_linux_semid_ds(struct semid_ds *, struct linux_semid_ds *);
void linux_to_bsd_semid_ds(struct linux_semid_ds *, struct semid_ds *);
d81 6
a86 6
int linux_msgsnd(struct proc *, void *, register_t *);
int linux_msgrcv(struct proc *, void *, register_t *);
int linux_msgget(struct proc *, void *, register_t *);
int linux_msgctl(struct proc *, void *, register_t *);
void linux_to_bsd_msqid_ds(struct linux_msqid_ds *, struct msqid_ds *);
void bsd_to_linux_msqid_ds(struct msqid_ds *, struct linux_msqid_ds *);
d90 6
a95 6
int linux_shmat(struct proc *, void *, register_t *);
int linux_shmdt(struct proc *, void *, register_t *);
int linux_shmget(struct proc *, void *, register_t *);
int linux_shmctl(struct proc *, void *, register_t *);
void linux_to_bsd_shmid_ds(struct linux_shmid_ds *, struct shmid_ds *);
void bsd_to_linux_shmid_ds(struct shmid_ds *, struct linux_shmid_ds *);
d99 2
a100 2
void linux_to_bsd_ipc_perm(struct linux_ipc_perm *, struct ipc_perm *);
void bsd_to_linux_ipc_perm(struct ipc_perm *, struct linux_ipc_perm *);
@


1.4.10.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d541 1
a541 1
	if ((error = sys_shmat1(p, &bsa, retval, 1)))
@


1.3
log
@Contextual goo for -Wall, and remove some stasic specifiers
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_ipc.c,v 1.2 1996/04/17 05:23:52 mickey Exp $	*/
d678 1
a678 1
		if ((error = copyin((caddr_t) &bs, (caddr_t) bsp, sizeof bs)))
d689 1
a689 1
		if ((error = copyout((caddr_t) &bs, (caddr_t) bsp, sizeof bs)))
@


1.2
log
@Good fixes and changes from latest Net.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d73 8
a80 10
static int linux_semop __P((struct proc *, struct linux_sys_ipc_args *,
				register_t *));
static int linux_semget __P((struct proc *, struct linux_sys_ipc_args *,
				register_t *));
static int linux_semctl __P((struct proc *, struct linux_sys_ipc_args *,
				register_t *));
static void bsd_to_linux_semid_ds __P((struct semid_ds *,
				       struct linux_semid_ds *));
static void linux_to_bsd_semid_ds __P((struct linux_semid_ds *,
				       struct semid_ds *));
d84 10
a93 12
static int linux_msgsnd __P((struct proc *, struct linux_sys_ipc_args *,
				register_t *));
static int linux_msgrcv __P((struct proc *, struct linux_sys_ipc_args *,
				register_t *));
static int linux_msgget __P((struct proc *, struct linux_sys_ipc_args *,
				register_t *));
static int linux_msgctl __P((struct proc *, struct linux_sys_ipc_args *,
				register_t *));
static void linux_to_bsd_msqid_ds __P((struct linux_msqid_ds *,
				       struct msqid_ds *));
static void bsd_to_linux_msqid_ds __P((struct msqid_ds *,
				       struct linux_msqid_ds *));
d97 10
a106 12
static int linux_shmat __P((struct proc *, struct linux_sys_ipc_args *,
				register_t *));
static int linux_shmdt __P((struct proc *, struct linux_sys_ipc_args *,
				register_t *));
static int linux_shmget __P((struct proc *, struct linux_sys_ipc_args *,
				register_t *));
static int linux_shmctl __P((struct proc *, struct linux_sys_ipc_args *,
				register_t *));
static void linux_to_bsd_shmid_ds __P((struct linux_shmid_ds *,
				       struct shmid_ds *));
static void bsd_to_linux_shmid_ds __P((struct shmid_ds *,
				       struct linux_shmid_ds *));
d109 4
a112 5

static void linux_to_bsd_ipc_perm __P((struct linux_ipc_perm *,
				       struct ipc_perm *));
static void bsd_to_linux_ipc_perm __P((struct ipc_perm *,
				       struct linux_ipc_perm *));
d162 1
d167 1
a167 1
static void
d182 1
a182 1
static void
d196 1
d207 1
a207 1
static void
d220 1
a220 1
static void
d363 1
a363 1
static void
d382 1
a382 1
static void
d401 1
a401 1
static int
d423 1
a423 1
static int
d451 1
a451 1
static int
d471 1
a471 1
static int
d525 1
a525 1
static int
d559 1
a559 1
static int
d581 1
a581 1
static int
d610 1
a610 1
static void
d627 1
a627 1
static void
d651 1
a651 1
static int
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: linux_ipc.c,v 1.9 1995/10/08 22:49:29 fvdl Exp $	*/
d79 4
d90 1
a90 1
static int linux_msgop __P((struct proc *, struct linux_sys_ipc_args *,
d94 4
d109 4
d116 5
a133 1
	int what, error;
d406 1
a406 1
int
d428 1
a428 1
int
d456 1
a456 1
int
d476 1
a476 1
int
d530 1
a530 1
int
d564 1
a564 1
int
d586 1
a586 1
int
d656 1
a656 1
int
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
