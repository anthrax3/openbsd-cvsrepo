head	1.77;
access;
symbols
	OPENBSD_5_9:1.76.0.4
	OPENBSD_5_9_BASE:1.76
	OPENBSD_5_8:1.76.0.6
	OPENBSD_5_8_BASE:1.76
	OPENBSD_5_7:1.76.0.2
	OPENBSD_5_7_BASE:1.76
	OPENBSD_5_6:1.75.0.6
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.75.0.4
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.71.0.6
	OPENBSD_5_4_BASE:1.71
	OPENBSD_5_3:1.71.0.4
	OPENBSD_5_3_BASE:1.71
	OPENBSD_5_2:1.71.0.2
	OPENBSD_5_2_BASE:1.71
	OPENBSD_5_1_BASE:1.66
	OPENBSD_5_1:1.66.0.2
	OPENBSD_5_0:1.61.0.2
	OPENBSD_5_0_BASE:1.61
	OPENBSD_4_9:1.53.0.2
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.51.0.2
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.50.0.10
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.50.0.12
	OPENBSD_4_6_BASE:1.50
	OPENBSD_4_5:1.50.0.8
	OPENBSD_4_5_BASE:1.50
	OPENBSD_4_4:1.50.0.6
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.50.0.4
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.50.0.2
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.49.0.10
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.49.0.8
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.49.0.6
	OPENBSD_3_9_BASE:1.49
	OPENBSD_3_8:1.49.0.4
	OPENBSD_3_8_BASE:1.49
	OPENBSD_3_7:1.49.0.2
	OPENBSD_3_7_BASE:1.49
	OPENBSD_3_6:1.48.0.2
	OPENBSD_3_6_BASE:1.48
	SMP_SYNC_A:1.47
	SMP_SYNC_B:1.47
	OPENBSD_3_5:1.45.0.4
	OPENBSD_3_5_BASE:1.45
	OPENBSD_3_4:1.45.0.2
	OPENBSD_3_4_BASE:1.45
	UBC_SYNC_A:1.37
	OPENBSD_3_3:1.36.0.2
	OPENBSD_3_3_BASE:1.36
	OPENBSD_3_2:1.34.0.2
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	UBC_SYNC_B:1.35
	UBC:1.31.0.4
	UBC_BASE:1.31
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_8:1.25.0.2
	OPENBSD_2_8_BASE:1.25
	OPENBSD_2_7:1.22.0.2
	OPENBSD_2_7_BASE:1.22
	SMP:1.14.0.2
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.13.0.8
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.13.0.6
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.77
date	2016.03.02.15.41.48;	author naddy;	state dead;
branches;
next	1.76;
commitid	ZfNt0OHZhMg52abA;

1.76
date	2014.09.01.05.09.53;	author doug;	state Exp;
branches;
next	1.75;
commitid	XQe4V1YtkyCx6uWd;

1.75
date	2013.11.03.13.52.44;	author pirofti;	state Exp;
branches;
next	1.74;

1.74
date	2013.10.25.05.10.03;	author guenther;	state Exp;
branches;
next	1.73;

1.73
date	2013.10.25.04.51.39;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2013.08.13.05.52.22;	author guenther;	state Exp;
branches;
next	1.71;

1.71
date	2012.06.19.11.35.29;	author pirofti;	state Exp;
branches;
next	1.70;

1.70
date	2012.06.19.11.31.39;	author pirofti;	state Exp;
branches;
next	1.69;

1.69
date	2012.06.08.14.28.23;	author pirofti;	state Exp;
branches;
next	1.68;

1.68
date	2012.05.23.19.47.02;	author pirofti;	state Exp;
branches;
next	1.67;

1.67
date	2012.05.23.11.08.57;	author pirofti;	state Exp;
branches;
next	1.66;

1.66
date	2011.12.14.08.33.18;	author robert;	state Exp;
branches;
next	1.65;

1.65
date	2011.11.25.10.10.05;	author robert;	state Exp;
branches;
next	1.64;

1.64
date	2011.09.19.22.49.37;	author pirofti;	state Exp;
branches;
next	1.63;

1.63
date	2011.09.19.14.33.14;	author pirofti;	state Exp;
branches;
next	1.62;

1.62
date	2011.09.18.02.23.18;	author pirofti;	state Exp;
branches;
next	1.61;

1.61
date	2011.07.14.23.32.08;	author matthew;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.09.00.10.52;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.08.19.19.20;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2011.07.08.05.01.27;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.07.06.15.47;	author pirofti;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.07.01.19.39;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2011.04.05.15.44.40;	author pirofti;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.04.21.50.41;	author pirofti;	state Exp;
branches;
next	1.53;

1.53
date	2011.02.11.21.40.04;	author pirofti;	state Exp;
branches;
next	1.52;

1.52
date	2011.02.10.11.58.43;	author pirofti;	state Exp;
branches;
next	1.51;

1.51
date	2010.06.30.21.54.12;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.29.03.28.01;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2004.10.27.13.23.38;	author niklas;	state Exp;
branches;
next	1.48;

1.48
date	2004.07.09.23.52.02;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.28.18.28.14;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.05.00.01.12;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.04.02.57.22;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.01.14.00.23;	author fgsch;	state Exp;
branches;
next	1.43;

1.43
date	2003.08.15.14.02.22;	author fgsch;	state Exp;
branches;
next	1.42;

1.42
date	2003.08.14.18.50.13;	author fgsch;	state Exp;
branches;
next	1.41;

1.41
date	2003.08.14.18.34.15;	author fgsch;	state Exp;
branches;
next	1.40;

1.40
date	2003.08.02.18.37.06;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.23.17.42.09;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.03.00.00.04;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2003.05.10.17.53.57;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2002.10.30.20.10.48;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2002.10.28.03.35.53;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2002.06.05.19.43.25;	author jasoni;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.14.00.42.25;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.04.20.04.52;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.04.19.59.47;	author jasoni;	state Exp;
branches
	1.31.4.1;
next	1.30;

1.30
date	2001.07.03.21.56.26;	author jasoni;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.03.15.32.34;	author jasoni;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.02.21.43.11;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.29.07.23.54;	author jasoni;	state Exp;
branches;
next	1.26;

1.26
date	2000.12.22.07.34.02;	author jasoni;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.07.02.13.40;	author jasoni;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.07.14.11.38;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.07.13.35.02;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.12.04.22.40;	author jasoni;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.04.05.31.50;	author jasoni;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.28.06.35.57;	author jasoni;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.27.22.38.12;	author jasoni;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.18.21.36.02;	author ian;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.13.08.18.30;	author jasoni;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.08.03.35.29;	author jasoni;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.28.13.29.30;	author jasoni;	state Exp;
branches;
next	1.14;

1.14
date	99.12.06.19.36.42;	author aaron;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	97.12.10.11.55.28;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.11.13.18.35.27;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.07.28.10.21.31;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.07.28.10.19.35;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.27.21.01.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.04.14.11.16.31;	author graichen;	state Exp;
branches;
next	1.7;

1.7
date	96.05.22.12.01.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.28.07.53.18;	author etheisen;	state Exp;
branches;
next	1.5;

1.5
date	96.04.28.07.38.24;	author etheisen;	state Exp;
branches;
next	1.4;

1.4
date	96.04.17.05.24.13;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	95.12.19.15.41.07;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.47.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.20;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.20;	author deraadt;	state Exp;
branches;
next	;

1.14.2.1
date	2000.03.02.07.04.35;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2000.03.24.09.09.03;	author niklas;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2001.05.14.22.04.54;	author niklas;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.14.2.5;

1.14.2.5
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.14.2.6;

1.14.2.6
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.14.2.7;

1.14.2.7
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	1.14.2.8;

1.14.2.8
date	2003.05.13.19.21.27;	author ho;	state Exp;
branches;
next	1.14.2.9;

1.14.2.9
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	1.14.2.10;

1.14.2.10
date	2004.06.05.23.12.34;	author niklas;	state Exp;
branches;
next	;

1.31.4.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	1.31.4.2;

1.31.4.2
date	2002.10.29.00.30.51;	author art;	state Exp;
branches;
next	1.31.4.3;

1.31.4.3
date	2003.05.19.21.52.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.77
log
@remove the Linux emulation code, no longer referenced by anything
@
text
@	$OpenBSD: syscalls.master,v 1.76 2014/09/01 05:09:53 doug Exp $
;	$NetBSD: syscalls.master,v 1.15 1995/12/18 14:35:10 fvdl Exp $

;	@@(#)syscalls.master	8.1 (Berkeley) 7/19/93

; OpenBSD COMPAT_LINUX system call name/number "master" file.
; (See syscalls.conf to see what it is processed into.)
;
; Fields: number type [type-dependent ...]
;	number	system call number, must be in order
;	type	one of STD, OBSOL, UNIMPL, NODEF, NOARGS, or one of
;		the compatibility options defined in syscalls.conf.
;
; types:
;	STD	always included
;	OBSOL	obsolete, not included in system
;	UNIMPL	unimplemented, not included in system
;	NODEF	included, but don't define the syscall number
;	NOARGS	included, but don't define the syscall args structure
;
; The compat options are defined in the syscalls.conf file, and the
; compat option name is prefixed to the syscall name.  Other than
; that, they're like NODEF (for 'compat' options), or STD (for
; 'libcompat' options).
;
; The type-dependent arguments are as follows:
; For STD, NODEF, NOARGS, and compat syscalls:
;	{ pseudo-proto } [alias]
; For other syscalls:
;	[comment]
;
; #ifdef's, etc. may be included, and are copied to the output files.
; #include's are copied to the syscall switch definition file only.

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signal.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <compat/linux/linux_types.h>
#include <compat/linux/linux_signal.h>
#include <compat/linux/linux_misc.h>
#include <compat/linux/linux_syscallargs.h>

#include <machine/linux_machdep.h>

0	NOARGS		{ int sys_nosys(void); } syscall
1	NOARGS		{ int sys_exit(int rval); }
2	NOARGS		{ int sys_fork(void); }
3	NOARGS		{ int sys_read(int fd, char *buf, u_int nbyte); }
4	NOARGS		{ int sys_write(int fd, char *buf, u_int nbyte); }
5	STD		{ int linux_sys_open(char *path, int flags, int mode); }
6	NOARGS		{ int sys_close(int fd); }
7	STD		{ int linux_sys_waitpid(int pid, int *status, \
			    int options);}
8	STD		{ int linux_sys_creat(char *path, int mode); }
9	NOARGS		{ int sys_link(char *path, char *link); }
10	STD		{ int linux_sys_unlink(char *path); }
11	STD		{ int linux_sys_execve(char *path, char **argp, \
			    char **envp); }
12	STD		{ int linux_sys_chdir(char *path); }
13	STD		{ int linux_sys_time(linux_time_t *t); }
14	STD		{ int linux_sys_mknod(char *path, int mode, int dev); }
15	STD		{ int linux_sys_chmod(char *path, int mode); }
16	STD		{ int linux_sys_lchown16(char *path, int uid, \
			    int gid); }
17	STD		{ int linux_sys_break(char *nsize); }
18	STD		{ int linux_sys_ostat(void); }
19	STD		{ long linux_sys_lseek(int fd, long offset, \
			    int whence); }
20	STD		{ pid_t linux_sys_getpid(void); }
21	STD		{ int linux_sys_mount(char *specialfile, char *dir, \
			    char *filesystemtype, long rwflag, void *data); }
22	STD		{ int linux_sys_umount(char *specialfile); }
23	NOARGS		linux_setuid16 { int sys_setuid(uid_t uid); }
24	STD		linux_getuid16 { uid_t linux_sys_getuid(void); }
25	UNIMPL		stime
#ifdef PTRACE
26	STD		{ int linux_sys_ptrace(void); }
#else
26	UNIMPL		ptrace
#endif
27	STD		{ int linux_sys_alarm(unsigned int secs); }
28	STD		{ int linux_sys_ofstat(void); }
29	STD		{ int linux_sys_pause(void); }
30	STD		{ int linux_sys_utime(char *path, \
			    struct linux_utimbuf *times); }
31	STD		{ int linux_sys_stty(void); }
32	STD		{ int linux_sys_gtty(void); }
33	STD		{ int linux_sys_access(char *path, int flags); }
34	STD		{ int linux_sys_nice(int incr); }
35	STD		{ int linux_sys_ftime(void); }
36	NOARGS		{ int sys_sync(void); }
37	STD		{ int linux_sys_kill(int pid, int signum); }
38	STD		{ int linux_sys_rename(char *from, char *to); }
39	STD		{ int linux_sys_mkdir(char *path, int mode); }
40	STD		{ int linux_sys_rmdir(char *path); }
41	NOARGS		{ int sys_dup(u_int fd); }
42	NOARGS		{ int sys_pipe(int *fdp); }
43	STD		{ int linux_sys_times(struct linux_tms *tms); }
44	STD		{ int linux_sys_prof(void); }
45	STD		{ int linux_sys_brk(char *nsize); }
46	NOARGS		linux_setgid16 { int sys_setgid(gid_t gid); }
47	STD		linux_getgid16 { gid_t linux_sys_getgid(void); }
48	STD		{ int linux_sys_signal(int sig, \
			    linux_handler_t handler); }
49	NOARGS		linux_geteuid16 { uid_t sys_geteuid(void); }
50	NOARGS		linux_getegid16 { gid_t sys_getegid(void); }
#ifdef ACCOUNTING
51	NOARGS		{ int sys_acct(char *path); }
#else
51	UNIMPL		acct
#endif
52	STD		{ int linux_sys_phys(void); }
53	STD		{ int linux_sys_lock(void); }
54	STD		{ int linux_sys_ioctl(int fd, u_long com, \
			    caddr_t data); }
55	STD		{ int linux_sys_fcntl(int fd, int cmd, void *arg); }
56	STD		{ int linux_sys_mpx(void); }
57	NOARGS		{ int sys_setpgid(int pid, int pgid); }
58	STD		{ int linux_sys_ulimit(void); }
59	STD		{ int linux_sys_oldolduname(struct linux_oldold_utsname *up); }
60	NOARGS		{ int sys_umask(int newmask); }
61	NOARGS		{ int sys_chroot(char *path); }
62	STD		{ int linux_sys_ustat(void); }
63	NOARGS		{ int sys_dup2(u_int from, u_int to); }
64	NOARGS		{ pid_t sys_getppid(void); }
65	NOARGS		{ int sys_getpgrp(void); }
66	NOARGS		{ int sys_setsid(void); }
67	STD		{ int linux_sys_sigaction(int signum, \
			    struct linux_old_sigaction *nsa, \
			    struct linux_old_sigaction *osa); }
68	STD		{ int linux_sys_siggetmask(void); }
69	STD		{ int linux_sys_sigsetmask(linux_old_sigset_t mask); }
70	STD		{ int linux_sys_setreuid16(int ruid, int euid); }
71	STD		{ int linux_sys_setregid16(int rgid, int egid); }
72	STD		{ int linux_sys_sigsuspend(caddr_t restart, \
			    int oldmask, int mask); }
73	STD		{ int linux_sys_sigpending(linux_old_sigset_t *mask); }
74	STD		{ int linux_sys_sethostname(char *hostname, u_int len);}
75	STD		{ int linux_sys_setrlimit(u_int which, \
			    struct linux_rlimit *rlp); }
76	STD		{ int linux_sys_getrlimit(u_int which, \
			    struct linux_rlimit *rlp); }
77	STD		{ int linux_sys_getrusage(int who, \
			    struct linux_rusage *rusage); }
78	STD		{ int linux_sys_gettimeofday(struct linux_timeval *tp, \
			    struct timezone *tzp); }
79	UNIMPL		settimeofday
80	NOARGS		linux_getgroups { int sys_getgroups(u_int gidsetsize, \
			    gid_t *gidset); }
81	NOARGS		linux_setgroups { int sys_setgroups(u_int gidsetsize, \
			    gid_t *gidset); }
82	STD		{ int linux_sys_oldselect(struct linux_select *lsp); }
83	STD		{ int linux_sys_symlink(char *path, char *to); }
84	NOARGS		{ int linux_sys_lstat(char *path, \
			    struct linux_stat *up); } olstat
85	STD		{ ssize_t linux_sys_readlink(char *name, \
			    char *buf, int count); }
86	UNIMPL		linux_sys_uselib
87	STD		{ int linux_sys_swapon(char *name); }
88	NOARGS		{ int sys_reboot(int opt); }
89	STD		{ int linux_sys_readdir(int fd, caddr_t dent, \
			    unsigned int count); }
90	STD		{ int linux_sys_mmap(struct linux_mmap *lmp); }
91	NOARGS		{ int sys_munmap(caddr_t addr, int len); }
92	STD		{ int linux_sys_truncate(char *path, long length); }
93	STD		{ int linux_sys_ftruncate(int fd, long length); }
94	NOARGS		{ int sys_fchmod(int fd, int mode); }
95	STD		{ int linux_sys_fchown16(int fd, int uid, int gid); }
96	NOARGS		{ int sys_getpriority(int which, int who); }
97	NOARGS		{ int sys_setpriority(int which, int who, int prio); }
98	NOARGS		{ int sys_profil(caddr_t samples, u_int size, \
			    u_int offset, u_int scale); }
99	STD		{ int linux_sys_statfs(char *path, \
			    struct linux_statfs *sp); }
100	STD		{ int linux_sys_fstatfs(int fd, \
			    struct linux_statfs *sp); }
#ifdef __i386__
101	STD		{ int linux_sys_ioperm(unsigned int lo, \
			    unsigned int hi, int val); }
#else
101	STD		{ int linux_sys_ioperm(void); }
#endif
102	STD		{ int linux_sys_socketcall(int what, void *args); }
103	STD		{ int linux_sys_klog(void); }
104	STD		{ int linux_sys_setitimer(u_int which, \
			    struct linux_itimerval *itv, \
			    struct linux_itimerval *oitv); }
105	STD		{ int linux_sys_getitimer(u_int which, \
			    struct linux_itimerval *itv); }
106	STD		{ int linux_sys_stat(char *path, \
			    struct linux_stat *sp); }
107	STD		{ int linux_sys_lstat(char *path, \
			    struct linux_stat *sp); }
108	STD		{ int linux_sys_fstat(int fd, struct linux_stat *sp); }
109	STD		{ int linux_sys_olduname(struct linux_old_utsname *up); }
#ifdef __i386__
110	STD		{ int linux_sys_iopl(int level); }
#else
110	STD		{ int linux_sys_iopl(void); }
#endif
111	STD		{ int linux_sys_vhangup(void); }
112	STD		{ int linux_sys_idle(void); }
113	STD		{ int linux_sys_vm86old(void); }
114	STD		{ int linux_sys_wait4(int pid, int *status, \
			    int options, struct linux_rusage *rusage); }
115	STD		{ int linux_sys_swapoff(void); }
116	STD		{ int linux_sys_sysinfo(struct linux_sysinfo *sysinfo); }
117	STD		{ int linux_sys_ipc(int what, int a1, int a2, int a3, \
			    caddr_t ptr); }
118	NOARGS		{ int sys_fsync(int fd); }
119	STD		{ int linux_sys_sigreturn(struct linux_sigcontext *scp); }
120	STD		{ int linux_sys_clone(int flags, void *stack, \
			    void *parent_tidptr, void *tls, void *child_tidptr); }
121	STD		{ int linux_sys_setdomainname(char *name, int len); }
122	STD		{ int linux_sys_uname(struct linux_utsname *up); }
#ifdef __i386__
123	STD		{ int linux_sys_modify_ldt(int func, void *ptr, \
			    size_t bytecount); }
#else
123	STD		{ int linux_sys_modify_ldt(void); }
#endif
124	STD		{ int linux_sys_adjtimex(void); }
125	STD		{ int linux_sys_mprotect(caddr_t addr, int len, int prot); }
126	STD		{ int linux_sys_sigprocmask(int how, \
			    linux_old_sigset_t *set, linux_old_sigset_t *oset); }
127	STD		{ int linux_sys_create_module(void); }
128	STD		{ int linux_sys_init_module(void); }
129	STD		{ int linux_sys_delete_module(void); }
130	STD		{ int linux_sys_get_kernel_syms(void); }
131	STD		{ int linux_sys_quotactl(void); }
132	STD		{ int linux_sys_getpgid(int pid); }
133	NOARGS		{ int sys_fchdir(int fd); }
134	STD		{ int linux_sys_bdflush(void); }
135	STD		{ int linux_sys_sysfs(void); }
136	STD		{ int linux_sys_personality(int per); }
137	STD		{ int linux_sys_afs_syscall(void); }
138	NOARGS		linux_setfsuid16 { int linux_sys_setfsuid(uid_t uid); }
139	NOARGS		linux_getfsuid16 { int linux_sys_getfsuid(void); }
140	STD		{ int linux_sys_llseek(int fd, u_int32_t ohigh, \
			    u_int32_t olow, caddr_t res, int whence); }
141	STD		{ int linux_sys_getdents(int fd, void *dirent, \
			    unsigned count); }
142	STD		{ int linux_sys_select(int nfds, fd_set *readfds, \
			    fd_set *writefds, fd_set *exceptfds, \
			    struct linux_timeval *timeout); }
143	NOARGS		{ int sys_flock(int fd, int how); }
144	NOARGS		{ int sys_msync(void *addr, int len, int fl); }
145	NOARGS		{ int sys_readv(int fd, struct iovec *iovp, \
				u_int iovcnt); }
146	NOARGS		{ int sys_writev(int fd, struct iovec *iovp, \
				u_int iovcnt); }
147	NOARGS		{ int sys_getsid(pid_t pid); }
148	STD		{ int linux_sys_fdatasync(int fd); }
149	STD		{ int linux_sys___sysctl(struct linux___sysctl *lsp); }
150	NOARGS		{ int sys_mlock(caddr_t addr, size_t len); }
151	NOARGS		{ int sys_munlock(caddr_t addr, size_t len); }
152	STD		{ int linux_sys_mlockall(void); }
153	STD		{ int linux_sys_munlockall(void); }
154	STD		{ int linux_sys_sched_setparam(linux_pid_t pid, \
			    const struct linux_sched_param *sp); }
155	STD		{ int linux_sys_sched_getparam(linux_pid_t pid, \
			    struct linux_sched_param *sp); }
156	STD		{ int linux_sys_sched_setscheduler(linux_pid_t pid, \
			    int policy, const struct linux_sched_param *sp); }
157	STD		{ int linux_sys_sched_getscheduler(linux_pid_t pid); }
158	STD		{ int linux_sys_sched_yield(void); }
159	STD		{ int linux_sys_sched_get_priority_max(int policy); }
160	STD		{ int linux_sys_sched_get_priority_min(int policy); }
161	STD		{ int linux_sys_sched_rr_get_interval(void); }
162	STD		{ int linux_sys_nanosleep( \
				const struct linux_timespec *rqtp, \
				struct linux_timespec *rmtp); }
163	STD		{ int linux_sys_mremap(void *old_address, \
			    size_t old_size, size_t new_size, long flags); }
164	STD		{ int linux_sys_setresuid16(u_int16_t ruid, \
			    u_int16_t euid, u_int16_t suid); }
165	STD		{ int linux_sys_getresuid16(u_int16_t *ruid, \
			    u_int16_t *euid, u_int16_t *suid); }
166	STD		{ int linux_sys_vm86(void); }
167	STD		{ int linux_sys_query_module(void); }
168	NOARGS		{ int sys_poll(struct pollfd *fds, u_int nfds, \
			    int timeout); }
169	STD		{ int linux_sys_nfsservctl(void); }
170	STD		{ int linux_sys_setresgid16(u_int16_t rgid, \
			    u_int16_t egid, u_int16_t sgid); }
171	STD		{ int linux_sys_getresgid16(u_int16_t *rgid, \
			    u_int16_t *egid, u_int16_t *sgid); }
172	STD		{ int linux_sys_prctl(int option, unsigned long arg2, \
			    unsigned long arg3, unsigned long arg4, \
			    unsigned long arg5); }
173	STD     	{ int linux_sys_rt_sigreturn( \
	                    struct linux_rt_sigframe *sfp); }
174	STD		{ int linux_sys_rt_sigaction(int signum, \
			    struct linux_sigaction *nsa, \
			    struct linux_sigaction *osa, \
		            size_t sigsetsize); }
175	STD		{ int linux_sys_rt_sigprocmask(int how, \
			    const linux_sigset_t *set, \
			    linux_sigset_t *oset, size_t sigsetsize); }
176	STD		{ int linux_sys_rt_sigpending(linux_sigset_t *set, \
			    size_t sigsetsize); }
177	STD		{ int linux_sys_rt_sigtimedwait(void); }
178	STD		{ int linux_sys_rt_queueinfo(void); }
179	STD		{ int linux_sys_rt_sigsuspend(linux_sigset_t *unewset, \
			    size_t sigsetsize); }
180	STD		{ int linux_sys_pread(int fd, char *buf, \
			    size_t nbyte, linux_off_t offset); }
181	STD		{ int linux_sys_pwrite(int fd, char *buf, \
			    size_t nbyte, linux_off_t offset); }
182	STD		{ int linux_sys_chown16(char *path, int uid, \
			    int gid); }
183	NOARGS		{ int sys___getcwd(char *bufp, size_t length); }
184	STD		{ int linux_sys_capget(void); }
185	STD		{ int linux_sys_capset(void); }
186	STD		{ int linux_sys_sigaltstack( \
			    const struct linux_sigaltstack *nss, \
			    struct linux_sigaltstack *oss); }
187	STD		{ int linux_sys_sendfile(void); }
188	STD		{ int linux_sys_getpmsg(void); }
189	STD		{ int linux_sys_putpmsg(void); }
190	STD		{ int sys_vfork(void); }
191	STD		{ int linux_sys_ugetrlimit(u_int which, \
			    struct linux_rlimit *rlp); }
192	STD		{ linux_off_t linux_sys_mmap2(unsigned long addr, \
			   size_t len, int prot, int flags, int fd, \
			   linux_off_t offset); }
193	STD		{ int linux_sys_truncate64(char *path, off_t length); }
194	STD		{ int linux_sys_ftruncate64(int fd, off_t length); }
195	STD        	{ int linux_sys_stat64(char *path, \
			    struct linux_stat64 *sp); }
196	STD        	{ int linux_sys_lstat64(char *path, \
			    struct linux_stat64 *sp); }
197	STD        	{ int linux_sys_fstat64(int fd, \
			    struct linux_stat64 *sp); }
198	NOARGS		{ int linux_sys_lchown(void); }
199	STD		{ uid_t linux_sys_getuid(void); }
200	STD		{ gid_t linux_sys_getgid(void); }
201	NOARGS		{ uid_t sys_geteuid(void); }
202	NOARGS		{ gid_t sys_getegid(void); }
203	NOARGS		{ int sys_setreuid(int ruid, int euid); }
204	NOARGS		{ int sys_setregid(int rgid, int egid); }
205	NOARGS		{ int sys_getgroups(u_int gidsetsize, gid_t *gidset); }
206	NOARGS		{ int sys_setgroups(u_int gidsetsize, gid_t *gidset); }
207	NOARGS		{ int linux_sys_fchown(void); }
208	NOARGS		{ int sys_setresuid(uid_t ruid, uid_t euid, \
			    uid_t suid); }
209	NOARGS		{ int sys_getresuid(uid_t *ruid, uid_t *euid, \
			    uid_t *suid); }
210	NOARGS		{ int sys_setresgid(gid_t rgid, gid_t egid, \
			    gid_t sgid); }
211	NOARGS		{ int sys_getresgid(gid_t *rgid, gid_t *egid, \
			    gid_t *sgid); }
212	STD		{ int linux_sys_chown(char *path, uid_t uid, \
			    gid_t gid); }
213	NOARGS		{ int sys_setuid(uid_t uid); }
214	NOARGS		{ int sys_setgid(gid_t gid); }
215	STD		{ int linux_sys_setfsuid(uid_t uid); }
216	NOARGS		{ int linux_sys_setfsgid(void); }
217	NOARGS		{ int linux_sys_pivot_root(void); }
218	NOARGS		{ int linux_sys_mincore(void); }
219	NOARGS		{ int sys_madvise(void *addr, size_t len, int behav); }
220	STD		{ int linux_sys_getdents64(int fd, void *dirent, \
			    unsigned count); }
221	STD		{ int linux_sys_fcntl64(u_int fd, u_int cmd, \
			    void *arg); }
222	UNIMPL
223	UNIMPL
224	STD		{ linux_pid_t linux_sys_gettid(void); }
225	UNIMPL		linux_sys_readahead
226	NOARGS		{ int linux_sys_setxattr(void); }
227	NOARGS		{ int linux_sys_lsetxattr(void); }
228	NOARGS		{ int linux_sys_fsetxattr(void); }
229	NOARGS		{ int linux_sys_getxattr(void); }
230	NOARGS		{ int linux_sys_lgetxattr(void); }
231	NOARGS		{ int linux_sys_fgetxattr(void); }
232	NOARGS		{ int linux_sys_listxattr(void); }
233	NOARGS		{ int linux_sys_llistxattr(void); }
234	NOARGS		{ int linux_sys_flistxattr(void); }
235	NOARGS		{ int linux_sys_removexattr(void); }
236	NOARGS		{ int linux_sys_lremovexattr(void); }
237	NOARGS		{ int linux_sys_fremovexattr(void); }
238	UNIMPL		linux_sys_tkill
239	UNIMPL		linux_sys_sendfile64
240	STD		{ int linux_sys_futex(int *uaddr, int op, int val, \
			    const struct linux_timespec *timeout, \
			    int *uaddr2, int val3); }
241	UNIMPL		linux_sys_sched_setaffinity
242	UNIMPL		linux_sys_sched_getaffinity
243	STD		{ int linux_sys_set_thread_area(	\
			    struct l_segment_descriptor *desc); }
244	STD		{ int linux_sys_get_thread_area(	\
			    struct l_segment_descriptor *desc); }
245	UNIMPL		linux_sys_io_setup
246	UNIMPL		linux_sys_io_destroy
247	UNIMPL		linux_sys_io_getevents
248	UNIMPL		linux_sys_io_submit
249	UNIMPL		linux_sys_io_cancel
250	NOARGS		{ int linux_sys_fadvise64(void); }
251	UNIMPL		
252	NOARGS		linux_exit_group { int sys_exit(int rval); }
253	UNIMPL		linux_sys_lookup_dcookie
254	NOARGS		{ int linux_sys_epoll_create(void); }
255	NOARGS		{ int linux_sys_epoll_ctl(void); }
256	NOARGS		{ int linux_sys_epoll_wait(void); }
257	UNIMPL		linux_sys_remap_file_pages
258	STD		{ int linux_sys_set_tid_address(void *tidptr); }
259	UNIMPL		linux_sys_timer_create
260	UNIMPL		linux_sys_timer_settime
261	UNIMPL		linux_sys_timer_gettime
262	UNIMPL		linux_sys_timer_getoverrun
263	UNIMPL		linux_sys_timer_delete
264	UNIMPL		linux_sys_clock_settime
265	STD		{ int linux_sys_clock_gettime(clockid_t which, \
			    struct linux_timespec *tp); }
266	STD		{ int linux_sys_clock_getres(clockid_t which, \
			    struct linux_timespec *tp); }
267	UNIMPL		linux_sys_clock_nanosleep
268	STD		{ int linux_sys_statfs64(char *path, \
			    struct linux_statfs64 *sp); }
269	STD		{ int linux_sys_fstatfs64(int fd, \
			    struct linux_statfs64 *sp); }
270	STD		{ int linux_sys_tgkill(int tgid, int tid, int sig); }
271	UNIMPL		linux_sys_utimes
272	UNIMPL		linux_sys_fadvise64_64
273	UNIMPL		linux_sys_vserver
274	UNIMPL		linux_sys_mbind
275	UNIMPL		linux_sys_get_mempolicy
276	UNIMPL		linux_sys_set_mempolicy
277	UNIMPL		linux_sys_mq_open
278	UNIMPL		linux_sys_mq_unlink
279	UNIMPL		linux_sys_mq_timedsend
280	UNIMPL		linux_sys_mq_timedreceive
281	UNIMPL		linux_sys_mq_notify
282	UNIMPL		linux_sys_mq_getsetattr
283	UNIMPL		linux_sys_sys_kexec_load
284	UNIMPL		linux_sys_waitid
285	UNIMPL		/* unused */
286	UNIMPL		linux_sys_add_key
287	UNIMPL		linux_sys_request_key
288	UNIMPL		linux_sys_keyctl
289	UNIMPL		linux_sys_ioprio_set
290	UNIMPL		linux_sys_ioprio_get
291	UNIMPL		linux_sys_inotify_init
292	UNIMPL		linux_sys_inotify_add_watch
293	UNIMPL		linux_sys_inotify_rm_watch
294	UNIMPL		linux_sys_migrate_pages
295	UNIMPL		linux_sys_openalinux_sys_t
296	UNIMPL		linux_sys_mkdirat
297	UNIMPL		linux_sys_mknodat
298	UNIMPL		linux_sys_fchownat
299	UNIMPL		linux_sys_futimesat
300	UNIMPL		linux_sys_fstatat64
301	UNIMPL		linux_sys_unlinkat
302	UNIMPL		linux_sys_renameat
303	UNIMPL		linux_sys_linkat
304	UNIMPL		linux_sys_symlinkat
305	UNIMPL		linux_sys_readlinkat
306	UNIMPL		linux_sys_fchmodat
307	UNIMPL		linux_sys_faccessat
308	UNIMPL		linux_sys_pselect6
309	UNIMPL		linux_sys_ppoll
310	UNIMPL		linux_sys_unshare
311	STD		{ int linux_sys_set_robust_list( \
			    struct linux_robust_list_head *head, size_t len); }
312	STD		{ int linux_sys_get_robust_list(int pid, \
			    struct linux_robust_list_head **head, \
			    size_t *len); }   
313	UNIMPL		splice
314	UNIMPL		sync_file_range
315	UNIMPL		tee
316	UNIMPL		vmsplice
317	UNIMPL		move_pages
318	UNIMPL		getcpu
319	NOARGS		{ int linux_sys_epoll_pwait(void); }
320	UNIMPL		utimensat
321	UNIMPL		signalfd
322	UNIMPL		timerfd_create
323	NOARGS		{ int linux_sys_eventfd(void); }
324	UNIMPL		fallocate
325	UNIMPL		timerfd_settime
326	UNIMPL		timerfd_gettime
327	UNIMPL		signalfd4
328	NOARGS		{ int linux_sys_eventfd2(void); }
329	NOARGS		{ int linux_sys_epoll_create1(void); }
330	UNIMPL		dup3
331	STD		{ int linux_sys_pipe2(int *fdp, int flags); }
332	UNIMPL		inotify_init1
333	UNIMPL		preadv
334	UNIMPL		pwritev
335	UNIMPL		rt_tgsigqueueinfo
336	UNIMPL		perf_counter_open
337	UNIMPL		recvmmsg
@


1.76
log
@Sync readlink(2) with IEEE Std 1003.1-2008.

discussion, help and ok guenther@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.75 2013/11/03 13:52:44 pirofti Exp $
@


1.75
log
@Remove a.out support from compat_linux(8).

Tested with the syscall regression test suite from IBM and Opera.

Requested by deraadt@@.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.74 2013/10/25 05:10:03 guenther Exp $
d159 2
a160 2
85	STD		{ int linux_sys_readlink(char *name, char *buf, \
			    int count); }
@


1.74
log
@Unimplement stime() and settimeofday(): why are you using a Linux-compat
binary to change the system time?

ok pirofti@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.73 2013/10/25 04:51:39 guenther Exp $
d161 1
a161 1
86	STD		{ int linux_sys_uselib(char *path); }
@


1.73
log
@Start to deal with the time_t change's effect on compat/linux:
 - add Linux versions of struct rusage, timeval, and itimerval and
   conversion functions for them
 - add Linux versions of getrusage(), gettimeofday(), {set,get}itimer(),
   and nanosleep()
 - fix various inconsistencies in naming of Linux versions of types
   and conversion functions
 - add mappings for LINUX_CLOCK_{PROCESS,THREAD}_CPUTIME_ID to the
   native versions

Originally written months ago as part of the time_t work; long
memory, prodding, and ok from pirofti@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.72 2013/08/13 05:52:22 guenther Exp $
d78 1
a78 1
25	STD		{ int linux_sys_stime(linux_time_t *t); }
d150 1
a150 2
79	NOARGS		{ int sys_settimeofday(struct timeval *tp, \
			    struct timezone *tzp); }
@


1.72
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.71 2012/06/19 11:35:29 pirofti Exp $
d101 1
a101 1
43	STD		{ int linux_sys_times(struct times *tms); }
d146 3
a148 2
77	NOARGS		{ int sys_getrusage(int who, struct rusage *rusage); }
78	NOARGS		{ int t32_sys_gettimeofday(struct timeval *tp, \
d189 5
a193 4
104	NOARGS		{ int sys_setitimer(u_int which, \
			    struct itimerval *itv, struct itimerval *oitv); }
105	NOARGS		{ int sys_getitimer(u_int which, \
			    struct itimerval *itv); }
d209 1
a209 1
			    int options, struct rusage *rusage); }
d211 1
a211 1
116	STD		{ int linux_sys_sysinfo(struct linux_sys_sysinfo_args *sysinfo); }
d249 1
a249 1
			    struct timeval *timeout); }
d274 3
a276 2
162	NOARGS		{ int t32_sys_nanosleep(const struct timespec32 *rqtp, \
				struct timespec32 *rmtp); }
d389 1
a389 1
			    const struct linux_timespec *timeout,	   \
d418 1
a418 1
			    struct l_timespec *tp); }
d420 1
a420 1
			    struct l_timespec *tp); }
@


1.71
log
@Implement linux_sys_tgkill.

Nobody calls linux_sys_tkill anymore so code for that is not needed.
If this will become an issue in the future a simple wrapper will fix that.

Okay jasper@@.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.70 2012/06/19 11:31:39 pirofti Exp $
d147 1
a147 1
78	NOARGS		{ int sys_gettimeofday(struct timeval *tp, \
d272 2
a273 2
162	NOARGS		{ int sys_nanosleep(const struct timespec *rqtp, \
				struct timespec *rmtp); }
@


1.70
log
@Add dummies for the epoll and eventfd syscall families.

Okay jasper@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.69 2012/06/08 14:28:23 pirofti Exp $
d423 1
a423 1
270	UNIMPL		linux_sys_tgkill
@


1.69
log
@Remove the lack of gettid() implementation. Okay tedu@@

Looks right to jasper@@ as well.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.68 2012/05/23 19:47:02 pirofti Exp $
d403 3
a405 3
254	UNIMPL		linux_sys_epoll_create
255	UNIMPL		linux_sys_epoll_ctl
256	UNIMPL		linux_sys_epoll_wait
d475 1
a475 1
319	UNIMPL		epoll_wait
d479 1
a479 1
323	UNIMPL		eventfd
d484 2
a485 2
328	UNIMPL		eventfd2
329	UNIMPL		epoll_create1
@


1.68
log
@Add emulation support for fstatfs64.

Okay matthew@@.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.67 2012/05/23 11:08:57 pirofti Exp $
d369 1
a369 1
224	UNIMPL		linux_sys_gettid
@


1.67
log
@Add support for statfs64.

While at it get rid of some magic numbers and add support for more
filesystem types (like NTFS, AFS etc.).

Suggestions and feedback from ajacoutot@@, jsing@@ and matthew@@.

Okay matthew@@.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.66 2011/12/14 08:33:18 robert Exp $
d421 2
a422 1
269	UNIMPL		linux_sys_fstatfs64
@


1.66
log
@implement prctl() for COMPAT_LINUX

ok pirofti@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.65 2011/11/25 10:10:05 robert Exp $
d419 2
a420 1
268	UNIMPL		linux_sys_statfs64
@


1.65
log
@implement chown(2) in compat_linux which is needed by some antivirus software

ok pirofti@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.64 2011/09/19 22:49:37 pirofti Exp $
d289 3
a291 1
172	STD		{ int linux_sys_prctl(void); }
@


1.64
log
@Add pipe2. Okay miod@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.63 2011/09/19 14:33:14 pirofti Exp $
d352 2
a353 1
212	NOARGS		{ int linux_sys_chown(void); }
@


1.63
log
@Expand syscall awareness in preparation for pipe2 implementation.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.62 2011/09/18 02:23:18 pirofti Exp $
d482 1
a482 1
331	UNIMPL		pipe2
@


1.62
log
@Add futex support for compat/linux.

Based on Emmanuel Dreyfus work with additions, tricks and adaptations by me.

Lots of help and reviewing by guenther@@ and oga@@.

Okay guenther@@.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.61 2011/07/14 23:32:08 matthew Exp $
d464 25
@


1.61
log
@Fix entry 84 to use the same prototype for linux_sys_lstat() as entry
107 does (i.e., using a pointer to "struct linux_stat" rather than a
pointer to "struct stat43").

No binary change: entry 84 is "NOARGS" so the prototype only goes into
a comment in linux_syscall.h.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.60 2011/07/09 00:10:52 deraadt Exp $
d382 3
a384 1
240	UNIMPL		linux_sys_futex
d459 5
a463 2
311	UNIMPL		linux_sys_set_robust_list
312	UNIMPL		linux_sys_get_robust_list
@


1.60
log
@Remove COMPAT_25.  The one piece moved by COMPAT_LINUX moves there.
ok guenther
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.59 2011/07/08 19:19:20 tedu Exp $
d158 1
a158 1
			    struct stat43 *up); } olstat
@


1.59
log
@remove all traces of COMPAT_09 and COMPAT_10. ok deraadt
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.58 2011/07/08 05:01:27 matthew Exp $
d162 1
a162 1
87	NOARGS		{ int compat_25_sys_swapon(char *name); }
@


1.58
log
@Remove the sys_opipe() kernel entry point.  sys_pipe() is the future.

While here, switch compat_linux to just use sys_pipe() rather than
incorrectly wrapping sys_opipe().

ok tedu@@, miod@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.57 2011/07/07 06:15:47 pirofti Exp $
d216 1
a216 2
121	NOARGS		{ int compat_09_sys_setdomainname(char *name, \
			    int len); }
@


1.57
log
@Add more syscalls to the list.

This is in preparation of the robust syscalls, number 311 and 312, which
create a gap (between the syscall numbers we currently have) that the script
genearating the files doesn't allow.

Okay guenther@@.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.56 2011/07/07 01:19:39 tedu Exp $
d100 1
a100 1
42	STD		{ int linux_sys_pipe(int *pfds); }
@


1.56
log
@remove all the old COMPAT_43 syscalls.  The option itself remains for
the other things it enables.  Move a few old wrappers into linux compat
where they are still being used.
ok deraadt guenther
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.55 2011/04/05 15:44:40 pirofti Exp $
d415 45
@


1.55
log
@Add set_tid_address() syscall. Lots of help from and okay guenther@@.

This is more than a simple syscall.This expands TLS support quite a bit.
Also linux_sys_clone() handles CLONE_CHILD_CLEARTID, CLONE_CHILD_SETTID,
CLONE_PARENT_SETTID flags as well as the CLONE_SETTLS by doing what
set_thread_area() is doing.

Next on the list is futex support which should allow compat to cope with
newer Linux kernels.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.54 2011/04/04 21:50:41 pirofti Exp $
d70 1
a70 1
19	NOARGS		{ long compat_43_sys_lseek(int fd, long offset, \
d141 1
a141 2
74	NOARGS		{ int compat_43_sys_sethostname(char *hostname, \
			    u_int len);}
d157 1
a157 1
84	NOARGS		{ int compat_43_sys_lstat(char *path, \
d169 1
a169 1
93	NOARGS		{ int compat_43_sys_ftruncate(int fd, long length); }
@


1.54
log
@Add linux_sys_[g|s]et_set_thread_area() support. Okay guenther@@.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.53 2011/02/11 21:40:04 pirofti Exp $
d215 2
a216 1
120	STD		{ int linux_sys_clone(int flags, void *stack); }
d404 1
a404 1
258	UNIMPL		linux_sys_set_tid_address
@


1.53
log
@Add linux_mprotect() syscall. Okay otto@@.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.52 2011/02/10 11:58:43 pirofti Exp $
d386 4
a389 2
243	UNIMPL		linux_sys_set_thread_area
244	UNIMPL		linux_sys_get_thread_area
@


1.52
log
@Add time related syscalls clock_gettime() and clock_getres().

Okay miod@@.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.51 2010/06/30 21:54:12 guenther Exp $
d226 1
a226 1
125	NOARGS		{ int sys_mprotect(caddr_t addr, int len, int prot); }
@


1.51
log
@Merge from NetBSD: "Linux's getsid(2) does in fact return a pid,
not a pointer."  So just use the native implementation.
ok deraadt@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.50 2007/05/29 03:28:01 tedu Exp $
d408 4
a411 2
265	UNIMPL		linux_sys_clock_gettime
266	UNIMPL		linux_sys_clock_getres
@


1.50
log
@linux_getcwd is the same as the system one.
discovered/ok beck
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.49 2004/10/27 13:23:38 niklas Exp $
d255 1
a255 1
147	STD		{ int linux_sys_getsid(int pid); }
@


1.49
log
@Add support for sys_setre[ug]id, ok deraadt@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.48 2004/07/09 23:52:02 millert Exp $
d312 1
a312 1
183	STD		{ int linux_sys_getcwd(char *bufp, size_t length); }
@


1.48
log
@Rename ostat -> stat43 to disambiguate from upcoming struct stat changes.
Idea from NetBSD, OK deraadt@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.47 2004/05/28 18:28:14 tedu Exp $
d340 2
a341 2
203	NOARGS		{ int linux_sys_setreuid(void); }
204	NOARGS		{ int linux_sys_setregid(void); }
@


1.47
log
@ACCOUNTING is optional.  found by mpech. ok deraadt
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.46 2004/04/05 00:01:12 tedu Exp $
d159 1
a159 1
			    struct ostat *up); } olstat
@


1.46
log
@madvise works fine without translation, from Sam Smith.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.45 2003/09/04 02:57:22 tedu Exp $
d110 1
d112 3
@


1.45
log
@dummy xattr syscalls.  ok deraadt@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.44 2003/09/01 14:00:23 fgsch Exp $
d356 1
a356 1
219	NOARGS		{ int linux_sys_madvise(void); }
@


1.44
log
@set fadvise64 as dummy. some binaries compiled with a recent glibc
seems to require it; henning ok.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.43 2003/08/15 14:02:22 fgsch Exp $
d365 12
a376 12
226	UNIMPL		linux_sys_setxattr
227	UNIMPL		linux_sys_lsetxattr
228	UNIMPL		linux_sys_fsetxattr
229	UNIMPL		linux_sys_getxattr
230	UNIMPL		linux_sys_lgetxattr
231	UNIMPL		linux_sys_fgetxattr
232	UNIMPL		linux_sys_listxattr
233	UNIMPL		linux_sys_llistxattr
234	UNIMPL		linux_sys_flistxattr
235	UNIMPL		linux_sys_removexattr
236	UNIMPL		linux_sys_lremovexattr
237	UNIMPL		linux_sys_fremovexattr
@


1.43
log
@simplify.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.41 2003/08/14 18:34:15 fgsch Exp $
d389 1
a389 1
250	UNIMPL		linux_sys_fadvise64
@


1.42
log
@unbust my previous commit.
@
text
@d391 1
a391 1
252	STD		{ int linux_sys_exit_group(int rval); }
@


1.41
log
@add more syscalls. implement exit_group (which is actually an alias for
sys_exit), needed for newer glibc's binaries.
from marius aamodt eriksen <marius at monkey dot org>
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.40 2003/08/02 18:37:06 deraadt Exp $
d391 1
a391 1
252	NOARGS		{ int sys_exit(int rval); }
@


1.40
log
@wrong args for linux ftruncate64; marius@@monkey.org
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.39 2003/07/23 17:42:09 tedu Exp $
d271 2
a272 2
163	STD		{ int linux_sys_mremap(void *old_address, size_t old_size, \
			    size_t new_size, long flags); }
d323 1
a323 2
193	STD        	{ int linux_sys_truncate64(char *path, \
			    off_t length); }
d359 48
a406 1
221	STD		{ int linux_sys_fcntl64(u_int fd, u_int cmd, void *arg); }
@


1.39
log
@add sys_sysinfo.  from marius aamodt eriksen.
linux_misc.c: fvdl gave his copyright to tnf, adjust.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.38 2003/07/03 00:00:04 tedu Exp $
d320 1
a320 1
192     STD		{ linux_off_t linux_sys_mmap2(unsigned long addr, \
d323 1
a323 1
193     STD        	{ int linux_sys_truncate64(char *path, \
d325 2
a326 2
194	NOARGS		linux_ftruncate64 { int sys_ftruncate(int fd, off_t length); }
195     STD        	{ int linux_sys_stat64(char *path, \
d328 1
a328 1
196     STD        	{ int linux_sys_lstat64(char *path, \
d330 1
a330 1
197     STD        	{ int linux_sys_fstat64(int fd, \
@


1.38
log
@add mmap2 (mmap64, take your pick) and clean up some.  use MAP_TRYFIXED
since that's the way linux works.  no regressions by various ports testers,
eyeballed by a few others.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.37 2003/05/10 17:53:57 miod Exp $
d43 1
d206 1
a206 1
116	STD		{ int linux_sys_sysinfo(void); }
@


1.37
log
@Deprecate the swapon system call and move it to COMPAT_25 land, since swapctl
has been introduced for this release.

ok deraadt@@ weingart@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.36 2002/10/30 20:10:48 millert Exp $
d319 3
a321 1
192     STD		{ int linux_sys_mmap2(void); }
@


1.36
log
@Now that we have [gs]etres[ug]id() as a native system call, use it
for HP-UX, FreeBSD, and Linux emulations.  Note that Linux has two
versions of these system calls.  One for 16bit uids and another for
32bit uids.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.35 2002/10/28 03:35:53 fgsch Exp $
d158 1
a158 1
87	NOARGS		{ int sys_swapon(char *name); }
@


1.35
log
@add getdents64.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.33 2002/03/14 00:42:25 miod Exp $
d272 4
a275 4
164	STD		{ int linux_sys_setresuid16(uid_t ruid, uid_t euid, \
			    uid_t suid); }
165	NOARGS		linux_getresuid16 { int linux_sys_getresuid( \
			    uid_t *ruid, uid_t *euid, uid_t *suid); }
d281 4
a284 4
170	STD		{ int linux_sys_setresgid16(gid_t rgid, gid_t egid, \
			    gid_t sgid); }
171	STD		{ int linux_sys_getresgid16(gid_t *rgid, gid_t *egid, \
			    gid_t *sgid); }
d339 3
a341 2
208	NOARGS		{ int linux_sys_setresuid(void); }
209	STD		{ int linux_sys_getresuid(uid_t *ruid, uid_t *euid, \
d343 4
a346 2
210	NOARGS		{ int linux_sys_setresgid(void); }
211	NOARGS		{ int linux_sys_getresgid(void); }
@


1.34
log
@provide local versions of getpid, getuid and getgid that do not
stuff a value in retval[1] as newer linux libs puke on it.
@
text
@d352 2
a353 1
220	NOARGS		{ int linux_sys_getdents64(void); }
@


1.33
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.32 2002/02/04 20:04:52 provos Exp $
d71 1
a71 1
20	NOARGS		{ pid_t sys_getpid(void); }
d76 1
a76 1
24	NOARGS		linux_getuid16 { uid_t sys_getuid(void); }
d104 1
a104 1
47	NOARGS		linux_getgid16 { gid_t sys_getgid(void); }
d330 2
a331 2
199	NOARGS		{ uid_t sys_getuid(void); }
200	NOARGS		{ gid_t sys_getgid(void); }
@


1.32
log
@fcntl64 support; okay deraadt@@
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.30 2001/07/03 21:56:26 jasoni Exp $
d78 1
d80 3
@


1.31
log
@add new system calls as dummies, except for those which we already have
an equivalent for; from netbsd
ok niklas@@
@
text
@d349 1
a349 1
221	NOARGS		{ int linux_sys_fcntl64(void); }
@


1.31.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.31 2001/07/04 19:59:47 jasoni Exp $
d71 1
a71 1
20	STD		{ pid_t linux_sys_getpid(void); }
d76 1
a76 1
24	STD		linux_getuid16 { uid_t linux_sys_getuid(void); }
a77 1
#ifdef PTRACE
a78 3
#else
26	UNIMPL		ptrace
#endif
d100 1
a100 1
47	STD		linux_getgid16 { gid_t linux_sys_getgid(void); }
d326 2
a327 2
199	STD		{ uid_t linux_sys_getuid(void); }
200	STD		{ gid_t linux_sys_getgid(void); }
d349 1
a349 1
221	STD		{ int linux_sys_fcntl64(u_int fd, u_int cmd, void *arg); }
@


1.31.4.2
log
@sync to -current
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.31.4.1 2002/06/11 03:28:08 art Exp $
d352 1
a352 2
220	STD		{ int linux_sys_getdents64(int fd, void *dirent, \
			    unsigned count); }
@


1.31.4.3
log
@sync
@
text
@d1 1
a1 1
	$OpenBSD$
d158 1
a158 1
87	NOARGS		{ int compat_25_sys_swapon(char *name); }
d272 4
a275 4
164	STD		{ int linux_sys_setresuid16(u_int16_t ruid, \
			    u_int16_t euid, u_int16_t suid); }
165	STD		{ int linux_sys_getresuid16(u_int16_t *ruid, \
			    u_int16_t *euid, u_int16_t *suid); }
d281 4
a284 4
170	STD		{ int linux_sys_setresgid16(u_int16_t rgid, \
			    u_int16_t egid, u_int16_t sgid); }
171	STD		{ int linux_sys_getresgid16(u_int16_t *rgid, \
			    u_int16_t *egid, u_int16_t *sgid); }
d339 2
a340 3
208	NOARGS		{ int sys_setresuid(uid_t ruid, uid_t euid, \
			    uid_t suid); }
209	NOARGS		{ int sys_getresuid(uid_t *ruid, uid_t *euid, \
d342 2
a343 4
210	NOARGS		{ int sys_setresgid(gid_t rgid, gid_t egid, \
			    gid_t sgid); }
211	NOARGS		{ int sys_getresgid(gid_t *rgid, gid_t *egid, \
			    gid_t *sgid); }
@


1.30
log
@rename 2 more syscalls to syscallname16 (missed last time)
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.29 2001/07/03 15:32:34 jasoni Exp $
d231 1
a231 1
138	STD		linux_setfsuid16 { int linux_sys_setfsuid(uid_t uid); }
d270 1
a270 1
165	STD		linux_getresuid16 { int linux_sys_getresuid( \
d325 25
@


1.29
log
@rename some syscalls to <syscall>16 to make room for new ones.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.28 2001/04/02 21:43:11 niklas Exp $
d277 1
a277 1
170	STD		{ int linux_sys_setresgid(gid_t rgid, gid_t egid, \
d279 1
a279 1
171	STD		{ int linux_sys_getresgid(gid_t *rgid, gid_t *egid, \
@


1.28
log
@On popular demand, the Linux-compatibility clone(2) implementation based
on NetBSD's code, as well as some faked Posix RT extensions by me.  This makes
at least simple linuxthreads tests work.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.27 2001/01/29 07:23:54 jasoni Exp $
d65 2
a66 1
16	STD		{ int linux_sys_lchown(char *path, int uid, int gid); }
d75 2
a76 2
23	NOARGS		{ int sys_setuid(uid_t uid); }
24	NOARGS		{ uid_t sys_getuid(void); }
d99 2
a100 2
46	NOARGS		{ int sys_setgid(gid_t gid); }
47	NOARGS		{ gid_t sys_getgid(void); }
d103 2
a104 2
49	NOARGS		{ uid_t sys_geteuid(void); }
50	NOARGS		{ gid_t sys_getegid(void); }
d127 2
a128 2
70	STD		{ int linux_sys_setreuid(int ruid, int euid); }
71	STD		{ int linux_sys_setregid(int rgid, int egid); }
d143 4
a146 2
80	NOARGS		{ int sys_getgroups(u_int gidsetsize, gid_t *gidset); }
81	NOARGS		{ int sys_setgroups(u_int gidsetsize, gid_t *gidset); }
d163 1
a163 1
95	STD		{ int linux_sys_fchown(int fd, int uid, int gid); }
d231 2
a232 2
138	STD		{ int linux_sys_setfsuid(uid_t uid); }
139	NOARGS		{ int linux_sys_getfsuid(void); }
d268 1
a268 1
164	STD		{ int linux_sys_setresuid(uid_t ruid, uid_t euid, \
d270 2
a271 2
165	STD		{ int linux_sys_getresuid(uid_t *ruid, uid_t *euid, \
			    uid_t *suid); }
d301 2
a302 1
182	STD		{ int linux_sys_chown(char *path, int uid, int gid); }
a324 1

@


1.27
log
@implement ftruncate64
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.26 2000/12/22 07:34:02 jasoni Exp $
d203 1
a203 1
120	STD		{ int linux_sys_clone(void); }
d250 7
a256 4
154	STD		{ int linux_sys_sched_setparam(void); }
155	STD		{ int linux_sys_sched_getparam(void); }
156	STD		{ int linux_sys_sched_setscheduler(void); }
157	STD		{ int linux_sys_sched_getscheduler(void); }
d258 2
a259 2
159	STD		{ int linux_sys_sched_get_priority_max(void); }
160	STD		{ int linux_sys_sched_get_priority_min(void); }
@


1.26
log
@Implement truncate64, stat64, lstat64, fstat64; from NetBSD
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.25 2000/07/07 02:13:40 jasoni Exp $
d311 1
a311 1
194     STD        	{ int linux_sys_ftruncate64(void); }
@


1.25
log
@Change all UNIMPL and OBSOL syscalls to STD.
Add these syscalls to linux_dummy.c where they return ENOSYS and display
a friendler message which tells you what unimplemented syscall has been
called.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.24 2000/06/07 14:11:38 niklas Exp $
d309 2
a310 1
193     STD        	{ int linux_sys_truncate64(void); }
d312 6
a317 3
195     STD        	{ int linux_sys_stat64(void); }
196     STD        	{ int linux_sys_lstat64(void); }
197     STD        	{ int linux_sys_fstat64(void); }
@


1.24
log
@Implement sigaltstack
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.23 2000/06/07 13:35:02 niklas Exp $
d67 1
a67 1
18	OBSOL		ostat
d77 1
a77 1
26	UNIMPL		ptrace
d79 1
a79 1
28	OBSOL		ofstat
d83 2
a84 2
31	UNIMPL		stty
32	UNIMPL		gtty
d87 1
a87 1
35	UNIMPL		ftime
d96 1
a96 1
44	UNIMPL		prof
d105 2
a106 2
52	UNIMPL		phys
53	UNIMPL		lock
d110 1
a110 1
56	UNIMPL		mpx
d112 1
a112 1
58	UNIMPL		ulimit
d116 1
a116 1
62	UNIMPL		ustat
d173 1
a173 1
101	UNIMPL		ioperm
d176 1
a176 1
103	UNIMPL		klog
d190 1
a190 1
110	UNIMPL		iopl
d192 3
a194 3
111	UNIMPL		vhangup
112	UNIMPL		idle
113	UNIMPL		vm86
d197 2
a198 2
115	UNIMPL		swapoff
116	UNIMPL		sysinfo
d203 1
a203 1
120	UNIMPL		clone
d211 1
a211 1
123	UNIMPL		modify_ldt
d213 1
a213 1
124	UNIMPL		adjtimex
d217 5
a221 5
127	UNIMPL		create_module
128	UNIMPL		init_module
129	UNIMPL		delete_module
130	UNIMPL		get_kernel_syms
131	UNIMPL		quotactl
d224 2
a225 2
134	UNIMPL		bdflush
135	UNIMPL		sysfs
d227 1
a227 1
137	UNIMPL		afs_syscall
d248 10
a257 10
152	UNIMPL		mlockall
153	UNIMPL		munlockall
154	UNIMPL		sched_setparam
155	UNIMPL		sched_getparam
156	UNIMPL		sched_setscheduler
157	UNIMPL		sched_getscheduler
158	UNIMPL		sched_yield
159	UNIMPL		sched_get_priority_max
160	UNIMPL		sched_get_priority_min
161	UNIMPL		sched_rr_get_interval
d266 2
a267 2
166	UNIMPL		vm86
167	UNIMPL		query_module
d270 1
a270 1
169	UNIMPL		nfsservctl
d275 1
a275 1
172	UNIMPL		prctl
d287 2
a288 2
177	UNIMPL		rt_sigtimedwait
178	UNIMPL		rt_queueinfo
d297 2
a298 2
184	UNIMPL		capget
185	UNIMPL		capset
d302 3
a304 3
187	UNIMPL		sendfile
188	UNIMPL		getpmsg
189	UNIMPL		putpmsg
d308 7
@


1.23
log
@Fix linux [gs]etrlimit emulation + add their latest ugetrlimit
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.22 2000/04/12 04:22:40 jasoni Exp $
d299 3
a301 1
186	UNIMPL		sigaltstack
@


1.22
log
@Implement linux's setfsuid and getfsuid (from NetBSD)
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.21 2000/04/04 05:31:50 jasoni Exp $
d133 4
a136 4
75	NOARGS		{ int compat_43_sys_setrlimit(u_int which, \
			    struct ogetrlimit *rlp); }
76	NOARGS		{ int compat_43_sys_getrlimit(u_int which, \
			    struct ogetrlimit *rlp); }
d304 2
@


1.21
log
@Implement Linux's pread(2) and pwrite(2).
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.20 2000/03/28 06:35:57 jasoni Exp $
d228 2
a229 2
138	UNIMPL		setfsuid
139	UNIMPL		getfsuid
@


1.20
log
@Implement rt_sigreturn.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.19 2000/03/27 22:38:12 jasoni Exp $
d291 4
a294 2
180	UNIMPL		pread
181	UNIMPL		pwrite
@


1.19
log
@Implement getcwd.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.18 2000/03/18 21:36:02 ian Exp $
d276 2
a277 1
173	UNIMPL		rt_sigreturn
@


1.18
log
@Implement vfork (ok jasoni).
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.17 2000/03/13 08:18:30 jasoni Exp $
a270 2
;170	UNIMPL		setresgid
;171	UNIMPL		getresgid
d293 1
a293 1
183	UNIMPL		getcwd
@


1.17
log
@Implement rt_sigaction, rt_sigprocmask, rt_sigpending & rt_sigsuspend.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.16 2000/03/08 03:35:29 jasoni Exp $
d302 1
a302 1
190	UNIMPL		vfork
@


1.16
log
@Add support for the new sigset_t and sigaction.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.15 2000/02/28 13:29:30 jasoni Exp $
d279 9
a287 3
174	UNIMPL		rt_sigaction
175	UNIMPL		rt_sigprocmask
176	UNIMPL		rt_sigpending
d290 2
a291 1
179	UNIMPL		rt_sigsuspend
@


1.15
log
@Add missing system calls as unimplemented.
Implement chown, poll, setresuid, getresuid, setresgid, getresgid.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.14 1999/12/06 19:36:42 aaron Exp $
d122 2
a123 2
			    struct linux_sigaction *nsa, \
			    struct linux_sigaction *osa); }
d125 1
a125 1
69	STD		{ int linux_sys_sigsetmask(linux_sigset_t mask); }
d130 1
a130 1
73	STD		{ int linux_sys_sigpending(linux_sigset_t *mask); }
d216 1
a216 1
			    linux_sigset_t *set, linux_sigset_t *oset); }
@


1.14
log
@Implement compatibility for Linux stime() syscall.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.13 1997/12/10 11:55:28 deraadt Exp $
d65 1
a65 1
16	STD		{ int linux_sys_chown(char *path, int uid, int gid); }
d262 34
@


1.14.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
	$OpenBSD$
d65 1
a65 1
16	STD		{ int linux_sys_lchown(char *path, int uid, int gid); }
a261 34
164	STD		{ int linux_sys_setresuid(uid_t ruid, uid_t euid, \
			    uid_t suid); }
165	STD		{ int linux_sys_getresuid(uid_t *ruid, uid_t *euid, \
			    uid_t *suid); }
166	UNIMPL		vm86
167	UNIMPL		query_module
168	NOARGS		{ int sys_poll(struct pollfd *fds, u_int nfds, \
			    int timeout); }
169	UNIMPL		nfsservctl
;170	UNIMPL		setresgid
;171	UNIMPL		getresgid
170	STD		{ int linux_sys_setresgid(gid_t rgid, gid_t egid, \
			    gid_t sgid); }
171	STD		{ int linux_sys_getresgid(gid_t *rgid, gid_t *egid, \
			    gid_t *sgid); }
172	UNIMPL		prctl
173	UNIMPL		rt_sigreturn
174	UNIMPL		rt_sigaction
175	UNIMPL		rt_sigprocmask
176	UNIMPL		rt_sigpending
177	UNIMPL		rt_sigtimedwait
178	UNIMPL		rt_queueinfo
179	UNIMPL		rt_sigsuspend
180	UNIMPL		pread
181	UNIMPL		pwrite
182	STD		{ int linux_sys_chown(char *path, int uid, int gid); }
183	UNIMPL		getcwd
184	UNIMPL		capget
185	UNIMPL		capset
186	UNIMPL		sigaltstack
187	UNIMPL		sendfile
188	UNIMPL		getpmsg
189	UNIMPL		putpmsg
190	UNIMPL		vfork
@


1.14.2.2
log
@Sync with -current
@
text
@d122 2
a123 2
			    struct linux_old_sigaction *nsa, \
			    struct linux_old_sigaction *osa); }
d125 1
a125 1
69	STD		{ int linux_sys_sigsetmask(linux_old_sigset_t mask); }
d130 1
a130 1
73	STD		{ int linux_sys_sigpending(linux_old_sigset_t *mask); }
d216 1
a216 1
			    linux_old_sigset_t *set, linux_old_sigset_t *oset); }
d279 3
a281 9
174	STD		{ int linux_sys_rt_sigaction(int signum, \
			    struct linux_sigaction *nsa, \
			    struct linux_sigaction *osa, \
		            size_t sigsetsize); }
175	STD		{ int linux_sys_rt_sigprocmask(int how, \
			    const linux_sigset_t *set, \
			    linux_sigset_t *oset, size_t sigsetsize); }
176	STD		{ int linux_sys_rt_sigpending(linux_sigset_t *set, \
			    size_t sigsetsize); }
d284 1
a284 2
179	STD		{ int linux_sys_rt_sigsuspend(linux_sigset_t *unewset, \
			    size_t sigsetsize); }
d295 1
a295 1
190	STD		{ int sys_vfork(void); }
@


1.14.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.28 2001/04/02 21:43:11 niklas Exp $
d67 1
a67 1
18	STD		{ int linux_sys_ostat(void); }
d77 1
a77 1
26	STD		{ int linux_sys_ptrace(void); }
d79 1
a79 1
28	STD		{ int linux_sys_ofstat(void); }
d83 2
a84 2
31	STD		{ int linux_sys_stty(void); }
32	STD		{ int linux_sys_gtty(void); }
d87 1
a87 1
35	STD		{ int linux_sys_ftime(void); }
d96 1
a96 1
44	STD		{ int linux_sys_prof(void); }
d105 2
a106 2
52	STD		{ int linux_sys_phys(void); }
53	STD		{ int linux_sys_lock(void); }
d110 1
a110 1
56	STD		{ int linux_sys_mpx(void); }
d112 1
a112 1
58	STD		{ int linux_sys_ulimit(void); }
d116 1
a116 1
62	STD		{ int linux_sys_ustat(void); }
d133 4
a136 4
75	STD		{ int linux_sys_setrlimit(u_int which, \
			    struct linux_rlimit *rlp); }
76	STD		{ int linux_sys_getrlimit(u_int which, \
			    struct linux_rlimit *rlp); }
d173 1
a173 1
101	STD		{ int linux_sys_ioperm(void); }
d176 1
a176 1
103	STD		{ int linux_sys_klog(void); }
d190 1
a190 1
110	STD		{ int linux_sys_iopl(void); }
d192 3
a194 3
111	STD		{ int linux_sys_vhangup(void); }
112	STD		{ int linux_sys_idle(void); }
113	STD		{ int linux_sys_vm86old(void); }
d197 2
a198 2
115	STD		{ int linux_sys_swapoff(void); }
116	STD		{ int linux_sys_sysinfo(void); }
d203 1
a203 1
120	STD		{ int linux_sys_clone(int flags, void *stack); }
d211 1
a211 1
123	STD		{ int linux_sys_modify_ldt(void); }
d213 1
a213 1
124	STD		{ int linux_sys_adjtimex(void); }
d217 5
a221 5
127	STD		{ int linux_sys_create_module(void); }
128	STD		{ int linux_sys_init_module(void); }
129	STD		{ int linux_sys_delete_module(void); }
130	STD		{ int linux_sys_get_kernel_syms(void); }
131	STD		{ int linux_sys_quotactl(void); }
d224 2
a225 2
134	STD		{ int linux_sys_bdflush(void); }
135	STD		{ int linux_sys_sysfs(void); }
d227 3
a229 3
137	STD		{ int linux_sys_afs_syscall(void); }
138	STD		{ int linux_sys_setfsuid(uid_t uid); }
139	NOARGS		{ int linux_sys_getfsuid(void); }
d248 10
a257 13
152	STD		{ int linux_sys_mlockall(void); }
153	STD		{ int linux_sys_munlockall(void); }
154	STD		{ int linux_sys_sched_setparam(linux_pid_t pid, \
			    const struct linux_sched_param *sp); }
155	STD		{ int linux_sys_sched_getparam(linux_pid_t pid, \
			    struct linux_sched_param *sp); }
156	STD		{ int linux_sys_sched_setscheduler(linux_pid_t pid, \
			    int policy, const struct linux_sched_param *sp); }
157	STD		{ int linux_sys_sched_getscheduler(linux_pid_t pid); }
158	STD		{ int linux_sys_sched_yield(void); }
159	STD		{ int linux_sys_sched_get_priority_max(int policy); }
160	STD		{ int linux_sys_sched_get_priority_min(int policy); }
161	STD		{ int linux_sys_sched_rr_get_interval(void); }
d266 2
a267 2
166	STD		{ int linux_sys_vm86(void); }
167	STD		{ int linux_sys_query_module(void); }
d270 3
a272 1
169	STD		{ int linux_sys_nfsservctl(void); }
d277 2
a278 3
172	STD		{ int linux_sys_prctl(void); }
173	STD     	{ int linux_sys_rt_sigreturn( \
	                    struct linux_rt_sigframe *sfp); }
d288 2
a289 2
177	STD		{ int linux_sys_rt_sigtimedwait(void); }
178	STD		{ int linux_sys_rt_queueinfo(void); }
d292 2
a293 4
180	STD		{ int linux_sys_pread(int fd, char *buf, \
			    size_t nbyte, linux_off_t offset); }
181	STD		{ int linux_sys_pwrite(int fd, char *buf, \
			    size_t nbyte, linux_off_t offset); }
d295 7
a301 9
183	STD		{ int linux_sys_getcwd(char *bufp, size_t length); }
184	STD		{ int linux_sys_capget(void); }
185	STD		{ int linux_sys_capset(void); }
186	STD		{ int linux_sys_sigaltstack( \
			    const struct linux_sigaltstack *nss, \
			    struct linux_sigaltstack *oss); }
187	STD		{ int linux_sys_sendfile(void); }
188	STD		{ int linux_sys_getpmsg(void); }
189	STD		{ int linux_sys_putpmsg(void); }
a302 13
191	STD		{ int linux_sys_ugetrlimit(u_int which, \
			    struct linux_rlimit *rlp); }
192     STD		{ int linux_sys_mmap2(void); }
193     STD        	{ int linux_sys_truncate64(char *path, \
			    off_t length); }
194	NOARGS		linux_ftruncate64 { int sys_ftruncate(int fd, off_t length); }
195     STD        	{ int linux_sys_stat64(char *path, \
			    struct linux_stat64 *sp); }
196     STD        	{ int linux_sys_lstat64(char *path, \
			    struct linux_stat64 *sp); }
197     STD        	{ int linux_sys_fstat64(int fd, \
			    struct linux_stat64 *sp); }

@


1.14.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.14.2.3 2001/05/14 22:04:54 niklas Exp $
d65 1
a65 2
16	STD		{ int linux_sys_lchown16(char *path, int uid, \
			    int gid); }
d74 2
a75 2
23	NOARGS		linux_setuid16 { int sys_setuid(uid_t uid); }
24	NOARGS		linux_getuid16 { uid_t sys_getuid(void); }
d98 2
a99 2
46	NOARGS		linux_setgid16 { int sys_setgid(gid_t gid); }
47	NOARGS		linux_getgid16 { gid_t sys_getgid(void); }
d102 2
a103 2
49	NOARGS		linux_geteuid16 { uid_t sys_geteuid(void); }
50	NOARGS		linux_getegid16 { gid_t sys_getegid(void); }
d126 2
a127 2
70	STD		{ int linux_sys_setreuid16(int ruid, int euid); }
71	STD		{ int linux_sys_setregid16(int rgid, int egid); }
d142 2
a143 4
80	NOARGS		linux_getgroups { int sys_getgroups(u_int gidsetsize, \
			    gid_t *gidset); }
81	NOARGS		linux_setgroups { int sys_setgroups(u_int gidsetsize, \
			    gid_t *gidset); }
d160 1
a160 1
95	STD		{ int linux_sys_fchown16(int fd, int uid, int gid); }
d228 2
a229 2
138	NOARGS		linux_setfsuid16 { int linux_sys_setfsuid(uid_t uid); }
139	NOARGS		linux_getfsuid16 { int linux_sys_getfsuid(void); }
d265 1
a265 1
164	STD		{ int linux_sys_setresuid16(uid_t ruid, uid_t euid, \
d267 2
a268 2
165	NOARGS		linux_getresuid16 { int linux_sys_getresuid( \
			    uid_t *ruid, uid_t *euid, uid_t *suid); }
d274 1
a274 1
170	STD		{ int linux_sys_setresgid16(gid_t rgid, gid_t egid, \
d276 1
a276 1
171	STD		{ int linux_sys_getresgid16(gid_t *rgid, gid_t *egid, \
d298 1
a298 2
182	STD		{ int linux_sys_chown16(char *path, int uid, \
			    int gid); }
d321 1
a321 25
198	NOARGS		{ int linux_sys_lchown(void); }
199	NOARGS		{ uid_t sys_getuid(void); }
200	NOARGS		{ gid_t sys_getgid(void); }
201	NOARGS		{ uid_t sys_geteuid(void); }
202	NOARGS		{ gid_t sys_getegid(void); }
203	NOARGS		{ int linux_sys_setreuid(void); }
204	NOARGS		{ int linux_sys_setregid(void); }
205	NOARGS		{ int sys_getgroups(u_int gidsetsize, gid_t *gidset); }
206	NOARGS		{ int sys_setgroups(u_int gidsetsize, gid_t *gidset); }
207	NOARGS		{ int linux_sys_fchown(void); }
208	NOARGS		{ int linux_sys_setresuid(void); }
209	STD		{ int linux_sys_getresuid(uid_t *ruid, uid_t *euid, \
			    uid_t *suid); }
210	NOARGS		{ int linux_sys_setresgid(void); }
211	NOARGS		{ int linux_sys_getresgid(void); }
212	NOARGS		{ int linux_sys_chown(void); }
213	NOARGS		{ int sys_setuid(uid_t uid); }
214	NOARGS		{ int sys_setgid(gid_t gid); }
215	STD		{ int linux_sys_setfsuid(uid_t uid); }
216	NOARGS		{ int linux_sys_setfsgid(void); }
217	NOARGS		{ int linux_sys_pivot_root(void); }
218	NOARGS		{ int linux_sys_mincore(void); }
219	NOARGS		{ int linux_sys_madvise(void); }
220	NOARGS		{ int linux_sys_getdents64(void); }
221	NOARGS		{ int linux_sys_fcntl64(void); }
@


1.14.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
	$OpenBSD$
d349 1
a349 1
221	STD		{ int linux_sys_fcntl64(u_int fd, u_int cmd, void *arg); }
@


1.14.2.6
log
@Merge in -current from about a week ago
@
text
@a77 1
#ifdef PTRACE
a78 3
#else
26	UNIMPL		ptrace
#endif
@


1.14.2.7
log
@Sync the SMP branch with 3.3
@
text
@d71 1
a71 1
20	STD		{ pid_t linux_sys_getpid(void); }
d76 1
a76 1
24	STD		linux_getuid16 { uid_t linux_sys_getuid(void); }
d104 1
a104 1
47	STD		linux_getgid16 { gid_t linux_sys_getgid(void); }
d272 4
a275 4
164	STD		{ int linux_sys_setresuid16(u_int16_t ruid, \
			    u_int16_t euid, u_int16_t suid); }
165	STD		{ int linux_sys_getresuid16(u_int16_t *ruid, \
			    u_int16_t *euid, u_int16_t *suid); }
d281 4
a284 4
170	STD		{ int linux_sys_setresgid16(u_int16_t rgid, \
			    u_int16_t egid, u_int16_t sgid); }
171	STD		{ int linux_sys_getresgid16(u_int16_t *rgid, \
			    u_int16_t *egid, u_int16_t *sgid); }
d330 2
a331 2
199	STD		{ uid_t linux_sys_getuid(void); }
200	STD		{ gid_t linux_sys_getgid(void); }
d339 2
a340 3
208	NOARGS		{ int sys_setresuid(uid_t ruid, uid_t euid, \
			    uid_t suid); }
209	NOARGS		{ int sys_getresuid(uid_t *ruid, uid_t *euid, \
d342 2
a343 4
210	NOARGS		{ int sys_setresgid(gid_t rgid, gid_t egid, \
			    gid_t sgid); }
211	NOARGS		{ int sys_getresgid(gid_t *rgid, gid_t *egid, \
			    gid_t *sgid); }
d352 1
a352 2
220	STD		{ int linux_sys_getdents64(int fd, void *dirent, \
			    unsigned count); }
@


1.14.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.14.2.7 2003/03/27 23:53:47 niklas Exp $
d158 1
a158 1
87	NOARGS		{ int compat_25_sys_swapon(char *name); }
@


1.14.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
	$OpenBSD$
a42 1
#include <compat/linux/linux_misc.h>
d205 1
a205 1
116	STD		{ int linux_sys_sysinfo(struct linux_sys_sysinfo_args *sysinfo); }
d270 2
a271 2
163	STD		{ int linux_sys_mremap(void *old_address, \
			    size_t old_size, size_t new_size, long flags); }
d319 5
a323 6
192	STD		{ linux_off_t linux_sys_mmap2(unsigned long addr, \
			   size_t len, int prot, int flags, int fd, \
			   linux_off_t offset); }
193	STD		{ int linux_sys_truncate64(char *path, off_t length); }
194	STD		{ int linux_sys_ftruncate64(int fd, off_t length); }
195	STD        	{ int linux_sys_stat64(char *path, \
d325 1
a325 1
196	STD        	{ int linux_sys_lstat64(char *path, \
d327 1
a327 1
197	STD        	{ int linux_sys_fstat64(int fd, \
d357 1
a357 48
221	STD		{ int linux_sys_fcntl64(u_int fd, u_int cmd, \
			    void *arg); }
222	UNIMPL
223	UNIMPL
224	UNIMPL		linux_sys_gettid
225	UNIMPL		linux_sys_readahead
226	NOARGS		{ int linux_sys_setxattr(void); }
227	NOARGS		{ int linux_sys_lsetxattr(void); }
228	NOARGS		{ int linux_sys_fsetxattr(void); }
229	NOARGS		{ int linux_sys_getxattr(void); }
230	NOARGS		{ int linux_sys_lgetxattr(void); }
231	NOARGS		{ int linux_sys_fgetxattr(void); }
232	NOARGS		{ int linux_sys_listxattr(void); }
233	NOARGS		{ int linux_sys_llistxattr(void); }
234	NOARGS		{ int linux_sys_flistxattr(void); }
235	NOARGS		{ int linux_sys_removexattr(void); }
236	NOARGS		{ int linux_sys_lremovexattr(void); }
237	NOARGS		{ int linux_sys_fremovexattr(void); }
238	UNIMPL		linux_sys_tkill
239	UNIMPL		linux_sys_sendfile64
240	UNIMPL		linux_sys_futex
241	UNIMPL		linux_sys_sched_setaffinity
242	UNIMPL		linux_sys_sched_getaffinity
243	UNIMPL		linux_sys_set_thread_area
244	UNIMPL		linux_sys_get_thread_area
245	UNIMPL		linux_sys_io_setup
246	UNIMPL		linux_sys_io_destroy
247	UNIMPL		linux_sys_io_getevents
248	UNIMPL		linux_sys_io_submit
249	UNIMPL		linux_sys_io_cancel
250	NOARGS		{ int linux_sys_fadvise64(void); }
251	UNIMPL		
252	NOARGS		linux_exit_group { int sys_exit(int rval); }
253	UNIMPL		linux_sys_lookup_dcookie
254	UNIMPL		linux_sys_epoll_create
255	UNIMPL		linux_sys_epoll_ctl
256	UNIMPL		linux_sys_epoll_wait
257	UNIMPL		linux_sys_remap_file_pages
258	UNIMPL		linux_sys_set_tid_address
259	UNIMPL		linux_sys_timer_create
260	UNIMPL		linux_sys_timer_settime
261	UNIMPL		linux_sys_timer_gettime
262	UNIMPL		linux_sys_timer_getoverrun
263	UNIMPL		linux_sys_timer_delete
264	UNIMPL		linux_sys_clock_settime
265	UNIMPL		linux_sys_clock_gettime
266	UNIMPL		linux_sys_clock_getres
267	UNIMPL		linux_sys_clock_nanosleep
@


1.14.2.10
log
@Merge with the trunk
@
text
@a109 1
#ifdef ACCOUNTING
a110 3
#else
51	UNIMPL		acct
#endif
d356 1
a356 1
219	NOARGS		{ int sys_madvise(void *addr, size_t len, int behav); }
@


1.13
log
@nanosleep emulation
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.12 1997/11/13 18:35:27 deraadt Exp $
d76 1
a76 1
25	UNIMPL		stime
@


1.12
log
@make msync() have 3 args
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.11 1997/07/28 10:21:31 deraadt Exp $
d258 2
a259 1
162	UNIMPL		nanosleep
@


1.11
log
@i screwed up twice in 20 seconds, wow
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.10 1997/07/28 10:19:35 deraadt Exp $
d238 1
a238 1
144	STD		{ int linux_sys_msync(caddr_t addr, int len, int fl); }
@


1.10
log
@oops
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.9 1997/07/27 21:01:37 deraadt Exp $
d259 1
a259 1
163	STD		{ int sys_mremap(void *old_address, size_t old_size, \
@


1.9
log
@mremap non-emulation; tron@@lyssa.owl.de
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.8 1997/04/14 11:16:31 graichen Exp $
d259 1
a259 1
163	STD		{ int mremap(void *old_address, size_t old_size, \
@


1.8
log
@#34 - linux_sys_nice from NetBSD
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.7 1996/05/22 12:01:51 deraadt Exp $
d259 2
a260 1
163	UNIMPL		mremap
@


1.7
log
@sync
@
text
@d1 1
a1 1
	$OpenBSD$
d86 1
a86 1
34	UNIMPL		nice
@


1.6
log
@Reran makesyscalls.sh for addition of Linux dummy mount/umount() syscalls.
Fixed OpenBSD tag damage during previous checkin.
@
text
@d243 17
@


1.5
log
@Added dummy mount/umount() syscalls for bogus Linux applications that
blindly call mount().  These dummy calls always return EPERM.  Fixed
uncommented NetBSD tag problem encountered when using makesyscalls.sh.
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.4 1996/04/17 05:24:13 mickey Exp$
@


1.4
log
@Good fixes and changes from latest Net.
@
text
@d1 2
a2 2
	$OpenBSD$
	$NetBSD: syscalls.master,v 1.15 1995/12/18 14:35:10 fvdl Exp $
d71 3
a73 2
21	UNIMPL		mount
22	UNIMPL		umount
@


1.3
log
@from fvdl; add msync(), readv() and writev()
@
text
@d1 1
d6 1
a6 1
; NetBSD COMPAT_LINUX system call name/number "master" file.
@


1.2
log
@update from netbsd
@
text
@d1 1
a1 1
	$NetBSD: syscalls.master,v 1.14 1995/12/09 04:01:47 mycroft Exp $
d236 5
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
	$NetBSD: syscalls.master,v 1.13 1995/10/07 06:27:15 mycroft Exp $
d48 1
a48 1
2	STD		{ int linux_sys_fork(void); }
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
