head	1.31;
access;
symbols
	OPENBSD_5_9:1.30.0.6
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.8
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.4
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.2
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.25.0.2
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.12
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.14
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.10
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.8
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.6
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.14
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.12
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.10
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.8
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.6
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.6
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.21
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	SMP:1.9.0.10
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.8
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.6
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.03.02.15.41.48;	author naddy;	state dead;
branches;
next	1.30;
commitid	ZfNt0OHZhMg52abA;

1.30
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2014.01.23.23.46.42;	author pirofti;	state Exp;
branches;
next	1.28;

1.28
date	2013.05.10.10.31.16;	author pirofti;	state Exp;
branches;
next	1.27;

1.27
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2011.11.25.10.10.05;	author robert;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.07.01.19.39;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2006.09.25.07.12.57;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.13.04.01.37;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.50;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.13.19.08.06;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.02.16.05.58;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.10.26.12.03.27;	author art;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.07.03.15.32.34;	author jasoni;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.10.15.33.09;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.07.17.52.23;	author ericj;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.23.22.24.37;	author jasoni;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.21.15.50.20;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.19.08.34.56;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.04.05.31.50;	author jasoni;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.28.13.29.29;	author jasoni;	state Exp;
branches;
next	1.9;

1.9
date	97.11.13.06.37.48;	author deraadt;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	97.09.05.04.35.14;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.27.21.01.36;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.27.00.50.30;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.01.27.00.33.04;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.12.25.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.12.01.48;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.17.05.23.49;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.18;	author deraadt;	state Exp;
branches;
next	;

1.9.10.1
date	2000.03.02.07.04.34;	author niklas;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2001.05.14.22.04.39;	author niklas;	state Exp;
branches;
next	1.9.10.3;

1.9.10.3
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.9.10.4;

1.9.10.4
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.9.10.5;

1.9.10.5
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.9.10.6;

1.9.10.6
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.31
log
@remove the Linux emulation code, no longer referenced by anything
@
text
@/*	$OpenBSD: linux_file.c,v 1.30 2014/03/26 05:23:42 guenther Exp $	*/
/*	$NetBSD: linux_file.c,v 1.15 1996/05/20 01:59:09 fvdl Exp $	*/

/*
 * Copyright (c) 1995 Frank van der Linden
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project
 *      by Frank van der Linden
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/mount.h>
#include <sys/signalvar.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/vnode.h>
#include <sys/tty.h>
#include <sys/conf.h>
#include <sys/stdint.h>

#include <sys/syscallargs.h>

#include <compat/linux/linux_types.h>
#include <compat/linux/linux_signal.h>
#include <compat/linux/linux_syscallargs.h>
#include <compat/linux/linux_fcntl.h>
#include <compat/linux/linux_util.h>

#include <machine/linux_machdep.h>

static int linux_to_bsd_ioflags(int);
static int bsd_to_linux_ioflags(int);
static void bsd_to_linux_flock(struct flock *, struct linux_flock *);
static void linux_to_bsd_flock(struct linux_flock *, struct flock *);
static int bsd_to_linux_stat(struct stat *, struct linux_stat *);
static int linux_stat1(struct proc *, void *, register_t *, int);


/*
 * Some file-related calls are handled here. The usual flag conversion
 * an structure conversion is done, and alternate emul path searching.
 */

/*
 * The next two functions convert between the Linux and OpenBSD values
 * of the flags used in open(2) and fcntl(2).
 */
static int
linux_to_bsd_ioflags(lflags)
	int lflags;
{
	int res = 0;

	res |= cvtto_bsd_mask(lflags, LINUX_O_WRONLY, O_WRONLY);
	res |= cvtto_bsd_mask(lflags, LINUX_O_RDONLY, O_RDONLY);
	res |= cvtto_bsd_mask(lflags, LINUX_O_RDWR, O_RDWR);
	res |= cvtto_bsd_mask(lflags, LINUX_O_CREAT, O_CREAT);
	res |= cvtto_bsd_mask(lflags, LINUX_O_EXCL, O_EXCL);
	res |= cvtto_bsd_mask(lflags, LINUX_O_NOCTTY, O_NOCTTY);
	res |= cvtto_bsd_mask(lflags, LINUX_O_TRUNC, O_TRUNC);
	res |= cvtto_bsd_mask(lflags, LINUX_O_NDELAY, O_NDELAY);
	res |= cvtto_bsd_mask(lflags, LINUX_O_SYNC, O_SYNC);
	res |= cvtto_bsd_mask(lflags, LINUX_FASYNC, O_ASYNC);
	res |= cvtto_bsd_mask(lflags, LINUX_O_APPEND, O_APPEND);

	return res;
}

static int
bsd_to_linux_ioflags(bflags)
	int bflags;
{
	int res = 0;

	res |= cvtto_linux_mask(bflags, O_WRONLY, LINUX_O_WRONLY);
	res |= cvtto_linux_mask(bflags, O_RDONLY, LINUX_O_RDONLY);
	res |= cvtto_linux_mask(bflags, O_RDWR, LINUX_O_RDWR);
	res |= cvtto_linux_mask(bflags, O_CREAT, LINUX_O_CREAT);
	res |= cvtto_linux_mask(bflags, O_EXCL, LINUX_O_EXCL);
	res |= cvtto_linux_mask(bflags, O_NOCTTY, LINUX_O_NOCTTY);
	res |= cvtto_linux_mask(bflags, O_TRUNC, LINUX_O_TRUNC);
	res |= cvtto_linux_mask(bflags, O_NDELAY, LINUX_O_NDELAY);
	res |= cvtto_linux_mask(bflags, O_SYNC, LINUX_O_SYNC);
	res |= cvtto_linux_mask(bflags, O_ASYNC, LINUX_FASYNC);
	res |= cvtto_linux_mask(bflags, O_APPEND, LINUX_O_APPEND);

	return res;
}

/*
 * creat(2) is an obsolete function, but it's present as a Linux
 * system call, so let's deal with it.
 *
 * Just call open(2) with the TRUNC, CREAT and WRONLY flags.
 */
int
linux_sys_creat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_creat_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
	} */ *uap = v;
	struct sys_open_args oa;
	caddr_t sg;

	sg = stackgap_init(p);
	LINUX_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));

	SCARG(&oa, path) = SCARG(uap, path);
	SCARG(&oa, flags) = O_CREAT | O_TRUNC | O_WRONLY;
	SCARG(&oa, mode) = SCARG(uap, mode);

	return sys_open(p, &oa, retval);
}

/*
 * open(2). Take care of the different flag values, and let the
 * OpenBSD syscall do the real work. See if this operation
 * gives the current process a controlling terminal.
 * (XXX is this necessary?)
 */
int
linux_sys_open(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_open_args /* {
		syscallarg(char *) path;
		syscallarg(int) flags;
		syscallarg(int) mode;
	} */ *uap = v;
	int error, fl;
	struct sys_open_args boa;
	caddr_t sg;

	sg = stackgap_init(p);

	fl = linux_to_bsd_ioflags(SCARG(uap, flags));

	if (fl & O_CREAT)
		LINUX_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));
	else
		LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&boa, path) = SCARG(uap, path);
	SCARG(&boa, flags) = fl;
	SCARG(&boa, mode) = SCARG(uap, mode);

	if ((error = sys_open(p, &boa, retval)))
		return error;

	/*
	 * this bit from sunos_misc.c (and svr4_fcntl.c).
	 * If we are a session leader, and we don't have a controlling
	 * terminal yet, and the O_NOCTTY flag is not set, try to make
	 * this the controlling terminal.
	 */ 
        if (!(fl & O_NOCTTY) && SESS_LEADER(p->p_p) &&
	    !(p->p_p->ps_flags & PS_CONTROLT)) {
                struct filedesc *fdp = p->p_fd;
                struct file     *fp;

		if ((fp = fd_getfile(fdp, *retval)) == NULL)
			return (EBADF);
		FREF(fp);
                if (fp->f_type == DTYPE_VNODE)
                        (fp->f_ops->fo_ioctl) (fp, TIOCSCTTY, (caddr_t) 0, p);
		FRELE(fp, p);
        }
	return 0;
}

int
linux_sys_lseek(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_lseek_args /* {
		syscallarg(int) fd;
		syscallarg(long) offset;
		syscallarg(int) whence;
	} */ *uap = v;
	struct sys_lseek_args bla;

	SCARG(&bla, fd) = SCARG(uap, fd);
	SCARG(&bla, offset) = SCARG(uap, offset);
	SCARG(&bla, whence) = SCARG(uap, whence);

	return sys_lseek(p, &bla, retval);
}

/*
 * This appears to be part of a Linux attempt to switch to 64 bits file sizes.
 */
int
linux_sys_llseek(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_llseek_args /* {
		syscallarg(int) fd;
		syscallarg(uint32_t) ohigh;
		syscallarg(uint32_t) olow;
		syscallarg(caddr_t) res;
		syscallarg(int) whence;
	} */ *uap = v;
	struct sys_lseek_args bla;
	int error;
	off_t off;

	off = SCARG(uap, olow) | (((off_t) SCARG(uap, ohigh)) << 32);

	SCARG(&bla, fd) = SCARG(uap, fd);
	SCARG(&bla, offset) = off;
	SCARG(&bla, whence) = SCARG(uap, whence);

	if ((error = sys_lseek(p, &bla, retval)))
		return error;

	if ((error = copyout(retval, SCARG(uap, res), sizeof (off_t))))
		return error;

	retval[0] = 0;
	return 0;
}

/*
 * The next two functions take care of converting the flock
 * structure back and forth between Linux and OpenBSD format.
 * The only difference in the structures is the order of
 * the fields, and the 'whence' value.
 */
static void
bsd_to_linux_flock(bfp, lfp)
	struct flock *bfp;
	struct linux_flock *lfp;
{

	lfp->l_start = bfp->l_start;
	lfp->l_len = bfp->l_len;
	lfp->l_pid = bfp->l_pid;
	lfp->l_whence = bfp->l_whence;
	switch (bfp->l_type) {
	case F_RDLCK:
		lfp->l_type = LINUX_F_RDLCK;
		break;
	case F_UNLCK:
		lfp->l_type = LINUX_F_UNLCK;
		break;
	case F_WRLCK:
		lfp->l_type = LINUX_F_WRLCK;
		break;
	}
}

static void
linux_to_bsd_flock(lfp, bfp)
	struct linux_flock *lfp;
	struct flock *bfp;
{

	bfp->l_start = lfp->l_start;
	bfp->l_len = lfp->l_len;
	bfp->l_pid = lfp->l_pid;
	bfp->l_whence = lfp->l_whence;
	switch (lfp->l_type) {
	case LINUX_F_RDLCK:
		bfp->l_type = F_RDLCK;
		break;
	case LINUX_F_UNLCK:
		bfp->l_type = F_UNLCK;
		break;
	case LINUX_F_WRLCK:
		bfp->l_type = F_WRLCK;
		break;
	}
}

/*
 * Most actions in the fcntl() call are straightforward; simply
 * pass control to the OpenBSD system call. A few commands need
 * conversions after the actual system call has done its work,
 * because the flag values and lock structure are different.
 */
int
linux_sys_fcntl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_fcntl_args /* {
		syscallarg(int) fd;
		syscallarg(int) cmd;
		syscallarg(void *) arg;
	} */ *uap = v;
	int fd, cmd, error;
	intptr_t val;
	caddr_t arg, sg;
	struct linux_flock lfl;
	struct flock *bfp, bfl;
	struct sys_fcntl_args fca;
	struct filedesc *fdp;
	struct file *fp;
	struct vnode *vp;
	struct vattr va;
	long pgid;
	struct pgrp *pgrp;
	struct tty *tp, *(*d_tty)(dev_t);

	fd = SCARG(uap, fd);
	cmd = SCARG(uap, cmd);
	arg = (caddr_t) SCARG(uap, arg);

	switch (cmd) {
	case LINUX_F_DUPFD:
		cmd = F_DUPFD;
		break;
	case LINUX_F_GETFD:
		cmd = F_GETFD;
		break;
	case LINUX_F_SETFD:
		cmd = F_SETFD;
		break;
	case LINUX_F_GETFL:
		SCARG(&fca, fd) = fd;
		SCARG(&fca, cmd) = F_GETFL;
		SCARG(&fca, arg) = arg;
		if ((error = sys_fcntl(p, &fca, retval)))
			return error;
		retval[0] = bsd_to_linux_ioflags(retval[0]);
		return 0;
	case LINUX_F_SETFL:
		val = linux_to_bsd_ioflags((intptr_t)SCARG(uap, arg));
		SCARG(&fca, fd) = fd;
		SCARG(&fca, cmd) = F_SETFL;
		SCARG(&fca, arg) = (caddr_t) val;
		return sys_fcntl(p, &fca, retval);
	case LINUX_F_GETLK:
		sg = stackgap_init(p);
		if ((error = copyin(arg, &lfl, sizeof lfl)))
			return error;
		linux_to_bsd_flock(&lfl, &bfl);
		bfp = (struct flock *) stackgap_alloc(&sg, sizeof *bfp);
		SCARG(&fca, fd) = fd;
		SCARG(&fca, cmd) = F_GETLK;
		SCARG(&fca, arg) = bfp;
		if ((error = copyout(&bfl, bfp, sizeof bfl)))
			return error;
		if ((error = sys_fcntl(p, &fca, retval)))
			return error;
		if ((error = copyin(bfp, &bfl, sizeof bfl)))
			return error;
		bsd_to_linux_flock(&bfl, &lfl);
		error = copyout(&lfl, arg, sizeof lfl);
		return error;
		break;
	case LINUX_F_SETLK:
	case LINUX_F_SETLKW:
		cmd = (cmd == LINUX_F_SETLK ? F_SETLK : F_SETLKW);
		if ((error = copyin(arg, &lfl, sizeof lfl)))
			return error;
		linux_to_bsd_flock(&lfl, &bfl);
		sg = stackgap_init(p);
		bfp = (struct flock *) stackgap_alloc(&sg, sizeof *bfp);
		if ((error = copyout(&bfl, bfp, sizeof bfl)))
			return error;
		SCARG(&fca, fd) = fd;
		SCARG(&fca, cmd) = cmd;
		SCARG(&fca, arg) = bfp;
		return sys_fcntl(p, &fca, retval);
		break;
	case LINUX_F_SETOWN:
	case LINUX_F_GETOWN:	
		/*
		 * We need to route around the normal fcntl() for these calls,
		 * since it uses TIOC{G,S}PGRP, which is too restrictive for
		 * Linux F_{G,S}ETOWN semantics. For sockets, this problem
		 * does not exist.
		 */
		fdp = p->p_fd;
		if ((fp = fd_getfile(fdp, fd)) == NULL)
			return (EBADF);
		if (fp->f_type == DTYPE_SOCKET) {
			cmd = cmd == LINUX_F_SETOWN ? F_SETOWN : F_GETOWN;
			break;
		}
		vp = (struct vnode *)fp->f_data;
		if (vp->v_type != VCHR)
			return EINVAL;
		FREF(fp);
		error = VOP_GETATTR(vp, &va, p->p_ucred, p);
		FRELE(fp, p);
		if (error)
			return error;
		d_tty = cdevsw[major(va.va_rdev)].d_tty;
		if (!d_tty || (!(tp = (*d_tty)(va.va_rdev))))
			return EINVAL;
		if (cmd == LINUX_F_GETOWN) {
			retval[0] = tp->t_pgrp ? tp->t_pgrp->pg_id : NO_PID;
			return 0;
		}
		if ((long)arg <= 0) {
			pgid = -(long)arg;
		} else {
			struct process *pr = prfind((long)arg);
			if (pr == 0)
				return (ESRCH);
			pgid = (long)pr->ps_pgrp->pg_id;
		}
		pgrp = pgfind(pgid);
		if (pgrp == NULL || pgrp->pg_session != p->p_p->ps_session)
			return EPERM;
		tp->t_pgrp = pgrp;
		return 0;
	default:
		return EOPNOTSUPP;
	}

	SCARG(&fca, fd) = fd;
	SCARG(&fca, cmd) = cmd;
	SCARG(&fca, arg) = arg;

	return sys_fcntl(p, &fca, retval);
}

/*
 * Convert a OpenBSD stat structure to a Linux stat structure.
 * Only the order of the fields and the padding in the structure
 * is different. linux_fakedev is a machine-dependent function
 * which optionally converts device driver major/minor numbers
 * (XXX horrible, but what can you do against code that compares
 * things against constant major device numbers? sigh)
 */
static int
bsd_to_linux_stat(bsp, lsp)
	struct stat *bsp;
	struct linux_stat *lsp;
{
	if (bsp->st_ino > LINUX_INO_MAX)
		return EOVERFLOW;

	lsp->lst_dev     = bsp->st_dev;
	lsp->lst_ino     = (linux_ino_t)bsp->st_ino;
	lsp->lst_mode    = bsp->st_mode;
	lsp->lst_nlink   = bsp->st_nlink;
	lsp->lst_uid     = bsp->st_uid;
	lsp->lst_gid     = bsp->st_gid;
	lsp->lst_rdev    = linux_fakedev(bsp->st_rdev);
	lsp->lst_size    = bsp->st_size;
	lsp->lst_blksize = bsp->st_blksize;
	lsp->lst_blocks  = bsp->st_blocks;
	lsp->lst_atime   = bsp->st_atime;
	lsp->lst_mtime   = bsp->st_mtime;
	lsp->lst_ctime   = bsp->st_ctime;

	return 0;
}

/*
 * The stat functions below are plain sailing. stat and lstat are handled
 * by one function to avoid code duplication.
 */
int
linux_sys_fstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_fstat_args /* {
		syscallarg(int) fd;
		syscallarg(linux_stat *) sp;
	} */ *uap = v;
	struct sys_fstat_args fsa;
	struct linux_stat tmplst;
	struct stat *st,tmpst;
	caddr_t sg;
	int error;

	sg = stackgap_init(p);

	st = stackgap_alloc(&sg, sizeof (struct stat));

	SCARG(&fsa, fd) = SCARG(uap, fd);
	SCARG(&fsa, sb) = st;

	if ((error = sys_fstat(p, &fsa, retval)))
		return error;

	if ((error = copyin(st, &tmpst, sizeof tmpst)))
		return error;

	if ((error = bsd_to_linux_stat(&tmpst, &tmplst)))
		return error;

	if ((error = copyout(&tmplst, SCARG(uap, sp), sizeof tmplst)))
		return error;

	return 0;
}

static int
linux_stat1(p, v, retval, dolstat)
	struct proc *p;
	void *v;
	register_t *retval;
	int dolstat;
{
	struct sys_stat_args sa;
	struct linux_stat tmplst;
	struct stat *st, tmpst;
	caddr_t sg;
	int error;
	struct linux_sys_stat_args *uap = v;

	sg = stackgap_init(p);

	st = stackgap_alloc(&sg, sizeof (struct stat));
	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&sa, ub) = st;
	SCARG(&sa, path) = SCARG(uap, path);

	if ((error = (dolstat ? sys_lstat(p, &sa, retval) :
				sys_stat(p, &sa, retval))))
		return error;

	if ((error = copyin(st, &tmpst, sizeof tmpst)))
		return error;

	if ((error = bsd_to_linux_stat(&tmpst, &tmplst)))
		return error;

	if ((error = copyout(&tmplst, SCARG(uap, sp), sizeof tmplst)))
		return error;

	return 0;
}

int
linux_sys_stat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_stat_args /* {
		syscallarg(char *) path;
		syscallarg(struct linux_stat *) sp;
	} */ *uap = v;

	return linux_stat1(p, uap, retval, 0);
}

int
linux_sys_lstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_lstat_args /* {
		syscallarg(char *) path;
		syscallarg(struct linux_stat *) sp;
	} */ *uap = v;

	return linux_stat1(p, uap, retval, 1);
}

/*
 * The following syscalls are mostly here because of the alternate path check.
 */
int
linux_sys_access(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_access_args /* {
		syscallarg(char *) path;
		syscallarg(int) flags;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p);

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return sys_access(p, uap, retval);
}

int
linux_sys_unlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;

{
	struct linux_sys_unlink_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p);

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return sys_unlink(p, uap, retval);
}

int
linux_sys_chdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_chdir_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p);

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return sys_chdir(p, uap, retval);
}

int
linux_sys_mknod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_mknod_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
		syscallarg(int) dev;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p);
	struct sys_mkfifo_args bma;

	LINUX_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));

	/*
	 * BSD handles FIFOs separately
	 */
	if (S_ISFIFO(SCARG(uap, mode))) {
		SCARG(&bma, path) = SCARG(uap, path);
		SCARG(&bma, mode) = SCARG(uap, mode);
		return sys_mkfifo(p, uap, retval);
	} else
		return sys_mknod(p, uap, retval);
}

int
linux_sys_chmod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_chmod_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p);

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return sys_chmod(p, uap, retval);
}

int
linux_sys_chown(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_chown_args /* {
		syscallarg(char *) path;
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p);

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return sys_chown(p, uap, retval);
}

int
linux_sys_chown16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_chown16_args /* {
		syscallarg(char *) path;
		syscallarg(int) uid;
		syscallarg(int) gid;
	} */ *uap = v;
	struct sys_chown_args bca;
	caddr_t sg = stackgap_init(p);

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&bca, path) = SCARG(uap, path);
	SCARG(&bca, uid) = ((linux_uid_t)SCARG(uap, uid) == (linux_uid_t)-1) ?
		(uid_t)-1 : SCARG(uap, uid);
	SCARG(&bca, gid) = ((linux_gid_t)SCARG(uap, gid) == (linux_gid_t)-1) ?
		(gid_t)-1 : SCARG(uap, gid);
	
	return sys_chown(p, &bca, retval);
}

int
linux_sys_fchown16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_fchown16_args /* {
		syscallarg(int) fd;
		syscallarg(int) uid;
		syscallarg(int) gid;
	} */ *uap = v;
	struct sys_fchown_args bfa;

	SCARG(&bfa, fd) = SCARG(uap, fd);
	SCARG(&bfa, uid) = ((linux_uid_t)SCARG(uap, uid) == (linux_uid_t)-1) ?
		(uid_t)-1 : SCARG(uap, uid);
	SCARG(&bfa, gid) = ((linux_gid_t)SCARG(uap, gid) == (linux_gid_t)-1) ?
		(gid_t)-1 : SCARG(uap, gid);
	
	return sys_fchown(p, &bfa, retval);
}

int
linux_sys_lchown16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_lchown16_args /* {
		syscallarg(char *) path;
		syscallarg(int) uid;
		syscallarg(int) gid;
	} */ *uap = v;
	struct sys_lchown_args bla;

	SCARG(&bla, path) = SCARG(uap, path);
	SCARG(&bla, uid) = ((linux_uid_t)SCARG(uap, uid) == (linux_uid_t)-1) ?
		(uid_t)-1 : SCARG(uap, uid);
	SCARG(&bla, gid) = ((linux_gid_t)SCARG(uap, gid) == (linux_gid_t)-1) ?
		(gid_t)-1 : SCARG(uap, gid);

	return sys_lchown(p, &bla, retval);
}

int
linux_sys_rename(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_rename_args /* {
		syscallarg(char *) from;
		syscallarg(char *) to;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p);

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, from));
	LINUX_CHECK_ALT_CREAT(p, &sg, SCARG(uap, to));

	return sys_rename(p, uap, retval);
}

int
linux_sys_mkdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_mkdir_args /* {
		syscallarg(char *) path;
		syscallarg(int) mode;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p);

	LINUX_CHECK_ALT_CREAT(p, &sg, SCARG(uap, path));

	return sys_mkdir(p, uap, retval);
}

int
linux_sys_rmdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_rmdir_args /* {
		syscallarg(char *) path;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p);

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	return sys_rmdir(p, uap, retval);
}

int
linux_sys_symlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_symlink_args /* {
		syscallarg(char *) path;
		syscallarg(char *) to;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p);

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));
	LINUX_CHECK_ALT_CREAT(p, &sg, SCARG(uap, to));

	return sys_symlink(p, uap, retval);
}

int
linux_sys_readlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_readlink_args /* {
		syscallarg(char *) name;
		syscallarg(char *) buf;
		syscallarg(int) count;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p);

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, name));

	return sys_readlink(p, uap, retval);
}

int
linux_sys_ftruncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ftruncate_args /* {
		syscallarg(int)  fd;
		syscallarg(long) length;
	} */ *uap = v;
	struct sys_ftruncate_args sta;

	SCARG(&sta, fd) = SCARG(uap, fd);
	SCARG(&sta, length) = SCARG(uap, length);

	return sys_ftruncate(p, uap, retval);
}

int
linux_sys_truncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_truncate_args /* {
		syscallarg(char *) path;
		syscallarg(long) length;
	} */ *uap = v;
	caddr_t sg = stackgap_init(p);
	struct sys_truncate_args sta;

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&sta, path) = SCARG(uap, path);
	SCARG(&sta, length) = SCARG(uap, length);

	return sys_truncate(p, &sta, retval);
}

/*
 * This is just fsync() for now (just as it is in the Linux kernel)
 */
int
linux_sys_fdatasync(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_fdatasync_args /* {
		syscallarg(int) fd;
	} */ *uap = v;
	return sys_fsync(p, uap, retval);
}

/*
 * pread(2).
 */
int
linux_sys_pread(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_pread_args /* {
		syscallarg(int) fd;
		syscallarg(void *) buf;
		syscallarg(size_t) nbyte;
		syscallarg(linux_off_t) offset;
	} */ *uap = v;
	struct sys_pread_args pra;
	
	SCARG(&pra, fd) = SCARG(uap, fd);
	SCARG(&pra, buf) = SCARG(uap, buf);
	SCARG(&pra, nbyte) = SCARG(uap, nbyte);
	SCARG(&pra, offset) = SCARG(uap, offset);
	
	return sys_pread(p, &pra, retval);
}

/*
 * pwrite(2).
 */
int
linux_sys_pwrite(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_pwrite_args /* {
		syscallarg(int) fd;
		syscallarg(char *) buf;
		syscallarg(size_t) nbyte;
		syscallarg(linux_off_t) offset;
	} */ *uap = v;
	struct sys_pwrite_args pra;

	SCARG(&pra, fd) = SCARG(uap, fd);
	SCARG(&pra, buf) = SCARG(uap, buf);
	SCARG(&pra, nbyte) = SCARG(uap, nbyte);
	SCARG(&pra, offset) = SCARG(uap, offset);

	return sys_pwrite(p, &pra, retval);
}
@


1.30
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.29 2014/01/23 23:46:42 pirofti Exp $	*/
@


1.29
log
@Try to cope better with void pointer to int usage cases.

Use intptr_t for such cases.
More casts/types should be improved in this file.

Tested with syscall regression tests from IBM.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.28 2013/05/10 10:31:16 pirofti Exp $	*/
d141 1
a141 1
	sg = stackgap_init(p->p_emul);
d172 1
a172 1
	sg = stackgap_init(p->p_emul);
d377 1
a377 1
		sg = stackgap_init(p->p_emul);
d401 1
a401 1
		sg = stackgap_init(p->p_emul);
d517 1
a517 1
	sg = stackgap_init(p->p_emul);
d553 1
a553 1
	sg = stackgap_init(p->p_emul);
d618 1
a618 1
	caddr_t sg = stackgap_init(p->p_emul);
d635 1
a635 1
	caddr_t sg = stackgap_init(p->p_emul);
d651 1
a651 1
	caddr_t sg = stackgap_init(p->p_emul);
d669 1
a669 1
	caddr_t sg = stackgap_init(p->p_emul);
d695 1
a695 1
	caddr_t sg = stackgap_init(p->p_emul);
d710 1
a710 1
	caddr_t sg = stackgap_init(p->p_emul);
d729 1
a729 1
	caddr_t sg = stackgap_init(p->p_emul);
d796 1
a796 1
	caddr_t sg = stackgap_init(p->p_emul);
d814 1
a814 1
	caddr_t sg = stackgap_init(p->p_emul);
d830 1
a830 1
	caddr_t sg = stackgap_init(p->p_emul);
d847 1
a847 1
	caddr_t sg = stackgap_init(p->p_emul);
d866 1
a866 1
	caddr_t sg = stackgap_init(p->p_emul);
d901 1
a901 1
	caddr_t sg = stackgap_init(p->p_emul);
@


1.28
log
@compat_linux: Add support for future time_t and ino_t size enlargements.

Reviewed by guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.27 2012/04/22 05:43:14 guenther Exp $	*/
d51 1
d334 2
a335 1
	int fd, cmd, error, val;
d371 1
a371 1
		val = linux_to_bsd_ioflags((int)SCARG(uap, arg));
@


1.27
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.26 2011/11/25 10:10:05 robert Exp $	*/
d66 1
a66 1
static void bsd_to_linux_stat(struct stat *, struct linux_stat *);
d470 1
a470 1
static void
d475 2
d479 1
a479 1
	lsp->lst_ino     = bsp->st_ino;
d491 2
d528 2
a529 1
	bsd_to_linux_stat(&tmpst, &tmplst);
d566 2
a567 1
	bsd_to_linux_stat(&tmpst, &tmplst);
@


1.26
log
@implement chown(2) in compat_linux which is needed by some antivirus software

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.25 2011/07/07 01:19:39 tedu Exp $	*/
d203 1
a203 1
		FRELE(fp);
d428 1
a428 1
		FRELE(fp);
@


1.25
log
@remove all the old COMPAT_43 syscalls.  The option itself remains for
the other things it enables.  Move a few old wrappers into linux compat
where they are still being used.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.24 2010/07/26 01:56:27 guenther Exp $	*/
d692 15
@


1.24
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.23 2006/09/25 07:12:57 otto Exp $	*/
d208 20
d851 18
d879 1
d883 4
a886 1
	return compat_43_sys_truncate(p, uap, retval);
@


1.23
log
@Use S_IS* macros insted of masking with S_IF* flags. The latter may
have multiple bits set, which lead to surprising results. Spotted by
from Paul Stoeber, more to come. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.22 2003/08/13 04:01:37 tedu Exp $	*/
d193 2
a194 1
        if (!(fl & O_NOCTTY) && SESS_LEADER(p) && !(p->p_flag & P_CONTROLT)) {
d421 2
a422 2
			struct proc *p1 = pfind((long)arg);
			if (p1 == 0)
d424 1
a424 1
			pgid = (long)p1->p_pgrp->pg_id;
d427 1
a427 1
		if (pgrp == NULL || pgrp->pg_session != p->p_session)
@


1.22
log
@remove some copy and waste. from marius@@monkey.org
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.21 2002/03/14 01:26:50 millert Exp $	*/
d648 1
a648 1
	if (SCARG(uap, mode) & S_IFIFO) {
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.20 2002/02/13 19:08:06 art Exp $	*/
a876 3
	caddr_t sg;

	sg = stackgap_init(p->p_emul);
a901 3
	caddr_t sg;

	sg = stackgap_init(p->p_emul);
@


1.20
log
@More FREF/FRELE on relevant places. Now, only sys_mmap and a bunch of ioctl functions in sys/compat are left.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.19 2002/02/02 16:05:58 art Exp $	*/
d62 6
a67 6
static int linux_to_bsd_ioflags __P((int));
static int bsd_to_linux_ioflags __P((int));
static void bsd_to_linux_flock __P((struct flock *, struct linux_flock *));
static void linux_to_bsd_flock __P((struct linux_flock *, struct flock *));
static void bsd_to_linux_stat __P((struct stat *, struct linux_stat *));
static int linux_stat1 __P((struct proc *, void *, register_t *, int));
d323 1
a323 1
	struct tty *tp, *(*d_tty) __P((dev_t));
@


1.19
log
@Be more consistent about using fd_getfile where it matters.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.18 2001/10/26 12:03:27 art Exp $	*/
d199 1
d202 1
d405 4
a408 1
		if ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)))
@


1.18
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.17 2001/07/03 15:32:34 jasoni Exp $	*/
d195 1
a195 1
                struct file     *fp = fdp->fd_ofiles[*retval];
d197 2
a198 1
                /* ignore any error, just give it a try */
@


1.18.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.18 2001/10/26 12:03:27 art Exp $	*/
d62 6
a67 6
static int linux_to_bsd_ioflags(int);
static int bsd_to_linux_ioflags(int);
static void bsd_to_linux_flock(struct flock *, struct linux_flock *);
static void linux_to_bsd_flock(struct linux_flock *, struct flock *);
static void bsd_to_linux_stat(struct stat *, struct linux_stat *);
static int linux_stat1(struct proc *, void *, register_t *, int);
d195 1
a195 1
                struct file     *fp;
d197 1
a197 3
		if ((fp = fd_getfile(fdp, *retval)) == NULL)
			return (EBADF);
		FREF(fp);
a199 1
		FRELE(fp);
d320 1
a320 1
	struct tty *tp, *(*d_tty)(dev_t);
d402 1
a402 4
		FREF(fp);
		error = VOP_GETATTR(vp, &va, p->p_ucred, p);
		FRELE(fp);
		if (error)
@


1.17
log
@rename some syscalls to <syscall>16 to make room for new ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.16 2000/11/10 15:33:09 provos Exp $	*/
d393 2
a394 3
		if ((u_int)fd >= fdp->fd_nfiles ||
		    (fp = fdp->fd_ofiles[fd]) == NULL)
			return EBADF;
@


1.16
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.15 2000/09/07 17:52:23 ericj Exp $	*/
d669 1
a669 1
linux_sys_chown(p, v, retval)
d674 1
a674 1
	struct linux_sys_chown_args /* {
d694 1
a694 1
linux_sys_fchown(p, v, retval)
d699 1
a699 1
	struct linux_sys_fchown_args /* {
d716 1
a716 1
linux_sys_lchown(p, v, retval)
d721 1
a721 1
	struct linux_sys_lchown_args /* {
@


1.15
log
@common/compat_util.c
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.14 2000/07/23 22:24:37 jasoni Exp $	*/
d641 1
a641 1
	 * BSD handles FIFOs seperately
@


1.14
log
@Use our own pread/pwrite.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.13 2000/04/21 15:50:20 millert Exp $	*/
d522 1
a524 1
	st = stackgap_alloc(&sg, sizeof (struct stat));
@


1.13
log
@O_FYNC -> O_SYNC
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.12 2000/04/19 08:34:56 csapuntz Exp $	*/
a67 1
static int linux_set_pos __P((struct proc *, int, off_t));
a856 31
 * sys_lseek trimmed down
 */
static int
linux_set_pos(p, fd, offset)
	struct proc *p;
	int fd;
	off_t offset;
{
	register struct filedesc *fdp = p->p_fd;
	register struct file *fp;
	struct vnode *vp;
	int special;

	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL)
		return (EBADF);
	if (fp->f_type != DTYPE_VNODE)
		return (ESPIPE);
	vp = (struct vnode *)fp->f_data;
	if (vp->v_type == VFIFO)
		return (ESPIPE);
	if (vp->v_type == VCHR)
		special = 1;
	else
		special = 0;
	if (!special && offset < 0)
		return (EINVAL);
	return (0);
}

/*
d871 11
a881 34
	register struct file *fp;
	register struct filedesc *fdp = p->p_fd;
	struct uio auio;
	struct iovec aiov;
	long cnt, error = 0;
	off_t offset;

	/* Don't allow nbyte to be larger than max return val */
	if (SCARG(uap, nbyte) > SSIZE_MAX)
		return(EINVAL);

	offset = SCARG(uap, offset);

	if ((error = linux_set_pos(p, SCARG(uap, fd), offset)) != 0)
		return (error);

	fp = fdp->fd_ofiles[SCARG(uap, fd)];
	aiov.iov_base = (caddr_t)SCARG(uap, buf);
	aiov.iov_len = SCARG(uap, nbyte);
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_resid = SCARG(uap, nbyte);
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;
	cnt = SCARG(uap, nbyte);
	error = (*fp->f_ops->fo_read)(fp, &offset, &auio, fp->f_cred);
	if (error)
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	cnt -= auio.uio_resid;
	*retval = cnt;
	return (error);
d899 11
a909 39
	register struct file *fp;
	register struct filedesc *fdp = p->p_fd;
	struct uio auio;
	struct iovec aiov;
	long cnt, error = 0;
	off_t offset;

	/* Don't allow nbyte to be larger than max return val */
	if (SCARG(uap, nbyte) > SSIZE_MAX)
		return(EINVAL);

	offset = SCARG(uap, offset);

	if ((error = linux_set_pos(p, SCARG(uap, fd), offset)) != 0)
		return (error);
	fp = fdp->fd_ofiles[SCARG(uap, fd)];
	if ((fp->f_flag & FWRITE) == 0)
		return (EBADF);
	
	aiov.iov_base = (caddr_t)SCARG(uap, buf);
	aiov.iov_len = SCARG(uap, nbyte);
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_resid = SCARG(uap, nbyte);
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;
	cnt = SCARG(uap, nbyte);
	error = (*fp->f_ops->fo_write)(fp, &offset, &auio, fp->f_cred);
	if (error) {
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
			psignal(p, SIGPIPE);
	}
	cnt -= auio.uio_resid;
	*retval = cnt;
	return (error);
@


1.12
log
@

Change struct file interface methods read and write to pass file offset in
and out.

Make pread/pwrite in netbsd & linux thread safe - which is the whole point
anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.11 2000/04/04 05:31:50 jasoni Exp $	*/
d94 1
a94 1
	res |= cvtto_bsd_mask(lflags, LINUX_O_SYNC, O_FSYNC);
d115 1
a115 1
	res |= cvtto_linux_mask(bflags, O_FSYNC, LINUX_O_SYNC);
@


1.11
log
@Implement Linux's pread(2) and pwrite(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.10 2000/02/28 13:29:29 jasoni Exp $	*/
d68 1
a68 1
static int linux_set_pos __P((struct proc *, int, off_t, off_t *));
d861 1
a861 1
linux_set_pos(p, fd, offset, ooffset)
a864 1
	off_t *ooffset;
a884 2
	*ooffset = fp->f_offset;
	fp->f_offset = offset;
d908 1
a908 1
	off_t save_offset;
d913 4
a916 2
	if ((error = linux_set_pos(p, SCARG(uap, fd), SCARG(uap, offset),
		&save_offset)))
d918 1
d929 1
a929 1
	error = (*fp->f_ops->fo_read)(fp, &auio, fp->f_cred);
a934 1
	fp->f_offset = save_offset;
d959 1
a959 1
	off_t save_offset;
d964 4
a967 2
	if ((error = linux_set_pos(p, SCARG(uap, fd), SCARG(uap, offset),
		&save_offset)))
d970 1
a970 2
	if ((fp->f_flag & FWRITE) == 0) {
		fp->f_offset = save_offset;
d972 1
a972 1
	}
d982 1
a982 1
	error = (*fp->f_ops->fo_write)(fp, &auio, fp->f_cred);
a991 1
	fp->f_offset = save_offset;
@


1.10
log
@Add missing system calls as unimplemented.
Implement chown, poll, setresuid, getresuid, setresgid, getresgid.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.9 1997/11/13 06:37:48 deraadt Exp $	*/
d45 2
d68 2
d77 1
a77 1
 * The next two functions convert between the Linux and NetBSD values
d153 1
a153 1
 * NetBSD syscall do the real work. See if this operation
d243 1
a243 1
 * structure back and forth between Linux and NetBSD format.
d295 1
a295 1
 * pass control to the NetBSD system call. A few commands need
d438 1
a438 1
 * Convert a NetBSD stat structure to a Linux stat structure.
d855 139
@


1.9
log
@put mremap() in linux_misc.c
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.8 1997/09/05 04:35:14 deraadt Exp $	*/
d710 22
@


1.9.10.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a709 22
}

int
linux_sys_lchown(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_lchown_args /* {
		syscallarg(char *) path;
		syscallarg(int) uid;
		syscallarg(int) gid;
	} */ *uap = v;
	struct sys_lchown_args bla;

	SCARG(&bla, path) = SCARG(uap, path);
	SCARG(&bla, uid) = ((linux_uid_t)SCARG(uap, uid) == (linux_uid_t)-1) ?
		(uid_t)-1 : SCARG(uap, uid);
	SCARG(&bla, gid) = ((linux_gid_t)SCARG(uap, gid) == (linux_gid_t)-1) ?
		(gid_t)-1 : SCARG(uap, gid);

	return sys_lchown(p, &bla, retval);
@


1.9.10.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.16 2000/11/10 15:33:09 provos Exp $	*/
a44 2
#include <sys/signalvar.h>
#include <sys/uio.h>
a66 1

d73 1
a73 1
 * The next two functions convert between the Linux and OpenBSD values
d90 1
a90 1
	res |= cvtto_bsd_mask(lflags, LINUX_O_SYNC, O_SYNC);
d111 1
a111 1
	res |= cvtto_linux_mask(bflags, O_SYNC, LINUX_O_SYNC);
d149 1
a149 1
 * OpenBSD syscall do the real work. See if this operation
d239 1
a239 1
 * structure back and forth between Linux and OpenBSD format.
d291 1
a291 1
 * pass control to the OpenBSD system call. A few commands need
d434 1
a434 1
 * Convert a OpenBSD stat structure to a Linux stat structure.
a518 1
	st = stackgap_alloc(&sg, sizeof (struct stat));
d521 1
d638 1
a638 1
	 * BSD handles FIFOs separately
a850 56
}

/*
 * pread(2).
 */
int
linux_sys_pread(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_pread_args /* {
		syscallarg(int) fd;
		syscallarg(void *) buf;
		syscallarg(size_t) nbyte;
		syscallarg(linux_off_t) offset;
	} */ *uap = v;
	struct sys_pread_args pra;
	caddr_t sg;

	sg = stackgap_init(p->p_emul);
	
	SCARG(&pra, fd) = SCARG(uap, fd);
	SCARG(&pra, buf) = SCARG(uap, buf);
	SCARG(&pra, nbyte) = SCARG(uap, nbyte);
	SCARG(&pra, offset) = SCARG(uap, offset);
	
	return sys_pread(p, &pra, retval);
}

/*
 * pwrite(2).
 */
int
linux_sys_pwrite(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_pwrite_args /* {
		syscallarg(int) fd;
		syscallarg(char *) buf;
		syscallarg(size_t) nbyte;
		syscallarg(linux_off_t) offset;
	} */ *uap = v;
	struct sys_pwrite_args pra;
	caddr_t sg;

	sg = stackgap_init(p->p_emul);

	SCARG(&pra, fd) = SCARG(uap, fd);
	SCARG(&pra, buf) = SCARG(uap, buf);
	SCARG(&pra, nbyte) = SCARG(uap, nbyte);
	SCARG(&pra, offset) = SCARG(uap, offset);

	return sys_pwrite(p, &pra, retval);
@


1.9.10.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.9.10.2 2001/05/14 22:04:39 niklas Exp $	*/
d393 3
a395 2
		if ((fp = fd_getfile(fdp, fd)) == NULL)
			return (EBADF);
d669 1
a669 1
linux_sys_chown16(p, v, retval)
d674 1
a674 1
	struct linux_sys_chown16_args /* {
d694 1
a694 1
linux_sys_fchown16(p, v, retval)
d699 1
a699 1
	struct linux_sys_fchown16_args /* {
d716 1
a716 1
linux_sys_lchown16(p, v, retval)
d721 1
a721 1
	struct linux_sys_lchown16_args /* {
@


1.9.10.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d195 1
a195 1
                struct file     *fp;
d197 1
a197 3
		if ((fp = fd_getfile(fdp, *retval)) == NULL)
			return (EBADF);
		FREF(fp);
a199 1
		FRELE(fp);
d402 1
a402 4
		FREF(fp);
		error = VOP_GETATTR(vp, &va, p->p_ucred, p);
		FRELE(fp);
		if (error)
@


1.9.10.5
log
@Merge in -current from about a week ago
@
text
@d62 6
a67 6
static int linux_to_bsd_ioflags(int);
static int bsd_to_linux_ioflags(int);
static void bsd_to_linux_flock(struct flock *, struct linux_flock *);
static void linux_to_bsd_flock(struct linux_flock *, struct flock *);
static void bsd_to_linux_stat(struct stat *, struct linux_stat *);
static int linux_stat1(struct proc *, void *, register_t *, int);
d323 1
a323 1
	struct tty *tp, *(*d_tty)(dev_t);
@


1.9.10.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d877 3
d905 3
@


1.8
log
@fix F_GETLK; tron@@lyssa.owl.de
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.7 1997/07/27 21:01:36 deraadt Exp $	*/
a828 20
}

/*
 * mremap() dummy
*/
int
linux_sys_mremap(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#ifdef notdef
	struct linux_sys_mremap_args /* {
		syscallarg(void *) old_address;
		syscallarg(size_t) old_size;
		syscallarg(size_t) new_size;
		syscallarg(unsigned long) flags;
	} */ *uap = v;
#endif
	return ENOMEM;
@


1.7
log
@mremap non-emulation; tron@@lyssa.owl.de
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.6 1997/01/27 00:50:30 downsj Exp $	*/
d349 3
d356 2
d363 2
a364 1
		return copyout(&lfl, arg, sizeof lfl);
@


1.6
log
@Nevermind, I looked at it wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.5 1997/01/27 00:33:04 downsj Exp $	*/
d823 20
@


1.5
log
@As of 2.1.14, Linux chown() doesn't follow symlinks either.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.4 1996/10/16 12:25:08 deraadt Exp $	*/
d681 1
a681 1
	return sys_lchown(p, &bca, retval);
@


1.4
log
@use variable
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_file.c,v 1.3 1996/05/22 12:01:48 deraadt Exp $	*/
d681 1
a681 1
	return sys_chown(p, &bca, retval);
@


1.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d822 1
a822 1
	return sys_fsync(p, v, retval);
@


1.2
log
@Good fixes and changes from latest Net.
@
text
@d2 1
a2 1
/*	$NetBSD: linux_file.c,v 1.14 1996/04/05 00:01:21 christos Exp $	*/
d808 15
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: linux_file.c,v 1.13 1995/10/08 22:53:43 fvdl Exp $	*/
d58 9
d77 2
a78 1
linux_to_bsd_ioflags(int lflags)
d98 2
a99 1
bsd_to_linux_ioflags(int bflags)
d498 1
a498 1
linux_stat1(p, uap, retval, dolstat)
d500 1
a500 1
	struct linux_sys_stat_args *uap;
d509 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
