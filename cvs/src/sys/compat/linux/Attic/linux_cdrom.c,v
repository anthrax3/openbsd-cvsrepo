head	1.13;
access;
symbols
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.6
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.4
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.2
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.42
	OPENBSD_5_0:1.8.0.40
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.38
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.36
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.32
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.34
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.30
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.28
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.26
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.24
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.22
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.20
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.18
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.16
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.14
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.12
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.10
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.10
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.8
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.13
date	2016.03.02.15.41.47;	author naddy;	state dead;
branches;
next	1.12;
commitid	ZfNt0OHZhMg52abA;

1.12
date	2015.04.30.09.20.51;	author mpi;	state Exp;
branches;
next	1.11;
commitid	ngMdImGL4WWFm6gy;

1.11
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2014.01.21.01.49.13;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.50;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.13.20.43.42;	author jasoni;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.26.12.03.27;	author art;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.05.24.06.00.08;	author jasoni;	state Exp;
branches;
next	1.4;

1.4
date	98.01.23.11.30.06;	author provos;	state Exp;
branches
	1.4.10.1;
next	1.3;

1.3
date	97.12.20.22.51.53;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	97.12.10.00.01.39;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	97.12.07.22.59.14;	author provos;	state Exp;
branches;
next	;

1.4.10.1
date	2001.07.04.10.39.22;	author niklas;	state Exp;
branches;
next	1.4.10.2;

1.4.10.2
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.4.10.3;

1.4.10.3
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.4.10.4;

1.4.10.4
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@remove the Linux emulation code, no longer referenced by anything
@
text
@
/*	$OpenBSD: linux_cdrom.c,v 1.12 2015/04/30 09:20:51 mpi Exp $	*/
/*
 * Copyright 1997 Niels Provos <provos@@physnet.uni-hamburg.de>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/cdio.h>

#include <sys/syscallargs.h>

#include <compat/linux/linux_types.h>
#include <compat/linux/linux_ioctl.h>
#include <compat/linux/linux_signal.h>
#include <compat/linux/linux_syscallargs.h>
#include <compat/linux/linux_util.h>
#include <compat/linux/linux_cdrom.h>

void bsd_addr_to_linux_addr(union msf_lba *bsd,
    union linux_cdrom_addr *linux, int format);

void 
bsd_addr_to_linux_addr(bsd, linux, format)
        union msf_lba *bsd;
        union linux_cdrom_addr *linux;
        int format;
{
        if (format == CD_MSF_FORMAT) {
 	        linux->msf.minute = bsd->msf.minute;
		linux->msf.second = bsd->msf.second;
		linux->msf.frame = bsd->msf.frame;
	} else 
	        linux->lba = bsd->lba;
}

int
linux_ioctl_cdrom(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ioctl_args /* {
		syscallarg(int) fd;
		syscallarg(u_long) com;
		syscallarg(caddr_t) data;
	} */ *uap = v;
	struct file *fp;
	struct filedesc *fdp;
	caddr_t sg;
	u_long com, arg;
	struct sys_ioctl_args ia;
	int error;

	union {
	        struct cd_toc_entry te;
	        struct cd_sub_channel_info scinfo;
	} data;
	union {
	        struct ioc_toc_header th;
	        struct ioc_read_toc_entry tes;
	        struct ioc_play_track ti;
		struct ioc_play_msf msf;
		struct ioc_play_blocks blk;
	        struct ioc_read_subchannel sc;
		struct ioc_vol vol;
	} tmpb;
	union {
	        struct linux_cdrom_tochdr th;
	        struct linux_cdrom_tocentry te;
	        struct linux_cdrom_ti ti;
		struct linux_cdrom_msf msf;
		struct linux_cdrom_blk blk;
	        struct linux_cdrom_subchnl sc;
		struct linux_cdrom_volctrl vol;
	} tmpl;


	fdp = p->p_fd;
	if ((fp = fd_getfile_mode(fdp, SCARG(uap, fd), FREAD|FWRITE)) == NULL)
		return (EBADF);
	FREF(fp);

	com = SCARG(uap, com);
	retval[0] = 0;
                
	switch (com) {
	case LINUX_CDROMREADTOCHDR:
	        error = (*fp->f_ops->fo_ioctl)(fp, CDIOREADTOCHEADER,
		    (caddr_t)&tmpb.th, p);
	        if (error)
			goto out;
		tmpl.th.cdth_trk0 = tmpb.th.starting_track;
		tmpl.th.cdth_trk1 = tmpb.th.ending_track;
		error = copyout(&tmpl, SCARG(uap, data), sizeof tmpl.th);
		goto out;
	case LINUX_CDROMREADTOCENTRY:
		error = copyin(SCARG(uap, data), &tmpl.te, sizeof tmpl.te);
		if (error)
		        goto out;

		sg = stackgap_init(p);
		
		memset(&tmpb.tes, 0, sizeof tmpb.tes);
		tmpb.tes.starting_track = tmpl.te.cdte_track;
		tmpb.tes.address_format = (tmpl.te.cdte_format == LINUX_CDROM_MSF)
		    ? CD_MSF_FORMAT : CD_LBA_FORMAT;
		tmpb.tes.data_len = sizeof(struct cd_toc_entry);
		tmpb.tes.data = stackgap_alloc(&sg, tmpb.tes.data_len);

	        error = (*fp->f_ops->fo_ioctl)(fp, CDIOREADTOCENTRYS,
		    (caddr_t)&tmpb.tes, p);
	        if (error) 
			goto out;
		if ((error = copyin(tmpb.tes.data, &data.te, sizeof data.te)))
			goto out;
		
		tmpl.te.cdte_ctrl = data.te.control;
		tmpl.te.cdte_adr = data.te.addr_type;
		tmpl.te.cdte_track = data.te.track;
		tmpl.te.cdte_datamode = CD_TRACK_INFO;
		bsd_addr_to_linux_addr(&data.te.addr, &tmpl.te.cdte_addr, 
		    tmpb.tes.address_format);
		error = copyout(&tmpl, SCARG(uap, data), sizeof tmpl.te);
		goto out;
	case LINUX_CDROMSUBCHNL:
		error = copyin(SCARG(uap, data), &tmpl.sc, sizeof tmpl.sc);
		if (error)
			goto out;

		sg = stackgap_init(p);
		
		memset(&tmpb.sc, 0, sizeof tmpb.sc);
		tmpb.sc.data_format = CD_CURRENT_POSITION;
		tmpb.sc.address_format = (tmpl.sc.cdsc_format == LINUX_CDROM_MSF)
		    ? CD_MSF_FORMAT : CD_LBA_FORMAT;
		tmpb.sc.data_len = sizeof(struct cd_sub_channel_info);
		tmpb.sc.data = stackgap_alloc(&sg, tmpb.sc.data_len);

	        error = (*fp->f_ops->fo_ioctl)(fp, CDIOCREADSUBCHANNEL,
		    (caddr_t)&tmpb.sc, p);
	        if (error)
			goto out;
		if ((error = copyin(tmpb.sc.data, &data.scinfo, sizeof data.scinfo)))
			goto out;
		
		tmpl.sc.cdsc_audiostatus = data.scinfo.header.audio_status;
		tmpl.sc.cdsc_adr = data.scinfo.what.position.addr_type;
		tmpl.sc.cdsc_ctrl = data.scinfo.what.position.control;
		tmpl.sc.cdsc_trk = data.scinfo.what.position.track_number;
		tmpl.sc.cdsc_ind = data.scinfo.what.position.index_number;
		bsd_addr_to_linux_addr(&data.scinfo.what.position.absaddr, 
		    &tmpl.sc.cdsc_absaddr, 
		    tmpb.sc.address_format);
		bsd_addr_to_linux_addr(&data.scinfo.what.position.reladdr, 
		    &tmpl.sc.cdsc_reladdr, 
		    tmpb.sc.address_format);

		error = copyout(&tmpl, SCARG(uap, data), sizeof tmpl.sc);
		goto out;
	case LINUX_CDROMPLAYTRKIND:
		error = copyin(SCARG(uap, data), &tmpl.ti, sizeof tmpl.ti);
		if (error)
			goto out;

		tmpb.ti.start_track = tmpl.ti.cdti_trk0;
		tmpb.ti.start_index = tmpl.ti.cdti_ind0;
		tmpb.ti.end_track = tmpl.ti.cdti_trk1;
		tmpb.ti.end_index = tmpl.ti.cdti_ind1;
	        error = (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYTRACKS,
		    (caddr_t)&tmpb.ti, p);
		goto out;
	case LINUX_CDROMPLAYMSF:
		error = copyin(SCARG(uap, data), &tmpl.msf, sizeof tmpl.msf);
		if (error)
			goto out;

		tmpb.msf.start_m = tmpl.msf.cdmsf_min0;
		tmpb.msf.start_s = tmpl.msf.cdmsf_sec0;
		tmpb.msf.start_f = tmpl.msf.cdmsf_frame0;
		tmpb.msf.end_m = tmpl.msf.cdmsf_min1;
		tmpb.msf.end_s = tmpl.msf.cdmsf_sec1;
		tmpb.msf.end_f = tmpl.msf.cdmsf_frame1;

		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYMSF,
		    (caddr_t)&tmpb.msf, p);
		goto out;
	case LINUX_CDROMPLAYBLK:
		error = copyin(SCARG(uap, data), &tmpl.blk, sizeof tmpl.blk);
		if (error)
			goto out;

		tmpb.blk.blk = tmpl.blk.from;
		tmpb.blk.len = tmpl.blk.len;

		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYBLOCKS,
		    (caddr_t)&tmpb.blk, p);
		goto out;
	case LINUX_CDROMVOLCTRL:
		error = copyin(SCARG(uap, data), &tmpl.vol, sizeof tmpl.vol);
		if (error)
			goto out;

		tmpb.vol.vol[0] = tmpl.vol.channel0;
		tmpb.vol.vol[1] = tmpl.vol.channel1;
		tmpb.vol.vol[2] = tmpl.vol.channel2;
		tmpb.vol.vol[3] = tmpl.vol.channel3;

		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCSETVOL,
		    (caddr_t)&tmpb.vol, p);
		goto out;
	case LINUX_CDROMVOLREAD:
		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCGETVOL,
		    (caddr_t)&tmpb.vol, p);
		if (error)
			goto out;

		tmpl.vol.channel0 = tmpb.vol.vol[0];
		tmpl.vol.channel1 = tmpb.vol.vol[1];
		tmpl.vol.channel2 = tmpb.vol.vol[2];
		tmpl.vol.channel3 = tmpb.vol.vol[3];

		error = copyout(&tmpl.vol, SCARG(uap, data), sizeof tmpl.vol);
		goto out;
	case LINUX_CDROMPAUSE:
		SCARG(&ia, com) = CDIOCPAUSE;
		break;
	case LINUX_CDROMRESUME:
		SCARG(&ia, com) = CDIOCRESUME;
		break;
	case LINUX_CDROMSTOP:
		SCARG(&ia, com) = CDIOCSTOP;
		break;
	case LINUX_CDROMSTART:
		SCARG(&ia, com) = CDIOCSTART;
		break;
	case LINUX_CDROMEJECT_SW:
		error = copyin(SCARG(uap, data), &arg, sizeof arg);
		if (error)
			goto out;
		SCARG(&ia, com) = arg ? CDIOCALLOW : CDIOCPREVENT;
		break;
	case LINUX_CDROMEJECT:
		SCARG(&ia, com) = CDIOCEJECT;
		break;
	case LINUX_CDROMRESET:
		SCARG(&ia, com) = CDIOCRESET;
		break;
	default:
	        printf("linux_ioctl_cdrom: invalid ioctl %08lx\n", com);
		error = EINVAL;
		goto out;
	}

	SCARG(&ia, fd) = SCARG(uap, fd);
	SCARG(&ia, data) = SCARG(uap, data);
	error = sys_ioctl(p, &ia, retval);

out:
	FRELE(fp, p);
	return (error);
}
@


1.12
log
@Indroduce fd_getfile_mode() and use it were fd_getfile() is directly
followed by a mode check.  This will simplify the ref/unref dance as
soon as fd_getfile() will increment fp's reference counter.

Idea from and ok guenther@@, ok millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.11 2014/03/26 05:23:42 guenther Exp $	*/
@


1.11
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d2 1
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.10 2014/01/21 01:49:13 tedu Exp $	*/
d111 1
a111 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
a113 5

	if ((fp->f_flag & (FREAD | FWRITE)) == 0) {
		error = EBADF;
		goto out;
	}
@


1.10
log
@bzero -> memset
@
text
@d2 1
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.9 2012/04/22 05:43:14 guenther Exp $	*/
d138 1
a138 1
		sg = stackgap_init(p->p_emul);
d167 1
a167 1
		sg = stackgap_init(p->p_emul);
@


1.9
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.8 2002/03/14 01:26:50 millert Exp $	*/
d140 1
a140 1
		bzero(&tmpb.tes, sizeof tmpb.tes);
d169 1
a169 1
		bzero(&tmpb.sc, sizeof tmpb.sc);
@


1.8
log
@First round of __P removal in sys
@
text
@d2 1
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.7 2002/02/13 20:43:42 jasoni Exp $	*/
d296 1
a296 1
	FRELE(fp);
@


1.7
log
@FREF/FRELE where required due to fd_getfile.
- ok art@@
@
text
@d2 1
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.6 2001/10/26 12:03:27 art Exp $	*/
d51 2
a52 2
void bsd_addr_to_linux_addr __P((union msf_lba *bsd,
    union linux_cdrom_addr *linux, int format));
@


1.6
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d2 1
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.5 2001/05/24 06:00:08 jasoni Exp $	*/
d70 1
a70 1
	register struct proc *p;
d74 1
a74 1
	register struct linux_sys_ioctl_args /* {
d79 2
a80 2
	register struct file *fp;
	register struct filedesc *fdp;
d113 1
d115 4
a118 2
	if ((fp->f_flag & (FREAD | FWRITE)) == 0)
		return (EBADF);
d128 1
a128 1
		        return error;
d131 2
a132 1
		return copyout(&tmpl, SCARG(uap, data), sizeof tmpl.th);
d136 1
a136 1
		        return error;
d150 1
a150 1
		        return error;
d152 1
a152 1
		        return error;
d160 2
a161 1
		return copyout(&tmpl, SCARG(uap, data), sizeof tmpl.te);
d165 1
a165 1
		        return error;
d179 1
a179 1
		        return error;
d181 1
a181 1
		        return error;
d195 2
a196 1
		return copyout(&tmpl, SCARG(uap, data), sizeof tmpl.sc);
d200 1
a200 1
		        return error;
d206 3
a208 2
	        return (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYTRACKS,
					      (caddr_t)&tmpb.ti, p);
d212 1
a212 1
		        return error;
d221 3
a223 1
		return (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYMSF, (caddr_t)&tmpb.msf, p);
d227 1
a227 1
		        return error;
d232 3
a234 1
		return (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYBLOCKS, (caddr_t)&tmpb.blk, p);
d238 1
a238 1
		        return error;
d245 3
a247 1
		return (*fp->f_ops->fo_ioctl)(fp, CDIOCSETVOL, (caddr_t)&tmpb.vol, p);
d249 2
a250 1
		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCGETVOL, (caddr_t)&tmpb.vol, p);
d252 1
a252 1
			return error;
d259 2
a260 1
		return copyout(&tmpl.vol, SCARG(uap, data), sizeof tmpl.vol);
d276 1
a276 1
		        return error;
d287 2
a288 1
		return EINVAL;
d293 5
a297 1
	return sys_ioctl(p, &ia, retval);
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d2 1
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.6 2001/10/26 12:03:27 art Exp $	*/
d51 2
a52 2
void bsd_addr_to_linux_addr(union msf_lba *bsd,
    union linux_cdrom_addr *linux, int format);
d70 1
a70 1
	struct proc *p;
d74 1
a74 1
	struct linux_sys_ioctl_args /* {
d79 2
a80 2
	struct file *fp;
	struct filedesc *fdp;
a112 1
	FREF(fp);
d114 2
a115 4
	if ((fp->f_flag & (FREAD | FWRITE)) == 0) {
		error = EBADF;
		goto out;
	}
d125 1
a125 1
			goto out;
d128 1
a128 2
		error = copyout(&tmpl, SCARG(uap, data), sizeof tmpl.th);
		goto out;
d132 1
a132 1
		        goto out;
d146 1
a146 1
			goto out;
d148 1
a148 1
			goto out;
d156 1
a156 2
		error = copyout(&tmpl, SCARG(uap, data), sizeof tmpl.te);
		goto out;
d160 1
a160 1
			goto out;
d174 1
a174 1
			goto out;
d176 1
a176 1
			goto out;
d190 1
a190 2
		error = copyout(&tmpl, SCARG(uap, data), sizeof tmpl.sc);
		goto out;
d194 1
a194 1
			goto out;
d200 2
a201 3
	        error = (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYTRACKS,
		    (caddr_t)&tmpb.ti, p);
		goto out;
d205 1
a205 1
			goto out;
d214 1
a214 3
		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYMSF,
		    (caddr_t)&tmpb.msf, p);
		goto out;
d218 1
a218 1
			goto out;
d223 1
a223 3
		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYBLOCKS,
		    (caddr_t)&tmpb.blk, p);
		goto out;
d227 1
a227 1
			goto out;
d234 1
a234 3
		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCSETVOL,
		    (caddr_t)&tmpb.vol, p);
		goto out;
d236 1
a236 2
		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCGETVOL,
		    (caddr_t)&tmpb.vol, p);
d238 1
a238 1
			goto out;
d245 1
a245 2
		error = copyout(&tmpl.vol, SCARG(uap, data), sizeof tmpl.vol);
		goto out;
d261 1
a261 1
			goto out;
d272 1
a272 2
		error = EINVAL;
		goto out;
d277 1
a277 5
	error = sys_ioctl(p, &ia, retval);

out:
	FRELE(fp);
	return (error);
@


1.5
log
@style/cleanup (of function headers)
@
text
@d2 1
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.4 1998/01/23 11:30:06 provos Exp $	*/
d111 1
a111 2
	if ((u_int)SCARG(uap, fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
@


1.4
log
@additional ioctls, makes workman and workbone working.
@
text
@d2 1
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.3 1997/12/20 22:51:53 deraadt Exp $	*/
d69 1
a69 1
linux_ioctl_cdrom(p, uap, retval)
d71 3
d78 1
a78 3
	} */ *uap;
	register_t *retval;
{
@


1.4.10.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d2 1
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.4 1998/01/23 11:30:06 provos Exp $	*/
d69 1
a69 1
linux_ioctl_cdrom(p, v, retval)
a70 3
	void *v;
	register_t *retval;
{
d75 3
a77 1
	} */ *uap = v;
@


1.4.10.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d2 1
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.4.10.1 2001/07/04 10:39:22 niklas Exp $	*/
d111 2
a112 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
@


1.4.10.3
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d70 1
a70 1
	struct proc *p;
d74 1
a74 1
	struct linux_sys_ioctl_args /* {
d79 2
a80 2
	struct file *fp;
	struct filedesc *fdp;
a112 1
	FREF(fp);
d114 2
a115 4
	if ((fp->f_flag & (FREAD | FWRITE)) == 0) {
		error = EBADF;
		goto out;
	}
d125 1
a125 1
			goto out;
d128 1
a128 2
		error = copyout(&tmpl, SCARG(uap, data), sizeof tmpl.th);
		goto out;
d132 1
a132 1
		        goto out;
d146 1
a146 1
			goto out;
d148 1
a148 1
			goto out;
d156 1
a156 2
		error = copyout(&tmpl, SCARG(uap, data), sizeof tmpl.te);
		goto out;
d160 1
a160 1
			goto out;
d174 1
a174 1
			goto out;
d176 1
a176 1
			goto out;
d190 1
a190 2
		error = copyout(&tmpl, SCARG(uap, data), sizeof tmpl.sc);
		goto out;
d194 1
a194 1
			goto out;
d200 2
a201 3
	        error = (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYTRACKS,
		    (caddr_t)&tmpb.ti, p);
		goto out;
d205 1
a205 1
			goto out;
d214 1
a214 3
		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYMSF,
		    (caddr_t)&tmpb.msf, p);
		goto out;
d218 1
a218 1
			goto out;
d223 1
a223 3
		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYBLOCKS,
		    (caddr_t)&tmpb.blk, p);
		goto out;
d227 1
a227 1
			goto out;
d234 1
a234 3
		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCSETVOL,
		    (caddr_t)&tmpb.vol, p);
		goto out;
d236 1
a236 2
		error = (*fp->f_ops->fo_ioctl)(fp, CDIOCGETVOL,
		    (caddr_t)&tmpb.vol, p);
d238 1
a238 1
			goto out;
d245 1
a245 2
		error = copyout(&tmpl.vol, SCARG(uap, data), sizeof tmpl.vol);
		goto out;
d261 1
a261 1
			goto out;
d272 1
a272 2
		error = EINVAL;
		goto out;
d277 1
a277 5
	error = sys_ioctl(p, &ia, retval);

out:
	FRELE(fp);
	return (error);
@


1.4.10.4
log
@Merge in -current from about a week ago
@
text
@d51 2
a52 2
void bsd_addr_to_linux_addr(union msf_lba *bsd,
    union linux_cdrom_addr *linux, int format);
@


1.3
log
@indent
@
text
@d1 2
a2 1
/*	$OpenBSD: linux_cdrom.c,v 1.2 1997/12/10 00:01:39 provos Exp $	*/
d81 1
a81 1
	u_long com;
d93 2
d96 1
d102 2
d105 1
d128 1
a128 4
		error = copyout(&tmpl, SCARG(uap, data), sizeof tmpl.th);
		if (error)
			return error;
		return 0;
d156 1
a156 4
		error = copyout(&tmpl, SCARG(uap, data), sizeof tmpl.te);
		if (error)
			return error;
		return 0;
d190 1
a190 4
		error = copyout(&tmpl, SCARG(uap, data), sizeof tmpl.sc);
		if (error)
			return error;
		return 0;
d200 27
a226 3
	        error = (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYTRACKS,
		    (caddr_t)&tmpb.ti, p);
	        if (error)
d228 18
a245 1
		return 0;
d258 6
d266 3
@


1.2
log
@insert forgotten copyright + handle eject ioctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_cdrom.c,v 1.1 1997/12/07 22:59:14 provos Exp $	*/
d50 2
a51 1
void bsd_addr_to_linux_addr __P((union msf_lba *bsd, union linux_cdrom_addr *linux, int format));
d115 2
a116 1
	        error = (*fp->f_ops->fo_ioctl)(fp, CDIOREADTOCHEADER, (caddr_t)&tmpb.th, p);
d134 2
a135 1
		tmpb.tes.address_format = tmpl.te.cdte_format == LINUX_CDROM_MSF ? CD_MSF_FORMAT : CD_LBA_FORMAT;
d139 2
a140 1
	        error = (*fp->f_ops->fo_ioctl)(fp, CDIOREADTOCENTRYS, (caddr_t)&tmpb.tes, p);
d151 1
a151 1
				       tmpb.tes.address_format);
d165 2
a166 1
		tmpb.sc.address_format = tmpl.sc.cdsc_format == LINUX_CDROM_MSF ? CD_MSF_FORMAT : CD_LBA_FORMAT;
d170 2
a171 1
	        error = (*fp->f_ops->fo_ioctl)(fp, CDIOCREADSUBCHANNEL, (caddr_t)&tmpb.sc, p);
d183 2
a184 2
				       &tmpl.sc.cdsc_absaddr, 
				       tmpb.sc.address_format);
d186 2
a187 2
				       &tmpl.sc.cdsc_reladdr, 
				       tmpb.sc.address_format);
d202 2
a203 1
	        error = (*fp->f_ops->fo_ioctl)(fp, CDIOCPLAYTRACKS, (caddr_t)&tmpb.ti, p);
@


1.1
log
@handle linux cdrom ioctls. not that i play quake that often but it was
the only binary around.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d211 3
@
