head	1.96;
access;
symbols
	OPENBSD_5_9:1.95.0.2
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.94.0.4
	OPENBSD_5_8_BASE:1.94
	OPENBSD_5_7:1.92.0.2
	OPENBSD_5_7_BASE:1.92
	OPENBSD_5_6:1.90.0.4
	OPENBSD_5_6_BASE:1.90
	OPENBSD_5_5:1.86.0.4
	OPENBSD_5_5_BASE:1.86
	OPENBSD_5_4:1.80.0.2
	OPENBSD_5_4_BASE:1.80
	OPENBSD_5_3:1.79.0.4
	OPENBSD_5_3_BASE:1.79
	OPENBSD_5_2:1.79.0.2
	OPENBSD_5_2_BASE:1.79
	OPENBSD_5_1_BASE:1.73
	OPENBSD_5_1:1.73.0.2
	OPENBSD_5_0:1.72.0.2
	OPENBSD_5_0_BASE:1.72
	OPENBSD_4_9:1.66.0.2
	OPENBSD_4_9_BASE:1.66
	OPENBSD_4_8:1.65.0.2
	OPENBSD_4_8_BASE:1.65
	OPENBSD_4_7:1.63.0.2
	OPENBSD_4_7_BASE:1.63
	OPENBSD_4_6:1.62.0.8
	OPENBSD_4_6_BASE:1.62
	OPENBSD_4_5:1.62.0.4
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.62.0.2
	OPENBSD_4_4_BASE:1.62
	OPENBSD_4_3:1.61.0.2
	OPENBSD_4_3_BASE:1.61
	OPENBSD_4_2:1.60.0.4
	OPENBSD_4_2_BASE:1.60
	OPENBSD_4_1:1.60.0.2
	OPENBSD_4_1_BASE:1.60
	OPENBSD_4_0:1.58.0.8
	OPENBSD_4_0_BASE:1.58
	OPENBSD_3_9:1.58.0.6
	OPENBSD_3_9_BASE:1.58
	OPENBSD_3_8:1.58.0.4
	OPENBSD_3_8_BASE:1.58
	OPENBSD_3_7:1.58.0.2
	OPENBSD_3_7_BASE:1.58
	OPENBSD_3_6:1.57.0.2
	OPENBSD_3_6_BASE:1.57
	SMP_SYNC_A:1.55
	SMP_SYNC_B:1.55
	OPENBSD_3_5:1.55.0.2
	OPENBSD_3_5_BASE:1.55
	OPENBSD_3_4:1.54.0.2
	OPENBSD_3_4_BASE:1.54
	UBC_SYNC_A:1.48
	OPENBSD_3_3:1.48.0.2
	OPENBSD_3_3_BASE:1.48
	OPENBSD_3_2:1.45.0.2
	OPENBSD_3_2_BASE:1.45
	OPENBSD_3_1:1.42.0.2
	OPENBSD_3_1_BASE:1.42
	UBC_SYNC_B:1.46
	UBC:1.39.0.2
	UBC_BASE:1.39
	OPENBSD_3_0:1.38.0.2
	OPENBSD_3_0_BASE:1.38
	OPENBSD_2_9_BASE:1.35
	OPENBSD_2_9:1.35.0.2
	OPENBSD_2_8:1.33.0.2
	OPENBSD_2_8_BASE:1.33
	OPENBSD_2_7:1.27.0.2
	OPENBSD_2_7_BASE:1.27
	SMP:1.25.0.2
	SMP_BASE:1.25
	kame_19991208:1.25
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.18.0.2
	OPENBSD_2_4_BASE:1.18
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.96
date	2016.03.02.15.41.48;	author naddy;	state dead;
branches;
next	1.95;
commitid	ZfNt0OHZhMg52abA;

1.95
date	2015.09.13.17.08.03;	author guenther;	state Exp;
branches;
next	1.94;
commitid	BssYI6s6zozAyfkk;

1.94
date	2015.05.07.08.53.32;	author mpi;	state Exp;
branches;
next	1.93;
commitid	c9ymkCbPubGplOgk;

1.93
date	2015.05.02.14.43.06;	author jsg;	state Exp;
branches;
next	1.92;
commitid	rFJz42H3jb1kUvTz;

1.92
date	2014.11.16.12.30.59;	author deraadt;	state Exp;
branches;
next	1.91;
commitid	yv0ECmCdICvq576h;

1.91
date	2014.09.08.01.47.06;	author guenther;	state Exp;
branches;
next	1.90;
commitid	QKTb36RFnfteZJPE;

1.90
date	2014.06.28.21.20.19;	author matthew;	state Exp;
branches;
next	1.89;
commitid	LDp2QfWBOQOk4bmT;

1.89
date	2014.03.30.21.54.49;	author guenther;	state Exp;
branches;
next	1.88;

1.88
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.87;

1.87
date	2014.03.24.03.48.00;	author guenther;	state Exp;
branches;
next	1.86;

1.86
date	2014.02.12.05.47.36;	author guenther;	state Exp;
branches;
next	1.85;

1.85
date	2014.01.23.04.11.46;	author tedu;	state Exp;
branches;
next	1.84;

1.84
date	2013.12.08.03.30.01;	author brad;	state Exp;
branches;
next	1.83;

1.83
date	2013.10.25.05.10.03;	author guenther;	state Exp;
branches;
next	1.82;

1.82
date	2013.10.25.04.51.39;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2013.08.13.05.52.21;	author guenther;	state Exp;
branches;
next	1.80;

1.80
date	2013.05.10.10.31.16;	author pirofti;	state Exp;
branches;
next	1.79;

1.79
date	2012.06.08.14.28.23;	author pirofti;	state Exp;
branches;
next	1.78;

1.78
date	2012.05.23.19.47.02;	author pirofti;	state Exp;
branches;
next	1.77;

1.77
date	2012.05.23.11.08.57;	author pirofti;	state Exp;
branches;
next	1.76;

1.76
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2012.04.10.15.50.52;	author guenther;	state Exp;
branches;
next	1.74;

1.74
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.73;

1.73
date	2011.12.14.08.33.18;	author robert;	state Exp;
branches;
next	1.72;

1.72
date	2011.07.09.00.10.52;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2011.07.08.19.19.20;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2011.07.08.05.01.27;	author matthew;	state Exp;
branches;
next	1.69;

1.69
date	2011.07.07.01.19.39;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2011.06.05.19.41.09;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2011.04.05.15.36.09;	author pirofti;	state Exp;
branches;
next	1.66;

1.66
date	2011.02.11.21.40.04;	author pirofti;	state Exp;
branches;
next	1.65;

1.65
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.64;

1.64
date	2010.06.30.21.54.35;	author guenther;	state Exp;
branches;
next	1.63;

1.63
date	2009.09.05.10.28.43;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2008.06.26.05.42.14;	author ray;	state Exp;
branches;
next	1.61;

1.61
date	2007.09.01.15.14.44;	author martin;	state Exp;
branches;
next	1.60;

1.60
date	2007.02.06.18.42.37;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2006.10.08.19.49.57;	author sturm;	state Exp;
branches;
next	1.58;

1.58
date	2005.02.17.18.07.36;	author jfb;	state Exp;
branches;
next	1.57;

1.57
date	2004.06.24.19.35.23;	author tholo;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.22.23.52.18;	author jfb;	state Exp;
branches;
next	1.55;

1.55
date	2003.12.02.03.46.45;	author nordin;	state Exp;
branches;
next	1.54;

1.54
date	2003.08.15.20.32.16;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2003.08.15.14.02.22;	author fgsch;	state Exp;
branches;
next	1.52;

1.52
date	2003.08.14.18.50.13;	author fgsch;	state Exp;
branches;
next	1.51;

1.51
date	2003.07.23.17.42.09;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2003.07.03.00.00.04;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.21.00.42.58;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2003.01.30.03.29.49;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2002.10.30.20.10.48;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2002.10.28.03.39.30;	author fgsch;	state Exp;
branches;
next	1.45;

1.45
date	2002.08.23.15.39.31;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2002.07.25.22.18.27;	author nordin;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.05.19.43.25;	author jasoni;	state Exp;
branches;
next	1.42;

1.42
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.14.01.26.50;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.12.18.41.20;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.06.19.53.17;	author miod;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.03.21.56.26;	author jasoni;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.03.15.32.34;	author jasoni;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.02.21.43.11;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	2001.01.23.05.48.05;	author csapuntz;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.10.07.04.20;	author jasoni;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.07.17.52.24;	author ericj;	state Exp;
branches;
next	1.31;

1.31
date	2000.07.23.22.35.38;	author jasoni;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.17.05.45.34;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.17.05.43.10;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.26.16.21.27;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.12.04.22.40;	author jasoni;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2000.02.28.13.29.30;	author jasoni;	state Exp;
branches;
next	1.25;

1.25
date	99.12.06.19.36.41;	author aaron;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	99.06.14.06.47.54;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.06.08.16.05.23;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	99.06.08.15.47.39;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	99.05.31.17.34.46;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	99.02.10.08.01.52;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	99.02.10.00.16.12;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	98.07.05.20.49.12;	author downsj;	state Exp;
branches;
next	1.17;

1.17
date	98.07.04.08.59.08;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	98.04.26.10.19.12;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.03.22.23.33.06;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.02.23.08.57.54;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	97.11.26.09.18.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.11.13.18.35.26;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.11.13.06.37.49;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.11.06.05.58.04;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.20.19.31;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.06.15.05.18;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.04.14.11.16.23;	author graichen;	state Exp;
branches;
next	1.6;

1.6
date	96.08.10.12.09.23;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.22.12.01.48;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.17.05.23.54;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	95.12.19.15.41.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.47.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.18;	author deraadt;	state Exp;
branches;
next	;

1.25.2.1
date	2000.03.02.07.04.34;	author niklas;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2001.05.14.22.04.45;	author niklas;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.25.2.5;

1.25.2.5
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.25.2.6;

1.25.2.6
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.25.2.7;

1.25.2.7
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	1.25.2.8;

1.25.2.8
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	;

1.27.2.1
date	2000.07.04.18.48.01;	author jason;	state Exp;
branches;
next	;

1.39.2.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2002.10.29.00.30.51;	author art;	state Exp;
branches;
next	1.39.2.3;

1.39.2.3
date	2003.05.19.21.52.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.96
log
@remove the Linux emulation code, no longer referenced by anything
@
text
@/*	$OpenBSD: linux_misc.c,v 1.95 2015/09/13 17:08:03 guenther Exp $	*/
/*	$NetBSD: linux_misc.c,v 1.27 1996/05/20 01:59:21 fvdl Exp $	*/

/*-
 * Copyright (c) 1995, 1998, 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Frank van der Linden and Eric Haszlakiewicz; by Jason R. Thorpe
 * of the Numerical Aerospace Simulation Facility, NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Linux compatibility module. Try to deal with various Linux system calls.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/dirent.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/mman.h>
#include <sys/mount.h>
#include <sys/ptrace.h>
#include <sys/resource.h>
#include <sys/swap.h>
#include <sys/resourcevar.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/socket.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <sys/vnode.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/unistd.h>

#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

#include <compat/linux/linux_types.h>
#include <compat/linux/linux_time.h>
#include <compat/linux/linux_fcntl.h>
#include <compat/linux/linux_misc.h>
#include <compat/linux/linux_mmap.h>
#include <compat/linux/linux_sched.h>
#include <compat/linux/linux_signal.h>
#include <compat/linux/linux_syscallargs.h>
#include <compat/linux/linux_util.h>
#include <compat/linux/linux_dirent.h>
#include <compat/linux/linux_emuldata.h>

#include <compat/common/compat_dir.h>

/* linux_misc.c */
void	bsd_to_linux_statfs(const struct statfs *, struct linux_statfs *);
void	bsd_to_linux_statfs64(const struct statfs *, struct linux_statfs64 *);
int	linux_select1(struct proc *, register_t *, int, fd_set *,
	     fd_set *, fd_set *, struct linux_timeval *);
int	getdents_common(struct proc *, void *, register_t *, int);
void	linux_to_bsd_mmap_args(struct sys_mmap_args *,
	    const struct linux_sys_mmap2_args *);
void	bsd_to_linux_rusage(struct linux_rusage *, const struct rusage *);
void	bsd_to_linux_wstat(int *);


/*
 * The information on a terminated (or stopped) process needs
 * to be converted in order for Linux binaries to get a valid signal
 * number out of it.
 */
void
bsd_to_linux_wstat(status)
	int *status;
{

	if (WIFSIGNALED(*status))
		*status = (*status & ~0177) |
		    bsd_to_linux_sig[WTERMSIG(*status)];
	else if (WIFSTOPPED(*status))
		*status = (*status & ~0xff00) |
		    (bsd_to_linux_sig[WSTOPSIG(*status)] << 8);
}

/*
 * Convert an rusage to Linux format: small time_t in the timevals
 */
void
bsd_to_linux_rusage(struct linux_rusage *lrup, const struct rusage *rup)
{
	bsd_to_linux_timeval(&lrup->ru_utime, &rup->ru_utime);
	bsd_to_linux_timeval(&lrup->ru_utime, &rup->ru_utime);
	memcpy(&lrup->ru_maxrss, &rup->ru_maxrss,
	    offsetof(struct rusage, ru_nivcsw) -
	    offsetof(struct rusage, ru_maxrss) +
	    sizeof(lrup->ru_nivcsw));
}

/*
 * waitpid(2). Just forward on to linux_sys_wait4 with a NULL rusage.
 */
int
linux_sys_waitpid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_waitpid_args /* {
		syscallarg(int) pid;
		syscallarg(int *) status;
		syscallarg(int) options;
	} */ *uap = v;
	struct sys_wait4_args linux_w4a;

	SCARG(&linux_w4a, pid) = SCARG(uap, pid);
	SCARG(&linux_w4a, status) = SCARG(uap, status);
	SCARG(&linux_w4a, options) = SCARG(uap, options);
	SCARG(&linux_w4a, rusage) = NULL;

	return (linux_sys_wait4(p, &linux_w4a, retval));
}

/*
 * wait4(2): handle conversion of the options on entry and status and rusage
 * on return.
 */
int
linux_sys_wait4(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_wait4_args /* {
		syscallarg(int) pid;
		syscallarg(int *) status;
		syscallarg(int) options;
		syscallarg(struct linux_rusage *) rusage;
	} */ *uap = v;
	struct rusage ru;
	int error, status, linux_options, options;

	linux_options = SCARG(uap, options);
	options = 0;
	if (linux_options & ~(LINUX_WAIT4_WNOHANG|LINUX_WAIT4_WUNTRACED))
		return (EINVAL);

	if (linux_options & LINUX_WAIT4_WNOHANG)
		options |= WNOHANG;
	if (linux_options & LINUX_WAIT4_WUNTRACED)
		options |= WUNTRACED;

	if ((error = dowait4(p, SCARG(uap, pid),
	    SCARG(uap, status) ? &status : NULL, options,
	    SCARG(uap, rusage) ? &ru : NULL, retval)))
		return error;

	atomic_clearbits_int(&p->p_siglist, sigmask(SIGCHLD));

	if (SCARG(uap, rusage) != NULL) {
		struct linux_rusage lru;

		bsd_to_linux_rusage(&lru, &ru);
		if ((error = copyout(&lru, SCARG(uap, rusage), sizeof lru)))
			return error;
	}
	if (SCARG(uap, status) != NULL) {
		bsd_to_linux_wstat(&status);
		return copyout(&status, SCARG(uap, status), sizeof status);
	}

	return 0;
}

/*
 * getrusage(2): convert rusage on return
 */
int
linux_sys_getrusage(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_getrusage_args /* {
		syscallarg(int) who;
		syscallarg(struct linux_rusage *) rusage;
	} */ *uap = v;
	struct rusage ru;
	int error;

	error = dogetrusage(p, SCARG(uap, who), &ru);
	if (error == 0) {
		struct linux_rusage lru;

		bsd_to_linux_rusage(&lru, &ru);
		error = copyout(&lru, SCARG(uap, rusage), sizeof lru);
	}
	return error;
}


int
linux_sys_setresgid16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_setresgid16_args /* {
		syscallarg(u_int16_t) rgid;
		syscallarg(u_int16_t) egid;
		syscallarg(u_int16_t) sgid;
	} */ *uap = v;
	struct sys_setresgid_args nuap;
	u_int16_t rgid, egid, sgid;

	rgid = SCARG(uap, rgid);
	SCARG(&nuap, rgid) = (rgid == (u_int16_t)-1) ? (gid_t)-1 : rgid;
	egid = SCARG(uap, egid);
	SCARG(&nuap, egid) = (egid == (u_int16_t)-1) ? (gid_t)-1 : egid;
	sgid = SCARG(uap, sgid);
	SCARG(&nuap, sgid) = (sgid == (u_int16_t)-1) ? (gid_t)-1 : sgid;

	return sys_setresgid(p, &nuap, retval);
}

int
linux_sys_getresgid16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_getresgid16_args /* {
		syscallarg(u_int16_t *) rgid;
		syscallarg(u_int16_t *) egid;
		syscallarg(u_int16_t *) sgid;
	} */ *uap = v;
	struct sys_getresgid_args nuap;

	SCARG(&nuap, rgid) = (gid_t *)SCARG(uap, rgid);
	SCARG(&nuap, egid) = (gid_t *)SCARG(uap, egid);
	SCARG(&nuap, sgid) = (gid_t *)SCARG(uap, sgid);

	return sys_getresgid(p, &nuap, retval);
}

int
linux_sys_setresuid16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_setresuid16_args /* {
		syscallarg(u_int16_t) ruid;
		syscallarg(u_int16_t) euid;
		syscallarg(u_int16_t) suid;
	} */ *uap = v;
	struct sys_setresuid_args nuap;
	u_int16_t ruid, euid, suid;

	ruid = SCARG(uap, ruid);
	SCARG(&nuap, ruid) = (ruid == (u_int16_t)-1) ? (uid_t)-1 : ruid;
	euid = SCARG(uap, euid);
	SCARG(&nuap, euid) = (euid == (u_int16_t)-1) ? (uid_t)-1 : euid;
	suid = SCARG(uap, suid);
	SCARG(&nuap, suid) = (suid == (u_int16_t)-1) ? (uid_t)-1 : suid;

	return sys_setresuid(p, &nuap, retval);
}

int
linux_sys_getresuid16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_getresuid16_args /* {
		syscallarg(u_int16_t *) ruid;
		syscallarg(u_int16_t *) euid;
		syscallarg(u_int16_t *) suid;
	} */ *uap = v;
	struct sys_getresuid_args nuap;

	SCARG(&nuap, ruid) = (uid_t *)SCARG(uap, ruid);
	SCARG(&nuap, euid) = (uid_t *)SCARG(uap, euid);
	SCARG(&nuap, suid) = (uid_t *)SCARG(uap, suid);

	return sys_getresuid(p, &nuap, retval);
}

/*
 * This is the old brk(2) call. I don't think anything in the Linux
 * world uses this anymore
 */
int
linux_sys_break(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
#if 0
	struct linux_sys_brk_args /* {
		syscallarg(char *) nsize;
	} */ *uap = v;
#endif

	return ENOSYS;
}

/*
 * Linux brk(2). The check if the new address is >= the old one is
 * done in the kernel in Linux. OpenBSD does it in the library.
 */
int
linux_sys_brk(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_brk_args /* {
		syscallarg(char *) nsize;
	} */ *uap = v;
	char *nbrk = SCARG(uap, nsize);
	struct sys_obreak_args oba;
	struct vmspace *vm = p->p_vmspace;
	struct linux_emuldata *ed = (struct linux_emuldata*)p->p_emuldata;

	SCARG(&oba, nsize) = nbrk;

	if ((caddr_t) nbrk > vm->vm_daddr && sys_obreak(p, &oba, retval) == 0)
		ed->p_break = (char*)nbrk;
	else
		nbrk = ed->p_break;

	retval[0] = (register_t)nbrk;

	return 0;
}

/*
 * I wonder why Linux has gettimeofday() _and_ time().. Still, we
 * need to deal with it.
 */
int
linux_sys_time(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_time_args /* {
		linux_time_t *t;
	} */ *uap = v;
	struct timeval atv;
	linux_time_t tt;
	int error;

	microtime(&atv);

	if (atv.tv_sec > LINUX_TIME_MAX)
		return (EOVERFLOW);
	tt = (linux_time_t)atv.tv_sec;
	if (SCARG(uap, t) && (error = copyout(&tt, SCARG(uap, t), sizeof tt)))
		return error;

	retval[0] = tt;
	return 0;
}

/*
 * Convert BSD statfs structure to Linux statfs structure.
 * The Linux structure has less fields, and it also wants
 * the length of a name in a dir entry in a field, which
 * we fake (probably the wrong way).
 */
void
bsd_to_linux_statfs(const struct statfs *bsp, struct linux_statfs *lsp)
{

	/*
	 * Convert BSD filesystem names to Linux filesystem type numbers
	 * where possible.  Linux statfs uses a value of -1 to indicate
	 * an unsupported field.
	 */
	if (!strcmp(bsp->f_fstypename, MOUNT_FFS) ||
	    !strcmp(bsp->f_fstypename, MOUNT_MFS))
		lsp->l_ftype = LINUX_FSTYPE_FFS;
	else if (!strcmp(bsp->f_fstypename, MOUNT_NFS))
		lsp->l_ftype = LINUX_FSTYPE_NFS;
	else if (!strcmp(bsp->f_fstypename, MOUNT_MSDOS))
		lsp->l_ftype = LINUX_FSTYPE_MSDOS;
	else if (!strcmp(bsp->f_fstypename, MOUNT_EXT2FS))
		lsp->l_ftype = LINUX_FSTYPE_EXT2FS;
	else if (!strcmp(bsp->f_fstypename, MOUNT_CD9660))
		lsp->l_ftype = LINUX_FSTYPE_CD9660;
	else if (!strcmp(bsp->f_fstypename, MOUNT_NCPFS))
		lsp->l_ftype = LINUX_FSTYPE_NCPFS;
	else if (!strcmp(bsp->f_fstypename, MOUNT_NTFS))
		lsp->l_ftype = LINUX_FSTYPE_NTFS;
	else if (!strcmp(bsp->f_fstypename, MOUNT_UDF))
		lsp->l_ftype = LINUX_FSTYPE_UDF;
	else if (!strcmp(bsp->f_fstypename, MOUNT_AFS))
		lsp->l_ftype = LINUX_FSTYPE_AFS;
	else
		lsp->l_ftype = -1;

	lsp->l_fbsize = bsp->f_bsize;
	lsp->l_fblocks = bsp->f_blocks;
	lsp->l_fbfree = bsp->f_bfree;
	lsp->l_fbavail = bsp->f_bavail;
	lsp->l_ffiles = bsp->f_files;
	lsp->l_fffree = bsp->f_ffree;
	lsp->l_ffsid.val[0] = bsp->f_fsid.val[0];
	lsp->l_ffsid.val[1] = bsp->f_fsid.val[1];
	lsp->l_fnamelen = MAXNAMLEN;	/* XXX */
}

/*
 * Implement the fs stat functions. Straightforward.
 */
int
linux_sys_statfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_statfs_args /* {
		syscallarg(char *) path;
		syscallarg(struct linux_statfs *) sp;
	} */ *uap = v;
	struct statfs btmp, *bsp;
	struct linux_statfs ltmp;
	struct sys_statfs_args bsa;
	caddr_t sg;
	int error;

	sg = stackgap_init(p);
	bsp = (struct statfs *) stackgap_alloc(&sg, sizeof (struct statfs));

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&bsa, path) = SCARG(uap, path);
	SCARG(&bsa, buf) = bsp;

	if ((error = sys_statfs(p, &bsa, retval)))
		return error;

	if ((error = copyin((caddr_t) bsp, (caddr_t) &btmp, sizeof btmp)))
		return error;

	bsd_to_linux_statfs(&btmp, &ltmp);

	return copyout((caddr_t) &ltmp, (caddr_t) SCARG(uap, sp), sizeof ltmp);
}

void
bsd_to_linux_statfs64(const struct statfs *bsp, struct linux_statfs64 *lsp)
{

	/*
	 * Convert BSD filesystem names to Linux filesystem type numbers
	 * where possible.  Linux statfs uses a value of -1 to indicate
	 * an unsupported field.
	 */
	if (!strcmp(bsp->f_fstypename, MOUNT_FFS) ||
	    !strcmp(bsp->f_fstypename, MOUNT_MFS))
		lsp->l_ftype = LINUX_FSTYPE_FFS;
	else if (!strcmp(bsp->f_fstypename, MOUNT_NFS))
		lsp->l_ftype = LINUX_FSTYPE_NFS;
	else if (!strcmp(bsp->f_fstypename, MOUNT_MSDOS))
		lsp->l_ftype = LINUX_FSTYPE_MSDOS;
	else if (!strcmp(bsp->f_fstypename, MOUNT_EXT2FS))
		lsp->l_ftype = LINUX_FSTYPE_EXT2FS;
	else if (!strcmp(bsp->f_fstypename, MOUNT_CD9660))
		lsp->l_ftype = LINUX_FSTYPE_CD9660;
	else if (!strcmp(bsp->f_fstypename, MOUNT_NCPFS))
		lsp->l_ftype = LINUX_FSTYPE_NCPFS;
	else if (!strcmp(bsp->f_fstypename, MOUNT_NTFS))
		lsp->l_ftype = LINUX_FSTYPE_NTFS;
	else if (!strcmp(bsp->f_fstypename, MOUNT_UDF))
		lsp->l_ftype = LINUX_FSTYPE_UDF;
	else if (!strcmp(bsp->f_fstypename, MOUNT_AFS))
		lsp->l_ftype = LINUX_FSTYPE_AFS;
	else
		lsp->l_ftype = -1;

	lsp->l_fbsize = bsp->f_bsize;
	lsp->l_fblocks = bsp->f_blocks;
	lsp->l_fbfree = bsp->f_bfree;
	lsp->l_fbavail = bsp->f_bavail;
	lsp->l_ffiles = bsp->f_files;
	lsp->l_fffree = bsp->f_ffree;
	lsp->l_ffsid.val[0] = bsp->f_fsid.val[0];
	lsp->l_ffsid.val[1] = bsp->f_fsid.val[1];
	lsp->l_fnamelen = MAXNAMLEN;	/* XXX */
}

int
linux_sys_statfs64(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_statfs64_args /* {
		syscallarg(char *) path;
		syscallarg(struct linux_statfs64 *) sp;
	} */ *uap = v;
	struct statfs btmp, *bsp;
	struct linux_statfs64 ltmp;
	struct sys_statfs_args bsa;
	caddr_t sg;
	int error;

	sg = stackgap_init(p);
	bsp = (struct statfs *) stackgap_alloc(&sg, sizeof (struct statfs));

	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&bsa, path) = SCARG(uap, path);
	SCARG(&bsa, buf) = bsp;

	if ((error = sys_statfs(p, &bsa, retval)))
		return error;

	if ((error = copyin((caddr_t) bsp, (caddr_t) &btmp, sizeof btmp)))
		return error;

	bsd_to_linux_statfs64(&btmp, &ltmp);

	return copyout((caddr_t) &ltmp, (caddr_t) SCARG(uap, sp), sizeof ltmp);
}

int
linux_sys_fstatfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_fstatfs_args /* {
		syscallarg(int) fd;
		syscallarg(struct linux_statfs *) sp;
	} */ *uap = v;
	struct statfs btmp, *bsp;
	struct linux_statfs ltmp;
	struct sys_fstatfs_args bsa;
	caddr_t sg;
	int error;

	sg = stackgap_init(p);
	bsp = (struct statfs *) stackgap_alloc(&sg, sizeof (struct statfs));

	SCARG(&bsa, fd) = SCARG(uap, fd);
	SCARG(&bsa, buf) = bsp;

	if ((error = sys_fstatfs(p, &bsa, retval)))
		return error;

	if ((error = copyin((caddr_t) bsp, (caddr_t) &btmp, sizeof btmp)))
		return error;

	bsd_to_linux_statfs(&btmp, &ltmp);

	return copyout((caddr_t) &ltmp, (caddr_t) SCARG(uap, sp), sizeof ltmp);
}

int
linux_sys_fstatfs64(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_fstatfs64_args /* {
		syscallarg(int) fd;
		syscallarg(struct linux_statfs64 *) sp;
	} */ *uap = v;
	struct statfs btmp, *bsp;
	struct linux_statfs64 ltmp;
	struct sys_fstatfs_args bsa;
	caddr_t sg;
	int error;

	sg = stackgap_init(p);
	bsp = (struct statfs *) stackgap_alloc(&sg, sizeof (struct statfs));

	SCARG(&bsa, fd) = SCARG(uap, fd);
	SCARG(&bsa, buf) = bsp;

	if ((error = sys_fstatfs(p, &bsa, retval)))
		return error;

	if ((error = copyin((caddr_t) bsp, (caddr_t) &btmp, sizeof btmp)))
		return error;

	bsd_to_linux_statfs64(&btmp, &ltmp);

	return copyout((caddr_t) &ltmp, (caddr_t) SCARG(uap, sp), sizeof ltmp);
}
/*
 * uname(). Just copy the info from the various strings stored in the
 * kernel, and put it in the Linux utsname structure. That structure
 * is almost the same as the OpenBSD one, only it has fields 65 characters
 * long, and an extra domainname field.
 */
int
linux_sys_uname(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_uname_args /* {
		syscallarg(struct linux_utsname *) up;
	} */ *uap = v;
	extern char hostname[], machine[], domainname[];
	struct linux_utsname luts;
	int len;
	char *cp;

	strlcpy(luts.l_sysname, ostype, sizeof(luts.l_sysname));
	strlcpy(luts.l_nodename, hostname, sizeof(luts.l_nodename));
	strlcpy(luts.l_release, osrelease, sizeof(luts.l_release));
	strlcpy(luts.l_version, version, sizeof(luts.l_version));
	strlcpy(luts.l_machine, machine, sizeof(luts.l_machine));
	strlcpy(luts.l_domainname, domainname, sizeof(luts.l_domainname));

	/* This part taken from the uname() in libc */
	len = sizeof(luts.l_version);
	for (cp = luts.l_version; len--; ++cp)
		if (*cp == '\n' || *cp == '\t')
			*cp = (len > 1) ? ' ' : '\0';

	return copyout(&luts, SCARG(uap, up), sizeof(luts));
}

int
linux_sys_olduname(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_uname_args /* {
		syscallarg(struct linux_oldutsname *) up;
	} */ *uap = v;
	extern char hostname[], machine[];
	struct linux_oldutsname luts;
	int len;
	char *cp;

	strlcpy(luts.l_sysname, ostype, sizeof(luts.l_sysname));
	strlcpy(luts.l_nodename, hostname, sizeof(luts.l_nodename));
	strlcpy(luts.l_release, osrelease, sizeof(luts.l_release));
	strlcpy(luts.l_version, version, sizeof(luts.l_version));
	strlcpy(luts.l_machine, machine, sizeof(luts.l_machine));

	/* This part taken from the uname() in libc */
	len = sizeof(luts.l_version);
	for (cp = luts.l_version; len--; ++cp)
		if (*cp == '\n' || *cp == '\t')
			*cp = (len > 1) ? ' ' : '\0';

	return copyout(&luts, SCARG(uap, up), sizeof(luts));
}

int
linux_sys_oldolduname(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_uname_args /* {
		syscallarg(struct linux_oldoldutsname *) up;
	} */ *uap = v;
	extern char hostname[], machine[];
	struct linux_oldoldutsname luts;
	int len;
	char *cp;

	strlcpy(luts.l_sysname, ostype, sizeof(luts.l_sysname));
	strlcpy(luts.l_nodename, hostname, sizeof(luts.l_nodename));
	strlcpy(luts.l_release, osrelease, sizeof(luts.l_release));
	strlcpy(luts.l_version, version, sizeof(luts.l_version));
	strlcpy(luts.l_machine, machine, sizeof(luts.l_machine));

	/* This part taken from the uname() in libc */
	len = sizeof(luts.l_version);
	for (cp = luts.l_version; len--; ++cp)
		if (*cp == '\n' || *cp == '\t')
			*cp = (len > 1) ? ' ' : '\0';

	return copyout(&luts, SCARG(uap, up), sizeof(luts));
}

int
linux_sys_sethostname(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_sethostname_args *uap = v;
	int name;
	int error;

	if ((error = suser(p, 0)) != 0)
		return (error);
	name = KERN_HOSTNAME;
	return (kern_sysctl(&name, 1, 0, 0, SCARG(uap, hostname),
			    SCARG(uap, len), p));
}

/*
 * Linux wants to pass everything to a syscall in registers. However,
 * mmap() has 6 of them. Oops: out of register error. They just pass
 * everything in a structure.
 */
int
linux_sys_mmap(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_mmap_args /* {
		syscallarg(struct linux_mmap *) lmp;
	} */ *uap = v;
	struct linux_mmap lmap;
	struct linux_sys_mmap2_args nlmap;
	struct sys_mmap_args cma;
	int error;

	if ((error = copyin(SCARG(uap, lmp), &lmap, sizeof lmap)))
		return error;

	if (lmap.lm_pos & PAGE_MASK)
		return EINVAL;

	/* repackage into something sane */
	SCARG(&nlmap,addr) = (unsigned long)lmap.lm_addr;
	SCARG(&nlmap,len) = lmap.lm_len;
	SCARG(&nlmap,prot) = lmap.lm_prot;
	SCARG(&nlmap,flags) = lmap.lm_flags;
	SCARG(&nlmap,fd) = lmap.lm_fd;
	SCARG(&nlmap,offset) = (unsigned)lmap.lm_pos;

	linux_to_bsd_mmap_args(&cma, &nlmap);
	SCARG(&cma, pos) = (off_t)SCARG(&nlmap, offset);

	return sys_mmap(p, &cma, retval);
}

/*
 * Guts of most architectures' mmap64() implementations.  This shares
 * its list of arguments with linux_sys_mmap().
 *
 * The difference in linux_sys_mmap2() is that "offset" is actually
 * (offset / pagesize), not an absolute byte count.  This translation
 * to pagesize offsets is done inside glibc between the mmap64() call
 * point, and the actual syscall.
 */
int
linux_sys_mmap2(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_mmap2_args /* {
		syscallarg(unsigned long) addr;
		syscallarg(size_t) len;
		syscallarg(int) prot;
		syscallarg(int) flags;
		syscallarg(int) fd;
		syscallarg(linux_off_t) offset;
	} */ *uap = v;
	struct sys_mmap_args cma;

	linux_to_bsd_mmap_args(&cma, uap);
	SCARG(&cma, pos) = ((off_t)SCARG(uap, offset)) << PAGE_SHIFT;

	return sys_mmap(p, &cma, retval);
}

void
linux_to_bsd_mmap_args(cma, uap)
	struct sys_mmap_args *cma;
	const struct linux_sys_mmap2_args *uap;
{
	int flags = 0, fl = SCARG(uap, flags);
	
	flags |= cvtto_bsd_mask(fl, LINUX_MAP_SHARED, MAP_SHARED);
	flags |= cvtto_bsd_mask(fl, LINUX_MAP_PRIVATE, MAP_PRIVATE);
	flags |= cvtto_bsd_mask(fl, LINUX_MAP_FIXED, MAP_FIXED);
	flags |= cvtto_bsd_mask(fl, LINUX_MAP_ANON, MAP_ANON);
	/* XXX XAX ERH: Any other flags here?  There are more defined... */

	SCARG(cma, addr) = (void *)SCARG(uap, addr);
	SCARG(cma, len) = SCARG(uap, len);
	SCARG(cma, prot) = SCARG(uap, prot);
	if (SCARG(cma, prot) & PROT_WRITE) /* XXX */
		SCARG(cma, prot) |= PROT_READ;
	SCARG(cma, flags) = flags;
	SCARG(cma, fd) = flags & MAP_ANON ? -1 : SCARG(uap, fd);
	SCARG(cma, pad) = 0;
}

int
linux_sys_mremap(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	struct linux_sys_mremap_args /* {
		syscallarg(void *) old_address;
		syscallarg(size_t) old_size;
		syscallarg(size_t) new_size;
		syscallarg(u_long) flags;
	} */ *uap = v;
	struct sys_munmap_args mua;
	size_t old_size, new_size;
	int error;
 
	old_size = round_page(SCARG(uap, old_size));
	new_size = round_page(SCARG(uap, new_size));
 
	/*
	 * Growing mapped region.
	 */
	if (new_size > old_size) {
		/*
		 * XXX Implement me.  What we probably want to do is
		 * XXX dig out the guts of the old mapping, mmap that
		 * XXX object again with the new size, then munmap
		 * XXX the old mapping.
		 */
		*retval = 0;
		return (ENOMEM);
	}
	/*
	 * Shrinking mapped region.
	 */
	if (new_size < old_size) {
		SCARG(&mua, addr) = (caddr_t)SCARG(uap, old_address) + new_size;
		SCARG(&mua, len) = old_size - new_size;
		error = sys_munmap(p, &mua, retval);
		*retval = error ? 0 : (register_t)SCARG(uap, old_address);
		return (error);
	}
 
	/*
	 * No change.
	 */
	*retval = (register_t)SCARG(uap, old_address);
	return (0);

}

/*
 * This code is partly stolen from src/lib/libc/gen/times.c
 * XXX - CLK_TCK isn't declared in /sys, just in <time.h>, done here
 */

#define CLK_TCK 100
#define	CONVTCK(r)	(r.tv_sec * CLK_TCK + r.tv_usec / (1000000 / CLK_TCK))

int
linux_sys_times(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_times_args /* {
		syscallarg(struct linux_tms *) tms;
	} */ *uap = v;
	struct timeval t, ut, st;
	struct linux_tms ltms;
	time_t ticks;
	int error;

	calcru(&p->p_p->ps_tu, &ut, &st, NULL);

	ticks = CONVTCK(ut);
	if (ticks > LINUX_TIME_MAX)
		return EOVERFLOW;
	ltms.ltms_utime = (linux_clock_t)ticks;

	ticks = CONVTCK(st);
	if (ticks > LINUX_TIME_MAX)
		return EOVERFLOW;
	ltms.ltms_stime = (linux_clock_t)ticks;

	ticks = CONVTCK(p->p_p->ps_cru.ru_utime);
	if (ticks > LINUX_TIME_MAX)
		return EOVERFLOW;
	ltms.ltms_cutime = (linux_clock_t)ticks;

	ticks = CONVTCK(p->p_p->ps_cru.ru_stime);
	if (ticks > LINUX_TIME_MAX)
		return EOVERFLOW;
	ltms.ltms_cstime = (linux_clock_t)ticks;

	if ((error = copyout(&ltms, SCARG(uap, tms), sizeof ltms)))
		return error;

	microuptime(&t);

	retval[0] = ((linux_clock_t)(CONVTCK(t)));
	return 0;
}

/*
 * Alarm. This is a libc call which uses setitimer(2) in OpenBSD.
 * Fiddle with the timers to make it work.
 */
int
linux_sys_alarm(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_alarm_args /* {
		syscallarg(unsigned int) secs;
	} */ *uap = v;
	struct process *pr;
	struct itimerval *itp, it;
	struct timeval tv;
	int s;
	int timo;
	linux_time_t seconds_due = 0;

	pr = p->p_p;
	itp = &pr->ps_timer[ITIMER_REAL];
	s = splclock();
	/*
	 * Clear any pending timer alarms.
	 */
	getmicrouptime(&tv);
	timeout_del(&pr->ps_realit_to);
	timerclear(&itp->it_interval);
	if (timerisset(&itp->it_value) &&
	    timercmp(&itp->it_value, &tv, >))
		timersub(&itp->it_value, &tv, &itp->it_value);
	/*
	 * Return how many seconds were left (rounded up)
	 */
	if (itp->it_value.tv_sec > LINUX_TIME_MAX) {
		splx(s);
		return EOVERFLOW;
	}
	seconds_due = (linux_time_t)itp->it_value.tv_sec;
	if (itp->it_value.tv_usec) {
		if (seconds_due == LINUX_TIME_MAX) {
			splx(s);
			return EOVERFLOW;
		}
		seconds_due++;
	}
	retval[0] = seconds_due;

	/*
	 * alarm(0) just resets the timer.
	 */
	if (SCARG(uap, secs) == 0) {
		timerclear(&itp->it_value);
		splx(s);
		return 0;
	}

	/*
	 * Check the new alarm time for sanity, and set it.
	 */
	timerclear(&it.it_interval);
	it.it_value.tv_sec = SCARG(uap, secs);
	it.it_value.tv_usec = 0;
	if (itimerfix(&it.it_value)) {
		splx(s);
		return (EINVAL);
	}

	if (timerisset(&it.it_value)) {
		timo = tvtohz(&it.it_value);
		timeradd(&it.it_value, &tv, &it.it_value);
		timeout_add(&pr->ps_realit_to, timo);
	}
	pr->ps_timer[ITIMER_REAL] = it;
	splx(s);

	return 0;
}

/*
 * utime(). Do conversion to things that utimes() understands, 
 * and pass it on.
 */
int
linux_sys_utime(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_utime_args /* {
		syscallarg(char *) path;
		syscallarg(struct linux_utimbuf *)times;
	} */ *uap = v;
	caddr_t sg;
	int error;
	struct sys_utimes_args ua;
	struct timeval tv[2], *tvp;
	struct linux_utimbuf lut;

	sg = stackgap_init(p);
	tvp = (struct timeval *) stackgap_alloc(&sg, sizeof(tv));
	LINUX_CHECK_ALT_EXIST(p, &sg, SCARG(uap, path));

	SCARG(&ua, path) = SCARG(uap, path);

	if (SCARG(uap, times) != NULL) {
		if ((error = copyin(SCARG(uap, times), &lut, sizeof lut)))
			return error;
		tv[0].tv_usec = tv[1].tv_usec = 0;
		tv[0].tv_sec = lut.l_actime;
		tv[1].tv_sec = lut.l_modtime;
		if ((error = copyout(tv, tvp, sizeof tv)))
			return error;
		SCARG(&ua, tptr) = tvp;
	}
	else
		SCARG(&ua, tptr) = NULL;

	return sys_utimes(p, &ua, retval);
}

/*
 * The old Linux readdir was only able to read one entry at a time,
 * even though it had a 'count' argument. In fact, the emulation
 * of the old call was better than the original, because it did handle
 * the count arg properly. Don't bother with it anymore now, and use
 * it to distinguish between old and new. The difference is that the
 * newer one actually does multiple entries, and the reclen field
 * really is the reclen, not the namelength.
 */
int
linux_sys_readdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_readdir_args /* {
		syscallarg(int) fd;
		syscallarg(struct linux_dirent *) dent;
		syscallarg(unsigned int) count;
	} */ *uap = v;

	SCARG(uap, count) = 1;

	return linux_sys_getdents(p, uap, retval);
}

/*
 * Linux 'readdir' call. This code is mostly taken from the
 * SunOS getdents call (see compat/sunos/sunos_misc.c), though
 * an attempt has been made to keep it a little cleaner (failing
 * miserably, because of the cruft needed if count 1 is passed).
 *
 * The d_off field should contain the offset of the next valid entry,
 * but in Linux it has the offset of the entry itself. We emulate
 * that bug here.
 *
 * Read in BSD-style entries, convert them, and copy them out.
 *
 * Note that this doesn't handle union-mounted filesystems.
 */
int linux_readdir_callback(void *, struct dirent *);

struct linux_readdir_callback_args {
	caddr_t outp;
	int     resid;
	int     oldcall;
	int	is64bit;
};

int
linux_readdir_callback(arg, bdp)
	void *arg;
	struct dirent *bdp;
{
	struct linux_dirent64 idb64;
	struct linux_dirent idb;
	struct linux_readdir_callback_args *cb = arg;
	int linux_reclen;
	int error;

	if (cb->oldcall == 2) 
		return (ENOMEM);

	linux_reclen = (cb->is64bit) ?
	     LINUX_RECLEN(&idb64, bdp->d_namlen) :
	     LINUX_RECLEN(&idb, bdp->d_namlen);

	if (cb->resid < linux_reclen)
		return (ENOMEM);

	if (cb->is64bit) {
		idb64.d_ino = (linux_ino64_t)bdp->d_fileno;
		idb64.d_off = (linux_off64_t)bdp->d_off;
		idb64.d_reclen = (u_short)linux_reclen;
		idb64.d_type = bdp->d_type;
		strlcpy(idb64.d_name, bdp->d_name, sizeof(idb64.d_name));
		error = copyout((caddr_t)&idb64, cb->outp, linux_reclen);
	} else {
		if (bdp->d_fileno > LINUX_INO_MAX)
			return EOVERFLOW;
		idb.d_ino = (linux_ino_t)bdp->d_fileno;
		if (cb->oldcall) {
			/*
			 * The old readdir() call misuses the offset
			 * and reclen fields.
			 */
			idb.d_off = (linux_off_t)linux_reclen;
			idb.d_reclen = (u_short)bdp->d_namlen;
		} else {
			idb.d_off = (linux_off_t)bdp->d_off;
			idb.d_reclen = (u_short)linux_reclen;
		}
		strlcpy(idb.d_name, bdp->d_name, sizeof(idb.d_name));
		error = copyout((caddr_t)&idb, cb->outp, linux_reclen);
	}
	if (error)
		return (error);

	/* advance output past Linux-shaped entry */
	cb->outp += linux_reclen;
	cb->resid -= linux_reclen;

	if (cb->oldcall == 1)
		++cb->oldcall;
	
	return (0);
}

int
linux_sys_getdents64(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	return getdents_common(p, v, retval, 1);
}

int
linux_sys_getdents(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	return getdents_common(p, v, retval, 0);
}

int
getdents_common(p, v, retval, is64bit)
	struct proc *p;
	void *v;
	register_t *retval;
	int is64bit;
{
	struct linux_sys_getdents_args /* {
		syscallarg(int) fd;
		syscallarg(void *) dirent;
		syscallarg(unsigned) count;
	} */ *uap = v;
	struct linux_readdir_callback_args args;
	struct file *fp;
	int error;
	int nbytes = SCARG(uap, count);

	if ((error = getvnode(p, SCARG(uap, fd), &fp)) != 0)
		return (error);

	if (nbytes == 1) {	/* emulating old, broken behaviour */
		/* readdir(2) case. Always struct dirent. */
		if (is64bit) {
			FRELE(fp, p);
			return (EINVAL);
		}
		nbytes = sizeof(struct linux_dirent);
		args.oldcall = 1;
	} else {
		args.oldcall = 0;
	}

	args.resid = nbytes;
	args.outp = (caddr_t)SCARG(uap, dirent);
	args.is64bit = is64bit;

	if ((error = readdir_with_callback(fp, &fp->f_offset, nbytes,
	    linux_readdir_callback, &args)) != 0)
		goto exit;

	*retval = nbytes - args.resid;

 exit:
	FRELE(fp, p);
	return (error);
}

/*
 * Not sure why the arguments to this older version of select() were put
 * into a structure, because there are 5, and that can be handled all
 * in registers on the i386 like Linux wants to.
 */
int
linux_sys_oldselect(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_oldselect_args /* {
		syscallarg(struct linux_select *) lsp;
	} */ *uap = v;
	struct linux_select ls;
	int error;

	if ((error = copyin(SCARG(uap, lsp), &ls, sizeof(ls))))
		return error;

	return linux_select1(p, retval, ls.nfds, ls.readfds, ls.writefds,
	    ls.exceptfds, ls.timeout);
}

/*
 * Even when just using registers to pass arguments to syscalls you can
 * have 5 of them on the i386. So this newer version of select() does
 * this.
 */
int
linux_sys_select(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_select_args /* {
		syscallarg(int) nfds;
		syscallarg(fd_set *) readfds;
		syscallarg(fd_set *) writefds;
		syscallarg(fd_set *) exceptfds;
		syscallarg(struct linux_timeval *) timeout;
	} */ *uap = v;

	return linux_select1(p, retval, SCARG(uap, nfds), SCARG(uap, readfds),
	    SCARG(uap, writefds), SCARG(uap, exceptfds), SCARG(uap, timeout));
}

/*
 * Common code for the old and new versions of select(). A couple of
 * things are important:
 * 1) return the amount of time left in the 'timeout' parameter
 * 2) select never returns ERESTART on Linux, always return EINTR
 */
int
linux_select1(struct proc *p, register_t *retval, int nfds, fd_set *readfds,
    fd_set *writefds, fd_set *exceptfds, struct linux_timeval *timeout)
{
	struct sys_select_args bsa;
	struct linux_timeval lutv;
	struct timeval tv0, tv1, utv, *tvp;
	caddr_t sg;
	int error;

	SCARG(&bsa, nd) = nfds;
	SCARG(&bsa, in) = readfds;
	SCARG(&bsa, ou) = writefds;
	SCARG(&bsa, ex) = exceptfds;

	/*
	 * Store current time for computation of the amount of
	 * time left.
	 */
	if (timeout) {
		if ((error = copyin(timeout, &lutv, sizeof(lutv))))
			return error;
		linux_to_bsd_timeval(&utv, &lutv);
		if (itimerfix(&utv)) {
			/*
			 * The timeval was invalid.  Convert it to something
			 * valid that will act as it does under Linux.
			 */
			utv.tv_sec += utv.tv_usec / 1000000;
			utv.tv_usec %= 1000000;
			if (utv.tv_usec < 0) {
				utv.tv_sec -= 1;
				utv.tv_usec += 1000000;
			}
			if (utv.tv_sec < 0)
				timerclear(&utv);
		}

		sg = stackgap_init(p);
		tvp = stackgap_alloc(&sg, sizeof(utv));
		if ((error = copyout(&utv, tvp, sizeof(utv))))
			return error;
		SCARG(&bsa, tv) = tvp;
		microtime(&tv0);
	} else
		SCARG(&bsa, tv) = NULL;

	error = sys_select(p, &bsa, retval);
	if (error) {
		/*
		 * See fs/select.c in the Linux kernel.  Without this,
		 * Maelstrom doesn't work.
		 */
		if (error == ERESTART)
			error = EINTR;
		else if (error != EINTR)
			return error;
	}

	if (timeout) {
		if (*retval) {
			/*
			 * Compute how much time was left of the timeout,
			 * by subtracting the current time and the time
			 * before we started the call, and subtracting
			 * that result from the user-supplied value.
			 */
			microtime(&tv1);
			timersub(&tv1, &tv0, &tv1);
			timersub(&utv, &tv1, &utv);
			if (utv.tv_sec < 0)
				timerclear(&utv);
		} else
			timerclear(&utv);
		bsd_to_linux_timeval(&lutv, &utv);	/* can't fail */
		if ((error = copyout(&lutv, timeout, sizeof(lutv))))
			return error;
	}

	return (error);
}

/*
 * Get the process group of a certain process. Look it up
 * and return the value.
 */
int
linux_sys_getpgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_getpgid_args /* {
		syscallarg(int) pid;
	} */ *uap = v;
	struct process *targpr;

	if (SCARG(uap, pid) != 0 && SCARG(uap, pid) != p->p_p->ps_pid) {
		if ((targpr = prfind(SCARG(uap, pid))) == 0)
			return ESRCH;
	}
	else
		targpr = p->p_p;

	retval[0] = targpr->ps_pgid;
	return 0;
}

/*
 * Set the 'personality' (emulation mode) for the current process. Only
 * accept the Linux personality here (0). This call is needed because
 * the Linux ELF crt0 issues it in an ugly kludge to make sure that
 * ELF binaries run in Linux mode, not SVR4 mode.
 */
int
linux_sys_personality(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_personality_args /* {
		syscallarg(int) per;
	} */ *uap = v;

	if (SCARG(uap, per) != 0)
		return EINVAL;
	retval[0] = 0;
	return 0;
}

/*
 * The calls are here because of type conversions.
 */
int
linux_sys_setreuid16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_setreuid16_args /* {
		syscallarg(int) ruid;
		syscallarg(int) euid;
	} */ *uap = v;
	struct sys_setreuid_args bsa;
	
	SCARG(&bsa, ruid) = ((linux_uid_t)SCARG(uap, ruid) == (linux_uid_t)-1) ?
		(uid_t)-1 : SCARG(uap, ruid);
	SCARG(&bsa, euid) = ((linux_uid_t)SCARG(uap, euid) == (linux_uid_t)-1) ?
		(uid_t)-1 : SCARG(uap, euid);

	return sys_setreuid(p, &bsa, retval);
}

int
linux_sys_setregid16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_setregid16_args /* {
		syscallarg(int) rgid;
		syscallarg(int) egid;
	} */ *uap = v;
	struct sys_setregid_args bsa;
	
	SCARG(&bsa, rgid) = ((linux_gid_t)SCARG(uap, rgid) == (linux_gid_t)-1) ?
		(uid_t)-1 : SCARG(uap, rgid);
	SCARG(&bsa, egid) = ((linux_gid_t)SCARG(uap, egid) == (linux_gid_t)-1) ?
		(uid_t)-1 : SCARG(uap, egid);

	return sys_setregid(p, &bsa, retval);
}

int
linux_sys___sysctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys___sysctl_args /* {
		syscallarg(struct linux___sysctl *) lsp;
	} */ *uap = v;
	struct linux___sysctl ls;
	struct sys_sysctl_args bsa;
	int error;

	if ((error = copyin(SCARG(uap, lsp), &ls, sizeof ls)))
		return error;
	SCARG(&bsa, name) = ls.name;
	SCARG(&bsa, namelen) = ls.namelen;
	SCARG(&bsa, old) = ls.old;
	SCARG(&bsa, oldlenp) = ls.oldlenp;
	SCARG(&bsa, new) = ls.new;
	SCARG(&bsa, newlen) = ls.newlen;

	return sys_sysctl(p, &bsa, retval);
}

/*
 * We have nonexistent fsuid equal to uid.
 * If modification is requested, refuse.
 */
int
linux_sys_setfsuid(p, v, retval)
	 struct proc *p;
	 void *v;
	 register_t *retval;
{
	 struct linux_sys_setfsuid_args /* {
		 syscallarg(uid_t) uid;
	 } */ *uap = v;
	 uid_t uid;

	 uid = SCARG(uap, uid);
	 if (p->p_ucred->cr_ruid != uid)
		 return sys_nosys(p, v, retval);
	 else
		 return (0);
}

int
linux_sys_getfsuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	return sys_getuid(p, v, retval);
}


int
linux_sys_nice(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_nice_args /* {
		syscallarg(int) incr;
	} */ *uap = v;
	struct sys_setpriority_args bsa;

	SCARG(&bsa, which) = PRIO_PROCESS;
	SCARG(&bsa, who) = 0;
	SCARG(&bsa, prio) = SCARG(uap, incr);
	return sys_setpriority(p, &bsa, retval);
}

int
linux_sys_getpid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	*retval = p->p_p->ps_pid;
	return (0);
}

linux_pid_t
linux_sys_gettid(struct proc *p, void *v, register_t *retval)
{
	*retval = p->p_pid + THREAD_PID_OFFSET;
	return (0);
}

int
linux_sys_getuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	*retval = p->p_ucred->cr_ruid;
	return (0);
}

int
linux_sys_getgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	*retval = p->p_ucred->cr_rgid;
	return (0);
}


/*
 * sysinfo()
 */
/* ARGSUSED */
int
linux_sys_sysinfo(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_sysinfo_args /* {
		syscallarg(struct linux_sysinfo *) sysinfo;
	} */ *uap = v;
	struct linux_sysinfo si;
	struct loadavg *la;
	extern long bufpages;
	struct timeval tv;

	getmicrouptime(&tv);
	if (tv.tv_sec > LINUX_TIME_MAX)
		return EOVERFLOW;
	si.uptime = (linux_time_t)tv.tv_sec;
	la = &averunnable;
	si.loads[0] = la->ldavg[0] * LINUX_SYSINFO_LOADS_SCALE / la->fscale;
	si.loads[1] = la->ldavg[1] * LINUX_SYSINFO_LOADS_SCALE / la->fscale;
	si.loads[2] = la->ldavg[2] * LINUX_SYSINFO_LOADS_SCALE / la->fscale;
	si.totalram = ptoa(physmem);
	si.freeram = uvmexp.free * uvmexp.pagesize;
	si.sharedram = 0;/* XXX */
	si.bufferram = bufpages * PAGE_SIZE;
	si.totalswap = uvmexp.swpages * PAGE_SIZE;
	si.freeswap = (uvmexp.swpages - uvmexp.swpginuse) * PAGE_SIZE;
	si.procs = nthreads;
	/* The following are only present in newer Linux kernels. */
	si.totalbig = 0;
	si.freebig = 0;
	si.mem_unit = 1;

	return (copyout(&si, SCARG(uap, sysinfo), sizeof(si)));
}

int
linux_sys_mprotect(struct proc *p, void *v, register_t *retval)
{
	struct sys_mprotect_args *uap = v;

	if (SCARG(uap, prot) & (PROT_WRITE | PROT_EXEC))
		SCARG(uap, prot) |= PROT_READ;
	return (sys_mprotect(p, uap, retval));
}

int
linux_sys_setdomainname(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_setdomainname_args *uap = v;
	int error, mib[1];
	
	if ((error = suser(p, 0)))
		return (error);
	mib[0] = KERN_DOMAINNAME;
	return (kern_sysctl(mib, 1, NULL, NULL, SCARG(uap, name),
	    SCARG(uap, len), p));
}

int
linux_sys_swapon(struct proc *p, void *v, register_t *retval)
{
	struct sys_swapctl_args ua;
	struct linux_sys_swapon_args /* {
		syscallarg(const char *) name;
	} */ *uap = v;

	SCARG(&ua, cmd) = SWAP_ON;
	SCARG(&ua, arg) = (void *)SCARG(uap, name);
	SCARG(&ua, misc) = 0;	/* priority */
	return (sys_swapctl(p, &ua, retval));
}

int
linux_sys_prctl(struct proc *p, void *v, register_t *retval)
{
	int error = 0, max_size, pdeath_signal;
	char comm[LINUX_MAX_COMM_LEN];
	struct linux_emuldata *ed = (struct linux_emuldata*)p->p_emuldata;

	struct linux_sys_prctl_args /* {
		int option;
		unsigned long arg2;
		unsigned long arg3;
		unsigned long arg4;
		unsigned long arg5;
	} */ *uap = v;

	switch (SCARG(uap, option)) {
	case LINUX_PR_SET_PDEATHSIG:
		if (SCARG(uap, arg2) >= LINUX__NSIG)
			return (EINVAL);
		ed->pdeath_signal = SCARG(uap, arg2);
		break;
	case LINUX_PR_GET_PDEATHSIG:
		pdeath_signal = ed->pdeath_signal;
		error = copyout(&pdeath_signal, (void *)SCARG(uap, arg2),
		    sizeof(pdeath_signal));
		break;
	case LINUX_PR_GET_KEEPCAPS:
		/*
		 * Indicate that we always clear the effective and
		 * permitted capability sets when the user id becomes
		 * non-zero (actually the capability sets are simply
		 * always zero in the current implementation).
		 */
		*retval = 0;
		break;
	case LINUX_PR_SET_KEEPCAPS:
		 /*
		  * Ignore requests to keep the effective and permitted
		  * capability sets when the user id becomes non-zero.
		  */
		break;
	case LINUX_PR_SET_NAME:
		/*
		 * To be on the safe side we need to make sure not to
		 * overflow the size a linux program expects. We already
		 * do this here in the copyin, so that we don't need to
		 * check on copyout.
		 */
		max_size = MIN(sizeof(comm), sizeof(p->p_comm));
		error = copyinstr((void *)SCARG(uap, arg2), comm,
		    max_size, NULL);

		/* Linux silently truncates the name if it is too long. */
		if (error == ENAMETOOLONG) {
			/*
			 * XXX: copyinstr() isn't documented to populate the
			 * array completely, so do a copyin() to be on the
			 * safe side. This should be changed in case copyinstr()
			 * is changed to guarantee this.
			 */
			error = copyin((void *)SCARG(uap, arg2), comm,
			    max_size - 1);
			comm[max_size - 1] = '\0';
		}
		if (error)
			return (error);
		strlcpy(p->p_comm, comm, sizeof(p->p_comm));
		break;
	case LINUX_PR_GET_NAME:
		strlcpy(comm, p->p_comm, sizeof(comm));
		error = copyout(comm, (void *)SCARG(uap, arg2),
		    strlen(comm) + 1);
		break;
	default:
		printf("linux_sys_prctl: unsupported option %d\n",
		    SCARG(uap, option));
		error = EINVAL;
		break;
	}

	return (error);
}
@


1.95
log
@Rename __sysctl syscall to just sysctl, as the userland wrapper is no longer
necessary

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.94 2015/05/07 08:53:32 mpi Exp $	*/
@


1.94
log
@Pass a thread pointer instead of its file descriptor table to getvnode(9).

Input and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.93 2015/05/02 14:43:06 jsg Exp $	*/
d1456 1
a1456 1
	struct sys___sysctl_args bsa;
d1468 1
a1468 1
	return sys___sysctl(p, &bsa, retval);
@


1.93
log
@add missing splx calls
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.92 2014/11/16 12:30:59 deraadt Exp $	*/
d1190 1
a1190 1
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
@


1.92
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.91 2014/09/08 01:47:06 guenther Exp $	*/
d960 2
a961 1
	if (itp->it_value.tv_sec > LINUX_TIME_MAX)
d963 1
d966 2
a967 1
		if (seconds_due == LINUX_TIME_MAX)
d969 1
@


1.91
log
@Delete procfs; it's always had races and is now unused: no one noticed for
months that I broke it before the 5.5 release.

confirmed as not being required by ports by sthen@@, ajacoutot@@, dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.90 2014/06/28 21:20:19 matthew Exp $	*/
d813 2
a814 2
	if (SCARG(cma, prot) & VM_PROT_WRITE) /* XXX */
		SCARG(cma, prot) |= VM_PROT_READ;
@


1.90
log
@Don't use meaningless MAP_TRYFIXED flag in compat_linux

Pointed out by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.89 2014/03/30 21:54:49 guenther Exp $	*/
a418 2
	else if (!strcmp(bsp->f_fstypename, MOUNT_PROCFS))
		lsp->l_ftype = LINUX_FSTYPE_PROCFS;
a498 2
	else if (!strcmp(bsp->f_fstypename, MOUNT_PROCFS))
		lsp->l_ftype = LINUX_FSTYPE_PROCFS;
@


1.89
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.88 2014/03/26 05:23:42 guenther Exp $	*/
d806 1
a806 1
	int flags = MAP_TRYFIXED, fl = SCARG(uap, flags);
@


1.88
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.87 2014/03/24 03:48:00 guenther Exp $	*/
d1487 1
a1487 1
	 if (p->p_cred->p_ruid != uid)
d1545 1
a1545 1
	*retval = p->p_cred->p_ruid;
d1556 1
a1556 1
	*retval = p->p_cred->p_rgid;
@


1.87
log
@The kernel isn't involved in times(3); <sys/times.h> should never be
included there
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.86 2014/02/12 05:47:36 guenther Exp $	*/
d466 1
a466 1
	sg = stackgap_init(p->p_emul);
d542 1
a542 1
	sg = stackgap_init(p->p_emul);
d577 1
a577 1
	sg = stackgap_init(p->p_emul);
d607 1
a607 1
	sg = stackgap_init(p->p_emul);
d1025 1
a1025 1
	sg = stackgap_init(p->p_emul);
d1311 1
a1311 1
		sg = stackgap_init(p->p_emul);
@


1.86
log
@Eliminate the exit sig handling, which was only invokable via the
Linux-compat clone() syscall when *not* using CLONE_THREAD.  pirofti@@
confirms Opera runs in compat without this, so out it goes; one less hair
to choke on in kern_exit.c

ok tedu@@ pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.85 2014/01/23 04:11:46 tedu Exp $	*/
a60 1
#include <sys/times.h>
@


1.85
log
@adjust a comment or two
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.84 2013/12/08 03:30:01 brad Exp $	*/
d175 1
a175 2
	if (linux_options &
	    ~(LINUX_WAIT4_WNOHANG|LINUX_WAIT4_WUNTRACED|LINUX_WAIT4_WCLONE))
a181 2
	if (linux_options & LINUX_WAIT4_WCLONE)
		options |= WALTSIG;
@


1.84
log
@Remove unsigned comparison < 0.

Pointed out by LLVM.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.83 2013/10/25 05:10:03 guenther Exp $	*/
d1226 1
a1226 1
 * into a structure, because there are 5, and that can all be handled
d1679 2
a1680 1
		 /* Ignore requests to keep the effective and permitted
@


1.83
log
@Unimplement stime() and settimeofday(): why are you using a Linux-compat
binary to change the system time?

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.82 2013/10/25 04:51:39 guenther Exp $	*/
d1660 1
a1660 1
		if (SCARG(uap, arg2) < 0 || SCARG(uap, arg2) >= LINUX__NSIG)
@


1.82
log
@Start to deal with the time_t change's effect on compat/linux:
 - add Linux versions of struct rusage, timeval, and itimerval and
   conversion functions for them
 - add Linux versions of getrusage(), gettimeofday(), {set,get}itimer(),
   and nanosleep()
 - fix various inconsistencies in naming of Linux versions of types
   and conversion functions
 - add mappings for LINUX_CLOCK_{PROCESS,THREAD}_CPUTIME_ID to the
   native versions

Originally written months ago as part of the time_t work; long
memory, prodding, and ok from pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.81 2013/08/13 05:52:21 guenther Exp $	*/
a1521 27
}

int
linux_sys_stime(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_time_args /* {
		linux_time_t *t;
	} */ *uap = v;
	struct timespec ats;
	linux_time_t tt;
	int error;

	if ((error = suser(p, 0)) != 0)
		return (error);

	if ((error = copyin(SCARG(uap, t), &tt, sizeof(tt))) != 0)
		return (error);

	ats.tv_sec = tt;
	ats.tv_nsec = 0;

	error = settime(&ats);

	return (error);
@


1.81
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.80 2013/05/10 10:31:16 pirofti Exp $	*/
d73 1
d87 2
a88 1
static void bsd_to_linux_statfs(struct statfs *, struct linux_statfs *);
d90 7
a96 4
     fd_set *, fd_set *, struct timeval *);
static int getdents_common(struct proc *, void *, register_t *, int);
static void linux_to_bsd_mmap_args(struct sys_mmap_args *,
    const struct linux_sys_mmap2_args *);
d117 14
d155 2
a156 3
 * wait4(2). Passed on to the OpenBSD call, surrounded by code to reserve
 * some space for an OpenBSD-style wait status, and converting it to what
 * Linux wants.
d168 1
a168 1
		syscallarg(struct rusage *) rusage;
d170 2
a171 9
	struct sys_wait4_args w4a;
	int error, *status, tstat, linux_options, options;
	caddr_t sg;

	if (SCARG(uap, status) != NULL) {
		sg = stackgap_init(p->p_emul);
		status = (int *) stackgap_alloc(&sg, sizeof *status);
	} else
		status = NULL;
d186 3
a188 6
	SCARG(&w4a, pid) = SCARG(uap, pid);
	SCARG(&w4a, status) = status;
	SCARG(&w4a, options) = options;
	SCARG(&w4a, rusage) = SCARG(uap, rusage);

	if ((error = sys_wait4(p, &w4a, retval)))
d193 5
a197 2
	if (status != NULL) {
		if ((error = copyin(status, &tstat, sizeof tstat)))
d199 4
a202 3

		bsd_to_linux_wstat(&tstat);
		return copyout(&tstat, SCARG(uap, status), sizeof tstat);
d208 27
d407 2
a408 2
static void
bsd_to_linux_statfs(struct statfs *bsp, struct linux_statfs *lsp)
d489 2
a490 2
static void
bsd_to_linux_statfs64(struct statfs *bsp, struct linux_statfs64 *lsp)
d805 1
a805 1
static void
d895 1
a895 1
		syscallarg(struct times *) tms;
d1177 1
a1177 1
static int
d1264 1
a1264 1
		syscallarg(struct timeval *) timeout;
d1278 2
a1279 6
linux_select1(p, retval, nfds, readfds, writefds, exceptfds, timeout)
	struct proc *p;
	register_t *retval;
	int nfds;
	fd_set *readfds, *writefds, *exceptfds;
	struct timeval *timeout;
d1282 1
a1290 1
	SCARG(&bsa, tv) = timeout;
d1297 1
a1297 1
		if ((error = copyin(timeout, &utv, sizeof(utv))))
d1299 1
a1304 2
			sg = stackgap_init(p->p_emul);
			tvp = stackgap_alloc(&sg, sizeof(utv));
a1312 3
			if ((error = copyout(&utv, tvp, sizeof(utv))))
				return error;
			SCARG(&bsa, tv) = tvp;
d1314 6
d1321 2
a1322 1
	}
d1332 2
a1333 1
		return error;
d1351 2
a1352 1
		if ((error = copyout(&utv, timeout, sizeof(utv))))
d1356 1
a1356 1
	return 0;
@


1.80
log
@compat_linux: Add support for future time_t and ino_t size enlargements.

Reviewed by guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.79 2012/06/08 14:28:23 pirofti Exp $	*/
d1052 1
a1052 1
int linux_readdir_callback(void *, struct dirent *, off_t);
d1062 1
a1062 1
linux_readdir_callback(arg, bdp, cookie)
a1064 1
	off_t cookie;
d1084 1
a1084 1
		idb64.d_off = (linux_off64_t)cookie;
d1101 1
a1101 1
			idb.d_off = (linux_off_t)cookie;
@


1.79
log
@Remove the lack of gettid() implementation. Okay tedu@@

Looks right to jasper@@ as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.78 2012/05/23 19:47:02 pirofti Exp $	*/
d352 3
a354 1
	tt = atv.tv_sec;
d860 1
a863 2
	ltms.ltms_utime = CONVTCK(ut);
	ltms.ltms_stime = CONVTCK(st);
d865 19
a883 2
	ltms.ltms_cutime = CONVTCK(p->p_p->ps_cru.ru_utime);
	ltms.ltms_cstime = CONVTCK(p->p_p->ps_cru.ru_stime);
d912 1
d929 9
a937 3
	retval[0] = itp->it_value.tv_sec;
	if (itp->it_value.tv_usec)
		retval[0]++;
d1091 2
d1572 3
a1574 1
	si.uptime = tv.tv_sec;
@


1.78
log
@Add emulation support for fstatfs64.

Okay matthew@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.77 2012/05/23 11:08:57 pirofti Exp $	*/
d1493 7
@


1.77
log
@Add support for statfs64.

While at it get rid of some magic numbers and add support for more
filesystem types (like NTFS, AFS etc.).

Suggestions and feedback from ajacoutot@@, jsing@@ and matthew@@.

Okay matthew@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.76 2012/04/22 05:43:14 guenther Exp $	*/
d557 29
@


1.76
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.75 2012/04/10 15:50:52 guenther Exp $	*/
d367 1
a367 3
bsd_to_linux_statfs(bsp, lsp)
	struct statfs *bsp;
	struct linux_statfs *lsp;
d377 1
a377 1
		lsp->l_ftype = 0x11954;
d379 1
a379 1
		lsp->l_ftype = 0x6969;
d381 1
a381 1
		lsp->l_ftype = 0x4d44;
d383 1
a383 1
		lsp->l_ftype = 0x9fa0;
d385 1
a385 1
		lsp->l_ftype = 0xef53;
d387 1
a387 1
		lsp->l_ftype = 0x9660;
d389 7
a395 1
		lsp->l_ftype = 0x6969;
d444 76
@


1.75
log
@Make the KERN_NPROCS and KERN_MAXPROC sysctl()s and the RLIMIT_NPROC rlimit
count processes instead of threads.  New sysctl()s KERN_NTHREADS and
KERN_MAXTHREAD count and limit threads.  The nprocs and maxproc kernel
variables are replaced by nprocess, maxprocess, nthreads, and maxthread.

ok tedu@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.74 2012/03/23 15:51:26 guenther Exp $	*/
d1026 1
a1026 1
			FRELE(fp);
d1046 1
a1046 1
	FRELE(fp);
@


1.74
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.73 2011/12/14 08:33:18 robert Exp $	*/
d1440 1
a1440 1
	si.procs = nprocs;
@


1.73
log
@implement prctl() for COMPAT_LINUX

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.72 2011/07/09 00:10:52 deraadt Exp $	*/
d747 1
a747 1
	struct timeval t;
a748 1
	struct rusage ru;
d751 3
a753 3
	calcru(p, &ru.ru_utime, &ru.ru_stime, NULL);
	ltms.ltms_utime = CONVTCK(ru.ru_utime);
	ltms.ltms_stime = CONVTCK(ru.ru_stime);
d755 2
a756 2
	ltms.ltms_cutime = CONVTCK(p->p_stats->p_cru.ru_utime);
	ltms.ltms_cstime = CONVTCK(p->p_stats->p_cru.ru_stime);
d780 1
a780 1
	int s;
d783 1
d786 2
a787 1
	itp = &p->p_realtimer;
d793 1
a793 1
	timeout_del(&p->p_realit_to);
d820 1
a820 1
	if (itimerfix(&it.it_value) || itimerfix(&it.it_interval)) {
d828 1
a828 1
		timeout_add(&p->p_realit_to, timo);
d830 1
a830 1
	p->p_realtimer = it;
@


1.72
log
@Remove COMPAT_25.  The one piece moved by COMPAT_LINUX moves there.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.71 2011/07/08 19:19:20 tedu Exp $	*/
d1483 82
@


1.71
log
@remove all traces of COMPAT_09 and COMPAT_10. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.70 2011/07/08 05:01:27 matthew Exp $	*/
d54 1
d1469 14
@


1.70
log
@Remove the sys_opipe() kernel entry point.  sys_pipe() is the future.

While here, switch compat_linux to just use sys_pipe() rather than
incorrectly wrapping sys_opipe().

ok tedu@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.69 2011/07/07 01:19:39 tedu Exp $	*/
d1455 13
@


1.69
log
@remove all the old COMPAT_43 syscalls.  The option itself remains for
the other things it enables.  Move a few old wrappers into linux compat
where they are still being used.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.68 2011/06/05 19:41:09 deraadt Exp $	*/
a763 46
	return 0;
}

/*
 * OpenBSD passes fd[0] in retval[0], and fd[1] in retval[1].
 * Linux directly passes the pointer.
 */
int
linux_sys_pipe(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_pipe_args /* {
		syscallarg(int *) pfds;
	} */ *uap = v;
	int error;
	int pfds[2];
#ifdef __i386__
	int reg_edx = retval[1];
#endif /* __i386__ */

	if ((error = sys_opipe(p, 0, retval))) {
#ifdef __i386__
		retval[1] = reg_edx;
#endif /* __i386__ */
		return error;
	}

	/* Assumes register_t is an int */

	pfds[0] = retval[0];
	pfds[1] = retval[1];
	if ((error = copyout(pfds, SCARG(uap, pfds), 2 * sizeof (int)))) {
#ifdef __i386__
		retval[1] = reg_edx;
#endif /* __i386__ */
		fdrelease(p, retval[0]);
		fdrelease(p, retval[1]);
		return error;
	}

	retval[0] = 0;
#ifdef __i386__
	retval[1] = reg_edx;
#endif /* __i386__ */
@


1.68
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.67 2011/04/05 15:36:09 pirofti Exp $	*/
d58 1
d568 14
@


1.67
log
@Fix PID fetching -- noticed last night by guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.66 2011/02/11 21:40:04 pirofti Exp $	*/
d1454 1
a1454 1
	extern int bufpages;
@


1.66
log
@Add linux_mprotect() syscall. Okay otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.65 2010/07/26 01:56:27 guenther Exp $	*/
d1228 1
a1228 1
	if (SCARG(uap, pid) != 0 && SCARG(uap, pid) != p->p_pid) {
d1412 1
a1412 1
	*retval = p->p_pid;
@


1.65
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.64 2010/06/30 21:54:35 guenther Exp $	*/
d1476 10
@


1.64
log
@Merge from NetBSD: "Linux's getsid(2) does in fact return a pid,
not a pointer."  So just use the native implementation.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.63 2009/09/05 10:28:43 miod Exp $	*/
d1226 1
a1226 1
	struct proc *targp;
d1229 1
a1229 1
		if ((targp = pfind(SCARG(uap, pid))) == 0)
d1233 1
a1233 1
		targp = p;
d1235 1
a1235 1
	retval[0] = targp->p_pgid;
@


1.63
log
@Fix various cases of stackgap_alloc() size arguments not being computed
correctly, usually yielding the right value on 32 bit machines because
sizeof int == sizeof pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.62 2008/06/26 05:42:14 ray Exp $	*/
a1301 27
}

int
linux_sys_getsid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_getsid_args /* {
		syscallarg(int) pid;
	} */ *uap = v;
	struct proc *p1;
	pid_t pid;

	pid = (pid_t)SCARG(uap, pid);

	if (pid == 0) {
		retval[0] = (int)p->p_session;	/* XXX Oh well */
		return 0;
	}

	p1 = pfind((int)pid);
	if (p1 == NULL)
		return ESRCH;

	retval[0] = (int)p1->p_session;
	return 0;
@


1.62
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.61 2007/09/01 15:14:44 martin Exp $	*/
d156 1
a156 1
		status = (int *) stackgap_alloc(&sg, sizeof status);
@


1.61
log
@replace the machine dependant bytes-to-clicks macro by the MI ptoa()
version for i386

more architectures and ctob() replacement is being worked on

prodded by and ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.60 2007/02/06 18:42:37 art Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.60
log
@Use atomic.h operation for manipulating p_siglist in struct proc. Solves
the problem with lost signals in MP kernels.

miod@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.59 2006/10/08 19:49:57 sturm Exp $	*/
d1497 1
a1497 1
	si.totalram = ctob(physmem);
@


1.59
log
@Pass linux_sys_waitpid() on to linux_sys_wait4() in order to properly
check and translate options. from netbsd

ok deraadt, kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.58 2005/02/17 18:07:36 jfb Exp $	*/
d188 1
a188 1
	p->p_siglist &= ~sigmask(SIGCHLD);
@


1.58
log
@miscellaneous typo fixes:
- sturct -> struct (spotted by pedro)
- elimination of consecutive 'the' words

ok jmc@@, henning@@, krw@@, robert@@, some whining by jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.57 2004/06/24 19:35:23 tholo Exp $	*/
d117 1
a117 3
 * waitpid(2). Passed on to the OpenBSD call, surrounded by code to
 * reserve some space for a OpenBSD-style wait status, and converting
 * it to what Linux wants.
d130 1
a130 27
	struct sys_wait4_args w4a;
	int error, *status, tstat;
	caddr_t sg;

	if (SCARG(uap, status) != NULL) {
		sg = stackgap_init(p->p_emul);
		status = (int *) stackgap_alloc(&sg, sizeof status);
	} else
		status = NULL;

	SCARG(&w4a, pid) = SCARG(uap, pid);
	SCARG(&w4a, status) = status;
	SCARG(&w4a, options) = SCARG(uap, options);
	SCARG(&w4a, rusage) = NULL;

	if ((error = sys_wait4(p, &w4a, retval)))
		return error;

	p->p_siglist &= ~sigmask(SIGCHLD);

	if (status != NULL) {
		if ((error = copyin(status, &tstat, sizeof tstat)))
			return error;

		bsd_to_linux_wstat(&tstat);
		return copyout(&tstat, SCARG(uap, status), sizeof tstat);
	}
d132 6
a137 1
	return 0;
d141 3
a143 1
 * This is very much the same as waitpid()
@


1.57
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.56 2004/06/22 23:52:18 jfb Exp $	*/
d530 1
a530 1
	/* This part taken from the the uname() in libc */
d559 1
a559 1
	/* This part taken from the the uname() in libc */
d588 1
a588 1
	/* This part taken from the the uname() in libc */
@


1.56
log
@Replace a whole bunch of scary uses of strncpy() with strlcpy() and
use compat-specific MAXNAMLEN values where appropriate

ok millert@@, pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.55 2003/12/02 03:46:45 nordin Exp $	*/
d762 1
a762 1
	int error, s;
d774 1
a774 3
	s = splclock();
	timersub(&time, &boottime, &t);
	splx(s);
d841 1
d849 1
a849 1

d853 2
a854 2
	    timercmp(&itp->it_value, &time, >))
		timersub(&itp->it_value, &time, &itp->it_value);
d884 1
a884 3
		if (timo <= 0)
			timo = 1;
		timeradd(&it.it_value, &time, &it.it_value);
d1442 1
a1442 1
	struct timeval atv;
d1452 2
a1453 2
	atv.tv_sec = tt;
	atv.tv_usec = 0;
d1455 1
a1455 1
	error = settime(&atv);
d1510 1
d1512 2
a1513 2

	si.uptime = time.tv_sec - boottime.tv_sec;
@


1.55
log
@Count from now, not from the epoch, to arm alarm.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.54 2003/08/15 20:32:16 tedu Exp $	*/
d523 6
a528 12
	strncpy(luts.l_sysname, ostype, sizeof(luts.l_sysname) - 1);
	luts.l_sysname[sizeof(luts.l_sysname) - 1] = '\0';
	strncpy(luts.l_nodename, hostname, sizeof(luts.l_nodename) - 1);
	luts.l_nodename[sizeof(luts.l_nodename) - 1] = '\0';
	strncpy(luts.l_release, osrelease, sizeof(luts.l_release) - 1);
	luts.l_release[sizeof(luts.l_release) - 1] = '\0';
	strncpy(luts.l_version, version, sizeof(luts.l_version) - 1);
	luts.l_version[sizeof(luts.l_version) - 1] = '\0';
	strncpy(luts.l_machine, machine, sizeof(luts.l_machine) - 1);
	luts.l_machine[sizeof(luts.l_machine) - 1] = '\0';
	strncpy(luts.l_domainname, domainname, sizeof(luts.l_domainname) - 1);
	luts.l_domainname[sizeof(luts.l_domainname) - 1] = '\0';
d553 5
a557 5
	strncpy(luts.l_sysname, ostype, sizeof(luts.l_sysname));
	strncpy(luts.l_nodename, hostname, sizeof(luts.l_nodename));
	strncpy(luts.l_release, osrelease, sizeof(luts.l_release));
	strncpy(luts.l_version, version, sizeof(luts.l_version));
	strncpy(luts.l_machine, machine, sizeof(luts.l_machine));
d582 5
a586 5
	strncpy(luts.l_sysname, ostype, sizeof(luts.l_sysname));
	strncpy(luts.l_nodename, hostname, sizeof(luts.l_nodename));
	strncpy(luts.l_release, osrelease, sizeof(luts.l_release));
	strncpy(luts.l_version, version, sizeof(luts.l_version));
	strncpy(luts.l_machine, machine, sizeof(luts.l_machine));
@


1.54
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.53 2003/08/15 14:02:22 fgsch Exp $	*/
d890 1
a890 1
		timo = hzto(&it.it_value);
@


1.53
log
@simplify.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.51 2003/07/23 17:42:09 tedu Exp $	*/
d1455 1
a1455 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.52
log
@unbust my previous commit.
@
text
@a1539 6

int
linux_sys_exit_group(struct proc *p, void *v, register_t *retval)
{
	return (sys_exit(p, v, retval));
}
@


1.51
log
@add sys_sysinfo.  from marius aamodt eriksen.
linux_misc.c: fvdl gave his copyright to tnf, adjust.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.50 2003/07/03 00:00:04 tedu Exp $	*/
d1539 6
@


1.50
log
@add mmap2 (mmap64, take your pick) and clean up some.  use MAP_TRYFIXED
since that's the way linux works.  no regressions by various ports testers,
eyeballed by a few others.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.49 2003/06/21 00:42:58 tedu Exp $	*/
d4 2
a5 2
/*
 * Copyright (c) 1995 Frank van der Linden
d8 4
d22 5
a26 4
 *      This product includes software developed for the NetBSD Project
 *      by Frank van der Linden
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
d28 11
a38 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
d1500 39
@


1.49
log
@add exec/fork/exit hooks per process for compat emulations.
use them to correctly emulate linux brk.
update to TNF copyright in linux_exec.c.

from netbsd, mostly from a diff by Kurt Miller in pr3318.
this should fix java.  no regressions in testing by kurt and sturm@@.
be prepared for "proc size mismatch" -- recompile ps and friends.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.48 2003/01/30 03:29:49 millert Exp $	*/
d89 2
d612 1
d614 1
a614 1
	int error, flags;
d619 44
a662 15
	flags = 0;
	flags |= cvtto_bsd_mask(lmap.lm_flags, LINUX_MAP_SHARED, MAP_SHARED);
	flags |= cvtto_bsd_mask(lmap.lm_flags, LINUX_MAP_PRIVATE, MAP_PRIVATE);
	flags |= cvtto_bsd_mask(lmap.lm_flags, LINUX_MAP_FIXED, MAP_FIXED);
	flags |= cvtto_bsd_mask(lmap.lm_flags, LINUX_MAP_ANON, MAP_ANON);

	SCARG(&cma,addr) = lmap.lm_addr;
	SCARG(&cma,len) = lmap.lm_len;
	if (lmap.lm_prot & VM_PROT_WRITE)	/* XXX */
		lmap.lm_prot |= VM_PROT_READ;
 	SCARG(&cma,prot) = lmap.lm_prot;
	SCARG(&cma,flags) = flags;
	SCARG(&cma,fd) = flags & MAP_ANON ? -1 : lmap.lm_fd;
	SCARG(&cma,pad) = 0;
	SCARG(&cma,pos) = lmap.lm_pos;
d665 23
@


1.48
log
@Bring back setreuid(2) and setregid(2) as first class syscalls
(but still implemented via setres[ug]id(2)).  Basically this just
moves them from COMPAT_43 into kern_prot.c.  Also fixes a typo in my
old implementation.  The userland portion will follow in a few days.
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.47 2002/10/30 20:10:48 millert Exp $	*/
d80 1
d337 1
a337 1
	caddr_t oldbrk;
a338 7
	oldbrk = vm->vm_daddr + ctob(vm->vm_dsize);
	/*
	 * XXX inconsistent.. Linux always returns at least the old
	 * brk value, but it will be page-aligned if this fails,
	 * and possibly not page aligned if it succeeds (the user
	 * supplied pointer is returned).
	 */
d342 1
a342 1
		retval[0] = (register_t)nbrk;
d344 3
a346 1
		retval[0] = (register_t)oldbrk;
@


1.47
log
@Now that we have [gs]etres[ug]id() as a native system call, use it
for HP-UX, FreeBSD, and Linux emulations.  Note that Linux has two
versions of these system calls.  One for 16bit uids and another for
32bit uids.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.46 2002/10/28 03:39:30 fgsch Exp $	*/
d1254 1
a1254 1
	struct compat_43_sys_setreuid_args bsa;
d1261 1
a1261 1
	return compat_43_sys_setreuid(p, &bsa, retval);
d1274 1
a1274 1
	struct compat_43_sys_setregid_args bsa;
d1281 1
a1281 1
	return compat_43_sys_setregid(p, &bsa, retval);
@


1.46
log
@getdents64 support, based on FreeBSD.
thanks to jpmk@@fibertel.com.ar for providing a testbed; jasoni ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.44 2002/07/25 22:18:27 nordin Exp $	*/
d220 3
a222 3
		syscallarg(gid_t) rgid;
		syscallarg(gid_t) egid;
		syscallarg(gid_t) sgid;
d224 2
a225 3
	struct pcred *pc = p->p_cred;
	gid_t rgid, egid, sgid;
	int error;
d228 1
d230 1
d232 1
d234 2
a235 11
	/*
	 * Note: These checks are a little different than the OpenBSD
	 * setregid(2) call performs.  This precisely follows the
	 * behavior of the Linux kernel.
	 */
	if (rgid != (gid_t)-1 &&
	    rgid != pc->p_rgid &&
	    rgid != pc->pc_ucred->cr_gid &&
	    rgid != pc->p_svgid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);
d237 12
a248 6
	if (egid != (gid_t)-1 &&
	    egid != pc->p_rgid &&
	    egid != pc->pc_ucred->cr_gid &&
	    egid != pc->p_svgid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);
d250 3
a252 6
	if (sgid != (gid_t)-1 &&
	    sgid != pc->p_rgid &&
	    sgid != pc->pc_ucred->cr_gid &&
	    sgid != pc->p_svgid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);
d254 2
a255 8
	/*
	 * Now assign the real, effective, and saved GIDs.
	 * Note that Linux, unlike OpenBSD in setregid(2), does not
	 * set the saved UID in this call unless the user specifies
	 * it.
	 */
	if (rgid != (gid_t)-1)
		pc->p_rgid = rgid;
d257 13
a269 4
	if (egid != (gid_t)-1) {
		pc->pc_ucred = crcopy(pc->pc_ucred);
		pc->pc_ucred->cr_gid = egid;
	}
d271 6
a276 2
	if (sgid != (gid_t)-1)
		pc->p_svgid = sgid;
d278 1
a278 3
	if (rgid != (gid_t)-1 && egid != (gid_t)-1 && sgid != (gid_t)-1)
		p->p_flag |= P_SUGID;
	return (0);
d282 1
a282 1
linux_sys_getresgid16(p, v, retval)
d287 4
a290 4
	struct linux_sys_getresgid16_args /* {
		syscallarg(gid_t *) rgid;
		syscallarg(gid_t *) egid;
		syscallarg(gid_t *) sgid;
d292 1
a292 13
	struct pcred *pc = p->p_cred;
	int error;

	/*
	 * Linux copies these values out to userspace like so:
	 *
	 *	1. Copy out rgid.
	 *	2. If that succeeds, copy out egid.
	 *	3. If both of those succeed, copy out sgid.
	 */
	if ((error = copyout(&pc->p_rgid, SCARG(uap, rgid),
			     sizeof(gid_t))) != 0)
		return (error);
d294 3
a296 3
	if ((error = copyout(&pc->pc_ucred->cr_uid, SCARG(uap, egid),
			     sizeof(gid_t))) != 0)
		return (error);
d298 1
a298 1
	return (copyout(&pc->p_svgid, SCARG(uap, sgid), sizeof(gid_t)));
a1333 102
}

int
linux_sys_setresuid16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_setresuid16_args /* {
		syscallarg(uid_t) ruid;
		syscallarg(uid_t) euid;
		syscallarg(uid_t) suid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	uid_t ruid, euid, suid;
	int error;

	ruid = SCARG(uap, ruid);
	euid = SCARG(uap, euid);
	suid = SCARG(uap, suid);

	/*
	 * Note: These checks are a little different than the OpenBSD
	 * setreuid(2) call performs.  This precisely follows the
	 * behavior of the Linux kernel.
	 */
	if (ruid != (uid_t)-1 &&
	    ruid != pc->p_ruid &&
	    ruid != pc->pc_ucred->cr_uid &&
	    ruid != pc->p_svuid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (euid != (uid_t)-1 &&
	    euid != pc->p_ruid &&
	    euid != pc->pc_ucred->cr_uid &&
	    euid != pc->p_svuid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (suid != (uid_t)-1 &&
	    suid != pc->p_ruid &&
	    suid != pc->pc_ucred->cr_uid &&
	    suid != pc->p_svuid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	/*
	 * Now assign the new real, effective, and saved UIDs.
	 * Note that Linux, unlike OpenBSD in setreuid(2), does not
	 * set the saved UID in this call unless the user specifies
	 * it.
	 */
	if (ruid != (uid_t)-1) {
		(void)chgproccnt(pc->p_ruid, -1);
		(void)chgproccnt(ruid, 1);
		pc->p_ruid = ruid;
	}

	if (euid != (uid_t)-1) {
		pc->pc_ucred = crcopy(pc->pc_ucred);
		pc->pc_ucred->cr_uid = euid;
	}

	if (suid != (uid_t)-1)
		pc->p_svuid = suid;

	if (ruid != (uid_t)-1 && euid != (uid_t)-1 && suid != (uid_t)-1)
		p->p_flag |= P_SUGID;
	return (0);
}

int
linux_sys_getresuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_getresuid_args /* {
		syscallarg(uid_t *) ruid;
		syscallarg(uid_t *) euid;
		syscallarg(uid_t *) suid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	int error;

	/*
	 * Linux copies these values out to userspace like so:
	 *
	 *	1. Copy out ruid.
	 *	2. If that succeeds, copy out euid.
	 *	3. If both of those succeed, copy out suid.
	 */
	if ((error = copyout(&pc->p_ruid, SCARG(uap, ruid),
			     sizeof(uid_t))) != 0)
		return (error);

	if ((error = copyout(&pc->pc_ucred->cr_uid, SCARG(uap, euid),
			     sizeof(uid_t))) != 0)
		return (error);

	return (copyout(&pc->p_svuid, SCARG(uap, suid), sizeof(uid_t)));
@


1.45
log
@Cleanup change. Since almost all callers (except one) of getvnode did a FREF
on the returned file, do the FREF inside getvnode so that people can't
get away with avoiding FREF and FRELE.

Eyeballed by various people.
@
text
@d87 1
d944 1
d953 1
d962 4
a965 1
	linux_reclen = LINUX_RECLEN(&idb, bdp->d_namlen);
d969 7
a975 13
	/*
	 * Massage in place to make a Linux-shaped dirent (otherwise
	 * we have to worry about touching user memory outside of
	 * the copyout() call).
	 */
	idb.d_ino = (linux_ino_t)bdp->d_fileno;
	
	/*
	 * The old readdir() call misuses the offset and reclen fields.
	 */
	if (cb->oldcall) {
		idb.d_off = (linux_off_t)linux_reclen;
		idb.d_reclen = (u_short)bdp->d_namlen;
d977 14
a990 2
		idb.d_off = (linux_off_t)cookie;
		idb.d_reclen = (u_short)linux_reclen;
d992 1
a992 3
	
	strlcpy(idb.d_name, bdp->d_name, sizeof(idb.d_name));
	if ((error = copyout((caddr_t)&idb, cb->outp, linux_reclen)))
d1006 9
d1020 10
d1044 5
d1057 1
@


1.44
log
@Avoid time wrap at securelevel 2. ok millert@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.43 2002/06/05 19:43:25 jasoni Exp $	*/
a1023 1
	FREF(fp);
@


1.43
log
@provide local versions of getpid, getuid and getgid that do not
stuff a value in retval[1] as newer linux libs puke on it.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.42 2002/03/14 20:31:31 mickey Exp $	*/
d1486 1
a1486 1
	settime(&atv);
d1488 1
a1488 1
	return 0;
@


1.42
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.41 2002/03/14 01:26:50 millert Exp $	*/
d1489 33
@


1.41
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.40 2002/02/12 18:41:20 art Exp $	*/
d524 1
a524 2
	extern char ostype[], hostname[], osrelease[], version[], machine[],
	    domainname[];
d560 1
a560 1
	extern char ostype[], hostname[], osrelease[], version[], machine[];
d589 1
a589 1
	extern char ostype[], hostname[], osrelease[], version[], machine[];
@


1.40
log
@More FREF/FRELE protection. This time all users of getvnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.39 2001/11/06 19:53:17 miod Exp $	*/
d84 3
a86 3
static void bsd_to_linux_statfs __P((struct statfs *, struct linux_statfs *));
int	linux_select1 __P((struct proc *, register_t *, int, fd_set *,
     fd_set *, fd_set *, struct timeval *));
d938 1
a938 1
int linux_readdir_callback __P((void *, struct dirent *, off_t));
@


1.39
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.38 2001/08/12 20:33:50 mickey Exp $	*/
d1025 1
d1033 1
@


1.39.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.39 2001/11/06 19:53:17 miod Exp $	*/
d84 3
a86 3
static void bsd_to_linux_statfs(struct statfs *, struct linux_statfs *);
int	linux_select1(struct proc *, register_t *, int, fd_set *,
     fd_set *, fd_set *, struct timeval *);
d524 2
a525 1
	extern char hostname[], machine[], domainname[];
d561 1
a561 1
	extern char hostname[], machine[];
d590 1
a590 1
	extern char hostname[], machine[];
d938 1
a938 1
int linux_readdir_callback(void *, struct dirent *, off_t);
a1024 1
	FREF(fp);
a1031 1
	FRELE(fp);
a1487 33
}

int
linux_sys_getpid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	*retval = p->p_pid;
	return (0);
}

int
linux_sys_getuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	*retval = p->p_cred->p_ruid;
	return (0);
}

int
linux_sys_getgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	*retval = p->p_cred->p_rgid;
	return (0);
@


1.39.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.39.2.1 2002/06/11 03:28:08 art Exp $	*/
a86 1
static int getdents_common(struct proc *, void *, register_t *, int);
a942 1
	int	is64bit;
a950 1
	struct linux_dirent64 idb64;
d959 1
a959 4
	linux_reclen = (cb->is64bit) ?
	     LINUX_RECLEN(&idb64, bdp->d_namlen) :
	     LINUX_RECLEN(&idb, bdp->d_namlen);

d963 13
a975 7
	if (cb->is64bit) {
		idb64.d_ino = (linux_ino64_t)bdp->d_fileno;
		idb64.d_off = (linux_off64_t)cookie;
		idb64.d_reclen = (u_short)linux_reclen;
		idb64.d_type = bdp->d_type;
		strlcpy(idb64.d_name, bdp->d_name, sizeof(idb64.d_name));
		error = copyout((caddr_t)&idb64, cb->outp, linux_reclen);
d977 2
a978 14
		idb.d_ino = (linux_ino_t)bdp->d_fileno;
		if (cb->oldcall) {
			/*
			 * The old readdir() call misuses the offset
			 * and reclen fields.
			 */
			idb.d_off = (linux_off_t)linux_reclen;
			idb.d_reclen = (u_short)bdp->d_namlen;
		} else {
			idb.d_off = (linux_off_t)cookie;
			idb.d_reclen = (u_short)linux_reclen;
		}
		strlcpy(idb.d_name, bdp->d_name, sizeof(idb.d_name));
		error = copyout((caddr_t)&idb, cb->outp, linux_reclen);
d980 3
a982 1
	if (error)
a995 9
linux_sys_getdents64(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	return getdents_common(p, v, retval, 1);
}

int
a1000 10
	return getdents_common(p, v, retval, 0);
}

static int
getdents_common(p, v, retval, is64bit)
	struct proc *p;
	void *v;
	register_t *retval;
	int is64bit;
{
a1014 5
		/* readdir(2) case. Always struct dirent. */
		if (is64bit) {
			FRELE(fp);
			return (EINVAL);
		}
a1022 1
	args.is64bit = is64bit;
d1024 1
d1486 1
a1486 1
	error = settime(&atv);
d1488 1
a1488 1
	return (error);
@


1.39.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d220 3
a222 3
		syscallarg(u_int16_t) rgid;
		syscallarg(u_int16_t) egid;
		syscallarg(u_int16_t) sgid;
d224 3
a226 2
	struct sys_setresgid_args nuap;
	u_int16_t rgid, egid, sgid;
a228 1
	SCARG(&nuap, rgid) = (rgid == (u_int16_t)-1) ? (gid_t)-1 : rgid;
a229 1
	SCARG(&nuap, egid) = (egid == (u_int16_t)-1) ? (gid_t)-1 : egid;
a230 1
	SCARG(&nuap, sgid) = (sgid == (u_int16_t)-1) ? (gid_t)-1 : sgid;
d232 11
a242 2
	return sys_setresgid(p, &nuap, retval);
}
d244 6
a249 12
int
linux_sys_getresgid16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_getresgid16_args /* {
		syscallarg(u_int16_t *) rgid;
		syscallarg(u_int16_t *) egid;
		syscallarg(u_int16_t *) sgid;
	} */ *uap = v;
	struct sys_getresgid_args nuap;
d251 6
a256 3
	SCARG(&nuap, rgid) = (gid_t *)SCARG(uap, rgid);
	SCARG(&nuap, egid) = (gid_t *)SCARG(uap, egid);
	SCARG(&nuap, sgid) = (gid_t *)SCARG(uap, sgid);
d258 8
a265 2
	return sys_getresgid(p, &nuap, retval);
}
d267 4
a270 13
int
linux_sys_setresuid16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_setresuid16_args /* {
		syscallarg(u_int16_t) ruid;
		syscallarg(u_int16_t) euid;
		syscallarg(u_int16_t) suid;
	} */ *uap = v;
	struct sys_setresuid_args nuap;
	u_int16_t ruid, euid, suid;
d272 2
a273 6
	ruid = SCARG(uap, ruid);
	SCARG(&nuap, ruid) = (ruid == (u_int16_t)-1) ? (uid_t)-1 : ruid;
	euid = SCARG(uap, euid);
	SCARG(&nuap, euid) = (euid == (u_int16_t)-1) ? (uid_t)-1 : euid;
	suid = SCARG(uap, suid);
	SCARG(&nuap, suid) = (suid == (u_int16_t)-1) ? (uid_t)-1 : suid;
d275 3
a277 1
	return sys_setresuid(p, &nuap, retval);
d281 1
a281 1
linux_sys_getresuid16(p, v, retval)
d286 4
a289 4
	struct linux_sys_getresuid16_args /* {
		syscallarg(u_int16_t *) ruid;
		syscallarg(u_int16_t *) euid;
		syscallarg(u_int16_t *) suid;
d291 13
a303 1
	struct sys_getresuid_args nuap;
d305 3
a307 3
	SCARG(&nuap, ruid) = (uid_t *)SCARG(uap, ruid);
	SCARG(&nuap, euid) = (uid_t *)SCARG(uap, euid);
	SCARG(&nuap, suid) = (uid_t *)SCARG(uap, suid);
d309 1
a309 1
	return sys_getresuid(p, &nuap, retval);
d1265 1
a1265 1
	struct sys_setreuid_args bsa;
d1272 1
a1272 1
	return sys_setreuid(p, &bsa, retval);
d1285 1
a1285 1
	struct sys_setregid_args bsa;
d1292 1
a1292 1
	return sys_setregid(p, &bsa, retval);
d1345 102
@


1.38
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.37 2001/07/03 21:56:26 jasoni Exp $	*/
d69 1
a69 1
#include <vm/vm.h>
@


1.37
log
@rename 2 more syscalls to syscallname16 (missed last time)
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.36 2001/07/03 15:32:34 jasoni Exp $	*/
a69 1
#include <vm/vm_param.h>
@


1.36
log
@rename some syscalls to <syscall>16 to make room for new ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.35 2001/04/02 21:43:11 niklas Exp $	*/
d214 1
a214 1
linux_sys_setresgid(p, v, retval)
d219 1
a219 1
	struct linux_sys_setresgid_args /* {
d281 1
a281 1
linux_sys_getresgid(p, v, retval)
d286 1
a286 1
	struct linux_sys_getresgid_args /* {
@


1.35
log
@On popular demand, the Linux-compatibility clone(2) implementation based
on NetBSD's code, as well as some faked Posix RT extensions by me.  This makes
at least simple linuxthreads tests work.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.34 2001/01/23 05:48:05 csapuntz Exp $	*/
d1222 1
a1222 1
linux_sys_setreuid(p, v, retval)
d1227 1
a1227 1
	struct linux_sys_setreuid_args /* {
d1242 1
a1242 1
linux_sys_setregid(p, v, retval)
d1247 1
a1247 1
	struct linux_sys_setregid_args /* {
d1314 1
a1314 1
linux_sys_setresuid(p, v, retval)
d1319 1
a1319 1
	struct linux_sys_setresuid_args /* {
@


1.34
log
@

SunOS, IBCS2, Linux, and SVR4 all require translations of directory entries
from OpenBSD format to their respective native formats.

A lot of common code here for interfacing with OpenBSD VOP_READDIR. Most
of this code and logic has been moved to common/compat_dir.c

When reading a portion of the directory, the compatibility layer registers
a callback which is passed an OpenBSD-style dirent and the cookie/offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.33 2000/09/10 07:04:20 jasoni Exp $	*/
d74 1
d76 1
a84 1
static void bsd_to_linux_wstat __P((int *));
d86 2
a87 2
int linux_select1 __P((struct proc *, register_t *, int, fd_set *, fd_set *,
		       fd_set *, struct timeval *));
d94 1
a94 1
static void
d170 1
a170 1
	int error, *status, tstat;
d179 13
d194 1
a194 1
	SCARG(&w4a, options) = SCARG(uap, options);
@


1.33
log
@Linux mmap ignores the fd argument when MAP_ANON is on.   Always pass -1
to the native mmap system call (in case the linux app doesn't).
- From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.32 2000/09/07 17:52:24 ericj Exp $	*/
d80 2
d907 1
d925 58
d989 1
a989 1
	struct linux_sys_readdir_args /* {
d991 2
a992 2
		syscallarg(caddr_t) dent;
		syscallarg(unsigned int) count;
d994 1
a994 6
	register struct dirent *bdp;
	struct vnode *vp;
	caddr_t	inp, buf;		/* BSD-format */
	int len, reclen;		/* BSD-format */
	caddr_t outp;			/* Linux-format */
	int resid, linux_reclen = 0;	/* Linux-format */
d996 2
a997 8
	struct uio auio;
	struct iovec aiov;
	struct linux_dirent idb;
	off_t off;		/* true file offset */
	int buflen, error, eofflag, nbytes, oldcall;
	struct vattr va;
	u_long *cookiebuf = NULL, *cookie;
	int ncookies = 0;
a1001 12
	if ((fp->f_flag & FREAD) == 0)
		return (EBADF);

	vp = (struct vnode *)fp->f_data;

	if (vp->v_type != VDIR)	/* XXX  vnode readdir op should do this */
		return (EINVAL);

	if ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)))
		return error;

	nbytes = SCARG(uap, count);
d1003 2
a1004 3
		nbytes = sizeof (struct linux_dirent);
		buflen = max(va.va_blocksize, nbytes);
		oldcall = 1;
d1006 1
a1006 2
		buflen = min(MAXBSIZE, nbytes);
		oldcall = 0;
a1007 47
	buf = malloc(buflen, M_TEMP, M_WAITOK);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	off = fp->f_offset;
again:
	aiov.iov_base = buf;
	aiov.iov_len = buflen;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_procp = p;
	auio.uio_resid = buflen;
	auio.uio_offset = off;
	/*
	 * First we read into the malloc'ed buffer, then
	 * we massage it into user space, one record at a time.
	 */
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, &ncookies,
	    &cookiebuf);
	if (error)
		goto out;

	if (!error && !cookiebuf)
		goto out;

	inp = buf;
	outp = SCARG(uap, dent);
	resid = nbytes;
	if ((len = buflen - auio.uio_resid) == 0)
		goto eof;

	for (cookie = cookiebuf; len > 0; len -= reclen) {
		bdp = (struct dirent *)inp;
		reclen = bdp->d_reclen;
		if (reclen & 3)
			panic("linux_readdir: bad reclen");
		if (bdp->d_fileno == 0) {
			inp += reclen;	/* it is a hole; squish it out */
			off = *cookie++;
			continue;
		}
		linux_reclen = LINUX_RECLEN(&idb, bdp->d_namlen);
		if (reclen > len || resid < linux_reclen) {
			/* entry too big for buffer, so just stop */
			outp++;
			break;
		}
d1009 6
a1014 6
		/*
		 * Massage in place to make a Linux-shaped dirent (otherwise
		 * we have to worry about touching user memory outside of
		 * the copyout() call).
		 */
		idb.d_ino = (linux_ino_t)bdp->d_fileno;
d1016 1
a1016 23
		/*
		 * The old readdir() call misuses the offset and reclen fields.
		 */
		if (oldcall) {
			idb.d_off = (linux_off_t)linux_reclen;
			idb.d_reclen = (u_short)bdp->d_namlen;
		} else {
			idb.d_off = (linux_off_t)off;
			idb.d_reclen = (u_short)linux_reclen;
		}
		strncpy(idb.d_name, bdp->d_name, sizeof(idb.d_name) - 1);
		idb.d_name[sizeof(idb.d_name) - 1] = '\0';
		if ((error = copyout((caddr_t)&idb, outp, linux_reclen)))
			goto out;
		/* advance past this real entry */
		inp += reclen;
		off = *cookie++;	/* each entry points to itself */
		/* advance output past Linux-shaped entry */
		outp += linux_reclen;
		resid -= linux_reclen;
		if (oldcall)
			break;
	}
d1018 2
a1019 16
	/* if we squished out the whole block, try again */
	if (outp == SCARG(uap, dent))
		goto again;
	fp->f_offset = off;	/* update the vnode offset */

	if (oldcall)
		nbytes = resid + linux_reclen;

eof:
	*retval = nbytes - resid;
out:
	VOP_UNLOCK(vp, 0, p);
	if (cookiebuf)
		free(cookiebuf, M_TEMP);
	free(buf, M_TEMP);
	return error;
@


1.32
log
@common/compat_util.c
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.31 2000/07/23 22:35:38 jasoni Exp $	*/
d628 1
a628 1
	SCARG(&cma,fd) = lmap.lm_fd;
@


1.31
log
@OpenBSD -> NetBSD where previously missed.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.30 2000/07/17 05:45:34 art Exp $	*/
d862 1
a872 1
		tvp = (struct timeval *) stackgap_alloc(&sg, sizeof(tv));
@


1.30
log
@Oops.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.29 2000/07/17 05:43:10 art Exp $	*/
d105 2
a106 2
 * waitpid(2). Passed on to the NetBSD call, surrounded by code to
 * reserve some space for a NetBSD-style wait status, and converting
d217 1
a217 1
	 * Note: These checks are a little different than the NetBSD
d244 1
a244 1
	 * Note that Linux, unlike NetBSD in setregid(2), does not
d317 1
a317 1
 * done in the kernel in Linux. NetBSD does it in the library.
d497 1
a497 1
 * is almost the same as the NetBSD one, only it has fields 65 characters
d728 1
a728 1
 * NetBSD passes fd[0] in retval[0], and fd[1] in retval[1].
d774 1
a774 1
 * Alarm. This is a libc call which uses setitimer(2) in NetBSD.
d1366 1
a1366 1
	 * Note: These checks are a little different than the NetBSD
d1393 1
a1393 1
	 * Note that Linux, unlike NetBSD in setreuid(2), does not
@


1.29
log
@Be more careful about return values from hzto.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.28 2000/06/26 16:21:27 art Exp $	*/
d830 1
a830 1
		if (timo < 0)
@


1.28
log
@Use new timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.27 2000/04/12 04:22:40 jasoni Exp $	*/
d788 1
d829 3
d833 1
a833 1
		timeout_add(&p->p_realit_to, hzto(&it.it_value));
@


1.27
log
@Implement linux's setfsuid and getfsuid (from NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.26 2000/02/28 13:29:30 jasoni Exp $	*/
d794 2
a795 1
	untimeout(realitexpire, p);
d829 1
a829 1
		timeout(realitexpire, p, hzto(&it.it_value));
@


1.27.2.1
log
@Pull in patch from current:
Fix (art):
Use new timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.27 2000/04/12 04:22:40 jasoni Exp $	*/
d794 1
a794 2

	timeout_del(&p->p_realit_to);
d828 1
a828 1
		timeout_add(&p->p_realit_to, hzto(&it.it_value));
@


1.26
log
@Add missing system calls as unimplemented.
Implement chown, poll, setresuid, getresuid, setresgid, getresgid.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.25 1999/12/06 19:36:41 aaron Exp $	*/
d1442 32
@


1.25
log
@Implement compatibility for Linux stime() syscall.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.24 1999/06/14 06:47:54 deraadt Exp $	*/
d197 99
d1339 102
@


1.25.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a196 99
int
linux_sys_setresgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_setresgid_args /* {
		syscallarg(gid_t) rgid;
		syscallarg(gid_t) egid;
		syscallarg(gid_t) sgid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	gid_t rgid, egid, sgid;
	int error;

	rgid = SCARG(uap, rgid);
	egid = SCARG(uap, egid);
	sgid = SCARG(uap, sgid);

	/*
	 * Note: These checks are a little different than the NetBSD
	 * setregid(2) call performs.  This precisely follows the
	 * behavior of the Linux kernel.
	 */
	if (rgid != (gid_t)-1 &&
	    rgid != pc->p_rgid &&
	    rgid != pc->pc_ucred->cr_gid &&
	    rgid != pc->p_svgid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (egid != (gid_t)-1 &&
	    egid != pc->p_rgid &&
	    egid != pc->pc_ucred->cr_gid &&
	    egid != pc->p_svgid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (sgid != (gid_t)-1 &&
	    sgid != pc->p_rgid &&
	    sgid != pc->pc_ucred->cr_gid &&
	    sgid != pc->p_svgid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	/*
	 * Now assign the real, effective, and saved GIDs.
	 * Note that Linux, unlike NetBSD in setregid(2), does not
	 * set the saved UID in this call unless the user specifies
	 * it.
	 */
	if (rgid != (gid_t)-1)
		pc->p_rgid = rgid;

	if (egid != (gid_t)-1) {
		pc->pc_ucred = crcopy(pc->pc_ucred);
		pc->pc_ucred->cr_gid = egid;
	}

	if (sgid != (gid_t)-1)
		pc->p_svgid = sgid;

	if (rgid != (gid_t)-1 && egid != (gid_t)-1 && sgid != (gid_t)-1)
		p->p_flag |= P_SUGID;
	return (0);
}

int
linux_sys_getresgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_getresgid_args /* {
		syscallarg(gid_t *) rgid;
		syscallarg(gid_t *) egid;
		syscallarg(gid_t *) sgid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	int error;

	/*
	 * Linux copies these values out to userspace like so:
	 *
	 *	1. Copy out rgid.
	 *	2. If that succeeds, copy out egid.
	 *	3. If both of those succeed, copy out sgid.
	 */
	if ((error = copyout(&pc->p_rgid, SCARG(uap, rgid),
			     sizeof(gid_t))) != 0)
		return (error);

	if ((error = copyout(&pc->pc_ucred->cr_uid, SCARG(uap, egid),
			     sizeof(gid_t))) != 0)
		return (error);

	return (copyout(&pc->p_svgid, SCARG(uap, sgid), sizeof(gid_t)));
}

a1239 102
}

int
linux_sys_setresuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_setresuid_args /* {
		syscallarg(uid_t) ruid;
		syscallarg(uid_t) euid;
		syscallarg(uid_t) suid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	uid_t ruid, euid, suid;
	int error;

	ruid = SCARG(uap, ruid);
	euid = SCARG(uap, euid);
	suid = SCARG(uap, suid);

	/*
	 * Note: These checks are a little different than the NetBSD
	 * setreuid(2) call performs.  This precisely follows the
	 * behavior of the Linux kernel.
	 */
	if (ruid != (uid_t)-1 &&
	    ruid != pc->p_ruid &&
	    ruid != pc->pc_ucred->cr_uid &&
	    ruid != pc->p_svuid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (euid != (uid_t)-1 &&
	    euid != pc->p_ruid &&
	    euid != pc->pc_ucred->cr_uid &&
	    euid != pc->p_svuid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (suid != (uid_t)-1 &&
	    suid != pc->p_ruid &&
	    suid != pc->pc_ucred->cr_uid &&
	    suid != pc->p_svuid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	/*
	 * Now assign the new real, effective, and saved UIDs.
	 * Note that Linux, unlike NetBSD in setreuid(2), does not
	 * set the saved UID in this call unless the user specifies
	 * it.
	 */
	if (ruid != (uid_t)-1) {
		(void)chgproccnt(pc->p_ruid, -1);
		(void)chgproccnt(ruid, 1);
		pc->p_ruid = ruid;
	}

	if (euid != (uid_t)-1) {
		pc->pc_ucred = crcopy(pc->pc_ucred);
		pc->pc_ucred->cr_uid = euid;
	}

	if (suid != (uid_t)-1)
		pc->p_svuid = suid;

	if (ruid != (uid_t)-1 && euid != (uid_t)-1 && suid != (uid_t)-1)
		p->p_flag |= P_SUGID;
	return (0);
}

int
linux_sys_getresuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_getresuid_args /* {
		syscallarg(uid_t *) ruid;
		syscallarg(uid_t *) euid;
		syscallarg(uid_t *) suid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	int error;

	/*
	 * Linux copies these values out to userspace like so:
	 *
	 *	1. Copy out ruid.
	 *	2. If that succeeds, copy out euid.
	 *	3. If both of those succeed, copy out suid.
	 */
	if ((error = copyout(&pc->p_ruid, SCARG(uap, ruid),
			     sizeof(uid_t))) != 0)
		return (error);

	if ((error = copyout(&pc->pc_ucred->cr_uid, SCARG(uap, euid),
			     sizeof(uid_t))) != 0)
		return (error);

	return (copyout(&pc->p_svuid, SCARG(uap, suid), sizeof(uid_t)));
@


1.25.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.35 2001/04/02 21:43:11 niklas Exp $	*/
a73 1
#include <compat/linux/linux_misc.h>
a74 1
#include <compat/linux/linux_sched.h>
a79 2
#include <compat/common/compat_dir.h>

d81 1
d83 2
a84 2
int	linux_select1 __P((struct proc *, register_t *, int, fd_set *,
     fd_set *, fd_set *, struct timeval *));
d91 1
a91 1
void
d105 2
a106 2
 * waitpid(2). Passed on to the OpenBSD call, surrounded by code to
 * reserve some space for a OpenBSD-style wait status, and converting
d167 1
a167 1
	int error, *status, tstat, linux_options, options;
a175 13
	linux_options = SCARG(uap, options);
	options = 0;
	if (linux_options &
	    ~(LINUX_WAIT4_WNOHANG|LINUX_WAIT4_WUNTRACED|LINUX_WAIT4_WCLONE))
		return (EINVAL);

	if (linux_options & LINUX_WAIT4_WNOHANG)
		options |= WNOHANG;
	if (linux_options & LINUX_WAIT4_WUNTRACED)
		options |= WUNTRACED;
	if (linux_options & LINUX_WAIT4_WCLONE)
		options |= WALTSIG;

d178 1
a178 1
	SCARG(&w4a, options) = options;
d217 1
a217 1
	 * Note: These checks are a little different than the OpenBSD
d244 1
a244 1
	 * Note that Linux, unlike OpenBSD in setregid(2), does not
d317 1
a317 1
 * done in the kernel in Linux. OpenBSD does it in the library.
d497 1
a497 1
 * is almost the same as the OpenBSD one, only it has fields 65 characters
d628 1
a628 1
	SCARG(&cma,fd) = flags & MAP_ANON ? -1 : lmap.lm_fd;
d728 1
a728 1
 * OpenBSD passes fd[0] in retval[0], and fd[1] in retval[1].
d774 1
a774 1
 * Alarm. This is a libc call which uses setitimer(2) in OpenBSD.
a787 1
	int timo;
d794 1
a794 2

	timeout_del(&p->p_realit_to);
a826 3
		timo = hzto(&it.it_value);
		if (timo <= 0)
			timo = 1;
d828 1
a828 1
		timeout_add(&p->p_realit_to, timo);
a856 1
	tvp = (struct timeval *) stackgap_alloc(&sg, sizeof(tv));
d867 1
a899 1

a916 58
int linux_readdir_callback __P((void *, struct dirent *, off_t));

struct linux_readdir_callback_args {
	caddr_t outp;
	int     resid;
	int     oldcall;
};

int
linux_readdir_callback(arg, bdp, cookie)
	void *arg;
	struct dirent *bdp;
	off_t cookie;
{
	struct linux_dirent idb;
	struct linux_readdir_callback_args *cb = arg;
	int linux_reclen;
	int error;

	if (cb->oldcall == 2) 
		return (ENOMEM);

	linux_reclen = LINUX_RECLEN(&idb, bdp->d_namlen);
	if (cb->resid < linux_reclen)
		return (ENOMEM);

	/*
	 * Massage in place to make a Linux-shaped dirent (otherwise
	 * we have to worry about touching user memory outside of
	 * the copyout() call).
	 */
	idb.d_ino = (linux_ino_t)bdp->d_fileno;
	
	/*
	 * The old readdir() call misuses the offset and reclen fields.
	 */
	if (cb->oldcall) {
		idb.d_off = (linux_off_t)linux_reclen;
		idb.d_reclen = (u_short)bdp->d_namlen;
	} else {
		idb.d_off = (linux_off_t)cookie;
		idb.d_reclen = (u_short)linux_reclen;
	}
	
	strlcpy(idb.d_name, bdp->d_name, sizeof(idb.d_name));
	if ((error = copyout((caddr_t)&idb, cb->outp, linux_reclen)))
		return (error);

	/* advance output past Linux-shaped entry */
	cb->outp += linux_reclen;
	cb->resid -= linux_reclen;

	if (cb->oldcall == 1)
		++cb->oldcall;
	
	return (0);
}

d923 1
a923 1
	struct linux_sys_getdents_args /* {
d925 2
a926 2
		syscallarg(void *) dirent;
		syscallarg(unsigned) count;
d928 6
a933 1
	struct linux_readdir_callback_args args;
d935 8
a942 2
	int error;
	int nbytes = SCARG(uap, count);
d947 12
d960 3
a962 2
		nbytes = sizeof(struct linux_dirent);
		args.oldcall = 1;
d964 2
a965 1
		args.oldcall = 0;
d967 47
d1015 6
a1020 2
	args.resid = nbytes;
	args.outp = (caddr_t)SCARG(uap, dirent);
d1022 23
a1044 5
	if ((error = readdir_with_callback(fp, &fp->f_offset, nbytes,
	    linux_readdir_callback, &args)) != 0)
		goto exit;

	*retval = nbytes - args.resid;
d1046 16
a1061 2
 exit:
	return (error);
d1361 1
a1361 1
	 * Note: These checks are a little different than the OpenBSD
d1388 1
a1388 1
	 * Note that Linux, unlike OpenBSD in setreuid(2), does not
a1441 32

/*
 * We have nonexistent fsuid equal to uid.
 * If modification is requested, refuse.
 */
int
linux_sys_setfsuid(p, v, retval)
	 struct proc *p;
	 void *v;
	 register_t *retval;
{
	 struct linux_sys_setfsuid_args /* {
		 syscallarg(uid_t) uid;
	 } */ *uap = v;
	 uid_t uid;

	 uid = SCARG(uap, uid);
	 if (p->p_cred->p_ruid != uid)
		 return sys_nosys(p, v, retval);
	 else
		 return (0);
}

int
linux_sys_getfsuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	return sys_getuid(p, v, retval);
}

@


1.25.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.25.2.2 2001/05/14 22:04:45 niklas Exp $	*/
d70 1
d214 1
a214 1
linux_sys_setresgid16(p, v, retval)
d219 1
a219 1
	struct linux_sys_setresgid16_args /* {
d281 1
a281 1
linux_sys_getresgid16(p, v, retval)
d286 1
a286 1
	struct linux_sys_getresgid16_args /* {
d1222 1
a1222 1
linux_sys_setreuid16(p, v, retval)
d1227 1
a1227 1
	struct linux_sys_setreuid16_args /* {
d1242 1
a1242 1
linux_sys_setregid16(p, v, retval)
d1247 1
a1247 1
	struct linux_sys_setregid16_args /* {
d1314 1
a1314 1
linux_sys_setresuid16(p, v, retval)
d1319 1
a1319 1
	struct linux_sys_setresuid16_args /* {
@


1.25.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 1
a69 1
#include <uvm/uvm_extern.h>
@


1.25.2.5
log
@Merge in trunk
@
text
@a1024 1
	FREF(fp);
a1031 1
	FRELE(fp);
@


1.25.2.6
log
@Merge in -current from about a week ago
@
text
@d84 3
a86 3
static void bsd_to_linux_statfs(struct statfs *, struct linux_statfs *);
int	linux_select1(struct proc *, register_t *, int, fd_set *,
     fd_set *, fd_set *, struct timeval *);
d524 2
a525 1
	extern char hostname[], machine[], domainname[];
d561 1
a561 1
	extern char hostname[], machine[];
d590 1
a590 1
	extern char hostname[], machine[];
d938 1
a938 1
int linux_readdir_callback(void *, struct dirent *, off_t);
@


1.25.2.7
log
@Sync the SMP branch with 3.3
@
text
@a86 1
static int getdents_common(struct proc *, void *, register_t *, int);
d219 3
a221 3
		syscallarg(u_int16_t) rgid;
		syscallarg(u_int16_t) egid;
		syscallarg(u_int16_t) sgid;
d223 3
a225 2
	struct sys_setresgid_args nuap;
	u_int16_t rgid, egid, sgid;
a227 1
	SCARG(&nuap, rgid) = (rgid == (u_int16_t)-1) ? (gid_t)-1 : rgid;
a228 1
	SCARG(&nuap, egid) = (egid == (u_int16_t)-1) ? (gid_t)-1 : egid;
a229 1
	SCARG(&nuap, sgid) = (sgid == (u_int16_t)-1) ? (gid_t)-1 : sgid;
d231 11
a241 2
	return sys_setresgid(p, &nuap, retval);
}
d243 6
a248 12
int
linux_sys_getresgid16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_getresgid16_args /* {
		syscallarg(u_int16_t *) rgid;
		syscallarg(u_int16_t *) egid;
		syscallarg(u_int16_t *) sgid;
	} */ *uap = v;
	struct sys_getresgid_args nuap;
d250 6
a255 3
	SCARG(&nuap, rgid) = (gid_t *)SCARG(uap, rgid);
	SCARG(&nuap, egid) = (gid_t *)SCARG(uap, egid);
	SCARG(&nuap, sgid) = (gid_t *)SCARG(uap, sgid);
d257 8
a264 2
	return sys_getresgid(p, &nuap, retval);
}
d266 4
a269 13
int
linux_sys_setresuid16(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_setresuid16_args /* {
		syscallarg(u_int16_t) ruid;
		syscallarg(u_int16_t) euid;
		syscallarg(u_int16_t) suid;
	} */ *uap = v;
	struct sys_setresuid_args nuap;
	u_int16_t ruid, euid, suid;
d271 2
a272 6
	ruid = SCARG(uap, ruid);
	SCARG(&nuap, ruid) = (ruid == (u_int16_t)-1) ? (uid_t)-1 : ruid;
	euid = SCARG(uap, euid);
	SCARG(&nuap, euid) = (euid == (u_int16_t)-1) ? (uid_t)-1 : euid;
	suid = SCARG(uap, suid);
	SCARG(&nuap, suid) = (suid == (u_int16_t)-1) ? (uid_t)-1 : suid;
d274 3
a276 1
	return sys_setresuid(p, &nuap, retval);
d280 1
a280 1
linux_sys_getresuid16(p, v, retval)
d285 4
a288 4
	struct linux_sys_getresuid16_args /* {
		syscallarg(u_int16_t *) ruid;
		syscallarg(u_int16_t *) euid;
		syscallarg(u_int16_t *) suid;
d290 13
a302 1
	struct sys_getresuid_args nuap;
d304 3
a306 3
	SCARG(&nuap, ruid) = (uid_t *)SCARG(uap, ruid);
	SCARG(&nuap, euid) = (uid_t *)SCARG(uap, euid);
	SCARG(&nuap, suid) = (uid_t *)SCARG(uap, suid);
d308 1
a308 1
	return sys_getresuid(p, &nuap, retval);
a942 1
	int	is64bit;
a950 1
	struct linux_dirent64 idb64;
d959 1
a959 4
	linux_reclen = (cb->is64bit) ?
	     LINUX_RECLEN(&idb64, bdp->d_namlen) :
	     LINUX_RECLEN(&idb, bdp->d_namlen);

d963 13
a975 7
	if (cb->is64bit) {
		idb64.d_ino = (linux_ino64_t)bdp->d_fileno;
		idb64.d_off = (linux_off64_t)cookie;
		idb64.d_reclen = (u_short)linux_reclen;
		idb64.d_type = bdp->d_type;
		strlcpy(idb64.d_name, bdp->d_name, sizeof(idb64.d_name));
		error = copyout((caddr_t)&idb64, cb->outp, linux_reclen);
d977 2
a978 14
		idb.d_ino = (linux_ino_t)bdp->d_fileno;
		if (cb->oldcall) {
			/*
			 * The old readdir() call misuses the offset
			 * and reclen fields.
			 */
			idb.d_off = (linux_off_t)linux_reclen;
			idb.d_reclen = (u_short)bdp->d_namlen;
		} else {
			idb.d_off = (linux_off_t)cookie;
			idb.d_reclen = (u_short)linux_reclen;
		}
		strlcpy(idb.d_name, bdp->d_name, sizeof(idb.d_name));
		error = copyout((caddr_t)&idb, cb->outp, linux_reclen);
d980 3
a982 1
	if (error)
a995 9
linux_sys_getdents64(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	return getdents_common(p, v, retval, 1);
}

int
a1000 10
	return getdents_common(p, v, retval, 0);
}

static int
getdents_common(p, v, retval, is64bit)
	struct proc *p;
	void *v;
	register_t *retval;
	int is64bit;
{
a1014 5
		/* readdir(2) case. Always struct dirent. */
		if (is64bit) {
			FRELE(fp);
			return (EINVAL);
		}
a1022 1
	args.is64bit = is64bit;
d1024 1
d1231 1
a1231 1
	struct sys_setreuid_args bsa;
d1238 1
a1238 1
	return sys_setreuid(p, &bsa, retval);
d1251 1
a1251 1
	struct sys_setregid_args bsa;
d1258 1
a1258 1
	return sys_setregid(p, &bsa, retval);
d1313 102
d1486 1
a1486 1
	error = settime(&atv);
d1488 1
a1488 34
	return (error);
}

int
linux_sys_getpid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	*retval = p->p_pid;
	return (0);
}

int
linux_sys_getuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	*retval = p->p_cred->p_ruid;
	return (0);
}

int
linux_sys_getgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{

	*retval = p->p_cred->p_rgid;
	return (0);
@


1.25.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d4 2
a5 2
/*-
 * Copyright (c) 1995, 1998, 1999 The NetBSD Foundation, Inc.
a7 4
 * This code is derived from software contributed to The NetBSD Foundation
 * by Frank van der Linden and Eric Haszlakiewicz; by Jason R. Thorpe
 * of the Numerical Aerospace Simulation Facility, NASA Ames Research Center.
 *
d18 4
a21 5
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
d23 10
a32 11
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
a79 1
#include <compat/linux/linux_emuldata.h>
a87 2
static void linux_to_bsd_mmap_args(struct sys_mmap_args *,
    const struct linux_sys_mmap2_args *);
d336 1
a336 1
	struct linux_emuldata *ed = (struct linux_emuldata*)p->p_emuldata;
d338 7
d348 1
a348 1
		ed->p_break = (char*)nbrk;
d350 1
a350 3
		nbrk = ed->p_break;

	retval[0] = (register_t)nbrk;
a613 1
	struct linux_sys_mmap2_args nlmap;
d615 1
a615 1
	int error;
d620 15
a634 44
	if (lmap.lm_pos & PAGE_MASK)
		return EINVAL;

	/* repackage into something sane */
	SCARG(&nlmap,addr) = (unsigned long)lmap.lm_addr;
	SCARG(&nlmap,len) = lmap.lm_len;
	SCARG(&nlmap,prot) = lmap.lm_prot;
	SCARG(&nlmap,flags) = lmap.lm_flags;
	SCARG(&nlmap,fd) = lmap.lm_fd;
	SCARG(&nlmap,offset) = (unsigned)lmap.lm_pos;

	linux_to_bsd_mmap_args(&cma, &nlmap);
	SCARG(&cma, pos) = (off_t)SCARG(&nlmap, offset);

	return sys_mmap(p, &cma, retval);
}

/*
 * Guts of most architectures' mmap64() implementations.  This shares
 * its list of arguments with linux_sys_mmap().
 *
 * The difference in linux_sys_mmap2() is that "offset" is actually
 * (offset / pagesize), not an absolute byte count.  This translation
 * to pagesize offsets is done inside glibc between the mmap64() call
 * point, and the actual syscall.
 */
int
linux_sys_mmap2(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_mmap2_args /* {
		syscallarg(unsigned long) addr;
		syscallarg(size_t) len;
		syscallarg(int) prot;
		syscallarg(int) flags;
		syscallarg(int) fd;
		syscallarg(linux_off_t) offset;
	} */ *uap = v;
	struct sys_mmap_args cma;

	linux_to_bsd_mmap_args(&cma, uap);
	SCARG(&cma, pos) = ((off_t)SCARG(uap, offset)) << PAGE_SHIFT;
a638 23
static void
linux_to_bsd_mmap_args(cma, uap)
	struct sys_mmap_args *cma;
	const struct linux_sys_mmap2_args *uap;
{
	int flags = MAP_TRYFIXED, fl = SCARG(uap, flags);
	
	flags |= cvtto_bsd_mask(fl, LINUX_MAP_SHARED, MAP_SHARED);
	flags |= cvtto_bsd_mask(fl, LINUX_MAP_PRIVATE, MAP_PRIVATE);
	flags |= cvtto_bsd_mask(fl, LINUX_MAP_FIXED, MAP_FIXED);
	flags |= cvtto_bsd_mask(fl, LINUX_MAP_ANON, MAP_ANON);
	/* XXX XAX ERH: Any other flags here?  There are more defined... */

	SCARG(cma, addr) = (void *)SCARG(uap, addr);
	SCARG(cma, len) = SCARG(uap, len);
	SCARG(cma, prot) = SCARG(uap, prot);
	if (SCARG(cma, prot) & VM_PROT_WRITE) /* XXX */
		SCARG(cma, prot) |= VM_PROT_READ;
	SCARG(cma, flags) = flags;
	SCARG(cma, fd) = flags & MAP_ANON ? -1 : SCARG(uap, fd);
	SCARG(cma, pad) = 0;
}

d833 1
a833 1
		timo = tvtohz(&it.it_value);
d1398 1
a1398 1
	if ((error = suser(p, 0)) != 0)
a1442 39
}


/*
 * sysinfo()
 */
/* ARGSUSED */
int
linux_sys_sysinfo(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_sysinfo_args /* {
		syscallarg(struct linux_sysinfo *) sysinfo;
	} */ *uap = v;
	struct linux_sysinfo si;
	struct loadavg *la;
	extern int bufpages;


	si.uptime = time.tv_sec - boottime.tv_sec;
	la = &averunnable;
	si.loads[0] = la->ldavg[0] * LINUX_SYSINFO_LOADS_SCALE / la->fscale;
	si.loads[1] = la->ldavg[1] * LINUX_SYSINFO_LOADS_SCALE / la->fscale;
	si.loads[2] = la->ldavg[2] * LINUX_SYSINFO_LOADS_SCALE / la->fscale;
	si.totalram = ctob(physmem);
	si.freeram = uvmexp.free * uvmexp.pagesize;
	si.sharedram = 0;/* XXX */
	si.bufferram = bufpages * PAGE_SIZE;
	si.totalswap = uvmexp.swpages * PAGE_SIZE;
	si.freeswap = (uvmexp.swpages - uvmexp.swpginuse) * PAGE_SIZE;
	si.procs = nprocs;
	/* The following are only present in newer Linux kernels. */
	si.totalbig = 0;
	si.freebig = 0;
	si.mem_unit = 1;

	return (copyout(&si, SCARG(uap, sysinfo), sizeof(si)));
@


1.24
log
@avoid future register_t vs int problems, if this becomes 64 bit
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.23 1999/06/08 16:05:23 deraadt Exp $	*/
d1257 27
@


1.23
log
@better fd leak prevention
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.22 1999/06/08 15:47:39 deraadt Exp $	*/
d642 1
d656 3
a658 1
	if ((error = copyout(retval, SCARG(uap, pfds), 2 * sizeof (int)))) {
@


1.22
log
@use sys_opipe(), but note the descriptor leakage
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.21 1999/05/31 17:34:46 millert Exp $	*/
d659 2
a660 1
		/* XXX leaks descriptors */
@


1.21
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.20 1999/02/10 08:01:52 deraadt Exp $	*/
d646 1
a646 1
	if ((error = sys_pipe(p, 0, retval))) {
d659 1
@


1.20
log
@strncpy; edx trashing solution in sys_pipe(); freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.19 1999/02/10 00:16:12 niklas Exp $	*/
d290 23
a312 1
	lsp->l_ftype = bsp->f_type;
@


1.19
log
@Correct directory entry reads, big directories lost entries as it were.
Also, fix the NCR SVR4 rdebug syscall emulation.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.18 1998/07/05 20:49:12 downsj Exp $	*/
d394 12
a405 6
	strncpy(luts.l_sysname, ostype, sizeof(luts.l_sysname));
	strncpy(luts.l_nodename, hostname, sizeof(luts.l_nodename));
	strncpy(luts.l_release, osrelease, sizeof(luts.l_release));
	strncpy(luts.l_version, version, sizeof(luts.l_version));
	strncpy(luts.l_machine, machine, sizeof(luts.l_machine));
	strncpy(luts.l_domainname, domainname, sizeof(luts.l_domainname));
d620 8
a627 2

	if ((error = sys_pipe(p, 0, retval)))
d629 1
d633 4
a636 1
	if ((error = copyout(retval, SCARG(uap, pfds), 2 * sizeof (int))))
d638 1
d641 3
d906 2
a907 1
		strcpy(idb.d_name, bdp->d_name);
@


1.18
log
@fix netbsd bug; from boquist@@cs.chalmers.se
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.17 1998/07/04 08:59:08 deraadt Exp $	*/
d856 1
a856 1
			panic("linux_readdir");
a865 1
			off = *cookie++;
d868 1
d875 1
@


1.17
log
@emulate shrinking in mremap(); boquist@@cs.chalmers.se
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.16 1998/04/26 10:19:12 deraadt Exp $	*/
d545 1
a545 2
		SCARG(&mua, addr) = (caddr_t)SCARG(uap, old_address) +
		    SCARG(uap, new_size);
@


1.16
log
@correct utimes() emulation
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.15 1998/03/22 23:33:06 millert Exp $	*/
d514 1
a514 1
#ifdef notyet
d521 38
a558 2
#endif
	return (ENOMEM);
d836 3
a838 3
         * First we read into the malloc'ed buffer, then
         * we massage it into user space, one record at a time.
         */
@


1.15
log
@correct a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.14 1998/02/23 08:57:54 niklas Exp $	*/
d694 1
a694 1
	return sys_utimes(p, uap, retval);
@


1.14
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.13 1997/11/26 09:18:12 deraadt Exp $	*/
d526 1
a526 1
 * This code is partly stolen from src/lib/libc/compat-43/times.c
@


1.13
log
@enforce VM_PROT_READ in mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.12 1997/11/13 18:35:26 deraadt Exp $	*/
d405 1
a405 4
			if (len > 1)
				*cp = ' ';
			else
				*cp = '\0';
d434 1
a434 4
			if (len > 1)
				*cp = ' ';
			else
				*cp = '\0';
d463 1
a463 4
			if (len > 1)
				*cp = ' ';
			else
				*cp = '\0';
@


1.12
log
@make msync() have 3 args
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.11 1997/11/13 06:37:49 deraadt Exp $	*/
d506 2
@


1.11
log
@put mremap() in linux_misc.c
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.10 1997/11/06 05:58:04 csapuntz Exp $	*/
a529 21
}

int
linux_sys_msync(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_msync_args /* {
		syscallarg(caddr_t) addr;
		syscallarg(int) len;
		syscallarg(int) fl;
	} */ *uap = v;

	struct sys_msync_args bma;

	/* flags are ignored */
	SCARG(&bma, addr) = SCARG(uap, addr);
	SCARG(&bma, len) = SCARG(uap, len);

	return sys_msync(p, &bma, retval);
@


1.10
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.9 1997/10/06 20:19:31 deraadt Exp $	*/
d513 17
@


1.9
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.7 1997/04/14 11:16:23 graichen Exp $	*/
d771 2
a772 2
	u_long *cookiebuf, *cookie;
	int ncookies;
d798 1
a798 3
	ncookies = buflen / 16;
	cookiebuf = malloc(ncookies * sizeof(*cookiebuf), M_TEMP, M_WAITOK);
	VOP_LOCK(vp);
d814 2
a815 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, cookiebuf,
	    ncookies);
d819 3
d885 3
a887 2
	VOP_UNLOCK(vp);
	free(cookiebuf, M_TEMP);
@


1.8
log
@VFS Lite2 Changes
@
text
@d771 2
a772 2
	u_long *cookiebuf = NULL, *cookie;
	int ncookies = 0;
d798 3
a800 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d816 2
a817 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, &ncookies,
	    &cookiebuf);
a820 3
	if (!error && !cookiebuf)
		goto out;

d884 2
a885 3
	VOP_UNLOCK(vp, 0, p);
	if (cookiebuf)
		free(cookiebuf, M_TEMP);
@


1.7
log
@#34 - linux_sys_nice from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.6 1996/08/10 12:09:23 deraadt Exp $	*/
d771 2
a772 2
	u_long *cookiebuf, *cookie;
	int ncookies;
d798 1
a798 3
	ncookies = buflen / 16;
	cookiebuf = malloc(ncookies * sizeof(*cookiebuf), M_TEMP, M_WAITOK);
	VOP_LOCK(vp);
d814 2
a815 2
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, cookiebuf,
	    ncookies);
d819 3
d885 3
a887 2
	VOP_UNLOCK(vp);
	free(cookiebuf, M_TEMP);
@


1.6
log
@sys/dirent.h
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_misc.c,v 1.5 1996/05/22 12:01:48 deraadt Exp $	*/
d1165 17
@


1.5
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
a43 1
#include <sys/dir.h>
@


1.4
log
@Good fixes and changes from latest Net.
@
text
@d2 1
a2 1
/*	$NetBSD: linux_misc.c,v 1.26 1996/04/04 23:56:01 christos Exp $	*/
d1113 52
@


1.3
log
@from fvdl; add msync(), readv() and writev()
@
text
@d1 2
a2 1
/*	$NetBSD: linux_misc.c,v 1.24 1995/12/18 14:35:08 fvdl Exp $	*/
d80 6
d91 1
a91 1
static int
a190 1

d207 1
d211 1
d232 1
a232 2
	int error = 0;
	caddr_t oldbrk, newbrk;
d616 1
a616 1
	int error, s;
d760 4
a763 4
	caddr_t	inp, buf;	/* BSD-format */
	int len, reclen;	/* BSD-format */
	caddr_t outp;		/* Linux-format */
	int resid, linux_reclen;/* Linux-format */
d1039 1
a1039 1
	if (SCARG(uap, pid) != 0 && SCARG(uap, pid) != p->p_pid)
d1042 1
@


1.2
log
@update from netbsd
@
text
@d1 1
a1 1
/*	$NetBSD: linux_misc.c,v 1.23 1995/12/09 04:01:42 mycroft Exp $	*/
d506 21
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: linux_misc.c,v 1.22 1995/10/09 11:24:05 mycroft Exp $	*/
a505 21
}

/*
 * Linux doesn't use the retval[1] value to determine whether
 * we are the child or parent.
 */
int
linux_sys_fork(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	int error;

	if ((error = sys_fork(p, v, retval)))
		return error;

	if (retval[1] == 1)
		retval[0] = 0;

	return 0;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
