head	1.62;
access;
symbols
	OPENBSD_5_9:1.61.0.2
	OPENBSD_5_9_BASE:1.61
	OPENBSD_5_8:1.61.0.4
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.53.0.4
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.48.0.4
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.46.0.6
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.4
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.46.0.2
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.2
	OPENBSD_5_0:1.41.0.2
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.39.0.6
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.38.0.6
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.36.0.4
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.35.0.4
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.32.0.4
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.31.0.2
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	UBC_SYNC_A:1.29
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.25
	UBC:1.20.0.4
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.4
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.17.0.8
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.6
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.4
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.62
date	2016.03.02.15.41.48;	author naddy;	state dead;
branches;
next	1.61;
commitid	ZfNt0OHZhMg52abA;

1.61
date	2015.05.06.08.52.17;	author mpi;	state Exp;
branches;
next	1.60;
commitid	8Nt1erARPXBfs0Oe;

1.60
date	2015.01.30.23.38.49;	author millert;	state Exp;
branches;
next	1.59;
commitid	shxI90BWmtkPJSS6;

1.59
date	2015.01.21.13.47.45;	author mpi;	state Exp;
branches;
next	1.58;
commitid	68eD3TMsCU7g4JGU;

1.58
date	2015.01.21.02.23.14;	author guenther;	state Exp;
branches;
next	1.57;
commitid	z0tt692wWLCZ7FbG;

1.57
date	2015.01.19.23.30.20;	author guenther;	state Exp;
branches;
next	1.56;
commitid	jUAtDCK37g8NbVh3;

1.56
date	2014.12.05.15.50.03;	author mpi;	state Exp;
branches;
next	1.55;
commitid	t9FBKDfc4VDxpEy2;

1.55
date	2014.10.25.03.29.32;	author lteo;	state Exp;
branches;
next	1.54;
commitid	DZaOmw5xtfKdFlqd;

1.54
date	2014.09.10.04.39.50;	author mlarkin;	state Exp;
branches;
next	1.53;
commitid	BleaYqrbdYgOg8oI;

1.53
date	2014.07.12.18.50.00;	author tedu;	state Exp;
branches;
next	1.52;
commitid	C8XZQyreqTUCeixA;

1.52
date	2014.04.07.10.04.17;	author mpi;	state Exp;
branches;
next	1.51;

1.51
date	2014.03.28.08.33.51;	author sthen;	state Exp;
branches;
next	1.50;

1.50
date	2014.03.27.13.27.28;	author mpi;	state Exp;
branches;
next	1.49;

1.49
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2014.02.13.13.10.34;	author mpi;	state Exp;
branches;
next	1.47;

1.47
date	2014.01.23.04.11.46;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2012.06.26.10.18.08;	author pirofti;	state Exp;
branches;
next	1.45;

1.45
date	2012.06.19.11.28.20;	author pirofti;	state Exp;
branches;
next	1.44;

1.44
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2011.12.03.12.38.30;	author fgsch;	state Exp;
branches;
next	1.42;

1.42
date	2011.09.19.22.37.03;	author pirofti;	state Exp;
branches;
next	1.41;

1.41
date	2011.07.09.00.47.18;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.07.01.19.39;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.05.10.28.43;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2009.02.19.19.04.34;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.10.16.40.49;	author matthieu;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.06.09.59.21;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.21.18.16.37;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2005.06.07.02.30.47;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.08.15.11.37;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.25.21.43.42;	author nordin;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.24.01.31.36;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2003.01.21.08.05.11;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	2002.12.10.23.21.16;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2002.12.10.08.00.16;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.27.07.30.36;	author ish;	state Exp;
branches;
next	1.25;

1.25
date	2002.08.09.03.11.30;	author aaron;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.09.01.03.25;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.50;	author millert;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2002.02.13.20.43.42;	author jasoni;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.06.01.55.04;	author jasoni;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.21.01.43.57;	author itojun;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2001.05.24.06.00.09;	author jasoni;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.23.22.35.38;	author jasoni;	state Exp;
branches;
next	1.17;

1.17
date	99.02.10.08.04.26;	author deraadt;	state Exp;
branches
	1.17.6.1;
next	1.16;

1.16
date	99.02.10.08.04.04;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.07.19.15.32.24;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.07.13.19.45.47;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.04.25.05.47.35;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.04.25.00.12.45;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.02.10.04.32.41;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	98.02.07.16.33.34;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.12.14.20.51.16;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.12.10.12.44.38;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	97.12.10.01.51.23;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.11.27.00.57.28;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.11.26.08.51.08;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.11.26.08.45.46;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.17.05.24.01;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.03.08.23.43.06;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.19;	author deraadt;	state Exp;
branches;
next	;

1.17.6.1
date	2001.05.14.22.04.50;	author niklas;	state Exp;
branches;
next	1.17.6.2;

1.17.6.2
date	2001.07.04.10.39.26;	author niklas;	state Exp;
branches;
next	1.17.6.3;

1.17.6.3
date	2002.03.06.02.07.08;	author niklas;	state Exp;
branches;
next	1.17.6.4;

1.17.6.4
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.17.6.5;

1.17.6.5
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	1.17.6.6;

1.17.6.6
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	;

1.20.4.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2002.10.29.00.30.51;	author art;	state Exp;
branches;
next	1.20.4.3;

1.20.4.3
date	2003.05.19.21.52.09;	author tedu;	state Exp;
branches;
next	;

1.23.2.1
date	2002.08.26.20.53.39;	author jason;	state Exp;
branches;
next	;


desc
@@


1.62
log
@remove the Linux emulation code, no longer referenced by anything
@
text
@/*	$OpenBSD: linux_socket.c,v 1.61 2015/05/06 08:52:17 mpi Exp $	*/
/*	$NetBSD: linux_socket.c,v 1.14 1996/04/05 00:01:50 christos Exp $	*/

/*
 * Copyright (c) 1995 Frank van der Linden
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project
 *      by Frank van der Linden
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/domain.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/mbuf.h>
#include <sys/selinfo.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/un.h>
#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/if_dl.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/device.h>

#include <sys/syscallargs.h>

#include <compat/linux/linux_types.h>
#include <compat/linux/linux_util.h>
#include <compat/linux/linux_signal.h>
#include <compat/linux/linux_syscallargs.h>
#include <compat/linux/linux_ioctl.h>
#include <compat/linux/linux_socket.h>
#include <compat/linux/linux_socketcall.h>
#include <compat/linux/linux_sockio.h>

/*
 * All the calls in this file are entered via one common system
 * call in Linux, represented here by linux_socketcall().
 * Arguments for the various calls are on the user stack. A pointer
 * to them is the only thing that is passed. It is up to the various
 * calls to copy them in themselves. To make it look better, they
 * are copied to structures.
 */

static int linux_to_bsd_domain (int);
static int bsd_to_linux_domain(int);

static int linux_to_bsd_msg_flags(int);

int linux_socket(struct proc *, void *, register_t *);
int linux_bind(struct proc *, void *, register_t *);
int linux_connect(struct proc *, void *, register_t *);
int linux_listen(struct proc *, void *, register_t *);
int linux_accept(struct proc *, void *, register_t *);
int linux_getsockname(struct proc *, void *, register_t *);
int linux_getpeername(struct proc *, void *, register_t *);
int linux_socketpair(struct proc *, void *, register_t *);
int linux_send(struct proc *, void *, register_t *);
int linux_recv(struct proc *, void *, register_t *);
int linux_sendto(struct proc *, void *, register_t *);
int linux_recvfrom(struct proc *, void *, register_t *);
int linux_shutdown(struct proc *, void *, register_t *);
int linux_to_bsd_sopt_level(int);
int linux_to_bsd_so_sockopt(int);
int linux_to_bsd_ip_sockopt(int);
int linux_to_bsd_tcp_sockopt(int);
int linux_to_bsd_udp_sockopt(int);
int linux_setsockopt(struct proc *, void *, register_t *);
int linux_getsockopt(struct proc *, void *, register_t *);
int linux_recvmsg(struct proc *, void *, register_t *);
int linux_sendmsg(struct proc *, void *, register_t *);

int linux_check_hdrincl(struct proc *, int, register_t *, caddr_t *);
int linux_sendto_hdrincl(struct proc *, struct sys_sendto_args *,
    register_t *, caddr_t *);

int linux_sa_get(struct proc *, caddr_t *, struct sockaddr **,
    const struct linux_sockaddr *, int *);
int linux_sa_put(struct sockaddr *);

static const int linux_to_bsd_domain_[LINUX_AF_MAX] = {
	AF_UNSPEC,
	AF_UNIX,
	AF_INET,
	-1,		/* LINUX_AF_AX25 */
	-1,		/* IPX */
	-1		/* APPLETALK */
	-1,		/* LINUX_AF_NETROM */
	-1,		/* LINUX_AF_BRIDGE */
	-1,		/* LINUX_AF_ATMPVC */
	-1,		/* LINUX_AF_X25 */
	AF_INET6,
	-1,		/* LINUX_AF_ROSE */
	AF_DECnet,
	-1,		/* LINUX_AF_NETBEUI */
	-1,		/* LINUX_AF_SECURITY */
	-1,		/* pseudo_AF_KEY */
	AF_ROUTE,	/* LINUX_AF_NETLINK */
	-1,		/* LINUX_AF_PACKET */
	-1,		/* LINUX_AF_ASH */
	-1,		/* LINUX_AF_ECONET */
	-1,		/* LINUX_AF_ATMSVC */
	AF_SNA,
	/* rest up to LINUX_AF_MAX-1 is not allocated */
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

static const int bsd_to_linux_domain_[AF_MAX] = {
	LINUX_AF_UNSPEC,
	LINUX_AF_UNIX,
	LINUX_AF_INET,
	-1,		/* AF_IMPLINK */
	-1,		/* AF_PUP */
	-1,		/* AF_CHAOS */
	-1,		/* AF_NS */
	-1,		/* AF_ISO */
	-1,		/* AF_ECMA */
	-1,		/* AF_DATAKIT */
	-1,		/* AF_CCITT */
	-1,		/* LINUX_AF_SNA */
	-1,		/* LINUX_AF_DECnet */
	-1,		/* AF_DLI */
	-1,		/* AF_LAT */
	-1,		/* AF_HYLINK */
	LINUX_AF_APPLETALK,
	-1,		/* LINUX_AF_NETLINK */
	-1,		/* AF_LINK */
	-1,		/* AF_XTP */
	-1,		/* AF_COIP */
	-1,		/* AF_CNT */
	-1,		/* pseudo_AF_RTIP */
	LINUX_AF_IPX,
	LINUX_AF_INET6,
	-1,		/* pseudo_AF_PIP */
	-1,		/* AF_ISDN */
	-1,		/* AF_NATM */
	-1,		/* AF_ARP */
	-1,		/* LINUX_pseudo_AF_KEY */
	-1,		/* pseudo_AF_HDRCMPLT */
};

/*
 * Convert from Linux to BSD socket domain values
 */
static int
linux_to_bsd_domain(ldom)
	int ldom;
{
	if (ldom < 0 || ldom >= LINUX_AF_MAX)
		return (-1);

	return linux_to_bsd_domain_[ldom];
}

/*
 * Convert from BSD to Linux socket domain values
 */
static int
bsd_to_linux_domain(bdom)
	int bdom;
{
	if (bdom < 0 || bdom >= AF_MAX)
		return (-1);

	return bsd_to_linux_domain_[bdom];
}

/*
 * Convert from Linux to BSD MSG_XXX flags
 */
static int
linux_to_bsd_msg_flags(int lflags)
{
	int flags = 0;

	if (lflags & LINUX_MSG_OOB)
		flags |= MSG_OOB;
	if (lflags & LINUX_MSG_PEEK)
		flags |= MSG_PEEK;
	if (lflags & LINUX_MSG_DONTWAIT)
		flags |= MSG_DONTWAIT;
	if (lflags & LINUX_MSG_WAITALL)
		flags |= MSG_WAITALL;
	if (lflags & LINUX_MSG_NOSIGNAL)
		flags |= MSG_NOSIGNAL;
	return (flags);
}

int
linux_socket(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_socket_args /* {
		syscallarg(int)	domain;
		syscallarg(int)	type;
		syscallarg(int) protocol;
	} */ *uap = v;
	struct linux_socket_args lsa;
	struct sys_socket_args bsa;
	int error;

	if ((error = copyin(uap, &lsa, sizeof lsa)))
		return error;

	SCARG(&bsa, protocol) = lsa.protocol;
	SCARG(&bsa, type) = lsa.type & LINUX_SOCKET_TYPE_MASK;
	SCARG(&bsa, domain) = linux_to_bsd_domain(lsa.domain);
	if (SCARG(&bsa, domain) == -1)
		return (EINVAL);

	if (lsa.type & ~(LINUX_SOCKET_TYPE_MASK | LINUX_SOCK_CLOEXEC |
	    LINUX_SOCK_NONBLOCK))
		return (EINVAL);
	if (lsa.type & LINUX_SOCK_CLOEXEC)
		SCARG(&bsa, type) |= SOCK_CLOEXEC;
	if (lsa.type & LINUX_SOCK_NONBLOCK)
		SCARG(&bsa, type) |= SOCK_NONBLOCK;

	return (sys_socket(p, &bsa, retval));
}

int
linux_bind(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_bind_args /* {
		syscallarg(int)	s;
		syscallarg(struct linux_sockaddr *) name;
		syscallarg(int)	namelen;
	} */ *uap = v;
	struct linux_bind_args lba;
	struct sys_bind_args bba;
	int error;
	int namlen;

	if ((error = copyin((caddr_t) uap, (caddr_t) &lba, sizeof lba)))
		return error;

	SCARG(&bba, s) = lba.s;
	namlen = lba.namelen;
	if (lba.name) {
		struct sockaddr *sa;
		caddr_t sg = stackgap_init(p);

		error = linux_sa_get(p, &sg, &sa, lba.name, &namlen);
		if (error)
			return (error);
		SCARG(&bba, name) = sa;
	} else
		SCARG(&bba, name) = NULL;
	SCARG(&bba, namelen) = namlen;

	return sys_bind(p, &bba, retval);
}

int
linux_connect(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_connect_args /* {
		syscallarg(int)	s;
		syscallarg(struct linux_sockaddr *) name;
		syscallarg(int)	namelen;
	} */ *uap = v;
	struct linux_connect_args lca;
	struct sys_connect_args bca;
	struct sockaddr *sa;
	caddr_t sg = stackgap_init(p);
	int namlen;
	int error;

	if ((error = copyin((caddr_t) uap, (caddr_t) &lca, sizeof lca)))
		return error;

	namlen = lca.namelen;
	error = linux_sa_get(p, &sg, &sa, lca.name, &namlen);
	if (error)
		return (error);

	SCARG(&bca, s) = lca.s;
	SCARG(&bca, name) = sa;
	SCARG(&bca, namelen) = (unsigned int)namlen;

	error = sys_connect(p, &bca, retval);

	if (error == EISCONN) {
		struct sys_getsockopt_args bga;
#if 0
		struct sys_fcntl_args fca;
#endif
		void *status, *statusl;
		int stat, statl = sizeof stat;

#if 0
		SCARG(&fca, fd) = lca.s;
		SCARG(&fca, cmd) = F_GETFL;
		SCARG(&fca, arg) = 0;
		if (sys_fcntl(p, &fca, retval) == -1 ||
		    (*retval & O_NONBLOCK) == 0)
			return error;
#endif

		status = stackgap_alloc(&sg, sizeof stat);
		statusl = stackgap_alloc(&sg, sizeof statl);

		if ((error = copyout(&statl, statusl, sizeof statl)))
			return error;

		SCARG(&bga, s) = lca.s;
		SCARG(&bga, level) = SOL_SOCKET;
		SCARG(&bga, name) = SO_ERROR;
		SCARG(&bga, val) = status;
		SCARG(&bga, avalsize) = statusl;
		
		error = sys_getsockopt(p, &bga, retval);
		if (error)
			return error;
		if ((error = copyin(status, &stat, sizeof stat)))
			return error;
		return stat;
	}
	return error;
}

int
linux_listen(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_listen_args /* {
		syscallarg(int) s;
		syscallarg(int) backlog;
	} */ *uap = v;
	struct linux_listen_args lla;
	struct sys_listen_args bla;
	int error;

	if ((error = copyin((caddr_t) uap, (caddr_t) &lla, sizeof lla)))
		return error;

	SCARG(&bla, s) = lla.s;
	SCARG(&bla, backlog) = lla.backlog;

	return sys_listen(p, &bla, retval);
}

int
linux_accept(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_accept_args /* {
		syscallarg(int) s;
		syscallarg(struct sockaddr *) addr;
		syscallarg(int *) namelen;
	} */ *uap = v;
	struct linux_accept_args laa;
	int error;

	if ((error = copyin((caddr_t) uap, (caddr_t) &laa, sizeof laa)))
		return error;

	if ((error = doaccept(p, laa.s, laa.addr, laa.namelen, 0, retval)))
		return (error);

	return (linux_sa_put(laa.addr));
}

int
linux_getsockname(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_getsockname_args /* {
		syscallarg(int) s;
		syscallarg(struct sockaddr *) addr;
		syscallarg(int *) namelen;
	} */ *uap = v;
	struct linux_getsockname_args lga;
	struct sys_getsockname_args bga;
	int error;

	if ((error = copyin((caddr_t) uap, (caddr_t) &lga, sizeof lga)))
		return error;

	SCARG(&bga, fdes) = lga.s;
	SCARG(&bga, asa)  = lga.addr;
	SCARG(&bga, alen) = lga.namelen;

	error = sys_getsockname(p, &bga, retval);
	if (error)
		return (error);

	return (linux_sa_put(lga.addr));
}

int
linux_getpeername(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_getpeername_args /* {
		syscallarg(int) s;
		syscallarg(struct sockaddr *) addr;
		syscallarg(int *) namelen;
	} */ *uap = v;
	struct linux_getpeername_args lga;
	struct sys_getpeername_args bga;
	int error;

	if ((error = copyin(uap, &lga, sizeof lga)))
		return error;

	SCARG(&bga, fdes) = lga.s;
	SCARG(&bga, asa)  = lga.addr;
	SCARG(&bga, alen) = lga.namelen;

	error = sys_getpeername(p, &bga, retval);
	if (error)
		return (error);

	return (linux_sa_put(lga.addr));
}

int
linux_socketpair(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_socketpair_args /* {
		syscallarg(int) domain;
		syscallarg(int) type;
		syscallarg(int) protocol;
		syscallarg(int *) rsv;
	} */ *uap = v;
	struct linux_socketpair_args lsa;
	struct sys_socketpair_args bsa;
	int error;

	if ((error = copyin((caddr_t) uap, &lsa, sizeof lsa)))
		return error;

	SCARG(&bsa, domain) = linux_to_bsd_domain(lsa.domain);
	if (SCARG(&bsa, domain) == -1)
		return EINVAL;
	SCARG(&bsa, type) = lsa.type;
	SCARG(&bsa, protocol) = lsa.protocol;
	SCARG(&bsa, rsv) = lsa.rsv;

	return sys_socketpair(p, &bsa, retval);
}

int
linux_send(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_send_args /* {
		syscallarg(int) s;
		syscallarg(void *) msg;
		syscallarg(int) len;
		syscallarg(int) flags;
	} */ *uap = v;
	struct linux_send_args lsa;
	struct msghdr msg;
	struct iovec aiov;
	int error;

	if ((error = copyin((caddr_t) uap, (caddr_t) &lsa, sizeof lsa)))
		return error;

	msg.msg_name = 0;
	msg.msg_namelen = 0;
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = lsa.msg;
	aiov.iov_len = lsa.len;
	msg.msg_control = 0;
	msg.msg_flags = 0;

	return (sendit(p, lsa.s, &msg, linux_to_bsd_msg_flags(lsa.flags),
	    retval));
}

int
linux_recv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_recv_args /* {
		syscallarg(int) s;
		syscallarg(void *) msg;
		syscallarg(int) len;
		syscallarg(int) flags;
	} */ *uap = v;
	struct linux_recv_args lra;
	struct msghdr msg;
	struct iovec aiov;
	int error;

	if ((error = copyin((caddr_t) uap, (caddr_t) &lra, sizeof lra)))
		return error;

	msg.msg_name = 0;
	msg.msg_namelen = 0;
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = lra.msg;
	aiov.iov_len = lra.len;
	msg.msg_control = 0;
	msg.msg_flags = linux_to_bsd_msg_flags(lra.flags);

	return (recvit(p, lra.s, &msg, NULL, retval));
}

int
linux_check_hdrincl(p, fd, retval, sgp)
	struct proc *p;
	int fd;
	register_t *retval;
	caddr_t *sgp;
{
	struct sys_getsockopt_args /* {
		int s;
		int level;
		int name;
		caddr_t val;
		int *avalsize;
	} */ gsa;
	int error;
	caddr_t val;
	int *valsize;
	int size_val = sizeof val;
	int optval;

	val = stackgap_alloc(sgp, sizeof(optval));
	valsize = stackgap_alloc(sgp, sizeof(size_val));

	if ((error = copyout(&size_val, valsize, sizeof(size_val))))
		return (error);
	SCARG(&gsa, s) = fd;
	SCARG(&gsa, level) = IPPROTO_IP;
	SCARG(&gsa, name) = IP_HDRINCL;
	SCARG(&gsa, val) = val;
	SCARG(&gsa, avalsize) = valsize;

	if ((error = sys_getsockopt(p, &gsa, retval)))
		return (error);
	if ((error = copyin(val, &optval, sizeof(optval))))
		return (error);
	return (optval == 0);
}

/*
 * linux_ip_copysize defines how many bytes we should copy
 * from the beginning of the IP packet before we customize it for BSD.
 * It should include all the fields we modify (ip_len and ip_off)
 * and be as small as possible to minimize copying overhead.
 */
#define linux_ip_copysize      8

int
linux_sendto_hdrincl(p, bsa, retval, sgp)
	struct proc *p;
	struct sys_sendto_args *bsa;
	register_t *retval;
	caddr_t *sgp;
{
	struct sys_sendmsg_args ssa;
	struct ip *packet, rpacket;
	struct msghdr *msg, rmsg;
	struct iovec *iov, riov[2];
	int error;

	/* Check the packet isn't too small before we mess with it */
	if (SCARG(bsa, len) < linux_ip_copysize)
		return EINVAL;

	/*
	 * Tweaking the user buffer in place would be bad manners.
	 * We create a corrected IP header with just the needed length,
	 * then use an iovec to glue it to the rest of the user packet
	 * when calling sendmsg().
	 */
	packet = (struct ip *)stackgap_alloc(sgp, linux_ip_copysize);
	msg = (struct msghdr *)stackgap_alloc(sgp, sizeof(*msg));
	iov = (struct iovec *)stackgap_alloc(sgp, sizeof(*iov)*2);

	/* Make a copy of the beginning of the packet to be sent */
	if ((error = copyin(SCARG(bsa, buf), (caddr_t)&rpacket,
	    linux_ip_copysize)))
		return error;

	/* Convert fields from Linux to BSD raw IP socket format */
	rpacket.ip_len = SCARG(bsa, len);
	error = copyout(&rpacket, packet, linux_ip_copysize);
	if (error)
		return (error);

	riov[0].iov_base = (char *)packet;
	riov[0].iov_len = linux_ip_copysize;
	riov[1].iov_base = (caddr_t)SCARG(bsa, buf) + linux_ip_copysize;
	riov[1].iov_len = SCARG(bsa, len) - linux_ip_copysize;

	error = copyout(&riov[0], iov, sizeof(riov));
	if (error)
		return (error);

	/* Prepare the msghdr and iovec structures describing the new packet */
	rmsg.msg_name = (void *)SCARG(bsa, to);
	rmsg.msg_namelen = SCARG(bsa, tolen);
	rmsg.msg_iov = iov;
	rmsg.msg_iovlen = 2;
	rmsg.msg_control = NULL;
	rmsg.msg_controllen = 0;
	rmsg.msg_flags = 0;

	error = copyout(&riov[0], iov, sizeof(riov));
	if (error)
		return (error);

	SCARG(&ssa, s) = SCARG(bsa, s);
	SCARG(&ssa, msg) = msg;
	SCARG(&ssa, flags) = SCARG(bsa, flags);
	return sys_sendmsg(p, &ssa, retval);
}

int
linux_sendto(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sendto_args /* {
		syscallarg(int) s;
		syscallarg(void *) msg;
		syscallarg(int) len;
		syscallarg(int) flags;
		syscallarg(linux_sockaddr *) to;
		syscallarg(int) tolen;
	} */ *uap = v;
	struct linux_sendto_args lsa;
	struct sys_sendto_args bsa;
	int error;
	int tolen;
	caddr_t sg = stackgap_init(p);

	if ((error = copyin((caddr_t) uap, (caddr_t) &lsa, sizeof lsa)))
		return error;

	SCARG(&bsa, s) = lsa.s;
	SCARG(&bsa, buf) = lsa.msg;
	SCARG(&bsa, len) = lsa.len;
	SCARG(&bsa, flags) = linux_to_bsd_msg_flags(lsa.flags);
	tolen = lsa.tolen;
	if (lsa.to) {
		struct sockaddr *sa;

		if ((error = linux_sa_get(p, &sg, &sa, lsa.to, &tolen)))
			return (error);
		SCARG(&bsa, to) = sa;
	} else
		SCARG(&bsa, to) = NULL;
	SCARG(&bsa, tolen) = tolen;

	if (linux_check_hdrincl(p, lsa.s, retval, &sg) == 0)
		return linux_sendto_hdrincl(p, &bsa, retval, &sg);
	return sys_sendto(p, &bsa, retval);
}

int
linux_recvfrom(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_recvfrom_args /* {
		syscallarg(int) s;
		syscallarg(void *) buf;
		syscallarg(int) len;
		syscallarg(int) flags;
		syscallarg(struct sockaddr *) from;
		syscallarg(int *) fromlen;
	} */ *uap = v;
	struct linux_recvfrom_args lra;
	struct sys_recvfrom_args bra;
	int error;

	if ((error = copyin((caddr_t) uap, (caddr_t) &lra, sizeof lra)))
		return error;

	SCARG(&bra, s) = lra.s;
	SCARG(&bra, buf) = lra.buf;
	SCARG(&bra, len) = lra.len;
	SCARG(&bra, flags) = linux_to_bsd_msg_flags(lra.flags);
	SCARG(&bra, from) = lra.from;
	SCARG(&bra, fromlenaddr) = lra.fromlen;

	if ((error = sys_recvfrom(p, &bra, retval)))
		return (error);

	if (lra.from && (error = linux_sa_put(lra.from)))
		return (error);

	return (0);
}

int
linux_shutdown(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_shutdown_args /* {
		syscallarg(int) s;
		syscallarg(int) how;
	} */ *uap = v;
	struct linux_shutdown_args lsa;
	struct sys_shutdown_args bsa;
	int error;

	if ((error = copyin((caddr_t) uap, (caddr_t) &lsa, sizeof lsa)))
		return error;

	SCARG(&bsa, s) = lsa.s;
	SCARG(&bsa, how) = lsa.how;

	return sys_shutdown(p, &bsa, retval);
}

/*
 * Convert socket option level from Linux to OpenBSD value. Only SOL_SOCKET
 * is different, the rest matches IPPROTO_* on both systems.
 */
int
linux_to_bsd_sopt_level(llevel)
	int llevel;
{

	switch (llevel) {
	case LINUX_SOL_SOCKET:
		return SOL_SOCKET;
	case LINUX_SOL_IP:
		return IPPROTO_IP;
	case LINUX_SOL_TCP:
		return IPPROTO_TCP;
	case LINUX_SOL_UDP:
		return IPPROTO_UDP;
	default:
		return -1;
	}
}

/*
 * Convert Linux socket level socket option numbers to OpenBSD values.
 */
int
linux_to_bsd_so_sockopt(lopt)
	int lopt;
{

	switch (lopt) {
	case LINUX_SO_DEBUG:
		return SO_DEBUG;
	case LINUX_SO_REUSEADDR:
		/*
		 * Linux does not implement SO_REUSEPORT, but allows reuse
		 * of a host:port pair through SO_REUSEADDR even if the
		 * address is not a multicast-address.  Effectively, this
		 * means that we should use SO_REUSEPORT to allow Linux
		 * applications to not receive EADDRINUSE.
		 */
		return SO_REUSEPORT;
	case LINUX_SO_TYPE:
		return SO_TYPE;
	case LINUX_SO_ERROR:
		return SO_ERROR;
	case LINUX_SO_DONTROUTE:
		return SO_DONTROUTE;
	case LINUX_SO_BROADCAST:
		return SO_BROADCAST;
	case LINUX_SO_SNDBUF:
		return SO_SNDBUF;
	case LINUX_SO_RCVBUF:
		return SO_RCVBUF;
	case LINUX_SO_KEEPALIVE:
		return SO_KEEPALIVE;
	case LINUX_SO_OOBINLINE:
		return SO_OOBINLINE;
	case LINUX_SO_LINGER:
		return SO_LINGER;
	case LINUX_SO_PRIORITY:
	case LINUX_SO_NO_CHECK:
	default:
		return -1;
	}
}

/*
 * Convert Linux IP level socket option number to OpenBSD values.
 */
int
linux_to_bsd_ip_sockopt(lopt)
	int lopt;
{

	switch (lopt) {
	case LINUX_IP_TOS:
		return IP_TOS;
	case LINUX_IP_TTL:
		return IP_TTL;
	case LINUX_IP_MULTICAST_TTL:
		return IP_MULTICAST_TTL;
	case LINUX_IP_MULTICAST_LOOP:
		return IP_MULTICAST_LOOP;
	case LINUX_IP_MULTICAST_IF:
		return IP_MULTICAST_IF;
	case LINUX_IP_ADD_MEMBERSHIP:
		return IP_ADD_MEMBERSHIP;
	case LINUX_IP_DROP_MEMBERSHIP:
		return IP_DROP_MEMBERSHIP;
	case LINUX_IP_HDRINCL:
		return IP_HDRINCL;
	default:
		return -1;
	}
}

/*
 * Convert Linux TCP level socket option number to OpenBSD values.
 */
int
linux_to_bsd_tcp_sockopt(lopt)
	int lopt;
{

	switch (lopt) {
	case LINUX_TCP_NODELAY:
		return TCP_NODELAY;
	case LINUX_TCP_MAXSEG:
		return TCP_MAXSEG;
	default:
		return -1;
	}
}

/*
 * Convert Linux UDP level socket option number to OpenBSD values.
 */
int
linux_to_bsd_udp_sockopt(lopt)
	int lopt;
{

	switch (lopt) {
	default:
		return -1;
	}
}

/*
 * Another reasonably straightforward function: setsockopt(2).
 * The level and option numbers are converted; the values passed
 * are not (yet) converted, the ones currently implemented don't
 * need conversion, as they are the same on both systems.
 */
int
linux_setsockopt(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_setsockopt_args /* {
		syscallarg(int) s;
		syscallarg(int) level;
		syscallarg(int) optname;
		syscallarg(void *) optval;
		syscallarg(int) optlen;
	} */ *uap = v;
	struct linux_setsockopt_args lsa;
	struct file *fp;
	struct mbuf *m = NULL;
	struct socket *so;
	int error, level, name;

	if ((error = copyin((caddr_t) uap, (caddr_t) &lsa, sizeof lsa)))
		return error;

	if ((error = getsock(p, lsa.s, &fp)) != 0)
		return error;
	
	level = linux_to_bsd_sopt_level(lsa.level);
	switch (level) {
	case SOL_SOCKET:
		name = linux_to_bsd_so_sockopt(lsa.optname);
		break;
	case IPPROTO_IP:
		name = linux_to_bsd_ip_sockopt(lsa.optname);
		break;
	case IPPROTO_TCP:
		name = linux_to_bsd_tcp_sockopt(lsa.optname);
		break;
	case IPPROTO_UDP:
		name = linux_to_bsd_udp_sockopt(lsa.optname);
		break;
	default:
		error = EINVAL;
		goto bad;
	}
	if (name == -1) {
		error = EINVAL;
		goto bad;
	}
	if (lsa.optlen > MLEN) {
		error = EINVAL;
		goto bad;
	}
	if (lsa.optval != NULL) {
		m = m_get(M_WAIT, MT_SOOPTS);
		error = copyin(lsa.optval, mtod(m, caddr_t), lsa.optlen);
		if (error)
			goto bad;
		m->m_len = lsa.optlen;
	}
	so = (struct socket *)fp->f_data;
	if (so->so_proto && level == IPPROTO_TCP && name == TCP_NODELAY && 
	    so->so_proto->pr_domain->dom_family == AF_LOCAL &&
	    so->so_proto->pr_protocol == PF_LOCAL) {
		/* ignore it */
		error = 0;
		goto bad;
	}
	error = sosetopt(so, level, name, m);
	m = NULL;
bad:
	if (m)
		m_free(m);
	FRELE(fp, p);
	return (error);
}

/*
 * getsockopt(2) is very much the same as setsockopt(2) (see above)
 */
int
linux_getsockopt(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_getsockopt_args /* {
		syscallarg(int) s;
		syscallarg(int) level;
		syscallarg(int) optname;
		syscallarg(void *) optval;
		syscallarg(int) *optlen;
	} */ *uap = v;
	struct linux_getsockopt_args lga;
	struct sys_getsockopt_args bga;
	int error, name;

	if ((error = copyin((caddr_t) uap, (caddr_t) &lga, sizeof lga)))
		return error;

	SCARG(&bga, s) = lga.s;
	SCARG(&bga, level) = linux_to_bsd_sopt_level(lga.level);
	SCARG(&bga, val) = lga.optval;
	SCARG(&bga, avalsize) = lga.optlen;

	switch (SCARG(&bga, level)) {
	case SOL_SOCKET:
		name = linux_to_bsd_so_sockopt(lga.optname);
		break;
	case IPPROTO_IP:
		name = linux_to_bsd_ip_sockopt(lga.optname);
		break;
	case IPPROTO_TCP:
		name = linux_to_bsd_tcp_sockopt(lga.optname);
		break;
	case IPPROTO_UDP:
		name = linux_to_bsd_udp_sockopt(lga.optname);
		break;
	default:
		return EINVAL;
	}

	if (name == -1)
		return EINVAL;
	SCARG(&bga, name) = name;

	return sys_getsockopt(p, &bga, retval);
}

int
linux_recvmsg(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_recvmsg_args /* {
		syscallarg(int) s;
		syscallarg(caddr_t) msg;
		syscallarg(int) flags;
	} */ *uap = v;
	struct linux_recvmsg_args lla;
	struct sys_recvmsg_args bla;
	struct msghdr msg;
	int error;

	if ((error = copyin((caddr_t) uap, (caddr_t) &lla, sizeof lla)))
		return error;

	SCARG(&bla, s) = lla.s;
	SCARG(&bla, msg) = (struct msghdr *)lla.msg;
	SCARG(&bla, flags) = linux_to_bsd_msg_flags(lla.flags);

	error = sys_recvmsg(p, &bla, retval);
	if (error)
		return (error);

	error = copyin(lla.msg, (caddr_t)&msg, sizeof(msg));

	if (!error && msg.msg_name && msg.msg_namelen > 2)
		error = linux_sa_put(msg.msg_name);

	return (error);
}

int
linux_sendmsg(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sendmsg_args /* {
		syscallarg(int) s;
		syscallarg(struct msghdr *) msg;
		syscallarg(int) flags;
	} */ *uap = v;
	struct linux_sendmsg_args lla;
	struct sys_sendmsg_args bla;
	struct msghdr msg, *nmsg = NULL;
	int error;
	caddr_t control;
	int level = -1;

	if ((error = copyin((caddr_t) uap, (caddr_t) &lla, sizeof lla)))
		return error;

	if ((error = copyin(lla.msg, (caddr_t) &msg, sizeof(msg))))
		return (error);

	if (msg.msg_name) {
		struct sockaddr *sa;
		caddr_t sg = stackgap_init(p);

		nmsg = (struct msghdr *)stackgap_alloc(&sg,
		    sizeof(struct msghdr));
		if (!nmsg)
			return (ENOMEM);

		error = linux_sa_get(p, &sg, &sa,
		    (struct linux_sockaddr *)msg.msg_name, &msg.msg_namelen);
		if (error)
			return (error);

		msg.msg_name = sa;
		if ((error = copyout(&msg, nmsg, sizeof(struct msghdr))))
			return (error);
		lla.msg = nmsg;
	}

	SCARG(&bla, s) = lla.s;
	SCARG(&bla, msg) = lla.msg;
	SCARG(&bla, flags) = linux_to_bsd_msg_flags(lla.flags);

	error = copyin(lla.msg->msg_control, &control, sizeof(caddr_t));
	if (error)
		return error;
	if (control == NULL)
		goto done;
	error = copyin(&((struct cmsghdr *)control)->cmsg_level,
	    &level, sizeof(int));
	if (error)
		return error;
	if (level == 1) {
		/*
		 * Linux thinks that SOL_SOCKET is 1; we know that it's really
		 * 0xffff, of course.
		 */
		level = SOL_SOCKET;
		/*
		 * XXX should use stack gap!
		 * We don't because the control header is variable length
		 * up to 2048 bytes, and there's only 512 bytes of gap.
		 */
		error = copyout(&level, &((struct cmsghdr *)control)->
		    cmsg_level, sizeof(int));
		if (error)
			return error;
	}
done:
	error = sys_sendmsg(p, &bla, retval);
	/* replace level, just in case somebody cares. */
	if (level == SOL_SOCKET) {
		level = 1;
		/* don't worry about the error */
		copyout(&level, &((struct cmsghdr *)control)->cmsg_level,
		    sizeof(int));
	}
	return (error);
}

/*
 * Copy the linux_sockaddr structure pointed to by osa to kernel, adjust
 * family and convert to sockaddr, allocate stackgap and put the
 * the converted structure there.  Address on stackgap returned in sap.
 */
int
linux_sa_get(struct proc *p, caddr_t *sgp, struct sockaddr **sap,
    const struct linux_sockaddr *osa, int *osalen)
{
	int error, bdom;
	struct sockaddr *sa, *usa;
	struct linux_sockaddr *kosa;
	int alloclen;
#ifdef INET6
	int oldv6size;
	struct sockaddr_in6 *sin6;
#endif

	if (*osalen < 2 || *osalen > UCHAR_MAX || !osa) {
		return (EINVAL);
	}

	if (osa->sa_family == AF_UNIX && *osalen > sizeof(struct sockaddr_un))
		alloclen = sizeof(struct sockaddr_un);
	else
		alloclen = *osalen;
#ifdef INET6
	oldv6size = 0;
	/*
	 * Check for old (pre-RFC2553) sockaddr_in6. We may accept it
	 * if it's a v4-mapped address, so reserve the proper space
	 * for it.
	 */
	if (alloclen == sizeof (struct sockaddr_in6) - sizeof (u_int32_t)) {
		alloclen = sizeof (struct sockaddr_in6);
		oldv6size = 1;
	}
#endif

	kosa = malloc(alloclen, M_TEMP, M_WAITOK);

	if ((error = copyin(osa, (caddr_t) kosa, *osalen))) {
		goto out;
	}

	bdom = linux_to_bsd_domain(kosa->sa_family);
	if (bdom == -1) {
		error = EINVAL;
		goto out;
	}

#ifdef INET6
	/*
	 * Older Linux IPv6 code uses obsolete RFC2133 struct sockaddr_in6,
	 * which lacks the scope id compared with RFC2553 one. If we detect
	 * the situation, reject the address.
	 *
	 * Still accept addresses for which the scope id is not used.
	 */
	if (oldv6size && bdom == AF_INET6) {
		sin6 = (struct sockaddr_in6 *)kosa;
		if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr) ||
		    (!IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr) &&
		     !IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr) &&
		     !IN6_IS_ADDR_V4COMPAT(&sin6->sin6_addr) &&
		     !IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) &&
		     !IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr))) {
			sin6->sin6_scope_id = 0;
		} else {
			error = EINVAL;
			goto out;
		}
	} else
#endif 
	if (bdom == AF_INET) {
		alloclen = sizeof(struct sockaddr_in);
	}

	sa = (struct sockaddr *) kosa;
	sa->sa_family = bdom;
	sa->sa_len = alloclen;

	usa = (struct sockaddr *) stackgap_alloc(sgp, alloclen);
	if (!usa) {
		error = ENOMEM;
		goto out;
	}

	if ((error = copyout(sa, usa, alloclen))) {
		goto out;
	}

	*sap = usa;

    out:
	*osalen = alloclen;
	free(kosa, M_TEMP, 0);
	return (error);
}

int
linux_sa_put(struct sockaddr *osa)
{
	struct sockaddr sa;
	struct linux_sockaddr *kosa;
	int error, bdom, len;

	/*
	 * Only read/write the sockaddr family and length part, the rest is
	 * not changed.
	 */
	len = sizeof(sa.sa_len) + sizeof(sa.sa_family);

	error = copyin((caddr_t) osa, (caddr_t) &sa, len);
	if (error)
		return (error);

	bdom = bsd_to_linux_domain(sa.sa_family);
	if (bdom == -1)
		return (EINVAL);

	/* Note: we convert from sockaddr to linux_sockaddr here, too */
	kosa = (struct linux_sockaddr *) &sa;
	kosa->sa_family = bdom;
	error = copyout(kosa, osa, len);
	if (error)
		return (error);

	return (0);
}

/*
 * Entry point to all Linux socket calls. Just check which call to
 * make and take appropriate action.
 */
int
linux_sys_socketcall(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_socketcall_args /* {
		syscallarg(int) what;
		syscallarg(void *) args;
	} */ *uap = v;

	switch (SCARG(uap, what)) {
	case LINUX_SYS_socket:
		return linux_socket(p, SCARG(uap, args), retval);
	case LINUX_SYS_bind:
		return linux_bind(p, SCARG(uap, args), retval);
	case LINUX_SYS_connect:
		return linux_connect(p, SCARG(uap, args), retval);
	case LINUX_SYS_listen:
		return linux_listen(p, SCARG(uap, args), retval);
	case LINUX_SYS_accept:
		return linux_accept(p, SCARG(uap, args), retval);
	case LINUX_SYS_getsockname:
		return linux_getsockname(p, SCARG(uap, args), retval);
	case LINUX_SYS_getpeername:
		return linux_getpeername(p, SCARG(uap, args), retval);
	case LINUX_SYS_socketpair:
		return linux_socketpair(p, SCARG(uap, args), retval);
	case LINUX_SYS_send:
		return linux_send(p, SCARG(uap, args), retval);
	case LINUX_SYS_recv:
		return linux_recv(p, SCARG(uap, args), retval);
	case LINUX_SYS_sendto:
		return linux_sendto(p, SCARG(uap, args), retval);
	case LINUX_SYS_recvfrom:
		return linux_recvfrom(p, SCARG(uap, args), retval);
	case LINUX_SYS_shutdown:
		return linux_shutdown(p, SCARG(uap, args), retval);
	case LINUX_SYS_setsockopt:
		return linux_setsockopt(p, SCARG(uap, args), retval);
	case LINUX_SYS_getsockopt:
		return linux_getsockopt(p, SCARG(uap, args), retval);
	case LINUX_SYS_sendmsg:
		return linux_sendmsg(p, SCARG(uap, args), retval);
	case LINUX_SYS_recvmsg:
		return linux_recvmsg(p, SCARG(uap, args), retval);
	default:
		return ENOSYS;
	}
}

int
linux_ioctl_socket(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_ioctl_args /* {
		syscallarg(int) fd;
		syscallarg(u_long) com;
		syscallarg(caddr_t) data;
	} */ *uap = v;
	u_long com;
	struct sys_ioctl_args ia;
	struct file *fp;
	struct filedesc *fdp;
	struct vnode *vp;
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *);
	struct ioctl_pt pt;
	void *data = SCARG(uap, data);
	int error = 0, isdev = 0, dosys = 1;

	fdp = p->p_fd;
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return (EBADF);
	FREF(fp);

	if (fp->f_type == DTYPE_VNODE) {
		vp = (struct vnode *)fp->f_data;
		isdev = vp->v_type == VCHR;
	}

	/*
	 * Don't try to interpret socket ioctl calls that are done
	 * on a device file descriptor, just pass them through, to
	 * emulate Linux behaviour. Use PTIOCLINUX so that the
	 * device will only handle these if it's prepared to do
	 * so, to avoid unexpected things from happening.
	 */
	if (isdev) {
		dosys = 0;
		ioctlf = fp->f_ops->fo_ioctl;
		pt.com = SCARG(uap, com);
		pt.data = data;
		error = ioctlf(fp, PTIOCLINUX, (caddr_t)&pt, p);
		/*
		 * XXX hack: if the function returns EJUSTRETURN,       
		 * it has stuffed a sysctl return value in pt.data.
		 */
		if (error == EJUSTRETURN) {
			retval[0] = (register_t)pt.data;
			error = 0;
		}
		goto out;
	}

	com = SCARG(uap, com);
	retval[0] = 0;

	switch (com) {
	case LINUX_FIOSETOWN:
		SCARG(&ia, com) = FIOSETOWN;
		break;
	case LINUX_SIOCSPGRP:
		SCARG(&ia, com) = SIOCSPGRP;
		break;
	case LINUX_FIOGETOWN:
		SCARG(&ia, com) = FIOGETOWN;
		break;
	case LINUX_SIOCGPGRP:
		SCARG(&ia, com) = SIOCGPGRP;
		break;
	case LINUX_SIOCATMARK:
		SCARG(&ia, com) = SIOCATMARK;
		break;
#if 0
	case LINUX_SIOCGSTAMP:
		SCARG(&ia, com) = SIOCGSTAMP;
		break;
#endif
	case LINUX_SIOCGIFCONF:
		SCARG(&ia, com) = OSIOCGIFCONF;
		break;
	case LINUX_SIOCGIFFLAGS:
		SCARG(&ia, com) = SIOCGIFFLAGS;
		break;
	case LINUX_SIOCGIFADDR:
		SCARG(&ia, com) = SIOCGIFADDR;
		break;
	case LINUX_SIOCGIFDSTADDR:
		SCARG(&ia, com) = SIOCGIFDSTADDR;
		break;
	case LINUX_SIOCGIFBRDADDR:
		SCARG(&ia, com) = SIOCGIFBRDADDR;
		break;
	case LINUX_SIOCGIFNETMASK:
		SCARG(&ia, com) = SIOCGIFNETMASK;
		break;
	case LINUX_SIOCGIFMETRIC:
		SCARG(&ia, com) = SIOCGIFMETRIC;
		break;
	case LINUX_SIOCGIFMTU:
		SCARG(&ia, com) = SIOCGIFMTU;
		break;
	case LINUX_SIOCADDMULTI:
		SCARG(&ia, com) = SIOCADDMULTI;
		break;
	case LINUX_SIOCDELMULTI:
		SCARG(&ia, com) = SIOCDELMULTI;
		break;
	case LINUX_SIOCGIFHWADDR: {
		struct linux_ifreq *ifr = data;
		struct sockaddr_dl *sdl;
		struct ifnet *ifp;

		/* 
		 * Note that we don't actually respect the name in the ifreq
		 * structure, as Linux interface names are all different.
		 */
		TAILQ_FOREACH(ifp, &ifnet, if_list) {
			if (ifp->if_type != IFT_ETHER)
				continue;
			if ((sdl = ifp->if_sadl) &&
			    (sdl->sdl_family == AF_LINK) &&
			    (sdl->sdl_type == IFT_ETHER)) {
				error = copyout(LLADDR(sdl),
				    &ifr->ifr_hwaddr.sa_data,
				    LINUX_IFHWADDRLEN);
				dosys = 0;
				goto out;
			}
		}
		error = ENOENT;
		break;
	    }
	default:
		error = EINVAL;
	}

out:
	if (error == 0 && dosys) {
		SCARG(&ia, fd) = SCARG(uap, fd);
		SCARG(&ia, data) = data;
		error = sys_ioctl(p, &ia, retval);

		if (error == 0) {
			struct ifreq *ifr = data;

			switch (com) {
			case LINUX_SIOCGIFADDR:
			case LINUX_SIOCGIFDSTADDR:
			case LINUX_SIOCGIFBRDADDR:
			case LINUX_SIOCGIFNETMASK:
				error = linux_sa_put(&ifr->ifr_addr);
				break;
			}
		}
	}

	FRELE(fp, p);
	return (error);
}
@


1.61
log
@Pass a thread pointer instead of its file descriptor table to getsock(9).

Diff from Vitaliy Makkoveev.

Manpage tweak and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.60 2015/01/30 23:38:49 millert Exp $	*/
@


1.60
log
@Fix mbuf leak in Linux compat setsockopt() in the error path when
optval is not valid.  Found by Maxime Villard.  OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.59 2015/01/21 13:47:45 mpi Exp $	*/
d940 1
a940 1
	if ((error = getsock(p->p_fd, lsa.s, &fp)) != 0)
@


1.59
log
@Ubreak the tree by using "struct ifreq" instead of "struct linux_ifreq".
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.58 2015/01/21 02:23:14 guenther Exp $	*/
d972 1
a972 2
		if (error) {
			(void) m_free(m);
a973 1
		}
d985 1
d987 2
@


1.58
log
@Delete option COMPAT_43: support for pre-sa_len binaries has been obsolete
for a couple decades.  Keep the OSIOCGIFCONF ioctl to support COMPAT_LINUX
but move the rest of the Linux-specific ioctl() handling into linux_socket.c
This lets struct osockaddr finally move from sys/socket.h to protocols/talkd.h

ok krw@@ deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.57 2015/01/19 23:30:20 guenther Exp $	*/
d1495 1
a1495 1
			struct linux_ifreq *ifr = data;
@


1.57
log
@Prefer linux_sockaddr over osockaddr, so the latter can go away.
sys_socket() supports SOCK_{CLOEXEC,NONBLOCK} now, so build on that.
doaccept() supports the non-inheriting-of-O_NONBLOCK, so build on that.
Merge compat_sys_{accept,send,recv}() into their only callers.
Lie a little and use struct sockaddr in the linux socket syscall args when
 it's a return argument to avoid a bunch a casts.
Delete many other unnecessary sockaddr casts

verified with a curl Linux binary
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.56 2014/12/05 15:50:03 mpi Exp $	*/
d1368 1
d1392 1
a1392 1
		pt.data = SCARG(uap, data);
d1436 1
a1436 1
		SCARG(&ia, com) = OSIOCGIFADDR;
d1439 1
a1439 1
		SCARG(&ia, com) = OSIOCGIFDSTADDR;
d1442 1
a1442 1
		SCARG(&ia, com) = OSIOCGIFBRDADDR;
d1445 1
a1445 1
		SCARG(&ia, com) = OSIOCGIFNETMASK;
d1460 1
a1460 1
		struct linux_ifreq *ifr = (struct linux_ifreq *)SCARG(uap, data);
d1491 1
a1491 1
		SCARG(&ia, data) = SCARG(uap, data);
d1493 13
@


1.56
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.55 2014/10/25 03:29:32 lteo Exp $	*/
d116 2
a117 2
    const struct osockaddr *, int *);
int linux_sa_put(struct osockaddr *);
d240 1
a240 3
	struct sys_fcntl_args bfa;
	struct sys_close_args bca;
	int error, type_flags, fd;
d242 1
a242 1
	if ((error = copyin((caddr_t) uap, (caddr_t) &lsa, sizeof lsa)))
a244 4
	type_flags = lsa.type & ~LINUX_SOCKET_TYPE_MASK;
	if (type_flags & ~(LINUX_SOCK_CLOEXEC | LINUX_SOCK_NONBLOCK))
		return EINVAL;

d249 1
a249 13
		return EINVAL;
	error = sys_socket(p, &bsa, retval);
	if (error)
		return error;
	
	fd = SCARG(&bfa, fd) = retval[0];
	if (type_flags & LINUX_SOCK_NONBLOCK) {
		SCARG(&bfa, cmd) = F_SETFL;
		SCARG(&bfa, arg) = (void *)O_NONBLOCK;
		error = sys_fcntl(p, &bfa, retval);
		if (error)
			goto err;
	}
d251 7
a257 9
	if (type_flags & LINUX_SOCK_CLOEXEC) {
		SCARG(&bfa, cmd) = F_SETFD;
		SCARG(&bfa, arg) = (void *)FD_CLOEXEC;
		error = sys_fcntl(p, &bfa, retval);
		if (error)
			goto err;
	}
	retval[0] = fd;
	return error;
d259 1
a259 5
err:
	SCARG(&bca, fd) = fd;
	sys_close(p, &bca, retval);
	retval[0] = -1;
	return error;
d270 1
a270 1
		syscallarg(struct sockaddr *) name;
d306 1
a306 1
		syscallarg(struct osockaddr *) name;
a391 28
int compat_sys_accept(struct proc *p, void *v, register_t *retval);
int
compat_sys_accept(struct proc *p, void *v, register_t *retval)
{
	struct sys_accept_args /* {
		syscallarg(int) s;
		syscallarg(caddr_t) name;
		syscallarg(int *) anamelen;
	} */ *uap = v;
	int error;

	if ((error = sys_accept(p, uap, retval)) != 0)
		return error;

	if (SCARG(uap, name)) {
		struct sockaddr sa;

		if ((error = copyin(SCARG(uap, name), &sa, sizeof(sa))) != 0)
			return error;

		((struct osockaddr*) &sa)->sa_family = sa.sa_family;

		if ((error = copyout(&sa, SCARG(uap, name), sizeof(sa))) != 0)
			return error;
	}
	return 0;
}

a403 2
	struct sys_accept_args baa;
	struct sys_fcntl_args fca;
d409 1
a409 6
	SCARG(&baa, s) = laa.s;
	SCARG(&baa, name) = laa.addr;
	SCARG(&baa, anamelen) = laa.namelen;

	error = compat_sys_accept(p, &baa, retval);
	if (error)
d412 1
a412 11
	/*
	 * linux appears not to copy flags from the parent socket to the
	 * accepted one, so we must clear the flags in the new descriptor.
	 * Ignore any errors, because we already have an open fd.
	 */
	SCARG(&fca, fd) = *retval;
	SCARG(&fca, cmd) = F_SETFL;
	SCARG(&fca, arg) = 0;
	(void)sys_fcntl(p, &fca, retval);
	*retval = SCARG(&fca, fd);
	return (0);
d423 1
a423 1
		syscallarg(caddr_t) addr;
d434 1
a434 1
	SCARG(&bga, asa) = (struct sockaddr *) lga.addr;
d441 1
a441 4
	if ((error = linux_sa_put((struct osockaddr *)lga.addr)))
		return (error);

	return (0);
d459 1
a459 1
	if ((error = copyin((caddr_t) uap, (caddr_t) &lga, sizeof lga)))
d463 1
a463 1
	SCARG(&bga, asa) = (struct sockaddr *) lga.addr;
d470 1
a470 4
	if ((error = linux_sa_put((struct osockaddr *)lga.addr)))
		return (error);

	return (0);
a501 28
int compat_sys_send(struct proc *, void *, register_t *);
struct compat_sys_send_args {
	syscallarg(int) s;
	syscallarg(caddr_t) buf;
	syscallarg(int) len;
	syscallarg(int) flags;
};
int
compat_sys_send(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct compat_sys_send_args *uap = v;
	struct msghdr msg;
	struct iovec aiov;

	msg.msg_name = 0;
	msg.msg_namelen = 0;
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = SCARG(uap, buf);
	aiov.iov_len = SCARG(uap, len);
	msg.msg_control = 0;
	msg.msg_flags = 0;
	return (sendit(p, SCARG(uap, s), &msg, SCARG(uap, flags), retval));
}

a513 1
	struct compat_sys_send_args bsa;
d515 2
a521 25
	SCARG(&bsa, s) = lsa.s;
	SCARG(&bsa, buf) = lsa.msg;
	SCARG(&bsa, len) = lsa.len;
	SCARG(&bsa, flags) = linux_to_bsd_msg_flags(lsa.flags);

	return compat_sys_send(p, &bsa, retval);
}

struct compat_sys_recv_args {
	syscallarg(int) s;
	syscallarg(caddr_t) buf;
	syscallarg(int) len;
	syscallarg(int) flags;
};
int compat_sys_recv(struct proc *p, void *v, register_t *retval);
int
compat_sys_recv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct compat_sys_recv_args *uap = v;
	struct msghdr msg;
	struct iovec aiov;

d526 2
a527 2
	aiov.iov_base = SCARG(uap, buf);
	aiov.iov_len = SCARG(uap, len);
d529 4
a532 2
	msg.msg_flags = SCARG(uap, flags);
	return (recvit(p, SCARG(uap, s), &msg, (caddr_t)0, retval));
d548 2
a549 1
	struct compat_sys_recv_args bra;
d555 8
a562 4
	SCARG(&bra, s) = lra.s;
	SCARG(&bra, buf) = lra.msg;
	SCARG(&bra, len) = lra.len;
	SCARG(&bra, flags) = linux_to_bsd_msg_flags(lra.flags);
d564 1
a564 1
	return compat_sys_recv(p, &bra, retval);
d690 1
a690 1
		syscallarg(osockaddr *) to;
d733 1
a733 1
		syscallarg(struct osockaddr *) from;
d747 1
a747 1
	SCARG(&bra, from) = (struct sockaddr *) lra.from;
d1113 1
a1113 1
		    (struct osockaddr *)msg.msg_name, &msg.msg_namelen);
d1117 1
a1117 1
		msg.msg_name = (struct sockaddr *)sa;
d1165 1
a1165 1
 * Copy the osockaddr structure pointed to by osa to kernel, adjust
d1170 2
a1171 6
linux_sa_get(p, sgp, sap, osa, osalen)
	struct proc *p;
	caddr_t *sgp;
	struct sockaddr **sap;
	const struct osockaddr *osa;
	int *osalen;
d1173 1
a1173 1
	int error=0, bdom;
d1175 1
a1175 1
	struct osockaddr *kosa;
d1203 1
a1203 1
	kosa = (struct osockaddr *) malloc(alloclen, M_TEMP, M_WAITOK);
d1265 1
a1265 2
linux_sa_put(osa)
	struct osockaddr *osa;
d1268 1
a1268 1
	struct osockaddr *kosa;
d1285 2
a1286 2
	/* Note: we convert from sockaddr to osockaddr here, too */
	kosa = (struct osockaddr *) &sa;
@


1.55
log
@Remove unnecessary netinet/in_systm.h include.

Compiles on i386, which is the only architecture where COMPAT_LINUX is
enabled at the moment.

"If it compiles, go ahead" pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.54 2014/09/10 04:39:50 mlarkin Exp $	*/
d52 1
@


1.54
log
@Avoid possible use of uninitialized variable.

From Maxime Villard via a post to tech@@ a long time ago

ok guenther@@, doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.53 2014/07/12 18:50:00 tedu Exp $	*/
a54 1
#include <netinet/in_systm.h>
@


1.53
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.52 2014/04/07 10:04:17 mpi Exp $	*/
d1215 1
a1215 1
	int level;
@


1.52
log
@Retire kernel support for SO_DONTROUTE, this time without breaking
localhost connections.

The plan is to always use the routing table for addresses and routes
resolutions, so there is no future for an option that wants to bypass
it.  This option has never been implemented for IPv6 anyway, so let's
just remove the IPv4 bits that you weren't aware of.

Tested a least by lteo@@, guenther@@ and chrisz@@, ok mikeb@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.50 2014/03/27 13:27:28 mpi Exp $	*/
d1384 1
a1384 1
	free(kosa, M_TEMP);
@


1.51
log
@revert "Retire kernel support for SO_DONTROUTE" diff, which does bad things
for localhost connections. discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.49 2014/03/26 05:23:42 guenther Exp $	*/
a217 2
	if (lflags & LINUX_MSG_DONTROUTE)
		flags |= MSG_DONTROUTE;
@


1.50
log
@Retire kernel support for SO_DONTROUTE, since the plan is to always
use the routing table there's no future for an option that wants to
bypass it.  This option has never been implemented for IPv6 anyway,
so let's just remove the IPv4 bits that you weren't aware of.

Tested by florian@@, man pages inputs from jmc@@, ok benno@@
@
text
@d218 2
@


1.49
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.48 2014/02/13 13:10:34 mpi Exp $	*/
a217 2
	if (lflags & LINUX_MSG_DONTROUTE)
		flags |= MSG_DONTROUTE;
@


1.48
log
@Instead of iterating over the per-interface list of addresses to
find the link-layer address of an interface, use the pointer to
the sockaddr_dl already present in the interface's descriptor.

Tested for regression by pirofti@@ with opera.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.47 2014/01/23 04:11:46 tedu Exp $	*/
d311 1
a311 1
		caddr_t sg = stackgap_init(p->p_emul);
d338 1
a338 1
	caddr_t sg = stackgap_init(p->p_emul);
d819 1
a819 1
	caddr_t sg = stackgap_init(p->p_emul);
d1227 1
a1227 1
		caddr_t sg = stackgap_init(p->p_emul);
@


1.47
log
@adjust a comment or two
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.46 2012/06/26 10:18:08 pirofti Exp $	*/
a1588 1
		struct ifaddr *ifa;
d1597 8
a1604 10
			TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
				if ((sdl = (struct sockaddr_dl *)ifa->ifa_addr) &&
				    (sdl->sdl_family == AF_LINK) &&
				    (sdl->sdl_type == IFT_ETHER)) {
					error = copyout(LLADDR(sdl),
					    (caddr_t)&ifr->ifr_hwaddr.sa_data,
					    LINUX_IFHWADDRLEN);
					dosys = 0;
					goto out;
				}
@


1.46
log
@Don't ignore SOCK_CLOEXEC and SOCK_NONBLOCK.

CAVEATS: Assumes that a new socket can't have any of the
FCNTLFLAGS set on it, which _is_ true, currently... (guenther@@)

Okay guenther@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.45 2012/06/19 11:28:20 pirofti Exp $	*/
d76 1
a76 1
 * call in Linux, represented here by linux_socketcall()
d181 1
a181 1
 * Convert between Linux and BSD socket domain values
d194 1
a194 1
 * Convert between BSD and Linux socket domain values
d207 1
a207 1
 * Convert between Linux and BSD MSG_XXX flags
d944 1
a944 1
		 * applications to not exit with EADDRINUSE.
d1289 1
a1289 1
 * the converted structure there, address on stackgap returned in sap.
d1509 1
a1509 1
	 * on a device filedescriptor, just pass them through, to
@


1.45
log
@Add socket type mask to filter out implementation specific flags.

The newer glibc's, when creating a socket, add some higher bit flags to
the type argument that are used for debug, statistics, profiling
whatever. They are not useful and implementation specific.

This is needed for DNS resolving, otherwise the nss library from glibc
will always fail to do the right thing.

Okay jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.44 2012/04/22 05:43:14 guenther Exp $	*/
d242 3
a244 1
	int error;
d249 4
d258 28
a285 1
	return sys_socket(p, &bsa, retval);
@


1.44
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.43 2011/12/03 12:38:30 fgsch Exp $	*/
d248 1
a248 1
	SCARG(&bsa, type) = lsa.type;
@


1.43
log
@add support for MSG_NOSIGNAL.
linux bits compiled on i386 by sebastia@@, mikeb@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.42 2011/09/19 22:37:03 pirofti Exp $	*/
d1077 1
a1077 1
	FRELE(fp);
d1591 1
a1591 1
	FRELE(fp);
@


1.42
log
@Fix Unix socket handling when the length is too large by trimming.

Okay claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.41 2011/07/09 00:47:18 henning Exp $	*/
d86 2
d206 23
d596 1
a596 1
	SCARG(&bsa, flags) = lsa.flags;
d651 1
a651 1
	SCARG(&bra, flags) = lra.flags;
d794 1
a794 1
	SCARG(&bsa, flags) = lsa.flags;
d835 1
a835 1
	SCARG(&bra, flags) = lra.flags;
d1154 1
a1154 1
	SCARG(&bla, flags) = lla.flags;
d1214 1
a1214 1
	SCARG(&bla, flags) = lla.flags;
@


1.41
log
@begone, fucking rotten appletalk shit. ok room
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.40 2011/07/07 01:19:39 tedu Exp $	*/
d50 1
d1254 4
a1257 1
	alloclen = *osalen;
@


1.40
log
@remove all the old COMPAT_43 syscalls.  The option itself remains for
the other things it enables.  Move a few old wrappers into linux compat
where they are still being used.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.39 2009/09/05 10:28:43 miod Exp $	*/
d122 1
a122 1
	AF_APPLETALK,
@


1.39
log
@Fix various cases of stackgap_alloc() size arguments not being computed
correctly, usually yielding the right value on 32 bit machines because
sizeof int == sizeof pointer.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.38 2009/02/19 19:04:34 deraadt Exp $	*/
d359 28
d399 1
a399 1
	struct compat_43_sys_accept_args baa;
d407 1
a407 1
	SCARG(&baa, name) = (caddr_t) laa.addr;
d410 1
a410 1
	error = compat_43_sys_accept(p, &baa, retval);
d520 28
d560 1
a561 1
	struct compat_43_sys_send_args bsa;
d572 29
a600 1
	return compat_43_sys_send(p, &bsa, retval);
d616 1
a616 1
	struct compat_43_sys_recv_args bra;
d627 1
a627 1
	return compat_43_sys_recv(p, &bra, retval);
@


1.38
log
@sys/types.h or sys/param.h MUST BE FIRST
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.37 2008/06/10 16:40:49 matthieu Exp $	*/
d315 1
a315 1
		statusl = stackgap_alloc(&sg, sizeof statusl);
@


1.37
log
@Allow linux binaries to call setsockopt(,TCPNODELAY,) on a AF_LOCAL
socket, since some of them do that. ok deraadt@@, henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.36 2007/06/06 09:59:21 henning Exp $	*/
d35 1
a36 1
#include <sys/param.h>
@


1.36
log
@put IPX in the unsupported boat
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.35 2006/03/05 21:48:56 miod Exp $	*/
d35 1
d45 1
d47 1
d911 4
a914 2
	struct sys_setsockopt_args bsa;
	int error, name;
d919 5
a923 6
	SCARG(&bsa, s) = lsa.s;
	SCARG(&bsa, level) = linux_to_bsd_sopt_level(lsa.level);
	SCARG(&bsa, val) = lsa.optval;
	SCARG(&bsa, valsize) = lsa.optlen;

	switch (SCARG(&bsa, level)) {
d937 27
a963 1
		return EINVAL;
d965 4
a968 6

	if (name == -1)
		return EINVAL;
	SCARG(&bsa, name) = name;

	return sys_setsockopt(p, &bsa, retval);
@


1.35
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.34 2005/11/21 18:16:37 millert Exp $	*/
d118 1
a118 1
	AF_IPX,
@


1.34
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.33 2005/06/07 02:30:47 henning Exp $	*/
d1421 1
a1421 2
		for (ifp = ifnet.tqh_first; ifp != 0;
		    ifp = ifp->if_list.tqe_next) {
d1424 1
a1424 2
			for (ifa = ifp->if_addrlist.tqh_first; ifa;
			    ifa = ifa->ifa_list.tqe_next) {
@


1.33
log
@remove CCITT handling
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.32 2004/07/08 15:11:37 tedu Exp $	*/
d44 1
a44 1
#include <sys/select.h>
@


1.32
log
@we don't care about copyout's success.  add a comment to appease sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.31 2003/11/25 21:43:42 nordin Exp $	*/
d117 1
a117 1
	AF_CCITT,	/* LINUX_AF_AX25 */
d123 1
a123 1
	AF_CCITT,	/* LINUX_AF_X25 */
d151 1
a151 1
	LINUX_AF_AX25,	/* AF_CCITT */
@


1.31
log
@Make SIOCGIFHWADDR work. ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.30 2003/07/24 01:31:36 tedu Exp $	*/
d1108 1
@


1.30
log
@after sys_sendmsg, change control message level back in case somebody looks
at it.  we don't use stackgap because control messages can be larger than
the gap, and it's just easier this way.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.29 2003/01/21 08:05:11 niklas Exp $	*/
d1411 1
a1411 1
		struct linux_ifreq *ifr = (struct linux_ifreq *)SCARG(&ia, data);
d1438 1
@


1.29
log
@Do not do multiple stackgap_init calls in the same syscall execution,
chances are big that entities allocated early should live longer than
later stackgap_init invocations.  This fixes UDP problems in Linux
emulation, most notably YP, and some DNS issues.
ok fgsch@@, jasoni@@ & pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.28 2002/12/10 23:21:16 fgsch Exp $	*/
d1071 1
d1093 5
a1097 1
		/* XXX should use stack gap! */
d1104 8
a1111 1
	return sys_sendmsg(p, &bla, retval);
@


1.28
log
@pass p->p_emul to stackgap_init(), not 0 to be consistent.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.27 2002/12/10 08:00:16 fgsch Exp $	*/
d105 1
a105 1
int linux_check_hdrincl(struct proc *, int, register_t *);
d107 1
a107 1
    register_t *);
d109 3
a111 3
int linux_sa_get(struct proc *, caddr_t *sgp, struct sockaddr **sap,
    const struct osockaddr *osa, int *osalen);
int linux_sa_put(struct osockaddr *osa);
a300 1
		caddr_t sg;
a310 1
		sg = stackgap_init(p->p_emul);
d544 1
a544 1
linux_check_hdrincl(p, fd, retval)
d548 1
d558 1
a558 1
	caddr_t sg, val;
d563 2
a564 3
	sg = stackgap_init(p->p_emul);
	val = stackgap_alloc(&sg, sizeof(optval));
	valsize = stackgap_alloc(&sg, sizeof(size_val));
d590 1
a590 1
linux_sendto_hdrincl(p, bsa, retval)
d594 1
a595 1
	caddr_t sg;
d612 3
a614 4
	sg = stackgap_init(p->p_emul);
	packet = (struct ip *)stackgap_alloc(&sg, linux_ip_copysize);
	msg = (struct msghdr *)stackgap_alloc(&sg, sizeof(*msg));
	iov = (struct iovec *)stackgap_alloc(&sg, sizeof(*iov)*2);
d673 1
a684 1
		caddr_t sg = stackgap_init(p->p_emul);
d693 2
a694 2
	if (linux_check_hdrincl(p, lsa.s, retval) == 0)
		return linux_sendto_hdrincl(p, &bsa, retval);
d1117 1
a1117 1
	struct osockaddr *kosa = (struct osockaddr *) &sa;
@


1.27
log
@fix setsockopt SO_REUSEADDR under linux emul; from NetBSD.
thanks to jpmp@@fibertel.com.ar for the testbed.  ish@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.25 2002/08/09 03:11:30 aaron Exp $	*/
d249 1
a249 1
		caddr_t sg = stackgap_init(0);
d276 1
a276 1
	caddr_t sg = stackgap_init(0);
d687 1
a687 1
		caddr_t sg = stackgap_init(0);
d1059 1
a1059 1
		caddr_t sg = stackgap_init(0);
@


1.26
log
@do address translation for for socket syscalls that pass addresses in
or out - this allows linux programs that use IPv6 to work (not ipv4
mapped addresses though)
- from NetBSD
@
text
@d796 8
a803 1
		return SO_REUSEADDR;
@


1.25
log
@Correct the size arg to copyout.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.24 2002/08/09 01:03:25 fgsch Exp $	*/
d79 3
a81 1
int linux_to_bsd_domain(int);
d109 65
d177 1
a177 1
int
d181 15
d197 1
a197 18
	switch (ldom) {
	case LINUX_AF_UNSPEC:
		return AF_UNSPEC;
	case LINUX_AF_UNIX:
		return AF_LOCAL;
	case LINUX_AF_INET:
		return AF_INET;
	case LINUX_AF_AX25:
		return AF_CCITT;
	case LINUX_AF_IPX:
		return AF_IPX;
	case LINUX_AF_APPLETALK:
		return AF_APPLETALK;
	case LINUX_AF_INET6:
		return AF_INET6;
	default:
		return -1;
	}
d240 1
d246 12
a257 2
	SCARG(&bba, name) = (void *) lba.name;
	SCARG(&bba, namelen) = lba.namelen;
d270 1
a270 1
		syscallarg(struct sockaddr *) name;
d275 3
d283 5
d289 2
a290 2
	SCARG(&bca, name) = (void *) lca.name;
	SCARG(&bca, namelen) = lca.namelen;
d406 1
a406 1
		syscallarg(struct sockaddr *) addr;
d410 1
a410 1
	struct compat_43_sys_getsockname_args bga;
d416 2
a417 2
	SCARG(&bga, fdec) = lga.s;
	SCARG(&bga, asa) = (caddr_t) lga.addr;
d420 8
a427 1
	return compat_43_sys_getsockname(p, &bga, retval);
d442 1
a442 1
	struct compat_43_sys_getpeername_args bga;
d449 1
a449 1
	SCARG(&bga, asa) = (caddr_t) lga.addr;
d452 8
a459 1
	return compat_43_sys_getpeername(p, &bga, retval);
d669 1
a669 1
		syscallarg(sockaddr *) to;
d675 1
d684 11
a694 2
	SCARG(&bsa, to) = (void *) lsa.to;
	SCARG(&bsa, tolen) = lsa.tolen;
d712 1
a712 1
		syscallarg(struct sockaddr *) from;
d716 1
a716 1
	struct compat_43_sys_recvfrom_args bra;
d726 1
a726 1
	SCARG(&bra, from) = (caddr_t) lra.from;
d729 7
a735 1
	return compat_43_sys_recvfrom(p, &bra, retval);
d1004 1
d1014 10
a1023 1
	return sys_recvmsg(p, &bla, retval);
d1039 1
d1046 23
d1096 133
@


1.24
log
@socket flags are not inherited via accept() on linux; found and tested
by gustavo, several ppl ok@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.23 2002/03/14 01:26:50 millert Exp $	*/
d528 1
a528 1
	error = copyout(&rpacket, packet, sizeof(packet));
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.22 2002/02/13 20:43:42 jasoni Exp $	*/
d287 1
d297 15
a311 1
	return compat_43_sys_accept(p, &baa, retval);
@


1.23.2.1
log
@Pull in patches from current:
Fix (aaron,fgsch):
- Correct the size arg to copyout.
- socket flags are not inherited via accept() on linux; found and tested
by gustavo, several ppl ok@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.23 2002/03/14 01:26:50 millert Exp $	*/
a286 1
	struct sys_fcntl_args fca;
d296 1
a296 15
	error = compat_43_sys_accept(p, &baa, retval);
	if (error)
		return (error);

	/*
	 * linux appears not to copy flags from the parent socket to the
	 * accepted one, so we must clear the flags in the new descriptor.
	 * Ignore any errors, because we already have an open fd.
	 */
	SCARG(&fca, fd) = *retval;
	SCARG(&fca, cmd) = F_SETFL;
	SCARG(&fca, arg) = 0;
	(void)sys_fcntl(p, &fca, retval);
	*retval = SCARG(&fca, fd);
	return (0);
d513 1
a513 1
	error = copyout(&rpacket, packet, linux_ip_copysize);
@


1.22
log
@FREF/FRELE where required due to fd_getfile.
- ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.21 2002/02/06 01:55:04 jasoni Exp $	*/
d79 27
a105 27
int linux_to_bsd_domain __P((int));
int linux_socket __P((struct proc *, void *, register_t *));
int linux_bind __P((struct proc *, void *, register_t *));
int linux_connect __P((struct proc *, void *, register_t *));
int linux_listen __P((struct proc *, void *, register_t *));
int linux_accept __P((struct proc *, void *, register_t *));
int linux_getsockname __P((struct proc *, void *, register_t *));
int linux_getpeername __P((struct proc *, void *, register_t *));
int linux_socketpair __P((struct proc *, void *, register_t *));
int linux_send __P((struct proc *, void *, register_t *));
int linux_recv __P((struct proc *, void *, register_t *));
int linux_sendto __P((struct proc *, void *, register_t *));
int linux_recvfrom __P((struct proc *, void *, register_t *));
int linux_shutdown __P((struct proc *, void *, register_t *));
int linux_to_bsd_sopt_level __P((int));
int linux_to_bsd_so_sockopt __P((int));
int linux_to_bsd_ip_sockopt __P((int));
int linux_to_bsd_tcp_sockopt __P((int));
int linux_to_bsd_udp_sockopt __P((int));
int linux_setsockopt __P((struct proc *, void *, register_t *));
int linux_getsockopt __P((struct proc *, void *, register_t *));
int linux_recvmsg __P((struct proc *, void *, register_t *));
int linux_sendmsg __P((struct proc *, void *, register_t *));

int linux_check_hdrincl __P((struct proc *, int, register_t *));
int linux_sendto_hdrincl __P((struct proc *, struct sys_sendto_args *,
    register_t *));
d1006 1
a1006 1
	int (*ioctlf) __P((struct file *, u_long, caddr_t, struct proc *));
@


1.21
log
@emulate linux behaviour by passing ioctl's down to the underlying device
> From NetBSD; ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.20 2001/06/21 01:43:57 itojun Exp $	*/
d996 1
a996 1
	register struct linux_sys_ioctl_args /* {
d1013 1
d1117 1
a1117 1
					return copyout(LLADDR(sdl),
d1120 2
d1125 1
a1125 1
		return ENOENT;
d1128 1
a1128 1
		return EINVAL;
d1138 1
@


1.20
log
@translate LINUX_AF_INET6 (10) into AF_INET6.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.19 2001/05/24 06:00:09 jasoni Exp $	*/
d1003 39
d1128 8
a1135 3
	SCARG(&ia, fd) = SCARG(uap, fd);
	SCARG(&ia, data) = SCARG(uap, data);
	return sys_ioctl(p, &ia, retval);
@


1.20.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.20 2001/06/21 01:43:57 itojun Exp $	*/
d79 27
a105 27
int linux_to_bsd_domain(int);
int linux_socket(struct proc *, void *, register_t *);
int linux_bind(struct proc *, void *, register_t *);
int linux_connect(struct proc *, void *, register_t *);
int linux_listen(struct proc *, void *, register_t *);
int linux_accept(struct proc *, void *, register_t *);
int linux_getsockname(struct proc *, void *, register_t *);
int linux_getpeername(struct proc *, void *, register_t *);
int linux_socketpair(struct proc *, void *, register_t *);
int linux_send(struct proc *, void *, register_t *);
int linux_recv(struct proc *, void *, register_t *);
int linux_sendto(struct proc *, void *, register_t *);
int linux_recvfrom(struct proc *, void *, register_t *);
int linux_shutdown(struct proc *, void *, register_t *);
int linux_to_bsd_sopt_level(int);
int linux_to_bsd_so_sockopt(int);
int linux_to_bsd_ip_sockopt(int);
int linux_to_bsd_tcp_sockopt(int);
int linux_to_bsd_udp_sockopt(int);
int linux_setsockopt(struct proc *, void *, register_t *);
int linux_getsockopt(struct proc *, void *, register_t *);
int linux_recvmsg(struct proc *, void *, register_t *);
int linux_sendmsg(struct proc *, void *, register_t *);

int linux_check_hdrincl(struct proc *, int, register_t *);
int linux_sendto_hdrincl(struct proc *, struct sys_sendto_args *,
    register_t *);
d996 1
a996 1
	struct linux_sys_ioctl_args /* {
a1002 40
	struct file *fp;
	struct filedesc *fdp;
	struct vnode *vp;
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *);
	struct ioctl_pt pt;
	int error = 0, isdev = 0, dosys = 1;

	fdp = p->p_fd;
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return (EBADF);
	FREF(fp);

	if (fp->f_type == DTYPE_VNODE) {
		vp = (struct vnode *)fp->f_data;
		isdev = vp->v_type == VCHR;
	}

	/*
	 * Don't try to interpret socket ioctl calls that are done
	 * on a device filedescriptor, just pass them through, to
	 * emulate Linux behaviour. Use PTIOCLINUX so that the
	 * device will only handle these if it's prepared to do
	 * so, to avoid unexpected things from happening.
	 */
	if (isdev) {
		dosys = 0;
		ioctlf = fp->f_ops->fo_ioctl;
		pt.com = SCARG(uap, com);
		pt.data = SCARG(uap, data);
		error = ioctlf(fp, PTIOCLINUX, (caddr_t)&pt, p);
		/*
		 * XXX hack: if the function returns EJUSTRETURN,       
		 * it has stuffed a sysctl return value in pt.data.
		 */
		if (error == EJUSTRETURN) {
			retval[0] = (register_t)pt.data;
			error = 0;
		}
		goto out;
	}
d1077 1
a1077 1
					error = copyout(LLADDR(sdl),
a1079 2
					dosys = 0;
					goto out;
d1083 1
a1083 1
		error = ENOENT;
d1086 1
a1086 8
		error = EINVAL;
	}

out:
	if (error == 0 && dosys) {
		SCARG(&ia, fd) = SCARG(uap, fd);
		SCARG(&ia, data) = SCARG(uap, data);
		error = sys_ioctl(p, &ia, retval);
d1089 3
a1091 2
	FRELE(fp);
	return (error);
@


1.20.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.20.4.1 2002/06/11 03:28:08 art Exp $	*/
a286 1
	struct sys_fcntl_args fca;
d296 1
a296 15
	error = compat_43_sys_accept(p, &baa, retval);
	if (error)
		return (error);

	/*
	 * linux appears not to copy flags from the parent socket to the
	 * accepted one, so we must clear the flags in the new descriptor.
	 * Ignore any errors, because we already have an open fd.
	 */
	SCARG(&fca, fd) = *retval;
	SCARG(&fca, cmd) = F_SETFL;
	SCARG(&fca, arg) = 0;
	(void)sys_fcntl(p, &fca, retval);
	*retval = SCARG(&fca, fd);
	return (0);
d513 1
a513 1
	error = copyout(&rpacket, packet, linux_ip_copysize);
@


1.20.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 1
a79 3
static int linux_to_bsd_domain (int);
static int bsd_to_linux_domain(int);

d103 1
a103 1
int linux_check_hdrincl(struct proc *, int, register_t *, caddr_t *);
d105 1
a105 66
    register_t *, caddr_t *);

int linux_sa_get(struct proc *, caddr_t *, struct sockaddr **,
    const struct osockaddr *, int *);
int linux_sa_put(struct osockaddr *);

static const int linux_to_bsd_domain_[LINUX_AF_MAX] = {
	AF_UNSPEC,
	AF_UNIX,
	AF_INET,
	AF_CCITT,	/* LINUX_AF_AX25 */
	AF_IPX,
	AF_APPLETALK,
	-1,		/* LINUX_AF_NETROM */
	-1,		/* LINUX_AF_BRIDGE */
	-1,		/* LINUX_AF_ATMPVC */
	AF_CCITT,	/* LINUX_AF_X25 */
	AF_INET6,
	-1,		/* LINUX_AF_ROSE */
	AF_DECnet,
	-1,		/* LINUX_AF_NETBEUI */
	-1,		/* LINUX_AF_SECURITY */
	-1,		/* pseudo_AF_KEY */
	AF_ROUTE,	/* LINUX_AF_NETLINK */
	-1,		/* LINUX_AF_PACKET */
	-1,		/* LINUX_AF_ASH */
	-1,		/* LINUX_AF_ECONET */
	-1,		/* LINUX_AF_ATMSVC */
	AF_SNA,
	/* rest up to LINUX_AF_MAX-1 is not allocated */
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

static const int bsd_to_linux_domain_[AF_MAX] = {
	LINUX_AF_UNSPEC,
	LINUX_AF_UNIX,
	LINUX_AF_INET,
	-1,		/* AF_IMPLINK */
	-1,		/* AF_PUP */
	-1,		/* AF_CHAOS */
	-1,		/* AF_NS */
	-1,		/* AF_ISO */
	-1,		/* AF_ECMA */
	-1,		/* AF_DATAKIT */
	LINUX_AF_AX25,	/* AF_CCITT */
	-1,		/* LINUX_AF_SNA */
	-1,		/* LINUX_AF_DECnet */
	-1,		/* AF_DLI */
	-1,		/* AF_LAT */
	-1,		/* AF_HYLINK */
	LINUX_AF_APPLETALK,
	-1,		/* LINUX_AF_NETLINK */
	-1,		/* AF_LINK */
	-1,		/* AF_XTP */
	-1,		/* AF_COIP */
	-1,		/* AF_CNT */
	-1,		/* pseudo_AF_RTIP */
	LINUX_AF_IPX,
	LINUX_AF_INET6,
	-1,		/* pseudo_AF_PIP */
	-1,		/* AF_ISDN */
	-1,		/* AF_NATM */
	-1,		/* AF_ARP */
	-1,		/* LINUX_pseudo_AF_KEY */
	-1,		/* pseudo_AF_HDRCMPLT */
};
d110 1
a110 1
static int
a113 2
	if (ldom < 0 || ldom >= LINUX_AF_MAX)
		return (-1);
d115 18
a132 14
	return linux_to_bsd_domain_[ldom];
}

/*
 * Convert between BSD and Linux socket domain values
 */
static int
bsd_to_linux_domain(bdom)
	int bdom;
{
	if (bdom < 0 || bdom >= AF_MAX)
		return (-1);

	return bsd_to_linux_domain_[bdom];
a174 1
	int namlen;
d180 2
a181 12
	namlen = lba.namelen;
	if (lba.name) {
		struct sockaddr *sa;
		caddr_t sg = stackgap_init(p->p_emul);

		error = linux_sa_get(p, &sg, &sa, lba.name, &namlen);
		if (error)
			return (error);
		SCARG(&bba, name) = sa;
	} else
		SCARG(&bba, name) = NULL;
	SCARG(&bba, namelen) = namlen;
d194 1
a194 1
		syscallarg(struct osockaddr *) name;
a198 3
	struct sockaddr *sa;
	caddr_t sg = stackgap_init(p->p_emul);
	int namlen;
a203 5
	namlen = lca.namelen;
	error = linux_sa_get(p, &sg, &sa, lca.name, &namlen);
	if (error)
		return (error);

d205 2
a206 2
	SCARG(&bca, name) = sa;
	SCARG(&bca, namelen) = (unsigned int)namlen;
d217 1
d228 1
d322 1
a322 1
		syscallarg(caddr_t) addr;
d326 1
a326 1
	struct sys_getsockname_args bga;
d332 2
a333 2
	SCARG(&bga, fdes) = lga.s;
	SCARG(&bga, asa) = (struct sockaddr *) lga.addr;
d336 1
a336 8
	error = sys_getsockname(p, &bga, retval);
	if (error)
		return (error);

	if ((error = linux_sa_put((struct osockaddr *)lga.addr)))
		return (error);

	return (0);
d351 1
a351 1
	struct sys_getpeername_args bga;
d358 1
a358 1
	SCARG(&bga, asa) = (struct sockaddr *) lga.addr;
d361 1
a361 8
	error = sys_getpeername(p, &bga, retval);
	if (error)
		return (error);

	if ((error = linux_sa_put((struct osockaddr *)lga.addr)))
		return (error);

	return (0);
d448 1
a448 1
linux_check_hdrincl(p, fd, retval, sgp)
a451 1
	caddr_t *sgp;
d461 1
a461 1
	caddr_t val;
d466 3
a468 2
	val = stackgap_alloc(sgp, sizeof(optval));
	valsize = stackgap_alloc(sgp, sizeof(size_val));
d494 1
a494 1
linux_sendto_hdrincl(p, bsa, retval, sgp)
a497 1
	caddr_t *sgp;
d499 1
d516 4
a519 3
	packet = (struct ip *)stackgap_alloc(sgp, linux_ip_copysize);
	msg = (struct msghdr *)stackgap_alloc(sgp, sizeof(*msg));
	iov = (struct iovec *)stackgap_alloc(sgp, sizeof(*iov)*2);
d571 1
a571 1
		syscallarg(osockaddr *) to;
a576 2
	int tolen;
	caddr_t sg = stackgap_init(p->p_emul);
d585 2
a586 10
	tolen = lsa.tolen;
	if (lsa.to) {
		struct sockaddr *sa;

		if ((error = linux_sa_get(p, &sg, &sa, lsa.to, &tolen)))
			return (error);
		SCARG(&bsa, to) = sa;
	} else
		SCARG(&bsa, to) = NULL;
	SCARG(&bsa, tolen) = tolen;
d588 2
a589 2
	if (linux_check_hdrincl(p, lsa.s, retval, &sg) == 0)
		return linux_sendto_hdrincl(p, &bsa, retval, &sg);
d604 1
a604 1
		syscallarg(struct osockaddr *) from;
d608 1
a608 1
	struct sys_recvfrom_args bra;
d618 1
a618 1
	SCARG(&bra, from) = (struct sockaddr *) lra.from;
d621 1
a621 7
	if ((error = sys_recvfrom(p, &bra, retval)))
		return (error);

	if (lra.from && (error = linux_sa_put(lra.from)))
		return (error);

	return (0);
d682 1
a682 8
		/*
		 * Linux does not implement SO_REUSEPORT, but allows reuse
		 * of a host:port pair through SO_REUSEADDR even if the
		 * address is not a multicast-address.  Effectively, this
		 * means that we should use SO_REUSEPORT to allow Linux
		 * applications to not exit with EADDRINUSE.
		 */
		return SO_REUSEPORT;
a889 1
	struct msghdr msg;
d899 1
a899 10
	error = sys_recvmsg(p, &bla, retval);
	if (error)
		return (error);

	error = copyin(lla.msg, (caddr_t)&msg, sizeof(msg));

	if (!error && msg.msg_name && msg.msg_namelen > 2)
		error = linux_sa_put(msg.msg_name);

	return (error);
a914 1
	struct msghdr msg, *nmsg = NULL;
a920 23

	if ((error = copyin(lla.msg, (caddr_t) &msg, sizeof(msg))))
		return (error);

	if (msg.msg_name) {
		struct sockaddr *sa;
		caddr_t sg = stackgap_init(p->p_emul);

		nmsg = (struct msghdr *)stackgap_alloc(&sg,
		    sizeof(struct msghdr));
		if (!nmsg)
			return (ENOMEM);

		error = linux_sa_get(p, &sg, &sa,
		    (struct osockaddr *)msg.msg_name, &msg.msg_namelen);
		if (error)
			return (error);

		msg.msg_name = (struct sockaddr *)sa;
		if ((error = copyout(&msg, nmsg, sizeof(struct msghdr))))
			return (error);
	}

a947 133
}

/*
 * Copy the osockaddr structure pointed to by osa to kernel, adjust
 * family and convert to sockaddr, allocate stackgap and put the
 * the converted structure there, address on stackgap returned in sap.
 */
int
linux_sa_get(p, sgp, sap, osa, osalen)
	struct proc *p;
	caddr_t *sgp;
	struct sockaddr **sap;
	const struct osockaddr *osa;
	int *osalen;
{
	int error=0, bdom;
	struct sockaddr *sa, *usa;
	struct osockaddr *kosa;
	int alloclen;
#ifdef INET6
	int oldv6size;
	struct sockaddr_in6 *sin6;
#endif

	if (*osalen < 2 || *osalen > UCHAR_MAX || !osa) {
		return (EINVAL);
	}

	alloclen = *osalen;
#ifdef INET6
	oldv6size = 0;
	/*
	 * Check for old (pre-RFC2553) sockaddr_in6. We may accept it
	 * if it's a v4-mapped address, so reserve the proper space
	 * for it.
	 */
	if (alloclen == sizeof (struct sockaddr_in6) - sizeof (u_int32_t)) {
		alloclen = sizeof (struct sockaddr_in6);
		oldv6size = 1;
	}
#endif

	kosa = (struct osockaddr *) malloc(alloclen, M_TEMP, M_WAITOK);

	if ((error = copyin(osa, (caddr_t) kosa, *osalen))) {
		goto out;
	}

	bdom = linux_to_bsd_domain(kosa->sa_family);
	if (bdom == -1) {
		error = EINVAL;
		goto out;
	}

#ifdef INET6
	/*
	 * Older Linux IPv6 code uses obsolete RFC2133 struct sockaddr_in6,
	 * which lacks the scope id compared with RFC2553 one. If we detect
	 * the situation, reject the address.
	 *
	 * Still accept addresses for which the scope id is not used.
	 */
	if (oldv6size && bdom == AF_INET6) {
		sin6 = (struct sockaddr_in6 *)kosa;
		if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr) ||
		    (!IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr) &&
		     !IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr) &&
		     !IN6_IS_ADDR_V4COMPAT(&sin6->sin6_addr) &&
		     !IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) &&
		     !IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr))) {
			sin6->sin6_scope_id = 0;
		} else {
			error = EINVAL;
			goto out;
		}
	} else
#endif 
	if (bdom == AF_INET) {
		alloclen = sizeof(struct sockaddr_in);
	}

	sa = (struct sockaddr *) kosa;
	sa->sa_family = bdom;
	sa->sa_len = alloclen;

	usa = (struct sockaddr *) stackgap_alloc(sgp, alloclen);
	if (!usa) {
		error = ENOMEM;
		goto out;
	}

	if ((error = copyout(sa, usa, alloclen))) {
		goto out;
	}

	*sap = usa;

    out:
	*osalen = alloclen;
	free(kosa, M_TEMP);
	return (error);
}

int
linux_sa_put(osa)
	struct osockaddr *osa;
{
	struct sockaddr sa;
	struct osockaddr *kosa;
	int error, bdom, len;

	/*
	 * Only read/write the sockaddr family and length part, the rest is
	 * not changed.
	 */
	len = sizeof(sa.sa_len) + sizeof(sa.sa_family);

	error = copyin((caddr_t) osa, (caddr_t) &sa, len);
	if (error)
		return (error);

	bdom = bsd_to_linux_domain(sa.sa_family);
	if (bdom == -1)
		return (EINVAL);

	/* Note: we convert from sockaddr to osockaddr here, too */
	kosa = (struct osockaddr *) &sa;
	kosa->sa_family = bdom;
	error = copyout(kosa, osa, len);
	if (error)
		return (error);

	return (0);
@


1.19
log
@style/cleanup (of function headers)
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.18 2000/07/23 22:35:38 jasoni Exp $	*/
d128 2
@


1.18
log
@OpenBSD -> NetBSD where previously missed.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.17 1999/02/10 08:04:26 deraadt Exp $	*/
d80 13
a92 19
int linux_socket __P((struct proc *, struct linux_socket_args *, register_t *));
int linux_bind __P((struct proc *, struct linux_bind_args *, register_t *));
int linux_connect __P((struct proc *, struct linux_connect_args *,
    register_t *));
int linux_listen __P((struct proc *, struct linux_listen_args *, register_t *));
int linux_accept __P((struct proc *, struct linux_accept_args *, register_t *));
int linux_getsockname __P((struct proc *, struct linux_getsockname_args *,
    register_t *));
int linux_getpeername __P((struct proc *, struct linux_getpeername_args *,
    register_t *));
int linux_socketpair __P((struct proc *, struct linux_socketpair_args *,
    register_t *));
int linux_send __P((struct proc *, struct linux_send_args *, register_t *));
int linux_recv __P((struct proc *, struct linux_recv_args *, register_t *));
int linux_sendto __P((struct proc *, struct linux_sendto_args *, register_t *));
int linux_recvfrom __P((struct proc *, struct linux_recvfrom_args *,
    register_t *));
int linux_shutdown __P((struct proc *, struct linux_shutdown_args *,
    register_t *));
d98 4
a101 8
int linux_setsockopt __P((struct proc *, struct linux_setsockopt_args *,
    register_t *));
int linux_getsockopt __P((struct proc *, struct linux_getsockopt_args *,
    register_t *));
int linux_recvmsg __P((struct proc *, struct linux_recvmsg_args *,
    register_t *));
int linux_sendmsg __P((struct proc *, struct linux_sendmsg_args *,
    register_t *));
d134 1
a134 1
linux_socket(p, uap, retval)
d136 3
d143 1
a143 3
	} */ *uap;
	register_t *retval;
{
d160 1
a160 1
linux_bind(p, uap, retval)
d162 3
d169 1
a169 3
	} */ *uap;
	register_t *retval;
{
d185 1
a185 1
linux_connect(p, uap, retval)
d187 3
d194 1
a194 3
	} */ *uap;
	register_t *retval;
{
d250 1
a250 1
linux_listen(p, uap, retval)
d252 3
d258 1
a258 3
	} */ *uap;
	register_t *retval;
{
d273 1
a273 1
linux_accept(p, uap, retval)
d275 3
d282 1
a282 3
	} */ *uap;
	register_t *retval;
{
d298 1
a298 1
linux_getsockname(p, uap, retval)
d300 3
d307 1
a307 3
	} */ *uap;
	register_t *retval;
{
d323 1
a323 1
linux_getpeername(p, uap, retval)
d325 3
d332 1
a332 3
	} */ *uap;
	register_t *retval;
{
d348 1
a348 1
linux_socketpair(p, uap, retval)
d350 3
d358 1
a358 3
	} */ *uap;
	register_t *retval;
{
d377 1
a377 1
linux_send(p, uap, retval)
d379 3
d387 1
a387 3
	} */ *uap;
	register_t *retval;
{
d404 1
a404 1
linux_recv(p, uap, retval)
d406 3
d414 1
a414 3
	} */ *uap;
	register_t *retval;
{
d544 1
a544 1
linux_sendto(p, uap, retval)
d546 3
d556 1
a556 3
	} */ *uap;
	register_t *retval;
{
d577 1
a577 1
linux_recvfrom(p, uap, retval)
d579 3
d589 1
a589 3
	} */ *uap;
	register_t *retval;
{
d608 1
a608 1
linux_shutdown(p, uap, retval)
d610 3
d616 1
a616 3
	} */ *uap;
	register_t *retval;
{
d760 1
a760 1
linux_setsockopt(p, uap, retval)
d762 3
d771 1
a771 3
	} */ *uap;
	register_t *retval;
{
d812 1
a812 1
linux_getsockopt(p, uap, retval)
d814 3
d823 1
a823 3
	} */ *uap;
	register_t *retval;
{
d861 1
a861 1
linux_recvmsg(p, uap, retval)
d863 3
d870 1
a870 3
	} */ *uap;
	register_t *retval;
{
d886 1
a886 1
linux_sendmsg(p, uap, retval)
d888 3
d895 1
a895 3
	} */ *uap;
	register_t *retval;
{
d989 1
a989 1
linux_ioctl_socket(p, uap, retval)
d991 3
d998 1
a998 3
	} */ *uap;
	register_t *retval;
{
@


1.17
log
@more ioctl support
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.16 1999/02/10 08:04:04 deraadt Exp $	*/
d628 1
a628 1
 * Convert socket option level from Linux to NetBSD value. Only SOL_SOCKET
d651 1
a651 1
 * Convert Linux socket level socket option numbers to NetBSD values.
d689 1
a689 1
 * Convert Linux IP level socket option number to NetBSD values.
d719 1
a719 1
 * Convert Linux TCP level socket option number to NetBSD values.
d737 1
a737 1
 * Convert Linux UDP level socket option number to NetBSD values.
@


1.17.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.18 2000/07/23 22:35:38 jasoni Exp $	*/
d628 1
a628 1
 * Convert socket option level from Linux to OpenBSD value. Only SOL_SOCKET
d651 1
a651 1
 * Convert Linux socket level socket option numbers to OpenBSD values.
d689 1
a689 1
 * Convert Linux IP level socket option number to OpenBSD values.
d719 1
a719 1
 * Convert Linux TCP level socket option number to OpenBSD values.
d737 1
a737 1
 * Convert Linux UDP level socket option number to OpenBSD values.
@


1.17.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.17.6.1 2001/05/14 22:04:50 niklas Exp $	*/
d80 19
a98 13
int linux_socket __P((struct proc *, void *, register_t *));
int linux_bind __P((struct proc *, void *, register_t *));
int linux_connect __P((struct proc *, void *, register_t *));
int linux_listen __P((struct proc *, void *, register_t *));
int linux_accept __P((struct proc *, void *, register_t *));
int linux_getsockname __P((struct proc *, void *, register_t *));
int linux_getpeername __P((struct proc *, void *, register_t *));
int linux_socketpair __P((struct proc *, void *, register_t *));
int linux_send __P((struct proc *, void *, register_t *));
int linux_recv __P((struct proc *, void *, register_t *));
int linux_sendto __P((struct proc *, void *, register_t *));
int linux_recvfrom __P((struct proc *, void *, register_t *));
int linux_shutdown __P((struct proc *, void *, register_t *));
d104 8
a111 4
int linux_setsockopt __P((struct proc *, void *, register_t *));
int linux_getsockopt __P((struct proc *, void *, register_t *));
int linux_recvmsg __P((struct proc *, void *, register_t *));
int linux_sendmsg __P((struct proc *, void *, register_t *));
a137 2
	case LINUX_AF_INET6:
		return AF_INET6;
d144 1
a144 1
linux_socket(p, v, retval)
a145 3
	void *v;
	register_t *retval;
{
d150 3
a152 1
	} */ *uap = v;
d169 1
a169 1
linux_bind(p, v, retval)
a170 3
	void *v;
	register_t *retval;
{
d175 3
a177 1
	} */ *uap = v;
d193 1
a193 1
linux_connect(p, v, retval)
a194 3
	void *v;
	register_t *retval;
{
d199 3
a201 1
	} */ *uap = v;
d257 1
a257 1
linux_listen(p, v, retval)
a258 3
	void *v;
	register_t *retval;
{
d262 3
a264 1
	} */ *uap = v;
d279 1
a279 1
linux_accept(p, v, retval)
a280 3
	void *v;
	register_t *retval;
{
d285 3
a287 1
	} */ *uap = v;
d303 1
a303 1
linux_getsockname(p, v, retval)
a304 3
	void *v;
	register_t *retval;
{
d309 3
a311 1
	} */ *uap = v;
d327 1
a327 1
linux_getpeername(p, v, retval)
a328 3
	void *v;
	register_t *retval;
{
d333 3
a335 1
	} */ *uap = v;
d351 1
a351 1
linux_socketpair(p, v, retval)
a352 3
	void *v;
	register_t *retval;
{
d358 3
a360 1
	} */ *uap = v;
d379 1
a379 1
linux_send(p, v, retval)
a380 3
	void *v;
	register_t *retval;
{
d386 3
a388 1
	} */ *uap = v;
d405 1
a405 1
linux_recv(p, v, retval)
a406 3
	void *v;
	register_t *retval;
{
d412 3
a414 1
	} */ *uap = v;
d544 1
a544 1
linux_sendto(p, v, retval)
a545 3
	void *v;
	register_t *retval;
{
d553 3
a555 1
	} */ *uap = v;
d576 1
a576 1
linux_recvfrom(p, v, retval)
a577 3
	void *v;
	register_t *retval;
{
d585 3
a587 1
	} */ *uap = v;
d606 1
a606 1
linux_shutdown(p, v, retval)
a607 3
	void *v;
	register_t *retval;
{
d611 3
a613 1
	} */ *uap = v;
d757 1
a757 1
linux_setsockopt(p, v, retval)
a758 3
	void *v;
	register_t *retval;
{
d765 3
a767 1
	} */ *uap = v;
d808 1
a808 1
linux_getsockopt(p, v, retval)
a809 3
	void *v;
	register_t *retval;
{
d816 3
a818 1
	} */ *uap = v;
d856 1
a856 1
linux_recvmsg(p, v, retval)
a857 3
	void *v;
	register_t *retval;
{
d862 3
a864 1
	} */ *uap = v;
d880 1
a880 1
linux_sendmsg(p, v, retval)
a881 3
	void *v;
	register_t *retval;
{
d886 3
a888 1
	} */ *uap = v;
d982 1
a982 1
linux_ioctl_socket(p, v, retval)
a983 3
	void *v;
	register_t *retval;
{
d988 3
a990 1
	} */ *uap = v;
@


1.17.6.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d996 1
a996 1
	struct linux_sys_ioctl_args /* {
a1002 40
	struct file *fp;
	struct filedesc *fdp;
	struct vnode *vp;
	int (*ioctlf) __P((struct file *, u_long, caddr_t, struct proc *));
	struct ioctl_pt pt;
	int error = 0, isdev = 0, dosys = 1;

	fdp = p->p_fd;
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return (EBADF);
	FREF(fp);

	if (fp->f_type == DTYPE_VNODE) {
		vp = (struct vnode *)fp->f_data;
		isdev = vp->v_type == VCHR;
	}

	/*
	 * Don't try to interpret socket ioctl calls that are done
	 * on a device filedescriptor, just pass them through, to
	 * emulate Linux behaviour. Use PTIOCLINUX so that the
	 * device will only handle these if it's prepared to do
	 * so, to avoid unexpected things from happening.
	 */
	if (isdev) {
		dosys = 0;
		ioctlf = fp->f_ops->fo_ioctl;
		pt.com = SCARG(uap, com);
		pt.data = SCARG(uap, data);
		error = ioctlf(fp, PTIOCLINUX, (caddr_t)&pt, p);
		/*
		 * XXX hack: if the function returns EJUSTRETURN,       
		 * it has stuffed a sysctl return value in pt.data.
		 */
		if (error == EJUSTRETURN) {
			retval[0] = (register_t)pt.data;
			error = 0;
		}
		goto out;
	}
d1077 1
a1077 1
					error = copyout(LLADDR(sdl),
a1079 2
					dosys = 0;
					goto out;
d1083 1
a1083 1
		error = ENOENT;
d1086 1
a1086 8
		error = EINVAL;
	}

out:
	if (error == 0 && dosys) {
		SCARG(&ia, fd) = SCARG(uap, fd);
		SCARG(&ia, data) = SCARG(uap, data);
		error = sys_ioctl(p, &ia, retval);
d1089 3
a1091 2
	FRELE(fp);
	return (error);
@


1.17.6.4
log
@Merge in -current from about a week ago
@
text
@d79 27
a105 27
int linux_to_bsd_domain(int);
int linux_socket(struct proc *, void *, register_t *);
int linux_bind(struct proc *, void *, register_t *);
int linux_connect(struct proc *, void *, register_t *);
int linux_listen(struct proc *, void *, register_t *);
int linux_accept(struct proc *, void *, register_t *);
int linux_getsockname(struct proc *, void *, register_t *);
int linux_getpeername(struct proc *, void *, register_t *);
int linux_socketpair(struct proc *, void *, register_t *);
int linux_send(struct proc *, void *, register_t *);
int linux_recv(struct proc *, void *, register_t *);
int linux_sendto(struct proc *, void *, register_t *);
int linux_recvfrom(struct proc *, void *, register_t *);
int linux_shutdown(struct proc *, void *, register_t *);
int linux_to_bsd_sopt_level(int);
int linux_to_bsd_so_sockopt(int);
int linux_to_bsd_ip_sockopt(int);
int linux_to_bsd_tcp_sockopt(int);
int linux_to_bsd_udp_sockopt(int);
int linux_setsockopt(struct proc *, void *, register_t *);
int linux_getsockopt(struct proc *, void *, register_t *);
int linux_recvmsg(struct proc *, void *, register_t *);
int linux_sendmsg(struct proc *, void *, register_t *);

int linux_check_hdrincl(struct proc *, int, register_t *);
int linux_sendto_hdrincl(struct proc *, struct sys_sendto_args *,
    register_t *);
d1006 1
a1006 1
	int (*ioctlf)(struct file *, u_long, caddr_t, struct proc *);
@


1.17.6.5
log
@Sync the SMP branch with 3.3
@
text
@d79 1
a79 3
static int linux_to_bsd_domain (int);
static int bsd_to_linux_domain(int);

d103 1
a103 1
int linux_check_hdrincl(struct proc *, int, register_t *, caddr_t *);
d105 1
a105 66
    register_t *, caddr_t *);

int linux_sa_get(struct proc *, caddr_t *, struct sockaddr **,
    const struct osockaddr *, int *);
int linux_sa_put(struct osockaddr *);

static const int linux_to_bsd_domain_[LINUX_AF_MAX] = {
	AF_UNSPEC,
	AF_UNIX,
	AF_INET,
	AF_CCITT,	/* LINUX_AF_AX25 */
	AF_IPX,
	AF_APPLETALK,
	-1,		/* LINUX_AF_NETROM */
	-1,		/* LINUX_AF_BRIDGE */
	-1,		/* LINUX_AF_ATMPVC */
	AF_CCITT,	/* LINUX_AF_X25 */
	AF_INET6,
	-1,		/* LINUX_AF_ROSE */
	AF_DECnet,
	-1,		/* LINUX_AF_NETBEUI */
	-1,		/* LINUX_AF_SECURITY */
	-1,		/* pseudo_AF_KEY */
	AF_ROUTE,	/* LINUX_AF_NETLINK */
	-1,		/* LINUX_AF_PACKET */
	-1,		/* LINUX_AF_ASH */
	-1,		/* LINUX_AF_ECONET */
	-1,		/* LINUX_AF_ATMSVC */
	AF_SNA,
	/* rest up to LINUX_AF_MAX-1 is not allocated */
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
};

static const int bsd_to_linux_domain_[AF_MAX] = {
	LINUX_AF_UNSPEC,
	LINUX_AF_UNIX,
	LINUX_AF_INET,
	-1,		/* AF_IMPLINK */
	-1,		/* AF_PUP */
	-1,		/* AF_CHAOS */
	-1,		/* AF_NS */
	-1,		/* AF_ISO */
	-1,		/* AF_ECMA */
	-1,		/* AF_DATAKIT */
	LINUX_AF_AX25,	/* AF_CCITT */
	-1,		/* LINUX_AF_SNA */
	-1,		/* LINUX_AF_DECnet */
	-1,		/* AF_DLI */
	-1,		/* AF_LAT */
	-1,		/* AF_HYLINK */
	LINUX_AF_APPLETALK,
	-1,		/* LINUX_AF_NETLINK */
	-1,		/* AF_LINK */
	-1,		/* AF_XTP */
	-1,		/* AF_COIP */
	-1,		/* AF_CNT */
	-1,		/* pseudo_AF_RTIP */
	LINUX_AF_IPX,
	LINUX_AF_INET6,
	-1,		/* pseudo_AF_PIP */
	-1,		/* AF_ISDN */
	-1,		/* AF_NATM */
	-1,		/* AF_ARP */
	-1,		/* LINUX_pseudo_AF_KEY */
	-1,		/* pseudo_AF_HDRCMPLT */
};
d110 1
a110 1
static int
a113 2
	if (ldom < 0 || ldom >= LINUX_AF_MAX)
		return (-1);
d115 18
a132 14
	return linux_to_bsd_domain_[ldom];
}

/*
 * Convert between BSD and Linux socket domain values
 */
static int
bsd_to_linux_domain(bdom)
	int bdom;
{
	if (bdom < 0 || bdom >= AF_MAX)
		return (-1);

	return bsd_to_linux_domain_[bdom];
a174 1
	int namlen;
d180 2
a181 12
	namlen = lba.namelen;
	if (lba.name) {
		struct sockaddr *sa;
		caddr_t sg = stackgap_init(p->p_emul);

		error = linux_sa_get(p, &sg, &sa, lba.name, &namlen);
		if (error)
			return (error);
		SCARG(&bba, name) = sa;
	} else
		SCARG(&bba, name) = NULL;
	SCARG(&bba, namelen) = namlen;
d194 1
a194 1
		syscallarg(struct osockaddr *) name;
a198 3
	struct sockaddr *sa;
	caddr_t sg = stackgap_init(p->p_emul);
	int namlen;
a203 5
	namlen = lca.namelen;
	error = linux_sa_get(p, &sg, &sa, lca.name, &namlen);
	if (error)
		return (error);

d205 2
a206 2
	SCARG(&bca, name) = sa;
	SCARG(&bca, namelen) = (unsigned int)namlen;
d217 1
d228 1
a286 1
	struct sys_fcntl_args fca;
d296 1
a296 15
	error = compat_43_sys_accept(p, &baa, retval);
	if (error)
		return (error);

	/*
	 * linux appears not to copy flags from the parent socket to the
	 * accepted one, so we must clear the flags in the new descriptor.
	 * Ignore any errors, because we already have an open fd.
	 */
	SCARG(&fca, fd) = *retval;
	SCARG(&fca, cmd) = F_SETFL;
	SCARG(&fca, arg) = 0;
	(void)sys_fcntl(p, &fca, retval);
	*retval = SCARG(&fca, fd);
	return (0);
d307 1
a307 1
		syscallarg(caddr_t) addr;
d311 1
a311 1
	struct sys_getsockname_args bga;
d317 2
a318 2
	SCARG(&bga, fdes) = lga.s;
	SCARG(&bga, asa) = (struct sockaddr *) lga.addr;
d321 1
a321 8
	error = sys_getsockname(p, &bga, retval);
	if (error)
		return (error);

	if ((error = linux_sa_put((struct osockaddr *)lga.addr)))
		return (error);

	return (0);
d336 1
a336 1
	struct sys_getpeername_args bga;
d343 1
a343 1
	SCARG(&bga, asa) = (struct sockaddr *) lga.addr;
d346 1
a346 8
	error = sys_getpeername(p, &bga, retval);
	if (error)
		return (error);

	if ((error = linux_sa_put((struct osockaddr *)lga.addr)))
		return (error);

	return (0);
d433 1
a433 1
linux_check_hdrincl(p, fd, retval, sgp)
a436 1
	caddr_t *sgp;
d446 1
a446 1
	caddr_t val;
d451 3
a453 2
	val = stackgap_alloc(sgp, sizeof(optval));
	valsize = stackgap_alloc(sgp, sizeof(size_val));
d479 1
a479 1
linux_sendto_hdrincl(p, bsa, retval, sgp)
a482 1
	caddr_t *sgp;
d484 1
d501 4
a504 3
	packet = (struct ip *)stackgap_alloc(sgp, linux_ip_copysize);
	msg = (struct msghdr *)stackgap_alloc(sgp, sizeof(*msg));
	iov = (struct iovec *)stackgap_alloc(sgp, sizeof(*iov)*2);
d513 1
a513 1
	error = copyout(&rpacket, packet, linux_ip_copysize);
d556 1
a556 1
		syscallarg(osockaddr *) to;
a561 2
	int tolen;
	caddr_t sg = stackgap_init(p->p_emul);
d570 2
a571 10
	tolen = lsa.tolen;
	if (lsa.to) {
		struct sockaddr *sa;

		if ((error = linux_sa_get(p, &sg, &sa, lsa.to, &tolen)))
			return (error);
		SCARG(&bsa, to) = sa;
	} else
		SCARG(&bsa, to) = NULL;
	SCARG(&bsa, tolen) = tolen;
d573 2
a574 2
	if (linux_check_hdrincl(p, lsa.s, retval, &sg) == 0)
		return linux_sendto_hdrincl(p, &bsa, retval, &sg);
d589 1
a589 1
		syscallarg(struct osockaddr *) from;
d593 1
a593 1
	struct sys_recvfrom_args bra;
d603 1
a603 1
	SCARG(&bra, from) = (struct sockaddr *) lra.from;
d606 1
a606 7
	if ((error = sys_recvfrom(p, &bra, retval)))
		return (error);

	if (lra.from && (error = linux_sa_put(lra.from)))
		return (error);

	return (0);
d667 1
a667 8
		/*
		 * Linux does not implement SO_REUSEPORT, but allows reuse
		 * of a host:port pair through SO_REUSEADDR even if the
		 * address is not a multicast-address.  Effectively, this
		 * means that we should use SO_REUSEPORT to allow Linux
		 * applications to not exit with EADDRINUSE.
		 */
		return SO_REUSEPORT;
a874 1
	struct msghdr msg;
d884 1
a884 10
	error = sys_recvmsg(p, &bla, retval);
	if (error)
		return (error);

	error = copyin(lla.msg, (caddr_t)&msg, sizeof(msg));

	if (!error && msg.msg_name && msg.msg_namelen > 2)
		error = linux_sa_put(msg.msg_name);

	return (error);
a899 1
	struct msghdr msg, *nmsg = NULL;
a905 23

	if ((error = copyin(lla.msg, (caddr_t) &msg, sizeof(msg))))
		return (error);

	if (msg.msg_name) {
		struct sockaddr *sa;
		caddr_t sg = stackgap_init(p->p_emul);

		nmsg = (struct msghdr *)stackgap_alloc(&sg,
		    sizeof(struct msghdr));
		if (!nmsg)
			return (ENOMEM);

		error = linux_sa_get(p, &sg, &sa,
		    (struct osockaddr *)msg.msg_name, &msg.msg_namelen);
		if (error)
			return (error);

		msg.msg_name = (struct sockaddr *)sa;
		if ((error = copyout(&msg, nmsg, sizeof(struct msghdr))))
			return (error);
	}

a932 133
}

/*
 * Copy the osockaddr structure pointed to by osa to kernel, adjust
 * family and convert to sockaddr, allocate stackgap and put the
 * the converted structure there, address on stackgap returned in sap.
 */
int
linux_sa_get(p, sgp, sap, osa, osalen)
	struct proc *p;
	caddr_t *sgp;
	struct sockaddr **sap;
	const struct osockaddr *osa;
	int *osalen;
{
	int error=0, bdom;
	struct sockaddr *sa, *usa;
	struct osockaddr *kosa;
	int alloclen;
#ifdef INET6
	int oldv6size;
	struct sockaddr_in6 *sin6;
#endif

	if (*osalen < 2 || *osalen > UCHAR_MAX || !osa) {
		return (EINVAL);
	}

	alloclen = *osalen;
#ifdef INET6
	oldv6size = 0;
	/*
	 * Check for old (pre-RFC2553) sockaddr_in6. We may accept it
	 * if it's a v4-mapped address, so reserve the proper space
	 * for it.
	 */
	if (alloclen == sizeof (struct sockaddr_in6) - sizeof (u_int32_t)) {
		alloclen = sizeof (struct sockaddr_in6);
		oldv6size = 1;
	}
#endif

	kosa = (struct osockaddr *) malloc(alloclen, M_TEMP, M_WAITOK);

	if ((error = copyin(osa, (caddr_t) kosa, *osalen))) {
		goto out;
	}

	bdom = linux_to_bsd_domain(kosa->sa_family);
	if (bdom == -1) {
		error = EINVAL;
		goto out;
	}

#ifdef INET6
	/*
	 * Older Linux IPv6 code uses obsolete RFC2133 struct sockaddr_in6,
	 * which lacks the scope id compared with RFC2553 one. If we detect
	 * the situation, reject the address.
	 *
	 * Still accept addresses for which the scope id is not used.
	 */
	if (oldv6size && bdom == AF_INET6) {
		sin6 = (struct sockaddr_in6 *)kosa;
		if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr) ||
		    (!IN6_IS_ADDR_LINKLOCAL(&sin6->sin6_addr) &&
		     !IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr) &&
		     !IN6_IS_ADDR_V4COMPAT(&sin6->sin6_addr) &&
		     !IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) &&
		     !IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr))) {
			sin6->sin6_scope_id = 0;
		} else {
			error = EINVAL;
			goto out;
		}
	} else
#endif 
	if (bdom == AF_INET) {
		alloclen = sizeof(struct sockaddr_in);
	}

	sa = (struct sockaddr *) kosa;
	sa->sa_family = bdom;
	sa->sa_len = alloclen;

	usa = (struct sockaddr *) stackgap_alloc(sgp, alloclen);
	if (!usa) {
		error = ENOMEM;
		goto out;
	}

	if ((error = copyout(sa, usa, alloclen))) {
		goto out;
	}

	*sap = usa;

    out:
	*osalen = alloclen;
	free(kosa, M_TEMP);
	return (error);
}

int
linux_sa_put(osa)
	struct osockaddr *osa;
{
	struct sockaddr sa;
	struct osockaddr *kosa;
	int error, bdom, len;

	/*
	 * Only read/write the sockaddr family and length part, the rest is
	 * not changed.
	 */
	len = sizeof(sa.sa_len) + sizeof(sa.sa_family);

	error = copyin((caddr_t) osa, (caddr_t) &sa, len);
	if (error)
		return (error);

	bdom = bsd_to_linux_domain(sa.sa_family);
	if (bdom == -1)
		return (EINVAL);

	/* Note: we convert from sockaddr to osockaddr here, too */
	kosa = (struct osockaddr *) &sa;
	kosa->sa_family = bdom;
	error = copyout(kosa, osa, len);
	if (error)
		return (error);

	return (0);
@


1.17.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a1070 1
		lla.msg = nmsg;
d1092 1
a1092 5
		/*
		 * XXX should use stack gap!
		 * We don't because the control header is variable length
		 * up to 2048 bytes, and there's only 512 bytes of gap.
		 */
d1099 1
a1099 8
	error = sys_sendmsg(p, &bla, retval);
	/* replace level, just in case somebody cares. */
	if (level == SOL_SOCKET) {
		level = 1;
		copyout(&level, &((struct cmsghdr *)control)->cmsg_level,
		    sizeof(int));
	}
	return (error);
d1399 1
a1399 1
		struct linux_ifreq *ifr = (struct linux_ifreq *)SCARG(uap, data);
a1425 1
		break;
@


1.16
log
@IP_HDRINCL support, will need tweaking; freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.15 1998/07/19 15:32:24 deraadt Exp $	*/
d998 20
@


1.15
log
@no; linux connect() appears busted in blocking mode too
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.14 1998/07/13 19:45:47 deraadt Exp $	*/
d51 2
d108 8
d431 113
d570 2
d855 71
d972 4
@


1.14
log
@oops; mwp@@aba.net.au
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.13 1998/04/25 05:47:35 millert Exp $	*/
d207 1
d209 1
d214 1
d221 1
@


1.13
log
@Aparently the socketpair bug is fixed in current Linux kernels so
back out my last change.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.12 1998/04/25 00:12:45 millert Exp $	*/
d215 1
a215 1
		if (sys_getsockopt(p, &fca, retval) == -1 ||
@


1.12
log
@Linux has SHUT_RD and SHUT_WR reversed in the ``how'' argument.  Presumably
they will fix this sometime, after which this change should be backed out.
Pointed out by tchrist@@perl.com
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.11 1998/02/10 04:32:41 deraadt Exp $	*/
a490 8
	/*
	 * XXX - Linux gets the ``how'' argument wrong.  It is reversed!
	 *       Hopefully they will fix this someday.
	 */
	if (lsa.how == SHUT_RD)
		lsa.how = SHUT_WR;
	else if (lsa.how == SHUT_WR)
		lsa.how = SHUT_RD;
@


1.11
log
@recover from lint changes elsewhere, not completely tested
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.10 1998/02/07 16:33:34 deraadt Exp $	*/
d491 8
@


1.10
log
@emulate linux connect() braindamage even better -- only do so on async
sockets; pb@@fasterix.freenix.org
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.9 1997/12/14 20:51:16 deraadt Exp $	*/
d176 1
a176 1
	SCARG(&bba, name) = (caddr_t) lba.name;
d200 1
a200 1
	SCARG(&bca, name) = (caddr_t) lca.name;
d440 1
a440 1
	SCARG(&bsa, to) = (caddr_t) lsa.to;
@


1.9
log
@support IP_HDRINCL
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.8 1997/12/10 12:44:38 provos Exp $	*/
d207 1
d211 7
@


1.8
log
@add GIFMETRIC and GIFMTU
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.7 1997/12/10 01:51:23 deraadt Exp $	*/
d574 2
@


1.7
log
@emulate linux SIOCGIFHWADDR; stolen from freebsd; not tested yet
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.6 1997/11/27 00:57:28 deraadt Exp $	*/
d801 6
@


1.6
log
@oh, connect() semantics are EVEN WORSE
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.5 1997/11/26 08:51:08 deraadt Exp $	*/
d48 2
d808 27
@


1.5
log
@If using async connect(), after select for writeable, if getpeername()
indicates connection failure, you can use getsockopt(SOL_SOCKET,
SO_ERROR, ...) to find the error. But the linux people I guess didn't
know about this, and changed connect() so that a 2nd connect() call on
a failed socket returns the error directly. Fake this demented
non-standard behaviour which Linux users are now starting to code to.
Talk about dilution of the API...
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_socket.c,v 1.3 1996/04/17 05:24:01 mickey Exp $	*/
d227 1
a227 3
		if (stat)
			return stat;
		return EISCONN;
@


1.4
log
@indent
@
text
@d201 31
a231 1
	return sys_connect(p, &bca, retval);
@


1.3
log
@Good fixes and changes from latest Net.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d612 14
a625 14
		case SOL_SOCKET:
			name = linux_to_bsd_so_sockopt(lsa.optname);
			break;
		case IPPROTO_IP:
			name = linux_to_bsd_ip_sockopt(lsa.optname);
			break;
		case IPPROTO_TCP:
			name = linux_to_bsd_tcp_sockopt(lsa.optname);
			break;
		case IPPROTO_UDP:
			name = linux_to_bsd_udp_sockopt(lsa.optname);
			break;
		default:
			return EINVAL;
d663 14
a676 14
		case SOL_SOCKET:
			name = linux_to_bsd_so_sockopt(lga.optname);
			break;
		case IPPROTO_IP:
			name = linux_to_bsd_ip_sockopt(lga.optname);
			break;
		case IPPROTO_TCP:
			name = linux_to_bsd_tcp_sockopt(lga.optname);
			break;
		case IPPROTO_UDP:
			name = linux_to_bsd_udp_sockopt(lga.optname);
			break;
		default:
			return EINVAL;
@


1.2
log
@From NetBSD:
linux compatibility changes.
@
text
@d1 2
a2 1
/*	$NetBSD: linux_socket.c,v 1.13 1996/03/08 04:56:05 mycroft Exp $	*/
d74 30
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: linux_socket.c,v 1.12 1995/10/07 06:27:13 mycroft Exp $	*/
d704 50
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
