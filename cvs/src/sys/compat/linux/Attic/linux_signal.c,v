head	1.19;
access;
symbols
	OPENBSD_5_9:1.18.0.4
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.6
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.10
	OPENBSD_5_0:1.14.0.8
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.6
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.22
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.20
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.18
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.16
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.14
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.12
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.10
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.8
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.6
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.8
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.6
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.4.0.6
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2016.03.02.15.41.48;	author naddy;	state dead;
branches;
next	1.18;
commitid	ZfNt0OHZhMg52abA;

1.18
date	2015.02.09.13.41.24;	author pelikan;	state Exp;
branches;
next	1.17;
commitid	A5GI5pfcmwpscN1L;

1.17
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2014.01.21.01.49.13;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2012.06.19.11.35.29;	author pirofti;	state Exp;
branches;
next	1.14;

1.14
date	2009.12.09.16.29.56;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.01.11.53.26;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.25.09.10.27;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.09.14.15.22;	author niklas;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.07.27.06.10.38;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.09.06.52.26;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.02.21.43.11;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.07.14.11.38;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.13.08.18.30;	author jasoni;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.08.03.35.28;	author jasoni;	state Exp;
branches;
next	1.4;

1.4
date	98.12.22.07.58.45;	author deraadt;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	97.06.02.09.42.12;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.17.05.23.59;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.19;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.19;	author deraadt;	state Exp;
branches;
next	;

1.4.6.1
date	2000.03.24.09.09.02;	author niklas;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2001.05.14.22.04.49;	author niklas;	state Exp;
branches;
next	1.4.6.3;

1.4.6.3
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.4.6.4;

1.4.6.4
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2003.05.19.21.52.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@remove the Linux emulation code, no longer referenced by anything
@
text
@/*	$OpenBSD: linux_signal.c,v 1.18 2015/02/09 13:41:24 pelikan Exp $	*/
/*	$NetBSD: linux_signal.c,v 1.10 1996/04/04 23:51:36 christos Exp $	*/

/*
 * Copyright (c) 1995 Frank van der Linden
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed for the NetBSD Project
 *      by Frank van der Linden
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * heavily from: svr4_signal.c,v 1.7 1995/01/09 01:04:21 christos Exp
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/kernel.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>

#include <sys/syscallargs.h>

#include <compat/linux/linux_types.h>
#include <compat/linux/linux_signal.h>
#include <compat/linux/linux_syscallargs.h>
#include <compat/linux/linux_util.h>

#define	sigemptyset(s)		memset((s), 0, sizeof(*(s)))
#define	sigismember(s, n)	(*(s) & sigmask(n))
#define	sigaddset(s, n)		(*(s) |= sigmask(n))
 
/* Locally used defines (in bsd<->linux conversion functions): */
#define	linux_sigmask(n)	(1 << ((n) - 1))
#define	linux_sigemptyset(s)	memset((s), 0, sizeof(*(s)))
#define	linux_sigismember(s, n)	((s)->sig[((n) - 1) / LINUX__NSIG_BPW]	\
					& (1 << ((n) - 1) % LINUX__NSIG_BPW))
#define	linux_sigaddset(s, n)	((s)->sig[((n) - 1) / LINUX__NSIG_BPW]	\
					|= (1 << ((n) - 1) % LINUX__NSIG_BPW))

int bsd_to_linux_sig[NSIG] = {
	0,
	LINUX_SIGHUP,
	LINUX_SIGINT,
	LINUX_SIGQUIT,
	LINUX_SIGILL,
	LINUX_SIGTRAP,
	LINUX_SIGABRT,
	LINUX_NSIG,		/* XXX Kludge to get RT signal #32 to work */
	LINUX_SIGFPE,
	LINUX_SIGKILL,
	LINUX_SIGBUS,
	LINUX_SIGSEGV,
	LINUX_NSIG + 1,			/* XXX Kludge to get RT signal #32 to work */
	LINUX_SIGPIPE,
	LINUX_SIGALRM,
	LINUX_SIGTERM,
	LINUX_SIGURG,
	LINUX_SIGSTOP,
	LINUX_SIGTSTP,
	LINUX_SIGCONT,
	LINUX_SIGCHLD,
	LINUX_SIGTTIN,
	LINUX_SIGTTOU,
	LINUX_SIGIO,
	LINUX_SIGXCPU,
	LINUX_SIGXFSZ,
	LINUX_SIGVTALRM,
	LINUX_SIGPROF,
	LINUX_SIGWINCH,
	0,			/* SIGINFO */
	LINUX_SIGUSR1,
	LINUX_SIGUSR2,
	0,			/* SIGTHR */
};

int linux_to_bsd_sig[LINUX__NSIG] = {
	0,
	SIGHUP,
	SIGINT,
	SIGQUIT,
	SIGILL,
	SIGTRAP,
	SIGABRT,
	SIGBUS,
	SIGFPE,
	SIGKILL,
	SIGUSR1,
	SIGSEGV,
	SIGUSR2,
	SIGPIPE,
	SIGALRM,
	SIGTERM,
	0,			/* SIGSTKFLT */
	SIGCHLD,
	SIGCONT,
	SIGSTOP,
	SIGTSTP,
	SIGTTIN,
	SIGTTOU,
	SIGURG,
	SIGXCPU,
	SIGXFSZ,
	SIGVTALRM,
	SIGPROF,
	SIGWINCH,
	SIGIO,
	0,			/* SIGUNUSED */
	0,
	SIGEMT,			/* XXX Gruesome hack for linuxthreads:       */
	SIGSYS,			/* Map 1st 2 RT signals onto ones we handle. */
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
};

/*
 * Convert between Linux and BSD signal sets.
 */
void
linux_old_to_bsd_sigset(lss, bss)
	const linux_old_sigset_t *lss;
	sigset_t *bss;
{
	linux_old_extra_to_bsd_sigset(lss, (const unsigned long *) 0, bss);    
}

void
bsd_to_linux_old_sigset(bss, lss)
	const sigset_t *bss;
	linux_old_sigset_t *lss;
{
	bsd_to_linux_old_extra_sigset(bss, lss, (unsigned long *) 0); 
}

void
linux_old_extra_to_bsd_sigset(lss, extra, bss)
	const linux_old_sigset_t *lss;
	const unsigned long *extra;
	sigset_t *bss;
{
	linux_sigset_t lsnew;

	/* convert old sigset to new sigset */
	linux_sigemptyset(&lsnew);
	lsnew.sig[0] = *lss;
	if (extra)
		bcopy(extra, &lsnew.sig[1],
			sizeof(linux_sigset_t) - sizeof(linux_old_sigset_t));

	linux_to_bsd_sigset(&lsnew, bss);
}

void
bsd_to_linux_old_extra_sigset(bss, lss, extra)
	const sigset_t *bss;
	linux_old_sigset_t *lss;
	unsigned long *extra;
{
	linux_sigset_t lsnew;

	bsd_to_linux_sigset(bss, &lsnew);

	/* convert new sigset to old sigset */
	*lss = lsnew.sig[0];
	if (extra)
		bcopy(&lsnew.sig[1], extra,
			sizeof(linux_sigset_t) - sizeof(linux_old_sigset_t));
}

void
linux_to_bsd_sigset(lss, bss)
	const linux_sigset_t *lss;
	sigset_t *bss;
{
	int i, newsig;

	sigemptyset(bss);
	for (i = 1; i < LINUX__NSIG; i++) {
		if (linux_sigismember(lss, i)) {
			newsig = linux_to_bsd_sig[i];
			if (newsig)
				sigaddset(bss, newsig);
		}
	}
}

void
bsd_to_linux_sigset(bss, lss)
	const sigset_t *bss;
	linux_sigset_t *lss;
{
	int i, newsig;

	linux_sigemptyset(lss);
	for (i = 1; i < NSIG; i++) {
		if (sigismember(bss, i)) {
			newsig = bsd_to_linux_sig[i];
			if (newsig)
				linux_sigaddset(lss, newsig);
		}
	}
}

/*
 * Convert between Linux and BSD sigaction structures. Linux has
 * one extra field (sa_restorer) which we don't support.
 */
void
linux_old_to_bsd_sigaction(lsa, bsa)
	struct linux_old_sigaction *lsa;
	struct sigaction *bsa;
{

	bsa->sa_handler = lsa->sa__handler;
	linux_old_to_bsd_sigset(&lsa->sa_mask, &bsa->sa_mask);
	bsa->sa_flags = 0;
	if ((lsa->sa_flags & LINUX_SA_ONSTACK) != 0)
		bsa->sa_flags |= SA_ONSTACK;
	if ((lsa->sa_flags & LINUX_SA_RESTART) != 0)
		bsa->sa_flags |= SA_RESTART;
	if ((lsa->sa_flags & LINUX_SA_ONESHOT) != 0)
		bsa->sa_flags |= SA_RESETHAND;
	if ((lsa->sa_flags & LINUX_SA_NOCLDSTOP) != 0)
		bsa->sa_flags |= SA_NOCLDSTOP;
	if ((lsa->sa_flags & LINUX_SA_NOMASK) != 0)
		bsa->sa_flags |= SA_NODEFER;
}

void
bsd_to_linux_old_sigaction(bsa, lsa)
	struct sigaction *bsa;
	struct linux_old_sigaction *lsa;
{

	lsa->sa__handler = bsa->sa_handler;
	bsd_to_linux_old_sigset(&bsa->sa_mask, &lsa->sa_mask);
	lsa->sa_flags = 0;
	if ((bsa->sa_flags & SA_NOCLDSTOP) != 0)
		lsa->sa_flags |= LINUX_SA_NOCLDSTOP;
	if ((bsa->sa_flags & SA_ONSTACK) != 0)
		lsa->sa_flags |= LINUX_SA_ONSTACK;
	if ((bsa->sa_flags & SA_RESTART) != 0)
		lsa->sa_flags |= LINUX_SA_RESTART;
	if ((bsa->sa_flags & SA_NODEFER) != 0)
		lsa->sa_flags |= LINUX_SA_NOMASK;
	if ((bsa->sa_flags & SA_RESETHAND) != 0)
		lsa->sa_flags |= LINUX_SA_ONESHOT;
	lsa->sa_restorer = NULL;
}

void
linux_to_bsd_sigaction(lsa, bsa)
	struct linux_sigaction *lsa;
	struct sigaction *bsa;
{

	bsa->sa_handler = lsa->sa__handler;
	linux_to_bsd_sigset(&lsa->sa_mask, &bsa->sa_mask);
	bsa->sa_flags = 0;
	if ((lsa->sa_flags & LINUX_SA_NOCLDSTOP) != 0)
		bsa->sa_flags |= SA_NOCLDSTOP;
	if ((lsa->sa_flags & LINUX_SA_ONSTACK) != 0)
		bsa->sa_flags |= SA_ONSTACK;
	if ((lsa->sa_flags & LINUX_SA_RESTART) != 0)
		bsa->sa_flags |= SA_RESTART;
	if ((lsa->sa_flags & LINUX_SA_ONESHOT) != 0)
		bsa->sa_flags |= SA_RESETHAND;
	if ((lsa->sa_flags & LINUX_SA_NOMASK) != 0)
		bsa->sa_flags |= SA_NODEFER;
	if ((lsa->sa_flags & LINUX_SA_SIGINFO) != 0)
		bsa->sa_flags |= SA_SIGINFO;
}

void
bsd_to_linux_sigaction(bsa, lsa)
	struct sigaction *bsa;
	struct linux_sigaction *lsa;
{

	/* Clear sa_flags and sa_restorer (if it exists) */
	memset(lsa, 0, sizeof(struct linux_sigaction));

	/* ...and fill in the mask and flags */
	bsd_to_linux_sigset(&bsa->sa_mask, &lsa->sa_mask);
	if ((bsa->sa_flags & SA_NOCLDSTOP) != 0)
		lsa->sa_flags |= LINUX_SA_NOCLDSTOP;
	if ((bsa->sa_flags & SA_ONSTACK) != 0)
		lsa->sa_flags |= LINUX_SA_ONSTACK;
	if ((bsa->sa_flags & SA_RESTART) != 0)
		lsa->sa_flags |= LINUX_SA_RESTART;
	if ((bsa->sa_flags & SA_NODEFER) != 0)
		lsa->sa_flags |= LINUX_SA_NOMASK;
	if ((bsa->sa_flags & SA_RESETHAND) != 0)
		lsa->sa_flags |= LINUX_SA_ONESHOT;
	if ((bsa->sa_flags & SA_SIGINFO) != 0)
		lsa->sa_flags |= LINUX_SA_SIGINFO;
	lsa->sa__handler = bsa->sa_handler;
}

int
linux_to_bsd_signal(int linuxsig, int *bsdsig)
{
	if (linuxsig < 0 || linuxsig >= LINUX__NSIG)
		return (EINVAL);

	*bsdsig = linux_to_bsd_sig[linuxsig];
	return (0);
}

int
bsd_to_linux_signal(int bsdsig, int *linuxsig)
{
	if (bsdsig < 0 || bsdsig >= NSIG)
		return (EINVAL);

	*linuxsig = bsd_to_linux_sig[bsdsig];
	return (0);
}

/*
 * The Linux sigaction() system call. Do the usual conversions,
 * and just call sigaction(). Some flags and values are silently
 * ignored (see above).
 */
int
linux_sys_sigaction(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_sigaction_args /* {
		syscallarg(int) signum;
		syscallarg(struct linux_old_sigaction *) nsa;
		syscallarg(struct linux_old_sigaction *) osa;
	} */ *uap = v;
	struct linux_old_sigaction *nlsa, *olsa, tmplsa;
	struct sigaction *nbsa, *obsa, tmpbsa;
	struct sys_sigaction_args sa;
	caddr_t sg;
	int error;

	if (SCARG(uap, signum) < 0 || SCARG(uap, signum) >= LINUX__NSIG)
		return (EINVAL);

	sg = stackgap_init(p);
	nlsa = SCARG(uap, nsa);
	olsa = SCARG(uap, osa);

	if (olsa != NULL)
		obsa = stackgap_alloc(&sg, sizeof(struct sigaction));
	else
		obsa = NULL;

	if (nlsa != NULL) {
		nbsa = stackgap_alloc(&sg, sizeof(struct sigaction));
		if ((error = copyin(nlsa, &tmplsa, sizeof(tmplsa))) != 0)
			return (error);
		linux_old_to_bsd_sigaction(&tmplsa, &tmpbsa);
		if ((error = copyout(&tmpbsa, nbsa, sizeof(tmpbsa))) != 0)
			return (error);
	} else
		nbsa = NULL;

	SCARG(&sa, signum) = linux_to_bsd_sig[SCARG(uap, signum)];
	SCARG(&sa, nsa) = nbsa;
	SCARG(&sa, osa) = obsa;

	/* Silently ignore unknown signals */
	if (SCARG(&sa, signum) == 0) {
		if (obsa != NULL) {
			obsa->sa_handler = SIG_IGN;
			sigemptyset(&obsa->sa_mask);
			obsa->sa_flags = 0;
		}
	}
	else {
		if ((error = sys_sigaction(p, &sa, retval)) != 0)
			return (error);
	}

	if (olsa != NULL) {
		if ((error = copyin(obsa, &tmpbsa, sizeof(tmpbsa))) != 0)
			return (error);
		bsd_to_linux_old_sigaction(&tmpbsa, &tmplsa);
		if ((error = copyout(&tmplsa, olsa, sizeof(tmplsa))) != 0)
			return (error);
	}

	return (0);
}

int
linux_sys_rt_sigaction(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_rt_sigaction_args /* {
		syscallarg(int) signum;
		syscallarg(struct linux_sigaction *) nsa;
		syscallarg(struct linux_sigaction *) osa;
		syscallarg(size_t) sigsetsize;
	} */ *uap = v;
	struct linux_sigaction *nlsa, *olsa, tmplsa;
	struct sigaction *nbsa, *obsa, tmpbsa;
	struct sys_sigaction_args sa;
	caddr_t sg;
	int error;

	if (SCARG(uap, sigsetsize) != sizeof(linux_sigset_t))
		return (EINVAL);

	if (SCARG(uap, signum) < 0 || SCARG(uap, signum) >= LINUX__NSIG)
		return (EINVAL);

	sg = stackgap_init(p);
	nlsa = SCARG(uap, nsa);
	olsa = SCARG(uap, osa);

	if (olsa != NULL) 
		obsa = stackgap_alloc(&sg, sizeof(struct sigaction));
	else
		obsa = NULL;

	if (nlsa != NULL) {
		nbsa = stackgap_alloc(&sg, sizeof(struct sigaction));
		if ((error = copyin(nlsa, &tmplsa, sizeof(tmplsa))) != 0)
			return (error);
		linux_to_bsd_sigaction(&tmplsa, &tmpbsa);
		if ((error = copyout(&tmpbsa, nbsa, sizeof(tmpbsa))) != 0)
			return (error);
	}
	else
		nbsa = NULL;

	SCARG(&sa, signum) = linux_to_bsd_sig[SCARG(uap, signum)];
	SCARG(&sa, nsa) = nbsa;
	SCARG(&sa, osa) = obsa;

	/* Silently ignore unknown signals */
	if (SCARG(&sa, signum) == 0) {
		if (obsa != NULL) {
			obsa->sa_handler = SIG_IGN;
			sigemptyset(&obsa->sa_mask);
			obsa->sa_flags = 0;
		}
	}
	else {
		if ((error = sys_sigaction(p, &sa, retval)) != 0)
			return (error);
	}

	if (olsa != NULL) {
		if ((error = copyin(obsa, &tmpbsa, sizeof(tmpbsa))) != 0)
			return (error);
		bsd_to_linux_sigaction(&tmpbsa, &tmplsa);
		if ((error = copyout(&tmplsa, olsa, sizeof(tmplsa))) != 0)
			return (error);
	}

	return (0);
}

/*
 * The Linux signal() system call. I think that the signal() in the C
 * library actually calls sigaction, so I doubt this one is ever used.
 * But hey, it can't hurt having it here. The same restrictions as for
 * sigaction() apply.
 */
int
linux_sys_signal(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_signal_args /* {
		syscallarg(int) sig;
		syscallarg(linux_handler_t) handler;
	} */ *uap = v;
	caddr_t sg;
	struct sys_sigaction_args sa_args;
	struct sigaction *osa, *nsa, tmpsa;
	int error;

	if (SCARG(uap, sig) < 0 || SCARG(uap, sig) >= LINUX__NSIG)
		return (EINVAL);

	sg = stackgap_init(p);
	nsa = stackgap_alloc(&sg, sizeof *nsa);
	osa = stackgap_alloc(&sg, sizeof *osa);

	tmpsa.sa_handler = SCARG(uap, handler);
	tmpsa.sa_mask = (sigset_t) 0;
	tmpsa.sa_flags = SA_RESETHAND | SA_NODEFER;
	if ((error = copyout(&tmpsa, nsa, sizeof tmpsa)))
		return (error);

	SCARG(&sa_args, signum) = linux_to_bsd_sig[SCARG(uap, sig)];
	SCARG(&sa_args, osa) = osa;
	SCARG(&sa_args, nsa) = nsa;

	/* Silently ignore unknown signals */
	if (SCARG(&sa_args, signum) != 0) {
		if ((error = sys_sigaction(p, &sa_args, retval)))
			return (error);
	}

	if ((error = copyin(osa, &tmpsa, sizeof *osa)))
		return (error);
	retval[0] = (register_t) tmpsa.sa_handler;

	return (0);
}

/*
 * This is just a copy of the svr4 compat one. I feel so creative now.
 */
int
linux_sys_sigprocmask(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_sigprocmask_args /* {
		syscallarg(int) how;
		syscallarg(linux_old_sigset_t *) set;
		syscallarg(linux_old_sigset_t *) oset;
	} */ *uap = v;
	linux_old_sigset_t ss;
	sigset_t bs;
	int error = 0;

	*retval = 0;

	if (SCARG(uap, oset) != NULL) {
		/* Fix the return value first if needed */
		bsd_to_linux_old_sigset(&p->p_sigmask, &ss);
		if ((error = copyout(&ss, SCARG(uap, oset), sizeof(ss))) != 0)
			return (error);
	}

	if (SCARG(uap, set) == NULL)
		/* Just examine */
		return (0);

	if ((error = copyin(SCARG(uap, set), &ss, sizeof(ss))) != 0)
		return (error);

	linux_old_to_bsd_sigset(&ss, &bs);

	bs &= ~sigcantmask;
	switch (SCARG(uap, how)) {
	case LINUX_SIG_BLOCK:
		atomic_setbits_int(&p->p_sigmask, bs);
		break;

	case LINUX_SIG_UNBLOCK:
		atomic_clearbits_int(&p->p_sigmask, bs);
		break;

	case LINUX_SIG_SETMASK:
		p->p_sigmask = bs;
		break;

	default:
		error = EINVAL;
		break;
	}

	return (error);
}

int
linux_sys_rt_sigprocmask(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_rt_sigprocmask_args /* {
		syscallarg(int) how;
		syscallarg(const linux_sigset_t *) set;
		syscallarg(linux_sigset_t *) oset;
		syscallarg(size_t) sigsetsize;
	} */ *uap = v;
	linux_sigset_t ls;
	sigset_t bs;
	int error = 0;

	if (SCARG(uap, sigsetsize) != sizeof(linux_sigset_t))
		return (EINVAL);

	*retval = 0;

	if (SCARG(uap, oset) != NULL) {
		/* Fix the return value first if needed */
		bsd_to_linux_sigset(&p->p_sigmask, &ls);
		if ((error = copyout(&ls, SCARG(uap, oset), sizeof(ls))) != 0)
			return (error);
	}

	if (SCARG(uap, set) == NULL)
		/* Just examine */
		return (0);

	if ((error = copyin(SCARG(uap, set), &ls, sizeof(ls))) != 0)
		return (error);

	linux_to_bsd_sigset(&ls, &bs);

	bs &= ~sigcantmask;
	switch (SCARG(uap, how)) {
	case LINUX_SIG_BLOCK:
		atomic_setbits_int(&p->p_sigmask, bs);
		break;

	case LINUX_SIG_UNBLOCK:
		atomic_clearbits_int(&p->p_sigmask, bs);
		break;

	case LINUX_SIG_SETMASK:
		p->p_sigmask = bs;
		break;

	default:
		error = EINVAL;
		break;
	}

	return (error);
}

/*
 * The functions below really make no distinction between an int
 * and [linux_]sigset_t. This is ok for now, but it might break
 * sometime. Then again, sigset_t is trusted to be an int everywhere
 * else in the kernel too.
 */
/* ARGSUSED */
int
linux_sys_siggetmask(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{

	bsd_to_linux_old_sigset(&p->p_sigmask, (linux_old_sigset_t *)retval);
	return (0);
}

/*
 * The following three functions fiddle with a process' signal mask.
 * Convert the signal masks because of the different signal
 * values for Linux. The need for this is the reason why
 * they are here, and have not been mapped directly.
 */
int
linux_sys_sigsetmask(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_sigsetmask_args /* {
		syscallarg(linux_old_sigset_t) mask;
	} */ *uap = v;
	linux_old_sigset_t mask;
	sigset_t bsdsig;

	bsd_to_linux_old_sigset(&p->p_sigmask, (linux_old_sigset_t *)retval);

	mask = SCARG(uap, mask);
	bsd_to_linux_old_sigset(&bsdsig, &mask);

	p->p_sigmask = bsdsig & ~sigcantmask;

	return (0);
}

int
linux_sys_sigpending(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_sigpending_args /* {
		syscallarg(linux_old_sigset_t *) mask;
	} */ *uap = v;
	sigset_t bs;
	linux_old_sigset_t ls;

	bs = p->p_siglist & p->p_sigmask;
	bsd_to_linux_old_sigset(&bs, &ls);

	return (copyout(&ls, SCARG(uap, mask), sizeof ls));
}

int
linux_sys_rt_sigpending(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_rt_sigpending_args /* {
		syscallarg(linux_sigset_t *) set;
		syscallarg(size_t) sigsetsize;
	} */ *uap = v;
	sigset_t bs;
	linux_sigset_t ls;

	if (SCARG(uap, sigsetsize) != sizeof(linux_sigset_t))
		return (EINVAL);

	bs = p->p_siglist & p->p_sigmask;
	bsd_to_linux_sigset(&bs, &ls);

	return (copyout(&ls, SCARG(uap, set), sizeof ls));
}

int
linux_sys_sigsuspend(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_sigsuspend_args /* {
		syscallarg(caddr_t) restart;
		syscallarg(int) oldmask;
		syscallarg(int) mask;
	} */ *uap = v;
	struct sys_sigsuspend_args sa;
	linux_old_sigset_t mask = SCARG(uap, mask);

	linux_old_to_bsd_sigset(&mask, &SCARG(&sa, mask));
	return (sys_sigsuspend(p, &sa, retval));
}

int
linux_sys_rt_sigsuspend(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_rt_sigsuspend_args /* {
		syscallarg(sigset_t *) unewset;
		syscallarg(size_t) sigsetsize;
	} */ *uap = v;
	struct sys_sigsuspend_args sa;
	linux_sigset_t mask;
	int error;

	if (SCARG(uap, sigsetsize) != sizeof(linux_sigset_t))
		return (EINVAL);
	
	error = copyin(SCARG(uap, unewset), &mask, sizeof mask);
	if (error)
		return (error);
	
	linux_to_bsd_sigset(&mask, &SCARG(&sa, mask));
	return (sys_sigsuspend(p, &sa, retval));
}

/*
 * Linux' sigaltstack structure is just of a different order than BSD's
 * so just shuffle the fields around and call our version.
 */
int
linux_sys_sigaltstack(p, v, retval)
	register struct proc *p;
	void *v;	
	register_t *retval;
{	
	struct linux_sys_sigaltstack_args /* {
		syscallarg(const struct linux_sigaltstack *) nss;
		syscallarg(struct linux_sigaltstack *) oss;
	} */ *uap = v;
	struct linux_sigaltstack linux_ss;
	struct sigaltstack *bsd_nss, *bsd_oss;
	struct sys_sigaltstack_args sa;
	int error;
	caddr_t sg;

	sg = stackgap_init(p);

	if (SCARG(uap, nss) != NULL) {
		bsd_nss = stackgap_alloc(&sg, sizeof *bsd_nss);

		error = copyin(SCARG(uap, nss), &linux_ss, sizeof linux_ss);
		if (error)
			return (error);

		bsd_nss->ss_sp = linux_ss.ss_sp;
		bsd_nss->ss_size = linux_ss.ss_size;
		bsd_nss->ss_flags = (linux_ss.ss_flags & LINUX_SS_DISABLE) ?
		    SS_DISABLE : 0;

		SCARG(&sa, nss) = bsd_nss;
	} else
		SCARG(&sa, nss) = NULL;

	if (SCARG(uap, oss) == NULL) {
		SCARG(&sa, oss) = NULL;
		return (sys_sigaltstack(p, &sa, retval));
	}
	SCARG(&sa, oss) = bsd_oss = stackgap_alloc(&sg, sizeof *bsd_oss);

	error = sys_sigaltstack(p, &sa, retval);
	if (error)
		return (error);

	linux_ss.ss_sp = bsd_oss->ss_sp;
	linux_ss.ss_size = bsd_oss->ss_size;
	linux_ss.ss_flags = 0;
	if (bsd_oss->ss_flags & SS_ONSTACK)
		linux_ss.ss_flags |= LINUX_SS_ONSTACK;
	if (bsd_oss->ss_flags & SS_DISABLE)
		linux_ss.ss_flags |= LINUX_SS_DISABLE;
	return (copyout(&linux_ss, SCARG(uap, oss), sizeof linux_ss));
}

/*
 * The deprecated pause(2), which is really just an instance
 * of sigsuspend(2).
 */
int
linux_sys_pause(p, v, retval)
	register struct proc *p;
	void *v;	
	register_t *retval;
{	
	struct sys_sigsuspend_args bsa;

	SCARG(&bsa, mask) = p->p_sigmask;
	return (sys_sigsuspend(p, &bsa, retval));
}

/*
 * Once more: only a signal conversion is needed.
 */
int
linux_sys_kill(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_kill_args /* {
		syscallarg(int) pid;
		syscallarg(int) signum;
	} */ *uap = v;
	struct sys_kill_args ka;

	SCARG(&ka, pid) = SCARG(uap, pid);
	if (SCARG(uap, signum) < 0 || SCARG(uap, signum) >= LINUX__NSIG)
		return (EINVAL);
	SCARG(&ka, signum) = linux_to_bsd_sig[SCARG(uap, signum)];
	return (sys_kill(p, &ka, retval));
}

int
linux_sys_tgkill(struct proc *p, void *v, register_t *retval)
{
	struct linux_sys_tgkill_args /* {
		syscallarg(int) tgid;
		syscallarg(int) tid;
		syscallarg(int) sig;
	}; */ *uap = v;

	int error;
	int sig;
	struct sys_kill_args ka;

	if (SCARG(uap, tgid) < 0 || SCARG(uap, tid) < 0)
		return (EINVAL);

	if ((error = linux_to_bsd_signal(SCARG(uap, sig), &sig)))
		return (error);

	/* XXX: Ignoring tgid, behaving like the obsolete linux_sys_tkill */
	SCARG(&ka, pid) = SCARG(uap, tid);
	SCARG(&ka, signum) = sig;
	return (sys_kill(p, &ka, retval));
}
@


1.18
log
@make sigprocmask(2) not take the kernel lock

Tests on a 4-core CPU show setjmp(3) run four times as fast under load.

discussed on tech@@ some time ago, now by kettenis and guenther, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.17 2014/03/26 05:23:42 guenther Exp $	*/
@


1.17
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.16 2014/01/21 01:49:13 tedu Exp $	*/
a586 1
	int s;
d606 1
a606 2
	s = splhigh();

d609 1
a609 1
		p->p_sigmask |= bs & ~sigcantmask;
d613 1
a613 1
		p->p_sigmask &= ~bs;
d617 1
a617 1
		p->p_sigmask = bs & ~sigcantmask;
a624 2
	splx(s);

a642 1
	int s;
d665 1
a665 2
	s = splhigh();

d668 1
a668 1
		p->p_sigmask |= bs & ~sigcantmask;
d672 1
a672 1
		p->p_sigmask &= ~bs;
d676 1
a676 1
		p->p_sigmask = bs & ~sigcantmask;
a683 2
	splx(s);

a721 1
	int s;
a727 1
	s = splhigh();
a728 1
	splx(s);
@


1.16
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.15 2012/06/19 11:35:29 pirofti Exp $	*/
d400 1
a400 1
	sg = stackgap_init(p->p_emul);
d471 1
a471 1
	sg = stackgap_init(p->p_emul);
d543 1
a543 1
	sg = stackgap_init(p->p_emul);
d847 1
a847 1
	sg = stackgap_init(p->p_emul);
@


1.15
log
@Implement linux_sys_tgkill.

Nobody calls linux_sys_tkill anymore so code for that is not needed.
If this will become an issue in the future a simple wrapper will fix that.

Okay jasper@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.14 2009/12/09 16:29:56 jsg Exp $	*/
d56 1
a56 1
#define	sigemptyset(s)		bzero((s), sizeof(*(s)))
d62 1
a62 1
#define	linux_sigemptyset(s)	bzero((s), sizeof(*(s)))
d336 1
a336 1
	bzero(lsa, sizeof(struct linux_sigaction));
@


1.14
log
@Add entries in compat signal mapping arrays for SIGTHR.
Prompted by parfait noticing overflows in ibcs2/svr4 which
are now changed to being NSIG sized like the others as
suggested by tedu.

ok tedu@@ miod@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.13 2008/05/01 11:53:26 miod Exp $	*/
d920 25
@


1.13
log
@spl0() is not your friend, use splx() instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.12 2003/02/25 09:10:27 tedu Exp $	*/
d101 1
@


1.12
log
@fix off by one signal checks.  thanks yichen's checker

ok niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.11 2001/08/09 14:15:22 niklas Exp $	*/
d586 1
d606 1
a606 1
	(void) splhigh();
d626 1
a626 1
	(void) spl0();
d646 1
d669 1
a669 1
	(void) splhigh();
d689 1
a689 1
	(void) spl0();
d729 1
d736 1
a736 1
	splhigh();
d738 1
a738 1
	spl0();
@


1.11
log
@Correct linux-compat sigaltstack implementation.
Helps HotSpot Java VMs a bit, but not totally.  I can at least run javac
on J2SE 1.4beta with good results, but anything that uses swing seems to
fail on something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.10 2001/07/27 06:10:38 csapuntz Exp $	*/
d357 1
a357 1
	if (linuxsig < 0 || linuxsig > LINUX__NSIG)
d367 1
a367 1
	if (bsdsig < 0 || bsdsig > NSIG)
@


1.11.4.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d357 1
a357 1
	if (linuxsig < 0 || linuxsig >= LINUX__NSIG)
d367 1
a367 1
	if (bsdsig < 0 || bsdsig >= NSIG)
@


1.10
log
@

Convert array lookups to function calls that are bounds checked
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.9 2001/04/09 06:52:26 tholo Exp $	*/
a843 1
	bsd_nss = stackgap_alloc(&sg, sizeof *bsd_nss);
d845 15
a859 3
	error = copyin(SCARG(uap, nss), &linux_ss, sizeof linux_ss);
	if (error)
		return (error);
a860 4
	bsd_nss->ss_sp = linux_ss.ss_sp;
	bsd_nss->ss_size = linux_ss.ss_size;
	bsd_nss->ss_flags = linux_ss.ss_flags;
	SCARG(&sa, nss) = bsd_nss;
d873 5
a877 1
	linux_ss.ss_flags = bsd_oss->ss_flags;
@


1.9
log
@Silently ignore signals we don't handle; idea from NetBSD.  Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.8 2001/04/02 21:43:11 niklas Exp $	*/
d352 20
@


1.8
log
@On popular demand, the Linux-compatibility clone(2) implementation based
on NetBSD's code, as well as some faked Posix RT extensions by me.  This makes
at least simple linuxthreads tests work.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.7 2000/06/07 14:11:38 niklas Exp $	*/
d402 12
a413 2
	if ((error = sys_sigaction(p, &sa, retval)) != 0)
		return (error);
d474 12
a485 2
	if ((error = sys_sigaction(p, &sa, retval)) != 0)
		return (error);
d535 6
a540 2
	if ((error = sys_sigaction(p, &sa_args, retval)))
		return (error);
@


1.7
log
@Implement sigaltstack
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.6 2000/03/13 08:18:30 jasoni Exp $	*/
d76 1
a76 1
	0,			/* SIGEMT */
d81 1
a81 1
	0,			/* SIGSYS */
d136 2
a137 2
	0,
	0,
d376 1
a376 1
	if (SCARG(uap, signum) < 0 || SCARG(uap, signum) >= LINUX_NSIG)
d437 1
a437 1
	if (SCARG(uap, signum) < 0 || SCARG(uap, signum) >= LINUX_NSIG)
d499 1
a499 1
	if (SCARG(uap, sig) < 0 || SCARG(uap, sig) >= LINUX_NSIG)
d858 1
a858 1
	if (SCARG(uap, signum) < 0 || SCARG(uap, signum) >= LINUX_NSIG)
@


1.6
log
@Implement rt_sigaction, rt_sigprocmask, rt_sigpending & rt_sigsuspend.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.5 2000/03/08 03:35:28 jasoni Exp $	*/
d391 1
a391 1
			return error;
d394 1
a394 1
			return error;
d403 1
a403 1
		return error;
d407 1
a407 1
			return error;
d410 1
a410 1
			return error;
d413 1
a413 1
	return 0;
d452 1
a452 1
			return error;
d455 1
a455 1
			return error;
d465 1
a465 1
		return error;
d469 1
a469 1
			return error;
d472 1
a472 1
			return error;
d475 1
a475 1
	return 0;
d510 1
a510 1
		return error;
d516 1
a516 1
		return error;
d519 1
a519 1
		return error;
d522 1
a522 1
	return 0;
d549 1
a549 1
			return error;
d554 1
a554 1
		return 0;
d557 1
a557 1
		return error;
d583 1
a583 1
	return error;
d611 1
a611 1
			return error;
d616 1
a616 1
		return 0;
d619 1
a619 1
		return error;
d645 1
a645 1
	return error;
d663 1
a663 1
	return 0;
d693 1
a693 1
	return 0;
d711 1
a711 1
	return copyout(&ls, SCARG(uap, mask), sizeof(ls));
d733 1
a733 1
	return copyout(&ls, SCARG(uap, set), sizeof(ls));
d751 1
a751 1
	return sys_sigsuspend(p, &sa, retval);
d771 1
a771 1
	error = copyin(SCARG(uap, unewset), &mask, sizeof(linux_sigset_t));
d776 48
a823 1
	return sys_sigsuspend(p, &sa, retval);
d839 1
a839 1
	return sys_sigsuspend(p, &bsa, retval);
d861 1
a861 1
	return sys_kill(p, &ka, retval);
@


1.5
log
@Add support for the new sigset_t and sigaction.
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.4 1998/12/22 07:58:45 deraadt Exp $	*/
d416 62
d586 62
d715 22
d751 25
@


1.4
log
@range check signal [] conversions
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.3 1997/06/02 09:42:12 deraadt Exp $	*/
d60 1
d63 4
a66 2
#define	linux_sigismember(s, n)	(*(s) & linux_sigmask(n))
#define	linux_sigaddset(s, n)	(*(s) |= linux_sigmask(n))
d68 1
a68 1
int bsd_to_linux_sig[] = {
d76 1
a76 1
	0,
d81 1
a81 1
	0,
d98 1
a98 1
	0,
d103 1
a103 1
int linux_to_bsd_sig[] = {
d120 1
a120 1
	0,
d134 32
d170 10
d181 42
a222 5
/* linux_signal.c */
void linux_to_bsd_sigset __P((const linux_sigset_t *, sigset_t *));
void bsd_to_linux_sigset __P((const sigset_t *, linux_sigset_t *));
void linux_to_bsd_sigaction __P((struct linux_sigaction *, struct sigaction *));
void bsd_to_linux_sigaction __P((struct sigaction *, struct linux_sigaction *));
a223 4
/*
 * Ok, we know that Linux and BSD signals both are just an unsigned int.
 * Don't bother to use the sigismember() stuff for now.
 */
d232 1
a232 1
	for (i = 1; i < LINUX_NSIG; i++) {
d247 1
a247 1
	
d263 43
d314 2
a321 2
	if ((lsa->sa_flags & LINUX_SA_NOCLDSTOP) != 0)
		bsa->sa_flags |= SA_NOCLDSTOP;
d324 2
d334 4
a337 1
	lsa->sa__handler = bsa->sa_handler;
a338 1
	lsa->sa_flags = 0;
d349 3
a351 1
	lsa->sa_restorer = NULL;
a353 1

d367 2
a368 2
		syscallarg(struct linux_sigaction *) nsa;
		syscallarg(struct linux_sigaction *) osa;
d370 1
a370 1
	struct linux_sigaction *nlsa, *olsa, tmplsa;
d392 1
a392 1
		linux_to_bsd_sigaction(&tmplsa, &tmpbsa);
d408 1
a408 1
		bsd_to_linux_sigaction(&tmpbsa, &tmplsa);
d474 2
a475 2
		syscallarg(linux_sigset_t *) set;
		syscallarg(linux_sigset_t *) oset;
d477 1
a477 1
	linux_sigset_t ss;
d485 1
a485 1
		bsd_to_linux_sigset(&p->p_sigmask, &ss);
d497 1
a497 1
	linux_to_bsd_sigset(&ss, &bs);
d538 1
a538 1
	bsd_to_linux_sigset(&p->p_sigmask, (linux_sigset_t *)retval);
d555 1
a555 1
		syscallarg(linux_sigset_t) mask;
d557 1
a557 1
	linux_sigset_t mask;
d560 1
a560 1
	bsd_to_linux_sigset(&p->p_sigmask, (linux_sigset_t *)retval);
d563 1
a563 1
	bsd_to_linux_sigset(&bsdsig, &mask);
d579 1
a579 1
		syscallarg(linux_sigset_t *) mask;
d582 1
a582 1
	linux_sigset_t ls;
d585 1
a585 1
	bsd_to_linux_sigset(&bs, &ls);
d602 1
a602 1
	linux_sigset_t mask = SCARG(uap, mask);
d604 1
a604 1
	linux_to_bsd_sigset(&mask, &SCARG(&sa, mask));
@


1.4.6.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a59 1
/* Locally used defines (in bsd<->linux conversion functions): */
d62 2
a63 4
#define	linux_sigismember(s, n)	((s)->sig[((n) - 1) / LINUX__NSIG_BPW]	\
					& (1 << ((n) - 1) % LINUX__NSIG_BPW))
#define	linux_sigaddset(s, n)	((s)->sig[((n) - 1) / LINUX__NSIG_BPW]	\
					|= (1 << ((n) - 1) % LINUX__NSIG_BPW))
d65 1
a65 1
int bsd_to_linux_sig[NSIG] = {
d73 1
a73 1
	0,			/* SIGEMT */
d78 1
a78 1
	0,			/* SIGSYS */
d95 1
a95 1
	0,			/* SIGINFO */
d100 1
a100 1
int linux_to_bsd_sig[LINUX__NSIG] = {
d117 1
a117 1
	0,			/* SIGSTKFLT */
a130 32
	0,			/* SIGUNUSED */
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
d135 7
d143 2
a144 1
 * Convert between Linux and BSD signal sets.
a146 51
linux_old_to_bsd_sigset(lss, bss)
	const linux_old_sigset_t *lss;
	sigset_t *bss;
{
	linux_old_extra_to_bsd_sigset(lss, (const unsigned long *) 0, bss);    
}

void
bsd_to_linux_old_sigset(bss, lss)
	const sigset_t *bss;
	linux_old_sigset_t *lss;
{
	bsd_to_linux_old_extra_sigset(bss, lss, (unsigned long *) 0); 
}

void
linux_old_extra_to_bsd_sigset(lss, extra, bss)
	const linux_old_sigset_t *lss;
	const unsigned long *extra;
	sigset_t *bss;
{
	linux_sigset_t lsnew;

	/* convert old sigset to new sigset */
	linux_sigemptyset(&lsnew);
	lsnew.sig[0] = *lss;
	if (extra)
		bcopy(extra, &lsnew.sig[1],
			sizeof(linux_sigset_t) - sizeof(linux_old_sigset_t));

	linux_to_bsd_sigset(&lsnew, bss);
}

void
bsd_to_linux_old_extra_sigset(bss, lss, extra)
	const sigset_t *bss;
	linux_old_sigset_t *lss;
	unsigned long *extra;
{
	linux_sigset_t lsnew;

	bsd_to_linux_sigset(bss, &lsnew);

	/* convert new sigset to old sigset */
	*lss = lsnew.sig[0];
	if (extra)
		bcopy(&lsnew.sig[1], extra,
			sizeof(linux_sigset_t) - sizeof(linux_old_sigset_t));
}

void
d154 1
a154 1
	for (i = 1; i < LINUX__NSIG; i++) {
d169 1
a169 1

d185 2
a186 2
linux_old_to_bsd_sigaction(lsa, bsa)
	struct linux_old_sigaction *lsa;
d191 1
a191 1
	linux_old_to_bsd_sigset(&lsa->sa_mask, &bsa->sa_mask);
d206 1
a206 1
bsd_to_linux_old_sigaction(bsa, lsa)
d208 1
a208 1
	struct linux_old_sigaction *lsa;
d212 1
a212 1
	bsd_to_linux_old_sigset(&bsa->sa_mask, &lsa->sa_mask);
a226 48
void
linux_to_bsd_sigaction(lsa, bsa)
	struct linux_sigaction *lsa;
	struct sigaction *bsa;
{

	bsa->sa_handler = lsa->sa__handler;
	linux_to_bsd_sigset(&lsa->sa_mask, &bsa->sa_mask);
	bsa->sa_flags = 0;
	if ((lsa->sa_flags & LINUX_SA_NOCLDSTOP) != 0)
		bsa->sa_flags |= SA_NOCLDSTOP;
	if ((lsa->sa_flags & LINUX_SA_ONSTACK) != 0)
		bsa->sa_flags |= SA_ONSTACK;
	if ((lsa->sa_flags & LINUX_SA_RESTART) != 0)
		bsa->sa_flags |= SA_RESTART;
	if ((lsa->sa_flags & LINUX_SA_ONESHOT) != 0)
		bsa->sa_flags |= SA_RESETHAND;
	if ((lsa->sa_flags & LINUX_SA_NOMASK) != 0)
		bsa->sa_flags |= SA_NODEFER;
	if ((lsa->sa_flags & LINUX_SA_SIGINFO) != 0)
		bsa->sa_flags |= SA_SIGINFO;
}

void
bsd_to_linux_sigaction(bsa, lsa)
	struct sigaction *bsa;
	struct linux_sigaction *lsa;
{

	/* Clear sa_flags and sa_restorer (if it exists) */
	bzero(lsa, sizeof(struct linux_sigaction));

	/* ...and fill in the mask and flags */
	bsd_to_linux_sigset(&bsa->sa_mask, &lsa->sa_mask);
	if ((bsa->sa_flags & SA_NOCLDSTOP) != 0)
		lsa->sa_flags |= LINUX_SA_NOCLDSTOP;
	if ((bsa->sa_flags & SA_ONSTACK) != 0)
		lsa->sa_flags |= LINUX_SA_ONSTACK;
	if ((bsa->sa_flags & SA_RESTART) != 0)
		lsa->sa_flags |= LINUX_SA_RESTART;
	if ((bsa->sa_flags & SA_NODEFER) != 0)
		lsa->sa_flags |= LINUX_SA_NOMASK;
	if ((bsa->sa_flags & SA_RESETHAND) != 0)
		lsa->sa_flags |= LINUX_SA_ONESHOT;
	if ((bsa->sa_flags & SA_SIGINFO) != 0)
		lsa->sa_flags |= LINUX_SA_SIGINFO;
	lsa->sa__handler = bsa->sa_handler;
}
a240 57
		syscallarg(struct linux_old_sigaction *) nsa;
		syscallarg(struct linux_old_sigaction *) osa;
	} */ *uap = v;
	struct linux_old_sigaction *nlsa, *olsa, tmplsa;
	struct sigaction *nbsa, *obsa, tmpbsa;
	struct sys_sigaction_args sa;
	caddr_t sg;
	int error;

	if (SCARG(uap, signum) < 0 || SCARG(uap, signum) >= LINUX_NSIG)
		return (EINVAL);

	sg = stackgap_init(p->p_emul);
	nlsa = SCARG(uap, nsa);
	olsa = SCARG(uap, osa);

	if (olsa != NULL)
		obsa = stackgap_alloc(&sg, sizeof(struct sigaction));
	else
		obsa = NULL;

	if (nlsa != NULL) {
		nbsa = stackgap_alloc(&sg, sizeof(struct sigaction));
		if ((error = copyin(nlsa, &tmplsa, sizeof(tmplsa))) != 0)
			return error;
		linux_old_to_bsd_sigaction(&tmplsa, &tmpbsa);
		if ((error = copyout(&tmpbsa, nbsa, sizeof(tmpbsa))) != 0)
			return error;
	} else
		nbsa = NULL;

	SCARG(&sa, signum) = linux_to_bsd_sig[SCARG(uap, signum)];
	SCARG(&sa, nsa) = nbsa;
	SCARG(&sa, osa) = obsa;

	if ((error = sys_sigaction(p, &sa, retval)) != 0)
		return error;

	if (olsa != NULL) {
		if ((error = copyin(obsa, &tmpbsa, sizeof(tmpbsa))) != 0)
			return error;
		bsd_to_linux_old_sigaction(&tmpbsa, &tmplsa);
		if ((error = copyout(&tmplsa, olsa, sizeof(tmplsa))) != 0)
			return error;
	}

	return 0;
}

int
linux_sys_rt_sigaction(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_rt_sigaction_args /* {
		syscallarg(int) signum;
a242 1
		syscallarg(size_t) sigsetsize;
a249 3
	if (SCARG(uap, sigsetsize) != sizeof(linux_sigset_t))
		return (EINVAL);

d257 1
a257 1
	if (olsa != NULL) 
d269 1
a269 2
	}
	else
d348 2
a349 2
		syscallarg(linux_old_sigset_t *) set;
		syscallarg(linux_old_sigset_t *) oset;
d351 1
a351 1
	linux_old_sigset_t ss;
d359 1
a359 1
		bsd_to_linux_old_sigset(&p->p_sigmask, &ss);
d371 1
a371 63
	linux_old_to_bsd_sigset(&ss, &bs);

	(void) splhigh();

	switch (SCARG(uap, how)) {
	case LINUX_SIG_BLOCK:
		p->p_sigmask |= bs & ~sigcantmask;
		break;

	case LINUX_SIG_UNBLOCK:
		p->p_sigmask &= ~bs;
		break;

	case LINUX_SIG_SETMASK:
		p->p_sigmask = bs & ~sigcantmask;
		break;

	default:
		error = EINVAL;
		break;
	}

	(void) spl0();

	return error;
}

int
linux_sys_rt_sigprocmask(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_rt_sigprocmask_args /* {
		syscallarg(int) how;
		syscallarg(const linux_sigset_t *) set;
		syscallarg(linux_sigset_t *) oset;
		syscallarg(size_t) sigsetsize;
	} */ *uap = v;
	linux_sigset_t ls;
	sigset_t bs;
	int error = 0;

	if (SCARG(uap, sigsetsize) != sizeof(linux_sigset_t))
		return (EINVAL);

	*retval = 0;

	if (SCARG(uap, oset) != NULL) {
		/* Fix the return value first if needed */
		bsd_to_linux_sigset(&p->p_sigmask, &ls);
		if ((error = copyout(&ls, SCARG(uap, oset), sizeof(ls))) != 0)
			return error;
	}

	if (SCARG(uap, set) == NULL)
		/* Just examine */
		return 0;

	if ((error = copyin(SCARG(uap, set), &ls, sizeof(ls))) != 0)
		return error;

	linux_to_bsd_sigset(&ls, &bs);
d412 1
a412 1
	bsd_to_linux_old_sigset(&p->p_sigmask, (linux_old_sigset_t *)retval);
d429 1
a429 1
		syscallarg(linux_old_sigset_t) mask;
d431 1
a431 1
	linux_old_sigset_t mask;
d434 1
a434 1
	bsd_to_linux_old_sigset(&p->p_sigmask, (linux_old_sigset_t *)retval);
d437 1
a437 1
	bsd_to_linux_old_sigset(&bsdsig, &mask);
d453 1
a453 20
		syscallarg(linux_old_sigset_t *) mask;
	} */ *uap = v;
	sigset_t bs;
	linux_old_sigset_t ls;

	bs = p->p_siglist & p->p_sigmask;
	bsd_to_linux_old_sigset(&bs, &ls);

	return copyout(&ls, SCARG(uap, mask), sizeof(ls));
}

int
linux_sys_rt_sigpending(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_rt_sigpending_args /* {
		syscallarg(linux_sigset_t *) set;
		syscallarg(size_t) sigsetsize;
a457 3
	if (SCARG(uap, sigsetsize) != sizeof(linux_sigset_t))
		return (EINVAL);

d461 1
a461 1
	return copyout(&ls, SCARG(uap, set), sizeof(ls));
d476 1
a476 1
	linux_old_sigset_t mask = SCARG(uap, mask);
a477 25
	linux_old_to_bsd_sigset(&mask, &SCARG(&sa, mask));
	return sys_sigsuspend(p, &sa, retval);
}

int
linux_sys_rt_sigsuspend(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
{
	struct linux_sys_rt_sigsuspend_args /* {
		syscallarg(sigset_t *) unewset;
		syscallarg(size_t) sigsetsize;
	} */ *uap = v;
	struct sys_sigsuspend_args sa;
	linux_sigset_t mask;
	int error;

	if (SCARG(uap, sigsetsize) != sizeof(linux_sigset_t))
		return (EINVAL);
	
	error = copyin(SCARG(uap, unewset), &mask, sizeof(linux_sigset_t));
	if (error)
		return (error);
	
@


1.4.6.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.9 2001/04/09 06:52:26 tholo Exp $	*/
d76 1
a76 1
	LINUX_NSIG,		/* XXX Kludge to get RT signal #32 to work */
d81 1
a81 1
	LINUX_NSIG + 1,			/* XXX Kludge to get RT signal #32 to work */
d136 2
a137 2
	SIGEMT,			/* XXX Gruesome hack for linuxthreads:       */
	SIGSYS,			/* Map 1st 2 RT signals onto ones we handle. */
d376 1
a376 1
	if (SCARG(uap, signum) < 0 || SCARG(uap, signum) >= LINUX__NSIG)
d391 1
a391 1
			return (error);
d394 1
a394 1
			return (error);
d402 2
a403 12
	/* Silently ignore unknown signals */
	if (SCARG(&sa, signum) == 0) {
		if (obsa != NULL) {
			obsa->sa_handler = SIG_IGN;
			sigemptyset(&obsa->sa_mask);
			obsa->sa_flags = 0;
		}
	}
	else {
		if ((error = sys_sigaction(p, &sa, retval)) != 0)
			return (error);
	}
d407 1
a407 1
			return (error);
d410 1
a410 1
			return (error);
d413 1
a413 1
	return (0);
d437 1
a437 1
	if (SCARG(uap, signum) < 0 || SCARG(uap, signum) >= LINUX__NSIG)
d452 1
a452 1
			return (error);
d455 1
a455 1
			return (error);
d464 2
a465 12
	/* Silently ignore unknown signals */
	if (SCARG(&sa, signum) == 0) {
		if (obsa != NULL) {
			obsa->sa_handler = SIG_IGN;
			sigemptyset(&obsa->sa_mask);
			obsa->sa_flags = 0;
		}
	}
	else {
		if ((error = sys_sigaction(p, &sa, retval)) != 0)
			return (error);
	}
d469 1
a469 1
			return (error);
d472 1
a472 1
			return (error);
d475 1
a475 1
	return (0);
d499 1
a499 1
	if (SCARG(uap, sig) < 0 || SCARG(uap, sig) >= LINUX__NSIG)
d510 1
a510 1
		return (error);
d515 2
a516 6

	/* Silently ignore unknown signals */
	if (SCARG(&sa_args, signum) != 0) {
		if ((error = sys_sigaction(p, &sa_args, retval)))
			return (error);
	}
d519 1
a519 1
		return (error);
d522 1
a522 1
	return (0);
d549 1
a549 1
			return (error);
d554 1
a554 1
		return (0);
d557 1
a557 1
		return (error);
d583 1
a583 1
	return (error);
d611 1
a611 1
			return (error);
d616 1
a616 1
		return (0);
d619 1
a619 1
		return (error);
d645 1
a645 1
	return (error);
d663 1
a663 1
	return (0);
d693 1
a693 1
	return (0);
d711 1
a711 1
	return (copyout(&ls, SCARG(uap, mask), sizeof ls));
d733 1
a733 1
	return (copyout(&ls, SCARG(uap, set), sizeof ls));
d751 1
a751 1
	return (sys_sigsuspend(p, &sa, retval));
d771 1
a771 1
	error = copyin(SCARG(uap, unewset), &mask, sizeof mask);
d776 1
a776 48
	return (sys_sigsuspend(p, &sa, retval));
}

/*
 * Linux' sigaltstack structure is just of a different order than BSD's
 * so just shuffle the fields around and call our version.
 */
int
linux_sys_sigaltstack(p, v, retval)
	register struct proc *p;
	void *v;	
	register_t *retval;
{	
	struct linux_sys_sigaltstack_args /* {
		syscallarg(const struct linux_sigaltstack *) nss;
		syscallarg(struct linux_sigaltstack *) oss;
	} */ *uap = v;
	struct linux_sigaltstack linux_ss;
	struct sigaltstack *bsd_nss, *bsd_oss;
	struct sys_sigaltstack_args sa;
	int error;
	caddr_t sg;

	sg = stackgap_init(p->p_emul);
	bsd_nss = stackgap_alloc(&sg, sizeof *bsd_nss);

	error = copyin(SCARG(uap, nss), &linux_ss, sizeof linux_ss);
	if (error)
		return (error);

	bsd_nss->ss_sp = linux_ss.ss_sp;
	bsd_nss->ss_size = linux_ss.ss_size;
	bsd_nss->ss_flags = linux_ss.ss_flags;
	SCARG(&sa, nss) = bsd_nss;
	if (SCARG(uap, oss) == NULL) {
		SCARG(&sa, oss) = NULL;
		return (sys_sigaltstack(p, &sa, retval));
	}
	SCARG(&sa, oss) = bsd_oss = stackgap_alloc(&sg, sizeof *bsd_oss);

	error = sys_sigaltstack(p, &sa, retval);
	if (error)
		return (error);

	linux_ss.ss_sp = bsd_oss->ss_sp;
	linux_ss.ss_size = bsd_oss->ss_size;
	linux_ss.ss_flags = bsd_oss->ss_flags;
	return (copyout(&linux_ss, SCARG(uap, oss), sizeof linux_ss));
d792 1
a792 1
	return (sys_sigsuspend(p, &bsa, retval));
d811 1
a811 1
	if (SCARG(uap, signum) < 0 || SCARG(uap, signum) >= LINUX__NSIG)
d814 1
a814 1
	return (sys_kill(p, &ka, retval));
@


1.4.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.4.6.2 2001/05/14 22:04:49 niklas Exp $	*/
a353 20
int
linux_to_bsd_signal(int linuxsig, int *bsdsig)
{
	if (linuxsig < 0 || linuxsig > LINUX__NSIG)
		return (EINVAL);

	*bsdsig = linux_to_bsd_sig[linuxsig];
	return (0);
}

int
bsd_to_linux_signal(int bsdsig, int *linuxsig)
{
	if (bsdsig < 0 || bsdsig > NSIG)
		return (EINVAL);

	*linuxsig = bsd_to_linux_sig[bsdsig];
	return (0);
}

d824 1
d826 3
a828 15
	if (SCARG(uap, nss) != NULL) {
		bsd_nss = stackgap_alloc(&sg, sizeof *bsd_nss);

		error = copyin(SCARG(uap, nss), &linux_ss, sizeof linux_ss);
		if (error)
			return (error);

		bsd_nss->ss_sp = linux_ss.ss_sp;
		bsd_nss->ss_size = linux_ss.ss_size;
		bsd_nss->ss_flags = (linux_ss.ss_flags & LINUX_SS_DISABLE) ?
		    SS_DISABLE : 0;

		SCARG(&sa, nss) = bsd_nss;
	} else
		SCARG(&sa, nss) = NULL;
d830 4
d846 1
a846 5
	linux_ss.ss_flags = 0;
	if (bsd_oss->ss_flags & SS_ONSTACK)
		linux_ss.ss_flags |= LINUX_SS_ONSTACK;
	if (bsd_oss->ss_flags & SS_DISABLE)
		linux_ss.ss_flags |= LINUX_SS_DISABLE;
@


1.4.6.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d357 1
a357 1
	if (linuxsig < 0 || linuxsig >= LINUX__NSIG)
d367 1
a367 1
	if (bsdsig < 0 || bsdsig >= NSIG)
@


1.3
log
@rename sa_handler to sa__handler
@
text
@d1 1
a1 1
/*	$OpenBSD: linux_signal.c,v 1.2 1996/04/17 05:23:59 mickey Exp $	*/
d250 3
d311 3
d514 2
@


1.2
log
@Good fixes and changes from latest Net.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d190 1
a190 1
	bsa->sa_handler = lsa->sa_handler;
d211 1
a211 1
	lsa->sa_handler = bsa->sa_handler;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: linux_signal.c,v 1.9 1995/10/07 06:27:12 mycroft Exp $	*/
d135 7
d191 1
a191 1
	linux_to_bsd_sigset(&bsa->sa_mask, &lsa->sa_mask);
d212 1
a212 1
	bsd_to_linux_sigset(&lsa->sa_mask, &bsa->sa_mask);
d431 1
a431 1
	bsd_to_linux_sigset(&mask, &bsdsig);
d470 1
d472 1
a472 1
	linux_to_bsd_sigset(&SCARG(uap, mask), &SCARG(&sa, mask));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
