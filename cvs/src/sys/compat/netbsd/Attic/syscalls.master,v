head	1.27;
access;
symbols
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.6
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.24.0.4
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.17
	UBC:1.15.0.4
	UBC_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.6
	OPENBSD_2_8:1.11.0.4
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.10.0.4
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10;
locks; strict;
comment	@# @;


1.27
date	2007.05.28.23.10.10;	author beck;	state dead;
branches;
next	1.26;

1.26
date	2006.09.22.15.29.57;	author pedro;	state Exp;
branches;
next	1.25;

1.25
date	2005.06.17.20.39.14;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.09.23.52.02;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.28.18.28.14;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.14.05.23.25;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.11.19.45.18;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.30.22.02.56;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.30.03.29.49;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.06.19.14.20;	author nordin;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.00.42.25;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.21.15.31.59;	author art;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2001.09.05.23.41.45;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.16.21.24.01;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.16.17.14.38;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.01.23.10.58;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.09.21.22.45.07;	author kstailey;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	99.09.17.22.14.09;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	99.09.17.15.03.18;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	99.09.17.13.41.29;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	99.09.17.12.13.47;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	99.09.15.20.41.16;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	99.09.15.18.36.38;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	99.09.14.01.05.25;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	99.09.12.14.34.18;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	99.09.12.14.15.17;	author kstailey;	state Exp;
branches;
next	;

1.10.4.1
date	2001.05.14.22.04.59;	author niklas;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2001.07.04.10.39.36;	author niklas;	state Exp;
branches;
next	1.10.4.3;

1.10.4.3
date	2001.10.31.03.11.46;	author nate;	state Exp;
branches;
next	1.10.4.4;

1.10.4.4
date	2002.03.28.11.28.06;	author niklas;	state Exp;
branches;
next	1.10.4.5;

1.10.4.5
date	2003.03.27.23.53.47;	author niklas;	state Exp;
branches;
next	1.10.4.6;

1.10.4.6
date	2003.05.13.19.21.27;	author ho;	state Exp;
branches;
next	1.10.4.7;

1.10.4.7
date	2004.02.19.10.51.29;	author niklas;	state Exp;
branches;
next	1.10.4.8;

1.10.4.8
date	2004.06.05.23.12.34;	author niklas;	state Exp;
branches;
next	;

1.15.4.1
date	2002.06.11.03.28.08;	author art;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2002.10.29.00.30.51;	author art;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2003.05.19.21.52.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Maintaining a broken compatibility layer for a broken OS is not a productive
activity for anyone. Bye bye COMPAT_NETBSD. ok tedu@@, deraadt@@, and many others
in the hackathon room.
@
text
@;	$OpenBSD: syscalls.master,v 1.26 2006/09/22 15:29:57 pedro Exp $

;	@@(#)syscalls.master	8.2 (Berkeley) 1/13/94

; OpenBSD COMPAT_NETBSD system call name/number "master" file.
; (See syscalls.conf to see what it is processed into.)
;
; Fields: number type [type-dependent ...]
;	number	system call number, must be in order
;	type	one of STD, OBSOL, UNIMPL, NODEF, NOARGS, or one of
;		the compatibility options defined in syscalls.conf.
;
; types:
;	STD	always included
;	OBSOL	obsolete, not included in system
;	UNIMPL	unimplemented, not included in system
;	NODEF	included, but don't define the syscall number
;	NOARGS	included, but don't define the syscall args structure
;	INDIR	included, but don't define the syscall args structure,
;		and allow it to be "really" varargs.
;
; The compat options are defined in the syscalls.conf file, and the
; compat option name is prefixed to the syscall name.  Other than
; that, they're like NODEF (for 'compat' options), or STD (for
; 'libcompat' options).
;
; The type-dependent arguments are as follows:
; For STD, NODEF, NOARGS, and compat syscalls:
;	{ pseudo-proto } [alias]
; For other syscalls:
;	[comment]
;
; #ifdef's, etc. may be included, and are copied to the output files.
; #include's are copied to the syscall switch definition file only.

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signal.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#include <sys/poll.h>

#include <compat/netbsd/netbsd_types.h>
#include <compat/netbsd/netbsd_stat.h>
#include <compat/netbsd/netbsd_signal.h>
#include <compat/netbsd/netbsd_syscallargs.h>

#include <machine/netbsd_machdep.h>

; Reserved/unimplemented system calls in the range 0-150 inclusive
; are reserved for use in future Berkeley releases.
; Additional system calls implemented in vendor and other
; redistributions should be placed in the reserved range at the end
; of the current calls.

0	INDIR		{ int sys_syscall(int number, ...); }
1	NOARGS		{ void sys_exit(int rval); }
2	NOARGS		{ int sys_fork(void); }
3	NOARGS		{ ssize_t sys_read(int fd, void *buf, size_t nbyte); }
4	NOARGS		{ ssize_t sys_write(int fd, const void *buf, \
			    size_t nbyte); }
; XXX int mode vs. mode_t mode
5	STD		{ int netbsd_sys_open(char *path, \
			    int flags, ... int mode); }
6	NOARGS		{ int sys_close(int fd); }
7	NOARGS		{ int sys_wait4(int pid, int *status, int options, \
			    struct rusage *rusage); }
; XXX int mode vs. mode_t mode
8	STD		{ int compat_43_netbsd_sys_creat(char *path, \
			    int mode); } ocreat
9	STD		{ int netbsd_sys_link(char *path, char *link); }
10	STD		{ int netbsd_sys_unlink(char *path); }
11	OBSOL		execv
12	STD		{ int netbsd_sys_chdir(char *path); }
13	NOARGS		{ int sys_fchdir(int fd); }
; XXX int mode vs. mode_t mode
14	STD		{ int netbsd_sys_mknod(char *path, int mode, \
			    dev_t dev); }
; XXX int mode vs. mode_t mode
15	STD		{ int netbsd_sys_chmod(char *path, int mode); }
16	STD		{ int netbsd_sys_chown(char *path, uid_t uid, \
			    gid_t gid); }
17	NOARGS		{ int sys_obreak(char *nsize); } break
18	NOARGS		{ int compat_25_sys_getfsstat(struct ostatfs *buf, \
			    long bufsize, int flags); }
19	NOARGS		{ long sys_lseek(int fd, long offset, int whence); } \
			    olseek
20	NOARGS		{ pid_t sys_getpid(void); }
21	NOARGS		{ int sys_mount(const char *type, const char *path, \
			    int flags, void *data); }
22	STD		{ int netbsd_sys_unmount(char *path, int flags); }
23	NOARGS		{ int sys_setuid(uid_t uid); }
24	NOARGS		{ uid_t sys_getuid(void); }
25	NOARGS		{ uid_t sys_geteuid(void); }
#ifdef PTRACE
26	NOARGS		{ int sys_ptrace(int req, pid_t pid, caddr_t addr, \
			    int data); }
#else
26	UNIMPL		ptrace
#endif
27	NOARGS		{ ssize_t sys_recvmsg(int s, struct msghdr *msg, \
			    int flags); }
28	NOARGS		{ ssize_t sys_sendmsg(int s, \
			    const struct msghdr *msg, int flags); }
; XXX unsigned int *fromlenaddr vs. socklen_t *fromlenaddr
29	NOARGS		{ ssize_t sys_recvfrom(int s, void *buf, size_t len, \
			    int flags, struct sockaddr *from, \
			    socklen_t *fromlenaddr); }
; XXX unsigned int *fromlenaddr vs. socklen_t *fromlenaddr
30	NOARGS		{ int sys_accept(int s, struct sockaddr *name, \
			    socklen_t *anamelen); }
; XXX unsigned int *alen vs. int *alen
31	NOARGS		{ int sys_getpeername(int fdes, struct sockaddr *asa, \
			    int *alen); }
32	NOARGS		{ int sys_getsockname(int fdes, struct sockaddr *asa, \
			    socklen_t *alen); }
33	STD		{ int netbsd_sys_access(char *path, int flags); }
; XXX u_long flags vs. u_int flags
34	STD		{ int netbsd_sys_chflags(char *path, u_int flags); }
; XXX u_long flags vs. u_int flags
35	NOARGS		{ int sys_fchflags(int fd, u_int flags); }
36	NOARGS		{ void sys_sync(void); }
37	NOARGS		{ int sys_kill(int pid, int signum); }
38	STD		{ int compat_43_netbsd_sys_stat(char *path, \
			    struct stat43 *ub); } stat43
39	NOARGS		{ pid_t sys_getppid(void); }
40	STD		{ int compat_43_netbsd_sys_lstat(char *path, \
			    struct stat43 *ub); } lstat43
41	NOARGS		{ int sys_dup(int fd); }
42	NOARGS		{ int sys_opipe(void); }
43	NOARGS		{ gid_t sys_getegid(void); }
44	NOARGS		{ int sys_profil(caddr_t samples, size_t size, \
			    u_long offset, u_int scale); }
#ifdef KTRACE
45	NOARGS		{ int sys_ktrace(const char *fname, int ops, \
			    int facs, pid_t pid); }
#else
45	UNIMPL		ktrace
#endif
46	NOARGS		{ int sys_sigaction(int signum, \
			    const struct sigaction *nsa, \
			    struct sigaction *osa); }
47	NOARGS		{ gid_t sys_getgid(void); }
48	NOARGS		{ int sys_sigprocmask(int how, sigset_t mask); }
49	NOARGS		{ int sys_getlogin(char *namebuf, u_int namelen); }
50	NOARGS		{ int sys_setlogin(const char *namebuf); }
#ifdef ACCOUNTING
51	NOARGS		{ int sys_acct(const char *path); }
#else
51	UNIMPL		acct
#endif
52	NOARGS		{ int sys_sigpending(void); }
53	NOARGS		{ int sys_osigaltstack(const struct osigaltstack *nss, \
			    struct osigaltstack *oss); }
54	NOARGS		{ int sys_ioctl(int fd, \
			    u_long com, ... void *data); }
55	NOARGS		{ int sys_reboot(int opt); }
56	STD		{ int netbsd_sys_revoke(char *path); }
57	STD		{ int netbsd_sys_symlink(char *path, char *link); }
58	STD		{ int netbsd_sys_readlink(char *path, char *buf, \
			    size_t count); }
59	STD		{ int netbsd_sys_execve(char *path, \
			    char **argp, char **envp); }
60	NOARGS		{ int sys_umask(int newmask); }
61	STD		{ int netbsd_sys_chroot(char *path); }
62	NOARGS		{ int sys_fstat(int fd, struct stat43 *sb); } fstat43
63	NOARGS		{ int compat_43_sys_getkerninfo(int op, char *where, \
			    int *size, int arg); } ogetkerninfo
64	NOARGS		{ int compat_43_sys_getpagesize(void); } ogetpagesize
65	NOARGS		{ int compat_25_sys_omsync(caddr_t addr, size_t len); }
66	NOARGS		{ int sys_vfork(void); }
67	OBSOL		vread
68	OBSOL		vwrite
69	NOARGS		{ int sys_sbrk(int incr); }
70	NOARGS		{ int sys_sstk(int incr); }
71	NOARGS		{ int sys_mmap(caddr_t addr, size_t len, int prot, \
			    int flags, int fd, long pos); } ommap
72	NOARGS		{ int sys_ovadvise(int anom); } vadvise
73	NOARGS		{ int sys_munmap(void *addr, size_t len); }
74	NOARGS		{ int sys_mprotect(void *addr, size_t len, \
			    int prot); }
75	NOARGS		{ int sys_madvise(void *addr, size_t len, \
			    int behav); }
76	OBSOL		vhangup
77	OBSOL		vlimit
78	NOARGS		{ int sys_mincore(void *addr, size_t len, \
			    char *vec); }
79	NOARGS		{ int sys_getgroups(int gidsetsize, \
			    gid_t *gidset); }
80	NOARGS		{ int sys_setgroups(int gidsetsize, \
			    const gid_t *gidset); }
81	NOARGS		{ int sys_getpgrp(void); }
82	NOARGS		{ int sys_setpgid(pid_t pid, int pgid); }
83	NOARGS		{ int sys_setitimer(int which, \
			    const struct itimerval *itv, \
			    struct itimerval *oitv); }
84	NOARGS		{ int compat_43_sys_wait(void); } owait
85	NOARGS		{ int compat_25_sys_swapon(const char *name); }
86	NOARGS		{ int sys_getitimer(int which, \
			    struct itimerval *itv); }
87	NOARGS		{ int compat_43_sys_gethostname(char *hostname, \
			    u_int len); } ogethostname
88	NOARGS		{ int compat_43_sys_sethostname(char *hostname, \
			    u_int len); } osethostname
89	NOARGS		{ int compat_43_sys_getdtablesize(void); } \
			    ogetdtablesize
90	NOARGS		{ int sys_dup2(int from, int to); }
91	UNIMPL		getdopt
92	NOARGS		{ int sys_fcntl(int fd, int cmd, ... void *arg); }
93	NOARGS		{ int sys_select(int nd, fd_set *in, fd_set *ou, \
			    fd_set *ex, struct timeval *tv); }
94	UNIMPL		setdopt
95	NOARGS		{ int sys_fsync(int fd); }
96	NOARGS		{ int sys_setpriority(int which, int who, int prio); }
97	NOARGS		{ int sys_socket(int domain, int type, int protocol); }
98	NOARGS		{ int sys_connect(int s, const struct sockaddr *name, \
			    socklen_t namelen); }
99	NOARGS		{ int sys_accept(int s, caddr_t name, \
			    int *anamelen); } oaccept
100	NOARGS		{ int sys_getpriority(int which, int who); }
101	NOARGS		{ int compat_43_sys_send(int s, caddr_t buf, int len, \
			    int flags); } osend
102	NOARGS		{ int compat_43_sys_recv(int s, caddr_t buf, int len, \
			    int flags); } orecv
103	NOARGS		{ int sys_sigreturn(struct sigcontext *sigcntxp); }
104	NOARGS		{ int sys_bind(int s, const struct sockaddr *name, \
			    socklen_t namelen); }
105	NOARGS		{ int sys_setsockopt(int s, int level, int name, \
			    const void *val, socklen_t valsize); }
106	NOARGS		{ int sys_listen(int s, int backlog); }
107	OBSOL		vtimes
108	NOARGS		{ int compat_43_sys_sigvec(int signum, \
			    struct sigvec *nsv, struct sigvec *osv); } osigvec
109	NOARGS		{ int compat_43_sys_sigblock(int mask); } osigblock
110	NOARGS		{ int compat_43_sys_sigsetmask(int mask); } osigsetmask
111	NOARGS		{ int sys_sigsuspend(int mask); }
112	NOARGS		{ int compat_43_sys_sigstack(struct sigstack *nss, \
			    struct sigstack *oss); } osigstack
#ifdef MSG_COMPAT
113	NOARGS		{ int compat_43_sys_recvmsg(int s, \
			    struct omsghdr *msg, int flags); } orecvmsg
#else
113	OBSOL		orecvmsg
#endif
#ifdef MSG_COMPAT
114	NOARGS		{ int compat_43_sys_sendmsg(int s, caddr_t msg, \
			    int flags); } osendmsg
#else
114	OBSOL		orecvmsg
#endif
115	OBSOL		vtrace
116	NOARGS		{ int sys_gettimeofday(struct timeval *tp, \
			    struct timezone *tzp); }
117	NOARGS		{ int sys_getrusage(int who, struct rusage *rusage); }
118	NOARGS		{ int sys_getsockopt(int s, int level, int name, \
			    void *val, socklen_t *avalsize); }
119	OBSOL		resuba
120	NOARGS		{ ssize_t sys_readv(int fd, \
			    const struct iovec *iovp, int iovcnt); }
121	NOARGS		{ ssize_t sys_writev(int fd, \
			    const struct iovec *iovp, int iovcnt); }
122	NOARGS		{ int sys_settimeofday(const struct timeval *tv, \
			    const struct timezone *tzp); }
123	NOARGS		{ int sys_fchown(int fd, uid_t uid, gid_t gid); }
124	NOARGS		{ int sys_fchmod(int fd, int mode); }
#ifdef MSG_COMPAT
125	NOARGS		{ int compat_43_sys_recvfrom(int s, caddr_t buf, \
			    size_t len, int flags, caddr_t from, \
			    int *fromlenaddr); } orecvfrom
#else
125	OBSOL		orecvfrom
#endif
126	NOARGS		{ int sys_setreuid(uid_t ruid, uid_t euid); }
127	NOARGS		{ int sys_setregid(gid_t rgid, gid_t egid); }
128	STD		{ int netbsd_sys_rename(char *from, char *to); }
129	STD		{ int compat_43_netbsd_sys_truncate(char *path, \
			    long length); } otruncate
130	NOARGS		{ int compat_43_sys_ftruncate(int fd, long length); } \
			    oftruncate
131	NOARGS		{ int sys_flock(int fd, int how); }
132	STD		{ int netbsd_sys_mkfifo(char *path, int mode); }
133	NOARGS		{ ssize_t sys_sendto(int s, const void *buf, \
			    size_t len, int flags, const struct sockaddr *to, \
			    socklen_t tolen); }
134	NOARGS		{ int sys_shutdown(int s, int how); }
135	NOARGS		{ int sys_socketpair(int domain, int type, \
			    int protocol, int *rsv); }
136	STD		{ int netbsd_sys_mkdir(char *path, int mode); }
137	STD		{ int netbsd_sys_rmdir(char *path); }
138	NOARGS		{ int sys_utimes(const char *path, \
			    const struct timeval *tptr); }
139	OBSOL		4.2 sigreturn
140	NOARGS		{ int sys_adjtime(const struct timeval *delta, \
			    struct timeval *olddelta); }
141	NOARGS		{ int compat_43_sys_getpeername(int fdes, caddr_t asa, \
			    int *alen); } ogetpeername
142	NOARGS		{ int32_t compat_43_sys_gethostid(void); } ogethostid
143	NOARGS		{ int compat_43_sys_sethostid(int32_t hostid); } \
			    osethostid
144	NOARGS		{ int compat_43_sys_getrlimit(u_int which, \
			    struct ogetrlimit *rlp); } ogetrlimit
145	NOARGS		{ int compat_43_sys_setrlimit(u_int which, \
			    struct ogetrlimit *rlp); } osetrlimit
146	NOARGS		{ int compat_43_sys_killpg(int pgid, int signum); } \
			    okillpg
147	NOARGS		{ int sys_setsid(void); }
148	NOARGS		{ int sys_quotactl(const char *path, int cmd, \
			    int uid, char *arg); }
149	NOARGS		{ int compat_43_sys_quota(void); } oquota
150	NOARGS		{ int compat_43_sys_getsockname(int fdec, caddr_t asa, \
			    int *alen); } ogetsockname

; Syscalls 151-180 inclusive are reserved for vendor-specific
; system calls.  (This includes various calls added for compatibity
; with other Unix variants.)
; Some of these calls are now supported by BSD...
151	UNIMPL
152	UNIMPL
153	UNIMPL
154	UNIMPL
#if defined(NFSCLIENT) || defined(NFSSERVER)
155	NOARGS		{ int sys_nfssvc(int flag, void *argp); }
#else
155	UNIMPL
#endif
156	NOARGS		{ int compat_43_sys_getdirentries(int fd, char *buf, \
			    u_int count, long *basep); } ogetdirentries
157	NOARGS		{ int compat_25_sys_statfs(char *path, \
			    struct ostatfs *buf); }
158	NOARGS		{ int compat_25_sys_fstatfs(int fd, \
			    struct ostatfs *buf); }
159	UNIMPL
160	UNIMPL
#if defined(NFSCLIENT) || defined(NFSSERVER)
161	NOARGS		{ int sys_getfh(const char *fname, fhandle_t *fhp); }
#else
161	UNIMPL		getfh
#endif
162	NOARGS		{ int compat_09_sys_getdomainname(char *domainname, \
			    int len); } ogetdomainname
163	NOARGS		{ int compat_09_sys_setdomainname(char *domainname, \
			    int len); } osetdomainname
164	NOARGS		{ int compat_09_sys_uname(struct outsname *name); } \
			    ouname
165	NOARGS		{ int sys_sysarch(int op, char *parms); }
166	UNIMPL
167	UNIMPL
168	UNIMPL
; XXX more generally, never on machines where sizeof(void *) != sizeof(int)
#if defined(SYSVSEM) && !defined(alpha)
169	NOARGS		{ int compat_10_sys_semsys(int which, int a2, int a3, \
			    int a4, int a5); } osemsys
#else
169	UNIMPL		1.0 semsys
#endif
; XXX more generally, never on machines where sizeof(void *) != sizeof(int)
#if defined(SYSVMSG) && !defined(alpha)
170	NOARGS		{ int compat_10_sys_msgsys(int which, int a2, int a3, \
			    int a4, int a5, int a6); } omsgsys
#else
170	UNIMPL		1.0 msgsys
#endif
; XXX more generally, never on machines where sizeof(void *) != sizeof(int)
#if defined(SYSVSHM) && !defined(alpha)
171	NOARGS		{ int compat_10_sys_shmsys(int which, int a2, int a3, \
			    int a4); }
#else
171	UNIMPL		1.0 shmsys
#endif
172	UNIMPL
173	NOARGS		{ ssize_t sys_pread(int fd, void *buf, \
			    size_t nbyte, int pad, off_t offset); }
174	NOARGS		{ ssize_t sys_pwrite(int fd, const void *buf, \
			    size_t nbyte, int pad, off_t offset); }
175	UNIMPL		ntp_gettime
176	UNIMPL		ntp_adjtime
177	UNIMPL
178	UNIMPL
179	UNIMPL
180	UNIMPL

; Syscalls 181-199 are used by/reserved for BSD
181	NOARGS		{ int sys_setgid(gid_t gid); }
182	NOARGS		{ int sys_setegid(gid_t egid); }
183	NOARGS		{ int sys_seteuid(uid_t euid); }
184	UNIMPL
185	UNIMPL
186	UNIMPL
187	UNIMPL
188	STD		{ int netbsd_sys_stat(char *path, struct stat35 *ub); }
189	NOARGS		{ int sys_fstat(int fd, struct stat35 *sb); }
190	STD		{ int netbsd_sys_lstat(char *path, struct stat35 *ub); }
191	STD		{ long netbsd_sys_pathconf(char *path, int name); }
192	NOARGS		{ long sys_fpathconf(int fd, int name); }
193	NOARGS		{ int sys_swapctl(int cmd, const void *arg, int misc); }
194	NOARGS		{ int sys_getrlimit(int which, \
			    struct rlimit *rlp); }
195	NOARGS		{ int sys_setrlimit(int which, \
			    const struct rlimit *rlp); }
196	NOARGS		{ int sys_getdirentries(int fd, char *buf, \
			    int count, long *basep); }
197	NOARGS		{ void *sys_mmap(void *addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }
198	INDIR		{ quad_t sys___syscall(quad_t num, ...); }
199	NOARGS		{ off_t sys_lseek(int fd, int pad, off_t offset, \
			    int whence); }
200	STD		{ int netbsd_sys_truncate(char *path, int pad, \
			    off_t length); }
201	NOARGS		{ int sys_ftruncate(int fd, int pad, off_t length); }
202	NOARGS		{ int sys___sysctl(int *name, u_int namelen, \
			    void *old, size_t *oldlenp, void *new, \
			    size_t newlen); }
203	NOARGS		{ int sys_mlock(const void *addr, size_t len); }
204	NOARGS		{ int sys_munlock(const void *addr, size_t len); }
205	UNIMPL		sys_undelete
206	NOARGS		{ int sys_futimes(int fd, \
			    const struct timeval *tptr); }
207	NOARGS		{ int sys_getpgid(pid_t pid); }
208	NOARGS		{ int sys_xfspioctl(int operation, char *a_pathP, \
			    int a_opcode, struct ViceIoctl *a_paramsP, \
			    int a_followSymlinks); }
; XXX u_int nfds vs. unsigned long nfds
209	NOARGS		{ int sys_poll(struct pollfd *fds, \
			    unsigned long nfds, int timeout); }
;
; Syscalls 210-219 are reserved for dynamically loaded syscalls
;
#ifdef LKM
210	NODEF		{ int sys_lkmnosys(void); }
211	NODEF		{ int sys_lkmnosys(void); }
212	NODEF		{ int sys_lkmnosys(void); }
213	NODEF		{ int sys_lkmnosys(void); }
214	NODEF		{ int sys_lkmnosys(void); }
215	NODEF		{ int sys_lkmnosys(void); }
216	NODEF		{ int sys_lkmnosys(void); }
217	NODEF		{ int sys_lkmnosys(void); }
218	NODEF		{ int sys_lkmnosys(void); }
219	NODEF		{ int sys_lkmnosys(void); }
#else	/* !LKM */
210	UNIMPL
211	UNIMPL
212	UNIMPL
213	UNIMPL
214	UNIMPL
215	UNIMPL
216	UNIMPL
217	UNIMPL
218	UNIMPL
219	UNIMPL
#endif	/* !LKM */
; System calls 220-240 are reserved for use by OpenBSD
#ifdef SYSVSEM
220	NOARGS		{ int compat_23_sys___semctl(int semid, int semnum, \
			    int cmd, union semun *arg); } __osemctl
221	NOARGS		{ int sys_semget(key_t key, int nsems, int semflg); }
222	NOARGS		{ int sys_semop(int semid, struct sembuf *sops, \
			    u_int nsops); }
223	OBSOL		sys_semconfig
#else
220	UNIMPL		semctl
221	UNIMPL		semget
222	UNIMPL		semop
223	UNIMPL		semconfig
#endif
#ifdef SYSVMSG
224	NOARGS		{ int compat_23_sys_msgctl(int msqid, int cmd, \
			    struct omsqid_ds *buf); } omsgctl
225	NOARGS		{ int sys_msgget(key_t key, int msgflg); }
226	NOARGS		{ int sys_msgsnd(int msqid, const void *msgp, \
			    size_t msgsz, int msgflg); }
227	NOARGS		{ int sys_msgrcv(int msqid, void *msgp, size_t msgsz, \
			    long msgtyp, int msgflg); }
#else
224	UNIMPL		msgctl
225	UNIMPL		msgget
226	UNIMPL		msgsnd
227	UNIMPL		msgrcv
#endif
#ifdef SYSVSHM
228	NOARGS		{ void *sys_shmat(int shmid, const void *shmaddr, \
			    int shmflg); }
229	NOARGS		{ int compat_23_sys_shmctl(int shmid, int cmd, \
			    struct oshmid_ds *buf); } oshmctl
230	NOARGS		{ int sys_shmdt(const void *shmaddr); }
231	NOARGS		{ int sys_shmget(key_t key, int size, int shmflg); }
#else
228	UNIMPL		shmat
229	UNIMPL		shmctl
230	UNIMPL		shmdt
231	UNIMPL		shmget
#endif
232	NOARGS		{ int sys_clock_gettime(clockid_t clock_id, \
			    struct timespec *tp); }
233	NOARGS		{ int sys_clock_settime(clockid_t clock_id, \
			    const struct timespec *tp); }
234	NOARGS		{ int sys_clock_getres(clockid_t clock_id, \
			    struct timespec *tp); }
235	UNIMPL		timer_create
236	UNIMPL		timer_delete
237	UNIMPL		timer_settime
238	UNIMPL		timer_gettime
239	UNIMPL		timer_getoverrun
;
; System calls 240-249 are reserved for other IEEE Std1003.1b syscalls
;
240	NOARGS		{ int sys_nanosleep(const struct timespec *rqtp, \
			    struct timespec *rmtp); }
241	STD		{ int netbsd_sys_fdatasync(int fd); }
242	UNIMPL
243	UNIMPL
244	UNIMPL
245	UNIMPL
246	UNIMPL
247	UNIMPL
248	UNIMPL
249	UNIMPL
250	UNIMPL
251	UNIMPL
252	UNIMPL
253	UNIMPL
254	UNIMPL
255	UNIMPL
256	UNIMPL
257	UNIMPL
258	UNIMPL
259	UNIMPL
260	UNIMPL
261	UNIMPL
262	UNIMPL
263	UNIMPL
264	UNIMPL
265	UNIMPL
266	UNIMPL
267	UNIMPL
268	UNIMPL
269	UNIMPL
270	UNIMPL
;270	STD		{ int netbsd_sys___posix_rename(const char *from, \
;			    const char *to); }
271	UNIMPL
;271	STD		{ int netbsd_sys_swapctl(int cmd, const void *arg,
;			    int misc); }
272	STD		{ int netbsd_sys_getdents(int fd, char *buf, \
			    size_t count); }
273	NOARGS		{ int sys_minherit(void *addr, size_t len, \
			    int inherit); }
274	STD		{ int netbsd_sys_lchmod(const char *path, \
			    netbsd_mode_t mode); }
275	NOARGS		{ int sys_lchown(const char *path, uid_t uid, \
			    gid_t gid); }
276	STD		{ int netbsd_sys_lutimes(const char *path, \
			    const struct timeval *tptr); }
277	NOARGS		{ int sys_msync(void *addr, size_t len, int flags); }
278	STD		{ int netbsd_sys___stat13(char *path, \
			   struct netbsd_stat *ub); }
279	STD		{ int netbsd_sys___fstat13(int fd, \
			    struct netbsd_stat *ub); }
280	STD		{ int netbsd_sys___lstat13(char *path, \
			    struct netbsd_stat *ub); }
281	NOARGS		{ int sys_sigaltstack( \
			    const struct sigaltstack *nss, \
			    struct sigaltstack *oss); }
282	STD		{ int netbsd_sys___vfork14(void); }
283	UNIMPL
;283	STD		{ int netbsd_sys___posix_chown(const char *path, \
;			    uid_t uid, gid_t gid); }
284	UNIMPL
;284	STD		{ int netbsd_sys___posix_fchown(int fd, uid_t uid, \
;			    gid_t gid); }
285	UNIMPL
;285	STD		{ int netbsd_sys___posix_lchown(const char *path, \
;			    uid_t uid, gid_t gid); }
286	NOARGS		{ int sys_getsid(pid_t pid); }
287	UNIMPL
#ifdef KTRACE
288	UNIMPL
;288	STD		{ int netbsd_sys_fktrace(const int fd, int ops, \
;			    int facs, int pid); }
#else
288	UNIMPL
#endif
289	NOARGS		{ ssize_t sys_preadv(int fd, \
			    const struct iovec *iovp, int iovcnt, \
			    int pad, off_t offset); }
290	NOARGS		{ ssize_t sys_pwritev(int fd, \
			    const struct iovec *iovp, int iovcnt, \
			    int pad, off_t offset); }
291	STD		{ int netbsd_sys___sigaction14(int signum, \
			    const struct netbsd_sigaction *nsa, \
			    struct netbsd_sigaction *osa); }
292	STD		{ int netbsd_sys___sigpending14(netbsd_sigset_t \
			    *set); }
293	STD		{ int netbsd_sys___sigprocmask14(int how, \
			    const netbsd_sigset_t *set, \
			    netbsd_sigset_t *oset); }
294	STD		{ int netbsd_sys___sigsuspend14(const netbsd_sigset_t \
			    *set); }
295	STD		{ int netbsd_sys___sigreturn14(struct \
			    netbsd_sigcontext *sigcntxp); }
296	STD		{ int netbsd_sys___getcwd(char *bufp, size_t length); }
297	UNIMPL
;297	STD		{ int netbsd_sys_fchroot(int fd); }
298	UNIMPL
299	UNIMPL
300	UNIMPL
301	UNIMPL
302	UNIMPL
303	UNIMPL
304	UNIMPL
305	STD		{ int sys_issetugid(void); }
@


1.26
log
@Remove LFS system calls from here too
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.25 2005/06/17 20:39:14 millert Exp $
@


1.25
log
@remove undelete syscall
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.24 2004/07/13 21:04:29 millert Exp $
a385 8
#ifdef LFS
184	NOARGS		{ int lfs_bmapv(fsid_t *fsidp, \
			    struct block_info *blkiov, int blkcnt); }
185	NOARGS		{ int lfs_markv(fsid_t *fsidp, \
			    struct block_info *blkiov, int blkcnt); }
186	NOARGS		{ int lfs_segclean(fsid_t *fsidp, u_long segment); }
187	NOARGS		{ int lfs_segwait(fsid_t *fsidp, struct timeval *tv); }
#else
a389 1
#endif
@


1.24
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.23 2004/07/09 23:52:02 millert Exp $
d424 1
a424 1
205	NOARGS		{ int sys_undelete(const char *path); }
@


1.23
log
@Rename ostat -> stat43 to disambiguate from upcoming struct stat changes.
Idea from NetBSD, OK deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.22 2004/05/28 18:28:14 tedu Exp $
d399 3
a401 3
188	STD		{ int netbsd_sys_stat(char *path, struct stat *ub); }
189	NOARGS		{ int sys_fstat(int fd, struct stat12 *sb); }
190	STD		{ int netbsd_sys_lstat(char *path, struct stat *ub); }
@


1.22
log
@ACCOUNTING is optional.  found by mpech. ok deraadt
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.21 2004/01/14 05:23:25 tedu Exp $
a123 1
; XXX struct stat43 *ub vs. struct ostat *ub
d125 1
a125 1
			    struct ostat *ub); } ostat
a126 1
; XXX struct stat43 *ub vs. struct ostat *ub
d128 1
a128 1
			    struct ostat *ub); } olstat
d166 1
a166 1
62	NOARGS		{ int sys_fstat(int fd, struct ostat *sb); } ofstat
@


1.21
log
@change sigaltstack.ss_size type to size_t.  handle syscall fallout.
add stack_t and ucontext_t typedefs.
ok deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.20 2003/05/11 19:45:18 deraadt Exp $
d149 1
d151 3
@


1.20
log
@finish compat swapon cleanup
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.19 2003/04/30 22:02:56 miod Exp $
d151 2
a152 2
53	NOARGS		{ int sys_sigaltstack(const struct sigaltstack *nss, \
			    struct sigaltstack *oss); }
d567 3
a569 3
281	STD		{ int netbsd_sys___sigaltstack14( \
			    const struct netbsd_sigaltstack *nss, \
			    struct netbsd_sigaltstack *oss); }
@


1.19
log
@Oops, repair omsync deprecation lossage.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.18 2003/01/30 03:29:49 millert Exp $
d196 1
a196 1
85	NOARGS		{ int sys_swapon(const char *name); }
@


1.18
log
@Bring back setreuid(2) and setregid(2) as first class syscalls
(but still implemented via setres[ug]id(2)).  Basically this just
moves them from COMPAT_43 into kern_prot.c.  Also fixes a typo in my
old implementation.  The userland portion will follow in a few days.
deraadt@@ OK
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.17 2002/07/06 19:14:20 nordin Exp $
d168 1
a168 1
65	NOARGS		{ int sys_omsync(caddr_t addr, size_t len); }
@


1.17
log
@Remove kernel support for NTP. ok deraadt@@ and tholo@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.16 2002/03/14 00:42:25 miod Exp $
d271 2
a272 4
126	NOARGS		{ int compat_43_sys_setreuid(int ruid, int euid); } \
			    osetreuid
127	NOARGS		{ int compat_43_sys_setregid(int rgid, int egid); } \
			    osetregid
@


1.16
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.15 2001/09/21 15:31:59 art Exp $
a374 4
#ifdef NTP
175	NOARGS		{ int sys_ntp_gettime(struct ntptimeval *ntvp); }
176	NOARGS		{ int sys_ntp_adjtime(struct timex *tp); }
#else
a376 1
#endif
@


1.15
log
@no need for own implemenation of p{read,write}{,v}
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.14 2001/09/05 23:41:45 art Exp $
d95 1
d98 3
@


1.15.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.15 2001/09/21 15:31:59 art Exp $
a94 1
#ifdef PTRACE
a96 3
#else
26	UNIMPL		ptrace
#endif
@


1.15.4.2
log
@sync to -current
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.15.4.1 2002/06/11 03:28:08 art Exp $
d375 4
d381 1
@


1.15.4.3
log
@sync
@
text
@d1 1
a1 1
;	$OpenBSD$
d168 1
a168 1
65	NOARGS		{ int compat_25_sys_omsync(caddr_t addr, size_t len); }
d196 1
a196 1
85	NOARGS		{ int compat_25_sys_swapon(const char *name); }
d271 4
a274 2
126	NOARGS		{ int sys_setreuid(uid_t ruid, uid_t euid); }
127	NOARGS		{ int sys_setregid(gid_t rgid, gid_t egid); }
@


1.14
log
@Add some necessary MSG_COMPAT.
Fix some mode_t vs. netbsd_mode_t (more needed)
add issetugid
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.13 2001/05/16 21:24:01 millert Exp $
d367 1
a367 1
173	STD		{ ssize_t netbsd_sys_pread(int fd, void *buf, \
d369 1
a369 1
174	STD		{ ssize_t netbsd_sys_pwrite(int fd, const void *buf, \
d592 1
a592 1
289	STD		{ ssize_t netbsd_sys_preadv(int fd, \
d595 1
a595 1
290	STD		{ ssize_t netbsd_sys_pwritev(int fd, \
@


1.13
log
@Missed conversion of sys___osemctl, sys_omsgctl, sys_oshmctl, to compat_23
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.12 2001/05/16 17:14:38 millert Exp $
d233 1
d236 4
a241 2
#ifdef TRACE
115	NOARGS		{ int sys_vtrace(int request, int value); }
d243 2
a245 1
#endif
d260 1
d264 3
d558 1
a558 1
			    mode_t mode); }
d613 8
@


1.12
log
@Create COMPAT_25 and move ogetfsstat, ostatfs and ostatfs into it.
Create COMPAT_23 and move __osemctl, omsgctl, oshmctl there.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.11 2000/05/01 23:10:58 deraadt Exp $
d455 2
a456 2
220	NOARGS		{ int sys___osemctl(int semid, int semnum, int cmd, \
			    union semun *arg); }
d468 2
a469 2
224	NOARGS		{ int sys_omsgctl(int msqid, int cmd, \
			    struct omsqid_ds *buf); }
d484 2
a485 2
229	NOARGS		{ int sys_oshmctl(int shmid, int cmd, \
			    struct oshmid_ds *buf); }
@


1.11
log
@sys_semconfig goes away
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.10 1999/09/21 22:45:07 kstailey Exp $
d84 2
a85 2
18	NOARGS		{ int sys_ogetfsstat(struct statfs *buf, long bufsize, \
			    int flags); }
d316 4
a319 2
157	NOARGS		{ int sys_ostatfs(char *path, struct ostatfs *buf); }
158	NOARGS		{ int sys_ofstatfs(int fd, struct ostatfs *buf); }
@


1.10
log
@some COMPATs not seen on alpha
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.9 1999/09/17 22:14:09 kstailey Exp $
d458 1
a458 1
223	NOARGS		{ int sys_semconfig(int flag); }
@


1.10.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.11 2000/05/01 23:10:58 deraadt Exp $
d458 1
a458 1
223	OBSOL		sys_semconfig
@


1.10.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.10.4.1 2001/05/14 22:04:59 niklas Exp $
d84 2
a85 2
18	NOARGS		{ int compat_25_sys_getfsstat(struct ostatfs *buf, \
			    long bufsize, int flags); }
d316 2
a317 4
157	NOARGS		{ int compat_25_sys_statfs(char *path, \
			    struct ostatfs *buf); }
158	NOARGS		{ int compat_25_sys_fstatfs(int fd, \
			    struct ostatfs *buf); }
d453 2
a454 2
220	NOARGS		{ int compat_23_sys___semctl(int semid, int semnum, \
			    int cmd, union semun *arg); } __osemctl
d466 2
a467 2
224	NOARGS		{ int compat_23_sys_msgctl(int msqid, int cmd, \
			    struct omsqid_ds *buf); } omsgctl
d482 2
a483 2
229	NOARGS		{ int compat_23_sys_shmctl(int shmid, int cmd, \
			    struct oshmid_ds *buf); } oshmctl
@


1.10.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.10.4.2 2001/07/04 10:39:36 niklas Exp $
a232 1
#ifdef MSG_COMPAT
a234 4
#else
113	OBSOL		orecvmsg
#endif
#ifdef MSG_COMPAT
d237 2
d240 1
a240 1
114	OBSOL		orecvmsg
a241 1
115	OBSOL		vtrace
a255 1
#ifdef MSG_COMPAT
a258 3
#else
125	OBSOL		orecvfrom
#endif
d359 1
a359 1
173	NOARGS		{ ssize_t sys_pread(int fd, void *buf, \
d361 1
a361 1
174	NOARGS		{ ssize_t sys_pwrite(int fd, const void *buf, \
d550 1
a550 1
			    netbsd_mode_t mode); }
d584 1
a584 1
289	NOARGS		{ ssize_t sys_preadv(int fd, \
d587 1
a587 1
290	NOARGS		{ ssize_t sys_pwritev(int fd, \
a604 8
298	UNIMPL
299	UNIMPL
300	UNIMPL
301	UNIMPL
302	UNIMPL
303	UNIMPL
304	UNIMPL
305	STD		{ int sys_issetugid(void); }
@


1.10.4.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
;	$OpenBSD$
a94 1
#ifdef PTRACE
a96 3
#else
26	UNIMPL		ptrace
#endif
@


1.10.4.5
log
@Sync the SMP branch with 3.3
@
text
@d271 4
a274 2
126	NOARGS		{ int sys_setreuid(uid_t ruid, uid_t euid); }
127	NOARGS		{ int sys_setregid(gid_t rgid, gid_t egid); }
d375 4
d381 1
@


1.10.4.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.10.4.5 2003/03/27 23:53:47 niklas Exp $
d168 1
a168 1
65	NOARGS		{ int compat_25_sys_omsync(caddr_t addr, size_t len); }
d196 1
a196 1
85	NOARGS		{ int compat_25_sys_swapon(const char *name); }
@


1.10.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
;	$OpenBSD$
d151 2
a152 2
53	NOARGS		{ int sys_osigaltstack(const struct osigaltstack *nss, \
			    struct osigaltstack *oss); }
d567 3
a569 3
281	NOARGS		{ int sys_sigaltstack( \
			    const struct sigaltstack *nss, \
			    struct sigaltstack *oss); }
@


1.10.4.8
log
@Merge with the trunk
@
text
@a148 1
#ifdef ACCOUNTING
a149 3
#else
51	UNIMPL		acct
#endif
@


1.9
log
@alternate path
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.8 1999/09/17 15:03:18 kstailey Exp $
d337 2
a338 2
169	NOARGS		{ int sys_semsys(int which, int a2, int a3, int a4, \
			    int a5); } osemsys
d344 2
a345 2
170	NOARGS		{ int sys_msgsys(int which, int a2, int a3, int a4, \
			    int a5, int a6); } omsgsys
@


1.8
log
@lcrap()
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.7 1999/09/17 13:41:29 kstailey Exp $
d63 1
a63 1
5	NOARGS		{ int sys_open(const char *path, \
d69 1
a69 1
8	NOARGS		{ int compat_43_sys_creat(char *path, \
d71 2
a72 2
9	NOARGS		{ int sys_link(const char *path, const char *link); }
10	NOARGS		{ int sys_unlink(const char *path); }
d74 1
a74 1
12	NOARGS		{ int sys_chdir(const char *path); }
d77 1
a77 1
14	NOARGS		{ int sys_mknod(const char *path, int mode, \
d80 2
a81 2
15	NOARGS		{ int sys_chmod(const char *path, int mode); }
16	NOARGS		{ int sys_chown(const char *path, uid_t uid, \
d91 1
a91 1
22	NOARGS		{ int sys_unmount(const char *path, int flags); }
d113 1
a113 1
33	NOARGS		{ int sys_access(const char *path, int flags); }
d115 1
a115 1
34	NOARGS		{ int sys_chflags(const char *path, u_int flags); }
d121 2
a122 2
38	NOARGS		{ int sys_stat(const char *path, struct ostat *ub); } \
			    ostat
d125 1
a125 1
40	NOARGS		{ int sys_lstat(char *path, \
d152 3
a154 4
56	NOARGS		{ int sys_revoke(const char *path); }
57	NOARGS		{ int sys_symlink(const char *path, \
			    const char *link); }
58	NOARGS		{ int sys_readlink(const char *path, char *buf, \
d156 2
a157 2
59	NOARGS		{ int sys_execve(const char *path, \
			    char * const *argp, char * const *envp); }
d159 1
a159 1
61	NOARGS		{ int sys_chroot(const char *path); }
d263 2
a264 2
128	NOARGS		{ int sys_rename(const char *from, const char *to); }
129	NOARGS		{ int compat_43_sys_truncate(char *path, \
d269 1
a269 1
132	NOARGS		{ int sys_mkfifo(const char *path, int mode); }
d276 2
a277 2
136	NOARGS		{ int sys_mkdir(const char *path, int mode); }
137	NOARGS		{ int sys_rmdir(const char *path); }
d390 1
a390 1
188	NOARGS		{ int sys_stat(const char *path, struct stat *ub); }
d392 2
a393 2
190	NOARGS		{ int sys_lstat(const char *path, struct stat *ub); }
191	NOARGS		{ long sys_pathconf(const char *path, int name); }
d407 1
a407 1
200	NOARGS		{ int sys_truncate(const char *path, int pad, \
d554 1
a554 1
278	STD		{ int netbsd_sys___stat13(const char *path, \
d558 1
a558 1
280	STD		{ int netbsd_sys___lstat13(const char *path, \
@


1.7
log
@rest of pread() etc., fdatasync() hack
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.6 1999/09/17 12:13:47 kstailey Exp $
d548 2
a549 3
274	UNIMPL
;274	STD		{ int netbsd_sys_lchmod(const char *path, \
;			    mode_t mode); }
d552 2
a553 3
276	UNIMPL
;276	STD		{ int netbsd_sys_lutimes(const char *path, \
;			    const struct timeval *tptr); }
@


1.6
log
@start of pread(2) etc., stat(2) fixes, "ls -l" now runs
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.5 1999/09/15 20:41:16 kstailey Exp $
d509 1
a509 2
241	UNIMPL
;241	STD		{ int sys_fdatasync(int fd); }
@


1.5
log
@getdents(2)
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.4 1999/09/15 18:36:38 kstailey Exp $
d358 4
a361 6
173	UNIMPL
;173	STD		{ ssize_t sys_pread(int fd, void *buf, \
;			    size_t nbyte, int pad, off_t offset); }
174	UNIMPL
;174	STD		{ ssize_t sys_pwrite(int fd, const void *buf, \
;			    size_t nbyte, int pad, off_t offset); }
d586 6
a591 8
289	UNIMPL
;289	STD		{ ssize_t netbsd_sys_preadv(int fd, \
;			    const struct iovec *iovp, int iovcnt, \
;			    int pad, off_t offset); }
290	UNIMPL
;290	STD		{ ssize_t netbsd_sys_pwritev(int fd, \
;			    const struct iovec *iovp, int iovcnt, \
;			    int pad, off_t offset); }
@


1.4
log
@more and better signal routines, vfork()
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.3 1999/09/14 01:05:25 kstailey Exp $
d359 2
d362 2
d547 2
a548 3
272	UNIMPL
;272	STD		{ int netbsd_sys_getdents(int fd, char *buf, \
;			    size_t count); }
@


1.3
log
@signals
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.2 1999/09/12 14:34:18 kstailey Exp $
d566 1
a566 2
282	UNIMPL
;282	STD		{ int netbsd_sys___vfork14(void); }
d598 5
a602 6
293	UNIMPL
;293	STD		{ int netbsd_sys___sigprocmask14(int how, \
;			    const sigset_t *set, \
;			    sigset_t *oset); }
294	UNIMPL
;294	STD		{ int netbsd_sys___sigsuspend14(const sigset_t *set); }
@


1.2
log
@take out unimplemented calls
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.1 1999/09/12 14:15:17 kstailey Exp $
d45 1
d538 1
a538 1
;270	STD		{ int sys___posix_rename(const char *from, \
d541 2
a542 1
;271	STD		{ int sys_swapctl(int cmd, const void *arg, int misc); }
d544 2
a545 1
;272	STD		{ int sys_getdents(int fd, char *buf, size_t count); }
d549 2
a550 1
;274	STD		{ int sys_lchmod(const char *path, mode_t mode); }
d554 1
a554 1
;276	STD		{ int sys_lutimes(const char *path, \
d563 3
a565 4
281	UNIMPL
;281	STD		{ int sys___sigaltstack14( \
;			    const struct sigaltstack *nss, \
;			    struct sigaltstack *oss); }
d567 1
a567 1
;282	STD		{ int sys___vfork14(void); }
d569 2
a570 2
;283	STD		{ int sys___posix_chown(const char *path, uid_t uid, \
;			    gid_t gid); }
d572 1
a572 1
;284	STD		{ int sys___posix_fchown(int fd, uid_t uid, \
d575 2
a576 2
;285	STD		{ int sys___posix_lchown(const char *path, uid_t uid, \
;			    gid_t gid); }
d581 1
a581 1
;288	STD		{ int sys_fktrace(const int fd, int ops, \
d587 1
a587 1
;289	STD		{ ssize_t sys_preadv(int fd, \
d591 1
a591 1
;290	STD		{ ssize_t sys_pwritev(int fd, \
d594 5
a598 6
291	UNIMPL
;291	STD		{ int netbsd_sys___sigaction14(int signum, \
;			    const struct sigaction *nsa, \
;			    struct sigaction *osa); }
292	UNIMPL
;292	STD		{ int sys___sigpending14(sigset_t *set); }
d600 1
a600 1
;293	STD		{ int sys___sigprocmask14(int how, \
d604 3
a606 3
;294	STD		{ int sys___sigsuspend14(const sigset_t *set); }
295	UNIMPL
;295	STD		{ int sys___sigreturn14(struct sigcontext *sigcntxp); }
d609 1
a609 1
;297	STD		{ int sys_fchroot(int fd); }
@


1.1
log
@Add COMPAT_NETBSD.  Currently only works for ELF64.  Many missing system calls.
@
text
@d1 1
a1 1
;	$OpenBSD$
d5 1
a5 1
; OpenBSD COMPAT_FREEBSD system call name/number "master" file.
d467 2
a468 2
226	NOARGS		{ int sys_msgsnd(int msqid, const void *msgp, size_t msgsz, \
			    int msgflg); }
a522 4
#ifdef SYSVSEM
257	NOARGS		{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); }
#else
a523 5
#endif
#ifdef SYSVSHM
258	NOARGS		{ int sys_shmctl(int shmid, int cmd, \
			    struct shmid_ds *buf); }
#else
a524 5
#endif
#ifdef SYSVMSG
259	NOARGS		{ int sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds *buf); }
#else
a525 1
#endif
@

