head	1.33;
access;
symbols
	OPENBSD_6_2:1.33.0.8
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.33.0.6
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.31.0.2
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.26.0.10
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.6
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.4
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.6
	OPENBSD_5_0:1.23.0.4
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.8
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.10
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.8
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.6
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.15.0.4
	UBC_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.6.0.18
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.16
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.14
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.12
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.10
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.8
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.6
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.32;
commitid	kCz5QgxnxRMKOzNf;

1.32
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.31;
commitid	p4LJxGKbi0BU2cG6;

1.31
date	2014.12.10.02.44.47;	author tedu;	state Exp;
branches;
next	1.30;
commitid	tsoJBlEBSyYO22RG;

1.30
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	3SGDR5EjcwE01W8S;

1.29
date	2014.07.13.15.52.38;	author tedu;	state Exp;
branches;
next	1.28;
commitid	iyde0xIVfkKugN9I;

1.28
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.27;
commitid	QlVV51SZgNFxsXxC;

1.27
date	2014.07.09.15.46.22;	author tedu;	state Exp;
branches;
next	1.26;
commitid	uvHu90KgKRPsOij7;

1.26
date	2012.05.24.19.46.27;	author nicm;	state Exp;
branches;
next	1.25;

1.25
date	2012.05.24.19.30.45;	author nicm;	state Exp;
branches;
next	1.24;

1.24
date	2012.05.24.19.22.46;	author nicm;	state Exp;
branches;
next	1.23;

1.23
date	2010.11.11.17.35.23;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.13.21.10.34;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.07.19.08.16.06;	author blambert;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.31.22.40.34;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.21.12.43.49;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.04.00.16;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.27.05;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.28.13.03.56;	author art;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2001.09.28.09.14.07;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.05.10.12.25;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.22.14.14.09;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.16.12.52.58;	author ho;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.25.03.50.53;	author todd;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.27.16.13.46;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.04.16.39.47;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.04.16.33.05;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.10.07.19.55.27;	author deraadt;	state Exp;
branches
	1.6.16.1;
next	1.5;

1.5
date	96.10.07.19.45.57;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.06.09.52.07;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.05.22.56.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.20.12;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches;
next	;

1.6.16.1
date	2001.05.14.22.32.44;	author niklas;	state Exp;
branches;
next	1.6.16.2;

1.6.16.2
date	2001.07.04.10.48.42;	author niklas;	state Exp;
branches;
next	1.6.16.3;

1.6.16.3
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.6.16.4;

1.6.16.4
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.6.16.5;

1.6.16.5
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	;

1.15.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@/*	$OpenBSD: tty_subr.c,v 1.32 2015/03/14 03:38:51 jsg Exp $	*/
/*	$NetBSD: tty_subr.c,v 1.13 1996/02/09 19:00:43 christos Exp $	*/

/*
 * Copyright (c) 1993, 1994 Theo de Raadt
 * All rights reserved.
 *
 * Per Lindqvist <pgd@@compuram.bbt.se> supplied an almost fully working
 * set of true clist functions that this is very loosely based on.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/malloc.h>

/*
 * If TTY_QUOTE functionality isn't required by a line discipline,
 * it can free c_cq and set it to NULL. This speeds things up,
 * and also does not use any extra memory. This is useful for (say)
 * a SLIP line discipline that wants a 32K ring buffer for data
 * but doesn't need quoting.
 */
#define QMEM(n)		((((n)-1)/NBBY)+1)

void	clrbits(u_char *, int, int);

/*
 * Initialize a particular clist. Ok, they are really ring buffers,
 * of the specified length, with/without quoting support.
 */
void
clalloc(struct clist *clp, int size, int quot)
{

	clp->c_cs = malloc(size, M_TTYS, M_WAITOK|M_ZERO);

	if (quot)
		clp->c_cq = malloc(QMEM(size), M_TTYS, M_WAITOK|M_ZERO);
	else
		clp->c_cq = NULL;

	clp->c_cf = clp->c_cl = NULL;
	clp->c_ce = clp->c_cs + size;
	clp->c_cn = size;
	clp->c_cc = 0;
}

void
clfree(struct clist *clp)
{
	if (clp->c_cs) {
		explicit_bzero(clp->c_cs, clp->c_cn);
		free(clp->c_cs, M_TTYS, clp->c_cn);
	}
	if (clp->c_cq) {
		explicit_bzero(clp->c_cq, QMEM(clp->c_cn));
		free(clp->c_cq, M_TTYS, QMEM(clp->c_cn));
	}
	clp->c_cs = clp->c_cq = NULL;
}


/*
 * Get a character from a clist.
 */
int
getc(struct clist *clp)
{
	int c = -1;
	int s;

	s = spltty();
	if (clp->c_cc == 0)
		goto out;

	c = *clp->c_cf & 0xff;
	*clp->c_cf = 0;
	if (clp->c_cq) {
		if (isset(clp->c_cq, clp->c_cf - clp->c_cs))
			c |= TTY_QUOTE;
		clrbit(clp->c_cq, clp->c_cf - clp->c_cs);
	}
	if (++clp->c_cf == clp->c_ce)
		clp->c_cf = clp->c_cs;
	if (--clp->c_cc == 0)
		clp->c_cf = clp->c_cl = NULL;
out:
	splx(s);
	return c;
}

/*
 * Copy clist to buffer.
 * Return number of bytes moved.
 */
int
q_to_b(struct clist *clp, u_char *cp, int count)
{
	int cc;
	u_char *p = cp;
	int s;

	s = spltty();
	/* optimize this while loop */
	while (count > 0 && clp->c_cc > 0) {
		cc = clp->c_cl - clp->c_cf;
		if (clp->c_cf >= clp->c_cl)
			cc = clp->c_ce - clp->c_cf;
		if (cc > count)
			cc = count;
		memcpy(p, clp->c_cf, cc);
		memset(clp->c_cf, 0, cc);
		if (clp->c_cq)
			clrbits(clp->c_cq, clp->c_cf - clp->c_cs, cc);
		count -= cc;
		p += cc;
		clp->c_cc -= cc;
		clp->c_cf += cc;
		if (clp->c_cf == clp->c_ce)
			clp->c_cf = clp->c_cs;
	}
	if (clp->c_cc == 0)
		clp->c_cf = clp->c_cl = NULL;
	splx(s);
	return p - cp;
}

/*
 * Return count of contiguous characters in clist.
 * Stop counting if flag&character is non-null.
 */
int
ndqb(struct clist *clp, int flag)
{
	int count = 0;
	int i;
	int cc;
	int s;

	s = spltty();
	if ((cc = clp->c_cc) == 0)
		goto out;

	if (flag == 0) {
		count = clp->c_cl - clp->c_cf;
		if (count <= 0)
			count = clp->c_ce - clp->c_cf;
		goto out;
	}

	i = clp->c_cf - clp->c_cs;
	if (flag & TTY_QUOTE) {
		while (cc-- > 0 && !(clp->c_cs[i++] & (flag & ~TTY_QUOTE) ||
		    isset(clp->c_cq, i))) {
			count++;
			if (i == clp->c_cn)
				break;
		}
	} else {
		while (cc-- > 0 && !(clp->c_cs[i++] & flag)) {
			count++;
			if (i == clp->c_cn)
				break;
		}
	}
out:
	splx(s);
	return count;
}

/*
 * Flush count bytes from clist.
 */
void
ndflush(struct clist *clp, int count)
{
	int cc;
	int s;

	s = spltty();
	if (count == clp->c_cc) {
		clp->c_cc = 0;
		clp->c_cf = clp->c_cl = NULL;
		goto out;
	}
	/* optimize this while loop */
	while (count > 0 && clp->c_cc > 0) {
		cc = clp->c_cl - clp->c_cf;
		if (clp->c_cf >= clp->c_cl)
			cc = clp->c_ce - clp->c_cf;
		if (cc > count)
			cc = count;
		count -= cc;
		clp->c_cc -= cc;
		clp->c_cf += cc;
		if (clp->c_cf == clp->c_ce)
			clp->c_cf = clp->c_cs;
	}
	if (clp->c_cc == 0)
		clp->c_cf = clp->c_cl = NULL;
out:
	splx(s);
}

/*
 * Put a character into the output queue.
 */
int
putc(int c, struct clist *clp)
{
	int i;
	int s;

	s = spltty();
	if (clp->c_cc == clp->c_cn) {
		splx(s);
		return -1;
	}

	if (clp->c_cc == 0) {
		if (!clp->c_cs) {
#if defined(DIAGNOSTIC)
			printf("putc: required clalloc\n");
#endif
			clalloc(clp, 1024, 1);
		}
		clp->c_cf = clp->c_cl = clp->c_cs;
	}

	*clp->c_cl = c & 0xff;
	i = clp->c_cl - clp->c_cs;
	if (clp->c_cq) {
		if (c & TTY_QUOTE)
			setbit(clp->c_cq, i);
		else
			clrbit(clp->c_cq, i);
	}
	clp->c_cc++;
	clp->c_cl++;
	if (clp->c_cl == clp->c_ce)
		clp->c_cl = clp->c_cs;
	splx(s);
	return 0;
}

/*
 * optimized version of
 *
 * for (i = 0; i < len; i++)
 *	clrbit(cp, off + i);
 */
void
clrbits(u_char *cp, int off, int len)
{
	int sby, sbi, eby, ebi;
	int i;
	u_char mask;

	if (len==1) {
		clrbit(cp, off);
		return;
	}

	sby = off / NBBY;
	sbi = off % NBBY;
	eby = (off+len) / NBBY;
	ebi = (off+len) % NBBY;
	if (sby == eby) {
		mask = ((1 << (ebi - sbi)) - 1) << sbi;
		cp[sby] &= ~mask;
	} else {
		mask = (1<<sbi) - 1;
		cp[sby++] &= mask;

		for (i = sby; i < eby; i++)
			cp[i] = 0x00;

		mask = (1<<ebi) - 1;
		if (mask)	/* if no mask, eby may be 1 too far */
			cp[eby] &= ~mask;

	}
}

/*
 * Copy buffer to clist.
 * Return number of bytes not transferred.
 */
int
b_to_q(u_char *cp, int count, struct clist *clp)
{
	int cc;
	u_char *p = cp;
	int s;

	if (count <= 0)
		return 0;

	s = spltty();
	if (clp->c_cc == clp->c_cn)
		goto out;

	if (clp->c_cc == 0) {
		if (!clp->c_cs) {
#if defined(DIAGNOSTIC)
			printf("b_to_q: required clalloc\n");
#endif
			clalloc(clp, 1024, 1);
		}
		clp->c_cf = clp->c_cl = clp->c_cs;
	}

	/* optimize this while loop */
	while (count > 0 && clp->c_cc < clp->c_cn) {
		cc = clp->c_ce - clp->c_cl;
		if (clp->c_cf > clp->c_cl)
			cc = clp->c_cf - clp->c_cl;
		if (cc > count)
			cc = count;
		memcpy(clp->c_cl, p, cc);
		if (clp->c_cq)
			clrbits(clp->c_cq, clp->c_cl - clp->c_cs, cc);
		p += cc;
		count -= cc;
		clp->c_cc += cc;
		clp->c_cl += cc;
		if (clp->c_cl == clp->c_ce)
			clp->c_cl = clp->c_cs;
	}
out:
	splx(s);
	return count;
}

static int cc;

/*
 * Given a non-NULL pointer into the clist return the pointer
 * to the next character in the list or return NULL if no more chars.
 *
 * Callers must not allow getc's to happen between firstc's and nextc's
 * so that the pointer becomes invalid.  Note that interrupts are NOT
 * masked.
 */
u_char *
nextc(struct clist *clp, u_char *cp, int *c)
{

	if (clp->c_cf == cp) {
		/*
		 * First time initialization.
		 */
		cc = clp->c_cc;
	}
	if (cc == 0 || cp == NULL)
		return NULL;
	if (--cc == 0)
		return NULL;
	if (++cp == clp->c_ce)
		cp = clp->c_cs;
	*c = *cp & 0xff;
	if (clp->c_cq) {
		if (isset(clp->c_cq, cp - clp->c_cs))
			*c |= TTY_QUOTE;
	}
	return cp;
}

/*
 * Given a non-NULL pointer into the clist return the pointer
 * to the first character in the list or return NULL if no more chars.
 *
 * Callers must not allow getc's to happen between firstc's and nextc's
 * so that the pointer becomes invalid.  Note that interrupts are NOT
 * masked.
 *
 * *c is set to the NEXT character
 */
u_char *
firstc(struct clist *clp, int *c)
{
	u_char *cp;

	cc = clp->c_cc;
	if (cc == 0)
		return NULL;
	cp = clp->c_cf;
	*c = *cp & 0xff;
	if (clp->c_cq) {
		if (isset(clp->c_cq, cp - clp->c_cs))
			*c |= TTY_QUOTE;
	}
	return clp->c_cf;
}

/*
 * Remove the last character in the clist and return it.
 */
int
unputc(struct clist *clp)
{
	unsigned int c = -1;
	int s;

	s = spltty();
	if (clp->c_cc == 0)
		goto out;

	if (clp->c_cl == clp->c_cs)
		clp->c_cl = clp->c_ce - 1;
	else
		--clp->c_cl;
	clp->c_cc--;

	c = *clp->c_cl & 0xff;
	*clp->c_cl = 0;
	if (clp->c_cq) {
		if (isset(clp->c_cq, clp->c_cl - clp->c_cs))
			c |= TTY_QUOTE;
		clrbit(clp->c_cq, clp->c_cl - clp->c_cs);
	}
	if (clp->c_cc == 0)
		clp->c_cf = clp->c_cl = NULL;
out:
	splx(s);
	return c;
}

/*
 * Put the chars in the from queue on the end of the to queue.
 */
void
catq(struct clist *from, struct clist *to)
{
	int c;
	int s;

	s = spltty();
	if (from->c_cc == 0) {	/* nothing to move */
		splx(s);
		return;
	}

	/*
	 * if `to' queue is empty and the queues are the same max size,
	 * it is more efficient to just swap the clist structures.
	 */
	if (to->c_cc == 0 && from->c_cn == to->c_cn) {
		struct clist tmp;

		tmp = *from;
		*from = *to;
		*to = tmp;
		splx(s);
		return;
	}
	splx(s);

	while ((c = getc(from)) != -1)
		putc(c, to);
}
@


1.32
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.31 2014/12/10 02:44:47 tedu Exp $	*/
d108 1
a108 1
		clp->c_cf = clp->c_cl = (u_char *)0;
d145 1
a145 1
		clp->c_cf = clp->c_cl = (u_char *)0;
d205 1
a205 1
		clp->c_cf = clp->c_cl = (u_char *)0;
d222 1
a222 1
		clp->c_cf = clp->c_cl = (u_char *)0;
d445 1
a445 1
		clp->c_cf = clp->c_cl = (u_char *)0;
@


1.31
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.30 2014/11/03 03:08:00 deraadt Exp $	*/
a33 1
#include <sys/buf.h>
@


1.30
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.29 2014/07/13 15:52:38 tedu Exp $	*/
d134 1
a134 1
		bcopy(clp->c_cf, p, cc);
d343 1
a343 1
		bcopy(p, clp->c_cl, cc);
@


1.29
log
@bzero -> memset. for the speeds.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.28 2014/07/12 18:43:32 tedu Exp $	*/
d76 1
a76 1
		free(clp->c_cs, M_TTYS, 0);
d80 1
a80 1
		free(clp->c_cq, M_TTYS, 0);
@


1.28
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.27 2014/07/09 15:46:22 tedu Exp $	*/
d135 1
a135 1
		bzero(clp->c_cf, cc);
@


1.27
log
@use explicit_bzero for stack and freed variables
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.26 2012/05/24 19:46:27 nicm Exp $	*/
d76 1
a76 1
		free(clp->c_cs, M_TTYS);
d80 1
a80 1
		free(clp->c_cq, M_TTYS);
@


1.26
log
@A couple of trivial spacing and comment fixes.

ok miod blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.25 2012/05/24 19:30:45 nicm Exp $	*/
d75 1
a75 1
		bzero(clp->c_cs, clp->c_cn);
d79 1
a79 1
		bzero(clp->c_cq, QMEM(clp->c_cn));
@


1.25
log
@unputc should clear the character removed in the buffers like getc.

ok matthew miod deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.24 2012/05/24 19:22:46 nicm Exp $	*/
d102 1
a102 1
		if (isset(clp->c_cq, clp->c_cf - clp->c_cs) )
d273 1
a273 1
 *	clrbit(cp, off + len);
d364 1
a364 1
 * Callers must not allow getc's to happen between firstc's and getc's
d396 1
a396 1
 * Callers must not allow getc's to happen between firstc's and getc's
@


1.24
log
@When clearing quote bits in getc and q_to_b, clear from the c_cf (the
first, that is being removed) rather than c_cl (the last).

ok matthew miod deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.23 2010/11/11 17:35:23 miod Exp $	*/
d439 1
d443 1
@


1.23
log
@Kill unused cinit(), and skip some diagnostic printf if option
DIAGNOSTIC is not set. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.22 2009/11/13 21:10:34 deraadt Exp $	*/
d104 1
a104 1
		clrbit(clp->c_cq, clp->c_cl - clp->c_cs);
d137 1
a137 1
			clrbits(clp->c_cq, clp->c_cl - clp->c_cs, cc);
@


1.22
log
@>15 year old buffer-read-1-byte-too-far in clrbits() [code I wrote, yeah]
with a subtle change to make it more clear (and more cache friendly)
netbsd pr 42312, found by tlambert@@apple.com
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.21 2009/07/19 08:16:06 blambert Exp $	*/
a47 1
void	cinit(void);
a50 8
 * Initialize clists.
 */
void
cinit(void)
{
}

/*
d245 1
a245 1
#if defined(DIAGNOSTIC) || 1
d328 1
a328 1
#if defined(DIAGNOSTIC) || 1
@


1.21
log
@clalloc() can't fail, so there's no need to handle failure cases.
Change to void function.
Also, no need to have global tty stats pointer, so just return it
from clalloc, as the caller frees it immediately anyway.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.20 2008/03/31 22:40:34 deraadt Exp $	*/
d307 3
d311 2
a312 1
		cp[eby] &= ~mask;
a313 2
		for (i = sby; i < eby; i++)
			cp[i] = 0x00;
@


1.20
log
@purge memory in the tty clist rings as we advance; tested by a few
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.19 2007/09/07 15:00:20 art Exp $	*/
d63 1
a63 1
int
d72 1
a72 1
		clp->c_cq = (u_char *)0;
d74 1
a74 1
	clp->c_cf = clp->c_cl = (u_char *)0;
a77 1
	return (0);
d91 1
a91 1
	clp->c_cs = clp->c_cq = (u_char *)0;
d247 4
a250 2
	if (clp->c_cc == clp->c_cn)
		goto out;
d257 1
a257 5
			if (clalloc(clp, 1024, 1)) {
out:
				splx(s);
				return -1;
			}
d338 1
a338 2
			if (clalloc(clp, 1024, 1))
				goto out;
@


1.19
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.18 2005/12/21 12:43:49 jsg Exp $	*/
d110 1
d114 1
d145 3
d355 1
a355 1
		if (clp->c_cq) {
a356 1
		}
@


1.18
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.17 2003/06/02 04:00:16 deraadt Exp $	*/
d67 1
a67 2
	clp->c_cs = malloc(size, M_TTYS, M_WAITOK);
	bzero(clp->c_cs, size);
d69 3
a71 4
	if (quot) {
		clp->c_cq = malloc(QMEM(size), M_TTYS, M_WAITOK);
		bzero(clp->c_cq, QMEM(size));
	} else
@


1.17
log
@remove terms 3 and 4 of some of my licences
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.16 2002/03/14 01:27:05 millert Exp $	*/
d55 1
a55 1
cinit()
d64 1
a64 4
clalloc(clp, size, quot)
	struct clist *clp;
	int size;
	int quot;
d84 1
a84 2
clfree(clp)
	struct clist *clp;
d102 1
a102 2
getc(clp)
	struct clist *clp;
d104 1
a104 1
	register int c = -1;
d130 1
a130 4
q_to_b(clp, cp, count)
	struct clist *clp;
	u_char *cp;
	int count;
d132 1
a132 1
	register int cc;
d163 1
a163 3
ndqb(clp, flag)
	struct clist *clp;
	int flag;
d166 2
a167 2
	register int i;
	register int cc;
d205 1
a205 3
ndflush(clp, count)
	struct clist *clp;
	int count;
d207 1
a207 1
	register int cc;
d239 1
a239 3
putc(c, clp)
	int c;
	struct clist *clp;
d241 1
a241 1
	register int i;
d285 1
a285 4
clrbits(cp, off, len)
	u_char *cp;
	int off;
	int len;
d288 1
a288 1
	register int i;
d320 1
a320 4
b_to_q(cp, count, clp)
	u_char *cp;
	int count;
	struct clist *clp;
d378 1
a378 4
nextc(clp, cp, c)
	struct clist *clp;
	register u_char *cp;
	int *c;
d412 1
a412 3
firstc(clp, c)
	struct clist *clp;
	int *c;
d414 1
a414 1
	register u_char *cp;
d432 1
a432 2
unputc(clp)
	struct clist *clp;
d463 1
a463 2
catq(from, to)
	struct clist *from, *to;
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.15 2001/09/28 13:03:56 art Exp $	*/
a18 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Theo de Raadt.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.15
log
@QBITS is always defined, no point in having all those cofusing ifdefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.14 2001/09/28 09:14:07 art Exp $	*/
d53 2
a54 2
void	cinit __P((void));
void	clrbits __P((u_char *, int, int));
@


1.15.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.15 2001/09/28 13:03:56 art Exp $	*/
d53 2
a54 2
void	cinit(void);
void	clrbits(u_char *, int, int);
@


1.14
log
@Redundant prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.13 2001/07/05 10:12:25 art Exp $	*/
a44 6
 * At compile time, choose:
 * There are two ways the TTY_QUOTE bit can be stored. If QBITS is
 * defined we allocate an array of bits -- 1/8th as much memory but
 * setbit(), clrbit(), and isset() take more cpu. If QBITS is
 * undefined, we just use an array of bytes.
 *
a50 3
#define QBITS

#ifdef QBITS
a51 3
#else
#define QMEM(n)		(n)
#endif
a53 1
#ifdef QBITS
a54 1
#endif
a122 1
#ifdef QBITS
a124 4
#else
		if (*(clp->c_cf - clp->c_cs + clp->c_cq))
			c |= TTY_QUOTE;
#endif
a283 1
#ifdef QBITS
a287 4
#else
		q = clp->c_cq + i;
		*q = (c & TTY_QUOTE) ? 1 : 0;
#endif
a296 1
#ifdef QBITS
a335 1
#endif
d347 2
a348 2
	register int cc;
	register u_char *p = cp;
a377 1
#ifdef QBITS
a378 3
#else
			bzero(clp->c_cl - clp->c_cs + clp->c_cq, cc);
#endif
a422 1
#ifdef QBITS
a424 4
#else
		if (*(clp->c_cf - clp->c_cs + clp->c_cq))
			*c |= TTY_QUOTE;
#endif
a451 1
#ifdef QBITS
a453 4
#else
		if (*(cp - clp->c_cs + clp->c_cq))
			*c |= TTY_QUOTE;
#endif
a479 1
#ifdef QBITS
a481 4
#else
		if (*(clp->c_cf - clp->c_cs + clp->c_cq))
			c |= TTY_QUOTE;
#endif
@


1.13
log
@Get rid of REAL_CLISTS. It was never implemented and the tentacles are
everywhhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.12 2001/06/22 14:14:09 deraadt Exp $	*/
a65 2
int	ndqb __P((struct clist *, int));
int	putc __P((int, struct clist *));
a68 2
int	b_to_q __P((u_char *, int, struct clist *));
u_char *firstc __P((struct clist *, int *));
@


1.12
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.11 2001/05/16 12:52:58 ho Exp $	*/
a41 3
#ifdef REAL_CLISTS
#include <sys/clist.h>
#endif
@


1.11
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.10 2001/01/25 03:50:53 todd Exp $	*/
d53 1
a53 1
 * 
d312 1
a312 1
			setbit(clp->c_cq, i); 
@


1.10
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.9 2000/09/27 16:13:46 mickey Exp $	*/
a96 2
	if (!clp->c_cs)
		return (-1);
a100 5
		if (!clp->c_cq) {
			free(clp->c_cs, M_TTYS);
			clp->c_cs = NULL;
			return (-1);
		}
@


1.9
log
@replace MALLOC/FREE w/ malloc/free for non-constant-sized memory allocations; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.8 2000/08/04 16:39:47 deraadt Exp $	*/
d379 1
a379 1
 * Return number of bytes not transfered.
@


1.8
log
@clear rings before freeing them
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.7 2000/08/04 16:33:05 deraadt Exp $	*/
d96 1
a96 1
	MALLOC(clp->c_cs, u_char *, size, M_TTYS, M_WAITOK);
d102 1
a102 1
		MALLOC(clp->c_cq, u_char *, QMEM(size), M_TTYS, M_WAITOK);
d104 1
a104 1
			FREE(clp->c_cs, M_TTYS);
d125 1
a125 1
		FREE(clp->c_cs, M_TTYS);
d129 1
a129 1
		FREE(clp->c_cq, M_TTYS);
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.6 1996/10/07 19:55:27 deraadt Exp $	*/
d123 2
a124 1
	if (clp->c_cs)
d126 3
a128 1
	if (clp->c_cq)
d130 1
@


1.6
log
@a teeny bit more care
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.5 1996/10/07 19:45:57 deraadt Exp $	*/
d123 1
a123 1
	if(clp->c_cs)
d125 1
a125 1
	if(clp->c_cq)
d301 1
a301 1
			if(clalloc(clp, 1024, 1)) {
d348 1
a348 1
	if(len==1) {
d399 1
a399 1
			if(clalloc(clp, 1024, 1))
d496 1
a496 1
	if(clp->c_cq) {
@


1.6.16.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.10 2001/01/25 03:50:53 todd Exp $	*/
d96 1
a96 1
	clp->c_cs = malloc(size, M_TTYS, M_WAITOK);
d102 1
a102 1
		clp->c_cq = malloc(QMEM(size), M_TTYS, M_WAITOK);
d104 1
a104 1
			free(clp->c_cs, M_TTYS);
d123 4
a126 8
	if (clp->c_cs) {
		bzero(clp->c_cs, clp->c_cn);
		free(clp->c_cs, M_TTYS);
	}
	if (clp->c_cq) {
		bzero(clp->c_cq, QMEM(clp->c_cn));
		free(clp->c_cq, M_TTYS);
	}
d301 1
a301 1
			if (clalloc(clp, 1024, 1)) {
d348 1
a348 1
	if (len==1) {
d375 1
a375 1
 * Return number of bytes not transferred.
d399 1
a399 1
			if (clalloc(clp, 1024, 1))
d496 1
a496 1
	if (clp->c_cq) {
@


1.6.16.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.6.16.1 2001/05/14 22:32:44 niklas Exp $	*/
d53 1
a53 1
 *
d97 2
d103 5
d319 1
a319 1
			setbit(clp->c_cq, i);
@


1.6.16.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.6.16.2 2001/07/04 10:48:42 niklas Exp $	*/
d42 3
d48 6
d60 3
d64 3
d69 3
d73 3
d144 1
d147 4
d310 1
d315 4
d328 1
d368 1
d380 2
a381 2
	int cc;
	u_char *p = cp;
d411 1
d413 3
d460 1
d463 4
d494 1
d497 4
d527 1
d530 4
@


1.6.16.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 2
a54 2
void	cinit(void);
void	clrbits(u_char *, int, int);
@


1.6.16.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.6.16.4 2002/03/28 11:43:04 niklas Exp $	*/
d19 5
@


1.5
log
@clear quotes not buf; from hbriceno@@lcs.mit.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.4 1996/06/06 09:52:07 deraadt Exp $	*/
d105 1
@


1.4
log
@catq: must spltty before playing
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_subr.c,v 1.3 1996/06/05 22:56:43 deraadt Exp $	*/
d101 1
a101 1
	if(quot) {
d107 1
a107 1
		bzero(clp->c_cs, QMEM(size));
@


1.3
log
@catq() optimizations; if to queue is empty, swapping clist structures is faster
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d552 1
d554 3
a556 1
	if (from->c_cc == 0)	/* nothing to move */
d558 1
d570 2
d573 1
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d553 15
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: tty_subr.c,v 1.11 1994/10/30 21:48:03 cgd Exp $	*/
d68 8
d203 1
a287 1
	register u_char *q;
a288 1
	int r = -1;
d382 1
a382 1
	register int i, cc;
d384 1
a384 1
	int off, s;
a487 1
	int empty = 0;
a488 1
	register int i;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
