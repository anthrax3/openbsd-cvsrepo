head	1.31;
access;
symbols
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.29.0.2
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.28.0.4
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.6
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.25.0.4
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.17.0.2
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.6
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.5.0.6
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.4
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.31
date	2017.03.07.20.22.37;	author dhill;	state Exp;
branches;
next	1.30;
commitid	9473CC0ambFCcoAD;

1.30
date	2017.02.09.20.15.28;	author mikeb;	state Exp;
branches;
next	1.29;
commitid	qIqUe5AjrRqXtLvz;

1.29
date	2016.07.06.15.53.01;	author tedu;	state Exp;
branches;
next	1.28;
commitid	dZWS1TCbA5Wj2uVG;

1.28
date	2014.12.10.02.44.47;	author tedu;	state Exp;
branches
	1.28.4.1
	1.28.6.1;
next	1.27;
commitid	tsoJBlEBSyYO22RG;

1.27
date	2014.11.01.23.58.28;	author tedu;	state Exp;
branches;
next	1.26;
commitid	9PQjDNhyphSHE6E7;

1.26
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.25;
commitid	uzzBR7hz9ncd4O6G;

1.25
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.24;
commitid	QlVV51SZgNFxsXxC;

1.24
date	2014.04.03.17.58.31;	author beck;	state Exp;
branches;
next	1.23;

1.23
date	2014.04.03.15.55.29;	author beck;	state Exp;
branches;
next	1.22;

1.22
date	2014.01.30.21.01.59;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.06.01.27.49;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.02.20.59.09;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2012.11.05.19.39.35;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2012.05.24.07.17.42;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.24.07.29.30;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.24.02.55.43;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.24.16.38.05;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.21.17.56.34;	author robert;	state Exp;
branches;
next	1.10;

1.10
date	2007.12.27.19.05.22;	author otto;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.09.17.42.19;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.31.14.46.48;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.15.17.25.40;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.30.20.19.33;	author otto;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.03.11.10.56;	author hshoexer;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.21.00.20.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.17.10.18.01;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2004.08.04.15.36.44;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.28.17.15.12;	author tholo;	state Exp;
branches;
next	;

1.28.4.1
date	2016.07.14.02.45.23;	author tedu;	state Exp;
branches;
next	;
commitid	iy5C78vcnVfjlmst;

1.28.6.1
date	2016.07.14.02.46.11;	author tedu;	state Exp;
branches;
next	;
commitid	kzYtCgZfgZewqezu;


desc
@@


1.31
log
@Drop unused variable from ntp_update_second().

ok jca@@ deraadt@@
@
text
@/*	$OpenBSD: kern_tc.c,v 1.30 2017/02/09 20:15:28 mikeb Exp $ */

/*
 * Copyright (c) 2000 Poul-Henning Kamp <phk@@FreeBSD.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * If we meet some day, and you think this stuff is worth it, you
 * can buy me a beer in return. Poul-Henning Kamp
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/timeout.h>
#include <sys/sysctl.h>
#include <sys/syslog.h>
#include <sys/systm.h>
#include <sys/timetc.h>
#include <sys/malloc.h>
#include <dev/rndvar.h>

/*
 * A large step happens on boot.  This constant detects such steps.
 * It is relatively small so that ntp_update_second gets called enough
 * in the typical 'missed a couple of seconds' case, but doesn't loop
 * forever when the time step is large.
 */
#define LARGE_STEP	200

u_int dummy_get_timecount(struct timecounter *);

void ntp_update_second(int64_t *);
int sysctl_tc_hardware(void *, size_t *, void *, size_t);
int sysctl_tc_choice(void *, size_t *, void *, size_t);

/*
 * Implement a dummy timecounter which we can use until we get a real one
 * in the air.  This allows the console and other early stuff to use
 * time services.
 */

u_int
dummy_get_timecount(struct timecounter *tc)
{
	static u_int now;

	return (++now);
}

static struct timecounter dummy_timecounter = {
	dummy_get_timecount, 0, ~0u, 1000000, "dummy", -1000000
};

struct timehands {
	/* These fields must be initialized by the driver. */
	struct timecounter	*th_counter;
	int64_t			th_adjustment;
	u_int64_t		th_scale;
	u_int	 		th_offset_count;
	struct bintime		th_offset;
	struct timeval		th_microtime;
	struct timespec		th_nanotime;
	/* Fields not to be copied in tc_windup start with th_generation. */
	volatile u_int		th_generation;
	struct timehands	*th_next;
};

static struct timehands th0;
static struct timehands th9 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th0};
static struct timehands th8 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th9};
static struct timehands th7 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th8};
static struct timehands th6 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th7};
static struct timehands th5 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th6};
static struct timehands th4 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th5};
static struct timehands th3 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th4};
static struct timehands th2 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th3};
static struct timehands th1 = { NULL, 0, 0, 0, {0, 0}, {0, 0}, {0, 0}, 0, &th2};
static struct timehands th0 = {
	&dummy_timecounter,
	0,
	(uint64_t)-1 / 1000000,
	0,
	{1, 0},
	{0, 0},
	{0, 0},
	1,
	&th1
};

static struct timehands *volatile timehands = &th0;
struct timecounter *timecounter = &dummy_timecounter;
static struct timecounter *timecounters = &dummy_timecounter;

volatile time_t time_second = 1;
volatile time_t time_uptime = 0;

struct bintime naptime;
static struct bintime boottimebin;
static int timestepwarnings;

void tc_windup(void);

/*
 * Return the difference between the timehands' counter value now and what
 * was when we copied it to the timehands' offset_count.
 */
static __inline u_int
tc_delta(struct timehands *th)
{
	struct timecounter *tc;

	tc = th->th_counter;
	return ((tc->tc_get_timecount(tc) - th->th_offset_count) &
	    tc->tc_counter_mask);
}

/*
 * Functions for reading the time.  We have to loop until we are sure that
 * the timehands that we operated on was not updated under our feet.  See
 * the comment in <sys/time.h> for a description of these 12 functions.
 */

void
binuptime(struct bintime *bt)
{
	struct timehands *th;
	u_int gen;

	do {
		th = timehands;
		gen = th->th_generation;
		*bt = th->th_offset;
		bintime_addx(bt, th->th_scale * tc_delta(th));
	} while (gen == 0 || gen != th->th_generation);
}

void
nanouptime(struct timespec *tsp)
{
	struct bintime bt;

	binuptime(&bt);
	bintime2timespec(&bt, tsp);
}

void
microuptime(struct timeval *tvp)
{
	struct bintime bt;

	binuptime(&bt);
	bintime2timeval(&bt, tvp);
}

void
bintime(struct bintime *bt)
{

	binuptime(bt);
	bintime_add(bt, &boottimebin);
}

void
nanotime(struct timespec *tsp)
{
	struct bintime bt;

	bintime(&bt);
	bintime2timespec(&bt, tsp);
}

void
microtime(struct timeval *tvp)
{
	struct bintime bt;

	bintime(&bt);
	bintime2timeval(&bt, tvp);
}

void
getnanouptime(struct timespec *tsp)
{
	struct timehands *th;
	u_int gen;

	do {
		th = timehands;
		gen = th->th_generation;
		bintime2timespec(&th->th_offset, tsp);
	} while (gen == 0 || gen != th->th_generation);
}

void
getmicrouptime(struct timeval *tvp)
{
	struct timehands *th;
	u_int gen;

	do {
		th = timehands;
		gen = th->th_generation;
		bintime2timeval(&th->th_offset, tvp);
	} while (gen == 0 || gen != th->th_generation);
}

void
getnanotime(struct timespec *tsp)
{
	struct timehands *th;
	u_int gen;

	do {
		th = timehands;
		gen = th->th_generation;
		*tsp = th->th_nanotime;
	} while (gen == 0 || gen != th->th_generation);
}

void
getmicrotime(struct timeval *tvp)
{
	struct timehands *th;
	u_int gen;

	do {
		th = timehands;
		gen = th->th_generation;
		*tvp = th->th_microtime;
	} while (gen == 0 || gen != th->th_generation);
}

/*
 * Initialize a new timecounter and possibly use it.
 */
void
tc_init(struct timecounter *tc)
{
	u_int u;

	u = tc->tc_frequency / tc->tc_counter_mask;
	/* XXX: We need some margin here, 10% is a guess */
	u *= 11;
	u /= 10;
	if (tc->tc_quality >= 0) {
		if (u > hz) {
			tc->tc_quality = -2000;
			printf("Timecounter \"%s\" frequency %lu Hz",
			    tc->tc_name, (unsigned long)tc->tc_frequency);
			printf(" -- Insufficient hz, needs at least %u\n", u);
		}
	}

	tc->tc_next = timecounters;
	timecounters = tc;
	/*
	 * Never automatically use a timecounter with negative quality.
	 * Even though we run on the dummy counter, switching here may be
	 * worse since this timecounter may not be monotonic.
	 */
	if (tc->tc_quality < 0)
		return;
	if (tc->tc_quality < timecounter->tc_quality)
		return;
	if (tc->tc_quality == timecounter->tc_quality &&
	    tc->tc_frequency < timecounter->tc_frequency)
		return;
	(void)tc->tc_get_timecount(tc);
	add_timer_randomness(tc->tc_get_timecount(tc));

	timecounter = tc;
}

/* Report the frequency of the current timecounter. */
u_int64_t
tc_getfrequency(void)
{

	return (timehands->th_counter->tc_frequency);
}

/*
 * Step our concept of UTC, aka the realtime clock.
 * This is done by modifying our estimate of when we booted.
 * XXX: not locked.
 */
void
tc_setrealtimeclock(struct timespec *ts)
{
	struct timespec ts2;
	struct bintime bt, bt2;

	binuptime(&bt2);
	timespec2bintime(ts, &bt);
	bintime_sub(&bt, &bt2);
	bintime_add(&bt2, &boottimebin);
	boottimebin = bt;
	bintime2timespec(&bt, &boottime);
	add_timer_randomness(ts->tv_sec);

	/* XXX fiddle all the little crinkly bits around the fiords... */
	tc_windup();
	if (timestepwarnings) {
		bintime2timespec(&bt2, &ts2);
		log(LOG_INFO, "Time stepped from %lld.%09ld to %lld.%09ld\n",
		    (long long)ts2.tv_sec, ts2.tv_nsec,
		    (long long)ts->tv_sec, ts->tv_nsec);
	}
}

/*
 * Step the monotonic and realtime clocks, triggering any timeouts that
 * should have occurred across the interval.
 * XXX: not locked.
 */
void
tc_setclock(struct timespec *ts)
{
	struct bintime bt, bt2;
#ifndef SMALL_KERNEL
	long long adj_ticks;
#endif

	/*
	 * When we're called for the first time, during boot when
	 * the root partition is mounted, boottime is still zero:
	 * we just need to set it.
	 */
	if (boottimebin.sec == 0) {
		tc_setrealtimeclock(ts);
		return;
	}

	add_timer_randomness(ts->tv_sec);

	timespec2bintime(ts, &bt);
	bintime_sub(&bt, &boottimebin);
	bt2 = timehands->th_offset;
	timehands->th_offset = bt;

	/* XXX fiddle all the little crinkly bits around the fiords... */
	tc_windup();

#ifndef SMALL_KERNEL
	/* convert the bintime to ticks */
	bintime_sub(&bt, &bt2);
	bintime_add(&naptime, &bt);
	adj_ticks = (uint64_t)hz * bt.sec +
	    (((uint64_t)1000000 * (uint32_t)(bt.frac >> 32)) >> 32) / tick;
	if (adj_ticks > 0) {
		if (adj_ticks > INT_MAX)
			adj_ticks = INT_MAX;
		timeout_adjust_ticks(adj_ticks);
	}
#endif
}

/*
 * Initialize the next struct timehands in the ring and make
 * it the active timehands.  Along the way we might switch to a different
 * timecounter and/or do seconds processing in NTP.  Slightly magic.
 */
void
tc_windup(void)
{
	struct bintime bt;
	struct timehands *th, *tho;
	u_int64_t scale;
	u_int delta, ncount, ogen;
	int i;

	/*
	 * Make the next timehands a copy of the current one, but do not
	 * overwrite the generation or next pointer.  While we update
	 * the contents, the generation must be zero.
	 */
	tho = timehands;
	th = tho->th_next;
	ogen = th->th_generation;
	th->th_generation = 0;
	memcpy(th, tho, offsetof(struct timehands, th_generation));

	/*
	 * Capture a timecounter delta on the current timecounter and if
	 * changing timecounters, a counter value from the new timecounter.
	 * Update the offset fields accordingly.
	 */
	delta = tc_delta(th);
	if (th->th_counter != timecounter)
		ncount = timecounter->tc_get_timecount(timecounter);
	else
		ncount = 0;
	th->th_offset_count += delta;
	th->th_offset_count &= th->th_counter->tc_counter_mask;
	bintime_addx(&th->th_offset, th->th_scale * delta);

#ifdef notyet
	/*
	 * Hardware latching timecounters may not generate interrupts on
	 * PPS events, so instead we poll them.  There is a finite risk that
	 * the hardware might capture a count which is later than the one we
	 * got above, and therefore possibly in the next NTP second which might
	 * have a different rate than the current NTP second.  It doesn't
	 * matter in practice.
	 */
	if (tho->th_counter->tc_poll_pps)
		tho->th_counter->tc_poll_pps(tho->th_counter);
#endif

	/*
	 * Deal with NTP second processing.  The for loop normally
	 * iterates at most once, but in extreme situations it might
	 * keep NTP sane if timeouts are not run for several seconds.
	 * At boot, the time step can be large when the TOD hardware
	 * has been read, so on really large steps, we call
	 * ntp_update_second only twice.  We need to call it twice in
	 * case we missed a leap second.
	 */
	bt = th->th_offset;
	bintime_add(&bt, &boottimebin);
	i = bt.sec - tho->th_microtime.tv_sec;
	if (i > LARGE_STEP)
		i = 2;
	for (; i > 0; i--)
		ntp_update_second(&th->th_adjustment);

	/* Update the UTC timestamps used by the get*() functions. */
	/* XXX shouldn't do this here.  Should force non-`get' versions. */
	bintime2timeval(&bt, &th->th_microtime);
	bintime2timespec(&bt, &th->th_nanotime);

	/* Now is a good time to change timecounters. */
	if (th->th_counter != timecounter) {
		th->th_counter = timecounter;
		th->th_offset_count = ncount;
	}

	/*-
	 * Recalculate the scaling factor.  We want the number of 1/2^64
	 * fractions of a second per period of the hardware counter, taking
	 * into account the th_adjustment factor which the NTP PLL/adjtime(2)
	 * processing provides us with.
	 *
	 * The th_adjustment is nanoseconds per second with 32 bit binary
	 * fraction and we want 64 bit binary fraction of second:
	 *
	 *	 x = a * 2^32 / 10^9 = a * 4.294967296
	 *
	 * The range of th_adjustment is +/- 5000PPM so inside a 64bit int
	 * we can only multiply by about 850 without overflowing, but that
	 * leaves suitably precise fractions for multiply before divide.
	 *
	 * Divide before multiply with a fraction of 2199/512 results in a
	 * systematic undercompensation of 10PPM of th_adjustment.  On a
	 * 5000PPM adjustment this is a 0.05PPM error.  This is acceptable.
 	 *
	 * We happily sacrifice the lowest of the 64 bits of our result
	 * to the goddess of code clarity.
	 *
	 */
	scale = (u_int64_t)1 << 63;
	scale += (th->th_adjustment / 1024) * 2199;
	scale /= th->th_counter->tc_frequency;
	th->th_scale = scale * 2;

	/*
	 * Now that the struct timehands is again consistent, set the new
	 * generation number, making sure to not make it zero.
	 */
	if (++ogen == 0)
		ogen = 1;
	th->th_generation = ogen;

	/* Go live with the new struct timehands. */
	time_second = th->th_microtime.tv_sec;
	time_uptime = th->th_offset.sec;
	timehands = th;
}

/* Report or change the active timecounter hardware. */
int
sysctl_tc_hardware(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
{
	char newname[32];
	struct timecounter *newtc, *tc;
	int error;

	tc = timecounter;
	strlcpy(newname, tc->tc_name, sizeof(newname));

	error = sysctl_string(oldp, oldlenp, newp, newlen, newname, sizeof(newname));
	if (error != 0 || strcmp(newname, tc->tc_name) == 0)
		return (error);
	for (newtc = timecounters; newtc != NULL; newtc = newtc->tc_next) {
		if (strcmp(newname, newtc->tc_name) != 0)
			continue;

		/* Warm up new timecounter. */
		(void)newtc->tc_get_timecount(newtc);
		(void)newtc->tc_get_timecount(newtc);

		timecounter = newtc;
		return (0);
	}
	return (EINVAL);
}

/* Report or change the active timecounter hardware. */
int
sysctl_tc_choice(void *oldp, size_t *oldlenp, void *newp, size_t newlen)
{
	char buf[32], *spc, *choices;
	struct timecounter *tc;
	int error, maxlen;

	spc = "";
	maxlen = 0;
	for (tc = timecounters; tc != NULL; tc = tc->tc_next)
		maxlen += sizeof(buf);
	choices = malloc(maxlen, M_TEMP, M_WAITOK);
	*choices = '\0';
	for (tc = timecounters; tc != NULL; tc = tc->tc_next) {
		snprintf(buf, sizeof(buf), "%s%s(%d)",
		    spc, tc->tc_name, tc->tc_quality);
		spc = " ";
		strlcat(choices, buf, maxlen);
	}
	error = sysctl_rdstring(oldp, oldlenp, newp, choices);
	free(choices, M_TEMP, maxlen);
	return (error);
}

/*
 * Timecounters need to be updated every so often to prevent the hardware
 * counter from overflowing.  Updating also recalculates the cached values
 * used by the get*() family of functions, so their precision depends on
 * the update frequency.
 */
static int tc_tick;

void
tc_ticktock(void)
{
	static int count;

	if (++count < tc_tick)
		return;
	count = 0;
	tc_windup();
}

void
inittimecounter(void)
{
#ifdef DEBUG
	u_int p;
#endif

	/*
	 * Set the initial timeout to
	 * max(1, <approx. number of hardclock ticks in a millisecond>).
	 * People should probably not use the sysctl to set the timeout
	 * to smaller than its initial value, since that value is the
	 * smallest reasonable one.  If they want better timestamps they
	 * should use the non-"get"* functions.
	 */
	if (hz > 1000)
		tc_tick = (hz + 500) / 1000;
	else
		tc_tick = 1;
#ifdef DEBUG
	p = (tc_tick * 1000000) / hz;
	printf("Timecounters tick every %d.%03u msec\n", p / 1000, p % 1000);
#endif

	/* warm up new timecounter (again) and get rolling. */
	(void)timecounter->tc_get_timecount(timecounter);
	(void)timecounter->tc_get_timecount(timecounter);
}

/*
 * Return timecounter-related information.
 */
int
sysctl_tc(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case KERN_TIMECOUNTER_TICK:
		return (sysctl_rdint(oldp, oldlenp, newp, tc_tick));
	case KERN_TIMECOUNTER_TIMESTEPWARNINGS:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &timestepwarnings));
	case KERN_TIMECOUNTER_HARDWARE:
		return (sysctl_tc_hardware(oldp, oldlenp, newp, newlen));
	case KERN_TIMECOUNTER_CHOICE:
		return (sysctl_tc_choice(oldp, oldlenp, newp, newlen));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

void
ntp_update_second(int64_t *adjust)
{
	int64_t adj;

	/* Skew time according to any adjtime(2) adjustments. */
	if (adjtimedelta > 0)
		adj = MIN(5000, adjtimedelta);
	else
		adj = MAX(-5000, adjtimedelta);
	adjtimedelta -= adj;
	*adjust = (adj * 1000) << 32;
	*adjust += timecounter->tc_freq_adj;
}

int
tc_adjfreq(int64_t *old, int64_t *new)
{
	if (old != NULL) {
		*old = timecounter->tc_freq_adj;
	}
	if (new != NULL) {
		timecounter->tc_freq_adj = *new;
	}
	return 0;
}
@


1.30
log
@remove a dead variable; ok millert, guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tc.c,v 1.29 2016/07/06 15:53:01 tedu Exp $ */
d44 1
a44 1
void ntp_update_second(int64_t *, time_t *);
d437 1
a437 1
		ntp_update_second(&th->th_adjustment, &bt.sec);
d620 1
a620 1
ntp_update_second(int64_t *adjust, time_t *sec)
@


1.29
log
@fix several places where calculating ticks could overflow.
it's not enough to assign to an unsigned type because if the arithmetic
overflows the compiler may decide to do anything. so change all the
long long casts to uint64_t so that we start with the right type.
reported by Tim Newsham of NCC.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tc.c,v 1.28 2014/12/10 02:44:47 tedu Exp $ */
a382 3
#ifdef leapsecs
	time_t t;
#endif
@


1.28
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tc.c,v 1.27 2014/11/01 23:58:28 tedu Exp $ */
d360 1
a360 1
	adj_ticks = (long long)hz * bt.sec +
@


1.28.6.1
log
@backport timeout overflow fixes:
fix several places where calculating ticks could overflow.
it's not enough to assign to an unsigned type because if the arithmetic
overflows the compiler may decide to do anything. so change all the
long long casts to uint64_t so that we start with the right type.
reported by Tim Newsham of NCC.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tc.c,v 1.28 2014/12/10 02:44:47 tedu Exp $ */
d360 1
a360 1
	adj_ticks = (uint64_t)hz * bt.sec +
@


1.28.4.1
log
@backport timeout overflow fixes:
fix several places where calculating ticks could overflow.
it's not enough to assign to an unsigned type because if the arithmetic
overflows the compiler may decide to do anything. so change all the
long long casts to uint64_t so that we start with the right type.
reported by Tim Newsham of NCC.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tc.c,v 1.28 2014/12/10 02:44:47 tedu Exp $ */
d360 1
a360 1
	adj_ticks = (uint64_t)hz * bt.sec +
@


1.27
log
@add a few sizes to free
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tc.c,v 1.26 2014/09/14 14:17:25 jsg Exp $ */
d396 1
a396 1
	bcopy(tho, th, offsetof(struct timehands, th_generation));
@


1.26
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tc.c,v 1.25 2014/07/12 18:43:32 tedu Exp $ */
d544 1
a544 1
	free(choices, M_TEMP, 0);
@


1.25
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tc.c,v 1.24 2014/04/03 17:58:31 beck Exp $ */
d26 1
a26 1
#include <sys/proc.h>
@


1.24
log
@fix $OpenBSD$, noticed by philip
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d544 1
a544 1
	free(choices, M_TEMP);
@


1.23
log
@I have discussed these licenses with Poul-Henning Kamp and he has agreed to
this license change. We will remember that we all still like beer.
@
text
@d1 2
@


1.22
log
@Simplyfy adjtime(2) by keeping track of the adjustment as a number of
microsecond in a 64-bit integer.  Fixes the issue where ntpd loses sync
because the struct timeval currently used to hold the adjustment is not
properly normalized after the changes guenther@@ made.

ok guenther@@, millert@@
@
text
@d1 2
a2 7
/*-
 * ----------------------------------------------------------------------------
 * "THE BEER-WARE LICENSE" (Revision 42):
 * <phk@@FreeBSD.ORG> wrote this file.  As long as you retain this notice you
 * can do whatever you want with this stuff. If we meet some day, and you think
 * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp
 * ----------------------------------------------------------------------------
d4 16
a19 2
 * $OpenBSD: kern_tc.c,v 1.21 2013/10/06 01:27:49 guenther Exp $
 * $FreeBSD: src/sys/kern/kern_tc.c,v 1.148 2003/03/18 08:45:23 phk Exp $
@


1.21
log
@Add CLOCK_UPTIME, a clock which measures time-running-not-suspended, so
that mlarkin@@ can fix programs that report rates-over-uptime.

ok kettenis@@
manpage corrections jmc@@ (which I've probably broken again)
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.20 2013/06/03 16:55:22 guenther Exp $
d614 1
a614 1
	struct timeval adj;
d617 6
a622 11
	timerclear(&adj);
	if (adjtimedelta.tv_sec > 0)
		adj.tv_usec = 5000;
	else if (adjtimedelta.tv_sec == 0)
		adj.tv_usec = MIN(5000, adjtimedelta.tv_usec);
	else if (adjtimedelta.tv_sec < -1)
		adj.tv_usec = -5000;
	else if (adjtimedelta.tv_sec == -1)
		adj.tv_usec = MAX(-5000, adjtimedelta.tv_usec - 1000000);
	timersub(&adjtimedelta, &adj, &adjtimedelta);
	*adjust = ((int64_t)adj.tv_usec * 1000) << 32;
@


1.20
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.19 2013/06/02 20:59:09 guenther Exp $
d98 1
a98 1
extern struct timeval adjtimedelta;
d342 3
d348 1
a356 3

	/* XXX fiddle all the little crinkly bits around the fiords... */
	tc_windup();
@


1.19
log
@Use long long and %lld for printing tv_sec values

ok deraadt@@
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.18 2012/11/05 19:39:35 miod Exp $
d299 1
a299 1
	bintime2timeval(&bt, &boottime);
@


1.18
log
@unifdef -D __HAVE_TIMECOUNTER
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.17 2012/05/24 07:17:42 guenther Exp $
d306 3
a308 3
		log(LOG_INFO, "Time stepped from %ld.%09ld to %ld.%09ld\n",
		    (long)ts2.tv_sec, ts2.tv_nsec,
		    (long)ts->tv_sec, ts->tv_nsec);
@


1.17
log
@On resume, run forward the monotonic and realtimes clocks instead of jumping
just the realtime clock, triggering and adjusting timeouts to reflect that.

ok matthew@@ deraadt@@
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.16 2010/09/24 07:29:30 deraadt Exp $
a22 1
#ifdef __HAVE_TIMECOUNTER
a640 1
#endif /* __HAVE_TIMECOUNTER */
@


1.16
log
@useless store
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.15 2010/09/24 02:55:43 deraadt Exp $
d261 1
a261 1
	 * worse since this timecounter may not be monotonous.
d285 2
a286 2
 * Step our concept of UTC.  This is done by modifying our estimate of
 * when we booted.
d290 1
a290 1
tc_setclock(struct timespec *ts)
d311 46
@


1.15
log
@move DEBUG-only variable into #ifdef
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.14 2010/04/20 22:05:43 tedu Exp $
a474 1
	error = 0;
@


1.14
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.13 2010/01/14 23:12:11 schwarze Exp $
d514 1
d516 1
d530 1
a531 1
#ifdef DEBUG
@


1.13
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.12 2008/11/24 16:38:05 deraadt Exp $
d15 1
@


1.12
log
@queue tc randomness when we get it.  the tc_init() ones are (might be)
submitted before randomattach, and thus will perturb the first arc4random()
call, which is very good
ok art djm
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.11 2008/11/21 17:56:34 robert Exp $
d519 1
a519 1
	 * to smaller than its inital value, since that value is the
@


1.11
log
@don't declare th0 extern before declaring it as static; makes gcc4 happy

ok deraadt@@
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.10 2007/12/27 19:05:22 otto Exp $
d20 1
d270 2
a271 1
	(void)tc->tc_get_timecount(tc);
d300 1
@


1.10
log
@allow for max 5000 uses/sec offset adjust, this makes it possible for
clocks with drifts larger than 500ppm to be corrected.
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.9 2007/05/09 17:42:19 deraadt Exp $
d68 1
a68 1
extern struct timehands th0;
@


1.9
log
@unused apis, very dangerous: getbinuptime() getbintime(),  ok art
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.8 2007/03/31 14:46:48 kettenis Exp $
d570 1
a570 1
		adj.tv_usec = MIN(500, adjtimedelta.tv_usec);
d574 1
a574 1
		adj.tv_usec = MAX(-500, adjtimedelta.tv_usec - 1000000);
@


1.8
log
@Add missing bintime2timespec().

ok art@@
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.7 2006/11/15 17:25:40 jmc Exp $
a181 13
getbinuptime(struct bintime *bt)
{
	struct timehands *th;
	u_int gen;

	do {
		th = timehands;
		gen = th->th_generation;
		*bt = th->th_offset;
	} while (gen == 0 || gen != th->th_generation);
}

void
a204 14
}

void
getbintime(struct bintime *bt)
{
	struct timehands *th;
	u_int gen;

	do {
		th = timehands;
		gen = th->th_generation;
		*bt = th->th_offset;
	} while (gen == 0 || gen != th->th_generation);
	bintime_add(bt, &boottimebin);
@


1.7
log
@typos; from bret lambert
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.6 2006/10/30 20:19:33 otto Exp $
d329 1
@


1.6
log
@Timecounter based implementation of adjfreq(2). Largely from art@@
Tested by various using not (yet) committed amd64 timecounter code.
ok deraadt@@
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.5 2005/05/03 11:10:56 hshoexer Exp $
d591 1
a591 1
	/* Slew time according to any adjtime(2) adjustments. */
@


1.5
log
@clean up some small fallout from initial freebsd import.

ok grange@@
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.4 2005/04/21 00:20:13 deraadt Exp $
d603 13
@


1.4
log
@unused variable n; ok cloder
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.3 2004/09/17 10:18:01 grange Exp $
d503 1
a503 1
	for (tc = timecounters; error == 0 && tc != NULL; tc = tc->tc_next) {
d509 1
a509 2
	if (!error)
		error = sysctl_rdstring(oldp, oldlenp, newp, choices);
@


1.3
log
@Some cleanup:
- don't mix unsigned and u_int across the code
- un'static some funcs

ok art@@
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.2 2004/08/04 15:36:44 art Exp $
d494 1
a494 1
	int error, maxlen, n;
d504 1
a504 1
		n = snprintf(buf, sizeof(buf), "%s%s(%d)",
@


1.2
log
@- Match time_second and time_uptime prototypes.
- Less chatty.
@
text
@d9 1
a9 1
 * $OpenBSD: kern_tc.c,v 1.1 2004/07/28 17:15:12 tholo Exp $
d30 2
d42 1
a42 1
static u_int
d101 1
a101 1
static void tc_windup(void);
d266 1
a266 1
	unsigned u;
d340 1
a340 1
static void
@


1.1
log
@This touches only MI code, and adds new time keeping code.  The
code is all conditionalized on __HAVE_TIMECOUNTER, and not
enabled on any platforms.

adjtime(2) support exists, courtesy of nordin@@, sysctl(2) support
and a concept of quality for each time source attached exists.

High quality time sources exists for PIIX4 ACPI timer as well as
some AMD power management chips.  This will have to be redone
once we actually add ACPI support (at that time we need to use
the ACPI interfaces to get at these clocks).

ok art@@ ken@@ miod@@ jmc@@ and many more
@
text
@d9 1
a9 1
 * $OpenBSD$
d92 2
a93 2
time_t time_second = 1;
time_t time_uptime = 0;
a270 2
		printf("Timecounter \"%s\" frequency %lu Hz",
		    tc->tc_name, (unsigned long)tc->tc_frequency);
d273 2
a276 2
		else
			printf(" quality %d\n", tc->tc_quality);
d550 1
d552 1
@

