head	1.76;
access;
symbols
	OPENBSD_6_0:1.69.0.2
	OPENBSD_6_0_BASE:1.69
	OPENBSD_5_9:1.68.0.2
	OPENBSD_5_9_BASE:1.68
	OPENBSD_5_8:1.67.0.6
	OPENBSD_5_8_BASE:1.67
	OPENBSD_5_7:1.67.0.2
	OPENBSD_5_7_BASE:1.67
	OPENBSD_5_6:1.64.0.4
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.58.0.4
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.57.0.6
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.57.0.4
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.57.0.2
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.48
	OPENBSD_5_1:1.48.0.4
	OPENBSD_5_0:1.48.0.2
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.47.0.4
	OPENBSD_4_9_BASE:1.47
	OPENBSD_4_8:1.47.0.2
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.44.0.2
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.39.0.6
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.4
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.36.0.2
	OPENBSD_4_0_BASE:1.36
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.31.0.2
	OPENBSD_3_8_BASE:1.31
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.23
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.6
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.76
date	2017.01.25.07.35.04;	author guenther;	state Exp;
branches;
next	1.75;
commitid	CYncOWzGBjVm3DuH;

1.75
date	2017.01.24.00.58.55;	author mpi;	state Exp;
branches;
next	1.74;
commitid	r0ks7yUPmANG37rA;

1.74
date	2016.11.07.00.26.33;	author guenther;	state Exp;
branches;
next	1.73;
commitid	W7ztnDZwvjCaeQTS;

1.73
date	2016.10.19.08.31.33;	author guenther;	state Exp;
branches;
next	1.72;
commitid	FyYQJQUG0i6W5gNT;

1.72
date	2016.10.19.08.28.19;	author guenther;	state Exp;
branches;
next	1.71;
commitid	VoR9X3uHTxRSYC5r;

1.71
date	2016.10.09.22.46.48;	author guenther;	state Exp;
branches;
next	1.70;
commitid	wxgrBM3uprzXLRiL;

1.70
date	2016.09.01.12.47.18;	author akfaew;	state Exp;
branches;
next	1.69;
commitid	aeQs2i5zZ87ZjqI3;

1.69
date	2016.05.31.22.34.53;	author jca;	state Exp;
branches;
next	1.68;
commitid	nhmYf5YSI3yVBDlB;

1.68
date	2015.09.24.20.35.18;	author tedu;	state Exp;
branches;
next	1.67;
commitid	4mF0OaTa4XzkD0jz;

1.67
date	2015.01.20.19.43.21;	author kettenis;	state Exp;
branches;
next	1.66;
commitid	Fn841MmVYz2JHvBP;

1.66
date	2014.12.12.07.45.46;	author tedu;	state Exp;
branches;
next	1.65;
commitid	tOiu53jgNjU0V5Os;

1.65
date	2014.09.08.01.47.06;	author guenther;	state Exp;
branches;
next	1.64;
commitid	QKTb36RFnfteZJPE;

1.64
date	2014.07.13.15.00.40;	author tedu;	state Exp;
branches;
next	1.63;
commitid	7E1o7NIDvSyD48ls;

1.63
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.62;
commitid	QlVV51SZgNFxsXxC;

1.62
date	2014.07.11.08.18.31;	author guenther;	state Exp;
branches;
next	1.61;
commitid	zJyOCNTjgsYVGLiw;

1.61
date	2014.05.04.05.03.26;	author guenther;	state Exp;
branches;
next	1.60;

1.60
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.59;

1.59
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2014.01.21.01.48.45;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2012.04.13.19.20.31;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2012.04.13.16.37.51;	author kettenis;	state Exp;
branches;
next	1.55;

1.55
date	2012.04.12.14.40.41;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2012.04.12.12.09.05;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2012.04.11.15.28.50;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2012.04.06.20.28.51;	author kettenis;	state Exp;
branches;
next	1.51;

1.51
date	2012.03.10.05.54.28;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2012.02.25.16.45.03;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2012.02.20.22.23.39;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.02.17.04.35;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.26.23.24.45;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2010.05.02.11.15.29;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2010.01.28.19.23.06;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2008.10.31.17.29.51;	author deraadt;	state Exp;
branches
	1.43.2.1
	1.43.6.1;
next	1.42;

1.42
date	2008.10.31.17.17.07;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.31.17.15.30;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.16.19.41.06;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.29.12.24.18;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.19.18.38.42;	author grunk;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.18.21.27.24;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.13.10.33.14;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.11.21.30.31;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.14.20.55.59;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.02.18.04.07;	author kettenis;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.16.22.19.28;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2005.04.03.20.21.44;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.08.00.04.21;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.09.01.33.59;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.27.02.04.50;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.04.10.17.31.59;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.12.14.37.40;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.12.11.57.12;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.11.15.39.27;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.11.14.20.35;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2002.01.30.20.45.35;	author nordin;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.20.11.27.52;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.02.02.38.42;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.06.27.04.49.47;	author art;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.06.18.09.01.52;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.18.08.17.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.09.07.14.18;	author tholo;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.11.10.15.33.10;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.08.22.25.24;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.02.26.05.12.18;	author art;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	98.06.27.07.32.13;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.06.09.18.13.45;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.29.14.51.41;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.52.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.20.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches;
next	;

1.7.6.1
date	2001.05.14.22.32.44;	author niklas;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2001.07.04.10.48.35;	author niklas;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.7.6.4;

1.7.6.4
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.7.6.5;

1.7.6.5
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.7.6.6;

1.7.6.6
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.7.6.7;

1.7.6.7
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.7.6.8;

1.7.6.8
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.7.6.9;

1.7.6.9
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	1.7.6.10;

1.7.6.10
date	2004.06.05.23.13.02;	author niklas;	state Exp;
branches;
next	1.7.6.11;

1.7.6.11
date	2004.06.05.23.18.25;	author tedu;	state Exp;
branches;
next	;

1.10.2.1
date	2002.02.20.08.52.33;	author miod;	state Exp;
branches;
next	;

1.13.2.1
date	2002.01.23.03.10.01;	author jason;	state Exp;
branches;
next	;

1.14.2.1
date	2002.01.31.22.55.41;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;

1.43.2.1
date	2010.01.29.21.33.30;	author sthen;	state Exp;
branches;
next	;

1.43.6.1
date	2010.01.29.21.33.13;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.76
log
@deSCARGize sys_ptrace()

ok mpi@@
@
text
@/*	$OpenBSD: sys_process.c,v 1.75 2017/01/24 00:58:55 mpi Exp $	*/
/*	$NetBSD: sys_process.c,v 1.55 1996/05/15 06:17:47 tls Exp $	*/

/*-
 * Copyright (c) 1994 Christopher G. Demetriou.  All rights reserved.
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)sys_process.c	8.1 (Berkeley) 6/10/93
 */

/*
 * References:
 *	(1) Bach's "The Design of the UNIX Operating System",
 *	(2) sys/miscfs/procfs from UCB's 4.4BSD-Lite distribution,
 *	(3) the "4.4BSD Programmer's Reference Manual" published
 *		by USENIX and O'Reilly & Associates.
 * The 4.4BSD PRM does a reasonably good job of documenting what the various
 * ptrace() requests should actually do, and its text is quoted several times
 * in this file.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/exec.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/ptrace.h>
#include <sys/uio.h>
#include <sys/sched.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

#include <machine/reg.h>

int	process_auxv_offset(struct proc *, struct process *, struct uio *);

#ifdef PTRACE
int	global_ptrace;	/* permit tracing of not children */
/*
 * Process debugging system call.
 */
int
sys_ptrace(struct proc *p, void *v, register_t *retval)
{
	struct sys_ptrace_args /* {
		syscallarg(int) req;
		syscallarg(pid_t) pid;
		syscallarg(caddr_t) addr;
		syscallarg(int) data;
	} */ *uap = v;
	struct proc *t;				/* target thread */
	struct process *tr;			/* target process */
	struct uio uio;
	struct iovec iov;
	struct ptrace_io_desc piod;
	struct ptrace_event pe;
	struct ptrace_thread_state pts;
	struct reg *regs;
#if defined (PT_SETFPREGS) || defined (PT_GETFPREGS)
	struct fpreg *fpregs;
#endif
#if defined (PT_SETXMMREGS) || defined (PT_GETXMMREGS)
	struct xmmregs *xmmregs;
#endif
#ifdef PT_WCOOKIE
	register_t wcookie;
#endif
	int error, write;
	int temp;
	int req = SCARG(uap, req);
	pid_t pid = SCARG(uap, pid);
	caddr_t addr = SCARG(uap, addr);
	int data = SCARG(uap, data);
	int s;

	/* "A foolish consistency..." XXX */
	switch (req) {
	case PT_TRACE_ME:
		t = p;
		tr = t->p_p;
		break;

	/* calls that only operate on the PID */
	case PT_READ_I:
	case PT_READ_D:
	case PT_WRITE_I:
	case PT_WRITE_D:
	case PT_KILL:
	case PT_ATTACH:
	case PT_IO:
	case PT_SET_EVENT_MASK:
	case PT_GET_EVENT_MASK:
	case PT_GET_PROCESS_STATE:
	case PT_GET_THREAD_FIRST:
	case PT_GET_THREAD_NEXT:
	case PT_DETACH:
	default:
		/* Find the process we're supposed to be operating on. */
		if ((tr = prfind(pid)) == NULL)
			return (ESRCH);
		t = tr->ps_mainproc;	/* XXX */
		break;

	/* calls that accept a PID or a thread ID */
	case PT_CONTINUE:
#ifdef PT_STEP
	case PT_STEP:
#endif
#ifdef PT_WCOOKIE
	case PT_WCOOKIE:
#endif
	case PT_GETREGS:
	case PT_SETREGS:
#ifdef PT_GETFPREGS
	case PT_GETFPREGS:
#endif
#ifdef PT_SETFPREGS
	case PT_SETFPREGS:
#endif
#ifdef PT_GETXMMREGS
	case PT_GETXMMREGS:
#endif
#ifdef PT_SETXMMREGS
	case PT_SETXMMREGS:
#endif
		if (pid > THREAD_PID_OFFSET) {
			t = tfind(pid - THREAD_PID_OFFSET);
			if (t == NULL)
				return (ESRCH);
			tr = t->p_p;
		} else {
			if ((tr = prfind(pid)) == NULL)
				return (ESRCH);
			t = tr->ps_mainproc;	/* XXX */
		}
		break;
	}

	if ((tr->ps_flags & PS_INEXEC) != 0)
		return (EAGAIN);

	/* Make sure we can operate on it. */
	switch (req) {
	case  PT_TRACE_ME:
		/* Saying that you're being traced is always legal. */
		break;

	case  PT_ATTACH:
		/*
		 * You can't attach to a process if:
		 *	(1) it's the process that's doing the attaching,
		 */
		if (tr == p->p_p)
			return (EINVAL);

		/*
		 *	(2) it's a system process
		 */
		if (ISSET(tr->ps_flags, PS_SYSTEM))
			return (EPERM);

		/*
		 *	(3) it's already being traced, or
		 */
		if (ISSET(tr->ps_flags, PS_TRACED))
			return (EBUSY);

		/*
		 *	(4) it's not owned by you, or the last exec
		 *	    gave us setuid/setgid privs (unless
		 *	    you're root), or...
		 * 
		 *      [Note: once PS_SUGID or PS_SUGIDEXEC gets set in
		 *	execve(), they stay set until the process does
		 *	another execve().  Hence this prevents a setuid
		 *	process which revokes its special privileges using
		 *	setuid() from being traced.  This is good security.]
		 */
		if ((tr->ps_ucred->cr_ruid != p->p_ucred->cr_ruid ||
		    ISSET(tr->ps_flags, PS_SUGIDEXEC | PS_SUGID)) &&
		    (error = suser(p, 0)) != 0)
			return (error);

		/*
		 * 	(4.5) it's not a child of the tracing process.
		 */
		if (global_ptrace == 0 && !inferior(tr, p->p_p) &&
		    (error = suser(p, 0)) != 0)
			return (error);

		/*
		 *	(5) ...it's init, which controls the security level
		 *	    of the entire system, and the system was not
		 *          compiled with permanently insecure mode turned
		 *	    on.
		 */
		if ((tr->ps_pid == 1) && (securelevel > -1))
			return (EPERM);

		/*
		 *	(6) it's an ancestor of the current process and
		 *	    not init (because that would create a loop in
		 *	    the process graph).
		 */
		if (tr->ps_pid != 1 && inferior(p->p_p, tr))
			return (EINVAL);
		break;

	case  PT_READ_I:
	case  PT_READ_D:
	case  PT_WRITE_I:
	case  PT_WRITE_D:
	case  PT_IO:
	case  PT_CONTINUE:
	case  PT_KILL:
	case  PT_DETACH:
#ifdef PT_STEP
	case  PT_STEP:
#endif
	case  PT_SET_EVENT_MASK:
	case  PT_GET_EVENT_MASK:
	case  PT_GET_PROCESS_STATE:
	case  PT_GETREGS:
	case  PT_SETREGS:
#ifdef PT_GETFPREGS
	case  PT_GETFPREGS:
#endif
#ifdef PT_SETFPREGS
	case  PT_SETFPREGS:
#endif
#ifdef PT_GETXMMREGS
	case  PT_GETXMMREGS:
#endif
#ifdef PT_SETXMMREGS
	case  PT_SETXMMREGS:
#endif
#ifdef PT_WCOOKIE
	case  PT_WCOOKIE:
#endif
		/*
		 * You can't do what you want to the process if:
		 *	(1) It's not being traced at all,
		 */
		if (!ISSET(tr->ps_flags, PS_TRACED))
			return (EPERM);

		/*
		 *	(2) it's not being traced by _you_, or
		 */
		if (tr->ps_pptr != p->p_p)
			return (EBUSY);

		/*
		 *	(3) it's not currently stopped.
		 */
		if (t->p_stat != SSTOP || !ISSET(tr->ps_flags, PS_WAITED))
			return (EBUSY);
		break;

	case  PT_GET_THREAD_FIRST:
	case  PT_GET_THREAD_NEXT:
		/*
		 * You can't do what you want to the process if:
		 *	(1) It's not being traced at all,
		 */
		if (!ISSET(tr->ps_flags, PS_TRACED))
			return (EPERM);

		/*
		 *	(2) it's not being traced by _you_, or
		 */
		if (tr->ps_pptr != p->p_p)
			return (EBUSY);

		/*
		 * Do the work here because the request isn't actually
		 * associated with 't'
		 */
		if (data != sizeof(pts))
			return (EINVAL);

		if (req == PT_GET_THREAD_NEXT) {
			error = copyin(addr, &pts, sizeof(pts));
			if (error)
				return (error);

			t = tfind(pts.pts_tid - THREAD_PID_OFFSET);
			if (t == NULL || ISSET(t->p_flag, P_WEXIT))
				return (ESRCH);
			if (t->p_p != tr)
				return (EINVAL);
			t = TAILQ_NEXT(t, p_thr_link);
		} else {
			t = TAILQ_FIRST(&tr->ps_threads);
		}

		if (t == NULL)
			pts.pts_tid = -1;
		else
			pts.pts_tid = t->p_tid + THREAD_PID_OFFSET;
		return (copyout(&pts, addr, sizeof(pts)));

	default:			/* It was not a legal request. */
		return (EINVAL);
	}

	/* Do single-step fixup if needed. */
	FIX_SSTEP(t);

	/* Now do the operation. */
	write = 0;
	*retval = 0;

	switch (req) {
	case  PT_TRACE_ME:
		/* Just set the trace flag. */
		atomic_setbits_int(&tr->ps_flags, PS_TRACED);
		tr->ps_oppid = tr->ps_pptr->ps_pid;
		if (tr->ps_ptstat == NULL)
			tr->ps_ptstat = malloc(sizeof(*tr->ps_ptstat),
			    M_SUBPROC, M_WAITOK);
		memset(tr->ps_ptstat, 0, sizeof(*tr->ps_ptstat));
		return (0);

	case  PT_WRITE_I:		/* XXX no separate I and D spaces */
	case  PT_WRITE_D:
		write = 1;
		temp = data;
	case  PT_READ_I:		/* XXX no separate I and D spaces */
	case  PT_READ_D:
		/* write = 0 done above. */
		iov.iov_base = (caddr_t)&temp;
		iov.iov_len = sizeof(int);
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(vaddr_t)addr;
		uio.uio_resid = sizeof(int);
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = write ? UIO_WRITE : UIO_READ;
		uio.uio_procp = p;
		error = process_domem(p, tr, &uio, write ? PT_WRITE_I :
				PT_READ_I);
		if (write == 0)
			*retval = temp;
		return (error);
	case  PT_IO:
		error = copyin(addr, &piod, sizeof(piod));
		if (error)
			return (error);
		iov.iov_base = piod.piod_addr;
		iov.iov_len = piod.piod_len;
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(vaddr_t)piod.piod_offs;
		uio.uio_resid = piod.piod_len;
		uio.uio_segflg = UIO_USERSPACE;
		uio.uio_procp = p;
		switch (piod.piod_op) {
		case PIOD_READ_I:
			req = PT_READ_I;
			uio.uio_rw = UIO_READ;
			break;
		case PIOD_READ_D:
			req = PT_READ_D;
			uio.uio_rw = UIO_READ;
			break;
		case PIOD_WRITE_I:
			req = PT_WRITE_I;
			uio.uio_rw = UIO_WRITE;
			break;
		case PIOD_WRITE_D:
			req = PT_WRITE_D;
			uio.uio_rw = UIO_WRITE;
			break;
		case PIOD_READ_AUXV:
			req = PT_READ_D;
			uio.uio_rw = UIO_READ;
			temp = tr->ps_emul->e_arglen * sizeof(char *);
			if (uio.uio_offset > temp)
				return (EIO);
			if (uio.uio_resid > temp - uio.uio_offset)
				uio.uio_resid = temp - uio.uio_offset;
			piod.piod_len = iov.iov_len = uio.uio_resid;
			error = process_auxv_offset(p, tr, &uio);
			if (error)
				return (error);
			break;
		default:
			return (EINVAL);
		}
		error = process_domem(p, tr, &uio, req);
		piod.piod_len -= uio.uio_resid;
		(void) copyout(&piod, addr, sizeof(piod));
		return (error);
#ifdef PT_STEP
	case  PT_STEP:
		/*
		 * From the 4.4BSD PRM:
		 * "Execution continues as in request PT_CONTINUE; however
		 * as soon as possible after execution of at least one
		 * instruction, execution stops again. [ ... ]"
		 */
#endif
	case  PT_CONTINUE:
		/*
		 * From the 4.4BSD PRM:
		 * "The data argument is taken as a signal number and the
		 * child's execution continues at location addr as if it
		 * incurred that signal.  Normally the signal number will
		 * be either 0 to indicate that the signal that caused the
		 * stop should be ignored, or that value fetched out of
		 * the process's image indicating which signal caused
		 * the stop.  If addr is (int *)1 then execution continues
		 * from where it stopped."
		 */

		if (pid < THREAD_PID_OFFSET && tr->ps_single)
			t = tr->ps_single;

		/* Check that the data is a valid signal number or zero. */
		if (data < 0 || data >= NSIG)
			return (EINVAL);

		/* If the address parameter is not (int *)1, set the pc. */
		if ((int *)addr != (int *)1)
			if ((error = process_set_pc(t, addr)) != 0)
				return error;

#ifdef PT_STEP
		/*
		 * Arrange for a single-step, if that's requested and possible.
		 */
		error = process_sstep(t, req == PT_STEP);
		if (error)
			return error;
#endif
		goto sendsig;

	case  PT_DETACH:
		/*
		 * From the 4.4BSD PRM:
		 * "The data argument is taken as a signal number and the
		 * child's execution continues at location addr as if it
		 * incurred that signal.  Normally the signal number will
		 * be either 0 to indicate that the signal that caused the
		 * stop should be ignored, or that value fetched out of
		 * the process's image indicating which signal caused
		 * the stop.  If addr is (int *)1 then execution continues
		 * from where it stopped."
		 */

		if (pid < THREAD_PID_OFFSET && tr->ps_single)
			t = tr->ps_single;

		/* Check that the data is a valid signal number or zero. */
		if (data < 0 || data >= NSIG)
			return (EINVAL);

#ifdef PT_STEP
		/*
		 * Stop single stepping.
		 */
		error = process_sstep(t, 0);
		if (error)
			return error;
#endif

		/* give process back to original parent or init */
		if (tr->ps_oppid != tr->ps_pptr->ps_pid) {
			struct process *ppr;

			ppr = prfind(tr->ps_oppid);
			proc_reparent(tr, ppr ? ppr : initprocess);
		}

		/* not being traced any more */
		tr->ps_oppid = 0;
		atomic_clearbits_int(&tr->ps_flags, PS_TRACED|PS_WAITED);

	sendsig:
		memset(tr->ps_ptstat, 0, sizeof(*tr->ps_ptstat));

		/* Finally, deliver the requested signal (or none). */
		if (t->p_stat == SSTOP) {
			t->p_xstat = data;
			SCHED_LOCK(s);
			setrunnable(t);
			SCHED_UNLOCK(s);
		} else {
			if (data != 0)
				psignal(t, data);
		}

		return (0);

	case  PT_KILL:
		if (pid < THREAD_PID_OFFSET && tr->ps_single)
			t = tr->ps_single;

		/* just send the process a KILL signal. */
		data = SIGKILL;
		goto sendsig;	/* in PT_CONTINUE, above. */

	case  PT_ATTACH:
		/*
		 * As was done in procfs:
		 * Go ahead and set the trace flag.
		 * Save the old parent (it's reset in
		 *   _DETACH, and also in kern_exit.c:wait4()
		 * Reparent the process so that the tracing
		 *   proc gets to see all the action.
		 * Stop the target.
		 */
		atomic_setbits_int(&tr->ps_flags, PS_TRACED);
		tr->ps_oppid = tr->ps_pptr->ps_pid;
		if (tr->ps_pptr != p->p_p)
			proc_reparent(tr, p->p_p);
		if (tr->ps_ptstat == NULL)
			tr->ps_ptstat = malloc(sizeof(*tr->ps_ptstat),
			    M_SUBPROC, M_WAITOK);
		data = SIGSTOP;
		goto sendsig;

	case  PT_GET_EVENT_MASK:
		if (data != sizeof(pe))
			return (EINVAL);
		memset(&pe, 0, sizeof(pe));
		pe.pe_set_event = tr->ps_ptmask;
		return (copyout(&pe, addr, sizeof(pe)));
	case  PT_SET_EVENT_MASK:
		if (data != sizeof(pe))
			return (EINVAL);
		if ((error = copyin(addr, &pe, sizeof(pe))))
			return (error);
		tr->ps_ptmask = pe.pe_set_event;
		return (0);

	case  PT_GET_PROCESS_STATE:
		if (data != sizeof(*tr->ps_ptstat))
			return (EINVAL);

		if (tr->ps_single)
			tr->ps_ptstat->pe_tid =
			    tr->ps_single->p_tid + THREAD_PID_OFFSET;

		return (copyout(tr->ps_ptstat, addr, sizeof(*tr->ps_ptstat)));

	case  PT_SETREGS:
		KASSERT((p->p_flag & P_SYSTEM) == 0);
		if ((error = process_checkioperm(p, tr)) != 0)
			return (error);

		regs = malloc(sizeof(*regs), M_TEMP, M_WAITOK);
		error = copyin(addr, regs, sizeof(*regs));
		if (error == 0) {
			error = process_write_regs(t, regs);
		}
		free(regs, M_TEMP, sizeof(*regs));
		return (error);
	case  PT_GETREGS:
		KASSERT((p->p_flag & P_SYSTEM) == 0);
		if ((error = process_checkioperm(p, tr)) != 0)
			return (error);

		regs = malloc(sizeof(*regs), M_TEMP, M_WAITOK);
		error = process_read_regs(t, regs);
		if (error == 0)
			error = copyout(regs, addr, sizeof (*regs));
		free(regs, M_TEMP, sizeof(*regs));
		return (error);
#ifdef PT_SETFPREGS
	case  PT_SETFPREGS:
		KASSERT((p->p_flag & P_SYSTEM) == 0);
		if ((error = process_checkioperm(p, tr)) != 0)
			return (error);

		fpregs = malloc(sizeof(*fpregs), M_TEMP, M_WAITOK);
		error = copyin(addr, fpregs, sizeof(*fpregs));
		if (error == 0) {
			error = process_write_fpregs(t, fpregs);
		}
		free(fpregs, M_TEMP, sizeof(*fpregs));
		return (error);
#endif
#ifdef PT_GETFPREGS
	case  PT_GETFPREGS:
		KASSERT((p->p_flag & P_SYSTEM) == 0);
		if ((error = process_checkioperm(p, tr)) != 0)
			return (error);

		fpregs = malloc(sizeof(*fpregs), M_TEMP, M_WAITOK);
		error = process_read_fpregs(t, fpregs);
		if (error == 0)
			error = copyout(fpregs, addr, sizeof(*fpregs));
		free(fpregs, M_TEMP, sizeof(*fpregs));
		return (error);
#endif
#ifdef PT_SETXMMREGS
	case  PT_SETXMMREGS:
		KASSERT((p->p_flag & P_SYSTEM) == 0);
		if ((error = process_checkioperm(p, tr)) != 0)
			return (error);

		xmmregs = malloc(sizeof(*xmmregs), M_TEMP, M_WAITOK);
		error = copyin(addr, xmmregs, sizeof(*xmmregs));
		if (error == 0) {
			error = process_write_xmmregs(t, xmmregs);
		}
		free(xmmregs, M_TEMP, sizeof(*xmmregs));
		return (error);
#endif
#ifdef PT_GETXMMREGS
	case  PT_GETXMMREGS:
		KASSERT((p->p_flag & P_SYSTEM) == 0);
		if ((error = process_checkioperm(p, tr)) != 0)
			return (error);

		xmmregs = malloc(sizeof(*xmmregs), M_TEMP, M_WAITOK);
		error = process_read_xmmregs(t, xmmregs);
		if (error == 0)
			error = copyout(xmmregs, addr, sizeof(*xmmregs));
		free(xmmregs, M_TEMP, sizeof(*xmmregs));
		return (error);
#endif
#ifdef PT_WCOOKIE
	case  PT_WCOOKIE:
		wcookie = process_get_wcookie (t);
		return (copyout(&wcookie, addr, sizeof (register_t)));
#endif
	}

#ifdef DIAGNOSTIC
	panic("ptrace: impossible");
#endif
	return 0;
}

/*
 * Check if a process is allowed to fiddle with the memory of another.
 *
 * p = tracer
 * tr = tracee
 *
 * 1.  You can't attach to a process not owned by you or one that has raised
 *     its privileges.
 * 1a. ...unless you are root.
 *
 * 2.  init is always off-limits because it can control the securelevel.
 * 2a. ...unless securelevel is permanently set to insecure.
 *
 * 3.  Processes that are in the process of doing an exec() are always
 *     off-limits because of the can of worms they are. Just wait a
 *     second.
 */
int
process_checkioperm(struct proc *p, struct process *tr)
{
	int error;

	if ((tr->ps_ucred->cr_ruid != p->p_ucred->cr_ruid ||
	    ISSET(tr->ps_flags, PS_SUGIDEXEC | PS_SUGID)) &&
	    (error = suser(p, 0)) != 0)
		return (error);

	if ((tr->ps_pid == 1) && (securelevel > -1))
		return (EPERM);

	if (tr->ps_flags & PS_INEXEC)
		return (EAGAIN);

	return (0);
}

int
process_domem(struct proc *curp, struct process *tr, struct uio *uio, int req)
{
	struct vmspace *vm;
	int error;
	vaddr_t addr;
	vsize_t len;

	len = uio->uio_resid;
	if (len == 0)
		return 0;

	if ((error = process_checkioperm(curp, tr)) != 0)
		return error;

	/* XXXCDC: how should locking work here? */
	vm = tr->ps_vmspace;
	if ((tr->ps_flags & PS_EXITING) || (vm->vm_refcnt < 1))
		return EFAULT;
	addr = uio->uio_offset;

	vm->vm_refcnt++;

	error = uvm_io(&vm->vm_map, uio,
	    (uio->uio_rw == UIO_WRITE) ? UVM_IO_FIXPROT : 0);

	uvmspace_free(vm);

	if (error == 0 && req == PT_WRITE_I)
		pmap_proc_iflush(tr, addr, len);

	return error;
}

int
process_auxv_offset(struct proc *curp, struct process *tr, struct uio *uiop)
{
	struct vmspace *vm;
	struct ps_strings pss;
	struct iovec iov;
	struct uio uio;
	int error;

	iov.iov_base = &pss;
	iov.iov_len = sizeof(pss);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;	
	uio.uio_offset = (off_t)tr->ps_strings;
	uio.uio_resid = sizeof(pss);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = curp;

	vm = tr->ps_vmspace;
	if ((tr->ps_flags & PS_EXITING) || (vm->vm_refcnt < 1))
		return EFAULT;

	vm->vm_refcnt++;
	error = uvm_io(&vm->vm_map, &uio, 0);
	uvmspace_free(vm);

	if (error != 0)
		return error;

	if (pss.ps_envstr == NULL)
		return EIO;

	uiop->uio_offset += (off_t)(vaddr_t)(pss.ps_envstr + pss.ps_nenvstr + 1);
#ifdef MACHINE_STACK_GROWS_UP
	if (uiop->uio_offset < (off_t)tr->ps_strings)
		return EIO;
#else
	if (uiop->uio_offset > (off_t)tr->ps_strings)
		return EIO;
	if ((uiop->uio_offset + uiop->uio_resid) > (off_t)tr->ps_strings)
		uiop->uio_resid = (off_t)tr->ps_strings - uiop->uio_offset;
#endif

	return 0;
}
#endif
@


1.75
log
@Rename pfind(9) into tfind(9) to reflect that it deals with threads.

While here document prfind(9.

with and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.74 2016/11/07 00:26:33 guenther Exp $	*/
d106 3
d134 1
a134 1
		if ((tr = prfind(SCARG(uap, pid))) == NULL)
d161 2
a162 2
		if (SCARG(uap, pid) > THREAD_PID_OFFSET) {
			t = tfind(SCARG(uap, pid) - THREAD_PID_OFFSET);
d167 1
a167 1
			if ((tr = prfind(SCARG(uap, pid))) == NULL)
d314 1
a314 1
		if (SCARG(uap, data) != sizeof(pts))
d318 1
a318 1
			error = copyin(SCARG(uap, addr), &pts, sizeof(pts));
d336 1
a336 1
		return (copyout(&pts, SCARG(uap, addr), sizeof(pts)));
d363 1
a363 1
		temp = SCARG(uap, data);
d371 1
a371 1
		uio.uio_offset = (off_t)(vaddr_t)SCARG(uap, addr);
d382 1
a382 1
		error = copyin(SCARG(uap, addr), &piod, sizeof(piod));
d428 1
a428 1
		(void) copyout(&piod, SCARG(uap, addr), sizeof(piod));
d452 1
a452 1
		if (SCARG(uap, pid) < THREAD_PID_OFFSET && tr->ps_single)
d456 1
a456 1
		if (SCARG(uap, data) < 0 || SCARG(uap, data) >= NSIG)
d460 2
a461 2
		if ((int *)SCARG(uap, addr) != (int *)1)
			if ((error = process_set_pc(t, SCARG(uap, addr))) != 0)
d487 1
a487 1
		if (SCARG(uap, pid) < THREAD_PID_OFFSET && tr->ps_single)
d491 1
a491 1
		if (SCARG(uap, data) < 0 || SCARG(uap, data) >= NSIG)
d520 1
a520 1
			t->p_xstat = SCARG(uap, data);
d525 2
a526 2
			if (SCARG(uap, data) != 0)
				psignal(t, SCARG(uap, data));
d532 1
a532 1
		if (SCARG(uap, pid) < THREAD_PID_OFFSET && tr->ps_single)
d536 1
a536 1
		SCARG(uap, data) = SIGKILL;
d556 1
a556 1
		SCARG(uap, data) = SIGSTOP;
d560 1
a560 1
		if (SCARG(uap, data) != sizeof(pe))
d564 1
a564 1
		return (copyout(&pe, SCARG(uap, addr), sizeof(pe)));
d566 1
a566 1
		if (SCARG(uap, data) != sizeof(pe))
d568 1
a568 1
		if ((error = copyin(SCARG(uap, addr), &pe, sizeof(pe))))
d574 1
a574 1
		if (SCARG(uap, data) != sizeof(*tr->ps_ptstat))
d581 1
a581 2
		return (copyout(tr->ps_ptstat, SCARG(uap, addr),
		    sizeof(*tr->ps_ptstat)));
d589 1
a589 1
		error = copyin(SCARG(uap, addr), regs, sizeof(*regs));
d603 1
a603 2
			error = copyout(regs,
			    SCARG(uap, addr), sizeof (*regs));
d613 1
a613 1
		error = copyin(SCARG(uap, addr), fpregs, sizeof(*fpregs));
d629 1
a629 2
			error = copyout(fpregs,
			    SCARG(uap, addr), sizeof(*fpregs));
d640 1
a640 1
		error = copyin(SCARG(uap, addr), xmmregs, sizeof(*xmmregs));
d656 1
a656 2
			error = copyout(xmmregs,
			    SCARG(uap, addr), sizeof(*xmmregs));
d663 1
a663 2
		return (copyout(&wcookie, SCARG(uap, addr),
		    sizeof (register_t)));
@


1.74
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.73 2016/10/19 08:31:33 guenther Exp $	*/
d159 1
a159 1
			t = pfind(SCARG(uap, pid) - THREAD_PID_OFFSET);
d319 1
a319 1
			t = pfind(pts.pts_tid - THREAD_PID_OFFSET);
@


1.73
log
@Change process_{domem,auxv_offset}() to take a process instead of a proc.
Make process_auxv_offset() take and release a reference of the vmspace like
process_domem() does.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.72 2016/10/19 08:28:19 guenther Exp $	*/
d112 1
d128 1
d131 1
a131 3
		if ((t = pfind(SCARG(uap, pid))) == NULL)
			return (ESRCH);
		if (t->p_flag & P_THREAD)
d133 1
a137 1
	case PT_DETACH:
d141 3
d162 1
d164 1
a164 3
			if ((t = pfind(SCARG(uap, pid))) == NULL)
				return (ESRCH);
			if (t->p_flag & P_THREAD)
d166 1
a169 1
	tr = t->p_p;
d332 1
a332 1
			pts.pts_tid = t->p_pid + THREAD_PID_OFFSET;
d576 1
a576 1
			    tr->ps_single->p_pid + THREAD_PID_OFFSET;
@


1.72
log
@Change pmap_proc_iflush() to take a process instead of a proc
powerpc: rename second argument of pmap_proc_iflush() to match other archs

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.71 2016/10/09 22:46:48 guenther Exp $	*/
d70 1
a70 1
int	process_auxv_offset(struct proc *, struct proc *, struct uio *);
d371 1
a371 1
		error = process_domem(p, t, &uio, write ? PT_WRITE_I :
d414 1
a414 1
			error = process_auxv_offset(p, t, &uio);
d421 1
a421 1
		error = process_domem(p, t, &uio, req);
d710 1
a710 1
process_domem(struct proc *curp, struct proc *p, struct uio *uio, int req)
d719 1
a719 1
		return (0);
d721 2
a722 2
	if ((error = process_checkioperm(curp, p->p_p)) != 0)
		return (error);
d725 3
a727 2
	if ((p->p_p->ps_flags & PS_EXITING) || (p->p_vmspace->vm_refcnt < 1))
		return(EFAULT);
a729 1
	vm = p->p_vmspace;
d738 1
a738 1
		pmap_proc_iflush(p->p_p, addr, len);
d740 1
a740 1
	return (error);
d744 1
a744 1
process_auxv_offset(struct proc *curp, struct proc *p, struct uio *uiop)
d746 1
a746 1
	struct process *pr = p->p_p;
d756 1
a756 1
	uio.uio_offset = (off_t)pr->ps_strings;
d762 10
a771 2
	if ((error = uvm_io(&p->p_vmspace->vm_map, &uio, 0)) != 0)
		return (error);
d774 1
a774 1
		return (EIO);
d778 2
a779 2
	if (uiop->uio_offset < (off_t)pr->ps_strings)
		return (EIO);
d781 4
a784 4
	if (uiop->uio_offset > (off_t)pr->ps_strings)
		return (EIO);
	if ((uiop->uio_offset + uiop->uio_resid) > (off_t)pr->ps_strings)
		uiop->uio_resid = (off_t)pr->ps_strings - uiop->uio_offset;
d787 1
a787 1
	return (0);
@


1.71
log
@With systrace and procfs gone, process_checkioperm() and process_domem()
are for option PTRACE only

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.70 2016/09/01 12:47:18 akfaew Exp $	*/
d738 1
a738 1
		pmap_proc_iflush(p, addr, len);
@


1.70
log
@Get rid of 'relebad:'.

OK natano@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.69 2016/05/31 22:34:53 jca Exp $	*/
a671 1
#endif	/* PTRACE */
a742 1
#ifdef PTRACE
@


1.69
log
@Fix ptrace PT_WRITE_D that returned EFAULT.

Broken in r.1.33.  After discussion from kettenis@@, don't attempt to
make PT_WRITE_D and PT_WRITE_I equivalent again.

From Mathieu (naabed at poolp dot org)
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.68 2015/09/24 20:35:18 tedu Exp $	*/
d457 1
a457 1
				goto relebad;
d465 1
a465 1
			goto relebad;
d495 1
a495 1
			goto relebad;
a524 3

	relebad:
		return (error);
@


1.68
log
@buglet: there's no way for req to be STEP in the DETACH case.
also fix the confusing comment. ok guethner.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.67 2015/01/20 19:43:21 kettenis Exp $	*/
d737 1
a737 1
	    (req == PT_WRITE_I) ? UVM_IO_FIXPROT : 0);
@


1.67
log
@Move ps_strings "after" the random stackgap.  This makes its location a
per-process value, and therefpore turns the VM_PSSTRINGS sysctl into a
per-process one as well.  This gets rid of a pointer to the bottom of the
stack at a fixed location.  Also clears the road for unmapping the stackgap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.66 2014/12/12 07:45:46 tedu Exp $	*/
d491 1
a491 1
		 * Arrange for a single-step, if that's requested and possible.
d493 1
a493 1
		error = process_sstep(t, req == PT_STEP);
@


1.66
log
@sysctl kern.global_ptrace.
controls whether you can ptrace any process with appropriate privileges
or only one own's children.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.65 2014/09/08 01:47:06 guenther Exp $	*/
d751 1
d761 1
a761 1
	uio.uio_offset = (off_t)(vaddr_t)PS_STRINGS;
d775 1
a775 1
	if (uiop->uio_offset < (off_t)(vaddr_t)PS_STRINGS)
d778 1
a778 1
	if (uiop->uio_offset > (off_t)(vaddr_t)PS_STRINGS)
d780 2
a781 2
	if ((uiop->uio_offset + uiop->uio_resid) > (off_t)(vaddr_t)PS_STRINGS)
		uiop->uio_resid = (off_t)(vaddr_t)PS_STRINGS - uiop->uio_offset;
@


1.65
log
@Delete procfs; it's always had races and is now unused: no one noticed for
months that I broke it before the 5.5 release.

confirmed as not being required by ports by sthen@@, ajacoutot@@, dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.64 2014/07/13 15:00:40 tedu Exp $	*/
d73 1
d211 7
@


1.64
log
@pass the size to free in some of the obvious cases
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.63 2014/07/12 18:43:32 tedu Exp $	*/
d531 1
a531 1
		 * As done in procfs:
@


1.63
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.62 2014/07/11 08:18:31 guenther Exp $	*/
d584 1
a584 1
		free(regs, M_TEMP, 0);
d596 1
a596 1
		free(regs, M_TEMP, 0);
d609 1
a609 1
		free(fpregs, M_TEMP, 0);
d623 1
a623 1
		free(fpregs, M_TEMP, 0);
d637 1
a637 1
		free(xmmregs, M_TEMP, 0);
d651 1
a651 1
		free(xmmregs, M_TEMP, 0);
@


1.62
log
@It's init as a process that's special, not init's original thread.
Remember initprocess instead of initproc.

ok matthew@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.61 2014/05/04 05:03:26 guenther Exp $	*/
d584 1
a584 1
		free(regs, M_TEMP);
d596 1
a596 1
		free(regs, M_TEMP);
d609 1
a609 1
		free(fpregs, M_TEMP);
d623 1
a623 1
		free(fpregs, M_TEMP);
d637 1
a637 1
		free(xmmregs, M_TEMP);
d651 1
a651 1
		free(xmmregs, M_TEMP);
@


1.61
log
@Add PS_SYSTEM, the process-level mirror of the thread-level P_SYSTEM,
and FORK_SYSTEM as a flag to set them.  This eliminates needing to
peek into other processes threads in various places.  Inspired by NetBSD

ok miod@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.60 2014/03/30 21:54:48 guenther Exp $	*/
d495 1
a495 1
			proc_reparent(tr, ppr ? ppr : initproc->p_p);
@


1.60
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.59 2014/03/26 05:23:42 guenther Exp $	*/
d188 1
a188 1
		if (ISSET(t->p_flag, P_SYSTEM))
@


1.59
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.58 2014/01/21 01:48:45 tedu Exp $	*/
d208 1
a208 1
		if ((tr->ps_cred->p_ruid != p->p_cred->p_ruid ||
d691 1
a691 1
	if ((tr->ps_cred->p_ruid != p->p_cred->p_ruid ||
@


1.58
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.57 2012/04/13 19:20:31 kettenis Exp $	*/
d400 1
a400 1
			temp = t->p_emul->e_arglen * sizeof(char *);
@


1.57
log
@For now, direct the kill signal sent by PT_KILL to the thread that made us
stop, just like we do for PT_CONTINUE/PT_STEP.  The current code isn't
ready for directing signals to other threads yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.56 2012/04/13 16:37:51 kettenis Exp $	*/
d344 1
a344 1
		bzero(tr->ps_ptstat, sizeof(*tr->ps_ptstat));
d503 1
a503 1
		bzero(tr->ps_ptstat, sizeof(*tr->ps_ptstat));
d552 1
a552 1
		bzero(&pe, sizeof(pe));
@


1.56
log
@First stab at making ptrace(2) usable for debugging multi-threaded programs.
It implements a full-stop model where all threads are stopped before handing
over control to the debugger.  Events are reported as before through wait(2);
you will have to call ptrace(PT_GET_PROCESS_STATE, ...) to find out which
thread hit the event.  Since this changes the size of struct ptrace_state,
you will have to recompile gdb.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.55 2012/04/12 14:40:41 kettenis Exp $	*/
d522 3
@


1.55
log
@If the "main" thread exits it stays around but unlinks itself from the
threads list.  Calling TAILQ_NEXT on them is a bad idea and will panic
the kernel.  So check the P_WEXIT flag and pretend the thread doesn't
exist if it is set.  Also make PT_GET_THREAD_FIRST return the first
thread on the threads list instead of the "main" thread, such that you
can actually keep enumerating the threads in this case.

ok guenther@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.54 2012/04/12 12:09:05 kettenis Exp $	*/
a86 1
	struct proc *q;
d439 3
d474 3
d515 1
a515 7
		SCHED_LOCK(s);
		TAILQ_FOREACH(q, &tr->ps_threads, p_thr_link) {
			if (q != t && q->p_stat == SSTOP) {
				setrunnable(q);
			}
		}
		SCHED_UNLOCK(s);
d563 5
@


1.54
log
@PT_GETXMMREGS and PT_SETXMMREGS can take a TID.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.53 2012/04/11 15:28:50 kettenis Exp $	*/
d311 1
a311 1
			if (t == NULL)
d316 2
@


1.53
log
@Move the P_WAITED flag from struct proc to struct process.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.52 2012/04/06 20:28:51 kettenis Exp $	*/
d148 6
@


1.52
log
@Implement PT_GET_THREAD_FIRS and PT_GET_THREAD_NEXT.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.51 2012/03/10 05:54:28 guenther Exp $	*/
d273 1
a273 2
		if (t->p_stat != SSTOP ||
		    !ISSET(tr->ps_mainproc->p_flag, P_WAITED))
d487 1
a487 2
		atomic_clearbits_int(&tr->ps_flags, PS_TRACED);
		atomic_clearbits_int(&t->p_flag, P_WAITED);
@


1.51
log
@Add PS_EXITING to better differentiate between the process exiting and
the main thread exiting.  c.f. regress/sys/kern/main-thread-exited/
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.50 2012/02/25 16:45:03 miod Exp $	*/
d92 1
d273 2
a274 1
		if (t->p_stat != SSTOP || !ISSET(t->p_flag, P_WAITED))
a295 1
		 * XXX
d297 7
d305 7
a311 1
		return (ENOTSUP);	/* XXX */
d313 5
a317 1
		break;
@


1.50
log
@Allow this to build on platforms lacking PT_GETFPREGS or PT_SETFPREGS; broken
in previous rev.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.49 2012/02/20 22:23:39 guenther Exp $	*/
d690 1
a690 1
	if ((p->p_flag & P_WEXIT) || (p->p_vmspace->vm_refcnt < 1)) 
@


1.49
log
@First steps for making ptrace work with rthreads:
 - move the P_TRACED and P_INEXEC flags, and p_oppid, p_ptmask, and
   p_ptstat member from struct proc to struct process
 - sort the PT_* requests into those that take a PID vs those that
   can also take a TID
 - stub in PT_GET_THREAD_FIRST and PT_GET_THREAD_NEXT

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.48 2011/04/02 17:04:35 guenther Exp $	*/
d142 1
d144 2
d147 1
@


1.48
log
@Move P_SUGID and P_SUGIDEXEC from struct proc to struct process, so
that you can't evade the checks by doing the dirty work in an rthread

ok blambert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.47 2010/07/26 01:56:27 guenther Exp $	*/
d85 3
a87 1
	struct proc *t;				/* target process */
d104 1
a104 1
	int req;
d108 2
a109 1
	if (SCARG(uap, req) == PT_TRACE_ME)
d111 1
a111 1
	else {
d113 14
d130 25
d156 1
d158 1
a158 1
	if ((t->p_flag & P_INEXEC) != 0)
d162 1
a162 1
	switch (SCARG(uap, req)) {
d172 1
a172 1
		if (t->p_pid == p->p_pid)
d184 1
a184 1
		if (ISSET(t->p_flag, P_TRACED))
d198 2
a199 2
		if ((t->p_cred->p_ruid != p->p_cred->p_ruid ||
		    ISSET(t->p_p->ps_flags, PS_SUGIDEXEC | PS_SUGID)) &&
d209 1
a209 1
		if ((t->p_pid == 1) && (securelevel > -1))
d217 1
a217 1
		if (t->p_pid != 1 && inferior(p->p_p, t->p_p))
d256 1
a256 1
		if (!ISSET(t->p_flag, P_TRACED))
d262 1
a262 1
		if (t->p_p->ps_pptr != p->p_p)
d272 25
d308 1
a308 1
	switch (SCARG(uap, req)) {
d311 4
a314 4
		atomic_setbits_int(&t->p_flag, P_TRACED);
		t->p_oppid = t->p_p->ps_pptr->ps_pid;
		if (t->p_ptstat == NULL)
			t->p_ptstat = malloc(sizeof(*t->p_ptstat),
d316 1
a316 1
		bzero(t->p_ptstat, sizeof(*t->p_ptstat));
d424 1
a424 1
		error = process_sstep(t, SCARG(uap, req) == PT_STEP);
d451 1
a451 1
		error = process_sstep(t, SCARG(uap, req) == PT_STEP);
d457 1
a457 1
		if (t->p_oppid != t->p_p->ps_pptr->ps_pid) {
d460 2
a461 2
			ppr = prfind(t->p_oppid);
			proc_reparent(t->p_p, ppr ? ppr : initproc->p_p);
d465 3
a467 2
		t->p_oppid = 0;
		atomic_clearbits_int(&t->p_flag, P_TRACED|P_WAITED);
d470 1
a470 1
		bzero(t->p_ptstat, sizeof(*t->p_ptstat));
d482 7
d509 6
a514 6
		atomic_setbits_int(&t->p_flag, P_TRACED);
		t->p_oppid = t->p_p->ps_pptr->ps_pid;
		if (t->p_p->ps_pptr != p->p_p)
			proc_reparent(t->p_p, p->p_p);
		if (t->p_ptstat == NULL)
			t->p_ptstat = malloc(sizeof(*t->p_ptstat),
d523 1
a523 1
		pe.pe_set_event = t->p_ptmask;
d530 1
a530 1
		t->p_ptmask = pe.pe_set_event;
d534 1
a534 1
		if (SCARG(uap, data) != sizeof(*t->p_ptstat))
d536 2
a537 2
		return (copyout(t->p_ptstat, SCARG(uap, addr),
		    sizeof(*t->p_ptstat)));
d541 1
a541 1
		if ((error = process_checkioperm(p, t)) != 0)
d553 1
a553 1
		if ((error = process_checkioperm(p, t)) != 0)
d566 1
a566 1
		if ((error = process_checkioperm(p, t)) != 0)
d580 1
a580 1
		if ((error = process_checkioperm(p, t)) != 0)
d594 1
a594 1
		if ((error = process_checkioperm(p, t)) != 0)
d608 1
a608 1
		if ((error = process_checkioperm(p, t)) != 0)
d638 1
a638 1
 * t = tracee
d652 1
a652 1
process_checkioperm(struct proc *p, struct proc *t)
d656 2
a657 2
	if ((t->p_cred->p_ruid != p->p_cred->p_ruid ||
	    ISSET(t->p_p->ps_flags, PS_SUGIDEXEC | PS_SUGID)) &&
d661 1
a661 1
	if ((t->p_pid == 1) && (securelevel > -1))
d664 1
a664 1
	if (t->p_flag & P_INEXEC)
d682 1
a682 1
	if ((error = process_checkioperm(curp, p)) != 0)
@


1.47
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.46 2010/06/26 23:24:45 guenther Exp $	*/
d149 1
a149 1
		 *      [Note: once P_SUGID or P_SUGIDEXEC gets set in
d156 1
a156 2
		    ISSET(t->p_flag, P_SUGIDEXEC) ||
		    ISSET(t->p_flag, P_SUGID)) &&
d581 1
a581 2
	    ISSET(t->p_flag, P_SUGIDEXEC) ||
	    ISSET(t->p_flag, P_SUGID)) &&
@


1.46
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.45 2010/05/02 11:15:29 kettenis Exp $	*/
d175 1
a175 1
		if (t->p_pid != 1 && inferior(p, t))
d220 1
a220 1
		if (t->p_pptr != p)
d245 1
a245 1
		t->p_oppid = t->p_pptr->p_pid;
d390 2
a391 2
		if (t->p_oppid != t->p_pptr->p_pid) {
			struct proc *pp;
d393 2
a394 2
			pp = pfind(t->p_oppid);
			proc_reparent(t, pp ? pp : initproc);
d435 3
a437 3
		t->p_oppid = t->p_pptr->p_pid;
		if (t->p_pptr != p)
			proc_reparent(t, p);
@


1.45
log
@Use intermediate vaddr_t cast when casting a pointer to off_t.  Prevents
gcc4 from complaining about casting a pointer to an integer type of different
size.

ok guenther@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.44 2010/01/28 19:23:06 guenther Exp $	*/
a60 1
#include <sys/user.h>
@


1.44
log
@Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.43 2008/10/31 17:29:51 deraadt Exp $	*/
d264 1
a264 1
		uio.uio_offset = (off_t)(long)SCARG(uap, addr);
d282 1
a282 1
		uio.uio_offset = (off_t)(long)piod.piod_offs;
d644 1
a644 1
	uio.uio_offset = (off_t)PS_STRINGS;
d656 1
a656 1
	uiop->uio_offset += (off_t)(long)(pss.ps_envstr + pss.ps_nenvstr + 1);
d658 1
a658 1
	if (uiop->uio_offset < (off_t)PS_STRINGS)
d661 1
a661 1
	if (uiop->uio_offset > (off_t)PS_STRINGS)
d663 2
a664 2
	if ((uiop->uio_offset + uiop->uio_resid) > (off_t)PS_STRINGS)
		uiop->uio_resid = (off_t)PS_STRINGS - uiop->uio_offset;
@


1.43
log
@Do not assume that a pointer to another process will live over a set of
sleeping calls.  Since we are simply operating on another process'
vmspace, grab a (refcounted) copy of that pointer and use that instead.
Similar to the bug just fixed in sysctl_proc_args.
discussed with art
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.41 2008/10/31 17:15:30 deraadt Exp $	*/
d170 8
@


1.43.2.1
log
@Merge from -current:

----
Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
----

Requested by guenther@@. The hpux_compat change here is more
conservative than committed to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.43 2008/10/31 17:29:51 deraadt Exp $	*/
a169 8

		/*
		 *	(6) it's an ancestor of the current process and
		 *	    not init (because that would create a loop in
		 *	    the process graph).
		 */
		if (t->p_pid != 1 && inferior(p, t))
			return (EINVAL);
@


1.43.6.1
log
@Merge from -current:

----
Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
----

Requested by guenther@@. The hpux_compat change here is more
conservative than committed to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.43 2008/10/31 17:29:51 deraadt Exp $	*/
a169 8

		/*
		 *	(6) it's an ancestor of the current process and
		 *	    not init (because that would create a loop in
		 *	    the process graph).
		 */
		if (t->p_pid != 1 && inferior(p, t))
			return (EINVAL);
@


1.42
log
@accidental commit ... backout
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.40 2008/09/16 19:41:06 kettenis Exp $	*/
d592 1
d608 5
a612 2
	p->p_vmspace->vm_refcnt++;  /* XXX */
	error = uvm_io(&p->p_vmspace->vm_map, uio,
d614 2
a615 1
	uvmspace_free(p->p_vmspace);
@


1.41
log
@kern_sysctl.c
@
text
@a591 1
	struct vmspace *vm;
d607 2
a608 5

	vm = p->p_vmspace;
	vm->vm_refcnt++;

	error = uvm_io(&vm->vm_map, uio,
d610 1
a610 2

	uvmspace_free(vm);
@


1.40
log
@Add PIOD_READ_AUXV, a way to get the ELF auxilliary vector through ptrace(2).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.39 2007/04/10 17:47:55 miod Exp $	*/
d592 1
d608 5
a612 2
	p->p_vmspace->vm_refcnt++;  /* XXX */
	error = uvm_io(&p->p_vmspace->vm_map, uio,
d614 2
a615 1
	uvmspace_free(p->p_vmspace);
@


1.39
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.38 2007/03/15 10:22:30 art Exp $	*/
d54 1
d71 2
d295 13
d617 40
@


1.38
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.37 2006/11/29 12:24:18 miod Exp $	*/
d150 1
a150 1
		 *	process which revokes it's special privileges using
@


1.37
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.36 2006/07/19 18:38:42 grunk Exp $	*/
d234 1
a234 1
		SET(t->p_flag, P_TRACED);
d376 1
a376 1
		CLR(t->p_flag, P_TRACED|P_WAITED);
d411 1
a411 1
		SET(t->p_flag, P_TRACED);
@


1.36
log
@make kernels w/o PTRACE compile again.

help from mickey@@, "commit it" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.35 2006/05/18 21:27:24 miod Exp $	*/
a324 1
		PHOLD(t);
a337 1
		PRELE(t);
a356 1
		PHOLD(t);
a364 1
		PRELE(t);
a393 1
		PRELE(t);
a448 1
			PHOLD(p);
a449 1
			PRELE(p);
a458 1
		PHOLD(p);
a459 1
		PRELE(p);
a473 1
			PHOLD(p);
a474 1
			PRELE(p);
a485 1
		PHOLD(p);
a486 1
		PRELE(p);
a501 1
			PHOLD(p);
a502 1
			PRELE(p);
a513 1
		PHOLD(p);
a514 1
		PRELE(p);
@


1.35
log
@paramter -> parameter
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.34 2005/12/13 10:33:14 jsg Exp $	*/
d70 1
d551 1
@


1.34
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.33 2005/12/11 21:30:31 miod Exp $	*/
d325 1
a325 1
		/* If the address paramter is not (int *)1, set the pc. */
@


1.33
log
@Replace procfs_domem() with a similar interface, process_domem(), which lives
out of procfs and gets a ptrace request PT_{READ,WRITE}_{I,D} as argument;
also procfs_checkioperm() becomes process_checkioperm().

From art@@ some time ago; ok kettenis@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.32 2005/09/14 20:55:59 kettenis Exp $	*/
d74 1
a74 4
sys_ptrace(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
@


1.32
log
@ptrace(2) following fork(2)
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.31 2005/08/02 18:04:07 kettenis Exp $	*/
a69 2
#include <miscfs/procfs/procfs.h>

d102 1
d260 2
a261 1
		error = procfs_domem(p, t, NULL, &uio);
d278 4
d283 1
a283 1
		case PIOD_READ_I:
d286 4
d291 1
a291 1
		case PIOD_WRITE_I:
d297 1
a297 1
		error = procfs_domem(p, t, NULL, &uio);
d450 1
a450 1
		if ((error = procfs_checkioperm(p, t)) != 0)
d464 1
a464 1
		if ((error = procfs_checkioperm(p, t)) != 0)
d479 1
a479 1
		if ((error = procfs_checkioperm(p, t)) != 0)
d495 1
a495 1
		if ((error = procfs_checkioperm(p, t)) != 0)
d511 1
a511 1
		if ((error = procfs_checkioperm(p, t)) != 0)
d527 1
a527 1
		if ((error = procfs_checkioperm(p, t)) != 0)
d552 66
@


1.31
log
@Reduce stack usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.30 2005/04/16 22:19:28 kettenis Exp $	*/
d91 1
d183 3
d239 4
d377 2
d414 3
d419 20
@


1.30
log
@Remove regs and fpregs pseudo-files from procfs.
ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.29 2005/04/03 20:21:44 kettenis Exp $	*/
d57 1
d91 1
a91 1
	struct reg regs;
d93 1
a93 1
	struct fpreg fpregs;
d96 1
a96 1
	struct xmmregs xmmregs;
d412 8
a419 6
		error = copyin(SCARG(uap, addr), &regs, sizeof(regs));
		if (error)
			return (error);
		PHOLD(p);
		error = process_write_regs(t, &regs);
		PRELE(p);
d426 1
d428 1
a428 1
		error = process_read_regs(t, &regs);
d430 5
a434 3
		if (error)
			return (error);
		return (copyout(&regs, SCARG(uap, addr), sizeof (regs)));
d441 8
a448 6
		error = copyin(SCARG(uap, addr), &fpregs, sizeof(fpregs));
		if (error)
			return (error);
		PHOLD(p);
		error = process_write_fpregs(t, &fpregs);
		PRELE(p);
d457 1
d459 1
a459 1
		error = process_read_fpregs(t, &fpregs);
d461 5
a465 3
		if (error)
			return (error);
		return (copyout(&fpregs, SCARG(uap, addr), sizeof (fpregs)));
d473 8
a480 6
		error = copyin(SCARG(uap, addr), &xmmregs, sizeof(xmmregs));
		if (error)
			return (error);
		PHOLD(p);
		error = process_write_xmmregs(t, &xmmregs);
		PRELE(p);
d489 1
d491 1
a491 1
		error = process_read_xmmregs(t, &xmmregs);
d493 5
a497 3
		if (error)
			return (error);
		return (copyout(&xmmregs, SCARG(uap, addr), sizeof (xmmregs)));
@


1.29
log
@Implemente PT_[GS]ETXMMREGS ptrace(2) requests on i386.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.28 2004/06/13 21:49:26 niklas Exp $	*/
d90 4
d407 11
a417 1
		write = 1;
d419 10
a428 15
		/* write = 0 done above. */
		if (!procfs_validregs(t, NULL))
			return (EINVAL);
		else {
			iov.iov_base = SCARG(uap, addr);
			iov.iov_len = sizeof(struct reg);
			uio.uio_iov = &iov;
			uio.uio_iovcnt = 1;
			uio.uio_offset = 0;
			uio.uio_resid = sizeof(struct reg);
			uio.uio_segflg = UIO_USERSPACE;
			uio.uio_rw = write ? UIO_WRITE : UIO_READ;
			uio.uio_procp = p;
			return (procfs_doregs(p, t, NULL, &uio));
		}
d431 11
a441 1
		write = 1;
d445 10
a454 17
		/* write = 0 done above. */
#endif
#if defined(PT_SETFPREGS) || defined(PT_GETFPREGS)
		if (!procfs_validfpregs(t, NULL))
			return (EINVAL);
		else {
			iov.iov_base = SCARG(uap, addr);
			iov.iov_len = sizeof(struct fpreg);
			uio.uio_iov = &iov;
			uio.uio_iovcnt = 1;
			uio.uio_offset = 0;
			uio.uio_resid = sizeof(struct fpreg);
			uio.uio_segflg = UIO_USERSPACE;
			uio.uio_rw = write ? UIO_WRITE : UIO_READ;
			uio.uio_procp = p;
			return (procfs_dofpregs(p, t, NULL, &uio));
		}
d458 1
a458 3
		if (!procfs_validfpregs(t, NULL))
			return (EINVAL);

d472 1
a472 3
		if (!procfs_validfpregs(t, NULL))
			return (EINVAL);

@


1.28
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 3
d185 6
d443 31
@


1.27
log
@restored & repaired wcookie support; kettenis@@chello.nl
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.26 2003/08/15 20:32:18 tedu Exp $	*/
d60 1
d95 1
d358 1
d360 1
@


1.26
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.25 2003/06/02 23:28:06 millert Exp $	*/
d89 3
d180 3
d430 6
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.24 2003/03/09 01:33:59 millert Exp $	*/
d145 1
a145 1
		    (error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.24
log
@Disallow ptrace if P_SUGIDEXEC flag is set (we already disallow if P_SUGID
is set).  deraadt@@ and tholo@@ OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.23 2002/06/27 02:04:50 deraadt Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.23
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.22 2002/04/10 17:31:59 fgsch Exp $	*/
d140 5
a144 5
		 *      [Note: once P_SUGID gets set in execve(), it stays
		 *	set until the process does another execve(). Hence
		 *	this prevents a setuid process which revokes it's
		 *	special privilidges using setuid() from being
		 *	traced. This is good security.]
d147 1
@


1.22
log
@don't attach to system processes.
art@@ niklas@@ markus@@ millert@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.21 2002/03/12 14:37:40 art Exp $	*/
d147 1
a147 1
			ISSET(t->p_flag, P_SUGID)) &&
@


1.21
log
@Change the PT_IO interfaces like discussed on
the bsd-api-discuss list.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.20 2002/03/12 11:57:12 art Exp $	*/
d124 7
a130 1
		 *	(2) it's already being traced, or
d136 1
a136 1
		 *	(3) it's not owned by you, or the last exec
d152 1
a152 1
		 *	(4) ...it's init, which controls the security level
@


1.20
log
@In the PT_STEP case, first set the new pc, then arrange
for the single-step. This can slightly break the error handling when
setting the sstep fails, but allows us to emulate single stepping in
software on arch that don't have support for that in hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.19 2002/03/11 15:39:27 art Exp $	*/
d92 1
a94 1
	struct ptrace_io_desc piod;
d245 2
a246 2
		case PIOD_OP_READ_DATA:
		case PIOD_OP_READ_TEXT:
d249 2
a250 2
		case PIOD_OP_WRITE_DATA:
		case PIOD_OP_WRITE_TEXT:
d257 2
a258 1
		*retval = piod.piod_len - uio.uio_resid;
@


1.19
log
@Since all archs implement PT_GETREGS and PT_SETREGS, make then unoptional.
They still stay in MD code for backwards compatibility, but a check in
ptrace.h checks if they are defined.

Note - the same thing will be done with PT_{GET,SET}FPREGS once vax implements
 them and with PT_STEP when it's implemented by sparc, sparc64 and alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.18 2002/03/11 14:20:35 art Exp $	*/
d286 5
a298 5

		/* If the address paramter is not (int *)1, set the pc. */
		if ((int *)SCARG(uap, addr) != (int *)1)
			if ((error = process_set_pc(t, SCARG(uap, addr))) != 0)
				goto relebad;
@


1.18
log
@Add a more sane API for reading/writing traced process memory
with ptrace - PT_IO.
Man page update in a few.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.17 2002/01/30 20:45:35 nordin Exp $	*/
a165 1
#ifdef PT_GETREGS
a166 2
#endif
#ifdef PT_SETREGS
a167 1
#endif
a378 1
#ifdef PT_SETREGS
a380 2
#endif
#ifdef PT_GETREGS
a382 2
#endif
#if defined(PT_SETREGS) || defined(PT_GETREGS)
a396 2
#endif

@


1.17
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.16 2002/01/20 11:27:52 art Exp $	*/
d94 1
d159 1
d236 27
a262 1

@


1.16
log
@When a process is exec:ing mark it with a flag. Check that flag in ptrace
and procfs (and possibly more places in the future) and simply refuse to
fiddle with the execing process. This is an ugly hack, but this far we
haven't been successful in creating a race-free exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.15 2002/01/02 02:38:42 art Exp $	*/
a72 5

/* Macros to clear/set/test flags. */
#define	SET(t, f)	(t) |= (f)
#define	CLR(t, f)	(t) &= ~(f)
#define	ISSET(t, f)	((t) & (f))
@


1.15
log
@register_t is not an int, so don't use it that way.
Fixes PT_{READ,WRITE}_{I,D} on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.14 2001/11/06 19:53:20 miod Exp $	*/
d109 3
@


1.14
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.13 2001/06/27 04:49:47 art Exp $	*/
d98 1
d219 1
d223 1
a223 2
		iov.iov_base =
		    write ? (caddr_t)&SCARG(uap, data) : (caddr_t)retval;
d232 4
a235 1
		return (procfs_domem(p, t, NULL, &uio));
@


1.14.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.17 2002/01/30 20:45:35 nordin Exp $	*/
d74 5
a97 1
	int temp;
a108 3
	if ((t->p_flag & P_INEXEC) != 0)
		return (EAGAIN);

a217 1
		temp = SCARG(uap, data);
d221 2
a222 1
		iov.iov_base = (caddr_t)&temp;
d231 1
a231 4
		error = procfs_domem(p, t, NULL, &uio);
		if (write == 0)
			*retval = temp;
		return (error);
@


1.14.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.14.2.1 2002/01/31 22:55:41 niklas Exp $	*/
a91 1
	struct ptrace_io_desc piod;
d123 1
a123 7
		 *	(2) it's a system process
		 */
		if (ISSET(t->p_flag, P_SYSTEM))
			return (EPERM);

		/*
		 *	(3) it's already being traced, or
d129 1
a129 1
		 *	(4) it's not owned by you, or the last exec
d145 1
a145 1
		 *	(5) ...it's init, which controls the security level
a157 1
	case  PT_IO:
d164 1
d166 2
d169 1
d234 1
a234 28
	case  PT_IO:
		error = copyin(SCARG(uap, addr), &piod, sizeof(piod));
		if (error)
			return (error);
		iov.iov_base = piod.piod_addr;
		iov.iov_len = piod.piod_len;
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(long)piod.piod_offs;
		uio.uio_resid = piod.piod_len;
		uio.uio_segflg = UIO_USERSPACE;
		uio.uio_procp = p;
		switch (piod.piod_op) {
		case PIOD_READ_D:
		case PIOD_READ_I:
			uio.uio_rw = UIO_READ;
			break;
		case PIOD_WRITE_D:
		case PIOD_WRITE_I:
			uio.uio_rw = UIO_WRITE;
			break;
		default:
			return (EINVAL);
		}
		error = procfs_domem(p, t, NULL, &uio);
		piod.piod_len -= uio.uio_resid;
		(void) copyout(&piod, SCARG(uap, addr), sizeof(piod));
		return (error);
a261 5
		/* If the address paramter is not (int *)1, set the pc. */
		if ((int *)SCARG(uap, addr) != (int *)1)
			if ((error = process_set_pc(t, SCARG(uap, addr))) != 0)
				goto relebad;

d270 5
d355 1
d358 2
d362 2
d378 2
@


1.14.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.14.2.2 2002/06/11 03:29:40 art Exp $	*/
d147 1
a147 1
		    ISSET(t->p_flag, P_SUGID)) &&
@


1.14.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d140 5
a144 5
		 *      [Note: once P_SUGID or P_SUGIDEXEC gets set in
		 *	execve(), they stay set until the process does
		 *	another execve().  Hence this prevents a setuid
		 *	process which revokes it's special privileges using
		 *	setuid() from being traced.  This is good security.]
a146 1
		    ISSET(t->p_flag, P_SUGIDEXEC) ||
@


1.13
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.12 2001/06/18 09:01:52 art Exp $	*/
a67 1
#include <vm/vm.h>
@


1.13.2.1
log
@Pull in patch from current:
Errata 012:
A race condition between the ptrace(2) and execve(2) system
calls allows an attacker to modify the memory contents of
suid/sgid processes which could lead to compromise of the
super-user account.
Fix (art):
When a process is exec:ing mark it with a flag. Check that flag in ptrace
and procfs (and possibly more places in the future) and simply refuse to
fiddle with the execing process. This is an ugly hack, but this far we
haven't been successful in creating a race-free exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.13 2001/06/27 04:49:47 art Exp $	*/
a108 3

	if ((t->p_flag & P_INEXEC) != 0)
		return (EAGAIN);
@


1.12
log
@trace_req is not used anymore (was a nop).
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.11 2001/06/18 08:17:46 deraadt Exp $	*/
a67 1
#if defined(UVM)
a69 1
#endif
@


1.11
log
@split PT_DETACH handling, so that pc cannot be set by it; art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.10 2001/04/09 07:14:18 tholo Exp $	*/
a410 9
}

int
trace_req(a1)
	struct proc *a1;
{

	/* just return 1 to keep other parts of the system happy */
	return (1);
@


1.10
log
@Add emulation of Linux features to procfs; mostly from NetBSD.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.9 2000/11/10 15:33:10 provos Exp $	*/
a245 1
	case  PT_DETACH:
a262 1

d276 15
d292 13
d307 6
a312 12
		if (SCARG(uap, req) == PT_DETACH) {
			/* give process back to original parent or init */
			if (t->p_oppid != t->p_pptr->p_pid) {
				struct proc *pp;

				pp = pfind(t->p_oppid);
				proc_reparent(t, pp ? pp : initproc);
			}

			/* not being traced any more */
			t->p_oppid = 0;
			CLR(t->p_flag, P_TRACED|P_WAITED);
d314 4
@


1.10.2.1
log
@MFC, requested by art@@ some time ago:
When a process is exec:ing mark it with a flag. Check that flag in ptrace
and procfs (and possibly more places in the future) and simply refuse to
fiddle with the execing process. This is an ugly hack, but this far we
haven't been successful in creating a race-free exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.10 2001/04/09 07:14:18 tholo Exp $	*/
a110 3

	if ((t->p_flag & P_INEXEC) != 0)
		return (EAGAIN);
@


1.9
log
@seperate -> separate, okay aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.8 2000/06/08 22:25:24 niklas Exp $	*/
d341 1
a341 1
		if (!procfs_validregs(t))
d366 1
a366 1
		if (!procfs_validfpregs(t))
@


1.8
log
@Add explicit inclusions of signalvar.h to files actually using syms defined
there but relying on an indirect inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.8 2000/06/08 21:12:12 niklas Exp $	*/
d218 1
a218 1
	case  PT_WRITE_I:		/* XXX no seperate I and D spaces */
d221 1
a221 1
	case  PT_READ_I:		/* XXX no seperate I and D spaces */
@


1.7
log
@kmem allocation changes for uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.6 1998/06/27 07:32:13 deraadt Exp $	*/
d59 1
@


1.7.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.10 2001/04/09 07:14:18 tholo Exp $	*/
a58 1
#include <sys/signalvar.h>
d217 1
a217 1
	case  PT_WRITE_I:		/* XXX no separate I and D spaces */
d220 1
a220 1
	case  PT_READ_I:		/* XXX no separate I and D spaces */
d340 1
a340 1
		if (!procfs_validregs(t, NULL))
d365 1
a365 1
		if (!procfs_validfpregs(t, NULL))
@


1.7.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.7.6.1 2001/05/14 22:32:44 niklas Exp $	*/
d68 1
d71 1
d246 1
d264 1
a277 2
		PRELE(t);
		goto sendsig;
a278 26
	case  PT_DETACH:
		/*
		 * From the 4.4BSD PRM:
		 * "The data argument is taken as a signal number and the
		 * child's execution continues at location addr as if it
		 * incurred that signal.  Normally the signal number will
		 * be either 0 to indicate that the signal that caused the
		 * stop should be ignored, or that value fetched out of
		 * the process's image indicating which signal caused
		 * the stop.  If addr is (int *)1 then execution continues
		 * from where it stopped."
		 */

		/* Check that the data is a valid signal number or zero. */
		if (SCARG(uap, data) < 0 || SCARG(uap, data) >= NSIG)
			return (EINVAL);

		PHOLD(t);
#ifdef PT_STEP
		/*
		 * Arrange for a single-step, if that's requested and possible.
		 */
		error = process_sstep(t, SCARG(uap, req) == PT_STEP);
		if (error)
			goto relebad;
#endif
d281 12
a292 6
		/* give process back to original parent or init */
		if (t->p_oppid != t->p_pptr->p_pid) {
			struct proc *pp;

			pp = pfind(t->p_oppid);
			proc_reparent(t, pp ? pp : initproc);
a294 4
		/* not being traced any more */
		t->p_oppid = 0;
		CLR(t->p_flag, P_TRACED|P_WAITED);

d387 9
@


1.7.6.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 1
@


1.7.6.4
log
@Merge in trunk
@
text
@d74 5
a97 1
	int temp;
a108 3
	if ((t->p_flag & P_INEXEC) != 0)
		return (EAGAIN);

a217 1
		temp = SCARG(uap, data);
d221 2
a222 1
		iov.iov_base = (caddr_t)&temp;
d231 1
a231 4
		error = procfs_domem(p, t, NULL, &uio);
		if (write == 0)
			*retval = temp;
		return (error);
@


1.7.6.5
log
@Merge in -current from about a week ago
@
text
@a91 1
	struct ptrace_io_desc piod;
a157 1
	case  PT_IO:
d164 1
d166 2
d169 1
d234 1
a234 28
	case  PT_IO:
		error = copyin(SCARG(uap, addr), &piod, sizeof(piod));
		if (error)
			return (error);
		iov.iov_base = piod.piod_addr;
		iov.iov_len = piod.piod_len;
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(long)piod.piod_offs;
		uio.uio_resid = piod.piod_len;
		uio.uio_segflg = UIO_USERSPACE;
		uio.uio_procp = p;
		switch (piod.piod_op) {
		case PIOD_READ_D:
		case PIOD_READ_I:
			uio.uio_rw = UIO_READ;
			break;
		case PIOD_WRITE_D:
		case PIOD_WRITE_I:
			uio.uio_rw = UIO_WRITE;
			break;
		default:
			return (EINVAL);
		}
		error = procfs_domem(p, t, NULL, &uio);
		piod.piod_len -= uio.uio_resid;
		(void) copyout(&piod, SCARG(uap, addr), sizeof(piod));
		return (error);
a261 5
		/* If the address paramter is not (int *)1, set the pc. */
		if ((int *)SCARG(uap, addr) != (int *)1)
			if ((error = process_set_pc(t, SCARG(uap, addr))) != 0)
				goto relebad;

d270 5
d355 1
d358 2
d362 2
d378 2
@


1.7.6.6
log
@Sync the SMP branch with 3.3
@
text
@d124 1
a124 7
		 *	(2) it's a system process
		 */
		if (ISSET(t->p_flag, P_SYSTEM))
			return (EPERM);

		/*
		 *	(3) it's already being traced, or
d130 1
a130 1
		 *	(4) it's not owned by you, or the last exec
d134 5
a138 5
		 *      [Note: once P_SUGID or P_SUGIDEXEC gets set in
		 *	execve(), they stay set until the process does
		 *	another execve().  Hence this prevents a setuid
		 *	process which revokes it's special privileges using
		 *	setuid() from being traced.  This is good security.]
d141 1
a141 2
		    ISSET(t->p_flag, P_SUGIDEXEC) ||
		    ISSET(t->p_flag, P_SUGID)) &&
d146 1
a146 1
		 *	(5) ...it's init, which controls the security level
@


1.7.6.7
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.7.6.6 2003/03/28 00:41:27 niklas Exp $	*/
a94 1
	int s;
a353 1
			SCHED_LOCK(s);
a354 1
			SCHED_UNLOCK(s);
@


1.7.6.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.7.6.7 2003/05/15 04:08:02 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.6.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d146 1
a146 1
		    (error = suser(p, 0)) != 0)
@


1.7.6.10
log
@Merge with the trunk
@
text
@a88 3
#ifdef PT_WCOOKIE
	register_t wcookie;
#endif
a177 3
#ifdef PT_WCOOKIE
	case  PT_WCOOKIE:
#endif
a426 6
#endif
#ifdef PT_WCOOKIE
	case  PT_WCOOKIE:
		wcookie = process_get_wcookie (t);
		return (copyout(&wcookie, SCARG(uap, addr),
		    sizeof (register_t)));
@


1.7.6.11
log
@few fixes to make non-smp compile
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.7.6.10 2004/06/05 23:13:02 niklas Exp $	*/
a59 1
#include <sys/sched.h>
@


1.6
log
@securelevels do NOT protect running binaries; only filesystem activity
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.4 1996/07/29 14:51:41 deraadt Exp $	*/
d66 5
@


1.5
log
@do not permit ptrace attach to immutable executable
@
text
@a61 2
#include <sys/vnode.h>
#include <sys/stat.h>
a93 1
	struct vattr va;
a148 6
			return (EPERM);

		error = VOP_GETATTR(t->p_textvp, &va, p->p_ucred, p);
		if (error)
			return (error);
		if (va.va_flags & IMMUTABLE)
@


1.4
log
@comment on ptrace & P_SUGID
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_process.c,v 1.3 1996/05/22 11:52:32 deraadt Exp $	*/
d62 2
d96 1
d152 6
@


1.3
log
@fix obscure problem involving ptrace of init
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d127 9
a135 2
		 *	(3) it's not owned by you, or is set-id on exec
		 *	    (unless you're root), or...
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d2 1
a2 1
/*	$NetBSD: sys_process.c,v 1.54 1996/02/09 19:00:14 christos Exp $	*/
d100 1
d128 1
a128 1
		 *	    (unless you're root).
d134 9
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: sys_process.c,v 1.52 1995/10/07 06:28:36 mycroft Exp $	*/
d69 2
d246 2
a247 1
		if (error = process_sstep(t, SCARG(uap, req) == PT_STEP))
d253 1
a253 1
			if (error = process_set_pc(t, SCARG(uap, addr)))
d363 1
d366 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
