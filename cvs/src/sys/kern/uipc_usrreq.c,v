head	1.119;
access;
symbols
	OPENBSD_6_2_BASE:1.119
	OPENBSD_6_1:1.117.0.4
	OPENBSD_6_1_BASE:1.117
	OPENBSD_6_0:1.100.0.2
	OPENBSD_6_0_BASE:1.100
	OPENBSD_5_9:1.95.0.2
	OPENBSD_5_9_BASE:1.95
	OPENBSD_5_8:1.83.0.4
	OPENBSD_5_8_BASE:1.83
	OPENBSD_5_7:1.79.0.2
	OPENBSD_5_7_BASE:1.79
	OPENBSD_5_6:1.76.0.4
	OPENBSD_5_6_BASE:1.76
	OPENBSD_5_5:1.72.0.4
	OPENBSD_5_5_BASE:1.72
	OPENBSD_5_4:1.71.0.2
	OPENBSD_5_4_BASE:1.71
	OPENBSD_5_3:1.69.0.2
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.66.0.2
	OPENBSD_5_2_BASE:1.66
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.4
	OPENBSD_5_0:1.55.0.2
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.49.0.2
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.45.0.4
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.6
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.34.0.4
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.22
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.8
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.6
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.4
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.119
date	2017.08.11.19.53.02;	author bluhm;	state Exp;
branches;
next	1.118;
commitid	ZSLEQCt6cCaCd9uI;

1.118
date	2017.06.26.09.32.31;	author mpi;	state Exp;
branches;
next	1.117;
commitid	gZMpLuRopIsWa0cT;

1.117
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.116;
commitid	ZsxSSZJSFxZH81LL;

1.116
date	2017.02.14.09.46.21;	author mpi;	state Exp;
branches;
next	1.115;
commitid	4bln7omqWkS0RJo9;

1.115
date	2017.02.09.11.18.55;	author mpi;	state Exp;
branches;
next	1.114;
commitid	Hm0H5Q7sfjFqJyvk;

1.114
date	2017.02.09.10.40.57;	author mpi;	state Exp;
branches;
next	1.113;
commitid	NT70zzZm0C7cEEin;

1.113
date	2017.01.27.20.31.42;	author bluhm;	state Exp;
branches;
next	1.112;
commitid	iyCOWv2EkHfmOzpr;

1.112
date	2017.01.25.06.15.50;	author mpi;	state Exp;
branches;
next	1.111;
commitid	X7Hk1efefaYrWlw3;

1.111
date	2017.01.24.04.09.59;	author deraadt;	state Exp;
branches;
next	1.110;
commitid	zUYmRLEGzx1xH8Zk;

1.110
date	2017.01.23.23.44.04;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	fnkGGZuISh6m65vf;

1.109
date	2016.12.29.12.12.43;	author mpi;	state Exp;
branches;
next	1.108;
commitid	RhxGXGNe4WuNtTZs;

1.108
date	2016.12.29.07.35.09;	author mpi;	state Exp;
branches;
next	1.107;
commitid	ONGiehQKBzZJ18Ht;

1.107
date	2016.12.22.15.15.28;	author mpi;	state Exp;
branches;
next	1.106;
commitid	0uLvTq9TOOw9qc5H;

1.106
date	2016.12.22.13.30.09;	author mpi;	state Exp;
branches;
next	1.105;
commitid	VPGQLX2tqvZpLX4H;

1.105
date	2016.12.22.01.52.40;	author visa;	state Exp;
branches;
next	1.104;
commitid	QRyYBICwV6ebvBDr;

1.104
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.103;
commitid	QqHqT2WhCBWqYgGJ;

1.103
date	2016.11.29.10.22.30;	author jsg;	state Exp;
branches;
next	1.102;
commitid	ZQetSMB5ilG2z10X;

1.102
date	2016.08.26.07.12.30;	author guenther;	state Exp;
branches;
next	1.101;
commitid	xkPYiAs1DSWWJj7t;

1.101
date	2016.08.17.13.53.14;	author bluhm;	state Exp;
branches;
next	1.100;
commitid	VicvrrGUF4bIRjc3;

1.100
date	2016.07.19.05.30.48;	author tedu;	state Exp;
branches;
next	1.99;
commitid	FKUdJBjDGQ8bsk5L;

1.99
date	2016.07.12.14.28.02;	author tedu;	state Exp;
branches;
next	1.98;
commitid	rhyhhI7Q1kIybPEJ;

1.98
date	2016.07.12.13.19.14;	author deraadt;	state Exp;
branches;
next	1.97;
commitid	Wq1Rm71N2p3jXqPr;

1.97
date	2016.04.25.20.18.31;	author tedu;	state Exp;
branches;
next	1.96;
commitid	AL2KSeDZVXs2nAYI;

1.96
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.95;
commitid	gAjwyca5TfuoJAhn;

1.95
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches
	1.95.2.1;
next	1.94;
commitid	Cl55DD2g2xm69E6W;

1.94
date	2015.11.03.20.33.30;	author deraadt;	state Exp;
branches;
next	1.93;
commitid	9Yd0qonu8m6gAWJX;

1.93
date	2015.11.02.16.31.55;	author semarie;	state Exp;
branches;
next	1.92;
commitid	PyvdcQVr9G4daVnG;

1.92
date	2015.11.01.19.03.33;	author semarie;	state Exp;
branches;
next	1.91;
commitid	VKRkUfXZQNJ8UQeY;

1.91
date	2015.11.01.13.49.00;	author deraadt;	state Exp;
branches;
next	1.90;
commitid	UX7SMDZ0kBn0Thzs;

1.90
date	2015.10.25.20.39.54;	author deraadt;	state Exp;
branches;
next	1.89;
commitid	SIwCBDJKKae61tEi;

1.89
date	2015.10.18.20.15.10;	author deraadt;	state Exp;
branches;
next	1.88;
commitid	Nk95LvaVIfrgXtf6;

1.88
date	2015.10.17.23.15.10;	author deraadt;	state Exp;
branches;
next	1.87;
commitid	ptBJqTXoS2r6ChsK;

1.87
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.86;
commitid	av6ZVErLSWkVP5Zz;

1.86
date	2015.08.29.21.10.20;	author deraadt;	state Exp;
branches;
next	1.85;
commitid	r3RQ1BKb3glRar6Y;

1.85
date	2015.08.28.04.38.47;	author guenther;	state Exp;
branches;
next	1.84;
commitid	plAZIJHa0HKzn8y4;

1.84
date	2015.08.22.20.18.50;	author deraadt;	state Exp;
branches;
next	1.83;
commitid	6NDuzTPjBp2GqkfQ;

1.83
date	2015.07.28.14.20.10;	author bluhm;	state Exp;
branches;
next	1.82;
commitid	6VWflVEq4Wv8kTOL;

1.82
date	2015.07.18.15.00.01;	author guenther;	state Exp;
branches;
next	1.81;
commitid	roluigiGALHjIxXb;

1.81
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.80;
commitid	J4OPNuggl4DOKGzM;

1.80
date	2015.03.28.23.50.55;	author bluhm;	state Exp;
branches;
next	1.79;
commitid	kVBWJiCghZrzYhp3;

1.79
date	2014.12.11.19.21.57;	author tedu;	state Exp;
branches;
next	1.78;
commitid	KtikWduHBwfG1emb;

1.78
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	3SGDR5EjcwE01W8S;

1.77
date	2014.08.31.01.42.36;	author guenther;	state Exp;
branches;
next	1.76;
commitid	zF5A8BuuSSyqaDyM;

1.76
date	2014.07.13.15.52.38;	author tedu;	state Exp;
branches;
next	1.75;
commitid	iyde0xIVfkKugN9I;

1.75
date	2014.07.13.15.29.04;	author tedu;	state Exp;
branches;
next	1.74;
commitid	bFFVdS3JEaMhyZxJ;

1.74
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.73;
commitid	QlVV51SZgNFxsXxC;

1.73
date	2014.03.18.06.59.00;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2014.01.24.06.00.01;	author guenther;	state Exp;
branches;
next	1.71;

1.71
date	2013.04.05.08.25.30;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2013.03.30.06.32.25;	author tedu;	state Exp;
branches;
next	1.69;

1.69
date	2012.10.12.20.45.49;	author guenther;	state Exp;
branches;
next	1.68;

1.68
date	2012.09.02.05.20.17;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2012.08.23.00.11.56;	author guenther;	state Exp;
branches;
next	1.66;

1.66
date	2012.04.26.17.18.17;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	2012.04.23.15.36.07;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	2012.04.14.09.42.32;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2012.04.14.09.07.42;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2012.04.14.08.47.27;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2012.04.13.19.22.18;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2012.04.13.19.18.58;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2012.04.13.19.16.11;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2012.04.13.19.12.44;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2012.04.13.09.38.32;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2012.04.11.14.08.27;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2011.07.06.06.31.38;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.06.06.26.14;	author guenther;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.05.23.06.43;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2011.06.28.10.15.38;	author thib;	state Exp;
branches;
next	1.51;

1.51
date	2011.05.17.00.17.01;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2011.04.04.12.44.10;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2010.10.18.04.31.01;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.02.00.11.39;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.01.17.20.48;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.30.19.57.05;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2009.02.22.07.47.22;	author otto;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.29.22.08.45;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.42;

1.42
date	2008.04.15.19.01.45;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2008.04.10.17.50.46;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2008.04.08.20.47.55;	author stefan;	state Exp;
branches;
next	1.39;

1.39
date	2008.04.02.19.09.13;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2008.03.24.16.07.37;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.28.16.56.46;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.29.18.36.00;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.17.08.33.20;	author claudio;	state Exp;
branches;
next	1.32;

1.32
date	2006.10.31.16.24.55;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.27.23.38.11;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.05.05.05.07;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.17.21.43.08;	author fgsch;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2004.07.22.06.13.08;	author tedu;	state Exp;
branches
	1.28.4.1;
next	1.27;

1.27
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.01.23.56.05;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.06.04.18.18;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.17.22.59.42;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.28.07;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.23.15.33.12;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.27.05;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.19.23.14.59;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.11.12.35.53;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.08.13.53.28;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.05.16.02.27;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.02.16.05.58;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.26.12.03.27;	author art;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.10.26.10.39.31;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.26.19.56.52;	author dugsong;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.06.04.42.07;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	99.10.11.19.49.39;	author deraadt;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	99.02.05.04.14.19;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	98.03.01.19.34.15;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.11.17.18.09.15;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.58.25;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.20.06;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.12.33;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.06.05.08.13.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.06.25.21.26.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.20.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.47;	author deraadt;	state Exp;
branches;
next	;

1.11.4.1
date	2001.05.14.22.32.45;	author niklas;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2001.07.04.10.48.46;	author niklas;	state Exp;
branches;
next	1.11.4.3;

1.11.4.3
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.11.4.4;

1.11.4.4
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.11.4.5;

1.11.4.5
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.11.4.6;

1.11.4.6
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.11.4.7;

1.11.4.7
date	2003.06.07.11.03.41;	author ho;	state Exp;
branches;
next	1.11.4.8;

1.11.4.8
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	1.11.4.9;

1.11.4.9
date	2004.06.05.23.13.03;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	;

1.28.4.1
date	2006.03.04.03.18.05;	author brad;	state Exp;
branches;
next	;

1.29.2.1
date	2006.03.04.03.04.00;	author brad;	state Exp;
branches;
next	;

1.95.2.1
date	2016.07.14.03.08.33;	author tedu;	state Exp;
branches;
next	;
commitid	WPzRs4FzG7jbt3Mp;


desc
@@


1.119
log
@Validate sockaddr from userland in central functions.  This results
in common checks for unix, inet, inet6 instead of partial checks
here and there.  Some checks are already done at a higher layer,
but better be paranoid with user input.
OK claudio@@ millert@@
@
text
@/*	$OpenBSD: uipc_usrreq.c,v 1.118 2017/06/26 09:32:31 mpi Exp $	*/
/*	$NetBSD: uipc_usrreq.c,v 1.18 1996/02/09 19:00:50 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)uipc_usrreq.c	8.3 (Berkeley) 1/4/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/filedesc.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/unpcb.h>
#include <sys/un.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/mbuf.h>
#include <sys/task.h>
#include <sys/pledge.h>

void	uipc_setaddr(const struct unpcb *, struct mbuf *);

/* list of all UNIX domain sockets, for unp_gc() */
LIST_HEAD(unp_head, unpcb) unp_head = LIST_HEAD_INITIALIZER(unp_head);

/*
 * Stack of sets of files that were passed over a socket but were
 * not received and need to be closed.
 */
struct	unp_deferral {
	SLIST_ENTRY(unp_deferral)	ud_link;
	int	ud_n;
	/* followed by ud_n struct fdpass */
	struct fdpass ud_fp[];
};

void	unp_discard(struct fdpass *, int);
void	unp_mark(struct fdpass *, int);
void	unp_scan(struct mbuf *, void (*)(struct fdpass *, int));
int	unp_nam2sun(struct mbuf *, struct sockaddr_un **, size_t *);

/* list of sets of files that were sent over sockets that are now closed */
SLIST_HEAD(,unp_deferral) unp_deferred = SLIST_HEAD_INITIALIZER(unp_deferred);

struct task unp_gc_task = TASK_INITIALIZER(unp_gc, NULL);


/*
 * Unix communications domain.
 *
 * TODO:
 *	RDM
 *	rethink name space problems
 *	need a proper out-of-band
 */
struct	sockaddr sun_noname = { sizeof(sun_noname), AF_UNIX };
ino_t	unp_ino;			/* prototype for fake inode numbers */

void
uipc_setaddr(const struct unpcb *unp, struct mbuf *nam)
{
	if (unp != NULL && unp->unp_addr != NULL) {
		nam->m_len = unp->unp_addr->m_len;
		memcpy(mtod(nam, caddr_t), mtod(unp->unp_addr, caddr_t),
		    nam->m_len);
	} else {
		nam->m_len = sizeof(sun_noname);
		memcpy(mtod(nam, struct sockaddr *), &sun_noname,
		    nam->m_len);
	}
}

int
uipc_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
    struct mbuf *control, struct proc *p)
{
	struct unpcb *unp = sotounpcb(so);
	struct socket *so2;
	int error = 0;

	if (req == PRU_CONTROL)
		return (EOPNOTSUPP);
	if (req != PRU_SEND && control && control->m_len) {
		error = EOPNOTSUPP;
		goto release;
	}
	if (unp == NULL) {
		error = EINVAL;
		goto release;
	}

	NET_ASSERT_UNLOCKED();

	switch (req) {

	case PRU_DETACH:
		unp_detach(unp);
		break;

	case PRU_BIND:
		error = unp_bind(unp, nam, p);
		break;

	case PRU_LISTEN:
		if (unp->unp_vnode == NULL)
			error = EINVAL;
		break;

	case PRU_CONNECT:
		error = unp_connect(so, nam, p);
		break;

	case PRU_CONNECT2:
		error = unp_connect2(so, (struct socket *)nam);
		break;

	case PRU_DISCONNECT:
		unp_disconnect(unp);
		break;

	case PRU_ACCEPT:
		/*
		 * Pass back name of connected socket,
		 * if it was bound and we are still connected
		 * (our peer may have closed already!).
		 */
		uipc_setaddr(unp->unp_conn, nam);
		break;

	case PRU_SHUTDOWN:
		socantsendmore(so);
		unp_shutdown(unp);
		break;

	case PRU_RCVD:
		switch (so->so_type) {

		case SOCK_DGRAM:
			panic("uipc 1");
			/*NOTREACHED*/

		case SOCK_STREAM:
		case SOCK_SEQPACKET:
#define	rcv (&so->so_rcv)
#define snd (&so2->so_snd)
			if (unp->unp_conn == NULL)
				break;
			so2 = unp->unp_conn->unp_socket;
			/*
			 * Adjust backpressure on sender
			 * and wakeup any waiting to write.
			 */
			snd->sb_mbcnt = rcv->sb_mbcnt;
			snd->sb_cc = rcv->sb_cc;
			sowwakeup(so2);
#undef snd
#undef rcv
			break;

		default:
			panic("uipc 2");
		}
		break;

	case PRU_SEND:
		if (control && (error = unp_internalize(control, p)))
			break;
		switch (so->so_type) {

		case SOCK_DGRAM: {
			struct sockaddr *from;

			if (nam) {
				if (unp->unp_conn) {
					error = EISCONN;
					break;
				}
				error = unp_connect(so, nam, p);
				if (error)
					break;
			} else {
				if (unp->unp_conn == NULL) {
					error = ENOTCONN;
					break;
				}
			}
			so2 = unp->unp_conn->unp_socket;
			if (unp->unp_addr)
				from = mtod(unp->unp_addr, struct sockaddr *);
			else
				from = &sun_noname;
			if (sbappendaddr(so2, &so2->so_rcv, from, m, control)) {
				sorwakeup(so2);
				m = NULL;
				control = NULL;
			} else
				error = ENOBUFS;
			if (nam)
				unp_disconnect(unp);
			break;
		}

		case SOCK_STREAM:
		case SOCK_SEQPACKET:
#define	rcv (&so2->so_rcv)
#define	snd (&so->so_snd)
			if (so->so_state & SS_CANTSENDMORE) {
				error = EPIPE;
				break;
			}
			if (unp->unp_conn == NULL) {
				error = ENOTCONN;
				break;
			}
			so2 = unp->unp_conn->unp_socket;
			/*
			 * Send to paired receive port, and then raise
			 * send buffer counts to maintain backpressure.
			 * Wake up readers.
			 */
			if (control) {
				if (sbappendcontrol(so2, rcv, m, control))
					control = NULL;
				else {
					error = ENOBUFS;
					break;
				}
			} else if (so->so_type == SOCK_SEQPACKET)
				sbappendrecord(so2, rcv, m);
			else
				sbappend(so2, rcv, m);
			snd->sb_mbcnt = rcv->sb_mbcnt;
			snd->sb_cc = rcv->sb_cc;
			sorwakeup(so2);
			m = NULL;
#undef snd
#undef rcv
			break;

		default:
			panic("uipc 4");
		}
		/* we need to undo unp_internalize in case of errors */
		if (control && error)
			unp_dispose(control);
		break;

	case PRU_ABORT:
		unp_drop(unp, ECONNABORTED);
		break;

	case PRU_SENSE: {
		struct stat *sb = (struct stat *)m;

		sb->st_blksize = so->so_snd.sb_hiwat;
		sb->st_dev = NODEV;
		if (unp->unp_ino == 0)
			unp->unp_ino = unp_ino++;
		sb->st_atim.tv_sec =
		    sb->st_mtim.tv_sec =
		    sb->st_ctim.tv_sec = unp->unp_ctime.tv_sec;
		sb->st_atim.tv_nsec =
		    sb->st_mtim.tv_nsec =
		    sb->st_ctim.tv_nsec = unp->unp_ctime.tv_nsec;
		sb->st_ino = unp->unp_ino;
		return (0);
	}

	case PRU_RCVOOB:
		return (EOPNOTSUPP);

	case PRU_SENDOOB:
		error = EOPNOTSUPP;
		break;

	case PRU_SOCKADDR:
		uipc_setaddr(unp, nam);
		break;

	case PRU_PEERADDR:
		uipc_setaddr(unp->unp_conn, nam);
		break;

	case PRU_SLOWTIMO:
		break;

	default:
		panic("piusrreq");
	}
release:
	m_freem(control);
	m_freem(m);
	return (error);
}

/*
 * Both send and receive buffers are allocated PIPSIZ bytes of buffering
 * for stream sockets, although the total for sender and receiver is
 * actually only PIPSIZ.
 * Datagram sockets really use the sendspace as the maximum datagram size,
 * and don't really want to reserve the sendspace.  Their recvspace should
 * be large enough for at least one max-size datagram plus address.
 */
#define	PIPSIZ	4096
u_long	unpst_sendspace = PIPSIZ;
u_long	unpst_recvspace = PIPSIZ;
u_long	unpdg_sendspace = 2*1024;	/* really max datagram size */
u_long	unpdg_recvspace = 4*1024;

int	unp_rights;			/* file descriptors in flight */

int
uipc_attach(struct socket *so, int proto)
{
	struct unpcb *unp;
	int error;
	
	if (so->so_pcb)
		return EISCONN;
	if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) {
		switch (so->so_type) {

		case SOCK_STREAM:
		case SOCK_SEQPACKET:
			error = soreserve(so, unpst_sendspace, unpst_recvspace);
			break;

		case SOCK_DGRAM:
			error = soreserve(so, unpdg_sendspace, unpdg_recvspace);
			break;

		default:
			panic("unp_attach");
		}
		if (error)
			return (error);
	}
	unp = malloc(sizeof(*unp), M_PCB, M_NOWAIT|M_ZERO);
	if (unp == NULL)
		return (ENOBUFS);
	unp->unp_socket = so;
	so->so_pcb = unp;
	getnanotime(&unp->unp_ctime);
	LIST_INSERT_HEAD(&unp_head, unp, unp_link);
	return (0);
}

void
unp_detach(struct unpcb *unp)
{
	struct vnode *vp;

	LIST_REMOVE(unp, unp_link);
	if (unp->unp_vnode) {
		unp->unp_vnode->v_socket = NULL;
		vp = unp->unp_vnode;
		unp->unp_vnode = NULL;
		vrele(vp);
	}
	if (unp->unp_conn)
		unp_disconnect(unp);
	while (!SLIST_EMPTY(&unp->unp_refs))
		unp_drop(SLIST_FIRST(&unp->unp_refs), ECONNRESET);
	soisdisconnected(unp->unp_socket);
	unp->unp_socket->so_pcb = NULL;
	m_freem(unp->unp_addr);
	free(unp, M_PCB, sizeof *unp);
	if (unp_rights)
		task_add(systq, &unp_gc_task);
}

int
unp_bind(struct unpcb *unp, struct mbuf *nam, struct proc *p)
{
	struct sockaddr_un *soun;
	struct mbuf *nam2;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;
	size_t pathlen;

	if (unp->unp_vnode != NULL)
		return (EINVAL);
	if ((error = unp_nam2sun(nam, &soun, &pathlen)))
		return (error);

	nam2 = m_getclr(M_WAITOK, MT_SONAME);
	nam2->m_len = sizeof(struct sockaddr_un);
	memcpy(mtod(nam2, struct sockaddr_un *), soun,
	    offsetof(struct sockaddr_un, sun_path) + pathlen);
	/* No need to NUL terminate: m_getclr() returns zero'd mbufs. */

	soun = mtod(nam2, struct sockaddr_un *);

	/* Fixup sun_len to keep it in sync with m_len. */
	soun->sun_len = nam2->m_len;

	NDINIT(&nd, CREATE, NOFOLLOW | LOCKPARENT, UIO_SYSSPACE,
	    soun->sun_path, p);
	nd.ni_pledge = PLEDGE_UNIX;
/* SHOULD BE ABLE TO ADOPT EXISTING AND wakeup() ALA FIFO's */
	if ((error = namei(&nd)) != 0) {
		m_freem(nam2);
		return (error);
	}
	vp = nd.ni_vp;
	if (vp != NULL) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vrele(vp);
		m_freem(nam2);
		return (EADDRINUSE);
	}
	VATTR_NULL(&vattr);
	vattr.va_type = VSOCK;
	vattr.va_mode = ACCESSPERMS &~ p->p_fd->fd_cmask;
	error = VOP_CREATE(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &vattr);
	if (error) {
		m_freem(nam2);
		return (error);
	}
	unp->unp_addr = nam2;
	vp = nd.ni_vp;
	vp->v_socket = unp->unp_socket;
	unp->unp_vnode = vp;
	unp->unp_connid.uid = p->p_ucred->cr_uid;
	unp->unp_connid.gid = p->p_ucred->cr_gid;
	unp->unp_connid.pid = p->p_p->ps_pid;
	unp->unp_flags |= UNP_FEIDSBIND;
	VOP_UNLOCK(vp, p);
	return (0);
}

int
unp_connect(struct socket *so, struct mbuf *nam, struct proc *p)
{
	struct sockaddr_un *soun;
	struct vnode *vp;
	struct socket *so2, *so3;
	struct unpcb *unp, *unp2, *unp3;
	struct nameidata nd;
	int error;

	if ((error = unp_nam2sun(nam, &soun, NULL)))
		return (error);

	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_SYSSPACE, soun->sun_path, p);
	nd.ni_pledge = PLEDGE_UNIX;
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if (vp->v_type != VSOCK) {
		error = ENOTSOCK;
		goto bad;
	}
	if ((error = VOP_ACCESS(vp, VWRITE, p->p_ucred, p)) != 0)
		goto bad;
	so2 = vp->v_socket;
	if (so2 == NULL) {
		error = ECONNREFUSED;
		goto bad;
	}
	if (so->so_type != so2->so_type) {
		error = EPROTOTYPE;
		goto bad;
	}
	if (so->so_proto->pr_flags & PR_CONNREQUIRED) {
		if ((so2->so_options & SO_ACCEPTCONN) == 0 ||
		    (so3 = sonewconn(so2, 0)) == 0) {
			error = ECONNREFUSED;
			goto bad;
		}
		unp = sotounpcb(so);
		unp2 = sotounpcb(so2);
		unp3 = sotounpcb(so3);
		if (unp2->unp_addr)
			unp3->unp_addr =
			    m_copym(unp2->unp_addr, 0, M_COPYALL, M_NOWAIT);
		unp3->unp_connid.uid = p->p_ucred->cr_uid;
		unp3->unp_connid.gid = p->p_ucred->cr_gid;
		unp3->unp_connid.pid = p->p_p->ps_pid;
		unp3->unp_flags |= UNP_FEIDS;
		so2 = so3;
		if (unp2->unp_flags & UNP_FEIDSBIND) {
			unp->unp_connid = unp2->unp_connid;
			unp->unp_flags |= UNP_FEIDS;
		}
	}
	error = unp_connect2(so, so2);
bad:
	vput(vp);
	return (error);
}

int
unp_connect2(struct socket *so, struct socket *so2)
{
	struct unpcb *unp = sotounpcb(so);
	struct unpcb *unp2;

	if (so2->so_type != so->so_type)
		return (EPROTOTYPE);
	unp2 = sotounpcb(so2);
	unp->unp_conn = unp2;
	switch (so->so_type) {

	case SOCK_DGRAM:
		SLIST_INSERT_HEAD(&unp2->unp_refs, unp, unp_nextref);
		soisconnected(so);
		break;

	case SOCK_STREAM:
	case SOCK_SEQPACKET:
		unp2->unp_conn = unp;
		soisconnected(so);
		soisconnected(so2);
		break;

	default:
		panic("unp_connect2");
	}
	return (0);
}

void
unp_disconnect(struct unpcb *unp)
{
	struct unpcb *unp2 = unp->unp_conn;

	if (unp2 == NULL)
		return;
	unp->unp_conn = NULL;
	switch (unp->unp_socket->so_type) {

	case SOCK_DGRAM:
		SLIST_REMOVE(&unp2->unp_refs, unp, unpcb, unp_nextref);
		unp->unp_socket->so_state &= ~SS_ISCONNECTED;
		break;

	case SOCK_STREAM:
	case SOCK_SEQPACKET:
		unp->unp_socket->so_snd.sb_mbcnt = 0;
		unp->unp_socket->so_snd.sb_cc = 0;
		soisdisconnected(unp->unp_socket);
		unp2->unp_conn = NULL;
		unp2->unp_socket->so_snd.sb_mbcnt = 0;
		unp2->unp_socket->so_snd.sb_cc = 0;
		soisdisconnected(unp2->unp_socket);
		break;
	}
}

void
unp_shutdown(struct unpcb *unp)
{
	struct socket *so;

	switch (unp->unp_socket->so_type) {
	case SOCK_STREAM:
	case SOCK_SEQPACKET:
		if (unp->unp_conn && (so = unp->unp_conn->unp_socket))
			socantrcvmore(so);
		break;
	default:
		break;
	}
}

void
unp_drop(struct unpcb *unp, int errno)
{
	struct socket *so = unp->unp_socket;

	so->so_error = errno;
	unp_disconnect(unp);
	if (so->so_head) {
		so->so_pcb = NULL;
		sofree(so);
		m_freem(unp->unp_addr);
		free(unp, M_PCB, sizeof *unp);
	}
}

#ifdef notdef
unp_drain(void)
{

}
#endif

extern	struct domain unixdomain;

static struct unpcb *
fptounp(struct file *fp)
{
	struct socket *so;

	if (fp->f_type != DTYPE_SOCKET)
		return (NULL);
	if ((so = fp->f_data) == NULL)
		return (NULL);
	if (so->so_proto->pr_domain != &unixdomain)
		return (NULL);
	return (sotounpcb(so));
}

int
unp_externalize(struct mbuf *rights, socklen_t controllen, int flags)
{
	struct proc *p = curproc;		/* XXX */
	struct cmsghdr *cm = mtod(rights, struct cmsghdr *);
	int i, *fdp = NULL;
	struct fdpass *rp;
	struct file *fp;
	int nfds, error = 0;

	nfds = (cm->cmsg_len - CMSG_ALIGN(sizeof(*cm))) /
	    sizeof(struct fdpass);
	if (controllen < CMSG_ALIGN(sizeof(struct cmsghdr)))
		controllen = 0;
	else
		controllen -= CMSG_ALIGN(sizeof(struct cmsghdr));
	if (nfds > controllen / sizeof(int)) {
		error = EMSGSIZE;
		goto restart;
	}

	/* Make sure the recipient should be able to see the descriptors.. */
	rp = (struct fdpass *)CMSG_DATA(cm);
	for (i = 0; i < nfds; i++) {
		fp = rp->fp;
		rp++;
		error = pledge_recvfd(p, fp);
		if (error)
			break;

		/*
		 * No to block devices.  If passing a directory,
		 * make sure that it is underneath the root.
		 */
		if (p->p_fd->fd_rdir != NULL && fp->f_type == DTYPE_VNODE) {
			struct vnode *vp = (struct vnode *)fp->f_data;

			if (vp->v_type == VBLK ||
			    (vp->v_type == VDIR &&
			    !vn_isunder(vp, p->p_fd->fd_rdir, p))) {
				error = EPERM;
				break;
			}
		}
	}

	fdp = mallocarray(nfds, sizeof(int), M_TEMP, M_WAITOK);

restart:
	fdplock(p->p_fd);
	if (error != 0) {
		if (nfds > 0) {
			rp = ((struct fdpass *)CMSG_DATA(cm));
			unp_discard(rp, nfds);
		}
		goto out;
	}

	/*
	 * First loop -- allocate file descriptor table slots for the
	 * new descriptors.
	 */
	rp = ((struct fdpass *)CMSG_DATA(cm));
	for (i = 0; i < nfds; i++) {
		if ((error = fdalloc(p, 0, &fdp[i])) != 0) {
			/*
			 * Back out what we've done so far.
			 */
			for (--i; i >= 0; i--)
				fdremove(p->p_fd, fdp[i]);

			if (error == ENOSPC) {
				fdexpand(p);
				error = 0;
			} else {
				/*
				 * This is the error that has historically
				 * been returned, and some callers may
				 * expect it.
				 */
				error = EMSGSIZE;
			}
			fdpunlock(p->p_fd);
			goto restart;
		}

		/*
		 * Make the slot reference the descriptor so that
		 * fdalloc() works properly.. We finalize it all
		 * in the loop below.
		 */
		p->p_fd->fd_ofiles[fdp[i]] = rp->fp;
		p->p_fd->fd_ofileflags[fdp[i]] = (rp->flags & UF_PLEDGED);
		rp++;

		if (flags & MSG_CMSG_CLOEXEC)
			p->p_fd->fd_ofileflags[fdp[i]] |= UF_EXCLOSE;
	}

	/*
	 * Now that adding them has succeeded, update all of the
	 * descriptor passing state.
	 */
	rp = (struct fdpass *)CMSG_DATA(cm);
	for (i = 0; i < nfds; i++) {
		struct unpcb *unp;

		fp = rp->fp;
		rp++;
		if ((unp = fptounp(fp)) != NULL)
			unp->unp_msgcount--;
		unp_rights--;
	}

	/*
	 * Copy temporary array to message and adjust length, in case of
	 * transition from large struct file pointers to ints.
	 */
	memcpy(CMSG_DATA(cm), fdp, nfds * sizeof(int));
	cm->cmsg_len = CMSG_LEN(nfds * sizeof(int));
	rights->m_len = CMSG_LEN(nfds * sizeof(int));
 out:
	fdpunlock(p->p_fd);
	if (fdp)
		free(fdp, M_TEMP, nfds * sizeof(int));
	return (error);
}

int
unp_internalize(struct mbuf *control, struct proc *p)
{
	struct filedesc *fdp = p->p_fd;
	struct cmsghdr *cm = mtod(control, struct cmsghdr *);
	struct fdpass *rp;
	struct file *fp;
	struct unpcb *unp;
	int i, error;
	int nfds, *ip, fd, neededspace;

	/*
	 * Check for two potential msg_controllen values because
	 * IETF stuck their nose in a place it does not belong.
	 */ 
	if (cm->cmsg_type != SCM_RIGHTS || cm->cmsg_level != SOL_SOCKET ||
	    !(cm->cmsg_len == control->m_len ||
	    control->m_len == CMSG_ALIGN(cm->cmsg_len)))
		return (EINVAL);
	nfds = (cm->cmsg_len - CMSG_ALIGN(sizeof(*cm))) / sizeof (int);

	if (unp_rights + nfds > maxfiles / 10)
		return (EMFILE);

	/* Make sure we have room for the struct file pointers */
morespace:
	neededspace = CMSG_SPACE(nfds * sizeof(struct fdpass)) -
	    control->m_len;
	if (neededspace > M_TRAILINGSPACE(control)) {
		char *tmp;
		/* if we already have a cluster, the message is just too big */
		if (control->m_flags & M_EXT)
			return (E2BIG);

		/* copy cmsg data temporarily out of the mbuf */
		tmp = malloc(control->m_len, M_TEMP, M_WAITOK);
		memcpy(tmp, mtod(control, caddr_t), control->m_len);

		/* allocate a cluster and try again */
		MCLGET(control, M_WAIT);
		if ((control->m_flags & M_EXT) == 0) {
			free(tmp, M_TEMP, control->m_len);
			return (ENOBUFS);       /* allocation failed */
		}

		/* copy the data back into the cluster */
		cm = mtod(control, struct cmsghdr *);
		memcpy(cm, tmp, control->m_len);
		free(tmp, M_TEMP, control->m_len);
		goto morespace;
	}

	/* adjust message & mbuf to note amount of space actually used. */
	cm->cmsg_len = CMSG_LEN(nfds * sizeof(struct fdpass));
	control->m_len = CMSG_SPACE(nfds * sizeof(struct fdpass));

	ip = ((int *)CMSG_DATA(cm)) + nfds - 1;
	rp = ((struct fdpass *)CMSG_DATA(cm)) + nfds - 1;
	for (i = 0; i < nfds; i++) {
		memcpy(&fd, ip, sizeof fd);
		ip--;
		if ((fp = fd_getfile(fdp, fd)) == NULL) {
			error = EBADF;
			goto fail;
		}
		if (fp->f_count == LONG_MAX-2) {
			error = EDEADLK;
			goto fail;
		}
		error = pledge_sendfd(p, fp);
		if (error)
			goto fail;
		    
		/* kqueue descriptors cannot be copied */
		if (fp->f_type == DTYPE_KQUEUE) {
			error = EINVAL;
			goto fail;
		}
		rp->fp = fp;
		rp->flags = fdp->fd_ofileflags[fd] & UF_PLEDGED;
		rp--;
		fp->f_count++;
		if ((unp = fptounp(fp)) != NULL) {
			unp->unp_file = fp;
			unp->unp_msgcount++;
		}
		unp_rights++;
	}
	return (0);
fail:
	/* Back out what we just did. */
	for ( ; i > 0; i--) {
		rp++;
		fp = rp->fp;
		fp->f_count--;
		if ((unp = fptounp(fp)) != NULL)
			unp->unp_msgcount--;
		unp_rights--;
	}

	return (error);
}

int	unp_defer, unp_gcing;

void
unp_gc(void *arg __unused)
{
	struct unp_deferral *defer;
	struct file *fp;
	struct socket *so;
	struct unpcb *unp;
	int nunref, i;

	if (unp_gcing)
		return;
	unp_gcing = 1;

	/* close any fds on the deferred list */
	while ((defer = SLIST_FIRST(&unp_deferred)) != NULL) {
		SLIST_REMOVE_HEAD(&unp_deferred, ud_link);
		for (i = 0; i < defer->ud_n; i++) {
			fp = defer->ud_fp[i].fp;
			if (fp == NULL)
				continue;
			FREF(fp);
			if ((unp = fptounp(fp)) != NULL)
				unp->unp_msgcount--;
			unp_rights--;
			(void) closef(fp, NULL);
		}
		free(defer, M_TEMP, sizeof(*defer) +
		    sizeof(struct fdpass) * defer->ud_n);
	}

	unp_defer = 0;
	LIST_FOREACH(unp, &unp_head, unp_link)
		unp->unp_flags &= ~(UNP_GCMARK | UNP_GCDEFER | UNP_GCDEAD);
	do {
		nunref = 0;
		LIST_FOREACH(unp, &unp_head, unp_link) {
			if (unp->unp_flags & UNP_GCDEFER) {
				/*
				 * This socket is referenced by another
				 * socket which is known to be live,
				 * so it's certainly live.
				 */
				unp->unp_flags &= ~UNP_GCDEFER;
				unp_defer--;
			} else if (unp->unp_flags & UNP_GCMARK) {
				/* marked as live in previous pass */
				continue;
			} else if ((fp = unp->unp_file) == NULL) {
				/* not being passed, so can't be in loop */
			} else if (fp->f_count == 0) {
				/*
				 * Already being closed, let normal close
				 * path take its course
				 */
			} else {
				/*
				 * Unreferenced by other sockets so far,
				 * so if all the references (f_count) are
				 * from passing (unp_msgcount) then this
				 * socket is prospectively dead
				 */
				if (fp->f_count == unp->unp_msgcount) {
					nunref++;
					unp->unp_flags |= UNP_GCDEAD;
					continue;
				}
			}

			/*
			 * This is the first time we've seen this socket on
			 * the mark pass and known it has a live reference,
			 * so mark it, then scan its receive buffer for
			 * sockets and note them as deferred (== referenced,
			 * but not yet marked).
			 */
			unp->unp_flags |= UNP_GCMARK;

			so = unp->unp_socket;
#ifdef notdef
			if (so->so_rcv.sb_flags & SB_LOCK) {
				/*
				 * This is problematical; it's not clear
				 * we need to wait for the sockbuf to be
				 * unlocked (on a uniprocessor, at least),
				 * and it's also not clear what to do
				 * if sbwait returns an error due to receipt
				 * of a signal.  If sbwait does return
				 * an error, we'll go into an infinite
				 * loop.  Delete all of this for now.
				 */
				(void) sbwait(&so->so_rcv);
				goto restart;
			}
#endif
			unp_scan(so->so_rcv.sb_mb, unp_mark);
		}
	} while (unp_defer);

	/*
	 * If there are any unreferenced sockets, then for each dispose
	 * of files in its receive buffer and then close it.
	 */
	if (nunref) {
		LIST_FOREACH(unp, &unp_head, unp_link) {
			if (unp->unp_flags & UNP_GCDEAD)
				unp_scan(unp->unp_socket->so_rcv.sb_mb,
				    unp_discard);
		}
	}
	unp_gcing = 0;
}

void
unp_dispose(struct mbuf *m)
{

	if (m)
		unp_scan(m, unp_discard);
}

void
unp_scan(struct mbuf *m0, void (*op)(struct fdpass *, int))
{
	struct mbuf *m;
	struct fdpass *rp;
	struct cmsghdr *cm;
	int qfds;

	while (m0) {
		for (m = m0; m; m = m->m_next) {
			if (m->m_type == MT_CONTROL &&
			    m->m_len >= sizeof(*cm)) {
				cm = mtod(m, struct cmsghdr *);
				if (cm->cmsg_level != SOL_SOCKET ||
				    cm->cmsg_type != SCM_RIGHTS)
					continue;
				qfds = (cm->cmsg_len - CMSG_ALIGN(sizeof *cm))
				    / sizeof(struct fdpass);
				if (qfds > 0) {
					rp = (struct fdpass *)CMSG_DATA(cm);
					op(rp, qfds);
				}
				break;		/* XXX, but saves time */
			}
		}
		m0 = m0->m_nextpkt;
	}
}

void
unp_mark(struct fdpass *rp, int nfds)
{
	struct unpcb *unp;
	int i;

	for (i = 0; i < nfds; i++) {
		if (rp[i].fp == NULL)
			continue;

		unp = fptounp(rp[i].fp);
		if (unp == NULL)
			continue;

		if (unp->unp_flags & (UNP_GCMARK|UNP_GCDEFER))
			continue;

		unp_defer++;
		unp->unp_flags |= UNP_GCDEFER;
		unp->unp_flags &= ~UNP_GCDEAD;
	}
}

void
unp_discard(struct fdpass *rp, int nfds)
{
	struct unp_deferral *defer;

	/* copy the file pointers to a deferral structure */
	defer = malloc(sizeof(*defer) + sizeof(*rp) * nfds, M_TEMP, M_WAITOK);
	defer->ud_n = nfds;
	memcpy(&defer->ud_fp[0], rp, sizeof(*rp) * nfds);
	memset(rp, 0, sizeof(*rp) * nfds);
	SLIST_INSERT_HEAD(&unp_deferred, defer, ud_link);

	task_add(systq, &unp_gc_task);
}

int
unp_nam2sun(struct mbuf *nam, struct sockaddr_un **sun, size_t *pathlen)
{
	struct sockaddr *sa = mtod(nam, struct sockaddr *);
	size_t size, len;

	if (nam->m_len < offsetof(struct sockaddr, sa_data))
		return EINVAL;
	if (sa->sa_family != AF_UNIX)
		return EAFNOSUPPORT;
	if (sa->sa_len != nam->m_len)
		return EINVAL;
	if (sa->sa_len > sizeof(struct sockaddr_un))
		return EINVAL;
	*sun = (struct sockaddr_un *)sa;

	/* ensure that sun_path is NUL terminated and fits */
	size = (*sun)->sun_len - offsetof(struct sockaddr_un, sun_path);
	len = strnlen((*sun)->sun_path, size);
	if (len == sizeof((*sun)->sun_path))
		return EINVAL;
	if (len == size) {
		if (M_TRAILINGSPACE(nam) == 0)
			return EINVAL;
		nam->m_len++;
		(*sun)->sun_len++;
		(*sun)->sun_path[len] = '\0';
	}
	if (pathlen != NULL)
		*pathlen = len;

	return 0;
}
@


1.118
log
@Assert that the corresponding socket is locked when manipulating socket
buffers.

This is one step towards unlocking TCP input path.  Note that all the
functions asserting for the socket lock are not necessarilly MP-safe.
All the fields of 'struct socket' aren't protected.

Introduce a new kernel-only kqueue hint, NOTE_SUBMIT, to be able to
tell when a filter needs to lock the underlying data structures.  Logic
and name taken from NetBSD.

Tested by Hrvoje Popovski.

ok claudio@@, bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.117 2017/03/13 20:18:21 claudio Exp $	*/
d73 1
a73 1

d408 1
a408 1
	struct sockaddr_un *soun = mtod(nam, struct sockaddr_un *);
d418 2
a419 11

	if (soun->sun_len > sizeof(struct sockaddr_un) ||
	    soun->sun_len < offsetof(struct sockaddr_un, sun_path))
		return (EINVAL);
	if (soun->sun_family != AF_UNIX)
		return (EAFNOSUPPORT);

	pathlen = strnlen(soun->sun_path, soun->sun_len -
	    offsetof(struct sockaddr_un, sun_path));
	if (pathlen == sizeof(soun->sun_path))
		return (EINVAL);
d474 1
a474 1
	struct sockaddr_un *soun = mtod(nam, struct sockaddr_un *);
d481 2
a482 9
	if (soun->sun_family != AF_UNIX)
		return (EAFNOSUPPORT);

	if (nam->m_len < sizeof(struct sockaddr_un))
		*(mtod(nam, caddr_t) + nam->m_len) = 0;
	else if (nam->m_len > sizeof(struct sockaddr_un))
		return (EINVAL);
	else if (memchr(soun->sun_path, '\0', sizeof(soun->sun_path)) == NULL)
		return (EINVAL);
d1062 34
@


1.117
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.116 2017/02/14 09:46:21 mpi Exp $	*/
d225 1
a225 1
			if (sbappendaddr(&so2->so_rcv, from, m, control)) {
d255 1
a255 1
				if (sbappendcontrol(rcv, m, control))
d262 1
a262 1
				sbappendrecord(rcv, m);
d264 1
a264 1
				sbappend(rcv, m);
@


1.116
log
@Wrap the NET_LOCK() into a per-socket solock() that does nothing for
unix domain sockets.

This should prevent the multiple deadlock related to unix domain sockets.

Inputs from millert@@ and bluhm@@, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.115 2017/02/09 11:18:55 mpi Exp $	*/
d120 1
a120 1
	if (unp == NULL && req != PRU_ATTACH) {
a128 8
	case PRU_ATTACH:
		if (unp) {
			error = EISCONN;
			break;
		}
		error = unp_attach(so);
		break;

d346 1
a346 1
unp_attach(struct socket *so)
d351 2
@


1.115
log
@Temporarily grab the NET_LOCK() around soisdisconnected().

This makes a (wrong) assert disappear and makes sure we hack to avoid a
recursion in the upcall case still work.

The real solution to this problem is to not grab the NET_LOCK() before
entering uipc_usrreq().

Issue reported by dtucker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.114 2017/02/09 10:40:57 mpi Exp $	*/
d124 3
a137 2
		/* XXXSMP breaks atomicity */
		rw_exit_write(&netlock);
a138 1
		rw_enter_write(&netlock);
a141 2
		/* XXXSMP breaks atomicity */
		rw_exit_write(&netlock);
a142 1
		rw_enter_write(&netlock);
a150 2
		/* XXXSMP breaks atomicity */
		rw_exit_write(&netlock);
a151 1
		rw_enter_write(&netlock);
a218 2
				/* XXXSMP breaks atomicity */
				rw_exit_write(&netlock);
a219 1
				rw_enter_write(&netlock);
a391 2
	NET_ASSERT_UNLOCKED();

a402 2
	/* XXXSMP The assert is wrong */
	rw_enter_write(&netlock);
a403 1
	rw_exit_write(&netlock);
d494 1
a494 3
	int error, s;

	NET_ASSERT_UNLOCKED();
a525 1
	NET_LOCK(s);
d530 1
a530 1
			goto unlock;
a548 2
unlock:
	NET_UNLOCK(s);
@


1.114
log
@Release the NET_LOCK() before calling unp_detach(), fix a recursion
found by dtucker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.113 2017/01/27 20:31:42 bluhm Exp $	*/
d401 2
d414 2
d417 1
@


1.113
log
@In sosend() the size of the control message for file descriptor
passing is checked.  As the data type has changed in unp_internalize(),
the calculation has to be adapted in sosend().
Found by relayd regress test on i386.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.112 2017/01/25 06:15:50 mpi Exp $	*/
d135 2
d138 1
d400 1
a400 1
	
@


1.112
log
@Enable the NET_LOCK(), take 2.

Recursions are currently known and marked a XXXSMP.

Please report any assert to bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.111 2017/01/24 04:09:59 deraadt Exp $	*/
a57 5

struct fdpass {
	struct file	*fp;
	int		flags;
};
@


1.111
log
@Track a per-fd flag UF_PLEDGED.  This indicates the initial open was done by a
pledged process. dup(2) and recvmsg(2) retain UF_PLEDGED from the original fd.
In pledge "exec" circumstances, exceve clears UF_PLEDGED on all the process's
fds.

In a pledge'd process, ioctl(2) can use this additional information to grant
access to ioctl's which are more sensitive or dive deeply into the kernel.
Developers will be encouraged to open such sensitive resources before calling
pledge(2), rather than afterwards.  That matches the heading of privsep
development practices.

Future changes will introduce those ioctl(2) changes.

Lots of discussions with semarie guenther and benno.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.110 2017/01/23 23:44:04 deraadt Exp $	*/
d144 2
d147 1
d156 2
d159 1
d227 2
d230 1
d506 2
@


1.110
log
@File descriptor passing internalizes fd's into an mbuf-stored array of
struct file *, and then externalizes back to fd upon delivery.
Convert storage to array of struct fdpass, containing struct file *
(and soon something else).  memcpy originally intended for alignment
purposes can be removed because CMSG_ALIGN is _ALIGN.

There is some anxiety over changing this code, but it reads easier.
ok mpi guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.109 2016/12/29 12:12:43 mpi Exp $	*/
d61 1
d763 1
d878 1
@


1.109
log
@Change NET_LOCK()/NET_UNLOCK() to be simple wrappers around
splsoftnet()/splx() until the known issues are fixed.

In other words, stop using a rwlock since it creates a deadlock when
chrome is used.

Issue reported by Dimitris Papastamos and kettenis@@

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.108 2016/12/29 07:35:09 mpi Exp $	*/
d59 4
d70 2
a71 2
	/* followed by ud_n struct file * pointers */
	struct file *ud_fp[];
d74 5
d676 1
a676 1
	struct file **rp;
d681 1
a681 1
	    sizeof(struct file *);
d692 1
a692 1
	rp = (struct file **)CMSG_DATA(cm);
d694 2
a695 1
		fp = *rp++;
d722 1
a722 1
			rp = ((struct file **)CMSG_DATA(cm));
d732 1
a732 1
	rp = ((struct file **)CMSG_DATA(cm));
d761 2
a762 1
		p->p_fd->fd_ofiles[fdp[i]] = *rp++;
d772 1
a772 1
	rp = (struct file **)CMSG_DATA(cm);
d776 2
a777 1
		fp = *rp++;
d802 2
a803 1
	struct file **rp, *fp;
d823 1
a823 1
	neededspace = CMSG_SPACE(nfds * sizeof(struct file *)) -
d850 2
a851 2
	cm->cmsg_len = CMSG_LEN(nfds * sizeof(struct file *));
	control->m_len = CMSG_SPACE(nfds * sizeof(struct file *));
d854 1
a854 1
	rp = ((struct file **)CMSG_DATA(cm)) + nfds - 1;
d875 1
a875 1
		memcpy(rp, &fp, sizeof fp);
d889 1
a889 1
		memcpy(&fp, rp, sizeof(fp));
d918 1
a918 1
			fp = defer->ud_fp[i];
d927 2
a928 1
		free(defer, M_TEMP, sizeof(*defer) + sizeof(fp) * defer->ud_n);
d1022 1
a1022 1
unp_scan(struct mbuf *m0, void (*op)(struct file **, int))
d1025 1
a1025 1
	struct file **rp;
d1038 1
a1038 1
				    / sizeof(struct file *);
d1040 1
a1040 1
					rp = (struct file **)CMSG_DATA(cm);
d1051 1
a1051 1
unp_mark(struct file **rp, int nfds)
d1057 1
a1057 1
		if (rp[i] == NULL)
d1060 1
a1060 1
		unp = fptounp(rp[i]);
d1074 1
a1074 1
unp_discard(struct file **rp, int nfds)
@


1.108
log
@Release the NET_LOCK() before calling unp_connect().  It is not possible
to hold it during VFS operations as NFS might try to grab it.

Problem also reported by Siegfried Rudzio on bugs@@.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.107 2016/12/22 15:15:28 mpi Exp $	*/
a133 2
		/* XXXSMP breaks atomicity */
		rw_exit_write(&netlock);
a134 1
		rw_enter_write(&netlock);
a142 2
		/* XXXSMP breaks atomicity */
		rw_exit_write(&netlock);
a143 1
		rw_enter_write(&netlock);
a210 2
				/* XXXSMP breaks atomicity */
				rw_exit_write(&netlock);
a211 1
				rw_enter_write(&netlock);
a486 2

	rw_assert_unlocked(&netlock);
@


1.107
log
@Release the NET_LOCK() before namei(9) as a workaround to let NFS boot
work without assert.

ok visa@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.106 2016/12/22 13:30:09 mpi Exp $	*/
d146 2
d149 1
d217 2
d220 1
a493 1
	int error;
d495 3
d511 1
a511 16
	/*
	 * XXXSMP breaks atomicity
	 *
	 * NFS might try to enter sosend(), at least during boot:
	 *  sosend
	 *  nfs_send
	 *  nfs_request
	 *  nfs_lookup
	 *  VOP_LOOKUP
	 *  vfs_lookup
	 *  namei
	 */
	rw_exit_write(&netlock);
	error = namei(&nd);
	rw_enter_write(&netlock);
	if (error != 0)
d529 1
d534 1
a534 1
			goto bad;
d553 2
@


1.106
log
@Revert workaround for NFS boot, it triggers the following assert:

swakeup
sowakeup
sowwakeup
unp_connect2
unp_connect
uipc_usrreq
soconnect
sys_connect

reported by stsp@@, tb@@ and RT Thrush
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.105 2016/12/22 01:52:40 visa Exp $	*/
d503 16
a518 1
	if ((error = namei(&nd)) != 0)
@


1.105
log
@Work around a NET_LOCK() recursion seen during NFS netboot:

sosend  <- NET_LOCK()
nfs_send
nfs_request
nfs_lookup
VOP_LOOKUP
vfs_lookup
namei
unp_connect
uipc_usrreq
soconnect  <- NET_LOCK()
sys_connect

OK bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.104 2016/12/19 08:36:49 mpi Exp $	*/
a145 2
		/* XXXSMP breaks atomicity */
		rw_exit_write(&netlock);
a146 1
		rw_enter_write(&netlock);
@


1.104
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.103 2016/11/29 10:22:30 jsg Exp $	*/
d146 2
d149 1
@


1.103
log
@m_free() and m_freem() test for NULL.  Simplify callers which had their own
NULL tests.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.102 2016/08/26 07:12:30 guenther Exp $	*/
d134 2
d137 1
@


1.102
log
@The *_HEAD_INITIALIZER() macros are documented as taking the struct,
not a pointer to it
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.101 2016/08/17 13:53:14 bluhm Exp $	*/
d324 2
a325 4
	if (control)
		m_freem(control);
	if (m)
		m_freem(m);
@


1.101
log
@Fix an mbuf leak and missing error propagation in uipc_usrreq(PRU_SEND)
in case sbappendcontrol() fails.
From Simon Mages; OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.100 2016/07/19 05:30:48 tedu Exp $	*/
d57 1
a57 1
LIST_HEAD(unp_head, unpcb) unp_head = LIST_HEAD_INITIALIZER(&unp_head);
d71 1
a71 1
SLIST_HEAD(,unp_deferral) unp_deferred = SLIST_HEAD_INITIALIZER(&unp_deferred);
@


1.100
log
@instead of messing about with pointer arithmetic, add an empty array
to the end of the defer structure. solves sizing and alignment concerns.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.99 2016/07/12 14:28:02 tedu Exp $	*/
d257 4
@


1.99
log
@in the great unp_gc rewrite, a null check was lost. we have spent some
time investigating and arguing about whether a NULL fp is a bug or not,
but what has become clear is that NULL fps get passed to unp_discard
and have been for quite some time.
restore old accomodating behavior by checking for null in unp_gc.
ok deraadt kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.98 2016/07/12 13:19:14 deraadt Exp $	*/
d67 1
d900 1
a900 2
			memcpy(&fp, &((struct file **)(defer + 1))[i],
			    sizeof(fp));
d1062 1
a1062 1
	memcpy(defer + 1, rp, sizeof(*rp) * nfds);
@


1.98
log
@The check for pledge "recvfd" was mistakenly only being performed
for chroot'd processes.
ok stefan semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.97 2016/04/25 20:18:31 tedu Exp $	*/
d901 2
@


1.97
log
@remove systrace remnants
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.96 2016/03/19 12:04:15 natano Exp $	*/
d676 1
d678 5
d684 6
a689 7
	fdp = mallocarray(nfds, sizeof(int), M_TEMP, M_WAITOK);

	/* Make sure the recipient should be able to see the descriptors.. */
	if (p->p_fd->fd_rdir != NULL) {
		rp = (struct file **)CMSG_DATA(cm);
		for (i = 0; i < nfds; i++) {
			fp = *rp++;
d691 4
a694 2
			error = pledge_recvfd(p, fp);
			if (error)
a695 13
			/*
			 * No to block devices.  If passing a directory,
			 * make sure that it is underneath the root.
			 */
			if (fp->f_type == DTYPE_VNODE) {
				struct vnode *vp = (struct vnode *)fp->f_data;

				if (vp->v_type == VBLK ||
				    (vp->v_type == VDIR &&
				    !vn_isunder(vp, p->p_fd->fd_rdir, p))) {
					error = EPERM;
					break;
				}
d699 2
@


1.96
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.95 2015/12/05 10:11:53 tedu Exp $	*/
d855 2
a856 3
		/* kq and systrace descriptors cannot be copied */
		if (fp->f_type == DTYPE_KQUEUE ||
		    fp->f_type == DTYPE_SYSTRACE) {
@


1.95
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.94 2015/11/03 20:33:30 deraadt Exp $	*/
d471 1
a471 1
	VOP_UNLOCK(vp, 0, p);
@


1.95.2.1
log
@backport 1.99:
in the great unp_gc rewrite, a null check was lost. we have spent some
time investigating and arguing about whether a NULL fp is a bug or not,
but what has become clear is that NULL fps get passed to unp_discard
and have been for quite some time.
restore old accomodating behavior by checking for null in unp_gc.
ok deraadt kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.95 2015/12/05 10:11:53 tedu Exp $	*/
a905 2
			if (fp == NULL)
				continue;
@


1.94
log
@AF_UNIX connect is a "unix" operation, not "rpath wpath"
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.93 2015/11/02 16:31:55 semarie Exp $	*/
a99 1
/*ARGSUSED*/
@


1.93
log
@move the pledgenote annotation from `struct proc' to `struct nameidata'

pledgenote is used for annotate the policy for a namei context. So make it
tracking the nameidata.

It is expected for the caller to explicitly define the policy. It is a kernel
bug to not do so.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.92 2015/11/01 19:03:33 semarie Exp $	*/
d497 1
a497 1
	nd.ni_pledge = PLEDGE_RPATH | PLEDGE_WPATH;
@


1.92
log
@refactor pledge_*_check and pledge_fail functions

- rename _check function without suffix: a "pledge" function called from
  anywhere is a "check" function.

- makes pledge_fail call the responsability to the _check function. remove it
  from caller.

- make proper use of (potential) returned error of _check() functions.

- adds pledge_kill() and pledge_protexec()

with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.91 2015/11/01 13:49:00 deraadt Exp $	*/
a436 1
	p->p_pledgenote = PLEDGE_UNIX;
d439 1
a495 1
	p->p_pledgenote = PLEDGE_RPATH | PLEDGE_WPATH;
d497 1
@


1.91
log
@bind() on AF_UNIX should set PLEDGE_UNIX not PLEDGE_CPATH; ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.90 2015/10/25 20:39:54 deraadt Exp $	*/
d687 1
a687 1
			error = pledge_recvfd_check(p, fp);
d852 1
a852 1
		error = pledge_sendfd_check(p, fp);
@


1.90
log
@Fold "malloc" into "stdio" and -- recognizing that no program so far has
used less than "stdio" -- include all the "self" operations.  Instead of
different defines, use regular PLEDGE_* in the "p_pledgenote" variable
(which indicates the operation subtype a system call is performing).  Many
checks before easier to understand.  p_pledgenote can often be passed
directly to ktrace, so that kdump says:
 15565 test     CALL  pledge(0xa9a3f804c51,0)
 15565 test     STRU  pledge request="stdio"
 15565 test     RET   pledge 0
 15565 test     CALL  open(0xa9a3f804c57,0x2<O_RDWR>)
 15565 test     NAMI  "/tmp/testfile"
 15565 test     PLDG  open, "wpath", errno 1 Operation not permitted
with help from semarie, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.89 2015/10/18 20:15:10 deraadt Exp $	*/
d437 1
a437 1
	p->p_pledgenote = PLEDGE_CPATH;
@


1.89
log
@Instead of fragile CMSG parsing, control pledge "sendfd" and "recvfd"
in unp_internalize and unp_externalize.
ok kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.88 2015/10/17 23:15:10 deraadt Exp $	*/
d437 1
a437 1
	p->p_pledgenote = TMN_CPATH;
d496 1
a496 1
	p->p_pledgenote = TMN_RPATH | TMN_WPATH;
@


1.88
log
@connect() to an AF_UNIX socket is really read/write, so tell pledge this
is a RPATH|WPATH operation.
Discussed with doug and millert
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.87 2015/10/09 01:10:27 deraadt Exp $	*/
d52 1
d686 4
d852 4
@


1.87
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.86 2015/08/29 21:10:20 deraadt Exp $	*/
d495 1
a495 1
	p->p_pledgenote = TMN_RPATH;
@


1.86
log
@sizes for free(); ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.85 2015/08/28 04:38:47 guenther Exp $	*/
d436 1
a436 1
	p->p_tamenote = TMN_CPATH;
d495 1
a495 1
	p->p_tamenote = TMN_RPATH;
@


1.85
log
@Rework the UNIX domain socket garbage collector, including ideas from
{Free,Net}BSD
 - when a socket is closed with fds in its input, defer closing them to
   a task to avoid recursing.  This eliminates the complicated extra
   reference taking which had a 37 line(!) comment explanation
 - move flags, counts, and links only needed for this from struct file to
   struct unpcb
 - document the flow of the mark/sweep collector

much help from claudio@@ who made me explain the GC to him until we trusted it
ok claudio@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.84 2015/08/22 20:18:50 deraadt Exp $	*/
d395 1
a395 1
	free(unp, M_PCB, 0);
d628 1
a628 1
		free(unp, M_PCB, sizeof(*unp));
d775 1
a775 1
		free(fdp, M_TEMP, 0);
@


1.84
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.83 2015/07/28 14:20:10 bluhm Exp $	*/
d51 1
d55 19
d372 1
d381 1
d395 3
a397 13
	if (unp_rights) {
		/*
		 * Normally the receive buffer is flushed later,
		 * in sofree, but if our receive buffer holds references
		 * to descriptors that are now garbage, we will dispose
		 * of those descriptor references after the garbage collector
		 * gets them (resulting in a "panic: closef: count < 0").
		 */
		sorflush(unp->unp_socket);
		free(unp, M_PCB, 0);
		unp_gc();
	} else
		free(unp, M_PCB, 0);
d639 16
d705 4
a708 2
		rp = ((struct file **)CMSG_DATA(cm));
		unp_discard(rp, nfds);
d757 2
d760 2
a761 1
		fp->f_msgcount--;
d785 1
d843 1
a843 2
		if (fp->f_count == LONG_MAX-2 ||
		    fp->f_msgcount == LONG_MAX-2) {
d856 4
a859 1
		fp->f_msgcount++;
d869 2
a870 1
		fp->f_msgcount--;
a877 1
extern	struct domain unixdomain;
d880 1
a880 1
unp_gc(void)
d882 2
a883 1
	struct file *fp, *nextfp;
d885 1
a885 1
	struct file **extra_ref, **fpp;
d891 16
d908 2
a909 2
	LIST_FOREACH(fp, &filehead, f_list)
		fp->f_iflags &= ~(FIF_MARK|FIF_DEFER);
d911 9
a919 3
		LIST_FOREACH(fp, &filehead, f_list) {
			if (fp->f_iflags & FIF_DEFER) {
				fp->f_iflags &= ~FIF_DEFER;
d921 10
d932 9
a940 5
				if (fp->f_count == 0)
					continue;
				if (fp->f_iflags & FIF_MARK)
					continue;
				if (fp->f_count == fp->f_msgcount)
d942 1
a943 1
			fp->f_iflags |= FIF_MARK;
d945 10
a954 6
			if (fp->f_type != DTYPE_SOCKET ||
			    (so = fp->f_data) == NULL)
				continue;
			if (so->so_proto->pr_domain != &unixdomain ||
			    (so->so_proto->pr_flags&PR_RIGHTS) == 0)
				continue;
d974 1
d976 2
a977 37
	 * We grab an extra reference to each of the file table entries
	 * that are not otherwise accessible and then free the rights
	 * that are stored in messages on them.
	 *
	 * The bug in the original code is a little tricky, so I'll describe
	 * what's wrong with it here.
	 *
	 * It is incorrect to simply unp_discard each entry for f_msgcount
	 * times -- consider the case of sockets A and B that contain
	 * references to each other.  On a last close of some other socket,
	 * we trigger a gc since the number of outstanding rights (unp_rights)
	 * is non-zero.  If during the sweep phase the gc code un_discards,
	 * we end up doing a (full) closef on the descriptor.  A closef on A
	 * results in the following chain.  Closef calls soo_close, which
	 * calls soclose.   Soclose calls first (through the switch
	 * uipc_usrreq) unp_detach, which re-invokes unp_gc.  Unp_gc simply
	 * returns because the previous instance had set unp_gcing, and
	 * we return all the way back to soclose, which marks the socket
	 * with SS_NOFDREF, and then calls sofree.  Sofree calls sorflush
	 * to free up the rights that are queued in messages on the socket A,
	 * i.e., the reference on B.  The sorflush calls via the dom_dispose
	 * switch unp_dispose, which unp_scans with unp_discard.  This second
	 * instance of unp_discard just calls closef on B.
	 *
	 * Well, a similar chain occurs on B, resulting in a sorflush on B,
	 * which results in another closef on A.  Unfortunately, A is already
	 * being closed, and the descriptor has already been marked with
	 * SS_NOFDREF, and soclose panics at this point.
	 *
	 * Here, we first take an extra reference to each inaccessible
	 * descriptor.  Then, we call sorflush ourself, since we know
	 * it is a Unix domain socket anyhow.  After we destroy all the
	 * rights carried in messages, we do a last closef to get rid
	 * of our extra reference.  This is the last close, and the
	 * unp_detach etc will shut down the socket.
	 *
	 * 91/09/19, bsy@@cs.cmu.edu
d979 5
a983 12
	extra_ref = mallocarray(nfiles, sizeof(struct file *), M_FILE, M_WAITOK);
	for (nunref = 0, fp = LIST_FIRST(&filehead), fpp = extra_ref;
	    fp != NULL; fp = nextfp) {
		nextfp = LIST_NEXT(fp, f_list);
		if (fp->f_count == 0)
			continue;
		if (fp->f_count == fp->f_msgcount &&
		    !(fp->f_iflags & FIF_MARK)) {
			*fpp++ = fp;
			nunref++;
			FREF(fp);
			fp->f_count++;
a985 6
	for (i = nunref, fpp = extra_ref; --i >= 0; ++fpp)
	        if ((*fpp)->f_type == DTYPE_SOCKET && (*fpp)->f_data != NULL)
		        sorflush((*fpp)->f_data);
	for (i = nunref, fpp = extra_ref; --i >= 0; ++fpp)
		(void) closef(*fpp, NULL);
	free(extra_ref, M_FILE, 0);
d1029 1
d1036 2
a1037 1
		if (rp[i]->f_iflags & (FIF_MARK|FIF_DEFER))
d1040 6
a1045 6
		if (rp[i]->f_type == DTYPE_SOCKET) {
			unp_defer++;
			rp[i]->f_iflags |= FIF_DEFER;
		} else {
			rp[i]->f_iflags |= FIF_MARK;
		}
d1052 8
a1059 2
	struct file *fp;
	int i;
d1061 1
a1061 9
	for (i = 0; i < nfds; i++) {
		if ((fp = rp[i]) == NULL)
			continue;
		rp[i] = NULL;
		FREF(fp);
		fp->f_msgcount--;
		unp_rights--;
		(void) closef(fp, NULL);
	}
@


1.83
log
@For unix domain sequenced packet socket pairs the ruby regression
tests reported an EMSGSIZE error although the sent message was not
too large.  The way backpressure was implemented for unix domain
sockets confused the check in sosend().

Unix domain sockets append data only to the recv buffer.  To report
the amount of content to the sender, the high watermark of the send
buffer was reduced.  This happend for SOCK_STREAM and SOCK_SEQPACKET.
Sosend checks wether atomic chunks could ever fit into the send
buffer which is limited by the high watermark.  This happens for
SOCK_DGRAM and SOCK_SEQPACKET.  For SOCK_SEQPACKET the combination
of these mechanisms resulted in an EMSGSIZE error when the buffer
got filled.  This also happened when space could be created by
reading from the other end in contradiction to the semantics of
EMSGSIZE.

Do not emulate a send buffer that has no space.  It is better to
fill the buffer with fake data than to reduce its size.  Thus the
high watermark always contains the real value.  When disconnecting,
reset the counters.  Otherwise the socket layer would try to flush
non existing data in the send buffer.

Tested by jeremy@@ with a C program and the ruby tests.
OK markus@@ jeremy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.82 2015/07/18 15:00:01 guenther Exp $	*/
d424 1
d483 1
@


1.82
log
@Change unp_scan() and its callbacks to pass the array of struct file **
and a count instead of calling the callback on each one, while also renders
the 'dispose' argument superfluous.
Move unp_*() prototypes from <sys/un.h> to <sys/unpcb.h>

ok claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.81 2015/06/30 15:30:17 mpi Exp $	*/
d165 2
a166 4
			snd->sb_mbmax += unp->unp_mbcnt - rcv->sb_mbcnt;
			unp->unp_mbcnt = rcv->sb_mbcnt;
			snd->sb_hiwat += unp->unp_cc - rcv->sb_cc;
			unp->unp_cc = rcv->sb_cc;
d229 2
a230 2
			 * Send to paired receive port, and then reduce
			 * send buffer hiwater marks to maintain backpressure.
d240 2
a241 5
			snd->sb_mbmax -=
			    rcv->sb_mbcnt - unp->unp_conn->unp_mbcnt;
			unp->unp_conn->unp_mbcnt = rcv->sb_mbcnt;
			snd->sb_hiwat -= rcv->sb_cc - unp->unp_conn->unp_cc;
			unp->unp_conn->unp_cc = rcv->sb_cc;
a263 11
		switch (so->so_type) {
		case SOCK_STREAM:
		case SOCK_SEQPACKET:
			if (unp->unp_conn != NULL) {
				so2 = unp->unp_conn->unp_socket;
				sb->st_blksize += so2->so_rcv.sb_cc;
			}
			break;
		default:
			break;
		}
d576 2
d580 2
@


1.81
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.80 2015/03/28 23:50:55 bluhm Exp $	*/
d688 1
a688 9
		for (i = 0; i < nfds; i++) {
			fp = *rp;
			/*
			 * zero the pointer before calling unp_discard,
			 * since it may end up in unp_gc()..
			 */
			*rp++ = NULL;
			unp_discard(fp);
		}
d904 1
a904 1
			unp_scan(so->so_rcv.sb_mb, unp_mark, 0);
d974 1
a974 1
		unp_scan(m, unp_discard, 1);
d978 1
a978 1
unp_scan(struct mbuf *m0, void (*op)(struct file *), int discard)
d981 1
a981 1
	struct file **rp, *fp;
a982 1
	int i;
d995 3
a997 7
				rp = (struct file **)CMSG_DATA(cm);
				for (i = 0; i < qfds; i++) {
					fp = *rp;
					if (discard)
						*rp = 0;
					(*op)(fp);
					rp++;
d1007 1
a1007 1
unp_mark(struct file *fp)
d1009 5
a1013 2
	if (fp == NULL)
		return;
d1015 2
a1016 2
	if (fp->f_iflags & (FIF_MARK|FIF_DEFER))
		return;
d1018 6
a1023 5
	if (fp->f_type == DTYPE_SOCKET) {
		unp_defer++;
		fp->f_iflags |= FIF_DEFER;
	} else {
		fp->f_iflags |= FIF_MARK;
d1028 1
a1028 1
unp_discard(struct file *fp)
d1030 2
d1033 9
a1041 6
	if (fp == NULL)
		return;
	FREF(fp);
	fp->f_msgcount--;
	unp_rights--;
	(void) closef(fp, NULL);
@


1.80
log
@Replace the hand-crafted list of datagram unix domain sockets with
a SLIST.
OK mpi@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.79 2014/12/11 19:21:57 tedu Exp $	*/
d528 1
a528 1
			    m_copy(unp2->unp_addr, 0, (int)M_COPYALL);
@


1.79
log
@convert bcopy to memcpy/memmove. ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.78 2014/11/03 03:08:00 deraadt Exp $	*/
d41 1
d384 2
a385 2
	while (unp->unp_refs)
		unp_drop(unp->unp_refs, ECONNRESET);
d558 1
a558 2
		unp->unp_nextref = unp2->unp_refs;
		unp2->unp_refs = unp;
d586 1
a586 14
		if (unp2->unp_refs == unp)
			unp2->unp_refs = unp->unp_nextref;
		else {
			unp2 = unp2->unp_refs;
			for (;;) {
				if (unp2 == NULL)
					panic("unp_disconnect");
				if (unp2->unp_nextref == unp)
					break;
				unp2 = unp2->unp_nextref;
			}
			unp2->unp_nextref = unp->unp_nextref;
		}
		unp->unp_nextref = NULL;
@


1.78
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.77 2014/08/31 01:42:36 guenther Exp $	*/
d69 1
a69 1
		bcopy(mtod(unp->unp_addr, caddr_t), mtod(nam, caddr_t),
d73 1
a73 1
		bcopy(&sun_noname, mtod(nam, struct sockaddr *),
d834 1
a834 1
		bcopy(ip, &fd, sizeof fd);
d851 1
a851 1
		bcopy(&fp, rp, sizeof fp);
d862 1
a862 1
		bcopy(rp, &fp, sizeof(fp));
@


1.77
log
@Add additional kernel interfaces for setting close-on-exec on fds
when creating them: pipe2(), dup3(), accept4(), MSG_CMSG_CLOEXEC,
SOCK_CLOEXEC.  Includes SOCK_NONBLOCK support.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.76 2014/07/13 15:52:38 tedu Exp $	*/
d639 1
a639 1
		free(unp, M_PCB, 0);
d816 1
a816 1
			free(tmp, M_TEMP, 0);
d823 1
a823 1
		free(tmp, M_TEMP, 0);
@


1.76
log
@bzero -> memset. for the speeds.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.75 2014/07/13 15:29:04 tedu Exp $	*/
d651 1
a651 1
unp_externalize(struct mbuf *rights, socklen_t controllen)
d747 3
@


1.75
log
@use mallocarray where arguments are multipled. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.74 2014/07/12 18:43:32 tedu Exp $	*/
d432 1
a432 1
	/* No need to NUL terminate: m_getclr() returns bzero'd mbufs. */
@


1.74
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.73 2014/03/18 06:59:00 guenther Exp $	*/
d673 1
a673 1
	fdp = malloc(nfds * sizeof(int), M_TEMP, M_WAITOK);
d964 1
a964 1
	extra_ref = malloc(nfiles * sizeof(struct file *), M_FILE, M_WAITOK);
@


1.73
log
@In prep for killing ps_mainproc, use pr->ps_pid instead of
pr->ps_mainproc->p_pid to get the PID.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.72 2014/01/24 06:00:01 guenther Exp $	*/
d397 1
a397 1
		free(unp, M_PCB);
d400 1
a400 1
		free(unp, M_PCB);
d639 1
a639 1
		free(unp, M_PCB);
d770 1
a770 1
		free(fdp, M_TEMP);
d813 1
a813 1
			free(tmp, M_TEMP);
d820 1
a820 1
		free(tmp, M_TEMP);
d983 1
a983 1
	free(extra_ref, M_FILE);
@


1.72
log
@Copy timespecs member by member in fo_stat callback functions, to avoid
leaking values in the padding bytes on LP64.  Also, vn_stat() was lacking
the zero-fill to clean its padding.

ok kettenis@@ deraadt@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.71 2013/04/05 08:25:30 tedu Exp $	*/
d471 1
a471 1
	unp->unp_connid.pid = p->p_p->ps_mainproc->p_pid;
d530 1
a530 1
		unp3->unp_connid.pid = p->p_p->ps_mainproc->p_pid;
@


1.71
log
@remove some obsolete casts
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.70 2013/03/30 06:32:25 tedu Exp $	*/
d264 4
a267 2
	case PRU_SENSE:
		((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat;
d273 1
a273 2
				((struct stat *) m)->st_blksize +=
				    so2->so_rcv.sb_cc;
d279 1
a279 1
		((struct stat *) m)->st_dev = NODEV;
d282 7
a288 4
		((struct stat *) m)->st_atim =
		    ((struct stat *) m)->st_mtim =
		    ((struct stat *) m)->st_ctim = unp->unp_ctime;
		((struct stat *) m)->st_ino = unp->unp_ino;
d290 1
@


1.70
log
@vrele() is a tricky beast. it can sleep if the refcount hits zero,
leaving us with a free type function that isn't atomic. deal with this
by erasing any reachable pointers to the vnode first, then free it.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.69 2012/10/12 20:45:49 guenther Exp $	*/
d896 1
a896 1
			    (so = (struct socket *)fp->f_data) == NULL)
d975 1
a975 1
		        sorflush((struct socket *)(*fpp)->f_data);
d978 1
a978 1
	free((caddr_t)extra_ref, M_FILE);
@


1.69
log
@For consistency with other OSes and ease of porting, make
get{sock,peer}name() behave like accept() when the involved UNIX-domain
socket isn't bound to an address, returning an AF_UNIX sockaddr
with zero-length sun_path.  Based on diff from robert@@ and mikeb@@

ok robert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.68 2012/09/02 05:20:17 deraadt Exp $	*/
d368 1
d372 1
a372 1
		vrele(unp->unp_vnode);
d374 1
@


1.68
log
@Do not need bcopy trickery to update the file descriptor
pointer array; we can access it directly.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.67 2012/08/23 00:11:56 guenther Exp $	*/
d51 2
d64 14
d138 1
a138 8
		if (unp->unp_conn && unp->unp_conn->unp_addr) {
			nam->m_len = unp->unp_conn->unp_addr->m_len;
			bcopy(mtod(unp->unp_conn->unp_addr, caddr_t),
			    mtod(nam, caddr_t), nam->m_len);
		} else {
			nam->m_len = sizeof(sun_noname);
			*(mtod(nam, struct sockaddr *)) = sun_noname;
		}
d295 1
a295 6
		if (unp->unp_addr) {
			nam->m_len = unp->unp_addr->m_len;
			bcopy(mtod(unp->unp_addr, caddr_t),
			    mtod(nam, caddr_t), nam->m_len);
		} else
			nam->m_len = 0;
d299 1
a299 6
		if (unp->unp_conn && unp->unp_conn->unp_addr) {
			nam->m_len = unp->unp_conn->unp_addr->m_len;
			bcopy(mtod(unp->unp_conn->unp_addr, caddr_t),
			    mtod(nam, caddr_t), nam->m_len);
		} else
			nam->m_len = 0;
@


1.67
log
@To protect assumptions inside systrace, don't let systrace fds be
shared between processes.

ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.66 2012/04/26 17:18:17 matthew Exp $	*/
a712 2
		bcopy(rp, &fp, sizeof(fp));
		rp++;
d740 1
a740 1
		p->p_fd->fd_ofiles[fdp[i]] = fp;
@


1.66
log
@Cleanup unp_bind() a little:

  - Require sun_family to be set to AF_UNIX (also in unp_connect())
  - Ensure internal sockaddr_un's always have their length set to
    sizeof(struct sockaddr_un) regardless of the user specified length,
    implicitly extending with NUL characters as necessary.
  - Normalize sun_path to never contain a non-NUL character after a
    NUL character.

Lack of NUL termination on truncated sockaddrs issue pointed out by
Michael Kerrisk on the Austin Group mailing list.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.65 2012/04/23 15:36:07 matthew Exp $	*/
d838 3
a840 2
		/* kq descriptors cannot be copied */
		if (fp->f_type == DTYPE_KQUEUE) {
@


1.65
log
@Don't leak mbufs when bind() on a PF_UNIX socket fails.

ok deraadt, miod, guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.64 2012/04/14 09:42:32 claudio Exp $	*/
d404 1
a404 1
	int error, namelen;
d406 1
d410 11
a420 10
	namelen = soun->sun_len - offsetof(struct sockaddr_un, sun_path);
	if (namelen <= 0 || namelen > sizeof(soun->sun_path))
		return EINVAL;
	if (namelen == sizeof(soun->sun_path) &&
	    memchr(soun->sun_path, '\0', namelen) == NULL)
		return EINVAL;
	/*
	 * if namelen < sizeof(sun_path) then the strncpy below
	 * will NUL terminate it
	 */
d423 4
a426 5
	nam2->m_len = soun->sun_len;
	memcpy(mtod(nam2, caddr_t), soun,
	    offsetof(struct sockaddr_un, sun_path));
	strncpy(mtod(nam2, caddr_t) +
	    offsetof(struct sockaddr_un, sun_path), soun->sun_path, namelen);
d429 4
d480 3
@


1.64
log
@Do not just return in case the provided control buffer is too short since
that leaks all the file pointers. Instead make sure that the exit path via
restart: -> out: does not free the uninitialized pointer.
OK deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.63 2012/04/14 09:07:42 claudio Exp $	*/
d401 1
d420 3
a422 3
	unp->unp_addr = m_getclr(M_WAITOK, MT_SONAME);
	unp->unp_addr->m_len = soun->sun_len;
	memcpy(mtod(unp->unp_addr, caddr_t *), soun,
d424 1
a424 1
	strncpy(mtod(unp->unp_addr, caddr_t) +
d427 1
a427 1
	soun = mtod(unp->unp_addr, struct sockaddr_un *);
d431 2
a432 1
	if ((error = namei(&nd)) != 0)
d434 1
d443 1
d450 2
a451 1
	if (error)
d453 2
@


1.63
log
@Free tmp buffer in case the cluster allocation failed. Found by David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.62 2012/04/14 08:47:27 guenther Exp $	*/
d634 1
a634 1
	int i, *fdp;
d645 4
a648 2
	if (nfds > controllen / sizeof(int))
		return (EMSGSIZE);
d750 2
a751 1
	free(fdp, M_TEMP);
@


1.62
log
@Revert rev 1.58, as it frees an uninitialized pointer

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.61 2012/04/13 19:22:18 deraadt Exp $	*/
d790 2
a791 1
		if ((control->m_flags & M_EXT) == 0)
d793 1
@


1.61
log
@gc unused function
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.60 2012/04/13 19:18:58 claudio Exp $	*/
d645 2
a646 4
	if (nfds > controllen / sizeof(int)) {
		error = EMSGSIZE;
		goto restart;
	}
@


1.60
log
@Don't convert a mbuf to a cluster and think the data in the mbuf is still
valid after that. Copy the data into a temp buffer and then copy it back
into the shiny new cluster. Problem found by deraadt@@. Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.59 2012/04/13 19:16:11 deraadt Exp $	*/
a589 7

#ifdef notdef
unp_abort(struct unpcb *unp)
{
	unp_detach(unp);
}
#endif
@


1.59
log
@oops, wrong version of diff in previous
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.58 2012/04/13 19:12:44 deraadt Exp $	*/
d788 1
d793 4
d802 1
a802 2
		/* copy the data to the cluster */
		memcpy(mtod(control, char *), cm, cm->cmsg_len);
d804 2
@


1.58
log
@Do not clamp the file descriptors to the buffer size; that leads to
losing them.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.57 2012/04/13 09:38:32 deraadt Exp $	*/
d652 4
a655 2
	if (nfds > controllen / sizeof(int))
		return EMSGSIZE;
@


1.57
log
@unneccessary casts to unsigned; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.56 2012/04/11 14:08:27 deraadt Exp $	*/
d653 1
a653 1
		nfds = controllen / sizeof(int);
@


1.56
log
@In sendmsg() permit at most 10% of maxfiles to be in-flight
during CMSG_DATA SCM_RIGHTS fd transfers. If this is exceeded,
return EMFILE.
ok claudio guenther gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.55 2011/07/06 06:31:38 matthew Exp $	*/
d125 1
a125 1
			    mtod(nam, caddr_t), (unsigned)nam->m_len);
d289 1
a289 1
			    mtod(nam, caddr_t), (unsigned)nam->m_len);
d298 1
a298 1
			    mtod(nam, caddr_t), (unsigned)nam->m_len);
@


1.55
log
@Implement SOCK_SEQPACKET for UNIX sockets.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.54 2011/07/06 06:26:14 guenther Exp $	*/
d777 3
@


1.54
log
@Correct the check for a sun_path that lacks NUL termination to just require
that *some* char in sun_path is NUL, not necessarily the last.

ok claudio@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.53 2011/07/05 23:06:43 claudio Exp $	*/
d55 1
a55 1
 *	SEQPACKET, RDM
d145 1
d208 1
d228 3
a230 1
			} else
d257 11
a267 3
		if (so->so_type == SOCK_STREAM && unp->unp_conn != NULL) {
			so2 = unp->unp_conn->unp_socket;
			((struct stat *) m)->st_blksize += so2->so_rcv.sb_cc;
d343 1
d542 1
d583 1
d603 9
a611 3
	if (unp->unp_socket->so_type == SOCK_STREAM && unp->unp_conn &&
	    (so = unp->unp_conn->unp_socket))
		socantrcvmore(so);
@


1.53
log
@Enforce that the path to the unix socket fits into struct sockaddr_un
and that it is nul terminated. This means the longest path is now 103
char longs. With and OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.52 2011/06/28 10:15:38 thib Exp $	*/
d399 1
a399 1
	    soun->sun_path[namelen - 1] != '\0')
d401 4
d456 1
a456 5
	if (nam->m_len >= sizeof(struct sockaddr_un)) {
		if (nam->m_len > sizeof(struct sockaddr_un) ||
		    *(mtod(nam, caddr_t) + nam->m_len - 1) != 0)
			return (EMSGSIZE);
	} else
d458 5
@


1.52
log
@Rename FMARK to FIF_MARK and FDEFER to FIF_DEFER and
move those flags to f_iflags; This makes rooms in the
flag member of struct file for some goodies matthew@@
as planned.

ok matthew@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.51 2011/05/17 00:17:01 guenther Exp $	*/
a391 1
	char buf[MLEN];
d396 1
a396 1
	if (namelen <= 0 || namelen >= MLEN)
d398 14
a411 3
	strncpy(buf, soun->sun_path, namelen);
	buf[namelen] = 0;       /* null-terminate the string */
	NDINIT(&nd, CREATE, NOFOLLOW | LOCKPARENT, UIO_SYSSPACE, buf, p);
a433 1
	unp->unp_addr = m_copy(nam, 0, (int)M_COPYALL);
d452 3
a454 3
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_SYSSPACE, soun->sun_path, p);
	if (nam->m_data + nam->m_len == &nam->m_dat[MLEN]) {	/* XXX */
		if (*(mtod(nam, caddr_t) + nam->m_len - 1) != 0)
d458 1
@


1.51
log
@Ban passing of kqueue descriptors via UNIX domain sockets.  Currently,
they're tightly bound to struct filedesc, leading to NULL derefs
during exit1().

ok henning@@, millert@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.50 2011/04/04 12:44:10 deraadt Exp $	*/
d821 1
a821 1
		fp->f_flag &= ~(FMARK|FDEFER);
d824 2
a825 2
			if (fp->f_flag & FDEFER) {
				fp->f_flag &= ~FDEFER;
d830 1
a830 1
				if (fp->f_flag & FMARK)
d835 1
a835 1
			fp->f_flag |= FMARK;
d907 2
a908 1
		if (fp->f_count == fp->f_msgcount && !(fp->f_flag & FMARK)) {
d972 1
a972 4
	if (fp->f_flag & FMARK)
		return;

	if (fp->f_flag & FDEFER)
d977 1
a977 1
		fp->f_flag |= FDEFER;
d979 1
a979 1
		fp->f_flag |= FMARK;
@


1.50
log
@COMPAT_O47 (kernel getpeereid, which was replaced by libc getpeereid)
can go away
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.49 2010/10/18 04:31:01 guenther Exp $	*/
d778 5
@


1.49
log
@PRU_PEEREID is only used by code under COMPAT_O47, so put it there too
so that we remember to remove it all at the same time in two years.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.48 2010/07/02 00:11:39 deraadt Exp $	*/
a289 11

#ifdef COMPAT_O47
	case PRU_PEEREID:
		if (unp->unp_flags & UNP_FEIDS) {
			nam->m_len = sizeof(struct sockpeercred);
			bcopy((caddr_t)(&(unp->unp_connid)),
			    mtod(nam, caddr_t), (unsigned)nam->m_len);
		} else
			nam->m_len = 0;
		break;
#endif /* COMPAT_O47 */
@


1.48
log
@structure copy the unp_connid to the other socket
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.47 2010/07/01 17:20:48 deraadt Exp $	*/
d291 1
d300 1
@


1.47
log
@SO_PEERCRED should pass out the main pid, not the "pid" of the current
thread.  Discussion with guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.46 2010/06/30 19:57:05 deraadt Exp $	*/
d494 1
a494 3
			unp->unp_connid.uid = unp2->unp_connid.uid;
			unp->unp_connid.gid = unp2->unp_connid.gid;
			unp->unp_connid.pid = unp2->unp_connid.pid;
@


1.46
log
@Add getsockopt SOL_SOCKET SO_PEERCRED support. This behaves similar to
getpeereid(2), but also supplies the remote pid.  This is supplied in
a 'struct sockpeercred' (unlike Linux -- they showed how little they
know about real unix by calling theirs 'struct ucred').
ok guenther ajacoutot
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.45 2009/02/22 07:47:22 otto Exp $	*/
d436 1
a436 1
	unp->unp_connid.pid = p->p_pid;
d490 1
a490 1
		unp3->unp_connid.pid = p->p_pid;
@


1.45
log
@fix PR 6082: do not create more fd's than will fit in the message on
the receiving side when passing fd's. ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.44 2009/01/29 22:08:45 guenther Exp $	*/
d293 1
a293 1
			nam->m_len = sizeof(struct unpcbid);
d434 3
a436 2
	unp->unp_connid.unp_euid = p->p_ucred->cr_uid;
	unp->unp_connid.unp_egid = p->p_ucred->cr_gid;
d488 3
a490 2
		unp3->unp_connid.unp_euid = p->p_ucred->cr_uid;
		unp3->unp_connid.unp_egid = p->p_ucred->cr_gid;
d494 3
a496 2
			unp->unp_connid.unp_euid = unp2->unp_connid.unp_euid;
			unp->unp_connid.unp_egid = unp2->unp_connid.unp_egid;
@


1.44
log
@Switch struct stat's timespec members to the names standardized in
POSIX 1003.1-2008, with compatibility macros for the names used in
previous version of OpenBSD.  Update all the references in the
kernel to use the new, standard member names.

ok'ed by miod@@, otto@@; ports build test by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.43 2008/05/23 15:51:12 thib Exp $	*/
d609 1
a609 1
unp_externalize(struct mbuf *rights)
d620 7
@


1.43
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.42 2008/04/15 19:01:45 deraadt Exp $	*/
d260 3
a262 3
		((struct stat *) m)->st_atimespec =
		    ((struct stat *) m)->st_mtimespec =
		    ((struct stat *) m)->st_ctimespec = unp->unp_ctime;
@


1.42
log
@describe why fd passing is now so fucked up, and who's fault it is
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.41 2008/04/10 17:50:46 kettenis Exp $	*/
d65 1
a65 1
    struct mbuf *control)
a69 1
	struct proc *p = curproc;	/* XXX */
@


1.41
log
@Make sure the fd passing code only accepts control messages without padding
and with exactly the right amount of padding.

diff actually typed in by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.40 2008/04/08 20:47:55 stefan Exp $	*/
d734 3
a736 7
	/* XXX
	 * To be more strict with the API/ABI, the following check for
	 *	cm->cmsg_len > control->m_len
	 * should be changed to
	 *	CMSG_ALIGN(cm->cmsg_len) != control->m_len
	 * after 4.3 is released (and all callers correctly set msg_controllen
	 * using CMSG_SPACE().  In particular, sparc64 alignment changes.
@


1.40
log
@unp_internalize() repaired wrong file structs on error. ok deraadt@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.39 2008/04/02 19:09:13 deraadt Exp $	*/
d743 2
a744 1
	    cm->cmsg_len > control->m_len)
@


1.39
log
@repair code which blocks passing fd's for block devices or
dir-outside-chroot-directory into a chroot jail
ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.38 2008/03/24 16:07:37 deraadt Exp $	*/
d795 1
a796 1
		rp++;
@


1.38
log
@We were led astray (like many others before us) to believe that
msg_controllen should be CMSG_LEN() instead of CMSG_SPACE() because
the kernel fd passing code was erroring out when
     "cm->cmsg_len != control->m_len"
instead of
     "CMSG_ALIGN(cm->cmsg_len) != control->m_len".
On machines with 16-byte alignment, when one thinks about how the ALIGN
padding happens, it is clear that msg_controllen has to be CMSG_SPACE()
or the kernel cannot hope to bounds check the messages correctly.
For now, change the check to cm->cmsg_len > control->m_len to permit the
old ABI to continue working.  Later perhaps when all the old binaries
are gone we can stop permitting their use.
lots of discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.37 2007/11/28 16:56:46 tedu Exp $	*/
a624 1
#ifdef notyet
d626 1
a626 1
	if (p->p_cwdi->cwdi_rdir != NULL) {
d631 2
a632 4
			 * If we are in a chroot'ed directory, and
			 * someone wants to pass us a directory, make
			 * sure it's inside the subtree we're allowed
			 * to access.
d636 4
a639 2
				if ((vp->v_type == VDIR) &&
				    !vn_isunder(vp, p->p_cwdi->cwdi_rdir, p)) {
a645 1
#endif
@


1.37
log
@a few more places where getmicrotime is good enough. ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.36 2007/10/29 18:36:00 deraadt Exp $	*/
d736 8
d745 1
a745 1
	    cm->cmsg_len != control->m_len)
@


1.36
log
@For fd passing, at externalize time we are dealing with int[] not pointer[],
so we need to correct the mbuf length using CMSG_LEN() not CMSG_SPACE()
test case was sparc64 sending 2 (or more) descriptors
ok millert thib
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.35 2007/09/07 15:00:20 art Exp $	*/
d359 1
a359 1
	nanotime(&unp->unp_ctime);
@


1.35
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.34 2007/01/16 17:52:18 thib Exp $	*/
d720 1
a720 1
	rights->m_len = CMSG_SPACE(nfds * sizeof(int));
@


1.34
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.33 2006/11/17 08:33:20 claudio Exp $	*/
d354 1
a354 1
	unp = malloc(sizeof(*unp), M_PCB, M_NOWAIT);
a356 1
	bzero((caddr_t)unp, sizeof(*unp));
@


1.33
log
@Make getpeereid() work on both sides of a connection. The client can now get
the euid/egid of the server it connects to. The euid and egid are captured in
the bind() call -- this is the equivalent of the client behaviour where the
same thing is done in connect().
tested and ok espie@@, ok henning@@, go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.32 2006/10/31 16:24:55 markus Exp $	*/
a428 1
	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
@


1.32
log
@undo unp_internalize in case of errors; report Christian Biere; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.31 2006/02/27 23:38:11 miod Exp $	*/
d437 3
d450 1
a450 1
	struct unpcb *unp2, *unp3;
d484 1
d494 5
@


1.31
log
@Do not stupidly panic but return ENOTCONN when trying to pass fds on an
unconnected socket; reported by Christian Biere <christianbiere at gmx dot de>
ok claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.30 2006/01/05 05:05:07 jsg Exp $	*/
d243 3
@


1.30
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.29 2005/05/17 21:43:08 fgsch Exp $	*/
d214 4
a217 2
			if (unp->unp_conn == NULL)
				panic("uipc 3");
@


1.29
log
@under some circunstances, unp_scan() can call unp_mark() with a null pointer,
so check fp before dereferencing it; fixes a crash found by hshoexer@@
with input from art@@, art@@ millert@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.28 2004/07/22 06:13:08 tedu Exp $	*/
d64 2
a65 4
uipc_usrreq(so, req, m, nam, control)
	struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
d68 2
a69 2
	register struct socket *so2;
	register int error = 0;
d327 1
a327 2
unp_attach(so)
	struct socket *so;
d329 1
a329 1
	register struct unpcb *unp;
d360 1
a360 2
unp_detach(unp)
	register struct unpcb *unp;
d391 1
a391 4
unp_bind(unp, nam, p)
	struct unpcb *unp;
	struct mbuf *nam;
	struct proc *p;
d394 1
a394 1
	register struct vnode *vp;
d437 1
a437 4
unp_connect(so, nam, p)
	struct socket *so;
	struct mbuf *nam;
	struct proc *p;
d439 3
a441 3
	register struct sockaddr_un *soun = mtod(nam, struct sockaddr_un *);
	register struct vnode *vp;
	register struct socket *so2, *so3;
d493 1
a493 3
unp_connect2(so, so2)
	register struct socket *so;
	register struct socket *so2;
d495 2
a496 2
	register struct unpcb *unp = sotounpcb(so);
	register struct unpcb *unp2;
d523 1
a523 2
unp_disconnect(unp)
	struct unpcb *unp;
d525 1
a525 1
	register struct unpcb *unp2 = unp->unp_conn;
d559 1
a559 2
unp_abort(unp)
	struct unpcb *unp;
a560 1

d566 1
a566 2
unp_shutdown(unp)
	struct unpcb *unp;
d576 1
a576 3
unp_drop(unp, errno)
	struct unpcb *unp;
	int errno;
d591 1
a591 1
unp_drain()
d598 1
a598 2
unp_externalize(rights)
	struct mbuf *rights;
d716 1
a716 3
unp_internalize(control, p)
	struct mbuf *control;
	struct proc *p;
d791 1
a791 1
unp_gc()
d793 2
a794 2
	register struct file *fp, *nextfp;
	register struct socket *so;
d906 1
a906 2
unp_dispose(m)
	struct mbuf *m;
d914 1
a914 4
unp_scan(m0, op, discard)
	struct mbuf *m0;
	void (*op)(struct file *);
	int discard;
d948 1
a948 2
unp_mark(fp)
	struct file *fp;
d968 1
a968 2
unp_discard(fp)
	struct file *fp;
@


1.29.2.1
log
@MFC:
Fix by miod@@

Do not stupidly panic but return ENOTCONN when trying to pass fds on an
unconnected socket; reported by Christian Biere <christianbiere at gmx dot de>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.29 2005/05/17 21:43:08 fgsch Exp $	*/
d216 2
a217 4
			if (unp->unp_conn == NULL) {
				error = ENOTCONN;
				break;
			}
@


1.28
log
@remove p arg from fdplock
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.27 2004/06/24 19:35:24 tholo Exp $	*/
d976 2
@


1.28.4.1
log
@MFC:
Fix by miod@@

Do not stupidly panic but return ENOTCONN when trying to pass fds on an
unconnected socket; reported by Christian Biere <christianbiere at gmx dot de>

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.28 2004/07/22 06:13:08 tedu Exp $	*/
d216 2
a217 4
			if (unp->unp_conn == NULL) {
				error = ENOTCONN;
				break;
			}
@


1.27
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.26 2004/04/01 23:56:05 tedu Exp $	*/
d657 1
a657 1
	fdplock(p->p_fd, p);
@


1.26
log
@use NULL for ptrs.  parts from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.25 2004/01/06 04:18:18 tedu Exp $	*/
a332 1
	struct timeval tv;
d358 1
a358 2
	microtime(&tv);
	TIMEVAL_TO_TIMESPEC(&tv, &unp->unp_ctime);
@


1.25
log
@lock filedesc before manipulating.  avoids some rare races.
testing for quite some time by brad + otto
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.24 2003/08/17 22:59:42 tedu Exp $	*/
d80 1
a80 1
	if (unp == 0 && req != PRU_ATTACH) {
d103 1
a103 1
		if (unp->unp_vnode == 0)
d150 1
a150 1
			if (unp->unp_conn == 0)
d188 1
a188 1
				if (unp->unp_conn == 0) {
d200 2
a201 2
				m = 0;
				control = 0;
d216 1
a216 1
			if (unp->unp_conn == 0)
d226 1
a226 1
					control = 0;
d235 1
a235 1
			m = 0;
d251 1
a251 1
		if (so->so_type == SOCK_STREAM && unp->unp_conn != 0) {
d370 1
a370 1
		unp->unp_vnode->v_socket = 0;
d372 1
a372 1
		unp->unp_vnode = 0;
d379 1
a379 1
	unp->unp_socket->so_pcb = 0;
d474 1
a474 1
	if (so2 == 0) {
d542 1
a542 1
	if (unp2 == 0)
d544 1
a544 1
	unp->unp_conn = 0;
d553 1
a553 1
				if (unp2 == 0)
d561 1
a561 1
		unp->unp_nextref = 0;
d567 1
a567 1
		unp2->unp_conn = 0;
d603 1
a603 1
		so->so_pcb = 0;
d668 1
a668 1
			*rp++ = 0;
d843 1
a843 1
			    (so = (struct socket *)fp->f_data) == 0)
d907 2
a908 2
	for (nunref = 0, fp = LIST_FIRST(&filehead), fpp = extra_ref; fp != 0;
	    fp = nextfp) {
@


1.24
log
@unused var
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.23 2003/06/02 23:28:07 millert Exp $	*/
d659 1
d700 1
d731 1
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.22 2002/08/23 15:33:12 art Exp $	*/
a741 1
	struct mbuf *n = NULL;
a802 2
	if (n)
		m_freem(n);
@


1.22
log
@Use LIST_ macros for the list of all struct file.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.21 2002/03/14 01:27:05 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.20 2002/02/19 23:14:59 art Exp $	*/
d829 1
a829 1
	for (fp = filehead.lh_first; fp != 0; fp = fp->f_list.le_next)
d832 1
a832 1
		for (fp = filehead.lh_first; fp != 0; fp = fp->f_list.le_next) {
d911 1
a911 1
	for (nunref = 0, fp = filehead.lh_first, fpp = extra_ref; fp != 0;
d913 1
a913 1
		nextfp = fp->f_list.le_next;
@


1.20
log
@Heh. Don't assume that sizeof(void *) > sizeof(int).
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.19 2002/02/11 12:35:53 art Exp $	*/
d944 1
a944 1
	void (*op) __P((struct file *));
@


1.19
log
@Big fixup of fd passing. It now works, even on sparc64.
Some parts from NetBSD, but with big modifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.18 2002/02/08 13:53:28 art Exp $	*/
d681 1
a681 1
	rp = ((struct file **)CMSG_DATA(cm)) + nfds - 1;
d684 1
a684 1
		rp--;
d778 1
a778 1
	ip = ((int *)CMSG_DATA(cm));
d782 1
a782 1
		ip++;
@


1.18
log
@- Rename FILE_{,UN}USE to FREF and FRELE. USE is a bad verb and we don't have
  the same semantics as NetBSD anyway, so it's good to avoid name collissions.
- Always fdremove before freeing the file, not the other way around.
- falloc FREFs the file.
- have FILE_SET_MATURE FRELE the file (It feels like a good ortogonality to
  falloc FREFing the file).
- Use closef as much as possible instead of ffree in error paths of
  falloc:ing functions. closef is much more careful with the fd and can
  deal with the fd being forcibly closed by dup2. Also try to avoid
  manually calling *fo_close when closef can do that for us (this makes
  some error paths mroe complicated (sys_socketpair and sys_pipe), but
  others become simpler (sys_open)).
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.17 2002/02/05 16:02:27 art Exp $	*/
a662 1
	rp = (struct file **)CMSG_DATA(cm);
d664 1
d681 1
d683 2
a684 1
		fp = *rp++;
d743 1
a743 1
	register struct cmsghdr *cm = mtod(control, struct cmsghdr *);
d745 1
a745 1
	register int i;
d747 1
a747 1
	int oldfds, *ip, fd;
d752 29
a780 18
	oldfds = (cm->cmsg_len - sizeof (*cm)) / sizeof (int);
	ip = (int *)(cm + 1);
	for (i = 0; i < oldfds; i++) {
		struct file *fp;
		fd = *ip++;
		if ((fp = fd_getfile(fdp, fd)) == NULL)
			return (EBADF);
		if (fp->f_count == LONG_MAX-2 ||
		    fp->f_msgcount == LONG_MAX-2)
			return (EDEADLK);
	}
	ip = (int *)(cm + 1);
	if (sizeof(int) != sizeof(struct file *)) {
		MGET(n, M_WAIT, MT_DATA);
		rp = (struct file **)mtod(n, caddr_t);
	} else
		rp = (struct file **)ip;
	for (i = 0; i < oldfds; i++) {
d783 9
a791 2
		fp = fd_getfile(fdp, fd);
		/* XXX - are ew really sure that this will never fail? */
d793 1
a793 1
		rp++;
d798 9
a806 4
	if (n) {
		m_adj(control, -(oldfds * sizeof(int)));
		n->m_len = oldfds * sizeof(struct file *);
		m_cat(control, n);
d808 4
a811 1
	return (0);
a832 2
			if (fp->f_count == 0)
				continue;
d837 2
a842 1
				fp->f_flag |= FMARK;
d844 2
d868 1
a868 1
			unp_scan(so->so_rcv.sb_mb, unp_mark);
d938 1
a938 1
		unp_scan(m, unp_discard);
d942 2
a943 2
unp_scan(m0, op)
	register struct mbuf *m0;
d945 1
d947 1
a947 1
	register struct mbuf *m;
d949 2
a950 2
	register struct cmsghdr *cm;
	register int i;
d954 1
a954 1
		for (m = m0; m; m = m->m_next)
d961 3
a963 2
				qfds = (cm->cmsg_len - sizeof *cm) / sizeof (int);
				rp = (struct file **)(cm + 1);
d965 4
a968 1
					bcopy(rp, &fp, sizeof fp);
a969 1
					(*op)(fp);
d973 2
a974 1
		m0 = m0->m_act;
d985 10
a994 2
	unp_defer++;
	fp->f_flag |= (FMARK|FDEFER);
d1002 2
@


1.17
log
@Add counting of temporary references to a struct file (as opposed to references
from fd tables and other long-lived objects). This is to avoid races between
using a file descriptor and having another process (with shared fd table)
close it. We use a separate refence count so that error values from close(2)
will be correctly returned to the caller of close(2).

The macros for those reference counts are FILE_USE(fp) and FILE_UNUSE(fp).

Make sure that the cases where closef can be called "incorrectly" (most notably
dup2(2)) are handled.

Right now only callers of closef (and {,p}read) use FILE_{,UN}USE correctly,
more fixes incoming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.16 2002/02/02 16:05:58 art Exp $	*/
d890 1
a890 1
			FILE_USE(fp);
d960 1
a960 1
	FILE_USE(fp);
@


1.16
log
@Be more consistent about using fd_getfile where it matters.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.15 2001/10/26 12:03:27 art Exp $	*/
d890 1
d898 1
a898 1
		(void) closef(*fpp, (struct proc *)0);
d960 1
d963 1
a963 1
	(void) closef(fp, (struct proc *)0);
@


1.15
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.14 2001/10/26 10:39:31 art Exp $	*/
d753 1
d755 1
a755 1
		if (fd_getfile(fdp, fd) == NULL)
d757 2
a758 2
		if (fdp->fd_ofiles[fd]->f_count == LONG_MAX-2 ||
		    fdp->fd_ofiles[fd]->f_msgcount == LONG_MAX-2)
d770 2
a771 1
		fp = fdp->fd_ofiles[fd];
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.15 2001/10/26 12:03:27 art Exp $	*/
d663 1
a664 1
		rp = ((struct file **)CMSG_DATA(cm));
a680 1
	rp = ((struct file **)CMSG_DATA(cm));
d682 1
a682 2
		bcopy(rp, &fp, sizeof(fp));
		rp++;
d741 1
a741 1
	struct cmsghdr *cm = mtod(control, struct cmsghdr *);
d743 1
a743 1
	int i, error;
d745 1
a745 1
	int nfds, *ip, fd, neededspace;
d750 17
a766 29
	nfds = (cm->cmsg_len - CMSG_ALIGN(sizeof(*cm))) / sizeof (int);

	/* Make sure we have room for the struct file pointers */
morespace:
	neededspace = CMSG_SPACE(nfds * sizeof(struct file *)) -
	    control->m_len;
	if (neededspace > M_TRAILINGSPACE(control)) {
		/* if we already have a cluster, the message is just too big */
		if (control->m_flags & M_EXT)
			return (E2BIG);

		/* allocate a cluster and try again */
		MCLGET(control, M_WAIT);
		if ((control->m_flags & M_EXT) == 0)
			return (ENOBUFS);       /* allocation failed */

		/* copy the data to the cluster */
		memcpy(mtod(control, char *), cm, cm->cmsg_len);
		cm = mtod(control, struct cmsghdr *);
		goto morespace;
	}

	/* adjust message & mbuf to note amount of space actually used. */
	cm->cmsg_len = CMSG_LEN(nfds * sizeof(struct file *));
	control->m_len = CMSG_SPACE(nfds * sizeof(struct file *));

	ip = ((int *)CMSG_DATA(cm)) + nfds - 1;
	rp = ((struct file **)CMSG_DATA(cm)) + nfds - 1;
	for (i = 0; i < nfds; i++) {
d768 2
a769 10
		ip--;
		if ((fp = fd_getfile(fdp, fd)) == NULL) {
			error = EBADF;
			goto fail;
		}
		if (fp->f_count == LONG_MAX-2 ||
		    fp->f_msgcount == LONG_MAX-2) {
			error = EDEADLK;
			goto fail;
		}
d771 1
a771 1
		rp--;
d776 5
a781 13
fail:
	/* Back out what we just did. */
	for ( ; i > 0; i--) {
		bcopy(rp, &fp, sizeof(fp));
		rp++;
		fp->f_count--;
		fp->f_msgcount--;
		unp_rights--;
	}
	if (n)
		m_freem(n);

	return (error);
d803 2
a808 2
				if (fp->f_count == 0)
					continue;
d813 1
a814 2
			fp->f_flag |= FMARK;

d837 1
a837 1
			unp_scan(so->so_rcv.sb_mb, unp_mark, 0);
a887 1
			FREF(fp);
d895 1
a895 1
		(void) closef(*fpp, NULL);
d906 1
a906 1
		unp_scan(m, unp_discard, 1);
d910 3
a912 4
unp_scan(m0, op, discard)
	struct mbuf *m0;
	void (*op)(struct file *);
	int discard;
d914 1
a914 1
	struct mbuf *m;
d916 2
a917 2
	struct cmsghdr *cm;
	int i;
d921 1
a921 1
		for (m = m0; m; m = m->m_next) {
d928 2
a929 3
				qfds = (cm->cmsg_len - CMSG_ALIGN(sizeof *cm))
				    / sizeof(struct file *);
				rp = (struct file **)CMSG_DATA(cm);
d931 2
a932 3
					fp = *rp;
					if (discard)
						*rp = 0;
a933 1
					rp++;
d937 1
a937 2
		}
		m0 = m0->m_nextpkt;
d948 2
a949 10

	if (fp->f_flag & FDEFER)
		return;

	if (fp->f_type == DTYPE_SOCKET) {
		unp_defer++;
		fp->f_flag |= FDEFER;
	} else {
		fp->f_flag |= FMARK;
	}
a956 3
	if (fp == NULL)
		return;
	FREF(fp);
d959 1
a959 1
	(void) closef(fp, NULL);
@


1.15.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.15.2.1 2002/06/11 03:29:40 art Exp $	*/
d829 1
a829 1
	LIST_FOREACH(fp, &filehead, f_list)
d832 1
a832 1
		LIST_FOREACH(fp, &filehead, f_list) {
d911 1
a911 1
	for (nunref = 0, fp = LIST_FIRST(&filehead), fpp = extra_ref; fp != 0;
d913 1
a913 1
		nextfp = LIST_NEXT(fp, f_list);
@


1.14
log
@ - split fdalloc into two functions. fdalloc now returns ENOSPC if it
   would have to grow the table and fdexpand that grows the table. Since
   fdexpand can sleep we have to restart all operations if we have to call
   it.
 - dup2 changed so that finishdup frees the destination descriptor.
 - unp_externalize is a completly rewritten version from NetBSD.

Changes mostly inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.13 2001/06/26 19:56:52 dugsong Exp $	*/
d754 1
a754 2
		if ((unsigned)fd >= fdp->fd_nfiles ||
		    fdp->fd_ofiles[fd] == NULL)
@


1.13
log
@implement djb's getpeereid(2), to allow local-domain servers to determine client credentials. mostly from superscript.com. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.12 2001/04/06 04:42:07 csapuntz Exp $	*/
d626 35
a660 4
	register struct cmsghdr *cm = mtod(rights, struct cmsghdr *);
	struct file **rp = (struct file **)(cm + 1), *fp;
	int newfds = (cm->cmsg_len - sizeof(*cm)) / sizeof (int);
	int i, f, *ip;
d662 4
a665 2
	if (!fdavail(p, newfds)) {
		for (i = 0; i < newfds; i++) {
d667 5
a672 1
			*rp++ = 0;
d674 36
a709 1
		return (EMSGSIZE);
d711 8
a718 7
	ip = (int *)rp;
	for (i = 0; i < newfds; i++) {
		if (fdalloc(p, 0, &f))
			panic("unp_externalize");
		bcopy(rp, &fp, sizeof fp);
		rp++;
		p->p_fd->fd_ofiles[f] = fp;
a720 2
		bcopy(&f, ip, sizeof f);
		ip++;
d722 11
a732 1
	return (0);
@


1.12
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.11 1999/10/11 19:49:39 deraadt Exp $	*/
d293 9
d496 4
a499 1
				  m_copy(unp2->unp_addr, 0, (int)M_COPYALL);
@


1.11
log
@for AF_UNIX, do not follow symlinks when creating sockets, terminate
names more carefully; art
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.10 1999/02/05 04:14:19 angelos Exp $	*/
a405 1
#define offsetof(s, e) ((char *)&((s *)0)->e - (char *)((s *)0))
@


1.11.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.12 2001/04/06 04:42:07 csapuntz Exp $	*/
d406 1
@


1.11.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.11.4.1 2001/05/14 22:32:45 niklas Exp $	*/
a292 9
	case PRU_PEEREID:
		if (unp->unp_flags & UNP_FEIDS) {
			nam->m_len = sizeof(struct unpcbid);
			bcopy((caddr_t)(&(unp->unp_connid)),
			    mtod(nam, caddr_t), (unsigned)nam->m_len);
		} else
			nam->m_len = 0;
		break;

d487 1
a487 4
			    m_copy(unp2->unp_addr, 0, (int)M_COPYALL);
		unp3->unp_connid.unp_euid = p->p_ucred->cr_uid;
		unp3->unp_connid.unp_egid = p->p_ucred->cr_gid;
		unp3->unp_flags |= UNP_FEIDS;
@


1.11.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.11.4.2 2001/07/04 10:48:46 niklas Exp $	*/
d626 4
a629 35
	struct cmsghdr *cm = mtod(rights, struct cmsghdr *);
	int i, *fdp;
	struct file **rp;
	struct file *fp;
	int nfds, error = 0;

	nfds = (cm->cmsg_len - CMSG_ALIGN(sizeof(*cm))) /
	    sizeof(struct file *);
	rp = (struct file **)CMSG_DATA(cm);

	fdp = malloc(nfds * sizeof(int), M_TEMP, M_WAITOK);

#ifdef notyet
	/* Make sure the recipient should be able to see the descriptors.. */
	if (p->p_cwdi->cwdi_rdir != NULL) {
		rp = (struct file **)CMSG_DATA(cm);
		for (i = 0; i < nfds; i++) {
			fp = *rp++;
			/*
			 * If we are in a chroot'ed directory, and
			 * someone wants to pass us a directory, make
			 * sure it's inside the subtree we're allowed
			 * to access.
			 */
			if (fp->f_type == DTYPE_VNODE) {
				struct vnode *vp = (struct vnode *)fp->f_data;
				if ((vp->v_type == VDIR) &&
				    !vn_isunder(vp, p->p_cwdi->cwdi_rdir, p)) {
					error = EPERM;
					break;
				}
			}
		}
	}
#endif
d631 2
a632 4
restart:
	rp = (struct file **)CMSG_DATA(cm);
	if (error != 0) {
		for (i = 0; i < nfds; i++) {
d634 1
a634 4
			/*
			 * zero the pointer before calling unp_discard,
			 * since it may end up in unp_gc()..
			 */
a635 1
			unp_discard(fp);
d637 1
a637 1
		goto out;
d639 7
a645 43

	/*
	 * First loop -- allocate file descriptor table slots for the
	 * new descriptors.
	 */
	for (i = 0; i < nfds; i++) {
		fp = *rp++;
		if ((error = fdalloc(p, 0, &fdp[i])) != 0) {
			/*
			 * Back out what we've done so far.
			 */
			for (--i; i >= 0; i--)
				fdremove(p->p_fd, fdp[i]);

			if (error == ENOSPC) {
				fdexpand(p);
				error = 0;
			} else {
				/*
				 * This is the error that has historically
				 * been returned, and some callers may
				 * expect it.
				 */
				error = EMSGSIZE;
			}
			goto restart;
		}

		/*
		 * Make the slot reference the descriptor so that
		 * fdalloc() works properly.. We finalize it all
		 * in the loop below.
		 */
		p->p_fd->fd_ofiles[fdp[i]] = fp;
	}

	/*
	 * Now that adding them has succeeded, update all of the
	 * descriptor passing state.
	 */
	rp = (struct file **)CMSG_DATA(cm);
	for (i = 0; i < nfds; i++) {
		fp = *rp++;
d648 2
d651 1
a651 11

	/*
	 * Copy temporary array to message and adjust length, in case of
	 * transition from large struct file pointers to ints.
	 */
	memcpy(CMSG_DATA(cm), fdp, nfds * sizeof(int));
	cm->cmsg_len = CMSG_LEN(nfds * sizeof(int));
	rights->m_len = CMSG_SPACE(nfds * sizeof(int));
 out:
	free(fdp, M_TEMP);
	return (error);
d673 2
a674 1
		if (fd_getfile(fdp, fd) == NULL)
@


1.11.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d663 1
a664 1
		rp = ((struct file **)CMSG_DATA(cm));
a680 1
	rp = ((struct file **)CMSG_DATA(cm));
d682 1
a682 2
		bcopy(rp, &fp, sizeof(fp));
		rp++;
d741 1
a741 1
	struct cmsghdr *cm = mtod(control, struct cmsghdr *);
d743 1
a743 1
	int i, error;
d745 1
a745 1
	int nfds, *ip, fd, neededspace;
d750 17
a766 29
	nfds = (cm->cmsg_len - CMSG_ALIGN(sizeof(*cm))) / sizeof (int);

	/* Make sure we have room for the struct file pointers */
morespace:
	neededspace = CMSG_SPACE(nfds * sizeof(struct file *)) -
	    control->m_len;
	if (neededspace > M_TRAILINGSPACE(control)) {
		/* if we already have a cluster, the message is just too big */
		if (control->m_flags & M_EXT)
			return (E2BIG);

		/* allocate a cluster and try again */
		MCLGET(control, M_WAIT);
		if ((control->m_flags & M_EXT) == 0)
			return (ENOBUFS);       /* allocation failed */

		/* copy the data to the cluster */
		memcpy(mtod(control, char *), cm, cm->cmsg_len);
		cm = mtod(control, struct cmsghdr *);
		goto morespace;
	}

	/* adjust message & mbuf to note amount of space actually used. */
	cm->cmsg_len = CMSG_LEN(nfds * sizeof(struct file *));
	control->m_len = CMSG_SPACE(nfds * sizeof(struct file *));

	ip = ((int *)CMSG_DATA(cm)) + nfds - 1;
	rp = ((struct file **)CMSG_DATA(cm)) + nfds - 1;
	for (i = 0; i < nfds; i++) {
d768 2
a769 10
		ip--;
		if ((fp = fd_getfile(fdp, fd)) == NULL) {
			error = EBADF;
			goto fail;
		}
		if (fp->f_count == LONG_MAX-2 ||
		    fp->f_msgcount == LONG_MAX-2) {
			error = EDEADLK;
			goto fail;
		}
d771 1
a771 1
		rp--;
d776 5
a781 13
fail:
	/* Back out what we just did. */
	for ( ; i > 0; i--) {
		bcopy(rp, &fp, sizeof(fp));
		rp++;
		fp->f_count--;
		fp->f_msgcount--;
		unp_rights--;
	}
	if (n)
		m_freem(n);

	return (error);
d803 2
a808 2
				if (fp->f_count == 0)
					continue;
d813 1
a814 2
			fp->f_flag |= FMARK;

d837 1
a837 1
			unp_scan(so->so_rcv.sb_mb, unp_mark, 0);
a887 1
			FREF(fp);
d895 1
a895 1
		(void) closef(*fpp, NULL);
d906 1
a906 1
		unp_scan(m, unp_discard, 1);
d910 2
a911 2
unp_scan(m0, op, discard)
	struct mbuf *m0;
a912 1
	int discard;
d914 1
a914 1
	struct mbuf *m;
d916 2
a917 2
	struct cmsghdr *cm;
	int i;
d921 1
a921 1
		for (m = m0; m; m = m->m_next) {
d928 2
a929 3
				qfds = (cm->cmsg_len - CMSG_ALIGN(sizeof *cm))
				    / sizeof(struct file *);
				rp = (struct file **)CMSG_DATA(cm);
d931 2
a932 3
					fp = *rp;
					if (discard)
						*rp = 0;
a933 1
					rp++;
d937 1
a937 2
		}
		m0 = m0->m_nextpkt;
d948 2
a949 10

	if (fp->f_flag & FDEFER)
		return;

	if (fp->f_type == DTYPE_SOCKET) {
		unp_defer++;
		fp->f_flag |= FDEFER;
	} else {
		fp->f_flag |= FMARK;
	}
a956 3
	if (fp == NULL)
		return;
	FREF(fp);
d959 1
a959 1
	(void) closef(fp, NULL);
@


1.11.4.5
log
@Merge in -current from about a week ago
@
text
@d944 1
a944 1
	void (*op)(struct file *);
@


1.11.4.6
log
@Sync the SMP branch with 3.3
@
text
@d829 1
a829 1
	LIST_FOREACH(fp, &filehead, f_list)
d832 1
a832 1
		LIST_FOREACH(fp, &filehead, f_list) {
d911 1
a911 1
	for (nunref = 0, fp = LIST_FIRST(&filehead), fpp = extra_ref; fp != 0;
d913 1
a913 1
		nextfp = LIST_NEXT(fp, f_list);
@


1.11.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.11.4.6 2003/03/28 00:41:27 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a658 1
	fdplock(p->p_fd, p);
a698 1
			fdpunlock(p->p_fd);
a728 1
	fdpunlock(p->p_fd);
d742 1
d804 2
@


1.11.4.9
log
@Merge with the trunk
@
text
@d80 1
a80 1
	if (unp == NULL && req != PRU_ATTACH) {
d103 1
a103 1
		if (unp->unp_vnode == NULL)
d150 1
a150 1
			if (unp->unp_conn == NULL)
d188 1
a188 1
				if (unp->unp_conn == NULL) {
d200 2
a201 2
				m = NULL;
				control = NULL;
d216 1
a216 1
			if (unp->unp_conn == NULL)
d226 1
a226 1
					control = NULL;
d235 1
a235 1
			m = NULL;
d251 1
a251 1
		if (so->so_type == SOCK_STREAM && unp->unp_conn != NULL) {
d370 1
a370 1
		unp->unp_vnode->v_socket = NULL;
d372 1
a372 1
		unp->unp_vnode = NULL;
d379 1
a379 1
	unp->unp_socket->so_pcb = NULL;
d474 1
a474 1
	if (so2 == NULL) {
d542 1
a542 1
	if (unp2 == NULL)
d544 1
a544 1
	unp->unp_conn = NULL;
d553 1
a553 1
				if (unp2 == NULL)
d561 1
a561 1
		unp->unp_nextref = NULL;
d567 1
a567 1
		unp2->unp_conn = NULL;
d603 1
a603 1
		so->so_pcb = NULL;
d668 1
a668 1
			*rp++ = NULL;
d843 1
a843 1
			    (so = (struct socket *)fp->f_data) == NULL)
d907 2
a908 2
	for (nunref = 0, fp = LIST_FIRST(&filehead), fpp = extra_ref;
	    fp != NULL; fp = nextfp) {
@


1.10
log
@Check that a socket we're closing is really a socket. dillon@@freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.9 1998/03/01 19:34:15 deraadt Exp $	*/
d400 1
a400 1
	int error;
d402 1
a403 2
	NDINIT(&nd, CREATE, FOLLOW | LOCKPARENT, UIO_SYSSPACE,
	    soun->sun_path, p);
d406 7
a412 5
	if (nam->m_len == MLEN) {
		if (*(mtod(nam, caddr_t) + nam->m_len - 1) != 0)
			return (EINVAL);
	} else
		*(mtod(nam, caddr_t) + nam->m_len) = 0;
@


1.9
log
@crank f_count/f_msgcount to long; when incrementing try to leave 2 slots
empty for unp_gc() in case of cross referenced sockets. part by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.8 1997/11/17 18:09:15 deraadt Exp $	*/
d800 2
a801 1
		sorflush((struct socket *)(*fpp)->f_data);
@


1.8
log
@kleink: When fstat(2)ing a file descriptor of a local communications domain
socket, fill the socket's creation time into the stat structure's st_[acm]time
fields: POSIX requires this behavior for pipe(2). N.B.: updating the
st_[am]time fields when reading/writing the pipe is neither required nor
implemented, though.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.7 1997/11/06 05:58:25 csapuntz Exp $	*/
d664 3
d753 1
a753 1
	 * The bug in the orginal code is a little tricky, so I'll describe
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.6 1997/10/06 20:20:06 deraadt Exp $	*/
d262 3
d328 1
d354 2
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.4 1997/06/05 08:13:12 deraadt Exp $	*/
d430 1
a430 1
	VOP_UNLOCK(vp);
@


1.5
log
@VFS Lite2 Changes
@
text
@d430 1
a430 1
	VOP_UNLOCK(vp, 0, p);
@


1.4
log
@fix sendmsg() credential passing on 64 bit machines, i hope. (this was hellish)
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.3 1996/06/25 21:26:11 deraadt Exp $	*/
d430 1
a430 1
	VOP_UNLOCK(vp);
@


1.3
log
@consider umask for AF_UNIX bind()
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_usrreq.c,v 1.2 1996/03/03 17:20:22 niklas Exp $	*/
a607 1
	register int i;
d609 1
a609 2
	register struct file **rp = (struct file **)(cm + 1);
	register struct file *fp;
d611 1
a611 1
	int f;
d621 1
d625 2
a626 1
		fp = *rp;
d630 2
a631 1
		*(int *)rp++ = f;
d643 4
a646 4
	register struct file **rp;
	register struct file *fp;
	register int i, fd;
	int oldfds;
d652 1
a652 1
	rp = (struct file **)(cm + 1);
d654 1
a654 1
		fd = *(int *)rp++;
d659 6
a664 1
	rp = (struct file **)(cm + 1);
d666 5
a670 2
		fp = fdp->fd_ofiles[*(int *)rp];
		*rp++ = fp;
d675 5
d813 1
a813 1
	register struct file **rp;
d826 1
a826 2
				qfds = (cm->cmsg_len - sizeof *cm)
						/ sizeof (struct file *);
d828 5
a832 2
				for (i = 0; i < qfds; i++)
					(*op)(*rp++);
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d421 1
a421 1
	vattr.va_mode = ACCESSPERMS;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: uipc_usrreq.c,v 1.15 1995/08/17 02:57:20 mycroft Exp $	*/
d353 1
a353 1
int
d407 1
a407 1
	if (error = namei(&nd))
d423 2
a424 1
	if (error = VOP_CREATE(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &vattr))
d453 1
a453 1
	if (error = namei(&nd))
d460 1
a460 1
	if (error = VOP_ACCESS(vp, VWRITE, p->p_ucred, p))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

