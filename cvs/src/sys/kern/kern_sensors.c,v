head	1.38;
access;
symbols
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.36.0.10
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.24.0.12
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.10
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.8
	OPENBSD_5_0:1.24.0.6
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.21.0.6
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7;
locks; strict;
comment	@ * @;


1.38
date	2017.04.09.15.47.18;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	06qImH2u9L5tg1W0;

1.37
date	2017.04.08.04.06.01;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	Y9YNKWu5EX2Z4WOG;

1.36
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.35;
commitid	p4LJxGKbi0BU2cG6;

1.35
date	2015.02.09.03.15.41;	author dlg;	state Exp;
branches;
next	1.34;
commitid	jVd0KngVszV2FEfg;

1.34
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.33;
commitid	MyKPm9Q3dQu92BiX;

1.33
date	2014.11.14.23.26.48;	author tedu;	state Exp;
branches;
next	1.32;
commitid	Xw9eD6Y0JOIFIwDy;

1.32
date	2014.11.08.13.36.51;	author jasper;	state Exp;
branches;
next	1.31;
commitid	YCnyi4lG3P5X2an9;

1.31
date	2014.11.04.18.29.32;	author jasper;	state Exp;
branches;
next	1.30;
commitid	SdFRepPuoakbhpry;

1.30
date	2014.11.01.23.58.28;	author tedu;	state Exp;
branches;
next	1.29;
commitid	9PQjDNhyphSHE6E7;

1.29
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.28;
commitid	uzzBR7hz9ncd4O6G;

1.28
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.27;
commitid	QlVV51SZgNFxsXxC;

1.27
date	2013.12.09.17.39.08;	author mikeb;	state Exp;
branches;
next	1.26;

1.26
date	2013.11.04.00.25.14;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.28.16.58.45;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.20.20.49.33;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.03.07.08.33;	author blambert;	state Exp;
branches;
next	1.22;

1.22
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.03.03.22.34;	author cnst;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.04.18.42.05;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.01.04.15.45;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.23.17.41.26;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.06.11.35.15;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.28.16.43.50;	author mk;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.28.03.22.35;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2006.05.28.02.26.28;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2006.05.28.01.33.50;	author mk;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.28.00.24.00;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.27.23.51.27;	author mk;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.12.13.48.32;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2006.01.28.09.53.37;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.19.17.08.40;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.21.13.47.52;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2005.11.13.22.41.56;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2005.11.10.08.32.56;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2005.11.10.08.20.20;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2005.11.10.08.10.16;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Correct wakeup() dance in sensor_task_work()
Problem noticed by krw
@
text
@/*	$OpenBSD: kern_sensors.c,v 1.37 2017/04/08 04:06:01 deraadt Exp $	*/

/*
 * Copyright (c) 2005 David Gwynne <dlg@@openbsd.org>
 * Copyright (c) 2006 Constantine A. Murenin <cnst+openbsd@@bugmail.mojo.ru>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/device.h>
#include <sys/hotplug.h>
#include <sys/timeout.h>
#include <sys/task.h>
#include <sys/rwlock.h>
#include <sys/atomic.h>

#include <sys/sensors.h>
#include "hotplug.h"

struct taskq		*sensors_taskq;
int			sensordev_count;
SLIST_HEAD(, ksensordev) sensordev_list =
    SLIST_HEAD_INITIALIZER(sensordev_list);

void
sensordev_install(struct ksensordev *sensdev)
{
	struct ksensordev *v, *nv;
	int s;

	s = splhigh();
	if (sensordev_count == 0) {
		sensdev->num = 0;
		SLIST_INSERT_HEAD(&sensordev_list, sensdev, list);
	} else {
		for (v = SLIST_FIRST(&sensordev_list);
		    (nv = SLIST_NEXT(v, list)) != NULL; v = nv)
			if (nv->num - v->num > 1)
				break;
		sensdev->num = v->num + 1;
		SLIST_INSERT_AFTER(v, sensdev, list);
	}
	sensordev_count++;
	splx(s);

#if NHOTPLUG > 0
	hotplug_device_attach(DV_DULL, "sensordev");
#endif
}

void
sensor_attach(struct ksensordev *sensdev, struct ksensor *sens)
{
	struct ksensor *v, *nv;
	struct ksensors_head *sh;
	int s, i;

	s = splhigh();
	sh = &sensdev->sensors_list;
	if (sensdev->sensors_count == 0) {
		for (i = 0; i < SENSOR_MAX_TYPES; i++)
			sensdev->maxnumt[i] = 0;
		sens->numt = 0;
		SLIST_INSERT_HEAD(sh, sens, list);
	} else {
		for (v = SLIST_FIRST(sh);
		    (nv = SLIST_NEXT(v, list)) != NULL; v = nv)
			if (v->type == sens->type && (v->type != nv->type || 
			    (v->type == nv->type && nv->numt - v->numt > 1)))
				break;
		/* sensors of the same type go after each other */
		if (v->type == sens->type)
			sens->numt = v->numt + 1;
		else
			sens->numt = 0;
		SLIST_INSERT_AFTER(v, sens, list);
	}
	/* we only increment maxnumt[] if the sensor was added
	 * to the last position of sensors of this type
	 */
	if (sensdev->maxnumt[sens->type] == sens->numt)
		sensdev->maxnumt[sens->type]++;
	sensdev->sensors_count++;
	splx(s);
}

void
sensordev_deinstall(struct ksensordev *sensdev)
{
	int s;

	s = splhigh();
	sensordev_count--;
	SLIST_REMOVE(&sensordev_list, sensdev, ksensordev, list);
	splx(s);

#if NHOTPLUG > 0
	hotplug_device_detach(DV_DULL, "sensordev");
#endif
}

void
sensor_detach(struct ksensordev *sensdev, struct ksensor *sens)
{
	struct ksensors_head *sh;
	int s;

	s = splhigh();
	sh = &sensdev->sensors_list;
	sensdev->sensors_count--;
	SLIST_REMOVE(sh, sens, ksensor, list);
	/* we only decrement maxnumt[] if this is the tail 
	 * sensor of this type
	 */
	if (sens->numt == sensdev->maxnumt[sens->type] - 1)
		sensdev->maxnumt[sens->type]--;
	splx(s);
}

int
sensordev_get(int num, struct ksensordev **sensdev)
{
	struct ksensordev *sd;

	SLIST_FOREACH(sd, &sensordev_list, list) {
		if (sd->num == num) {
			*sensdev = sd;
			return (0);
		}
		if (sd->num > num)
			return (ENXIO);
	}
	return (ENOENT);
}

int
sensor_find(int dev, enum sensor_type type, int numt, struct ksensor **ksensorp)
{
	struct ksensor *s;
	struct ksensordev *sensdev;
	struct ksensors_head *sh;
	int ret;

	ret = sensordev_get(dev, &sensdev);
	if (ret)
		return (ret);

	sh = &sensdev->sensors_list;
	SLIST_FOREACH(s, sh, list)
		if (s->type == type && s->numt == numt) {
			*ksensorp = s;
			return (0);
		}

	return (ENOENT);
}

struct sensor_task {
	void				(*func)(void *);
	void				*arg;

	unsigned int			period;
	struct timeout			timeout;
	struct task			task;
	struct rwlock			lock;
};

void	sensor_task_tick(void *);
void	sensor_task_work(void *);

struct sensor_task *
sensor_task_register(void *arg, void (*func)(void *), unsigned int period)
{
	struct sensor_task *st;

#ifdef DIAGNOSTIC
	if (period == 0)
		panic("sensor_task_register: period is 0");
#endif

	if (sensors_taskq == NULL &&
	    (sensors_taskq = taskq_create("sensors", 1, IPL_HIGH, 0)) == NULL)
		sensors_taskq = systq;

	st = malloc(sizeof(*st), M_DEVBUF, M_NOWAIT);
	if (st == NULL)
		return (NULL);

	st->func = func;
	st->arg = arg;
	st->period = period;
	timeout_set(&st->timeout, sensor_task_tick, st);
	task_set(&st->task, sensor_task_work, st);
	rw_init(&st->lock, "sensor");

	sensor_task_tick(st);

	return (st);
}

void
sensor_task_unregister(struct sensor_task *st)
{
	/*
	 * we can't reliably timeout_del or task_del because there's a window
	 * between when they come off the lists and the timeout or task code
	 * actually runs the respective handlers for them. mark the sensor_task
	 * as dying by setting period to 0 and let sensor_task_work mop up.
	 */

	rw_enter_write(&st->lock);
	st->period = 0;
	rw_exit_write(&st->lock);
}

void
sensor_task_tick(void *arg)
{
	struct sensor_task *st = arg;
	task_add(sensors_taskq, &st->task);
}

static int sensors_quiesced;
static int sensors_running;

void
sensor_quiesce(void)
{
	sensors_quiesced = 1;
	while (sensors_running > 0)
		tsleep(&sensors_running, PZERO, "sensorpause", 0);
	
}
void
sensor_restart(void)
{
	sensors_quiesced = 0;
}

void
sensor_task_work(void *xst)
{
	struct sensor_task *st = xst;
	unsigned int period = 0;

	atomic_inc_int(&sensors_running);
	rw_enter_write(&st->lock);
	period = st->period;
	if (period > 0 && !sensors_quiesced)
		st->func(st->arg);
	rw_exit_write(&st->lock);
	if (atomic_dec_int_nv(&sensors_running) == 0) {
		if (sensors_quiesced)
			wakeup(&sensors_running);
	}

	if (period == 0)
		free(st, M_DEVBUF, sizeof(*st));
	else 
		timeout_add_sec(&st->timeout, period);
}
@


1.37
log
@Sensors are run as callbacks inside tasks.  During suspend a sensor
could be running inside a driver that will be force-detached, or due
to tsleep end up disrupting the softstate/hardstate contract.  At
suspend time, quisce all these callbacks by waiting for completion.
This issue has never been observed for real, but may be implicated in
suspend/resume failures.
ok kettenis guenther mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.36 2015/03/14 03:38:50 jsg Exp $	*/
d266 4
a269 2
	if (sensors_quiesced && atomic_dec_int_nv(&sensors_running) == 0)
		wakeup(&sensors_running);
@


1.36
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.35 2015/02/09 03:15:41 dlg Exp $	*/
d29 1
d237 17
d260 1
d263 1
a263 1
	if (period > 0)
d266 2
@


1.35
log
@we want to defer work traditionally (in openbsd) handled in an
interrupt context to a taskq running in a thread. however, there
is a concern that if we do that then we allow accidental use of
sleeping APIs in this work, which will make it harder to move the
work back to interrupts in the future.

guenther and kettenis came up with the idea of marking a proc with
CANTSLEEP which the sleep paths can check and panic on.

this builds on that so you create taskqs that run with CANTSLEEP
set except when they need to sleep for more tasks to run.

the taskq_create api is changed to take a flags argument so users
can specify CANTSLEEP. MPSAFE is also passed via this flags field
now.  this means archs that defined IPL_MPSAFE to 0 can now create
mpsafe taskqs too.

lots of discussion at s2k15
ok guenther@@ miod@@ mpi@@ tedu@@ pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.34 2015/01/27 03:17:36 dlg Exp $	*/
a21 1
#include <sys/kernel.h>
@


1.34
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.33 2014/11/14 23:26:48 tedu Exp $	*/
d196 1
a196 1
	    (sensors_taskq = taskq_create("sensors", 1, IPL_HIGH)) == NULL)
@


1.33
log
@prefer sizeof(*ptr) to sizeof(struct) for malloc and free
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.32 2014/11/08 13:36:51 jasper Exp $	*/
d183 1
a183 1
void	sensor_task_work(void *, void *);
d207 1
a207 1
	task_set(&st->task, sensor_task_work, st, NULL);
d238 1
a238 1
sensor_task_work(void *xst, void *arg)
@


1.32
log
@some systems install sensors where numbering introduces a gap which
falsely triggered the added panic. revert the panic for now while a
better solution is being worked on

as reported by Bjorn Ketelaars on misc@@ via jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.31 2014/11/04 18:29:32 jasper Exp $	*/
d199 1
a199 1
	st = malloc(sizeof(struct sensor_task), M_DEVBUF, M_NOWAIT);
d250 1
a250 1
		free(st, M_DEVBUF, sizeof(struct sensor_task));
@


1.31
log
@panic when a sensordev gets installed twice, instead of blowing up amazingly
later on

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.30 2014/11/01 23:58:28 tedu Exp $	*/
d53 1
a53 1
				panic("sensor installed twice");
@


1.30
log
@add a few sizes to free
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.29 2014/09/14 14:17:25 jsg Exp $	*/
d53 1
a53 1
				break;
@


1.29
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.28 2014/07/12 18:43:32 tedu Exp $	*/
d250 1
a250 1
		free(st, M_DEVBUF, 0);
@


1.28
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.27 2013/12/09 17:39:08 mikeb Exp $	*/
a20 1
#include <sys/proc.h>
@


1.27
log
@use a separate task queue for sensors;
with input from and ok kettenis, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.26 2013/11/04 00:25:14 dlg Exp $	*/
d251 1
a251 1
		free(st, M_DEVBUF);
@


1.26
log
@move kernel sensor tasks from using workqs to tasks. while here
whack the locking and task cancellation.

sensor updates tested locally, and by mpi@@ on ugold(4). ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.25 2013/03/28 16:58:45 deraadt Exp $	*/
d35 1
d196 4
d235 1
a235 1
	task_add(systq, &st->task);
@


1.25
log
@sys/param.h gets you sys/types.h automatically
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.24 2010/04/20 20:49:33 deraadt Exp $	*/
d29 2
a30 1
#include <sys/workq.h>
d176 1
a176 1
	int				period;
d178 2
a179 7
	volatile enum {
		ST_TICKING,
		ST_WORKQ,
		ST_RUNNING,
		ST_DYING,
		ST_DEAD
	}				state;
d186 1
a186 1
sensor_task_register(void *arg, void (*func)(void *), int period)
d190 5
d203 2
d214 6
a219 6
	timeout_del(&st->timeout);

	switch (st->state) {
	case ST_TICKING:
		free(st, M_DEVBUF);
		break;
d221 3
a223 14
	case ST_WORKQ:
		st->state = ST_DYING;
		break;

	case ST_RUNNING:
		st->state = ST_DYING;
		while (st->state != ST_DEAD)
			tsleep(st, 0, "stunr", 0);
		free(st, M_DEVBUF);
		break;
	default:
		panic("sensor_task_unregister: unexpected state %d",
		    st->state);
	}
d230 1
a230 6

	/* try to schedule the task */
	if (workq_add_task(NULL, 0, sensor_task_work, st, NULL) != 0)
		timeout_add_msec(&st->timeout, 500);

	st->state = ST_WORKQ;
d237 7
d245 1
a245 1
	if (st->state == ST_DYING) {
d247 2
a248 13
		return;
	}

	st->state = ST_RUNNING;
	st->func(st->arg);

	if (st->state == ST_DYING) {
		st->state = ST_DEAD;
		wakeup(st);
	} else {
		st->state = ST_TICKING;
		timeout_add_sec(&st->timeout, st->period);
	}
@


1.24
log
@Get rid of MAXSENSORDEVICES.  Gaps in sensordev lists are now handled
by returning ENXIO instead of ENOENT, to essentially indicate hotplug
sensor that has gone away.  Accessing beyond the end of the sensordev
list still returns ENOENT, so that you can see there are no further devices.
ok kettenis oga
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.23 2009/08/03 07:08:33 blambert Exp $	*/
a25 1
#include <sys/types.h>
@


1.23
log
@timeout_add -> timeout_add_msec

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.22 2008/09/10 14:01:23 blambert Exp $	*/
d35 1
a35 1
int			sensordev_count = 0;
d134 2
a135 2
struct ksensordev *
sensordev_get(int num)
d139 9
a147 5
	SLIST_FOREACH(sd, &sensordev_list, list)
		if (sd->num == num)
			return (sd);

	return (NULL);
d150 2
a151 2
struct ksensor *
sensor_find(int dev, enum sensor_type type, int numt)
d156 1
d158 3
a160 3
	sensdev = sensordev_get(dev);
	if (sensdev == NULL)
		return (NULL);
d164 4
a167 2
		if (s->type == type && s->numt == numt)
			return (s);
d169 1
a169 1
	return (NULL);
@


1.22
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.21 2007/07/03 03:22:34 cnst Exp $	*/
d235 1
a235 1
		timeout_add(&st->timeout, hz/2);
@


1.21
log
@fix a memory leak that was introduced in r1.20 on 2007-06-24T05Z; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.20 2007/06/24 05:34:35 dlg Exp $	*/
d258 1
a258 1
		timeout_add(&st->timeout, hz * st->period);
@


1.20
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.18 2007/06/01 04:15:45 dlg Exp $	*/
d220 1
d231 1
a231 1
	struct sensor_task	*st = arg;
@


1.19
log
@perhaps it made art's head hurt because it is wrong.  triggers NULL
deref in sensor_task_work(); found by krw, dlg should talk to him
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.17 2007/03/22 16:55:31 deraadt Exp $	*/
d21 1
a24 1
#include <sys/kthread.h>
a26 1
#include <sys/time.h>
d29 2
d36 2
a37 17
SLIST_HEAD(, ksensordev) sensordev_list = SLIST_HEAD_INITIALIZER(sensordev_list);

struct sensor_task {
	void				*arg;
	void				(*func)(void *);

	int				period;
	time_t				nextrun;
	volatile int			running;
	TAILQ_ENTRY(sensor_task)	entry;
};

void	sensor_task_create(void *);
void	sensor_task_thread(void *);
void	sensor_task_schedule(struct sensor_task *);

TAILQ_HEAD(, sensor_task) tasklist = TAILQ_HEAD_INITIALIZER(tasklist);
d165 19
a183 1
int
d186 1
a186 1
	struct sensor_task	*st;
d190 1
a190 1
		return (1);
d192 1
a193 1
	st->func = func;
d195 1
d197 1
a197 8
	st->running = 1;

	if (TAILQ_EMPTY(&tasklist))
		kthread_create_deferred(sensor_task_create, NULL);

	st->nextrun = 0;
	TAILQ_INSERT_HEAD(&tasklist, st, entry);
	wakeup(&tasklist);
d199 1
a199 1
	return (0);
d203 1
a203 1
sensor_task_unregister(void *arg)
d205 1
a205 1
	struct sensor_task	*st;
d207 17
a223 3
	TAILQ_FOREACH(st, &tasklist, entry) {
		if (st->arg == arg)
			st->running = 0;
d228 1
a228 1
sensor_task_create(void *arg)
d230 7
a236 2
	if (kthread_create(sensor_task_thread, NULL, NULL, "sensors") != 0)
		panic("sensors kthread");
d240 1
a240 1
sensor_task_thread(void *arg)
d242 1
a242 14
	struct sensor_task	*st, *nst;
	time_t			now;

	while (!TAILQ_EMPTY(&tasklist)) {
		while ((nst = TAILQ_FIRST(&tasklist))->nextrun >
		    (now = time_uptime))
			tsleep(&tasklist, PWAIT, "timeout",
			    (nst->nextrun - now) * hz);

		while ((st = nst) != NULL) {
			nst = TAILQ_NEXT(st, entry);

			if (st->nextrun > now)
				break;
d244 3
a246 13
			/* take it out while we work on it */
			TAILQ_REMOVE(&tasklist, st, entry);

			if (!st->running) {
				free(st, M_DEVBUF);
				continue;
			}

			/* run the task */
			st->func(st->arg);
			/* stick it back in the tasklist */
			sensor_task_schedule(st);
		}
d249 2
a250 2
	kthread_exit(0);
}
d252 6
a257 12
void
sensor_task_schedule(struct sensor_task *st)
{
	struct sensor_task 	*cst;

	st->nextrun = time_uptime + st->period;

	TAILQ_FOREACH(cst, &tasklist, entry) {
		if (cst->nextrun > st->nextrun) {
			TAILQ_INSERT_BEFORE(cst, st, entry);
			return;
		}
a258 3

	/* must be an empty list, or at the end of the list */
	TAILQ_INSERT_TAIL(&tasklist, st, entry);
a259 1

@


1.18
log
@rework the sensor task handling to run in the kernels generic workq.

apologies to art for abusing timeouts so badly. apologies to tedu for
making his head hurt.

tested by and ok tedu@@
@
text
@a29 1
#include <sys/workq.h>
d38 1
a39 1
	void				*arg;
d43 1
d47 3
a49 3
struct timeout sensor_task_to;
TAILQ_HEAD(, sensor_task) sensor_task_list =
    TAILQ_HEAD_INITIALIZER(sensor_task_list);
d51 1
a51 3
void	sensor_task_tick(void *);
void	sensor_task_schedule(struct sensor_task *);
void	sensor_task_work(void *, void *);
a190 1
	st->nextrun = 0;
d192 1
a192 4
	if (TAILQ_EMPTY(&sensor_task_list))
		timeout_set(&sensor_task_to, sensor_task_tick, NULL);
	else
		timeout_del(&sensor_task_to);
d194 2
a195 1
	TAILQ_INSERT_HEAD(&sensor_task_list, st, entry);
d197 3
a199 1
	sensor_task_tick(NULL);
d207 1
a207 8
	struct sensor_task	*st, *nst;

	timeout_del(&sensor_task_to);

	nst = TAILQ_FIRST(&sensor_task_list);
	while (nst != NULL) {
		st = nst;
		nst = TAILQ_NEXT(st, entry);
d209 1
d211 1
a211 1
			free(st, M_DEVBUF);
d213 1
d215 5
a219 4
	if (TAILQ_EMPTY(&sensor_task_list))
		return;

	sensor_task_tick(NULL);
d223 1
a223 1
sensor_task_tick(void *arg)
d226 7
a232 1
	time_t			now = time_uptime;
d234 2
a235 4
#ifdef DIAGNOSTIC
	if (TAILQ_EMPTY(&sensor_task_list))
		panic("sensor task tick for no sensors");
#endif
d237 2
a238 10
	nst = TAILQ_FIRST(&sensor_task_list);
	while (nst->nextrun <= now) {
		st = nst;
		nst = TAILQ_NEXT(st, entry);

		/* try to schedule the task */
		if (workq_add_task(NULL, 0, sensor_task_work, st, NULL) != 0) {
			timeout_add(&sensor_task_to, hz);
			return;
		}
d240 2
a241 2
		/* take it out while we work on it */
		TAILQ_REMOVE(&sensor_task_list, st, entry);
d243 10
a252 2
		if (nst == NULL)
			return;
d255 1
a255 14
	timeout_add(&sensor_task_to, (nst->nextrun - now) * hz);
}

void
sensor_task_work(void *xst, void *arg)
{
	struct sensor_task	*st = xst;

	timeout_del(&sensor_task_to);

	st->func(st->arg);
	sensor_task_schedule(st);

	sensor_task_tick(NULL);
d261 1
a261 1
	struct sensor_task	*cst;
d265 1
a265 1
	TAILQ_FOREACH(cst, &sensor_task_list, entry) {
d273 1
a273 1
	TAILQ_INSERT_TAIL(&sensor_task_list, st, entry);
d275 1
@


1.17
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.16 2006/12/23 17:41:26 deraadt Exp $	*/
d30 1
d39 1
a40 1
	void				(*func)(void *);
a43 1
	volatile int			running;
d47 5
a51 2
void	sensor_task_create(void *);
void	sensor_task_thread(void *);
d53 1
a53 2

TAILQ_HEAD(, sensor_task) tasklist = TAILQ_HEAD_INITIALIZER(tasklist);
d193 1
d195 4
a198 1
	st->running = 1;
d200 1
a200 2
	if (TAILQ_EMPTY(&tasklist))
		kthread_create_deferred(sensor_task_create, NULL);
d202 1
a202 3
	st->nextrun = 0;
	TAILQ_INSERT_HEAD(&tasklist, st, entry);
	wakeup(&tasklist);
d210 8
a217 1
	struct sensor_task	*st;
a218 1
	TAILQ_FOREACH(st, &tasklist, entry) {
d220 1
a220 1
			st->running = 0;
a221 1
}
d223 4
a226 5
void
sensor_task_create(void *arg)
{
	if (kthread_create(sensor_task_thread, NULL, NULL, "sensors") != 0)
		panic("sensors kthread");
d230 1
a230 1
sensor_task_thread(void *arg)
d233 1
a233 1
	time_t			now;
d235 4
a238 5
	while (!TAILQ_EMPTY(&tasklist)) {
		while ((nst = TAILQ_FIRST(&tasklist))->nextrun >
		    (now = time_uptime))
			tsleep(&tasklist, PWAIT, "timeout",
			    (nst->nextrun - now) * hz);
d240 20
a259 2
		while ((st = nst) != NULL) {
			nst = TAILQ_NEXT(st, entry);
d261 4
a264 2
			if (st->nextrun > now)
				break;
d266 1
a266 2
			/* take it out while we work on it */
			TAILQ_REMOVE(&tasklist, st, entry);
d268 2
a269 11
			if (!st->running) {
				free(st, M_DEVBUF);
				continue;
			}

			/* run the task */
			st->func(st->arg);
			/* stick it back in the tasklist */
			sensor_task_schedule(st);
		}
	}
d271 1
a271 1
	kthread_exit(0);
d277 1
a277 1
	struct sensor_task 	*cst;
d281 1
a281 1
	TAILQ_FOREACH(cst, &tasklist, entry) {
d289 1
a289 1
	TAILQ_INSERT_TAIL(&tasklist, st, entry);
a290 1

@


1.16
log
@kernel code implimemting the new two-level sensor api; written by
Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.15 2006/11/06 11:35:15 dlg Exp $	*/
d35 1
a35 1
SLIST_HEAD(, sensordev)	sensordev_list = SLIST_HEAD_INITIALIZER(sensordev_list);
d54 1
a54 1
sensordev_install(struct sensordev *sensdev)
d56 1
a56 1
	struct sensordev *v, *nv;
d80 1
a80 1
sensor_attach(struct sensordev *sensdev, struct sensor *sens)
d82 2
a83 2
	struct sensor *v, *nv;
	struct sensors_head *sh;
d116 1
a116 1
sensordev_deinstall(struct sensordev *sensdev)
d122 1
a122 1
	SLIST_REMOVE(&sensordev_list, sensdev, sensordev, list);
d131 1
a131 1
sensor_detach(struct sensordev *sensdev, struct sensor *sens)
d133 1
a133 1
	struct sensors_head *sh;
d139 1
a139 1
	SLIST_REMOVE(sh, sens, sensor, list);
d148 1
a148 1
struct sensordev *
d151 1
a151 1
	struct sensordev *sd;
d160 1
a160 1
struct sensor *
d163 3
a165 3
	struct sensor *s;
	struct sensordev *sensdev;
	struct sensors_head *sh;
@


1.15
log
@force a new sensor task to be run as soon as possible. previously it used
to have to wait its timeout before the first run, which led to some
weird values or states being visible after boot, but before the first
update.

for jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.14 2006/05/28 16:43:50 mk Exp $	*/
d5 1
d34 2
a35 2
int			sensors_count = 0;
SLIST_HEAD(, sensor)	sensors_list = SLIST_HEAD_INITIALIZER(&sensors_list);
d54 1
a54 1
sensor_add(struct sensor *sens)
d56 1
a56 1
	struct sensor *v, *nv;
d60 3
a62 3
	if (sensors_count == 0) {
		sens->num = 0;
		SLIST_INSERT_HEAD(&sensors_list, sens, list);
d64 1
a64 1
		for (v = SLIST_FIRST(&sensors_list);
d68 2
a69 2
		sens->num = v->num + 1;
		SLIST_INSERT_AFTER(v, sens, list);
d71 1
a71 1
	sensors_count++;
d75 1
a75 1
	hotplug_device_attach(DV_DULL, "sensor");
d80 37
a116 1
sensor_del(struct sensor *sens)
d121 2
a122 2
	sensors_count--;
	SLIST_REMOVE(&sensors_list, sens, sensor, list);
d126 1
a126 1
	hotplug_device_detach(DV_DULL, "sensor");
d130 30
d161 1
a161 1
sensor_get(int num)
d164 2
d167 7
a173 2
	SLIST_FOREACH(s, &sensors_list, list) {
		if (s->num == num)
a174 1
	}
@


1.14
log
@Remove device id from hotplug events.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.13 2006/05/28 03:22:35 henning Exp $	*/
d124 2
a125 1
	sensor_task_schedule(st);
@


1.13
log
@intrducing device type DV_SENSOR turned out to be a bad idea as it
affects way more than just hotplug messages. remove DV_SENSOR and use
DV_DULL for the moment. proper solution coming.
discussed with deraadt mk jason
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.12 2006/05/28 02:26:28 jason Exp $	*/
d74 1
a74 1
	hotplug_device_attach(DV_DULL, sens->device, sens->num);
d89 1
a89 1
	hotplug_device_detach(DV_DULL, sens->device, sens->num);
@


1.12
log
@need <sys/device.h> or it doesn't compile on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.11 2006/05/28 01:33:50 mk Exp $	*/
d74 1
a74 1
	hotplug_device_attach(DV_SENSOR, sens->device, sens->num);
d89 1
a89 1
	hotplug_device_detach(DV_SENSOR, sens->device, sens->num);
@


1.11
log
@Include device id in hotplug events.  This will be used by ntpd to check
sensors on attach/detach.  hotplugd changes following in a minute.

ok henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.10 2006/05/28 00:24:00 henning Exp $	*/
d27 1
@


1.10
log
@unbreak, of course this needs to included sys/hotplug.h too
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.9 2006/05/27 23:51:27 mk Exp $	*/
d73 1
a73 1
	hotplug_device_attach(DV_SENSOR, sens->device);
d88 1
a88 1
	hotplug_device_detach(DV_SENSOR, sens->device);
@


1.9
log
@Make sensor add/remove create hotplug events (after much prodding from henning).  Idea from mbalmer.  'in it goes!' deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.8 2006/03/12 13:48:32 dlg Exp $	*/
d27 1
@


1.8
log
@sensors_head is only used in kern_sensors.c, so its unnecessay to declare
it in sensors.h.

from Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.7 2006/01/28 09:53:37 dlg Exp $	*/
d29 1
d70 4
d85 4
@


1.7
log
@get rid of the sensors globals. theyre were only used by sysctl for
locating and finding the correct sensor to spit out. instead provide a
a sensor_get function that wraps up the access to the vars. theyre now
safe inside kern_sensors.c.

theres also a touch of whitespace tweaking

ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.6 2006/01/19 17:08:40 grange Exp $	*/
d31 1
a31 1
struct sensors_head	sensors_list = SLIST_HEAD_INITIALIZER(&sensors_list);
@


1.6
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sensors.c,v 1.5 2005/11/21 13:47:52 dlg Exp $	*/
d30 2
a31 2
int _sensors_count = 0;
struct sensors_head _sensors_list = SLIST_HEAD_INITIALIZER(&_sensors_list);
d56 1
a56 1
	if (_sensors_count == 0) {
d58 1
a58 1
		SLIST_INSERT_HEAD(&_sensors_list, sens, list);
d60 1
a60 1
		for (v = SLIST_FIRST(&_sensors_list);
d67 1
a67 1
	_sensors_count++;
d77 2
a78 2
	_sensors_count--;
	SLIST_REMOVE(&_sensors_list, sens, sensor, list);
d80 13
@


1.5
log
@rename the sensor globals to names that are not obvious to avoid
collisions with local variable names someone might make. this has bitten
me twice now and caused me to lose about 4 hours scratching my head when
nsensors just magically corrupts and gets bigger. at least my ram isnt
screwed.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: kern_sensors.c,v 1.4 2005/11/13 22:41:56 dlg Exp $ */
d48 33
@


1.4
log
@shorten this a bit through better use of TAILQ macros.

mostly ok otto@@ (ive since fixed the chunk he was worried about)
@
text
@d1 1
a1 1
/* $OpenBSD: kern_sensors.c,v 1.3 2005/11/10 08:32:56 dlg Exp $ */
d30 2
a31 2
int nsensors = 0;
struct sensors_head sensors = SLIST_HEAD_INITIALIZER(&sensors);
@


1.3
log
@the tasklist can be modified while the kthread is sleeping, so refetch
the first element before iterating through the rest of them. stylistic
guidance from angela pascoe.

mark all tasks using the same argument as not running anymore, rather than
just the first one we bump into.
@
text
@d1 1
a1 1
/* $OpenBSD: kern_sensors.c,v 1.2 2005/11/10 08:20:20 dlg Exp $ */
d76 1
a76 5
	struct sensor_task	*st, *nst;

	nst = TAILQ_FIRST(&tasklist);
	while ((st = nst) != NULL) {
		nst = TAILQ_NEXT(st, entry);
d78 1
a97 2
		nst = TAILQ_FIRST(&tasklist);

d130 1
a130 1
	struct sensor_task 	*cst, *nst;
d134 1
a134 4
	nst = TAILQ_FIRST(&tasklist);
	while ((cst = nst) != NULL) {
		nst = TAILQ_NEXT(cst, entry);

@


1.2
log
@first go at a generic kthread for sensors to be run out of. its a bit
hairy at the moment, but its going into the tree so it can be worked on
and used.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d68 1
d82 1
a82 1
		if (st->arg == arg) {
a83 2
			return;
		}
d103 2
a104 1
		while (nst->nextrun > (now = time_uptime))
@


1.1
log
@split the sensors stuff out into a source file of its own.

tested on GENERIC and RAMDISK_CD to see if the small_kernel stuff stays
happy
@
text
@d20 4
d32 120
@

