head	1.114;
access;
symbols
	OPENBSD_6_0:1.112.0.2
	OPENBSD_6_0_BASE:1.112
	OPENBSD_5_9:1.110.0.2
	OPENBSD_5_9_BASE:1.110
	OPENBSD_5_8:1.100.0.4
	OPENBSD_5_8_BASE:1.100
	OPENBSD_5_7:1.96.0.2
	OPENBSD_5_7_BASE:1.96
	OPENBSD_5_6:1.92.0.4
	OPENBSD_5_6_BASE:1.92
	OPENBSD_5_5:1.85.0.4
	OPENBSD_5_5_BASE:1.85
	OPENBSD_5_4:1.81.0.2
	OPENBSD_5_4_BASE:1.81
	OPENBSD_5_3:1.78.0.4
	OPENBSD_5_3_BASE:1.78
	OPENBSD_5_2:1.78.0.2
	OPENBSD_5_2_BASE:1.78
	OPENBSD_5_1_BASE:1.73
	OPENBSD_5_1:1.73.0.2
	OPENBSD_5_0:1.72.0.4
	OPENBSD_5_0_BASE:1.72
	OPENBSD_4_9:1.72.0.2
	OPENBSD_4_9_BASE:1.72
	OPENBSD_4_8:1.70.0.2
	OPENBSD_4_8_BASE:1.70
	OPENBSD_4_7:1.67.0.2
	OPENBSD_4_7_BASE:1.67
	OPENBSD_4_6:1.66.0.4
	OPENBSD_4_6_BASE:1.66
	OPENBSD_4_5:1.59.0.2
	OPENBSD_4_5_BASE:1.59
	OPENBSD_4_4:1.58.0.4
	OPENBSD_4_4_BASE:1.58
	OPENBSD_4_3:1.58.0.2
	OPENBSD_4_3_BASE:1.58
	OPENBSD_4_2:1.57.0.2
	OPENBSD_4_2_BASE:1.57
	OPENBSD_4_1:1.54.0.4
	OPENBSD_4_1_BASE:1.54
	OPENBSD_4_0:1.54.0.2
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.51.0.2
	OPENBSD_3_9_BASE:1.51
	OPENBSD_3_8:1.50.0.2
	OPENBSD_3_8_BASE:1.50
	OPENBSD_3_7:1.49.0.4
	OPENBSD_3_7_BASE:1.49
	OPENBSD_3_6:1.49.0.2
	OPENBSD_3_6_BASE:1.49
	SMP_SYNC_A:1.47
	SMP_SYNC_B:1.47
	OPENBSD_3_5:1.47.0.2
	OPENBSD_3_5_BASE:1.47
	OPENBSD_3_4:1.45.0.2
	OPENBSD_3_4_BASE:1.45
	UBC_SYNC_A:1.41
	OPENBSD_3_3:1.41.0.4
	OPENBSD_3_3_BASE:1.41
	OPENBSD_3_2:1.41.0.2
	OPENBSD_3_2_BASE:1.41
	OPENBSD_3_1:1.39.0.2
	OPENBSD_3_1_BASE:1.39
	UBC_SYNC_B:1.41
	UBC:1.31.0.2
	UBC_BASE:1.31
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.24.0.2
	OPENBSD_2_7_BASE:1.24
	SMP:1.22.0.2
	SMP_BASE:1.22
	kame_19991208:1.22
	OPENBSD_2_6:1.20.0.2
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.114
date	2017.01.24.00.58.55;	author mpi;	state Exp;
branches;
next	1.113;
commitid	r0ks7yUPmANG37rA;

1.113
date	2016.11.07.00.26.33;	author guenther;	state Exp;
branches;
next	1.112;
commitid	W7ztnDZwvjCaeQTS;

1.112
date	2016.07.05.00.35.09;	author tedu;	state Exp;
branches;
next	1.111;
commitid	5f77pWnv6tsUbekq;

1.111
date	2016.06.07.06.12.37;	author deraadt;	state Exp;
branches;
next	1.110;
commitid	3b5aikHetmWeZowP;

1.110
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.109;
commitid	Cl55DD2g2xm69E6W;

1.109
date	2015.11.01.19.03.33;	author semarie;	state Exp;
branches;
next	1.108;
commitid	VKRkUfXZQNJ8UQeY;

1.108
date	2015.10.18.05.26.55;	author semarie;	state Exp;
branches;
next	1.107;
commitid	vI7WMFKKR27g98c6;

1.107
date	2015.10.11.23.13.02;	author deraadt;	state Exp;
branches;
next	1.106;
commitid	GHObeJEKGMngKUv6;

1.106
date	2015.10.09.05.55.58;	author deraadt;	state Exp;
branches;
next	1.105;
commitid	aSKakMvLqEnJi2mc;

1.105
date	2015.10.09.05.30.03;	author deraadt;	state Exp;
branches;
next	1.104;
commitid	2OjRc0zgcc3zTio6;

1.104
date	2015.10.09.01.17.21;	author deraadt;	state Exp;
branches;
next	1.103;
commitid	6ulbDS81ej0XxvnS;

1.103
date	2015.09.11.15.29.47;	author deraadt;	state Exp;
branches;
next	1.102;
commitid	0NZe9BgjJety4Dtk;

1.102
date	2015.09.11.08.22.31;	author guenther;	state Exp;
branches;
next	1.101;
commitid	Lqreadw8v5IPAc0L;

1.101
date	2015.08.22.20.18.49;	author deraadt;	state Exp;
branches;
next	1.100;
commitid	6NDuzTPjBp2GqkfQ;

1.100
date	2015.07.28.05.50.41;	author guenther;	state Exp;
branches;
next	1.99;
commitid	6ofl1o2NCJLJenZf;

1.99
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	1.98;
commitid	CJwjm9NDWu6nJ6ES;

1.98
date	2015.05.10.22.35.38;	author millert;	state Exp;
branches;
next	1.97;
commitid	rtX5Mpzd4CgHtDmM;

1.97
date	2015.04.30.09.20.51;	author mpi;	state Exp;
branches;
next	1.96;
commitid	ngMdImGL4WWFm6gy;

1.96
date	2015.02.12.22.27.04;	author millert;	state Exp;
branches;
next	1.95;
commitid	vC4j7knv5kZdPdsR;

1.95
date	2014.12.10.02.44.47;	author tedu;	state Exp;
branches;
next	1.94;
commitid	tsoJBlEBSyYO22RG;

1.94
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.93;
commitid	3SGDR5EjcwE01W8S;

1.93
date	2014.10.13.03.21.18;	author dlg;	state Exp;
branches;
next	1.92;
commitid	ywxZaZy8jiMcXArT;

1.92
date	2014.07.13.15.48.41;	author tedu;	state Exp;
branches;
next	1.91;
commitid	Szz2w3fAfwxRfkCN;

1.91
date	2014.07.13.15.29.04;	author tedu;	state Exp;
branches;
next	1.90;
commitid	bFFVdS3JEaMhyZxJ;

1.90
date	2014.07.12.21.21.19;	author matthew;	state Exp;
branches;
next	1.89;
commitid	hPWqptyZtIqB8x1B;

1.89
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.88;
commitid	QlVV51SZgNFxsXxC;

1.88
date	2014.07.08.17.42.50;	author miod;	state Exp;
branches;
next	1.87;
commitid	BNvdU32ZeEdxUmLG;

1.87
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.86;
commitid	EF98ch02VpFassUi;

1.86
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.85;

1.85
date	2014.01.21.01.48.45;	author tedu;	state Exp;
branches;
next	1.84;

1.84
date	2013.09.14.02.28.02;	author guenther;	state Exp;
branches;
next	1.83;

1.83
date	2013.09.14.01.35.01;	author guenther;	state Exp;
branches;
next	1.82;

1.82
date	2013.08.13.05.52.24;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2013.06.01.16.27.37;	author tedu;	state Exp;
branches;
next	1.80;

1.80
date	2013.05.19.19.14.44;	author guenther;	state Exp;
branches;
next	1.79;

1.79
date	2013.04.29.17.06.20;	author matthew;	state Exp;
branches;
next	1.78;

1.78
date	2012.07.09.17.51.08;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2012.07.09.10.47.29;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2012.03.19.09.05.39;	author guenther;	state Exp;
branches;
next	1.74;

1.74
date	2012.02.15.04.26.27;	author guenther;	state Exp;
branches;
next	1.73;

1.73
date	2011.11.06.12.10.04;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2010.12.19.19.54.46;	author kettenis;	state Exp;
branches;
next	1.71;

1.71
date	2010.08.18.17.42.12;	author marco;	state Exp;
branches;
next	1.70;

1.70
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.69;

1.69
date	2010.07.08.20.15.03;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2010.04.11.17.46.13;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.66;

1.66
date	2009.06.08.23.18.42;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2009.06.04.00.24.02;	author blambert;	state Exp;
branches;
next	1.64;

1.64
date	2009.06.03.03.57.20;	author blambert;	state Exp;
branches;
next	1.63;

1.63
date	2009.06.02.05.20.41;	author thib;	state Exp;
branches;
next	1.62;

1.62
date	2009.06.02.04.13.37;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2009.06.02.03.04.09;	author blambert;	state Exp;
branches;
next	1.60;

1.60
date	2009.03.24.13.49.38;	author kurt;	state Exp;
branches;
next	1.59;

1.59
date	2008.12.16.07.57.28;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2007.07.25.23.11.52;	author art;	state Exp;
branches;
next	1.56;

1.56
date	2007.03.24.16.01.22;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.54;

1.54
date	2006.04.15.20.02.19;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.26.17.47.10;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2006.03.15.11.22.16;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2005.12.13.10.33.14;	author jsg;	state Exp;
branches;
next	1.50;

1.50
date	2005.08.01.06.26.16;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.47;

1.47
date	2003.12.10.23.10.08;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.01.18.06.03;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.23.04.26.53;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.08.12.14.32.44;	author aaron;	state Exp;
branches;
next	1.40;

1.40
date	2002.08.11.02.20.24;	author provos;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2002.03.13.00.24.18;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.13.19.08.06;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2002.02.08.19.58.03;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.08.19.47.50;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.08.13.53.28;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.05.16.02.27;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.02.16.05.58;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.14.19.47.07;	author deraadt;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2001.10.26.12.03.27;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.16.12.52.58;	author ho;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2000.11.10.18.15.47;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2000.09.27.16.13.46;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2000.07.07.14.33.20;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.07.13.24.09;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.20.06.32.00;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.19.08.34.54;	author csapuntz;	state Exp;
branches;
next	1.22;

1.22
date	99.11.29.22.02.14;	author deraadt;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	99.11.29.19.56.59;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.08.04.19.18.13;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	99.05.24.17.18.52;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	99.03.22.02.22.15;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.02.14.21.11.01;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	99.02.14.19.02.21;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.07.28.22.36.42;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.07.28.19.47.07;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.07.28.00.12.58;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.02.09.06.29.07;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	97.11.06.05.58.20;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.10.06.20.20.01;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.15.12.28;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.08.31.20.42.21;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.01.27.23.21.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.10.12.01.15.44;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.18.08.53.09;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.05.52.01;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.27.24;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.20.03;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches;
next	;

1.22.2.1
date	2001.05.14.22.32.43;	author niklas;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2001.07.04.10.48.33;	author niklas;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.22.2.7;

1.22.2.7
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.22.2.8;

1.22.2.8
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.22.2.9;

1.22.2.9
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.22.2.10;

1.22.2.10
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	1.22.2.11;

1.22.2.11
date	2004.06.05.23.18.25;	author tedu;	state Exp;
branches;
next	;

1.29.2.1
date	2002.08.11.12.54.32;	author miod;	state Exp;
branches;
next	;

1.31.2.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	;

1.39.2.1
date	2002.08.11.17.14.55;	author jason;	state Exp;
branches;
next	;


desc
@@


1.114
log
@Rename pfind(9) into tfind(9) to reflect that it deals with threads.

While here document prfind(9.

with and ok guenther@@
@
text
@/*	$OpenBSD: sys_generic.c,v 1.113 2016/11/07 00:26:33 guenther Exp $	*/
/*	$NetBSD: sys_generic.c,v 1.24 1996/03/29 00:25:32 cgd Exp $	*/

/*
 * Copyright (c) 1996 Theo de Raadt
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)sys_generic.c	8.5 (Berkeley) 1/21/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/filedesc.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/socketvar.h>
#include <sys/signalvar.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/stat.h>
#include <sys/malloc.h>
#include <sys/poll.h>
#ifdef KTRACE
#include <sys/ktrace.h>
#endif
#include <sys/sched.h>
#include <sys/pledge.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

int selscan(struct proc *, fd_set *, fd_set *, int, int, register_t *);
void pollscan(struct proc *, struct pollfd *, u_int, register_t *);
int pollout(struct pollfd *, struct pollfd *, u_int);
int dopselect(struct proc *, int, fd_set *, fd_set *, fd_set *,
    const struct timespec *, const sigset_t *, register_t *);
int doppoll(struct proc *, struct pollfd *, u_int, const struct timespec *,
    const sigset_t *, register_t *);

/*
 * Read system call.
 */
int
sys_read(struct proc *p, void *v, register_t *retval)
{
	struct sys_read_args /* {
		syscallarg(int) fd;
		syscallarg(void *) buf;
		syscallarg(size_t) nbyte;
	} */ *uap = v;
	struct iovec iov;
	int fd = SCARG(uap, fd);
	struct file *fp;
	struct filedesc *fdp = p->p_fd;

	if ((fp = fd_getfile_mode(fdp, fd, FREAD)) == NULL)
		return (EBADF);

	iov.iov_base = SCARG(uap, buf);
	iov.iov_len = SCARG(uap, nbyte);

	FREF(fp);

	/* dofilereadv() will FRELE the descriptor for us */
	return (dofilereadv(p, fd, fp, &iov, 1, 0, &fp->f_offset, retval));
}

/*
 * Scatter read system call.
 */
int
sys_readv(struct proc *p, void *v, register_t *retval)
{
	struct sys_readv_args /* {
		syscallarg(int) fd;
		syscallarg(const struct iovec *) iovp;
		syscallarg(int) iovcnt;
	} */ *uap = v;
	int fd = SCARG(uap, fd);
	struct file *fp;
	struct filedesc *fdp = p->p_fd;

	if ((fp = fd_getfile_mode(fdp, fd, FREAD)) == NULL)
		return (EBADF);
	FREF(fp);

	/* dofilereadv() will FRELE the descriptor for us */
	return (dofilereadv(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt), 1,
	    &fp->f_offset, retval));
}

int
dofilereadv(struct proc *p, int fd, struct file *fp, const struct iovec *iovp,
    int iovcnt, int userspace, off_t *offset, register_t *retval)
{
	struct iovec aiov[UIO_SMALLIOV];
	struct uio auio;
	struct iovec *iov;
	struct iovec *needfree = NULL;
	long i, cnt, error = 0;
	u_int iovlen;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif

	/* note: can't use iovlen until iovcnt is validated */
	iovlen = iovcnt * sizeof(struct iovec);

	/*
	 * If the iovec array exists in userspace, it needs to be copied in;
	 * otherwise, it can be used directly.
	 */
	if (userspace) {
		if ((u_int)iovcnt > UIO_SMALLIOV) {
			if ((u_int)iovcnt > IOV_MAX) {
				error = EINVAL;
				goto out;
			}
			iov = needfree = malloc(iovlen, M_IOV, M_WAITOK);
		} else if ((u_int)iovcnt > 0) {
			iov = aiov;
			needfree = NULL;
		} else {
			error = EINVAL;
			goto out;
		}
		if ((error = copyin(iovp, iov, iovlen)))
			goto done;
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktriovec(p, iov, iovcnt);
#endif
	} else {
		iov = (struct iovec *)iovp;		/* de-constify */
	}

	auio.uio_iov = iov;
	auio.uio_iovcnt = iovcnt;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;
	auio.uio_resid = 0;
	for (i = 0; i < iovcnt; i++) {
		auio.uio_resid += iov->iov_len;
		/*
		 * Reads return ssize_t because -1 is returned on error.
		 * Therefore we must restrict the length to SSIZE_MAX to
		 * avoid garbage return values.  Note that the addition is
		 * guaranteed to not wrap because SSIZE_MAX * 2 < SIZE_MAX.
		 */
		if (iov->iov_len > SSIZE_MAX || auio.uio_resid > SSIZE_MAX) {
			error = EINVAL;
			goto done;
		}
		iov++;
	}
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO)) {
		ktriov = malloc(iovlen, M_TEMP, M_WAITOK);
		memcpy(ktriov, auio.uio_iov, iovlen);
	}
#endif
	cnt = auio.uio_resid;
	error = (*fp->f_ops->fo_read)(fp, offset, &auio, fp->f_cred);
	if (error)
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	cnt -= auio.uio_resid;

	fp->f_rxfer++;
	fp->f_rbytes += cnt;
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p, fd, UIO_READ, ktriov, cnt);
		free(ktriov, M_TEMP, iovlen);
	}
#endif
	*retval = cnt;
 done:
	if (needfree)
		free(needfree, M_IOV, iovlen);
 out:
	FRELE(fp, p);
	return (error);
}

/*
 * Write system call
 */
int
sys_write(struct proc *p, void *v, register_t *retval)
{
	struct sys_write_args /* {
		syscallarg(int) fd;
		syscallarg(const void *) buf;
		syscallarg(size_t) nbyte;
	} */ *uap = v;
	struct iovec iov;
	int fd = SCARG(uap, fd);
	struct file *fp;
	struct filedesc *fdp = p->p_fd;

	if ((fp = fd_getfile_mode(fdp, fd, FWRITE)) == NULL)
		return (EBADF);

	iov.iov_base = (void *)SCARG(uap, buf);
	iov.iov_len = SCARG(uap, nbyte);

	FREF(fp);

	/* dofilewritev() will FRELE the descriptor for us */
	return (dofilewritev(p, fd, fp, &iov, 1, 0, &fp->f_offset, retval));
}

/*
 * Gather write system call
 */
int
sys_writev(struct proc *p, void *v, register_t *retval)
{
	struct sys_writev_args /* {
		syscallarg(int) fd;
		syscallarg(const struct iovec *) iovp;
		syscallarg(int) iovcnt;
	} */ *uap = v;
	int fd = SCARG(uap, fd);
	struct file *fp;
	struct filedesc *fdp = p->p_fd;

	if ((fp = fd_getfile_mode(fdp, fd, FWRITE)) == NULL)
		return (EBADF);
	FREF(fp);

	/* dofilewritev() will FRELE the descriptor for us */
	return (dofilewritev(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt), 1,
	    &fp->f_offset, retval));
}

int
dofilewritev(struct proc *p, int fd, struct file *fp, const struct iovec *iovp,
    int iovcnt, int userspace, off_t *offset, register_t *retval)
{
	struct iovec aiov[UIO_SMALLIOV];
	struct uio auio;
	struct iovec *iov;
	struct iovec *needfree = NULL;
	long i, cnt, error = 0;
	u_int iovlen;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif

	/* note: can't use iovlen until iovcnt is validated */
	iovlen = iovcnt * sizeof(struct iovec);

	/*
	 * If the iovec array exists in userspace, it needs to be copied in;
	 * otherwise, it can be used directly.
	 */
	if (userspace) {
		if ((u_int)iovcnt > UIO_SMALLIOV) {
			if ((u_int)iovcnt > IOV_MAX) {
				error = EINVAL;
				goto out;
			}
			iov = needfree = malloc(iovlen, M_IOV, M_WAITOK);
		} else if ((u_int)iovcnt > 0) {
			iov = aiov;
			needfree = NULL;
		} else {
			error = EINVAL;
			goto out;
		}
		if ((error = copyin(iovp, iov, iovlen)))
			goto done;
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktriovec(p, iov, iovcnt);
#endif
	} else {
		iov = (struct iovec *)iovp;		/* de-constify */
	}

	auio.uio_iov = iov;
	auio.uio_iovcnt = iovcnt;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;
	auio.uio_resid = 0;
	for (i = 0; i < iovcnt; i++) {
		auio.uio_resid += iov->iov_len;
		/*
		 * Writes return ssize_t because -1 is returned on error.
		 * Therefore we must restrict the length to SSIZE_MAX to
		 * avoid garbage return values.  Note that the addition is
		 * guaranteed to not wrap because SSIZE_MAX * 2 < SIZE_MAX.
		 */
		if (iov->iov_len > SSIZE_MAX || auio.uio_resid > SSIZE_MAX) {
			error = EINVAL;
			goto done;
		}
		iov++;
	}
#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO)) {
		ktriov = malloc(iovlen, M_TEMP, M_WAITOK);
		memcpy(ktriov, auio.uio_iov, iovlen);
	}
#endif
	cnt = auio.uio_resid;
	error = (*fp->f_ops->fo_write)(fp, offset, &auio, fp->f_cred);
	if (error) {
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
			ptsignal(p, SIGPIPE, STHREAD);
	}
	cnt -= auio.uio_resid;

	fp->f_wxfer++;
	fp->f_wbytes += cnt;
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p, fd, UIO_WRITE, ktriov, cnt);
		free(ktriov, M_TEMP, iovlen);
	}
#endif
	*retval = cnt;
 done:
	if (needfree)
		free(needfree, M_IOV, iovlen);
 out:
	FRELE(fp, p);
	return (error);
}

/*
 * Ioctl system call
 */
int
sys_ioctl(struct proc *p, void *v, register_t *retval)
{
	struct sys_ioctl_args /* {
		syscallarg(int) fd;
		syscallarg(u_long) com;
		syscallarg(void *) data;
	} */ *uap = v;
	struct file *fp;
	struct filedesc *fdp;
	u_long com = SCARG(uap, com);
	int error;
	u_int size;
	caddr_t data, memp;
	int tmp;
#define STK_PARAMS	128
	long long stkbuf[STK_PARAMS / sizeof(long long)];

	fdp = p->p_fd;
	fp = fd_getfile_mode(fdp, SCARG(uap, fd), FREAD|FWRITE);

	if (fp == NULL)
		return (EBADF);

	if (fp->f_type == DTYPE_SOCKET) {
		struct socket *so = fp->f_data;

		if (so->so_state & SS_DNS)
			return (EINVAL);
	}

	error = pledge_ioctl(p, com, fp);
	if (error)
		return (error);

	switch (com) {
	case FIONCLEX:
	case FIOCLEX:
		fdplock(fdp);
		if (com == FIONCLEX)
			fdp->fd_ofileflags[SCARG(uap, fd)] &= ~UF_EXCLOSE;
		else
			fdp->fd_ofileflags[SCARG(uap, fd)] |= UF_EXCLOSE;
		fdpunlock(fdp);
		return (0);
	}

	/*
	 * Interpret high order word to find amount of data to be
	 * copied to/from the user's address space.
	 */
	size = IOCPARM_LEN(com);
	if (size > IOCPARM_MAX)
		return (ENOTTY);
	FREF(fp);
	memp = NULL;
	if (size > sizeof (stkbuf)) {
		memp = malloc(size, M_IOCTLOPS, M_WAITOK);
		data = memp;
	} else
		data = (caddr_t)stkbuf;
	if (com&IOC_IN) {
		if (size) {
			error = copyin(SCARG(uap, data), data, size);
			if (error) {
				goto out;
			}
		} else
			*(caddr_t *)data = SCARG(uap, data);
	} else if ((com&IOC_OUT) && size)
		/*
		 * Zero the buffer so the user always
		 * gets back something deterministic.
		 */
		memset(data, 0, size);
	else if (com&IOC_VOID)
		*(caddr_t *)data = SCARG(uap, data);

	switch (com) {

	case FIONBIO:
		if ((tmp = *(int *)data) != 0)
			fp->f_flag |= FNONBLOCK;
		else
			fp->f_flag &= ~FNONBLOCK;
		error = (*fp->f_ops->fo_ioctl)(fp, FIONBIO, (caddr_t)&tmp, p);
		break;

	case FIOASYNC:
		if ((tmp = *(int *)data) != 0)
			fp->f_flag |= FASYNC;
		else
			fp->f_flag &= ~FASYNC;
		error = (*fp->f_ops->fo_ioctl)(fp, FIOASYNC, (caddr_t)&tmp, p);
		break;

	case FIOSETOWN:
		tmp = *(int *)data;
		if (fp->f_type == DTYPE_SOCKET) {
			struct socket *so = fp->f_data;

			so->so_pgid = tmp;
			so->so_siguid = p->p_ucred->cr_ruid;
			so->so_sigeuid = p->p_ucred->cr_uid;
			error = 0;
			break;
		}
		if (tmp <= 0) {
			tmp = -tmp;
		} else {
			struct process *pr = prfind(tmp);
			if (pr == NULL) {
				error = ESRCH;
				break;
			}
			tmp = pr->ps_pgrp->pg_id;
		}
		error = (*fp->f_ops->fo_ioctl)
		    (fp, TIOCSPGRP, (caddr_t)&tmp, p);
		break;

	case FIOGETOWN:
		if (fp->f_type == DTYPE_SOCKET) {
			error = 0;
			*(int *)data = ((struct socket *)fp->f_data)->so_pgid;
			break;
		}
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCGPGRP, data, p);
		*(int *)data = -*(int *)data;
		break;

	default:
		error = (*fp->f_ops->fo_ioctl)(fp, com, data, p);
		break;
	}
	/*
	 * Copy any data to user, size was
	 * already set and checked above.
	 */
	if (error == 0 && (com&IOC_OUT) && size)
		error = copyout(data, SCARG(uap, data), size);
out:
	FRELE(fp, p);
	if (memp)
		free(memp, M_IOCTLOPS, size);
	return (error);
}

int	selwait, nselcoll;

/*
 * Select system call.
 */
int
sys_select(struct proc *p, void *v, register_t *retval)
{
	struct sys_select_args /* {
		syscallarg(int) nd;
		syscallarg(fd_set *) in;
		syscallarg(fd_set *) ou;
		syscallarg(fd_set *) ex;
		syscallarg(struct timeval *) tv;
	} */ *uap = v;

	struct timespec ts, *tsp = NULL;
	int error;

	if (SCARG(uap, tv) != NULL) {
		struct timeval tv;
		if ((error = copyin(SCARG(uap, tv), &tv, sizeof tv)) != 0)
			return (error);
		if ((error = itimerfix(&tv)) != 0)
			return (error);
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrreltimeval(p, &tv);
#endif
		TIMEVAL_TO_TIMESPEC(&tv, &ts);
		tsp = &ts;
	}

	return (dopselect(p, SCARG(uap, nd), SCARG(uap, in), SCARG(uap, ou),
	    SCARG(uap, ex), tsp, NULL, retval));
}

int
sys_pselect(struct proc *p, void *v, register_t *retval)
{
	struct sys_pselect_args /* {
		syscallarg(int) nd;
		syscallarg(fd_set *) in;
		syscallarg(fd_set *) ou;
		syscallarg(fd_set *) ex;
		syscallarg(const struct timespec *) ts;
		syscallarg(const sigset_t *) mask;
	} */ *uap = v;

	struct timespec ts, *tsp = NULL;
	sigset_t ss, *ssp = NULL;
	int error;

	if (SCARG(uap, ts) != NULL) {
		if ((error = copyin(SCARG(uap, ts), &ts, sizeof ts)) != 0)
			return (error);
		if ((error = timespecfix(&ts)) != 0)
			return (error);
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrreltimespec(p, &ts);
#endif
		tsp = &ts;
	}
	if (SCARG(uap, mask) != NULL) {
		if ((error = copyin(SCARG(uap, mask), &ss, sizeof ss)) != 0)
			return (error);
		ssp = &ss;
	}

	return (dopselect(p, SCARG(uap, nd), SCARG(uap, in), SCARG(uap, ou),
	    SCARG(uap, ex), tsp, ssp, retval));
}

int
dopselect(struct proc *p, int nd, fd_set *in, fd_set *ou, fd_set *ex,
    const struct timespec *tsp, const sigset_t *sigmask, register_t *retval)
{
	fd_mask bits[6];
	fd_set *pibits[3], *pobits[3];
	struct timespec ats, rts, tts;
	int s, ncoll, error = 0, timo;
	u_int ni;

	if (nd < 0)
		return (EINVAL);
	if (nd > p->p_fd->fd_nfiles) {
		/* forgiving; slightly wrong */
		nd = p->p_fd->fd_nfiles;
	}
	ni = howmany(nd, NFDBITS) * sizeof(fd_mask);
	if (ni > sizeof(bits[0])) {
		caddr_t mbits;

		mbits = mallocarray(6, ni, M_TEMP, M_WAITOK|M_ZERO);
		pibits[0] = (fd_set *)&mbits[ni * 0];
		pibits[1] = (fd_set *)&mbits[ni * 1];
		pibits[2] = (fd_set *)&mbits[ni * 2];
		pobits[0] = (fd_set *)&mbits[ni * 3];
		pobits[1] = (fd_set *)&mbits[ni * 4];
		pobits[2] = (fd_set *)&mbits[ni * 5];
	} else {
		memset(bits, 0, sizeof(bits));
		pibits[0] = (fd_set *)&bits[0];
		pibits[1] = (fd_set *)&bits[1];
		pibits[2] = (fd_set *)&bits[2];
		pobits[0] = (fd_set *)&bits[3];
		pobits[1] = (fd_set *)&bits[4];
		pobits[2] = (fd_set *)&bits[5];
	}

#define	getbits(name, x) \
	if (name && (error = copyin(name, pibits[x], ni))) \
		goto done;
	getbits(in, 0);
	getbits(ou, 1);
	getbits(ex, 2);
#undef	getbits
#ifdef KTRACE
	if (ni > 0 && KTRPOINT(p, KTR_STRUCT)) {
		if (in) ktrfdset(p, pibits[0], ni);
		if (ou) ktrfdset(p, pibits[1], ni);
		if (ex) ktrfdset(p, pibits[2], ni);
	}
#endif

	if (tsp) {
		getnanouptime(&rts);
		timespecadd(tsp, &rts, &ats);
	} else {
		ats.tv_sec = 0;
		ats.tv_nsec = 0;
	}
	timo = 0;

	if (sigmask)
		dosigsuspend(p, *sigmask &~ sigcantmask);

retry:
	ncoll = nselcoll;
	atomic_setbits_int(&p->p_flag, P_SELECT);
	error = selscan(p, pibits[0], pobits[0], nd, ni, retval);
	if (error || *retval)
		goto done;
	if (tsp) {
		getnanouptime(&rts);
		if (timespeccmp(&rts, &ats, >=))
			goto done;
		timespecsub(&ats, &rts, &tts);
		timo = tts.tv_sec > 24 * 60 * 60 ?
			24 * 60 * 60 * hz : tstohz(&tts);
	}
	s = splhigh();
	if ((p->p_flag & P_SELECT) == 0 || nselcoll != ncoll) {
		splx(s);
		goto retry;
	}
	atomic_clearbits_int(&p->p_flag, P_SELECT);
	error = tsleep(&selwait, PSOCK | PCATCH, "select", timo);
	splx(s);
	if (error == 0)
		goto retry;
done:
	atomic_clearbits_int(&p->p_flag, P_SELECT);
	/* select is not restarted after signals... */
	if (error == ERESTART)
		error = EINTR;
	if (error == EWOULDBLOCK)
		error = 0;
#define	putbits(name, x) \
	if (name && (error2 = copyout(pobits[x], name, ni))) \
		error = error2;
	if (error == 0) {
		int error2;

		putbits(in, 0);
		putbits(ou, 1);
		putbits(ex, 2);
#undef putbits
#ifdef KTRACE
		if (ni > 0 && KTRPOINT(p, KTR_STRUCT)) {
			if (in) ktrfdset(p, pobits[0], ni);
			if (ou) ktrfdset(p, pobits[1], ni);
			if (ex) ktrfdset(p, pobits[2], ni);
		}
#endif
	}

	if (pibits[0] != (fd_set *)&bits[0])
		free(pibits[0], M_TEMP, 6 * ni);
	return (error);
}

int
selscan(struct proc *p, fd_set *ibits, fd_set *obits, int nfd, int ni,
    register_t *retval)
{
	caddr_t cibits = (caddr_t)ibits, cobits = (caddr_t)obits;
	struct filedesc *fdp = p->p_fd;
	int msk, i, j, fd;
	fd_mask bits;
	struct file *fp;
	int n = 0;
	static const int flag[3] = { POLLIN, POLLOUT|POLL_NOHUP, POLLPRI };

	for (msk = 0; msk < 3; msk++) {
		fd_set *pibits = (fd_set *)&cibits[msk*ni];
		fd_set *pobits = (fd_set *)&cobits[msk*ni];

		for (i = 0; i < nfd; i += NFDBITS) {
			bits = pibits->fds_bits[i/NFDBITS];
			while ((j = ffs(bits)) && (fd = i + --j) < nfd) {
				bits &= ~(1 << j);
				if ((fp = fd_getfile(fdp, fd)) == NULL)
					return (EBADF);
				FREF(fp);
				if ((*fp->f_ops->fo_poll)(fp, flag[msk], p)) {
					FD_SET(fd, pobits);
					n++;
				}
				FRELE(fp, p);
			}
		}
	}
	*retval = n;
	return (0);
}

int
seltrue(dev_t dev, int events, struct proc *p)
{

	return (events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
}

int
selfalse(dev_t dev, int events, struct proc *p)
{

	return (0);
}

/*
 * Record a select request.
 */
void
selrecord(struct proc *selector, struct selinfo *sip)
{
	struct proc *p;
	pid_t mytid;

	mytid = selector->p_tid;
	if (sip->si_seltid == mytid)
		return;
	if (sip->si_seltid && (p = tfind(sip->si_seltid)) &&
	    p->p_wchan == (caddr_t)&selwait)
		sip->si_flags |= SI_COLL;
	else
		sip->si_seltid = mytid;
}

/*
 * Do a wakeup when a selectable event occurs.
 */
void
selwakeup(struct selinfo *sip)
{
	struct proc *p;
	int s;

	KNOTE(&sip->si_note, 0);
	if (sip->si_seltid == 0)
		return;
	if (sip->si_flags & SI_COLL) {
		nselcoll++;
		sip->si_flags &= ~SI_COLL;
		wakeup(&selwait);
	}
	p = tfind(sip->si_seltid);
	sip->si_seltid = 0;
	if (p != NULL) {
		SCHED_LOCK(s);
		if (p->p_wchan == (caddr_t)&selwait) {
			if (p->p_stat == SSLEEP)
				setrunnable(p);
			else
				unsleep(p);
		} else if (p->p_flag & P_SELECT)
			atomic_clearbits_int(&p->p_flag, P_SELECT);
		SCHED_UNLOCK(s);
	}
}

void
pollscan(struct proc *p, struct pollfd *pl, u_int nfd, register_t *retval)
{
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	u_int i;
	int n = 0;

	for (i = 0; i < nfd; i++, pl++) {
		/* Check the file descriptor. */
		if (pl->fd < 0) {
			pl->revents = 0;
			continue;
		}
		if ((fp = fd_getfile(fdp, pl->fd)) == NULL) {
			pl->revents = POLLNVAL;
			n++;
			continue;
		}
		FREF(fp);
		pl->revents = (*fp->f_ops->fo_poll)(fp, pl->events, p);
		FRELE(fp, p);
		if (pl->revents != 0)
			n++;
	}
	*retval = n;
}

/*
 * Only copyout the revents field.
 */
int
pollout(struct pollfd *pl, struct pollfd *upl, u_int nfds)
{
	int error = 0;
	u_int i = 0;

	while (!error && i++ < nfds) {
		error = copyout(&pl->revents, &upl->revents,
		    sizeof(upl->revents));
		pl++;
		upl++;
	}

	return (error);
}

/*
 * We are using the same mechanism as select only we encode/decode args
 * differently.
 */
int
sys_poll(struct proc *p, void *v, register_t *retval)
{
	struct sys_poll_args /* {
		syscallarg(struct pollfd *) fds;
		syscallarg(u_int) nfds;
		syscallarg(int) timeout;
	} */ *uap = v;

	struct timespec ts, *tsp = NULL;
	int msec = SCARG(uap, timeout);

	if (msec != INFTIM) {
		if (msec < 0)
			return (EINVAL);
		ts.tv_sec = msec / 1000;
		ts.tv_nsec = (msec - (ts.tv_sec * 1000)) * 1000000;
		tsp = &ts;
	}

	return (doppoll(p, SCARG(uap, fds), SCARG(uap, nfds), tsp, NULL,
	    retval));
}

int
sys_ppoll(struct proc *p, void *v, register_t *retval)
{
	struct sys_ppoll_args /* {
		syscallarg(struct pollfd *) fds;
		syscallarg(u_int) nfds;
		syscallarg(const struct timespec *) ts;
		syscallarg(const sigset_t *) mask;
	} */ *uap = v;

	int error;
	struct timespec ts, *tsp = NULL;
	sigset_t ss, *ssp = NULL;

	if (SCARG(uap, ts) != NULL) {
		if ((error = copyin(SCARG(uap, ts), &ts, sizeof ts)) != 0)
			return (error);
		if ((error = timespecfix(&ts)) != 0)
			return (error);
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrreltimespec(p, &ts);
#endif
		tsp = &ts;
	}

	if (SCARG(uap, mask) != NULL) {
		if ((error = copyin(SCARG(uap, mask), &ss, sizeof ss)) != 0)
			return (error);
		ssp = &ss;
	}

	return (doppoll(p, SCARG(uap, fds), SCARG(uap, nfds), tsp, ssp,
	    retval));
}

int
doppoll(struct proc *p, struct pollfd *fds, u_int nfds,
    const struct timespec *tsp, const sigset_t *sigmask, register_t *retval)
{
	size_t sz;
	struct pollfd pfds[4], *pl = pfds;
	struct timespec ats, rts, tts;
	int timo, ncoll, i, s, error;

	/* Standards say no more than MAX_OPEN; this is possibly better. */
	if (nfds > min((int)p->p_rlimit[RLIMIT_NOFILE].rlim_cur, maxfiles))
		return (EINVAL);

	/* optimize for the default case, of a small nfds value */
	if (nfds > nitems(pfds)) {
		pl = mallocarray(nfds, sizeof(*pl), M_TEMP,
		    M_WAITOK | M_CANFAIL);
		if (pl == NULL)
			return (EINVAL);
	}

	sz = nfds * sizeof(*pl);

	if ((error = copyin(fds, pl, sz)) != 0)
		goto bad;

	for (i = 0; i < nfds; i++) {
		pl[i].events &= ~POLL_NOHUP;
		pl[i].revents = 0;
	}

	if (tsp != NULL) {
		getnanouptime(&rts);
		timespecadd(tsp, &rts, &ats);
	} else {
		ats.tv_sec = 0;
		ats.tv_nsec = 0;
	}
	timo = 0;

	if (sigmask)
		dosigsuspend(p, *sigmask &~ sigcantmask);

retry:
	ncoll = nselcoll;
	atomic_setbits_int(&p->p_flag, P_SELECT);
	pollscan(p, pl, nfds, retval);
	if (*retval)
		goto done;
	if (tsp != NULL) {
		getnanouptime(&rts);
		if (timespeccmp(&rts, &ats, >=))
			goto done;
		timespecsub(&ats, &rts, &tts);
		timo = tts.tv_sec > 24 * 60 * 60 ?
			24 * 60 * 60 * hz : tstohz(&tts);
	}
	s = splhigh();
	if ((p->p_flag & P_SELECT) == 0 || nselcoll != ncoll) {
		splx(s);
		goto retry;
	}
	atomic_clearbits_int(&p->p_flag, P_SELECT);
	error = tsleep(&selwait, PSOCK | PCATCH, "poll", timo);
	splx(s);
	if (error == 0)
		goto retry;

done:
	atomic_clearbits_int(&p->p_flag, P_SELECT);
	/*
	 * NOTE: poll(2) is not restarted after a signal and EWOULDBLOCK is
	 *       ignored (since the whole point is to see what would block).
	 */
	switch (error) {
	case ERESTART:
		error = pollout(pl, fds, nfds);
		if (error == 0)
			error = EINTR;
		break;
	case EWOULDBLOCK:
	case 0:
		error = pollout(pl, fds, nfds);
		break;
	}
#ifdef KTRACE
	if (KTRPOINT(p, KTR_STRUCT))
		ktrpollfd(p, pl, nfds);
#endif /* KTRACE */
bad:
	if (pl != pfds)
		free(pl, M_TEMP, sz);
	return (error);
}

/*
 * utrace system call
 */
int
sys_utrace(struct proc *curp, void *v, register_t *retval)
{
#ifdef KTRACE
	struct sys_utrace_args /* {
		syscallarg(const char *) label;
		syscallarg(const void *) addr;
		syscallarg(size_t) len;
	} */ *uap = v;
	return (ktruser(curp, SCARG(uap, label), SCARG(uap, addr),
	    SCARG(uap, len)));
#else
	return (0);
#endif
}
@


1.113
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.112 2016/07/05 00:35:09 tedu Exp $	*/
d786 1
a786 1
	if (sip->si_seltid && (p = pfind(sip->si_seltid)) &&
d810 1
a810 1
	p = pfind(sip->si_seltid);
@


1.112
log
@remove some casts that aren't necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.111 2016/06/07 06:12:37 deraadt Exp $	*/
d781 1
a781 1
	pid_t mypid;
d783 2
a784 2
	mypid = selector->p_pid;
	if (sip->si_selpid == mypid)
d786 1
a786 1
	if (sip->si_selpid && (p = pfind(sip->si_selpid)) &&
d790 1
a790 1
		sip->si_selpid = mypid;
d803 1
a803 1
	if (sip->si_selpid == 0)
d810 2
a811 2
	p = pfind(sip->si_selpid);
	sip->si_selpid = 0;
@


1.111
log
@ktrace support for pollfd[] arrays
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.110 2015/12/05 10:11:53 tedu Exp $	*/
d441 1
a441 1
		memp = (caddr_t)malloc((u_long)size, M_IOCTLOPS, M_WAITOK);
d447 1
a447 1
			error = copyin(SCARG(uap, data), data, (u_int)size);
d483 1
a483 1
			struct socket *so = (struct socket *)fp->f_data;
d502 1
a502 1
			(fp, TIOCSPGRP, (caddr_t)&tmp, p);
d524 1
a524 1
		error = copyout(data, SCARG(uap, data), (u_int)size);
@


1.110
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.109 2015/11/01 19:03:33 semarie Exp $	*/
d735 1
a735 1
	static const int flag[3] = { POLLIN, POLLOUT|POLLNOHUP, POLLPRI };
d963 1
a963 1
		pl[i].events &= ~POLLNOHUP;
d1021 4
@


1.109
log
@refactor pledge_*_check and pledge_fail functions

- rename _check function without suffix: a "pledge" function called from
  anywhere is a "check" function.

- makes pledge_fail call the responsability to the _check function. remove it
  from caller.

- make proper use of (potential) returned error of _check() functions.

- adds pledge_kill() and pledge_protexec()

with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.108 2015/10/18 05:26:55 semarie Exp $	*/
a76 1
/* ARGSUSED */
a383 1
/* ARGSUSED */
a759 1
/*ARGSUSED*/
a1029 1
/* ARGSUSED */
@


1.108
log
@move SS_DNS socket check from kern_plegde.c to sys_generic.c

this check has nothing to do with pledge(2). make it lives in sys_ioctl() call.

while here, move the (fp == NULL) check early and remove duplicate check from
pledge_ioctl_check().

ok guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.107 2015/10/11 23:13:02 deraadt Exp $	*/
d417 1
a417 1
	error = pledge_ioctl_check(p, com, fp);
@


1.107
log
@pledge_ioctl_check() will do the killing if neccessary; if it returns,
that is an errno to pass up to the calling system call instead. test
case is "who < /dev/null", via ttyname().
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.106 2015/10/09 05:55:58 deraadt Exp $	*/
d407 10
a419 3

	if (fp == NULL)
		return (EBADF);
@


1.106
log
@another stray )
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.105 2015/10/09 05:30:03 deraadt Exp $	*/
d409 1
a409 1
		return (pledge_fail(p, EPERM, PLEDGE_IOCTL));
@


1.105
log
@shortcircuit TIOCGETA to directly return ENOTTY for non-ttys.  It could
be called against a non-tty fd, so as to test "is this a tty".  Discovered
by sthen and rob pierce at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.104 2015/10/09 01:17:21 deraadt Exp $	*/
d407 1
a407 1
	error = pledge_ioctl_check(p, com, fp))
@


1.104
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.103 2015/09/11 15:29:47 deraadt Exp $	*/
d407 2
a408 1
	if (pledge_ioctl_check(p, com, fp))
@


1.103
log
@Convert _TM_ flags to TAME_ flags, collapsing the entire mapping
layer because the strings select the right options.  Mechanical
conversion.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.102 2015/09/11 08:22:31 guenther Exp $	*/
d59 1
a59 1
#include <sys/tame.h>
d407 2
a408 2
	if (tame_ioctl_check(p, com, fp))
		return (tame_fail(p, EPERM, TAME_IOCTL));
@


1.102
log
@Only include <sys/tame.h> in the .c files that need it

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.101 2015/08/22 20:18:49 deraadt Exp $	*/
d408 1
a408 1
		return (tame_fail(p, EPERM, _TM_IOCTL));
@


1.101
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.100 2015/07/28 05:50:41 guenther Exp $	*/
d59 1
@


1.100
log
@Add ktracing of structs iovec, msghdr, and cmsghdr for {,p}{read,write}v(),
sendmsg(), and recvmsg().  For cmsghdr, the len, level, and type are always
shown, and for SOL_SOCKET,SCM_RIGHTS the fd numbers being passed are shown.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.99 2015/07/19 02:35:35 deraadt Exp $	*/
a54 1
#include <sys/tame.h>
@


1.99
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.98 2015/05/10 22:35:38 millert Exp $	*/
d164 4
d316 4
@


1.98
log
@Set POLLHUP even if no valid events were specified as per POSIX.
Since we use the poll backend for select(2), care must be taken not
to set the fd's bit in writefds in this case.  A kernel-only flag,
POLLNOHUP, is used by selscan() to tell the poll backend not to
return POLLHUP on EOF.  This is currently only used by fifo_poll().
The fifofs regress now passes.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.97 2015/04/30 09:20:51 mpi Exp $	*/
d55 1
d388 1
a388 1
	u_long com;
d397 6
a402 1
	if ((fp = fd_getfile_mode(fdp, SCARG(uap, fd), FREAD|FWRITE)) == NULL)
d405 1
a405 1
	switch (com = SCARG(uap, com)) {
@


1.97
log
@Indroduce fd_getfile_mode() and use it were fd_getfile() is directly
followed by a mode check.  This will simplify the ref/unref dance as
soon as fd_getfile() will increment fp's reference counter.

Idea from and ok guenther@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.96 2015/02/12 22:27:04 millert Exp $	*/
d715 1
a715 1
	static const int flag[3] = { POLLIN, POLLOUT, POLLPRI };
d943 2
a944 1
	for (i = 0; i < nfds; i++)
d946 1
@


1.96
log
@Remove useless extern definitions of nselcoll and selwait.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.95 2014/12/10 02:44:47 tedu Exp $	*/
d90 1
a90 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FREAD) == 0)
d117 1
a117 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FREAD) == 0)
a118 1

d238 1
a238 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FWRITE) == 0)
d265 1
a265 1
	if ((fp = fd_getfile(fdp, fd)) == NULL)
a266 3
	if ((fp->f_flag & FWRITE) == 0)
		return (EBADF);

d396 1
a396 4
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return (EBADF);

	if ((fp->f_flag & (FREAD | FWRITE)) == 0)
@


1.95
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.94 2014/11/03 03:08:00 deraadt Exp $	*/
a937 1
	extern int nselcoll, selwait;
@


1.94
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.93 2014/10/13 03:21:18 dlg Exp $	*/
d198 1
a198 1
		bcopy(auio.uio_iov, ktriov, iovlen);
d351 1
a351 1
		bcopy(auio.uio_iov, ktriov, iovlen);
@


1.93
log
@use mallocarray to get the array of pollfd structs.

tweaks and ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.92 2014/07/13 15:48:41 tedu Exp $	*/
d215 1
a215 1
		free(ktriov, M_TEMP, 0);
d221 1
a221 1
		free(needfree, M_IOV, 0);
d371 1
a371 1
		free(ktriov, M_TEMP, 0);
d377 1
a377 1
		free(needfree, M_IOV, 0);
d521 1
a521 1
		free(memp, M_IOCTLOPS, 0);
d714 1
a714 1
		free(pibits[0], M_TEMP, 0);
d1016 1
a1016 1
		free(pl, M_TEMP, 0);
@


1.92
log
@trim some casts
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.91 2014/07/13 15:29:04 tedu Exp $	*/
d944 7
a950 1
	sz = sizeof(struct pollfd) * nfds;
d952 1
a952 3
	/* optimize for the default case, of a small nfds value */
	if (sz > sizeof(pfds))
		pl = malloc(sz, M_TEMP, M_WAITOK);
@


1.91
log
@use mallocarray where arguments are multipled. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.90 2014/07/12 21:21:19 matthew Exp $	*/
d948 1
a948 1
		pl = (struct pollfd *) malloc(sz, M_TEMP, M_WAITOK);
@


1.90
log
@Refactor out dosigsuspend() function

Discussed with guenther and kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.89 2014/07/12 18:43:32 tedu Exp $	*/
d619 1
a619 1
		mbits = malloc(ni * 6, M_TEMP, M_WAITOK|M_ZERO);
@


1.89
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.88 2014/07/08 17:42:50 miod Exp $	*/
d660 2
a661 5
	if (sigmask) {
		p->p_oldmask = p->p_sigmask;
		atomic_setbits_int(&p->p_flag, P_SIGSUSPEND);
		p->p_sigmask = *sigmask &~ sigcantmask;
	}
d965 2
a966 5
	if (sigmask) {
		p->p_oldmask = p->p_sigmask;
		atomic_setbits_int(&p->p_flag, P_SIGSUSPEND);
		p->p_sigmask = *sigmask &~ sigcantmask;
	}
@


1.88
log
@Repair compilability after the recent uvmexp changes, especially for
not compile-time-known page size platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.87 2014/07/08 17:19:25 deraadt Exp $	*/
d215 1
a215 1
		free(ktriov, M_TEMP);
d221 1
a221 1
		free(needfree, M_IOV);
d371 1
a371 1
		free(ktriov, M_TEMP);
d377 1
a377 1
		free(needfree, M_IOV);
d521 1
a521 1
		free(memp, M_IOCTLOPS);
d717 1
a717 1
		free(pibits[0], M_TEMP);
d1018 1
a1018 1
		free(pl, M_TEMP);
@


1.87
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.86 2014/03/30 21:54:48 guenther Exp $	*/
d62 2
@


1.86
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.85 2014/01/21 01:48:45 tedu Exp $	*/
a61 2

#include <uvm/uvm_extern.h>
@


1.85
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.84 2013/09/14 02:28:02 guenther Exp $	*/
d479 1
a479 1
			so->so_siguid = p->p_cred->p_ruid;
@


1.84
log
@Correct the handling of I/O of >=2^32 bytes and the ktracing there of
by using size_t/ssize_t instead of int/u_int to handle I/O lengths in
uiomove(), vn_fsizechk(), and ktrgenio().  Eliminate the always-zero
'error' argument to ktrgenio() at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.83 2013/09/14 01:35:01 guenther Exp $	*/
d451 1
a451 1
		bzero(data, size);
d627 1
a627 1
		bzero(bits, sizeof(bits));
@


1.83
log
@Snapshots for all archs have been built, so remove the T32 code
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.82 2013/08/13 05:52:24 guenther Exp $	*/
d214 1
a214 2
			ktrgenio(p, fd, UIO_READ, ktriov, cnt,
			    error);
d370 1
a370 1
			ktrgenio(p, fd, UIO_WRITE, ktriov, cnt, error);
@


1.82
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.81 2013/06/01 16:27:37 tedu Exp $	*/
a720 139

#ifdef T32
int
t32_sys_select(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_select_args /* {
		syscallarg(int) nd;
		syscallarg(fd_set *) in;
		syscallarg(fd_set *) ou;
		syscallarg(fd_set *) ex;
		syscallarg(struct timeval32 *) tv;
	} */ *uap = v;
	fd_mask bits[6];
	fd_set *pibits[3], *pobits[3];
	struct timeval32 atv32;
	struct timeval atv, rtv, ttv;
	int s, ncoll, error = 0, timo;
	u_int nd, ni;

	nd = SCARG(uap, nd);
	if (nd > p->p_fd->fd_nfiles) {
		/* forgiving; slightly wrong */
		nd = p->p_fd->fd_nfiles;
	}
	ni = howmany(nd, NFDBITS) * sizeof(fd_mask);
	if (ni > sizeof(bits[0])) {
		caddr_t mbits;

		mbits = malloc(ni * 6, M_TEMP, M_WAITOK|M_ZERO);
		pibits[0] = (fd_set *)&mbits[ni * 0];
		pibits[1] = (fd_set *)&mbits[ni * 1];
		pibits[2] = (fd_set *)&mbits[ni * 2];
		pobits[0] = (fd_set *)&mbits[ni * 3];
		pobits[1] = (fd_set *)&mbits[ni * 4];
		pobits[2] = (fd_set *)&mbits[ni * 5];
	} else {
		bzero(bits, sizeof(bits));
		pibits[0] = (fd_set *)&bits[0];
		pibits[1] = (fd_set *)&bits[1];
		pibits[2] = (fd_set *)&bits[2];
		pobits[0] = (fd_set *)&bits[3];
		pobits[1] = (fd_set *)&bits[4];
		pobits[2] = (fd_set *)&bits[5];
	}

#define	getbits(name, x) \
	if (SCARG(uap, name) && (error = copyin(SCARG(uap, name), \
	    pibits[x], ni))) \
		goto done;
	getbits(in, 0);
	getbits(ou, 1);
	getbits(ex, 2);
#undef	getbits
#ifdef KTRACE
	if (ni > 0 && KTRPOINT(p, KTR_STRUCT)) {
		if (SCARG(uap, in)) ktrfdset(p, pibits[0], ni);
		if (SCARG(uap, ou)) ktrfdset(p, pibits[1], ni);
		if (SCARG(uap, ex)) ktrfdset(p, pibits[2], ni);
	}
#endif

	if (SCARG(uap, tv)) {
		error = copyin(SCARG(uap, tv), &atv32, sizeof(atv32));
		if (error)
			goto done;
		TIMEVAL_FROM_32(&atv, &atv32);
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrreltimeval(p, &atv);
#endif
		if (itimerfix(&atv)) {
			error = EINVAL;
			goto done;
		}
		getmicrouptime(&rtv);
		timeradd(&atv, &rtv, &atv);
	} else {
		atv.tv_sec = 0;
		atv.tv_usec = 0;
	}
	timo = 0;

retry:
	ncoll = nselcoll;
	atomic_setbits_int(&p->p_flag, P_SELECT);
	error = selscan(p, pibits[0], pobits[0], nd, ni, retval);
	if (error || *retval)
		goto done;
	if (SCARG(uap, tv)) {
		getmicrouptime(&rtv);
		if (timercmp(&rtv, &atv, >=))
			goto done;
		ttv = atv;
		timersub(&ttv, &rtv, &ttv);
		timo = ttv.tv_sec > 24 * 60 * 60 ?
			24 * 60 * 60 * hz : tvtohz(&ttv);
	}
	s = splhigh();
	if ((p->p_flag & P_SELECT) == 0 || nselcoll != ncoll) {
		splx(s);
		goto retry;
	}
	atomic_clearbits_int(&p->p_flag, P_SELECT);
	error = tsleep(&selwait, PSOCK | PCATCH, "select", timo);
	splx(s);
	if (error == 0)
		goto retry;
done:
	atomic_clearbits_int(&p->p_flag, P_SELECT);
	/* select is not restarted after signals... */
	if (error == ERESTART)
		error = EINTR;
	if (error == EWOULDBLOCK)
		error = 0;
#define	putbits(name, x) \
	if (SCARG(uap, name) && (error2 = copyout(pobits[x], \
	    SCARG(uap, name), ni))) \
		error = error2;
	if (error == 0) {
		int error2;

		putbits(in, 0);
		putbits(ou, 1);
		putbits(ex, 2);
#undef putbits
#ifdef KTRACE
		if (ni > 0 && KTRPOINT(p, KTR_STRUCT)) {
			if (SCARG(uap, in)) ktrfdset(p, pobits[0], ni);
			if (SCARG(uap, ou)) ktrfdset(p, pobits[1], ni);
			if (SCARG(uap, ex)) ktrfdset(p, pobits[2], ni);
		}
#endif
	}

	if (pibits[0] != (fd_set *)&bits[0])
		free(pibits[0], M_TEMP);
	return (error);
}
#endif
@


1.81
log
@always implement stub utrace syscall, but keep the body #ifdef KTRACE
ok guenther matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.80 2013/05/19 19:14:44 guenther Exp $	*/
d721 139
@


1.80
log
@select(-1, ...) should fail with EINVAL.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.79 2013/04/29 17:06:20 matthew Exp $	*/
d1021 20
@


1.79
log
@Extend P_SIGSUSPEND handling in userret() to properly restore the
sigmask even if there are no pending signals under the temporary
sigmask.

Refactor existing select() and poll() system calls to introduce the
pselect() and ppoll() system calls.

Add rthread wrappers for pselect() and ppoll().  While there, update
cancellation point comments to reflect recent fdatasync() addition.

Minor bumps for libc and librthread due to new symbols.

ok guenther, millert, deraadt, jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.78 2012/07/09 17:51:08 claudio Exp $	*/
d68 1
a68 1
int dopselect(struct proc *, u_int, fd_set *, fd_set *, fd_set *,
d601 1
a601 1
dopselect(struct proc *p, u_int nd, fd_set *in, fd_set *ou, fd_set *ex,
d610 2
@


1.78
log
@Print the fd_set used by select in kdump.
OK guenther@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.77 2012/07/09 10:47:29 claudio Exp $	*/
d68 4
d541 63
d606 1
a606 1
	struct timeval atv, rtv, ttv;
d608 1
a608 1
	u_int nd, ni;
a609 1
	nd = SCARG(uap, nd);
d636 1
a636 2
	if (SCARG(uap, name) && (error = copyin(SCARG(uap, name), \
	    pibits[x], ni))) \
d644 3
a646 3
		if (SCARG(uap, in)) ktrfdset(p, pibits[0], ni);
		if (SCARG(uap, ou)) ktrfdset(p, pibits[1], ni);
		if (SCARG(uap, ex)) ktrfdset(p, pibits[2], ni);
d650 3
a652 14
	if (SCARG(uap, tv)) {
		error = copyin(SCARG(uap, tv), &atv, sizeof (atv));
		if (error)
			goto done;
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrreltimeval(p, &atv);
#endif
		if (itimerfix(&atv)) {
			error = EINVAL;
			goto done;
		}
		getmicrouptime(&rtv);
		timeradd(&atv, &rtv, &atv);
d654 2
a655 2
		atv.tv_sec = 0;
		atv.tv_usec = 0;
d659 6
d671 3
a673 3
	if (SCARG(uap, tv)) {
		getmicrouptime(&rtv);
		if (timercmp(&rtv, &atv, >=))
d675 3
a677 4
		ttv = atv;
		timersub(&ttv, &rtv, &ttv);
		timo = ttv.tv_sec > 24 * 60 * 60 ?
			24 * 60 * 60 * hz : tvtohz(&ttv);
d697 1
a697 2
	if (SCARG(uap, name) && (error2 = copyout(pobits[x], \
	    SCARG(uap, name), ni))) \
d708 3
a710 3
			if (SCARG(uap, in)) ktrfdset(p, pobits[0], ni);
			if (SCARG(uap, ou)) ktrfdset(p, pobits[1], ni);
			if (SCARG(uap, ex)) ktrfdset(p, pobits[2], ni);
d880 56
d938 1
a938 2
	int msec = SCARG(uap, timeout);
	struct timeval atv, rtv, ttv;
a940 1
	u_int nfds = SCARG(uap, nfds);
d952 1
a952 1
	if ((error = copyin(SCARG(uap, fds), pl, sz)) != 0)
d958 3
a960 10
	if (msec != INFTIM) {
		atv.tv_sec = msec / 1000;
		atv.tv_usec = (msec - (atv.tv_sec * 1000)) * 1000;

		if (itimerfix(&atv)) {
			error = EINVAL;
			goto done;
		}
		getmicrouptime(&rtv);
		timeradd(&atv, &rtv, &atv);
d962 2
a963 2
		atv.tv_sec = 0;
		atv.tv_usec = 0;
d967 6
d979 3
a981 3
	if (msec != INFTIM) {
		getmicrouptime(&rtv);
		if (timercmp(&rtv, &atv, >=))
d983 3
a985 4
		ttv = atv;
		timersub(&ttv, &rtv, &ttv);
		timo = ttv.tv_sec > 24 * 60 * 60 ?
			24 * 60 * 60 * hz : tvtohz(&ttv);
d1006 1
a1006 1
		error = pollout(pl, SCARG(uap, fds), nfds);
d1012 1
a1012 1
		error = pollout(pl, SCARG(uap, fds), nfds);
@


1.77
log
@Compare the size of the static fd_mask against the number of bytes needed
not against the number bit / number of fds in the select set.
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.76 2012/04/22 05:43:14 guenther Exp $	*/
d577 7
d648 7
@


1.76
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.75 2012/03/19 09:05:39 guenther Exp $	*/
d549 1
a549 1
	if (nd > sizeof(bits[0])) {
@


1.75
log
@Add tracing and dumping of "pointer to struct" syscall arguments for
structs timespec, timeval, sigaction, and rlimit.

ok otto@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.74 2012/02/15 04:26:27 guenther Exp $	*/
d220 1
a220 1
	FRELE(fp);
d376 1
a376 1
	FRELE(fp);
d516 1
a516 1
	FRELE(fp);
d675 1
a675 1
				FRELE(fp);
d770 1
a770 1
		FRELE(fp);
@


1.74
log
@Hold struct filedesc's fd_lock when writing to the fd_ofiles, fd_ofileflags,
or fd_{lo,hi}maps members, or when doing a read for a write.  Fixes hangs
when an rthreaded processes sleeps while copying the fd table for fork()
and catches another thread with the lock.

ok jsing@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.73 2011/11/06 12:10:04 guenther Exp $	*/
d582 4
@


1.73
log
@Document a non-obvious reason why something can't overflow.
Discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.72 2010/12/19 19:54:46 kettenis Exp $	*/
a410 2
		fdp->fd_ofileflags[SCARG(uap, fd)] &= ~UF_EXCLOSE;
		return (0);
d412 6
a417 1
		fdp->fd_ofileflags[SCARG(uap, fd)] |= UF_EXCLOSE;
@


1.72
log
@Since we have an ioctl that uses a struct with an off_t member as its
argument, we need to make sure this buffer has 64-bit alignment, even
on 32-bit architectures.  Fixes the alignment trap triggered by
vnconfig(8) on sparc for kernels compiled with gcc4.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.71 2010/08/18 17:42:12 marco Exp $	*/
d179 2
a180 1
		 * avoid garbage return values.
d333 2
a334 1
		 * avoid garbage return values.
@


1.71
log
@delete some rogue spaces and tabs. no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.70 2010/07/26 01:56:27 guenther Exp $	*/
d398 1
a398 1
	u_long stkbuf[STK_PARAMS / sizeof(u_long)];
@


1.70
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.69 2010/07/08 20:15:03 deraadt Exp $	*/
d191 1
a191 1
	if (KTRPOINT(p, KTR_GENIO))  {
d208 1
a208 1
		if (error == 0) 
d344 1
a344 1
	if (KTRPOINT(p, KTR_GENIO))  {
d364 1
a364 1
		if (error == 0) 
d633 1
a633 1
	
d776 1
a776 1
	
d812 1
a812 1
	
@


1.69
log
@Devices which don't have read or write functionality should not return
enodev to poll, because this returns an errno of 19 in revents.  Oops.
Use seltrue where needed, and use a new selfalse function for those which
don't know if the next op will be non-blocking
Mostly discussed with guenther and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.68 2010/04/11 17:46:13 kettenis Exp $	*/
d479 2
a480 2
			struct proc *p1 = pfind(tmp);
			if (p1 == 0) {
d484 1
a484 1
			tmp = p1->p_pgrp->pg_id;
@


1.68
log
@In sys_ioctl(), change the type of stkbuf to u_long to make sure it is
properly aligned.  Otherwise we lose on strict alignment architectures if
the compiler happens to give it a smaller alignment.  Fixes another gcc4
problem on sparc64.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.67 2009/11/09 17:53:39 nicm Exp $	*/
a65 1
int seltrue(dev_t, int, struct proc *);
d680 7
@


1.67
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.66 2009/06/08 23:18:42 deraadt Exp $	*/
d399 1
a399 1
	char stkbuf[STK_PARAMS];
d430 1
a430 1
		data = stkbuf;
@


1.66
log
@must calculate iovlen or ktrace panics the machine; diff from blambert
and it is pretty critical so commiting it now.  Any more fallout from
the code 'simplication'?
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.65 2009/06/04 00:24:02 blambert Exp $	*/
d711 1
@


1.65
log
@Put readv/writev changes back in, as they no longer hang ckuethe's ntpd.

Special thanks to ckuethe's ntpd for noticing the problem.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.64 2009/06/03 03:57:20 blambert Exp $	*/
d142 3
a149 2
		/* note: can't use iovlen until iovcnt is validated */
		iovlen = iovcnt * sizeof(struct iovec);
d295 3
a302 2
		/* note: can't use iovlen until iovcnt is validated */
		iovlen = iovcnt * sizeof(struct iovec);
@


1.64
log
@Revert readv/writev changes, as they trigger an apparent file descriptor
deadlock for ckuethe@@

"if you have to revert, you have to revert" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.63 2009/06/02 05:20:41 thib Exp $	*/
d82 1
d92 3
d97 2
a98 60
	/* dofileread() will FRELE the descriptor for us */
	return (dofileread(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &fp->f_offset, retval));
}

int
dofileread(struct proc *p, int fd, struct file *fp, void *buf, size_t nbyte,
    off_t *offset, register_t *retval)
{
	struct uio auio;
	struct iovec aiov;
	long cnt, error = 0;
#ifdef KTRACE
	struct iovec ktriov;
#endif

	aiov.iov_base = buf;
	aiov.iov_len = nbyte;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_resid = nbyte;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;

	/*
	 * Reads return ssize_t because -1 is returned on error.  Therefore
	 * we must restrict the length to SSIZE_MAX to avoid garbage return
	 * values.
	 */
	if (auio.uio_resid > SSIZE_MAX) {
		error = EINVAL;
		goto out;
	}

#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))
		ktriov = aiov;
#endif
	cnt = auio.uio_resid;
	error = (*fp->f_ops->fo_read)(fp, offset, &auio, fp->f_cred);
	if (error)
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	cnt -= auio.uio_resid;

	fp->f_rxfer++;
	fp->f_rbytes += cnt;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO) && error == 0)
		ktrgenio(p, fd, UIO_READ, &ktriov, cnt, error);
#endif
	*retval = cnt;
 out:
	FRELE(fp);
	return (error);
d124 1
a124 1
	return (dofilereadv(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
d130 1
a130 1
    int iovcnt, off_t *offset, register_t *retval)
d132 1
d135 1
a135 2
	struct iovec *needfree;
	struct iovec aiov[UIO_SMALLIOV];
d142 17
a158 4
	/* note: can't use iovlen until iovcnt is validated */
	iovlen = iovcnt * sizeof(struct iovec);
	if ((u_int)iovcnt > UIO_SMALLIOV) {
		if ((u_int)iovcnt > IOV_MAX) {
d162 2
a163 4
		iov = needfree = malloc(iovlen, M_IOV, M_WAITOK);
	} else if ((u_int)iovcnt > 0) {
		iov = aiov;
		needfree = NULL;
d165 1
a165 2
		error = EINVAL;
		goto out;
a172 3
	error = copyin(iovp, iov, iovlen);
	if (error)
		goto done;
d234 1
d244 3
d249 2
a250 63
	/* dofilewrite() will FRELE the descriptor for us */
	return (dofilewrite(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &fp->f_offset, retval));
}

int
dofilewrite(struct proc *p, int fd, struct file *fp, const void *buf,
    size_t nbyte, off_t *offset, register_t *retval)
{
	struct uio auio;
	struct iovec aiov;
	long cnt, error = 0;
#ifdef KTRACE
	struct iovec ktriov;
#endif

	aiov.iov_base = (void *)buf;		/* XXX kills const */
	aiov.iov_len = nbyte;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_resid = nbyte;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;

	/*
	 * Writes return ssize_t because -1 is returned on error.  Therefore
	 * we must restrict the length to SSIZE_MAX to avoid garbage return
	 * values.
	 */
	if (auio.uio_resid > SSIZE_MAX) {
		error = EINVAL;
		goto out;
	}

#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))
		ktriov = aiov;
#endif
	cnt = auio.uio_resid;
	error = (*fp->f_ops->fo_write)(fp, offset, &auio, fp->f_cred);
	if (error) {
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
			ptsignal(p, SIGPIPE, STHREAD);
	}
	cnt -= auio.uio_resid;

	fp->f_wxfer++;
	fp->f_wbytes += cnt;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO) && error == 0)
		ktrgenio(p, fd, UIO_WRITE, &ktriov, cnt, error);
#endif
	*retval = cnt;
 out:
	FRELE(fp);
	return (error);
d276 1
a276 1
	return (dofilewritev(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
d282 1
a282 1
    int iovcnt, off_t *offset, register_t *retval)
d284 1
d287 1
a287 2
	struct iovec *needfree;
	struct iovec aiov[UIO_SMALLIOV];
d294 17
a310 4
	/* note: can't use iovlen until iovcnt is validated */
	iovlen = iovcnt * sizeof(struct iovec);
	if ((u_int)iovcnt > UIO_SMALLIOV) {
		if ((u_int)iovcnt > IOV_MAX) {
d314 2
a315 4
		iov = needfree = malloc(iovlen, M_IOV, M_WAITOK);
	} else if ((u_int)iovcnt > 0) {
		iov = aiov;
		needfree = NULL;
d317 1
a317 2
		error = EINVAL;
		goto out;
a324 3
	error = copyin(iovp, iov, iovlen);
	if (error)
		goto done;
@


1.63
log
@set needfree to NULL in sys_writev() so stack garbage
does not cause us to call free if we never malloced.

crash found by & OK marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.62 2009/06/02 04:13:37 deraadt Exp $	*/
a81 1
	struct iovec iov;
d91 17
a107 2
	iov.iov_base = (void *)SCARG(uap, buf);
	iov.iov_len = SCARG(uap, nbyte);
d109 33
a141 1
	FREF(fp);
d143 10
a152 2
	/* dofilereadv() will FRELE the descriptor for us */
	return (dofilereadv(p, fd, fp, &iov, 1, &fp->f_offset, retval));
a160 1
	struct iovec aiov[UIO_SMALLIOV];
a168 5
	struct iovec *iov, *needfree;
	const struct iovec *iovp = SCARG(uap, iovp);
	int iovcnt = SCARG(uap, iovcnt);
	int iovlen;
	int error;
d175 21
d212 1
a212 27
	error = copyin(iovp, iov, iovlen);
	if (error)
		goto out;

	FREF(fp);

	/* dofilereadv() will FRELE the descriptor for us */
	error = dofilereadv(p, fd, fp, iov, iovcnt, &fp->f_offset, retval);
out:
	if (needfree)
		free(needfree, M_IOV);

	return (error);
}

int
dofilereadv(struct proc *p, int fd, struct file *fp, const struct iovec *iov,
    int iovcnt, off_t *offset, register_t *retval)
{
	struct uio auio;
	long i, cnt, error = 0;
#ifdef KTRACE
	u_int iovlen = iovcnt * sizeof(struct iovec);
	struct iovec *ktriov = NULL;
#endif

	auio.uio_iov = (struct iovec *)iov;
d217 3
d230 1
a230 1
			goto out;
d262 3
a280 1
	struct iovec iov;
d292 4
a295 2
	iov.iov_base = (void *)SCARG(uap, buf);
	iov.iov_len = SCARG(uap, nbyte);
d297 58
a354 2
	/* dofilewritev() will FRELE the descriptor for us */
	return (dofilewritev(p, fd, fp, &iov, 1, &fp->f_offset, retval));
a362 1
	struct iovec aiov[UIO_SMALLIOV];
d368 2
a370 8
	struct file *fp;
	struct iovec *needfree = NULL;
	struct iovec *iov;
	const struct iovec *iovp = SCARG(uap, iovp);
	int fd = SCARG(uap, fd);
	int iovcnt = SCARG(uap, iovcnt);
	u_int iovlen;
	int error;
d379 19
a412 3
	error = copyin(iovp, iov, iovlen);
	if (error)
		goto out;
d414 1
a414 21
	/* dofilewritev() will FRELE the descriptor for us */
	error = dofilewritev(p, fd, fp, iov, iovcnt, &fp->f_offset, retval);
out:
	if (needfree)
		free(needfree, M_IOV);

	return (error);
}

int
dofilewritev(struct proc *p, int fd, struct file *fp, const struct iovec *iov,
    int iovcnt, off_t *offset, register_t *retval)
{
	struct uio auio;
	long i, cnt, error = 0;
#ifdef KTRACE
	u_int iovlen;
	struct iovec *ktriov = NULL;
#endif

	auio.uio_iov = (struct iovec *)iov;
d419 3
d432 1
a432 1
			goto out;
d466 3
d582 2
a583 1
		error = (*fp->f_ops->fo_ioctl)(fp, TIOCSPGRP, (caddr_t)&tmp, p);
@


1.62
log
@it is better when ramdisks compile
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.61 2009/06/02 03:04:09 blambert Exp $	*/
d265 1
a265 1
	struct iovec *needfree;
@


1.61
log
@dofile{read,write} are essentially identical to their iovec equivalents,
dofile{read,write}v, so remove the former and rework it so that everything
uses the latter

"nice" deraadt@@ "reads ok" oga@@ spastic 'OMG Ponies!!!!' weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.60 2009/03/24 13:49:38 kurt Exp $	*/
d164 1
a165 1
#ifdef KTRACE
d314 1
a315 1
#ifdef KTRACE
@


1.60
log
@Only copy out the revents field, not the whole pollfd structure. This
allows threaded programs to concurrently update the events field while
a thread is blocked in poll(2).

okay deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.59 2008/12/16 07:57:28 guenther Exp $	*/
d82 1
d92 3
d97 2
a98 60
	/* dofileread() will FRELE the descriptor for us */
	return (dofileread(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &fp->f_offset, retval));
}

int
dofileread(struct proc *p, int fd, struct file *fp, void *buf, size_t nbyte,
    off_t *offset, register_t *retval)
{
	struct uio auio;
	struct iovec aiov;
	long cnt, error = 0;
#ifdef KTRACE
	struct iovec ktriov;
#endif

	aiov.iov_base = buf;
	aiov.iov_len = nbyte;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_resid = nbyte;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;

	/*
	 * Reads return ssize_t because -1 is returned on error.  Therefore
	 * we must restrict the length to SSIZE_MAX to avoid garbage return
	 * values.
	 */
	if (auio.uio_resid > SSIZE_MAX) {
		error = EINVAL;
		goto out;
	}

#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))
		ktriov = aiov;
#endif
	cnt = auio.uio_resid;
	error = (*fp->f_ops->fo_read)(fp, offset, &auio, fp->f_cred);
	if (error)
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	cnt -= auio.uio_resid;

	fp->f_rxfer++;
	fp->f_rbytes += cnt;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO) && error == 0)
		ktrgenio(p, fd, UIO_READ, &ktriov, cnt, error);
#endif
	*retval = cnt;
 out:
	FRELE(fp);
	return (error);
d107 1
d116 5
a126 21
	FREF(fp);

	/* dofilereadv() will FRELE the descriptor for us */
	return (dofilereadv(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
	    &fp->f_offset, retval));
}

int
dofilereadv(struct proc *p, int fd, struct file *fp, const struct iovec *iovp,
    int iovcnt, off_t *offset, register_t *retval)
{
	struct uio auio;
	struct iovec *iov;
	struct iovec *needfree;
	struct iovec aiov[UIO_SMALLIOV];
	long i, cnt, error = 0;
	u_int iovlen;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif

d143 27
a169 1
	auio.uio_iov = iov;
a173 3
	error = copyin(iovp, iov, iovlen);
	if (error)
		goto done;
d184 1
a184 1
			goto done;
a215 3
 done:
	if (needfree)
		free(needfree, M_IOV);
d232 1
d244 2
a245 4
	/* dofilewrite() will FRELE the descriptor for us */
	return (dofilewrite(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &fp->f_offset, retval));
}
d247 2
a248 58
int
dofilewrite(struct proc *p, int fd, struct file *fp, const void *buf,
    size_t nbyte, off_t *offset, register_t *retval)
{
	struct uio auio;
	struct iovec aiov;
	long cnt, error = 0;
#ifdef KTRACE
	struct iovec ktriov;
#endif

	aiov.iov_base = (void *)buf;		/* XXX kills const */
	aiov.iov_len = nbyte;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_resid = nbyte;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;

	/*
	 * Writes return ssize_t because -1 is returned on error.  Therefore
	 * we must restrict the length to SSIZE_MAX to avoid garbage return
	 * values.
	 */
	if (auio.uio_resid > SSIZE_MAX) {
		error = EINVAL;
		goto out;
	}

#ifdef KTRACE
	/*
	 * if tracing, save a copy of iovec
	 */
	if (KTRPOINT(p, KTR_GENIO))
		ktriov = aiov;
#endif
	cnt = auio.uio_resid;
	error = (*fp->f_ops->fo_write)(fp, offset, &auio, fp->f_cred);
	if (error) {
		if (auio.uio_resid != cnt && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE)
			ptsignal(p, SIGPIPE, STHREAD);
	}
	cnt -= auio.uio_resid;

	fp->f_wxfer++;
	fp->f_wbytes += cnt;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO) && error == 0)
		ktrgenio(p, fd, UIO_WRITE, &ktriov, cnt, error);
#endif
	*retval = cnt;
 out:
	FRELE(fp);
	return (error);
d257 1
d263 5
d269 3
a271 2
	struct file *fp;
	struct filedesc *fdp = p->p_fd;
a279 19
	/* dofilewritev() will FRELE the descriptor for us */
	return (dofilewritev(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
	    &fp->f_offset, retval));
}

int
dofilewritev(struct proc *p, int fd, struct file *fp, const struct iovec *iovp,
    int iovcnt, off_t *offset, register_t *retval)
{
	struct uio auio;
	struct iovec *iov;
	struct iovec *needfree;
	struct iovec aiov[UIO_SMALLIOV];
	long i, cnt, error = 0;
	u_int iovlen;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
#endif

d295 3
d299 21
a319 1
	auio.uio_iov = iov;
a323 3
	error = copyin(iovp, iov, iovlen);
	if (error)
		goto done;
d334 1
a334 1
			goto done;
a367 3
 done:
	if (needfree)
		free(needfree, M_IOV);
d481 1
a481 2
		error = (*fp->f_ops->fo_ioctl)
			(fp, TIOCSPGRP, (caddr_t)&tmp, p);
@


1.59
log
@Move the functionality of psignal() to a new function ptsignal()
that takes an additional argument "type" that indicates whether the
signal is for the process, just a particular thread, or propagated
to a thread because it's not caught or blocked.  psignal() becomes
a wrapper that does the first of those.

So that sys_kill() can tell apart signals for the process and signals
for the process's original thread, the tid of the original thread
is defined as its pid + THREAD_PID_OFFSET.

ok tedu@@ art@@ andreas@@ kurt@@   "better early than late" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.58 2007/09/07 15:00:20 art Exp $	*/
d68 1
d857 19
d961 1
a961 1
		error = copyout(pl, SCARG(uap, fds), sz);
d967 1
a967 1
		error = copyout(pl, SCARG(uap, fds), sz);
@


1.58
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.57 2007/07/25 23:11:52 art Exp $	*/
d340 1
a340 1
			psignal(p, SIGPIPE);
d451 1
a451 1
			psignal(p, SIGPIPE);
@


1.57
log
@Back out the tracking of procs in struct selinfo. There's one serious
bug in the code, but as soon as I try to fix it, it seems to trigger
some other bugs. Instead of trying to figure out what's going on
while everyone suffers, it's better to back out and figure out
the bugs outside the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.55 2007/03/15 10:22:30 art Exp $	*/
d642 1
a642 2
		mbits = malloc(ni * 6, M_TEMP, M_WAITOK);
		bzero(mbits, ni * 6);
@


1.56
log
@Kill the horrible hack of storing the pid in struct selinfo.

Instead, keep the proc pointer in it and put the selinfo on a list
in struct proc in selrecord. Then clean up the list when leaving
sys_select and sys_poll.

miod@@ ok, testing by many, including Bobs spamd boxes.
@
text
@a68 2
void sel_clean_proclist(struct proc *);

a710 1
	sel_clean_proclist(p);
d784 8
a791 4
	if (sip->si_selproc == NULL) {
		sip->si_selproc = selector;
		TAILQ_INSERT_TAIL(&selector->p_selects, sip, si_list);
	} else if (sip->si_selproc != selector) {
d793 2
a794 1
	}
d806 2
d813 5
a817 12

	/*
	 * We check the process once before locking.
	 * Then we wake the process and clean up its
	 * selects list.
	 */
	if (sip->si_selproc == NULL)
		return;

	SCHED_LOCK(s);
	if ((p = sip->si_selproc) != NULL) {
		if (p->p_wchan != NULL) {
d822 1
a822 1
		} else {
d824 1
a824 13
		}
	}
	SCHED_UNLOCK(s);
}

void
sel_clean_proclist(struct proc *p)
{
	struct selinfo *sip;

	while ((sip = TAILQ_FIRST(&p->p_selects)) != NULL) {
		sip->si_selproc = NULL;
		TAILQ_REMOVE(&p->p_selects, sip, si_list);
a934 1
	sel_clean_proclist(p);
@


1.55
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.54 2006/04/15 20:02:19 miod Exp $	*/
d69 2
d713 1
d787 4
a790 8
	struct proc *p;
	pid_t mypid;

	mypid = selector->p_pid;
	if (sip->si_selpid == mypid)
		return;
	if (sip->si_selpid && (p = pfind(sip->si_selpid)) &&
	    p->p_wchan == (caddr_t)&selwait)
d792 1
a792 2
	else
		sip->si_selpid = mypid;
a803 2
	if (sip->si_selpid == 0)
		return;
d809 12
a820 5
	p = pfind(sip->si_selpid);
	sip->si_selpid = 0;
	if (p != NULL) {
		SCHED_LOCK(s);
		if (p->p_wchan == (caddr_t)&selwait) {
d825 1
a825 1
		} else if (p->p_flag & P_SELECT)
d827 13
a839 1
		SCHED_UNLOCK(s);
d950 1
@


1.54
log
@Repair FIOGETOWN operation; from Alexandre Ratchov.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.53 2006/03/26 17:47:10 mickey Exp $	*/
d687 1
a687 1
	p->p_flag |= P_SELECT;
d705 1
a705 1
	p->p_flag &= ~P_SELECT;
d711 1
a711 1
	p->p_flag &= ~P_SELECT;
d823 1
a823 1
			p->p_flag &= ~P_SELECT;
d910 1
a910 1
	p->p_flag |= P_SELECT;
d928 1
a928 1
	p->p_flag &= ~P_SELECT;
d935 1
a935 1
	p->p_flag &= ~P_SELECT;
@


1.53
log
@do per file io accounting and show that in fstat as well; pedro@@ marco@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.52 2006/03/15 11:22:16 claudio Exp $	*/
a596 6
		/*
		 * Copy any data to user, size was
		 * already set and checked above.
		 */
		if (error == 0 && (com&IOC_OUT) && size)
			error = copyout(data, SCARG(uap, data), (u_int)size);
d599 6
@


1.52
log
@copyout() the pollfds if poll() gets interrupted. This resets the revents
bitmask and makes poll() behave like documented in the man page.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.51 2005/12/13 10:33:14 jsg Exp $	*/
d141 3
d249 3
d343 3
d454 3
d460 1
a460 2
			ktrgenio(p, fd, UIO_WRITE, ktriov, cnt,
			    error);
@


1.51
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.50 2005/08/01 06:26:16 deraadt Exp $	*/
d931 3
a933 1
		error = EINTR;
@


1.50
log
@sys_select() used to use 6 local fd_set's in case the width was <= the
size of an fd_set (ie. 256 bits), to avoid the malloc.  that is a lot
of local storage. change the cross-over point to 32-bits, which is more
fair.  if you select with large widths, you pay the price.  tested by
dlg, read by millert and pascoe, run on all machines
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.49 2004/06/24 19:35:24 tholo Exp $	*/
d74 1
a74 4
sys_read(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d98 2
a99 8
dofileread(p, fd, fp, buf, nbyte, offset, retval)
	struct proc *p;
	int fd;
	struct file *fp;
	void *buf;
	size_t nbyte;
	off_t *offset;
	register_t *retval;
d155 1
a155 4
sys_readv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d179 2
a180 8
dofilereadv(p, fd, fp, iovp, iovcnt, offset, retval)
	struct proc *p;
	int fd;
	struct file *fp;
	const struct iovec *iovp;
	int iovcnt;
	off_t *offset;
	register_t *retval;
d267 1
a267 4
sys_write(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d291 2
a292 8
dofilewrite(p, fd, fp, buf, nbyte, offset, retval)
	struct proc *p;
	int fd;
	struct file *fp;
	const void *buf;
	size_t nbyte;
	off_t *offset;
	register_t *retval;
d351 1
a351 4
sys_writev(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d375 2
a376 8
dofilewritev(p, fd, fp, iovp, iovcnt, offset, retval)
	struct proc *p;
	int fd;
	struct file *fp;
	const struct iovec *iovp;
	int iovcnt;
	off_t *offset;
	register_t *retval;
d467 1
a467 4
sys_ioctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d725 2
a726 6
selscan(p, ibits, obits, nfd, ni, retval)
	struct proc *p;
	fd_set *ibits, *obits;
	int nfd;
	int ni;
	register_t *retval;
d729 3
a731 3
	register struct filedesc *fdp = p->p_fd;
	register int msk, i, j, fd;
	register fd_mask bits;
d761 1
a761 4
seltrue(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d771 1
a771 3
selrecord(selector, sip)
	struct proc *selector;
	struct selinfo *sip;
d790 1
a790 2
selwakeup(sip)
	register struct selinfo *sip;
d792 1
a792 1
	register struct proc *p;
d818 1
a818 5
pollscan(p, pl, nfd, retval)
	struct proc *p;
	struct pollfd *pl;
	u_int nfd;
	register_t *retval;
@


1.49
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.48 2004/06/13 21:49:26 niklas Exp $	*/
d65 1
a65 1
int selscan(struct proc *, fd_set *, fd_set *, int, register_t *);
d655 2
a656 1
	fd_set bits[6], *pibits[3], *pobits[3];
d667 1
a667 1
	if (nd > FD_SETSIZE) {
d680 6
a685 6
		pibits[0] = &bits[0];
		pibits[1] = &bits[1];
		pibits[2] = &bits[2];
		pobits[0] = &bits[3];
		pobits[1] = &bits[4];
		pobits[2] = &bits[5];
d716 1
a716 1
	error = selscan(p, pibits[0], pobits[0], nd, retval);
d758 1
a758 1
	if (pibits[0] != &bits[0])
d764 1
a764 1
selscan(p, ibits, obits, nfd, retval)
d768 1
d776 1
a776 1
	int ni, n = 0;
a777 8

	/*
	 * if nfd > FD_SETSIZE then the fd_set's contain nfd bits (rounded
	 * up to the next byte) otherwise the fd_set's are normal sized.
	 */
	ni = sizeof(fd_set);
	if (nfd > FD_SETSIZE)
		ni = howmany(nfd, NFDBITS) * sizeof(fd_mask);
@


1.48
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d656 1
a656 1
	struct timeval atv;
d704 8
a711 5
		s = splclock();
		timeradd(&atv, &time, &atv);
		splx(s);
	} else
		timo = 0;
d719 2
a720 5
		/*
		 * We have to recalculate the timeout on every retry.
		 */
		timo = hzto(&atv);
		if (timo <= 0)
d722 4
d919 1
a919 1
	struct timeval atv;
d948 7
a954 5
		s = splclock();
		timeradd(&atv, &time, &atv);
		splx(s);
	} else
		timo = 0;
d963 2
a964 5
		/*
		 * We have to recalculate the timeout on every retry.
		 */
		timo = hzto(&atv);
		if (timo <= 0)
d966 4
@


1.47
log
@Add an nfds_t type as per POSIX and also add pollfd_t like Solaris has.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.46 2003/09/23 16:51:12 millert Exp $	*/
d58 1
d856 1
a856 1
		s = splhigh();
d864 1
a864 1
		splx(s);
@


1.46
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.45 2003/09/01 18:06:03 henning Exp $	*/
d66 1
a66 1
void pollscan(struct proc *, struct pollfd *, int, register_t *);
d871 1
a871 1
	int nfd;
d876 2
a877 1
	int i, n = 0;
d906 5
a910 1
	struct sys_poll_args *uap = v;
d917 1
a917 6
	u_int nfds;

	if (SCARG(uap, nfds) < 0)
		return (EINVAL);

	nfds = SCARG(uap, nfds);
@


1.45
log
@match syscallargs comments with reality
from Patrick Latifi <patrick.l@@hermes.usherb.ca>
ok jason@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.44 2003/07/21 22:44:50 tedu Exp $	*/
d770 1
a770 1
	static int flag[3] = { FREAD, FWRITE, 0 };
d791 1
a791 1
				if ((*fp->f_ops->fo_select)(fp, flag[msk], p)) {
d805 1
a805 1
seltrue(dev, flag, p)
d807 1
a807 1
	int flag;
d811 1
a811 1
	return (1);
d874 1
a874 2
	register struct filedesc *fdp = p->p_fd;
	register int msk, i;
d876 1
a876 3
	int x, n = 0;
	static int flag[3] = { FREAD, FWRITE, 0 };
	static int pflag[3] = { POLLIN|POLLRDNORM, POLLOUT, POLLERR };
d878 1
a878 4
	/* 
	 * XXX: We need to implement the rest of the flags.
	 */
	for (i = 0; i < nfd; i++) {
d880 2
a881 2
		if (pl[i].fd < 0) {
			pl[i].revents = 0;
d884 2
a885 2
		if ((fp = fd_getfile(fdp, pl[i].fd)) == NULL) {
			pl[i].revents = POLLNVAL;
d890 1
a890 9
		for (x = msk = 0; msk < 3; msk++) {
			if (pl[i].events & pflag[msk]) {
				if ((*fp->f_ops->fo_select)(fp, flag[msk], p)) {
					pl[i].revents |= pflag[msk] &
					    pl[i].events;
					x++;
				}
			}
		}
d892 1
a892 1
		if (x)
d910 1
a910 1
	int timo, ncoll, i, s, error, error2;
d935 1
a935 1
	if (msec != -1) {
d955 1
a955 1
	if (msec != -1) {
d976 6
a981 2
	/* poll is not restarted after signals... */
	if (error == ERESTART)
d983 6
a988 4
	if (error == EWOULDBLOCK)
		error = 0;
	if ((error2 = copyout(pl, SCARG(uap, fds), sz)) != 0)
		error = error2;
d991 1
a991 1
		free((char *) pl, M_TEMP);
a993 1

@


1.44
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.43 2003/06/23 04:26:53 deraadt Exp $	*/
d510 1
a510 1
		syscallarg(caddr_t) data;
@


1.43
log
@fix nfds type; tedu marc ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.42 2003/06/02 23:28:06 millert Exp $	*/
d116 1
a116 1
	aiov.iov_base = (caddr_t)buf;
d253 1
a253 1
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
d327 1
a327 1
	aiov.iov_base = (caddr_t)buf;		/* XXX kills const */
d467 1
a467 1
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
d677 1
a677 1
		bzero((caddr_t)bits, sizeof(bits));
d687 2
a688 2
	if (SCARG(uap, name) && (error = copyin((caddr_t)SCARG(uap, name), \
	    (caddr_t)pibits[x], ni))) \
d696 1
a696 2
		error = copyin((caddr_t)SCARG(uap, tv), (caddr_t)&atv,
			sizeof (atv));
d728 1
a728 1
	error = tsleep((caddr_t)&selwait, PSOCK | PCATCH, "select", timo);
d740 2
a741 2
	if (SCARG(uap, name) && (error2 = copyout((caddr_t)pobits[x], \
	    (caddr_t)SCARG(uap, name), ni))) \
d850 1
a850 1
		wakeup((caddr_t)&selwait);
d983 1
a983 1
	error = tsleep((caddr_t)&selwait, PSOCK | PCATCH, "poll", timo);
@


1.42
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.41 2002/08/12 14:32:44 aaron Exp $	*/
d927 6
a932 1
	u_int nfds = SCARG(uap, nfds);
@


1.41
log
@Missing FRELE() call on writev(2) error condition; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.40 2002/08/11 02:20:24 provos Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.40
log
@SCARG cleanup; okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.39 2002/03/14 01:27:04 millert Exp $	*/
d430 4
a433 2
		if ((u_int)iovcnt > IOV_MAX)
			return (EINVAL);
@


1.39
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.38 2002/03/13 00:24:18 miod Exp $	*/
d647 1
a647 4
sys_select(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
d649 1
a649 1
	register struct sys_select_args /* {
d659 1
a659 1
	u_int ni;
d661 2
a662 1
	if (SCARG(uap, nd) > p->p_fd->fd_nfiles) {
d664 1
a664 1
		SCARG(uap, nd) = p->p_fd->fd_nfiles;
d666 2
a667 2
	ni = howmany(SCARG(uap, nd), NFDBITS) * sizeof(fd_mask);
	if (SCARG(uap, nd) > FD_SETSIZE) {
d714 1
a714 1
	error = selscan(p, pibits[0], pobits[0], SCARG(uap, nd), retval);
d920 1
a920 4
sys_poll(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
d929 1
d932 1
a932 2
	if (SCARG(uap, nfds) > min((int)p->p_rlimit[RLIMIT_NOFILE].rlim_cur, 
	    maxfiles))
d935 1
a935 1
	sz = sizeof(struct pollfd) * SCARG(uap, nfds);
d944 1
a944 1
	for (i = 0; i < SCARG(uap, nfds); i++)
d964 1
a964 1
	pollscan(p, pl, SCARG(uap, nfds), retval);
@


1.39.2.1
log
@PUll in patch from current:
SCARG cleanup; okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.39 2002/03/14 01:27:04 millert Exp $	*/
d647 4
a650 1
sys_select(struct proc *p, void *v, register_t *retval)
d652 1
a652 1
	struct sys_select_args /* {
d662 1
a662 1
	u_int nd, ni;
d664 1
a664 2
	nd = SCARG(uap, nd);
	if (nd > p->p_fd->fd_nfiles) {
d666 1
a666 1
		nd = p->p_fd->fd_nfiles;
d668 2
a669 2
	ni = howmany(nd, NFDBITS) * sizeof(fd_mask);
	if (nd > FD_SETSIZE) {
d716 1
a716 1
	error = selscan(p, pibits[0], pobits[0], nd, retval);
d922 4
a925 1
sys_poll(struct proc *p, void *v, register_t *retval)
a933 1
	u_int nfds = SCARG(uap, nfds);
d936 2
a937 1
	if (nfds > min((int)p->p_rlimit[RLIMIT_NOFILE].rlim_cur, maxfiles))
d940 1
a940 1
	sz = sizeof(struct pollfd) * nfds;
d949 1
a949 1
	for (i = 0; i < nfds; i++)
d969 1
a969 1
	pollscan(p, pl, nfds, retval);
@


1.38
log
@On sparc, PAGE_SIZE and friends might not be a compile-time constant.
Instead of using a homegrown set of variables in this case, rely on uvmexp
fields once uvm has been initialized.

This requires a few #include <uvm/uvm_extern.h> here and there in the kernel
as well.

Idea from art@@, changes by me.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.37 2002/02/13 19:08:06 art Exp $	*/
d68 3
a70 3
int selscan __P((struct proc *, fd_set *, fd_set *, int, register_t *));
int seltrue __P((dev_t, int, struct proc *));
void pollscan __P((struct proc *, struct pollfd *, int, register_t *));
@


1.37
log
@More FREF/FRELE on relevant places. Now, only sys_mmap and a bunch of ioctl functions in sys/compat are left.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.36 2002/02/08 19:58:03 art Exp $	*/
d65 2
@


1.36
log
@Require a FREFd file in dofilewrite{,v}.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.35 2002/02/08 19:47:50 art Exp $	*/
d507 1
a507 1
	register struct sys_ioctl_args /* {
d512 5
a516 5
	register struct file *fp;
	register struct filedesc *fdp;
	register u_long com;
	register int error;
	register u_int size;
d545 1
d556 1
a556 3
				if (memp)
					free(memp, M_IOCTLOPS);
				return (error);
d632 2
d793 1
d798 1
d898 1
d908 1
@


1.35
log
@require a FREFd fp in dofilereadv. Fix some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.34 2002/02/08 13:53:28 art Exp $	*/
d305 3
a307 1
	/* dofilewrite() will unuse the descriptor for us */
d371 1
d398 3
a400 1
	/* dofilewritev() will unuse the descriptor for us */
d493 1
@


1.34
log
@- Rename FILE_{,UN}USE to FREF and FRELE. USE is a bad verb and we don't have
  the same semantics as NetBSD anyway, so it's good to avoid name collissions.
- Always fdremove before freeing the file, not the other way around.
- falloc FREFs the file.
- have FILE_SET_MATURE FRELE the file (It feels like a good ortogonality to
  falloc FREFing the file).
- Use closef as much as possible instead of ffree in error paths of
  falloc:ing functions. closef is much more careful with the fd and can
  deal with the fd being forcibly closed by dup2. Also try to avoid
  manually calling *fo_close when closef can do that for us (this makes
  some error paths mroe complicated (sys_socketpair and sys_pipe), but
  others become simpler (sys_open)).
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.33 2002/02/05 16:02:27 art Exp $	*/
d96 1
a96 1
	/* dofileread() will unuse the descriptor for us */
d184 3
a186 1
	/* dofilereadv() will unuse the descriptor for us */
d278 1
@


1.33
log
@Add counting of temporary references to a struct file (as opposed to references
from fd tables and other long-lived objects). This is to avoid races between
using a file descriptor and having another process (with shared fd table)
close it. We use a separate refence count so that error values from close(2)
will be correctly returned to the caller of close(2).

The macros for those reference counts are FILE_USE(fp) and FILE_UNUSE(fp).

Make sure that the cases where closef can be called "incorrectly" (most notably
dup2(2)) are handled.

Right now only callers of closef (and {,p}read) use FILE_{,UN}USE correctly,
more fixes incoming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.32 2002/02/02 16:05:58 art Exp $	*/
d94 1
a94 1
	FILE_USE(fp);
d157 1
a157 1
	FILE_UNUSE(fp);
a275 3
#if notyet
	FILE_UNUSE(fp, p);
#endif
a365 3
#if notyet
	FILE_UNUSE(fp, p);
#endif
a484 3
#if notyet
	FILE_UNUSE(fp, p);
#endif
@


1.32
log
@Be more consistent about using fd_getfile where it matters.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.31 2001/11/14 19:47:07 deraadt Exp $	*/
d94 2
d157 1
a157 3
#if notyet
	FILE_UNUSE(fp, p);
#endif
@


1.31
log
@in poll, if fd is < 0, clear revents; bjy@@mogua.org
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.30 2001/10/26 12:03:27 art Exp $	*/
d790 1
a790 2
				fp = fdp->fd_ofiles[fd];
				if (fp == NULL)
d886 1
a886 7
		if (pl[i].fd < 0)
			continue;
		if (pl[i].fd >= fdp->fd_nfiles) {
			pl[i].revents = POLLNVAL;
			n++;
			continue;
		} else if (pl[i].fd < 0) {
d890 1
a890 3

		fp = fdp->fd_ofiles[pl[i].fd];
		if (fp == NULL) {
@


1.31.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.31 2001/11/14 19:47:07 deraadt Exp $	*/
d66 3
a68 5
#include <uvm/uvm_extern.h>

int selscan(struct proc *, fd_set *, fd_set *, int, register_t *);
int seltrue(dev_t, int, struct proc *);
void pollscan(struct proc *, struct pollfd *, int, register_t *);
d94 1
a94 3
	FREF(fp);

	/* dofileread() will FRELE the descriptor for us */
d155 3
a157 1
	FRELE(fp);
d184 1
a184 3
	FREF(fp);

	/* dofilereadv() will FRELE the descriptor for us */
d276 3
a278 1
	FRELE(fp);
d305 1
a305 3
	FREF(fp);

	/* dofilewrite() will FRELE the descriptor for us */
d369 3
a371 1
	FRELE(fp);
d398 1
a398 3
	FREF(fp);

	/* dofilewritev() will FRELE the descriptor for us */
d491 3
a493 1
	FRELE(fp);
d507 1
a507 1
	struct sys_ioctl_args /* {
d512 5
a516 5
	struct file *fp;
	struct filedesc *fdp;
	u_long com;
	int error;
	u_int size;
a544 1
	FREF(fp);
d555 3
a557 1
				goto out;
a632 2
out:
	FRELE(fp);
d790 2
a791 1
				if ((fp = fd_getfile(fdp, fd)) == NULL)
a792 1
				FREF(fp);
a796 1
				FRELE(fp);
d887 7
a893 1
		if (pl[i].fd < 0) {
d897 3
a899 1
		if ((fp = fd_getfile(fdp, pl[i].fd)) == NULL) {
a903 1
		FREF(fp);
a912 1
		FRELE(fp);
@


1.31.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.31.2.1 2002/06/11 03:29:40 art Exp $	*/
d430 2
a431 4
		if ((u_int)iovcnt > IOV_MAX) {
			error = EINVAL;
			goto out;
		}
d647 4
a650 1
sys_select(struct proc *p, void *v, register_t *retval)
d652 1
a652 1
	struct sys_select_args /* {
d662 1
a662 1
	u_int nd, ni;
d664 1
a664 2
	nd = SCARG(uap, nd);
	if (nd > p->p_fd->fd_nfiles) {
d666 1
a666 1
		nd = p->p_fd->fd_nfiles;
d668 2
a669 2
	ni = howmany(nd, NFDBITS) * sizeof(fd_mask);
	if (nd > FD_SETSIZE) {
d716 1
a716 1
	error = selscan(p, pibits[0], pobits[0], nd, retval);
d922 4
a925 1
sys_poll(struct proc *p, void *v, register_t *retval)
a933 1
	u_int nfds = SCARG(uap, nfds);
d936 2
a937 1
	if (nfds > min((int)p->p_rlimit[RLIMIT_NOFILE].rlim_cur, maxfiles))
d940 1
a940 1
	sz = sizeof(struct pollfd) * nfds;
d949 1
a949 1
	for (i = 0; i < nfds; i++)
d969 1
a969 1
	pollscan(p, pl, nfds, retval);
@


1.30
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.29 2001/05/16 12:52:58 ho Exp $	*/
d892 3
@


1.29
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.28 2000/11/10 18:15:47 art Exp $	*/
d89 3
a91 6
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
	    (fp->f_flag & FREAD) == 0)
a93 3
#if notyet
	FILE_USE(fp);
#endif
d179 3
a181 6
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
	    (fp->f_flag & FREAD) == 0)
a183 3
#if notyet
	FILE_USE(fp);
#endif
d300 3
a302 6
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
	    (fp->f_flag & FWRITE) == 0)
a304 3
#if notyet
	FILE_USE(fp);
#endif
d393 3
a395 6
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
	    (fp->f_flag & FWRITE) == 0)
a397 3
#if notyet
	FILE_USE(fp);
#endif
d523 1
a523 2
	if ((u_int)SCARG(uap, fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
@


1.29.2.1
log
@Errata #031 (provos):
SCARG cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.40 2002/08/11 02:20:24 provos Exp $	*/
d669 4
a672 1
sys_select(struct proc *p, void *v, register_t *retval)
d674 1
a674 1
	struct sys_select_args /* {
d684 1
a684 1
	u_int nd, ni;
d686 1
a686 2
	nd = SCARG(uap, nd);
	if (nd > p->p_fd->fd_nfiles) {
d688 1
a688 1
		nd = p->p_fd->fd_nfiles;
d690 2
a691 2
	ni = howmany(nd, NFDBITS) * sizeof(fd_mask);
	if (nd > FD_SETSIZE) {
d738 1
a738 1
	error = selscan(p, pibits[0], pobits[0], nd, retval);
d946 4
a949 1
sys_poll(struct proc *p, void *v, register_t *retval)
a957 1
	u_int nfds = SCARG(uap, nfds);
d960 2
a961 1
	if (nfds > min((int)p->p_rlimit[RLIMIT_NOFILE].rlim_cur, maxfiles))
d964 1
a964 1
	sz = sizeof(struct pollfd) * nfds;
d973 1
a973 1
	for (i = 0; i < nfds; i++)
d993 1
a993 1
	pollscan(p, pl, nfds, retval);
@


1.28
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.27 2000/09/27 16:13:46 mickey Exp $	*/
d694 1
a694 4
		if ((mbits = malloc(ni * 6, M_TEMP, M_WAITOK)) == NULL) {
			error = EINVAL;
			goto cleanup;
		}
a778 1
cleanup:
@


1.27
log
@replace MALLOC/FREE w/ malloc/free for non-constant-sized memory allocations; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.26 2000/07/07 14:33:20 art Exp $	*/
d157 1
a157 1
		ktrgenio(p->p_tracep, fd, UIO_READ, &ktriov, cnt, error);
d278 1
a278 1
			ktrgenio(p->p_tracep, fd, UIO_READ, ktriov, cnt,
d383 1
a383 1
		ktrgenio(p->p_tracep, fd, UIO_WRITE, &ktriov, cnt, error);
d505 1
a505 1
			ktrgenio(p->p_tracep, fd, UIO_WRITE, ktriov, cnt,
@


1.26
log
@Isn't code sharing great?
poll had the same timeout problem as select.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.25 2000/07/07 13:24:09 art Exp $	*/
d228 1
a228 2
		MALLOC(iov, struct iovec *, iovlen, M_IOV, M_WAITOK);
		needfree = iov;
d264 1
a264 1
		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
d280 1
a280 1
		FREE(ktriov, M_TEMP);
d286 1
a286 1
		FREE(needfree, M_IOV);
d452 1
a452 2
		MALLOC(iov, struct iovec *, iovlen, M_IOV, M_WAITOK);
		needfree = iov;
d488 1
a488 1
		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
d507 1
a507 1
		FREE(ktriov, M_TEMP);
d513 1
a513 1
		FREE(needfree, M_IOV);
@


1.25
log
@When select is awakened by a select collission, we need to recalculate
the timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.24 2000/04/20 06:32:00 deraadt Exp $	*/
a991 6
		timo = hzto(&atv);
		/*
		 * Avoid inadvertently sleeping forever.
		 */
		if (timo == 0)
			timo = 1;
d1002 8
a1010 4
	if (timo && timercmp(&time, &atv, >=)) {
		splx(s);
		goto done;
	}
d1035 1
@


1.24
log
@p{read,write}{,v} from csapuntz, partial NetBSD origin I think
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.23 2000/04/19 08:34:54 csapuntz Exp $	*/
a736 6
		timo = hzto(&atv);
		/*
		 * Avoid inadvertently sleeping forever.
		 */
		if (timo == 0)
			timo = 1;
d746 8
a754 6
	/* this should be timercmp(&time, &atv, >=) */
	if (SCARG(uap, tv) && (time.tv_sec > atv.tv_sec ||
	    (time.tv_sec == atv.tv_sec && time.tv_usec >= atv.tv_usec))) {
		splx(s);
		goto done;
	}
@


1.23
log
@

Change struct file interface methods read and write to pass file offset in
and out.

Make pread/pwrite in netbsd & linux thread safe - which is the whole point
anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.22 1999/11/29 22:02:14 deraadt Exp $	*/
d80 1
a80 1
	register struct sys_read_args /* {
d85 30
a114 2
	register struct file *fp;
	register struct filedesc *fdp = p->p_fd;
d122 2
a123 9
	if (((u_int)SCARG(uap, fd)) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL ||
	    (fp->f_flag & FREAD) == 0)
		return (EBADF);
	/* Don't allow nbyte to be larger than max return val */
	if (SCARG(uap, nbyte) > SSIZE_MAX)
		return(EINVAL);
	aiov.iov_base = (caddr_t)SCARG(uap, buf);
	aiov.iov_len = SCARG(uap, nbyte);
d126 1
a126 1
	auio.uio_resid = SCARG(uap, nbyte);
d130 11
d148 2
a149 2
	cnt = SCARG(uap, nbyte);
	error = (*fp->f_ops->fo_read)(fp, &fp->f_offset, &auio, fp->f_cred);
d157 1
a157 2
		ktrgenio(p->p_tracep, SCARG(uap, fd), UIO_READ, &ktriov,
		    cnt, error);
d160 4
d176 1
a176 1
	register struct sys_readv_args /* {
d178 1
a178 1
		syscallarg(struct iovec *) iovp;
d181 30
a210 2
	register struct file *fp;
	register struct filedesc *fdp = p->p_fd;
d212 1
a212 1
	register struct iovec *iov;
a220 6
	if (((u_int)SCARG(uap, fd)) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL ||
	    (fp->f_flag & FREAD) == 0)
		return (EBADF);
	if (SCARG(uap, iovcnt) <= 0)
		return (EINVAL);
d222 6
a227 4
	iovlen = SCARG(uap, iovcnt) * sizeof (struct iovec);
	if (SCARG(uap, iovcnt) > UIO_SMALLIOV) {
		if (SCARG(uap, iovcnt) > IOV_MAX)
			return (EINVAL);
d230 1
a230 1
	} else {
d233 3
d237 1
d239 1
a239 1
	auio.uio_iovcnt = SCARG(uap, iovcnt);
d243 1
a243 1
	error = copyin((caddr_t)SCARG(uap, iovp), (caddr_t)iov, iovlen);
d247 8
a254 4
	for (i = 0; i < SCARG(uap, iovcnt); i++, iov++) {
		/* Don't allow sum > SSIZE_MAX */
		if (iov->iov_len > SSIZE_MAX ||
		    (auio.uio_resid += iov->iov_len) > SSIZE_MAX) {
d258 1
d270 1
a270 1
	error = (*fp->f_ops->fo_read)(fp, &fp->f_offset, &auio, fp->f_cred);
d278 3
a280 3
		if (error == 0)
			ktrgenio(p->p_tracep, SCARG(uap, fd), UIO_READ, ktriov,
			    cnt, error);
d285 1
a285 1
done:
d288 4
d304 1
a304 1
	register struct sys_write_args /* {
d306 1
a306 1
		syscallarg(void *) buf;
d309 30
a338 2
	register struct file *fp;
	register struct filedesc *fdp = p->p_fd;
d346 2
a347 9
	if (((u_int)SCARG(uap, fd)) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL ||
	    (fp->f_flag & FWRITE) == 0)
		return (EBADF);
	/* Don't allow nbyte to be larger than max return val */
	if (SCARG(uap, nbyte) > SSIZE_MAX)
		return(EINVAL);
	aiov.iov_base = (caddr_t)SCARG(uap, buf);
	aiov.iov_len = SCARG(uap, nbyte);
d350 1
a350 1
	auio.uio_resid = SCARG(uap, nbyte);
d354 11
d372 2
a373 2
	cnt = SCARG(uap, nbyte);
	error = (*fp->f_ops->fo_write)(fp, &fp->f_offset, &auio, fp->f_cred);
d384 1
a384 2
		ktrgenio(p->p_tracep, SCARG(uap, fd), UIO_WRITE,
		    &ktriov, cnt, error);
d387 4
d403 1
a403 1
	register struct sys_writev_args /* {
d405 1
a405 1
		syscallarg(struct iovec *) iovp;
d408 30
a437 2
	register struct file *fp;
	register struct filedesc *fdp = p->p_fd;
d439 1
a439 1
	register struct iovec *iov;
a447 6
	if (((u_int)SCARG(uap, fd)) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL ||
	    (fp->f_flag & FWRITE) == 0)
		return (EBADF);
	if (SCARG(uap, iovcnt) <= 0)
		return (EINVAL);
d449 3
a451 3
	iovlen = SCARG(uap, iovcnt) * sizeof (struct iovec);
	if (SCARG(uap, iovcnt) > UIO_SMALLIOV) {
		if (SCARG(uap, iovcnt) > IOV_MAX)
d455 1
a455 1
	} else {
d458 3
d462 1
d464 1
a464 1
	auio.uio_iovcnt = SCARG(uap, iovcnt);
d468 1
a468 1
	error = copyin((caddr_t)SCARG(uap, iovp), (caddr_t)iov, iovlen);
d472 8
a479 4
	for (i = 0; i < SCARG(uap, iovcnt); i++, iov++) {
		/* Don't allow sum > SSIZE_MAX */
		if (iov->iov_len > SSIZE_MAX ||
		    (auio.uio_resid += iov->iov_len) > SSIZE_MAX) {
d483 1
d495 1
a495 1
	error = (*fp->f_ops->fo_write)(fp, &fp->f_offset, &auio, fp->f_cred);
d506 3
a508 3
		if (error == 0)
			ktrgenio(p->p_tracep, SCARG(uap, fd), UIO_WRITE,
				ktriov, cnt, error);
d513 1
a513 1
done:
d516 4
@


1.22
log
@revents already cleared; d
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.21 1999/11/29 19:56:59 deraadt Exp $	*/
d117 1
a117 1
	error = (*fp->f_ops->fo_read)(fp, &auio, fp->f_cred);
d202 1
a202 1
	error = (*fp->f_ops->fo_read)(fp, &auio, fp->f_cred);
d269 1
a269 1
	error = (*fp->f_ops->fo_write)(fp, &auio, fp->f_cred);
d357 1
a357 1
	error = (*fp->f_ops->fo_write)(fp, &auio, fp->f_cred);
@


1.22.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.28 2000/11/10 18:15:47 art Exp $	*/
d80 1
a80 1
	struct sys_read_args /* {
d85 2
a86 30
	int fd = SCARG(uap, fd);
	struct file *fp;
	struct filedesc *fdp = p->p_fd;

	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
	    (fp->f_flag & FREAD) == 0)
		return (EBADF);

#if notyet
	FILE_USE(fp);
#endif
	/* dofileread() will unuse the descriptor for us */
	return (dofileread(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &fp->f_offset, retval));
}

int
dofileread(p, fd, fp, buf, nbyte, offset, retval)
	struct proc *p;
	int fd;
	struct file *fp;
	void *buf;
	size_t nbyte;
	off_t *offset;
	register_t *retval;
{
d94 9
a102 2
	aiov.iov_base = (caddr_t)buf;
	aiov.iov_len = nbyte;
d105 1
a105 1
	auio.uio_resid = nbyte;
a108 11

	/*
	 * Reads return ssize_t because -1 is returned on error.  Therefore
	 * we must restrict the length to SSIZE_MAX to avoid garbage return
	 * values.
	 */
	if (auio.uio_resid > SSIZE_MAX) {
		error = EINVAL;
		goto out;
	}

d116 2
a117 2
	cnt = auio.uio_resid;
	error = (*fp->f_ops->fo_read)(fp, offset, &auio, fp->f_cred);
d125 2
a126 1
		ktrgenio(p, fd, UIO_READ, &ktriov, cnt, error);
a128 4
 out:
#if notyet
	FILE_UNUSE(fp, p);
#endif
d141 1
a141 1
	struct sys_readv_args /* {
d143 1
a143 1
		syscallarg(const struct iovec *) iovp;
d146 2
a147 30
	int fd = SCARG(uap, fd);
	struct file *fp;
	struct filedesc *fdp = p->p_fd;

	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
	    (fp->f_flag & FREAD) == 0)
		return (EBADF);

#if notyet
	FILE_USE(fp);
#endif
	/* dofilereadv() will unuse the descriptor for us */
	return (dofilereadv(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
	    &fp->f_offset, retval));
}

int
dofilereadv(p, fd, fp, iovp, iovcnt, offset, retval)
	struct proc *p;
	int fd;
	struct file *fp;
	const struct iovec *iovp;
	int iovcnt;
	off_t *offset;
	register_t *retval;
{
d149 1
a149 1
	struct iovec *iov;
d158 6
d165 7
a171 8
	iovlen = iovcnt * sizeof(struct iovec);
	if ((u_int)iovcnt > UIO_SMALLIOV) {
		if ((u_int)iovcnt > IOV_MAX) {
			error = EINVAL;
			goto out;
		}
		iov = needfree = malloc(iovlen, M_IOV, M_WAITOK);
	} else if ((u_int)iovcnt > 0) {
a173 3
	} else {
		error = EINVAL;
		goto out;
a174 1

d176 1
a176 1
	auio.uio_iovcnt = iovcnt;
d180 1
a180 1
	error = copyin(iovp, iov, iovlen);
d184 4
a187 8
	for (i = 0; i < iovcnt; i++) {
		auio.uio_resid += iov->iov_len;
		/*
		 * Reads return ssize_t because -1 is returned on error.
		 * Therefore we must restrict the length to SSIZE_MAX to
		 * avoid garbage return values.
		 */
		if (iov->iov_len > SSIZE_MAX || auio.uio_resid > SSIZE_MAX) {
a190 1
		iov++;
d197 1
a197 1
		ktriov = malloc(iovlen, M_TEMP, M_WAITOK);
d202 1
a202 1
	error = (*fp->f_ops->fo_read)(fp, offset, &auio, fp->f_cred);
d210 4
a213 4
		if (error == 0) 
			ktrgenio(p, fd, UIO_READ, ktriov, cnt,
			    error);
		free(ktriov, M_TEMP);
d217 1
a217 1
 done:
d219 1
a219 5
		free(needfree, M_IOV);
 out:
#if notyet
	FILE_UNUSE(fp, p);
#endif
d232 1
a232 1
	struct sys_write_args /* {
d234 1
a234 1
		syscallarg(const void *) buf;
d237 2
a238 30
	int fd = SCARG(uap, fd);
	struct file *fp;
	struct filedesc *fdp = p->p_fd;

	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
	    (fp->f_flag & FWRITE) == 0)
		return (EBADF);

#if notyet
	FILE_USE(fp);
#endif
	/* dofilewrite() will unuse the descriptor for us */
	return (dofilewrite(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &fp->f_offset, retval));
}

int
dofilewrite(p, fd, fp, buf, nbyte, offset, retval)
	struct proc *p;
	int fd;
	struct file *fp;
	const void *buf;
	size_t nbyte;
	off_t *offset;
	register_t *retval;
{
d246 9
a254 2
	aiov.iov_base = (caddr_t)buf;		/* XXX kills const */
	aiov.iov_len = nbyte;
d257 1
a257 1
	auio.uio_resid = nbyte;
a260 11

	/*
	 * Writes return ssize_t because -1 is returned on error.  Therefore
	 * we must restrict the length to SSIZE_MAX to avoid garbage return
	 * values.
	 */
	if (auio.uio_resid > SSIZE_MAX) {
		error = EINVAL;
		goto out;
	}

d268 2
a269 2
	cnt = auio.uio_resid;
	error = (*fp->f_ops->fo_write)(fp, offset, &auio, fp->f_cred);
d280 2
a281 1
		ktrgenio(p, fd, UIO_WRITE, &ktriov, cnt, error);
a283 4
 out:
#if notyet
	FILE_UNUSE(fp, p);
#endif
d296 1
a296 1
	struct sys_writev_args /* {
d298 1
a298 1
		syscallarg(const struct iovec *) iovp;
d301 2
a302 30
	int fd = SCARG(uap, fd);
	struct file *fp;
	struct filedesc *fdp = p->p_fd;

	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
	    (fp->f_flag & FWRITE) == 0)
		return (EBADF);

#if notyet
	FILE_USE(fp);
#endif
	/* dofilewritev() will unuse the descriptor for us */
	return (dofilewritev(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
	    &fp->f_offset, retval));
}

int
dofilewritev(p, fd, fp, iovp, iovcnt, offset, retval)
	struct proc *p;
	int fd;
	struct file *fp;
	const struct iovec *iovp;
	int iovcnt;
	off_t *offset;
	register_t *retval;
{
d304 1
a304 1
	struct iovec *iov;
d313 6
d320 3
a322 3
	iovlen = iovcnt * sizeof(struct iovec);
	if ((u_int)iovcnt > UIO_SMALLIOV) {
		if ((u_int)iovcnt > IOV_MAX)
d324 3
a326 2
		iov = needfree = malloc(iovlen, M_IOV, M_WAITOK);
	} else if ((u_int)iovcnt > 0) {
a328 3
	} else {
		error = EINVAL;
		goto out;
a329 1

d331 1
a331 1
	auio.uio_iovcnt = iovcnt;
d335 1
a335 1
	error = copyin(iovp, iov, iovlen);
d339 4
a342 8
	for (i = 0; i < iovcnt; i++) {
		auio.uio_resid += iov->iov_len;
		/*
		 * Writes return ssize_t because -1 is returned on error.
		 * Therefore we must restrict the length to SSIZE_MAX to
		 * avoid garbage return values.
		 */
		if (iov->iov_len > SSIZE_MAX || auio.uio_resid > SSIZE_MAX) {
a345 1
		iov++;
d352 1
a352 1
		ktriov = malloc(iovlen, M_TEMP, M_WAITOK);
d357 1
a357 1
	error = (*fp->f_ops->fo_write)(fp, offset, &auio, fp->f_cred);
d368 4
a371 4
		if (error == 0) 
			ktrgenio(p, fd, UIO_WRITE, ktriov, cnt,
			    error);
		free(ktriov, M_TEMP);
d375 1
a375 1
 done:
d377 1
a377 5
		free(needfree, M_IOV);
 out:
#if notyet
	FILE_UNUSE(fp, p);
#endif
d595 6
d610 6
a615 7
	if (SCARG(uap, tv)) {
		/*
		 * We have to recalculate the timeout on every retry.
		 */
		timo = hzto(&atv);
		if (timo <= 0)
			goto done;
a616 1
	s = splhigh();
d854 6
d870 4
a873 7
	if (msec != -1) {
		/*
		 * We have to recalculate the timeout on every retry.
		 */
		timo = hzto(&atv);
		if (timo <= 0)
			goto done;
a874 1
	s = splhigh();
a898 1

@


1.22.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.22.2.1 2001/05/14 22:32:43 niklas Exp $	*/
d694 4
a697 1
		mbits = malloc(ni * 6, M_TEMP, M_WAITOK);
d782 1
@


1.22.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.22.2.2 2001/07/04 10:48:33 niklas Exp $	*/
d89 6
a94 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FREAD) == 0)
d97 3
d185 6
a190 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FREAD) == 0)
d193 3
d312 6
a317 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FWRITE) == 0)
d320 3
d411 6
a416 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FWRITE) == 0)
d419 3
d547 2
a548 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
@


1.22.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a891 3
			continue;
		} else if (pl[i].fd < 0) {
			pl[i].revents = 0;
@


1.22.2.5
log
@Merge in trunk
@
text
@d94 1
a94 3
	FREF(fp);

	/* dofileread() will FRELE the descriptor for us */
d155 3
a157 1
	FRELE(fp);
d184 1
a184 3
	FREF(fp);

	/* dofilereadv() will FRELE the descriptor for us */
d276 3
a278 1
	FRELE(fp);
d305 1
a305 3
	FREF(fp);

	/* dofilewrite() will FRELE the descriptor for us */
d369 3
a371 1
	FRELE(fp);
d398 1
a398 3
	FREF(fp);

	/* dofilewritev() will FRELE the descriptor for us */
d491 3
a493 1
	FRELE(fp);
d507 1
a507 1
	struct sys_ioctl_args /* {
d512 5
a516 5
	struct file *fp;
	struct filedesc *fdp;
	u_long com;
	int error;
	u_int size;
a544 1
	FREF(fp);
d555 3
a557 1
				goto out;
a632 2
out:
	FRELE(fp);
d790 2
a791 1
				if ((fp = fd_getfile(fdp, fd)) == NULL)
a792 1
				FREF(fp);
a796 1
				FRELE(fp);
d887 7
a893 1
		if (pl[i].fd < 0) {
d897 3
a899 1
		if ((fp = fd_getfile(fdp, pl[i].fd)) == NULL) {
a903 1
		FREF(fp);
a912 1
		FRELE(fp);
@


1.22.2.6
log
@Merge in -current from about a week ago
@
text
@d66 3
a68 5
#include <uvm/uvm_extern.h>

int selscan(struct proc *, fd_set *, fd_set *, int, register_t *);
int seltrue(dev_t, int, struct proc *);
void pollscan(struct proc *, struct pollfd *, int, register_t *);
@


1.22.2.7
log
@Sync the SMP branch with 3.3
@
text
@d430 2
a431 4
		if ((u_int)iovcnt > IOV_MAX) {
			error = EINVAL;
			goto out;
		}
d647 4
a650 1
sys_select(struct proc *p, void *v, register_t *retval)
d652 1
a652 1
	struct sys_select_args /* {
d662 1
a662 1
	u_int nd, ni;
d664 1
a664 2
	nd = SCARG(uap, nd);
	if (nd > p->p_fd->fd_nfiles) {
d666 1
a666 1
		nd = p->p_fd->fd_nfiles;
d668 2
a669 2
	ni = howmany(nd, NFDBITS) * sizeof(fd_mask);
	if (nd > FD_SETSIZE) {
d716 1
a716 1
	error = selscan(p, pibits[0], pobits[0], nd, retval);
d922 4
a925 1
sys_poll(struct proc *p, void *v, register_t *retval)
a933 1
	u_int nfds = SCARG(uap, nfds);
d936 2
a937 1
	if (nfds > min((int)p->p_rlimit[RLIMIT_NOFILE].rlim_cur, maxfiles))
d940 1
a940 1
	sz = sizeof(struct pollfd) * nfds;
d949 1
a949 1
	for (i = 0; i < nfds; i++)
d969 1
a969 1
	pollscan(p, pl, nfds, retval);
@


1.22.2.8
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.22.2.7 2003/03/28 00:41:27 niklas Exp $	*/
d860 1
a860 1
		SCHED_LOCK(s);
d868 1
a868 1
		SCHED_UNLOCK(s);
@


1.22.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.22.2.8 2003/05/15 04:08:02 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.22.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 1
a66 1
void pollscan(struct proc *, struct pollfd *, u_int, register_t *);
d116 1
a116 1
	aiov.iov_base = buf;
d253 1
a253 1
		bcopy(auio.uio_iov, ktriov, iovlen);
d327 1
a327 1
	aiov.iov_base = (void *)buf;		/* XXX kills const */
d467 1
a467 1
		bcopy(auio.uio_iov, ktriov, iovlen);
d510 1
a510 1
		syscallarg(void *) data;
d677 1
a677 1
		bzero(bits, sizeof(bits));
d687 2
a688 2
	if (SCARG(uap, name) && (error = copyin(SCARG(uap, name), \
	    pibits[x], ni))) \
d696 2
a697 1
		error = copyin(SCARG(uap, tv), &atv, sizeof (atv));
d729 1
a729 1
	error = tsleep(&selwait, PSOCK | PCATCH, "select", timo);
d741 2
a742 2
	if (SCARG(uap, name) && (error2 = copyout(pobits[x], \
	    SCARG(uap, name), ni))) \
d771 1
a771 1
	static const int flag[3] = { POLLIN, POLLOUT, POLLPRI };
d792 1
a792 1
				if ((*fp->f_ops->fo_poll)(fp, flag[msk], p)) {
d806 1
a806 1
seltrue(dev, events, p)
d808 1
a808 1
	int events;
d812 1
a812 1
	return (events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
d851 1
a851 1
		wakeup(&selwait);
d872 1
a872 1
	u_int nfd;
d875 2
a876 1
	struct filedesc *fdp = p->p_fd;
d878 3
a880 2
	u_int i;
	int n = 0;
d882 4
a885 1
	for (i = 0; i < nfd; i++, pl++) {
d887 2
a888 2
		if (pl->fd < 0) {
			pl->revents = 0;
d891 2
a892 2
		if ((fp = fd_getfile(fdp, pl->fd)) == NULL) {
			pl->revents = POLLNVAL;
d897 9
a905 1
		pl->revents = (*fp->f_ops->fo_poll)(fp, pl->events, p);
d907 1
a907 1
		if (pl->revents != 0)
d920 1
a920 5
	struct sys_poll_args /* {
		syscallarg(struct pollfd *) fds;
		syscallarg(u_int) nfds;
		syscallarg(int) timeout;
	} */ *uap = v;
d925 1
a925 1
	int timo, ncoll, i, s, error;
d945 1
a945 1
	if (msec != INFTIM) {
d965 1
a965 1
	if (msec != INFTIM) {
d979 1
a979 1
	error = tsleep(&selwait, PSOCK | PCATCH, "poll", timo);
d986 2
a987 6
	/*
	 * NOTE: poll(2) is not restarted after a signal and EWOULDBLOCK is
	 *       ignored (since the whole point is to see what would block).
	 */
	switch (error) {
	case ERESTART:
d989 4
a992 6
		break;
	case EWOULDBLOCK:
	case 0:
		error = copyout(pl, SCARG(uap, fds), sz);
		break;
	}
d995 1
a995 1
		free(pl, M_TEMP);
d998 1
@


1.22.2.11
log
@few fixes to make non-smp compile
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.22.2.10 2004/02/19 10:56:38 niklas Exp $	*/
a57 1
#include <sys/sched.h>
@


1.21
log
@handle invalid file descriptors in poll more carefully; d
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.20 1999/08/04 19:18:13 deraadt Exp $	*/
d780 1
a780 2
		if (pl[i].fd < 0) {
			pl[i].revents = 0;
a781 1
		}
@


1.20
log
@optimize poll() for small nfds, by avoiding malloc
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.19 1999/05/24 17:18:52 deraadt Exp $	*/
d51 1
d779 11
d792 2
a793 4
			if (pl[i].events & POLLNVAL) {
				pl[i].revents |= POLLNVAL;
				n++;
			}
d829 5
a833 3
	/* XXX constrain; This may not match standards */
	if (SCARG(uap, nfds) > p->p_fd->fd_nfiles)
		SCARG(uap, nfds) = p->p_fd->fd_nfiles;
@


1.19
log
@correct return value of poll(); noted by d@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.18 1999/03/22 02:22:15 deraadt Exp $	*/
d813 1
a813 1
	struct pollfd *pl;
d824 3
a826 1
	pl = (struct pollfd *) malloc(sz, M_TEMP, M_WAITOK);
d885 2
a886 1
	free((char *) pl, M_TEMP);
@


1.18
log
@in poll(), constrain nfds better, to avoid kvm starvation; alex
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.17 1999/02/14 21:11:01 millert Exp $	*/
d770 1
a770 1
	int n = 0;
d786 1
a786 1
		for (msk = 0; msk < 3; msk++) {
d791 1
a791 1
					n++;
d795 2
@


1.17
log
@Use IOV_MAX, not the deprecated UIO_MAXIOV
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.15 1998/07/28 22:36:42 millert Exp $	*/
d810 1
a810 1
	size_t sz = sizeof(struct pollfd) * SCARG(uap, nfds);
d817 5
@


1.16
log
@readv/writev with iov_len == 0 is legal (was already ok in uipc_syscalls.c).
Make the check more readable by comparing against SSIZE_MAX instead
of checking for wraparound.  This is safe because SSIZE_MAX * 2 <=
SIZE_T_MAX.  Fixes recno problems in the db routines exposed by a
perl test.
@
text
@d166 1
a166 1
		if (SCARG(uap, iovcnt) > UIO_MAXIOV)
d321 1
a321 1
		if (SCARG(uap, iovcnt) > UIO_MAXIOV)
@


1.15
log
@writev takes an int as param #3; theo
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.14 1998/07/28 19:47:07 millert Exp $	*/
d185 2
a186 1
		if ((ssize_t)(auio.uio_resid += iov->iov_len) <= 0) {
d340 2
a341 1
		if ((ssize_t)(auio.uio_resid += iov->iov_len) <= 0) {
@


1.14
log
@For read, write, send, sendto, recv, recvfrom return EINVAL is size arg > SSIZE_MAX.  For readv, writev, sendmsg, recvmsg return EINVAL if sum of the  over iov_len values overflows an ssize_t.  Based on what XPG 4.2 says (though XPG is not entirely consistent here).  Basically since the return value is ssize_t allowing size > SSIZE_MAX is bad since people who (incorrectly mind you) check the return value for < 0 instead of == -1 will have bad things happen to them.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.13 1998/07/28 00:12:58 millert Exp $	*/
d297 1
a297 1
		syscallarg(u_int) iovcnt;
@


1.13
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.12 1998/02/09 06:29:07 tholo Exp $	*/
d81 2
a82 2
		syscallarg(char *) buf;
		syscallarg(u_int) nbyte;
d97 3
d143 1
a143 1
		syscallarg(u_int) iovcnt;
d183 3
a185 2
	for (i = 0; i < SCARG(uap, iovcnt); i++) {
		if (auio.uio_resid + iov->iov_len < auio.uio_resid) {
a188 3

		auio.uio_resid += iov->iov_len;
		iov++;
d232 2
a233 2
		syscallarg(char *) buf;
		syscallarg(u_int) nbyte;
d248 3
d337 3
a339 2
	for (i = 0; i < SCARG(uap, iovcnt); i++) {
		if (auio.uio_resid + iov->iov_len < auio.uio_resid) {
a342 3

		auio.uio_resid += iov->iov_len;
		iov++;
@


1.12
log
@More missing type changes; pointed out by deraadt@@OpenBSD.org
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.11 1997/11/06 05:58:20 csapuntz Exp $	*/
a104 2
	if (auio.uio_resid < 0)
		return EINVAL;
d158 2
a254 2
	if (auio.uio_resid < 0)
		return EINVAL;
d311 2
@


1.11
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.10 1997/10/06 20:20:01 deraadt Exp $	*/
d530 1
a530 1
		syscallarg(u_int) nd;
@


1.10
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.8 1997/08/31 20:42:21 deraadt Exp $	*/
d181 1
a181 3
#if 0
		/* Cannot happen iov_len is unsigned */
		if (iov->iov_len < 0) {
d185 1
a185 1
#endif
a186 4
		if (auio.uio_resid < 0) {
			error = EINVAL;
			goto done;
		}
d334 1
a334 3
#if 0
		/* Cannot happen iov_len is unsigned */
		if (iov->iov_len < 0) {
d338 1
a338 1
#endif
a339 4
		if (auio.uio_resid < 0) {
			error = EINVAL;
			goto done;
		}
@


1.9
log
@VFS Lite2 Changes
@
text
@d181 3
a183 1
		if (auio.uio_resid + iov->iov_len < auio.uio_resid) {
d187 1
a187 1

d189 4
d340 3
a342 1
		if (auio.uio_resid + iov->iov_len < auio.uio_resid) {
d346 1
a346 1

d348 4
@


1.8
log
@for non-tty TIOCSPGRP/F_SETOWN/FIOSETOWN pgid setting calls, store uid
and euid as well, then deliver them using new csignal() interface
which ensures that pgid setting process is permitted to signal the
pgid process(es). Thanks to newsham@@aloha.net for extensive help and
discussion.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.7 1997/01/27 23:21:13 deraadt Exp $	*/
d181 1
a181 3
#if 0
		/* Cannot happen iov_len is unsigned */
		if (iov->iov_len < 0) {
d185 1
a185 1
#endif
a186 4
		if (auio.uio_resid < 0) {
			error = EINVAL;
			goto done;
		}
d334 1
a334 3
#if 0
		/* Cannot happen iov_len is unsigned */
		if (iov->iov_len < 0) {
d338 1
a338 1
#endif
a339 4
		if (auio.uio_resid < 0) {
			error = EINVAL;
			goto done;
		}
@


1.7
log
@select subsystem si_pid becomes si_selpid, to not conflict against user/kernel siginfo si_pid #define
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.6 1996/10/12 01:15:44 deraadt Exp $	*/
d483 5
a487 1
			((struct socket *)fp->f_data)->so_pgid = tmp;
@


1.6
log
@i added a fair bit to this
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.5 1996/05/18 08:53:09 deraadt Exp $	*/
d723 1
a723 1
	if (sip->si_pid == mypid)
d725 1
a725 1
	if (sip->si_pid && (p = pfind(sip->si_pid)) &&
d729 1
a729 1
		sip->si_pid = mypid;
d742 1
a742 1
	if (sip->si_pid == 0)
d749 2
a750 2
	p = pfind(sip->si_pid);
	sip->si_pid = 0;
@


1.5
log
@poll() as a system call
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.3 1996/04/21 22:27:24 deraadt Exp $	*/
d5 1
@


1.4
log
@if nfds > FD_SETSIZE, allocate room for the bitmasks inside the kernel; also
selscan() now understands that it may possible be passed home-grown fd_set's
larger than FD_SETSIZE.
@
text
@d56 1
d66 1
d761 120
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_generic.c,v 1.2 1996/03/03 17:20:03 niklas Exp $	*/
d541 1
a541 1
	fd_set ibits[3], obits[3];
a545 4
	bzero((caddr_t)ibits, sizeof(ibits));
	bzero((caddr_t)obits, sizeof(obits));
	if (SCARG(uap, nd) > FD_SETSIZE)
		return (EINVAL);
d551 23
d577 1
a577 1
	    (caddr_t)&ibits[x], ni))) \
d607 1
a607 1
	error = selscan(p, ibits, obits, SCARG(uap, nd), retval);
d634 1
a634 1
	if (SCARG(uap, name) && (error2 = copyout((caddr_t)&obits[x], \
d645 4
d659 1
d664 1
a664 1
	int n = 0;
d667 8
d676 3
d680 1
a680 1
			bits = ibits[msk].fds_bits[i/NFDBITS];
d687 1
a687 1
					FD_SET(fd, &obits[msk]);
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: sys_generic.c,v 1.23 1996/02/09 19:00:09 christos Exp $	*/
d495 1
a495 1
			(fp, (int)TIOCSPGRP, (caddr_t)&tmp, p);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: sys_generic.c,v 1.21 1995/10/07 06:28:34 mycroft Exp $	*/
d51 1
d63 3
d70 1
d112 2
a113 1
	if (error = (*fp->f_ops->fo_read)(fp, &auio, fp->f_cred))
d130 1
d173 2
a174 1
	if (error = copyin((caddr_t)SCARG(uap, iovp), (caddr_t)iov, iovlen))
d178 2
d184 1
d202 2
a203 1
	if (error = (*fp->f_ops->fo_read)(fp, &auio, fp->f_cred))
d226 1
d268 2
a269 1
	if (error = (*fp->f_ops->fo_write)(fp, &auio, fp->f_cred)) {
d289 1
d332 2
a333 1
	if (error = copyin((caddr_t)SCARG(uap, iovp), (caddr_t)iov, iovlen))
d337 2
d343 1
d361 2
a362 1
	if (error = (*fp->f_ops->fo_write)(fp, &auio, fp->f_cred)) {
d389 1
d462 1
a462 1
		if (tmp = *(int *)data)
d470 1
a470 1
		if (tmp = *(int *)data)
d528 1
d594 1
a594 1
	    time.tv_sec == atv.tv_sec && time.tv_usec >= atv.tv_usec)) {
d629 1
d663 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
