head	1.141;
access;
symbols
	OPENBSD_6_2:1.141.0.4
	OPENBSD_6_2_BASE:1.141
	OPENBSD_6_1:1.140.0.4
	OPENBSD_6_1_BASE:1.140
	OPENBSD_6_0:1.132.0.2
	OPENBSD_6_0_BASE:1.132
	OPENBSD_5_9:1.128.0.2
	OPENBSD_5_9_BASE:1.128
	OPENBSD_5_8:1.120.0.4
	OPENBSD_5_8_BASE:1.120
	OPENBSD_5_7:1.116.0.2
	OPENBSD_5_7_BASE:1.116
	OPENBSD_5_6:1.112.0.4
	OPENBSD_5_6_BASE:1.112
	OPENBSD_5_5:1.104.0.4
	OPENBSD_5_5_BASE:1.104
	OPENBSD_5_4:1.102.0.2
	OPENBSD_5_4_BASE:1.102
	OPENBSD_5_3:1.99.0.2
	OPENBSD_5_3_BASE:1.99
	OPENBSD_5_2:1.98.0.2
	OPENBSD_5_2_BASE:1.98
	OPENBSD_5_1_BASE:1.88
	OPENBSD_5_1:1.88.0.4
	OPENBSD_5_0:1.88.0.2
	OPENBSD_5_0_BASE:1.88
	OPENBSD_4_9:1.85.0.4
	OPENBSD_4_9_BASE:1.85
	OPENBSD_4_8:1.85.0.2
	OPENBSD_4_8_BASE:1.85
	OPENBSD_4_7:1.82.0.2
	OPENBSD_4_7_BASE:1.82
	OPENBSD_4_6:1.81.0.6
	OPENBSD_4_6_BASE:1.81
	OPENBSD_4_5:1.81.0.2
	OPENBSD_4_5_BASE:1.81
	OPENBSD_4_4:1.79.0.2
	OPENBSD_4_4_BASE:1.79
	OPENBSD_4_3:1.77.0.2
	OPENBSD_4_3_BASE:1.77
	OPENBSD_4_2:1.76.0.2
	OPENBSD_4_2_BASE:1.76
	OPENBSD_4_1:1.75.0.2
	OPENBSD_4_1_BASE:1.75
	OPENBSD_4_0:1.74.0.2
	OPENBSD_4_0_BASE:1.74
	OPENBSD_3_9:1.73.0.2
	OPENBSD_3_9_BASE:1.73
	OPENBSD_3_8:1.70.0.2
	OPENBSD_3_8_BASE:1.70
	OPENBSD_3_7:1.69.0.4
	OPENBSD_3_7_BASE:1.69
	OPENBSD_3_6:1.69.0.2
	OPENBSD_3_6_BASE:1.69
	SMP_SYNC_A:1.68
	SMP_SYNC_B:1.68
	OPENBSD_3_5:1.68.0.2
	OPENBSD_3_5_BASE:1.68
	OPENBSD_3_4:1.65.0.2
	OPENBSD_3_4_BASE:1.65
	UBC_SYNC_A:1.62
	OPENBSD_3_3:1.62.0.2
	OPENBSD_3_3_BASE:1.62
	OPENBSD_3_2:1.59.0.2
	OPENBSD_3_2_BASE:1.59
	OPENBSD_3_1:1.56.0.2
	OPENBSD_3_1_BASE:1.56
	UBC_SYNC_B:1.60
	UBC:1.43.0.2
	UBC_BASE:1.43
	OPENBSD_3_0:1.38.0.2
	OPENBSD_3_0_BASE:1.38
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	SMP:1.18.0.4
	SMP_BASE:1.18
	kame_19991208:1.18
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.15.0.4
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.141
date	2017.07.20.16.47.21;	author mpi;	state Exp;
branches;
next	1.140;
commitid	sjNbUTUXwBH9q8DZ;

1.140
date	2017.02.11.19.51.06;	author guenther;	state Exp;
branches
	1.140.4.1;
next	1.139;
commitid	dp1qF9REvzwtzfTw;

1.139
date	2017.01.24.04.09.59;	author deraadt;	state Exp;
branches;
next	1.138;
commitid	zUYmRLEGzx1xH8Zk;

1.138
date	2017.01.23.23.22.00;	author mpi;	state Exp;
branches;
next	1.137;
commitid	SZjZb8CbIOdxacwf;

1.137
date	2017.01.23.22.34.10;	author deraadt;	state Exp;
branches;
next	1.136;
commitid	99bh3dETE3sAQhkj;

1.136
date	2016.09.24.18.39.17;	author tedu;	state Exp;
branches;
next	1.135;
commitid	GXzKcsQAvRY5ZZxt;

1.135
date	2016.09.15.02.00.16;	author dlg;	state Exp;
branches;
next	1.134;
commitid	RlO92XR575sygHqm;

1.134
date	2016.08.25.00.00.02;	author dlg;	state Exp;
branches;
next	1.133;
commitid	iTfOIfeIXH3Xx3fA;

1.133
date	2016.08.23.23.28.02;	author tedu;	state Exp;
branches;
next	1.132;
commitid	nIfbjtBCGXU5qzrs;

1.132
date	2016.05.29.13.51.53;	author natano;	state Exp;
branches
	1.132.2.1;
next	1.131;
commitid	HySIJoapyPyeYVBn;

1.131
date	2016.05.28.00.11.10;	author tedu;	state Exp;
branches;
next	1.130;
commitid	1242jzVIjcckQh3D;

1.130
date	2016.04.25.20.18.31;	author tedu;	state Exp;
branches;
next	1.129;
commitid	AL2KSeDZVXs2nAYI;

1.129
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.128;
commitid	gAjwyca5TfuoJAhn;

1.128
date	2016.01.06.17.59.30;	author tedu;	state Exp;
branches;
next	1.127;
commitid	vtbNHxTkwTC4OW91;

1.127
date	2015.12.17.16.59.26;	author tedu;	state Exp;
branches;
next	1.126;
commitid	07JQrvp6dj3rkN0y;

1.126
date	2015.12.17.16.49.07;	author tedu;	state Exp;
branches;
next	1.125;
commitid	w7DsIJJXiykbFu6r;

1.125
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.124;
commitid	Cl55DD2g2xm69E6W;

1.124
date	2015.11.01.19.03.33;	author semarie;	state Exp;
branches;
next	1.123;
commitid	VKRkUfXZQNJ8UQeY;

1.123
date	2015.10.28.12.17.20;	author deraadt;	state Exp;
branches;
next	1.122;
commitid	zkbQCjO85aouBbdV;

1.122
date	2015.10.21.16.09.13;	author bluhm;	state Exp;
branches;
next	1.121;
commitid	bk8sSUoDvt17cdPF;

1.121
date	2015.10.16.13.37.43;	author millert;	state Exp;
branches;
next	1.120;
commitid	H99PcNtHGZMrNl2r;

1.120
date	2015.05.17.01.22.01;	author deraadt;	state Exp;
branches;
next	1.119;
commitid	g7n1QS40YlvIgI3S;

1.119
date	2015.04.30.21.18.45;	author millert;	state Exp;
branches;
next	1.118;
commitid	PBh01zO4NZnjp5jl;

1.118
date	2015.04.30.09.20.51;	author mpi;	state Exp;
branches;
next	1.117;
commitid	ngMdImGL4WWFm6gy;

1.117
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.116;
commitid	p4LJxGKbi0BU2cG6;

1.116
date	2015.01.19.01.19.17;	author deraadt;	state Exp;
branches;
next	1.115;
commitid	GZxOWQTfFvMIrIGB;

1.115
date	2014.12.19.05.59.21;	author tedu;	state Exp;
branches;
next	1.114;
commitid	zdJTCwdpqRUwO1SL;

1.114
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.113;
commitid	P6Av4XGqOi3rFasL;

1.113
date	2014.08.31.01.42.36;	author guenther;	state Exp;
branches;
next	1.112;
commitid	zF5A8BuuSSyqaDyM;

1.112
date	2014.07.13.15.29.04;	author tedu;	state Exp;
branches;
next	1.111;
commitid	bFFVdS3JEaMhyZxJ;

1.111
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.110;
commitid	QlVV51SZgNFxsXxC;

1.110
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	EF98ch02VpFassUi;

1.109
date	2014.06.15.20.39.22;	author matthew;	state Exp;
branches;
next	1.108;
commitid	kyWCRChhNHqPmEUV;

1.108
date	2014.05.15.03.52.25;	author guenther;	state Exp;
branches;
next	1.107;

1.107
date	2014.04.12.14.18.11;	author espie;	state Exp;
branches;
next	1.106;

1.106
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.105;

1.105
date	2014.03.08.22.54.29;	author tedu;	state Exp;
branches;
next	1.104;

1.104
date	2013.09.14.01.35.00;	author guenther;	state Exp;
branches;
next	1.103;

1.103
date	2013.08.13.05.52.23;	author guenther;	state Exp;
branches;
next	1.102;

1.102
date	2013.07.04.16.55.19;	author sf;	state Exp;
branches;
next	1.101;

1.101
date	2013.06.11.13.00.31;	author tedu;	state Exp;
branches;
next	1.100;

1.100
date	2013.06.05.01.26.00;	author guenther;	state Exp;
branches;
next	1.99;

1.99
date	2012.08.23.00.11.56;	author guenther;	state Exp;
branches;
next	1.98;

1.98
date	2012.07.11.23.07.19;	author guenther;	state Exp;
branches;
next	1.97;

1.97
date	2012.07.08.10.55.10;	author guenther;	state Exp;
branches;
next	1.96;

1.96
date	2012.05.21.16.41.03;	author matthew;	state Exp;
branches;
next	1.95;

1.95
date	2012.05.14.02.41.13;	author guenther;	state Exp;
branches;
next	1.94;

1.94
date	2012.05.01.03.43.23;	author guenther;	state Exp;
branches;
next	1.93;

1.93
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.92;

1.92
date	2012.04.12.17.42.57;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2012.04.12.11.07.20;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2012.04.12.11.01.37;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2012.02.15.04.26.27;	author guenther;	state Exp;
branches;
next	1.88;

1.88
date	2011.07.08.21.26.27;	author matthew;	state Exp;
branches;
next	1.87;

1.87
date	2011.07.08.19.28.36;	author otto;	state Exp;
branches;
next	1.86;

1.86
date	2011.04.02.17.04.35;	author guenther;	state Exp;
branches;
next	1.85;

1.85
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.84;

1.84
date	2010.07.19.23.00.15;	author guenther;	state Exp;
branches;
next	1.83;

1.83
date	2010.03.24.23.18.17;	author tedu;	state Exp;
branches;
next	1.82;

1.82
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.81;

1.81
date	2008.11.25.18.04.38;	author blambert;	state Exp;
branches;
next	1.80;

1.80
date	2008.09.19.12.24.55;	author art;	state Exp;
branches;
next	1.79;

1.79
date	2008.06.12.18.10.06;	author thib;	state Exp;
branches;
next	1.78;

1.78
date	2008.05.06.20.57.19;	author thib;	state Exp;
branches;
next	1.77;

1.77
date	2007.10.29.14.12.19;	author chl;	state Exp;
branches;
next	1.76;

1.76
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.75;

1.75
date	2006.11.14.18.00.27;	author jmc;	state Exp;
branches;
next	1.74;

1.74
date	2006.05.07.20.12.41;	author tedu;	state Exp;
branches;
next	1.73;

1.73
date	2006.01.06.18.28.33;	author jmc;	state Exp;
branches;
next	1.72;

1.72
date	2005.12.07.19.04.53;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2005.11.28.00.14.28;	author jsg;	state Exp;
branches;
next	1.70;

1.70
date	2005.07.03.01.07.44;	author jaredy;	state Exp;
branches
	1.70.2.1;
next	1.69;

1.69
date	2004.07.22.06.13.08;	author tedu;	state Exp;
branches
	1.69.4.1;
next	1.68;

1.68
date	2004.01.12.18.06.51;	author tedu;	state Exp;
branches;
next	1.67;

1.67
date	2004.01.06.04.18.18;	author tedu;	state Exp;
branches;
next	1.66;

1.66
date	2003.12.02.01.40.18;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2003.08.06.20.37.38;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2002.11.22.13.40.06;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2002.11.08.18.38.00;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2002.10.15.01.27.31;	author nordin;	state Exp;
branches;
next	1.59;

1.59
date	2002.08.23.00.56.04;	author pvalchev;	state Exp;
branches;
next	1.58;

1.58
date	2002.06.03.12.04.08;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.23.14.25.20;	author art;	state Exp;
branches;
next	1.56;

1.56
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2002.02.19.06.12.13;	author nordin;	state Exp;
branches;
next	1.54;

1.54
date	2002.02.18.23.12.04;	author ericj;	state Exp;
branches;
next	1.53;

1.53
date	2002.02.13.19.08.06;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.09.00.27.49;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.08.18.43.54;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.08.18.29.08;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.08.16.32.27;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.08.13.53.28;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2002.02.05.16.02.27;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.04.11.48.22;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.02.17.52.27;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2002.01.23.00.39.47;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.15.13.07.53;	author niklas;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2001.11.05.02.03.58;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2001.10.26.12.03.27;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.10.26.10.39.31;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.10.07.23.12.06;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.10.07.22.42.07;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2001.10.01.16.55.57;	author gluk;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.29.20.10.43;	author gluk;	state Exp;
branches;
next	1.34;

1.34
date	2001.07.28.17.12.12;	author gluk;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.25.16.03.14;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.27.04.49.41;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.22.14.14.08;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.23.14.50.15;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.16.12.49.45;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.14.13.43.53;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.14.13.28.20;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.14.12.11.52;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.14.11.04.04;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.14.10.51.26;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.16.20.02.16;	author provos;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2000.09.27.16.13.46;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.24.19.13.26;	author provos;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.01.23.29.25;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.28.18.04.08;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	99.07.13.15.17.50;	author provos;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	99.02.26.05.10.40;	author art;	state Exp;
branches;
next	1.16;

1.16
date	98.12.04.19.40.55;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.03.01.19.34.12;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.08.31.20.42.15;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.08.21.05.17.37;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.07.25.17.31.38;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.01.25.17.37.34;	author dm;	state Exp;
branches;
next	1.10;

1.10
date	97.01.25.00.27.30;	author dm;	state Exp;
branches;
next	1.9;

1.9
date	96.10.28.00.42.30;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.10.26.07.31.48;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.09.04.22.33.48;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.08.27.14.46.59;	author shawn;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.26.59;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.19.16.08.53;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.17.19.42;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.07.17.38.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches;
next	;

1.18.4.1
date	2000.03.02.07.04.40;	author niklas;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2001.05.14.22.32.40;	author niklas;	state Exp;
branches;
next	1.18.4.3;

1.18.4.3
date	2001.07.04.10.48.15;	author niklas;	state Exp;
branches;
next	1.18.4.4;

1.18.4.4
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.18.4.5;

1.18.4.5
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.18.4.6;

1.18.4.6
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.18.4.7;

1.18.4.7
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.18.4.8;

1.18.4.8
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.18.4.9;

1.18.4.9
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.18.4.10;

1.18.4.10
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.18.4.11;

1.18.4.11
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	;

1.23.2.1
date	2001.05.31.05.08.29;	author jason;	state Exp;
branches;
next	;

1.43.2.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.43.2.3;

1.43.2.3
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.43.2.4;

1.43.2.4
date	2003.05.19.22.31.09;	author tedu;	state Exp;
branches;
next	;

1.69.4.1
date	2005.12.30.01.28.02;	author brad;	state Exp;
branches;
next	;

1.70.2.1
date	2005.12.22.02.41.54;	author brad;	state Exp;
branches;
next	;

1.132.2.1
date	2017.08.02.16.49.44;	author deraadt;	state Exp;
branches;
next	;
commitid	Pqo2AYcc1UhIvGgt;

1.140.4.1
date	2017.08.01.22.25.07;	author bluhm;	state Exp;
branches;
next	;
commitid	9aaMmNLMDnFmtWLn;


desc
@@


1.141
log
@Initialize a local variable to not leak kernel stack info to userland
if TIOCGPGRP fail.

Issue found by Ilja van Sprundel.

ok bluhm@@, millert@@, deraadt@@
@
text
@/*	$OpenBSD: kern_descrip.c,v 1.140 2017/02/11 19:51:06 guenther Exp $	*/
/*	$NetBSD: kern_descrip.c,v 1.42 1996/03/30 22:24:38 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_descrip.c	8.6 (Berkeley) 4/19/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/filedesc.h>
#include <sys/kernel.h>
#include <sys/vnode.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/lock.h>
#include <sys/malloc.h>
#include <sys/syslog.h>
#include <sys/ucred.h>
#include <sys/unistd.h>
#include <sys/resourcevar.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#include <sys/event.h>
#include <sys/pool.h>
#include <sys/ktrace.h>
#include <sys/pledge.h>

#include <sys/pipe.h>

/*
 * Descriptor management.
 */
struct filelist filehead;	/* head of list of open files */
int numfiles;			/* actual number of open files */

static __inline void fd_used(struct filedesc *, int);
static __inline void fd_unused(struct filedesc *, int);
static __inline int find_next_zero(u_int *, int, u_int);
int finishdup(struct proc *, struct file *, int, int, register_t *, int);
int find_last_set(struct filedesc *, int);
int dodup3(struct proc *, int, int, int, register_t *);

struct pool file_pool;
struct pool fdesc_pool;

void
filedesc_init(void)
{
	pool_init(&file_pool, sizeof(struct file), 0, IPL_NONE,
	    PR_WAITOK, "filepl", NULL);
	pool_init(&fdesc_pool, sizeof(struct filedesc0), 0, IPL_NONE,
	    PR_WAITOK, "fdescpl", NULL);
	LIST_INIT(&filehead);
}

static __inline int
find_next_zero (u_int *bitmap, int want, u_int bits)
{
	int i, off, maxoff;
	u_int sub;

	if (want > bits)
		return -1;

	off = want >> NDENTRYSHIFT;
	i = want & NDENTRYMASK;
	if (i) {
		sub = bitmap[off] | ((u_int)~0 >> (NDENTRIES - i));
		if (sub != ~0)
			goto found;
		off++;
	}

	maxoff = NDLOSLOTS(bits);
	while (off < maxoff) {
		if ((sub = bitmap[off]) != ~0)
			goto found;
		off++;
	}

	return -1;

 found:
	return (off << NDENTRYSHIFT) + ffs(~sub) - 1;
}

int
find_last_set(struct filedesc *fd, int last)
{
	int off, i;
	struct file **ofiles = fd->fd_ofiles;
	u_int *bitmap = fd->fd_lomap;

	off = (last - 1) >> NDENTRYSHIFT;

	while (off >= 0 && !bitmap[off])
		off--;
	if (off < 0)
		return 0;

	i = ((off + 1) << NDENTRYSHIFT) - 1;
	if (i >= last)
		i = last - 1;

	while (i > 0 && ofiles[i] == NULL)
		i--;
	return i;
}

static __inline void
fd_used(struct filedesc *fdp, int fd)
{
	u_int off = fd >> NDENTRYSHIFT;

	fdp->fd_lomap[off] |= 1 << (fd & NDENTRYMASK);
	if (fdp->fd_lomap[off] == ~0)
		fdp->fd_himap[off >> NDENTRYSHIFT] |= 1 << (off & NDENTRYMASK);

	if (fd > fdp->fd_lastfile)
		fdp->fd_lastfile = fd;
	fdp->fd_openfd++;
}

static __inline void
fd_unused(struct filedesc *fdp, int fd)
{
	u_int off = fd >> NDENTRYSHIFT;

	if (fd < fdp->fd_freefile)
		fdp->fd_freefile = fd;

	if (fdp->fd_lomap[off] == ~0)
		fdp->fd_himap[off >> NDENTRYSHIFT] &= ~(1 << (off & NDENTRYMASK));
	fdp->fd_lomap[off] &= ~(1 << (fd & NDENTRYMASK));

#ifdef DIAGNOSTIC
	if (fd > fdp->fd_lastfile)
		panic("fd_unused: fd_lastfile inconsistent");
#endif
	if (fd == fdp->fd_lastfile)
		fdp->fd_lastfile = find_last_set(fdp, fd);
	fdp->fd_openfd--;
}

struct file *
fd_getfile(struct filedesc *fdp, int fd)
{
	struct file *fp;

	if ((u_int)fd >= fdp->fd_nfiles || (fp = fdp->fd_ofiles[fd]) == NULL)
		return (NULL);

	if (!FILE_IS_USABLE(fp))
		return (NULL);

	return (fp);
}

struct file *
fd_getfile_mode(struct filedesc *fdp, int fd, int mode)
{
	struct file *fp;

	KASSERT(mode != 0);

	fp = fd_getfile(fdp, fd);

	if (fp == NULL || (fp->f_flag & mode) == 0)
		return (NULL);

	return (fp);
}

/*
 * System calls on descriptors.
 */

/*
 * Duplicate a file descriptor.
 */
int
sys_dup(struct proc *p, void *v, register_t *retval)
{
	struct sys_dup_args /* {
		syscallarg(int) fd;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	int old = SCARG(uap, fd);
	struct file *fp;
	int new;
	int error;

restart:
	if ((fp = fd_getfile(fdp, old)) == NULL)
		return (EBADF);
	FREF(fp);
	fdplock(fdp);
	if ((error = fdalloc(p, 0, &new)) != 0) {
		FRELE(fp, p);
		if (error == ENOSPC) {
			fdexpand(p);
			fdpunlock(fdp);
			goto restart;
		}
		goto out;
	}
	error = finishdup(p, fp, old, new, retval, 0);

out:
	fdpunlock(fdp);
	return (error);
}

/*
 * Duplicate a file descriptor to a particular value.
 */
int
sys_dup2(struct proc *p, void *v, register_t *retval)
{
	struct sys_dup2_args /* {
		syscallarg(int) from;
		syscallarg(int) to;
	} */ *uap = v;

	return (dodup3(p, SCARG(uap, from), SCARG(uap, to), 0, retval));
}

int
sys_dup3(struct proc *p, void *v, register_t *retval)
{
	struct sys_dup3_args /* {
		syscallarg(int) from;
		syscallarg(int) to;
		syscallarg(int) flags;
	} */ *uap = v;

	if (SCARG(uap, from) == SCARG(uap, to))
		return (EINVAL);
	if (SCARG(uap, flags) & ~O_CLOEXEC)
		return (EINVAL);
	return (dodup3(p, SCARG(uap, from), SCARG(uap, to),
	    SCARG(uap, flags), retval));
}

int
dodup3(struct proc *p, int old, int new, int flags, register_t *retval)
{
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	int i, error;

restart:
	if ((fp = fd_getfile(fdp, old)) == NULL)
		return (EBADF);
	if ((u_int)new >= p->p_rlimit[RLIMIT_NOFILE].rlim_cur ||
	    (u_int)new >= maxfiles)
		return (EBADF);
	if (old == new) {
		/*
		 * NOTE! This doesn't clear the close-on-exec flag. This might
		 * or might not be the intended behavior from the start, but
		 * this is what everyone else does.
		 */
		*retval = new;
		return (0);
	}
	FREF(fp);
	fdplock(fdp);
	if (new >= fdp->fd_nfiles) {
		if ((error = fdalloc(p, new, &i)) != 0) {
			FRELE(fp, p);
			if (error == ENOSPC) {
				fdexpand(p);
				fdpunlock(fdp);
				goto restart;
			}
			goto out;
		}
		if (new != i)
			panic("dup2: fdalloc");
		fd_unused(fdp, new);
	}
	/* finishdup() does FRELE */
	error = finishdup(p, fp, old, new, retval, 1);
	if (!error && flags & O_CLOEXEC)
		fdp->fd_ofileflags[new] |= UF_EXCLOSE;

out:
	fdpunlock(fdp);
	return (error);
}

/*
 * The file control system call.
 */
int
sys_fcntl(struct proc *p, void *v, register_t *retval)
{
	struct sys_fcntl_args /* {
		syscallarg(int) fd;
		syscallarg(int) cmd;
		syscallarg(void *) arg;
	} */ *uap = v;
	int fd = SCARG(uap, fd);
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	int i, tmp, newmin, flg = F_POSIX;
	struct flock fl;
	int error = 0;

	error = pledge_fcntl(p, SCARG(uap, cmd));
	if (error)
		return (error);

restart:
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	FREF(fp);
	switch (SCARG(uap, cmd)) {

	case F_DUPFD:
	case F_DUPFD_CLOEXEC:
		newmin = (long)SCARG(uap, arg);
		if ((u_int)newmin >= p->p_rlimit[RLIMIT_NOFILE].rlim_cur ||
		    (u_int)newmin >= maxfiles) {
			error = EINVAL;
			break;
		}
		fdplock(fdp);
		if ((error = fdalloc(p, newmin, &i)) != 0) {
			FRELE(fp, p);
			if (error == ENOSPC) {
				fdexpand(p);
				fdpunlock(fdp);
				goto restart;
			}
		} else {
			/* finishdup will FRELE for us. */
			error = finishdup(p, fp, fd, i, retval, 0);

			if (!error && SCARG(uap, cmd) == F_DUPFD_CLOEXEC)
				fdp->fd_ofileflags[i] |= UF_EXCLOSE;
		}

		fdpunlock(fdp);
		return (error);

	case F_GETFD:
		*retval = fdp->fd_ofileflags[fd] & UF_EXCLOSE ? 1 : 0;
		break;

	case F_SETFD:
		fdplock(fdp);
		if ((long)SCARG(uap, arg) & 1)
			fdp->fd_ofileflags[fd] |= UF_EXCLOSE;
		else
			fdp->fd_ofileflags[fd] &= ~UF_EXCLOSE;
		fdpunlock(fdp);
		break;

	case F_GETFL:
		*retval = OFLAGS(fp->f_flag);
		break;

	case F_ISATTY:
		vp = fp->f_data;
	        if (fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
			*retval = 1;
		else {
			*retval = 0;
			error = ENOTTY;
		}
		break;

	case F_SETFL:
		fp->f_flag &= ~FCNTLFLAGS;
		fp->f_flag |= FFLAGS((long)SCARG(uap, arg)) & FCNTLFLAGS;
		tmp = fp->f_flag & FNONBLOCK;
		error = (*fp->f_ops->fo_ioctl)(fp, FIONBIO, (caddr_t)&tmp, p);
		if (error)
			break;
		tmp = fp->f_flag & FASYNC;
		error = (*fp->f_ops->fo_ioctl)(fp, FIOASYNC, (caddr_t)&tmp, p);
		if (!error)
			break;
		fp->f_flag &= ~FNONBLOCK;
		tmp = 0;
		(void) (*fp->f_ops->fo_ioctl)(fp, FIONBIO, (caddr_t)&tmp, p);
		break;

	case F_GETOWN:
		if (fp->f_type == DTYPE_SOCKET) {
			*retval = ((struct socket *)fp->f_data)->so_pgid;
			break;
		}
		if (fp->f_type == DTYPE_PIPE) {
			*retval = ((struct pipe *)fp->f_data)->pipe_pgid;
			break;
		}
		tmp = 0;
		error = (*fp->f_ops->fo_ioctl)
			(fp, TIOCGPGRP, (caddr_t)&tmp, p);
		*retval = -tmp;
		break;

	case F_SETOWN:
		if (fp->f_type == DTYPE_SOCKET) {
			struct socket *so = fp->f_data;

			so->so_pgid = (long)SCARG(uap, arg);
			so->so_siguid = p->p_ucred->cr_ruid;
			so->so_sigeuid = p->p_ucred->cr_uid;
			break;
		}
		if (fp->f_type == DTYPE_PIPE) {
			struct pipe *mpipe = fp->f_data;

			mpipe->pipe_pgid = (long)SCARG(uap, arg);
			break;
		}
		if ((long)SCARG(uap, arg) <= 0) {
			SCARG(uap, arg) = (void *)(-(long)SCARG(uap, arg));
		} else {
			struct process *pr1 = prfind((long)SCARG(uap, arg));
			if (pr1 == 0) {
				error = ESRCH;
				break;
			}
			SCARG(uap, arg) = (void *)(long)pr1->ps_pgrp->pg_id;
		}
		error = ((*fp->f_ops->fo_ioctl)
			(fp, TIOCSPGRP, (caddr_t)&SCARG(uap, arg), p));
		break;

	case F_SETLKW:
		flg |= F_WAIT;
		/* FALLTHROUGH */

	case F_SETLK:
		error = pledge_flock(p);
		if (error != 0)
			break;

		if (fp->f_type != DTYPE_VNODE) {
			error = EBADF;
			break;
		}
		vp = fp->f_data;
		/* Copy in the lock structure */
		error = copyin((caddr_t)SCARG(uap, arg), (caddr_t)&fl,
		    sizeof (fl));
		if (error)
			break;
		if (fl.l_whence == SEEK_CUR) {
			if (fl.l_start == 0 && fl.l_len < 0) {
				/* lockf(3) compliance hack */
				fl.l_len = -fl.l_len;
				fl.l_start = fp->f_offset - fl.l_len;
			} else
				fl.l_start += fp->f_offset;
		}
		switch (fl.l_type) {

		case F_RDLCK:
			if ((fp->f_flag & FREAD) == 0) {
				error = EBADF;
				goto out;
			}
			atomic_setbits_int(&fdp->fd_flags, FD_ADVLOCK);
			error = VOP_ADVLOCK(vp, fdp, F_SETLK, &fl, flg);
			break;

		case F_WRLCK:
			if ((fp->f_flag & FWRITE) == 0) {
				error = EBADF;
				goto out;
			}
			atomic_setbits_int(&fdp->fd_flags, FD_ADVLOCK);
			error = VOP_ADVLOCK(vp, fdp, F_SETLK, &fl, flg);
			break;

		case F_UNLCK:
			error = VOP_ADVLOCK(vp, fdp, F_UNLCK, &fl, F_POSIX);
			goto out;

		default:
			error = EINVAL;
			goto out;
		}

		if (fp != fd_getfile(fdp, fd)) {
			/*
			 * We have lost the race with close() or dup2();
			 * unlock, pretend that we've won the race and that
			 * lock had been removed by close()
			 */
			fl.l_whence = SEEK_SET;
			fl.l_start = 0;
			fl.l_len = 0;
			VOP_ADVLOCK(vp, fdp, F_UNLCK, &fl, F_POSIX);
			fl.l_type = F_UNLCK;
		}
		goto out;


	case F_GETLK:
		error = pledge_flock(p);
		if (error != 0)
			break;

		if (fp->f_type != DTYPE_VNODE) {
			error = EBADF;
			break;
		}
		vp = fp->f_data;
		/* Copy in the lock structure */
		error = copyin((caddr_t)SCARG(uap, arg), (caddr_t)&fl,
		    sizeof (fl));
		if (error)
			break;
		if (fl.l_whence == SEEK_CUR) {
			if (fl.l_start == 0 && fl.l_len < 0) {
				/* lockf(3) compliance hack */
				fl.l_len = -fl.l_len;
				fl.l_start = fp->f_offset - fl.l_len;
			} else
				fl.l_start += fp->f_offset;
		}
		if (fl.l_type != F_RDLCK &&
		    fl.l_type != F_WRLCK &&
		    fl.l_type != F_UNLCK &&
		    fl.l_type != 0) {
			error = EINVAL;
			break;
		}
		error = VOP_ADVLOCK(vp, fdp, F_GETLK, &fl, F_POSIX);
		if (error)
			break;
		error = (copyout((caddr_t)&fl, (caddr_t)SCARG(uap, arg),
		    sizeof (fl)));
		break;

	default:
		error = EINVAL;
		break;
	}
out:
	FRELE(fp, p);
	return (error);	
}

/*
 * Common code for dup, dup2, and fcntl(F_DUPFD).
 */
int
finishdup(struct proc *p, struct file *fp, int old, int new,
    register_t *retval, int dup2)
{
	struct file *oldfp;
	struct filedesc *fdp = p->p_fd;

	fdpassertlocked(fdp);
	if (fp->f_count == LONG_MAX-2) {
		FRELE(fp, p);
		return (EDEADLK);
	}

	/*
	 * Don't fd_getfile here. We want to closef LARVAL files and
	 * closef can deal with that.
	 */
	oldfp = fdp->fd_ofiles[new];
	if (oldfp != NULL)
		FREF(oldfp);

	fdp->fd_ofiles[new] = fp;
	fdp->fd_ofileflags[new] = fdp->fd_ofileflags[old] & ~(UF_EXCLOSE|UF_PLEDGED);
	fp->f_count++;
	FRELE(fp, p);
	if (dup2 && oldfp == NULL)
		fd_used(fdp, new);
	*retval = new;

	if (oldfp != NULL) {
		if (new < fdp->fd_knlistsize)
			knote_fdclose(p, new);
		closef(oldfp, p);
	}

	return (0);
}

void
fdremove(struct filedesc *fdp, int fd)
{
	fdpassertlocked(fdp);
	fdp->fd_ofiles[fd] = NULL;
	fdp->fd_ofileflags[fd] = 0;
	fd_unused(fdp, fd);
}

int
fdrelease(struct proc *p, int fd)
{
	struct filedesc *fdp = p->p_fd;
	struct file **fpp, *fp;

	fdpassertlocked(fdp);

	/*
	 * Don't fd_getfile here. We want to closef LARVAL files and closef
	 * can deal with that.
	 */
	fpp = &fdp->fd_ofiles[fd];
	fp = *fpp;
	if (fp == NULL)
		return (EBADF);
	FREF(fp);
	*fpp = NULL;
	fd_unused(fdp, fd);
	if (fd < fdp->fd_knlistsize)
		knote_fdclose(p, fd);
	return (closef(fp, p));
}

/*
 * Close a file descriptor.
 */
int
sys_close(struct proc *p, void *v, register_t *retval)
{
	struct sys_close_args /* {
		syscallarg(int) fd;
	} */ *uap = v;
	int fd = SCARG(uap, fd), error;
	struct filedesc *fdp = p->p_fd;

	if (fd_getfile(fdp, fd) == NULL)
		return (EBADF);
	fdplock(fdp);
	error = fdrelease(p, fd);
	fdpunlock(fdp);

	return (error);
}

/*
 * Return status information about a file descriptor.
 */
int
sys_fstat(struct proc *p, void *v, register_t *retval)
{
	struct sys_fstat_args /* {
		syscallarg(int) fd;
		syscallarg(struct stat *) sb;
	} */ *uap = v;
	int fd = SCARG(uap, fd);
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct stat ub;
	int error;

	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	FREF(fp);
	error = (*fp->f_ops->fo_stat)(fp, &ub, p);
	FRELE(fp, p);
	if (error == 0) {
		/* 
		 * Don't let non-root see generation numbers
		 * (for NFS security)
		 */
		if (suser(p, 0))
			ub.st_gen = 0;
		error = copyout((caddr_t)&ub, (caddr_t)SCARG(uap, sb),
		    sizeof (ub));
	}
#ifdef KTRACE
	if (error == 0 && KTRPOINT(p, KTR_STRUCT))
		ktrstat(p, &ub);
#endif
	return (error);
}

/*
 * Return pathconf information about a file descriptor.
 */
int
sys_fpathconf(struct proc *p, void *v, register_t *retval)
{
	struct sys_fpathconf_args /* {
		syscallarg(int) fd;
		syscallarg(int) name;
	} */ *uap = v;
	int fd = SCARG(uap, fd);
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	int error;

	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	FREF(fp);
	switch (fp->f_type) {
	case DTYPE_PIPE:
	case DTYPE_SOCKET:
		if (SCARG(uap, name) != _PC_PIPE_BUF) {
			error = EINVAL;
			break;
		}
		*retval = PIPE_BUF;
		error = 0;
		break;

	case DTYPE_VNODE:
		vp = fp->f_data;
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
		error = VOP_PATHCONF(vp, SCARG(uap, name), retval);
		VOP_UNLOCK(vp, p);
		break;

	default:
		error = EOPNOTSUPP;
		break;
	}
	FRELE(fp, p);
	return (error);
}

/*
 * Allocate a file descriptor for the process.
 */
int
fdalloc(struct proc *p, int want, int *result)
{
	struct filedesc *fdp = p->p_fd;
	int lim, last, i;
	u_int new, off;

	/*
	 * Search for a free descriptor starting at the higher
	 * of want or fd_freefile.  If that fails, consider
	 * expanding the ofile array.
	 */
restart:
	lim = min((int)p->p_rlimit[RLIMIT_NOFILE].rlim_cur, maxfiles);
	last = min(fdp->fd_nfiles, lim);
	if ((i = want) < fdp->fd_freefile)
		i = fdp->fd_freefile;
	off = i >> NDENTRYSHIFT;
	new = find_next_zero(fdp->fd_himap, off,
	    (last + NDENTRIES - 1) >> NDENTRYSHIFT);
	if (new != -1) {
		i = find_next_zero(&fdp->fd_lomap[new], 
				   new > off ? 0 : i & NDENTRYMASK,
				   NDENTRIES);
		if (i == -1) {
			/*
			 * Free file descriptor in this block was
			 * below want, try again with higher want.
			 */
			want = (new + 1) << NDENTRYSHIFT;
			goto restart;
		}
		i += (new << NDENTRYSHIFT);
		if (i < last) {
			fd_used(fdp, i);
			if (want <= fdp->fd_freefile)
				fdp->fd_freefile = i;
			*result = i;
			fdp->fd_ofileflags[i] = 0;
			if (ISSET(p->p_p->ps_flags, PS_PLEDGE))
				fdp->fd_ofileflags[i] |= UF_PLEDGED;
			return (0);
		}
	}
	if (fdp->fd_nfiles >= lim)
		return (EMFILE);

	return (ENOSPC);
}

void
fdexpand(struct proc *p)
{
	struct filedesc *fdp = p->p_fd;
	int nfiles;
	size_t copylen;
	struct file **newofile;
	char *newofileflags;
	u_int *newhimap, *newlomap;

	fdpassertlocked(fdp);

	/*
	 * No space in current array.
	 */
	if (fdp->fd_nfiles < NDEXTENT)
		nfiles = NDEXTENT;
	else
		nfiles = 2 * fdp->fd_nfiles;

	newofile = mallocarray(nfiles, OFILESIZE, M_FILEDESC, M_WAITOK);
	/*
	 * Allocate all required chunks before calling free(9) to make
	 * sure that ``fd_ofiles'' stays valid if we go to sleep.
	 */
	if (NDHISLOTS(nfiles) > NDHISLOTS(fdp->fd_nfiles)) {
		newhimap = mallocarray(NDHISLOTS(nfiles), sizeof(u_int),
		    M_FILEDESC, M_WAITOK);
		newlomap = mallocarray(NDLOSLOTS(nfiles), sizeof(u_int),
		    M_FILEDESC, M_WAITOK);
	}
	newofileflags = (char *) &newofile[nfiles];

	/*
	 * Copy the existing ofile and ofileflags arrays
	 * and zero the new portion of each array.
	 */
	copylen = sizeof(struct file *) * fdp->fd_nfiles;
	memcpy(newofile, fdp->fd_ofiles, copylen);
	memset((char *)newofile + copylen, 0,
	    nfiles * sizeof(struct file *) - copylen);
	copylen = sizeof(char) * fdp->fd_nfiles;
	memcpy(newofileflags, fdp->fd_ofileflags, copylen);
	memset(newofileflags + copylen, 0, nfiles * sizeof(char) - copylen);

	if (fdp->fd_nfiles > NDFILE)
		free(fdp->fd_ofiles, M_FILEDESC, fdp->fd_nfiles * OFILESIZE);

	if (NDHISLOTS(nfiles) > NDHISLOTS(fdp->fd_nfiles)) {
		copylen = NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int);
		memcpy(newhimap, fdp->fd_himap, copylen);
		memset((char *)newhimap + copylen, 0,
		    NDHISLOTS(nfiles) * sizeof(u_int) - copylen);

		copylen = NDLOSLOTS(fdp->fd_nfiles) * sizeof(u_int);
		memcpy(newlomap, fdp->fd_lomap, copylen);
		memset((char *)newlomap + copylen, 0,
		    NDLOSLOTS(nfiles) * sizeof(u_int) - copylen);

		if (NDHISLOTS(fdp->fd_nfiles) > NDHISLOTS(NDFILE)) {
			free(fdp->fd_himap, M_FILEDESC,
			    NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int));
			free(fdp->fd_lomap, M_FILEDESC,
			    NDLOSLOTS(fdp->fd_nfiles) * sizeof(u_int));
		}
		fdp->fd_himap = newhimap;
		fdp->fd_lomap = newlomap;
	}
	fdp->fd_ofiles = newofile;
	fdp->fd_ofileflags = newofileflags;
	fdp->fd_nfiles = nfiles;	
}

/*
 * Create a new open file structure and allocate
 * a file descriptor for the process that refers to it.
 */
int
falloc(struct proc *p, int flags, struct file **resultfp, int *resultfd)
{
	struct file *fp, *fq;
	int error, i;

	KASSERT(resultfp != NULL);
	KASSERT(resultfd != NULL);

	fdpassertlocked(p->p_fd);
restart:
	if ((error = fdalloc(p, 0, &i)) != 0) {
		if (error == ENOSPC) {
			fdexpand(p);
			goto restart;
		}
		return (error);
	}
	if (numfiles >= maxfiles) {
		fd_unused(p->p_fd, i);
		tablefull("file");
		return (ENFILE);
	}
	/*
	 * Allocate a new file descriptor.
	 * If the process has file descriptor zero open, add to the list
	 * of open files at that point, otherwise put it at the front of
	 * the list of open files.
	 */
	numfiles++;
	fp = pool_get(&file_pool, PR_WAITOK|PR_ZERO);
	fp->f_iflags = FIF_LARVAL;
	if ((fq = p->p_fd->fd_ofiles[0]) != NULL) {
		LIST_INSERT_AFTER(fq, fp, f_list);
	} else {
		LIST_INSERT_HEAD(&filehead, fp, f_list);
	}
	p->p_fd->fd_ofiles[i] = fp;
	p->p_fd->fd_ofileflags[i] |= (flags & UF_EXCLOSE);
	fp->f_count = 1;
	fp->f_cred = p->p_ucred;
	crhold(fp->f_cred);
	*resultfp = fp;
	*resultfd = i;
	FREF(fp);
	return (0);
}

/*
 * Build a new filedesc structure.
 */
struct filedesc *
fdinit(void)
{
	struct filedesc0 *newfdp;

	newfdp = pool_get(&fdesc_pool, PR_WAITOK|PR_ZERO);
	rw_init(&newfdp->fd_fd.fd_lock, "fdlock");

	/* Create the file descriptor table. */
	newfdp->fd_fd.fd_refcnt = 1;
	newfdp->fd_fd.fd_cmask = S_IWGRP|S_IWOTH;
	newfdp->fd_fd.fd_ofiles = newfdp->fd_dfiles;
	newfdp->fd_fd.fd_ofileflags = newfdp->fd_dfileflags;
	newfdp->fd_fd.fd_nfiles = NDFILE;
	newfdp->fd_fd.fd_himap = newfdp->fd_dhimap;
	newfdp->fd_fd.fd_lomap = newfdp->fd_dlomap;
	newfdp->fd_fd.fd_knlistsize = -1;

	newfdp->fd_fd.fd_freefile = 0;
	newfdp->fd_fd.fd_lastfile = 0;

	return (&newfdp->fd_fd);
}

/*
 * Share a filedesc structure.
 */
struct filedesc *
fdshare(struct process *pr)
{
	pr->ps_fd->fd_refcnt++;
	return (pr->ps_fd);
}

/*
 * Copy a filedesc structure.
 */
struct filedesc *
fdcopy(struct process *pr)
{
	struct filedesc *newfdp, *fdp = pr->ps_fd;
	struct file **fpp;
	int i;

	fdplock(fdp);
	newfdp = pool_get(&fdesc_pool, PR_WAITOK);
	memcpy(newfdp, fdp, sizeof(struct filedesc));
	if (newfdp->fd_cdir)
		vref(newfdp->fd_cdir);
	if (newfdp->fd_rdir)
		vref(newfdp->fd_rdir);
	newfdp->fd_refcnt = 1;
	rw_init(&newfdp->fd_lock, "fdlock");

	/*
	 * If the number of open files fits in the internal arrays
	 * of the open file structure, use them, otherwise allocate
	 * additional memory for the number of descriptors currently
	 * in use.
	 */
	if (newfdp->fd_lastfile < NDFILE) {
		newfdp->fd_ofiles = ((struct filedesc0 *) newfdp)->fd_dfiles;
		newfdp->fd_ofileflags =
		    ((struct filedesc0 *) newfdp)->fd_dfileflags;
		i = NDFILE;
	} else {
		/*
		 * Compute the smallest multiple of NDEXTENT needed
		 * for the file descriptors currently in use,
		 * allowing the table to shrink.
		 */
		i = newfdp->fd_nfiles;
		while (i >= 2 * NDEXTENT && i > newfdp->fd_lastfile * 2)
			i /= 2;
		newfdp->fd_ofiles = mallocarray(i, OFILESIZE, M_FILEDESC, M_WAITOK);
		newfdp->fd_ofileflags = (char *) &newfdp->fd_ofiles[i];
	}
	if (NDHISLOTS(i) <= NDHISLOTS(NDFILE)) {
		newfdp->fd_himap =
			((struct filedesc0 *) newfdp)->fd_dhimap;
		newfdp->fd_lomap =
			((struct filedesc0 *) newfdp)->fd_dlomap;
	} else {
		newfdp->fd_himap = mallocarray(NDHISLOTS(i), sizeof(u_int),
		    M_FILEDESC, M_WAITOK);
		newfdp->fd_lomap = mallocarray(NDLOSLOTS(i), sizeof(u_int),
		    M_FILEDESC, M_WAITOK);
	}
	newfdp->fd_nfiles = i;
	memcpy(newfdp->fd_ofiles, fdp->fd_ofiles, i * sizeof(struct file *));
	memcpy(newfdp->fd_ofileflags, fdp->fd_ofileflags, i * sizeof(char));
	memcpy(newfdp->fd_himap, fdp->fd_himap, NDHISLOTS(i) * sizeof(u_int));
	memcpy(newfdp->fd_lomap, fdp->fd_lomap, NDLOSLOTS(i) * sizeof(u_int));
	fdpunlock(fdp);

	fdplock(newfdp);
	fpp = newfdp->fd_ofiles;
	for (i = 0; i <= newfdp->fd_lastfile; i++, fpp++)
		if (*fpp != NULL) {
			/*
			 * XXX Gruesome hack. If count gets too high, fail
			 * to copy an fd, since fdcopy()'s callers do not
			 * permit it to indicate failure yet.
			 * Meanwhile, kqueue files have to be
			 * tied to the process that opened them to enforce
			 * their internal consistency, so close them here.
			 */
			if ((*fpp)->f_count == LONG_MAX-2 ||
			    (*fpp)->f_type == DTYPE_KQUEUE)
				fdremove(newfdp, i);
			else
				(*fpp)->f_count++;
		}

	/* finish cleaning up kq bits */
	if (newfdp->fd_knlistsize != -1) {
		newfdp->fd_knlist = NULL;
		newfdp->fd_knlistsize = -1;
		newfdp->fd_knhash = NULL;
		newfdp->fd_knhashmask = 0;
	}

	fdpunlock(newfdp);
	return (newfdp);
}

/*
 * Release a filedesc structure.
 */
void
fdfree(struct proc *p)
{
	struct filedesc *fdp = p->p_fd;
	struct file **fpp, *fp;
	int i;

	if (--fdp->fd_refcnt > 0)
		return;
	fpp = fdp->fd_ofiles;
	for (i = fdp->fd_lastfile; i >= 0; i--, fpp++) {
		fp = *fpp;
		if (fp != NULL) {
			FREF(fp);
			*fpp = NULL;
			(void) closef(fp, p);
		}
	}
	p->p_fd = NULL;
	if (fdp->fd_nfiles > NDFILE)
		free(fdp->fd_ofiles, M_FILEDESC, fdp->fd_nfiles * OFILESIZE);
	if (NDHISLOTS(fdp->fd_nfiles) > NDHISLOTS(NDFILE)) {
		free(fdp->fd_himap, M_FILEDESC,
		    NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int));
		free(fdp->fd_lomap, M_FILEDESC,
		    NDLOSLOTS(fdp->fd_nfiles) * sizeof(u_int));
	}
	if (fdp->fd_cdir)
		vrele(fdp->fd_cdir);
	if (fdp->fd_rdir)
		vrele(fdp->fd_rdir);
	free(fdp->fd_knlist, M_TEMP, fdp->fd_knlistsize * sizeof(struct klist));
	hashfree(fdp->fd_knhash, KN_HASHSIZE, M_TEMP);
	pool_put(&fdesc_pool, fdp);
}

/*
 * Internal form of close.
 * Decrement reference count on file structure.
 * Note: p may be NULL when closing a file
 * that was being passed in a message.
 *
 * The fp must have its usecount bumped and will be FRELEd here.
 */
int
closef(struct file *fp, struct proc *p)
{
	struct filedesc *fdp;

	if (fp == NULL)
		return (0);

#ifdef DIAGNOSTIC
	if (fp->f_count < 2)
		panic("closef: count (%ld) < 2", fp->f_count);
#endif
	fp->f_count--;

	/*
	 * POSIX record locking dictates that any close releases ALL
	 * locks owned by this process.  This is handled by setting
	 * a flag in the unlock to free ONLY locks obeying POSIX
	 * semantics, and not to free BSD-style file locks.
	 * If the descriptor was in a message, POSIX-style locks
	 * aren't passed with the descriptor.
	 */

	if (p && ((fdp = p->p_fd) != NULL) &&
	    (fdp->fd_flags & FD_ADVLOCK) &&
	    fp->f_type == DTYPE_VNODE) {
		struct vnode *vp = fp->f_data;
		struct flock lf;

		lf.l_whence = SEEK_SET;
		lf.l_start = 0;
		lf.l_len = 0;
		lf.l_type = F_UNLCK;
		(void) VOP_ADVLOCK(vp, fdp, F_UNLCK, &lf, F_POSIX);
	}

	return (FRELE(fp, p));
}

int
fdrop(struct file *fp, struct proc *p)
{
	int error;

#ifdef DIAGNOSTIC
	if (fp->f_count != 0)
		panic("fdrop: count (%ld) != 0", fp->f_count);
#endif

	if (fp->f_ops)
		error = (*fp->f_ops->fo_close)(fp, p);
	else
		error = 0;

	/* Free fp */
	LIST_REMOVE(fp, f_list);
	crfree(fp->f_cred);
	numfiles--;
	pool_put(&file_pool, fp);

	return (error);
}

/*
 * Apply an advisory lock on a file descriptor.
 *
 * Just attempt to get a record lock of the requested type on
 * the entire file (l_whence = SEEK_SET, l_start = 0, l_len = 0).
 */
int
sys_flock(struct proc *p, void *v, register_t *retval)
{
	struct sys_flock_args /* {
		syscallarg(int) fd;
		syscallarg(int) how;
	} */ *uap = v;
	int fd = SCARG(uap, fd);
	int how = SCARG(uap, how);
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	struct flock lf;
	int error;

	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if (fp->f_type != DTYPE_VNODE)
		return (EOPNOTSUPP);
	FREF(fp);
	vp = fp->f_data;
	lf.l_whence = SEEK_SET;
	lf.l_start = 0;
	lf.l_len = 0;
	if (how & LOCK_UN) {
		lf.l_type = F_UNLCK;
		fp->f_iflags &= ~FIF_HASLOCK;
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_UNLCK, &lf, F_FLOCK);
		goto out;
	}
	if (how & LOCK_EX)
		lf.l_type = F_WRLCK;
	else if (how & LOCK_SH)
		lf.l_type = F_RDLCK;
	else {
		error = EINVAL;
		goto out;
	}
	fp->f_iflags |= FIF_HASLOCK;
	if (how & LOCK_NB)
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, F_FLOCK);
	else
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, F_FLOCK|F_WAIT);
out:
	FRELE(fp, p);
	return (error);
}

/*
 * File Descriptor pseudo-device driver (/dev/fd/).
 *
 * Opening minor device N dup()s the file (if any) connected to file
 * descriptor N belonging to the calling process.  Note that this driver
 * consists of only the ``open()'' routine, because all subsequent
 * references to this file will be direct to the other driver.
 */
int
filedescopen(dev_t dev, int mode, int type, struct proc *p)
{

	/*
	 * XXX Kludge: set curproc->p_dupfd to contain the value of the
	 * the file descriptor being sought for duplication. The error
	 * return ensures that the vnode for this device will be released
	 * by vn_open. Open will detect this special error and take the
	 * actions in dupfdopen below. Other callers of vn_open or VOP_OPEN
	 * will simply report the error.
	 */
	p->p_dupfd = minor(dev);
	return (ENODEV);
}

/*
 * Duplicate the specified descriptor to a free descriptor.
 */
int
dupfdopen(struct proc *p, int indx, int mode)
{
	struct filedesc *fdp = p->p_fd;
	int dupfd = p->p_dupfd;
	struct file *wfp;

	fdpassertlocked(fdp);

	/*
	 * Assume that the filename was user-specified; applications do
	 * not tend to open /dev/fd/# when they can just call dup()
	 */
	if ((p->p_p->ps_flags & (PS_SUGIDEXEC | PS_SUGID))) {
		if (p->p_descfd == 255)
			return (EPERM);
		if (p->p_descfd != dupfd)
			return (EPERM);
	}

	/*
	 * If the to-be-dup'd fd number is greater than the allowed number
	 * of file descriptors, or the fd to be dup'd has already been
	 * closed, reject. Note, there is no need to check for new == old
	 * because fd_getfile will return NULL if the file at indx is
	 * newly created by falloc (FIF_LARVAL).
	 */
	if ((wfp = fd_getfile(fdp, dupfd)) == NULL)
		return (EBADF);

	/*
	 * Check that the mode the file is being opened for is a
	 * subset of the mode of the existing descriptor.
	 */
	if (((mode & (FREAD|FWRITE)) | wfp->f_flag) != wfp->f_flag)
		return (EACCES);
	if (wfp->f_count == LONG_MAX-2)
		return (EDEADLK);

	fdp->fd_ofiles[indx] = wfp;
	fdp->fd_ofileflags[indx] = (fdp->fd_ofileflags[indx] & UF_EXCLOSE) |
	    (fdp->fd_ofileflags[dupfd] & ~UF_EXCLOSE);
	if (ISSET(p->p_p->ps_flags, PS_PLEDGE))
		fdp->fd_ofileflags[indx] |= UF_PLEDGED;
	wfp->f_count++;
	fd_used(fdp, indx);
	return (0);
}

/*
 * Close any files on exec?
 */
void
fdcloseexec(struct proc *p)
{
	struct filedesc *fdp = p->p_fd;
	int fd;

	fdplock(fdp);
	for (fd = 0; fd <= fdp->fd_lastfile; fd++) {
		fdp->fd_ofileflags[fd] &= ~UF_PLEDGED;
		if (fdp->fd_ofileflags[fd] & UF_EXCLOSE)
			(void) fdrelease(p, fd);
	}
	fdpunlock(fdp);
}

int
sys_closefrom(struct proc *p, void *v, register_t *retval)
{
	struct sys_closefrom_args *uap = v;
	struct filedesc *fdp = p->p_fd;
	u_int startfd, i;

	startfd = SCARG(uap, fd);
	fdplock(fdp);

	if (startfd > fdp->fd_lastfile) {
		fdpunlock(fdp);
		return (EBADF);
	}

	for (i = startfd; i <= fdp->fd_lastfile; i++)
		fdrelease(p, i);

	fdpunlock(fdp);
	return (0);
}

int
sys_getdtablecount(struct proc *p, void *v, register_t *retval)
{
	*retval = p->p_fd->fd_openfd;
	return (0);
}
@


1.140
log
@Add a flags argument to falloc() that lets it optionally set the
close-on-exec flag on the newly allocated fd.  Make falloc()'s
return arguments non-optional: assert that they're not NULL.

ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.139 2017/01/24 04:09:59 deraadt Exp $	*/
d438 1
@


1.140.4.1
log
@Initialize a local variable to not leak kernel stack info to userland
if TIOCGPGRP fail.
Issue found by Ilja van Sprundel.
errata 022
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.140 2017/02/11 19:51:06 guenther Exp $	*/
a437 1
		tmp = 0;
@


1.139
log
@Track a per-fd flag UF_PLEDGED.  This indicates the initial open was done by a
pledged process. dup(2) and recvmsg(2) retain UF_PLEDGED from the original fd.
In pledge "exec" circumstances, exceve clears UF_PLEDGED on all the process's
fds.

In a pledge'd process, ioctl(2) can use this additional information to grant
access to ioctl's which are more sensitive or dive deeply into the kernel.
Developers will be encouraged to open such sensitive resources before calling
pledge(2), rather than afterwards.  That matches the heading of privsep
development practices.

Future changes will introduce those ioctl(2) changes.

Lots of discussions with semarie guenther and benno.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.138 2017/01/23 23:22:00 mpi Exp $	*/
d898 1
a898 1
falloc(struct proc *p, struct file **resultfp, int *resultfd)
d903 3
d935 1
d939 2
a940 4
	if (resultfp)
		*resultfp = fp;
	if (resultfd)
		*resultfd = i;
@


1.138
log
@Allocate all memory chunks, and potentially sleeping, before freeing
the old array of open files.

Fix a race for multi-threaded processes reported by cheeky.m@@gmx.com
on bugs@@ and analyzed with bluhm@@.

ok deraadt@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.137 2017/01/23 22:34:10 deraadt Exp $	*/
d614 1
a614 1
	fdp->fd_ofileflags[new] = fdp->fd_ofileflags[old] & ~UF_EXCLOSE;
d635 1
d809 2
d1305 2
d1322 2
a1323 1
	for (fd = 0; fd <= fdp->fd_lastfile; fd++)
d1326 1
@


1.137
log
@Avoid curproc dance in dupfdopen(), by passing a struct proc *
ok guenther mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.136 2016/09/24 18:39:17 tedu Exp $	*/
d838 10
a865 5
		newhimap = mallocarray(NDHISLOTS(nfiles), sizeof(u_int),
		    M_FILEDESC, M_WAITOK);
		newlomap = mallocarray(NDLOSLOTS(nfiles), sizeof(u_int),
		    M_FILEDESC, M_WAITOK);

@


1.136
log
@move knhash size to event.h, use it for hashfree. from Mathieu -
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.135 2016/09/15 02:00:16 dlg Exp $	*/
d1256 1
a1256 1
dupfdopen(struct filedesc *fdp, int indx, int dfd, int mode)
d1258 2
d1268 2
a1269 2
	if ((curproc->p_p->ps_flags & (PS_SUGIDEXEC | PS_SUGID))) {
		if (curproc->p_descfd == 255)
d1271 1
a1271 1
		if (curproc->p_descfd != curproc->p_dupfd)
d1282 1
a1282 1
	if ((wfp = fd_getfile(fdp, dfd)) == NULL)
d1296 1
a1296 1
	    (fdp->fd_ofileflags[dfd] & ~UF_EXCLOSE);
@


1.135
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.134 2016/08/25 00:00:02 dlg Exp $	*/
d1099 1
a1099 1
	free(fdp->fd_knhash, M_TEMP, 0);
@


1.134
log
@pool_setipl

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.133 2016/08/23 23:28:02 tedu Exp $	*/
d86 4
a89 6
	pool_init(&file_pool, sizeof(struct file), 0, 0, PR_WAITOK,
	    "filepl", NULL);
	pool_setipl(&file_pool, IPL_NONE);
	pool_init(&fdesc_pool, sizeof(struct filedesc0), 0, 0, PR_WAITOK,
	    "fdescpl", NULL);
	pool_setipl(&fdesc_pool, IPL_NONE);
@


1.133
log
@rename nfiles to numfiles to avoid shadowing and stretch out the name.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.132 2016/05/29 13:51:53 natano Exp $	*/
d88 1
d91 1
@


1.132
log
@Fix sizes passed to free() in fdfree(). This prevents a panic reported
by sthen.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.131 2016/05/28 00:11:10 tedu Exp $	*/
d71 1
a71 1
int nfiles;			/* actual number of open files */
d904 1
a904 1
	if (nfiles >= maxfiles) {
d915 1
a915 1
	nfiles++;
d1168 1
a1168 1
	nfiles--;
@


1.132.2.1
log
@Initialize a local variable to not leak kernel stack info to userland
if TIOCGPGRP fail.
Issue found by Ilja van Sprundel.
errata 36
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.132 2016/05/29 13:51:53 natano Exp $	*/
a437 1
		tmp = 0;
@


1.131
log
@add sizes to free() calls for descrip tables
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.130 2016/04/25 20:18:31 tedu Exp $	*/
d875 1
a875 1
			    NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int));
d1092 1
a1092 1
		    NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int));
@


1.130
log
@remove systrace remnants
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.129 2016/03/19 12:04:15 natano Exp $	*/
d853 1
a853 1
		free(fdp->fd_ofiles, M_FILEDESC, 0);
d872 4
a875 2
			free(fdp->fd_himap, M_FILEDESC, 0);
			free(fdp->fd_lomap, M_FILEDESC, 0);
d1087 1
a1087 1
		free(fdp->fd_ofiles, M_FILEDESC, 0);
d1089 4
a1092 2
		free(fdp->fd_himap, M_FILEDESC, 0);
		free(fdp->fd_lomap, M_FILEDESC, 0);
@


1.129
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.128 2016/01/06 17:59:30 tedu Exp $	*/
d1039 1
a1039 1
			 * Meanwhile, kqueue and systrace files have to be
d1044 1
a1044 2
			    (*fpp)->f_type == DTYPE_KQUEUE ||
			    (*fpp)->f_type == DTYPE_SYSTRACE)
@


1.128
log
@remove unnecessary casts where the incoming type is void *.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.127 2015/12/17 16:59:26 tedu Exp $	*/
d755 1
a755 1
		VOP_UNLOCK(vp, 0, p);
@


1.127
log
@no need to check null before free
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.126 2015/12/17 16:49:07 tedu Exp $	*/
d404 1
a404 1
		vp = (struct vnode *)fp->f_data;
d445 1
a445 1
			struct socket *so = (struct socket *)fp->f_data;
d453 1
a453 1
			struct pipe *mpipe = (struct pipe *)fp->f_data;
d485 1
a485 1
		vp = (struct vnode *)fp->f_data;
d552 1
a552 1
		vp = (struct vnode *)fp->f_data;
d752 1
a752 1
		vp = (struct vnode *)fp->f_data;
d1197 1
a1197 1
	vp = (struct vnode *)fp->f_data;
@


1.126
log
@add size to free. from Mathieu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.125 2015/12/05 10:11:53 tedu Exp $	*/
d1095 2
a1096 4
	if (fdp->fd_knlist)
		free(fdp->fd_knlist, M_TEMP, fdp->fd_knlistsize * sizeof(struct klist));
	if (fdp->fd_knhash)
		free(fdp->fd_knhash, M_TEMP, 0);
@


1.125
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.124 2015/11/01 19:03:33 semarie Exp $	*/
d1096 1
a1096 1
		free(fdp->fd_knlist, M_TEMP, 0);
@


1.124
log
@refactor pledge_*_check and pledge_fail functions

- rename _check function without suffix: a "pledge" function called from
  anywhere is a "check" function.

- makes pledge_fail call the responsability to the _check function. remove it
  from caller.

- make proper use of (potential) returned error of _check() functions.

- adds pledge_kill() and pledge_protexec()

with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.123 2015/10/28 12:17:20 deraadt Exp $	*/
a217 1
/* ARGSUSED */
a332 1
/* ARGSUSED */
a664 1
/* ARGSUSED */
a723 1
/* ARGSUSED */
a1178 1
/* ARGSUSED */
a1234 1
/* ARGSUSED */
@


1.123
log
@Prevent F_SETOWN, unless a "proc" pledge was made.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.122 2015/10/21 16:09:13 bluhm Exp $	*/
d351 3
a353 3
	error = pledge_fcntl_check(p,  SCARG(uap, cmd));
	if (error != 0)
		return (pledge_fail(p, error, PLEDGE_PROC));
d479 1
a479 1
		error = pledge_flock_check(p);
d546 1
a546 1
		error = pledge_flock_check(p);
@


1.122
log
@Setting fcntl(F_SETOWN) for a pipe failed with inappropriate ioctl
for device.  In sys_fcntl() the ioctl(TIOCSPGRP) is called, but the
pipe expects SIOCSPGRP.  Sockets have a specal case for the same
reason, so adapt the special code for pipes.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.121 2015/10/16 13:37:43 millert Exp $	*/
d350 4
@


1.121
log
@Implement real "flock" request and add it to userland programs that
use pledge and file locking.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.120 2015/05/17 01:22:01 deraadt Exp $	*/
d432 4
d448 6
@


1.120
log
@isatty() is used by stdio to determine the buffering mode.  Add a F_ISATTY
option to fcntl(), so that isatty() can use this rather than than the bloated
ioctl() interface.  Reducing uses of ioctl() by libc makes it easier to
constrain programs with various kinds of systrace sandboxes.
ok guenther, previously discussed as a concept with nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.119 2015/04/30 21:18:45 millert Exp $	*/
d63 1
d465 4
d532 4
@


1.119
log
@Avoid NULL deref in fd_getfile_mode(); OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.118 2015/04/30 09:20:51 mpi Exp $	*/
d398 10
@


1.118
log
@Indroduce fd_getfile_mode() and use it were fd_getfile() is directly
followed by a mode check.  This will simplify the ref/unref dance as
soon as fd_getfile() will increment fp's reference counter.

Idea from and ok guenther@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.117 2015/03/14 03:38:50 jsg Exp $	*/
d204 1
a204 1
	if ((fp->f_flag & mode) == 0)
@


1.117
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.116 2015/01/19 01:19:17 deraadt Exp $	*/
d190 15
@


1.116
log
@unneccessary cmask variable; ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.115 2014/12/19 05:59:21 tedu Exp $	*/
a57 1
#include <sys/conf.h>
@


1.115
log
@start retiring the nointr allocator. specify PR_WAITOK as a flag as a
marker for which pools are not interrupt safe. ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.114 2014/12/16 18:30:03 tedu Exp $	*/
a896 1
	extern int cmask;
d903 1
a903 1
	newfdp->fd_fd.fd_cmask = cmask;
@


1.114
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.113 2014/08/31 01:42:36 guenther Exp $	*/
d86 4
a89 4
	pool_init(&file_pool, sizeof(struct file), 0, 0, 0, "filepl",
		&pool_allocator_nointr);
	pool_init(&fdesc_pool, sizeof(struct filedesc0), 0, 0, 0, "fdescpl",
		&pool_allocator_nointr);
@


1.113
log
@Add additional kernel interfaces for setting close-on-exec on fds
when creating them: pipe2(), dup3(), accept4(), MSG_CMSG_CLOEXEC,
SOCK_CLOEXEC.  Includes SOCK_NONBLOCK support.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.112 2014/07/13 15:29:04 tedu Exp $	*/
d52 1
@


1.112
log
@use mallocarray where arguments are multipled. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.111 2014/07/12 18:43:32 tedu Exp $	*/
d77 1
a238 1
/* ARGSUSED */
d246 24
a269 1
	int old = SCARG(uap, from), new = SCARG(uap, to);
d307 2
@


1.111
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.110 2014/07/08 17:19:25 deraadt Exp $	*/
d768 1
a768 1
	newofile = malloc(nfiles * OFILESIZE, M_FILEDESC, M_WAITOK);
d787 1
a787 1
		newhimap = malloc(NDHISLOTS(nfiles) * sizeof(u_int),
d789 1
a789 1
		newlomap = malloc(NDLOSLOTS(nfiles) * sizeof(u_int),
d942 1
a942 1
		newfdp->fd_ofiles = malloc(i * OFILESIZE, M_FILEDESC, M_WAITOK);
d951 1
a951 1
		newfdp->fd_himap = malloc(NDHISLOTS(i) * sizeof(u_int),
d953 1
a953 1
		newfdp->fd_lomap = malloc(NDLOSLOTS(i) * sizeof(u_int),
@


1.110
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.109 2014/06/15 20:39:22 matthew Exp $	*/
d784 1
a784 1
		free(fdp->fd_ofiles, M_FILEDESC);
d803 2
a804 2
			free(fdp->fd_himap, M_FILEDESC);
			free(fdp->fd_lomap, M_FILEDESC);
d1018 1
a1018 1
		free(fdp->fd_ofiles, M_FILEDESC);
d1020 2
a1021 2
		free(fdp->fd_himap, M_FILEDESC);
		free(fdp->fd_lomap, M_FILEDESC);
d1028 1
a1028 1
		free(fdp->fd_knlist, M_TEMP);
d1030 1
a1030 1
		free(fdp->fd_knhash, M_TEMP);
@


1.109
log
@Use sizeof(struct file *) consistently for memcpy()'ing fd_ofiles.

Pointed out by Jean-Philippe Ouellet.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.108 2014/05/15 03:52:25 guenther Exp $	*/
a62 2

#include <uvm/uvm_extern.h>
@


1.108
log
@Move from struct proc to process the reference-count-holding pointers
to the process's vmspace and filedescs.  struct proc continues to
keep copies of the pointers, copying them on fork, clearing them
on exit, and (for vmspace) refreshing on exec.
Also, make uvm_swapout_threads() thread aware, eliminating p_swtime
in kernel.

particular testing by ajacoutot@@ and sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.107 2014/04/12 14:18:11 espie Exp $	*/
d959 1
a959 1
	memcpy(newfdp->fd_ofiles, fdp->fd_ofiles, i * sizeof(struct file **));
@


1.107
log
@revert falloc change, as it causes all new processes to get stuck after a while
(race condition ?)

problem noticed by me, aja, sthen, brynet, rpe.

vanishing after this revert, okay aja@@, sthen@@

tedu, you probably want to look into re-checking the fcreate/fpublish addition
first, then if it's stable, see about tweaking doopenat ?
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.106 2014/03/30 21:54:48 guenther Exp $	*/
d870 1
a870 1
fdinit(struct proc *p)
a875 9
	if (p != NULL) {
		struct filedesc *fdp = p->p_fd;

		newfdp->fd_fd.fd_cdir = fdp->fd_cdir;
		vref(newfdp->fd_fd.fd_cdir);
		newfdp->fd_fd.fd_rdir = fdp->fd_rdir;
		if (newfdp->fd_fd.fd_rdir)
			vref(newfdp->fd_fd.fd_rdir);
	}
d898 1
a898 1
fdshare(struct proc *p)
d900 2
a901 2
	p->p_fd->fd_refcnt++;
	return (p->p_fd);
d908 1
a908 1
fdcopy(struct proc *p)
d910 1
a910 1
	struct filedesc *newfdp, *fdp = p->p_fd;
@


1.106
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.105 2014/03/08 22:54:29 tedu Exp $	*/
d823 2
a824 1
	int error;
d826 7
a832 1
	if ((error = fcreate(p, resultfp)))
d834 1
a834 17
	if ((error = fpublish(p, *resultfp, resultfd)))
		closef(*resultfp, p);
	return (error);
}

int
fcreate(struct proc *p, struct file **resultfp)
{
	struct filedesc *fdp = p->p_fd;
	struct file *fp, *fq;
	int lim;

	fdpassertlocked(fdp);
	lim = min((int)p->p_rlimit[RLIMIT_NOFILE].rlim_cur, maxfiles);
	if (fdp->fd_openfd >= lim)
		return (EMFILE);

d836 1
a845 1
	fdp->fd_openfd++;
d854 1
a859 22
	FREF(fp);
	return (0);
}

int
fpublish(struct proc *p, struct file *fp, int *resultfd)
{
	struct filedesc *fdp = p->p_fd;
	int i, error;

	fdpassertlocked(fdp);
	fdp->fd_openfd--; /* undo previous increase by fcreate */
restart:
	if ((error = fdalloc(p, 0, &i)) != 0) {
		if (error == ENOSPC) {
			fdexpand(p);
			goto restart;
		}
		return (error);
	}

	fdp->fd_ofiles[i] = fp;
d862 1
@


1.105
log
@split falloc into two functions, the allocation and the publication.
the first part is likely to fail, but we can generally prevent the second
part from failing.
use these two functions to drop the fdp lock around vn_open in sys_open,
but still maintain the original semantics of allocate then open.
the goal here is to fix the blocked fifo deadlock in a threaded program.

testing volunteers in short supply, resorting to conscription
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.104 2013/09/14 01:35:00 guenther Exp $	*/
d393 1
a393 1
			so->so_siguid = p->p_cred->p_ruid;
@


1.104
log
@Snapshots for all archs have been built, so remove the T32 code
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.103 2013/08/13 05:52:23 guenther Exp $	*/
d823 13
d837 6
a842 1
	int error, i;
a843 9
	fdpassertlocked(p->p_fd);
restart:
	if ((error = fdalloc(p, 0, &i)) != 0) {
		if (error == ENOSPC) {
			fdexpand(p);
			goto restart;
		}
		return (error);
	}
a844 1
		fd_unused(p->p_fd, i);
d854 1
a862 1
	p->p_fd->fd_ofiles[i] = fp;
d868 22
a891 1
	FREF(fp);
@


1.103
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.102 2013/07/04 16:55:19 sf Exp $	*/
a651 26

#ifdef T32
int	copyout_stat32(struct stat *, void *, struct proc *);
int
t32_sys_fstat(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_fstat_args /* {
		syscallarg(int) fd;
		syscallarg(struct stat32 *) sb;
	} */ *uap = v;
	int fd = SCARG(uap, fd);
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct stat ub;
	int error;

	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	FREF(fp);
	error = (*fp->f_ops->fo_stat)(fp, &ub, p);
	FRELE(fp, p);
	if (error == 0)
		error = copyout_stat32(&ub, SCARG(uap, sb), p);
	return (error);
}
#endif
@


1.102
log
@Format string fixes:

f_count is long
ok kettenis@@

Change esm_sensor_map.arg to int
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.101 2013/06/11 13:00:31 tedu Exp $	*/
a617 1
/* ARGSUSED */
d652 26
@


1.101
log
@convert some easy bcopy to memcpy and clean up fdexpand a bit.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.100 2013/06/05 01:26:00 guenther Exp $	*/
d1064 1
a1064 1
		panic("closef: count (%d) < 2", fp->f_count);
d1100 1
a1100 1
		panic("fdrop: count (%d) != 0", fp->f_count);
@


1.100
log
@Move FHASLOCK from f_flag to f_iflags, freeing up a bit for passing
O_* flags and eliminating an XXX comment.

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.99 2012/08/23 00:11:56 guenther Exp $	*/
d755 2
a756 1
	int nfiles, i;
d778 7
a784 6
	bcopy(fdp->fd_ofiles, newofile,
		(i = sizeof(struct file *) * fdp->fd_nfiles));
	bzero((char *)newofile + i, nfiles * sizeof(struct file *) - i);
	bcopy(fdp->fd_ofileflags, newofileflags,
		(i = sizeof(char) * fdp->fd_nfiles));
	bzero(newofileflags + i, nfiles * sizeof(char) - i);
d795 9
a803 9
		bcopy(fdp->fd_himap, newhimap,
		    (i = NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int)));
		bzero((char *)newhimap + i,
		    NDHISLOTS(nfiles) * sizeof(u_int) - i);

		bcopy(fdp->fd_lomap, newlomap,
		    (i = NDLOSLOTS(fdp->fd_nfiles) * sizeof(u_int)));
		bzero((char *)newlomap + i,
		    NDLOSLOTS(nfiles) * sizeof(u_int) - i);
d926 1
a926 1
	bcopy(fdp, newfdp, sizeof(struct filedesc));
d969 4
a972 4
	bcopy(fdp->fd_ofiles, newfdp->fd_ofiles, i * sizeof(struct file **));
	bcopy(fdp->fd_ofileflags, newfdp->fd_ofileflags, i * sizeof(char));
	bcopy(fdp->fd_himap, newfdp->fd_himap, NDHISLOTS(i) * sizeof(u_int));
	bcopy(fdp->fd_lomap, newfdp->fd_lomap, NDLOSLOTS(i) * sizeof(u_int));
@


1.99
log
@To protect assumptions inside systrace, don't let systrace fds be
shared between processes.

ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.98 2012/07/11 23:07:19 guenther Exp $	*/
d1148 1
a1148 1
		fp->f_flag &= ~FHASLOCK;
d1160 1
a1160 1
	fp->f_flag |= FHASLOCK;
@


1.98
log
@Revert the blocked FIFO open fix, as there's either a race in the
ref-count handling under handling, or blambert@@ is messing with my head
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.96 2012/05/21 16:41:03 matthew Exp $	*/
a972 3
	/*
	 * kq descriptors cannot be copied.
	 */
a973 11
	if (newfdp->fd_knlistsize != -1) {
		fpp = newfdp->fd_ofiles;
		for (i = 0; i <= newfdp->fd_lastfile; i++, fpp++)
			if (*fpp != NULL && (*fpp)->f_type == DTYPE_KQUEUE)
				fdremove(newfdp, i);
		newfdp->fd_knlist = NULL;
		newfdp->fd_knlistsize = -1;
		newfdp->fd_knhash = NULL;
		newfdp->fd_knhashmask = 0;
	}

d981 3
d985 3
a987 1
			if ((*fpp)->f_count == LONG_MAX-2)
d992 9
@


1.97
log
@Don't hold the fd-table lock across vn_open(), as opening a FIFO may block.
Having done that, dupfdopen() has to handle a possible race.

ok matthew@@ krw@@
@
text
@d1199 1
a1199 1
dupfdopen(struct proc *p, int indx, struct file *fp, int mode)
a1200 1
	struct filedesc *fdp = p->p_fd;
a1201 1
	int dfd = p->p_dupfd;
d1209 2
a1210 2
	if ((p->p_p->ps_flags & (PS_SUGIDEXEC | PS_SUGID))) {
		if (p->p_descfd == 255)
d1212 1
a1212 1
		if (p->p_descfd != dfd)
a1234 14
	FREF(wfp);

	/*
	 * Check whether the larval fd was close behind our back.
	 * If it was, we act like the open() completed before the
	 * close(): fake up a closef(), to provide POSIX lock semantics,
	 * then return success.
	 */
	if (fdp->fd_ofiles[indx] != fp) {
		FREF(wfp);	/* yes, again: closef() decrements it twice */
		closef(wfp, p);
		return (0);
	}

d1238 1
@


1.96
log
@Cleanup O_CLOEXEC handling and make sure UF_EXCLOSE is set correctly
when opening /dev/fd/* (i.e., UF_EXCLOSE is now set iff O_CLOEXEC is
set, rather than copying UF_EXCLOSE from the file descriptor being
dup'd).

Also, add support for O_CLOEXEC and O_DIRECTORY to fhopen().

ok krw, guenther; feedback from millert; testing and bug finding by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.95 2012/05/14 02:41:13 guenther Exp $	*/
d1199 1
a1199 1
dupfdopen(struct filedesc *fdp, int indx, int dfd, int mode)
d1201 1
d1203 1
d1211 2
a1212 2
	if ((curproc->p_p->ps_flags & (PS_SUGIDEXEC | PS_SUGID))) {
		if (curproc->p_descfd == 255)
d1214 1
a1214 1
		if (curproc->p_descfd != curproc->p_dupfd)
d1237 14
a1253 1
	wfp->f_count++;
@


1.95
log
@Remove the "vn_open() returning ENXIO means dup+close" hook that
was used by the now defunct portalfs.  Zero out fd_ofileflags[fd]
when allocating an fd instead of when releasing it.

ok krw@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.94 2012/05/01 03:43:23 guenther Exp $	*/
d1236 2
a1237 1
	fdp->fd_ofileflags[indx] = fdp->fd_ofileflags[dfd];
@


1.94
log
@Eliminate the f_usecount ref count in struct file; instead of sleeping
at the top of closef() until all in-progress calls finish, just do the
advisory locking bits required of close() by POSIX and let whichever
thread has the last reference do the call to the file's fo_close()
method and the final cleanup.

lots of discussion with deraadt@@ and others; worked out with and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.93 2012/04/22 05:43:14 guenther Exp $	*/
a586 1
	fdp->fd_ofileflags[fd] = 0;
d741 1
d1199 1
a1199 1
dupfdopen(struct filedesc *fdp, int indx, int dfd, int mode, int error)
d1227 2
a1228 10
	 * There are two cases of interest here.
	 *
	 * For ENODEV simply dup (dfd) to file descriptor
	 * (indx) and return.
	 *
	 * For ENXIO steal away the file structure from (dfd) and
	 * store it in (indx).  (dfd) is effectively closed by
	 * this operation.
	 *
	 * Any other error code is just returned.
d1230 4
a1233 15
	switch (error) {
	case ENODEV:
		/*
		 * Check that the mode the file is being opened for is a
		 * subset of the mode of the existing descriptor.
		 */
		if (((mode & (FREAD|FWRITE)) | wfp->f_flag) != wfp->f_flag)
			return (EACCES);
		if (wfp->f_count == LONG_MAX-2)
			return (EDEADLK);
		fdp->fd_ofiles[indx] = wfp;
		fdp->fd_ofileflags[indx] = fdp->fd_ofileflags[dfd];
		wfp->f_count++;
		fd_used(fdp, indx);
		return (0);
d1235 5
a1239 20
	case ENXIO:
		/*
		 * Steal away the file pointer from dfd, and stuff it into indx.
		 */
		fdp->fd_ofiles[indx] = fdp->fd_ofiles[dfd];
		fdp->fd_ofileflags[indx] = fdp->fd_ofileflags[dfd];
		fdp->fd_ofiles[dfd] = NULL;
		fdp->fd_ofileflags[dfd] = 0;
		/*
		 * Complete the clean up of the filedesc structure by
		 * recomputing the various hints.
		 */
		fd_used(fdp, indx);
		fd_unused(fdp, dfd);
		return (0);

	default:
		return (error);
	}
	/* NOTREACHED */
@


1.93
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.92 2012/04/12 17:42:57 deraadt Exp $	*/
a1055 2
	int references_left;
	int error;
a1059 11
	/*
	 * Some files passed to this function could be accessed
	 * without a FILE_IS_USABLE check (and in some cases it's perfectly
	 * legal), we must beware of files where someone already won the
	 * race to FIF_WANTCLOSE.
	 */
	if ((fp->f_iflags & FIF_WANTCLOSE) != 0 ||
	    --fp->f_count > 0) {
		references_left = 1;
	} else {
		references_left = 0;
d1061 2
a1062 2
		if (fp->f_count < 0)
			panic("closef: count < 0");
d1064 1
a1064 6

		/* Wait for the last usecount to drain. */
		fp->f_iflags |= FIF_WANTCLOSE;
		while (fp->f_usecount > 1)
			tsleep(&fp->f_usecount, PRIBIO, "closef", 0);
	}
d1088 12
a1099 4
	if (references_left) {
		FRELE(fp, p);
		return (0);
	}
a1108 4
#ifdef DIAGNOSTIC
	if (fp->f_count != 0 || fp->f_usecount != 1)
		panic("closef: count: %d/%d", fp->f_count, fp->f_usecount);
#endif
@


1.92
log
@In this case where dup2() extends the table using fdalloc, the newly
selected fd is automatically fd_used().  We need to fd_unused() it,
because it will be fd_used() again in finishdup().  spotted by guenther
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.91 2012/04/12 11:07:20 deraadt Exp $	*/
d222 1
a222 1
		FRELE(fp);
d272 1
a272 1
			FRELE(fp);
d328 1
a328 1
			FRELE(fp);
d516 1
a516 1
	FRELE(fp);
d532 1
a532 1
		FRELE(fp);
d547 1
a547 1
	FRELE(fp);
d637 1
a637 1
	FRELE(fp);
d697 1
a697 1
	FRELE(fp);
d1092 1
d1107 1
a1107 1
		FRELE(fp);
d1180 1
a1180 1
	FRELE(fp);
@


1.91
log
@New system call: getdtablecount(2) returns the number of file
descriptors the process currently has open.
ok guenther miod gilles ...
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.90 2012/04/12 11:01:37 deraadt Exp $	*/
d282 1
@


1.90
log
@dup() was calling fd_used() twice for the new file descriptor.  Seperate
the dup and dup2 cases.  with guenther
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.89 2012/02/15 04:26:27 guenther Exp $	*/
d158 1
d179 1
d1323 7
@


1.89
log
@Hold struct filedesc's fd_lock when writing to the fd_ofiles, fd_ofileflags,
or fd_{lo,hi}maps members, or when doing a read for a write.  Fixes hangs
when an rthreaded processes sleeps while copying the fd table for fork()
and catches another thread with the lock.

ok jsing@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.88 2011/07/08 21:26:27 matthew Exp $	*/
d77 1
a77 1
int finishdup(struct proc *, struct file *, int, int, register_t *);
d228 1
a228 1
	error = finishdup(p, fp, old, new, retval);
d282 1
a282 1
	error = finishdup(p, fp, old, new, retval);
d333 1
a333 1
			error = finishdup(p, fp, fd, i, retval);
d521 2
a522 1
finishdup(struct proc *p, struct file *fp, int old, int new, register_t *retval)
d545 1
a545 1
	if (oldfp == NULL)
@


1.88
log
@Add F_DUPFD_CLOEXEC.

"Sure" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.87 2011/07/08 19:28:36 otto Exp $	*/
d325 1
a327 1
				FRELE(fp);
d331 2
a332 3
		}
		/* finishdup will FRELE for us. */
		if (!error)
a333 2
		else
			FRELE(fp);
d335 3
a337 2
		if (!error && SCARG(uap, cmd) == F_DUPFD_CLOEXEC)
			fdp->fd_ofileflags[i] |= UF_EXCLOSE;
d347 1
d352 1
d526 1
d560 1
d571 2
d756 2
d821 1
d918 1
d926 1
d967 1
d972 1
d997 1
d1212 2
d1294 1
d1298 1
@


1.87
log
@Support sending struct info to kdump. So far for struct stat and
struct sockaddress; mostly from freebsd. ok deraadt@@ tedu@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.86 2011/04/02 17:04:35 guenther Exp $	*/
d316 1
d337 3
@


1.86
log
@Move P_SUGID and P_SUGIDEXEC from struct proc to struct process, so
that you can't evade the checks by doing the dirty work in an rthread

ok blambert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.85 2010/07/26 01:56:27 guenther Exp $	*/
d62 1
d636 4
@


1.85
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.84 2010/07/19 23:00:15 guenther Exp $	*/
d1195 1
a1195 1
	if ((curproc->p_flag & (P_SUGIDEXEC | P_SUGID))) {
@


1.84
log
@Rollback the allproclk and fileheadlk addition.  When grabbing an
rwlock, the thread will release biglock if it sleeps, means that
atomicity from before the rw_enter() to after it is not guaranteed.
The change didn't address those, so pulling it until it does.

"go for it" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.83 2010/03/24 23:18:17 tedu Exp $	*/
d392 2
a393 2
			struct proc *p1 = pfind((long)SCARG(uap, arg));
			if (p1 == 0) {
d397 1
a397 1
			SCARG(uap, arg) = (void *)(long)p1->p_pgrp->pg_id;
@


1.83
log
@Add a rwlock around the filehead and allproc lists, mainly to protect
list walkers in sysctl that can block.  As a reward, no more vslock.
With some feedback from art, guenther, phessler.  ok guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.82 2009/07/09 22:29:56 thib Exp $	*/
a70 1
struct rwlock fileheadlk;
a89 1
	rw_init(&fileheadlk, "filehead");
a827 1
	rw_enter_write(&fileheadlk);
a832 1
	rw_exit_write(&fileheadlk);
a1090 1
	rw_enter_write(&fileheadlk);
a1091 1
	rw_exit_write(&fileheadlk);
@


1.82
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.80 2008/09/19 12:24:55 art Exp $	*/
d71 1
d91 1
d830 1
d836 1
d1095 1
d1097 1
@


1.81
log
@Punctuate comment for clarity, and keep tense consistent throughout

ok and improvements jmc@@
@
text
@d859 1
a859 1
		VREF(newfdp->fd_fd.fd_cdir);
d862 1
a862 1
			VREF(newfdp->fd_fd.fd_rdir);
d905 1
a905 1
		VREF(newfdp->fd_cdir);
d907 1
a907 1
		VREF(newfdp->fd_rdir);
@


1.80
log
@Fix a bunch of problems and races with posix file locking.

- file descriptor table becomes the owner of the lock instead of the proc.
- When grabbing the lock, we check if the fd hasn't changed under our
  feet, this is more or less impossible to solve without a hack like
  this. I've banged my head against the wall, I figured out a solution,
  but implementing it correctly would cost me 12 gray hairs. Screw it,
  this is ugly, but it works.
- Wait until usecount drains before releasing the posix lock in closef.
- Add missing FREF/FRELE to sys_flock
- keep the pid in the flock struct instead of abusing the fact that we
  used to use the proc as the lock owner.

Pointed out by and discussed with Al Viro, big thanks.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.79 2008/06/12 18:10:06 thib Exp $	*/
d457 2
a458 2
			 * We have lost the race with close() or dup2()
			 * unlock, pretend that we'd won the race and that
@


1.79
log
@use PR_ZERO instead of a bzero() right after the pool_get();

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.78 2008/05/06 20:57:19 thib Exp $	*/
d433 3
a435 3
			atomic_setbits_int(&p->p_flag, P_ADVLOCK);
			error = (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg));
			goto out;
d442 3
a444 3
			atomic_setbits_int(&p->p_flag, P_ADVLOCK);
			error = (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg));
			goto out;
d447 1
a447 2
			error = (VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &fl,
				F_POSIX));
d455 15
d496 1
a496 1
		error = VOP_ADVLOCK(vp, (caddr_t)p, F_GETLK, &fl, F_POSIX);
d1030 2
a1031 2
	struct vnode *vp;
	struct flock lf;
d1038 22
d1067 6
a1072 1
	if (p && (p->p_flag & P_ADVLOCK) && fp->f_type == DTYPE_VNODE) {
d1077 1
a1077 13
		vp = (struct vnode *)fp->f_data;
		(void) VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &lf, F_POSIX);
	}

	/*
	 * Some files passed to this function could be accessed
	 * without a FILE_IS_USABLE check (and in some cases it's perfectly
	 * legal), we must beware of files where someone already won the
	 * race to FIF_WANTCLOSE.
	 */
	if ((fp->f_iflags & FIF_WANTCLOSE) != 0) {
		FRELE(fp);
		return (0);
d1080 1
a1080 1
	if (--fp->f_count > 0) {
a1084 18
#ifdef DIAGNOSTIC
	if (fp->f_count < 0)
		panic("closef: count < 0");
#endif

	/* Wait for the last usecount to drain. */
	fp->f_iflags |= FIF_WANTCLOSE;
	while (fp->f_usecount > 1)
		tsleep(&fp->f_usecount, PRIBIO, "closef", 0);

	if ((fp->f_flag & FHASLOCK) && fp->f_type == DTYPE_VNODE) {
		lf.l_whence = SEEK_SET;
		lf.l_start = 0;
		lf.l_len = 0;
		lf.l_type = F_UNLCK;
		vp = (struct vnode *)fp->f_data;
		(void) VOP_ADVLOCK(vp, (caddr_t)fp, F_UNLCK, &lf, F_FLOCK);
	}
d1129 1
d1154 1
@


1.78
log
@Add a PR_ZERO flag for pools, to compliment the M_ZERO
malloc flag, does the same thing.
use it in a few places.

OK tedu@@, "then go ahead. and don't forget the manpage (-:" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.77 2007/10/29 14:12:19 chl Exp $	*/
d840 1
a840 2
	newfdp = pool_get(&fdesc_pool, PR_WAITOK);
	bzero(newfdp, sizeof(struct filedesc0));
@


1.77
log
@MALLOC/FREE -> malloc/free
replace an hard coded value with M_WAITOK

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.76 2007/03/15 10:22:30 art Exp $	*/
d812 1
a812 2
	fp = pool_get(&file_pool, PR_WAITOK);
	bzero(fp, sizeof(struct file));
@


1.76
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.75 2006/11/14 18:00:27 jmc Exp $	*/
d1001 1
a1001 1
		FREE(fdp->fd_knlist, M_TEMP);
d1003 1
a1003 1
		FREE(fdp->fd_knhash, M_TEMP);
@


1.75
log
@grammar, spelling, and style fixes from bret lambert;
kern_descrip.c change ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.74 2006/05/07 20:12:41 tedu Exp $	*/
d433 1
a433 1
			p->p_flag |= P_ADVLOCK;
d442 1
a442 1
			p->p_flag |= P_ADVLOCK;
@


1.74
log
@add a name to rwlock so that we can tell where procs are getting stuck
without breaking into ddb.  doubles the size of rwlock [1], but moving
forward this really helps.  ok/tested pedro fgsch millert krw
[1 - next person to add a field to this struct gets whipped with a wet noodle]
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.73 2006/01/06 18:28:33 jmc Exp $	*/
d612 4
a615 2
		/* Don't let non-root see generation numbers
		   (for NFS security) */
@


1.73
log
@typo fix from ray lai;
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.72 2005/12/07 19:04:53 deraadt Exp $	*/
d850 1
a850 1
	rw_init(&newfdp->fd_fd.fd_lock);
@


1.72
log
@do not allow setugid processes to use /dev/fd/#, unless they are a
setuid-script and are attempting to dup is the specific setuid-script
fd via such a pathname; ok tedu pedro millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.71 2005/11/28 00:14:28 jsg Exp $	*/
d1180 1
a1180 1
	 * not tend to opens of /dev/fd/# when they can just call dup()
@


1.71
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.70 2005/07/03 01:07:44 jaredy Exp $	*/
d1177 11
@


1.70
log
@change VOP_PATHCONF to take a locked vnode, as its
comment entry describes.  requires that sys_fpathconf()
lock its vnode.

lots of testing by jolan and myself, ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.69 2004/07/22 06:13:08 tedu Exp $	*/
d83 1
a83 1
filedesc_init()
d147 1
a147 3
fd_used(fdp, fd)
	register struct filedesc *fdp;
	register int fd;
d160 1
a160 3
fd_unused(fdp, fd)
	register struct filedesc *fdp;
	register int fd;
d180 1
a180 3
fd_getfile(fdp, fd)
	struct filedesc *fdp;
	int fd;
d202 1
a202 4
sys_dup(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d239 1
a239 4
sys_dup2(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d293 1
a293 4
sys_fcntl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d538 1
a538 3
fdremove(fdp, fd)
	struct filedesc *fdp;
	int fd;
d545 1
a545 3
fdrelease(p, fd)
	struct proc *p;
	int fd;
d572 1
a572 4
sys_close(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d594 1
a594 4
sys_fstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d627 1
a627 4
sys_fpathconf(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d672 1
a672 4
fdalloc(p, want, result)
	struct proc *p;
	int want;
	int *result;
d719 1
a719 2
fdexpand(p)
	struct proc *p;
d785 1
a785 4
falloc(p, resultfp, resultfd)
	register struct proc *p;
	struct file **resultfp;
	int *resultfd;
d787 1
a787 1
	register struct file *fp, *fq;
d872 1
a872 2
fdshare(p)
	struct proc *p;
d882 1
a882 2
fdcopy(p)
	struct proc *p;
d970 1
a970 2
fdfree(p)
	struct proc *p;
d972 3
a974 3
	register struct filedesc *fdp = p->p_fd;
	register struct file **fpp, *fp;
	register int i;
d1100 1
a1100 4
sys_flock(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1155 1
a1155 4
filedescopen(dev, mode, type, p)
	dev_t dev;
	int mode, type;
	struct proc *p;
d1174 1
a1174 5
dupfdopen(fdp, indx, dfd, mode, error)
	struct filedesc *fdp;
	int indx, dfd;
	int mode;
	int error;
d1242 1
a1242 2
fdcloseexec(p)
	struct proc *p;
d1244 2
a1245 2
	register struct filedesc *fdp = p->p_fd;
	register int fd;
@


1.70.2.1
log
@MFC:
Fix by deraadt@@

do not allow setugid processes to use /dev/fd/#, unless they are a
setuid-script and are attempting to dup is the specific setuid-script
fd via such a pathname;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.70 2005/07/03 01:07:44 jaredy Exp $	*/
a1224 11

	/*
	 * Assume that the filename was user-specified; applications do
	 * not tend to opens of /dev/fd/# when they can just call dup()
	 */
	if ((curproc->p_flag & (P_SUGIDEXEC | P_SUGID))) {
		if (curproc->p_descfd == 255)
			return (EPERM);
		if (curproc->p_descfd != curproc->p_dupfd)
			return (EPERM);
	}
@


1.69
log
@remove p arg from fdplock
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.68 2004/01/12 18:06:51 tedu Exp $	*/
d683 1
d685 1
@


1.69.4.1
log
@MFC:
Fix by deraadt@@

do not allow setugid processes to use /dev/fd/#, unless they are a
setuid-script and are attempting to dup is the specific setuid-script
fd via such a pathname;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.69 2004/07/22 06:13:08 tedu Exp $	*/
a1222 11

	/*
	 * Assume that the filename was user-specified; applications do
	 * not tend to opens of /dev/fd/# when they can just call dup()
	 */
	if ((curproc->p_flag & (P_SUGIDEXEC | P_SUGID))) {
		if (curproc->p_descfd == 255)
			return (EPERM);
		if (curproc->p_descfd != curproc->p_dupfd)
			return (EPERM);
	}
@


1.68
log
@new syscall closefrom(int fd) closes all fds equal and greater than fd.
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.67 2004/01/06 04:18:18 tedu Exp $	*/
d226 1
a226 1
	fdplock(fdp, p);
d278 1
a278 1
	fdplock(fdp, p);
d336 1
a336 1
		fdplock(fdp, p);
d604 1
a604 1
	fdplock(fdp, p);
d1307 1
a1307 1
	fdplock(fdp, p);
@


1.67
log
@lock filedesc before manipulating.  avoids some rare races.
testing for quite some time by brad + otto
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.66 2003/12/02 01:40:18 millert Exp $	*/
d1297 22
@


1.66
log
@Check array index before using it; from Tim Robbins via Niels.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.65 2003/08/15 20:32:18 tedu Exp $	*/
d226 1
d231 1
d234 1
a234 1
		return (error);
d236 5
a240 1
	return (finishdup(p, fp, old, new, retval));
d278 1
d284 1
d287 1
a287 1
			return (error);
d293 5
a297 1
	return (finishdup(p, fp, old, new, retval));
d336 1
d341 1
a343 1
			break;
d346 7
a352 1
		return (finishdup(p, fp, fd, i, retval));
d599 1
a599 1
	int fd = SCARG(uap, fd);
d604 5
a608 1
	return (fdrelease(p, fd));
a757 7
	 * If it's already expanding just wait for that expansion to finish
	 * and return and let the caller retry the operation.
	 */
	if (lockmgr(&fdp->fd_lock, LK_EXCLUSIVE|LK_SLEEPFAIL, NULL, p))
		return;

	/*
a807 2

	lockmgr(&fdp->fd_lock, LK_RELEASE, NULL, p);
d883 1
a883 1
	lockinit(&newfdp->fd_fd.fd_lock, PLOCK, "fdexpand", 0, 0);
@


1.65
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.64 2003/08/06 20:37:38 millert Exp $	*/
d132 1
a132 1
	while (!bitmap[off] && off >= 0)
@


1.64
log
@Remove unreachable return statement after break; Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.63 2003/06/02 23:28:05 millert Exp $	*/
d616 1
a616 1
		if (suser(p->p_ucred, &p->p_acflag))
@


1.63
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.62 2002/11/22 13:40:06 art Exp $	*/
a656 1
		return (0);
@


1.62
log
@Allow fdinit to be called with p == NULL so that we can use
it to properly init filedescs for proc0.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.61 2002/11/08 18:38:00 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.61
log
@finishdup: Avoid reference count leak in error case by reordering some code.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.60 2002/10/15 01:27:31 nordin Exp $	*/
d858 1
a858 2
fdinit(p)
	struct proc *p;
d860 1
a860 2
	register struct filedesc0 *newfdp;
	register struct filedesc *fdp = p->p_fd;
d865 9
a873 5
	newfdp->fd_fd.fd_cdir = fdp->fd_cdir;
	VREF(newfdp->fd_fd.fd_cdir);
	newfdp->fd_fd.fd_rdir = fdp->fd_rdir;
	if (newfdp->fd_fd.fd_rdir)
		VREF(newfdp->fd_fd.fd_rdir);
@


1.60
log
@Match reality by changing (u_int) -> (int) in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.59 2002/08/23 00:56:04 pvalchev Exp $	*/
d507 5
a519 4
	if (fp->f_count == LONG_MAX-2) {
		FRELE(fp);
		return (EDEADLK);
	}
@


1.59
log
@Add missing FRELE() in finishdup() error case; ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.58 2002/06/03 12:04:08 deraadt Exp $	*/
d218 1
a218 1
		syscallarg(u_int) fd;
d252 2
a253 2
		syscallarg(u_int) from;
		syscallarg(u_int) to;
@


1.58
log
@compatiblity -> compatibility
decriptor -> descriptor
authentciated -> authenticated
transmition -> transmission
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.57 2002/05/23 14:25:20 art Exp $	*/
d288 1
d515 2
a516 1
	if (fp->f_count == LONG_MAX-2)
d518 1
@


1.57
log
@Fix a comment I missed when renaming FILE_UNUSE to FRELE.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.56 2002/03/14 01:27:04 millert Exp $	*/
d799 1
a799 1
 * a file decriptor for the process that refers to it.
@


1.56
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.55 2002/02/19 06:12:13 nordin Exp $	*/
d1032 1
a1032 1
 * The fp must have its usecount bumped and will be FILE_UNUSEd here.
@


1.55
log
@Missing FRELE in error case. ok provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.54 2002/02/18 23:12:04 ericj Exp $	*/
d77 3
a79 3
static __inline void fd_used __P((struct filedesc *, int));
static __inline void fd_unused __P((struct filedesc *, int));
static __inline int find_next_zero __P((u_int *, int, u_int));
d81 1
a81 1
int find_last_set __P((struct filedesc *, int));
@


1.54
log
@
fix issue on LP64 BE arch's w/ fcntl's F_GETOWN
pointed out by der Mouse <mouse@@Rodents.Montreal.QC.CA>
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.53 2002/02/13 19:08:06 art Exp $	*/
d231 1
@


1.53
log
@More FREF/FRELE on relevant places. Now, only sys_mmap and a bunch of ioctl functions in sys/compat are left.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.52 2002/02/09 00:27:49 art Exp $	*/
d374 2
a375 2
			(fp, TIOCGPGRP, (caddr_t)retval, p);
		*retval = -*retval;
@


1.52
log
@Protect the whole sys_fnctl with one big FREF/FRELE pair.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.51 2002/02/08 18:43:54 art Exp $	*/
d580 1
a580 1
	register struct filedesc *fdp = p->p_fd;
d609 1
d611 1
d633 1
a633 1
	register struct sys_fpathconf_args /* {
d641 1
d645 1
d649 4
a652 2
		if (SCARG(uap, name) != _PC_PIPE_BUF)
			return (EINVAL);
d654 2
d660 2
a661 1
		return (VOP_PATHCONF(vp, SCARG(uap, name), retval));
d664 2
a665 1
		return (EOPNOTSUPP);
d667 2
a668 1
	/*NOTREACHED*/
d1125 1
a1125 1
	register struct sys_flock_args /* {
d1131 2
a1132 2
	register struct filedesc *fdp = p->p_fd;
	register struct file *fp;
d1135 1
d1148 2
a1149 1
		return (VOP_ADVLOCK(vp, (caddr_t)fp, F_UNLCK, &lf, F_FLOCK));
d1155 4
a1158 2
	else
		return (EINVAL);
d1161 5
a1165 2
		return (VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, F_FLOCK));
	return (VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, F_FLOCK|F_WAIT));
@


1.51
log
@Add a comment about an obscure behavior in dup2(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.50 2002/02/08 18:29:08 art Exp $	*/
d316 1
a325 1
		FREF(fp);
d329 1
d334 1
d492 1
@


1.50
log
@Add a slightly redundant arg to finishdup that's the struct file *
present on the 'old' descriptor. It's not really necessary because
we can easily find it with 'fp = p->p_fd->fd_ofiles[old];', but this
allows us to require that the fp is FREFed without violating all rules
of good taste and all callers have to do fd_getfile on it anyway (to
detect larval and closing files.

FREF the fp in all callers.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.49 2002/02/08 16:32:27 art Exp $	*/
d266 5
@


1.49
log
@No more need for ffree. Since it's hard to use it safely, remove it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.48 2002/02/08 13:53:28 art Exp $	*/
d80 1
a80 1
int finishdup __P((struct proc *, int, int, register_t *));
d220 3
a222 2
	register struct filedesc *fdp = p->p_fd;
	register int old = SCARG(uap, fd);
d227 1
a227 1
	if (fd_getfile(fdp, old) == NULL)
d229 1
d237 1
a237 1
	return (finishdup(p, old, new, retval));
d254 1
d256 1
a256 1
	int old = SCARG(uap, from), new = SCARG(uap, to);
d260 1
a260 1
	if (fd_getfile(fdp, old) == NULL)
d269 1
d272 1
d282 1
a282 1
	return (finishdup(p, old, new, retval));
d320 1
d328 1
a328 1
		return (finishdup(p, fd, i, retval));
d492 1
a492 4
finishdup(p, old, new, retval)
	struct proc *p;
	int old, new;
	register_t *retval;
d494 1
a494 1
	struct file *fp, *oldfp;
a504 1
	fp = fdp->fd_ofiles[old];
d510 1
@


1.48
log
@- Rename FILE_{,UN}USE to FREF and FRELE. USE is a bad verb and we don't have
  the same semantics as NetBSD anyway, so it's good to avoid name collissions.
- Always fdremove before freeing the file, not the other way around.
- falloc FREFs the file.
- have FILE_SET_MATURE FRELE the file (It feels like a good ortogonality to
  falloc FREFing the file).
- Use closef as much as possible instead of ffree in error paths of
  falloc:ing functions. closef is much more careful with the fd and can
  deal with the fd being forcibly closed by dup2. Also try to avoid
  manually calling *fo_close when closef can do that for us (this makes
  some error paths mroe complicated (sys_socketpair and sys_pipe), but
  others become simpler (sys_open)).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.47 2002/02/05 16:02:27 art Exp $	*/
a827 18
 * Free a file descriptor.
 */
void
ffree(fp)
	register struct file *fp;
{
	LIST_REMOVE(fp, f_list);
	crfree(fp->f_cred);
#ifdef DIAGNOSTIC
	fp->f_count = 0;
	if (fp->f_usecount != 0)
		panic("ffree: usecount != 0");
#endif
	nfiles--;
	pool_put(&file_pool, fp);
}

/*
d1076 11
a1086 2
	fp->f_usecount--;
	ffree(fp);
@


1.47
log
@Add counting of temporary references to a struct file (as opposed to references
from fd tables and other long-lived objects). This is to avoid races between
using a file descriptor and having another process (with shared fd table)
close it. We use a separate refence count so that error values from close(2)
will be correctly returned to the caller of close(2).

The macros for those reference counts are FILE_USE(fp) and FILE_UNUSE(fp).

Make sure that the cases where closef can be called "incorrectly" (most notably
dup2(2)) are handled.

Right now only callers of closef (and {,p}read) use FILE_{,UN}USE correctly,
more fixes incoming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.46 2002/02/04 11:48:22 art Exp $	*/
d500 1
a500 1
		FILE_USE(oldfp);
d546 1
a546 1
	FILE_USE(fp);
d823 1
d998 1
a998 1
			FILE_USE(fp);
d1063 1
a1063 1
		FILE_UNUSE(fp);
d1068 1
a1068 1
		FILE_UNUSE(fp);
@


1.46
log
@Add some comments documenting why we use fd_ofiles instead
of fd_getfile in some places.

Also, get rid of the check for old == new in dupfdopen and document why
the semantics of fd_getfile make it unnecessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.45 2002/02/02 17:52:27 art Exp $	*/
d499 2
d546 1
d837 2
d997 1
d1025 2
d1029 1
a1029 3
closef(fp, p)
	register struct file *fp;
	register struct proc *p;
d1037 1
d1054 14
a1067 1
	if (--fp->f_count > 0)
d1069 3
d1074 7
d1093 1
@


1.45
log
@Reorganize sys_fcntl to make future changes easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.44 2002/01/23 00:39:47 art Exp $	*/
d494 4
d536 4
d1149 2
a1150 2
	register struct filedesc *fdp;
	register int indx, dfd;
d1154 1
a1154 2
	register struct file *wfp;
	struct file *fp;
d1159 3
a1161 3
	 * closed, reject.  Note, check for new == old is necessary as
	 * falloc could allocate an already closed to-be-dup'd descriptor
	 * as the new descriptor.
a1162 1
	fp = fdp->fd_ofiles[indx];
a1163 3
		return (EBADF);

	if (fp == wfp)
@


1.44
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.43 2001/11/15 13:07:53 niklas Exp $	*/
d299 1
a299 1
	int i, tmp, error, flg = F_POSIX;
d301 1
a301 1
	int newmin;
d311 4
a314 2
		    (u_int)newmin >= maxfiles)
			return (EINVAL);
d320 1
a320 1
			return (error);
d326 1
a326 1
		return (0);
d333 1
a333 1
		return (0);
d337 1
a337 1
		return (0);
d345 1
a345 1
			return (error);
d349 1
a349 1
			return (0);
d353 1
a353 1
		return (error);
d358 1
a358 1
			return (0);
d363 1
a363 1
		return (error);
d372 1
a372 1
			return (0);
d378 4
a381 2
			if (p1 == 0)
				return (ESRCH);
d384 1
a384 1
		return ((*fp->f_ops->fo_ioctl)
d386 1
d393 4
a396 2
		if (fp->f_type != DTYPE_VNODE)
			return (EBADF);
d402 1
a402 1
			return (error);
d414 4
a417 2
			if ((fp->f_flag & FREAD) == 0)
				return (EBADF);
d419 2
a420 1
			return (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg));
d423 4
a426 2
			if ((fp->f_flag & FWRITE) == 0)
				return (EBADF);
d428 2
a429 1
			return (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg));
d432 1
a432 1
			return (VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &fl,
d434 1
d437 2
a438 1
			return (EINVAL);
d442 4
a445 2
		if (fp->f_type != DTYPE_VNODE)
			return (EBADF);
d451 1
a451 1
			return (error);
d463 4
a466 2
		    fl.l_type != 0)
			return (EINVAL);
d469 2
a470 2
			return (error);
		return (copyout((caddr_t)&fl, (caddr_t)SCARG(uap, arg),
d472 1
d475 2
a476 1
		return (EINVAL);
d478 2
a479 1
	/* NOTREACHED */
@


1.43
log
@Initialize list
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.42 2001/11/06 19:53:20 miod Exp $	*/
d90 1
a90 1
		0, pool_page_alloc_nointr, pool_page_free_nointr, M_PROC);
d92 1
a92 1
		0, pool_page_alloc_nointr, pool_page_free_nointr, M_FILEDESC);
@


1.43.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.44 2002/01/23 00:39:47 art Exp $	*/
d90 1
a90 1
		&pool_allocator_nointr);
d92 1
a92 1
		&pool_allocator_nointr);
@


1.43.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.43.2.1 2002/01/31 22:55:40 niklas Exp $	*/
d77 5
a81 5
static __inline void fd_used(struct filedesc *, int);
static __inline void fd_unused(struct filedesc *, int);
static __inline int find_next_zero(u_int *, int, u_int);
int finishdup(struct proc *, struct file *, int, int, register_t *);
int find_last_set(struct filedesc *, int);
d220 2
a221 3
	struct filedesc *fdp = p->p_fd;
	int old = SCARG(uap, fd);
	struct file *fp;
d226 1
a226 1
	if ((fp = fd_getfile(fdp, old)) == NULL)
a227 1
	FREF(fp);
a228 1
		FRELE(fp);
d235 1
a235 1
	return (finishdup(p, fp, old, new, retval));
d252 1
a253 2
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
d257 1
a257 1
	if ((fp = fd_getfile(fdp, old)) == NULL)
a262 5
		/*
		 * NOTE! This doesn't clear the close-on-exec flag. This might
		 * or might not be the intended behavior from the start, but
		 * this is what everyone else does.
		 */
a265 1
	FREF(fp);
a267 1
			FRELE(fp);
d277 1
a277 1
	return (finishdup(p, fp, old, new, retval));
d299 1
a299 1
	int i, tmp, newmin, flg = F_POSIX;
d301 1
a301 1
	int error = 0;
a305 1
	FREF(fp);
d311 2
a312 4
		    (u_int)newmin >= maxfiles) {
			error = EINVAL;
			break;
		}
a315 1
				FRELE(fp);
d318 1
a318 1
			break;
d320 1
a320 2
		/* finishdup will FRELE for us. */
		return (finishdup(p, fp, fd, i, retval));
d324 1
a324 1
		break;
d331 1
a331 1
		break;
d335 1
a335 1
		break;
d343 1
a343 1
			break;
d347 1
a347 1
			break;
d351 1
a351 1
		break;
d356 1
a356 1
			break;
d359 3
a361 3
			(fp, TIOCGPGRP, (caddr_t)&tmp, p);
		*retval = -tmp;
		break;
d370 1
a370 1
			break;
d376 2
a377 4
			if (p1 == 0) {
				error = ESRCH;
				break;
			}
d380 1
a380 1
		error = ((*fp->f_ops->fo_ioctl)
a381 1
		break;
d388 2
a389 4
		if (fp->f_type != DTYPE_VNODE) {
			error = EBADF;
			break;
		}
d395 1
a395 1
			break;
d407 2
a408 4
			if ((fp->f_flag & FREAD) == 0) {
				error = EBADF;
				goto out;
			}
d410 1
a410 2
			error = (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg));
			goto out;
d413 2
a414 4
			if ((fp->f_flag & FWRITE) == 0) {
				error = EBADF;
				goto out;
			}
d416 1
a416 2
			error = (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg));
			goto out;
d419 1
a419 1
			error = (VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &fl,
a420 1
			goto out;
d423 1
a423 2
			error = EINVAL;
			goto out;
d427 2
a428 4
		if (fp->f_type != DTYPE_VNODE) {
			error = EBADF;
			break;
		}
d434 1
a434 1
			break;
d446 2
a447 4
		    fl.l_type != 0) {
			error = EINVAL;
			break;
		}
d450 2
a451 2
			break;
		error = (copyout((caddr_t)&fl, (caddr_t)SCARG(uap, arg),
a452 1
		break;
d455 1
a455 2
		error = EINVAL;
		break;
d457 1
a457 3
out:
	FRELE(fp);
	return (error);	
d464 4
a467 1
finishdup(struct proc *p, struct file *fp, int old, int new, register_t *retval)
d469 1
a469 1
	struct file *oldfp;
a471 4
	/*
	 * Don't fd_getfile here. We want to closef LARVAL files and
	 * closef can deal with that.
	 */
a472 2
	if (oldfp != NULL)
		FREF(oldfp);
d474 1
a479 1
	FRELE(fp);
a509 4
	/*
	 * Don't fd_getfile here. We want to closef LARVAL files and closef
	 * can deal with that.
	 */
a513 1
	FREF(fp);
d536 1
a536 1
	struct filedesc *fdp = p->p_fd;
a564 1
	FREF(fp);
a565 1
	FRELE(fp);
d587 1
a587 1
	struct sys_fpathconf_args /* {
a594 1
	int error;
a597 1
	FREF(fp);
d601 2
a602 4
		if (SCARG(uap, name) != _PC_PIPE_BUF) {
			error = EINVAL;
			break;
		}
a603 2
		error = 0;
		break;
d608 1
a608 2
		error = VOP_PATHCONF(vp, SCARG(uap, name), retval);
		break;
d611 1
a611 2
		error = EOPNOTSUPP;
		break;
d613 1
a613 2
	FRELE(fp);
	return (error);
d743 1
a743 1
 * a file descriptor for the process that refers to it.
a789 1
	FREF(fp);
d794 16
a961 1
			FREF(fp);
a988 2
 *
 * The fp must have its usecount bumped and will be FRELEd here.
d991 3
a993 1
closef(struct file *fp, struct proc *p)
a1000 1

d1017 1
a1017 14

	/*
	 * Some files passed to this function could be accessed
	 * without a FILE_IS_USABLE check (and in some cases it's perfectly
	 * legal), we must beware of files where someone already won the
	 * race to FIF_WANTCLOSE.
	 */
	if ((fp->f_iflags & FIF_WANTCLOSE) != 0) {
		FRELE(fp);
		return (0);
	}

	if (--fp->f_count > 0) {
		FRELE(fp);
a1018 3
	}

#ifdef DIAGNOSTIC
a1020 7
#endif

	/* Wait for the last usecount to drain. */
	fp->f_iflags |= FIF_WANTCLOSE;
	while (fp->f_usecount > 1)
		tsleep(&fp->f_usecount, PRIBIO, "closef", 0);

d1033 1
a1033 11

	/* Free fp */
	LIST_REMOVE(fp, f_list);
	crfree(fp->f_cred);
#ifdef DIAGNOSTIC
	if (fp->f_count != 0 || fp->f_usecount != 1)
		panic("closef: count: %d/%d", fp->f_count, fp->f_usecount);
#endif
	nfiles--;
	pool_put(&file_pool, fp);

d1050 1
a1050 1
	struct sys_flock_args /* {
d1056 2
a1057 2
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
a1059 1
	int error;
d1072 1
a1072 2
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_UNLCK, &lf, F_FLOCK);
		goto out;
d1078 2
a1079 4
	else {
		error = EINVAL;
		goto out;
	}
d1082 2
a1083 5
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, F_FLOCK);
	else
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, F_FLOCK|F_WAIT);
out:
	return (error);
d1119 2
a1120 2
	struct filedesc *fdp;
	int indx, dfd;
d1124 2
a1125 1
	struct file *wfp;
d1130 3
a1132 3
	 * closed, reject. Note, there is no need to check for new == old
	 * because fd_getfile will return NULL if the file at indx is
	 * newly created by falloc (FIF_LARVAL).
d1134 1
d1136 3
@


1.43.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.43.2.2 2002/06/11 03:29:40 art Exp $	*/
d218 1
a218 1
		syscallarg(int) fd;
d252 2
a253 2
		syscallarg(int) from;
		syscallarg(int) to;
a287 1
	/* finishdup() does FRELE */
d514 1
a514 2
	if (fp->f_count == LONG_MAX-2) {
		FRELE(fp);
a515 1
	}
@


1.43.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a506 5
	if (fp->f_count == LONG_MAX-2) {
		FRELE(fp);
		return (EDEADLK);
	}

d515 4
d857 2
a858 1
fdinit(struct proc *p)
d860 2
a861 1
	struct filedesc0 *newfdp;
d866 5
a870 9
	if (p != NULL) {
		struct filedesc *fdp = p->p_fd;

		newfdp->fd_fd.fd_cdir = fdp->fd_cdir;
		VREF(newfdp->fd_fd.fd_cdir);
		newfdp->fd_fd.fd_rdir = fdp->fd_rdir;
		if (newfdp->fd_fd.fd_rdir)
			VREF(newfdp->fd_fd.fd_rdir);
	}
@


1.42
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.41 2001/11/05 02:03:58 art Exp $	*/
d93 1
@


1.41
log
@let finishdup take the proc as arguemnt instead of the filedesc.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.40 2001/10/26 12:03:27 art Exp $	*/
d67 1
a67 1
#include <vm/vm.h>
@


1.40
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.39 2001/10/26 10:39:31 art Exp $	*/
d80 1
a80 1
int finishdup __P((struct filedesc *, int, int, register_t *));
d234 1
a234 1
	return (finishdup(fdp, old, new, retval));
d276 1
a276 1
	return (finishdup(fdp, old, new, retval));
d319 1
a319 1
		return (finishdup(fdp, fd, i, retval));
a460 2
 *
 * XXX - should take a proc as an argument.
d463 3
a465 3
finishdup(fdp, old, new, retval)
	register struct filedesc *fdp;
	register int old, new;
d469 1
d485 2
a486 2
			knote_fdclose(curproc, new);
		closef(oldfp, curproc);
@


1.39
log
@ - split fdalloc into two functions. fdalloc now returns ENOSPC if it
   would have to grow the table and fdexpand that grows the table. Since
   fdexpand can sleep we have to restart all operations if we have to call
   it.
 - dup2 changed so that finishdup frees the destination descriptor.
 - unp_externalize is a completly rewritten version from NetBSD.

Changes mostly inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.38 2001/10/07 23:12:06 art Exp $	*/
d186 16
d225 1
a225 1
	if ((u_int)old >= fdp->fd_nfiles || fdp->fd_ofiles[old] == NULL)
d256 3
a258 2
	if ((u_int)old >= fdp->fd_nfiles || fdp->fd_ofiles[old] == NULL ||
	    (u_int)new >= p->p_rlimit[RLIMIT_NOFILE].rlim_cur ||
d303 1
a303 2
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL)
d538 1
a538 1
	if ((u_int)fd >= fdp->fd_nfiles)
d563 1
a563 2
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL)
d596 1
a596 2
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL)
a741 23
 * Check to see whether n user file descriptors
 * are available to the process p.
 */
int
fdavail(p, n)
	struct proc *p;
	register int n;
{
	register struct filedesc *fdp = p->p_fd;
	register struct file **fpp;
	register int i, lim;

	lim = min((int)p->p_rlimit[RLIMIT_NOFILE].rlim_cur, maxfiles);
	if ((i = lim - fdp->fd_nfiles) > 0 && (n -= i) <= 0)
		return (1);
	fpp = &fdp->fd_ofiles[fdp->fd_freefile];
	for (i = min(lim, fdp->fd_nfiles) - fdp->fd_freefile; --i >= 0; fpp++)
		if (*fpp == NULL && --n <= 0)
			return (1);
	return (0);
}

/*
d776 1
d1061 1
a1061 2
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL)
d1135 4
a1138 2
	if ((u_int)dfd >= fdp->fd_nfiles ||
	    (wfp = fdp->fd_ofiles[dfd]) == NULL || fp == wfp)
@


1.38
log
@Clean up fdrelease.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.37 2001/10/07 22:42:07 art Exp $	*/
d208 1
d211 5
a215 1
	if ((error = fdalloc(p, 0, &new)) != 0)
d217 1
d239 1
d249 5
a253 1
		if ((error = fdalloc(p, new, &i)) != 0)
d255 1
a257 2
	} else {
		(void) fdrelease(p, new);
d285 1
d296 5
a300 1
		if ((error = fdalloc(p, newmin, &i)) != 0)
d302 1
d445 2
d454 3
a456 1
	register struct file *fp;
d462 1
a462 1
	fdp->fd_ofileflags[new] = fdp->fd_ofileflags[old] &~ UF_EXCLOSE;
d464 2
a465 1
	fd_used(fdp, new);
d467 7
a604 2
int fdexpand;

d611 3
a613 6
	register struct filedesc *fdp = p->p_fd;
	register int i;
	int lim, last, nfiles;
	struct file **newofile;
	char *newofileflags;
	u_int *newhimap, *newlomap, new, off;
d620 1
d622 25
a646 26
	for (;;) {
		last = min(fdp->fd_nfiles, lim);
		if ((i = want) < fdp->fd_freefile)
			i = fdp->fd_freefile;
		off = i >> NDENTRYSHIFT;
		new = find_next_zero(fdp->fd_himap, off,
		    (last + NDENTRIES - 1) >> NDENTRYSHIFT);
		if (new != -1) {
			i = find_next_zero(&fdp->fd_lomap[new], 
					   new > off ? 0 : i & NDENTRYMASK,
					   NDENTRIES);
			if (i == -1) {
				/* free file descriptor in this block was
				 * below want, try again with higher want.
				 */
				want = (new + 1) << NDENTRYSHIFT;
				continue;
			}
			i += (new << NDENTRYSHIFT);
			if (i < last) {
				fd_used(fdp, i);
				if (want <= fdp->fd_freefile)
					fdp->fd_freefile = i;
				*result = i;
				return (0);
			}
d648 3
d652 64
a715 49
		/*
		 * No space in current array.  Expand?
		 */
		if (fdp->fd_nfiles >= lim)
			return (EMFILE);
		if (fdp->fd_nfiles < NDEXTENT)
			nfiles = NDEXTENT;
		else
			nfiles = 2 * fdp->fd_nfiles;
		nfiles = min(lim, nfiles);
		newofile = malloc(nfiles * OFILESIZE, M_FILEDESC, M_WAITOK);
		newofileflags = (char *) &newofile[nfiles];

		/*
		 * Copy the existing ofile and ofileflags arrays
		 * and zero the new portion of each array.
		 */
		bcopy(fdp->fd_ofiles, newofile,
			(i = sizeof(struct file *) * fdp->fd_nfiles));
		bzero((char *)newofile + i, nfiles * sizeof(struct file *) - i);
		bcopy(fdp->fd_ofileflags, newofileflags,
			(i = sizeof(char) * fdp->fd_nfiles));
		bzero(newofileflags + i, nfiles * sizeof(char) - i);

		if (fdp->fd_nfiles > NDFILE)
			free(fdp->fd_ofiles, M_FILEDESC);

		if (NDHISLOTS(nfiles) > NDHISLOTS(fdp->fd_nfiles)) {
			newhimap = malloc(NDHISLOTS(nfiles) * sizeof(u_int),
			    M_FILEDESC, M_WAITOK);
			newlomap = malloc( NDLOSLOTS(nfiles) * sizeof(u_int),
			    M_FILEDESC, M_WAITOK);

			bcopy(fdp->fd_himap, newhimap,
			    (i = NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int)));
			bzero((char *)newhimap + i,
			    NDHISLOTS(nfiles) * sizeof(u_int) - i);

			bcopy(fdp->fd_lomap, newlomap,
			    (i = NDLOSLOTS(fdp->fd_nfiles) * sizeof(u_int)));
			bzero((char *)newlomap + i,
			    NDLOSLOTS(nfiles) * sizeof(u_int) - i);

			if (NDHISLOTS(fdp->fd_nfiles) > NDHISLOTS(NDFILE)) {
				free(fdp->fd_himap, M_FILEDESC);
				free(fdp->fd_lomap, M_FILEDESC);
			}
			fdp->fd_himap = newhimap;
			fdp->fd_lomap = newlomap;
d717 2
a718 4
		fdp->fd_ofiles = newofile;
		fdp->fd_ofileflags = newofileflags;
		fdp->fd_nfiles = nfiles;
		fdexpand++;
d720 5
d763 6
a768 1
	if ((error = fdalloc(p, 0, &i)) != 0)
d770 1
d835 1
@


1.37
log
@gc UF_MAPPED.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.36 2001/10/01 16:55:57 gluk Exp $	*/
d463 2
a464 3
	register struct filedesc *fdp = p->p_fd;
	register struct file **fpp, *fp;
	register char *pf;
a469 1
	pf = &fdp->fd_ofileflags[fd];
d471 1
a471 1
	*pf = 0;
@


1.36
log
@Avoid panic when unconfiguring raid device which was autoconfigured and
so has fdp->fd_cdir = NULL.

From Tertou <TDeval@@PrimeOBJ.COM>
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.35 2001/09/29 20:10:43 gluk Exp $	*/
a471 4
	if (*pf & UF_MAPPED) {
		/* XXX: USELESS? XXXCDC check it */
		p->p_fd->fd_ofileflags[fd] &= ~UF_MAPPED;
	}
@


1.35
log
@Avoid panic at time of raid autoconfiguration. Raid kernel thread starts
when root filesystem isn't configured yet and some kernel variables can't
be initialized.

From Thierry Deval <TDeval@@PrimeOBJ.COM>
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.34 2001/07/28 17:12:12 gluk Exp $	*/
d936 2
a937 1
	vrele(fdp->fd_cdir);
@


1.34
log
@Allow negative lock length in case of lockf(3). This makes lockf(3)
compliant to specification.
costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.33 2001/07/25 16:03:14 art Exp $	*/
d832 2
a833 1
	VREF(newfdp->fd_cdir);
@


1.33
log
@Random cleanups that generate noise in my cvs updates.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.32 2001/06/27 04:49:41 art Exp $	*/
d352 1
a352 1
		/* Fall into F_SETLK */
d363 8
a370 2
		if (fl.l_whence == SEEK_CUR)
			fl.l_start += fp->f_offset;
d402 8
a409 8
		if (fl.l_whence == SEEK_CUR)
			fl.l_start += fp->f_offset;
		else if (fl.l_whence != SEEK_END &&
			 fl.l_whence != SEEK_SET &&
			 fl.l_whence != 0)
			return (EINVAL);
		if (fl.l_start < 0)
			return (EINVAL);
@


1.32
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.31 2001/06/22 14:14:08 deraadt Exp $	*/
d229 2
a230 2
	register struct filedesc *fdp = p->p_fd;
	register int old = SCARG(uap, from), new = SCARG(uap, to);
d262 1
a262 1
	register struct sys_fcntl_args /* {
d268 2
a269 2
	register struct filedesc *fdp = p->p_fd;
	register struct file *fp;
@


1.31
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.30 2001/05/23 14:50:15 art Exp $	*/
a465 1
#if defined(UVM)
a469 4
#else
	if (*pf & UF_MAPPED)
		(void) munmapfd(p, fd);
#endif
@


1.30
log
@Don't panic on kqueues and crypto descriptors in fpathconf.
Just return EOPNOTSUPP.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.29 2001/05/16 12:49:45 art Exp $	*/
d98 1
a98 1
        int i, off, maxoff;
d101 2
a102 2
        if (want > bits)
                return -1;
d106 1
a106 1
        if (i) {
d111 1
a111 1
        }
d114 3
a116 3
        while (off < maxoff) {
                if ((sub = bitmap[off]) != ~0)
                        goto found;
d118 1
a118 1
        }
d120 1
a120 1
        return -1;
d123 1
a123 1
        return (off << NDENTRYSHIFT) + ffs(~sub) - 1;
a136 1

d139 1
a139 1
	
a145 1

d609 1
a609 1
				     (last + NDENTRIES - 1) >> NDENTRYSHIFT);
d660 1
a660 1
			       M_FILEDESC, M_WAITOK);
d662 1
a662 1
			       M_FILEDESC, M_WAITOK);
d665 1
a665 1
			      (i = NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int)));
d667 1
a667 1
			      NDHISLOTS(nfiles) * sizeof(u_int) - i);
d670 1
a670 1
			      (i = NDLOSLOTS(fdp->fd_nfiles) * sizeof(u_int)));
d672 1
a672 1
			      NDLOSLOTS(nfiles) * sizeof(u_int) - i);
d866 1
a866 1
		       M_FILEDESC, M_WAITOK);
d868 1
a868 1
		       M_FILEDESC, M_WAITOK);
d1065 1
a1065 1
	 * the file descriptor being sought for duplication. The error 
@


1.29
log
@Use pool to allocate struct filedesc0 and struct file.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.28 2001/05/14 13:43:53 art Exp $	*/
d576 1
a576 1
		panic("fpathconf");
@


1.28
log
@gc OLD_PIPE.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.27 2001/05/14 13:28:20 art Exp $	*/
d65 1
d83 12
d740 1
a740 1
	MALLOC(fp, struct file *, sizeof(struct file), M_FILE, M_WAITOK);
d771 1
a771 1
	FREE(fp, M_FILE);
d785 1
a785 2
	MALLOC(newfdp, struct filedesc0 *, sizeof(struct filedesc0),
	    M_FILEDESC, M_WAITOK);
d827 3
a829 3
	register struct filedesc *newfdp, *fdp = p->p_fd;
	register struct file **fpp;
	register int i;
d831 1
a831 2
	MALLOC(newfdp, struct filedesc *, sizeof(struct filedesc0),
	    M_FILEDESC, M_WAITOK);
d943 1
a943 1
	FREE(fdp, M_FILEDESC);
@


1.27
log
@use fo_stat in fileops instead of huge switch statements.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.26 2001/05/14 12:11:52 art Exp $	*/
a550 2

#ifndef OLD_PIPE
a551 1
#endif
@


1.26
log
@Implement a wrapper round vn_stat that takes the same arguments
as soo_stat and pipe_stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.25 2001/05/14 11:04:04 art Exp $	*/
d503 1
a503 1
	register struct sys_fstat_args /* {
d516 1
a516 20
	switch (fp->f_type) {

	case DTYPE_VNODE:
		error = vn_statfile(fp, &ub, p);
		break;

	case DTYPE_SOCKET:
		error = soo_stat(fp, &ub, p);
		break;

#ifndef OLD_PIPE
	case DTYPE_PIPE:
		error = pipe_stat(fp, &ub, p);
		break;
#endif

	default:
		panic("fstat");
		/*NOTREACHED*/
	}
@


1.25
log
@More generic arguments to soo_stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.24 2001/05/14 10:51:26 art Exp $	*/
d519 1
a519 1
		error = vn_stat((struct vnode *)fp->f_data, &ub, p);
@


1.24
log
@More generic arguments to pipe_stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.23 2000/11/16 20:02:16 provos Exp $	*/
d523 1
a523 1
		error = soo_stat((struct socket *)fp->f_data, &ub);
@


1.23
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.22 2000/09/27 16:13:46 mickey Exp $	*/
d508 2
a509 2
	register struct filedesc *fdp = p->p_fd;
	register struct file *fp;
d528 1
a528 1
		error = pipe_stat((struct pipe *)fp->f_data, &ub);
@


1.23.2.1
log
@Fix (art):
don't panic on kqueue.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.23 2000/11/16 20:02:16 provos Exp $	*/
d533 2
a534 1
		return (EOPNOTSUPP);
d585 1
a585 1
		return (EOPNOTSUPP);
@


1.22
log
@replace MALLOC/FREE w/ malloc/free for non-constant-sized memory allocations; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.21 2000/09/24 19:13:26 provos Exp $	*/
d64 1
d467 2
d811 1
d888 15
d904 1
a904 1
	for (i = newfdp->fd_lastfile; i >= 0; i--, fpp++)
d912 1
a912 1
				*fpp = NULL;
d950 4
@


1.21
log
@prevent memory leak in fdalloc; fix by greg@@nest.cx
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.20 2000/04/01 23:29:25 provos Exp $	*/
d649 1
a649 2
		MALLOC(newofile, struct file **, nfiles * OFILESIZE,
		    M_FILEDESC, M_WAITOK);
d664 1
a664 1
			FREE(fdp->fd_ofiles, M_FILEDESC);
d667 1
a667 2
			MALLOC(newhimap, u_int *,
			       NDHISLOTS(nfiles) * sizeof(u_int),
d669 1
a669 2
			MALLOC(newlomap, u_int *,
			       NDLOSLOTS(nfiles) * sizeof(u_int),
d683 2
a684 2
				FREE(fdp->fd_himap, M_FILEDESC);
				FREE(fdp->fd_lomap, M_FILEDESC);
d865 1
a865 2
		MALLOC(newfdp->fd_ofiles, struct file **, i * OFILESIZE,
		    M_FILEDESC, M_WAITOK);
d874 1
a874 1
		MALLOC(newfdp->fd_himap, u_int *, NDHISLOTS(i) * sizeof(u_int),
d876 1
a876 1
		MALLOC(newfdp->fd_lomap, u_int *, NDLOSLOTS(i) * sizeof(u_int),
d923 1
a923 1
		FREE(fdp->fd_ofiles, M_FILEDESC);
d925 2
a926 2
		FREE(fdp->fd_himap, M_FILEDESC);
		FREE(fdp->fd_lomap, M_FILEDESC);
@


1.20
log
@fdup could fail when want for fdalloc > than the free fd in the block.
slightly different fix than in the bug report by
Rob Pickering <rob@@syntonet.co.uk>
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.19 2000/02/28 18:04:08 provos Exp $	*/
a652 4
		MALLOC(newhimap, u_int *, NDHISLOTS(nfiles) * sizeof(u_int),
		       M_FILEDESC, M_WAITOK);
		MALLOC(newlomap, u_int *, NDLOSLOTS(nfiles) * sizeof(u_int),
		       M_FILEDESC, M_WAITOK);
a663 10
		bcopy(fdp->fd_himap, newhimap,
		      (i = NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int)));
		bzero((char *)newhimap + i,
		      NDHISLOTS(nfiles) * sizeof(u_int) - i);

		bcopy(fdp->fd_lomap, newlomap,
		      (i = NDLOSLOTS(fdp->fd_nfiles) * sizeof(u_int)));
		bzero((char *)newlomap + i,
		      NDLOSLOTS(nfiles) * sizeof(u_int) - i);

d666 25
a690 3
		if (NDHISLOTS(fdp->fd_nfiles) > NDHISLOTS(NDFILE)) {
			FREE(fdp->fd_himap, M_FILEDESC);
			FREE(fdp->fd_lomap, M_FILEDESC);
a694 2
		fdp->fd_himap = newhimap;
		fdp->fd_lomap = newlomap;
@


1.19
log
@Optimized fdalloc as in Banga and Mogul paper:
http://www.usenix.org/publications/library/proceedings/usenix98/banga.html
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.18 1999/07/13 15:17:50 provos Exp $	*/
d622 7
@


1.18
log
@introduce fdremove() to mark a file descriptor as unused. fdremove makes
sure that the fd_freefile hints stay in sync, otherwise free file
descriptors might not be overlooked by fdalloc(); ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.17 1999/02/26 05:10:40 art Exp $	*/
d77 1
d79 57
d142 5
d157 1
d161 5
d170 2
a171 6
	if (fd == fdp->fd_lastfile) {
		do {
			fd--;
		} while (fd >= 0 && fdp->fd_ofiles[fd] == NULL);
		fdp->fd_lastfile = fd;
	}
d603 1
d615 9
a623 2
		for (; i < last; i++) {
			if (fdp->fd_ofiles[i] == NULL) {
d645 5
d660 11
d673 4
d680 2
d725 1
d796 2
d859 11
d873 2
d915 4
@


1.18.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a76 1
static __inline int find_next_zero __P((u_int *, int, u_int));
a77 57
int find_last_set __P((struct filedesc *, int));

static __inline int
find_next_zero (u_int *bitmap, int want, u_int bits)
{
        int i, off, maxoff;
	u_int sub;

        if (want > bits)
                return -1;

	off = want >> NDENTRYSHIFT;
	i = want & NDENTRYMASK;
        if (i) {
		sub = bitmap[off] | ((u_int)~0 >> (NDENTRIES - i));
		if (sub != ~0)
			goto found;
		off++;
        }

	maxoff = NDLOSLOTS(bits);
        while (off < maxoff) {
                if ((sub = bitmap[off]) != ~0)
                        goto found;
		off++;
        }

        return -1;

 found:
        return (off << NDENTRYSHIFT) + ffs(~sub) - 1;
}

int
find_last_set(struct filedesc *fd, int last)
{
	int off, i;
	struct file **ofiles = fd->fd_ofiles;
	u_int *bitmap = fd->fd_lomap;

	off = (last - 1) >> NDENTRYSHIFT;

	while (!bitmap[off] && off >= 0)
		off--;

	if (off < 0)
		return 0;
	
	i = ((off + 1) << NDENTRYSHIFT) - 1;
	if (i >= last)
		i = last - 1;

	while (i > 0 && ofiles[i] == NULL)
		i--;

	return i;
}
a83 5
	u_int off = fd >> NDENTRYSHIFT;

	fdp->fd_lomap[off] |= 1 << (fd & NDENTRYMASK);
	if (fdp->fd_lomap[off] == ~0)
		fdp->fd_himap[off >> NDENTRYSHIFT] |= 1 << (off & NDENTRYMASK);
a93 1
	u_int off = fd >> NDENTRYSHIFT;
a96 5

	if (fdp->fd_lomap[off] == ~0)
		fdp->fd_himap[off >> NDENTRYSHIFT] &= ~(1 << (off & NDENTRYMASK));
	fdp->fd_lomap[off] &= ~(1 << (fd & NDENTRYMASK));

d101 6
a106 2
	if (fd == fdp->fd_lastfile)
		fdp->fd_lastfile = find_last_set(fdp, fd);
a537 1
	u_int *newhimap, *newlomap, new, off;
d549 2
a550 9
		off = i >> NDENTRYSHIFT;
		new = find_next_zero(fdp->fd_himap, off,
				     (last + NDENTRIES - 1) >> NDENTRYSHIFT);
		if (new != -1) {
			i = find_next_zero(&fdp->fd_lomap[new], 
					   new > off ? 0 : i & NDENTRYMASK,
					   NDENTRIES);
			i += (new << NDENTRYSHIFT);
			if (i < last) {
a571 5

		MALLOC(newhimap, u_int *, NDHISLOTS(nfiles) * sizeof(u_int),
		       M_FILEDESC, M_WAITOK);
		MALLOC(newlomap, u_int *, NDLOSLOTS(nfiles) * sizeof(u_int),
		       M_FILEDESC, M_WAITOK);
a581 11

		bcopy(fdp->fd_himap, newhimap,
		      (i = NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int)));
		bzero((char *)newhimap + i,
		      NDHISLOTS(nfiles) * sizeof(u_int) - i);

		bcopy(fdp->fd_lomap, newlomap,
		      (i = NDLOSLOTS(fdp->fd_nfiles) * sizeof(u_int)));
		bzero((char *)newlomap + i,
		      NDLOSLOTS(nfiles) * sizeof(u_int) - i);

a583 4
		if (NDHISLOTS(fdp->fd_nfiles) > NDHISLOTS(NDFILE)) {
			FREE(fdp->fd_himap, M_FILEDESC);
			FREE(fdp->fd_lomap, M_FILEDESC);
		}
a586 2
		fdp->fd_himap = newhimap;
		fdp->fd_lomap = newlomap;
a629 1
		fd_unused(p->p_fd, i);
a699 2
	newfdp->fd_fd.fd_himap = newfdp->fd_dhimap;
	newfdp->fd_fd.fd_lomap = newfdp->fd_dlomap;
a760 11
	if (NDHISLOTS(i) <= NDHISLOTS(NDFILE)) {
		newfdp->fd_himap =
			((struct filedesc0 *) newfdp)->fd_dhimap;
		newfdp->fd_lomap =
			((struct filedesc0 *) newfdp)->fd_dlomap;
	} else {
		MALLOC(newfdp->fd_himap, u_int *, NDHISLOTS(i) * sizeof(u_int),
		       M_FILEDESC, M_WAITOK);
		MALLOC(newfdp->fd_lomap, u_int *, NDLOSLOTS(i) * sizeof(u_int),
		       M_FILEDESC, M_WAITOK);
	}
a763 2
	bcopy(fdp->fd_himap, newfdp->fd_himap, NDHISLOTS(i) * sizeof(u_int));
	bcopy(fdp->fd_lomap, newfdp->fd_lomap, NDLOSLOTS(i) * sizeof(u_int));
a803 4
	if (NDHISLOTS(fdp->fd_nfiles) > NDHISLOTS(NDFILE)) {
		FREE(fdp->fd_himap, M_FILEDESC);
		FREE(fdp->fd_lomap, M_FILEDESC);
	}
@


1.18.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.23 2000/11/16 20:02:16 provos Exp $	*/
a63 1
#include <sys/event.h>
a465 2
	if (fd < fdp->fd_knlistsize)
		knote_fdclose(p, fd);
a621 7
			if (i == -1) {
				/* free file descriptor in this block was
				 * below want, try again with higher want.
				 */
				want = (new + 1) << NDENTRYSHIFT;
				continue;
			}
d642 2
a643 1
		newofile = malloc(nfiles * OFILESIZE, M_FILEDESC, M_WAITOK);
d646 4
d661 10
d672 4
a675 24
			free(fdp->fd_ofiles, M_FILEDESC);

		if (NDHISLOTS(nfiles) > NDHISLOTS(fdp->fd_nfiles)) {
			newhimap = malloc(NDHISLOTS(nfiles) * sizeof(u_int),
			       M_FILEDESC, M_WAITOK);
			newlomap = malloc( NDLOSLOTS(nfiles) * sizeof(u_int),
			       M_FILEDESC, M_WAITOK);

			bcopy(fdp->fd_himap, newhimap,
			      (i = NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int)));
			bzero((char *)newhimap + i,
			      NDHISLOTS(nfiles) * sizeof(u_int) - i);

			bcopy(fdp->fd_lomap, newlomap,
			      (i = NDLOSLOTS(fdp->fd_nfiles) * sizeof(u_int)));
			bzero((char *)newlomap + i,
			      NDLOSLOTS(nfiles) * sizeof(u_int) - i);

			if (NDHISLOTS(fdp->fd_nfiles) > NDHISLOTS(NDFILE)) {
				free(fdp->fd_himap, M_FILEDESC);
				free(fdp->fd_lomap, M_FILEDESC);
			}
			fdp->fd_himap = newhimap;
			fdp->fd_lomap = newlomap;
d680 2
a797 1
	newfdp->fd_fd.fd_knlistsize = -1;
d855 2
a856 1
		newfdp->fd_ofiles = malloc(i * OFILESIZE, M_FILEDESC, M_WAITOK);
d865 1
a865 1
		newfdp->fd_himap = malloc(NDHISLOTS(i) * sizeof(u_int),
d867 1
a867 1
		newfdp->fd_lomap = malloc(NDLOSLOTS(i) * sizeof(u_int),
a874 15

	/*
	 * kq descriptors cannot be copied.
	 */
	if (newfdp->fd_knlistsize != -1) {
		fpp = newfdp->fd_ofiles;
		for (i = 0; i <= newfdp->fd_lastfile; i++, fpp++)
			if (*fpp != NULL && (*fpp)->f_type == DTYPE_KQUEUE)
				fdremove(newfdp, i);
		newfdp->fd_knlist = NULL;
		newfdp->fd_knlistsize = -1;
		newfdp->fd_knhash = NULL;
		newfdp->fd_knhashmask = 0;
	}

d876 1
a876 1
	for (i = 0; i <= newfdp->fd_lastfile; i++, fpp++)
d884 1
a884 1
				fdremove(newfdp, i);
d914 1
a914 1
		free(fdp->fd_ofiles, M_FILEDESC);
d916 2
a917 2
		free(fdp->fd_himap, M_FILEDESC);
		free(fdp->fd_lomap, M_FILEDESC);
a921 4
	if (fdp->fd_knlist)
		FREE(fdp->fd_knlist, M_TEMP);
	if (fdp->fd_knhash)
		FREE(fdp->fd_knhash, M_TEMP);
@


1.18.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.18.4.2 2001/05/14 22:32:40 niklas Exp $	*/
a64 1
#include <sys/pool.h>
a81 12
struct pool file_pool;
struct pool fdesc_pool;

void
filedesc_init()
{
	pool_init(&file_pool, sizeof(struct file), 0, 0, 0, "filepl",
		0, pool_page_alloc_nointr, pool_page_free_nointr, M_PROC);
	pool_init(&fdesc_pool, sizeof(struct filedesc0), 0, 0, 0, "fdescpl",
		0, pool_page_alloc_nointr, pool_page_free_nointr, M_FILEDESC);
}

d85 1
a85 1
	int i, off, maxoff;
d88 2
a89 2
	if (want > bits)
		return -1;
d93 1
a93 1
	if (i) {
d98 1
a98 1
	}
d101 3
a103 3
	while (off < maxoff) {
		if ((sub = bitmap[off]) != ~0)
			goto found;
d105 1
a105 1
	}
d107 1
a107 1
	return -1;
d110 1
a110 1
	return (off << NDENTRYSHIFT) + ffs(~sub) - 1;
d124 1
d127 1
a127 1

d134 1
d455 1
d460 4
d503 1
a503 1
	struct sys_fstat_args /* {
d508 2
a509 2
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
d516 20
a535 1
	error = (*fp->f_ops->fo_stat)(fp, &ub, p);
d570 2
d573 1
d585 1
a585 1
		return (EOPNOTSUPP);
d620 1
a620 1
		    (last + NDENTRIES - 1) >> NDENTRYSHIFT);
d671 1
a671 1
			    M_FILEDESC, M_WAITOK);
d673 1
a673 1
			    M_FILEDESC, M_WAITOK);
d676 1
a676 1
			    (i = NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int)));
d678 1
a678 1
			    NDHISLOTS(nfiles) * sizeof(u_int) - i);
d681 1
a681 1
			    (i = NDLOSLOTS(fdp->fd_nfiles) * sizeof(u_int)));
d683 1
a683 1
			    NDLOSLOTS(nfiles) * sizeof(u_int) - i);
d749 1
a749 1
	fp = pool_get(&file_pool, PR_WAITOK);
d780 1
a780 1
	pool_put(&file_pool, fp);
d794 2
a795 1
	newfdp = pool_get(&fdesc_pool, PR_WAITOK);
d837 3
a839 3
	struct filedesc *newfdp, *fdp = p->p_fd;
	struct file **fpp;
	int i;
d841 2
a842 1
	newfdp = pool_get(&fdesc_pool, PR_WAITOK);
d879 1
a879 1
		    M_FILEDESC, M_WAITOK);
d881 1
a881 1
		    M_FILEDESC, M_WAITOK);
d954 1
a954 1
	pool_put(&fdesc_pool, fdp);
d1078 1
a1078 1
	 * the file descriptor being sought for duplication. The error
@


1.18.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.18.4.3 2001/07/04 10:48:15 niklas Exp $	*/
a185 16
struct file *
fd_getfile(fdp, fd)
	struct filedesc *fdp;
	int fd;
{
	struct file *fp;

	if ((u_int)fd >= fdp->fd_nfiles || (fp = fdp->fd_ofiles[fd]) == NULL)
		return (NULL);

	if (!FILE_IS_USABLE(fp))
		return (NULL);

	return (fp);
}

d208 1
a208 2
restart:
	if (fd_getfile(fdp, old) == NULL)
d210 1
a210 5
	if ((error = fdalloc(p, 0, &new)) != 0) {
		if (error == ENOSPC) {
			fdexpand(p);
			goto restart;
		}
a211 1
	}
d229 2
a230 2
	struct filedesc *fdp = p->p_fd;
	int old = SCARG(uap, from), new = SCARG(uap, to);
d233 2
a234 4
restart:
	if (fd_getfile(fdp, old) == NULL)
		return (EBADF);
	if ((u_int)new >= p->p_rlimit[RLIMIT_NOFILE].rlim_cur ||
d242 1
a242 5
		if ((error = fdalloc(p, new, &i)) != 0) {
			if (error == ENOSPC) {
				fdexpand(p);
				goto restart;
			}
a243 1
		}
d246 2
d262 1
a262 1
	struct sys_fcntl_args /* {
d268 2
a269 2
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
d275 2
a276 2
restart:
	if ((fp = fd_getfile(fdp, fd)) == NULL)
d285 1
a285 5
		if ((error = fdalloc(p, newmin, &i)) != 0) {
			if (error == ENOSPC) {
				fdexpand(p);
				goto restart;
			}
a286 1
		}
d352 1
a352 1
		/* FALLTHROUGH */
d363 2
a364 8
		if (fl.l_whence == SEEK_CUR) {
			if (fl.l_start == 0 && fl.l_len < 0) {
				/* lockf(3) compliance hack */
				fl.l_len = -fl.l_len;
				fl.l_start = fp->f_offset - fl.l_len;
			} else
				fl.l_start += fp->f_offset;
		}
d396 8
a403 8
		if (fl.l_whence == SEEK_CUR) {
			if (fl.l_start == 0 && fl.l_len < 0) {
				/* lockf(3) compliance hack */
				fl.l_len = -fl.l_len;
				fl.l_start = fp->f_offset - fl.l_len;
			} else
				fl.l_start += fp->f_offset;
		}
a422 2
 *
 * XXX - should take a proc as an argument.
d430 1
a430 3
	struct file *fp, *oldfp;

	oldfp = fdp->fd_ofiles[new];
d436 1
a436 1
	fdp->fd_ofileflags[new] = fdp->fd_ofileflags[old] & ~UF_EXCLOSE;
d438 1
a438 2
	if (oldfp == NULL)
		fd_used(fdp, new);
a439 7

	if (oldfp != NULL) {
		if (new < fdp->fd_knlistsize)
			knote_fdclose(curproc, new);
		closef(oldfp, curproc);
	}

d457 3
a459 2
	struct filedesc *fdp = p->p_fd;
	struct file **fpp, *fp;
d465 5
d471 1
a471 1
	fdp->fd_ofileflags[fd] = 0;
d494 1
a494 1
	if (fd_getfile(fdp, fd) == NULL)
d519 2
a520 1
	if ((fp = fd_getfile(fdp, fd)) == NULL)
d553 2
a554 1
	if ((fp = fd_getfile(fdp, fd)) == NULL)
d577 2
d585 6
a590 3
	struct filedesc *fdp = p->p_fd;
	int lim, last, i;
	u_int new, off;
a596 1
restart:
d598 26
a623 17
	last = min(fdp->fd_nfiles, lim);
	if ((i = want) < fdp->fd_freefile)
		i = fdp->fd_freefile;
	off = i >> NDENTRYSHIFT;
	new = find_next_zero(fdp->fd_himap, off,
	    (last + NDENTRIES - 1) >> NDENTRYSHIFT);
	if (new != -1) {
		i = find_next_zero(&fdp->fd_lomap[new], 
				   new > off ? 0 : i & NDENTRYMASK,
				   NDENTRIES);
		if (i == -1) {
			/*
			 * Free file descriptor in this block was
			 * below want, try again with higher want.
			 */
			want = (new + 1) << NDENTRYSHIFT;
			goto restart;
d625 50
a674 7
		i += (new << NDENTRYSHIFT);
		if (i < last) {
			fd_used(fdp, i);
			if (want <= fdp->fd_freefile)
				fdp->fd_freefile = i;
			*result = i;
			return (0);
d676 4
a680 4
	if (fdp->fd_nfiles >= lim)
		return (EMFILE);

	return (ENOSPC);
d683 6
a688 2
void
fdexpand(p)
d690 1
d692 3
a694 5
	struct filedesc *fdp = p->p_fd;
	int nfiles, i;
	struct file **newofile;
	char *newofileflags;
	u_int *newhimap, *newlomap;
d696 8
a703 60
	/*
	 * If it's already expanding just wait for that expansion to finish
	 * and return and let the caller retry the operation.
	 */
	if (lockmgr(&fdp->fd_lock, LK_EXCLUSIVE|LK_SLEEPFAIL, NULL, p))
		return;

	/*
	 * No space in current array.
	 */
	if (fdp->fd_nfiles < NDEXTENT)
		nfiles = NDEXTENT;
	else
		nfiles = 2 * fdp->fd_nfiles;

	newofile = malloc(nfiles * OFILESIZE, M_FILEDESC, M_WAITOK);
	newofileflags = (char *) &newofile[nfiles];

	/*
	 * Copy the existing ofile and ofileflags arrays
	 * and zero the new portion of each array.
	 */
	bcopy(fdp->fd_ofiles, newofile,
		(i = sizeof(struct file *) * fdp->fd_nfiles));
	bzero((char *)newofile + i, nfiles * sizeof(struct file *) - i);
	bcopy(fdp->fd_ofileflags, newofileflags,
		(i = sizeof(char) * fdp->fd_nfiles));
	bzero(newofileflags + i, nfiles * sizeof(char) - i);

	if (fdp->fd_nfiles > NDFILE)
		free(fdp->fd_ofiles, M_FILEDESC);

	if (NDHISLOTS(nfiles) > NDHISLOTS(fdp->fd_nfiles)) {
		newhimap = malloc(NDHISLOTS(nfiles) * sizeof(u_int),
		    M_FILEDESC, M_WAITOK);
		newlomap = malloc(NDLOSLOTS(nfiles) * sizeof(u_int),
		    M_FILEDESC, M_WAITOK);

		bcopy(fdp->fd_himap, newhimap,
		    (i = NDHISLOTS(fdp->fd_nfiles) * sizeof(u_int)));
		bzero((char *)newhimap + i,
		    NDHISLOTS(nfiles) * sizeof(u_int) - i);

		bcopy(fdp->fd_lomap, newlomap,
		    (i = NDLOSLOTS(fdp->fd_nfiles) * sizeof(u_int)));
		bzero((char *)newlomap + i,
		    NDLOSLOTS(nfiles) * sizeof(u_int) - i);

		if (NDHISLOTS(fdp->fd_nfiles) > NDHISLOTS(NDFILE)) {
			free(fdp->fd_himap, M_FILEDESC);
			free(fdp->fd_lomap, M_FILEDESC);
		}
		fdp->fd_himap = newhimap;
		fdp->fd_lomap = newlomap;
	}
	fdp->fd_ofiles = newofile;
	fdp->fd_ofileflags = newofileflags;
	fdp->fd_nfiles = nfiles;	

	lockmgr(&fdp->fd_lock, LK_RELEASE, NULL, p);
d719 1
a719 6
restart:
	if ((error = fdalloc(p, 0, &i)) != 0) {
		if (error == ENOSPC) {
			fdexpand(p);
			goto restart;
		}
a720 1
	}
a734 1
	fp->f_iflags = FIF_LARVAL;
a784 1
	lockinit(&newfdp->fd_fd.fd_lock, PLOCK, "fdexpand", 0, 0);
d826 1
a826 2
	if (newfdp->fd_cdir)
		VREF(newfdp->fd_cdir);
d929 1
a929 2
	if (fdp->fd_cdir)
		vrele(fdp->fd_cdir);
d1016 2
a1017 1
	if ((fp = fd_getfile(fdp, fd)) == NULL)
d1091 2
a1092 4
	if ((wfp = fd_getfile(fdp, dfd)) == NULL)
		return (EBADF);

	if (fp == wfp)
@


1.18.4.5
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
#include <uvm/uvm_extern.h>
d80 1
a80 1
int finishdup __P((struct proc *, int, int, register_t *));
d234 1
a234 1
	return (finishdup(p, old, new, retval));
d276 1
a276 1
	return (finishdup(p, old, new, retval));
d319 1
a319 1
		return (finishdup(p, fd, i, retval));
d461 2
d465 3
a467 3
finishdup(p, old, new, retval)
	struct proc *p;
	int old, new;
a470 1
	struct filedesc *fdp = p->p_fd;
d486 2
a487 2
			knote_fdclose(p, new);
		closef(oldfp, p);
@


1.18.4.6
log
@Merge in -current
@
text
@a92 1
	LIST_INIT(&filehead);
@


1.18.4.7
log
@Merge in trunk
@
text
@d80 1
a80 1
int finishdup(struct proc *, struct file *, int, int, register_t *);
d90 1
a90 1
		&pool_allocator_nointr);
d92 1
a92 1
		&pool_allocator_nointr);
d220 2
a221 3
	struct filedesc *fdp = p->p_fd;
	int old = SCARG(uap, fd);
	struct file *fp;
d226 1
a226 1
	if ((fp = fd_getfile(fdp, old)) == NULL)
a227 1
	FREF(fp);
a228 1
		FRELE(fp);
d235 1
a235 1
	return (finishdup(p, fp, old, new, retval));
d252 1
a253 2
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
d257 1
a257 1
	if ((fp = fd_getfile(fdp, old)) == NULL)
a262 5
		/*
		 * NOTE! This doesn't clear the close-on-exec flag. This might
		 * or might not be the intended behavior from the start, but
		 * this is what everyone else does.
		 */
a265 1
	FREF(fp);
a267 1
			FRELE(fp);
d277 1
a277 1
	return (finishdup(p, fp, old, new, retval));
d299 1
a299 1
	int i, tmp, newmin, flg = F_POSIX;
d301 1
a301 1
	int error = 0;
a305 1
	FREF(fp);
d311 2
a312 4
		    (u_int)newmin >= maxfiles) {
			error = EINVAL;
			break;
		}
a315 1
				FRELE(fp);
d318 1
a318 1
			break;
d320 1
a320 2
		/* finishdup will FRELE for us. */
		return (finishdup(p, fp, fd, i, retval));
d324 1
a324 1
		break;
d331 1
a331 1
		break;
d335 1
a335 1
		break;
d343 1
a343 1
			break;
d347 1
a347 1
			break;
d351 1
a351 1
		break;
d356 1
a356 1
			break;
d359 3
a361 3
			(fp, TIOCGPGRP, (caddr_t)&tmp, p);
		*retval = -tmp;
		break;
d370 1
a370 1
			break;
d376 2
a377 4
			if (p1 == 0) {
				error = ESRCH;
				break;
			}
d380 1
a380 1
		error = ((*fp->f_ops->fo_ioctl)
a381 1
		break;
d388 2
a389 4
		if (fp->f_type != DTYPE_VNODE) {
			error = EBADF;
			break;
		}
d395 1
a395 1
			break;
d407 2
a408 4
			if ((fp->f_flag & FREAD) == 0) {
				error = EBADF;
				goto out;
			}
d410 1
a410 2
			error = (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg));
			goto out;
d413 2
a414 4
			if ((fp->f_flag & FWRITE) == 0) {
				error = EBADF;
				goto out;
			}
d416 1
a416 2
			error = (VOP_ADVLOCK(vp, (caddr_t)p, F_SETLK, &fl, flg));
			goto out;
d419 1
a419 1
			error = (VOP_ADVLOCK(vp, (caddr_t)p, F_UNLCK, &fl,
a420 1
			goto out;
d423 1
a423 2
			error = EINVAL;
			goto out;
d427 2
a428 4
		if (fp->f_type != DTYPE_VNODE) {
			error = EBADF;
			break;
		}
d434 1
a434 1
			break;
d446 2
a447 4
		    fl.l_type != 0) {
			error = EINVAL;
			break;
		}
d450 2
a451 2
			break;
		error = (copyout((caddr_t)&fl, (caddr_t)SCARG(uap, arg),
a452 1
		break;
d455 1
a455 2
		error = EINVAL;
		break;
d457 1
a457 3
out:
	FRELE(fp);
	return (error);	
d464 4
a467 1
finishdup(struct proc *p, struct file *fp, int old, int new, register_t *retval)
d469 1
a469 1
	struct file *oldfp;
a471 4
	/*
	 * Don't fd_getfile here. We want to closef LARVAL files and
	 * closef can deal with that.
	 */
a472 2
	if (oldfp != NULL)
		FREF(oldfp);
d474 1
a479 1
	FRELE(fp);
a509 4
	/*
	 * Don't fd_getfile here. We want to closef LARVAL files and closef
	 * can deal with that.
	 */
a513 1
	FREF(fp);
d536 1
a536 1
	struct filedesc *fdp = p->p_fd;
a564 1
	FREF(fp);
a565 1
	FRELE(fp);
d587 1
a587 1
	struct sys_fpathconf_args /* {
a594 1
	int error;
a597 1
	FREF(fp);
d601 2
a602 4
		if (SCARG(uap, name) != _PC_PIPE_BUF) {
			error = EINVAL;
			break;
		}
a603 2
		error = 0;
		break;
d608 1
a608 2
		error = VOP_PATHCONF(vp, SCARG(uap, name), retval);
		break;
d611 1
a611 2
		error = EOPNOTSUPP;
		break;
d613 1
a613 2
	FRELE(fp);
	return (error);
a789 1
	FREF(fp);
d794 16
a961 1
			FREF(fp);
a988 2
 *
 * The fp must have its usecount bumped and will be FILE_UNUSEd here.
d991 3
a993 1
closef(struct file *fp, struct proc *p)
a1000 1

d1017 1
a1017 14

	/*
	 * Some files passed to this function could be accessed
	 * without a FILE_IS_USABLE check (and in some cases it's perfectly
	 * legal), we must beware of files where someone already won the
	 * race to FIF_WANTCLOSE.
	 */
	if ((fp->f_iflags & FIF_WANTCLOSE) != 0) {
		FRELE(fp);
		return (0);
	}

	if (--fp->f_count > 0) {
		FRELE(fp);
a1018 3
	}

#ifdef DIAGNOSTIC
a1020 7
#endif

	/* Wait for the last usecount to drain. */
	fp->f_iflags |= FIF_WANTCLOSE;
	while (fp->f_usecount > 1)
		tsleep(&fp->f_usecount, PRIBIO, "closef", 0);

d1033 1
a1033 11

	/* Free fp */
	LIST_REMOVE(fp, f_list);
	crfree(fp->f_cred);
#ifdef DIAGNOSTIC
	if (fp->f_count != 0 || fp->f_usecount != 1)
		panic("closef: count: %d/%d", fp->f_count, fp->f_usecount);
#endif
	nfiles--;
	pool_put(&file_pool, fp);

d1050 1
a1050 1
	struct sys_flock_args /* {
d1056 2
a1057 2
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
a1059 1
	int error;
d1072 1
a1072 2
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_UNLCK, &lf, F_FLOCK);
		goto out;
d1078 2
a1079 4
	else {
		error = EINVAL;
		goto out;
	}
d1082 2
a1083 5
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, F_FLOCK);
	else
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, F_FLOCK|F_WAIT);
out:
	return (error);
d1119 2
a1120 2
	struct filedesc *fdp;
	int indx, dfd;
d1124 2
a1125 1
	struct file *wfp;
d1130 3
a1132 3
	 * closed, reject. Note, there is no need to check for new == old
	 * because fd_getfile will return NULL if the file at indx is
	 * newly created by falloc (FIF_LARVAL).
d1134 1
d1136 3
@


1.18.4.8
log
@Merge in -current from about a week ago
@
text
@d77 3
a79 3
static __inline void fd_used(struct filedesc *, int);
static __inline void fd_unused(struct filedesc *, int);
static __inline int find_next_zero(u_int *, int, u_int);
d81 1
a81 1
int find_last_set(struct filedesc *, int);
@


1.18.4.9
log
@Sync the SMP branch with 3.3
@
text
@d218 1
a218 1
		syscallarg(int) fd;
d252 2
a253 2
		syscallarg(int) from;
		syscallarg(int) to;
a287 1
	/* finishdup() does FRELE */
a505 5
	if (fp->f_count == LONG_MAX-2) {
		FRELE(fp);
		return (EDEADLK);
	}

d514 2
d799 1
a799 1
 * a file descriptor for the process that refers to it.
d854 2
a855 1
fdinit(struct proc *p)
d857 2
a858 1
	struct filedesc0 *newfdp;
d863 5
a867 9
	if (p != NULL) {
		struct filedesc *fdp = p->p_fd;

		newfdp->fd_fd.fd_cdir = fdp->fd_cdir;
		VREF(newfdp->fd_fd.fd_cdir);
		newfdp->fd_fd.fd_rdir = fdp->fd_rdir;
		if (newfdp->fd_fd.fd_rdir)
			VREF(newfdp->fd_fd.fd_rdir);
	}
d1032 1
a1032 1
 * The fp must have its usecount bumped and will be FRELEd here.
@


1.18.4.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.18.4.9 2003/03/28 00:41:26 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.18.4.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d132 1
a132 1
	while (off >= 0 && !bitmap[off])
a225 1
	fdplock(fdp, p);
a229 1
			fdpunlock(fdp);
d232 1
a232 1
		goto out;
d234 1
a234 5
	error = finishdup(p, fp, old, new, retval);

out:
	fdpunlock(fdp);
	return (error);
a271 1
	fdplock(fdp, p);
a276 1
				fdpunlock(fdp);
d279 1
a279 1
			goto out;
d285 1
a285 5
	error = finishdup(p, fp, old, new, retval);

out:
	fdpunlock(fdp);
	return (error);
a323 1
		fdplock(fdp, p);
a327 1
				fdpunlock(fdp);
d330 1
d333 1
a333 7
		if (!error)
			error = finishdup(p, fp, fd, i, retval);
		else
			FRELE(fp);

		fdpunlock(fdp);
		return (error);
d580 1
a580 1
	int fd = SCARG(uap, fd), error;
d585 1
a585 5
	fdplock(fdp, p);
	error = fdrelease(p, fd);
	fdpunlock(fdp);

	return (error);
d616 1
a616 1
		if (suser(p, 0))
d657 1
d736 7
d793 2
d870 1
a870 1
	rw_init(&newfdp->fd_fd.fd_lock);
a1283 22
}

int
sys_closefrom(struct proc *p, void *v, register_t *retval)
{
	struct sys_closefrom_args *uap = v;
	struct filedesc *fdp = p->p_fd;
	u_int startfd, i;

	startfd = SCARG(uap, fd);
	fdplock(fdp, p);

	if (startfd > fdp->fd_lastfile) {
		fdpunlock(fdp);
		return (EBADF);
	}

	for (i = startfd; i <= fdp->fd_lastfile; i++)
		fdrelease(p, i);

	fdpunlock(fdp);
	return (0);
@


1.17
log
@uvm allocation and name changes
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.16 1998/12/04 19:40:55 deraadt Exp $	*/
d364 9
@


1.16
log
@consider limits, in fdavail(); michaels@@inet.no
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.15 1998/03/01 19:34:12 deraadt Exp $	*/
d380 6
d388 1
@


1.15
log
@crank f_count/f_msgcount to long; when incrementing try to leave 2 slots
empty for unp_gc() in case of cross referenced sockets. part by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.14 1997/08/31 20:42:15 deraadt Exp $	*/
d592 1
a592 1
	for (i = fdp->fd_nfiles - fdp->fd_freefile; --i >= 0; fpp++)
@


1.14
log
@for non-tty TIOCSPGRP/F_SETOWN/FIOSETOWN pgid setting calls, store uid
and euid as well, then deliver them using new csignal() interface
which ensures that pgid setting process is permitted to signal the
pgid process(es). Thanks to newsham@@aloha.net for extensive help and
discussion.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.13 1997/08/21 05:17:37 deraadt Exp $	*/
d356 2
d750 11
a760 2
		if (*fpp != NULL)
			(*fpp)->f_count++;
d970 2
@


1.13
log
@constrain nfiles so that fdavail() never lies; bug report and test program from abelits@@phobos.illtel.denver.co.us
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.12 1997/07/25 17:31:38 mickey Exp $	*/
d58 1
d255 5
a259 2
			((struct socket *)fp->f_data)->so_pgid =
			    (long)SCARG(uap, arg);
@


1.12
log
@return EINVAL in case bad locking specified; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.11 1997/01/25 17:37:34 dm Exp $	*/
d546 1
@


1.11
log
@Changed my mind about where to do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.10 1997/01/25 00:27:30 dm Exp $	*/
d874 1
a874 1
		return (EBADF);
@


1.10
log
@Only disclose generation number to root.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.9 1996/10/28 00:42:30 tholo Exp $	*/
a429 4
		/* Don't let non-root see generation numbers
		   (for NFS security) */
		if (suser(p->p_ucred, &p->p_acflag))
			ub.st_gen = 0;
d446 5
a450 1
	if (error == 0)
d453 1
@


1.9
log
@More argument checking of fcntl(, F_GETLK, )
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.8 1996/10/26 07:31:48 tholo Exp $	*/
d430 4
@


1.8
log
@Verify arguments to fcntl(, F_GETLK, )
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.7 1996/09/04 22:33:48 niklas Exp $	*/
d317 4
@


1.7
log
@pipe.h needed vm_page_t defined for me, so I moved it down
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.6 1996/08/27 14:46:59 shawn Exp $	*/
d317 7
@


1.6
log
@New fast pipe(2) from freebsd without fancy vm stuff.

The old pipes can be used with the "OLD_PIPE" config option.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.5 1996/04/21 22:26:59 deraadt Exp $	*/
a60 2
#include <sys/pipe.h>

d65 2
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_descrip.c,v 1.4 1996/04/19 16:08:53 niklas Exp $	*/
d61 1
d425 6
d465 3
@


1.4
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: kern_descrip.c,v 1.3 1996/03/03 17:19:42 niklas Exp $	*/
/*	$NetBSD: kern_descrip.c,v 1.40 1996/03/14 19:01:10 christos Exp $	*/
d60 1
a66 2
#include <kern/kern_conf.h>

d247 1
a247 1
			(fp, (int)TIOCGPGRP, (caddr_t)retval, p);
d266 1
a266 1
			(fp, (int)TIOCSPGRP, (caddr_t)&SCARG(uap, arg), p));
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: kern_descrip.c,v 1.39 1996/02/09 18:59:26 christos Exp $	*/
d866 1
a866 1
fdopen(dev, mode, type, p)
@


1.2
log
@add fdshare() and fdinit() calls for dealing with filedesc structures
@
text
@d1 2
a2 1
/*	$NetBSD: kern_descrip.c,v 1.37 1995/10/07 06:28:09 mycroft Exp $	*/
d64 4
d74 5
a78 1
static __inline
d88 1
a88 1
static __inline
d116 1
d132 1
a132 1
	if (error = fdalloc(p, 0, &new))
d141 1
d164 1
a164 1
		if (error = fdalloc(p, new, &i))
d178 1
d207 1
a207 1
		if (error = fdalloc(p, newmin, &i))
d317 2
a318 1
		if (error = VOP_ADVLOCK(vp, (caddr_t)p, F_GETLK, &fl, F_POSIX))
d375 1
d396 1
d439 1
d480 1
d547 1
d570 1
d579 1
a579 1
	if (error = fdalloc(p, 0, &i))
d594 1
a594 1
	if (fq = p->p_fd->fd_ofiles[0]) {
d613 1
a616 2
	register struct file *fq;

d759 1
d813 1
@


1.1
log
@Initial revision
@
text
@d609 44
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

