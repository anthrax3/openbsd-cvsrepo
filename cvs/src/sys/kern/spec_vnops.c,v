head	1.89;
access;
symbols
	OPENBSD_6_1:1.89.0.4
	OPENBSD_6_1_BASE:1.89
	OPENBSD_6_0:1.89.0.2
	OPENBSD_6_0_BASE:1.89
	OPENBSD_5_9:1.85.0.2
	OPENBSD_5_9_BASE:1.85
	OPENBSD_5_8:1.83.0.6
	OPENBSD_5_8_BASE:1.83
	OPENBSD_5_7:1.83.0.2
	OPENBSD_5_7_BASE:1.83
	OPENBSD_5_6:1.78.0.6
	OPENBSD_5_6_BASE:1.78
	OPENBSD_5_5:1.78.0.4
	OPENBSD_5_5_BASE:1.78
	OPENBSD_5_4:1.74.0.2
	OPENBSD_5_4_BASE:1.74
	OPENBSD_5_3:1.69.0.4
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.69.0.2
	OPENBSD_5_2_BASE:1.69
	OPENBSD_5_1_BASE:1.68
	OPENBSD_5_1:1.68.0.4
	OPENBSD_5_0:1.68.0.2
	OPENBSD_5_0_BASE:1.68;
locks; strict;
comment	@ * @;


1.89
date	2016.04.05.19.26.15;	author natano;	state Exp;
branches;
next	1.88;
commitid	yk8EkL7swzNNGn3c;

1.88
date	2016.04.01.11.51.55;	author mikeb;	state Exp;
branches;
next	1.87;
commitid	WRmLf3alaeLrWDOA;

1.87
date	2016.03.31.20.00.17;	author natano;	state Exp;
branches;
next	1.86;
commitid	MnVY7egfe4wB5xs8;

1.86
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.85;
commitid	gAjwyca5TfuoJAhn;

1.85
date	2016.01.19.19.13.38;	author stefan;	state Exp;
branches;
next	1.84;
commitid	UBk7HTY9wHa7TNTw;

1.84
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.83;
commitid	Cl55DD2g2xm69E6W;

1.83
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.82;
commitid	C5iGb36LQxjM60Q3;

1.82
date	2014.12.29.05.29.27;	author miod;	state Exp;
branches;
next	1.81;
commitid	UbmX4MifiudCV4qQ;

1.81
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.80;
commitid	P6Av4XGqOi3rFasL;

1.80
date	2014.11.03.21.28.35;	author tedu;	state Exp;
branches;
next	1.79;
commitid	EkuwmBeHv2Tqmdnx;

1.79
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.78;
commitid	jdBY2kKXhfcoQitp;

1.78
date	2013.10.30.03.16.49;	author guenther;	state Exp;
branches;
next	1.77;

1.77
date	2013.10.29.03.11.08;	author guenther;	state Exp;
branches;
next	1.76;

1.76
date	2013.08.06.08.22.37;	author kettenis;	state Exp;
branches;
next	1.75;

1.75
date	2013.07.29.18.51.42;	author kettenis;	state Exp;
branches;
next	1.74;

1.74
date	2013.07.09.15.37.43;	author beck;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2013.06.11.19.01.20;	author beck;	state Exp;
branches;
next	1.72;

1.72
date	2013.06.11.16.42.16;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2013.03.28.03.29.44;	author guenther;	state Exp;
branches;
next	1.70;

1.70
date	2013.03.28.02.08.39;	author guenther;	state Exp;
branches;
next	1.69;

1.69
date	2012.06.20.17.30.22;	author matthew;	state Exp;
branches
	1.69.4.1;
next	1.68;

1.68
date	2011.07.30.10.26.03;	author jsing;	state Exp;
branches;
next	1.67;

1.67
date	2011.07.05.05.37.07;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2011.07.04.20.51.19;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2011.07.04.17.12.53;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2011.07.04.16.52.41;	author nicm;	state Exp;
branches;
next	1.63;

1.63
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.62;

1.62
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.61;

1.61
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.60;

1.60
date	2010.09.10.16.34.08;	author thib;	state Exp;
branches;
next	1.59;

1.59
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.58;

1.58
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.57;

1.57
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.56;

1.56
date	2009.08.13.15.00.14;	author jasper;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.25.15.49.26;	author thib;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.06.18.06.22;	author art;	state Exp;
branches;
next	1.53;

1.53
date	2008.07.24.18.48.18;	author thib;	state Exp;
branches;
next	1.52;

1.52
date	2008.06.12.06.58.40;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.11.12.35.46;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.10.20.14.36;	author beck;	state Exp;
branches;
next	1.49;

1.49
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.48;

1.48
date	2008.05.03.14.41.29;	author thib;	state Exp;
branches;
next	1.47;

1.47
date	2008.04.14.10.15.50;	author thib;	state Exp;
branches;
next	1.46;

1.46
date	2008.04.12.13.32.03;	author thib;	state Exp;
branches;
next	1.45;

1.45
date	2008.04.08.14.46.45;	author thib;	state Exp;
branches;
next	1.44;

1.44
date	2007.12.27.13.59.12;	author thib;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.18.08.30.07;	author jasper;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.02.00.45.21;	author thib;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.39;

1.39
date	2007.04.10.19.02.26;	author thib;	state Exp;
branches;
next	1.38;

1.38
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.29.14.30.30;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2006.10.16.11.27.53;	author pedro;	state Exp;
branches;
next	1.35;

1.35
date	2006.07.12.19.56.18;	author thib;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.02.20.25.09;	author pedro;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.02.20.19.44.58;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.31.21.22.35;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.29.20.00.52;	author pedro;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.24.04.45.13;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.29.17.05.05;	author grange;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.23.28.11;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.12.14.41.07;	author jason;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.08.04.34.17;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.27.08;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.04.22.44.32;	author art;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.06.23.02.14.26;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.15.16.44.15;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.01.20.54.35;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.24.19.07.10;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.23.14.42.39;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	98.02.23.17.40.58;	author niklas;	state Exp;
branches
	1.15.10.1;
next	1.14;

1.14
date	97.12.28.19.34.49;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	97.11.06.20.04.35;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	97.11.06.05.58.44;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.10.06.20.20.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.10.06.15.19.12;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.01.04.17.10.04;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	96.12.22.16.05.24;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.12.05.16.25.08;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.11.23.23.19.52;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	96.11.23.21.47.11;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	96.11.04.03.31.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.02.13.20.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.08.05.15;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.02;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.02;	author deraadt;	state Exp;
branches;
next	;

1.15.10.1
date	2001.05.14.22.32.56;	author niklas;	state Exp;
branches;
next	1.15.10.2;

1.15.10.2
date	2001.07.04.10.49.19;	author niklas;	state Exp;
branches;
next	1.15.10.3;

1.15.10.3
date	2002.03.28.15.02.01;	author niklas;	state Exp;
branches;
next	1.15.10.4;

1.15.10.4
date	2003.03.28.00.00.20;	author niklas;	state Exp;
branches;
next	1.15.10.5;

1.15.10.5
date	2003.06.07.11.06.06;	author ho;	state Exp;
branches;
next	1.15.10.6;

1.15.10.6
date	2004.02.19.10.57.20;	author niklas;	state Exp;
branches;
next	;

1.21.2.1
date	2002.06.11.03.30.21;	author art;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.11.04.18.02.31;	author art;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2003.05.19.22.36.12;	author tedu;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2003.05.20.04.05.39;	author tedu;	state Exp;
branches;
next	;

1.69.4.1
date	2013.11.12.02.35.03;	author william;	state Exp;
branches;
next	;

1.74.2.1
date	2013.11.12.02.37.04;	author william;	state Exp;
branches;
next	;


desc
@@


1.89
log
@Increase size of the clone bitmap (revised diff after revert). I have
tested this with fuse _and_ drm on amd64 and macppc. Also tested with
cloning bpf (not in the tree) on macppc.

ok mikeb
"looks correct to me" millert

The original commit message is as follows:

Increase size of the clone bitmap. A limit of only 64 device clones
turned out to be too low for the upcoming work on cloning bpf. The new
limit is 1024 device clones. As part of the size increase, the bitmap
has been changed to be allocated separately to avoid bloating all device
nodes, as suggested by guenther, millert and deraadt.

ok millert mikeb
@
text
@/*	$OpenBSD: spec_vnops.c,v 1.88 2016/04/01 11:51:55 mikeb Exp $	*/
/*	$NetBSD: spec_vnops.c,v 1.29 1996/04/22 01:42:38 christos Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)spec_vnops.c	8.8 (Berkeley) 11/21/94
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/buf.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/stat.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/file.h>
#include <sys/disklabel.h>
#include <sys/lockf.h>
#include <sys/poll.h>
#include <sys/dkio.h>
#include <sys/malloc.h>
#include <sys/specdev.h>
#include <sys/unistd.h>

#include <uvm/uvm_extern.h>

#define v_lastr v_specinfo->si_lastr

int	spec_open_clone(struct vop_open_args *);
int	spec_close_clone(struct vop_close_args *);

struct vnode *speclisth[SPECHSZ];

struct vops spec_vops = {
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= spec_badop,
	.vop_mknod	= spec_badop,
	.vop_open	= spec_open,
	.vop_close	= spec_close,
	.vop_access	= spec_access,
	.vop_getattr	= spec_getattr,
	.vop_setattr	= spec_setattr,
	.vop_read	= spec_read,
	.vop_write	= spec_write,
	.vop_ioctl	= spec_ioctl,
	.vop_poll	= spec_poll,
	.vop_kqfilter	= spec_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_fsync	= spec_fsync,
	.vop_remove	= spec_badop,
	.vop_link	= spec_badop,
	.vop_rename	= spec_badop,
	.vop_mkdir	= spec_badop,
	.vop_rmdir	= spec_badop,
	.vop_symlink	= spec_badop,
	.vop_readdir	= spec_badop,
	.vop_readlink	= spec_badop,
	.vop_abortop	= spec_badop,
	.vop_inactive	= spec_inactive,
	.vop_reclaim	= nullop,
	.vop_lock	= vop_generic_lock,
	.vop_unlock	= vop_generic_unlock,
	.vop_islocked	= vop_generic_islocked,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= spec_strategy,
	.vop_print	= spec_print,
	.vop_pathconf	= spec_pathconf,
	.vop_advlock	= spec_advlock,
	.vop_bwrite	= vop_generic_bwrite,
};

/*
 * Open a special file.
 */
int
spec_open(void *v)
{
	struct vop_open_args *ap = v;
	struct proc *p = ap->a_p;
	struct vnode *vp = ap->a_vp;
	struct vnode *bvp;
	dev_t bdev;
	dev_t dev = (dev_t)vp->v_rdev;
	int maj = major(dev);
	int error;

	/*
	 * Don't allow open if fs is mounted -nodev.
	 */
	if (vp->v_mount && (vp->v_mount->mnt_flag & MNT_NODEV))
		return (ENXIO);

	switch (vp->v_type) {

	case VCHR:
		if ((u_int)maj >= nchrdev)
			return (ENXIO);
		if (ap->a_cred != FSCRED && (ap->a_mode & FWRITE)) {
			/*
			 * When running in very secure mode, do not allow
			 * opens for writing of any disk character devices.
			 */
			if (securelevel >= 2 && cdevsw[maj].d_type == D_DISK)
				return (EPERM);
			/*
			 * When running in secure mode, do not allow opens
			 * for writing of /dev/mem, /dev/kmem, or character
			 * devices whose corresponding block devices are
			 * currently mounted.
			 */
			if (securelevel >= 1) {
				if ((bdev = chrtoblk(dev)) != NODEV &&
				    vfinddev(bdev, VBLK, &bvp) &&
				    bvp->v_usecount > 0 &&
				    (error = vfs_mountedon(bvp)))
					return (error);
				if (iskmemdev(dev))
					return (EPERM);
			}
		}
		if (cdevsw[maj].d_type == D_TTY)
			vp->v_flag |= VISTTY;
		if (cdevsw[maj].d_flags & D_CLONE)
			return (spec_open_clone(ap));
		VOP_UNLOCK(vp, p);
		error = (*cdevsw[maj].d_open)(dev, ap->a_mode, S_IFCHR, p);
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
		return (error);

	case VBLK:
		if ((u_int)maj >= nblkdev)
			return (ENXIO);
		/*
		 * When running in very secure mode, do not allow
		 * opens for writing of any disk block devices.
		 */
		if (securelevel >= 2 && ap->a_cred != FSCRED &&
		    (ap->a_mode & FWRITE) && bdevsw[maj].d_type == D_DISK)
			return (EPERM);
		/*
		 * Do not allow opens of block devices that are
		 * currently mounted.
		 */
		if ((error = vfs_mountedon(vp)) != 0)
			return (error);
		return ((*bdevsw[maj].d_open)(dev, ap->a_mode, S_IFBLK, p));
	case VNON:
	case VLNK:
	case VDIR:
	case VREG:
	case VBAD:
	case VFIFO:
	case VSOCK:
		break;
	}
	return (0);
}

/*
 * Vnode op for read
 */
int
spec_read(void *v)
{
	struct vop_read_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct uio *uio = ap->a_uio;
 	struct proc *p = uio->uio_procp;
	struct buf *bp;
	daddr_t bn, nextbn, bscale;
	int bsize;
	struct partinfo dpart;
	size_t n;
	int on, majordev;
	int (*ioctl)(dev_t, u_long, caddr_t, int, struct proc *);
	int error = 0;

#ifdef DIAGNOSTIC
	if (uio->uio_rw != UIO_READ)
		panic("spec_read mode");
	if (uio->uio_segflg == UIO_USERSPACE && uio->uio_procp != curproc)
		panic("spec_read proc");
#endif
	if (uio->uio_resid == 0)
		return (0);

	switch (vp->v_type) {

	case VCHR:
		VOP_UNLOCK(vp, p);
		error = (*cdevsw[major(vp->v_rdev)].d_read)
			(vp->v_rdev, uio, ap->a_ioflag);
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
		return (error);

	case VBLK:
		if (uio->uio_offset < 0)
			return (EINVAL);
		bsize = BLKDEV_IOSIZE;
		if ((majordev = major(vp->v_rdev)) < nblkdev &&
		    (ioctl = bdevsw[majordev].d_ioctl) != NULL &&
		    (*ioctl)(vp->v_rdev, DIOCGPART, (caddr_t)&dpart, FREAD, p) == 0) {
			u_int32_t frag =
			    DISKLABELV1_FFS_FRAG(dpart.part->p_fragblock);
			u_int32_t fsize =
			    DISKLABELV1_FFS_FSIZE(dpart.part->p_fragblock);
			if (dpart.part->p_fstype == FS_BSDFFS && frag != 0 &&
			    fsize != 0)
				bsize = frag * fsize;
		}
		bscale = btodb(bsize);
		do {
			bn = btodb(uio->uio_offset) & ~(bscale - 1);
			on = uio->uio_offset % bsize;
			n = ulmin((bsize - on), uio->uio_resid);
			if (vp->v_lastr + bscale == bn) {
				nextbn = bn + bscale;
				error = breadn(vp, bn, bsize, &nextbn, &bsize,
				    1, &bp);
			} else
				error = bread(vp, bn, bsize, &bp);
			vp->v_lastr = bn;
			n = ulmin(n, bsize - bp->b_resid);
			if (error) {
				brelse(bp);
				return (error);
			}
			error = uiomove((char *)bp->b_data + on, n, uio);
			brelse(bp);
		} while (error == 0 && uio->uio_resid > 0 && n != 0);
		return (error);

	default:
		panic("spec_read type");
	}
	/* NOTREACHED */
}

int
spec_inactive(void *v)
{
	struct vop_inactive_args *ap = v;

	VOP_UNLOCK(ap->a_vp, ap->a_p);
	return (0);
}

/*
 * Vnode op for write
 */
int
spec_write(void *v)
{
	struct vop_write_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct uio *uio = ap->a_uio;
	struct proc *p = uio->uio_procp;
	struct buf *bp;
	daddr_t bn, bscale;
	int bsize;
	struct partinfo dpart;
	size_t n;
	int on, majordev;
	int (*ioctl)(dev_t, u_long, caddr_t, int, struct proc *);
	int error = 0;

#ifdef DIAGNOSTIC
	if (uio->uio_rw != UIO_WRITE)
		panic("spec_write mode");
	if (uio->uio_segflg == UIO_USERSPACE && uio->uio_procp != curproc)
		panic("spec_write proc");
#endif

	switch (vp->v_type) {

	case VCHR:
		VOP_UNLOCK(vp, p);
		error = (*cdevsw[major(vp->v_rdev)].d_write)
			(vp->v_rdev, uio, ap->a_ioflag);
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
		return (error);

	case VBLK:
		if (uio->uio_resid == 0)
			return (0);
		if (uio->uio_offset < 0)
			return (EINVAL);
		bsize = BLKDEV_IOSIZE;
		if ((majordev = major(vp->v_rdev)) < nblkdev &&
		    (ioctl = bdevsw[majordev].d_ioctl) != NULL &&
		    (*ioctl)(vp->v_rdev, DIOCGPART, (caddr_t)&dpart, FREAD, p) == 0) {
			u_int32_t frag =
			    DISKLABELV1_FFS_FRAG(dpart.part->p_fragblock);
			u_int32_t fsize =
			    DISKLABELV1_FFS_FSIZE(dpart.part->p_fragblock);
			if (dpart.part->p_fstype == FS_BSDFFS && frag != 0 &&
			    fsize != 0)
				bsize = frag * fsize;
		}
		bscale = btodb(bsize);
		do {
			bn = btodb(uio->uio_offset) & ~(bscale - 1);
			on = uio->uio_offset % bsize;
			n = ulmin((bsize - on), uio->uio_resid);
			error = bread(vp, bn, bsize, &bp);
			n = ulmin(n, bsize - bp->b_resid);
			if (error) {
				brelse(bp);
				return (error);
			}
			error = uiomove((char *)bp->b_data + on, n, uio);
			if (n + on == bsize)
				bawrite(bp);
			else
				bdwrite(bp);
		} while (error == 0 && uio->uio_resid > 0 && n != 0);
		return (error);

	default:
		panic("spec_write type");
	}
	/* NOTREACHED */
}

/*
 * Device ioctl operation.
 */
int
spec_ioctl(void *v)
{
	struct vop_ioctl_args *ap = v;
	dev_t dev = ap->a_vp->v_rdev;
	int maj = major(dev);

	switch (ap->a_vp->v_type) {

	case VCHR:
		return ((*cdevsw[maj].d_ioctl)(dev, ap->a_command, ap->a_data,
		    ap->a_fflag, ap->a_p));

	case VBLK:
		return ((*bdevsw[maj].d_ioctl)(dev, ap->a_command, ap->a_data,
		    ap->a_fflag, ap->a_p));

	default:
		panic("spec_ioctl");
		/* NOTREACHED */
	}
}

int
spec_poll(void *v)
{
	struct vop_poll_args *ap = v;
	dev_t dev;

	switch (ap->a_vp->v_type) {

	default:
		return (ap->a_events &
		    (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));

	case VCHR:
		dev = ap->a_vp->v_rdev;
		return (*cdevsw[major(dev)].d_poll)(dev, ap->a_events, ap->a_p);
	}
}
int
spec_kqfilter(void *v)
{
	struct vop_kqfilter_args *ap = v;

	dev_t dev;

	dev = ap->a_vp->v_rdev;
	if (cdevsw[major(dev)].d_kqfilter)
		return (*cdevsw[major(dev)].d_kqfilter)(dev, ap->a_kn);
	return (EOPNOTSUPP);
}

/*
 * Synch buffers associated with a block device
 */
int
spec_fsync(void *v)
{
	struct vop_fsync_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct buf *bp;
	struct buf *nbp;
	int s;

	if (vp->v_type == VCHR)
		return (0);
	/*
	 * Flush all dirty buffers associated with a block device.
	 */
loop:
	s = splbio();
	for (bp = LIST_FIRST(&vp->v_dirtyblkhd); bp != NULL; bp = nbp) {
		nbp = LIST_NEXT(bp, b_vnbufs);
		if ((bp->b_flags & B_BUSY))
			continue;
		if ((bp->b_flags & B_DELWRI) == 0)
			panic("spec_fsync: not dirty");
		bremfree(bp);
		buf_acquire(bp);
		splx(s);
		bawrite(bp);
		goto loop;
	}
	if (ap->a_waitfor == MNT_WAIT) {
		vwaitforio (vp, 0, "spec_fsync", 0);

#ifdef DIAGNOSTIC
		if (!LIST_EMPTY(&vp->v_dirtyblkhd)) {
			splx(s);
			vprint("spec_fsync: dirty", vp);
			goto loop;
		}
#endif
	}
	splx(s);
	return (0);
}

int
spec_strategy(void *v)
{
	struct vop_strategy_args *ap = v;
	struct buf *bp = ap->a_bp;
	int maj = major(bp->b_dev);
	
	if (LIST_FIRST(&bp->b_dep) != NULL)
		buf_start(bp);

	(*bdevsw[maj].d_strategy)(bp);
	return (0);
}

/*
 * Device close routine
 */
int
spec_close(void *v)
{
	struct vop_close_args *ap = v;
	struct proc *p = ap->a_p;
	struct vnode *vp = ap->a_vp;
	dev_t dev = vp->v_rdev;
	int (*devclose)(dev_t, int, int, struct proc *);
	int mode, relock, error;

	switch (vp->v_type) {

	case VCHR:
		/*
		 * Hack: a tty device that is a controlling terminal
		 * has a reference from the session structure.
		 * We cannot easily tell that a character device is
		 * a controlling terminal, unless it is the closing
		 * process' controlling terminal.  In that case,
		 * if the reference count is 2 (this last descriptor
		 * plus the session), release the reference from the session.
		 */
		if (vcount(vp) == 2 && p != NULL && p->p_p->ps_pgrp &&
		    vp == p->p_p->ps_pgrp->pg_session->s_ttyvp) {
			vrele(vp);
			p->p_p->ps_pgrp->pg_session->s_ttyvp = NULL;
		}
		if (cdevsw[major(dev)].d_flags & D_CLONE)
			return (spec_close_clone(ap));
		/*
		 * If the vnode is locked, then we are in the midst
		 * of forcably closing the device, otherwise we only
		 * close on last reference.
		 */
		if (vcount(vp) > 1 && (vp->v_flag & VXLOCK) == 0)
			return (0);
		devclose = cdevsw[major(dev)].d_close;
		mode = S_IFCHR;
		break;

	case VBLK:
		/*
		 * On last close of a block device (that isn't mounted)
		 * we must invalidate any in core blocks, so that
		 * we can, for instance, change floppy disks. In order to do
		 * that, we must lock the vnode. If we are coming from
		 * vclean(), the vnode is already locked.
		 */
		if (!(vp->v_flag & VXLOCK))
			vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
		error = vinvalbuf(vp, V_SAVE, ap->a_cred, p, 0, 0);
		if (!(vp->v_flag & VXLOCK))
			VOP_UNLOCK(vp, p);
		if (error)
			return (error);
		/*
		 * We do not want to really close the device if it
		 * is still in use unless we are trying to close it
		 * forcibly. Since every use (buffer, vnode, swap, cmap)
		 * holds a reference to the vnode, and because we mark
		 * any other vnodes that alias this device, when the
		 * sum of the reference counts on all the aliased
		 * vnodes descends to one, we are on last close.
		 */
		if (vcount(vp) > 1 && (vp->v_flag & VXLOCK) == 0)
			return (0);
		devclose = bdevsw[major(dev)].d_close;
		mode = S_IFBLK;
		break;

	default:
		panic("spec_close: not special");
	}

	/* release lock if held and this isn't coming from vclean() */
	relock = VOP_ISLOCKED(vp) && !(vp->v_flag & VXLOCK);
	if (relock)
		VOP_UNLOCK(vp, p);
	error = (*devclose)(dev, ap->a_fflag, mode, p);
	if (relock)
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	return (error);
}

int
spec_getattr(void *v)
{
	struct vop_getattr_args	*ap = v;
	struct vnode		*vp = ap->a_vp;

	if (!(vp->v_flag & VCLONE))
		return (EBADF);

	return (VOP_GETATTR(vp->v_specparent, ap->a_vap, ap->a_cred, ap->a_p));
}

int
spec_setattr(void *v)
{
	struct vop_getattr_args	*ap = v;
	struct proc		*p = ap->a_p;
	struct vnode		*vp = ap->a_vp;
	int			 error;

	if (!(vp->v_flag & VCLONE))
		return (EBADF);

	vn_lock(vp->v_specparent, LK_EXCLUSIVE|LK_RETRY, p);
	error = VOP_SETATTR(vp->v_specparent, ap->a_vap, ap->a_cred, p);
	VOP_UNLOCK(vp, p);

	return (error);
}

int
spec_access(void *v)
{
	struct vop_access_args	*ap = v;
	struct vnode		*vp = ap->a_vp;

	if (!(vp->v_flag & VCLONE))
		return (EBADF);

	return (VOP_ACCESS(vp->v_specparent, ap->a_mode, ap->a_cred, ap->a_p));
}

/*
 * Print out the contents of a special device vnode.
 */
int
spec_print(void *v)
{
	struct vop_print_args *ap = v;

	printf("tag VT_NON, dev %d, %d\n", major(ap->a_vp->v_rdev),
		minor(ap->a_vp->v_rdev));
	return 0;
}

/*
 * Return POSIX pathconf information applicable to special devices.
 */
int
spec_pathconf(void *v)
{
	struct vop_pathconf_args *ap = v;
	int error = 0;

	switch (ap->a_name) {
	case _PC_LINK_MAX:
		*ap->a_retval = LINK_MAX;
		break;
	case _PC_MAX_CANON:
		*ap->a_retval = MAX_CANON;
		break;
	case _PC_MAX_INPUT:
		*ap->a_retval = MAX_INPUT;
		break;
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		break;
	case _PC_VDISABLE:
		*ap->a_retval = _POSIX_VDISABLE;
		break;
	case _PC_TIMESTAMP_RESOLUTION:
		*ap->a_retval = 1;
		break;
	default:
		error = EINVAL;
		break;
	}

	return (error);
}

/*
 * Special device advisory byte-level locks.
 */
int
spec_advlock(void *v)
{
	struct vop_advlock_args *ap = v;
	struct vnode *vp = ap->a_vp;

	return (lf_advlock(&vp->v_speclockf, (off_t)0, ap->a_id,
		ap->a_op, ap->a_fl, ap->a_flags));
}

/*
 * Special device bad operation
 */
int
spec_badop(void *v)
{

	panic("spec_badop called");
	/* NOTREACHED */
}

/*
 * Copyright (c) 2006 Pedro Martelletto <pedro@@ambientworks.net>
 * Copyright (c) 2006 Thordur Bjornsson <thib@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifdef	CLONE_DEBUG
#define	DNPRINTF(m...)	do { printf(m);  } while (0)
#else
#define	DNPRINTF(m...)	/* nothing */
#endif

int
spec_open_clone(struct vop_open_args *ap)
{
	struct vnode *cvp, *vp = ap->a_vp;
	struct cloneinfo *cip;
	int error, i;

	DNPRINTF("cloning vnode\n");

	if (minor(vp->v_rdev) >= (1 << CLONE_SHIFT))
		return (ENXIO);

	for (i = 1; i < CLONE_MAPSZ * NBBY; i++)
		if (isclr(vp->v_specbitmap, i)) {
			setbit(vp->v_specbitmap, i);
			break;
		}

	if (i == CLONE_MAPSZ * NBBY)
		return (EBUSY); /* too many open instances */

	error = cdevvp(makedev(major(vp->v_rdev),
	    (i << CLONE_SHIFT) | minor(vp->v_rdev)), &cvp);
	if (error) {
		clrbit(vp->v_specbitmap, i);
		return (error); /* out of vnodes */
	}

	VOP_UNLOCK(vp, ap->a_p);

	error = cdevsw[major(vp->v_rdev)].d_open(cvp->v_rdev, ap->a_mode,
	    S_IFCHR, ap->a_p);

	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, ap->a_p);

	if (error) {
		vput(cvp);
		clrbit(vp->v_specbitmap, i);
		return (error); /* device open failed */
	}

	cvp->v_flag |= VCLONE;

	cip = malloc(sizeof(struct cloneinfo), M_TEMP, M_WAITOK);
	cip->ci_data = vp->v_data;
	cip->ci_vp = cvp;

	cvp->v_specparent = vp;
	vp->v_flag |= VCLONED;
	vp->v_data = cip;

	DNPRINTF("clone of vnode %p is vnode %p\n", vp, cvp);

	return (0); /* device cloned */
}

int
spec_close_clone(struct vop_close_args *ap)
{
	struct vnode *pvp, *vp = ap->a_vp;
	int error;

	error = cdevsw[major(vp->v_rdev)].d_close(vp->v_rdev, ap->a_fflag,
	    S_IFCHR, ap->a_p);
	if (error)
		return (error); /* device close failed */

	pvp = vp->v_specparent; /* get parent device */
	clrbit(pvp->v_specbitmap, minor(vp->v_rdev) >> CLONE_SHIFT);
	vrele(pvp);

	return (0); /* clone closed */
}
@


1.88
log
@Revert the clone bitmap enlargement change
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.86 2016/03/19 12:04:15 natano Exp $	*/
d710 1
a710 1
	for (i = 1; i < sizeof(vp->v_specbitmap) * NBBY; i++)
d716 1
a716 1
	if (i == sizeof(vp->v_specbitmap) * NBBY)
@


1.87
log
@Increase size of the clone bitmap. A limit of only 64 device clones
turned out to be too low for the upcoming work on cloning bpf. The new
limit is 1024 device clones. As part of the size increase, the bitmap
has been changed to be allocated separately to avoid bloating all device
nodes, as suggested by guenther, millert and deraadt.

ok millert mikeb
@
text
@d710 1
a710 1
	for (i = 1; i < CLONE_MAP_SZ * NBBY; i++) {
a714 1
	}
d716 1
a716 1
	if (i == CLONE_MAP_SZ * NBBY)
@


1.86
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.85 2016/01/19 19:13:38 stefan Exp $	*/
d710 1
a710 1
	for (i = 1; i < sizeof(vp->v_specbitmap) * NBBY; i++)
d715 1
d717 1
a717 1
	if (i == sizeof(vp->v_specbitmap) * NBBY)
@


1.85
log
@Convert min() and uiomovei() to ulmin() and uiomove(),
preventing integer truncation.

Diff from Martin Natano

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.84 2015/12/05 10:11:53 tedu Exp $	*/
d157 1
a157 1
		VOP_UNLOCK(vp, 0, p);
d222 1
a222 1
		VOP_UNLOCK(vp, 0, p);
d276 1
a276 1
	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
d309 1
a309 1
		VOP_UNLOCK(vp, 0, p);
d528 1
a528 1
			VOP_UNLOCK(vp, 0, p);
d553 1
a553 1
		VOP_UNLOCK(vp, 0, p);
d585 1
a585 1
	VOP_UNLOCK(vp, 0, p);
d726 1
a726 1
	VOP_UNLOCK(vp, 0, ap->a_p);
@


1.84
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.83 2015/02/10 21:56:09 miod Exp $	*/
d205 2
a206 1
	int n, on, majordev;
d247 1
a247 1
			n = min((bsize - on), uio->uio_resid);
d255 1
a255 1
			n = min(n, bsize - bp->b_resid);
d260 1
a260 1
			error = uiomovei((char *)bp->b_data + on, n, uio);
d294 2
a295 1
	int n, on, majordev;
d336 1
a336 1
			n = min((bsize - on), uio->uio_resid);
d338 1
a338 1
			n = min(n, bsize - bp->b_resid);
d343 1
a343 1
			error = uiomovei((char *)bp->b_data + on, n, uio);
@


1.83
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.82 2014/12/29 05:29:27 miod Exp $	*/
a664 1
/*ARGSUSED*/
@


1.82
log
@Explicitely include <uvm/uvm_extern.h> in order to build on variable page size
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.81 2014/12/16 18:30:04 tedu Exp $	*/
d259 1
a259 1
			error = uiomove((char *)bp->b_data + on, n, uio);
d341 1
a341 1
			error = uiomove((char *)bp->b_data + on, n, uio);
@


1.81
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.80 2014/11/03 21:28:35 tedu Exp $	*/
d56 2
@


1.80
log
@include sys/unistd.h where needed instead of indirect reliance. ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.79 2014/09/13 16:06:37 doug Exp $	*/
d44 1
@


1.79
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.78 2013/10/30 03:16:49 guenther Exp $	*/
d54 1
@


1.78
log
@Use local variables for ap->a_p where appropriate.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.77 2013/10/29 03:11:08 guenther Exp $	*/
d426 1
a426 2
	for (bp = LIST_FIRST(&vp->v_dirtyblkhd);
	    bp != LIST_END(&vp->v_dirtyblkhd); bp = nbp) {
@


1.77
log
@Unlock the vnode while calling a device's d_close routine, except when
it's locked for changing the type (i.e., revoke()).  We already unlock
it while calling the d_open, d_read, and d_write routines and this is
safe for the same reason: the device routines operate at a lower level
and don't need the protection of the vnode locks.  This is important
as the device close routine may block indefinitely.

"don't see anything wrong" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.76 2013/08/06 08:22:37 kettenis Exp $	*/
d154 1
a154 1
		error = (*cdevsw[maj].d_open)(dev, ap->a_mode, S_IFCHR, ap->a_p);
d174 1
a174 1
		return ((*bdevsw[maj].d_open)(dev, ap->a_mode, S_IFBLK, ap->a_p));
d493 2
a494 2
		if (vcount(vp) == 2 && ap->a_p && ap->a_p->p_p->ps_pgrp &&
		    vp == ap->a_p->p_p->ps_pgrp->pg_session->s_ttyvp) {
d496 1
a496 1
			ap->a_p->p_p->ps_pgrp->pg_session->s_ttyvp = NULL;
d520 2
a521 2
			vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, ap->a_p);
		error = vinvalbuf(vp, V_SAVE, ap->a_cred, ap->a_p, 0, 0);
d523 1
a523 1
			VOP_UNLOCK(vp, 0, ap->a_p);
d571 1
d578 3
a580 3
	vn_lock(vp->v_specparent, LK_EXCLUSIVE|LK_RETRY, ap->a_p);
	error = VOP_SETATTR(vp->v_specparent, ap->a_vap, ap->a_cred, ap->a_p);
	VOP_UNLOCK(vp, 0, ap->a_p);
@


1.76
log
@Make it possible to have multiple clonable devices per major.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.75 2013/07/29 18:51:42 kettenis Exp $	*/
d475 1
d479 1
a479 1
	int mode, error;
d545 8
a552 1
	return ((*devclose)(dev, ap->a_fflag, mode, ap->a_p));
@


1.75
log
@Do a proper cleanup in the error path when opening a clonable device fails.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.74 2013/07/09 15:37:43 beck Exp $	*/
d694 3
d706 2
a707 1
	error = cdevvp(makedev(major(vp->v_rdev), i), &cvp);
d753 1
a753 1
	clrbit(pvp->v_specbitmap, minor(vp->v_rdev));
@


1.74
log
@back out the cache flipper temporarily to work out of tree.
will come back soon.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.72 2013/06/11 16:42:16 deraadt Exp $	*/
d704 2
a705 1
	if (error)
d707 1
d717 3
a719 2
		 clrbit(vp->v_specbitmap, i);
		 return (error); /* device open failed */
@


1.74.2.1
log
@MFC:

This is http://ftp.openbsd.org/pub/OpenBSD/patches/5.4/common/003_vnode.patch

An unprivileged user may hang the system.

requested by dcoppa
fix by guenther
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.74 2013/07/09 15:37:43 beck Exp $	*/
a474 1
	struct proc *p = ap->a_p;
d478 1
a478 1
	int mode, relock, error;
d544 1
a544 8
	/* release lock if held and this isn't coming from vclean() */
	relock = VOP_ISLOCKED(vp) && !(vp->v_flag & VXLOCK);
	if (relock)
		VOP_UNLOCK(vp, 0, p);
	error = (*devclose)(dev, ap->a_fflag, mode, p);
	if (relock)
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	return (error);
@


1.73
log
@High memory page flipping for the buffer cache.

This change splits the buffer cache free lists into lists of dma reachable
buffers and high memory buffers based on the ranges returned by pmemrange.
Buffers move from dma to high memory as they age, but are flipped to dma
reachable memory if IO is needed to/from and high mem buffer. The total
amount of buffers  allocated is now bufcachepercent of both the dma and
the high memory region.

This change allows the use of large buffer caches on amd64 using more than
4 GB of memory

ok tedu@@ krw@@ - testing by many.
@
text
@d460 1
a460 3

	if (!ISSET(bp->b_flags, B_DMA) && ISSET(bp->b_flags, B_BC))
		panic("bogus buf %p passed to spec_strategy", bp);
@


1.72
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.71 2013/03/28 03:29:44 guenther Exp $	*/
d460 3
a462 1
	
@


1.71
log
@Add support for _PC_TIMESTAMP_RESOLUTION for ffs/mfs, cd9600, ext2,
msdos, NFS, fifos and devices, plus support for querying it in
getconf(2) and the requisite pathconf(2) manpage blurb

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.70 2013/03/28 02:08:39 guenther Exp $	*/
d198 1
a198 1
	daddr64_t bn, nextbn, bscale;
d286 1
a286 1
	daddr64_t bn, bscale;
@


1.70
log
@Handle the pathconf _PC_PATH_MAX, _PC_PIPE_BUF, _PC_ASYNC_IO,
_PC_PRIO_IO, and _PC_SYNC_IO names in VOP_PATHCONF(), as they're
fs-independent for us.  Since we don't support latter three on any
fs, we can also define the related _POSIX_{ASYNC,PRIO,SYNC}_IO
symbols in <unistd.h> (via sys/unistd.h) with value -1.

Also, zap pointless tty-only values from procfs(!).

ok beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.69 2012/06/20 17:30:22 matthew Exp $	*/
d625 3
@


1.69
log
@Cleanup our filesystem pathconf() code a little bit to make it easier
to diff against FreeBSD's.

From Brad; no object file change on amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.68 2011/07/30 10:26:03 jsing Exp $	*/
a618 3
		break;
	case _PC_PIPE_BUF:
		*ap->a_retval = PIPE_BUF;
@


1.69.4.1
log
@MFC:

This is http://ftp.openbsd.org/pub/OpenBSD/patches/5.3/common/010_vnode.patch

An unprivileged user may hang the system.

requested by dcoppa
fix by guenther
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.69 2012/06/20 17:30:22 matthew Exp $	*/
a474 1
	struct proc *p = ap->a_p;
d478 1
a478 1
	int mode, relock, error;
d544 1
a544 8
	/* release lock if held and this isn't coming from vclean() */
	relock = VOP_ISLOCKED(vp) && !(vp->v_flag & VXLOCK);
	if (relock)
		VOP_UNLOCK(vp, 0, p);
	error = (*devclose)(dev, ap->a_fflag, mode, p);
	if (relock)
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	return (error);
@


1.68
log
@When using rthreads, the thread that calls exit will be the last one to
actually exit. This means that the main thread will exit and free the
process group, which results in the thread dereferencing a null pointer
when it is woken back up. Avoid this by checking that the ps_pgrp is not
null before deferefencing it. Also expand the ps_session macro to avoid
hiding the dereference.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.66 2011/07/04 20:51:19 deraadt Exp $	*/
d608 1
d613 1
a613 1
		return (0);
d616 1
a616 1
		return (0);
d619 1
a619 1
		return (0);
d622 1
a622 1
		return (0);
d625 1
a625 1
		return (0);
d628 1
a628 1
		return (0);
d630 2
a631 1
		return (EINVAL);
d633 2
a634 1
	/* NOTREACHED */
@


1.67
log
@clean up some left over decls from before the code moved to one file
ok guenther
@
text
@d492 2
a493 2
		if (vcount(vp) == 2 && ap->a_p &&
		    vp == ap->a_p->p_p->ps_session->s_ttyvp) {
d495 1
a495 1
			ap->a_p->p_p->ps_session->s_ttyvp = NULL;
@


1.66
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.1 2011/07/04 20:35:35 deraadt Exp $	*/
d56 3
@


1.65
log
@Fix another kqfilter return value.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.64 2011/07/04 16:52:41 nicm Exp $	*/
d52 2
a53 2

#include <miscfs/specfs/specdev.h>
d654 90
@


1.64
log
@Nuke the useless D_KQFILTER flag and just check that d_kqfilter is
filled in. Move D_CLONE down to 0x0001 as suggested by thib.

ok deraadt thib
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.63 2011/07/04 04:30:41 tedu Exp $	*/
d401 1
a401 1
	return (1);
@


1.63
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.62 2011/04/05 14:14:07 thib Exp $	*/
d399 1
a399 1
	if (cdevsw[major(dev)].d_flags & D_KQFILTER)
@


1.62
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.61 2010/12/21 20:14:43 thib Exp $	*/
d243 1
a243 1
				    1, NOCRED, &bp);
d245 1
a245 1
				error = bread(vp, bn, bsize, NOCRED, &bp);
d328 1
a328 1
			error = bread(vp, bn, bsize, NOCRED, &bp);
@


1.61
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.60 2010/09/10 16:34:08 thib Exp $	*/
a59 1
	.vop_default	= eopnotsupp,
@


1.60
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.59 2010/09/06 23:44:10 thib Exp $	*/
d59 37
a95 39
int (**spec_vnodeop_p)(void *);
struct vnodeopv_entry_desc spec_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, vop_generic_lookup },
	{ &vop_create_desc, spec_badop },
	{ &vop_mknod_desc, spec_badop },
	{ &vop_open_desc, spec_open },
	{ &vop_close_desc, spec_close },
	{ &vop_access_desc, spec_access },
	{ &vop_getattr_desc, spec_getattr },
	{ &vop_setattr_desc, spec_setattr },
	{ &vop_read_desc, spec_read },
	{ &vop_write_desc, spec_write },
	{ &vop_ioctl_desc, spec_ioctl },
	{ &vop_poll_desc, spec_poll },
	{ &vop_kqfilter_desc, spec_kqfilter },
	{ &vop_revoke_desc, vop_generic_revoke },
	{ &vop_fsync_desc, spec_fsync },
	{ &vop_remove_desc, spec_badop },
	{ &vop_link_desc, spec_badop },
	{ &vop_rename_desc, spec_badop },
	{ &vop_mkdir_desc, spec_badop },
	{ &vop_rmdir_desc, spec_badop },
	{ &vop_symlink_desc, spec_badop },
	{ &vop_readdir_desc, spec_badop },
	{ &vop_readlink_desc, spec_badop },
	{ &vop_abortop_desc, spec_badop },
	{ &vop_inactive_desc, spec_inactive },
	{ &vop_reclaim_desc, nullop },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_bmap_desc, vop_generic_bmap },
	{ &vop_strategy_desc, spec_strategy },
	{ &vop_print_desc, spec_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_pathconf_desc, spec_pathconf },
	{ &vop_advlock_desc, spec_advlock },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a96 10
struct vnodeopv_desc spec_vnodeop_opv_desc =
	{ &spec_vnodeop_p, spec_vnodeop_entries };

int
spec_vnoperate(void *v)
{
	struct vop_generic_args *ap = v;

	return (VOCALL(spec_vnodeop_p, ap->a_desc->vdesc_offset, ap));
}
@


1.59
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.58 2010/07/26 01:56:27 guenther Exp $	*/
d59 39
a97 37
struct vops spec_vops = {
	.vop_default	= eopnotsupp,
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= spec_badop,
	.vop_mknod	= spec_badop,
	.vop_open	= spec_open,
	.vop_close	= spec_close,
	.vop_access	= spec_access,
	.vop_getattr	= spec_getattr,
	.vop_setattr	= spec_setattr,
	.vop_read	= spec_read,
	.vop_write	= spec_write,
	.vop_ioctl	= spec_ioctl,
	.vop_poll	= spec_poll,
	.vop_kqfilter	= spec_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_fsync	= spec_fsync,
	.vop_remove	= spec_badop,
	.vop_link	= spec_badop,
	.vop_rename	= spec_badop,
	.vop_mkdir	= spec_badop,
	.vop_rmdir	= spec_badop,
	.vop_symlink	= spec_badop,
	.vop_readdir	= spec_badop,
	.vop_readlink	= spec_badop,
	.vop_abortop	= spec_badop,
	.vop_inactive	= spec_inactive,
	.vop_reclaim	= nullop,
	.vop_lock	= vop_generic_lock,
	.vop_unlock	= vop_generic_unlock,
	.vop_islocked	= vop_generic_islocked,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= spec_strategy,
	.vop_print	= spec_print,
	.vop_pathconf	= spec_pathconf,
	.vop_advlock	= spec_advlock,
	.vop_bwrite	= vop_generic_bwrite,
d99 10
@


1.58
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.57 2010/05/18 04:41:14 dlg Exp $	*/
d59 37
a95 39
int (**spec_vnodeop_p)(void *);
struct vnodeopv_entry_desc spec_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, vop_generic_lookup },
	{ &vop_create_desc, spec_badop },
	{ &vop_mknod_desc, spec_badop },
	{ &vop_open_desc, spec_open },
	{ &vop_close_desc, spec_close },
	{ &vop_access_desc, spec_access },
	{ &vop_getattr_desc, spec_getattr },
	{ &vop_setattr_desc, spec_setattr },
	{ &vop_read_desc, spec_read },
	{ &vop_write_desc, spec_write },
	{ &vop_ioctl_desc, spec_ioctl },
	{ &vop_poll_desc, spec_poll },
	{ &vop_kqfilter_desc, spec_kqfilter },
	{ &vop_revoke_desc, vop_generic_revoke },
	{ &vop_fsync_desc, spec_fsync },
	{ &vop_remove_desc, spec_badop },
	{ &vop_link_desc, spec_badop },
	{ &vop_rename_desc, spec_badop },
	{ &vop_mkdir_desc, spec_badop },
	{ &vop_rmdir_desc, spec_badop },
	{ &vop_symlink_desc, spec_badop },
	{ &vop_readdir_desc, spec_badop },
	{ &vop_readlink_desc, spec_badop },
	{ &vop_abortop_desc, spec_badop },
	{ &vop_inactive_desc, spec_inactive },
	{ &vop_reclaim_desc, nullop },
	{ &vop_lock_desc, vop_generic_lock },
	{ &vop_unlock_desc, vop_generic_unlock },
	{ &vop_bmap_desc, vop_generic_bmap },
	{ &vop_strategy_desc, spec_strategy },
	{ &vop_print_desc, spec_print },
	{ &vop_islocked_desc, vop_generic_islocked },
	{ &vop_pathconf_desc, spec_pathconf },
	{ &vop_advlock_desc, spec_advlock },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a96 10
struct vnodeopv_desc spec_vnodeop_opv_desc =
	{ &spec_vnodeop_p, spec_vnodeop_entries };

int
spec_vnoperate(void *v)
{
	struct vop_generic_args *ap = v;

	return (VOCALL(spec_vnodeop_p, ap->a_desc->vdesc_offset, ap));
}
@


1.57
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.56 2009/08/13 15:00:14 jasper Exp $	*/
d503 1
a503 1
		    vp == ap->a_p->p_session->s_ttyvp) {
d505 1
a505 1
			ap->a_p->p_session->s_ttyvp = NULL;
@


1.56
log
@- remove super-obvious comments from $fs_vnodeop_entries[]

prodded by and ok thib@@
agreed by art@@ and blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.55 2009/06/25 15:49:26 thib Exp $	*/
d51 1
@


1.55
log
@backout the buf_acquire() does the bremfree() since all callers
where doing bremfree() befure calling buf_acquire().

This is causing us headache pinning down a bug that showed up
when deraadt@@ too cvs to current, and will have to be done
anyway as a preperation for backouts.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.53 2008/07/24 18:48:18 thib Exp $	*/
d61 35
a95 35
	{ &vop_lookup_desc, vop_generic_lookup },	/* lookup */
	{ &vop_create_desc, spec_badop },		/* create */
	{ &vop_mknod_desc, spec_badop },		/* mknod */
	{ &vop_open_desc, spec_open },			/* open */
	{ &vop_close_desc, spec_close },		/* close */
	{ &vop_access_desc, spec_access },		/* access */
	{ &vop_getattr_desc, spec_getattr },		/* getattr */
	{ &vop_setattr_desc, spec_setattr },		/* setattr */
	{ &vop_read_desc, spec_read },			/* read */
	{ &vop_write_desc, spec_write },		/* write */
	{ &vop_ioctl_desc, spec_ioctl },		/* ioctl */
	{ &vop_poll_desc, spec_poll },			/* poll */
	{ &vop_kqfilter_desc, spec_kqfilter },		/* kqfilter */
	{ &vop_revoke_desc, vop_generic_revoke },	/* revoke */
	{ &vop_fsync_desc, spec_fsync },		/* fsync */
	{ &vop_remove_desc, spec_badop },		/* remove */
	{ &vop_link_desc, spec_badop },			/* link */
	{ &vop_rename_desc, spec_badop },		/* rename */
	{ &vop_mkdir_desc, spec_badop },		/* mkdir */
	{ &vop_rmdir_desc, spec_badop },		/* rmdir */
	{ &vop_symlink_desc, spec_badop },		/* symlink */
	{ &vop_readdir_desc, spec_badop },		/* readdir */
	{ &vop_readlink_desc, spec_badop },		/* readlink */
	{ &vop_abortop_desc, spec_badop },		/* abortop */
	{ &vop_inactive_desc, spec_inactive },		/* inactive */
	{ &vop_reclaim_desc, nullop },			/* reclaim */
	{ &vop_lock_desc, vop_generic_lock },		/* lock */
	{ &vop_unlock_desc, vop_generic_unlock },	/* unlock */
	{ &vop_bmap_desc, vop_generic_bmap },		/* bmap */
	{ &vop_strategy_desc, spec_strategy },		/* strategy */
	{ &vop_print_desc, spec_print },		/* print */
	{ &vop_islocked_desc, vop_generic_islocked },	/* islocked */
	{ &vop_pathconf_desc, spec_pathconf },		/* pathconf */
	{ &vop_advlock_desc, spec_advlock },		/* advlock */
	{ &vop_bwrite_desc, vop_generic_bwrite },	/* bwrite */
@


1.54
log
@All caller of buf_acquire were doing bremfree before the call.
Just put it in the buf_acquire function.
oga@@ ok
@
text
@d442 1
@


1.53
log
@remove a bunch of bogus ARGSUSED
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.52 2008/06/12 06:58:40 deraadt Exp $	*/
a441 1
		bremfree(bp);
@


1.52
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.50 2008/06/10 20:14:36 beck Exp $	*/
a111 1
/* ARGSUSED */
a198 1
/* ARGSUSED */
a286 1
/* ARGSUSED */
a362 1
/* ARGSUSED */
a385 1
/* ARGSUSED */
a402 1
/* ARGSUSED */
a418 1
/* ARGSUSED */
a479 1
/* ARGSUSED */
a645 1
/* ARGSUSED */
@


1.51
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.49 2008/05/08 17:45:45 thib Exp $	*/
d450 1
a450 1
		bp->b_flags |= B_BUSY;
@


1.50
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@d450 1
a450 1
		buf_acquire(bp);
@


1.49
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.48 2008/05/03 14:41:29 thib Exp $	*/
d450 1
a450 1
		bp->b_flags |= B_BUSY;
@


1.48
log
@Introduce vop_generic_bmap(); use it where applicable.
one thing of note, fifofs changes in that its bmap now
sets the runp too 0, but that was an oversight in the
old code.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.47 2008/04/14 10:15:50 thib Exp $	*/
d60 1
a60 1
	{ &vop_default_desc, vn_default_error },
@


1.47
log
@garbage collect the now unused spec_ebadf();

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.46 2008/04/12 13:32:03 thib Exp $	*/
d89 1
a89 1
	{ &vop_bmap_desc, spec_bmap },			/* bmap */
a480 18
	return (0);
}

/*
 * This is a noop, simply returning what one has been given.
 */
int
spec_bmap(void *v)
{
	struct vop_bmap_args *ap = v;

	if (ap->a_vpp != NULL)
		*ap->a_vpp = ap->a_vp;
	if (ap->a_bnp != NULL)
		*ap->a_bnp = ap->a_bn;
	if (ap->a_runp != NULL)
		*ap->a_runp = 0;
	
@


1.46
log
@remove useless defines for the vnode operations, and instead
init the op array functions with whatever the define was set
too.

ok dlg@@,blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.45 2008/04/08 14:46:45 thib Exp $	*/
a680 11
}

/*
 * Special device failed operation
 */
/*ARGSUSED*/
int
spec_ebadf(void *v)
{

	return (EBADF);
@


1.45
log
@bring cloning up too date; Munge it so it will work with atleast
oga@@'s upcoming DRM changes and too some degree ratchov@@'s audio
work. It still works for bpf's though.

Parts from ratchov@@; fstat(1) parts from Pedro Martelletto;
tested by many, ok'ed by a few;
"get going with cloning" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.44 2007/12/27 13:59:12 thib Exp $	*/
d62 2
a63 2
	{ &vop_create_desc, spec_create },		/* create */
	{ &vop_mknod_desc, spec_mknod },		/* mknod */
d74 1
a74 1
	{ &vop_revoke_desc, spec_revoke },              /* revoke */
d76 9
a84 9
	{ &vop_remove_desc, spec_remove },		/* remove */
	{ &vop_link_desc, spec_link },			/* link */
	{ &vop_rename_desc, spec_rename },		/* rename */
	{ &vop_mkdir_desc, spec_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, spec_rmdir },		/* rmdir */
	{ &vop_symlink_desc, spec_symlink },		/* symlink */
	{ &vop_readdir_desc, spec_readdir },		/* readdir */
	{ &vop_readlink_desc, spec_readlink },		/* readlink */
	{ &vop_abortop_desc, spec_abortop },		/* abortop */
d86 3
a88 3
	{ &vop_reclaim_desc, spec_reclaim },		/* reclaim */
	{ &vop_lock_desc, spec_lock },			/* lock */
	{ &vop_unlock_desc, spec_unlock },		/* unlock */
d92 1
a92 1
	{ &vop_islocked_desc, spec_islocked },		/* islocked */
d95 1
a95 1
	{ &vop_bwrite_desc, spec_bwrite },		/* bwrite */
@


1.44
log
@fifofs, deadfs and specfs all have the same "trivial lookup routine that
always fails". Introduce vop_generic_lookup(), which is a trivial lookup
routine that always fails and use that instead, zap the redundant copies.

ok toby@@, tedu@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.43 2007/06/18 08:30:07 jasper Exp $	*/
d532 2
a540 2
		if (cdevsw[major(dev)].d_flags & D_CLONE)
			return (spec_close_clone(ap));
d580 41
@


1.43
log
@ansify/de-register.
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.42 2007/06/02 00:45:21 thib Exp $	*/
d61 1
a61 1
	{ &vop_lookup_desc, spec_lookup },		/* lookup */
a106 12
}

/*
 * Trivial lookup routine that always fails.
 */
int
spec_lookup(void *v)
{
	struct vop_lookup_args *ap = v;

	*ap->a_vpp = NULL;
	return (ENOTDIR);
@


1.42
log
@daddr_t -> daddr64_t for specfs. convert some variables
to proper types along the way (ints), fixes a subtle bug
wich otto@@ pointed me at.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.41 2007/06/01 23:47:57 deraadt Exp $	*/
d113 1
a113 2
spec_lookup(v)
	void *v;
d126 1
a126 2
spec_open(v)
	void *v;
d134 1
a134 1
	register int maj = major(dev);
d214 1
a214 2
spec_read(v)
	void *v;
d217 2
a218 2
	register struct vnode *vp = ap->a_vp;
	register struct uio *uio = ap->a_uio;
d290 1
a290 2
spec_inactive(v)
	void *v;
d303 1
a303 2
spec_write(v)
	void *v;
d306 2
a307 2
	register struct vnode *vp = ap->a_vp;
	register struct uio *uio = ap->a_uio;
d380 1
a380 2
spec_ioctl(v)
	void *v;
d404 1
a404 2
spec_poll(v)
	void *v;
d407 1
a407 1
	register dev_t dev;
d422 1
a422 2
spec_kqfilter(v)
	void *v;
d439 1
a439 2
spec_fsync(v)
	void *v;
d442 2
a443 2
	register struct vnode *vp = ap->a_vp;
	register struct buf *bp;
d483 1
a483 2
spec_strategy(v)
	void *v;
d500 1
a500 2
spec_bmap(v)
	void *v;
d519 1
a519 2
spec_close(v)
	void *v;
d522 1
a522 1
	register struct vnode *vp = ap->a_vp;
d598 1
a598 2
spec_print(v)
	void *v;
d611 1
a611 2
spec_pathconf(v)
	void *v;
d645 1
a645 2
spec_advlock(v)
	void *v;
d648 1
a648 1
	register struct vnode *vp = ap->a_vp;
d659 1
a659 2
spec_ebadf(v)
	void *v;
d670 1
a670 2
spec_badop(v)
	void *v;
@


1.41
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.40 2007/05/29 06:28:15 otto Exp $	*/
d224 2
a225 2
	daddr64_t bn, nextbn;
	long bsize, bscale;
d268 1
a268 1
			n = min((unsigned)(bsize - on), uio->uio_resid);
d271 2
a272 2
				error = breadn(vp, bn, (int)bsize, &nextbn,
					(int *)&bsize, 1, NOCRED, &bp);
d274 1
a274 1
				error = bread(vp, bn, (int)bsize, NOCRED, &bp);
d315 2
a316 2
	daddr_t bn;
	long bsize, bscale;
d359 1
a359 1
			n = min((unsigned)(bsize - on), uio->uio_resid);
@


1.40
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.39 2007/04/10 19:02:26 thib Exp $	*/
d116 1
a116 5
	struct vop_lookup_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
	} */ *ap = v;
d130 1
a130 6
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d219 1
a219 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d296 1
a296 4
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
d310 1
a310 6
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d388 1
a388 8
	struct vop_ioctl_args /* {
		struct vnode *a_vp;
		u_long a_command;
		caddr_t  a_data;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d413 1
a413 5
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int  a_events;
		struct proc *a_p;
	} */ *ap = v;
d432 1
a432 4
	struct vop_kqfilter_args /* {
		struct vnode *a_vp;
		struct knote *a_kn;
	} */ *ap = v;
d450 1
a450 6
	struct vop_fsync_args /* {
		struct vnode *a_vp;
		struct ucred *a_cred;
		int  a_waitfor;
		struct proc *a_p;
	} */ *ap = v;
d495 1
a495 3
	struct vop_strategy_args /* {
		struct buf *a_bp;
	} */ *ap = v;
d513 1
a513 7
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr_t  a_bn;
		struct vnode **a_vpp;
		daddr_t *a_bnp;
		int *a_runp;
	} */ *ap = v;
d533 1
a533 6
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d613 1
a613 3
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d627 1
a627 5
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		register_t *a_retval;
	} */ *ap = v;
d662 1
a662 8
	struct vop_advlock_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode *a_vp;
		caddr_t  a_id;
		int  a_op;
		struct flock *a_fl;
		int  a_flags;
	} */ *ap = v;
@


1.39
log
@remove duplicate check for uio_resid == 0 in
spec_read();

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.38 2007/01/16 17:52:18 thib Exp $	*/
d270 7
a276 4
			if (dpart.part->p_fstype == FS_BSDFFS &&
			    dpart.part->p_frag != 0 && dpart.part->p_fsize != 0)
				bsize = dpart.part->p_frag *
				    dpart.part->p_fsize;
d369 7
a375 4
			if (dpart.part->p_fstype == FS_BSDFFS &&
			    dpart.part->p_frag != 0 && dpart.part->p_fsize != 0)
				bsize = dpart.part->p_frag *
				    dpart.part->p_fsize;
@


1.38
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.37 2006/11/29 14:30:30 krw Exp $	*/
a263 2
		if (uio->uio_resid == 0)
			return (0);
@


1.37
log
@Correct the calculation of block address for specfs block i/o on
devices with sectorsizes other than 512. e.g. cd's. Fixes PR #5235
from Paul Stoeber with a slightly tweaked diff. NetBSD did the same
with their r1.59 in 2001, closing their PR#3261 and PR#14026.

tweak suggestions and ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.36 2006/10/16 11:27:53 pedro Exp $	*/
a70 1
	{ &vop_lease_desc, spec_lease_check },		/* lease */
@


1.36
log
@Use daddr64_t for logical blocks, okay krw@@ thib@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.35 2006/07/12 19:56:18 thib Exp $	*/
d240 1
a240 1
	long bsize, bscale, ssize;
a269 1
		ssize = DEV_BSIZE;
a276 2
			if (dpart.disklab->d_secsize != 0)
				ssize = dpart.disklab->d_secsize;
d278 1
a278 1
		bscale = bsize / ssize;
d280 1
a280 1
			bn = (uio->uio_offset / ssize) &~ (bscale - 1);
d338 1
a338 1
	long bsize, bscale, ssize;
a365 1
		ssize = DEV_BSIZE;
a372 2
			if (dpart.disklab->d_secsize != 0)
				ssize = dpart.disklab->d_secsize;
d374 1
a374 1
		bscale = bsize / ssize;
d376 1
a376 1
			bn = (uio->uio_offset / ssize) &~ (bscale - 1);
@


1.35
log
@zap some unused variables.
the only use was in an #if notyet chunk since '97.

ok miod@@
'no objections' pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.34 2006/06/02 20:25:09 pedro Exp $	*/
d239 1
a239 1
	daddr_t bn, nextbn;
@


1.34
log
@Add a clonable devices implementation. Hacked along with thib@@, input
from krw@@ and toby@@, subliminal prodding from dlg@@, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.33 2006/03/05 21:48:56 miod Exp $	*/
a56 9

/* symbolic sleep message strings for devices */
char	devopn[] = "devopn";
char	devio[] = "devio";
char	devwait[] = "devwait";
char	devin[] = "devin";
char	devout[] = "devout";
char	devioc[] = "devioc";
char	devcls[] = "devcls";
@


1.33
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.32 2006/02/20 19:44:58 miod Exp $	*/
d194 2
d629 2
@


1.32
log
@Remove historical yet completely undocumented ``is this a tape'' ioctl for
block devices where ioctl request is zero and data is B_TAPE, which no sane
userland program uses those days.
General disgust and ok deraadt@@ millert@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.31 2005/12/31 21:22:35 miod Exp $	*/
d514 3
a516 2
	for (bp = vp->v_dirtyblkhd.lh_first; bp; bp = nbp) {
		nbp = bp->b_vnbufs.le_next;
d531 1
a531 1
		if (vp->v_dirtyblkhd.lh_first) {
@


1.31
log
@Split the d_type field of cdevsw entries into d_type and d_flags for clarity.
Discussed with and ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.30 2005/12/29 20:00:52 pedro Exp $	*/
a437 2
		if (ap->a_command == 0 && (long)ap->a_data == B_TAPE) 
			return ((bdevsw[maj].d_type == D_TAPE) ? 0 : 1);
@


1.30
log
@Fix wrong optimization in spec_write() that goes: if we are about to do
a write that will globber the whole buffer, and it's not in cache, do
not bother reading it in. That's wrong, since the user may be trying to
write beyond the disk extent, in which case we definitely want to return
an error, rather than returning saying the write was okay, and failing
later on at an 'uncatched' biodone(). Okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.29 2005/05/24 04:45:13 pedro Exp $	*/
d485 1
a485 1
	if (cdevsw[major(dev)].d_type & D_KQFILTER)
@


1.29
log
@better handling of disappearing devices, in spec_close(), don't try to
double-lock the vnode if we're coming from vclean()
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.28 2004/11/29 17:05:05 grange Exp $	*/
d392 1
a392 4
			if (n == bsize)
				bp = getblk(vp, bn, bsize, 0, 0);
			else
				error = bread(vp, bn, bsize, NOCRED, &bp);
@


1.28
log
@Don't use seltrue() in poll ops since it requires v_rdev dereferencing
which is not possible here. Problem found and fixed by form@@.

ok millert@@ fgsch@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.27 2003/09/23 16:51:13 millert Exp $	*/
d639 3
a641 1
		 * we can, for instance, change floppy disks.
d643 2
a644 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, ap->a_p);
d646 2
a647 1
		VOP_UNLOCK(vp, 0, ap->a_p);
@


1.27
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.26 2003/06/02 23:28:11 millert Exp $	*/
d467 2
a468 1
		return (seltrue(ap->a_vp->v_rdev, ap->a_events, ap->a_p));
@


1.26
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.25 2003/02/12 14:41:07 jason Exp $	*/
d50 1
d82 1
a82 1
	{ &vop_select_desc, spec_select },		/* select */
d454 1
a454 1
spec_select(v)
d457 1
a457 1
	struct vop_select_args /* {
d459 1
a459 3
		int  a_which;
		int  a_fflags;
		struct ucred *a_cred;
d467 1
a467 1
		return (1);		/* XXX */
d471 1
a471 1
		return (*cdevsw[major(dev)].d_select)(dev, ap->a_which, ap->a_p);
@


1.25
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.24 2002/11/08 04:34:17 art Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.24
log
@Implement simple vnodeop inheritance for specfs and fifofs.

The inheritace is implemented by setting the default vnodeop to a
bypass op that repeats the operation on the spec/fifo vnodeop vector.
The overhead of one extra indirect function call is worth the cleanup
and improved correctness.

This actually solves a few bugs where some vnode ops were missing from
some vectors (like kqfilter or revoke). (and even more on the ubc
branch).

Inspired by the same thing done in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.23 2002/03/14 01:27:08 millert Exp $	*/
d58 2
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.22 2001/12/19 08:58:06 art Exp $	*/
d107 1
a107 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d111 8
@


1.22
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.20 2001/06/23 02:14:26 csapuntz Exp $	*/
d68 1
a68 1
int (**spec_vnodeop_p) __P((void *));
d107 1
a107 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d243 1
a243 1
	int (*ioctl) __P((dev_t, u_long, caddr_t, int, struct proc *));
d344 1
a344 1
	int (*ioctl) __P((dev_t, u_long, caddr_t, int, struct proc *));
d598 1
a598 1
	int (*devclose) __P((dev_t, int, int, struct proc *));
@


1.21
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d107 1
a107 2
	{ &vop_mmap_desc, spec_mmap },
	{ NULL, NULL }
@


1.21.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.21 2001/12/04 22:44:32 art Exp $	*/
d68 1
a68 1
int (**spec_vnodeop_p)(void *);
d244 1
a244 1
	int (*ioctl)(dev_t, u_long, caddr_t, int, struct proc *);
d345 1
a345 1
	int (*ioctl)(dev_t, u_long, caddr_t, int, struct proc *);
d599 1
a599 1
	int (*devclose)(dev_t, int, int, struct proc *);
@


1.21.2.2
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.21.2.1 2002/06/11 03:30:21 art Exp $	*/
a55 1
#include <miscfs/genfs/genfs.h>
d71 4
d81 5
d87 9
d100 2
d104 4
a107 1
	SPEC_VNODEOP_DESCS,
@


1.21.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a59 2
struct vnode *speclisth[SPECHSZ];

a71 4
	{ &vop_lookup_desc, spec_lookup },		/* lookup */
	{ &vop_create_desc, spec_create },		/* create */
	{ &vop_mknod_desc, spec_mknod },		/* mknod */
	{ &vop_open_desc, spec_open },			/* open */
a77 5
	{ &vop_lease_desc, spec_lease_check },		/* lease */
	{ &vop_ioctl_desc, spec_ioctl },		/* ioctl */
	{ &vop_select_desc, spec_select },		/* select */
	{ &vop_kqfilter_desc, spec_kqfilter },		/* kqfilter */
	{ &vop_revoke_desc, spec_revoke },		/* revoke */
a78 9
	{ &vop_remove_desc, spec_remove },		/* remove */
	{ &vop_link_desc, spec_link },			/* link */
	{ &vop_rename_desc, spec_rename },		/* rename */
	{ &vop_mkdir_desc, spec_mkdir },		/* mkdir */
	{ &vop_rmdir_desc, spec_rmdir },		/* rmdir */
	{ &vop_symlink_desc, spec_symlink },		/* symlink */
	{ &vop_readdir_desc, spec_readdir },		/* readdir */
	{ &vop_readlink_desc, spec_readlink },		/* readlink */
	{ &vop_abortop_desc, spec_abortop },		/* abortop */
a82 2
	{ &vop_bmap_desc, spec_bmap },			/* bmap */
	{ &vop_strategy_desc, spec_strategy },		/* strategy */
d85 1
a85 6
	{ &vop_pathconf_desc, spec_pathconf },		/* pathconf */
	{ &vop_advlock_desc, spec_advlock },		/* advlock */
	{ &vop_bwrite_desc, spec_bwrite },		/* bwrite */
	{ &vop_mmap_desc, spec_mmap },			/* mmap */
	{ &vop_getpages_desc, spec_getpages },		/* getpages */
	{ &vop_putpages_desc, spec_putpages },		/* putpages */
a89 8

int
spec_vnoperate(void *v)
{
	struct vop_generic_args *ap = v;

	return (VOCALL(spec_vnodeop_p, ap->a_desc->vdesc_offset, ap));
}
@


1.21.2.4
log
@convert to genfs_nolock.  genfs_lock for kern and procfs
@
text
@a54 1
#include <miscfs/genfs/genfs.h>
@


1.20
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.19 2001/03/15 16:44:15 csapuntz Exp $	*/
d107 2
a108 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.19
log
@
Use buf_start
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.18 2001/03/01 20:54:35 provos Exp $	*/
a85 1
	{ &vop_mmap_desc, spec_mmap },			/* mmap */
a86 1
	{ &vop_seek_desc, spec_seek },			/* seek */
a105 5
	{ &vop_blkatoff_desc, spec_blkatoff },		/* blkatoff */
	{ &vop_valloc_desc, spec_valloc },		/* valloc */
	{ &vop_vfree_desc, spec_vfree },		/* vfree */
	{ &vop_truncate_desc, spec_truncate },		/* truncate */
	{ &vop_update_desc, spec_update },		/* update */
@


1.18
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.17 2001/02/24 19:07:10 csapuntz Exp $	*/
d557 2
a558 2
	if (LIST_FIRST(&bp->b_dep) != NULL && bioops.io_start)
		(*bioops.io_start)(bp);
@


1.17
log
@

Cleanup of vnode interface continues. Get rid of VHOLD/HOLDRELE.
Change VM/UVM to use buf_replacevnode to change the vnode associated
with a buffer.

Addition v_bioflag for flags written in interrupt handlers
(and read at splbio, though not strictly necessary)

Add vwaitforio and use it instead of a while loop of v_numoutput.

Fix race conditions when manipulation vnode free list
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.16 2001/02/23 14:42:39 csapuntz Exp $	*/
d84 1
d476 18
@


1.16
log
@

Remove the clustering fields from the vnodes and place them in the
file system inode instead
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.15 1998/02/23 17:40:58 niklas Exp $	*/
d514 2
a515 4
		while (vp->v_numoutput) {
			vp->v_flag |= VBWAIT;
			sleep((caddr_t)&vp->v_numoutput, PRIBIO + 1);
		}
@


1.15
log
@Please GCC 2.8 -Wall + some KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.14 1997/12/28 19:34:49 csapuntz Exp $	*/
d56 2
@


1.15.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.19 2001/03/15 16:44:15 csapuntz Exp $	*/
a56 2
#define v_lastr v_specinfo->si_lastr

a81 1
	{ &vop_kqfilter_desc, spec_kqfilter },		/* kqfilter */
a472 18
/* ARGSUSED */
int
spec_kqfilter(v)
	void *v;
{
	struct vop_kqfilter_args /* {
		struct vnode *a_vp;
		struct knote *a_kn;
	} */ *ap = v;

	dev_t dev;

	dev = ap->a_vp->v_rdev;
	if (cdevsw[major(dev)].d_type & D_KQFILTER)
		return (*cdevsw[major(dev)].d_kqfilter)(dev, ap->a_kn);
	return (1);
}

d512 4
a515 2
		vwaitforio (vp, 0, "spec_fsync", 0);

d538 2
a539 2
	if (LIST_FIRST(&bp->b_dep) != NULL)
		buf_start(bp);
@


1.15.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.15.10.1 2001/05/14 22:32:56 niklas Exp $	*/
d86 1
d88 1
d108 5
@


1.15.10.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 1
a68 1
int (**spec_vnodeop_p)(void *);
d107 1
a107 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d243 1
a243 1
	int (*ioctl)(dev_t, u_long, caddr_t, int, struct proc *);
d344 1
a344 1
	int (*ioctl)(dev_t, u_long, caddr_t, int, struct proc *);
d598 1
a598 1
	int (*devclose)(dev_t, int, int, struct proc *);
@


1.15.10.4
log
@Sync the SMP branch with 3.3
@
text
@a58 2
struct vnode *speclisth[SPECHSZ];

d107 1
a107 1
	{ NULL, NULL }
a110 8

int
spec_vnoperate(void *v)
{
	struct vop_generic_args *ap = v;

	return (VOCALL(spec_vnodeop_p, ap->a_desc->vdesc_offset, ap));
}
@


1.15.10.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.15.10.4 2003/03/28 00:00:20 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.15.10.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a49 1
#include <sys/poll.h>
d81 1
a81 1
	{ &vop_poll_desc, spec_poll },			/* poll */
d453 1
a453 1
spec_poll(v)
d456 1
a456 1
	struct vop_poll_args /* {
d458 3
a460 1
		int  a_events;
d468 1
a468 1
		return (seltrue(ap->a_vp->v_rdev, ap->a_events, ap->a_p));
d472 1
a472 1
		return (*cdevsw[major(dev)].d_poll)(dev, ap->a_events, ap->a_p);
@


1.14
log
@I should be more careful about what I check in. Undo earlier commenting-out
of security check. Restricted access to /dev/memat higher secure levels
now enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.13 1997/11/06 20:04:35 csapuntz Exp $	*/
d438 2
a439 5
		if (ap->a_command == 0 && (long)ap->a_data == B_TAPE)
			if (bdevsw[maj].d_type == D_TAPE)
				return (0);
			else
				return (1);
d441 1
a441 1
		   ap->a_fflag, ap->a_p));
@


1.13
log
@Removed i386-specific crud
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.12 1997/11/06 05:58:44 csapuntz Exp $	*/
a148 1
#if 0
a150 1
#endif
a178 1
#if 0
a187 1
#endif
@


1.12
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.11 1997/10/06 20:20:37 deraadt Exp $	*/
a534 71
/*
 * Just call the device strategy routine
 */
int fs_read[16], fs_write[16];

int cur_found[10];

int fs_bwrite[64][10];
int fs_bwrite_cnt[64];
int num_found;

int num_levels = 4;
#include <machine/cpu.h>
#include <machine/pcb.h>

int find_stack(int);

int find_stack(int levels)

{
        struct    pcb  stack;
        int   *eip, *ebp;

        savectx(&stack);
        ebp = (int *)stack.pcb_ebp;
        eip = (int *) *(ebp + 1);
        
        while ((int)ebp > 0xf0000000 && levels--) {
                eip = (int *) *(ebp + 1);

                ebp = (int *) *ebp;
        }
        
	return ((int)eip);
}

void track_write __P((void));

void track_write(void)

{
	int  idx, cnt;

	for (idx = 0; idx < 10; idx++) {
		cur_found[idx] = find_stack(idx + num_levels);
	}

	for (cnt = 0; cnt < num_found; cnt++) {
		for (idx = 0; idx < 10; idx++) {
			if (fs_bwrite[cnt][idx] != cur_found[idx])
				goto next_iter;
		}

		fs_bwrite_cnt[cnt]++;
		break;
	next_iter:
	}

	if ((cnt == num_found) &&
	    (num_found != 64)) {
		for (idx = 0; idx < 10; idx++) {
			fs_bwrite[num_found][idx] = cur_found[idx];
		}
		
		fs_bwrite_cnt[num_found] = 1;
		num_found++;
	}

	return;
}

d542 2
a543 3
	struct buf *bp;

	int maj = major(ap->a_bp->b_dev);
a544 17
	if ((maj >= 0) && (maj < 16)) {
		if (ap->a_bp->b_flags & B_READ)
			fs_read[maj]++;
		else {
			fs_write[maj]++;
			if (maj == 4)
				track_write();

		}
	}

#if 0
	assert (!(flags & (B_DELWRI | B_DONE)));
#endif

	bp = ap->a_bp;

d548 1
a548 1
	(*bdevsw[maj].d_strategy)(ap->a_bp);
@


1.11
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.9 1997/01/04 17:10:04 kstailey Exp $	*/
d82 1
d147 7
a153 2
	struct vnode *bvp, *vp = ap->a_vp;
	dev_t bdev, dev = (dev_t)vp->v_rdev;
d181 1
d191 1
d195 1
a195 1
		VOP_UNLOCK(vp);
d197 1
a197 1
		VOP_LOCK(vp);
d266 1
a266 1
		VOP_UNLOCK(vp);
d269 1
a269 1
		VOP_LOCK(vp);
d317 13
d365 1
a365 1
		VOP_UNLOCK(vp);
d368 1
a368 1
		VOP_LOCK(vp);
d538 68
d613 1
d615 23
a637 1
	(*bdevsw[major(ap->a_bp->b_dev)].d_strategy)(ap->a_bp);
d653 1
d660 3
a662 21
	return (0);
}

/*
 * At the moment we do not do any locking.
 */
/* ARGSUSED */
int
spec_lock(v)
	void *v;
{

	return (0);
}

/* ARGSUSED */
int
spec_unlock(v)
	void *v;
{

d719 1
d721 1
@


1.10
log
@VFS Lite2 Changes
@
text
@a81 1
	{ &vop_revoke_desc, spec_revoke },              /* revoke */
d146 2
a147 7
	struct proc *p = ap->a_p;
	struct vnode *vp = ap->a_vp;
#if 0
	struct vnode *bvp;
	dev_t bdev;
#endif
	dev_t dev = (dev_t)vp->v_rdev;
a174 1
#if 0
a183 1
#endif
d187 1
a187 1
		VOP_UNLOCK(vp, 0, p);
d189 1
a189 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d258 1
a258 1
		VOP_UNLOCK(vp, 0, p);
d261 1
a261 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
a308 13
int
spec_inactive(v)
	void *v;
{
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;

	VOP_UNLOCK(ap->a_vp, 0, ap->a_p);
	return (0);
}

d344 1
a344 1
		VOP_UNLOCK(vp, 0, p);
d347 1
a347 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
a516 68
int fs_read[16], fs_write[16];

int cur_found[10];

int fs_bwrite[64][10];
int fs_bwrite_cnt[64];
int num_found;

int num_levels = 4;
#include <machine/cpu.h>
#include <machine/pcb.h>

int find_stack(int);

int find_stack(int levels)

{
        struct    pcb  stack;
        int   *eip, *ebp;

        savectx(&stack);
        ebp = (int *)stack.pcb_ebp;
        eip = (int *) *(ebp + 1);
        
        while ((int)ebp > 0xf0000000 && levels--) {
                eip = (int *) *(ebp + 1);

                ebp = (int *) *ebp;
        }
        
	return ((int)eip);
}

void track_write __P((void));

void track_write(void)

{
	int  idx, cnt;

	for (idx = 0; idx < 10; idx++) {
		cur_found[idx] = find_stack(idx + num_levels);
	}

	for (cnt = 0; cnt < num_found; cnt++) {
		for (idx = 0; idx < 10; idx++) {
			if (fs_bwrite[cnt][idx] != cur_found[idx])
				goto next_iter;
		}

		fs_bwrite_cnt[cnt]++;
		break;
	next_iter:
	}

	if ((cnt == num_found) &&
	    (num_found != 64)) {
		for (idx = 0; idx < 10; idx++) {
			fs_bwrite[num_found][idx] = cur_found[idx];
		}
		
		fs_bwrite_cnt[num_found] = 1;
		num_found++;
	}

	return;
}

a523 1
	struct buf *bp;
d525 1
a525 23
	int maj = major(ap->a_bp->b_dev);
	
	if ((maj >= 0) && (maj < 16)) {
		if (ap->a_bp->b_flags & B_READ)
			fs_read[maj]++;
		else {
			fs_write[maj]++;
			if (maj == 4)
				track_write();

		}
	}

#if 0
	assert (!(flags & (B_DELWRI | B_DONE)));
#endif

	bp = ap->a_bp;

	if (LIST_FIRST(&bp->b_dep) != NULL && bioops.io_start)
		(*bioops.io_start)(bp);

	(*bdevsw[maj].d_strategy)(ap->a_bp);
a540 1
		int *a_runp;
d547 21
a567 3
	if (ap->a_runp != NULL)
		*ap->a_runp = 0;
	
a623 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, ap->a_p);
a624 1
		VOP_UNLOCK(vp, 0, ap->a_p);
@


1.9
log
@spec_advlock() via lf_advlock()
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.8 1996/12/22 16:05:24 kstailey Exp $	*/
d82 1
d147 7
a153 2
	struct vnode *bvp, *vp = ap->a_vp;
	dev_t bdev, dev = (dev_t)vp->v_rdev;
d181 1
d191 1
d195 1
a195 1
		VOP_UNLOCK(vp);
d197 1
a197 1
		VOP_LOCK(vp);
d266 1
a266 1
		VOP_UNLOCK(vp);
d269 1
a269 1
		VOP_LOCK(vp);
d317 13
d365 1
a365 1
		VOP_UNLOCK(vp);
d368 1
a368 1
		VOP_LOCK(vp);
d538 68
d613 1
d615 23
a637 1
	(*bdevsw[major(ap->a_bp->b_dev)].d_strategy)(ap->a_bp);
d653 1
d660 3
a662 21
	return (0);
}

/*
 * At the moment we do not do any locking.
 */
/* ARGSUSED */
int
spec_lock(v)
	void *v;
{

	return (0);
}

/* ARGSUSED */
int
spec_unlock(v)
	void *v;
{

d719 1
d721 1
@


1.8
log
@make spec_advlock() perform indirect call to lf_advlock()
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.7 1996/12/05 16:25:08 kstailey Exp $	*/
d53 1
d719 1
d721 2
a722 5
	/* XXX Should call lf_advlock() from here, but no snode. */
	/* Instead call through non-special file on same filesystem. */

	return (VCALL(ap->a_vp->v_mount->mnt_vnodelist.lh_first,
		      VOFFSET(vop_advlock), ap));
@


1.7
log
@fix locking on devices to work on diskless workstations
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.6 1996/11/23 23:19:52 kstailey Exp $	*/
d710 11
a720 2
#ifdef FFS
	extern int ufs_advlock __P((void *v));
d722 2
a723 10
	return (ufs_advlock(v));
#else
#ifdef NFSCLIENT
	extern int nfs_advlock __P((void *v));

	return (nfs_advlock(v));
#else
	return (EOPNOTSUPP);
#endif /* NFSCLIENT */
#endif /* FFS */
@


1.6
log
@remrq -> remrunqueue
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.5 1996/11/23 21:47:11 kstailey Exp $	*/
d710 1
a710 1
#ifdef UFS
d715 5
d721 2
a722 1
#endif
@


1.5
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.4 1996/11/04 03:31:15 deraadt Exp $	*/
d710 1
a710 1
#ifdef NFSSERVER
@


1.4
log
@permit locking on devices
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.3 1996/05/02 13:20:19 deraadt Exp $	*/
d710 1
d714 3
@


1.3
log
@no sys/cpu.h
@
text
@d1 1
a1 1
/*	$OpenBSD: spec_vnops.c,v 1.2 1996/02/27 08:05:15 niklas Exp $	*/
d710 1
d712 1
a712 1
	return (EOPNOTSUPP);
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: spec_vnops.c,v 1.28 1996/02/09 22:40:57 christos Exp $	*/
a52 1
#include <sys/cpu.h>
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: spec_vnops.c,v 1.26.2.1 1995/10/15 05:19:55 mycroft Exp $	*/
d53 2
d66 1
a66 1
int (**spec_vnodeop_p)();
d109 2
a110 2
	{ &vop_bwrite_desc, vn_bwrite },		/* bwrite */
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
d119 3
a121 1
spec_lookup(ap)
d126 1
a126 2
	} */ *ap;
{
d136 4
a139 1
spec_open(ap)
d145 1
a145 2
	} */ *ap;
{
d206 1
a206 1
		if (error = vfs_mountedon(vp))
d209 8
d225 4
a228 1
spec_read(ap)
d234 1
a234 2
	} */ *ap;
{
d242 2
a243 1
	int n, on, majordev, (*ioctl)();
d313 4
a316 1
spec_write(ap)
d322 1
a322 2
	} */ *ap;
{
d330 2
a331 1
	int n, on, majordev, (*ioctl)();
d399 4
a402 1
spec_ioctl(ap)
d410 1
a410 2
	} */ *ap;
{
d436 4
a439 1
spec_select(ap)
d446 1
a446 2
	} */ *ap;
{
d464 3
a466 1
spec_fsync(ap)
d472 1
a472 2
	} */ *ap;
{
d517 4
a520 1
spec_strategy(ap)
d523 1
a523 2
	} */ *ap;
{
d532 4
a535 1
spec_bmap(ap)
d541 1
a541 2
	} */ *ap;
{
d554 3
a556 4
spec_lock(ap)
	struct vop_lock_args /* {
		struct vnode *a_vp;
	} */ *ap;
d563 3
a565 4
spec_unlock(ap)
	struct vop_unlock_args /* {
		struct vnode *a_vp;
	} */ *ap;
d575 4
a578 1
spec_close(ap)
d584 1
a584 2
	} */ *ap;
{
d624 2
a625 1
		if (error = vinvalbuf(vp, V_SAVE, ap->a_cred, ap->a_p, 0, 0))
d652 4
a655 1
spec_print(ap)
d658 1
a658 2
	} */ *ap;
{
d662 1
d668 4
a671 1
spec_pathconf(ap)
d676 1
a676 2
	} */ *ap;
{
d707 3
a709 8
spec_advlock(ap)
	struct vop_advlock_args /* {
		struct vnode *a_vp;
		caddr_t  a_id;
		int  a_op;
		struct flock *a_fl;
		int  a_flags;
	} */ *ap;
d718 4
a721 1
spec_ebadf()
d730 4
a733 1
spec_badop()
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
