head	1.33;
access;
symbols
	OPENBSD_6_2:1.33.0.6
	OPENBSD_6_2_BASE:1.33
	OPENBSD_6_1:1.33.0.4
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.32.0.2
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.6
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.4
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.2
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.8
	OPENBSD_5_0:1.23.0.6
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.23.0.4
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.12
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.8
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.6
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.4
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.8
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.6
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.9.0.8
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.7.0.8
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.32;
commitid	CHRb0fCqa8XxUAMH;

1.32
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.31;
commitid	gAjwyca5TfuoJAhn;

1.31
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.30;
commitid	kCz5QgxnxRMKOzNf;

1.30
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.29;
commitid	Cl55DD2g2xm69E6W;

1.29
date	2014.12.10.02.44.46;	author tedu;	state Exp;
branches;
next	1.28;
commitid	tsoJBlEBSyYO22RG;

1.28
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2012.07.08.17.14.39;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2012.04.12.10.11.41;	author mikeb;	state Exp;
branches;
next	1.24;

1.24
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.12.22.14.15;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.14.18.00.27;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.05.03.18.46;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.28.00.14.28;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.28.07.30.25;	author marius;	state Exp;
branches;
next	1.15;

1.15
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.27.08.25.53;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.01.18.06.03;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.02.21.42.15;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.05.05.08.38.23;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.23.11.26.28;	author art;	state Exp;
branches;
next	1.7;

1.7
date	98.07.28.00.13.00;	author millert;	state Exp;
branches
	1.7.8.1;
next	1.6;

1.6
date	98.05.17.10.47.35;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.11.06.05.58.15;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.20.19.50;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.06.15.12.14;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.19.40;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches;
next	;

1.7.8.1
date	2000.03.24.09.09.23;	author niklas;	state Exp;
branches;
next	1.7.8.2;

1.7.8.2
date	2001.05.14.22.32.39;	author niklas;	state Exp;
branches;
next	1.7.8.3;

1.7.8.3
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.7.8.4;

1.7.8.4
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.7.8.5;

1.7.8.5
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.7.8.6;

1.7.8.6
date	2004.06.05.23.13.01;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.33
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@/*	$OpenBSD: kern_acct.c,v 1.32 2016/03/19 12:04:15 natano Exp $	*/
/*	$NetBSD: kern_acct.c,v 1.42 1996/02/04 02:15:12 christos Exp $	*/

/*-
 * Copyright (c) 1994 Christopher G. Demetriou
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_acct.c	8.1 (Berkeley) 6/14/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/file.h>
#include <sys/syslog.h>
#include <sys/kernel.h>
#include <sys/namei.h>
#include <sys/errno.h>
#include <sys/acct.h>
#include <sys/resourcevar.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/kthread.h>

#include <sys/syscallargs.h>

/*
 * The routines implemented in this file are described in:
 *      Leffler, et al.: The Design and Implementation of the 4.3BSD
 *	    UNIX Operating System (Addison Welley, 1989)
 * on pages 62-63.
 *
 * Arguably, to simplify accounting operations, this mechanism should
 * be replaced by one in which an accounting log file (similar to /dev/klog)
 * is read by a user process, etc.  However, that has its own problems.
 */

/*
 * Internal accounting functions.
 */
comp_t	encode_comp_t(u_long, u_long);
int	acct_start(void);
void	acct_thread(void *);
void	acct_shutdown(void);

/*
 * Accounting vnode pointer, and saved vnode pointer.
 */
struct	vnode *acctp;
struct	vnode *savacctp;

/*
 * Values associated with enabling and disabling accounting
 */
int	acctsuspend = 2;	/* stop accounting when < 2% free space left */
int	acctresume = 4;		/* resume when free space risen to > 4% */
int	acctchkfreq = 15;	/* frequency (in seconds) to check space */

struct proc *acct_proc;

/*
 * Accounting system call.  Written based on the specification and
 * previous implementation done by Mark Tinguely.
 */
int
sys_acct(struct proc *p, void *v, register_t *retval)
{
	struct sys_acct_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;
	struct nameidata nd;
	int error;

	/* Make sure that the caller is root. */
	if ((error = suser(p, 0)) != 0)
		return (error);

	/*
	 * If accounting is to be started to a file, open that file for
	 * writing and make sure it's 'normal'.
	 */
	if (SCARG(uap, path) != NULL) {
		NDINIT(&nd, LOOKUP, NOFOLLOW, UIO_USERSPACE, SCARG(uap, path),
		    p);
		if ((error = vn_open(&nd, FWRITE|O_APPEND, 0)) != 0)
			return (error);
		VOP_UNLOCK(nd.ni_vp, p);
		if (nd.ni_vp->v_type != VREG) {
			vn_close(nd.ni_vp, FWRITE, p->p_ucred, p);
			return (EACCES);
		}
	}

	/*
	 * If accounting was previously enabled, kill the old space-watcher,
	 * close the file, and (if no new file was specified, leave).
	 */
	if (acctp != NULL || savacctp != NULL) {
		wakeup(&acct_proc);
		error = vn_close((acctp != NULL ? acctp : savacctp), FWRITE,
		    p->p_ucred, p);
		acctp = savacctp = NULL;
	}
	if (SCARG(uap, path) == NULL)
		return (0);

	/*
	 * Save the new accounting file vnode, and schedule the new
	 * free space watcher.
	 */
	acctp = nd.ni_vp;
	if ((error = acct_start()) != 0) {
		acctp = NULL;
		(void)vn_close(nd.ni_vp, FWRITE, p->p_ucred, p);
		return (error);
	}
	return (0);
}

/*
 * Write out process accounting information, on process exit.
 * Data to be written out is specified in Leffler, et al.
 * and are enumerated below.  (They're also noted in the system
 * "acct.h" header file.)
 */
int
acct_process(struct proc *p)
{
	struct acct acct;
	struct process *pr = p->p_p;
	struct rusage *r;
	struct timespec ut, st, tmp;
	int t;
	struct vnode *vp;
	int error;

	/* If accounting isn't enabled, don't bother */
	vp = acctp;
	if (vp == NULL)
		return (0);

	/*
	 * Get process accounting information.
	 */

	/* (1) The name of the command that ran */
	memcpy(acct.ac_comm, pr->ps_comm, sizeof acct.ac_comm);

	/* (2) The amount of user and system time that was used */
	calctsru(&pr->ps_tu, &ut, &st, NULL);
	acct.ac_utime = encode_comp_t(ut.tv_sec, ut.tv_nsec);
	acct.ac_stime = encode_comp_t(st.tv_sec, st.tv_nsec);

	/* (3) The elapsed time the command ran (and its starting time) */
	acct.ac_btime = pr->ps_start.tv_sec;
	getnanotime(&tmp);
	timespecsub(&tmp, &pr->ps_start, &tmp);
	acct.ac_etime = encode_comp_t(tmp.tv_sec, tmp.tv_nsec);

	/* (4) The average amount of memory used */
	r = &p->p_ru;
	timespecadd(&ut, &st, &tmp);
	t = tmp.tv_sec * hz + tmp.tv_nsec / (1000 * tick);
	if (t)
		acct.ac_mem = (r->ru_ixrss + r->ru_idrss + r->ru_isrss) / t;
	else
		acct.ac_mem = 0;

	/* (5) The number of disk I/O operations done */
	acct.ac_io = encode_comp_t(r->ru_inblock + r->ru_oublock, 0);

	/* (6) The UID and GID of the process */
	acct.ac_uid = pr->ps_ucred->cr_ruid;
	acct.ac_gid = pr->ps_ucred->cr_rgid;

	/* (7) The terminal from which the process was started */
	if ((pr->ps_flags & PS_CONTROLT) &&
	    pr->ps_pgrp->pg_session->s_ttyp)
		acct.ac_tty = pr->ps_pgrp->pg_session->s_ttyp->t_dev;
	else
		acct.ac_tty = NODEV;

	/* (8) The boolean flags that tell how the process terminated, etc. */
	acct.ac_flag = pr->ps_acflag;

	/*
	 * Now, just write the accounting information to the file.
	 */
	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&acct, sizeof (acct),
	    (off_t)0, UIO_SYSSPACE, IO_APPEND|IO_UNIT|IO_NOLIMIT,
	    p->p_ucred, NULL, p);

	return error;
}

/*
 * Encode_comp_t converts from ticks in seconds and microseconds
 * to ticks in 1/AHZ seconds.  The encoding is described in
 * Leffler, et al., on page 63.
 */

#define	MANTSIZE	13			/* 13 bit mantissa. */
#define	EXPSIZE		3			/* Base 8 (3 bit) exponent. */
#define	MAXFRACT	((1 << MANTSIZE) - 1)	/* Maximum fractional value. */

comp_t
encode_comp_t(u_long s, u_long ns)
{
	int exp, rnd;

	exp = 0;
	rnd = 0;
	s *= AHZ;
	s += ns / (1000000000 / AHZ);	/* Maximize precision. */

	while (s > MAXFRACT) {
	rnd = s & (1 << (EXPSIZE - 1));	/* Round up? */
		s >>= EXPSIZE;		/* Base 8 exponent == 3 bit shift. */
		exp++;
	}

	/* If we need to round up, do it (and handle overflow correctly). */
	if (rnd && (++s > MAXFRACT)) {
		s >>= EXPSIZE;
		exp++;
	}

	/* Clean it up and polish it off. */
	exp <<= MANTSIZE;		/* Shift the exponent into place */
	exp += s;			/* and add on the mantissa. */
	return (exp);
}

int
acct_start(void)
{
	/* Already running. */
	if (acct_proc != NULL)
		return (0);

	return (kthread_create(acct_thread, NULL, &acct_proc, "acct"));
}

/*
 * Periodically check the file system to see if accounting
 * should be turned on or off.  Beware the case where the vnode
 * has been vgone()'d out from underneath us, e.g. when the file
 * system containing the accounting file has been forcibly unmounted.
 */
void
acct_thread(void *arg)
{
	struct statfs sb;
	struct proc *p = curproc;

	for (;;) {
		if (savacctp != NULL) {
			if (savacctp->v_type == VBAD) {
				(void) vn_close(savacctp, FWRITE, NOCRED, p);
				savacctp = NULL;
				break;
			}
			(void)VFS_STATFS(savacctp->v_mount, &sb, NULL);
			if (sb.f_bavail > acctresume * sb.f_blocks / 100) {
				acctp = savacctp;
				savacctp = NULL;
				log(LOG_NOTICE, "Accounting resumed\n");
			}
		} else if (acctp != NULL) {
			if (acctp->v_type == VBAD) {
				(void) vn_close(acctp, FWRITE, NOCRED, p);
				acctp = NULL;
				break;
			}
			(void)VFS_STATFS(acctp->v_mount, &sb, NULL);
			if (sb.f_bavail <= acctsuspend * sb.f_blocks / 100) {
				savacctp = acctp;
				acctp = NULL;
				log(LOG_NOTICE, "Accounting suspended\n");
			}
		} else {
			break;
		}
		tsleep(&acct_proc, PPAUSE, "acct", acctchkfreq *hz);
	}
	acct_proc = NULL;
	kthread_exit(0);
}

void
acct_shutdown(void)
{

	struct proc *p = curproc;

	if (acctp != NULL || savacctp != NULL) {
		vn_close((acctp != NULL ? acctp : savacctp), FWRITE,
		    NOCRED, p);
		acctp = savacctp = NULL;
	}
}
@


1.32
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.31 2016/03/14 23:08:06 krw Exp $	*/
d179 1
a179 1
	memcpy(acct.ac_comm, p->p_comm, sizeof acct.ac_comm);
@


1.31
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.30 2015/12/05 10:11:53 tedu Exp $	*/
d119 1
a119 1
		VOP_UNLOCK(nd.ni_vp, 0, p);
@


1.30
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.29 2014/12/10 02:44:46 tedu Exp $	*/
d295 1
a295 1
			(void)VFS_STATFS(savacctp->v_mount, &sb, (struct proc *)0);
d307 1
a307 1
			(void)VFS_STATFS(acctp->v_mount, &sb, (struct proc *)0);
@


1.29
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.28 2014/03/30 21:54:48 guenther Exp $	*/
a281 1
/* ARGSUSED */
@


1.28
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.27 2013/06/03 16:55:22 guenther Exp $	*/
d179 1
a179 1
	bcopy(p->p_comm, acct.ac_comm, sizeof acct.ac_comm);
@


1.27
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.26 2012/07/08 17:14:39 guenther Exp $	*/
d205 2
a206 2
	acct.ac_uid = p->p_cred->p_ruid;
	acct.ac_gid = p->p_cred->p_rgid;
@


1.26
log
@Use IO_NOLIMIT instead of munging the process's limits

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.25 2012/04/12 10:11:41 mikeb Exp $	*/
d164 1
a164 1
	struct timeval ut, st, tmp;
d182 3
a184 3
	calcru(&pr->ps_tu, &ut, &st, NULL);
	acct.ac_utime = encode_comp_t(ut.tv_sec, ut.tv_usec);
	acct.ac_stime = encode_comp_t(st.tv_sec, st.tv_usec);
d188 3
a190 3
	getmicrotime(&tmp);
	timersub(&tmp, &pr->ps_start, &tmp);
	acct.ac_etime = encode_comp_t(tmp.tv_sec, tmp.tv_usec);
d194 2
a195 2
	timeradd(&ut, &st, &tmp);
	t = tmp.tv_sec * hz + tmp.tv_usec / tick;
d239 1
a239 1
encode_comp_t(u_long s, u_long us)
d246 1
a246 1
	s += us / (1000000 / AHZ);	/* Maximize precision. */
@


1.25
log
@move accounting flags to struct process; idea and ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.24 2012/03/23 15:51:26 guenther Exp $	*/
a166 1
	struct plimit *oplim = NULL;
a174 10
	 * Raise the file limit so that accounting can't be stopped by the
	 * user. (XXX - we should think about the cpu limit too).
	 */
	if (pr->ps_limit->p_refcnt > 1) {
		oplim = pr->ps_limit;
		pr->ps_limit = limcopy(pr->ps_limit);
	}
	p->p_rlimit[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;

	/*
d222 2
a223 6
	    (off_t)0, UIO_SYSSPACE, IO_APPEND|IO_UNIT, p->p_ucred, NULL, p);

	if (oplim) {
		limfree(pr->ps_limit);
		pr->ps_limit = oplim;
	}
@


1.24
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.23 2010/07/26 01:56:27 guenther Exp $	*/
d227 1
a227 1
	acct.ac_flag = p->p_acflag;
@


1.23
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.22 2010/01/14 23:12:11 schwarze Exp $	*/
d162 1
d179 3
a181 3
	if (p->p_p->ps_limit->p_refcnt > 1) {
		oplim = p->p_p->ps_limit;
		p->p_p->ps_limit = limcopy(p->p_p->ps_limit);
d193 1
a193 1
	calcru(p, &ut, &st, NULL);
d198 1
a198 1
	acct.ac_btime = p->p_stats->p_start.tv_sec;
d200 1
a200 1
	timersub(&tmp, &p->p_stats->p_start, &tmp);
d204 1
a204 1
	r = &p->p_stats->p_ru;
d220 3
a222 3
	if ((p->p_p->ps_flags & PS_CONTROLT) &&
	    p->p_p->ps_pgrp->pg_session->s_ttyp)
		acct.ac_tty = p->p_p->ps_pgrp->pg_session->s_ttyp->t_dev;
d236 2
a237 2
		limfree(p->p_p->ps_limit);
		p->p_p->ps_limit = oplim;
@


1.22
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.21 2007/04/12 22:14:15 tedu Exp $	*/
d219 3
a221 2
	if ((p->p_flag & P_CONTROLT) && p->p_pgrp->pg_session->s_ttyp)
		acct.ac_tty = p->p_pgrp->pg_session->s_ttyp->t_dev;
@


1.21
log
@move p_limit and p_cred into struct process
leave macros behind for now to keep the commit small
ok art beck miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.20 2007/01/16 17:52:18 thib Exp $	*/
d196 1
a196 1
	/* (3) The elapsed time the commmand ran (and its starting time) */
@


1.20
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.19 2006/11/14 18:00:27 jmc Exp $	*/
d178 3
a180 3
	if (p->p_limit->p_refcnt > 1) {
		oplim = p->p_limit;
		p->p_limit = limcopy(p->p_limit);
d234 2
a235 2
		limfree(p->p_limit);
		p->p_limit = oplim;
@


1.19
log
@grammar, spelling, and style fixes from bret lambert;
kern_descrip.c change ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.18 2006/01/05 03:18:46 tedu Exp $	*/
a229 1
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
@


1.18
log
@if a kthread fails to call kthread_exit() but instead returns,
bad things happen.  fix acct thread.  from art
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.17 2005/11/28 00:14:28 jsg Exp $	*/
d112 1
a112 1
	 * writing and make sure it's a 'normal'.
@


1.17
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.16 2005/05/28 07:30:25 marius Exp $	*/
d308 1
a308 1
				return;
d320 1
a320 1
				return;
d329 1
a329 2
			acct_proc = NULL;
			kthread_exit(0);
d333 2
@


1.16
log
@have vn_close() lock the vnode before calling VOP_CLOSE().

fix the acct_*() code so that we always have a proc to lock on.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.15 2004/06/24 19:35:24 tholo Exp $	*/
d98 1
a98 4
sys_acct(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
@


1.15
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.14 2004/05/27 08:25:53 tedu Exp $	*/
d304 1
d309 1
a309 1
				(void) vn_close(savacctp, FWRITE, NOCRED, NULL);
d321 1
a321 1
				(void) vn_close(acctp, FWRITE, NOCRED, NULL);
d343 2
d347 1
a347 1
		    NOCRED, NULL);
@


1.14
log
@shutdown accounting before shutting down vfs.  should prevent some panics.
ok david@@ millert@@ (iirc)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.13 2003/09/01 18:06:03 henning Exp $	*/
d167 1
a167 1
	int s, t;
d201 2
a202 3
	s = splclock();
	timersub(&time, &p->p_stats->p_start, &tmp);
	splx(s);
@


1.13
log
@match syscallargs comments with reality
from Patrick Latifi <patrick.l@@hermes.usherb.ca>
ok jason@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.12 2003/08/15 20:32:18 tedu Exp $	*/
d76 1
d336 11
@


1.12
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.11 2003/06/02 23:28:05 millert Exp $	*/
d103 1
a103 1
		syscallarg(char *) path;
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.10 2001/11/02 21:42:15 art Exp $	*/
d109 1
a109 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.10
log
@Move the accounting disk space watcher into a kernel thread.
Since we do filesystem operations, we need process context.

This should fix accounting on nfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.9 2000/05/05 08:38:23 art Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Don't set filesize limit to infinity on exit.
This is only needed in accounting and has to be done carefully because
the limit structures are shared between processes.

Found by Denis A. Doroshenko, analysed by Hannah Schroeter.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.8 2000/03/23 11:26:28 art Exp $	*/
d59 1
a59 1
#include <sys/timeout.h>
a75 2
 * The former's operation is described in Leffler, et al., and the latter
 * was provided by UCB with the 4.4BSD-Lite release
d77 3
a79 2
comp_t	encode_comp_t __P((u_long, u_long));
void	acctwatch __P((void *));
d94 2
a110 1
	static struct timeout acct_timeout;
d136 3
a138 3
	if (acctp != NULLVP || savacctp != NULLVP) {
		timeout_del(&acct_timeout);
		error = vn_close((acctp != NULLVP ? acctp : savacctp), FWRITE,
d140 1
a140 1
		acctp = savacctp = NULLVP;
d143 1
a143 1
		return (error);
d150 6
a155 4
	if (!timeout_initialized(&acct_timeout))
		timeout_set(&acct_timeout, acctwatch, &acct_timeout);
	acctwatch(&acct_timeout);
	return (error);
d165 1
a165 2
acct_process(p)
	struct proc *p;
d177 1
a177 1
	if (vp == NULLVP)
d260 1
a260 2
encode_comp_t(s, us)
	u_long s, us;
d287 10
d305 1
a305 2
acctwatch(arg)
	void *arg;
a306 1
	struct timeout *to = (struct timeout *)arg;
d309 28
a336 5
	if (savacctp != NULLVP) {
		if (savacctp->v_type == VBAD) {
			(void) vn_close(savacctp, FWRITE, NOCRED, NULL);
			savacctp = NULLVP;
			return;
d338 2
a339 21
		(void)VFS_STATFS(savacctp->v_mount, &sb, (struct proc *)0);
		if (sb.f_bavail > acctresume * sb.f_blocks / 100) {
			acctp = savacctp;
			savacctp = NULLVP;
			log(LOG_NOTICE, "Accounting resumed\n");
		}
	} else if (acctp != NULLVP) {
		if (acctp->v_type == VBAD) {
			(void) vn_close(acctp, FWRITE, NOCRED, NULL);
			acctp = NULLVP;
			return;
		}
		(void)VFS_STATFS(acctp->v_mount, &sb, (struct proc *)0);
		if (sb.f_bavail <= acctsuspend * sb.f_blocks / 100) {
			savacctp = acctp;
			acctp = NULLVP;
			log(LOG_NOTICE, "Accounting suspended\n");
		}
	} else
		return;
	timeout_add(to, acctchkfreq * hz);
@


1.8
log
@convert to new timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.7 1998/07/28 00:13:00 millert Exp $	*/
d171 2
d180 10
d237 9
a245 2
	return (vn_rdwr(UIO_WRITE, vp, (caddr_t)&acct, sizeof (acct),
	    (off_t)0, UIO_SYSSPACE, IO_APPEND|IO_UNIT, p->p_ucred, NULL, p));
@


1.7
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.6 1998/05/17 10:47:35 deraadt Exp $	*/
d59 1
d110 1
d137 1
a137 1
		untimeout(acctwatch, NULL);
d150 3
a152 1
	acctwatch(NULL);
d276 2
a277 2
acctwatch(a)
	void *a;
d279 1
d308 1
a308 1
	timeout(acctwatch, NULL, acctchkfreq * hz);
@


1.7.8.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a58 1
#include <sys/timeout.h>
a108 1
	static struct timeout acct_timeout;
d135 1
a135 1
		timeout_del(&acct_timeout);
d148 1
a148 3
	if (!timeout_initialized(&acct_timeout))
		timeout_set(&acct_timeout, acctwatch, &acct_timeout);
	acctwatch(&acct_timeout);
d272 2
a273 2
acctwatch(arg)
	void *arg;
a274 1
	struct timeout *to = (struct timeout *)arg;
d303 1
a303 1
	timeout_add(to, acctchkfreq * hz);
@


1.7.8.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.9 2000/05/05 08:38:23 art Exp $	*/
a170 2
	struct plimit *oplim = NULL;
	int error;
a177 10
	 * Raise the file limit so that accounting can't be stopped by the
	 * user. (XXX - we should think about the cpu limit too).
	 */
	if (p->p_limit->p_refcnt > 1) {
		oplim = p->p_limit;
		p->p_limit = limcopy(p->p_limit);
	}
	p->p_rlimit[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;

	/*
d225 2
a226 9
	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&acct, sizeof (acct),
	    (off_t)0, UIO_SYSSPACE, IO_APPEND|IO_UNIT, p->p_ucred, NULL, p);

	if (oplim) {
		limfree(p->p_limit);
		p->p_limit = oplim;
	}

	return error;
@


1.7.8.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
a59 1
#include <sys/kthread.h>
d76 2
d79 2
a80 3
comp_t	encode_comp_t(u_long, u_long);
int	acct_start(void);
void	acct_thread(void *);
a94 2
struct proc *acct_proc;

d110 1
d136 3
a138 3
	if (acctp != NULL || savacctp != NULL) {
		wakeup(&acct_proc);
		error = vn_close((acctp != NULL ? acctp : savacctp), FWRITE,
d140 1
a140 1
		acctp = savacctp = NULL;
d143 1
a143 1
		return (0);
d150 4
a153 6
	if ((error = acct_start()) != 0) {
		acctp = NULL;
		(void)vn_close(nd.ni_vp, FWRITE, p->p_ucred, p);
		return (error);
	}
	return (0);
d163 2
a164 1
acct_process(struct proc *p)
d176 1
a176 1
	if (vp == NULL)
d259 2
a260 1
encode_comp_t(u_long s, u_long us)
a286 10
int
acct_start(void)
{
	/* Already running. */
	if (acct_proc != NULL)
		return (0);

	return (kthread_create(acct_thread, NULL, &acct_proc, "acct"));
}

d295 2
a296 1
acct_thread(void *arg)
d298 1
d301 5
a305 28
	for (;;) {
		if (savacctp != NULL) {
			if (savacctp->v_type == VBAD) {
				(void) vn_close(savacctp, FWRITE, NOCRED, NULL);
				savacctp = NULL;
				return;
			}
			(void)VFS_STATFS(savacctp->v_mount, &sb, (struct proc *)0);
			if (sb.f_bavail > acctresume * sb.f_blocks / 100) {
				acctp = savacctp;
				savacctp = NULL;
				log(LOG_NOTICE, "Accounting resumed\n");
			}
		} else if (acctp != NULL) {
			if (acctp->v_type == VBAD) {
				(void) vn_close(acctp, FWRITE, NOCRED, NULL);
				acctp = NULL;
				return;
			}
			(void)VFS_STATFS(acctp->v_mount, &sb, (struct proc *)0);
			if (sb.f_bavail <= acctsuspend * sb.f_blocks / 100) {
				savacctp = acctp;
				acctp = NULL;
				log(LOG_NOTICE, "Accounting suspended\n");
			}
		} else {
			acct_proc = NULL;
			kthread_exit(0);
d307 21
a327 2
		tsleep(&acct_proc, PPAUSE, "acct", acctchkfreq *hz);
	}
@


1.7.8.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.7.8.3 2001/11/13 23:04:23 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.8.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 1
a103 1
		syscallarg(const char *) path;
d109 1
a109 1
	if ((error = suser(p, 0)) != 0)
@


1.7.8.6
log
@Merge with the trunk
@
text
@a75 1
void	acct_shutdown(void);
a334 11
	}
}

void
acct_shutdown(void)
{

	if (acctp != NULL || savacctp != NULL) {
		vn_close((acctp != NULL ? acctp : savacctp), FWRITE,
		    NOCRED, NULL);
		acctp = savacctp = NULL;
@


1.6
log
@for acct(), vn_open() with O_APPEND flag so that append-only files work;
problem pointed out by andrew@@untraceable.net
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.5 1997/11/06 05:58:15 csapuntz Exp $	*/
d222 1
a222 2
	    (off_t)0, UIO_SYSSPACE, IO_APPEND|IO_UNIT, p->p_ucred,
	    (int *)0, p));
@


1.5
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.4 1997/10/06 20:19:50 deraadt Exp $	*/
d121 1
a121 1
		if ((error = vn_open(&nd, FWRITE, 0)) != 0)
@


1.4
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_acct.c,v 1.2 1996/03/03 17:19:40 niklas Exp $	*/
d123 1
a123 1
		VOP_UNLOCK(nd.ni_vp);
@


1.3
log
@VFS Lite2 Changes
@
text
@d123 1
a123 1
		VOP_UNLOCK(nd.ni_vp, 0, p);
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d123 1
a123 1
		VOP_UNLOCK(nd.ni_vp);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: kern_acct.c,v 1.41 1995/10/07 06:28:07 mycroft Exp $	*/
d111 1
a111 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d121 1
a121 1
		if (error = vn_open(&nd, FWRITE, 0))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
