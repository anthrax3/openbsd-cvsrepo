head	1.92;
access;
symbols
	OPENBSD_6_0:1.92.0.2
	OPENBSD_6_0_BASE:1.92
	OPENBSD_5_9:1.91.0.2
	OPENBSD_5_9_BASE:1.91
	OPENBSD_5_8:1.87.0.4
	OPENBSD_5_8_BASE:1.87
	OPENBSD_5_7:1.86.0.2
	OPENBSD_5_7_BASE:1.86
	OPENBSD_5_6:1.78.0.4
	OPENBSD_5_6_BASE:1.78
	OPENBSD_5_5:1.73.0.4
	OPENBSD_5_5_BASE:1.73
	OPENBSD_5_4:1.68.0.2
	OPENBSD_5_4_BASE:1.68
	OPENBSD_5_3:1.67.0.2
	OPENBSD_5_3_BASE:1.67
	OPENBSD_5_2:1.66.0.6
	OPENBSD_5_2_BASE:1.66
	OPENBSD_5_1_BASE:1.66
	OPENBSD_5_1:1.66.0.4
	OPENBSD_5_0:1.66.0.2
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.63.0.2
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.61.0.2
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.60.0.2
	OPENBSD_4_7_BASE:1.60
	OPENBSD_4_6:1.56.0.6
	OPENBSD_4_6_BASE:1.56
	OPENBSD_4_5:1.56.0.2
	OPENBSD_4_5_BASE:1.56
	OPENBSD_4_4:1.55.0.4
	OPENBSD_4_4_BASE:1.55
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.52.0.2
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.49.0.4
	OPENBSD_4_1_BASE:1.49
	OPENBSD_4_0:1.49.0.2
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.40.0.4
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.37
	SMP_SYNC_B:1.37
	OPENBSD_3_5:1.36.0.4
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	UBC_SYNC_A:1.35
	OPENBSD_3_3:1.32.0.2
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.31.0.2
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	UBC_SYNC_B:1.32
	UBC:1.29.0.4
	UBC_BASE:1.29
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.6
	OPENBSD_2_8:1.27.0.4
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.27.0.2
	OPENBSD_2_7_BASE:1.27
	SMP:1.25.0.4
	SMP_BASE:1.25
	kame_19991208:1.25
	OPENBSD_2_6:1.25.0.2
	OPENBSD_2_6_BASE:1.25
	OPENBSD_2_5:1.22.0.2
	OPENBSD_2_5_BASE:1.22
	OPENBSD_2_4:1.21.0.2
	OPENBSD_2_4_BASE:1.21
	OPENBSD_2_3:1.20.0.2
	OPENBSD_2_3_BASE:1.20
	OPENBSD_2_2:1.15.0.4
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.92
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.91;
commitid	kCz5QgxnxRMKOzNf;

1.91
date	2015.12.20.10.03.23;	author mpi;	state Exp;
branches;
next	1.90;
commitid	HZUjXsZLQEP5kplx;

1.90
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.89;
commitid	fbhqfhfdKxBcsetK;

1.89
date	2015.09.11.20.43.23;	author dlg;	state Exp;
branches;
next	1.88;
commitid	lTmV1RMoNjwk10Nu;

1.88
date	2015.09.11.19.14.51;	author dlg;	state Exp;
branches;
next	1.87;
commitid	tcvJK23Xd1SxOg7k;

1.87
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.86;
commitid	p4LJxGKbi0BU2cG6;

1.86
date	2015.02.09.13.38.50;	author dlg;	state Exp;
branches;
next	1.85;
commitid	eMvhFUiBesaW2SnV;

1.85
date	2015.02.09.12.37.18;	author dlg;	state Exp;
branches;
next	1.84;
commitid	jH3Dm3ljHp9J11sR;

1.84
date	2015.01.22.01.19.51;	author dlg;	state Exp;
branches;
next	1.83;
commitid	fU9vNstft8jqIvCa;

1.83
date	2015.01.19.23.01.07;	author deraadt;	state Exp;
branches;
next	1.82;
commitid	u69DhkyXuvGPFWP5;

1.82
date	2015.01.19.22.58.53;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	q2qmQe03sXNqYOwm;

1.81
date	2015.01.19.06.27.57;	author dlg;	state Exp;
branches;
next	1.80;
commitid	WcofK0jl8cZjUnkv;

1.80
date	2014.09.18.18.54.29;	author kettenis;	state Exp;
branches;
next	1.79;
commitid	TX9jsBqgspzyUKq3;

1.79
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.78;
commitid	uzzBR7hz9ncd4O6G;

1.78
date	2014.07.13.15.29.04;	author tedu;	state Exp;
branches;
next	1.77;
commitid	bFFVdS3JEaMhyZxJ;

1.77
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.76;
commitid	QlVV51SZgNFxsXxC;

1.76
date	2014.07.12.13.43.08;	author mpi;	state Exp;
branches;
next	1.75;
commitid	BmzaJbdGJKPXN3hj;

1.75
date	2014.03.29.18.09.31;	author guenther;	state Exp;
branches;
next	1.74;

1.74
date	2014.03.13.03.52.56;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2013.12.12.20.56.01;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2013.11.29.05.05.13;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2013.11.27.00.00.53;	author dlg;	state Exp;
branches;
next	1.69;

1.69
date	2013.11.26.11.45.48;	author dlg;	state Exp;
branches;
next	1.68;

1.68
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	2011.06.20.17.05.46;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2011.06.01.03.25.01;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	2010.09.08.15.50.11;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2010.08.31.17.13.48;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2010.06.30.22.05.44;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2010.02.28.17.31.27;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2009.11.23.14.12.10;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2009.11.22.18.40.13;	author pirofti;	state Exp;
branches;
next	1.57;

1.57
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.56;

1.56
date	2008.08.20.04.37.15;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.23.18.21.43;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.29.01.05.13;	author dlg;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.30.05.36.36;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.15.01.56.47;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.09.14.51.54;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2006.05.28.16.43.50;	author mk;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.28.07.12.11;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.28.01.33.50;	author mk;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.17.23.56.03;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2006.05.17.03.43.03;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.14.14.07.20;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2006.01.21.12.20.53;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2006.01.13.19.22.54;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.09.09.09.52;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.23.19.08.55;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.03.17.49.04;	author pefo;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.30.08.11.26;	author grange;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.03.21.14.59;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.19.19.08.53;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2003.03.30.20.52.43;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2002.10.06.23.12.31;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.24.21.53.12;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.01.05.48.18;	author jason;	state Exp;
branches
	1.29.4.1;
next	1.28;

1.28
date	2001.08.31.15.12.05;	author jason;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.09.22.46.03;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.09.19.23.18;	author csapuntz;	state Exp;
branches;
next	1.25;

1.25
date	99.08.08.00.37.09;	author niklas;	state Exp;
branches
	1.25.4.1;
next	1.24;

1.24
date	99.08.05.17.41.44;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	99.07.23.19.45.21;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	99.01.11.05.12.23;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	98.05.11.09.59.39;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	98.02.20.14.51.57;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	98.01.21.12.23.45;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	98.01.20.20.12.11;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	98.01.20.19.05.02;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	97.11.23.08.22.47;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.02.03.03.04.22;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	96.11.21.12.47.15;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	96.10.18.14.46.35;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.09.24.02.40.11;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.08.15.12.33.20;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.07.02.22.21.24;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.07.02.06.51.59;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.06.23.19.34.30;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	96.06.18.09.43.44;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.07.15.23.36;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.04.29.14.17.45;	author hvozda;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.27.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.19.16.09.01;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.19.59;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches;
next	;

1.25.4.1
date	2001.05.14.22.32.42;	author niklas;	state Exp;
branches;
next	1.25.4.2;

1.25.4.2
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.25.4.3;

1.25.4.3
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.25.4.4;

1.25.4.4
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.25.4.5;

1.25.4.5
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.25.4.6;

1.25.4.6
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.25.4.7;

1.25.4.7
date	2004.06.05.23.13.01;	author niklas;	state Exp;
branches;
next	;

1.29.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.29.4.2;

1.29.4.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.29.4.3;

1.29.4.3
date	2003.05.19.22.31.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.92
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@/*	$OpenBSD: subr_autoconf.c,v 1.91 2015/12/20 10:03:23 mpi Exp $	*/
/*	$NetBSD: subr_autoconf.c,v 1.21 1996/04/04 06:06:18 cgd Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratories.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Header: subr_autoconf.c,v 1.12 93/02/01 19:31:48 torek Exp  (LBL)
 *
 *	@@(#)subr_autoconf.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/hotplug.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/queue.h>
#include <sys/mutex.h>
#include <sys/atomic.h>

#include "hotplug.h"
#include "mpath.h"

/*
 * Autoconfiguration subroutines.
 */

/*
 * ioconf.c exports exactly two names: cfdata and cfroots.  All system
 * devices and drivers are found via these tables.
 */
extern short cfroots[];

#define	ROOT ((struct device *)NULL)

struct matchinfo {
	cfmatch_t fn;
	struct	device *parent;
	void	*match, *aux;
	int	indirect, pri;
};

#ifndef AUTOCONF_VERBOSE
#define AUTOCONF_VERBOSE 0
#endif /* AUTOCONF_VERBOSE */
int autoconf_verbose = AUTOCONF_VERBOSE;	/* trace probe calls */

static void mapply(struct matchinfo *, struct cfdata *);

struct deferred_config {
	TAILQ_ENTRY(deferred_config) dc_queue;
	struct device *dc_dev;
	void (*dc_func)(struct device *);
};

TAILQ_HEAD(, deferred_config) deferred_config_queue;
TAILQ_HEAD(, deferred_config) mountroot_config_queue;

void *config_rootsearch(cfmatch_t, char *, void *);
void config_process_deferred_children(struct device *);

struct devicelist alldevs;		/* list of all devices */

volatile int config_pending;		/* semaphore for mountroot */

struct mutex autoconf_attdet_mtx = MUTEX_INITIALIZER(IPL_HIGH);
/*
 * If > 0, devices are being attached and any thread which tries to
 * detach will sleep; if < 0 devices are being detached and any
 * thread which tries to attach will sleep.
 */
int	autoconf_attdet;

/*
 * Initialize autoconfiguration data structures.  This occurs before console
 * initialization as that might require use of this subsystem.  Furthermore
 * this means that malloc et al. isn't yet available.
 */
void
config_init(void)
{
	TAILQ_INIT(&deferred_config_queue);
	TAILQ_INIT(&mountroot_config_queue);
	TAILQ_INIT(&alldevs);
}

/*
 * Apply the matching function and choose the best.  This is used
 * a few times and we want to keep the code small.
 */
void
mapply(struct matchinfo *m, struct cfdata *cf)
{
	int pri;
	void *match;

	if (m->indirect)
		match = config_make_softc(m->parent, cf);
	else
		match = cf;

	if (autoconf_verbose) {
		printf(">>> probing for %s", cf->cf_driver->cd_name);
		if (cf->cf_fstate == FSTATE_STAR)
			printf("*\n");
		else
			printf("%d\n", cf->cf_unit);
	}
	if (m->fn != NULL)
		pri = (*m->fn)(m->parent, match, m->aux);
	else {
	        if (cf->cf_attach->ca_match == NULL) {
			panic("mapply: no match function for '%s' device",
			    cf->cf_driver->cd_name);
		}
		pri = (*cf->cf_attach->ca_match)(m->parent, match, m->aux);
	}
	if (autoconf_verbose)
		printf(">>> %s probe returned %d\n", cf->cf_driver->cd_name,
		    pri);

	if (pri > m->pri) {
		if (m->indirect && m->match)
			free(m->match, M_DEVBUF, 0);
		m->match = match;
		m->pri = pri;
	} else {
		if (m->indirect)
			free(match, M_DEVBUF, 0);
	}
}

/*
 * Iterate over all potential children of some device, calling the given
 * function (default being the child's match function) for each one.
 * Nonzero returns are matches; the highest value returned is considered
 * the best match.  Return the `found child' if we got a match, or NULL
 * otherwise.  The `aux' pointer is simply passed on through.
 *
 * Note that this function is designed so that it can be used to apply
 * an arbitrary function to all potential children (its return value
 * can be ignored).
 */
void *
config_search(cfmatch_t fn, struct device *parent, void *aux)
{
	struct cfdata *cf;
	short *p;
	struct matchinfo m;

	m.fn = fn;
	m.parent = parent;
	m.match = NULL;
	m.aux = aux;
	m.indirect = parent && parent->dv_cfdata->cf_driver->cd_indirect;
	m.pri = 0;

	for (cf = cfdata; cf->cf_driver; cf++) {
		/*
		 * Skip cf if no longer eligible, otherwise scan
		 * through parents for one matching `parent',
		 * and try match function.
		 */
		if (cf->cf_fstate == FSTATE_FOUND)
			continue;
		if (cf->cf_fstate == FSTATE_DNOTFOUND ||
		    cf->cf_fstate == FSTATE_DSTAR)
			continue;
		for (p = cf->cf_parents; *p >= 0; p++)
			if (parent->dv_cfdata == &cfdata[*p])
				mapply(&m, cf);
	}

	if (autoconf_verbose) {
		if (m.match) {
			if (m.indirect)
				cf = ((struct device *)m.match)->dv_cfdata;
			else
				cf = (struct cfdata *)m.match;
			printf(">>> %s probe won\n",
			    cf->cf_driver->cd_name);
		} else
			printf(">>> no winning probe\n");
	}
	return (m.match);
}

/*
 * Iterate over all potential children of some device, calling the given
 * function for each one.
 *
 * Note that this function is designed so that it can be used to apply
 * an arbitrary function to all potential children (its return value
 * can be ignored).
 */
void
config_scan(cfscan_t fn, struct device *parent)
{
	struct cfdata *cf;
	short *p;
	void *match;
	int indirect;

	indirect = parent && parent->dv_cfdata->cf_driver->cd_indirect;

	for (cf = cfdata; cf->cf_driver; cf++) {
		/*
		 * Skip cf if no longer eligible, otherwise scan
		 * through parents for one matching `parent',
		 * and try match function.
		 */
		if (cf->cf_fstate == FSTATE_FOUND)
			continue;
		if (cf->cf_fstate == FSTATE_DNOTFOUND ||
		    cf->cf_fstate == FSTATE_DSTAR)
			continue;
		for (p = cf->cf_parents; *p >= 0; p++)
			if (parent->dv_cfdata == &cfdata[*p]) {
				match = indirect?
				    config_make_softc(parent, cf) :
				    (void *)cf;
				(*fn)(parent, match);
			}
	}
}

/*
 * Find the given root device.
 * This is much like config_search, but there is no parent.
 */
void *
config_rootsearch(cfmatch_t fn, char *rootname, void *aux)
{
	struct cfdata *cf;
	short *p;
	struct matchinfo m;

	m.fn = fn;
	m.parent = ROOT;
	m.match = NULL;
	m.aux = aux;
	m.indirect = 0;
	m.pri = 0;
	/*
	 * Look at root entries for matching name.  We do not bother
	 * with found-state here since only one instance of each possible
	 * root child should ever be searched.
	 */
	for (p = cfroots; *p >= 0; p++) {
		cf = &cfdata[*p];
		if (cf->cf_fstate == FSTATE_DNOTFOUND ||
		    cf->cf_fstate == FSTATE_DSTAR)
			continue;
		if (strcmp(cf->cf_driver->cd_name, rootname) == 0)
			mapply(&m, cf);
	}
	return (m.match);
}

const char *msgs[3] = { "", " not configured\n", " unsupported\n" };

/*
 * The given `aux' argument describes a device that has been found
 * on the given parent, but not necessarily configured.  Locate the
 * configuration data for that device (using the submatch function
 * provided, or using candidates' cd_match configuration driver
 * functions) and attach it, and return true.  If the device was
 * not configured, call the given `print' function and return 0.
 */
struct device *
config_found_sm(struct device *parent, void *aux, cfprint_t print,
    cfmatch_t submatch)
{
	void *match;

	if ((match = config_search(submatch, parent, aux)) != NULL)
		return (config_attach(parent, match, aux, print));
	if (print)
		printf("%s", msgs[(*print)(aux, parent->dv_xname)]);
	return (NULL);
}

/*
 * As above, but for root devices.
 */
struct device *
config_rootfound(char *rootname, void *aux)
{
	void *match;

	if ((match = config_rootsearch((cfmatch_t)NULL, rootname, aux)) != NULL)
		return (config_attach(ROOT, match, aux, (cfprint_t)NULL));
	printf("root device %s not configured\n", rootname);
	return (NULL);
}

/*
 * Attach a found device.  Allocates memory for device variables.
 */
struct device *
config_attach(struct device *parent, void *match, void *aux, cfprint_t print)
{
	struct cfdata *cf;
	struct device *dev;
	struct cfdriver *cd;
	struct cfattach *ca;

	mtx_enter(&autoconf_attdet_mtx);
	while (autoconf_attdet < 0)
		msleep(&autoconf_attdet, &autoconf_attdet_mtx,
		    PWAIT, "autoconf", 0);
	autoconf_attdet++;
	mtx_leave(&autoconf_attdet_mtx);

	if (parent && parent->dv_cfdata->cf_driver->cd_indirect) {
		dev = match;
		cf = dev->dv_cfdata;
	} else {
		cf = match;
		dev = config_make_softc(parent, cf);
	}

	cd = cf->cf_driver;
	ca = cf->cf_attach;

	KASSERT(cd->cd_devs != NULL);
	KASSERT(dev->dv_unit < cd->cd_ndevs);
	KASSERT(cd->cd_devs[dev->dv_unit] == NULL);
	cd->cd_devs[dev->dv_unit] = dev;

	/*
	 * If this is a "STAR" device and we used the last unit, prepare for
	 * another one.
	 */
	if (cf->cf_fstate == FSTATE_STAR) {
		if (dev->dv_unit == cf->cf_unit)
			cf->cf_unit++;
	} else
		cf->cf_fstate = FSTATE_FOUND;

	TAILQ_INSERT_TAIL(&alldevs, dev, dv_list);
	device_ref(dev);

	if (parent == ROOT)
		printf("%s at root", dev->dv_xname);
	else {
		printf("%s at %s", dev->dv_xname, parent->dv_xname);
		if (print)
			(void) (*print)(aux, NULL);
	}

	/*
	 * Before attaching, clobber any unfound devices that are
	 * otherwise identical, or bump the unit number on all starred
	 * cfdata for this device.
	 */
	for (cf = cfdata; cf->cf_driver; cf++) {
		if (cf->cf_driver == cd &&
		    cf->cf_unit == dev->dv_unit) {
			if (cf->cf_fstate == FSTATE_NOTFOUND)
				cf->cf_fstate = FSTATE_FOUND;
			if (cf->cf_fstate == FSTATE_STAR)
				cf->cf_unit++;
		}
	}
	device_register(dev, aux);
	(*ca->ca_attach)(parent, dev, aux);
	config_process_deferred_children(dev);
#if NHOTPLUG > 0
	if (!cold)
		hotplug_device_attach(cd->cd_class, dev->dv_xname);
#endif

	mtx_enter(&autoconf_attdet_mtx);
	if (--autoconf_attdet == 0)
		wakeup(&autoconf_attdet);
	mtx_leave(&autoconf_attdet_mtx);
	return (dev);
}

struct device *
config_make_softc(struct device *parent, struct cfdata *cf)
{
	struct device *dev;
	struct cfdriver *cd;
	struct cfattach *ca;

	cd = cf->cf_driver;
	ca = cf->cf_attach;
	if (ca->ca_devsize < sizeof(struct device))
		panic("config_make_softc");

	/* get memory for all device vars */
	dev = malloc(ca->ca_devsize, M_DEVBUF, M_NOWAIT|M_ZERO);
	if (dev == NULL)
		panic("config_make_softc: allocation for device softc failed");

	dev->dv_class = cd->cd_class;
	dev->dv_cfdata = cf;
	dev->dv_flags = DVF_ACTIVE;	/* always initially active */

	/* If this is a STAR device, search for a free unit number */
	if (cf->cf_fstate == FSTATE_STAR) {
		for (dev->dv_unit = cf->cf_starunit1;
		    dev->dv_unit < cf->cf_unit; dev->dv_unit++)
			if (cd->cd_ndevs == 0 ||
			    dev->dv_unit >= cd->cd_ndevs ||
			    cd->cd_devs[dev->dv_unit] == NULL)
				break;
	} else
		dev->dv_unit = cf->cf_unit;

	/* Build the device name into dv_xname. */
	if (snprintf(dev->dv_xname, sizeof(dev->dv_xname), "%s%d",
	    cd->cd_name, dev->dv_unit) >= sizeof(dev->dv_xname))
		panic("config_make_softc: device name too long");
	dev->dv_parent = parent;

	/* put this device in the devices array */
	if (dev->dv_unit >= cd->cd_ndevs) {
		/*
		 * Need to expand the array.
		 */
		int old = cd->cd_ndevs, new;
		void **nsp;

		if (old == 0)
			new = MINALLOCSIZE / sizeof(void *);
		else
			new = old * 2;
		while (new <= dev->dv_unit)
			new *= 2;
		cd->cd_ndevs = new;
		nsp = mallocarray(new, sizeof(void *), M_DEVBUF, M_NOWAIT|M_ZERO);
		if (nsp == NULL)
			panic("config_make_softc: %sing dev array",
			    old != 0 ? "expand" : "creat");
		if (old != 0) {
			bcopy(cd->cd_devs, nsp, old * sizeof(void *));
			free(cd->cd_devs, M_DEVBUF, 0);
		}
		cd->cd_devs = nsp;
	}
	if (cd->cd_devs[dev->dv_unit])
		panic("config_make_softc: duplicate %s", dev->dv_xname);

	dev->dv_ref = 1;

	return (dev);
}

/*
 * Detach a device.  Optionally forced (e.g. because of hardware
 * removal) and quiet.  Returns zero if successful, non-zero
 * (an error code) otherwise.
 *
 * Note that this code wants to be run from a process context, so
 * that the detach can sleep to allow processes which have a device
 * open to run and unwind their stacks.
 */
int
config_detach(struct device *dev, int flags)
{
	struct cfdata *cf;
	struct cfattach *ca;
	struct cfdriver *cd;
	int rv = 0, i;
#ifdef DIAGNOSTIC
	struct device *d;
#endif
#if NHOTPLUG > 0
	char devname[16];
#endif

	mtx_enter(&autoconf_attdet_mtx);
	while (autoconf_attdet > 0)
		msleep(&autoconf_attdet, &autoconf_attdet_mtx,
		    PWAIT, "autoconf", 0);
	autoconf_attdet--;
	mtx_leave(&autoconf_attdet_mtx);

#if NHOTPLUG > 0
	strlcpy(devname, dev->dv_xname, sizeof(devname));
#endif

	cf = dev->dv_cfdata;
#ifdef DIAGNOSTIC
	if (cf->cf_fstate != FSTATE_FOUND && cf->cf_fstate != FSTATE_STAR)
		panic("config_detach: bad device fstate");
#endif
	ca = cf->cf_attach;
	cd = cf->cf_driver;

	/*
	 * Ensure the device is deactivated.  If the device has an
	 * activation entry point and DVF_ACTIVE is still set, the
	 * device is busy, and the detach fails.
	 */
	rv = config_deactivate(dev);

	/*
	 * Try to detach the device.  If that's not possible, then
	 * we either panic() (for the forced but failed case), or
	 * return an error.
	 */
	if (rv == 0) {
		if (ca->ca_detach != NULL)
			rv = (*ca->ca_detach)(dev, flags);
		else
			rv = EOPNOTSUPP;
	}
	if (rv != 0) {
		if ((flags & DETACH_FORCE) == 0)
			goto done;
		else
			panic("config_detach: forced detach of %s failed (%d)",
			    dev->dv_xname, rv);
	}

	/*
	 * The device has now been successfully detached.
	 */

#ifdef DIAGNOSTIC
	/*
	 * Sanity: If you're successfully detached, you should have no
	 * children.  (Note that because children must be attached
	 * after parents, we only need to search the latter part of
	 * the list.)
	 */
	i = 0;
	for (d = TAILQ_NEXT(dev, dv_list); d != NULL;
	     d = TAILQ_NEXT(d, dv_list)) {
		if (d->dv_parent == dev) {
			printf("config_detach: %s attached at %s\n",
			    d->dv_xname, dev->dv_xname);
			i = 1;
		}
	}
	if (i != 0)
		panic("config_detach: detached device (%s) has children",
		    dev->dv_xname);
#endif

	/*
	 * Mark cfdata to show that the unit can be reused, if possible.
	 * Note that we can only re-use a starred unit number if the unit
	 * being detached had the last assigned unit number.
	 */
	for (cf = cfdata; cf->cf_driver; cf++) {
		if (cf->cf_driver == cd) {
			if (cf->cf_fstate == FSTATE_FOUND &&
			    cf->cf_unit == dev->dv_unit)
				cf->cf_fstate = FSTATE_NOTFOUND;
			if (cf->cf_fstate == FSTATE_STAR &&
			    cf->cf_unit == dev->dv_unit + 1)
				cf->cf_unit--;
		}
	}

	/*
	 * Unlink from device list.
	 */
	TAILQ_REMOVE(&alldevs, dev, dv_list);
	device_unref(dev);

	/*
	 * Remove from cfdriver's array, tell the world, and free softc.
	 */
	cd->cd_devs[dev->dv_unit] = NULL;
	if ((flags & DETACH_QUIET) == 0)
		printf("%s detached\n", dev->dv_xname);

	device_unref(dev);
	/*
	 * If the device now has no units in use, deallocate its softc array.
	 */
	for (i = 0; i < cd->cd_ndevs; i++)
		if (cd->cd_devs[i] != NULL)
			break;
	if (i == cd->cd_ndevs) {		/* nothing found; deallocate */
		free(cd->cd_devs, M_DEVBUF, 0);
		cd->cd_devs = NULL;
		cd->cd_ndevs = 0;
		cf->cf_unit = 0;
	}

#if NHOTPLUG > 0
	if (!cold)
		hotplug_device_detach(cd->cd_class, devname);
#endif

	/*
	 * Return success.
	 */
done:
	mtx_enter(&autoconf_attdet_mtx);
	if (++autoconf_attdet == 0)
		wakeup(&autoconf_attdet);
	mtx_leave(&autoconf_attdet_mtx);
	return (rv);
}

int
config_deactivate(struct device *dev)
{
	int rv = 0, oflags = dev->dv_flags;

	if (dev->dv_flags & DVF_ACTIVE) {
		dev->dv_flags &= ~DVF_ACTIVE;
		rv = config_suspend(dev, DVACT_DEACTIVATE);
		if (rv)
			dev->dv_flags = oflags;
	}
	return (rv);
}

/*
 * Defer the configuration of the specified device until all
 * of its parent's devices have been attached.
 */
void
config_defer(struct device *dev, void (*func)(struct device *))
{
	struct deferred_config *dc;

	if (dev->dv_parent == NULL)
		panic("config_defer: can't defer config of a root device");

#ifdef DIAGNOSTIC
	for (dc = TAILQ_FIRST(&deferred_config_queue); dc != NULL;
	     dc = TAILQ_NEXT(dc, dc_queue)) {
		if (dc->dc_dev == dev)
			panic("config_defer: deferred twice");
	}
#endif

	if ((dc = malloc(sizeof(*dc), M_DEVBUF, M_NOWAIT)) == NULL)
		panic("config_defer: can't allocate defer structure");

	dc->dc_dev = dev;
	dc->dc_func = func;
	TAILQ_INSERT_TAIL(&deferred_config_queue, dc, dc_queue);
	config_pending_incr();
}

/*
 * Defer the configuration of the specified device until after
 * root file system is mounted.
 */
void
config_mountroot(struct device *dev, void (*func)(struct device *))
{
	struct deferred_config *dc;

	/*
	 * No need to defer if root file system is already mounted.
	 */
	if (rootvp != NULL) {
		(*func)(dev);
		return;
	}

#ifdef DIAGNOSTIC
	for (dc = TAILQ_FIRST(&mountroot_config_queue); dc != NULL;
	     dc = TAILQ_NEXT(dc, dc_queue)) {
		if (dc->dc_dev == dev)
			panic("config_mountroot: deferred twice");
	}
#endif

	if ((dc = malloc(sizeof(*dc), M_DEVBUF, M_NOWAIT)) == NULL)
		panic("config_mountroot: can't allocate defer structure");

	dc->dc_dev = dev;
	dc->dc_func = func;
	TAILQ_INSERT_TAIL(&mountroot_config_queue, dc, dc_queue);
}

/*
 * Process the deferred configuration queue for a device.
 */
void
config_process_deferred_children(struct device *parent)
{
	struct deferred_config *dc, *ndc;

	for (dc = TAILQ_FIRST(&deferred_config_queue);
	     dc != NULL; dc = ndc) {
		ndc = TAILQ_NEXT(dc, dc_queue);
		if (dc->dc_dev->dv_parent == parent) {
			TAILQ_REMOVE(&deferred_config_queue, dc, dc_queue);
			(*dc->dc_func)(dc->dc_dev);
			free(dc, M_DEVBUF, sizeof(*dc));
			config_pending_decr();
		}
	}
}

/*
 * Process the deferred configuration queue after the root file
 * system is mounted .
 */
void
config_process_deferred_mountroot(void)
{
	struct deferred_config *dc;

	while ((dc = TAILQ_FIRST(&mountroot_config_queue)) != NULL) {
		TAILQ_REMOVE(&mountroot_config_queue, dc, dc_queue);
		(*dc->dc_func)(dc->dc_dev);
		free(dc, M_DEVBUF, sizeof(*dc));
	}
}

/*
 * Manipulate the config_pending semaphore.
 */
void
config_pending_incr(void)
{

	config_pending++;
}

void
config_pending_decr(void)
{

#ifdef DIAGNOSTIC
	if (config_pending == 0)
		panic("config_pending_decr: config_pending == 0");
#endif
	config_pending--;
	if (config_pending == 0)
		wakeup((void *)&config_pending);
}

int
config_detach_children(struct device *parent, int flags)
{
	struct device *dev, *next_dev;
	int rv = 0;

	/*
	 * The config_detach routine may sleep, meaning devices
	 * may be added to the queue. However, all devices will
	 * be added to the tail of the queue, the queue won't
	 * be re-organized, and the subtree of parent here should be locked
	 * for purposes of adding/removing children.
	 *
	 * Note that we can not afford trying to walk the device list
	 * once - our ``next'' device might be a child of the device
	 * we are about to detach, so it would disappear.
	 * Just play it safe and restart from the parent.
	 */
	for (dev = TAILQ_LAST(&alldevs, devicelist);
	    dev != NULL; dev = next_dev) {
		if (dev->dv_parent == parent) {
			if ((rv = config_detach(dev, flags)) != 0)
				return (rv);
			next_dev = TAILQ_LAST(&alldevs, devicelist);
		} else {
			next_dev = TAILQ_PREV(dev, devicelist, dv_list);
		}
	}

	return (0);
}

int
config_suspend(struct device *dev, int act)
{
	struct cfattach *ca = dev->dv_cfdata->cf_attach;
	int r;

	device_ref(dev);
	if (ca->ca_activate)
		r = (*ca->ca_activate)(dev, act);
	else
		r = config_activate_children(dev, act);
	device_unref(dev);
	return (r);
}

int
config_suspend_all(int act)
{
	struct device *mainbus = device_mainbus();
	struct device *mpath = device_mpath();
	int rv = 0;

	switch (act) {
	case DVACT_QUIESCE:
	case DVACT_SUSPEND:
	case DVACT_POWERDOWN:
		if (mpath) {
			rv = config_suspend(mpath, act);
			if (rv)
				return rv;
		}
		if (mainbus)
			rv = config_suspend(mainbus, act);
		break;
	case DVACT_RESUME:
	case DVACT_WAKEUP:
		if (mainbus) {
			rv = config_suspend(mainbus, act);
			if (rv)
				return rv;
		}
		if (mpath)
			rv = config_suspend(mpath, act);
		break;
	}

	return (rv);
}

/*
 * Call the ca_activate for each of our children, letting each
 * decide whether they wish to do the same for their children
 * and more.
 */
int
config_activate_children(struct device *parent, int act)
{
	struct device *d;
	int rv = 0;

	for (d = TAILQ_NEXT(parent, dv_list); d != NULL;
	    d = TAILQ_NEXT(d, dv_list)) {
		if (d->dv_parent != parent)
			continue;
		switch (act) {
		case DVACT_QUIESCE:
		case DVACT_SUSPEND:
		case DVACT_RESUME:
		case DVACT_WAKEUP:
		case DVACT_POWERDOWN:
			rv = config_suspend(d, act);
			break;
		case DVACT_DEACTIVATE:
			rv = config_deactivate(d);
			break;
		}
		if (rv == 0)
			continue;

		/*
		 * Found a device that refuses the action.
		 * If we were being asked to suspend, we can
		 * try to resume all previous devices.
		 */
#ifdef DIAGNOSTIC
		printf("config_activate_children: device %s failed %d\n",
		    d->dv_xname, act);
#endif
		if (act == DVACT_RESUME)
			printf("failing resume cannot be handled\n");
		if (act == DVACT_POWERDOWN)
			return (rv);
		if (act != DVACT_SUSPEND)
			return (rv);

		d = TAILQ_PREV(d, devicelist, dv_list);
		for (; d != NULL && d != parent;
		    d = TAILQ_PREV(d, devicelist, dv_list)) {
			if (d->dv_parent != parent)
				continue;
			printf("resume %s\n", d->dv_xname);
			config_suspend(d, DVACT_RESUME);
		}
		return (rv);
	}
	return (rv);
}

/* 
 * Lookup a device in the cfdriver device array.  Does not return a
 * device if it is not active.
 *
 * Increments ref count on the device by one, reflecting the
 * new reference created on the stack.
 *
 * Context: process only 
 */
struct device *
device_lookup(struct cfdriver *cd, int unit)
{
	struct device *dv = NULL;

	if (unit >= 0 && unit < cd->cd_ndevs)
		dv = (struct device *)(cd->cd_devs[unit]);

	if (!dv)
		return (NULL);

	if (!(dv->dv_flags & DVF_ACTIVE))
		dv = NULL;

	if (dv != NULL)
		device_ref(dv);

	return (dv);
}

struct device *
device_mainbus(void)
{
	extern struct cfdriver mainbus_cd;

	if (mainbus_cd.cd_ndevs < 1)
		return (NULL);

	return (mainbus_cd.cd_devs[0]);
}

struct device *
device_mpath(void)
{
#if NMPATH > 0
	extern struct cfdriver mpath_cd;

	if (mpath_cd.cd_ndevs < 1)
		return (NULL);

	return (mpath_cd.cd_devs[0]);
#else
	return (NULL);
#endif
}

/*
 * Increments the ref count on the device structure. The device
 * structure is freed when the ref count hits 0.
 *
 * Context: process or interrupt
 */
void
device_ref(struct device *dv)
{
	atomic_inc_int(&dv->dv_ref);
}

/*
 * Decrement the ref count on the device structure.
 *
 * free's the structure when the ref count hits zero.
 *
 * Context: process or interrupt
 */
void
device_unref(struct device *dv)
{
	struct cfattach *ca;

	if (atomic_dec_int_nv(&dv->dv_ref) == 0) {
		ca = dv->dv_cfdata->cf_attach;
		free(dv, M_DEVBUF, ca->ca_devsize);
	}
}
@


1.91
log
@Simple free(9) sizes, from Matthieu <naabed AT poolp DOT org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.90 2015/12/11 16:07:02 mpi Exp $	*/
d383 1
a383 1
			(void) (*print)(aux, (char *)0);
@


1.90
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.89 2015/09/11 20:43:23 dlg Exp $	*/
d728 1
a728 1
			free(dc, M_DEVBUF, 0);
d746 1
a746 1
		free(dc, M_DEVBUF, 0);
@


1.89
log
@back out refcnt for dv_ref, there's too many hand crafted devices all
over the tree.

much encouragement from l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.88 2015/09/11 19:14:51 dlg Exp $	*/
d91 1
d93 1
d117 1
d682 33
d735 16
d929 1
a929 1
	
d961 1
a961 1
		
@


1.88
log
@use refcnts for the device reference counts as an example of how
refcnt(9) can be used.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.87 2015/03/14 03:38:50 jsg Exp $	*/
d478 1
a478 1
	refcnt_init(&dev->dv_ref);
d925 1
a925 1
	refcnt_take(&dv->dv_ref);
d940 1
a940 1
	if (refcnt_rele(&dv->dv_ref)) {
@


1.87
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.86 2015/02/09 13:38:50 dlg Exp $	*/
d478 1
a478 1
	dev->dv_ref = 1;
d925 1
a925 1
	atomic_inc_int(&dv->dv_ref);
d940 1
a940 1
	if (atomic_dec_int_nv(&dv->dv_ref) == 0) {
@


1.86
log
@you need atomic.h to do atomic things.

pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.85 2015/02/09 12:37:18 dlg Exp $	*/
a48 1
#include <sys/limits.h>
@


1.85
log
@use atomic ops to increment and decrement the device ref count in
device_ref and device_unref.

ok guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.84 2015/01/22 01:19:51 dlg Exp $	*/
d54 1
@


1.84
log
@bring back r1.80:

pass the size of the softc to free.

this time we only dereference the cfattach structure if we actually
need it once the refcount has dropped to 0.

tested by krw@@ who found the original panic r1.80 was backed out for.
putting this in again so i can find out when else will break.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.83 2015/01/19 23:01:07 deraadt Exp $	*/
d925 1
a925 1
	dv->dv_ref++;
d940 1
a940 2
	dv->dv_ref--;
	if (dv->dv_ref == 0) {
@


1.83
log
@back it out properly
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.80 2014/09/18 18:54:29 kettenis Exp $	*/
d938 2
d942 2
a943 1
		free(dv, M_DEVBUF, 0);
@


1.82
log
@never tested with a make release
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.81 2015/01/19 06:27:57 dlg Exp $	*/
a937 2
	struct cfattach *ca = dv->dv_cfdata->cf_attach;

@


1.81
log
@pass the size of the softc to free.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.80 2014/09/18 18:54:29 kettenis Exp $	*/
d942 1
a942 1
		free(dv, M_DEVBUF, ca->ca_devsize);
@


1.80
log
@Introduce config_suspend_all(9) a function that invokes config_suspend(9)
on all relevant device hierarchies in the appropriate order.  For now this
means mpath(4) and mainbus(4), doing mpath(4) before mainbus(4) when
suspending or powering down and doing mpath(4) after mainbus(4) when
resuming such that mpath(4) can realy on the underlying hardware being
in a functional state.

Fixes problems with unflushed disk caches on machines where mpath(4) takes
control of some of your disks.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.79 2014/09/14 14:17:25 jsg Exp $	*/
d938 2
d942 1
a942 1
		free(dv, M_DEVBUF, 0);
@


1.79
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.78 2014/07/13 15:29:04 tedu Exp $	*/
d56 1
d768 34
d899 15
@


1.78
log
@use mallocarray where arguments are multipled. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.77 2014/07/12 18:43:32 tedu Exp $	*/
a52 1
#include <sys/proc.h>
@


1.77
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.76 2014/07/12 13:43:08 mpi Exp $	*/
d465 1
a465 1
		nsp = malloc(new * sizeof(void *), M_DEVBUF, M_NOWAIT|M_ZERO);
@


1.76
log
@Change config_deactivate(9) to always unset the DVF_ACTIVE flag so
that drivers can check for this flag to know they have to stop doing
any hardware access and release their reference.

While here makes the ca_activate() function optional and propagates
DVACT_DEACTIVATE to the children of a device that do not implement this
interface like it is done during suspend/resume.

ok uebayasi@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.75 2014/03/29 18:09:31 guenther Exp $	*/
d155 1
a155 1
			free(m->match, M_DEVBUF);
d160 1
a160 1
			free(match, M_DEVBUF);
d471 1
a471 1
			free(cd->cd_devs, M_DEVBUF);
d613 1
a613 1
		free(cd->cd_devs, M_DEVBUF);
d692 1
a692 1
			free(dc, M_DEVBUF);
d891 1
a891 1
		free(dv, M_DEVBUF);
@


1.75
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.74 2014/03/13 03:52:56 dlg Exp $	*/
d526 2
a527 3
	 * Ensure the device is deactivated.  If the device doesn't
	 * have an activation entry point, we allow DVF_ACTIVE to
	 * remain set.  Otherwise, if DVF_ACTIVE is still set, the
d530 1
a530 2
	if (ca->ca_activate != NULL)
		rv = config_deactivate(dev);
a637 1
	struct cfattach *ca = dev->dv_cfdata->cf_attach;
a639 3
	if (ca->ca_activate == NULL)
		return (EOPNOTSUPP);

d642 1
a642 1
		rv = (*ca->ca_activate)(dev, DVACT_DEACTIVATE);
d764 1
a764 1
	device_unref(dev);      
@


1.74
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.73 2013/12/12 20:56:01 guenther Exp $	*/
d96 1
a96 1
__volatile int config_pending;		/* semaphore for mountroot */
@


1.73
log
@printf(variable) --> printf("%s", variable)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.72 2013/12/06 21:03:02 deraadt Exp $	*/
d862 10
@


1.72
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.71 2013/11/29 05:05:13 deraadt Exp $	*/
d310 1
a310 1
		printf(msgs[(*print)(aux, parent->dv_xname)]);
@


1.71
log
@msgs can be const
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.70 2013/11/27 00:00:53 dlg Exp $	*/
d763 1
d765 1
d767 1
a767 1
		return (*ca->ca_activate)(dev, act);
d769 3
a771 1
		return config_activate_children(dev, act);
d790 1
d793 1
a793 1
		case DVACT_QUIESCE:
@


1.70
log
@get rid of the goop for maintaining multiple cftables since theres
no current code there to add or remove them. such code was put in
17 years ago, disabled 14 years ago, and removed 11 years ago, so
i suspect we dont really need it or the goop to support it.

very ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.69 2013/11/26 11:45:48 dlg Exp $	*/
d291 1
a291 1
char *msgs[3] = { "", " not configured\n", " unsupported\n" };
@


1.69
log
@compare pointers to NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.68 2013/05/30 16:15:02 deraadt Exp $	*/
a76 6
struct cftable_head allcftables;

static struct cftable staticcftable = {
	cfdata
};

a115 2
	TAILQ_INIT(&allcftables);
	TAILQ_INSERT_TAIL(&allcftables, &staticcftable, list);
a180 1
	struct cftable *t;
d188 15
a202 16
	TAILQ_FOREACH(t, &allcftables, list) {
		for (cf = t->tab; cf->cf_driver; cf++) {
			/*
			 * Skip cf if no longer eligible, otherwise scan
			 * through parents for one matching `parent',
			 * and try match function.
			 */
			if (cf->cf_fstate == FSTATE_FOUND)
				continue;
			if (cf->cf_fstate == FSTATE_DNOTFOUND ||
			    cf->cf_fstate == FSTATE_DSTAR)
				continue;
			for (p = cf->cf_parents; *p >= 0; p++)
				if (parent->dv_cfdata == &(t->tab)[*p])
					mapply(&m, cf);
		}
d204 1
a233 1
	struct cftable *t;
d236 19
a254 20
	TAILQ_FOREACH(t, &allcftables, list) {
		for (cf = t->tab; cf->cf_driver; cf++) {
			/*
			 * Skip cf if no longer eligible, otherwise scan
			 * through parents for one matching `parent',
			 * and try match function.
			 */
			if (cf->cf_fstate == FSTATE_FOUND)
				continue;
			if (cf->cf_fstate == FSTATE_DNOTFOUND ||
			    cf->cf_fstate == FSTATE_DSTAR)
				continue;
			for (p = cf->cf_parents; *p >= 0; p++)
				if (parent->dv_cfdata == &(t->tab)[*p]) {
					match = indirect?
					    config_make_softc(parent, cf) :
					    (void *)cf;
					(*fn)(parent, match);
				}
		}
a337 1
	struct cftable *t;
d388 8
a395 9
	TAILQ_FOREACH(t, &allcftables, list) {
		for (cf = t->tab; cf->cf_driver; cf++)
			if (cf->cf_driver == cd &&
			    cf->cf_unit == dev->dv_unit) {
				if (cf->cf_fstate == FSTATE_NOTFOUND)
					cf->cf_fstate = FSTATE_FOUND;
				if (cf->cf_fstate == FSTATE_STAR)
					cf->cf_unit++;
			}
@


1.68
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.67 2012/10/08 21:47:50 deraadt Exp $	*/
d439 1
a439 1
	if (!dev)
d479 1
a479 1
		if (nsp == 0)
@


1.67
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.66 2011/07/03 15:47:16 matthew Exp $	*/
d777 1
a777 4
	if (ca->ca_activate) {
#if 0
		printf("activate: %s %d\n", dev->dv_xname, act);
#endif
d779 2
a780 2
	}
	return (0);
@


1.66
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.65 2011/06/20 17:05:46 deraadt Exp $	*/
d805 1
d826 2
@


1.65
log
@serialize attach and detach of device sub-trees -- only one device
sub-tree may attach or detach at a time.  attach and detach will sleep
against each other.
this is fixing (working around?) some bizzare corner cases that have
been seen (but not fully diagnosed) where the device trees, disk registration
subsystem, and other things could get messed up.  one could argue though
that this serialization is a very good thing; it is easier than adding piles
of locks in various other places.
ok matthew jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.64 2011/06/01 03:25:01 matthew Exp $	*/
a650 18
config_activate(struct device *dev)
{
	struct cfattach *ca = dev->dv_cfdata->cf_attach;
	int rv = 0, oflags = dev->dv_flags;

	if (ca->ca_activate == NULL)
		return (EOPNOTSUPP);

	if ((dev->dv_flags & DVF_ACTIVE) == 0) {
		dev->dv_flags |= DVF_ACTIVE;
		rv = (*ca->ca_activate)(dev, DVACT_ACTIVATE);
		if (rv)
			dev->dv_flags = oflags;
	}
	return (rv);
}

int
a801 3
		case DVACT_ACTIVATE:
			rv = config_activate(d);
			break;
@


1.64
log
@Add a few KASSERTs to config_attach() for sanity to make sure we don't
try to reuse device unit numbers and to check that the device pointer
array is allocated and large enough.

Also, improve the panic message generated by config_detach() when we
detect that we're detaching a device that still has children.

Discussed with deraadt@@ while trying to brainstorm ways that
interleaving config_attach and config_detach could blow up.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.63 2010/09/08 15:50:11 deraadt Exp $	*/
d54 1
d104 8
d351 7
d417 5
d519 7
d560 1
a560 1
			return (rv);
d642 6
a647 1
	return (0);
@


1.63
log
@remove a useless comment
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.62 2010/08/31 17:13:48 deraadt Exp $	*/
d353 3
d549 1
d552 5
a556 2
		if (d->dv_parent == dev)
			panic("config_detach: detached device has children");
d558 3
@


1.62
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.61 2010/06/30 22:05:44 deraadt Exp $	*/
a51 1
/* Extra stuff from Matthias Drochner <drochner@@zelux6.zel.kfa-juelich.de> */
@


1.61
log
@Silence the activation debug reporting.  We are starting to get worried
that there are interactions when we print in the various (saved, post-saved,
pre-restored, and restored) vga states, especially with how intel drm is
getting involved.  If your machine has issues, you may want to activate
these messages again to help debug things better.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.60 2010/02/28 17:31:27 miod Exp $	*/
a780 3
		case DVACT_DEACTIVATE:
			rv = config_deactivate(d);
			break;
d783 1
d785 3
@


1.60
log
@Remove leftover debug printf in config_activate_children(); ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.59 2009/11/23 14:12:10 deraadt Exp $	*/
d754 1
d756 1
@


1.59
log
@Make config_activate_children() more useable as a suspend-and-resume
device tree walker, and add config_suspend() as well.
ok mlarkin pirofti, discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.58 2009/11/22 18:40:13 pirofti Exp $	*/
a774 2
		if (d->dv_cfdata->cf_attach->ca_activate)
			printf("device %s act %d\n", d->dv_xname, act);
@


1.58
log
@Add basic suspend/resume autoconf functionality.

Okay deraadt@@, kettenis@@, mlarkin@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.57 2009/10/13 19:33:19 pirofti Exp $	*/
a643 36
int
config_suspend(struct device *dev)
{
	struct cfattach *ca = dev->dv_cfdata->cf_attach;
	int rv = 0, oflags = dev->dv_flags;

	if (ca->ca_activate == NULL)
		return (EOPNOTSUPP);

	if ((dev->dv_flags & DVF_SUSPEND) == 0) {
		dev->dv_flags |= DVF_SUSPEND;
		rv = (*ca->ca_activate)(dev, DVACT_SUSPEND);
		if (rv)
			dev->dv_flags = oflags;
	}
	return (rv);
}

int
config_resume(struct device *dev)
{
	struct cfattach *ca = dev->dv_cfdata->cf_attach;
	int rv = 0, oflags = dev->dv_flags;

	if (ca->ca_activate == NULL)
		return (EOPNOTSUPP);

	if (dev->dv_flags & DVF_SUSPEND) {
		dev->dv_flags &= ~DVF_SUSPEND;
		rv = (*ca->ca_activate)(dev, DVACT_RESUME);
		if (rv)
			dev->dv_flags = oflags;
	}
	return (rv);
}

d749 17
d768 23
a790 2
	struct device *dev, *next_dev;
	int  rv = 0;
d792 5
a796 24
	/* The config_deactivate routine may sleep, meaning devices
	   may be added to the queue. However, all devices will
	   be added to the tail of the queue, the queue won't
	   be re-organized, and the subtree of parent here should be locked
	   for purposes of adding/removing children.
	*/
	for (dev = TAILQ_FIRST(&alldevs);
	     dev != NULL; dev = next_dev) {
		next_dev = TAILQ_NEXT(dev, dv_list);
		if (dev->dv_parent == parent) {
			switch (act) {
			case DVACT_ACTIVATE:
				rv = config_activate(dev);
				break;
			case DVACT_DEACTIVATE:
				rv = config_deactivate(dev);
				break;
			case DVACT_SUSPEND:
				rv = config_suspend(dev);
				break;
			case DVACT_RESUME:
				rv = config_resume(dev);
				break;
			default:
d798 2
a799 1
				printf ("config_activate_children: shouldn't get here");
d801 4
a804 2
				rv = EOPNOTSUPP;
				break;
d806 7
a812 4
			}
						
			if (rv)
				break;
d814 1
d816 1
a816 2

	return  (rv);
@


1.57
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.56 2008/08/20 04:37:15 miod Exp $	*/
d644 36
d806 6
@


1.56
log
@Allow devices attaching at root (such as softraid) to be disabled in UKC.
ok marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.55 2007/11/23 18:21:43 kettenis Exp $	*/
d749 1
a749 1
config_activate_children(struct device *parent, enum devact act)
@


1.55
log
@Since the devices that we detach may have children we cannot rely on the
"previous" device still being there, so if we detach a device, we really
have to start from scratch again (like the comment on this code actually
says we should).  Simplifies the code as a bonus.

ok dlg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.54 2007/10/29 01:05:13 dlg Exp $	*/
d280 2
a281 2
	 * with found-state here since only one root should ever be
	 * searched (and it must be done first).
d285 3
@


1.54
log
@get rid of the unused cond_predicate_t typedef.

ok miod@@ deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.53 2007/09/07 15:00:20 art Exp $	*/
d716 1
a716 1
	struct device *dev, *next_dev, *prev_dev;
d731 1
a731 1
	for (prev_dev = NULL, dev = TAILQ_LAST(&alldevs, devicelist);
d736 1
a736 2
			next_dev = prev_dev ? prev_dev : TAILQ_LAST(&alldevs,
			    devicelist);
a737 1
			prev_dev = dev;
@


1.53
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.52 2007/05/30 05:36:36 deraadt Exp $	*/
a60 2

typedef int (*cond_predicate_t)(struct device *, void *);
@


1.52
log
@the (root) stuff is ugly, so print "at root", so it looks more like
regular things.  everyone here buys it, and i'm 90% sure miod will be
ok with it
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.51 2007/05/15 01:56:47 deraadt Exp $	*/
d414 1
a414 1
	dev = (struct device *)malloc(ca->ca_devsize, M_DEVBUF, M_NOWAIT);
d417 1
a417 1
	bzero(dev, ca->ca_devsize);
d454 1
a454 1
		nsp = malloc(new * sizeof(void *), M_DEVBUF, M_NOWAIT);	
a457 1
		bzero(nsp + old, (new - old) * sizeof(void *));
@


1.51
log
@kill __HAVE_DEVICE_REGISTER by requiring all architectures to have a
device_register() function -- even if it does nothing.  reduces the
cpp-based blather different between architectures
idea ok'd by miod; tested on all architectures (except a few miod will
need to cleanup because he has them)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.50 2007/05/09 14:51:54 deraadt Exp $	*/
d369 1
a369 1
		printf("%s (root)", dev->dv_xname);
@


1.50
log
@evcnt_attach() is no longer used; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.49 2006/05/28 16:43:50 mk Exp $	*/
a390 1
#ifdef __HAVE_DEVICE_REGISTER
a391 1
#endif
@


1.49
log
@Remove device id from hotplug events.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.48 2006/05/28 07:12:11 deraadt Exp $	*/
a102 1
struct evcntlist allevents;		/* list of all event counters */
a115 1
	TAILQ_INIT(&allevents);
a847 20
}

/*
 * Attach an event.  These must come from initially-zero space (see
 * commented-out assignments below), but that occurs naturally for
 * device instance variables.
 */
void
evcnt_attach(struct device *dev, const char *name, struct evcnt *ev)
{

#ifdef DIAGNOSTIC
	if (strlen(name) >= sizeof(ev->ev_name))
		panic("evcnt_attach");
#endif
	/* ev->ev_next = NULL; */
	ev->ev_dev = dev;
	/* ev->ev_count = 0; */
	strlcpy(ev->ev_name, name, sizeof ev->ev_name);
	TAILQ_INSERT_TAIL(&allevents, ev, ev_list);
@


1.48
log
@more fallout from the sensors:  Every single ramdisk got broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.47 2006/05/28 01:33:50 mk Exp $	*/
d400 1
a400 1
		hotplug_device_attach(cd->cd_class, dev->dv_xname, dev->dv_unit);
d492 1
a492 1
	int rv = 0, i, devnum = dev->dv_unit;
d566 1
a566 1
			    cf->cf_unit == devnum)
d569 1
a569 1
			    cf->cf_unit == devnum + 1)
d583 1
a583 1
	cd->cd_devs[devnum] = NULL;
d603 1
a603 1
		hotplug_device_detach(cd->cd_class, devname, devnum);
@


1.47
log
@Include device id in hotplug events.  This will be used by ntpd to check
sensors on attach/detach.  hotplugd changes following in a minute.

ok henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.46 2006/05/17 23:56:03 krw Exp $	*/
d492 1
a495 1
	int rv = 0, i;
d498 1
a498 1
	int devnum = dev->dv_unit;
d500 1
@


1.46
log
@cf_unit should have a value between 0 and cd_ndevs. So set cf_unit to 0 when
cd_ndevs is set to 0.

"No kidding!" deraadt@@ "Seems to make sense to me." beck@@ "Seems right." miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.45 2006/05/17 03:43:03 krw Exp $	*/
d400 1
a400 1
		hotplug_device_attach(cd->cd_class, dev->dv_xname);
d498 1
d565 1
a565 1
			    cf->cf_unit == dev->dv_unit)
d568 1
a568 1
			    cf->cf_unit == dev->dv_unit + 1)
d582 1
a582 1
	cd->cd_devs[dev->dv_unit] = NULL;
d602 1
a602 1
		hotplug_device_detach(cd->cd_class, devname);
@


1.45
log
@Detach children devices in reverse order. This gives better display, and
allows cf_unit to be decremented correctly.

'put it in' deraadt@@ "i think it's good' tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.44 2006/05/14 14:07:20 krw Exp $	*/
d596 1
@


1.44
log
@When assigning a unit number, treat running off the end of the
cd_devs[] array the same as finding a NULL entry.

Fixes inconsistant assignment of unit numbers to media slots on the
Neodio 8-in-1 USB card reader donated by Manuel Pata. Previously the
unit numbers would vary depending on whether it had attached an even
or odd number of times.

'reads ok' marco@@ ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.43 2006/01/21 12:20:53 miod Exp $	*/
d735 1
a735 1
	for (prev_dev = NULL, dev = TAILQ_FIRST(&alldevs);
d740 6
a745 3
			next_dev = prev_dev ? prev_dev : TAILQ_FIRST(&alldevs);
		} else
			next_dev = TAILQ_NEXT(prev_dev = dev, dv_list);
@


1.43
log
@Remove now unused zeroref member in cfattach structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.42 2006/01/13 19:22:54 miod Exp $	*/
d431 1
@


1.42
log
@In config_detach_children(), after detaching a device, restart the device
list walk from its parent device, as the device which was following it may
have been one of its children, and thus gone as well. Found the hard way
using the strict queue macros.

Feedback and help toby@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.41 2005/12/09 09:09:52 jsg Exp $	*/
d832 1
a832 2
 * free's the structure when the ref count hits zero and calls the zeroref
 * function.
a840 3
		if (dv->dv_cfdata->cf_attach->ca_zeroref)
			(*dv->dv_cfdata->cf_attach->ca_zeroref)(dv);
		
@


1.41
log
@ansi and deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.40 2004/12/26 21:22:13 miod Exp $	*/
d719 2
a720 2
	struct device *dev, *next_dev;
	int  rv = 0;
d722 20
a741 12
	/* The config_detach routine may sleep, meaning devices
	   may be added to the queue. However, all devices will
	   be added to the tail of the queue, the queue won't
	   be re-organized, and the subtree of parent here should be locked
	   for purposes of adding/removing children.
	*/
	for (dev  = TAILQ_FIRST(&alldevs);
	     dev != NULL; dev = next_dev) {
		next_dev = TAILQ_NEXT(dev, dv_list);
		if (dev->dv_parent == parent &&
		    (rv = config_detach(dev, flags)))
			return (rv);
d744 1
a744 1
	return  (rv);
@


1.40
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.39 2004/11/23 19:08:55 miod Exp $	*/
d113 1
a113 1
config_init()
d127 1
a127 3
mapply(m, cf)
	register struct matchinfo *m;
	register struct cfdata *cf;
d129 1
a129 1
	register int pri;
d180 1
a180 4
config_search(fn, parent, aux)
	cfmatch_t fn;
	register struct device *parent;
	void *aux;
d182 2
a183 2
	register struct cfdata *cf;
	register short *p;
d233 1
a233 3
config_scan(fn, parent)
	cfscan_t fn;
	register struct device *parent;
d235 2
a236 2
	register struct cfdata *cf;
	register short *p;
d270 1
a270 4
config_rootsearch(fn, rootname, aux)
	register cfmatch_t fn;
	register char *rootname;
	register void *aux;
d272 2
a273 2
	register struct cfdata *cf;
	register short *p;
d306 2
a307 5
config_found_sm(parent, aux, print, submatch)
	struct device *parent;
	void *aux;
	cfprint_t print;
	cfmatch_t submatch;
d322 1
a322 3
config_rootfound(rootname, aux)
	char *rootname;
	void *aux;
d336 1
a336 5
config_attach(parent, match, aux, print)
	register struct device *parent;
	void *match;
	register void *aux;
	cfprint_t print;
d338 4
a341 4
	register struct cfdata *cf;
	register struct device *dev;
	register struct cfdriver *cd;
	register struct cfattach *ca;
d406 1
a406 3
config_make_softc(parent, cf)
	struct device *parent;
	struct cfdata *cf;
d408 3
a410 3
	register struct device *dev;
	register struct cfdriver *cd;
	register struct cfattach *ca;
d486 1
a486 3
config_detach(dev, flags)
	struct device *dev;
	int flags;
d609 1
a609 2
config_activate(dev)
	struct device *dev;
d627 1
a627 2
config_deactivate(dev)
	struct device *dev;
d649 1
a649 3
config_defer(dev, func)
	struct device *dev;
	void (*func)(struct device *);
d677 1
a677 2
config_process_deferred_children(parent)
	struct device *parent;
d717 1
a717 3
config_detach_children(parent, flags)
	struct device *parent;
	int flags;
d740 1
a740 3
config_activate_children(parent, act)
	struct device *parent;
	enum devact act;
d789 1
a789 3
device_lookup(cd, unit)
	struct cfdriver *cd;
	int unit;
d816 1
a816 2
device_ref(dv)
	struct device *dv;
d830 1
a830 2
device_unref(dv)
	struct device *dv;
d847 1
a847 4
evcnt_attach(dev, name, ev)
	struct device *dev;
	const char *name;
	struct evcnt *ev;
@


1.39
log
@Create the init process earlier, before the root filesystem is mounted,
and have it stall on a semaphore. This allows all kthread creations which
could have been requested during autoconf to be processed before root
is mounted as well.

This causes umass devices attached to any usb with flags 1 (such as on macppc)
to configure properly instead of panicing the kernel at mountroot time.

From NetBSD; tested by various.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.38 2004/08/03 17:49:04 pefo Exp $	*/
d198 1
a198 1
	for(t = allcftables.tqh_first; t; t = t->list.tqe_next) {
d249 1
a249 1
	for (t = allcftables.tqh_first; t; t = t->list.tqe_next) {
d402 1
a402 1
	for (t = allcftables.tqh_first; t; t = t->list.tqe_next) {
@


1.38
log
@Fix a minor bug where indirect config crashes the kernel
when match verbose is turend on.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.37 2004/05/30 08:11:26 grange Exp $	*/
d54 1
d105 2
d697 1
d716 1
d719 23
@


1.37
log
@Devices hot plugging support.
The hotplug pseudo-device passes device attachment and detachment events
to userland.  When a device attaches or detaches, the corresponding event
is queued.  The events can then be obtained from the queue through the
read(2) call on the /dev/hotplug device file. Each event consists of
event type (attach/detach), device class (DV_*) and device name (sd1 e.g.).

We have hotplug pseudo-device on alpha, amd64, i386, macppc and sparc64.
Since it was tested only on i386 other archs has it commented out
in GENERIC until tested.

The idea liked peter@@ tedu@@ drahn@@ millert@@ marco@@ henning@@.
Ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.36 2003/06/02 23:28:06 millert Exp $	*/
d213 5
a217 1
		if (m.match)
d219 2
a220 2
			    ((struct cfdata *)m.match)->cf_driver->cd_name);
		else
@


1.36
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.35 2003/05/03 21:14:59 deraadt Exp $	*/
d48 1
d55 2
d410 4
d511 5
d612 5
@


1.35
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.34 2003/04/19 19:08:53 krw Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.34
log
@Tweak previous sprintf -> snprintf fix to eliminate unnecessary
intermediate variable.

Suggested by deraadt@@.

ok henning@@ millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.33 2003/03/30 20:52:43 krw Exp $	*/
d851 1
a851 1
	strcpy(ev->ev_name, name);
@


1.33
log
@Use snprintf() to simplify device name construction, removing now
superfluous variables and the function 'number()'.

ok deraadt@@ and millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.32 2002/10/06 23:12:31 art Exp $	*/
a421 1
	register size_t lname;
d447 3
a449 5
	/* compute length of name and decimal expansion of unit number */

	lname = snprintf(dev->dv_xname, sizeof(dev->dv_xname), "%s%d",
		    cd->cd_name, dev->dv_unit);
	if (lname >= sizeof(dev->dv_xname))
@


1.32
log
@Remove some '#if 0' cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.31 2002/04/24 21:53:12 espie Exp $	*/
a89 1
static char *number(char *, int);
a340 16
/* just like sprintf(buf, "%d") except that it works from the end */
char *
number(ep, n)
	register char *ep;
	register int n;
{

	*--ep = 0;
	while (n >= 10) {
		*--ep = (n % 10) + '0';
		n /= 10;
	}
	*--ep = n + '0';
	return (ep);
}

d422 1
a422 3
	register size_t lname, lunit;
	register char *xunit;
	char num[10];
d449 4
a452 4
	lname = strlen(cd->cd_name);
	xunit = number(&num[sizeof num], dev->dv_unit);
	lunit = &num[sizeof num] - xunit;
	if (lname + lunit >= sizeof(dev->dv_xname))
a453 3

	bcopy(cd->cd_name, dev->dv_xname, lname);
	bcopy(xunit, dev->dv_xname + lname, lunit);
@


1.31
log
@Introduce a new file, machine/internal_types.h, to hold that specific arch
type characteristics.

internal_types.h will contain only settings invisible from standard C, e.g.,
in the __* or _[A-Z]* namespace, and be reused by files like limits.h.

This allows us to shorten machine/limits.h greatly, as all the common defines
are now in sys/limits.h, plus a small stub in internal_types.h.

Tested on all arches as far as I know.
Approved after discussion with art, millert, deraadt, and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.30 2002/03/14 01:27:04 millert Exp $	*/
a878 59

#if 0
int
attach_loadable(parentname, parentunit, cftable)
	char *parentname;
	int parentunit;
	struct cftable *cftable;
{
	int found = 0;
	struct device *d;

	TAILQ_INSERT_TAIL(&allcftables, cftable, list);

	for(d = alldevs.tqh_first; d != NULL; d = d->dv_list.tqe_next) {
		struct cfdriver *drv = d->dv_cfdata->cf_driver;

		if (strcmp(parentname, drv->cd_name) == NULL &&
		    (parentunit == -1 || parentunit == d->dv_unit)) {
			int s;

			s = splhigh(); /* ??? */
			found |= (*d->dv_cfdata->cf_attach->ca_reprobe)(d,
			    &(cftable->tab[0]));
			splx(s);
		}
	}
	if (!found)
		TAILQ_REMOVE(&allcftables, cftable, list);
	return(found);
}

int
devcf_intable(struct device *, void *);

int
devcf_intable(dev, arg)
	struct device *dev;
	void *arg;
{
	struct cftable *tbl = arg;
	struct cfdata *cf;

	for(cf = tbl->tab; cf->cf_driver; cf++) {
		if (dev->dv_cfdata == cf)
			return(1);
	}
	return(0);
}

int
detach_loadable(cftable)
	struct cftable *cftable;
{
	if (!detach_devices(devcf_intable, cftable, 0, 0))
		return(0);
	TAILQ_REMOVE(&allcftables, cftable, list);
	return(1);
}
#endif
@


1.30
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.29 2001/09/01 05:48:18 jason Exp $	*/
d52 1
a54 1
#include <machine/limits.h>
@


1.29
log
@Add __HAVE_DEVICE_REGISTER to hp300/alpha (sparc64 already had it) and
clean up the arch specific #ifdef's in subr_autoconf.c; from NetBSD.
(tested by me on alpha/sparc64 and miod on hp300)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.28 2001/08/31 15:12:05 jason Exp $	*/
d62 1
a62 1
typedef int (*cond_predicate_t) __P((struct device *, void *));
d90 2
a91 2
static char *number __P((char *, int));
static void mapply __P((struct matchinfo *, struct cfdata *));
d96 1
a96 1
	void (*dc_func) __P((struct device *));
d101 1
a101 1
void config_process_deferred_children __P((struct device *));
d681 1
a681 1
	void (*func) __P((struct device *));
d911 1
a911 1
devcf_intable __P((struct device *, void *));
@


1.29.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.29 2001/09/01 05:48:18 jason Exp $	*/
a51 1
#include <sys/limits.h>
d54 1
d62 1
a62 1
typedef int (*cond_predicate_t)(struct device *, void *);
d90 2
a91 2
static char *number(char *, int);
static void mapply(struct matchinfo *, struct cfdata *);
d96 1
a96 1
	void (*dc_func)(struct device *);
d101 1
a101 1
void config_process_deferred_children(struct device *);
d681 1
a681 1
	void (*func)(struct device *);
d911 1
a911 1
devcf_intable(struct device *, void *);
@


1.29.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.29.4.1 2002/06/11 03:29:40 art Exp $	*/
d879 59
@


1.29.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
d342 16
d439 3
d467 5
a471 3
	/* Build the device name into dv_xname. */
	if (snprintf(dev->dv_xname, sizeof(dev->dv_xname), "%s%d",
	    cd->cd_name, dev->dv_unit) >= sizeof(dev->dv_xname))
d473 3
d876 1
a876 1
	strlcpy(ev->ev_name, name, sizeof ev->ev_name);
@


1.28
log
@implement autoconf mechanism using device_register(); from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.27 2000/04/09 22:46:03 deraadt Exp $	*/
a57 5
/* Bleh!  Need device_register proto */
#if defined(__alpha__) || defined(hp300) || defined(__sparc64__)
#include <machine/autoconf.h>
#endif /* __alpha__ || hp300 || __sparc64__ */

d423 1
a423 1
#if defined(__alpha__) || defined(hp300) || defined(__sparc64__)
@


1.27
log
@range error; < cd_ndevs, not <=
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.26 2000/04/09 19:23:18 csapuntz Exp $	*/
d59 1
a59 1
#if defined(__alpha__) || defined(hp300)
d61 1
a61 1
#endif /* __alpha__ || hp300 */
d428 1
a428 1
#if defined(__alpha__) || defined(hp300)
@


1.26
log
@

Added config_detach_children, config_activate_children.

Added ref counting to devices: device_ref, device_unref and a new method
for devices : ca_zeroref, called when the ref count hits zero.

Note that ca_zeroref may be called from interrupt context.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.25 1999/08/08 00:37:09 niklas Exp $	*/
d812 1
a812 1
	if (unit >= 0 && unit <= cd->cd_ndevs)
@


1.25
log
@From NetBSD; new device detaching infrastructure.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.24 1999/08/05 17:41:44 niklas Exp $	*/
d403 1
d512 2
d613 1
a620 1
	free(dev, M_DEVBUF);
d622 1
d726 133
@


1.25.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.27 2000/04/09 22:46:03 deraadt Exp $	*/
a402 1
	device_ref(dev);
a510 2
	dev->dv_ref = 1;

a609 1
	device_unref(dev);
d617 1
a618 1
	device_unref(dev);
a721 133
	}
}

int
config_detach_children(parent, flags)
	struct device *parent;
	int flags;
{
	struct device *dev, *next_dev;
	int  rv = 0;

	/* The config_detach routine may sleep, meaning devices
	   may be added to the queue. However, all devices will
	   be added to the tail of the queue, the queue won't
	   be re-organized, and the subtree of parent here should be locked
	   for purposes of adding/removing children.
	*/
	for (dev  = TAILQ_FIRST(&alldevs);
	     dev != NULL; dev = next_dev) {
		next_dev = TAILQ_NEXT(dev, dv_list);
		if (dev->dv_parent == parent &&
		    (rv = config_detach(dev, flags)))
			return (rv);
	}

	return  (rv);
}

int
config_activate_children(parent, act)
	struct device *parent;
	enum devact act;
{
	struct device *dev, *next_dev;
	int  rv = 0;

	/* The config_deactivate routine may sleep, meaning devices
	   may be added to the queue. However, all devices will
	   be added to the tail of the queue, the queue won't
	   be re-organized, and the subtree of parent here should be locked
	   for purposes of adding/removing children.
	*/
	for (dev = TAILQ_FIRST(&alldevs);
	     dev != NULL; dev = next_dev) {
		next_dev = TAILQ_NEXT(dev, dv_list);
		if (dev->dv_parent == parent) {
			switch (act) {
			case DVACT_ACTIVATE:
				rv = config_activate(dev);
				break;
			case DVACT_DEACTIVATE:
				rv = config_deactivate(dev);
				break;
			default:
#ifdef DIAGNOSTIC
				printf ("config_activate_children: shouldn't get here");
#endif
				rv = EOPNOTSUPP;
				break;

			}
						
			if (rv)
				break;
		}
	}

	return  (rv);
}

/* 
 * Lookup a device in the cfdriver device array.  Does not return a
 * device if it is not active.
 *
 * Increments ref count on the device by one, reflecting the
 * new reference created on the stack.
 *
 * Context: process only 
 */
struct device *
device_lookup(cd, unit)
	struct cfdriver *cd;
	int unit;
{
	struct device *dv = NULL;

	if (unit >= 0 && unit < cd->cd_ndevs)
		dv = (struct device *)(cd->cd_devs[unit]);
	
	if (!dv)
		return (NULL);

	if (!(dv->dv_flags & DVF_ACTIVE))
		dv = NULL;

	if (dv != NULL)
		device_ref(dv);

	return (dv);
}


/*
 * Increments the ref count on the device structure. The device
 * structure is freed when the ref count hits 0.
 *
 * Context: process or interrupt
 */
void
device_ref(dv)
	struct device *dv;
{
	dv->dv_ref++;
}

/*
 * Decrement the ref count on the device structure.
 *
 * free's the structure when the ref count hits zero and calls the zeroref
 * function.
 *
 * Context: process or interrupt
 */
void
device_unref(dv)
	struct device *dv;
{
	dv->dv_ref--;
	if (dv->dv_ref == 0) {
		if (dv->dv_cfdata->cf_attach->ca_zeroref)
			(*dv->dv_cfdata->cf_attach->ca_zeroref)(dv);
		
		free(dv, M_DEVBUF);
@


1.25.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.25.4.1 2001/05/14 22:32:42 niklas Exp $	*/
d58 5
d428 1
a428 1
#ifdef __HAVE_DEVICE_REGISTER
@


1.25.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
a62 1
typedef int (*cond_predicate_t)(struct device *, void *);
d90 2
a91 2
static char *number(char *, int);
static void mapply(struct matchinfo *, struct cfdata *);
d96 1
a96 1
	void (*dc_func)(struct device *);
d101 1
a101 1
void config_process_deferred_children(struct device *);
d681 1
a681 1
	void (*func)(struct device *);
d911 1
a911 1
devcf_intable(struct device *, void *);
@


1.25.4.4
log
@Sync the SMP branch with 3.3
@
text
@a51 1
#include <sys/limits.h>
d54 1
d879 59
@


1.25.4.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.25.4.4 2003/03/28 00:41:26 niklas Exp $	*/
d90 1
d342 16
d439 3
d467 5
a471 3
	/* Build the device name into dv_xname. */
	if (snprintf(dev->dv_xname, sizeof(dev->dv_xname), "%s%d",
	    cd->cd_name, dev->dv_unit) >= sizeof(dev->dv_xname))
d473 3
d876 1
a876 1
	strlcpy(ev->ev_name, name, sizeof ev->ev_name);
@


1.25.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.25.4.5 2003/05/13 19:21:28 ho Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.25.4.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a47 1
#include <sys/hotplug.h>
a53 2
#include "hotplug.h"

a406 4
#if NHOTPLUG > 0
	if (!cold)
		hotplug_device_attach(cd->cd_class, dev->dv_xname);
#endif
a503 5
#if NHOTPLUG > 0
	char devname[16];

	strlcpy(devname, dev->dv_xname, sizeof(devname));
#endif
a599 5

#if NHOTPLUG > 0
	if (!cold)
		hotplug_device_detach(cd->cd_class, devname);
#endif
@


1.24
log
@From NetBSD; config_defer to defer configuration of a device until after all
other siblings.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.23 1999/07/23 19:45:21 niklas Exp $	*/
d459 1
d512 161
@


1.23
log
@Remove obsolete detach logic in preparation of a newer one
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.22 1999/01/11 05:12:23 millert Exp $	*/
d98 10
d119 1
a119 1

d130 1
a130 1
static void
d348 1
a348 1
static char *
d431 1
d511 50
@


1.22
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.21 1998/05/11 09:59:39 niklas Exp $	*/
a96 6
static int haschild __P((struct device *));
int	detach_devices __P((cond_predicate_t, void *,
	    config_detach_callback_t, void *));
int	dev_matches_cfdata __P((struct device *dev, void *));
int	parentdev_matches_cfdata __P((struct device *dev, void *));

d525 1
a525 131
static int
haschild(dev)
	struct device *dev;
{
	struct device *d;

	for (d = alldevs.tqh_first; d != NULL; d = d->dv_list.tqe_next) {
		if (d->dv_parent == dev)
			return(1);
	}
	return(0);
}

int
detach_devices(cond, condarg, callback, arg)
	cond_predicate_t cond;
	void *condarg;
	config_detach_callback_t callback;
	void *arg;
{
	struct device *d;
	int alldone = 1;

	/*
	 * XXX should use circleq and run around the list backwards
	 * to allow for predicates to match children.
	 */
	d = alldevs.tqh_first;
	while (d != NULL) {
		if ((*cond)(d, condarg)) {
			struct cfdriver *drv = d->dv_cfdata->cf_driver;

			/* device not busy? */
			/* driver's detach routine decides, upper
			   layer (eg bus dependent code) is notified
			   via callback */
#ifdef DEBUG
			printf("trying to detach device %s (%p)\n",
			       d->dv_xname, d);
#endif
			if (!haschild(d) &&
			    d->dv_cfdata->cf_attach->ca_detach &&
			    ((*(d->dv_cfdata->cf_attach->ca_detach))(d)) == 0) {
				int needit, i;
				struct device *help;

				if (callback)
					(*callback)(d, arg);

				/* remove reference in driver's devicelist */
				if ((d->dv_unit >= drv->cd_ndevs) ||
				    (drv->cd_devs[d->dv_unit]!=d))
					panic("bad unit in detach_devices");
				drv->cd_devs[d->dv_unit] = NULL;

				/* driver is not needed anymore? */
				needit = 0;
				for(i = 0; i<drv->cd_ndevs; i++)
					if (drv->cd_devs[i])
						needit = 1;

				if (!needit) {
					/* free devices array (alloc'd
                                           in config_make_softc) */
					free(drv->cd_devs, M_DEVBUF);
					drv->cd_ndevs = 0;
				}

				/* remove entry in global device list */
				help = d->dv_list.tqe_next;
				TAILQ_REMOVE(&alldevs, d, dv_list);
#ifdef DEBUG
				printf("%s removed\n", d->dv_xname);
#endif
				if (d->dv_cfdata->cf_fstate == FSTATE_FOUND)
					d->dv_cfdata->cf_fstate =
					    FSTATE_NOTFOUND;
				/* free memory for dev data (alloc'd
                                   in config_make_softc) */
				free(d, M_DEVBUF);
				d = help;
				continue;
			} else
				alldone = 0;
		}
		d = d->dv_list.tqe_next;
	}
	return (!alldone);
}

int
dev_matches_cfdata(dev, arg)
	struct device *dev;
	void *arg;
{
	struct cfdata *cfdata = arg;
	return(/* device uses same driver ? */
		(dev->dv_cfdata->cf_driver == cfdata->cf_driver)
		/* device instance described by this cfdata? */
		&& ((cfdata->cf_fstate == FSTATE_STAR)
		    || ((cfdata->cf_fstate == FSTATE_FOUND)
		        && (dev->dv_unit == cfdata->cf_unit)))
		);
}

int
parentdev_matches_cfdata(dev, arg)
	struct device *dev;
	void *arg;
{
	return (dev->dv_parent ? dev_matches_cfdata(dev->dv_parent, arg) : 0);
}

int
config_detach(cf, callback, arg)
	struct cfdata *cf;
	config_detach_callback_t callback;
	void *arg;
{
	return (detach_devices(dev_matches_cfdata, cf, callback, arg));
}

int
config_detach_children(cf, callback, arg)
	struct cfdata *cf;
	config_detach_callback_t callback;
	void *arg;
{
	return (detach_devices(parentdev_matches_cfdata, cf, callback, arg));
}

d555 1
a555 1
static int
d558 1
a558 1
static int
d582 1
@


1.21
log
@Formerly reuse of unit numbers of detached devices was impossible, with
this change starred devices will search from the first allowed unit for
such devices and up for free units when attaching.  This means you have
to rerun config(8) before yopu compile current kernels.  FYI, this is
a necessity when doing PCMCIA flashcard reading, otherwise you soon run
out of unit numbers.

I have also added a way to detach all children of a certain device, used
in a new PCMCIA framework to come, so you detach all functions on a
single PCMCIA card when pulling it out.

A few bugs wrt starred devices fixed in the autoconfig_verbose code too.
Last and least, fixed some panic messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.20 1998/02/20 14:51:57 niklas Exp $	*/
d150 1
a150 1
			panic("mapply: no match function for '%s' device\n",
@


1.20
log
@Please GCC 2.8's harsher view of good style
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.19 1998/01/21 12:23:45 niklas Exp $	*/
d67 2
d97 6
d139 7
a145 3
	if (autoconf_verbose)
		printf(">>> probing for %s%d\n", cf->cf_driver->cd_name,
		    cf->cf_unit);
d156 2
a157 2
		printf(">>> probe for %s%d returned %d\n",
		    cf->cf_driver->cd_name, cf->cf_unit, pri);
d217 2
a218 3
			printf(">>> probe for %s%d won\n",
			    ((struct cfdata *)m.match)->cf_driver->cd_name,
			    ((struct cfdata *)m.match)->cf_unit);
a384 1
	cd->cd_devs[cf->cf_unit] = dev;
d386 10
a395 3
	if (cf->cf_fstate == FSTATE_STAR)
		cf->cf_unit++;
	else
a446 7
	/* compute length of name and decimal expansion of unit number */
	lname = strlen(cd->cd_name);
	xunit = number(&num[sizeof num], cf->cf_unit);
	lunit = &num[sizeof num] - xunit;
	if (lname + lunit >= sizeof(dev->dv_xname))
		panic("config_attach: device name too long");

d450 1
a450 1
	    panic("config_attach: memory allocation for device softc failed");
d454 18
a471 1
	dev->dv_unit = cf->cf_unit;
d493 1
a493 1
			panic("config_attach: %sing dev array",
d503 1
a503 1
		panic("config_attach: duplicate %s", dev->dv_xname);
a530 6
typedef int (*cond_predicate_t) __P((struct device*, void*));

static int haschild __P((struct device *));
static int detach_devices __P((cond_predicate_t, void *,
			       config_detach_callback_t, void *));

d544 1
a544 1
static int
d605 3
a607 1
				d->dv_cfdata->cf_fstate = FSTATE_NOTFOUND;
d618 1
a618 1
	return(!alldone);
a620 2
int dev_matches_cfdata __P((struct device *dev, void *));

d637 8
d650 10
a659 1
	return(detach_devices(dev_matches_cfdata, cf, callback, arg));
@


1.19
log
@Prevent a NULL-deref in the autoconf_verbose case
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.18 1998/01/20 20:12:11 niklas Exp $	*/
d203 1
a203 1
	if (autoconf_verbose)
d210 1
@


1.18
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.17 1998/01/20 19:05:02 niklas Exp $	*/
d204 6
a209 3
		printf(">>> probe for %s%d won\n",
		    ((struct cfdata *)m.match)->cf_driver->cd_name,
		    ((struct cfdata *)m.match)->cf_unit);
@


1.17
log
@Provide a way to debug probes.  set autoconf_verbose via DDB, or
option AUTOCONF_VERBOSE=1
in your kernel config.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.16 1997/11/23 08:22:47 mickey Exp $	*/
d205 2
a206 2
		    ((struct cfdata *)match)->cf_driver->cd_name,
		    ((struct cfdata *)match)->cf_unit);
d305 1
a305 1
	if ((match = config_search(submatch, parent, aux)) != NULL) {
@


1.16
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.15 1997/02/03 03:04:22 downsj Exp $	*/
d88 5
d131 3
d143 3
d203 4
d305 1
a305 1
	if ((match = config_search(submatch, parent, aux)) != NULL)
@


1.15
log
@hp300 needs device_register(), too.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.14 1996/11/21 12:47:15 mickey Exp $	*/
d175 16
a190 15
	for(t = allcftables.tqh_first; t; t = t->list.tqe_next){
	  for (cf = t->tab; cf->cf_driver; cf++) {
	    /*
	     * Skip cf if no longer eligible, otherwise scan through
	     * parents for one matching `parent', and try match function.
	     */
	    if (cf->cf_fstate == FSTATE_FOUND)
	      continue;
	    if (cf->cf_fstate == FSTATE_DNOTFOUND ||
		cf->cf_fstate == FSTATE_DSTAR)
	      continue;
	    for (p = cf->cf_parents; *p >= 0; p++)
	      if (parent->dv_cfdata == &(t->tab)[*p])
		mapply(&m, cf);
	  }
d216 19
a234 19
	  for (cf = t->tab; cf->cf_driver; cf++) {
	    /*
	     * Skip cf if no longer eligible, otherwise scan through
	     * parents for one matching `parent', and try match function.
	     */
	    if (cf->cf_fstate == FSTATE_FOUND)
	      continue;
	    if (cf->cf_fstate == FSTATE_DNOTFOUND ||
		cf->cf_fstate == FSTATE_DSTAR)
	      continue;
	    for (p = cf->cf_parents; *p >= 0; p++)
	      if (parent->dv_cfdata == &(t->tab)[*p]) {
		if (indirect)
		  match = config_make_softc(parent, cf);
		else
		  match = cf;
		(*fn)(parent, match);
	      }
	  }
d378 8
a385 7
	  for (cf = t->tab; cf->cf_driver; cf++)
	    if (cf->cf_driver == cd && cf->cf_unit == dev->dv_unit) {
			if (cf->cf_fstate == FSTATE_NOTFOUND)
				cf->cf_fstate = FSTATE_FOUND;
			if (cf->cf_fstate == FSTATE_STAR)
				cf->cf_unit++;
	    }
d497 1
a497 3
	for (d = alldevs.tqh_first;
	     d != NULL;
	     d = d->dv_list.tqe_next) {
@


1.14
log
@export struct cfdata cfdata[];
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.13 1996/10/18 14:46:35 niklas Exp $	*/
d59 1
a59 1
#ifdef __alpha__
d61 1
a61 1
#endif /* __alpha__ */
d385 1
a385 1
#ifdef __alpha__
@


1.13
log
@As alpha uses device_register, it needs its proto too
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.12 1996/09/24 02:40:11 deraadt Exp $	*/
a70 1
extern struct cfdata cfdata[];
@


1.12
log
@no mknod in chroot
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.11 1996/08/15 12:33:20 niklas Exp $	*/
d55 1
a55 2
/* Extra stuff from Matthias Drochner <drochner@@zelux6.zel.kfa-juelich.de>
 */
d57 5
@


1.11
log
@Remove unnecessary prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.10 1996/07/02 22:21:24 deraadt Exp $	*/
d267 1
a267 1
static char *msgs[3] = { "", " not configured\n", " unsupported\n" };
@


1.10
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.9 1996/07/02 06:51:59 niklas Exp $	*/
a70 2

struct device *config_make_softc __P((struct device *, struct cfdata *));
@


1.9
log
@-Wall & -Wstrict-prototype fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.8 1996/06/23 19:34:30 maja Exp $	*/
d376 1
a376 1
		for (cf = t->tab; cf->cf_driver; cf++)
d615 1
a615 3
	for(d = alldevs.tqh_first;
	    d != NULL;
	    d = d->dv_list.tqe_next) {
d618 2
a619 2
		if ((!strcmp(parentname, drv->cd_name))
		    && ((parentunit == -1) || (parentunit == d->dv_unit))) {
d623 2
a624 1
			found |= (*d->dv_cfdata->cf_attach->ca_reprobe)(d, &(cftable->tab[0]));
a627 1

a629 1

@


1.8
log
@Added support for user modifiable kernel at boot (-c) /maja
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.7 1996/06/18 09:43:44 deraadt Exp $	*/
d182 1
a182 1
	    if (cf->cf_fstate == FSTATE_DNOTFOUND |
d221 1
a221 1
	    if (cf->cf_fstate == FSTATE_DNOTFOUND |
@


1.7
log
@sick netbsd alpha hack (why not do what other ports do?)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.6 1996/05/07 15:23:36 niklas Exp $	*/
d182 3
d220 3
@


1.6
log
@Make sure config_init gets called before consinit, as at least one port
actually uses config_* functions for console attachment.  Document
config_init should not call malloc as the move was over the mem-init
function calls too.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.4 1996/04/21 22:27:13 deraadt Exp $	*/
d378 3
@


1.5
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d94 3
a96 1
 * Initialize autoconfiguration data structures.
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_autoconf.c,v 1.3 1996/04/19 16:09:01 niklas Exp $	*/
d55 3
d81 6
d102 2
d164 1
d172 12
a183 10
	for (cf = cfdata; cf->cf_driver; cf++) {
		/*
		 * Skip cf if no longer eligible, otherwise scan through
		 * parents for one matching `parent', and try match function.
		 */
		if (cf->cf_fstate == FSTATE_FOUND)
			continue;
		for (p = cf->cf_parents; *p >= 0; p++)
			if (parent->dv_cfdata == &cfdata[*p])
				mapply(&m, cf);
d205 1
d208 17
a224 15
	for (cf = cfdata; cf->cf_driver; cf++) {
		/*
		 * Skip cf if no longer eligible, otherwise scan through
		 * parents for one matching `parent', and try match function.
		 */
		if (cf->cf_fstate == FSTATE_FOUND)
			continue;
		for (p = cf->cf_parents; *p >= 0; p++)
			if (parent->dv_cfdata == &cfdata[*p]) {
				if (indirect)
					match = config_make_softc(parent, cf);
				else
					match = cf;
				(*fn)(parent, match);
			}
d333 1
d367 3
a369 2
	for (cf = cfdata; cf->cf_driver; cf++)
		if (cf->cf_driver == cd && cf->cf_unit == dev->dv_unit) {
d374 2
a375 1
		}
d469 182
@


1.3
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: subr_autoconf.c,v 1.2 1996/03/03 17:19:59 niklas Exp $	*/
/*	$NetBSD: subr_autoconf.c,v 1.18 1996/02/27 21:45:46 cgd Exp $	*/
d81 14
d115 1
a115 1
	        if (cf->cf_driver->cd_match == NULL) {
d119 1
a119 1
		pri = (*cf->cf_driver->cd_match)(m->parent, match, m->aux);
d254 1
a254 1
int
d263 2
a264 4
	if ((match = config_search(submatch, parent, aux)) != NULL) {
		config_attach(parent, match, aux, print);
		return (1);
	}
d267 1
a267 1
	return (0);
d273 1
a273 1
int
d280 2
a281 5
	if ((match = config_rootsearch((cfmatch_t)NULL, rootname, aux))
	    != NULL) {
		config_attach(ROOT, match, aux, (cfprint_t)NULL);
		return (1);
	}
d283 1
a283 1
	return (0);
d305 1
a305 1
void
d315 1
a315 1
	static struct device **nextp = &alldevs;
d326 1
d334 1
a334 2
	*nextp = dev;			/* link up */
	nextp = &dev->dv_next;
d346 2
a347 1
	 * otherwise identical.
d350 8
a357 4
		if (cf->cf_driver == cd && cf->cf_unit == dev->dv_unit &&
		    cf->cf_fstate == FSTATE_NOTFOUND)
			cf->cf_fstate = FSTATE_FOUND;
	(*cd->cd_attach)(parent, dev, aux);
d367 1
d373 2
a374 1
	if (cd->cd_devsize < sizeof(struct device))
d385 1
a385 1
	dev = (struct device *)malloc(cd->cd_devsize, M_DEVBUF, M_NOWAIT);
d388 1
a388 1
	bzero(dev, cd->cd_devsize);
a438 1
	static struct evcnt **nextp = &allevents;
d448 1
a448 2
	*nextp = ev;
	nextp = &ev->ev_next;
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: subr_autoconf.c,v 1.17 1996/02/04 02:16:35 christos Exp $	*/
d235 3
a237 2
 * configuration data for that device (using the cd_match configuration
 * driver function) and attach it, and return true.  If the device was
d241 1
a241 1
config_found(parent, aux, print)
d245 1
d249 1
a249 1
	if ((match = config_search((cfmatch_t)NULL, parent, aux)) != NULL) {
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: subr_autoconf.c,v 1.16 1994/11/04 06:40:11 mycroft Exp $	*/
d53 1
a53 1
#include <lib/libkern/libkern.h>
d77 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
