head	1.58;
access;
symbols
	OPENBSD_6_2:1.58.0.2
	OPENBSD_6_2_BASE:1.58
	OPENBSD_6_1:1.58.0.4
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.57.0.4
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.56.0.4
	OPENBSD_5_8_BASE:1.56
	OPENBSD_5_7:1.55.0.2
	OPENBSD_5_7_BASE:1.55
	OPENBSD_5_6:1.51.0.4
	OPENBSD_5_6_BASE:1.51
	OPENBSD_5_5:1.50.0.4
	OPENBSD_5_5_BASE:1.50
	OPENBSD_5_4:1.47.0.4
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.47.0.2
	OPENBSD_5_3_BASE:1.47
	OPENBSD_5_2:1.45.0.8
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.6
	OPENBSD_5_0:1.45.0.4
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.2
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.44.0.2
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.42.0.2
	OPENBSD_4_7_BASE:1.42
	OPENBSD_4_6:1.39.0.4
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.34.0.4
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.33.0.8
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.33.0.6
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.4
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.25.0.8
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.6
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.4
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.23
	UBC:1.18.0.4
	UBC_BASE:1.18
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.7.0.6
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.58
date	2016.09.15.02.00.16;	author dlg;	state Exp;
branches;
next	1.57;
commitid	RlO92XR575sygHqm;

1.57
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	NdgfPIGUgJxQPnT7;

1.56
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.55;
commitid	p4LJxGKbi0BU2cG6;

1.55
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	3SGDR5EjcwE01W8S;

1.54
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.53;
commitid	uzzBR7hz9ncd4O6G;

1.53
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.52;
commitid	jdBY2kKXhfcoQitp;

1.52
date	2014.08.17.09.48.55;	author dlg;	state Exp;
branches;
next	1.51;
commitid	br0kVsuAHTYVtDY3;

1.51
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.50;
commitid	QlVV51SZgNFxsXxC;

1.50
date	2014.01.21.21.45.58;	author kettenis;	state Exp;
branches;
next	1.49;

1.49
date	2014.01.21.01.48.44;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2013.08.08.23.25.06;	author syl;	state Exp;
branches;
next	1.47;

1.47
date	2013.02.17.17.39.29;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2013.02.09.20.56.35;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2011.01.05.13.36.19;	author fgsch;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.03.03.04.55;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2010.06.20.17.57.09;	author phessler;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.13.20.53.41;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.18.22.16.28;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.09.19.16.39;	author oga;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.04.03.14.14;	author oga;	state Exp;
branches;
next	1.37;

1.37
date	2009.04.19.15.26.52;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2009.04.10.20.57.04;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2009.04.04.22.32.05;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.04.22.47.16;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.16.22.14.28;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.23.19.58.47;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.09.09.09.52;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.08.14.05.28;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.21.17.46.52;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.21.17.45.25;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2002.12.08.08.18.37;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.08.04.22.33;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.28.20.45.44;	author jason;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.11.05.59.25;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.21.16.24.16;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.23.00.39.47;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.06.11.19.26;	author art;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	2001.07.26.14.34.43;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.05.10.00.45;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.22.14.14.09;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.08.19.40.55;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.08.19.29.37;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.17.02.48.17;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.15.22.18.24;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.20.17.30.56;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.15.15.58.40;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.15.16.30.28;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.02.17.13.15.46;	author fgsch;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	99.01.11.01.28.10;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.10.01.18.00.04;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	98.02.25.19.53.49;	author weingart;	state Exp;
branches;
next	1.3;

1.3
date	97.07.12.22.50.06;	author weingart;	state Exp;
branches;
next	1.2;

1.2
date	96.12.09.09.27.04;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.08.07.17.27.53;	author deraadt;	state Exp;
branches;
next	;

1.7.6.1
date	2000.02.20.11.57.18;	author niklas;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2000.03.24.09.09.25;	author niklas;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2001.05.14.22.32.43;	author niklas;	state Exp;
branches;
next	1.7.6.4;

1.7.6.4
date	2001.07.04.10.48.30;	author niklas;	state Exp;
branches;
next	1.7.6.5;

1.7.6.5
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.7.6.6;

1.7.6.6
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.7.6.7;

1.7.6.7
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.7.6.8;

1.7.6.8
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	;

1.18.4.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.18.4.3;

1.18.4.3
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.18.4.4;

1.18.4.4
date	2003.05.19.22.31.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.58
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@/*	$OpenBSD: subr_extent.c,v 1.57 2015/08/28 00:03:53 deraadt Exp $	*/
/*	$NetBSD: subr_extent.c,v 1.7 1996/11/21 18:46:34 cgd Exp $	*/

/*-
 * Copyright (c) 1996, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe and Matthias Drochner.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * General purpose extent manager.
 */

#ifdef _KERNEL
#include <sys/param.h>
#include <sys/extent.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/queue.h>
#include <sys/pool.h>
#include <ddb/db_output.h>
#else
/*
 * user-land definitions, so it can fit into a testing harness.
 */
#include <sys/param.h>
#include <sys/extent.h>
#include <sys/queue.h>
#include <errno.h>
#include <err.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define	malloc(s, t, flags)		malloc(s)
#define	free(p, t, s)			free(p)

#define	tsleep(chan, pri, str, timo)	(EWOULDBLOCK)
#define	wakeup(chan)			((void)0)

struct pool {
	size_t pr_size;
};

#define	pool_init(a, b, c, d, e, f, g)	do { (a)->pr_size = (b); } while (0)
#define pool_get(pp, flags)		malloc((pp)->pr_size, 0, 0)
#define	pool_put(pp, rp)		free((rp), 0, 0)

#define	panic(...)		do { warnx(__VA_ARGS__); abort(); } while (0)
#endif

#if defined(DIAGNOSTIC) || defined(DDB)
void	extent_print1(struct extent *, int (*)(const char *, ...)
	    __attribute__((__format__(__kprintf__,1,2))));
#endif

static	void extent_insert_and_optimize(struct extent *, u_long, u_long,
	    struct extent_region *, struct extent_region *);
static	struct extent_region *extent_alloc_region_descriptor(struct extent *, int);
static	void extent_free_region_descriptor(struct extent *,
	    struct extent_region *);
int	extent_do_alloc(struct extent *, u_long, u_long, u_long, u_long,
	    u_long, u_long, int, struct extent_region *, u_long *);

/*
 * Shortcut to align to an arbitrary power-of-two boundary.
 */
static __inline__ u_long
extent_align(u_long start, u_long align, u_long skew)
{
	return ((((start - skew) + (align - 1)) & (-align)) + skew);
}


#if defined(DIAGNOSTIC) || defined(DDB)
/*
 * Register the extent on a doubly linked list.
 * Should work, no?
 */
static LIST_HEAD(listhead, extent) ext_list;
static	void extent_register(struct extent *);

static void
extent_register(struct extent *ex)
{
#ifdef DIAGNOSTIC
	struct extent *ep;
#endif
	static int initialized;

	if (!initialized){
		LIST_INIT(&ext_list);
		initialized = 1;
	}

#ifdef DIAGNOSTIC
	LIST_FOREACH(ep, &ext_list, ex_link) {
		if (ep == ex)
			panic("%s: already registered", __func__);
	}
#endif

	/* Insert into list */
	LIST_INSERT_HEAD(&ext_list, ex, ex_link);
}
#endif	/* DIAGNOSTIC || DDB */

struct pool ex_region_pl;

static void
extent_pool_init(void)
{
	static int inited;

	if (!inited) {
		pool_init(&ex_region_pl, sizeof(struct extent_region), 0,
		    IPL_VM, 0, "extentpl", NULL);
		inited = 1;
	}
}

#ifdef DDB
/*
 * Print out all extents registered.  This is used in
 * DDB show extents
 */
void
extent_print_all(void)
{
	struct extent *ep;

	LIST_FOREACH(ep, &ext_list, ex_link) {
		extent_print1(ep, db_printf);
	}
}
#endif

/*
 * Allocate and initialize an extent map.
 */
struct extent *
extent_create(char *name, u_long start, u_long end, int mtype, caddr_t storage,
    size_t storagesize, int flags)
{
	struct extent *ex;
	caddr_t cp = storage;
	size_t sz = storagesize;
	struct extent_region *rp;
	int fixed_extent = (storage != NULL);

#ifdef DIAGNOSTIC
	/* Check arguments. */
	if (name == NULL)
		panic("%s: name == NULL", __func__);
	if (end < start) {
		printf("%s: extent `%s', start 0x%lx, end 0x%lx\n",
		    __func__, name, start, end);
		panic("%s: end < start", __func__);
	}
	if (fixed_extent && (storagesize < sizeof(struct extent_fixed)))
		panic("%s: fixed extent, bad storagesize 0x%lx",
		    __func__, (u_long)storagesize);
	if (fixed_extent == 0 && (storagesize != 0 || storage != NULL))
		panic("%s: storage provided for non-fixed", __func__);
#endif

	extent_pool_init();

	/* Allocate extent descriptor. */
	if (fixed_extent) {
		struct extent_fixed *fex;

		memset(storage, 0, storagesize);

		/*
		 * Align all descriptors on "long" boundaries.
		 */
		fex = (struct extent_fixed *)cp;
		ex = (struct extent *)fex;
		cp += ALIGN(sizeof(struct extent_fixed));
		sz -= ALIGN(sizeof(struct extent_fixed));
		fex->fex_storage = storage;
		fex->fex_storagesize = storagesize;

		/*
		 * In a fixed extent, we have to pre-allocate region
		 * descriptors and place them in the extent's freelist.
		 */
		LIST_INIT(&fex->fex_freelist);
		while (sz >= ALIGN(sizeof(struct extent_region))) {
			rp = (struct extent_region *)cp;
			cp += ALIGN(sizeof(struct extent_region));
			sz -= ALIGN(sizeof(struct extent_region));
			LIST_INSERT_HEAD(&fex->fex_freelist, rp, er_link);
		}
	} else {
		ex = (struct extent *)malloc(sizeof(struct extent),
		    mtype, (flags & EX_WAITOK) ? M_WAITOK : M_NOWAIT);
		if (ex == NULL)
			return (NULL);
	}

	/* Fill in the extent descriptor and return it to the caller. */
	LIST_INIT(&ex->ex_regions);
	ex->ex_name = name;
	ex->ex_start = start;
	ex->ex_end = end;
	ex->ex_mtype = mtype;
	ex->ex_flags = 0;
	if (fixed_extent)
		ex->ex_flags |= EXF_FIXED;
	if (flags & EX_NOCOALESCE)
		ex->ex_flags |= EXF_NOCOALESCE;

	if (flags & EX_FILLED) {
		rp = extent_alloc_region_descriptor(ex, flags);
		if (rp == NULL) {
			if (!fixed_extent)
				free(ex, mtype, sizeof(struct extent));
			return (NULL);
		}
		rp->er_start = start;
		rp->er_end = end;
		LIST_INSERT_HEAD(&ex->ex_regions, rp, er_link);
	}

#if defined(DIAGNOSTIC) || defined(DDB)
	extent_register(ex);
#endif
	return (ex);
}

/*
 * Destroy an extent map.
 */
void
extent_destroy(struct extent *ex)
{
	struct extent_region *rp, *orp;

#ifdef DIAGNOSTIC
	/* Check arguments. */
	if (ex == NULL)
		panic("%s: NULL extent", __func__);
#endif

	/* Free all region descriptors in extent. */
	for (rp = LIST_FIRST(&ex->ex_regions); rp != NULL; ) {
		orp = rp;
		rp = LIST_NEXT(rp, er_link);
		LIST_REMOVE(orp, er_link);
		extent_free_region_descriptor(ex, orp);
	}

#if defined(DIAGNOSTIC) || defined(DDB)
	/* Remove from the list of all extents. */
	LIST_REMOVE(ex, ex_link);
#endif

	/* If we're not a fixed extent, free the extent descriptor itself. */
	if ((ex->ex_flags & EXF_FIXED) == 0)
		free(ex, ex->ex_mtype, sizeof(*ex));
}

/*
 * Insert a region descriptor into the sorted region list after the
 * entry "after" or at the head of the list (if "after" is NULL).
 * The region descriptor we insert is passed in "rp".  We must
 * allocate the region descriptor before calling this function!
 * If we don't need the region descriptor, it will be freed here.
 */
static void
extent_insert_and_optimize(struct extent *ex, u_long start, u_long size,
    struct extent_region *after, struct extent_region *rp)
{
	struct extent_region *nextr;
	int appended = 0;

	if (after == NULL) {
		/*
		 * We're the first in the region list.  If there's
		 * a region after us, attempt to coalesce to save
		 * descriptor overhead.
		 */
		if (((ex->ex_flags & EXF_NOCOALESCE) == 0) &&
		    !LIST_EMPTY(&ex->ex_regions) &&
		    ((start + size) == LIST_FIRST(&ex->ex_regions)->er_start)) {
			/*
			 * We can coalesce.  Prepend us to the first region.
			 */
			LIST_FIRST(&ex->ex_regions)->er_start = start;
			extent_free_region_descriptor(ex, rp);
			return;
		}

		/*
		 * Can't coalesce.  Fill in the region descriptor
		 * in, and insert us at the head of the region list.
		 */
		rp->er_start = start;
		rp->er_end = start + (size - 1);
		LIST_INSERT_HEAD(&ex->ex_regions, rp, er_link);
		return;
	}

	/*
	 * If EXF_NOCOALESCE is set, coalescing is disallowed.
	 */
	if (ex->ex_flags & EXF_NOCOALESCE)
		goto cant_coalesce;

	/*
	 * Attempt to coalesce with the region before us.
	 */
	if ((after->er_end + 1) == start) {
		/*
		 * We can coalesce.  Append ourselves and make
		 * note of it.
		 */
		after->er_end = start + (size - 1);
		appended = 1;
	}

	/*
	 * Attempt to coalesce with the region after us.
	 */
	if (LIST_NEXT(after, er_link) != NULL &&
	    ((start + size) == LIST_NEXT(after, er_link)->er_start)) {
		/*
		 * We can coalesce.  Note that if we appended ourselves
		 * to the previous region, we exactly fit the gap, and
		 * can free the "next" region descriptor.
		 */
		if (appended) {
			/*
			 * Yup, we can free it up.
			 */
			after->er_end = LIST_NEXT(after, er_link)->er_end;
			nextr = LIST_NEXT(after, er_link);
			LIST_REMOVE(nextr, er_link);
			extent_free_region_descriptor(ex, nextr);
		} else {
			/*
			 * Nope, just prepend us to the next region.
			 */
			LIST_NEXT(after, er_link)->er_start = start;
		}

		extent_free_region_descriptor(ex, rp);
		return;
	}

	/*
	 * We weren't able to coalesce with the next region, but
	 * we don't need to allocate a region descriptor if we
	 * appended ourselves to the previous region.
	 */
	if (appended) {
		extent_free_region_descriptor(ex, rp);
		return;
	}

 cant_coalesce:

	/*
	 * Fill in the region descriptor and insert ourselves
	 * into the region list.
	 */
	rp->er_start = start;
	rp->er_end = start + (size - 1);
	LIST_INSERT_AFTER(after, rp, er_link);
}

/*
 * Allocate a specific region in an extent map.
 */
int
extent_alloc_region(struct extent *ex, u_long start, u_long size, int flags)
{
	struct extent_region *rp, *last, *myrp;
	u_long end = start + (size - 1);
	int error;

#ifdef DIAGNOSTIC
	/* Check arguments. */
	if (ex == NULL)
		panic("%s: NULL extent", __func__);
	if (size < 1) {
		printf("%s: extent `%s', size 0x%lx\n",
		    __func__, ex->ex_name, size);
		panic("%s: bad size", __func__);
	}
	if (end < start) {
		printf("%s: extent `%s', start 0x%lx, size 0x%lx\n",
		    __func__, ex->ex_name, start, size);
		panic("%s: overflow", __func__);
	}
	if ((flags & EX_CONFLICTOK) && (flags & EX_WAITSPACE))
		panic("%s: EX_CONFLICTOK and EX_WAITSPACE "
		    "are mutually exclusive", __func__);
#endif

	/*
	 * Make sure the requested region lies within the
	 * extent.
	 */
	if ((start < ex->ex_start) || (end > ex->ex_end)) {
#ifdef DIAGNOSTIC
		printf("%s: extent `%s' (0x%lx - 0x%lx)\n",
		    __func__, ex->ex_name, ex->ex_start, ex->ex_end);
		printf("%s: start 0x%lx, end 0x%lx\n",
		    __func__, start, end);
		panic("%s: region lies outside extent", __func__);
#else
		return (EINVAL);
#endif
	}

	/*
	 * Allocate the region descriptor.  It will be freed later
	 * if we can coalesce with another region.
	 */
	myrp = extent_alloc_region_descriptor(ex, flags);
	if (myrp == NULL) {
#ifdef DIAGNOSTIC
		printf(
		    "%s: can't allocate region descriptor\n", __func__);
#endif
		return (ENOMEM);
	}

 alloc_start:
	/*
	 * Attempt to place ourselves in the desired area of the
	 * extent.  We save ourselves some work by keeping the list sorted.
	 * In other words, if the start of the current region is greater
	 * than the end of our region, we don't have to search any further.
	 */

	/*
	 * Keep a pointer to the last region we looked at so
	 * that we don't have to traverse the list again when
	 * we insert ourselves.  If "last" is NULL when we
	 * finally insert ourselves, we go at the head of the
	 * list.  See extent_insert_and_optimize() for details.
	 */
	last = NULL;

	LIST_FOREACH(rp, &ex->ex_regions, er_link) {
		if (rp->er_start > end) {
			/*
			 * We lie before this region and don't
			 * conflict.
			 */
			break;
		}

		/*
		 * The current region begins before we end.
		 * Check for a conflict.
		 */
		if (rp->er_end >= start) {
			/*
			 * We conflict.  If we can (and want to) wait,
			 * do so.
			 */
			if (flags & EX_WAITSPACE) {
				ex->ex_flags |= EXF_WANTED;
				error = tsleep(ex,
				    PRIBIO | ((flags & EX_CATCH) ? PCATCH : 0),
				    "extnt", 0);
				if (error)
					return (error);
				goto alloc_start;
			}

			/*
			 * If we tolerate conflicts adjust things such
			 * that all space in the requested region is
			 * allocated.
			 */
			if (flags & EX_CONFLICTOK) {
				/*
				 * There are four possibilities:
				 *
				 * 1. The current region overlaps with
				 *    the start of the requested region.
				 *    Adjust the requested region to
				 *    start at the end of the current
				 *    region and try again.
				 *
				 * 2. The current region falls
				 *    completely within the requested
				 *    region.  Free the current region
				 *    and try again.
				 *
				 * 3. The current region overlaps with
				 *    the end of the requested region.
				 *    Adjust the requested region to
				 *    end at the start of the current
				 *    region and try again.
				 *
				 * 4. The requested region falls
				 *    completely within the current
				 *    region.  We're done.
				 */
				if (rp->er_start <= start) {
					if (rp->er_end < ex->ex_end) {
						start = rp->er_end + 1;
						size = end - start + 1;
						goto alloc_start;
					}
				} else if (rp->er_end < end) {
					LIST_REMOVE(rp, er_link);
					extent_free_region_descriptor(ex, rp);
					goto alloc_start;
				} else if (rp->er_start < end) {
					if (rp->er_start > ex->ex_start) {
						end = rp->er_start - 1;
						size = end - start + 1;
						goto alloc_start;
					}
				}
				return (0);
			}

			extent_free_region_descriptor(ex, myrp);
			return (EAGAIN);
		}
		/*
		 * We don't conflict, but this region lies before
		 * us.  Keep a pointer to this region, and keep
		 * trying.
		 */
		last = rp;
	}

	/*
	 * We don't conflict with any regions.  "last" points
	 * to the region we fall after, or is NULL if we belong
	 * at the beginning of the region list.  Insert ourselves.
	 */
	extent_insert_and_optimize(ex, start, size, last, myrp);
	return (0);
}

/*
 * Macro to check (x + y) <= z.  This check is designed to fail
 * if an overflow occurs.
 */
#define LE_OV(x, y, z)	((((x) + (y)) >= (x)) && (((x) + (y)) <= (z)))

/*
 * Allocate a region in an extent map subregion.
 *
 * If EX_FAST is specified, we return the first fit in the map.
 * Otherwise, we try to minimize fragmentation by finding the
 * smallest gap that will hold the request.
 *
 * The allocated region is aligned to "alignment", which must be
 * a power of 2.
 */
int
extent_do_alloc(struct extent *ex, u_long substart, u_long subend,
    u_long size, u_long alignment, u_long skew, u_long boundary, int flags,
    struct extent_region *myrp, u_long *result)
{
	struct extent_region *rp, *last, *bestlast;
	u_long newstart, newend, exend, beststart, bestovh, ovh;
	u_long dontcross;
	int error;

#ifdef DIAGNOSTIC
	/* Check arguments. */
	if (ex == NULL)
		panic("%s: NULL extent", __func__);
	if (myrp == NULL)
		panic("%s: NULL region descriptor", __func__);
	if (result == NULL)
		panic("%s: NULL result pointer", __func__);
	if ((substart < ex->ex_start) || (substart > ex->ex_end) ||
	    (subend > ex->ex_end) || (subend < ex->ex_start)) {
		printf("%s: extent `%s', ex_start 0x%lx, ex_end 0x%lx\n",
		    __func__, ex->ex_name, ex->ex_start, ex->ex_end);
		printf("%s: substart 0x%lx, subend 0x%lx\n",
		    __func__, substart, subend);
		panic("%s: bad subregion", __func__);
	}
	if ((size < 1) || ((size - 1) > (subend - substart))) {
		printf("%s: extent `%s', size 0x%lx\n",
		    __func__, ex->ex_name, size);
		panic("%s: bad size", __func__);
	}
	if (alignment == 0)
		panic("%s: bad alignment", __func__);
	if (boundary && (boundary < size)) {
		printf("%s: extent `%s', size 0x%lx, boundary 0x%lx\n",
		    __func__, ex->ex_name, size, boundary);
		panic("%s: bad boundary", __func__);
	}
#endif

 alloc_start:
	/*
	 * Keep a pointer to the last region we looked at so
	 * that we don't have to traverse the list again when
	 * we insert ourselves.  If "last" is NULL when we
	 * finally insert ourselves, we go at the head of the
	 * list.  See extent_insert_and_optimize() for details.
	 */
	last = NULL;

	/*
	 * Keep track of size and location of the smallest
	 * chunk we fit in.
	 *
	 * Since the extent can be as large as the numeric range
	 * of the CPU (0 - 0xffffffff for 32-bit systems), the
	 * best overhead value can be the maximum unsigned integer.
	 * Thus, we initialize "bestovh" to 0, since we insert ourselves
	 * into the region list immediately on an exact match (which
	 * is the only case where "bestovh" would be set to 0).
	 */
	bestovh = 0;
	beststart = 0;
	bestlast = NULL;

	/*
	 * Keep track of end of free region.  This is either the end of extent
	 * or the start of a region past the subend.
	 */
	exend = ex->ex_end;

	/*
	 * For N allocated regions, we must make (N + 1)
	 * checks for unallocated space.  The first chunk we
	 * check is the area from the beginning of the subregion
	 * to the first allocated region after that point.
	 */
	newstart = extent_align(substart, alignment, skew);
	if (newstart < ex->ex_start) {
#ifdef DIAGNOSTIC
		printf("%s: extent `%s' (0x%lx - 0x%lx), alignment 0x%lx\n",
		    __func__, ex->ex_name, ex->ex_start, ex->ex_end,
		    alignment);
		panic("%s: overflow after alignment", __func__);
#else
		extent_free_region_descriptor(ex, myrp);
		return (EINVAL);
#endif
	}

	/*
	 * Find the first allocated region that begins on or after
	 * the subregion start, advancing the "last" pointer along
	 * the way.
	 */
	LIST_FOREACH(rp, &ex->ex_regions, er_link) {
		if (rp->er_start >= newstart)
			break;
		last = rp;
	}

	/*
	 * Relocate the start of our candidate region to the end of
	 * the last allocated region (if there was one overlapping
	 * our subrange).
	 */
	if (last != NULL && last->er_end >= newstart)
		newstart = extent_align((last->er_end + 1), alignment, skew);

	for (; rp != NULL; rp = LIST_NEXT(rp, er_link)) {
		/*
		 * If the region pasts the subend, bail out and see
		 * if we fit against the subend.
		 */
		if (rp->er_start > subend) {
			exend = rp->er_start;
			break;
		}

		/*
		 * Check the chunk before "rp".  Note that our
		 * comparison is safe from overflow conditions.
		 */
		if (LE_OV(newstart, size, rp->er_start)) {
			/*
			 * Do a boundary check, if necessary.  Note
			 * that a region may *begin* on the boundary,
			 * but it must end before the boundary.
			 */
			if (boundary) {
				newend = newstart + (size - 1);

				/*
				 * Calculate the next boundary after the start
				 * of this region.
				 */
				dontcross = extent_align(newstart+1, boundary, 
				    (flags & EX_BOUNDZERO) ? 0 : ex->ex_start)
				    - 1;

#if 0
				printf("newstart=%lx newend=%lx ex_start=%lx ex_end=%lx boundary=%lx dontcross=%lx\n",
				    newstart, newend, ex->ex_start, ex->ex_end,
				    boundary, dontcross);
#endif

				/* Check for overflow */
				if (dontcross < ex->ex_start)
					dontcross = ex->ex_end;
				else if (newend > dontcross) {
					/*
					 * Candidate region crosses boundary.
					 * Throw away the leading part and see
					 * if we still fit.
					 */
					newstart = dontcross + 1;
					newend = newstart + (size - 1);
					dontcross += boundary;
					if (!LE_OV(newstart, size, rp->er_start))
						goto skip;
				}

				/*
				 * If we run past the end of
				 * the extent or the boundary
				 * overflows, then the request
				 * can't fit.
				 */
				if (newstart + size - 1 > ex->ex_end ||
				    dontcross < newstart)
					goto fail;
			}

			/*
			 * We would fit into this space.  Calculate
			 * the overhead (wasted space).  If we exactly
			 * fit, or we're taking the first fit, insert
			 * ourselves into the region list.
			 */
			ovh = rp->er_start - newstart - size;
			if ((flags & EX_FAST) || (ovh == 0))
				goto found;

			/*
			 * Don't exactly fit, but check to see
			 * if we're better than any current choice.
			 */
			if ((bestovh == 0) || (ovh < bestovh)) {
				bestovh = ovh;
				beststart = newstart;
				bestlast = last;
			}
		}

skip:
		/*
		 * Skip past the current region and check again.
		 */
		newstart = extent_align((rp->er_end + 1), alignment, skew);
		if (newstart < rp->er_end) {
			/*
			 * Overflow condition.  Don't error out, since
			 * we might have a chunk of space that we can
			 * use.
			 */
			goto fail;
		}
		
		last = rp;
	}

	/*
	 * The final check is from the current starting point to the
	 * end of the subregion.  If there were no allocated regions,
	 * "newstart" is set to the beginning of the subregion, or
	 * just past the end of the last allocated region, adjusted
	 * for alignment in either case.
	 */
	if (LE_OV(newstart, (size - 1), subend)) {
		/*
		 * Do a boundary check, if necessary.  Note
		 * that a region may *begin* on the boundary,
		 * but it must end before the boundary.
		 */
		if (boundary) {
			newend = newstart + (size - 1);

			/*
			 * Calculate the next boundary after the start
			 * of this region.
			 */
			dontcross = extent_align(newstart+1, boundary, 
			    (flags & EX_BOUNDZERO) ? 0 : ex->ex_start)
			    - 1;

#if 0
			printf("newstart=%lx newend=%lx ex_start=%lx ex_end=%lx boundary=%lx dontcross=%lx\n",
			    newstart, newend, ex->ex_start, ex->ex_end,
			    boundary, dontcross);
#endif

			/* Check for overflow */
			if (dontcross < ex->ex_start)
				dontcross = ex->ex_end;
			else if (newend > dontcross) {
				/*
				 * Candidate region crosses boundary.
				 * Throw away the leading part and see
				 * if we still fit.
				 */
				newstart = dontcross + 1;
				newend = newstart + (size - 1);
				dontcross += boundary;
				if (!LE_OV(newstart, (size - 1), subend))
					goto fail;
			}

			/*
			 * If we run past the end of
			 * the extent or the boundary
			 * overflows, then the request
			 * can't fit.
			 */
			if (newstart + size - 1 > ex->ex_end ||
			    dontcross < newstart)
				goto fail;
		}

		/*
		 * We would fit into this space.  Calculate
		 * the overhead (wasted space).  If we exactly
		 * fit, or we're taking the first fit, insert
		 * ourselves into the region list.
		 */
		ovh = exend - newstart - (size - 1);
		if ((flags & EX_FAST) || (ovh == 0))
			goto found;

		/*
		 * Don't exactly fit, but check to see
		 * if we're better than any current choice.
		 */
		if ((bestovh == 0) || (ovh < bestovh)) {
			bestovh = ovh;
			beststart = newstart;
			bestlast = last;
		}
	}

 fail:
	/*
	 * One of the following two conditions have
	 * occurred:
	 *
	 *	There is no chunk large enough to hold the request.
	 *
	 *	If EX_FAST was not specified, there is not an
	 *	exact match for the request.
	 *
	 * Note that if we reach this point and EX_FAST is
	 * set, then we know there is no space in the extent for
	 * the request.
	 */
	if (((flags & EX_FAST) == 0) && (bestovh != 0)) {
		/*
		 * We have a match that's "good enough".
		 */
		newstart = beststart;
		last = bestlast;
		goto found;
	}

	/*
	 * No space currently available.  Wait for it to free up,
	 * if possible.
	 */
	if (flags & EX_WAITSPACE) {
		ex->ex_flags |= EXF_WANTED;
		error = tsleep(ex,
		    PRIBIO | ((flags & EX_CATCH) ? PCATCH : 0), "extnt", 0);
		if (error)
			return (error);
		goto alloc_start;
	}

	extent_free_region_descriptor(ex, myrp);
	return (EAGAIN);

 found:
	/*
	 * Insert ourselves into the region list.
	 */
	extent_insert_and_optimize(ex, newstart, size, last, myrp);
	*result = newstart;
	return (0);
}

int
extent_alloc_subregion(struct extent *ex, u_long substart, u_long subend,
    u_long size, u_long alignment, u_long skew, u_long boundary, int flags,
    u_long *result)
{
	struct extent_region *rp;

	/*
	 * Allocate the region descriptor.  It will be freed later
	 * if we can coalesce with another region.
	 */
	rp = extent_alloc_region_descriptor(ex, flags);
	if (rp == NULL) {
#ifdef DIAGNOSTIC
		printf("%s: can't allocate region descriptor\n", __func__);
#endif
		return (ENOMEM);
	}

	return extent_do_alloc(ex, substart, subend, size, alignment, skew,
	    boundary, flags, rp, result);
}

int
extent_alloc_subregion_with_descr(struct extent *ex, u_long substart,
    u_long subend, u_long size, u_long alignment, u_long skew,
    u_long boundary, int flags, struct extent_region *rp, u_long *result)
{
#ifdef DIAGNOSTIC
	if ((ex->ex_flags & EXF_NOCOALESCE) == 0)
		panic("%s: EX_NOCOALESCE not set", __func__);
#endif

	rp->er_flags = ER_DISCARD;
	return extent_do_alloc(ex, substart, subend, size, alignment, skew,
	    boundary, flags, rp, result);
}

int
extent_free(struct extent *ex, u_long start, u_long size, int flags)
{
	struct extent_region *rp, *nrp = NULL;
	u_long end = start + (size - 1);
	int exflags;

#ifdef DIAGNOSTIC
	/* Check arguments. */
	if (ex == NULL)
		panic("%s: NULL extent", __func__);
	if ((start < ex->ex_start) || (end > ex->ex_end)) {
		extent_print(ex);
		printf("%s: extent `%s', start 0x%lx, size 0x%lx\n",
		    __func__, ex->ex_name, start, size);
		panic("%s: extent `%s', region not within extent",
		    __func__, ex->ex_name);
	}
	/* Check for an overflow. */
	if (end < start) {
		extent_print(ex);
		printf("%s: extent `%s', start 0x%lx, size 0x%lx\n",
		    __func__, ex->ex_name, start, size);
		panic("%s: overflow", __func__);
	}
#endif

	/*
	 * If we're allowing coalescing, we must allocate a region
	 * descriptor now, since it might block.
	 *
	 * XXX Make a static, create-time flags word, so we don't
	 * XXX have to lock to read it!
	 */
	exflags = ex->ex_flags;

	if ((exflags & EXF_NOCOALESCE) == 0) {
		/* Allocate a region descriptor. */
		nrp = extent_alloc_region_descriptor(ex, flags);
		if (nrp == NULL)
			return (ENOMEM);
	}

	/*
	 * Find region and deallocate.  Several possibilities:
	 *
	 *	1. (start == er_start) && (end == er_end):
	 *	   Free descriptor.
	 *
	 *	2. (start == er_start) && (end < er_end):
	 *	   Adjust er_start.
	 *
	 *	3. (start > er_start) && (end == er_end):
	 *	   Adjust er_end.
	 *
	 *	4. (start > er_start) && (end < er_end):
	 *	   Fragment region.  Requires descriptor alloc.
	 *
	 * Cases 2, 3, and 4 require that the EXF_NOCOALESCE flag
	 * is not set.
	 */
	LIST_FOREACH(rp, &ex->ex_regions, er_link) {
		/*
		 * Save ourselves some comparisons; does the current
		 * region end before chunk to be freed begins?  If so,
		 * then we haven't found the appropriate region descriptor.
		 */
		if (rp->er_end < start)
			continue;

		/*
		 * Save ourselves some traversal; does the current
		 * region begin after the chunk to be freed ends?  If so,
		 * then we've already passed any possible region descriptors
		 * that might have contained the chunk to be freed.
		 */
		if (rp->er_start > end)
			break;

		/* Case 1. */
		if ((start == rp->er_start) && (end == rp->er_end)) {
			LIST_REMOVE(rp, er_link);
			extent_free_region_descriptor(ex, rp);
			goto done;
		}

		/*
		 * The following cases all require that EXF_NOCOALESCE
		 * is not set.
		 */
		if (ex->ex_flags & EXF_NOCOALESCE)
			continue;

		/* Case 2. */
		if ((start == rp->er_start) && (end < rp->er_end)) {
			rp->er_start = (end + 1);
			goto done;
		}

		/* Case 3. */
		if ((start > rp->er_start) && (end == rp->er_end)) {
			rp->er_end = (start - 1);
			goto done;
		}

		/* Case 4. */
		if ((start > rp->er_start) && (end < rp->er_end)) {
			/* Fill in new descriptor. */
			nrp->er_start = end + 1;
			nrp->er_end = rp->er_end;

			/* Adjust current descriptor. */
			rp->er_end = start - 1;

			/* Insert new descriptor after current. */
			LIST_INSERT_AFTER(rp, nrp, er_link);

			/* We used the new descriptor, so don't free it below */
			nrp = NULL;
			goto done;
		}
	}

	/* Region not found, or request otherwise invalid. */
#if defined(DIAGNOSTIC) || defined(DDB)
	extent_print(ex);
#endif
	printf("%s: start 0x%lx, end 0x%lx\n", __func__, start, end);
	panic("%s: region not found", __func__);

 done:
	if (nrp != NULL)
		extent_free_region_descriptor(ex, nrp);
	if (ex->ex_flags & EXF_WANTED) {
		ex->ex_flags &= ~EXF_WANTED;
		wakeup(ex);
	}
	return (0);
}

static struct extent_region *
extent_alloc_region_descriptor(struct extent *ex, int flags)
{
	struct extent_region *rp;

	if (ex->ex_flags & EXF_FIXED) {
		struct extent_fixed *fex = (struct extent_fixed *)ex;

		while (LIST_EMPTY(&fex->fex_freelist)) {
			if (flags & EX_MALLOCOK)
				goto alloc;

			if ((flags & EX_WAITOK) == 0)
				return (NULL);
			ex->ex_flags |= EXF_FLWANTED;
			if (tsleep(&fex->fex_freelist,
			    PRIBIO | ((flags & EX_CATCH) ? PCATCH : 0),
			    "extnt", 0))
				return (NULL);
		}
		rp = LIST_FIRST(&fex->fex_freelist);
		LIST_REMOVE(rp, er_link);

		/*
		 * Don't muck with flags after pulling it off the
		 * freelist; it may be a dynamically allocated
		 * region pointer that was kindly given to us,
		 * and we need to preserve that information.
		 */

		return (rp);
	}

 alloc:
	rp = pool_get(&ex_region_pl, (flags & EX_WAITOK) ? PR_WAITOK :
	    PR_NOWAIT);
	if (rp != NULL)
		rp->er_flags = ER_ALLOC;

	return (rp);
}

static void
extent_free_region_descriptor(struct extent *ex, struct extent_region *rp)
{
	if (rp->er_flags & ER_DISCARD)
		return;

	if (ex->ex_flags & EXF_FIXED) {
		struct extent_fixed *fex = (struct extent_fixed *)ex;

		/*
		 * If someone's waiting for a region descriptor,
		 * be nice and give them this one, rather than
		 * just free'ing it back to the system.
		 */
		if (rp->er_flags & ER_ALLOC) {
			if (ex->ex_flags & EXF_FLWANTED) {
				/* Clear all but ER_ALLOC flag. */
				rp->er_flags = ER_ALLOC;
				LIST_INSERT_HEAD(&fex->fex_freelist, rp,
				    er_link);
				goto wake_em_up;
			} else {
				pool_put(&ex_region_pl, rp);
			}
		} else {
			/* Clear all flags. */
			rp->er_flags = 0;
			LIST_INSERT_HEAD(&fex->fex_freelist, rp, er_link);
		}

		if (ex->ex_flags & EXF_FLWANTED) {
 wake_em_up:
			ex->ex_flags &= ~EXF_FLWANTED;
			wakeup(&fex->fex_freelist);
		}
		return;
	}

	/*
	 * We know it's dynamically allocated if we get here.
	 */
	pool_put(&ex_region_pl, rp);
}


#if defined(DIAGNOSTIC) || defined(DDB) || !defined(_KERNEL)

void
extent_print(struct extent *ex)
{
	extent_print1(ex, printf);
}

void
extent_print1(struct extent *ex,
    int (*pr)(const char *, ...) __attribute__((__format__(__kprintf__,1,2))))
{
	struct extent_region *rp;

	if (ex == NULL)
		panic("%s: NULL extent", __func__);

#ifdef _KERNEL
	(*pr)("extent `%s' (0x%lx - 0x%lx), flags=%b\n", ex->ex_name,
	    ex->ex_start, ex->ex_end, ex->ex_flags, EXF_BITS);
#else
	(*pr)("extent `%s' (0x%lx - 0x%lx), flags = 0x%x\n", ex->ex_name,
	    ex->ex_start, ex->ex_end, ex->ex_flags);
#endif

	LIST_FOREACH(rp, &ex->ex_regions, er_link)
		(*pr)("     0x%lx - 0x%lx\n", rp->er_start, rp->er_end);
}
#endif
@


1.57
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.56 2015/03/14 03:38:50 jsg Exp $	*/
a68 1
#define	pool_setipl(pp, ipl)		/* nothing */
d139 2
a140 3
		pool_init(&ex_region_pl, sizeof(struct extent_region), 0, 0, 0,
		    "extentpl", NULL);
		pool_setipl(&ex_region_pl, IPL_VM);
@


1.56
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.55 2014/11/03 03:08:00 deraadt Exp $	*/
d287 1
a287 1
		free(ex, ex->ex_mtype, 0);
@


1.55
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.54 2014/09/14 14:17:25 jsg Exp $	*/
a40 1
#include <sys/time.h>
@


1.54
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.53 2014/09/13 16:06:37 doug Exp $	*/
d245 1
a245 1
				free(ex, mtype, 0);
@


1.53
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.52 2014/08/17 09:48:55 dlg Exp $	*/
a42 1
#include <sys/proc.h>
@


1.52
log
@i broke the userland shim used for the extent regress test when i
made it so struct pool was only visible to _KERNEL. tedu broke it
too when he added the size argument to the kernel free
functions.

this fixes both issues. the main change is to provide a local version of
struct pool with just the bit (pr_size) needed for extent to run.

if extents take advantage of more malloc/pool features (eg, {M,PR}_ZERO
then this will need to be updated again.

found by and based on a diff from Theo Buehler
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.51 2014/07/12 18:43:32 tedu Exp $	*/
d275 1
a275 2
	for (rp = LIST_FIRST(&ex->ex_regions);
	    rp != LIST_END(&ex->ex_regions); ) {
d699 1
a699 1
	for (; rp != LIST_END(&ex->ex_regions); rp = LIST_NEXT(rp, er_link)) {
@


1.51
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.50 2014/01/21 21:45:58 kettenis Exp $	*/
a51 1
#include <sys/pool.h>
d55 1
d61 2
a62 1
#define	free(p, t)			free(p)
d65 11
a75 5
#define	pool_get(pool, flags)		malloc((pool)->pr_size, 0, 0)
#define	pool_init(a, b, c, d, e, f, g)	(a)->pr_size = (b)
#define	pool_setipl(pool, ipl)		/* nothing */
#define	pool_put(pool, rp)		free((rp), 0)
#define	panic				printf
@


1.50
log
@Add extent_alloc_subregion_with_descr(9) which allows the caller to provide
a region descriptor such that the extent manager doesn't need to call
malloc(9).

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.49 2014/01/21 01:48:44 tedu Exp $	*/
d239 1
a239 1
				free(ex, mtype);
d283 1
a283 1
		free(ex, ex->ex_mtype);
@


1.49
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.48 2013/08/08 23:25:06 syl Exp $	*/
d81 2
d585 1
a585 1
extent_alloc_subregion(struct extent *ex, u_long substart, u_long subend,
d587 1
a587 1
    u_long *result)
d589 1
a589 1
	struct extent_region *rp, *myrp, *last, *bestlast;
d598 2
a623 12
	/*
	 * Allocate the region descriptor.  It will be freed later
	 * if we can coalesce with another region.
	 */
	myrp = extent_alloc_region_descriptor(ex, flags);
	if (myrp == NULL) {
#ifdef DIAGNOSTIC
		printf("%s: can't allocate region descriptor\n", __func__);
#endif
		return (ENOMEM);
	}

d922 38
d1144 3
d1185 1
a1185 1
	
@


1.48
log
@Uncomment kprintf format attributes for sys/kern

tested on vax (gcc3) ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.47 2013/02/17 17:39:29 miod Exp $	*/
d191 1
a191 1
		bzero(storage, storagesize);
@


1.47
log
@Comment out recently added __attribute__((__format__(__kprintf__))) annotations
in MI code; gcc 2.95 does not accept such annotation for function pointer
declarations, only function prototypes.
To be uncommented once gcc 2.95 bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.46 2013/02/09 20:56:35 miod Exp $	*/
d73 1
a73 1
	    /* __attribute__((__format__(__kprintf__,1,2))) */);
d1163 1
a1163 1
    int (*pr)(const char *, ...) /* __attribute__((__format__(__kprintf__,1,2))) */)
@


1.46
log
@Add explicit __attribute__ ((__format__(__kprintf__)))) to the functions and
function pointer arguments which are {used as,} wrappers around the kernel
printf function.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.45 2011/01/05 13:36:19 fgsch Exp $	*/
d73 1
a73 1
	    __attribute__((__format__(__kprintf__,1,2))));
d1163 1
a1163 1
    int (*pr)(const char *, ...) __attribute__((__format__(__kprintf__,1,2))))
@


1.45
log
@use __func__ where possible. shaves 4k and makes indentation much better.
kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.44 2010/07/03 03:04:55 tedu Exp $	*/
d72 2
a73 1
void	extent_print1(struct extent *, int (*)(const char *, ...));
d1162 2
a1163 1
extent_print1(struct extent *ex, int (*pr)(const char *, ...))
@


1.44
log
@explicitly specify flags to malloc and pool_get instead of relying on 0.
This is more clear, and as thib pointed out, the default in softraid was
wrong.  ok thib.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.43 2010/06/20 17:57:09 phessler Exp $	*/
d115 1
a115 1
			panic("extent_register: already registered");
d171 1
a171 1
		panic("extent_create: name == NULL");
d173 3
a175 3
		printf("extent_create: extent `%s', start 0x%lx, end 0x%lx\n",
		    name, start, end);
		panic("extent_create: end < start");
d178 2
a179 2
		panic("extent_create: fixed extent, bad storagesize 0x%lx",
		    (u_long)storagesize);
d181 1
a181 1
		panic("extent_create: storage provided for non-fixed");
d261 1
a261 1
		panic("extent_destroy: NULL extent");
d405 1
a405 1
		panic("extent_alloc_region: NULL extent");
d407 3
a409 3
		printf("extent_alloc_region: extent `%s', size 0x%lx\n",
		    ex->ex_name, size);
		panic("extent_alloc_region: bad size");
d412 3
a414 4
		printf(
		 "extent_alloc_region: extent `%s', start 0x%lx, size 0x%lx\n",
		 ex->ex_name, start, size);
		panic("extent_alloc_region: overflow");
d417 2
a418 2
		panic("extent_alloc_region: EX_CONFLICTOK and EX_WAITSPACE "
		    "are mutually exclusive");
d427 5
a431 5
		printf("extent_alloc_region: extent `%s' (0x%lx - 0x%lx)\n",
		    ex->ex_name, ex->ex_start, ex->ex_end);
		printf("extent_alloc_region: start 0x%lx, end 0x%lx\n",
		    start, end);
		panic("extent_alloc_region: region lies outside extent");
d445 1
a445 1
		    "extent_alloc_region: can't allocate region descriptor\n");
d594 1
a594 1
		panic("extent_alloc_subregion: NULL extent");
d596 1
a596 1
		panic("extent_alloc_subregion: NULL result pointer");
d599 5
a603 5
  printf("extent_alloc_subregion: extent `%s', ex_start 0x%lx, ex_end 0x%lx\n",
		    ex->ex_name, ex->ex_start, ex->ex_end);
		printf("extent_alloc_subregion: substart 0x%lx, subend 0x%lx\n",
		    substart, subend);
		panic("extent_alloc_subregion: bad subregion");
d606 3
a608 3
		printf("extent_alloc_subregion: extent `%s', size 0x%lx\n",
		    ex->ex_name, size);
		panic("extent_alloc_subregion: bad size");
d611 1
a611 1
		panic("extent_alloc_subregion: bad alignment");
d613 3
a615 4
		printf(
		    "extent_alloc_subregion: extent `%s', size 0x%lx, "
		    "boundary 0x%lx\n", ex->ex_name, size, boundary);
		panic("extent_alloc_subregion: bad boundary");
d626 1
a626 2
		printf(
		 "extent_alloc_subregion: can't allocate region descriptor\n");
d671 4
a674 4
		printf(
      "extent_alloc_subregion: extent `%s' (0x%lx - 0x%lx), alignment 0x%lx\n",
		 ex->ex_name, ex->ex_start, ex->ex_end, alignment);
		panic("extent_alloc_subregion: overflow after alignment");
d938 1
a938 1
		panic("extent_free: NULL extent");
d941 4
a944 4
		printf("extent_free: extent `%s', start 0x%lx, size 0x%lx\n",
		    ex->ex_name, start, size);
		panic("extent_free: extent `%s', region not within extent",
		    ex->ex_name);
d949 3
a951 3
		printf("extent_free: extent `%s', start 0x%lx, size 0x%lx\n",
		    ex->ex_name, start, size);
		panic("extent_free: overflow");
d1055 2
a1056 2
	printf("extent_free: start 0x%lx, end 0x%lx\n", start, end);
	panic("extent_free: region not found");
d1166 1
a1166 1
		panic("extent_print: NULL extent");
@


1.43
log
@Add some missing includes, so we do not have implicit function
declarations.

OK miod@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.42 2010/01/14 23:12:11 schwarze Exp $	*/
d1105 2
a1106 1
	rp = pool_get(&ex_region_pl, (flags & EX_WAITOK) ? PR_WAITOK : 0);
@


1.42
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.41 2009/10/13 20:53:41 miod Exp $	*/
d58 1
@


1.41
log
@Make sure we do not loop when allocating an extent region with EX_CONFLICTOK
and the whole extent is used; the current code computations would wrap.
Found the hard way by jsg@@, fix discuss with kettenis@@, and you get a
regress test for free (which will spin if you compile it again an old
subr_extent.c)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.40 2009/09/18 22:16:28 kettenis Exp $	*/
d639 1
a639 1
	 * list.  See extent_insert_and_optimize() for deatails.
d1095 1
a1095 1
		 * freelist; it may be a dynamiclly allocated
@


1.40
log
@Make sure we handle all possible ways regions can overlap when EX_CONFLICTOK
is specified.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.39 2009/06/09 19:16:39 oga Exp $	*/
d526 5
a530 3
					start = rp->er_end + 1;
					size = end - start + 1;
					goto alloc_start;
d536 5
a540 3
					end = rp->er_start - 1;
					size = end - start + 1;
					goto alloc_start;
@


1.39
log
@Fix userland regression tests by providing a #define for pool_setipl()
(just a noop since that doesn't matter in userland).

Pointed out by a couple of people, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.38 2009/06/04 03:14:14 oga Exp $	*/
d502 1
a502 1
				 * There are two possibilities:
d504 2
a505 1
				 * 1. The current region overlaps.
d508 1
a508 1
				 *    region, and try again.
d511 13
a523 3
                                 *    completely within the requested
                                 *    region.  Free the current region
                                 *    and try again.
d528 2
a529 1
				} else {
d532 5
d538 1
a538 1
				goto alloc_start;
@


1.38
log
@don't use splvm ourselves, use pool_setipl on the pool we're allocating
from and it will do it for us.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.37 2009/04/19 15:26:52 kettenis Exp $	*/
d65 1
a67 1
#define	splx(s)				((void)(s))
@


1.37
log
@Add a new EX_FILLED flag to make extent_create() create an extent map that
has all space allocated such that we can make holes in it using extent_free().

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.36 2009/04/10 20:57:04 kettenis Exp $	*/
a66 1
#define	splvm()				(1)
d133 1
a1052 1
	int s;
a1082 1
	s = splvm();
a1083 1
	splx(s);
a1092 2
	int s;

a1108 1
				s = splvm();
a1109 1
				splx(s);
a1127 1
	s = splvm();
a1128 1
	splx(s);
@


1.36
log
@Add EX_CONFLICTOK flag that allows an allocation to conflict with existing
allocations, making sure that the union of all space is allocated.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.35 2009/04/04 22:32:05 kettenis Exp $	*/
d230 12
@


1.35
log
@Make extent_print() use printf to avoid the pagination that db_printf
provides, while keeping this behaviour for extent_print_all() which is
only called by ddb.  Based on a diff from deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.34 2008/06/26 05:42:20 ray Exp $	*/
d404 3
d482 30
@


1.34
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.33 2006/06/04 22:47:16 miod Exp $	*/
d71 4
d149 1
a149 1
		extent_print(ep);
d1095 2
a1096 3
#ifndef DDB
#define db_printf printf
#endif
a1097 1
#if defined(DIAGNOSTIC) || defined(DDB) || !defined(_KERNEL)
d1101 6
d1113 1
a1113 1
	db_printf("extent `%s' (0x%lx - 0x%lx), flags=%b\n", ex->ex_name,
d1116 1
a1116 1
	db_printf("extent `%s' (0x%lx - 0x%lx), flags = 0x%x\n", ex->ex_name,
d1121 1
a1121 1
		db_printf("     0x%lx - 0x%lx\n", rp->er_start, rp->er_end);
@


1.33
log
@In extent_destroy(), only remove the extent from the global extent list if
the list is really used, i.e. if option DIAGNOSTIC || option DDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.32 2006/03/16 22:14:28 miod Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.32
log
@Turn EXTENT_ALIGN into an inline function; shaves about 50 to 100 bytes
on RISC arches, but m68k loses a few bytes; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.31 2006/02/23 19:58:47 miod Exp $	*/
d263 1
d266 1
@


1.31
log
@Remove unused extent_find(). Then, we can keep the extent list only if
option DIAGNOSTIC || option DDB, saves some room on installation media.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.30 2005/12/09 09:09:52 jsg Exp $	*/
d85 1
a85 1
 * Macro to align to an arbitrary power-of-two boundary.
d87 5
a91 2
#define EXTENT_ALIGN(_start, _align, _skew)		\
	(((((_start) - (_skew)) + ((_align) - 1)) & (-(_align))) + (_skew))
d605 1
a605 1
	newstart = EXTENT_ALIGN(substart, alignment, skew);
d635 1
a635 1
		newstart = EXTENT_ALIGN((last->er_end + 1), alignment, skew);
d664 1
a664 1
				dontcross = EXTENT_ALIGN(newstart+1, boundary, 
d726 1
a726 1
		newstart = EXTENT_ALIGN((rp->er_end + 1), alignment, skew);
d759 1
a759 1
			dontcross = EXTENT_ALIGN(newstart+1, boundary, 
@


1.30
log
@ansi and deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.29 2005/07/08 14:05:28 krw Exp $	*/
a82 1
static	void extent_register(struct extent *);
d91 1
d97 1
d122 1
a137 20
/*
 * Find a given extent, and return a pointer to
 * it so that other extent functions can be used
 * on it.
 *
 * Returns NULL on failure.
 */
struct extent *
extent_find(char *name)
{
	struct extent *ep;

	LIST_FOREACH(ep, &ext_list, ex_link) {
		if (!strcmp(ep->ex_name, name))
			return(ep);
	}

	return(NULL);
}

d231 1
d233 1
@


1.29
log
@Remove unused extent_insert_and_optimize() parameter 'flags'. Spotted
by lint.

ok art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.28 2005/04/21 17:46:52 miod Exp $	*/
d144 1
a144 2
extent_find(name)
	char *name;
d176 2
a177 7
extent_create(name, start, end, mtype, storage, storagesize, flags)
	char *name;
	u_long start, end;
	int mtype;
	caddr_t storage;
	size_t storagesize;
	int flags;
d257 1
a257 2
extent_destroy(ex)
	struct extent *ex;
d292 2
a293 4
extent_insert_and_optimize(ex, start, size, after, rp)
	struct extent *ex;
	u_long start, size;
	struct extent_region *after, *rp;
d397 1
a397 4
extent_alloc_region(ex, start, size, flags)
	struct extent *ex;
	u_long start, size;
	int flags;
d530 3
a532 6
extent_alloc_subregion(ex, substart, subend, size, alignment, skew, boundary,
    flags, result)
	struct extent *ex;
	u_long substart, subend, size, alignment, skew, boundary;
	int flags;
	u_long *result;
d879 1
a879 4
extent_free(ex, start, size, flags)
	struct extent *ex;
	u_long start, size;
	int flags;
d1019 1
a1019 3
extent_alloc_region_descriptor(ex, flags)
	struct extent *ex;
	int flags;
d1063 1
a1063 3
extent_free_region_descriptor(ex, rp)
	struct extent *ex;
	struct extent_region *rp;
d1115 1
a1115 2
extent_print(ex)
	struct extent *ex;
@


1.28
log
@Correctly handle allocations of size 1 at an extent boundary; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.27 2005/04/21 17:45:25 miod Exp $	*/
d79 1
a79 1
	    int, struct extent_region *, struct extent_region *);
d299 1
a299 1
extent_insert_and_optimize(ex, start, size, flags, after, rp)
a301 1
	int flags;
d521 1
a521 1
	extent_insert_and_optimize(ex, start, size, flags, last, myrp);
d888 1
a888 1
	extent_insert_and_optimize(ex, newstart, size, flags, last, myrp);
@


1.27
log
@Make the non-_KERNEL compilation usable again, in order to add a regress test.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.26 2004/12/26 21:22:13 miod Exp $	*/
d671 1
a671 1
		if (rp->er_start >= subend) {
d908 1
a908 1
	if ((start < ex->ex_start) || (start > ex->ex_end)) {
@


1.26
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.25 2002/12/08 08:18:37 deraadt Exp $	*/
d59 1
d70 6
a75 1
#define db_printf printf
d1136 1
a1136 1
#if defined(DIAGNOSTIC) || defined(DDB)
d1146 1
d1149 4
@


1.25
log
@compile non-DIAGNOSTIC kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.24 2002/12/08 04:22:33 art Exp $	*/
d269 2
a270 1
	for (rp = ex->ex_regions.lh_first; rp != NULL; ) {
d272 1
a272 1
		rp = rp->er_link.le_next;
d309 2
a310 2
		    (ex->ex_regions.lh_first != NULL) &&
		    ((start + size) == ex->ex_regions.lh_first->er_start)) {
d314 1
a314 1
			ex->ex_regions.lh_first->er_start = start;
d350 2
a351 2
	if ((after->er_link.le_next != NULL) &&
	    ((start + size) == after->er_link.le_next->er_start)) {
d361 2
a362 2
			after->er_end = after->er_link.le_next->er_end;
			nextr = after->er_link.le_next;
d369 1
a369 1
			after->er_link.le_next->er_start = start;
d473 1
a473 2
	for (rp = ex->ex_regions.lh_first; rp != NULL;
	    rp = rp->er_link.le_next) {
d646 1
a646 2
	for (rp = ex->ex_regions.lh_first; rp != NULL;
	     rp = rp->er_link.le_next) {
d660 1
a660 1
	for (; rp != NULL; rp = rp->er_link.le_next) {
d952 1
a952 2
	for (rp = ex->ex_regions.lh_first; rp != NULL;
	    rp = rp->er_link.le_next) {
d1042 1
a1042 1
		while (fex->fex_freelist.lh_first == NULL) {
d1054 1
a1054 1
		rp = fex->fex_freelist.lh_first;
d1143 1
a1143 2
	for (rp = ex->ex_regions.lh_first; rp != NULL;
	    rp = rp->er_link.le_next)
@


1.24
log
@ - Use LIST_ macros.
 - Make sure that extent_register is not called more than once on an extent.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.23 2002/06/28 20:45:44 jason Exp $	*/
d95 1
d97 1
@


1.23
log
@Use %b and print the bitmask of the flags in the debugging message for the extent.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.22 2002/06/11 05:59:25 art Exp $	*/
a90 1
static struct listhead *ext_listp;
d93 1
a93 2
extent_register(ex)
	struct extent *ex;
d95 4
a98 2
	/* Is this redundant? */
	if (ext_listp == NULL){
d100 1
a100 1
		ext_listp = &ext_list;
d103 7
d111 1
a111 1
	LIST_INSERT_HEAD(ext_listp, ex, ex_link);
d141 1
a141 1
	for(ep = ext_listp->lh_first; ep != NULL; ep = ep->ex_link.le_next){
d159 1
a159 1
	for(ep = ext_listp->lh_first; ep != NULL; ep = ep->ex_link.le_next){
@


1.22
log
@splvm, not splimp.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.21 2002/03/21 16:24:16 jason Exp $	*/
d1133 2
a1134 2
	db_printf("extent `%s' (0x%lx - 0x%lx), flags = 0x%x\n", ex->ex_name,
	    ex->ex_start, ex->ex_end, ex->ex_flags);
@


1.21
log
@Two patches from NetBSD:
- extent_alloc_subregion shouldn't allocate a region pasts the end of subregion.
- extent_alloc_subregion1(): when a candidate region doesn't fit after being
rounded up to respect boundary limits, adjust newstart and last before
skiping to the next region. Otherwise we may check the same candidate
region against the start of the next region, no the one immediatly following
the hole, leading to corrupted map.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.20 2002/03/14 01:27:04 millert Exp $	*/
d1061 1
a1061 1
	s = splimp();
d1093 1
a1093 1
				s = splimp();
d1114 1
a1114 1
	s = splimp();
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.19 2002/01/23 00:39:47 art Exp $	*/
d186 2
a187 2
		panic("extent_create: fixed extent, bad storagesize 0x%x",
		    storagesize);
d536 1
a536 1
	u_long newstart, newend, beststart, bestovh, ovh;
d608 6
d654 9
d679 1
a679 1
				dontcross = EXTENT_ALIGN(newstart+1, boundary,
d702 1
a702 1
						continue;
d737 1
d750 1
a750 8

		/*
		 * Check that the current region don't run past the
		 * end of the subregion.
		 */
		if (!LE_OV(newstart, (size - 1), subend))
			goto fail;

d774 1
a774 1
			dontcross = EXTENT_ALIGN(newstart+1, boundary,
d817 1
a817 1
		ovh = ex->ex_end - newstart - (size - 1);
@


1.19
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.18 2001/08/06 11:19:26 art Exp $	*/
d72 6
a77 7
static	void extent_insert_and_optimize __P((struct extent *, u_long, u_long,
	    int, struct extent_region *, struct extent_region *));
static	struct extent_region *extent_alloc_region_descriptor
	    __P((struct extent *, int));
static	void extent_free_region_descriptor __P((struct extent *,
	    struct extent_region *));
static	void extent_register __P((struct extent *));
@


1.18
log
@Use pool to allocate extent region descriptors.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.17 2001/07/26 14:34:43 art Exp $	*/
d117 1
a117 1
		    "extentpl", 0, 0, 0, 0);
@


1.18.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.19 2002/01/23 00:39:47 art Exp $	*/
d117 1
a117 1
		    "extentpl", NULL);
@


1.18.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.18.4.1 2002/01/31 22:55:40 niklas Exp $	*/
d72 7
a78 6
static	void extent_insert_and_optimize(struct extent *, u_long, u_long,
	    int, struct extent_region *, struct extent_region *);
static	struct extent_region *extent_alloc_region_descriptor(struct extent *, int);
static	void extent_free_region_descriptor(struct extent *,
	    struct extent_region *);
static	void extent_register(struct extent *);
d187 2
a188 2
		panic("extent_create: fixed extent, bad storagesize 0x%lx",
		    (u_long)storagesize);
d537 1
a537 1
	u_long newstart, newend, exend, beststart, bestovh, ovh;
a608 6
	 * Keep track of end of free region.  This is either the end of extent
	 * or the start of a region past the subend.
	 */
	exend = ex->ex_end;

	/*
a648 9
		 * If the region pasts the subend, bail out and see
		 * if we fit against the subend.
		 */
		if (rp->er_start >= subend) {
			exend = rp->er_start;
			break;
		}

		/*
d665 1
a665 1
				dontcross = EXTENT_ALIGN(newstart+1, boundary, 
d688 1
a688 1
						goto skip;
a722 1
skip:
d735 8
a742 1
		
d766 1
a766 1
			dontcross = EXTENT_ALIGN(newstart+1, boundary, 
d809 1
a809 1
		ovh = exend - newstart - (size - 1);
@


1.18.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.18.4.2 2002/06/11 03:29:40 art Exp $	*/
d1061 1
a1061 1
	s = splvm();
d1093 1
a1093 1
				s = splvm();
d1114 1
a1114 1
	s = splvm();
d1133 2
a1134 2
	db_printf("extent `%s' (0x%lx - 0x%lx), flags=%b\n", ex->ex_name,
	    ex->ex_start, ex->ex_end, ex->ex_flags, EXF_BITS);
@


1.18.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d91 1
d94 2
a95 1
extent_register(struct extent *ex)
d97 2
a98 6
#ifdef DIAGNOSTIC
	struct extent *ep;
#endif
	static int initialized;

	if (!initialized){
d100 1
a100 1
		initialized = 1;
a102 7
#ifdef DIAGNOSTIC
	LIST_FOREACH(ep, &ext_list, ex_link) {
		if (ep == ex)
			panic("extent_register: already registered");
	}
#endif

d104 1
a104 1
	LIST_INSERT_HEAD(&ext_list, ex, ex_link);
d134 1
a134 1
	LIST_FOREACH(ep, &ext_list, ex_link) {
d152 1
a152 1
	LIST_FOREACH(ep, &ext_list, ex_link) {
@


1.17
log
@In extent_destroy, remove the extent from the list of
all extents.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.16 2001/07/05 10:00:45 art Exp $	*/
d52 1
d108 14
d193 2
d1022 1
d1053 3
a1055 4
	rp = (struct extent_region *)
	    malloc(sizeof(struct extent_region), ex->ex_mtype,
	    (flags & EX_WAITOK) ? M_WAITOK : M_NOWAIT);

d1067 1
d1085 3
a1087 1
				free(rp, ex->ex_mtype);
d1106 3
a1108 1
	free(rp, ex->ex_mtype);
@


1.16
log
@Get rid of the wrapper macros around extent_alloc*1
Pass the right amount of arguments and rename them back to their right names.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.15 2001/06/22 14:14:09 deraadt Exp $	*/
d250 3
@


1.15
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.14 2001/05/08 19:40:55 fgsch Exp $	*/
d509 1
a509 1
extent_alloc_subregion1(ex, substart, subend, size, alignment, skew, boundary,
@


1.14
log
@correct 1 printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.13 2001/05/08 19:29:37 fgsch Exp $	*/
d98 1
a98 1
	if(ext_listp == NULL){
d121 2
a122 1
		if(!strcmp(ep->ex_name, name)) return(ep);
d645 1
a645 1
				dontcross = EXTENT_ALIGN(newstart+1, boundary, 
d722 1
a722 1
		
d746 1
a746 1
			dontcross = EXTENT_ALIGN(newstart+1, boundary, 
@


1.13
log
@In extent_alloc_subregion1, be sure that the region returned don't run
past the end of the subregion; art@@ok, deraadt@@ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.12 2001/01/17 02:48:17 deraadt Exp $	*/
d543 2
a544 2
		    "extent_alloc_subregion: extent `%s', size 0x%lx,
		    boundary 0x%lx\n", ex->ex_name, size, boundary);
@


1.12
log
@do not call extent_print() unless DDB || DIAGNOSTIC
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.11 2001/01/15 22:18:24 jason Exp $	*/
d714 7
@


1.11
log
@update from netbsd:
several fixes with regards to boundary cases and other fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.10 2000/09/20 17:30:56 niklas Exp $	*/
d972 1
d974 1
@


1.10
log
@Off by one in a validity check
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.9 2000/03/15 15:58:40 mickey Exp $	*/
d5 1
a5 1
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
d21 2
a22 2
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
d30 2
a31 2
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
d82 1
a82 1
#define EXTENT_ALIGN(_start, _align, _skew)	\
d450 1
a450 1
			 break;
d517 1
a517 1
	u_long dontcross, odontcross;
d526 2
a527 2
	if ((substart < ex->ex_start) || (substart >= ex->ex_end) ||
	    (subend > ex->ex_end) || (subend <= ex->ex_start)) {
d534 1
a534 1
	if (size < 1 || (size - 1) > (subend - substart)) {
a572 16
	 * Initialize the "don't cross" boundary, a.k.a a line
	 * that a region should not cross.  If the boundary lies
	 * before the region starts, we add the "boundary" argument
	 * until we get a meaningful comparison.
	 *
	 * Start the boundary lines at 0 if the caller requests it.
	 */
	dontcross = 0;
	if (boundary) {
		dontcross =
		    ((flags & EX_BOUNDZERO) ? 0 : ex->ex_start) + boundary;
		while (dontcross < substart)
			dontcross += boundary;
	}

	/*
d591 1
a591 1
	 * to the first allocated region.
d606 1
a606 1
	/* 
d612 1
a612 1
	    rp = rp->er_link.le_next) {
d619 3
a621 3
	 * If there are no allocated regions beyond where we want to be,
	 * relocate the start of our candidate region to the end of
	 * the last allocated region (if there was one).
d623 1
a623 1
	if (rp == NULL && last != NULL)
a627 7
		 * Check from the current starting point to the
		 * end of the subregion.
		 */
		if (!LE_OV(newstart, size - 1, subend))
			goto fail;

		/*
d641 2
a642 2
				 * Adjust boundary for a meaningful
				 * comparison.
d644 9
a652 3
				while (dontcross <= newstart) {
					odontcross = dontcross;
					dontcross += boundary;
d654 4
d659 3
a661 4
					 * If we run past the end of
					 * the extent or the boundary
					 * overflows, then the request
					 * can't fit.
d663 5
a667 3
					if ((dontcross > ex->ex_end) ||
					    (dontcross < odontcross))
						goto fail;
d670 9
a678 8
				/* Do the boundary check. */
				if (newend >= dontcross) {
					/*
					 * Candidate region crosses
					 * boundary.  Try again.
					 */
					continue;
				}
d727 49
d850 1
a850 1
	struct extent_region *rp;
d852 1
d875 16
a954 7
			struct extent_region *nrp;

			/* Allocate a region descriptor. */
			nrp = extent_alloc_region_descriptor(ex, flags);
			if (nrp == NULL)
				return (ENOMEM);

d962 1
a962 1
			/* Instert new descriptor after current. */
d964 3
a970 1
#ifdef DIAGNOSTIC
a974 1
#endif
d977 2
@


1.9
log
@prevent overflow in a diagnostic check; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.8 2000/02/15 16:30:28 art Exp $	*/
d647 1
a647 1
		if (LE_OV(newstart, size, subend) == 0)
@


1.8
log
@Add another argument to extent_alloc_subregion to allow specifing an offset
to the alignment. rename the function to extent_alloc_subregion1 and add
compatibility macros.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.7 1999/02/17 13:15:46 fgsch Exp $	*/
d534 1
a534 1
	if ((size < 1) || (size > ((subend - substart) + 1))) {
@


1.7
log
@Always check that the start of our candidate region is within the
bounds of "substart" and "subend".
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.6 1999/01/11 01:28:10 niklas Exp $	*/
d82 3
a84 2
#define EXTENT_ALIGN(_start, _align)			\
	(((_start) + ((_align) - 1)) & (-(_align)))
d508 1
a508 1
extent_alloc_subregion(ex, substart, subend, size, alignment, boundary,
d511 1
a511 1
	u_long substart, subend, size, alignment, boundary;
d609 1
a609 1
	newstart = EXTENT_ALIGN(substart, alignment);
d640 1
a640 1
		newstart = EXTENT_ALIGN((last->er_end + 1), alignment);
d716 1
a716 1
		newstart = EXTENT_ALIGN((rp->er_end + 1), alignment);
@


1.7.6.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.8 2000/02/15 16:30:28 art Exp $	*/
d82 2
a83 3
#define EXTENT_ALIGN(_start, _align, _skew)	\
	(((((_start) - (_skew)) + ((_align) - 1)) & (-(_align))) + (_skew))

d507 1
a507 1
extent_alloc_subregion1(ex, substart, subend, size, alignment, skew, boundary,
d510 1
a510 1
	u_long substart, subend, size, alignment, skew, boundary;
d608 1
a608 1
	newstart = EXTENT_ALIGN(substart, alignment, skew);
d639 1
a639 1
		newstart = EXTENT_ALIGN((last->er_end + 1), alignment, skew);
d715 1
a715 1
		newstart = EXTENT_ALIGN((rp->er_end + 1), alignment, skew);
@


1.7.6.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d534 1
a534 1
	if (size < 1 || (size - 1) > (subend - substart)) {
@


1.7.6.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.12 2001/01/17 02:48:17 deraadt Exp $	*/
d5 1
a5 1
 * Copyright (c) 1996, 1998 The NetBSD Foundation, Inc.
d21 2
a22 2
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
d30 2
a31 2
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
d82 1
a82 1
#define EXTENT_ALIGN(_start, _align, _skew)		\
d450 1
a450 1
			break;
d517 1
a517 1
	u_long dontcross;
d526 2
a527 2
	if ((substart < ex->ex_start) || (substart > ex->ex_end) ||
	    (subend > ex->ex_end) || (subend < ex->ex_start)) {
d534 1
a534 1
	if ((size < 1) || ((size - 1) > (subend - substart))) {
d573 16
d607 1
a607 1
	 * to the first allocated region after that point.
d622 1
a622 1
	/*
d628 1
a628 1
	     rp = rp->er_link.le_next) {
d635 3
a637 3
	 * Relocate the start of our candidate region to the end of
	 * the last allocated region (if there was one overlapping
	 * our subrange).
d639 1
a639 1
	if (last != NULL && last->er_end >= newstart)
d644 7
d664 2
a665 2
				 * Calculate the next boundary after the start
				 * of this region.
d667 3
a669 9
				dontcross = EXTENT_ALIGN(newstart+1, boundary, 
				    (flags & EX_BOUNDZERO) ? 0 : ex->ex_start)
				    - 1;

#if 0
				printf("newstart=%lx newend=%lx ex_start=%lx ex_end=%lx boundary=%lx dontcross=%lx\n",
				    newstart, newend, ex->ex_start, ex->ex_end,
				    boundary, dontcross);
#endif
a670 4
				/* Check for overflow */
				if (dontcross < ex->ex_start)
					dontcross = ex->ex_end;
				else if (newend > dontcross) {
d672 4
a675 3
					 * Candidate region crosses boundary.
					 * Throw away the leading part and see
					 * if we still fit.
d677 3
a679 5
					newstart = dontcross + 1;
					newend = newstart + (size - 1);
					dontcross += boundary;
					if (!LE_OV(newstart, size, rp->er_start))
						continue;
d682 8
a689 9
				/*
				 * If we run past the end of
				 * the extent or the boundary
				 * overflows, then the request
				 * can't fit.
				 */
				if (newstart + size - 1 > ex->ex_end ||
				    dontcross < newstart)
					goto fail;
a737 49
		 * Do a boundary check, if necessary.  Note
		 * that a region may *begin* on the boundary,
		 * but it must end before the boundary.
		 */
		if (boundary) {
			newend = newstart + (size - 1);

			/*
			 * Calculate the next boundary after the start
			 * of this region.
			 */
			dontcross = EXTENT_ALIGN(newstart+1, boundary, 
			    (flags & EX_BOUNDZERO) ? 0 : ex->ex_start)
			    - 1;

#if 0
			printf("newstart=%lx newend=%lx ex_start=%lx ex_end=%lx boundary=%lx dontcross=%lx\n",
			    newstart, newend, ex->ex_start, ex->ex_end,
			    boundary, dontcross);
#endif

			/* Check for overflow */
			if (dontcross < ex->ex_start)
				dontcross = ex->ex_end;
			else if (newend > dontcross) {
				/*
				 * Candidate region crosses boundary.
				 * Throw away the leading part and see
				 * if we still fit.
				 */
				newstart = dontcross + 1;
				newend = newstart + (size - 1);
				dontcross += boundary;
				if (!LE_OV(newstart, (size - 1), subend))
					goto fail;
			}

			/*
			 * If we run past the end of
			 * the extent or the boundary
			 * overflows, then the request
			 * can't fit.
			 */
			if (newstart + size - 1 > ex->ex_end ||
			    dontcross < newstart)
				goto fail;
		}

		/*
d812 1
a812 1
	struct extent_region *rp, *nrp = NULL;
a813 1
	int exflags;
a835 16
	 * If we're allowing coalescing, we must allocate a region
	 * descriptor now, since it might block.
	 *
	 * XXX Make a static, create-time flags word, so we don't
	 * XXX have to lock to read it!
	 */
	exflags = ex->ex_flags;

	if ((exflags & EXF_NOCOALESCE) == 0) {
		/* Allocate a region descriptor. */
		nrp = extent_alloc_region_descriptor(ex, flags);
		if (nrp == NULL)
			return (ENOMEM);
	}

	/*
d900 7
d914 1
a914 1
			/* Insert new descriptor after current. */
a915 3

			/* We used the new descriptor, so don't free it below */
			nrp = NULL;
d920 1
a921 1
#if defined(DIAGNOSTIC) || defined(DDB)
a922 1
#endif
d925 1
a927 2
	if (nrp != NULL)
		extent_free_region_descriptor(ex, nrp);
@


1.7.6.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.7.6.3 2001/05/14 22:32:43 niklas Exp $	*/
d98 1
a98 1
	if (ext_listp == NULL){
d121 1
a121 2
		if (!strcmp(ep->ex_name, name))
			return(ep);
d543 2
a544 2
		    "extent_alloc_subregion: extent `%s', size 0x%lx, "
		    "boundary 0x%lx\n", ex->ex_name, size, boundary);
d644 1
a644 1
				dontcross = EXTENT_ALIGN(newstart+1, boundary,
d714 1
a714 8

		/*
		 * Check that the current region don't run past the
		 * end of the subregion.
		 */
		if (!LE_OV(newstart, (size - 1), subend))
			goto fail;

d738 1
a738 1
			dontcross = EXTENT_ALIGN(newstart+1, boundary,
@


1.7.6.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.7.6.4 2001/07/04 10:48:30 niklas Exp $	*/
a51 1
#include <sys/pool.h>
a106 14
struct pool ex_region_pl;

static void
extent_pool_init(void)
{
	static int inited;

	if (!inited) {
		pool_init(&ex_region_pl, sizeof(struct extent_region), 0, 0, 0,
		    "extentpl", 0, 0, 0, 0);
		inited = 1;
	}
}

a177 2
	extent_pool_init();

a250 3
	/* Remove from the list of all extents. */
	LIST_REMOVE(ex, ex_link);

d509 1
a509 1
extent_alloc_subregion(ex, substart, subend, size, alignment, skew, boundary,
a1001 1
	int s;
d1032 4
a1035 3
	s = splimp();
	rp = pool_get(&ex_region_pl, (flags & EX_WAITOK) ? PR_WAITOK : 0);
	splx(s);
a1046 1
	int s;
d1064 1
a1064 3
				s = splimp();
				pool_put(&ex_region_pl, rp);
				splx(s);
d1083 1
a1083 3
	s = splimp();
	pool_put(&ex_region_pl, rp);
	splx(s);
@


1.7.6.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d117 1
a117 1
		    "extentpl", NULL);
@


1.7.6.7
log
@Merge in -current from about a week ago
@
text
@d72 7
a78 6
static	void extent_insert_and_optimize(struct extent *, u_long, u_long,
	    int, struct extent_region *, struct extent_region *);
static	struct extent_region *extent_alloc_region_descriptor(struct extent *, int);
static	void extent_free_region_descriptor(struct extent *,
	    struct extent_region *);
static	void extent_register(struct extent *);
d187 2
a188 2
		panic("extent_create: fixed extent, bad storagesize 0x%lx",
		    (u_long)storagesize);
d537 1
a537 1
	u_long newstart, newend, exend, beststart, bestovh, ovh;
a608 6
	 * Keep track of end of free region.  This is either the end of extent
	 * or the start of a region past the subend.
	 */
	exend = ex->ex_end;

	/*
a648 9
		 * If the region pasts the subend, bail out and see
		 * if we fit against the subend.
		 */
		if (rp->er_start >= subend) {
			exend = rp->er_start;
			break;
		}

		/*
d665 1
a665 1
				dontcross = EXTENT_ALIGN(newstart+1, boundary, 
d688 1
a688 1
						goto skip;
a722 1
skip:
d735 8
a742 1
		
d766 1
a766 1
			dontcross = EXTENT_ALIGN(newstart+1, boundary, 
d809 1
a809 1
		ovh = exend - newstart - (size - 1);
@


1.7.6.8
log
@Sync the SMP branch with 3.3
@
text
@d91 1
d94 2
a95 1
extent_register(struct extent *ex)
d97 2
a98 6
#ifdef DIAGNOSTIC
	struct extent *ep;
#endif
	static int initialized;

	if (!initialized){
d100 1
a100 1
		initialized = 1;
a102 7
#ifdef DIAGNOSTIC
	LIST_FOREACH(ep, &ext_list, ex_link) {
		if (ep == ex)
			panic("extent_register: already registered");
	}
#endif

d104 1
a104 1
	LIST_INSERT_HEAD(&ext_list, ex, ex_link);
d134 1
a134 1
	LIST_FOREACH(ep, &ext_list, ex_link) {
d152 1
a152 1
	LIST_FOREACH(ep, &ext_list, ex_link) {
d1061 1
a1061 1
	s = splvm();
d1093 1
a1093 1
				s = splvm();
d1114 1
a1114 1
	s = splvm();
d1133 2
a1134 2
	db_printf("extent `%s' (0x%lx - 0x%lx), flags=%b\n", ex->ex_name,
	    ex->ex_start, ex->ex_end, ex->ex_flags, EXF_BITS);
@


1.6
log
@Adhere better to DIAGNOSTIC and DDB options
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.5 1998/10/01 18:00:04 fgsch Exp $	*/
d642 7
@


1.5
log
@Fix a serious bug in extent_alloc_subregion where the subregion start
was ignored. This fix some problems in the pcmcia framework.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.4 1998/02/25 19:53:49 weingart Exp $	*/
d126 1
a126 1

d140 1
d912 1
d917 1
d1021 1
d1038 1
@


1.4
log
@Add command to print out extents.  This helps in debugging PnP stuff,
and "it's just plain cool".
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.3 1997/07/12 22:50:06 weingart Exp $	*/
d620 5
d627 14
@


1.3
log
@Add some more extent stuff, in preperation of PnP.  Huh?  Did I
say PnP?  Anyways, this stuff just adds the ability to register
the extents on creation, etc, etc...

Someone needs to add a DDB command "show extent", to make this
really usefull... ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_extent.c,v 1.2 1996/12/09 09:27:04 niklas Exp $	*/
d52 1
d68 1
d995 4
d1008 1
a1008 1
	printf("extent `%s' (0x%lx - 0x%lx), flags = 0x%x\n", ex->ex_name,
d1013 1
a1013 1
		printf("     0x%lx - 0x%lx\n", rp->er_start, rp->er_end);
@


1.2
log
@Import extent manager from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
d58 1
d75 1
d84 56
d218 2
@


1.1
log
@tiny extent manager by shawn
@
text
@d2 1
d4 2
a5 2
/*
 * Copyright (c) 1996, Shawn Hsiao <shawn@@alpha.secc.fju.edu.tw>
d8 3
d19 7
d27 11
a37 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d40 5
d46 3
d50 6
a55 2
#include <sys/malloc.h>
#include <sys/queue.h>
d57 16
d74 5
a78 2
LIST_HEAD(, emap) emap_list;
static initialized = 0;
d80 5
a84 2
struct emap *
find_emap(name)
d86 117
d204 2
a205 1
	struct emap *e;
d207 25
a231 3
	if (!initialized) {
		LIST_INIT(&emap_list);
		initialized = 1;
d234 45
a278 3
	for (e = emap_list.lh_first; e; e = e->emap_link.le_next) {
		if (!strcmp(e->name, name))
			break;
d281 8
a288 7
	if (!e) {
		e = (struct emap *)malloc(sizeof(struct emap),
		    M_DEVBUF, M_WAITOK);
		e->name = (char *)malloc(strlen(name) + 1, M_DEVBUF, M_WAITOK);
		strcpy(e->name, name);
		LIST_INIT(&e->extent_list);
		LIST_INSERT_HEAD(&emap_list, e, emap_link);
d290 10
a299 1
	return(e);
d302 8
a309 4
void
add_extent(e, base, size)
	struct emap *e;
	u_int32_t base, size;
d311 105
a415 1
	struct extent *this;
d417 7
a423 6
	this = (struct extent *)malloc(sizeof(struct extent),
	    M_DEVBUF, M_WAITOK);
	bzero(this, sizeof(struct extent));
	this->base = base;
	this->size = size;
	LIST_INSERT_HEAD(&e->extent_list, this, extent_link);
d427 14
a440 2
 * return 0 if the region does not conflict with other's
 * return -1 if it does
d443 25
a467 13
probe_extent(e, base, size)
	struct emap *e;
	u_int32_t base, size;
{
	struct extent *ptr;

	for (ptr = e->extent_list.lh_first; ptr;
	     ptr = ptr->extent_link.le_next) {
		if (ptr->base <= base && ptr->base + ptr->size > base)
			return(-1);
		if (ptr->base < base + size &&
		    ptr->base + ptr->size >= base + size)
			return (-1);
d469 478
a946 1
	return(0);
@

