head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.25.0.6
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.2
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.8
	OPENBSD_5_0:1.19.0.6
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.17.0.10
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.12
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.8
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.6
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.4
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.11
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.22
	OPENBSD_2_8:1.6.0.20
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.18
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.16
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.14
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.12
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.10
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.8
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.6
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.4
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2016.09.04.09.22.29;	author mpi;	state Exp;
branches;
next	1.29;
commitid	jBolvsPoQ0BaYiLs;

1.29
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.28;
commitid	Cl55DD2g2xm69E6W;

1.28
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.27;
commitid	p4LJxGKbi0BU2cG6;

1.27
date	2014.08.30.08.48.23;	author mpi;	state Exp;
branches;
next	1.26;
commitid	YAuBsf99YYiHTIEO;

1.26
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	EF98ch02VpFassUi;

1.25
date	2013.03.28.16.55.25;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.22;

1.22
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2012.08.02.03.18.48;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.09.20.30.48;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.26.23.24.45;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.24.20.28.43;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.09.09.09.52;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.01.18.06.03;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.14.17.52.51;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.10.11.11.22;	author nordin;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.07.21.20.02;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.09.19.20.50.59;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.17.14.26.36;	author art;	state Exp;
branches;
next	1.6;

1.6
date	96.05.02.13.12.22;	author deraadt;	state Exp;
branches
	1.6.16.1;
next	1.5;

1.5
date	96.04.28.00.26.46;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.27.21;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.17.20.01;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.43.37;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches;
next	;

1.6.16.1
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.6.16.2;

1.6.16.2
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.6.16.3;

1.6.16.3
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.6.16.4;

1.6.16.4
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.6.16.5;

1.6.16.5
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.6.16.6;

1.6.16.6
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Introduce Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

Currently only available on amd64 and guarded under DDBPROF.  Support
for other archs will follow soon.

A new sysctl knob, ddb.console, need to be set to 1 in securelevel 0
to be able to use this feature.

Inputs and ok guenther@@
@
text
@/*	$OpenBSD: subr_prof.c,v 1.29 2015/12/05 10:11:53 tedu Exp $	*/
/*	$NetBSD: subr_prof.c,v 1.12 1996/04/22 01:38:50 christos Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)subr_prof.c	8.3 (Berkeley) 9/23/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/mount.h>
#include <sys/sysctl.h>
#include <sys/syscallargs.h>


#if defined(GPROF) || defined(DDBPROF)
#include <sys/malloc.h>
#include <sys/gmon.h>

#include <uvm/uvm_extern.h>

#include <machine/db_machdep.h>
#include <ddb/db_extern.h>

/*
 * Flag to prevent CPUs from executing the mcount() monitor function
 * until we're sure they are in a sane state.
 */
int gmoninit = 0;

extern char etext[];

void
prof_init(void)
{
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	struct gmonparam *p;
	u_long lowpc, highpc, textsize;
	u_long kcountsize, fromssize, tossize;
	long tolimit;
	char *cp;
	int size;

#if !defined(GPROF) && defined(DDBPROF)
	db_prof_init();
#endif

	/*
	 * Round lowpc and highpc to multiples of the density we're using
	 * so the rest of the scaling (here and in gprof) stays in ints.
	 */
	lowpc = ROUNDDOWN(KERNBASE, HISTFRACTION * sizeof(HISTCOUNTER));
	highpc = ROUNDUP((u_long)etext, HISTFRACTION * sizeof(HISTCOUNTER));
	textsize = highpc - lowpc;
#ifdef GPROF
	printf("Profiling kernel, textsize=%ld [%lx..%lx]\n",
	    textsize, lowpc, highpc);
#endif
	kcountsize = textsize / HISTFRACTION;
	fromssize = textsize / HASHFRACTION;
	tolimit = textsize * ARCDENSITY / 100;
	if (tolimit < MINARCS)
		tolimit = MINARCS;
	else if (tolimit > MAXARCS)
		tolimit = MAXARCS;
	tossize = tolimit * sizeof(struct tostruct);
	size = sizeof(*p) + kcountsize + fromssize + tossize;

	/* Allocate and initialize one profiling buffer per CPU. */
	CPU_INFO_FOREACH(cii, ci) {
		cp = km_alloc(round_page(size), &kv_any, &kp_zero, &kd_nowait);
		if (cp == NULL) {
			printf("No memory for profiling.\n");
			return;
		}

		p = (struct gmonparam *)cp;
		cp += sizeof(*p);
		p->tos = (struct tostruct *)cp;
		cp += tossize;
		p->kcount = (u_short *)cp;
		cp += kcountsize;
		p->froms = (u_short *)cp;

		p->state = GMON_PROF_OFF;
		p->lowpc = lowpc;
		p->highpc = highpc;
		p->textsize = textsize;
		p->hashfraction = HASHFRACTION;
		p->kcountsize = kcountsize;
		p->fromssize = fromssize;
		p->tolimit = tolimit;
		p->tossize = tossize;

		ci->ci_gmon = p;
	}
}

int
prof_state_toggle(struct gmonparam *gp, int oldstate)
{
	int error = 0;

	if (gp->state == oldstate)
		return (0);

	switch (gp->state) {
	case GMON_PROF_ON:
#if !defined(GPROF)
		/*
		 * If this is not a profiling kernel, we need to patch
		 * all symbols that can be instrummented.
		 */
		error = db_prof_enable();
#endif
		if (error == 0)
			startprofclock(&process0);
		break;
	default:
		error = EINVAL;
		gp->state = GMON_PROF_OFF;
		/* FALLTHROUGH */
	case GMON_PROF_OFF:
		stopprofclock(&process0);
#if !defined(GPROF)
		db_prof_disable();
#endif
		break;
	}

	return (error);
}

/*
 * Return kernel profiling information.
 */
int
sysctl_doprof(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	struct gmonparam *gp = NULL;
	int error, cpuid, op, state;

	/* all sysctl names at this level are name and field */
	if (namelen != 2)
		return (ENOTDIR);		/* overloaded */

	op = name[0];
	cpuid = name[1];

	CPU_INFO_FOREACH(cii, ci) {
		if (cpuid == CPU_INFO_UNIT(ci)) {
			gp = ci->ci_gmon;
			break;
		}
	}

	if (gp == NULL)
		return (EOPNOTSUPP);

	/* Assume that if we're here it is safe to execute profiling. */
	gmoninit = 1;

	switch (op) {
	case GPROF_STATE:
		state = gp->state;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &gp->state);
		if (error)
			return (error);
		return (prof_state_toggle(gp, state));
	case GPROF_COUNT:
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    gp->kcount, gp->kcountsize));
	case GPROF_FROMS:
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    gp->froms, gp->fromssize));
	case GPROF_TOS:
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    gp->tos, gp->tossize));
	case GPROF_GMONPARAM:
		return (sysctl_rdstruct(oldp, oldlenp, newp, gp, sizeof *gp));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}
#endif /* GPROF || DDBPROF */

/*
 * Profiling system call.
 *
 * The scale factor is a fixed point number with 16 bits of fraction, so that
 * 1.0 is represented as 0x10000.  A scale factor of 0 turns off profiling.
 */
int
sys_profil(struct proc *p, void *v, register_t *retval)
{
	struct sys_profil_args /* {
		syscallarg(caddr_t) samples;
		syscallarg(size_t) size;
		syscallarg(u_long) offset;
		syscallarg(u_int) scale;
	} */ *uap = v;
	struct process *pr = p->p_p;
	struct uprof *upp;
	int s;

	if (SCARG(uap, scale) > (1 << 16))
		return (EINVAL);
	if (SCARG(uap, scale) == 0) {
		stopprofclock(pr);
		return (0);
	}
	upp = &pr->ps_prof;

	/* Block profile interrupts while changing state. */
	s = splstatclock();
	upp->pr_off = SCARG(uap, offset);
	upp->pr_scale = SCARG(uap, scale);
	upp->pr_base = (caddr_t)SCARG(uap, samples);
	upp->pr_size = SCARG(uap, size);
	startprofclock(pr);
	splx(s);

	return (0);
}

/*
 * Scale is a fixed-point number with the binary point 16 bits
 * into the value, and is <= 1.0.  pc is at most 32 bits, so the
 * intermediate result is at most 48 bits.
 */
#define	PC_TO_INDEX(pc, prof) \
	((int)(((u_quad_t)((pc) - (prof)->pr_off) * \
	    (u_quad_t)((prof)->pr_scale)) >> 16) & ~1)

/*
 * Collect user-level profiling statistics; called on a profiling tick,
 * when a process is running in user-mode.  This routine may be called
 * from an interrupt context. Schedule an AST that will vector us to
 * trap() with a context in which copyin and copyout will work.
 * Trap will then call addupc_task().
 */
void
addupc_intr(struct proc *p, u_long pc)
{
	struct uprof *prof;

	prof = &p->p_p->ps_prof;
	if (pc < prof->pr_off || PC_TO_INDEX(pc, prof) >= prof->pr_size)
		return;			/* out of range; ignore */

	p->p_prof_addr = pc;
	p->p_prof_ticks++;
	atomic_setbits_int(&p->p_flag, P_OWEUPC);
	need_proftick(p);
}


/*
 * Much like before, but we can afford to take faults here.  If the
 * update fails, we simply turn off profiling.
 */
void
addupc_task(struct proc *p, u_long pc, u_int nticks)
{
	struct process *pr = p->p_p;
	struct uprof *prof;
	caddr_t addr;
	u_int i;
	u_short v;

	/* Testing PS_PROFIL may be unnecessary, but is certainly safe. */
	if ((pr->ps_flags & PS_PROFIL) == 0 || nticks == 0)
		return;

	prof = &pr->ps_prof;
	if (pc < prof->pr_off ||
	    (i = PC_TO_INDEX(pc, prof)) >= prof->pr_size)
		return;

	addr = prof->pr_base + i;
	if (copyin(addr, (caddr_t)&v, sizeof(v)) == 0) {
		v += nticks;
		if (copyout((caddr_t)&v, addr, sizeof(v)) == 0)
			return;
	}
	stopprofclock(pr);
}
@


1.29
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.28 2015/03/14 03:38:50 jsg Exp $	*/
d44 1
a44 1
#ifdef GPROF
d50 3
d62 1
a62 1
kmstartup(void)
d73 4
d84 1
d87 1
d128 35
d173 1
a173 1
	int error, cpuid, op;
d197 1
d201 1
a201 5
		if (gp->state == GMON_PROF_OFF)
			stopprofclock(&process0);
		else
			startprofclock(&process0);
		return (0);
d218 1
a218 1
#endif /* GPROF */
@


1.28
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.27 2014/08/30 08:48:23 mpi Exp $	*/
a184 1
/* ARGSUSED */
@


1.27
log
@Fix profiling (GPROF) build.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.26 2014/07/08 17:19:25 deraadt Exp $	*/
a36 1
#include <sys/kernel.h>
@


1.26
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.25 2013/03/28 16:55:25 deraadt Exp $	*/
d48 2
@


1.25
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.24 2013/03/12 09:37:16 mpi Exp $	*/
a47 1
#include <uvm/uvm_extern.h>
@


1.24
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.23 2013/02/12 08:06:22 mpi Exp $	*/
a43 1
#include <machine/cpu.h>
@


1.23
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.22 2013/02/11 17:05:25 mpi Exp $	*/
d52 2
a53 1
 * Froms is actually a bunch of unsigned shorts indexing tos
d55 1
a55 1
struct gmonparam _gmonparam = { GMON_PROF_OFF };
a58 1

d62 6
a68 1
	struct gmonparam *p = &_gmonparam;
d75 3
a77 3
	p->lowpc = ROUNDDOWN(KERNBASE, HISTFRACTION * sizeof(HISTCOUNTER));
	p->highpc = ROUNDUP((u_long)etext, HISTFRACTION * sizeof(HISTCOUNTER));
	p->textsize = p->highpc - p->lowpc;
d79 38
a116 15
	       p->textsize, p->lowpc, p->highpc);
	p->kcountsize = p->textsize / HISTFRACTION;
	p->hashfraction = HASHFRACTION;
	p->fromssize = p->textsize / HASHFRACTION;
	p->tolimit = p->textsize * ARCDENSITY / 100;
	if (p->tolimit < MINARCS)
		p->tolimit = MINARCS;
	else if (p->tolimit > MAXARCS)
		p->tolimit = MAXARCS;
	p->tossize = p->tolimit * sizeof(struct tostruct);
	size = p->kcountsize + p->fromssize + p->tossize;
	cp = (char *)uvm_km_zalloc(kernel_map, round_page(size));
	if (cp == 0) {
		printf("No memory for profiling.\n");
		return;
a117 5
	p->tos = (struct tostruct *)cp;
	cp += p->tossize;
	p->kcount = (u_short *)cp;
	cp += p->kcountsize;
	p->froms = (u_short *)cp;
d127 4
a130 2
	struct gmonparam *gp = &_gmonparam;
	int error;
d132 2
a133 2
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
d136 17
a152 1
	switch (name[0]) {
@


1.22
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.21 2012/08/02 03:18:48 guenther Exp $	*/
d52 1
a52 2
 * Protect CPUs from executing profiling while they are not yet in a
 * sane state.
d54 1
a54 1
int gmoninit = 0;
a57 2
#define ROUNDDOWN(x,y)	(((x)/(y))*(y))
#define ROUNDUP(x,y)	((((x)+(y)-1)/(y))*(y))
a61 6
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	struct gmonparam *p;
	u_long lowpc, highpc, textsize;
	u_long kcountsize, fromssize, tossize;
	long tolimit;
d63 1
d70 3
a72 3
	lowpc = ROUNDDOWN(KERNBASE, HISTFRACTION * sizeof(HISTCOUNTER));
	highpc = ROUNDUP((u_long)etext, HISTFRACTION * sizeof(HISTCOUNTER));
	textsize = highpc - lowpc;
d74 15
a88 38
	    textsize, lowpc, highpc);
	kcountsize = textsize / HISTFRACTION;
	fromssize = textsize / HASHFRACTION;
	tolimit = textsize * ARCDENSITY / 100;
	if (tolimit < MINARCS)
		tolimit = MINARCS;
	else if (tolimit > MAXARCS)
		tolimit = MAXARCS;
	tossize = tolimit * sizeof(struct tostruct);
	size = sizeof(*p) + kcountsize + fromssize + tossize;

	/* Allocate and initialize one profiling buffer per CPU. */
	CPU_INFO_FOREACH(cii, ci) {
		cp = km_alloc(round_page(size), &kv_any, &kp_zero, &kd_nowait);
		if (cp == NULL) {
			printf("No memory for profiling.\n");
			return;
		}

		p = (struct gmonparam *)cp;
		cp += sizeof(*p);
		p->tos = (struct tostruct *)cp;
		cp += tossize;
		p->kcount = (u_short *)cp;
		cp += kcountsize;
		p->froms = (u_short *)cp;

		p->state = GMON_PROF_OFF;
		p->lowpc = lowpc;
		p->highpc = highpc;
		p->textsize = textsize;
		p->hashfraction = HASHFRACTION;
		p->kcountsize = kcountsize;
		p->fromssize = fromssize;
		p->tolimit = tolimit;
		p->tossize = tossize;

		ci->ci_gmon = p;
d90 5
d104 2
a105 4
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	struct gmonparam *gp = NULL;
	int error, cpuid, op;
d107 2
a108 2
	/* all sysctl names at this level are name and field */
	if (namelen != 2)
d111 1
a111 17
	op = name[0];
	cpuid = name[1];

	CPU_INFO_FOREACH(cii, ci) {
		if (cpuid == CPU_INFO_UNIT(ci)) {
			gp = ci->ci_gmon;
			break;
		}
	}

	if (gp == NULL)
		return (EOPNOTSUPP);

	/* Assume that if we're here it is safe to execute profiling. */
	gmoninit = 1;

	switch (op) {
@


1.21
log
@Apply profiling to all threads instead of just the thread that called
profil() by moving P_PROFIL from proc->p_flag to process->ps_flags with
matching adjustment in fork1() and exit1()

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.20 2012/03/23 15:51:26 guenther Exp $	*/
d52 2
a53 1
 * Froms is actually a bunch of unsigned shorts indexing tos
d55 1
a55 1
struct gmonparam _gmonparam = { GMON_PROF_OFF };
d59 2
d65 6
a71 1
	struct gmonparam *p = &_gmonparam;
d78 3
a80 3
	p->lowpc = ROUNDDOWN(KERNBASE, HISTFRACTION * sizeof(HISTCOUNTER));
	p->highpc = ROUNDUP((u_long)etext, HISTFRACTION * sizeof(HISTCOUNTER));
	p->textsize = p->highpc - p->lowpc;
d82 38
a119 15
	       p->textsize, p->lowpc, p->highpc);
	p->kcountsize = p->textsize / HISTFRACTION;
	p->hashfraction = HASHFRACTION;
	p->fromssize = p->textsize / HASHFRACTION;
	p->tolimit = p->textsize * ARCDENSITY / 100;
	if (p->tolimit < MINARCS)
		p->tolimit = MINARCS;
	else if (p->tolimit > MAXARCS)
		p->tolimit = MAXARCS;
	p->tossize = p->tolimit * sizeof(struct tostruct);
	size = p->kcountsize + p->fromssize + p->tossize;
	cp = (char *)uvm_km_zalloc(kernel_map, round_page(size));
	if (cp == 0) {
		printf("No memory for profiling.\n");
		return;
a120 5
	p->tos = (struct tostruct *)cp;
	cp += p->tossize;
	p->kcount = (u_short *)cp;
	cp += p->kcountsize;
	p->froms = (u_short *)cp;
d130 4
a133 2
	struct gmonparam *gp = &_gmonparam;
	int error;
d135 2
a136 2
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
d139 17
a155 1
	switch (name[0]) {
@


1.20
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.19 2010/07/09 20:30:48 deraadt Exp $	*/
d117 1
a117 1
			stopprofclock(&proc0);
d119 1
a119 1
			startprofclock(&proc0);
d155 1
d162 1
a162 1
		stopprofclock(p);
d165 1
a165 1
	upp = &p->p_p->ps_prof;
d173 1
a173 1
	startprofclock(p);
d218 1
d224 2
a225 2
	/* Testing P_PROFIL may be unnecessary, but is certainly safe. */
	if ((p->p_flag & P_PROFIL) == 0 || nticks == 0)
d228 1
a228 1
	prof = &p->p_p->ps_prof;
d239 1
a239 1
	stopprofclock(p);
@


1.19
log
@need sysctl.h to compile with GPROF; Luis Henriques
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.18 2010/06/26 23:24:45 guenther Exp $	*/
d164 1
a164 1
	upp = &p->p_stats->p_prof;
d199 1
a199 1
	prof = &p->p_stats->p_prof;
d203 2
a204 2
	prof->pr_addr = pc;
	prof->pr_ticks++;
d226 1
a226 1
	prof = &p->p_stats->p_prof;
@


1.18
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.17 2007/03/15 10:22:30 art Exp $	*/
d41 1
@


1.17
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.16 2006/12/24 20:28:43 miod Exp $	*/
d39 1
a39 1
#include <sys/user.h>
@


1.16
log
@Keep a counter for addupc_intr() invocations, and pass its value, instead of 1,
to addupc_task() in ADDUPROF(). From NetBSD via art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.15 2005/12/09 09:09:52 jsg Exp $	*/
d204 1
@


1.15
log
@ansi and deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.14 2003/09/01 18:06:03 henning Exp $	*/
d203 1
@


1.14
log
@match syscallargs comments with reality
from Patrick Latifi <patrick.l@@hermes.usherb.ca>
ok jason@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.13 2003/06/02 23:28:06 millert Exp $	*/
d59 1
a59 1
kmstartup()
d100 2
a101 7
sysctl_doprof(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
d146 1
a146 4
sys_profil(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d148 1
a148 1
	register struct sys_profil_args /* {
d154 1
a154 1
	register struct uprof *upp;
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.12 2003/04/14 17:52:51 tedu Exp $	*/
d157 3
a159 3
		syscallarg(char *) samples;
		syscallarg(u_int) size;
		syscallarg(u_int) offset;
@


1.12
log
@rename ticks to nticks to avoid global.  ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.11 2002/06/10 11:11:22 nordin Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@Grammar.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.10 2002/06/07 21:20:02 art Exp $	*/
d224 1
a224 1
addupc_task(struct proc *p, u_long pc, u_int ticks)
d232 1
a232 1
	if ((p->p_flag & P_PROFIL) == 0 || ticks == 0)
d242 1
a242 1
		v += ticks;
@


1.10
log
@Change addupc_intr to not use fuswintr and suswintr to update the profiling
info. Since we only use it to profile processes in user mode and there
is no way to get back user mode without going past the AST that will
write out the profiling info in a context where copyout works.

Sitting in my tree for ages.
Reviewed and with some suggestions from nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.9 2001/11/06 19:53:20 miod Exp $	*/
d201 1
a201 1
 * from an interrupt context. Schedule and AST that will vector us to
@


1.9
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.8 2001/09/19 20:50:59 mickey Exp $	*/
d201 3
a203 9
 * from an interrupt context.  We try to update the user profiling buffers
 * cheaply with fuswintr() and suswintr().  If that fails, we revert to
 * an AST that will vector us to trap() with a context in which copyin
 * and copyout will work.  Trap will then call addupc_task().
 *
 * Note that we may (rarely) not get around to the AST soon enough, and
 * lose profile ticks when the next tick overwrites this one, but in this
 * case the system is overloaded and the profile is probably already
 * inaccurate.
d206 1
a206 4
addupc_intr(p, pc, ticks)
	register struct proc *p;
	register u_long pc;
	u_int ticks;
d208 1
a208 4
	register struct uprof *prof;
	register caddr_t addr;
	register u_int i;
	register int v;
a209 2
	if (ticks == 0)
		return;
d211 1
a211 2
	if (pc < prof->pr_off ||
	    (i = PC_TO_INDEX(pc, prof)) >= prof->pr_size)
d214 2
a215 6
	addr = prof->pr_base + i;
	if ((v = fuswintr(addr)) == -1 || suswintr(addr, v + ticks) == -1) {
		prof->pr_addr = pc;
		prof->pr_ticks = ticks;
		need_proftick(p);
	}
d218 1
d224 1
a224 4
addupc_task(p, pc, ticks)
	register struct proc *p;
	register u_long pc;
	u_int ticks;
d226 3
a228 3
	register struct uprof *prof;
	register caddr_t addr;
	register u_int i;
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.9 2001/11/06 19:53:20 miod Exp $	*/
d201 9
a209 3
 * from an interrupt context. Schedule and AST that will vector us to
 * trap() with a context in which copyin and copyout will work.
 * Trap will then call addupc_task().
d212 4
a215 1
addupc_intr(struct proc *p, u_long pc)
d217 4
a220 1
	struct uprof *prof;
d222 2
d225 2
a226 1
	if (pc < prof->pr_off || PC_TO_INDEX(pc, prof) >= prof->pr_size)
d229 6
a234 2
	prof->pr_addr = pc;
	need_proftick(p);
a236 1

d242 4
a245 1
addupc_task(struct proc *p, u_long pc, u_int ticks)
d247 3
a249 3
	struct uprof *prof;
	caddr_t addr;
	u_int i;
@


1.9.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.9.2.1 2002/06/11 03:29:40 art Exp $	*/
d201 1
a201 1
 * from an interrupt context. Schedule an AST that will vector us to
@


1.9.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d224 1
a224 1
addupc_task(struct proc *p, u_long pc, u_int nticks)
d232 1
a232 1
	if ((p->p_flag & P_PROFIL) == 0 || nticks == 0)
d242 1
a242 1
		v += nticks;
@


1.8
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.7 2001/09/17 14:26:36 art Exp $	*/
a51 1
#include <vm/vm.h>
@


1.7
log
@Allocate the profiling buffer from kernel_map, not with malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.6 1996/05/02 13:12:22 deraadt Exp $	*/
a52 1
#include <vm/vm_kern.h>
@


1.6
log
@sync syscalls, no sys/cpu.h
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.3 1996/03/03 17:20:01 niklas Exp $	*/
d52 3
d69 2
d89 2
a90 2
	cp = (char *)malloc(p->kcountsize + p->fromssize + p->tossize,
	    M_GPROF, M_NOWAIT);
a94 1
	bzero(cp, p->kcountsize + p->tossize + p->fromssize);
@


1.6.16.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.6 1996/05/02 13:12:22 deraadt Exp $	*/
a51 2
#include <vm/vm.h>
#include <uvm/uvm_extern.h>
a65 2
	int size;

d84 2
a85 2
	size = p->kcountsize + p->fromssize + p->tossize;
	cp = (char *)uvm_km_zalloc(kernel_map, round_page(size));
d90 1
@


1.6.16.2
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
@


1.6.16.3
log
@Sync the SMP branch with 3.3
@
text
@d201 9
a209 3
 * from an interrupt context. Schedule an AST that will vector us to
 * trap() with a context in which copyin and copyout will work.
 * Trap will then call addupc_task().
d212 4
a215 1
addupc_intr(struct proc *p, u_long pc)
d217 4
a220 1
	struct uprof *prof;
d222 2
d225 2
a226 1
	if (pc < prof->pr_off || PC_TO_INDEX(pc, prof) >= prof->pr_size)
d229 6
a234 2
	prof->pr_addr = pc;
	need_proftick(p);
a236 1

d242 4
a245 1
addupc_task(struct proc *p, u_long pc, u_int ticks)
d247 3
a249 3
	struct uprof *prof;
	caddr_t addr;
	u_int i;
@


1.6.16.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.6.16.3 2003/03/28 00:41:27 niklas Exp $	*/
d224 1
a224 1
addupc_task(struct proc *p, u_long pc, u_int nticks)
d232 1
a232 1
	if ((p->p_flag & P_PROFIL) == 0 || nticks == 0)
d242 1
a242 1
		v += nticks;
@


1.6.16.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prof.c,v 1.6.16.4 2003/05/13 19:21:28 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.16.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d157 3
a159 3
		syscallarg(caddr_t) samples;
		syscallarg(size_t) size;
		syscallarg(u_long) offset;
@


1.5
log
@First argument to profil(2) should be `char *', not `caddr_t'.
@
text
@d2 1
a2 1
/*	$NetBSD: subr_prof.c,v 1.11 1996/03/17 02:44:40 pk Exp $	*/
a43 1
#include <sys/cpu.h>
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d160 1
a160 1
		syscallarg(caddr_t) samples;
d180 1
a180 1
	upp->pr_base = SCARG(uap, samples);
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: subr_prof.c,v 1.10 1996/02/09 19:00:06 christos Exp $	*/
d74 1
a74 1
	printf("Profiling kernel, textsize=%d [%p..%p]\n",
d102 2
a103 1
sysctl_doprof(name, namelen, oldp, oldlenp, newp, newlen, p)
@


1.2
log
@profil() args have changed type..
@
text
@d1 2
a2 1
/*	$NetBSD: subr_prof.c,v 1.8 1995/11/22 23:07:26 cgd Exp $	*/
d44 1
a44 1

d61 2
d152 1
d160 2
a161 2
		syscallarg(size_t) size;
		syscallarg(u_long) offset;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: subr_prof.c,v 1.7 1995/10/07 06:28:33 mycroft Exp $	*/
d156 2
a157 2
		syscallarg(u_int) size;
		syscallarg(u_int) offset;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
