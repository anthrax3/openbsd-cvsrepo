head	1.17;
access;
symbols
	OPENBSD_4_9:1.16.0.14
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.12
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.8
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.10
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.6
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.15.0.8
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.6
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.4
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.8.0.6
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.10
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.8
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.6
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.17
date	2011.04.02.16.27.29;	author thib;	state dead;
branches;
next	1.16;

1.16
date	2007.12.12.16.24.49;	author thib;	state Exp;
branches;
next	1.15;

1.15
date	2006.01.02.05.05.11;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.22.21.07.23;	author pedro;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.28.07;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.01.21.41.35;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2003.05.01.21.13.05;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.23.47.05;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.02.02.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.26.17.34.18;	author art;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	2001.02.26.17.12.27;	author art;	state Exp;
branches;
next	1.6;

1.6
date	99.03.03.20.58.27;	author deraadt;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	99.03.03.14.23.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.12.05.16.50.41;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	96.04.19.16.09.13;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.03.26.15.09.30;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.48;	author deraadt;	state Exp;
branches;
next	;

1.6.6.1
date	2001.05.14.22.32.47;	author niklas;	state Exp;
branches;
next	1.6.6.2;

1.6.6.2
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.6.6.3;

1.6.6.3
date	2003.05.13.19.21.29;	author ho;	state Exp;
branches;
next	1.6.6.4;

1.6.6.4
date	2003.06.07.11.03.41;	author ho;	state Exp;
branches;
next	;

1.8.6.1
date	2002.06.11.03.29.41;	author art;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.17
log
@remove the vnode_if.* files, as they are now totally
obsolete.

the move to vfs_vops.c is here to stay, so they are
pointless.
@
text
@#!/bin/sh -
copyright="\
/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
"
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.16 2007/12/12 16:24:49 thib Exp $'
# SCRIPT_ID='$NetBSD: vnode_if.sh,v 1.9 1996/02/29 20:58:22 cgd Exp $'

# Script to produce VFS front-end sugar.
#
# usage: vnode_if.sh srcfile
#	(where srcfile is currently /sys/kern/vnode_if.src)
#

if [ $# -ne 1 ] ; then
	echo 'usage: vnode_if.sh srcfile'
	exit 1
fi

# Name and revision of the source file.
src=$1
SRC_ID=`head -1 $src | sed -e 's/.*\$\(.*\)\$.*/\1/'`

# Names of the created files.
out_c=vnode_if.c
out_h=../sys/vnode_if.h

# Awk program (must support nawk extensions)
# Use "awk" at Berkeley, "nawk" or "gawk" elsewhere.
awk=${AWK:-awk}

# Does this awk have a "toupper" function? (i.e. is it GNU awk)
isgawk=`$awk 'BEGIN { print toupper("true"); exit; }' 2>/dev/null`

# If this awk does not define "toupper" then define our own.
if [ "$isgawk" = TRUE ] ; then
	# GNU awk provides it.
	toupper=
else
	# Provide our own toupper()
	toupper='
function toupper(str) {
	_toupper_cmd = "echo "str" |tr a-z A-Z"
	_toupper_cmd | getline _toupper_str;
	close(_toupper_cmd);
	return _toupper_str;
}'
fi

#
# This is the common part of all awk programs that read $src
# This parses the input for one function into the arrays:
#	argdir, argtype, argname, willrele
# and calls "doit()" to generate output for the function.
#
# Input to this parser is pre-processed slightly by sed
# so this awk parser doesn't have to work so hard.  The
# changes done by the sed pre-processing step are:
#	insert a space beween * and pointer name
#	replace semicolons with spaces
#
sed_prep='s:\*\([^\*/]\):\* \1:g
s/;/ /'
awk_parser='
# Comment line
/^#/	{ next; }
# First line of description
/^vop_/	{
	name=$1;
	argc=0;
	next;
}
# Last line of description
/^}/	{
	doit();
	next;
}
# Middle lines of description
{
	argdir[argc] = $1; i=2;
	if ($2 == "WILLRELE" ||
	    $3 == "WILLRELE") {
		willrele[argc] = 1;
		i++;
	} else if ($2 == "WILLUNLOCK" ||
	    $3 == "WILLUNLOCK") {
		willrele[argc] = 2;
		i++;
	} else if ($2 == "WILLPUT" ||
	    $3 == "WILLPUT") {
		willrele[argc] = 3;
		i++;
	} else
		willrele[argc] = 0;

	if ($2 == "SHOULDBELOCKED") {
	   shouldbelocked[argc] = 1;
	   i++;
	} else
	   shouldbelocked[argc] = 0;

	argtype[argc] = $i; i++;
	while (i < NF) {
		argtype[argc] = argtype[argc]" "$i;
		i++;
	}
	argname[argc] = $i;
	argc++;
	next;
}
'

# This is put after the copyright on each generated file.
warning="\
/*
 * Warning: This file is generated automatically.
 * (Modifications made here may easily be lost!)
 *
 * Created from the file:
 *	${SRC_ID}
 * by the script:
 *	${SCRIPT_ID}
 */
" 

# This is to satisfy McKusick (get rid of evil spaces 8^)
anal_retentive='s:\([^/]\*\) :\1:g'

#
# Redirect stdout to the H file.
#
echo "$0: Creating $out_h" 1>&2
exec > $out_h

# Begin stuff
echo -n "$warning" | sed -e 's/\$//g'
echo ""
echo -n "$copyright"
echo '
extern struct vnodeop_desc vop_default_desc;
'

echo '#include "systm.h"'

# Body stuff
# This awk program needs toupper() so define it if necessary.
sed -e "$sed_prep" $src | $awk "$toupper"'
function doit() {
	# Declare arg struct, descriptor.
	printf("\nstruct %s_args {\n", name);
	printf("\tstruct vnodeop_desc * a_desc;\n");
	for (i=0; i<argc; i++) {
		printf("\t%s a_%s;\n", argtype[i], argname[i]);
	}
	printf("};\n");
	printf("extern struct vnodeop_desc %s_desc;\n", name);
	# Prototype it.
	protoarg = sprintf("int %s(", toupper(name));
	protolen = length(protoarg);
	printf("%s", protoarg);
	for (i=0; i<argc; i++) {
		protoarg = sprintf("%s", argtype[i]);
		if (i < (argc-1)) protoarg = (protoarg ", ");
		arglen = length(protoarg);
		if ((protolen + arglen) > 77) {
			protoarg = ("\n    " protoarg);
			arglen += 4;
			protolen = 0;
		}
		printf("%s", protoarg);
		protolen += arglen;
	}
	printf(");\n");
}
BEGIN	{
	arg0special="";
}
END	{
	printf("\n/* Special cases: */\n#include <sys/buf.h>\n");
	argc=1;
	argtype[0]="struct buf *";
	argname[0]="bp";
	shouldbelocked[0] = 0;
	arg0special="->b_vp";
	name="vop_strategy";
	doit();
	name="vop_bwrite";
	doit();
}
'"$awk_parser" | sed -e "$anal_retentive"

# End stuff
echo '
/* End of special cases. */'


#
# Redirect stdout to the C file.
#
echo "$0: Creating $out_c" 1>&2
exec > $out_c

# Begin stuff
echo -n "$warning" | sed -e 's/\$//g'
echo ""
echo -n "$copyright"
echo '
#include <sys/param.h>
#include <sys/mount.h>
#include <sys/vnode.h>

struct vnodeop_desc vop_default_desc = {
	0,
	"default",
	0,
};
'

# Body stuff
sed -e "$sed_prep" $src | $awk '
function doit() {
	# Define F_desc
	printf("struct vnodeop_desc %s_desc = {\n", name);
	# offset
	printf ("\t0,\n");
	# printable name
	printf ("\t\"%s\",\n", name);
	# flags
	printf("\t0");
	vpnum = 0;
	for (i=0; i<argc; i++) {
		if (willrele[i]) {
			if (willrele[i] == 2) {
				word = "UNLOCK";
			} else if (willrele[i] == 3) {
				word = "PUT";
			} else {
				word = "RELE";
			}
			if (argdir[i] ~ /OUT/) {
				printf(" | VDESC_VPP_WILL%s", word);
			} else {
				printf(" | VDESC_VP%s_WILL%s", vpnum, word);
			};
			vpnum++;
		}
	}
	printf (",\n};\n");

	# Define inline function.
	printf("\nint %s(", toupper(name));
	desclen = 5 + length(name);
	for (i=0; i<argc; i++) {
		arglen = length(argtype[i]) + length(argname[i]);
		
		if (arglen + desclen > 77) {
			printf("\n    ");
			arglen += 4;
			desclen = 0;
		}
		printf("%s %s", argtype[i], argname[i]);
		if (i < (argc-1)) {
			printf(", ");
			desclen += 2;
		}
		desclen += arglen;
	}
	printf(")\n");
	printf("{\n\tstruct %s_args a;\n", name);
	printf("\ta.a_desc = VDESC(%s);\n", name);
	for (i=0; i<argc; i++) {
		printf("\ta.a_%s = %s;\n", argname[i], argname[i]);
		if (shouldbelocked[i]) {
			printf ("#ifdef VFSDEBUG\n");
			printf ("\tif ((%s->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(%s))\n", argname[i], argname[i]);
			printf ("\t\tpanic(\"%s: %s\");\n", name, argname[i]);
			printf ("#endif\n");
		}
	}
	printf("\treturn (VCALL(%s%s, VOFFSET(%s), &a));\n}\n",
		argname[0], arg0special, name);

}
BEGIN	{
	arg0special="";
}
END	{
	printf("\n/* Special cases: */\n");
	argc=1;
	argtype[0]="struct buf *";
	argdir[0]="IN";
	argname[0]="bp";
	shouldbelocked[0] = 0;
	arg0special="->b_vp";
	willrele[0]=0;
	name="vop_strategy";
	doit();
	name="vop_bwrite";
	doit();
}
'"$awk_parser" | sed -e "$anal_retentive"

# End stuff
echo '
/* End of special cases. */'

# Add the vfs_op_descs array to the C file.
# Begin stuff
echo '
struct vnodeop_desc *vfs_op_descs[] = {
	&vop_default_desc,	/* MUST BE FIRST */
	&vop_strategy_desc,	/* XXX: SPECIAL CASE */
	&vop_bwrite_desc,	/* XXX: SPECIAL CASE */
'

# Body stuff
sed -e "$sed_prep" $src | $awk '
function doit() {
	printf("\t&%s_desc,\n", name);
}
'"$awk_parser"

# End stuff
echo '	NULL
};
'

exit 0

# Local Variables:
# tab-width: 4
# End:
@


1.16
log
@Garbage collect a few members of the vnodeop_desc structure,
they where used to keep "offsets" of arguments too the VOP's
for use by bypass routines, these have been unused now for
quite some time;

Tested on sparc64/amd64 (shaves about 1k of GENERIC).

ok beck@@
@
text
@d32 1
a32 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.15 2006/01/02 05:05:11 jsg Exp $'
@


1.15
log
@Make this generate code with ansi function declarations.
No binary change in compiled version of generated file.
@
text
@d32 1
a32 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.14 2005/05/22 21:07:23 pedro Exp $'
a241 6
	NULL,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a246 12
function do_offset(typematch) {
	for (i=0; i<argc; i++) {
		if (argtype[i] == typematch) {
			printf("\tVOPARG_OFFSETOF(struct %s_args, a_%s),\n",
				name, argname[i]);
			return i;
		};
	};
	print "\tVDESC_NO_OFFSET,";
	return -1;
}

a247 10
	# Define offsets array
	printf("\nint %s_vp_offsets[] = {\n", name);
	for (i=0; i<argc; i++) {
		if (argtype[i] == "struct vnode *") {
			printf ("\tVOPARG_OFFSETOF(struct %s_args,a_%s),\n",
				name, argname[i]);
		}
	}
	print "\tVDESC_NO_OFFSET";
	print "};";
d274 1
a274 13
	print ",";
	# vp offsets
	printf ("\t%s_vp_offsets,\n", name);
	# vpp (if any)
	do_offset("struct vnode **");
	# cred (if any)
	do_offset("struct ucred *");
	# proc (if any)
	do_offset("struct proc *");
	# componentname
	do_offset("struct componentname *");
	# transport layer information
	printf ("\tNULL,\n};\n");
@


1.14
log
@output code for incoming VFSDEBUG option
@
text
@d32 1
a32 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.13 2003/06/02 23:28:07 millert Exp $'
d318 1
d320 13
a332 2
		printf("%s", argname[i]);
		if (i < (argc-1)) printf(", ");
a334 3
	for (i=0; i<argc; i++) {
		printf("\t%s %s;\n", argtype[i], argname[i]);
	}
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d32 1
a32 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.12 2003/05/01 21:41:35 tedu Exp $'
d331 1
a331 1
			printf ("#ifdef LOCKDEBUG\n");
@


1.12
log
@knf
@
text
@d15 1
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d32 1
a32 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.11 2003/05/01 21:13:05 tedu Exp $'
@


1.11
log
@several related changes:
vfs_subr.c:
	add a missing simple_lock_init for vnode interlock
	try to avoid reclaiming locked or layered vnodes
	initialize vnlock pointer to NULL
	remove old code to free vnlock, never used
	lockinit the new vnode lock
vfs_syscalls.c:
	support for VLAYER flag
vnode_if.sh:
	support for splitting VDESC flags
vnode_if.src:
	split VDESC flags
	WILLPUT is the combination of WILLRELE and WILLUNLOCK
	most uses for WILLRELE become WILLPUT
vnode.h:
	add v_lock to struct vnode
	add VLAYER flag
	update for new VDESC flags
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.10 2002/03/14 23:47:05 millert Exp $'
d126 1
a126 2

    if ($2 == "SHOULDBELOCKED") {
@


1.10
log
@Don't put a space between a function name and its args in the prototype.
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.9 2002/03/14 02:02:56 millert Exp $'
d115 8
d126 1
d292 7
d300 1
a300 1
				printf(" | VDESC_VPP_WILLRELE");
d302 1
a302 1
				printf(" | VDESC_VP%s_WILLRELE", vpnum);
@


1.9
log
@generate std ANSI protos, not __P ones
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.8 2001/02/26 17:34:18 art Exp $'
d180 1
a180 1
	protoarg = sprintf("int %s (", toupper(name));
@


1.8
log
@Since VLOCKSWORK is only set when LOCKDEBUG is defined,
ifdef the VOP_ISLOCKED code with LOCKDEBUG instead of DIAGNOSTIC.
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.7 2001/02/26 17:12:27 art Exp $'
d180 1
a180 1
	protoarg = sprintf("int %s __P((", toupper(name));
d195 1
a195 1
	printf("));\n");
@


1.8.6.1
log
@Sync UBC branch to -current
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.8 2001/02/26 17:34:18 art Exp $'
d180 1
a180 1
	protoarg = sprintf("int %s(", toupper(name));
d195 1
a195 1
	printf(");\n");
@


1.8.6.2
log
@sync
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD$'
a114 8
	} else if ($2 == "WILLUNLOCK" ||
	    $3 == "WILLUNLOCK") {
		willrele[argc] = 2;
		i++;
	} else if ($2 == "WILLPUT" ||
	    $3 == "WILLPUT") {
		willrele[argc] = 3;
		i++;
d118 1
a118 1
	if ($2 == "SHOULDBELOCKED") {
a282 7
			if (willrele[i] == 2) {
				word = "UNLOCK";
			} else if (willrele[i] == 3) {
				word = "PUT";
			} else {
				word = "RELE";
			}
d284 1
a284 1
				printf(" | VDESC_VPP_WILL%s", word);
d286 1
a286 1
				printf(" | VDESC_VP%s_WILL%s", vpnum, word);
@


1.7
log
@Indentation nit in the generated code.
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.6 1999/03/03 20:58:27 deraadt Exp $'
d320 1
a320 1
			printf ("#ifdef DIAGNOSTIC\n");
@


1.6
log
@not using inline functions saves about 120K
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.5 1999/03/03 14:23:19 deraadt Exp $'
d320 3
a322 2
		    printf ("#ifdef DIAGNOSTIC\n");
			printf ("\tif ((%s->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(%s)) panic(\"%s: %s\");\n", argname[i], argname[i], name, argname[i]);
@


1.6.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.8 2001/02/26 17:34:18 art Exp $'
d320 2
a321 3
			printf ("#ifdef LOCKDEBUG\n");
			printf ("\tif ((%s->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(%s))\n", argname[i], argname[i]);
			printf ("\t\tpanic(\"%s: %s\");\n", name, argname[i]);
@


1.6.6.2
log
@Merge in -current from about a week ago
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD$'
d180 1
a180 1
	protoarg = sprintf("int %s(", toupper(name));
d195 1
a195 1
	printf(");\n");
@


1.6.6.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.6.6.2 2002/03/28 11:43:04 niklas Exp $'
a114 8
	} else if ($2 == "WILLUNLOCK" ||
	    $3 == "WILLUNLOCK") {
		willrele[argc] = 2;
		i++;
	} else if ($2 == "WILLPUT" ||
	    $3 == "WILLPUT") {
		willrele[argc] = 3;
		i++;
d118 1
a118 1
	if ($2 == "SHOULDBELOCKED") {
a282 7
			if (willrele[i] == 2) {
				word = "UNLOCK";
			} else if (willrele[i] == 3) {
				word = "PUT";
			} else {
				word = "RELE";
			}
d284 1
a284 1
				printf(" | VDESC_VPP_WILL%s", word);
d286 1
a286 1
				printf(" | VDESC_VP%s_WILL%s", vpnum, word);
@


1.6.6.4
log
@Sync SMP branch to -current
@
text
@d15 5
a19 1
 * 3. Neither the name of the University nor the names of its contributors
d36 1
a36 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.6.6.3 2003/05/13 19:21:29 ho Exp $'
@


1.5
log
@do not inline. this needs cleanup.  from art
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.4 1998/12/05 16:50:41 csapuntz Exp $'
a166 13
echo '#ifdef VOP_NOT_INLINE'
echo '#define STATIC_INLINE'
echo '#else'
echo '#define STATIC_INLINE static __inline'
echo '#endif'

echo '#ifdef INTERNAL_VOP_NOT_INLINE'
echo '#define FUNC_STATIC_INLINE'
echo '#else'
echo '#undef FUNC_STATIC_INLINE'
echo '#define FUNC_STATIC_INLINE static __inline'
echo '#endif'

d180 1
a180 1
	protoarg = sprintf("STATIC_INLINE int %s __P((", toupper(name));
a195 24
	printf("#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)\n");
	# Define inline function.
	printf("FUNC_STATIC_INLINE int %s(", toupper(name));
	for (i=0; i<argc; i++) {
		printf("%s", argname[i]);
		if (i < (argc-1)) printf(", ");
	}
	printf(")\n");
	for (i=0; i<argc; i++) {
		printf("\t%s %s;\n", argtype[i], argname[i]);
	}
	printf("{\n\tstruct %s_args a;\n", name);
	printf("\ta.a_desc = VDESC(%s);\n", name);
	for (i=0; i<argc; i++) {
		printf("\ta.a_%s = %s;\n", argname[i], argname[i]);
		if (shouldbelocked[i]) {
		    printf ("#ifdef DIAGNOSTIC\n");
			printf ("\tif ((%s->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(%s)) panic(\"%s: %s\");\n", argname[i], argname[i], name, argname[i]);
			printf ("#endif\n");
		}
	}
	printf("\treturn (VCALL(%s%s, VOFFSET(%s), &a));\n}\n",
		argname[0], arg0special, name);
    printf("#endif /* !VOP_NOT_INLINE */");
a229 1
#define INTERNAL_VOP_NOT_INLINE
d304 27
d335 1
a336 1
	argtype[0]="struct buf *";
d338 2
@


1.4
log
@

Framework for generating automatic test code for locking discipline
in DIAGNOSTIC mode.

Added documentation to vfs_subr.c on locking needs of a couple calls.

Improvements to the vinvalbuf patch. We need to start over after we
let our pants down.
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD: vnode_if.sh,v 1.3 1996/04/19 16:09:13 niklas Exp $'
d166 14
d193 1
a193 1
	protoarg = sprintf("static __inline int %s __P((", toupper(name));
d209 1
d211 1
a211 1
	printf("static __inline int %s(", toupper(name));
d232 1
d267 1
@


1.3
log
@NetBSD 960317 merge
@
text
@d36 1
a36 1
SCRIPT_ID='$OpenBSD$'
d111 2
a112 1
	if ($2 == "WILLRELE") {
d117 7
d165 1
d209 5
d226 1
@


1.2
log
@From NetBSD: vnode_if.[ch] made machine independent.
very usefull (for <sys/vnode.h> inclusion).
from the other side this is really machine independent ...
tested w/ i386, but should not cause errors w/ other arch's.
pls, test it (don't forget to reconfig kernel ;)
@
text
@d36 2
a37 1
SCRIPT_ID='$NetBSD: vnode_if.sh,v 1.9 1996/02/29 20:58:22 cgd Exp $'
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
copyright='
d35 2
a36 2
'
SCRIPT_ID='$NetBSD: vnode_if.sh,v 1.8 1995/03/10 04:13:52 chopps Exp $'
d49 1
a49 1
# Name of the source file.
d51 1
d55 1
a55 1
out_h=vnode_if.h
d127 1
a127 1
warning="
d132 3
a134 1
 * Created by the script:
d137 1
a137 1
"
d149 3
a151 2
echo "$copyright"
echo "$warning"
d231 3
a233 2
echo "$copyright"
echo "$warning"
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
