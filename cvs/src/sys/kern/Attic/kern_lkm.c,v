head	1.50;
access;
symbols
	OPENBSD_5_6:1.48.0.4
	OPENBSD_5_6_BASE:1.48
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.46.0.16
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.14
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.46.0.12
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.10
	OPENBSD_5_0:1.46.0.8
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.46.0.6
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.46.0.4
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.45.0.10
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.6
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.45.0.4
	OPENBSD_4_4_BASE:1.45
	OPENBSD_4_3:1.45.0.2
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.43.0.4
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.43.0.2
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.42.0.4
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.41.0.8
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.41.0.6
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.41.0.4
	OPENBSD_3_6_BASE:1.41
	SMP_SYNC_A:1.41
	SMP_SYNC_B:1.41
	OPENBSD_3_5:1.41.0.2
	OPENBSD_3_5_BASE:1.41
	OPENBSD_3_4:1.40.0.2
	OPENBSD_3_4_BASE:1.40
	UBC_SYNC_A:1.38
	OPENBSD_3_3:1.37.0.6
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.37.0.4
	OPENBSD_3_2_BASE:1.37
	OPENBSD_3_1:1.37.0.2
	OPENBSD_3_1_BASE:1.37
	UBC_SYNC_B:1.37
	UBC:1.34.0.2
	UBC_BASE:1.34
	OPENBSD_3_0:1.33.0.2
	OPENBSD_3_0_BASE:1.33
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_8:1.26.0.6
	OPENBSD_2_8_BASE:1.26
	OPENBSD_2_7:1.26.0.4
	OPENBSD_2_7_BASE:1.26
	SMP:1.26.0.2
	SMP_BASE:1.26
	kame_19991208:1.25
	OPENBSD_2_6:1.25.0.4
	OPENBSD_2_6_BASE:1.25
	OPENBSD_2_5:1.25.0.2
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.23.0.4
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.23.0.2
	OPENBSD_2_3_BASE:1.23
	OPENBSD_2_2:1.20.0.2
	OPENBSD_2_2_BASE:1.20
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2014.10.09.04.05.04;	author tedu;	state dead;
branches;
next	1.49;
commitid	0n74lRqjdhzqrMTv;

1.49
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.48;
commitid	uzzBR7hz9ncd4O6G;

1.48
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.47;
commitid	QlVV51SZgNFxsXxC;

1.47
date	2014.01.21.01.48.44;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.45;

1.45
date	2007.11.03.22.23.35;	author mikeb;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.29.14.12.19;	author chl;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.15.17.25.40;	author jmc;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.28.00.14.28;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2004.03.03.06.26.22;	author tedu;	state Exp;
branches;
next	1.40;

1.40
date	2003.08.23.20.27.30;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.29.07.14.11;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.09.19.05.17;	author ericj;	state Exp;
branches;
next	1.35;

1.35
date	2002.01.07.19.23.32;	author ericj;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2001.09.19.20.50.58;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.27.04.49.42;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.16.12.52.58;	author ho;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.05.20.57.00;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.10.10.42.35;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.06.16.38.13;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2000.01.02.06.28.06;	author assar;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	99.02.26.04.54.00;	author art;	state Exp;
branches;
next	1.24;

1.24
date	99.02.19.17.17.49;	author art;	state Exp;
branches;
next	1.23;

1.23
date	98.03.18.22.47.27;	author art;	state Exp;
branches;
next	1.22;

1.22
date	98.03.17.05.30.18;	author art;	state Exp;
branches;
next	1.21;

1.21
date	97.11.06.05.58.17;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	97.10.06.20.19.54;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.10.06.15.12.19;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	97.09.24.18.16.22;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.07.23.23.09.49;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	97.07.20.21.24.32;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.05.29.22.42.00;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.02.06.13.09.13;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.10.14.13.01.33;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	96.10.02.20.22.13;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.09.27.14.41.16;	author briggs;	state Exp;
branches;
next	1.10;

1.10
date	96.09.16.07.56.19;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	96.09.09.14.29.26;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.09.04.22.24.23;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.08.29.15.17.37;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.02.06.51.56;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.06.21.17.03.26;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.06.21.11.33.30;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.27.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.19.47;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches;
next	;

1.26.2.1
date	2001.05.14.22.32.40;	author niklas;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2001.07.04.10.48.21;	author niklas;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.26.2.4;

1.26.2.4
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.26.2.5;

1.26.2.5
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.26.2.6;

1.26.2.6
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.26.2.7;

1.26.2.7
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.26.2.8;

1.26.2.8
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.26.2.9;

1.26.2.9
date	2004.06.05.23.13.01;	author niklas;	state Exp;
branches;
next	;

1.34.2.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2003.05.19.22.31.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.50
log
@remove lkm files
@
text
@/*	$OpenBSD: kern_lkm.c,v 1.49 2014/09/14 14:17:25 jsg Exp $	*/
/*	$NetBSD: kern_lkm.c,v 1.31 1996/03/31 21:40:27 christos Exp $	*/

/*
 * Copyright (c) 1994 Christopher G. Demetriou
 * Copyright (c) 1992 Terrence R. Lambert.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Terrence R. Lambert.
 * 4. The name Terrence R. Lambert may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TERRENCE R. LAMBERT ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE TERRENCE R. LAMBERT BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * XXX it's not really safe to unload *any* of the types which are
 * currently loadable; e.g. you could unload a syscall which was being
 * blocked in, etc.  In the long term, a solution should be come up
 * with, but "not right now." -- cgd
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/exec.h>
#include <sys/syscallargs.h>
#include <sys/conf.h>

#include <sys/lkm.h>
#include <sys/syscall.h>

#include <uvm/uvm_extern.h>

#ifdef DDB
#include <machine/db_machdep.h>
#include <ddb/db_sym.h>
#endif

/* flags */
#define	LKM_ALLOC		0x01
#define	LKM_WANT		0x02
#define	LKM_INIT		0x04

#define	LKMS_IDLE		0x00
#define	LKMS_RESERVED		0x01
#define	LKMS_LOADING		0x02
#define	LKMS_LOADING_SYMS	0x03
#define	LKMS_LOADED		0x04
#define	LKMS_UNLOADING		0x08

struct vm_map *lkm_map = NULL;

static int lkm_v = 0;
static int lkm_state = LKMS_IDLE;

static TAILQ_HEAD(lkmods, lkm_table) lkmods;	/* table of loaded modules */
static struct lkm_table	*curp;		/* global for in-progress ops */

static struct lkm_table *lkmalloc(void);
static void lkmfree(struct lkm_table *);
static struct lkm_table *lkmlookup(int, char *, int *);
static void lkmunreserve(void);
static int _lkm_syscall(struct lkm_table *, int);
static int _lkm_vfs(struct lkm_table *, int);
static int _lkm_dev(struct lkm_table *, int);
static int _lkm_exec(struct lkm_table *, int);

void lkminit(void);
int lkmexists(struct lkm_table *);

void init_exec(void);

void
lkminit(void)
{

	/*
	 * If machine-dependent code hasn't initialized the lkm_map
	 * then just use kernel_map.
	 */
	if (lkm_map == NULL)
		lkm_map = kernel_map;
	TAILQ_INIT(&lkmods);
	lkm_v |= LKM_INIT;
}

/*ARGSUSED*/
int
lkmopen(dev_t dev, int flag, int devtype, struct proc *p)
{
	int error;

	if (minor(dev) != 0)
		return (ENXIO);

	if (!(lkm_v & LKM_INIT))
		lkminit();

	/*
	 * Use of the loadable kernel module device must be exclusive; we
	 * may try to remove this restriction later, but it's really no
	 * hardship.
	 */
	while (lkm_v & LKM_ALLOC) {
		if (flag & FNONBLOCK)		/* don't hang */
			return (EBUSY);
		lkm_v |= LKM_WANT;
		/*
		 * Sleep pending unlock; we use tsleep() to allow
		 * an alarm out of the open.
		 */
		error = tsleep(&lkm_v, TTIPRI|PCATCH, "lkmopn", 0);
		if (error)
			return (error);	/* leave LKM_WANT set -- no problem */
	}
	lkm_v |= LKM_ALLOC;

	return (0);		/* pseudo-device open */
}

/*
 * Allocates new LKM table entry, fills module id, inserts into the list.
 * Returns NULL on failure.
 *
 */
static struct lkm_table *
lkmalloc(void)
{
	struct lkm_table *p, *ret = NULL;
	int id = 0;

	ret = malloc(sizeof(*ret), M_DEVBUF, M_WAITOK);
	ret->refcnt = ret->depcnt = 0;
	ret->sym_id = -1;
	/* 
	 * walk the list finding the first free id. as long as the list is
	 * kept sorted this is not too inefficient, which is why we insert in
	 * order below.
 	 */
	TAILQ_FOREACH(p, &lkmods, list) {
		if (id == p->id)
			id++;
		else
			break;
	}
	ret->id = id;
	if (p == NULL) /* either first or last entry */
		TAILQ_INSERT_TAIL(&lkmods, ret, list);
	else 
		TAILQ_INSERT_BEFORE(p, ret, list);

	return ret;
}

/*
 * Frees the slot, decreases the number of modules.
 */
static void
lkmfree(struct lkm_table *p)
{

	TAILQ_REMOVE(&lkmods, p, list);
	free(p, M_DEVBUF, 0);
	curp = NULL;
}

struct lkm_table *
lkm_list(struct lkm_table *p)
{

	if (p == NULL)
		p = TAILQ_FIRST(&lkmods);
	else
		p = TAILQ_NEXT(p, list);

	return (p);
}

static struct lkm_table *
lkmlookup(int i, char *name, int *error)
{
	struct lkm_table *p = NULL;
	char istr[MAXLKMNAME];
	
	/* 
 	 * p being NULL here implies the list is empty, so any lookup is
 	 * invalid (name based or otherwise). Since the list of modules is
 	 * kept sorted by id, lowest to highest, the id of the last entry 
 	 * will be the highest in use. 
	 */ 
	p = TAILQ_LAST(&lkmods, lkmods);
	if (p == NULL || i > p->id) {
		*error = EINVAL;
		return NULL;
	}

	if (i < 0) {		/* unload by name */
		/*
		 * Copy name and lookup id from all loaded
		 * modules.  May fail.
		 */
	 	*error = copyinstr(name, istr, MAXLKMNAME-1, NULL);
		if (*error)
			return NULL;
		istr[MAXLKMNAME-1] = '\0';

		TAILQ_FOREACH(p, &lkmods, list) {
			if (!strcmp(istr, p->private.lkm_any->lkm_name))
				break;
		}
	} else 
		TAILQ_FOREACH(p, &lkmods, list) 
			if (i == p->id)
				break;
		
	if (p == NULL)
		*error = ENOENT;

	return p;
}

/*
 * Unreserve the memory associated with the current loaded module; done on
 * a coerced close of the lkm device (close on premature exit of modload)
 * or explicitly by modload as a result of a link failure.
 */
static void
lkmunreserve(void)
{

	if (lkm_state == LKMS_IDLE)
		return;

#ifdef DDB
	if (curp && curp->sym_id != -1)
		db_del_symbol_table(curp->private.lkm_any->lkm_name);
#endif

	if (curp && curp->syms) {
		uvm_km_free(lkm_map, (vaddr_t)curp->syms, curp->sym_size);
		curp->syms = NULL;
	}

	/*
	 * Actually unreserve the memory
	 */
	if (curp && curp->area) {
		uvm_km_free(lkm_map, curp->area, curp->size);
		curp->area = 0;
	}
	lkm_state = LKMS_IDLE;
}

int
lkmclose(dev_t dev, int flag, int mode, struct proc *p)
{

	if (minor(dev) != 0)
		return (ENXIO);

	if (!(lkm_v & LKM_ALLOC))
		return (EBADF);

	/* do this before waking the herd... */
	if (curp != NULL && !curp->refcnt) {
		/*
		 * If we close before setting used, we have aborted
		 * by way of error or by way of close-on-exit from
		 * a premature exit of "modload".
		 */
		lkmunreserve();
		lkmfree(curp);
	}
	lkm_v &= ~LKM_ALLOC;
	wakeup(&lkm_v);	/* thundering herd "problem" here */

	return (0);
}

/*ARGSUSED*/
int
lkmioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	int error = 0;

	if (securelevel > 0) {
		switch (cmd) {
		case LMSTAT:
			break;
		default:
			return (EPERM);
		}
	}

	if (!(flags & FWRITE)) {
		switch (cmd) {
		case LMSTAT:
			break;
		default:
			return (EACCES);
		}
	}

	switch (cmd) {
	case LMRESERV:
	case LMRESERV_O: {
		struct lmc_resrv *resrvp = (struct lmc_resrv *)data;

		if ((curp = lkmalloc()) == NULL) {
			error = ENOMEM;	
			break;
		}
		curp->ver = (cmd == LMRESERV) ? LKM_VERSION : LKM_OLDVERSION;
		resrvp->slot = curp->id;	/* return slot */

		/*
		 * Get memory for module
		 */
		curp->size = resrvp->size;
		curp->area = uvm_km_zalloc(lkm_map, curp->size);
		curp->offset = 0;
		resrvp->addr = curp->area;

		if (cmd == LMRESERV && resrvp->sym_size) {
			curp->sym_size = resrvp->sym_size;
			curp->sym_symsize = resrvp->sym_symsize;
			curp->syms = (caddr_t)uvm_km_zalloc(lkm_map,
							    curp->sym_size);
			curp->sym_offset = 0;
			resrvp->sym_addr = curp->syms;
		} else {
			curp->sym_size = 0;
			curp->syms = 0;
			curp->sym_offset = 0;
			if (cmd == LMRESERV)
				resrvp->sym_addr = 0;
		}
#ifdef LKM_DEBUG
		printf("LKM: LMRESERV (actual   = 0x%08lx)\n", curp->area);
		printf("LKM: LMRESERV (syms     = 0x%08x)\n", curp->syms);
		printf("LKM: LMRESERV (adjusted = 0x%08lx)\n",
			trunc_page(curp->area));
#endif	/* LKM_DEBUG */

		lkm_state = LKMS_RESERVED;
		break;
	}

	case LMLOADBUF: {
		struct lmc_loadbuf *loadbufp = (struct lmc_loadbuf *)data;

		if ((lkm_state != LKMS_RESERVED && lkm_state != LKMS_LOADING)
		    || loadbufp->cnt < 0
		    || loadbufp->cnt > MODIOBUF
		    || loadbufp->cnt > (curp->size - curp->offset)) {
			error = ENOMEM;
			break;
		}

		/* copy in buffer full of data */
		error = copyin(loadbufp->data, 
			(caddr_t)curp->area + curp->offset, loadbufp->cnt);
		if (error)
			break;

		if ((curp->offset + loadbufp->cnt) < curp->size)
			lkm_state = LKMS_LOADING;
		else
			lkm_state = LKMS_LOADING_SYMS;

		curp->offset += loadbufp->cnt;
		break;
	}

	case LMLOADSYMS: {
		struct lmc_loadbuf *loadbufp = (struct lmc_loadbuf *)data;

		if ((lkm_state != LKMS_LOADING &&
		    lkm_state != LKMS_LOADING_SYMS)
		    || loadbufp->cnt < 0
		    || loadbufp->cnt > MODIOBUF
		    || loadbufp->cnt > (curp->sym_size - curp->sym_offset)) {
			error = ENOMEM;
			break;
		}

		/* copy in buffer full of data*/
		error = copyin(loadbufp->data, curp->syms +
		    curp->sym_offset, loadbufp->cnt);
		if (error)
			break;

		if ((curp->sym_offset + loadbufp->cnt) < curp->sym_size)
			lkm_state = LKMS_LOADING_SYMS;
		else
			lkm_state = LKMS_LOADED;

		curp->sym_offset += loadbufp->cnt;
		break;
	}

	case LMUNRESRV:
		lkmunreserve();
		if (curp)
			lkmfree(curp);
		break;

	case LMREADY:
		switch (lkm_state) {
		case LKMS_LOADED:
			break;
		case LKMS_LOADING:
		case LKMS_LOADING_SYMS:
			if ((curp->size - curp->offset) > 0)
			    /* The remainder must be bss, so we clear it */
			    memset((caddr_t)curp->area + curp->offset, 0,
				  curp->size - curp->offset);
			break;
		default:
			return (ENXIO);
		}

		curp->entry = (int (*)(struct lkm_table *, int, int))
		    (*((long *) (data)));

#ifdef LKM_DEBUG
		printf("LKM: call entrypoint %x\n", curp->entry);
#endif /* LKM_DEBUG */

		/* call entry(load)... (assigns "private" portion) */
		error = (*(curp->entry))(curp, LKM_E_LOAD, curp->ver);
		if (error) {
			/*
			 * Module may refuse loading or may have a
			 * version mismatch...
			 */
			lkm_state = LKMS_UNLOADING;	/* for lkmunreserve */
			lkmunreserve();			/* free memory */
			lkmfree(curp);			/* free slot */
			break;
		}

#ifdef LKM_DEBUG
		printf("LKM: LMREADY, id=%d, dev=%d\n", curp->id,
		    curp->private.lkm_any->lkm_offset);
#endif	/* LKM_DEBUG */

#ifdef DDB
		if (curp->syms && curp->sym_offset >= curp->sym_size) {
			curp->sym_id = db_add_symbol_table(curp->syms,
			    curp->syms + curp->sym_symsize,
			    curp->private.lkm_any->lkm_name,
			    curp->syms);
			printf("DDB symbols added: %ld bytes\n",
			    curp->sym_symsize);
		}
#endif /* DDB */

		curp->refcnt++;
		lkm_state = LKMS_IDLE;
		break;

	case LMUNLOAD: {
		struct lmc_unload *unloadp = (struct lmc_unload *)data;

		curp = lkmlookup(unloadp->id, unloadp->name, &error);
		if (curp == NULL)
			break;

		/* call entry(unload) */
		if ((*(curp->entry))(curp, LKM_E_UNLOAD, curp->ver)) {
			error = EBUSY;
			break;
		}

		lkm_state = LKMS_UNLOADING;	/* non-idle for lkmunreserve */
		lkmunreserve();			/* free memory */
		lkmfree(curp);			/* free slot */
		break;
	}

	case LMSTAT: {
		struct lmc_stat *statp = (struct lmc_stat *)data;

		if ((curp = lkmlookup(statp->id, statp->name, &error)) == NULL)
			break;

		if ((error = (*curp->entry)(curp, LKM_E_STAT, curp->ver)))
			break;

		/*
		 * Copy out stat information for this module...
		 */
		statp->id	= curp->id;
		statp->offset	= curp->private.lkm_any->lkm_offset;
		statp->type	= curp->private.lkm_any->lkm_type;
		statp->area	= curp->area;
		statp->size	= curp->size / PAGE_SIZE;
		statp->private	= (unsigned long)curp->private.lkm_any;
		statp->ver	= curp->private.lkm_any->lkm_ver;
		copyoutstr(curp->private.lkm_any->lkm_name, 
			  statp->name, MAXLKMNAME, NULL);

		break;
	}

	default:
		error = ENODEV;
		break;
	}

	return (error);
}

/*
 * Acts like "nosys" but can be identified in sysent for dynamic call
 * number assignment for a limited number of calls.
 *
 * Place holder for system call slots reserved for loadable modules.
 */
int
sys_lkmnosys(struct proc *p, void *v, register_t *retval)
{

	return (sys_nosys(p, v, retval));
}

/*
 * Acts like "enodev", but can be identified in cdevsw and bdevsw for
 * dynamic driver major number assignment for a limited number of
 * drivers.
 *
 * Place holder for device switch slots reserved for loadable modules.
 */
int
lkmenodev(void)
{

	return (enodev());
}

/*
 * A placeholder function for load/unload/stat calls; simply returns zero.
 * Used where people don't want to specify a special function.
 */
int
lkm_nofunc(struct lkm_table *lkmtp, int cmd)
{

	return (0);
}

int
lkmexists(struct lkm_table *lkmtp)
{
	struct lkm_table *p;

	TAILQ_FOREACH(p, &lkmods, list) {
		if (!strcmp(lkmtp->private.lkm_any->lkm_name,
		     p->private.lkm_any->lkm_name) && p->refcnt)
			return (1);
	}
	return (0);
}

/*
 * For the loadable system call described by the structure pointed to
 * by lkmtp, load/unload/stat it depending on the cmd requested.
 */
static int
_lkm_syscall(struct lkm_table *lkmtp, int cmd)
{
	struct lkm_syscall *args = lkmtp->private.lkm_syscall;
	int i;
	int error = 0;

	switch (cmd) {
	case LKM_E_LOAD:
		/* don't load twice! */
		if (lkmexists(lkmtp))
			return (EEXIST);

		if ((i = args->lkm_offset) == -1) {	/* auto */
			/*
			 * Search the table looking for a slot...
			 */
			for (i = 0; i < SYS_MAXSYSCALL; i++)
				if (sysent[i].sy_call == sys_lkmnosys)
					break;		/* found it! */
			/* out of allocable slots? */
			if (i == SYS_MAXSYSCALL) {
				error = ENFILE;
				break;
			}
		} else {				/* assign */
			if (i < 0 || i >= SYS_MAXSYSCALL) {
				error = EINVAL;
				break;
			}
		}

		/* save old */
		bcopy(&sysent[i], &args->lkm_oldent, sizeof(struct sysent));

		/* replace with new */
		bcopy(args->lkm_sysent, &sysent[i], sizeof(struct sysent));

		/* done! */
		args->lkm_offset = i;	/* slot in sysent[] */

		break;

	case LKM_E_UNLOAD:
		/* current slot... */
		i = args->lkm_offset;

		/* replace current slot contents with old contents */
		bcopy(&args->lkm_oldent, &sysent[i], sizeof(struct sysent));

		break;

	case LKM_E_STAT:	/* no special handling... */
		break;
	}

	return (error);
}

/*
 * For the loadable virtual file system described by the structure pointed
 * to by lkmtp, load/unload/stat it depending on the cmd requested.
 */
static int
_lkm_vfs(struct lkm_table *lkmtp, int cmd)
{
	int error = 0;
	struct lkm_vfs *args = lkmtp->private.lkm_vfs;

	switch (cmd) {
	case LKM_E_LOAD:
		/* don't load twice! */
		if (lkmexists(lkmtp))
			return (EEXIST);
		error = vfs_register(args->lkm_vfsconf);
		break;

	case LKM_E_UNLOAD:
		error = vfs_unregister(args->lkm_vfsconf);
		break;

	case LKM_E_STAT:	/* no special handling... */
		break;
	}

	return (error);
}

/*
 * For the loadable device driver described by the structure pointed to
 * by lkmtp, load/unload/stat it depending on the cmd requested.
 */
static int
_lkm_dev(struct lkm_table *lkmtp, int cmd)
{
	struct lkm_dev *args = lkmtp->private.lkm_dev;
	int i;
	int error = 0;

	switch (cmd) {
	case LKM_E_LOAD:
		/* don't load twice! */
		if (lkmexists(lkmtp))
			return (EEXIST);

		switch (args->lkm_devtype) {
		case LM_DT_BLOCK:
			if ((i = args->lkm_offset) == -1) {	/* auto */
				/*
				 * Search the table looking for a slot...
				 */
				for (i = 0; i < nblkdev; i++)
					if (bdevsw[i].d_open == 
					    (dev_type_open((*))) lkmenodev)
						break;		/* found it! */
				/* out of allocable slots? */
				if (i == nblkdev) {
					error = ENFILE;
					break;
				}
			} else {				/* assign */
				if (i < 0 || i >= nblkdev) {
					error = EINVAL;
					break;
				}
			}

			/* save old */
			bcopy(&bdevsw[i], &args->lkm_olddev.bdev,
			    sizeof(struct bdevsw));

			/* replace with new */
			bcopy(args->lkm_dev.bdev, &bdevsw[i],
			    sizeof(struct bdevsw));

			/* done! */
			args->lkm_offset = i;	/* slot in bdevsw[] */
			break;

		case LM_DT_CHAR:
			if ((i = args->lkm_offset) == -1) {	/* auto */
				/*
				 * Search the table looking for a slot...
				 */
				for (i = 0; i < nchrdev; i++)
					if (cdevsw[i].d_open ==
					    (dev_type_open((*))) lkmenodev)
						break;		/* found it! */
				/* out of allocable slots? */
				if (i == nchrdev) {
					error = ENFILE;
					break;
				}
			} else {				/* assign */
				if (i < 0 || i >= nchrdev) {
					error = EINVAL;
					break;
				}
			}

			/* save old */
			bcopy(&cdevsw[i], &args->lkm_olddev.cdev,
			    sizeof(struct cdevsw));

			/* replace with new */
			bcopy(args->lkm_dev.cdev, &cdevsw[i],
			    sizeof(struct cdevsw));

			/* done! */
			args->lkm_offset = i;	/* slot in cdevsw[] */

			break;

		default:
			error = ENODEV;
			break;
		}
		break;

	case LKM_E_UNLOAD:
		/* current slot... */
		i = args->lkm_offset;

		switch (args->lkm_devtype) {
		case LM_DT_BLOCK:
			/* replace current slot contents with old contents */
			bcopy(&args->lkm_olddev.bdev, &bdevsw[i],
			    sizeof(struct bdevsw));
			break;

		case LM_DT_CHAR:
			/* replace current slot contents with old contents */
			bcopy(&args->lkm_olddev.cdev, &cdevsw[i],
			    sizeof(struct cdevsw));
			break;

		default:
			error = ENODEV;
			break;
		}
		break;

	case LKM_E_STAT:	/* no special handling... */
		break;
	}

	return (error);
}

/*
 * For the loadable execution class described by the structure pointed to
 * by lkmtp, load/unload/stat it depending on the cmd requested.
 */
static int
_lkm_exec(struct lkm_table *lkmtp, int cmd)
{
	struct lkm_exec *args = lkmtp->private.lkm_exec;
	int i;
	int error = 0;

	switch (cmd) {
	case LKM_E_LOAD:
		/* don't load twice! */
		if (lkmexists(lkmtp))
			return (EEXIST);

		if ((i = args->lkm_offset) == -1) {	/* auto */
			/*
			 * Search the table looking for a slot...
			 */
			for (i = 0; i < nexecs; i++)
				if (execsw[i].es_check == NULL)
					break;		/* found it! */
			/* out of allocable slots? */
			if (i == nexecs) {
				error = ENFILE;
				break;
			}
		} else {				/* assign */
			if (i < 0 || i >= nexecs) {
				error = EINVAL;
				break;
			}
		}

		/* save old */
		bcopy(&execsw[i], &args->lkm_oldexec, sizeof(struct execsw));

		/* replace with new */
		bcopy(args->lkm_exec, &execsw[i], sizeof(struct execsw));

		/* need to recompute max header size */
		init_exec();

		/* done! */
		args->lkm_offset = i;	/* slot in execsw[] */

		break;

	case LKM_E_UNLOAD:
		/* current slot... */
		i = args->lkm_offset;

		/* replace current slot contents with old contents */
		bcopy(&args->lkm_oldexec, &execsw[i], sizeof(struct execsw));

		/* need to recompute max header size */
		init_exec();

		break;

	case LKM_E_STAT:	/* no special handling... */
		break;
	}

	return (error);
}

/*
 * This code handles the per-module type "wiring-in" of loadable modules
 * into existing kernel tables.  For "LM_MISC" modules, wiring and unwiring
 * is assumed to be done in their entry routines internal to the module
 * itself.
 */
int
lkmdispatch(struct lkm_table *lkmtp, int cmd)
{
	int error =  0;

#ifdef LKM_DEBUG
	printf("lkmdispatch: %x %d\n", lkmtp, cmd);
#endif /* LKM_DEBUG */

	switch (lkmtp->private.lkm_any->lkm_type) {
	case LM_SYSCALL:
		error = _lkm_syscall(lkmtp, cmd);
		break;

	case LM_VFS:
		error = _lkm_vfs(lkmtp, cmd);
		break;

	case LM_DEV:
		error = _lkm_dev(lkmtp, cmd);
		break;

	case LM_EXEC:
		error = _lkm_exec(lkmtp, cmd);
		break;

	case LM_MISC:	/* ignore content -- no "misc-specific" procedure */
		break;

	default:
		error = ENXIO;	/* unknown type */
		break;
	}

	return (error);
}
@


1.49
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.48 2014/07/12 18:43:32 tedu Exp $	*/
@


1.48
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.47 2014/01/21 01:48:44 tedu Exp $	*/
a48 1
#include <sys/proc.h>
@


1.47
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.46 2010/01/14 23:12:11 schwarze Exp $	*/
d193 1
a193 1
	free(p, M_DEVBUF);
@


1.46
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.45 2007/11/03 22:23:35 mikeb Exp $	*/
d446 1
a446 1
			    bzero((caddr_t)curp->area + curp->offset,
@


1.45
log
@Fix LKM support for amd64.

ok deraadt weingart
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.44 2007/10/29 14:12:19 chl Exp $	*/
d152 1
a152 1
 * Alocates new LKM table entry, fills module id, inserts in the list.
@


1.44
log
@MALLOC/FREE -> malloc/free
replace an hard coded value with M_WAITOK

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.43 2006/11/15 17:25:40 jmc Exp $	*/
d81 2
d107 6
d270 1
a270 1
		uvm_km_free(kernel_map, (vaddr_t)curp->syms, curp->sym_size);
d278 1
a278 1
		uvm_km_free(kernel_map, curp->area, curp->size);
d350 1
a350 1
		curp->area = uvm_km_zalloc(kernel_map, curp->size);
d357 1
a357 1
			curp->syms = (caddr_t)uvm_km_zalloc(kernel_map,
@


1.43
log
@typos; from bret lambert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.42 2005/11/28 00:14:28 jsg Exp $	*/
d154 1
a154 1
	MALLOC(ret, struct lkm_table *, sizeof(*ret), M_DEVBUF, M_WAITOK);
@


1.42
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.41 2004/03/03 06:26:22 tedu Exp $	*/
d159 1
a159 1
	 * kept sorted this is not too ineffcient, which is why we insert in
@


1.41
log
@better way of finding and identifying lkms.
adapted from pr2910 by peter werner, minus lkmfree removals since
i couldn't tell what issue they were fixing.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.40 2003/08/23 20:27:30 tedu Exp $	*/
d102 1
a102 1
lkminit()
d149 1
a149 1
lkmalloc()
d250 1
a250 1
lkmunreserve()
d558 1
a558 1
lkmenodev()
@


1.40
log
@remember to reset exec_maxhdrsz after lkm load/unload.  ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.39 2003/07/21 22:44:50 tedu Exp $	*/
d72 1
d84 1
a84 1
static TAILQ_HEAD(, lkm_table) lkmods;	/* table of loaded modules */
a85 1
static size_t nlkms = 0;		/* number of loaded lkms */
d106 1
d118 3
a139 3
	if (nlkms == 0)
		lkminit();	/* XXX */

d151 2
a152 1
	struct lkm_table *ret = NULL;
a155 1
	ret->id = nlkms++;
d157 16
a172 1
	TAILQ_INSERT_TAIL(&lkmods, ret, list);
a186 1
	nlkms--;
d206 12
d233 5
a237 8
	} else if (i >= nlkms) {
		*error = EINVAL;
		return NULL;
	} else
		for (p = TAILQ_FIRST(&lkmods); p != NULL && i--;
		     p = TAILQ_NEXT(p, list))
			;

@


1.39
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.38 2003/04/29 07:14:11 tedu Exp $	*/
d99 2
d819 2
a820 2
		/* realize need to recompute max header size */
		exec_maxhdrsz = 0;
d834 2
a835 2
		/* realize need to recompute max header size */
		exec_maxhdrsz = 0;
@


1.38
log
@after freeing curp, set to NULL.  fixes a crash when loading a module
twice.  similar to patch from Even Farrer farrer at uofu.net
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.37 2002/03/14 01:27:04 millert Exp $	*/
d128 1
a128 1
		error = tsleep((caddr_t)&lkm_v, TTIPRI|PCATCH, "lkmopn", 0);
d271 1
a271 1
	wakeup((caddr_t)&lkm_v);	/* thundering herd "problem" here */
@


1.37
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.36 2002/01/09 19:05:17 ericj Exp $	*/
d168 1
@


1.36
log
@
make sure we use lkmfree() in error cases as well.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.35 2002/01/07 19:23:32 ericj Exp $	*/
d96 2
a97 2
void lkminit __P((void));
int lkmexists __P((struct lkm_table *));
d418 1
a418 1
		curp->entry = (int (*) __P((struct lkm_table *, int, int)))
@


1.35
log
@
first pass cleanup for lkms
- Use queue.h macros instead of accessing members directly
- Allocate from kernel_map instead of kmem_map
- remove streams
- free memory for syms in lkmunreserve()
- change LMREADY arg to u_long (allow it to work on 64bit systems) - NetBSD
- KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.34 2001/11/06 19:53:20 miod Exp $	*/
d113 1
a113 1
		return (ENXIO);		/* bad minor # */
d253 3
d260 1
a260 1
	if (curp != NULL) {
d266 2
a267 1
		lkmunreserve();	/* coerce state to LKM_IDLE */
d399 2
@


1.34
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.33 2001/09/19 20:50:58 mickey Exp $	*/
d69 7
a75 6
#define	LKM_ALLOC	0x01
#define	LKM_WANT	0x02

#define	LKMS_IDLE	0x00
#define	LKMS_RESERVED	0x01
#define	LKMS_LOADING	0x02
d77 2
a78 2
#define	LKMS_LOADED	0x04
#define	LKMS_UNLOADING	0x08
d80 2
a81 2
static int	lkm_v = 0;
static int	lkm_state = LKMS_IDLE;
d83 1
a83 1
static TAILQ_HEAD(, lkm_table)	lkmods;	/* table of loaded modules */
d85 1
a85 1
static size_t		nlkms = 0;	/* number of loaded lkms */
d87 8
a94 11
static struct lkm_table *lkmalloc __P((void));  /* allocate new lkm table entry */
static void lkmfree __P((struct lkm_table *)); /* free it */
static struct lkm_table *lkmlookup __P((int, char *, int *));
static void lkmunreserve __P((void));
static int _lkm_syscall __P((struct lkm_table *, int));
static int _lkm_vfs __P((struct lkm_table *, int));
static int _lkm_dev __P((struct lkm_table *, int));
#ifdef STREAMS
static int _lkm_strmod __P((struct lkm_table *, int));
#endif
static int _lkm_exec __P((struct lkm_table *, int));
d102 1
d108 1
a108 5
lkmopen(dev, flag, devtype, p)
	dev_t dev;
	int flag;
	int devtype;
	struct proc *p;
d163 1
a163 2
lkmfree(p)
	struct lkm_table *p;
d165 1
a165 4
#ifdef	PARANOIA
	if (p == NULL)
		panic("lkmfree: freeing NULL");
#endif
d172 1
a172 2
lkm_list(p)
	struct lkm_table *p;
d174 1
d176 1
a176 1
		p = lkmods.tqh_first;
d178 1
a178 1
		p = p->list.tqe_next;
d180 1
a180 1
	return p;
d184 1
a184 4
lkmlookup(i, name, error)
	int	i;
	char	*name;
	int	*error;
d186 2
a187 2
	register struct lkm_table *p = NULL;
	char	istr[MAXLKMNAME];
d199 1
a199 1
		for (p = lkmods.tqh_first; p != NULL; p = p->list.tqe_next)
d202 1
d207 2
a208 2
		for (p = lkmods.tqh_first; p != NULL && i--;
		    p = p->list.tqe_next)
d230 2
a231 3
	if (curp && curp->private.lkm_any && curp->private.lkm_any->lkm_name
	    && curp->sym_id != -1)
	    db_del_symbol_table(curp->private.lkm_any->lkm_name);
d234 5
d243 1
a243 1
		uvm_km_free(kmem_map, curp->area, curp->size);
a245 1

d250 1
a250 5
lkmclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d253 1
a253 4
	if (!(lkm_v & LKM_ALLOC)) {
#ifdef LKM_DEBUG
		printf("LKM: close before open!\n");
#endif	/* LKM_DEBUG */
a254 1
	}
a264 1

d268 1
a268 1
	return (0);		/* pseudo-device closed */
d273 3
a275 18
lkmioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
{
	int error = 0, i;
	struct lmc_resrv *resrvp;
	struct lmc_loadbuf *loadbufp;
	struct lmc_unload *unloadp;
	struct lmc_stat	 *statp;

	switch(cmd) {
	case LMRESERV:		/* reserve pages for a module */
	case LMRESERV_O:	/* reserve pages for a module */
		if (securelevel > 0)
			return EPERM;
d277 8
a284 2
		if ((flag & FWRITE) == 0) /* only allow this if writing */
			return EPERM;
d286 13
a298 1
		resrvp = (struct lmc_resrv *)data;
d301 1
a301 1
			error = ENOMEM;		/* no slots available */
d311 3
a313 6

		curp->area = uvm_km_zalloc(kmem_map, curp->size);

		curp->offset = 0;		/* load offset */

		resrvp->addr = curp->area; /* ret kernel addr */
d318 1
a318 1
			curp->syms = (caddr_t)uvm_km_zalloc(kmem_map,
d321 1
a321 1
			resrvp->sym_addr = curp->syms; /* ret symbol addr */
d335 1
d338 1
d340 2
a341 6
	case LMLOADBUF:		/* Copy in; stateful, follows LMRESERV */
		if (securelevel > 0)
			return EPERM;

		if ((flag & FWRITE) == 0) /* only allow this if writing */
			return EPERM;
a342 1
		loadbufp = (struct lmc_loadbuf *)data;
d346 1
a346 1
		    || loadbufp->cnt > curp->size - curp->offset) {
d357 1
a357 1
		if ((curp->offset + loadbufp->cnt) < curp->size) {
d359 1
a359 5
#ifdef LKM_DEBUG
			printf("LKM: LMLOADBUF (loading @@ %ld of %ld, i = %d)\n",
			curp->offset, curp->size, loadbufp->cnt);
#endif	/* LKM_DEBUG */
		} else {
d361 1
a361 4
#ifdef LKM_DEBUG
			printf("LKM: LMLOADBUF (loaded)\n");
#endif	/* LKM_DEBUG */
		}
d364 1
d366 2
a367 3
	case LMLOADSYMS:	/* Copy in; stateful, follows LMRESERV*/
		if ((flag & FWRITE) == 0) /* only allow this if writing */
			return EPERM;
a368 2
		loadbufp = (struct lmc_loadbuf *)data;
		i = loadbufp->cnt;
d371 3
a373 3
		    || i < 0
		    || i > MODIOBUF
		    || i > curp->sym_size - curp->sym_offset) {
d380 1
a380 1
		    curp->sym_offset, i);
d384 1
a384 1
		if ((curp->sym_offset + i) < curp->sym_size) {
d386 1
a386 5
#ifdef LKM_DEBUG
			printf( "LKM: LMLOADSYMS (loading @@ %d of %d, i = %d)\n",
			curp->sym_offset, curp->sym_size, i);
#endif	/* LKM_DEBUG*/
		} else {
d388 2
a389 5
#ifdef LKM_DEBUG
			printf( "LKM: LMLOADSYMS (loaded)\n");
#endif	/* LKM_DEBUG*/
		}
		curp->sym_offset += i;
d391 1
d393 2
a394 11
	case LMUNRESRV:		/* discard reserved pages for a module */
		if (securelevel > 0)
			return EPERM;

		if ((flag & FWRITE) == 0) /* only allow this if writing */
			return EPERM;

		lkmunreserve();	/* coerce state to LKM_IDLE */
#ifdef LKM_DEBUG
		printf("LKM: LMUNRESERV\n");
#endif	/* LKM_DEBUG */
d397 1
a397 7
	case LMREADY:		/* module loaded: call entry */
		if (securelevel > 0)
			return EPERM;

		if ((flag & FWRITE) == 0) /* only allow this if writing */
			return EPERM;

d403 1
a403 1
			if (curp->size - curp->offset > 0)
d409 1
a409 5

#ifdef LKM_DEBUG
			printf("lkm_state is %02x\n", lkm_state);
#endif	/* LKM_DEBUG */
			return ENXIO;
d418 1
d436 1
d447 1
d452 6
a457 12
	case LMUNLOAD:		/* unload a module */
		if (securelevel > 0)
			return EPERM;

		if ((flag & FWRITE) == 0) /* only allow this if writing */
			return EPERM;

		unloadp = (struct lmc_unload *)data;

		if ((curp =
		    lkmlookup(unloadp->id, unloadp->name, &error)) == NULL)
			break; /* error set in lkmlookup */
d469 1
d471 2
a472 2
	case LMSTAT:		/* stat a module by id/name */
		/* allow readers and writers to stat */
d474 2
a475 1
		statp = (struct lmc_stat *)data;
d477 2
a478 2
		if ((curp = lkmlookup(statp->id, statp->name, &error)) == NULL)
			break; /* error set in lkmlookup */
d494 1
d496 2
a497 2
	default:		/* bad ioctl()... */
		error = ENOTTY;
d511 1
a511 4
sys_lkmnosys(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d536 1
a536 3
lkm_nofunc(lkmtp, cmd)
	struct lkm_table *lkmtp;
	int cmd;
d543 1
a543 2
lkmexists(lkmtp)
	struct lkm_table *lkmtp;
d545 1
a545 1
	register struct lkm_table *p;
d547 1
a547 4
	/*
	 * see if name exists...
	 */
	for (p = lkmods.tqh_first; p != NULL ; p = p->list.tqe_next)
d549 4
a552 4
			p->private.lkm_any->lkm_name) && p->refcnt)
			return (1);		/* already loaded... */

	return (0);		/* module not loaded... */
d560 1
a560 3
_lkm_syscall(lkmtp, cmd)
	struct lkm_table *lkmtp;
	int cmd;
d566 1
a566 1
	switch(cmd) {
d623 1
a623 3
_lkm_vfs(lkmtp, cmd)
	struct lkm_table *lkmtp;
	int cmd;
d626 1
a626 1
	struct vfsconf *vfs = lkmtp->private.lkm_vfs->lkm_vfsconf;
d628 1
a628 1
	switch(cmd) {
d633 1
a633 1
		error = vfs_register(vfs);
d637 1
a637 1
		error = vfs_unregister(vfs);
d652 1
a652 3
_lkm_dev(lkmtp, cmd)
	struct lkm_table *lkmtp;
	int cmd;
a656 1
	extern int nblkdev, nchrdev;	/* from conf.c */
d658 1
a658 1
	switch(cmd) {
d664 1
a664 1
		switch(args->lkm_devtype) {
d742 1
a742 1
		switch(args->lkm_devtype) {
a767 32
#ifdef STREAMS
/*
 * For the loadable streams module described by the structure pointed to
 * by lkmtp, load/unload/stat it depending on the cmd requested.
 */
static int
_lkm_strmod(lkmtp, cmd)
	struct lkm_table *lkmtp;
	int cmd;
{
	struct lkm_strmod *args = lkmtp->private.lkm_strmod;
	int i;
	int error = 0;

	switch(cmd) {
	case LKM_E_LOAD:
		/* don't load twice! */
		if (lkmexists(lkmtp))
			return (EEXIST);
		break;

	case LKM_E_UNLOAD:
		break;

	case LKM_E_STAT:	/* no special handling... */
		break;
	}

	return (error);
}
#endif	/* STREAMS */

d773 1
a773 3
_lkm_exec(lkmtp, cmd)
	struct lkm_table *lkmtp;
	int cmd;
d779 1
a779 1
	switch(cmd) {
d844 1
a844 3
lkmdispatch(lkmtp, cmd)
	struct lkm_table *lkmtp;	
	int cmd;
d846 1
a846 1
	int error = 0;		/* default = success */
d852 1
a852 1
	switch(lkmtp->private.lkm_any->lkm_type) {
a863 9

#ifdef STREAMS
	case LM_STRMOD:
	    {
		struct lkm_strmod *args = lkmtp->private.lkm_strmod;
	    }
		break;

#endif	/* STREAMS */
@


1.34.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.36 2002/01/09 19:05:17 ericj Exp $	*/
d69 6
a74 7
/* flags */
#define	LKM_ALLOC		0x01
#define	LKM_WANT		0x02

#define	LKMS_IDLE		0x00
#define	LKMS_RESERVED		0x01
#define	LKMS_LOADING		0x02
d76 2
a77 2
#define	LKMS_LOADED		0x04
#define	LKMS_UNLOADING		0x08
d79 2
a80 2
static int lkm_v = 0;
static int lkm_state = LKMS_IDLE;
d82 1
a82 1
static TAILQ_HEAD(, lkm_table) lkmods;	/* table of loaded modules */
d84 1
a84 1
static size_t nlkms = 0;		/* number of loaded lkms */
d86 11
a96 8
static struct lkm_table *lkmalloc(void);
static void lkmfree(struct lkm_table *);
static struct lkm_table *lkmlookup(int, char *, int *);
static void lkmunreserve(void);
static int _lkm_syscall(struct lkm_table *, int);
static int _lkm_vfs(struct lkm_table *, int);
static int _lkm_dev(struct lkm_table *, int);
static int _lkm_exec(struct lkm_table *, int);
a103 1

d109 5
a113 1
lkmopen(dev_t dev, int flag, int devtype, struct proc *p)
d118 1
a118 1
		return (ENXIO);
d168 2
a169 1
lkmfree(struct lkm_table *p)
d171 4
a174 1

d181 2
a182 1
lkm_list(struct lkm_table *p)
a183 1

d185 1
a185 1
		p = TAILQ_FIRST(&lkmods);
d187 1
a187 1
		p = TAILQ_NEXT(p, list);
d189 1
a189 1
	return (p);
d193 4
a196 1
lkmlookup(int i, char *name, int *error)
d198 2
a199 2
	struct lkm_table *p = NULL;
	char istr[MAXLKMNAME];
d211 1
a211 1
		TAILQ_FOREACH(p, &lkmods, list) {
a213 1
		}
d218 2
a219 2
		for (p = TAILQ_FIRST(&lkmods); p != NULL && i--;
		     p = TAILQ_NEXT(p, list))
d241 3
a243 2
	if (curp && curp->sym_id != -1)
		db_del_symbol_table(curp->private.lkm_any->lkm_name);
a245 5
	if (curp && curp->syms) {
		uvm_km_free(kernel_map, (vaddr_t)curp->syms, curp->sym_size);
		curp->syms = NULL;
	}

d250 1
a250 1
		uvm_km_free(kernel_map, curp->area, curp->size);
d253 1
d258 5
a262 1
lkmclose(dev_t dev, int flag, int mode, struct proc *p)
d265 4
a268 4
	if (minor(dev) != 0)
		return (ENXIO);

	if (!(lkm_v & LKM_ALLOC))
d270 1
d273 1
a273 1
	if (curp != NULL && !curp->refcnt) {
d279 1
a279 2
		lkmunreserve();
		lkmfree(curp);
d281 1
d285 1
a285 1
	return (0);
d290 18
a307 12
lkmioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	int error = 0;

	if (securelevel > 0) {
		switch (cmd) {
		case LMSTAT:
			break;
		default:
			return (EPERM);
		}
	}
d309 2
a310 8
	if (!(flags & FWRITE)) {
		switch (cmd) {
		case LMSTAT:
			break;
		default:
			return (EACCES);
		}
	}
d312 1
a312 4
	switch (cmd) {
	case LMRESERV:
	case LMRESERV_O: {
		struct lmc_resrv *resrvp = (struct lmc_resrv *)data;
d315 1
a315 1
			error = ENOMEM;	
d325 6
a330 3
		curp->area = uvm_km_zalloc(kernel_map, curp->size);
		curp->offset = 0;
		resrvp->addr = curp->area;
d335 1
a335 1
			curp->syms = (caddr_t)uvm_km_zalloc(kernel_map,
d338 1
a338 1
			resrvp->sym_addr = curp->syms;
a351 1

a353 1
	}
d355 6
a360 2
	case LMLOADBUF: {
		struct lmc_loadbuf *loadbufp = (struct lmc_loadbuf *)data;
d362 1
d366 1
a366 1
		    || loadbufp->cnt > (curp->size - curp->offset)) {
d377 1
a377 1
		if ((curp->offset + loadbufp->cnt) < curp->size)
d379 5
a383 1
		else
d385 4
a388 1

a390 1
	}
d392 3
a394 2
	case LMLOADSYMS: {
		struct lmc_loadbuf *loadbufp = (struct lmc_loadbuf *)data;
d396 2
d400 3
a402 3
		    || loadbufp->cnt < 0
		    || loadbufp->cnt > MODIOBUF
		    || loadbufp->cnt > (curp->sym_size - curp->sym_offset)) {
d409 1
a409 1
		    curp->sym_offset, loadbufp->cnt);
d413 1
a413 1
		if ((curp->sym_offset + loadbufp->cnt) < curp->sym_size)
d415 5
a419 1
		else
d421 10
d432 7
a438 1
		curp->sym_offset += loadbufp->cnt;
a439 1
	}
d441 6
a446 5
	case LMUNRESRV:
		lkmunreserve();
		if (curp)
			lkmfree(curp);
		break;
a447 1
	case LMREADY:
d453 1
a453 1
			if ((curp->size - curp->offset) > 0)
d459 5
a463 1
			return (ENXIO);
a471 1

a488 1

a498 1

d503 12
a514 6
	case LMUNLOAD: {
		struct lmc_unload *unloadp = (struct lmc_unload *)data;

		curp = lkmlookup(unloadp->id, unloadp->name, &error);
		if (curp == NULL)
			break;
a525 1
	}
d527 4
a530 2
	case LMSTAT: {
		struct lmc_stat *statp = (struct lmc_stat *)data;
d533 1
a533 4
			break;

		if ((error = (*curp->entry)(curp, LKM_E_STAT, curp->ver)))
			break;
a548 1
	}
d550 2
a551 2
	default:
		error = ENODEV;
d565 4
a568 1
sys_lkmnosys(struct proc *p, void *v, register_t *retval)
d593 3
a595 1
lkm_nofunc(struct lkm_table *lkmtp, int cmd)
d602 2
a603 1
lkmexists(struct lkm_table *lkmtp)
d605 1
a605 1
	struct lkm_table *p;
d607 4
a610 1
	TAILQ_FOREACH(p, &lkmods, list) {
d612 4
a615 4
		     p->private.lkm_any->lkm_name) && p->refcnt)
			return (1);
	}
	return (0);
d623 3
a625 1
_lkm_syscall(struct lkm_table *lkmtp, int cmd)
d631 1
a631 1
	switch (cmd) {
d688 3
a690 1
_lkm_vfs(struct lkm_table *lkmtp, int cmd)
d693 1
a693 1
	struct lkm_vfs *args = lkmtp->private.lkm_vfs;
d695 1
a695 1
	switch (cmd) {
d700 1
a700 1
		error = vfs_register(args->lkm_vfsconf);
d704 1
a704 1
		error = vfs_unregister(args->lkm_vfsconf);
d719 3
a721 1
_lkm_dev(struct lkm_table *lkmtp, int cmd)
d726 1
d728 1
a728 1
	switch (cmd) {
d734 1
a734 1
		switch (args->lkm_devtype) {
d812 1
a812 1
		switch (args->lkm_devtype) {
d838 32
d875 3
a877 1
_lkm_exec(struct lkm_table *lkmtp, int cmd)
d883 1
a883 1
	switch (cmd) {
d948 3
a950 1
lkmdispatch(struct lkm_table *lkmtp, int cmd)
d952 1
a952 1
	int error =  0;
d958 1
a958 1
	switch (lkmtp->private.lkm_any->lkm_type) {
d970 9
@


1.34.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.34.2.1 2002/01/31 22:55:40 niklas Exp $	*/
d96 2
a97 2
void lkminit(void);
int lkmexists(struct lkm_table *);
d418 1
a418 1
		curp->entry = (int (*)(struct lkm_table *, int, int))
@


1.34.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a167 1
	curp = NULL;
@


1.33
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.32 2001/08/12 20:33:50 mickey Exp $	*/
a61 1
#include <vm/vm.h>
@


1.32
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.31 2001/06/27 04:49:42 art Exp $	*/
d63 1
a63 1
#include <vm/vm_kern.h>
@


1.31
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.30 2001/05/16 12:52:58 ho Exp $	*/
a62 1
#include <vm/vm_param.h>
@


1.30
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.29 2001/05/05 20:57:00 art Exp $	*/
a251 1
#if defined(UVM)
a252 3
#else
		kmem_free(kmem_map, curp->area, curp->size);/**/
#endif
a327 1
#if defined(UVM)
a328 3
#else
		curp->area = kmem_alloc(kmem_map, curp->size);/**/
#endif
a336 1
#if defined(UVM)
a338 4
#else
			curp->syms = (caddr_t)kmem_alloc(kmem_map,
							 curp->sym_size);
#endif
@


1.29
log
@Get rid of CLSIZE and all related stuff.
CLSIZE -> 1
CLBYTES -> PAGE_SIZE
OLOFSET -> PAGE_MASK
etc.
At the same time some archs needed some cleaning in vmparam.h so that
goes in at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.28 2001/02/10 10:42:35 niklas Exp $	*/
d158 4
a161 7
	if (ret != NULL) {
		ret->refcnt =
		ret->depcnt = 0;
		ret->id = nlkms++;
		ret->sym_id = -1;
		TAILQ_INSERT_TAIL(&lkmods, ret, list);
	}
@


1.28
log
@new symbol handling in ddb for ELF, there is still a problem with hangman on alpha though..
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.27 2001/02/06 16:38:13 fgsch Exp $	*/
d560 1
a560 1
		statp->size	= curp->size / CLBYTES;
@


1.27
log
@spelling and KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.26 2000/01/02 06:28:06 assar Exp $	*/
d512 1
a512 1
			    curp->syms, curp->syms + curp->sym_size);
@


1.26
log
@(lkmalloc): initialize `sym_id'
(lkmunreserve): check that the DDB symbols were actually loaded before
unloading them
PR 1031
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.25 1999/02/26 04:54:00 art Exp $	*/
d504 2
a505 1
		printf("LKM: LMREADY, id=%d, dev=%d\n", curp->id, curp->private.lkm_any->lkm_offset);
d530 2
a531 1
		if ((curp = lkmlookup(unloadp->id, unloadp->name, &error)) == NULL)
d608 1
a608 1
 * Used where people don't wnat tp specify a special function.
d775 2
a776 1
			bcopy(&bdevsw[i], &args->lkm_olddev.bdev, sizeof(struct bdevsw));
d779 2
a780 1
			bcopy(args->lkm_dev.bdev, &bdevsw[i], sizeof(struct bdevsw));
d808 2
a809 1
			bcopy(&cdevsw[i], &args->lkm_olddev.cdev, sizeof(struct cdevsw));
d812 2
a813 1
			bcopy(args->lkm_dev.cdev, &cdevsw[i], sizeof(struct cdevsw));
d833 2
a834 1
			bcopy(&args->lkm_olddev.bdev, &bdevsw[i], sizeof(struct bdevsw));
d839 2
a840 1
			bcopy(&args->lkm_olddev.cdev, &cdevsw[i], sizeof(struct cdevsw));
@


1.26.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.28 2001/02/10 10:42:35 niklas Exp $	*/
d504 1
a504 2
		printf("LKM: LMREADY, id=%d, dev=%d\n", curp->id,
		    curp->private.lkm_any->lkm_offset);
d511 1
a511 1
			    curp->syms);
d529 1
a529 2
		if ((curp =
		    lkmlookup(unloadp->id, unloadp->name, &error)) == NULL)
d606 1
a606 1
 * Used where people don't want to specify a special function.
d773 1
a773 2
			bcopy(&bdevsw[i], &args->lkm_olddev.bdev,
			    sizeof(struct bdevsw));
d776 1
a776 2
			bcopy(args->lkm_dev.bdev, &bdevsw[i],
			    sizeof(struct bdevsw));
d804 1
a804 2
			bcopy(&cdevsw[i], &args->lkm_olddev.cdev,
			    sizeof(struct cdevsw));
d807 1
a807 2
			bcopy(args->lkm_dev.cdev, &cdevsw[i],
			    sizeof(struct cdevsw));
d827 1
a827 2
			bcopy(&args->lkm_olddev.bdev, &bdevsw[i],
			    sizeof(struct bdevsw));
d832 1
a832 2
			bcopy(&args->lkm_olddev.cdev, &cdevsw[i],
			    sizeof(struct cdevsw));
@


1.26.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.26.2.1 2001/05/14 22:32:40 niklas Exp $	*/
d158 7
a164 4
	ret->refcnt = ret->depcnt = 0;
	ret->id = nlkms++;
	ret->sym_id = -1;
	TAILQ_INSERT_TAIL(&lkmods, ret, list);
d255 1
d257 3
d335 1
d337 3
d348 1
d351 4
d560 1
a560 1
		statp->size	= curp->size / PAGE_SIZE;
@


1.26.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.26.2.2 2001/07/04 10:48:21 niklas Exp $	*/
d63 2
a64 1
#include <uvm/uvm_extern.h>
@


1.26.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
@


1.26.2.5
log
@Merge in trunk
@
text
@d69 6
a74 7
/* flags */
#define	LKM_ALLOC		0x01
#define	LKM_WANT		0x02

#define	LKMS_IDLE		0x00
#define	LKMS_RESERVED		0x01
#define	LKMS_LOADING		0x02
d76 2
a77 2
#define	LKMS_LOADED		0x04
#define	LKMS_UNLOADING		0x08
d79 2
a80 2
static int lkm_v = 0;
static int lkm_state = LKMS_IDLE;
d82 1
a82 1
static TAILQ_HEAD(, lkm_table) lkmods;	/* table of loaded modules */
d84 1
a84 1
static size_t nlkms = 0;		/* number of loaded lkms */
d86 11
a96 8
static struct lkm_table *lkmalloc(void);
static void lkmfree(struct lkm_table *);
static struct lkm_table *lkmlookup(int, char *, int *);
static void lkmunreserve(void);
static int _lkm_syscall(struct lkm_table *, int);
static int _lkm_vfs(struct lkm_table *, int);
static int _lkm_dev(struct lkm_table *, int);
static int _lkm_exec(struct lkm_table *, int);
a103 1

d109 5
a113 1
lkmopen(dev_t dev, int flag, int devtype, struct proc *p)
d118 1
a118 1
		return (ENXIO);
d168 2
a169 1
lkmfree(struct lkm_table *p)
d171 4
a174 1

d181 2
a182 1
lkm_list(struct lkm_table *p)
a183 1

d185 1
a185 1
		p = TAILQ_FIRST(&lkmods);
d187 1
a187 1
		p = TAILQ_NEXT(p, list);
d189 1
a189 1
	return (p);
d193 4
a196 1
lkmlookup(int i, char *name, int *error)
d198 2
a199 2
	struct lkm_table *p = NULL;
	char istr[MAXLKMNAME];
d211 1
a211 1
		TAILQ_FOREACH(p, &lkmods, list) {
a213 1
		}
d218 2
a219 2
		for (p = TAILQ_FIRST(&lkmods); p != NULL && i--;
		     p = TAILQ_NEXT(p, list))
d241 3
a243 2
	if (curp && curp->sym_id != -1)
		db_del_symbol_table(curp->private.lkm_any->lkm_name);
a245 5
	if (curp && curp->syms) {
		uvm_km_free(kernel_map, (vaddr_t)curp->syms, curp->sym_size);
		curp->syms = NULL;
	}

d250 1
a250 1
		uvm_km_free(kernel_map, curp->area, curp->size);
d253 1
d258 5
a262 1
lkmclose(dev_t dev, int flag, int mode, struct proc *p)
d265 4
a268 4
	if (minor(dev) != 0)
		return (ENXIO);

	if (!(lkm_v & LKM_ALLOC))
d270 1
d273 1
a273 1
	if (curp != NULL && !curp->refcnt) {
d279 1
a279 2
		lkmunreserve();
		lkmfree(curp);
d281 1
d285 1
a285 1
	return (0);
d290 18
a307 12
lkmioctl(dev_t dev, u_long cmd, caddr_t data, int flags, struct proc *p)
{
	int error = 0;

	if (securelevel > 0) {
		switch (cmd) {
		case LMSTAT:
			break;
		default:
			return (EPERM);
		}
	}
d309 2
a310 8
	if (!(flags & FWRITE)) {
		switch (cmd) {
		case LMSTAT:
			break;
		default:
			return (EACCES);
		}
	}
d312 1
a312 4
	switch (cmd) {
	case LMRESERV:
	case LMRESERV_O: {
		struct lmc_resrv *resrvp = (struct lmc_resrv *)data;
d315 1
a315 1
			error = ENOMEM;	
d325 6
a330 3
		curp->area = uvm_km_zalloc(kernel_map, curp->size);
		curp->offset = 0;
		resrvp->addr = curp->area;
d335 1
a335 1
			curp->syms = (caddr_t)uvm_km_zalloc(kernel_map,
d338 1
a338 1
			resrvp->sym_addr = curp->syms;
a351 1

a353 1
	}
d355 6
a360 2
	case LMLOADBUF: {
		struct lmc_loadbuf *loadbufp = (struct lmc_loadbuf *)data;
d362 1
d366 1
a366 1
		    || loadbufp->cnt > (curp->size - curp->offset)) {
d377 1
a377 1
		if ((curp->offset + loadbufp->cnt) < curp->size)
d379 5
a383 1
		else
d385 4
a388 1

a390 1
	}
d392 3
a394 2
	case LMLOADSYMS: {
		struct lmc_loadbuf *loadbufp = (struct lmc_loadbuf *)data;
d396 2
d400 3
a402 3
		    || loadbufp->cnt < 0
		    || loadbufp->cnt > MODIOBUF
		    || loadbufp->cnt > (curp->sym_size - curp->sym_offset)) {
d409 1
a409 1
		    curp->sym_offset, loadbufp->cnt);
d413 1
a413 1
		if ((curp->sym_offset + loadbufp->cnt) < curp->sym_size)
d415 5
a419 1
		else
d421 10
d432 7
a438 1
		curp->sym_offset += loadbufp->cnt;
a439 1
	}
d441 6
a446 5
	case LMUNRESRV:
		lkmunreserve();
		if (curp)
			lkmfree(curp);
		break;
a447 1
	case LMREADY:
d453 1
a453 1
			if ((curp->size - curp->offset) > 0)
d459 5
a463 1
			return (ENXIO);
a471 1

a488 1

a498 1

d503 12
a514 6
	case LMUNLOAD: {
		struct lmc_unload *unloadp = (struct lmc_unload *)data;

		curp = lkmlookup(unloadp->id, unloadp->name, &error);
		if (curp == NULL)
			break;
a525 1
	}
d527 4
a530 2
	case LMSTAT: {
		struct lmc_stat *statp = (struct lmc_stat *)data;
d533 1
a533 4
			break;

		if ((error = (*curp->entry)(curp, LKM_E_STAT, curp->ver)))
			break;
a548 1
	}
d550 2
a551 2
	default:
		error = ENODEV;
d565 4
a568 1
sys_lkmnosys(struct proc *p, void *v, register_t *retval)
d593 3
a595 1
lkm_nofunc(struct lkm_table *lkmtp, int cmd)
d602 2
a603 1
lkmexists(struct lkm_table *lkmtp)
d605 1
a605 1
	struct lkm_table *p;
d607 4
a610 1
	TAILQ_FOREACH(p, &lkmods, list) {
d612 4
a615 4
		     p->private.lkm_any->lkm_name) && p->refcnt)
			return (1);
	}
	return (0);
d623 3
a625 1
_lkm_syscall(struct lkm_table *lkmtp, int cmd)
d631 1
a631 1
	switch (cmd) {
d688 3
a690 1
_lkm_vfs(struct lkm_table *lkmtp, int cmd)
d693 1
a693 1
	struct lkm_vfs *args = lkmtp->private.lkm_vfs;
d695 1
a695 1
	switch (cmd) {
d700 1
a700 1
		error = vfs_register(args->lkm_vfsconf);
d704 1
a704 1
		error = vfs_unregister(args->lkm_vfsconf);
d719 3
a721 1
_lkm_dev(struct lkm_table *lkmtp, int cmd)
d726 1
d728 1
a728 1
	switch (cmd) {
d734 1
a734 1
		switch (args->lkm_devtype) {
d812 1
a812 1
		switch (args->lkm_devtype) {
d838 32
d875 3
a877 1
_lkm_exec(struct lkm_table *lkmtp, int cmd)
d883 1
a883 1
	switch (cmd) {
d948 3
a950 1
lkmdispatch(struct lkm_table *lkmtp, int cmd)
d952 1
a952 1
	int error =  0;
d958 1
a958 1
	switch (lkmtp->private.lkm_any->lkm_type) {
d970 9
@


1.26.2.6
log
@Merge in -current from about a week ago
@
text
@d96 2
a97 2
void lkminit(void);
int lkmexists(struct lkm_table *);
d418 1
a418 1
		curp->entry = (int (*)(struct lkm_table *, int, int))
@


1.26.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.26.2.6 2002/03/28 11:43:04 niklas Exp $	*/
a167 1
	curp = NULL;
@


1.26.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a98 2
void init_exec(void);

d128 1
a128 1
		error = tsleep(&lkm_v, TTIPRI|PCATCH, "lkmopn", 0);
d271 1
a271 1
	wakeup(&lkm_v);	/* thundering herd "problem" here */
d817 2
a818 2
		/* need to recompute max header size */
		init_exec();
d832 2
a833 2
		/* need to recompute max header size */
		init_exec();
@


1.26.2.9
log
@Merge with the trunk
@
text
@a71 1
#define	LKM_INIT		0x04
d83 1
a83 1
static TAILQ_HEAD(lkmods, lkm_table) lkmods;	/* table of loaded modules */
d85 1
a105 1
	lkm_v |= LKM_INIT;
a116 3
	if (!(lkm_v & LKM_INIT))
		lkminit();

d136 3
d150 1
a150 2
	struct lkm_table *p, *ret = NULL;
	int id = 0;
d154 1
d156 1
a156 16
	/* 
	 * walk the list finding the first free id. as long as the list is
	 * kept sorted this is not too ineffcient, which is why we insert in
	 * order below.
 	 */
	TAILQ_FOREACH(p, &lkmods, list) {
		if (id == p->id)
			id++;
		else
			break;
	}
	ret->id = id;
	if (p == NULL) /* either first or last entry */
		TAILQ_INSERT_TAIL(&lkmods, ret, list);
	else 
		TAILQ_INSERT_BEFORE(p, ret, list);
d171 1
a190 12
	
	/* 
 	 * p being NULL here implies the list is empty, so any lookup is
 	 * invalid (name based or otherwise). Since the list of modules is
 	 * kept sorted by id, lowest to highest, the id of the last entry 
 	 * will be the highest in use. 
	 */ 
	p = TAILQ_LAST(&lkmods, lkmods);
	if (p == NULL || i > p->id) {
		*error = EINVAL;
		return NULL;
	}
d206 8
a213 5
	} else 
		TAILQ_FOREACH(p, &lkmods, list) 
			if (i == p->id)
				break;
		
@


1.25
log
@kmem allocation changes for uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.24 1999/02/19 17:17:49 art Exp $	*/
d162 1
d246 2
a247 1
	if (curp && curp->private.lkm_any && curp->private.lkm_any->lkm_name)
@


1.24
log
@Change the vfs lkm interface do it takes a full struct vfsconf instead of
only struct vfsops.
Use the new vfs_register and vfs_unregister in the vfs lkms.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.23 1998/03/18 22:47:27 art Exp $	*/
d253 3
d257 1
d333 3
d337 1
d346 7
a352 1
			curp->syms = (caddr_t)kmem_alloc(kmem_map, curp->sym_size);
@


1.23
log
@initialize all fileds in vfsconf when installing a new filesystem.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.22 1998/03/17 05:30:18 art Exp $	*/
d693 1
a693 2
	struct lkm_vfs *args = lkmtp->private.lkm_vfs;
	struct vfsconf *vfsp, **vfspp;
d700 1
a700 39

		/* make sure there's no VFS in the table with this name */
		for (vfspp = &vfsconf, vfsp = vfsconf; vfsp; 
		    vfspp = &vfsp->vfc_next, vfsp = vfsp->vfc_next)
			if (strncmp(vfsp->vfc_name, args->lkm_name,
			    MFSNAMELEN) == 0)
				return (EEXIST);
		
		/* pick the last available empty slot */
		MALLOC (vfsp, struct vfsconf *, sizeof (struct vfsconf),
		    M_VFS, M_WAITOK);

		/* Add tot he end of the list */
		*vfspp = vfsp;

		/*
		 * Set up file system
		 */
#ifndef min
#define min(a,b) (a < b ? a : b)
#endif
		vfsp->vfc_vfsops = args->lkm_vfsops;
		bcopy(args->lkm_name, vfsp->vfc_name, 
		    min(strlen(args->lkm_name) + 1, MFSNAMELEN));
#undef min

		vfsp->vfc_typenum = 0;
		vfsp->vfc_refcount = 0;
		vfsp->vfc_flags = 0; /* XXX - should be configurable */
		vfsp->vfc_mountroot = 0;
		vfsp->vfc_next = NULL;

		maxvfsconf++;

		/* Call init function for this VFS... */
	 	(*(vfsp->vfc_vfsops->vfs_init))(vfsp);

		/* Nope - can't return this */
		return 0;
d704 1
a704 15
		for (vfspp = &vfsconf, vfsp = vfsconf; vfsp &&
		    strncmp(vfsp->vfc_name, args->lkm_name, MFSNAMELEN) != 0;
		    vfsp = vfsp->vfc_next)
			;

		if (!vfsp)
			return EEXIST;

		if (vfsp->vfc_refcount)
			return EBUSY;
		
		*vfspp = vfsp->vfc_next;
		FREE(vfsp, M_VFS);
		maxvfsconf--;
		return 0;
@


1.22
log
@fix vfs lkms + some indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.21 1997/11/06 05:58:17 csapuntz Exp $	*/
d726 6
@


1.21
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.20 1997/10/06 20:19:54 deraadt Exp $	*/
d223 1
a223 1
		     p = p->list.tqe_next)
d401 1
a401 1
		     lkm_state != LKMS_LOADING_SYMS)
d410 2
a411 2
		error = copyin(loadbufp->data, curp->syms + curp->sym_offset,
		    i);
d469 1
a469 1
				(*((long *) (data)));
d492 6
a497 6
		    curp->sym_id = db_add_symbol_table(curp->syms,
					curp->syms + curp->sym_symsize,
					curp->private.lkm_any->lkm_name,
					curp->syms, 
					curp->syms + curp->sym_size );
		    printf("DDB symbols added: %ld bytes\n", curp->sym_symsize);
a692 1
#if 0
d695 1
a695 1
#endif
a701 2
		return (EEXIST);
#if 0
d703 4
a706 6
		for (vfspp = &vfsconf, vfsp = vfsconf; 
		     vfsp; 
		     vfspp = &vfsp->vfc_next, vfsp = vfsp->vfc_next)
			if (strncmp(vfsp->vfc_name,
				    args->lkm_vfsops->vfs_name,
				    MFSNAMELEN) == 0)
a708 1

d711 1
a711 1
			M_VFS, M_WAITOK);
d719 7
a725 1
		/* FIXME (CPS): Setup new vfsconf structure */
d727 3
a729 3
		/*
		 * Call init function for this VFS...
		 */
a731 1
		/* done! */
d733 1
a734 1
#endif
d737 15
@


1.20
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.18 1997/09/24 18:16:22 mickey Exp $	*/
d692 2
d695 2
a696 3
	int i;
	int error = 0;

d703 2
d706 4
a709 3
		for (i = 0; i < nvfssw; i++)
			if (vfssw[i] != (struct vfsops *)0 &&
			    strncmp(vfssw[i]->vfs_name,
d713 1
d716 5
a720 7
		for (i = nvfssw - 1; i >= 0; i--)
			if (vfssw[i] == (struct vfsops *)0)
				break;
		if (i == -1) {		/* or if none, punt */
			error = EINVAL;
			break;
		}
d725 1
a725 2
		vfssw[i] = args->lkm_vfsops;
		vfssw[i]->vfs_refcount = 0;
d730 1
a730 1
	 	(*(vfssw[i]->vfs_init))();
d733 1
a733 1
		args->lkm_offset = i;	/* slot in vfssw[] */
d735 1
a737 8
		/* current slot... */
		i = args->lkm_offset;

		if (vfssw[i]->vfs_refcount != 0)
			return (EBUSY);

		/* replace current slot contents with old contents */
		vfssw[i] = (struct vfsops *)0;
@


1.19
log
@VFS Lite2 Changes
@
text
@d692 2
d695 1
a695 4
#if 0
	struct lkm_vfs *args = lkmtp->private.lkm_vfs;
	struct vfsconf *vfsp, **vfspp;
#endif
a701 2
		return (EEXIST);
#if 0
d703 3
a705 4
		for (vfspp = &vfsconf, vfsp = vfsconf; 
		     vfsp; 
		     vfspp = &vfsp->vfc_next, vfsp = vfsp->vfc_next)
			if (strncmp(vfsp->vfc_name,
a708 1
		
d711 7
a717 5
		MALLOC (vfsp, struct vfsconf *, sizeof (struct vfsconf),
			M_VFS, M_WAITOK);

		/* Add tot he end of the list */
		*vfspp = vfsp;
d722 2
a723 1
		/* FIXME (CPS): Setup new vfsconf structure */
d728 1
a728 1
	 	(*(vfsp->vfc_vfsops->vfs_init))(vfsp);
d731 1
a731 1
		/* Nope - can't return this */
a732 1
#endif
d735 8
@


1.18
log
@s/DEBUG/LKM_DEBUG/g
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.17 1997/07/23 23:09:49 niklas Exp $	*/
d692 2
d695 2
a696 3
	int i;
	int error = 0;

d703 2
d706 4
a709 3
		for (i = 0; i < nvfssw; i++)
			if (vfssw[i] != (struct vfsops *)0 &&
			    strncmp(vfssw[i]->vfs_name,
d713 1
d716 5
a720 7
		for (i = nvfssw - 1; i >= 0; i--)
			if (vfssw[i] == (struct vfsops *)0)
				break;
		if (i == -1) {		/* or if none, punt */
			error = EINVAL;
			break;
		}
d725 1
a725 2
		vfssw[i] = args->lkm_vfsops;
		vfssw[i]->vfs_refcount = 0;
d730 1
a730 1
	 	(*(vfssw[i]->vfs_init))();
d733 1
a733 1
		args->lkm_offset = i;	/* slot in vfssw[] */
d735 1
a737 8
		/* current slot... */
		i = args->lkm_offset;

		if (vfssw[i]->vfs_refcount != 0)
			return (EBUSY);

		/* replace current slot contents with old contents */
		vfssw[i] = (struct vfsops *)0;
@


1.17
log
@No need to doubly include vm/vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.16 1997/07/20 21:24:32 deraadt Exp $	*/
d269 1
a269 1
#ifdef DEBUG
d271 1
a271 1
#endif	/* DEBUG */
d348 1
a348 1
#ifdef DEBUG
d353 1
a353 1
#endif	/* DEBUG */
d381 1
a381 1
#ifdef DEBUG
d384 1
a384 1
#endif	/* DEBUG */
d387 1
a387 1
#ifdef DEBUG
d389 1
a389 1
#endif	/* DEBUG */
d417 1
a417 1
#ifdef DEBUG
d420 1
a420 1
#endif	/* DEBUG*/
d423 1
a423 1
#ifdef DEBUG
d425 1
a425 1
#endif	/* DEBUG*/
d438 1
a438 1
#ifdef DEBUG
d440 1
a440 1
#endif	/* DEBUG */
d462 1
a462 1
#ifdef DEBUG
d464 1
a464 1
#endif	/* DEBUG */
d471 1
a471 1
#ifdef DEBUG
d473 1
a473 1
#endif
d487 1
a487 1
#ifdef DEBUG
d489 1
a489 1
#endif	/* DEBUG */
d499 1
a499 1
#endif
d986 1
a986 1
#ifdef DEBUG
d988 1
a988 1
#endif /* DEBUG */
@


1.16
log
@vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.15 1997/05/29 22:42:00 mickey Exp $	*/
a61 1
#ifdef DDB
d63 2
d66 1
a69 4

#include <vm/vm.h>
#include <vm/vm_param.h>
#include <vm/vm_kern.h>
@


1.15
log
@save symtab id after addition to ddb for future use
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.14 1997/02/06 13:09:13 deraadt Exp $	*/
d63 2
@


1.14
log
@terminate copyinstr, copyoutstr full name; Don.Lewis@@tsc.tdk.com
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.13 1996/10/14 13:01:33 mickey Exp $	*/
d492 1
a492 1
		    db_add_symbol_table(curp->syms,
@


1.13
log
@make gcc -Wall happy for lkms...
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.12 1996/10/02 20:22:13 deraadt Exp $	*/
d210 1
a210 1
	 	*error = copyinstr(name, istr, MAXLKMNAME, NULL);
d213 1
d546 1
a546 1
			  statp->name, MAXLKMNAME - 2, NULL);
@


1.12
log
@copyinstr correctly; spotted by bitblt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.11 1996/09/27 14:41:16 briggs Exp $	*/
a101 1
int lkmdispatch __P((struct lkm_table *, int));
@


1.11
log
@Format type fix (%d -> %ld) in debugging/DDB printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.10 1996/09/16 07:56:19 tholo Exp $	*/
d211 1
a211 1
	 	*error = copyinstr(name, istr, MAXLKMNAME-1, NULL);
@


1.10
log
@Be less verbose if we have been compiled without DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.9 1996/09/09 14:29:26 mickey Exp $	*/
d497 1
a497 1
		    printf("DDB symbols added: %d bytes\n", curp->sym_symsize);
@


1.9
log
@fix db_add_symtab arguments.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.8 1996/09/04 22:24:23 niklas Exp $	*/
d986 1
d988 1
@


1.8
log
@Do not do the if(a = b) game even if correct, it is confusing
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.7 1996/08/29 15:17:37 deraadt Exp $	*/
d495 2
a496 1
					curp->syms, NULL);
@


1.7
log
@lkm ddb symbol table loading. done during the middle ages by jtkohl, merged
to modern day sources by rees@@umich.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.5 1996/06/21 17:03:26 mickey Exp $	*/
d410 3
a412 1
		if (error = copyin(loadbufp->data, curp->syms + curp->sym_offset, i))
@


1.6
log
@-Wall & -Wstrict-prototype fixes
@
text
@d62 5
d77 1
d244 5
d300 1
a300 1
	int error = 0;
d308 1
d321 1
d335 13
d350 1
d386 1
a386 1
			lkm_state = LKMS_LOADED;
d394 34
d452 5
a456 3
			/* The remainder must be bss, so we clear it */
			bzero((caddr_t)curp->area + curp->offset,
			      curp->size - curp->offset);
d469 3
d473 1
a473 1
		error = (*(curp->entry))(curp, LKM_E_LOAD, LKM_VERSION);
d488 9
d514 1
a514 1
		if ((*(curp->entry))(curp, LKM_E_UNLOAD, LKM_VERSION)) {
d982 2
@


1.5
log
@allow LKM listing.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.4 1996/06/21 11:33:30 mickey Exp $	*/
d82 1
a82 1
static struct lkm_table *lkmalloc __P(());  /* allocate new lkm table entry */
d94 1
@


1.4
log
@allocate LKM slot dynamically.
prepare to LKM symtabs, cross deps, etc!
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_lkm.c,v 1.2 1996/03/03 17:19:47 niklas Exp $	*/
d176 12
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@a65 3

#define PAGESIZE 1024		/* kmem_alloc() allocation quantum */

d78 7
a84 7
#ifndef MAXLKMS
#define	MAXLKMS		20
#endif

static struct lkm_table	lkmods[MAXLKMS];	/* table of loaded modules */
static struct lkm_table	*curp;			/* global for in-progress ops */

d97 6
d135 3
d142 72
d252 1
a252 1
	if (curp && !curp->used) {
a276 1
	int i;
a280 1
	char istr[MAXLKMNAME];
d292 1
a292 7
		/*
		 * Find a free slot.
		 */
		for (i = 0; i < MAXLKMS; i++)
			if (!lkmods[i].used)
				break;
		if (i == MAXLKMS) {
d296 1
a296 4
		curp = &lkmods[i];
		curp->id = i;		/* self reference slot offset */

		resrvp->slot = i;		/* return slot */
a324 1
		i = loadbufp->cnt;
d326 3
a328 3
		    || i < 0
		    || i > MODIOBUF
		    || i > curp->size - curp->offset) {
d335 1
a335 1
			       (caddr_t)curp->area + curp->offset, i);
d339 1
a339 1
		if ((curp->offset + i) < curp->size) {
d343 1
a343 1
			curp->offset, curp->size, i);
d351 1
a351 1
		curp->offset += i;
d402 1
a402 1
			curp->used = 0;			/* free slot */
a405 1
		curp->used = 1;
d407 1
a407 1
		printf("LKM: LMREADY\n");
d409 1
d422 2
a423 36
		if ((i = unloadp->id) == -1) {		/* unload by name */
			/*
			 * Copy name and lookup id from all loaded
			 * modules.  May fail.
			 */
		 	error = copyinstr(unloadp->name, istr, MAXLKMNAME-1,
					  NULL);
			if (error)
				break;

			/*
			 * look up id...
			 */
			for (i = 0; i < MAXLKMS; i++) {
				if (!lkmods[i].used)
					continue;
				if (!strcmp(istr,
				        lkmods[i].private.lkm_any->lkm_name))
					break;
			}
		}

		/*
		 * Range check the value; on failure, return EINVAL
		 */
		if (i < 0 || i >= MAXLKMS) {
			error = EINVAL;
			break;
		}

		curp = &lkmods[i];

		if (!curp->used) {
			error = ENOENT;
			break;
		}
d433 1
a433 1
		curp->used = 0;			/* free slot */
d441 2
a442 37
		if ((i = statp->id) == -1) {		/* stat by name */
			/*
			 * Copy name and lookup id from all loaded
			 * modules.
			 */
		 	copystr(statp->name, istr, MAXLKMNAME-1, (size_t *)0);
			/*
			 * look up id...
			 */
			for (i = 0; i < MAXLKMS; i++) {
				if (!lkmods[i].used)
					continue;
				if (!strcmp(istr,
				        lkmods[i].private.lkm_any->lkm_name))
					break;
			}

			if (i == MAXLKMS) {		/* Not found */
				error = ENOENT;
				break;
			}
		}

		/*
		 * Range check the value; on failure, return EINVAL
		 */
		if (i < 0 || i >= MAXLKMS) {
			error = EINVAL;
			break;
		}

		curp = &lkmods[i];

		if (!curp->used) {			/* Not found */
			error = ENOENT;
			break;
		}
d451 1
a451 1
		statp->size	= curp->size / PAGESIZE;
d454 2
a455 4
		copystr(curp->private.lkm_any->lkm_name, 
			  statp->name,
			  MAXLKMNAME - 2,
			  (size_t *)0);
d514 1
a514 1
	int i;
d519 1
a519 7
	for (i = 0; i < MAXLKMS; i++) {
		/*
		 * An unused module and the one we are testing are not
		 * considered.
		 */
		if (!lkmods[i].used || &lkmods[i] == lkmtp)
			continue;
d521 1
a521 1
			lkmods[i].private.lkm_any->lkm_name))
a522 1
	}
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: kern_lkm.c,v 1.28 1996/02/09 18:59:38 christos Exp $	*/
d57 1
a57 2

#include <kern/kern_conf.h>
d243 2
a244 2
		printf("LKM: LMRESERV (actual   = 0x%08x)\n", curp->area);
		printf("LKM: LMRESERV (adjusted = 0x%08x)\n",
d276 1
a276 1
			printf("LKM: LMLOADBUF (loading @@ %d of %d, i = %d)\n",
d496 1
a496 4
lkmenodev(dev, oflags, devtype, p)
	dev_t dev;
	int oflags, devtype;
	struct proc *p;
d700 2
a701 1
					if (bdevsw[i].d_open == lkmenodev)
d731 2
a732 1
					if (cdevsw[i].d_open == lkmenodev)
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: kern_lkm.c,v 1.26 1995/10/10 00:23:20 thorpej Exp $	*/
a47 1
#include <sys/conf.h>
d56 4
d67 1
d89 12
d127 2
a128 1
		if (error = tsleep((caddr_t)&lkm_v, TTIPRI|PCATCH, "lkmopn", 0))
d141 1
a141 1
static int
d192 1
a192 1
lkmioctl(dev, cmd, data, flag)
d197 1
d199 1
a199 1
	int err = 0;
a204 1
	int (*funcp)();
d224 1
a224 1
			err = ENOMEM;		/* no slots available */
d264 1
a264 1
			err = ENOMEM;
d269 3
a271 1
		if (err = copyin((caddr_t)loadbufp->data, (caddr_t)curp->area + curp->offset, i))
d325 2
a326 1
		curp->entry = (int (*)()) (*((long *) (data)));
d329 2
a330 1
		if (err = (*(curp->entry))(curp, LKM_E_LOAD, LKM_VERSION)) {
d362 3
a364 2
		 	if (err = copyinstr(unloadp->name, istr, MAXLKMNAME-1,
			    (size_t *)0))
d383 1
a383 1
			err = EINVAL;
d390 1
a390 1
			err = ENOENT;
d396 1
a396 1
			err = EBUSY;
d428 1
a428 1
				err = ENOENT;
d437 1
a437 1
			err = EINVAL;
d444 1
a444 1
			err = ENOENT;
d466 1
a466 1
		err = ENOTTY;
d470 1
a470 1
	return (err);
d554 1
a554 1
	int err = 0;
d571 1
a571 1
				err = ENFILE;
d576 1
a576 1
				err = EINVAL;
d605 1
a605 1
	return (err);
d619 1
a619 1
	int err = 0;
d631 2
a632 1
			    args->lkm_vfsops->vfs_name, MFSNAMELEN) == 0)
d640 1
a640 1
			err = EINVAL;
d674 1
a674 1
	return (err);
d688 1
a688 1
	int err = 0;
d708 1
a708 1
					err = ENFILE;
d713 1
a713 1
					err = EINVAL;
d738 1
a738 1
					err = ENFILE;
d743 1
a743 1
					err = EINVAL;
d760 1
a760 1
			err = ENODEV;
d781 1
a781 1
			err = ENODEV;
d790 1
a790 1
	return (err);
d805 1
a805 1
	int err = 0;
d821 1
a821 1
	return (err);
d836 1
a836 1
	int err = 0;
d853 1
a853 1
				err = ENFILE;
d858 1
a858 1
				err = EINVAL;
d893 1
a893 1
	return (err);
d907 1
a907 1
	int err = 0;		/* default = success */
d911 1
a911 1
		err = _lkm_syscall(lkmtp, cmd);
d915 1
a915 1
		err = _lkm_vfs(lkmtp, cmd);
d919 1
a919 1
		err = _lkm_dev(lkmtp, cmd);
d932 1
a932 1
		err = _lkm_exec(lkmtp, cmd);
d939 1
a939 1
		err = ENXIO;	/* unknown type */
d943 1
a943 1
	return (err);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

