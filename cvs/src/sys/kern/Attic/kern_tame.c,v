head	1.72;
access;
symbols
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18;
locks; strict;
comment	@ * @;


1.72
date	2015.10.09.01.17.21;	author deraadt;	state dead;
branches;
next	1.71;
commitid	6ulbDS81ej0XxvnS;

1.71
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	av6ZVErLSWkVP5Zz;

1.70
date	2015.10.08.17.29.43;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	hnJbXUn2yElhWXFF;

1.69
date	2015.10.08.13.25.04;	author deraadt;	state Exp;
branches;
next	1.68;
commitid	zD55lphD0g0Wt56y;

1.68
date	2015.10.08.13.21.06;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	dAm3vdIMrocOi1DU;

1.67
date	2015.10.07.19.52.54;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	IGhnuDU3vY4XDUz1;

1.66
date	2015.10.07.03.47.43;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	Ge0gajSA2YHu7mGQ;

1.65
date	2015.10.06.18.35.09;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	j2maOrUzg7k1I2D7;

1.64
date	2015.10.06.18.15.02;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	jWUm8suTnRhfeo1L;

1.63
date	2015.10.06.17.05.30;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	a3u7WQegN1tuIEuI;

1.62
date	2015.10.06.15.21.26;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	ZuHSGSKpxfpgDZgj;

1.61
date	2015.10.06.14.55.41;	author claudio;	state Exp;
branches;
next	1.60;
commitid	aKDI9c1pZxa7lXR3;

1.60
date	2015.10.06.14.38.23;	author deraadt;	state Exp;
branches;
next	1.59;
commitid	ezI4v050sQmwUQBC;

1.59
date	2015.10.06.14.02.49;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	7ltrUsagcDA0jJuA;

1.58
date	2015.10.06.05.42.12;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	mEn2DvBJAQNrsRCp;

1.57
date	2015.10.04.17.55.21;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	XwcHA8D8ELYXEZI1;

1.56
date	2015.10.04.04.08.25;	author deraadt;	state Exp;
branches;
next	1.55;
commitid	UHz4HillX3khxDif;

1.55
date	2015.10.04.01.56.54;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	JE4Y9Zjk411NYKhs;

1.54
date	2015.10.03.23.52.30;	author guenther;	state Exp;
branches;
next	1.53;
commitid	7fZFfLhcNPssv7ez;

1.53
date	2015.10.02.20.48.48;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	EGAPALxX0zu1J1YM;

1.52
date	2015.10.02.20.42.26;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	BW5Pda2HfvrLwqHz;

1.51
date	2015.10.02.05.30.30;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	ntjHHv4vF5xV5S2V;

1.50
date	2015.10.02.02.13.59;	author deraadt;	state Exp;
branches;
next	1.49;
commitid	lcBac0YSqv8SSUdr;

1.49
date	2015.10.02.02.12.08;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	q1gMGHpjM4bmOx2q;

1.48
date	2015.10.02.01.44.52;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	TZCJphBozUuVD8pg;

1.47
date	2015.10.01.23.50.37;	author doug;	state Exp;
branches;
next	1.46;
commitid	BrIZEPnqrFyLfoME;

1.46
date	2015.10.01.10.17.27;	author sthen;	state Exp;
branches;
next	1.45;
commitid	37vw0ukpcvYyAK9b;

1.45
date	2015.09.30.11.36.07;	author semarie;	state Exp;
branches;
next	1.44;
commitid	TMIPnGR2J26p7mlU;

1.44
date	2015.09.29.14.41.27;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	civTCFX42Z1WEUxQ;

1.43
date	2015.09.28.15.40.18;	author semarie;	state Exp;
branches;
next	1.42;
commitid	r1EbZLbyjDs5Df4X;

1.42
date	2015.09.19.20.39.06;	author semarie;	state Exp;
branches;
next	1.41;
commitid	edPdYQKveuw1Sbd8;

1.41
date	2015.09.13.17.08.03;	author guenther;	state Exp;
branches;
next	1.40;
commitid	BssYI6s6zozAyfkk;

1.40
date	2015.09.11.15.29.47;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	0NZe9BgjJety4Dtk;

1.39
date	2015.09.11.08.22.31;	author guenther;	state Exp;
branches;
next	1.38;
commitid	Lqreadw8v5IPAc0L;

1.38
date	2015.09.09.17.56.59;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	LR11yk102SoyZdKV;

1.37
date	2015.09.01.18.26.19;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	wnBaLIn8JylaNIgB;

1.36
date	2015.09.01.09.19.21;	author semarie;	state Exp;
branches;
next	1.35;
commitid	FGtL2C4WPPJmvYnf;

1.35
date	2015.08.31.16.17.53;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	SqPA2zvntamgumOd;

1.34
date	2015.08.31.00.51.20;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	VWc2v5830YAMZFzi;

1.33
date	2015.08.26.14.46.22;	author semarie;	state Exp;
branches;
next	1.32;
commitid	AxoeFxjeSo4N2gfv;

1.32
date	2015.08.26.06.33.57;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	5Jednaa7MGapbQVM;

1.31
date	2015.08.26.05.55.53;	author doug;	state Exp;
branches;
next	1.30;
commitid	GKmxn2JABuE79Vad;

1.30
date	2015.08.26.05.20.06;	author doug;	state Exp;
branches;
next	1.29;
commitid	B5zLNz9UGGYolarc;

1.29
date	2015.08.25.15.35.44;	author jsg;	state Exp;
branches;
next	1.28;
commitid	IMCqz0gG6J1GGaNX;

1.28
date	2015.08.24.06.19.39;	author semarie;	state Exp;
branches;
next	1.27;
commitid	2FUiKMQabyKNTUUW;

1.27
date	2015.08.24.06.17.48;	author doug;	state Exp;
branches;
next	1.26;
commitid	kWhg1GtbVfNiqJGb;

1.26
date	2015.08.23.21.30.04;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	PzgvA1HdxT7cshVV;

1.25
date	2015.08.23.19.32.20;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	3EXXnYubxazkmtSA;

1.24
date	2015.08.23.16.41.55;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	P2sSpZtwWkGSjbnr;

1.23
date	2015.08.23.16.39.30;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	lNhaU5Hpwculrxd1;

1.22
date	2015.08.23.14.20.59;	author semarie;	state Exp;
branches;
next	1.21;
commitid	jGK9MEddZekp0rpL;

1.21
date	2015.08.22.20.18.49;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	6NDuzTPjBp2GqkfQ;

1.20
date	2015.08.21.07.26.09;	author doug;	state Exp;
branches;
next	1.19;
commitid	REKU4QrYg7M2FSKo;

1.19
date	2015.08.20.06.00.23;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	tI4aXDrstHpK8IcB;

1.18
date	2015.07.29.17.55.27;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	b7rNxx1wmMdL6WUO;

1.17
date	2015.07.28.15.22.25;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	moA8QuVyWFnzHz5B;

1.16
date	2015.07.27.18.22.37;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	4VS4Pd5BumhjJccK;

1.15
date	2015.07.27.15.02.36;	author semarie;	state Exp;
branches;
next	1.14;
commitid	m0DNf5ZLVFu0vumj;

1.14
date	2015.07.23.02.57.51;	author doug;	state Exp;
branches;
next	1.13;
commitid	F5IlpEXK6FYM1wmH;

1.13
date	2015.07.22.05.32.44;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	KDSQ5ccvYX9keTHm;

1.12
date	2015.07.21.16.17.17;	author guenther;	state Exp;
branches;
next	1.11;
commitid	s2dDIB5nR7bbpiA8;

1.11
date	2015.07.20.21.36.27;	author tedu;	state Exp;
branches;
next	1.10;
commitid	Ba8RjZJ0sLAkGtw5;

1.10
date	2015.07.20.18.58.53;	author jeremy;	state Exp;
branches;
next	1.9;
commitid	2h9mf1JBUex2occL;

1.9
date	2015.07.20.18.04.05;	author schwarze;	state Exp;
branches;
next	1.8;
commitid	g9Ja86yiGSNNq64y;

1.8
date	2015.07.20.17.01.26;	author nicm;	state Exp;
branches;
next	1.7;
commitid	LYVwMZqztUEFNyOB;

1.7
date	2015.07.20.16.48.07;	author nicm;	state Exp;
branches;
next	1.6;
commitid	BDF9a64PlZRYrgw5;

1.6
date	2015.07.20.16.15.40;	author nicm;	state Exp;
branches;
next	1.5;
commitid	sw8WaqLBSBuLGCKx;

1.5
date	2015.07.20.15.52.18;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	ViHRo4yl9UhOG2ZN;

1.4
date	2015.07.20.15.26.28;	author nicm;	state Exp;
branches;
next	1.3;
commitid	yQHLRdGikSs6Lpyj;

1.3
date	2015.07.20.02.43.26;	author deraadt;	state Exp;
branches;
next	1.2;
commitid	QHeYIIZCj4tI4ZiY;

1.2
date	2015.07.19.21.25.32;	author deraadt;	state Exp;
branches;
next	1.1;
commitid	nFfvQqigHXAtKrmZ;

1.1
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	;
commitid	CJwjm9NDWu6nJ6ES;


desc
@@


1.72
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@/*	$OpenBSD: kern_tame.c,v 1.71 2015/10/09 01:10:27 deraadt Exp $	*/

/*
 * Copyright (c) 2015 Nicholas Marriott <nicm@@openbsd.org>
 * Copyright (c) 2015 Theo de Raadt <deraadt@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/types.h>

#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/fcntl.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/vnode.h>
#include <sys/mbuf.h>
#include <sys/sysctl.h>
#include <sys/ktrace.h>

#include <sys/ioctl.h>
#include <sys/termios.h>
#include <sys/mtio.h>
#include <net/bpf.h>
#include <net/route.h>
#include <net/if.h>
#include <netinet/in.h>
#include <netinet/tcp.h>

#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/syscall.h>
#include <sys/syscallargs.h>
#include <sys/systm.h>
#include <sys/pledge.h>

int canonpath(const char *input, char *buf, size_t bufsize);

const u_int pledge_syscalls[SYS_MAXSYSCALL] = {
	[SYS_exit] = 0xffffffff,
	[SYS_kbind] = 0xffffffff,

	[SYS_getuid] = PLEDGE_SELF,
	[SYS_geteuid] = PLEDGE_SELF,
	[SYS_getresuid] = PLEDGE_SELF,
	[SYS_getgid] = PLEDGE_SELF,
	[SYS_getegid] = PLEDGE_SELF,
	[SYS_getresgid] = PLEDGE_SELF,
	[SYS_getgroups] = PLEDGE_SELF,
	[SYS_getlogin] = PLEDGE_SELF,
	[SYS_getpgrp] = PLEDGE_SELF,
	[SYS_getpgid] = PLEDGE_SELF,
	[SYS_getppid] = PLEDGE_SELF,
	[SYS_getsid] = PLEDGE_SELF,
	[SYS_getthrid] = PLEDGE_SELF,
	[SYS_getrlimit] = PLEDGE_SELF,
	[SYS_gettimeofday] = PLEDGE_SELF,
	[SYS_getdtablecount] = PLEDGE_SELF,
	[SYS_getrusage] = PLEDGE_SELF,
	[SYS_issetugid] = PLEDGE_SELF,
	[SYS_clock_getres] = PLEDGE_SELF,
	[SYS_clock_gettime] = PLEDGE_SELF,
	[SYS_getpid] = PLEDGE_SELF,
	[SYS_umask] = PLEDGE_SELF,
	[SYS_sysctl] = PLEDGE_SELF,	/* read-only; narrow subset */
	[SYS_adjtime] = PLEDGE_SELF,	/* read-only */

	[SYS_fchdir] = PLEDGE_SELF,	/* careful of directory fd inside jails */

	/* needed by threaded programs */
	[SYS_sched_yield] = PLEDGE_SELF,
	[SYS___thrsleep] = PLEDGE_SELF,
	[SYS___thrwakeup] = PLEDGE_SELF,
	[SYS___threxit] = PLEDGE_SELF,
	[SYS___thrsigdivert] = PLEDGE_SELF,

	[SYS_sendsyslog] = PLEDGE_SELF,
	[SYS_nanosleep] = PLEDGE_SELF,
	[SYS_sigprocmask] = PLEDGE_SELF,
	[SYS_sigaction] = PLEDGE_SELF,
	[SYS_sigreturn] = PLEDGE_SELF,
	[SYS_sigpending] = PLEDGE_SELF,
	[SYS_getitimer] = PLEDGE_SELF,
	[SYS_setitimer] = PLEDGE_SELF,

	[SYS_pledge] = PLEDGE_SELF,

	[SYS_wait4] = PLEDGE_SELF,

	[SYS_poll] = PLEDGE_RW,
	[SYS_kevent] = PLEDGE_RW,
	[SYS_kqueue] = PLEDGE_RW,
	[SYS_select] = PLEDGE_RW,

	[SYS_close] = PLEDGE_RW,
	[SYS_dup] = PLEDGE_RW,
	[SYS_dup2] = PLEDGE_RW,
	[SYS_dup3] = PLEDGE_RW,
	[SYS_closefrom] = PLEDGE_RW,
	[SYS_shutdown] = PLEDGE_RW,
	[SYS_read] = PLEDGE_RW,
	[SYS_readv] = PLEDGE_RW,
	[SYS_pread] = PLEDGE_RW,
	[SYS_preadv] = PLEDGE_RW,
	[SYS_write] = PLEDGE_RW,
	[SYS_writev] = PLEDGE_RW,
	[SYS_pwrite] = PLEDGE_RW,
	[SYS_pwritev] = PLEDGE_RW,
	[SYS_ftruncate] = PLEDGE_RW,
	[SYS_lseek] = PLEDGE_RW,
	[SYS_fstat] = PLEDGE_RW,

	[SYS_fcntl] = PLEDGE_RW,
	[SYS_fsync] = PLEDGE_RW,
	[SYS_pipe] = PLEDGE_RW,
	[SYS_pipe2] = PLEDGE_RW,
	[SYS_socketpair] = PLEDGE_RW,
	[SYS_getdents] = PLEDGE_RW,

	[SYS_sendto] = PLEDGE_RW | PLEDGE_DNS_ACTIVE | PLEDGE_YP_ACTIVE,
	[SYS_sendmsg] = PLEDGE_RW,
	[SYS_recvmsg] = PLEDGE_RW,
	[SYS_recvfrom] = PLEDGE_RW | PLEDGE_DNS_ACTIVE | PLEDGE_YP_ACTIVE,

	[SYS_fork] = PLEDGE_PROC,
	[SYS_vfork] = PLEDGE_PROC,
	[SYS_kill] = PLEDGE_PROC,
	[SYS_setpgid] = PLEDGE_PROC,
	[SYS_sigsuspend] = PLEDGE_PROC,
	[SYS_setrlimit] = PLEDGE_PROC,

	[SYS_execve] = PLEDGE_EXEC,

	[SYS_setgroups] = PLEDGE_PROC,
	[SYS_setresgid] = PLEDGE_PROC,
	[SYS_setresuid] = PLEDGE_PROC,

	/* FIONREAD/FIONBIO, plus further checks in pledge_ioctl_check() */
	[SYS_ioctl] = PLEDGE_RW | PLEDGE_IOCTL | PLEDGE_TTY,

	[SYS_getentropy] = PLEDGE_MALLOC,
	[SYS_madvise] = PLEDGE_MALLOC,
	[SYS_minherit] = PLEDGE_MALLOC,
	[SYS_mmap] = PLEDGE_MALLOC,
	[SYS_mprotect] = PLEDGE_MALLOC,
	[SYS_mquery] = PLEDGE_MALLOC,
	[SYS_munmap] = PLEDGE_MALLOC,

	[SYS_open] = PLEDGE_SELF,			/* further checks in namei */
	[SYS_stat] = PLEDGE_SELF,			/* further checks in namei */
	[SYS_access] = PLEDGE_SELF,		/* further checks in namei */
	[SYS_readlink] = PLEDGE_SELF,		/* further checks in namei */

	[SYS_chdir] = PLEDGE_RPATH,
	[SYS_openat] = PLEDGE_RPATH | PLEDGE_WPATH,
	[SYS_fstatat] = PLEDGE_RPATH | PLEDGE_WPATH,
	[SYS_faccessat] = PLEDGE_RPATH | PLEDGE_WPATH,
	[SYS_readlinkat] = PLEDGE_RPATH | PLEDGE_WPATH,
	[SYS_lstat] = PLEDGE_RPATH | PLEDGE_WPATH | PLEDGE_TMPPATH,
	[SYS_rename] = PLEDGE_CPATH,
	[SYS_rmdir] = PLEDGE_CPATH,
	[SYS_renameat] = PLEDGE_CPATH,
	[SYS_link] = PLEDGE_CPATH,
	[SYS_linkat] = PLEDGE_CPATH,
	[SYS_symlink] = PLEDGE_CPATH,
	[SYS_unlink] = PLEDGE_CPATH | PLEDGE_TMPPATH,
	[SYS_unlinkat] = PLEDGE_CPATH,
	[SYS_mkdir] = PLEDGE_CPATH,
	[SYS_mkdirat] = PLEDGE_CPATH,

	/*
	 * Classify as RPATH|WPATH, because of path information leakage.
	 * WPATH due to unknown use of mk*temp(3) on non-/tmp paths..
	 */
	[SYS___getcwd] = PLEDGE_RPATH | PLEDGE_WPATH,

	/* Classify as RPATH, because these leak path information */
	[SYS_getfsstat] = PLEDGE_RPATH,
	[SYS_statfs] = PLEDGE_RPATH,
	[SYS_fstatfs] = PLEDGE_RPATH,

	[SYS_utimes] = PLEDGE_FATTR,
	[SYS_futimes] = PLEDGE_FATTR,
	[SYS_utimensat] = PLEDGE_FATTR,
	[SYS_futimens] = PLEDGE_FATTR,
	[SYS_chmod] = PLEDGE_FATTR,
	[SYS_fchmod] = PLEDGE_FATTR,
	[SYS_fchmodat] = PLEDGE_FATTR,
	[SYS_chflags] = PLEDGE_FATTR,
	[SYS_chflagsat] = PLEDGE_FATTR,
	[SYS_chown] = PLEDGE_FATTR,
	[SYS_fchownat] = PLEDGE_FATTR,
	[SYS_lchown] = PLEDGE_FATTR,
	[SYS_fchown] = PLEDGE_FATTR,

	[SYS_socket] = PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS_ACTIVE | PLEDGE_YP_ACTIVE,
	[SYS_connect] = PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS_ACTIVE | PLEDGE_YP_ACTIVE,

	[SYS_listen] = PLEDGE_INET | PLEDGE_UNIX,
	[SYS_bind] = PLEDGE_INET | PLEDGE_UNIX,
	[SYS_accept4] = PLEDGE_INET | PLEDGE_UNIX,
	[SYS_accept] = PLEDGE_INET | PLEDGE_UNIX,
	[SYS_getpeername] = PLEDGE_INET | PLEDGE_UNIX,
	[SYS_getsockname] = PLEDGE_INET | PLEDGE_UNIX,
	[SYS_setsockopt] = PLEDGE_INET | PLEDGE_UNIX,
	[SYS_getsockopt] = PLEDGE_INET | PLEDGE_UNIX,

	[SYS_flock] = PLEDGE_GETPW,
};

static const struct {
	char *name;
	int flags;
} pledgereq[] = {
	{ "malloc",		PLEDGE_SELF | PLEDGE_MALLOC },
	{ "rw",			PLEDGE_SELF | PLEDGE_RW },
	{ "stdio",		PLEDGE_SELF | PLEDGE_MALLOC | PLEDGE_RW },
	{ "rpath",		PLEDGE_SELF | PLEDGE_RW | PLEDGE_RPATH },
	{ "wpath",		PLEDGE_SELF | PLEDGE_RW | PLEDGE_WPATH },
	{ "tmppath",		PLEDGE_SELF | PLEDGE_RW | PLEDGE_TMPPATH },
	{ "inet",		PLEDGE_SELF | PLEDGE_RW | PLEDGE_INET },
	{ "unix",		PLEDGE_SELF | PLEDGE_RW | PLEDGE_UNIX },
	{ "dns",		PLEDGE_SELF | PLEDGE_MALLOC | PLEDGE_DNSPATH },
	{ "getpw",		PLEDGE_SELF | PLEDGE_MALLOC | PLEDGE_RW | PLEDGE_GETPW },
/*X*/	{ "cmsg",		PLEDGE_UNIX | PLEDGE_INET | PLEDGE_SENDFD | PLEDGE_RECVFD },
	{ "sendfd",		PLEDGE_RW | PLEDGE_SENDFD },
	{ "recvfd",		PLEDGE_RW | PLEDGE_RECVFD },
	{ "ioctl",		PLEDGE_IOCTL },
	{ "route",		PLEDGE_ROUTE },
	{ "mcast",		PLEDGE_MCAST },
	{ "tty",		PLEDGE_TTY },
	{ "proc",		PLEDGE_PROC },
	{ "exec",		PLEDGE_EXEC },
	{ "cpath",		PLEDGE_CPATH },
	{ "abort",		PLEDGE_ABORT },
	{ "fattr",		PLEDGE_FATTR },
	{ "prot_exec",		PLEDGE_PROTEXEC },
};

int
sys_pledge(struct proc *p, void *v, register_t *retval)
{
	struct sys_pledge_args /* {
		syscallarg(const char *)request;
		syscallarg(const char **)paths;
	} */	*uap = v;
	int flags = 0;
	int error;

	if (SCARG(uap, request)) {
		size_t rbuflen;
		char *rbuf, *rp, *pn;
		int f, i;

		rbuf = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
		error = copyinstr(SCARG(uap, request), rbuf, MAXPATHLEN,
		    &rbuflen);
		if (error) {
			free(rbuf, M_TEMP, MAXPATHLEN);
			return (error);
		}
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrstruct(p, "pledgereq", rbuf, rbuflen-1);
#endif

		for (rp = rbuf; rp && *rp && error == 0; rp = pn) {
			pn = strchr(rp, ' ');	/* find terminator */
			if (pn) {
				while (*pn == ' ')
					*pn++ = '\0';
			}

			for (f = i = 0; i < nitems(pledgereq); i++) {
				if (strcmp(rp, pledgereq[i].name) == 0) {
					f = pledgereq[i].flags;
					break;
				}
			}
			if (f == 0) {
				free(rbuf, M_TEMP, MAXPATHLEN);
				return (EINVAL);
			}
			flags |= f;
		}
		free(rbuf, M_TEMP, MAXPATHLEN);
	}

	if (flags & ~PLEDGE_USERSET)
		return (EINVAL);

	if ((p->p_p->ps_flags & PS_PLEDGE)) {
		/* Already pledged, only allow reductions */
		if (((flags | p->p_p->ps_pledge) & PLEDGE_USERSET) !=
		    (p->p_p->ps_pledge & PLEDGE_USERSET)) {
			return (EPERM);
		}

		flags &= p->p_p->ps_pledge;
		flags &= PLEDGE_USERSET;		/* Relearn _ACTIVE */
	}

	if (SCARG(uap, paths)) {
		const char **u = SCARG(uap, paths), *sp;
		struct whitepaths *wl;
		char *cwdpath = NULL, *path;
		size_t cwdpathlen = MAXPATHLEN * 4, cwdlen, len, maxargs = 0;
		int i, error;

		if (p->p_p->ps_pledgepaths)
			return (EPERM);

		/* Count paths */
		for (i = 0; i < PLEDGE_MAXPATHS; i++) {
			if ((error = copyin(u + i, &sp, sizeof(sp))) != 0)
				return (error);
			if (sp == NULL)
				break;
		}
		if (i == PLEDGE_MAXPATHS)
			return (E2BIG);

		wl = malloc(sizeof *wl + sizeof(struct whitepath) * (i+1),
		    M_TEMP, M_WAITOK | M_ZERO);
		wl->wl_size = sizeof *wl + sizeof(struct whitepath) * (i+1);
		wl->wl_count = i;
		wl->wl_ref = 1;

		path = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);

		/* Copy in */
		for (i = 0; i < wl->wl_count; i++) {
			char *fullpath = NULL, *builtpath = NULL, *canopath = NULL, *cwd;
			size_t builtlen = 0;

			if ((error = copyin(u + i, &sp, sizeof(sp))) != 0)
				break;
			if (sp == NULL)
				break;
			if ((error = copyinstr(sp, path, MAXPATHLEN, &len)) != 0)
				break;
#ifdef KTRACE
			if (KTRPOINT(p, KTR_STRUCT))
				ktrstruct(p, "pledgepath", path, len-1);
#endif

			/* If path is relative, prepend cwd */
			if (path[0] != '/') {
				if (cwdpath == NULL) {
					char *bp, *bpend;

					cwdpath = malloc(cwdpathlen, M_TEMP, M_WAITOK);
					bp = &cwdpath[cwdpathlen];
					bpend = bp;
					*(--bp) = '\0';

					error = vfs_getcwd_common(p->p_fd->fd_cdir,
					    NULL, &bp, cwdpath, cwdpathlen/2,
					    GETCWD_CHECK_ACCESS, p);
					if (error)
						break;
					cwd = bp;
					cwdlen = (bpend - bp);
				}

				/* NUL included in cwd component */
				builtlen = cwdlen + 1 + strlen(path);
				if (builtlen > PATH_MAX) {
					error = ENAMETOOLONG;
					break;
				}
				builtpath = malloc(builtlen, M_TEMP, M_WAITOK);
				snprintf(builtpath, builtlen, "%s/%s", cwd, path);
				// printf("pledge: builtpath = %s\n", builtpath);
				fullpath = builtpath;
			} else
				fullpath = path;

			canopath = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
			error = canonpath(fullpath, canopath, MAXPATHLEN);

			free(builtpath, M_TEMP, builtlen);
			if (error != 0) {
				free(canopath, M_TEMP, MAXPATHLEN);
				break;
			}

			len = strlen(canopath) + 1;

			//printf("pledge: canopath = %s %lld strlen %lld\n", canopath,
			//    (long long)len, (long long)strlen(canopath));

			if (maxargs += len > ARG_MAX) {
				error = E2BIG;
				break;
			}
			wl->wl_paths[i].name = malloc(len, M_TEMP, M_WAITOK);
			memcpy(wl->wl_paths[i].name, canopath, len);
			wl->wl_paths[i].len = len;
			free(canopath, M_TEMP, MAXPATHLEN);
		}
		free(path, M_TEMP, MAXPATHLEN);
		free(cwdpath, M_TEMP, cwdpathlen);

		if (error) {
			for (i = 0; i < wl->wl_count; i++)
				free(wl->wl_paths[i].name,
				    M_TEMP, wl->wl_paths[i].len);
			free(wl, M_TEMP, wl->wl_size);
			return (error);
		}
		p->p_p->ps_pledgepaths = wl;
#if 0
		printf("pledge: %s(%d): paths loaded:\n", p->p_comm, p->p_pid);
		for (i = 0; i < wl->wl_count; i++)
			if (wl->wl_paths[i].name)
				printf("pledge: %d=%s %lld\n", i, wl->wl_paths[i].name,
				    (long long)wl->wl_paths[i].len);
#endif
	}

	p->p_p->ps_pledge = flags;
	p->p_p->ps_flags |= PS_PLEDGE;
	return (0);
}

int
pledge_check(struct proc *p, int code)
{
	p->p_pledgenote = p->p_pledgeafter = 0;	/* XX optimise? */
	p->p_pledge_syscall = code;

	if (code < 0 || code > SYS_MAXSYSCALL - 1)
		return (0);

	if (p->p_p->ps_pledge == 0)
		return (code == SYS_exit || code == SYS_kbind);
	return (p->p_p->ps_pledge & pledge_syscalls[code]);
}

int
pledge_fail(struct proc *p, int error, int code)
{
	printf("%s(%d): syscall %d\n", p->p_comm, p->p_pid, p->p_pledge_syscall);
	if (p->p_p->ps_pledge & PLEDGE_ABORT) {	/* Core dump requested */
		struct sigaction sa;

		memset(&sa, 0, sizeof sa);
		sa.sa_handler = SIG_DFL;
		setsigvec(p, SIGABRT, &sa);
		psignal(p, SIGABRT);
	} else
		psignal(p, SIGKILL);

	p->p_p->ps_pledge = 0;		/* Disable all PLEDGE_ flags */
	return (error);
}

/*
 * Need to make it more obvious that one cannot get through here
 * without the right flags set
 */
int
pledge_namei(struct proc *p, char *origpath)
{
	char path[PATH_MAX];

	if (p->p_pledgenote == TMN_COREDUMP)
		return (0);			/* Allow a coredump */

	if (canonpath(origpath, path, sizeof(path)) != 0)
		return (pledge_fail(p, EPERM, PLEDGE_RPATH));

	if ((p->p_pledgenote & TMN_FATTR) &&
	    (p->p_p->ps_pledge & PLEDGE_FATTR) == 0) {
		printf("%s(%d): inode syscall%d, not allowed\n",
		    p->p_comm, p->p_pid, p->p_pledge_syscall);
		return (pledge_fail(p, EPERM, PLEDGE_FATTR));
	}

	/* Detect what looks like a mkstemp(3) family operation */
	if ((p->p_p->ps_pledge & PLEDGE_TMPPATH) &&
	    (p->p_pledge_syscall == SYS_open) &&
	    (p->p_pledgenote & TMN_CPATH) &&
	    strncmp(path, "/tmp/", sizeof("/tmp/") - 1) == 0) {
		return (0);
	}

	/* Allow unlinking of a mkstemp(3) file...
	 * Good opportunity for strict checks here.
	 */
	if ((p->p_p->ps_pledge & PLEDGE_TMPPATH) &&
	    (p->p_pledge_syscall == SYS_unlink) &&
	    strncmp(path, "/tmp/", sizeof("/tmp/") - 1) == 0) {
		return (0);
	}

	/* open, mkdir, or other path creation operation */
	if ((p->p_pledgenote & TMN_CPATH) &&
	    ((p->p_p->ps_pledge & PLEDGE_CPATH) == 0))
		return (pledge_fail(p, EPERM, PLEDGE_CPATH));

	if ((p->p_pledgenote & TMN_WPATH) &&
	    (p->p_p->ps_pledge & PLEDGE_WPATH) == 0)
		return (pledge_fail(p, EPERM, PLEDGE_WPATH));

	/* Read-only paths used occasionally by libc */
	switch (p->p_pledge_syscall) {
	case SYS_access:
		/* tzset() needs this. */
		if ((p->p_pledgenote == TMN_RPATH) &&
		    strcmp(path, "/etc/localtime") == 0)
			return (0);
		break;
	case SYS_open:
		/* getpw* and friends need a few files */
		if ((p->p_pledgenote == TMN_RPATH) &&
		    (p->p_p->ps_pledge & PLEDGE_GETPW)) {
			if (strcmp(path, "/etc/spwd.db") == 0)
				return (EPERM);
			if (strcmp(path, "/etc/pwd.db") == 0)
				return (0);
			if (strcmp(path, "/etc/group") == 0)
				return (0);
		}

		/* DNS needs /etc/{resolv.conf,hosts,services}. */
		if ((p->p_pledgenote == TMN_RPATH) &&
		    (p->p_p->ps_pledge & PLEDGE_DNSPATH)) {
			if (strcmp(path, "/etc/resolv.conf") == 0) {
				p->p_pledgeafter |= TMA_DNSRESOLV;
				return (0);
			}
			if (strcmp(path, "/etc/hosts") == 0)
				return (0);
			if (strcmp(path, "/etc/services") == 0)
				return (0);
		}
		if ((p->p_pledgenote == TMN_RPATH) &&
		    (p->p_p->ps_pledge & PLEDGE_GETPW)) {
			if (strcmp(path, "/var/run/ypbind.lock") == 0) {
				p->p_pledgeafter |= TMA_YPLOCK;
				return (0);
			}
			if (strncmp(path, "/var/yp/binding/",
			    sizeof("/var/yp/binding/") - 1) == 0)
				return (0);
		}
		/* tzset() needs these. */
		if ((p->p_pledgenote == TMN_RPATH) &&
		    strncmp(path, "/usr/share/zoneinfo/",
		    sizeof("/usr/share/zoneinfo/") - 1) == 0)
			return (0);
		if ((p->p_pledgenote == TMN_RPATH) &&
		    strcmp(path, "/etc/localtime") == 0)
			return (0);

		/* /usr/share/nls/../libc.cat has to succeed for strerror(3). */
		if ((p->p_pledgenote == TMN_RPATH) &&
		    strncmp(path, "/usr/share/nls/",
		    sizeof("/usr/share/nls/") - 1) == 0 &&
		    strcmp(path + strlen(path) - 9, "/libc.cat") == 0)
			return (0);
		break;
	case SYS_readlink:
		/* Allow /etc/malloc.conf for malloc(3). */
		if ((p->p_pledgenote == TMN_RPATH) &&
		    strcmp(path, "/etc/malloc.conf") == 0)
			return (0);
		break;
	case SYS_stat:
		/* DNS needs /etc/resolv.conf. */
		if ((p->p_pledgenote == TMN_RPATH) &&
		    (p->p_p->ps_pledge & PLEDGE_DNSPATH)) {
			if (strcmp(path, "/etc/resolv.conf") == 0) {
				p->p_pledgeafter |= TMA_DNSRESOLV;
				return (0);
			}
		}
		break;
	}

	/*
	 * If a whitelist is set, compare canonical paths.  Anything
	 * not on the whitelist gets ENOENT.
	 */
	if (p->p_p->ps_pledgepaths) {
		struct whitepaths *wl = p->p_p->ps_pledgepaths;
		char *fullpath, *builtpath = NULL, *canopath = NULL;
		size_t builtlen = 0;
		int i, error;

		if (origpath[0] != '/') {
			char *cwdpath, *cwd, *bp, *bpend;
			size_t cwdpathlen = MAXPATHLEN * 4, cwdlen;

			cwdpath = malloc(cwdpathlen, M_TEMP, M_WAITOK);
			bp = &cwdpath[cwdpathlen];
			bpend = bp;
			*(--bp) = '\0';

			error = vfs_getcwd_common(p->p_fd->fd_cdir,
			    NULL, &bp, cwdpath, cwdpathlen/2,
			    GETCWD_CHECK_ACCESS, p);
			if (error) {
				free(cwdpath, M_TEMP, cwdpathlen);
				return (error);
			}
			cwd = bp;
			cwdlen = (bpend - bp);

			/* NUL included in cwd component */
			builtlen = cwdlen + 1 + strlen(origpath);
			builtpath = malloc(builtlen, M_TEMP, M_WAITOK);
			snprintf(builtpath, builtlen, "%s/%s", cwd, origpath);
			fullpath = builtpath;
			free(cwdpath, M_TEMP, cwdpathlen);

			//printf("namei: builtpath = %s %lld strlen %lld\n", builtpath,
			//    (long long)builtlen, (long long)strlen(builtpath));
		} else
			fullpath = path;

		canopath = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
		error = canonpath(fullpath, canopath, MAXPATHLEN);

		free(builtpath, M_TEMP, builtlen);
		if (error != 0) {
			free(canopath, M_TEMP, MAXPATHLEN);
			return (pledge_fail(p, EPERM, PLEDGE_RPATH));
		}

		//printf("namei: canopath = %s strlen %lld\n", canopath,
		//    (long long)strlen(canopath));

		error = ENOENT;
		for (i = 0; i < wl->wl_count && wl->wl_paths[i].name && error; i++) {
			if (strncmp(canopath, wl->wl_paths[i].name,
			    wl->wl_paths[i].len - 1) == 0) {
				u_char term = canopath[wl->wl_paths[i].len - 1];

				if (term == '\0' || term == '/' ||
				    wl->wl_paths[i].name[1] == '\0')
					error = 0;
			}
		}
		free(canopath, M_TEMP, MAXPATHLEN);
		return (error);			/* Don't hint why it failed */
	}

	if (p->p_p->ps_pledge & PLEDGE_RPATH)
		return (0);
	if (p->p_p->ps_pledge & PLEDGE_WPATH)
		return (0);
	if (p->p_p->ps_pledge & PLEDGE_CPATH)
		return (0);

	return (pledge_fail(p, EPERM, PLEDGE_RPATH));
}

void
pledge_aftersyscall(struct proc *p, int code, int error)
{
	if ((p->p_pledgeafter & TMA_YPLOCK) && error == 0)
		atomic_setbits_int(&p->p_p->ps_pledge, PLEDGE_YP_ACTIVE | PLEDGE_INET);
	if ((p->p_pledgeafter & TMA_DNSRESOLV) && error == 0)
		atomic_setbits_int(&p->p_p->ps_pledge, PLEDGE_DNS_ACTIVE);
}

/*
 * By default, only the advisory cmsg's can be received from the kernel,
 * such as TIMESTAMP ntpd.
 *
 * If PLEDGE_RECVFD is set SCM_RIGHTS is also allowed in for a carefully
 * selected set of descriptors (specifically to exclude directories).
 *
 * This results in a kill upon recv, if some other process on the system
 * send a SCM_RIGHTS to an open socket of some sort.  That will discourage
 * leaving such sockets lying around...
 */
int
pledge_cmsg_recv(struct proc *p, struct mbuf *control)
{
	struct msghdr tmp;
	struct cmsghdr *cmsg;
	int *fdp, fd;
	struct file *fp;
	int nfds, i;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	/* Scan the cmsg */
	memset(&tmp, 0, sizeof(tmp));
	tmp.msg_control = mtod(control, struct cmsghdr *);
	tmp.msg_controllen = control->m_len;
	cmsg = CMSG_FIRSTHDR(&tmp);

	while (cmsg != NULL) {
		if (cmsg->cmsg_level == SOL_SOCKET &&
		    cmsg->cmsg_type == SCM_RIGHTS)
			break;
		cmsg = CMSG_NXTHDR(&tmp, cmsg);
	}

	/* No SCM_RIGHTS found -> OK */
	if (cmsg == NULL)
		return (0);

	if ((p->p_p->ps_pledge & PLEDGE_RECVFD) == 0)
		return pledge_fail(p, EPERM, PLEDGE_RECVFD);

	/* In OpenBSD, a CMSG only contains one SCM_RIGHTS.  Check it. */
	fdp = (int *)CMSG_DATA(cmsg);
	nfds = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(*cmsg))) /
	    sizeof(struct file *);
	for (i = 0; i < nfds; i++) {
		struct vnode *vp;

		fd = *fdp++;
		fp = fd_getfile(p->p_fd, fd);
		if (fp == NULL)
			return pledge_fail(p, EBADF, PLEDGE_RECVFD);

		/* Only allow passing of sockets, pipes, and pure files */
		switch (fp->f_type) {
		case DTYPE_SOCKET:
		case DTYPE_PIPE:
			continue;
		case DTYPE_VNODE:
			vp = (struct vnode *)fp->f_data;
			if (vp->v_type == VREG)
				continue;
			break;
		default:
			break;
		}
		return pledge_fail(p, EPERM, PLEDGE_RECVFD);
	}
	return (0);
}

/*
 * When pledged, default prevents sending of a cmsg.
 *
 * Unlike pledge_cmsg_recv pledge_cmsg_send is called with individual
 * cmsgs one per mbuf. So no need to loop or scan.
 */
int
pledge_cmsg_send(struct proc *p, struct mbuf *control)
{
	struct cmsghdr *cmsg;
	int *fdp, fd;
	struct file *fp;
	int nfds, i;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if ((p->p_p->ps_pledge & PLEDGE_SENDFD) == 0)
		return pledge_fail(p, EPERM, PLEDGE_SENDFD);

	/* Scan the cmsg */
	cmsg = mtod(control, struct cmsghdr *);

	/* Contains no SCM_RIGHTS, so OK */
	if (!(cmsg->cmsg_level == SOL_SOCKET &&
	    cmsg->cmsg_type == SCM_RIGHTS))
		return (0);

	/* In OpenBSD, a CMSG only contains one SCM_RIGHTS.  Check it. */
	fdp = (int *)CMSG_DATA(cmsg);
	nfds = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(*cmsg))) /
	    sizeof(struct file *);
	for (i = 0; i < nfds; i++) {
		struct vnode *vp;

		fd = *fdp++;
		fp = fd_getfile(p->p_fd, fd);
		if (fp == NULL)
			return pledge_fail(p, EBADF, PLEDGE_SENDFD);

		/* Only allow passing of sockets, pipes, and pure files */
		switch (fp->f_type) {
		case DTYPE_SOCKET:
		case DTYPE_PIPE:
			continue;
		case DTYPE_VNODE:
			vp = (struct vnode *)fp->f_data;
			if (vp->v_type == VREG)
				continue;
			break;
		default:
			break;
		}
		/* Not allowed to send a bad fd type */
		return pledge_fail(p, EPERM, PLEDGE_SENDFD);
	}
	return (0);
}

int
pledge_sysctl_check(struct proc *p, int miblen, int *mib, void *new)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if (new)
		return (EFAULT);

	/* routing table observation */
	if ((p->p_p->ps_pledge & PLEDGE_ROUTE)) {
		if (miblen == 7 &&
		    mib[0] == CTL_NET && mib[1] == PF_ROUTE &&
		    mib[2] == 0 &&
		    (mib[3] == 0 || mib[3] == AF_INET6 || mib[3] == AF_INET) &&
		    mib[4] == NET_RT_DUMP)
			return (0);

		if (miblen == 6 &&
		    mib[0] == CTL_NET && mib[1] == PF_ROUTE &&
		    mib[2] == 0 &&
		    (mib[3] == 0 || mib[3] == AF_INET6 || mib[3] == AF_INET) &&
		    mib[4] == NET_RT_TABLE)
			return (0);

		if (miblen == 7 &&			/* exposes MACs */
		    mib[0] == CTL_NET && mib[1] == PF_ROUTE &&
		    mib[2] == 0 && mib[3] == AF_INET &&
		    mib[4] == NET_RT_FLAGS && mib[5] == RTF_LLINFO)
			return (0);
	}

	if ((p->p_p->ps_pledge & (PLEDGE_ROUTE | PLEDGE_INET))) {
		if (miblen == 6 &&		/* getifaddrs() */
		    mib[0] == CTL_NET && mib[1] == PF_ROUTE &&
		    mib[2] == 0 &&
		    (mib[3] == 0 || mib[3] == AF_INET6 || mib[3] == AF_INET) &&
		    mib[4] == NET_RT_IFLIST)
			return (0);
	}

	/* used by ntpd(8) to read sensors. */
	if (miblen >= 3 &&
	    mib[0] == CTL_HW && mib[1] == HW_SENSORS)
		return (0);

	if (miblen == 2 &&			/* getdomainname() */
	    mib[0] == CTL_KERN && mib[1] == KERN_DOMAINNAME)
		return (0);
	if (miblen == 2 &&			/* gethostname() */
	    mib[0] == CTL_KERN && mib[1] == KERN_HOSTNAME)
		return (0);
	if (miblen == 2 &&			/* uname() */
	    mib[0] == CTL_KERN && mib[1] == KERN_OSTYPE)
		return (0);
	if (miblen == 2 &&			/* uname() */
	    mib[0] == CTL_KERN && mib[1] == KERN_OSRELEASE)
		return (0);
	if (miblen == 2 &&			/* uname() */
	    mib[0] == CTL_KERN && mib[1] == KERN_OSVERSION)
		return (0);
	if (miblen == 2 &&			/* uname() */
	    mib[0] == CTL_KERN && mib[1] == KERN_VERSION)
		return (0);
	if (miblen == 2 &&			/* uname() */
	    mib[0] == CTL_HW && mib[1] == HW_MACHINE)
		return (0);
	if (miblen == 2 &&			/* getpagesize() */
	    mib[0] == CTL_HW && mib[1] == HW_PAGESIZE)
		return (0);
	if (miblen == 2 &&			/* setproctitle() */
	    mib[0] == CTL_VM && mib[1] == VM_PSSTRINGS)
		return (0);

	printf("%s(%d): sysctl %d: %d %d %d %d %d %d\n",
	    p->p_comm, p->p_pid, miblen, mib[0], mib[1],
	    mib[2], mib[3], mib[4], mib[5]);
	return (EFAULT);
}

int
pledge_adjtime_check(struct proc *p, const void *v)
{
	const struct timeval *delta = v;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if (delta)
		return (EFAULT);
	return (0);
}

int
pledge_connect_check(struct proc *p)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if ((p->p_p->ps_pledge & PLEDGE_DNS_ACTIVE))
		return (0);	/* A port check happens inside sys_connect() */

	if ((p->p_p->ps_pledge & (PLEDGE_INET | PLEDGE_UNIX)))
		return (0);
	return (EPERM);
}

int
pledge_recvfrom_check(struct proc *p, void *v)
{
	struct sockaddr *from = v;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if ((p->p_p->ps_pledge & PLEDGE_DNS_ACTIVE) && from == NULL)
		return (0);
	if (p->p_p->ps_pledge & PLEDGE_INET)
		return (0);
	if (p->p_p->ps_pledge & PLEDGE_UNIX)
		return (0);
	if (from == NULL)
		return (0);		/* behaves just like write */
	return (EPERM);
}

int
pledge_sendto_check(struct proc *p, const void *v)
{
	const struct sockaddr *to = v;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if ((p->p_p->ps_pledge & PLEDGE_DNS_ACTIVE) && to == NULL)
		return (0);

	if ((p->p_p->ps_pledge & PLEDGE_INET))
		return (0);
	if ((p->p_p->ps_pledge & PLEDGE_UNIX))
		return (0);
	if (to == NULL)
		return (0);		/* behaves just like write */
	return (EPERM);
}

int
pledge_socket_check(struct proc *p, int domain)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);
	if ((p->p_p->ps_pledge & (PLEDGE_INET | PLEDGE_UNIX)))
		return (0);
	if ((p->p_p->ps_pledge & PLEDGE_DNS_ACTIVE) &&
	    (domain == AF_INET || domain == AF_INET6))
		return (0);
	return (EPERM);
}

int
pledge_bind_check(struct proc *p, const void *v)
{

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);
	if ((p->p_p->ps_pledge & PLEDGE_INET))
		return (0);
	return (EPERM);
}

int
pledge_ioctl_check(struct proc *p, long com, void *v)
{
	struct file *fp = v;
	struct vnode *vp = NULL;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	/*
	 * The ioctl's which are always allowed.
	 */
	switch (com) {
	case FIONREAD:
	case FIONBIO:
		return (0);
	}

	if (fp == NULL)
		return (EBADF);
	vp = (struct vnode *)fp->f_data;

	/*
	 * Further sets of ioctl become available, but are checked a
	 * bit more carefully against the vnode.
	 */
	if ((p->p_p->ps_pledge & PLEDGE_IOCTL)) {
		switch (com) {
		case FIOCLEX:
		case FIONCLEX:
		case FIOASYNC:
		case FIOSETOWN:
		case FIOGETOWN:
			return (0);
		case TIOCGETA:
		case TIOCGPGRP:
		case TIOCGWINSZ:	/* various programs */
			if (fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
				return (0);
			break;
		case BIOCGSTATS:	/* bpf: tcpdump privsep on ^C */
			if (fp->f_type == DTYPE_VNODE &&
			    fp->f_ops->fo_ioctl == vn_ioctl)
				return (0);
			break;
		case MTIOCGET:
		case MTIOCTOP:
			/* for pax(1) and such, checking tapes... */
			if (fp->f_type == DTYPE_VNODE &&
			    (vp->v_type == VCHR || vp->v_type == VBLK))
				return (0);
			break;
		case SIOCGIFGROUP:
			if ((p->p_p->ps_pledge & PLEDGE_INET) &&
			    fp->f_type == DTYPE_SOCKET)
				return (0);
			break;
		}
	}

	if ((p->p_p->ps_pledge & PLEDGE_ROUTE)) {
		switch (com) {
		case SIOCGIFADDR:
		case SIOCGIFFLAGS:
		case SIOCGIFRDOMAIN:
			if (fp->f_type == DTYPE_SOCKET)
				return (0);
			break;
		}
	}

	if ((p->p_p->ps_pledge & PLEDGE_TTY)) {
		switch (com) {
		case TIOCSPGRP:
			if ((p->p_p->ps_pledge & PLEDGE_PROC) == 0)
				break;
			/* FALTHROUGH */
		case TIOCGETA:
		case TIOCGPGRP:
		case TIOCGWINSZ:	/* various programs */
#if notyet
		case TIOCSTI:		/* ksh? csh? */
#endif
		case TIOCSBRK:		/* cu */
		case TIOCCDTR:		/* cu */
		case TIOCSETA:		/* cu, ... */
		case TIOCSETAW:		/* cu, ... */
		case TIOCSETAF:		/* tcsetattr TCSAFLUSH, script */
			if (fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
				return (0);
			break;
		}
	}

	return pledge_fail(p, EPERM, PLEDGE_IOCTL);
}

int
pledge_setsockopt_check(struct proc *p, int level, int optname)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	/* common case for PLEDGE_UNIX and PLEDGE_INET */
	switch (level) {
	case SOL_SOCKET:
		switch (optname) {
		case SO_RTABLE:
			return (EPERM);
		}
		return (0);
	}

	if ((p->p_p->ps_pledge & PLEDGE_INET) == 0)
		return (EPERM);

	switch (level) {
	case IPPROTO_TCP:
		switch (optname) {
		case TCP_NODELAY:
		case TCP_MD5SIG:
		case TCP_SACK_ENABLE:
		case TCP_MAXSEG:
		case TCP_NOPUSH:
			return (0);
		}
		break;
	case IPPROTO_IP:
		switch (optname) {
		case IP_TOS:
		case IP_TTL:
		case IP_MINTTL:
		case IP_PORTRANGE:
		case IP_RECVDSTADDR:
			return (0);
		case IP_MULTICAST_IF:
		case IP_ADD_MEMBERSHIP:
		case IP_DROP_MEMBERSHIP:
			if ((p->p_p->ps_pledge & PLEDGE_MCAST) == 0)
				return (0);
			break;
		}		
		break;
	case IPPROTO_ICMP:
		break;
	case IPPROTO_IPV6:
		switch (optname) {
		case IPV6_UNICAST_HOPS:
		case IPV6_RECVHOPLIMIT:
		case IPV6_PORTRANGE:
		case IPV6_RECVPKTINFO:
#ifdef notyet
		case IPV6_V6ONLY:
#endif
			return (0);
		case IPV6_MULTICAST_IF:
		case IPV6_JOIN_GROUP:
		case IPV6_LEAVE_GROUP:
			if ((p->p_p->ps_pledge & PLEDGE_MCAST) == 0)
				return (0);
			break;
		}
		break;
	case IPPROTO_ICMPV6:
		break;
	}
	return (EPERM);
}

int
pledge_dns_check(struct proc *p, in_port_t port)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if ((p->p_p->ps_pledge & PLEDGE_INET))
		return (0);
	if ((p->p_p->ps_pledge & PLEDGE_DNS_ACTIVE) && port == htons(53))
		return (0);	/* Allow a DNS connect outbound */
	return (EPERM);
}

void
pledge_dropwpaths(struct process *pr)
{
	if (pr->ps_pledgepaths && --pr->ps_pledgepaths->wl_ref == 0) {
		struct whitepaths *wl = pr->ps_pledgepaths;
		int i;

		for (i = 0; i < wl->wl_count; i++)
			free(wl->wl_paths[i].name, M_TEMP, wl->wl_paths[i].len);
		free(wl, M_TEMP, wl->wl_size);
	}
	pr->ps_pledgepaths = NULL;
}

int
canonpath(const char *input, char *buf, size_t bufsize)
{
	char *p, *q, *s, *end;

	/* can't canon relative paths, don't bother */
	if (input[0] != '/') {
		if (strlcpy(buf, input, bufsize) >= bufsize)
			return (ENAMETOOLONG);
		return (0);
	}

	/* easiest to work with strings always ending in '/' */
	if (snprintf(buf, bufsize, "%s/", input) >= bufsize)
		return (ENAMETOOLONG);

	/* after this we will only be shortening the string. */
	p = buf;
	q = p;
	while (*p) {
		if (p[0] == '/' && p[1] == '/') {
			p += 1;
		} else if (p[0] == '/' && p[1] == '.' &&
		    p[2] == '/') {
			p += 2;
		} else {
			*q++ = *p++;
		}
	}
	*q = 0;

	end = buf + strlen(buf);
	s = buf;
	p = s;
	while (1) {
		/* find "/../" (where's strstr when you need it?) */
		while (p < end) {
			if (p[0] == '/' && strncmp(p + 1, "../", 3) == 0)
				break;
			p++;
		}
		if (p == end)
			break;
		if (p == s) {
			memmove(s, p + 3, end - p - 3 + 1);
			end -= 3;
		} else {
			/* s starts with '/', so we know there's one
			 * somewhere before p. */
			q = p - 1;
			while (*q != '/')
				q--;
			memmove(q, p + 3, end - p - 3 + 1);
			end -= p + 3 - q;
			p = q;
		}
	}
	if (end > s + 1)
		*(end - 1) = 0; /* remove trailing '/' */

	return 0;
}
@


1.71
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.70 2015/10/08 17:29:43 deraadt Exp $	*/
@


1.70
log
@Expose a small set of multicast join operators under the request "mcast".
This will be used by a few daemons.  If they lack this feature, then
they would need to operate without tame.
Discussed with renato
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.69 2015/10/08 13:25:04 deraadt Exp $	*/
d47 1
a47 1
#include <sys/tame.h>
d51 1
a51 1
const u_int tame_syscalls[SYS_MAXSYSCALL] = {
d55 24
a78 24
	[SYS_getuid] = TAME_SELF,
	[SYS_geteuid] = TAME_SELF,
	[SYS_getresuid] = TAME_SELF,
	[SYS_getgid] = TAME_SELF,
	[SYS_getegid] = TAME_SELF,
	[SYS_getresgid] = TAME_SELF,
	[SYS_getgroups] = TAME_SELF,
	[SYS_getlogin] = TAME_SELF,
	[SYS_getpgrp] = TAME_SELF,
	[SYS_getpgid] = TAME_SELF,
	[SYS_getppid] = TAME_SELF,
	[SYS_getsid] = TAME_SELF,
	[SYS_getthrid] = TAME_SELF,
	[SYS_getrlimit] = TAME_SELF,
	[SYS_gettimeofday] = TAME_SELF,
	[SYS_getdtablecount] = TAME_SELF,
	[SYS_getrusage] = TAME_SELF,
	[SYS_issetugid] = TAME_SELF,
	[SYS_clock_getres] = TAME_SELF,
	[SYS_clock_gettime] = TAME_SELF,
	[SYS_getpid] = TAME_SELF,
	[SYS_umask] = TAME_SELF,
	[SYS_sysctl] = TAME_SELF,	/* read-only; narrow subset */
	[SYS_adjtime] = TAME_SELF,	/* read-only */
d80 1
a80 1
	[SYS_fchdir] = TAME_SELF,	/* careful of directory fd inside jails */
d83 99
a181 99
	[SYS_sched_yield] = TAME_SELF,
	[SYS___thrsleep] = TAME_SELF,
	[SYS___thrwakeup] = TAME_SELF,
	[SYS___threxit] = TAME_SELF,
	[SYS___thrsigdivert] = TAME_SELF,

	[SYS_sendsyslog] = TAME_SELF,
	[SYS_nanosleep] = TAME_SELF,
	[SYS_sigprocmask] = TAME_SELF,
	[SYS_sigaction] = TAME_SELF,
	[SYS_sigreturn] = TAME_SELF,
	[SYS_sigpending] = TAME_SELF,
	[SYS_getitimer] = TAME_SELF,
	[SYS_setitimer] = TAME_SELF,

	[SYS_tame] = TAME_SELF,

	[SYS_wait4] = TAME_SELF,

	[SYS_poll] = TAME_RW,
	[SYS_kevent] = TAME_RW,
	[SYS_kqueue] = TAME_RW,
	[SYS_select] = TAME_RW,

	[SYS_close] = TAME_RW,
	[SYS_dup] = TAME_RW,
	[SYS_dup2] = TAME_RW,
	[SYS_dup3] = TAME_RW,
	[SYS_closefrom] = TAME_RW,
	[SYS_shutdown] = TAME_RW,
	[SYS_read] = TAME_RW,
	[SYS_readv] = TAME_RW,
	[SYS_pread] = TAME_RW,
	[SYS_preadv] = TAME_RW,
	[SYS_write] = TAME_RW,
	[SYS_writev] = TAME_RW,
	[SYS_pwrite] = TAME_RW,
	[SYS_pwritev] = TAME_RW,
	[SYS_ftruncate] = TAME_RW,
	[SYS_lseek] = TAME_RW,
	[SYS_fstat] = TAME_RW,

	[SYS_fcntl] = TAME_RW,
	[SYS_fsync] = TAME_RW,
	[SYS_pipe] = TAME_RW,
	[SYS_pipe2] = TAME_RW,
	[SYS_socketpair] = TAME_RW,
	[SYS_getdents] = TAME_RW,

	[SYS_sendto] = TAME_RW | TAME_DNS_ACTIVE | TAME_YP_ACTIVE,
	[SYS_sendmsg] = TAME_RW,
	[SYS_recvmsg] = TAME_RW,
	[SYS_recvfrom] = TAME_RW | TAME_DNS_ACTIVE | TAME_YP_ACTIVE,

	[SYS_fork] = TAME_PROC,
	[SYS_vfork] = TAME_PROC,
	[SYS_kill] = TAME_PROC,
	[SYS_setpgid] = TAME_PROC,
	[SYS_sigsuspend] = TAME_PROC,
	[SYS_setrlimit] = TAME_PROC,

	[SYS_execve] = TAME_EXEC,

	[SYS_setgroups] = TAME_PROC,
	[SYS_setresgid] = TAME_PROC,
	[SYS_setresuid] = TAME_PROC,

	/* FIONREAD/FIONBIO, plus further checks in tame_ioctl_check() */
	[SYS_ioctl] = TAME_RW | TAME_IOCTL | TAME_TTY,

	[SYS_getentropy] = TAME_MALLOC,
	[SYS_madvise] = TAME_MALLOC,
	[SYS_minherit] = TAME_MALLOC,
	[SYS_mmap] = TAME_MALLOC,
	[SYS_mprotect] = TAME_MALLOC,
	[SYS_mquery] = TAME_MALLOC,
	[SYS_munmap] = TAME_MALLOC,

	[SYS_open] = TAME_SELF,			/* further checks in namei */
	[SYS_stat] = TAME_SELF,			/* further checks in namei */
	[SYS_access] = TAME_SELF,		/* further checks in namei */
	[SYS_readlink] = TAME_SELF,		/* further checks in namei */

	[SYS_chdir] = TAME_RPATH,
	[SYS_openat] = TAME_RPATH | TAME_WPATH,
	[SYS_fstatat] = TAME_RPATH | TAME_WPATH,
	[SYS_faccessat] = TAME_RPATH | TAME_WPATH,
	[SYS_readlinkat] = TAME_RPATH | TAME_WPATH,
	[SYS_lstat] = TAME_RPATH | TAME_WPATH | TAME_TMPPATH,
	[SYS_rename] = TAME_CPATH,
	[SYS_rmdir] = TAME_CPATH,
	[SYS_renameat] = TAME_CPATH,
	[SYS_link] = TAME_CPATH,
	[SYS_linkat] = TAME_CPATH,
	[SYS_symlink] = TAME_CPATH,
	[SYS_unlink] = TAME_CPATH | TAME_TMPPATH,
	[SYS_unlinkat] = TAME_CPATH,
	[SYS_mkdir] = TAME_CPATH,
	[SYS_mkdirat] = TAME_CPATH,
d187 1
a187 1
	[SYS___getcwd] = TAME_RPATH | TAME_WPATH,
d190 29
a218 29
	[SYS_getfsstat] = TAME_RPATH,
	[SYS_statfs] = TAME_RPATH,
	[SYS_fstatfs] = TAME_RPATH,

	[SYS_utimes] = TAME_FATTR,
	[SYS_futimes] = TAME_FATTR,
	[SYS_utimensat] = TAME_FATTR,
	[SYS_futimens] = TAME_FATTR,
	[SYS_chmod] = TAME_FATTR,
	[SYS_fchmod] = TAME_FATTR,
	[SYS_fchmodat] = TAME_FATTR,
	[SYS_chflags] = TAME_FATTR,
	[SYS_chflagsat] = TAME_FATTR,
	[SYS_chown] = TAME_FATTR,
	[SYS_fchownat] = TAME_FATTR,
	[SYS_lchown] = TAME_FATTR,
	[SYS_fchown] = TAME_FATTR,

	[SYS_socket] = TAME_INET | TAME_UNIX | TAME_DNS_ACTIVE | TAME_YP_ACTIVE,
	[SYS_connect] = TAME_INET | TAME_UNIX | TAME_DNS_ACTIVE | TAME_YP_ACTIVE,

	[SYS_listen] = TAME_INET | TAME_UNIX,
	[SYS_bind] = TAME_INET | TAME_UNIX,
	[SYS_accept4] = TAME_INET | TAME_UNIX,
	[SYS_accept] = TAME_INET | TAME_UNIX,
	[SYS_getpeername] = TAME_INET | TAME_UNIX,
	[SYS_getsockname] = TAME_INET | TAME_UNIX,
	[SYS_setsockopt] = TAME_INET | TAME_UNIX,
	[SYS_getsockopt] = TAME_INET | TAME_UNIX,
d220 1
a220 1
	[SYS_flock] = TAME_GETPW,
d226 24
a249 24
} tamereq[] = {
	{ "malloc",		TAME_SELF | TAME_MALLOC },
	{ "rw",			TAME_SELF | TAME_RW },
	{ "stdio",		TAME_SELF | TAME_MALLOC | TAME_RW },
	{ "rpath",		TAME_SELF | TAME_RW | TAME_RPATH },
	{ "wpath",		TAME_SELF | TAME_RW | TAME_WPATH },
	{ "tmppath",		TAME_SELF | TAME_RW | TAME_TMPPATH },
	{ "inet",		TAME_SELF | TAME_RW | TAME_INET },
	{ "unix",		TAME_SELF | TAME_RW | TAME_UNIX },
	{ "dns",		TAME_SELF | TAME_MALLOC | TAME_DNSPATH },
	{ "getpw",		TAME_SELF | TAME_MALLOC | TAME_RW | TAME_GETPW },
/*X*/	{ "cmsg",		TAME_UNIX | TAME_INET | TAME_SENDFD | TAME_RECVFD },
	{ "sendfd",		TAME_RW | TAME_SENDFD },
	{ "recvfd",		TAME_RW | TAME_RECVFD },
	{ "ioctl",		TAME_IOCTL },
	{ "route",		TAME_ROUTE },
	{ "mcast",		TAME_MCAST },
	{ "tty",		TAME_TTY },
	{ "proc",		TAME_PROC },
	{ "exec",		TAME_EXEC },
	{ "cpath",		TAME_CPATH },
	{ "abort",		TAME_ABORT },
	{ "fattr",		TAME_FATTR },
	{ "prot_exec",		TAME_PROTEXEC },
d253 1
a253 1
sys_tame(struct proc *p, void *v, register_t *retval)
d255 1
a255 1
	struct sys_tame_args /* {
d276 1
a276 1
			ktrstruct(p, "tamereq", rbuf, rbuflen-1);
d286 3
a288 3
			for (f = i = 0; i < nitems(tamereq); i++) {
				if (strcmp(rp, tamereq[i].name) == 0) {
					f = tamereq[i].flags;
d301 1
a301 1
	if (flags & ~TAME_USERSET)
d304 4
a307 4
	if ((p->p_p->ps_flags & PS_TAMED)) {
		/* Already tamed, only allow reductions */
		if (((flags | p->p_p->ps_tame) & TAME_USERSET) !=
		    (p->p_p->ps_tame & TAME_USERSET)) {
d311 2
a312 2
		flags &= p->p_p->ps_tame;
		flags &= TAME_USERSET;		/* Relearn _ACTIVE */
d322 1
a322 1
		if (p->p_p->ps_tamepaths)
d326 1
a326 1
		for (i = 0; i < TAME_MAXPATHS; i++) {
d332 1
a332 1
		if (i == TAME_MAXPATHS)
d356 1
a356 1
				ktrstruct(p, "tamepath", path, len-1);
d386 1
a386 1
				// printf("tame: builtpath = %s\n", builtpath);
d402 1
a402 1
			//printf("tame: canopath = %s %lld strlen %lld\n", canopath,
d424 1
a424 1
		p->p_p->ps_tamepaths = wl;
d426 1
a426 1
		printf("tame: %s(%d): paths loaded:\n", p->p_comm, p->p_pid);
d429 1
a429 1
				printf("tame: %d=%s %lld\n", i, wl->wl_paths[i].name,
d434 2
a435 2
	p->p_p->ps_tame = flags;
	p->p_p->ps_flags |= PS_TAMED;
d440 1
a440 1
tame_check(struct proc *p, int code)
d442 2
a443 2
	p->p_tamenote = p->p_tameafter = 0;	/* XX optimise? */
	p->p_tame_syscall = code;
d448 1
a448 1
	if (p->p_p->ps_tame == 0)
d450 1
a450 1
	return (p->p_p->ps_tame & tame_syscalls[code]);
d454 1
a454 1
tame_fail(struct proc *p, int error, int code)
d456 2
a457 2
	printf("%s(%d): syscall %d\n", p->p_comm, p->p_pid, p->p_tame_syscall);
	if (p->p_p->ps_tame & TAME_ABORT) {	/* Core dump requested */
d467 1
a467 1
	p->p_p->ps_tame = 0;		/* Disable all TAME_ flags */
d476 1
a476 1
tame_namei(struct proc *p, char *origpath)
d480 1
a480 1
	if (p->p_tamenote == TMN_COREDUMP)
d484 1
a484 1
		return (tame_fail(p, EPERM, TAME_RPATH));
d486 2
a487 2
	if ((p->p_tamenote & TMN_FATTR) &&
	    (p->p_p->ps_tame & TAME_FATTR) == 0) {
d489 2
a490 2
		    p->p_comm, p->p_pid, p->p_tame_syscall);
		return (tame_fail(p, EPERM, TAME_FATTR));
d494 3
a496 3
	if ((p->p_p->ps_tame & TAME_TMPPATH) &&
	    (p->p_tame_syscall == SYS_open) &&
	    (p->p_tamenote & TMN_CPATH) &&
d504 2
a505 2
	if ((p->p_p->ps_tame & TAME_TMPPATH) &&
	    (p->p_tame_syscall == SYS_unlink) &&
d511 7
a517 7
	if ((p->p_tamenote & TMN_CPATH) &&
	    ((p->p_p->ps_tame & TAME_CPATH) == 0))
		return (tame_fail(p, EPERM, TAME_CPATH));

	if ((p->p_tamenote & TMN_WPATH) &&
	    (p->p_p->ps_tame & TAME_WPATH) == 0)
		return (tame_fail(p, EPERM, TAME_WPATH));
d520 1
a520 1
	switch (p->p_tame_syscall) {
d523 1
a523 1
		if ((p->p_tamenote == TMN_RPATH) &&
d529 2
a530 2
		if ((p->p_tamenote == TMN_RPATH) &&
		    (p->p_p->ps_tame & TAME_GETPW)) {
d540 2
a541 2
		if ((p->p_tamenote == TMN_RPATH) &&
		    (p->p_p->ps_tame & TAME_DNSPATH)) {
d543 1
a543 1
				p->p_tameafter |= TMA_DNSRESOLV;
d551 2
a552 2
		if ((p->p_tamenote == TMN_RPATH) &&
		    (p->p_p->ps_tame & TAME_GETPW)) {
d554 1
a554 1
				p->p_tameafter |= TMA_YPLOCK;
d562 1
a562 1
		if ((p->p_tamenote == TMN_RPATH) &&
d566 1
a566 1
		if ((p->p_tamenote == TMN_RPATH) &&
d571 1
a571 1
		if ((p->p_tamenote == TMN_RPATH) &&
d579 1
a579 1
		if ((p->p_tamenote == TMN_RPATH) &&
d585 2
a586 2
		if ((p->p_tamenote == TMN_RPATH) &&
		    (p->p_p->ps_tame & TAME_DNSPATH)) {
d588 1
a588 1
				p->p_tameafter |= TMA_DNSRESOLV;
d599 2
a600 2
	if (p->p_p->ps_tamepaths) {
		struct whitepaths *wl = p->p_p->ps_tamepaths;
d642 1
a642 1
			return (tame_fail(p, EPERM, TAME_RPATH));
d663 1
a663 1
	if (p->p_p->ps_tame & TAME_RPATH)
d665 1
a665 1
	if (p->p_p->ps_tame & TAME_WPATH)
d667 1
a667 1
	if (p->p_p->ps_tame & TAME_CPATH)
d670 1
a670 1
	return (tame_fail(p, EPERM, TAME_RPATH));
d674 1
a674 1
tame_aftersyscall(struct proc *p, int code, int error)
d676 4
a679 4
	if ((p->p_tameafter & TMA_YPLOCK) && error == 0)
		atomic_setbits_int(&p->p_p->ps_tame, TAME_YP_ACTIVE | TAME_INET);
	if ((p->p_tameafter & TMA_DNSRESOLV) && error == 0)
		atomic_setbits_int(&p->p_p->ps_tame, TAME_DNS_ACTIVE);
d686 1
a686 1
 * If TAME_RECVFD is set SCM_RIGHTS is also allowed in for a carefully
d694 1
a694 1
tame_cmsg_recv(struct proc *p, struct mbuf *control)
d702 1
a702 1
	if ((p->p_p->ps_flags & PS_TAMED) == 0)
d722 2
a723 2
	if ((p->p_p->ps_tame & TAME_RECVFD) == 0)
		return tame_fail(p, EPERM, TAME_RECVFD);
d735 1
a735 1
			return tame_fail(p, EBADF, TAME_RECVFD);
d750 1
a750 1
		return tame_fail(p, EPERM, TAME_RECVFD);
d756 1
a756 1
 * When tamed, default prevents sending of a cmsg.
d758 1
a758 1
 * Unlike tame_cmsg_recv tame_cmsg_send is called with individual
d762 1
a762 1
tame_cmsg_send(struct proc *p, struct mbuf *control)
d769 1
a769 1
	if ((p->p_p->ps_flags & PS_TAMED) == 0)
d772 2
a773 2
	if ((p->p_p->ps_tame & TAME_SENDFD) == 0)
		return tame_fail(p, EPERM, TAME_SENDFD);
d793 1
a793 1
			return tame_fail(p, EBADF, TAME_SENDFD);
d809 1
a809 1
		return tame_fail(p, EPERM, TAME_SENDFD);
d815 1
a815 1
tame_sysctl_check(struct proc *p, int miblen, int *mib, void *new)
d817 1
a817 1
	if ((p->p_p->ps_flags & PS_TAMED) == 0)
d824 1
a824 1
	if ((p->p_p->ps_tame & TAME_ROUTE)) {
d846 1
a846 1
	if ((p->p_p->ps_tame & (TAME_ROUTE | TAME_INET))) {
d895 1
a895 1
tame_adjtime_check(struct proc *p, const void *v)
d899 1
a899 1
	if ((p->p_p->ps_flags & PS_TAMED) == 0)
d908 1
a908 1
tame_connect_check(struct proc *p)
d910 1
a910 1
	if ((p->p_p->ps_flags & PS_TAMED) == 0)
d913 1
a913 1
	if ((p->p_p->ps_tame & TAME_DNS_ACTIVE))
d916 1
a916 1
	if ((p->p_p->ps_tame & (TAME_INET | TAME_UNIX)))
d922 1
a922 1
tame_recvfrom_check(struct proc *p, void *v)
d926 1
a926 1
	if ((p->p_p->ps_flags & PS_TAMED) == 0)
d929 1
a929 1
	if ((p->p_p->ps_tame & TAME_DNS_ACTIVE) && from == NULL)
d931 1
a931 1
	if (p->p_p->ps_tame & TAME_INET)
d933 1
a933 1
	if (p->p_p->ps_tame & TAME_UNIX)
d941 1
a941 1
tame_sendto_check(struct proc *p, const void *v)
d945 1
a945 1
	if ((p->p_p->ps_flags & PS_TAMED) == 0)
d948 1
a948 1
	if ((p->p_p->ps_tame & TAME_DNS_ACTIVE) && to == NULL)
d951 1
a951 1
	if ((p->p_p->ps_tame & TAME_INET))
d953 1
a953 1
	if ((p->p_p->ps_tame & TAME_UNIX))
d961 1
a961 1
tame_socket_check(struct proc *p, int domain)
d963 1
a963 1
	if ((p->p_p->ps_flags & PS_TAMED) == 0)
d965 1
a965 1
	if ((p->p_p->ps_tame & (TAME_INET | TAME_UNIX)))
d967 1
a967 1
	if ((p->p_p->ps_tame & TAME_DNS_ACTIVE) &&
d974 1
a974 1
tame_bind_check(struct proc *p, const void *v)
d977 1
a977 1
	if ((p->p_p->ps_flags & PS_TAMED) == 0)
d979 1
a979 1
	if ((p->p_p->ps_tame & TAME_INET))
d985 1
a985 1
tame_ioctl_check(struct proc *p, long com, void *v)
d990 1
a990 1
	if ((p->p_p->ps_flags & PS_TAMED) == 0)
d1010 1
a1010 1
	if ((p->p_p->ps_tame & TAME_IOCTL)) {
d1037 1
a1037 1
			if ((p->p_p->ps_tame & TAME_INET) &&
d1044 1
a1044 1
	if ((p->p_p->ps_tame & TAME_ROUTE)) {
d1055 1
a1055 1
	if ((p->p_p->ps_tame & TAME_TTY)) {
d1058 1
a1058 1
			if ((p->p_p->ps_tame & TAME_PROC) == 0)
d1078 1
a1078 1
	return tame_fail(p, EPERM, TAME_IOCTL);
d1082 1
a1082 1
tame_setsockopt_check(struct proc *p, int level, int optname)
d1084 1
a1084 1
	if ((p->p_p->ps_flags & PS_TAMED) == 0)
d1087 1
a1087 1
	/* common case for TAME_UNIX and TAME_INET */
d1097 1
a1097 1
	if ((p->p_p->ps_tame & TAME_INET) == 0)
d1122 1
a1122 1
			if ((p->p_p->ps_tame & TAME_MCAST) == 0)
d1142 1
a1142 1
			if ((p->p_p->ps_tame & TAME_MCAST) == 0)
d1154 1
a1154 1
tame_dns_check(struct proc *p, in_port_t port)
d1156 1
a1156 1
	if ((p->p_p->ps_flags & PS_TAMED) == 0)
d1159 1
a1159 1
	if ((p->p_p->ps_tame & TAME_INET))
d1161 1
a1161 1
	if ((p->p_p->ps_tame & TAME_DNS_ACTIVE) && port == htons(53))
d1167 1
a1167 1
tame_dropwpaths(struct process *pr)
d1169 2
a1170 2
	if (pr->ps_tamepaths && --pr->ps_tamepaths->wl_ref == 0) {
		struct whitepaths *wl = pr->ps_tamepaths;
d1177 1
a1177 1
	pr->ps_tamepaths = NULL;
@


1.69
log
@setsockopt has a small list of options it can set.  If we find ourselves
only in TAME_UNIX, stop trying after servicing SOL_SOCKET.
discussion with claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.67 2015/10/07 19:52:54 deraadt Exp $	*/
d242 1
d1119 7
a1125 1
		}
d1135 3
d1139 6
@


1.68
log
@Only in TAME_ROUTE, allow ioctl SIOCGIFADDR/SIOCGIFFLAGS/SIOCGIFRDOMAIN,
because many routing daemon processes with this attribute need to fetch
that information to work.
discussed with claudio and renato
@
text
@d1086 1
d1094 6
@


1.67
log
@Split out routing sysctl's from tame "inet", and put them into the
new tame "route" request.  Now routing daemons and tools (such as arp),
can narrowly ask for either feature.  One thing remains available in
both cases -- support for getifaddr()'s, since libc and programs often
use that in close association with socket creation.
ok benno sthen beck, some discussion with renato
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.66 2015/10/07 03:47:43 deraadt Exp $	*/
d1038 11
@


1.66
log
@Add the tame "exec" request.  This allows processes which request
"exec" to call execve(2), potentially fork(2) beforehands if they
asked for "proc".  Calling execve is what "shells" (ksh, tmux, etc)
have as their primary purpose.  But meantime, if such a shell has a
nasty bug, we want to mitigate the process from opening a socket or
calling 100+ other system calls.  Unfortunately silver bullets are in
short supply, so if our goal is to stay in a POSIX-y environment, we
have to let shells call execve().  POSIX ate the world, so choices do
we all have?
Warning for many: silver bullets are even more rare in other OS
ecosystems, so please accept this as a narrow lowering of the bar in a
very raised environment.
Commited from a machine running tame "proc exec" ksh, make, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.65 2015/10/06 18:35:09 deraadt Exp $	*/
d241 1
d814 1
a814 1
tame_sysctl_check(struct proc *p, int namelen, int *name, void *new)
d822 31
a852 22
	/* setproctitle() */
	if (namelen == 2 &&
	    name[0] == CTL_VM &&
	    name[1] == VM_PSSTRINGS)
		return (0);

	/* getifaddrs() */
	if ((p->p_p->ps_tame & TAME_INET) &&
	    namelen == 6 &&
	    name[0] == CTL_NET && name[1] == PF_ROUTE &&
	    name[2] == 0 && name[3] == 0 &&
	    name[4] == NET_RT_IFLIST && name[5] == 0)
		return (0);

	/* used by arp(8).  Exposes MAC addresses known on local nets */
	/* XXX Put into a special catagory. */
	if ((p->p_p->ps_tame & TAME_INET) &&
	    namelen == 7 &&
	    name[0] == CTL_NET && name[1] == PF_ROUTE &&
	    name[2] == 0 && name[3] == AF_INET &&
	    name[4] == NET_RT_FLAGS && name[5] == RTF_LLINFO)
		return (0);
d855 2
a856 3
	/* XXX Put into a special catagory. */
	if (namelen >= 3 &&
	    name[0] == CTL_HW && name[1] == HW_SENSORS)
d859 5
a863 3
	/* getdomainname(), gethostname(), getpagesize(), uname() */
	if (namelen == 2 &&
	    name[0] == CTL_KERN && name[1] == KERN_DOMAINNAME)
d865 2
a866 2
	if (namelen == 2 &&
	    name[0] == CTL_KERN && name[1] == KERN_HOSTNAME)
d868 2
a869 2
	if (namelen == 2 &&
	    name[0] == CTL_KERN && name[1] == KERN_OSTYPE)
d871 2
a872 2
	if (namelen == 2 &&
	    name[0] == CTL_KERN && name[1] == KERN_OSRELEASE)
d874 2
a875 2
	if (namelen == 2 &&
	    name[0] == CTL_KERN && name[1] == KERN_OSVERSION)
d877 2
a878 2
	if (namelen == 2 &&
	    name[0] == CTL_KERN && name[1] == KERN_VERSION)
d880 2
a881 2
	if (namelen == 2 &&
	    name[0] == CTL_HW && name[1] == HW_MACHINE)
d883 2
a884 2
	if (namelen == 2 &&
	    name[0] == CTL_HW && name[1] == HW_PAGESIZE)
d888 2
a889 2
	    p->p_comm, p->p_pid, namelen, name[0], name[1],
	    name[2], name[3], name[4], name[5]);
@


1.65
log
@A process should be able to do sigpending for itself
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.64 2015/10/06 18:15:02 deraadt Exp $	*/
d144 2
d243 1
d1119 14
@


1.64
log
@For TAME_PROC, allow setrlimit()
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.63 2015/10/06 17:05:30 deraadt Exp $	*/
d94 1
@


1.63
log
@When "proc" is requested, allow setpgid() and sigsuspend().
Also the combination of "proc tty" needs to permit TIOCSPGRP.

This is the start at minimum semantics required by processes which
work on process groups, sessions, ttys.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.62 2015/10/06 15:21:26 deraadt Exp $	*/
d141 1
@


1.62
log
@Add new "tty" request, which allows TIOCGETA, TIOCGPGRP, TIOCGWINSZ,
TIOCSBRK, TIOCCDTR, TIOCSETA, TIOCSETAW, and TIOCSETAF on tty
vnodes. This helps programs which call tcsetattr(), tcgetattr(), or
readpassphrase().  Especially the latter - tame's goal is to satisfy
the libc requirements of security-sensitive programs.

Remove TIOCSETAF from the basic "ioctl" request, because it is a "set"
option. "ioctl" is slowly turning into a "request information, cannot
set options" package.

Split the "cmsg" request into "sendfd" and "recvfd".  Non-SCM_RIGHTS
messages are currently flowing through freely and we'll need to think
about that.  This split lets us more strictly describe what our many
fd-passing programs will do.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.61 2015/10/06 14:55:41 claudio Exp $	*/
d139 2
d1029 4
@


1.61
log
@Rework the tame cmsg handler to make it work both ways. While on recv one
mbuf blob with all the cmsgs inside while on send cmsgs in an mbuf chain,
one mbuf per message. Adjust the calls accordingly.
Putting it in so deraadt@@ can move forward.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.60 2015/10/06 14:38:23 deraadt Exp $	*/
d145 1
a145 1
	[SYS_ioctl] = TAME_RW | TAME_IOCTL,
a228 1
	{ "cmsg",		TAME_SELF | TAME_RW | TAME_UNIX | TAME_CMSG },
d230 4
d235 1
a235 1
	{ "getpw",		TAME_SELF | TAME_MALLOC | TAME_RW | TAME_GETPW },
d677 1
a677 1
 * If TAME_CMSG is set SCM_RIGHTS is also allowed through for a carefully
d713 2
a714 2
	if ((p->p_p->ps_tame & TAME_CMSG) == 0)
		return tame_fail(p, EPERM, TAME_CMSG);
d726 1
a726 1
			return tame_fail(p, EBADF, TAME_CMSG);
d741 1
a741 1
		return tame_fail(p, EPERM, TAME_CMSG);
d763 2
a764 2
	if ((p->p_p->ps_tame & TAME_CMSG) == 0)
		return tame_fail(p, EPERM, TAME_CMSG);
d784 1
a784 1
			return tame_fail(p, EBADF, TAME_CMSG);
d800 1
a800 1
		return tame_fail(p, EPERM, TAME_CMSG);
a1001 3
		case TIOCSTI:		/* ksh? csh? */
		case TIOCSBRK:		/* cu */
		case TIOCCDTR:		/* cu */
a1009 4
		case TIOCSETAF:		/* tcsetattr TCSAFLUSH, script */
			if (fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
				return (0);
			break;
d1025 20
a1044 2
	printf("tame: ioctl %lx\n", com);
	return (EPERM);
@


1.60
log
@oops, namei was never allowing through valid CPATH operations
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.59 2015/10/06 14:02:49 deraadt Exp $	*/
d682 1
a682 1
tame_cmsg_recv(struct proc *p, void *v, int controllen)
a683 1
	struct mbuf *control = v;
d696 1
a696 1
	tmp.msg_controllen = controllen;
d745 3
d750 1
a750 1
tame_cmsg_send(struct proc *p, void *v, int controllen)
a751 2
	struct mbuf *control = v;
	struct msghdr tmp;
d764 1
a764 11
	memset(&tmp, 0, sizeof(tmp));
	tmp.msg_control = mtod(control, struct cmsghdr *);
	tmp.msg_controllen = controllen;
	cmsg = CMSG_FIRSTHDR(&tmp);

	while (cmsg != NULL) {
		if (cmsg->cmsg_level == SOL_SOCKET &&
		    cmsg->cmsg_type == SCM_RIGHTS)
			break;
		cmsg = CMSG_NXTHDR(&tmp, cmsg);
	}
d767 2
a768 1
	if (cmsg == NULL)
@


1.59
log
@Add getrusage() to the TAME_SELF catagory.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.58 2015/10/06 05:42:12 deraadt Exp $	*/
a652 1

d654 2
@


1.58
log
@Enable ioctl() in the "rw" request, to support FIONREAD/FIONBIO easier
for the stdio/libevent usage case.  Further ioctl commands are narrowly
checked as before.
ok djm guenther semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.57 2015/10/04 17:55:21 deraadt Exp $	*/
d71 1
@


1.57
log
@Move getcwd to a seperate area, with a hand-waving explanation for why
it is RPATH|WPATH... nothing changes, just the new explanation.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.56 2015/10/04 04:08:25 deraadt Exp $	*/
d143 2
a144 1
	[SYS_ioctl] = TAME_IOCTL,		/* very limited subset */
a977 6
	if (fp == NULL)
		return (EBADF);
	vp = (struct vnode *)fp->f_data;

	switch (com) {

d979 1
a979 2
	 * This is a set of "get" info ioctls at the top layer.  Hopefully
	 * a safe list, since they are used a lot.
d981 1
a981 2
	case FIOCLEX:
	case FIONCLEX:
a983 1
	case FIOGETOWN:
a984 15
	case FIOASYNC:
	case FIOSETOWN:
		return (EPERM);

	/* tty subsystem */
	case TIOCGETA:
	case TIOCGPGRP:
	case TIOCGWINSZ:	/* various programs */
	case TIOCSTI:		/* ksh? csh? */
		if (fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
			return (0);
		break;

	default:
		break;
d987 3
a989 2
	if ((p->p_p->ps_tame & TAME_IOCTL) == 0)
		return (EPERM);
d995 7
a1001 5

	switch (com) {
	case BIOCGSTATS:	/* bpf: tcpdump privsep on ^C */
		if (fp->f_type == DTYPE_VNODE &&
		    fp->f_ops->fo_ioctl == vn_ioctl)
d1003 32
a1034 15
		break;

	case TIOCSETAF:		/* tcsetattr TCSAFLUSH, script */
		if (fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
			return (0);
		break;


	case MTIOCGET:
	case MTIOCTOP:
		/* for pax(1) and such, checking tapes... */
		if (fp->f_type == DTYPE_VNODE &&
		    (vp->v_type == VCHR || vp->v_type == VBLK))
			return (0);
		break;
d1036 1
a1036 10
	case SIOCGIFGROUP:
		if ((p->p_p->ps_tame & TAME_INET) &&
		    fp->f_type == DTYPE_SOCKET)
			return (0);
		break;

	default:
		printf("tame: ioctl %lx\n", com);
		break;
	}
@


1.56
log
@Allow sysctl read of vm.vm_psstrings, as setproctitle() uses this to
find the ps buffer.  Few programs want to do their first setproctitle()
rather late...
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.55 2015/10/04 01:56:54 deraadt Exp $	*/
a158 1
	[SYS___getcwd] = TAME_RPATH | TAME_WPATH,
d174 6
@


1.55
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.54 2015/10/03 23:52:30 guenther Exp $	*/
d811 6
@


1.54
log
@Add ktracing of tame()'s arguments' values

"every tool helps" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.53 2015/10/02 20:48:48 deraadt Exp $	*/
d176 1
a176 1
	/* Classify as RPATH, becuase these leak path information */
@


1.53
log
@I see no evidence that lstat() is being done for /etc/resolv.conf, nor
can I figure out why I added this in the past...
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.52 2015/10/02 20:42:26 deraadt Exp $	*/
d255 4
d335 4
@


1.52
log
@kern_tame.c
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.51 2015/10/02 05:30:30 deraadt Exp $	*/
d164 1
a164 1
	[SYS_lstat] = TAME_RPATH | TAME_WPATH | TAME_TMPPATH | TAME_DNSPATH,
@


1.51
log
@Actually, open of /etc/spwd.db must be handled by returning EPERM, not
dropping through to to the kill path.  The best way to understand this
is id(1).  It calls getpwuid, which tries /etc/spwd.db before
/etc/pwd.db ...
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.50 2015/10/02 02:13:59 deraadt Exp $	*/
d932 2
a933 1
	if ((p->p_p->ps_tame & TAME_DNS_ACTIVE) && domain == AF_INET)
@


1.50
log
@mention these pathname calls are checked in namei
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.49 2015/10/02 02:12:08 deraadt Exp $	*/
d504 2
@


1.49
log
@remove some debug printf no longer needed
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.48 2015/10/02 01:44:52 deraadt Exp $	*/
d153 4
a156 4
	[SYS_open] = TAME_SELF,
	[SYS_stat] = TAME_SELF,
	[SYS_access] = TAME_SELF,
	[SYS_readlink] = TAME_SELF,
@


1.48
log
@changed my mind; block spwd.db, force drop-through to pwd.db for processes under tame
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.47 2015/10/01 23:50:37 doug Exp $	*/
a269 2
				printf("%s(%d): unknown req %s\n",
				    p->p_comm, p->p_pid, rp);
a284 2
			printf("%s(%d): fail change %x %x\n", p->p_comm, p->p_pid,
			    flags, p->p_p->ps_tame);
a390 2
			printf("%s(%d): path load error %d\n",
			    p->p_comm, p->p_pid, error);
d398 1
d404 1
a629 2
		if (error)
			printf("bad path: %s\n", canopath);
a708 1
		printf("f_type %d\n", fp->f_type);
a714 1
			printf("v_type %d\n", vp->v_type);
a720 1
		printf("bad fd type\n");
a774 1
		printf("f_type %d\n", fp->f_type);
a780 1
			printf("v_type %d\n", vp->v_type);
d1024 1
a1024 1
		printf("ioctl %lx\n", com);
@


1.47
log
@Fix tame(2) setsockopt check for TCP level.

ok deraadt@@, semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.46 2015/10/01 10:17:27 sthen Exp $	*/
a507 2
			if (strcmp(path, "/etc/spwd.db") == 0)
				return (0);
@


1.46
log
@add IPv6 equivalents for the permitted IPv4 setsockopts, noticed by doug@@,
ok semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.45 2015/09/30 11:36:07 semarie Exp $	*/
d1065 1
d1075 1
@


1.45
log
@implement new "prot_exec" tame(2) request:
- by default, a tamed-program don't have the possibility to use PROT_EXEC for
  mmap(2) or mprotect(2)
- for that, use the request "prot_exec" (that could be dropped later)

initial idea from deraadt@@ and kettenis@@

"make complete sense" beck@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.44 2015/09/29 14:41:27 deraadt Exp $	*/
d1077 8
@


1.44
log
@Reluctantly classify statfs and fstatfs as RPATH for now, because they
leak system path information.  Should be reconsidered in the future.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.43 2015/09/28 15:40:18 semarie Exp $	*/
d229 2
a230 1
	{ "fattr",		TAME_FATTR }
@


1.43
log
@make using tame path "/" work.
and add a regress test for that.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.42 2015/09/19 20:39:06 semarie Exp $	*/
d176 1
a176 1
	/* Classify so due to info leak */
d178 2
a179 1
	/* XXX Consider statfs and fstatfs */
@


1.42
log
@In the internal conversion of _TM_* to TAME_*, some bits were lost for
"dns" and "cmsg" in the `tamereq' array.

Restore the previous behaviour.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.41 2015/09/13 17:08:03 guenther Exp $	*/
d629 2
a630 1
				if (term == '\0' || term == '/')
@


1.41
log
@Rename __sysctl syscall to just sysctl, as the userland wrapper is no longer
necessary

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.40 2015/09/11 15:29:47 deraadt Exp $	*/
d221 2
a222 2
	{ "cmsg",		TAME_UNIX | TAME_CMSG },
	{ "dns",		TAME_MALLOC | TAME_DNSPATH },
@


1.40
log
@Convert _TM_ flags to TAME_ flags, collapsing the entire mapping
layer because the strings select the right options.  Mechanical
conversion.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.39 2015/09/11 08:22:31 guenther Exp $	*/
d76 1
a76 1
	[SYS___sysctl] = TAME_SELF,	/* read-only; narrow subset */
@


1.39
log
@Only include <sys/tame.h> in the .c files that need it

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.38 2015/09/09 17:56:59 deraadt Exp $	*/
d55 23
a77 23
	[SYS_getuid] = _TM_SELF,
	[SYS_geteuid] = _TM_SELF,
	[SYS_getresuid] = _TM_SELF,
	[SYS_getgid] = _TM_SELF,
	[SYS_getegid] = _TM_SELF,
	[SYS_getresgid] = _TM_SELF,
	[SYS_getgroups] = _TM_SELF,
	[SYS_getlogin] = _TM_SELF,
	[SYS_getpgrp] = _TM_SELF,
	[SYS_getpgid] = _TM_SELF,
	[SYS_getppid] = _TM_SELF,
	[SYS_getsid] = _TM_SELF,
	[SYS_getthrid] = _TM_SELF,
	[SYS_getrlimit] = _TM_SELF,
	[SYS_gettimeofday] = _TM_SELF,
	[SYS_getdtablecount] = _TM_SELF,
	[SYS_issetugid] = _TM_SELF,
	[SYS_clock_getres] = _TM_SELF,
	[SYS_clock_gettime] = _TM_SELF,
	[SYS_getpid] = _TM_SELF,
	[SYS_umask] = _TM_SELF,
	[SYS___sysctl] = _TM_SELF,	/* read-only; narrow subset */
	[SYS_adjtime] = _TM_SELF,	/* read-only */
d79 1
a79 1
	[SYS_fchdir] = _TM_SELF,	/* careful of directory fd inside jails */
d82 93
a174 93
	[SYS_sched_yield] = _TM_SELF,
	[SYS___thrsleep] = _TM_SELF,
	[SYS___thrwakeup] = _TM_SELF,
	[SYS___threxit] = _TM_SELF,
	[SYS___thrsigdivert] = _TM_SELF,

	[SYS_sendsyslog] = _TM_SELF,
	[SYS_nanosleep] = _TM_SELF,
	[SYS_sigprocmask] = _TM_SELF,
	[SYS_sigaction] = _TM_SELF,
	[SYS_sigreturn] = _TM_SELF,
	[SYS_getitimer] = _TM_SELF,
	[SYS_setitimer] = _TM_SELF,

	[SYS_tame] = _TM_SELF,

	[SYS_wait4] = _TM_SELF,

	[SYS_poll] = _TM_RW,
	[SYS_kevent] = _TM_RW,
	[SYS_kqueue] = _TM_RW,
	[SYS_select] = _TM_RW,

	[SYS_close] = _TM_RW,
	[SYS_dup] = _TM_RW,
	[SYS_dup2] = _TM_RW,
	[SYS_dup3] = _TM_RW,
	[SYS_closefrom] = _TM_RW,
	[SYS_shutdown] = _TM_RW,
	[SYS_read] = _TM_RW,
	[SYS_readv] = _TM_RW,
	[SYS_pread] = _TM_RW,
	[SYS_preadv] = _TM_RW,
	[SYS_write] = _TM_RW,
	[SYS_writev] = _TM_RW,
	[SYS_pwrite] = _TM_RW,
	[SYS_pwritev] = _TM_RW,
	[SYS_ftruncate] = _TM_RW,
	[SYS_lseek] = _TM_RW,
	[SYS_fstat] = _TM_RW,

	[SYS_fcntl] = _TM_RW,
	[SYS_fsync] = _TM_RW,
	[SYS_pipe] = _TM_RW,
	[SYS_pipe2] = _TM_RW,
	[SYS_socketpair] = _TM_RW,
	[SYS_getdents] = _TM_RW,

	[SYS_sendto] = _TM_RW | _TM_DNS_ACTIVE | _TM_YP_ACTIVE,
	[SYS_sendmsg] = _TM_RW,
	[SYS_recvmsg] = _TM_RW,
	[SYS_recvfrom] = _TM_RW | _TM_DNS_ACTIVE | _TM_YP_ACTIVE,

	[SYS_fork] = _TM_PROC,
	[SYS_vfork] = _TM_PROC,
	[SYS_kill] = _TM_PROC,

	[SYS_setgroups] = _TM_PROC,
	[SYS_setresgid] = _TM_PROC,
	[SYS_setresuid] = _TM_PROC,

	[SYS_ioctl] = _TM_IOCTL,		/* very limited subset */

	[SYS_getentropy] = _TM_MALLOC,
	[SYS_madvise] = _TM_MALLOC,
	[SYS_minherit] = _TM_MALLOC,
	[SYS_mmap] = _TM_MALLOC,
	[SYS_mprotect] = _TM_MALLOC,
	[SYS_mquery] = _TM_MALLOC,
	[SYS_munmap] = _TM_MALLOC,

	[SYS_open] = _TM_SELF,
	[SYS_stat] = _TM_SELF,
	[SYS_access] = _TM_SELF,
	[SYS_readlink] = _TM_SELF,

	[SYS_chdir] = _TM_RPATH,
	[SYS___getcwd] = _TM_RPATH | _TM_WPATH,
	[SYS_openat] = _TM_RPATH | _TM_WPATH,
	[SYS_fstatat] = _TM_RPATH | _TM_WPATH,
	[SYS_faccessat] = _TM_RPATH | _TM_WPATH,
	[SYS_readlinkat] = _TM_RPATH | _TM_WPATH,
	[SYS_lstat] = _TM_RPATH | _TM_WPATH | _TM_TMPPATH | _TM_DNSPATH,
	[SYS_rename] = _TM_CPATH,
	[SYS_rmdir] = _TM_CPATH,
	[SYS_renameat] = _TM_CPATH,
	[SYS_link] = _TM_CPATH,
	[SYS_linkat] = _TM_CPATH,
	[SYS_symlink] = _TM_CPATH,
	[SYS_unlink] = _TM_CPATH | _TM_TMPPATH,
	[SYS_unlinkat] = _TM_CPATH,
	[SYS_mkdir] = _TM_CPATH,
	[SYS_mkdirat] = _TM_CPATH,
d177 1
a177 1
	[SYS_getfsstat] = _TM_RPATH,
d180 25
a204 25
	[SYS_utimes] = _TM_FATTR,
	[SYS_futimes] = _TM_FATTR,
	[SYS_utimensat] = _TM_FATTR,
	[SYS_futimens] = _TM_FATTR,
	[SYS_chmod] = _TM_FATTR,
	[SYS_fchmod] = _TM_FATTR,
	[SYS_fchmodat] = _TM_FATTR,
	[SYS_chflags] = _TM_FATTR,
	[SYS_chflagsat] = _TM_FATTR,
	[SYS_chown] = _TM_FATTR,
	[SYS_fchownat] = _TM_FATTR,
	[SYS_lchown] = _TM_FATTR,
	[SYS_fchown] = _TM_FATTR,

	[SYS_socket] = _TM_INET | _TM_UNIX | _TM_DNS_ACTIVE | _TM_YP_ACTIVE,
	[SYS_connect] = _TM_INET | _TM_UNIX | _TM_DNS_ACTIVE | _TM_YP_ACTIVE,

	[SYS_listen] = _TM_INET | _TM_UNIX,
	[SYS_bind] = _TM_INET | _TM_UNIX,
	[SYS_accept4] = _TM_INET | _TM_UNIX,
	[SYS_accept] = _TM_INET | _TM_UNIX,
	[SYS_getpeername] = _TM_INET | _TM_UNIX,
	[SYS_getsockname] = _TM_INET | _TM_UNIX,
	[SYS_setsockopt] = _TM_INET | _TM_UNIX,
	[SYS_getsockopt] = _TM_INET | _TM_UNIX,
d206 1
a206 1
	[SYS_flock] = _TM_GETPW,
d213 16
a228 16
	{ "malloc",		_TM_SELF | _TM_MALLOC },
	{ "rw",			_TM_SELF | _TM_RW },
	{ "stdio",		_TM_SELF | _TM_MALLOC | _TM_RW },
	{ "rpath",		_TM_SELF | _TM_RW | _TM_RPATH },
	{ "wpath",		_TM_SELF | _TM_RW | _TM_WPATH },
	{ "tmppath",		_TM_SELF | _TM_RW | _TM_TMPPATH },
	{ "inet",		_TM_SELF | _TM_RW | _TM_INET },
	{ "unix",		_TM_SELF | _TM_RW | _TM_UNIX },
	{ "cmsg",		TAME_UNIX | _TM_CMSG },
	{ "dns",		TAME_MALLOC | _TM_DNSPATH },
	{ "ioctl",		_TM_IOCTL },
	{ "getpw",		TAME_STDIO | _TM_GETPW },
	{ "proc",		_TM_PROC },
	{ "cpath",		_TM_CPATH },
	{ "abort",		_TM_ABORT },
	{ "fattr",		_TM_FATTR }
d278 1
a278 1
	if (flags & ~_TM_USERSET)
d283 2
a284 2
		if (((flags | p->p_p->ps_tame) & _TM_USERSET) !=
		    (p->p_p->ps_tame & _TM_USERSET)) {
d291 1
a291 1
		flags &= _TM_USERSET;		/* Relearn _ACTIVE */
d432 1
a432 1
	if (p->p_p->ps_tame & _TM_ABORT) {	/* Core dump requested */
d462 1
a462 1
	    (p->p_p->ps_tame & _TM_FATTR) == 0) {
d469 1
a469 1
	if ((p->p_p->ps_tame & _TM_TMPPATH) &&
d479 1
a479 1
	if ((p->p_p->ps_tame & _TM_TMPPATH) &&
d487 1
a487 1
	    ((p->p_p->ps_tame & _TM_CPATH) == 0))
d491 1
a491 1
	    (p->p_p->ps_tame & _TM_WPATH) == 0)
d505 1
a505 1
		    (p->p_p->ps_tame & _TM_GETPW)) {
d516 1
a516 1
		    (p->p_p->ps_tame & _TM_DNSPATH)) {
d527 1
a527 1
		    (p->p_p->ps_tame & _TM_GETPW)) {
d561 1
a561 1
		    (p->p_p->ps_tame & _TM_DNSPATH)) {
d639 1
a639 1
	if (p->p_p->ps_tame & _TM_RPATH)
d642 1
a642 1
	if (p->p_p->ps_tame & _TM_WPATH)
d652 1
a652 1
		atomic_setbits_int(&p->p_p->ps_tame, _TM_YP_ACTIVE | TAME_INET);
d654 1
a654 1
		atomic_setbits_int(&p->p_p->ps_tame, _TM_DNS_ACTIVE);
d698 1
a698 1
	if ((p->p_p->ps_tame & _TM_CMSG) == 0)
d750 1
a750 1
	if ((p->p_p->ps_tame & _TM_CMSG) == 0)
d813 1
a813 1
	if ((p->p_p->ps_tame & _TM_INET) &&
d822 1
a822 1
	if ((p->p_p->ps_tame & _TM_INET) &&
d886 1
a886 1
	if ((p->p_p->ps_tame & _TM_DNS_ACTIVE))
d889 1
a889 1
	if ((p->p_p->ps_tame & (_TM_INET | _TM_UNIX)))
d902 1
a902 1
	if ((p->p_p->ps_tame & _TM_DNS_ACTIVE) && from == NULL)
d904 1
a904 1
	if (p->p_p->ps_tame & _TM_INET)
d906 1
a906 1
	if (p->p_p->ps_tame & _TM_UNIX)
d921 1
a921 1
	if ((p->p_p->ps_tame & _TM_DNS_ACTIVE) && to == NULL)
d924 1
a924 1
	if ((p->p_p->ps_tame & _TM_INET))
d926 1
a926 1
	if ((p->p_p->ps_tame & _TM_UNIX))
d938 1
a938 1
	if ((p->p_p->ps_tame & (_TM_INET | _TM_UNIX)))
d940 1
a940 1
	if ((p->p_p->ps_tame & _TM_DNS_ACTIVE) && domain == AF_INET)
d951 1
a951 1
	if ((p->p_p->ps_tame & _TM_INET))
d998 1
a998 1
	if ((p->p_p->ps_tame & _TM_IOCTL) == 0)
d1028 1
a1028 1
		if ((p->p_p->ps_tame & _TM_INET) &&
d1086 1
a1086 1
	if ((p->p_p->ps_tame & _TM_INET))
d1088 1
a1088 1
	if ((p->p_p->ps_tame & _TM_DNS_ACTIVE) && port == htons(53))
@


1.38
log
@Move to next tame() API.  The flags are now passed as a very simple string,
which results in tame() code placements being much more recognizeable.
tame() can be moved to unistd.h and does not need cpp symbols to turn the
bits on and off.  The resulting API is a bit unexpected, but simplifies the
mapping to enabling bits in the kernel substantially.
vague ok's from various including guenther doug semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.38 2015/09/09 17:49:31 deraadt Exp $	*/
d47 1
@


1.37
log
@the special check logic for /usr/share/nls/../libc.cat became failure
to return failure.  open() of these paths should succeed to satisfy
strerror() and friends.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.36 2015/09/01 09:19:21 semarie Exp $	*/
d208 22
d234 1
a234 1
		syscallarg(int) flags;
d237 39
a275 1
	int	 flags = SCARG(uap, flags);
@


1.36
log
@Corrects a use-after-free in tame_namei().

ok doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.35 2015/08/31 16:17:53 deraadt Exp $	*/
d484 1
a484 1
		/* /usr/share/nls/../libc.cat returns EPERM, for strerror(3). */
d489 1
a489 1
			return (EPERM);
@


1.35
log
@Consider getfsstat() a RPATH, even though it has no path in it.  We may
want to do the same for fstatfs(), after we handle statfs().  These system
calls leak path information, however I am reluctant to add a seperate
catagory.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.34 2015/08/31 00:51:20 deraadt Exp $	*/
a571 1
		free(canopath, M_TEMP, MAXPATHLEN);
d574 1
@


1.34
log
@spaces snuck in
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.33 2015/08/26 14:46:22 semarie Exp $	*/
d174 4
@


1.33
log
@use ENAMETOOLONG instead of EINVAL for errno when string overflow occurs.
document tame.2 according.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.32 2015/08/26 06:33:57 deraadt Exp $	*/
d215 1
a215 1
	
d440 1
a440 1
		    (p->p_p->ps_tame & _TM_GETPW)) {		    
d497 1
a497 1
		    	if (strcmp(path, "/etc/resolv.conf") == 0) {
d636 1
a636 1
	/* In OpenBSD, a CMSG only contains one SCM_RIGHTS.  Check it. */ 
a670 1
 * If CMSG flag is set, 
d705 1
a705 1
	/* In OpenBSD, a CMSG only contains one SCM_RIGHTS.  Check it. */ 
d749 1
a749 1
    	    namelen == 6 &&
d758 1
a758 1
    	    namelen == 7 &&
d852 1
a852 1
		
d942 1
a942 1
	case BIOCGSTATS:        /* bpf: tcpdump privsep on ^C */
d988 1
a988 1
	case IPPROTO_TCP: 
d1065 1
a1065 1
		    	if (p[0] == '/' && strncmp(p + 1, "../", 3) == 0)
@


1.32
log
@After a report from jsg about a memory leak (or was it a double free?),
refactor the code around getcwd and canonpath, with some help from semarie
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.31 2015/08/26 05:55:53 doug Exp $	*/
d1037 1
a1037 1
			return (EINVAL);
d1043 1
a1043 1
		return (EINVAL);
@


1.31
log
@Add TIOCGETA to the tame list for TAME_IOCTL.

This is used by readpassphrase() and curses.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.30 2015/08/26 05:20:06 doug Exp $	*/
d233 1
a233 1
		size_t cwdpathlen, cwdlen, len, maxargs = 0;
d260 1
a260 1
			size_t builtlen;
a273 1
					cwdpathlen = MAXPATHLEN * 4;
d282 1
a282 2
					if (error) {
						printf("getcwd: %d\n", error);
a283 1
					}
d302 4
a305 2
			if (canonpath(fullpath, canopath, MAXPATHLEN) != 0) {
				free(path, M_TEMP, MAXPATHLEN);
d307 1
a307 3
				if (builtpath)
					free(builtpath, M_TEMP, builtlen);
				return (tame_fail(p, EPERM, TAME_RPATH));
a309 3
			if (builtpath)
				free(builtpath, M_TEMP, builtlen);

d325 1
a325 2
		if (cwdpath)
			free(cwdpath, M_TEMP, cwdpathlen);
d511 2
a512 3
		char *fullpath = path, *builtpath = NULL, *canopath = NULL;
		char *cwdpath = NULL, *cwd;
		size_t cwdpathlen, cwdlen, builtlen;
d516 2
a517 1
			char *bp, *bpend;
a518 1
			cwdpathlen = MAXPATHLEN * 4;
a528 1
				printf("getcwd: %d\n", error);
d538 3
d543 2
a544 2
			fullpath = builtpath;
		}
d547 4
a550 3
		if (canonpath(fullpath, canopath, MAXPATHLEN) != 0) {
			if (cwdpath)
				free(cwdpath, M_TEMP, cwdpathlen);
a551 2
			if (builtpath)
				free(builtpath, M_TEMP, builtlen);
d558 1
a558 1
		error = EACCES;
d568 1
d571 1
a571 7
		if (cwdpath)
			free(cwdpath, M_TEMP, cwdpathlen);
		free(canopath, M_TEMP, MAXPATHLEN);
		if (builtpath)
			free(builtpath, M_TEMP, builtlen);
		if (error)
			return (ENOENT);	/* Don't hint why it failed */
@


1.30
log
@Convert paths argument of tame(2) to const char **.

The path will not be modified and this reduces casts.  Discussed with many.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.29 2015/08/25 15:35:44 jsg Exp $	*/
d934 1
@


1.29
log
@remove duplicate SYS_utimes entry
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.28 2015/08/24 06:19:39 semarie Exp $	*/
d209 1
a209 1
		syscallarg(char **)paths;
d230 1
a230 1
		char **u = SCARG(uap, paths), *sp;
@


1.28
log
@corrects two potential double-free on `cwdpath'. The variable will be free'ed
outside the for-loop.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.27 2015/08/24 06:17:48 doug Exp $	*/
a187 1
	[SYS_utimes] = _TM_FATTR,
@


1.27
log
@Initialize cwdpath so free() is properly handled.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.26 2015/08/23 21:30:04 deraadt Exp $	*/
a284 1
						free(cwdpath, M_TEMP, cwdpathlen);
a294 1
					free(cwdpath, M_TEMP, cwdpathlen);
@


1.26
log
@fix /tmp handling of unlink(); from Caspar Schutijser
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.25 2015/08/23 19:32:20 deraadt Exp $	*/
d522 1
a522 1
		char *cwdpath, *cwd;
@


1.25
log
@Perform maximum one cwd lookup in tame(), also make namei version look the
same.
Idea from semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.24 2015/08/23 16:41:55 deraadt Exp $	*/
d426 1
a426 1
	    strncmp(path, "/tmp/", sizeof("/tmp") - 1) == 0) {
@


1.24
log
@Canonicalize non-rooted paths after cwd prepend.
with semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.22 2015/08/23 14:20:59 semarie Exp $	*/
d233 2
a234 2
		char *path;
		size_t len, maxargs = 0;
d260 1
a260 1
			char *fullpath = NULL, *builtpath = NULL, *canopath = NULL;
d272 2
a273 2
				char *cwdpath, *bp, *bpend;
				size_t cwdlen = MAXPATHLEN * 4;
d275 16
a290 11
				cwdpath = malloc(cwdlen, M_TEMP, M_WAITOK);
				bp = &cwdpath[cwdlen];
				bpend = bp;
				*(--bp) = '\0';

				error = vfs_getcwd_common(p->p_fd->fd_cdir, NULL, &bp,
				    cwdpath, cwdlen/2, GETCWD_CHECK_ACCESS, p);
				if (error) {
					free(cwdpath, M_TEMP, cwdlen);
					printf("getcwd: %d\n", error);
					break;
d294 1
a294 1
				builtlen = (bpend - bp) + 1 + strlen(path);
d296 1
a296 1
					free(cwdpath, M_TEMP, cwdlen);
d301 2
a302 5
				snprintf(builtpath, builtlen, "%s/%s", bp, path);
				//printf("tame: builtpath = %s %lld strlen %lld\n",
				//    builtpath, (long long)builtlen,
				//    (long long)strlen(builtpath));
				free(cwdpath, M_TEMP, cwdlen);
d334 2
d522 2
a523 1
		size_t builtlen;
d527 1
a527 2
			char *cwdpath, *bp, *bpend;
			size_t cwdlen = MAXPATHLEN * 4;
d529 3
a531 2
			cwdpath = malloc(cwdlen, M_TEMP, M_WAITOK);
			bp = &cwdpath[cwdlen];
d535 3
a537 2
			error = vfs_getcwd_common(p->p_fd->fd_cdir, NULL, &bp,
			    cwdpath, cwdlen/2, GETCWD_CHECK_ACCESS, p);
d539 1
a539 1
				free(cwdpath, M_TEMP, cwdlen);
d543 2
d547 1
a547 1
			builtlen = (bpend - bp) + 1 + strlen(origpath);
d549 1
a549 1
			snprintf(builtpath, builtlen, "%s/%s", bp, origpath);
a551 1
			free(cwdpath, M_TEMP, cwdlen);
d557 2
d580 2
@


1.23
log
@check correct offset for terminator; with semarie
@
text
@d233 1
a233 1
		char *ipath, *path;
a255 1
		ipath = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
d260 1
a260 1
			char *fullpath = path, *builtpath = NULL;
d267 1
a267 1
			if ((error = copyinstr(sp, ipath, MAXPATHLEN, &len)) != 0)
a269 6
			if (canonpath(ipath, path, MAXPATHLEN) != 0) {
				free(ipath, M_TEMP, MAXPATHLEN);
				free(path, M_TEMP, MAXPATHLEN);
				return (tame_fail(p, EPERM, TAME_RPATH));
			}

d297 3
a299 1
				// printf("builtpath = %s\n", builtpath);
a301 1
				len = builtlen;
d303 18
a320 1
				len = strlen(path) + 1;
a322 2
				if (builtpath)
					free(builtpath, M_TEMP, len);
d327 1
a327 1
			memcpy(wl->wl_paths[i].name, fullpath, len);
d329 1
a329 2
			if (builtpath)
				free(builtpath, M_TEMP, len);
a330 1
		free(ipath, M_TEMP, MAXPATHLEN);
d343 1
a343 1
		printf("%s(%d): paths loaded:\n", p->p_comm, p->p_pid);
d346 2
a347 1
				printf("%d=%s\n", i, wl->wl_paths[i].name);
d517 1
a517 1
		char *fullpath = path, *builtpath = NULL;
d521 1
a521 1
		if (path[0] != '/') {
d539 1
a539 1
			builtlen = (bpend - bp) + 1 + strlen(path);
d541 3
a543 2
			snprintf(builtpath, builtlen, "%s/%s", bp, path);
			// printf("builtpath = %s\n", builtpath);
d548 11
d561 1
a561 1
			if (strncmp(fullpath, wl->wl_paths[i].name,
d563 1
a563 1
				char term = fullpath[wl->wl_paths[i].len - 1];
d570 2
a571 1
			printf("bad path: %s\n", fullpath);
@


1.22
log
@recompute len when the path is absolute as canonpath could have shrink it

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.21 2015/08/22 20:18:49 deraadt Exp $	*/
d543 1
a543 1
				char term = fullpath[wl->wl_paths[i].len];
@


1.21
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.20 2015/08/21 07:26:09 doug Exp $	*/
d308 2
a309 1
			}
@


1.20
log
@Whitelist TIOCGPGRP (for tcgetpgrp()) in TAME_IOCTL.

Requested by Sunil Nimmagadda to help tame http.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.19 2015/08/20 06:00:23 deraadt Exp $	*/
a41 2
#include <sys/tame.h>

a77 2
	[SYS_chdir] = _TM_RPATH,

d120 1
a120 5

	[SYS_utimes] = _TM_RW,
	[SYS_futimes] = _TM_RW,
	[SYS_utimensat] = _TM_RW,
	[SYS_futimens] = _TM_RW,
a126 1

d152 6
a158 1
	[SYS_open] = _TM_SELF,
a159 1
	[SYS_stat] = _TM_SELF,
a160 1
	[SYS_access] = _TM_SELF,
a161 1
	[SYS_readlink] = _TM_SELF,
a163 8
	[SYS_chmod] = _TM_RPATH | _TM_WPATH | _TM_TMPPATH,
	[SYS_fchmod] = _TM_RPATH | _TM_WPATH,
	[SYS_fchmodat] = _TM_RPATH | _TM_WPATH,
	[SYS_chflags] = _TM_RPATH | _TM_WPATH | _TM_TMPPATH,
	[SYS_chflagsat] = _TM_RPATH | _TM_WPATH,
	[SYS_chown] = _TM_RPATH | _TM_WPATH | _TM_TMPPATH,
	[SYS_fchown] = _TM_RPATH | _TM_WPATH,
	[SYS_fchownat] = _TM_RPATH | _TM_WPATH,
d175 14
a188 1
	[SYS_fstat] = _TM_RW | _TM_RPATH | _TM_WPATH | _TM_TMPPATH,	/* rare */
d191 2
a194 1
	[SYS_connect] = _TM_INET | _TM_UNIX | _TM_DNS_ACTIVE | _TM_YP_ACTIVE,
d199 1
a199 1
	[SYS_setsockopt] = _TM_INET | _TM_UNIX,		/* small subset */
d210 1
d214 14
a227 5
	flags &= _TM_USERSET;
	if ((p->p_p->ps_flags & PS_TAMED) == 0) {
		p->p_p->ps_flags |= PS_TAMED;
		p->p_p->ps_tame = flags;
		return (0);
d230 110
a339 4
	/* May not set new bits */
	if (((flags | p->p_p->ps_tame) & _TM_USERSET) !=
	    (p->p_p->ps_tame & _TM_USERSET))
		return (EPERM);
d341 2
a342 3
	/* More tame bits being cleared.  Force re-learning of _ACTIVE things */
	p->p_p->ps_tame &= flags;
	p->p_p->ps_tame &= _TM_USERSET;
d363 1
a363 2
	printf("tame: pid %d %s syscall %d\n", p->p_pid, p->p_comm,
	    p->p_tame_syscall);
d393 7
d403 1
a403 1
	    (p->p_tamenote & (TMN_CREAT | TMN_IMODIFY)) == TMN_CREAT &&
d418 1
a418 1
	if ((p->p_tamenote & (TMN_CREAT | TMN_IMODIFY)) == TMN_CREAT &&
d422 1
a422 8
	/* inode change operation, issued against a path */
	if ((p->p_tamenote & (TMN_CREAT | TMN_IMODIFY)) == TMN_IMODIFY &&
	    ((p->p_p->ps_tame & _TM_CPATH) == 0)) {
		// XXX should _TM_CPATH be a seperate check?
		return (tame_fail(p, EPERM, TAME_CPATH));
	}

	if ((p->p_tamenote & TMN_WRITE) &&
d426 1
a426 7
	if (p->p_p->ps_tame & _TM_RPATH)
		return (0);

	if (p->p_p->ps_tame & _TM_WPATH)
		return (0);

	/* All remaining cases are RPATH */
d430 2
a431 1
		if (strcmp(path, "/etc/localtime") == 0)
d436 2
a437 1
		if (p->p_p->ps_tame & _TM_GETPW) {
d447 2
a448 1
		if (p->p_p->ps_tame & _TM_DNSPATH) {
d450 1
a450 2
				p->p_tamenote |= TMN_DNSRESOLV;
				p->p_tameafter = 1;
d458 2
a459 1
		if (p->p_p->ps_tame & _TM_GETPW) {
d461 1
a461 2
				p->p_tamenote |= TMN_YPLOCK;
				p->p_tameafter = 1;
d469 2
a470 1
		if (strncmp(path, "/usr/share/zoneinfo/",
d473 2
a474 1
		if (strcmp(path, "/etc/localtime") == 0)
d478 2
a479 1
		if (strncmp(path, "/usr/share/nls/",
d486 2
a487 1
		if (strcmp(path, "/etc/malloc.conf") == 0)
d492 4
a495 4
		if (p->p_p->ps_tame & _TM_DNSPATH) {
			if (strcmp(path, "/etc/resolv.conf") == 0) {
				p->p_tamenote |= TMN_DNSRESOLV;
				p->p_tameafter = 1;
d502 60
d568 1
a568 1
	if ((p->p_tamenote & TMN_YPLOCK) && error == 0)
d570 1
a570 1
	if ((p->p_tamenote & TMN_DNSRESOLV) && error == 0)
d779 2
a780 2
	printf("tame: pid %d %s sysctl %d: %d %d %d %d %d %d\n",
	    p->p_pid, p->p_comm, namelen, name[0], name[1],
@


1.19
log
@reactivate tame()
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.17 2015/07/28 15:22:25 deraadt Exp $	*/
d731 1
@


1.18
log
@Neuter tame(2) with ENOSYS for upcoming release cycle, in a fairly
simple and gross fashion, but the least impact on other parts...
@
text
@a208 3
#if 1
	return (ENOSYS);
#else
a229 1
#endif
@


1.17
log
@normalize disclaimer to license.template; noted by reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.16 2015/07/27 18:22:37 deraadt Exp $	*/
d209 3
d233 1
@


1.16
log
@Rather than disabling tame to coredump, leave it enabled but flag that
a coredump is happening.  This improves behaviour while threaded.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.15 2015/07/27 15:02:36 semarie Exp $	*/
d15 3
a17 3
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.15
log
@enforce tame by disabling all TAME_ flags if tame_fail() is reach, and not only
if TAME_ABORT is setted.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.14 2015/07/23 02:57:51 doug Exp $	*/
d273 3
@


1.14
log
@Replace TIOCSWINSZ with TIOCGWINSZ in tame(2).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.13 2015/07/22 05:32:44 deraadt Exp $	*/
a253 1
		p->p_p->ps_tame = 0;		/* Disable all TAME_ flags */
d260 2
@


1.13
log
@Slam signal handlers harder in tame_fail(), found by semarie.
Also delete some prototype KTRACE code which is not headed in the
right direction.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.12 2015/07/21 16:17:17 guenther Exp $	*/
d727 1
a727 1
	case TIOCSWINSZ:	/* various programs */
@


1.12
log
@Always permit kbind (for dynamic linking) and add __thrsigdivert to the
SELF list like the other threading calls

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.11 2015/07/20 21:36:27 tedu Exp $	*/
d44 1
d251 7
a257 19
#ifdef KTRACE
	if (KTRPOINT(p, KTR_PSIG)) {
		siginfo_t si;

		memset(&si, 0, sizeof(si));
		if (p->p_p->ps_tame & _TM_ABORT)
			si.si_signo = SIGABRT;
		else
			si.si_signo = SIGKILL;
		si.si_code = code;
		// si.si_syscall = p->p_tame_syscall;
		/// si.si_nsysarg ...
		ktrpsig(p, si.si_signo, SIG_DFL, p->p_sigmask, code, &si);
	}
#endif
	if (p->p_p->ps_tame & _TM_ABORT) {
		/* Core dump requested */
		atomic_clearbits_int(&p->p_sigmask, sigmask(SIGABRT));
		atomic_clearbits_int(&p->p_p->ps_flags, PS_TAMED);
@


1.11
log
@crudely canonicalize paths before taming them. ok deraadt doug
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.10 2015/07/20 18:58:53 jeremy Exp $	*/
d53 1
d88 1
d241 1
a241 1
		return (code == SYS_exit);
@


1.10
log
@Allow the sched_yield, __thrsleep, __thrwakeup, and __threxit syscalls
when using tame(2).  This allows threaded programs to work.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.9 2015/07/20 18:04:05 schwarze Exp $	*/
d49 2
d278 1
a278 1
tame_namei(struct proc *p, char *path)
d280 5
d839 63
@


1.9
log
@In _TM_SELF, permit uname(3); OK deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.8 2015/07/20 17:01:26 nicm Exp $	*/
d79 6
@


1.8
log
@Be more paranoid and don't let any ioctls through with invalid file
descriptors.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.7 2015/07/20 16:48:07 nicm Exp $	*/
d572 4
a575 1
	/* gethostname(), getdomainname(), getpagesize() */
d580 13
a592 1
	    name[0] == CTL_KERN && name[1] == KERN_DOMAINNAME)
@


1.7
log
@Don't try to dereference fp if it is NULL, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.6 2015/07/20 16:15:40 nicm Exp $	*/
d687 3
a689 2
	if (fp != NULL)
		vp = (struct vnode *)fp->f_data;
@


1.6
log
@tame_cmsg_send and tame_cmsg_recv are called with the data set to a file
descriptor, so call fd_getfile to get a struct file *. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.5 2015/07/20 15:52:18 deraadt Exp $	*/
d682 1
a682 1
	struct vnode *vp = (struct vnode *)fp->f_data;
d686 3
@


1.5
log
@getpagesize() may occur late in programs; permit it
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.4 2015/07/20 15:26:28 nicm Exp $	*/
d27 1
d410 2
a411 1
	struct file **rp, *fp;
d438 1
a438 1
	rp = (struct file **)CMSG_DATA(cmsg);
d444 4
a447 1
		fp = *rp++;
d480 2
a481 1
	struct file **rp, *fp;
d508 1
a508 1
	rp = (struct file **)CMSG_DATA(cmsg);
d514 4
a517 1
		fp = *rp++;
@


1.4
log
@Add setgroups(2) to TAME_PROC, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.3 2015/07/20 02:43:26 deraadt Exp $	*/
d563 4
d571 1
a571 1
	    name[0] == CTL_KERN && name[1] == KERN_HOSTNAME)
@


1.3
log
@In TAME_IOCTL, permit BIOCGSTATS on a vnode.  We don't drill down deeper
yet to verify it is a bpf node.  Will be used by tcpdump privsep side.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.2 2015/07/19 21:25:32 deraadt Exp $	*/
d135 1
@


1.2
log
@Repair various strncmp lengths, noticed by Brandon Casey
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.1 2015/07/19 02:35:35 deraadt Exp $	*/
d709 6
@


1.1
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d274 1
a274 1
	    strncmp(path, "/tmp/", 5) == 0) {
d283 1
a283 1
	    strncmp(path, "/tmp/", 5) == 0) {
d345 2
a346 1
			if (strncmp(path, "/var/yp/binding/", 14) == 0)
d350 2
a351 1
		if (strncmp(path, "/usr/share/zoneinfo/", 20) == 0)
d357 2
a358 1
		if (strncmp(path, "/usr/share/nls/", 15) == 0 &&
@

