head	1.49;
access;
symbols
	OPENBSD_4_9:1.48.0.14
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.12
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.48.0.8
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.48.0.10
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.48.0.6
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.48.0.4
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.47.0.4
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.47.0.2
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.44.0.4
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.38.0.4
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.37
	SMP_SYNC_B:1.37
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.30.0.4
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	UBC_SYNC_B:1.30
	UBC:1.26.0.2
	UBC_BASE:1.26
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.11.0.10
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.8
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.6
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.49
date	2011.04.02.16.27.29;	author thib;	state dead;
branches;
next	1.48;

1.48
date	2007.12.12.16.26.49;	author thib;	state Exp;
branches;
next	1.47;

1.47
date	2007.01.16.18.05.46;	author thib;	state Exp;
branches;
next	1.46;

1.46
date	2006.10.16.11.29.51;	author pedro;	state Exp;
branches;
next	1.45;

1.45
date	2006.10.03.19.53.15;	author pedro;	state Exp;
branches;
next	1.44;

1.44
date	2006.01.02.05.06.50;	author jsg;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.25.13.42.46;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2005.07.03.20.14.19;	author drahn;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.03.01.09.35;	author jaredy;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.28.03.06.53;	author pedro;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.22.21.09.49;	author pedro;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.13.21.52.07;	author niklas;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.12.04.41.59;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.23.16.46.40;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.21.22.45.24;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.04.21.48.00;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.02.18.19.10;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.01.21.14.13;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2003.04.14.06.28.29;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.08.08.18.26.37;	author todd;	state Exp;
branches;
next	1.29;

1.29
date	2002.08.08.17.07.32;	author provos;	state Exp;
branches;
next	1.28;

1.28
date	2002.02.22.20.54.39;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.10.04.46.24;	author art;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2001.12.10.04.45.31;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.05.00.25.15;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.04.22.44.31;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.11.28.16.25.38;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.28.16.24.26;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.27.05.30.16;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.26.20.24.47;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.26.02.10.41;	author assar;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.23.02.23.05;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.21.17.23.14;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.01.20.55.47;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.26.17.34.52;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.26.17.13.39;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.03.03.20.58.57;	author deraadt;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	99.03.03.14.23.43;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.12.05.16.50.41;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	98.08.30.18.18.52;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.58.30;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.20.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.12.47;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.01.26.05.21.00;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.50.49;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.16.09.11;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.03.26.15.09.31;	author mickey;	state Exp;
branches;
next	;

1.11.6.1
date	2001.05.14.22.32.47;	author niklas;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2001.07.04.10.48.57;	author niklas;	state Exp;
branches;
next	1.11.6.3;

1.11.6.3
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.11.6.4;

1.11.6.4
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.11.6.5;

1.11.6.5
date	2003.05.13.19.21.29;	author ho;	state Exp;
branches;
next	1.11.6.6;

1.11.6.6
date	2003.05.15.04.08.03;	author niklas;	state Exp;
branches;
next	1.11.6.7;

1.11.6.7
date	2003.06.07.11.03.41;	author ho;	state Exp;
branches;
next	1.11.6.8;

1.11.6.8
date	2004.02.19.10.56.39;	author niklas;	state Exp;
branches;
next	;

1.26.2.1
date	2002.02.02.03.28.25;	author art;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2002.06.11.03.29.41;	author art;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.49
log
@remove the vnode_if.* files, as they are now totally
obsolete.

the move to vfs_vops.c is here to stay, so they are
pointless.
@
text
@/*
 * Warning: This file is generated automatically.
 * (Modifications made here may easily be lost!)
 *
 * Created from the file:
 *	OpenBSD: vnode_if.src,v 1.32 2007/01/16 17:52:18 thib Exp 
 * by the script:
 *	OpenBSD: vnode_if.sh,v 1.16 2007/12/12 16:24:49 thib Exp 
 */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mount.h>
#include <sys/vnode.h>

struct vnodeop_desc vop_default_desc = {
	0,
	"default",
	0,
};

struct vnodeop_desc vop_islocked_desc = {
	0,
	"vop_islocked",
	0,
};

int VOP_ISLOCKED(struct vnode *vp)
{
	struct vop_islocked_args a;
	a.a_desc = VDESC(vop_islocked);
	a.a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_islocked), &a));
}
struct vnodeop_desc vop_lookup_desc = {
	0,
	"vop_lookup",
	0,
};

int VOP_LOOKUP(struct vnode *dvp, struct vnode **vpp, 
    struct componentname *cnp)
{
	struct vop_lookup_args a;
	a.a_desc = VDESC(vop_lookup);
	a.a_dvp = dvp;
	a.a_vpp = vpp;
	a.a_cnp = cnp;
	return (VCALL(dvp, VOFFSET(vop_lookup), &a));
}
struct vnodeop_desc vop_create_desc = {
	0,
	"vop_create",
	0 | VDESC_VP0_WILLPUT,
};

int VOP_CREATE(struct vnode *dvp, struct vnode **vpp, 
    struct componentname *cnp, struct vattr *vap)
{
	struct vop_create_args a;
	a.a_desc = VDESC(vop_create);
	a.a_dvp = dvp;
#ifdef VFSDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_create: dvp");
#endif
	a.a_vpp = vpp;
	a.a_cnp = cnp;
	a.a_vap = vap;
	return (VCALL(dvp, VOFFSET(vop_create), &a));
}
struct vnodeop_desc vop_mknod_desc = {
	0,
	"vop_mknod",
	0 | VDESC_VP0_WILLPUT | VDESC_VPP_WILLRELE,
};

int VOP_MKNOD(struct vnode *dvp, struct vnode **vpp, 
    struct componentname *cnp, struct vattr *vap)
{
	struct vop_mknod_args a;
	a.a_desc = VDESC(vop_mknod);
	a.a_dvp = dvp;
#ifdef VFSDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_mknod: dvp");
#endif
	a.a_vpp = vpp;
	a.a_cnp = cnp;
	a.a_vap = vap;
	return (VCALL(dvp, VOFFSET(vop_mknod), &a));
}
struct vnodeop_desc vop_open_desc = {
	0,
	"vop_open",
	0,
};

int VOP_OPEN(struct vnode *vp, int mode, struct ucred *cred, struct proc *p)
{
	struct vop_open_args a;
	a.a_desc = VDESC(vop_open);
	a.a_vp = vp;
	a.a_mode = mode;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_open), &a));
}
struct vnodeop_desc vop_close_desc = {
	0,
	"vop_close",
	0,
};

int VOP_CLOSE(struct vnode *vp, int fflag, struct ucred *cred, struct proc *p)
{
	struct vop_close_args a;
	a.a_desc = VDESC(vop_close);
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_close: vp");
#endif
	a.a_fflag = fflag;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_close), &a));
}
struct vnodeop_desc vop_access_desc = {
	0,
	"vop_access",
	0,
};

int VOP_ACCESS(struct vnode *vp, int mode, struct ucred *cred, struct proc *p)
{
	struct vop_access_args a;
	a.a_desc = VDESC(vop_access);
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_access: vp");
#endif
	a.a_mode = mode;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_access), &a));
}
struct vnodeop_desc vop_getattr_desc = {
	0,
	"vop_getattr",
	0,
};

int VOP_GETATTR(struct vnode *vp, struct vattr *vap, struct ucred *cred, 
    struct proc *p)
{
	struct vop_getattr_args a;
	a.a_desc = VDESC(vop_getattr);
	a.a_vp = vp;
	a.a_vap = vap;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_getattr), &a));
}
struct vnodeop_desc vop_setattr_desc = {
	0,
	"vop_setattr",
	0,
};

int VOP_SETATTR(struct vnode *vp, struct vattr *vap, struct ucred *cred, 
    struct proc *p)
{
	struct vop_setattr_args a;
	a.a_desc = VDESC(vop_setattr);
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_setattr: vp");
#endif
	a.a_vap = vap;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_setattr), &a));
}
struct vnodeop_desc vop_read_desc = {
	0,
	"vop_read",
	0,
};

int VOP_READ(struct vnode *vp, struct uio *uio, int ioflag, struct ucred *cred)
{
	struct vop_read_args a;
	a.a_desc = VDESC(vop_read);
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_read: vp");
#endif
	a.a_uio = uio;
	a.a_ioflag = ioflag;
	a.a_cred = cred;
	return (VCALL(vp, VOFFSET(vop_read), &a));
}
struct vnodeop_desc vop_write_desc = {
	0,
	"vop_write",
	0,
};

int VOP_WRITE(struct vnode *vp, struct uio *uio, int ioflag, 
    struct ucred *cred)
{
	struct vop_write_args a;
	a.a_desc = VDESC(vop_write);
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_write: vp");
#endif
	a.a_uio = uio;
	a.a_ioflag = ioflag;
	a.a_cred = cred;
	return (VCALL(vp, VOFFSET(vop_write), &a));
}
struct vnodeop_desc vop_ioctl_desc = {
	0,
	"vop_ioctl",
	0,
};

int VOP_IOCTL(struct vnode *vp, u_long command, void *data, int fflag, 
    struct ucred *cred, struct proc *p)
{
	struct vop_ioctl_args a;
	a.a_desc = VDESC(vop_ioctl);
	a.a_vp = vp;
	a.a_command = command;
	a.a_data = data;
	a.a_fflag = fflag;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_ioctl), &a));
}
struct vnodeop_desc vop_poll_desc = {
	0,
	"vop_poll",
	0,
};

int VOP_POLL(struct vnode *vp, int events, struct proc *p)
{
	struct vop_poll_args a;
	a.a_desc = VDESC(vop_poll);
	a.a_vp = vp;
	a.a_events = events;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_poll), &a));
}
struct vnodeop_desc vop_kqfilter_desc = {
	0,
	"vop_kqfilter",
	0,
};

int VOP_KQFILTER(struct vnode *vp, struct knote *kn)
{
	struct vop_kqfilter_args a;
	a.a_desc = VDESC(vop_kqfilter);
	a.a_vp = vp;
	a.a_kn = kn;
	return (VCALL(vp, VOFFSET(vop_kqfilter), &a));
}
struct vnodeop_desc vop_revoke_desc = {
	0,
	"vop_revoke",
	0,
};

int VOP_REVOKE(struct vnode *vp, int flags)
{
	struct vop_revoke_args a;
	a.a_desc = VDESC(vop_revoke);
	a.a_vp = vp;
	a.a_flags = flags;
	return (VCALL(vp, VOFFSET(vop_revoke), &a));
}
struct vnodeop_desc vop_fsync_desc = {
	0,
	"vop_fsync",
	0,
};

int VOP_FSYNC(struct vnode *vp, struct ucred *cred, int waitfor, 
    struct proc *p)
{
	struct vop_fsync_args a;
	a.a_desc = VDESC(vop_fsync);
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_fsync: vp");
#endif
	a.a_cred = cred;
	a.a_waitfor = waitfor;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_fsync), &a));
}
struct vnodeop_desc vop_remove_desc = {
	0,
	"vop_remove",
	0 | VDESC_VP0_WILLPUT | VDESC_VP1_WILLPUT,
};

int VOP_REMOVE(struct vnode *dvp, struct vnode *vp, struct componentname *cnp)
{
	struct vop_remove_args a;
	a.a_desc = VDESC(vop_remove);
	a.a_dvp = dvp;
#ifdef VFSDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_remove: dvp");
#endif
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_remove: vp");
#endif
	a.a_cnp = cnp;
	return (VCALL(dvp, VOFFSET(vop_remove), &a));
}
struct vnodeop_desc vop_link_desc = {
	0,
	"vop_link",
	0 | VDESC_VP0_WILLPUT,
};

int VOP_LINK(struct vnode *dvp, struct vnode *vp, struct componentname *cnp)
{
	struct vop_link_args a;
	a.a_desc = VDESC(vop_link);
	a.a_dvp = dvp;
#ifdef VFSDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_link: dvp");
#endif
	a.a_vp = vp;
	a.a_cnp = cnp;
	return (VCALL(dvp, VOFFSET(vop_link), &a));
}
struct vnodeop_desc vop_rename_desc = {
	0,
	"vop_rename",
	0 | VDESC_VP0_WILLRELE | VDESC_VP1_WILLRELE | VDESC_VP2_WILLPUT | VDESC_VP3_WILLRELE,
};

int VOP_RENAME(struct vnode *fdvp, struct vnode *fvp, 
    struct componentname *fcnp, struct vnode *tdvp, struct vnode *tvp, 
    struct componentname *tcnp)
{
	struct vop_rename_args a;
	a.a_desc = VDESC(vop_rename);
	a.a_fdvp = fdvp;
	a.a_fvp = fvp;
	a.a_fcnp = fcnp;
	a.a_tdvp = tdvp;
#ifdef VFSDEBUG
	if ((tdvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(tdvp))
		panic("vop_rename: tdvp");
#endif
	a.a_tvp = tvp;
	a.a_tcnp = tcnp;
	return (VCALL(fdvp, VOFFSET(vop_rename), &a));
}
struct vnodeop_desc vop_mkdir_desc = {
	0,
	"vop_mkdir",
	0 | VDESC_VP0_WILLPUT,
};

int VOP_MKDIR(struct vnode *dvp, struct vnode **vpp, 
    struct componentname *cnp, struct vattr *vap)
{
	struct vop_mkdir_args a;
	a.a_desc = VDESC(vop_mkdir);
	a.a_dvp = dvp;
#ifdef VFSDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_mkdir: dvp");
#endif
	a.a_vpp = vpp;
	a.a_cnp = cnp;
	a.a_vap = vap;
	return (VCALL(dvp, VOFFSET(vop_mkdir), &a));
}
struct vnodeop_desc vop_rmdir_desc = {
	0,
	"vop_rmdir",
	0 | VDESC_VP0_WILLPUT | VDESC_VP1_WILLPUT,
};

int VOP_RMDIR(struct vnode *dvp, struct vnode *vp, struct componentname *cnp)
{
	struct vop_rmdir_args a;
	a.a_desc = VDESC(vop_rmdir);
	a.a_dvp = dvp;
#ifdef VFSDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_rmdir: dvp");
#endif
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_rmdir: vp");
#endif
	a.a_cnp = cnp;
	return (VCALL(dvp, VOFFSET(vop_rmdir), &a));
}
struct vnodeop_desc vop_symlink_desc = {
	0,
	"vop_symlink",
	0 | VDESC_VP0_WILLPUT | VDESC_VPP_WILLRELE,
};

int VOP_SYMLINK(struct vnode *dvp, struct vnode **vpp, 
    struct componentname *cnp, struct vattr *vap, char *target)
{
	struct vop_symlink_args a;
	a.a_desc = VDESC(vop_symlink);
	a.a_dvp = dvp;
#ifdef VFSDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_symlink: dvp");
#endif
	a.a_vpp = vpp;
	a.a_cnp = cnp;
	a.a_vap = vap;
	a.a_target = target;
	return (VCALL(dvp, VOFFSET(vop_symlink), &a));
}
struct vnodeop_desc vop_readdir_desc = {
	0,
	"vop_readdir",
	0,
};

int VOP_READDIR(struct vnode *vp, struct uio *uio, struct ucred *cred, 
    int *eofflag, int *ncookies, u_long **cookies)
{
	struct vop_readdir_args a;
	a.a_desc = VDESC(vop_readdir);
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_readdir: vp");
#endif
	a.a_uio = uio;
	a.a_cred = cred;
	a.a_eofflag = eofflag;
	a.a_ncookies = ncookies;
	a.a_cookies = cookies;
	return (VCALL(vp, VOFFSET(vop_readdir), &a));
}
struct vnodeop_desc vop_readlink_desc = {
	0,
	"vop_readlink",
	0,
};

int VOP_READLINK(struct vnode *vp, struct uio *uio, struct ucred *cred)
{
	struct vop_readlink_args a;
	a.a_desc = VDESC(vop_readlink);
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_readlink: vp");
#endif
	a.a_uio = uio;
	a.a_cred = cred;
	return (VCALL(vp, VOFFSET(vop_readlink), &a));
}
struct vnodeop_desc vop_abortop_desc = {
	0,
	"vop_abortop",
	0,
};

int VOP_ABORTOP(struct vnode *dvp, struct componentname *cnp)
{
	struct vop_abortop_args a;
	a.a_desc = VDESC(vop_abortop);
	a.a_dvp = dvp;
	a.a_cnp = cnp;
	return (VCALL(dvp, VOFFSET(vop_abortop), &a));
}
struct vnodeop_desc vop_inactive_desc = {
	0,
	"vop_inactive",
	0 | VDESC_VP0_WILLUNLOCK,
};

int VOP_INACTIVE(struct vnode *vp, struct proc *p)
{
	struct vop_inactive_args a;
	a.a_desc = VDESC(vop_inactive);
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_inactive: vp");
#endif
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_inactive), &a));
}
struct vnodeop_desc vop_reclaim_desc = {
	0,
	"vop_reclaim",
	0,
};

int VOP_RECLAIM(struct vnode *vp, struct proc *p)
{
	struct vop_reclaim_args a;
	a.a_desc = VDESC(vop_reclaim);
	a.a_vp = vp;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_reclaim), &a));
}
struct vnodeop_desc vop_lock_desc = {
	0,
	"vop_lock",
	0,
};

int VOP_LOCK(struct vnode *vp, int flags, struct proc *p)
{
	struct vop_lock_args a;
	a.a_desc = VDESC(vop_lock);
	a.a_vp = vp;
	a.a_flags = flags;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_lock), &a));
}
struct vnodeop_desc vop_unlock_desc = {
	0,
	"vop_unlock",
	0,
};

int VOP_UNLOCK(struct vnode *vp, int flags, struct proc *p)
{
	struct vop_unlock_args a;
	a.a_desc = VDESC(vop_unlock);
	a.a_vp = vp;
	a.a_flags = flags;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_unlock), &a));
}
struct vnodeop_desc vop_bmap_desc = {
	0,
	"vop_bmap",
	0,
};

int VOP_BMAP(struct vnode *vp, daddr64_t bn, struct vnode **vpp, 
    daddr64_t *bnp, int *runp)
{
	struct vop_bmap_args a;
	a.a_desc = VDESC(vop_bmap);
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_bmap: vp");
#endif
	a.a_bn = bn;
	a.a_vpp = vpp;
	a.a_bnp = bnp;
	a.a_runp = runp;
	return (VCALL(vp, VOFFSET(vop_bmap), &a));
}
struct vnodeop_desc vop_print_desc = {
	0,
	"vop_print",
	0,
};

int VOP_PRINT(struct vnode *vp)
{
	struct vop_print_args a;
	a.a_desc = VDESC(vop_print);
	a.a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_print), &a));
}
struct vnodeop_desc vop_pathconf_desc = {
	0,
	"vop_pathconf",
	0,
};

int VOP_PATHCONF(struct vnode *vp, int name, register_t *retval)
{
	struct vop_pathconf_args a;
	a.a_desc = VDESC(vop_pathconf);
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_pathconf: vp");
#endif
	a.a_name = name;
	a.a_retval = retval;
	return (VCALL(vp, VOFFSET(vop_pathconf), &a));
}
struct vnodeop_desc vop_advlock_desc = {
	0,
	"vop_advlock",
	0,
};

int VOP_ADVLOCK(struct vnode *vp, void *id, int op, struct flock *fl, int flags)
{
	struct vop_advlock_args a;
	a.a_desc = VDESC(vop_advlock);
	a.a_vp = vp;
	a.a_id = id;
	a.a_op = op;
	a.a_fl = fl;
	a.a_flags = flags;
	return (VCALL(vp, VOFFSET(vop_advlock), &a));
}
struct vnodeop_desc vop_reallocblks_desc = {
	0,
	"vop_reallocblks",
	0,
};

int VOP_REALLOCBLKS(struct vnode *vp, struct cluster_save *buflist)
{
	struct vop_reallocblks_args a;
	a.a_desc = VDESC(vop_reallocblks);
	a.a_vp = vp;
#ifdef VFSDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_reallocblks: vp");
#endif
	a.a_buflist = buflist;
	return (VCALL(vp, VOFFSET(vop_reallocblks), &a));
}

/* Special cases: */
struct vnodeop_desc vop_strategy_desc = {
	0,
	"vop_strategy",
	0,
};

int VOP_STRATEGY(struct buf *bp)
{
	struct vop_strategy_args a;
	a.a_desc = VDESC(vop_strategy);
	a.a_bp = bp;
	return (VCALL(bp->b_vp, VOFFSET(vop_strategy), &a));
}
struct vnodeop_desc vop_bwrite_desc = {
	0,
	"vop_bwrite",
	0,
};

int VOP_BWRITE(struct buf *bp)
{
	struct vop_bwrite_args a;
	a.a_desc = VDESC(vop_bwrite);
	a.a_bp = bp;
	return (VCALL(bp->b_vp, VOFFSET(vop_bwrite), &a));
}

/* End of special cases. */

struct vnodeop_desc *vfs_op_descs[] = {
	&vop_default_desc,	/* MUST BE FIRST */
	&vop_strategy_desc,	/* XXX: SPECIAL CASE */
	&vop_bwrite_desc,	/* XXX: SPECIAL CASE */

	&vop_islocked_desc,
	&vop_lookup_desc,
	&vop_create_desc,
	&vop_mknod_desc,
	&vop_open_desc,
	&vop_close_desc,
	&vop_access_desc,
	&vop_getattr_desc,
	&vop_setattr_desc,
	&vop_read_desc,
	&vop_write_desc,
	&vop_ioctl_desc,
	&vop_poll_desc,
	&vop_kqfilter_desc,
	&vop_revoke_desc,
	&vop_fsync_desc,
	&vop_remove_desc,
	&vop_link_desc,
	&vop_rename_desc,
	&vop_mkdir_desc,
	&vop_rmdir_desc,
	&vop_symlink_desc,
	&vop_readdir_desc,
	&vop_readlink_desc,
	&vop_abortop_desc,
	&vop_inactive_desc,
	&vop_reclaim_desc,
	&vop_lock_desc,
	&vop_unlock_desc,
	&vop_bmap_desc,
	&vop_print_desc,
	&vop_pathconf_desc,
	&vop_advlock_desc,
	&vop_reallocblks_desc,
	NULL
};

@


1.48
log
@regen
@
text
@@


1.47
log
@regen
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.15 2006/01/02 05:05:11 jsg Exp 
a47 6
	NULL,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a49 5

int vop_islocked_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_islocked_args,a_vp),
	VDESC_NO_OFFSET
};
a53 6
	vop_islocked_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a62 5

int vop_lookup_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_lookup_args,a_dvp),
	VDESC_NO_OFFSET
};
a66 6
	vop_lookup_vp_offsets,
	VOPARG_OFFSETOF(struct vop_lookup_args, a_vpp),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_lookup_args, a_cnp),
	NULL,
a78 5

int vop_create_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_create_args,a_dvp),
	VDESC_NO_OFFSET
};
a82 6
	vop_create_vp_offsets,
	VOPARG_OFFSETOF(struct vop_create_args, a_vpp),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_create_args, a_cnp),
	NULL,
a99 5

int vop_mknod_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_mknod_args,a_dvp),
	VDESC_NO_OFFSET
};
a103 6
	vop_mknod_vp_offsets,
	VOPARG_OFFSETOF(struct vop_mknod_args, a_vpp),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_mknod_args, a_cnp),
	NULL,
a120 5

int vop_open_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_open_args,a_vp),
	VDESC_NO_OFFSET
};
a124 6
	vop_open_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_open_args, a_cred),
	VOPARG_OFFSETOF(struct vop_open_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
a136 5

int vop_close_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_close_args,a_vp),
	VDESC_NO_OFFSET
};
a140 6
	vop_close_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_close_args, a_cred),
	VOPARG_OFFSETOF(struct vop_close_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
a156 5

int vop_access_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_access_args,a_vp),
	VDESC_NO_OFFSET
};
a160 6
	vop_access_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_access_args, a_cred),
	VOPARG_OFFSETOF(struct vop_access_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
a176 5

int vop_getattr_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_getattr_args,a_vp),
	VDESC_NO_OFFSET
};
a180 6
	vop_getattr_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_getattr_args, a_cred),
	VOPARG_OFFSETOF(struct vop_getattr_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
a193 5

int vop_setattr_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_setattr_args,a_vp),
	VDESC_NO_OFFSET
};
a197 6
	vop_setattr_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_setattr_args, a_cred),
	VOPARG_OFFSETOF(struct vop_setattr_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
a214 5

int vop_read_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_read_args,a_vp),
	VDESC_NO_OFFSET
};
a218 6
	vop_read_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_read_args, a_cred),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a234 5

int vop_write_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_write_args,a_vp),
	VDESC_NO_OFFSET
};
a238 6
	vop_write_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_write_args, a_cred),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a255 5

int vop_ioctl_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_ioctl_args,a_vp),
	VDESC_NO_OFFSET
};
a259 6
	vop_ioctl_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_ioctl_args, a_cred),
	VOPARG_OFFSETOF(struct vop_ioctl_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
a274 5

int vop_poll_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_poll_args,a_vp),
	VDESC_NO_OFFSET
};
a278 6
	vop_poll_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_poll_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
a289 5

int vop_kqfilter_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_kqfilter_args,a_vp),
	VDESC_NO_OFFSET
};
a293 6
	vop_kqfilter_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a303 5

int vop_revoke_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_revoke_args,a_vp),
	VDESC_NO_OFFSET
};
a307 6
	vop_revoke_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a317 5

int vop_fsync_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_fsync_args,a_vp),
	VDESC_NO_OFFSET
};
a321 6
	vop_fsync_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_fsync_args, a_cred),
	VOPARG_OFFSETOF(struct vop_fsync_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
a338 6

int vop_remove_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_remove_args,a_dvp),
	VOPARG_OFFSETOF(struct vop_remove_args,a_vp),
	VDESC_NO_OFFSET
};
a342 6
	vop_remove_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_remove_args, a_cnp),
	NULL,
a361 6

int vop_link_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_link_args,a_dvp),
	VOPARG_OFFSETOF(struct vop_link_args,a_vp),
	VDESC_NO_OFFSET
};
a365 6
	vop_link_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_link_args, a_cnp),
	NULL,
a380 8

int vop_rename_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_rename_args,a_fdvp),
	VOPARG_OFFSETOF(struct vop_rename_args,a_fvp),
	VOPARG_OFFSETOF(struct vop_rename_args,a_tdvp),
	VOPARG_OFFSETOF(struct vop_rename_args,a_tvp),
	VDESC_NO_OFFSET
};
a384 6
	vop_rename_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_rename_args, a_fcnp),
	NULL,
a404 5

int vop_mkdir_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_mkdir_args,a_dvp),
	VDESC_NO_OFFSET
};
a408 6
	vop_mkdir_vp_offsets,
	VOPARG_OFFSETOF(struct vop_mkdir_args, a_vpp),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_mkdir_args, a_cnp),
	NULL,
a425 6

int vop_rmdir_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_rmdir_args,a_dvp),
	VOPARG_OFFSETOF(struct vop_rmdir_args,a_vp),
	VDESC_NO_OFFSET
};
a429 6
	vop_rmdir_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_rmdir_args, a_cnp),
	NULL,
a448 5

int vop_symlink_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_symlink_args,a_dvp),
	VDESC_NO_OFFSET
};
a452 6
	vop_symlink_vp_offsets,
	VOPARG_OFFSETOF(struct vop_symlink_args, a_vpp),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_symlink_args, a_cnp),
	NULL,
a470 5

int vop_readdir_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_readdir_args,a_vp),
	VDESC_NO_OFFSET
};
a474 6
	vop_readdir_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_readdir_args, a_cred),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a493 5

int vop_readlink_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_readlink_args,a_vp),
	VDESC_NO_OFFSET
};
a497 6
	vop_readlink_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_readlink_args, a_cred),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a512 5

int vop_abortop_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_abortop_args,a_dvp),
	VDESC_NO_OFFSET
};
a516 6
	vop_abortop_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_abortop_args, a_cnp),
	NULL,
a526 5

int vop_inactive_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_inactive_args,a_vp),
	VDESC_NO_OFFSET
};
a530 6
	vop_inactive_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_inactive_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
a544 5

int vop_reclaim_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_reclaim_args,a_vp),
	VDESC_NO_OFFSET
};
a548 6
	vop_reclaim_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_reclaim_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
a558 5

int vop_lock_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_lock_args,a_vp),
	VDESC_NO_OFFSET
};
a562 6
	vop_lock_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_lock_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
a573 5

int vop_unlock_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_unlock_args,a_vp),
	VDESC_NO_OFFSET
};
a577 6
	vop_unlock_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_unlock_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
a588 5

int vop_bmap_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_bmap_args,a_vp),
	VDESC_NO_OFFSET
};
a592 6
	vop_bmap_vp_offsets,
	VOPARG_OFFSETOF(struct vop_bmap_args, a_vpp),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a610 5

int vop_print_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_print_args,a_vp),
	VDESC_NO_OFFSET
};
a614 6
	vop_print_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a623 5

int vop_pathconf_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_pathconf_args,a_vp),
	VDESC_NO_OFFSET
};
a627 6
	vop_pathconf_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a642 5

int vop_advlock_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_advlock_args,a_vp),
	VDESC_NO_OFFSET
};
a646 6
	vop_advlock_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a659 5

int vop_reallocblks_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_reallocblks_args,a_vp),
	VDESC_NO_OFFSET
};
a663 6
	vop_reallocblks_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a679 4

int vop_strategy_vp_offsets[] = {
	VDESC_NO_OFFSET
};
a683 6
	vop_strategy_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
a692 4

int vop_bwrite_vp_offsets[] = {
	VDESC_NO_OFFSET
};
a696 6
	vop_bwrite_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
@


1.46
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.31 2006/10/16 11:27:53 pedro Exp 
a383 27
int vop_lease_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_lease_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_lease_desc = {
	0,
	"vop_lease",
	0,
	vop_lease_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_lease_args, a_cred),
	VOPARG_OFFSETOF(struct vop_lease_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_LEASE(struct vnode *vp, struct proc *p, struct ucred *cred, int flag)
{
	struct vop_lease_args a;
	a.a_desc = VDESC(vop_lease);
	a.a_vp = vp;
	a.a_p = p;
	a.a_cred = cred;
	a.a_flag = flag;
	return (VCALL(vp, VOFFSET(vop_lease), &a));
}

a1130 1
	&vop_lease_desc,
@


1.45
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.30 2006/10/03 19:49:06 pedro Exp 
d964 2
a965 2
int VOP_BMAP(struct vnode *vp, daddr_t bn, struct vnode **vpp, daddr64_t *bnp, 
    int *runp)
@


1.44
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.29 2005/07/14 09:04:59 pedro Exp 
d964 1
a964 1
int VOP_BMAP(struct vnode *vp, daddr_t bn, struct vnode **vpp, daddr_t *bnp, 
@


1.43
log
@built files should be checked in after the source file
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.14 2005/05/22 21:07:23 pedro Exp 
d73 1
a73 2
int VOP_ISLOCKED(vp)
	struct vnode *vp;
d97 2
a98 4
int VOP_LOOKUP(dvp, vpp, cnp)
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
d124 2
a125 5
int VOP_CREATE(dvp, vpp, cnp, vap)
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
	struct vattr *vap;
d156 2
a157 5
int VOP_MKNOD(dvp, vpp, cnp, vap)
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
	struct vattr *vap;
d188 1
a188 5
int VOP_OPEN(vp, mode, cred, p)
	struct vnode *vp;
	int mode;
	struct ucred *cred;
	struct proc *p;
d215 1
a215 5
int VOP_CLOSE(vp, fflag, cred, p)
	struct vnode *vp;
	int fflag;
	struct ucred *cred;
	struct proc *p;
d246 1
a246 5
int VOP_ACCESS(vp, mode, cred, p)
	struct vnode *vp;
	int mode;
	struct ucred *cred;
	struct proc *p;
d277 2
a278 5
int VOP_GETATTR(vp, vap, cred, p)
	struct vnode *vp;
	struct vattr *vap;
	struct ucred *cred;
	struct proc *p;
d305 2
a306 5
int VOP_SETATTR(vp, vap, cred, p)
	struct vnode *vp;
	struct vattr *vap;
	struct ucred *cred;
	struct proc *p;
d337 1
a337 5
int VOP_READ(vp, uio, ioflag, cred)
	struct vnode *vp;
	struct uio *uio;
	int ioflag;
	struct ucred *cred;
d368 2
a369 5
int VOP_WRITE(vp, uio, ioflag, cred)
	struct vnode *vp;
	struct uio *uio;
	int ioflag;
	struct ucred *cred;
d400 1
a400 5
int VOP_LEASE(vp, p, cred, flag)
	struct vnode *vp;
	struct proc *p;
	struct ucred *cred;
	int flag;
d427 2
a428 7
int VOP_IOCTL(vp, command, data, fflag, cred, p)
	struct vnode *vp;
	u_long command;
	void *data;
	int fflag;
	struct ucred *cred;
	struct proc *p;
d457 1
a457 4
int VOP_POLL(vp, events, p)
	struct vnode *vp;
	int events;
	struct proc *p;
d483 1
a483 3
int VOP_KQFILTER(vp, kn)
	struct vnode *vp;
	struct knote *kn;
d508 1
a508 3
int VOP_REVOKE(vp, flags)
	struct vnode *vp;
	int flags;
d533 2
a534 5
int VOP_FSYNC(vp, cred, waitfor, p)
	struct vnode *vp;
	struct ucred *cred;
	int waitfor;
	struct proc *p;
d566 1
a566 4
int VOP_REMOVE(dvp, vp, cnp)
	struct vnode *dvp;
	struct vnode *vp;
	struct componentname *cnp;
d601 1
a601 4
int VOP_LINK(dvp, vp, cnp)
	struct vnode *dvp;
	struct vnode *vp;
	struct componentname *cnp;
d634 3
a636 7
int VOP_RENAME(fdvp, fvp, fcnp, tdvp, tvp, tcnp)
	struct vnode *fdvp;
	struct vnode *fvp;
	struct componentname *fcnp;
	struct vnode *tdvp;
	struct vnode *tvp;
	struct componentname *tcnp;
d669 2
a670 5
int VOP_MKDIR(dvp, vpp, cnp, vap)
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
	struct vattr *vap;
d702 1
a702 4
int VOP_RMDIR(dvp, vp, cnp)
	struct vnode *dvp;
	struct vnode *vp;
	struct componentname *cnp;
d736 2
a737 6
int VOP_SYMLINK(dvp, vpp, cnp, vap, target)
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
	struct vattr *vap;
	char *target;
d769 2
a770 7
int VOP_READDIR(vp, uio, cred, eofflag, ncookies, cookies)
	struct vnode *vp;
	struct uio *uio;
	struct ucred *cred;
	int *eofflag;
	int *ncookies;
	u_long **cookies;
d803 1
a803 4
int VOP_READLINK(vp, uio, cred)
	struct vnode *vp;
	struct uio *uio;
	struct ucred *cred;
d833 1
a833 3
int VOP_ABORTOP(dvp, cnp)
	struct vnode *dvp;
	struct componentname *cnp;
d858 1
a858 3
int VOP_INACTIVE(vp, p)
	struct vnode *vp;
	struct proc *p;
d887 1
a887 3
int VOP_RECLAIM(vp, p)
	struct vnode *vp;
	struct proc *p;
d912 1
a912 4
int VOP_LOCK(vp, flags, p)
	struct vnode *vp;
	int flags;
	struct proc *p;
d938 1
a938 4
int VOP_UNLOCK(vp, flags, p)
	struct vnode *vp;
	int flags;
	struct proc *p;
d964 2
a965 6
int VOP_BMAP(vp, bn, vpp, bnp, runp)
	struct vnode *vp;
	daddr_t bn;
	struct vnode **vpp;
	daddr_t *bnp;
	int *runp;
d997 1
a997 2
int VOP_PRINT(vp)
	struct vnode *vp;
d1021 1
a1021 4
int VOP_PATHCONF(vp, name, retval)
	struct vnode *vp;
	int name;
	register_t *retval;
d1051 1
a1051 6
int VOP_ADVLOCK(vp, id, op, fl, flags)
	struct vnode *vp;
	void *id;
	int op;
	struct flock *fl;
	int flags;
d1079 1
a1079 3
int VOP_REALLOCBLKS(vp, buflist)
	struct vnode *vp;
	struct cluster_save *buflist;
d1109 1
a1109 2
int VOP_STRATEGY(bp)
	struct buf *bp;
d1132 1
a1132 2
int VOP_BWRITE(bp)
	struct buf *bp;
@


1.42
log
@sync
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.28 2005/07/03 20:14:00 drahn Exp 
@


1.41
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.27 2005/07/03 01:07:44 jaredy Exp 
a1199 72
int vop_getextattr_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_getextattr_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_getextattr_desc = {
	0,
	"vop_getextattr",
	0,
	vop_getextattr_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_getextattr_args, a_cred),
	VOPARG_OFFSETOF(struct vop_getextattr_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_GETEXTATTR(vp, attrnamespace, name, uio, size, cred, p)
	struct vnode *vp;
	int attrnamespace;
	const char *name;
	struct uio *uio;
	size_t *size;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_getextattr_args a;
	a.a_desc = VDESC(vop_getextattr);
	a.a_vp = vp;
	a.a_attrnamespace = attrnamespace;
	a.a_name = name;
	a.a_uio = uio;
	a.a_size = size;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_getextattr), &a));
}

int vop_setextattr_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_setextattr_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_setextattr_desc = {
	0,
	"vop_setextattr",
	0,
	vop_setextattr_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_setextattr_args, a_cred),
	VOPARG_OFFSETOF(struct vop_setextattr_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_SETEXTATTR(vp, attrnamespace, name, uio, cred, p)
	struct vnode *vp;
	int attrnamespace;
	const char *name;
	struct uio *uio;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_setextattr_args a;
	a.a_desc = VDESC(vop_setextattr);
	a.a_vp = vp;
	a.a_attrnamespace = attrnamespace;
	a.a_name = name;
	a.a_uio = uio;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_setextattr), &a));
}

a1291 2
	&vop_getextattr_desc,
	&vop_setextattr_desc,
@


1.40
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.26 2005/05/28 03:05:44 pedro Exp 
d1127 4
@


1.39
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.25 2005/05/22 21:08:21 pedro Exp 
a1195 33
int vop_whiteout_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_whiteout_args,a_dvp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_whiteout_desc = {
	0,
	"vop_whiteout",
	0,
	vop_whiteout_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_whiteout_args, a_cnp),
	NULL,
};

int VOP_WHITEOUT(dvp, cnp, flags)
	struct vnode *dvp;
	struct componentname *cnp;
	int flags;
{
	struct vop_whiteout_args a;
	a.a_desc = VDESC(vop_whiteout);
	a.a_dvp = dvp;
#ifdef VFSDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_whiteout: dvp");
#endif
	a.a_cnp = cnp;
	a.a_flags = flags;
	return (VCALL(dvp, VOFFSET(vop_whiteout), &a));
}

a1359 1
	&vop_whiteout_desc,
@


1.38
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD
d8 1
a8 1
 *	OpenBSD
d136 1
a136 1
#ifdef LOCKDEBUG
d171 1
a171 1
#ifdef LOCKDEBUG
d237 4
d272 1
a272 1
#ifdef LOCKDEBUG
d338 1
a338 1
#ifdef LOCKDEBUG
d373 1
a373 1
#ifdef LOCKDEBUG
d408 1
a408 1
#ifdef LOCKDEBUG
d592 1
a592 1
#ifdef LOCKDEBUG
d627 1
a627 1
#ifdef LOCKDEBUG
d632 1
a632 1
#ifdef LOCKDEBUG
d665 1
a665 1
#ifdef LOCKDEBUG
d707 1
a707 1
#ifdef LOCKDEBUG
d741 1
a741 1
#ifdef LOCKDEBUG
d776 1
a776 1
#ifdef LOCKDEBUG
d781 1
a781 1
#ifdef LOCKDEBUG
d815 1
a815 1
#ifdef LOCKDEBUG
d853 1
a853 1
#ifdef LOCKDEBUG
d889 1
a889 1
#ifdef LOCKDEBUG
d948 1
a948 1
#ifdef LOCKDEBUG
d1067 1
a1067 1
#ifdef LOCKDEBUG
d1188 1
a1188 1
#ifdef LOCKDEBUG
d1220 1
a1220 1
#ifdef LOCKDEBUG
@


1.37
log
@these need to be synced when vnode_if.src changes
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.24 2003/11/08 19:17:28 jmc Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.13 2003/06/02 23:28:07 millert Exp 
@


1.36
log
@regen (Prepare for conversion of select backend -> poll)
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.23 2003/09/23 16:46:02 millert Exp 
@


1.35
log
@sync
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.22 2003/07/21 22:44:50 tedu Exp 
d480 2
a481 2
int vop_select_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_select_args,a_vp),
d484 1
a484 1
struct vnodeop_desc vop_select_desc = {
d486 1
a486 1
	"vop_select",
d488 1
a488 1
	vop_select_vp_offsets,
d490 2
a491 2
	VOPARG_OFFSETOF(struct vop_select_args, a_cred),
	VOPARG_OFFSETOF(struct vop_select_args, a_p),
d496 1
a496 1
int VOP_SELECT(vp, which, fflags, cred, p)
d498 1
a498 3
	int which;
	int fflags;
	struct ucred *cred;
d501 2
a502 2
	struct vop_select_args a;
	a.a_desc = VDESC(vop_select);
d504 1
a504 3
	a.a_which = which;
	a.a_fflags = fflags;
	a.a_cred = cred;
d506 1
a506 1
	return (VCALL(vp, VOFFSET(vop_select), &a));
d1367 1
a1367 1
	&vop_select_desc,
@


1.34
log
@mop up some more 3/4 license issues
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.20 2003/05/01 21:13:05 tedu Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.12 2003/05/01 21:41:35 tedu Exp 
d464 1
a464 1
	caddr_t data;
d1150 1
a1150 1
	caddr_t id;
@


1.33
log
@sync
@
text
@d23 1
a23 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.32
log
@sync
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.11 2003/05/01 21:13:05 tedu Exp 
@


1.31
log
@sync
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.19 2002/02/22 20:37:45 drahn Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.10 2002/03/14 23:47:05 millert Exp 
d122 1
a122 1
	0 | VDESC_VP0_WILLRELE,
d157 1
a157 1
	0 | VDESC_VP0_WILLRELE | VDESC_VPP_WILLRELE,
d614 1
a614 1
	0 | VDESC_VP0_WILLRELE | VDESC_VP1_WILLRELE,
d652 1
a652 1
	0 | VDESC_VP0_WILLRELE,
d688 1
a688 1
	0 | VDESC_VP0_WILLRELE | VDESC_VP1_WILLRELE | VDESC_VP2_WILLRELE | VDESC_VP3_WILLRELE,
d727 1
a727 1
	0 | VDESC_VP0_WILLRELE,
d763 1
a763 1
	0 | VDESC_VP0_WILLRELE | VDESC_VP1_WILLRELE,
d800 1
a800 1
	0 | VDESC_VP0_WILLRELE | VDESC_VPP_WILLRELE,
d936 1
a936 1
	0,
@


1.30
log
@backout the tree break. ok pb@@, art@@
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.8 2001/02/26 17:34:18 art Exp 
@


1.29
log
@socket buf speedup from thorpej@@netbsd, okay art@@ ericj@@:

Make insertion of data into socket buffers O(C):
* Keep pointers to the first and last mbufs of the last record in the
  socket buffer.
* Use the sb_lastrecord pointer in the sbappend*() family of functions
  to avoid traversing the packet chain to find the last record.
* Add a new sbappend_stream() function for stream protocols which
  guarantee that there will never be more than one record in the
  socket buffer.  This function uses the sb_mbtail pointer to perform
  the data insertion.  Make TCP use sbappend_stream(). On a profiling
run, this makes sbappend of a TCP transmission using
a 1M socket buffer go from 50% of the time to .02% of the time. Thanks
to Bill Sommerfeld and YAMAMOTO Takashi for their debugging
assistance!
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.10 2002/03/14 23:47:05 millert Exp 
@


1.28
log
@EA sync
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.8 2001/02/26 17:34:18 art Exp 
@


1.27
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.11 2001/06/23 02:21:05 csapuntz Exp 
d1233 72
d1398 2
@


1.26
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.17 2001/12/10 04:45:31 art Exp 
a1232 103
int vop_getpages_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_getpages_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_getpages_desc = {
	0,
	"vop_getpages",
	0,
	vop_getpages_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_GETPAGES(vp, offset, m, count, centeridx, access_type, advice, flags)
	struct vnode *vp;
	voff_t offset;
	struct vm_page **m;
	int *count;
	int centeridx;
	vm_prot_t access_type;
	int advice;
	int flags;
{
	struct vop_getpages_args a;
	a.a_desc = VDESC(vop_getpages);
	a.a_vp = vp;
	a.a_offset = offset;
	a.a_m = m;
	a.a_count = count;
	a.a_centeridx = centeridx;
	a.a_access_type = access_type;
	a.a_advice = advice;
	a.a_flags = flags;
	return (VCALL(vp, VOFFSET(vop_getpages), &a));
}

int vop_putpages_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_putpages_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_putpages_desc = {
	0,
	"vop_putpages",
	0,
	vop_putpages_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_PUTPAGES(vp, m, count, flags, rtvals)
	struct vnode *vp;
	struct vm_page **m;
	int count;
	int flags;
	int *rtvals;
{
	struct vop_putpages_args a;
	a.a_desc = VDESC(vop_putpages);
	a.a_vp = vp;
	a.a_m = m;
	a.a_count = count;
	a.a_flags = flags;
	a.a_rtvals = rtvals;
	return (VCALL(vp, VOFFSET(vop_putpages), &a));
}

int vop_mmap_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_mmap_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_mmap_desc = {
	0,
	"vop_mmap",
	0,
	vop_mmap_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_mmap_args, a_cred),
	VOPARG_OFFSETOF(struct vop_mmap_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_MMAP(vp, fflags, cred, p)
	struct vnode *vp;
	int fflags;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_mmap_args a;
	a.a_desc = VDESC(vop_mmap);
	a.a_vp = vp;
	a.a_fflags = fflags;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_mmap), &a));
}

a1325 3
	&vop_getpages_desc,
	&vop_putpages_desc,
	&vop_mmap_desc,
@


1.26.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1288 1
a1288 1
int VOP_PUTPAGES(vp, offlo, offhi, flags)
d1290 2
a1291 2
	voff_t offlo;
	voff_t offhi;
d1293 1
d1298 2
a1299 2
	a.a_offlo = offlo;
	a.a_offhi = offhi;
d1301 1
@


1.26.2.2
log
@Sync UBC branch to -current
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.17.2.1 2002/02/02 03:28:25 art Exp 
a1333 72
int vop_getextattr_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_getextattr_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_getextattr_desc = {
	0,
	"vop_getextattr",
	0,
	vop_getextattr_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_getextattr_args, a_cred),
	VOPARG_OFFSETOF(struct vop_getextattr_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_GETEXTATTR(vp, attrnamespace, name, uio, size, cred, p)
	struct vnode *vp;
	int attrnamespace;
	const char *name;
	struct uio *uio;
	size_t *size;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_getextattr_args a;
	a.a_desc = VDESC(vop_getextattr);
	a.a_vp = vp;
	a.a_attrnamespace = attrnamespace;
	a.a_name = name;
	a.a_uio = uio;
	a.a_size = size;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_getextattr), &a));
}

int vop_setextattr_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_setextattr_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_setextattr_desc = {
	0,
	"vop_setextattr",
	0,
	vop_setextattr_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_setextattr_args, a_cred),
	VOPARG_OFFSETOF(struct vop_setextattr_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_SETEXTATTR(vp, attrnamespace, name, uio, cred, p)
	struct vnode *vp;
	int attrnamespace;
	const char *name;
	struct uio *uio;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_setextattr_args a;
	a.a_desc = VDESC(vop_setextattr);
	a.a_vp = vp;
	a.a_attrnamespace = attrnamespace;
	a.a_name = name;
	a.a_uio = uio;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_setextattr), &a));
}

a1429 2
	&vop_getextattr_desc,
	&vop_setextattr_desc,
@


1.26.2.3
log
@sync
@
text
@d6 1
a6 1
 *	OpenBSD
d8 1
a8 1
 *	OpenBSD
d122 1
a122 1
	0 | VDESC_VP0_WILLPUT,
d157 1
a157 1
	0 | VDESC_VP0_WILLPUT | VDESC_VPP_WILLRELE,
d614 1
a614 1
	0 | VDESC_VP0_WILLPUT | VDESC_VP1_WILLPUT,
d652 1
a652 1
	0 | VDESC_VP0_WILLPUT,
d688 1
a688 1
	0 | VDESC_VP0_WILLRELE | VDESC_VP1_WILLRELE | VDESC_VP2_WILLPUT | VDESC_VP3_WILLRELE,
d727 1
a727 1
	0 | VDESC_VP0_WILLPUT,
d763 1
a763 1
	0 | VDESC_VP0_WILLPUT | VDESC_VP1_WILLPUT,
d800 1
a800 1
	0 | VDESC_VP0_WILLPUT | VDESC_VPP_WILLRELE,
d936 1
a936 1
	0 | VDESC_VP0_WILLUNLOCK,
@


1.25
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.16 2001/12/04 22:44:31 art Exp 
@


1.24
log
@Oops forgot to regen.
@
text
@a1232 33
int vop_ballocn_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_ballocn_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_ballocn_desc = {
	0,
	"vop_ballocn",
	0,
	vop_ballocn_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_ballocn_args, a_cred),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_BALLOCN(vp, offset, length, cred, flags)
	struct vnode *vp;
	off_t offset;
	off_t length;
	struct ucred *cred;
	int flags;
{
	struct vop_ballocn_args a;
	a.a_desc = VDESC(vop_ballocn);
	a.a_vp = vp;
	a.a_offset = offset;
	a.a_length = length;
	a.a_cred = cred;
	a.a_flags = flags;
	return (VCALL(vp, VOFFSET(vop_ballocn), &a));
}

a1304 29
int vop_size_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_size_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_size_desc = {
	0,
	"vop_size",
	0,
	vop_size_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_SIZE(vp, size, eobp)
	struct vnode *vp;
	off_t size;
	off_t *eobp;
{
	struct vop_size_args a;
	a.a_desc = VDESC(vop_size);
	a.a_vp = vp;
	a.a_size = size;
	a.a_eobp = eobp;
	return (VCALL(vp, VOFFSET(vop_size), &a));
}

a1428 1
	&vop_ballocn_desc,
a1430 1
	&vop_size_desc,
@


1.23
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.15 2001/11/28 16:24:26 art Exp 
@


1.22
log
@regen
@
text
@d1367 31
d1495 1
@


1.21
log
@more typedef zapping vm_page_t -> struct vm_page *
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.14 2001/11/27 05:27:12 art Exp 
@


1.20
log
@regen for UBC changes
@
text
@d1285 1
a1285 1
	vm_page_t *m;
d1323 1
a1323 1
	vm_page_t *m;
@


1.19
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.13 2001/07/26 20:24:47 millert Exp 
@


1.18
log
@Back out changes to symlink and mknod that were not well tested.
A simple mknod at causes a kernel panic (uvm_fault).
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.11 2001/06/23 02:21:05 csapuntz Exp 
d1233 134
d1460 4
@


1.17
log
@change vop_symlink and vop_mknod to return vpp (the created node)
refed, so that the caller can actually use it.  update callers and
file systems that implement these vnode operations

ok'd by art
@
text
@d157 1
a157 1
	0 | VDESC_VP0_WILLRELE,
d800 1
a800 1
	0 | VDESC_VP0_WILLRELE,
@


1.16
log
@Bye-bye to UFS-specific and unused functions
@
text
@d157 1
a157 1
	0 | VDESC_VP0_WILLRELE | VDESC_VPP_WILLRELE,
d800 1
a800 1
	0 | VDESC_VP0_WILLRELE | VDESC_VPP_WILLRELE,
@


1.15
log
@Regen with the right vnode_if.sh
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.10 2001/03/01 20:54:34 provos Exp 
a570 31
int vop_mmap_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_mmap_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_mmap_desc = {
	0,
	"vop_mmap",
	0,
	vop_mmap_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_mmap_args, a_cred),
	VOPARG_OFFSETOF(struct vop_mmap_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_MMAP(vp, fflags, cred, p)
	struct vnode *vp;
	int fflags;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_mmap_args a;
	a.a_desc = VDESC(vop_mmap);
	a.a_vp = vp;
	a.a_fflags = fflags;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_mmap), &a));
}

a605 31
int vop_seek_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_seek_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_seek_desc = {
	0,
	"vop_seek",
	0,
	vop_seek_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_seek_args, a_cred),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_SEEK(vp, oldoff, newoff, cred)
	struct vnode *vp;
	off_t oldoff;
	off_t newoff;
	struct ucred *cred;
{
	struct vop_seek_args a;
	a.a_desc = VDESC(vop_seek);
	a.a_vp = vp;
	a.a_oldoff = oldoff;
	a.a_newoff = newoff;
	a.a_cred = cred;
	return (VCALL(vp, VOFFSET(vop_seek), &a));
}

a1168 109
int vop_blkatoff_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_blkatoff_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_blkatoff_desc = {
	0,
	"vop_blkatoff",
	0,
	vop_blkatoff_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_BLKATOFF(vp, offset, res, bpp)
	struct vnode *vp;
	off_t offset;
	char **res;
	struct buf **bpp;
{
	struct vop_blkatoff_args a;
	a.a_desc = VDESC(vop_blkatoff);
	a.a_vp = vp;
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_blkatoff: vp");
#endif
	a.a_offset = offset;
	a.a_res = res;
	a.a_bpp = bpp;
	return (VCALL(vp, VOFFSET(vop_blkatoff), &a));
}

int vop_valloc_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_valloc_args,a_pvp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_valloc_desc = {
	0,
	"vop_valloc",
	0,
	vop_valloc_vp_offsets,
	VOPARG_OFFSETOF(struct vop_valloc_args, a_vpp),
	VOPARG_OFFSETOF(struct vop_valloc_args, a_cred),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_VALLOC(pvp, mode, cred, vpp)
	struct vnode *pvp;
	int mode;
	struct ucred *cred;
	struct vnode **vpp;
{
	struct vop_valloc_args a;
	a.a_desc = VDESC(vop_valloc);
	a.a_pvp = pvp;
#ifdef LOCKDEBUG
	if ((pvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(pvp))
		panic("vop_valloc: pvp");
#endif
	a.a_mode = mode;
	a.a_cred = cred;
	a.a_vpp = vpp;
	return (VCALL(pvp, VOFFSET(vop_valloc), &a));
}

int vop_balloc_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_balloc_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_balloc_desc = {
	0,
	"vop_balloc",
	0,
	vop_balloc_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_balloc_args, a_cred),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_BALLOC(vp, startoffset, size, cred, flags, bpp)
	struct vnode *vp;
	off_t startoffset;
	int size;
	struct ucred *cred;
	int flags;
	struct buf **bpp;
{
	struct vop_balloc_args a;
	a.a_desc = VDESC(vop_balloc);
	a.a_vp = vp;
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_balloc: vp");
#endif
	a.a_startoffset = startoffset;
	a.a_size = size;
	a.a_cred = cred;
	a.a_flags = flags;
	a.a_bpp = bpp;
	return (VCALL(vp, VOFFSET(vop_balloc), &a));
}

a1199 105
int vop_vfree_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_vfree_args,a_pvp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_vfree_desc = {
	0,
	"vop_vfree",
	0,
	vop_vfree_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_VFREE(pvp, ino, mode)
	struct vnode *pvp;
	ino_t ino;
	int mode;
{
	struct vop_vfree_args a;
	a.a_desc = VDESC(vop_vfree);
	a.a_pvp = pvp;
#ifdef LOCKDEBUG
	if ((pvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(pvp))
		panic("vop_vfree: pvp");
#endif
	a.a_ino = ino;
	a.a_mode = mode;
	return (VCALL(pvp, VOFFSET(vop_vfree), &a));
}

int vop_truncate_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_truncate_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_truncate_desc = {
	0,
	"vop_truncate",
	0,
	vop_truncate_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_truncate_args, a_cred),
	VOPARG_OFFSETOF(struct vop_truncate_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_TRUNCATE(vp, length, flags, cred, p)
	struct vnode *vp;
	off_t length;
	int flags;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_truncate_args a;
	a.a_desc = VDESC(vop_truncate);
	a.a_vp = vp;
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_truncate: vp");
#endif
	a.a_length = length;
	a.a_flags = flags;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_truncate), &a));
}

int vop_update_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_update_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_update_desc = {
	0,
	"vop_update",
	0,
	vop_update_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_UPDATE(vp, access, modify, waitfor)
	struct vnode *vp;
	struct timespec *access;
	struct timespec *modify;
	int waitfor;
{
	struct vop_update_args a;
	a.a_desc = VDESC(vop_update);
	a.a_vp = vp;
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_update: vp");
#endif
	a.a_access = access;
	a.a_modify = modify;
	a.a_waitfor = waitfor;
	return (VCALL(vp, VOFFSET(vop_update), &a));
}

a1305 1
	&vop_mmap_desc,
a1306 1
	&vop_seek_desc,
a1323 3
	&vop_blkatoff_desc,
	&vop_valloc_desc,
	&vop_balloc_desc,
a1324 3
	&vop_vfree_desc,
	&vop_truncate_desc,
	&vop_update_desc,
@


1.14
log
@sync
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.6 1999/03/03 20:58:27 deraadt Exp 
d140 3
a142 2
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_create: dvp");
d175 3
a177 2
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_mknod: dvp");
d272 3
a274 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_access: vp");
d338 3
a340 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_setattr: vp");
d373 3
a375 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_read: vp");
d408 3
a410 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_write: vp");
d627 3
a629 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_fsync: vp");
d693 3
a695 2
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_remove: dvp");
d698 3
a700 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_remove: vp");
d731 3
a733 2
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_link: dvp");
d773 3
a775 2
#ifdef DIAGNOSTIC
	if ((tdvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(tdvp)) panic("vop_rename: tdvp");
d807 3
a809 2
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_mkdir: dvp");
d842 3
a844 2
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_rmdir: dvp");
d847 3
a849 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_rmdir: vp");
d881 3
a883 2
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_symlink: dvp");
d919 3
a921 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_readdir: vp");
d955 3
a957 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_readlink: vp");
d1014 3
a1016 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_inactive: vp");
d1133 3
a1135 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_bmap: vp");
d1256 3
a1258 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_blkatoff: vp");
d1291 3
a1293 2
#ifdef DIAGNOSTIC
	if ((pvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(pvp)) panic("vop_valloc: pvp");
d1328 3
a1330 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_balloc: vp");
d1363 3
a1365 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_reallocblks: vp");
d1395 3
a1397 2
#ifdef DIAGNOSTIC
	if ((pvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(pvp)) panic("vop_vfree: pvp");
d1430 3
a1432 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_truncate: vp");
d1466 3
a1468 2
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_update: vp");
d1500 3
a1502 2
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_whiteout: dvp");
@


1.13
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.9 1998/12/05 16:54:02 csapuntz Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.8 2001/02/26 17:34:18 art Exp 
d140 2
a141 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_create: dvp");
d174 2
a175 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_mknod: dvp");
d270 2
a271 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_access: vp");
d335 2
a336 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_setattr: vp");
d369 2
a370 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_read: vp");
d403 2
a404 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_write: vp");
d511 27
d621 2
a622 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_fsync: vp");
d686 2
a687 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_remove: dvp");
d690 2
a691 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_remove: vp");
d722 2
a723 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_link: dvp");
d763 2
a764 3
#ifdef LOCKDEBUG
	if ((tdvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(tdvp))
		panic("vop_rename: tdvp");
d796 2
a797 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_mkdir: dvp");
d830 2
a831 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_rmdir: dvp");
d834 2
a835 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_rmdir: vp");
d867 2
a868 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_symlink: dvp");
d904 2
a905 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_readdir: vp");
d939 2
a940 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_readlink: vp");
d997 2
a998 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_inactive: vp");
d1115 2
a1116 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_bmap: vp");
d1237 2
a1238 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_blkatoff: vp");
d1271 2
a1272 3
#ifdef LOCKDEBUG
	if ((pvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(pvp))
		panic("vop_valloc: pvp");
d1307 2
a1308 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_balloc: vp");
d1341 2
a1342 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_reallocblks: vp");
d1372 2
a1373 3
#ifdef LOCKDEBUG
	if ((pvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(pvp))
		panic("vop_vfree: pvp");
d1406 2
a1407 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_truncate: vp");
d1441 2
a1442 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_update: vp");
d1474 2
a1475 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_whiteout: dvp");
d1553 1
@


1.12
log
@regen
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.7 2001/02/26 17:12:27 art Exp 
d140 1
a140 1
#ifdef DIAGNOSTIC
d175 1
a175 1
#ifdef DIAGNOSTIC
d272 1
a272 1
#ifdef DIAGNOSTIC
d338 1
a338 1
#ifdef DIAGNOSTIC
d373 1
a373 1
#ifdef DIAGNOSTIC
d408 1
a408 1
#ifdef DIAGNOSTIC
d600 1
a600 1
#ifdef DIAGNOSTIC
d666 1
a666 1
#ifdef DIAGNOSTIC
d671 1
a671 1
#ifdef DIAGNOSTIC
d704 1
a704 1
#ifdef DIAGNOSTIC
d746 1
a746 1
#ifdef DIAGNOSTIC
d780 1
a780 1
#ifdef DIAGNOSTIC
d815 1
a815 1
#ifdef DIAGNOSTIC
d820 1
a820 1
#ifdef DIAGNOSTIC
d854 1
a854 1
#ifdef DIAGNOSTIC
d892 1
a892 1
#ifdef DIAGNOSTIC
d928 1
a928 1
#ifdef DIAGNOSTIC
d987 1
a987 1
#ifdef DIAGNOSTIC
d1106 1
a1106 1
#ifdef DIAGNOSTIC
d1229 1
a1229 1
#ifdef DIAGNOSTIC
d1264 1
a1264 1
#ifdef DIAGNOSTIC
d1301 1
a1301 1
#ifdef DIAGNOSTIC
d1336 1
a1336 1
#ifdef DIAGNOSTIC
d1368 1
a1368 1
#ifdef DIAGNOSTIC
d1403 1
a1403 1
#ifdef DIAGNOSTIC
d1439 1
a1439 1
#ifdef DIAGNOSTIC
d1473 1
a1473 1
#ifdef DIAGNOSTIC
@


1.11
log
@sync
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.6 1999/03/03 20:58:27 deraadt Exp 
d141 2
a142 1
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_create: dvp");
d176 2
a177 1
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_mknod: dvp");
d273 2
a274 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_access: vp");
d339 2
a340 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_setattr: vp");
d374 2
a375 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_read: vp");
d409 2
a410 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_write: vp");
d601 2
a602 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_fsync: vp");
d667 2
a668 1
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_remove: dvp");
d672 2
a673 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_remove: vp");
d705 2
a706 1
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_link: dvp");
d747 2
a748 1
	if ((tdvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(tdvp)) panic("vop_rename: tdvp");
d781 2
a782 1
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_mkdir: dvp");
d816 2
a817 1
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_rmdir: dvp");
d821 2
a822 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_rmdir: vp");
d855 2
a856 1
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_symlink: dvp");
d893 2
a894 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_readdir: vp");
d929 2
a930 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_readlink: vp");
d988 2
a989 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_inactive: vp");
d1107 2
a1108 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_bmap: vp");
d1230 2
a1231 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_blkatoff: vp");
d1265 2
a1266 1
	if ((pvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(pvp)) panic("vop_valloc: pvp");
d1302 2
a1303 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_balloc: vp");
d1337 2
a1338 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_reallocblks: vp");
d1369 2
a1370 1
	if ((pvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(pvp)) panic("vop_vfree: pvp");
d1404 2
a1405 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_truncate: vp");
d1440 2
a1441 1
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_update: vp");
d1474 2
a1475 1
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_whiteout: dvp");
@


1.11.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.10 2001/03/01 20:54:34 provos Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.8 2001/02/26 17:34:18 art Exp 
d140 2
a141 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_create: dvp");
d174 2
a175 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_mknod: dvp");
d270 2
a271 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_access: vp");
d335 2
a336 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_setattr: vp");
d369 2
a370 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_read: vp");
d403 2
a404 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_write: vp");
a510 27
int vop_kqfilter_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_kqfilter_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_kqfilter_desc = {
	0,
	"vop_kqfilter",
	0,
	vop_kqfilter_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_KQFILTER(vp, kn)
	struct vnode *vp;
	struct knote *kn;
{
	struct vop_kqfilter_args a;
	a.a_desc = VDESC(vop_kqfilter);
	a.a_vp = vp;
	a.a_kn = kn;
	return (VCALL(vp, VOFFSET(vop_kqfilter), &a));
}

d594 2
a595 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_fsync: vp");
d659 2
a660 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_remove: dvp");
d663 2
a664 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_remove: vp");
d695 2
a696 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_link: dvp");
d736 2
a737 3
#ifdef LOCKDEBUG
	if ((tdvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(tdvp))
		panic("vop_rename: tdvp");
d769 2
a770 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_mkdir: dvp");
d803 2
a804 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_rmdir: dvp");
d807 2
a808 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_rmdir: vp");
d840 2
a841 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_symlink: dvp");
d877 2
a878 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_readdir: vp");
d912 2
a913 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_readlink: vp");
d970 2
a971 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_inactive: vp");
d1088 2
a1089 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_bmap: vp");
d1210 2
a1211 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_blkatoff: vp");
d1244 2
a1245 3
#ifdef LOCKDEBUG
	if ((pvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(pvp))
		panic("vop_valloc: pvp");
d1280 2
a1281 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_balloc: vp");
d1314 2
a1315 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_reallocblks: vp");
d1345 2
a1346 3
#ifdef LOCKDEBUG
	if ((pvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(pvp))
		panic("vop_vfree: pvp");
d1379 2
a1380 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_truncate: vp");
d1414 2
a1415 3
#ifdef LOCKDEBUG
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp))
		panic("vop_update: vp");
d1447 2
a1448 3
#ifdef LOCKDEBUG
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp))
		panic("vop_whiteout: dvp");
a1525 1
	&vop_kqfilter_desc,
@


1.11.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.11 2001/06/23 02:21:05 csapuntz Exp 
d571 31
d637 31
d1231 109
d1371 105
d1582 1
d1584 1
d1602 3
d1606 3
@


1.11.6.3
log
@Merge in -current
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.15 2001/11/28 16:24:26 art Exp 
a1232 134
int vop_ballocn_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_ballocn_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_ballocn_desc = {
	0,
	"vop_ballocn",
	0,
	vop_ballocn_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_ballocn_args, a_cred),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_BALLOCN(vp, offset, length, cred, flags)
	struct vnode *vp;
	off_t offset;
	off_t length;
	struct ucred *cred;
	int flags;
{
	struct vop_ballocn_args a;
	a.a_desc = VDESC(vop_ballocn);
	a.a_vp = vp;
	a.a_offset = offset;
	a.a_length = length;
	a.a_cred = cred;
	a.a_flags = flags;
	return (VCALL(vp, VOFFSET(vop_ballocn), &a));
}

int vop_getpages_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_getpages_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_getpages_desc = {
	0,
	"vop_getpages",
	0,
	vop_getpages_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_GETPAGES(vp, offset, m, count, centeridx, access_type, advice, flags)
	struct vnode *vp;
	voff_t offset;
	struct vm_page **m;
	int *count;
	int centeridx;
	vm_prot_t access_type;
	int advice;
	int flags;
{
	struct vop_getpages_args a;
	a.a_desc = VDESC(vop_getpages);
	a.a_vp = vp;
	a.a_offset = offset;
	a.a_m = m;
	a.a_count = count;
	a.a_centeridx = centeridx;
	a.a_access_type = access_type;
	a.a_advice = advice;
	a.a_flags = flags;
	return (VCALL(vp, VOFFSET(vop_getpages), &a));
}

int vop_putpages_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_putpages_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_putpages_desc = {
	0,
	"vop_putpages",
	0,
	vop_putpages_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_PUTPAGES(vp, m, count, flags, rtvals)
	struct vnode *vp;
	struct vm_page **m;
	int count;
	int flags;
	int *rtvals;
{
	struct vop_putpages_args a;
	a.a_desc = VDESC(vop_putpages);
	a.a_vp = vp;
	a.a_m = m;
	a.a_count = count;
	a.a_flags = flags;
	a.a_rtvals = rtvals;
	return (VCALL(vp, VOFFSET(vop_putpages), &a));
}

int vop_size_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_size_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_size_desc = {
	0,
	"vop_size",
	0,
	vop_size_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

int VOP_SIZE(vp, size, eobp)
	struct vnode *vp;
	off_t size;
	off_t *eobp;
{
	struct vop_size_args a;
	a.a_desc = VDESC(vop_size);
	a.a_vp = vp;
	a.a_size = size;
	a.a_eobp = eobp;
	return (VCALL(vp, VOFFSET(vop_size), &a));
}

a1325 4
	&vop_ballocn_desc,
	&vop_getpages_desc,
	&vop_putpages_desc,
	&vop_size_desc,
@


1.11.6.4
log
@Merge in trunk
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.19 2002/02/22 20:37:45 drahn Exp 
d1233 2
a1234 2
int vop_getextattr_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_getextattr_args,a_vp),
d1237 1
a1237 1
struct vnodeop_desc vop_getextattr_desc = {
d1239 1
a1239 1
	"vop_getextattr",
d1241 3
a1243 1
	vop_getextattr_vp_offsets,
a1244 2
	VOPARG_OFFSETOF(struct vop_getextattr_args, a_cred),
	VOPARG_OFFSETOF(struct vop_getextattr_args, a_p),
d1249 1
a1249 1
int VOP_GETEXTATTR(vp, attrnamespace, name, uio, size, cred, p)
d1251 2
a1252 4
	int attrnamespace;
	const char *name;
	struct uio *uio;
	size_t *size;
d1254 1
a1254 1
	struct proc *p;
d1256 2
a1257 2
	struct vop_getextattr_args a;
	a.a_desc = VDESC(vop_getextattr);
d1259 2
a1260 4
	a.a_attrnamespace = attrnamespace;
	a.a_name = name;
	a.a_uio = uio;
	a.a_size = size;
d1262 74
a1335 2
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_getextattr), &a));
d1338 2
a1339 2
int vop_setextattr_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_setextattr_args,a_vp),
d1342 1
a1342 1
struct vnodeop_desc vop_setextattr_desc = {
d1344 1
a1344 1
	"vop_setextattr",
d1346 3
a1348 1
	vop_setextattr_vp_offsets,
a1349 2
	VOPARG_OFFSETOF(struct vop_setextattr_args, a_cred),
	VOPARG_OFFSETOF(struct vop_setextattr_args, a_p),
d1354 1
a1354 1
int VOP_SETEXTATTR(vp, attrnamespace, name, uio, cred, p)
d1356 2
a1357 5
	int attrnamespace;
	const char *name;
	struct uio *uio;
	struct ucred *cred;
	struct proc *p;
d1359 2
a1360 2
	struct vop_setextattr_args a;
	a.a_desc = VDESC(vop_setextattr);
d1362 3
a1364 6
	a.a_attrnamespace = attrnamespace;
	a.a_name = name;
	a.a_uio = uio;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_setextattr), &a));
d1460 4
a1463 2
	&vop_getextattr_desc,
	&vop_setextattr_desc,
@


1.11.6.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.20 2003/05/01 21:13:05 tedu Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.12 2003/05/01 21:41:35 tedu Exp 
d122 1
a122 1
	0 | VDESC_VP0_WILLPUT,
d157 1
a157 1
	0 | VDESC_VP0_WILLPUT | VDESC_VPP_WILLRELE,
d614 1
a614 1
	0 | VDESC_VP0_WILLPUT | VDESC_VP1_WILLPUT,
d652 1
a652 1
	0 | VDESC_VP0_WILLPUT,
d688 1
a688 1
	0 | VDESC_VP0_WILLRELE | VDESC_VP1_WILLRELE | VDESC_VP2_WILLPUT | VDESC_VP3_WILLRELE,
d727 1
a727 1
	0 | VDESC_VP0_WILLPUT,
d763 1
a763 1
	0 | VDESC_VP0_WILLPUT | VDESC_VP1_WILLPUT,
d800 1
a800 1
	0 | VDESC_VP0_WILLPUT | VDESC_VPP_WILLRELE,
d936 1
a936 1
	0 | VDESC_VP0_WILLUNLOCK,
@


1.11.6.6
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.9.6.6 2003/05/13 19:21:29 ho Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.6.6.3 2003/05/13 19:21:29 ho Exp 
@


1.11.6.7
log
@Sync SMP branch to -current
@
text
@d23 5
a27 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.6.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d6 1
a6 1
 *	OpenBSD
d8 1
a8 1
 *	OpenBSD
d464 1
a464 1
	void *data;
d480 2
a481 2
int vop_poll_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_poll_args,a_vp),
d484 1
a484 1
struct vnodeop_desc vop_poll_desc = {
d486 1
a486 1
	"vop_poll",
d488 1
a488 1
	vop_poll_vp_offsets,
d490 2
a491 2
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_poll_args, a_p),
d496 1
a496 1
int VOP_POLL(vp, events, p)
d498 3
a500 1
	int events;
d503 2
a504 2
	struct vop_poll_args a;
	a.a_desc = VDESC(vop_poll);
d506 3
a508 1
	a.a_events = events;
d510 1
a510 1
	return (VCALL(vp, VOFFSET(vop_poll), &a));
d1150 1
a1150 1
	void *id;
d1371 1
a1371 1
	&vop_poll_desc,
@


1.10
log
@vnode_if sync
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.5 1999/03/03 14:23:19 deraadt Exp 
a43 1
#define INTERNAL_VOP_NOT_INLINE
d77 9
d102 13
d131 18
d165 18
d199 15
d230 15
d261 18
d295 15
d326 18
d360 18
d394 18
d428 15
d459 19
d494 17
d527 11
d554 15
d585 18
d619 15
d651 19
d687 16
d722 22
d760 18
d795 19
d830 20
d866 22
d904 16
d936 11
d963 14
d993 11
d1020 13
d1049 13
d1078 20
d1114 9
d1139 13
d1168 17
d1201 18
d1235 18
d1269 22
d1307 14
d1337 16
d1369 20
d1405 18
d1439 16
d1472 9
d1495 9
@


1.9
log
@

Framework for generating automatic test code for locking discipline
in DIAGNOSTIC mode.

Added documentation to vfs_subr.c on locking needs of a couple calls.

Improvements to the vinvalbuf patch. We need to start over after we
let our pants down.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.8 1998/08/08 03:53:30 csapuntz Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.3 1996/04/19 16:09:13 niklas Exp 
d44 1
@


1.8
log
@sync
@
text
@d61 16
a594 16
int vop_islocked_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_islocked_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_islocked_desc = {
	0,
	"vop_islocked",
	0,
	vop_islocked_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

d794 1
a826 1
	&vop_islocked_desc,
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.4 1996/05/22 11:47:12 deraadt Exp 
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d221 16
d269 16
d494 1
a494 1
	VDESC_NO_OFFSET,
d510 1
a510 1
	VDESC_NO_OFFSET,
d526 1
a526 1
	VDESC_NO_OFFSET,
d542 1
a542 1
	VDESC_NO_OFFSET,
d659 16
a738 16
int vop_lease_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_lease_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_lease_desc = {
	0,
	"vop_lease",
	0,
	vop_lease_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_lease_args, a_cred),
	VOPARG_OFFSETOF(struct vop_lease_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
};

d804 1
d807 1
d831 1
a835 1
	&vop_lease_desc,
@


1.5
log
@VFS Lite2 Changes
@
text
@a220 16
int vop_lease_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_lease_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_lease_desc = {
	0,
	"vop_lease",
	0,
	vop_lease_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_lease_args, a_cred),
	VOPARG_OFFSETOF(struct vop_lease_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
};

a252 16
int vop_revoke_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_revoke_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_revoke_desc = {
	0,
	"vop_revoke",
	0,
	vop_revoke_vp_offsets,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

d462 1
a462 1
	VOPARG_OFFSETOF(struct vop_inactive_args, a_p),
d478 1
a478 1
	VOPARG_OFFSETOF(struct vop_reclaim_args, a_p),
d494 1
a494 1
	VOPARG_OFFSETOF(struct vop_lock_args, a_p),
d510 1
a510 1
	VOPARG_OFFSETOF(struct vop_unlock_args, a_p),
a626 16
int vop_balloc_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_balloc_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_balloc_desc = {
	0,
	"vop_balloc",
	0,
	vop_balloc_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_balloc_args, a_cred),
	VDESC_NO_OFFSET,
	VDESC_NO_OFFSET,
	NULL,
};

d691 16
a771 1
	&vop_lease_desc,
a773 1
	&vop_revoke_desc,
a796 1
	&vop_balloc_desc,
d801 1
@


1.4
log
@Regen.
@
text
@d221 16
d269 16
d494 1
a494 1
	VDESC_NO_OFFSET,
d510 1
a510 1
	VDESC_NO_OFFSET,
d526 1
a526 1
	VDESC_NO_OFFSET,
d542 1
a542 1
	VDESC_NO_OFFSET,
d659 16
a738 16
int vop_lease_vp_offsets[] = {
	VOPARG_OFFSETOF(struct vop_lease_args,a_vp),
	VDESC_NO_OFFSET
};
struct vnodeop_desc vop_lease_desc = {
	0,
	"vop_lease",
	0,
	vop_lease_vp_offsets,
	VDESC_NO_OFFSET,
	VOPARG_OFFSETOF(struct vop_lease_args, a_cred),
	VOPARG_OFFSETOF(struct vop_lease_args, a_p),
	VDESC_NO_OFFSET,
	NULL,
};

d804 1
d807 1
d831 1
a835 1
	&vop_lease_desc,
@


1.3
log
@sync
@
text
@d8 1
a8 1
 *	OpenBSD
@


1.2
log
@NetBSD 960317 merge
@
text
@d6 1
a6 1
 *	OpenBSD
@


1.1
log
@From NetBSD: vnode_if.[ch] made machine independent.
very usefull (for <sys/vnode.h> inclusion).
from the other side this is really machine independent ...
tested w/ i386, but should not cause errors w/ other arch's.
pls, test it (don't forget to reconfig kernel ;)
@
text
@d6 1
a6 1
 *	NetBSD: vnode_if.src,v 1.9 1996/02/09 14:45:38 mycroft Exp 
d8 1
a8 1
 *	NetBSD: vnode_if.sh,v 1.9 1996/02/29 20:58:22 cgd Exp 
@
