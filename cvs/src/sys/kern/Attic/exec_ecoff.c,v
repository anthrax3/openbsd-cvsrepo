head	1.11;
access;
symbols
	OPENBSD_5_4:1.10.0.32
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.30
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.28
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.26
	OPENBSD_5_0:1.10.0.24
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.22
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.20
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.16
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.18
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.14
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.12
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.10
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.8
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.18
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.16
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.14
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.12
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.10
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.8
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.6
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.4
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.8
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.6
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.8
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2013.10.17.08.02.20;	author deraadt;	state dead;
branches;
next	1.10;

1.10
date	2005.11.12.04.31.24;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.15.06.22.30;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.22.14.14.07;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.31.14.49.06;	author ericj;	state Exp;
branches;
next	1.5;

1.5
date	99.01.11.05.12.21;	author millert;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	96.12.23.02.42.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.12.05.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.16.08.47;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches;
next	;

1.5.6.1
date	2001.05.14.22.32.38;	author niklas;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2001.07.04.10.48.11;	author niklas;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.5.6.4;

1.5.6.4
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@/*	$OpenBSD: exec_ecoff.c,v 1.10 2005/11/12 04:31:24 jsg Exp $	*/
/*	$NetBSD: exec_ecoff.c,v 1.8 1996/05/19 20:36:06 jonathan Exp $	*/

/*
 * Copyright (c) 1994 Adam Glass
 * Copyright (c) 1993, 1994, 1996 Christopher G. Demetriou
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/vnode.h>
#include <sys/exec.h>
#include <sys/resourcevar.h>
#include <uvm/uvm_extern.h>

#if defined(_KERN_DO_ECOFF)

#include <sys/exec_ecoff.h>

/*
 * exec_ecoff_makecmds(): Check if it's an ecoff-format executable.
 *
 * Given a proc pointer and an exec package pointer, see if the referent
 * of the epp is in ecoff format.  Check 'standard' magic numbers for
 * this architecture.  If that fails, return failure.
 *
 * This function is  responsible for creating a set of vmcmds which can be
 * used to build the process's vm space and inserting them into the exec
 * package.
 */
int
exec_ecoff_makecmds(struct proc *p, struct exec_package *epp)
{
	int error;
	struct ecoff_exechdr *execp = epp->ep_hdr;

	if (epp->ep_hdrvalid < ECOFF_HDR_SIZE)
		return ENOEXEC;

	if (ECOFF_BADMAG(execp))
		return ENOEXEC;

	switch (execp->a.magic) {
	case ECOFF_OMAGIC:
		error = exec_ecoff_prep_omagic(p, epp);
		break;
	case ECOFF_NMAGIC:
		error = exec_ecoff_prep_nmagic(p, epp);
		break;
	case ECOFF_ZMAGIC:
		error = exec_ecoff_prep_zmagic(p, epp);
		break;
	default:
		return ENOEXEC;
	}

	if (error == 0)
		error = cpu_exec_ecoff_hook(p, epp);

	if (error)
		kill_vmcmds(&epp->ep_vmcmds);

	return error;
}

/*
 * exec_ecoff_prep_omagic(): Prepare a ECOFF OMAGIC binary's exec package
 */
int
exec_ecoff_prep_omagic(struct proc *p, struct exec_package *epp)
{
	struct ecoff_exechdr *execp = epp->ep_hdr;
	struct ecoff_aouthdr *eap = &execp->a;

	epp->ep_taddr = ECOFF_SEGMENT_ALIGN(execp, eap->text_start);
	epp->ep_tsize = eap->tsize;
	epp->ep_daddr = ECOFF_SEGMENT_ALIGN(execp, eap->data_start);
	epp->ep_dsize = eap->dsize + eap->bsize;
	epp->ep_entry = eap->entry;

	/* set up command for text and data segments */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn,
	    eap->tsize + eap->dsize, epp->ep_taddr, epp->ep_vp,
	    ECOFF_TXTOFF(execp),
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	if (eap->bsize > 0)
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, eap->bsize,
		    ECOFF_SEGMENT_ALIGN(execp, eap->bss_start), NULLVP, 0,
		    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return exec_setup_stack(p, epp);
}

/*
 * exec_ecoff_prep_nmagic(): Prepare a 'native' NMAGIC ECOFF binary's exec
 *                           package.
 */
int
exec_ecoff_prep_nmagic(struct proc *p, struct exec_package *epp)
{
	struct ecoff_exechdr *execp = epp->ep_hdr;
	struct ecoff_aouthdr *eap = &execp->a;

	epp->ep_taddr = ECOFF_SEGMENT_ALIGN(execp, eap->text_start);
	epp->ep_tsize = eap->tsize;
	epp->ep_daddr = ECOFF_ROUND(eap->data_start, ECOFF_LDPGSZ);
	epp->ep_dsize = eap->dsize + eap->bsize;
	epp->ep_entry = eap->entry;

	/* set up command for text segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, epp->ep_tsize,
	    epp->ep_taddr, epp->ep_vp, ECOFF_TXTOFF(execp),
	    VM_PROT_READ|VM_PROT_EXECUTE);

	/* set up command for data segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, epp->ep_dsize,
	    epp->ep_daddr, epp->ep_vp, ECOFF_DATOFF(execp),
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	if (eap->bsize > 0)
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, eap->bsize,
		    ECOFF_SEGMENT_ALIGN(execp, eap->bss_start), NULLVP, 0,
		    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return exec_setup_stack(p, epp);
}

/*
 * exec_ecoff_prep_zmagic(): Prepare a ECOFF ZMAGIC binary's exec package
 *
 * First, set the various offsets/lengths in the exec package.
 *
 * Then, mark the text image busy (so it can be demand paged) or error
 * out if this is not possible.  Finally, set up vmcmds for the
 * text, data, bss, and stack segments.
 */
int
exec_ecoff_prep_zmagic(struct proc *p, struct exec_package *epp)
{
	struct ecoff_exechdr *execp = epp->ep_hdr;
	struct ecoff_aouthdr *eap = &execp->a;

	epp->ep_taddr = ECOFF_SEGMENT_ALIGN(execp, eap->text_start);
	epp->ep_tsize = eap->tsize;
	epp->ep_daddr = ECOFF_SEGMENT_ALIGN(execp, eap->data_start);
	epp->ep_dsize = eap->dsize + eap->bsize;
	epp->ep_entry = eap->entry;

	/*
	 * check if vnode is in open for writing, because we want to
	 * demand-page out of it.  if it is, don't do it, for various
	 * reasons
	 */
	if ((eap->tsize != 0 || eap->dsize != 0) &&
	    epp->ep_vp->v_writecount != 0) {
#ifdef DIAGNOSTIC
		if (epp->ep_vp->v_flag & VTEXT)
			panic("exec: a VTEXT vnode has writecount != 0");
#endif
		return ETXTBSY;
	}
	vn_marktext(epp->ep_vp);

	/* set up command for text segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, eap->tsize,
	    epp->ep_taddr, epp->ep_vp, ECOFF_TXTOFF(execp),
	    VM_PROT_READ|VM_PROT_EXECUTE);

	/* set up command for data segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, eap->dsize,
	    epp->ep_daddr, epp->ep_vp, ECOFF_DATOFF(execp),
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	/* set up command for bss segment */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, eap->bsize,
	    ECOFF_SEGMENT_ALIGN(execp, eap->bss_start), NULLVP, 0,
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return exec_setup_stack(p, epp);
}

#endif /* _KERN_DO_ECOFF */
@


1.10
log
@ansi. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_ecoff.c,v 1.9 2001/11/15 06:22:30 art Exp $	*/
@


1.9
log
@New function vn_marktext - mark a vnode as executing a text image.
Use where VTEXT was set in vnode flags before. Doesn't do anything else (yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_ecoff.c,v 1.8 2001/11/06 19:53:20 miod Exp $	*/
d60 1
a60 3
exec_ecoff_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
d98 1
a98 3
exec_ecoff_prep_omagic(p, epp)
	struct proc *p;
	struct exec_package *epp;
d129 1
a129 3
exec_ecoff_prep_nmagic(p, epp)
	struct proc *p;
	struct exec_package *epp;
d169 1
a169 3
exec_ecoff_prep_zmagic(p, epp)
	struct proc *p;
	struct exec_package *epp;
@


1.8
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_ecoff.c,v 1.7 2001/06/22 14:14:07 deraadt Exp $	*/
d201 1
a201 1
	epp->ep_vp->v_flag |= VTEXT;
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_ecoff.c,v 1.6 2000/08/31 14:49:06 ericj Exp $	*/
d42 1
a42 1
#include <vm/vm.h>
@


1.6
log
@
re-org ecoff headers. move some declarations from exec_ecoff.c to exec_ecoff.h
so they can be used for osf1 emul.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_ecoff.c,v 1.5 1999/01/11 05:12:21 millert Exp $	*/
d72 1
a72 1
	
d124 1
a124 1
	
@


1.5
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_ecoff.c,v 1.4 1996/12/23 02:42:42 deraadt Exp $	*/
a46 5

int	exec_ecoff_prep_omagic __P((struct proc *, struct exec_package *));
int	exec_ecoff_prep_nmagic __P((struct proc *, struct exec_package *));
int	exec_ecoff_prep_zmagic __P((struct proc *, struct exec_package *));
int	exec_ecoff_setup_stack __P((struct proc *, struct exec_package *));
@


1.5.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_ecoff.c,v 1.6 2000/08/31 14:49:06 ericj Exp $	*/
d47 5
@


1.5.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_ecoff.c,v 1.5.6.1 2001/05/14 22:32:38 niklas Exp $	*/
d72 1
a72 1

d124 1
a124 1

@


1.5.6.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
#include <uvm/uvm_extern.h>
@


1.5.6.4
log
@Merge in -current
@
text
@d201 1
a201 1
	vn_marktext(epp->ep_vp);
@


1.4
log
@use _{NLIST,KERN}_DO_{AOUT,ELF,ECOFF} to select binary types
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_ecoff.c,v 1.3 1996/05/22 12:05:19 deraadt Exp $	*/
d202 1
a202 1
			panic("exec: a VTEXT vnode has writecount != 0\n");
@


1.3
log
@fiddling
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 2
a101 43
 * exec_ecoff_setup_stack(): Set up the stack segment for an ecoff
 * executable.
 *
 * Note that the ep_ssize parameter must be set to be the current stack
 * limit; this is adjusted in the body of execve() to yield the
 * appropriate stack segment usage once the argument length is
 * calculated.
 *
 * This function returns an int for uniformity with other (future) formats'
 * stack setup functions.  They might have errors to return.
 */
int
exec_ecoff_setup_stack(p, epp)
	struct proc *p;
	struct exec_package *epp;
{

	epp->ep_maxsaddr = USRSTACK - MAXSSIZ;
	epp->ep_minsaddr = USRSTACK;
	epp->ep_ssize = p->p_rlimit[RLIMIT_STACK].rlim_cur;

	/*
	 * set up commands for stack.  note that this takes *two*, one to
	 * map the part of the stack which we can access, and one to map
	 * the part which we can't.
	 *
	 * arguably, it could be made into one, but that would require the
	 * addition of another mapping proc, which is unnecessary
	 *
	 * note that in memory, things assumed to be: 0 ....... ep_maxsaddr
	 * <stack> ep_minsaddr
	 */
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero,
	    ((epp->ep_minsaddr - epp->ep_ssize) - epp->ep_maxsaddr),
	    epp->ep_maxsaddr, NULLVP, 0, VM_PROT_NONE);
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, epp->ep_ssize,
	    (epp->ep_minsaddr - epp->ep_ssize), NULLVP, 0,
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);

	return 0;
}

/*
d130 1
a130 1
	return exec_ecoff_setup_stack(p, epp);
d167 1
a167 1
	return exec_ecoff_setup_stack(p, epp);
d223 1
a223 1
	return exec_ecoff_setup_stack(p, epp);
d225 2
@


1.2
log
@NetBSD 960317 merge
@
text
@d2 1
a2 1
/*	$NetBSD: exec_ecoff.c,v 1.6 1996/03/07 14:31:16 christos Exp $	*/
d6 1
a6 1
 * Copyright (c) 1993, 1994 Christopher G. Demetriou
d46 3
a48 9
int	exec_ecoff_prep_omagic __P((struct proc *, struct exec_package *,
				    struct ecoff_filehdr *, 
				    struct ecoff_aouthdr *));
int	exec_ecoff_prep_nmagic __P((struct proc *, struct exec_package *,
				    struct ecoff_filehdr *, 
				    struct ecoff_aouthdr *));
int	exec_ecoff_prep_zmagic __P((struct proc *, struct exec_package *,
				    struct ecoff_filehdr *, 
				    struct ecoff_aouthdr *));
a61 1

d68 1
a68 2
	struct ecoff_filehdr *efp = epp->ep_hdr;
	struct ecoff_aouthdr *eap;
d73 1
a73 1
	if (ECOFF_BADMAG(efp))
d76 1
a76 3
	eap = (struct ecoff_aouthdr *)
	    ((caddr_t)epp->ep_hdr + sizeof(struct ecoff_filehdr));
	switch (eap->ea_magic) {
d78 1
a78 1
		error = exec_ecoff_prep_omagic(p, epp, efp, eap);
d81 1
a81 1
		error = exec_ecoff_prep_nmagic(p, epp, efp, eap);
d84 1
a84 1
		error = exec_ecoff_prep_zmagic(p, epp, efp, eap);
d91 1
a91 1
		error = cpu_exec_ecoff_hook(p, epp, eap);
a110 1

d133 2
a134 2
		  ((epp->ep_minsaddr - epp->ep_ssize) - epp->ep_maxsaddr),
		  epp->ep_maxsaddr, NULLVP, 0, VM_PROT_NONE);
d136 2
a137 2
		  (epp->ep_minsaddr - epp->ep_ssize), NULLVP, 0,
		  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
a141 1

a144 1

d146 1
a146 1
exec_ecoff_prep_omagic(p, epp, efp, eap)
a148 2
	struct ecoff_filehdr *efp;
	struct ecoff_aouthdr *eap;
d150 8
a157 5
	epp->ep_taddr = ECOFF_SEGMENT_ALIGN(eap, eap->ea_text_start);
	epp->ep_tsize = eap->ea_tsize;
	epp->ep_daddr = ECOFF_SEGMENT_ALIGN(eap, eap->ea_data_start);
	epp->ep_dsize = eap->ea_dsize + eap->ea_bsize;
	epp->ep_entry = eap->ea_entry;
d161 3
a163 3
		  eap->ea_tsize + eap->ea_dsize, epp->ep_taddr, epp->ep_vp,
		  ECOFF_TXTOFF(efp, eap),
		  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
d166 4
a169 5
	if (eap->ea_bsize > 0)
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, eap->ea_bsize,
			  ECOFF_SEGMENT_ALIGN(eap, eap->ea_bss_start),
			  NULLVP, 0,
			  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
a177 1

d179 1
a179 1
exec_ecoff_prep_nmagic(p, epp, efp, eap)
a181 2
	struct ecoff_filehdr *efp;
	struct ecoff_aouthdr *eap;
d183 8
a190 5
	epp->ep_taddr = ECOFF_SEGMENT_ALIGN(eap, eap->ea_text_start);
	epp->ep_tsize = eap->ea_tsize;
	epp->ep_daddr = ECOFF_ROUND(eap->ea_data_start, ECOFF_LDPGSZ);
	epp->ep_dsize = eap->ea_dsize + eap->ea_bsize;
	epp->ep_entry = eap->ea_entry;
d194 2
a195 2
		  epp->ep_taddr, epp->ep_vp, ECOFF_TXTOFF(efp, eap),
		  VM_PROT_READ|VM_PROT_EXECUTE);
d199 2
a200 2
		  epp->ep_daddr, epp->ep_vp, ECOFF_DATOFF(efp, eap),
		  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
d203 4
a206 5
	if (eap->ea_bsize > 0)
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, eap->ea_bsize,
			  ECOFF_SEGMENT_ALIGN(eap, eap->ea_bss_start),
			  NULLVP, 0,
			  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
a219 1

d221 1
a221 1
exec_ecoff_prep_zmagic(p, epp, efp, eap)
a223 2
	struct ecoff_filehdr *efp;
	struct ecoff_aouthdr *eap;
d225 8
a232 5
	epp->ep_taddr = ECOFF_SEGMENT_ALIGN(eap, eap->ea_text_start);
	epp->ep_tsize = eap->ea_tsize;
	epp->ep_daddr = ECOFF_SEGMENT_ALIGN(eap, eap->ea_data_start);
	epp->ep_dsize = eap->ea_dsize + eap->ea_bsize;
	epp->ep_entry = eap->ea_entry;
d239 1
a239 1
	if ((eap->ea_tsize != 0 || eap->ea_dsize != 0) &&
d250 3
a252 3
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, eap->ea_tsize,
		  epp->ep_taddr, epp->ep_vp, ECOFF_TXTOFF(efp, eap),
		  VM_PROT_READ|VM_PROT_EXECUTE);
d255 3
a257 4
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_pagedvn, eap->ea_dsize,
		  epp->ep_daddr, epp->ep_vp,
		  ECOFF_DATOFF(efp, eap),
		  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
d260 3
a262 3
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, eap->ea_bsize,
		  ECOFF_SEGMENT_ALIGN(eap, eap->ea_bss_start), NULLVP, 0,
		  VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: exec_ecoff.c,v 1.5 1994/08/18 22:09:35 cgd Exp $	*/
a73 2
	u_long midmag, magic;
	u_short mid;
a105 1
bad:
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
