head	1.33;
access;
symbols
	OPENBSD_4_9:1.32.0.18
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.16
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.12
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.14
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.10
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.8
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.6
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.4
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.29.0.6
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.29.0.4
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.24.0.6
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.10
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.6
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.33
date	2011.04.02.16.27.29;	author thib;	state dead;
branches;
next	1.32;

1.32
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.31;

1.31
date	2006.10.16.11.27.53;	author pedro;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.03.19.49.06;	author pedro;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.14.09.04.59;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2005.07.03.20.14.00;	author drahn;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.03.01.07.44;	author jaredy;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.28.03.05.44;	author pedro;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.22.21.08.21;	author pedro;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.08.19.17.28;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.23.16.46.02;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.28.07;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.01.21.13.05;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.22.20.37.45;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.10.04.45.31;	author art;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.12.04.22.44.31;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.28.16.24.26;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.26.20.24.47;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.26.02.10.41;	author assar;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.23.02.21.05;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.01.20.54.34;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	98.12.05.16.54.02;	author csapuntz;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	98.08.08.03.53.30;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.58.30;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.20.17;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.12.48;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	96.05.22.11.47.12;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.19.16.09.14;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.13.39.00;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.48;	author deraadt;	state Exp;
branches;
next	;

1.9.6.1
date	2001.05.14.22.32.47;	author niklas;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2001.07.04.10.48.57;	author niklas;	state Exp;
branches;
next	1.9.6.3;

1.9.6.3
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.9.6.4;

1.9.6.4
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.9.6.5;

1.9.6.5
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.9.6.6;

1.9.6.6
date	2003.05.13.19.21.29;	author ho;	state Exp;
branches;
next	1.9.6.7;

1.9.6.7
date	2003.06.07.11.03.41;	author ho;	state Exp;
branches;
next	1.9.6.8;

1.9.6.8
date	2004.02.19.10.56.39;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.02.02.03.28.25;	author art;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.29.41;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@remove the vnode_if.* files, as they are now totally
obsolete.

the move to vfs_vops.c is here to stay, so they are
pointless.
@
text
@#	$OpenBSD: vnode_if.src,v 1.32 2007/01/16 17:52:18 thib Exp $
#	$NetBSD: vnode_if.src,v 1.10 1996/05/11 18:26:27 mycroft Exp $
#
# Copyright (c) 1992, 1993
#	The Regents of the University of California.  All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. Neither the name of the University nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
#	@@(#)vnode_if.src	8.3 (Berkeley) 2/3/94
#


#
# Above each of the vop descriptors is a specification of the locking
# protocol used by each vop call.  The first column is the name of
# the variable, the remaining three columns are in, out and error
# respectively.  The "in" column defines the lock state on input,
# the "out" column defines the state on successful return, and the
# "error" column defines the locking state on error exit.
#
# The locking value can take the following values:
# L: locked.
# U: unlocked/
# -: not applicable.  vnode does not yet (or no longer) exists.
# =: the same on input and output, may be either L or U.
# X: locked if not nil.
#


#
#% islocked	vp	= = =
#
vop_islocked {
	IN struct vnode *vp;
};

#
#% lookup	dvp	L ? ?
#% lookup	vpp	- L -
#
#
# Note that EJUSTRETURN is not considered an error condition for locking
# purposes.
#
# if both ISLASTCN and LOCKPARENT are set in cnp->cn_flags then 
#
#	dvp  L L L*
#
# otherwise,
#
#       dvp  L U L*
#
# * The lock state on return is indeterminate since the lookup implementations
# unlock and relock the vnode (an operation which is not guaranteed to 
# succeed). However, these types of failures should be rare. Unfortunately,
# they are currently undetectable.
#

vop_lookup {
	IN struct vnode *dvp;
	INOUT struct vnode **vpp;
	IN struct componentname *cnp;
};

#
#% create	dvp	L U U
#% create	vpp	- L -
#

vop_create {
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
	OUT struct vnode **vpp;
	IN struct componentname *cnp;
	IN struct vattr *vap;
};

#
#% mknod	dvp	L U U
#% mknod	vpp	- X -
#

vop_mknod {
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
	OUT WILLRELE struct vnode **vpp;
	IN struct componentname *cnp;
	IN struct vattr *vap;
};

#
#% open		vp	= = =
#

vop_open {
	IN struct vnode *vp;
	IN int mode;
	IN struct ucred *cred;
	IN struct proc *p;
};

#
#% close	vp	L L L
#

vop_close {
	IN SHOULDBELOCKED struct vnode *vp;
	IN int fflag;
	IN struct ucred *cred;
	IN struct proc *p;
};

#
#% access	vp	L L L
#

vop_access {
	IN SHOULDBELOCKED struct vnode *vp;
	IN int mode;
	IN struct ucred *cred;
	IN struct proc *p;
};

#
#% getattr	vp	= = =
#

vop_getattr {
	IN struct vnode *vp;
	IN struct vattr *vap;
	IN struct ucred *cred;
	IN struct proc *p;
};


#
#% setattr	vp	L L L
#

vop_setattr {
	IN SHOULDBELOCKED struct vnode *vp;
	IN struct vattr *vap;
	IN struct ucred *cred;
	IN struct proc *p;
};

#
#% read		vp	L L L
#

vop_read {
	IN SHOULDBELOCKED struct vnode *vp;
	INOUT struct uio *uio;
	IN int ioflag;
	IN struct ucred *cred;
};

#
#% write	vp	L L L
#

vop_write {
	IN SHOULDBELOCKED struct vnode *vp;
	INOUT struct uio *uio;
	IN int ioflag;
	IN struct ucred *cred;
};

#
#% ioctl	vp	U U U
#

vop_ioctl {
	IN struct vnode *vp;
	IN u_long command;
	IN void *data;
	IN int fflag;
	IN struct ucred *cred;
	IN struct proc *p;
};

#
#% poll	vp	U U U
#
vop_poll {
	IN struct vnode *vp;
	IN int events;
	IN struct proc *p;
};

#
#% kqfilter	vp	U U U
#
vop_kqfilter {
	IN struct vnode *vp;
	IN struct knote *kn;
};

#
#% revoke	vp	U U U
#
vop_revoke {
	IN struct vnode *vp;
	IN int flags;
};

#
#% fsync	vp	L L L
#
vop_fsync {
	IN SHOULDBELOCKED struct vnode *vp;
	IN struct ucred *cred;
	IN int waitfor;
	IN struct proc *p;
};

#
#% remove	dvp	L U U
#% remove	vp	L U U
#

vop_remove {
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
	IN SHOULDBELOCKED WILLPUT struct vnode *vp;
	IN struct componentname *cnp;
};

#
#% link		dvp	L U U
#% link		vp	U U U
#
vop_link {
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
	IN struct vnode *vp;
	IN struct componentname *cnp;
};

#
#% rename	fdvp	U U U
#% rename	fvp	U U U
#% rename	tdvp	L U U
#% rename	tvp	X U U
#

vop_rename {
	IN WILLRELE struct vnode *fdvp;
	IN WILLRELE struct vnode *fvp;
	IN struct componentname *fcnp;
	IN SHOULDBELOCKED WILLPUT struct vnode *tdvp;
	IN WILLRELE struct vnode *tvp;
	IN struct componentname *tcnp;
};

#
#% mkdir	dvp	L U U
#% mkdir	vpp	- L -
#

vop_mkdir {
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
	OUT struct vnode **vpp;
	IN struct componentname *cnp;
	IN struct vattr *vap;
};

#
#% rmdir	dvp	L U U
#% rmdir	vp	L U U
#

vop_rmdir {
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
	IN SHOULDBELOCKED WILLPUT struct vnode *vp;
	IN struct componentname *cnp;
};

#
#% symlink	dvp	L U U
#% symlink	vpp	- U -
#
# XXX - note that the return vnode has already been VRELE'ed
#	by the filesystem layer.  To use it you must use vget,
#	possibly with a further namei.
#

vop_symlink {
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
	OUT WILLRELE struct vnode **vpp;
	IN struct componentname *cnp;
	IN struct vattr *vap;
	IN char *target;
};

#
#% readdir	vp	L L L
#

vop_readdir {
	IN SHOULDBELOCKED struct vnode *vp;
	INOUT struct uio *uio;
	IN struct ucred *cred;
	INOUT int *eofflag;
	OUT int *ncookies;
	INOUT u_long **cookies;
};

#
#% readlink	vp	L L L
#
vop_readlink {
	IN SHOULDBELOCKED struct vnode *vp;
	INOUT struct uio *uio;
	IN struct ucred *cred;
};

#
#% abortop	dvp	= = =
#
vop_abortop {
	IN struct vnode *dvp;
	IN struct componentname *cnp;
};


#
#% inactive	vp	L U U
#
vop_inactive {
	IN SHOULDBELOCKED WILLUNLOCK struct vnode *vp;
	IN struct proc *p;
};

#
#% reclaim	vp	U U U
#

vop_reclaim {
	IN struct vnode *vp;
	IN struct proc *p;
};

#
#% lock		vp	U L U
#

vop_lock {
	IN struct vnode *vp;
	IN int flags;
	IN struct proc *p;
};

#
#% unlock	vp	L U L
#

vop_unlock {
	IN struct vnode *vp;
	IN int flags;
	IN struct proc *p;
};

#
#% bmap		vp	L L L
#% bmap		vpp	- U -
#

vop_bmap {
	IN SHOULDBELOCKED struct vnode *vp;
	IN daddr64_t bn;
	OUT struct vnode **vpp;
	IN daddr64_t *bnp;
	OUT int *runp;
};

#
# Needs work: no vp?
#
#vop_strategy {
#	IN struct buf *bp;
#};

#
#% print	vp	= = =
#
vop_print {
	IN struct vnode *vp;
};
#
#% pathconf	vp	L L L
#
vop_pathconf {
	IN SHOULDBELOCKED struct vnode *vp;
	IN int name;
	OUT register_t *retval;
};

#
#% advlock	vp	U U U
#
vop_advlock {
	IN struct vnode *vp;
	IN void *id;
	IN int op;
	IN struct flock *fl;
	IN int flags;
};

#
#% reallocblks	vp	L L L
#
vop_reallocblks {
	IN SHOULDBELOCKED struct vnode *vp;
	IN struct cluster_save *buflist;
};

# Needs work: no vp?
#vop_bwrite {
#	IN struct buf *bp;
#};
@


1.32
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.31 2006/10/16 11:27:53 pedro Exp $
@


1.31
log
@Use daddr64_t for logical blocks, okay krw@@ thib@@ mickey@@
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.30 2006/10/03 19:49:06 pedro Exp $
a186 10
};

#
#% lease	vp	= = =
#
vop_lease {
	IN struct vnode *vp;
	IN struct proc *p;
	IN struct ucred *cred;
	IN int flag;
@


1.30
log
@Introduce daddr64_t and use it for physical block numbers
Okay weingart@@, "I'm game with putting my name on it" dlg@@
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.29 2005/07/14 09:04:59 pedro Exp $
d399 1
a399 1
	IN daddr_t bn;
@


1.29
log
@Fix comments concerning VOP_LINK().
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.28 2005/07/03 20:14:00 drahn Exp $
d401 1
a401 1
	IN daddr_t *bnp;
@


1.28
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.27 2005/07/03 01:07:44 jaredy Exp $
d259 1
a260 1
#% link		tdvp	L U U
@


1.27
log
@change VOP_PATHCONF to take a locked vnode, as its
comment entry describes.  requires that sys_fpathconf()
lock its vnode.

lots of testing by jolan and myself, ok pedro
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.26 2005/05/28 03:05:44 pedro Exp $
a449 24
#
#% getextattr	vp	L L L
#
vop_getextattr {
	IN struct vnode *vp;
	IN int attrnamespace;
	IN const char *name;
	INOUT struct uio *uio;
	OUT size_t *size;
	IN struct ucred *cred;
	IN struct proc *p;
};

#
#% setextattr	vp	L L L
#
vop_setextattr {
	IN struct vnode *vp;
	IN int attrnamespace;
	IN const char *name;
	INOUT struct uio *uio;
	IN struct ucred *cred;
	IN struct proc *p;
};
@


1.26
log
@bye bye VOP_WHITEOUT
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.25 2005/05/22 21:08:21 pedro Exp $
d422 1
a422 1
	IN struct vnode *vp;
@


1.25
log
@change VOP_CLOSE to take a locked vnode
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.24 2003/11/08 19:17:28 jmc Exp $
a443 12
};

#
#% whiteout	dvp	L L L
#% whiteout	cnp	- - -
#% whiteout	flag	- - -
#

vop_whiteout {
	IN SHOULDBELOCKED struct vnode *dvp;
	IN struct componentname *cnp;
	IN int flags;
@


1.24
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.23 2003/09/23 16:46:02 millert Exp $
d123 1
a123 1
#% close	vp	U U U
d127 1
a127 1
	IN struct vnode *vp;
@


1.23
log
@Prepare for conversion of select backend -> poll
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.22 2003/07/21 22:44:50 tedu Exp $
d40 1
a40 1
# the "out" column defines the state on succesful return, and the
@


1.22
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.21 2003/06/02 23:28:07 millert Exp $
d213 1
a213 1
#% select	vp	U U U
d215 1
a215 3
# Needs work?  (fflags)
#
vop_select {
d217 1
a217 3
	IN int which;
	IN int fflags;
	IN struct ucred *cred;
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.20 2003/05/01 21:13:05 tedu Exp $
d206 1
a206 1
	IN caddr_t data;
d436 1
a436 1
	IN caddr_t id;
@


1.20
log
@several related changes:
vfs_subr.c:
	add a missing simple_lock_init for vnode interlock
	try to avoid reclaiming locked or layered vnodes
	initialize vnlock pointer to NULL
	remove old code to free vnlock, never used
	lockinit the new vnode lock
vfs_syscalls.c:
	support for VLAYER flag
vnode_if.sh:
	support for splitting VDESC flags
vnode_if.src:
	split VDESC flags
	WILLPUT is the combination of WILLRELE and WILLUNLOCK
	most uses for WILLRELE become WILLPUT
vnode.h:
	add v_lock to struct vnode
	add VLAYER flag
	update for new VDESC flags
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.19 2002/02/22 20:37:45 drahn Exp $
d15 1
a15 5
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#	This product includes software developed by the University of
#	California, Berkeley and its contributors.
# 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.18 2001/12/19 08:58:06 art Exp $
d97 1
a97 1
	IN SHOULDBELOCKED WILLRELE struct vnode *dvp;
d109 1
a109 1
	IN SHOULDBELOCKED WILLRELE struct vnode *dvp;
d261 2
a262 2
	IN SHOULDBELOCKED WILLRELE struct vnode *dvp;
	IN SHOULDBELOCKED WILLRELE struct vnode *vp;
d271 1
a271 1
	IN SHOULDBELOCKED WILLRELE struct vnode *dvp;
d287 1
a287 1
	IN SHOULDBELOCKED WILLRELE struct vnode *tdvp;
d298 1
a298 1
	IN SHOULDBELOCKED WILLRELE struct vnode *dvp;
d310 2
a311 2
	IN SHOULDBELOCKED WILLRELE struct vnode *dvp;
	IN SHOULDBELOCKED WILLRELE struct vnode *vp;
d325 1
a325 1
	IN SHOULDBELOCKED WILLRELE struct vnode *dvp;
d367 1
a367 1
	IN SHOULDBELOCKED struct vnode *vp;
@


1.18
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.13 2001/07/26 20:24:47 millert Exp $
d470 24
@


1.17
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.16 2001/12/04 22:44:31 art Exp $
a469 35

#
#% getpages    vp L L L
#
vop_getpages {
	IN struct vnode *vp;
	IN voff_t offset;
	IN struct vm_page **m;
	IN int *count;
	IN int centeridx;
	IN vm_prot_t access_type;
	IN int advice;
	IN int flags;
};

#
#% putpages    vp L L L
#
vop_putpages {
	IN struct vnode *vp;
	IN struct vm_page **m;
	IN int count;
	IN int flags;
	IN int *rtvals;
};

#
#% mmap		vp = = =
#
vop_mmap {
	IN struct vnode *vp;
	IN int fflags;
	IN struct ucred *cred;
	IN struct proc *p;
};
@


1.17.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.17 2001/12/10 04:45:31 art Exp $
d490 2
a491 2
	IN voff_t offlo;
	IN voff_t offhi;
d493 1
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.17.2.1 2002/02/02 03:28:25 art Exp $
a503 25
#
#% getextattr	vp	L L L
#
vop_getextattr {
	IN struct vnode *vp;
	IN int attrnamespace;
	IN const char *name;
	INOUT struct uio *uio;
	OUT size_t *size;
	IN struct ucred *cred;
	IN struct proc *p;
};

#
#% setextattr	vp	L L L
#
vop_setextattr {
	IN struct vnode *vp;
	IN int attrnamespace;
	IN const char *name;
	INOUT struct uio *uio;
	IN struct ucred *cred;
	IN struct proc *p;
};

@


1.17.2.3
log
@sync
@
text
@d1 1
a1 1
#	$OpenBSD$
d97 1
a97 1
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
d109 1
a109 1
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
d261 2
a262 2
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
	IN SHOULDBELOCKED WILLPUT struct vnode *vp;
d271 1
a271 1
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
d287 1
a287 1
	IN SHOULDBELOCKED WILLPUT struct vnode *tdvp;
d298 1
a298 1
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
d310 2
a311 2
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
	IN SHOULDBELOCKED WILLPUT struct vnode *vp;
d325 1
a325 1
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
d367 1
a367 1
	IN SHOULDBELOCKED WILLUNLOCK struct vnode *vp;
@


1.16
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.15 2001/11/28 16:24:26 art Exp $
a471 11
#% ballocn    vp      L L L
#
vop_ballocn {
	IN struct vnode *vp;
	IN off_t offset;
	IN off_t length;
	IN struct ucred *cred;
	IN int flags;
};

#
a493 9
};

#
#% size                vp = = =
#
vop_size {
	IN struct vnode *vp;
	IN off_t size;
	OUT off_t *eobp;
@


1.15
log
@more typedef zapping vm_page_t -> struct vm_page *
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.14 2001/11/27 05:27:12 art Exp $
d514 10
@


1.14
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.13 2001/07/26 20:24:47 millert Exp $
d488 1
a488 1
	IN vm_page_t *m;
d501 1
a501 1
	IN vm_page_t *m;
@


1.13
log
@Back out changes to symlink and mknod that were not well tested.
A simple mknod at causes a kernel panic (uvm_fault).
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.11 2001/06/23 02:21:05 csapuntz Exp $
d470 45
@


1.12
log
@change vop_symlink and vop_mknod to return vpp (the created node)
refed, so that the caller can actually use it.  update callers and
file systems that implement these vnode operations

ok'd by art
@
text
@d105 1
a105 1
#% mknod	vpp	- L -
d110 1
a110 1
	OUT struct vnode **vpp;
d317 5
a321 1
#% symlink	vpp	- L -
d326 1
a326 1
	OUT struct vnode **vpp;
@


1.11
log
@Get rid of UFS-specific and unused functions in the VFS interface
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.10 2001/03/01 20:54:34 provos Exp $
d105 1
a105 1
#% mknod	vpp	- X -
d110 1
a110 1
	OUT WILLRELE struct vnode **vpp;
d317 1
a317 5
#% symlink	vpp	- U -
#
# XXX - note that the return vnode has already been VRELE'ed
#	by the filesystem layer.  To use it you must use vget,
#	possibly with a further namei.
d322 1
a322 1
	OUT WILLRELE struct vnode **vpp;
@


1.10
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.9 1998/12/05 16:54:02 csapuntz Exp $
a245 10
# XXX - not used
#
vop_mmap {
	IN struct vnode *vp;
	IN int fflags;
	IN struct ucred *cred;
	IN struct proc *p;
};

#
a255 11
# XXX - not used
# Needs work: Is newoff right?  What's it mean?
#
vop_seek {
	IN struct vnode *vp;
	IN off_t oldoff;
	IN off_t newoff;
	IN struct ucred *cred;
};

#
a446 32
#% blkatoff	vp	L L L
#
vop_blkatoff {
	IN SHOULDBELOCKED struct vnode *vp;
	IN off_t offset;
	OUT char **res;
	OUT struct buf **bpp;
};

#
#% valloc	pvp	L L L
#
vop_valloc {
	IN SHOULDBELOCKED struct vnode *pvp;
	IN int mode;
	IN struct ucred *cred;
	OUT struct vnode **vpp;
};

#
#% balloc       vp      L L L
#
vop_balloc {
	IN SHOULDBELOCKED struct vnode *vp;
	IN off_t startoffset;
	IN int size;
	IN struct ucred *cred;
	IN int flags;
	OUT struct buf **bpp;
};

#
a451 33
};

#
#% vfree	pvp	L L L
#

vop_vfree {
	IN SHOULDBELOCKED struct vnode *pvp;
	IN ino_t ino;
	IN int mode;
};

#
#% truncate	vp	L L L
#

vop_truncate {
	IN SHOULDBELOCKED struct vnode *vp;
	IN off_t length;
	IN int flags;
	IN struct ucred *cred;
	IN struct proc *p;
};

#
#% update	vp	L L L
#

vop_update {
	IN SHOULDBELOCKED struct vnode *vp;
	IN struct timespec *access;
	IN struct timespec *modify;
	IN int waitfor;
@


1.9
log
@

Updated vnode_if specificiation
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.8 1998/08/08 03:53:30 csapuntz Exp $
d227 8
@


1.9.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.10 2001/03/01 20:54:34 provos Exp $
a226 8
};

#
#% kqfilter	vp	U U U
#
vop_kqfilter {
	IN struct vnode *vp;
	IN struct knote *kn;
@


1.9.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.9.6.1 2001/05/14 22:32:47 niklas Exp $
d246 10
d266 11
d468 32
d505 33
@


1.9.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.9.6.2 2001/07/04 10:48:57 niklas Exp $
@


1.9.6.4
log
@Merge in -current
@
text
@d1 1
a1 1
#	$OpenBSD$
a469 45

#
#% ballocn    vp      L L L
#
vop_ballocn {
	IN struct vnode *vp;
	IN off_t offset;
	IN off_t length;
	IN struct ucred *cred;
	IN int flags;
};

#
#% getpages    vp L L L
#
vop_getpages {
	IN struct vnode *vp;
	IN voff_t offset;
	IN struct vm_page **m;
	IN int *count;
	IN int centeridx;
	IN vm_prot_t access_type;
	IN int advice;
	IN int flags;
};

#
#% putpages    vp L L L
#
vop_putpages {
	IN struct vnode *vp;
	IN struct vm_page **m;
	IN int count;
	IN int flags;
	IN int *rtvals;
};

#
#% size                vp = = =
#
vop_size {
	IN struct vnode *vp;
	IN off_t size;
	OUT off_t *eobp;
};
@


1.9.6.5
log
@Merge in trunk
@
text
@d470 1
d472 1
a472 1
#% getextattr	vp	L L L
d474 1
a474 1
vop_getextattr {
d476 2
a477 4
	IN int attrnamespace;
	IN const char *name;
	INOUT struct uio *uio;
	OUT size_t *size;
d479 15
a493 1
	IN struct proc *p;
d497 1
a497 1
#% setextattr	vp	L L L
d499 1
a499 1
vop_setextattr {
d501 13
a513 5
	IN int attrnamespace;
	IN const char *name;
	INOUT struct uio *uio;
	IN struct ucred *cred;
	IN struct proc *p;
@


1.9.6.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.9.6.5 2002/03/06 02:13:24 niklas Exp $
d97 1
a97 1
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
d109 1
a109 1
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
d261 2
a262 2
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
	IN SHOULDBELOCKED WILLPUT struct vnode *vp;
d271 1
a271 1
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
d287 1
a287 1
	IN SHOULDBELOCKED WILLPUT struct vnode *tdvp;
d298 1
a298 1
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
d310 2
a311 2
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
	IN SHOULDBELOCKED WILLPUT struct vnode *vp;
d325 1
a325 1
	IN SHOULDBELOCKED WILLPUT struct vnode *dvp;
d367 1
a367 1
	IN SHOULDBELOCKED WILLUNLOCK struct vnode *vp;
@


1.9.6.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.9.6.6 2003/05/13 19:21:29 ho Exp $
d15 5
a19 1
# 3. Neither the name of the University nor the names of its contributors
@


1.9.6.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
#	$OpenBSD$
d40 1
a40 1
# the "out" column defines the state on successful return, and the
d206 1
a206 1
	IN void *data;
d213 1
a213 1
#% poll	vp	U U U
d215 3
a217 1
vop_poll {
d219 3
a221 1
	IN int events;
d436 1
a436 1
	IN void *id;
@


1.8
log
@

Document the locking discipline a bit better
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.7 1997/11/06 05:58:30 csapuntz Exp $
d55 8
d97 1
a97 1
	IN WILLRELE struct vnode *dvp;
d109 1
a109 1
	IN WILLRELE struct vnode *dvp;
d116 1
a116 1
#% open		vp	L L L
d142 1
a142 1
	IN struct vnode *vp;
d165 1
a165 1
	IN struct vnode *vp;
d176 1
a176 1
	IN struct vnode *vp;
d187 1
a187 1
	IN struct vnode *vp;
d251 1
a251 1
	IN struct vnode *vp;
d274 2
a275 2
	IN WILLRELE struct vnode *dvp;
	IN WILLRELE struct vnode *vp;
d284 1
a284 1
	IN WILLRELE struct vnode *dvp;
d300 1
a300 1
	IN WILLRELE struct vnode *tdvp;
d311 1
a311 1
	IN WILLRELE struct vnode *dvp;
d323 2
a324 2
	IN WILLRELE struct vnode *dvp;
	IN WILLRELE struct vnode *vp;
d338 1
a338 1
	IN WILLRELE struct vnode *dvp;
d350 1
a350 1
	IN struct vnode *vp;
d362 1
a362 1
	IN struct vnode *vp;
d380 1
a380 1
	IN struct vnode *vp;
d419 1
a419 1
	IN struct vnode *vp;
a438 8

#
#% islocked	vp	= = =
#
vop_islocked {
	IN struct vnode *vp;
};

d463 1
a463 1
	IN struct vnode *vp;
d473 1
a473 1
	IN struct vnode *pvp;
d483 1
a483 1
	IN struct vnode *vp;
d495 1
a495 1
	IN struct vnode *vp;
d504 1
a504 1
	IN struct vnode *pvp;
d514 1
a514 1
	IN struct vnode *vp;
d526 1
a526 1
	IN struct vnode *vp;
d539 1
a539 1
	IN struct vnode *dvp;
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.6 1997/10/06 20:20:17 deraadt Exp $
d59 17
a75 3
# XXX - the lookup locking protocol defies simple description and depends
#	on the flags and operation fields in the (cnp) structure.  Note
#	especially that *vpp may equal dvp and both may be locked.
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
#	$OpenBSD: vnode_if.src,v 1.4 1996/05/22 11:47:12 deraadt Exp $
d37 26
d69 5
d81 5
d93 4
d104 4
d115 4
d126 4
d137 5
d149 4
d160 4
d171 14
d194 3
d198 1
d207 11
d225 3
d235 4
a238 1
# Needs word: Is newoff right?  What's it mean?
d246 5
d257 4
d267 7
d283 5
d295 5
d306 9
d323 4
d331 3
a333 3
	OUT int *eofflag;
	OUT u_long *cookies;
	IN int ncookies;
d336 3
d345 3
d353 4
d359 1
d362 4
d368 1
d371 4
d377 2
d381 4
d387 2
d391 5
d404 3
d411 3
d418 3
d425 3
d434 3
d445 3
d455 3
d465 15
d485 4
d495 4
d507 4
d518 5
a522 6
vop_lease {
	IN struct vnode *vp;
	IN struct proc *p;
	IN struct ucred *cred;
	IN int flag;
};
@


1.5
log
@VFS Lite2 Changes
@
text
@a36 26


#
# Above each of the vop descriptors is a specification of the locking
# protocol used by each vop call.  The first column is the name of
# the variable, the remaining three columns are in, out and error
# respectively.  The "in" column defines the lock state on input,
# the "out" column defines the state on succesful return, and the
# "error" column defines the locking state on error exit.
#
# The locking value can take the following values:
# L: locked.
# U: unlocked/
# -: not applicable.  vnode does not yet (or no longer) exists.
# =: the same on input and output, may be either L or U.
# X: locked if not nil.
#

#
#% lookup	dvp	L ? ?
#% lookup	vpp	- L -
#
# XXX - the lookup locking protocol defies simple description and depends
#	on the flags and operation fields in the (cnp) structure.  Note
#	especially that *vpp may equal dvp and both may be locked.

a42 5
#
#% create	dvp	L U U
#% create	vpp	- L -
#

a49 5
#
#% mknod	dvp	L U U
#% mknod	vpp	- X -
#

a56 4
#
#% open		vp	L L L
#

a63 4
#
#% close	vp	U U U
#

a70 4
#
#% access	vp	L L L
#

a77 4
#
#% getattr	vp	= = =
#

a84 5

#
#% setattr	vp	L L L
#

a91 4
#
#% read		vp	L L L
#

a98 4
#
#% write	vp	L L L
#

a105 14
#
#% lease	vp	= = =
#
vop_lease {
	IN struct vnode *vp;
	IN struct proc *p;
	IN struct ucred *cred;
	IN int flag;
};

#
#% ioctl	vp	U U U
#

a114 3
#
#% select	vp	U U U
#
a115 1
#
a123 11
#
#% revoke	vp	U U U
#
vop_revoke {
	IN struct vnode *vp;
	IN int flags;
};

#
# XXX - not used
#
a130 3
#
#% fsync	vp	L L L
#
d138 1
a138 4
#
# XXX - not used
# Needs work: Is newoff right?  What's it mean?
#
a145 5
#
#% remove	dvp	L U U
#% remove	vp	L U U
#

a151 4
#
#% link		vp	U U U
#% link		tdvp	L U U
#
a157 7
#
#% rename	fdvp	U U U
#% rename	fvp	U U U
#% rename	tdvp	L U U
#% rename	tvp	X U U
#

a166 5
#
#% mkdir	dvp	L U U
#% mkdir	vpp	- L -
#

a173 5
#
#% rmdir	dvp	L U U
#% rmdir	vp	L U U
#

a179 9
#
#% symlink	dvp	L U U
#% symlink	vpp	- U -
#
# XXX - note that the return vnode has already been VRELE'ed
#	by the filesystem layer.  To use it you must use vget,
#	possibly with a further namei.
#

a187 4
#
#% readdir	vp	L L L
#

d192 3
a194 3
	INOUT int *eofflag;
	OUT int *ncookies;
	INOUT u_long **cookies;
a196 3
#
#% readlink	vp	L L L
#
a202 3
#
#% abortop	dvp	= = =
#
a207 4

#
#% inactive	vp	L U U
#
a209 1
	IN struct proc *p;
a211 4
#
#% reclaim	vp	U U U
#

a213 1
	IN struct proc *p;
a215 4
#
#% lock		vp	U L U
#

a217 2
	IN int flags;
	IN struct proc *p;
a219 4
#
#% unlock	vp	L U L
#

a221 2
	IN int flags;
	IN struct proc *p;
a223 5
#
#% bmap		vp	L L L
#% bmap		vpp	- U -
#

a231 3
#
# Needs work: no vp?
#
a235 3
#
#% print	vp	= = =
#
a239 3
#
#% islocked	vp	= = =
#
a243 3
#
#% pathconf	vp	L L L
#
a249 3
#
#% advlock	vp	U U U
#
a257 3
#
#% blkatoff	vp	L L L
#
a264 3
#
#% valloc	pvp	L L L
#
a271 15
#
#% balloc       vp      L L L
#
vop_balloc {
	IN struct vnode *vp;
	IN off_t startoffset;
	IN int size;
	IN struct ucred *cred;
	IN int flags;
	OUT struct buf **bpp;
};

#
#% reallocblks	vp	L L L
#
a276 4
#
#% vfree	pvp	L L L
#

a282 4
#
#% truncate	vp	L L L
#

a290 4
#
#% update	vp	L L L
#

d298 6
a303 5
#
#% whiteout	dvp	L L L
#% whiteout	cnp	- - -
#% whiteout	flag	- - -
#
@


1.4
log
@Change VOP_UPDATE() semantics:
* Make 2nd and 3rd args timespecs, not timevals.
* Consistently pass a Boolean as the 4th arg (except in LFS).
Also, fix ffs_update() and lfs_update() to actually change the nsec fields.
@
text
@d1 1
a1 1
#	$OpenBSD$
d37 26
d69 5
d81 5
d93 4
d104 4
d115 4
d126 4
d137 5
d149 4
d160 4
d171 14
d194 3
d198 1
d207 11
d225 3
d235 4
a238 1
# Needs word: Is newoff right?  What's it mean?
d246 5
d257 4
d267 7
d283 5
d295 5
d306 9
d323 4
d331 3
a333 3
	OUT int *eofflag;
	OUT u_long *cookies;
	IN int ncookies;
d336 3
d345 3
d353 4
d359 1
d362 4
d368 1
d371 4
d377 2
d381 4
d387 2
d391 5
d404 3
d411 3
d418 3
d425 3
d434 3
d445 3
d455 3
d465 15
d485 4
d495 4
d507 4
d518 5
a522 6
vop_lease {
	IN struct vnode *vp;
	IN struct proc *p;
	IN struct ucred *cred;
	IN int flag;
};
@


1.3
log
@NetBSD 960317 merge
@
text
@d2 1
a2 1
#	$NetBSD: vnode_if.src,v 1.9 1996/02/09 14:45:38 mycroft Exp $
d293 2
a294 2
	IN struct timeval *access;
	IN struct timeval *modify;
@


1.2
log
@From NetBSD: Merge with NetBSD 960217
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#	$NetBSD: vnode_if.src,v 1.8 1994/12/14 18:58:43 mycroft Exp $
d152 2
a153 2
	IN WILLRELE struct vnode *vp;
	IN struct vnode *tdvp;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
