head	1.7;
access;
symbols
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.5.0.10
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.8
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.6
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.4
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.2.0.26
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.24
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.22
	OPENBSD_2_8:1.2.0.20
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.16
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.7
date	2006.08.03.16.13.24;	author mbalmer;	state dead;
branches;
next	1.6;

1.6
date	2005.12.21.12.43.49;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.11.09.56.49;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.27.05;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.20.13;	author niklas;	state Exp;
branches
	1.2.16.1
	1.2.26.1;
next	1.1;

1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches;
next	;

1.2.16.1
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.2.16.3;

1.2.16.3
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	;

1.2.26.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Remove the tb(4) line discipline and manual page.  I found no man pages
referencing tb(4).

ok deraadt
@
text
@/*	$OpenBSD: tty_tb.c,v 1.6 2005/12/21 12:43:49 jsg Exp $	*/
/*	$NetBSD: tty_tb.c,v 1.18 1996/02/04 02:17:36 christos Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tty_tb.c	8.1 (Berkeley) 6/10/93
 */

#include "tb.h"

/*
 * Line discipline for RS232 tablets;
 * supplies binary coordinate data.
 */
#include <sys/param.h>
#include <sys/tablet.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/ioctl_compat.h>
#include <sys/tty.h>
#include <sys/proc.h>

union tbpos {
	struct	hitpos hitpos;
	struct	gtcopos gtcopos;
	struct	polpos polpos;
};

/*
 * Tablet configuration table.
 */
struct	tbconf {
	short	tbc_recsize;	/* input record size in bytes */
	short	tbc_uiosize;	/* size of data record returned user */
	int	tbc_sync;	/* mask for finding sync byte/bit */
				/* decoding routine */
    	void    (*tbc_decode)(const struct tbconf *, char *, union tbpos *);
	u_char	*tbc_run;	/* enter run mode sequence */
	u_char	*tbc_point;	/* enter point mode sequence */
	u_char	*tbc_stop;	/* stop sequence */
	u_char	*tbc_start;	/* start/restart sequence */
	int	tbc_flags;
#define	TBF_POL		0x1	/* polhemus hack */
#define	TBF_INPROX	0x2	/* tablet has proximity info */
};

static void gtcodecode(const struct tbconf *, char *, union tbpos *);
static void tbolddecode(const struct tbconf *, char *, union tbpos *);
static void tblresdecode(const struct tbconf *, char *, union tbpos *);
static void tbhresdecode(const struct tbconf *, char *, union tbpos *);
static void poldecode(const struct tbconf *, char *, union tbpos *);


const struct	tbconf tbconf[TBTYPE] = {
{ 0 },
{ 5, sizeof (struct hitpos), 0200, tbolddecode, "6", "4" },
{ 5, sizeof (struct hitpos), 0200, tbolddecode, "\1CN", "\1RT", "\2", "\4" },
{ 8, sizeof (struct gtcopos), 0200, gtcodecode },
{17, sizeof (struct polpos), 0200, poldecode, 0, 0, "\21", "\5\22\2\23",
  TBF_POL },
{ 5, sizeof (struct hitpos), 0100, tblresdecode, "\1CN", "\1PT", "\2", "\4",
  TBF_INPROX },
{ 6, sizeof (struct hitpos), 0200, tbhresdecode, "\1CN", "\1PT", "\2", "\4",
  TBF_INPROX },
{ 5, sizeof (struct hitpos), 0100, tblresdecode, "\1CL\33", "\1PT\33", 0, 0},
{ 6, sizeof (struct hitpos), 0200, tbhresdecode, "\1CL\33", "\1PT\33", 0, 0},
};

/*
 * Tablet state
 */
struct tb {
	int	tbflags;		/* mode & type bits */
#define	TBMAXREC	17	/* max input record size */
	char	cbuf[TBMAXREC];		/* input buffer */
	int	tbinbuf;
	char	*tbcp;
	union	tbpos tbpos; 
} tb[NTB];


int	tbopen(dev_t, struct tty *);
void	tbclose(struct tty *);
int	tbread(struct tty *, struct uio *);
void	tbinput(int, struct tty *);
int	tbtioctl(struct tty *, u_long, caddr_t, int, struct proc *);
void	tbattach(int);

/*
 * Open as tablet discipline; called on discipline change.
 */
/*ARGSUSED*/
int
tbopen(dev_t dev, struct tty *tp)
{
	struct tb *tbp;

	if (tp->t_line == TABLDISC)
		return (ENODEV);
	ttywflush(tp);
	for (tbp = tb; tbp < &tb[NTB]; tbp++)
		if (tbp->tbflags == 0)
			break;
	if (tbp >= &tb[NTB])
		return (EBUSY);
	tbp->tbflags = TBTIGER|TBPOINT;		/* default */
	tbp->tbcp = tbp->cbuf;
	tbp->tbinbuf = 0;
	bzero((caddr_t)&tbp->tbpos, sizeof (tbp->tbpos));
	tp->t_sc = (caddr_t)tbp;
	tp->t_flags |= LITOUT;
	return (0);
}

/*
 * Line discipline change or last device close.
 */
void
tbclose(struct tty *tp)
{
	int modebits = TBPOINT|TBSTOP;

	tbtioctl(tp, BIOSMODE, (caddr_t) &modebits, 0, curproc);
}

/*
 * Read from a tablet line.
 * Characters have been buffered in a buffer and decoded.
 */
int
tbread(struct tty *tp, struct uio *uio)
{
	struct tb *tbp = (struct tb *)tp->t_sc;
	const struct tbconf *tc = &tbconf[tbp->tbflags & TBTYPE];
	int ret;

	if ((tp->t_state&TS_CARR_ON) == 0)
		return (EIO);
	ret = uiomove((caddr_t) &tbp->tbpos, tc->tbc_uiosize, uio);
	if (tc->tbc_flags&TBF_POL)
		tbp->tbpos.polpos.p_key = ' ';
	return (ret);
}

/*
 * Low level character input routine.
 * Stuff the character in the buffer, and decode
 * if all the chars are there.
 *
 * This routine could be expanded in-line in the receiver
 * interrupt routine to make it run as fast as possible.
 */
void
tbinput(int c, struct tty *tp)
{
	struct tb *tbp = (struct tb *)tp->t_sc;
	const struct tbconf *tc = &tbconf[tbp->tbflags & TBTYPE];

	if (tc->tbc_recsize == 0 || tc->tbc_decode == 0)	/* paranoid? */
		return;
	/*
	 * Locate sync bit/byte or reset input buffer.
	 */
	if (c&tc->tbc_sync || tbp->tbinbuf == tc->tbc_recsize) {
		tbp->tbcp = tbp->cbuf;
		tbp->tbinbuf = 0;
	}
	*tbp->tbcp++ = c&0177;
	/*
	 * Call decode routine only if a full record has been collected.
	 */
	if (++tbp->tbinbuf == tc->tbc_recsize)
		(*tc->tbc_decode)(tc, tbp->cbuf, &tbp->tbpos);
}

/*
 * Decode GTCO 8 byte format (high res, tilt, and pressure).
 */
static void
gtcodecode(const struct tbconf *tc, char *cp, union tbpos *u)
{
	struct gtcopos *pos = &u->gtcopos;
	pos->pressure = *cp >> 2;
	pos->status = (pos->pressure > 16) | TBINPROX; /* half way down */
	pos->xpos = (*cp++ & 03) << 14;
	pos->xpos |= *cp++ << 7;
	pos->xpos |= *cp++;
	pos->ypos = (*cp++ & 03) << 14;
	pos->ypos |= *cp++ << 7;
	pos->ypos |= *cp++;
	pos->xtilt = *cp++;
	pos->ytilt = *cp++;
	pos->scount++;
}

/*
 * Decode old Hitachi 5 byte format (low res).
 */
static void
tbolddecode(const struct tbconf *tc, char *cp, union tbpos *u)
{
	struct hitpos *pos = &u->hitpos;
	char byte;

	byte = *cp++;
	pos->status = (byte&0100) ? TBINPROX : 0;
	byte &= ~0100;
	if (byte > 036)
		pos->status |= 1 << ((byte-040)/2);
	pos->xpos = *cp++ << 7;
	pos->xpos |= *cp++;
	if (pos->xpos < 256)			/* tablet wraps around at 256 */
		pos->status &= ~TBINPROX;	/* make it out of proximity */
	pos->ypos = *cp++ << 7;
	pos->ypos |= *cp++;
	pos->scount++;
}

/*
 * Decode new Hitach 5-byte format (low res).
 */
static void
tblresdecode(const struct tbconf *tc, char *cp, union tbpos *u)
{
	struct hitpos *pos = &u->hitpos;

	*cp &= ~0100;		/* mask sync bit */
	pos->status = (*cp++ >> 2) | TBINPROX;
	if (tc->tbc_flags&TBF_INPROX && pos->status&020)
		pos->status &= ~(020|TBINPROX);
	pos->xpos = *cp++;
	pos->xpos |= *cp++ << 6;
	pos->ypos = *cp++;
	pos->ypos |= *cp++ << 6;
	pos->scount++;
}

/*
 * Decode new Hitach 6-byte format (high res).
 */
static void
tbhresdecode(const struct tbconf *tc, char *cp, union tbpos *u)
{
	struct hitpos *pos = &u->hitpos;
	char byte;

	byte = *cp++;
	pos->xpos = (byte & 03) << 14;
	pos->xpos |= *cp++ << 7;
	pos->xpos |= *cp++;
	pos->ypos = *cp++ << 14;
	pos->ypos |= *cp++ << 7;
	pos->ypos |= *cp++;
	pos->status = (byte >> 2) | TBINPROX;
	if (tc->tbc_flags&TBF_INPROX && pos->status&020)
		pos->status &= ~(020|TBINPROX);
	pos->scount++;
}

/*
 * Polhemus decode.
 */
static void
poldecode(const struct tbconf *tc, char *cp, union tbpos *u)
{
	struct polpos *pos = &u->polpos;

	pos->p_x = cp[4] | cp[3]<<7 | (cp[9] & 0x03) << 14;
	pos->p_y = cp[6] | cp[5]<<7 | (cp[9] & 0x0c) << 12;
	pos->p_z = cp[8] | cp[7]<<7 | (cp[9] & 0x30) << 10;
	pos->p_azi = cp[11] | cp[10]<<7 | (cp[16] & 0x03) << 14;
	pos->p_pit = cp[13] | cp[12]<<7 | (cp[16] & 0x0c) << 12;
	pos->p_rol = cp[15] | cp[14]<<7 | (cp[16] & 0x30) << 10;
	pos->p_stat = cp[1] | cp[0]<<7;
	if (cp[2] != ' ')
		pos->p_key = cp[2];
}

/*ARGSUSED*/
int
tbtioctl(struct tty *tp, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct tb *tbp = (struct tb *)tp->t_sc;

	switch (cmd) {

	case BIOGMODE:
		*(int *)data = tbp->tbflags & TBMODE;
		break;

	case BIOSTYPE:
		if (tbconf[*(int *)data & TBTYPE].tbc_recsize == 0 ||
		    tbconf[*(int *)data & TBTYPE].tbc_decode == 0)
			return (EINVAL);
		tbp->tbflags &= ~TBTYPE;
		tbp->tbflags |= *(int *)data & TBTYPE;
		/* fall thru... to set mode bits */

	case BIOSMODE: {
		const struct tbconf *tc;
		u_char *c;

		tbp->tbflags &= ~TBMODE;
		tbp->tbflags |= *(int *)data & TBMODE;
		tc = &tbconf[tbp->tbflags & TBTYPE];
		if (tbp->tbflags & TBSTOP) {
			if (tc->tbc_stop)
				for (c = tc->tbc_stop; *c != '\0'; c++)
					ttyoutput(*c, tp);
		} else if (tc->tbc_start)
			for (c = tc->tbc_start; *c != '\0'; c++)
				ttyoutput(*c, tp);
		if (tbp->tbflags & TBPOINT) {
			if (tc->tbc_point)
				for (c = tc->tbc_point; *c != '\0'; c++)
					ttyoutput(*c, tp);
		} else if (tc->tbc_run)
			for (c = tc->tbc_run; *c != '\0'; c++)
				ttyoutput(*c, tp);
		ttstart(tp);
		break;
	}

	case BIOGTYPE:
		*(int *)data = tbp->tbflags & TBTYPE;
		break;

	case TIOCSETD:
	case TIOCGETD:
	case TIOCGETP:
	case TIOCGETC:
		return (-1);		/* pass thru... */

	default:
		return (ENOTTY);
	}
	return (0);
}

void
tbattach(int dummy)
{
    /* stub to handle side effect of new config */
}
@


1.6
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_tb.c,v 1.5 2003/08/11 09:56:49 mickey Exp $	*/
@


1.5
log
@constify constant consts
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_tb.c,v 1.4 2003/06/02 23:28:06 millert Exp $	*/
d120 1
a120 3
tbopen(dev, tp)
	dev_t dev;
	register struct tty *tp;
d122 1
a122 1
	register struct tb *tbp;
d145 1
a145 2
tbclose(tp)
	register struct tty *tp;
d157 1
a157 3
tbread(tp, uio)
	register struct tty *tp;
	struct uio *uio;
d180 1
a180 3
tbinput(c, tp)
	register int c;
	register struct tty *tp;
d206 1
a206 4
gtcodecode(tc, cp, u)
	const struct tbconf *tc;
	register char *cp;
	register union tbpos *u;
d226 1
a226 4
tbolddecode(tc, cp, u)
	const struct tbconf *tc;
	register char *cp;
	register union tbpos *u;
d229 1
a229 1
	register char byte;
d249 1
a249 4
tblresdecode(tc, cp, u)
	const struct tbconf *tc;
	register char *cp;
	register union tbpos *u;
d268 1
a268 4
tbhresdecode(tc, cp, u)
	const struct tbconf *tc;
	register char *cp;
	register union tbpos *u;
d290 1
a290 4
poldecode(tc, cp, u)
	const struct tbconf *tc;
	register char *cp;
	register union tbpos *u;
d307 1
a307 6
tbtioctl(tp, cmd, data, flag, p)
	struct tty *tp;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d309 1
a309 1
	register struct tb *tbp = (struct tb *)tp->t_sc;
d367 1
a367 2
tbattach(dummy)
       int dummy;
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_tb.c,v 1.3 2002/03/14 01:27:05 millert Exp $	*/
d63 1
a63 1
    	void    (*tbc_decode)(struct tbconf *, char *, union tbpos *);
d73 5
a77 5
static void gtcodecode(struct tbconf *, char *, union tbpos *);
static void tbolddecode(struct tbconf *, char *, union tbpos *);
static void tblresdecode(struct tbconf *, char *, union tbpos *);
static void tbhresdecode(struct tbconf *, char *, union tbpos *);
static void poldecode(struct tbconf *, char *, union tbpos *);
d80 1
a80 1
struct	tbconf tbconf[TBTYPE] = {
d164 2
a165 2
	register struct tb *tbp = (struct tb *)tp->t_sc;
	register struct tbconf *tc = &tbconf[tbp->tbflags & TBTYPE];
d189 2
a190 2
	register struct tb *tbp = (struct tb *)tp->t_sc;
	register struct tbconf *tc = &tbconf[tbp->tbflags & TBTYPE];
d214 1
a214 1
	struct tbconf *tc;
d237 1
a237 1
	struct tbconf *tc;
d263 1
a263 1
	struct tbconf *tc;
d285 1
a285 1
	struct tbconf *tc;
d310 1
a310 1
	struct tbconf *tc;
d353 1
a353 1
		register struct tbconf *tc;
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_tb.c,v 1.2 1996/03/03 17:20:13 niklas Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
    	void    (*tbc_decode) __P((struct tbconf *, char *, union tbpos *));
d77 5
a81 5
static void gtcodecode __P((struct tbconf *, char *, union tbpos *));
static void tbolddecode __P((struct tbconf *, char *, union tbpos *));
static void tblresdecode __P((struct tbconf *, char *, union tbpos *));
static void tbhresdecode __P((struct tbconf *, char *, union tbpos *));
static void poldecode __P((struct tbconf *, char *, union tbpos *));
d112 6
a117 6
int	tbopen __P((dev_t, struct tty *));
void	tbclose __P((struct tty *));
int	tbread __P((struct tty *, struct uio *));
void	tbinput __P((int, struct tty *));
int	tbtioctl __P((struct tty *, u_long, caddr_t, int, struct proc *));
void	tbattach __P((int));
@


1.2.26.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_tb.c,v 1.2 1996/03/03 17:20:13 niklas Exp $	*/
d67 1
a67 1
    	void    (*tbc_decode)(struct tbconf *, char *, union tbpos *);
d77 5
a81 5
static void gtcodecode(struct tbconf *, char *, union tbpos *);
static void tbolddecode(struct tbconf *, char *, union tbpos *);
static void tblresdecode(struct tbconf *, char *, union tbpos *);
static void tbhresdecode(struct tbconf *, char *, union tbpos *);
static void poldecode(struct tbconf *, char *, union tbpos *);
d112 6
a117 6
int	tbopen(dev_t, struct tty *);
void	tbclose(struct tty *);
int	tbread(struct tty *, struct uio *);
void	tbinput(int, struct tty *);
int	tbtioctl(struct tty *, u_long, caddr_t, int, struct proc *);
void	tbattach(int);
@


1.2.16.1
log
@Merge in -current from about a week ago
@
text
@d67 1
a67 1
    	void    (*tbc_decode)(struct tbconf *, char *, union tbpos *);
d77 5
a81 5
static void gtcodecode(struct tbconf *, char *, union tbpos *);
static void tbolddecode(struct tbconf *, char *, union tbpos *);
static void tblresdecode(struct tbconf *, char *, union tbpos *);
static void tbhresdecode(struct tbconf *, char *, union tbpos *);
static void poldecode(struct tbconf *, char *, union tbpos *);
d112 6
a117 6
int	tbopen(dev_t, struct tty *);
void	tbclose(struct tty *);
int	tbread(struct tty *, struct uio *);
void	tbinput(int, struct tty *);
int	tbtioctl(struct tty *, u_long, caddr_t, int, struct proc *);
void	tbattach(int);
@


1.2.16.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_tb.c,v 1.2.16.1 2002/03/28 11:43:04 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.16.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
a63 1
    	void    (*tbc_decode)(const struct tbconf *, char *, union tbpos *);
d73 5
a77 5
static void gtcodecode(const struct tbconf *, char *, union tbpos *);
static void tbolddecode(const struct tbconf *, char *, union tbpos *);
static void tblresdecode(const struct tbconf *, char *, union tbpos *);
static void tbhresdecode(const struct tbconf *, char *, union tbpos *);
static void poldecode(const struct tbconf *, char *, union tbpos *);
d80 1
a80 1
const struct	tbconf tbconf[TBTYPE] = {
d164 2
a165 2
	struct tb *tbp = (struct tb *)tp->t_sc;
	const struct tbconf *tc = &tbconf[tbp->tbflags & TBTYPE];
d189 2
a190 2
	struct tb *tbp = (struct tb *)tp->t_sc;
	const struct tbconf *tc = &tbconf[tbp->tbflags & TBTYPE];
d214 1
a214 1
	const struct tbconf *tc;
d237 1
a237 1
	const struct tbconf *tc;
d263 1
a263 1
	const struct tbconf *tc;
d285 1
a285 1
	const struct tbconf *tc;
d310 1
a310 1
	const struct tbconf *tc;
d353 1
a353 1
		const struct tbconf *tc;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: tty_tb.c,v 1.17 1995/05/10 16:53:02 christos Exp $	*/
d47 1
d53 6
d66 2
a67 1
	int	(*tbc_decode)();/* decoding routine */
d77 6
a82 2
static	int tbdecode(), gtcodecode(), poldecode();
static	int tblresdecode(), tbhresdecode();
d86 2
a87 2
{ 5, sizeof (struct tbpos), 0200, tbdecode, "6", "4" },
{ 5, sizeof (struct tbpos), 0200, tbdecode, "\1CN", "\1RT", "\2", "\4" },
d91 1
a91 1
{ 5, sizeof (struct tbpos), 0100, tblresdecode, "\1CN", "\1PT", "\2", "\4",
d93 1
a93 1
{ 6, sizeof (struct tbpos), 0200, tbhresdecode, "\1CN", "\1PT", "\2", "\4",
d95 2
a96 2
{ 5, sizeof (struct tbpos), 0100, tblresdecode, "\1CL\33", "\1PT\33", 0, 0},
{ 6, sizeof (struct tbpos), 0200, tbhresdecode, "\1CL\33", "\1PT\33", 0, 0},
d108 1
a108 5
	union {
		struct	tbpos tbpos;
		struct	gtcopos gtcopos;
		struct	polpos polpos;
	} rets;				/* processed state */
d111 8
d123 1
d141 1
a141 1
	bzero((caddr_t)&tbp->rets, sizeof (tbp->rets));
d150 1
d156 1
a156 1
	tbtioctl(tp, BIOSMODE, &modebits, 0, curproc);
d163 1
d174 1
a174 1
	ret = uiomove(&tbp->rets, tc->tbc_uiosize, uio);
d176 1
a176 1
		tbp->rets.polpos.p_key = ' ';
d188 1
d210 1
a210 1
		(*tc->tbc_decode)(tc, tbp->cbuf, &tbp->rets);
d216 2
a217 2
static
gtcodecode(tc, cp, tbpos)
d220 1
a220 1
	register struct gtcopos *tbpos;
d222 12
a233 12

	tbpos->pressure = *cp >> 2;
	tbpos->status = (tbpos->pressure > 16) | TBINPROX; /* half way down */
	tbpos->xpos = (*cp++ & 03) << 14;
	tbpos->xpos |= *cp++ << 7;
	tbpos->xpos |= *cp++;
	tbpos->ypos = (*cp++ & 03) << 14;
	tbpos->ypos |= *cp++ << 7;
	tbpos->ypos |= *cp++;
	tbpos->xtilt = *cp++;
	tbpos->ytilt = *cp++;
	tbpos->scount++;
d239 2
a240 2
static
tbdecode(tc, cp, tbpos)
d243 1
a243 1
	register struct tbpos *tbpos;
d245 1
d249 1
a249 1
	tbpos->status = (byte&0100) ? TBINPROX : 0;
d252 8
a259 8
		tbpos->status |= 1 << ((byte-040)/2);
	tbpos->xpos = *cp++ << 7;
	tbpos->xpos |= *cp++;
	if (tbpos->xpos < 256)			/* tablet wraps around at 256 */
		tbpos->status &= ~TBINPROX;	/* make it out of proximity */
	tbpos->ypos = *cp++ << 7;
	tbpos->ypos |= *cp++;
	tbpos->scount++;
d265 2
a266 2
static
tblresdecode(tc, cp, tbpos)
d269 1
a269 1
	register struct tbpos *tbpos;
d271 1
d274 8
a281 8
	tbpos->status = (*cp++ >> 2) | TBINPROX;
	if (tc->tbc_flags&TBF_INPROX && tbpos->status&020)
		tbpos->status &= ~(020|TBINPROX);
	tbpos->xpos = *cp++;
	tbpos->xpos |= *cp++ << 6;
	tbpos->ypos = *cp++;
	tbpos->ypos |= *cp++ << 6;
	tbpos->scount++;
d287 2
a288 2
static
tbhresdecode(tc, cp, tbpos)
d291 1
a291 1
	register struct tbpos *tbpos;
d293 1
d297 10
a306 10
	tbpos->xpos = (byte & 03) << 14;
	tbpos->xpos |= *cp++ << 7;
	tbpos->xpos |= *cp++;
	tbpos->ypos = *cp++ << 14;
	tbpos->ypos |= *cp++ << 7;
	tbpos->ypos |= *cp++;
	tbpos->status = (byte >> 2) | TBINPROX;
	if (tc->tbc_flags&TBF_INPROX && tbpos->status&020)
		tbpos->status &= ~(020|TBINPROX);
	tbpos->scount++;
d312 2
a313 2
static
poldecode(tc, cp, polpos)
d316 1
a316 1
	register struct polpos *polpos;
d318 1
d320 7
a326 7
	polpos->p_x = cp[4] | cp[3]<<7 | (cp[9] & 0x03) << 14;
	polpos->p_y = cp[6] | cp[5]<<7 | (cp[9] & 0x0c) << 12;
	polpos->p_z = cp[8] | cp[7]<<7 | (cp[9] & 0x30) << 10;
	polpos->p_azi = cp[11] | cp[10]<<7 | (cp[16] & 0x03) << 14;
	polpos->p_pit = cp[13] | cp[12]<<7 | (cp[16] & 0x0c) << 12;
	polpos->p_rol = cp[15] | cp[14]<<7 | (cp[16] & 0x30) << 10;
	polpos->p_stat = cp[1] | cp[0]<<7;
d328 1
a328 1
		polpos->p_key = cp[2];
d332 1
d397 2
a398 1
void tbattach(dummy)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
