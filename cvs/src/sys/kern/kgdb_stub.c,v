head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.6
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.9.0.20
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.22
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.14
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.18
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.16
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.12
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.8.0.20
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.16
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.18
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.14
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.12
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.10
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.8
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.6
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.2.0.4
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.11
date	2016.06.07.01.31.54;	author tedu;	state Exp;
branches;
next	1.10;
commitid	37V3kDRiYRccnYvB;

1.10
date	2016.03.07.18.43.59;	author naddy;	state Exp;
branches;
next	1.9;
commitid	Z6e4eqr6FuYFPnlL;

1.9
date	2010.10.30.04.17.07;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.17.19.23.01;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.13.17.50.45;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.06.07.28.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.03.16.09;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2001.01.24.09.37.59;	author hugh;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.05.14.22.32.42;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.1.4.5;

1.1.4.5
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	;

1.2.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2003.05.19.22.31.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.11
log
@per trending style, add continue to empty loops.
ok mglocker
@
text
@/*	$OpenBSD: kgdb_stub.c,v 1.10 2016/03/07 18:43:59 naddy Exp $	*/
/*	$NetBSD: kgdb_stub.c,v 1.6 1998/08/30 20:30:57 scottr Exp $	*/

/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratories.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kgdb_stub.c	8.4 (Berkeley) 1/12/94
 */

/*
 * "Stub" to allow remote cpu to debug over a serial line using gdb.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kgdb.h>

/* #define	DEBUG_KGDB XXX */

/* XXX: Maybe these should be in the MD files? */
#ifndef KGDBDEV
#define KGDBDEV -1
#endif
#ifndef KGDBRATE
#define KGDBRATE 19200
#endif

int kgdb_dev = KGDBDEV;		/* remote debugging device (-1 if none) */
int kgdb_rate = KGDBRATE;	/* remote debugging baud rate */
int kgdb_active = 0;		/* remote debugging active if != 0 */
int kgdb_debug_init = 0;	/* != 0 waits for remote at system init */
int kgdb_debug_panic = 0;	/* != 0 waits for remote on panic */
label_t *kgdb_recover = 0;

static void kgdb_copy(void *, void *, int);
/* static void kgdb_zero(void *, int); */
static void kgdb_send(u_char *);
static int kgdb_recv(u_char *, int);
static int digit2i(u_char);
static u_char i2digit(int);
static void mem2hex(void *, void *, int);
static u_char *hex2mem(void *, u_char *, int);
static vaddr_t hex2i(u_char **);

static int (*kgdb_getc)(void *);
static void (*kgdb_putc)(void *, int);
static void *kgdb_ioarg;

static u_char buffer[KGDB_BUFLEN];
static kgdb_reg_t gdb_regs[KGDB_NUMREGS];

#define GETC()	((*kgdb_getc)(kgdb_ioarg))
#define PUTC(c)	((*kgdb_putc)(kgdb_ioarg, c))

/*
 * This little routine exists simply so that bcopy() can be debugged.
 */
static void
kgdb_copy(void *vsrc, void *vdst, int len)
{
	char *src = vsrc;
	char *dst = vdst;

	while (--len >= 0)
		*dst++ = *src++;
}

#if 0
/* ditto for bzero */
static void
kgdb_zero(void *vptr, int len)
{
	char *ptr = vptr;

	while (--len >= 0)
		*ptr++ = (char) 0;
}
#endif

/*
 * Convert a hex digit into an integer.
 * This returns -1 if the argument passed is no
 * valid hex digit.
 */
static int
digit2i(u_char c)
{
	if (c >= '0' && c <= '9')
		return (c - '0');
	else if (c >= 'a' && c <= 'f')
		return (c - 'a' + 10);
	else if (c >= 'A' && c <= 'F')

		return (c - 'A' + 10);
	else
		return (-1);
}

/*
 * Convert the low 4 bits of an integer into
 * an hex digit.
 */
static u_char
i2digit(int n)
{
	return ("0123456789abcdef"[n & 0x0f]);
}

/*
 * Convert a byte array into an hex string.
 */
static void
mem2hex(void *vdst, void *vsrc, int len)
{
	u_char *dst = vdst;
	u_char *src = vsrc;

	while (len--) {
		*dst++ = i2digit(*src >> 4);
		*dst++ = i2digit(*src++);
	}
	*dst = '\0';
}

/*
 * Convert an hex string into a byte array.
 * This returns a pointer to the character following
 * the last valid hex digit. If the string ends in
 * the middle of a byte, NULL is returned.
 */
static u_char *
hex2mem(void *vdst, u_char *src, int maxlen)
{
	u_char *dst = vdst;
	int msb, lsb;

	while (*src && maxlen--) {
		msb = digit2i(*src++);
		if (msb < 0)
			return (src - 1);
		lsb = digit2i(*src++);
		if (lsb < 0)
			return (NULL);
		*dst++ = (msb << 4) | lsb;
	}
	return (src);
}

/*
 * Convert an hex string into an integer.
 * This returns a pointer to the character following
 * the last valid hex digit.
 */
static vaddr_t
hex2i(u_char **srcp)
{
	char *src = *srcp;
	vaddr_t r = 0;
	int nibble;

	while ((nibble = digit2i(*src)) >= 0) {
		r *= 16;
		r += nibble;
		src++;
	}
	*srcp = src;
	return (r);
}

/*
 * Send a packet.
 */
static void
kgdb_send(u_char *bp)
{
	u_char *p;
	u_char csum, c;

#ifdef	DEBUG_KGDB
	printf("kgdb_send: %s\n", bp);
#endif
	do {
		p = bp;
		PUTC(KGDB_START);
		for (csum = 0; (c = *p); p++) {
			PUTC(c);
			csum += c;
		}
		PUTC(KGDB_END);
		PUTC(i2digit(csum >> 4));
		PUTC(i2digit(csum));
	} while ((c = GETC() & 0x7f) == KGDB_BADP);
}

/*
 * Receive a packet.
 */
static int
kgdb_recv(u_char *bp, int maxlen)
{
	u_char *p;
	int c, csum;
	int len;

	do {
		p = bp;
		csum = len = 0;
		while ((c = GETC()) != KGDB_START)
			continue;

		while ((c = GETC()) != KGDB_END && len < maxlen) {
			c &= 0x7f;
			csum += c;
			*p++ = c;
			len++;
		}
		csum &= 0xff;
		*p = '\0';

		if (len >= maxlen) {
			PUTC(KGDB_BADP);
			continue;
		}

		csum -= digit2i(GETC()) * 16;
		csum -= digit2i(GETC());

		if (csum == 0) {
			PUTC(KGDB_GOODP);
			/* Sequence present? */
			if (bp[2] == ':') {
				PUTC(bp[0]);
				PUTC(bp[1]);
				len -= 3;
				kgdb_copy(bp + 3, bp, len);
			}
			break;
		}
		PUTC(KGDB_BADP);
	} while (1);
#ifdef	DEBUG_KGDB
	printf("kgdb_recv: %s\n", bp);
#endif
	return (len);
}

/*
 * This is called by the appropriate tty driver.
 */
void
kgdb_attach(int (*getfn)(void *), void (*putfn)(void *, int), void *ioarg)
{
	kgdb_getc = getfn;
	kgdb_putc = putfn;
	kgdb_ioarg = ioarg;
}

/*
 * This function does all command processing for interfacing to
 * a remote gdb.  Note that the error codes are ignored by gdb
 * at present, but might eventually become meaningful. (XXX)
 * It might makes sense to use POSIX errno values, because
 * that is what the gdb/remote.c functions want to return.
 */
int
kgdb_trap(int type, db_regs_t *regs)
{
	label_t jmpbuf;
	vaddr_t addr;
	size_t len;
	u_char *p;

	if (kgdb_dev < 0 || kgdb_getc == NULL) {
		/* not debugging */
		return (0);
	}

	/* Detect and recover from unexpected traps. */
	if (kgdb_recover != 0) {
		printf("kgdb: caught trap 0x%x at %p\n",
			   type, (void *)PC_REGS(regs));
		kgdb_send("E0E"); /* 14==EFAULT */
		longjmp(kgdb_recover);
	}

	/*
	 * The first entry to this function is normally through
	 * a breakpoint trap in kgdb_connect(), in which case we
	 * must advance past the breakpoint because gdb will not.
	 *
	 * Machines vary as to where they leave the PC after a
	 * breakpoint trap.  Those that leave the PC set to the
	 * address of the trap instruction (i.e. pc532) will not
	 * define FIXUP_PC_AFTER_BREAK(), and therefore will just
	 * advance the PC.  On machines that leave the PC set to
	 * the instruction after the trap, FIXUP_PC_AFTER_BREAK
	 * will be defined to back-up the PC, so that after the
	 * "first-time" part of the if statement below has run,
	 * the PC will be the same as it was on entry.
	 *
	 * On the first entry here, we expect that gdb is not yet
	 * listening to us, so just enter the interaction loop.
	 * After the debugger is "active" (connected) it will be
	 * waiting for a "signaled" message from us.
	 */
	if (kgdb_active == 0) {
		if (!IS_BREAKPOINT_TRAP(type, 0)) {
			/* No debugger active -- let trap handle this. */
			return (0);
		}
		/* Make the PC point at the breakpoint... */
#ifdef	FIXUP_PC_AFTER_BREAK
		FIXUP_PC_AFTER_BREAK(regs);
#endif
		/* ... and then advance past it. */
#ifdef	PC_ADVANCE
		PC_ADVANCE(regs);
#else
		SET_PC_REGS(regs, PC_REGS(regs) + BKPT_SIZE);
#endif
		kgdb_active = 1;
	} else {
		/* Tell remote host that an exception has occurred. */
		snprintf(buffer, sizeof buffer, "S%02x", kgdb_signal(type));
		kgdb_send(buffer);
	}

	/* Stick frame regs into our reg cache. */
	kgdb_getregs(regs, gdb_regs);

	/*
	 * Interact with gdb until it lets us go.
	 * If we cause a trap, resume here.
	 */
	(void)setjmp((kgdb_recover = &jmpbuf));
	for (;;) {
		kgdb_recv(buffer, sizeof(buffer));
		switch (buffer[0]) {

		default:
			/* Unknown command. */
			kgdb_send("");
			continue;

		case KGDB_SIGNAL:
			/*
			 * if this command came from a running gdb,
			 * answer it -- the other guy has no way of
			 * knowing if we're in or out of this loop
			 * when he issues a "remote-signal".
			 */
			snprintf(buffer, sizeof buffer, "S%02x",
			    kgdb_signal(type));
			kgdb_send(buffer);
			continue;

		case KGDB_REG_R:
			mem2hex(buffer, gdb_regs, sizeof(gdb_regs));
			kgdb_send(buffer);
			continue;

		case KGDB_REG_W:
			p = hex2mem(gdb_regs, buffer + 1, sizeof(gdb_regs));
			if (p == NULL || *p != '\0')
				kgdb_send("E01");
			else {
				kgdb_setregs(regs, gdb_regs);
				kgdb_send("OK");
			}
			continue;

		case KGDB_MEM_R:
			p = buffer + 1;
			addr = hex2i(&p);
			if (*p++ != ',') {
				kgdb_send("E02");
				continue;
			}
			len = hex2i(&p);
			if (*p != '\0') {
				kgdb_send("E03");
				continue;
			}
			if (len > sizeof(buffer) / 2) {
				kgdb_send("E04");
				continue;
			}
			if (kgdb_acc(addr, len) == 0) {
				kgdb_send("E05");
				continue;
			}
			db_read_bytes(addr, (size_t)len,
					(char *)buffer + sizeof(buffer) / 2);
			mem2hex(buffer, buffer + sizeof(buffer) / 2, len);
			kgdb_send(buffer);
			continue;

		case KGDB_MEM_W:
			p = buffer + 1;
			addr = hex2i(&p);
			if (*p++ != ',') {
				kgdb_send("E06");
				continue;
			}
			len = hex2i(&p);
			if (*p++ != ':') {
				kgdb_send("E07");
				continue;
			}
			if (len > (sizeof(buffer) - (p - buffer))) {
				kgdb_send("E08");
				continue;
			}
			p = hex2mem(buffer, p, sizeof(buffer));
			if (p == NULL) {
				kgdb_send("E09");
				continue;
			}
			if (kgdb_acc(addr, len) == 0) {
				kgdb_send("E0A");
				continue;
			}
			db_write_bytes(addr, (size_t)len, (char *)buffer);
			kgdb_send("OK");
			continue;

		case KGDB_DETACH:
			kgdb_active = 0;
			printf("kgdb detached\n");
			db_clear_single_step(regs);
			kgdb_send("OK");
			goto out;

		case KGDB_KILL:
			kgdb_active = 0;
			printf("kgdb detached\n");
			db_clear_single_step(regs);
			goto out;

		case KGDB_CONT:
			if (buffer[1]) {
				p = buffer + 1;
				addr = hex2i(&p);
				if (*p) {
					kgdb_send("E0B");
					continue;
				}
				SET_PC_REGS(regs, addr);
			}
			db_clear_single_step(regs);
			goto out;

		case KGDB_STEP:
			if (buffer[1]) {
				p = buffer + 1;
				addr = hex2i(&p);
				if (*p) {
					kgdb_send("E0B");
					continue;
				}
				SET_PC_REGS(regs, addr);
			}
			db_set_single_step(regs);
			goto out;
		}
	}
 out:
	kgdb_recover = 0;
	return (1);
}

/*
 * Trap into kgdb to wait for debugger to connect,
 * noting on the console why nothing else is going on.
 */
void
kgdb_connect(int verbose)
{
	if (kgdb_dev < 0)
		return;

	KGDB_PREPARE;

	if (verbose)
		printf("kgdb waiting...");

	KGDB_ENTER;

	if (verbose)
		printf("connected.\n");

	kgdb_debug_panic = 1;
}

/*
 * Decide what to do on panic.
 * (This is called by panic, like Debugger())
 */
void
kgdb_panic(void)
{
	if (kgdb_dev >= 0 && kgdb_debug_panic) {
		printf("entering kgdb\n");
		kgdb_connect(kgdb_active == 0);
	}
}
@


1.10
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kgdb_stub.c,v 1.9 2010/10/30 04:17:07 tedu Exp $	*/
d243 1
a243 1
			;
@


1.9
log
@don't abuse lvalues, reported by Amit Kulkarni.
(actually using KGDB remains as suspect as ever)
@
text
@d1 1
a1 1
/*	$OpenBSD: kgdb_stub.c,v 1.8 2005/11/17 19:23:01 fgsch Exp $	*/
d534 1
a534 1
kgdb_panic()
@


1.8
log
@style; no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kgdb_stub.c,v 1.7 2005/11/13 17:50:45 fgsch Exp $	*/
d353 1
a353 1
		PC_REGS(regs) += BKPT_SIZE;
d482 1
a482 1
				PC_REGS(regs) = addr;
d495 1
a495 1
				PC_REGS(regs) = addr;
@


1.7
log
@move kgdb_connect and kgdb_panic into MI. looked by miod@@ and kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: kgdb_stub.c,v 1.6 2003/06/02 23:28:06 millert Exp $ */
d93 1
a93 3
kgdb_copy(vsrc, vdst, len)
	void *vsrc, *vdst;
	int len;
d105 1
a105 3
kgdb_zero(vptr, len)
	void *vptr;
	int len;
d120 1
a120 2
digit2i(c)
	u_char c;
d125 1
a125 1
		return (c - 'a' + 10);	
d128 1
a128 1
		return (c - 'A' + 10);	
d138 1
a138 2
i2digit(n)
	int n;
d147 1
a147 3
mem2hex(vdst, vsrc, len)
	void *vdst, *vsrc;
	int len;
d166 1
a166 4
hex2mem(vdst, src, maxlen)
	void *vdst;
	u_char *src;
	int maxlen;
d187 1
a187 1
 */ 
d189 1
a189 2
hex2i(srcp)
	u_char **srcp;
d208 1
a208 2
kgdb_send(bp)
	u_char *bp;
d233 1
a233 3
kgdb_recv(bp, maxlen)
	u_char *bp;
	int maxlen;
d285 1
a285 4
kgdb_attach(getfn, putfn, ioarg)
	int (*getfn)(void *);
	void (*putfn)(void *, int);
	void *ioarg;
d300 1
a300 3
kgdb_trap(type, regs)
	int type;
	db_regs_t *regs;
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: kgdb_stub.c,v 1.5 2003/05/06 07:28:38 deraadt Exp $ */
d406 2
a407 1
			snprintf(buffer, sizeof buffer, "S%02x", kgdb_signal(type));
d524 36
@


1.5
log
@string cleaning; tedu ok
@
text
@d1 1
a1 1
/* $OpenBSD: kgdb_stub.c,v 1.4 2002/03/14 03:16:09 millert Exp $ */
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.4
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: kgdb_stub.c,v 1.3 2002/03/14 01:27:04 millert Exp $ */
d382 1
a382 1
		sprintf(buffer, "S%02x", kgdb_signal(type));
d410 1
a410 1
			sprintf(buffer, "S%02x", kgdb_signal(type));
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: kgdb_stub.c,v 1.2 2001/09/20 17:02:31 mpech Exp $ */
d339 1
a339 1
			   type, (void*)PC_REGS(regs));
@


1.2
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: kgdb_stub.c,v 1.1 2001/01/24 09:37:59 hugh Exp $ */
d73 9
a81 9
static void kgdb_copy __P((void *, void *, int));
/* static void kgdb_zero __P((void *, int)); */
static void kgdb_send __P((u_char *));
static int kgdb_recv __P((u_char *, int));
static int digit2i __P((u_char));
static u_char i2digit __P((int));
static void mem2hex __P((void *, void *, int));
static u_char *hex2mem __P((void *, u_char *, int));
static vaddr_t hex2i __P((u_char **));
d83 2
a84 2
static int (*kgdb_getc) __P((void *));
static void (*kgdb_putc) __P((void *, int));
d305 2
a306 2
	int (*getfn) __P((void *));
	void (*putfn) __P((void *, int));
@


1.2.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: kgdb_stub.c,v 1.2 2001/09/20 17:02:31 mpech Exp $ */
d73 9
a81 9
static void kgdb_copy(void *, void *, int);
/* static void kgdb_zero(void *, int); */
static void kgdb_send(u_char *);
static int kgdb_recv(u_char *, int);
static int digit2i(u_char);
static u_char i2digit(int);
static void mem2hex(void *, void *, int);
static u_char *hex2mem(void *, u_char *, int);
static vaddr_t hex2i(u_char **);
d83 2
a84 2
static int (*kgdb_getc)(void *);
static void (*kgdb_putc)(void *, int);
d305 2
a306 2
	int (*getfn)(void *);
	void (*putfn)(void *, int);
d339 1
a339 1
			   type, (void *)PC_REGS(regs));
@


1.2.4.2
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d382 1
a382 1
		snprintf(buffer, sizeof buffer, "S%02x", kgdb_signal(type));
d410 1
a410 1
			snprintf(buffer, sizeof buffer, "S%02x", kgdb_signal(type));
@


1.1
log
@KGDB for i386 from NetBSD via niklas, with tweaks and accommodations.
Tested by various, vetted by mickey & theo.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d381 1
a381 1
		/* Tell remote host that an exception has occured. */
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: kgdb_stub.c,v 1.1 2001/01/24 09:37:59 hugh Exp $ */
@


1.1.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: kgdb_stub.c,v 1.1.4.1 2001/05/14 22:32:42 niklas Exp $ */
d381 1
a381 1
		/* Tell remote host that an exception has occurred. */
@


1.1.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d73 9
a81 9
static void kgdb_copy(void *, void *, int);
/* static void kgdb_zero(void *, int); */
static void kgdb_send(u_char *);
static int kgdb_recv(u_char *, int);
static int digit2i(u_char);
static u_char i2digit(int);
static void mem2hex(void *, void *, int);
static u_char *hex2mem(void *, u_char *, int);
static vaddr_t hex2i(u_char **);
d83 2
a84 2
static int (*kgdb_getc)(void *);
static void (*kgdb_putc)(void *, int);
d305 2
a306 2
	int (*getfn)(void *);
	void (*putfn)(void *, int);
d339 1
a339 1
			   type, (void *)PC_REGS(regs));
@


1.1.4.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/* $OpenBSD: kgdb_stub.c,v 1.1.4.3 2002/03/28 11:43:04 niklas Exp $ */
d382 1
a382 1
		snprintf(buffer, sizeof buffer, "S%02x", kgdb_signal(type));
d410 1
a410 1
			snprintf(buffer, sizeof buffer, "S%02x", kgdb_signal(type));
@


1.1.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: kgdb_stub.c,v 1.1.4.4 2003/05/13 19:21:28 ho Exp $ */
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


