head	1.21;
access;
symbols
	OPENBSD_6_0:1.21.0.8
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.4
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.56
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.20.0.54
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.50
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.48
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.46
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.44
	OPENBSD_5_0:1.20.0.42
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.40
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.38
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.34
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.36
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.32
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.30
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.28
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.26
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.24
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.22
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.20
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.18
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.16
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.14
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.12
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.10
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.8
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.6
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.4
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.20
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7;
locks; strict;
comment	@ * @;


1.21
date	2015.01.20.04.41.01;	author krw;	state Exp;
branches;
next	1.20;
commitid	4iV7KHZz26Tut4Vx;

1.20
date	2001.10.27.18.40.57;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.09.19.13.28.43;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.08.11.23.14.22;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.30.11.56.39;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.09.18.55.21;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.22.14.14.07;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.29.13.25.34;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.07.00.56.30;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.03.23.32.13;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.22.14.25.03;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.16.15.46.20;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.14.16.54.41;	author art;	state Exp;
branches;
next	1.8;

1.8
date	99.11.25.13.41.30;	author art;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.09.27.11.10.30;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	99.09.25.11.43.29;	author kstailey;	state Exp;
branches;
next	1.5;

1.5
date	99.09.20.11.09.37;	author kstailey;	state Exp;
branches;
next	1.4;

1.4
date	99.09.19.16.16.49;	author kstailey;	state Exp;
branches;
next	1.3;

1.3
date	99.09.19.13.59.22;	author kstailey;	state Exp;
branches;
next	1.2;

1.2
date	99.09.12.14.15.17;	author kstailey;	state Exp;
branches;
next	1.1;

1.1
date	99.09.10.12.24.27;	author kstailey;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.32.38;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.48.12;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.26.28;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Missing $OpenBSD$'s.

ok deraadt@@
@
text
@/*	$OpenBSD$	*/
/*
 * Public domain. Author: Artur Grabowski <art@@openbsd.org>
 */
#include <machine/exec.h>

#ifdef _KERN_DO_ELF64
#define ELFSIZE 64
#include <kern/exec_elf.c>
#endif /* _KERN_DO_ELF64 */
@


1.20
log
@Every file must have a license blob, even if the blob is larger than the file.
@
text
@d1 1
@


1.19
log
@Unify elf32 and elf64 code with macros. This forced a renaming
of a few functions from elf32.
@
text
@d1 3
@


1.18
log
@Why is it so popular to include <vm/*.h> everywhere?
@
text
@a0 57
/*	$OpenBSD: exec_elf64.c,v 1.17 2001/07/30 11:56:39 art Exp $	*/

/*
 * Copyright (c) 1996 Per Fogelstrom
 * All rights reserved.
 *
 * Copyright (c) 1994 Christos Zoulas
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/exec.h>

#if defined(_KERN_DO_ELF64)

#include <sys/exec_elf.h>
#include <sys/exec_olf.h>
#include <sys/file.h>
#include <sys/syscall.h>
#include <sys/signalvar.h>
#include <sys/stat.h>

#include <sys/mman.h>
#include <vm/vm.h>

#include <machine/cpu.h>
#include <machine/reg.h>
d3 3
a5 782
#ifdef COMPAT_LINUX
#include <compat/linux/linux_exec.h>
#endif

#ifdef COMPAT_SVR4
#include <compat/svr4/svr4_exec.h>
#endif

#ifdef COMPAT_FREEBSD
#include <compat/freebsd/freebsd_exec.h>
#endif

#ifdef COMPAT_NETBSD
#include <compat/netbsd/netbsd_exec.h>
#endif

struct elf64_probe_entry {
	int (*func) __P((struct proc *, struct exec_package *, char *,
	    u_long *, u_int8_t *));
	int os_mask;
} elf64_probes[] = {
#ifdef COMPAT_FREEBSD
	{ freebsd_elf64_probe, 1 << OOS_FREEBSD },
#endif
#ifdef COMPAT_SVR4
	{ svr4_elf64_probe,
	    1 << OOS_SVR4 | 1 << OOS_ESIX | 1 << OOS_SOLARIS | 1 << OOS_SCO |
	    1 << OOS_DELL | 1 << OOS_NCR },
#endif
#ifdef COMPAT_LINUX
	{ linux_elf64_probe, 1 << OOS_LINUX },
#endif
#ifdef COMPAT_NETBSD
	{ netbsd_elf64_probe, 1 << OOS_NETBSD },
#endif
#ifdef NATIVE_EXEC_ELF
	{ 0, 1 << OOS_OPENBSD }
#endif
};

int elf64_load_file __P((struct proc *, char *, struct exec_package *,
    struct elf_args *, u_long *));

int elf64_check_header __P((Elf64_Ehdr *, int));
int olf64_check_header __P((Elf64_Ehdr *, int, u_int8_t *));
int elf64_read_from __P((struct proc *, struct vnode *, u_long, caddr_t, int));
void elf64_load_psection __P((struct exec_vmcmd_set *, struct vnode *,
    Elf64_Phdr *, u_int64_t *, u_int64_t *, int *));

int exec_elf64_fixup __P((struct proc *, struct exec_package *));

/* round up and down to page boundaries. */
#define ELF_ROUND(a, b)		(((a) + (b) - 1) & ~((b) - 1))
#define ELF_TRUNC(a, b)		((a) & ~((b) - 1))

/*
 * This is the basic elf emul. elf64_probe_funcs may change to other emuls.
 */

extern char sigcode[], esigcode[];
#ifdef SYSCALL_DEBUG
extern char *syscallnames[];
#endif

struct emul emul_elf64 = {
	"native",
	NULL,
	sendsig,
	SYS_syscall,
	SYS_MAXSYSCALL,
	sysent,
#ifdef SYSCALL_DEBUG
	syscallnames,
#else
	NULL,
#endif
	sizeof (AuxInfo) * ELF_AUX_ENTRIES,
	elf64_copyargs,
	setregs,
	exec_elf64_fixup,
	sigcode,
	esigcode,
};

/*
 * Copy arguments onto the stack in the normal way, but add some
 * space for extra information in case of dynamic binding.
 */
void *
elf64_copyargs(pack, arginfo, stack, argp)
	struct exec_package *pack;
	struct ps_strings *arginfo;
	void *stack;
	void *argp;
{
	stack = copyargs(pack, arginfo, stack, argp);
	if (!stack)
		return (NULL);

	/*
	 * Push space for extra arguments on the stack needed by
	 * dynamically linked binaries
	 */
	if (pack->ep_interp != NULL) {
		pack->ep_emul_argp = stack;
		stack += ELF_AUX_ENTRIES * sizeof (AuxInfo);
	}
	return (stack);
}

/*
 * elf64_check_header():
 *
 * Check header for validity; return 0 for ok, ENOEXEC if error
 */
int
elf64_check_header(ehdr, type)
	Elf64_Ehdr *ehdr;
	int type;
{
	/*
	 * We need to check magic, class size, endianess, and version before
	 * we look at the rest of the Elf64_Ehdr structure. These few elements
	 * are represented in a machine independant fashion.
	 */
	if (!IS_ELF(*ehdr) ||
	    ehdr->e_ident[EI_CLASS] != ELF_TARG_CLASS ||
	    ehdr->e_ident[EI_DATA] != ELF_TARG_DATA ||
	    ehdr->e_ident[EI_VERSION] != ELF_TARG_VER)
		return (ENOEXEC);

	/* Now check the machine dependant header */
	if (ehdr->e_machine != ELF_TARG_MACH ||
	    ehdr->e_version != ELF_TARG_VER)
		return (ENOEXEC);

	/* Check the type */
	if (ehdr->e_type != type)
		return (ENOEXEC);

	if (ehdr->e_phnum > 128)
		return (ENOEXEC);

	return (0);
}

/*
 * olf64_check_header():
 *
 * Check header for validity; return 0 for ok, ENOEXEC if error.
 * Remeber OS tag for callers sake.
 */
int
olf64_check_header(ehdr, type, os)
	Elf64_Ehdr *ehdr;
	int type;
	u_int8_t *os;
{
	int i;

	/*
	 * We need to check magic, class size, endianess, version, and OS
	 * before we look at the rest of the Elf64_Ehdr structure. These few
	 * elements are represented in a machine independant fashion.
	 */
	if (!IS_OLF(*ehdr) ||
	    ehdr->e_ident[OI_CLASS] != ELF_TARG_CLASS ||
	    ehdr->e_ident[OI_DATA] != ELF_TARG_DATA ||
	    ehdr->e_ident[OI_VERSION] != ELF_TARG_VER)
		return (ENOEXEC);

	for (i = 0; i < sizeof elf64_probes / sizeof elf64_probes[0]; i++)
		if ((1 << ehdr->e_ident[OI_OS]) & elf64_probes[i].os_mask)
			goto os_ok;
	return (ENOEXEC);

os_ok:
	/* Now check the machine dependant header */
	if (ehdr->e_machine != ELF_TARG_MACH ||
	    ehdr->e_version != ELF_TARG_VER)
		return (ENOEXEC);

	/* Check the type */
	if (ehdr->e_type != type)
		return (ENOEXEC);

	/* Don't allow an insane amount of sections. */
	if (ehdr->e_phnum > 128)
		return (ENOEXEC);

	*os = ehdr->e_ident[OI_OS];
	return (0);
}

/*
 * elf64_load_psection():
 *
 * Load a psection at the appropriate address
 */
void
elf64_load_psection(vcset, vp, ph, addr, size, prot)
	struct exec_vmcmd_set *vcset;
	struct vnode *vp;
	Elf64_Phdr *ph;
	u_int64_t *addr;
	u_int64_t *size;
	int *prot;
{
	u_long uaddr, msize, psize, rm, rf;
	long diff, offset;

	/*
	 * If the user specified an address, then we load there.
	 */
	if (*addr != ELF64_NO_ADDR) {
		if (ph->p_align > 1) {
			*addr = ELF_ROUND(*addr, ph->p_align);
			uaddr = ELF_TRUNC(ph->p_vaddr, ph->p_align);
		} else
			uaddr = ph->p_vaddr;
		diff = ph->p_vaddr - uaddr;
	} else {
		*addr = uaddr = ph->p_vaddr;
		if (ph->p_align > 1)
			*addr = ELF_TRUNC(uaddr, ph->p_align);
		diff = uaddr - *addr;
	}

	*prot |= (ph->p_flags & PF_R) ? VM_PROT_READ : 0;
	*prot |= (ph->p_flags & PF_W) ? VM_PROT_WRITE : 0;
	*prot |= (ph->p_flags & PF_X) ? VM_PROT_EXECUTE : 0;

	offset = ph->p_offset - diff;
	*size = ph->p_filesz + diff;
	msize = ph->p_memsz + diff;
	psize = round_page(*size);

	/*
	 * Because the pagedvn pager can't handle zero fill of the last
	 * data page if it's not page aligned we map the last page readvn.
	 */
	if (ph->p_flags & PF_W) {
		psize = trunc_page(*size);
		NEW_VMCMD(vcset, vmcmd_map_pagedvn, psize, *addr, vp,
		    offset, *prot);
		if (psize != *size) {
			NEW_VMCMD(vcset, vmcmd_map_readvn, *size - psize,
			    *addr + psize, vp, offset + psize, *prot);
		}
	} else {
		NEW_VMCMD(vcset, vmcmd_map_pagedvn, psize, *addr, vp, offset,
		    *prot);
	}

	/*
	 * Check if we need to extend the size of the segment
	 */
	rm = round_page(*addr + msize);
	rf = round_page(*addr + *size);

	if (rm != rf) {
		NEW_VMCMD(vcset, vmcmd_map_zero, rm - rf, rf, NULLVP, 0,
		    *prot);
		*size = msize;
	}
}

/*
 * elf64_read_from():
 *
 *	Read from vnode into buffer at offset.
 */
int
elf64_read_from(p, vp, off, buf, size)
	struct proc *p;
	struct vnode *vp;
	u_long off;
	caddr_t buf;
	int size;
{
	int error;
	size_t resid;

	if ((error = vn_rdwr(UIO_READ, vp, buf, size, off, UIO_SYSSPACE,
	    IO_NODELOCKED, p->p_ucred, &resid, p)) != 0)
		return error;
	/*
	 * See if we got all of it
	 */
	if (resid != 0)
		return (ENOEXEC);
	return (0);
}

/*
 * elf64_load_file():
 *
 * Load a file (interpreter/library) pointed to by path [stolen from
 * coff_load_shlib()]. Made slightly generic so it might be used externally.
 */
int
elf64_load_file(p, path, epp, ap, last)
	struct proc *p;
	char *path;
	struct exec_package *epp;
	struct elf_args	*ap;
	u_long *last;
{
	int error, i;
	struct nameidata nd;
	Elf64_Ehdr eh;
	Elf64_Phdr *ph = NULL;
	u_long phsize;
	char *bp = NULL;
	u_int64_t addr = *last;
	struct vnode *vp;
	u_int8_t os;			/* Just a dummy in this routine */

	bp = path;
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_SYSSPACE, path, p);
	if ((error = namei(&nd)) != 0) {
		return (error);
	}
	vp = nd.ni_vp;
	if (vp->v_type != VREG) {
		error = EACCES;
		goto bad;
	}
	if ((error = VOP_GETATTR(vp, epp->ep_vap, p->p_ucred, p)) != 0)
		goto bad;
	if (vp->v_mount->mnt_flag & MNT_NOEXEC) {
		error = EACCES;
		goto bad;
	}
	if ((error = VOP_ACCESS(vp, VREAD, p->p_ucred, p)) != 0)
		goto bad1;
	if ((error = elf64_read_from(p, nd.ni_vp, 0,
				    (caddr_t)&eh, sizeof(eh))) != 0)
		goto bad1;

	if (elf64_check_header(&eh, ET_DYN) &&
	    olf64_check_header(&eh, ET_DYN, &os)) {
		error = ENOEXEC;
		goto bad1;
	}

	phsize = eh.e_phnum * sizeof(Elf64_Phdr);
	ph = (Elf64_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);

	if ((error = elf64_read_from(p, nd.ni_vp, eh.e_phoff, (caddr_t)ph,
	    phsize)) != 0)
		goto bad1;

	/*
	 * Load all the necessary sections
	 */
	for (i = 0; i < eh.e_phnum; i++) {
		u_int64_t size = 0;
		int prot = 0;
#if defined(__mips__)
		if (*last == ELF64_NO_ADDR)
			addr = ELF64_NO_ADDR;	/* GRRRRR!!!!! */
#endif

		switch (ph[i].p_type) {
		case PT_LOAD:
			elf64_load_psection(&epp->ep_vmcmds, nd.ni_vp, &ph[i],
						&addr, &size, &prot);
			/* If entry is within this section it must be text */
			if (eh.e_entry >= ph[i].p_vaddr &&
			    eh.e_entry < (ph[i].p_vaddr + size)) {
 				epp->ep_entry = addr + eh.e_entry -
				    ELF_TRUNC(ph[i].p_vaddr,ph[i].p_align);
				ap->arg_interp = addr;
			}
			addr += size;
			break;

		case PT_DYNAMIC:
		case PT_PHDR:
		case PT_NOTE:
			break;

		default:
			break;
		}
	}

bad1:
	VOP_CLOSE(nd.ni_vp, FREAD, p->p_ucred, p);
bad:
	if (ph != NULL)
		free((char *)ph, M_TEMP);

	*last = addr;
	vput(nd.ni_vp);
	return (error);
}

/*
 * exec_elf64_makecmds(): Prepare an Elf binary's exec package
 *
 * First, set of the various offsets/lengths in the exec package.
 *
 * Then, mark the text image busy (so it can be demand paged) or error out if
 * this is not possible.  Finally, set up vmcmds for the text, data, bss, and
 * stack segments.
 */
int
exec_elf64_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	Elf64_Ehdr *eh = epp->ep_hdr;
	Elf64_Phdr *ph, *pp;
	Elf64_Addr phdr = 0;
	int error, i, nload;
	char interp[MAXPATHLEN];
	u_long pos = 0, phsize;
	u_int8_t os = OOS_NULL;

	if (epp->ep_hdrvalid < sizeof(Elf64_Ehdr))
		return (ENOEXEC);

	if (elf64_check_header(eh, ET_EXEC) &&
	    olf64_check_header(eh, ET_EXEC, &os))
		return (ENOEXEC);

	/*
	 * check if vnode is in open for writing, because we want to demand-
	 * page out of it.  if it is, don't do it, for various reasons.
	 */
	if (epp->ep_vp->v_writecount != 0) {
#ifdef DIAGNOSTIC
		if (epp->ep_vp->v_flag & VTEXT)
			panic("exec: a VTEXT vnode has writecount != 0");
#endif
		return (ETXTBSY);
	}
	/*
	 * Allocate space to hold all the program headers, and read them
	 * from the file
	 */
	phsize = eh->e_phnum * sizeof(Elf64_Phdr);
	ph = (Elf64_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);

	if ((error = elf64_read_from(p, epp->ep_vp, eh->e_phoff, (caddr_t)ph,
	    phsize)) != 0)
		goto bad;

	epp->ep_tsize = ELF64_NO_ADDR;
	epp->ep_dsize = ELF64_NO_ADDR;

	interp[0] = '\0';

	for (i = 0; i < eh->e_phnum; i++) {
		pp = &ph[i];
		if (pp->p_type == PT_INTERP) {
			if (pp->p_filesz >= sizeof(interp))
				goto bad;
			if ((error = elf64_read_from(p, epp->ep_vp,
			    pp->p_offset, (caddr_t)interp,
			    pp->p_filesz)) != 0)
				goto bad;
			break;
		}
	}

	/*
	 * OK, we want a slightly different twist of the
	 * standard emulation package for "real" elf.
	 */
	epp->ep_emul = &emul_elf64;
	pos = ELF64_NO_ADDR;

	/*
	 * On the same architecture, we may be emulating different systems.
	 * See which one will accept this executable. This currently only
	 * applies to Linux and SVR4 on the i386 and the Alpha.
	 *
	 * Probe functions would normally see if the interpreter (if any)
	 * exists. Emulation packages may possibly replace the interpreter in
	 * interp[] with a changed path (/emul/xxx/<path>), and also
	 * set the ep_emul field in the exec package structure.
	 */
	error = ENOEXEC;
	p->p_os = OOS_OPENBSD;

#ifdef NATIVE_EXEC_ELF
	if (elf64_os_pt_note(p, epp, epp->ep_hdr, "OpenBSD", 8, 4) == 0) {
		goto native;
	}
#endif
	for (i = 0; i < sizeof elf64_probes / sizeof elf64_probes[0] && error;
	    i++)
		if (os == OOS_NULL || ((1 << os) & elf64_probes[i].os_mask))
			error = elf64_probes[i].func ?
			    (*elf64_probes[i].func)(p, epp, interp, &pos, &os) :
			    0;
	if (!error)
		p->p_os = os;
#ifndef NATIVE_EXEC_ELF
	else
		goto bad;
#endif /* NATIVE_EXEC_ELF */

native:
	/*
	 * Load all the necessary sections
	 */
	for (i = nload = 0; i < eh->e_phnum; i++) {
		u_int64_t addr = ELF64_NO_ADDR, size = 0;
		int prot = 0;

		pp = &ph[i];

		switch (ph[i].p_type) {
		case PT_LOAD:
			/*
			 * XXX
			 * Can handle only 2 sections: text and data
			 */
			if (nload++ == 2)
				goto bad;
			elf64_load_psection(&epp->ep_vmcmds, epp->ep_vp, &ph[i],
			    &addr, &size, &prot);
			/*
			 * Decide whether it's text or data by looking
			 * at the entry point.
			 */
			if (eh->e_entry >= addr &&
			    eh->e_entry < (addr + size)) {
				epp->ep_taddr = addr;
				epp->ep_tsize = size;
				if (epp->ep_daddr == ELF64_NO_ADDR) {
					epp->ep_daddr = addr;
					epp->ep_dsize = size;
				}
			} else {
				epp->ep_daddr = addr;
				epp->ep_dsize = size;
			}
			break;

		case PT_SHLIB:
			error = ENOEXEC;
			goto bad;

		case PT_INTERP:
			/* Already did this one */
		case PT_DYNAMIC:
		case PT_NOTE:
			break;

		case PT_PHDR:
			/* Note address of program headers (in text segment) */
			phdr = pp->p_vaddr;
			break;

		default:
			/*
			 * Not fatal, we don't need to understand everything
			 * :-)
			 */
			break;
		}
	}

#if !defined(__mips__)
	/*
	 * If no position to load the interpreter was set by a probe
	 * function, pick the same address that a non-fixed mmap(0, ..)
	 * would (i.e. something safely out of the way).
	 */
	if (pos == ELF64_NO_ADDR)
		pos = round_page(epp->ep_daddr + MAXDSIZ);
#endif

	/*
	 * Check if we found a dynamically linked binary and arrange to load
	 * it's interpreter when the exec file is released.
	 */
	if (interp[0]) {
		char *ip;
		struct elf_args *ap;

		ip = (char *)malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
		ap = (struct elf_args *)
		    malloc(sizeof(struct elf_args), M_TEMP, M_WAITOK);

		bcopy(interp, ip, MAXPATHLEN);
		epp->ep_interp = ip;
		epp->ep_interp_pos = pos;

		ap->arg_phaddr = phdr;
		ap->arg_phentsize = eh->e_phentsize;
		ap->arg_phnum = eh->e_phnum;
		ap->arg_entry = eh->e_entry;
		ap->arg_os = os;

		epp->ep_emul_arg = ap;
		epp->ep_entry = eh->e_entry; /* keep check_exec() happy */
	} else {
		epp->ep_interp = NULL;
		epp->ep_entry = eh->e_entry;
	}

#if defined(COMPAT_SVR4) && defined(i386)
#ifndef ELF_MAP_PAGE_ZERO
	/* Dell SVR4 maps page zero, yeuch! */
	if (p->p_os == OOS_DELL)
#endif
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, PAGE_SIZE, 0,
		    epp->ep_vp, 0, VM_PROT_READ);
#endif

	free((char *)ph, M_TEMP);
	epp->ep_vp->v_flag |= VTEXT;
	return (exec_setup_stack(p, epp));

bad:
	free((char *)ph, M_TEMP);
	kill_vmcmds(&epp->ep_vmcmds);
	return (ENOEXEC);
}

/*
 * Phase II of load. It is now safe to load the interpreter. Info collected
 * when loading the program is available for setup of the interpreter.
 */
int
exec_elf64_fixup(p, epp)
	struct proc *p;
	struct exec_package *epp;
{
	char	*interp;
	int	error, i;
	struct	elf_args *ap;
	AuxInfo ai[ELF_AUX_ENTRIES], *a;
	u_long	pos = epp->ep_interp_pos;

	if (epp->ep_interp == 0) {
		return (0);
	}

	interp = (char *)epp->ep_interp;
	ap = (struct elf_args *)epp->ep_emul_arg;

	if ((error = elf64_load_file(p, interp, epp, ap, &pos)) != 0) {
		free((char *)ap, M_TEMP);
		free((char *)interp, M_TEMP);
		kill_vmcmds(&epp->ep_vmcmds);
		return (error);
	}

	/*
	 * We have to do this ourselves...
	 */
	for (i = 0; i < epp->ep_vmcmds.evs_used && !error; i++) {
		struct exec_vmcmd *vcp;

		vcp = &epp->ep_vmcmds.evs_cmds[i];
		error = (*vcp->ev_proc)(p, vcp);
	}
	kill_vmcmds(&epp->ep_vmcmds);

	/*
	 * Push extra arguments on the stack needed by dynamically
	 * linked binaries
	 */
	if (error == 0) {
		a = ai;

		a->au_id = AUX_phdr;
		a->au_v = ap->arg_phaddr;
		a++;

		a->au_id = AUX_phent;
		a->au_v = ap->arg_phentsize;
		a++;

		a->au_id = AUX_phnum;
		a->au_v = ap->arg_phnum;
		a++;

		a->au_id = AUX_pagesz;
		a->au_v = PAGE_SIZE;
		a++;

		a->au_id = AUX_base;
		a->au_v = ap->arg_interp;
		a++;

		a->au_id = AUX_flags;
		a->au_v = 0;
		a++;

		a->au_id = AUX_entry;
		a->au_v = ap->arg_entry;
		a++;

		a->au_id = AUX_null;
		a->au_v = 0;
		a++;

		error = copyout(ai, epp->ep_emul_argp, sizeof ai);
	}
	free((char *)ap, M_TEMP);
	free((char *)interp, M_TEMP);
	return (error);
}

char *
elf64_check_brand(eh)
	Elf64_Ehdr *eh;
{
	if (eh->e_ident[EI_BRAND] == '\0')
		return (NULL);
	return (&eh->e_ident[EI_BRAND]);
}

int
elf64_os_pt_note(p, epp, eh, os_name, name_size, desc_size)
	struct proc *p;
	struct exec_package *epp;
	Elf64_Ehdr *eh;
	char *os_name;
	size_t name_size, desc_size;
{
	Elf64_Phdr *hph, *ph;
	Elf64_Note *np = NULL;
	size_t phsize;
	int error;

	phsize = eh->e_phnum * sizeof(Elf64_Phdr);
	hph = (Elf64_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
	if ((error = elf64_read_from(p, epp->ep_vp, eh->e_phoff,
	    (caddr_t)hph, phsize)) != 0)
		goto out1;

	for (ph = hph;  ph < &hph[eh->e_phnum]; ph++) {
		if (ph->p_type != PT_NOTE ||
		    ph->p_filesz < sizeof(Elf64_Note) + name_size)
			continue;

		np = (Elf64_Note *)malloc(ph->p_filesz, M_TEMP, M_WAITOK);
		if ((error = elf64_read_from(p, epp->ep_vp, ph->p_offset,
		    (caddr_t)np, ph->p_filesz)) != 0)
			goto out2;

#if 0
		if (np->type != ELF_NOTE_TYPE_OSVERSION) {
			free(np, M_TEMP);
			np = NULL;
			continue;
		}
#endif

		/* Check the name and description sizes. */
		if (np->namesz != name_size ||
		    np->descsz != desc_size)
			goto out3;

		if (bcmp((np + 1), os_name, name_size))
			goto out3;

		/* XXX: We could check for the specific emulation here */
		/* All checks succeeded. */
		error = 0;
		goto out2;
	}

out3:
	error = ENOEXEC;
out2:
	if (np)
		free(np, M_TEMP);
out1:
	free(hph, M_TEMP);
	return error;
}

@


1.17
log
@Make the e_phnum check slightly cleaner.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.16 2001/07/09 18:55:21 millert Exp $	*/
a54 2
#include <vm/vm_param.h>
#include <vm/vm_map.h>
@


1.16
log
@Make quad types on alpha be "long long" not "long".  This means that
printf's "%lld" can be used with a quad_t or int64_t without a bogus cast.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.15 2001/06/22 14:14:07 deraadt Exp $	*/
d202 3
d248 4
a408 5
	if (phsize > 8192) {
		/* XXX - this is not the way we want to fix this, but ... */
		error = EINVAL;
		goto bad1;
	}
a796 4
	if (phsize > 8192) {
		/* XXX - this is not the way we want to fix this, but ... */
		return EINVAL;
	}
@


1.15
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.14 2001/03/29 13:25:34 art Exp $	*/
d109 1
a109 1
    Elf64_Phdr *, u_long *, u_long *, int *));
d259 2
a260 2
	u_long *addr;
	u_long *size;
d369 1
a369 1
	u_long addr = *last;
d417 1
a417 1
		u_long size = 0;
@


1.14
log
@Kludge around a problem where incorrect elf headers can cause
us to allocate too much memory in kmem_map and barf.
This solution is completly bogus but it is the best I can do right now.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.13 2001/03/07 00:56:30 niklas Exp $	*/
d114 2
a115 2
#define ELF_ROUND(a, b)         (((a) + (b) - 1) & ~((b) - 1))
#define ELF_TRUNC(a, b)         ((a) & ~((b) - 1))
d182 1
a182 1
        /*
d191 3
a193 3
                return (ENOEXEC);
        
        /* Now check the machine dependant header */
d196 1
a196 1
                return (ENOEXEC);
d198 1
a198 1
        /* Check the type */
d219 1
a219 1
        /*
d228 1
a228 1
                return (ENOEXEC);
d232 1
a232 1
                	goto os_ok;
d235 2
a236 2
os_ok:        
        /* Now check the machine dependant header */
d239 1
a239 1
                return (ENOEXEC);
d241 1
a241 1
        /* Check the type */
d251 1
a251 1
 * 
d296 1
a296 1
	if(ph->p_flags & PF_W) {
d304 3
a306 4
	}
	else {
		 NEW_VMCMD(vcset, vmcmd_map_pagedvn, psize, *addr, vp, offset,
		     *prot);
d432 1
a432 1
                                        ELF_TRUNC(ph[i].p_vaddr,ph[i].p_align);
d521 2
a522 2
			     pp->p_offset, (caddr_t)interp,
			     pp->p_filesz)) != 0)
d554 1
a554 1
	     i++)
d595 3
a597 3
                                        epp->ep_daddr = addr;
                                        epp->ep_dsize = size;
                                }
d662 1
a662 2
	}
	else {
d701 1
a701 1
	if(epp->ep_interp == 0) {
@


1.13
log
@2nd bug on the road to shlibs on alpha:
Off by one page when loading.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.12 2001/02/03 23:32:13 art Exp $	*/
d403 5
d797 4
@


1.12
log
@Do a check for the OpenBSD note before doing any emulation probes.
This way OpenBSD will be explicitly treated first and not handled as a
fallback.
This should speed archs with many emulations.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.11 2001/01/22 14:25:03 art Exp $	*/
d271 1
a271 1
			*addr = ELF_ROUND(*addr + ph->p_align, ph->p_align);
@


1.11
log
@NATIVE_ELF -> NATIVE_EXEC_ELF (just some leftovers)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.10 2001/01/16 15:46:20 art Exp $	*/
a145 1

d300 1
a300 1
		if(psize != *size) {
d543 6
d562 1
@


1.10
log
@Add a check for MNT_NOEXEC that was in exec_elf.c but not here.
I am not sure if it is necessary, but it will not hurt either.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.9 2000/12/14 16:54:41 art Exp $	*/
d555 1
a555 1
#endif /* NATIVE_ELF */
@


1.9
log
@NATIVE_ELF -> NATIVE_EXEC_ELF (this is what userland uses and
what is defined in machine/exec.h
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.8 1999/11/25 13:41:30 art Exp $	*/
d387 4
@


1.8
log
@Use PAGE_SIZE instead of NBPG.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.7 1999/09/27 11:10:30 kstailey Exp $	*/
d97 1
a97 1
#ifdef NATIVE_ELF
d548 1
a548 1
#ifndef NATIVE_ELF
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.14 2001/03/29 13:25:34 art Exp $	*/
d97 1
a97 1
#ifdef NATIVE_EXEC_ELF
d146 1
d272 1
a272 1
			*addr = ELF_ROUND(*addr, ph->p_align);
d301 1
a301 1
		if (psize != *size) {
a386 4
	if (vp->v_mount->mnt_flag & MNT_NOEXEC) {
		error = EACCES;
		goto bad;
	}
a399 5
	if (phsize > 8192) {
		/* XXX - this is not the way we want to fix this, but ... */
		error = EINVAL;
		goto bad1;
	}
a539 6

#ifdef NATIVE_EXEC_ELF
	if (elf64_os_pt_note(p, epp, epp->ep_hdr, "OpenBSD", 8, 4) == 0) {
		goto native;
	}
#endif
d548 1
a548 1
#ifndef NATIVE_EXEC_ELF
d551 1
a551 1
#endif /* NATIVE_EXEC_ELF */
a552 1
native:
a781 4
	if (phsize > 8192) {
		/* XXX - this is not the way we want to fix this, but ... */
		return EINVAL;
	}
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.8.2.1 2001/05/14 22:32:38 niklas Exp $	*/
d114 2
a115 2
#define ELF_ROUND(a, b)		(((a) + (b) - 1) & ~((b) - 1))
#define ELF_TRUNC(a, b)		((a) & ~((b) - 1))
d182 1
a182 1
	/*
d191 3
a193 3
		return (ENOEXEC);

	/* Now check the machine dependant header */
d196 1
a196 1
		return (ENOEXEC);
d198 1
a198 1
	/* Check the type */
d219 1
a219 1
	/*
d228 1
a228 1
		return (ENOEXEC);
d232 1
a232 1
			goto os_ok;
d235 2
a236 2
os_ok:
	/* Now check the machine dependant header */
d239 1
a239 1
		return (ENOEXEC);
d241 1
a241 1
	/* Check the type */
d251 1
a251 1
 *
d296 1
a296 1
	if (ph->p_flags & PF_W) {
d304 4
a307 3
	} else {
		NEW_VMCMD(vcset, vmcmd_map_pagedvn, psize, *addr, vp, offset,
		    *prot);
d433 1
a433 1
				    ELF_TRUNC(ph[i].p_vaddr,ph[i].p_align);
d522 2
a523 2
			    pp->p_offset, (caddr_t)interp,
			    pp->p_filesz)) != 0)
d555 1
a555 1
	    i++)
d596 3
a598 3
					epp->ep_daddr = addr;
					epp->ep_dsize = size;
				}
d663 2
a664 1
	} else {
d703 1
a703 1
	if (epp->ep_interp == 0) {
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 59
d62 784
a845 3
#ifdef _KERN_DO_ELF64
#define ELFSIZE 64
#include <kern/exec_elf.c>
@


1.8.2.4
log
@merge in -current
@
text
@a0 3
/*
 * Public domain. Author: Artur Grabowski <art@@openbsd.org>
 */
@


1.7
log
@do not attempt to run NetBSD binaries using native emul
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.6 1999/09/25 11:43:29 kstailey Exp $	*/
d659 1
a659 1
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, NBPG, 0,
d733 1
a733 1
		a->au_v = NBPG;
@


1.6
log
@clean up
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.5 1999/09/20 11:09:37 kstailey Exp $	*/
d97 1
d99 1
@


1.5
log
@clean up
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.4 1999/09/19 16:16:49 kstailey Exp $	*/
a48 1
#include <sys/filedesc.h>
a364 1
	struct vnode *vp;
d370 1
a382 2
	if ((error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p)) != 0)
		goto bad;
d385 2
a386 7
	if (vp->v_mount->mnt_flag & MNT_NOEXEC) {
		error = EACCES;
		goto bad;
	}
	if ((vp->v_mount->mnt_flag & MNT_NOSUID) ||
	    (p->p_flag & P_TRACED) || p->p_fd->fd_refcnt > 1)
		epp->ep_vap->va_mode &= ~(VSUID | VSGID);
d515 1
d594 1
a595 1
		case PT_DYNAMIC:
@


1.4
log
@improved OS brand PT_NOTE detection
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.3 1999/09/19 13:59:22 kstailey Exp $	*/
d600 1
a601 1
			/* Already did these */
a691 1
	size_t len;
a717 2
	a = ai;

d723 1
a751 1
	}
d753 3
a755 3
	a->au_id = AUX_null;
	a->au_v = 0;
	a++;
d757 2
a758 2
	len = (a - ai) * sizeof(AuxInfo);
	error = copyout(ai, epp->ep_emul_argp, len);
@


1.3
log
@use PT_NOTE to identify NetBSD ELF64 binaries
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.2 1999/09/12 14:15:17 kstailey Exp $	*/
a523 10
		if (pp->p_type == PT_NOTE) {
			int max_brand = (EI_NIDENT - 1) - EI_BRAND;

			if ((error = elf64_read_from(p, epp->ep_vp,
			     pp->p_offset + 12, (caddr_t)&eh->e_ident[EI_BRAND],
			     pp->p_filesz - 12 <= max_brand ?
			     pp->p_filesz - 12 : max_brand)) != 0)
				goto bad;
			eh->e_ident[EI_NIDENT - 1] = '\0';
		}
d692 1
d719 2
d725 1
a725 2
	if(error == 0) {
		a = ai;
d754 1
d756 3
a758 3
		a->au_id = AUX_null;
		a->au_v = 0;
		a++;
d760 2
a761 2
		error = copyout(ai, epp->ep_emul_argp, sizeof ai);
	}
d774 61
@


1.2
log
@Add COMPAT_NETBSD.  Currently only works for ELF64.  Many missing system calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf64.c,v 1.1 1999/09/10 12:24:27 kstailey Exp $	*/
d49 1
d184 1
a184 1
	 * we look at the rest of the Elf32_Ehdr structure. These few elements
d221 1
a221 1
	 * before we look at the rest of the Elf32_Ehdr structure. These few
d294 1
a294 1
	 * data page if it's not page aligned we map the las page readvn.
d366 1
a371 1
	struct vnode *vp;
d384 2
d392 3
a394 2
	if ((error = VOP_ACCESS(vp, VREAD, p->p_ucred, p)) != 0)
		goto bad1;
d419 2
a420 2
		if (*last == ELF32_NO_ADDR)
			addr = ELF32_NO_ADDR;	/* GRRRRR!!!!! */
d523 10
a532 1
			break;
d610 2
a611 1
			/* Already did this one */
a612 1
		case PT_NOTE:
d716 1
d718 1
a718 1
	 * We have to do this ourselfs...
@


1.1
log
@ELF64
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 4
d93 3
@

