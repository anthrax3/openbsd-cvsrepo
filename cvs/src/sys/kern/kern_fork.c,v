head	1.195;
access;
symbols
	OPENBSD_6_1:1.195.0.4
	OPENBSD_6_1_BASE:1.195
	OPENBSD_6_0:1.187.0.2
	OPENBSD_6_0_BASE:1.187
	OPENBSD_5_9:1.184.0.2
	OPENBSD_5_9_BASE:1.184
	OPENBSD_5_8:1.181.0.4
	OPENBSD_5_8_BASE:1.181
	OPENBSD_5_7:1.178.0.2
	OPENBSD_5_7_BASE:1.178
	OPENBSD_5_6:1.173.0.4
	OPENBSD_5_6_BASE:1.173
	OPENBSD_5_5:1.158.0.4
	OPENBSD_5_5_BASE:1.158
	OPENBSD_5_4:1.152.0.2
	OPENBSD_5_4_BASE:1.152
	OPENBSD_5_3:1.143.0.2
	OPENBSD_5_3_BASE:1.143
	OPENBSD_5_2:1.141.0.2
	OPENBSD_5_2_BASE:1.141
	OPENBSD_5_1_BASE:1.133
	OPENBSD_5_1:1.133.0.2
	OPENBSD_5_0:1.128.0.2
	OPENBSD_5_0_BASE:1.128
	OPENBSD_4_9:1.123.0.2
	OPENBSD_4_9_BASE:1.123
	OPENBSD_4_8:1.122.0.2
	OPENBSD_4_8_BASE:1.122
	OPENBSD_4_7:1.108.0.2
	OPENBSD_4_7_BASE:1.108
	OPENBSD_4_6:1.103.0.4
	OPENBSD_4_6_BASE:1.103
	OPENBSD_4_5:1.101.0.2
	OPENBSD_4_5_BASE:1.101
	OPENBSD_4_4:1.95.0.2
	OPENBSD_4_4_BASE:1.95
	OPENBSD_4_3:1.93.0.2
	OPENBSD_4_3_BASE:1.93
	OPENBSD_4_2:1.92.0.2
	OPENBSD_4_2_BASE:1.92
	OPENBSD_4_1:1.86.0.2
	OPENBSD_4_1_BASE:1.86
	OPENBSD_4_0:1.84.0.2
	OPENBSD_4_0_BASE:1.84
	OPENBSD_3_9:1.82.0.2
	OPENBSD_3_9_BASE:1.82
	OPENBSD_3_8:1.76.0.2
	OPENBSD_3_8_BASE:1.76
	OPENBSD_3_7:1.74.0.2
	OPENBSD_3_7_BASE:1.74
	OPENBSD_3_6:1.72.0.2
	OPENBSD_3_6_BASE:1.72
	SMP_SYNC_A:1.68
	SMP_SYNC_B:1.68
	OPENBSD_3_5:1.63.0.2
	OPENBSD_3_5_BASE:1.63
	OPENBSD_3_4:1.62.0.2
	OPENBSD_3_4_BASE:1.62
	UBC_SYNC_A:1.59
	OPENBSD_3_3:1.59.0.2
	OPENBSD_3_3_BASE:1.59
	OPENBSD_3_2:1.55.0.2
	OPENBSD_3_2_BASE:1.55
	OPENBSD_3_1:1.54.0.2
	OPENBSD_3_1_BASE:1.54
	UBC_SYNC_B:1.58
	UBC:1.47.0.2
	UBC_BASE:1.47
	OPENBSD_3_0:1.44.0.2
	OPENBSD_3_0_BASE:1.44
	OPENBSD_2_9_BASE:1.39
	OPENBSD_2_9:1.39.0.2
	OPENBSD_2_8:1.34.0.2
	OPENBSD_2_8_BASE:1.34
	OPENBSD_2_7:1.31.0.2
	OPENBSD_2_7_BASE:1.31
	SMP:1.27.0.2
	SMP_BASE:1.27
	kame_19991208:1.24
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.11.0.6
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.4
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.195
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.194;
commitid	1rXx7AiXIWFC9gYa;

1.194
date	2017.02.08.20.58.30;	author guenther;	state Exp;
branches;
next	1.193;
commitid	RODF8jyufTSNUZTf;

1.193
date	2017.01.24.00.58.55;	author mpi;	state Exp;
branches;
next	1.192;
commitid	r0ks7yUPmANG37rA;

1.192
date	2016.11.07.00.26.32;	author guenther;	state Exp;
branches;
next	1.191;
commitid	W7ztnDZwvjCaeQTS;

1.191
date	2016.10.22.02.55.36;	author guenther;	state Exp;
branches;
next	1.190;
commitid	l1sd7z8X5468Zlqi;

1.190
date	2016.10.15.05.09.01;	author guenther;	state Exp;
branches;
next	1.189;
commitid	nO83SSBM5BPAr8yb;

1.189
date	2016.09.03.14.29.05;	author jca;	state Exp;
branches;
next	1.188;
commitid	iJf9rV3r9IVwcwIp;

1.188
date	2016.08.31.14.15.07;	author tom;	state Exp;
branches;
next	1.187;
commitid	DR0BBySvA0Y2Pi3E;

1.187
date	2016.04.25.20.18.31;	author tedu;	state Exp;
branches;
next	1.186;
commitid	AL2KSeDZVXs2nAYI;

1.186
date	2016.04.25.20.00.33;	author tedu;	state Exp;
branches;
next	1.185;
commitid	MLNYUlvoOtU8VX0s;

1.185
date	2016.03.11.19.10.14;	author tedu;	state Exp;
branches;
next	1.184;
commitid	aLbL6ncKegvTEVWV;

1.184
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.183;
commitid	av6ZVErLSWkVP5Zz;

1.183
date	2015.09.11.08.22.31;	author guenther;	state Exp;
branches;
next	1.182;
commitid	Lqreadw8v5IPAc0L;

1.182
date	2015.08.22.20.18.49;	author deraadt;	state Exp;
branches;
next	1.181;
commitid	6NDuzTPjBp2GqkfQ;

1.181
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	1.180;
commitid	CJwjm9NDWu6nJ6ES;

1.180
date	2015.03.14.07.33.42;	author jsg;	state Exp;
branches;
next	1.179;
commitid	Pve4Y9ViiMt4ukJa;

1.179
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.178;
commitid	p4LJxGKbi0BU2cG6;

1.178
date	2015.02.10.05.28.18;	author guenther;	state Exp;
branches;
next	1.177;
commitid	GFzml5gt9M5PfXe6;

1.177
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.176;
commitid	Z1vcFtHO8wRH0yRt;

1.176
date	2014.11.03.21.28.35;	author tedu;	state Exp;
branches;
next	1.175;
commitid	EkuwmBeHv2Tqmdnx;

1.175
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.174;
commitid	3SGDR5EjcwE01W8S;

1.174
date	2014.09.08.01.47.06;	author guenther;	state Exp;
branches;
next	1.173;
commitid	QKTb36RFnfteZJPE;

1.173
date	2014.07.13.15.46.21;	author uebayasi;	state Exp;
branches;
next	1.172;
commitid	Scu6CelRPdB3AwwA;

1.172
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.171;
commitid	QlVV51SZgNFxsXxC;

1.171
date	2014.07.11.08.20.42;	author guenther;	state Exp;
branches;
next	1.170;
commitid	SW7lRo2yjndZqTao;

1.170
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.169;
commitid	EF98ch02VpFassUi;

1.169
date	2014.07.07.05.31.42;	author matthew;	state Exp;
branches;
next	1.168;
commitid	EsBdDSSIJKtJvk79;

1.168
date	2014.07.04.05.58.30;	author guenther;	state Exp;
branches;
next	1.167;
commitid	vhXZZxMGVTWiFaF3;

1.167
date	2014.05.15.03.52.25;	author guenther;	state Exp;
branches;
next	1.166;

1.166
date	2014.05.06.11.50.14;	author mpi;	state Exp;
branches;
next	1.165;

1.165
date	2014.05.04.05.03.26;	author guenther;	state Exp;
branches;
next	1.164;

1.164
date	2014.05.03.22.44.36;	author guenther;	state Exp;
branches;
next	1.163;

1.163
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.162;

1.162
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.161;

1.161
date	2014.03.28.17.57.11;	author mpi;	state Exp;
branches;
next	1.160;

1.160
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.159;

1.159
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.158;

1.158
date	2014.02.12.05.47.36;	author guenther;	state Exp;
branches;
next	1.157;

1.157
date	2014.02.10.01.38.07;	author guenther;	state Exp;
branches;
next	1.156;

1.156
date	2014.01.20.21.19.28;	author guenther;	state Exp;
branches;
next	1.155;

1.155
date	2014.01.20.03.23.42;	author guenther;	state Exp;
branches;
next	1.154;

1.154
date	2013.10.08.03.50.07;	author guenther;	state Exp;
branches;
next	1.153;

1.153
date	2013.08.14.05.26.14;	author guenther;	state Exp;
branches;
next	1.152;

1.152
date	2013.06.11.13.00.31;	author tedu;	state Exp;
branches;
next	1.151;

1.151
date	2013.06.06.13.09.37;	author haesbaert;	state Exp;
branches;
next	1.150;

1.150
date	2013.06.05.00.53.26;	author tedu;	state Exp;
branches;
next	1.149;

1.149
date	2013.06.03.22.35.15;	author guenther;	state Exp;
branches;
next	1.148;

1.148
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.147;

1.147
date	2013.06.01.16.04.46;	author tedu;	state Exp;
branches;
next	1.146;

1.146
date	2013.04.06.03.44.34;	author tedu;	state Exp;
branches;
next	1.145;

1.145
date	2013.03.14.21.38.22;	author tedu;	state Exp;
branches;
next	1.144;

1.144
date	2013.03.02.07.05.17;	author guenther;	state Exp;
branches;
next	1.143;

1.143
date	2012.11.19.09.26.08;	author guenther;	state Exp;
branches;
next	1.142;

1.142
date	2012.08.02.03.18.48;	author guenther;	state Exp;
branches;
next	1.141;

1.141
date	2012.06.21.00.56.59;	author guenther;	state Exp;
branches;
next	1.140;

1.140
date	2012.05.10.05.01.23;	author guenther;	state Exp;
branches;
next	1.139;

1.139
date	2012.04.13.16.37.51;	author kettenis;	state Exp;
branches;
next	1.138;

1.138
date	2012.04.12.12.33.03;	author deraadt;	state Exp;
branches;
next	1.137;

1.137
date	2012.04.12.10.11.41;	author mikeb;	state Exp;
branches;
next	1.136;

1.136
date	2012.04.10.15.50.52;	author guenther;	state Exp;
branches;
next	1.135;

1.135
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.134;

1.134
date	2012.02.20.22.23.39;	author guenther;	state Exp;
branches;
next	1.133;

1.133
date	2011.12.14.07.32.16;	author guenther;	state Exp;
branches;
next	1.132;

1.132
date	2011.11.22.23.20.19;	author joshe;	state Exp;
branches;
next	1.131;

1.131
date	2011.11.09.20.57.38;	author guenther;	state Exp;
branches;
next	1.130;

1.130
date	2011.11.05.23.02.37;	author guenther;	state Exp;
branches;
next	1.129;

1.129
date	2011.10.15.23.35.29;	author guenther;	state Exp;
branches;
next	1.128;

1.128
date	2011.07.07.18.00.33;	author guenther;	state Exp;
branches;
next	1.127;

1.127
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.126;

1.126
date	2011.06.06.17.05.46;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.124;

1.124
date	2011.04.02.17.04.35;	author guenther;	state Exp;
branches;
next	1.123;

1.123
date	2010.10.31.00.03.44;	author guenther;	state Exp;
branches;
next	1.122;

1.122
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.121;

1.121
date	2010.07.23.14.19.02;	author miod;	state Exp;
branches;
next	1.120;

1.120
date	2010.07.19.23.00.15;	author guenther;	state Exp;
branches;
next	1.119;

1.119
date	2010.07.02.01.25.05;	author art;	state Exp;
branches;
next	1.118;

1.118
date	2010.06.30.21.01.45;	author thib;	state Exp;
branches;
next	1.117;

1.117
date	2010.06.30.00.40.28;	author guenther;	state Exp;
branches;
next	1.116;

1.116
date	2010.06.29.20.25.57;	author guenther;	state Exp;
branches;
next	1.115;

1.115
date	2010.06.29.20.14.46;	author guenther;	state Exp;
branches;
next	1.114;

1.114
date	2010.06.29.00.35.28;	author tedu;	state Exp;
branches;
next	1.113;

1.113
date	2010.06.29.00.28.14;	author tedu;	state Exp;
branches;
next	1.112;

1.112
date	2010.06.27.03.26.39;	author guenther;	state Exp;
branches;
next	1.111;

1.111
date	2010.05.29.02.47.48;	author guenther;	state Exp;
branches;
next	1.110;

1.110
date	2010.05.18.22.26.10;	author tedu;	state Exp;
branches;
next	1.109;

1.109
date	2010.03.24.23.18.17;	author tedu;	state Exp;
branches;
next	1.108;

1.108
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.107;

1.107
date	2009.12.28.02.54.24;	author guenther;	state Exp;
branches;
next	1.106;

1.106
date	2009.12.23.07.40.31;	author guenther;	state Exp;
branches;
next	1.105;

1.105
date	2009.11.27.20.05.50;	author guenther;	state Exp;
branches;
next	1.104;

1.104
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.103;

1.103
date	2009.04.14.09.13.25;	author art;	state Exp;
branches;
next	1.102;

1.102
date	2009.03.23.13.25.11;	author art;	state Exp;
branches;
next	1.101;

1.101
date	2008.11.11.02.13.14;	author tedu;	state Exp;
branches;
next	1.100;

1.100
date	2008.11.09.05.13.55;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2008.11.03.03.03.35;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2008.10.14.18.27.29;	author guenther;	state Exp;
branches;
next	1.97;

1.97
date	2008.10.10.14.35.06;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2008.10.09.06.31.53;	author guenther;	state Exp;
branches;
next	1.95;

1.95
date	2008.05.11.23.54.40;	author tedu;	state Exp;
branches;
next	1.94;

1.94
date	2008.05.11.23.50.32;	author tedu;	state Exp;
branches;
next	1.93;

1.93
date	2007.10.10.15.53.53;	author art;	state Exp;
branches;
next	1.92;

1.92
date	2007.07.25.23.11.52;	author art;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.16.17.27.30;	author art;	state Exp;
branches;
next	1.90;

1.90
date	2007.04.12.22.14.15;	author tedu;	state Exp;
branches;
next	1.89;

1.89
date	2007.04.03.08.05.43;	author art;	state Exp;
branches;
next	1.88;

1.88
date	2007.03.24.16.01.22;	author art;	state Exp;
branches;
next	1.87;

1.87
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.86;

1.86
date	2007.01.17.13.51.52;	author mickey;	state Exp;
branches;
next	1.85;

1.85
date	2006.11.29.12.24.17;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2006.04.30.15.37.07;	author kettenis;	state Exp;
branches;
next	1.83;

1.83
date	2006.03.27.19.08.58;	author mickey;	state Exp;
branches;
next	1.82;

1.82
date	2006.02.20.19.39.11;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2005.12.22.06.55.03;	author tedu;	state Exp;
branches;
next	1.80;

1.80
date	2005.12.04.21.21.46;	author tedu;	state Exp;
branches;
next	1.79;

1.79
date	2005.12.03.18.09.08;	author tedu;	state Exp;
branches;
next	1.78;

1.78
date	2005.11.02.20.03.16;	author aaron;	state Exp;
branches;
next	1.77;

1.77
date	2005.09.14.20.55.59;	author kettenis;	state Exp;
branches;
next	1.76;

1.76
date	2005.05.29.03.20.41;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.74;

1.74
date	2005.02.24.04.44.25;	author tedu;	state Exp;
branches;
next	1.73;

1.73
date	2004.11.23.19.08.55;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2004.08.06.22.31.30;	author mickey;	state Exp;
branches;
next	1.71;

1.71
date	2004.08.04.21.49.19;	author art;	state Exp;
branches;
next	1.70;

1.70
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.69;

1.69
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.68;

1.68
date	2004.06.09.20.18.28;	author art;	state Exp;
branches;
next	1.67;

1.67
date	2004.06.05.22.38.40;	author tedu;	state Exp;
branches;
next	1.66;

1.66
date	2004.05.24.02.51.22;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2004.05.23.19.37.24;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2004.04.02.19.08.58;	author tedu;	state Exp;
branches;
next	1.63;

1.63
date	2003.09.23.20.26.18;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2003.07.02.00.07.42;	author avsm;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.21.00.42.58;	author tedu;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2002.10.31.01.33.27;	author art;	state Exp;
branches;
next	1.58;

1.58
date	2002.10.22.01.48.25;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2002.10.21.21.30.02;	author art;	state Exp;
branches;
next	1.56;

1.56
date	2002.10.21.21.15.17;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2002.05.16.16.16.51;	author provos;	state Exp;
branches;
next	1.54;

1.54
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2002.02.22.01.08.42;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2002.02.16.00.54.49;	author nordin;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.14.22.58.15;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.05.15.41.24;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2002.01.25.15.00.26;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.06.13.36.52;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.10.14.14.39.03;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2001.09.19.20.50.58;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.27.07.14.22;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.27.06.21.28;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.27.04.49.42;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.02.21.43.11;	author niklas;	state Exp;
branches;
next	1.38;

1.38
date	2001.03.23.18.42.06;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.02.13.21.00.48;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2000.11.16.20.02.17;	author provos;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.09.17.02.25;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2000.07.10.05.06.12;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2000.07.07.15.57.02;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2000.06.18.17.59.55;	author niklas;	state Exp;
branches;
next	1.31;

1.31
date	2000.03.23.16.54.44;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2000.03.03.11.46.09;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2000.03.03.11.31.42;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.21.20.00.09;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2000.01.31.19.57.18;	author deraadt;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2000.01.31.01.09.10;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2000.01.28.19.45.04;	author art;	state Exp;
branches;
next	1.24;

1.24
date	99.08.17.10.32.18;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	99.08.15.00.07.43;	author pjanzen;	state Exp;
branches;
next	1.22;

1.22
date	99.07.17.21.49.37;	author art;	state Exp;
branches;
next	1.21;

1.21
date	99.07.15.14.07.41;	author art;	state Exp;
branches;
next	1.20;

1.20
date	99.03.12.17.49.37;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	99.03.02.22.19.08;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	99.02.26.04.59.39;	author art;	state Exp;
branches;
next	1.17;

1.17
date	99.02.23.18.55.09;	author art;	state Exp;
branches;
next	1.16;

1.16
date	99.02.23.18.50.22;	author art;	state Exp;
branches;
next	1.15;

1.15
date	99.02.23.18.17.19;	author art;	state Exp;
branches;
next	1.14;

1.14
date	99.02.19.19.21.42;	author art;	state Exp;
branches;
next	1.13;

1.13
date	99.01.11.20.25.09;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	99.01.10.02.20.20;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.08.01.22.54.49;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.08.01.21.59.13;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.07.07.17.52.10;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.06.05.10.15.26;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.02.18.00.11.47;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.09.02.01.22.05;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.03.03.17.19.45;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.19.22.33.38;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.01.10.18.02.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.21.37;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches;
next	;

1.27.2.1
date	2000.02.21.22.29.14;	author niklas;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2000.03.24.09.09.24;	author niklas;	state Exp;
branches;
next	1.27.2.3;

1.27.2.3
date	2001.05.14.22.32.40;	author niklas;	state Exp;
branches;
next	1.27.2.4;

1.27.2.4
date	2001.07.04.10.48.19;	author niklas;	state Exp;
branches;
next	1.27.2.5;

1.27.2.5
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.27.2.6;

1.27.2.6
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.27.2.7;

1.27.2.7
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.27.2.8;

1.27.2.8
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.27.2.9;

1.27.2.9
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.27.2.10;

1.27.2.10
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.27.2.11;

1.27.2.11
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.27.2.12;

1.27.2.12
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.27.2.13;

1.27.2.13
date	2004.03.14.22.08.21;	author niklas;	state Exp;
branches;
next	1.27.2.14;

1.27.2.14
date	2004.06.05.23.13.01;	author niklas;	state Exp;
branches;
next	1.27.2.15;

1.27.2.15
date	2004.06.06.21.46.12;	author tedu;	state Exp;
branches;
next	1.27.2.16;

1.27.2.16
date	2004.06.07.20.41.33;	author niklas;	state Exp;
branches;
next	1.27.2.17;

1.27.2.17
date	2004.06.10.11.40.33;	author niklas;	state Exp;
branches;
next	;

1.47.2.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.47.2.3;

1.47.2.3
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.47.2.4;

1.47.2.4
date	2002.11.04.18.02.31;	author art;	state Exp;
branches;
next	1.47.2.5;

1.47.2.5
date	2003.05.19.22.31.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.195
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@/*	$OpenBSD: kern_fork.c,v 1.194 2017/02/08 20:58:30 guenther Exp $	*/
/*	$NetBSD: kern_fork.c,v 1.29 1996/02/09 18:59:34 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_fork.c	8.6 (Berkeley) 4/8/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/filedesc.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/exec.h>
#include <sys/resourcevar.h>
#include <sys/signalvar.h>
#include <sys/vnode.h>
#include <sys/vmmeter.h>
#include <sys/file.h>
#include <sys/acct.h>
#include <sys/ktrace.h>
#include <sys/sched.h>
#include <sys/sysctl.h>
#include <sys/pool.h>
#include <sys/mman.h>
#include <sys/ptrace.h>
#include <sys/atomic.h>
#include <sys/pledge.h>
#include <sys/unistd.h>

#include <sys/syscallargs.h>

#include <uvm/uvm.h>

#ifdef __HAVE_MD_TCB
# include <machine/tcb.h>
#endif

int	nprocesses = 1;		/* process 0 */
int	nthreads = 1;		/* proc 0 */
int	randompid;		/* when set to 1, pid's go random */
struct	forkstat forkstat;

void fork_return(void *);
pid_t alloctid(void);
pid_t allocpid(void);
int ispidtaken(pid_t);

struct proc *thread_new(struct proc *_parent, vaddr_t _uaddr);
struct process *process_new(struct proc *, struct process *, int);
int fork_check_maxthread(uid_t _uid);

void
fork_return(void *arg)
{
	struct proc *p = (struct proc *)arg;

	if (p->p_p->ps_flags & PS_TRACED)
		psignal(p, SIGTRAP);

	child_return(p);
}

int
sys_fork(struct proc *p, void *v, register_t *retval)
{
	int flags;

	flags = FORK_FORK;
	if (p->p_p->ps_ptmask & PTRACE_FORK)
		flags |= FORK_PTRACE;
	return fork1(p, flags, fork_return, NULL, retval, NULL);
}

int
sys_vfork(struct proc *p, void *v, register_t *retval)
{
	return fork1(p, FORK_VFORK|FORK_PPWAIT, child_return, NULL,
	    retval, NULL);
}

int
sys___tfork(struct proc *p, void *v, register_t *retval)
{
	struct sys___tfork_args /* {
		syscallarg(const struct __tfork) *param;
		syscallarg(size_t) psize;
	} */ *uap = v;
	size_t psize = SCARG(uap, psize);
	struct __tfork param = { 0 };
	int error;

	if (psize == 0 || psize > sizeof(param))
		return EINVAL;
	if ((error = copyin(SCARG(uap, param), &param, psize)))
		return error;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_STRUCT))
		ktrstruct(p, "tfork", &param, sizeof(param));
#endif

	return thread_fork(p, param.tf_stack, param.tf_tcb, param.tf_tid,
	    retval);
}

/*
 * Allocate and initialize a thread (proc) structure, given the parent thread.
 */
struct proc *
thread_new(struct proc *parent, vaddr_t uaddr)
{
	struct proc *p; 

	p = pool_get(&proc_pool, PR_WAITOK);
	p->p_stat = SIDL;			/* protect against others */
	p->p_flag = 0;

	/*
	 * Make a proc table entry for the new process.
	 * Start by zeroing the section of proc that is zero-initialized,
	 * then copy the section that is copied directly from the parent.
	 */
	memset(&p->p_startzero, 0,
	    (caddr_t)&p->p_endzero - (caddr_t)&p->p_startzero);
	memcpy(&p->p_startcopy, &parent->p_startcopy,
	    (caddr_t)&p->p_endcopy - (caddr_t)&p->p_startcopy);
	crhold(p->p_ucred);
	p->p_addr = (struct user *)uaddr;

	/*
	 * Initialize the timeouts.
	 */
	timeout_set(&p->p_sleep_to, endtsleep, p);

	/*
	 * set priority of child to be that of parent
	 * XXX should move p_estcpu into the region of struct proc which gets
	 * copied.
	 */
	scheduler_fork_hook(parent, p);

	return p;
}

/*
 * Initialize common bits of a process structure, given the initial thread.
 */
void
process_initialize(struct process *pr, struct proc *p)
{
	/* initialize the thread links */
	pr->ps_mainproc = p;
	TAILQ_INIT(&pr->ps_threads);
	TAILQ_INSERT_TAIL(&pr->ps_threads, p, p_thr_link);
	pr->ps_refcnt = 1;
	p->p_p = pr;

	/* give the process the same creds as the initial thread */
	pr->ps_ucred = p->p_ucred;
	crhold(pr->ps_ucred);
	KASSERT(p->p_ucred->cr_ref >= 2);	/* new thread and new process */

	LIST_INIT(&pr->ps_children);

	timeout_set(&pr->ps_realit_to, realitexpire, pr);
}


/*
 * Allocate and initialize a new process.
 */
struct process *
process_new(struct proc *p, struct process *parent, int flags)
{
	struct process *pr;

	pr = pool_get(&process_pool, PR_WAITOK);

	/*
	 * Make a process structure for the new process.
	 * Start by zeroing the section of proc that is zero-initialized,
	 * then copy the section that is copied directly from the parent.
	 */
	memset(&pr->ps_startzero, 0,
	    (caddr_t)&pr->ps_endzero - (caddr_t)&pr->ps_startzero);
	memcpy(&pr->ps_startcopy, &parent->ps_startcopy,
	    (caddr_t)&pr->ps_endcopy - (caddr_t)&pr->ps_startcopy);

	process_initialize(pr, p);
	pr->ps_pid = allocpid();

	/* post-copy fixups */
	pr->ps_pptr = parent;
	pr->ps_limit->p_refcnt++;

	/* bump references to the text vnode (for sysctl) */
	pr->ps_textvp = parent->ps_textvp;
	if (pr->ps_textvp)
		vref(pr->ps_textvp);

	pr->ps_flags = parent->ps_flags &
	    (PS_SUGID | PS_SUGIDEXEC | PS_PLEDGE | PS_WXNEEDED);
	if (parent->ps_session->s_ttyvp != NULL)
		pr->ps_flags |= parent->ps_flags & PS_CONTROLT;

	/*
	 * Duplicate sub-structures as needed.
	 * Increase reference counts on shared objects.
	 */
	if (flags & FORK_SHAREFILES)
		pr->ps_fd = fdshare(parent);
	else
		pr->ps_fd = fdcopy(parent);
	if (flags & FORK_SIGHAND)
		pr->ps_sigacts = sigactsshare(parent);
	else
		pr->ps_sigacts = sigactsinit(parent);
	if (flags & FORK_SHAREVM)
		pr->ps_vmspace = uvmspace_share(parent);
	else
		pr->ps_vmspace = uvmspace_fork(parent);

	if (pr->ps_pledgepaths)
		pr->ps_pledgepaths->wl_ref++;

	if (parent->ps_flags & PS_PROFIL)
		startprofclock(pr);
	if (flags & FORK_PTRACE)
		pr->ps_flags |= parent->ps_flags & PS_TRACED;
	if (flags & FORK_NOZOMBIE)
		pr->ps_flags |= PS_NOZOMBIE;
	if (flags & FORK_SYSTEM)
		pr->ps_flags |= PS_SYSTEM;

	/* mark as embryo to protect against others */
	pr->ps_flags |= PS_EMBRYO;

	/* Force visibility of all of the above changes */
	membar_producer();

	/* it's sufficiently inited to be globally visible */
	LIST_INSERT_HEAD(&allprocess, pr, ps_list);

	return pr;
}

/* print the 'table full' message once per 10 seconds */
struct timeval fork_tfmrate = { 10, 0 };

int
fork_check_maxthread(uid_t uid)
{
	/*
	 * Although process entries are dynamically created, we still keep
	 * a global limit on the maximum number we will create. We reserve
	 * the last 5 processes to root. The variable nprocesses is the
	 * current number of processes, maxprocess is the limit.  Similar
	 * rules for threads (struct proc): we reserve the last 5 to root;
	 * the variable nthreads is the current number of procs, maxthread is
	 * the limit.
	 */
	if ((nthreads >= maxthread - 5 && uid != 0) || nthreads >= maxthread) {
		static struct timeval lasttfm;

		if (ratecheck(&lasttfm, &fork_tfmrate))
			tablefull("proc");
		return EAGAIN;
	}
	nthreads++;

	return 0;
}

static inline void
fork_thread_start(struct proc *p, struct proc *parent, int flags)
{
	int s;

	SCHED_LOCK(s);
	p->p_stat = SRUN;
	p->p_cpu = sched_choosecpu_fork(parent, flags);
	setrunqueue(p);
	SCHED_UNLOCK(s);
}

int
fork1(struct proc *curp, int flags, void (*func)(void *), void *arg,
    register_t *retval, struct proc **rnewprocp)
{
	struct process *curpr = curp->p_p;
	struct process *pr;
	struct proc *p;
	uid_t uid = curp->p_ucred->cr_ruid;
	struct vmspace *vm;
	int count;
	vaddr_t uaddr;
	int error;
	struct  ptrace_state *newptstat = NULL;

	KASSERT((flags & ~(FORK_FORK | FORK_VFORK | FORK_PPWAIT | FORK_PTRACE
	    | FORK_IDLE | FORK_SHAREVM | FORK_SHAREFILES | FORK_NOZOMBIE
	    | FORK_SYSTEM | FORK_SIGHAND)) == 0);
	KASSERT((flags & FORK_SIGHAND) == 0 || (flags & FORK_SHAREVM));
	KASSERT(func != NULL);

	if ((error = fork_check_maxthread(uid)))
		return error;

	if ((nprocesses >= maxprocess - 5 && uid != 0) ||
	    nprocesses >= maxprocess) {
		static struct timeval lasttfm;

		if (ratecheck(&lasttfm, &fork_tfmrate))
			tablefull("process");
		nthreads--;
		return EAGAIN;
	}
	nprocesses++;

	/*
	 * Increment the count of processes running with this uid.
	 * Don't allow a nonprivileged user to exceed their current limit.
	 */
	count = chgproccnt(uid, 1);
	if (uid != 0 && count > curp->p_rlimit[RLIMIT_NPROC].rlim_cur) {
		(void)chgproccnt(uid, -1);
		nprocesses--;
		nthreads--;
		return EAGAIN;
	}

	uaddr = uvm_uarea_alloc();
	if (uaddr == 0) {
		(void)chgproccnt(uid, -1);
		nprocesses--;
		nthreads--;
		return (ENOMEM);
	}

	/*
	 * From now on, we're committed to the fork and cannot fail.
	 */
	p = thread_new(curp, uaddr);
	pr = process_new(p, curpr, flags);

	p->p_fd		= pr->ps_fd;
	p->p_vmspace	= pr->ps_vmspace;
	if (pr->ps_flags & PS_SYSTEM)
		atomic_setbits_int(&p->p_flag, P_SYSTEM);

	if (flags & FORK_PPWAIT) {
		atomic_setbits_int(&pr->ps_flags, PS_PPWAIT);
		atomic_setbits_int(&curpr->ps_flags, PS_ISPWAIT);
	}

#ifdef KTRACE
	/*
	 * Copy traceflag and tracefile if enabled.
	 * If not inherited, these were zeroed above.
	 */
	if (curpr->ps_traceflag & KTRFAC_INHERIT)
		ktrsettrace(pr, curpr->ps_traceflag, curpr->ps_tracevp,
		    curpr->ps_tracecred);
#endif

	/*
	 * Finish creating the child thread.  cpu_fork() will copy
	 * and update the pcb and make the child ready to run.  If
	 * this is a normal user fork, the child will exit directly
	 * to user mode via child_return() on its first time slice
	 * and will not return here.  If this is a kernel thread,
	 * the specified entry point will be executed.
	 */
	cpu_fork(curp, p, NULL, NULL, func, arg ? arg : p);

	vm = pr->ps_vmspace;

	if (flags & FORK_FORK) {
		forkstat.cntfork++;
		forkstat.sizfork += vm->vm_dsize + vm->vm_ssize;
	} else if (flags & FORK_VFORK) {
		forkstat.cntvfork++;
		forkstat.sizvfork += vm->vm_dsize + vm->vm_ssize;
	} else {
		forkstat.cntkthread++;
	}

	if (pr->ps_flags & PS_TRACED && flags & FORK_FORK)
		newptstat = malloc(sizeof(*newptstat), M_SUBPROC, M_WAITOK);

	p->p_tid = alloctid();

	LIST_INSERT_HEAD(&allproc, p, p_list);
	LIST_INSERT_HEAD(TIDHASH(p->p_tid), p, p_hash);
	LIST_INSERT_HEAD(PIDHASH(pr->ps_pid), pr, ps_hash);
	LIST_INSERT_AFTER(curpr, pr, ps_pglist);
	LIST_INSERT_HEAD(&curpr->ps_children, pr, ps_sibling);

	if (pr->ps_flags & PS_TRACED) {
		pr->ps_oppid = curpr->ps_pid;
		if (pr->ps_pptr != curpr->ps_pptr)
			proc_reparent(pr, curpr->ps_pptr);

		/*
		 * Set ptrace status.
		 */
		if (newptstat != NULL) {
			pr->ps_ptstat = newptstat;
			newptstat = NULL;
			curpr->ps_ptstat->pe_report_event = PTRACE_FORK;
			pr->ps_ptstat->pe_report_event = PTRACE_FORK;
			curpr->ps_ptstat->pe_other_pid = pr->ps_pid;
			pr->ps_ptstat->pe_other_pid = curpr->ps_pid;
		}
	}

	/*
	 * For new processes, set accounting bits and mark as complete.
	 */
	getnanotime(&pr->ps_start);
	pr->ps_acflag = AFORK;
	atomic_clearbits_int(&pr->ps_flags, PS_EMBRYO);

	if ((flags & FORK_IDLE) == 0)
		fork_thread_start(p, curp, flags);
	else
		p->p_cpu = arg;

	free(newptstat, M_SUBPROC, sizeof(*newptstat));

	/*
	 * Notify any interested parties about the new process.
	 */
	KNOTE(&curpr->ps_klist, NOTE_FORK | pr->ps_pid);

	/*
	 * Update stats now that we know the fork was successful.
	 */
	uvmexp.forks++;
	if (flags & FORK_PPWAIT)
		uvmexp.forks_ppwait++;
	if (flags & FORK_SHAREVM)
		uvmexp.forks_sharevm++;

	/*
	 * Pass a pointer to the new process to the caller.
	 */
	if (rnewprocp != NULL)
		*rnewprocp = p;

	/*
	 * Preserve synchronization semantics of vfork.  If waiting for
	 * child to exec or exit, set PS_PPWAIT on child and PS_ISPWAIT
	 * on ourselves, and sleep on our process for the latter flag
	 * to go away.
	 * XXX Need to stop other rthreads in the parent
	 */
	if (flags & FORK_PPWAIT)
		while (curpr->ps_flags & PS_ISPWAIT)
			tsleep(curpr, PWAIT, "ppwait", 0);

	/*
	 * If we're tracing the child, alert the parent too.
	 */
	if ((flags & FORK_PTRACE) && (curpr->ps_flags & PS_TRACED))
		psignal(curp, SIGTRAP);

	/*
	 * Return child pid to parent process
	 */
	if (retval != NULL) {
		retval[0] = pr->ps_pid;
		retval[1] = 0;
	}
	return (0);
}

int
thread_fork(struct proc *curp, void *stack, void *tcb, pid_t *tidptr,
    register_t *retval)
{
	struct process *pr = curp->p_p;
	struct proc *p;
	pid_t tid;
	vaddr_t uaddr;
	int error;

	if (stack == NULL)
		return EINVAL;

	if ((error = fork_check_maxthread(curp->p_ucred->cr_ruid)))
		return error;

	uaddr = uvm_uarea_alloc();
	if (uaddr == 0) {
		nthreads--;
		return ENOMEM;
	}

	/*
	 * From now on, we're committed to the fork and cannot fail.
	 */
	p = thread_new(curp, uaddr);
	atomic_setbits_int(&p->p_flag, P_THREAD);
	sigstkinit(&p->p_sigstk);

	/* other links */
	p->p_p = pr;
	pr->ps_refcnt++;

	/* local copies */
	p->p_fd		= pr->ps_fd;
	p->p_vmspace	= pr->ps_vmspace;

	/*
	 * Finish creating the child thread.  cpu_fork() will copy
	 * and update the pcb and make the child ready to run.  The
	 * child will exit directly to user mode via child_return()
	 * on its first time slice and will not return here.
	 */
	cpu_fork(curp, p, stack, tcb, child_return, p);

	p->p_tid = alloctid();

	LIST_INSERT_HEAD(&allproc, p, p_list);
	LIST_INSERT_HEAD(TIDHASH(p->p_tid), p, p_hash);
	TAILQ_INSERT_TAIL(&pr->ps_threads, p, p_thr_link);

	/*
	 * if somebody else wants to take us to single threaded mode,
	 * count ourselves in.
	 */
	if (pr->ps_single) {
		pr->ps_singlecount++;
		atomic_setbits_int(&p->p_flag, P_SUSPSINGLE);
	}

	/*
	 * Return tid to parent thread and copy it out to userspace
	 */
	retval[0] = tid = p->p_tid + THREAD_PID_OFFSET;
	retval[1] = 0;
	if (tidptr != NULL) {
		if (copyout(&tid, tidptr, sizeof(tid)))
			psignal(curp, SIGSEGV);
	}

	fork_thread_start(p, curp, 0);

	/*
	 * Update stats now that we know the fork was successful.
	 */
	forkstat.cnttfork++;
	uvmexp.forks++;
	uvmexp.forks_sharevm++;

	return 0;
}


/* Find an unused tid */
pid_t
alloctid(void)
{
	pid_t tid;

	do {
		/* (0 .. TID_MASK+1] */
		tid = 1 + (arc4random() & TID_MASK);
	} while (tfind(tid) != NULL);

	return (tid);
}

/*
 * Checks for current use of a pid, either as a pid or pgid.
 */
pid_t oldpids[128];
int
ispidtaken(pid_t pid)
{
	uint32_t i;

	for (i = 0; i < nitems(oldpids); i++)
		if (pid == oldpids[i])
			return (1);

	if (prfind(pid) != NULL)
		return (1);
	if (pgfind(pid) != NULL)
		return (1);
	if (zombiefind(pid) != NULL)
		return (1);
	return (0);
}

/* Find an unused pid */
pid_t
allocpid(void)
{
	static pid_t lastpid;
	pid_t pid;

	if (!randompid) {
		/* only used early on for system processes */
		pid = ++lastpid;
	} else {
		/* Find an unused pid satisfying lastpid < pid <= PID_MAX */
		do {
			pid = arc4random_uniform(PID_MAX - lastpid) + 1 +
			    lastpid;
		} while (ispidtaken(pid));
	}

	return pid;
}

void
freepid(pid_t pid)
{
	static uint32_t idx;

	oldpids[idx++ % nitems(oldpids)] = pid;
}

#if defined(MULTIPROCESSOR)
/*
 * XXX This is a slight hack to get newly-formed processes to
 * XXX acquire the kernel lock as soon as they run.
 */
void
proc_trampoline_mp(void)
{
	SCHED_ASSERT_LOCKED();
	__mp_unlock(&sched_lock);
	spl0();
	SCHED_ASSERT_UNLOCKED();
	KERNEL_ASSERT_UNLOCKED();

	KERNEL_LOCK();
}
#endif
@


1.194
log
@Delete the obsolete fork/exec/exit emulation hooks.

ok mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.193 2017/01/24 00:58:55 mpi Exp $	*/
a77 1
void tfork_child_return(void *);
d82 3
a84 1
void process_new(struct proc *, struct process *, int);
d105 1
a105 1
	return (fork1(p, flags, NULL, 0, fork_return, NULL, retval, NULL));
d111 2
a112 2
	return (fork1(p, FORK_VFORK|FORK_PPWAIT, NULL, 0, NULL,
	    NULL, retval, NULL));
a123 1
	int flags;
d127 1
a127 1
		return (EINVAL);
d129 1
a129 1
		return (error);
d135 2
a136 5
	flags = FORK_TFORK | FORK_THREAD | FORK_SIGHAND | FORK_SHAREVM
	    | FORK_SHAREFILES;

	return (fork1(p, flags, param.tf_stack, param.tf_tid,
	    tfork_child_return, param.tf_tcb, retval, NULL));
d139 5
a143 2
void
tfork_child_return(void *arg)
d145 22
a166 1
	struct proc *p = curproc;
d168 8
a175 2
	TCB_SET(p, arg);
	child_return(p);
d205 1
a205 1
void
d276 2
d284 1
a284 3
fork1(struct proc *curp, int flags, void *stack, pid_t *tidptr,
    void (*func)(void *), void *arg, register_t *retval,
    struct proc **rnewprocp)
a285 20
	struct process *curpr = curp->p_p;
	struct process *pr;
	struct proc *p;
	uid_t uid;
	struct vmspace *vm;
	int count;
	vaddr_t uaddr;
	int s;
	struct  ptrace_state *newptstat = NULL;

	/* sanity check some flag combinations */
	if (flags & FORK_THREAD) {
		if ((flags & FORK_SHAREFILES) == 0 ||
		    (flags & FORK_SIGHAND) == 0 ||
		    (flags & FORK_SYSTEM) != 0)
			return (EINVAL);
	}
	if (flags & FORK_SIGHAND && (flags & FORK_SHAREVM) == 0)
		return (EINVAL);

a294 1
	uid = curp->p_ucred->cr_ruid;
d300 1
a300 1
		return (EAGAIN);
d304 48
a351 11
	if ((flags & FORK_THREAD) == 0) {
		if ((nprocesses >= maxprocess - 5 && uid != 0) ||
		    nprocesses >= maxprocess) {
			static struct timeval lasttfm;

			if (ratecheck(&lasttfm, &fork_tfmrate))
				tablefull("process");
			nthreads--;
			return (EAGAIN);
		}
		nprocesses++;
d353 10
a362 12
		/*
		 * Increment the count of processes running with
		 * this uid.  Don't allow a nonprivileged user to
		 * exceed their current limit.
		 */
		count = chgproccnt(uid, 1);
		if (uid != 0 && count > curp->p_rlimit[RLIMIT_NPROC].rlim_cur) {
			(void)chgproccnt(uid, -1);
			nprocesses--;
			nthreads--;
			return (EAGAIN);
		}
d367 2
a368 4
		if ((flags & FORK_THREAD) == 0) {
			(void)chgproccnt(uid, -1);
			nprocesses--;
		}
d376 2
a378 30
	/* Allocate new proc. */
	p = pool_get(&proc_pool, PR_WAITOK);

	p->p_stat = SIDL;			/* protect against others */
	p->p_flag = 0;

	/*
	 * Make a proc table entry for the new process.
	 * Start by zeroing the section of proc that is zero-initialized,
	 * then copy the section that is copied directly from the parent.
	 */
	memset(&p->p_startzero, 0,
	    (caddr_t)&p->p_endzero - (caddr_t)&p->p_startzero);
	memcpy(&p->p_startcopy, &curp->p_startcopy,
	    (caddr_t)&p->p_endcopy - (caddr_t)&p->p_startcopy);
	crhold(p->p_ucred);

	/*
	 * Initialize the timeouts.
	 */
	timeout_set(&p->p_sleep_to, endtsleep, p);

	if (flags & FORK_THREAD) {
		atomic_setbits_int(&p->p_flag, P_THREAD);
		p->p_p = pr = curpr;
		pr->ps_refcnt++;
	} else {
		process_new(p, curpr, flags);
		pr = p->p_p;
	}
d394 1
a394 1
	if ((flags & FORK_THREAD) == 0 && curpr->ps_traceflag & KTRFAC_INHERIT)
a399 12
	 * set priority of child to be that of parent
	 * XXX should move p_estcpu into the region of struct proc which gets
	 * copied.
	 */
	scheduler_fork_hook(curp, p);

	if (flags & FORK_THREAD)
		sigstkinit(&p->p_sigstk);

	p->p_addr = (struct user *)uaddr;

	/*
d407 1
a407 1
	cpu_fork(curp, p, stack, 0, func ? func : child_return, arg ? arg : p);
a416 2
	} else if (flags & FORK_TFORK) {
		forkstat.cnttfork++;
a418 1
		forkstat.sizkthread += vm->vm_dsize + vm->vm_ssize;
d428 9
a436 24
	if ((flags & FORK_THREAD) == 0) {
		LIST_INSERT_HEAD(PIDHASH(pr->ps_pid), pr, ps_hash);
		LIST_INSERT_AFTER(curpr, pr, ps_pglist);
		LIST_INSERT_HEAD(&curpr->ps_children, pr, ps_sibling);

		if (pr->ps_flags & PS_TRACED) {
			pr->ps_oppid = curpr->ps_pid;
			if (pr->ps_pptr != curpr->ps_pptr)
				proc_reparent(pr, curpr->ps_pptr);

			/*
			 * Set ptrace status.
			 */
			if (flags & FORK_FORK) {
				pr->ps_ptstat = newptstat;
				newptstat = NULL;
				curpr->ps_ptstat->pe_report_event = PTRACE_FORK;
				pr->ps_ptstat->pe_report_event = PTRACE_FORK;
				curpr->ps_ptstat->pe_other_pid = pr->ps_pid;
				pr->ps_ptstat->pe_other_pid = curpr->ps_pid;
			}
		}
	} else {
		TAILQ_INSERT_TAIL(&pr->ps_threads, p, p_thr_link);
d438 1
a438 2
		 * if somebody else wants to take us to single threaded mode,
		 * count ourselves in.
d440 7
a446 3
		if (pr->ps_single) {
			curpr->ps_singlecount++;
			atomic_setbits_int(&p->p_flag, P_SUSPSINGLE);
a449 7
	if (tidptr != NULL) {
		pid_t	tid = p->p_tid + THREAD_PID_OFFSET;

		if (copyout(&tid, tidptr, sizeof(tid)))
			psignal(curp, SIGSEGV);
	}

d453 3
a455 5
	if ((flags & FORK_THREAD) == 0) {
		getnanotime(&pr->ps_start);
		pr->ps_acflag = AFORK;
		atomic_clearbits_int(&pr->ps_flags, PS_EMBRYO);
	}
d457 3
a459 10
	/*
	 * Make child runnable and add to run queue.
	 */
	if ((flags & FORK_IDLE) == 0) {
		SCHED_LOCK(s);
		p->p_stat = SRUN;
		p->p_cpu = sched_choosecpu_fork(curp, flags);
		setrunqueue(p);
		SCHED_UNLOCK(s);
	} else
d462 1
a462 2
	if (newptstat)
		free(newptstat, M_SUBPROC, sizeof(*newptstat));
d467 1
a467 2
	if ((flags & FORK_THREAD) == 0)
		KNOTE(&curpr->ps_klist, NOTE_FORK | pr->ps_pid);
d502 1
a502 2
	 * Return child pid to parent process,
	 * marking us as parent via retval[1].
d505 1
a505 2
		retval[0] = (flags & FORK_THREAD) == 0 ? pr->ps_pid :
		    (p->p_tid + THREAD_PID_OFFSET);
d510 83
@


1.193
log
@Rename pfind(9) into tfind(9) to reflect that it deals with threads.

While here document prfind(9.

with and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.192 2016/11/07 00:26:32 guenther Exp $	*/
a396 6

	/*
	 * If emulation has thread fork hook, call it now.
	 */
	if (pr->ps_emul->e_proc_fork)
		(*pr->ps_emul->e_proc_fork)(p, curp);
@


1.192
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.191 2016/10/22 02:55:36 guenther Exp $	*/
d562 1
a562 1
	} while (pfind(tid) != NULL);
@


1.191
log
@Adjust allocpid() to take into account lastpid

ok jsing@@ kettensi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.190 2016/10/15 05:09:01 guenther Exp $	*/
d79 3
a81 1
int pidtaken(pid_t);
d196 1
d434 1
a434 1
	p->p_pid = allocpid();
d437 1
a437 1
	LIST_INSERT_HEAD(PIDHASH(p->p_pid), p, p_hash);
d439 1
d473 1
a473 1
		pid_t	pid = p->p_pid + THREAD_PID_OFFSET;
d475 1
a475 1
		if (copyout(&pid, tidptr, sizeof(pid)))
d507 1
a507 1
		KNOTE(&curpr->ps_klist, NOTE_FORK | p->p_pid);
d546 2
a547 2
		retval[0] = p->p_pid +
		    (flags & FORK_THREAD ? THREAD_PID_OFFSET : 0);
d553 14
d580 1
a580 1
	if (pfind(pid) != NULL)
@


1.190
log
@Process groups can't be removed if a zombie process is in them, so
ispidtaken() can rely on pgfind() for all pgrp checks and can simply
use zombiefind() for the zombie check

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.189 2016/09/03 14:29:05 jca Exp $	*/
d571 1
a571 1
/* Find an unused pid satisfying 1 <= lastpid <= PID_MAX */
d582 1
d584 2
a585 1
			pid = 1 + arc4random_uniform(PID_MAX);
@


1.189
log
@Inherit PS_WXNEEDED in forked processes.

Issue noticed when debugging lang/sbcl.

ok deraadt@@ guenther@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.188 2016/08/31 14:15:07 tom Exp $	*/
a556 1
	struct process *pr;
d566 2
a567 5
	LIST_FOREACH(pr, &zombprocess, ps_list) {
		if (pr->ps_pid == pid ||
		    (pr->ps_pgrp && pr->ps_pgrp->pg_id == pid))
			return (1);
	}
@


1.188
log
@proc_trampoline_mp hasn't needed curproc since 2011

ok guenther@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.187 2016/04/25 20:18:31 tedu Exp $	*/
d204 2
a205 1
	pr->ps_flags = parent->ps_flags & (PS_SUGID | PS_SUGIDEXEC | PS_PLEDGE);
@


1.187
log
@remove systrace remnants
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.186 2016/04/25 20:00:33 tedu Exp $	*/
a608 4
	struct proc *p;

	p = curproc;

@


1.186
log
@boom goes the dynamite
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.185 2016/03/11 19:10:14 tedu Exp $	*/
a263 3
#if NSYSTRACE > 0
	void *newstrp = NULL;
#endif
@


1.185
log
@increase size of oldpids to 128 to prevent mod bias when idx wraps.
from Michal Mazurek
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.184 2015/10/09 01:10:27 deraadt Exp $	*/
a65 3
#include "systrace.h"
#include <dev/systrace.h>

a431 4
#if NSYSTRACE > 0
	if (ISSET(curp->p_flag, P_SYSTRACE))
		newstrp = systrace_getproc();
#endif
a468 5

#if NSYSTRACE > 0
	if (newstrp)
		systrace_fork(curp, p, newstrp);
#endif
@


1.184
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.183 2015/09/11 08:22:31 guenther Exp $	*/
d566 1
a566 1
pid_t oldpids[100];
@


1.183
log
@Only include <sys/tame.h> in the .c files that need it

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.182 2015/08/22 20:18:49 deraadt Exp $	*/
d61 1
a61 1
#include <sys/tame.h>
d207 1
a207 1
	pr->ps_flags = parent->ps_flags & (PS_SUGID | PS_SUGIDEXEC | PS_TAMED);
d228 2
a229 2
	if (pr->ps_tamepaths)
		pr->ps_tamepaths->wl_ref++;
@


1.182
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.181 2015/07/19 02:35:35 deraadt Exp $	*/
d61 1
@


1.181
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.180 2015/03/14 07:33:42 jsg Exp $	*/
d226 3
@


1.180
log
@add sys/atomic.h back for membar_* needed for at least armv7
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.179 2015/03/14 03:38:50 jsg Exp $	*/
d206 1
a206 1
	pr->ps_flags = parent->ps_flags & (PS_SUGID | PS_SUGIDEXEC);
@


1.179
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.178 2015/02/10 05:28:18 guenther Exp $	*/
d60 1
@


1.178
log
@Factor out the common bits of process_new() and main()'s code for
setting up process0, 'cause I'm sick of forgetting to update main()
when touching process_new()

ok blambert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.177 2014/11/18 02:37:31 tedu Exp $	*/
a59 1
#include <sys/atomic.h>
@


1.177
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.176 2014/11/03 21:28:35 tedu Exp $	*/
a95 1
/*ARGSUSED*/
a106 1
/*ARGSUSED*/
d152 24
a183 7
	pr->ps_mainproc = p;

	TAILQ_INIT(&pr->ps_threads);
	TAILQ_INSERT_TAIL(&pr->ps_threads, p, p_thr_link);
	pr->ps_pptr = parent;
	LIST_INIT(&pr->ps_children);
	pr->ps_refcnt = 1;
d195 2
d198 1
a198 3
	pr->ps_ucred = p->p_ucred;
	crhold(pr->ps_ucred);
	KASSERT(p->p_ucred->cr_ref >= 3); /* fork thr, new thr, new process */
a205 2
	timeout_set(&pr->ps_realit_to, realitexpire, pr);

a208 2

	p->p_p = pr;
@


1.176
log
@include sys/unistd.h where needed instead of indirect reliance. ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.175 2014/11/03 03:08:00 deraadt Exp $	*/
a56 1
#include <dev/rndvar.h>
@


1.175
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.174 2014/09/08 01:47:06 guenther Exp $	*/
d62 1
@


1.174
log
@Delete procfs; it's always had races and is now unused: no one noticed for
months that I broke it before the 5.5 release.

confirmed as not being required by ports by sthen@@, ajacoutot@@, dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.173 2014/07/13 15:46:21 uebayasi Exp $	*/
d496 1
a496 1
		free(newptstat, M_SUBPROC, 0);
@


1.173
log
@KERNEL_ASSERT_LOCKED(9): Assertion for kernel lock (Rev. 3)

This adds a new assertion macro, KERNEL_ASSERT_LOCKED(), to assert that
kernel_lock is held.  In the long process of removing kernel_lock, there will
be a lot (hundreds or thousands) of use of this; virtually almost all functions
in !MP-safe subsystems should have this assertion.  Thus this assertion should
have a short, good name.

Not only that "KERNEL_ASSERT_LOCKED" is consistent with other KERNEL_* and
SCHED_ASSERT_LOCKED() macros.

Input from dlg@@ guenther@@ kettenis@@.

OK dlg@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d186 1
a186 1
	/* bump references to the text vnode (for procfs) */
@


1.172
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.171 2014/07/11 08:20:42 guenther Exp $	*/
d617 1
a617 1
	KASSERT(__mp_lock_held(&kernel_lock) == 0);
@


1.171
log
@Use membar_producer() to force visibility instead of misusing
atomic_setbits_int()

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.170 2014/07/08 17:19:25 deraadt Exp $	*/
d496 1
a496 1
		free(newptstat, M_SUBPROC);
@


1.170
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.169 2014/07/07 05:31:42 matthew Exp $	*/
d61 1
d225 5
a229 5
	/*
	 * Mark as embryo to protect against others.
	 * Done with atomic_* to force visibility of all of the above flags
	 */
	atomic_setbits_int(&pr->ps_flags, PS_EMBRYO);
@


1.169
log
@fork1: FORK_THREAD requires FORK_SHAREFILES

Now that file descriptor tables have moved from a per-thread resource
to per-process, it's impossible to fork a thread without sharing the
file descriptor table.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.168 2014/07/04 05:58:30 guenther Exp $	*/
d56 1
@


1.168
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.167 2014/05/15 03:52:25 guenther Exp $	*/
d256 3
a258 1
		if ((flags & FORK_SIGHAND) == 0 || (flags & FORK_SYSTEM) != 0)
@


1.167
log
@Move from struct proc to process the reference-count-holding pointers
to the process's vmspace and filedescs.  struct proc continues to
keep copies of the pointers, copying them on fork, clearing them
on exit, and (for vmspace) refreshing on exec.
Also, make uvm_swapout_threads() thread aware, eliminating p_swtime
in kernel.

particular testing by ajacoutot@@ and sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.166 2014/05/06 11:50:14 mpi Exp $	*/
d192 2
a193 3
	if (parent->ps_session->s_ttyvp != NULL &&
	    parent->ps_flags & PS_CONTROLT)
		atomic_setbits_int(&pr->ps_flags, PS_CONTROLT);
d216 2
a217 2
	if ((flags & FORK_PTRACE) && (parent->ps_flags & PS_TRACED))
		atomic_setbits_int(&pr->ps_flags, PS_TRACED);
d219 1
a219 1
		atomic_setbits_int(&pr->ps_flags, PS_NOZOMBIE);
d221 7
a227 1
		atomic_setbits_int(&pr->ps_flags, PS_SYSTEM);
d471 1
a471 1
	 * For new processes, set accounting bits
d476 1
@


1.166
log
@Include <sys/vmmeter.h> directly instead of relying on it being
pulled by <uvm/uvm_extern.h> and turn uvm_total() into a private
function.

The preferred way to get memory stats is through the VM_UVMEXP
sysctl(3) since VM_METER is just a wrapper on top of it.  In the
kernel, use `uvmexp' directly instead of uvm_total().

This change does not remove <sys/vmmeter.h> from <uvm/uvm_extern.h>
to give some more time to port maintainers to fix their ports.

ok guenther@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.165 2014/05/04 05:03:26 guenther Exp $	*/
d199 2
a200 1
	 * Create signal actions for the child process.
d202 4
d210 4
d346 2
a350 9
	/*
	 * Duplicate sub-structures as needed.
	 * Increase reference counts on shared objects.
	 */
	if (flags & FORK_SHAREFILES)
		p->p_fd = fdshare(curp);
	else
		p->p_fd = fdcopy(curp);

d385 6
a390 2
	 * Finish creating the child process.  It will return through a
	 * different path later.
d392 1
a392 2
	uvm_fork(curp, p, ((flags & FORK_SHAREVM) ? TRUE : FALSE), stack,
	    0, func ? func : child_return, arg ? arg : p);
d394 1
a394 1
	vm = p->p_vmspace;
@


1.165
log
@Add PS_SYSTEM, the process-level mirror of the thread-level P_SYSTEM,
and FORK_SYSTEM as a flag to set them.  This eliminates needing to
peek into other processes threads in various places.  Inspired by NetBSD

ok miod@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.164 2014/05/03 22:44:36 guenther Exp $	*/
d51 1
@


1.164
log
@Move the u-area allocation and pmap-magic logic to its own function
uvm_uarea_alloc()

function name from NetBSD; arm testing by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.163 2014/04/18 11:51:17 guenther Exp $	*/
d211 2
d241 1
a241 1
		if ((flags & FORK_SIGHAND) == 0)
d336 2
@


1.163
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.162 2014/03/30 21:54:48 guenther Exp $	*/
d290 1
a290 4
	uaddr = uvm_km_kmemalloc_pla(kernel_map, uvm.kernel_object, USPACE,
	    USPACE_ALIGN, UVM_KMF_ZERO,
	    no_constraint.ucr_low, no_constraint.ucr_high,
	    0, 0, USPACE/PAGE_SIZE);
@


1.162
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.161 2014/03/28 17:57:11 mpi Exp $	*/
d178 1
a178 1
	pr->ps_ucred = parent->ps_ucred;
d180 1
d322 1
@


1.161
log
@Reduce uvm include madness.  Use <uvm/uvm_extern.h> instead of
<uvm/uvm.h> if possible and remove double inclusions.

ok beck@@, mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.160 2014/03/26 05:23:42 guenther Exp $	*/
d178 2
a179 3
	pr->ps_cred = pool_get(&pcred_pool, PR_WAITOK);
	memcpy(pr->ps_cred, parent->ps_cred, sizeof(*pr->ps_cred));
	crhold(parent->ps_cred->pc_ucred);
d253 1
a253 1
	uid = curp->p_cred->p_ruid;
@


1.160
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.159 2014/03/22 06:05:45 guenther Exp $	*/
d65 1
a65 2
#include <uvm/uvm_extern.h>
#include <uvm/uvm_map.h>
@


1.159
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.158 2014/02/12 05:47:36 guenther Exp $	*/
d373 1
a373 1
	 * If emulation has process fork hook, call it now.
d375 2
a376 2
	if (p->p_emul->e_proc_fork)
		(*p->p_emul->e_proc_fork)(p, curp);
@


1.158
log
@Eliminate the exit sig handling, which was only invokable via the
Linux-compat clone() syscall when *not* using CLONE_THREAD.  pirofti@@
confirms Opera runs in compat without this, so out it goes; one less hair
to choke on in kern_exit.c

ok tedu@@ pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.157 2014/02/10 01:38:07 guenther Exp $	*/
d81 1
a81 1
void process_new(struct proc *, struct process *);
d155 1
a155 1
process_new(struct proc *p, struct process *parent)
d198 15
a312 10
	p->p_xstat = 0;

	if (flags & FORK_THREAD) {
		atomic_setbits_int(&p->p_flag, P_THREAD);
		p->p_p = pr = curpr;
		pr->ps_refcnt++;
	} else {
		process_new(p, curpr);
		pr = p->p_p;
	}
d329 9
a341 9
	if ((flags & FORK_THREAD) == 0) {
		if (curpr->ps_flags & PS_PROFIL)
			startprofclock(pr);
		if ((flags & FORK_PTRACE) && (curpr->ps_flags & PS_TRACED))
			atomic_setbits_int(&pr->ps_flags, PS_TRACED);
		if (flags & FORK_NOZOMBIE)
			atomic_setbits_int(&pr->ps_flags, PS_NOZOMBIE);
	}

a368 7
	/*
	 * Create signal actions for the child process.
	 */
	if (flags & FORK_SIGHAND)
		p->p_sigacts = sigactsshare(curp);
	else
		p->p_sigacts = sigactsinit(curp);
@


1.157
log
@arc4random_uniform() returns a value strictly less than its argument; fix
arithmetic so that PID_MAX can be reached.

ok otto@@ zhuk@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.156 2014/01/20 21:19:28 guenther Exp $	*/
d103 1
a103 2
	return (fork1(p, SIGCHLD, flags, NULL, 0,
	    fork_return, NULL, retval, NULL));
d110 1
a110 1
	return (fork1(p, SIGCHLD, FORK_VFORK|FORK_PPWAIT, NULL, 0, NULL,
d138 1
a138 1
	return (fork1(p, 0, flags, param.tf_stack, param.tf_tid,
d206 1
a206 1
fork1(struct proc *curp, int exitsig, int flags, void *stack, pid_t *tidptr,
a296 1
	p->p_exitsig = exitsig;
@


1.156
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.155 2014/01/20 03:23:42 guenther Exp $	*/
d573 1
a573 1
			pid = 1 + arc4random_uniform(PID_MAX - 1);
@


1.155
log
@Move p_textvp from struct proc to struct process so that the exit code
can be further simplified.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.154 2013/10/08 03:50:07 guenther Exp $	*/
d137 1
a137 1
	    | FORK_NOZOMBIE | FORK_SHAREFILES;
d198 3
d226 1
a226 2
		if ((flags & (FORK_SIGHAND | FORK_NOZOMBIE)) !=
		    (FORK_SIGHAND | FORK_NOZOMBIE))
d335 2
a347 2
	if (flags & FORK_NOZOMBIE)
		atomic_setbits_int(&p->p_flag, P_NOZOMBIE);
d543 1
a543 1
	struct proc *p;
d553 3
a555 3
	LIST_FOREACH(p, &zombproc, p_list) {
		if (p->p_pid == pid ||
		    (p->p_p->ps_pgrp && p->p_p->ps_pgrp->pg_id == pid))
@


1.154
log
@Fix delivery of SIGPROF and SIGVTALRM to threaded processes by having
hardclock() set a flag on the running thread and force AST processing,
and then have the thread signal itself from userret().

idea and flag names from FreeBSD
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.153 2013/08/14 05:26:14 guenther Exp $	*/
d185 5
a333 5

	/* bump references to the text vnode (for procfs) */
	p->p_textvp = curp->p_textvp;
	if (p->p_textvp)
		vref(p->p_textvp);
@


1.153
log
@The last user of the old __tfork() was updated to the current one,
so COMPAT_O51 can go.  The complete ABI role means COMPAT_O53 can
be removed as well.

ok jsing@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.152 2013/06/11 13:00:31 tedu Exp $	*/
a185 2
	timeout_set(&pr->ps_virt_to, virttimer_trampoline, pr);
	timeout_set(&pr->ps_prof_to, proftimer_trampoline, pr);
@


1.152
log
@convert some easy bcopy to memcpy and clean up fdexpand a bit.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.151 2013/06/06 13:09:37 haesbaert Exp $	*/
a141 25

#ifdef COMPAT_O51
int
compat_o51_sys___tfork(struct proc *p, void *v, register_t *retval)
{
	struct compat_o51_sys___tfork_args /* {
		syscallarg(struct __tfork51) *param;
	} */ *uap = v;
	struct __tfork51 param;
	int flags;
	int error;

	if ((error = copyin(SCARG(uap, param), &param, sizeof(param))))
		return (error);

	if (param.tf_flags != 0)
		return (EINVAL);

	flags = FORK_TFORK | FORK_THREAD | FORK_SIGHAND | FORK_SHAREVM
	    | FORK_NOZOMBIE | FORK_SHAREFILES;

	return (fork1(p, 0, flags, NULL, param.tf_tid, tfork_child_return,
	    param.tf_tcb, retval, NULL));
}
#endif
@


1.151
log
@Prevent idle thread from being stolen on startup.

There is a race condition which might trigger a case where two cpus try
to run the same idle thread.

The problem arises when one cpu steals the idle proc of another cpu and
this other cpu ends up running the idle thread via spc->spc_idleproc,
resulting in two cpus trying to cpu_switchto(idleX).

On startup, idle procs are scaterred around different runqueues, the
decision for scheduling is:

1 look at my runqueue.
2 if empty, look at other dudes runqueue.
3 if empty, select idle proc via spc->spc_idleproc.

The problem is that cpu0's idle0 might be running on cpu1 due to step 1
or 2 and cpu0 hits step 3.

So cpu0 will select idle0, while cpu1 is in fact running it already.

The solution is to never place idle on a runqueue, therefore being
only selectable through spc->spc_idleproc.

This race can be more easily triggered on a HT cpu on virtualized
environments, where the guest more often than not doesn't have the cpu
for itself, so timing gets shuffled.

ok tedu@@ guenther@@
go ahead after t2k13 deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.150 2013/06/05 00:53:26 tedu Exp $	*/
d199 4
a202 4
	bzero(&pr->ps_startzero,
	    (unsigned) ((caddr_t)&pr->ps_endzero - (caddr_t)&pr->ps_startzero));
	bcopy(&parent->ps_startcopy, &pr->ps_startcopy,
	    (unsigned) ((caddr_t)&pr->ps_endcopy - (caddr_t)&pr->ps_startcopy));
d206 1
a206 1
	bcopy(parent->ps_cred, pr->ps_cred, sizeof(*pr->ps_cred));
d336 4
a339 4
	bzero(&p->p_startzero,
	    (unsigned) ((caddr_t)&p->p_endzero - (caddr_t)&p->p_startzero));
	bcopy(&curp->p_startcopy, &p->p_startcopy,
	    (unsigned) ((caddr_t)&p->p_endcopy - (caddr_t)&p->p_startcopy));
@


1.150
log
@factor out pid allocation to functions. add a small cache of recently
exited pids that won't get recycled.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.149 2013/06/03 22:35:15 guenther Exp $	*/
d498 8
a505 5
	SCHED_LOCK(s);
	p->p_stat = SRUN;
	p->p_cpu = sched_choosecpu_fork(curp, flags);
	setrunqueue(p);
	SCHED_UNLOCK(s);
@


1.149
log
@When creating a thread, don't add it to the process's thread list
until it's fully built, so that it can't get a signal from
realitexpire(), as seen by sthen@@ and espie@@ in ports builds.

Exact bits moved down worked out with tedu@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.148 2013/06/03 16:55:22 guenther Exp $	*/
a74 1
pid_t	lastpid;
d438 1
a438 5
	/* Find an unused pid satisfying 1 <= lastpid <= PID_MAX */
	do {
		lastpid = 1 + (randompid ? arc4random() : lastpid) % PID_MAX;
	} while (pidtaken(lastpid));
	p->p_pid = lastpid;
d560 1
d562 1
a562 1
pidtaken(pid_t pid)
d564 1
d567 4
d576 2
a577 1
		if (p->p_pid == pid || (p->p_p->ps_pgrp && p->p_p->ps_pgrp->pg_id == pid))
d581 27
@


1.148
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.147 2013/06/01 16:04:46 tedu Exp $	*/
a325 1
		TAILQ_INSERT_TAIL(&pr->ps_threads, p, p_thr_link);
a326 8
		/*
		 * if somebody else wants to take us to single threaded mode,
		 * count ourselves in.
		 */
		if (pr->ps_single) {
			curpr->ps_singlecount++;
			atomic_setbits_int(&p->p_flag, P_SUSPSINGLE);
		}
d467 10
@


1.147
log
@As found by kurt, there's a twisty race between exit1 and fork1
with threaded processes. Fix this by checking for an attempt to go
single threaded in fork1 and account for the new thread as well.
ok espie guenther kurt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.146 2013/04/06 03:44:34 tedu Exp $	*/
d495 1
a495 1
		getmicrotime(&pr->ps_start);
@


1.146
log
@rthreads are always enabled. remove the sysctl.
ok deraadt guenther kettenis matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.145 2013/03/14 21:38:22 tedu Exp $	*/
d328 8
@


1.145
log
@the 5.1 era tfork syscall claws its way out of the grave. we failed to
fully deprecate it (notably the go port was still using it as of 5.3)
so to give users a little more time to update, __tfork51 lives again.
okish deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.143 2012/11/19 09:26:08 guenther Exp $	*/
a245 2
		if (!rthreads_enabled)
			return (ENOTSUP);
@


1.144
log
@No longer need the 5.1 version of the __tfork syscall

ok deraadt@@
@
text
@d144 25
@


1.143
log
@If uvm_km_kmemalloc_pla() fails when just creating a thread (and not a
process), then don't decrement the total and per-user counts of processes.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.142 2012/08/02 03:18:48 guenther Exp $	*/
a142 25

#ifdef COMPAT_O51
int
compat_o51_sys___tfork(struct proc *p, void *v, register_t *retval)
{
	struct compat_o51_sys___tfork_args /* {
		syscallarg(struct __tfork51) *param;
	} */ *uap = v;
	struct __tfork51 param;
	int flags;
	int error;

	if ((error = copyin(SCARG(uap, param), &param, sizeof(param))))
		return (error);

	if (param.tf_flags != 0)
		return (EINVAL);

	flags = FORK_TFORK | FORK_THREAD | FORK_SIGHAND | FORK_SHAREVM
	    | FORK_NOZOMBIE | FORK_SHAREFILES;

	return (fork1(p, 0, flags, NULL, param.tf_tid, tfork_child_return,
	    param.tf_tcb, retval, NULL));
}
#endif
@


1.142
log
@Apply profiling to all threads instead of just the thread that called
profil() by moving P_PROFIL from proc->p_flag to process->ps_flags with
matching adjustment in fork1() and exit1()

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.141 2012/06/21 00:56:59 guenther Exp $	*/
d305 4
a308 2
		chgproccnt(uid, -1);
		nprocesses--;
@


1.141
log
@__tfork() needs to set the stack address of the new thread in the kernel,
so that it can't get a signal while still running on the parent thread's
stack.  Also, pass in sizeof(struct __tfork) to provide forward compat
when more members are added.  This is an ABI change, so switch syscall
numbers and bump lib majors this time.

ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.140 2012/05/10 05:01:23 guenther Exp $	*/
d352 6
a357 4
	if (curp->p_flag & P_PROFIL)
		startprofclock(p);
	if (flags & FORK_PTRACE)
		atomic_setbits_int(&pr->ps_flags, curpr->ps_flags & PS_TRACED);
@


1.140
log
@Only set a process's start time when starting the main thread.  There's
also no need to protect that and the setting of the AFORK accounting flag
with the scheduler lock.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.139 2012/04/13 16:37:51 kettenis Exp $	*/
d120 2
a121 1
		syscallarg(struct __tfork) *param;
d123 29
a151 1
	struct __tfork param;
d167 1
@


1.139
log
@First stab at making ptrace(2) usable for debugging multi-threaded programs.
It implements a full-stop model where all threads are stopped before handing
over control to the debugger.  Events are reported as before through wait(2);
you will have to call ptrace(PT_GET_PROCESS_STATE, ...) to find out which
thread hit the event.  Since this changes the size of struct ptrace_state,
you will have to recompile gdb.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.138 2012/04/12 12:33:03 deraadt Exp $	*/
d452 9
a460 1
	 * Make child runnable, set start time, and add to run queue.
a462 3
 	getmicrotime(&pr->ps_start);
	if ((flags & FORK_THREAD) == 0)
		pr->ps_acflag = AFORK;
@


1.138
log
@remove rfork(); ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.137 2012/04/12 10:11:41 mikeb Exp $	*/
d291 1
@


1.137
log
@move accounting flags to struct process; idea and ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.136 2012/04/10 15:50:52 guenther Exp $	*/
a116 41
sys_rfork(struct proc *p, void *v, register_t *retval)
{
	struct sys_rfork_args /* {
		syscallarg(int) flags;
	} */ *uap = v;

	int rforkflags;
	int flags;

	flags = FORK_RFORK;
	rforkflags = SCARG(uap, flags);

	if ((rforkflags & RFPROC) == 0)
		return (EINVAL);

	switch(rforkflags & (RFFDG|RFCFDG)) {
	case (RFFDG|RFCFDG):
		return EINVAL;
	case RFCFDG:
		flags |= FORK_CLEANFILES;
		break;
	case RFFDG:
		break;
	default:
		flags |= FORK_SHAREFILES;
		break;
	}

	if (rforkflags & RFNOWAIT)
		flags |= FORK_NOZOMBIE;

	if (rforkflags & RFMEM)
		flags |= FORK_SHAREVM;

	if (rforkflags & RFTHREAD)
		flags |= FORK_THREAD | FORK_SIGHAND | FORK_NOZOMBIE;

	return (fork1(p, SIGCHLD, flags, NULL, 0, NULL, NULL, retval, NULL));
}

int
a128 1
	/* XXX will supersede rfork at some point... */
d331 1
a331 3
	if (flags & FORK_CLEANFILES)
		p->p_fd = fdinit(curp);
	else if (flags & FORK_SHAREFILES)
a392 1
#if 0
a394 4
#endif
	} else if (flags & FORK_RFORK) {
		forkstat.cntrfork++;
		forkstat.sizrfork += vm->vm_dsize + vm->vm_ssize;
@


1.136
log
@Make the KERN_NPROCS and KERN_MAXPROC sysctl()s and the RLIMIT_NPROC rlimit
count processes instead of threads.  New sysctl()s KERN_NTHREADS and
KERN_MAXTHREAD count and limit threads.  The nprocs and maxproc kernel
variables are replaced by nprocess, maxprocess, nthreads, and maxthread.

ok tedu@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.135 2012/03/23 15:51:26 guenther Exp $	*/
d504 2
a505 1
	p->p_acflag = AFORK;
@


1.135
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.134 2012/02/20 22:23:39 guenther Exp $	*/
d72 2
a73 1
int	nprocs = 1;		/* process 0 */
d270 5
a274 2
	 * the last 5 processes to root. The variable nprocs is the current
	 * number of processes, maxproc is the limit.
d277 1
a277 1
	if ((nprocs >= maxproc - 5 && uid != 0) || nprocs >= maxproc) {
d284 1
a284 1
	nprocs++;
d286 24
a309 9
	/*
	 * Increment the count of procs running with this uid. Don't allow
	 * a nonprivileged user to exceed their current limit.
	 */
	count = chgproccnt(uid, 1);
	if (uid != 0 && count > curp->p_rlimit[RLIMIT_NPROC].rlim_cur) {
		(void)chgproccnt(uid, -1);
		nprocs--;
		return (EAGAIN);
d318 2
a319 1
		nprocs--;
@


1.134
log
@First steps for making ptrace work with rthreads:
 - move the P_TRACED and P_INEXEC flags, and p_oppid, p_ptmask, and
   p_ptstat member from struct proc to struct process
 - sort the PT_* requests into those that take a PID vs those that
   can also take a TID
 - stub in PT_GET_THREAD_FIRST and PT_GET_THREAD_NEXT

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.133 2011/12/14 07:32:16 guenther Exp $	*/
d222 4
a337 1
	timeout_set(&p->p_realit_to, realitexpire, p);
a341 1
	 * The p_stats and p_sigacts substructs are set in vm_fork.
a408 3
	timeout_set(&p->p_stats->p_virt_to, virttimer_trampoline, p);
	timeout_set(&p->p_stats->p_prof_to, proftimer_trampoline, p);

d483 1
a483 1
 	getmicrotime(&p->p_stats->p_start);
@


1.133
log
@Handle rthreads consistently in ktrace by moving the flags and vnode into
struct process; KTRFAC_ACTIVE becomes P_INKTR.  Also, save the credentials
used to open the file in sys_ktrace() and use them for all writes to the
vnode.

much feedback and ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.132 2011/11/22 23:20:19 joshe Exp $	*/
d88 1
a88 1
	if (p->p_flag & P_TRACED)
d101 1
a101 1
	if (p->p_ptmask & PTRACE_FORK)
d344 1
a344 1
		atomic_setbits_int(&p->p_flag, curp->p_flag & P_TRACED);
d430 1
a430 1
	if (p->p_flag & P_TRACED && flags & FORK_FORK)
a447 1
	}
d449 16
a464 16
	if (p->p_flag & P_TRACED) {
		p->p_oppid = curp->p_pid;
		if ((flags & FORK_THREAD) == 0 &&
		    pr->ps_pptr != curpr->ps_pptr)
			proc_reparent(pr, curpr->ps_pptr);

		/*
		 * Set ptrace status.
		 */
		if (flags & FORK_FORK) {
			p->p_ptstat = newptstat;
			newptstat = NULL;
			curp->p_ptstat->pe_report_event = PTRACE_FORK;
			p->p_ptstat->pe_report_event = PTRACE_FORK;
			curp->p_ptstat->pe_other_pid = p->p_pid;
			p->p_ptstat->pe_other_pid = curp->p_pid;
d529 1
a529 1
	if ((flags & FORK_PTRACE) && (curp->p_flag & P_TRACED))
@


1.132
log
@Move struct proc's sigaltstack struct from the zeroed area into the
copied area, and initialize it properly in the FORK_THREAD case.

This restores the behavior of a forked process inheriting its parent's
signal stack.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.131 2011/11/09 20:57:38 guenther Exp $	*/
d370 3
a372 5
	if (curp->p_traceflag & KTRFAC_INHERIT) {
		p->p_traceflag = curp->p_traceflag;
		if ((p->p_tracep = curp->p_tracep) != NULL)
			vref(p->p_tracep);
	}
@


1.131
log
@Change fork1() and kthread_create() to match the rest of the tree
and use curp vs p instead of p1 vs p2.  Add curpr and pr variables
for the respective struct processes.  Make sigactsshare() return
the shared sigacts intead of taking the struct proc to update.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.130 2011/11/05 23:02:37 guenther Exp $	*/
d391 2
@


1.130
log
@I had moved earlier the adding of processes to the pgrp and children lists
during the big rework at c2k10, but it's too early as signals can be posted
before the process is fully built.  Move those list adds back down to the
late stage they were before.

Problem seen on sebastia@@'s sparc.
ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.129 2011/10/15 23:35:29 guenther Exp $	*/
d81 1
a81 1
void process_new(struct proc *, struct proc *);
d193 1
a193 1
process_new(struct proc *newproc, struct proc *parentproc)
d195 1
a195 1
	struct process *pr, *parent;
d198 1
a198 2
	pr->ps_mainproc = newproc;
	parent = parentproc->p_p;
d201 1
a201 1
	TAILQ_INSERT_TAIL(&pr->ps_threads, newproc, p_thr_link);
d227 1
a227 1
	newproc->p_p = pr;
d234 1
a234 1
fork1(struct proc *p1, int exitsig, int flags, void *stack, pid_t *tidptr,
d238 3
a240 1
	struct proc *p2;
d268 1
a268 1
	uid = p1->p_cred->p_ruid;
d283 1
a283 1
	if (uid != 0 && count > p1->p_rlimit[RLIMIT_NPROC].rlim_cur) {
d304 1
a304 1
	p2 = pool_get(&proc_pool, PR_WAITOK);
d306 3
a308 3
	p2->p_stat = SIDL;			/* protect against others */
	p2->p_exitsig = exitsig;
	p2->p_flag = 0;
d311 4
a314 4
		atomic_setbits_int(&p2->p_flag, P_THREAD);
		p2->p_p = p1->p_p;
		TAILQ_INSERT_TAIL(&p2->p_p->ps_threads, p2, p_thr_link);
		p2->p_p->ps_refcnt++;
d316 2
a317 1
		process_new(p2, p1);
d325 4
a328 4
	bzero(&p2->p_startzero,
	    (unsigned) ((caddr_t)&p2->p_endzero - (caddr_t)&p2->p_startzero));
	bcopy(&p1->p_startcopy, &p2->p_startcopy,
	    (unsigned) ((caddr_t)&p2->p_endcopy - (caddr_t)&p2->p_startcopy));
d333 2
a334 2
	timeout_set(&p2->p_sleep_to, endtsleep, p2);
	timeout_set(&p2->p_realit_to, realitexpire, p2);
d341 2
a342 2
	if (p1->p_flag & P_PROFIL)
		startprofclock(p2);
d344 1
a344 1
		atomic_setbits_int(&p2->p_flag, p1->p_flag & P_TRACED);
d347 3
a349 3
	p2->p_textvp = p1->p_textvp;
	if (p2->p_textvp)
		vref(p2->p_textvp);
d352 1
a352 1
		p2->p_fd = fdinit(p1);
d354 1
a354 1
		p2->p_fd = fdshare(p1);
d356 1
a356 1
		p2->p_fd = fdcopy(p1);
d359 2
a360 2
		atomic_setbits_int(&p2->p_p->ps_flags, PS_PPWAIT);
		atomic_setbits_int(&p1->p_p->ps_flags, PS_ISPWAIT);
d363 1
a363 1
		atomic_setbits_int(&p2->p_flag, P_NOZOMBIE);
d370 4
a373 4
	if (p1->p_traceflag & KTRFAC_INHERIT) {
		p2->p_traceflag = p1->p_traceflag;
		if ((p2->p_tracep = p1->p_tracep) != NULL)
			vref(p2->p_tracep);
d382 1
a382 1
	scheduler_fork_hook(p1, p2);
d388 1
a388 1
		sigactsshare(p1, p2);
d390 1
a390 1
		p2->p_sigacts = sigactsinit(p1);
d395 2
a396 2
	if (p2->p_emul->e_proc_fork)
		(*p2->p_emul->e_proc_fork)(p2, p1);
d398 1
a398 1
	p2->p_addr = (struct user *)uaddr;
d404 2
a405 2
	uvm_fork(p1, p2, ((flags & FORK_SHAREVM) ? TRUE : FALSE), stack,
	    0, func ? func : child_return, arg ? arg : p2);
d407 2
a408 2
	timeout_set(&p2->p_stats->p_virt_to, virttimer_trampoline, p2);
	timeout_set(&p2->p_stats->p_prof_to, proftimer_trampoline, p2);
d410 1
a410 1
	vm = p2->p_vmspace;
d430 1
a430 1
	if (p2->p_flag & P_TRACED && flags & FORK_FORK)
d433 1
a433 1
	if (ISSET(p1->p_flag, P_SYSTRACE))
d441 1
a441 1
	p2->p_pid = lastpid;
d443 2
a444 2
	LIST_INSERT_HEAD(&allproc, p2, p_list);
	LIST_INSERT_HEAD(PIDHASH(p2->p_pid), p2, p_hash);
d446 2
a447 2
		LIST_INSERT_AFTER(p1->p_p, p2->p_p, ps_pglist);
		LIST_INSERT_HEAD(&p1->p_p->ps_children, p2->p_p, ps_sibling);
d450 2
a451 2
	if (p2->p_flag & P_TRACED) {
		p2->p_oppid = p1->p_pid;
d453 2
a454 2
		    p2->p_p->ps_pptr != p1->p_p->ps_pptr)
			proc_reparent(p2->p_p, p1->p_p->ps_pptr);
d460 1
a460 1
			p2->p_ptstat = newptstat;
d462 4
a465 4
			p1->p_ptstat->pe_report_event = PTRACE_FORK;
			p2->p_ptstat->pe_report_event = PTRACE_FORK;
			p1->p_ptstat->pe_other_pid = p2->p_pid;
			p2->p_ptstat->pe_other_pid = p1->p_pid;
d471 1
a471 1
		systrace_fork(p1, p2, newstrp);
d475 1
a475 1
		pid_t	pid = p2->p_pid + THREAD_PID_OFFSET;
d478 1
a478 1
			psignal(p1, SIGSEGV);
d485 5
a489 5
 	getmicrotime(&p2->p_stats->p_start);
	p2->p_acflag = AFORK;
	p2->p_stat = SRUN;
	p2->p_cpu = sched_choosecpu_fork(p1, flags);
	setrunqueue(p2);
d499 1
a499 1
		KNOTE(&p1->p_p->ps_klist, NOTE_FORK | p2->p_pid);
d514 1
a514 1
		*rnewprocp = p2;
d524 2
a525 2
		while (p1->p_p->ps_flags & PS_ISPWAIT)
			tsleep(p1->p_p, PWAIT, "ppwait", 0);
d530 2
a531 2
	if ((flags & FORK_PTRACE) && (p1->p_flag & P_TRACED))
		psignal(p1, SIGTRAP);
d538 1
a538 1
		retval[0] = p2->p_pid +
@


1.129
log
@"TLS-lite": add kernel support for a per-thread userspace pointer,
for pointing to the thread-control-block.  Support for mapping this
to the correct hardware register can be added as it's finished;
start with support for amd64, sparc, and sparc64.  Includes syscalls
for getting and setting it (for a portable __errno implementation) as
well as creating a new thread with an initial value for it.

discussed with miod@@, kettenis@@, deraadt@@; committing to get the syscalls
in with the impending libc bump and do further refinements in tree
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.128 2011/07/07 18:00:33 guenther Exp $	*/
a202 1
	LIST_INSERT_AFTER(parent, pr, ps_pglist);
a203 1
	LIST_INSERT_HEAD(&parent->ps_children, pr, ps_sibling);
d443 4
@


1.128
log
@Functions used in files other than where they are defined should be
declared in .h files, not in each .c.  Apply that rule to endtsleep(),
scheduler_start(), updatepri(), and realitexpire()

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.127 2011/07/06 21:41:37 art Exp $	*/
d68 4
d78 1
d156 33
d237 1
a237 1
fork1(struct proc *p1, int exitsig, int flags, void *stack, size_t stacksize,
d405 1
a405 1
	    stacksize, func ? func : child_return, arg ? arg : p2);
d418 4
d469 7
@


1.127
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.126 2011/06/06 17:05:46 deraadt Exp $	*/
a208 2
	extern void endtsleep(void *);
	extern void realitexpire(void *);
@


1.126
log
@push kernel malloc(9) and kernel stacks into non-dma memory, since that
appears to be safe now.  If not, we'll know soon where the bugs lie, so
that we can fix them.  This diff has been in snapshots for many months.
ok oga miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.125 2011/04/03 14:56:28 guenther Exp $	*/
d531 1
a531 1
	KERNEL_PROC_LOCK(p);
@


1.125
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.124 2011/04/02 17:04:35 guenther Exp $	*/
d256 1
a256 1
	    dma_constraint.ucr_low, dma_constraint.ucr_high,
@


1.124
log
@Move P_SUGID and P_SUGIDEXEC from struct proc to struct process, so
that you can't evade the checks by doing the dirty work in an rthread

ok blambert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.123 2010/10/31 00:03:44 guenther Exp $	*/
d322 4
a325 2
	if (flags & FORK_PPWAIT)
		atomic_setbits_int(&p2->p_flag, P_PPWAIT);
d467 4
a470 2
	 * child to exec or exit, set P_PPWAIT on child, and sleep on our
	 * process (in case of exit).
d473 1
a473 1
		while (p2->p_flag & P_PPWAIT)
@


1.123
log
@The return of rfork(RFTHREAD) must be consistent with getthrid().
Fixes rthread breakage observed by Vladimir Kirillov.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.122 2010/07/26 01:56:27 guenther Exp $	*/
d187 1
a306 1
	atomic_setbits_int(&p2->p_flag, p1->p_flag & (P_SUGID | P_SUGIDEXEC));
@


1.122
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.121 2010/07/23 14:19:02 miod Exp $	*/
d483 2
a484 1
		retval[0] = p2->p_pid;
@


1.121
log
@Make sure the u area of new processes is zero-filled; this got lost in
1.119.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.120 2010/07/19 23:00:15 guenther Exp $	*/
d161 2
d165 4
a170 2
	parent = parentproc->p_p;

d187 4
a321 2
	if (p1->p_session->s_ttyvp != NULL && p1->p_flag & P_CONTROLT)
		atomic_setbits_int(&p2->p_flag, P_CONTROLT);
a323 1
	p2->p_pptr = p1;
a325 1
	LIST_INIT(&p2->p_children);
d403 1
a403 2
	LIST_INSERT_HEAD(&p1->p_children, p2, p_sibling);
	LIST_INSERT_AFTER(p1, p2, p_pglist);
d406 3
a408 2
		if (p2->p_pptr != p1->p_pptr)
			proc_reparent(p2, p1->p_pptr);
d466 1
a466 1
	 * proc (in case of exit).
d470 1
a470 1
			tsleep(p1, PWAIT, "ppwait", 0);
d501 2
a502 2
	LIST_FOREACH(p, &zombproc, p_list)
		if (p->p_pid == pid || (p->p_pgrp && p->p_pgrp->pg_id == pid))
d504 1
@


1.120
log
@Rollback the allproclk and fileheadlk addition.  When grabbing an
rwlock, the thread will release biglock if it sleeps, means that
atomicity from before the rw_enter() to after it is not guaranteed.
The change didn't address those, so pulling it until it does.

"go for it" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.119 2010/07/02 01:25:05 art Exp $	*/
d246 2
a247 1
	    USPACE_ALIGN, 0, dma_constraint.ucr_low, dma_constraint.ucr_high,
@


1.119
log
@add an align argument to uvm_km_kmemalloc_pla.

Use uvm_km_kmemalloc_pla with the dma constraint to allocate kernel stacks.

Yes, that means DMA is possible to kernel stacks, but only until we've fixed
all the scary drivers.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.118 2010/06/30 21:01:45 thib Exp $	*/
a390 1
	rw_enter_write(&allproclk);
a397 1
	rw_exit_write(&allproclk);
@


1.118
log
@style nit
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.117 2010/06/30 00:40:28 guenther Exp $	*/
d245 3
a247 1
	uaddr = uvm_km_alloc1(kernel_map, USPACE, USPACE_ALIGN, 1);
@


1.117
log
@Move the plimit and pcred bits in fork1() into process_new() and make
process_new() handle the new struct process like fork1() does struct proc,
with a range of members zeroed and a range copied from the parent process.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.116 2010/06/29 20:25:57 guenther Exp $	*/
d208 1
a208 2
	if (flags & FORK_THREAD)
	{
@


1.116
log
@We always copy struct pcred when creating a new process, so the reference
count was always one.  That's pointless, so remove the member and the code.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.115 2010/06/29 20:14:46 guenther Exp $	*/
d159 1
a159 1
	pr = pool_get(&process_pool, PR_WAITOK | PR_ZERO);
d166 16
a181 1
	pr->ps_rdomain = parent->ps_rdomain;
a298 5
	if ((flags & FORK_THREAD) == 0) {
		p2->p_p->ps_cred = pool_get(&pcred_pool, PR_WAITOK);
		bcopy(p1->p_p->ps_cred, p2->p_p->ps_cred, sizeof(*p2->p_p->ps_cred));
		crhold(p1->p_ucred);
	}
a310 5

	if ((flags & FORK_THREAD) == 0) {
		p2->p_p->ps_limit = p1->p_p->ps_limit;
		p2->p_p->ps_limit->p_refcnt++;
	}
@


1.115
log
@Eliminate struct plimit's PL_SHAREMOD flag: it was for COMPAT_IRIX
sproc() support, but we don't have COMPAT_IRIX.
ok krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.114 2010/06/29 00:35:28 tedu Exp $	*/
a286 1
		p2->p_p->ps_cred->p_refcnt = 1;
@


1.114
log
@some late breaking style comments from guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.113 2010/06/29 00:28:14 tedu Exp $	*/
a302 6
	/*
	 * If ps_limit is still copy-on-write, bump refcnt,
	 * otherwise get a copy that won't be modified.
	 * (If PL_SHAREMOD is clear, the structure is shared
	 * copy-on-write.)
	 */
d304 2
a305 6
		if (p1->p_p->ps_limit->p_lflags & PL_SHAREMOD)
			p2->p_p->ps_limit = limcopy(p1->p_p->ps_limit);
		else {
			p2->p_p->ps_limit = p1->p_p->ps_limit;
			p2->p_p->ps_limit->p_refcnt++;
		}
@


1.113
log
@Eliminate RTHREADS kernel option in favor of a sysctl.  The actual status
(not done) hasn't changed, but now it's less work to test things.
ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.112 2010/06/27 03:26:39 guenther Exp $	*/
d284 1
a284 3
	if (flags & FORK_THREAD) {
		/* nothing */
	} else {
d309 1
a309 3
	if (flags & FORK_THREAD) {
		/* nothing */
	} else {
@


1.112
log
@A process on the zombie list can have a NULL p_pgrp if it sleeps when
grabbing allproclk in proc_zap(); don't dereference the process's p_pgrp
if that happens.

ok art@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.111 2010/05/29 02:47:48 guenther Exp $	*/
d195 2
a196 1
#ifdef RTHREADS
a199 3
#else
		return (ENOTSUP);
#endif
a248 1
#ifdef RTHREADS
a256 3
#else
	process_new(p2, p1);
#endif
a283 1
#ifdef RTHREADS
d286 1
a286 3
	} else
#endif
	{
a310 1
#ifdef RTHREADS
d313 1
a313 3
	} else
#endif
	{
@


1.111
log
@As noted by art, two processes with the same pid would be bad.  Grab
the allproclk before searching for a free pid so that we don't sleep
between picking one and adding it to the list that is searched.
Also, keep holding the lock until after the PIDHASH update.

ok art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.110 2010/05/18 22:26:10 tedu Exp $	*/
d520 1
a520 1
		if (p->p_pid == pid || p->p_pgid == pid)
@


1.110
log
@move knote list to struct process.  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.109 2010/03/24 23:18:17 tedu Exp $	*/
d412 1
a417 1
	rw_enter_write(&allproclk);
d419 1
a420 1
	LIST_INSERT_HEAD(PIDHASH(p2->p_pid), p2, p_hash);
@


1.109
log
@Add a rwlock around the filehead and allproc lists, mainly to protect
list walkers in sysctl that can block.  As a reward, no more vslock.
With some feedback from art, guenther, phessler.  ok guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.108 2010/01/14 23:12:11 schwarze Exp $	*/
d159 1
a159 1
	pr = pool_get(&process_pool, PR_WAITOK);
d463 2
a464 1
	KNOTE(&p1->p_klist, NOTE_FORK | p2->p_pid);
@


1.108
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.107 2009/12/28 02:54:24 guenther Exp $	*/
d417 1
d419 1
@


1.107
log
@Sanity check flags in fork1(), banning some combos we don't support
and catching FORK_THREAD when RTHREADS wasn't compiled in.  Simplify
sys_rfork() based on that.

Flesh out the Linux clone support with more flags, but stricter
checks for missing support or bad combos.  Still not enough for
NPTL to work, mind you.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.106 2009/12/23 07:40:31 guenther Exp $	*/
d464 1
a464 1
	 * Update stats now that we know the fork was successfull.
@


1.106
log
@The process's rdomain should be, well, per-process and not per-rthread,
so put it in struct process instead of struct proc.  While at it,
move the p_emul member inside struct proc so that it gets copied
automatically instead of requiring manual assignment.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.105 2009/11/27 20:05:50 guenther Exp $	*/
d144 1
a144 1
#ifdef RTHREADS
d146 1
a146 2
		flags |= FORK_THREAD | FORK_SIGHAND;
#endif
d191 14
@


1.105
log
@Add setrdomain() and getrdomain() system calls.  Committing now to
catch the libc major bump per request from deraadt@@

Diff by reyk.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.104 2009/07/09 22:29:56 thib Exp $	*/
d156 1
a156 1
process_new(struct proc *newproc, struct proc *parent)
d158 1
a158 1
	struct process *pr;
d165 4
a271 2
	p2->p_emul = p1->p_emul;
	p2->p_rdomain = p1->p_rdomain;
@


1.104
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.102 2009/03/23 13:25:11 art Exp $	*/
d269 1
@


1.103
log
@Some tweaks to the cpu affinity code.
 - Split up choosing of cpu between fork and "normal" cases. Fork is
   very different and should be treated as such.
 - Instead of implicitly choosing a cpu in setrunqueue, do it outside
   where it actually makes sense.
 - Just because a cpu is marked as idle doesn't mean it will be soon.
   There could be a thundering herd effect if we call wakeup from an
   interrupt handler, so subtract cpus with queued processes when
   deciding which cpu is actually idle.
 - some simplifications allowed by the above.

kettenis@@ ok (except one bugfix that was not in the intial diff)
@
text
@d289 1
a289 1
		VREF(p2->p_textvp);
d335 1
a335 1
			VREF(p2->p_tracep);
@


1.102
log
@Processor affinity for processes.
 - Split up run queues so that every cpu has one.
 - Make setrunqueue choose the cpu where we want to make this process
   runnable (this should be refined and less brutal in the future).
 - When choosing the cpu where we want to run, make some kind of educated
   guess where it will be best to run (very naive right now).
Other:
 - Set operations for sets of cpus.
 - load average calculations per cpu.
 - sched_is_idle() -> curcpu_is_idle()

tested, debugged and prodded by many@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.101 2008/11/11 02:13:14 tedu Exp $	*/
d435 1
@


1.101
log
@slightly optimized the ptrace stat allocation to only happen when needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.100 2008/11/09 05:13:55 deraadt Exp $	*/
a261 2

	p2->p_cpu = p1->p_cpu;
@


1.100
log
@systrace activation happens in the middle of a rather sensitive piece of
fork(), i worry about it a lot but cannot prove yet that sleeping there
is bad.  Anyways, this change makes us never sleep in that area -- the
memory needed is allocated ealier like the ptrace state.  tested by many
developers.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.99 2008/11/03 03:03:35 deraadt Exp $	*/
d184 1
a184 1
	struct  ptrace_state *newptstat;
d390 2
a391 1
	newptstat = malloc(sizeof(struct ptrace_state), M_SUBPROC, M_WAITOK);
@


1.99
log
@pre-allocate the ptrace_state we may need to tie to the new process
in case we need it.  the idea is to try to get rid of some potential
sleeps..
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.98 2008/10/14 18:27:29 guenther Exp $	*/
d185 3
d391 4
d425 2
a426 2
	if (ISSET(p1->p_flag, P_SYSTRACE))
		systrace_fork(p1, p2);
@


1.98
log
@Back-in; problems were apparently elsewhere.
Put a reference count in struct process to prevent use-after-free
if the main thread reaches the reaper ahead of some other thread
in the process.  Use the reference count to update the user process
count correctly when changin real uid.

"please re-commit before something else nasty comes in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.97 2008/10/10 14:35:06 deraadt Exp $	*/
d184 1
d387 2
d408 2
a409 2
			p2->p_ptstat = malloc(sizeof(*p2->p_ptstat),
			    M_SUBPROC, M_WAITOK);
d431 3
@


1.97
log
@backout; is causing some people difficulty
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.95 2008/05/11 23:54:40 tedu Exp $	*/
d164 1
d235 1
@


1.96
log
@Put a reference count in struct process to prevent use-after-free
if the main thread reaches the reaper ahead of some other thread
in the process.

ok art@@ tedu@@
@
text
@a163 1
	pr->ps_refcnt = 1;
a233 1
		p2->p_p->ps_refcnt++;
@


1.95
log
@set p_flag to 0 sooner, so we don't overwrite the thread flag.  and correctly
free things when exiting a threaded proc.  from philip guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.94 2008/05/11 23:50:32 tedu Exp $	*/
d164 1
d235 1
@


1.94
log
@share signal handlers for rthreads.  from philip guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.93 2007/10/10 15:53:53 art Exp $	*/
d227 1
a263 1
	p2->p_flag = 0;
@


1.93
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.92 2007/07/25 23:11:52 art Exp $	*/
d146 1
a146 1
		flags |= FORK_THREAD;
@


1.92
log
@Back out the tracking of procs in struct selinfo. There's one serious
bug in the code, but as soon as I try to fix it, it seems to trigger
some other bugs. Instead of trying to figure out what's going on
while everyone suffers, it's better to back out and figure out
the bugs outside the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.87 2007/03/15 10:22:30 art Exp $	*/
a226 1
	p2->p_forw = p2->p_back = NULL;
d503 3
d507 2
@


1.91
log
@The world of __HAVEs and __HAVE_NOTs is reducing. All architectures
have cpu_info now, so kill the option.

eyeballed by jsg@@ and grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.90 2007/04/12 22:14:15 tedu Exp $	*/
a281 2

	TAILQ_INIT(&p2->p_selects);
@


1.90
log
@move p_limit and p_cred into struct process
leave macros behind for now to keep the commit small
ok art beck miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.89 2007/04/03 08:05:43 art Exp $	*/
a256 1
#if defined(__HAVE_CPUINFO)
a257 1
#endif
@


1.89
log
@Start moving state that is shared among threads in a process into
a new struct. Instead of doing a huge rename and deal with the fallout
for weeks, like other projects that need no mention, we will slowly and
carefully move things out of struct proc into a new struct process.

 - Create struct process and the infrastructure to create and remove them.
 - Move threads in a process into struct process.

deraadt@@, tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.88 2007/03/24 16:01:22 art Exp $	*/
d273 11
a283 4
	p2->p_cred = pool_get(&pcred_pool, PR_WAITOK);
	bcopy(p1->p_cred, p2->p_cred, sizeof(*p2->p_cred));
	p2->p_cred->p_refcnt = 1;
	crhold(p1->p_ucred);
d300 1
a300 1
	 * If p_limit is still copy-on-write, bump refcnt,
d305 12
a316 5
	if (p1->p_limit->p_lflags & PL_SHAREMOD)
		p2->p_limit = limcopy(p1->p_limit);
	else {
		p2->p_limit = p1->p_limit;
		p2->p_limit->p_refcnt++;
@


1.88
log
@Kill the horrible hack of storing the pid in struct selinfo.

Instead, keep the proc pointer in it and put the selinfo on a list
in struct proc in selrecord. Then clean up the list when leaving
sys_select and sys_poll.

miod@@ ok, testing by many, including Bobs spamd boxes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.87 2007/03/15 10:22:30 art Exp $	*/
d76 2
d152 15
d229 12
a313 13
#ifdef RTHREADS
	if (flags & FORK_THREAD) {
		atomic_setbits_int(&p2->p_flag, P_THREAD);
		p2->p_thrparent = p1->p_thrparent;
	} else {
		p2->p_thrparent = p2;
	}
#else
	p2->p_thrparent = p2;
#endif

	LIST_INIT(&p2->p_thrchildren);

a384 4
#ifdef RTHREADS
	if (flags & FORK_THREAD)
		LIST_INSERT_HEAD(&p1->p_thrparent->p_thrchildren, p2, p_thrsib);
#endif
@


1.87
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.86 2007/01/17 13:51:52 mickey Exp $	*/
d248 2
@


1.86
log
@reintroduce rev 1.83 -- put the new process on the proc lists
later when more of it's resources have been allocated and thus
kill(2)ing such a process has more predictable results.
now w/ a couple of kettenis remarks; kettenis@@ miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.83 2006/03/27 19:08:58 mickey Exp $	*/
d241 1
a241 1
	p2->p_flag |= (p1->p_flag & (P_SUGID | P_SUGIDEXEC));
d243 1
a243 1
		p2->p_flag |= (p1->p_flag & P_TRACED);
d275 1
a275 1
		p2->p_flag |= P_CONTROLT;
d277 1
a277 1
		p2->p_flag |= P_PPWAIT;
d280 1
a280 1
		p2->p_flag |= P_NOZOMBIE;
d285 1
a285 1
		p2->p_flag |= P_THREAD;
@


1.85
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.84 2006/04/30 15:37:07 kettenis Exp $	*/
a277 1
	LIST_INSERT_AFTER(p1, p2, p_pglist);
a280 1
	LIST_INSERT_HEAD(&p1->p_children, p2, p_sibling);
a286 1
		LIST_INSERT_HEAD(&p1->p_thrparent->p_thrchildren, p2, p_thrsib);
d338 3
d362 9
a388 3
	LIST_INSERT_HEAD(&allproc, p2, p_list);
	LIST_INSERT_HEAD(PIDHASH(p2->p_pid), p2, p_hash);

a392 3

	timeout_set(&p2->p_stats->p_virt_to, virttimer_trampoline, p2);
	timeout_set(&p2->p_stats->p_prof_to, proftimer_trampoline, p2);
@


1.84
log
@Backout last commit, it makes us crash when a ptraced program forks.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.82 2006/02/20 19:39:11 miod Exp $	*/
d194 1
a194 4
	/*
	 * Allocate a pcb and kernel stack for the process
	 */
	uaddr = uvm_km_valloc_align(kernel_map, USPACE, USPACE_ALIGN);
d237 1
a237 1
	p2->p_flag = P_INMEM;
a330 5
	/*
	 * This begins the section where we must prevent the parent
	 * from being swapped.
	 */
	PHOLD(p1);
a399 5

	/*
	 * Now can be swapped.
	 */
	PRELE(p1);
@


1.83
log
@do not rush putting embrionic process on child/thread/sibling lists and set timeouts earlier as we can sleep later and get signals and exit and cause all kinds of hell; pedro@@ ok
@
text
@d281 1
d285 1
d292 1
a348 3
	timeout_set(&p2->p_stats->p_virt_to, virttimer_trampoline, p2);
	timeout_set(&p2->p_stats->p_prof_to, proftimer_trampoline, p2);

a389 4
	LIST_INSERT_HEAD(&p1->p_children, p2, p_sibling);
	LIST_INSERT_AFTER(p1, p2, p_pglist);
	if (flags & FORK_THREAD)
		LIST_INSERT_HEAD(&p1->p_thrparent->p_thrchildren, p2, p_thrsib);
d395 3
@


1.82
log
@Compile out more rthreads stuff unless option RTHREADS;
discussed with a few, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.81 2005/12/22 06:55:03 tedu Exp $	*/
a280 1
	LIST_INSERT_AFTER(p1, p2, p_pglist);
a283 1
	LIST_INSERT_HEAD(&p1->p_children, p2, p_sibling);
a289 1
		LIST_INSERT_HEAD(&p1->p_thrparent->p_thrchildren, p2, p_thrsib);
d346 3
d390 4
a398 3

	timeout_set(&p2->p_stats->p_virt_to, virttimer_trampoline, p2);
	timeout_set(&p2->p_stats->p_prof_to, proftimer_trampoline, p2);
@


1.81
log
@fix memory leak conditions in thrsleep and significantly simplify
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.80 2005/12/04 21:21:46 tedu Exp $	*/
d288 1
d296 3
@


1.80
log
@forgot to set P_THREAD for threaded processes
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.79 2005/12/03 18:09:08 tedu Exp $	*/
a296 1
	LIST_INIT(&p2->p_sleepers);
@


1.79
log
@kernel support for threaded processes (rthreads).
uses rfork(RFTHREAD) to create threads, which are presently processes
that are a little more tightly bound together.  several new syscalls
added to facilitate a userland thread library.
all conditional on RTHREADS, currently disabled.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.78 2005/11/02 20:03:16 aaron Exp $	*/
d289 1
@


1.78
log
@Avoid a theoretical race condition.

In fork1(), setup the p_{prof,virt}_to timeouts _before_ putting the process
on the runqueue.  Since SCHED_UNLOCK() can cause pre-emption, it is possible
(with the old code) for the newly created process to run and become curproc
before the timeouts were set.  If itimers are set early, and you're unlucky,
hardclock() might fire at this time and attempt timeout_add() on the unset
timeouts, leading to "panic: timeout_add: not initialized".

deraadt@@, miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.77 2005/09/14 20:55:59 kettenis Exp $	*/
d142 4
d287 10
@


1.77
log
@ptrace(2) following fork(2)
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.76 2005/05/29 03:20:41 deraadt Exp $	*/
d378 3
a389 3

	timeout_set(&p2->p_stats->p_virt_to, virttimer_trampoline, p2);
	timeout_set(&p2->p_stats->p_prof_to, proftimer_trampoline, p2);
@


1.76
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.74 2005/02/24 04:44:25 tedu Exp $	*/
d58 1
d73 1
d76 11
d91 7
a97 2
	return (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, NULL,
	    NULL, retval, NULL));
d241 2
d352 17
d424 6
@


1.75
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@d344 1
a346 1
	SCHED_LOCK(s);
@


1.74
log
@fix pr4036, don't set p2->p_cpu to null
ok deraadt miod markus
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.73 2004/11/23 19:08:55 miod Exp $	*/
a343 1
	SCHED_LOCK(s);
d346 1
@


1.73
log
@Create the init process earlier, before the root filesystem is mounted,
and have it stall on a semaphore. This allows all kthread creations which
could have been requested during autoconf to be processed before root
is mounted as well.

This causes umass devices attached to any usb with flags 1 (such as on macppc)
to configure properly instead of panicing the kernel at mountroot time.

From NetBSD; tested by various.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.72 2004/08/06 22:31:30 mickey Exp $	*/
d210 1
a210 1
	p2->p_cpu = NULL;
@


1.72
log
@provide md USPACE_ALIGN zero on all but mips; deradat@@ pefo@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.71 2004/08/04 21:49:19 art Exp $	*/
d78 2
a79 1
	return (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, NULL, NULL, retval));
d87 1
a87 1
	    NULL, retval));
d125 1
a125 1
	return (fork1(p, SIGCHLD, flags, NULL, 0, NULL, NULL, retval));
d133 2
a134 1
    void (*func)(void *), void *arg, register_t *retval)
d359 8
d374 1
a374 1
	 * tell any interested parties about the new process
d376 2
a377 1
	KNOTE(&p1->p_klist, NOTE_FORK | p2->p_pid);
@


1.71
log
@hardclock detects if ITIMER_VIRTUAL and ITIMER_PROF have expired and
sends SIGVTALRM and SIGPROF to the process if they had. There is a big
problem with calling psignal from hardclock on MULTIPROCESSOR machines
though. It means we need to protect all signal state in the process
with a lock because hardclock doesn't obtain KERNEL_LOCK. Trying to
track down all the tentacles of this quickly becomes very messy. What
saves us at the moment is that SCHED_LOCK (which is used to protect
parts of the signal state, but not all) happens to be recursive and
forgives small and big errors. That's about to change.

So instead of trying to hunt down all the locking problems here, just
make hardclock not send signals. Instead hardclock schedules a timeout
that will send the signal later. There are many reasons why this works
just as good as the previous code, all explained in a comment written
in big, friendly letters in kern_clock.

miod@@ ok noone else dared to ok this, but noone screamed in agony either.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.70 2004/06/24 19:35:24 tholo Exp $	*/
d173 1
a173 1
	uaddr = uvm_km_valloc(kernel_map, USPACE);
@


1.70
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.69 2004/06/13 21:49:26 niklas Exp $	*/
d348 3
@


1.69
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d343 1
a343 1
	p2->p_stats->p_start = time;
@


1.68
log
@Merge in a piece of the SMP branch into HEAD.

Introduce the cpu_info structure, p_cpu field in struct proc and global
scheduling context and various changed code to deal with this. At the
moment no architecture uses this stuff yet, but it will allow us slow and
controlled migration to the new APIs.

All new code is ifdef:ed out.

ok deraadt@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.67 2004/06/05 22:38:40 tedu Exp $	*/
d207 1
a207 1
#ifdef __HAVE_CPUINFO
d342 1
a342 1
	s = splstatclock();
d347 1
a347 1
	splx(s);
d402 17
@


1.67
log
@retval may be NULL in fork1, take 2
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.66 2004/05/24 02:51:22 deraadt Exp $	*/
d206 4
@


1.66
log
@No way: This breaks nearly every architecture
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.64 2004/04/02 19:08:58 tedu Exp $	*/
d374 4
a377 2
	retval[0] = p2->p_pid;
	retval[1] = 0;
@


1.65
log
@according to fork1(9), retval is optional.  make it so.
from form@@pdp-11.org.ru via mpech.  ok millert
@
text
@d187 4
a199 2
	p2->p_stat = SIDL;			/* protect against others */
	p2->p_exitsig = exitsig;
d374 2
a375 4
	if (retval != NULL) {
		retval[0] = p2->p_pid;
		retval[1] = 0;
	}
@


1.64
log
@rfork(RFMEM) shares complete vmspace.  much more useful, and in line with
other projects' implementations.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.63 2003/09/23 20:26:18 millert Exp $	*/
a186 4
	p2->p_stat = SIDL;			/* protect against others */
	p2->p_exitsig = exitsig;
	p2->p_forw = p2->p_back = NULL;

d196 2
d372 4
a375 2
	retval[0] = p2->p_pid;
	retval[1] = 0;
@


1.63
log
@Limit "proc: table is full" messages to once every 10 seconds which helps when there is a fork bomb going on.  From NetBSD (jdolecek)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.62 2003/07/02 00:07:42 avsm Exp $	*/
d47 1
d122 1
a122 1
		flags |= FORK_VMNOSTACK;
a294 17

	if (flags & FORK_VMNOSTACK) {
		/* share everything, but ... */
		uvm_map_inherit(&p1->p_vmspace->vm_map,
		    VM_MIN_ADDRESS, VM_MAXUSER_ADDRESS,
		    MAP_INHERIT_SHARE);
		/* ... don't share stack */
#ifdef MACHINE_STACK_GROWS_UP
		uvm_map_inherit(&p1->p_vmspace->vm_map,
		    USRSTACK, USRSTACK + MAXSSIZ,
		    MAP_INHERIT_COPY);
#else
		uvm_map_inherit(&p1->p_vmspace->vm_map,
		    USRSTACK - MAXSSIZ, USRSTACK,
		    MAP_INHERIT_COPY);
#endif
	}
@


1.62
log
@comitted->committed in a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.61 2003/06/21 00:42:58 tedu Exp $	*/
d126 3
d150 4
a153 1
		tablefull("proc");
@


1.61
log
@add exec/fork/exit hooks per process for compat emulations.
use them to correctly emulate linux brk.
update to TNF copyright in linux_exec.c.

from netbsd, mostly from a diff by Kurt Miller in pr3318.
this should fix java.  no regressions in testing by kurt and sturm@@.
be prepared for "proc size mismatch" -- recompile ps and friends.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.60 2003/06/02 23:28:05 millert Exp $	*/
d174 1
a174 1
	 * From now on, we're comitted to the fork and cannot fail.
@


1.60
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.59 2002/10/31 01:33:27 art Exp $	*/
d278 5
@


1.59
log
@Defer pid allocation and making the new process visible until after it's
been fully initialized. Otherwise the scheduler and other things can
accidentally stumble into semi-initialized processes and strange things
can happen. This also requires us to do systrace attachment a bit later.

Debugging help from fgs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.58 2002/10/22 01:48:25 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.58
log
@Remove a part that did sneak in that wasn't meant to be commited yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.57 2002/10/21 21:30:02 art Exp $	*/
a135 1
	struct proc *newproc;
d182 1
a182 1
	newproc = pool_get(&proc_pool, PR_WAITOK);
a183 6
	/* Find an unused pid satisfying 1 <= lastpid <= PID_MAX */
	do {
		lastpid = 1 + (randompid ? arc4random() : lastpid) % PID_MAX;
	} while (pidtaken(lastpid));

	p2 = newproc;
a184 1
	p2->p_pid = lastpid;
d186 1
a186 3
	LIST_INSERT_HEAD(&allproc, p2, p_list);
	p2->p_forw = p2->p_back = NULL;		/* shouldn't be necessary */
	LIST_INSERT_HEAD(PIDHASH(p2->p_pid), p2, p_hash);
a265 4
#if NSYSTRACE > 0
	if (ISSET(p1->p_flag, P_SYSTRACE))
		systrace_fork(p1, p2);
#endif
d329 14
@


1.57
log
@ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.56 2002/10/21 21:15:17 art Exp $	*/
d171 1
a171 1
	uaddr = uvm_km_valloc_noexec(kernel_map, USPACE);
@


1.56
log
@Two problems.
First we check for running out of processes (nprocs variable) before we
continue with the fork, then we do various calls that might sleep (and
allow other forks to start and pass that check), then we increase that
variable. This could allow processes to be created past the limit.

Second is that we don't decrease the the process count for this uid
if the stack allocation fails. So a user could run out of processes
he's allowed to run without actually having them.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.55 2002/05/16 16:16:51 provos Exp $	*/
d79 1
a79 4
sys_fork(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d86 1
a86 4
sys_vfork(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d93 1
a93 4
sys_rfork(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d131 2
a132 9
fork1(p1, exitsig, flags, stack, stacksize, func, arg, retval)
	struct proc *p1;
	int exitsig;
	int flags;
	void *stack;
	size_t stacksize;
	void (*func)(void *);
	void *arg;
	register_t *retval;
@


1.55
log
@systrace facility, used to enforce and generate policies for system calls
okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.54 2002/03/14 01:27:04 millert Exp $	*/
d171 1
d180 1
d187 10
a196 3
	uaddr = uvm_km_valloc(kernel_map, USPACE);
	if (uaddr == 0)
		return ENOMEM;
a205 1
	nprocs++;
@


1.54
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.53 2002/02/22 01:08:42 art Exp $	*/
d64 3
d283 4
@


1.53
log
@Fix stack sharing in FORK_VMNOSTACK.
Don't assume that the stack is on the top of user address space.
And don't assume that the stack grows down.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.52 2002/02/16 00:54:49 nordin Exp $	*/
d154 2
a155 2
	extern void endtsleep __P((void *));
	extern void realitexpire __P((void *));
@


1.52
log
@Simplify pid selection algorithm. ok art@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.51 2002/02/14 22:58:15 art Exp $	*/
d304 3
a306 3
		/* share as much address space as possible */
		(void) uvm_map_inherit(&p1->p_vmspace->vm_map,
		    VM_MIN_ADDRESS, round_page(VM_MAXUSER_ADDRESS - MAXSSIZ),
d308 10
@


1.51
log
@No more RFORK_FDSAHRE option, always allow FORK_SHAREFILES.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.50 2002/02/05 15:41:24 art Exp $	*/
d72 1
a151 1
	static int pidchecked = 0;
d189 4
a192 43
	lastpid++;
	if (randompid)
		lastpid = PID_MAX;
retry:
	/*
	 * If the process ID prototype has wrapped around,
	 * restart somewhat above 0, as the low-numbered procs
	 * tend to include daemons that don't exit.
	 */
	if (lastpid >= PID_MAX) {
		lastpid = arc4random() % PID_MAX;
		pidchecked = 0;
	}
	if (lastpid >= pidchecked) {
		int doingzomb = 0;

		pidchecked = PID_MAX;
		/*
		 * Scan the active and zombie procs to check whether this pid
		 * is in use.  Remember the lowest pid that's greater
		 * than lastpid, so we can avoid checking for a while.
		 */
		p2 = LIST_FIRST(&allproc);
again:
		for (; p2 != 0; p2 = LIST_NEXT(p2, p_list)) {
			while (p2->p_pid == lastpid ||
			    p2->p_pgrp->pg_id == lastpid) {
				lastpid++;
				if (lastpid >= pidchecked)
					goto retry;
			}
			if (p2->p_pid > lastpid && pidchecked > p2->p_pid)
				pidchecked = p2->p_pid;
			if (p2->p_pgrp->pg_id > lastpid && 
			    pidchecked > p2->p_pgrp->pg_id)
				pidchecked = p2->p_pgrp->pg_id;
		}
		if (!doingzomb) {
			doingzomb = 1;
			p2 = LIST_FIRST(&zombproc);
			goto again;
		}
	}
d379 17
@


1.50
log
@Workaround for VM_MAXUSER_ADDRESS not being page aligned on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.49 2002/01/25 15:00:26 art Exp $	*/
a155 7

#ifndef RFORK_FDSHARE
	/* XXX - Too dangerous right now. */
	if (flags & FORK_SHAREFILES) {
		return (EOPNOTSUPP);
	}
#endif
@


1.49
log
@poolify pcreds.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.48 2002/01/16 20:50:17 miod Exp $	*/
d352 1
a352 1
		    VM_MIN_ADDRESS, VM_MAXUSER_ADDRESS - MAXSSIZ,
@


1.48
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.47 2001/11/06 19:53:20 miod Exp $	*/
d275 1
a275 2
	MALLOC(p2->p_cred, struct pcred *, sizeof(struct pcred),
	    M_SUBPROC, M_WAITOK);
@


1.47
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.46 2001/11/06 18:41:10 art Exp $	*/
a45 1
#include <sys/map.h>
@


1.47.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.49 2002/01/25 15:00:26 art Exp $	*/
d46 1
d276 2
a277 1
	p2->p_cred = pool_get(&pcred_pool, PR_WAITOK);
@


1.47.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.47.2.1 2002/01/31 22:55:40 niklas Exp $	*/
a63 3
#include "systrace.h"
#include <dev/systrace.h>

a71 1
int pidtaken(pid_t);
d151 1
d154 9
a162 2
	extern void endtsleep(void *);
	extern void realitexpire(void *);
d196 43
a238 4
	/* Find an unused pid satisfying 1 <= lastpid <= PID_MAX */
	do {
		lastpid = 1 + (randompid ? arc4random() : lastpid) % PID_MAX;
	} while (pidtaken(lastpid));
a326 4
#if NSYSTRACE > 0
	if (ISSET(p1->p_flag, P_SYSTRACE))
		systrace_fork(p1, p2);
#endif
d350 3
a352 3
		/* share everything, but ... */
		uvm_map_inherit(&p1->p_vmspace->vm_map,
		    VM_MIN_ADDRESS, VM_MAXUSER_ADDRESS,
a353 10
		/* ... don't share stack */
#ifdef MACHINE_STACK_GROWS_UP
		uvm_map_inherit(&p1->p_vmspace->vm_map,
		    USRSTACK, USRSTACK + MAXSSIZ,
		    MAP_INHERIT_COPY);
#else
		uvm_map_inherit(&p1->p_vmspace->vm_map,
		    USRSTACK - MAXSSIZ, USRSTACK,
		    MAP_INHERIT_COPY);
#endif
a424 17
/*
 * Checks for current use of a pid, either as a pid or pgid.
 */
int
pidtaken(pid_t pid)
{
	struct proc *p;

	if (pfind(pid) != NULL)
		return (1);
	if (pgfind(pid) != NULL)
		return (1);
	LIST_FOREACH(p, &zombproc, p_list)
		if (p->p_pid == pid || p->p_pgid == pid)
			return (1);
	return (0);
}
@


1.47.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.47.2.2 2002/06/11 03:29:40 art Exp $	*/
d79 4
a82 1
sys_fork(struct proc *p, void *v, register_t *retval)
d89 4
a92 1
sys_vfork(struct proc *p, void *v, register_t *retval)
d99 4
a102 1
sys_rfork(struct proc *p, void *v, register_t *retval)
d140 9
a148 2
fork1(struct proc *p1, int exitsig, int flags, void *stack, size_t stacksize,
    void (*func)(void *), void *arg, register_t *retval)
a170 1
	nprocs++;
a178 1
		nprocs--;
d186 2
a187 9
	if (uaddr == 0) {
		chgproccnt(uid, -1);
		nprocs--;
		return (ENOMEM);
	}

	/*
	 * From now on, we're comitted to the fork and cannot fail.
	 */
d197 1
@


1.47.2.4
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.47.2.3 2002/10/29 00:36:44 art Exp $	*/
d171 1
a171 1
	uaddr = uvm_uarea_alloc();
@


1.47.2.5
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d136 1
d183 1
a183 1
	p2 = pool_get(&proc_pool, PR_WAITOK);
d185 6
d192 1
d194 3
a196 1
	p2->p_forw = p2->p_back = NULL;
d276 4
a342 14

	/* Find an unused pid satisfying 1 <= lastpid <= PID_MAX */
	do {
		lastpid = 1 + (randompid ? arc4random() : lastpid) % PID_MAX;
	} while (pidtaken(lastpid));
	p2->p_pid = lastpid;

	LIST_INSERT_HEAD(&allproc, p2, p_list);
	LIST_INSERT_HEAD(PIDHASH(p2->p_pid), p2, p_hash);

#if NSYSTRACE > 0
	if (ISSET(p1->p_flag, P_SYSTRACE))
		systrace_fork(p1, p2);
#endif
@


1.46
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.45 2001/11/06 13:36:52 art Exp $	*/
a64 1
#include <vm/vm.h>
@


1.45
log
@More sync to NetBSD.
 - Use malloc/free instead of MALLOC/FREE for variable sized allocations.
 - Move the memory inheritance code to sys/mman.h and rename from VM_* to MAP_*
 - various cleanups and simplifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.44 2001/10/14 14:39:03 art Exp $	*/
d82 1
a82 1
	return (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, retval));
d92 2
a93 1
	return (fork1(p, SIGCHLD, FORK_VFORK|FORK_PPWAIT, NULL, 0, retval));
d134 1
a134 1
	return (fork1(p, SIGCHLD, flags, NULL, 0, retval));
d138 2
a139 2
fork1(p1, exitsig, flags, stack, stacksize, retval)
	register struct proc *p1;
d144 2
d366 1
a366 1
	    stacksize);
@


1.44
log
@Disable fd sharing for this release. Sorry.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.43 2001/09/19 20:50:58 mickey Exp $	*/
d61 1
d353 1
a353 1
		    VM_INHERIT_SHARE);
@


1.43
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.42 2001/06/27 07:14:22 art Exp $	*/
d154 7
@


1.42
log
@no more fork braindamage
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.41 2001/06/27 06:21:28 art Exp $	*/
a64 2
#include <vm/vm_kern.h>

@


1.41
log
@mips_cachealias is no more
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.40 2001/06/27 04:49:42 art Exp $	*/
a351 15
#ifdef __FORK_BRAINDAMAGE
	/*
	 * Set return values for child before vm_fork,
	 * so they can be copied to child stack.
	 * We return 0, rather than the traditional behaviour of modifying the
	 * return value in the system call stub.
	 * NOTE: the kernel stack may be at a different location in the child
	 * process, and thus addresses of automatic variables (including retval)
	 * may be invalid after vm_fork returns in the child process.
	 */
	retval[0] = 0;
	retval[1] = 1;
	if (vm_fork(p1, p2, stack, stacksize))
		return (0);
#else
d358 1
a358 1
#endif
@


1.40
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.39 2001/04/02 21:43:11 niklas Exp $	*/
a181 3
#if defined(arc) || defined(mips_cachealias)
	uaddr = kmem_alloc_upage(kernel_map, USPACE);
#else
a182 1
#endif
@


1.39
log
@On popular demand, the Linux-compatibility clone(2) implementation based
on NetBSD's code, as well as some faked Posix RT extensions by me.  This makes
at least simple linuxthreads tests work.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.38 2001/03/23 18:42:06 art Exp $	*/
a66 1
#if defined(UVM)
a68 1
#endif
a168 5
#if !defined(UVM)
	if (flags & FORK_SHAREVM)
		return (EINVAL);
#endif

a184 1
#if defined(UVM)
a185 3
#else
	uaddr = kmem_alloc_pageable(kernel_map, USPACE);
#endif
a346 1
#if defined(UVM)
a352 8
#else
	if (flags & FORK_VMNOSTACK) {
		/* share as much address space as possible */
		(void) vm_map_inherit(&p1->p_vmspace->vm_map,
		    VM_MIN_ADDRESS, VM_MAXUSER_ADDRESS - MAXSSIZ,
		    VM_INHERIT_SHARE);
	}
#endif
a374 1
#if defined(UVM)
a376 3
#else /* UVM */
	vm_fork(p1, p2, stack, stacksize);
#endif /* UVM */
a408 1
#if defined(UVM)
a413 1
#endif
@


1.38
log
@Use pool to allocate processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.37 2001/02/13 21:00:48 art Exp $	*/
d53 1
d85 1
a85 1
	return (fork1(p, FORK_FORK, NULL, 0, retval));
d95 1
a95 1
	return (fork1(p, FORK_VFORK|FORK_PPWAIT, NULL, 0, retval));
d107 1
d136 1
a136 1
	return (fork1(p, flags, NULL, 0, retval));
d140 1
a140 1
fork1(p1, flags, stack, stacksize, retval)
d142 1
d252 1
d345 8
d397 1
a397 1
		 stacksize);
@


1.37
log
@More sane spl handling. Don't just assume that we're called at spl0.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.36 2000/11/16 20:02:17 provos Exp $	*/
d59 1
d199 1
a199 1
	MALLOC(newproc, struct proc *, sizeof(struct proc), M_PROC, M_WAITOK);
@


1.36
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.35 2000/11/09 17:02:25 art Exp $	*/
d151 1
d408 1
a408 1
	(void) splstatclock();
d413 1
a413 1
	(void) spl0();
@


1.35
log
@PHOLD/PRELE instead manual fiddling with p_holdcnt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.34 2000/07/10 05:06:12 deraadt Exp $	*/
d426 5
@


1.34
log
@last change was not tested on VM systems
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.33 2000/07/07 15:57:02 art Exp $	*/
d342 1
a342 1
	p1->p_holdcnt++;
d417 1
a417 1
	p1->p_holdcnt--;
@


1.33
log
@The rfork sharing of vmspace is .. special and was broken with UVM.
Add a new flag to fork1 - FORK_VMNOSTACK that shares all of the vmspace
except the stack and use it for rfork.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.32 2000/06/18 17:59:55 niklas Exp $	*/
d167 1
a167 1
	if (flag & FORK_SHAREVM)
@


1.32
log
@Mark kernel threads as system processes.  Make ps hide them by default,
show them with -k.  Do not try to show RSS based values for them as they
mess up column alignment.  vmstat -f now shows kernel threads separately
from rforks too.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.31 2000/03/23 16:54:44 art Exp $	*/
d131 1
a131 1
		flags |= FORK_SHAREVM;
d166 5
d344 9
a352 2
#if !defined(UVM) /* We do this later for UVM */
	if (flags & FORK_SHAREVM) {
@


1.31
log
@Don't reinitialize the tsleep and ITIMER_REAL timers all the time.
The function and the argument never change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.30 2000/03/03 11:46:09 art Exp $	*/
d387 3
@


1.30
log
@Use the LIST_FIRST macro to get the head of zombproc list.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.29 2000/03/03 11:31:42 art Exp $	*/
d144 2
a145 2
	register struct proc *p2;
	register uid_t uid;
d151 2
d255 6
@


1.29
log
@Use LIST_ macros instead of internal field names to walk the allproc list.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.28 2000/02/21 20:00:09 art Exp $	*/
d231 1
a231 1
			p2 = zombproc.lh_first;
@


1.28
log
@dead code and symbol pollution.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.27 2000/01/31 19:57:18 deraadt Exp $	*/
d214 1
a214 1
		p2 = allproc.lh_first;
d216 1
a216 1
		for (; p2 != 0; p2 = p2->p_list.le_next) {
@


1.27
log
@re-add fixed vfork code from art
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.25 2000/01/28 19:45:04 art Exp $	*/
d73 2
@


1.27.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.28 2000/02/21 20:00:09 art Exp $	*/
a72 2
struct	forkstat forkstat;

@


1.27.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d144 2
a145 2
	struct proc *p2;
	uid_t uid;
a150 2
	extern void endtsleep __P((void *));
	extern void realitexpire __P((void *));
d214 1
a214 1
		p2 = LIST_FIRST(&allproc);
d216 1
a216 1
		for (; p2 != 0; p2 = LIST_NEXT(p2, p_list)) {
d231 1
a231 1
			p2 = LIST_FIRST(&zombproc);
a252 6

	/*
	 * Initialize the timeouts.
	 */
	timeout_set(&p2->p_sleep_to, endtsleep, p2);
	timeout_set(&p2->p_realit_to, realitexpire, p2);
@


1.27.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.39 2001/04/02 21:43:11 niklas Exp $	*/
a52 1
#include <sys/signalvar.h>
a58 1
#include <sys/pool.h>
d83 1
a83 1
	return (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, retval));
d93 1
a93 1
	return (fork1(p, SIGCHLD, FORK_VFORK|FORK_PPWAIT, NULL, 0, retval));
a104 1

d131 1
a131 1
		flags |= FORK_VMNOSTACK;
d133 1
a133 1
	return (fork1(p, SIGCHLD, flags, NULL, 0, retval));
d137 1
a137 1
fork1(p1, exitsig, flags, stack, stacksize, retval)
a138 1
	int exitsig;
a150 1
	int s;
a165 5
#if !defined(UVM)
	if (flags & FORK_SHAREVM)
		return (EINVAL);
#endif

d192 1
a192 1
	newproc = pool_get(&proc_pool, PR_WAITOK);
a241 1
	p2->p_exitsig = exitsig;
a333 8
	 * Create signal actions for the child process.
	 */
	if (flags & FORK_SIGHAND)
		sigactsshare(p1, p2);
	else
		p2->p_sigacts = sigactsinit(p1);

	/*
d337 1
a337 1
	PHOLD(p1);
d339 2
a340 9
#if defined(UVM)
	if (flags & FORK_VMNOSTACK) {
		/* share as much address space as possible */
		(void) uvm_map_inherit(&p1->p_vmspace->vm_map,
		    VM_MIN_ADDRESS, VM_MAXUSER_ADDRESS - MAXSSIZ,
		    VM_INHERIT_SHARE);
	}
#else
	if (flags & FORK_VMNOSTACK) {
d371 1
a371 1
	    stacksize);
a386 3
	} else {
		forkstat.cntkthread++;
		forkstat.sizkthread += vm->vm_dsize + vm->vm_ssize;
d392 1
a392 1
	s = splstatclock();
d397 1
a397 1
	splx(s);
d402 1
a402 1
	PRELE(p1);
a410 5

	/*
	 * tell any interested parties about the new process
	 */
	KNOTE(&p1->p_klist, NOTE_FORK | p2->p_pid);
@


1.27.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.27.2.3 2001/05/14 22:32:40 niklas Exp $	*/
d67 1
d70 1
d171 5
d189 4
d194 4
d358 1
d365 8
d376 15
d395 1
d398 4
a401 1

d433 1
d439 1
@


1.27.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.27.2.4 2001/07/04 10:48:19 niklas Exp $	*/
d65 2
a155 7

#ifndef RFORK_FDSHARE
	/* XXX - Too dangerous right now. */
	if (flags & FORK_SHAREFILES) {
		return (EOPNOTSUPP);
	}
#endif
@


1.27.2.6
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a60 1
#include <sys/mman.h>
d64 1
d81 1
a81 1
	return (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, NULL, NULL, retval));
d91 1
a91 2
	return (fork1(p, SIGCHLD, FORK_VFORK|FORK_PPWAIT, NULL, 0, NULL,
	    NULL, retval));
d132 1
a132 1
	return (fork1(p, SIGCHLD, flags, NULL, 0, NULL, NULL, retval));
d136 2
a137 2
fork1(p1, exitsig, flags, stack, stacksize, func, arg, retval)
	struct proc *p1;
a141 2
	void (*func)(void *);
	void *arg;
d352 1
a352 1
		    MAP_INHERIT_SHARE);
d362 1
a362 1
	    stacksize, func ? func : child_return, arg ? arg : p2);
@


1.27.2.7
log
@Merge in trunk
@
text
@d46 1
a72 1
int pidtaken(pid_t);
d152 1
d158 7
d197 43
a239 4
	/* Find an unused pid satisfying 1 <= lastpid <= PID_MAX */
	do {
		lastpid = 1 + (randompid ? arc4random() : lastpid) % PID_MAX;
	} while (pidtaken(lastpid));
d276 2
a277 1
	p2->p_cred = pool_get(&pcred_pool, PR_WAITOK);
d352 3
a354 3
		/* share everything, but ... */
		uvm_map_inherit(&p1->p_vmspace->vm_map,
		    VM_MIN_ADDRESS, VM_MAXUSER_ADDRESS,
a355 10
		/* ... don't share stack */
#ifdef MACHINE_STACK_GROWS_UP
		uvm_map_inherit(&p1->p_vmspace->vm_map,
		    USRSTACK, USRSTACK + MAXSSIZ,
		    MAP_INHERIT_COPY);
#else
		uvm_map_inherit(&p1->p_vmspace->vm_map,
		    USRSTACK - MAXSSIZ, USRSTACK,
		    MAP_INHERIT_COPY);
#endif
a426 17
/*
 * Checks for current use of a pid, either as a pid or pgid.
 */
int
pidtaken(pid_t pid)
{
	struct proc *p;

	if (pfind(pid) != NULL)
		return (1);
	if (pgfind(pid) != NULL)
		return (1);
	LIST_FOREACH(p, &zombproc, p_list)
		if (p->p_pid == pid || p->p_pgid == pid)
			return (1);
	return (0);
}
@


1.27.2.8
log
@Merge in -current from about a week ago
@
text
@d154 2
a155 2
	extern void endtsleep(void *);
	extern void realitexpire(void *);
@


1.27.2.9
log
@Sync the SMP branch with 3.3
@
text
@a63 3
#include "systrace.h"
#include <dev/systrace.h>

d76 4
a79 1
sys_fork(struct proc *p, void *v, register_t *retval)
d86 4
a89 1
sys_vfork(struct proc *p, void *v, register_t *retval)
d96 4
a99 1
sys_rfork(struct proc *p, void *v, register_t *retval)
d137 9
a145 2
fork1(struct proc *p1, int exitsig, int flags, void *stack, size_t stacksize,
    void (*func)(void *), void *arg, register_t *retval)
d149 1
a167 1
	nprocs++;
a175 1
		nprocs--;
d183 2
a184 5
	if (uaddr == 0) {
		chgproccnt(uid, -1);
		nprocs--;
		return (ENOMEM);
	}
d186 2
a187 3
	/*
	 * From now on, we're comitted to the fork and cannot fail.
	 */
d189 4
a192 2
	/* Allocate new proc. */
	p2 = pool_get(&proc_pool, PR_WAITOK);
d194 2
d197 1
d199 3
a201 1
	p2->p_forw = p2->p_back = NULL;
a343 14

	/* Find an unused pid satisfying 1 <= lastpid <= PID_MAX */
	do {
		lastpid = 1 + (randompid ? arc4random() : lastpid) % PID_MAX;
	} while (pidtaken(lastpid));
	p2->p_pid = lastpid;

	LIST_INSERT_HEAD(&allproc, p2, p_list);
	LIST_INSERT_HEAD(PIDHASH(p2->p_pid), p2, p_hash);

#if NSYSTRACE > 0
	if (ISSET(p1->p_flag, P_SYSTRACE))
		systrace_fork(p1, p2);
#endif
@


1.27.2.10
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.27.2.9 2003/03/28 00:41:26 niklas Exp $	*/
d347 1
a347 1
	SCHED_LOCK(s);
d352 1
a352 1
	SCHED_UNLOCK(s);
a404 17

#if defined(MULTIPROCESSOR)
/*
 * XXX This is a slight hack to get newly-formed processes to
 * XXX acquire the kernel lock as soon as they run.
 */
void
proc_trampoline_mp(void)
{
	struct proc *p;

	p = curproc;

	SCHED_ASSERT_UNLOCKED();
	KERNEL_PROC_LOCK(p);
}
#endif
@


1.27.2.11
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.27.2.10 2003/05/15 04:08:02 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.27.2.12
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a125 3
/* print the 'table full' message once per 10 seconds */
struct timeval fork_tfmrate = { 10, 0 };

d147 1
a147 4
		static struct timeval lasttfm;

		if (ratecheck(&lasttfm, &fork_tfmrate))
			tablefull("proc");
d174 1
a174 1
	 * From now on, we're committed to the fork and cannot fail.
a277 5
	/*
	 * If emulation has process fork hook, call it now.
	 */
	if (p2->p_emul->e_proc_fork)
		(*p2->p_emul->e_proc_fork)(p2, p1);
@


1.27.2.13
log
@Some merged code from NetBSD, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.27.2.12 2004/02/19 10:56:37 niklas Exp $	*/
a204 17

#if !defined(MULTIPROCESSOR)
	/*
	 * In the single-processor case, all processes will always run
	 * on the same CPU.  So, initialize the child's CPU to the parent's
	 * now.  In the multiprocessor case, the child's CPU will be
	 * initialized in the low-level context switch code when the
	 * process runs.
	 */
	KASSERT(p1->p_cpu != NULL);
	p2->p_cpu = p1->p_cpu;
#else
	/*
	 * zero child's CPU pointer so we don't get trash.
	 */
	p2->p_cpu = NULL;
#endif /* ! MULTIPROCESSOR */
@


1.27.2.14
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a46 1
#include <sys/exec.h>
d121 1
a121 1
		flags |= FORK_SHAREVM;
d311 17
@


1.27.2.15
log
@don't rely on curcpu() and other fixes for non-mp
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.27.2.14 2004/06/05 23:13:01 niklas Exp $	*/
d207 11
a217 1
#if defined(MULTIPROCESSOR)
@


1.27.2.16
log
@sync to head
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d381 2
a382 4
	if (retval != NULL) {
		retval[0] = p2->p_pid;
		retval[1] = 0;
	}
@


1.27.2.17
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d207 4
a210 1
#if defined(__HAVE_CPUINFO)
d212 1
a212 1
#endif
@


1.26
log
@undo vfork changes, since non-UVM was not considered
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.24 1999/08/17 10:32:18 niklas Exp $	*/
d81 1
a81 1
	return (fork1(p, ISFORK, 0, NULL, 0, retval));
d91 1
a91 1
	return (fork1(p, ISVFORK, 0, NULL, 0, retval));
d103 27
d131 1
a131 1
	return (fork1(p, ISRFORK, SCARG(uap, flags), NULL, 0, retval));
d135 1
a135 1
fork1(p1, forktype, rforkflags, stack, stacksize, retval)
d137 1
a137 2
	int forktype;
	int rforkflags;
a147 1
	int dupfd = 1, cleanfd = 0;
a149 12
	if (forktype == ISRFORK) {
		dupfd = 0;
		if ((rforkflags & RFPROC) == 0)
			return (EINVAL);
		if ((rforkflags & (RFFDG|RFCFDG)) == (RFFDG|RFCFDG))
			return (EINVAL);
		if (rforkflags & RFFDG)
			dupfd = 1;
		if (rforkflags & RFCFDG)
			cleanfd = 1;
	}

d273 1
a273 1
	if (cleanfd)
d275 3
a277 1
	else if (dupfd)
a278 2
	else
		p2->p_fd = fdshare(p1);
d295 1
a295 1
	if (forktype == ISVFORK)
d299 1
a299 1
	if (forktype == ISRFORK && (rforkflags & RFNOWAIT))
d309 1
a309 1
	if (p1->p_traceflag&KTRFAC_INHERIT) {
d330 1
a330 1
	if (forktype == ISRFORK && (rforkflags & RFMEM)) {
d360 2
a361 3
	uvm_fork(p1, p2,
	    (forktype == ISRFORK && (rforkflags & RFMEM)) ? TRUE : FALSE,
	    stack, stacksize);
d368 9
a376 13
	switch (forktype) {
		case ISFORK:
			forkstat.cntfork++;
			forkstat.sizfork += vm->vm_dsize + vm->vm_ssize;
			break;
		case ISVFORK:
			forkstat.cntvfork++;
			forkstat.sizvfork += vm->vm_dsize + vm->vm_ssize;
			break;
		case ISRFORK:
			forkstat.cntrfork++;
			forkstat.sizrfork += vm->vm_dsize + vm->vm_ssize;
			break;
d396 1
a396 1
	if (forktype == ISVFORK)
d398 1
a398 1
	if (forktype == ISRFORK && (rforkflags & RFMEM))
d407 1
a407 1
	if (forktype == ISVFORK)
@


1.25
log
@Change fork1() from taking forktype and rforkflags, into a single flags
argument. Let sys_rfork build the arguments to fork1() and do the
sanity checks itself.
@
text
@d81 1
a81 1
	return (fork1(p, FORK_FORK, NULL, 0, retval));
d91 1
a91 1
	return (fork1(p, FORK_VFORK|FORK_PPWAIT, NULL, 0, retval));
a102 27
	int rforkflags;
	int flags;

	flags = FORK_RFORK;
	rforkflags = SCARG(uap, flags);

	if ((rforkflags & RFPROC) == 0)
		return (EINVAL);

	switch(rforkflags & (RFFDG|RFCFDG)) {
	case (RFFDG|RFCFDG):
		return EINVAL;
	case RFCFDG:
		flags |= FORK_CLEANFILES;
		break;
	case RFFDG:
		break;
	default:
		flags |= FORK_SHAREFILES;
		break;
	}

	if (rforkflags & RFNOWAIT)
		flags |= FORK_NOZOMBIE;

	if (rforkflags & RFMEM)
		flags |= FORK_SHAREVM;
d104 1
a104 1
	return (fork1(p, flags, NULL, 0, retval));
d108 1
a108 1
fork1(p1, flags, stack, stacksize, retval)
d110 2
a111 1
	int flags;
d122 1
d125 12
d260 1
a260 1
	if (flags & FORK_CLEANFILES)
d262 3
a264 1
	else if (flags & FORK_SHAREFILES)
a265 2
	else
		p2->p_fd = fdcopy(p1);
d282 1
a282 1
	if (flags & FORK_PPWAIT)
d286 1
a286 1
	if (flags & FORK_NOZOMBIE)
d296 1
a296 1
	if (p1->p_traceflag & KTRFAC_INHERIT) {
d317 1
a317 1
	if (flags & FORK_SHAREVM)
d347 3
a349 2
	uvm_fork(p1, p2, ((flags & FORK_SHAREVM) ? TRUE : FALSE), stack,
		 stacksize);
d356 13
a368 9
	if (flags & FORK_FORK) {
		forkstat.cntfork++;
		forkstat.sizfork += vm->vm_dsize + vm->vm_ssize;
	} else if (flags & FORK_VFORK) {
		forkstat.cntvfork++;
		forkstat.sizvfork += vm->vm_dsize + vm->vm_ssize;
	} else if (flags & FORK_RFORK) {
		forkstat.cntrfork++;
		forkstat.sizrfork += vm->vm_dsize + vm->vm_ssize;
d388 1
a388 1
	if (flags & FORK_PPWAIT)
d390 1
a390 1
	if (flags & FORK_SHAREVM)
d399 1
a399 1
	if (flags & FORK_PPWAIT)
@


1.24
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.23 1999/08/15 00:07:43 pjanzen Exp $	*/
d81 1
a81 1
	return (fork1(p, ISFORK, 0, NULL, 0, retval));
d91 1
a91 1
	return (fork1(p, ISVFORK, 0, NULL, 0, retval));
d103 27
d131 1
a131 1
	return (fork1(p, ISRFORK, SCARG(uap, flags), NULL, 0, retval));
d135 1
a135 1
fork1(p1, forktype, rforkflags, stack, stacksize, retval)
d137 1
a137 2
	int forktype;
	int rforkflags;
a147 1
	int dupfd = 1, cleanfd = 0;
a149 12
	if (forktype == ISRFORK) {
		dupfd = 0;
		if ((rforkflags & RFPROC) == 0)
			return (EINVAL);
		if ((rforkflags & (RFFDG|RFCFDG)) == (RFFDG|RFCFDG))
			return (EINVAL);
		if (rforkflags & RFFDG)
			dupfd = 1;
		if (rforkflags & RFCFDG)
			cleanfd = 1;
	}

d273 1
a273 1
	if (cleanfd)
d275 3
a277 1
	else if (dupfd)
a278 2
	else
		p2->p_fd = fdshare(p1);
d295 1
a295 1
	if (forktype == ISVFORK)
d299 1
a299 1
	if (forktype == ISRFORK && (rforkflags & RFNOWAIT))
d309 1
a309 1
	if (p1->p_traceflag&KTRFAC_INHERIT) {
d330 1
a330 1
	if (forktype == ISRFORK && (rforkflags & RFMEM)) {
d360 2
a361 3
	uvm_fork(p1, p2,
	    (forktype == ISRFORK && (rforkflags & RFMEM)) ? TRUE : FALSE,
	    stack, stacksize);
d368 9
a376 13
	switch (forktype) {
		case ISFORK:
			forkstat.cntfork++;
			forkstat.sizfork += vm->vm_dsize + vm->vm_ssize;
			break;
		case ISVFORK:
			forkstat.cntvfork++;
			forkstat.sizvfork += vm->vm_dsize + vm->vm_ssize;
			break;
		case ISRFORK:
			forkstat.cntrfork++;
			forkstat.sizrfork += vm->vm_dsize + vm->vm_ssize;
			break;
d396 1
a396 1
	if (forktype == ISVFORK)
d398 1
a398 1
	if (forktype == ISRFORK && (rforkflags & RFMEM))
d407 1
a407 1
	if (forktype == ISVFORK)
@


1.23
log
@Adopt NetBSD fix for scheduler problems (nice was broken).  From the NetBSD
commit messages:

Scheduler bug fixes and reorganization
* fix the ancient nice(1) bug, where nice +20 processes incorrectly
  steal 10 - 20% of the CPU, (or even more depending on load average)
* provide a new schedclock() mechanism at a new clock at schedhz, so high
  platform hz values don't cause nice +0 processes to look like they are
  niced
* change the algorithm slightly, and reorganize the code a lot
* fix percent-CPU calculation bugs, and eliminate some no-op code

=== nice bug === Correctly divide the scheduler queues between niced and
compute-bound processes. The current nice weight of two (sort of, see
`algorithm change' below) neatly divides the USRPRI queues in half; this
should have been used to clip p_estcpu, instead of UCHAR_MAX.  Besides
being the wrong amount, clipping an unsigned char to UCHAR_MAX is a no-op,
and it was done after decay_cpu() which can only _reduce_ the value.  It
has to be kept <= NICE_WEIGHT * PRIO_MAX - PPQ or processes can
scheduler-penalize themselves onto the same queue as nice +20 processes.
(Or even a higher one.)

=== New schedclock() mechanism === Some platforms should be cutting down
stathz before hitting the scheduler, since the scheduler algorithm only
works right in the vicinity of 64 Hz. Rather than prescale hz, then scale
back and forth by 4 every time p_estcpu is touched (each occurance an
abstraction violation), use p_estcpu without scaling and require schedhz
to be generated directly at the right frequency. Use a default stathz (well,
actually, profhz) / 4, so nothing changes unless a platform defines schedhz
and a new clock.
[ To do:  Define these for alpha, where hz==1024, and nice was totally broke.]

=== Algorithm change === The nice value used to be added to the
exponentially-decayed scheduler history value p_estcpu, in _addition_ to
be incorporated directly (with greater weight) into the priority calculation.
At first glance, it appears to be a pointless increase of 1/8 the nice
effect (pri = p_estcpu/4 + nice*2), but it's actually at least 3x that
because it will ramp up linearly but be decayed only exponentially, thus
converging to an additional .75 nice for a loadaverage of one. I killed
this: it makes the behavior hard to control, almost impossible to analyze,
and the effect (~~nothing at for the first second, then somewhat increased
niceness after three seconds or more, depending on load average) pointless.

=== Other bugs === hz -> profhz in the p_pctcpu = f(p_cpticks) calcuation.
Collect scheduler functionality. Try to put each abstraction in just one
place.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.22 1999/07/17 21:49:37 art Exp $	*/
d81 1
a81 1
	return (fork1(p, ISFORK, 0, retval));
d91 1
a91 1
	return (fork1(p, ISVFORK, 0, retval));
d104 1
a104 1
	return (fork1(p, ISRFORK, SCARG(uap, flags), retval));
d108 1
a108 1
fork1(p1, forktype, rforkflags, retval)
d112 2
d339 1
a339 1
	if (vm_fork(p1, p2))
d347 3
a349 1
	uvm_fork(p1, p2, (forktype == ISRFORK && (rforkflags & RFMEM)) ? TRUE : FALSE);
d351 1
a351 1
	vm_fork(p1, p2);
@


1.22
log
@correct fork statistics for UVM
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.21 1999/07/15 14:07:41 art Exp $	*/
d57 1
d306 1
a306 1
	p2->p_estcpu = p1->p_estcpu;
@


1.21
log
@vm_offset_t -> {v,p}addr_t ; vm_size_t -> {v,p}size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.20 1999/03/12 17:49:37 deraadt Exp $	*/
d381 1
a381 1
#if defined(UVM) /* ART_UVM_XXX */
d383 1
a383 2
#ifdef notyet
	if (rforkflags & FORK_PPWAIT)
d385 1
a385 2
#endif
	if (rforkflags & RFMEM)
@


1.20
log
@in scheduler, bias parents for child cpu usage; ross@@ghs.com
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.19 1999/03/02 22:19:08 niklas Exp $	*/
d120 1
a120 1
	vm_offset_t uaddr;
@


1.19
log
@RFNOWAIT does not dissociate the child from its parent in any other
way than that the parent wait call will never get the status of this child,
says Rob
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.18 1999/02/26 04:59:39 art Exp $	*/
d299 7
@


1.18
log
@kmem allocation changes for uvm, and vm_fork -> uvm_fork (with one extra argument)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.17 1999/02/23 18:55:09 art Exp $	*/
d283 1
a283 1
	if (forktype == ISRFORK && (rforkflags & RFNOWAIT)) {
d285 1
a285 3
	} else {
		LIST_INSERT_HEAD(&p1->p_children, p2, p_sibling);
	}
@


1.17
log
@update the comment about number of allowed processes
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.16 1999/02/23 18:50:22 art Exp $	*/
d64 5
d162 3
d167 1
d308 1
d315 1
d338 3
d342 1
d376 10
d403 1
@


1.16
log
@Allow up to 5 (was 1) root processes when the process limit is reached.
This gives root a bigger chance to fix any problem that caused the limit
to be reached.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.15 1999/02/23 18:17:19 art Exp $	*/
d131 3
a133 4
	 * a global limit on the maximum number we will create.  Don't allow
	 * a nonprivileged user to use the last process; don't let root
	 * exceed the limit. The variable nprocs is the current number of
	 * processes, maxproc is the limit.
@


1.15
log
@Ooops! Move the allocation of the U area to after the limits checks.
That was a memory leak.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.14 1999/02/19 19:21:42 art Exp $	*/
d137 1
a137 1
	if ((nprocs >= maxproc - 1 && uid != 0) || nprocs >= maxproc) {
@


1.14
log
@Allocate the u-area early in fork1 instead of in vm_fork.
Now we can return ENOMEM instead of doing a panic when we run out of memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.13 1999/01/11 20:25:09 niklas Exp $	*/
a116 11
	/*
	 * Allocate a pcb and kernel stack for the process
	 */
#if defined(arc) || defined(mips_cachealias)
	uaddr = kmem_alloc_upage(kernel_map, USPACE);
#else
	uaddr = kmem_alloc_pageable(kernel_map, USPACE);
#endif
	if (uaddr == 0)
		return ENOMEM;

d151 11
@


1.13
log
@just check rforkflags if ISRFORK
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.12 1999/01/10 02:20:20 niklas Exp $	*/
d62 1
d115 12
d306 2
@


1.12
log
@Make RFNOWAIT work in rfork(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.11 1997/08/01 22:54:49 deraadt Exp $	*/
d262 1
a262 1
	if (rforkflags & RFNOWAIT) {
@


1.11
log
@only allow setuid if fd_refcnt == 1, due to rfork
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.10 1997/08/01 21:59:13 deraadt Exp $	*/
a66 6
#define	ISFORK	0
#define	ISVFORK	1
#define	ISRFORK	2

int fork1 __P((struct proc *, int, int, register_t *));

a122 2
		if (rforkflags & RFNOWAIT)
			return (EINVAL);	/* XXX unimplimented */
d263 1
a263 1
		/* XXX should we do anything? */
@


1.10
log
@disable RFFDG; long explanation...
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.9 1997/07/07 17:52:10 kstailey Exp $	*/
a132 2
		if (dupfd == 0)
			return (EPERM);
@


1.9
log
@count pages in forkstat, see "vmstat -f"
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.8 1997/06/05 10:15:26 deraadt Exp $	*/
d133 2
@


1.8
log
@random pid generation, heh
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.7 1997/02/18 00:11:47 deraadt Exp $	*/
d116 1
d323 1
d328 1
d332 1
d336 1
@


1.7
log
@cp P_SUGID/P_SUGIDEXEC to child, doh; half from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.6 1996/09/02 01:22:05 tholo Exp $	*/
d57 1
d64 1
a159 4
	/*
	 * Find an unused process ID.  We remember a range of unused IDs
	 * ready to use (from lastpid+1 through pidchecked-1).
	 */
d161 2
d170 1
a170 1
		lastpid = 100;
@


1.6
log
@Rename nextpid to lastpid; make it a global with type pid_t
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_fork.c,v 1.5 1996/03/03 17:19:45 niklas Exp $	*/
d231 1
@


1.5
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
d115 1
a115 1
	static int nextpid, pidchecked = 0;
d160 1
a160 1
	 * ready to use (from nextpid+1 through pidchecked-1).
d162 1
a162 1
	nextpid++;
d169 2
a170 2
	if (nextpid >= PID_MAX) {
		nextpid = 100;
d173 1
a173 1
	if (nextpid >= pidchecked) {
d180 1
a180 1
		 * than nextpid, so we can avoid checking for a while.
d185 4
a188 4
			while (p2->p_pid == nextpid ||
			    p2->p_pgrp->pg_id == nextpid) {
				nextpid++;
				if (nextpid >= pidchecked)
d191 1
a191 1
			if (p2->p_pid > nextpid && pidchecked > p2->p_pid)
d193 1
a193 1
			if (p2->p_pgrp->pg_id > nextpid && 
d207 1
a207 1
	p2->p_pid = nextpid;
@


1.4
log
@Count number of forks, vforks, rforks; still need to count VM pages affected
by the various fork types
@
text
@d1 2
a2 1
/*	$NetBSD: kern_fork.c,v 1.27 1995/12/10 08:26:02 mycroft Exp $	*/
d50 1
d58 2
a61 3
#include <sys/mount.h>
#include <sys/syscallargs.h>

d68 3
d80 1
a112 1
	struct proc **hash;
@


1.3
log
@plan9-like rfork() implimentation by me based on some earlier incomplete
work by rminnich@@Sarnoff.COM. still needs RFNOWAIT support.
@
text
@a72 1

a81 1

d316 12
@


1.2
log
@from netbsd:
Only expect vm_fork() to return if __FORK_BRAINDAMAGE is defined.
Use splstatclock() rather than splhigh() in one place.
Eliminate unused third arg to vm_fork().
@
text
@d56 5
d63 4
d74 1
a74 1
	return (fork1(p, 0, retval));
d84 1
a84 1
	return (fork1(p, 1, retval));
d88 14
a101 1
fork1(p1, isvfork, retval)
d103 2
a104 1
	int isvfork;
d113 15
d239 7
a245 1
	p2->p_fd = fdcopy(p1);
d261 1
a261 1
	if (isvfork)
d265 5
a269 1
	LIST_INSERT_HEAD(&p1->p_children, p2, p_sibling);
d290 7
d339 1
a339 1
	if (isvfork)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: kern_fork.c,v 1.25 1995/10/07 06:28:15 mycroft Exp $	*/
d56 3
a58 1
/* ARGSUSED */
d68 1
a68 1
/* ARGSUSED */
d78 1
a78 2
int	nprocs = 1;		/* process 0 */

d241 2
d246 2
a247 1
	 * We return parent pid, and mark as child in retval[1].
d252 1
a252 1
	retval[0] = p1->p_pid;
d254 1
a254 1
	if (vm_fork(p1, p2, isvfork))
d256 7
d267 1
a267 1
	(void) splhigh();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
