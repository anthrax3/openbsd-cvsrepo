head	1.159;
access;
symbols
	OPENBSD_6_1:1.159.0.4
	OPENBSD_6_1_BASE:1.159
	OPENBSD_6_0:1.157.0.2
	OPENBSD_6_0_BASE:1.157
	OPENBSD_5_9:1.154.0.2
	OPENBSD_5_9_BASE:1.154
	OPENBSD_5_8:1.149.0.4
	OPENBSD_5_8_BASE:1.149
	OPENBSD_5_7:1.148.0.2
	OPENBSD_5_7_BASE:1.148
	OPENBSD_5_6:1.147.0.4
	OPENBSD_5_6_BASE:1.147
	OPENBSD_5_5:1.135.0.4
	OPENBSD_5_5_BASE:1.135
	OPENBSD_5_4:1.125.0.2
	OPENBSD_5_4_BASE:1.125
	OPENBSD_5_3:1.119.0.2
	OPENBSD_5_3_BASE:1.119
	OPENBSD_5_2:1.117.0.2
	OPENBSD_5_2_BASE:1.117
	OPENBSD_5_1_BASE:1.106
	OPENBSD_5_1:1.106.0.2
	OPENBSD_5_0:1.103.0.2
	OPENBSD_5_0_BASE:1.103
	OPENBSD_4_9:1.97.0.4
	OPENBSD_4_9_BASE:1.97
	OPENBSD_4_8:1.97.0.2
	OPENBSD_4_8_BASE:1.97
	OPENBSD_4_7:1.89.0.2
	OPENBSD_4_7_BASE:1.89
	OPENBSD_4_6:1.85.0.4
	OPENBSD_4_6_BASE:1.85
	OPENBSD_4_5:1.82.0.2
	OPENBSD_4_5_BASE:1.82
	OPENBSD_4_4:1.73.0.2
	OPENBSD_4_4_BASE:1.73
	OPENBSD_4_3:1.72.0.2
	OPENBSD_4_3_BASE:1.72
	OPENBSD_4_2:1.71.0.2
	OPENBSD_4_2_BASE:1.71
	OPENBSD_4_1:1.62.0.4
	OPENBSD_4_1_BASE:1.62
	OPENBSD_4_0:1.62.0.2
	OPENBSD_4_0_BASE:1.62
	OPENBSD_3_9:1.59.0.2
	OPENBSD_3_9_BASE:1.59
	OPENBSD_3_8:1.54.0.4
	OPENBSD_3_8_BASE:1.54
	OPENBSD_3_7:1.54.0.2
	OPENBSD_3_7_BASE:1.54
	OPENBSD_3_6:1.53.0.2
	OPENBSD_3_6_BASE:1.53
	SMP_SYNC_A:1.50
	SMP_SYNC_B:1.50
	OPENBSD_3_5:1.49.0.2
	OPENBSD_3_5_BASE:1.49
	OPENBSD_3_4:1.47.0.2
	OPENBSD_3_4_BASE:1.47
	UBC_SYNC_A:1.43
	OPENBSD_3_3:1.43.0.2
	OPENBSD_3_3_BASE:1.43
	OPENBSD_3_2:1.42.0.2
	OPENBSD_3_2_BASE:1.42
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	UBC_SYNC_B:1.42
	UBC:1.37.0.2
	UBC_BASE:1.37
	OPENBSD_3_0:1.35.0.2
	OPENBSD_3_0_BASE:1.35
	OPENBSD_2_9_BASE:1.30
	OPENBSD_2_9:1.30.0.2
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.24.0.2
	OPENBSD_2_7_BASE:1.24
	SMP:1.20.0.4
	SMP_BASE:1.20
	kame_19991208:1.20
	OPENBSD_2_6:1.20.0.2
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.159
date	2017.02.08.20.58.30;	author guenther;	state Exp;
branches;
next	1.158;
commitid	RODF8jyufTSNUZTf;

1.158
date	2016.11.07.00.26.32;	author guenther;	state Exp;
branches;
next	1.157;
commitid	W7ztnDZwvjCaeQTS;

1.157
date	2016.04.25.20.00.33;	author tedu;	state Exp;
branches;
next	1.156;
commitid	MLNYUlvoOtU8VX0s;

1.156
date	2016.03.29.08.46.08;	author mpi;	state Exp;
branches;
next	1.155;
commitid	Yyb4nhV2PH21mCBk;

1.155
date	2016.03.06.05.20.26;	author guenther;	state Exp;
branches;
next	1.154;
commitid	MvBfQoVendDQNACE;

1.154
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.153;
commitid	av6ZVErLSWkVP5Zz;

1.153
date	2015.10.07.03.47.43;	author deraadt;	state Exp;
branches;
next	1.152;
commitid	Ge0gajSA2YHu7mGQ;

1.152
date	2015.09.11.08.22.31;	author guenther;	state Exp;
branches;
next	1.151;
commitid	Lqreadw8v5IPAc0L;

1.151
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.150;
commitid	NdgfPIGUgJxQPnT7;

1.150
date	2015.08.22.20.18.49;	author deraadt;	state Exp;
branches;
next	1.149;
commitid	6NDuzTPjBp2GqkfQ;

1.149
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.148;
commitid	p4LJxGKbi0BU2cG6;

1.148
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.147;
commitid	P6Av4XGqOi3rFasL;

1.147
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.146;
commitid	QlVV51SZgNFxsXxC;

1.146
date	2014.07.11.08.18.31;	author guenther;	state Exp;
branches;
next	1.145;
commitid	zJyOCNTjgsYVGLiw;

1.145
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.144;
commitid	EF98ch02VpFassUi;

1.144
date	2014.07.04.05.58.30;	author guenther;	state Exp;
branches;
next	1.143;
commitid	vhXZZxMGVTWiFaF3;

1.143
date	2014.06.11.20.39.18;	author matthew;	state Exp;
branches;
next	1.142;
commitid	AVOEvzTZM1cwHKHJ;

1.142
date	2014.05.15.04.43.25;	author guenther;	state Exp;
branches;
next	1.141;

1.141
date	2014.05.15.03.52.25;	author guenther;	state Exp;
branches;
next	1.140;

1.140
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.139;

1.139
date	2014.04.17.14.52.50;	author guenther;	state Exp;
branches;
next	1.138;

1.138
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.137;

1.137
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.136;

1.136
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.135;

1.135
date	2014.02.12.05.47.36;	author guenther;	state Exp;
branches;
next	1.134;

1.134
date	2014.02.09.11.17.19;	author kettenis;	state Exp;
branches;
next	1.133;

1.133
date	2014.01.24.04.26.51;	author guenther;	state Exp;
branches;
next	1.132;

1.132
date	2014.01.21.06.22.37;	author guenther;	state Exp;
branches;
next	1.131;

1.131
date	2014.01.20.21.19.27;	author guenther;	state Exp;
branches;
next	1.130;

1.130
date	2014.01.20.03.23.42;	author guenther;	state Exp;
branches;
next	1.129;

1.129
date	2013.10.25.04.42.48;	author guenther;	state Exp;
branches;
next	1.128;

1.128
date	2013.10.08.03.50.07;	author guenther;	state Exp;
branches;
next	1.127;

1.127
date	2013.09.14.01.35.00;	author guenther;	state Exp;
branches;
next	1.126;

1.126
date	2013.08.13.05.52.23;	author guenther;	state Exp;
branches;
next	1.125;

1.125
date	2013.06.05.00.53.26;	author tedu;	state Exp;
branches;
next	1.124;

1.124
date	2013.06.01.04.05.26;	author tedu;	state Exp;
branches;
next	1.123;

1.123
date	2013.05.07.19.26.25;	author guenther;	state Exp;
branches;
next	1.122;

1.122
date	2013.04.06.03.44.34;	author tedu;	state Exp;
branches;
next	1.121;

1.121
date	2013.03.30.06.32.25;	author tedu;	state Exp;
branches;
next	1.120;

1.120
date	2013.03.28.16.55.25;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2012.09.08.14.52.00;	author kettenis;	state Exp;
branches;
next	1.118;

1.118
date	2012.08.02.03.18.48;	author guenther;	state Exp;
branches;
next	1.117;

1.117
date	2012.07.11.08.45.21;	author guenther;	state Exp;
branches;
next	1.116;

1.116
date	2012.07.09.23.06.07;	author guenther;	state Exp;
branches;
next	1.115;

1.115
date	2012.04.14.14.26.39;	author kettenis;	state Exp;
branches;
next	1.114;

1.114
date	2012.04.13.19.18.24;	author kettenis;	state Exp;
branches;
next	1.113;

1.113
date	2012.04.13.16.37.51;	author kettenis;	state Exp;
branches;
next	1.112;

1.112
date	2012.04.11.15.28.50;	author kettenis;	state Exp;
branches;
next	1.111;

1.111
date	2012.04.10.15.50.52;	author guenther;	state Exp;
branches;
next	1.110;

1.110
date	2012.04.06.02.18.49;	author guenther;	state Exp;
branches;
next	1.109;

1.109
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.108;

1.108
date	2012.03.10.05.54.28;	author guenther;	state Exp;
branches;
next	1.107;

1.107
date	2012.02.20.22.23.39;	author guenther;	state Exp;
branches;
next	1.106;

1.106
date	2012.01.17.02.34.18;	author guenther;	state Exp;
branches;
next	1.105;

1.105
date	2011.12.14.07.32.16;	author guenther;	state Exp;
branches;
next	1.104;

1.104
date	2011.12.11.19.42.28;	author guenther;	state Exp;
branches;
next	1.103;

1.103
date	2011.07.25.19.38.53;	author tedu;	state Exp;
branches;
next	1.102;

1.102
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.101;

1.101
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.100;

1.100
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.99;

1.99
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.98;

1.98
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.97;

1.97
date	2010.08.02.19.54.07;	author guenther;	state Exp;
branches;
next	1.96;

1.96
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.19.23.00.15;	author guenther;	state Exp;
branches;
next	1.94;

1.94
date	2010.06.29.20.25.57;	author guenther;	state Exp;
branches;
next	1.93;

1.93
date	2010.06.29.00.28.14;	author tedu;	state Exp;
branches;
next	1.92;

1.92
date	2010.05.26.15.16.57;	author oga;	state Exp;
branches;
next	1.91;

1.91
date	2010.05.18.22.26.10;	author tedu;	state Exp;
branches;
next	1.90;

1.90
date	2010.03.24.23.18.17;	author tedu;	state Exp;
branches;
next	1.89;

1.89
date	2009.12.20.23.54.11;	author guenther;	state Exp;
branches;
next	1.88;

1.88
date	2009.12.20.23.36.04;	author guenther;	state Exp;
branches;
next	1.87;

1.87
date	2009.11.27.19.42.24;	author guenther;	state Exp;
branches;
next	1.86;

1.86
date	2009.10.05.17.43.07;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2009.06.24.13.03.20;	author kurt;	state Exp;
branches;
next	1.84;

1.84
date	2009.04.03.04.22.49;	author guenther;	state Exp;
branches;
next	1.83;

1.83
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.82;

1.82
date	2008.12.16.07.57.28;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2008.12.11.16.31.47;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2008.11.06.21.47.50;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2008.10.31.17.17.01;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2008.10.31.17.15.30;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2008.10.30.17.09.13;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2008.10.14.18.27.29;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2008.10.10.14.35.06;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2008.10.09.06.31.53;	author guenther;	state Exp;
branches;
next	1.73;

1.73
date	2008.05.11.23.54.40;	author tedu;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.10.15.53.53;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.12.22.14.15;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2007.04.11.14.27.08;	author tedu;	state Exp;
branches;
next	1.69;

1.69
date	2007.04.10.21.09.42;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2007.04.10.16.54.48;	author tedu;	state Exp;
branches;
next	1.67;

1.67
date	2007.04.05.02.31.48;	author tedu;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.04.14.40.55;	author pedro;	state Exp;
branches;
next	1.65;

1.65
date	2007.04.04.14.34.56;	author pedro;	state Exp;
branches;
next	1.64;

1.64
date	2007.04.03.08.05.43;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.62;

1.62
date	2006.06.23.13.46.05;	author mickey;	state Exp;
branches;
next	1.61;

1.61
date	2006.06.15.20.08.01;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2006.04.06.21.43.28;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2006.02.20.19.39.11;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2005.12.13.07.38.40;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2005.12.03.18.09.08;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2005.11.28.00.14.28;	author jsg;	state Exp;
branches;
next	1.55;

1.55
date	2005.09.14.20.55.59;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2004.08.04.21.49.19;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2004.07.22.15.42.11;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.50;

1.50
date	2004.05.27.20.48.46;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2004.03.20.19.55.50;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.31.00.13.24;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2003.08.03.19.25.49;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.21.00.42.58;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2002.10.29.01.32.16;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.16.16.16.51;	author provos;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2002.01.25.15.00.26;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2002.01.23.15.46.48;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.12.01.26.09;	author art;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.25.12.11.40;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.27.04.49.41;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.03.08.55.11;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.16.05.07.52;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.02.21.43.11;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.23.18.42.06;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.16.20.02.16;	author provos;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.06.18.50.32;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.05.14.55.16;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.05.11.02.50;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.05.08.38.23;	author art;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2000.04.20.10.03.43;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.23.15.55.52;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.21.20.00.09;	author art;	state Exp;
branches;
next	1.20;

1.20
date	99.08.15.00.07.43;	author pjanzen;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	99.07.15.14.11.05;	author art;	state Exp;
branches;
next	1.18;

1.18
date	99.06.23.09.44.28;	author art;	state Exp;
branches;
next	1.17;

1.17
date	99.03.12.17.49.37;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.03.02.22.19.09;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.02.26.05.06.34;	author art;	state Exp;
branches;
next	1.14;

1.14
date	99.01.11.20.30.40;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.01.10.02.20.20;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.11.06.05.58.16;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.10.06.20.19.52;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.10.06.15.12.17;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.09.15.05.46.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	96.10.26.07.30.24;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.08.15.21.51.50;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.05.02.13.12.11;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.03.03.17.19.44;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	95.12.30.08.35.39;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.05.19.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.22.11.05.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches;
next	;

1.20.4.1
date	2000.02.21.22.29.14;	author niklas;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2000.03.24.09.09.24;	author niklas;	state Exp;
branches;
next	1.20.4.3;

1.20.4.3
date	2001.05.14.22.32.40;	author niklas;	state Exp;
branches;
next	1.20.4.4;

1.20.4.4
date	2001.07.04.10.48.18;	author niklas;	state Exp;
branches;
next	1.20.4.5;

1.20.4.5
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.20.4.6;

1.20.4.6
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.20.4.7;

1.20.4.7
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.20.4.8;

1.20.4.8
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.20.4.9;

1.20.4.9
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.20.4.10;

1.20.4.10
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.20.4.11;

1.20.4.11
date	2003.05.18.17.43.43;	author niklas;	state Exp;
branches;
next	1.20.4.12;

1.20.4.12
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.20.4.13;

1.20.4.13
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.20.4.14;

1.20.4.14
date	2004.04.21.09.40.50;	author niklas;	state Exp;
branches;
next	1.20.4.15;

1.20.4.15
date	2004.06.05.23.13.01;	author niklas;	state Exp;
branches;
next	;

1.24.2.1
date	2000.07.04.19.12.36;	author jason;	state Exp;
branches;
next	;

1.37.2.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.37.2.3;

1.37.2.3
date	2003.05.19.22.31.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.159
log
@Delete the obsolete fork/exec/exit emulation hooks.

ok mpi@@ dlg@@
@
text
@/*	$OpenBSD: kern_exit.c,v 1.158 2016/11/07 00:26:32 guenther Exp $	*/
/*	$NetBSD: kern_exit.c,v 1.39 1996/04/22 01:38:25 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_exit.c	8.7 (Berkeley) 2/12/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/kernel.h>
#include <sys/sysctl.h>
#include <sys/wait.h>
#include <sys/file.h>
#include <sys/vnode.h>
#include <sys/syslog.h>
#include <sys/malloc.h>
#include <sys/resourcevar.h>
#include <sys/ptrace.h>
#include <sys/acct.h>
#include <sys/filedesc.h>
#include <sys/signalvar.h>
#include <sys/sched.h>
#include <sys/ktrace.h>
#include <sys/pool.h>
#include <sys/mutex.h>
#include <sys/pledge.h>
#ifdef SYSVSEM
#include <sys/sem.h>
#endif

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

void	proc_finish_wait(struct proc *, struct proc *);
void	process_zap(struct process *);
void	proc_free(struct proc *);

/*
 * exit --
 *	Death of process.
 */
int
sys_exit(struct proc *p, void *v, register_t *retval)
{
	struct sys_exit_args /* {
		syscallarg(int) rval;
	} */ *uap = v;

	exit1(p, W_EXITCODE(SCARG(uap, rval), 0), EXIT_NORMAL);
	/* NOTREACHED */
	return (0);
}

int
sys___threxit(struct proc *p, void *v, register_t *retval)
{
	struct sys___threxit_args /* {
		syscallarg(pid_t *) notdead;
	} */ *uap = v;

	if (SCARG(uap, notdead) != NULL) {
		pid_t zero = 0;
		if (copyout(&zero, SCARG(uap, notdead), sizeof(zero)))
			psignal(p, SIGSEGV);
	}
	exit1(p, 0, EXIT_THREAD);

	return (0);
}

/*
 * Exit: deallocate address space and other resources, change proc state
 * to zombie, and unlink proc from allproc and parent's lists.  Save exit
 * status and rusage for wait().  Check for child processes and orphan them.
 */
void
exit1(struct proc *p, int rv, int flags)
{
	struct process *pr, *qr, *nqr;
	struct rusage *rup;
	struct vnode *ovp;
	
	atomic_setbits_int(&p->p_flag, P_WEXIT);

	pr = p->p_p;

	/* single-threaded? */
	if (!P_HASSIBLING(p)) {
		flags = EXIT_NORMAL;
	} else {
		/* nope, multi-threaded */
		if (flags == EXIT_NORMAL)
			single_thread_set(p, SINGLE_EXIT, 0);
		else if (flags == EXIT_THREAD)
			single_thread_check(p, 0);
	}

	if (flags == EXIT_NORMAL) {
		if (pr->ps_pid == 1)
			panic("init died (signal %d, exit %d)",
			    WTERMSIG(rv), WEXITSTATUS(rv));

		atomic_setbits_int(&pr->ps_flags, PS_EXITING);
		pr->ps_mainproc->p_xstat = rv;

		/*
		 * If parent is waiting for us to exit or exec, PS_PPWAIT
		 * is set; we wake up the parent early to avoid deadlock.
		 */
		if (pr->ps_flags & PS_PPWAIT) {
			atomic_clearbits_int(&pr->ps_flags, PS_PPWAIT);
			atomic_clearbits_int(&pr->ps_pptr->ps_flags,
			    PS_ISPWAIT);
			wakeup(pr->ps_pptr);
		}
	}

	/* unlink ourselves from the active threads */
	TAILQ_REMOVE(&pr->ps_threads, p, p_thr_link);
	if ((p->p_flag & P_THREAD) == 0) {
		/* main thread gotta wait because it has the pid, et al */
		while (pr->ps_refcnt > 1)
			tsleep(&pr->ps_threads, PUSER, "thrdeath", 0);
		if (pr->ps_flags & PS_PROFIL)
			stopprofclock(pr);
	}

	rup = pr->ps_ru;
	if (rup == NULL) {
		rup = pool_get(&rusage_pool, PR_WAITOK | PR_ZERO);
		if (pr->ps_ru == NULL) {
			pr->ps_ru = rup;
		} else {
			pool_put(&rusage_pool, rup);
			rup = pr->ps_ru;
		}
	}
	p->p_siglist = 0;

	if ((p->p_flag & P_THREAD) == 0) {
		/* close open files and release open-file table */
		fdfree(p);

		timeout_del(&pr->ps_realit_to);
#ifdef SYSVSEM
		semexit(pr);
#endif
		if (SESS_LEADER(pr)) {
			struct session *sp = pr->ps_session;

			if (sp->s_ttyvp) {
				/*
				 * Controlling process.
				 * Signal foreground pgrp,
				 * drain controlling terminal
				 * and revoke access to controlling terminal.
				 */
				if (sp->s_ttyp->t_session == sp) {
					if (sp->s_ttyp->t_pgrp)
						pgsignal(sp->s_ttyp->t_pgrp,
						    SIGHUP, 1);
					ttywait(sp->s_ttyp);
					/*
					 * The tty could have been revoked
					 * if we blocked.
					 */
					if (sp->s_ttyvp)
						VOP_REVOKE(sp->s_ttyvp,
						    REVOKEALL);
				}
				ovp = sp->s_ttyvp;
				sp->s_ttyvp = NULL;
				if (ovp)
					vrele(ovp);
				/*
				 * s_ttyp is not zero'd; we use this to
				 * indicate that the session once had a
				 * controlling terminal.  (for logging and
				 * informational purposes)
				 */
			}
			sp->s_leader = NULL;
		}
		fixjobc(pr, pr->ps_pgrp, 0);

#ifdef ACCOUNTING
		acct_process(p);
#endif

#ifdef KTRACE
		/* release trace file */
		if (pr->ps_tracevp)
			ktrcleartrace(pr);
#endif

		/*
		 * If parent has the SAS_NOCLDWAIT flag set, we're not
		 * going to become a zombie.
		 */
		if (pr->ps_pptr->ps_sigacts->ps_flags & SAS_NOCLDWAIT)
			atomic_setbits_int(&pr->ps_flags, PS_NOZOMBIE);
	}

	p->p_fd = NULL;		/* zap the thread's copy */

        /*
	 * Remove proc from pidhash chain and allproc so looking
	 * it up won't work.  We will put the proc on the
	 * deadproc list later (using the p_hash member), and
	 * wake up the reaper when we do.  If this is the last
	 * thread of a process that isn't PS_NOZOMBIE, we'll put
	 * the process on the zombprocess list below.
	 */
	/*
	 * NOTE: WE ARE NO LONGER ALLOWED TO SLEEP!
	 */
	p->p_stat = SDEAD;

	LIST_REMOVE(p, p_hash);
	LIST_REMOVE(p, p_list);

	if ((p->p_flag & P_THREAD) == 0) {
		LIST_REMOVE(pr, ps_hash);
		LIST_REMOVE(pr, ps_list);

		if ((pr->ps_flags & PS_NOZOMBIE) == 0)
			LIST_INSERT_HEAD(&zombprocess, pr, ps_list);
		else {
			/*
			 * Not going to be a zombie, so it's now off all
			 * the lists scanned by ispidtaken(), so block
			 * fast reuse of the pid now.
			 */
			freepid(pr->ps_pid);
		}

		/*
		 * Give orphaned children to init(8).
		 */
		qr = LIST_FIRST(&pr->ps_children);
		if (qr)		/* only need this if any child is S_ZOMB */
			wakeup(initprocess);
		for (; qr != 0; qr = nqr) {
			nqr = LIST_NEXT(qr, ps_sibling);
			proc_reparent(qr, initprocess);
			/*
			 * Traced processes are killed since their
			 * existence means someone is screwing up.
			 */
			if (qr->ps_flags & PS_TRACED &&
			    !(qr->ps_flags & PS_EXITING)) {
				atomic_clearbits_int(&qr->ps_flags, PS_TRACED);
				/*
				 * If single threading is active,
				 * direct the signal to the active
				 * thread to avoid deadlock.
				 */
				if (qr->ps_single)
					ptsignal(qr->ps_single, SIGKILL,
					    STHREAD);
				else
					prsignal(qr, SIGKILL);
			}
		}
	}

	/* add thread's accumulated rusage into the process's total */
	ruadd(rup, &p->p_ru);
	tuagg(pr, p);

	/*
	 * clear %cpu usage during swap
	 */
	p->p_pctcpu = 0;

	if ((p->p_flag & P_THREAD) == 0) {
		/*
		 * Final thread has died, so add on our children's rusage
		 * and calculate the total times
		 */
		calcru(&pr->ps_tu, &rup->ru_utime, &rup->ru_stime, NULL);
		ruadd(rup, &pr->ps_cru);

		/* notify interested parties of our demise and clean up */
		knote_processexit(p);

		/*
		 * Notify parent that we're gone.  If we're not going to
		 * become a zombie, reparent to process 1 (init) so that
		 * we can wake our original parent to possibly unblock
		 * wait4() to return ECHILD.
		 */
		if (pr->ps_flags & PS_NOZOMBIE) {
			struct process *ppr = pr->ps_pptr;
			proc_reparent(pr, initprocess);
			wakeup(ppr);
		}

		/*
		 * Release the process's signal state.
		 */
		sigactsfree(pr);
	}

	/* just a thread? detach it from its process */
	if (p->p_flag & P_THREAD) {
		/* scheduler_wait_hook(pr->ps_mainproc, p); XXX */
		if (--pr->ps_refcnt == 1)
			wakeup(&pr->ps_threads);
		KASSERT(pr->ps_refcnt > 0);
	}

	/*
	 * Other substructures are freed from reaper and wait().
	 */

	/*
	 * Finally, call machine-dependent code to switch to a new
	 * context (possibly the idle context).  Once we are no longer
	 * using the dead process's vmspace and stack, exit2() will be
	 * called to schedule those resources to be released by the
	 * reaper thread.
	 *
	 * Note that cpu_exit() will end with a call equivalent to
	 * cpu_switch(), finishing our execution (pun intended).
	 */
	uvmexp.swtch++;
	cpu_exit(p);
	panic("cpu_exit returned");
}

/*
 * Locking of this proclist is special; it's accessed in a
 * critical section of process exit, and thus locking it can't
 * modify interrupt state.  We use a simple spin lock for this
 * proclist.  We use the p_hash member to linkup to deadproc.
 */
struct mutex deadproc_mutex = MUTEX_INITIALIZER(IPL_NONE);
struct proclist deadproc = LIST_HEAD_INITIALIZER(deadproc);

/*
 * We are called from cpu_exit() once it is safe to schedule the
 * dead process's resources to be freed.
 *
 * NOTE: One must be careful with locking in this routine.  It's
 * called from a critical section in machine-dependent code, so
 * we should refrain from changing any interrupt state.
 *
 * We lock the deadproc list, place the proc on that list (using
 * the p_hash member), and wake up the reaper.
 */
void
exit2(struct proc *p)
{
	mtx_enter(&deadproc_mutex);
	LIST_INSERT_HEAD(&deadproc, p, p_hash);
	mtx_leave(&deadproc_mutex);

	wakeup(&deadproc);
}

void
proc_free(struct proc *p)
{
	crfree(p->p_ucred);
	pool_put(&proc_pool, p);
	nthreads--;
}

/*
 * Process reaper.  This is run by a kernel thread to free the resources
 * of a dead process.  Once the resources are free, the process becomes
 * a zombie, and the parent is allowed to read the undead's status.
 */
void
reaper(void)
{
	struct proc *p;

	KERNEL_UNLOCK();

	SCHED_ASSERT_UNLOCKED();

	for (;;) {
		mtx_enter(&deadproc_mutex);
		while ((p = LIST_FIRST(&deadproc)) == NULL)
			msleep(&deadproc, &deadproc_mutex, PVM, "reaper", 0);

		/* Remove us from the deadproc list. */
		LIST_REMOVE(p, p_hash);
		mtx_leave(&deadproc_mutex);

		KERNEL_LOCK();

		/*
		 * Free the VM resources we're still holding on to.
		 * We must do this from a valid thread because doing
		 * so may block.
		 */
		uvm_uarea_free(p);
		p->p_vmspace = NULL;		/* zap the thread's copy */

		if (p->p_flag & P_THREAD) {
			/* Just a thread */
			proc_free(p);
		} else {
			struct process *pr = p->p_p;

			/* Release the rest of the process's vmspace */
			uvm_exit(pr);

			if ((pr->ps_flags & PS_NOZOMBIE) == 0) {
				/* Process is now a true zombie. */
				atomic_setbits_int(&pr->ps_flags, PS_ZOMBIE);
				prsignal(pr->ps_pptr, SIGCHLD);

				/* Wake up the parent so it can get exit status. */
				wakeup(pr->ps_pptr);
			} else {
				/* No one will wait for us. Just zap the process now */
				process_zap(pr);
			}
		}

		KERNEL_UNLOCK();
	}
}

int
sys_wait4(struct proc *q, void *v, register_t *retval)
{
	struct sys_wait4_args /* {
		syscallarg(pid_t) pid;
		syscallarg(int *) status;
		syscallarg(int) options;
		syscallarg(struct rusage *) rusage;
	} */ *uap = v;
	struct rusage ru;
	int status, error;

	error = dowait4(q, SCARG(uap, pid),
	    SCARG(uap, status) ? &status : NULL,
	    SCARG(uap, options), SCARG(uap, rusage) ? &ru : NULL, retval);
	if (error == 0 && retval[0] > 0 && SCARG(uap, status)) {
		error = copyout(&status, SCARG(uap, status), sizeof(status));
	}
	if (error == 0 && retval[0] > 0 && SCARG(uap, rusage)) {
		error = copyout(&ru, SCARG(uap, rusage), sizeof(ru));
#ifdef KTRACE
		if (error == 0 && KTRPOINT(q, KTR_STRUCT))
			ktrrusage(q, &ru);
#endif
	}
	return (error);
}

int
dowait4(struct proc *q, pid_t pid, int *statusp, int options,
    struct rusage *rusage, register_t *retval)
{
	int nfound;
	struct process *pr;
	struct proc *p;
	int error;

	if (pid == 0)
		pid = -q->p_p->ps_pgid;
	if (options &~ (WUNTRACED|WNOHANG|WCONTINUED))
		return (EINVAL);

loop:
	nfound = 0;
	LIST_FOREACH(pr, &q->p_p->ps_children, ps_sibling) {
		if ((pr->ps_flags & PS_NOZOMBIE) ||
		    (pid != WAIT_ANY &&
		    pr->ps_pid != pid &&
		    pr->ps_pgid != -pid))
			continue;

		p = pr->ps_mainproc;

		nfound++;
		if (pr->ps_flags & PS_ZOMBIE) {
			retval[0] = pr->ps_pid;

			if (statusp != NULL)
				*statusp = p->p_xstat;	/* convert to int */
			if (rusage != NULL)
				memcpy(rusage, pr->ps_ru, sizeof(*rusage));
			proc_finish_wait(q, p);
			return (0);
		}
		if (pr->ps_flags & PS_TRACED &&
		    (pr->ps_flags & PS_WAITED) == 0 && pr->ps_single &&
		    pr->ps_single->p_stat == SSTOP &&
		    (pr->ps_single->p_flag & P_SUSPSINGLE) == 0) {
			single_thread_wait(pr);

			atomic_setbits_int(&pr->ps_flags, PS_WAITED);
			retval[0] = pr->ps_pid;

			if (statusp != NULL)
				*statusp = W_STOPCODE(pr->ps_single->p_xstat);
			if (rusage != NULL)
				memset(rusage, 0, sizeof(*rusage));
			return (0);
		}
		if (p->p_stat == SSTOP &&
		    (pr->ps_flags & PS_WAITED) == 0 &&
		    (p->p_flag & P_SUSPSINGLE) == 0 &&
		    (pr->ps_flags & PS_TRACED ||
		    options & WUNTRACED)) {
			atomic_setbits_int(&pr->ps_flags, PS_WAITED);
			retval[0] = pr->ps_pid;

			if (statusp != NULL)
				*statusp = W_STOPCODE(p->p_xstat);
			if (rusage != NULL)
				memset(rusage, 0, sizeof(*rusage));
			return (0);
		}
		if ((options & WCONTINUED) && (p->p_flag & P_CONTINUED)) {
			atomic_clearbits_int(&p->p_flag, P_CONTINUED);
			retval[0] = pr->ps_pid;

			if (statusp != NULL)
				*statusp = _WCONTINUED;
			if (rusage != NULL)
				memset(rusage, 0, sizeof(*rusage));
			return (0);
		}
	}
	if (nfound == 0)
		return (ECHILD);
	if (options & WNOHANG) {
		retval[0] = 0;
		return (0);
	}
	if ((error = tsleep(q->p_p, PWAIT | PCATCH, "wait", 0)) != 0)
		return (error);
	goto loop;
}

void
proc_finish_wait(struct proc *waiter, struct proc *p)
{
	struct process *pr, *tr;
	struct rusage *rup;

	/*
	 * If we got the child via a ptrace 'attach',
	 * we need to give it back to the old parent.
	 */
	pr = p->p_p;
	if (pr->ps_oppid && (tr = prfind(pr->ps_oppid))) {
		atomic_clearbits_int(&pr->ps_flags, PS_TRACED);
		pr->ps_oppid = 0;
		proc_reparent(pr, tr);
		prsignal(tr, SIGCHLD);
		wakeup(tr);
	} else {
		scheduler_wait_hook(waiter, p);
		p->p_xstat = 0;
		rup = &waiter->p_p->ps_cru;
		ruadd(rup, pr->ps_ru);
		LIST_REMOVE(pr, ps_list);	/* off zombprocess */
		freepid(pr->ps_pid);
		process_zap(pr);
	}
}

/*
 * make process 'parent' the new parent of process 'child'.
 */
void
proc_reparent(struct process *child, struct process *parent)
{

	if (child->ps_pptr == parent)
		return;

	LIST_REMOVE(child, ps_sibling);
	LIST_INSERT_HEAD(&parent->ps_children, child, ps_sibling);
	child->ps_pptr = parent;
}

void
process_zap(struct process *pr)
{
	struct vnode *otvp;
	struct proc *p = pr->ps_mainproc;

	/*
	 * Finally finished with old proc entry.
	 * Unlink it from its process group and free it.
	 */
	leavepgrp(pr);
	LIST_REMOVE(pr, ps_sibling);

	/*
	 * Decrement the count of procs running with this uid.
	 */
	(void)chgproccnt(pr->ps_ucred->cr_ruid, -1);

	pledge_dropwpaths(pr);

	/*
	 * Release reference to text vnode
	 */
	otvp = pr->ps_textvp;
	pr->ps_textvp = NULL;
	if (otvp)
		vrele(otvp);

	KASSERT(pr->ps_refcnt == 1);
	if (pr->ps_ptstat != NULL)
		free(pr->ps_ptstat, M_SUBPROC, sizeof(*pr->ps_ptstat));
	pool_put(&rusage_pool, pr->ps_ru);
	KASSERT(TAILQ_EMPTY(&pr->ps_threads));
	limfree(pr->ps_limit);
	crfree(pr->ps_ucred);
	pool_put(&process_pool, pr);
	nprocesses--;

	proc_free(p);
}
@


1.158
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.157 2016/04/25 20:00:33 tedu Exp $	*/
a243 6

	/*
	 * If emulation has thread exit hook, call it now.
	 */
	if (pr->ps_emul->e_proc_exit)
		(*pr->ps_emul->e_proc_exit)(p);
@


1.157
log
@boom goes the dynamite
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.156 2016/03/29 08:46:08 mpi Exp $	*/
d268 1
d279 1
a279 1
			freepid(p->p_pid);
a518 1
		p = pr->ps_mainproc;
d521 1
a521 1
		    p->p_pid != pid &&
d525 2
d529 1
a529 1
			retval[0] = p->p_pid;
d545 1
a545 1
			retval[0] = p->p_pid;
d559 1
a559 1
			retval[0] = p->p_pid;
d569 1
a569 1
			retval[0] = p->p_pid;
d612 1
a612 1
		freepid(p->p_pid);
@


1.156
log
@Use a macro to check if a thread has a sibling.

Note that without locking a thread cannot claim that it is part
of a multi-threaded process using this macro.

Suggested by miod@@, ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.155 2016/03/06 05:20:26 guenther Exp $	*/
a67 3
#include "systrace.h"
#include <dev/systrace.h>

a243 5

#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		systrace_exit(p);
#endif
@


1.155
log
@Localize some declarations to kern_exit.c: the last good reason to put
them in sys/proc.h has been removed with compat_linux

diff from Michal Mazurek (akfaew (at) jasminek.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.154 2015/10/09 01:10:27 deraadt Exp $	*/
d130 1
a130 2
	if (TAILQ_FIRST(&pr->ps_threads) == p &&
	    TAILQ_NEXT(p, p_thr_link) == NULL) {
@


1.154
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.153 2015/10/07 03:47:43 deraadt Exp $	*/
d75 4
@


1.153
log
@Add the tame "exec" request.  This allows processes which request
"exec" to call execve(2), potentially fork(2) beforehands if they
asked for "proc".  Calling execve is what "shells" (ksh, tmux, etc)
have as their primary purpose.  But meantime, if such a shell has a
nasty bug, we want to mitigate the process from opening a socket or
calling 100+ other system calls.  Unfortunately silver bullets are in
short supply, so if our goal is to stay in a POSIX-y environment, we
have to let shells call execve().  POSIX ate the world, so choices do
we all have?
Warning for many: silver bullets are even more rare in other OS
ecosystems, so please accept this as a narrow lowering of the bar in a
very raised environment.
Commited from a machine running tame "proc exec" ksh, make, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.152 2015/09/11 08:22:31 guenther Exp $	*/
d63 1
a63 1
#include <sys/tame.h>
d653 1
a653 1
	tame_dropwpaths(pr);
@


1.152
log
@Only include <sys/tame.h> in the .c files that need it

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.151 2015/08/28 00:03:53 deraadt Exp $	*/
d653 1
a653 9
	if (pr->ps_tamepaths && --pr->ps_tamepaths->wl_ref == 0) {
		struct whitepaths *wl = pr->ps_tamepaths;
		int i;

		for (i = 0; i < wl->wl_count; i++)
			free(wl->wl_paths[i].name, M_TEMP, wl->wl_paths[i].len);
		free(wl, M_TEMP, wl->wl_size);
	}
	pr->ps_tamepaths = NULL;
@


1.151
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.150 2015/08/22 20:18:49 deraadt Exp $	*/
d63 1
@


1.150
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.149 2015/03/14 03:38:50 jsg Exp $	*/
d672 1
a672 1
		free(pr->ps_ptstat, M_SUBPROC, 0);
@


1.149
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.148 2014/12/16 18:30:04 tedu Exp $	*/
d651 10
@


1.148
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.147 2014/07/12 18:43:32 tedu Exp $	*/
a48 1
#include <sys/buf.h>
@


1.147
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.146 2014/07/11 08:18:31 guenther Exp $	*/
d73 2
@


1.146
log
@It's init as a process that's special, not init's original thread.
Remember initprocess instead of initproc.

ok matthew@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.145 2014/07/08 17:19:25 deraadt Exp $	*/
d661 1
a661 1
		free(pr->ps_ptstat, M_SUBPROC);
@


1.145
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.144 2014/07/04 05:58:30 guenther Exp $	*/
d289 1
a289 1
			wakeup(initproc->p_p);
d292 1
a292 1
			proc_reparent(qr, initproc->p_p);
d342 1
a342 1
			proc_reparent(pr, initproc->p_p);
@


1.144
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.143 2014/06/11 20:39:18 matthew Exp $	*/
d48 1
a72 3


#include <uvm/uvm_extern.h>
@


1.143
log
@Fix wait4 to not modify status or rusage if we return 0 because of
WNOHANG, in accordance with POSIX.  Additionally, if rusage is
requested but the waited-on process did not terminate, return zero
bytes instead of kernel stack garbage.

ok deraadt, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.142 2014/05/15 04:43:25 guenther Exp $	*/
d463 1
a463 1
				p->p_stat = SZOMB;
d531 1
a531 1
		if (p->p_stat == SZOMB) {
@


1.142
log
@knote_processexit() needs the thread to pass down to FRELE(), so pass it
the exiting thread instead of assuming that that's ps_mainproc.
Also, panic no matter which thread of init takes it down.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.141 2014/05/15 03:52:25 guenther Exp $	*/
d493 1
a493 1
	if (error == 0 && SCARG(uap, status)) {
d496 1
a496 1
	if (error == 0 && SCARG(uap, rusage)) {
d552 2
d566 2
d576 2
@


1.141
log
@Move from struct proc to process the reference-count-holding pointers
to the process's vmspace and filedescs.  struct proc continues to
keep copies of the pointers, copying them on fork, clearing them
on exit, and (for vmspace) refreshing on exec.
Also, make uvm_swapout_threads() thread aware, eliminating p_swtime
in kernel.

particular testing by ajacoutot@@ and sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.140 2014/04/18 11:51:17 guenther Exp $	*/
a119 4

	if (p->p_pid == 1)
		panic("init died (signal %d, exit %d)",
		    WTERMSIG(rv), WEXITSTATUS(rv));
d138 4
d334 1
a334 1
		knote_processexit(pr);
@


1.140
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.139 2014/04/17 14:52:50 guenther Exp $	*/
d179 3
a181 4
	/*
	 * Close open files and release open-file table.
	 */
	fdfree(p);
a182 1
	if ((p->p_flag & P_THREAD) == 0) {
d243 2
d449 2
a450 1
		uvm_exit(p);
d457 3
@


1.139
log
@Make sure the original thread is blocked until any other threads are
completely detached from the process before letting it exit, so that
sleeping in systrace_exit() doesn't reorder them and lead to a panic.

Panic reported by Fabian Raetz (fabian.raetz (at) gmail.com)
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.138 2014/03/30 21:54:48 guenther Exp $	*/
d414 1
@


1.138
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.137 2014/03/26 05:23:42 guenther Exp $	*/
d161 1
a161 1
		while (!TAILQ_EMPTY(&pr->ps_threads))
a164 2
	} else if (TAILQ_EMPTY(&pr->ps_threads)) {
		wakeup(&pr->ps_threads);
d357 2
a358 1
		--pr->ps_refcnt;
@


1.137
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.136 2014/03/22 06:05:45 guenther Exp $	*/
d641 1
a641 1
	(void)chgproccnt(pr->ps_cred->p_ruid, -1);
d657 1
a657 2
	crfree(pr->ps_cred->pc_ucred);
	pool_put(&pcred_pool, pr->ps_cred);
@


1.136
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.135 2014/02/12 05:47:36 guenther Exp $	*/
d253 1
a253 1
	 * If emulation has process exit hook, call it now.
d255 2
a256 2
	if (p->p_emul->e_proc_exit)
		(*p->p_emul->e_proc_exit)(p);
@


1.135
log
@Eliminate the exit sig handling, which was only invokable via the
Linux-compat clone() syscall when *not* using CLONE_THREAD.  pirofti@@
confirms Opera runs in compat without this, so out it goes; one less hair
to choke on in kern_exit.c

ok tedu@@ pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.134 2014/02/09 11:17:19 kettenis Exp $	*/
d243 1
a243 2
		if (pr->ps_pptr->ps_mainproc->p_sigacts->ps_flags &
		    SAS_NOCLDWAIT)
d349 5
a354 5

	/*
	 * Release the process's signal state.
	 */
	sigactsfree(p);
@


1.134
log
@Fix the lock order reversal problem in the code that stops traced
multi-threaded  processes when they receive a signal:

1. Make the parent of the process (the tracer) wait for all threads to be
   stopped (in wait4(2)) instead of the thread that received the signal.
   This prevents us from calling tsleep(9) recursively.

2. Assume that we already hold the kernel lock if the P_SINTR flag is set
   (just like we already assumed we were holding the scheduler lock) and
   don't try to grab it again.

This should fix the panic that many people reported when debugging
multi-threaded programs with gdb(1).

ok & lots of help from guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.133 2014/01/24 04:26:51 guenther Exp $	*/
d461 1
a461 3

				if (P_EXITSIG(p) != 0)
					prsignal(pr->ps_pptr, P_EXITSIG(p));
d514 1
a514 1
	if (options &~ (WUNTRACED|WNOHANG|WALTSIG|WCONTINUED))
a526 9
		/*
		 * Wait for processes with p_exitsig != SIGCHLD processes only
		 * if WALTSIG is set; wait for processes with p_exitsig ==
		 * SIGCHLD only if WALTSIG is clear.
		 */
		if ((options & WALTSIG) ?
		    (p->p_exitsig == SIGCHLD) : (P_EXITSIG(p) != SIGCHLD))
			continue;

d598 1
a598 2
		if (p->p_exitsig != 0)
			prsignal(tr, p->p_exitsig);
a619 3

	if (parent == initproc->p_p)
		child->ps_mainproc->p_exitsig = SIGCHLD;
@


1.133
log
@exit1() needs to do a final aggregation of the thread's [us]ticks
and runtime to the process totals.  Also, add ktracing of struct
rusage in wait4() and getrusage().

problem pointed out by tedu@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.132 2014/01/21 06:22:37 guenther Exp $	*/
d553 2
@


1.132
log
@Setting p->p_p to NULL when it's still running isn't safe for statclock().
It was just for cleanliness, so be a little dirty

ok krw@@, who managed to convince his clock to fire in the gap
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.131 2014/01/20 21:19:27 guenther Exp $	*/
d321 1
d497 4
@


1.131
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.130 2014/01/20 03:23:42 guenther Exp $	*/
a360 1
		p->p_p = NULL;
@


1.130
log
@Move p_textvp from struct proc to struct process so that the exit code
can be further simplified.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.129 2013/10/25 04:42:48 guenther Exp $	*/
d238 8
d260 7
a266 6
         * Remove proc from pidhash chain so looking it up won't
         * work.  Move it from allproc to zombproc, but do not yet
         * wake up the reaper.  We will put the proc on the
         * deadproc list later (using the p_hash member), and
         * wake up the reaper when we do.
         */
a273 1
	LIST_INSERT_HEAD(&zombproc, p, p_list);
a274 3
	/*
	 * Give orphaned children to init(8).
	 */
d276 16
a318 1

d339 4
a342 3
		 * Notify parent that we're gone.  If we have P_NOZOMBIE
		 * or parent has the SAS_NOCLDWAIT flag set, notify process 1
		 * instead (and hope it will handle this situation).
d344 1
a344 3
		if ((p->p_flag & P_NOZOMBIE) ||
		    (pr->ps_pptr->ps_mainproc->p_sigacts->ps_flags &
		    SAS_NOCLDWAIT)) {
a346 6

			/*
			 * Notify parent, so in case he was wait(2)ing or
			 * executing waitpid(2) with our pid, he will
			 * continue.
			 */
d356 8
d387 1
a387 2
 * proclist.  Processes on this proclist are also on zombproc;
 * we use the p_hash member to linkup to deadproc.
d413 7
d452 3
a454 8
		/* Process is now a true zombie. */
		if ((p->p_flag & P_NOZOMBIE) == 0) {
			p->p_stat = SZOMB;

			if (P_EXITSIG(p) != 0)
				prsignal(p->p_p->ps_pptr, P_EXITSIG(p));
			/* Wake up the parent so it can get exit status. */
			wakeup(p->p_p->ps_pptr);
d456 15
a470 2
			/* Noone will wait for us. Just zap the process now */
			proc_zap(p);
d519 1
a519 1
		if ((p->p_flag & P_NOZOMBIE) ||
d527 1
a527 1
		 * if WALTSIG is set; wait for processes with pexitsig ==
d599 1
a599 2
	if ((p->p_flag & P_THREAD) == 0 && pr->ps_oppid &&
	    (tr = prfind(pr->ps_oppid))) {
d611 3
a613 1
		proc_zap(p);
d636 1
a636 1
proc_zap(struct proc *p)
a637 1
	struct process *pr = p->p_p;
d639 1
d645 2
a646 5
	if ((p->p_flag & P_THREAD) == 0)
		leavepgrp(pr);
	LIST_REMOVE(p, p_list);	/* off zombproc */
	if ((p->p_flag & P_THREAD) == 0) {
		LIST_REMOVE(pr, ps_sibling);
d648 4
a651 13
		/*
		 * Decrement the count of procs running with this uid.
		 */
		(void)chgproccnt(p->p_cred->p_ruid, -1);

		/*
		 * Release reference to text vnode
		 */
		otvp = pr->ps_textvp;
		pr->ps_textvp = NULL;
		if (otvp)
			vrele(otvp);
	}
d654 1
a654 2
	 * Remove us from our process list, possibly killing the process
	 * in the process (pun intended).
d656 15
a670 11
	if (--pr->ps_refcnt == 0) {
		if (pr->ps_ptstat != NULL)
			free(pr->ps_ptstat, M_SUBPROC);
		pool_put(&rusage_pool, pr->ps_ru);
		KASSERT(TAILQ_EMPTY(&pr->ps_threads));
		limfree(pr->ps_limit);
		crfree(pr->ps_cred->pc_ucred);
		pool_put(&pcred_pool, pr->ps_cred);
		pool_put(&process_pool, pr);
		nprocesses--;
	}
d672 1
a672 3
	freepid(p->p_pid);
	pool_put(&proc_pool, p);
	nthreads--;
@


1.129
log
@Move the declarations for dogetrusage(), itimerround(), and dowait4()
to sys/*.h headers so that the compat/linux code can use them.
Change dowait4() to not copyout() the status value, but rather leave
that for its caller, as compat/linux has to translate it, with the
side benefit of simplifying the native code.

Originally written months ago as part of the time_t work; long
memory, prodding, and ok from pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.128 2013/10/08 03:50:07 guenther Exp $	*/
d619 8
a627 8

	/*
	 * Release reference to text vnode
	 */
	otvp = p->p_textvp;
	p->p_textvp = NULL;
	if (otvp)
		vrele(otvp);
@


1.128
log
@Fix delivery of SIGPROF and SIGVTALRM to threaded processes by having
hardclock() set a flag on the running thread and force AST processing,
and then have the thread signal itself from userret().

idea and flag names from FreeBSD
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.127 2013/09/14 01:35:00 guenther Exp $	*/
a441 3
int	dowait4(struct proc *, pid_t, int *, int, struct rusage *,
	    register_t *);

d452 1
a452 1
	int error;
d454 2
a455 1
	error = dowait4(q, SCARG(uap, pid), SCARG(uap, status),
d457 3
d473 1
a473 1
	int status, error;
d503 2
a504 7
			if (statusp != NULL) {
				status = p->p_xstat;	/* convert to int */
				error = copyout(&status,
				    statusp, sizeof(status));
				if (error)
					return (error);
			}
d517 3
a519 7
			if (statusp != NULL) {
				status = W_STOPCODE(pr->ps_single->p_xstat);
				error = copyout(&status, statusp,
				    sizeof(status));
			} else
				error = 0;
			return (error);
d529 3
a531 7
			if (statusp != NULL) {
				status = W_STOPCODE(p->p_xstat);
				error = copyout(&status, statusp,
				    sizeof(status));
			} else
				error = 0;
			return (error);
d537 3
a539 7
			if (statusp != NULL) {
				status = _WCONTINUED;
				error = copyout(&status, statusp,
				    sizeof(status));
			} else
				error = 0;
			return (error);
@


1.127
log
@Snapshots for all archs have been built, so remove the T32 code
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.126 2013/08/13 05:52:23 guenther Exp $	*/
a187 2
		timeout_del(&pr->ps_virt_to);
		timeout_del(&pr->ps_prof_to);
@


1.126
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.125 2013/06/05 00:53:26 tedu Exp $	*/
a465 25

#ifdef T32
int
t32_sys_wait4(struct proc *q, void *v, register_t *retval)
{
	struct t32_sys_wait4_args /* {
		syscallarg(pid_t) pid;
		syscallarg(int *) status;
		syscallarg(int) options;
		syscallarg(struct rusage32 *) rusage;
	} */ *uap = v;
	struct rusage ru;
	int error;

	error = dowait4(q, SCARG(uap, pid), SCARG(uap, status),
	    SCARG(uap, options), SCARG(uap, rusage) ? &ru : NULL, retval);
	if (error == 0 && SCARG(uap, rusage)) {
		struct rusage32 ru32;

		RUSAGE_TO_32(&ru32, &ru);
		error = copyout(&ru32, SCARG(uap, rusage), sizeof(ru32));
	}
	return (error);
}
#endif
@


1.125
log
@factor out pid allocation to functions. add a small cache of recently
exited pids that won't get recycled.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.124 2013/06/01 04:05:26 tedu Exp $	*/
d444 3
d456 40
d501 3
a503 3
	if (SCARG(uap, pid) == 0)
		SCARG(uap, pid) = -q->p_p->ps_pgid;
	if (SCARG(uap, options) &~ (WUNTRACED|WNOHANG|WALTSIG|WCONTINUED))
d511 3
a513 3
		    (SCARG(uap, pid) != WAIT_ANY &&
		    p->p_pid != SCARG(uap, pid) &&
		    pr->ps_pgid != -SCARG(uap, pid)))
d521 1
a521 1
		if ((SCARG(uap, options) & WALTSIG) ?
d529 1
a529 1
			if (SCARG(uap, status)) {
d532 1
a532 1
				    SCARG(uap, status), sizeof(status));
d536 2
a537 4
			if (SCARG(uap, rusage) &&
			    (error = copyout(pr->ps_ru,
			    SCARG(uap, rusage), sizeof(struct rusage))))
				return (error);
d548 1
a548 1
			if (SCARG(uap, status)) {
d550 1
a550 1
				error = copyout(&status, SCARG(uap, status),
d560 1
a560 1
		    SCARG(uap, options) & WUNTRACED)) {
d564 1
a564 1
			if (SCARG(uap, status)) {
d566 1
a566 1
				error = copyout(&status, SCARG(uap, status),
d572 1
a572 1
		if ((SCARG(uap, options) & WCONTINUED) && (p->p_flag & P_CONTINUED)) {
d576 1
a576 1
			if (SCARG(uap, status)) {
d578 1
a578 1
				error = copyout(&status, SCARG(uap, status),
d587 1
a587 1
	if (SCARG(uap, options) & WNOHANG) {
@


1.124
log
@some small style changes that are distracting me from seeing a real bug
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.123 2013/05/07 19:26:25 guenther Exp $	*/
d647 1
@


1.123
log
@Merge from FreeBSD, r191313
---------------------------
On the exit of the child process which parent either set SA_NOCLDWAIT
or ignored SIGCHLD, unconditionally wake up the parent instead of doing
this only when the child is a last child.

This brings us in line with other U**xes that support SA_NOCLDWAIT. If
the parent called waitpid(childpid), then exit of the child should wake
up the parent immediately instead of forcing it to wait for all children
to exit.
---------------------------

ok tedu@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.122 2013/04/06 03:44:34 tedu Exp $	*/
d101 1
a101 1
		if (copyout(&zero, SCARG(uap, notdead), sizeof(zero))) {
a102 1
		}
d131 1
a131 1
	    TAILQ_NEXT(p, p_thr_link) == NULL)
d133 1
a133 1
	else {
d161 1
a161 1
		while (! TAILQ_EMPTY(&pr->ps_threads))
d165 1
a165 1
	} else if (TAILQ_EMPTY(&pr->ps_threads))
d167 1
d172 1
a172 2

		if (pr->ps_ru == NULL)
d174 1
a174 1
		else {
d207 1
a207 1
					(void) ttywait(sp->s_ttyp);
d232 1
a232 1
		(void)acct_process(p);
@


1.122
log
@rthreads are always enabled. remove the sysctl.
ok deraadt guenther kettenis matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.121 2013/03/30 06:32:25 tedu Exp $	*/
d331 1
d333 2
a334 2
			 * If this was the last child of our parent, notify
			 * parent, so in case he was wait(2)ing, he will
d337 1
a337 2
			if (LIST_EMPTY(&ppr->ps_children))
				wakeup(ppr);
@


1.121
log
@vrele() is a tricky beast. it can sleep if the refcount hits zero,
leaving us with a free type function that isn't atomic. deal with this
by erasing any reachable pointers to the vnode first, then free it.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.120 2013/03/28 16:55:25 deraadt Exp $	*/
a97 3

	if (!rthreads_enabled)
		return (EINVAL);
@


1.120
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.119 2012/09/08 14:52:00 kettenis Exp $	*/
d123 1
d220 1
a220 2
				if (sp->s_ttyvp)
					vrele(sp->s_ttyvp);
d222 2
d609 1
d630 4
a633 2
	if (p->p_textvp)
		vrele(p->p_textvp);
@


1.119
log
@Plug a race where we're trying to kill a traced process while it is aleady
exiting.  At that point ps_single may point to a proc that's already freed.
Since there is no point in killing a process that's already exiting, just
skip this step.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.118 2012/08/02 03:18:48 guenther Exp $	*/
a72 1
#include <machine/cpu.h>
@


1.118
log
@Apply profiling to all threads instead of just the thread that called
profil() by moving P_PROFIL from proc->p_flag to process->ps_flags with
matching adjustment in fork1() and exit1()

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.117 2012/07/11 08:45:21 guenther Exp $	*/
d283 2
a284 2
			 * Traced processes are killed
			 * since their existence means someone is screwing up.
d286 2
a287 1
			if (qr->ps_flags & PS_TRACED) {
@


1.117
log
@exit1(EXIT_THREAD) needs to call single_thread_check() so that it
can be suspended and/or decrement pr->ps_singlecount if necessary.
With that added, the call the other direction needs to use its own
flag (EXIT_THREAD_NOCHECK) to avoid looping.

problem diagnosed from a hang naddy@@ hit; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.116 2012/07/09 23:06:07 guenther Exp $	*/
d167 2
a171 2
	if (p->p_flag & P_PROFIL)
		stopprofclock(p);
@


1.116
log
@The linux emulation exit hook needs to be able to sleep, so call it
before changing p_stat to SDEAD

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.115 2012/04/14 14:26:39 kettenis Exp $	*/
d141 2
@


1.115
log
@If single threading is active, drirect the SIGKILL signal we send to orphaned
traced processes to the active thread, otherwise we will deadlock resulting
in an unkillable stopped process.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.114 2012/04/13 19:18:24 kettenis Exp $	*/
d247 7
a347 6

	/*
	 * If emulation has process exit hook, call it now.
	 */
	if (p->p_emul->e_proc_exit)
		(*p->p_emul->e_proc_exit)(p);
@


1.114
log
@Backout a tiny part of the previous commit.  Decrementing ps_singlecount in
exit1() is wrong, since single_thread_check() already decrements it and may
call exit1() after that.  I can't reproduce the hang that this was supposed
to fix anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.113 2012/04/13 16:37:51 kettenis Exp $	*/
d279 10
a288 1
				prsignal(qr, SIGKILL);
@


1.113
log
@First stab at making ptrace(2) usable for debugging multi-threaded programs.
It implements a full-stop model where all threads are stopped before handing
over control to the debugger.  Events are reported as before through wait(2);
you will have to call ptrace(PT_GET_PROCESS_STATE, ...) to find out which
thread hit the event.  Since this changes the size of struct ptrace_state,
you will have to recompile gdb.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.112 2012/04/11 15:28:50 kettenis Exp $	*/
a160 4
	if (ISSET(p->p_flag, P_SUSPSINGLE)) {
		if (--pr->ps_singlecount == 0)
			wakeup(&pr->ps_singlecount);
	}
@


1.112
log
@Move the P_WAITED flag from struct proc to struct process.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.111 2012/04/10 15:50:52 guenther Exp $	*/
d161 4
d493 15
@


1.111
log
@Make the KERN_NPROCS and KERN_MAXPROC sysctl()s and the RLIMIT_NPROC rlimit
count processes instead of threads.  New sysctl()s KERN_NTHREADS and
KERN_MAXTHREAD count and limit threads.  The nprocs and maxproc kernel
variables are replaced by nprocess, maxprocess, nthreads, and maxthread.

ok tedu@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.110 2012/04/06 02:18:49 guenther Exp $	*/
d491 2
a492 1
		    (p->p_flag & (P_WAITED|P_SUSPSINGLE)) == 0 &&
d495 1
a495 1
			atomic_setbits_int(&p->p_flag, P_WAITED);
@


1.110
log
@ruadd() does the summing of system and user times, so doing so again
results in bogus total times, as reported by numerous ports people.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.109 2012/03/23 15:51:26 guenther Exp $	*/
d587 1
a587 1
	if ((p->p_flag & P_THREAD) == 0)
d590 5
a594 4
	/*
	 * Decrement the count of procs running with this uid.
	 */
	(void)chgproccnt(p->p_cred->p_ruid, -1);
d615 1
d619 1
a619 1
	nprocs--;
@


1.109
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.108 2012/03/10 05:54:28 guenther Exp $	*/
a299 2
		timeradd(&rup->ru_utime, &pr->ps_cru.ru_utime, &rup->ru_utime);
		timeradd(&rup->ru_stime, &pr->ps_cru.ru_stime, &rup->ru_stime);
a552 2
		timeradd(&rup->ru_utime, &pr->ps_ru->ru_utime, &rup->ru_utime);
		timeradd(&rup->ru_stime, &pr->ps_ru->ru_stime, &rup->ru_stime);
@


1.108
log
@Add PS_EXITING to better differentiate between the process exiting and
the main thread exiting.  c.f. regress/sys/kern/main-thread-exited/
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.107 2012/02/20 22:23:39 guenther Exp $	*/
d123 1
d170 11
a180 1
	p->p_ru = pool_get(&rusage_pool, PR_WAITOK);
a181 3
	timeout_del(&p->p_realit_to);
	timeout_del(&p->p_stats->p_virt_to);
	timeout_del(&p->p_stats->p_prof_to);
d189 3
d285 2
a286 7
	/*
	 * Save exit status and final rusage info, adding in child rusage
	 * info and self times.
	 */
	*p->p_ru = p->p_stats->p_ru;
	calcru(p, &p->p_ru->ru_utime, &p->p_ru->ru_stime, NULL);
	ruadd(p->p_ru, &p->p_stats->p_cru);
d294 9
d486 1
a486 1
			    (error = copyout(p->p_ru,
d535 1
d553 4
a556 1
		ruadd(&waiter->p_stats->p_cru, p->p_ru);
a583 4
	pool_put(&rusage_pool, p->p_ru);
	if ((p->p_flag & P_THREAD) == 0 && pr->ps_ptstat)
		free(pr->ps_ptstat, M_SUBPROC);

d610 3
@


1.107
log
@First steps for making ptrace work with rthreads:
 - move the P_TRACED and P_INEXEC flags, and p_oppid, p_ptmask, and
   p_ptstat member from struct proc to struct process
 - sort the PT_* requests into those that take a PID vs those that
   can also take a TID
 - stub in PT_GET_THREAD_FIRST and PT_GET_THREAD_NEXT

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.106 2012/01/17 02:34:18 guenther Exp $	*/
d143 1
@


1.106
log
@Reimplement mutexes, condvars, and rwlocks to eliminate bugs,
particularly the "consume the signal you just sent" hang, and putting
the wait queues in userspace.

Do cancellation handling in pthread_cond_*wait(), pthread_join(),
and sem_wait().

Add __ prefix to thr{sleep,wakeup,exit,sigdivert}() syscalls; add
'abort" argument to thrsleep to close cancellation race; make
thr{sleep,wakeup} return errno values via *retval to avoid touching
userspace errno.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.105 2011/12/14 07:32:16 guenther Exp $	*/
d265 2
a266 3
			if (qr->ps_mainproc->p_flag & P_TRACED) {
				atomic_clearbits_int(&qr->ps_mainproc->p_flag,
				    P_TRACED);
d478 2
a479 1
		    (p->p_flag & P_TRACED || SCARG(uap, options) & WUNTRACED)) {
d518 1
a518 1
	struct process *tr;
d524 6
a529 4
	if (p->p_oppid && (tr = prfind(p->p_oppid))) {
		atomic_clearbits_int(&p->p_flag, P_TRACED);
		p->p_oppid = 0;
		proc_reparent(p->p_p, tr);
d565 2
a566 2
	if (p->p_ptstat)
		free(p->p_ptstat, M_SUBPROC);
@


1.105
log
@Handle rthreads consistently in ktrace by moving the flags and vnode into
struct process; KTRFAC_ACTIVE becomes P_INKTR.  Also, save the credentials
used to open the file in sys_ktrace() and use them for all writes to the
vnode.

much feedback and ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.104 2011/12/11 19:42:28 guenther Exp $	*/
d94 1
a94 1
sys_threxit(struct proc *p, void *v, register_t *retval)
d96 1
a96 1
	struct sys_threxit_args /* {
@


1.104
log
@Suspend other rthreads before dumping core or execing; make them exit
when exec succeeds.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.103 2011/07/25 19:38:53 tedu Exp $	*/
a222 1
	}
d225 3
a227 6
	/* 
	 * release trace file
	 */
	p->p_traceflag = 0;	/* don't trace the vrele() */
	if (p->p_tracep)
		ktrsettracevnode(p, NULL);
d229 2
@


1.103
log
@sys_wait4 properly returns int.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.102 2011/07/06 21:41:37 art Exp $	*/
a121 1
	struct proc *q, *nq;
a129 1
	/* unlink ourselves from the active threads */
d131 12
a142 15
	TAILQ_REMOVE(&pr->ps_threads, p, p_thr_link);
	if (TAILQ_EMPTY(&pr->ps_threads))
		wakeup(&pr->ps_threads);
	/*
	 * if one thread calls exit, we take down everybody.
	 * we have to be careful not to get recursively caught.
	 * this is kinda sick.
	 */
	if (flags == EXIT_NORMAL && (p->p_flag & P_THREAD) &&
	    (pr->ps_mainproc->p_flag & P_WEXIT) == 0) {
		/*
		 * we are one of the threads.  we SIGKILL the parent,
		 * it will wake us up again, then we proceed.
		 */
		atomic_setbits_int(&pr->ps_mainproc->p_flag, P_IGNEXITRV);
d144 1
a144 15
		ptsignal(pr->ps_mainproc, SIGKILL, SPROPAGATED);
		tsleep(pr, PUSER, "thrdying", 0);
	} else if ((p->p_flag & P_THREAD) == 0) {
		if (flags == EXIT_NORMAL) {
			q = TAILQ_FIRST(&pr->ps_threads);
			for (; q != NULL; q = nq) {
				nq = TAILQ_NEXT(q, p_thr_link);
				atomic_setbits_int(&q->p_flag, P_IGNEXITRV);
				q->p_xstat = rv;
				ptsignal(q, SIGKILL, SPROPAGATED);
			}
		}
		wakeup(pr);
		while (!TAILQ_EMPTY(&pr->ps_threads))
			tsleep(&pr->ps_threads, PUSER, "thrdeath", 0);
d157 9
a279 2
	if (!(p->p_flag & P_IGNEXITRV))
		p->p_xstat = rv;
d479 2
a480 1
		if (p->p_stat == SSTOP && (p->p_flag & P_WAITED) == 0 &&
@


1.102
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.101 2011/07/05 04:48:02 guenther Exp $	*/
d435 1
a435 1
pid_t
@


1.101
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.100 2011/04/18 21:44:56 guenther Exp $	*/
d396 1
a396 1
	KERNEL_PROC_UNLOCK(curproc);
d409 1
a409 1
		KERNEL_PROC_LOCK(curproc);
d431 1
a431 1
		KERNEL_PROC_UNLOCK(curproc);
@


1.100
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.98 2011/04/03 14:56:28 guenther Exp $	*/
a178 1
	p->p_sigignore = ~0;
d307 1
a307 1
		 * or parent has the P_NOCLDWAIT flag set, notify process 1
d311 2
a312 1
		    (pr->ps_pptr->ps_mainproc->p_flag & P_NOCLDWAIT)) {
@


1.99
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d179 1
d308 1
a308 1
		 * or parent has the SAS_NOCLDWAIT flag set, notify process 1
d312 1
a312 2
		    (pr->ps_pptr->ps_mainproc->p_sigacts->ps_flags &
		    SAS_NOCLDWAIT)) {
@


1.98
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.97 2010/08/02 19:54:07 guenther Exp $	*/
a178 1
	p->p_sigignore = ~0;
d307 1
a307 1
		 * or parent has the P_NOCLDWAIT flag set, notify process 1
d311 2
a312 1
		    (pr->ps_pptr->ps_mainproc->p_flag & P_NOCLDWAIT)) {
@


1.97
log
@Fix knote handling for exiting processes: when triggering a NOTE_EXIT
knote, remove it from the process's klist; after handling those,
remove and drop any remaining knotes from the process's klist.  Ban
attaching knotes to processes that have started exiting or attaching
them via the pid of a thread other than the main thread.

ok tedu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.96 2010/07/26 01:56:27 guenther Exp $	*/
d165 1
a165 1
		 * If parent is waiting for us to exit or exec, P_PPWAIT
d168 4
a171 2
		if (p->p_flag & P_PPWAIT) {
			atomic_clearbits_int(&p->p_flag, P_PPWAIT);
@


1.96
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.95 2010/07/19 23:00:15 guenther Exp $	*/
d301 2
a302 2
		/* notify interested parties of our demise */
		KNOTE(&pr->ps_klist, NOTE_EXIT);
@


1.95
log
@Rollback the allproclk and fileheadlk addition.  When grabbing an
rwlock, the thread will release biglock if it sleeps, means that
atomicity from before the rw_enter() to after it is not guaranteed.
The change didn't address those, so pulling it until it does.

"go for it" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.94 2010/06/29 20:25:57 guenther Exp $	*/
d123 1
d129 2
d132 4
a135 3
	TAILQ_REMOVE(&p->p_p->ps_threads, p, p_thr_link);
	if (TAILQ_EMPTY(&p->p_p->ps_threads))
		wakeup(&p->p_p->ps_threads);
d142 1
a142 1
	    (p->p_p->ps_mainproc->p_flag & P_WEXIT) == 0) {
d147 4
a150 4
		atomic_setbits_int(&p->p_p->ps_mainproc->p_flag, P_IGNEXITRV);
		p->p_p->ps_mainproc->p_xstat = rv;
		ptsignal(p->p_p->ps_mainproc, SIGKILL, SPROPAGATED);
		tsleep(p->p_p, PUSER, "thrdying", 0);
a151 1
		atomic_setbits_int(&p->p_flag, P_WEXIT);
d153 1
a153 1
			q = TAILQ_FIRST(&p->p_p->ps_threads);
d161 11
a171 3
		wakeup(p->p_p);
		while (!TAILQ_EMPTY(&p->p_p->ps_threads))
			tsleep(&p->p_p->ps_threads, PUSER, "thrdeath", 0);
a176 9
	/*
	 * If parent is waiting for us to exit or exec, P_PPWAIT is set; we
	 * wake up the parent early to avoid deadlock.
	 */
	atomic_setbits_int(&p->p_flag, P_WEXIT);
	if (p->p_flag & P_PPWAIT) {
		atomic_clearbits_int(&p->p_flag, P_PPWAIT);
		wakeup(p->p_pptr);
	}
d188 1
d190 1
a190 2
	if ((p->p_flag & P_THREAD) == 0)
		semexit(p->p_p);
d192 2
a193 2
	if (SESS_LEADER(p)) {
		struct session *sp = p->p_session;
d195 1
a195 11
		if (sp->s_ttyvp) {
			/*
			 * Controlling process.
			 * Signal foreground pgrp,
			 * drain controlling terminal
			 * and revoke access to controlling terminal.
			 */
			if (sp->s_ttyp->t_session == sp) {
				if (sp->s_ttyp->t_pgrp)
					pgsignal(sp->s_ttyp->t_pgrp, SIGHUP, 1);
				(void) ttywait(sp->s_ttyp);
d197 4
a200 2
				 * The tty could have been revoked
				 * if we blocked.
d202 13
d216 8
a223 1
					VOP_REVOKE(sp->s_ttyvp, REVOKEALL);
d225 1
a225 8
			if (sp->s_ttyvp)
				vrele(sp->s_ttyvp);
			sp->s_ttyvp = NULL;
			/*
			 * s_ttyp is not zero'd; we use this to indicate
			 * that the session once had a controlling terminal.
			 * (for logging and informational purposes)
			 */
d227 2
a228 3
		sp->s_leader = NULL;
	}
	fixjobc(p, p->p_pgrp, 0);
d230 1
a230 1
	(void)acct_process(p);
d232 2
d265 16
a280 13
	q = LIST_FIRST(&p->p_children);
	if (q)		/* only need this if any child is S_ZOMB */
		wakeup(initproc);
	for (; q != 0; q = nq) {
		nq = LIST_NEXT(q, p_sibling);
		proc_reparent(q, initproc);
		/*
		 * Traced processes are killed
		 * since their existence means someone is screwing up.
		 */
		if (q->p_flag & P_TRACED) {
			atomic_clearbits_int(&q->p_flag, P_TRACED);
			psignal(q, SIGKILL);
d300 3
a302 5
	/*
	 * notify interested parties of our demise.
	 */
	if (p == p->p_p->ps_mainproc)
		KNOTE(&p->p_p->ps_klist, NOTE_EXIT);
a303 8
	/*
	 * Notify parent that we're gone.  If we have P_NOZOMBIE or parent has
	 * the P_NOCLDWAIT flag set, notify process 1 instead (and hope it
	 * will handle this situation).
	 */
	if ((p->p_flag & P_NOZOMBIE) || (p->p_pptr->p_flag & P_NOCLDWAIT)) {
		struct proc *pp = p->p_pptr;
		proc_reparent(p, initproc);
d305 3
a307 3
		 * If this was the last child of our parent, notify
		 * parent, so in case he was wait(2)ing, he will
		 * continue.
d309 12
a320 2
		if (LIST_EMPTY(&pp->p_children))
			wakeup(pp);
d421 1
a421 1
				psignal(p->p_pptr, P_EXITSIG(p));
d423 1
a423 1
			wakeup(p->p_pptr);
d443 1
d448 1
a448 1
		SCARG(uap, pid) = -q->p_pgid;
d454 2
a455 1
	LIST_FOREACH(p, &q->p_children, p_sibling) {
d459 1
a459 1
		    p->p_pgid != -SCARG(uap, pid)))
d521 1
a521 1
	if ((error = tsleep(q, PWAIT | PCATCH, "wait", 0)) != 0)
d529 1
a529 1
	struct proc *t;
d535 1
a535 1
	if (p->p_oppid && (t = pfind(p->p_oppid))) {
d538 1
a538 1
		proc_reparent(p, t);
d540 2
a541 2
			psignal(t, p->p_exitsig);
		wakeup(t);
d554 1
a554 1
proc_reparent(struct proc *child, struct proc *parent)
d557 1
a557 1
	if (child->p_pptr == parent)
d560 2
a561 2
	if (parent == initproc)
		child->p_exitsig = SIGCHLD;
d563 3
a565 3
	LIST_REMOVE(child, p_sibling);
	LIST_INSERT_HEAD(&parent->p_children, child, p_sibling);
	child->p_pptr = parent;
d571 1
a571 1
	struct process *pr;
d581 2
a582 1
	leavepgrp(p);
d584 2
a585 1
	LIST_REMOVE(p, p_sibling);
a601 1
	pr = p->p_p;
a612 1

@


1.94
log
@We always copy struct pcred when creating a new process, so the reference
count was always one.  That's pointless, so remove the member and the code.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.93 2010/06/29 00:28:14 tedu Exp $	*/
a244 1
	rw_enter_write(&allproclk);
a252 1
	rw_exit_write(&allproclk);
a568 1
	rw_enter_write(&allproclk);
a569 1
	rw_exit_write(&allproclk);
@


1.93
log
@Eliminate RTHREADS kernel option in favor of a sysctl.  The actual status
(not done) hasn't changed, but now it's less work to test things.
ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.92 2010/05/26 15:16:57 oga Exp $	*/
d560 2
d591 7
a597 8
	if (--p->p_p->ps_refcnt == 0) {
		KASSERT(TAILQ_EMPTY(&p->p_p->ps_threads));
		limfree(p->p_p->ps_limit);
		if (--p->p_p->ps_cred->p_refcnt == 0) {
			crfree(p->p_p->ps_cred->pc_ucred);
			pool_put(&pcred_pool, p->p_p->ps_cred);
		}
		pool_put(&process_pool, p->p_p);
@


1.92
log
@Bad tedu, no cookie.

Don't set SDEAD on the process in exit1 untile we have grabbed the
allproclk.  allproclk is a rwlock and thus we may sleep to grab hold of
it. This is a big of a bugger when we just set a flag that means we
panic if we sleep.

ok art@@. turns Tom Murphy's fstat panic into a deadlock instead *sigh*,
this is being looked into.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.91 2010/05/18 22:26:10 tedu Exp $	*/
a92 1
#ifdef RTHREADS
d100 3
a112 1
#endif
a129 1
#ifdef RTHREADS
a161 1
#endif
@


1.91
log
@move knote list to struct process.  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.90 2010/03/24 23:18:17 tedu Exp $	*/
a238 5
	/*
	 * NOTE: WE ARE NO LONGER ALLOWED TO SLEEP!
	 */
	p->p_stat = SDEAD;

d247 5
@


1.90
log
@Add a rwlock around the filehead and allproc lists, mainly to protect
list walkers in sysctl that can block.  As a reward, no more vslock.
With some feedback from art, guenther, phessler.  ok guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.89 2009/12/20 23:54:11 guenther Exp $	*/
d295 2
a296 1
	KNOTE(&p->p_klist, NOTE_EXIT);
@


1.89
log
@When using ptrace(), death of the traced process should always send
SIGCHLD to the tracer, even if the real parent requested an alternate
exit signal.  So, delay clearing the P_TRACED flag from exit1() to
sys_wait4() so that we don't send the wrong signal from reaper().

Originally discussed with kurt months ago
"looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.88 2009/12/20 23:36:04 guenther Exp $	*/
d251 1
d255 1
d569 1
d571 1
@


1.88
log
@svr4_sys_waitsys() was seemingly implemented by copying sys_wait4()
and hacking on it.  Since then, some of the details of finishing a
wait have changed (p_exitsig handling), so factor out the common
bit into into proc_finish_wait() and have both sys_wait4() and
svr4_sys_waitsys() call that to kill the divergence.

"looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.87 2009/11/27 19:42:24 guenther Exp $	*/
a171 1
	atomic_clearbits_int(&p->p_flag, P_TRACED);
d523 1
@


1.87
log
@Change threxit() to take a pointer to a pid_t to zero out from the
kernel so that librthread can detect when a thread is completely
done with its stack without need a kqueue.  The dying thread moves
itself to a GC list, other threads scan the GC list on pthread_create()
and pthread_join() and free the stack and handle once the thread's
thread id is zeroed.

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.86 2009/10/05 17:43:07 deraadt Exp $	*/
d433 1
a433 1
	struct proc *p, *t;
d474 1
a474 20

			/*
			 * If we got the child via a ptrace 'attach',
			 * we need to give it back to the old parent.
			 */
			if (p->p_oppid && (t = pfind(p->p_oppid))) {
				p->p_oppid = 0;
				proc_reparent(p, t);
				if (p->p_exitsig != 0)
					psignal(t, P_EXITSIG(p));
				wakeup(t);
				return (0);
			}

			scheduler_wait_hook(q, p);
			p->p_xstat = 0;
			ruadd(&q->p_stats->p_cru, p->p_ru);

			proc_zap(p);

d512 23
@


1.86
log
@Don't drop the big lock at the end of exit1(), but move it into the middle of
sched_exit().  This means that cpu_exit() and whatever it does (for instance
calling free(), as well as the deadproc p_hash handling are now locked as well.
This may have been one of the causes of the reaper panics, especially with
rthread patches... which were terminating a lot of threads very quickly onto
the deadproc p_hash list.
ok kurt kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.85 2009/06/24 13:03:20 kurt Exp $	*/
d98 1
a98 1
		syscallarg(int) rval;
d101 7
a107 1
	exit1(p, W_EXITCODE(SCARG(uap, rval), 0), EXIT_THREAD);
@


1.85
log
@Remove extra psignal/wakeup in exit1() which can cause the parent to
receive SIGCHLD twice if scheduled before the reaper runs. diff by
guenther@@ and myself. okay guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.84 2009/04/03 04:22:49 guenther Exp $	*/
a320 3

	/* This process no longer needs to hold the kernel lock. */
	KERNEL_PROC_UNLOCK(p);
@


1.84
log
@Fix SEM_UNDO handling for rthreads: use the struct process* instead
of the struct proc* as the identifier for SEM_UNDO tracking and only
call semexit() from the original thread, once the process as a whole
is exiting

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.83 2009/03/26 17:24:33 oga Exp $	*/
a306 4
	if (p->p_exitsig != 0)
		psignal(p->p_pptr, P_EXITSIG(p));
	wakeup(p->p_pptr);

d407 2
a409 1
			psignal(p->p_pptr, SIGCHLD);
@


1.83
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.82 2008/12/16 07:57:28 guenther Exp $	*/
a62 3
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
d183 2
a184 1
	semexit(p);
@


1.82
log
@Move the functionality of psignal() to a new function ptsignal()
that takes an additional argument "type" that indicates whether the
signal is for the process, just a particular thread, or propagated
to a thread because it's not caught or blocked.  psignal() becomes
a wrapper that does the first of those.

So that sys_kill() can tell apart signals for the process and signals
for the process's original thread, the tid of the original thread
is defined as its pid + THREAD_PID_OFFSET.

ok tedu@@ art@@ andreas@@ kurt@@   "better early than late" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.81 2008/12/11 16:31:47 deraadt Exp $	*/
a400 8

		/*
		 * Give machine-dependent code a chance to free any
		 * resources it couldn't free while still running on
		 * that process's context.  This must be done before
		 * uvm_exit(), in case these resources are in the PCB.
		 */
		cpu_wait(p);
@


1.81
log
@a little bit of paranoia
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.80 2008/11/06 21:47:50 deraadt Exp $	*/
d100 3
a102 1
	struct sys_threxit_args *uap = v;
d134 1
a134 1
	if (flags == EXIT_NORMAL && p->p_p->ps_mainproc != p &&
d142 1
a142 1
		psignal(p->p_p->ps_mainproc, SIGKILL);
d144 1
a144 1
	} else if (p == p->p_p->ps_mainproc) {
d152 1
a152 1
				psignal(q, SIGKILL);
@


1.80
log
@remove a really stupid comment.  Duh, of course it can block
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.79 2008/10/31 17:17:01 deraadt Exp $	*/
d341 1
@


1.79
log
@accidental commit ... backout
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.77 2008/10/30 17:09:13 deraadt Exp $	*/
a179 1
	 * This may block!
@


1.78
log
@kern_sysctl.c
@
text
@d228 2
a229 6
	if (p->p_tracep) {
		struct vnode *vp = p->p_tracep;
		if (ktrsettracevnode(p, NULL) == 1)
			vrele(vp);
	}
		
@


1.77
log
@Use msleep() in the reaper to make it not lose events.  Based on discussion
PR 5609, and revisited with dlg.  Tested on all platforms.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.76 2008/10/14 18:27:29 guenther Exp $	*/
d228 6
a233 2
	if (p->p_tracep)
		ktrsettracevnode(p, NULL);
@


1.76
log
@Back-in; problems were apparently elsewhere.
Put a reference count in struct process to prevent use-after-free
if the main thread reaches the reaper ahead of some other thread
in the process.  Use the reference count to update the user process
count correctly when changin real uid.

"please re-commit before something else nasty comes in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.75 2008/10/10 14:35:06 deraadt Exp $	*/
d391 2
a392 7
		p = LIST_FIRST(&deadproc);
		if (p == NULL) {
			/* No work for us; go to sleep until someone exits. */
			mtx_leave(&deadproc_mutex);
			(void) tsleep(&deadproc, PVM, "reaper", 0);
			continue;
		}
d397 1
@


1.75
log
@backout; is causing some people difficulty
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.73 2008/05/11 23:54:40 tedu Exp $	*/
d593 1
a593 1
	if ((p->p_flag & P_THREAD) == 0) {
@


1.74
log
@Put a reference count in struct process to prevent use-after-free
if the main thread reaches the reaper ahead of some other thread
in the process.

ok art@@ tedu@@
@
text
@d593 1
a593 1
	if (--p->p_p->ps_refcnt == 0) {
@


1.73
log
@set p_flag to 0 sooner, so we don't overwrite the thread flag.  and correctly
free things when exiting a threaded proc.  from philip guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.72 2007/10/10 15:53:53 art Exp $	*/
d593 1
a593 1
	if ((p->p_flag & P_THREAD) == 0) {
@


1.72
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.71 2007/04/12 22:14:15 tedu Exp $	*/
d593 2
a594 4
#if 0
	TAILQ_REMOVE(&p->p_p->ps_threads, p, p_thr_link);
#endif
	if (TAILQ_EMPTY(&p->p_p->ps_threads)) {
@


1.71
log
@move p_limit and p_cred into struct process
leave macros behind for now to keep the commit small
ok art beck miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.70 2007/04/11 14:27:08 tedu Exp $	*/
d318 1
a318 8
	 * Clear curproc after we've done all operations
	 * that could block, and before tearing down the rest
	 * of the process state that might be used from clock, etc.
	 * Also, can't clear curproc while we're still runnable,
	 * as we're not on a run queue (we are current, just not
	 * a proper proc any longer!).
	 *
	 * Other substructures are freed from wait().
a319 1
	curproc = NULL;
a367 2
	int s;

a372 2

	SCHED_LOCK(s);
d386 2
@


1.70
log
@remove proc from process thread list sooner in exit (notably, before waiting
for the list to become empty)
ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.69 2007/04/10 21:09:42 tedu Exp $	*/
a327 2
	limfree(p->p_limit);
	p->p_limit = NULL;
a593 8
	 * Free up credentials.
	 */
	if (--p->p_cred->p_refcnt == 0) {
		crfree(p->p_cred->pc_ucred);
		pool_put(&pcred_pool, p->p_cred);
	}

	/*
d606 6
a611 1
	if (TAILQ_EMPTY(&p->p_p->ps_threads))
d613 1
@


1.69
log
@undo
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.67 2007/04/05 02:31:48 tedu Exp $	*/
d122 2
d125 2
a147 6

				/*
				 * Don't shoot ourselves again.
				 */
				if (q == p)
					continue;
a269 6
	/* unlink ourselves from the active threads */
	TAILQ_REMOVE(&p->p_p->ps_threads, p, p_thr_link);
#ifdef RTHREADS
	if (TAILQ_EMPTY(&p->p_p->ps_threads))
		wakeup(&p->p_p->ps_threads);
#endif
@


1.68
log
@remove process from thread list sooner in exit (notably, before waiting
for the list to become empty)
@
text
@a121 2
	/* unlink ourselves from the active threads */
	TAILQ_REMOVE(&p->p_p->ps_threads, p, p_thr_link);
a122 2
	if (TAILQ_EMPTY(&p->p_p->ps_threads))
		wakeup(&p->p_p->ps_threads);
d144 6
d272 6
@


1.67
log
@jason crawford noticed that the rthreads diff didn't compile with rthreads!
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.66 2007/04/04 14:40:55 pedro Exp $	*/
d122 2
d125 2
a147 6

				/*
				 * Don't shoot ourselves again.
				 */
				if (q == p)
					continue;
a269 6
	/* unlink ourselves from the active threads */
	TAILQ_REMOVE(&p->p_p->ps_threads, p, p_thr_link);
#ifdef RTHREADS
	if (TAILQ_EMPTY(&p->p_p->ps_threads))
		wakeup(&p->p_p->ps_threads);
#endif
@


1.66
log
@oursleves -> ourselves
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.65 2007/04/04 14:34:56 pedro Exp $	*/
d134 1
a134 1
		atomic_setbits_int(&p->p_thrparent->p_flag, P_IGNEXITRV);
@


1.65
log
@Don't remove the process from the threads queue in proc_zap() as that
currently already happens in exit1(), okay art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.64 2007/04/03 08:05:43 art Exp $	*/
d272 1
a272 1
	/* unlink oursleves from the active threads */
@


1.64
log
@Start moving state that is shared among threads in a process into
a new struct. Instead of doing a huge rename and deal with the fallout
for weeks, like other projects that need no mention, we will slowly and
carefully move things out of struct proc into a new struct process.

 - Create struct process and the infrastructure to create and remove them.
 - Move threads in a process into struct process.

deraadt@@, tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.63 2007/03/15 10:22:30 art Exp $	*/
d621 1
a621 1

d623 1
@


1.63
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.62 2006/06/23 13:46:05 mickey Exp $	*/
d128 2
a129 2
	if (flags == EXIT_NORMAL && p != p->p_thrparent &&
	    (p->p_thrparent->p_flag & P_WEXIT) == 0) {
d135 4
a138 4
		p->p_thrparent->p_xstat = rv;
		psignal(p->p_thrparent, SIGKILL);
		tsleep(&p->p_thrparent->p_thrchildren, PUSER, "thrdying", 0);
	} else if (p == p->p_thrparent) {
d141 1
a141 1
			q = LIST_FIRST(&p->p_thrchildren);
d143 7
a149 1
				nq = LIST_NEXT(q, p_thrsib);
d155 3
a157 3
		wakeup(&p->p_thrchildren);
		while (!LIST_EMPTY(&p->p_thrchildren))
			tsleep(&p->p_thrchildren, PUSER, "thrdeath", 0);
d272 2
d275 2
a276 6
	/* unlink oursleves from the active threads */
	if (p != p->p_thrparent) {
		LIST_REMOVE(p, p_thrsib);
		if (LIST_EMPTY(&p->p_thrparent->p_thrchildren))
			wakeup(&p->p_thrparent->p_thrchildren);
	}
d616 9
@


1.62
log
@consistantly count context switches on exit; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.61 2006/06/15 20:08:01 miod Exp $	*/
d134 1
a134 1
		p->p_thrparent->p_flag |= P_IGNEXITRV;
d139 1
a139 1
		p->p_flag |= P_WEXIT;
d144 1
a144 1
				q->p_flag |= P_IGNEXITRV;
d162 2
a163 2
	p->p_flag |= P_WEXIT;
	p->p_flag &= ~P_TRACED;
d165 1
a165 1
		p->p_flag &= ~P_PPWAIT;
d261 1
a261 1
			q->p_flag &= ~P_TRACED;
d526 1
a526 1
			p->p_flag |= P_WAITED;
d538 1
a538 1
			p->p_flag &= ~P_CONTINUED;
@


1.61
log
@Nothing sets P_FSTRACE anymore, so remove all what's left of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.60 2006/04/06 21:43:28 mickey Exp $	*/
d354 1
@


1.60
log
@release kernel lock _after_ the emulation exit hook is called to protect possible free()s; tedu@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.59 2006/02/20 19:39:11 miod Exp $	*/
d312 1
a312 1
	if ((p->p_flag & P_FSTRACE) == 0 && p->p_exitsig != 0)
a314 6

	/*
	 * Notify procfs debugger
	 */
	if (p->p_flag & P_FSTRACE)
		wakeup(p);
@


1.59
log
@Compile out more rthreads stuff unless option RTHREADS;
discussed with a few, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.58 2005/12/13 07:38:40 tedu Exp $	*/
a340 3
	/* This process no longer needs to hold the kernel lock. */
	KERNEL_PROC_UNLOCK(p);

d346 3
@


1.58
log
@make exiting actually work when a thread receives a signal.
previously, the child and parent would deadlock in the kernel
and be unable to exit.  help with diagnosis from art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.57 2005/12/03 18:09:08 tedu Exp $	*/
d122 1
d153 1
d266 1
d273 1
a273 1
	
@


1.57
log
@kernel support for threaded processes (rthreads).
uses rfork(RFTHREAD) to create threads, which are presently processes
that are a little more tightly bound together.  several new syscalls
added to facilitate a userland thread library.
all conditional on RTHREADS, currently disabled.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.56 2005/11/28 00:14:28 jsg Exp $	*/
a128 1
		printf("thread exiting normally %d\n", p->p_pid);
d131 1
a131 2
		 * then wait for it to kill us back.  as soon as we return,
		 * we'll exit again.
d136 1
a136 4
		tsleep(&p->p_thrparent->p_thrchildren, PUSER | PCATCH, "dying",
		    0);
		printf("thread got sig %d\n", p->p_pid);
		return;
d141 1
a141 1
			for (; q != 0; q = nq) {
a144 1
				printf("parent killing child %d\n", q->p_pid);
d148 1
a151 1

@


1.56
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.55 2005/09/14 20:55:59 kettenis Exp $	*/
d91 1
a91 1
	exit1(p, W_EXITCODE(SCARG(uap, rval), 0));
d96 12
d114 1
a114 1
exit1(struct proc *p, int rv)
d121 37
d270 8
d282 2
a283 1
	p->p_xstat = rv;
@


1.55
log
@ptrace(2) following fork(2)
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.54 2004/12/26 21:22:13 miod Exp $	*/
d85 1
a85 4
sys_exit(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d102 1
a102 3
exit1(p, rv)
	struct proc *p;
	int rv;
d139 1
a139 1
		register struct session *sp = p->p_session;
d402 1
a402 4
sys_wait4(q, v, retval)
	register struct proc *q;
	void *v;
	register_t *retval;
d404 1
a404 1
	register struct sys_wait4_args /* {
d410 2
a411 2
	register int nfound;
	register struct proc *p, *t;
d515 1
a515 3
proc_reparent(child, parent)
	register struct proc *child;
	register struct proc *parent;
@


1.54
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.53 2004/08/04 21:49:19 art Exp $	*/
d543 2
@


1.53
log
@hardclock detects if ITIMER_VIRTUAL and ITIMER_PROF have expired and
sends SIGVTALRM and SIGPROF to the process if they had. There is a big
problem with calling psignal from hardclock on MULTIPROCESSOR machines
though. It means we need to protect all signal state in the process
with a lock because hardclock doesn't obtain KERNEL_LOCK. Trying to
track down all the tentacles of this quickly becomes very messy. What
saves us at the moment is that SCHED_LOCK (which is used to protect
parts of the signal state, but not all) happens to be recursive and
forgives small and big errors. That's about to change.

So instead of trying to hunt down all the locking problems here, just
make hardclock not send signals. Instead hardclock schedules a timeout
that will send the signal later. There are many reasons why this works
just as good as the previous code, all explained in a comment written
in big, friendly letters in kern_clock.

miod@@ ok noone else dared to ok this, but noone screamed in agony either.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.52 2004/07/22 15:42:11 art Exp $	*/
d210 1
a210 1
	q = p->p_children.lh_first;
d214 1
a214 1
		nq = q->p_sibling.le_next;
d258 1
a258 1
		if (pp->p_children.lh_first == NULL)
d429 1
a429 1
	for (p = q->p_children.lh_first; p != 0; p = p->p_sibling.le_next) {
@


1.52
log
@SIMPLELOCK -> mutex for the lock around deadproc list.
Also move the whole deadproc infrastructure to kern_exit, it's only used
there.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.51 2004/06/13 21:49:26 niklas Exp $	*/
d131 2
@


1.51
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
d312 10
d329 2
a330 2
 * We lock the deadproc list (a spin lock), place the proc on that
 * list (using the p_hash member), and wake up the reaper.
d333 1
a333 2
exit2(p)
	struct proc *p;
d337 1
a337 1
	SIMPLE_LOCK(&deadproc_slock);
d339 1
a339 1
	SIMPLE_UNLOCK(&deadproc_slock);
d359 1
a359 1
		SIMPLE_LOCK(&deadproc_slock);
d363 1
a363 1
			SIMPLE_UNLOCK(&deadproc_slock);
d370 1
a370 1
		SIMPLE_UNLOCK(&deadproc_slock);
d399 1
a399 2
		/* XXXNJW where should this be with respect to 
		 * the wakeup() above? */
@


1.50
log
@make acct(2) optional with ACCOUNTING
ok art@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.49 2004/03/20 19:55:50 tedu Exp $	*/
d288 3
d325 1
d327 1
a327 1
	simple_lock(&deadproc_slock);
d329 1
a329 1
	simple_unlock(&deadproc_slock);
d332 2
d346 2
d349 1
a349 1
		simple_lock(&deadproc_slock);
d353 1
a353 1
			simple_unlock(&deadproc_slock);
d360 2
a361 1
		simple_unlock(&deadproc_slock);
d389 3
@


1.49
log
@one proc.h is sufficient
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.48 2003/12/31 00:13:24 millert Exp $	*/
d173 1
d175 1
@


1.48
log
@wait4(2) takes and returns pid_t, not int.  OK deraadt@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.47 2003/08/03 19:25:49 millert Exp $	*/
a47 1
#include <sys/proc.h>
@


1.47
log
@Implement the WCONTINUED flag to the wait(2) family of syscalls and the
associated WIFCONTINUED macro as per 1003.1-2001.  Adapted from FreeBSD.
A minor amount of trickiness is involved here.  The value for WCONTINUED
is chosen in such a way that _WSTATUS(_WCONTINUED) == _WSTOPPED and the
WIFSTOPPED macro has been modified such that WIFSTOPPED(_WCONTINUED) !=
_WSTOPPED.  This means we don't need to add an extra check to the
WIFSIGNALED and WIFSTOPPED macros.  deraadt@@ OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.46 2003/07/21 22:44:50 tedu Exp $	*/
d382 1
a382 1
int
d389 1
a389 1
		syscallarg(int) pid;
@


1.46
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.45 2003/06/21 00:42:58 tedu Exp $	*/
d400 1
a400 1
	if (SCARG(uap, options) &~ (WUNTRACED|WNOHANG|WALTSIG))
d465 12
@


1.45
log
@add exec/fork/exit hooks per process for compat emulations.
use them to correctly emulate linux brk.
update to TNF copyright in linux_exec.c.

from netbsd, mostly from a diff by Kurt Miller in pr3318.
this should fix java.  no regressions in testing by kurt and sturm@@.
be prepared for "proc size mismatch" -- recompile ps and friends.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.44 2003/06/02 23:28:05 millert Exp $	*/
d126 1
a126 1
		wakeup((caddr_t)p->p_pptr);
d208 1
a208 1
		wakeup((caddr_t)initproc);
d255 1
a255 1
			wakeup((caddr_t)pp);
d260 1
a260 1
	wakeup((caddr_t)p->p_pptr);
d266 1
a266 1
		wakeup((caddr_t)p);
d374 1
a374 1
			wakeup((caddr_t)p->p_pptr);
d427 2
a428 3
				error = copyout((caddr_t)&status,
						(caddr_t)SCARG(uap, status),
						sizeof(status));
d433 2
a434 3
			    (error = copyout((caddr_t)p->p_ru,
			    (caddr_t)SCARG(uap, rusage),
			    sizeof(struct rusage))))
d446 1
a446 1
				wakeup((caddr_t)t);
d465 1
a465 2
				error = copyout((caddr_t)&status,
				    (caddr_t)SCARG(uap, status),
d478 1
a478 1
	if ((error = tsleep((caddr_t)q, PWAIT | PCATCH, "wait", 0)) != 0)
@


1.44
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.43 2002/10/29 01:32:16 art Exp $	*/
d286 6
@


1.43
log
@No need to free the address space in exit1(), we'll do that in the reaper.
That gives us the advantage of not being the active address space when
freeing the mappings in the pmap, which can lead to expensive TLB
flushes on some architectures.

plus some minor cleaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.42 2002/05/16 16:16:51 provos Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.42
log
@systrace facility, used to enforce and generate policies for system calls
okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.41 2002/03/14 01:27:04 millert Exp $	*/
a83 2
void proc_zap(struct proc *);

a113 1
	struct vmspace *vm;
a141 2
	/* The next three chunks should probably be moved to vmspace_exit. */
	vm = p->p_vmspace;
a144 12
	/*
	 * Release user portion of address space.
	 * This releases references to vnodes,
	 * which could cause I/O if the file has been unlinked.
	 * Need to do this early enough that we can still sleep.
	 * Can't free the entire vmspace as the kernel stack
	 * may be mapped within that space also.
	 */
	if (vm->vm_refcnt == 1)
		(void) uvm_deallocate(&vm->vm_map, VM_MIN_ADDRESS,
		    VM_MAXUSER_ADDRESS - VM_MIN_ADDRESS);

d333 1
a333 1
reaper()
d505 1
a505 2
proc_zap(p)
	struct proc *p;
a506 1

@


1.41
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.40 2002/01/25 15:00:26 art Exp $	*/
d74 3
d203 4
@


1.40
log
@poolify pcreds.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.39 2002/01/23 15:46:48 art Exp $	*/
d81 1
a81 1
void proc_zap __P((struct proc *));
@


1.39
log
@Allocate rusage, pgrp, ucred and session with pool.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.38 2002/01/16 20:50:17 miod Exp $	*/
d539 1
a539 1
		FREE(p->p_cred, M_SUBPROC);
@


1.38
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.37 2001/11/12 01:26:09 art Exp $	*/
d121 1
a121 2
	MALLOC(p->p_ru, struct rusage *, sizeof(struct rusage),
		M_ZOMBIE, M_WAITOK);
d519 1
a519 1
	FREE(p->p_ru, M_ZOMBIE);
@


1.37
log
@Bring in more changes from NetBSD. Mostly pagedaemon improvements.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.36 2001/11/06 19:53:20 miod Exp $	*/
a45 1
#include <sys/map.h>
@


1.37.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.40 2002/01/25 15:00:26 art Exp $	*/
d46 1
d122 2
a123 1
	p->p_ru = pool_get(&rusage_pool, PR_WAITOK);
d521 1
a521 1
	pool_put(&rusage_pool, p->p_ru);
d541 1
a541 1
		pool_put(&pcred_pool, p->p_cred);
@


1.37.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.37.2.1 2002/01/31 22:55:40 niklas Exp $	*/
a73 3
#include "systrace.h"
#include <dev/systrace.h>

d81 1
a81 1
void proc_zap(struct proc *);
a199 4
#endif
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		systrace_exit(p);
@


1.37.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 2
d116 1
d145 2
d150 12
d350 1
a350 1
reaper(void)
d522 2
a523 1
proc_zap(struct proc *p)
d525 1
@


1.36
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.35 2001/09/11 20:05:25 miod Exp $	*/
a145 4
#ifdef SYSVSHM
	if (vm->vm_shm && vm->vm_refcnt == 1)
		shmexit(vm);
#endif
@


1.35
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.34 2001/08/25 12:11:40 art Exp $	*/
a78 2

#include <vm/vm.h>
@


1.34
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.33 2001/06/27 04:49:41 art Exp $	*/
a80 1
#include <vm/vm_kern.h>
@


1.33
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.32 2001/06/03 08:55:11 angelos Exp $	*/
d113 1
a113 1
	register struct proc *p;
d116 2
a117 2
	register struct proc *q, *nq;
	register struct vmspace *vm;
@


1.32
log
@WALTSIG is a valid option for sys_wait4().
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.31 2001/05/16 05:07:52 millert Exp $	*/
a82 1
#if defined(UVM)
a83 1
#endif
a163 1
#if defined(UVM)
a166 5
#else
	if (vm->vm_refcnt == 1)
		(void) vm_map_remove(&vm->vm_map, VM_MIN_ADDRESS,
		    VM_MAXUSER_ADDRESS);
#endif
a377 1
#ifdef UVM
a383 4
#else
		vmspace_free(p->p_vmspace);
		kmem_free(kernel_map, (vaddr_t)p->p_addr, USPACE);
#endif
@


1.31
log
@kill COMPAT_{09,10,11} kernel options.  We still need kern_info_09.c and kern_ipc_10.c for other compat modules.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.30 2001/04/02 21:43:11 niklas Exp $	*/
d430 1
a430 1
	if (SCARG(uap, options) &~ (WUNTRACED|WNOHANG))
@


1.30
log
@On popular demand, the Linux-compatibility clone(2) implementation based
on NetBSD's code, as well as some faked Posix RT extensions by me.  This makes
at least simple linuxthreads tests work.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.29 2001/03/23 18:42:06 art Exp $	*/
a426 4

#ifdef COMPAT_09
	SCARG(uap, pid) = (short)SCARG(uap, pid);
#endif
@


1.29
log
@Use pool to allocate processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.28 2000/11/16 20:02:16 provos Exp $	*/
d289 4
d300 5
d445 10
d480 2
a481 1
				psignal(t, SIGCHLD);
d531 3
@


1.28
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.27 2000/06/06 18:50:32 art Exp $	*/
d67 1
d551 1
a551 1
	FREE(p, M_PROC);
@


1.27
log
@If the process is P_NOZOMBIE free it's resources in the reaper.
Noone will wait for it (because noone is allowed to wait for it).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.26 2000/06/05 14:55:16 art Exp $	*/
d265 5
@


1.26
log
@No need to use curproc here. We already know who we are.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.25 2000/06/05 11:02:50 art Exp $	*/
d86 2
d384 2
a385 1
		p->p_stat = SZOMB;
d387 7
a393 3
		/* Wake up the parent so it can get exit status. */
		psignal(p->p_pptr, SIGCHLD);
		wakeup((caddr_t)p->p_pptr);
d447 1
a462 9
			FREE(p->p_ru, M_ZOMBIE);

			/*
			 * Finally finished with old proc entry.
			 * Unlink it from its process group and free it.
			 */
			leavepgrp(p);
			LIST_REMOVE(p, p_list);	/* off zombproc */
			LIST_REMOVE(p, p_sibling);
d464 1
a464 4
			/*
			 * Decrement the count of procs running with this uid.
			 */
			(void)chgproccnt(p->p_cred->p_ruid, -1);
a465 16
			/*
			 * Free up credentials.
			 */
			if (--p->p_cred->p_refcnt == 0) {
				crfree(p->p_cred->pc_ucred);
				FREE(p->p_cred, M_SUBPROC);
			}

			/*
			 * Release reference to text vnode
			 */
			if (p->p_textvp)
				vrele(p->p_textvp);

			FREE(p, M_PROC);
			nprocs--;
d510 39
@


1.25
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.24 2000/05/05 08:38:23 art Exp $	*/
d452 1
a452 1
			scheduler_wait_hook(curproc, p);
@


1.24
log
@Don't set filesize limit to infinity on exit.
This is only needed in accounting and has to be done carefully because
the limit structures are shared between processes.

Found by Denis A. Doroshenko, analysed by Hannah Schroeter.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.23 2000/04/20 10:03:43 art Exp $	*/
d216 1
a216 2
	 * Remove proc from allproc queue and pidhash chain.
	 * Place onto zombproc.  Unlink from parent's child list.
d218 10
a229 3
	p->p_stat = SZOMB;

	LIST_REMOVE(p, p_hash);
d231 3
a279 2
	psignal(p->p_pptr, SIGCHLD);
	wakeup((caddr_t)p->p_pptr);
d286 1
a286 4
#if defined(tahoe)
	/* move this to cpu_exit */
	p->p_addr->u_pcb.pcb_savacc.faddr = (float *)NULL;
#endif
d302 8
a309 7
	 * Finally, call machine-dependent code to release the remaining
	 * resources including address space, the kernel stack and pcb.
	 * The address space is released by "vmspace_free(p->p_vmspace)";
	 * This is machine-dependent, as we may have to change stacks
	 * or ensure that the current one isn't reallocated before we
	 * finish.  cpu_exit will end with a call to cpu_swtch(), finishing
	 * our execution (pun intended).
d314 76
d438 1
a438 1
			    sizeof (struct rusage))))
a483 6
			/*
			 * Give machine-dependent layer a chance
			 * to free anything that cpu_exit couldn't
			 * release while still running in process context.
			 */
			cpu_wait(p);
@


1.24.2.1
log
@Pull in patch from current:
Fix (art):
revert revision 1.16
date: 1999/03/02 22:19:09;  author: niklas;  state: Exp;  lines: +4 -3
RFNOWAIT does not dissociate the child from its parent in any other
way than that the parent wait call will never get the status of this child,
says Rob
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.24 2000/05/05 08:38:23 art Exp $	*/
d337 2
a338 1
		if (SCARG(uap, pid) != WAIT_ANY &&
d340 1
a340 1
		    p->p_pgid != -SCARG(uap, pid))
@


1.23
log
@Add a function "ktrsettracevnode", that changes the ktrace vnode for a process
in a correct way. Use it in all places where the vnode was changed.
(most of the earlier code was incorrect and had races).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.22 2000/03/23 15:55:52 art Exp $	*/
a205 1
	p->p_rlimit[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
d294 2
a295 2
	if (--p->p_limit->p_refcnt == 0)
		FREE(p->p_limit, M_SUBPROC);
@


1.22
log
@Use the new timeout facilities for ITIMER_REAL.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.21 2000/02/21 20:00:09 art Exp $	*/
d66 1
d214 1
a214 1
		vrele(p->p_tracep);
@


1.21
log
@dead code and symbol pollution.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.20 1999/08/15 00:07:43 pjanzen Exp $	*/
d137 1
a137 1
	untimeout(realitexpire, (caddr_t)p);
@


1.20
log
@Adopt NetBSD fix for scheduler problems (nice was broken).  From the NetBSD
commit messages:

Scheduler bug fixes and reorganization
* fix the ancient nice(1) bug, where nice +20 processes incorrectly
  steal 10 - 20% of the CPU, (or even more depending on load average)
* provide a new schedclock() mechanism at a new clock at schedhz, so high
  platform hz values don't cause nice +0 processes to look like they are
  niced
* change the algorithm slightly, and reorganize the code a lot
* fix percent-CPU calculation bugs, and eliminate some no-op code

=== nice bug === Correctly divide the scheduler queues between niced and
compute-bound processes. The current nice weight of two (sort of, see
`algorithm change' below) neatly divides the USRPRI queues in half; this
should have been used to clip p_estcpu, instead of UCHAR_MAX.  Besides
being the wrong amount, clipping an unsigned char to UCHAR_MAX is a no-op,
and it was done after decay_cpu() which can only _reduce_ the value.  It
has to be kept <= NICE_WEIGHT * PRIO_MAX - PPQ or processes can
scheduler-penalize themselves onto the same queue as nice +20 processes.
(Or even a higher one.)

=== New schedclock() mechanism === Some platforms should be cutting down
stathz before hitting the scheduler, since the scheduler algorithm only
works right in the vicinity of 64 Hz. Rather than prescale hz, then scale
back and forth by 4 every time p_estcpu is touched (each occurance an
abstraction violation), use p_estcpu without scaling and require schedhz
to be generated directly at the right frequency. Use a default stathz (well,
actually, profhz) / 4, so nothing changes unless a platform defines schedhz
and a new clock.
[ To do:  Define these for alpha, where hz==1024, and nice was totally broke.]

=== Algorithm change === The nice value used to be added to the
exponentially-decayed scheduler history value p_estcpu, in _addition_ to
be incorporated directly (with greater weight) into the priority calculation.
At first glance, it appears to be a pointless increase of 1/8 the nice
effect (pri = p_estcpu/4 + nice*2), but it's actually at least 3x that
because it will ramp up linearly but be decayed only exponentially, thus
converging to an additional .75 nice for a loadaverage of one. I killed
this: it makes the behavior hard to control, almost impossible to analyze,
and the effect (~~nothing at for the first second, then somewhat increased
niceness after three seconds or more, depending on load average) pointless.

=== Other bugs === hz -> profhz in the p_pctcpu = f(p_cpticks) calcuation.
Collect scheduler functionality. Try to put each abstraction in just one
place.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.19 1999/07/15 14:11:05 art Exp $	*/
d120 1
a120 3
#ifdef PGINPROF
	vmsizmon();
#endif
@


1.20.4.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.21 2000/02/21 20:00:09 art Exp $	*/
d120 3
a122 1

@


1.20.4.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d137 1
a137 1
	timeout_del(&p->p_realit_to);
@


1.20.4.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.30 2001/04/02 21:43:11 niklas Exp $	*/
a65 2
#include <sys/ktrace.h>
#include <sys/pool.h>
a84 2
void proc_zap __P((struct proc *));

d205 1
d213 1
a213 1
		ktrsettracevnode(p, NULL);
d216 2
a217 1
	 * NOTE: WE ARE NO LONGER ALLOWED TO SLEEP!
d219 3
a221 1
	p->p_stat = SDEAD;
a222 7
        /*
         * Remove proc from pidhash chain so looking it up won't
         * work.  Move it from allproc to zombproc, but do not yet
         * wake up the reaper.  We will put the proc on the
         * deadproc list later (using the p_hash member), and
         * wake up the reaper when we do.
         */
a223 2
	LIST_REMOVE(p, p_list);
	LIST_INSERT_HEAD(&zombproc, p, p_list);
a224 3
	/*
	 * Give orphaned children to init(8).
	 */
a255 5
	 * notify interested parties of our demise.
	 */
	KNOTE(&p->p_klist, NOTE_EXIT);

	/*
d271 1
a271 3

	if ((p->p_flag & P_FSTRACE) == 0 && p->p_exitsig != 0)
		psignal(p->p_pptr, P_EXITSIG(p));
d279 4
a282 6

	/*
	 * Release the process's signal state.
	 */
	sigactsfree(p);

d294 2
a295 2
	limfree(p->p_limit);
	p->p_limit = NULL;
d298 7
a304 8
	 * Finally, call machine-dependent code to switch to a new
	 * context (possibly the idle context).  Once we are no longer
	 * using the dead process's vmspace and stack, exit2() will be
	 * called to schedule those resources to be released by the
	 * reaper thread.
	 *
	 * Note that cpu_exit() will end with a call equivalent to
	 * cpu_switch(), finishing our execution (pun intended).
a308 81
/*
 * We are called from cpu_exit() once it is safe to schedule the
 * dead process's resources to be freed.
 *
 * NOTE: One must be careful with locking in this routine.  It's
 * called from a critical section in machine-dependent code, so
 * we should refrain from changing any interrupt state.
 *
 * We lock the deadproc list (a spin lock), place the proc on that
 * list (using the p_hash member), and wake up the reaper.
 */
void
exit2(p)
	struct proc *p;
{

	simple_lock(&deadproc_slock);
	LIST_INSERT_HEAD(&deadproc, p, p_hash);
	simple_unlock(&deadproc_slock);

	wakeup(&deadproc);
}

/*
 * Process reaper.  This is run by a kernel thread to free the resources
 * of a dead process.  Once the resources are free, the process becomes
 * a zombie, and the parent is allowed to read the undead's status.
 */
void
reaper()
{
	struct proc *p;

	for (;;) {
		simple_lock(&deadproc_slock);
		p = LIST_FIRST(&deadproc);
		if (p == NULL) {
			/* No work for us; go to sleep until someone exits. */
			simple_unlock(&deadproc_slock);
			(void) tsleep(&deadproc, PVM, "reaper", 0);
			continue;
		}

		/* Remove us from the deadproc list. */
		LIST_REMOVE(p, p_hash);
		simple_unlock(&deadproc_slock);

		/*
		 * Give machine-dependent code a chance to free any
		 * resources it couldn't free while still running on
		 * that process's context.  This must be done before
		 * uvm_exit(), in case these resources are in the PCB.
		 */
		cpu_wait(p);

#ifdef UVM
		/*
		 * Free the VM resources we're still holding on to.
		 * We must do this from a valid thread because doing
		 * so may block.
		 */
		uvm_exit(p);
#else
		vmspace_free(p->p_vmspace);
		kmem_free(kernel_map, (vaddr_t)p->p_addr, USPACE);
#endif

		/* Process is now a true zombie. */
		if ((p->p_flag & P_NOZOMBIE) == 0) {
			p->p_stat = SZOMB;

			/* Wake up the parent so it can get exit status. */
			psignal(p->p_pptr, SIGCHLD);
			wakeup((caddr_t)p->p_pptr);
		} else {
			/* Noone will wait for us. Just zap the process now */
			proc_zap(p);
		}
	}
}

a341 10

		/*
		 * Wait for processes with p_exitsig != SIGCHLD processes only
		 * if WALTSIG is set; wait for processes with pexitsig ==
		 * SIGCHLD only if WALTSIG is clear.
		 */
		if ((SCARG(uap, options) & WALTSIG) ?
		    (p->p_exitsig == SIGCHLD) : (P_EXITSIG(p) != SIGCHLD))
			continue;

d357 1
a357 1
			    sizeof(struct rusage))))
a358 1

d366 1
a366 2
				if (p->p_exitsig != 0)
					psignal(t, P_EXITSIG(p));
d371 1
a371 1
			scheduler_wait_hook(q, p);
d374 1
d376 7
a382 1
			proc_zap(p);
d384 27
a450 3
	if (parent == initproc)
		child->p_exitsig = SIGCHLD;

a454 39

void
proc_zap(p)
	struct proc *p;
{

	FREE(p->p_ru, M_ZOMBIE);

	/*
	 * Finally finished with old proc entry.
	 * Unlink it from its process group and free it.
	 */
	leavepgrp(p);
	LIST_REMOVE(p, p_list);	/* off zombproc */
	LIST_REMOVE(p, p_sibling);

	/*
	 * Decrement the count of procs running with this uid.
	 */
	(void)chgproccnt(p->p_cred->p_ruid, -1);

	/*
	 * Free up credentials.
	 */
	if (--p->p_cred->p_refcnt == 0) {
		crfree(p->p_cred->pc_ucred);
		FREE(p->p_cred, M_SUBPROC);
	}

	/*
	 * Release reference to text vnode
	 */
	if (p->p_textvp)
		vrele(p->p_textvp);

	pool_put(&proc_pool, p);
	nprocs--;
}

@


1.20.4.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.20.4.3 2001/05/14 22:32:40 niklas Exp $	*/
d83 1
d85 1
d166 1
d170 5
d386 1
d393 4
d428 4
d434 1
a434 1
	if (SCARG(uap, options) &~ (WUNTRACED|WNOHANG|WALTSIG))
@


1.20.4.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.20.4.4 2001/07/04 10:48:18 niklas Exp $	*/
d81 1
d113 1
a113 1
	struct proc *p;
d116 2
a117 2
	struct proc *q, *nq;
	struct vmspace *vm;
@


1.20.4.6
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 2
d148 4
@


1.20.4.7
log
@Merge in trunk
@
text
@d46 1
d122 2
a123 1
	p->p_ru = pool_get(&rusage_pool, PR_WAITOK);
d521 1
a521 1
	pool_put(&rusage_pool, p->p_ru);
d541 1
a541 1
		pool_put(&pcred_pool, p->p_cred);
@


1.20.4.8
log
@Merge in -current from about a week ago
@
text
@d81 1
a81 1
void proc_zap(struct proc *);
@


1.20.4.9
log
@Sync the SMP branch with 3.3
@
text
@a73 3
#include "systrace.h"
#include <dev/systrace.h>

d81 2
d113 1
d142 2
d147 12
a200 4
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE))
		systrace_exit(p);
#endif
d343 1
a343 1
reaper(void)
d515 2
a516 1
proc_zap(struct proc *p)
d518 1
@


1.20.4.10
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.20.4.9 2003/03/28 00:41:26 niklas Exp $	*/
a290 3
	/* This process no longer needs to hold the kernel lock. */
	KERNEL_PROC_UNLOCK(p);

a336 2
	KERNEL_PROC_UNLOCK(curproc);

a349 1
		KERNEL_PROC_LOCK(curproc);
a376 3
		/* XXXNJW where should this be with respect to 
		 * the wakeup() above? */
		KERNEL_PROC_UNLOCK(curproc);
@


1.20.4.11
log
@lock the scheduler before finishing a process. and scheduling a new
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.20.4.10 2003/05/15 04:08:02 niklas Exp $	*/
a321 1
	int s;
a327 2

	SCHED_LOCK(s);
@


1.20.4.12
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.20.4.11 2003/05/18 17:43:43 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.20.4.13
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d126 1
a126 1
		wakeup(p->p_pptr);
d208 1
a208 1
		wakeup(initproc);
d255 1
a255 1
			wakeup(pp);
d260 1
a260 1
	wakeup(p->p_pptr);
d266 1
a266 1
		wakeup(p);
a290 6
	 * If emulation has process exit hook, call it now.
	 */
	if (p->p_emul->e_proc_exit)
		(*p->p_emul->e_proc_exit)(p);

	/*
d377 1
a377 1
			wakeup(p->p_pptr);
d388 1
a388 1
pid_t
d395 1
a395 1
		syscallarg(pid_t) pid;
d406 1
a406 1
	if (SCARG(uap, options) &~ (WUNTRACED|WNOHANG|WALTSIG|WCONTINUED))
d433 3
a435 2
				error = copyout(&status,
				    SCARG(uap, status), sizeof(status));
d440 3
a442 2
			    (error = copyout(p->p_ru,
			    SCARG(uap, rusage), sizeof(struct rusage))))
d454 1
a454 1
				wakeup(t);
d473 2
a474 13
				error = copyout(&status, SCARG(uap, status),
				    sizeof(status));
			} else
				error = 0;
			return (error);
		}
		if ((SCARG(uap, options) & WCONTINUED) && (p->p_flag & P_CONTINUED)) {
			p->p_flag &= ~P_CONTINUED;
			retval[0] = p->p_pid;

			if (SCARG(uap, status)) {
				status = _WCONTINUED;
				error = copyout(&status, SCARG(uap, status),
d487 1
a487 1
	if ((error = tsleep(q, PWAIT | PCATCH, "wait", 0)) != 0)
@


1.20.4.14
log
@deadproc mgmt is outside biglock, make its lock a real one
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.20.4.13 2004/02/19 10:56:37 niklas Exp $	*/
d326 1
a326 1
	SIMPLE_LOCK(&deadproc_slock);
d328 1
a328 1
	SIMPLE_UNLOCK(&deadproc_slock);
d348 1
a348 1
		SIMPLE_LOCK(&deadproc_slock);
d352 1
a352 1
			SIMPLE_UNLOCK(&deadproc_slock);
d359 1
a359 1
		SIMPLE_UNLOCK(&deadproc_slock);
@


1.20.4.15
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a173 1
#ifdef ACCOUNTING
a174 1
#endif
@


1.19
log
@Don't destroy sysvshm if the vmspace is shared (only affects uvm)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.18 1999/06/23 09:44:28 art Exp $	*/
d65 1
d373 1
a373 3
			/* Charge us for our child's sins */
			curproc->p_estcpu = min(curproc->p_estcpu +
			    p->p_estcpu, UCHAR_MAX);
@


1.18
log
@Improved sysv shared memory. Works with UVM.
Original work done in FreeBSD, but this code was ported from NetBSD by
Chuck Cranor.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.17 1999/03/12 17:49:37 deraadt Exp $	*/
d149 1
a149 1
	if (vm->vm_shm)
@


1.17
log
@in scheduler, bias parents for child cpu usage; ross@@ghs.com
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.16 1999/03/02 22:19:09 niklas Exp $	*/
d150 1
a150 1
		shmexit(p);
@


1.16
log
@RFNOWAIT does not dissociate the child from its parent in any other
way than that the parent wait call will never get the status of this child,
says Rob
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.15 1999/02/26 05:06:34 art Exp $	*/
d371 4
@


1.15
log
@vm allocation changes for uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.14 1999/01/11 20:30:40 niklas Exp $	*/
d338 2
a339 1
		if (SCARG(uap, pid) != WAIT_ANY &&
d341 1
a341 1
		    p->p_pgid != -SCARG(uap, pid))
@


1.14
log
@comment typo
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.13 1999/01/10 02:20:20 niklas Exp $	*/
d80 4
d163 5
d171 1
@


1.13
log
@Make RFNOWAIT work in rfork(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.12 1997/11/06 05:58:16 csapuntz Exp $	*/
d247 1
a247 1
	 * Notify parent that we're gone.  If we have P_NOWAIT or parent has
@


1.12
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.11 1997/10/06 20:19:52 deraadt Exp $	*/
d247 3
a249 3
	 * Notify parent that we're gone.  If parent has the P_NOCLDWAIT
	 * flag set, notify process 1 instead (and hope it will handle
	 * this situation).
d251 1
a251 1
	if (p->p_pptr->p_flag & P_NOCLDWAIT) {
@


1.11
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.9 1997/09/15 05:46:12 millert Exp $	*/
d182 1
a182 1
					vgoneall(sp->s_ttyvp);
@


1.10
log
@VFS Lite2 Changes
@
text
@d182 1
a182 1
					VOP_REVOKE(sp->s_ttyvp, REVOKEALL);
@


1.9
log
@From FreeBSD (joerg@@freebsd.org):
    Implement SA_NOCLDWAIT by reparenting kids of processes that have
    the appropriate bit set to PID 1, and let PID 1 handle the zombie.
    This assumes that PID 1 will wait for its kids (which is true of init).
    This also includes some FreeBSD sigaction.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.8 1996/10/26 07:30:24 tholo Exp $	*/
d182 1
a182 1
					vgoneall(sp->s_ttyvp);
@


1.8
log
@Verify that options to wait4() are legal
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.7 1996/08/15 21:51:50 tholo Exp $	*/
d247 3
a249 1
	 * Notify parent that we're gone.
d251 11
d264 1
@


1.7
log
@Clear p_pctcpu when a process exit
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.6 1996/05/02 13:12:11 deraadt Exp $	*/
a307 1
#ifdef notyet
d310 1
a310 1
#endif
@


1.6
log
@sync syscalls, no sys/cpu.h
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exit.c,v 1.5 1996/03/03 17:19:44 niklas Exp $	*/
d240 5
@


1.5
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: kern_exit.c,v 1.38 1996/02/09 18:59:29 christos Exp $	*/
a70 1
#include <sys/cpu.h>
@


1.4
log
@from netbsd:
Remove the process from zombproc and its parent's child list before freeing
its resources.
@
text
@d1 2
a2 1
/*	$NetBSD: kern_exit.c,v 1.35 1995/12/24 11:23:33 mycroft Exp $	*/
d63 9
a80 3
void cpu_exit __P((struct proc *));	/* XXX MOVE ME */
void exit1 __P((struct proc *, int));

d124 2
a125 2
	 * If parent is waiting for us to exit or exec,
	 * P_PPWAIT is set; we will wakeup the parent below.
a126 1
	p->p_flag &= ~(P_TRACED | P_PPWAIT);
d128 5
d219 1
a219 1
		wakeup((caddr_t) initproc);
d267 2
a268 1
	limfree(p->p_limit);
d321 4
a324 3
				if (error = copyout((caddr_t)&status,
				    (caddr_t)SCARG(uap, status),
				    sizeof(status)))
d405 1
a405 1
	if (error = tsleep((caddr_t)q, PWAIT | PCATCH, "wait", 0))
@


1.3
log
@from netbsd; limfree()
@
text
@d1 1
a1 1
/*	$NetBSD: kern_exit.c,v 1.34 1995/12/09 04:09:32 mycroft Exp $	*/
d335 2
a336 1
			 * Decrement the count of procs running with this uid.
d338 3
a340 1
			(void)chgproccnt(p->p_cred->p_ruid, -1);
d343 1
a343 1
			 * Release reference to text vnode
d345 1
a345 2
			if (p->p_textvp)
				vrele(p->p_textvp);
d356 1
a356 2
			 * Finally finished with old proc entry.
			 * Unlink it from its process group and free it.
d358 2
a359 3
			leavepgrp(p);
			LIST_REMOVE(p, p_list);	/* off zombproc */
			LIST_REMOVE(p, p_sibling);
@


1.2
log
@release text vnode before releasing credentials. vnode releasing can
block, but credentials should be alive until the process is really
dead. from tegge@@idt.unit.no; netbsd pr#1767
@
text
@d1 1
a1 1
/*	$NetBSD: kern_exit.c,v 1.33 1995/10/07 06:28:13 mycroft Exp $	*/
d256 1
a256 2
	if (--p->p_limit->p_refcnt == 0)
		FREE(p->p_limit, M_SUBPROC);
@


1.1
log
@Initial revision
@
text
@d341 6
a352 6

			/*
			 * Release reference to text vnode
			 */
			if (p->p_textvp)
				vrele(p->p_textvp);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
