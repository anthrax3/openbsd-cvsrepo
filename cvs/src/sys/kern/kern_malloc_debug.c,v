head	1.35;
access;
symbols
	OPENBSD_6_2:1.35.0.4
	OPENBSD_6_2_BASE:1.35
	OPENBSD_6_1:1.34.0.12
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.8
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.4
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.28.0.6
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.8
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.6
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.4
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.26.0.8
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.6
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.4
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.23.0.12
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.10
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.8
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.6
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.4
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.2
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.18
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	SMP:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.35
date	2017.07.10.23.49.10;	author dlg;	state Exp;
branches;
next	1.34;
commitid	12RGR2FZp3Gfj9P4;

1.34
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	yv0ECmCdICvq576h;

1.33
date	2014.03.28.17.57.11;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2013.08.08.23.25.06;	author syl;	state Exp;
branches;
next	1.31;

1.31
date	2013.06.25.19.45.15;	author syl;	state Exp;
branches;
next	1.30;

1.30
date	2013.02.17.17.39.29;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2013.02.09.20.56.35;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.28.14.07.01;	author mcbride;	state Exp;
branches;
next	1.27;

1.27
date	2009.04.24.08.13.24;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.13.18.57.49;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.11.12.10.42;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.04.17.44.45;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.20.01.04.28;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.03.01.27.31;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.20.06.00.53;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.05.22.32.04;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.05.22.16.13;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.01.23.04.09;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.11.04.34.30;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.23.00.39.47;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.08.02.24.07;	author art;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.19.20.50.58;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.30.12.42.41;	author mpech;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.17.23.39.59;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.26.13.33.52;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.18.13.50.40;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.18.10.47.05;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.17.15.49.22;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.27.04.49.43;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.07.11.21.40;	author art;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	2000.06.07.09.38.46;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.07.08.29.34;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.06.20.24.51;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.06.20.18.20;	author art;	state Exp;
branches;
next	;

1.5.6.1
date	2001.05.14.22.32.41;	author niklas;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2001.07.04.10.48.22;	author niklas;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.5.6.4;

1.5.6.4
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.5.6.5;

1.5.6.5
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.5.6.6;

1.5.6.6
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.5.6.7;

1.5.6.7
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.02.02.03.28.25;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2003.05.19.22.31.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.35
log
@make malloc(9) mpsafe by using a mutex instead of splvm.

this is almost a straightforward change of spl ops with mutex ops,
except the accounting has been shuffled around. memory is counted
as used before an attempt to allocate it from uvm is made to prevent
overcommitting memory. this is modelled on how pools limit allocations.

the uvm bits have been eyeballed by kettenis@@ who says they should be safe.
visa@@ found some nits which have been fixed.

tested by chris@@ and amit kulkarni
ok kettenis@@ visa@@ mpi@@
@
text
@/*	$OpenBSD: kern_malloc_debug.c,v 1.34 2014/11/16 12:31:00 deraadt Exp $	*/

/*
 * Copyright (c) 1999, 2000 Artur Grabowski <art@@openbsd.org>
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

/*
 * This really belongs in kern/kern_malloc.c, but it was too much pollution.
 */

/*
 * It's only possible to debug one type/size at a time. The question is
 * if this is a limitation or a feature. We never want to run this as the
 * default malloc because we'll run out of memory really fast. Adding
 * more types will also add to the complexity of the code.
 *
 * This is really simple. Every malloc() allocates two virtual pages,
 * the second page is left unmapped, and the value returned is aligned
 * so that it ends at (or very close to) the page boundary to catch overflows.
 * Every free() changes the protection of the first page to PROT_NONE so
 * that we can catch any dangling writes to it.
 * To minimize the risk of writes to recycled chunks we keep an LRU of latest
 * freed chunks. The length of it is controlled by MALLOC_DEBUG_CHUNKS.
 *
 * Don't expect any performance.
 *
 * TODO:
 *  - support for size >= PAGE_SIZE
 *  - add support to the fault handler to give better diagnostics if we fail.
 */

#include <sys/param.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/pool.h>
#include <sys/mutex.h>

#include <uvm/uvm_extern.h>
#include <uvm/uvm.h>

/*
 * debug_malloc_type and debug_malloc_size define the type and size of
 * memory to be debugged. Use 0 for a wildcard. debug_malloc_size_lo
 * is the lower limit and debug_malloc_size_hi the upper limit of sizes
 * being debugged; 0 will not work as a wildcard for the upper limit.
 * For any debugging to take place, type must be != -1, size must be >= 0,
 * and if the limits are being used, size must be set to 0.
 * See /usr/src/sys/sys/malloc.h and malloc(9) for a list of types.
 *
 * Although those are variables, it's a really bad idea to change the type
 * if any memory chunks of this type are used. It's ok to change the size
 * in runtime.
 */
int debug_malloc_type = -1;
int debug_malloc_size = -1;
int debug_malloc_size_lo = -1;
int debug_malloc_size_hi = -1;

/*
 * MALLOC_DEBUG_CHUNKS is the number of memory chunks we require on the
 * freelist before we reuse them.
 */
#define MALLOC_DEBUG_CHUNKS 16

void debug_malloc_allocate_free(int);

struct debug_malloc_entry {
	TAILQ_ENTRY(debug_malloc_entry) md_list;
	vaddr_t md_va;
	paddr_t md_pa;
	size_t md_size;
	int md_type;
};

TAILQ_HEAD(,debug_malloc_entry) debug_malloc_freelist;
TAILQ_HEAD(,debug_malloc_entry) debug_malloc_usedlist;

int debug_malloc_allocs;
int debug_malloc_frees;
int debug_malloc_pages;
int debug_malloc_chunks_on_freelist;

int debug_malloc_initialized;

struct pool debug_malloc_pool;
struct mutex debug_malloc_mtx = MUTEX_INITIALIZER(IPL_VM);

int
debug_malloc(unsigned long size, int type, int flags, void **addr)
{
	struct debug_malloc_entry *md = NULL;
	int wait = (flags & M_NOWAIT) == 0;

	/* Careful not to compare unsigned long to int -1 */
	if (((type != debug_malloc_type && debug_malloc_type != 0) ||
	    (size != debug_malloc_size && debug_malloc_size != 0) ||
	    (debug_malloc_size_lo != -1 && size < debug_malloc_size_lo) ||
	    (debug_malloc_size_hi != -1 && size > debug_malloc_size_hi) ||
	    !debug_malloc_initialized) && type != M_DEBUG)
		return (0);

	/* XXX - fix later */
	if (size > PAGE_SIZE)
		return (0);

	if (debug_malloc_chunks_on_freelist < MALLOC_DEBUG_CHUNKS)
		debug_malloc_allocate_free(wait);

	mtx_enter(&debug_malloc_mtx);

	md = TAILQ_FIRST(&debug_malloc_freelist);
	if (md == NULL) {
		mtx_leave(&debug_malloc_mtx);
		return (0);
	}
	TAILQ_REMOVE(&debug_malloc_freelist, md, md_list);
	debug_malloc_chunks_on_freelist--;

	TAILQ_INSERT_HEAD(&debug_malloc_usedlist, md, md_list);
	debug_malloc_allocs++;

	md->md_size = size;
	md->md_type = type;

	mtx_leave(&debug_malloc_mtx);

	pmap_kenter_pa(md->md_va, md->md_pa, PROT_READ | PROT_WRITE);
	pmap_update(pmap_kernel());

	/*
	 * Align the returned addr so that it ends where the first page
	 * ends. roundup to get decent alignment.
	 */
	*addr = (void *)(md->md_va + PAGE_SIZE - roundup(size, sizeof(long)));
	return (1);
}

int
debug_free(void *addr, int type)
{
	struct debug_malloc_entry *md;
	vaddr_t va;

	if (type != debug_malloc_type && debug_malloc_type != 0 &&
	    type != M_DEBUG)
		return (0);

	/*
	 * trunc_page to get the address of the page.
	 */
	va = trunc_page((vaddr_t)addr);

	mtx_enter(&debug_malloc_mtx);
	TAILQ_FOREACH(md, &debug_malloc_usedlist, md_list)
		if (md->md_va == va)
			break;

	/*
	 * If we are not responsible for this entry, let the normal free
	 * handle it
	 */
	if (md == NULL) {
		/*
		 * sanity check. Check for multiple frees.
		 */
		TAILQ_FOREACH(md, &debug_malloc_freelist, md_list)
			if (md->md_va == va)
				panic("debug_free: already free");
		mtx_leave(&debug_malloc_mtx);
		return (0);
	}

	debug_malloc_frees++;
	TAILQ_REMOVE(&debug_malloc_usedlist, md, md_list);
	mtx_leave(&debug_malloc_mtx);

	/*
	 * unmap the page.
	 */
	pmap_kremove(md->md_va, PAGE_SIZE);
	pmap_update(pmap_kernel());

	mtx_enter(&debug_malloc_mtx);
	TAILQ_INSERT_TAIL(&debug_malloc_freelist, md, md_list);
	debug_malloc_chunks_on_freelist++;
	mtx_leave(&debug_malloc_mtx);

	return (1);
}

void
debug_malloc_init(void)
{

	TAILQ_INIT(&debug_malloc_freelist);
	TAILQ_INIT(&debug_malloc_usedlist);

	debug_malloc_allocs = 0;
	debug_malloc_frees = 0;
	debug_malloc_pages = 0;
	debug_malloc_chunks_on_freelist = 0;

	pool_init(&debug_malloc_pool, sizeof(struct debug_malloc_entry),
	    0, 0, IPL_VM, "mdbepl", NULL);

	debug_malloc_initialized = 1;
}

/*
 * Add one chunk to the freelist.
 *
 * called at splvm.
 */
void
debug_malloc_allocate_free(int wait)
{
	vaddr_t va, offset;
	struct vm_page *pg;
	struct debug_malloc_entry *md;
	int s;

	md = pool_get(&debug_malloc_pool, wait ? PR_WAITOK : PR_NOWAIT);
	if (md == NULL)
		return;

	s = splvm();

	va = uvm_km_kmemalloc(kmem_map, NULL, PAGE_SIZE * 2,
	    UVM_KMF_VALLOC | (wait ? 0: UVM_KMF_NOWAIT));
	if (va == 0)
		goto put;

	offset = va - vm_map_min(kernel_map);
	for (;;) {
		pg = uvm_pagealloc(NULL, 0, NULL, 0);
		if (pg) {
			atomic_clearbits_int(&pg->pg_flags, PG_BUSY);
			UVM_PAGE_OWN(pg, NULL);
		}

		if (pg)
			break;

		if (wait == 0)
			goto unmap;

		uvm_wait("debug_malloc");
	}

	splx(s);

	md->md_va = va;
	md->md_pa = VM_PAGE_TO_PHYS(pg);

	mtx_enter(&debug_malloc_mtx);
	debug_malloc_pages++;
	TAILQ_INSERT_HEAD(&debug_malloc_freelist, md, md_list);
	debug_malloc_chunks_on_freelist++;
	mtx_leave(&debug_malloc_mtx);

	return;

unmap:
	uvm_unmap(kmem_map, va, va + PAGE_SIZE * 2);
put:
	splx(s);
	pool_put(&debug_malloc_pool, md);
	return;
}

void
debug_malloc_print(void)
{

	debug_malloc_printit(printf, 0);
}

void
debug_malloc_assert_allocated(void *addr, const char *func)
{
	struct debug_malloc_entry *md;
	vaddr_t va = (vaddr_t)addr;

	TAILQ_FOREACH(md, &debug_malloc_freelist, md_list) {
		if (va >= md->md_va &&
		    va < md->md_va + 2 * PAGE_SIZE)
			panic("debug_malloc: (%s): %p - freed", func, addr);
	}
	TAILQ_FOREACH(md, &debug_malloc_usedlist, md_list) {
		if (va >= md->md_va + PAGE_SIZE &&
		    va < md->md_va + 2 * PAGE_SIZE)
			panic("debug_malloc: (%s): %p - overflow", func, addr);
	}
}

void
debug_malloc_printit(
    int (*pr)(const char *, ...) __attribute__((__format__(__kprintf__,1,2))),
    vaddr_t addr)
{
	struct debug_malloc_entry *md;

	if (addr) {
		TAILQ_FOREACH(md, &debug_malloc_freelist, md_list) {
			if (addr >= md->md_va &&
			    addr < md->md_va + 2 * PAGE_SIZE) {
				(*pr)("Memory at address 0x%lx is in a freed "
				      "area. type %d, size: %zu\n ",
				      addr, md->md_type, md->md_size);
				return;
			}
		}
		TAILQ_FOREACH(md, &debug_malloc_usedlist, md_list) {
			if (addr >= md->md_va + PAGE_SIZE &&
			    addr < md->md_va + 2 * PAGE_SIZE) {
				(*pr)("Memory at address 0x%lx is just outside "
				      "an allocated area. type %d, size: %zu\n",
				      addr, md->md_type, md->md_size);
				return;
			}
		}
		(*pr)("Memory at address 0x%lx is outside debugged malloc.\n",
		    addr);
		return;
	}

	(*pr)("allocs: %d\n", debug_malloc_allocs);
	(*pr)("frees: %d\n", debug_malloc_frees);
	(*pr)("pages used: %d\n", debug_malloc_pages);
	(*pr)("chunks on freelist: %d\n", debug_malloc_chunks_on_freelist);

	(*pr)("\taddr:\tsize:\n");
	(*pr)("free chunks:\n");
	TAILQ_FOREACH(md, &debug_malloc_freelist, md_list)
		(*pr)("\t0x%lx\t0x%lx\t%d\n", md->md_va, md->md_size,
		      md->md_type);
	(*pr)("used chunks:\n");
	TAILQ_FOREACH(md, &debug_malloc_usedlist, md_list)
		(*pr)("\t0x%lx\t0x%lx\t%d\n", md->md_va, md->md_size,
		      md->md_type);
}
@


1.34
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.33 2014/03/28 17:57:11 mpi Exp $	*/
d59 1
d62 1
d109 1
d115 1
a115 1
	int s, wait = (flags & M_NOWAIT) == 0;
a128 1
	s = splvm();
d132 2
d136 1
a136 1
		splx(s);
d144 5
a148 1
	splx(s);
a152 3
	md->md_size = size;
	md->md_type = type;

a165 1
	int s;
d176 1
a176 1
	s = splvm();
d192 1
a192 1
		splx(s);
d198 1
a199 2
	TAILQ_INSERT_TAIL(&debug_malloc_freelist, md, md_list);
	debug_malloc_chunks_on_freelist++;
d205 5
a209 1
	splx(s);
d227 1
a227 1
	    0, 0, 0, "mdbepl", NULL);
d243 1
a243 2

	splassert(IPL_VM);
d249 2
d253 2
a254 4
	if (va == 0) {
		pool_put(&debug_malloc_pool, md);
		return;
	}
d267 3
a269 5
		if (wait == 0) {
			uvm_unmap(kmem_map, va, va + PAGE_SIZE * 2);
			pool_put(&debug_malloc_pool, md);
			return;
		}
d273 2
d278 1
d282 10
d331 1
a331 1
				      "area. type %d, size: %d\n ",
d340 1
a340 1
				      "an allocated area. type %d, size: %d\n",
@


1.33
log
@Reduce uvm include madness.  Use <uvm/uvm_extern.h> instead of
<uvm/uvm.h> if possible and remove double inclusions.

ok beck@@, mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.32 2013/08/08 23:25:06 syl Exp $	*/
d41 1
a41 1
 * Every free() changes the protection of the first page to VM_PROT_NONE so
d142 1
a142 1
	pmap_kenter_pa(md->md_va, md->md_pa, VM_PROT_READ|VM_PROT_WRITE);
@


1.32
log
@Uncomment kprintf format attributes for sys/kern

tested on vax (gcc3) ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.31 2013/06/25 19:45:15 syl Exp $	*/
d60 1
a60 1
#include <uvm/uvm.h>
@


1.31
log
@allow kernel to compile with MALLOC_DEBUG.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.30 2013/02/17 17:39:29 miod Exp $	*/
d304 1
a304 1
    int (*pr)(const char *, ...) /* __attribute__((__format__(__kprintf__,1,2))) */,
@


1.30
log
@Comment out recently added __attribute__((__format__(__kprintf__))) annotations
in MI code; gcc 2.95 does not accept such annotation for function pointer
declarations, only function prototypes.
To be uncommented once gcc 2.95 bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.29 2013/02/09 20:56:35 miod Exp $	*/
d304 2
a305 1
    int (*pr)(const char *, ...) /* __attribute__((__format__(__kprintf__,1,2))) */)
@


1.29
log
@Add explicit __attribute__ ((__format__(__kprintf__)))) to the functions and
function pointer arguments which are {used as,} wrappers around the kernel
printf function.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.28 2011/07/28 14:07:01 mcbride Exp $	*/
d304 1
a304 1
    int (*pr)(const char *, ...) __attribute__((__format__(__kprintf__,1,2))))
@


1.28
log
@Kill integer from pointer warning when compiling with MALLOC_DEBUG.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.27 2009/04/24 08:13:24 jsg Exp $	*/
d303 2
a304 1
debug_malloc_printit(int (*pr)(const char *, ...), vaddr_t addr)
@


1.27
log
@Change format strings to allow 64 bit addresses to display properly,
and add a missing argument to one of the printf calls.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.26 2007/04/13 18:57:49 art Exp $	*/
d281 1
a281 1
	debug_malloc_printit(printf, NULL);
@


1.26
log
@While splitting flags and pqflags might have been a good idea in theory
to separate locking, on most modern machines this is not enough
since operations on short types touch other short types that share the
same word in memory.

Merge pg_flags and pqflags again and now use atomic operations to change
the flags. Also bump wire_count to an int and pg_version might go
int as well, just for alignment.

tested by many, many. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.25 2007/04/11 12:10:42 art Exp $	*/
d311 1
a311 1
				(*pr)("Memory at address 0x%x is in a freed "
d320 1
a320 1
				(*pr)("Memory at address 0x%x is just outside "
d326 2
a327 1
		(*pr)("Memory at address 0x%x is outside debugged malloc.\n");
d339 1
a339 1
		(*pr)("\t0x%x\t0x%x\t%d\n", md->md_va, md->md_size,
d343 1
a343 1
		(*pr)("\t0x%x\t0x%x\t%d\n", md->md_va, md->md_size,
@


1.25
log
@Instead of managing pages for intrsafe maps in special objects (aka.
kmem_object) just so that we can remove them, just use pmap_extract
to get the pages to free and simplify a lot of code to not deal with
the list of intrsafe maps, intrsafe objects, etc.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.24 2007/04/04 17:44:45 art Exp $	*/
d254 1
a254 1
			pg->pg_flags &= ~PG_BUSY;  /* new page */
@


1.24
log
@Mechanically rename the "flags" and "version" fields in struct vm_page
to "pg_flags" and "pg_version", so that they are a bit easier to work with.
Whoever uses generic names like this for a popular struct obviously doesn't
read much code.

Most architectures compile and there are no functionality changes.

deraadt@@ ok ("if something fails to compile, we fix that by hand")
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.23 2004/06/20 01:04:28 art Exp $	*/
d243 1
a243 1
	va = uvm_km_kmemalloc(kmem_map, uvmexp.kmem_object, PAGE_SIZE * 2,
d252 1
a252 2
		simple_lock(&uvmexp.kmem_object->vmobjlock);
		pg = uvm_pagealloc(uvmexp.kmem_object, offset, NULL, 0);
a256 1
		simple_unlock(&uvmexp.kmem_object->vmobjlock);
@


1.23
log
@Fix inversed logic in handling the "nowait/waitok" flags. Bugs in two places
in malloc_debug.

Also, add an assert-like function to sprinkle in code you're debugging at the
moment. Those asserts are _not_ supposed to be ever comitted, just use them
while debugging.

beck@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.22 2003/06/03 01:27:31 art Exp $	*/
d255 1
a255 1
			pg->flags &= ~PG_BUSY;  /* new page */
@


1.22
log
@license cleaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.21 2002/12/20 06:00:53 art Exp $	*/
d112 1
a112 1
	int s, wait = flags & M_NOWAIT;
d244 1
a244 1
	    UVM_KMF_VALLOC | (wait ? UVM_KMF_NOWAIT : 0));
d284 18
@


1.21
log
@Add a special malloc type M_DEBUG.
If the kernel is compiled with MALLOC_DEBUG, M_DEBUG will force the allocation
to be done through malloc_debug.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.20 2002/12/05 22:32:04 art Exp $	*/
d13 1
a13 4
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 * 3. The name of the author may not be used to endorse or promote products
@


1.20
log
@Hmm.. I don't think we want the default to be to debug every allocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.19 2002/12/05 22:16:13 art Exp $	*/
d118 1
a118 1
	if ((type != debug_malloc_type && debug_malloc_type != 0) ||
d122 1
a122 1
	    !debug_malloc_initialized)
d166 2
a167 1
	if (type != debug_malloc_type && debug_malloc_type != 0)
@


1.19
log
@Do not use debug_malloc if it hasn't been initialized.
This can happen when debug_malloc_init calls pool_init which calls
malloc (because the kernel is built with POOL_DIAGNOSTIC) which in turn
calls debug_malloc and debug_malloc just happens to trigger on all memory
allocations.

This allows us to run a kernel debugging _all_ allocations.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.18 2002/07/01 23:04:09 art Exp $	*/
d78 2
a79 2
int debug_malloc_type = 0;
int debug_malloc_size = 0;
@


1.18
log
@Don't abuse VM_PROT_ALL. Use VM_PROT_READ|VM_PROT_WRITE here.
We'll never want to exec code in malloc mappings.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.17 2002/06/11 04:34:30 art Exp $	*/
d78 2
a79 2
int debug_malloc_type = -1;
int debug_malloc_size = -1;
d107 2
d121 2
a122 1
	    (debug_malloc_size_hi != -1 && size > debug_malloc_size_hi))
d223 2
@


1.17
log
@splassert where needed
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.16 2002/01/23 00:39:47 art Exp $	*/
d142 1
a142 1
	pmap_kenter_pa(md->md_va, md->md_pa, VM_PROT_ALL);
@


1.16
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.15 2001/12/08 02:24:07 art Exp $	*/
d233 2
@


1.15
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.14 2001/11/06 19:53:20 miod Exp $	*/
d219 1
a219 1
	    0, 0, 0, "mdbepl", 0, NULL, NULL, 0);
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.16 2002/01/23 00:39:47 art Exp $	*/
d219 1
a219 1
	    0, 0, 0, "mdbepl", NULL);
@


1.15.2.2
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.15.2.1 2002/01/31 22:55:40 niklas Exp $	*/
d238 1
a238 1
	va = uvm_km_kmemalloc(kmem_map, NULL, PAGE_SIZE * 2,
d247 2
a248 1
		pg = uvm_pagealloc(NULL, offset, NULL, 0);
d253 1
@


1.15.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.15.2.2 2002/02/02 03:28:25 art Exp $	*/
d142 1
a142 1
	pmap_kenter_pa(md->md_va, md->md_pa, VM_PROT_READ|VM_PROT_WRITE);
a232 2

	splassert(IPL_VM);
@


1.15.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a106 2
int debug_malloc_initialized;

d116 1
a116 1
	if (((type != debug_malloc_type && debug_malloc_type != 0) ||
d119 1
a119 2
	    (debug_malloc_size_hi != -1 && size > debug_malloc_size_hi) ||
	    !debug_malloc_initialized) && type != M_DEBUG)
d163 1
a163 2
	if (type != debug_malloc_type && debug_malloc_type != 0 &&
	    type != M_DEBUG)
a219 2

	debug_malloc_initialized = 1;
@


1.14
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.13 2001/09/19 20:50:58 mickey Exp $	*/
d143 1
d200 1
@


1.13
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.12 2001/08/30 12:42:41 mpech Exp $	*/
a62 1
#include <vm/vm.h>
@


1.12
log
@typo in the comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.11 2001/08/17 23:39:59 art Exp $	*/
a63 1
#include <vm/vm_kern.h>
@


1.11
log
@When this code was imported to NetBSD by Jason Thorpe he did a bunch of
useful changes (and a lot of cleanup). Bring in them.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.10 2001/07/26 13:33:52 art Exp $	*/
d42 1
a42 1
 * the second page is left unmapped, and the the value returned is aligned
@


1.10
log
@Be more careful with ranges.
From Heikki Korpela <heko@@iki.fi>
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.9 2001/07/18 13:50:40 art Exp $	*/
d61 1
a65 1
#include <uvm/uvm_page.h>
d68 3
a70 3
 * malloc_deb_type and malloc_deb_size define the type and size of
 * memory to be debugged. Use 0 for a wildcard. malloc_deb_size_lo
 * is the lower limit and malloc_deb_size_hi the upper limit of sizes
d80 4
a83 4
int malloc_deb_type = -1;
int malloc_deb_size = -1;
int malloc_deb_size_lo = -1;
int malloc_deb_size_hi = -1;
d91 1
a91 8
/* returns 0 if normal malloc/free should be used */
int debug_malloc __P((unsigned long, int, int, void **));
int debug_free __P((void *, int));
void debug_malloc_init __P((void));

void malloc_deb_allocate_free __P((int));
void debug_malloc_print __P((void));
void debug_malloc_printit __P((int (*) __P((const char *, ...)), vaddr_t));
d93 2
a94 2
struct malloc_deb_entry {
	TAILQ_ENTRY(malloc_deb_entry) md_list;
d101 2
a102 2
TAILQ_HEAD(,malloc_deb_entry) malloc_deb_free;
TAILQ_HEAD(,malloc_deb_entry) malloc_deb_used;
d104 6
a109 8
int malloc_deb_allocs;
int malloc_deb_frees;
int malloc_deb_pages;
int malloc_deb_chunks_on_freelist;

#ifndef M_DEBUG
#define M_DEBUG M_TEMP
#endif
d112 1
a112 4
debug_malloc(size, type, flags, addr)
	unsigned long size;
	int type, flags;
	void **addr;
d114 2
a115 3
	struct malloc_deb_entry *md = NULL;
	int s;
	int wait = flags & M_NOWAIT;
d118 5
a122 6
	if ((type != malloc_deb_type && malloc_deb_type != 0) ||
	    (size != malloc_deb_size && malloc_deb_size != 0) ||
	    (malloc_deb_size_lo != -1 && size < malloc_deb_size_lo) ||
	    (malloc_deb_size_hi != -1 && size > malloc_deb_size_hi) ||
	    type == M_DEBUG)
		return 0;
d126 1
a126 1
		return 0;
d128 3
a130 3
	s = splimp();
	if (malloc_deb_chunks_on_freelist < MALLOC_DEBUG_CHUNKS)
		malloc_deb_allocate_free(wait);
d132 1
a132 1
	md = TAILQ_FIRST(&malloc_deb_free);
d135 1
a135 1
		return 0;
d137 2
a138 2
	TAILQ_REMOVE(&malloc_deb_free, md, md_list);
	malloc_deb_chunks_on_freelist--;
d140 2
a141 2
	TAILQ_INSERT_HEAD(&malloc_deb_used, md, md_list);
	malloc_deb_allocs++;
a143 1

d154 1
a154 1
	return 1;
d158 1
a158 3
debug_free(addr, type)
	void *addr;
	int type;
d160 2
a161 1
	struct malloc_deb_entry *md;
a162 1
	vaddr_t va;
d164 2
a165 3
	if ((type != malloc_deb_type && malloc_deb_type != 0) ||
	    type == M_DEBUG)
		return 0;
d172 2
a173 2
	s = splimp();
	TAILQ_FOREACH(md, &malloc_deb_used, md_list)
d185 1
a185 1
		TAILQ_FOREACH(md, &malloc_deb_free, md_list)
d189 1
a189 1
		return 0;
d192 2
a193 2
	malloc_deb_frees++;
	TAILQ_REMOVE(&malloc_deb_used, md, md_list);
d195 2
a196 2
	TAILQ_INSERT_TAIL(&malloc_deb_free, md, md_list);
	malloc_deb_chunks_on_freelist++;
d203 1
a203 1
	return 1;
d207 1
a207 1
debug_malloc_init()
a208 2
	TAILQ_INIT(&malloc_deb_free);
	TAILQ_INIT(&malloc_deb_used);
d210 10
a219 4
	malloc_deb_allocs = 0;
	malloc_deb_frees = 0;
	malloc_deb_pages = 0;
	malloc_deb_chunks_on_freelist = 0;
d225 1
a225 1
 * called at splimp.
d228 1
a228 2
malloc_deb_allocate_free(wait)
	int wait;
d232 1
a232 1
	struct malloc_deb_entry *md;
d234 1
a234 2
	md = malloc(sizeof(struct malloc_deb_entry), M_DEBUG,
		    wait ? M_WAITOK : M_NOWAIT);
d238 2
a239 3
	va = uvm_km_kmemalloc(kmem_map, uvmexp.kmem_object,
			      PAGE_SIZE * 2,
			      UVM_KMF_VALLOC | (wait ? UVM_KMF_NOWAIT : 0));
d241 1
a241 1
		free(md, M_DEBUG);
d246 1
a246 1
	do {
d260 1
a260 1
			free(md, M_DEBUG);
d264 1
a264 1
	} while (1);
d269 3
a271 3
	malloc_deb_pages++;
	TAILQ_INSERT_HEAD(&malloc_deb_free, md, md_list);
	malloc_deb_chunks_on_freelist++;
d275 1
a275 1
debug_malloc_print()
d277 1
d282 1
a282 3
debug_malloc_printit(pr, addr)
        int (*pr) __P((const char *, ...));
	vaddr_t addr;
d284 1
a284 1
	struct malloc_deb_entry *md;
d287 1
a287 1
		TAILQ_FOREACH(md, &malloc_deb_free, md_list) {
d296 1
a296 1
		TAILQ_FOREACH(md, &malloc_deb_used, md_list) {
d309 4
a312 4
	(*pr)("allocs: %d\n", malloc_deb_allocs);
	(*pr)("frees: %d\n", malloc_deb_frees);
	(*pr)("pages used: %d\n", malloc_deb_pages);
	(*pr)("chunks on freelist: %d\n", malloc_deb_chunks_on_freelist);
d316 1
a316 1
	TAILQ_FOREACH(md, &malloc_deb_free, md_list)
d320 1
a320 1
	TAILQ_FOREACH(md, &malloc_deb_used, md_list)
a323 2


@


1.9
log
@Typo.
Noted by: Heikki Korpela <heko@@iki.fi>
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.8 2001/07/18 10:47:05 art Exp $	*/
d69 6
a74 1
 * memory to be debugged. Use 0 for a wildcard.
d130 1
d133 2
a134 1
	    (size < malloc_deb_size_lo || size > malloc_deb_size_hi) ||
@


1.8
log
@Get rid of the PMAP_NEW option by making it mandatory for all archs.
The archs that didn't have a proper PMAP_NEW now have a dummy implementation
with wrappers around the old functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.7 2001/07/17 15:49:22 art Exp $	*/
d41 1
a41 1
 * This is really is simple. Every malloc() allocates two virtual pages,
@


1.7
log
@Since normal malloc reports "data modified on free list" with
the size we are trying to allocate and not the size of the bucket
and malloc_debug is not capable of debugging a prticular bucket, only
a size, add a possibility to specify a size range.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.6 2001/06/27 04:49:43 art Exp $	*/
a151 1
#ifdef PMAP_NEW
a152 4
#else
	pmap_enter(pmap_kernel(), md->md_va, md->md_pa, VM_PROT_ALL, TRUE,
		   VM_PROT_READ|VM_PROT_WRITE);
#endif
a210 1
#ifdef PMAP_NEW
a211 3
#else
	pmap_remove(pmap_kernel(), md->md_va, md->md_va + PAGE_SIZE);
#endif
@


1.6
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.5 2000/06/07 11:21:40 art Exp $	*/
d77 2
d127 1
@


1.5
log
@Allow passing an address to 'show malloc' and print out some information about
that address.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.4 2000/06/07 09:38:46 art Exp $	*/
a60 4

#if !defined(UVM)
#error MALLOC_DEBUG will not work without UVM.
#endif
@


1.5.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.5 2000/06/07 11:21:40 art Exp $	*/
@


1.5.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.5.6.1 2001/05/14 22:32:41 niklas Exp $	*/
d61 4
@


1.5.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.5.6.2 2001/07/04 10:48:22 niklas Exp $	*/
d41 2
a42 2
 * This is really simple. Every malloc() allocates two virtual pages,
 * the second page is left unmapped, and the value returned is aligned
a60 1
#include <sys/pool.h>
d63 1
d65 1
d68 2
a69 7
 * debug_malloc_type and debug_malloc_size define the type and size of
 * memory to be debugged. Use 0 for a wildcard. debug_malloc_size_lo
 * is the lower limit and debug_malloc_size_hi the upper limit of sizes
 * being debugged; 0 will not work as a wildcard for the upper limit.
 * For any debugging to take place, type must be != -1, size must be >= 0,
 * and if the limits are being used, size must be set to 0.
 * See /usr/src/sys/sys/malloc.h and malloc(9) for a list of types.
d75 2
a76 4
int debug_malloc_type = -1;
int debug_malloc_size = -1;
int debug_malloc_size_lo = -1;
int debug_malloc_size_hi = -1;
d84 8
a91 1
void debug_malloc_allocate_free(int);
d93 2
a94 2
struct debug_malloc_entry {
	TAILQ_ENTRY(debug_malloc_entry) md_list;
d101 2
a102 2
TAILQ_HEAD(,debug_malloc_entry) debug_malloc_freelist;
TAILQ_HEAD(,debug_malloc_entry) debug_malloc_usedlist;
d104 8
a111 6
int debug_malloc_allocs;
int debug_malloc_frees;
int debug_malloc_pages;
int debug_malloc_chunks_on_freelist;

struct pool debug_malloc_pool;
d114 4
a117 1
debug_malloc(unsigned long size, int type, int flags, void **addr)
d119 3
a121 2
	struct debug_malloc_entry *md = NULL;
	int s, wait = flags & M_NOWAIT;
d123 4
a126 6
	/* Careful not to compare unsigned long to int -1 */
	if ((type != debug_malloc_type && debug_malloc_type != 0) ||
	    (size != debug_malloc_size && debug_malloc_size != 0) ||
	    (debug_malloc_size_lo != -1 && size < debug_malloc_size_lo) ||
	    (debug_malloc_size_hi != -1 && size > debug_malloc_size_hi))
		return (0);
d130 1
a130 1
		return (0);
d132 3
a134 3
	s = splvm();
	if (debug_malloc_chunks_on_freelist < MALLOC_DEBUG_CHUNKS)
		debug_malloc_allocate_free(wait);
d136 1
a136 1
	md = TAILQ_FIRST(&debug_malloc_freelist);
d139 1
a139 1
		return (0);
d141 2
a142 2
	TAILQ_REMOVE(&debug_malloc_freelist, md, md_list);
	debug_malloc_chunks_on_freelist--;
d144 2
a145 2
	TAILQ_INSERT_HEAD(&debug_malloc_usedlist, md, md_list);
	debug_malloc_allocs++;
d148 2
d151 4
d164 1
a164 1
	return (1);
d168 3
a170 1
debug_free(void *addr, int type)
d172 2
a173 1
	struct debug_malloc_entry *md;
a174 1
	int s;
d176 3
a178 2
	if (type != debug_malloc_type && debug_malloc_type != 0)
		return (0);
d185 2
a186 2
	s = splvm();
	TAILQ_FOREACH(md, &debug_malloc_usedlist, md_list)
d198 1
a198 1
		TAILQ_FOREACH(md, &debug_malloc_freelist, md_list)
d202 1
a202 1
		return (0);
d205 2
a206 2
	debug_malloc_frees++;
	TAILQ_REMOVE(&debug_malloc_usedlist, md, md_list);
d208 2
a209 2
	TAILQ_INSERT_TAIL(&debug_malloc_freelist, md, md_list);
	debug_malloc_chunks_on_freelist++;
d213 1
d215 3
d220 1
a220 1
	return (1);
d224 1
a224 1
debug_malloc_init(void)
d226 2
d229 4
a232 10
	TAILQ_INIT(&debug_malloc_freelist);
	TAILQ_INIT(&debug_malloc_usedlist);

	debug_malloc_allocs = 0;
	debug_malloc_frees = 0;
	debug_malloc_pages = 0;
	debug_malloc_chunks_on_freelist = 0;

	pool_init(&debug_malloc_pool, sizeof(struct debug_malloc_entry),
	    0, 0, 0, "mdbepl", 0, NULL, NULL, 0);
d238 1
a238 1
 * called at splvm.
d241 2
a242 1
debug_malloc_allocate_free(int wait)
d246 1
a246 1
	struct debug_malloc_entry *md;
d248 2
a249 1
	md = pool_get(&debug_malloc_pool, wait ? PR_WAITOK : PR_NOWAIT);
d253 3
a255 2
	va = uvm_km_kmemalloc(kmem_map, uvmexp.kmem_object, PAGE_SIZE * 2,
	    UVM_KMF_VALLOC | (wait ? UVM_KMF_NOWAIT : 0));
d257 1
a257 1
		pool_put(&debug_malloc_pool, md);
d262 1
a262 1
	for (;;) {
d276 1
a276 1
			pool_put(&debug_malloc_pool, md);
d280 1
a280 1
	}
d285 3
a287 3
	debug_malloc_pages++;
	TAILQ_INSERT_HEAD(&debug_malloc_freelist, md, md_list);
	debug_malloc_chunks_on_freelist++;
d291 1
a291 1
debug_malloc_print(void)
a292 1

d297 3
a299 1
debug_malloc_printit(int (*pr)(const char *, ...), vaddr_t addr)
d301 1
a301 1
	struct debug_malloc_entry *md;
d304 1
a304 1
		TAILQ_FOREACH(md, &debug_malloc_freelist, md_list) {
d313 1
a313 1
		TAILQ_FOREACH(md, &debug_malloc_usedlist, md_list) {
d326 4
a329 4
	(*pr)("allocs: %d\n", debug_malloc_allocs);
	(*pr)("frees: %d\n", debug_malloc_frees);
	(*pr)("pages used: %d\n", debug_malloc_pages);
	(*pr)("chunks on freelist: %d\n", debug_malloc_chunks_on_freelist);
d333 1
a333 1
	TAILQ_FOREACH(md, &debug_malloc_freelist, md_list)
d337 1
a337 1
	TAILQ_FOREACH(md, &debug_malloc_usedlist, md_list)
d341 2
@


1.5.6.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
@


1.5.6.5
log
@Merge in trunk
@
text
@a142 1
	pmap_update(pmap_kernel());
a198 1
	pmap_update(pmap_kernel());
d217 1
a217 1
	    0, 0, 0, "mdbepl", NULL);
@


1.5.6.6
log
@Sync the SMP branch with 3.3
@
text
@a106 2
int debug_malloc_initialized;

d116 1
a116 1
	if (((type != debug_malloc_type && debug_malloc_type != 0) ||
d119 1
a119 2
	    (debug_malloc_size_hi != -1 && size > debug_malloc_size_hi) ||
	    !debug_malloc_initialized) && type != M_DEBUG)
d142 1
a142 1
	pmap_kenter_pa(md->md_va, md->md_pa, VM_PROT_READ|VM_PROT_WRITE);
d163 1
a163 2
	if (type != debug_malloc_type && debug_malloc_type != 0 &&
	    type != M_DEBUG)
a219 2

	debug_malloc_initialized = 1;
a232 2

	splassert(IPL_VM);
@


1.5.6.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.5.6.6 2003/03/28 00:41:26 niklas Exp $	*/
d13 4
a16 1
 * 2. The name of the author may not be used to endorse or promote products
@


1.4
log
@Change debug_malloc_print so that it can be called from ddb.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.3 2000/06/07 08:29:34 art Exp $	*/
d95 1
a95 1
void debug_malloc_printit __P((int (*) __P((const char *, ...))));
d297 1
a297 1
	debug_malloc_printit(printf);
d301 1
a301 1
debug_malloc_printit(pr)
d303 1
d307 23
d338 2
a339 1
		(*pr)("\t0x%x\t0x%x\t%d\n", md->md_va, md->md_size, md->md_type);
d342 2
a343 1
		(*pr)("\t0x%x\t0x%x\t%d\n", md->md_va, md->md_size, md->md_type);
@


1.3
log
@Default type and size to -1.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.2 2000/06/06 20:24:51 art Exp $	*/
d95 1
d297 7
d306 4
a309 4
	printf("allocs: %d\n", malloc_deb_allocs);
	printf("frees: %d\n", malloc_deb_frees);
	printf("pages used: %d\n", malloc_deb_pages);
	printf("chunks on freelist: %d\n", malloc_deb_chunks_on_freelist);
d311 2
a312 2
	printf("\taddr:\tsize:\n");
	printf("free chunks:\n");
d314 2
a315 2
		printf("\t0x%x\t0x%x\t%d\n", md->md_va, md->md_size, md->md_type);
	printf("used chunks:\n");
d317 1
a317 1
		printf("\t0x%x\t0x%x\t%d\n", md->md_va, md->md_size, md->md_type);
@


1.2
log
@This code will not work without UVM.
Add an #error instead of breaking while compiling.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_malloc_debug.c,v 1.1 2000/06/06 20:18:20 art Exp $	*/
d79 2
a80 2
int malloc_deb_type = M_MBUF;
int malloc_deb_size = 128;
@


1.1
log
@malloc debugging code. Enabled by option MALLOC_DEBUG.
Make sure you read the docs (malloc(9)) before use.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 4
@

