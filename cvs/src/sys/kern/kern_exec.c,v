head	1.187;
access;
symbols
	OPENBSD_6_1_BASE:1.187
	OPENBSD_6_0:1.182.0.2
	OPENBSD_6_0_BASE:1.182
	OPENBSD_5_9:1.173.0.2
	OPENBSD_5_9_BASE:1.173
	OPENBSD_5_8:1.163.0.4
	OPENBSD_5_8_BASE:1.163
	OPENBSD_5_7:1.160.0.2
	OPENBSD_5_7_BASE:1.160
	OPENBSD_5_6:1.144.0.4
	OPENBSD_5_6_BASE:1.144
	OPENBSD_5_5:1.137.0.4
	OPENBSD_5_5_BASE:1.137
	OPENBSD_5_4:1.135.0.2
	OPENBSD_5_4_BASE:1.135
	OPENBSD_5_3:1.132.0.2
	OPENBSD_5_3_BASE:1.132
	OPENBSD_5_2:1.131.0.2
	OPENBSD_5_2_BASE:1.131
	OPENBSD_5_1_BASE:1.122
	OPENBSD_5_1:1.122.0.2
	OPENBSD_5_0:1.119.0.2
	OPENBSD_5_0_BASE:1.119
	OPENBSD_4_9:1.114.0.2
	OPENBSD_4_9_BASE:1.114
	OPENBSD_4_8:1.113.0.2
	OPENBSD_4_8_BASE:1.113
	OPENBSD_4_7:1.111.0.2
	OPENBSD_4_7_BASE:1.111
	OPENBSD_4_6:1.109.0.6
	OPENBSD_4_6_BASE:1.109
	OPENBSD_4_5:1.109.0.2
	OPENBSD_4_5_BASE:1.109
	OPENBSD_4_4:1.106.0.4
	OPENBSD_4_4_BASE:1.106
	OPENBSD_4_3:1.106.0.2
	OPENBSD_4_3_BASE:1.106
	OPENBSD_4_2:1.102.0.2
	OPENBSD_4_2_BASE:1.102
	OPENBSD_4_1:1.101.0.2
	OPENBSD_4_1_BASE:1.101
	OPENBSD_4_0:1.99.0.4
	OPENBSD_4_0_BASE:1.99
	OPENBSD_3_9:1.99.0.2
	OPENBSD_3_9_BASE:1.99
	OPENBSD_3_8:1.95.0.2
	OPENBSD_3_8_BASE:1.95
	OPENBSD_3_7:1.91.0.2
	OPENBSD_3_7_BASE:1.91
	OPENBSD_3_6:1.90.0.2
	OPENBSD_3_6_BASE:1.90
	SMP_SYNC_A:1.86
	SMP_SYNC_B:1.85
	OPENBSD_3_5:1.84.0.2
	OPENBSD_3_5_BASE:1.84
	OPENBSD_3_4:1.82.0.2
	OPENBSD_3_4_BASE:1.82
	UBC_SYNC_A:1.77
	OPENBSD_3_3:1.76.0.2
	OPENBSD_3_3_BASE:1.76
	OPENBSD_3_2:1.71.0.2
	OPENBSD_3_2_BASE:1.71
	OPENBSD_3_1:1.66.0.2
	OPENBSD_3_1_BASE:1.66
	UBC_SYNC_B:1.72
	UBC:1.61.0.2
	UBC_BASE:1.61
	OPENBSD_3_0:1.57.0.2
	OPENBSD_3_0_BASE:1.57
	OPENBSD_2_9_BASE:1.48
	OPENBSD_2_9:1.48.0.2
	OPENBSD_2_8:1.44.0.2
	OPENBSD_2_8_BASE:1.44
	OPENBSD_2_7:1.42.0.2
	OPENBSD_2_7_BASE:1.42
	SMP:1.39.0.2
	SMP_BASE:1.39
	kame_19991208:1.34
	OPENBSD_2_6:1.33.0.2
	OPENBSD_2_6_BASE:1.33
	OPENBSD_2_5:1.26.0.2
	OPENBSD_2_5_BASE:1.26
	OPENBSD_2_4:1.25.0.2
	OPENBSD_2_4_BASE:1.25
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.187
date	2017.02.11.19.51.06;	author guenther;	state Exp;
branches;
next	1.186;
commitid	dp1qF9REvzwtzfTw;

1.186
date	2017.02.08.20.58.30;	author guenther;	state Exp;
branches;
next	1.185;
commitid	RODF8jyufTSNUZTf;

1.185
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.184;
commitid	CHRb0fCqa8XxUAMH;

1.184
date	2016.10.22.02.09.14;	author guenther;	state Exp;
branches;
next	1.183;
commitid	FjcuMmImMahb8P8A;

1.183
date	2016.09.03.14.28.24;	author jca;	state Exp;
branches;
next	1.182;
commitid	1psjyNFSatHAsvLc;

1.182
date	2016.06.11.21.00.11;	author kettenis;	state Exp;
branches;
next	1.181;
commitid	Pq6Tojlrqk2IMD8v;

1.181
date	2016.05.30.21.31.29;	author deraadt;	state Exp;
branches;
next	1.180;
commitid	KDWNECRaSEemSTKP;

1.180
date	2016.05.30.21.25.48;	author deraadt;	state Exp;
branches;
next	1.179;
commitid	EKR1QpDNmTXzcvJY;

1.179
date	2016.05.30.21.22.45;	author deraadt;	state Exp;
branches;
next	1.178;
commitid	WldUSxuLRn3bASy2;

1.178
date	2016.05.23.20.11.47;	author deraadt;	state Exp;
branches;
next	1.177;
commitid	0oWSDXhpPUnuLpPD;

1.177
date	2016.05.10.18.39.51;	author deraadt;	state Exp;
branches;
next	1.176;
commitid	qfOifNidEGDB2jL1;

1.176
date	2016.04.25.20.00.33;	author tedu;	state Exp;
branches;
next	1.175;
commitid	MLNYUlvoOtU8VX0s;

1.175
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.174;
commitid	gAjwyca5TfuoJAhn;

1.174
date	2016.03.06.20.25.27;	author guenther;	state Exp;
branches;
next	1.173;
commitid	PPKYgV5KWXY1sNxp;

1.173
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.172;
commitid	Cl55DD2g2xm69E6W;

1.172
date	2015.11.02.16.31.55;	author semarie;	state Exp;
branches;
next	1.171;
commitid	PyvdcQVr9G4daVnG;

1.171
date	2015.10.28.11.13.41;	author deraadt;	state Exp;
branches;
next	1.170;
commitid	dqnQWDnKFJUXeRNf;

1.170
date	2015.10.25.20.39.54;	author deraadt;	state Exp;
branches;
next	1.169;
commitid	SIwCBDJKKae61tEi;

1.169
date	2015.10.10.14.46.15;	author deraadt;	state Exp;
branches;
next	1.168;
commitid	lDLsX85yoZrvGrDS;

1.168
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.167;
commitid	av6ZVErLSWkVP5Zz;

1.167
date	2015.10.07.03.47.43;	author deraadt;	state Exp;
branches;
next	1.166;
commitid	Ge0gajSA2YHu7mGQ;

1.166
date	2015.10.02.15.49.22;	author deraadt;	state Exp;
branches;
next	1.165;
commitid	MIIvvuY5OYWOolF8;

1.165
date	2015.10.02.05.07.41;	author guenther;	state Exp;
branches;
next	1.164;
commitid	m4jkpHQAAdeQKWoV;

1.164
date	2015.09.28.20.32.59;	author deraadt;	state Exp;
branches;
next	1.163;
commitid	frMdHMPeIFVK1Idn;

1.163
date	2015.07.22.05.31.33;	author deraadt;	state Exp;
branches;
next	1.162;
commitid	F33ujWqbaC9CwEXT;

1.162
date	2015.07.20.00.56.10;	author guenther;	state Exp;
branches;
next	1.161;
commitid	pi31sn0pO464Xi5e;

1.161
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.160;
commitid	p4LJxGKbi0BU2cG6;

1.160
date	2015.02.09.11.52.47;	author miod;	state Exp;
branches
	1.160.2.1;
next	1.159;
commitid	3LyovzkL8t513Pbn;

1.159
date	2015.02.09.09.39.09;	author miod;	state Exp;
branches;
next	1.158;
commitid	Dny5EZ91sz8fb6Ea;

1.158
date	2015.02.07.08.47.49;	author tedu;	state Exp;
branches;
next	1.157;
commitid	v6f9Oc8DClWEIiS0;

1.157
date	2015.01.26.22.51.37;	author kettenis;	state Exp;
branches;
next	1.156;
commitid	4sRCDm8befLIJUvK;

1.156
date	2015.01.20.19.43.21;	author kettenis;	state Exp;
branches;
next	1.155;
commitid	Fn841MmVYz2JHvBP;

1.155
date	2015.01.15.16.31.19;	author kettenis;	state Exp;
branches;
next	1.154;
commitid	KydC0RrAIvgU8kGO;

1.154
date	2015.01.15.10.04.26;	author kettenis;	state Exp;
branches;
next	1.153;
commitid	VHbtwfqYWfhM6JTm;

1.153
date	2014.12.17.06.58.11;	author guenther;	state Exp;
branches;
next	1.152;
commitid	DImukoCWyTxwdbuh;

1.152
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.151;
commitid	P6Av4XGqOi3rFasL;

1.151
date	2014.12.15.02.24.23;	author guenther;	state Exp;
branches;
next	1.150;
commitid	ZxaujiOM0aYQRjFY;

1.150
date	2014.12.10.02.44.46;	author tedu;	state Exp;
branches;
next	1.149;
commitid	tsoJBlEBSyYO22RG;

1.149
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.148;
commitid	Z1vcFtHO8wRH0yRt;

1.148
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.147;
commitid	yv0ECmCdICvq576h;

1.147
date	2014.10.18.15.20.32;	author kettenis;	state Exp;
branches;
next	1.146;
commitid	A0328QnbZxiZhTBO;

1.146
date	2014.09.28.18.52.04;	author kettenis;	state Exp;
branches;
next	1.145;
commitid	p4obyg5p6bHyWTFt;

1.145
date	2014.09.08.01.47.06;	author guenther;	state Exp;
branches;
next	1.144;
commitid	QKTb36RFnfteZJPE;

1.144
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches
	1.144.4.1;
next	1.143;
commitid	QlVV51SZgNFxsXxC;

1.143
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.142;
commitid	EF98ch02VpFassUi;

1.142
date	2014.05.15.03.52.25;	author guenther;	state Exp;
branches;
next	1.141;

1.141
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.140;

1.140
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.139;

1.139
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.138;

1.138
date	2014.03.19.00.01.56;	author deraadt;	state Exp;
branches;
next	1.137;

1.137
date	2014.01.21.01.48.44;	author tedu;	state Exp;
branches
	1.137.4.1;
next	1.136;

1.136
date	2014.01.20.03.23.42;	author guenther;	state Exp;
branches;
next	1.135;

1.135
date	2013.06.17.19.11.54;	author guenther;	state Exp;
branches
	1.135.2.1;
next	1.134;

1.134
date	2013.03.30.06.32.25;	author tedu;	state Exp;
branches;
next	1.133;

1.133
date	2013.03.28.16.55.25;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2012.08.02.03.18.48;	author guenther;	state Exp;
branches;
next	1.131;

1.131
date	2012.05.01.03.21.50;	author guenther;	state Exp;
branches;
next	1.130;

1.130
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.129;

1.129
date	2012.04.13.16.37.50;	author kettenis;	state Exp;
branches;
next	1.128;

1.128
date	2012.04.12.10.11.41;	author mikeb;	state Exp;
branches;
next	1.127;

1.127
date	2012.03.26.04.19.55;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.125;

1.125
date	2012.03.09.13.01.28;	author ariane;	state Exp;
branches;
next	1.124;

1.124
date	2012.02.20.22.23.39;	author guenther;	state Exp;
branches;
next	1.123;

1.123
date	2012.02.15.04.26.27;	author guenther;	state Exp;
branches;
next	1.122;

1.122
date	2011.12.14.07.32.16;	author guenther;	state Exp;
branches;
next	1.121;

1.121
date	2011.12.11.19.42.28;	author guenther;	state Exp;
branches;
next	1.120;

1.120
date	2011.10.16.05.29.51;	author guenther;	state Exp;
branches;
next	1.119;

1.119
date	2011.06.06.17.10.23;	author ariane;	state Exp;
branches;
next	1.118;

1.118
date	2011.05.24.15.27.36;	author ariane;	state Exp;
branches;
next	1.117;

1.117
date	2011.04.04.13.00.13;	author guenther;	state Exp;
branches;
next	1.116;

1.116
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.115;

1.115
date	2011.04.02.17.04.35;	author guenther;	state Exp;
branches;
next	1.114;

1.114
date	2010.11.24.21.05.20;	author miod;	state Exp;
branches;
next	1.113;

1.113
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.112;

1.112
date	2010.05.18.22.26.10;	author tedu;	state Exp;
branches;
next	1.111;

1.111
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.110;

1.110
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.109;

1.109
date	2009.01.04.00.28.42;	author thib;	state Exp;
branches;
next	1.108;

1.108
date	2008.10.31.17.17.00;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2008.10.31.17.15.29;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2008.02.13.19.31.22;	author kettenis;	state Exp;
branches;
next	1.105;

1.105
date	2007.12.11.22.09.29;	author kettenis;	state Exp;
branches;
next	1.104;

1.104
date	2007.10.29.14.12.19;	author chl;	state Exp;
branches;
next	1.103;

1.103
date	2007.09.15.10.10.37;	author martin;	state Exp;
branches;
next	1.102;

1.102
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.101;

1.101
date	2007.03.01.11.18.40;	author art;	state Exp;
branches;
next	1.100;

1.100
date	2006.11.15.17.25.40;	author jmc;	state Exp;
branches;
next	1.99;

1.99
date	2006.01.19.17.54.47;	author mickey;	state Exp;
branches;
next	1.98;

1.98
date	2005.12.07.19.04.53;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2005.12.03.18.09.08;	author tedu;	state Exp;
branches;
next	1.96;

1.96
date	2005.11.28.00.14.28;	author jsg;	state Exp;
branches;
next	1.95;

1.95
date	2005.08.14.11.02.33;	author miod;	state Exp;
branches
	1.95.2.1;
next	1.94;

1.94
date	2005.08.01.07.02.39;	author art;	state Exp;
branches;
next	1.93;

1.93
date	2005.07.07.23.43.04;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2005.04.11.20.05.51;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2005.03.09.17.41.29;	author miod;	state Exp;
branches
	1.91.2.1;
next	1.90;

1.90
date	2004.08.24.23.01.26;	author mickey;	state Exp;
branches;
next	1.89;

1.89
date	2004.08.01.06.25.54;	author mickey;	state Exp;
branches;
next	1.88;

1.88
date	2004.07.07.07.31.40;	author marius;	state Exp;
branches;
next	1.87;

1.87
date	2004.06.23.05.16.35;	author marius;	state Exp;
branches;
next	1.86;

1.86
date	2004.06.11.12.57.36;	author mickey;	state Exp;
branches;
next	1.85;

1.85
date	2004.05.14.04.00.33;	author tedu;	state Exp;
branches;
next	1.84;

1.84
date	2004.03.12.09.32.55;	author tedu;	state Exp;
branches;
next	1.83;

1.83
date	2004.02.05.22.56.10;	author millert;	state Exp;
branches;
next	1.82;

1.82
date	2003.09.01.18.06.03;	author henning;	state Exp;
branches
	1.82.2.1;
next	1.81;

1.81
date	2003.08.21.18.56.07;	author tedu;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.21.00.42.58;	author tedu;	state Exp;
branches;
next	1.79;

1.79
date	2003.06.02.01.29.56;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2003.05.17.14.02.06;	author grange;	state Exp;
branches;
next	1.77;

1.77
date	2003.04.14.04.53.50;	author art;	state Exp;
branches;
next	1.76;

1.76
date	2003.03.09.01.27.50;	author millert;	state Exp;
branches;
next	1.75;

1.75
date	2002.12.11.00.08.08;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2002.12.04.04.31.20;	author art;	state Exp;
branches;
next	1.73;

1.73
date	2002.11.09.04.12.32;	author mickey;	state Exp;
branches;
next	1.72;

1.72
date	2002.10.06.22.39.25;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2002.09.23.01.41.09;	author art;	state Exp;
branches;
next	1.70;

1.70
date	2002.08.22.22.04.42;	author art;	state Exp;
branches;
next	1.69;

1.69
date	2002.07.25.01.21.51;	author nordin;	state Exp;
branches;
next	1.68;

1.68
date	2002.07.20.19.24.57;	author art;	state Exp;
branches;
next	1.67;

1.67
date	2002.05.02.00.36.04;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2002.03.14.17.17.23;	author mickey;	state Exp;
branches
	1.66.2.1;
next	1.65;

1.65
date	2002.02.17.04.31.26;	author art;	state Exp;
branches;
next	1.64;

1.64
date	2002.02.08.13.53.28;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2002.01.20.11.27.52;	author art;	state Exp;
branches;
next	1.62;

1.62
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2001.11.27.05.27.11;	author art;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2001.11.12.01.26.09;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2001.10.26.12.03.27;	author art;	state Exp;
branches;
next	1.57;

1.57
date	2001.09.19.20.50.58;	author mickey;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2001.08.25.20.37.06;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2001.08.18.03.32.16;	author art;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.27.04.49.41;	author art;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.22.23.55.23;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.22.14.14.08;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.19.07.54.36;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.18.13.28.41;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.15.11.10.18;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2001.04.01.21.30.33;	author art;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2001.02.22.16.08.01;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2000.11.16.20.02.16;	author provos;	state Exp;
branches;
next	1.45;

1.45
date	2000.11.10.18.15.46;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2000.09.28.13.41.39;	author art;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2000.09.26.14.01.39;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2000.04.20.10.03.42;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2000.03.23.15.55.52;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2000.03.22.21.35.37;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2000.02.01.04.03.14;	author assar;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2000.01.24.22.44.58;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2000.01.20.09.30.02;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2000.01.20.01.16.50;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2000.01.19.23.03.04;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	99.11.05.01.18.01;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	99.08.09.12.19.07;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	99.07.15.14.11.05;	author art;	state Exp;
branches;
next	1.31;

1.31
date	99.07.15.14.07.41;	author art;	state Exp;
branches;
next	1.30;

1.30
date	99.07.13.15.17.50;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	99.06.23.09.44.28;	author art;	state Exp;
branches;
next	1.28;

1.28
date	99.06.03.16.01.26;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	99.04.22.19.37.43;	author art;	state Exp;
branches;
next	1.26;

1.26
date	99.02.26.05.05.38;	author art;	state Exp;
branches;
next	1.25;

1.25
date	98.09.24.18.49.31;	author art;	state Exp;
branches;
next	1.24;

1.24
date	98.09.23.22.48.08;	author art;	state Exp;
branches;
next	1.23;

1.23
date	98.07.28.00.13.05;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	98.07.08.22.28.56;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.07.02.09.03.42;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.07.02.08.53.04;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	98.06.27.07.32.12;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	98.06.09.17.23.04;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.02.20.14.45.16;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	98.02.08.22.41.34;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	97.11.06.05.58.15;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	97.10.06.20.19.51;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.10.06.15.12.16;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	97.08.01.22.54.50;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.06.05.08.05.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.06.04.14.34.17;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.03.29.20.10.01;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	97.02.18.00.16.05;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.31.09.24.09;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	96.08.25.09.53.45;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.11.00.53.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.27.07.59.03;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.17.19.43;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.09.14;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches;
next	;

1.39.2.1
date	2000.03.24.09.09.24;	author niklas;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2001.05.14.22.32.40;	author niklas;	state Exp;
branches;
next	1.39.2.3;

1.39.2.3
date	2001.07.04.10.48.16;	author niklas;	state Exp;
branches;
next	1.39.2.4;

1.39.2.4
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.39.2.5;

1.39.2.5
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.39.2.6;

1.39.2.6
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.39.2.7;

1.39.2.7
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.39.2.8;

1.39.2.8
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.39.2.9;

1.39.2.9
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.39.2.10;

1.39.2.10
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.39.2.11;

1.39.2.11
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.39.2.12;

1.39.2.12
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.39.2.13;

1.39.2.13
date	2004.06.05.23.13.01;	author niklas;	state Exp;
branches;
next	1.39.2.14;

1.39.2.14
date	2004.06.13.08.50.15;	author niklas;	state Exp;
branches;
next	;

1.44.2.1
date	2001.06.15.20.41.28;	author miod;	state Exp;
branches;
next	;

1.48.2.1
date	2001.06.16.02.30.46;	author jason;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2002.02.20.08.52.33;	author miod;	state Exp;
branches;
next	1.48.2.3;

1.48.2.3
date	2002.05.08.23.00.22;	author millert;	state Exp;
branches;
next	;

1.57.2.1
date	2002.01.23.03.10.01;	author jason;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	2002.05.08.22.56.55;	author miod;	state Exp;
branches;
next	;

1.61.2.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.61.2.3;

1.61.2.3
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.61.2.4;

1.61.2.4
date	2003.05.19.22.31.09;	author tedu;	state Exp;
branches;
next	;

1.66.2.1
date	2002.05.08.22.56.13;	author jason;	state Exp;
branches;
next	;

1.82.2.1
date	2004.04.15.09.26.34;	author brad;	state Exp;
branches;
next	;

1.91.2.1
date	2005.12.30.01.28.02;	author brad;	state Exp;
branches;
next	;

1.95.2.1
date	2005.12.22.02.41.54;	author brad;	state Exp;
branches;
next	;

1.135.2.1
date	2014.10.19.22.17.52;	author tedu;	state Exp;
branches;
next	;
commitid	oyIStBIxXgQqU9Tg;

1.137.4.1
date	2014.10.19.22.17.58;	author tedu;	state Exp;
branches;
next	;
commitid	P2TsqXWJCb0OswFG;

1.144.4.1
date	2014.10.19.22.18.02;	author tedu;	state Exp;
branches;
next	1.144.4.2;
commitid	Beas8Ngjbcd6jCle;

1.144.4.2
date	2015.07.27.15.53.40;	author guenther;	state Exp;
branches;
next	;
commitid	BnX30Y66a65JwHUZ;

1.160.2.1
date	2015.07.27.15.51.28;	author krw;	state Exp;
branches;
next	;
commitid	VaWCZLNit1BEtzgi;


desc
@@


1.187
log
@Add a flags argument to falloc() that lets it optionally set the
close-on-exec flag on the newly allocated fd.  Make falloc()'s
return arguments non-optional: assert that they're not NULL.

ok mpi@@ millert@@
@
text
@/*	$OpenBSD: kern_exec.c,v 1.186 2017/02/08 20:58:30 guenther Exp $	*/
/*	$NetBSD: kern_exec.c,v 1.75 1996/02/09 18:59:28 christos Exp $	*/

/*-
 * Copyright (C) 1993, 1994 Christopher G. Demetriou
 * Copyright (C) 1992 Wolfgang Solfrank.
 * Copyright (C) 1992 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/filedesc.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/mount.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/file.h>
#include <sys/acct.h>
#include <sys/exec.h>
#include <sys/ktrace.h>
#include <sys/resourcevar.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <sys/signalvar.h>
#include <sys/stat.h>
#include <sys/conf.h>
#include <sys/pledge.h>
#ifdef SYSVSHM
#include <sys/shm.h>
#endif

#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

#ifdef __HAVE_MD_TCB
# include <machine/tcb.h>
#endif

const struct kmem_va_mode kv_exec = {
	.kv_wait = 1,
	.kv_map = &exec_map
};

/*
 * Map the shared signal code.
 */
int exec_sigcode_map(struct process *, struct emul *);

/*
 * If non-zero, stackgap_random specifies the upper limit of the random gap size
 * added to the fixed stack position. Must be n^2.
 */
int stackgap_random = STACKGAP_RANDOM;

/*
 * check exec:
 * given an "executable" described in the exec package's namei info,
 * see what we can do with it.
 *
 * ON ENTRY:
 *	exec package with appropriate namei info
 *	proc pointer of exec'ing proc
 *	NO SELF-LOCKED VNODES
 *
 * ON EXIT:
 *	error:	nothing held, etc.  exec header still allocated.
 *	ok:	filled exec package, one locked vnode.
 *
 * EXEC SWITCH ENTRY:
 * 	Locked vnode to check, exec package, proc.
 *
 * EXEC SWITCH EXIT:
 *	ok:	return 0, filled exec package, one locked vnode.
 *	error:	destructive:
 *			everything deallocated except exec header.
 *		non-destructive:
 *			error code, locked vnode, exec header unmodified
 */
int
check_exec(struct proc *p, struct exec_package *epp)
{
	int error, i;
	struct vnode *vp;
	struct nameidata *ndp;
	size_t resid;

	ndp = epp->ep_ndp;
	ndp->ni_cnd.cn_nameiop = LOOKUP;
	ndp->ni_cnd.cn_flags = FOLLOW | LOCKLEAF | SAVENAME;
	/* first get the vnode */
	if ((error = namei(ndp)) != 0)
		return (error);
	epp->ep_vp = vp = ndp->ni_vp;

	/* check for regular file */
	if (vp->v_type == VDIR) {
		error = EISDIR;
		goto bad1;
	}
	if (vp->v_type != VREG) {
		error = EACCES;
		goto bad1;
	}

	/* get attributes */
	if ((error = VOP_GETATTR(vp, epp->ep_vap, p->p_ucred, p)) != 0)
		goto bad1;

	/* Check mount point */
	if (vp->v_mount->mnt_flag & MNT_NOEXEC) {
		error = EACCES;
		goto bad1;
	}

	if ((vp->v_mount->mnt_flag & MNT_NOSUID))
		epp->ep_vap->va_mode &= ~(VSUID | VSGID);

	/* check access.  for root we have to see if any exec bit on */
	if ((error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p)) != 0)
		goto bad1;
	if ((epp->ep_vap->va_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) == 0) {
		error = EACCES;
		goto bad1;
	}

	/* try to open it */
	if ((error = VOP_OPEN(vp, FREAD, p->p_ucred, p)) != 0)
		goto bad1;

	/* unlock vp, we need it unlocked from here */
	VOP_UNLOCK(vp, p);

	/* now we have the file, get the exec header */
	error = vn_rdwr(UIO_READ, vp, epp->ep_hdr, epp->ep_hdrlen, 0,
	    UIO_SYSSPACE, 0, p->p_ucred, &resid, p);
	if (error)
		goto bad2;
	epp->ep_hdrvalid = epp->ep_hdrlen - resid;

	/*
	 * set up the vmcmds for creation of the process
	 * address space
	 */
	error = ENOEXEC;
	for (i = 0; i < nexecs && error != 0; i++) {
		int newerror;

		if (execsw[i].es_check == NULL)
			continue;
		newerror = (*execsw[i].es_check)(p, epp);
		if (!newerror && !(epp->ep_emul->e_flags & EMUL_ENABLED))
			newerror = EPERM;
		/* make sure the first "interesting" error code is saved. */
		if (!newerror || error == ENOEXEC)
			error = newerror;
		if (epp->ep_flags & EXEC_DESTR && error != 0)
			return (error);
	}
	if (!error) {
		/* check that entry point is sane */
		if (epp->ep_entry > VM_MAXUSER_ADDRESS) {
			error = ENOEXEC;
		}

		/* check limits */
		if ((epp->ep_tsize > MAXTSIZ) ||
		    (epp->ep_dsize > p->p_rlimit[RLIMIT_DATA].rlim_cur))
			error = ENOMEM;

		if (!error)
			return (0);
	}

	/*
	 * free any vmspace-creation commands,
	 * and release their references
	 */
	kill_vmcmds(&epp->ep_vmcmds);

bad2:
	/*
	 * close the vnode, free the pathname buf, and punt.
	 */
	vn_close(vp, FREAD, p->p_ucred, p);
	pool_put(&namei_pool, ndp->ni_cnd.cn_pnbuf);
	return (error);

bad1:
	/*
	 * free the namei pathname buffer, and put the vnode
	 * (which we don't yet have open).
	 */
	pool_put(&namei_pool, ndp->ni_cnd.cn_pnbuf);
	vput(vp);
	return (error);
}

/*
 * exec system call
 */
int
sys_execve(struct proc *p, void *v, register_t *retval)
{
	struct sys_execve_args /* {
		syscallarg(const char *) path;
		syscallarg(char *const *) argp;
		syscallarg(char *const *) envp;
	} */ *uap = v;
	int error;
	struct exec_package pack;
	struct nameidata nid;
	struct vattr attr;
	struct ucred *cred = p->p_ucred;
	char *argp;
	char * const *cpp, *dp, *sp;
#ifdef KTRACE
	char *env_start;
#endif
	struct process *pr = p->p_p;
	long argc, envc;
	size_t len, sgap;
#ifdef MACHINE_STACK_GROWS_UP
	size_t slen;
#endif
	char *stack;
	struct ps_strings arginfo;
	struct vmspace *vm;
	char **tmpfap;
	extern struct emul emul_native;
	struct vnode *otvp;

	/* get other threads to stop */
	if ((error = single_thread_set(p, SINGLE_UNWIND, 1)))
		return (error);

	/*
	 * Cheap solution to complicated problems.
	 * Mark this process as "leave me alone, I'm execing".
	 */
	atomic_setbits_int(&pr->ps_flags, PS_INEXEC);

	NDINIT(&nid, LOOKUP, NOFOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	nid.ni_pledge = PLEDGE_EXEC;

	/*
	 * initialize the fields of the exec package.
	 */
	pack.ep_name = (char *)SCARG(uap, path);
	pack.ep_hdr = malloc(exec_maxhdrsz, M_EXEC, M_WAITOK);
	pack.ep_hdrlen = exec_maxhdrsz;
	pack.ep_hdrvalid = 0;
	pack.ep_ndp = &nid;
	pack.ep_interp = NULL;
	pack.ep_emul_arg = NULL;
	VMCMDSET_INIT(&pack.ep_vmcmds);
	pack.ep_vap = &attr;
	pack.ep_emul = &emul_native;
	pack.ep_flags = 0;

	/* see if we can run it. */
	if ((error = check_exec(p, &pack)) != 0) {
		goto freehdr;
	}

	/* XXX -- THE FOLLOWING SECTION NEEDS MAJOR CLEANUP */

	/* allocate an argument buffer */
	argp = km_alloc(NCARGS, &kv_exec, &kp_pageable, &kd_waitok);
#ifdef DIAGNOSTIC
	if (argp == NULL)
		panic("execve: argp == NULL");
#endif
	dp = argp;
	argc = 0;

	/* copy the fake args list, if there's one, freeing it as we go */
	if (pack.ep_flags & EXEC_HASARGL) {
		tmpfap = pack.ep_fa;
		while (*tmpfap != NULL) {
			char *cp;

			cp = *tmpfap;
			while (*cp)
				*dp++ = *cp++;
			*dp++ = '\0';

			free(*tmpfap, M_EXEC, 0);
			tmpfap++; argc++;
		}
		free(pack.ep_fa, M_EXEC, 0);
		pack.ep_flags &= ~EXEC_HASARGL;
	}

	/* Now get argv & environment */
	if (!(cpp = SCARG(uap, argp))) {
		error = EFAULT;
		goto bad;
	}

	if (pack.ep_flags & EXEC_SKIPARG)
		cpp++;

	while (1) {
		len = argp + ARG_MAX - dp;
		if ((error = copyin(cpp, &sp, sizeof(sp))) != 0)
			goto bad;
		if (!sp)
			break;
		if ((error = copyinstr(sp, dp, len, &len)) != 0) {
			if (error == ENAMETOOLONG)
				error = E2BIG;
			goto bad;
		}
		dp += len;
		cpp++;
		argc++;
	}

	/* must have at least one argument */
	if (argc == 0) {
		error = EINVAL;
		goto bad;
	}

#ifdef KTRACE
	if (KTRPOINT(p, KTR_EXECARGS))
		ktrexec(p, KTR_EXECARGS, argp, dp - argp);
#endif

	envc = 0;
	/* environment does not need to be there */
	if ((cpp = SCARG(uap, envp)) != NULL ) {
#ifdef KTRACE
		env_start = dp;
#endif
		while (1) {
			len = argp + ARG_MAX - dp;
			if ((error = copyin(cpp, &sp, sizeof(sp))) != 0)
				goto bad;
			if (!sp)
				break;
			if ((error = copyinstr(sp, dp, len, &len)) != 0) {
				if (error == ENAMETOOLONG)
					error = E2BIG;
				goto bad;
			}
			dp += len;
			cpp++;
			envc++;
		}

#ifdef KTRACE
		if (KTRPOINT(p, KTR_EXECENV))
			ktrexec(p, KTR_EXECENV, env_start, dp - env_start);
#endif
	}

	dp = (char *)(((long)dp + _STACKALIGNBYTES) & ~_STACKALIGNBYTES);

	sgap = STACKGAPLEN;

	/*
	 * If we have enabled random stackgap, the stack itself has already
	 * been moved from a random location, but is still aligned to a page
	 * boundary.  Provide the lower bits of random placement now.
	 */
	if (stackgap_random != 0) {
		sgap += arc4random() & PAGE_MASK;
		sgap = (sgap + _STACKALIGNBYTES) & ~_STACKALIGNBYTES;
	}

	/* Now check if args & environ fit into new stack */
	len = ((argc + envc + 2 + pack.ep_emul->e_arglen) * sizeof(char *) +
	    sizeof(long) + dp + sgap + sizeof(struct ps_strings)) - argp;

	len = (len + _STACKALIGNBYTES) &~ _STACKALIGNBYTES;

	if (len > pack.ep_ssize) { /* in effect, compare to initial limit */
		error = ENOMEM;
		goto bad;
	}

	/* adjust "active stack depth" for process VSZ */
	pack.ep_ssize = len;	/* maybe should go elsewhere, but... */

	/*
	 * we're committed: any further errors will kill the process, so
	 * kill the other threads now.
	 */
	single_thread_set(p, SINGLE_EXIT, 0);

	/*
	 * Prepare vmspace for remapping. Note that uvmspace_exec can replace
	 * ps_vmspace!
	 */
	uvmspace_exec(p, VM_MIN_ADDRESS, VM_MAXUSER_ADDRESS);

	vm = pr->ps_vmspace;
	/* Now map address space */
	vm->vm_taddr = (char *)trunc_page(pack.ep_taddr);
	vm->vm_tsize = atop(round_page(pack.ep_taddr + pack.ep_tsize) -
	    trunc_page(pack.ep_taddr));
	vm->vm_daddr = (char *)trunc_page(pack.ep_daddr);
	vm->vm_dsize = atop(round_page(pack.ep_daddr + pack.ep_dsize) -
	    trunc_page(pack.ep_daddr));
	vm->vm_dused = 0;
	vm->vm_ssize = atop(round_page(pack.ep_ssize));
	vm->vm_maxsaddr = (char *)pack.ep_maxsaddr;
	vm->vm_minsaddr = (char *)pack.ep_minsaddr;

	/* create the new process's VM space by running the vmcmds */
#ifdef DIAGNOSTIC
	if (pack.ep_vmcmds.evs_used == 0)
		panic("execve: no vmcmds");
#endif
	error = exec_process_vmcmds(p, &pack);

	/* if an error happened, deallocate and punt */
	if (error)
		goto exec_abort;

	/* old "stackgap" is gone now */
	pr->ps_stackgap = 0;

#ifdef MACHINE_STACK_GROWS_UP
	pr->ps_strings = (vaddr_t)vm->vm_maxsaddr + sgap;
        if (uvm_map_protect(&vm->vm_map, (vaddr_t)vm->vm_maxsaddr,
            trunc_page(pr->ps_strings), PROT_NONE, TRUE))
                goto exec_abort;
#else
	pr->ps_strings = (vaddr_t)vm->vm_minsaddr - sizeof(arginfo) - sgap;
        if (uvm_map_protect(&vm->vm_map,
            round_page(pr->ps_strings + sizeof(arginfo)),
            (vaddr_t)vm->vm_minsaddr, PROT_NONE, TRUE))
                goto exec_abort;
#endif

	/* remember information about the process */
	arginfo.ps_nargvstr = argc;
	arginfo.ps_nenvstr = envc;

#ifdef MACHINE_STACK_GROWS_UP
	stack = (char *)vm->vm_maxsaddr + sizeof(arginfo) + sgap;
	slen = len - sizeof(arginfo) - sgap;
#else
	stack = (char *)(vm->vm_minsaddr - len);
#endif
	/* Now copy argc, args & environ to new stack */
	if (!(*pack.ep_emul->e_copyargs)(&pack, &arginfo, stack, argp))
		goto exec_abort;

	/* copy out the process's ps_strings structure */
	if (copyout(&arginfo, (char *)pr->ps_strings, sizeof(arginfo)))
		goto exec_abort;

	stopprofclock(pr);	/* stop profiling */
	fdcloseexec(p);		/* handle close on exec */
	execsigs(p);		/* reset caught signals */
	TCB_SET(p, NULL);	/* reset the TCB address */
	pr->ps_kbind_addr = 0;	/* reset the kbind bits */
	pr->ps_kbind_cookie = 0;
	arc4random_buf(&pr->ps_sigcookie, sizeof pr->ps_sigcookie);

	/* set command name & other accounting info */
	memset(pr->ps_comm, 0, sizeof(pr->ps_comm));
	len = min(nid.ni_cnd.cn_namelen, MAXCOMLEN);
	memcpy(pr->ps_comm, nid.ni_cnd.cn_nameptr, len);
	pr->ps_acflag &= ~AFORK;

	/* record proc's vnode, for use by sysctl */
	otvp = pr->ps_textvp;
	vref(pack.ep_vp);
	pr->ps_textvp = pack.ep_vp;
	if (otvp)
		vrele(otvp);

	atomic_setbits_int(&pr->ps_flags, PS_EXEC);
	if (pr->ps_flags & PS_PPWAIT) {
		atomic_clearbits_int(&pr->ps_flags, PS_PPWAIT);
		atomic_clearbits_int(&pr->ps_pptr->ps_flags, PS_ISPWAIT);
		wakeup(pr->ps_pptr);
	}

	/*
	 * If process does execve() while it has a mismatched real,
	 * effective, or saved uid/gid, we set PS_SUGIDEXEC.
	 */
	if (cred->cr_uid != cred->cr_ruid ||
	    cred->cr_uid != cred->cr_svuid ||
	    cred->cr_gid != cred->cr_rgid ||
	    cred->cr_gid != cred->cr_svgid)
		atomic_setbits_int(&pr->ps_flags, PS_SUGIDEXEC);
	else
		atomic_clearbits_int(&pr->ps_flags, PS_SUGIDEXEC);

	atomic_clearbits_int(&pr->ps_flags, PS_PLEDGE);
	pledge_dropwpaths(pr);

	/*
	 * deal with set[ug]id.
	 * MNT_NOEXEC has already been used to disable s[ug]id.
	 */
	if ((attr.va_mode & (VSUID | VSGID)) && proc_cansugid(p)) {
		int i;

		atomic_setbits_int(&pr->ps_flags, PS_SUGID|PS_SUGIDEXEC);

#ifdef KTRACE
		/*
		 * If process is being ktraced, turn off - unless
		 * root set it.
		 */
		if (pr->ps_tracevp && !(pr->ps_traceflag & KTRFAC_ROOT))
			ktrcleartrace(pr);
#endif
		p->p_ucred = cred = crcopy(cred);
		if (attr.va_mode & VSUID)
			cred->cr_uid = attr.va_uid;
		if (attr.va_mode & VSGID)
			cred->cr_gid = attr.va_gid;

		/*
		 * For set[ug]id processes, a few caveats apply to
		 * stdin, stdout, and stderr.
		 */
		error = 0;
		fdplock(p->p_fd);
		for (i = 0; i < 3; i++) {
			struct file *fp = NULL;

			/*
			 * NOTE - This will never return NULL because of
			 * immature fds. The file descriptor table is not
			 * shared because we're suid.
			 */
			fp = fd_getfile(p->p_fd, i);

			/*
			 * Ensure that stdin, stdout, and stderr are already
			 * allocated.  We do not want userland to accidentally
			 * allocate descriptors in this range which has implied
			 * meaning to libc.
			 */
			if (fp == NULL) {
				short flags = FREAD | (i == 0 ? 0 : FWRITE);
				struct vnode *vp;
				int indx;

				if ((error = falloc(p, 0, &fp, &indx)) != 0)
					break;
#ifdef DIAGNOSTIC
				if (indx != i)
					panic("sys_execve: falloc indx != i");
#endif
				if ((error = cdevvp(getnulldev(), &vp)) != 0) {
					fdremove(p->p_fd, indx);
					closef(fp, p);
					break;
				}
				if ((error = VOP_OPEN(vp, flags, cred, p)) != 0) {
					fdremove(p->p_fd, indx);
					closef(fp, p);
					vrele(vp);
					break;
				}
				if (flags & FWRITE)
					vp->v_writecount++;
				fp->f_flag = flags;
				fp->f_type = DTYPE_VNODE;
				fp->f_ops = &vnops;
				fp->f_data = (caddr_t)vp;
				FILE_SET_MATURE(fp, p);
			}
		}
		fdpunlock(p->p_fd);
		if (error)
			goto exec_abort;
	} else
		atomic_clearbits_int(&pr->ps_flags, PS_SUGID);

	/*
	 * Reset the saved ugids and update the process's copy of the
	 * creds if the creds have been changed
	 */
	if (cred->cr_uid != cred->cr_svuid ||
	    cred->cr_gid != cred->cr_svgid) {
		/* make sure we have unshared ucreds */
		p->p_ucred = cred = crcopy(cred);
		cred->cr_svuid = cred->cr_uid;
		cred->cr_svgid = cred->cr_gid;
	}

	if (pr->ps_ucred != cred) {
		struct ucred *ocred;

		ocred = pr->ps_ucred;
		crhold(cred);
		pr->ps_ucred = cred;
		crfree(ocred);
	}

	if (pr->ps_flags & PS_SUGIDEXEC) {
		int i, s = splclock();

		timeout_del(&pr->ps_realit_to);
		for (i = 0; i < nitems(pr->ps_timer); i++) {
			timerclear(&pr->ps_timer[i].it_interval);
			timerclear(&pr->ps_timer[i].it_value);
		}
		splx(s);
	}

	/* reset CPU time usage for the thread, but not the process */
	timespecclear(&p->p_tu.tu_runtime);
	p->p_tu.tu_uticks = p->p_tu.tu_sticks = p->p_tu.tu_iticks = 0;

	km_free(argp, NCARGS, &kv_exec, &kp_pageable);

	pool_put(&namei_pool, nid.ni_cnd.cn_pnbuf);
	vn_close(pack.ep_vp, FREAD, cred, p);

	/*
	 * notify others that we exec'd
	 */
	KNOTE(&pr->ps_klist, NOTE_EXEC);

	/* setup new registers and do misc. setup. */
	if (pack.ep_emul->e_fixup != NULL) {
		if ((*pack.ep_emul->e_fixup)(p, &pack) != 0)
			goto free_pack_abort;
	}
#ifdef MACHINE_STACK_GROWS_UP
	(*pack.ep_emul->e_setregs)(p, &pack, (u_long)stack + slen, retval);
#else
	(*pack.ep_emul->e_setregs)(p, &pack, (u_long)stack, retval);
#endif

	/* map the process's signal trampoline code */
	if (exec_sigcode_map(pr, pack.ep_emul))
		goto free_pack_abort;

#ifdef __HAVE_EXEC_MD_MAP
	/* perform md specific mappings that process might need */
	if (exec_md_map(p, &pack))
		goto free_pack_abort;
#endif

	if (pr->ps_flags & PS_TRACED)
		psignal(p, SIGTRAP);

	free(pack.ep_hdr, M_EXEC, pack.ep_hdrlen);

	p->p_descfd = 255;
	if ((pack.ep_flags & EXEC_HASFD) && pack.ep_fd < 255)
		p->p_descfd = pack.ep_fd;

	if (pack.ep_flags & EXEC_WXNEEDED)
		p->p_p->ps_flags |= PS_WXNEEDED;
	else
		p->p_p->ps_flags &= ~PS_WXNEEDED;

	/* update ps_emul, the old value is no longer needed */
	pr->ps_emul = pack.ep_emul;

	atomic_clearbits_int(&pr->ps_flags, PS_INEXEC);
	single_thread_clear(p, P_SUSPSIG);

	return (0);

bad:
	/* free the vmspace-creation commands, and release their references */
	kill_vmcmds(&pack.ep_vmcmds);
	/* kill any opened file descriptor, if necessary */
	if (pack.ep_flags & EXEC_HASFD) {
		pack.ep_flags &= ~EXEC_HASFD;
		fdplock(p->p_fd);
		(void) fdrelease(p, pack.ep_fd);
		fdpunlock(p->p_fd);
	}
	if (pack.ep_interp != NULL)
		pool_put(&namei_pool, pack.ep_interp);
	if (pack.ep_emul_arg != NULL)
		free(pack.ep_emul_arg, M_TEMP, pack.ep_emul_argsize);
	/* close and put the exec'd file */
	vn_close(pack.ep_vp, FREAD, cred, p);
	pool_put(&namei_pool, nid.ni_cnd.cn_pnbuf);
	km_free(argp, NCARGS, &kv_exec, &kp_pageable);

freehdr:
	free(pack.ep_hdr, M_EXEC, pack.ep_hdrlen);
	atomic_clearbits_int(&pr->ps_flags, PS_INEXEC);
	single_thread_clear(p, P_SUSPSIG);

	return (error);

exec_abort:
	/*
	 * the old process doesn't exist anymore.  exit gracefully.
	 * get rid of the (new) address space we have created, if any, get rid
	 * of our namei data and vnode, and exit noting failure
	 */
	uvm_deallocate(&vm->vm_map, VM_MIN_ADDRESS,
		VM_MAXUSER_ADDRESS - VM_MIN_ADDRESS);
	if (pack.ep_interp != NULL)
		pool_put(&namei_pool, pack.ep_interp);
	if (pack.ep_emul_arg != NULL)
		free(pack.ep_emul_arg, M_TEMP, pack.ep_emul_argsize);
	pool_put(&namei_pool, nid.ni_cnd.cn_pnbuf);
	vn_close(pack.ep_vp, FREAD, cred, p);
	km_free(argp, NCARGS, &kv_exec, &kp_pageable);

free_pack_abort:
	free(pack.ep_hdr, M_EXEC, pack.ep_hdrlen);
	exit1(p, W_EXITCODE(0, SIGABRT), EXIT_NORMAL);

	/* NOTREACHED */
	atomic_clearbits_int(&pr->ps_flags, PS_INEXEC);

	return (0);
}


void *
copyargs(struct exec_package *pack, struct ps_strings *arginfo, void *stack,
    void *argp)
{
	char **cpp = stack;
	char *dp, *sp;
	size_t len;
	void *nullp = NULL;
	long argc = arginfo->ps_nargvstr;
	int envc = arginfo->ps_nenvstr;

	if (copyout(&argc, cpp++, sizeof(argc)))
		return (NULL);

	dp = (char *) (cpp + argc + envc + 2 + pack->ep_emul->e_arglen);
	sp = argp;

	/* XXX don't copy them out, remap them! */
	arginfo->ps_argvstr = cpp; /* remember location of argv for later */

	for (; --argc >= 0; sp += len, dp += len)
		if (copyout(&dp, cpp++, sizeof(dp)) ||
		    copyoutstr(sp, dp, ARG_MAX, &len))
			return (NULL);

	if (copyout(&nullp, cpp++, sizeof(nullp)))
		return (NULL);

	arginfo->ps_envstr = cpp; /* remember location of envp for later */

	for (; --envc >= 0; sp += len, dp += len)
		if (copyout(&dp, cpp++, sizeof(dp)) ||
		    copyoutstr(sp, dp, ARG_MAX, &len))
			return (NULL);

	if (copyout(&nullp, cpp++, sizeof(nullp)))
		return (NULL);

	return (cpp);
}

int
exec_sigcode_map(struct process *pr, struct emul *e)
{
	vsize_t sz;

	sz = (vaddr_t)e->e_esigcode - (vaddr_t)e->e_sigcode;

	/*
	 * If we don't have a sigobject for this emulation, create one.
	 *
	 * sigobject is an anonymous memory object (just like SYSV shared
	 * memory) that we keep a permanent reference to and that we map
	 * in all processes that need this sigcode. The creation is simple,
	 * we create an object, add a permanent reference to it, map it in
	 * kernel space, copy out the sigcode to it and unmap it.
	 * Then we map it with PROT_READ|PROT_EXEC into the process just
	 * the way sys_mmap would map it.
	 */
	if (e->e_sigobject == NULL) {
		extern int sigfillsiz;
		extern u_char sigfill[];
		size_t off;
		vaddr_t va;
		int r;

		e->e_sigobject = uao_create(sz, 0);
		uao_reference(e->e_sigobject);	/* permanent reference */

		if ((r = uvm_map(kernel_map, &va, round_page(sz), e->e_sigobject,
		    0, 0, UVM_MAPFLAG(PROT_READ | PROT_WRITE, PROT_READ | PROT_WRITE,
		    MAP_INHERIT_SHARE, MADV_RANDOM, 0)))) {
			uao_detach(e->e_sigobject);
			return (ENOMEM);
		}

		for (off = 0; off < round_page(sz); off += sigfillsiz)
			memcpy((caddr_t)va + off, sigfill, sigfillsiz);
		memcpy((caddr_t)va, e->e_sigcode, sz);
		uvm_unmap(kernel_map, va, va + round_page(sz));
	}

	pr->ps_sigcode = 0; /* no hint */
	uao_reference(e->e_sigobject);
	if (uvm_map(&pr->ps_vmspace->vm_map, &pr->ps_sigcode, round_page(sz),
	    e->e_sigobject, 0, 0, UVM_MAPFLAG(PROT_READ | PROT_EXEC,
	    PROT_READ | PROT_WRITE | PROT_EXEC, MAP_INHERIT_COPY,
	    MADV_RANDOM, UVM_FLAG_COPYONW))) {
		uao_detach(e->e_sigobject);
		return (ENOMEM);
	}

	/* Calculate PC at point of sigreturn entry */
	pr->ps_sigcoderet = pr->ps_sigcode +
	    (pr->ps_emul->e_esigret - pr->ps_emul->e_sigcode);

	return (0);
}
@


1.186
log
@Delete the obsolete fork/exec/exit emulation hooks.

ok mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.185 2017/01/21 05:42:03 guenther Exp $	*/
d579 1
a579 1
				if ((error = falloc(p, &fp, &indx)) != 0)
@


1.185
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.184 2016/10/22 02:09:14 guenther Exp $	*/
a682 14
	/*
	 * Call emulation specific exec hook. This can setup per-process
	 * p->p_emuldata or do any other per-process stuff an emulation needs.
	 *
	 * If we are executing process of different emulation than the
	 * original forked process, call e_proc_exit() of the old emulation
	 * first, then e_proc_exec() of new emulation. If the emulation is
	 * same, the exec hook code should deallocate any old emulation
	 * resources held previously by this process.
	 */
	if (pr->ps_emul && pr->ps_emul->e_proc_exit &&
	    pr->ps_emul != pack.ep_emul)
		(*pr->ps_emul->e_proc_exit)(p);

a690 7

	/*
	 * Call exec hook. Emulation code may NOT store reference to anything
	 * from &pack.
	 */
	if (pack.ep_emul->e_proc_exec)
		(*pack.ep_emul->e_proc_exec)(p, &pack);
@


1.184
log
@Delete dead copy of pr->ps_vmspace; uvmspace_exec() can change it anyway

ok kettenis@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.183 2016/09/03 14:28:24 jca Exp $	*/
d495 1
a495 1
	memset(p->p_comm, 0, sizeof(p->p_comm));
d497 1
a497 1
	memcpy(p->p_comm, nid.ni_cnd.cn_nameptr, len);
@


1.183
log
@Reset PS_WXNEEDED in execve(2).

The new process should inherit wxneeded perms from the ELF executable only,
not from the former process.

Solution improved by guenther@@, ok guenther@@ deraadt@@, ok tedu@@ on a similar
diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.182 2016/06/11 21:00:11 kettenis Exp $	*/
d257 1
a257 1
	struct vmspace *vm = pr->ps_vmspace;
d424 1
a424 1
	 * pr_vmspace!
@


1.182
log
@Cleanup some systrace leftovers.

ok jca@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.181 2016/05/30 21:31:29 deraadt Exp $	*/
d703 2
@


1.181
log
@Identify W^X labelled binaries at execve() time based upon WX_OPENBSD_WXNEEDED
flag set by ld -zwxneeded.  Such binaries are allowed to run only on wxallowed
mountpoints.  They do not report mmap/mprotect problems.

Rate limit mmap/mprotect reports from other binaries.

These semantics are chosen to encourage progress in the ports ecosystem,
without overwhelming the developers who work in the area.
ok sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.179 2016/05/30 21:22:45 deraadt Exp $	*/
a259 1
	char *pathbuf = NULL;
d272 1
a272 6
	if (pathbuf != NULL) {
		NDINIT(&nid, LOOKUP, NOFOLLOW, UIO_SYSSPACE, pathbuf, p);
	} else {
		NDINIT(&nid, LOOKUP, NOFOLLOW, UIO_USERSPACE,
		    SCARG(uap, path), p);
	}
d278 1
a278 4
	if (pathbuf != NULL)
		pack.ep_name = pathbuf;
	else
		pack.ep_name = (char *)SCARG(uap, path);
a716 3
	if (pathbuf != NULL)
		pool_put(&namei_pool, pathbuf);

a742 3
	if (pathbuf != NULL)
		pool_put(&namei_pool, pathbuf);

a762 2
	if (pathbuf != NULL)
		pool_put(&namei_pool, pathbuf);
@


1.180
log
@backout to insert correct commit message
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.178 2016/05/23 20:11:47 deraadt Exp $	*/
d709 3
@


1.179
log
@*** empty log message ***
@
text
@a709 3
	if (pack.ep_flags & EXEC_WXNEEDED)
		p->p_p->ps_flags |= PS_WXNEEDED;

@


1.178
log
@Place a cpu-dependent trap/illegal instruction over the remainder of the
sigtramp page, so that it will generate a nice kernel fault if touched.
While here, move most of the sigtramps to the .rodata segment, because
they are not executed in the kernel.
Also some preparation for sliding the actual sigtramp forward (will need
some gdb changes)
ok mlarkin kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.177 2016/05/10 18:39:51 deraadt Exp $	*/
d709 3
@


1.177
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.176 2016/04/25 20:00:33 tedu Exp $	*/
d846 3
d861 4
a864 1
		memcpy((void *)va, e->e_sigcode, sz);
@


1.176
log
@boom goes the dynamite
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.175 2016/03/19 12:04:15 natano Exp $	*/
d501 1
d871 4
@


1.175
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.174 2016/03/06 20:25:27 guenther Exp $	*/
a68 6
#include "systrace.h"

#if NSYSTRACE > 0
#include <dev/systrace.h>
#endif

a259 4
#if NSYSTRACE > 0
	int wassugid = ISSET(pr->ps_flags, PS_SUGID | PS_SUGIDEXEC);
	size_t pathbuflen;
#endif
a272 10
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE)) {
		systrace_execve0(p);
		pathbuf = pool_get(&namei_pool, PR_WAITOK);
		error = copyinstr(SCARG(uap, path), pathbuf, MAXPATHLEN,
		    &pathbuflen);
		if (error != 0)
			goto clrflag;
	}
#endif
a721 6
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE) &&
	    wassugid && !ISSET(pr->ps_flags, PS_SUGID | PS_SUGIDEXEC))
		systrace_execve1(pathbuf, p);
#endif

d746 1
a746 1
 freehdr:
a747 3
#if NSYSTRACE > 0
 clrflag:
#endif
@


1.174
log
@No more compat emulations, so remove ktrace EMUL records and the baggage
for generating and parsing them.

ok mpi@@ naddy@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.173 2015/12/05 10:11:53 tedu Exp $	*/
d167 1
a167 1
	VOP_UNLOCK(vp, 0, p);
@


1.173
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.172 2015/11/02 16:31:55 semarie Exp $	*/
a735 9
#if defined(KTRACE) && defined(COMPAT_LINUX)
	/* update ps_emul, but don't ktrace it if native-execing-native */
	if (pr->ps_emul != pack.ep_emul || pack.ep_emul != &emul_native) {
		pr->ps_emul = pack.ep_emul;

		if (KTRPOINT(p, KTR_EMUL))
			ktremul(p);
	}
#else
a737 1
#endif
@


1.172
log
@move the pledgenote annotation from `struct proc' to `struct nameidata'

pledgenote is used for annotate the policy for a namei context. So make it
tracking the nameidata.

It is expected for the caller to explicitly define the policy. It is a kernel
bug to not do so.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.171 2015/10/28 11:13:41 deraadt Exp $	*/
a236 1
/* ARGSUSED */
@


1.171
log
@move p_pledgenote setting next to NDINIT()
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.170 2015/10/25 20:39:54 deraadt Exp $	*/
a293 1
	p->p_pledgenote = PLEDGE_EXEC;
d300 1
@


1.170
log
@Fold "malloc" into "stdio" and -- recognizing that no program so far has
used less than "stdio" -- include all the "self" operations.  Instead of
different defines, use regular PLEDGE_* in the "p_pledgenote" variable
(which indicates the operation subtype a system call is performing).  Many
checks before easier to understand.  p_pledgenote can often be passed
directly to ktrace, so that kdump says:
 15565 test     CALL  pledge(0xa9a3f804c51,0)
 15565 test     STRU  pledge request="stdio"
 15565 test     RET   pledge 0
 15565 test     CALL  open(0xa9a3f804c57,0x2<O_RDWR>)
 15565 test     NAMI  "/tmp/testfile"
 15565 test     PLDG  open, "wpath", errno 1 Operation not permitted
with help from semarie, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.169 2015/10/10 14:46:15 deraadt Exp $	*/
a282 1
	p->p_pledgenote = PLEDGE_EXEC;
d294 1
@


1.169
log
@I forgot execve would go through the namei codepath, so a program marked
"stdio rpath" this would fail to execve.  pre-indicate exec actions to the
namei checker to allow them through.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.168 2015/10/09 01:10:27 deraadt Exp $	*/
d283 1
a283 1
	p->p_pledgenote = TMN_XPATH;
@


1.168
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.167 2015/10/07 03:47:43 deraadt Exp $	*/
d283 1
@


1.167
log
@Add the tame "exec" request.  This allows processes which request
"exec" to call execve(2), potentially fork(2) beforehands if they
asked for "proc".  Calling execve is what "shells" (ksh, tmux, etc)
have as their primary purpose.  But meantime, if such a shell has a
nasty bug, we want to mitigate the process from opening a socket or
calling 100+ other system calls.  Unfortunately silver bullets are in
short supply, so if our goal is to stay in a POSIX-y environment, we
have to let shells call execve().  POSIX ate the world, so choices do
we all have?
Warning for many: silver bullets are even more rare in other OS
ecosystems, so please accept this as a narrow lowering of the bar in a
very raised environment.
Commited from a machine running tame "proc exec" ksh, make, etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.166 2015/10/02 15:49:22 deraadt Exp $	*/
d56 1
a56 1
#include <sys/tame.h>
d554 2
a555 2
	atomic_clearbits_int(&pr->ps_flags, PS_TAMED);
	tame_dropwpaths(pr);
@


1.166
log
@missing ) in COMPAT_LINUX block
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.165 2015/10/02 05:07:41 guenther Exp $	*/
d56 1
d553 3
@


1.165
log
@Add ktracing of argv and envp to execve(2), with envp not traced by default

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.164 2015/09/28 20:32:59 deraadt Exp $	*/
d737 1
a737 1
		if (KTRPOINT(p, KTR_EMUL)
@


1.164
log
@Track size of an opaque allocation to pass to free() later
ok guenther tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.163 2015/07/22 05:31:33 deraadt Exp $	*/
d252 3
d383 5
d391 3
d409 5
d732 9
a742 4

#ifdef KTRACE
	if (KTRPOINT(p, KTR_EMUL))
		ktremul(p);
@


1.163
log
@memory leak in execve with systrace, plus some unreachable code
spotted by Maxime Villard
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.162 2015/07/20 00:56:10 guenther Exp $	*/
d689 1
a689 1
	free(pack.ep_hdr, M_EXEC, 0);
d751 1
a751 1
		free(pack.ep_emul_arg, M_TEMP, 0);
d758 1
a758 1
	free(pack.ep_hdr, M_EXEC, 0);
d781 1
a781 1
		free(pack.ep_emul_arg, M_TEMP, 0);
d787 1
a787 1
	free(pack.ep_hdr, M_EXEC, 0);
@


1.162
log
@Add kbind, a syscall for ld.so to use to securely and efficiently update
memory for lazy binding

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.161 2015/03/14 03:38:50 jsg Exp $	*/
d788 2
a793 2
	if (pathbuf != NULL)
		pool_put(&namei_pool, pathbuf);
@


1.161
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.160 2015/02/09 11:52:47 miod Exp $	*/
d502 2
@


1.160
log
@Change the way stackgap_random is applied. Instead of applying it within the
fixed stack area of the exec'd image, and risking hitting process limits,
should we want to increase stackgap_random, the randomness is applied to the
stack region in the process' vmspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.159 2015/02/09 09:39:09 miod Exp $	*/
a62 2

#include <machine/reg.h>
@


1.160.2.1
log
@Backport rev 1.163 by deraadt:
memory leak in execve with systrace, plus some unreachable code
spotted by Maxime Villard
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.160 2015/02/09 11:52:47 miod Exp $	*/
a787 2
	if (pathbuf != NULL)
		pool_put(&namei_pool, pathbuf);
d792 2
@


1.159
log
@Stop using USRSTACK as the edge of the stack, but rather use the vmspace
vm_minsaddr or vm_maxsaddr, depending upon the direction the stack goes in.

This should have no effect on the existing behaviourrr.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.158 2015/02/07 08:47:49 tedu Exp $	*/
d88 1
a88 1
 * added to the fixed stack gap. Must be n^2.
d405 6
d412 1
a412 1
		sgap += arc4random() & (stackgap_random - 1);
@


1.158
log
@forbid execve() with argc == 0. prompted by a millert email.
ok deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.157 2015/01/26 22:51:37 kettenis Exp $	*/
d464 1
a464 1
	pr->ps_strings = (vaddr_t)USRSTACK + sgap;
d469 1
a469 1
	pr->ps_strings = (vaddr_t)USRSTACK - sizeof(arginfo) - sgap;
d481 1
a481 1
	stack = (char *)USRSTACK + sizeof(arginfo) + sgap;
d484 1
a484 1
	stack = (char *)(USRSTACK - len);
@


1.157
log
@Move the "stackgap" from the stack into its own page at a random address.
This allows us the unmap the initial part of the stack, such that it can't
be used as a staging area for ROP (or other) attacks.

ok guenther@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.156 2015/01/20 19:43:21 kettenis Exp $	*/
d374 6
@


1.156
log
@Move ps_strings "after" the random stackgap.  This makes its location a
per-process value, and therefpore turns the VM_PSSTRINGS sysctl into a
per-process one as well.  This gets rid of a pointer to the bottom of the
stack at a fixed location.  Also clears the road for unmapping the stackgap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.155 2015/01/15 16:31:19 kettenis Exp $	*/
d454 16
a484 5
#ifdef MACHINE_STACK_GROWS_UP
	pr->ps_strings = (vaddr_t)PS_STRINGS + sgap;
#else
	pr->ps_strings = (vaddr_t)PS_STRINGS - sgap;
#endif
@


1.155
log
@Map the sigcode page with MAP_INHERIT_COPY to make sure it isn't shared ater
a fork.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.154 2015/01/15 10:04:26 kettenis Exp $	*/
d469 6
a474 1
	if (copyout(&arginfo, (char *)PS_STRINGS, sizeof(arginfo)))
@


1.154
log
@Map the sigcode page copy-on-write.  This allows userland to put breakpoints
in the signal trampoline.  Solves some long-standing issues with debugging
signal handlers in GDB.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.153 2014/12/17 06:58:11 guenther Exp $	*/
d851 1
a851 1
	    PROT_READ | PROT_WRITE | PROT_EXEC, MAP_INHERIT_SHARE,
@


1.153
log
@Prefer MADV_* over POSIX_MADV_* in kernel for consistency: the latter
doesn't have all the values and therefore can't be used everywhere.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.152 2014/12/16 18:30:04 tedu Exp $	*/
d851 2
a852 1
	    PROT_READ | PROT_EXEC, MAP_INHERIT_SHARE, MADV_RANDOM, 0))) {
@


1.152
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.151 2014/12/15 02:24:23 guenther Exp $	*/
d839 1
a839 1
		    MAP_INHERIT_SHARE, POSIX_MADV_RANDOM, 0)))) {
d851 1
a851 1
	    PROT_READ | PROT_EXEC, MAP_INHERIT_SHARE, POSIX_MADV_RANDOM, 0))) {
@


1.151
log
@Use MAP_INHERIT_* for the 'inh' argument to the UMV_MAPFLAG() macro,
eliminating the must-be-kept-in-sync UVM_INH_* macros

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.150 2014/12/10 02:44:46 tedu Exp $	*/
d61 2
@


1.150
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.149 2014/11/18 02:37:31 tedu Exp $	*/
d837 1
a837 1
		    UVM_INH_SHARE, POSIX_MADV_RANDOM, 0)))) {
d849 1
a849 1
	    PROT_READ | PROT_EXEC, UVM_INH_SHARE, POSIX_MADV_RANDOM, 0))) {
@


1.149
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.148 2014/11/16 12:31:00 deraadt Exp $	*/
d478 1
a478 1
	bcopy(nid.ni_cnd.cn_nameptr, p->p_comm, len);
@


1.148
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.147 2014/10/18 15:20:32 kettenis Exp $	*/
a66 2

#include <dev/rndvar.h>
@


1.147
log
@Don't assume that ep_taddr and ep_daddr are page-aligned.  It is possible to
construct ELF executables for which ep_daddr ends up not being properly
aligned.  Sanitize the addresses before setting up the address space for the
new executable.  Should fix the panic discovered by Alejandro Hernandez.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.146 2014/09/28 18:52:04 kettenis Exp $	*/
d838 2
a839 2
		    0, 0, UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW,
		    UVM_INH_SHARE, UVM_ADV_RANDOM, 0)))) {
d850 2
a851 2
	    e->e_sigobject, 0, 0, UVM_MAPFLAG(UVM_PROT_RX, UVM_PROT_RX,
	    UVM_INH_SHARE, UVM_ADV_RANDOM, 0))) {
@


1.146
log
@Replace uvm_km_alloc(9) and uvm_km_free(9) with the equivalent km_alooc(9)
and km_free(9) calls.

ok tedu@@, mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.145 2014/09/08 01:47:06 guenther Exp $	*/
d432 6
a437 4
	vm->vm_taddr = (char *)pack.ep_taddr;
	vm->vm_tsize = atop(round_page(pack.ep_tsize));
	vm->vm_daddr = (char *)pack.ep_daddr;
	vm->vm_dsize = atop(round_page(pack.ep_dsize));
@


1.145
log
@Delete procfs; it's always had races and is now unused: no one noticed for
months that I broke it before the 5.5 release.

confirmed as not being required by ports by sthen@@, ajacoutot@@, dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.144 2014/07/12 18:43:32 tedu Exp $	*/
d76 5
d325 1
a325 1
	argp = (char *) uvm_km_valloc_wait(exec_map, NCARGS);
d625 1
a625 1
	uvm_km_free_wakeup(exec_map, (vaddr_t) argp, NCARGS);
d725 1
a725 1
	uvm_km_free_wakeup(exec_map, (vaddr_t) argp, NCARGS);
d754 1
a754 1
	uvm_km_free_wakeup(exec_map, (vaddr_t) argp, NCARGS);
@


1.144
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.143 2014/07/08 17:19:25 deraadt Exp $	*/
d476 1
a476 1
	/* record proc's vnode, for use by procfs and others */
a539 11
#ifdef PROCFS
			/*
			 * Close descriptors that are writing to procfs.
			 */
			if (fp && fp->f_type == DTYPE_VNODE &&
			    ((struct vnode *)(fp->f_data))->v_tag == VT_PROCFS &&
			    (fp->f_flag & FWRITE)) {
				fdrelease(p, i);
				fp = NULL;
			}
#endif
@


1.144.4.1
log
@Backport r1.147 by kettenis:
Don't assume that ep_taddr and ep_daddr are page-aligned.  It is possible to
construct ELF executables for which ep_daddr ends up not being properly
aligned.  Sanitize the addresses before setting up the address space for the
new executable.  Should fix the panic discovered by Alejandro Hernandez.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.144 2014/07/12 18:43:32 tedu Exp $	*/
d427 4
a430 6
	vm->vm_taddr = (char *)trunc_page(pack.ep_taddr);
	vm->vm_tsize = atop(round_page(pack.ep_taddr + pack.ep_tsize) -
	    trunc_page(pack.ep_taddr));
	vm->vm_daddr = (char *)trunc_page(pack.ep_daddr);
	vm->vm_dsize = atop(round_page(pack.ep_daddr + pack.ep_dsize) -
	    trunc_page(pack.ep_daddr));
@


1.144.4.2
log
@Backport rev 1.163 by deraadt:
memory leak in execve with systrace, plus some unreachable code
spotted by Maxime Villard
ok guenther millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.144.4.1 2014/10/19 22:18:02 tedu Exp $	*/
a765 2
	if (pathbuf != NULL)
		pool_put(&namei_pool, pathbuf);
d770 2
@


1.143
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.142 2014/05/15 03:52:25 guenther Exp $	*/
d339 1
a339 1
			free(*tmpfap, M_EXEC);
d342 1
a342 1
		free(pack.ep_fa, M_EXEC);
d665 1
a665 1
	free(pack.ep_hdr, M_EXEC);
d727 1
a727 1
		free(pack.ep_emul_arg, M_TEMP);
d734 1
a734 1
	free(pack.ep_hdr, M_EXEC);
d757 1
a757 1
		free(pack.ep_emul_arg, M_TEMP);
d763 1
a763 1
	free(pack.ep_hdr, M_EXEC);
@


1.142
log
@Move from struct proc to process the reference-count-holding pointers
to the process's vmspace and filedescs.  struct proc continues to
keep copies of the pointers, copying them on fork, clearing them
on exit, and (for vmspace) refreshing on exec.
Also, make uvm_swapout_threads() thread aware, eliminating p_swtime
in kernel.

particular testing by ajacoutot@@ and sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.141 2014/04/18 11:51:17 guenther Exp $	*/
a60 2

#include <uvm/uvm_extern.h>
@


1.141
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.140 2014/03/30 21:54:48 guenther Exp $	*/
d81 1
a81 1
int exec_sigcode_map(struct proc *, struct emul *);
d259 1
a259 1
	struct vmspace *vm = p->p_vmspace;
a417 1
	 * XXX wait until threads are reaped to make uvmspace_exec() cheaper?
d423 1
a423 1
	 * p_vmspace!
d427 1
a427 1
	vm = p->p_vmspace;
d655 1
a655 1
	if (exec_sigcode_map(p, pack.ep_emul))
d819 1
a819 1
exec_sigcode_map(struct proc *p, struct emul *e)
d853 1
a853 1
	p->p_p->ps_sigcode = 0; /* no hint */
d855 1
a855 1
	if (uvm_map(&p->p_vmspace->vm_map, &p->p_p->ps_sigcode, round_page(sz),
@


1.140
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.139 2014/03/26 05:23:42 guenther Exp $	*/
d598 4
a601 1
	/* reset the saved ugids */
d608 9
@


1.139
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.138 2014/03/19 00:01:56 deraadt Exp $	*/
d497 4
a500 4
	if (p->p_ucred->cr_uid != p->p_cred->p_ruid ||
	    p->p_ucred->cr_uid != p->p_cred->p_svuid ||
	    p->p_ucred->cr_gid != p->p_cred->p_rgid ||
	    p->p_ucred->cr_gid != p->p_cred->p_svgid)
d522 1
a522 1
		p->p_ucred = crcopy(cred);
d524 1
a524 1
			p->p_ucred->cr_uid = attr.va_uid;
d526 1
a526 1
			p->p_ucred->cr_gid = attr.va_gid;
d577 1
a577 1
				if ((error = VOP_OPEN(vp, flags, p->p_ucred, p)) != 0) {
d597 9
a605 2
	p->p_cred->p_svuid = p->p_ucred->cr_uid;
	p->p_cred->p_svgid = p->p_ucred->cr_gid;
@


1.138
log
@Properly align the stack using _STACKALIGNBYTES, rather that the ALIGN()
macro which is unaware that stacks may need larger alignment.  This may
mean that some workarounds in crt0 can go away (here's looking at you
mips64..)
Tested on about half the architectures (the most special cases), so let's
see what happens.
with tobiasu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.137 2014/01/21 01:48:44 tedu Exp $	*/
d661 3
a663 3
	if (p->p_emul && p->p_emul->e_proc_exit &&
	    p->p_emul != pack.ep_emul)
		(*p->p_emul->e_proc_exit)(p);
d676 2
a677 2
	/* update p_emul, the old value is no longer needed */
	p->p_emul = pack.ep_emul;
d681 1
a681 1
		ktremul(p, p->p_emul->e_name);
d835 1
a835 1
	p->p_sigcode = 0; /* no hint */
d837 1
a837 1
	if (uvm_map(&p->p_vmspace->vm_map, &p->p_sigcode, round_page(sz),
@


1.137
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.136 2014/01/20 03:23:42 guenther Exp $	*/
d84 2
a85 3
 * stackgap_random specifies if the stackgap should have a random size added
 * to it. Must be a n^2. If non-zero, the stack gap will be calculated as:
 * (arc4random() * ALIGNBYTES) & (stackgap_random - 1) + STACKGAPLEN.
d393 1
a393 1
	dp = (char *)ALIGN(dp);
d396 5
a400 5
	if (stackgap_random != 0)
		sgap += (arc4random() * ALIGNBYTES) & (stackgap_random - 1);
#ifdef MACHINE_STACK_GROWS_UP
	sgap = ALIGN(sgap);
#endif
d405 1
a405 1
	len = ALIGN(len);	/* make the stack "safely" aligned */
@


1.137.4.1
log
@Backport r1.147 by kettenis:
Don't assume that ep_taddr and ep_daddr are page-aligned.  It is possible to
construct ELF executables for which ep_daddr ends up not being properly
aligned.  Sanitize the addresses before setting up the address space for the
new executable.  Should fix the panic discovered by Alejandro Hernandez.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.137 2014/01/21 01:48:44 tedu Exp $	*/
d431 4
a434 6
	vm->vm_taddr = (char *)trunc_page(pack.ep_taddr);
	vm->vm_tsize = atop(round_page(pack.ep_taddr + pack.ep_tsize) -
	    trunc_page(pack.ep_taddr));
	vm->vm_daddr = (char *)trunc_page(pack.ep_daddr);
	vm->vm_dsize = atop(round_page(pack.ep_daddr + pack.ep_dsize) -
	    trunc_page(pack.ep_daddr));
@


1.136
log
@Move p_textvp from struct proc to struct process so that the exit code
can be further simplified.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.135 2013/06/17 19:11:54 guenther Exp $	*/
d475 1
a475 1
	bzero(p->p_comm, sizeof(p->p_comm));
@


1.135
log
@Add support for the _POSIX_CPUTIME and _POSIX_THREAD_CPUTIME options,
including CLOCK_{PROCESS,THREAD}_CPUTIME_ID constants and
{clock,pthread}_getcpuclockid() functions.

Worked out at t2k13 with help from tedu@@ and matthew@@ and testing by aja@@
ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.134 2013/03/30 06:32:25 tedu Exp $	*/
d481 1
a481 1
	otvp = p->p_textvp;
d483 1
a483 1
	p->p_textvp = pack.ep_vp;
@


1.135.2.1
log
@Backport r1.147 by kettenis:
Don't assume that ep_taddr and ep_daddr are page-aligned.  It is possible to
construct ELF executables for which ep_daddr ends up not being properly
aligned.  Sanitize the addresses before setting up the address space for the
new executable.  Should fix the panic discovered by Alejandro Hernandez.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.135 2013/06/17 19:11:54 guenther Exp $	*/
d431 4
a434 6
	vm->vm_taddr = (char *)trunc_page(pack.ep_taddr);
	vm->vm_tsize = atop(round_page(pack.ep_taddr + pack.ep_tsize) -
	    trunc_page(pack.ep_taddr));
	vm->vm_daddr = (char *)trunc_page(pack.ep_daddr);
	vm->vm_dsize = atop(round_page(pack.ep_daddr + pack.ep_dsize) -
	    trunc_page(pack.ep_daddr));
@


1.134
log
@vrele() is a tricky beast. it can sleep if the refcount hits zero,
leaving us with a free type function that isn't atomic. deal with this
by erasing any reachable pointers to the vnode first, then free it.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.133 2013/03/28 16:55:25 deraadt Exp $	*/
d611 4
@


1.133
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.132 2012/08/02 03:18:48 guenther Exp $	*/
d268 1
d481 1
a481 2
	if (p->p_textvp)
		vrele(p->p_textvp);
d484 2
@


1.132
log
@Apply profiling to all threads instead of just the thread that called
profil() by moving P_PROFIL from proc->p_flag to process->ps_flags with
matching adjustment in fork1() and exit1()

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.131 2012/05/01 03:21:50 guenther Exp $	*/
a63 1
#include <machine/cpu.h>
@


1.131
log
@Correct the error path in execve when there's a race to single thread
the process.

noted and ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.130 2012/04/22 05:43:14 guenther Exp $	*/
d469 1
a469 1
	stopprofclock(p);	/* stop profiling */
@


1.130
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.129 2012/04/13 16:37:50 kettenis Exp $	*/
d272 1
a272 1
		goto bad;
@


1.129
log
@First stab at making ptrace(2) usable for debugging multi-threaded programs.
It implements a full-stop model where all threads are stopped before handing
over control to the debugger.  Events are reported as before through wait(2);
you will have to call ptrace(PT_GET_PROCESS_STATE, ...) to find out which
thread hit the event.  Since this changes the size of struct ptrace_state,
you will have to recompile gdb.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.128 2012/04/12 10:11:41 mikeb Exp $	*/
d589 1
a589 1
				FILE_SET_MATURE(fp);
@


1.128
log
@move accounting flags to struct process; idea and ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.127 2012/03/26 04:19:55 deraadt Exp $	*/
d681 1
a681 1
	single_thread_clear(p);
d719 1
a719 1
	single_thread_clear(p);
@


1.127
log
@clear junk in p_comm before copying shorter names into it
ok jsing guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.126 2012/03/23 15:51:26 guenther Exp $	*/
d478 1
a478 1
	p->p_acflag &= ~AFORK;
@


1.126
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.125 2012/03/09 13:01:28 ariane Exp $	*/
d475 1
a477 1
	p->p_comm[len] = 0;
@


1.125
log
@New vmmap implementation.

no oks (it is really a pain to review properly)
extensively tested, I'm confident it'll be stable
'now is the time' from several icb inhabitants

Diff provides:
- ability to specify different allocators for different regions/maps
- a simpler implementation of the current allocator
- currently in compatibility mode: it will generate similar addresses
  as the old allocator
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.124 2012/02/20 22:23:39 guenther Exp $	*/
d603 4
a606 7
		timeout_del(&p->p_realit_to);
		timerclear(&p->p_realtimer.it_interval);
		timerclear(&p->p_realtimer.it_value);
		for (i = 0; i < sizeof(p->p_stats->p_timer) /
		    sizeof(p->p_stats->p_timer[0]); i++) {
			timerclear(&p->p_stats->p_timer[i].it_interval);
			timerclear(&p->p_stats->p_timer[i].it_value);
@


1.124
log
@First steps for making ptrace work with rthreads:
 - move the P_TRACED and P_INEXEC flags, and p_oppid, p_ptmask, and
   p_ptstat member from struct proc to struct process
 - sort the PT_* requests into those that take a PID vs those that
   can also take a TID
 - stub in PT_GET_THREAD_FIRST and PT_GET_THREAD_NEXT

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.123 2012/02/15 04:26:27 guenther Exp $	*/
a823 1
		va = vm_map_min(kernel_map);	/* hint */
d834 1
a834 2
	/* Just a hint to uvm_mmap where to put it. */
	p->p_sigcode = uvm_map_hint(p, VM_PROT_READ|VM_PROT_EXECUTE);
@


1.123
log
@Hold struct filedesc's fd_lock when writing to the fd_ofiles, fd_ofileflags,
or fd_{lo,hi}maps members, or when doing a read for a write.  Fixes hangs
when an rthreaded processes sleeps while copying the fd table for fork()
and catches another thread with the lock.

ok jsing@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.122 2011/12/14 07:32:16 guenther Exp $	*/
d278 1
a278 1
	atomic_setbits_int(&p->p_flag, P_INEXEC);
d645 1
a645 1
	if (p->p_flag & P_TRACED)
d683 1
a683 1
	atomic_clearbits_int(&p->p_flag, P_INEXEC);
d721 1
a721 1
	atomic_clearbits_int(&p->p_flag, P_INEXEC);
d750 1
a750 1
	atomic_clearbits_int(&p->p_flag, P_INEXEC);
@


1.122
log
@Handle rthreads consistently in ktrace by moving the flags and vnode into
struct process; KTRFAC_ACTIVE becomes P_INKTR.  Also, save the credentials
used to open the file in sys_ktrace() and use them for all writes to the
vnode.

much feedback and ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.121 2011/12/11 19:42:28 guenther Exp $	*/
d532 2
d567 1
a567 1
					goto exec_abort;
d575 1
a575 1
					goto exec_abort;
d581 1
a581 1
					goto exec_abort;
d592 3
d703 1
d705 1
@


1.121
log
@Suspend other rthreads before dumping core or execing; make them exit
when exec succeeds.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.120 2011/10/16 05:29:51 guenther Exp $	*/
d519 2
a520 4
		if (p->p_tracep && !(p->p_traceflag & KTRFAC_ROOT)) {
			p->p_traceflag = 0;
			ktrsettracevnode(p, NULL);
		}
@


1.120
log
@TCB address should be reset when execing, to provide a clean setup for
the new image
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.119 2011/06/06 17:10:23 ariane Exp $	*/
d270 4
d417 7
d681 1
d717 1
@


1.119
log
@Backout vmmap in order to repair virtual address selection algorithms
outside the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.118 2011/05/24 15:27:36 ariane Exp $	*/
d67 4
d461 1
@


1.118
log
@Reimplement uvm/uvm_map.

vmmap is designed to perform address space randomized allocations,
without letting fragmentation of the address space go through the roof.

Some highlights:
- kernel address space randomization
- proper implementation of guardpages
- roughly 10% system time reduction during kernel build

Tested by alot of people on tech@@ and developers.
Theo's machines are still happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.117 2011/04/04 13:00:13 guenther Exp $	*/
d813 1
@


1.117
log
@Move P_EXEC flag from struct proc to process, so that setpgid() will
fail regardless of which rthread calls execve()

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.116 2011/04/03 14:56:28 guenther Exp $	*/
a812 1
	p->p_sigcode = uvm_map_hint(p, VM_PROT_READ|VM_PROT_EXECUTE);
@


1.116
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.115 2011/04/02 17:04:35 guenther Exp $	*/
d470 1
a470 1
	atomic_setbits_int(&p->p_flag, P_EXEC);
@


1.115
log
@Move P_SUGID and P_SUGIDEXEC from struct proc to struct process, so
that you can't evade the checks by doing the dirty work in an rthread

ok blambert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.114 2010/11/24 21:05:20 miod Exp $	*/
d471 3
a473 2
	if (pr->ps_mainproc->p_flag & P_PPWAIT) {
		atomic_clearbits_int(&pr->ps_mainproc->p_flag, P_PPWAIT);
@


1.114
log
@Allow MD code to setup MD-specific mappings (kinda similar to the signal
trampoline) in sys_execve(), if MD <machine/_types.h> defines
__HAVE_EXEC_MD_MAP.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.113 2010/07/26 01:56:27 guenther Exp $	*/
d249 1
d261 1
a261 2
	int wassugid =
	    ISSET(p->p_flag, P_SUGID) || ISSET(p->p_flag, P_SUGIDEXEC);
d471 3
a473 3
	if (p->p_p->ps_mainproc->p_flag & P_PPWAIT) {
		atomic_clearbits_int(&p->p_p->ps_mainproc->p_flag, P_PPWAIT);
		wakeup(p->p_p->ps_pptr);
d478 1
a478 1
	 * effective, or saved uid/gid, we set P_SUGIDEXEC.
d484 1
a484 1
		atomic_setbits_int(&p->p_flag, P_SUGIDEXEC);
d486 1
a486 1
		atomic_clearbits_int(&p->p_flag, P_SUGIDEXEC);
d495 1
a495 1
		atomic_setbits_int(&p->p_flag, P_SUGID|P_SUGIDEXEC);
d576 1
a576 1
		atomic_clearbits_int(&p->p_flag, P_SUGID);
d580 1
a580 1
	if (p->p_flag & P_SUGIDEXEC) {
d602 1
a602 1
	KNOTE(&p->p_p->ps_klist, NOTE_EXEC);
d667 1
a667 2
	    wassugid && !ISSET(p->p_flag, P_SUGID) &&
	    !ISSET(p->p_flag, P_SUGIDEXEC))
@


1.113
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.112 2010/05/18 22:26:10 tedu Exp $	*/
d618 6
@


1.112
log
@move knote list to struct process.  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.111 2010/01/14 23:12:11 schwarze Exp $	*/
d471 3
a473 3
	if (p->p_flag & P_PPWAIT) {
		atomic_clearbits_int(&p->p_flag, P_PPWAIT);
		wakeup((caddr_t)p->p_pptr);
@


1.111
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.110 2009/07/09 22:29:56 thib Exp $	*/
d602 1
a602 1
	KNOTE(&p->p_klist, NOTE_EXEC);
@


1.110
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.108 2008/10/31 17:17:00 deraadt Exp $	*/
d107 1
a107 1
 *			everything deallocated execept exec header.
@


1.109
log
@properly terminate fake argument list.

From NetBSD;

OK deraadt@@
@
text
@d467 1
a467 1
	VREF(pack.ep_vp);
@


1.108
log
@accidental commit ... backout
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.106 2008/02/13 19:31:22 kettenis Exp $	*/
d332 1
a332 1
			dp++;
@


1.107
log
@kern_sysctl.c
@
text
@a502 2
			struct vnode *vp = p->p_tracep;

d504 1
a504 2
			if (ktrsettracevnode(p, NULL) == 1)
				vrele(vp);
@


1.106
log
@Make sure we reserve enough stack space on MACHINE_STACK_GROWS_UP architectures
by aligning the stack gap.  Fixes gettext port build (and probably many others).

ok miod@@, tedu@@, tested by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.105 2007/12/11 22:09:29 kettenis Exp $	*/
d503 2
d506 2
a507 1
			ktrsettracevnode(p, NULL);
@


1.105
log
@Don't store arguments and environment in the space reserved for stackgap on
machines where the stack grows up.  Fixes systrace(1) on hppa.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.104 2007/10/29 14:12:19 chl Exp $	*/
d391 3
d441 2
a442 2
	stack = (char *)USRSTACK + sizeof(arginfo) + ALIGN(sgap);
	slen = len - sizeof(arginfo) - ALIGN(sgap);
@


1.104
log
@MALLOC/FREE -> malloc/free
replace an hard coded value with M_WAITOK

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.103 2007/09/15 10:10:37 martin Exp $	*/
d438 2
a439 2
	stack = (char *)USRSTACK + sizeof(arginfo);
	slen = len - sizeof(arginfo);
@


1.103
log
@replace ctob and btoc with ptoa and atop respectively

help and ok miod@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.102 2007/03/15 10:22:30 art Exp $	*/
d337 1
a337 1
		FREE(pack.ep_fa, M_EXEC);
d679 1
a679 1
		FREE(pack.ep_emul_arg, M_TEMP);
d708 1
a708 1
		FREE(pack.ep_emul_arg, M_TEMP);
@


1.102
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.101 2007/03/01 11:18:40 art Exp $	*/
d414 1
a414 1
	vm->vm_tsize = btoc(pack.ep_tsize);
d416 1
a416 1
	vm->vm_dsize = btoc(pack.ep_dsize);
d418 1
a418 1
	vm->vm_ssize = btoc(pack.ep_ssize);
@


1.101
log
@Remove two ancient debugging printfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.100 2006/11/15 17:25:40 jmc Exp $	*/
d270 1
a270 1
	p->p_flag |= P_INEXEC;
d467 1
a467 1
	p->p_flag |= P_EXEC;
d469 1
a469 1
		p->p_flag &= ~P_PPWAIT;
d481 1
a481 1
		p->p_flag |= P_SUGIDEXEC;
d483 1
a483 1
		p->p_flag &= ~P_SUGIDEXEC;
d492 1
a492 2
		p->p_flag |= P_SUGID;
		p->p_flag |= P_SUGIDEXEC;
d573 1
a573 1
		p->p_flag &= ~P_SUGID;
d654 1
a654 1
	p->p_flag &= ~P_INEXEC;
d690 1
a690 1
	p->p_flag &= ~P_INEXEC;
d718 1
a718 1
	p->p_flag &= ~P_INEXEC;
@


1.100
log
@typos; from bret lambert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.99 2006/01/19 17:54:47 mickey Exp $	*/
a796 1
			printf("kernel mapping failed %d\n", r);
a809 1
		printf("user mapping failed\n");
@


1.99
log
@redo (w/ proper changes everywhere ;):
take interp[MAXPATHLEN] off the stack.  from mickey, ok otto
while here, switch above from malloc to pool, remove stupid casts
tedu@@ miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.98 2005/12/07 19:04:53 deraadt Exp $	*/
d520 1
a520 1
			 * unmature fds. The file descriptor table is not
@


1.98
log
@do not allow setugid processes to use /dev/fd/#, unless they are a
setuid-script and are attempting to dup is the specific setuid-script
fd via such a pathname; ok tedu pedro millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.97 2005/12/03 18:09:08 tedu Exp $	*/
d678 1
a678 1
		FREE(pack.ep_interp, M_TEMP);
d707 1
a707 1
		FREE(pack.ep_interp, M_TEMP);
@


1.97
log
@kernel support for threaded processes (rthreads).
uses rfork(RFTHREAD) to create threads, which are presently processes
that are a little more tightly bound together.  several new syscalls
added to facilitate a userland thread library.
all conditional on RTHREADS, currently disabled.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.96 2005/11/28 00:14:28 jsg Exp $	*/
d635 4
@


1.96
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.95 2005/08/14 11:02:33 miod Exp $	*/
d712 1
a712 1
	exit1(p, W_EXITCODE(0, SIGABRT));
@


1.95
log
@catched->caught
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.94 2005/08/01 07:02:39 art Exp $	*/
d112 1
a112 3
check_exec(p, epp)
	struct proc *p;
	struct exec_package *epp;
d235 1
a235 4
sys_execve(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
d724 2
a725 5
copyargs(pack, arginfo, stack, argp)
	struct exec_package *pack;
	struct ps_strings *arginfo;
	void *stack;
	void *argp;
@


1.95.2.1
log
@MFC:
Fix by deraadt@@

do not allow setugid processes to use /dev/fd/#, unless they are a
setuid-script and are attempting to dup is the specific setuid-script
fd via such a pathname;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.95 2005/08/14 11:02:33 miod Exp $	*/
a639 4

	p->p_descfd = 255;
	if ((pack.ep_flags & EXEC_HASFD) && pack.ep_fd < 255)
		p->p_descfd = pack.ep_fd;
@


1.94
log
@ - We shouldn't allocate MAXPATHLEN from the stack.
 - Don't copy the pathbuf into kernel space unless we're systracing.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.93 2005/07/07 23:43:04 deraadt Exp $	*/
d458 1
a458 1
	execsigs(p);		/* reset catched signals */
@


1.93
log
@clear vm_dused at exec time, since we are potentially re-using the vmspace;
fixes resource accounting in a mmap malloc world
ok "too busy but looks right" tedu, tdeval
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.92 2005/04/11 20:05:51 deraadt Exp $	*/
a266 1
	char pathbuf[MAXPATHLEN];
d269 1
d278 1
a278 1
	if (ISSET(p->p_flag, P_SYSTRACE))
d280 6
a285 9

	error = copyinstr(SCARG(uap, path), pathbuf, MAXPATHLEN, &pathbuflen);
	if (error != 0)
		goto clrflag;

	NDINIT(&nid, LOOKUP, NOFOLLOW, UIO_SYSSPACE, pathbuf, p);
#else
	/* init the namei data to point the file user's program name */
	NDINIT(&nid, LOOKUP, NOFOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
d287 6
d297 4
a300 5
#if NSYSTRACE > 0
	pack.ep_name = pathbuf;
#else
	pack.ep_name = (char *)SCARG(uap, path);
#endif
d665 3
d693 4
d721 3
@


1.92
log
@pull in new MD STACKGAP_RANDOM
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.91 2005/03/09 17:41:29 miod Exp $	*/
d420 1
@


1.91
log
@Fail exec for disabled compat with EPERM rather than ENOEXEC.

ok deraadt@@ mickey@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.90 2004/08/24 23:01:26 mickey Exp $	*/
d85 1
a85 1
int stackgap_random = 64*1024;
@


1.91.2.1
log
@MFC:
Fix by deraadt@@

do not allow setugid processes to use /dev/fd/#, unless they are a
setuid-script and are attempting to dup is the specific setuid-script
fd via such a pathname;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.91 2005/03/09 17:41:29 miod Exp $	*/
a636 4

	p->p_descfd = 255;
	if ((pack.ep_flags & EXEC_HASFD) && pack.ep_fd < 255)
		p->p_descfd = pack.ep_fd;
@


1.90
log
@back out the last change as it seems to produce problems found by brad@@; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.89 2004/08/01 06:25:54 mickey Exp $	*/
d186 1
a186 1
			newerror = ENOEXEC;
@


1.89
log
@leave space for stackgap on growsuppers
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.88 2004/07/07 07:31:40 marius Exp $	*/
d440 2
a441 2
	stack = (char *)USRSTACK + STACKGAPLEN;
	slen = len - STACKGAPLEN;
@


1.88
log
@fix an issue when scripts are exec'd under systrace where
the argv[0] would be normalized, and hence break scripts
that depend on how they were called.

this fixes an issue in the ports builds.

ok provos@@ deraadt@@; lots of testing during hackathon sturm@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.87 2004/06/23 05:16:35 marius Exp $	*/
d440 2
a441 2
	stack = (char *)USRSTACK + sizeof(arginfo);
	slen = len - sizeof(arginfo);
@


1.87
log
@a few fixes to systrace

- add an exec message so that whenever a set-uid/gid process
  exec's a new image which we may control, the exec does not
  go by unnoticed.

- take special care to check for P_SUGIDEXEC as well as
  P_SUGID, corresponding to the same changes that were made in
  the ptrace code a while ago

ok niels@@, sturm@@; thanks to naddy for testing
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.86 2004/06/11 12:57:36 mickey Exp $	*/
d278 3
d659 1
a659 1
		systrace_execve(pathbuf, p);
@


1.86
log
@vm->vm_minsaddr  was uninitialized (nothing realy uses it anyway)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.85 2004/05/14 04:00:33 tedu Exp $	*/
d69 6
d264 6
d277 7
d286 1
d291 3
d295 1
d649 1
d651 8
d678 1
a678 1
freehdr:
d680 3
@


1.85
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.84 2004/03/12 09:32:55 tedu Exp $	*/
d395 1
@


1.84
log
@don't leak memory on error, from Patrick Latifi
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.83 2004/02/05 22:56:10 millert Exp $	*/
d43 1
d213 1
a213 1
	FREE(ndp->ni_cnd.cn_pnbuf, M_NAMEI);
d221 1
a221 1
	FREE(ndp->ni_cnd.cn_pnbuf, M_NAMEI);
d568 1
a568 1
	FREE(nid.ni_cnd.cn_pnbuf, M_NAMEI);
d641 1
a641 1
	FREE(nid.ni_cnd.cn_pnbuf, M_NAMEI);
d661 1
a661 1
	FREE(nid.ni_cnd.cn_pnbuf, M_NAMEI);
@


1.83
log
@Decrement reference count in error case if uvm_map(9) fails and we
had previously increased the reference count.  Should not happen, but...
From dhartmei@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.82 2003/09/01 18:06:03 henning Exp $	*/
d275 1
d588 1
a588 1
		goto exec_abort;
d634 4
d656 3
a658 1
	if (pack.ep_emul_arg)
@


1.82
log
@match syscallargs comments with reality
from Patrick Latifi <patrick.l@@hermes.usherb.ca>
ok jason@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.81 2003/08/21 18:56:07 tedu Exp $	*/
d741 1
d755 1
@


1.82.2.1
log
@MFC:
Fix by tedu@@

don't leak memory on error, from Patrick Latifi

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.82 2003/09/01 18:06:03 henning Exp $	*/
a274 1
	pack.ep_interp = NULL;
d587 1
a587 1
		goto free_pack_abort;
a632 4
	if (pack.ep_interp != NULL)
		FREE(pack.ep_interp, M_TEMP);
	if (pack.ep_emul_arg != NULL)
		FREE(pack.ep_emul_arg, M_TEMP);
d651 1
a651 3
	if (pack.ep_interp != NULL)
		FREE(pack.ep_interp, M_TEMP);
	if (pack.ep_emul_arg != NULL)
@


1.81
log
@emulation is now controlled by sysctl.  changes:
add e_flags to struct emul.  this stores on/off and native flags.
check for emul enabled in check_exec().  gather all the emuls into a
emulsw so a sysctl can find them.  create sysctl.  move maxhdrsiz calcualation
into init_main so it cleans up sys_execve codepath.  teach sysctl utility
to grok kern.emul hierarchy.
requested and ok deraadt@@  some comments from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.80 2003/06/21 00:42:58 tedu Exp $	*/
d236 3
a238 3
		syscallarg(char *) path;
		syscallarg(char * *) argp;
		syscallarg(char * *) envp;
@


1.80
log
@add exec/fork/exit hooks per process for compat emulations.
use them to correctly emulate linux brk.
update to TNF copyright in linux_exec.c.

from netbsd, mostly from a diff by Kurt Miller in pr3318.
this should fix java.  no regressions in testing by kurt and sturm@@.
be prepared for "proc size mismatch" -- recompile ps and friends.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.79 2003/06/02 01:29:56 deraadt Exp $	*/
d178 2
d240 1
a240 1
	int error, i;
a262 12

	/*
	 * figure out the maximum size of an exec header, if necessary.
	 * XXX should be able to keep LKM code from modifying exec switch
	 * when we're still using it, but...
	 */
	if (exec_maxhdrsz == 0) {
		for (i = 0; i < nexecs; i++)
			if (execsw[i].es_check != NULL
			    && execsw[i].es_hdrsz > exec_maxhdrsz)
				exec_maxhdrsz = execsw[i].es_hdrsz;
	}
@


1.79
log
@stackgap_random becomes 64K
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.78 2003/05/17 14:02:06 grange Exp $	*/
d602 24
a626 1
	free(pack.ep_hdr, M_EXEC);
@


1.78
log
@Typos; from Julien Bordet <zejames@@greyhats.org>
Close PR 3262
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.77 2003/04/14 04:53:50 art Exp $	*/
d78 1
a78 1
int stackgap_random = 1024;
@


1.77
log
@There are two related changes.

The first one is an mquery(2) syscall. It's for asking the VM system
about where to map things. It will be used by ld.so, read the man page
for details.

The second change is related and is a centralization of uvm_map hint
that all callers of uvm_map calculated. This will allow us to adjust
this hint on architectures that have segments for non-exec mappings.

deraadt@@ drahn@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.76 2003/03/09 01:27:50 millert Exp $	*/
d713 1
a713 1
	 * The we map it with PROT_READ|PROT_EXEC into the process just
@


1.76
log
@Make the semantics of the P_SUGIDEXEC flag match the issetugid(2)
man page.  Instead of just clearing P_SUGIDEXEC if real and effective
uids/gids matched, we now set P_SUGIDEXEC if there is a mismatch in
the real, effective, or saved uid/gid and clear it otherwise.
deraadt@@ and tholo@@ OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.75 2002/12/11 00:08:08 miod Exp $	*/
d735 1
a735 1
	p->p_sigcode = round_page((vaddr_t)p->p_vmspace->vm_daddr + MAXDSIZ);
@


1.75
log
@descructive -> destructive
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.74 2002/12/04 04:31:20 art Exp $	*/
d456 2
a457 2
	 * If process does execve() while it has euid/uid or egid/gid
	 * which are mismatched, it remains P_SUGIDEXEC.
d459 6
a464 2
	if (p->p_ucred->cr_uid == p->p_cred->p_ruid &&
	    p->p_ucred->cr_gid == p->p_cred->p_rgid)
@


1.74
log
@No need to exit the process twice. exit1() can't fail.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.73 2002/11/09 04:12:32 mickey Exp $	*/
d101 1
a101 1
 *		non-descructive:
@


1.73
log
@fix a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.72 2002/10/06 22:39:25 art Exp $	*/
a642 1
	exit1(p, -1);
@


1.72
log
@Move out the execution of vmcmds into a separate function.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.71 2002/09/23 01:41:09 art Exp $	*/
d351 1
a351 1
	/* environment need not be there */
@


1.71
log
@Add support for vmcmds that load sections relative to a base section.
You mark one section with VMCMD_BASE and the rest are marked RELATIVE.
Use that to load ELF interpreter correctly in all cases.

Inspired by NetBSD. Great debugging help from drahn@@
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.70 2002/08/22 22:04:42 art Exp $	*/
a254 1
	struct exec_vmcmd *base_vc;
d409 1
a409 21
	base_vc = NULL;
	for (i = 0; i < pack.ep_vmcmds.evs_used && !error; i++) {
		struct exec_vmcmd *vcp;

		vcp = &pack.ep_vmcmds.evs_cmds[i];

		if (vcp->ev_flags & VMCMD_RELATIVE) {
#ifdef DIAGNOSTIC
			if (base_vc == NULL)
				panic("sys_execve: RELATIVE without base");
#endif
			vcp->ev_addr += base_vc->ev_addr;
		}

		error = (*vcp->ev_proc)(p, vcp);
		if (vcp->ev_flags & VMCMD_BASE)
			base_vc = vcp;
	}

	/* free the vmspace-creation commands, and release their references */
	kill_vmcmds(&pack.ep_vmcmds);
@


1.70
log
@Change the vnode locking in exec to not keep the vnode locked almost all
the time.

This could lead to problems when a process wants to do an exec on the same
vnode it's being run from and needs to copy in arguments from an uncached
page in the data segment. When that happens uvm detects a vnode deadlock
and returns an error causing execve() return EFAULT.

This fixes the regress test in regress/sys/kern/exec_self

Also, initialize scriptvp early in exec_script because it could be
used uninitialized in a failure case.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.69 2002/07/25 01:21:51 nordin Exp $	*/
d255 1
d410 1
d415 9
d425 2
@


1.69
log
@Compare with the same type. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.68 2002/07/20 19:24:57 art Exp $	*/
d157 3
d162 1
a162 1
	    UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred, &resid, p);
a176 1

d207 1
a207 2
	 * unlock and close the vnode, free the
	 * pathname buf, and punt.
a208 1
	VOP_UNLOCK(vp, 0, p);
d581 1
a581 2
	VOP_CLOSE(pack.ep_vp, FREAD, cred, p);
	vput(pack.ep_vp);
d625 1
a625 2
	VOP_CLOSE(pack.ep_vp, FREAD, cred, p);
	vput(pack.ep_vp);
d645 1
a645 2
	VOP_CLOSE(pack.ep_vp, FREAD, cred, p);
	vput(pack.ep_vp);
@


1.68
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.67 2002/05/02 00:36:04 millert Exp $	*/
d301 1
a301 1
	if (argp == (vaddr_t) 0)
@


1.67
log
@Cause the exec to fail if we are unable to allocate resources when dup'ing
/dev/null to fd's 0-2 for a setuid program; deraadt@@ and art@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.66 2002/03/14 17:17:23 mickey Exp $	*/
d69 5
a253 1
	int szsigcode;
a371 2
	szsigcode = pack.ep_emul->e_esigcode - pack.ep_emul->e_sigcode;

d377 1
a377 2
	    sizeof(long) + dp + sgap + szsigcode +
	    sizeof(struct ps_strings)) - argp;
d428 2
a429 2
	stack = (char *)USRSTACK + sizeof(arginfo) + szsigcode;
	slen = len - sizeof(arginfo) - szsigcode;
a440 11
	/* copy out the process's signal trampoline code */
#ifdef MACHINE_STACK_GROWS_UP
	if (szsigcode && copyout((char *)pack.ep_emul->e_sigcode,
	    ((char *)PS_STRINGS) + sizeof(arginfo), szsigcode))
		goto exec_abort;
#else
	if (szsigcode && copyout((char *)pack.ep_emul->e_sigcode,
	    ((char *)PS_STRINGS) - szsigcode, szsigcode))
		goto exec_abort;
#endif

d600 4
d704 49
@


1.66
log
@invalid argv causes efault, not einval; form daniel@@lucq.org
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.65 2002/02/17 04:31:26 art Exp $	*/
a536 3
			 *
			 * XXX - Shouldn't the exec fail if we can't allocate
			 *       resources here?
d544 1
a544 1
					break;
d552 1
a552 1
					break;
d558 1
a558 1
					break;
@


1.66.2.1
log
@Pull in patch from current:
Fix (millert):
Cause the exec to fail if we are unable to allocate resources when dup'ing
/dev/null to fd's 0-2 for a setuid program; deraadt@@ and art@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.66 2002/03/14 17:17:23 mickey Exp $	*/
d537 3
d547 1
a547 1
					goto exec_abort;
d555 1
a555 1
					goto exec_abort;
d561 1
a561 1
					goto exec_abort;
@


1.65
log
@Enable stackgap_random. Set it initially to 1k.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.64 2002/02/08 13:53:28 art Exp $	*/
d323 1
a323 1
		error = EINVAL;
@


1.64
log
@- Rename FILE_{,UN}USE to FREF and FRELE. USE is a bad verb and we don't have
  the same semantics as NetBSD anyway, so it's good to avoid name collissions.
- Always fdremove before freeing the file, not the other way around.
- falloc FREFs the file.
- have FILE_SET_MATURE FRELE the file (It feels like a good ortogonality to
  falloc FREFing the file).
- Use closef as much as possible instead of ffree in error paths of
  falloc:ing functions. closef is much more careful with the fd and can
  deal with the fd being forcibly closed by dup2. Also try to avoid
  manually calling *fo_close when closef can do that for us (this makes
  some error paths mroe complicated (sys_socketpair and sys_pipe), but
  others become simpler (sys_open)).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.63 2002/01/20 11:27:52 art Exp $	*/
d73 1
a73 1
int stackgap_random;
@


1.63
log
@When a process is exec:ing mark it with a flag. Check that flag in ptrace
and procfs (and possibly more places in the future) and simply refuse to
fiddle with the execing process. This is an ugly hack, but this far we
haven't been successful in creating a race-free exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.62 2001/12/19 08:58:06 art Exp $	*/
a552 1
					ffree(fp);
d554 1
a557 1
					ffree(fp);
d559 1
@


1.62
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.61 2001/11/27 05:27:11 art Exp $	*/
d253 6
d623 1
d642 1
d666 1
@


1.61
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.60 2001/11/12 01:26:09 art Exp $	*/
a152 1
	uvn_attach(vp, VM_PROT_READ);
@


1.61.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.63 2002/01/20 11:27:52 art Exp $	*/
a253 6
	 * Cheap solution to complicated problems.
	 * Mark this process as "leave me alone, I'm execing".
	 */
	p->p_flag |= P_INEXEC;

	/*
a617 1
	p->p_flag &= ~P_INEXEC;
a635 1
	p->p_flag &= ~P_INEXEC;
a658 1
	p->p_flag &= ~P_INEXEC;
@


1.61.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.61.2.1 2002/01/31 22:55:40 niklas Exp $	*/
d73 1
a73 1
int stackgap_random = 1024;
d324 1
a324 1
		error = EFAULT;
d538 3
d548 1
a548 1
					goto exec_abort;
d554 1
d556 1
a556 2
					closef(fp, p);
					goto exec_abort;
d559 1
a560 1
					closef(fp, p);
d562 1
a562 1
					goto exec_abort;
@


1.61.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.61.2.2 2002/06/11 03:29:40 art Exp $	*/
a68 5
 * Map the shared signal code.
 */
int exec_sigcode_map(struct proc *, struct emul *);

/*
a151 3
	/* unlock vp, we need it unlocked from here */
	VOP_UNLOCK(vp, 0, p);

d155 1
a155 1
	    UIO_SYSSPACE, 0, p->p_ucred, &resid, p);
d170 1
d201 2
a202 1
	 * close the vnode, free the pathname buf, and punt.
d204 1
d250 1
d298 1
a298 1
	if (argp == NULL)
d369 2
d376 2
a377 1
	    sizeof(long) + dp + sgap + sizeof(struct ps_strings)) - argp;
d409 9
a417 1
	error = exec_process_vmcmds(p, &pack);
d428 2
a429 2
	stack = (char *)USRSTACK + sizeof(arginfo);
	slen = len - sizeof(arginfo);
d441 11
d592 2
a593 1
	vn_close(pack.ep_vp, FREAD, cred, p);
a610 4
	/* map the process's signal trampoline code */
	if (exec_sigcode_map(p, pack.ep_emul))
		goto exec_abort;

d633 2
a634 1
	vn_close(pack.ep_vp, FREAD, cred, p);
d654 2
a655 1
	vn_close(pack.ep_vp, FREAD, cred, p);
a710 49
}

int
exec_sigcode_map(struct proc *p, struct emul *e)
{
	vsize_t sz;

	sz = (vaddr_t)e->e_esigcode - (vaddr_t)e->e_sigcode;

	/*
	 * If we don't have a sigobject for this emulation, create one.
	 *
	 * sigobject is an anonymous memory object (just like SYSV shared
	 * memory) that we keep a permanent reference to and that we map
	 * in all processes that need this sigcode. The creation is simple,
	 * we create an object, add a permanent reference to it, map it in
	 * kernel space, copy out the sigcode to it and unmap it.
	 * The we map it with PROT_READ|PROT_EXEC into the process just
	 * the way sys_mmap would map it.
	 */
	if (e->e_sigobject == NULL) {
		vaddr_t va;
		int r;

		e->e_sigobject = uao_create(sz, 0);
		uao_reference(e->e_sigobject);	/* permanent reference */

		va = vm_map_min(kernel_map);	/* hint */
		if ((r = uvm_map(kernel_map, &va, round_page(sz), e->e_sigobject,
		    0, 0, UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW,
		    UVM_INH_SHARE, UVM_ADV_RANDOM, 0)))) {
			printf("kernel mapping failed %d\n", r);
			return (ENOMEM);
		}
		memcpy((void *)va, e->e_sigcode, sz);
		uvm_unmap(kernel_map, va, va + round_page(sz));
	}

	/* Just a hint to uvm_mmap where to put it. */
	p->p_sigcode = round_page((vaddr_t)p->p_vmspace->vm_daddr + MAXDSIZ);
	uao_reference(e->e_sigobject);
	if (uvm_map(&p->p_vmspace->vm_map, &p->p_sigcode, round_page(sz),
	    e->e_sigobject, 0, 0, UVM_MAPFLAG(UVM_PROT_RX, UVM_PROT_RX,
	    UVM_INH_SHARE, UVM_ADV_RANDOM, 0))) {
		printf("user mapping failed\n");
		return (ENOMEM);
	}

	return (0);
@


1.61.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d101 1
a101 1
 *		non-destructive:
d352 1
a352 1
	/* environment does not need to be there */
d457 2
a458 2
	 * If process does execve() while it has a mismatched real,
	 * effective, or saved uid/gid, we set P_SUGIDEXEC.
d460 2
a461 6
	if (p->p_ucred->cr_uid != p->p_cred->p_ruid ||
	    p->p_ucred->cr_uid != p->p_cred->p_svuid ||
	    p->p_ucred->cr_gid != p->p_cred->p_rgid ||
	    p->p_ucred->cr_gid != p->p_cred->p_svgid)
		p->p_flag |= P_SUGIDEXEC;
	else
d644 1
d733 1
a733 1
	p->p_sigcode = uvm_map_hint(p, VM_PROT_READ|VM_PROT_EXECUTE);
@


1.60
log
@Bring in more changes from NetBSD. Mostly pagedaemon improvements.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.59 2001/11/06 19:53:20 miod Exp $	*/
d153 1
@


1.59
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.58 2001/10/26 12:03:27 art Exp $	*/
d386 1
a386 1
	uvmspace_exec(p);
@


1.58
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.57 2001/09/19 20:50:58 mickey Exp $	*/
a60 1
#include <vm/vm.h>
@


1.57
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.56 2001/08/25 20:37:06 art Exp $	*/
d509 6
a514 3
			if (i < p->p_fd->fd_nfiles)
				fp = p->p_fd->fd_ofiles[i];

d564 1
@


1.57.2.1
log
@Pull in patch from current:
Errata 012:
A race condition between the ptrace(2) and execve(2) system
calls allows an attacker to modify the memory contents of
suid/sgid processes which could lead to compromise of the
super-user account.
Fix (art):
When a process is exec:ing mark it with a flag. Check that flag in ptrace
and procfs (and possibly more places in the future) and simply refuse to
fiddle with the execing process. This is an ugly hack, but this far we
haven't been successful in creating a race-free exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.57 2001/09/19 20:50:58 mickey Exp $	*/
a253 6
	 * Cheap solution to complicated problems.
	 * Mark this process as "leave me alone, I'm execing".
	 */
	p->p_flag |= P_INEXEC;

	/*
a613 1
	p->p_flag &= ~P_INEXEC;
a631 1
	p->p_flag &= ~P_INEXEC;
a654 1
	p->p_flag &= ~P_INEXEC;
@


1.57.2.2
log
@Errata #21 (millert)

Cause the exec to fail if we are unable to allocate resources when dup'ing
/dev/null to fd's 0-2 for a setuid program; deraadt@@ and art@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.57.2.1 2002/01/23 03:10:01 jason Exp $	*/
d535 3
d545 1
a545 1
					goto exec_abort;
d553 1
a553 1
					goto exec_abort;
d559 1
a559 1
					goto exec_abort;
@


1.56
log
@It makes more sense to have argc stored as a long on the stack,
not int. Shouldn't affect any archs except sparc64 (now one step closer to a working userland).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.55 2001/08/18 03:32:16 art Exp $	*/
a61 2
#include <vm/vm_kern.h>

@


1.55
log
@Add a possibility to add a random offset to the stack on exec. This makes
it slightly harder to write generic buffer overflows. This doesn't really
give any real security, but it raises the bar for script-kiddies and it's
really cheap.

The range of the random offsets is controlled by the sysctl
kern.stackgap_random (must be a power of 2).

This is disabled by default right now, but we'll set it to a reasonable value
(1024?) soon, after some more testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.54 2001/06/27 04:49:41 art Exp $	*/
d672 1
a672 1
	int argc = arginfo->ps_nargvstr;
@


1.54
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.53 2001/06/22 23:55:23 art Exp $	*/
d69 9
d231 1
a231 1
	register struct sys_execve_args /* {
d244 1
a244 1
	size_t len;
d367 3
d372 1
a372 1
	    sizeof(long) + dp + STACKGAPLEN + szsigcode +
@


1.53
log
@Try again. (this time it's tested).
Add proc_cansugid that checks if a process may raise it's privileges.
Rework exec to remove the old sugid workaround and check proc_cansugid
just before raising privileges.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.52 2001/06/22 14:14:08 deraadt Exp $	*/
a63 1
#if defined(UVM)
a64 1
#endif
a282 1
#if defined(UVM)
a283 3
#else
	argp = (char *)kmem_alloc_wait(exec_map, NCARGS);
#endif
a376 1
#if defined(UVM)
a377 13
#else
	/* Unmap old program */
#ifdef __sparc__
	kill_user_windows(p);		/* before stack addresses go away */
#endif
	/* Kill shared memory and unmap old program */
#ifdef SYSVSHM
	if (vm->vm_shm && vm->vm_refcnt == 1)
		shmexit(vm);
#endif
	vm_deallocate(&vm->vm_map, VM_MIN_ADDRESS,
	    VM_MAXUSER_ADDRESS - VM_MIN_ADDRESS);
#endif
a571 1
#if defined(UVM)
a572 3
#else
	kmem_free_wakeup(exec_map, (vaddr_t)argp, NCARGS);
#endif
a617 1
#if defined(UVM)
a618 3
#else
	kmem_free_wakeup(exec_map, (vaddr_t) argp, NCARGS);
#endif
a629 1
#if defined(UVM)
a631 4
#else
	vm_deallocate(&vm->vm_map, VM_MIN_ADDRESS,
		VM_MAXUSER_ADDRESS - VM_MIN_ADDRESS);
#endif
a636 1
#if defined(UVM)
a637 3
#else
	kmem_free_wakeup(exec_map, (vaddr_t) argp, NCARGS);
#endif
@


1.52
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.51 2001/06/19 07:54:36 deraadt Exp $	*/
d132 2
a133 2
	if ((vp->v_mount->mnt_flag & MNT_NOSUID) ||
	    (p->p_flag & P_TRACED) || p->p_fd->fd_refcnt > 1)
a135 9
	/*
	 * Set the P_SUID* flags early so that we won't be fiddled with when
	 * we sleep later in this code.
	 * XXX - this could give us a few false positives and the caller must
	 *       make sure to save and restore the flags if exec fails.
	 */
	if (epp->ep_vap->va_mode & (VSUID|VSGID))
		p->p_flag |= P_SUGID|P_SUGIDEXEC;

a246 1
	int saved_sugid;
a276 1
	saved_sugid = p->p_flag & (P_SUGID|P_SUGIDEXEC);
d488 1
a488 1
	 * MNT_NOEXEC and P_TRACED have already been used to disable s[ug]id.
d490 1
a490 1
	if ((attr.va_mode & (VSUID | VSGID))) {
d493 3
a510 2
		p->p_flag |= P_SUGID;
		p->p_flag |= P_SUGIDEXEC;
a649 1
	p->p_flag = (p->p_flag & ~(P_SUGID|P_SUGIDEXEC)) | saved_sugid;
@


1.51
log
@no way, you are on drugs.  last commit revoked because it broke setuid majorly
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.49 2001/06/15 11:10:18 art Exp $	*/
d478 2
a479 2
        if (p->p_textvp)
                vrele(p->p_textvp);
d618 2
a619 2
	if(pack.ep_emul->e_fixup != NULL) {
		if((*pack.ep_emul->e_fixup)(p, &pack) != 0)
@


1.50
log
@Check is sugid is allowed where we set the P_SUGID* flags.
Remove the ugly hack added in last revision.
@
text
@d132 3
d136 8
a143 2
	if ((vp->v_mount->mnt_flag & MNT_NOSUID))
		epp->ep_vap->va_mode &= ~(VSUID | VSGID);
d256 1
d287 1
d499 1
a499 1
	 * MNT_NOEXEC has already been used to disable s[ug]id.
d501 1
a501 1
	if ((attr.va_mode & (VSUID | VSGID)) && proc_cansugid(p)) {
a503 3
		p->p_flag |= P_SUGID;
		p->p_flag |= P_SUGIDEXEC;

d519 2
d660 1
@


1.49
log
@Avoid a dangerous race.
To avoid having a ptrace(2)d process from doing an exec of a suid binary
we strip off the suid bits from the executable if the process is traced.
Later we P_SUGID{,EXEC} in the process flags that stops further ptrace
attempts.

The problem is that between the stripping of suid bits and setting
P_SUGID{,EXEC} there is a pretty large window where the process can sleep
and other processes can attach to it with ptrace.

This is a quick fix for that. We set P_SUGID{,EXEC} early and take care to
remove them (we don't want the process to become tainted unnecessarily) if
exec fails.
XXX - exec needs a lot more work, but people are asking for a solution now.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.48 2001/04/01 21:30:33 art Exp $	*/
d132 2
a133 2
	if ((vp->v_mount->mnt_flag & MNT_NOSUID) ||
	    (p->p_flag & P_TRACED) || p->p_fd->fd_refcnt > 1)
a135 9
	/*
	 * Set the P_SUID* flags early so that we won't be fiddled with when
	 * we sleep later in this code.
	 * XXX - this could give us a few false positives and the caller must
	 *       make sure to save and restore the flags if exec fails.
	 */
	if (epp->ep_vap->va_mode & (VSUID|VSGID))
		p->p_flag |= P_SUGID|P_SUGIDEXEC;

a246 1
	int saved_sugid;
a276 1
	saved_sugid = p->p_flag & (P_SUGID|P_SUGIDEXEC);
d488 1
a488 1
	 * MNT_NOEXEC and P_TRACED have already been used to disable s[ug]id.
d490 1
a490 1
	if ((attr.va_mode & (VSUID | VSGID))) {
d493 3
a510 2
		p->p_flag |= P_SUGID;
		p->p_flag |= P_SUGIDEXEC;
a649 1
	p->p_flag = (p->p_flag & ~(P_SUGID|P_SUGIDEXEC)) | saved_sugid;
@


1.48
log
@Add a macro to initialize the contents of a vmcmd set.
Correctly initialize the vmcmds in linux_exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.47 2001/02/22 16:08:01 art Exp $	*/
d136 9
d256 1
d287 1
d660 1
@


1.48.2.1
log
@Pull in patch from current:
Errata 007:
A race condition exists in the kernel execve(2) implementation that opens a
small window of vulnerability for a non-privileged user to ptrace(2) attach
to a suid/sgid process.
Fix (art):
Avoid a dangerous race.
To avoid having a ptrace(2)d process from doing an exec of a suid binary
we strip off the suid bits from the executable if the process is traced.
Later we P_SUGID{,EXEC} in the process flags that stops further ptrace
attempts.

The problem is that between the stripping of suid bits and setting
P_SUGID{,EXEC} there is a pretty large window where the process can sleep
and other processes can attach to it with ptrace.

This is a quick fix for that. We set P_SUGID{,EXEC} early and take care to
remove them (we don't want the process to become tainted unnecessarily) if
exec fails.
XXX - exec needs a lot more work, but people are asking for a solution now.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.48 2001/04/01 21:30:33 art Exp $	*/
a135 9
	/*
	 * Set the P_SUID* flags early so that we won't be fiddled with when
	 * we sleep later in this code.
	 * XXX - this could give us a few false positives and the caller must
	 *       make sure to save and restore the flags if exec fails.
	 */
	if (epp->ep_vap->va_mode & (VSUID|VSGID))
		p->p_flag |= P_SUGID|P_SUGIDEXEC;

a246 1
	int saved_sugid;
a276 1
	saved_sugid = p->p_flag & (P_SUGID|P_SUGIDEXEC);
a648 1
	p->p_flag = (p->p_flag & ~(P_SUGID|P_SUGIDEXEC)) | saved_sugid;
@


1.48.2.2
log
@MFC, requested by art@@ some time ago:
When a process is exec:ing mark it with a flag. Check that flag in ptrace
and procfs (and possibly more places in the future) and simply refuse to
fiddle with the execing process. This is an ugly hack, but this far we
haven't been successful in creating a race-free exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.48.2.1 2001/06/16 02:30:46 jason Exp $	*/
a258 6
	 * Cheap solution to complicated problems.
	 * Mark this process as "leave me alone, I'm execing".
	 */
	p->p_flag |= P_INEXEC;

	/*
a637 1
	p->p_flag &= ~P_INEXEC;
d660 1
a660 1
	p->p_flag = (p->p_flag & ~(P_SUGID|P_SUGIDEXEC|P_INEXEC)) | saved_sugid;
a692 1
	p->p_flag &= ~P_INEXEC;
@


1.48.2.3
log
@Errata #26 (millert)

Cause the exec to fail if we are unable to allocate resources when dup'ing
/dev/null to fd's 0-2 for a setuid program; deraadt@@ and art@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.48.2.2 2002/02/20 08:52:33 miod Exp $	*/
d555 3
d565 1
a565 1
					goto exec_abort;
d573 1
a573 1
					goto exec_abort;
d579 1
a579 1
					goto exec_abort;
@


1.47
log
@ELF uses more than 5 vmcmds by default, so grow the default vmcmd set size
to 8.

At the same time it seemed like a good idea to avoid to always malloc a
new vmcmd array, so put the default sized array into struct exec_vmcmd_set.

We might want to make a linked list of vmcmd arrays or exec_vmcmd_sets instead
of reallocating them some time in the future, but right now this seems like a
waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.46 2000/11/16 20:02:16 provos Exp $	*/
d272 1
a272 3
	pack.ep_vmcmds.evs_cnt = EXEC_DEFAULT_VMCMD_SETSIZE;
	pack.ep_vmcmds.evs_cmds = pack.ep_vmcmds.evs_start;
	pack.ep_vmcmds.evs_used = 0;
@


1.46
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.45 2000/11/10 18:15:46 art Exp $	*/
d272 2
a273 1
	pack.ep_vmcmds.evs_cnt = 0;
@


1.45
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.44 2000/09/28 13:41:39 art Exp $	*/
d601 5
@


1.44
log
@When allocating the unallocated file descriptors 0, 1 and 2 for suid execs,
don't do it by doing namei on /dev/null.

The vnode for the executed file is locked and we had a race where other
processes could lock the parent directories up to the root. When the
executing process did the lookup on /dev/null it could deadlock on the
root vnode while still holding the lock on the executed vnode.

Also, it's really bad idea to depend on certain filesystem layout inside
the kernel. Now we get the null device vnode by cdevvp(getnulldev(), ...

Thanks to Matrin Portmann <map@@infinitum.ch> for providing the (large)
ktrace that allowed me to track this down.

Fixes 1369.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.43 2000/09/26 14:01:39 art Exp $	*/
d621 1
a621 1
		ktremul(p->p_tracep, p->p_emul->e_name);
@


1.44.2.1
log
@Pull in patch from current:
Errata (030):
A race condition exists in the kernel execve(2) implementation that
opens a small window of vulnerability for a non-privileged user
to ptrace(2) attach to a suid/sgid process.
Fix (art):
Avoid a dangerous race.
To avoid having a ptrace(2)d process from doing an exec of a suid binary
we strip off the suid bits from the executable if the process is traced.
Later we P_SUGID{,EXEC} in the process flags that stops further ptrace
attempts.

The problem is that between the stripping of suid bits and setting
P_SUGID{,EXEC} there is a pretty large window where the process can sleep
and other processes can attach to it with ptrace.

This is a quick fix for that. We set P_SUGID{,EXEC} early and take care to
remove them (we don't want the process to become tainted unnecessarily) if
exec fails.
XXX - exec needs a lot more work, but people are asking for a solution now.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.44 2000/09/28 13:41:39 art Exp $	*/
a135 9
	/*
	 * Set the P_SUID* flags early so that we won't be fiddled with when
	 * we sleep later in this code.
	 * XXX - this could give us a few false positives and the caller must
	 *       make sure to save and restore the flags if exec fails.
	 */
	if (epp->ep_vap->va_mode & (VSUID|VSGID))
		p->p_flag |= P_SUGID|P_SUGIDEXEC;

a246 1
	int saved_sugid;
a277 1
	saved_sugid = p->p_flag & (P_SUGID|P_SUGIDEXEC);
a644 1
	p->p_flag = (p->p_flag & ~(P_SUGID|P_SUGIDEXEC)) | saved_sugid;
@


1.43
log
@Don't use MALLOC/FREE on variable sized allocations.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.42 2000/04/20 10:03:42 art Exp $	*/
d54 1
d539 3
d545 1
a545 1
				struct nameidata nd;
d549 11
a559 4
					continue;
				NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE,
				    "/dev/null", p);
				if ((error = vn_open(&nd, flags, 0)) != 0) {
d562 1
d565 2
d570 1
a570 2
				fp->f_data = (caddr_t)nd.ni_vp;
				VOP_UNLOCK(nd.ni_vp, 0, p);
@


1.42
log
@Add a function "ktrsettracevnode", that changes the ktrace vnode for a process
in a correct way. Use it in all places where the vnode was changed.
(most of the earlier code was incorrect and had races).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.41 2000/03/23 15:55:52 art Exp $	*/
d266 1
a266 1
	MALLOC(pack.ep_hdr, void *, exec_maxhdrsz, M_EXEC, M_WAITOK);
d308 1
a308 1
			FREE(*tmpfap, M_EXEC);
d604 1
a604 1
	FREE(pack.ep_hdr, M_EXEC);
d631 1
a631 1
	FREE(pack.ep_hdr, M_EXEC);
d659 1
a659 1
	FREE(pack.ep_hdr, M_EXEC);
@


1.41
log
@Use the new timeout facilities for ITIMER_REAL.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.40 2000/03/22 21:35:37 mickey Exp $	*/
d500 1
a500 2
			vrele(p->p_tracep);
			p->p_tracep = NULL;
@


1.40
log
@some more machine_stack_grows_up
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.39 2000/02/01 04:03:14 assar Exp $	*/
d569 1
a569 1
		untimeout(realitexpire, (void *)p);
@


1.39
log
@remove superflous declaration of vnops, it's now in <sys/file.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.38 2000/01/24 22:44:58 mickey Exp $	*/
d432 2
a433 2
	stack = (char *)USRSTACK;
	slen = len;
d448 1
a448 1
	    ((char *)PS_STRINGS) + sizeof(struct ps_strings), szsigcode))
@


1.39.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d432 2
a433 2
	stack = (char *)USRSTACK + sizeof(arginfo) + szsigcode;
	slen = len - sizeof(arginfo) - szsigcode;
d448 1
a448 1
	    ((char *)PS_STRINGS) + sizeof(arginfo), szsigcode))
d569 1
a569 1
		timeout_del(&p->p_realit_to);
@


1.39.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.48 2001/04/01 21:30:33 art Exp $	*/
a53 1
#include <sys/conf.h>
d266 1
a266 1
	pack.ep_hdr = malloc(exec_maxhdrsz, M_EXEC, M_WAITOK);
d271 2
a272 1
	VMCMDSET_INIT(&pack.ep_vmcmds);
d308 1
a308 1
			free(*tmpfap, M_EXEC);
d500 2
a501 1
			ktrsettracevnode(p, NULL);
a538 3
			 *
			 * XXX - Shouldn't the exec fail if we can't allocate
			 *       resources here?
d542 1
a542 1
				struct vnode *vp;
d546 4
a549 11
					break;
#ifdef DIAGNOSTIC
				if (indx != i)
					panic("sys_execve: falloc indx != i");
#endif
				if ((error = cdevvp(getnulldev(), &vp)) != 0) {
					ffree(fp);
					fdremove(p->p_fd, indx);
					break;
				}
				if ((error = VOP_OPEN(vp, flags, p->p_ucred, p)) != 0) {
a551 1
					vrele(vp);
a553 2
				if (flags & FWRITE)
					vp->v_writecount++;
d557 2
a558 1
				fp->f_data = (caddr_t)vp;
a589 5
	/*
	 * notify others that we exec'd
	 */
	KNOTE(&p->p_klist, NOTE_EXEC);

d605 1
a605 1
	free(pack.ep_hdr, M_EXEC);
d609 1
a609 1
		ktremul(p, p->p_emul->e_name);
d632 1
a632 1
	free(pack.ep_hdr, M_EXEC);
d660 1
a660 1
	free(pack.ep_hdr, M_EXEC);
@


1.39.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.39.2.2 2001/05/14 22:32:40 niklas Exp $	*/
d64 1
d66 1
d132 2
a133 2

	if ((vp->v_mount->mnt_flag & MNT_NOSUID))
d285 1
d287 3
d383 1
d385 13
d467 2
a468 2
	if (p->p_textvp)
		vrele(p->p_textvp);
d488 1
a488 1
	 * MNT_NOEXEC has already been used to disable s[ug]id.
d490 1
a490 1
	if ((attr.va_mode & (VSUID | VSGID)) && proc_cansugid(p)) {
a492 3
		p->p_flag |= P_SUGID;
		p->p_flag |= P_SUGIDEXEC;

d508 2
d591 1
d593 3
d607 2
a608 2
	if (pack.ep_emul->e_fixup != NULL) {
		if ((*pack.ep_emul->e_fixup)(p, &pack) != 0)
d641 1
d643 3
d657 1
d660 4
d669 1
d671 3
@


1.39.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.39.2.3 2001/07/04 10:48:16 niklas Exp $	*/
d62 2
a68 9
#include <dev/rndvar.h>

/*
 * stackgap_random specifies if the stackgap should have a random size added
 * to it. Must be a n^2. If non-zero, the stack gap will be calculated as:
 * (arc4random() * ALIGNBYTES) & (stackgap_random - 1) + STACKGAPLEN.
 */
int stackgap_random;

d222 1
a222 1
	struct sys_execve_args /* {
d235 1
a235 1
	size_t len, sgap;
a357 3
	sgap = STACKGAPLEN;
	if (stackgap_random != 0)
		sgap += (arc4random() * ALIGNBYTES) & (stackgap_random - 1);
d360 1
a360 1
	    sizeof(long) + dp + sgap + szsigcode +
d499 3
a501 6
			/*
			 * NOTE - This will never return NULL because of
			 * unmature fds. The file descriptor table is not
			 * shared because we're suid.
			 */
			fp = fd_getfile(p->p_fd, i);
a550 1
				FILE_SET_MATURE(fp);
d660 1
a660 1
	long argc = arginfo->ps_nargvstr;
@


1.39.2.5
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 1
d387 1
a387 1
	uvmspace_exec(p, VM_MIN_ADDRESS, VM_MAXUSER_ADDRESS);
@


1.39.2.6
log
@Merge in -current
@
text
@a152 1
	uvn_attach(vp, VM_PROT_READ);
@


1.39.2.7
log
@Merge in trunk
@
text
@d73 1
a73 1
int stackgap_random = 1024;
d153 1
a253 6
	 * Cheap solution to complicated problems.
	 * Mark this process as "leave me alone, I'm execing".
	 */
	p->p_flag |= P_INEXEC;

	/*
d548 1
a549 1
					closef(fp, p);
d553 1
a554 1
					closef(fp, p);
a617 1
	p->p_flag &= ~P_INEXEC;
a635 1
	p->p_flag &= ~P_INEXEC;
a658 1
	p->p_flag &= ~P_INEXEC;
@


1.39.2.8
log
@Merge in -current from about a week ago
@
text
@d323 1
a323 1
		error = EFAULT;
@


1.39.2.9
log
@Sync the SMP branch with 3.3
@
text
@a68 5
 * Map the shared signal code.
 */
int exec_sigcode_map(struct proc *, struct emul *);

/*
d96 1
a96 1
 *		non-destructive:
a151 3
	/* unlock vp, we need it unlocked from here */
	VOP_UNLOCK(vp, 0, p);

d154 1
a154 1
	    UIO_SYSSPACE, 0, p->p_ucred, &resid, p);
d169 1
d200 2
a201 1
	 * close the vnode, free the pathname buf, and punt.
d203 1
d249 1
d297 1
a297 1
	if (argp == NULL)
d347 1
a347 1
	/* environment does not need to be there */
d368 2
d375 2
a376 1
	    sizeof(long) + dp + sgap + sizeof(struct ps_strings)) - argp;
d408 9
a416 1
	error = exec_process_vmcmds(p, &pack);
d427 2
a428 2
	stack = (char *)USRSTACK + sizeof(arginfo);
	slen = len - sizeof(arginfo);
d440 11
d474 2
a475 2
	 * If process does execve() while it has a mismatched real,
	 * effective, or saved uid/gid, we set P_SUGIDEXEC.
d477 2
a478 6
	if (p->p_ucred->cr_uid != p->p_cred->p_ruid ||
	    p->p_ucred->cr_uid != p->p_cred->p_svuid ||
	    p->p_ucred->cr_gid != p->p_cred->p_rgid ||
	    p->p_ucred->cr_gid != p->p_cred->p_svgid)
		p->p_flag |= P_SUGIDEXEC;
	else
d537 3
d547 1
a547 1
					goto exec_abort;
d555 1
a555 1
					goto exec_abort;
d561 1
a561 1
					goto exec_abort;
d594 2
a595 1
	vn_close(pack.ep_vp, FREAD, cred, p);
a612 4
	/* map the process's signal trampoline code */
	if (exec_sigcode_map(p, pack.ep_emul))
		goto exec_abort;

d635 2
a636 1
	vn_close(pack.ep_vp, FREAD, cred, p);
d656 2
a657 1
	vn_close(pack.ep_vp, FREAD, cred, p);
d663 1
a712 49
}

int
exec_sigcode_map(struct proc *p, struct emul *e)
{
	vsize_t sz;

	sz = (vaddr_t)e->e_esigcode - (vaddr_t)e->e_sigcode;

	/*
	 * If we don't have a sigobject for this emulation, create one.
	 *
	 * sigobject is an anonymous memory object (just like SYSV shared
	 * memory) that we keep a permanent reference to and that we map
	 * in all processes that need this sigcode. The creation is simple,
	 * we create an object, add a permanent reference to it, map it in
	 * kernel space, copy out the sigcode to it and unmap it.
	 * The we map it with PROT_READ|PROT_EXEC into the process just
	 * the way sys_mmap would map it.
	 */
	if (e->e_sigobject == NULL) {
		vaddr_t va;
		int r;

		e->e_sigobject = uao_create(sz, 0);
		uao_reference(e->e_sigobject);	/* permanent reference */

		va = vm_map_min(kernel_map);	/* hint */
		if ((r = uvm_map(kernel_map, &va, round_page(sz), e->e_sigobject,
		    0, 0, UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_RW,
		    UVM_INH_SHARE, UVM_ADV_RANDOM, 0)))) {
			printf("kernel mapping failed %d\n", r);
			return (ENOMEM);
		}
		memcpy((void *)va, e->e_sigcode, sz);
		uvm_unmap(kernel_map, va, va + round_page(sz));
	}

	/* Just a hint to uvm_mmap where to put it. */
	p->p_sigcode = round_page((vaddr_t)p->p_vmspace->vm_daddr + MAXDSIZ);
	uao_reference(e->e_sigobject);
	if (uvm_map(&p->p_vmspace->vm_map, &p->p_sigcode, round_page(sz),
	    e->e_sigobject, 0, 0, UVM_MAPFLAG(UVM_PROT_RX, UVM_PROT_RX,
	    UVM_INH_SHARE, UVM_ADV_RANDOM, 0))) {
		printf("user mapping failed\n");
		return (ENOMEM);
	}

	return (0);
@


1.39.2.10
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.39.2.9 2003/03/28 00:41:26 niklas Exp $	*/
d735 1
a735 1
	p->p_sigcode = uvm_map_hint(p, VM_PROT_READ|VM_PROT_EXECUTE);
@


1.39.2.11
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.39.2.10 2003/05/13 19:21:28 ho Exp $	*/
d78 1
a78 1
int stackgap_random = 64*1024;
d713 1
a713 1
	 * Then we map it with PROT_READ|PROT_EXEC into the process just
@


1.39.2.12
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a177 2
		if (!newerror && !(epp->ep_emul->e_flags & EMUL_ENABLED))
			newerror = ENOEXEC;
d234 3
a236 3
		syscallarg(const char *) path;
		syscallarg(char *const *) argp;
		syscallarg(char *const *) envp;
d238 1
a238 1
	int error;
d262 12
d602 1
a603 24

	/*
	 * Call emulation specific exec hook. This can setup per-process
	 * p->p_emuldata or do any other per-process stuff an emulation needs.
	 *
	 * If we are executing process of different emulation than the
	 * original forked process, call e_proc_exit() of the old emulation
	 * first, then e_proc_exec() of new emulation. If the emulation is
	 * same, the exec hook code should deallocate any old emulation
	 * resources held previously by this process.
	 */
	if (p->p_emul && p->p_emul->e_proc_exit &&
	    p->p_emul != pack.ep_emul)
		(*p->p_emul->e_proc_exit)(p);

	/*
	 * Call exec hook. Emulation code may NOT store reference to anything
	 * from &pack.
	 */
	if (pack.ep_emul->e_proc_exec)
		(*pack.ep_emul->e_proc_exec)(p, &pack);

	/* update p_emul, the old value is no longer needed */
	p->p_emul = pack.ep_emul;
@


1.39.2.13
log
@Merge with the trunk
@
text
@a42 1
#include <sys/pool.h>
d212 1
a212 1
	pool_put(&namei_pool, ndp->ni_cnd.cn_pnbuf);
d220 1
a220 1
	pool_put(&namei_pool, ndp->ni_cnd.cn_pnbuf);
a274 1
	pack.ep_interp = NULL;
d566 1
a566 1
	pool_put(&namei_pool, nid.ni_cnd.cn_pnbuf);
d587 1
a587 1
		goto free_pack_abort;
a632 4
	if (pack.ep_interp != NULL)
		FREE(pack.ep_interp, M_TEMP);
	if (pack.ep_emul_arg != NULL)
		FREE(pack.ep_emul_arg, M_TEMP);
d635 1
a635 1
	pool_put(&namei_pool, nid.ni_cnd.cn_pnbuf);
d651 1
a651 3
	if (pack.ep_interp != NULL)
		FREE(pack.ep_interp, M_TEMP);
	if (pack.ep_emul_arg != NULL)
d653 1
a653 1
	pool_put(&namei_pool, nid.ni_cnd.cn_pnbuf);
a740 1
			uao_detach(e->e_sigobject);
a753 1
		uao_detach(e->e_sigobject);
@


1.39.2.14
log
@sync to HEAD
@
text
@a394 1
	vm->vm_minsaddr = (char *)pack.ep_minsaddr;
@


1.38
log
@fix setregs call for bawkward stacks; does not affect straight case
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.37 2000/01/20 09:30:02 deraadt Exp $	*/
a541 1
				extern struct fileops vnops;
@


1.37
log
@set[ug]id, not just setuid
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.36 2000/01/20 01:16:50 deraadt Exp $	*/
d237 3
d433 1
d597 1
a597 1
	(*pack.ep_emul->e_setregs)(p, &pack, (u_long)stack + len, retval);
@


1.36
log
@when procfs is compiled in, if a setuid process has any of descriptors 0-2
open for write on procfs, close it (and, thus, open a /dev/null instead);
problem reported by nergal@@idea.avet.com.pl, fix by me, thanks for help
from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.34 1999/11/05 01:18:01 mickey Exp $	*/
d509 2
a510 2
		 * For setuid processes, a few caveats apply to stdin, stdout,
		 * and stderr.
@


1.35
log
@do not NULL dereference if fd_nfiles < 3
@
text
@d509 2
a510 5
		 * XXX For setuid processes, attempt to ensure that
		 * stdin, stdout, and stderr are already allocated.
		 * We do not want userland to accidentally allocate
		 * descriptors in this range which has implied meaning
		 * to libc.
d513 1
a513 5
			extern struct fileops vnops;
			struct nameidata nd;
			struct file *fp;
			int indx;
			short flags;
d515 26
a540 1
			flags = FREAD | (i == 0 ? 0 : FWRITE);
a541 2
			if (i < p->p_fd->fd_nfiles ||
			    p->p_fd->fd_ofiles[i] == NULL) {
a557 1

@


1.34
log
@more stack direction fixes; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.33 1999/08/09 12:19:07 millert Exp $	*/
d524 2
a525 1
			if (p->p_fd->fd_ofiles[i] == NULL) {
@


1.33
log
@Stop profiling (see profil(2)) when we execve() a new process; ross@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.32 1999/07/15 14:11:05 art Exp $	*/
d428 3
d432 1
d441 6
a446 1
	/* copy out the process's signal trapoline code */
d450 1
d576 3
d580 1
@


1.32
log
@Don't destroy sysvshm if the vmspace is shared (only affects uvm)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.31 1999/07/15 14:07:41 art Exp $	*/
d442 1
@


1.31
log
@vm_offset_t -> {v,p}addr_t ; vm_size_t -> {v,p}size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.30 1999/07/13 15:17:50 provos Exp $	*/
d389 1
a389 1
	if (vm->vm_shm)
@


1.30
log
@introduce fdremove() to mark a file descriptor as unused. fdremove makes
sure that the fd_freefile hints stay in sync, otherwise free file
descriptors might not be overlooked by fdalloc(); ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.29 1999/06/23 09:44:28 art Exp $	*/
d288 1
a288 1
	if (argp == (vm_offset_t) 0)
d553 1
a553 1
	kmem_free_wakeup(exec_map, (vm_offset_t)argp, NCARGS);
d594 1
a594 1
	kmem_free_wakeup(exec_map, (vm_offset_t) argp, NCARGS);
d622 1
a622 1
	kmem_free_wakeup(exec_map, (vm_offset_t) argp, NCARGS);
@


1.29
log
@Improved sysv shared memory. Works with UVM.
Original work done in FreeBSD, but this code was ported from NetBSD by
Chuck Cranor.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.28 1999/06/03 16:01:26 deraadt Exp $	*/
d520 1
a520 1
					p->p_fd->fd_ofiles[indx] = NULL;
@


1.28
log
@use __sparc__ just in case
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.27 1999/04/22 19:37:43 art Exp $	*/
d390 1
a390 1
		shmexit(p);
@


1.27
log
@uvmspace_exec can change p_vmspace!
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.26 1999/02/26 05:05:38 art Exp $	*/
d384 1
a384 1
#ifdef sparc
@


1.26
log
@vm allocation changes for uvm.
Call uvmspace_exec instead of manually cleaning up.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.25 1998/09/24 18:49:31 art Exp $	*/
d376 4
d396 1
@


1.25
log
@pretty up previous fix
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.24 1998/09/23 22:48:08 art Exp $	*/
d63 4
d282 3
d286 1
d376 3
d390 1
d545 3
d549 1
d586 3
d590 1
d602 4
d608 1
d614 3
d618 1
@


1.24
log
@use the same flags for f_flag as there were used for vn_open, otherwise vn_close will not decrease v_writecount for the vnode causing panics
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.23 1998/07/28 00:13:05 millert Exp $	*/
d492 3
d501 1
a501 2
				if ((error = vn_open(&nd, FREAD |
				    (i == 0 ? 0 : FWRITE), 0)) != 0) {
d506 1
a506 1
				fp->f_flag = FREAD | (i == 0 ? 0 : FWRITE);
@


1.23
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.22 1998/07/08 22:28:56 deraadt Exp $	*/
d504 1
a504 1
				fp->f_flag = FREAD;
@


1.22
log
@open fd1 and fd2 as FREAD|FWRITE
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.21 1998/07/02 09:03:42 deraadt Exp $	*/
d98 1
a98 1
	int resid;
@


1.21
log
@I suppose debugging code can be removed
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.20 1998/07/02 08:53:04 deraadt Exp $	*/
d498 2
a499 1
				if ((error = vn_open(&nd, FREAD, 0)) != 0) {
@


1.20
log
@for sugid procs ensure that fd 0-2 are allocated slots (by pointing at
/dev/null -- future patch will use a dead vnode of some sort) to prevent
reuse (ie. new allocations) of these fd which libc makes many assumptions
about; problem noted by James Youngman
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.19 1998/06/27 07:32:12 deraadt Exp $	*/
a493 1
				printf("need %d\n", i);
a498 1
					printf("failed %d\n", i);
a502 1
				printf("got %d\n", i);
@


1.19
log
@securelevels do NOT protect running binaries; only filesystem activity
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.17 1998/02/20 14:45:16 niklas Exp $	*/
d459 2
d479 35
@


1.18
log
@if we are being ptraced, do not permit execve of an immutable binary
@
text
@a129 2
	if (p->p_flag & P_TRACED && (epp->ep_vap->va_flags & IMMUTABLE))
		goto bad1;
@


1.17
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.16 1998/02/08 22:41:34 tholo Exp $	*/
d130 2
@


1.16
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.15 1997/11/06 05:58:15 csapuntz Exp $	*/
d105 1
a105 1
		return error;
d145 1
a145 1
			UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred, &resid, p);
d166 1
a166 1
			return error;
d197 1
a197 1
	return error;
d206 1
a206 1
	return error;
d278 1
a278 1
	argp = (char *) kmem_alloc_wait(exec_map, NCARGS);
d349 1
a349 1
	dp = (char *) ALIGN(dp);
d378 1
a378 1
		VM_MAXUSER_ADDRESS - VM_MIN_ADDRESS);
d381 1
a381 1
	vm->vm_taddr = (char *) pack.ep_taddr;
d383 1
a383 1
	vm->vm_daddr = (char *) pack.ep_daddr;
d386 1
a386 1
	vm->vm_maxsaddr = (char *) pack.ep_maxsaddr;
d411 1
a411 1
	stack = (char *) (USRSTACK - len);
d417 1
a417 1
	if (copyout(&arginfo, (char *) PS_STRINGS, sizeof(arginfo)))
d421 2
a422 3
	if (szsigcode && copyout((char *) pack.ep_emul->e_sigcode,
				 ((char *) PS_STRINGS) - szsigcode,
				 szsigcode))
d443 1
a443 1
		wakeup((caddr_t) p->p_pptr);
d496 1
a496 1
	kmem_free_wakeup(exec_map, (vm_offset_t) argp, NCARGS);
d507 1
a507 1
	(*pack.ep_emul->e_setregs)(p, &pack, (u_long) stack, retval);
d519 1
a519 1
	return 0;
d537 1
a537 1
	return error;
d560 1
a560 1
	return 0;
d579 1
a579 1
		return NULL;
d590 1
a590 1
			return NULL;
d593 1
a593 1
		return NULL;
d600 1
a600 1
			return NULL;
d603 1
a603 1
		return NULL;
d605 1
a605 1
	return cpp;
@


1.15
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.14 1997/10/06 20:19:51 deraadt Exp $	*/
d230 1
a230 1
	char **cpp, *dp, *sp;
d258 1
a258 1
	pack.ep_name = SCARG(uap, path);
@


1.14
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.12 1997/08/01 22:54:50 deraadt Exp $	*/
d191 1
a191 1
	 * unlock and close the vnode, restore the old one, free the
d194 1
a194 1
	VOP_UNLOCK(vp);
@


1.13
log
@VFS Lite2 Changes
@
text
@d191 1
a191 1
	 * unlock and close the vnode, free the
d194 1
a194 1
	VOP_UNLOCK(vp, 0, p);
@


1.12
log
@only allow setuid if fd_refcnt == 1, due to rfork
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.11 1997/06/05 08:05:54 deraadt Exp $	*/
d191 1
a191 1
	 * unlock and close the vnode, restore the old one, free the
d194 1
a194 1
	VOP_UNLOCK(vp);
@


1.11
log
@kill the other timers too
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.10 1997/06/04 14:34:17 deraadt Exp $	*/
d127 2
a128 1
	if ((vp->v_mount->mnt_flag & MNT_NOSUID) || (p->p_flag & P_TRACED))
@


1.10
log
@clear timer for setuid; kloo
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.9 1997/03/29 20:10:01 tholo Exp $	*/
d483 2
a484 1
		int s = splclock();
d488 5
@


1.9
log
@Return EISDIR for directories; idea from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.8 1997/02/18 00:16:05 deraadt Exp $	*/
d481 8
@


1.8
log
@if a P_SUGIDEXEC proc execve()'s a non-set[ug]id program while running
with uid/gid mismatches, P_SUGIDEXEC should persist (in case the
environment has not been cleaned). pointed out by wietse@@porcupine.org
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.6 1996/08/25 09:53:45 deraadt Exp $	*/
d109 4
@


1.7
log
@Cleanup exec
@
text
@d443 8
d473 1
a473 1
	} else {
a474 2
		p->p_flag &= ~P_SUGIDEXEC;
	}
@


1.6
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.5 1996/07/11 00:53:35 deraadt Exp $	*/
d165 1
a165 1
		if (epp->ep_entry > VM_MAXUSER_ADDRESS)
d167 1
d266 1
a266 1
	if ((error = check_exec(p, &pack)) != 0)
d268 1
d479 4
d529 2
@


1.5
log
@do not lose setuid flag
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_exec.c,v 1.4 1996/05/27 07:59:03 deraadt Exp $	*/
d462 1
d465 1
@


1.4
log
@native emul is now called "native"
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d444 1
a444 4
	p->p_flag &= ~P_SUGID;
	if (((attr.va_mode & VSUID) != 0 && p->p_ucred->cr_uid != attr.va_uid)
	 || ((attr.va_mode & VSGID) != 0 && p->p_ucred->cr_gid != attr.va_gid)){
		p->p_ucred = crcopy(cred);
d451 1
a453 1
			p->p_traceflag = 0;
d456 1
d462 2
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d232 1
a232 1
	extern struct emul emul_netbsd;
d261 1
a261 1
	pack.ep_emul = &emul_netbsd;
@


1.2
log
@from netbsd; If we abort, make sure to free ep_emul_arg
@
text
@d1 2
a2 1
/*	$NetBSD: kern_exec.c,v 1.73 1995/12/09 04:11:00 mycroft Exp $	*/
d54 3
a96 1
	char *cp, *ep, *name;
d104 1
a104 1
	if (error = namei(ndp))
d115 1
a115 1
	if (error = VOP_GETATTR(vp, epp->ep_vap, p->p_ucred, p))
d127 1
a127 1
	if (error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p))
d135 1
a135 1
	if (error = VOP_OPEN(vp, FREAD, p->p_ucred, p))
d139 3
a141 2
	if (error = vn_rdwr(UIO_READ, vp, epp->ep_hdr, epp->ep_hdrlen, 0,
	    UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred, &resid, p))
d207 1
d265 1
a265 1
	if (error = check_exec(p, &pack))
d288 1
a288 1
			*dp++;
d308 1
a308 1
		if (error = copyin(cpp, &sp, sizeof(sp)))
d312 1
a312 1
		if (error = copyinstr(sp, dp, len, &len)) {
d323 2
a324 1
	if (cpp = SCARG(uap, envp)) {	/* environment need not be there */
d327 1
a327 1
			if (error = copyin(cpp, &sp, sizeof(sp)))
d331 1
a331 1
			if (error = copyinstr(sp, dp, len, &len)) {
d445 2
a446 4
	if (((attr.va_mode & VSUID) != 0 &&
	    p->p_ucred->cr_uid != attr.va_uid)
	    || (attr.va_mode & VSGID) != 0 &&
	    p->p_ucred->cr_gid != attr.va_gid) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: kern_exec.c,v 1.72 1995/10/07 06:28:11 mycroft Exp $	*/
d511 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
