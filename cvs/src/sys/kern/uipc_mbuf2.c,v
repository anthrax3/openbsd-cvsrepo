head	1.42;
access;
symbols
	OPENBSD_6_2_BASE:1.42
	OPENBSD_6_1:1.42.0.8
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.42.0.4
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.37.0.8
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.37.0.6
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.35.0.4
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.2
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.29.0.6
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.2
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.28.0.6
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.22.0.6
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.18
	UBC:1.15.0.4
	UBC_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	SMP:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.42
date	2015.11.13.10.12.39;	author mpi;	state Exp;
branches;
next	1.41;
commitid	BHDkuvEKkivQfKxx;

1.41
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.40;
commitid	J4OPNuggl4DOKGzM;

1.40
date	2014.12.11.19.21.57;	author tedu;	state Exp;
branches;
next	1.39;
commitid	KtikWduHBwfG1emb;

1.39
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.38;
commitid	uzzBR7hz9ncd4O6G;

1.38
date	2014.08.18.05.11.03;	author dlg;	state Exp;
branches;
next	1.37;
commitid	hjFdrSJM3VTXJUZV;

1.37
date	2013.06.11.01.01.15;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2013.02.07.11.06.42;	author mikeb;	state Exp;
branches;
next	1.35;

1.35
date	2011.11.30.10.26.56;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.05.11.48.28;	author blambert;	state Exp;
branches;
next	1.33;

1.33
date	2011.01.29.13.15.39;	author bluhm;	state Exp;
branches;
next	1.32;

1.32
date	2010.06.07.19.47.25;	author blambert;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.13.14.42.52;	author krw;	state Exp;
branches;
next	1.30;

1.30
date	2009.08.09.12.50.09;	author henning;	state Exp;
branches;
next	1.29;

1.29
date	2008.11.30.18.22.15;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2007.03.17.09.26.35;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2007.02.26.20.15.33;	author claudio;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2007.01.03.18.39.56;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.18.08.20.51;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.17.04.15.51;	author brad;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2006.01.05.05.05.06;	author jsg;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2004.07.22.09.33.21;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.03.12.53.57;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.03.12.08.30;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.10.10.38.13;	author kjc;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.27.05;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.01.15.36.29;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.23.04.39.33;	author angelos;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2001.06.23.03.57.48;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.27.00.38.25;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.26.07.00.02;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.24.19.04.51;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.24.18.47.21;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.22.20.22.22;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.20.08.31.47;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.17.18.41.45;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.28.20.03.00;	author angelos;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.02.14.17.04.34;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.12.16.41.30;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.12.17.24.27;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2000.01.04.12.44.30;	author angelos;	state dead;
branches;
next	1.1;

1.1
date	99.12.08.06.50.17;	author itojun;	state Exp;
branches;
next	;

1.6.4.1
date	2001.05.14.22.32.45;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.07.04.10.48.44;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	;

1.15.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;

1.23.2.1
date	2007.03.07.19.21.03;	author deraadt;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2007.03.17.20.52.10;	author henning;	state Exp;
branches;
next	;

1.24.2.1
date	2007.03.07.19.21.48;	author deraadt;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2007.03.17.20.50.50;	author henning;	state Exp;
branches;
next	;

1.27.2.1
date	2007.04.28.01.50.26;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Use ph_ prefix for tag-related fields.

ok dlg@@
@
text
@/*	$OpenBSD: uipc_mbuf2.c,v 1.41 2015/06/30 15:30:17 mpi Exp $	*/
/*	$KAME: uipc_mbuf2.c,v 1.29 2001/02/14 13:42:10 itojun Exp $	*/
/*	$NetBSD: uipc_mbuf.c,v 1.40 1999/04/01 00:23:25 thorpej Exp $	*/

/*
 * Copyright (C) 1999 WIDE Project.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1988, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)uipc_mbuf.c	8.4 (Berkeley) 2/14/95
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/mbuf.h>

extern struct pool mtagpool;

/* can't call it m_dup(), as freebsd[34] uses m_dup() with different arg */
static struct mbuf *m_dup1(struct mbuf *, int, int, int);

/*
 * ensure that [off, off + len] is contiguous on the mbuf chain "m".
 * packet chain before "off" is kept untouched.
 * if offp == NULL, the target will start at <retval, 0> on resulting chain.
 * if offp != NULL, the target will start at <retval, *offp> on resulting chain.
 *
 * on error return (NULL return value), original "m" will be freed.
 *
 * XXX M_TRAILINGSPACE/M_LEADINGSPACE on shared cluster (sharedcluster)
 */
struct mbuf *
m_pulldown(struct mbuf *m, int off, int len, int *offp)
{
	struct mbuf *n, *o;
	int hlen, tlen, olen;
	int sharedcluster;

	/* check invalid arguments. */
	if (m == NULL)
		panic("m == NULL in m_pulldown()");

	if ((n = m_getptr(m, off, &off)) == NULL) {
		m_freem(m);
		return (NULL);	/* mbuf chain too short */
	}

	sharedcluster = M_READONLY(n);

	/*
	 * the target data is on <n, off>.
	 * if we got enough data on the mbuf "n", we're done.
	 */
	if ((off == 0 || offp) && len <= n->m_len - off && !sharedcluster)
		goto ok;

	/*
	 * when len <= n->m_len - off and off != 0, it is a special case.
	 * len bytes from <n, off> sits in single mbuf, but the caller does
	 * not like the starting position (off).
	 * chop the current mbuf into two pieces, set off to 0.
	 */
	if (len <= n->m_len - off) {
		struct mbuf *mlast;

		o = m_dup1(n, off, n->m_len - off, M_DONTWAIT);
		if (o == NULL) {
			m_freem(m);
			return (NULL);	/* ENOBUFS */
		}
		for (mlast = o; mlast->m_next != NULL; mlast = mlast->m_next)
			;
		n->m_len = off;
		mlast->m_next = n->m_next;
		n->m_next = o;
		n = o;
		off = 0;
		goto ok;
	}

	/*
	 * we need to take hlen from <n, off> and tlen from <n->m_next, 0>,
	 * and construct contiguous mbuf with m_len == len.
	 * note that hlen + tlen == len, and tlen > 0.
	 */
	hlen = n->m_len - off;
	tlen = len - hlen;

	/*
	 * ensure that we have enough trailing data on mbuf chain.
	 * if not, we can do nothing about the chain.
	 */
	olen = 0;
	for (o = n->m_next; o != NULL; o = o->m_next)
		olen += o->m_len;
	if (hlen + olen < len) {
		m_freem(m);
		return (NULL);	/* mbuf chain too short */
	}

	/*
	 * easy cases first.
	 * we need to use m_copydata() to get data from <n->m_next, 0>.
	 */
	if ((off == 0 || offp) && M_TRAILINGSPACE(n) >= tlen &&
	    !sharedcluster) {
		m_copydata(n->m_next, 0, tlen, mtod(n, caddr_t) + n->m_len);
		n->m_len += tlen;
		m_adj(n->m_next, tlen);
		goto ok;
	}
	if ((off == 0 || offp) && M_LEADINGSPACE(n->m_next) >= hlen &&
	    !sharedcluster && n->m_next->m_len >= tlen) {
		n->m_next->m_data -= hlen;
		n->m_next->m_len += hlen;
		memmove(mtod(n->m_next, caddr_t), mtod(n, caddr_t) + off, hlen);
		n->m_len -= hlen;
		n = n->m_next;
		off = 0;
		goto ok;
	}

	/*
	 * now, we need to do the hard way.  don't m_copym as there's no room
	 * on both ends.
	 */
	if (len > MAXMCLBYTES) {
		m_freem(m);
		return (NULL);
	}
	MGET(o, M_DONTWAIT, m->m_type);
	if (o && len > MLEN) {
		MCLGETI(o, M_DONTWAIT, NULL, len);
		if ((o->m_flags & M_EXT) == 0) {
			m_free(o);
			o = NULL;
		}
	}
	if (!o) {
		m_freem(m);
		return (NULL);	/* ENOBUFS */
	}
	/* get hlen from <n, off> into <o, 0> */
	o->m_len = hlen;
	memmove(mtod(o, caddr_t), mtod(n, caddr_t) + off, hlen);
	n->m_len -= hlen;
	/* get tlen from <n->m_next, 0> into <o, hlen> */
	m_copydata(n->m_next, 0, tlen, mtod(o, caddr_t) + o->m_len);
	o->m_len += tlen;
	m_adj(n->m_next, tlen);
	o->m_next = n->m_next;
	n->m_next = o;
	n = o;
	off = 0;

ok:
	if (offp)
		*offp = off;
	return (n);
}

static struct mbuf *
m_dup1(struct mbuf *m, int off, int len, int wait)
{
	struct mbuf *n;
	int l;

	if (len > MAXMCLBYTES)
		return (NULL);
	if (off == 0 && (m->m_flags & M_PKTHDR) != 0) {
		MGETHDR(n, wait, m->m_type);
		if (n == NULL)
			return (NULL);
		if (m_dup_pkthdr(n, m, wait)) {
			m_free(n);
			return (NULL);
		}
		l = MHLEN;
	} else {
		MGET(n, wait, m->m_type);
		l = MLEN;
	}
	if (n && len > l) {
		MCLGETI(n, wait, NULL, len);
		if ((n->m_flags & M_EXT) == 0) {
			m_free(n);
			n = NULL;
		}
	}
	if (!n)
		return (NULL);

	m_copydata(m, off, len, mtod(n, caddr_t));
	n->m_len = len;

	return (n);
}

/* Get a packet tag structure along with specified data following. */
struct m_tag *
m_tag_get(int type, int len, int wait)
{
	struct m_tag *t;

	if (len < 0)
		return (NULL);
	if (len > PACKET_TAG_MAXSIZE)
		panic("requested tag size for pool %#x is too big", type);
	t = pool_get(&mtagpool, wait == M_WAITOK ? PR_WAITOK : PR_NOWAIT);
	if (t == NULL)
		return (NULL);
	t->m_tag_id = type;
	t->m_tag_len = len;
	return (t);
}

/* Prepend a packet tag. */
void
m_tag_prepend(struct mbuf *m, struct m_tag *t)
{
	SLIST_INSERT_HEAD(&m->m_pkthdr.ph_tags, t, m_tag_link);
	m->m_pkthdr.ph_tagsset |= t->m_tag_id;
}

/* Unlink and free a packet tag. */
void
m_tag_delete(struct mbuf *m, struct m_tag *t)
{
	u_int32_t	 ph_tagsset = 0;
	struct m_tag	*p;

	SLIST_REMOVE(&m->m_pkthdr.ph_tags, t, m_tag, m_tag_link);
	pool_put(&mtagpool, t);

	SLIST_FOREACH(p, &m->m_pkthdr.ph_tags, m_tag_link)
		ph_tagsset |= p->m_tag_id;
	m->m_pkthdr.ph_tagsset = ph_tagsset;

}

/* Unlink and free a packet tag chain. */
void
m_tag_delete_chain(struct mbuf *m)
{
	struct m_tag *p;

	while ((p = SLIST_FIRST(&m->m_pkthdr.ph_tags)) != NULL) {
		SLIST_REMOVE_HEAD(&m->m_pkthdr.ph_tags, m_tag_link);
		pool_put(&mtagpool, p);
	}
	m->m_pkthdr.ph_tagsset = 0;
}

/* Find a tag, starting from a given position. */
struct m_tag *
m_tag_find(struct mbuf *m, int type, struct m_tag *t)
{
	struct m_tag *p;

	if (!(m->m_pkthdr.ph_tagsset & type))
		return (NULL);

	if (t == NULL)
		p = SLIST_FIRST(&m->m_pkthdr.ph_tags);
	else
		p = SLIST_NEXT(t, m_tag_link);
	while (p != NULL) {
		if (p->m_tag_id == type)
			return (p);
		p = SLIST_NEXT(p, m_tag_link);
	}
	return (NULL);
}

/* Copy a single tag. */
struct m_tag *
m_tag_copy(struct m_tag *t, int wait)
{
	struct m_tag *p;

	p = m_tag_get(t->m_tag_id, t->m_tag_len, wait);
	if (p == NULL)
		return (NULL);
	memcpy(p + 1, t + 1, t->m_tag_len); /* Copy the data */
	return (p);
}

/*
 * Copy two tag chains. The destination mbuf (to) loses any attached
 * tags even if the operation fails. This should not be a problem, as
 * m_tag_copy_chain() is typically called with a newly-allocated
 * destination mbuf.
 */
int
m_tag_copy_chain(struct mbuf *to, struct mbuf *from, int wait)
{
	struct m_tag *p, *t, *tprev = NULL;

	m_tag_delete_chain(to);
	SLIST_FOREACH(p, &from->m_pkthdr.ph_tags, m_tag_link) {
		t = m_tag_copy(p, wait);
		if (t == NULL) {
			m_tag_delete_chain(to);
			return (ENOBUFS);
		}
		if (tprev == NULL)
			SLIST_INSERT_HEAD(&to->m_pkthdr.ph_tags, t, m_tag_link);
		else
			SLIST_INSERT_AFTER(tprev, t, m_tag_link);
		tprev = t;
		to->m_pkthdr.ph_tagsset |= t->m_tag_id;
	}
	return (0);
}

/* Initialize tags on an mbuf. */
void
m_tag_init(struct mbuf *m)
{
	SLIST_INIT(&m->m_pkthdr.ph_tags);
}

/* Get first tag in chain. */
struct m_tag *
m_tag_first(struct mbuf *m)
{
	return (SLIST_FIRST(&m->m_pkthdr.ph_tags));
}

/* Get next tag in chain. */
struct m_tag *
m_tag_next(struct mbuf *m, struct m_tag *t)
{
	return (SLIST_NEXT(t, m_tag_link));
}
@


1.41
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.40 2014/12/11 19:21:57 tedu Exp $	*/
d275 2
a276 2
	SLIST_INSERT_HEAD(&m->m_pkthdr.tags, t, m_tag_link);
	m->m_pkthdr.tagsset |= t->m_tag_id;
d283 1
a283 1
	u_int32_t	 tagsset = 0;
d286 1
a286 1
	SLIST_REMOVE(&m->m_pkthdr.tags, t, m_tag, m_tag_link);
d289 3
a291 3
	SLIST_FOREACH(p, &m->m_pkthdr.tags, m_tag_link)
		tagsset |= p->m_tag_id;
	m->m_pkthdr.tagsset = tagsset;
d301 2
a302 2
	while ((p = SLIST_FIRST(&m->m_pkthdr.tags)) != NULL) {
		SLIST_REMOVE_HEAD(&m->m_pkthdr.tags, m_tag_link);
d305 1
a305 1
	m->m_pkthdr.tagsset = 0;
d314 1
a314 1
	if (!(m->m_pkthdr.tagsset & type))
d318 1
a318 1
		p = SLIST_FIRST(&m->m_pkthdr.tags);
d354 1
a354 1
	SLIST_FOREACH(p, &from->m_pkthdr.tags, m_tag_link) {
d361 1
a361 1
			SLIST_INSERT_HEAD(&to->m_pkthdr.tags, t, m_tag_link);
d365 1
a365 1
		to->m_pkthdr.tagsset |= t->m_tag_id;
d374 1
a374 1
	SLIST_INIT(&m->m_pkthdr.tags);
d381 1
a381 1
	return (SLIST_FIRST(&m->m_pkthdr.tags));
@


1.40
log
@convert bcopy to memcpy/memmove. ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.39 2014/09/14 14:17:26 jsg Exp $	*/
d178 1
a178 1
	 * now, we need to do the hard way.  don't m_copy as there's no room
@


1.39
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.38 2014/08/18 05:11:03 dlg Exp $	*/
d170 1
a170 1
		bcopy(mtod(n, caddr_t) + off, mtod(n->m_next, caddr_t), hlen);
d199 1
a199 1
	bcopy(mtod(n, caddr_t) + off, mtod(o, caddr_t), hlen);
d338 1
a338 1
	bcopy(t + 1, p + 1, t->m_tag_len); /* Copy the data */
@


1.38
log
@dont rely on mbuf.h to provide pool.h.

ok miod@@, who has offerred to help with any MD fallout
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.37 2013/06/11 01:01:15 dlg Exp $	*/
a66 1
#include <sys/proc.h>
@


1.37
log
@return ENOBUFS on failure from m_defrag and m_tag_copy_chain.

m_foo functions that return errors are now consistent as far as i can tell.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.36 2013/02/07 11:06:42 mikeb Exp $	*/
d69 1
@


1.36
log
@convert mbuf tags to use pool(9) as a backend storage;
ok markus claudio haesbaert henning
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.35 2011/11/30 10:26:56 dlg Exp $	*/
d358 1
a358 1
			return (ENOMEM);
@


1.35
log
@this diff introduces the MAXMCLBYTES macro to describe the largest
cluster the generic network stack will be able to give you.

it also recognises that external storage on an mbuf may be bigger than
MCLBYTES. its only when m_pullup or m_pulldown need to allocate
another cluster that they now check the len argument, and now they
do it against MAXMCLBYTES.

this is required for me to do pfsync on jumbo frames as the m_pulldown
for the subregions fail beyond MCLBYTES into the packet.

ok deraadt@@ mikeb@@ henning@@ blambert@@
manpage changes ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.34 2011/04/05 11:48:28 blambert Exp $	*/
d71 2
d261 3
a263 1
	t = malloc(sizeof(struct m_tag) + len, M_PACKET_TAGS, wait);
d287 1
a287 1
	free(t, M_PACKET_TAGS);
d303 1
a303 1
		free(p, M_PACKET_TAGS);
@


1.34
log
@Passing M_WAITOK to mbuf functions is supposed to be a contract between
the caller and the function that the function will not fail to allocate
memory and return a NULL pointer. However, m_dup_pkthdr() violates
this contract, making it possible for functions that pass M_WAITOK to
be surprised in ways that hurt.

Fix this by passing the wait flag all the way down the functions that
actually do the allocation for m_dup_pkthdr() so that we won't be
surprised.

man page update forthcoming

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.33 2011/01/29 13:15:39 bluhm Exp $	*/
a93 4
	if (len > MCLBYTES) {
		m_freem(m);
		return (NULL);	/* impossible */
	}
d179 4
d185 1
a185 1
		MCLGET(o, M_DONTWAIT);
d220 1
a220 1
	if (len > MCLBYTES)
d236 1
a236 1
		MCLGET(n, wait);
@


1.33
log
@The function m_tag_copy_chain() returned 0 on success and 1 on
failure.  The man page explained it the other way around.  Change
the return code to the more obvious 0 or ENOMEM and document this.
ok krw@@ markus@@ miod@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.32 2010/06/07 19:47:25 blambert Exp $	*/
d226 1
a226 1
		if (m_dup_pkthdr(n, m)) {
d327 1
a327 1
m_tag_copy(struct m_tag *t)
d331 1
a331 1
	p = m_tag_get(t->m_tag_id, t->m_tag_len, M_NOWAIT);
d345 1
a345 1
m_tag_copy_chain(struct mbuf *to, struct mbuf *from)
d351 1
a351 1
		t = m_tag_copy(p);
@


1.32
log
@Replace some handrolled instances of m_getptr() with that function, which
also gets a bit of a KNF scrubbing at claudio@@'s insistence. Shaves some
bytes from the kernel as well.

tested by phessler@@ and zinovnik@@, thanks

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.31 2009/09/13 14:42:52 krw Exp $	*/
d354 1
a354 1
			return (1);
@


1.31
log
@M_DUP_PKTHDR() define -> m_dup_pkthdr() function to properly deal
with m_tag_copy_chain() failures.

Use m_defrag() to eliminate hand rolled defragging of mbufs and
some uses of M_DUP_PKTHDR().

Original diff from thib@@, claudio@@'s feedback integrated by me.

Tests kevlo@@ claudio@@, "reads ok" blambert@@

ok thib@@ claudio@@, "m_defrag() bits ok" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.30 2009/08/09 12:50:09 henning Exp $	*/
d99 1
a99 11
	n = m;
	while (n != NULL && off > 0) {
		if (n->m_len > off)
			break;
		off -= n->m_len;
		n = n->m_next;
	}
	/* be sure to point non-empty mbuf */
	while (n != NULL && n->m_len == 0)
		n = n->m_next;
	if (!n) {
@


1.30
log
@make mbuf tags suck a bit less, performance wise.
the most common operation is checking for a particular tag to be there.
in the majority of the cases it is not.
introduce a "tagsset" in the mbuf packet header which has a bit for
each mbuf tag type that is in the chain set, checking for its existance
is now as easy and cheap as (tagsset & type) != 0. theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.29 2008/11/30 18:22:15 deraadt Exp $	*/
d236 4
a239 1
		M_DUP_PKTHDR(n, m);
d364 1
a364 1
			return (0);
d373 1
a373 1
	return (1);
@


1.29
log
@clarify allocation
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.28 2007/03/17 09:26:35 art Exp $	*/
d279 1
d286 3
d291 5
d308 1
d317 3
d368 1
@


1.28
log
@Since we're not always called with M_WAIT, check return value from
MGETHDR and fail if it's NULL.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.27 2007/02/26 20:15:33 claudio Exp $	*/
d266 1
a266 1
	t = malloc(len + sizeof(struct m_tag), M_PACKET_TAGS, wait);
@


1.27
log
@m_dup1() copies the packet header and allocates the mbuf cluster in the
wrong order. M_DUP_PKTHDR needs to be called with an empty mbuf.
Allocating an mbuf cluster beforehand is not allowed as the resulting mbuf is
no longer considered empty (part of the header is initialized).
The correct order is to allocate an mbuf via MGETHDR(), copy the packet header
and as last step allocate the cluster.
Issue found by JINMEI Tatuya.
OK canacar@@ deraadt@@ mglocker@@ additional input itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.26 2007/01/03 18:39:56 claudio Exp $	*/
d234 2
@


1.27.2.1
log
@Since we're not always called with M_WAIT, check return value from
MGETHDR and fail if it's NULL.

original patch art@@
original patch ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.27 2007/02/26 20:15:33 claudio Exp $	*/
a233 2
		if (n == NULL)
			return (NULL);
@


1.26
log
@Remove two "unused" mbuf tag functions and kill the superfluous argument
to the m_tag_delete_chain() function.
m_tag_free() and m_tag_unlink() are only used by m_tag_delete() and I see
no need to have these functions around.
m_tag_delete_chain() has a second argument to specifiy a starting point
from where the chain should be deleted. This feature is never used and is
more complex because it is not possible to remove a SLIST element without
doing a list walk. Instead use SLIST_FIRST() and SLIST_REMOVE_HEAD() to
remove all items from the list. OK dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.25 2006/11/18 08:20:51 jmc Exp $	*/
a228 1
	int copyhdr;
a232 1
		copyhdr = 1;
d234 1
a236 1
		copyhdr = 0;
a249 2
	if (copyhdr)
		M_DUP_PKTHDR(n, m);
@


1.25
log
@typos; from bret lambert
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.24 2006/03/17 04:15:51 brad Exp $	*/
a275 7
/* Free a packet tag. */
void
m_tag_free(struct m_tag *t)
{
	free(t, M_PACKET_TAGS);
}

a282 7
/* Unlink a packet tag. */
void
m_tag_unlink(struct mbuf *m, struct m_tag *t)
{
	SLIST_REMOVE(&m->m_pkthdr.tags, t, m_tag, m_tag_link);
}

d287 2
a288 2
	m_tag_unlink(m, t);
	m_tag_free(t);
d291 1
a291 1
/* Unlink and free a packet tag chain, starting from given tag. */
d293 1
a293 1
m_tag_delete_chain(struct mbuf *m, struct m_tag *t)
d295 1
a295 1
	struct m_tag *p, *q;
d297 4
a300 9
	if (t != NULL)
		p = t;
	else
		p = SLIST_FIRST(&m->m_pkthdr.tags);
	if (p == NULL)
		return;
	while ((q = SLIST_NEXT(p, m_tag_link)) != NULL)
		m_tag_delete(m, q);
	m_tag_delete(m, p);
d345 1
a345 1
	m_tag_delete_chain(to, NULL);
d349 1
a349 1
			m_tag_delete_chain(to, NULL);
@


1.24
log
@In m_pulldown avoid a prepend to the next mbuf in the chain if the result
would still not have all data we want continous.

From martin NetBSD

ok claudio@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.23 2006/01/05 05:05:06 jsg Exp $	*/
d75 1
a75 1
 * ensure that [off, off + len) is contiguous on the mbuf chain "m".
d191 1
a191 1
	 * on both end.
@


1.24.2.1
log
@Pull up from trunk (rev 1.27)
m_dup1() copies the packet header and allocates the mbuf cluster in the
wrong order. M_DUP_PKTHDR needs to be called with an empty mbuf.
Allocating an mbuf cluster beforehand is not allowed as the resulting mbuf is
no longer considered empty (part of the header is initialized).
The correct order is to allocate an mbuf via MGETHDR(), copy the packet header
and as last step allocate the cluster.
Issue found by JINMEI Tatuya.
OK canacar@@ deraadt@@ mglocker@@ additional input itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.27 2007/02/26 20:15:33 claudio Exp $	*/
d229 1
d234 1
a235 1
		M_DUP_PKTHDR(n, m);
d238 1
d252 2
@


1.24.2.2
log
@MFC (art@@), requested by deraadt
Since we're not always called with M_WAIT, check return value from
MGETHDR and fail if it's NULL.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.28 2007/03/17 09:26:35 art Exp $	*/
a233 2
		if (n == NULL)
			return (NULL);
@


1.23
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.22 2004/07/22 09:33:21 itojun Exp $	*/
d179 1
a179 1
	    !sharedcluster) {
@


1.23.2.1
log
@Pull up from trunk (rev 1.27)
m_dup1() copies the packet header and allocates the mbuf cluster in the
wrong order. M_DUP_PKTHDR needs to be called with an empty mbuf.
Allocating an mbuf cluster beforehand is not allowed as the resulting mbuf is
no longer considered empty (part of the header is initialized).
The correct order is to allocate an mbuf via MGETHDR(), copy the packet header
and as last step allocate the cluster.
Issue found by JINMEI Tatuya.
OK canacar@@ deraadt@@ mglocker@@ additional input itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.27 2007/02/26 20:15:33 claudio Exp $	*/
d229 1
d234 1
a235 1
		M_DUP_PKTHDR(n, m);
d238 1
d252 2
@


1.23.2.2
log
@MFC (art@@), requested by deraadt
Since we're not always called with M_WAIT, check return value from
MGETHDR and fail if it's NULL.
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.28 2007/03/17 09:26:35 art Exp $	*/
a233 2
		if (n == NULL)
			return (NULL);
@


1.22
log
@fix cases when m_dup1() returned mbuf chain (instead of single mbuf).
yamt@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.21 2003/06/02 23:28:06 millert Exp $	*/
d85 1
a85 4
m_pulldown(m, off, len, offp)
	struct mbuf *m;
	int off, len;
	int *offp;
d225 1
a225 5
m_dup1(m, off, len, wait)
	struct mbuf *m;
	int off;
	int len;
	int wait;
d262 1
a262 4
m_tag_get(type, len, wait)
	int type;
	int len;
	int wait;
d278 1
a278 2
m_tag_free(t)
	struct m_tag *t;
d285 1
a285 3
m_tag_prepend(m, t)
	struct mbuf *m;
	struct m_tag *t;
d292 1
a292 3
m_tag_unlink(m, t)
	struct mbuf *m;
	struct m_tag *t;
d299 1
a299 3
m_tag_delete(m, t)
	struct mbuf *m;
	struct m_tag *t;
d307 1
a307 3
m_tag_delete_chain(m, t)
	struct mbuf *m;
	struct m_tag *t;
d324 1
a324 4
m_tag_find(m, type, t)
	struct mbuf *m;
	int type;
	struct m_tag *t;
d342 1
a342 2
m_tag_copy(t)
	struct m_tag *t;
d360 1
a360 3
m_tag_copy_chain(to, from)
	struct mbuf *to;
	struct mbuf *from;
d382 1
a382 2
m_tag_init(m)
	struct mbuf *m;
d389 1
a389 2
m_tag_first(m)
	struct mbuf *m;
d396 1
a396 3
m_tag_next(m, t)
	struct mbuf *m;
	struct m_tag *t;
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.20 2003/03/03 12:53:57 itojun Exp $	*/
d133 2
d140 2
d143 1
a143 1
		o->m_next = n->m_next;
d145 1
a145 1
		n = n->m_next;
@


1.20
log
@set n->m_len, somehow the line have lost.  thanks daniel
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.19 2003/03/03 12:08:30 itojun Exp $	*/
d46 1
a46 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@use M_READONLY instead of defining M_SHAREDCLUSTER().  the change should have
been made when M_READONLY was introduced.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.18 2002/10/10 10:38:13 kjc Exp $	*/
d262 2
@


1.18
log
@preserve the m_tag order in m_tag_copy_chain() as originally intended.
the order doesn't matter at this moment but could be problematic
if 2 tags of the same type are ever added.

ok jason@@, dhartmei@@, angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.17 2002/03/14 01:27:05 millert Exp $	*/
a74 4
#define M_SHAREDCLUSTER(m) \
	(((m)->m_flags & M_EXT) != 0 && \
	 ((m)->m_ext.ext_free || MCLISREFERENCED((m))))

d121 1
a121 1
	sharedcluster = M_SHAREDCLUSTER(n);
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.16 2002/02/01 15:36:29 art Exp $	*/
d400 1
a400 1
		else {
d402 1
a402 2
			tprev = t;
		}
@


1.16
log
@Don't MALLOC/FREE with variable size.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.15 2001/06/23 04:39:33 angelos Exp $	*/
d80 1
a80 1
static struct mbuf *m_dup1 __P((struct mbuf *, int, int, int));
@


1.15
log
@Having to update queue(3) for DLIST_* is a major PITA; thus, just use
SLIST and be done with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.14 2001/06/23 03:57:48 angelos Exp $	*/
d280 1
a280 2
	MALLOC(t, struct m_tag *, len + sizeof(struct m_tag), M_PACKET_TAGS,
	    wait);
d293 1
a293 1
	FREE(t, M_PACKET_TAGS);
@


1.15.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.15 2001/06/23 04:39:33 angelos Exp $	*/
d80 1
a80 1
static struct mbuf *m_dup1(struct mbuf *, int, int, int);
d280 2
a281 1
	t = malloc(len + sizeof(struct m_tag), M_PACKET_TAGS, wait);
d294 1
a294 1
	free(t, M_PACKET_TAGS);
@


1.15.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.15.4.1 2002/06/11 03:29:40 art Exp $	*/
d400 1
a400 1
		else
d402 2
a403 1
		tprev = t;
@


1.15.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 4
d125 1
a125 1
	sharedcluster = M_READONLY(n);
a265 2
	n->m_len = len;

@


1.14
log
@Use DLIST for tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.13 2001/05/27 00:38:25 angelos Exp $	*/
d303 1
a303 1
	DLIST_INSERT_HEAD(&m->m_pkthdr.tags, t, m_tag_link);
d312 1
a312 1
	DLIST_REMOVE(&m->m_pkthdr.tags, t, m_tag_link);
d336 1
a336 1
		p = DLIST_FIRST(&m->m_pkthdr.tags);
d339 1
a339 1
	while ((q = DLIST_NEXT(p, m_tag_link)) != NULL)
d354 1
a354 1
		p = DLIST_FIRST(&m->m_pkthdr.tags);
d356 1
a356 1
		p = DLIST_NEXT(t, m_tag_link);
d360 1
a360 1
		p = DLIST_NEXT(p, m_tag_link);
d393 1
a393 1
	DLIST_FOREACH(p, &from->m_pkthdr.tags, m_tag_link) {
d400 1
a400 1
			DLIST_INSERT_HEAD(&to->m_pkthdr.tags, t, m_tag_link);
d402 1
a402 1
			DLIST_INSERT_AFTER(tprev, t, m_tag_link);
d414 1
a414 1
	DLIST_INIT(&m->m_pkthdr.tags);
d422 1
a422 1
	return (DLIST_FIRST(&m->m_pkthdr.tags));
d431 1
a431 1
	return (DLIST_NEXT(t, m_tag_link));
@


1.13
log
@m_tag_first()/m_tag_next()
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.12 2001/05/26 07:00:02 angelos Exp $	*/
d303 1
a303 1
	LIST_INSERT_HEAD(&m->m_pkthdr.tags, t, m_tag_link);
d312 1
a312 1
	LIST_REMOVE(t, m_tag_link);
d336 1
a336 1
		p = LIST_FIRST(&m->m_pkthdr.tags);
d339 1
a339 1
	while ((q = LIST_NEXT(p, m_tag_link)) != NULL)
d354 1
a354 1
		p = LIST_FIRST(&m->m_pkthdr.tags);
d356 1
a356 1
		p = LIST_NEXT(t, m_tag_link);
d360 1
a360 1
		p = LIST_NEXT(p, m_tag_link);
d393 1
a393 1
	LIST_FOREACH(p, &from->m_pkthdr.tags, m_tag_link) {
d400 1
a400 1
			LIST_INSERT_HEAD(&to->m_pkthdr.tags, t, m_tag_link);
d402 1
a402 1
			LIST_INSERT_AFTER(tprev, t, m_tag_link);
d414 1
a414 1
	LIST_INIT(&m->m_pkthdr.tags);
d422 1
a422 1
	return (LIST_FIRST(&m->m_pkthdr.tags));
d431 1
a431 1
	return (LIST_NEXT(t, m_tag_link));
@


1.12
log
@Convert to LIST, remove m_tag_append(), add m_tag_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.11 2001/05/24 19:04:51 angelos Exp $	*/
d415 17
@


1.11
log
@More DIAGNOSTIC checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.10 2001/05/24 18:47:21 angelos Exp $	*/
d303 1
a303 10
	TAILQ_INSERT_HEAD(&m->m_pkthdr.tags, t, m_tag_link);
}

/* Append a packet tag. */
void
m_tag_append(m, t)
	struct mbuf *m;
	struct m_tag *t;
{
	TAILQ_INSERT_TAIL(&m->m_pkthdr.tags, t, m_tag_link);
d312 1
a312 1
	TAILQ_REMOVE(&m->m_pkthdr.tags, t, m_tag_link);
d331 1
a331 1
	struct m_tag *p;
d333 5
a337 10
#ifdef DIAGNOSTIC
	if ((m->m_flags & M_PKTHDR) == 0)
		printf("m_tag_delete_chain: non packet header mbuf %p give to us\n", m);

	if (m->m_pkthdr.tags.tqh_last == NULL ||
	    (m->m_pkthdr.tags.tqh_first == NULL &&
	    m->m_pkthdr.tags.tqh_last != &m->m_pkthdr.tags.tqh_first)) {
		printf("m_tag_delete_chain: uninitialized tags on mbuf %p\n",
		       m);
		TAILQ_INIT(&m->m_pkthdr.tags);
d339 3
a341 8
	}
#endif

	while ((p = TAILQ_LAST(&m->m_pkthdr.tags, packet_tags)) != NULL) {
		m_tag_delete(m, p);
		if (t != NULL && p == t)
			return;
	}
d354 1
a354 1
		p = TAILQ_FIRST(&m->m_pkthdr.tags);
d356 1
a356 1
		p = TAILQ_NEXT(t, m_tag_link);
d360 1
a360 1
		p = TAILQ_NEXT(p, m_tag_link);
d390 1
a390 1
	struct m_tag *p, *t;
d393 1
a393 1
	TAILQ_FOREACH(p, &from->m_pkthdr.tags, m_tag_link) {
d399 6
a404 1
		m_tag_append(to, t);
d407 8
@


1.10
log
@Catch another weird case in diagnostics.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.9 2001/05/22 20:22:22 angelos Exp $	*/
d342 4
a345 1
	/* Be a bit paranoid */
a348 1
#ifdef DIAGNOSTIC
a350 1
#endif
d354 2
@


1.9
log
@Do some ideally unneeded checking of tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.8 2001/05/20 08:31:47 angelos Exp $	*/
d343 3
a345 1
	if (m->m_pkthdr.tags.tqh_last == NULL) {
@


1.8
log
@m_tag_* routines, plus minor changes (convert from tdbi to tags)
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.7 2001/05/17 18:41:45 provos Exp $	*/
d342 9
@


1.7
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.6 2001/03/28 20:03:00 angelos Exp $	*/
d107 1
a107 1
		return NULL;	/* impossible */
d122 1
a122 1
		return NULL;	/* mbuf chain too short */
d144 1
a144 1
			return NULL;	/* ENOBUFS */
d171 1
a171 1
		return NULL;	/* mbuf chain too short */
d210 1
a210 1
		return NULL;	/* ENOBUFS */
d228 1
a228 1
	return n;
d243 1
a243 1
		return NULL;
d261 1
a261 1
		return NULL;
d266 141
a406 1
	return n;
@


1.6
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.5 2001/02/14 17:04:34 itojun Exp $	*/
d77 1
a77 1
	 ((m)->m_ext.ext_free || mclrefcnt[mtocl((m)->m_ext.ext_buf)] > 1))
@


1.6.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.6 2001/03/28 20:03:00 angelos Exp $	*/
@


1.6.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.6.4.1 2001/05/14 22:32:45 niklas Exp $	*/
d77 1
a77 1
	 ((m)->m_ext.ext_free || MCLISREFERENCED((m))))
d107 1
a107 1
		return (NULL);	/* impossible */
d122 1
a122 1
		return (NULL);	/* mbuf chain too short */
d144 1
a144 1
			return (NULL);	/* ENOBUFS */
d171 1
a171 1
		return (NULL);	/* mbuf chain too short */
d210 1
a210 1
		return (NULL);	/* ENOBUFS */
d228 1
a228 1
	return (n);
d243 1
a243 1
		return (NULL);
d261 1
a261 1
		return (NULL);
d266 1
a266 166
	return (n);
}

/* Get a packet tag structure along with specified data following. */
struct m_tag *
m_tag_get(type, len, wait)
	int type;
	int len;
	int wait;
{
	struct m_tag *t;

	if (len < 0)
		return (NULL);
	MALLOC(t, struct m_tag *, len + sizeof(struct m_tag), M_PACKET_TAGS,
	    wait);
	if (t == NULL)
		return (NULL);
	t->m_tag_id = type;
	t->m_tag_len = len;
	return (t);
}

/* Free a packet tag. */
void
m_tag_free(t)
	struct m_tag *t;
{
	FREE(t, M_PACKET_TAGS);
}

/* Prepend a packet tag. */
void
m_tag_prepend(m, t)
	struct mbuf *m;
	struct m_tag *t;
{
	SLIST_INSERT_HEAD(&m->m_pkthdr.tags, t, m_tag_link);
}

/* Unlink a packet tag. */
void
m_tag_unlink(m, t)
	struct mbuf *m;
	struct m_tag *t;
{
	SLIST_REMOVE(&m->m_pkthdr.tags, t, m_tag, m_tag_link);
}

/* Unlink and free a packet tag. */
void
m_tag_delete(m, t)
	struct mbuf *m;
	struct m_tag *t;
{
	m_tag_unlink(m, t);
	m_tag_free(t);
}

/* Unlink and free a packet tag chain, starting from given tag. */
void
m_tag_delete_chain(m, t)
	struct mbuf *m;
	struct m_tag *t;
{
	struct m_tag *p, *q;

	if (t != NULL)
		p = t;
	else
		p = SLIST_FIRST(&m->m_pkthdr.tags);
	if (p == NULL)
		return;
	while ((q = SLIST_NEXT(p, m_tag_link)) != NULL)
		m_tag_delete(m, q);
	m_tag_delete(m, p);
}

/* Find a tag, starting from a given position. */
struct m_tag *
m_tag_find(m, type, t)
	struct mbuf *m;
	int type;
	struct m_tag *t;
{
	struct m_tag *p;

	if (t == NULL)
		p = SLIST_FIRST(&m->m_pkthdr.tags);
	else
		p = SLIST_NEXT(t, m_tag_link);
	while (p != NULL) {
		if (p->m_tag_id == type)
			return (p);
		p = SLIST_NEXT(p, m_tag_link);
	}
	return (NULL);
}

/* Copy a single tag. */
struct m_tag *
m_tag_copy(t)
	struct m_tag *t;
{
	struct m_tag *p;

	p = m_tag_get(t->m_tag_id, t->m_tag_len, M_NOWAIT);
	if (p == NULL)
		return (NULL);
	bcopy(t + 1, p + 1, t->m_tag_len); /* Copy the data */
	return (p);
}

/*
 * Copy two tag chains. The destination mbuf (to) loses any attached
 * tags even if the operation fails. This should not be a problem, as
 * m_tag_copy_chain() is typically called with a newly-allocated
 * destination mbuf.
 */
int
m_tag_copy_chain(to, from)
	struct mbuf *to;
	struct mbuf *from;
{
	struct m_tag *p, *t, *tprev = NULL;

	m_tag_delete_chain(to, NULL);
	SLIST_FOREACH(p, &from->m_pkthdr.tags, m_tag_link) {
		t = m_tag_copy(p);
		if (t == NULL) {
			m_tag_delete_chain(to, NULL);
			return (0);
		}
		if (tprev == NULL)
			SLIST_INSERT_HEAD(&to->m_pkthdr.tags, t, m_tag_link);
		else {
			SLIST_INSERT_AFTER(tprev, t, m_tag_link);
			tprev = t;
		}
	}
	return (1);
}

/* Initialize tags on an mbuf. */
void
m_tag_init(m)
	struct mbuf *m;
{
	SLIST_INIT(&m->m_pkthdr.tags);
}

/* Get first tag in chain. */
struct m_tag *
m_tag_first(m)
	struct mbuf *m;
{
	return (SLIST_FIRST(&m->m_pkthdr.tags));
}

/* Get next tag in chain. */
struct m_tag *
m_tag_next(m, t)
	struct mbuf *m;
	struct m_tag *t;
{
	return (SLIST_NEXT(t, m_tag_link));
@


1.6.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d280 2
a281 1
	t = malloc(len + sizeof(struct m_tag), M_PACKET_TAGS, wait);
d294 1
a294 1
	free(t, M_PACKET_TAGS);
@


1.6.4.4
log
@Merge in -current from about a week ago
@
text
@d80 1
a80 1
static struct mbuf *m_dup1(struct mbuf *, int, int, int);
@


1.6.4.5
log
@Sync the SMP branch with 3.3
@
text
@d75 4
d125 1
a125 1
	sharedcluster = M_READONLY(n);
a265 2
	n->m_len = len;

d400 1
a400 1
		else
d402 2
a403 1
		tprev = t;
@


1.6.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.6.4.5 2003/03/28 00:41:27 niklas Exp $	*/
d46 5
a50 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5
log
@make sure we do not pass shared M_EXT mbuf.  will avoid
possible shared mbuf overwrite if we use bridge/multicast/loopback/whatever.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_mbuf2.c,v 1.4 2000/07/12 16:41:30 itojun Exp $	*/
d264 1
a264 1
		M_COPY_PKTHDR(n, m);
@


1.4
log
@remove m_pulldown statistics, which is highly experimental
@
text
@d1 2
a2 2
/*	$OpenBSD: uipc_mbuf2.c,v 1.3 2000/06/12 17:24:27 itojun Exp $	*/
/*	$KAME: uipc_mbuf2.c,v 1.15 2000/02/22 14:01:37 itojun Exp $	*/
a68 2
/*#define PULLDOWN_DEBUG*/

d75 7
a109 9
#ifdef PULLDOWN_DEBUG
    {
	struct mbuf *t;
	printf("before:");
	for (t = m; t; t = t->m_next)
		printf(" %d", t->m_len);
	printf("\n");
    }
#endif
d125 2
d131 1
a131 1
	if ((off == 0 || offp) && len <= n->m_len - off)
d135 1
a135 1
	 * when len < n->m_len - off and off != 0, it is a special case.
d140 2
a141 2
	if (len < n->m_len - off) {
		o = m_copym(n, off, n->m_len - off, M_DONTWAIT);
d178 2
a179 12
	if ((n->m_flags & M_EXT) == 0)
		sharedcluster = 0;
	else {
		if (n->m_ext.ext_free)
			sharedcluster = 1;
		else if (mclrefcnt[mtocl(n->m_ext.ext_buf)] > 1)
			sharedcluster = 1;
		else
			sharedcluster = 0;
	}
	if ((off == 0 || offp) && M_TRAILINGSPACE(n) >= tlen
	 && !sharedcluster) {
d185 2
a186 2
	if ((off == 0 || offp) && M_LEADINGSPACE(n->m_next) >= hlen
	 && !sharedcluster) {
d201 1
a201 5
	if (o == NULL) {
		m_freem(m);
		return NULL;	/* ENOBUFS */
	}
	if (len > MHLEN) {	/* use MHLEN just for safety */
a203 1
			m_freem(m);
d205 1
a205 1
			return NULL;	/* ENOBUFS */
d208 4
a225 9
#ifdef PULLDOWN_DEBUG
    {
	struct mbuf *t;
	printf("after:");
	for (t = m; t; t = t->m_next)
		printf("%c%d", t == n ? '*' : ' ', t->m_len);
	printf(" (off=%d)\n", off);
    }
#endif
d228 38
@


1.3
log
@update icmp6 name lookup code to conform to 05 draft.  previous code
was 03/05 chimera.

ping6: -n by default due to too many false error report due to too long
reverse query delay.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a68 1
#define PULLDOWN_STAT
a75 5
#if defined(PULLDOWN_STAT) && defined(INET6)
#include <netinet/in.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#endif
a95 4
#if defined(PULLDOWN_STAT) && defined(INET6)
	static struct mbuf *prev = NULL;
	int prevlen = 0, prevmlen = 0;
#endif
a104 66
#if defined(PULLDOWN_STAT) && defined(INET6)
	ip6stat.ip6s_pulldown++;
#endif

#if defined(PULLDOWN_STAT) && defined(INET6)
	/* statistics for m_pullup */
	ip6stat.ip6s_pullup++;
	if (off + len > MHLEN)
		ip6stat.ip6s_pullup_fail++;
	else {
		int dlen, mlen;

		dlen = (prev == m) ? prevlen : m->m_len;
		mlen = (prev == m) ? prevmlen : m->m_len + M_TRAILINGSPACE(m);

		if (dlen >= off + len)
			ip6stat.ip6s_pullup--; /* call will not be made! */
		else if ((m->m_flags & M_EXT) != 0) {
			ip6stat.ip6s_pullup_alloc++;
			ip6stat.ip6s_pullup_copy++;
		} else {
			if (mlen >= off + len)
				ip6stat.ip6s_pullup_copy++;
			else {
				ip6stat.ip6s_pullup_alloc++;
				ip6stat.ip6s_pullup_copy++;
			}
		}

		prevlen = off + len;
		prevmlen = MHLEN;
	}

	/* statistics for m_pullup2 */
	ip6stat.ip6s_pullup2++;
	if (off + len > MCLBYTES)
		ip6stat.ip6s_pullup2_fail++;
	else {
		int dlen, mlen;

		dlen = (prev == m) ? prevlen : m->m_len;
		mlen = (prev == m) ? prevmlen : m->m_len + M_TRAILINGSPACE(m);
		prevlen = off + len;
		prevmlen = mlen;

		if (dlen >= off + len)
			ip6stat.ip6s_pullup2--; /* call will not be made! */
		else if ((m->m_flags & M_EXT) != 0) {
			ip6stat.ip6s_pullup2_alloc++;
			ip6stat.ip6s_pullup2_copy++;
			prevmlen = (off + len > MHLEN) ? MCLBYTES : MHLEN;
		} else {
			if (mlen >= off + len)
				ip6stat.ip6s_pullup2_copy++;
			else {
				ip6stat.ip6s_pullup2_alloc++;
				ip6stat.ip6s_pullup2_copy++;
				prevmlen = (off + len > MHLEN) ? MCLBYTES
							       : MHLEN;
			}
		}
	}

	prev = m;
#endif

a135 4
#if defined(PULLDOWN_STAT) && defined(INET6)
	ip6stat.ip6s_pulldown_copy++;
#endif

a211 3
#if defined(PULLDOWN_STAT) && defined(INET6)
	ip6stat.ip6s_pulldown_alloc++;
#endif
@


1.2
log
@Remove unused file. If we end up using m_pulldown() in the future, it
should be added to uipc_mbuf.c
@
text
@d1 2
a71 6
#ifdef PULLDOWN_STAT
#if defined(__NetBSD__) || (defined(__FreeBSD__) && __FreeBSD__ >= 3)
#include "opt_inet.h"
#endif
#endif

d79 1
a79 1
#include <netinet6/ip6.h>
d102 4
d119 62
d197 3
a262 3
#ifdef __bsdi__
		if (n->m_ext.ext_func)
#else
a263 1
#endif
a264 3
#ifdef __NetBSD__
		else if (MCLISREFERENCED(n))
#else
a265 1
#endif
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@@

