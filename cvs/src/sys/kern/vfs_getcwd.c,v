head	1.26;
access;
symbols
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.18.0.6
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.4
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.17.0.6
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9;
locks; strict;
comment	@ * @;


1.26
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.25;
commitid	gAjwyca5TfuoJAhn;

1.25
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.24;
commitid	p4LJxGKbi0BU2cG6;

1.24
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.23;
commitid	P6Av4XGqOi3rFasL;

1.23
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	3SGDR5EjcwE01W8S;

1.22
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.21;
commitid	QlVV51SZgNFxsXxC;

1.21
date	2013.08.13.05.52.24;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2013.06.09.13.15.26;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2013.06.09.12.43.57;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2011.12.09.16.14.54;	author nicm;	state Exp;
branches;
next	1.17;

1.17
date	2010.05.19.08.31.23;	author thib;	state Exp;
branches;
next	1.16;

1.16
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.14;

1.14
date	2009.04.17.15.17.27;	author blambert;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.20;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.07.07.41.59;	author thib;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.30.04.27.42;	author beck;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.29.05.28.53;	author beck;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.17.12.52.12;	author pedro;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.01.21.50.48;	author pedro;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.01.21.08.44;	author pedro;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.01.20.03.06;	author pedro;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.30.01.03.51;	author pedro;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.30.00.34.34;	author pedro;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.30.00.08.13;	author pedro;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.29.21.31.15;	author pedro;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.28.08.34.31;	author pedro;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@/* $OpenBSD: vfs_getcwd.c,v 1.25 2015/03/14 03:38:51 jsg Exp $ */
/* $NetBSD: vfs_getcwd.c,v 1.3.2.3 1999/07/11 10:24:09 sommerfeld Exp $ */

/*
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Bill Sommerfeld.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/filedesc.h>
#include <sys/kernel.h>
#include <sys/stat.h>
#include <sys/lock.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/dirent.h>
#include <ufs/ufs/dir.h>	/* only for DIRBLKSIZ */

#include <sys/syscallargs.h>


/* Find parent vnode of *lvpp, return in *uvpp */
int
vfs_getcwd_scandir(struct vnode **lvpp, struct vnode **uvpp, char **bpp,
    char *bufp, struct proc *p)
{
	int eofflag, tries, dirbuflen, len, reclen, error = 0;
	off_t off;
	struct uio uio;
	struct iovec iov;
	char *dirbuf = NULL;
	ino_t fileno;
	struct vattr va;
	struct vnode *uvp = NULL;
	struct vnode *lvp = *lvpp;	
	struct componentname cn;

	tries = 0;

	/*
	 * If we want the filename, get some info we need while the
	 * current directory is still locked.
	 */
	if (bufp != NULL) {
		error = VOP_GETATTR(lvp, &va, p->p_ucred, p);
		if (error) {
			vput(lvp);
			*lvpp = NULL;
			*uvpp = NULL;
			return (error);
		}
	}

	cn.cn_nameiop = LOOKUP;
	cn.cn_flags = ISLASTCN | ISDOTDOT | RDONLY;
	cn.cn_proc = p;
	cn.cn_cred = p->p_ucred;
	cn.cn_pnbuf = NULL;
	cn.cn_nameptr = "..";
	cn.cn_namelen = 2;
	cn.cn_consume = 0;

	/* Get parent vnode using lookup of '..' */
	error = VOP_LOOKUP(lvp, uvpp, &cn);
	if (error) {
		vput(lvp);
		*lvpp = NULL;
		*uvpp = NULL;
		return (error);
	}

	uvp = *uvpp;

	/* If we don't care about the pathname, we're done */
	if (bufp == NULL) {
		vrele(lvp);
		*lvpp = NULL;
		return (0);
	}

	fileno = va.va_fileid;

	dirbuflen = DIRBLKSIZ;

	if (dirbuflen < va.va_blocksize)
		dirbuflen = va.va_blocksize;

	dirbuf = malloc(dirbuflen, M_TEMP, M_WAITOK);

	off = 0;

	do {
		char   *cpos;
		struct dirent *dp;

		iov.iov_base = dirbuf;
		iov.iov_len = dirbuflen;

		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = off;
		uio.uio_resid = dirbuflen;
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_READ;
		uio.uio_procp = p;

		eofflag = 0;

		/* Call VOP_READDIR of parent */
		error = VOP_READDIR(uvp, &uio, p->p_ucred, &eofflag);

		off = uio.uio_offset;

		/* Try again if NFS tosses its cookies */
		if (error == EINVAL && tries < 3) {
			tries++;
			off = 0;
			continue;
		} else if (error) {
			goto out; /* Old userland getcwd() behaviour */
		}

		cpos = dirbuf;
		tries = 0;

		/* Scan directory page looking for matching vnode */ 
		for (len = (dirbuflen - uio.uio_resid); len > 0;
		     len -= reclen) {
			dp = (struct dirent *)cpos;
			reclen = dp->d_reclen;

			/* Check for malformed directory */
			if (reclen < DIRENT_RECSIZE(1)) {
				error = EINVAL;
				goto out;
			}

			if (dp->d_fileno == fileno) {
				char *bp = *bpp;
				bp -= dp->d_namlen;

				if (bp <= bufp) {
					error = ERANGE;
					goto out;
				}

				memmove(bp, dp->d_name, dp->d_namlen);
				error = 0;
				*bpp = bp;

				goto out;
			}

			cpos += reclen;
		}

	} while (!eofflag);

	error = ENOENT;

out:

	vrele(lvp);
	*lvpp = NULL;

	free(dirbuf, M_TEMP, dirbuflen);

	return (error);
}

/* Do a lookup in the vnode-to-name reverse */
int
vfs_getcwd_getcache(struct vnode **lvpp, struct vnode **uvpp, char **bpp,
    char *bufp)
{
	struct vnode *lvp, *uvp = NULL;
	struct proc *p = curproc;
	char *obp;
	int error, vpid;

	lvp = *lvpp;
	obp = *bpp;	/* Save original position to restore to on error */

	error = cache_revlookup(lvp, uvpp, bpp, bufp);
	if (error) {
		if (error != -1) {
			vput(lvp);
			*lvpp = NULL;
			*uvpp = NULL;
		}

		return (error);
	}

	uvp = *uvpp;
	vpid = uvp->v_id;


	/* Release current lock before acquiring the parent lock */
	VOP_UNLOCK(lvp, p);

	error = vget(uvp, LK_EXCLUSIVE | LK_RETRY, p);
	if (error)
		*uvpp = NULL;

	/*
	 * Verify that vget() succeeded, and check that vnode capability
	 * didn't change while we were waiting for the lock.
	 */
	if (error || (vpid != uvp->v_id)) {
		/*
		 * Try to get our lock back. If that works, tell the caller to
		 * try things the hard way, otherwise give up.
		 */
		if (!error)
			vput(uvp);

		*uvpp = NULL;
		
		error = vn_lock(lvp, LK_EXCLUSIVE | LK_RETRY, p);
		if (!error) {
			*bpp = obp; /* restore the buffer */
			return (-1);
		}
	}

	vrele(lvp);
	*lvpp = NULL;

	return (error);
}

/* Common routine shared by sys___getcwd() and vn_isunder() */
int
vfs_getcwd_common(struct vnode *lvp, struct vnode *rvp, char **bpp, char *bufp,
    int limit, int flags, struct proc *p)
{
	struct filedesc *fdp = p->p_fd;
	struct vnode *uvp = NULL;
	char *bp = NULL;
	int error, perms = VEXEC;

	if (rvp == NULL) {
		rvp = fdp->fd_rdir;
		if (rvp == NULL)
			rvp = rootvnode;
	}

	vref(rvp);
	vref(lvp);

	error = vn_lock(lvp, LK_EXCLUSIVE | LK_RETRY, p);
	if (error) {
		vrele(lvp);
		lvp = NULL;
		goto out;
	}

	if (bufp)
		bp = *bpp;

	if (lvp == rvp) {
		if (bp)
			*(--bp) = '/';
		goto out;
	}

	/*
	 * This loop will terminate when we hit the root, VOP_READDIR() or
	 * VOP_LOOKUP() fails, or we run out of space in the user buffer.
	 */
	do {
		if (lvp->v_type != VDIR) {
			error = ENOTDIR;
			goto out;
		}

		/* Check for access if caller cares */
		if (flags & GETCWD_CHECK_ACCESS) {
			error = VOP_ACCESS(lvp, perms, p->p_ucred, p);
			if (error)
				goto out;
			perms = VEXEC|VREAD;
		}

		/* Step up if we're a covered vnode */
		while (lvp->v_flag & VROOT) {
			struct vnode *tvp;

			if (lvp == rvp)
				goto out;
			
			tvp = lvp;
			lvp = lvp->v_mount->mnt_vnodecovered;

			vput(tvp);

			if (lvp == NULL) {
				error = ENOENT;
				goto out;
			}

			vref(lvp);

			error = vn_lock(lvp, LK_EXCLUSIVE | LK_RETRY, p);
			if (error) {
				vrele(lvp);
				lvp = NULL;
				goto out;
			}
		}

		/* Look in the name cache */
		error = vfs_getcwd_getcache(&lvp, &uvp, &bp, bufp);

		if (error == -1) {
			/* If that fails, look in the directory */
			error = vfs_getcwd_scandir(&lvp, &uvp, &bp, bufp, p);
		}

		if (error)
			goto out;

#ifdef DIAGNOSTIC
		if (lvp != NULL)
			panic("getcwd: oops, forgot to null lvp");
		if (bufp && (bp <= bufp)) {
			panic("getcwd: oops, went back too far");
		}
#endif

		if (bp)
			*(--bp) = '/';

		lvp = uvp;
		uvp = NULL;
		limit--;

	} while ((lvp != rvp) && (limit > 0)); 

out:

	if (bpp)
		*bpp = bp;

	if (uvp)
		vput(uvp);

	if (lvp)
		vput(lvp);

	vrele(rvp);

	return (error);
}

/* Find pathname of a process's current directory */
int
sys___getcwd(struct proc *p, void *v, register_t *retval) 
{
	struct sys___getcwd_args *uap = v;
	int error, lenused, len = SCARG(uap, len);
	char *path, *bp, *bend;

	if (len > MAXPATHLEN * 4)
		len = MAXPATHLEN * 4;
	else if (len < 2)
		return (ERANGE);

	path = malloc(len, M_TEMP, M_WAITOK);

	bp = &path[len];
	bend = bp;
	*(--bp) = '\0';

	/*
	 * 5th argument here is "max number of vnodes to traverse".
	 * Since each entry takes up at least 2 bytes in the output
	 * buffer, limit it to N/2 vnodes for an N byte buffer.
	 */
	error = vfs_getcwd_common(p->p_fd->fd_cdir, NULL, &bp, path, len/2,
	    GETCWD_CHECK_ACCESS, p);

	if (error)
		goto out;

	lenused = bend - bp;
	*retval = lenused;

	/* Put the result into user buffer */
	error = copyout(bp, SCARG(uap, buf), lenused);

out:
	free(path, M_TEMP, len);

	return (error);
}
@


1.25
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.24 2014/12/16 18:30:04 tedu Exp $ */
d229 1
a229 1
	VOP_UNLOCK(lvp, 0, p);
@


1.24
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.23 2014/11/03 03:08:00 deraadt Exp $ */
a37 1
#include <sys/file.h>
@


1.23
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.22 2014/07/12 18:43:32 tedu Exp $ */
d40 1
@


1.22
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.21 2013/08/13 05:52:24 guenther Exp $ */
d195 1
a195 1
	free(dirbuf, M_TEMP, 0);
d423 1
a423 1
	free(path, M_TEMP, 0);
@


1.21
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.20 2013/06/09 13:15:26 tedu Exp $ */
d195 1
a195 1
	free(dirbuf, M_TEMP);
d423 1
a423 1
	free(path, M_TEMP);
@


1.20
log
@arguments to bcopy/memmove are reversed. put on thinking cap, then commit.
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.19 2013/06/09 12:43:57 tedu Exp $ */
a49 1
#define DIRENT_MINSIZE (sizeof(struct dirent) - (MAXNAMLEN + 1) + 4)
d139 1
a139 1
		error = VOP_READDIR(uvp, &uio, p->p_ucred, &eofflag, 0, 0);
d162 1
a162 1
			if (reclen < DIRENT_MINSIZE) {
@


1.19
log
@change a bcopy to memmove (mainly to catch platforms that don't offer it)
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.18 2011/12/09 16:14:54 nicm Exp $ */
d177 1
a177 1
				memmove(dp->d_name, bp, dp->d_namlen);
@


1.18
log
@Add new KERN_PROC_CWD sysctl to get the current working directory of a process.

ok guenther deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.17 2010/05/19 08:31:23 thib Exp $ */
d177 1
a177 1
				bcopy(dp->d_name, bp, dp->d_namlen);
@


1.17
log
@clean up a few things that where left to rot after bob's vfs cache work.
sync a few comments to reality (or remove them), remove the cn_hash member
from struct componentname, spacing.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.16 2010/01/14 23:12:11 schwarze Exp $ */
a261 2

#define GETCWD_CHECK_ACCESS 0x0001
@


1.16
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.15 2009/07/09 22:29:56 thib Exp $ */
a90 1
	cn.cn_hash = 0;
@


1.15
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.13 2008/06/26 05:42:20 ray Exp $ */
d213 1
a213 1
	obp = *bpp;	/* Save orginal position to restore to on error */
@


1.14
log
@Remove unused function proc_isunder()

"go for it" tedu@@
@
text
@d282 2
a283 2
	VREF(rvp);
	VREF(lvp);
d336 1
a336 1
			VREF(lvp);
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.12 2007/08/07 07:41:59 thib Exp $ */
a387 16
}

/* True if p1's root directory is equal to or under p2's root directory */
int
proc_isunder(struct proc *p1, struct proc *p2)
{
	struct vnode *r1 = p1->p_fd->fd_rdir;
	struct vnode *r2 = p2->p_fd->fd_rdir;

	if (r1 == NULL)
		return (r2 == NULL);

	if (r2 == NULL)
		return (1);

	return (vn_isunder(r1, r2, p2));
@


1.12
log
@fix the "double-path" errors seen with getcwd by saving the orignal
buffer position in vfs_getcwd_getcache() and restoring it on error.
Use u_int32_t for the componentname hash, use the same type in
the diagnostic code in relookup() to prevent unsigned vs signed errors.

help, testing & ok kurt@@
ok millert@@, art@@
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.11 2007/05/30 04:27:42 beck Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@back out vfs change - todd fries has seen afs issues, and I'm suspicious
this can cause other problems.
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.9 2006/05/17 12:52:12 pedro Exp $ */
d216 1
d220 1
d259 2
a260 1
		if (!error)
d262 1
@


1.10
log
@
	Step one of some vnode improvements - change getnewvnode to
actually allocate "desiredvnodes" - add a vdrop to un-hold a vnode held
with vhold, and change the name cache to make use of vhold/vdrop, while
keeping track of which vnodes are referred to by which cache entries to
correctly hold/drop vnodes when the cache uses them.
ok thib@@, tedu@@, art@@
@
text
@d242 5
a246 7

#ifdef DIAGNOSTIC
	/* XXX should not happen with vhold/vdrop in cache layer now. */
	if (vpid != uvp->v_id)
		panic("vpid %d != uvp->v_id %d\n");
#endif
	if (error) {
d251 2
@


1.9
log
@Don't cast malloc()
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.8 2006/05/01 21:50:48 pedro Exp $ */
d242 7
a248 5
	/*
	 * Verify that vget() succeeded, and check that vnode capability
	 * didn't change while we were waiting for the lock.
	 */
	if (error || (vpid != uvp->v_id)) {
a252 2
		if (!error)
			vput(uvp);
@


1.8
log
@Move vn_isunder() to vfs_vnops.c, that's the place for vn_* functions
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.7 2006/05/01 21:08:44 pedro Exp $ */
d126 1
a126 1
	dirbuf = (char *) malloc(dirbuflen, M_TEMP, M_WAITOK);
d422 1
a422 1
	path = (char *) malloc(len, M_TEMP, M_WAITOK);
@


1.7
log
@Rename functions and move prototypes around
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.6 2006/05/01 20:03:06 pedro Exp $ */
a390 14
}

/* Check if a directory can be found inside another in the hierarchy */
int
vn_isunder(struct vnode *lvp, struct vnode *rvp, struct proc *p)
{
	int error;

	error = vfs_getcwd_common(lvp, rvp, NULL, NULL, MAXPATHLEN/2, 0, p);

	if (!error)
		return (1);

	return (0);
@


1.6
log
@Make static functions global so DDB can see them
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.5 2006/04/30 01:03:51 pedro Exp $ */
a56 8
int getcwd_scandir(struct vnode **, struct vnode **, char **, char *,
    struct proc *);
int getcwd_common(struct vnode *, struct vnode *, char **, char *, int, int,
    struct proc *);

int getcwd_getcache(struct vnode **, struct vnode **, char **, char *);
int vn_isunder(struct vnode *, struct vnode *, struct proc *);

d61 1
a61 1
getcwd_scandir(struct vnode **lvpp, struct vnode **uvpp, char **bpp,
d211 1
a211 1
getcwd_getcache(struct vnode **lvpp, struct vnode **uvpp, char **bpp,
d271 1
a271 1
getcwd_common(struct vnode *lvp, struct vnode *rvp, char **bpp, char *bufp,
d350 1
a350 1
		error = getcwd_getcache(&lvp, &uvp, &bp, bufp);
d354 1
a354 1
			error = getcwd_scandir(&lvp, &uvp, &bp, bufp, p);
d399 1
a399 1
	error = getcwd_common(lvp, rvp, NULL, NULL, MAXPATHLEN/2, 0, p);
d447 1
a447 1
	error = getcwd_common(p->p_fd->fd_cdir, NULL, &bp, path, len/2,
@


1.5
log
@Prune remaining of the code, no binary change
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.4 2006/04/30 00:34:34 pedro Exp $ */
d57 1
a57 1
static int getcwd_scandir(struct vnode **, struct vnode **, char **, char *,
d59 5
a63 4
static int getcwd_getcache(struct vnode **, struct vnode **, char **, char *);
static int getcwd_common(struct vnode *, struct vnode *, char **, char *, int,
    int, struct proc *);
static int vn_isunder(struct vnode *, struct vnode *, struct proc *);
d68 1
a68 1
static int
d218 1
a218 1
static int
d278 1
a278 1
static int
d402 1
a402 1
static int
@


1.4
log
@Prune getcwd_common() and vn_isunder(), no binary change
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.3 2006/04/30 00:08:13 pedro Exp $ */
d53 1
a53 1
#include <ufs/ufs/dir.h>	/* XXX only for DIRBLKSIZ */
d57 2
a58 2
static int getcwd_scandir(struct vnode **, struct vnode **,
    char **, char *, struct proc *);
d60 2
a61 3
static int getcwd_common(struct vnode *, struct vnode *,
    char **, char *, int, int, struct proc *);

d64 1
a64 19
#define DIRENT_MINSIZE (sizeof(struct dirent) - (MAXNAMLEN+1) + 4)

/*
 * Vnode variable naming conventions in this file:
 *
 * rvp: the current root we're aiming towards.
 * lvp, *lvpp: the "lower" vnode
 * uvp, *uvpp: the "upper" vnode.
 *
 * Since all the vnodes we're dealing with are directories, and the
 * lookups are going *up* in the filesystem rather than *down*, the
 * usual "pvp" (parent) or "dvp" (directory) naming conventions are
 * too confusing.
 */

/*
 * XXX: is EINVAL the right thing to return if a directory is
 *      malformed?
 */
d66 1
a66 13

/*
 * Find parent vnode of *lvpp, return in *uvpp
 *
 * If we care about the name, scan it looking for name of directory
 * entry pointing at lvp.
 *
 * Place the name in the buffer which starts at bufp, immediately
 * before *bpp, and move bpp backwards to point at the start of it.
 *
 * On entry, *lvpp is a locked vnode reference; on exit, it is vput and NULL'ed
 * On exit, *uvpp is either NULL or is a locked vnode reference.
 */
d68 2
a69 2
getcwd_scandir(struct vnode **lvpp, struct vnode **uvpp,
    char **bpp, char *bufp, struct proc *p)
d71 2
a72 4
	int     error = 0;
	int     eofflag;
	off_t   off;
	int     tries;
d75 2
a76 3
	char   *dirbuf = NULL;
	int	dirbuflen;
	ino_t   fileno;
d81 1
a81 1
	int len, reclen;
a97 4
	/*
	 * Ok, we have to do it the hard way..
	 * Next, get parent vnode using lookup of ..
	 */
d107 2
a108 5
	
	/*
	 * At this point, lvp is locked and will be unlocked by the lookup.
	 * On successful return, *uvpp will be locked
	 */
d116 1
d125 1
a125 1
	
d129 1
d132 2
a133 1
	dirbuf = (char *)malloc(dirbuflen, M_TEMP, M_WAITOK);
d136 1
a140 1
		/* call VOP_READDIR of parent */
d154 1
d159 1
a159 3
		/*
		 * Try again if NFS tosses its cookies.
		 */
d164 2
a165 7
		} else if (error != 0) {
			/*
			 * We simply bail on error, even if we don't
			 * have eofflag yet.  This is the exact
			 * behavior of the old userland getcwd()
			 */
			goto out;
a167 1
		/* No error */
d171 1
a171 1
		/* scan directory page looking for matching vnode */ 
d177 1
a177 1
			/* check for malformed directory.. */
d182 1
a182 6
			/*
			 * XXX should perhaps do VOP_LOOKUP to
			 * check that we got back to the right place,
			 * but getting the locking games for that
			 * right would be heinous.
			 */
d191 1
d195 1
d198 1
d207 1
d210 1
d212 1
d216 1
a216 14
/*
 * Look in the vnode-to-name reverse cache to see if
 * we can find things the easy way.
 *
 * XXX vget failure path is untested.
 *
 * On entry, *lvpp is a locked vnode reference.
 * On exit, one of the following is the case:
 *	0) Both *lvpp and *uvpp are NULL and failure is returned.
 * 	1) *uvpp is NULL, *lvpp remains locked and -1 is returned (cache miss)
 *      2) *uvpp is a locked vnode reference, *lvpp is vput and NULL'ed
 *	   and 0 is returned (cache hit)
 */

d218 2
a219 2
getcwd_getcache(struct vnode **lvpp, struct vnode **uvpp,
    char **bpp, char *bufp)
a221 2
	int error;
	int vpid;
d223 2
a224 1
	
a226 4
	/*
	 * This returns 0 on a cache hit, -1 on a clean cache miss, or
	 * an errno on other failure.
	 */
d234 1
d237 1
a240 4
	/*
	 * Since we're going up, we have to release the current lock
	 * before we take the parent lock.
	 */
d242 1
d246 1
a246 1
	if (error != 0)
d248 1
d250 1
a250 1
	 * Verify that vget succeeded, and check that vnode capability
a251 4
	 *
	 * XXX: this is kind of nasty to have to check here.  It
	 * should really be done in cache_revlookup() (see comments
	 * there, too).
d255 2
a256 4
		 * Oops, we missed.  If the vget failed, or the
		 * capability changed, try to get our lock back; if
		 * that works, tell caller to try things the hard way,
		 * otherwise give up.
d260 1
a263 1

d267 1
d270 1
a273 4
/*
 * common routine shared by sys___getcwd() and vn_isunder()
 */

d276 1
@


1.3
log
@Prune proc_isunder() and sys___getcwd(), no binary change
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.2 2006/04/29 21:31:15 pedro Exp $ */
d347 2
a348 2
getcwd_common(struct vnode *lvp, struct vnode *rvp,
    char **bpp, char *bufp, int limit, int flags, struct proc *p)
d353 1
a353 2
	int error;
	int perms = VEXEC;
a363 7
	/*
	 * Error handling invariant:
	 * Before a `goto out':
	 *	lvp is either NULL, or locked and held.
	 *	uvp is either NULL, or locked and held.
	 */

d370 1
d373 1
a373 6
	/*
	 * this loop will terminate when one of the following happens:
	 *	- we hit the root
	 *	- getdirentries or lookup fails
	 *	- we run out of space in the buffer.
	 */
d379 5
d389 2
a390 5
		
		/*
		 * access check here is optional, depending on
		 * whether or not caller cares.
		 */
d397 2
a398 4
		
		/*
		 * step up if we're a covered vnode..
		 */
d407 1
d409 1
a409 3
			/*
			 * hodie natus est radici frater
			 */
d414 1
d416 1
d418 1
a418 1
			if (error != 0) {
d424 2
a425 4
		/*
		 * Look in the name cache; if that fails, look in the
		 * directory..
		 */
d427 3
a429 1
		if (error == -1)
d431 2
d435 2
a436 1
#ifdef DIAGNOSTIC		
d442 2
a443 1
#endif		
d446 1
d450 1
d454 1
d457 1
d460 1
d463 1
d465 1
d469 1
a469 7
/*
 * Check if one directory can be found inside another in the directory
 * hierarchy.
 *
 * Intended to be used in chroot, chdir, fchdir, etc., to ensure that
 * chroot() actually means something.
 */
d479 2
a480 2
	else
		return (0);
@


1.2
log
@KNF bits
@
text
@d1 1
a1 1
/* $OpenBSD: vfs_getcwd.c,v 1.1 2006/04/28 08:34:31 pedro Exp $ */
d489 1
a489 7
/*
 * Returns true if proc p1's root directory equal to or under p2's
 * root directory.
 *
 * Intended to be used from ptrace/procfs sorts of things.
 */

d498 2
a499 1
	else if (r2 == NULL)
d501 2
a502 2
	else
		return (vn_isunder(r1, r2, p2));
d505 1
a505 7
/*
 * Find pathname of process's current directory.
 *
 * Use vfs vnode-to-name reverse cache; if that fails, fall back
 * to reading directory contents.
 */

d509 3
a511 10
	register struct sys___getcwd_args /* {
		syscallarg(char *) buf;
		syscallarg(size_t) len;
	} */ *uap = v;

	int     error;
	char   *path;
	char   *bp, *bend;
	int     len = SCARG(uap, len);
	int	lenused;
d513 2
a514 2
	if (len > MAXPATHLEN*4)
		len = MAXPATHLEN*4;
d518 1
a518 1
	path = (char *)malloc(len, M_TEMP, M_WAITOK);
d534 1
d537 2
a538 1
	/* put the result into user buffer */
d543 1
@


1.1
log
@Instrumentation for an in-kernel getcwd() implementation.
Not yet activated. Diff by marius@@ long ago, from NetBSD.
Okay miod@@ and krw@@.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d128 1
a128 1
			return error;
d155 1
a155 1
		return error;
d163 1
a163 1
		return 0;
d257 1
a257 1
	return error;
d296 1
a296 1
		return error;
d333 1
a333 1
			return -1;
d466 1
a466 1
	return error;
d484 1
a484 1
		return 1;
d486 1
a486 1
		return 0;
d505 1
a505 1
		return 1;
d507 1
a507 1
		return vn_isunder(r1, r2, p2);
d534 1
a534 1
		return ERANGE;
d559 1
a559 1
	return error;
@

