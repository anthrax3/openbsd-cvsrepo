head	1.268;
access;
symbols
	OPENBSD_6_1:1.267.0.4
	OPENBSD_6_1_BASE:1.267
	OPENBSD_6_0:1.253.0.2
	OPENBSD_6_0_BASE:1.253
	OPENBSD_5_9:1.248.0.2
	OPENBSD_5_9_BASE:1.248
	OPENBSD_5_8:1.243.0.4
	OPENBSD_5_8_BASE:1.243
	OPENBSD_5_7:1.235.0.2
	OPENBSD_5_7_BASE:1.235
	OPENBSD_5_6:1.216.0.4
	OPENBSD_5_6_BASE:1.216
	OPENBSD_5_5:1.204.0.4
	OPENBSD_5_5_BASE:1.204
	OPENBSD_5_4:1.189.0.2
	OPENBSD_5_4_BASE:1.189
	OPENBSD_5_3:1.186.0.2
	OPENBSD_5_3_BASE:1.186
	OPENBSD_5_2:1.183.0.2
	OPENBSD_5_2_BASE:1.183
	OPENBSD_5_1_BASE:1.181
	OPENBSD_5_1:1.181.0.2
	OPENBSD_5_0:1.180.0.2
	OPENBSD_5_0_BASE:1.180
	OPENBSD_4_9:1.174.0.2
	OPENBSD_4_9_BASE:1.174
	OPENBSD_4_8:1.170.0.2
	OPENBSD_4_8_BASE:1.170
	OPENBSD_4_7:1.166.0.2
	OPENBSD_4_7_BASE:1.166
	OPENBSD_4_6:1.159.0.4
	OPENBSD_4_6_BASE:1.159
	OPENBSD_4_5:1.157.0.2
	OPENBSD_4_5_BASE:1.157
	OPENBSD_4_4:1.150.0.2
	OPENBSD_4_4_BASE:1.150
	OPENBSD_4_3:1.148.0.2
	OPENBSD_4_3_BASE:1.148
	OPENBSD_4_2:1.143.0.2
	OPENBSD_4_2_BASE:1.143
	OPENBSD_4_1:1.134.0.2
	OPENBSD_4_1_BASE:1.134
	OPENBSD_4_0:1.130.0.2
	OPENBSD_4_0_BASE:1.130
	OPENBSD_3_9:1.128.0.2
	OPENBSD_3_9_BASE:1.128
	OPENBSD_3_8:1.124.0.2
	OPENBSD_3_8_BASE:1.124
	OPENBSD_3_7:1.123.0.2
	OPENBSD_3_7_BASE:1.123
	OPENBSD_3_6:1.119.0.2
	OPENBSD_3_6_BASE:1.119
	SMP_SYNC_A:1.115
	SMP_SYNC_B:1.115
	OPENBSD_3_5:1.112.0.2
	OPENBSD_3_5_BASE:1.112
	OPENBSD_3_4:1.107.0.2
	OPENBSD_3_4_BASE:1.107
	UBC_SYNC_A:1.104
	OPENBSD_3_3:1.101.0.2
	OPENBSD_3_3_BASE:1.101
	OPENBSD_3_2:1.95.0.2
	OPENBSD_3_2_BASE:1.95
	OPENBSD_3_1:1.94.0.2
	OPENBSD_3_1_BASE:1.94
	UBC_SYNC_B:1.95
	UBC:1.88.0.2
	UBC_BASE:1.88
	OPENBSD_3_0:1.79.0.2
	OPENBSD_3_0_BASE:1.79
	OPENBSD_2_9_BASE:1.62
	OPENBSD_2_9:1.62.0.2
	OPENBSD_2_8:1.55.0.2
	OPENBSD_2_8_BASE:1.55
	OPENBSD_2_7:1.52.0.2
	OPENBSD_2_7_BASE:1.52
	SMP:1.46.0.2
	SMP_BASE:1.46
	kame_19991208:1.42
	OPENBSD_2_6:1.41.0.2
	OPENBSD_2_6_BASE:1.41
	OPENBSD_2_5:1.37.0.2
	OPENBSD_2_5_BASE:1.37
	OPENBSD_2_4:1.32.0.2
	OPENBSD_2_4_BASE:1.32
	OPENBSD_2_3:1.31.0.2
	OPENBSD_2_3_BASE:1.31
	OPENBSD_2_2:1.27.0.2
	OPENBSD_2_2_BASE:1.27
	OPENBSD_2_1:1.22.0.2
	OPENBSD_2_1_BASE:1.22
	OPENBSD_2_0:1.18.0.2
	OPENBSD_2_0_BASE:1.18
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.268
date	2017.04.20.12.59.36;	author visa;	state Exp;
branches;
next	1.267;
commitid	35AK3Wv48Mc7uWnr;

1.267
date	2017.03.06.10.48.16;	author mpi;	state Exp;
branches;
next	1.266;
commitid	h4IFdZnhvuleTTRh;

1.266
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.265;
commitid	1rXx7AiXIWFC9gYa;

1.265
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.264;
commitid	CHRb0fCqa8XxUAMH;

1.264
date	2017.01.01.07.00.56;	author jsg;	state Exp;
branches;
next	1.263;
commitid	muHkdG5LU6P00ImZ;

1.263
date	2016.11.14.10.32.46;	author mpi;	state Exp;
branches;
next	1.262;
commitid	to0Je2i4V2FtpmS1;

1.262
date	2016.11.07.00.26.32;	author guenther;	state Exp;
branches;
next	1.261;
commitid	W7ztnDZwvjCaeQTS;

1.261
date	2016.10.24.04.38.44;	author dlg;	state Exp;
branches;
next	1.260;
commitid	FCHpeu0V7ZGrMD9k;

1.260
date	2016.10.21.06.27.50;	author dlg;	state Exp;
branches;
next	1.259;
commitid	D5WUiCvZ665NhpbX;

1.259
date	2016.09.22.12.55.24;	author mpi;	state Exp;
branches;
next	1.258;
commitid	yHpOPoIDV9B9PJbt;

1.258
date	2016.09.18.12.36.28;	author jasper;	state Exp;
branches;
next	1.257;
commitid	jKjTYp08swyKgXHr;

1.257
date	2016.09.04.09.22.29;	author mpi;	state Exp;
branches;
next	1.256;
commitid	jBolvsPoQ0BaYiLs;

1.256
date	2016.09.03.14.46.56;	author naddy;	state Exp;
branches;
next	1.255;
commitid	RpNaiU9Lz1B3rhqT;

1.255
date	2016.09.03.13.16.50;	author deraadt;	state Exp;
branches;
next	1.254;
commitid	n0uKE3eSvTc1ibZV;

1.254
date	2016.09.02.12.17.33;	author tb;	state Exp;
branches;
next	1.253;
commitid	Z6hUPnAcS0GtAGum;

1.253
date	2016.05.17.23.28.03;	author bluhm;	state Exp;
branches;
next	1.252;
commitid	mdEa4Ht7h1M2c9Us;

1.252
date	2016.05.10.23.54.00;	author bluhm;	state Exp;
branches;
next	1.251;
commitid	ySY3TBIHoKy6xoBh;

1.251
date	2016.05.10.18.39.51;	author deraadt;	state Exp;
branches;
next	1.250;
commitid	qfOifNidEGDB2jL1;

1.250
date	2016.05.03.14.52.39;	author mpi;	state Exp;
branches;
next	1.249;
commitid	dxC8XEETMDhMlqh6;

1.249
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.248;
commitid	gAjwyca5TfuoJAhn;

1.248
date	2016.01.03.00.15.59;	author jsg;	state Exp;
branches;
next	1.247;
commitid	K43Y5X3aNw61hXRF;

1.247
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.246;
commitid	fbhqfhfdKxBcsetK;

1.246
date	2015.11.08.20.45.57;	author naddy;	state Exp;
branches;
next	1.245;
commitid	xMgxEPz4COvjCUcL;

1.245
date	2015.10.07.10.50.35;	author mpi;	state Exp;
branches;
next	1.244;
commitid	hPrd2a6fiZdlN2yP;

1.244
date	2015.08.30.10.39.16;	author mpi;	state Exp;
branches;
next	1.243;
commitid	avqdJydG8T8nvZhe;

1.243
date	2015.07.09.19.45.37;	author miod;	state Exp;
branches;
next	1.242;
commitid	AO7NhVXsNmk15Nrm;

1.242
date	2015.07.02.01.34.00;	author dlg;	state Exp;
branches;
next	1.241;
commitid	HBmwORlhlW47BLMN;

1.241
date	2015.06.24.03.42.08;	author dlg;	state Exp;
branches;
next	1.240;
commitid	VNhhk5TzpoF8wWLM;

1.240
date	2015.05.18.04.07.26;	author miod;	state Exp;
branches;
next	1.239;
commitid	rH98ca42JKflF3QO;

1.239
date	2015.05.05.02.13.46;	author guenther;	state Exp;
branches;
next	1.238;
commitid	dNPv28CJI5BxtRGW;

1.238
date	2015.05.01.11.18.21;	author miod;	state Exp;
branches;
next	1.237;
commitid	yMraB2XwI04iFONB;

1.237
date	2015.04.12.11.12.09;	author dlg;	state Exp;
branches;
next	1.236;
commitid	DsabHXpgojyK3w4b;

1.236
date	2015.04.07.11.07.56;	author dlg;	state Exp;
branches;
next	1.235;
commitid	8xqaL0s0mVMHEk93;

1.235
date	2015.02.10.05.28.18;	author guenther;	state Exp;
branches;
next	1.234;
commitid	GFzml5gt9M5PfXe6;

1.234
date	2015.02.09.09.39.09;	author miod;	state Exp;
branches;
next	1.233;
commitid	Dny5EZ91sz8fb6Ea;

1.233
date	2015.01.19.01.19.17;	author deraadt;	state Exp;
branches;
next	1.232;
commitid	GZxOWQTfFvMIrIGB;

1.232
date	2015.01.13.18.51.27;	author kettenis;	state Exp;
branches;
next	1.231;
commitid	ZIGGFwm21iN1eeWB;

1.231
date	2014.12.31.15.32.05;	author jsing;	state Exp;
branches;
next	1.230;
commitid	PknnwjBw6QPGjxop;

1.230
date	2014.12.28.21.32.45;	author krw;	state Exp;
branches;
next	1.229;
commitid	XsOzCX2YLadmSGZj;

1.229
date	2014.12.17.06.58.11;	author guenther;	state Exp;
branches;
next	1.228;
commitid	DImukoCWyTxwdbuh;

1.228
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.227;
commitid	P6Av4XGqOi3rFasL;

1.227
date	2014.12.15.02.24.23;	author guenther;	state Exp;
branches;
next	1.226;
commitid	ZxaujiOM0aYQRjFY;

1.226
date	2014.12.10.02.44.46;	author tedu;	state Exp;
branches;
next	1.225;
commitid	tsoJBlEBSyYO22RG;

1.225
date	2014.11.18.21.11.08;	author miod;	state Exp;
branches;
next	1.224;
commitid	aHu9cmBEDZ22eTiv;

1.224
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.223;
commitid	yv0ECmCdICvq576h;

1.223
date	2014.10.25.12.53.14;	author miod;	state Exp;
branches;
next	1.222;
commitid	rj66tKD7ZvBJYkJx;

1.222
date	2014.10.17.01.51.39;	author tedu;	state Exp;
branches;
next	1.221;
commitid	r6zxCLSQFWXeVG73;

1.221
date	2014.10.13.22.42.22;	author deraadt;	state Exp;
branches;
next	1.220;
commitid	IkkaAdr1p9A192qn;

1.220
date	2014.10.11.17.12.30;	author deraadt;	state Exp;
branches;
next	1.219;
commitid	il87miBjLKpme2E7;

1.219
date	2014.10.11.16.28.06;	author tedu;	state Exp;
branches;
next	1.218;
commitid	bu68m7FkSwmIteZe;

1.218
date	2014.10.03.18.06.46;	author kettenis;	state Exp;
branches;
next	1.217;
commitid	3JKupIsvM8vNecnK;

1.217
date	2014.08.14.09.01.47;	author mpi;	state Exp;
branches;
next	1.216;
commitid	xAyitDa7xkItKbjR;

1.216
date	2014.07.11.08.18.31;	author guenther;	state Exp;
branches;
next	1.215;
commitid	zJyOCNTjgsYVGLiw;

1.215
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.214;
commitid	EF98ch02VpFassUi;

1.214
date	2014.06.15.11.43.24;	author sf;	state Exp;
branches;
next	1.213;
commitid	Y0AWLKcfCeF28jP4;

1.213
date	2014.05.15.03.52.25;	author guenther;	state Exp;
branches;
next	1.212;

1.212
date	2014.05.04.05.03.26;	author guenther;	state Exp;
branches;
next	1.211;

1.211
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.210;

1.210
date	2014.03.31.19.37.15;	author kettenis;	state Exp;
branches;
next	1.209;

1.209
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.208;

1.208
date	2014.03.29.18.09.31;	author guenther;	state Exp;
branches;
next	1.207;

1.207
date	2014.03.28.17.57.11;	author mpi;	state Exp;
branches;
next	1.206;

1.206
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.205;

1.205
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.204;

1.204
date	2014.02.12.05.47.36;	author guenther;	state Exp;
branches;
next	1.203;

1.203
date	2014.01.20.21.19.27;	author guenther;	state Exp;
branches;
next	1.202;

1.202
date	2014.01.19.23.52.54;	author deraadt;	state Exp;
branches;
next	1.201;

1.201
date	2014.01.19.13.26.42;	author deraadt;	state Exp;
branches;
next	1.200;

1.200
date	2014.01.19.13.12.07;	author deraadt;	state Exp;
branches;
next	1.199;

1.199
date	2014.01.19.00.39.40;	author deraadt;	state Exp;
branches;
next	1.198;

1.198
date	2014.01.19.00.22.58;	author deraadt;	state Exp;
branches;
next	1.197;

1.197
date	2014.01.01.07.08.10;	author fgsch;	state Exp;
branches;
next	1.196;

1.196
date	2013.12.28.20.52.48;	author deraadt;	state Exp;
branches;
next	1.195;

1.195
date	2013.12.28.03.22.52;	author deraadt;	state Exp;
branches;
next	1.194;

1.194
date	2013.12.28.03.12.56;	author deraadt;	state Exp;
branches;
next	1.193;

1.193
date	2013.12.28.03.04.20;	author deraadt;	state Exp;
branches;
next	1.192;

1.192
date	2013.12.01.16.40.56;	author krw;	state Exp;
branches;
next	1.191;

1.191
date	2013.10.29.04.23.16;	author dlg;	state Exp;
branches;
next	1.190;

1.190
date	2013.08.26.01.59.22;	author dlg;	state Exp;
branches;
next	1.189;

1.189
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.188;

1.188
date	2013.03.28.16.55.25;	author deraadt;	state Exp;
branches;
next	1.187;

1.187
date	2013.03.25.14.58.28;	author markus;	state Exp;
branches;
next	1.186;

1.186
date	2013.01.01.19.39.50;	author jasper;	state Exp;
branches;
next	1.185;

1.185
date	2012.11.05.19.39.34;	author miod;	state Exp;
branches;
next	1.184;

1.184
date	2012.08.28.16.39.09;	author matthew;	state Exp;
branches;
next	1.183;

1.183
date	2012.06.13.22.47.39;	author ariane;	state Exp;
branches;
next	1.182;

1.182
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.181;

1.181
date	2012.01.01.12.17.33;	author fgsch;	state Exp;
branches;
next	1.180;

1.180
date	2011.07.07.18.00.33;	author guenther;	state Exp;
branches;
next	1.179;

1.179
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.178;

1.178
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.177;

1.177
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.176;

1.176
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.175;

1.175
date	2011.03.07.07.07.13;	author guenther;	state Exp;
branches;
next	1.174;

1.174
date	2011.01.08.19.45.09;	author deraadt;	state Exp;
branches;
next	1.173;

1.173
date	2011.01.01.06.54.51;	author deraadt;	state Exp;
branches;
next	1.172;

1.172
date	2010.12.21.14.56.24;	author claudio;	state Exp;
branches;
next	1.171;

1.171
date	2010.09.08.14.15.56;	author jsing;	state Exp;
branches;
next	1.170;

1.170
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.169;

1.169
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.168;

1.168
date	2010.06.29.20.25.57;	author guenther;	state Exp;
branches;
next	1.167;

1.167
date	2010.05.14.18.47.56;	author kettenis;	state Exp;
branches;
next	1.166;

1.166
date	2010.01.12.04.06.26;	author deraadt;	state Exp;
branches;
next	1.165;

1.165
date	2010.01.01.13.13.58;	author miod;	state Exp;
branches;
next	1.164;

1.164
date	2009.12.23.07.40.31;	author guenther;	state Exp;
branches;
next	1.163;

1.163
date	2009.11.27.20.05.50;	author guenther;	state Exp;
branches;
next	1.162;

1.162
date	2009.08.11.18.43.33;	author blambert;	state Exp;
branches;
next	1.161;

1.161
date	2009.08.09.12.47.23;	author dlg;	state Exp;
branches;
next	1.160;

1.160
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.159;

1.159
date	2009.04.19.17.53.38;	author deraadt;	state Exp;
branches;
next	1.158;

1.158
date	2009.03.05.19.52.24;	author kettenis;	state Exp;
branches;
next	1.157;

1.157
date	2009.02.13.19.58.27;	author deraadt;	state Exp;
branches;
next	1.156;

1.156
date	2009.01.01.15.45.09;	author miod;	state Exp;
branches;
next	1.155;

1.155
date	2008.12.03.23.39.32;	author dlg;	state Exp;
branches;
next	1.154;

1.154
date	2008.10.15.23.23.51;	author deraadt;	state Exp;
branches;
next	1.153;

1.153
date	2008.10.14.18.27.29;	author guenther;	state Exp;
branches;
next	1.152;

1.152
date	2008.10.10.14.35.06;	author deraadt;	state Exp;
branches;
next	1.151;

1.151
date	2008.10.09.06.31.53;	author guenther;	state Exp;
branches;
next	1.150;

1.150
date	2008.06.09.07.07.16;	author djm;	state Exp;
branches;
next	1.149;

1.149
date	2008.05.06.17.19.40;	author thib;	state Exp;
branches;
next	1.148;

1.148
date	2008.01.01.16.31.42;	author miod;	state Exp;
branches;
next	1.147;

1.147
date	2007.11.25.15.56.17;	author tedu;	state Exp;
branches;
next	1.146;

1.146
date	2007.10.16.23.41.42;	author fgsch;	state Exp;
branches;
next	1.145;

1.145
date	2007.10.10.15.53.53;	author art;	state Exp;
branches;
next	1.144;

1.144
date	2007.09.10.18.49.45;	author miod;	state Exp;
branches;
next	1.143;

1.143
date	2007.07.25.23.11.52;	author art;	state Exp;
branches;
next	1.142;

1.142
date	2007.06.01.19.25.09;	author deraadt;	state Exp;
branches;
next	1.141;

1.141
date	2007.05.31.18.16.59;	author dlg;	state Exp;
branches;
next	1.140;

1.140
date	2007.05.16.17.27.30;	author art;	state Exp;
branches;
next	1.139;

1.139
date	2007.04.12.22.14.15;	author tedu;	state Exp;
branches;
next	1.138;

1.138
date	2007.04.03.08.05.43;	author art;	state Exp;
branches;
next	1.137;

1.137
date	2007.03.24.16.01.22;	author art;	state Exp;
branches;
next	1.136;

1.136
date	2007.03.19.14.33.28;	author dlg;	state Exp;
branches;
next	1.135;

1.135
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.134;

1.134
date	2007.01.12.07.41.31;	author art;	state Exp;
branches;
next	1.133;

1.133
date	2007.01.02.06.07.58;	author drahn;	state Exp;
branches;
next	1.132;

1.132
date	2006.11.29.12.24.17;	author miod;	state Exp;
branches;
next	1.131;

1.131
date	2006.11.14.18.00.27;	author jmc;	state Exp;
branches;
next	1.130;

1.130
date	2006.05.06.23.02.36;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2006.03.04.22.40.15;	author brad;	state Exp;
branches;
next	1.128;

1.128
date	2006.01.01.11.54.31;	author miod;	state Exp;
branches;
next	1.127;

1.127
date	2005.12.22.06.55.03;	author tedu;	state Exp;
branches;
next	1.126;

1.126
date	2005.12.03.18.09.08;	author tedu;	state Exp;
branches;
next	1.125;

1.125
date	2005.11.12.04.31.24;	author jsg;	state Exp;
branches;
next	1.124;

1.124
date	2005.07.18.11.43.14;	author tom;	state Exp;
branches;
next	1.123;

1.123
date	2005.01.01.18.12.58;	author mickey;	state Exp;
branches;
next	1.122;

1.122
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.121;

1.121
date	2004.11.28.02.11.33;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2004.11.23.19.08.55;	author miod;	state Exp;
branches;
next	1.119;

1.119
date	2004.07.28.17.15.12;	author tholo;	state Exp;
branches;
next	1.118;

1.118
date	2004.07.20.20.19.52;	author art;	state Exp;
branches;
next	1.117;

1.117
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.116;

1.116
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.115;

1.115
date	2004.06.09.20.18.28;	author art;	state Exp;
branches;
next	1.114;

1.114
date	2004.06.08.18.09.31;	author marc;	state Exp;
branches;
next	1.113;

1.113
date	2004.04.01.00.27.51;	author tedu;	state Exp;
branches;
next	1.112;

1.112
date	2004.03.14.23.12.11;	author tedu;	state Exp;
branches;
next	1.111;

1.111
date	2004.01.21.19.03.44;	author tedu;	state Exp;
branches;
next	1.110;

1.110
date	2004.01.14.19.34.05;	author grange;	state Exp;
branches;
next	1.109;

1.109
date	2004.01.01.00.04.35;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2003.11.03.18.24.52;	author tedu;	state Exp;
branches;
next	1.107;

1.107
date	2003.09.01.18.06.03;	author henning;	state Exp;
branches;
next	1.106;

1.106
date	2003.08.21.18.56.07;	author tedu;	state Exp;
branches;
next	1.105;

1.105
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.104;

1.104
date	2003.05.13.22.45.11;	author miod;	state Exp;
branches;
next	1.103;

1.103
date	2003.05.13.06.11.11;	author tedu;	state Exp;
branches;
next	1.102;

1.102
date	2003.05.09.00.49.46;	author art;	state Exp;
branches;
next	1.101;

1.101
date	2003.03.06.17.06.18;	author mickey;	state Exp;
branches;
next	1.100;

1.100
date	2003.01.09.22.27.12;	author miod;	state Exp;
branches;
next	1.99;

1.99
date	2003.01.01.21.05.36;	author pvalchev;	state Exp;
branches;
next	1.98;

1.98
date	2002.12.19.00.57.07;	author mickey;	state Exp;
branches;
next	1.97;

1.97
date	2002.11.22.16.47.28;	author art;	state Exp;
branches;
next	1.96;

1.96
date	2002.11.22.09.50.08;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2002.05.27.13.42.16;	author itojun;	state Exp;
branches;
next	1.94;

1.94
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.93;

1.93
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.92;

1.92
date	2002.01.30.20.29.44;	author nordin;	state Exp;
branches;
next	1.91;

1.91
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.90;

1.90
date	2002.01.01.20.41.56;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.88;

1.88
date	2001.12.04.23.22.42;	author art;	state Exp;
branches
	1.88.2.1;
next	1.87;

1.87
date	2001.11.28.13.47.39;	author art;	state Exp;
branches;
next	1.86;

1.86
date	2001.11.27.22.53.19;	author provos;	state Exp;
branches;
next	1.85;

1.85
date	2001.11.27.05.27.11;	author art;	state Exp;
branches;
next	1.84;

1.84
date	2001.11.10.18.42.31;	author art;	state Exp;
branches;
next	1.83;

1.83
date	2001.11.07.01.18.01;	author art;	state Exp;
branches;
next	1.82;

1.82
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.80;

1.80
date	2001.11.06.13.36.52;	author art;	state Exp;
branches;
next	1.79;

1.79
date	2001.10.11.08.07.12;	author gluk;	state Exp;
branches;
next	1.78;

1.78
date	2001.09.29.20.09.34;	author gluk;	state Exp;
branches;
next	1.77;

1.77
date	2001.09.17.19.17.30;	author gluk;	state Exp;
branches;
next	1.76;

1.76
date	2001.09.12.15.48.45;	author art;	state Exp;
branches;
next	1.75;

1.75
date	2001.09.07.12.58.18;	author art;	state Exp;
branches;
next	1.74;

1.74
date	2001.08.23.14.01.02;	author art;	state Exp;
branches;
next	1.73;

1.73
date	2001.07.27.09.55.07;	author niklas;	state Exp;
branches;
next	1.72;

1.72
date	2001.07.05.10.12.24;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2001.06.27.07.16.28;	author art;	state Exp;
branches;
next	1.70;

1.70
date	2001.06.27.07.02.45;	author art;	state Exp;
branches;
next	1.69;

1.69
date	2001.06.27.04.49.40;	author art;	state Exp;
branches;
next	1.68;

1.68
date	2001.06.23.18.30.37;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2001.06.23.06.04.34;	author art;	state Exp;
branches;
next	1.66;

1.66
date	2001.06.22.14.14.08;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2001.05.17.18.41.44;	author provos;	state Exp;
branches;
next	1.64;

1.64
date	2001.05.16.12.49.45;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2001.05.05.22.34.32;	author art;	state Exp;
branches;
next	1.62;

1.62
date	2001.04.06.23.41.02;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2001.04.02.21.43.11;	author niklas;	state Exp;
branches;
next	1.60;

1.60
date	2001.03.16.15.49.05;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2001.03.16.08.49.09;	author art;	state Exp;
branches;
next	1.58;

1.58
date	2001.02.05.21.28.06;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2001.01.01.16.06.12;	author aaron;	state Exp;
branches;
next	1.56;

1.56
date	2000.11.08.05.41.04;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2000.06.18.03.07.48;	author angelos;	state Exp;
branches;
next	1.54;

1.54
date	2000.06.16.21.47.14;	author provos;	state Exp;
branches;
next	1.53;

1.53
date	2000.06.05.11.02.50;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2000.03.23.16.54.44;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2000.03.23.10.13.58;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2000.03.22.21.35.37;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2000.03.20.15.29.53;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2000.03.17.10.25.21;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	2000.02.28.18.04.08;	author provos;	state Exp;
branches;
next	1.46;

1.46
date	2000.01.31.19.57.18;	author deraadt;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2000.01.31.01.09.10;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2000.01.28.19.45.04;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2000.01.01.19.27.18;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	99.11.05.01.18.01;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	99.09.12.19.44.04;	author weingart;	state Exp;
branches;
next	1.40;

1.40
date	99.08.17.10.32.18;	author niklas;	state Exp;
branches;
next	1.39;

1.39
date	99.07.15.14.07.41;	author art;	state Exp;
branches;
next	1.38;

1.38
date	99.04.22.19.28.07;	author art;	state Exp;
branches;
next	1.37;

1.37
date	99.03.01.04.41.38;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	99.02.26.04.44.43;	author art;	state Exp;
branches;
next	1.35;

1.35
date	99.01.11.01.37.13;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	99.01.10.13.34.17;	author niklas;	state Exp;
branches;
next	1.33;

1.33
date	99.01.02.00.38.37;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	98.09.16.06.21.08;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	98.03.01.00.37.54;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	98.02.20.13.41.33;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	97.11.06.05.58.14;	author csapuntz;	state Exp;
branches;
next	1.28;

1.28
date	97.11.06.02.17.29;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	97.10.28.10.52.17;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	97.10.06.20.19.49;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	97.10.06.15.12.12;	author csapuntz;	state Exp;
branches;
next	1.24;

1.24
date	97.07.28.09.13.17;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	97.06.05.10.15.24;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.04.19.18.40.02;	author pefo;	state Exp;
branches;
next	1.21;

1.21
date	97.03.27.05.35.28;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	96.11.06.01.29.46;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	96.10.19.13.26.00;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	96.09.21.11.06.08;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	96.09.04.22.35.27;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	96.08.31.09.24.08;	author pefo;	state Exp;
branches;
next	1.15;

1.15
date	96.08.21.09.46.21;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.08.13.03.12.41;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.08.10.21.41.13;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.06.16.10.28.39;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.06.11.03.25.12;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	96.06.10.07.25.54;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.27.07.59.02;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.07.15.23.35;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.05.06.09.56.20;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.05.02.13.12.05;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.26.50;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.03.03.17.19.39;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.20.21.26;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.08.44;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches;
next	;

1.46.2.1
date	2000.02.20.11.57.17;	author niklas;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2000.03.02.07.04.40;	author niklas;	state Exp;
branches;
next	1.46.2.3;

1.46.2.3
date	2000.03.24.09.09.23;	author niklas;	state Exp;
branches;
next	1.46.2.4;

1.46.2.4
date	2001.05.14.22.32.39;	author niklas;	state Exp;
branches;
next	1.46.2.5;

1.46.2.5
date	2001.07.04.10.48.14;	author niklas;	state Exp;
branches;
next	1.46.2.6;

1.46.2.6
date	2001.07.14.10.02.19;	author ho;	state Exp;
branches;
next	1.46.2.7;

1.46.2.7
date	2001.10.27.10.00.47;	author niklas;	state Exp;
branches;
next	1.46.2.8;

1.46.2.8
date	2001.10.31.03.26.28;	author nate;	state Exp;
branches;
next	1.46.2.9;

1.46.2.9
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.46.2.10;

1.46.2.10
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.46.2.11;

1.46.2.11
date	2002.03.06.02.13.22;	author niklas;	state Exp;
branches;
next	1.46.2.12;

1.46.2.12
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.46.2.13;

1.46.2.13
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.46.2.14;

1.46.2.14
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.46.2.15;

1.46.2.15
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.46.2.16;

1.46.2.16
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.46.2.17;

1.46.2.17
date	2003.05.18.17.41.16;	author niklas;	state Exp;
branches;
next	1.46.2.18;

1.46.2.18
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.46.2.19;

1.46.2.19
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.46.2.20;

1.46.2.20
date	2004.06.05.17.19.55;	author niklas;	state Exp;
branches;
next	1.46.2.21;

1.46.2.21
date	2004.06.05.23.13.01;	author niklas;	state Exp;
branches;
next	1.46.2.22;

1.46.2.22
date	2004.06.06.21.46.12;	author tedu;	state Exp;
branches;
next	1.46.2.23;

1.46.2.23
date	2004.06.08.19.39.49;	author art;	state Exp;
branches;
next	1.46.2.24;

1.46.2.24
date	2004.06.10.11.40.33;	author niklas;	state Exp;
branches;
next	;

1.88.2.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.88.2.2;

1.88.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.88.2.3;

1.88.2.3
date	2003.05.19.22.31.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.268
log
@Add a port of witness(4) lock validation tool from FreeBSD.

Go-ahead from kettenis@@, guenther@@, deraadt@@
@
text
@/*	$OpenBSD: init_main.c,v 1.267 2017/03/06 10:48:16 mpi Exp $	*/
/*	$NetBSD: init_main.c,v 1.84.4.1 1996/06/02 09:08:06 mrg Exp $	*/

/*
 * Copyright (c) 1995 Christopher G. Demetriou.  All rights reserved.
 * Copyright (c) 1982, 1986, 1989, 1991, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)init_main.c	8.9 (Berkeley) 1/21/94
 */

#include <sys/param.h>
#include <sys/filedesc.h>
#include <sys/file.h>
#include <sys/errno.h>
#include <sys/exec.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/signalvar.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/tty.h>
#include <sys/conf.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/socketvar.h>
#include <sys/lockf.h>
#include <sys/protosw.h>
#include <sys/reboot.h>
#include <sys/user.h>
#ifdef SYSVSHM
#include <sys/shm.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
#include <sys/domain.h>
#include <sys/msgbuf.h>
#include <sys/mbuf.h>
#include <sys/pipe.h>
#include <sys/task.h>
#include <sys/witness.h>

#include <sys/syscall.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

#include <dev/rndvar.h>

#include <ufs/ufs/quota.h>

#include <net/if.h>
#include <net/rtable.h>
#include <net/netisr.h>

#if defined(CRYPTO)
#include <crypto/cryptodev.h>
#include <crypto/cryptosoft.h>
#endif

#if defined(NFSSERVER) || defined(NFSCLIENT)
extern void nfs_init(void);
#endif

#include "mpath.h"
#include "vscsi.h"
#include "softraid.h"

const char	copyright[] =
"Copyright (c) 1982, 1986, 1989, 1991, 1993\n"
"\tThe Regents of the University of California.  All rights reserved.\n"
"Copyright (c) 1995-2017 OpenBSD. All rights reserved.  https://www.OpenBSD.org\n";

/* Components of the first process -- never freed. */
struct	session session0;
struct	pgrp pgrp0;
struct	proc proc0;
struct	process process0;
struct	plimit limit0;
struct	vmspace vmspace0;
struct	sigacts sigacts0;
struct	process *initprocess;
struct	proc *reaperproc;

extern	struct user *proc0paddr;

struct	vnode *rootvp, *swapdev_vp;
int	boothowto;
struct	timespec boottime;
int	ncpus =  1;
int	ncpusfound = 1;			/* number of cpus we find */
volatile int start_init_exec;		/* semaphore for start_init() */

#if !defined(NO_PROPOLICE)
long	__guard_local __attribute__((section(".openbsd.randomdata")));
#endif

/* XXX return int so gcc -Werror won't complain */
int	main(void *);
void	check_console(struct proc *);
void	start_init(void *);
void	start_cleaner(void *);
void	start_update(void *);
void	start_reaper(void *);
void	crypto_init(void);
void	db_ctf_init(void);
void	prof_init(void);
void	init_exec(void);
void	kqueue_init(void);
void	taskq_init(void);
void	timeout_proc_init(void);
void	pool_gc_pages(void *);
void	percpu_init(void);

extern char sigcode[], esigcode[], sigcoderet[];
#ifdef SYSCALL_DEBUG
extern char *syscallnames[];
#endif

struct emul emul_native = {
	"native",
	NULL,
	sendsig,
	SYS_syscall,
	SYS_MAXSYSCALL,
	sysent,
#ifdef SYSCALL_DEBUG
	syscallnames,
#else
	NULL,
#endif
	0,
	copyargs,
	setregs,
	NULL,		/* fixup */
	NULL,		/* coredump */
	sigcode,
	esigcode,
	sigcoderet,
	EMUL_ENABLED | EMUL_NATIVE,
};


/*
 * System startup; initialize the world, create process 0, mount root
 * filesystem, and fork to create init and pagedaemon.  Most of the
 * hard work is done in the lower-level initialization routines including
 * startup(), which does memory initialization and autoconfiguration.
 */
/* XXX return int, so gcc -Werror won't complain */
int
main(void *framep)
{
	struct proc *p;
	struct process *pr;
	struct pdevinit *pdev;
	quad_t lim;
	int i;
	extern struct pdevinit pdevinit[];
	extern void disk_init(void);

	/*
	 * Initialize the current process pointer (curproc) before
	 * any possible traps/probes to simplify trap processing.
	 */
	curproc = p = &proc0;
	p->p_cpu = curcpu();

	/*
	 * Initialize timeouts.
	 */
	timeout_startup();

	/*
	 * Attempt to find console and initialize
	 * in case of early panic or other messages.
	 */
	config_init();		/* init autoconfiguration data structures */
	consinit();

	printf("%s\n", copyright);

	WITNESS_INITIALIZE();

	KERNEL_LOCK_INIT();
	SCHED_LOCK_INIT();

	uvm_init();
	disk_init();		/* must come before autoconfiguration */
	tty_init();		/* initialise tty's */
	cpu_startup();

	random_start();		/* Start the flow */

	/*
	 * Initialize mbuf's.  Do this now because we might attempt to
	 * allocate mbufs or mbuf clusters during autoconfiguration.
	 */
	mbinit();

	/* Initialize sockets. */
	soinit();

	/* Initialize SRP subsystem. */
	srp_startup();

	/*
	 * Initialize process and pgrp structures.
	 */
	procinit();

	/* Initialize file locking. */
	lf_init();

	/*
	 * Initialize filedescriptors.
	 */
	filedesc_init();

	/*
	 * Initialize pipes.
	 */
	pipe_init();

	/*
	 * Initialize kqueues.
	 */
	kqueue_init();

	/* Create credentials. */
	p->p_ucred = crget();
	p->p_ucred->cr_ngroups = 1;	/* group 0 */

	/*
	 * Create process 0 (the swapper).
	 */
	pr = &process0;
	process_initialize(pr, p);

	LIST_INSERT_HEAD(&allprocess, pr, ps_list);
	LIST_INSERT_HEAD(PIDHASH(0), pr, ps_hash);
	atomic_setbits_int(&pr->ps_flags, PS_SYSTEM);

	/* Set the default routing table/domain. */
	process0.ps_rtableid = 0;

	LIST_INSERT_HEAD(&allproc, p, p_list);
	pr->ps_pgrp = &pgrp0;
	LIST_INSERT_HEAD(TIDHASH(0), p, p_hash);
	LIST_INSERT_HEAD(PGRPHASH(0), &pgrp0, pg_hash);
	LIST_INIT(&pgrp0.pg_members);
	LIST_INSERT_HEAD(&pgrp0.pg_members, pr, ps_pglist);

	pgrp0.pg_session = &session0;
	session0.s_count = 1;
	session0.s_leader = pr;

	atomic_setbits_int(&p->p_flag, P_SYSTEM);
	p->p_stat = SONPROC;
	pr->ps_nice = NZERO;
	pr->ps_emul = &emul_native;
	strlcpy(pr->ps_comm, "swapper", sizeof(pr->ps_comm));

	/* Init timeouts. */
	timeout_set(&p->p_sleep_to, endtsleep, p);

	/* Initialize signal state for process 0. */
	signal_init();
	pr->ps_sigacts = &sigacts0;
	siginit(pr);

	/* Create the file descriptor table. */
	p->p_fd = pr->ps_fd = fdinit();

	/* Create the limits structures. */
	pr->ps_limit = &limit0;
	for (i = 0; i < nitems(p->p_rlimit); i++)
		limit0.pl_rlimit[i].rlim_cur =
		    limit0.pl_rlimit[i].rlim_max = RLIM_INFINITY;
	limit0.pl_rlimit[RLIMIT_NOFILE].rlim_cur = NOFILE;
	limit0.pl_rlimit[RLIMIT_NOFILE].rlim_max = MIN(NOFILE_MAX,
	    (maxfiles - NOFILE > NOFILE) ?  maxfiles - NOFILE : NOFILE);
	limit0.pl_rlimit[RLIMIT_NPROC].rlim_cur = MAXUPRC;
	lim = ptoa(uvmexp.free);
	limit0.pl_rlimit[RLIMIT_RSS].rlim_max = lim;
	limit0.pl_rlimit[RLIMIT_MEMLOCK].rlim_max = lim;
	limit0.pl_rlimit[RLIMIT_MEMLOCK].rlim_cur = lim / 3;
	limit0.p_refcnt = 1;

	/* Allocate a prototype map so we have something to fork. */
	uvmspace_init(&vmspace0, pmap_kernel(), round_page(VM_MIN_ADDRESS),
	    trunc_page(VM_MAX_ADDRESS), TRUE, TRUE);
	p->p_vmspace = pr->ps_vmspace = &vmspace0;

	p->p_addr = proc0paddr;				/* XXX */

	/*
	 * Charge root for one process.
	 */
	(void)chgproccnt(0, 1);

	/* Initialize run queues */
	sched_init_runqueues();
	sleep_queue_init();
	sched_init_cpu(curcpu());
	p->p_cpu->ci_randseed = (arc4random() & 0x7fffffff) + 1;

	/* Initialize timeouts in process context. */
	timeout_proc_init();

	/* Initialize task queues */
	taskq_init();

	/* Initialize the interface/address trees */
	ifinit();

	/* Lock the kernel on behalf of proc0. */
	KERNEL_LOCK();

#if NMPATH > 0
	/* Attach mpath before hardware */
	config_rootfound("mpath", NULL);
#endif

	/* Configure the devices */
	cpu_configure();

	/* Configure virtual memory system, set vm rlimits. */
	uvm_init_limits(p);

	/* Per CPU memory allocation */
	percpu_init();

	/* Initialize the file systems. */
#if defined(NFSSERVER) || defined(NFSCLIENT)
	nfs_init();			/* initialize server/shared data */
#endif
	vfsinit();

	/* Start real time and statistics clocks. */
	initclocks();

#ifdef SYSVSHM
	/* Initialize System V style shared memory. */
	shminit();
#endif

#ifdef SYSVSEM
	/* Initialize System V style semaphores. */
	seminit();
#endif

#ifdef SYSVMSG
	/* Initialize System V style message queues. */
	msginit();
#endif

	/* Create default routing table before attaching lo0. */
	rtable_init();

	/* Attach pseudo-devices. */
	for (pdev = pdevinit; pdev->pdev_attach != NULL; pdev++)
		if (pdev->pdev_count > 0)
			(*pdev->pdev_attach)(pdev->pdev_count);

#ifdef CRYPTO
	crypto_init();
	swcr_init();
#endif /* CRYPTO */

	/*
	 * Initialize protocols.
	 */
	domaininit();

	initconsbuf();

#if defined(GPROF) || defined(DDBPROF)
	/* Initialize kernel profiling. */
	prof_init();
#endif

	mbcpuinit();	/* enable per cpu mbuf data */

	/* init exec and emul */
	init_exec();

	/* Start the scheduler */
	scheduler_start();

	/*
	 * Create process 1 (init(8)).  We do this now, as Unix has
	 * historically had init be process 1, and changing this would
	 * probably upset a lot of people.
	 *
	 * Note that process 1 won't immediately exec init(8), but will
	 * wait for us to inform it that the root file system has been
	 * mounted.
	 */
	{
		struct proc *initproc;

		if (fork1(p, FORK_FORK, start_init, NULL, NULL, &initproc))
			panic("fork init");
		initprocess = initproc->p_p;
	}

	randompid = 1;

	/*
	 * Create any kernel threads whose creation was deferred because
	 * initprocess had not yet been created.
	 */
	kthread_run_deferred_queue();

	/*
	 * Now that device driver threads have been created, wait for
	 * them to finish any deferred autoconfiguration.  Note we don't
	 * need to lock this semaphore, since we haven't booted any
	 * secondary processors, yet.
	 */
	while (config_pending)
		(void) tsleep((void *)&config_pending, PWAIT, "cfpend", 0);

	dostartuphooks();

#if NVSCSI > 0
	config_rootfound("vscsi", NULL);
#endif
#if NSOFTRAID > 0
	config_rootfound("softraid", NULL);
#endif

	/* Configure root/swap devices */
	diskconf();

	if (mountroot == NULL || ((*mountroot)() != 0))
		panic("cannot mount root");

	TAILQ_FIRST(&mountlist)->mnt_flag |= MNT_ROOTFS;

	/* Get the vnode for '/'.  Set p->p_fd->fd_cdir to reference it. */
	if (VFS_ROOT(TAILQ_FIRST(&mountlist), &rootvnode))
		panic("cannot find root vnode");
	p->p_fd->fd_cdir = rootvnode;
	vref(p->p_fd->fd_cdir);
	VOP_UNLOCK(rootvnode, p);
	p->p_fd->fd_rdir = NULL;

	/*
	 * Now that root is mounted, we can fixup initprocess's CWD
	 * info.  All other processes are kthreads, which merely
	 * share proc0's CWD info.
	 */
	initprocess->ps_fd->fd_cdir = rootvnode;
	vref(initprocess->ps_fd->fd_cdir);
	initprocess->ps_fd->fd_rdir = NULL;

	/*
	 * Now can look at time, having had a chance to verify the time
	 * from the file system.  Reset p->p_rtime as it may have been
	 * munched in mi_switch() after the time got set.
	 */
	nanotime(&boottime);
	LIST_FOREACH(pr, &allprocess, ps_list) {
		pr->ps_start = boottime;
		TAILQ_FOREACH(p, &pr->ps_threads, p_thr_link) {
			nanouptime(&p->p_cpu->ci_schedstate.spc_runtime);
			timespecclear(&p->p_rtime);
		}
	}

	uvm_swap_init();

	/* Create the pageout daemon kernel thread. */
	if (kthread_create(uvm_pageout, NULL, NULL, "pagedaemon"))
		panic("fork pagedaemon");

	/* Create the reaper daemon kernel thread. */
	if (kthread_create(start_reaper, NULL, &reaperproc, "reaper"))
		panic("fork reaper");

	/* Create the cleaner daemon kernel thread. */
	if (kthread_create(start_cleaner, NULL, NULL, "cleaner"))
		panic("fork cleaner");

	/* Create the update daemon kernel thread. */
	if (kthread_create(start_update, NULL, NULL, "update"))
		panic("fork update");

	/* Create the aiodone daemon kernel thread. */ 
	if (kthread_create(uvm_aiodone_daemon, NULL, NULL, "aiodoned"))
		panic("fork aiodoned");

#if !defined(__hppa__)
	/* Create the page zeroing kernel thread. */
	if (kthread_create(uvm_pagezero_thread, NULL, NULL, "zerothread"))
		panic("fork zerothread");
#endif

#if defined(MULTIPROCESSOR)
	/* Boot the secondary processors. */
	cpu_boot_secondary_processors();
#endif

	config_process_deferred_mountroot();

#ifdef DDBCTF
	db_ctf_init();
#endif

	/*
	 * Okay, now we can let init(8) exec!  It's off to userland!
	 */
	start_init_exec = 1;
	wakeup((void *)&start_init_exec);

	/*
	 * Start the idle pool page garbage collector
	 */
#if !(defined(__m88k__) && defined(MULTIPROCESSOR))	/* XXX */
	pool_gc_pages(NULL);
#endif

	start_periodic_resettodr();

        /*
         * proc0: nothing to do, back to sleep
         */
        while (1)
                tsleep(&proc0, PVM, "scheduler", 0);
	/* NOTREACHED */
}

/*
 * List of paths to try when searching for "init".
 */
static char *initpaths[] = {
	"/sbin/init",
	"/sbin/oinit",
	"/sbin/init.bak",
	NULL,
};

void
check_console(struct proc *p)
{
	struct nameidata nd;
	int error;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, "/dev/console", p);
	error = namei(&nd);
	if (error) {
		if (error == ENOENT)
			printf("warning: /dev/console does not exist\n");
		else
			printf("warning: /dev/console error %d\n", error);
	} else
		vrele(nd.ni_vp);
}

/*
 * Start the initial user process; try exec'ing each pathname in "initpaths".
 * The program is invoked with one argument containing the boot flags.
 */
void
start_init(void *arg)
{
	struct proc *p = arg;
	vaddr_t addr;
	struct sys_execve_args /* {
		syscallarg(const char *) path;
		syscallarg(char *const *) argp;
		syscallarg(char *const *) envp;
	} */ args;
	int options, error;
	long i;
	register_t retval[2];
	char flags[4], *flagsp;
	char **pathp, *path, *ucp, **uap, *arg0, *arg1 = NULL;

	/*
	 * Now in process 1.
	 */

	/*
	 * Wait for main() to tell us that it's safe to exec.
	 */
	while (start_init_exec == 0)
		(void) tsleep((void *)&start_init_exec, PWAIT, "initexec", 0);

	check_console(p);

	/* process 0 ignores SIGCHLD, but we can't */
	p->p_p->ps_sigacts->ps_flags = 0;

	/*
	 * Need just enough stack to hold the faked-up "execve()" arguments.
	 */
#ifdef MACHINE_STACK_GROWS_UP
	addr = USRSTACK;
#else
	addr = USRSTACK - PAGE_SIZE;
#endif
	p->p_vmspace->vm_maxsaddr = (caddr_t)addr;
	p->p_vmspace->vm_minsaddr = (caddr_t)(addr + PAGE_SIZE);
	if (uvm_map(&p->p_vmspace->vm_map, &addr, PAGE_SIZE, 
	    NULL, UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(PROT_READ | PROT_WRITE, PROT_MASK, MAP_INHERIT_COPY,
	    MADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW)))
		panic("init: couldn't allocate argument space");

	for (pathp = &initpaths[0]; (path = *pathp) != NULL; pathp++) {
#ifdef MACHINE_STACK_GROWS_UP
		ucp = (char *)addr;
#else
		ucp = (char *)(addr + PAGE_SIZE);
#endif
		/*
		 * Construct the boot flag argument.
		 */
		flagsp = flags;
		*flagsp++ = '-';
		options = 0;

		if (boothowto & RB_SINGLE) {
			*flagsp++ = 's';
			options = 1;
		}
#ifdef notyet
		if (boothowto & RB_FASTBOOT) {
			*flagsp++ = 'f';
			options = 1;
		}
#endif

		/*
		 * Move out the flags (arg 1), if necessary.
		 */
		if (options != 0) {
			*flagsp++ = '\0';
			i = flagsp - flags;
#ifdef DEBUG
			printf("init: copying out flags `%s' %ld\n", flags, i);
#endif
#ifdef MACHINE_STACK_GROWS_UP
			arg1 = ucp;
			(void)copyout((caddr_t)flags, (caddr_t)ucp, i);
			ucp += i;
#else
			(void)copyout((caddr_t)flags, (caddr_t)(ucp -= i), i);
			arg1 = ucp;
#endif
		}

		/*
		 * Move out the file name (also arg 0).
		 */
		i = strlen(path) + 1;
#ifdef DEBUG
		printf("init: copying out path `%s' %ld\n", path, i);
#endif
#ifdef MACHINE_STACK_GROWS_UP
		arg0 = ucp;
		(void)copyout((caddr_t)path, (caddr_t)ucp, i);
		ucp += i;
		ucp = (caddr_t)ALIGN((u_long)ucp);
		uap = (char **)ucp + 3;
#else
		(void)copyout((caddr_t)path, (caddr_t)(ucp -= i), i);
		arg0 = ucp;
		uap = (char **)((u_long)ucp & ~ALIGNBYTES);
#endif

		/*
		 * Move out the arg pointers.
		 */
		i = 0;
		copyout(&i, (caddr_t)--uap, sizeof(register_t)); /* terminator */
		if (options != 0)
			copyout(&arg1, (caddr_t)--uap, sizeof(register_t));
		copyout(&arg0, (caddr_t)--uap, sizeof(register_t));

		/*
		 * Point at the arguments.
		 */
		SCARG(&args, path) = arg0;
		SCARG(&args, argp) = uap;
		SCARG(&args, envp) = NULL;

		/*
		 * Now try to exec the program.  If can't for any reason
		 * other than it doesn't exist, complain.
		 */
		if ((error = sys_execve(p, &args, retval)) == 0) {
			KERNEL_UNLOCK();
			return;
		}
		if (error != ENOENT)
			printf("exec %s: error %d\n", path, error);
	}
	printf("init: not found\n");
	panic("no init");
}

void
start_update(void *arg)
{
	sched_sync(curproc);
	/* NOTREACHED */
}

void
start_cleaner(void *arg)
{
	buf_daemon(curproc);
	/* NOTREACHED */
}

void
start_reaper(void *arg)
{
	reaper();
	/* NOTREACHED */
}
@


1.267
log
@domaininit() doesn't need splnet().

At this stage the scheduler isn't setup, which means the 'softnet'
isn't running yet, so input packets aren't processed.

Prodded by a question from guenther@@, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.266 2017/02/12 04:55:08 guenther Exp $	*/
d78 1
d219 2
@


1.266
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.265 2017/01/21 05:42:03 guenther Exp $	*/
d194 1
a194 1
	int s, i;
d406 1
a406 2
	 * Initialize protocols.  Block reception of incoming packets
	 * until everything is ready.
a407 1
	s = splnet();
a408 1
	splx(s);
@


1.265
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.264 2017/01/01 07:00:56 jsg Exp $	*/
d440 1
a440 2
		if (fork1(p, FORK_FORK, NULL, 0, start_init, NULL, NULL,
		    &initproc))
@


1.264
log
@copyright++;
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.263 2016/11/14 10:32:46 mpi Exp $	*/
d296 1
a296 1
	strlcpy(p->p_comm, "swapper", sizeof(p->p_comm));
@


1.263
log
@Automatically create a default lo(4) interface per rdomain.

In order to stop abusing lo0 for all rdomains, a new loopback interface
will be created every time a rdomain is created.  The unit number will
be the same as the rdomain, i.e. lo1 will be attached to rdomain 1.

If this loopback interface is already in use it wont be possible to create
the corresponding rdomain.

In order to know which lo(4) interface is attached to a rdomain, its index
is stored in the rtable/rdomain map.

This is a long overdue since the introduction of rtable/rdomain.  It also
fixes a recent regression due to resetting the rdomain of an incoming
packet reported by semarie@@, Andreas Bartelt and Nils Frohberg.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.262 2016/11/07 00:26:32 guenther Exp $	*/
d108 1
a108 1
"Copyright (c) 1995-2016 OpenBSD. All rights reserved.  https://www.OpenBSD.org\n";
@


1.262
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.261 2016/10/24 04:38:44 dlg Exp $	*/
d392 3
a403 2

	rtable_init();
@


1.261
log
@move the mbstat structure to percpu counters

each cpus counters still have to be protected by splnet, but this
is better thana single set of counters protected by a global mutex.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.260 2016/10/21 06:27:50 dlg Exp $	*/
d275 1
d283 1
a283 1
	LIST_INSERT_HEAD(PIDHASH(0), p, p_hash);
@


1.260
log
@add generalised access to per cpu data structures and counters.

both the cpumem and counters api simply allocates memory for each cpu in
the system that can be used for arbitrary per cpu data (via cpumem), or
a versioned set of counters per cpu (counters).

there is an alternate backend for uniprocessor systems that basically
turns the percpu data access into an immediate access to a single
allocation.

there is also support for percpu data structures that are available at
boot time by providing an allocation for the boot cpu. after autoconf,
these allocations have to be resized to provide for all cpus that were
enumerated by boot.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.259 2016/09/22 12:55:24 mpi Exp $	*/
d417 2
@


1.259
log
@Introduce a new 'softclock' thread that will be used to execute timeout
callbacks needing a process context.

The function timeout_set_proc(9) has to be used instead of timeout_set(9)
when a timeout callback needs a process context.

Note that if such a timeout is waiting, understand sleeping, for a non
negligible amount of time it might delay other timeouts needing a process
context.

dlg@@ agrees with this as a temporary solution.

Manpage tweaks from jmc@@

ok kettenis@@, bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.258 2016/09/18 12:36:28 jasper Exp $	*/
d149 1
d363 3
@


1.258
log
@add missing call to db_ctf_init().

this was part of the larger diff that was ok guenther@@ mpi@@, somehow I forgot
to commit this particular piece.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.257 2016/09/04 09:22:29 mpi Exp $	*/
d147 1
d339 3
@


1.257
log
@Introduce Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

Currently only available on amd64 and guarded under DDBPROF.  Support
for other archs will follow soon.

A new sysctl knob, ddb.console, need to be set to 1 in securelevel 0
to be able to use this feature.

Inputs and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.256 2016/09/03 14:46:56 naddy Exp $	*/
d142 1
d533 4
@


1.256
log
@Write the system time back to the RTC every 30 minutes.
This fixes the problem that long-running machines which were not
shut down properly would reboot with a badly offset system time.

hints and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.255 2016/09/03 13:16:50 deraadt Exp $	*/
d142 1
d404 1
a404 1
#ifdef GPROF
d406 1
a406 1
	kmstartup();
@


1.255
log
@Do not reinitialize __guard_local if it is 0.  This cannot be done
anymore, since it is now RO.

It is the bootloader's job to initialize it correctly.  If the
bootloader fails to perform that, you silently lose.  The road to
building an always-available rng is served by us depending on it :)
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.254 2016/09/02 12:17:33 tb Exp $	*/
d544 2
@


1.254
log
@move links from http to https://www.openbsd.org/

ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.253 2016/05/17 23:28:03 bluhm Exp $	*/
a405 9
#endif

#if !defined(NO_PROPOLICE)
	if (__guard_local == 0) {
		volatile long newguard;

		arc4random_buf((void *)&newguard, sizeof newguard);
		__guard_local = newguard;
	}
@


1.253
log
@Backout the previous fix for the sendsyslog(2) with LOG_CONS solution.
Permanently holding /dev/console open in the kernel works only until
init(8) calls revoke(2).  After that the console device vnode cannot
be used anymore.  It still resulted in a hanging init(8) if it tried
to syslog(3) something.  With the backout also dmesg -s works again.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.252 2016/05/10 23:54:00 bluhm Exp $	*/
d108 1
a108 1
"Copyright (c) 1995-2016 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.252
log
@If sendsyslog(2) is called with LOG_CONS before syslogd(8) has been
started and before init(8) has opened the console, the kernel could
crash as the console device has not been initialized.  Open
/dev/console in the kernel before starting init(8) and keep it open.
This way sendsyslog(2) can be called early in the system.
OK beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.251 2016/05/10 18:39:51 deraadt Exp $	*/
d123 1
a123 1
struct	vnode *rootvp, *swapdev_vp, *consolevp;
d136 1
a136 1
void	open_console(struct proc *);
d573 1
a573 1
open_console(struct proc *p)
a575 1
	struct vnode *vp;
d579 1
a579 1
	error = vn_open(&nd, FWRITE, 0);
d585 2
a586 11
		return;
	}
	vp = nd.ni_vp;
	VOP_UNLOCK(vp, p);
	if (!ISSET(vp->v_flag, VISTTY)) {
		printf("warning: /dev/console is not a tty device\n");
		vn_close(vp, FWRITE, p->p_ucred, p);
		return;
	}

	consolevp = vp;
d619 1
a619 1
	open_console(p);
@


1.251
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.250 2016/05/03 14:52:39 mpi Exp $	*/
d123 1
a123 1
struct	vnode *rootvp, *swapdev_vp;
d136 1
a136 1
void	check_console(struct proc *);
d573 1
a573 1
check_console(struct proc *p)
d576 1
d580 1
a580 1
	error = namei(&nd);
d586 11
a596 2
	} else
		vrele(nd.ni_vp);
d629 1
a629 1
	check_console(p);
@


1.250
log
@Stop using a soft-interrupt context to process incoming network packets.

Use a new task that runs holding the KERNEL_LOCK to execute mp-unsafe
code.  Our current goal is to progressively move input functions to the
unlocked task.

This gives a small performance boost confirmed by Hrvoje Popovski's
IPv4 forwarding measurement:

before:					after:

send           receive			send           receive
400kpps        400kpps                  400kpps        400kpps
500kpps        500kpps                  500kpps        500kpps
600kpps        600kpps                  600kpps        600kpps
650kpps        650kpps                  650kpps        640kpps
700kpps        700kpps                  700kpps        700kpps
720kpps        640kpps                  720kpps        710kpps
800kpps        640kpps                  800kpps        650kpps
1.4Mpps        570kpps                  1.4Mpps        590kpps
14Mpps         570kpps                  14Mpps         590kpps


ok kettenis@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.249 2016/03/19 12:04:15 natano Exp $	*/
d147 1
a147 1
extern char sigcode[], esigcode[];
d171 1
@


1.249
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.248 2016/01/03 00:15:59 jsg Exp $	*/
a396 1
	netisr_init();
@


1.248
log
@copyright++;
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.247 2015/12/11 16:07:02 mpi Exp $	*/
d480 1
a480 1
	VOP_UNLOCK(rootvnode, 0, p);
@


1.247
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.246 2015/11/08 20:45:57 naddy Exp $	*/
d108 1
a108 1
"Copyright (c) 1995-2015 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.246
log
@keep all the setperf timeout(9) handling in one place; ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.245 2015/10/07 10:50:35 mpi Exp $	*/
d539 1
a539 1
	domountroothooks();
@


1.245
log
@Initialize the routing table before domains.

The routing table is not an optional component of the network stack
and initializing it inside the "routing domain" requires some ugly
introspection in the domain interface.

This put the rtable* layer at the same level of the if* level.  These
two subsystem are organized around the two global data structure used
in the network stack:

- the global &ifnet list, to be used in process context only, and
- the routing table which can be read in interrupt context.

This change makes the rtable_* layer domain-aware and extends the
"struct domain" such that INET, INET6 and MPLS can specify the length
of the binary key used in lookups.  This allows us to keep, or move
towards, AF-free route and rtable layers.

While here stop the madness and pass the size of the maximum key length
in *byte* to rn_inithead0().

ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.244 2015/08/30 10:39:16 mpi Exp $	*/
a120 5
#ifndef SMALL_KERNEL
extern struct timeout setperf_to;
void setperf_auto(void *);
#endif

a545 4

#ifndef SMALL_KERNEL
	timeout_set(&setperf_to, setperf_auto, NULL);
#endif
@


1.244
log
@Use a global table for domains instead of building a list at run time.

As a side effect there's no need to run if_attachdomain() after the
list of domains has been built.

ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.243 2015/07/09 19:45:37 miod Exp $	*/
d89 1
d394 3
a396 1
	
@


1.243
log
@Disable pool_gc on m88k if MULTIPROCESSOR; we don't have enough volunteers
for human sacrifices to get this fixed in a reasonably near future, and the
tree must build.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.242 2015/07/02 01:34:00 dlg Exp $	*/
a400 1
	if_attachdomain();
@


1.242
log
@introduce srp, which according to the manpage i wrote is short for
"shared reference pointers".

srp allows concurrent access to a data structure by multiple cpus
while avoiding interlocking cpu opcodes. it manages its own reference
counts and the garbage collection of those data structure to avoid
use after frees.

internally srp is a twisted version of hazard pointers, which are
a relative of RCU.

jmatthew wrote the bulk of a hazard pointer implementation and
changed bpf to use it to allow mpsafe access to bpfilters. however,
at s2k15 we were trying to apply it to other data structures but
the memory overhead of every hazard pointer would have blown out
significantly in several uses cases. a bulk of our time at s2k15
was spent reworking hazard pointers into srp.

this diff adds the srp api and adds the necessary metadata to struct
cpuinfo on our MP architectures. srp on uniprocessor platforms has
alternate code that is optimised because it knows there'll be no
concurrent access to data by multiple cpus.

srp is made available to the system via param.h, so it should be
available everywhere in the kernel.

the docs likely need improvement cos im too close to the implementation.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.241 2015/06/24 03:42:08 dlg Exp $	*/
d557 1
d559 1
@


1.241
log
@reenable the pool gc task.

the problems it tickled by working outside the biglock on archs
with mutex and clock interaction have been fixed, as evidenced by
the softnet taskq.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.240 2015/05/18 04:07:26 miod Exp $	*/
d236 3
@


1.240
log
@Reenable the page zeroing thread on MP m88k kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.239 2015/05/05 02:13:46 guenther Exp $	*/
a553 1
#if notyet
a554 1
#endif
@


1.239
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.238 2015/05/01 11:18:21 miod Exp $	*/
d528 1
a528 2
#if !defined(__hppa__) && \
    !(defined(__m88k__) && defined(MULTIPROCESSOR))
@


1.238
log
@reenable page zeroing thread on SMP mips kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.237 2015/04/12 11:12:09 dlg Exp $	*/
a41 1
#include <sys/core.h>
d171 2
a172 2
	NULL,
	coredump_trad,
@


1.237
log
@disable the pool gc. there are reports of strange lockups on various mp
archs and this is the only interesting diff in the window.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.236 2015/04/07 11:07:56 dlg Exp $	*/
d530 1
a530 1
    !((defined(__m88k__) || defined(__mips64__)) && defined(MULTIPROCESSOR))
@


1.236
log
@introduce a garbage collector for (very) idle pool pages.

now that idle pool pages are timestamped we can tell how long theyve
been idle. this adds a task that runs every second that iterates
over all the pools looking for pages that have been idle for 8
seconds so it can free them.

this idea probably came from a conversation with tedu@@ months ago.

ok tedu@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.235 2015/02/10 05:28:18 guenther Exp $	*/
d556 1
d558 1
@


1.235
log
@Factor out the common bits of process_new() and main()'s code for
setting up process0, 'cause I'm sick of forgetting to update main()
when touching process_new()

ok blambert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.234 2015/02/09 09:39:09 miod Exp $	*/
d150 1
d552 5
@


1.234
log
@Stop using USRSTACK as the edge of the stack, but rather use the vmspace
vm_minsaddr or vm_maxsaddr, depending upon the direction the stack goes in.

This should have no effect on the existing behaviourrr.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.233 2015/01/19 01:19:17 deraadt Exp $	*/
d260 4
d267 2
a269 5
	process0.ps_mainproc = p;
	TAILQ_INIT(&process0.ps_threads);
	TAILQ_INSERT_TAIL(&process0.ps_threads, p, p_thr_link);
	process0.ps_refcnt = 1;
	p->p_p = pr = &process0;
a294 8
	timeout_set(&pr->ps_realit_to, realitexpire, pr);

	/* Create credentials. */
	pr->ps_ucred = crget();
	pr->ps_ucred->cr_ngroups = 1;	/* group 0 */

	p->p_ucred = pr->ps_ucred;	/* prime the thread's cache */
	crhold(p->p_ucred);
@


1.233
log
@unneccessary cmask variable; ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.232 2015/01/13 18:51:27 kettenis Exp $	*/
d637 2
a643 1
	p->p_vmspace->vm_maxsaddr = (caddr_t)addr;
@


1.232
log
@Many architectures call initmsgbuf() really really early, before uvm is
initialized.  Calling malloc(9) at that point is not a good idea.  So
initialize consbuf later.

Fixes dmesg -s on sparc64 (and probably a few other architectures).

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.231 2014/12/31 15:32:05 jsing Exp $	*/
a125 1
int	cmask = CMASK;
@


1.231
log
@copyright_year=$(date +%Y)
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.230 2014/12/28 21:32:45 krw Exp $	*/
d75 1
d408 2
@


1.230
log
@The greatest happiness is to scatter inferiour APIs, to drive them
before you, to see their files reduced to ashes, to see those who
love them shrouded in tears, and to gather into your API all their
invocations.

In other words, workq is no more. There is only taskq.

ok kettenis@@ dlg@@ (creator of taskq) jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.229 2014/12/17 06:58:11 guenther Exp $	*/
d107 1
a107 1
"Copyright (c) 1995-2014 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.229
log
@Prefer MADV_* over POSIX_MADV_* in kernel for consistency: the latter
doesn't have all the values and therefore can't be used everywhere.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.228 2014/12/16 18:30:03 tedu Exp $	*/
a76 1
#include <sys/workq.h>
a148 1
void	workq_init(void);
d344 1
a344 2
	/* Initialize work queues */
	workq_init();
@


1.228
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.227 2014/12/15 02:24:23 guenther Exp $	*/
d641 1
a641 1
	    POSIX_MADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW)))
@


1.227
log
@Use MAP_INHERIT_* for the 'inh' argument to the UMV_MAPFLAG() macro,
eliminating the must-be-kept-in-sync UVM_INH_* macros

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.226 2014/12/10 02:44:46 tedu Exp $	*/
d82 2
@


1.226
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.225 2014/11/18 21:11:08 miod Exp $	*/
d638 1
a638 1
	    UVM_MAPFLAG(PROT_READ | PROT_WRITE, PROT_MASK, UVM_INH_COPY,
@


1.225
log
@Disable the page zeroing thread on MULTIPROCESSOR mips64 kernels as well.
Regression spotted by tobiasu@@.

XXX I wonder if the page zeroing thread shouldn't perform explicit
XXX pmap_update(pmap_kernel()) calls after each page zeroing... but that
XXX might not be enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.224 2014/11/16 12:31:00 deraadt Exp $	*/
d290 1
a290 1
	bcopy("swapper", p->p_comm, sizeof ("swapper"));
@


1.224
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.223 2014/10/25 12:53:14 miod Exp $	*/
d534 2
a535 1
#if !defined(__hppa__) && !(defined(__m88k__) && defined(MULTIPROCESSOR))
@


1.223
log
@Do not launch the page zeroing thread on MULTIPROCESSOR m88k systems. This
causes a deadlock between reaper and zerothread I am currently investigating.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.222 2014/10/17 01:51:39 tedu Exp $	*/
d637 2
a638 2
	    UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_ALL, UVM_INH_COPY,
	    UVM_ADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW)))
@


1.222
log
@redo the performance throttling in the kernel.
introduce a new sysctl, hw.perfpolicy, that governs the policy.
when set to anything other than manual, hw.setperf then becomes read only.
phessler was heading in this direction, but this is slightly different. :)
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.221 2014/10/13 22:42:22 deraadt Exp $	*/
d534 1
a534 1
#ifndef __hppa__
@


1.221
log
@disable pagezero thread on hppa, until failure gets diagnosed, ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.220 2014/10/11 17:12:30 deraadt Exp $	*/
d119 5
d552 4
@


1.220
log
@back out; does not even compile
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.218 2014/10/03 18:06:46 kettenis Exp $	*/
d529 1
d533 1
@


1.219
log
@resurrect a many year old diff. move CPU throttling into the kernel,
enabled by setting hw.setperf=-1. some other bugs preventing this from
going in before have been fixed. my thanks to phessler for keeping the
diff alive in the mean time. tested by several to not regress.
@
text
@a118 5
#ifndef SMALL_KERNEL
extern struct timeout setperf_to;
void auto_setperf(void *);
#endif

a544 4

#ifndef SMALL_KERNEL
	timeout_set(&setperf_to, auto_setperf, NULL);
#endif
@


1.218
log
@Introduce a thread for zeroing pages without holding the kernel lock.  This
way we can do some useful kernel lock in parallel with other things and create
a reservoir of zeroed pages ready for use elsewhere.  This should reduce
latency.  The thread runs at the absolutel lowest priority such that we don't
keep other kernel threads or userland from doing useful work.

Can be easily disabled by disabling the kthread_create(9) call in main().
Which perhaps we should do for non-MP kernels.

ok deraadt@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.217 2014/08/14 09:01:47 mpi Exp $	*/
d119 5
d550 4
@


1.217
log
@No need for raw_cb.h
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.216 2014/07/11 08:18:31 guenther Exp $	*/
d528 4
@


1.216
log
@It's init as a process that's special, not init's original thread.
Remember initprocess instead of initproc.

ok matthew@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.215 2014/07/08 17:19:25 deraadt Exp $	*/
a87 1
#include <net/raw_cb.h>
@


1.215
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.214 2014/06/15 11:43:24 sf Exp $	*/
d117 1
a117 1
struct	proc *initproc;
d434 8
a441 3
	if (fork1(p, FORK_FORK, NULL, 0, start_init, NULL, NULL,
	    &initproc))
		panic("fork init");
d447 1
a447 1
	 * initproc had not yet been created.
d486 1
a486 1
	 * Now that root is mounted, we can fixup initproc's CWD
d490 3
a492 3
	initproc->p_fd->fd_cdir = rootvnode;
	vref(initproc->p_fd->fd_cdir);
	initproc->p_fd->fd_rdir = NULL;
@


1.214
log
@Fix a few format string bugs with -DDEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.213 2014/05/15 03:52:25 guenther Exp $	*/
a85 3


#include <uvm/uvm_extern.h>
@


1.213
log
@Move from struct proc to process the reference-count-holding pointers
to the process's vmspace and filedescs.  struct proc continues to
keep copies of the pointers, copying them on fork, clearing them
on exit, and (for vmspace) refreshing on exec.
Also, make uvm_swapout_threads() thread aware, eliminating p_swtime
in kernel.

particular testing by ajacoutot@@ and sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.212 2014/05/04 05:03:26 guenther Exp $	*/
d657 1
a657 1
			printf("init: copying out flags `%s' %d\n", flags, i);
d674 1
a674 1
		printf("init: copying out path `%s' %d\n", path, i);
@


1.212
log
@Add PS_SYSTEM, the process-level mirror of the thread-level P_SYSTEM,
and FORK_SYSTEM as a flag to set them.  This eliminates needing to
peek into other processes threads in various places.  Inspired by NetBSD

ok miod@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.211 2014/04/18 11:51:17 guenther Exp $	*/
d308 1
a308 1
	p->p_fd = fdinit(NULL);
d328 1
a328 1
	p->p_vmspace = &vmspace0;
@


1.211
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.210 2014/03/31 19:37:15 kettenis Exp $	*/
d269 1
@


1.210
log
@Grab the kernel lock before autoconf.  This way device drivers can drop it in
any context if they feel like it.

ok deraadt@@, guenther@@
(who both suggested we could probably grab it even earlier)
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.209 2014/03/30 21:54:48 guenther Exp $	*/
d297 3
@


1.209
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.208 2014/03/29 18:09:31 guenther Exp $	*/
d346 3
a367 3

	/* Lock the kernel on behalf of proc0. */
	KERNEL_LOCK();
@


1.208
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.207 2014/03/28 17:57:11 mpi Exp $	*/
a116 1
struct	pcred cred0;
d295 2
a296 3
	p->p_cred = &cred0;
	p->p_ucred = crget();
	p->p_ucred->cr_ngroups = 1;	/* group 0 */
@


1.207
log
@Reduce uvm include madness.  Use <uvm/uvm_extern.h> instead of
<uvm/uvm.h> if possible and remove double inclusions.

ok beck@@, mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.206 2014/03/26 05:23:42 guenther Exp $	*/
d132 1
a132 1
__volatile int start_init_exec;		/* semaphore for start_init() */
@


1.206
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.205 2014/03/22 06:05:45 guenther Exp $	*/
d88 1
a88 1
#include <uvm/uvm.h>
@


1.205
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.204 2014/02/12 05:47:36 guenther Exp $	*/
d288 1
a288 1
	p->p_emul = &emul_native;
@


1.204
log
@Eliminate the exit sig handling, which was only invokable via the
Linux-compat clone() syscall when *not* using CLONE_THREAD.  pirofti@@
confirms Opera runs in compat without this, so out it goes; one less hair
to choke on in kern_exit.c

ok tedu@@ pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.203 2014/01/20 21:19:27 guenther Exp $	*/
d302 2
a303 2
	p->p_sigacts = &sigacts0;
	siginit(p);
d607 1
a607 1
	p->p_sigacts->ps_flags = 0;
@


1.203
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.202 2014/01/19 23:52:54 deraadt Exp $	*/
d435 1
a435 1
	if (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, start_init, NULL, NULL,
@


1.202
log
@Refactor rnd startup so arc4random/arc4random_buf can create a chacha state
on first call, very early on, from boot-supplied entropy, then feed from
that.  Later when we have more subsystems ready, the main() can properly
initialize the entropy-driven model.  Lots of discussion with mikeb.
ok kettenis markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.201 2014/01/19 13:26:42 deraadt Exp $	*/
d269 1
d496 6
a501 4
	LIST_FOREACH(p, &allproc, p_list) {
		p->p_p->ps_start = boottime;
		nanouptime(&p->p_cpu->ci_schedstate.spc_runtime);
		timespecclear(&p->p_rtime);
@


1.201
log
@insane typo
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.200 2014/01/19 13:12:07 deraadt Exp $	*/
a219 2

	random_init();
@


1.200
log
@oops, forgotten part
Initialize ci_randseed better using arc4random() + a trick.  Remove the
libkern srandom() API since it is not suitable for this use.
ok kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.200 2014/01/19 13:07:49 deraadt Exp $	*/
d340 1
a340 1
	p->p_curcpu->ci_randseed = (arc4random() & 0x7fffffff) + 1;
@


1.199
log
@With the earlier initialization of the random subsystem, random_hostseed()
is no longer providing significant value.  The random subsystem is in
pretty good state, and moments later userland will feed the dmesg.
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.198 2014/01/19 00:22:58 deraadt Exp $	*/
d340 1
a340 1
	srandom(arc4random());
@


1.198
log
@We can call random_start() immediately after cpu_startup, that is the
point at which everything it does is safe, including msg buffer access.
ok kettenis jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.197 2014/01/01 07:08:10 fgsch Exp $	*/
a355 2

	random_hostseed();
@


1.197
log
@copyright++
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.196 2013/12/28 20:52:48 deraadt Exp $	*/
d228 2
a339 2

	random_start();
@


1.196
log
@oops, the fallback stack protector code must handle 64-bit guards
spotted by kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.195 2013/12/28 03:22:52 deraadt Exp $	*/
d110 1
a110 1
"Copyright (c) 1995-2013 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.195
log
@change the stack protector guard into a long word (removing the old legacy
compat pointed out by miod), and place it inside the ELF .openbsd.randomdata
segment.  Inside main(), only re-initialize the guard if the bootblocks
failed to initialize it for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.194 2013/12/28 03:12:56 deraadt Exp $	*/
d418 1
a418 1
		newguard = arc4random();
@


1.194
log
@We can initialize the srandom/random system earlier from arc4random,
and do not need microtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.193 2013/12/28 03:04:20 deraadt Exp $	*/
d135 1
a135 4
#ifdef __ELF__
long	__guard_local __dso_hidden;
#endif
long	__guard[8];
d415 2
a416 4
	{
		volatile long newguard[8];

		arc4random_buf((long *)newguard, sizeof(newguard));
d418 2
a419 5
#ifdef __ELF__
		__guard_local = newguard[0];
#endif
		for (i = nitems(__guard) - 1; i; i--)
			__guard[i] = newguard[i];
@


1.193
log
@We can random_start() earlier (not that it does too much) and call
arc4random() much earlier.  Leading to random pids for anything
besides 0 and 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.192 2013/12/01 16:40:56 krw Exp $	*/
a194 1
	struct timeval rtv;
a348 2
	random_start();

a533 3

	microtime(&rtv);
	srandom((u_int32_t)(rtv.tv_sec ^ rtv.tv_usec) ^ arc4random());
@


1.192
log
@Change 'mountlist' from CIRCLEQ to TAILQ. Be paranoid and
use TAILQ_*_SAFE more than might be needed.

Bulk ports build by sthen@@ showed nobody sticking their fingers
so deep into the kernel.

Feedback and suggestions from millert@@. ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.191 2013/10/29 04:23:16 dlg Exp $	*/
d343 3
d453 2
a539 2

	randompid = 1;
@


1.191
log
@introduce tasks and taskqs as an alternative to workqs.

tasks are modelled on the timeout api, so users familiar with
timeout_set, timeout_add, and timeout_del will already know what
to expect from task_set, task_add, and task_del.

i wrote this because workq_add_task can fail in the place you
actually need it, and there arent any good ways of recovering at
that point.  workq_queue_task was added to try and help, but required
external state to be stored for users of that api to know whether
something was already queued or not.

workqs also didnt provide a way to cancel or remove work.

this has been percolating with a bunch of people. putting it in as i
wrote it so i can apply their feedback to the code with the history kept
in cvs.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.190 2013/08/26 01:59:22 dlg Exp $	*/
d480 1
a480 1
	CIRCLEQ_FIRST(&mountlist)->mnt_flag |= MNT_ROOTFS;
d483 1
a483 1
	if (VFS_ROOT(CIRCLEQ_FIRST(&mountlist), &rootvnode))
@


1.190
log
@move attach mpath before any hardware. the benefits being:

- the mpath hooks path drivers call dont have to parse autoconf
structures to tell if mpath may attach in the future. it now either
has already attached or never will, which is simpler to check.

- i can get rid of the global mpath target array by moving it into
the mpath softc because of the above.

- makes reasoning about state transitions (especially around when
to attach) when groups of paths are implemented a lot simpler

the only real caveat is dmesg feng shui may be ruined. i can come
back and look at this after i move mpath itself forward though.

discussed with deraadt@@ miod@@
ok todd@@ matthew@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.189 2013/06/03 16:55:22 guenther Exp $	*/
d78 1
d152 1
d345 1
@


1.189
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.188 2013/03/28 16:55:25 deraadt Exp $	*/
d349 5
a463 3
#if NMPATH > 0
	config_rootfound("mpath", NULL);
#endif
@


1.188
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.187 2013/03/25 14:58:28 markus Exp $	*/
d128 1
a128 1
struct	timeval boottime;
d499 1
a499 1
	microtime(&boottime);
d502 2
a503 2
		microuptime(&p->p_cpu->ci_schedstate.spc_runtime);
		p->p_rtime.tv_sec = p->p_rtime.tv_usec = 0;
@


1.187
log
@reseed the random pool with 'dmesg' when more devices are attached
from hshoexer@@; ok tedu@@, "looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.186 2013/01/01 19:39:50 jasper Exp $	*/
a85 1
#include <machine/cpu.h>
@


1.186
log
@copyright++;
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.185 2012/11/05 19:39:34 miod Exp $	*/
d352 2
@


1.185
log
@unifdef -D __HAVE_TIMECOUNTER
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.184 2012/08/28 16:39:09 matthew Exp $	*/
d110 1
a110 1
"Copyright (c) 1995-2012 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.184
log
@Add __guard_local as a hidden symbol to ld.so, kernel, and every
executable and DSO (via crtbegin.c/crtbeginS.c).  Not used yet, but
needed before GCC can start emitting -fstack-protector code that uses
them instead of __guard.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.183 2012/06/13 22:47:39 ariane Exp $	*/
a497 1
#ifdef __HAVE_TIMECOUNTER
a498 3
#else
	boottime = mono_time = time;	
#endif
@


1.183
log
@Expose reaperproc.

I need this for my diffs.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.182 2012/03/23 15:51:26 guenther Exp $	*/
d135 3
d414 3
@


1.182
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.181 2012/01/01 12:17:33 fgsch Exp $	*/
d122 1
d510 1
a510 1
	if (kthread_create(start_reaper, NULL, NULL, "reaper"))
@


1.181
log
@copyright++
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.180 2011/07/07 18:00:33 guenther Exp $	*/
d291 1
a291 1
	timeout_set(&p->p_realit_to, realitexpire, p);
a328 6
	 * We continue to place resource usage info in the
	 * user struct so they're pageable.
	 */
	p->p_stats = &p->p_addr->u_stats;

	/*
d497 1
a497 1
		p->p_stats->p_start = boottime;
@


1.180
log
@Functions used in files other than where they are defined should be
declared in .h files, not in each .c.  Apply that rule to endtsleep(),
scheduler_start(), updatepri(), and realitexpire()

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.179 2011/07/06 21:41:37 art Exp $	*/
d110 1
a110 1
"Copyright (c) 1995-2011 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.179
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.178 2011/07/05 04:48:02 guenther Exp $	*/
a193 1
	extern void scheduler_start(void);
a194 2
	extern void endtsleep(void *);
	extern void realitexpire(void *);
@


1.178
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.177 2011/04/18 21:44:56 guenther Exp $	*/
d371 1
a371 1
	KERNEL_PROC_LOCK(p);
d719 1
a719 1
			KERNEL_PROC_UNLOCK(p);
@


1.177
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.175 2011/03/07 07:07:13 guenther Exp $	*/
d286 1
a286 1
	atomic_setbits_int(&p->p_flag, P_SYSTEM | P_NOCLDWAIT);
d617 3
@


1.176
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d286 1
a286 1
	atomic_setbits_int(&p->p_flag, P_SYSTEM);
a616 3

	/* process 0 ignores SIGCHLD, but we can't */
	p->p_sigacts->ps_flags = 0;
@


1.175
log
@The scheduling 'nice' value is per-process, not per-thread, so move it
into struct process.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.174 2011/01/08 19:45:09 deraadt Exp $	*/
d286 1
a286 1
	atomic_setbits_int(&p->p_flag, P_SYSTEM | P_NOCLDWAIT);
d617 3
@


1.174
log
@split randomattach into random_init() and random_start(), so that we
can make attempts to load 'entropy' into the RC4.
ok miod ariane
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.173 2011/01/01 06:54:51 deraadt Exp $	*/
d288 1
a288 1
	p->p_nice = NZERO;
@


1.173
log
@copyright++;
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.172 2010/12/21 14:56:24 claudio Exp $	*/
d223 2
d350 2
a388 1
	randomattach();
@


1.172
log
@Convert netisr to a normal soft interrupt instead of hanving MD code
for it. This makes the netisr a real C function which will help further
development. No noticable performance change on i386 and amd64.
With input from kettenis@@ and miod@@ additional OKs mikeb@@ and henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.171 2010/09/08 14:15:56 jsing Exp $	*/
d110 1
a110 1
"Copyright (c) 1995-2010 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.171
log
@Reintroduce most crypto/crypto.c r1.55:

Move pool initialization to init_crypto and zap the crypto_pool_initialized
variable. This way we don't have to check if the pool are initialized every
time we do a crypto_getreq().

However, also perform the crypto initialisation earlier in init_main so
that the crypto pools are initialised before they are used.

ok mikeb@@ thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.169 2010/07/03 04:44:51 guenther Exp $	*/
d92 1
d400 1
@


1.170
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d143 1
a143 1
void	init_crypto(void);
d390 1
a526 5

#ifdef CRYPTO
	/* Create the crypto kernel thread. */
	init_crypto();
#endif /* CRYPTO */
@


1.169
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.168 2010/06/29 20:25:57 guenther Exp $	*/
d187 1
d267 1
a267 1
	p->p_p = &process0;
d273 1
a273 1
	p->p_pgrp = &pgrp0;
d277 1
a277 1
	LIST_INSERT_HEAD(&pgrp0.pg_members, p, p_pglist);
d281 1
a281 1
	session0.s_leader = p;
d307 1
a307 1
	p->p_p->ps_limit = &limit0;
@


1.168
log
@We always copy struct pcred when creating a new process, so the reference
count was always one.  That's pointless, so remove the member and the code.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.167 2010/05/14 18:47:56 kettenis Exp $	*/
d268 2
a269 2
	/* Set the default routing domain. */
	process0.ps_rdomain = 0;
@


1.167
log
@Make sure we initialize sched_lock before we try to use it.

ok miod@@, thib@@, oga@@, jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.166 2010/01/12 04:06:26 deraadt Exp $	*/
a292 1
	cred0.p_refcnt = 1;
@


1.166
log
@Since ifinit() is now safe to be called earlier, call it just before
configure(), since some upcoming changes will require it.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.165 2010/01/01 13:13:58 miod Exp $	*/
d219 1
@


1.165
log
@copyright++;
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.164 2009/12/23 07:40:31 guenther Exp $	*/
d346 3
a396 1
	ifinit();
@


1.164
log
@The process's rdomain should be, well, per-process and not per-rthread,
so put it in struct process instead of struct proc.  While at it,
move the p_emul member inside struct proc so that it gets copied
automatically instead of requiring manual assignment.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.163 2009/11/27 20:05:50 guenther Exp $	*/
d109 1
a109 1
"Copyright (c) 1995-2009 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.163
log
@Add setrdomain() and getrdomain() system calls.  Committing now to
catch the libc major bump per request from deraadt@@

Diff by reyk.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.162 2009/08/11 18:43:33 blambert Exp $	*/
d267 3
a318 3

	/* Set the default routing domain. */
	p->p_rdomain = 0;
@


1.162
log
@uvm_scheduler() sounds important, but ``while(1) tsleep()'' is kinda lame

inline the loop in the one place it exists, and remove it from uvm

adjust a comment mentioning it accordingly

originally inspired by a diff fixing a comment from oga@@

ok art@@ beck@@ miod@@ oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.161 2009/08/09 12:47:23 dlg Exp $	*/
d316 3
@


1.161
log
@add mpath(4), a driver that steals paths to scsi devices if it
thinks they could be available via multiple paths. those stolen
devices are then made available via mpath(4).

this is the minimum amount of code to implement the stealing. it
is generally broken and very brittle, so it is currently disabled.

it is going in so i can work on it in the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.158 2009/03/05 19:52:24 kettenis Exp $	*/
d544 5
a548 2
	/* The scheduler is an infinite loop. */
	uvm_scheduler();
@


1.160
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d102 1
d448 3
@


1.159
log
@Count number of cpus found (potentially not attached) and store that
in sysctl hw.ncpufound; ok miod kettenis
@
text
@d466 1
a466 1
	VREF(p->p_fd->fd_cdir);
d476 1
a476 1
	VREF(initproc->p_fd->fd_cdir);
@


1.158
log
@Make ELF platforms generate ELF core dumps.  Somewhat based on code from
NetBSD.

ok kurt@@, drahn@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.157 2009/02/13 19:58:27 deraadt Exp $	*/
d128 1
@


1.157
log
@use nitems(); dunnoseriously@@gmail
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.156 2009/01/01 15:45:09 miod Exp $	*/
d42 1
d167 1
@


1.156
log
@copyright_year++;
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.155 2008/12/03 23:39:32 dlg Exp $	*/
d300 1
a300 1
	for (i = 0; i < sizeof(p->p_rlimit)/sizeof(p->p_rlimit[0]); i++)
d403 1
a403 1
		for (i = sizeof(__guard)/sizeof(__guard[0]) - 1; i; i--)
@


1.155
log
@add vscsi(4), a virtual scsi controller that passes all scsi requests up to
userland for handling. this is to scsi what tun(4) is for networks.

this is going into the tree so i can work on some crazy scsi stuff, but its
not being enabled since it is useless unless you're working on some crazy
scsi stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.153 2008/10/14 18:27:29 guenther Exp $	*/
d107 1
a107 1
"Copyright (c) 1995-2008 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.154
log
@make random(9) return per-cpu values (by saving the seed in the cpuinfo),
which are uniform for the profclock on each cpu in a SMP system (but using
a different seed for each cpu).  on all cpus, avoid seeding with a value out
of the [0, 2^31-1] range (since that is not stable)
ok kettenis drahn
@
text
@d101 1
d444 3
@


1.153
log
@Back-in; problems were apparently elsewhere.
Put a reference count in struct process to prevent use-after-free
if the main thread reaches the reaper ahead of some other thread
in the process.  Use the reference count to update the user process
count correctly when changin real uid.

"please re-commit before something else nasty comes in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.152 2008/10/10 14:35:06 deraadt Exp $	*/
d516 1
a516 1
	srandom((u_long)(rtv.tv_sec ^ rtv.tv_usec));
@


1.152
log
@backout; is causing some people difficulty
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.150 2008/06/09 07:07:16 djm Exp $	*/
d259 1
@


1.151
log
@Put a reference count in struct process to prevent use-after-free
if the main thread reaches the reaper ahead of some other thread
in the process.

ok art@@ tedu@@
@
text
@a258 1
	process0.ps_refcnt = 1;
@


1.150
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.149 2008/05/06 17:19:40 thib Exp $	*/
d259 1
@


1.149
log
@retire vfs_mountroot();

setroot() is now (and has been) responsible for setting
the mountroot function pointer "to the right thing", or
failing todo that, to ffs_mountroot;

based on a discussion/diff from deraadt@@.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.148 2008/01/01 16:31:42 miod Exp $	*/
d399 1
a399 1
		arc4random_bytes((long *)newguard, sizeof(newguard));
@


1.148
log
@Welcome to the jungle of 2008.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.147 2007/11/25 15:56:17 tedu Exp $	*/
d449 1
a449 2
	/* Mount the root file system. */
	if (vfs_mountroot())
d451 1
@


1.147
log
@convert crypto thread to workq.  add WQ_DIRECTOK flag to workq.
combined, this lets us use crypto before the thread is running
and therefore cryptoraid can attach nice and early.
ok/testing deraadt mbalmer marco
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.146 2007/10/16 23:41:42 fgsch Exp $	*/
d106 1
a106 1
"Copyright (c) 1995-2007 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.146
log
@more remove unneeded declarations that shadows existing vars; ok by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.145 2007/10/10 15:53:53 art Exp $	*/
d139 1
a139 1
void	start_crypto(void *);
d511 1
a511 2
	if (kthread_create(start_crypto, NULL, NULL, "crypto"))
		panic("crypto thread");
a723 9

#ifdef CRYPTO
void
start_crypto(void *arg)
{
	crypto_thread();
	/* NOTREACHED */
}
#endif /* CRYPTO */
@


1.145
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.144 2007/09/10 18:49:45 miod Exp $	*/
a397 1
		int i;
@


1.144
log
@Introduce a md pmap hook, pmap_remove_holes(), which is supposed to mark
the holes a MMU may have from a given vm_map. This will be automagically
invoked for newly created vmspaces.

On platforms with MMU holes (e.g. sun4, sun4c and vax), this prevents
mmap(2) hints which would end up being in the hole to be accepted as valid,
causing unexpected signals when the process tries to access the hole
(since pmap can not fill the hole anyway).

Unfortunately, the logic mmap() uses to pick a valid address for anonymous
mappings needs work, as it will only try to find an address higher than the
hint, which causes all mmap() with a hint in the hole to fail on vax. This
will be improved later.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.143 2007/07/25 23:11:52 art Exp $	*/
d330 3
a332 1
	rqinit();
@


1.143
log
@Back out the tracking of procs in struct selinfo. There's one serious
bug in the code, but as soon as I try to fix it, it seems to trigger
some other bugs. Instead of trying to figure out what's going on
while everyone suffers, it's better to back out and figure out
the bugs outside the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.136 2007/03/19 14:33:28 dlg Exp $	*/
d313 1
a313 1
	    trunc_page(VM_MAX_ADDRESS), TRUE);
@


1.142
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.142 2007/06/01 19:20:46 deraadt Exp $	*/
a294 2

	TAILQ_INIT(&p->p_selects);
@


1.141
log
@add an interface for work queues run from a kernel thread.

this type of code is implemented many times already in the kernel, this is
a generic version of all those replicated code bases.

originally from tedu@@
ok tedu@@ tom@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.140 2007/05/16 17:27:30 art Exp $	*/
a121 1
void	(*md_diskconf)(void) = NULL;
d448 1
a448 2
	if (md_diskconf)
		(*md_diskconf)();
@


1.140
log
@The world of __HAVEs and __HAVE_NOTs is reducing. All architectures
have cpu_info now, so kill the option.

eyeballed by jsg@@ and grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.139 2007/04/12 22:14:15 tedu Exp $	*/
d76 1
d143 1
d334 3
@


1.139
log
@move p_limit and p_cred into struct process
leave macros behind for now to keep the commit small
ok art beck miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.138 2007/04/03 08:05:43 art Exp $	*/
a115 3
#if !defined(__HAVE_CPUINFO) && !defined(curproc)
struct	proc *curproc;
#endif
a124 3
#ifndef __HAVE_CPUINFO
struct	timeval runtime;
#endif
a195 1
#ifdef __HAVE_CPUINFO
a196 1
#endif
a478 3
#ifndef __HAVE_CPUINFO
	microuptime(&runtime);
#endif
a480 1
#ifdef __HAVE_CPUINFO
a481 1
#endif
@


1.138
log
@Start moving state that is shared among threads in a process into
a new struct. Instead of doing a huge rename and deal with the fallout
for weeks, like other projects that need no mention, we will slowly and
carefully move things out of struct proc into a new struct process.

 - Create struct process and the infrastructure to create and remove them.
 - Move threads in a process into struct process.

deraadt@@, tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.137 2007/03/24 16:01:22 art Exp $	*/
d306 1
a306 1
	p->p_limit = &limit0;
@


1.137
log
@Kill the horrible hack of storing the pid in struct selinfo.

Instead, keep the proc pointer in it and put the selinfo on a list
in struct proc in selrecord. Then clean up the list when leaving
sys_select and sys_poll.

miod@@ ok, testing by many, including Bobs spamd boxes.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.136 2007/03/19 14:33:28 dlg Exp $	*/
d111 1
d262 6
a277 3

	p->p_thrparent = p;
	LIST_INIT(&p->p_thrchildren);
@


1.136
log
@attach softraid to the root of the device tree in a machine independant
way, rather than requiring some glue in each machines mainbus probe.

it is still commented out.

based on a discussion with miod@@ ok marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.134 2007/01/12 07:41:31 art Exp $	*/
d298 2
@


1.135
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d100 2
d440 4
@


1.134
log
@Switch some lockmgr locks to rwlocks.
In this commit:
 - gdt lock on amd64
 - sysctl lock
 - malloc sysctl lock
 - disk sysctl lock
 - swap syscall lock

miod@@, pedro@@ ok (and "looks good" others@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.133 2007/01/02 06:07:58 drahn Exp $	*/
d273 1
a273 1
	p->p_flag = P_SYSTEM | P_NOCLDWAIT;
@


1.133
log
@2007
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.132 2006/11/29 12:24:17 miod Exp $	*/
a231 3

	/* Initialize sysctls (must be done before any processes run) */
	sysctl_init();
@


1.132
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.131 2006/11/14 18:00:27 jmc Exp $	*/
d103 1
a103 1
"Copyright (c) 1995-2006 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.131
log
@grammar, spelling, and style fixes from bret lambert;
kern_descrip.c change ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.130 2006/05/06 23:02:36 deraadt Exp $	*/
d276 1
a276 1
	p->p_flag = P_INMEM | P_SYSTEM | P_NOCLDWAIT;
@


1.130
log
@initialize the propolice cookie more carefully so -fstack-protector-all
will work; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.129 2006/03/04 22:40:15 brad Exp $	*/
d426 1
a426 1
	 * Create any kernel threads who's creation was deferred because
@


1.129
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.128 2006/01/01 11:54:31 miod Exp $	*/
d395 9
a403 1
	arc4random_bytes(__guard, sizeof(__guard));
@


1.128
log
@2006
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.127 2005/12/22 06:55:03 tedu Exp $	*/
d383 1
a383 1
	s = splimp();
@


1.127
log
@fix memory leak conditions in thrsleep and significantly simplify
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.126 2005/12/03 18:09:08 tedu Exp $	*/
d103 1
a103 1
"Copyright (c) 1995-2005 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.126
log
@kernel support for threaded processes (rthreads).
uses rfork(RFTHREAD) to create threads, which are presently processes
that are a little more tightly bound together.  several new syscalls
added to facilitate a userland thread library.
all conditional on RTHREADS, currently disabled.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.125 2005/11/12 04:31:24 jsg Exp $	*/
a274 1
	LIST_INIT(&p->p_sleepers);
@


1.125
log
@ansi. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.124 2005/07/18 11:43:14 tom Exp $	*/
d272 4
@


1.124
log
@Typo in comment, from Giorgos Keramidas, keramida (at) ceid (dot)
upatras (dot) gr.  Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.122 2004/12/26 21:22:13 miod Exp $	*/
d181 1
a181 2
main(framep)
	void *framep;				/* XXX should go away */
d540 1
a540 2
check_console(p)
	struct proc *p;
d561 1
a561 2
start_init(arg)
	void *arg;
d697 1
a697 2
start_update(arg)
	void *arg;
d704 1
a704 2
start_cleaner(arg)
	void *arg;
d711 1
a711 2
start_reaper(arg)
	void *arg;
d719 1
a719 2
start_crypto(arg)
	void *arg;
@


1.123
log
@2005
@
text
@d231 1
a231 1
	/* Initalize sockets. */
@


1.122
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.121 2004/11/28 02:11:33 deraadt Exp $	*/
d103 1
a103 1
"Copyright (c) 1995-2004 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.121
log
@mountroothooks are called after the root filesystem is mounted.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.120 2004/11/23 19:08:55 miod Exp $	*/
d442 1
a442 1
	if (VFS_ROOT(mountlist.cqh_first, &rootvnode))
@


1.120
log
@Create the init process earlier, before the root filesystem is mounted,
and have it stall on a semaphore. This allows all kthread creations which
could have been requested during autoconf to be processed before root
is mounted as well.

This causes umass devices attached to any usb with flags 1 (such as on macppc)
to configure properly instead of panicing the kernel at mountroot time.

From NetBSD; tested by various.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.119 2004/07/28 17:15:12 tholo Exp $	*/
d516 2
@


1.119
log
@This touches only MI code, and adds new time keeping code.  The
code is all conditionalized on __HAVE_TIMECOUNTER, and not
enabled on any platforms.

adjtime(2) support exists, courtesy of nordin@@, sysctl(2) support
and a concept of quality for each time source attached exists.

High quality time sources exists for PIIX4 ACPI timer as well as
some AMD power management chips.  This will have to be redone
once we actually add ACPI support (at that time we need to use
the ACPI interfaces to get at these clocks).

ok art@@ ken@@ miod@@ jmc@@ and many more
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.118 2004/07/20 20:19:52 art Exp $	*/
d129 1
a188 1
	register_t rval[2];
d402 28
d450 9
d468 5
a472 1
	p->p_stats->p_start = boottime;	
d474 1
a474 3
	microuptime(&p->p_cpu->ci_schedstate.spc_runtime);
#else
	microuptime(&runtime);
d476 2
a477 1
	p->p_rtime.tv_sec = p->p_rtime.tv_usec = 0;
d481 1
a481 5
	/* Create process 1 (init(8)). */
	if (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, start_init, NULL, rval))
		panic("fork init");

	/* Create process 2, the pageout daemon kernel thread. */
d485 1
a485 1
	/* Create process 3, the reaper daemon kernel thread. */
d489 1
a489 1
	/* Create process 4, the cleaner daemon kernel thread. */
d493 1
a493 1
	/* Create process 5, the update daemon kernel thread. */
d497 1
a497 1
	/* Create process 6, the aiodone daemon kernel thread. */ 
d502 1
a502 1
	/* Create process 7, the crypto kernel thread. */
a506 3
	/* Create any other deferred kernel threads. */
	kthread_run_deferred_queue();

d517 6
d577 3
a579 1
	initproc = p;
d582 1
a582 1
	 * Now in process 1.
d584 3
@


1.118
log
@protect printf with a mutex instead of SIMPLELOCK.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.117 2004/06/24 19:35:24 tholo Exp $	*/
d426 6
a432 1
	p->p_stats->p_start = mono_time = boottime = time;
a434 1
	p->p_stats->p_start = runtime = mono_time = boottime = time;	
@


1.117
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.116 2004/06/13 21:49:26 niklas Exp $	*/
a189 1
	extern struct SIMPLELOCK kprintf_slock;
a214 2

	SIMPLE_LOCK_INIT(&kprintf_slock);
@


1.116
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d431 1
a431 1
	p->p_cpu->ci_schedstate.spc_runtime = time;
d434 1
@


1.115
log
@Merge in a piece of the SMP branch into HEAD.

Introduce the cpu_info structure, p_cpu field in struct proc and global
scheduling context and various changed code to deal with this. At the
moment no architecture uses this stuff yet, but it will allow us slow and
controlled migration to the new APIs.

All new code is ifdef:ed out.

ok deraadt@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.114 2004/06/08 18:09:31 marc Exp $	*/
a127 1

d190 1
d216 3
d221 2
d278 1
a278 1
	p->p_stat = SRUN;
d352 3
a423 2
	uvm_swap_init();

d433 1
a433 1
	p->p_stats->p_start = runtime = mono_time = boottime = time;
d437 2
d476 6
d640 2
a641 1
		if ((error = sys_execve(p, &args, retval)) == 0)
d643 1
@


1.114
log
@pull ncpus support from smp tree into main branch.
remove alpha specific definition of ncpus.
OK (and tested on alpha) deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.113 2004/04/01 00:27:51 tedu Exp $	*/
d113 1
a113 1
#ifndef curproc
d125 1
d127 2
d201 3
d423 4
d428 1
@


1.113
log
@init kqueues normally, from pedro martelletto
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.112 2004/03/14 23:12:11 tedu Exp $	*/
d126 1
@


1.112
log
@nicer printf for copyright.  from Pedro Martelletto
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.111 2004/01/21 19:03:44 tedu Exp $	*/
d138 1
a138 1
void    start_crypto(void *);
d140 1
d245 5
@


1.111
log
@call timeout_startup early, so timeouts are available.  report from sam smith
ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.110 2004/01/14 19:34:05 grange Exp $	*/
d208 1
a208 2
	printf(copyright);
	printf("\n");
@


1.110
log
@Get rid of M_LOCKF and use pool for allocating lockf structures.
 From NetBSD.

Tested by many people, ok art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.109 2004/01/01 00:04:35 deraadt Exp $	*/
d198 5
a223 5

	/*
	 * Initialize timeouts.
	 */
	timeout_startup();
@


1.109
log
@2004
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.108 2003/11/03 18:24:52 tedu Exp $	*/
d60 1
d232 3
@


1.108
log
@use arc4random_bytes
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.107 2003/09/01 18:06:03 henning Exp $	*/
d102 1
a102 1
"Copyright (c) 1995-2003 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.107
log
@match syscallargs comments with reality
from Patrick Latifi <patrick.l@@hermes.usherb.ca>
ok jason@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.106 2003/08/21 18:56:07 tedu Exp $	*/
a183 3
#if !defined(NO_PROPOLICE)
	int *guard = (int *)&__guard[0];
#endif
d372 1
a372 2
	for (i = 0; i < sizeof(__guard) / 4; i++)
		guard[i] = arc4random();
@


1.106
log
@emulation is now controlled by sysctl.  changes:
add e_flags to struct emul.  this stores on/off and native flags.
check for emul enabled in check_exec().  gather all the emuls into a
emulsw so a sysctl can find them.  create sysctl.  move maxhdrsiz calcualation
into init_main so it cleans up sys_execve codepath.  teach sysctl utility
to grok kern.emul hierarchy.
requested and ok deraadt@@  some comments from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.105 2003/06/02 23:28:05 millert Exp $	*/
d495 3
a497 3
		syscallarg(char *) path;
		syscallarg(char **) argp;
		syscallarg(char **) envp;
@


1.105
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.104 2003/05/13 22:45:11 miod Exp $	*/
d138 1
d163 1
d166 1
d378 3
@


1.104
log
@Add option NO_PROPOLICE, which explicitely disables the use of the propolice
stack protection when building kernels. Intended to be used on installation
media, with tight space constraints - currently, only added where
SMALL_KERNEL was already defined.

Not thoroughly tested, but requested by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.103 2003/05/13 06:11:11 tedu Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.103
log
@support for propolice in the kernel.
some style input itojun@@ tdeval@@ toby@@
tested, mostly by deraadt, on i386, macppc, vax, sparc64
ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.102 2003/05/09 00:49:46 art Exp $	*/
d130 1
d132 1
d185 1
d187 1
d375 1
d378 1
@


1.102
log
@Don't map the fake arg list for init with X permissions.

niklas@@ tdeval@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.101 2003/03/06 17:06:18 mickey Exp $	*/
d83 2
d130 2
d183 1
d370 3
@


1.101
log
@move cpu_configre() lower after the proc0 is more completely initialized.
still calculate the memory limits for proc0 at after the autoconf is done.
miod@@ testing on everything; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.100 2003/01/09 22:27:12 miod Exp $	*/
d506 1
a506 1
	    UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_COPY,
@


1.100
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.99 2003/01/01 21:05:36 pvalchev Exp $	*/
d173 2
a174 2
	register struct proc *p;
	register struct pdevinit *pdev;
a175 1
	register int i;
d177 1
a177 1
	int s;
d189 1
a189 2
	p = &proc0;
	curproc = p;
a218 2
	cpu_configure();

d267 5
d308 1
d311 3
a367 5

	/* Initialize signal state for process 0. */
	signal_init();
	p->p_sigacts = &sigacts0;
	siginit(p);
@


1.99
log
@2003 in copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.98 2002/12/19 00:57:07 mickey Exp $	*/
d483 2
a484 1
	int options, i, error;
d576 2
a577 1
		(void)suword((caddr_t)--uap, 0);	/* terminator */
d579 2
a580 2
			(void)suword((caddr_t)--uap, (long)arg1);
		(void)suword((caddr_t)--uap, (long)arg0);
@


1.98
log
@simplify stack grownups (growndowns are not touched)
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.97 2002/11/22 16:47:28 art Exp $	*/
d104 1
a104 1
"Copyright (c) 1995-2002 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.97
log
@Instead of statically allocating filedescs for proc0, use fdinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.96 2002/11/22 09:50:08 deraadt Exp $	*/
a507 3
#ifdef MACHINE_STACK_GROWS_UP
	p->p_vmspace->vm_maxsaddr = (caddr_t)addr + PAGE_SIZE;
#else
a508 1
#endif
@


1.96
log
@repair proc0 rlimit setup for >2GB machines
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.95 2002/05/27 13:42:16 itojun Exp $	*/
a110 1
struct	filedesc0 filedesc0;
d272 1
a272 8
	p->p_fd = &filedesc0.fd_fd;
	filedesc0.fd_fd.fd_refcnt = 1;
	filedesc0.fd_fd.fd_cmask = cmask;
	filedesc0.fd_fd.fd_ofiles = filedesc0.fd_dfiles;
	filedesc0.fd_fd.fd_ofileflags = filedesc0.fd_dfileflags;
	filedesc0.fd_fd.fd_nfiles = NDFILE;
	filedesc0.fd_fd.fd_himap = filedesc0.fd_dhimap;
	filedesc0.fd_fd.fd_lomap = filedesc0.fd_dlomap;
d380 1
a380 1
	/* Get the vnode for '/'.  Set filedesc0.fd_fd.fd_cdir to reference it. */
d383 2
a384 2
	filedesc0.fd_fd.fd_cdir = rootvnode;
	VREF(filedesc0.fd_fd.fd_cdir);
d386 1
a386 1
	filedesc0.fd_fd.fd_rdir = NULL;
@


1.95
log
@if_attach() gets called before domaininit().  scan all interfaces for if_afdata
initialization after domaininit().
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.94 2002/03/14 20:31:31 mickey Exp $	*/
d178 1
d291 4
a294 4
	i = ptoa(uvmexp.free);
	limit0.pl_rlimit[RLIMIT_RSS].rlim_max = i;
	limit0.pl_rlimit[RLIMIT_MEMLOCK].rlim_max = i;
	limit0.pl_rlimit[RLIMIT_MEMLOCK].rlim_cur = i / 3;
@


1.94
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.93 2002/03/14 01:27:04 millert Exp $	*/
d360 1
@


1.93
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.92 2002/01/30 20:29:44 nordin Exp $	*/
d101 1
a101 1
char	copyright[] =
@


1.92
log
@Add proc0 to the PIDHASH table. art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.91 2002/01/16 20:50:17 miod Exp $	*/
d98 1
a98 1
extern void nfs_init __P((void));
d123 1
a123 1
void	(*md_diskconf) __P((void)) = NULL;
d130 7
a136 7
int	main __P((void *));
void	check_console __P((struct proc *));
void	start_init __P((void *));
void	start_cleaner __P((void *));
void	start_update __P((void *));
void	start_reaper __P((void *));
void    start_crypto __P((void *));
d181 4
a184 4
	extern void scheduler_start __P((void));
	extern void disk_init __P((void));
	extern void endtsleep __P((void *));
	extern void realitexpire __P((void *));
@


1.91
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.90 2002/01/01 20:41:56 deraadt Exp $	*/
d246 1
@


1.90
log
@2002
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.89 2001/12/19 08:58:06 art Exp $	*/
a52 1
#include <sys/map.h>
@


1.89
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.88 2001/12/04 23:22:42 art Exp $	*/
d105 1
a105 1
"Copyright (c) 1995-2001 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.88
log
@Yet another sync to NetBSD uvm.
Today we add a pmap argument to pmap_update() and allocate map entries for
kernel_map from kmem_map instead of using the static entries. This should
get rid of MAX_KMAPENT panics. Also some uvm_loan problems are fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.87 2001/11/28 13:47:39 art Exp $	*/
a223 2
	ubc_init();		/* Initialize the unified buffer cache */

d298 1
a298 1
	    trunc_page(VM_MAX_ADDRESS));
@


1.88.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.92 2002/01/30 20:29:44 nordin Exp $	*/
d53 1
d105 1
a105 1
"Copyright (c) 1995-2002 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
a248 1
	LIST_INSERT_HEAD(PIDHASH(0), p, p_hash);
@


1.88.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.88.2.1 2002/01/31 22:55:40 niklas Exp $	*/
d98 1
a98 1
extern void nfs_init(void);
d101 1
a101 1
const char	copyright[] =
d123 1
a123 1
void	(*md_diskconf)(void) = NULL;
d130 7
a136 7
int	main(void *);
void	check_console(struct proc *);
void	start_init(void *);
void	start_cleaner(void *);
void	start_update(void *);
void	start_reaper(void *);
void    start_crypto(void *);
d181 4
a184 4
	extern void scheduler_start(void);
	extern void disk_init(void);
	extern void endtsleep(void *);
	extern void realitexpire(void *);
a361 1
	if_attachdomain();
@


1.88.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a82 2
#include <dev/rndvar.h>

d104 1
a104 1
"Copyright (c) 1995-2003 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
d111 1
a128 4
#if !defined(NO_PROPOLICE)
long	__guard[8];
#endif

d174 2
a175 2
	struct proc *p;
	struct pdevinit *pdev;
d177 2
a178 2
	quad_t lim;
	int s, i;
a179 3
#if !defined(NO_PROPOLICE)
	int *guard = (int *)&__guard[0];
#endif
d190 2
a191 1
	curproc = p = &proc0;
d221 2
a272 5
	/* Initialize signal state for process 0. */
	signal_init();
	p->p_sigacts = &sigacts0;
	siginit(p);

d274 8
a281 1
	p->p_fd = fdinit(NULL);
d292 4
a295 4
	lim = ptoa(uvmexp.free);
	limit0.pl_rlimit[RLIMIT_RSS].rlim_max = lim;
	limit0.pl_rlimit[RLIMIT_MEMLOCK].rlim_max = lim;
	limit0.pl_rlimit[RLIMIT_MEMLOCK].rlim_cur = lim / 3;
a315 1
	/* Initialize run queues */
a317 3
	/* Configure the devices */
	cpu_configure();

a369 5
#if !defined(NO_PROPOLICE)
	for (i = 0; i < sizeof(__guard) / 4; i++)
		guard[i] = arc4random();
#endif

d373 5
d389 1
a389 1
	/* Get the vnode for '/'.  Set p->p_fd->fd_cdir to reference it. */
d392 2
a393 2
	p->p_fd->fd_cdir = rootvnode;
	VREF(p->p_fd->fd_cdir);
d395 1
a395 1
	p->p_fd->fd_rdir = NULL;
d492 1
a492 2
	int options, error;
	long i;
d514 1
a514 1
	    UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_ALL, UVM_INH_COPY,
d517 3
d521 1
d588 1
a588 2
		i = 0;
		copyout(&i, (caddr_t)--uap, sizeof(register_t)); /* terminator */
d590 2
a591 2
			copyout(&arg1, (caddr_t)--uap, sizeof(register_t));
		copyout(&arg0, (caddr_t)--uap, sizeof(register_t));
@


1.87
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.86 2001/11/27 22:53:19 provos Exp $	*/
d300 1
a300 1
	    trunc_page(VM_MAX_ADDRESS), TRUE);
@


1.86
log
@change socket allocation to pool allocator; from netbsd; okay niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.85 2001/11/27 05:27:11 art Exp $	*/
d514 1
a514 2
	    UVM_ADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW))
	    != KERN_SUCCESS)
@


1.85
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.84 2001/11/10 18:42:31 art Exp $	*/
d64 1
d213 3
@


1.84
log
@Merge in some parts of the ubc work that has been done in NetBSD that are not
UBC, but prerequsites for it.

- Create a daemon that processes async I/O (swap and paging in the future)
  requests that need processing in process context and that were processed
  in the pagedaemon before.
- Convert some ugly ifdef DIAGNOSTIC code to less intrusive KASSERTs.
- misc other cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.83 2001/11/07 01:18:01 art Exp $	*/
d219 2
@


1.83
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.82 2001/11/06 19:53:20 miod Exp $	*/
d420 4
d425 1
a425 1
	/* Create process 6, the crypto kernel thread. */
@


1.82
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.81 2001/11/06 18:41:10 art Exp $	*/
d502 1
a502 1
	    NULL, UVM_UNKNOWN_OFFSET, 
@


1.81
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.80 2001/11/06 13:36:52 art Exp $	*/
a85 2

#include <vm/vm.h>
@


1.80
log
@More sync to NetBSD.
 - Use malloc/free instead of MALLOC/FREE for variable sized allocations.
 - Move the memory inheritance code to sys/mman.h and rename from VM_* to MAP_*
 - various cleanups and simplifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.79 2001/10/11 08:07:12 gluk Exp $	*/
d403 1
a403 1
	if (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, rval))
a404 2
	initproc = pfind(rval[0]);
	cpu_set_kpc(initproc, start_init, initproc);
d487 2
@


1.79
log
@Count pages not buffers. This fixes deadlock condition which mainly
occurs on the fs with large block size. We can have situation where
numcleanbufs < locleanbufs and numdirtybufs < hidirtybufs.  So, buffer
flushing daemon never wakeups and other processes asleep forever waiting
for a clean buffers. We count pages only for the dirty buffers which are
on freelist(BQ_DIRTY).

niklas@@ found this.

Rename flasher to cleaner. Suggested by costa@@.

Discussed with niklas@@, costa@@, millert@@, art@@.
Ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.78 2001/09/29 20:09:34 gluk Exp $	*/
a134 1
void	start_pagedaemon __P((void *));
d409 1
a409 1
	if (kthread_create(start_pagedaemon, NULL, NULL, "pagedaemon"))
a602 8
}

void
start_pagedaemon(arg)
	void *arg;
{
	uvm_pageout();
	/* NOTREACHED */
@


1.78
log
@Move signal initialization before dostartuphooks to avoid panic at
start of raid autoconfiguration thread. Required for upcoming RAIDFrame
code update.

From Thierry Deval <TDeval@@PrimeOBJ.COM>
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.77 2001/09/17 19:17:30 gluk Exp $	*/
d136 1
a136 1
void	start_flusher __P((void *));
d417 3
a419 3
	/* Create process 4, the flusher daemon kernel thread. */
	if (kthread_create(start_flusher, NULL, NULL, "flusher"))
		panic("fork flusher");
d623 1
a623 1
start_flusher(arg)
@


1.77
log
@ The first implementation of the buffer flushing daemon. It solves our
problem when syncer can't do its work because of vnode locks (PR1983).
This also solves our problem where bigger number of buffers results in a
much worse perfomance. In my configuration (i386, 128mb, BUFCACHEPERCENT=35)
this speedup tar -xzf ports.tar.gz in 2-4 times. In configuration with
low number of buffers and softupdates this may slowdown some operations
up to 15%.

 The major difference with current buffer cache is that new implementation
uses separate queues for dirty and clean buffers. I.e. BQ_LRU and BQ_AGE
replaced by BQ_CLEAN and BQ_DIRTY. This simplifies things a lot and
doesn't affect perfomance in a bad manner.

Thanks to art and costa for pointing on errors.

Tested by brad, millert, naddy, art, jj, camield

art, millert ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.76 2001/09/12 15:48:45 art Exp $	*/
d369 5
a401 5

	/* Initialize signal state for process 0. */
	signal_init();
	p->p_sigacts = &sigacts0;
	siginit(p);
@


1.76
log
@Rename timeout_init to timeout_startup to deconfuse a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.75 2001/09/07 12:58:18 art Exp $	*/
d136 1
d417 6
a422 3
	/* Create process 4, the update daemon kernel thread. */
	if (kthread_create(start_update, NULL, NULL, "update")) {
#ifdef DIAGNOSTIC
a423 2
#endif
	}
d426 1
a426 1
	/* Create process 5, the crypto kernel thread. */
d619 8
@


1.75
log
@make starting of init slightly cleaner. Also sets initproc earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.74 2001/08/23 14:01:02 art Exp $	*/
d218 1
a218 1
	timeout_init();
@


1.74
log
@We can now move timeout_init into main().
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.73 2001/07/27 09:55:07 niklas Exp $	*/
d405 2
a406 1
	cpu_set_kpc(pfind(rval[0]), start_init, pfind(rval[0]));
a491 2
	initproc = p;

@


1.73
log
@Startup hooks.  Can be used for providing root/swap devices from device
systems which want configuration to finish late, like I2O.  Implemented via
a general hooks mechanism which the shutdown hooks have been converted to
use as well.  It even has manpages!
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.72 2001/07/05 10:12:24 art Exp $	*/
d214 5
@


1.72
log
@Get rid of REAL_CLISTS. It was never implemented and the tentacles are
everywhhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.71 2001/06/27 07:16:28 art Exp $	*/
d362 2
@


1.71
log
@no more cpu_set_init_frame
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.70 2001/06/27 07:02:45 art Exp $	*/
a62 3
#ifdef REAL_CLISTS
#include <sys/clist.h>
#endif
a319 5

#ifdef REAL_CLISTS
	/* Initialize clists. */
	clist_init();
#endif
@


1.70
log
@vm_pageout.h bye bye.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.69 2001/06/27 04:49:40 art Exp $	*/
a142 4
#ifdef cpu_set_init_frame
void *initframep;				/* XXX should go away */
#endif

a405 10
#ifdef cpu_set_init_frame			/* XXX should go away */
	if (rval[1]) {
		/*
		 * Now in process 1.
		 */
		initframep = framep;
		start_init(curproc);
		return (0);
	}
#else
a406 1
#endif
a492 11

#ifdef cpu_set_init_frame			/* XXX should go away */
	/*
	 * We need to set the system call frame as if we were entered through
	 * a syscall() so that when we call sys_execve() below, it will be able
	 * to set the entry point (see setregs) when it tries to exec.  The
	 * startup code in "locore.s" has allocated space for the frame and
	 * passed a pointer to that space as main's argument.
	 */
	cpu_set_init_frame(p, initframep);
#endif
@


1.69
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.68 2001/06/23 18:30:37 deraadt Exp $	*/
a90 1
#include <vm/vm_pageout.h>
@


1.68
log
@merge crypto/crypto{dev,}.h to crypto/cryptodev.h, to avoid name conflicts inside OpenSSL codebase
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.67 2001/06/23 06:04:34 art Exp $	*/
a92 1
#if defined(UVM)
a93 1
#endif
a211 1
#if defined(UVM)
a212 7
#else
	vm_mem_init();
	kmeminit();
#if defined(MACHINE_NEW_NONCONTIG)
	vm_page_physrehash();
#endif
#endif /* UVM */
a290 1
#if defined(UVM)
a291 3
#else
	i = ptoa(cnt.v_free_count);
#endif /* UVM */
a297 1
#if defined(UVM)
a300 7
#else
	p->p_vmspace = &vmspace0;
	vmspace0.vm_refcnt = 1;
	vmspace0.vm_map.pmap = pmap_create(0);
	vm_map_init(&p->p_vmspace->vm_map, round_page(VM_MIN_ADDRESS),
	    trunc_page(VM_MAX_ADDRESS), TRUE);
#endif /* UVM */
a317 1
#if defined(UVM)
a318 3
#else
	vm_init_limits(p);
#endif
a392 1
#if defined(UVM)
a393 3
#else
	swapinit();
#endif
a452 1
#if defined(UVM)
a453 3
#else
	scheduler();
#endif
a530 1
#if defined(UVM)
a536 5
#else
	if (vm_allocate(&p->p_vmspace->vm_map, &addr, (vsize_t)PAGE_SIZE,
	    FALSE) != 0)
		panic("init: couldn't allocate argument space");
#endif
a636 1
#if defined(UVM)
a637 3
#else
	vm_pageout();
#endif
@


1.67
log
@Add pipe_init, call it from main, move the pool initialization into it.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.66 2001/06/22 14:14:08 deraadt Exp $	*/
d101 1
a101 1
#include <crypto/crypto.h>
@


1.66
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.65 2001/05/17 18:41:44 provos Exp $	*/
d81 1
d247 5
@


1.65
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.64 2001/05/16 12:49:45 art Exp $	*/
d466 1
a466 1
	        panic("crypto thread");
d561 4
a564 5
                    NULL, UVM_UNKNOWN_OFFSET, 
                    UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_COPY,
		    UVM_ADV_NORMAL,
                    UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW))
		!= KERN_SUCCESS)
d698 1
a698 1
        void *arg;
d700 2
a701 2
        crypto_thread();
        /* NOTREACHED */
@


1.64
log
@Use pool to allocate struct filedesc0 and struct file.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.63 2001/05/05 22:34:32 art Exp $	*/
d225 7
a347 3

	/* Initialize mbuf's. */
	mbinit();
@


1.63
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.62 2001/04/06 23:41:02 art Exp $	*/
d234 5
@


1.62
log
@Get rid of vm_pmap from struct vmspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.61 2001/04/02 21:43:11 niklas Exp $	*/
d225 1
@


1.61
log
@On popular demand, the Linux-compatibility clone(2) implementation based
on NetBSD's code, as well as some faked Posix RT extensions by me.  This makes
at least simple linuxthreads tests work.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.60 2001/03/16 15:49:05 art Exp $	*/
d300 1
a300 1
	pmap_pinit(&vmspace0.vm_pmap);
a302 1
	vmspace0.vm_map.pmap = &vmspace0.vm_pmap;
@


1.60
log
@Use CIRCLEQ macros for mountlist.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.59 2001/03/16 08:49:09 art Exp $	*/
d121 1
d309 2
a310 2
	 * We continue to place resource usage info and signal
	 * actions in the user struct so they're pageable.
a312 1
	p->p_sigacts = &p->p_addr->u_sigacts;
d419 2
d424 1
a424 1
	if (fork1(p, FORK_FORK, NULL, 0, rval))
@


1.59
log
@Use a lockmgr lock for keeping down the vslocked memory in sysctl
instead of a home-brew equivalent.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.58 2001/02/05 21:28:06 mickey Exp $	*/
d394 1
a394 1
	mountlist.cqh_first->mnt_flag |= MNT_ROOTFS;
@


1.58
log
@only attach pseudo-device if it's counter is above zero; deraadt@@, maja@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.57 2001/01/01 16:06:12 aaron Exp $	*/
d224 3
@


1.57
log
@2001
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.56 2000/11/08 05:41:04 art Exp $	*/
d360 2
a361 1
		(*pdev->pdev_attach)(pdev->pdev_count);
@


1.56
log
@If MD code has defined curproc, don't do it here.
This is not a perfect solution.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.55 2000/06/18 03:07:48 angelos Exp $	*/
d111 1
a111 1
"Copyright (c) 1995-2000 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.55
log
@Process ID 5 is now the crypto kernel thread.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.54 2000/06/16 21:47:14 provos Exp $	*/
d121 3
a123 1
struct	proc *curproc = &proc0;
d399 1
d624 1
@


1.54
log
@take MIN/MAX from param.h, okay theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.53 2000/06/05 11:02:50 art Exp $	*/
d140 1
d445 6
d676 10
@


1.53
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.52 2000/03/23 16:54:44 art Exp $	*/
a105 4
#endif

#ifndef MIN
#define MIN(a,b)	(((a)<(b))?(a):(b))
@


1.52
log
@Don't reinitialize the tsleep and ITIMER_REAL timers all the time.
The function and the argument never change.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.51 2000/03/23 10:13:58 art Exp $	*/
d143 1
d437 5
a441 1
	/* Create process 3, the update daemon kernel thread. */
d663 8
@


1.51
log
@Adapt roundrobin and schedcpu to the new timeout API.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.50 2000/03/22 21:35:37 mickey Exp $	*/
d193 2
d248 4
@


1.50
log
@some more machine_stack_grows_up
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.49 2000/03/20 15:29:53 deraadt Exp $	*/
d191 1
a191 2
	extern void roundrobin __P((void *));
	extern void schedcpu __P((void *));
d374 2
a375 3
	/* Kick off timeout driven events by calling first time. */
	roundrobin(NULL);
	schedcpu(NULL);
@


1.49
log
@bring proto into scope
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.48 2000/03/17 10:25:21 angelos Exp $	*/
d549 3
d553 1
a553 1

d581 5
d588 1
d598 7
d607 2
a608 1

a611 1
		uap = (char **)((long)ucp & ~ALIGNBYTES);
@


1.48
log
@Cryptographic services framework, and software "device driver". The
idea is to support various cryptographic hardware accelerators (which
may be (detachable) cards, secondary/tertiary/etc processors,
software crypto, etc). Supports session migration between crypto
devices. What it doesn't (yet) support:
 - multiple instances of the same algorithm used in the same session
 - use of multiple crypto drivers in the same session
 - asymmetric crypto

No support for a userland device yet.

IPsec code path modified to allow for asynchronous cryptography
(callbacks used in both input and output processing). Some unrelated
code simplification done in the process (especially for AH).

Development of this code kindly supported by Network Security
Technologies (NSTI). The code was writen mostly in Greece, and is
being committed from Montreal.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.47 2000/02/28 18:04:08 provos Exp $	*/
d101 1
@


1.47
log
@Optimized fdalloc as in Banga and Mogul paper:
http://www.usenix.org/publications/library/proceedings/usenix98/banga.html
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.46 2000/01/31 19:57:18 deraadt Exp $	*/
d99 4
d356 4
@


1.46
log
@re-add fixed vfork code from art
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.44 2000/01/28 19:45:04 art Exp $	*/
d256 2
@


1.46.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.46 2000/01/31 19:57:18 deraadt Exp $	*/
a130 1
int	ncpus =  1;
@


1.46.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a256 2
	filedesc0.fd_fd.fd_himap = filedesc0.fd_dhimap;
	filedesc0.fd_fd.fd_lomap = filedesc0.fd_dlomap;
@


1.46.2.3
log
@Sync with -current
@
text
@a98 5
#if defined(CRYPTO)
#include <crypto/crypto.h>
#include <crypto/cryptosoft.h>
#endif

d187 2
a188 1
	extern void scheduler_start __P((void));
a189 2
	extern void endtsleep __P((void *));
	extern void realitexpire __P((void *));
a243 4
	/* Init timeouts. */
	timeout_set(&p->p_sleep_to, endtsleep, p);
	timeout_set(&p->p_realit_to, realitexpire, p);

a352 4
#ifdef CRYPTO
	swcr_init();
#endif /* CRYPTO */
	
d367 3
a369 2
	/* Start the scheduler */
	scheduler_start();
a540 3
#ifdef MACHINE_STACK_GROWS_UP
		ucp = (char *)addr;
#else
d542 1
a542 1
#endif
a569 5
#ifdef MACHINE_STACK_GROWS_UP
			arg1 = ucp;
			(void)copyout((caddr_t)flags, (caddr_t)ucp, i);
			ucp += i;
#else
a571 1
#endif
a580 7
#ifdef MACHINE_STACK_GROWS_UP
		arg0 = ucp;
		(void)copyout((caddr_t)path, (caddr_t)ucp, i);
		ucp += i;
		ucp = (caddr_t)ALIGN((u_long)ucp);
		uap = (char **)ucp + 3;
#else
d583 1
a583 2
		uap = (char **)((u_long)ucp & ~ALIGNBYTES);
#endif
d587 1
@


1.46.2.4
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.62 2001/04/06 23:41:02 art Exp $	*/
d108 4
d115 1
a115 1
"Copyright (c) 1995-2001 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
d125 1
a125 4
struct	sigacts sigacts0;
#ifndef curproc
struct	proc *curproc;
#endif
a143 2
void	start_reaper __P((void *));
void    start_crypto __P((void *));
a225 3
	/* Initialize sysctls (must be done before any processes run) */
	sysctl_init();

d297 1
a297 1
	vmspace0.vm_map.pmap = pmap_create(0);
d300 1
d306 2
a307 2
	 * We continue to place resource usage info in the
	 * user struct so they're pageable.
d310 1
d361 1
a361 2
		if (pdev->pdev_count > 0)
			(*pdev->pdev_attach)(pdev->pdev_count);
d391 1
a391 1
	CIRCLEQ_FIRST(&mountlist)->mnt_flag |= MNT_ROOTFS;
a399 1

a414 2
	signal_init();
	p->p_sigacts = &sigacts0;
d418 1
a418 1
	if (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, rval))
d437 1
a437 5
	/* Create process 3, the reaper daemon kernel thread. */
	if (kthread_create(start_reaper, NULL, NULL, "reaper"))
		panic("fork reaper");

	/* Create process 4, the update daemon kernel thread. */
a443 6
#ifdef CRYPTO
	/* Create process 5, the crypto kernel thread. */
	if (kthread_create(start_crypto, NULL, NULL, "crypto"))
	        panic("crypto thread");
#endif /* CRYPTO */

a613 1

a660 18

void
start_reaper(arg)
	void *arg;
{
	reaper();
	/* NOTREACHED */
}

#ifdef CRYPTO
void
start_crypto(arg)
        void *arg;
{
        crypto_thread();
        /* NOTREACHED */
}
#endif /* CRYPTO */
@


1.46.2.5
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.46.2.4 2001/05/14 22:32:39 niklas Exp $	*/
a80 1
#include <sys/pipe.h>
d90 1
d92 1
d94 1
d100 1
a100 1
#include <crypto/cryptodev.h>
d146 4
d214 1
d216 7
a226 8
	/*
	 * Initialize mbuf's.  Do this now because we might attempt to
	 * allocate mbufs or mbuf clusters during autoconfiguration.
	 */
	mbinit();

	cpu_configure();

a235 10
	 * Initialize filedescriptors.
	 */
	filedesc_init();

	/*
	 * Initialize pipes.
	 */
	pipe_init();

	/*
d283 1
d285 3
d294 1
d298 7
d322 1
d324 3
d337 3
d404 1
d406 3
d426 10
d437 1
d457 1
a457 1
		panic("crypto thread");
d468 1
d470 3
d529 11
d550 1
d552 9
a560 4
	    NULL, UVM_UNKNOWN_OFFSET, 
	    UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_COPY,
	    UVM_ADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW))
	    != KERN_SUCCESS)
d562 1
d663 1
d665 3
d690 1
a690 1
	void *arg;
d692 2
a693 2
	crypto_thread();
	/* NOTREACHED */
@


1.46.2.6
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.46.2.5 2001/07/04 10:48:14 niklas Exp $	*/
a197 1
	/* XXX_SMP	p->p_cpu = curcpu(); */
@


1.46.2.7
log
@Try to spinup the application processors, not yet working.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d198 1
a198 1
	p->p_cpu = curcpu();
a437 6

#if defined(MULTIPROCESSOR)
	/* Boot the secondary processors. */
	cpu_boot_secondary_processors();
#endif

@


1.46.2.8
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.46.2.7 2001/10/27 10:00:47 niklas Exp $	*/
d63 3
a139 1
void	start_cleaner __P((void *));
a219 5
	/*
	 * Initialize timeouts.
	 */
	timeout_startup();

d326 5
a372 7
	/* Initialize signal state for process 0. */
	signal_init();
	p->p_sigacts = &sigacts0;
	siginit(p);

	dostartuphooks();

d400 5
d408 1
a408 2
	initproc = pfind(rval[0]);
	cpu_set_kpc(initproc, start_init, initproc);
d418 3
a420 6
	/* Create process 4, the cleaner daemon kernel thread. */
	if (kthread_create(start_cleaner, NULL, NULL, "cleaner"))
		panic("fork cleaner");

	/* Create process 5, the update daemon kernel thread. */
	if (kthread_create(start_update, NULL, NULL, "update"))
d422 2
d426 1
a426 1
	/* Create process 6, the crypto kernel thread. */
d500 2
a626 8
	/* NOTREACHED */
}

void
start_cleaner(arg)
	void *arg;
{
	buf_daemon(curproc);
@


1.46.2.9
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 2
d136 1
d406 1
a406 1
	if (fork1(p, SIGCHLD, FORK_FORK, NULL, 0, start_init, NULL, rval))
d408 2
d412 1
a412 1
	if (kthread_create(uvm_pageout, NULL, NULL, "pagedaemon"))
a426 4
	/* Create process 6, the aiodone daemon kernel thread. */ 
	if (kthread_create(uvm_aiodone_daemon, NULL, NULL, "aiodoned"))
		panic("fork aiodoned");

d428 1
a428 1
	/* Create process 7, the crypto kernel thread. */
a498 2
	initproc = p;

d513 1
a513 1
	    NULL, UVM_UNKNOWN_OFFSET, 0,
d612 8
@


1.46.2.10
log
@Merge in -current
@
text
@a63 1
#include <sys/socketvar.h>
a214 3
	/* Initalize sockets. */
	soinit();

a221 2
	ubc_init();		/* Initialize the unified buffer cache */

d516 2
a517 1
	    UVM_ADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW)))
@


1.46.2.11
log
@Merge in trunk
@
text
@d53 1
d105 1
a105 1
"Copyright (c) 1995-2002 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
d226 2
a250 1
	LIST_INSERT_HEAD(PIDHASH(0), p, p_hash);
@


1.46.2.12
log
@Merge in -current from about a week ago
@
text
@d98 1
a98 1
extern void nfs_init(void);
d101 1
a101 1
const char	copyright[] =
d123 1
a123 1
void	(*md_diskconf)(void) = NULL;
d131 7
a137 7
int	main(void *);
void	check_console(struct proc *);
void	start_init(void *);
void	start_cleaner(void *);
void	start_update(void *);
void	start_reaper(void *);
void    start_crypto(void *);
d182 4
a185 4
	extern void scheduler_start(void);
	extern void disk_init(void);
	extern void endtsleep(void *);
	extern void realitexpire(void *);
@


1.46.2.13
log
@Sync the SMP branch with 3.3
@
text
@d104 1
a104 1
"Copyright (c) 1995-2003 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
d111 1
d175 2
a176 2
	struct proc *p;
	struct pdevinit *pdev;
d178 2
a179 2
	quad_t lim;
	int s, i;
d191 2
a192 1
	curproc = p = &proc0;
d223 2
a272 5
	/* Initialize signal state for process 0. */
	signal_init();
	p->p_sigacts = &sigacts0;
	siginit(p);

d274 8
a281 1
	p->p_fd = fdinit(NULL);
d292 4
a295 4
	lim = ptoa(uvmexp.free);
	limit0.pl_rlimit[RLIMIT_RSS].rlim_max = lim;
	limit0.pl_rlimit[RLIMIT_MEMLOCK].rlim_max = lim;
	limit0.pl_rlimit[RLIMIT_MEMLOCK].rlim_cur = lim / 3;
a315 1
	/* Initialize run queues */
a317 3
	/* Configure the devices */
	cpu_configure();

a361 1
	if_attachdomain();
d372 5
d388 1
a388 1
	/* Get the vnode for '/'.  Set p->p_fd->fd_cdir to reference it. */
d391 2
a392 2
	p->p_fd->fd_cdir = rootvnode;
	VREF(p->p_fd->fd_cdir);
d394 1
a394 1
	p->p_fd->fd_rdir = NULL;
d497 1
a497 2
	int options, error;
	long i;
d522 3
d526 1
d593 1
a593 2
		i = 0;
		copyout(&i, (caddr_t)--uap, sizeof(register_t)); /* terminator */
d595 2
a596 2
			copyout(&arg1, (caddr_t)--uap, sizeof(register_t));
		copyout(&arg0, (caddr_t)--uap, sizeof(register_t));
@


1.46.2.14
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.46.2.13 2003/03/28 00:41:26 niklas Exp $	*/
d514 1
a514 1
	    UVM_MAPFLAG(UVM_PROT_RW, UVM_PROT_ALL, UVM_INH_COPY,
@


1.46.2.15
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.46.2.14 2003/05/13 19:21:28 ho Exp $	*/
a180 1
	extern struct simplelock kprintf_slock;
a198 3

	simple_lock_init(&kprintf_slock);

a201 2
	KERNEL_LOCK_INIT();

d254 1
a254 1
	p->p_stat = SONPROC;
a327 3
	/* Lock the kernel on behalf of proc0. */
	KERNEL_PROC_LOCK(p);

d601 1
a601 2
		if ((error = sys_execve(p, &args, retval)) == 0) {
			KERNEL_PROC_UNLOCK(p);
a602 1
		}
@


1.46.2.16
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a82 2
#include <dev/rndvar.h>

a128 4
#if !defined(NO_PROPOLICE)
long	__guard[8];
#endif

a179 3
#if !defined(NO_PROPOLICE)
	int *guard = (int *)&__guard[0];
#endif
a374 5
#endif

#if !defined(NO_PROPOLICE)
	for (i = 0; i < sizeof(__guard) / 4; i++)
		guard[i] = arc4random();
@


1.46.2.17
log
@Go back to defining simplelocks as noops, even if MULTIPROCESSOR.  Instead use
a new real simple recursive-lock capable lock implementation for the few
necessary locks (kernel, scheduler, tlb shootdown, printf and ddb MP).
This because we cannot trust the old fine-grained locks spread out all over
our kernel, and not really tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.46.2.16 2003/05/16 00:29:43 niklas Exp $	*/
d190 1
a190 1
	extern struct SIMPLELOCK kprintf_slock;
d210 1
a210 1
	SIMPLE_LOCK_INIT(&kprintf_slock);
@


1.46.2.18
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.46.2.17 2003/05/18 17:41:16 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.46.2.19
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a59 1
#include <sys/lockf.h>
d102 1
a102 1
"Copyright (c) 1995-2004 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
a138 1
void	init_exec(void);
a162 1
	EMUL_ENABLED | EMUL_NATIVE,
a164 1

d182 3
a199 5
	 * Initialize timeouts.
	 */
	timeout_startup();

	/*
d227 5
a239 3
	/* Initialize file locking. */
	lf_init();

d383 2
a384 1
	arc4random_bytes(__guard, sizeof(__guard));
a386 3
	/* init exec and emul */
	init_exec();

d506 3
a508 3
		syscallarg(const char *) path;
		syscallarg(char *const *) argp;
		syscallarg(char *const *) envp;
@


1.46.2.20
log
@Make a few scheduling globals per-cpu, mostly NetBSD code
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.46.2.19 2004/02/19 10:56:37 niklas Exp $	*/
a124 1
#ifndef MULTIPROCESSOR
a125 1
#endif
d415 2
d422 1
a422 4
	p->p_stats->p_start = mono_time = boottime = time;
#ifdef MULTIPROCESSOR
	p->p_cpu->ci_schedstate.spc_runtime = time;
#endif
a423 2

	uvm_swap_init();
@


1.46.2.21
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d141 1
a141 1
void	start_crypto(void *);
a142 1
void	kqueue_init(void);
d216 2
a217 1
	printf("%s\n", copyright);
a254 5

	/*
	 * Initialize kqueues.
	 */
	kqueue_init();
@


1.46.2.22
log
@don't rely on curcpu() and other fixes for non-mp
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.46.2.21 2004/06/05 23:13:01 niklas Exp $	*/
a200 1
#ifdef MULTIPROCESSOR
a201 1
#endif
@


1.46.2.23
log
@Set runtime in the !MP case too.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.46.2.22 2004/06/06 21:46:12 tedu Exp $	*/
d429 1
a430 1
	p->p_stats->p_start = mono_time = boottime = time;
a431 2
#else
	p->p_stats->p_start = runtime = mono_time = boottime = time;	
@


1.46.2.24
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 1
a113 1
#if !defined(__HAVE_CPUINFO) && !defined(curproc)
d125 1
a125 1
#ifndef __HAVE_CPUINFO
d201 1
a201 1
#ifdef __HAVE_CPUINFO
d429 1
a429 1
#ifdef __HAVE_CPUINFO
@


1.45
log
@undo vfork changes, since non-UVM was not considered
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.43 2000/01/01 19:27:18 deraadt Exp $	*/
d402 1
a402 1
	if (fork1(p, ISFORK, 0, NULL, 0, rval))
@


1.44
log
@Change fork1() from taking forktype and rforkflags, into a single flags
argument. Let sys_rfork build the arguments to fork1() and do the
sanity checks itself.
@
text
@d402 1
a402 1
	if (fork1(p, FORK_FORK, NULL, 0, rval))
@


1.43
log
@2000
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.42 1999/11/05 01:18:01 mickey Exp $	*/
d402 1
a402 1
	if (fork1(p, ISFORK, 0, NULL, 0, rval))
@


1.42
log
@more stack direction fixes; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.41 1999/09/12 19:44:04 weingart Exp $	*/
d110 1
a110 1
"Copyright (c) 1995-1999 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n";
@


1.41
log
@Fix rootdev handling, use disk checksums to find the device we were booted
from.  Hopefully this will fix all the hangs/panics where the root device
was not found.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.40 1999/08/17 10:32:18 niklas Exp $	*/
d513 3
d517 1
d531 3
d535 1
@


1.40
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.39 1999/07/15 14:07:41 art Exp $	*/
d126 1
d368 3
a370 10
#ifdef i386
#include "bios.h"
#if NBIOS
	/* XXX This is only a transient solution */
	{
		extern void dkcsumattach __P((void));
		dkcsumattach();
	}
#endif
#endif
@


1.39
log
@vm_offset_t -> {v,p}addr_t ; vm_size_t -> {v,p}size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.38 1999/04/22 19:28:07 art Exp $	*/
d408 1
a408 1
	if (fork1(p, ISFORK, 0, rval))
@


1.38
log
@better panic message
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.37 1999/03/01 04:41:38 deraadt Exp $	*/
d487 1
a487 1
	vm_offset_t addr;
d529 1
a529 1
	if (vm_allocate(&p->p_vmspace->vm_map, &addr, (vm_size_t)PAGE_SIZE,
@


1.37
log
@re-do how copyright messages are done
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.36 1999/02/26 04:44:43 art Exp $	*/
d425 1
a425 1
		panic("fork pager");
@


1.36
log
@initialize uvm, make allocations work with uvm, namchanges for uvm, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.35 1999/01/11 01:37:13 niklas Exp $	*/
d108 3
a110 3
"Copyright (c) 1982, 1986, 1989, 1991, 1993\n\tThe Regents of the University of California.  All rights reserved.\n";
char	copyright_openbsd[] =
"Copyright (c) 1995-1999 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n\n";
d203 1
a203 1
	printf(copyright_openbsd);
@


1.35
log
@kthread abstraction from NetBSD, implemented with our rfork
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.34 1999/01/10 13:34:17 niklas Exp $	*/
d92 4
d205 3
d213 1
d265 3
d269 1
d276 5
d287 2
d306 3
d310 1
d390 3
d394 1
d442 3
d446 1
d520 9
d532 1
d612 3
d616 1
@


1.34
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.33 1999/01/02 00:38:37 deraadt Exp $	*/
d51 1
d228 1
a228 1
	p->p_flag = P_INMEM | P_SYSTEM;
d381 1
a381 1
	if (sys_fork(p, NULL, rval))
d390 1
a390 1
		return 0;
d393 1
a393 1
	cpu_set_kpc(pfind(1), start_init, pfind(1));
d396 2
a397 2
	/* Create process 2 (the pageout daemon). */
	if (sys_fork(p, NULL, rval))
a398 10
#ifdef cpu_set_init_frame			/* XXX should go away */
	if (rval[1]) {
		/*
		 * Now in process 2.
		 */
		start_pagedaemon(curproc);
	}
#else
	cpu_set_kpc(pfind(2), start_pagedaemon, pfind(2));
#endif
d400 3
a402 2
	/* Create process 3 (the update daemon). */
	if (sys_fork(p, NULL, rval))
d404 1
a404 6
#ifdef cpu_set_init_frame			/* XXX should go away */
	if (rval[1]) {
		/*
		 * Now in process 3.
		 */
		start_update(curproc);
d406 3
a408 3
#else
	cpu_set_kpc(pfind(3), start_update, pfind(3));
#endif
a570 7
	struct proc *p = arg;

	/*
	 * Now in process 2.
	 */
	p->p_flag |= P_INMEM | P_SYSTEM;	/* XXX */
	bcopy("pagedaemon", curproc->p_comm, sizeof ("pagedaemon"));
d579 1
a579 8
	struct proc *p = arg;

	/*
	 * Now in process 3.
	 */
	p->p_flag |= P_INMEM | P_SYSTEM;	/* XXX */
	bcopy("update", curproc->p_comm, sizeof ("update"));
	sched_sync(p);
@


1.33
log
@1999
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.32 1998/09/16 06:21:08 deraadt Exp $	*/
d129 3
a131 3
void	start_init __P((struct proc *));
void	start_pagedaemon __P((struct proc *));
void	start_update __P((struct proc *));
d392 1
a392 1
	cpu_set_kpc(pfind(1), start_init);
d406 1
a406 1
	cpu_set_kpc(pfind(2), start_pagedaemon);
d420 1
a420 1
	cpu_set_kpc(pfind(3), start_update);
d465 2
a466 2
start_init(p)
	struct proc *p;
d468 1
d581 2
a582 2
start_pagedaemon(p)
	struct proc *p;
d584 1
d596 2
a597 2
start_update(p)
	struct proc *p;
d599 1
@


1.32
log
@add openbsd copyright; if you have not talked to me about this already, do so now
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.31 1998/03/01 00:37:54 niklas Exp $	*/
d105 1
a105 1
"Copyright (c) 1995-1998 OpenBSD. All rights reserved.  http://www.OpenBSD.org\n\n";
@


1.31
log
@Merge of MACHINE_NEW_CONTIG (aka MNN) code from Chuck Cranor,
<chuck@@openbsd.org>. This code is as of yet disabled on all platforms,
actually not yet supported on more than mvme68k, although other
platforms are expected soon, as code is already available.
This code makes handling of multiple physical memory regions
consistent over all platforms, as well as keeping the performance of
maintaining a single continuous memory chunk.  It is also a
requirement for the upcoming UVM replacement VM system.

What I did in this merge: just declared the pmap_map function in a
MD include file per port that needs it.  It's not an exported pmap
interface, says Chuck.  It ended up in differnt include files on
differnet ports, as I tried to follow the current policy on a per-arch
basis.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.30 1998/02/20 13:41:33 niklas Exp $	*/
d103 3
a105 1
"Copyright (c) 1982, 1986, 1989, 1991, 1993\n\tThe Regents of the University of California.  All rights reserved.\n\n";
d198 1
@


1.30
log
@prototype dkcsumattach correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.29 1997/11/06 05:58:14 csapuntz Exp $	*/
d199 3
@


1.29
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.28 1997/11/06 02:17:29 mickey Exp $	*/
d342 1
a342 1
		extern dkcsumattach __P((void));
@


1.28
log
@mak kernel compiles w/o bios0
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.27 1997/10/28 10:52:17 niklas Exp $	*/
d349 1
a349 1
	if ((*mountroot)())
a351 1
	mountlist.cqh_first->mnt_op->vfs_refcount++;
d358 1
a358 1
	VOP_UNLOCK(rootvnode);
d597 1
a597 1
	vn_update();
@


1.27
log
@dkcsum is *really* mandatory.  XXX will be done differently later.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.26 1997/10/06 20:19:49 deraadt Exp $	*/
d338 2
d345 1
@


1.26
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.24 1997/07/28 09:13:17 deraadt Exp $	*/
d336 8
@


1.25
log
@VFS Lite2 Changes
@
text
@d338 1
a338 1
	if (vfs_mountroot())
d341 1
d348 1
a348 1
	VOP_UNLOCK(rootvnode, 0, p);
d587 1
a587 1
	sched_sync(p);
@


1.24
log
@two unneeded variables; enami@@ba2.so-net.or.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.23 1997/06/05 10:15:24 deraadt Exp $	*/
d338 1
a338 1
	if ((*mountroot)())
a340 1
	mountlist.cqh_first->mnt_op->vfs_refcount++;
d347 1
a347 1
	VOP_UNLOCK(rootvnode);
d586 1
a586 1
	vn_update();
@


1.23
log
@random pid generation, heh
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.22 1997/04/19 18:40:02 pefo Exp $	*/
d114 1
a114 1
struct	proc *initproc, *pageproc;
a570 1
	pageproc = p;
a584 1
	pageproc = p;
@


1.22
log
@Fix return with missin value...
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.21 1997/03/27 05:35:28 millert Exp $	*/
d410 1
@


1.21
log
@Implement NOFILE_MAX--hard limit on max descriptors per proccess.
Future direction, might make sense to make this a kernel symbol tha
is sysctl-able.
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.20 1996/11/06 01:29:46 deraadt Exp $	*/
d373 1
a373 1
		return;
@


1.20
log
@mountroot is prototyped elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.18 1996/09/21 11:06:08 deraadt Exp $	*/
d47 1
d98 4
d247 2
@


1.19
log
@random device is permanent now.
@
text
@a171 1
	extern int (*mountroot) __P((void));
@


1.18
log
@fix NFSSERVER w/o NFSCLIENT; netbsd pr#1780, cgd@@netbsd (yes, a 10month
old PR and the fix is mostly unchanged).
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.17 1996/09/04 22:35:27 niklas Exp $	*/
d309 1
@


1.17
log
@more Swedish pedantery, kill statics, provide protos etc
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.16 1996/08/31 09:24:08 pefo Exp $	*/
d93 4
d277 3
@


1.16
log
@Cleanup exec
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.15 1996/08/21 09:46:21 deraadt Exp $	*/
a114 3
static void start_init __P((struct proc *));
static void start_pagedaemon __P((struct proc *));
static void start_update __P((struct proc *));
d116 5
a120 1
int main __P((void *));
d433 1
a433 1
static void
d548 1
a548 1
static void
d563 1
a563 1
static void
@


1.15
log
@spit out a warning if /dev/console does not exist; from mouse@@Collatz.McRCIM.McGill.EDU
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.14 1996/08/13 03:12:41 deraadt Exp $	*/
d145 1
@


1.14
log
@microtime for srandom
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.13 1996/08/10 21:41:13 deraadt Exp $	*/
d56 1
d409 18
d461 2
@


1.13
log
@srandom() seeds random() at boottime
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.12 1996/06/16 10:28:39 deraadt Exp $	*/
d161 1
d390 2
a391 1
	srandom((u_long)(time.tv_sec ^ time.tv_usec));
@


1.12
log
@only call config_init() once
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.11 1996/06/11 03:25:12 tholo Exp $	*/
d388 2
@


1.11
log
@Kernel-implementation of update(8) my me
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.10 1996/06/10 07:25:54 deraadt Exp $	*/
a188 1
	config_init();		/* init autoconfiguration data structures */
@


1.10
log
@call tty_init() and config_init()
@
text
@d1 1
a1 1
/*	$OpenBSD: init_main.c,v 1.9 1996/05/27 07:59:02 deraadt Exp $	*/
d116 1
d376 14
d534 15
@


1.9
log
@native emul is now called "native"
@
text
@d1 2
a2 2
/*	$OpenBSD: init_main.c,v 1.5 1996/04/21 22:26:50 deraadt Exp $	*/
/*	$NetBSD: init_main.c,v 1.84 1996/04/22 01:38:12 christos Exp $	*/
d57 1
d187 2
@


1.8
log
@Make sure config_init gets called before consinit, as at least one port
actually uses config_* functions for console attachment.  Document
config_init should not call malloc as the move was over the mem-init
function calls too.
@
text
@d127 2
a128 2
struct emul emul_netbsd = {
	"netbsd",
d209 1
a209 1
	p->p_emul = &emul_netbsd;
@


1.7
log
@Return int from main(), so gcc -Werror won't complain.  Rhyme not intended.
@
text
@d174 1
d179 1
a185 1
	config_init();		/* init autoconfiguration data structures */
@


1.6
log
@sync syscalls, no sys/cpu.h
@
text
@d115 2
a116 1
void main __P((void *));
d152 2
a153 1
void
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: init_main.c,v 1.4 1996/03/03 17:19:39 niklas Exp $	*/
/*	$NetBSD: init_main.c,v 1.83 1996/04/04 00:26:28 cgd Exp $	*/
a65 1
#include <sys/cpu.h>
@


1.4
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: init_main.c,v 1.82 1996/02/09 18:59:21 christos Exp $	*/
d183 1
@


1.3
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 2
a2 1
/*	$NetBSD: init_main.c,v 1.80 1996/01/07 22:03:47 thorpej Exp $	*/
d66 12
d87 4
d116 1
d152 1
a152 1
int
d401 1
a401 1
	char **pathp, *path, *ucp, **uap, *arg0, *arg1;
@


1.2
log
@from netbsd; init proc0 fd0 differently
@
text
@d1 1
a1 1
/*	$NetBSD: init_main.c,v 1.79 1995/12/09 04:07:41 mycroft Exp $	*/
d147 1
d164 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: init_main.c,v 1.78 1995/10/07 06:28:05 mycroft Exp $	*/
a138 1
	register struct filedesc0 *fdp;
d196 6
a201 7
	fdp = &filedesc0;
	p->p_fd = &fdp->fd_fd;
	fdp->fd_fd.fd_refcnt = 1;
	fdp->fd_fd.fd_cmask = cmask;
	fdp->fd_fd.fd_ofiles = fdp->fd_dfiles;
	fdp->fd_fd.fd_ofileflags = fdp->fd_dfileflags;
	fdp->fd_fd.fd_nfiles = NDFILE;
d299 1
a299 1
	/* Get the vnode for '/'.  Set fdp->fd_fd.fd_cdir to reference it. */
d302 2
a303 2
	fdp->fd_fd.fd_cdir = rootvnode;
	VREF(fdp->fd_fd.fd_cdir);
d305 1
a305 1
	fdp->fd_fd.fd_rdir = NULL;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

