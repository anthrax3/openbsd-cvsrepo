head	1.40;
access;
symbols
	OPENBSD_6_0:1.39.0.2
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.28.0.10
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.6
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.4
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.14
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.12
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.8
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.10
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.6
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.4
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.4
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.23.0.4
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.21.0.4
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.18.0.4
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.2
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.15.0.4
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.17
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.4
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.40
date	2017.02.11.19.51.06;	author guenther;	state Exp;
branches;
next	1.39;
commitid	dp1qF9REvzwtzfTw;

1.39
date	2016.04.25.20.00.33;	author tedu;	state Exp;
branches;
next	1.38;
commitid	MLNYUlvoOtU8VX0s;

1.38
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.37;
commitid	gAjwyca5TfuoJAhn;

1.37
date	2015.12.31.18.55.33;	author mmcc;	state Exp;
branches;
next	1.36;
commitid	u408PZ7eYD87V4cE;

1.36
date	2015.09.10.18.10.35;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	pbNNrPaFfPV40pxN;

1.35
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.34;
commitid	p4LJxGKbi0BU2cG6;

1.34
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.33;
commitid	P6Av4XGqOi3rFasL;

1.33
date	2014.11.19.21.19.15;	author tedu;	state Exp;
branches;
next	1.32;
commitid	91Kze1UoAP17AkhC;

1.32
date	2014.11.18.05.23.14;	author tedu;	state Exp;
branches;
next	1.31;
commitid	jfc9xuqBEg55HxTK;

1.31
date	2014.07.13.23.59.58;	author tedu;	state Exp;
branches;
next	1.30;
commitid	cj6Q9NwR5jhdT18r;

1.30
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.29;
commitid	QlVV51SZgNFxsXxC;

1.29
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	EF98ch02VpFassUi;

1.28
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2012.02.15.04.26.27;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.07.23.45.00;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.29.14.12.19;	author chl;	state Exp;
branches;
next	1.24;

1.24
date	2006.11.14.18.00.27;	author jmc;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.12.04.31.24;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.01.07.02.39;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.07.07.31.40;	author marius;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.23.05.16.35;	author marius;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.14.04.00.33;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.03.21.14.59;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.18.22.01.15;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.22.22.04.42;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.10.26.12.03.27;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.22.14.14.08;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.14.13.31.52;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2000.09.26.14.01.38;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.01.04.03.14;	author assar;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.10.18.17.07.11;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.01.11.05.12.22;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.58.13;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.19.48;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.12.10;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	96.10.20.15.30.07;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	96.06.12.07.35.06;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.19.38;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.14.22.32.39;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.07.04.10.48.13;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.10.31.03.26.28;	author nate;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2004.06.05.23.13.01;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.05.19.22.31.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.40
log
@Add a flags argument to falloc() that lets it optionally set the
close-on-exec flag on the newly allocated fd.  Make falloc()'s
return arguments non-optional: assert that they're not NULL.

ok mpi@@ millert@@
@
text
@/*	$OpenBSD: exec_script.c,v 1.39 2016/04/25 20:00:33 tedu Exp $	*/
/*	$NetBSD: exec_script.c,v 1.13 1996/02/04 02:15:06 christos Exp $	*/

/*
 * Copyright (c) 1993, 1994 Christopher G. Demetriou
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/namei.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/exec.h>

#include <sys/exec_script.h>


/*
 * exec_script_makecmds(): Check if it's an executable shell script.
 *
 * Given a proc pointer and an exec package pointer, see if the referent
 * of the epp is in shell script.  If it is, then set things up so that
 * the script can be run.  This involves preparing the address space
 * and arguments for the shell which will run the script.
 *
 * This function is ultimately responsible for creating a set of vmcmds
 * which can be used to build the process's vm space and inserting them
 * into the exec package.
 */
int
exec_script_makecmds(struct proc *p, struct exec_package *epp)
{
	int error, hdrlinelen, shellnamelen, shellarglen;
	char *hdrstr = epp->ep_hdr;
	char *cp, *shellname, *shellarg, *oldpnbuf;
	char **shellargp = NULL, **tmpsap;
	struct vnode *scriptvp;
	uid_t script_uid = -1;
	gid_t script_gid = -1;
	u_short script_sbits;

	/*
	 * remember the old vp and pnbuf for later, so we can restore
	 * them if check_exec() fails.
	 */
	scriptvp = epp->ep_vp;
	oldpnbuf = epp->ep_ndp->ni_cnd.cn_pnbuf;

	/*
	 * if the magic isn't that of a shell script, or we've already
	 * done shell script processing for this exec, punt on it.
	 */
	if ((epp->ep_flags & EXEC_INDIR) != 0 ||
	    epp->ep_hdrvalid < EXEC_SCRIPT_MAGICLEN ||
	    strncmp(hdrstr, EXEC_SCRIPT_MAGIC, EXEC_SCRIPT_MAGICLEN))
		return ENOEXEC;

	/*
	 * check that the shell spec is terminated by a newline,
	 * and that it isn't too large.  Don't modify the
	 * buffer unless we're ready to commit to handling it.
	 * (The latter requirement means that we have to check
	 * for both spaces and tabs later on.)
	 */
	hdrlinelen = min(epp->ep_hdrvalid, MAXINTERP);
	for (cp = hdrstr + EXEC_SCRIPT_MAGICLEN; cp < hdrstr + hdrlinelen;
	    cp++) {
		if (*cp == '\n') {
			*cp = '\0';
			break;
		}
	}
	if (cp >= hdrstr + hdrlinelen)
		return ENOEXEC;

	shellname = NULL;
	shellarg = NULL;
	shellarglen = 0;

	/* strip spaces before the shell name */
	for (cp = hdrstr + EXEC_SCRIPT_MAGICLEN; *cp == ' ' || *cp == '\t';
	    cp++)
		;

	/* collect the shell name; remember its length for later */
	shellname = cp;
	shellnamelen = 0;
	if (*cp == '\0')
		goto check_shell;
	for ( /* cp = cp */ ; *cp != '\0' && *cp != ' ' && *cp != '\t'; cp++)
		shellnamelen++;
	if (*cp == '\0')
		goto check_shell;
	*cp++ = '\0';

	/* skip spaces before any argument */
	for ( /* cp = cp */ ; *cp == ' ' || *cp == '\t'; cp++)
		;
	if (*cp == '\0')
		goto check_shell;

	/*
	 * collect the shell argument.  everything after the shell name
	 * is passed as ONE argument; that's the correct (historical)
	 * behaviour.
	 */
	shellarg = cp;
	for ( /* cp = cp */ ; *cp != '\0'; cp++)
		shellarglen++;
	*cp++ = '\0';

check_shell:
	/*
	 * MNT_NOSUID and STRC are already taken care of by check_exec,
	 * so we don't need to worry about them now or later.
	 */
	script_sbits = epp->ep_vap->va_mode & (VSUID | VSGID);
	if (script_sbits != 0) {
		script_uid = epp->ep_vap->va_uid;
		script_gid = epp->ep_vap->va_gid;
	}
	/*
	 * if the script isn't readable, or it's set-id, then we've
	 * gotta supply a "/dev/fd/..." for the shell to read.
	 * Note that stupid shells (csh) do the wrong thing, and
	 * close all open fd's when they start.  That kills this
	 * method of implementing "safe" set-id and x-only scripts.
	 */
	vn_lock(scriptvp, LK_EXCLUSIVE|LK_RETRY, p);
	error = VOP_ACCESS(scriptvp, VREAD, p->p_ucred, p);
	VOP_UNLOCK(scriptvp, p);
	if (error == EACCES || script_sbits) {
		struct file *fp;

#ifdef DIAGNOSTIC
		if (epp->ep_flags & EXEC_HASFD)
			panic("exec_script_makecmds: epp already has a fd");
#endif

		fdplock(p->p_fd);
		error = falloc(p, 0, &fp, &epp->ep_fd);
		fdpunlock(p->p_fd);
		if (error)
			goto fail;

		epp->ep_flags |= EXEC_HASFD;
		fp->f_type = DTYPE_VNODE;
		fp->f_ops = &vnops;
		fp->f_data = (caddr_t) scriptvp;
		fp->f_flag = FREAD;
		FILE_SET_MATURE(fp, p);
	}

	/* set up the parameters for the recursive check_exec() call */
	epp->ep_ndp->ni_dirfd = AT_FDCWD;
	epp->ep_ndp->ni_dirp = shellname;
	epp->ep_ndp->ni_segflg = UIO_SYSSPACE;
	epp->ep_flags |= EXEC_INDIR;

	/* and set up the fake args list, for later */
	shellargp = mallocarray(4, sizeof(char *), M_EXEC, M_WAITOK);
	tmpsap = shellargp;
	*tmpsap = malloc(shellnamelen + 1, M_EXEC, M_WAITOK);
	strlcpy(*tmpsap++, shellname, shellnamelen + 1);
	if (shellarg != NULL) {
		*tmpsap = malloc(shellarglen + 1, M_EXEC, M_WAITOK);
		strlcpy(*tmpsap++, shellarg, shellarglen + 1);
	}
	*tmpsap = malloc(MAXPATHLEN, M_EXEC, M_WAITOK);
	if ((epp->ep_flags & EXEC_HASFD) == 0) {
		error = copyinstr(epp->ep_name, *tmpsap, MAXPATHLEN,
		    NULL);
		if (error != 0) {
			*(tmpsap + 1) = NULL;
			goto fail;
		}
	} else
		snprintf(*tmpsap, MAXPATHLEN, "/dev/fd/%d", epp->ep_fd);
	tmpsap++;
	*tmpsap = NULL;

	/*
	 * mark the header we have as invalid; check_exec will read
	 * the header from the new executable
	 */
	epp->ep_hdrvalid = 0;

	if ((error = check_exec(p, epp)) == 0) {
		/* note that we've clobbered the header */
		epp->ep_flags |= EXEC_DESTR;

		/*
		 * It succeeded.  Unlock the script and
		 * close it if we aren't using it any more.
		 * Also, set things up so that the fake args
		 * list will be used.
		 */
		if ((epp->ep_flags & EXEC_HASFD) == 0)
			vn_close(scriptvp, FREAD, p->p_ucred, p);

		/* free the old pathname buffer */
		pool_put(&namei_pool, oldpnbuf);

		epp->ep_flags |= (EXEC_HASARGL | EXEC_SKIPARG);
		epp->ep_fa = shellargp;
		/*
		 * set things up so that set-id scripts will be
		 * handled appropriately
		 */
		epp->ep_vap->va_mode |= script_sbits;
		if (script_sbits & VSUID)
			epp->ep_vap->va_uid = script_uid;
		if (script_sbits & VSGID)
			epp->ep_vap->va_gid = script_gid;
		return (0);
	}

	/* XXX oldpnbuf not set for "goto fail" path */
	epp->ep_ndp->ni_cnd.cn_pnbuf = oldpnbuf;
fail:
	/* note that we've clobbered the header */
	epp->ep_flags |= EXEC_DESTR;

	/* kill the opened file descriptor, else close the file */
	if (epp->ep_flags & EXEC_HASFD) {
		epp->ep_flags &= ~EXEC_HASFD;
		fdplock(p->p_fd);
		(void) fdrelease(p, epp->ep_fd);
		fdpunlock(p->p_fd);
	} else
		vn_close(scriptvp, FREAD, p->p_ucred, p);

	pool_put(&namei_pool, epp->ep_ndp->ni_cnd.cn_pnbuf);

	/* free the fake arg list, because we're not returning it */
	if ((tmpsap = shellargp) != NULL) {
		while (*tmpsap != NULL) {
			free(*tmpsap, M_EXEC, 0);
			tmpsap++;
		}
		free(shellargp, M_EXEC, 4 * sizeof(char *));
	}

	/*
	 * free any vmspace-creation commands,
	 * and release their references
	 */
	kill_vmcmds(&epp->ep_vmcmds);

	return error;
}
@


1.39
log
@boom goes the dynamite
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.38 2016/03/19 12:04:15 natano Exp $	*/
d172 1
a172 1
		error = falloc(p, &fp, &epp->ep_fd);
@


1.38
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.37 2015/12/31 18:55:33 mmcc Exp $	*/
a47 6
#include "systrace.h"

#if NSYSTRACE > 0
#include <dev/systrace.h>
#endif

d202 2
a203 15
#if NSYSTRACE > 0
		if (ISSET(p->p_flag, P_SYSTRACE)) {
			error = systrace_scriptname(p, *tmpsap);
			if (error != 0)
				/*
				 * Since systrace_scriptname() provides a
				 * convenience, not a security issue, we are
				 * safe to do this.
				 */
				error = copystr(epp->ep_name, *tmpsap,
				    MAXPATHLEN, NULL);
		} else
#endif
			error = copyinstr(epp->ep_name, *tmpsap, MAXPATHLEN,
			    NULL);
@


1.37
log
@NULL-terminate a pointer array to prevent an invalid free, and simplify
the associated pointer incrementing logic.

Reported by Maxim Pugachev. Looks good to tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.36 2015/09/10 18:10:35 deraadt Exp $	*/
d168 1
a168 1
	VOP_UNLOCK(scriptvp, 0, p);
@


1.36
log
@sizes for free(); ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.35 2015/03/14 03:38:50 jsg Exp $	*/
d211 1
a211 3
			if (error == 0)
				tmpsap++;
			else
d217 1
a217 1
				error = copystr(epp->ep_name, *tmpsap++,
d221 1
a221 1
			error = copyinstr(epp->ep_name, *tmpsap++, MAXPATHLEN,
d223 2
a224 1
		if (error != 0)
d226 1
d228 2
a229 1
		snprintf(*tmpsap++, MAXPATHLEN, "/dev/fd/%d", epp->ep_fd);
@


1.35
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.34 2014/12/16 18:30:03 tedu Exp $	*/
d290 1
a290 1
		free(shellargp, M_EXEC, 0);
@


1.34
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.33 2014/11/19 21:19:15 tedu Exp $	*/
a44 1
#include <sys/resourcevar.h>
@


1.33
log
@panic should be reserved for unrecoverable errors, not things we merely
hope don't happen. also, always check for errors. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.32 2014/11/18 05:23:14 tedu Exp $	*/
d40 1
@


1.32
log
@unifdef SETUIDSCRIPT and FDSCRIPT. we always use them. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.31 2014/07/13 23:59:58 tedu Exp $	*/
a207 1
		/* normally can't fail, but check for it if diagnostic */
a224 1
#ifdef DIAGNOSTIC
d226 1
a226 2
			panic("exec_script: copyinstr couldn't fail");
#endif
@


1.31
log
@use mallocarray for multiplied value checking
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.30 2014/07/12 18:43:32 tedu Exp $	*/
a53 3
#if defined(SETUIDSCRIPTS) && !defined(FDSCRIPTS)
#define FDSCRIPTS		/* Need this for safe set-id scripts. */
#endif
a74 1
#ifdef SETUIDSCRIPTS
a77 1
#endif
a149 1
#ifdef SETUIDSCRIPTS
a158 2
#endif
#ifdef FDSCRIPTS
d169 1
a169 5
	if (error == EACCES
#ifdef SETUIDSCRIPTS
	    || script_sbits
#endif
	    ) {
a189 1
#endif
a206 1
#ifdef FDSCRIPTS
a207 1
#endif
d223 1
a225 4
#else
		error = copyinstr(epp->ep_name, *tmpsap++, MAXPATHLEN,
		    (size_t *)0);
#endif
a229 1
#ifdef FDSCRIPTS
a231 1
#endif
a257 1
#ifdef SETUIDSCRIPTS
a266 1
#endif
a271 1
#ifdef FDSCRIPTS
a272 1
#endif
@


1.30
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.29 2014/07/08 17:19:25 deraadt Exp $	*/
d211 1
a211 1
	shellargp = malloc(4 * sizeof(char *), M_EXEC, M_WAITOK);
@


1.29
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.28 2012/04/22 05:43:14 guenther Exp $	*/
d314 1
a314 1
			free(*tmpsap, M_EXEC);
d317 1
a317 1
		free(shellargp, M_EXEC);
@


1.28
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.27 2012/02/15 04:26:27 guenther Exp $	*/
a44 1
#include <uvm/uvm_extern.h>
@


1.27
log
@Hold struct filedesc's fd_lock when writing to the fd_ofiles, fd_ofileflags,
or fd_{lo,hi}maps members, or when doing a read for a write.  Fixes hangs
when an rthreaded processes sleeps while copying the fd table for fork()
and catches another thread with the lock.

ok jsing@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.26 2011/07/07 23:45:00 matthew Exp $	*/
d201 1
a201 1
		FILE_SET_MATURE(fp);
@


1.26
log
@Add new syscall entries to support the openat(2) family of functions
added in POSIX Issue 7: openat(), mknodat(), mkfifoat(), linkat(),
symlinkat(), unlinkat(), faccessat(), fstatat(), readlinkat(),
fchmodat(), fchownat(), utimensat(), renameat(), and mkdirat().

This diff mostly just refactors the existing sys_foo() logic into a
common dofooat() function that can then be called by both sys_foo()
and sys_fooat().  Some of the new system calls support new flags to
control their behavior, and proper support for these will be added in
subsequent diffs.

Incorporating suggestions from thib@@, guenther@@, and tedu@@.

ok tedu@@, thib@@, deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.25 2007/10/29 14:12:19 chl Exp $	*/
d190 4
a193 1
		if ((error = falloc(p, &fp, &epp->ep_fd)))
d304 1
d306 1
@


1.25
log
@MALLOC/FREE -> malloc/free
replace an hard coded value with M_WAITOK

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.24 2006/11/14 18:00:27 jmc Exp $	*/
d203 1
@


1.24
log
@grammar, spelling, and style fixes from bret lambert;
kern_descrip.c change ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.23 2005/11/12 04:31:24 jsg Exp $	*/
d208 1
a208 1
	MALLOC(shellargp, char **, 4 * sizeof(char *), M_EXEC, M_WAITOK);
d312 1
a312 1
		FREE(shellargp, M_EXEC);
@


1.23
log
@ansi. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.22 2005/08/01 07:02:39 art Exp $	*/
d63 1
a63 1
 * of the epp is in shell script.  If it is, then set thing up so that
d128 1
a128 1
	/* collect the shell name; remember it's length for later */
d172 1
a172 1
	 * close all open fd's when the start.  That kills this
d277 1
a277 1
		 * set thing up so that set-id scripts will be
@


1.22
log
@ - We shouldn't allocate MAXPATHLEN from the stack.
 - Don't copy the pathbuf into kernel space unless we're systracing.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.21 2004/07/07 07:31:40 marius Exp $	*/
d72 1
a72 3
exec_script_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
@


1.21
log
@fix an issue when scripts are exec'd under systrace where
the argv[0] would be normalized, and hence break scripts
that depend on how they were called.

this fixes an issue in the ports builds.

ok provos@@ deraadt@@; lots of testing during hackathon sturm@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.20 2004/06/23 05:16:35 marius Exp $	*/
a223 1
		error = 1;
d228 11
a238 9
		}
		if (error != 0)
			/*
			 * Since systrace_scriptname() provides a
			 * convenience, not a security issue, we are
			 * safe to do this.
			 */
			error = copystr(epp->ep_name, *tmpsap++,
			    MAXPATHLEN, NULL);
@


1.20
log
@a few fixes to systrace

- add an exec message so that whenever a set-uid/gid process
  exec's a new image which we may control, the exec does not
  go by unnoticed.

- take special care to check for P_SUGIDEXEC as well as
  P_SUGID, corresponding to the same changes that were made in
  the ptrace code a while ago

ok niels@@, sturm@@; thanks to naddy for testing
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.19 2004/05/14 04:00:33 tedu Exp $	*/
d224 14
a237 2
		error = copystr(epp->ep_name, *tmpsap++, MAXPATHLEN,
		    (size_t *)0);
d240 1
a240 1
		    (size_t *)0);		
@


1.19
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.18 2003/05/03 21:14:59 deraadt Exp $	*/
d49 6
d223 4
d228 2
a229 1
		    (size_t *)0);
@


1.18
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.17 2002/09/18 22:01:15 art Exp $	*/
d38 1
d249 1
a249 1
		FREE(oldpnbuf, M_NAMEI);
d282 1
a282 1
	FREE(epp->ep_ndp->ni_cnd.cn_pnbuf, M_NAMEI);
@


1.17
log
@We can jump to the fail: label before shellargp is initialized.
Make sure that we don't free random memory when that happens.
From <j at pureftpd.org>
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.16 2002/08/22 22:04:42 art Exp $	*/
d206 1
a206 1
	strcpy(*tmpsap++, shellname);
d209 1
a209 1
		strcpy(*tmpsap++, shellarg);
d224 1
a224 1
		sprintf(*tmpsap++, "/dev/fd/%d", epp->ep_fd);
@


1.16
log
@Change the vnode locking in exec to not keep the vnode locked almost all
the time.

This could lead to problems when a process wants to do an exec on the same
vnode it's being run from and needs to copy in arguments from an uncached
page in the data segment. When that happens uvm detects a vnode deadlock
and returns an error causing execve() return EFAULT.

This fixes the regress test in regress/sys/kern/exec_self

Also, initialize scriptvp early in exec_script because it could be
used uninitialized in a failure case.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.15 2001/11/06 19:53:20 miod Exp $	*/
d72 1
a72 1
	char **shellargp, **tmpsap;
d284 6
a289 4
	tmpsap = shellargp;
	while (*tmpsap != NULL) {
		free(*tmpsap, M_EXEC);
		tmpsap++;
a290 1
	FREE(shellargp, M_EXEC);
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.14 2001/10/26 12:03:27 art Exp $	*/
d81 7
d170 4
a173 1
	if (VOP_ACCESS(epp->ep_vp, VREAD, p->p_ucred, p) == EACCES
d191 1
a191 1
		fp->f_data = (caddr_t) epp->ep_vp;
a232 9

	/*
	 * remember the old vp and pnbuf for later, so we can restore
	 * them if check_exec() fails.
	 */
	scriptvp = epp->ep_vp;
	oldpnbuf = epp->ep_ndp->ni_cnd.cn_pnbuf;

	VOP_UNLOCK(scriptvp, 0, p);
@


1.15.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.15 2001/11/06 19:53:20 miod Exp $	*/
d72 1
a72 1
	char **shellargp = NULL, **tmpsap;
a80 7
	 * remember the old vp and pnbuf for later, so we can restore
	 * them if check_exec() fails.
	 */
	scriptvp = epp->ep_vp;
	oldpnbuf = epp->ep_ndp->ni_cnd.cn_pnbuf;

	/*
d163 1
a163 4
	vn_lock(scriptvp, LK_EXCLUSIVE|LK_RETRY, p);
	error = VOP_ACCESS(scriptvp, VREAD, p->p_ucred, p);
	VOP_UNLOCK(scriptvp, 0, p);
	if (error == EACCES
d181 1
a181 1
		fp->f_data = (caddr_t) scriptvp;
d224 9
d283 4
a286 6
	if ((tmpsap = shellargp) != NULL) {
		while (*tmpsap != NULL) {
			free(*tmpsap, M_EXEC);
			tmpsap++;
		}
		FREE(shellargp, M_EXEC);
d288 1
@


1.15.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d206 1
a206 1
	strlcpy(*tmpsap++, shellname, shellnamelen + 1);
d209 1
a209 1
		strlcpy(*tmpsap++, shellarg, shellarglen + 1);
d224 1
a224 1
		snprintf(*tmpsap++, MAXPATHLEN, "/dev/fd/%d", epp->ep_fd);
@


1.14
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.13 2001/06/22 14:14:08 deraadt Exp $	*/
d44 1
a44 1
#include <vm/vm.h>
@


1.13
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.12 2001/05/14 13:31:52 art Exp $	*/
d183 1
@


1.12
log
@ifdef FOO inside an ifdef FOO feels like overkill.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.11 2000/09/26 14:01:38 art Exp $	*/
d273 4
a276 4
        if (epp->ep_flags & EXEC_HASFD) {
                epp->ep_flags &= ~EXEC_HASFD;
                (void) fdrelease(p, epp->ep_fd);
        } else
d279 1
a279 1
        FREE(epp->ep_ndp->ni_cnd.cn_pnbuf, M_NAMEI);
d289 5
a293 5
        /*
         * free any vmspace-creation commands,
         * and release their references
         */
        kill_vmcmds(&epp->ep_vmcmds);
d295 1
a295 1
        return error;
@


1.11
log
@Don't use MALLOC/FREE on variable sized allocations.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.10 2000/02/01 04:03:14 assar Exp $	*/
d170 1
a170 1
#if defined(DIAGNOSTIC) && defined(FDSCRIPTS)
@


1.10
log
@remove superflous declaration of vnops, it's now in <sys/file.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.9 1999/10/18 17:07:11 deraadt Exp $	*/
d194 1
a194 1
	MALLOC(*tmpsap, char *, shellnamelen + 1, M_EXEC, M_WAITOK);
d197 1
a197 1
		MALLOC(*tmpsap, char *, shellarglen + 1, M_EXEC, M_WAITOK);
d200 1
a200 1
	MALLOC(*tmpsap, char *, MAXPATHLEN, M_EXEC, M_WAITOK);
d284 1
a284 1
		FREE(*tmpsap, M_EXEC);
@


1.10.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.11 2000/09/26 14:01:38 art Exp $	*/
d194 1
a194 1
	*tmpsap = malloc(shellnamelen + 1, M_EXEC, M_WAITOK);
d197 1
a197 1
		*tmpsap = malloc(shellarglen + 1, M_EXEC, M_WAITOK);
d200 1
a200 1
	*tmpsap = malloc(MAXPATHLEN, M_EXEC, M_WAITOK);
d284 1
a284 1
		free(*tmpsap, M_EXEC);
@


1.10.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.10.2.1 2001/05/14 22:32:39 niklas Exp $	*/
d170 1
a170 1
#ifdef DIAGNOSTIC
d273 4
a276 4
	if (epp->ep_flags & EXEC_HASFD) {
		epp->ep_flags &= ~EXEC_HASFD;
		(void) fdrelease(p, epp->ep_fd);
	} else
d279 1
a279 1
	FREE(epp->ep_ndp->ni_cnd.cn_pnbuf, M_NAMEI);
d289 5
a293 5
	/*
	 * free any vmspace-creation commands,
	 * and release their references
	 */
	kill_vmcmds(&epp->ep_vmcmds);
d295 1
a295 1
	return error;
@


1.10.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.10.2.2 2001/07/04 10:48:13 niklas Exp $	*/
a182 1
		FILE_SET_MATURE(fp);
@


1.10.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
#include <uvm/uvm_extern.h>
@


1.10.2.5
log
@Sync the SMP branch with 3.3
@
text
@d72 1
a72 1
	char **shellargp = NULL, **tmpsap;
a80 7
	 * remember the old vp and pnbuf for later, so we can restore
	 * them if check_exec() fails.
	 */
	scriptvp = epp->ep_vp;
	oldpnbuf = epp->ep_ndp->ni_cnd.cn_pnbuf;

	/*
d163 1
a163 4
	vn_lock(scriptvp, LK_EXCLUSIVE|LK_RETRY, p);
	error = VOP_ACCESS(scriptvp, VREAD, p->p_ucred, p);
	VOP_UNLOCK(scriptvp, 0, p);
	if (error == EACCES
d181 1
a181 1
		fp->f_data = (caddr_t) scriptvp;
d224 9
d283 4
a286 6
	if ((tmpsap = shellargp) != NULL) {
		while (*tmpsap != NULL) {
			free(*tmpsap, M_EXEC);
			tmpsap++;
		}
		FREE(shellargp, M_EXEC);
d288 1
@


1.10.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.10.2.5 2003/03/28 00:41:26 niklas Exp $	*/
d206 1
a206 1
	strlcpy(*tmpsap++, shellname, shellnamelen + 1);
d209 1
a209 1
		strlcpy(*tmpsap++, shellarg, shellarglen + 1);
d224 1
a224 1
		snprintf(*tmpsap++, MAXPATHLEN, "/dev/fd/%d", epp->ep_fd);
@


1.10.2.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a37 1
#include <sys/pool.h>
d248 1
a248 1
		pool_put(&namei_pool, oldpnbuf);
d281 1
a281 1
	pool_put(&namei_pool, epp->ep_ndp->ni_cnd.cn_pnbuf);
@


1.9
log
@force FDSCRIPTS after include files are pulled in
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.8 1999/01/11 05:12:22 millert Exp $	*/
a168 1
		extern struct fileops vnops;
@


1.8
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.7 1997/11/06 05:58:13 csapuntz Exp $	*/
a33 4
#if defined(SETUIDSCRIPTS) && !defined(FDSCRIPTS)
#define FDSCRIPTS		/* Need this for safe set-id scripts. */
#endif

d47 4
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.6 1997/10/06 20:19:48 deraadt Exp $	*/
d210 1
a210 1
			panic("exec_script: copyinstr couldn't fail\n");
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.4 1996/10/20 15:30:07 dm Exp $	*/
d231 1
a231 1
	VOP_UNLOCK(scriptvp);
@


1.5
log
@VFS Lite2 Changes
@
text
@d231 1
a231 1
	VOP_UNLOCK(scriptvp, 0, p);
@


1.4
log
@Make it build with -Wparentheses.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_script.c,v 1.3 1996/06/12 07:35:06 deraadt Exp $	*/
d231 1
a231 1
	VOP_UNLOCK(scriptvp);
@


1.3
log
@warning: variable might be used uninitialized -- sucks
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d176 1
a176 1
		if (error = falloc(p, &fp, &epp->ep_fd))
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d75 2
a76 2
	uid_t script_uid;
	gid_t script_gid;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: exec_script.c,v 1.12 1995/04/10 18:27:59 mycroft Exp $	*/
d109 1
a138 1
	shellarglen = 0;
d267 1
d269 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
