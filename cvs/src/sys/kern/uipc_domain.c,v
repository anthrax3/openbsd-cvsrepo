head	1.52;
access;
symbols
	OPENBSD_6_1:1.49.0.4
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.45.0.2
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.32.0.10
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.8
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.30.0.4
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.6
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.4
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.4
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.6
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.4
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.52
date	2017.08.11.21.24.19;	author mpi;	state Exp;
branches;
next	1.51;
commitid	qO4hXiGM2yDTtiTI;

1.51
date	2017.05.27.08.02.40;	author claudio;	state Exp;
branches;
next	1.50;
commitid	K3HTnnPNec6uTnyH;

1.50
date	2017.05.09.09.37.25;	author mpi;	state Exp;
branches;
next	1.49;
commitid	SZC6ZZHyj450ksmY;

1.49
date	2017.02.27.19.16.56;	author claudio;	state Exp;
branches;
next	1.48;
commitid	Ukq2QkllmG8rHpFv;

1.48
date	2016.12.20.21.15.36;	author mpi;	state Exp;
branches;
next	1.47;
commitid	FnVGQnLcvAzzyTgP;

1.47
date	2016.12.20.18.33.43;	author bluhm;	state Exp;
branches;
next	1.46;
commitid	xiXE7MGPpVXw2TS3;

1.46
date	2016.11.22.10.32.31;	author mpi;	state Exp;
branches;
next	1.45;
commitid	ZGbETuPKamiepsCV;

1.45
date	2016.03.03.00.34.10;	author dlg;	state Exp;
branches;
next	1.44;
commitid	ezg1LWzK2DiU4ZiM;

1.44
date	2016.03.03.00.25.09;	author dlg;	state Exp;
branches;
next	1.43;
commitid	XRpxNAz8nTIvhsin;

1.43
date	2015.09.04.08.43.39;	author mpi;	state Exp;
branches;
next	1.42;
commitid	qAevExm24QrBjVNL;

1.42
date	2015.08.30.10.39.16;	author mpi;	state Exp;
branches;
next	1.41;
commitid	avqdJydG8T8nvZhe;

1.41
date	2015.07.17.18.31.08;	author blambert;	state Exp;
branches;
next	1.40;
commitid	WEUQfMsVq6mbe3cF;

1.40
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.39;
commitid	p4LJxGKbi0BU2cG6;

1.39
date	2014.12.23.03.26.24;	author tedu;	state Exp;
branches;
next	1.38;
commitid	5maZww1zcSNGP9Eu;

1.38
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.37;
commitid	uzzBR7hz9ncd4O6G;

1.37
date	2014.07.11.21.54.38;	author tedu;	state Exp;
branches;
next	1.36;
commitid	0n9cIGBISFAEt4b1;

1.36
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	EF98ch02VpFassUi;

1.35
date	2014.03.11.19.45.28;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2014.01.19.03.04.54;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2013.08.20.09.14.21;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.09.00.47.18;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.08.18.30.16;	author yasuoka;	state Exp;
branches;
next	1.30;

1.30
date	2010.07.02.15.02.38;	author blambert;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.13.20.54.05;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2008.09.16.15.48.12;	author gollo;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.23.10.55.14;	author norby;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.06.10.04.36;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2007.01.18.20.00.18;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.15.10.46.58;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2005.06.08.06.18.54;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2005.06.07.02.30.47;	author henning;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.14.12.04.02;	author grange;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.27.14.50.55;	author pat;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.25.21.40.46;	author markus;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.15.17.46.44;	author grange;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.01.23.56.05;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.24.21.43.55;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.12.00.48.52;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.05;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.09.12.16.39.14;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.23.10.42.29;	author art;	state Exp;
branches;
next	1.9;

1.9
date	99.12.08.06.50.17;	author itojun;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.03.30.00.19.05;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.02.24.22.19.20;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	99.01.07.22.30.34;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.07.23.04.33.53;	author denny;	state Exp;
branches;
next	1.4;

1.4
date	97.02.20.01.07.26;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.27.13.21.06;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.20.16;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	2000.03.24.09.09.25;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.05.14.22.32.44;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2004.06.05.23.13.02;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.52
log
@Remove NET_LOCK()'s argument.

Tested by Hrvoje Popovski, ok bluhm@@
@
text
@/*	$OpenBSD: uipc_domain.c,v 1.51 2017/05/27 08:02:40 claudio Exp $	*/
/*	$NetBSD: uipc_domain.c,v 1.14 1996/02/09 19:00:44 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)uipc_domain.c	8.2 (Berkeley) 10/18/93
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/protosw.h>
#include <sys/domain.h>
#include <sys/mbuf.h>
#include <sys/time.h>
#include <sys/systm.h>
#include <sys/sysctl.h>
#include <sys/timeout.h>

#include "bpfilter.h"
#include "pflow.h"

extern struct domain mplsdomain;
extern struct domain pfkeydomain;
extern struct domain inet6domain;
extern struct domain inetdomain;
extern struct domain unixdomain;
extern struct domain routedomain;

struct domain *domains[] = {
#ifdef MPLS
	&mplsdomain,
#endif
#if defined (IPSEC) || defined (TCP_SIGNATURE)
	&pfkeydomain,
#endif
#ifdef INET6
	&inet6domain,
#endif /* INET6 */
	&inetdomain,
	&unixdomain,
	&routedomain,
	NULL
};

void		pffasttimo(void *);
void		pfslowtimo(void *);
struct domain *	pffinddomain(int);

void
domaininit(void)
{
	struct domain *dp;
	struct protosw *pr;
	static struct timeout pffast_timeout;
	static struct timeout pfslow_timeout;
	int i;

	for (i = 0; (dp = domains[i]) != NULL; i++) {
		if (dp->dom_init)
			(*dp->dom_init)();
		for (pr = dp->dom_protosw; pr < dp->dom_protoswNPROTOSW; pr++)
			if (pr->pr_init)
				(*pr->pr_init)();
	}

	/*
	 * max_linkhdr of 64 was chosen to encompass tunnelling
	 * traffic in IP payloads, eg, by etherip(4) or gif(4),
	 * without needing to prepend an mbuf to fit those
	 * headers.
	 */
	if (max_linkhdr < 64)
		max_linkhdr = 64;

	max_hdr = max_linkhdr + max_protohdr;
	timeout_set_proc(&pffast_timeout, pffasttimo, &pffast_timeout);
	timeout_set_proc(&pfslow_timeout, pfslowtimo, &pfslow_timeout);
	timeout_add(&pffast_timeout, 1);
	timeout_add(&pfslow_timeout, 1);
}

struct domain *
pffinddomain(int family)
{
	struct domain *dp;
	int i;

	for (i = 0; (dp = domains[i]) != NULL; i++) {
		if (dp->dom_family == family)
			return (dp);
	}
	return (NULL);
}

struct protosw *
pffindtype(int family, int type)
{
	struct domain *dp;
	struct protosw *pr;

	dp = pffinddomain(family);
	if (dp == NULL)
		return (NULL);

	for (pr = dp->dom_protosw; pr < dp->dom_protoswNPROTOSW; pr++)
		if (pr->pr_type && pr->pr_type == type)
			return (pr);
	return (NULL);
}

struct protosw *
pffindproto(int family, int protocol, int type)
{
	struct domain *dp;
	struct protosw *pr;
	struct protosw *maybe = NULL;

	if (family == 0)
		return (NULL);

	dp = pffinddomain(family);
	if (dp == NULL)
		return (NULL);

	for (pr = dp->dom_protosw; pr < dp->dom_protoswNPROTOSW; pr++) {
		if ((pr->pr_protocol == protocol) && (pr->pr_type == type))
			return (pr);

		if (type == SOCK_RAW && pr->pr_type == SOCK_RAW &&
		    pr->pr_protocol == 0 && maybe == NULL)
			maybe = pr;
	}
	return (maybe);
}

int
net_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	struct domain *dp;
	struct protosw *pr;
	int error, family, protocol;

	/*
	 * All sysctl names at this level are nonterminal.
	 * Usually: next two components are protocol family and protocol
	 *	number, then at least one addition component.
	 */
	if (namelen < 2)
		return (EISDIR);		/* overloaded */
	family = name[0];

	if (family == 0)
		return (0);
#if NBPFILTER > 0
	if (family == PF_BPF)
		return (bpf_sysctl(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
#if NPFLOW > 0
	if (family == PF_PFLOW)
		return (pflow_sysctl(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
#ifdef PIPEX
	if (family == PF_PIPEX)
		return (pipex_sysctl(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
#ifdef MPLS
	if (family == PF_MPLS)
		return (mpls_sysctl(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
	dp = pffinddomain(family);
	if (dp == NULL)
		return (ENOPROTOOPT);

	if (namelen < 3)
		return (EISDIR);		/* overloaded */
	protocol = name[1];
	for (pr = dp->dom_protosw; pr < dp->dom_protoswNPROTOSW; pr++)
		if (pr->pr_protocol == protocol && pr->pr_sysctl) {
			NET_LOCK();
			error = (*pr->pr_sysctl)(name + 2, namelen - 2,
			    oldp, oldlenp, newp, newlen);
			NET_UNLOCK();
			return (error);
		}
	return (ENOPROTOOPT);
}

void
pfctlinput(int cmd, struct sockaddr *sa)
{
	struct domain *dp;
	struct protosw *pr;
	int i;

	NET_ASSERT_LOCKED();

	for (i = 0; (dp = domains[i]) != NULL; i++) {
		for (pr = dp->dom_protosw; pr < dp->dom_protoswNPROTOSW; pr++)
			if (pr->pr_ctlinput)
				(*pr->pr_ctlinput)(cmd, sa, 0, NULL);
	}
}

void
pfslowtimo(void *arg)
{
	struct timeout *to = (struct timeout *)arg;
	struct domain *dp;
	struct protosw *pr;
	int i;

	NET_LOCK();
	for (i = 0; (dp = domains[i]) != NULL; i++) {
		for (pr = dp->dom_protosw; pr < dp->dom_protoswNPROTOSW; pr++)
			if (pr->pr_slowtimo)
				(*pr->pr_slowtimo)();
	}
	NET_UNLOCK();
	timeout_add_msec(to, 500);
}

void
pffasttimo(void *arg)
{
	struct timeout *to = (struct timeout *)arg;
	struct domain *dp;
	struct protosw *pr;
	int i;

	NET_LOCK();
	for (i = 0; (dp = domains[i]) != NULL; i++) {
		for (pr = dp->dom_protosw; pr < dp->dom_protoswNPROTOSW; pr++)
			if (pr->pr_fasttimo)
				(*pr->pr_fasttimo)();
	}
	NET_UNLOCK();
	timeout_add_msec(to, 200);
}
@


1.51
log
@Kill option KEY, it is a useless knob, nobody uses pfkeyv2 without IPSEC or
tcp md5. OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.50 2017/05/09 09:37:25 mpi Exp $	*/
d168 1
a168 1
	int s, error, family, protocol;
d210 1
a210 1
			NET_LOCK(s);
d213 1
a213 1
			NET_UNLOCK(s);
d241 1
a241 1
	int i, s;
d243 1
a243 1
	NET_LOCK(s);
d249 1
a249 1
	NET_UNLOCK(s);
d259 1
a259 1
	int i, s;
d261 1
a261 1
	NET_LOCK(s);
d267 1
a267 1
	NET_UNLOCK(s);
@


1.50
log
@Convert a splsoftnet()/splx() dance to NET_ASSERT_LOCKED().

pfctlinput() is only called in the input path with the NET_LOCK() held.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.49 2017/02/27 19:16:56 claudio Exp $	*/
d59 1
a59 1
#if defined (KEY) || defined (IPSEC) || defined (TCP_SIGNATURE)
@


1.49
log
@Retire the AF_MPLS protosw struct. Nothing is using it and the code was super
basic anyway. Simplifies the code a lot also by calling the mpls sysctl no
longer via the protosw but instead directly.
OK mpi@@ on a previous diff. Also tested by renato@@ who actually found a bug
which is now fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.48 2016/12/20 21:15:36 mpi Exp $	*/
d224 3
a226 1
	int i, s;
a227 1
	s = splsoftnet();
a232 1
	splx(s);
@


1.48
log
@Grab the NET_LOCK() in so{s,g}etopt(), pffasttimo() and pfslowtimo().

ok rzalamena@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.47 2016/12/20 18:33:43 bluhm Exp $	*/
d196 5
a203 11
#ifdef MPLS
	/* XXX WARNING: big fat ugly hack */
	/* stupid net.mpls is special as it does not have a protocol */
	if (family == PF_MPLS) {
		NET_LOCK(s);
		error = (dp->dom_protosw[0].pr_sysctl)(name + 1, namelen - 1,
		    oldp, oldlenp, newp, newlen);
		NET_UNLOCK(s);
		return (error);
	}
#endif
@


1.47
log
@A NET_LOCK() was is missing in tcp_sysctl() which shows up as spl
softnet assert failures.  It is better to place the lock into
net_sysctl() where all the protocol sysctls are called via pr_sysctl.
As calling sysctl(2) is in the slow path, doing fine grained locking
has no benefit.  Many sysctl cases copy out a struct.  Having a
lock around that keeps the struct consistent.  Put assertions in
the protocol sysctls that need it.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.46 2016/11/22 10:32:31 mpi Exp $	*/
d102 2
a103 2
	timeout_set(&pffast_timeout, pffasttimo, &pffast_timeout);
	timeout_set(&pfslow_timeout, pfslowtimo, &pfslow_timeout);
d249 1
a249 1
	s = splsoftnet();
d255 1
a255 1
	splx(s);
d267 1
a267 1
	s = splsoftnet();
d273 1
a273 1
	splx(s);
@


1.46
log
@Enforce that pr_ctlinput, pr_slowtimo and pr_fasttimo are called
at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.45 2016/03/03 00:34:10 dlg Exp $	*/
d168 1
a168 1
	int family, protocol;
d202 7
a208 3
	if (family == PF_MPLS)
		return (dp->dom_protosw[0].pr_sysctl(name + 1, namelen - 1,
		    oldp, oldlenp, newp, newlen));
d215 7
a221 3
		if (pr->pr_protocol == protocol && pr->pr_sysctl)
			return ((*pr->pr_sysctl)(name + 2, namelen - 2,
			    oldp, oldlenp, newp, newlen));
@


1.45
log
@replace the XXX next to setting link_maxhdr with an explanation

the XXX has been there since 1.1, even back in netbsd, and im too
lazy to go back further to try and see why it is there. either way
it is meaningless.

suggested by mikeb@@ and mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.44 2016/03/03 00:25:09 dlg Exp $	*/
d222 1
a222 1
	int i;
d224 1
d230 1
d239 1
a239 1
	int i;
d241 1
d247 1
d257 1
a257 1
	int i;
d259 1
d265 1
@


1.44
log
@bump link_maxhdr up from 16 to 64

link_maxhdr is best explained as the space reserved before an ip
packet payload for link headers, the most common of which is ethernet.
16 was a good choice when the only traffic we really did was ip
over ethernet, but now there are commonly used transports that are
bigger, specifically 802.11 traffic and vlan/vlan encapsulations,
that justify bumping it up.

i chose 64 because it would also allow enough space for encapsulations
like etherip or gif.

this reduces the size of the smallest packet that can fit into an
mbuf before more storage needs to be suffixed, but because most
traffic is either full sized (ie, already bigger than a single mbuf)
or tiny packets (think tcp ACKS, keystrokes over ssh, or dns requests)
the impact is negligible.

ok stsp@@ mpi@@ sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.43 2015/09/04 08:43:39 mpi Exp $	*/
d92 7
a98 1
	if (max_linkhdr < 64)		/* XXX */
d100 1
@


1.43
log
@Make every subsystem using a radix tree call rn_init() and pass the
length of the key as argument.

This way every consumer of the radix tree has a chance to explicitly
initialize the shared data structures and no longer rely on another
subsystem to do the initialization.

As a bonus ``dom_maxrtkey'' is no longer used an die.

ART kernels should now be fully usable because pf(4) and IPSEC properly
initialized the radix tree.

ok chris@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.42 2015/08/30 10:39:16 mpi Exp $	*/
d92 2
a93 2
	if (max_linkhdr < 16)		/* XXX */
		max_linkhdr = 16;
@


1.42
log
@Use a global table for domains instead of building a list at run time.

As a side effect there's no need to run if_attachdomain() after the
list of domains has been built.

ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.41 2015/07/17 18:31:08 blambert Exp $	*/
a47 1
extern struct domain routedomain;
d53 1
a55 1
	&routedomain,
d67 1
@


1.41
log
@manage spd entries by using the radix api directly instead of
reaching around through the routing table

original diff by myself, much improved by mikeb@@ and mpi@@

ok and testing mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.40 2015/03/14 03:38:51 jsg Exp $	*/
d48 22
a69 1
struct	domain *domains;
a74 6
#define	ADDDOMAIN(x)	{ \
	extern struct domain __CONCAT(x,domain); \
	__CONCAT(x,domain.dom_next) = domains; \
	domains = &__CONCAT(x,domain); \
}

d82 1
d84 1
a84 19
#undef unix
	/*
	 * KAME NOTE: ADDDOMAIN(route) is moved to the last part so that
	 * it will be initialized as the *first* element.  confusing!
	 */
	ADDDOMAIN(unix);
	ADDDOMAIN(inet);
#ifdef INET6
	ADDDOMAIN(inet6);
#endif /* INET6 */
#if defined (KEY) || defined (IPSEC) || defined (TCP_SIGNATURE)
	ADDDOMAIN(pfkey);
#endif
#ifdef MPLS
	ADDDOMAIN(mpls);
#endif
	ADDDOMAIN(route);

	for (dp = domains; dp; dp = dp->dom_next) {
d105 1
d107 1
a107 1
	for (dp = domains; dp != NULL; dp = dp->dom_next)
d110 1
d215 1
d217 1
a217 1
	for (dp = domains; dp; dp = dp->dom_next)
d221 1
d230 1
d232 1
a232 1
	for (dp = domains; dp; dp = dp->dom_next)
d236 1
d246 1
d248 1
a248 1
	for (dp = domains; dp; dp = dp->dom_next)
d252 1
@


1.40
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.39 2014/12/23 03:26:24 tedu Exp $	*/
a53 4
#if defined (KEY) || defined (IPSEC) || defined (TCP_SIGNATURE)
int pfkey_init(void);
#endif /* KEY || IPSEC || TCP_SIGNATURE */

d79 2
a80 2
	pfkey_init();
#endif /* KEY || IPSEC */
d82 1
a82 6
       ADDDOMAIN(mpls);
#endif
#ifdef IPSEC
#ifdef __KAME__
	ADDDOMAIN(key);
#endif
@


1.39
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.38 2014/09/14 14:17:26 jsg Exp $	*/
a40 1
#include <sys/kernel.h>
@


1.38
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.37 2014/07/11 21:54:38 tedu Exp $	*/
a78 1
#ifdef INET
a79 1
#endif
@


1.37
log
@"It's not the years, honey; it's the mileage."

bluetooth support doesn't work and isn't going anywhere. the current
design is a dead end, and should not be the basis for any future support.
general consensus says to whack it so as to not mislead the unwary.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.36 2014/07/08 17:19:25 deraadt Exp $	*/
a42 1
#include <sys/proc.h>
@


1.36
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.35 2014/03/11 19:45:28 guenther Exp $	*/
a46 1
#include "bluetooth.h"
a95 3
#endif
#if NBLUETOOTH > 0
	ADDDOMAIN(bt);
@


1.35
log
@lint is gone, and the 'lint' conditional was never in the implementation
namespace, so stop changing behavior when it's #defined

ok beck@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.34 2014/01/19 03:04:54 claudio Exp $	*/
a43 1
#include <uvm/uvm_extern.h>
@


1.34
log
@Remove max_datalen. It is only used once an can be replaced easily with
MHLEN - max_hdr in that place. OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.33 2013/08/20 09:14:21 mpi Exp $	*/
a80 1
#ifndef lint
a102 1
#endif
@


1.33
log
@tedu netnatm and ueagle(4).

ok mikeb@@, sthen@@, tedu@@ (implied), doc bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.32 2011/07/09 00:47:18 henning Exp $	*/
a116 1
	max_datalen = MHLEN - max_hdr;
@


1.32
log
@begone, fucking rotten appletalk shit. ok room
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.31 2011/07/08 18:30:16 yasuoka Exp $	*/
a93 3
#endif
#ifdef NATM
	ADDDOMAIN(natm);
@


1.31
log
@Include PIPEX in kernel by default.  And add new sysctl variable
`net.pipex.enable' to enable PIPEX.   By default, pipex is disabled
and it will not process packets from wire.  Update man pages and
update HOWTO_PIPEX_NPPPD.txt for testers.

discussed with dlg@@, ok deraadt@@ mcbride@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.30 2010/07/02 15:02:38 blambert Exp $	*/
a91 3
#ifdef NETATALK
	ADDDOMAIN(atalk);
#endif
@


1.30
log
@timeout_add -> timeout_add_msec

ok claudio@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.29 2009/11/13 20:54:05 claudio Exp $	*/
d209 5
@


1.29
log
@Extend the protosw pr_ctlinput function to include the rdomain. This is
needed so that the route and inp lookups done in TCP and UDP know where
to look. Additionally in_pcbnotifyall() and tcp_respond() got a rdomain
argument as well for similar reasons. With this tcp seems to be now
fully rdomain save and no longer leaks single packets into the main domain.
Looks good markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.28 2008/09/16 15:48:12 gollo Exp $	*/
d255 1
a255 1
	timeout_add(to, hz/2);
d269 1
a269 1
	timeout_add(to, hz/5);
@


1.28
log
@netstat statistics for pflow(4) via pseudo family

ok cluadio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.27 2008/04/23 10:55:14 norby Exp $	*/
d241 1
a241 1
				(*pr->pr_ctlinput)(cmd, sa, NULL);
@


1.27
log
@Import MPLS (Multi Protocol Label Switching)

MPLS support partly based on the (abandoned?) AYAME project.
Basic LSR (Label Switch Router) functionality is present, but not fully
functional yet.

It is currently possible to insert entries in the LIB (Label Information Base)
with route(8), but setting the operation type is not supported yet.

Imported to allow more people to work on this in the coming weeks.

ok claudio@@ laurent@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.26 2007/06/06 10:04:36 henning Exp $	*/
d50 1
d204 5
@


1.26
log
@remove remaining IPX hooks. all inside #ifdef IPX, so no actual change
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.25 2007/01/18 20:00:18 henning Exp $	*/
d94 3
d208 7
@


1.25
log
@allow kernels with TCP_SIGNATURE (aka tcp md5sig), but without IPSEC to
compile and work. need to register pfkey whenever tcp md5 or ipsec is
defined, and the various ipsec encapsulations only if ipsec is defined.
ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.24 2006/06/15 10:46:58 henning Exp $	*/
a90 3
#ifdef IPX
	ADDDOMAIN(ipx);
#endif
@


1.24
log
@nuke code that has been dead for so long that it stinks. claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.23 2005/06/08 06:18:54 henning Exp $	*/
d57 1
a57 1
#if defined (KEY) || defined (IPSEC)
d59 1
a59 1
#endif /* KEY || IPSEC */
d88 1
a88 1
#if defined (KEY) || defined (IPSEC)
@


1.23
log
@bye bye netns
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.22 2005/06/07 02:30:47 henning Exp $	*/
a98 6
#endif
#ifdef notdef /* XXXX */
#include "imp.h"
#if NIMP > 0
	ADDDOMAIN(imp);
#endif
@


1.22
log
@remove CCITT handling
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.21 2005/01/14 12:04:02 grange Exp $	*/
a95 3
#endif
#ifdef NS
	ADDDOMAIN(ns);
@


1.21
log
@First step in Bluetooth protocol stack support.

The code is adopted from the FreeBSD netgraph-based Bluetooth
implementation by Maksim Yevmenkin <m_evmenkin@@yahoo.com> but
all netgraph glue was replaced with usual BSD network stack
hooks. This is a work in progress. Only HCI layer works for now,
L2CAP and RFCOMM are on the way.

Help in testing from many, ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.20 2004/11/27 14:50:55 pat Exp $	*/
a98 3
#endif
#ifdef CCITT
	ADDDOMAIN(ccitt);
@


1.20
log
@introduce pffinddomain(), to find a domain by family.
while here, fix some spacing, ansi, de-register, etc.

mostly from netbsd

tested & ok otto millert
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.19 2004/11/25 21:40:46 markus Exp $	*/
d48 1
d116 3
@


1.19
log
@remove special handling of PF_KEY in net_sysctl; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.18 2004/09/15 17:46:44 grange Exp $	*/
d52 4
a55 2
void	pffasttimo(void *);
void	pfslowtimo(void *);
d67 1
a67 1
domaininit()
d127 2
a128 2
if (max_linkhdr < 16)		/* XXX */
max_linkhdr = 16;
d137 2
a138 3
struct protosw *
pffindtype(family, type)
	int family, type;
d140 1
a140 2
	register struct domain *dp;
	register struct protosw *pr;
d142 1
a142 1
	for (dp = domains; dp; dp = dp->dom_next)
d144 1
a144 1
			goto found;
d146 12
a157 1
found:
d165 1
a165 2
pffindproto(family, protocol, type)
	int family, protocol, type;
d167 2
a168 2
	register struct domain *dp;
	register struct protosw *pr;
d173 5
a177 5
	for (dp = domains; dp; dp = dp->dom_next)
		if (dp->dom_family == family)
			goto found;
	return (NULL);
found:
d183 1
a183 1
		    pr->pr_protocol == 0 && maybe == (struct protosw *)0)
d190 2
a191 8
net_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d193 2
a194 2
	register struct domain *dp;
	register struct protosw *pr;
a207 3
	for (dp = domains; dp; dp = dp->dom_next)
		if (dp->dom_family == family)
			goto found;
d213 4
a216 2
	return (ENOPROTOOPT);
found:
d228 1
a228 3
pfctlinput(cmd, sa)
	int cmd;
	struct sockaddr *sa;
d230 2
a231 2
	register struct domain *dp;
	register struct protosw *pr;
d240 1
a240 2
pfslowtimo(arg)
	void *arg;
d254 1
a254 2
pffasttimo(arg)
	void *arg;
@


1.18
log
@Kill more netiso ghosts.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.17 2004/04/01 23:56:05 tedu Exp $	*/
d195 1
a195 3
	 * PF_KEY: next component is protocol family, and then at least one
	 *	additional component.
	 * usually: next two components are protocol family and protocol
a213 14
	switch (family) {
#ifdef IPSEC
#ifdef __KAME__
	case PF_KEY:
		pr = dp->dom_protosw;
		if (pr->pr_sysctl)
			return ((*pr->pr_sysctl)(name + 1, namelen - 1,
				oldp, oldlenp, newp, newlen));
		return (ENOPROTOOPT);
#endif
#endif
	default:
		break;
	}
@


1.17
log
@use NULL for ptrs.  parts from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.16 2004/02/24 21:43:55 tedu Exp $	*/
a95 3
#endif
#ifdef ISO
	ADDDOMAIN(iso);
@


1.16
log
@sysctl knob for bpf tunables.  some tips from canacar@@
ok canacar@@ deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.15 2003/06/02 23:28:06 millert Exp $	*/
d148 1
a148 1
	return (0);
d153 1
a153 1
	return (0);
d162 1
a162 1
	struct protosw *maybe = 0;
d165 1
a165 1
		return (0);
d169 1
a169 1
	return (0);
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.14 2003/05/12 00:48:52 jason Exp $	*/
d48 2
d212 5
@


1.14
log
@Nuke a whole bunch of commons; ok tedu (still more to come *sigh*)
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.13 2002/03/14 01:27:05 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.12 2001/11/06 19:53:20 miod Exp $	*/
d51 2
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.11 2000/09/12 16:39:14 deraadt Exp $	*/
d52 2
a53 2
void	pffasttimo __P((void *));
void	pfslowtimo __P((void *));
d55 1
a55 1
int pfkey_init __P((void));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.12 2001/11/06 19:53:20 miod Exp $	*/
d52 2
a53 2
void	pffasttimo(void *);
void	pfslowtimo(void *);
d55 1
a55 1
int pfkey_init(void);
@


1.12.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a50 2

struct	domain *domains;
@


1.11
log
@NATM domain; stoklund@@taxidriver.dk
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.10 2000/03/23 10:42:29 art Exp $	*/
d48 1
a48 1
#include <vm/vm.h>
@


1.10
log
@Use new timeouts for pfslowtimo and pffasttimo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.9 1999/12/08 06:50:17 itojun Exp $	*/
d102 3
@


1.9
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.8 1999/03/30 00:19:05 niklas Exp $	*/
d50 1
d67 4
a70 2
	register struct domain *dp;
	register struct protosw *pr;
d129 4
a132 2
	timeout(pffasttimo, NULL, 1);
	timeout(pfslowtimo, NULL, 1);
d253 3
a255 2
	register struct domain *dp;
	register struct protosw *pr;
d261 1
a261 1
	timeout(pfslowtimo, NULL, hz/2);
d268 3
a270 2
	register struct domain *dp;
	register struct protosw *pr;
d276 1
a276 1
	timeout(pffasttimo, NULL, hz/5);
@


1.9.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a49 1
#include <sys/timeout.h>
d66 2
a67 4
	struct domain *dp;
	struct protosw *pr;
	static struct timeout pffast_timeout;
	static struct timeout pfslow_timeout;
d126 2
a127 4
	timeout_set(&pffast_timeout, pffasttimo, &pffast_timeout);
	timeout_set(&pfslow_timeout, pfslowtimo, &pfslow_timeout);
	timeout_add(&pffast_timeout, 1);
	timeout_add(&pfslow_timeout, 1);
d248 2
a249 3
	struct timeout *to = (struct timeout *)arg;
	struct domain *dp;
	struct protosw *pr;
d255 1
a255 1
	timeout_add(to, hz/2);
d262 2
a263 3
	struct timeout *to = (struct timeout *)arg;
	struct domain *dp;
	struct protosw *pr;
d269 1
a269 1
	timeout_add(to, hz/5);
@


1.9.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.11 2000/09/12 16:39:14 deraadt Exp $	*/
a101 3
#endif
#ifdef NATM
	ADDDOMAIN(natm);
@


1.9.2.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
#include <uvm/uvm_extern.h>
@


1.9.2.4
log
@Merge in -current from about a week ago
@
text
@d52 2
a53 2
void	pffasttimo(void *);
void	pfslowtimo(void *);
d55 1
a55 1
int pfkey_init(void);
@


1.9.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.9.2.4 2002/03/28 11:43:04 niklas Exp $	*/
a50 2

struct	domain *domains;
@


1.9.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.9.2.5 2003/05/13 19:21:28 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.2.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a47 2
#include "bpfilter.h"

d146 1
a146 1
	return (NULL);
d151 1
a151 1
	return (NULL);
d160 1
a160 1
	struct protosw *maybe = NULL;
d163 1
a163 1
		return (NULL);
d167 1
a167 1
	return (NULL);
a209 5
#if NBPFILTER > 0
	if (family == PF_BPF)
		return (bpf_sysctl(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
@


1.8
log
@make option IPSEC imply option KEY
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.7 1999/02/24 22:19:20 angelos Exp $	*/
d70 4
a75 1
	ADDDOMAIN(route);
d106 6
d189 5
a193 3
	 * All sysctl names at this level are nonterminal;
	 * next two components are protocol family and protocol number,
	 * then at least one addition component.
d195 1
a195 1
	if (namelen < 3)
a197 1
	protocol = name[1];
d206 17
@


1.7
log
@Disable encap domain.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.6 1999/01/07 22:30:34 deraadt Exp $	*/
d53 1
a53 1
#ifdef KEY
d55 1
a55 1
#endif /* KEY */
d79 1
a79 1
#ifdef KEY
d81 1
a81 1
#endif /* KEY */
@


1.6
log
@ready for INET6 and KEY
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.5 1997/07/23 04:33:53 denny Exp $	*/
a74 3
#ifdef IPSEC
	ADDDOMAIN(encap);
#endif
@


1.5
log
@Add AppleTalk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.4 1997/02/20 01:07:26 deraadt Exp $	*/
d53 3
d79 6
@


1.4
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_domain.c,v 1.2 1996/03/03 17:20:16 niklas Exp $	*/
d78 3
@


1.3
log
@Add IPX support (#ifdef'ed, so no problems would arise).
@
text
@d72 3
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 3
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: uipc_domain.c,v 1.12 1994/06/29 06:33:33 cgd Exp $	*/
d199 1
a199 1
				(*pr->pr_ctlinput)(cmd, sa, (caddr_t)0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
