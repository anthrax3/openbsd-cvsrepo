head	1.50;
access;
symbols
	OPENBSD_6_0:1.48.0.2
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.10
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.16.0.6
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.4
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.8
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.8
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.7.0.6
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.12
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.10
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.8
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.6
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.4
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2017.03.27.11.45.49;	author bluhm;	state Exp;
branches;
next	1.49;
commitid	P5fIAO7fo6lur3NB;

1.49
date	2017.03.24.16.42.38;	author bluhm;	state Exp;
branches;
next	1.48;
commitid	0tQHdZKg98RHeQQ1;

1.48
date	2016.06.23.15.41.42;	author bluhm;	state Exp;
branches;
next	1.47;
commitid	eotBcDsvio0StEfr;

1.47
date	2016.06.23.13.15.21;	author bluhm;	state Exp;
branches;
next	1.46;
commitid	L950Tprx6pIQhkRL;

1.46
date	2016.06.08.11.11.47;	author bluhm;	state Exp;
branches;
next	1.45;
commitid	ry9xU6Gs71N0ZOcX;

1.45
date	2016.05.31.22.12.26;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	0EyYiD0wCrSLXuqy;

1.44
date	2016.05.19.09.40.30;	author bluhm;	state Exp;
branches;
next	1.43;
commitid	n6Xn7ts6a43kNPD8;

1.43
date	2016.05.18.23.42.12;	author bluhm;	state Exp;
branches;
next	1.42;
commitid	SclkAbWeMbdNu7vS;

1.42
date	2016.05.18.23.28.43;	author bluhm;	state Exp;
branches;
next	1.41;
commitid	T9llX25VCbdtzf0i;

1.41
date	2016.05.17.23.43.47;	author bluhm;	state Exp;
branches;
next	1.40;
commitid	FQUHD8bvWBEOY9mu;

1.40
date	2016.05.17.23.28.03;	author bluhm;	state Exp;
branches;
next	1.39;
commitid	mdEa4Ht7h1M2c9Us;

1.39
date	2016.05.10.23.54.00;	author bluhm;	state Exp;
branches;
next	1.38;
commitid	ySY3TBIHoKy6xoBh;

1.38
date	2016.03.21.22.41.29;	author bluhm;	state Exp;
branches;
next	1.37;
commitid	hneUpr7ZOJCeNeHP;

1.37
date	2016.01.13.17.05.25;	author stefan;	state Exp;
branches;
next	1.36;
commitid	E7SDECFW8GCVa9n4;

1.36
date	2016.01.07.12.27.07;	author bluhm;	state Exp;
branches;
next	1.35;
commitid	uTqN3iZ8MQzDLyHU;

1.35
date	2016.01.01.19.15.00;	author bluhm;	state Exp;
branches;
next	1.34;
commitid	W9x3Bj241DbIKRl7;

1.34
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.33;
commitid	Cl55DD2g2xm69E6W;

1.33
date	2015.11.24.23.59.22;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	yUsxyREKtyEcbCjj;

1.32
date	2015.09.11.12.33.36;	author bluhm;	state Exp;
branches;
next	1.31;
commitid	nSYncLrrQs765xgZ;

1.31
date	2015.09.02.13.21.37;	author bluhm;	state Exp;
branches;
next	1.30;
commitid	mAdEN6BtYRbaABPy;

1.30
date	2015.05.06.08.52.17;	author mpi;	state Exp;
branches;
next	1.29;
commitid	8Nt1erARPXBfs0Oe;

1.29
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.28;
commitid	p4LJxGKbi0BU2cG6;

1.28
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.27;
commitid	C5iGb36LQxjM60Q3;

1.27
date	2015.01.13.18.51.27;	author kettenis;	state Exp;
branches;
next	1.26;
commitid	ZIGGFwm21iN1eeWB;

1.26
date	2015.01.13.10.07.58;	author mpf;	state Exp;
branches;
next	1.25;
commitid	IZ2rtJyRuzWF0F1j;

1.25
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.24;
commitid	20ZyHa9gTJxHxhwD;

1.24
date	2014.12.10.02.44.47;	author tedu;	state Exp;
branches;
next	1.23;
commitid	tsoJBlEBSyYO22RG;

1.23
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	3SGDR5EjcwE01W8S;

1.22
date	2014.07.28.20.30.01;	author bluhm;	state Exp;
branches;
next	1.21;
commitid	OCk8dTUlVycm4ejk;

1.21
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.20;
commitid	QlVV51SZgNFxsXxC;

1.20
date	2014.07.10.08.55.35;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	pbN6jG3m5FuHrSxQ;

1.19
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2014.01.21.01.48.44;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.02.22.20.08;	author nicm;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.03.17.51.03;	author thib;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.09.09.09.52;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.20.00.08.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.14.21.58.50;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.29.02.58.14;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.06.04.42.07;	author csapuntz;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2000.02.22.19.28.03;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.09.18.13.23.26;	author deraadt;	state Exp;
branches
	1.5.12.1;
next	1.4;

1.4
date	97.08.31.20.42.20;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.27.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.20.00;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches;
next	;

1.5.12.1
date	2000.03.02.07.04.40;	author niklas;	state Exp;
branches;
next	1.5.12.2;

1.5.12.2
date	2001.05.14.22.32.43;	author niklas;	state Exp;
branches;
next	1.5.12.3;

1.5.12.3
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.5.12.4;

1.5.12.4
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.5.12.5;

1.5.12.5
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	;

1.7.6.1
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Reorder FREF() and FRELE() in a way that the the global variable
syslogf always points to a file object with increased reference
count.  This makes the implementation independent from the fact
whether changing the reference counter may sleep.
pointed out by Mateusz Guzik; OK deraadt@@
@
text
@/*	$OpenBSD: subr_log.c,v 1.49 2017/03/24 16:42:38 bluhm Exp $	*/
/*	$NetBSD: subr_log.c,v 1.11 1996/03/30 22:24:44 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)subr_log.c	8.1 (Berkeley) 6/10/93
 */

/*
 * Error log buffer for kernel printf's.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/ioctl.h>
#include <sys/msgbuf.h>
#include <sys/file.h>
#include <sys/tty.h>
#include <sys/signalvar.h>
#include <sys/syslog.h>
#include <sys/poll.h>
#include <sys/malloc.h>
#include <sys/filedesc.h>
#include <sys/socket.h>
#include <sys/socketvar.h>

#ifdef KTRACE
#include <sys/ktrace.h>
#endif

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <dev/cons.h>

#define LOG_RDPRI	(PZERO + 1)

#define LOG_ASYNC	0x04
#define LOG_RDWAIT	0x08

struct logsoftc {
	int	sc_state;		/* see above for possibilities */
	struct	selinfo sc_selp;	/* process waiting on select call */
	int	sc_pgid;		/* process/group for async I/O */
	uid_t	sc_siguid;		/* uid for process that set sc_pgid */
	uid_t	sc_sigeuid;		/* euid for process that set sc_pgid */
} logsoftc;

int	log_open;			/* also used in log() */
int	msgbufmapped;			/* is the message buffer mapped */
struct	msgbuf *msgbufp;		/* the mapped buffer, itself. */
struct	msgbuf *consbufp;		/* console message buffer. */
struct	file *syslogf;

void filt_logrdetach(struct knote *kn);
int filt_logread(struct knote *kn, long hint);

struct filterops logread_filtops =
	{ 1, NULL, filt_logrdetach, filt_logread};

int dosendsyslog(struct proc *, const char *, size_t, int, enum uio_seg);

void
initmsgbuf(caddr_t buf, size_t bufsize)
{
	struct msgbuf *mbp;
	long new_bufs;

	/* Sanity-check the given size. */
	if (bufsize < sizeof(struct msgbuf))
		return;

	mbp = msgbufp = (struct msgbuf *)buf;

	new_bufs = bufsize - offsetof(struct msgbuf, msg_bufc);
	if ((mbp->msg_magic != MSG_MAGIC) || (mbp->msg_bufs != new_bufs) ||
	    (mbp->msg_bufr < 0) || (mbp->msg_bufr >= mbp->msg_bufs) ||
	    (mbp->msg_bufx < 0) || (mbp->msg_bufx >= mbp->msg_bufs)) {
		/*
		 * If the buffer magic number is wrong, has changed
		 * size (which shouldn't happen often), or is
		 * internally inconsistent, initialize it.
		 */

		memset(buf, 0, bufsize);
		mbp->msg_magic = MSG_MAGIC;
		mbp->msg_bufs = new_bufs;
	}

	/* Always start new buffer data on a new line. */
	if (mbp->msg_bufx > 0 && mbp->msg_bufc[mbp->msg_bufx - 1] != '\n')
		msgbuf_putchar(msgbufp, '\n');

	/* mark it as ready for use. */
	msgbufmapped = 1;
}

void
initconsbuf(void)
{
	long new_bufs;

	/* Set up a buffer to collect /dev/console output */
	consbufp = malloc(CONSBUFSIZE, M_TEMP, M_NOWAIT|M_ZERO);
	if (consbufp) {
		new_bufs = CONSBUFSIZE - offsetof(struct msgbuf, msg_bufc);
		consbufp->msg_magic = MSG_MAGIC;
		consbufp->msg_bufs = new_bufs;
	}
}

void
msgbuf_putchar(struct msgbuf *mbp, const char c)
{
	int s;

	if (mbp->msg_magic != MSG_MAGIC)
		/* Nothing we can do */
		return;

	s = splhigh();
	mbp->msg_bufc[mbp->msg_bufx++] = c;
	mbp->msg_bufl = lmin(mbp->msg_bufl+1, mbp->msg_bufs);
	if (mbp->msg_bufx < 0 || mbp->msg_bufx >= mbp->msg_bufs)
		mbp->msg_bufx = 0;
	/* If the buffer is full, keep the most recent data. */
	if (mbp->msg_bufr == mbp->msg_bufx) {
		if (++mbp->msg_bufr >= mbp->msg_bufs)
			mbp->msg_bufr = 0;
		mbp->msg_bufd++;
	}
	splx(s);
}

int
logopen(dev_t dev, int flags, int mode, struct proc *p)
{
	if (log_open)
		return (EBUSY);
	log_open = 1;
	return (0);
}

int
logclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct file *fp;

	fp = syslogf;
	syslogf = NULL;
	if (fp)
		FRELE(fp, p);
	log_open = 0;
	logsoftc.sc_state = 0;
	return (0);
}

int
logread(dev_t dev, struct uio *uio, int flag)
{
	struct msgbuf *mbp = msgbufp;
	size_t l;
	int s, error = 0;

	s = splhigh();
	while (mbp->msg_bufr == mbp->msg_bufx) {
		if (flag & IO_NDELAY) {
			error = EWOULDBLOCK;
			goto out;
		}
		logsoftc.sc_state |= LOG_RDWAIT;
		error = tsleep(mbp, LOG_RDPRI | PCATCH,
			       "klog", 0);
		if (error)
			goto out;
	}
	logsoftc.sc_state &= ~LOG_RDWAIT;

	if (mbp->msg_bufd > 0) {
		char buf[64];

		l = snprintf(buf, sizeof(buf),
		    "<%d>klog: dropped %ld byte%s, message buffer full\n",
		    LOG_KERN|LOG_WARNING, mbp->msg_bufd,
                    mbp->msg_bufd == 1 ? "" : "s");
		error = uiomove(buf, ulmin(l, sizeof(buf) - 1), uio);
		if (error)
			goto out;
		mbp->msg_bufd = 0;
	}

	while (uio->uio_resid > 0) {
		if (mbp->msg_bufx >= mbp->msg_bufr)
			l = mbp->msg_bufx - mbp->msg_bufr;
		else
			l = mbp->msg_bufs - mbp->msg_bufr;
		l = ulmin(l, uio->uio_resid);
		if (l == 0)
			break;
		error = uiomove(&mbp->msg_bufc[mbp->msg_bufr], l, uio);
		if (error)
			break;
		mbp->msg_bufr += l;
		if (mbp->msg_bufr < 0 || mbp->msg_bufr >= mbp->msg_bufs)
			mbp->msg_bufr = 0;
	}
 out:
	splx(s);
	return (error);
}

int
logpoll(dev_t dev, int events, struct proc *p)
{
	int s, revents = 0;

	s = splhigh();
	if (events & (POLLIN | POLLRDNORM)) {
		if (msgbufp->msg_bufr != msgbufp->msg_bufx)
			revents |= events & (POLLIN | POLLRDNORM);
		else
			selrecord(p, &logsoftc.sc_selp);
	}
	splx(s);
	return (revents);
}

int
logkqfilter(dev_t dev, struct knote *kn)
{
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &logsoftc.sc_selp.si_note;
		kn->kn_fop = &logread_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (void *)msgbufp;

	s = splhigh();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

void
filt_logrdetach(struct knote *kn)
{
	int s;

	s = splhigh();
	SLIST_REMOVE(&logsoftc.sc_selp.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_logread(struct knote *kn, long hint)
{
	struct  msgbuf *p = (struct  msgbuf *)kn->kn_hook;
	int s, event = 0;

	s = splhigh();
	kn->kn_data = (int)(p->msg_bufx - p->msg_bufr);
	event = (p->msg_bufx != p->msg_bufr);
	splx(s);
	return (event);
}

void
logwakeup(void)
{
	if (!log_open)
		return;
	selwakeup(&logsoftc.sc_selp);
	if (logsoftc.sc_state & LOG_ASYNC)
		csignal(logsoftc.sc_pgid, SIGIO,
		    logsoftc.sc_siguid, logsoftc.sc_sigeuid);
	if (logsoftc.sc_state & LOG_RDWAIT) {
		wakeup(msgbufp);
		logsoftc.sc_state &= ~LOG_RDWAIT;
	}
}

int
logioctl(dev_t dev, u_long com, caddr_t data, int flag, struct proc *p)
{
	struct file *fp;
	long l;
	int error, s;

	switch (com) {

	/* return number of characters immediately available */
	case FIONREAD:
		s = splhigh();
		l = msgbufp->msg_bufx - msgbufp->msg_bufr;
		splx(s);
		if (l < 0)
			l += msgbufp->msg_bufs;
		*(int *)data = l;
		break;

	case FIONBIO:
		break;

	case FIOASYNC:
		if (*(int *)data)
			logsoftc.sc_state |= LOG_ASYNC;
		else
			logsoftc.sc_state &= ~LOG_ASYNC;
		break;

	case TIOCSPGRP:
		logsoftc.sc_pgid = *(int *)data;
		logsoftc.sc_siguid = p->p_ucred->cr_ruid;
		logsoftc.sc_sigeuid = p->p_ucred->cr_uid;
		break;

	case TIOCGPGRP:
		*(int *)data = logsoftc.sc_pgid;
		break;

	case LIOCSFD:
		if ((error = suser(p, 0)) != 0)
			return (error);
		fp = syslogf;
		if ((error = getsock(p, *(int *)data, &syslogf)) != 0)
			return (error);
		if (fp)
			FRELE(fp, p);
		break;

	default:
		return (ENOTTY);
	}
	return (0);
}

int
sys_sendsyslog(struct proc *p, void *v, register_t *retval)
{
	struct sys_sendsyslog_args /* {
		syscallarg(const void *) buf;
		syscallarg(size_t) nbyte;
		syscallarg(int) flags;
	} */ *uap = v;
	int error;
	static int dropped_count, orig_error;

	if (dropped_count) {
		size_t l;
		char buf[64];

		l = snprintf(buf, sizeof(buf),
		    "<%d>sendsyslog: dropped %d message%s, error %d",
		    LOG_KERN|LOG_WARNING, dropped_count,
		    dropped_count == 1 ? "" : "s", orig_error);
		error = dosendsyslog(p, buf, ulmin(l, sizeof(buf) - 1),
		    0, UIO_SYSSPACE);
		if (error == 0)
			dropped_count = 0;
	}
	error = dosendsyslog(p, SCARG(uap, buf), SCARG(uap, nbyte),
	    SCARG(uap, flags), UIO_USERSPACE);
	if (error) {
		dropped_count++;
		orig_error = error;
	}
	return (error);
}

int
dosendsyslog(struct proc *p, const char *buf, size_t nbyte, int flags,
    enum uio_seg sflg)
{
#ifdef KTRACE
	struct iovec *ktriov = NULL;
	int iovlen;
#endif
	struct file *fp;
	char pri[6], *kbuf;
	struct iovec aiov;
	struct uio auio;
	size_t i, len;
	int error;

	/* Global variable syslogf may change during sleep, use local copy. */
	fp = syslogf;
	if (fp)
		FREF(fp);
	else if (!ISSET(flags, LOG_CONS))
		return (ENOTCONN);
	else {
		/*
		 * Strip off syslog priority when logging to console.
		 * LOG_PRIMASK | LOG_FACMASK is 0x03ff, so at most 4
		 * decimal digits may appear in priority as <1023>.
		 */
		len = MIN(nbyte, sizeof(pri));
		if (sflg == UIO_USERSPACE) {
			if ((error = copyin(buf, pri, len)))
				return (error);
		} else
			memcpy(pri, buf, len);
		if (0 < len && pri[0] == '<') {
			for (i = 1; i < len; i++) {
				if (pri[i] < '0' || pri[i] > '9')
					break;
			}
			if (i < len && pri[i] == '>') {
				i++;
				/* There must be at least one digit <0>. */
				if (i >= 3) {
					buf += i;
					nbyte -= i;
				}
			}
		}
	}

	aiov.iov_base = (char *)buf;
	aiov.iov_len = nbyte;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_segflg = sflg;
	auio.uio_rw = UIO_WRITE;
	auio.uio_procp = p;
	auio.uio_offset = 0;
	auio.uio_resid = aiov.iov_len;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO)) {
		ktriov = mallocarray(auio.uio_iovcnt, sizeof(struct iovec),
		    M_TEMP, M_WAITOK);
		iovlen = auio.uio_iovcnt * sizeof (struct iovec);

		memcpy(ktriov, auio.uio_iov, iovlen);
	}
#endif

	len = auio.uio_resid;
	if (fp) {
		error = sosend(fp->f_data, NULL, &auio, NULL, NULL, 0);
		if (error == 0)
			len -= auio.uio_resid;
	} else if (constty || cn_devvp) {
		error = cnwrite(0, &auio, 0);
		if (error == 0)
			len -= auio.uio_resid;
		aiov.iov_base = "\r\n";
		aiov.iov_len = 2;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_segflg = UIO_SYSSPACE;
		auio.uio_rw = UIO_WRITE;
		auio.uio_procp = p;
		auio.uio_offset = 0;
		auio.uio_resid = aiov.iov_len;
		cnwrite(0, &auio, 0);
	} else {
		/* XXX console redirection breaks down... */
		if (sflg == UIO_USERSPACE) {
			kbuf = malloc(len, M_TEMP, M_WAITOK);
			error = copyin(aiov.iov_base, kbuf, len);
		} else {
			kbuf = aiov.iov_base;
			error = 0;
		}
		if (error == 0)
			for (i = 0; i < len; i++) {
				if (kbuf[i] == '\0')
					break;
				cnputc(kbuf[i]);
				auio.uio_resid--;
			}
		if (sflg == UIO_USERSPACE)
			free(kbuf, M_TEMP, len);
		if (error == 0)
			len -= auio.uio_resid;
		cnputc('\n');
	}

#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p, -1, UIO_WRITE, ktriov, len);
		free(ktriov, M_TEMP, iovlen);
	}
#endif
	if (fp)
		FRELE(fp, p);
	else
		error = ENOTCONN;
	return (error);
}
@


1.49
log
@There was a race in dosendsyslog() which resulted in a crash.
sosend(syslogf->f_data, ...) could be called with a NULL pointer.
syslogf was not NULL, f_data was NULL and f_count was 1.  The file
structure is ref counted, but the global variable syslogf is not
protected.  So it may change during sleep and dosendsyslog() possibly
used a different socket at each access.  Solution is to access
syslogf only once, use a local copy, and do the ref counting there.
OK millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.48 2016/06/23 15:41:42 bluhm Exp $	*/
d175 1
d177 1
a177 2
	if (syslogf)
		FRELE(syslogf, p);
d179 2
d360 2
a361 1
		if ((error = getsock(p, *(int *)data, &fp)) != 0)
d363 2
a364 3
		if (syslogf)
			FRELE(syslogf, p);
		syslogf = fp;
@


1.48
log
@As klog dropped message has no ifdef small kernel, sendsyslog
should not have it either.  While there bring some variables in
sync between both functions.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.47 2016/06/23 13:15:21 bluhm Exp $	*/
d412 1
d419 4
a422 2
	if (syslogf)
		FREF(syslogf);
d473 2
a474 2
	if (syslogf) {
		error = sosend(syslogf->f_data, NULL, &auio, NULL, NULL, 0);
d521 2
a522 2
	if (syslogf)
		FRELE(syslogf, p);
@


1.47
log
@It is annoying that the dmesg buffer can overflow and loose messages
undetected during debugging.  To make clear what happens, count the
dropped bytes and write message buffer full to syslogd.  This also
helps to have a reliable log system.
OK deraadt@@ millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.46 2016/06/08 11:11:47 bluhm Exp $	*/
a379 1
#ifndef SMALL_KERNEL
a380 2
	int len;
	char buf[64];
d383 4
a386 1
		len = snprintf(buf, sizeof(buf),
d390 1
a390 1
		error = dosendsyslog(p, buf, MIN((size_t)len, sizeof(buf) - 1),
a394 1
#endif
a396 1
#ifndef SMALL_KERNEL
a400 1
#endif
@


1.46
log
@As logging to dmesg with msgbuf_putchar() can happen in any interrupt
handler, every access to msg buf counters should be protected by
splhigh().  This is already done in some places, make it consistenly
everywhere.
OK mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.45 2016/05/31 22:12:26 deraadt Exp $	*/
d158 1
d204 13
@


1.45
log
@sys_osendsyslog can go away; we have transitioned to the new version with
a flags argument
ok guenther sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.44 2016/05/19 09:40:30 bluhm Exp $	*/
d143 2
d149 1
d159 1
d188 1
a188 2
	int s;
	int error = 0;
d193 2
a194 2
			splx(s);
			return (EWOULDBLOCK);
d199 2
a200 4
		if (error) {
			splx(s);
			return (error);
		}
a201 1
	splx(s);
d219 2
d227 1
a227 2
	int revents = 0;
	int s = splhigh();
d229 1
d267 1
a267 1
	int s = splhigh();
d269 1
d278 1
d280 1
d282 3
a284 2

	return (p->msg_bufx != p->msg_bufr);
@


1.44
log
@All msg buf counters are long, so lmin(9) should be used for them.
OK deraadt@@ natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.43 2016/05/18 23:42:12 bluhm Exp $	*/
a348 15
}

int
sys_osendsyslog(struct proc *p, void *v, register_t *retval)
{
	struct sys_osendsyslog_args /* {
		syscallarg(const void *) buf;
		syscallarg(size_t) nbyte;
	} */ *uap = v;
	struct sys_sendsyslog_args oap;

	SCARG(&oap, buf) = SCARG(uap, buf);
	SCARG(&oap, nbyte) = SCARG(uap, nbyte);
	SCARG(&oap, flags) = 0;
	return sys_sendsyslog(p, &oap, retval);
@


1.43
log
@Kill trailing whitespaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.42 2016/05/18 23:28:43 bluhm Exp $	*/
d148 1
a148 1
	mbp->msg_bufl = min(mbp->msg_bufl+1, mbp->msg_bufs);
@


1.42
log
@Use constty and cn_devvp for checking wether to use cnwrite().  That
makes console redirection with senssyslog(2) and LOG_CONS work
again.  Also merge the two if else if else blocks into one.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.41 2016/05/17 23:43:47 bluhm Exp $	*/
d85 1
a85 1
   
d117 1
a117 1
	
d141 1
a141 1
msgbuf_putchar(struct msgbuf *mbp, const char c) 
@


1.41
log
@Allow sendsyslog(2) with LOG_CONS even when /dev/console has not
been opened during init(8).  Only log with cnwrite() if cn_devvp
exists, otherwise use cnputc() as fallback.  While there move extern
declarations to dev/cons.h.
input and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.40 2016/05/17 23:28:03 bluhm Exp $	*/
d468 1
a468 1
	if (syslogf)
d470 3
a472 1
	else if (cn_devvp)
d474 13
a486 1
	else {
d504 3
a507 19

	if (error == 0)
		len -= auio.uio_resid;

	if (syslogf)
		;
	else if (cn_devvp) {
		aiov.iov_base = "\r\n";
		aiov.iov_len = 2;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_segflg = UIO_SYSSPACE;
		auio.uio_rw = UIO_WRITE;
		auio.uio_procp = p;
		auio.uio_offset = 0;
		auio.uio_resid = aiov.iov_len;
		cnwrite(0, &auio, 0);
	} else
		cnputc('\n');
@


1.40
log
@Backout the previous fix for the sendsyslog(2) with LOG_CONS solution.
Permanently holding /dev/console open in the kernel works only until
init(8) calls revoke(2).  After that the console device vnode cannot
be used anymore.  It still resulted in a hanging init(8) if it tried
to syslog(3) something.  With the backout also dmesg -s works again.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.39 2016/05/10 23:54:00 bluhm Exp $	*/
d410 1
a410 1
	char pri[6];
d470 1
a470 1
	else
d472 20
d494 4
a497 1
	if (syslogf == NULL) {
d508 2
a509 1
	}
@


1.39
log
@If sendsyslog(2) is called with LOG_CONS before syslogd(8) has been
started and before init(8) has opened the console, the kernel could
crash as the console device has not been initialized.  Open
/dev/console in the kernel before starting init(8) and keep it open.
This way sendsyslog(2) can be called early in the system.
OK beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.38 2016/03/21 22:41:29 bluhm Exp $	*/
d418 1
a418 1
	else if (!ISSET(flags, LOG_CONS) || consolevp == NULL)
@


1.38
log
@Rename the system call sendsyslog2 to sendsyslog.  Keep the old one
as osendsyslog for a while.  The three argument variant is the only
one that will stay.
input kettenis@@;  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.37 2016/01/13 17:05:25 stefan Exp $	*/
d418 1
a418 1
	else if ((flags & LOG_CONS) == 0)
@


1.37
log
@Convert to uiomove(); from Martin Natano, thanks!

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.36 2016/01/07 12:27:07 bluhm Exp $	*/
d352 1
a352 1
sys_sendsyslog(struct proc *p, void *v, register_t *retval)
d354 1
a354 1
	struct sys_sendsyslog_args /* {
d358 1
a358 1
	struct sys_sendsyslog2_args oap;
d363 1
a363 1
	return sys_sendsyslog2(p, &oap, retval);
d367 1
a367 1
sys_sendsyslog2(struct proc *p, void *v, register_t *retval)
d369 1
a369 1
	struct sys_sendsyslog2_args /* {
@


1.36
log
@In sendsyslogd(2) strip off syslog priority when logging to console.
OK deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.35 2016/01/01 19:15:00 bluhm Exp $	*/
d183 1
a183 1
	long l;
d205 3
a207 2
		l = mbp->msg_bufx - mbp->msg_bufr;
		if (l < 0)
d209 1
a209 1
		l = min(l, uio->uio_resid);
d212 1
a212 1
		error = uiomovei(&mbp->msg_bufc[mbp->msg_bufr], (int)l, uio);
@


1.35
log
@The pointer buf is a user space string which was directly passed
to tputchar() and could crash the kernel.  Better use cnwrite() in
sendsyslog2() for writing to console.  It takes a struct uio which
does the copyin() automatically.  In addition cnwrite() outputs to
the real console or to a redirected one, whichever is appropriate.
One drawback is that the syslog priority cannot be stripped off
easily.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.34 2015/12/05 10:11:53 tedu Exp $	*/
d409 1
d412 1
a412 1
	size_t len;
a414 2
	if (syslogf == NULL && (flags & LOG_CONS) == 0)
		return (ENOTCONN);
d417 29
@


1.34
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.33 2015/11/24 23:59:22 deraadt Exp $	*/
d62 2
d81 1
a81 1
struct file *syslogf;
d385 3
a387 6
		    SCARG(uap, flags), UIO_SYSSPACE);
		if (error) {
			dropped_count++;
			return (error);
		}
		dropped_count = 0;
d393 1
a393 1
	if (error && error != ENOTCONN) {
a408 1
	extern struct tty *constty;
a410 1
	struct file *f;
d414 1
a414 14
	if (syslogf == NULL) {
		if (constty && (flags & LOG_CONS)) {
			int i;

			/* Skip syslog prefix */
			if (nbyte >= 4 && buf[0] == '<' &&
			    buf[3] == '>') {
				buf += 4;
				nbyte -= 4;
			}
			for (i = 0; i < nbyte; i++)
				tputchar(buf[i], constty);
			tputchar('\n', constty);
		}
d416 2
a417 3
	}
	f = syslogf;
	FREF(f);
d439 4
a442 1
	error = sosend(f->f_data, NULL, &auio, NULL, NULL, 0);
d445 12
d465 5
a469 2
	FRELE(f, p);
	return error;
@


1.33
log
@Add sendsyslog2(), which accepts the syslog/openlog "logopt" flag
LOG_CONS. If syslogd is not accepting messages, direct them to the console.
This allows us to remove the direct /dev/console opening code from the
bowels of libc.  Of course, that forgotten code was exposed by pledge.
ok kettenis millert beck
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.32 2015/09/11 12:33:36 bluhm Exp $	*/
a155 1
/*ARGSUSED*/
a164 1
/*ARGSUSED*/
a176 1
/*ARGSUSED*/
a218 1
/*ARGSUSED*/
a292 1
/*ARGSUSED*/
@


1.32
log
@The must be no space after the syslog priority in the sendsyslog(2)
dropped message error log.
OK benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.31 2015/09/02 13:21:37 bluhm Exp $	*/
d46 1
d87 1
a87 1
int dosendsyslog(struct proc *, const char *, size_t, enum uio_seg);
d360 16
d388 1
a388 1
		    UIO_SYSSPACE);
d397 1
a397 1
	    UIO_USERSPACE);
d399 1
a399 1
	if (error) {
d408 2
a409 1
dosendsyslog(struct proc *p, const char *buf, size_t nbyte, enum uio_seg sflg)
d415 1
d422 14
a435 1
	if (syslogf == NULL)
d437 1
@


1.31
log
@To make logging to local syslog reliable, log a message about failed
log atempts.  sendsyslog(2) is a good place to detect and report
the problem.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.30 2015/05/06 08:52:17 mpi Exp $	*/
d367 1
a367 1
		    "<%d> sendsyslog: dropped %d message%s, error %d",
@


1.30
log
@Pass a thread pointer instead of its file descriptor table to getsock(9).

Diff from Vitaliy Makkoveev.

Manpage tweak and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.29 2015/03/14 03:38:50 jsg Exp $	*/
d86 2
d359 34
d408 2
a409 2
	aiov.iov_base = (char *)SCARG(uap, buf);
	aiov.iov_len = SCARG(uap, nbyte);
d412 1
a412 1
	auio.uio_segflg = UIO_USERSPACE;
@


1.29
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.28 2015/02/10 21:56:09 miod Exp $	*/
d337 1
a337 1
		if ((error = getsock(p->p_fd, *(int *)data, &fp)) != 0)
@


1.28
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.27 2015/01/13 18:51:27 kettenis Exp $	*/
a47 1
#include <sys/conf.h>
@


1.27
log
@Many architectures call initmsgbuf() really really early, before uvm is
initialized.  Calling malloc(9) at that point is not a good idea.  So
initialize consbuf later.

Fixes dmesg -s on sparc64 (and probably a few other architectures).

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.26 2015/01/13 10:07:58 mpf Exp $	*/
d210 1
a210 1
		error = uiomove(&mbp->msg_bufc[mbp->msg_bufr], (int)l, uio);
@


1.26
log
@Add dmesg -s support, to view the output of rc(8) system startup messages.
Help and feedback by Theo and Miod.
OK deraadt@@, manpage-ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.25 2014/12/13 21:05:33 doug Exp $	*/
d120 6
@


1.25
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.24 2014/12/10 02:44:47 tedu Exp $	*/
a76 1
int	msgbufenabled;			/* is logging to the buffer enabled */
d78 1
d116 1
a116 1
		msgbuf_putchar('\n');
d119 9
a127 1
	msgbufmapped = msgbufenabled = 1;
d131 1
a131 1
msgbuf_putchar(const char c) 
a132 2
	struct msgbuf *mbp = msgbufp;

@


1.24
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.23 2014/11/03 03:08:00 deraadt Exp $	*/
d372 2
a375 1
		ktriov = malloc(iovlen, M_TEMP, M_WAITOK);
@


1.23
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.22 2014/07/28 20:30:01 bluhm Exp $	*/
d375 1
a375 1
		bcopy(auio.uio_iov, ktriov, iovlen);
@


1.22
log
@I/O ktrace of sendsyslog(2) did not work.  As uiomove() adjusts
iov_len to 0, we need a propper length calculation.  While there,
use -1 for the file descriptor because 0 is reserved for stdin.
OK deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.21 2014/07/12 18:43:32 tedu Exp $	*/
d348 1
d372 1
a372 1
		int iovlen = auio.uio_iovcnt * sizeof (struct iovec);
d388 1
a388 1
		free(ktriov, M_TEMP, 0);
@


1.21
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.20 2014/07/10 08:55:35 deraadt Exp $	*/
d352 1
d378 1
d380 2
d386 1
a386 1
			ktrgenio(p, 0, UIO_WRITE, ktriov, aiov.iov_len);
@


1.20
log
@Add new sendsyslog(const char *, size_t) system call which simply passes
a message up into syslogd's /dev/log interface.  This will be used to make
syslog_r work during file descriptor exhaustion, or inside sandboxes which
prohibit socket, connect, sendto, etc.
The system call is being added about a week before the library and daemon
changes.
ok guenther tedu miod matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.19 2014/03/30 21:54:48 guenther Exp $	*/
d383 1
a383 1
		free(ktriov, M_TEMP);
@


1.19
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.18 2014/01/21 01:48:44 tedu Exp $	*/
d50 11
d79 1
d157 3
d287 1
d289 1
a289 1
	int s;
d323 10
d337 51
@


1.18
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.17 2011/07/02 22:20:08 nicm Exp $	*/
d299 1
a299 1
		logsoftc.sc_siguid = p->p_cred->p_ruid;
@


1.17
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.16 2009/11/09 17:53:39 nicm Exp $	*/
d97 1
a97 1
		bzero(buf, bufsize);
@


1.16
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.15 2007/09/03 17:51:03 thib Exp $	*/
d222 1
a222 1
		return (1);
@


1.15
log
@unsupported ioctl's should be returned with ENOTTY
not -1;

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.14 2005/12/09 09:09:52 jsg Exp $	*/
a265 1
	KNOTE(&logsoftc.sc_selp.si_note, 0);
@


1.14
log
@ansi and deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.13 2005/04/20 00:08:50 deraadt Exp $	*/
d309 1
a309 1
		return (-1);
@


1.13
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.12 2005/04/14 21:58:50 krw Exp $	*/
d76 1
a76 3
initmsgbuf(buf, bufsize)
	caddr_t buf;
	size_t bufsize;
d132 1
a132 4
logopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
d142 1
a142 4
logclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d152 1
a152 4
logread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d195 1
a195 4
logpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d254 1
a254 1
logwakeup()
d271 1
a271 6
logioctl(dev, com, data, flag, p)
	dev_t dev;
	u_long com;
	caddr_t data;
	int flag;
	struct proc *p;
@


1.12
log
@Try to start log message buffer on a new line. Helps install scripts avoid
detecting phantom devices when scanning dmesg output.

Suggested by miod@@, ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.11 2003/09/23 16:51:12 millert Exp $	*/
d112 2
a113 1
void msgbuf_putchar(const char c) 
@


1.11
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.10 2003/07/21 22:44:50 tedu Exp $	*/
d80 1
a80 1
	register struct msgbuf *mbp;
d103 4
d112 19
d164 3
a166 3
	register struct msgbuf *mbp = msgbufp;
	register long l;
	register int s;
@


1.10
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.9 2003/06/02 23:28:06 millert Exp $	*/
d49 1
d182 1
a182 1
logselect(dev, rw, p)
d184 1
a184 1
	int rw;
d187 1
d190 5
a194 9
	switch (rw) {

	case FREAD:
		if (msgbufp->msg_bufr != msgbufp->msg_bufx) {
			splx(s);
			return (1);
		}
		selrecord(p, &logsoftc.sc_selp);
		break;
d197 1
a197 1
	return (0);
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.8 2002/06/29 02:58:14 mickey Exp $	*/
d152 1
a152 1
		error = tsleep((caddr_t)mbp, LOG_RDPRI | PCATCH,
d169 1
a169 2
		error = uiomove((caddr_t)&mbp->msg_bufc[mbp->msg_bufr],
			(int)l, uio);
d255 1
a255 1
		wakeup((caddr_t)msgbufp);
@


1.8
log
@kqfilter for the log. niels said i can commit it if it works
and i converted syslog to libevent and it works now (;
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.7 2001/04/06 04:42:07 csapuntz Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.6 2000/02/22 19:28:03 deraadt Exp $	*/
d72 6
d207 43
d263 1
@


1.7.6.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.7 2001/04/06 04:42:07 csapuntz Exp $	*/
a71 6
void filt_logrdetach(struct knote *kn);
int filt_logread(struct knote *kn, long hint);
   
struct filterops logread_filtops =
	{ 1, NULL, filt_logrdetach, filt_logread};

a200 43
int
logkqfilter(dev_t dev, struct knote *kn)
{
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &logsoftc.sc_selp.si_note;
		kn->kn_fop = &logread_filtops;
		break;
	default:
		return (1);
	}

	kn->kn_hook = (void *)msgbufp;

	s = splhigh();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

void
filt_logrdetach(struct knote *kn)
{
	int s = splhigh();

	SLIST_REMOVE(&logsoftc.sc_selp.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_logread(struct knote *kn, long hint)
{
	struct  msgbuf *p = (struct  msgbuf *)kn->kn_hook;

	kn->kn_data = (int)(p->msg_bufx - p->msg_bufr);

	return (p->msg_bufx != p->msg_bufr);
}

a213 1
	KNOTE(&logsoftc.sc_selp.si_note, 0);
@


1.6
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.5 1997/09/18 13:23:26 deraadt Exp $	*/
a70 2

#define offsetof(type, member) ((size_t)(&((type *)0)->member))
@


1.5
log
@it is definately wrong to initialize the pgid at open() time because the
uid/euid used for checking in csignal() is controlled by whoever used
TIOCSPGRP previously.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.4 1997/08/31 20:42:20 deraadt Exp $	*/
d68 38
a113 2
	register struct msgbuf *mbp = msgbufp;

a116 13
	/*
	 * Potential race here with putchar() but since putchar should be
	 * called by autoconf, msg_magic should be initialized by the time
	 * we get here.
	 */
	if (mbp->msg_magic != MSG_MAGIC) {
		register int i;

		mbp->msg_magic = MSG_MAGIC;
		mbp->msg_bufx = mbp->msg_bufr = 0;
		for (i=0; i < MSG_BSIZE; i++)
			mbp->msg_bufc[i] = 0;
	}
d165 1
a165 1
			l = MSG_BSIZE - mbp->msg_bufr;
d174 1
a174 1
		if (mbp->msg_bufr < 0 || mbp->msg_bufr >= MSG_BSIZE)
d238 1
a238 1
			l += MSG_BSIZE;
@


1.5.12.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a67 38
int	msgbufmapped;			/* is the message buffer mapped */
int	msgbufenabled;			/* is logging to the buffer enabled */
struct	msgbuf *msgbufp;		/* the mapped buffer, itself. */

#define offsetof(type, member) ((size_t)(&((type *)0)->member))

void
initmsgbuf(buf, bufsize)
	caddr_t buf;
	size_t bufsize;
{
	register struct msgbuf *mbp;
	long new_bufs;

	/* Sanity-check the given size. */
	if (bufsize < sizeof(struct msgbuf))
		return;

	mbp = msgbufp = (struct msgbuf *)buf;

	new_bufs = bufsize - offsetof(struct msgbuf, msg_bufc);
	if ((mbp->msg_magic != MSG_MAGIC) || (mbp->msg_bufs != new_bufs) ||
	    (mbp->msg_bufr < 0) || (mbp->msg_bufr >= mbp->msg_bufs) ||
	    (mbp->msg_bufx < 0) || (mbp->msg_bufx >= mbp->msg_bufs)) {
		/*
		 * If the buffer magic number is wrong, has changed
		 * size (which shouldn't happen often), or is
		 * internally inconsistent, initialize it.
		 */

		bzero(buf, bufsize);
		mbp->msg_magic = MSG_MAGIC;
		mbp->msg_bufs = new_bufs;
	}

	/* mark it as ready for use. */
	msgbufmapped = msgbufenabled = 1;
}
d76 2
d81 13
d142 1
a142 1
			l = mbp->msg_bufs - mbp->msg_bufr;
d151 1
a151 1
		if (mbp->msg_bufr < 0 || mbp->msg_bufr >= mbp->msg_bufs)
d215 1
a215 1
			l += msgbufp->msg_bufs;
@


1.5.12.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.7 2001/04/06 04:42:07 csapuntz Exp $	*/
d71 2
@


1.5.12.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a71 6
void filt_logrdetach(struct knote *kn);
int filt_logread(struct knote *kn, long hint);
   
struct filterops logread_filtops =
	{ 1, NULL, filt_logrdetach, filt_logread};

a200 43
int
logkqfilter(dev_t dev, struct knote *kn)
{
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &logsoftc.sc_selp.si_note;
		kn->kn_fop = &logread_filtops;
		break;
	default:
		return (1);
	}

	kn->kn_hook = (void *)msgbufp;

	s = splhigh();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

void
filt_logrdetach(struct knote *kn)
{
	int s = splhigh();

	SLIST_REMOVE(&logsoftc.sc_selp.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_logread(struct knote *kn, long hint)
{
	struct  msgbuf *p = (struct  msgbuf *)kn->kn_hook;

	kn->kn_data = (int)(p->msg_bufx - p->msg_bufr);

	return (p->msg_bufx != p->msg_bufr);
}

a213 1
	KNOTE(&logsoftc.sc_selp.si_note, 0);
@


1.5.12.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.5.12.3 2003/03/28 00:41:27 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5.12.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a48 1
#include <sys/poll.h>
d152 1
a152 1
		error = tsleep(mbp, LOG_RDPRI | PCATCH,
d169 2
a170 1
		error = uiomove(&mbp->msg_bufc[mbp->msg_bufr], (int)l, uio);
d182 1
a182 1
logpoll(dev, events, p)
d184 1
a184 1
	int events;
a186 1
	int revents = 0;
d189 9
a197 5
	if (events & (POLLIN | POLLRDNORM)) {
		if (msgbufp->msg_bufr != msgbufp->msg_bufx)
			revents |= events & (POLLIN | POLLRDNORM);
		else
			selrecord(p, &logsoftc.sc_selp);
d200 1
a200 1
	return (revents);
d256 1
a256 1
		wakeup(msgbufp);
@


1.4
log
@for non-tty TIOCSPGRP/F_SETOWN/FIOSETOWN pgid setting calls, store uid
and euid as well, then deliver them using new csignal() interface
which ensures that pgid setting process is permitted to signal the
pgid process(es). Thanks to newsham@@aloha.net for extensive help and
discussion.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.3 1996/04/21 22:27:17 deraadt Exp $	*/
a80 1
	logsoftc.sc_pgid = p->p_pid;		/* signal process only */
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_log.c,v 1.2 1996/03/03 17:20:00 niklas Exp $	*/
d63 2
a183 2
	struct proc *p;

d187 3
a189 6
	if (logsoftc.sc_state & LOG_ASYNC) {
		if (logsoftc.sc_pgid < 0)
			gsignal(-logsoftc.sc_pgid, SIGIO); 
		else if ((p = pfind(logsoftc.sc_pgid)) != NULL)
			psignal(p, SIGIO);
	}
d232 2
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: subr_log.c,v 1.10 1996/02/09 18:59:58 christos Exp $	*/
d52 1
a52 2

#include <kern/kern_conf.h>
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: subr_log.c,v 1.8 1994/10/30 21:47:47 cgd Exp $	*/
d50 4
d101 2
a102 1
	int flag;
d129 3
a131 2
		if (error = tsleep((caddr_t)mbp, LOG_RDPRI | PCATCH,
		    "klog", 0)) {
d191 1
a191 1
		else if (p = pfind(logsoftc.sc_pgid))
d202 1
a202 1
logioctl(dev, com, data, flag)
d207 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
