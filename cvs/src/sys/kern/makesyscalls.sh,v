head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.6
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.4
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.11.0.36
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.32
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.34
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.11.0.26
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.11.0.30
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.28
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.24
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.22
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.20
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.18
	OPENBSD_5_0:1.11.0.16
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.14
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.12
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.8
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.10
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.6
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.10.0.24
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.22
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.20
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.18
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.16
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.14
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.12
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.10
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.8
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.14
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.10
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.13
date	2016.09.26.16.42.34;	author jca;	state Exp;
branches;
next	1.12;
commitid	2Gn2CZVdbXLTVSQF;

1.12
date	2016.09.01.12.50.53;	author akfaew;	state Exp;
branches;
next	1.11;
commitid	dWKlOWgSK0wK2OBV;

1.11
date	2007.11.27.18.04.01;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.23.44.37;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.26.04.10.56;	author deraadt;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.01.29.07.20.24;	author jasoni;	state Exp;
branches;
next	1.6;

1.6
date	98.02.08.22.30.41;	author tholo;	state Exp;
branches
	1.6.10.1;
next	1.5;

1.5
date	98.01.02.05.37.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.02.24.14.19.57;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.01.08.13.37.50;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.03.26.15.09.29;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches;
next	;

1.6.10.1
date	2001.05.14.22.32.42;	author niklas;	state Exp;
branches;
next	1.6.10.2;

1.6.10.2
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.6.10.3;

1.6.10.3
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@unbalenced->unbalanced
@
text
@#! /bin/sh -
#	$OpenBSD: makesyscalls.sh,v 1.12 2016/09/01 12:50:53 akfaew Exp $
#	$NetBSD: makesyscalls.sh,v 1.26 1998/01/09 06:17:51 thorpej Exp $
#
# Copyright (c) 1994,1996 Christopher G. Demetriou
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#      This product includes software developed for the NetBSD Project
#      by Christopher G. Demetriou.
# 4. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#	@@(#)makesyscalls.sh	8.1 (Berkeley) 6/10/93

set -e

case $# in
    2)	;;
    *)	echo "Usage: $0 config-file input-file" 1>&2
	exit 1
	;;
esac

# source the config file.
case $1 in
    /*)	. $1
	;;
    *)	. ./$1
	;;
esac

# the config file sets the following variables:
#	sysnames	the syscall names file
#	sysnumhdr	the syscall numbers file
#	syssw		the syscall switch file
#	sysarghdr	the syscall argument struct definitions
#	compatopts	those syscall types that are for 'compat' syscalls
#	switchname	the name for the 'struct sysent' we define
#	namesname	the name for the 'char *[]' we define
#	constprefix	the prefix for the system call constants
#
# NOTE THAT THIS makesyscalls.sh DOES NOT SUPPORT 'LIBCOMPAT'.

# tmp files:
sysdcl="sysent.dcl"
sysprotos="sys.protos"
syscompat_pref="sysent."
sysent="sysent.switch"

trap "rm $sysdcl $sysprotos $sysent" 0

# Awk program (must support nawk extensions)
# Use "awk" at Berkeley, "nawk" or "gawk" elsewhere.
awk=${AWK:-awk}

# Does this awk have a "toupper" function? (i.e. is it GNU awk)
isgawk=`$awk 'BEGIN { print toupper("true"); exit; }' 2>/dev/null`

# If this awk does not define "toupper" then define our own.
if [ "$isgawk" = TRUE ] ; then
	# GNU awk provides it.
	toupper=
else
	# Provide our own toupper()
	toupper='
function toupper(str) {
	_toupper_cmd = "echo "str" |tr a-z A-Z"
	_toupper_cmd | getline _toupper_str;
	close(_toupper_cmd);
	return _toupper_str;
}'
fi

# before handing it off to awk, make a few adjustments:
#	(1) insert spaces around {, }, (, ), *, and commas.
#	(2) get rid of any and all dollar signs (so that rcs id use safe)
#
# The awk script will deal with blank lines and lines that
# start with the comment character (';').

sed -e '
s/\$//g
:join
	/\\$/{a\

	N
	s/\\\n//
	b join
	}
2,${
	/^#/!s/\([{}()*,]\)/ \1 /g
}
' < $2 | $awk "
$toupper
BEGIN {
	# to allow nested #if/#else/#endif sets
	savedepth = 0

	sysnames = \"$sysnames\"
	sysprotos = \"$sysprotos\"
	sysnumhdr = \"$sysnumhdr\"
	sysarghdr = \"$sysarghdr\"
	switchname = \"$switchname\"
	namesname = \"$namesname\"
	constprefix = \"$constprefix\"

	sysdcl = \"$sysdcl\"
	syscompat_pref = \"$syscompat_pref\"
	sysent = \"$sysent\"
	infile = \"$2\"

	compatopts = \"$compatopts\"
	"'

	printf "/*\t\$OpenBSD\$\t*/\n\n" > sysdcl
	printf "/*\n * System call switch table.\n *\n" > sysdcl
	printf " * DO NOT EDIT-- this file is automatically generated.\n" > sysdcl

	ncompat = split(compatopts,compat)
	for (i = 1; i <= ncompat; i++) {
		compat_upper[i] = toupper(compat[i])

		printf "\n#ifdef %s\n", compat_upper[i] > sysent
		printf "#define %s(func) __CONCAT(%s_,func)\n", compat[i], \
		    compat[i] > sysent
		printf "#else\n" > sysent
		printf "#define %s(func) sys_nosys\n", compat[i] > sysent
		printf "#endif\n" > sysent
	}

	printf "\n#define\ts(type)\tsizeof(type)\n\n" > sysent
	printf "struct sysent %s[] = {\n",switchname > sysent

	printf "/*\t\$OpenBSD\$\t*/\n\n" > sysnames
	printf "/*\n * System call names.\n *\n" > sysnames
	printf " * DO NOT EDIT-- this file is automatically generated.\n" > sysnames

	printf "\n/*\n * System call prototypes.\n */\n\n" > sysprotos

	printf "/*\t\$OpenBSD\$\t*/\n\n" > sysnumhdr
	printf "/*\n * System call numbers.\n *\n" > sysnumhdr
	printf " * DO NOT EDIT-- this file is automatically generated.\n" > sysnumhdr

	printf "/*\t\$OpenBSD\$\t*/\n\n" > sysarghdr
	printf "/*\n * System call argument lists.\n *\n" > sysarghdr
	printf " * DO NOT EDIT-- this file is automatically generated.\n" > sysarghdr
}
NR == 1 {
	printf " * created from%s\n */\n\n", $0 > sysdcl

	printf " * created from%s\n */\n\n", $0 > sysnames
	printf "char *%s[] = {\n",namesname > sysnames

	printf " * created from%s\n */\n\n", $0 > sysnumhdr

	printf " * created from%s\n */\n\n", $0 > sysarghdr
	printf "#ifdef\tsyscallarg\n" > sysarghdr
	printf "#undef\tsyscallarg\n" > sysarghdr
	printf "#endif\n\n" > sysarghdr
	printf "#define\tsyscallarg(x)\t\t\t\t\t\t\t\\\n" > sysarghdr
	printf "\tunion {\t\t\t\t\t\t\t\t\\\n" > sysarghdr
	printf "\t\tregister_t pad;\t\t\t\t\t\t\\\n" > sysarghdr
	printf "\t\tstruct { x datum; } le;\t\t\t\t\t\\\n" > sysarghdr
	printf "\t\tstruct {\t\t\t\t\t\t\\\n" > sysarghdr
	printf "\t\t\tint8_t pad[ (sizeof (register_t) < sizeof (x))\t\\\n" \
		> sysarghdr
	printf "\t\t\t\t? 0\t\t\t\t\t\\\n" > sysarghdr
	printf "\t\t\t\t: sizeof (register_t) - sizeof (x)];\t\\\n" \
		> sysarghdr
	printf "\t\t\tx datum;\t\t\t\t\t\\\n" > sysarghdr
	printf "\t\t} be;\t\t\t\t\t\t\t\\\n" > sysarghdr
	printf "\t}\n" > sysarghdr
	next
}
NF == 0 || $1 ~ /^;/ {
	next
}
$1 ~ /^#[ 	]*include/ {
	print > sysdcl
	next
}
$1 ~ /^#[ 	]*if/ {
	print > sysent
	print > sysprotos
	print > sysnames
	savesyscall[++savedepth] = syscall
	next
}
$1 ~ /^#[ 	]*else/ {
	print > sysent
	print > sysprotos
	print > sysnames
	if (savedepth <= 0) {
		printf "%s: line %d: unbalanced #else\n", \
		    infile, NR
		exit 1
	}
	syscall = savesyscall[savedepth]
	next
}
$1 ~ /^#/ {
	if ($1 ~ /^#[       ]*endif/) {
		if (savedepth <= 0) {
			printf "%s: line %d: unbalanced #endif\n", \
			    infile, NR
			exit 1
		}
		savedepth--;
	}
	print > sysent
	print > sysprotos
	print > sysnames
	next
}
syscall != $1 {
	printf "%s: line %d: syscall number out of sync at %d\n", \
	   infile, NR, syscall
	printf "line is:\n"
	print
	exit 1
}
function parserr(was, wanted) {
	printf "%s: line %d: unexpected %s (expected %s)\n", \
	    infile, NR, was, wanted
	exit 1
}
function parseline() {
	f=3			# toss number and type
	sycall_flags="0"
	if ($NF != "}") {
		funcalias=$NF
		end=NF-1
	} else {
		funcalias=""
		end=NF
	}
	if ($f == "NOLOCK") {		# syscall does not need locks
		sycall_flags = sprintf("SY_NOLOCK | %s", sycall_flags)
		f++
	}
	if ($f ~ /^[a-z0-9_]*$/) {      # allow syscall alias
		funcalias=$f
		f++
	}	
	if ($f != "{")
		parserr($f, "{")
	f++
	if ($end != "}")
		parserr($end, "}")
	end--
	if ($end != ";")
		parserr($end, ";")
	end--
	if ($end != ")")
		parserr($end, ")")
	end--

	returntype = oldf = "";
	do {
		if (returntype != "" && oldf != "*")
			returntype = returntype" ";
		returntype = returntype$f;
		oldf = $f;
		f++
	} while (f < (end - 1) && $(f+1) != "(");
	if (f == (end - 1)) {
		parserr($f, "function argument definition (maybe \"(\"?)");
	}

	funcname=$f
	if (funcalias == "") {
		funcalias=funcname
		sub(/^([^_]+_)*sys_/, "", funcalias)
	}
	f++

	if ($f != "(")
		parserr($f, ")")
	f++

	argc=0;
	if (f == end) {
		if ($f != "void")
			parserr($f, "argument definition")
		isvarargs = 0;
		varargc = 0;
		return
	}

	# some system calls (open() and fcntl()) can accept a variable
	# number of arguments.  If syscalls accept a variable number of
	# arguments, they must still have arguments specified for
	# the remaining argument "positions," because of the way the
	# kernel system call argument handling works.
	#
	# Indirect system calls, e.g. syscall(), are exceptions to this
	# rule, since they are handled entirely by machine-dependent code
	# and do not need argument structures built.

	isvarargs = 0;
	while (f <= end) {
		if ($f == "...") {
			f++;
			isvarargs = 1;
			varargc = argc;
			continue;
		}
		argc++
		argtype[argc]=""
		oldf=""
		while (f < end && $(f+1) != ",") {
			if (argtype[argc] != "" && oldf != "*")
				argtype[argc] = argtype[argc]" ";
			argtype[argc] = argtype[argc]$f;
			oldf = $f;
			f++
		}
		if (argtype[argc] == "")
			parserr($f, "argument definition")
		argname[argc]=$f;
		f += 2;			# skip name, and any comma
	}
	# must see another argument after varargs notice.
	if (isvarargs) {
		if (argc == varargc && $2 != "INDIR")
			parserr($f, "argument definition")
	} else
		varargc = argc;
}
function putent(nodefs, compatwrap) {
	# output syscall declaration for switch table.  INDIR functions
	# get none, since they always have sys_nosys() for their table
	# entries.
	if (nodefs != "INDIR") {
		prototype = "(struct proc *, void *, register_t *)"
		if (compatwrap == "")
			printf("int\t%s%s;\n", funcname,
			    prototype) > sysprotos
		else
			printf("int\t%s_%s%s;\n", compatwrap, funcname,
			    prototype) > sysprotos
	}

	# output syscall switch entry
	if (nodefs == "INDIR") {
		printf("\t{ 0, 0, %s,\n\t    sys_nosys },\t\t\t/* %d = %s (indir) */\n", \
		    sycall_flags, syscall, funcalias) > sysent
	} else {
#		printf("\t{ { %d", argc) > sysent
#		for (i = 1; i <= argc; i++) {
#			if (i == 5) 		# wrap the line
#				printf(",\n\t    ") > sysent
#			else
#				printf(", ") > sysent
#			printf("s(%s)", argtypenospc[i]) > sysent
#		}
		printf("\t{ %d, ", argc) > sysent
		if (argc == 0)
			printf("0") > sysent
		else if (compatwrap == "")
			printf("s(struct %s_args)", funcname) > sysent
		else
			printf("s(struct %s_%s_args)", compatwrap,
			    funcname) > sysent
		if (compatwrap == "")
			wfn = sprintf("%s", funcname);
		else
			wfn = sprintf("%s(%s)", compatwrap, funcname);
		printf(", %s,\n\t    %s },", sycall_flags, wfn) > sysent
		for (i = 0; i < (33 - length(wfn)) / 8; i++)
			printf("\t") > sysent
		if (compatwrap == "")
			printf("/* %d = %s */\n", syscall, funcalias) > sysent
		else
			printf("/* %d = %s %s */\n", syscall, compatwrap,
			    funcalias) > sysent
	}

	# output syscall name for names table
	if (compatwrap == "")
		printf("\t\"%s\",\t\t\t/* %d = %s */\n", funcalias, syscall,
		    funcalias) > sysnames
	else
		printf("\t\"%s_%s\",\t/* %d = %s %s */\n", compatwrap,
		    funcalias, syscall, compatwrap, funcalias) > sysnames

	# output syscall number of header, if appropriate
	if (nodefs == "" || nodefs == "NOARGS" || nodefs == "INDIR") {
		# output a prototype, to be used to generate lint stubs in
		# libc.
		printf("/* syscall: \"%s\" ret: \"%s\" args:", funcalias,
		    returntype) > sysnumhdr
		for (i = 1; i <= varargc; i++)
			printf(" \"%s\"", argtype[i]) > sysnumhdr
		if (isvarargs)
			printf(" \"...\"") > sysnumhdr
		printf(" */\n") > sysnumhdr

		printf("#define\t%s%s\t%d\n\n", constprefix, funcalias,
		    syscall) > sysnumhdr
	} else if (nodefs != "NODEF")
		printf("\t\t\t\t/* %d is %s %s */\n\n", syscall,
		    compatwrap, funcalias) > sysnumhdr

	# output syscall argument structure, if it has arguments
	if (argc != 0 && nodefs != "NOARGS" && nodefs != "INDIR") {
		if (compatwrap == "")
			printf("\nstruct %s_args {\n", funcname) > sysarghdr
		else
			printf("\nstruct %s_%s_args {\n", compatwrap,
			    funcname) > sysarghdr
		for (i = 1; i <= argc; i++)
			printf("\tsyscallarg(%s) %s;\n", argtype[i],
			    argname[i]) > sysarghdr
		printf("};\n") > sysarghdr
	}
}
$2 == "STD" {
	parseline()
	putent("", "");
	syscall++
	next
}
$2 == "NODEF" || $2 == "NOARGS" || $2 == "INDIR" {
	parseline()
	putent($2, "")
	syscall++
	next
}
$2 == "OBSOL" || $2 == "UNIMPL" {
	if ($2 == "OBSOL")
		comment="obsolete"
	else
		comment="unimplemented"
	for (i = 3; i <= NF; i++)
		comment=comment " " $i

	printf("\t{ 0, 0, 0,\n\t    sys_nosys },\t\t\t/* %d = %s */\n", \
	    syscall, comment) > sysent
	printf("\t\"#%d (%s)\",\t\t/* %d = %s */\n", \
	    syscall, comment, syscall, comment) > sysnames
	if ($2 != "UNIMPL")
		printf("\t\t\t\t/* %d is %s */\n", syscall, comment) > sysnumhdr
	syscall++
	next
}
{
	for (i = 1; i <= ncompat; i++) {
		if ($2 == compat_upper[i]) {
			parseline();
			putent("COMMENT", compat[i])
			syscall++
			next
		}
	}
	printf "%s: line %d: unrecognized keyword %s\n", infile, NR, $2
	exit 1
}
END {
	printf("};\n\n") > sysent
	printf("};\n") > sysnames
	printf("#define\t%sMAXSYSCALL\t%d\n", constprefix, syscall) > sysnumhdr
} '

cat $sysprotos >> $sysarghdr
cat $sysdcl $sysent > $syssw

#chmod 444 $sysnames $sysnumhdr $syssw
@


1.12
log
@MPSAFE is never used, so get rid of it.

OK natano@@ mpi@@ guenther@@
@
text
@d2 1
a2 1
#	$OpenBSD: makesyscalls.sh,v 1.11 2007/11/27 18:04:01 art Exp $
d215 1
a215 1
		printf "%s: line %d: unbalenced #else\n", \
d225 1
a225 1
			printf "%s: line %d: unbalenced #endif\n", \
@


1.11
log
@Add possibility to add flags to syscalls in syscalls.master to mark
syscalls as NOLOCK and MPSAFE. The flags have slightly different semantics:
 NOLOCK - the syscall doesn't grab any locks whatsoever.
 MPSAFE - the syscall deals with its own locking.

What this means in practice is that NOLOCK syscalls can always be done
without the biglock. The MPSAFE syscalls can be done without the biglock
on CPUs that don't handle interrupts that require biglock (to preserve
lock ordering).

deraadt@@ ok
@
text
@d2 1
a2 1
#	$OpenBSD: makesyscalls.sh,v 1.10 2002/03/14 23:44:37 millert Exp $
a256 4
	}
	if ($f == "MPSAFE") {		# allow MP-safe syscalls
		sycall_flags = sprintf("SY_MPSAFE | %s", sycall_flags)
		f++
@


1.10
log
@Don't put a tab between a function and its arguments
@
text
@d2 1
a2 1
#	$OpenBSD: makesyscalls.sh,v 1.9 2002/03/14 01:27:04 millert Exp $
d250 1
d258 8
d371 2
a372 2
		printf("\t{ 0, 0,\n\t    sys_nosys },\t\t\t/* %d = %s (indir) */\n", \
		    syscall, funcalias) > sysent
d394 1
a394 1
		printf(",\n\t    %s },", wfn) > sysent
d463 1
a463 1
	printf("\t{ 0, 0,\n\t    sys_nosys },\t\t\t/* %d = %s */\n", \
@


1.9
log
@First round of __P removal in sys
@
text
@d2 1
a2 1
#	$OpenBSD: makesyscalls.sh,v 1.8 2001/08/26 04:10:56 deraadt Exp $
d353 1
a353 1
			printf("int\t%s\t%s;\n", funcname,
d356 1
a356 1
			printf("int\t%s_%s\t%s;\n", compatwrap, funcname,
@


1.8
log
@be and le varients of syscallarg; from netbsd
@
text
@d2 1
a2 1
#	$OpenBSD: makesyscalls.sh,v 1.7 2001/01/29 07:20:24 jasoni Exp $
d351 1
a351 1
		prototype = "__P((struct proc *, void *, register_t *))"
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d2 1
a2 1
#	$OpenBSD: makesyscalls.sh,v 1.8 2001/08/26 04:10:56 deraadt Exp $
d351 1
a351 1
		prototype = "(struct proc *, void *, register_t *)"
d353 1
a353 1
			printf("int\t%s%s;\n", funcname,
d356 1
a356 1
			printf("int\t%s_%s%s;\n", compatwrap, funcname,
@


1.7
log
@Allow syscall aliasing to allow for multiple linux syscalls to be mapped
to the same native syscall. To quote Jaromir's NetBSD commit
	if the third argument in syscall.conf matches [a-z0-9_], use it
	as a function alias instead of the function name in { ... }
- from NetBSD, deraadt@@ ok.
@
text
@d2 1
a2 1
#	$OpenBSD: makesyscalls.sh,v 1.6 1998/02/08 22:30:41 tholo Exp $
d178 9
a186 1
	printf "#define\tsyscallarg(x)\tunion { x datum; register_t pad; }\n" \
d188 6
@


1.6
log
@Sync with NetBSD
@
text
@d2 1
a2 1
#	$OpenBSD$
d243 4
@


1.6.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
#	$OpenBSD: makesyscalls.sh,v 1.7 2001/01/29 07:20:24 jasoni Exp $
a242 4
	if ($f ~ /^[a-z0-9_]*$/) {      # allow syscall alias
		funcalias=$f
		f++
	}	
@


1.6.10.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d2 1
a2 1
#	$OpenBSD: makesyscalls.sh,v 1.6.10.1 2001/05/14 22:32:42 niklas Exp $
d178 1
a178 9
	printf "#ifdef\tsyscallarg\n" > sysarghdr
	printf "#undef\tsyscallarg\n" > sysarghdr
	printf "#endif\n\n" > sysarghdr
	printf "#define\tsyscallarg(x)\t\t\t\t\t\t\t\\\n" > sysarghdr
	printf "\tunion {\t\t\t\t\t\t\t\t\\\n" > sysarghdr
	printf "\t\tregister_t pad;\t\t\t\t\t\t\\\n" > sysarghdr
	printf "\t\tstruct { x datum; } le;\t\t\t\t\t\\\n" > sysarghdr
	printf "\t\tstruct {\t\t\t\t\t\t\\\n" > sysarghdr
	printf "\t\t\tint8_t pad[ (sizeof (register_t) < sizeof (x))\t\\\n" \
a179 6
	printf "\t\t\t\t? 0\t\t\t\t\t\\\n" > sysarghdr
	printf "\t\t\t\t: sizeof (register_t) - sizeof (x)];\t\\\n" \
		> sysarghdr
	printf "\t\t\tx datum;\t\t\t\t\t\\\n" > sysarghdr
	printf "\t\t} be;\t\t\t\t\t\t\t\\\n" > sysarghdr
	printf "\t}\n" > sysarghdr
@


1.6.10.3
log
@Merge in -current from about a week ago
@
text
@d2 1
a2 1
#	$OpenBSD$
d351 1
a351 1
		prototype = "(struct proc *, void *, register_t *)"
d353 1
a353 1
			printf("int\t%s%s;\n", funcname,
d356 1
a356 1
			printf("int\t%s_%s%s;\n", compatwrap, funcname,
@


1.5
log
@merge recent netbsd changes
@
text
@d2 2
a3 1
#	$NetBSD: makesyscalls.sh,v 1.21 1996/12/22 06:45:14 cgd Exp $
d136 1
d155 1
d161 1
d165 1
@


1.4
log
@OpenBSD tags
@
text
@d2 1
a2 2
#	$OpenBSD: makesyscalls.sh,v 1.18 1996/03/15 01:25:12 cgd Exp $
#	$NetBSD: makesyscalls.sh,v 1.18 1996/03/15 01:25:12 cgd Exp $
d4 1
a4 1
# Copyright (c) 1994 Christopher G. Demetriou
d251 11
a261 1
	f++			# toss return type
d274 1
a274 1
	argc= 0;
d278 2
d283 11
d295 6
d316 6
d324 12
a335 6
	# output syscall declaration for switch table
	prototype = "__P((struct proc *, void *, register_t *))"
	if (compatwrap == "")
		printf("int\t%s\t%s;\n", funcname, prototype) > sysprotos
	else
		printf("int\t%s_%s\t%s;\n", compatwrap, funcname, prototype) > sysprotos
d338 33
a370 27
#	printf("\t{ { %d", argc) > sysent
#	for (i = 1; i <= argc; i++) {
#		if (i == 5) 		# wrap the line
#			printf(",\n\t    ") > sysent
#		else
#			printf(", ") > sysent
#		printf("s(%s)", argtypenospc[i]) > sysent
#	}
	printf("\t{ %d, ", argc) > sysent
	if (argc == 0)
		printf("0") > sysent
	else if (compatwrap == "")
		printf("s(struct %s_args)", funcname) > sysent
	else
		printf("s(struct %s_%s_args)", compatwrap, funcname) > sysent
	if (compatwrap == "")
		wfn = sprintf("%s", funcname);
	else
		wfn = sprintf("%s(%s)", compatwrap, funcname);
	printf(",\n\t    %s },", wfn) > sysent
	for (i = 0; i < (33 - length(wfn)) / 8; i++)
		printf("\t") > sysent
	if (compatwrap == "")
		printf("/* %d = %s */\n", syscall, funcalias) > sysent
	else
		printf("/* %d = %s %s */\n", syscall, compatwrap,
		    funcalias) > sysent
d381 12
a392 2
	if (nodefs == "" || nodefs == "NOARGS")
		printf("#define\t%s%s\t%d\n", constprefix, funcalias,
d394 2
a395 2
	else if (nodefs != "NODEF")
		printf("\t\t\t\t/* %d is %s %s */\n", syscall,
d399 1
a399 1
	if (argc != 0 && nodefs != "NOARGS") {
d417 1
a417 1
$2 == "NODEF" || $2 == "NOARGS" {
@


1.3
log
@If config-file is not starting with /, consider it to be a
relative path.
@
text
@d2 1
@


1.2
log
@From NetBSD: vnode_if.[ch] made machine independent.
very usefull (for <sys/vnode.h> inclusion).
from the other side this is really machine independent ...
tested w/ i386, but should not cause errors w/ other arch's.
pls, test it (don't forget to reconfig kernel ;)
@
text
@d45 6
a50 1
. $1
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
#	$NetBSD: makesyscalls.sh,v 1.17 1995/10/07 06:28:31 mycroft Exp $
d111 3
d183 1
a183 1
	savesyscall = syscall
d190 6
a195 1
	syscall = savesyscall
d199 8
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
