head	1.45;
access;
symbols
	OPENBSD_6_0:1.45.0.4
	OPENBSD_6_0_BASE:1.45
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.44.0.6
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.39.0.18
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.14
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.12
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.10
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.8
	OPENBSD_5_0:1.39.0.6
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.4
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.33.0.2
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.30.0.2
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10;
locks; strict;
comment	@ * @;


1.45
date	2015.12.21.21.49.02;	author sf;	state Exp;
branches;
next	1.44;
commitid	QfhbTzV3KV3v5lir;

1.44
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	3SGDR5EjcwE01W8S;

1.43
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.42;
commitid	uzzBR7hz9ncd4O6G;

1.42
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.41;
commitid	QlVV51SZgNFxsXxC;

1.41
date	2014.03.21.21.54.14;	author andre;	state Exp;
branches;
next	1.40;

1.40
date	2014.03.21.21.46.47;	author andre;	state Exp;
branches;
next	1.39;

1.39
date	2010.05.27.17.18.23;	author sthen;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.23.03.44.44;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2010.04.21.23.43.39;	author sthen;	state Exp;
branches;
next	1.36;

1.36
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.02.21.17.35;	author ckuethe;	state Exp;
branches;
next	1.34;

1.34
date	2009.04.26.02.25.36;	author cnst;	state Exp;
branches;
next	1.33;

1.33
date	2008.12.25.21.25.55;	author stevesk;	state Exp;
branches;
next	1.32;

1.32
date	2008.12.25.21.04.36;	author stevesk;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.30;

1.30
date	2008.07.22.06.06.47;	author mbalmer;	state Exp;
branches;
next	1.29;

1.29
date	2008.07.07.08.01.47;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.06.21.03.13;	author mbalmer;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.11.17.11.36;	author mbalmer;	state Exp;
branches;
next	1.26;

1.26
date	2008.05.05.19.57.01;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2008.01.28.20.32.50;	author stevesk;	state Exp;
branches;
next	1.24;

1.24
date	2007.11.27.10.06.55;	author mbalmer;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.26.19.14.38;	author mbalmer;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2007.03.20.20.14.29;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2007.03.19.06.37.01;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.05.10.23.16;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.02.22.43.29;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.23.17.46.38;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.12.23.08.29.39;	author mbalmer;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.15.16.49.39;	author mbalmer;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.29.13.26.50;	author mbalmer;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.28.17.20.25;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.18.08.20.51;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.21.06.24.50;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.20.14.06.21;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.19.16.27.17;	author mbalmer;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.13.07.01.59;	author mbalmer;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.10.23.15.26;	author mbalmer;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.05.05.01.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.04.09.52.40;	author mbalmer;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.01.23.17.08;	author ckuethe;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.01.22.32.46;	author ckuethe;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.01.20.10.28;	author mbalmer;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Move ppp, nmea, endrun, and msts prototypes to tty.h

Fix inconsistent arguments for pppopen/pppclose/pppstart.
Use passed in argument p in pppopen instead of curproc.

"Looks good to me" deraadt@@
@
text
@/*	$OpenBSD: tty_nmea.c,v 1.44 2014/11/03 03:08:00 deraadt Exp $ */

/*
 * Copyright (c) 2006, 2007, 2008 Marc Balmer <mbalmer@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* A tty line discipline to decode NMEA 0183 data to get the time. */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/sensors.h>
#include <sys/tty.h>
#include <sys/conf.h>
#include <sys/time.h>

#ifdef NMEA_DEBUG
#define DPRINTFN(n, x)	do { if (nmeadebug > (n)) printf x; } while (0)
int nmeadebug = 0;
#else
#define DPRINTFN(n, x)
#endif
#define DPRINTF(x)	DPRINTFN(0, x)

void	nmeaattach(int);

#define NMEAMAX		82
#define MAXFLDS		32
#ifdef NMEA_DEBUG
#define TRUSTTIME	30
#else
#define TRUSTTIME	(10 * 60)	/* 10 minutes */
#endif

int nmea_count, nmea_nxid;

struct nmea {
	char			cbuf[NMEAMAX];	/* receive buffer */
	struct ksensor		time;		/* the timedelta sensor */
	struct ksensor		signal;		/* signal status */
	struct ksensor		latitude;
	struct ksensor		longitude;
	struct ksensordev	timedev;
	struct timespec		ts;		/* current timestamp */
	struct timespec		lts;		/* timestamp of last '$' seen */
	struct timeout		nmea_tout;	/* invalidate sensor */
	int64_t			gap;		/* gap between two sentences */
#ifdef NMEA_DEBUG
	int			gapno;
#endif
	int64_t			last;		/* last time rcvd */
	int			sync;		/* if 1, waiting for '$' */
	int			pos;		/* position in rcv buffer */
	int			no_pps;		/* no PPS although requested */
	char			mode;		/* GPS mode */
};

/* NMEA decoding */
void	nmea_scan(struct nmea *, struct tty *);
void	nmea_gprmc(struct nmea *, struct tty *, char *fld[], int fldcnt);

/* date and time conversion */
int	nmea_date_to_nano(char *s, int64_t *nano);
int	nmea_time_to_nano(char *s, int64_t *nano);

/* longitude and latitude conversion */
int	nmea_degrees(int64_t *dst, char *src, int neg);

/* degrade the timedelta sensor */
void	nmea_timeout(void *);

void
nmeaattach(int dummy)
{
	/* noop */
}

int
nmeaopen(dev_t dev, struct tty *tp, struct proc *p)
{
	struct nmea *np;
	int error;

	if (tp->t_line == NMEADISC)
		return (ENODEV);
	if ((error = suser(p, 0)) != 0)
		return (error);
	np = malloc(sizeof(struct nmea), M_DEVBUF, M_WAITOK | M_ZERO);
	snprintf(np->timedev.xname, sizeof(np->timedev.xname), "nmea%d",
	    nmea_nxid++);
	nmea_count++;
	np->time.status = SENSOR_S_UNKNOWN;
	np->time.type = SENSOR_TIMEDELTA;
	np->time.flags = SENSOR_FINVALID;
	sensor_attach(&np->timedev, &np->time);

	np->signal.type = SENSOR_INDICATOR;
	np->signal.status = SENSOR_S_UNKNOWN;
	np->signal.value = 0;
	strlcpy(np->signal.desc, "Signal", sizeof(np->signal.desc));
	sensor_attach(&np->timedev, &np->signal);

	np->latitude.type = SENSOR_ANGLE;
	np->latitude.status = SENSOR_S_UNKNOWN;
	np->latitude.flags = SENSOR_FINVALID;
	np->latitude.value = 0;
	strlcpy(np->latitude.desc, "Latitude", sizeof(np->latitude.desc));
	sensor_attach(&np->timedev, &np->latitude);

	np->longitude.type = SENSOR_ANGLE;
	np->longitude.status = SENSOR_S_UNKNOWN;
	np->longitude.flags = SENSOR_FINVALID;
	np->longitude.value = 0;
	strlcpy(np->longitude.desc, "Longitude", sizeof(np->longitude.desc));
	sensor_attach(&np->timedev, &np->longitude);

	np->sync = 1;
	tp->t_sc = (caddr_t)np;

	error = linesw[TTYDISC].l_open(dev, tp, p);
	if (error) {
		free(np, M_DEVBUF, sizeof(*np));
		tp->t_sc = NULL;
	} else {
		sensordev_install(&np->timedev);
		timeout_set(&np->nmea_tout, nmea_timeout, np);
	}
	return (error);
}

int
nmeaclose(struct tty *tp, int flags, struct proc *p)
{
	struct nmea *np = (struct nmea *)tp->t_sc;

	tp->t_line = TTYDISC;	/* switch back to termios */
	timeout_del(&np->nmea_tout);
	sensordev_deinstall(&np->timedev);
	free(np, M_DEVBUF, sizeof(*np));
	tp->t_sc = NULL;
	nmea_count--;
	if (nmea_count == 0)
		nmea_nxid = 0;
	return (linesw[TTYDISC].l_close(tp, flags, p));
}

/* Collect NMEA sentences from the tty. */
int
nmeainput(int c, struct tty *tp)
{
	struct nmea *np = (struct nmea *)tp->t_sc;
	struct timespec ts;
	int64_t gap;
	long tmin, tmax;

	switch (c) {
	case '$':
		nanotime(&ts);
		np->pos = np->sync = 0;
		gap = (ts.tv_sec * 1000000000LL + ts.tv_nsec) -
		    (np->lts.tv_sec * 1000000000LL + np->lts.tv_nsec);

		np->lts.tv_sec = ts.tv_sec;
		np->lts.tv_nsec = ts.tv_nsec;

		if (gap <= np->gap)
			break;

		np->ts.tv_sec = ts.tv_sec;
		np->ts.tv_nsec = ts.tv_nsec;

#ifdef NMEA_DEBUG
		if (nmeadebug > 0) {
			linesw[TTYDISC].l_rint('[', tp);
			linesw[TTYDISC].l_rint('0' + np->gapno++, tp);
			linesw[TTYDISC].l_rint(']', tp);
		}
#endif
		np->gap = gap;

		/*
		 * If a tty timestamp is available, make sure its value is
		 * reasonable by comparing against the timestamp just taken.
		 * If they differ by more than 2 seconds, assume no PPS signal
		 * is present, note the fact, and keep using the timestamp
		 * value.  When this happens, the sensor state is set to
		 * CRITICAL later when the GPRMC sentence is decoded.
		 */
		if (tp->t_flags & (TS_TSTAMPDCDSET | TS_TSTAMPDCDCLR |
		    TS_TSTAMPCTSSET | TS_TSTAMPCTSCLR)) {
			tmax = lmax(np->ts.tv_sec, tp->t_tv.tv_sec);
			tmin = lmin(np->ts.tv_sec, tp->t_tv.tv_sec);
			if (tmax - tmin > 1)
				np->no_pps = 1;
			else {
				np->ts.tv_sec = tp->t_tv.tv_sec;
				np->ts.tv_nsec = tp->t_tv.tv_usec *
				    1000L;
				np->no_pps = 0;
			}
		}
		break;
	case '\r':
	case '\n':
		if (!np->sync) {
			np->cbuf[np->pos] = '\0';
			nmea_scan(np, tp);
			np->sync = 1;
		}
		break;
	default:
		if (!np->sync && np->pos < (NMEAMAX - 1))
			np->cbuf[np->pos++] = c;
		break;
	}
	/* pass data to termios */
	return (linesw[TTYDISC].l_rint(c, tp));
}

/* Scan the NMEA sentence just received. */
void
nmea_scan(struct nmea *np, struct tty *tp)
{
	int fldcnt = 0, cksum = 0, msgcksum, n;
	char *fld[MAXFLDS], *cs;

	/* split into fields and calculate the checksum */
	fld[fldcnt++] = &np->cbuf[0];	/* message type */
	for (cs = NULL, n = 0; n < np->pos && cs == NULL; n++) {
		switch (np->cbuf[n]) {
		case '*':
			np->cbuf[n] = '\0';
			cs = &np->cbuf[n + 1];
			break;
		case ',':
			if (fldcnt < MAXFLDS) {
				cksum ^= np->cbuf[n];
				np->cbuf[n] = '\0';
				fld[fldcnt++] = &np->cbuf[n + 1];
			} else {
				DPRINTF(("nr of fields in %s sentence exceeds "
				    "maximum of %d\n", fld[0], MAXFLDS));
				return;
			}
			break;
		default:
			cksum ^= np->cbuf[n];
		}
	}

	/* we only look at the GPRMC message */
	if (strcmp(fld[0], "GPRMC"))
		return;

	/* if we have a checksum, verify it */
	if (cs != NULL) {
		msgcksum = 0;
		while (*cs) {
			if ((*cs >= '0' && *cs <= '9') ||
			    (*cs >= 'A' && *cs <= 'F')) {
				if (msgcksum)
					msgcksum <<= 4;
				if (*cs >= '0' && *cs<= '9')
					msgcksum += *cs - '0';
				else if (*cs >= 'A' && *cs <= 'F')
					msgcksum += 10 + *cs - 'A';
				cs++;
			} else {
				DPRINTF(("bad char %c in checksum\n", *cs));
				return;
			}
		}
		if (msgcksum != cksum) {
			DPRINTF(("checksum mismatch\n"));
			return;
		}
	}
	nmea_gprmc(np, tp, fld, fldcnt);
}

/* Decode the recommended minimum specific GPS/TRANSIT data. */
void
nmea_gprmc(struct nmea *np, struct tty *tp, char *fld[], int fldcnt)
{
	int64_t date_nano, time_nano, nmea_now;
	int jumped = 0;

	if (fldcnt != 12 && fldcnt != 13) {
		DPRINTF(("gprmc: field count mismatch, %d\n", fldcnt));
		return;
	}
	if (nmea_time_to_nano(fld[1], &time_nano)) {
		DPRINTF(("gprmc: illegal time, %s\n", fld[1]));
		return;
	}
	if (nmea_date_to_nano(fld[9], &date_nano)) {
		DPRINTF(("gprmc: illegal date, %s\n", fld[9]));
		return;
	}
	nmea_now = date_nano + time_nano;
	if (nmea_now <= np->last) {
		DPRINTF(("gprmc: time not monotonically increasing\n"));
		jumped = 1;
	}
	np->last = nmea_now;
	np->gap = 0LL;
#ifdef NMEA_DEBUG
	if (np->time.status == SENSOR_S_UNKNOWN) {
		np->time.status = SENSOR_S_OK;
		timeout_add_sec(&np->nmea_tout, TRUSTTIME);
	}
	np->gapno = 0;
	if (nmeadebug > 0) {
		linesw[TTYDISC].l_rint('[', tp);
		linesw[TTYDISC].l_rint('C', tp);
		linesw[TTYDISC].l_rint(']', tp);
	}
#endif

	np->time.value = np->ts.tv_sec * 1000000000LL +
	    np->ts.tv_nsec - nmea_now;
	np->time.tv.tv_sec = np->ts.tv_sec;
	np->time.tv.tv_usec = np->ts.tv_nsec / 1000L;

	if (fldcnt != 13)
		strlcpy(np->time.desc, "GPS", sizeof(np->time.desc));
	else if (fldcnt == 13 && *fld[12] != np->mode) {
		np->mode = *fld[12];
		switch (np->mode) {
		case 'S':
			strlcpy(np->time.desc, "GPS simulated",
			    sizeof(np->time.desc));
			break;
		case 'E':
			strlcpy(np->time.desc, "GPS estimated",
			    sizeof(np->time.desc));
			break;
		case 'A':
			strlcpy(np->time.desc, "GPS autonomous",
			    sizeof(np->time.desc));
			break;
		case 'D':
			strlcpy(np->time.desc, "GPS differential",
			    sizeof(np->time.desc));
			break;
		case 'N':
			strlcpy(np->time.desc, "GPS invalid",
			    sizeof(np->time.desc));
			break;
		default:
			strlcpy(np->time.desc, "GPS unknown",
			    sizeof(np->time.desc));
			DPRINTF(("gprmc: unknown mode '%c'\n", np->mode));
		}
	}
	switch (*fld[2]) {
	case 'A':	/* The GPS has a fix, (re)arm the timeout. */
			/* XXX is 'D' also a valid state? */
		np->time.status = SENSOR_S_OK;
		np->signal.value = 1;
		np->signal.status = SENSOR_S_OK;
		np->latitude.status = SENSOR_S_OK;
		np->longitude.status = SENSOR_S_OK;
		np->time.flags &= ~SENSOR_FINVALID;
		np->latitude.flags &= ~SENSOR_FINVALID;
		np->longitude.flags &= ~SENSOR_FINVALID;
		break;
	case 'V':	/*
			 * The GPS indicates a warning status, do not add to
			 * the timeout, if the condition persist, the sensor
			 * will be degraded.  Signal the condition through
			 * the signal sensor.
			 */
		np->signal.value = 0;
		np->signal.status = SENSOR_S_CRIT;
		np->latitude.status = SENSOR_S_WARN;
		np->longitude.status = SENSOR_S_WARN;
		break;
	}
	if (nmea_degrees(&np->latitude.value, fld[3], *fld[4] == 'S' ? 1 : 0))
		np->latitude.status = SENSOR_S_WARN;
	if (nmea_degrees(&np->longitude.value,fld[5], *fld[6] == 'W' ? 1 : 0))
		np->longitude.status = SENSOR_S_WARN;

	if (jumped)
		np->time.status = SENSOR_S_WARN;
	if (np->time.status == SENSOR_S_OK)
		timeout_add_sec(&np->nmea_tout, TRUSTTIME);
	/*
	 * If tty timestamping is requested, but no PPS signal is present, set
	 * the sensor state to CRITICAL.
	 */
	if (np->no_pps)
		np->time.status = SENSOR_S_CRIT;
}

/*
 * Convert a nmea position in the form DDDMM.MMMM to an
 * angle sensor value (degrees*1000000)
 */
int
nmea_degrees(int64_t *dst, char *src, int neg)
{
	size_t ppos;
	int i, n;
	int64_t deg = 0, min = 0;
	char *p;

	while (*src == '0')
		++src;	/* skip leading zeroes */

	for (p = src, ppos = 0; *p; ppos++)
		if (*p++ == '.')
			break;

	if (*p == '\0')
		return (-1);	/* no decimal point */

	for (n = 0; *src && n + 2 < ppos; n++)
		deg = deg * 10 + (*src++ - '0');

	for (; *src && n < ppos; n++)
		min = min * 10 + (*src++ - '0');

	src++;		/* skip decimal point */

	for (; *src && n < (ppos + 4); n++)
		min = min * 10 + (*src++ - '0');

	for (i=0; i < 6 + ppos - n; i++)
		min *= 10;

	deg = deg * 1000000 + (min/60);

	*dst = neg ? -deg : deg;
	return (0);
}

/*
 * Convert a NMEA 0183 formatted date string to seconds since the epoch.
 * The string must be of the form DDMMYY.
 * Return 0 on success, -1 if illegal characters are encountered.
 */
int
nmea_date_to_nano(char *s, int64_t *nano)
{
	struct clock_ymdhms ymd;
	time_t secs;
	char *p;
	int n;

	/* make sure the input contains only numbers and is six digits long */
	for (n = 0, p = s; n < 6 && *p && *p >= '0' && *p <= '9'; n++, p++)
		;
	if (n != 6 || (*p != '\0'))
		return (-1);

	ymd.dt_year = 2000 + (s[4] - '0') * 10 + (s[5] - '0');
	ymd.dt_mon = (s[2] - '0') * 10 + (s[3] - '0');
	ymd.dt_day = (s[0] - '0') * 10 + (s[1] - '0');
	ymd.dt_hour = ymd.dt_min = ymd.dt_sec = 0;

	secs = clock_ymdhms_to_secs(&ymd);
	*nano = secs * 1000000000LL;
	return (0);
}

/*
 * Convert NMEA 0183 formatted time string to nanoseconds since midnight.
 * The string must be of the form HHMMSS[.[sss]] (e.g. 143724 or 143723.615).
 * Return 0 on success, -1 if illegal characters are encountered.
 */
int
nmea_time_to_nano(char *s, int64_t *nano)
{
	long fac = 36000L, div = 6L, secs = 0L, frac = 0L;
	char ul = '2';
	int n;

	for (n = 0, secs = 0; fac && *s && *s >= '0' && *s <= ul; s++, n++) {
		secs += (*s - '0') * fac;
		div = 16 - div;
		fac /= div;
		switch (n) {
		case 0:
			if (*s <= '1')
				ul = '9';
			else
				ul = '3';
			break;
		case 1:
		case 3:
			ul = '5';
			break;
		case 2:
		case 4:
			ul = '9';
			break;
		}
	}
	if (fac)
		return (-1);

	/* Handle the fractions of a second, up to a maximum of 6 digits. */
	div = 1L;
	if (*s == '.') {
		for (++s; div < 1000000 && *s && *s >= '0' && *s <= '9'; s++) {
			frac *= 10;
			frac += (*s - '0');
			div *= 10;
		}
	}

	if (*s != '\0')
		return (-1);

	*nano = secs * 1000000000LL + (int64_t)frac * (1000000000 / div);
	return (0);
}

/*
 * Degrade the sensor state if we received no NMEA sentences for more than
 * TRUSTTIME seconds.
 */
void
nmea_timeout(void *xnp)
{
	struct nmea *np = xnp;

	np->signal.value = 0;
	np->signal.status = SENSOR_S_CRIT;
	if (np->time.status == SENSOR_S_OK) {
		np->time.status = SENSOR_S_WARN;
		np->latitude.status = SENSOR_S_WARN;
		np->longitude.status = SENSOR_S_WARN;
		/*
		 * further degrade in TRUSTTIME seconds if no new valid NMEA
		 * sentences are received.
		 */
		timeout_add_sec(&np->nmea_tout, TRUSTTIME);
	} else {
		np->time.status = SENSOR_S_CRIT;
		np->latitude.status = SENSOR_S_CRIT;
		np->longitude.status = SENSOR_S_CRIT;
	}
}
@


1.44
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.43 2014/09/14 14:17:26 jsg Exp $ */
a36 3
int	nmeaopen(dev_t, struct tty *, struct proc *);
int	nmeaclose(struct tty *, int, struct proc *);
int	nmeainput(int, struct tty *);
@


1.43
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.42 2014/07/12 18:43:32 tedu Exp $ */
d137 1
a137 1
		free(np, M_DEVBUF, 0);
d154 1
a154 1
	free(np, M_DEVBUF, 0);
@


1.42
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.41 2014/03/21 21:54:14 andre Exp $ */
a22 1
#include <sys/proc.h>
@


1.41
log
@Fix missing brackets: longitude/latitude status set to critical every time
nmea_timeout() is triggered introduced in rev 1.37.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.40 2014/03/21 21:46:47 andre Exp $ */
d138 1
a138 1
		free(np, M_DEVBUF);
d155 1
a155 1
	free(np, M_DEVBUF);
@


1.40
log
@Some knf, no functional changes.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.39 2010/05/27 17:18:23 sthen Exp $ */
d557 1
a557 1
	} else
d561 1
@


1.39
log
@Switch the signal status "percent" sensor, which is currently
hardcoded(!), over to an "indicator" sensor type, value depending
on whether the GPS has fix.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.38 2010/04/23 03:44:44 miod Exp $ */
d91 1
d101 1
a101 1
		return ENODEV;
d103 1
a103 1
		return error;
d144 1
a144 1
	return error;
d160 1
a160 1
	return linesw[TTYDISC].l_close(tp, flags, p);
d233 1
a233 1
	return linesw[TTYDISC].l_rint(c, tp);
d433 1
a433 1
		return -1;	/* no decimal point */
d452 1
a452 1
	return 0;
d472 1
a472 1
		return -1;
d481 1
a481 1
	return 0;
d518 1
a518 1
		return -1;
d531 1
a531 1
		return -1;
d534 1
a534 1
	return 0;
@


1.38
log
@Remove unnecessary pointer dereference causing gcc2 to warn.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.37 2010/04/21 23:43:39 sthen Exp $ */
d112 1
a112 1
	np->signal.type = SENSOR_PERCENT;
d114 1
a114 2
	np->signal.flags = SENSOR_FINVALID;
	np->signal.value = 100000LL;
d373 1
d375 1
a379 1
		np->signal.flags &= ~SENSOR_FINVALID;
d389 2
a390 1
		np->signal.status = SENSOR_S_WARN;
d545 2
@


1.37
log
@Provide nmea(4) position information using the new angle sensor type.
Use SENSOR_FINVALID until we have good data, suggested by deraadt@@
"i am happy" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.36 2010/04/12 12:57:52 tedu Exp $ */
d439 1
a439 1
	*src++;		/* skip decimal point */
@


1.36
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.35 2009/06/02 21:17:35 ckuethe Exp $ */
d57 2
d82 2
a83 4
#if NMEA_POS_IN_DESC
/* longitude and latitude formatting and copying */
void	nmea_degrees(char *dst, char *src, int neg, size_t len);
#endif
d109 1
d114 1
d119 14
a371 6
#if NMEA_POS_IN_DESC
	nmea_degrees(np->time.desc, fld[3], *fld[4] == 'S' ? 1 : 0,
	    sizeof(np->time.desc));
	nmea_degrees(np->time.desc, fld[5], *fld[6] == 'W' ? 1 : 0,
	    sizeof(np->time.desc));
#endif
d376 6
d390 2
d394 4
d411 6
a416 4
#ifdef NMEA_POS_IN_DESC
/* format a nmea position in the form DDDMM.MMMM to DDDdMM.MMm */
void
nmea_degrees(char *dst, char *src, int neg, size_t len)
d418 3
a420 2
	size_t dlen, ppos, rlen;
	int n;
a422 3
	for (dlen = 0; *dst; dlen++)
		dst++;

d431 1
a431 1
		return;	/* no decimal point */
d433 13
a445 18
	/*
	 * we need at least room for a comma, an optional '-', the src data up
	 * to the decimal point, the decimal point itself, two digits after
	 * it and some additional characters:  an optional leading '0' in case
	 * there a no degrees in src, the 'd' degrees indicator, the 'm'
	 * minutes indicator and the terminating NUL character.
	 */
	rlen = dlen + ppos + 7;
	if (neg)
		rlen++;
	if (ppos < 3)
		rlen++;
	if (len < rlen)
		return;		/* not enough room in dst */

	*dst++ = ',';
	if (neg)
		*dst++ = '-';
d447 1
a447 2
	if (ppos < 3)
		*dst++ = '0';
d449 2
a450 10
	for (n = 0; *src && n + 2 < ppos; n++)
		*dst++ = *src++;
	*dst++ = 'd';
	if (ppos == 0)
		*dst++ = '0';

	for (; *src && n < (ppos + 3); n++)
		*dst++ = *src++;
	*dst++ = 'm';
	*dst = '\0';
a451 1
#endif
d546 2
d555 2
@


1.35
log
@Add some extra protection against non-monotonic timestamps. ok stevesk
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.34 2009/04/26 02:25:36 cnst Exp $ */
d38 2
a39 2
int	nmeaopen(dev_t, struct tty *);
int	nmeaclose(struct tty *, int);
d94 1
a94 1
nmeaopen(dev_t dev, struct tty *tp)
a95 1
	struct proc *p = curproc;
d120 1
a120 1
	error = linesw[TTYDISC].l_open(dev, tp);
d132 1
a132 1
nmeaclose(struct tty *tp, int flags)
d144 1
a144 1
	return linesw[TTYDISC].l_close(tp, flags);
@


1.34
log
@don't zero sensor .value and .flags immediately after the allocation w/ M_ZERO; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.33 2008/12/25 21:25:55 stevesk Exp $ */
d181 1
a181 1
	
d287 1
d304 1
a304 1
		return;
a366 1
		timeout_add_sec(&np->nmea_tout, TRUSTTIME);
d378 4
@


1.33
log
@don't need #include <sys/queue.h>; ok mbalmer@@
CVS ---------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.32 2008/12/25 21:04:36 stevesk Exp $ */
a109 1
	np->time.value = 0LL;
a114 1
	np->signal.flags = 0;
@


1.32
log
@spelling in comments; ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.31 2008/09/10 14:01:23 blambert Exp $ */
a22 1
#include <sys/queue.h>
@


1.31
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.30 2008/07/22 06:06:47 mbalmer Exp $ */
d382 1
a382 1
	 * If tty timestamping is requested, but not PPS signal is present, set
@


1.30
log
@deactivate the code to display location in the sensor description
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.29 2008/07/07 08:01:47 mbalmer Exp $ */
a52 1
static int t_trust;
a98 1
	struct timeval t;
a130 5

		/* convert timevals to hz */
		t.tv_sec = TRUSTTIME;
		t.tv_usec = 0;
		t_trust = tvtohz(&t);
d313 1
a313 1
		timeout_add(&np->nmea_tout, t_trust);
d369 1
a369 1
		timeout_add(&np->nmea_tout, t_trust);
d543 1
a543 1
		timeout_add(&np->nmea_tout, t_trust);
@


1.29
log
@Shorten the sensor description and reserve room for optional characters
only when they are needed.  Makes locations like -123d45m,-123d45m fit.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.28 2008/07/06 21:03:13 mbalmer Exp $ */
d82 1
d85 1
d341 1
a341 1
			strlcpy(np->time.desc, "GPS sim", /* simulated */
d345 1
a345 1
			strlcpy(np->time.desc, "GPS est", /* estimated */
d349 1
a349 1
			strlcpy(np->time.desc, "GPS aut", /* autonomous */
d353 1
a353 1
			strlcpy(np->time.desc, "GPS dif", /* differential */
d357 1
a357 1
			strlcpy(np->time.desc, "GPS inv", /* not valid */
d361 1
a361 1
			strlcpy(np->time.desc, "GPS unk", /* unknown */
d366 1
d371 1
a371 1

d396 1
d451 1
@


1.28
log
@Add the position to the sensor description.

discussed with otto, sthen, ckuethe.  ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.27 2008/06/11 17:11:36 mbalmer Exp $ */
d339 1
a339 1
			strlcpy(np->time.desc, "GPS simulated",
d343 1
a343 1
			strlcpy(np->time.desc, "GPS estimated",
d347 1
a347 1
			strlcpy(np->time.desc, "GPS autonomous",
d351 1
a351 1
			strlcpy(np->time.desc, "GPS differential",
d355 1
a355 1
			strlcpy(np->time.desc, "GPS not valid",
d359 1
a359 1
			strlcpy(np->time.desc, "GPS unknown",
d397 1
a397 1
	size_t dlen, ppos;
d421 6
a426 1
	if (len < (dlen + ppos + 9))
@


1.27
log
@Don't use the reference count to create the sensor name; we can end up
with sensors with the same name.  The sensor name is now ever increasing
unless the reference count drops to zero, in which case the naming restarts
at zero as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.26 2008/05/05 19:57:01 mbalmer Exp $ */
d82 3
d364 4
d391 50
@


1.26
log
@Make nmea(4) behave like the other timedelta sensors and provide a
signal sensor that reflects the status of the receiver.

tested by and ok ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.25 2008/01/28 20:32:50 stevesk Exp $ */
d52 1
a52 1
int nmea_count;	/* this is wrong, it should really be a SLIST */
d104 2
a105 1
	    nmea_count++);
d148 2
@


1.25
log
@spelling in comment; ok mbalmer@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.24 2007/11/27 10:06:55 mbalmer Exp $ */
d4 1
a4 1
 * Copyright (c) 2006, 2007 Marc Balmer <mbalmer@@openbsd.org>
d58 1
d109 8
d362 1
d368 2
a369 1
			 * will be degraded.
d371 1
a371 2
			/* FALLTHROUGH */
	default:
@


1.24
log
@Only checksum the NMEA sentence if it as GPRMC message.
suggested by otto.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.23 2007/11/26 19:14:38 mbalmer Exp $ */
d68 1
a68 1
	int			pos;		/* positon in rcv buffer */
@


1.23
log
@Degrade the timedelta if the GPS reports a warning condition for more than
ten minutes (or if a serial GPS is disconnect and we get no NMEA sentences
at all).

ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.22 2007/09/07 15:00:20 art Exp $ */
d245 4
d272 1
a272 4

	/* check message type */
	if (!strcmp(fld[0], "GPRMC"))
		nmea_gprmc(np, tp, fld, fldcnt);
@


1.22
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.21 2007/03/22 16:55:31 deraadt Exp $ */
d44 7
a50 2
#define NMEAMAX	82
#define MAXFLDS	32
d53 1
d61 1
d81 3
d94 1
d101 1
a101 1
	np = malloc(sizeof(struct nmea), M_DEVBUF, M_WAITOK|M_ZERO);
d106 1
a106 1
	np->time.flags = SENSOR_FINVALID;
d115 1
a115 1
	} else
d117 7
d133 1
d141 1
a141 1
/* collect NMEA sentence from tty */
d214 1
a214 1
/* Scan the NMEA sentence just received */
d274 1
a274 1
/* Decode the recommended minimum specific GPS/TRANSIT data */
d300 4
d316 4
a319 7
	if (np->time.status == SENSOR_S_UNKNOWN) {
		np->time.status = SENSOR_S_OK;
		np->time.flags &= ~SENSOR_FINVALID;
		if (fldcnt != 13)
			strlcpy(np->time.desc, "GPS", sizeof(np->time.desc));
	}
	if (fldcnt == 13 && *fld[12] != np->mode) {
d348 1
d350 1
a350 1
	case 'A':
d352 1
d354 7
a360 2
	case 'V':
		np->time.status = SENSOR_S_WARN;
a361 2
	default:
		DPRINTF(("gprmc: unknown warning indication\n"));
d452 20
@


1.21
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.20 2007/03/20 20:14:29 deraadt Exp $ */
d90 1
a90 2
	np = malloc(sizeof(struct nmea), M_DEVBUF, M_WAITOK);
	bzero(np, sizeof(*np));
@


1.20
log
@swiss spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.19 2007/03/19 06:37:01 mbalmer Exp $ */
d51 2
a52 2
	struct sensor		time;		/* the timedelta sensor */
	struct sensordev	timedev;
@


1.19
log
@Change the way the nmea(4) line discipline takes the timestamp for
the timedelta sensor when no PPS signal is available.

Previously, the timestamp was taken at the leading '$' character
of a GPRMC message, which was not always correct, as some GPS units
send other messages first; we do not know when the GPRMC message
is sent within a data block (we refer to a data block as the set
of NMEA messages that are sent by a GPS unit in one go, usually
once per second).

nmea(4) now takes the timestamp at the first '$' character received
after the start of a new seconds.  Since GPS units transmit a data
block every second, the first message can be found by measuring the
gap between consecutive messages:  after the longest gap, the first
message of the next second follows.  And it is at the leading '$'
character of this message that we take the timestamp.

$GPGGA,.....    <- take timestamp here
$GPGSA,.....
$GPRMC,.....    <- decode time here
...             <- possibly more messages
		<- longer gap till start of next second
$GPGGA,.....	<- it starts all over, take next timestamp

This code has been designed to work independent of the baudrate and
the rate at which the GPS sends out it's data blocks (usually 1 Hz,
but 5 Hz units are common as well):

With this change, precision is greatly improved in the absence of a
PPS signal and as a side effect, jitter is reduced.

Note that while this is much better than before, there is still a
slight offset to the real time, as calculating the fix in the GPS unit
and transmitting the '$' character takes a short, but unpredictable
amount of time.

When tty timestamping is enabled, but there is no PPS signal available,
the sensor status will be degraded to CRITICAL, which means "check your
hardware".

Thanks to Chris Kuethe for testing and feedback.  ok ckuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.18 2007/03/05 10:23:16 mbalmer Exp $ */
d413 1
a413 1
	/* Handle the fractions of a second, up to a maxmimum of 6 digits. */
@


1.18
log
@If tty-timestamping is requested, but no PPS signal is present, output a
warning message and unconditionally set the sensor state to WARNING.

discussed with otto, ckuethe; ok otto, "i like it" ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.17 2007/01/02 22:43:29 mbalmer Exp $ */
d4 1
a4 1
 * Copyright (c) 2006 Marc Balmer <mbalmer@@openbsd.org>
d19 1
a19 1
/* line discipline to decode NMEA 0183 data */
d45 1
a45 1
#define MAXFLDS	16
d47 1
a47 1
int nmea_count;
d50 6
a55 2
	char		cbuf[NMEAMAX];
	struct sensor	time;
d57 1
a57 1
	struct sensor	skew;		/* soft to tty timestamp skew */
d59 5
a63 8
	struct sensordev timedev;
	struct timespec	ts;		/* soft timestamp */
	struct timeval	tv;		/* tty timestamp */
	int64_t		last;		/* last time rcvd */
	int		sync;
	int		pos;
	int		no_pps;		/* tty timestamping on, but no PPS */
	char		mode;		/* GPS mode */
d82 1
a82 1
	struct proc *p = curproc;	/* XXX */
a97 8
#ifdef NMEA_DEBUG
	snprintf(np->skew.desc, sizeof(np->skew.desc),
	    "nmea%d timestamp skew", nmea_count - 1);
	np->skew.status = SENSOR_S_UNKNOWN;
	np->skew.type = SENSOR_TIMEDELTA;
	np->skew.flags = SENSOR_FINVALID;
	sensor_attach(&np->timedev, &np->skew);
#endif
d128 2
d134 23
a156 7
		/*
		 * Capture the moment, take a soft timestamp in any case,
		 * it is possible that tty timestamping has been requested
		 * but device does not provide a PPS signal.  In this
		 * case we use the soft timestamp later.
		 */
		nanotime(&np->ts);
d159 5
a163 3
		 * reasonable by comparing against the "soft"-timestamp.  If
		 * they differ by more than 2 seconds, assume no PPS signal
		 * is present.
d169 1
a169 7
			DPRINTF(("tmax %ld, tmin %ld, diff %ld\n", tmax, tmin,
			    tmax - tmin));
			if (tmax - tmin > 1) {
				if (!np->no_pps)
					printf("nmea%d: tty timestamping "
					    "enabled, but no PPS signal\n",
					    nmea_count - 1);
d171 4
a174 6
			} else {
				np->tv.tv_sec = tp->t_tv.tv_sec;
				np->tv.tv_usec = tp->t_tv.tv_usec;
				if (np->no_pps)
					printf("nmea%d: PPS signal ok\n",
					    nmea_count - 1);
a177 2
		np->pos = 0;
		np->sync = 0;
a191 1

d203 1
a203 1
	/* split into fields and calc checksum */
d246 1
a246 1
			DPRINTF(("cksum mismatch\n"));
d280 1
a280 12

	/*
	 * if tty timestamping on DCD or CTS is used, take the timestamp
	 * from the tty, else use the timestamp taken on the initial '$'
	 * character.
	 */
	if (!np->no_pps && (tp->t_flags & (TS_TSTAMPDCDSET | TS_TSTAMPDCDCLR |
	    TS_TSTAMPCTSSET | TS_TSTAMPCTSCLR))) {
		np->time.value = np->ts.tv_sec * 1000000000LL +
		    np->ts.tv_nsec - nmea_now;
		np->time.tv.tv_sec = np->ts.tv_sec;
		np->time.tv.tv_usec = np->ts.tv_nsec / 1000L;
d282 6
a287 13
		/*
		 * If we got a tty timestamp, provide the skew to the
		 * soft timestamp (taken at the '$' character) in a
		 * second timedelta sensor.
		 */
		np->skew.value = (np->ts.tv_sec * 1000000000LL +
		    np->ts.tv_nsec - nmea_now) - np->time.value;
		np->skew.tv.tv_sec = np->tv.tv_sec;
		np->skew.tv.tv_usec = np->tv.tv_usec;
		if (np->skew.status == SENSOR_S_UNKNOWN) {
			np->skew.status = SENSOR_S_CRIT;
			np->skew.flags &= ~SENSOR_FINVALID;
		}
d289 5
a293 13
	} else {
		np->time.value = np->ts.tv_sec * 1000000000LL +
		    np->ts.tv_nsec - nmea_now;
		np->time.tv.tv_sec = np->ts.tv_sec;
		np->time.tv.tv_usec = np->ts.tv_nsec / 1000L;
#ifdef NMEA_DEBUG
		if (np->skew.status == SENSOR_S_CRIT) {
			np->skew.value = 0LL;
			np->skew.value = SENSOR_S_UNKNOWN;
			np->skew.flags |= SENSOR_FINVALID;
		}
#endif
	}
d341 2
a342 2
	 * if tty timestamping is on, but not PPS signal is present, set
	 * the sensor state to WARNING.
d345 1
a345 1
		np->time.status = SENSOR_S_WARN;
d349 3
a351 3
 * convert a NMEA 0183 formatted date string to seconds since the epoch
 * the string must be of the form DDMMYY
 * return 0 on success, -1 if illegal characters are encountered
d378 3
a380 4
 * convert NMEA 0183 formatted time string to nanoseconds since midnight
 * the string must be of the form HHMMSS[.[sss]]
 * (e.g. 143724 or 143723.615)
 * return 0 on success, -1 if illegal characters are encountered
d385 1
a385 1
	long fac = 36000L, div = 6L, secs = 0L, frac;
d413 1
a414 2
	frac = 0L;
	/* handle fractions of a second, max. 6 digits */
@


1.17
log
@return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.16 2006/12/23 17:46:38 deraadt Exp $ */
d61 1
d135 1
d146 6
a151 1
		/* if a tty timestamp is available, copy it now */
d154 18
a171 2
			np->tv.tv_sec = tp->t_tv.tv_sec;
			np->tv.tv_usec = tp->t_tv.tv_usec;
d284 6
a289 6
	if (tp->t_flags & (TS_TSTAMPDCDSET | TS_TSTAMPDCDCLR |
	    TS_TSTAMPCTSSET | TS_TSTAMPCTSCLR)) {
		np->time.value = np->tv.tv_sec * 1000000000LL +
		    np->tv.tv_usec * 1000LL - nmea_now;
		np->time.tv.tv_sec = np->tv.tv_sec;
		np->time.tv.tv_usec = np->tv.tv_usec;
d363 7
@


1.16
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.15 2006/12/23 08:29:39 mbalmer Exp $ */
d85 1
a85 1
		return (ENODEV);
d87 1
a87 1
		return (error);
d113 1
a113 1
	return (error);
d345 1
a345 1
 * return (0) on success, (-1) if illegal characters are encountered
d359 1
a359 1
		return (-1);
d368 1
a368 1
	return (0);
d375 1
a375 1
 * return (0) on success, (-1) if illegal characters are encountered
d406 1
a406 1
		return (-1);
d420 1
a420 1
		return (-1);
d423 1
a423 1
	return (0);
@


1.15
log
@in nmeaopen(), only add the sensors to the system if there was no error.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.14 2006/12/15 16:49:39 mbalmer Exp $ */
d55 1
d90 1
a90 1
	snprintf(np->time.device, sizeof(np->time.device), "nmea%d",
d95 1
a96 2
	snprintf(np->skew.device, sizeof(np->skew.device), "skew%d",
	    nmea_count - 1);
d102 1
d111 2
a112 6
	} else {
		sensor_add(&np->time);
#ifdef NMEA_DEBUG
		sensor_add(&np->skew);
#endif
	}
d122 1
a122 4
	sensor_del(&np->time);
#ifdef NMEA_DEBUG
	sensor_del(&np->skew);
#endif
@


1.14
log
@Correct order of malloc(9) arguments.
Spotted by  Constantine A. Murenin <cnst+openbsd@@bugmail.mojo.ru>; thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.13 2006/11/29 13:26:50 mbalmer Exp $ */
a93 1
	sensor_add(&np->time);
a101 1
	sensor_add(&np->skew);
d110 5
@


1.13
log
@Update the sensor description based on the GPS operation mode.  Initial
diff received from matthieu.
ok matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.12 2006/11/28 17:20:25 mbalmer Exp $ */
d87 1
a87 1
	np = malloc(sizeof(struct nmea), M_WAITOK, M_DEVBUF);
@


1.12
log
@Let nmea(4) use tty timestamps if they are enabled.  Using a GPS receiver
that provides a PPS signal, more precision and less jitter can be expected.
With my test setting (a Garmin GPS 18 LVC hooked up to a i386 machine) I
observed a skew of 0.03 to 0.05 seconds between the tty timestamp and the soft
timestamp.

"put it in" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.11 2006/11/18 08:20:51 jmc Exp $ */
d60 1
a298 25
		strlcpy(np->time.desc, "GPS", sizeof(np->time.desc));
		if (fldcnt == 13) {
			switch (*fld[12]) {
			case 'S':
				strlcat(np->time.desc, " simulated",
				    sizeof(np->time.desc));
				break;
			case 'E':
				strlcat(np->time.desc, " estimated",
				    sizeof(np->time.desc));
				break;
			case 'A':
				strlcat(np->time.desc, " autonomous",
				    sizeof(np->time.desc));
				break;
			case 'D':
				strlcat(np->time.desc, " differential",
				    sizeof(np->time.desc));
				break;
			case 'N':
				strlcat(np->time.desc, " not valid",
				    sizeof(np->time.desc));
				break;
			}
		}
d301 31
@


1.11
log
@typos; from bret lambert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.10 2006/06/21 06:24:50 mbalmer Exp $ */
d52 3
a91 1
	np->sync = 1;
d94 11
d122 3
a145 1
#ifdef NMEA_TSTAMP
a151 1
#endif
d223 1
a223 1
			DPRINTF(("cksum mismatch"));
a237 7
#ifdef NMEA_DEBUG
	int n;

	for (n = 0; n < fldcnt; n++)
		DPRINTF(("%s ", fld[n]));
	DPRINTF(("\n"));
#endif
a257 1
#ifdef NMEA_TSTAMP
d265 1
a265 1
		np->time.value = np->tv.tv_sec + 1000000000LL +
d269 15
a284 1
#endif
d289 7
a295 1
#ifdef NMEA_TSTAMP
a296 1
#endif
@


1.10
log
@If tty timestamping is enabled, copy the tty timestamp early to preserve
the value if it gets overwritten by other events.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.9 2006/06/20 14:06:21 deraadt Exp $ */
d124 1
a124 1
		 * capture the moment, take a soft timestamp in any case,
d126 1
a126 1
		 * but device device does not privide a PPS signal.  In this
@


1.9
log
@pruning; ok mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.8 2006/06/19 16:27:17 mbalmer Exp $ */
d52 3
a54 2
	struct timespec	ts;
	int64_t		last;			/* last time rcvd */
d123 6
a128 1
		/* capture the moment */
d130 8
d259 4
a262 4
		np->time.value = tp->t_tv.tv_sec + 1000000000LL +
		    tp->t_tv.tv_usec * 1000LL - nmea_now;
		np->time.tv.tv_sec = tp->t_tv.tv_sec;
		np->time.tv.tv_usec = tp->t_tv.tv_usec;
@


1.8
log
@Remove the no longer needed date/time calculations.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.7 2006/06/13 07:01:59 mbalmer Exp $ */
d47 1
a47 1
int nmea_count = 0;
d92 1
a92 1
	
d149 2
a150 8
	char *fld[MAXFLDS];
	char *cs;
	int fldcnt;
	int cksum, msgcksum;
	int n;

	fldcnt = 0;
	cksum = 0;
d337 2
a338 2
	long fac, div;
	long secs, frac;
a339 5
	char ul;

	fac = 36000L;
	div = 6L;
	secs = 0L;
a340 1
	ul = '2';
@


1.7
log
@Next round of clean-up:  Remove the ugly state machine and replace it with
a simpler function that splits the nmea sentence into fields, verifies the
checksum and eventually decodes the data (if it's a GPRMC sentence).
Ignore Loran-C for the moment, no one has such a receiver.  Loran-C can
easily be added later if we have a receiver to test with.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.6 2006/06/10 23:15:26 mbalmer Exp $ */
d29 1
a38 12
/* Traditional POSIX base year */
#define	POSIX_BASE_YEAR	1970

static inline int leapyear(int year);
#define FEBRUARY	2
#define	days_in_year(a) 	(leapyear(a) ? 366 : 365)
#define	days_in_month(a) 	(month_days[(a) - 1])

static const int month_days[12] = {
	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

d59 2
a60 2
void	nmea_scan(struct nmea *);
void	nmea_gprmc(struct nmea *, char *fld[], int fldcnt);
a64 2
static inline int leapyear(int year);
int	nmea_ymd_to_secs(int year, int month, int day, time_t *secs);
d122 1
a122 1
		/* timestamp and delta refs now */
d131 1
a131 1
			nmea_scan(np);
d147 1
a147 1
nmea_scan(struct nmea *np)
d208 1
a208 1
		nmea_gprmc(np, fld, fldcnt);
d211 1
a211 1
/* Decode the minimum recommended nav info sentence (RMC) */
d213 1
a213 1
nmea_gprmc(struct nmea *np, char *fld[], int fldcnt)
d242 22
a263 4
	np->time.value = np->ts.tv_sec * 1000000000LL + np->ts.tv_nsec -
	    nmea_now;
	np->time.tv.tv_sec = np->ts.tv_sec;
	np->time.tv.tv_usec = np->ts.tv_nsec / 1000L;
d313 1
a315 1
	int year, month, day;
d324 4
a327 3
	year = 2000 + (s[4] - '0') * 10 + (s[5] - '0');
	month = (s[2] - '0') * 10 + (s[3] - '0');
	day = (s[0] - '0') * 10 + (s[1] - '0');
d329 1
a329 2
	if (nmea_ymd_to_secs(year, month, day, &secs))
		return (-1);
a391 100
	return (0);
}

/*
 * the leapyear() and nmea_ymd_to_secs() functions to calculate the number
 * of seconds since the epoch for a certain date are from sys/dev/clock_subr.c,
 * the following copyright applies to these functions:
 */
/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * This inline avoids some unnecessary modulo operations
 * as compared with the usual macro:
 *   ( ((year % 4) == 0 &&
 *      (year % 100) != 0) ||
 *     ((year % 400) == 0) )
 * It is otherwise equivalent.
 */
static inline int
leapyear(int year)
{
	int rv = 0;

	if ((year & 3) == 0) {
		rv = 1;
		if ((year % 100) == 0) {
			rv = 0;
			if ((year % 400) == 0)
				rv = 1;
		}
	}
	return (rv);
}

/* convert year, month, day to seconds since the epoch */
int
nmea_ymd_to_secs(int year, int month, int day, time_t *secs)
{
	int i, days;
	int leap;

	if (month < 1 || month > 12)
		return (-1);

	days = days_in_month(month);
	leap = leapyear(year);
	if (month == FEBRUARY && leap)
		days++;
	if (day < 1 || day > days)
		return (-1);

	/*
	 * Compute days since start of time
	 * First from years, then from months.
	 */
	days = 0;
	for (i = POSIX_BASE_YEAR; i < year; i++)
		days += days_in_year(i);
	if (leap && month > FEBRUARY)
		days++;

	/* Months */
	for (i = 1; i < month; i++)
	  	days += days_in_month(i);
	days += (day - 1);

	/* convert to seconds. */
	*secs = days * 86400L;
@


1.6
log
@Add functions to decode date and time strings that make sure no invalid
information can be passed.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.5 2006/06/05 05:01:47 deraadt Exp $ */
d19 1
a19 1
/* line discipline to decode NMEA0183 data */
d56 1
a56 13
#define MAXFLDS	12

/* NMEA talker identifiers */
#define TI_UNK	0
#define TI_GPS	1
#define TI_LORC	2

/* NMEA message types */
#define MSG_RMC	5393731	/* recommended minimum sentence C */
#define MSG_GGA	4671297
#define MSG_GSA	4674369	/* satellites active */
#define MSG_GSV	4674390	/* satellites in view */
#define MSG_VTG	5657671	/* velocity, direction, speed */
a62 1
	struct timeval	tv;			/* soft timestamp */
d65 1
a65 1
	int		state;			/* state we're in */
a66 7
	int		fpos[MAXFLDS];
	int		flds;			/* expect nr of fields */
	int		fldcnt;			/* actual count of fields */
	int		cksum;			/* calculated checksum */
	int		msgcksum;		/* received cksum */
	int		ti;			/* talker identifier */
	int		msg;			/* NMEA msg type */
a68 3
/* NMEA protocol state machine */
void	nmea_hdlr(struct nmea *, int c);

d70 2
a71 2
void	nmea_decode(struct nmea *);
void	nmea_rmc(struct nmea *);
a78 12
/* helper functions */
void	nmea_bufadd(struct nmea *, int);

enum states {
	S_SYNC = 0,
	S_TI_1,
	S_TI_2,
	S_MSG,
	S_DATA,
	S_CKSUM
};

d101 1
a101 1
	np->state = S_SYNC;
d127 1
a127 1
/* scan input from tty for NMEA sentences */
d133 20
a152 1
	nmea_hdlr(np, c);
d158 1
a158 1
/* NMEA state machine */
d160 1
a160 1
nmea_hdlr(struct nmea *np, int c)
d162 13
a174 67
	switch (np->state) {
	case S_SYNC:
		switch (c) {
		case '$':
			/* timestamp and delta refs now */
			microtime(&np->tv);
			nanotime(&np->ts);
			np->pos = 0;
			np->fldcnt = 0;
			np->flds = 0;
			np->cbuf[np->pos++] = c;
			np->cksum = 0;
			np->msgcksum = -1;
			np->ti = TI_UNK;
			np->state = S_TI_1;
		}
		break;
	case S_TI_1:
		nmea_bufadd(np, c);
		np->state = S_TI_2;
		switch (c) {
		case 'G':
			np->ti = TI_GPS;
			break;
		case 'L':
			np->ti = TI_LORC;
			break;
		default:
			np->state = S_SYNC;
		}
		break;
	case S_TI_2:
		nmea_bufadd(np, c);
		np->state = S_SYNC;
		switch (c) {
		case 'P':
			if (np->ti == TI_GPS)
				np->state = S_MSG;
			break;
		case 'C':
			if (np->ti == TI_LORC)
				np->state = S_MSG;
			break;
		}
		break;
	case S_MSG:
		nmea_bufadd(np, c);
		if (np->pos == 6) {
			np->msg = (np->cbuf[3] << 16) + (np->cbuf[4] << 8) +
			    np->cbuf[5];
			switch (np->msg) {
			case MSG_RMC:
				np->flds = 12;	/* or 11 */
				np->state = S_DATA;
				break;
			default:
				np->state = S_SYNC;
			}
		}
		break;
	case S_DATA:
		switch (c) {
		case '\n':
			np->cbuf[np->pos] = '\0';
			nmea_decode(np);
			np->state = S_SYNC;
			break;
d176 2
a177 3
			np->cbuf[np->pos++] = c;
			np->msgcksum = 0;
			np->state = S_CKSUM;
d180 9
a188 15
			np->fpos[np->fldcnt++] = np->pos + 1;
		default:
			if (np->pos < NMEAMAX)
				nmea_bufadd(np, c);
			else
				np->state = S_SYNC;
		}
		break;
	case S_CKSUM:
		switch (c) {
		case '\r':
		case '\n':
			np->cbuf[np->pos] = '\0';
			nmea_decode(np);
			np->state = S_SYNC;
d191 1
a191 11
			if (np->pos < NMEAMAX && ((c >= '0' && c<= '9') ||
			    (c >= 'A' && c <= 'F'))) {
				np->cbuf[np->pos++] = c;
				if (np->msgcksum)
					np->msgcksum <<= 4;
				if (c >= '0' && c<= '9')
					np->msgcksum += c - '0';
				else if (c >= 'A' && c <= 'F')
					np->msgcksum += 10 + c - 'A';
			} else
				np->state = S_SYNC;
a192 1
		break;
a193 1
}
d195 22
a216 7
/* add a character to the buffer and update the checksum */
void
nmea_bufadd(struct nmea *np, int c)
{
	if (np->pos < NMEAMAX){
		np->cbuf[np->pos++] = c;
		np->cksum ^= c;
a217 1
}
d219 3
a221 8
void
nmea_decode(struct nmea *np)
{
	switch (np->msg) {
	case MSG_RMC:
		nmea_rmc(np);
		break;
	}
d226 1
a226 1
nmea_rmc(struct nmea *np)
d229 2
d232 7
a238 6
	if (np->fldcnt != 11 && np->fldcnt != 12) {
		DPRINTF(("field count mismatch\n"));
		return;
	}
	if (np->msgcksum >= 0 && np->cksum != np->msgcksum) {
		DPRINTF(("checksum error"));
d241 2
a242 2
	if (nmea_time_to_nano(&np->cbuf[7], &time_nano)) {
		DPRINTF(("illegal time"));
d245 2
a246 2
	if (nmea_date_to_nano(&np->cbuf[np->fpos[8]], &date_nano)) {
		DPRINTF(("illegal date"));
d251 1
a251 1
		DPRINTF(("time not monotonically increasing\n"));
d257 2
a258 2
	np->time.tv.tv_sec = np->tv.tv_sec;
	np->time.tv.tv_usec = np->tv.tv_usec;
d260 3
a262 4
		strlcpy(np->time.desc, np->ti == TI_GPS ? "GPS" :
		    "Loran-C", sizeof(np->time.desc));
		if (np->fldcnt == 12) {
			switch (np->cbuf[np->fpos[11]]) {
d288 1
a288 1
	switch (np->cbuf[np->fpos[1]]) {
d296 1
a296 1
		DPRINTF(("unknown warning indication\n"));
d301 1
a301 1
 * convert a NMEA0183 formatted date string to seconds since the epoch
d316 1
a316 1
	if (n != 6 || (*p != '\0' && *p != ','))
d330 1
a330 1
 * convert NMEA0183 formatted time string to nanoseconds since midnight
d383 1
a383 1
	if (*s != '\0' && *s != ',')
@


1.5
log
@various cleanups; ok mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.4 2006/06/04 09:52:40 mbalmer Exp $ */
a29 2
#include <dev/clock_subr.h>	/* clock_subr not avail on all arches */

d38 12
a58 1

a63 1

d77 1
a77 1
	time_t 		last;			/* last time rcvd */
d96 6
a102 1
int	nmea_atoi(char *, int *);
d162 1
a162 1
/* scan input from tty for NMEA telegrams */
a293 23
/*
 * convert a string to a number, stop at the first non-numerical
 * character or the end of the string.  any non-numerical character
 * following the number other than ',' is considered an error.
 */
int
nmea_atoi(char *s, int *num)
{
	int n;

	for (n = 0; *s && *s >= '0' && *s <= '9'; s++) {
		if (n)
			n *= 10;
		n += *s - '0';
	}

	if (*s && *s != ',')	/* no numeric character */
		return (-1);

	*num = n;
	return (0);
}

d308 1
a308 3
	struct clock_ymdhms ymdhms;
	time_t nmea_now;
	int n;
d318 2
a319 26
	np->cbuf[13] = '\0';
	if (nmea_atoi(&np->cbuf[11], &n)) {
		DPRINTF(("error in sec\n"));
		return;
	}
	ymdhms.dt_sec = n;
	np->cbuf[11] = 0;
	if (nmea_atoi(&np->cbuf[9], &n)) {
		DPRINTF(("error in min\n"));
		return;
	}
	ymdhms.dt_min = n;
	np->cbuf[9] = 0;
	if (nmea_atoi(&np->cbuf[7], &n)) {
		DPRINTF(("error in hour\n"));
		return;
	}
	ymdhms.dt_hour = n;
	if (nmea_atoi(&np->cbuf[np->fpos[8] + 4], &n)) {
		DPRINTF(("error in year\n"));
		return;
	}
	ymdhms.dt_year = 2000 + n;
	np->cbuf[np->fpos[8] + 4] = '\0';
	if (nmea_atoi(&np->cbuf[np->fpos[8] + 2], &n)) {
		DPRINTF(("error in month\n"));
d322 2
a323 4
	ymdhms.dt_mon = n;
	np->cbuf[np->fpos[8] + 2] = '\0';
	if (nmea_atoi(&np->cbuf[np->fpos[8]], &n)) {
		DPRINTF(("error in day\n"));
d326 1
a326 2
	ymdhms.dt_day = n;
	nmea_now = clock_ymdhms_to_secs(&ymdhms);
d332 2
a333 2
	np->time.value = (np->ts.tv_sec - nmea_now)
	    * 1000000000 + np->ts.tv_nsec;
d376 190
@


1.4
log
@- ntpd no longer needs the NTP identifier as part of a timedelta sensor
  description.
- create the timedelta sensors as early as possible, but mark them invalid
  as long as there is no real data.
- update docs accordingly
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.3 2006/06/01 23:17:08 ckuethe Exp $ */
d24 1
a81 1

a84 1

a88 1

d101 5
d109 1
d111 1
d113 19
a131 14
	if (tp->t_line != NMEADISC) {
		np = malloc(sizeof(struct nmea), M_WAITOK, M_DEVBUF);
		tp->t_sc = (caddr_t)np;

		snprintf(np->time.device, sizeof(np->time.device), "nmea%d",
		    nmea_count++);
		np->time.status = SENSOR_S_UNKNOWN;
		np->time.type = SENSOR_TIMEDELTA;
		np->time.value = 0LL;
		np->time.rfact = 0;
		np->time.flags = SENSOR_FINVALID;
		sensor_add(&np->time);
		np->state = S_SYNC;
		np->last = 0L;
d133 1
a133 2

	return linesw[0].l_open(dev, tp);
d141 1
a141 1
	tp->t_line = 0;	/* switch back to termios */
d144 1
d146 1
a146 1
	return linesw[0].l_close(tp, flags);
d158 1
a158 6
	return linesw[0].l_rint(c, tp);
}

void
nmeaattach(int dummy)
{
@


1.3
log
@Avoid buffer overflow in case of oversized input.
ok mbalmber
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_nmea.c,v 1.2 2006/06/01 22:32:46 ckuethe Exp $ */
d118 2
a119 1
		np->time.flags = 0;
d133 1
a133 2
	if (np->time.status != SENSOR_S_UNKNOWN)
		sensor_del(&np->time);
d371 2
a372 2
		strlcpy(np->time.desc, np->ti == TI_GPS ? "GPS  GPS" :
		    "LORC Loran-C", sizeof(np->time.desc));
d398 1
a398 1
		sensor_add(&np->time);
@


1.2
log
@mbalmer says the swiss have learned how to swim.

- fixed debug printfs
- cope with nmea0183 or nmea 2.3
- allow multiple receivers at the same time

Hacked in the park in downtown...

"commit this right away" mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d270 4
a273 2
	np->cbuf[np->pos++] = c;
	np->cksum ^= c;
@


1.1
log
@Add basic NMEA0183 support as a tty line discipline.  The line discipline
decodes NMEA messages completely transparent to userland applications, i.e.
userland can still use the NMEA stream and talk to the device.  If data
is received, a timedelta sensor suitable for ntpd is created.  The timestamp
is not very precise at the moment, use of this is experimental at best.

"get it in or we see how well the swiss people can swim" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD $*/
a61 1
time_t nmea_last = 0;
d68 1
d120 1
d212 1
a212 1
				np->flds = 12;
d315 2
a316 2
	if (np->fldcnt != np->flds) {
		DPRINTF("field count mismatch\n");
d320 1
a320 1
		DPRINTF("checksum error");
d325 1
a325 1
		DPRINTF("error in sec\n");
d331 1
a331 1
		DPRINTF("error in min\n");
d337 1
a337 1
		DPRINTF("error in hour\n");
d342 1
a342 1
		DPRINTF("error in year\n");
d348 1
a348 1
		DPRINTF("error in month\n");
d354 1
a354 1
		DPRINTF("error in day\n");
d359 2
a360 2
	if (nmea_now <= nmea_last) {
		DPRINTF("time not monotonically increasing\n");
d363 1
a363 1
	nmea_last = nmea_now;
d371 23
a393 21
		switch (np->cbuf[np->fpos[11]]) {
		case 'S':
			strlcat(np->time.desc, " simulated",
			    sizeof(np->time.desc));
			break;
		case 'E':
			strlcat(np->time.desc, " estimated",
			    sizeof(np->time.desc));
			break;
		case 'A':
			strlcat(np->time.desc, " autonomous",
			    sizeof(np->time.desc));
			break;
		case 'D':
			strlcat(np->time.desc, " differential",
			    sizeof(np->time.desc));
			break;
		case 'N':
			strlcat(np->time.desc, " not valid",
			    sizeof(np->time.desc));
			break;
d406 1
a406 1
		DPRINTF("unknown warning indication\n");
@

