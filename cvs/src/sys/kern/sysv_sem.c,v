head	1.53;
access;
symbols
	OPENBSD_6_2:1.53.0.8
	OPENBSD_6_2_BASE:1.53
	OPENBSD_6_1:1.53.0.10
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.53.0.6
	OPENBSD_6_0_BASE:1.53
	OPENBSD_5_9:1.53.0.2
	OPENBSD_5_9_BASE:1.53
	OPENBSD_5_8:1.53.0.4
	OPENBSD_5_8_BASE:1.53
	OPENBSD_5_7:1.52.0.2
	OPENBSD_5_7_BASE:1.52
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.44.0.4
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.44.0.2
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.43.0.2
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.2
	OPENBSD_5_0:1.41.0.4
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.2
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.40.0.6
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.40.0.4
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.33.0.6
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.33.0.4
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.32.0.8
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.6
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.32.0.4
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	SMP_SYNC_A:1.29
	SMP_SYNC_B:1.29
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.16.0.2
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.8
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.6
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.53
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.52;
commitid	p4LJxGKbi0BU2cG6;

1.52
date	2014.12.19.05.59.21;	author tedu;	state Exp;
branches;
next	1.51;
commitid	zdJTCwdpqRUwO1SL;

1.51
date	2014.12.10.02.44.47;	author tedu;	state Exp;
branches;
next	1.50;
commitid	tsoJBlEBSyYO22RG;

1.50
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.49;
commitid	jdBY2kKXhfcoQitp;

1.49
date	2014.07.13.15.29.04;	author tedu;	state Exp;
branches;
next	1.48;
commitid	bFFVdS3JEaMhyZxJ;

1.48
date	2014.07.13.15.00.40;	author tedu;	state Exp;
branches;
next	1.47;
commitid	7E1o7NIDvSyD48ls;

1.47
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.46;
commitid	QlVV51SZgNFxsXxC;

1.46
date	2014.03.18.06.59.00;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2013.11.25.23.15.58;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	2012.10.21.19.00.48;	author beck;	state Exp;
branches;
next	1.43;

1.43
date	2012.04.11.13.29.14;	author naddy;	state Exp;
branches;
next	1.42;

1.42
date	2012.01.10.23.12.13;	author bluhm;	state Exp;
branches;
next	1.41;

1.41
date	2011.02.02.09.33.11;	author fgsch;	state Exp;
branches;
next	1.40;

1.40
date	2009.06.02.12.11.16;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2009.05.16.23.00.45;	author thib;	state Exp;
branches;
next	1.38;

1.38
date	2009.04.03.04.22.49;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.15.22.54.21;	author oga;	state Exp;
branches;
next	1.36;

1.36
date	2008.05.23.20.14.45;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.14.23.08.04;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.10.17.03.48;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2004.07.15.11.24.46;	author millert;	state Exp;
branches
	1.32.6.1
	1.32.8.1;
next	1.31;

1.31
date	2004.07.14.23.40.27;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.03.17.38.48;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.17.19.54.24;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2004.03.17.18.04.08;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2004.03.13.07.17.39;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.20.19.06.29;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.17.20.40.57;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.03.19.03.42;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.11.20.22.22.35;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.09.18.57.36;	author tedu;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2003.08.20.18.02.20;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.17.21.56.25;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.03.01.52.41;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.07.00.34.41;	author millert;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2002.12.30.19.57.34;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.30.18.41.27;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.29.21.58.15;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.12.17.23.32.31;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.17.23.27.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.17.23.11.31;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.27.05;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.13.14.07.14;	author fgsch;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	2001.09.13.13.55.08;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.12.22.50.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.16.17.14.35;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.01.23.12.30;	author deraadt;	state Exp;
branches
	1.4.4.1
	1.4.6.1;
next	1.3;

1.3
date	98.06.11.18.32.16;	author deraadt;	state Exp;
branches
	1.3.8.1;
next	1.2;

1.2
date	96.03.03.17.20.06;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches;
next	;

1.3.8.1
date	2001.05.14.22.32.44;	author niklas;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2001.07.04.10.48.40;	author niklas;	state Exp;
branches;
next	1.3.8.3;

1.3.8.3
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.3.8.4;

1.3.8.4
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.3.8.5;

1.3.8.5
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.3.8.6;

1.3.8.6
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.3.8.7;

1.3.8.7
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	1.3.8.8;

1.3.8.8
date	2004.06.05.23.13.02;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2001.09.16.15.22.03;	author miod;	state Exp;
branches;
next	;

1.4.6.1
date	2001.10.14.20.44.49;	author jason;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;

1.16.2.1
date	2003.08.20.20.16.41;	author brad;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2003.09.10.15.38.01;	author brad;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2003.11.20.23.36.49;	author margarida;	state Exp;
branches;
next	;

1.21.2.1
date	2003.11.20.23.51.12;	author brad;	state Exp;
branches;
next	;

1.32.6.1
date	2006.08.19.19.56.51;	author brad;	state Exp;
branches;
next	;

1.32.8.1
date	2006.08.11.04.08.45;	author brad;	state Exp;
branches;
next	;


desc
@@


1.53
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: sysv_sem.c,v 1.52 2014/12/19 05:59:21 tedu Exp $	*/
/*	$NetBSD: sysv_sem.c,v 1.26 1996/02/09 19:00:25 christos Exp $	*/

/*
 * Copyright (c) 2002,2003 Todd C. Miller <Todd.Miller@@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
 */
/*
 * Implementation of SVID semaphores
 *
 * Author:  Daniel Boulet
 *
 * This software is provided ``AS IS'' without any warranties of any kind.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/sem.h>
#include <sys/sysctl.h>
#include <sys/malloc.h>
#include <sys/pool.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#ifdef SEM_DEBUG
#define DPRINTF(x)	printf x
#else
#define DPRINTF(x)
#endif

int	semtot = 0;
int	semutot = 0;
struct	semid_ds **sema;	/* semaphore id list */
SLIST_HEAD(, sem_undo) semu_list; /* list of undo structures */
struct	pool sema_pool;		/* pool for struct semid_ds */
struct	pool semu_pool;		/* pool for struct sem_undo (SEMUSZ) */
unsigned short *semseqs;	/* array of sem sequence numbers */

struct sem_undo *semu_alloc(struct process *);
int semundo_adjust(struct proc *, struct sem_undo **, int, int, int);
void semundo_clear(int, int);

void
seminit(void)
{

	pool_init(&sema_pool, sizeof(struct semid_ds), 0, 0, PR_WAITOK,
	    "semapl", NULL);
	pool_init(&semu_pool, SEMUSZ, 0, 0, PR_WAITOK, "semupl", NULL);
	sema = mallocarray(seminfo.semmni, sizeof(struct semid_ds *),
	    M_SEM, M_WAITOK|M_ZERO);
	semseqs = mallocarray(seminfo.semmni, sizeof(unsigned short),
	    M_SEM, M_WAITOK|M_ZERO);
	SLIST_INIT(&semu_list);
}

/*
 * Allocate a new sem_undo structure for a process
 * (returns ptr to structure or NULL if no more room)
 */
struct sem_undo *
semu_alloc(struct process *pr)
{
	struct sem_undo *suptr, *sutmp;

	if (semutot == seminfo.semmnu)
		return (NULL);		/* no space */

	/*
	 * Allocate a semu w/o waiting if possible.
	 * If we do have to wait, we must check to verify that a semu
	 * with un_proc == pr has not been allocated in the meantime.
	 */
	semutot++;
	if ((suptr = pool_get(&semu_pool, PR_NOWAIT)) == NULL) {
		sutmp = pool_get(&semu_pool, PR_WAITOK);
		SLIST_FOREACH(suptr, &semu_list, un_next) {
			if (suptr->un_proc == pr) {
				pool_put(&semu_pool, sutmp);
				semutot--;
				return (suptr);
			}
		}
		suptr = sutmp;
	}
	suptr->un_cnt = 0;
	suptr->un_proc = pr;
	SLIST_INSERT_HEAD(&semu_list, suptr, un_next);
	return (suptr);
}

/*
 * Adjust a particular entry for a particular proc
 */
int
semundo_adjust(struct proc *p, struct sem_undo **supptr, int semid, int semnum,
	int adjval)
{
	struct process *pr = p->p_p;
	struct sem_undo *suptr;
	struct undo *sunptr;
	int i;

	/*
	 * Look for and remember the sem_undo if the caller doesn't provide it.
	 */
	suptr = *supptr;
	if (suptr == NULL) {
		SLIST_FOREACH(suptr, &semu_list, un_next) {
			if (suptr->un_proc == pr) {
				*supptr = suptr;
				break;
			}
		}
		if (suptr == NULL) {
			if (adjval == 0)
				return (0);
			suptr = semu_alloc(p->p_p);
			if (suptr == NULL)
				return (ENOSPC);
			*supptr = suptr;
		}
	}

	/*
	 * Look for the requested entry and adjust it
	 * (delete if adjval becomes 0).
	 */
	sunptr = &suptr->un_ent[0];
	for (i = 0; i < suptr->un_cnt; i++, sunptr++) {
		if (sunptr->un_id != semid || sunptr->un_num != semnum)
			continue;
		if (adjval == 0)
			sunptr->un_adjval = 0;
		else
			sunptr->un_adjval += adjval;
		if (sunptr->un_adjval != 0)
			return (0);

		if (--suptr->un_cnt == 0) {
			SLIST_REMOVE(&semu_list, suptr, sem_undo, un_next);
			pool_put(&semu_pool, suptr);
			semutot--;
		} else if (i < suptr->un_cnt)
			suptr->un_ent[i] =
			    suptr->un_ent[suptr->un_cnt];
		return (0);
	}

	/* Didn't find the right entry - create it */
	if (adjval == 0)
		return (0);
	if (suptr->un_cnt == SEMUME)
		return (EINVAL);

	sunptr = &suptr->un_ent[suptr->un_cnt];
	suptr->un_cnt++;
	sunptr->un_adjval = adjval;
	sunptr->un_id = semid;
	sunptr->un_num = semnum;
	return (0);
}

void
semundo_clear(int semid, int semnum)
{
	struct sem_undo *suptr = SLIST_FIRST(&semu_list);
	struct sem_undo *suprev = NULL;
	struct undo *sunptr;
	int i;

	while (suptr != NULL) {
		sunptr = &suptr->un_ent[0];
		for (i = 0; i < suptr->un_cnt; i++, sunptr++) {
			if (sunptr->un_id == semid) {
				if (semnum == -1 || sunptr->un_num == semnum) {
					suptr->un_cnt--;
					if (i < suptr->un_cnt) {
						suptr->un_ent[i] =
						  suptr->un_ent[suptr->un_cnt];
						i--, sunptr--;
					}
				}
				if (semnum != -1)
					break;
			}
		}
		if (suptr->un_cnt == 0) {
			struct sem_undo *sutmp = suptr;

			if (suptr == SLIST_FIRST(&semu_list))
				SLIST_REMOVE_HEAD(&semu_list, un_next);
			else
				SLIST_REMOVE_AFTER(suprev, un_next);
			suptr = SLIST_NEXT(suptr, un_next);
			pool_put(&semu_pool, sutmp);
			semutot--;
		} else {
			suprev = suptr;
			suptr = SLIST_NEXT(suptr, un_next);
		}
	}
}

int
sys___semctl(struct proc *p, void *v, register_t *retval)
{
	struct sys___semctl_args /* {
		syscallarg(int) semid;
		syscallarg(int) semnum;
		syscallarg(int) cmd;
		syscallarg(union semun *) arg;
	} */ *uap = v;
	union semun arg;
	int error = 0, cmd = SCARG(uap, cmd);

	switch (cmd) {
	case IPC_SET:
	case IPC_STAT:
	case GETALL:
	case SETVAL:
	case SETALL:
		error = copyin(SCARG(uap, arg), &arg, sizeof(arg));
		break;
	}
	if (error == 0) {
		error = semctl1(p, SCARG(uap, semid), SCARG(uap, semnum),
		    cmd, &arg, retval, copyin, copyout);
	}
	return (error);
}

int
semctl1(struct proc *p, int semid, int semnum, int cmd, union semun *arg,
    register_t *retval, int (*ds_copyin)(const void *, void *, size_t),
    int (*ds_copyout)(const void *, void *, size_t))
{
	struct ucred *cred = p->p_ucred;
	int i, ix, error = 0;
	struct semid_ds sbuf;
	struct semid_ds *semaptr;
	unsigned short *semval = NULL;

	DPRINTF(("call to semctl(%d, %d, %d, %p)\n", semid, semnum, cmd, arg));

	ix = IPCID_TO_IX(semid);
	if (ix < 0 || ix >= seminfo.semmni)
		return (EINVAL);

	if ((semaptr = sema[ix]) == NULL ||
	    semaptr->sem_perm.seq != IPCID_TO_SEQ(semid))
		return (EINVAL);

	switch (cmd) {
	case IPC_RMID:
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_M)) != 0)
			return (error);
		semaptr->sem_perm.cuid = cred->cr_uid;
		semaptr->sem_perm.uid = cred->cr_uid;
		semtot -= semaptr->sem_nsems;
		free(semaptr->sem_base, M_SEM, 0);
		pool_put(&sema_pool, semaptr);
		sema[ix] = NULL;
		semundo_clear(ix, -1);
		wakeup(&sema[ix]);
		break;

	case IPC_SET:
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_M)))
			return (error);
		if ((error = ds_copyin(arg->buf, &sbuf, sizeof(sbuf))) != 0)
			return (error);
		semaptr->sem_perm.uid = sbuf.sem_perm.uid;
		semaptr->sem_perm.gid = sbuf.sem_perm.gid;
		semaptr->sem_perm.mode = (semaptr->sem_perm.mode & ~0777) |
		    (sbuf.sem_perm.mode & 0777);
		semaptr->sem_ctime = time_second;
		break;

	case IPC_STAT:
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
		error = ds_copyout(semaptr, arg->buf, sizeof(struct semid_ds));
		break;

	case GETNCNT:
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
		if (semnum < 0 || semnum >= semaptr->sem_nsems)
			return (EINVAL);
		*retval = semaptr->sem_base[semnum].semncnt;
		break;

	case GETPID:
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
		if (semnum < 0 || semnum >= semaptr->sem_nsems)
			return (EINVAL);
		*retval = semaptr->sem_base[semnum].sempid;
		break;

	case GETVAL:
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
		if (semnum < 0 || semnum >= semaptr->sem_nsems)
			return (EINVAL);
		*retval = semaptr->sem_base[semnum].semval;
		break;

	case GETALL:
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
		for (i = 0; i < semaptr->sem_nsems; i++) {
			error = ds_copyout(&semaptr->sem_base[i].semval,
			    &arg->array[i], sizeof(arg->array[0]));
			if (error != 0)
				break;
		}
		break;

	case GETZCNT:
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
		if (semnum < 0 || semnum >= semaptr->sem_nsems)
			return (EINVAL);
		*retval = semaptr->sem_base[semnum].semzcnt;
		break;

	case SETVAL:
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_W)))
			return (error);
		if (semnum < 0 || semnum >= semaptr->sem_nsems)
			return (EINVAL);
		if (arg->val > seminfo.semvmx)
			return (ERANGE);
		semaptr->sem_base[semnum].semval = arg->val;
		semundo_clear(ix, semnum);
		wakeup(&sema[ix]);
		break;

	case SETALL:
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_W)))
			return (error);
		semval = mallocarray(semaptr->sem_nsems, sizeof(arg->array[0]),
		    M_TEMP, M_WAITOK);
		for (i = 0; i < semaptr->sem_nsems; i++) {
			error = ds_copyin(&arg->array[i], &semval[i],
			    sizeof(arg->array[0]));
			if (error != 0)
				goto error;
			if (semval[i] > seminfo.semvmx) {
				error = ERANGE;
				goto error;
			}
		}
		for (i = 0; i < semaptr->sem_nsems; i++)
			semaptr->sem_base[i].semval = semval[i];
		semundo_clear(ix, -1);
		wakeup(&sema[ix]);
		break;

	default:
		return (EINVAL);
	}

error:
	if (semval)
		free(semval, M_TEMP,
		    semaptr->sem_nsems * sizeof(arg->array[0]));

	return (error);
}

int
sys_semget(struct proc *p, void *v, register_t *retval)
{
	struct sys_semget_args /* {
		syscallarg(key_t) key;
		syscallarg(int) nsems;
		syscallarg(int) semflg;
	} */ *uap = v;
	int semid, error;
	int key = SCARG(uap, key);
	int nsems = SCARG(uap, nsems);
	int semflg = SCARG(uap, semflg);
	struct semid_ds *semaptr, *semaptr_new = NULL;
	struct ucred *cred = p->p_ucred;

	DPRINTF(("semget(0x%x, %d, 0%o)\n", key, nsems, semflg));

	/*
	 * Preallocate space for the new semaphore.  If we are going
	 * to sleep, we want to sleep now to eliminate any race
	 * condition in allocating a semaphore with a specific key.
	 */
	if (key == IPC_PRIVATE || (semflg & IPC_CREAT)) {
		if (nsems <= 0 || nsems > seminfo.semmsl) {
			DPRINTF(("nsems out of range (0<%d<=%d)\n", nsems,
			    seminfo.semmsl));
			return (EINVAL);
		}
		if (nsems > seminfo.semmns - semtot) {
			DPRINTF(("not enough semaphores left (need %d, got %d)\n",
			    nsems, seminfo.semmns - semtot));
			return (ENOSPC);
		}
		semaptr_new = pool_get(&sema_pool, PR_WAITOK);
		semaptr_new->sem_base = mallocarray(nsems, sizeof(struct sem),
		    M_SEM, M_WAITOK|M_ZERO);
	}

	if (key != IPC_PRIVATE) {
		for (semid = 0, semaptr = NULL; semid < seminfo.semmni; semid++) {
			if ((semaptr = sema[semid]) != NULL &&
			    semaptr->sem_perm.key == key) {
				DPRINTF(("found public key\n"));
				if ((error = ipcperm(cred, &semaptr->sem_perm,
				    semflg & 0700)))
					goto error;
				if (nsems > 0 && semaptr->sem_nsems < nsems) {
					DPRINTF(("too small\n"));
					error = EINVAL;
					goto error;
				}
				if ((semflg & IPC_CREAT) && (semflg & IPC_EXCL)) {
					DPRINTF(("not exclusive\n"));
					error = EEXIST;
					goto error;
				}
				if (semaptr_new != NULL) {
					free(semaptr_new->sem_base, M_SEM,
					    nsems * sizeof(struct sem));
					pool_put(&sema_pool, semaptr_new);
				}
				goto found;
			}
		}
	}

	DPRINTF(("need to allocate the semid_ds\n"));
	if (key == IPC_PRIVATE || (semflg & IPC_CREAT)) {
		for (semid = 0; semid < seminfo.semmni; semid++) {
			if ((semaptr = sema[semid]) == NULL)
				break;
		}
		if (semid == seminfo.semmni) {
			DPRINTF(("no more semid_ds's available\n"));
			error = ENOSPC;
			goto error;
		}
		DPRINTF(("semid %d is available\n", semid));
		semaptr_new->sem_perm.key = key;
		semaptr_new->sem_perm.cuid = cred->cr_uid;
		semaptr_new->sem_perm.uid = cred->cr_uid;
		semaptr_new->sem_perm.cgid = cred->cr_gid;
		semaptr_new->sem_perm.gid = cred->cr_gid;
		semaptr_new->sem_perm.mode = (semflg & 0777);
		semaptr_new->sem_perm.seq = semseqs[semid] =
		    (semseqs[semid] + 1) & 0x7fff;
		semaptr_new->sem_nsems = nsems;
		semaptr_new->sem_otime = 0;
		semaptr_new->sem_ctime = time_second;
		sema[semid] = semaptr_new;
		semtot += nsems;
	} else {
		DPRINTF(("didn't find it and wasn't asked to create it\n"));
		return (ENOENT);
	}

found:
	*retval = IXSEQ_TO_IPCID(semid, sema[semid]->sem_perm);
	return (0);
error:
	if (semaptr_new != NULL) {
		free(semaptr_new->sem_base, M_SEM, nsems * sizeof(struct sem));
		pool_put(&sema_pool, semaptr_new);
	}
	return (error);
}

int
sys_semop(struct proc *p, void *v, register_t *retval)
{
	struct sys_semop_args /* {
		syscallarg(int) semid;
		syscallarg(struct sembuf *) sops;
		syscallarg(size_t) nsops;
	} */ *uap = v;
#define	NSOPS	8
	struct sembuf sopbuf[NSOPS];
	int semid = SCARG(uap, semid);
	size_t nsops = SCARG(uap, nsops);
	struct sembuf *sops;
	struct semid_ds *semaptr;
	struct sembuf *sopptr = NULL;
	struct sem *semptr = NULL;
	struct sem_undo *suptr = NULL;
	struct ucred *cred = p->p_ucred;
	size_t i, j;
	int do_wakeup, do_undos, error;

	DPRINTF(("call to semop(%d, %p, %lu)\n", semid, SCARG(uap, sops),
	    (u_long)nsops));

	semid = IPCID_TO_IX(semid);	/* Convert back to zero origin */

	if (semid < 0 || semid >= seminfo.semmni)
		return (EINVAL);

	if ((semaptr = sema[semid]) == NULL ||
	    semaptr->sem_perm.seq != IPCID_TO_SEQ(SCARG(uap, semid)))
		return (EINVAL);

	if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_W))) {
		DPRINTF(("error = %d from ipaccess\n", error));
		return (error);
	}

	if (nsops == 0) {
		*retval = 0;
		return (0);
	} else if (nsops > (size_t)seminfo.semopm) {
		DPRINTF(("too many sops (max=%d, nsops=%lu)\n", seminfo.semopm,
		    (u_long)nsops));
		return (E2BIG);
	}

	if (nsops <= NSOPS)
		sops = sopbuf;
	else
		sops = mallocarray(nsops, sizeof(struct sembuf), M_SEM, M_WAITOK);
	error = copyin(SCARG(uap, sops), sops, nsops * sizeof(struct sembuf));
	if (error != 0) {
		DPRINTF(("error = %d from copyin(%p, %p, %u)\n", error,
		    SCARG(uap, sops), &sops, nsops * sizeof(struct sembuf)));
		goto done2;
	}

	/* 
	 * Loop trying to satisfy the vector of requests.
	 * If we reach a point where we must wait, any requests already
	 * performed are rolled back and we go to sleep until some other
	 * process wakes us up.  At this point, we start all over again.
	 *
	 * This ensures that from the perspective of other tasks, a set
	 * of requests is atomic (never partially satisfied).
	 */
	do_undos = 0;

	for (;;) {
		do_wakeup = 0;

		for (i = 0; i < nsops; i++) {
			sopptr = &sops[i];

			if (sopptr->sem_num >= semaptr->sem_nsems) {
				error = EFBIG;
				goto done2;
			}

			semptr = &semaptr->sem_base[sopptr->sem_num];

			DPRINTF(("semop:  semaptr=%x, sem_base=%x, semptr=%x, sem[%d]=%d : op=%d, flag=%s\n",
			    semaptr, semaptr->sem_base, semptr,
			    sopptr->sem_num, semptr->semval, sopptr->sem_op,
			    (sopptr->sem_flg & IPC_NOWAIT) ? "nowait" : "wait"));

			if (sopptr->sem_op < 0) {
				if ((int)(semptr->semval +
					  sopptr->sem_op) < 0) {
					DPRINTF(("semop:  can't do it now\n"));
					break;
				} else {
					semptr->semval += sopptr->sem_op;
					if (semptr->semval == 0 &&
					    semptr->semzcnt > 0)
						do_wakeup = 1;
				}
				if (sopptr->sem_flg & SEM_UNDO)
					do_undos++;
			} else if (sopptr->sem_op == 0) {
				if (semptr->semval > 0) {
					DPRINTF(("semop:  not zero now\n"));
					break;
				}
			} else {
				if (semptr->semncnt > 0)
					do_wakeup = 1;
				semptr->semval += sopptr->sem_op;
				if (sopptr->sem_flg & SEM_UNDO)
					do_undos++;
			}
		}

		/*
		 * Did we get through the entire vector and can we undo it?
		 */
		if (i >= nsops && do_undos <= SEMUME)
			goto done;

		/*
		 * No ... rollback anything that we've already done
		 */
		DPRINTF(("semop:  rollback 0 through %d\n", i - 1));
		for (j = 0; j < i; j++)
			semaptr->sem_base[sops[j].sem_num].semval -=
			    sops[j].sem_op;

		/*
		 * Did we have too many SEM_UNDO's
		 */
		if (do_undos > SEMUME) {
			error = ENOSPC;
			goto done2;
		}

		/*
		 * If the request that we couldn't satisfy has the
		 * NOWAIT flag set then return with EAGAIN.
		 */
		if (sopptr->sem_flg & IPC_NOWAIT) {
			error = EAGAIN;
			goto done2;
		}

		if (sopptr->sem_op == 0)
			semptr->semzcnt++;
		else
			semptr->semncnt++;

		DPRINTF(("semop:  good night!\n"));
		error = tsleep(&sema[semid], PLOCK | PCATCH,
		    "semwait", 0);
		DPRINTF(("semop:  good morning (error=%d)!\n", error));

		suptr = NULL;	/* sem_undo may have been reallocated */

		/*
		 * Make sure that the semaphore still exists
		 */
		if (sema[semid] == NULL ||
		    semaptr->sem_perm.seq != IPCID_TO_SEQ(SCARG(uap, semid))) {
			error = EIDRM;
			goto done2;
		}

		/*
		 * The semaphore is still alive.  Readjust the count of
		 * waiting processes.
		 */
		if (sopptr->sem_op == 0)
			semptr->semzcnt--;
		else
			semptr->semncnt--;

		/*
		 * Is it really morning, or was our sleep interrupted?
		 * (Delayed check of tsleep() return code because we
		 * need to decrement sem[nz]cnt either way.)
		 */
		if (error != 0) {
			error = EINTR;
			goto done2;
		}
		DPRINTF(("semop:  good morning!\n"));
	}

done:
	/*
	 * Process any SEM_UNDO requests.
	 */
	if (do_undos) {
		for (i = 0; i < nsops; i++) {
			/*
			 * We only need to deal with SEM_UNDO's for non-zero
			 * op's.
			 */
			int adjval;

			if ((sops[i].sem_flg & SEM_UNDO) == 0)
				continue;
			adjval = sops[i].sem_op;
			if (adjval == 0)
				continue;
			error = semundo_adjust(p, &suptr, semid,
			    sops[i].sem_num, -adjval);
			if (error == 0)
				continue;

			/*
			 * Uh-Oh!  We ran out of either sem_undo's or undo's.
			 * Rollback the adjustments to this point and then
			 * rollback the semaphore ups and down so we can return
			 * with an error with all structures restored.  We
			 * rollback the undo's in the exact reverse order that
			 * we applied them.  This guarantees that we won't run
			 * out of space as we roll things back out.
			 */
			for (j = i; j > 0;) {
				j--;
				if ((sops[j].sem_flg & SEM_UNDO) == 0)
					continue;
				adjval = sops[j].sem_op;
				if (adjval == 0)
					continue;
				if (semundo_adjust(p, &suptr, semid,
				    sops[j].sem_num, adjval) != 0)
					panic("semop - can't undo undos");
			}

			for (j = 0; j < nsops; j++)
				semaptr->sem_base[sops[j].sem_num].semval -=
				    sops[j].sem_op;

			DPRINTF(("error = %d from semundo_adjust\n", error));
			goto done2;
		} /* loop through the sops */
	} /* if (do_undos) */

	/* We're definitely done - set the sempid's */
	for (i = 0; i < nsops; i++) {
		sopptr = &sops[i];
		semptr = &semaptr->sem_base[sopptr->sem_num];
		semptr->sempid = p->p_p->ps_pid;
	}

	semaptr->sem_otime = time_second;

	/* Do a wakeup if any semaphore was up'd. */
	if (do_wakeup) {
		DPRINTF(("semop:  doing wakeup\n"));
		wakeup(&sema[semid]);
		DPRINTF(("semop:  back from wakeup\n"));
	}
	DPRINTF(("semop:  done\n"));
	*retval = 0;
done2:
	if (sops != sopbuf)
		free(sops, M_SEM, nsops * sizeof(struct sembuf));
	return (error);
}

/*
 * Go through the undo structures for this process and apply the adjustments to
 * semaphores.
 */
void
semexit(struct process *pr)
{
	struct sem_undo *suptr;
	struct sem_undo **supptr;

	/*
	 * Go through the chain of undo vectors looking for one associated with
	 * this process.  Remember the pointer to the pointer to the element
	 * to dequeue it later.
	 */
	supptr = &SLIST_FIRST(&semu_list);
	SLIST_FOREACH(suptr, &semu_list, un_next) {
		if (suptr->un_proc == pr)
			break;
		supptr = &SLIST_NEXT(suptr, un_next);
	}

	/*
	 * If there is no undo vector, skip to the end.
	 */
	if (suptr == NULL)
		return;

	/*
	 * We now have an undo vector for this process.
	 */
	DPRINTF(("process @@%p has undo structure with %d entries\n", pr,
	    suptr->un_cnt));

	/*
	 * If there are any active undo elements then process them.
	 */
	if (suptr->un_cnt > 0) {
		int ix;

		for (ix = 0; ix < suptr->un_cnt; ix++) {
			int semid = suptr->un_ent[ix].un_id;
			int semnum = suptr->un_ent[ix].un_num;
			int adjval = suptr->un_ent[ix].un_adjval;
			struct semid_ds *semaptr;

			if ((semaptr = sema[semid]) == NULL)
				panic("semexit - semid not allocated");
			if (semnum >= semaptr->sem_nsems)
				panic("semexit - semnum out of range");

			DPRINTF(("semexit:  %p id=%d num=%d(adj=%d) ; sem=%d\n",
			    suptr->un_proc, suptr->un_ent[ix].un_id,
			    suptr->un_ent[ix].un_num,
			    suptr->un_ent[ix].un_adjval,
			    semaptr->sem_base[semnum].semval));

			if (adjval < 0 &&
			    semaptr->sem_base[semnum].semval < -adjval)
				semaptr->sem_base[semnum].semval = 0;
			else
				semaptr->sem_base[semnum].semval += adjval;

			wakeup(&sema[semid]);
			DPRINTF(("semexit:  back from wakeup\n"));
		}
	}

	/*
	 * Deallocate the undo vector.
	 */
	DPRINTF(("removing vector\n"));
	*supptr = SLIST_NEXT(suptr, un_next);
	pool_put(&semu_pool, suptr);
	semutot--;
}

/*
 * Userland access to struct seminfo.
 */
int
sysctl_sysvsem(int *name, u_int namelen, void *oldp, size_t *oldlenp,
	void *newp, size_t newlen)
{
	int error, val;
	struct semid_ds **sema_new;
	unsigned short *newseqs;

	if (namelen != 2) {
		switch (name[0]) {
		case KERN_SEMINFO_SEMMNI:
		case KERN_SEMINFO_SEMMNS:
		case KERN_SEMINFO_SEMMNU:
		case KERN_SEMINFO_SEMMSL:
		case KERN_SEMINFO_SEMOPM:
		case KERN_SEMINFO_SEMUME:
		case KERN_SEMINFO_SEMUSZ:
		case KERN_SEMINFO_SEMVMX:
		case KERN_SEMINFO_SEMAEM:
			break;
		default:
                        return (ENOTDIR);       /* overloaded */
                }
        }

	switch (name[0]) {
	case KERN_SEMINFO_SEMMNI:
		val = seminfo.semmni;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semmni)
			return (error);

		if (val < seminfo.semmni || val > 0xffff)
			return (EINVAL);

		/* Expand semsegs and semseqs arrays */
		sema_new = mallocarray(val, sizeof(struct semid_ds *),
		    M_SEM, M_WAITOK|M_ZERO);
		memcpy(sema_new, sema,
		    seminfo.semmni * sizeof(struct semid_ds *));
		newseqs = mallocarray(val, sizeof(unsigned short), M_SEM,
		    M_WAITOK|M_ZERO);
		memcpy(newseqs, semseqs,
		    seminfo.semmni * sizeof(unsigned short));
		free(sema, M_SEM, 0);
		free(semseqs, M_SEM, 0);
		sema = sema_new;
		semseqs = newseqs;
		seminfo.semmni = val;
		return (0);
	case KERN_SEMINFO_SEMMNS:
		val = seminfo.semmns;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semmns)
			return (error);
		if (val < seminfo.semmns || val > 0xffff)
			return (EINVAL);	/* can't decrease semmns */
		seminfo.semmns = val;
		return (0);
	case KERN_SEMINFO_SEMMNU:
		val = seminfo.semmnu;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semmnu)
			return (error);
		if (val < seminfo.semmnu)
			return (EINVAL);	/* can't decrease semmnu */
		seminfo.semmnu = val;
		return (0);
	case KERN_SEMINFO_SEMMSL:
		val = seminfo.semmsl;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semmsl)
			return (error);
		if (val < seminfo.semmsl || val > 0xffff)
			return (EINVAL);	/* can't decrease semmsl */
		seminfo.semmsl = val;
		return (0);
	case KERN_SEMINFO_SEMOPM:
		val = seminfo.semopm;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semopm)
			return (error);
		if (val <= 0)
			return (EINVAL);	/* semopm must be >= 1 */
		seminfo.semopm = val;
		return (0);
	case KERN_SEMINFO_SEMUME:
		return (sysctl_rdint(oldp, oldlenp, newp, seminfo.semume));
	case KERN_SEMINFO_SEMUSZ:
		return (sysctl_rdint(oldp, oldlenp, newp, seminfo.semusz));
	case KERN_SEMINFO_SEMVMX:
		return (sysctl_rdint(oldp, oldlenp, newp, seminfo.semvmx));
	case KERN_SEMINFO_SEMAEM:
		return (sysctl_rdint(oldp, oldlenp, newp, seminfo.semaem));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}
@


1.52
log
@start retiring the nointr allocator. specify PR_WAITOK as a flag as a
marker for which pools are not interrupt safe. ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.51 2014/12/10 02:44:47 tedu Exp $	*/
a32 1
#include <sys/kernel.h>
@


1.51
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.50 2014/09/13 16:06:37 doug Exp $	*/
d65 3
a67 4
	pool_init(&sema_pool, sizeof(struct semid_ds), 0, 0, 0, "semapl",
	    &pool_allocator_nointr);
	pool_init(&semu_pool, SEMUSZ, 0, 0, 0, "semupl",
	    &pool_allocator_nointr);
@


1.50
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.49 2014/07/13 15:29:04 tedu Exp $	*/
d880 1
a880 1
		bcopy(sema, sema_new,
d884 1
a884 1
		bcopy(semseqs, newseqs,
@


1.49
log
@use mallocarray where arguments are multipled. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.48 2014/07/13 15:00:40 tedu Exp $	*/
d187 1
a187 1
	struct sem_undo *suprev = SLIST_END(&semu_list);
d191 1
a191 1
	while (suptr != SLIST_END(&semu_list)) {
@


1.48
log
@pass the size to free in some of the obvious cases
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.47 2014/07/12 18:43:32 tedu Exp $	*/
d69 1
a69 1
	sema = malloc(seminfo.semmni * sizeof(struct semid_ds *),
d71 1
a71 1
	semseqs = malloc(seminfo.semmni * sizeof(unsigned short),
d363 1
a363 1
		semval = malloc(semaptr->sem_nsems * sizeof(arg->array[0]),
d427 1
a427 1
		semaptr_new->sem_base = malloc(nsems * sizeof(struct sem),
d550 1
a550 1
		sops = malloc(nsops * sizeof(struct sembuf), M_SEM, M_WAITOK);
d878 1
a878 1
		sema_new = malloc(val * sizeof(struct semid_ds *),
d882 1
a882 1
		newseqs = malloc(val * sizeof(unsigned short), M_SEM,
@


1.47
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.46 2014/03/18 06:59:00 guenther Exp $	*/
d387 2
a388 1
		free(semval, M_TEMP, 0);
d450 2
a451 1
					free(semaptr_new->sem_base, M_SEM, 0);
d494 1
a494 1
		free(semaptr_new->sem_base, M_SEM, 0);
d758 1
a758 1
		free(sops, M_SEM, 0);
@


1.46
log
@In prep for killing ps_mainproc, use pr->ps_pid instead of
pr->ps_mainproc->p_pid to get the PID.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.45 2013/11/25 23:15:58 matthew Exp $	*/
d280 1
a280 1
		free(semaptr->sem_base, M_SEM);
d387 1
a387 1
		free(semval, M_TEMP);
d449 1
a449 1
					free(semaptr_new->sem_base, M_SEM);
d492 1
a492 1
		free(semaptr_new->sem_base, M_SEM);
d756 1
a756 1
		free(sops, M_SEM);
d884 2
a885 2
		free(sema, M_SEM);
		free(semseqs, M_SEM);
@


1.45
log
@Fix infinite loop pointed out by clang/brad.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.44 2012/10/21 19:00:48 beck Exp $	*/
d741 1
a741 1
		semptr->sempid = p->p_p->ps_mainproc->p_pid;
@


1.44
log
@Fix problem reported by Nathan Weeks <weeks@@iastate.edu> where a userland
program could induce the kernel to panic by attempting to do a sempo
with nsops > kern.seminfo.semume and the SEM_UNFO flag set.

This fixes it so we return ENOSPC, like the man page says, rather
than panicing.

ok miod@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.43 2012/04/11 13:29:14 naddy Exp $	*/
d716 10
a725 11
			if (i != 0) {
				for (j = i - 1; j >= 0; j--) {
					if ((sops[j].sem_flg & SEM_UNDO) == 0)
						continue;
					adjval = sops[j].sem_op;
					if (adjval == 0)
						continue;
					if (semundo_adjust(p, &suptr, semid,
					    sops[j].sem_num, adjval) != 0)
						panic("semop - can't undo undos");
				}
@


1.43
log
@SLIST_REMOVE_NEXT -> SLIST_REMOVE_AFTER for better consistency and
compatibility with FreeBSD/NetBSD.
Also rename SIMPLEQ_REMOVE_NEXT to SIMPLEQ_REMOVE_AFTER.

ok mikeb@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.42 2012/01/10 23:12:13 bluhm Exp $	*/
d597 1
a597 1
					do_undos = 1;
d608 1
a608 1
					do_undos = 1;
d613 1
a613 1
		 * Did we get through the entire vector?
d615 1
a615 1
		if (i >= nsops)
d625 8
@


1.42
log
@Replace the only occurrence of the obscure macro SLIST_FOREACH_PREVPTR.
No binary change.
ok mikeb@@ deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.41 2011/02/02 09:33:11 fgsch Exp $	*/
d213 1
a213 1
				SLIST_REMOVE_NEXT(&semu_list, suprev, un_next);
@


1.41
log
@For SETVAL and SETALL operations make sure the specified value(s) are
within the system limits.  Fixes kernel/6547.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.40 2009/06/02 12:11:16 guenther Exp $	*/
d765 2
a766 1
	 * this process.
d768 2
a769 1
	SLIST_FOREACH_PREVPTR(suptr, supptr, &semu_list, un_next) {
d772 1
@


1.40
log
@msgctl(), shmctl(), semctl() all have operations that are supposed
to return pids, not thread ids, so record the former when performing
operations.

ok blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.39 2009/05/16 23:00:45 thib Exp $	*/
d261 1
d353 2
d363 2
d366 1
a366 2
			error = ds_copyin(&arg->array[i],
			    &semaptr->sem_base[i].semval,
d369 5
a373 1
				break;
d375 2
d384 4
@


1.39
log
@0 -> PR_NOWAIT for clarity.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.38 2009/04/03 04:22:49 guenther Exp $	*/
d720 1
a720 1
		semptr->sempid = p->p_pid;
@


1.38
log
@Fix SEM_UNDO handling for rthreads: use the struct process* instead
of the struct proc* as the identifier for SEM_UNDO tracking and only
call semexit() from the original thread, once the process as a whole
is exiting

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.37 2009/01/15 22:54:21 oga Exp $	*/
d94 1
a94 1
	if ((suptr = pool_get(&semu_pool, 0)) == NULL) {
@


1.37
log
@Fix a memory leak in in the case where semget() is called with a
non-private key and flags of IPC_CREAT.

Before, if we found an existing semaphore, we jumped to the return and
forgot the free the preallocated semaphore. Instead, free it before we
jump.

Bug reported by Roland Bramm; thanks!

ok miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.36 2008/05/23 20:14:45 djm Exp $	*/
d57 1
a57 1
struct sem_undo *semu_alloc(struct proc *);
d81 1
a81 1
semu_alloc(struct proc *p)
d91 1
a91 1
	 * with un_proc == p has not been allocated in the meantime.
d97 1
a97 1
			if (suptr->un_proc == p) {
d106 1
a106 1
	suptr->un_proc = p;
d118 1
d129 1
a129 1
			if (suptr->un_proc == p) {
d137 1
a137 1
			suptr = semu_alloc(p);
d744 1
a744 1
semexit(struct proc *p)
d754 1
a754 1
		if (suptr->un_proc == p)
d767 1
a767 1
	DPRINTF(("proc @@%p has undo structure with %d entries\n", p,
@


1.36
log
@update sem_otime on semop(); reported by mkbucc AT gmail.com
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.35 2007/10/14 23:08:04 fgsch Exp $	*/
d432 4
@


1.35
log
@remove tests for EIDRM and ENOMSG existence now that they're in the tree.
miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.34 2007/09/07 15:00:20 art Exp $	*/
d717 2
@


1.34
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.33 2006/08/10 17:03:48 millert Exp $	*/
a41 5

/* SVID defines EIDRM but BSD does not */
#ifndef EIDRM
#define EIDRM	EINVAL
#endif
@


1.33
log
@Fix a panic when more than the default number of sempahores are
allocated.  Problem debugged by thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.32 2004/07/15 11:24:46 millert Exp $	*/
d75 1
a75 2
	    M_SEM, M_WAITOK);
	bzero(sema, seminfo.semmni * sizeof(struct semid_ds *));
d77 1
a77 2
	    M_SEM, M_WAITOK);
	bzero(semseqs, seminfo.semmni * sizeof(unsigned short));
d417 1
a417 2
		    M_SEM, M_WAITOK);
		bzero(semaptr_new->sem_base, nsems * sizeof(struct sem));
d851 1
a851 1
		    M_SEM, M_WAITOK);
d854 2
a855 3
		bzero(sema_new + seminfo.semmni,
		    (val - seminfo.semmni) * sizeof(struct semid_ds *));
		newseqs = malloc(val * sizeof(unsigned short), M_SEM, M_WAITOK);
a857 2
		bzero(newseqs + seminfo.semmni,
		    (val - seminfo.semmni) * sizeof(unsigned short));
@


1.32
log
@Rename structs oipc_perm, omsqid_ds, osemid_ds, oshmid_ds to ipc_perm23,
etc to avoid confusion and for consistency with the *35 ones.
Remove *n2o functions that don't belong outside of compat.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.31 2004/07/14 23:40:27 millert Exp $	*/
d426 16
a441 17
			    semaptr->sem_perm.key == key)
				break;
		}
		if (semaptr != NULL) {
			DPRINTF(("found public key\n"));
			if ((error = ipcperm(cred, &semaptr->sem_perm,
			    semflg & 0700)))
				goto error;
			if (nsems > 0 && semaptr->sem_nsems < nsems) {
				DPRINTF(("too small\n"));
				error = EINVAL;
				goto error;
			}
			if ((semflg & IPC_CREAT) && (semflg & IPC_EXCL)) {
				DPRINTF(("not exclusive\n"));
				error = EEXIST;
				goto error;
a442 1
			goto found;
@


1.32.6.1
log
@MFC:
Fix by millert@@

Fix a panic when more than the default number of sempahores are
allocated.  Problem debugged by thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.32 2004/07/15 11:24:46 millert Exp $	*/
d426 17
a442 16
			    semaptr->sem_perm.key == key) {
				DPRINTF(("found public key\n"));
				if ((error = ipcperm(cred, &semaptr->sem_perm,
				    semflg & 0700)))
					goto error;
				if (nsems > 0 && semaptr->sem_nsems < nsems) {
					DPRINTF(("too small\n"));
					error = EINVAL;
					goto error;
				}
				if ((semflg & IPC_CREAT) && (semflg & IPC_EXCL)) {
					DPRINTF(("not exclusive\n"));
					error = EEXIST;
					goto error;
				}
				goto found;
d444 1
@


1.32.8.1
log
@MFC:
Fix by millert@@

Fix a panic when more than the default number of sempahores are
allocated.  Problem debugged by thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.32 2004/07/15 11:24:46 millert Exp $	*/
d426 17
a442 16
			    semaptr->sem_perm.key == key) {
				DPRINTF(("found public key\n"));
				if ((error = ipcperm(cred, &semaptr->sem_perm,
				    semflg & 0700)))
					goto error;
				if (nsems > 0 && semaptr->sem_nsems < nsems) {
					DPRINTF(("too small\n"));
					error = EINVAL;
					goto error;
				}
				if ((semflg & IPC_CREAT) && (semflg & IPC_EXCL)) {
					DPRINTF(("not exclusive\n"));
					error = EEXIST;
					goto error;
				}
				goto found;
d444 1
@


1.31
log
@Move the guts of the {sem,msg,shm}ctl system calls into a new function
which also takes two function pointers for copyin/copyout.  For the
real syscalls these are just the normal copyin/copyout functions.
For the compat routines, these are funtions that convert between
the new and old foo_ds structs automagically.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.30 2004/06/21 23:50:36 tholo Exp $	*/
a227 13
}

void
semid_n2o(struct semid_ds *n, struct osemid_ds *o)
{
	o->sem_base = n->sem_base;
	o->sem_nsems = n->sem_nsems;
	o->sem_otime = n->sem_otime;
	o->sem_pad1 = n->sem_pad1;
	o->sem_ctime = n->sem_ctime;
	o->sem_pad2 = n->sem_pad2;
	bcopy(n->sem_pad3, o->sem_pad3, sizeof o->sem_pad3);
	ipc_n2o(&n->sem_perm, &o->sem_perm);
@


1.30
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.29 2004/05/03 17:38:48 millert Exp $	*/
d252 24
a275 5
	int semid = SCARG(uap, semid);
	int semnum = SCARG(uap, semnum);
	int cmd = SCARG(uap, cmd);
	union semun *arg = SCARG(uap, arg);
	union semun real_arg;
d277 1
a277 1
	int i, rval, error;
d283 2
a284 2
	semid = IPCID_TO_IX(semid);
	if (semid < 0 || semid >= seminfo.semmni)
d287 2
a288 2
	if ((semaptr = sema[semid]) == NULL ||
	    semaptr->sem_perm.seq != IPCID_TO_SEQ(SCARG(uap, semid)))
a290 2
	error = rval = 0;

d300 3
a302 3
		sema[semid] = NULL;
		semundo_clear(semid, -1);
		wakeup(&sema[semid]);
d308 1
a308 3
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
		if ((error = copyin(real_arg.buf, &sbuf, sizeof(sbuf))) != 0)
d320 1
a320 3
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
		error = copyout(semaptr, real_arg.buf, sizeof(struct semid_ds));
d328 1
a328 1
		rval = semaptr->sem_base[semnum].semncnt;
d336 1
a336 1
		rval = semaptr->sem_base[semnum].sempid;
d344 1
a344 1
		rval = semaptr->sem_base[semnum].semval;
a349 2
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
d351 2
a352 2
			error = copyout(&semaptr->sem_base[i].semval,
			    &real_arg.array[i], sizeof(real_arg.array[0]));
d363 1
a363 1
		rval = semaptr->sem_base[semnum].semzcnt;
d371 3
a373 5
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
		semaptr->sem_base[semnum].semval = real_arg.val;
		semundo_clear(semid, semnum);
		wakeup(&sema[semid]);
a378 2
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
d380 1
a380 1
			error = copyin(&real_arg.array[i],
d382 1
a382 1
			    sizeof(real_arg.array[0]));
d386 2
a387 2
		semundo_clear(semid, -1);
		wakeup(&sema[semid]);
a393 2
	if (error == 0)
		*retval = rval;
@


1.29
log
@POSIX says the length parameter for semop(2) and shmget(2) should be size_t.
Create new syscalls with the correct parameters and add compat versions
for the old ones under COMPAT_35.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.28 2004/03/17 19:54:24 millert Exp $	*/
d299 1
a299 1
		semaptr->sem_ctime = time.tv_sec;
d478 1
a478 1
		semaptr_new->sem_ctime = time.tv_sec;
@


1.28
log
@Add missing open paren in comment noticed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.27 2004/03/17 18:04:08 millert Exp $	*/
d503 1
a503 1
		syscallarg(u_int) nsops;
d508 1
a508 1
	u_int nsops = SCARG(uap, nsops);
d515 1
a515 1
	u_int i, j;
d518 2
a519 2
	DPRINTF(("call to semop(%d, %p, %u)\n", semid, SCARG(uap, sops),
	    nsops));
d538 3
a540 3
	} else if (nsops > (u_int)seminfo.semopm) {
		DPRINTF(("too many sops (max=%d, nsops=%u)\n", seminfo.semopm,
		    nsops));
@


1.27
log
@Adjust the number of processes waiting on a semaphore properly if we're
woken up in the middle of sleeping; cperciva@@freebsd.org.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.26 2004/03/13 07:17:39 tedu Exp $	*/
d666 1
a666 1
		 * Delayed check of tsleep() return code because we
@


1.26
log
@sync comments with reality, semconfig is long gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.25 2003/12/20 19:06:29 millert Exp $	*/
a645 6
		if (error != 0) {
			error = EINTR;
			goto done2;
		}
		DPRINTF(("semop:  good morning!\n"));

d663 11
@


1.25
log
@In semop(2), use an array on the stack for small values of nsops so
we don't have to use malloc/free.  Adapted from FreeBSD; ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.24 2003/12/17 20:40:57 millert Exp $	*/
d765 1
a765 4
	 * No (i.e. we are in case 1 or 2).
	 *
	 * If there is no undo vector, skip to the end and unlock the
	 * semaphore facility if necessary.
d771 1
a771 2
	 * We are now in case 1 or 2, and we have an undo vector for this
	 * process.
@


1.24
log
@Use SLIST macros instead of rolling our own.  Idea from and partly
based on changes from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.23 2003/12/03 19:03:42 millert Exp $	*/
d505 2
d544 4
a547 1
	sops = malloc(nsops * sizeof(struct sembuf), M_SEM, M_WAITOK);
d552 1
a552 2
		free(sops, M_SEM);
		return (error);
d573 2
a574 2
				free(sops, M_SEM);
				return (EFBIG);
d630 2
a631 2
			free(sops, M_SEM);
			return (EAGAIN);
d647 2
a648 2
			free(sops, M_SEM);
			return (EINTR);
d657 2
a658 2
			free(sops, M_SEM);
			return (EIDRM);
d720 1
a720 2
			free(sops, M_SEM);
			return (error);
a729 1
	free(sops, M_SEM);
d739 4
a742 1
	return (0);
@


1.23
log
@Pass -Wsign-compare and avoid a potential malloc(0); ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.22 2003/11/20 22:22:35 millert Exp $	*/
d5 1
a5 1
 * Copyright (c) 2002 Todd C. Miller <Todd.Miller@@courtesan.com>
d57 1
a57 1
struct	sem_undo *semu_list;	/* list of undo structures */
d80 1
a80 1
	semu_list = NULL;
d90 1
a90 1
	struct sem_undo *suptr, *tmp;
d102 2
a103 2
		tmp = pool_get(&semu_pool, PR_WAITOK);
		for (suptr = semu_list; suptr != NULL; suptr = suptr->un_next) {
d105 1
a105 1
				pool_put(&semu_pool, tmp);
d110 1
a110 1
		suptr = tmp;
d114 1
a114 2
	suptr->un_next = semu_list;
	semu_list = suptr;
d134 1
a134 1
		for (suptr = semu_list; suptr != NULL; suptr = suptr->un_next) {
d166 1
a166 17
			struct sem_undo *suprev;

			if (semu_list == suptr)
				semu_list = suptr->un_next;
			else {
				/* this code path should be rare */
				for (suprev = semu_list; suprev != NULL &&
				    suprev->un_next != suptr;
				    suprev = suprev->un_next)
					/* NOTHING */;
#ifdef DIAGNOSTIC
				if (suprev == NULL)
					panic("semundo_adjust: "
					    "suptr not in semu_list");
#endif
				suprev->un_next = suptr->un_next;
			}
d192 2
a193 1
	struct sem_undo *suptr, *suprev, *tmp;
d197 1
a197 1
	for (suptr = semu_list; suptr != NULL; ) {
d214 4
a217 3
			tmp = suptr;
			if (suptr == semu_list)
				suptr = semu_list = suptr->un_next;
d219 3
a221 2
				suptr = suprev->un_next = suptr->un_next;
			pool_put(&semu_pool, tmp);
d225 1
a225 1
			suptr = suptr->un_next;
d754 1
a754 2
	for (supptr = &semu_list; (suptr = *supptr) != NULL;
	    supptr = &suptr->un_next) {
d813 1
a813 1
	*supptr = suptr->un_next;
@


1.22
log
@Correct bounds check in semop(2) and semctl(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.21 2003/09/09 18:57:36 tedu Exp $	*/
d527 2
a528 2
	int i, j, error;
	int do_wakeup, do_undos;
d530 2
a531 1
	DPRINTF(("call to semop(%d, %p, %d)\n", semid, sops, nsops));
d547 6
a552 2
	if (nsops > seminfo.semopm) {
		DPRINTF(("too many sops (max=%d, nsops=%d)\n", seminfo.semopm, nsops));
d559 1
a559 1
		DPRINTF(("error = %d from copyin(%p, %p, %d)\n", error,
d712 11
a722 9
			for (j = i - 1; j >= 0; j--) {
				if ((sops[j].sem_flg & SEM_UNDO) == 0)
					continue;
				adjval = sops[j].sem_op;
				if (adjval == 0)
					continue;
				if (semundo_adjust(p, &suptr, semid,
				    sops[j].sem_num, adjval) != 0)
					panic("semop - can't undo undos");
@


1.21
log
@fix potential int overflow found by blexim at hush.com.  restrict root to
setting max sems to sane values.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.20 2003/08/20 18:02:20 millert Exp $	*/
d279 1
a279 1
	if (semid < 0 || semid >= seminfo.semmsl)
d534 1
a534 1
	if (semid < 0 || semid >= seminfo.semmsl)
@


1.21.2.1
log
@MFC:
Fix by millert@@

Correct bounds check in semop(2) and semctl(2)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.21 2003/09/09 18:57:36 tedu Exp $	*/
d279 1
a279 1
	if (semid < 0 || semid >= seminfo.semmni)
d534 1
a534 1
	if (semid < 0 || semid >= seminfo.semmni)
@


1.20
log
@Move the nsem sanity checks where they belong (before the malloc call).
This was missed when that code got restructured/re-ordered.
Problem reported by blexim AT hush d0t com.
OK deraadt@@, tedu@@, henning@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.19 2003/07/21 22:44:50 tedu Exp $	*/
d887 1
a887 1
		if (val < seminfo.semmns)
d905 1
a905 1
		if (val < seminfo.semmsl)
@


1.19
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.18 2003/06/17 21:56:25 millert Exp $	*/
d425 1
a425 1
	 * to sleep, we want to sleep now to elliminate any race
d429 10
a471 12
		if (nsems <= 0 || nsems > seminfo.semmsl) {
			DPRINTF(("nsems out of range (0<%d<=%d)\n", nsems,
			    seminfo.semmsl));
			error = EINVAL;
			goto error;
		}
		if (nsems > seminfo.semmns - semtot) {
			DPRINTF(("not enough semaphores left (need %d, got %d)\n",
			    nsems, seminfo.semmns - semtot));
			error = ENOSPC;
			goto error;
		}
@


1.18
log
@Sync with share/misc/license.template and add missing DARPA credit
where applicable.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.17 2003/06/03 01:52:41 millert Exp $	*/
d299 1
a299 1
		wakeup((caddr_t)&sema[semid]);
d307 1
a307 2
		if ((error = copyin(real_arg.buf, (caddr_t)&sbuf,
		    sizeof(sbuf))) != 0)
d321 1
a321 2
		error = copyout((caddr_t)semaptr, real_arg.buf,
		    sizeof(struct semid_ds));
d354 1
a354 1
			error = copyout((caddr_t)&semaptr->sem_base[i].semval,
d378 1
a378 1
		wakeup((caddr_t)&sema[semid]);
d388 1
a388 1
			    (caddr_t)&semaptr->sem_base[i].semval,
d394 1
a394 1
		wakeup((caddr_t)&sema[semid]);
d647 1
a647 1
		error = tsleep((caddr_t)&sema[semid], PLOCK | PCATCH,
d741 1
a741 1
		wakeup((caddr_t)&sema[semid]);
d814 1
a814 1
			wakeup((caddr_t)&sema[semid]);
@


1.17
log
@Use an ISC-tyle license for all my code; it is simpler and more permissive.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.16 2003/01/07 00:34:41 millert Exp $	*/
d11 11
a21 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.16
log
@xerxes [/home/src/local/millert/sudo/sudo-1.6.7] % vi /usr/src/local/TiVo/Linux/Don't allow s{e,h}mmni to be set > 0xffff via sysctl since that could
cause id collisions (the macros in <sys/ipc.h> limit the index to 0xffff).
Prompted by a conversation with weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.15 2002/12/30 19:57:34 millert Exp $	*/
a5 1
 * All rights reserved.
d7 3
a9 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d11 7
a17 10
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@


1.16.2.1
log
@MFC:
Fix by millert@@

Move the nsem sanity checks where they belong (before the malloc call).
This was missed when that code got restructured/re-ordered.
Problem reported by blexim AT hush d0t com.
OK deraadt@@, tedu@@, henning@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.16 2003/01/07 00:34:41 millert Exp $	*/
d434 1
a434 1
	 * to sleep, we want to sleep now to eliminate any race
a437 10
		if (nsems <= 0 || nsems > seminfo.semmsl) {
			DPRINTF(("nsems out of range (0<%d<=%d)\n", nsems,
			    seminfo.semmsl));
			return (EINVAL);
		}
		if (nsems > seminfo.semmns - semtot) {
			DPRINTF(("not enough semaphores left (need %d, got %d)\n",
			    nsems, seminfo.semmns - semtot));
			return (ENOSPC);
		}
d471 12
@


1.16.2.2
log
@MFC:
Fix by tedu@@

fix potential int overflow found by blexim at hush.com.  restrict root to
setting max sems to sane values.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.16.2.1 2003/08/20 20:16:41 brad Exp $	*/
d896 1
a896 1
		if (val < seminfo.semmns || val > 0xffff)
d914 1
a914 1
		if (val < seminfo.semmsl || val > 0xffff)
@


1.16.2.3
log
@MFC:
Fix by millert@@

Correct bounds check in semop(2) and semctl(2)

Ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.16.2.2 2003/09/10 15:38:01 brad Exp $	*/
d286 1
a286 1
	if (semid < 0 || semid >= seminfo.semmni)
d543 1
a543 1
	if (semid < 0 || semid >= seminfo.semmni)
@


1.15
log
@Use PLOCK for tsleep priority instead of the (rather bogus) PZERO - 4.
PZERO - 4 == 18 which makes it equivalent to PRIBIO; not what we want.
Discussed with art@@ some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.14 2002/12/30 18:41:27 millert Exp $	*/
d872 2
a873 2
		if (val < seminfo.semmni)
			return (EINVAL);	/* can't decrease semmni */
@


1.14
log
@If we can't allocate a struct sem_undo w/o sleeping, use PR_WAITOK
but then check to see that one with our struct proc was not allocated
in the meantime.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.13 2002/12/29 21:58:15 millert Exp $	*/
d656 1
a656 1
		error = tsleep((caddr_t)&sema[semid], (PZERO - 4) | PCATCH,
@


1.13
log
@Fix a couple of cases where semutot was not getting decremented and
one where semtot was not getting incremented.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.12 2002/12/17 23:32:31 millert Exp $	*/
d97 1
a97 1
	struct sem_undo *suptr;
d99 1
a99 2
	if (semutot == seminfo.semmnu ||
	    (suptr = pool_get(&semu_pool, 0)) == NULL)
d102 5
d108 11
@


1.12
log
@Add my copyright notice.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.11 2002/12/17 23:27:08 millert Exp $	*/
d177 1
d228 1
d490 1
d819 1
@


1.11
log
@Replace printfs bracketed by #ifdef SEM_DEBUG with a DPRINTF macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.10 2002/12/17 23:11:31 millert Exp $	*/
d4 26
@


1.10
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.9 2002/03/14 01:27:05 millert Exp $	*/
d29 6
d240 1
a240 3
#ifdef SEM_DEBUG
	printf("call to semctl(%d, %d, %d, %p)\n", semid, semnum, cmd, arg);
#endif
d387 1
a387 3
#ifdef SEM_DEBUG
	printf("semget(0x%x, %d, 0%o)\n", key, nsems, semflg);
#endif
d408 1
a408 3
#ifdef SEM_DEBUG
			printf("found public key\n");
#endif
d413 1
a413 3
#ifdef SEM_DEBUG
				printf("too small\n");
#endif
d418 1
a418 3
#ifdef SEM_DEBUG
				printf("not exclusive\n");
#endif
d426 1
a426 3
#ifdef SEM_DEBUG
	printf("need to allocate the semid_ds\n");
#endif
d429 2
a430 4
#ifdef SEM_DEBUG
			printf("nsems out of range (0<%d<=%d)\n", nsems,
			    seminfo.semmsl);
#endif
d435 2
a436 4
#ifdef SEM_DEBUG
			printf("not enough semaphores left (need %d, got %d)\n",
			    nsems, seminfo.semmns - semtot);
#endif
d445 1
a445 3
#ifdef SEM_DEBUG
			printf("no more semid_ds's available\n");
#endif
d449 1
a449 3
#ifdef SEM_DEBUG
		printf("semid %d is available\n", semid);
#endif
d463 1
a463 3
#ifdef SEM_DEBUG
		printf("didn't find it and wasn't asked to create it\n");
#endif
d497 1
a497 3
#ifdef SEM_DEBUG
	printf("call to semop(%d, %p, %d)\n", semid, sops, nsops);
#endif
d509 1
a509 3
#ifdef SEM_DEBUG
		printf("error = %d from ipaccess\n", error);
#endif
d514 1
a514 3
#ifdef SEM_DEBUG
		printf("too many sops (max=%d, nsops=%d)\n", seminfo.semopm, nsops);
#endif
d521 2
a522 4
#ifdef SEM_DEBUG
		printf("error = %d from copyin(%p, %p, %d)\n", error,
		    SCARG(uap, sops), &sops, nsops * sizeof(struct sembuf));
#endif
d551 1
a551 2
#ifdef SEM_DEBUG
			printf("semop:  semaptr=%x, sem_base=%x, semptr=%x, sem[%d]=%d : op=%d, flag=%s\n",
d554 1
a554 2
			    (sopptr->sem_flg & IPC_NOWAIT) ? "nowait" : "wait");
#endif
d559 1
a559 3
#ifdef SEM_DEBUG
					printf("semop:  can't do it now\n");
#endif
d571 1
a571 3
#ifdef SEM_DEBUG
					printf("semop:  not zero now\n");
#endif
d592 1
a592 3
#ifdef SEM_DEBUG
		printf("semop:  rollback 0 through %d\n", i-1);
#endif
d611 1
a611 3
#ifdef SEM_DEBUG
		printf("semop:  good night!\n");
#endif
d614 1
a614 3
#ifdef SEM_DEBUG
		printf("semop:  good morning (error=%d)!\n", error);
#endif
d622 1
a622 3
#ifdef SEM_DEBUG
		printf("semop:  good morning!\n");
#endif
d689 1
a689 3
#ifdef SEM_DEBUG
			printf("error = %d from semundo_adjust\n", error);
#endif
d705 1
a705 3
#ifdef SEM_DEBUG
		printf("semop:  doing wakeup\n");
#endif
d707 1
a707 3
#ifdef SEM_DEBUG
		printf("semop:  back from wakeup\n");
#endif
d709 1
a709 3
#ifdef SEM_DEBUG
	printf("semop:  done\n");
#endif
d747 2
a748 4
#ifdef SEM_DEBUG
	printf("proc @@%p has undo structure with %d entries\n", p,
	    suptr->un_cnt);
#endif
d767 1
a767 2
#ifdef SEM_DEBUG
			printf("semexit:  %p id=%d num=%d(adj=%d) ; sem=%d\n",
d771 1
a771 2
			    semaptr->sem_base[semnum].semval);
#endif
d780 1
a780 3
#ifdef SEM_DEBUG
			printf("semexit:  back from wakeup\n");
#endif
d787 1
a787 3
#ifdef SEM_DEBUG
	printf("removing vector\n");
#endif
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.8 2001/09/13 14:07:14 fgsch Exp $	*/
d17 1
d19 1
d24 5
d30 6
a35 4
struct	semid_ds *sema;		/* semaphore id pool */
struct	sem *sem;		/* semaphore pool */
struct	sem_undo *semu_list;	/* list of active undo structures */
int	*semu;			/* undo structure pool */
d42 1
a42 1
seminit()
a43 1
	register int i;
d45 10
a54 13
	if (sema == NULL)
		panic("sema is NULL");
	if (semu == NULL)
		panic("semu is NULL");

	for (i = 0; i < seminfo.semmni; i++) {
		sema[i].sem_base = 0;
		sema[i].sem_perm.mode = 0;
	}
	for (i = 0; i < seminfo.semmnu; i++) {
		register struct sem_undo *suptr = SEMU(i);
		suptr->un_proc = NULL;
	}
d63 1
a63 2
semu_alloc(p)
	struct proc *p;
d65 1
a65 46
	register int i;
	register struct sem_undo *suptr;
	register struct sem_undo **supptr;
	int attempt;

	/*
	 * Try twice to allocate something.
	 * (we'll purge any empty structures after the first pass so
	 * two passes are always enough)
	 */

	for (attempt = 0; attempt < 2; attempt++) {
		/*
		 * Look for a free structure.
		 * Fill it in and return it if we find one.
		 */

		for (i = 0; i < seminfo.semmnu; i++) {
			suptr = SEMU(i);
			if (suptr->un_proc == NULL) {
				suptr->un_next = semu_list;
				semu_list = suptr;
				suptr->un_cnt = 0;
				suptr->un_proc = p;
				return(suptr);
			}
		}

		/*
		 * We didn't find a free one, if this is the first attempt
		 * then try to free some structures.
		 */

		if (attempt == 0) {
			/* All the structures are in use - try to free some */
			int did_something = 0;

			supptr = &semu_list;
			while ((suptr = *supptr) != NULL) {
				if (suptr->un_cnt == 0)  {
					suptr->un_proc = NULL;
					*supptr = suptr->un_next;
					did_something = 1;
				} else
					supptr = &(suptr->un_next);
			}
d67 10
a76 13
			/* If we didn't free anything then just give-up */
			if (!did_something)
				return(NULL);
		} else {
			/*
			 * The second pass failed even though we freed
			 * something after the first pass!
			 * This is IMPOSSIBLE!
			 */
			panic("semu_alloc - second attempt failed");
		}
	}
	return NULL;
d83 2
a84 5
semundo_adjust(p, supptr, semid, semnum, adjval)
	register struct proc *p;
	struct sem_undo **supptr;
	int semid, semnum;
	int adjval;
d86 2
a87 2
	register struct sem_undo *suptr;
	register struct undo *sunptr;
d90 3
a92 3
	/* Look for and remember the sem_undo if the caller doesn't provide
	   it */

d103 1
a103 1
				return(0);
d106 1
a106 1
				return(ENOSPC);
d123 26
a148 7
		if (sunptr->un_adjval == 0) {
			suptr->un_cnt--;
			if (i < suptr->un_cnt)
				suptr->un_ent[i] =
				    suptr->un_ent[suptr->un_cnt];
		}
		return(0);
d153 1
a153 1
		return(0);
d155 1
a155 1
		return(EINVAL);
d162 1
a162 1
	return(0);
d166 1
a166 2
semundo_clear(semid, semnum)
	int semid, semnum;
d168 3
a170 5
	register struct sem_undo *suptr;

	for (suptr = semu_list; suptr != NULL; suptr = suptr->un_next) {
		register struct undo *sunptr;
		register int i;
d172 1
d188 11
d203 1
a203 3
semid_n2o(n, o)
	struct semid_ds *n;
	struct osemid_ds *o;
d216 1
a216 4
sys___semctl(p, v, retval)
	struct proc *p;
	register void *v;
	register_t *retval;
d218 1
a218 1
	register struct sys___semctl_args /* {
d230 1
a230 1
	int i, rval, eval;
d232 1
a232 1
	register struct semid_ds *semaptr;
d240 1
a240 1
		return(EINVAL);
d242 1
a242 2
	semaptr = &sema[semid];
	if ((semaptr->sem_perm.mode & SEM_ALLOC) == 0 ||
d244 1
a244 1
		return(EINVAL);
d246 1
a246 2
	eval = 0;
	rval = 0;
d250 2
a251 2
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_M)) != 0)
			return(eval);
d255 3
a257 8
		for (i = semaptr->sem_base - sem; i < semtot; i++)
			sem[i] = sem[i + semaptr->sem_nsems];
		for (i = 0; i < seminfo.semmni; i++) {
			if ((sema[i].sem_perm.mode & SEM_ALLOC) &&
			    sema[i].sem_base > semaptr->sem_base)
				sema[i].sem_base -= semaptr->sem_nsems;
		}
		semaptr->sem_perm.mode = 0;
d259 1
a259 1
		wakeup((caddr_t)semaptr);
d263 5
a267 5
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_M)))
			return(eval);
		if ((eval = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return(eval);
		if ((eval = copyin(real_arg.buf, (caddr_t)&sbuf,
d269 1
a269 1
			return(eval);
d278 5
a282 5
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return(eval);
		if ((eval = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return(eval);
		eval = copyout((caddr_t)semaptr, real_arg.buf,
d287 2
a288 2
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return(eval);
d290 1
a290 1
			return(EINVAL);
d295 2
a296 2
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return(eval);
d298 1
a298 1
			return(EINVAL);
d303 2
a304 2
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return(eval);
d306 1
a306 1
			return(EINVAL);
d311 4
a314 4
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return(eval);
		if ((eval = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return(eval);
d316 1
a316 1
			eval = copyout((caddr_t)&semaptr->sem_base[i].semval,
d318 1
a318 1
			if (eval != 0)
d324 2
a325 2
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return(eval);
d327 1
a327 1
			return(EINVAL);
d332 2
a333 2
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_W)))
			return(eval);
d335 3
a337 3
			return(EINVAL);
		if ((eval = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return(eval);
d340 1
a340 1
		wakeup((caddr_t)semaptr);
d344 4
a347 4
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_W)))
			return(eval);
		if ((eval = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return(eval);
d349 1
a349 1
			eval = copyin(&real_arg.array[i],
d352 1
a352 1
			if (eval != 0)
d356 1
a356 1
		wakeup((caddr_t)semaptr);
d360 1
a360 1
		return(EINVAL);
d363 1
a363 1
	if (eval == 0)
d365 1
a365 1
	return(eval);
d369 1
a369 4
sys_semget(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d371 1
a371 1
	register struct sys_semget_args /* {
d376 1
a376 1
	int semid, eval;
d380 1
d387 12
d400 3
a402 3
		for (semid = 0; semid < seminfo.semmni; semid++) {
			if ((sema[semid].sem_perm.mode & SEM_ALLOC) &&
			    sema[semid].sem_perm.key == key)
d405 1
a405 1
		if (semid < seminfo.semmni) {
d409 1
a409 1
			if ((eval = ipcperm(cred, &sema[semid].sem_perm,
d411 2
a412 2
				return(eval);
			if (nsems > 0 && sema[semid].sem_nsems < nsems) {
d416 2
a417 1
				return(EINVAL);
d423 2
a424 1
				return(EEXIST);
d439 2
a440 1
			return(EINVAL);
d447 2
a448 1
			return(ENOSPC);
d451 1
a451 1
			if ((sema[semid].sem_perm.mode & SEM_ALLOC) == 0)
d458 2
a459 1
			return(ENOSPC);
d464 12
a475 19
		sema[semid].sem_perm.key = key;
		sema[semid].sem_perm.cuid = cred->cr_uid;
		sema[semid].sem_perm.uid = cred->cr_uid;
		sema[semid].sem_perm.cgid = cred->cr_gid;
		sema[semid].sem_perm.gid = cred->cr_gid;
		sema[semid].sem_perm.mode = (semflg & 0777) | SEM_ALLOC;
		sema[semid].sem_perm.seq =
		    (sema[semid].sem_perm.seq + 1) & 0x7fff;
		sema[semid].sem_nsems = nsems;
		sema[semid].sem_otime = 0;
		sema[semid].sem_ctime = time.tv_sec;
		sema[semid].sem_base = &sem[semtot];
		semtot += nsems;
		bzero(sema[semid].sem_base,
		    sizeof(sema[semid].sem_base[0])*nsems);
#ifdef SEM_DEBUG
		printf("sembase = %p, next = %p\n", sema[semid].sem_base,
		    &sem[semtot]);
#endif
d480 1
a480 1
		return(ENOENT);
d484 8
a491 2
	*retval = IXSEQ_TO_IPCID(semid, sema[semid].sem_perm);
	return(0);
d495 1
a495 4
sys_semop(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d497 1
a497 1
	register struct sys_semop_args /* {
d504 4
a507 4
	struct sembuf sops[MAX_SOPS];
	register struct semid_ds *semaptr;
	register struct sembuf *sopptr = NULL;
	register struct sem *semptr = NULL;
d510 1
a510 1
	int i, j, eval;
d520 1
a520 1
		return(EINVAL);
d522 1
a522 2
	semaptr = &sema[semid];
	if ((semaptr->sem_perm.mode & SEM_ALLOC) == 0 ||
d524 1
a524 1
		return(EINVAL);
d526 1
a526 1
	if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_W))) {
d528 1
a528 1
		printf("eval = %d from ipaccess\n", eval);
d530 1
a530 1
		return(eval);
d533 1
a533 1
	if (nsops > MAX_SOPS) {
d535 1
a535 1
		printf("too many sops (max=%d, nsops=%d)\n", MAX_SOPS, nsops);
d537 1
a537 1
		return(E2BIG);
d540 3
a542 2
	if ((eval = copyin(SCARG(uap, sops), sops, nsops * sizeof(sops[0])))
	    != 0) {
d544 2
a545 2
		printf("eval = %d from copyin(%p, %p, %d)\n", eval,
		    SCARG(uap, sops), &sops, nsops * sizeof(sops[0]));
d547 2
a548 1
		return(eval);
d568 4
a571 2
			if (sopptr->sem_num >= semaptr->sem_nsems)
				return(EFBIG);
d633 4
a636 2
		if (sopptr->sem_flg & IPC_NOWAIT)
			return(EAGAIN);
d646 1
a646 1
		eval = tsleep((caddr_t)semaptr, (PZERO - 4) | PCATCH,
d649 1
a649 1
		printf("semop:  good morning (eval=%d)!\n", eval);
d654 4
a657 2
		if (eval != 0)
			return(EINTR);
d665 1
a665 1
		if ((semaptr->sem_perm.mode & SEM_ALLOC) == 0 ||
d667 2
a668 7
			/* The man page says to return EIDRM. */
			/* Unfortunately, BSD doesn't define that code! */
#ifdef EIDRM
			return(EIDRM);
#else
			return(EINVAL);
#endif
d698 1
a698 1
			eval = semundo_adjust(p, &suptr, semid,
d700 1
a700 1
			if (eval == 0)
d704 1
a704 1
			 * Oh-Oh!  We ran out of either sem_undo's or undo's.
d728 1
a728 1
			printf("eval = %d from semundo_adjust\n", eval);
d730 2
a731 1
			return(eval);
d741 1
a746 4
#ifdef SEM_WAKEUP
		sem_wakeup((caddr_t)semaptr);
#else
		wakeup((caddr_t)semaptr);
d748 2
a750 2
#else
		wakeup((caddr_t)semaptr);
d757 1
a757 1
	return(0);
d765 1
a765 2
semexit(p)
	struct proc *p;
d767 2
a768 2
	register struct sem_undo *suptr;
	register struct sem_undo **supptr;
a773 1

a792 1

d810 1
a810 2
			semaptr = &sema[semid];
			if ((semaptr->sem_perm.mode & SEM_ALLOC) == 0)
d829 1
a829 5
#ifdef SEM_WAKEUP
			sem_wakeup((caddr_t)semaptr);
#else
			wakeup((caddr_t)semaptr);
#endif
a841 1
	suptr->un_proc = NULL;
d843 107
@


1.8
log
@Change nsops to u_int to match prototype as discussed with millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.7 2001/09/13 13:55:08 fgsch Exp $	*/
d28 3
a30 3
struct sem_undo *semu_alloc __P((struct proc *));
int semundo_adjust __P((struct proc *, struct sem_undo **, int, int, int));
void semundo_clear __P((int, int));
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.8 2001/09/13 14:07:14 fgsch Exp $	*/
d28 3
a30 3
struct sem_undo *semu_alloc(struct proc *);
int semundo_adjust(struct proc *, struct sem_undo **, int, int, int);
void semundo_clear(int, int);
@


1.8.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a4 26
 * Copyright (c) 2002 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
a16 1
#include <sys/sysctl.h>
a17 1
#include <sys/pool.h>
a21 11
/* SVID defines EIDRM but BSD does not */
#ifndef EIDRM
#define EIDRM	EINVAL
#endif

#ifdef SEM_DEBUG
#define DPRINTF(x)	printf x
#else
#define DPRINTF(x)
#endif

d23 4
a26 6
int	semutot = 0;
struct	semid_ds **sema;	/* semaphore id list */
struct	sem_undo *semu_list;	/* list of undo structures */
struct	pool sema_pool;		/* pool for struct semid_ds */
struct	pool semu_pool;		/* pool for struct sem_undo (SEMUSZ) */
unsigned short *semseqs;	/* array of sem sequence numbers */
d33 1
a33 1
seminit(void)
d35 1
d37 13
a49 10
	pool_init(&sema_pool, sizeof(struct semid_ds), 0, 0, 0, "semapl",
	    &pool_allocator_nointr);
	pool_init(&semu_pool, SEMUSZ, 0, 0, 0, "semupl",
	    &pool_allocator_nointr);
	sema = malloc(seminfo.semmni * sizeof(struct semid_ds *),
	    M_SEM, M_WAITOK);
	bzero(sema, seminfo.semmni * sizeof(struct semid_ds *));
	semseqs = malloc(seminfo.semmni * sizeof(unsigned short),
	    M_SEM, M_WAITOK);
	bzero(semseqs, seminfo.semmni * sizeof(unsigned short));
d58 2
a59 1
semu_alloc(struct proc *p)
d61 4
a64 4
	struct sem_undo *suptr, *tmp;

	if (semutot == seminfo.semmnu)
		return (NULL);		/* no space */
d67 3
a69 3
	 * Allocate a semu w/o waiting if possible.
	 * If we do have to wait, we must check to verify that a semu
	 * with un_proc == p has not been allocated in the meantime.
d71 35
a105 8
	semutot++;
	if ((suptr = pool_get(&semu_pool, 0)) == NULL) {
		tmp = pool_get(&semu_pool, PR_WAITOK);
		for (suptr = semu_list; suptr != NULL; suptr = suptr->un_next) {
			if (suptr->un_proc == p) {
				pool_put(&semu_pool, tmp);
				semutot--;
				return (suptr);
d107 11
a118 1
		suptr = tmp;
d120 1
a120 5
	suptr->un_cnt = 0;
	suptr->un_proc = p;
	suptr->un_next = semu_list;
	semu_list = suptr;
	return (suptr);
d127 5
a131 2
semundo_adjust(struct proc *p, struct sem_undo **supptr, int semid, int semnum,
	int adjval)
d133 2
a134 2
	struct sem_undo *suptr;
	struct undo *sunptr;
d137 3
a139 3
	/*
	 * Look for and remember the sem_undo if the caller doesn't provide it.
	 */
d150 1
a150 1
				return (0);
d153 1
a153 1
				return (ENOSPC);
d170 7
a176 27
		if (sunptr->un_adjval != 0)
			return (0);

		if (--suptr->un_cnt == 0) {
			struct sem_undo *suprev;

			if (semu_list == suptr)
				semu_list = suptr->un_next;
			else {
				/* this code path should be rare */
				for (suprev = semu_list; suprev != NULL &&
				    suprev->un_next != suptr;
				    suprev = suprev->un_next)
					/* NOTHING */;
#ifdef DIAGNOSTIC
				if (suprev == NULL)
					panic("semundo_adjust: "
					    "suptr not in semu_list");
#endif
				suprev->un_next = suptr->un_next;
			}
			pool_put(&semu_pool, suptr);
			semutot--;
		} else if (i < suptr->un_cnt)
			suptr->un_ent[i] =
			    suptr->un_ent[suptr->un_cnt];
		return (0);
d181 1
a181 1
		return (0);
d183 1
a183 1
		return (EINVAL);
d190 1
a190 1
	return (0);
d194 2
a195 1
semundo_clear(int semid, int semnum)
d197 5
a201 3
	struct sem_undo *suptr, *suprev, *tmp;
	struct undo *sunptr;
	int i;
a202 1
	for (suptr = semu_list; suptr != NULL; ) {
a217 12
		if (suptr->un_cnt == 0) {
			tmp = suptr;
			if (suptr == semu_list)
				suptr = semu_list = suptr->un_next;
			else
				suptr = suprev->un_next = suptr->un_next;
			pool_put(&semu_pool, tmp);
			semutot--;
		} else {
			suprev = suptr;
			suptr = suptr->un_next;
		}
d222 3
a224 1
semid_n2o(struct semid_ds *n, struct osemid_ds *o)
d237 4
a240 1
sys___semctl(struct proc *p, void *v, register_t *retval)
d242 1
a242 1
	struct sys___semctl_args /* {
d254 1
a254 1
	int i, rval, error;
d256 1
a256 1
	struct semid_ds *semaptr;
d258 3
a260 1
	DPRINTF(("call to semctl(%d, %d, %d, %p)\n", semid, semnum, cmd, arg));
d264 1
a264 1
		return (EINVAL);
d266 2
a267 1
	if ((semaptr = sema[semid]) == NULL ||
d269 1
a269 1
		return (EINVAL);
d271 2
a272 1
	error = rval = 0;
d276 2
a277 2
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_M)) != 0)
			return (error);
d281 8
a288 3
		free(semaptr->sem_base, M_SEM);
		pool_put(&sema_pool, semaptr);
		sema[semid] = NULL;
d290 1
a290 1
		wakeup((caddr_t)&sema[semid]);
d294 5
a298 5
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_M)))
			return (error);
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
		if ((error = copyin(real_arg.buf, (caddr_t)&sbuf,
d300 1
a300 1
			return (error);
d309 5
a313 5
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
		error = copyout((caddr_t)semaptr, real_arg.buf,
d318 2
a319 2
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
d321 1
a321 1
			return (EINVAL);
d326 2
a327 2
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
d329 1
a329 1
			return (EINVAL);
d334 2
a335 2
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
d337 1
a337 1
			return (EINVAL);
d342 4
a345 4
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
d347 1
a347 1
			error = copyout((caddr_t)&semaptr->sem_base[i].semval,
d349 1
a349 1
			if (error != 0)
d355 2
a356 2
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
d358 1
a358 1
			return (EINVAL);
d363 2
a364 2
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_W)))
			return (error);
d366 3
a368 3
			return (EINVAL);
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
d371 1
a371 1
		wakeup((caddr_t)&sema[semid]);
d375 4
a378 4
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_W)))
			return (error);
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
d380 1
a380 1
			error = copyin(&real_arg.array[i],
d383 1
a383 1
			if (error != 0)
d387 1
a387 1
		wakeup((caddr_t)&sema[semid]);
d391 1
a391 1
		return (EINVAL);
d394 1
a394 1
	if (error == 0)
d396 1
a396 1
	return (error);
d400 4
a403 1
sys_semget(struct proc *p, void *v, register_t *retval)
d405 1
a405 1
	struct sys_semget_args /* {
d410 1
a410 1
	int semid, error;
a413 1
	struct semid_ds *semaptr, *semaptr_new = NULL;
d416 3
a418 13
	DPRINTF(("semget(0x%x, %d, 0%o)\n", key, nsems, semflg));

	/*
	 * Preallocate space for the new semaphore.  If we are going
	 * to sleep, we want to sleep now to elliminate any race
	 * condition in allocating a semaphore with a specific key.
	 */
	if (key == IPC_PRIVATE || (semflg & IPC_CREAT)) {
		semaptr_new = pool_get(&sema_pool, PR_WAITOK);
		semaptr_new->sem_base = malloc(nsems * sizeof(struct sem),
		    M_SEM, M_WAITOK);
		bzero(semaptr_new->sem_base, nsems * sizeof(struct sem));
	}
d421 3
a423 3
		for (semid = 0, semaptr = NULL; semid < seminfo.semmni; semid++) {
			if ((semaptr = sema[semid]) != NULL &&
			    semaptr->sem_perm.key == key)
d426 5
a430 3
		if (semaptr != NULL) {
			DPRINTF(("found public key\n"));
			if ((error = ipcperm(cred, &semaptr->sem_perm,
d432 6
a437 5
				goto error;
			if (nsems > 0 && semaptr->sem_nsems < nsems) {
				DPRINTF(("too small\n"));
				error = EINVAL;
				goto error;
d440 4
a443 3
				DPRINTF(("not exclusive\n"));
				error = EEXIST;
				goto error;
d449 3
a451 1
	DPRINTF(("need to allocate the semid_ds\n"));
d454 5
a458 4
			DPRINTF(("nsems out of range (0<%d<=%d)\n", nsems,
			    seminfo.semmsl));
			error = EINVAL;
			goto error;
d461 5
a465 4
			DPRINTF(("not enough semaphores left (need %d, got %d)\n",
			    nsems, seminfo.semmns - semtot));
			error = ENOSPC;
			goto error;
d468 1
a468 1
			if ((semaptr = sema[semid]) == NULL)
d472 20
a491 17
			DPRINTF(("no more semid_ds's available\n"));
			error = ENOSPC;
			goto error;
		}
		DPRINTF(("semid %d is available\n", semid));
		semaptr_new->sem_perm.key = key;
		semaptr_new->sem_perm.cuid = cred->cr_uid;
		semaptr_new->sem_perm.uid = cred->cr_uid;
		semaptr_new->sem_perm.cgid = cred->cr_gid;
		semaptr_new->sem_perm.gid = cred->cr_gid;
		semaptr_new->sem_perm.mode = (semflg & 0777);
		semaptr_new->sem_perm.seq = semseqs[semid] =
		    (semseqs[semid] + 1) & 0x7fff;
		semaptr_new->sem_nsems = nsems;
		semaptr_new->sem_otime = 0;
		semaptr_new->sem_ctime = time.tv_sec;
		sema[semid] = semaptr_new;
d493 6
d500 4
a503 2
		DPRINTF(("didn't find it and wasn't asked to create it\n"));
		return (ENOENT);
d507 2
a508 8
	*retval = IXSEQ_TO_IPCID(semid, sema[semid]->sem_perm);
	return (0);
error:
	if (semaptr_new != NULL) {
		free(semaptr_new->sem_base, M_SEM);
		pool_put(&sema_pool, semaptr_new);
	}
	return (error);
d512 4
a515 1
sys_semop(struct proc *p, void *v, register_t *retval)
d517 1
a517 1
	struct sys_semop_args /* {
d524 4
a527 4
	struct sembuf *sops;
	struct semid_ds *semaptr;
	struct sembuf *sopptr = NULL;
	struct sem *semptr = NULL;
d530 1
a530 1
	int i, j, error;
d533 3
a535 1
	DPRINTF(("call to semop(%d, %p, %d)\n", semid, sops, nsops));
d540 1
a540 1
		return (EINVAL);
d542 2
a543 1
	if ((semaptr = sema[semid]) == NULL ||
d545 1
a545 1
		return (EINVAL);
d547 5
a551 3
	if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_W))) {
		DPRINTF(("error = %d from ipaccess\n", error));
		return (error);
d554 5
a558 3
	if (nsops > seminfo.semopm) {
		DPRINTF(("too many sops (max=%d, nsops=%d)\n", seminfo.semopm, nsops));
		return (E2BIG);
d561 7
a567 7
	sops = malloc(nsops * sizeof(struct sembuf), M_SEM, M_WAITOK);
	error = copyin(SCARG(uap, sops), sops, nsops * sizeof(struct sembuf));
	if (error != 0) {
		DPRINTF(("error = %d from copyin(%p, %p, %d)\n", error,
		    SCARG(uap, sops), &sops, nsops * sizeof(struct sembuf)));
		free(sops, M_SEM);
		return (error);
d587 2
a588 4
			if (sopptr->sem_num >= semaptr->sem_nsems) {
				free(sops, M_SEM);
				return (EFBIG);
			}
d592 2
a593 1
			DPRINTF(("semop:  semaptr=%x, sem_base=%x, semptr=%x, sem[%d]=%d : op=%d, flag=%s\n",
d596 2
a597 1
			    (sopptr->sem_flg & IPC_NOWAIT) ? "nowait" : "wait"));
d602 3
a604 1
					DPRINTF(("semop:  can't do it now\n"));
d616 3
a618 1
					DPRINTF(("semop:  not zero now\n"));
d639 3
a641 1
		DPRINTF(("semop:  rollback 0 through %d\n", i - 1));
d650 2
a651 4
		if (sopptr->sem_flg & IPC_NOWAIT) {
			free(sops, M_SEM);
			return (EAGAIN);
		}
d658 4
a661 2
		DPRINTF(("semop:  good night!\n"));
		error = tsleep((caddr_t)&sema[semid], PLOCK | PCATCH,
d663 3
a665 1
		DPRINTF(("semop:  good morning (error=%d)!\n", error));
d669 5
a673 5
		if (error != 0) {
			free(sops, M_SEM);
			return (EINTR);
		}
		DPRINTF(("semop:  good morning!\n"));
d678 1
a678 1
		if (sema[semid] == NULL ||
d680 7
a686 2
			free(sops, M_SEM);
			return (EIDRM);
d716 1
a716 1
			error = semundo_adjust(p, &suptr, semid,
d718 1
a718 1
			if (error == 0)
d722 1
a722 1
			 * Uh-Oh!  We ran out of either sem_undo's or undo's.
d745 4
a748 3
			DPRINTF(("error = %d from semundo_adjust\n", error));
			free(sops, M_SEM);
			return (error);
a757 1
	free(sops, M_SEM);
d761 11
a771 3
		DPRINTF(("semop:  doing wakeup\n"));
		wakeup((caddr_t)&sema[semid]);
		DPRINTF(("semop:  back from wakeup\n"));
d773 3
a775 1
	DPRINTF(("semop:  done\n"));
d777 1
a777 1
	return (0);
d785 2
a786 1
semexit(struct proc *p)
d788 2
a789 2
	struct sem_undo *suptr;
	struct sem_undo **supptr;
d795 1
d815 5
a819 2
	DPRINTF(("proc @@%p has undo structure with %d entries\n", p,
	    suptr->un_cnt));
d833 2
a834 1
			if ((semaptr = sema[semid]) == NULL)
d839 2
a840 1
			DPRINTF(("semexit:  %p id=%d num=%d(adj=%d) ; sem=%d\n",
d844 2
a845 1
			    semaptr->sem_base[semnum].semval));
d853 8
a860 2
			wakeup((caddr_t)&sema[semid]);
			DPRINTF(("semexit:  back from wakeup\n"));
d867 4
a870 1
	DPRINTF(("removing vector\n"));
a871 108
	pool_put(&semu_pool, suptr);
	semutot--;
}

/*
 * Userland access to struct seminfo.
 */
int
sysctl_sysvsem(int *name, u_int namelen, void *oldp, size_t *oldlenp,
	void *newp, size_t newlen)
{
	int error, val;
	struct semid_ds **sema_new;
	unsigned short *newseqs;

	if (namelen != 2) {
		switch (name[0]) {
		case KERN_SEMINFO_SEMMNI:
		case KERN_SEMINFO_SEMMNS:
		case KERN_SEMINFO_SEMMNU:
		case KERN_SEMINFO_SEMMSL:
		case KERN_SEMINFO_SEMOPM:
		case KERN_SEMINFO_SEMUME:
		case KERN_SEMINFO_SEMUSZ:
		case KERN_SEMINFO_SEMVMX:
		case KERN_SEMINFO_SEMAEM:
			break;
		default:
                        return (ENOTDIR);       /* overloaded */
                }
        }

	switch (name[0]) {
	case KERN_SEMINFO_SEMMNI:
		val = seminfo.semmni;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semmni)
			return (error);

		if (val < seminfo.semmni || val > 0xffff)
			return (EINVAL);

		/* Expand semsegs and semseqs arrays */
		sema_new = malloc(val * sizeof(struct semid_ds *),
		    M_SEM, M_WAITOK);
		bcopy(sema, sema_new,
		    seminfo.semmni * sizeof(struct semid_ds *));
		bzero(sema_new + seminfo.semmni,
		    (val - seminfo.semmni) * sizeof(struct semid_ds *));
		newseqs = malloc(val * sizeof(unsigned short), M_SEM, M_WAITOK);
		bcopy(semseqs, newseqs,
		    seminfo.semmni * sizeof(unsigned short));
		bzero(newseqs + seminfo.semmni,
		    (val - seminfo.semmni) * sizeof(unsigned short));
		free(sema, M_SEM);
		free(semseqs, M_SEM);
		sema = sema_new;
		semseqs = newseqs;
		seminfo.semmni = val;
		return (0);
	case KERN_SEMINFO_SEMMNS:
		val = seminfo.semmns;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semmns)
			return (error);
		if (val < seminfo.semmns)
			return (EINVAL);	/* can't decrease semmns */
		seminfo.semmns = val;
		return (0);
	case KERN_SEMINFO_SEMMNU:
		val = seminfo.semmnu;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semmnu)
			return (error);
		if (val < seminfo.semmnu)
			return (EINVAL);	/* can't decrease semmnu */
		seminfo.semmnu = val;
		return (0);
	case KERN_SEMINFO_SEMMSL:
		val = seminfo.semmsl;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semmsl)
			return (error);
		if (val < seminfo.semmsl)
			return (EINVAL);	/* can't decrease semmsl */
		seminfo.semmsl = val;
		return (0);
	case KERN_SEMINFO_SEMOPM:
		val = seminfo.semopm;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semopm)
			return (error);
		if (val <= 0)
			return (EINVAL);	/* semopm must be >= 1 */
		seminfo.semopm = val;
		return (0);
	case KERN_SEMINFO_SEMUME:
		return (sysctl_rdint(oldp, oldlenp, newp, seminfo.semume));
	case KERN_SEMINFO_SEMUSZ:
		return (sysctl_rdint(oldp, oldlenp, newp, seminfo.semusz));
	case KERN_SEMINFO_SEMVMX:
		return (sysctl_rdint(oldp, oldlenp, newp, seminfo.semvmx));
	case KERN_SEMINFO_SEMAEM:
		return (sysctl_rdint(oldp, oldlenp, newp, seminfo.semaem));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
@


1.7
log
@In sys_semop(), change local nsops to size_t to avoid ending with a
negative value if a sufficiently big number is used, thus passing the
check.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.6 2001/08/12 22:50:12 millert Exp $	*/
d523 1
a523 1
	size_t nsops = SCARG(uap, nsops);
@


1.6
log
@Don't allocate globals in include files, use extern declarations.
Move the actual variables into their respective .c files.
As a bonus, remove semmap which is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.5 2001/05/16 17:14:35 millert Exp $	*/
d523 1
a523 1
	int nsops = SCARG(uap, nsops);
@


1.5
log
@Create COMPAT_25 and move ogetfsstat, ostatfs and ostatfs into it.
Create COMPAT_23 and move __osemctl, omsgctl, oshmctl there.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.4 2000/05/01 23:12:30 deraadt Exp $	*/
d23 4
a56 1

a125 1

d159 2
a160 2
	 * Look for the requested entry and adjust it (delete if adjval becomes
	 * 0).
@


1.4
log
@sys_semconfig goes foom
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.3 1998/06/11 18:32:16 deraadt Exp $	*/
a231 163
}

int
sys___osemctl(p, v, retval)
	struct proc *p;
	register void *v;
	register_t *retval;
{
	register struct sys___semctl_args /* {
		syscallarg(int) semid;
		syscallarg(int) semnum;
		syscallarg(int) cmd;
		syscallarg(union semun *) arg;
	} */ *uap = v;
	int semid = SCARG(uap, semid);
	int semnum = SCARG(uap, semnum);
	int cmd = SCARG(uap, cmd);
	union semun *arg = SCARG(uap, arg);
	union semun real_arg;
	struct ucred *cred = p->p_ucred;
	int i, rval, eval;
	struct semid_ds *semaptr;
	struct osemid_ds osbuf;

#ifdef SEM_DEBUG
	printf("call to semctl(%d, %d, %d, %p)\n", semid, semnum, cmd, arg);
#endif

	semid = IPCID_TO_IX(semid);
	if (semid < 0 || semid >= seminfo.semmsl)
		return(EINVAL);

	semaptr = &sema[semid];
	if ((semaptr->sem_perm.mode & SEM_ALLOC) == 0 ||
	    semaptr->sem_perm.seq != IPCID_TO_SEQ(SCARG(uap, semid)))
		return(EINVAL);

	eval = 0;
	rval = 0;

	switch (cmd) {
	case IPC_RMID:
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_M)) != 0)
			return(eval);
		semaptr->sem_perm.cuid = cred->cr_uid;
		semaptr->sem_perm.uid = cred->cr_uid;
		semtot -= semaptr->sem_nsems;
		for (i = semaptr->sem_base - sem; i < semtot; i++)
			sem[i] = sem[i + semaptr->sem_nsems];
		for (i = 0; i < seminfo.semmni; i++) {
			if ((sema[i].sem_perm.mode & SEM_ALLOC) &&
			    sema[i].sem_base > semaptr->sem_base)
				sema[i].sem_base -= semaptr->sem_nsems;
		}
		semaptr->sem_perm.mode = 0;
		semundo_clear(semid, -1);
		wakeup((caddr_t)semaptr);
		break;

	case IPC_SET:
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_M)))
			return(eval);
		if ((eval = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return(eval);
		if ((eval = copyin(real_arg.buf, (caddr_t)&osbuf,
		    sizeof(osbuf))) != 0)
			return(eval);
		semaptr->sem_perm.uid = osbuf.sem_perm.uid;
		semaptr->sem_perm.gid = osbuf.sem_perm.gid;
		semaptr->sem_perm.mode = (semaptr->sem_perm.mode & ~0777) |
		    (osbuf.sem_perm.mode & 0777);
		semaptr->sem_ctime = time.tv_sec;
		break;

	case IPC_STAT:
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return(eval);
		if ((eval = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return(eval);
		semid_n2o(semaptr, &osbuf);
		eval = copyout((caddr_t)&osbuf, real_arg.buf, sizeof osbuf);
		break;

	case GETNCNT:
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return(eval);
		if (semnum < 0 || semnum >= semaptr->sem_nsems)
			return(EINVAL);
		rval = semaptr->sem_base[semnum].semncnt;
		break;

	case GETPID:
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return(eval);
		if (semnum < 0 || semnum >= semaptr->sem_nsems)
			return(EINVAL);
		rval = semaptr->sem_base[semnum].sempid;
		break;

	case GETVAL:
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return(eval);
		if (semnum < 0 || semnum >= semaptr->sem_nsems)
			return(EINVAL);
		rval = semaptr->sem_base[semnum].semval;
		break;

	case GETALL:
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return(eval);
		if ((eval = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return(eval);
		for (i = 0; i < semaptr->sem_nsems; i++) {
			eval = copyout((caddr_t)&semaptr->sem_base[i].semval,
			    &real_arg.array[i], sizeof(real_arg.array[0]));
			if (eval != 0)
				break;
		}
		break;

	case GETZCNT:
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return(eval);
		if (semnum < 0 || semnum >= semaptr->sem_nsems)
			return(EINVAL);
		rval = semaptr->sem_base[semnum].semzcnt;
		break;

	case SETVAL:
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_W)))
			return(eval);
		if (semnum < 0 || semnum >= semaptr->sem_nsems)
			return(EINVAL);
		if ((eval = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return(eval);
		semaptr->sem_base[semnum].semval = real_arg.val;
		semundo_clear(semid, semnum);
		wakeup((caddr_t)semaptr);
		break;

	case SETALL:
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_W)))
			return(eval);
		if ((eval = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return(eval);
		for (i = 0; i < semaptr->sem_nsems; i++) {
			eval = copyin(&real_arg.array[i],
			    (caddr_t)&semaptr->sem_base[i].semval,
			    sizeof(real_arg.array[0]));
			if (eval != 0)
				break;
		}
		semundo_clear(semid, -1);
		wakeup((caddr_t)semaptr);
		break;

	default:
		return(EINVAL);
	}

	if (eval == 0)
		*retval = rval;
	return(eval);
@


1.4.6.1
log
@MFS (from millert):
Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.4 2000/05/01 23:12:30 deraadt Exp $	*/
d684 1
a684 1
	u_int nsops = SCARG(uap, nsops);
@


1.4.4.1
log
@MFC:
Add some missing lengths checks when passing data from userland to the
kernel. From NetBSD via millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.8 2001/09/13 14:07:14 fgsch Exp $	*/
d684 1
a684 1
	u_int nsops = SCARG(uap, nsops);
@


1.3
log
@change ipc.h to use uid_t and friends, and then build compat system calls for the old ushort based ipc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.2 1996/03/03 17:20:06 niklas Exp $	*/
a22 1
struct	proc *semlock_holder = NULL;
a23 1
void semlock __P((struct proc *));
a48 59
void
semlock(p)
	struct proc *p;
{

	while (semlock_holder != NULL && semlock_holder != p)
		sleep((caddr_t)&semlock_holder, (PZERO - 4));
}

/*
 * Lock or unlock the entire semaphore facility.
 *
 * This will probably eventually evolve into a general purpose semaphore
 * facility status enquiry mechanism (I don't like the "read /dev/kmem"
 * approach currently taken by ipcs and the amount of info that we want
 * to be able to extract for ipcs is probably beyond the capability of
 * the getkerninfo facility.
 *
 * At the time that the current version of semconfig was written, ipcs is
 * the only user of the semconfig facility.  It uses it to ensure that the
 * semaphore facility data structures remain static while it fishes around
 * in /dev/kmem.
 */

int
sys_semconfig(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_semconfig_args /* {
		syscallarg(int) flag;
	} */ *uap = v;
	int eval = 0;

	semlock(p);

	switch (SCARG(uap, flag)) {
	case SEM_CONFIG_FREEZE:
		semlock_holder = p;
		break;

	case SEM_CONFIG_THAW:
		semlock_holder = NULL;
		wakeup((caddr_t)&semlock_holder);
		break;

	default:
		printf(
		    "semconfig: unknown flag parameter value (%d) - ignored\n",
		    SCARG(uap, flag));
		eval = EINVAL;
		break;
	}

	*retval = 0;
	return(eval);
}

a259 2
	semlock(p);

a422 2
	semlock(p);

a580 2
	semlock(p);

a697 2
	semlock(p);

d964 1
a964 20
	 * There are a few possibilities to consider here ...
	 *
	 * 1) The semaphore facility isn't currently locked.  In this case,
	 *    this call should proceed normally.
	 * 2) The semaphore facility is locked by this process (i.e. the one
	 *    that is exiting).  In this case, this call should proceed as
	 *    usual and the facility should be unlocked at the end of this
	 *    routine (since the locker is exiting).
	 * 3) The semaphore facility is locked by some other process and this
	 *    process doesn't have an undo structure allocated for it.  In this
	 *    case, this call should proceed normally (i.e. not accomplish
	 *    anything and, most importantly, not block since that is
	 *    unnecessary and could result in a LOT of processes blocking in
	 *    here if the facility is locked for a long time).
	 * 4) The semaphore facility is locked by some other process and this
	 *    process has an undo structure allocated for it.  In this case,
	 *    this call should block until the facility has been unlocked since
	 *    the holder of the lock may be examining this process's proc entry
	 *    (the ipcs utility does this when printing out the information
	 *    from the allocated sem undo elements).
d966 2
a967 12
	 * This leads to the conclusion that we should not block unless we
	 * discover that the someone else has the semaphore facility locked and
	 * this process has an undo structure.  Let's do that...
	 *
	 * Note that we do this in a separate pass from the one that processes
	 * any existing undo structure since we don't want to risk blocking at
	 * that time (it would make the actual unlinking of the element from
	 * the chain of allocated undo structures rather messy).
	 */

	/*
	 * Does someone else hold the semaphore facility's lock?
d969 2
a970 54

	if (semlock_holder != NULL && semlock_holder != p) {
		/*
		 * Yes (i.e. we are in case 3 or 4).
		 *
		 * If we didn't find an undo vector associated with this
		 * process than we can just return (i.e. we are in case 3).
		 *
		 * Note that we know that someone else is holding the lock so
		 * we don't even have to see if we're holding it...
		 */

		if (suptr == NULL)
			return;

		/*
		 * We are in case 4.
		 *
		 * Go to sleep as long as someone else is locking the semaphore
		 * facility (note that we won't get here if we are holding the
		 * lock so we don't need to check for that possibility).
		 */

		while (semlock_holder != NULL)
			sleep((caddr_t)&semlock_holder, (PZERO - 4));

		/*
		 * Nobody is holding the facility (i.e. we are now in case 1).
		 * We can proceed safely according to the argument outlined
		 * above.
		 *
		 * We look up the undo vector again, in case the list changed
		 * while we were asleep, and the parent is now different.
		 */

		for (supptr = &semu_list; (suptr = *supptr) != NULL;
		    supptr = &suptr->un_next) {
			if (suptr->un_proc == p)
				break;
		}

		if (suptr == NULL)
			panic("semexit: undo vector disappeared");
	} else {
		/*
		 * No (i.e. we are in case 1 or 2).
		 *
		 * If there is no undo vector, skip to the end and unlock the
		 * semaphore facility if necessary.
		 */

		if (suptr == NULL)
			goto unlock;
	}
a1032 10

unlock:
	/*
	 * If the exiting process is holding the global semaphore facility
	 * lock (i.e. we are in case 2) then release it.
	 */
	if (semlock_holder == p) {
		semlock_holder = NULL;
		wakeup((caddr_t)&semlock_holder);
	}
@


1.3.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.4 2000/05/01 23:12:30 deraadt Exp $	*/
d23 1
d25 1
d51 59
d321 2
d486 2
d646 2
d765 2
d1033 20
a1052 1
	 * No (i.e. we are in case 1 or 2).
d1054 12
a1065 2
	 * If there is no undo vector, skip to the end and unlock the
	 * semaphore facility if necessary.
d1067 54
a1120 2
	if (suptr == NULL)
		return;
d1183 10
@


1.3.8.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.3.8.1 2001/05/14 22:32:44 niklas Exp $	*/
d232 163
@


1.3.8.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.3.8.2 2001/07/04 10:48:40 niklas Exp $	*/
a22 4
struct	semid_ds *sema;		/* semaphore id pool */
struct	sem *sem;		/* semaphore pool */
struct	sem_undo *semu_list;	/* list of active undo structures */
int	*semu;			/* undo structure pool */
d53 1
d123 1
d157 2
a158 2
	 * Look for the requested entry and adjust it
	 * (delete if adjval becomes 0).
d521 1
a521 1
	u_int nsops = SCARG(uap, nsops);
@


1.3.8.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 3
a30 3
struct sem_undo *semu_alloc(struct proc *);
int semundo_adjust(struct proc *, struct sem_undo **, int, int, int);
void semundo_clear(int, int);
@


1.3.8.5
log
@Sync the SMP branch with 3.3
@
text
@a4 26
 * Copyright (c) 2002 Todd C. Miller <Todd.Miller@@courtesan.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
a16 1
#include <sys/sysctl.h>
a17 1
#include <sys/pool.h>
a21 11
/* SVID defines EIDRM but BSD does not */
#ifndef EIDRM
#define EIDRM	EINVAL
#endif

#ifdef SEM_DEBUG
#define DPRINTF(x)	printf x
#else
#define DPRINTF(x)
#endif

d23 4
a26 6
int	semutot = 0;
struct	semid_ds **sema;	/* semaphore id list */
struct	sem_undo *semu_list;	/* list of undo structures */
struct	pool sema_pool;		/* pool for struct semid_ds */
struct	pool semu_pool;		/* pool for struct sem_undo (SEMUSZ) */
unsigned short *semseqs;	/* array of sem sequence numbers */
d33 1
a33 1
seminit(void)
d35 1
d37 13
a49 10
	pool_init(&sema_pool, sizeof(struct semid_ds), 0, 0, 0, "semapl",
	    &pool_allocator_nointr);
	pool_init(&semu_pool, SEMUSZ, 0, 0, 0, "semupl",
	    &pool_allocator_nointr);
	sema = malloc(seminfo.semmni * sizeof(struct semid_ds *),
	    M_SEM, M_WAITOK);
	bzero(sema, seminfo.semmni * sizeof(struct semid_ds *));
	semseqs = malloc(seminfo.semmni * sizeof(unsigned short),
	    M_SEM, M_WAITOK);
	bzero(semseqs, seminfo.semmni * sizeof(unsigned short));
d58 2
a59 1
semu_alloc(struct proc *p)
d61 4
a64 4
	struct sem_undo *suptr, *tmp;

	if (semutot == seminfo.semmnu)
		return (NULL);		/* no space */
d67 3
a69 3
	 * Allocate a semu w/o waiting if possible.
	 * If we do have to wait, we must check to verify that a semu
	 * with un_proc == p has not been allocated in the meantime.
d71 35
a105 8
	semutot++;
	if ((suptr = pool_get(&semu_pool, 0)) == NULL) {
		tmp = pool_get(&semu_pool, PR_WAITOK);
		for (suptr = semu_list; suptr != NULL; suptr = suptr->un_next) {
			if (suptr->un_proc == p) {
				pool_put(&semu_pool, tmp);
				semutot--;
				return (suptr);
d107 11
a118 1
		suptr = tmp;
d120 1
a120 5
	suptr->un_cnt = 0;
	suptr->un_proc = p;
	suptr->un_next = semu_list;
	semu_list = suptr;
	return (suptr);
d127 5
a131 2
semundo_adjust(struct proc *p, struct sem_undo **supptr, int semid, int semnum,
	int adjval)
d133 2
a134 2
	struct sem_undo *suptr;
	struct undo *sunptr;
d137 3
a139 3
	/*
	 * Look for and remember the sem_undo if the caller doesn't provide it.
	 */
d150 1
a150 1
				return (0);
d153 1
a153 1
				return (ENOSPC);
d170 7
a176 27
		if (sunptr->un_adjval != 0)
			return (0);

		if (--suptr->un_cnt == 0) {
			struct sem_undo *suprev;

			if (semu_list == suptr)
				semu_list = suptr->un_next;
			else {
				/* this code path should be rare */
				for (suprev = semu_list; suprev != NULL &&
				    suprev->un_next != suptr;
				    suprev = suprev->un_next)
					/* NOTHING */;
#ifdef DIAGNOSTIC
				if (suprev == NULL)
					panic("semundo_adjust: "
					    "suptr not in semu_list");
#endif
				suprev->un_next = suptr->un_next;
			}
			pool_put(&semu_pool, suptr);
			semutot--;
		} else if (i < suptr->un_cnt)
			suptr->un_ent[i] =
			    suptr->un_ent[suptr->un_cnt];
		return (0);
d181 1
a181 1
		return (0);
d183 1
a183 1
		return (EINVAL);
d190 1
a190 1
	return (0);
d194 2
a195 1
semundo_clear(int semid, int semnum)
d197 5
a201 3
	struct sem_undo *suptr, *suprev, *tmp;
	struct undo *sunptr;
	int i;
a202 1
	for (suptr = semu_list; suptr != NULL; ) {
a217 12
		if (suptr->un_cnt == 0) {
			tmp = suptr;
			if (suptr == semu_list)
				suptr = semu_list = suptr->un_next;
			else
				suptr = suprev->un_next = suptr->un_next;
			pool_put(&semu_pool, tmp);
			semutot--;
		} else {
			suprev = suptr;
			suptr = suptr->un_next;
		}
d222 3
a224 1
semid_n2o(struct semid_ds *n, struct osemid_ds *o)
d237 4
a240 1
sys___semctl(struct proc *p, void *v, register_t *retval)
d242 1
a242 1
	struct sys___semctl_args /* {
d254 1
a254 1
	int i, rval, error;
d256 1
a256 1
	struct semid_ds *semaptr;
d258 3
a260 1
	DPRINTF(("call to semctl(%d, %d, %d, %p)\n", semid, semnum, cmd, arg));
d264 1
a264 1
		return (EINVAL);
d266 2
a267 1
	if ((semaptr = sema[semid]) == NULL ||
d269 1
a269 1
		return (EINVAL);
d271 2
a272 1
	error = rval = 0;
d276 2
a277 2
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_M)) != 0)
			return (error);
d281 8
a288 3
		free(semaptr->sem_base, M_SEM);
		pool_put(&sema_pool, semaptr);
		sema[semid] = NULL;
d290 1
a290 1
		wakeup((caddr_t)&sema[semid]);
d294 5
a298 5
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_M)))
			return (error);
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
		if ((error = copyin(real_arg.buf, (caddr_t)&sbuf,
d300 1
a300 1
			return (error);
d309 5
a313 5
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
		error = copyout((caddr_t)semaptr, real_arg.buf,
d318 2
a319 2
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
d321 1
a321 1
			return (EINVAL);
d326 2
a327 2
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
d329 1
a329 1
			return (EINVAL);
d334 2
a335 2
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
d337 1
a337 1
			return (EINVAL);
d342 4
a345 4
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
d347 1
a347 1
			error = copyout((caddr_t)&semaptr->sem_base[i].semval,
d349 1
a349 1
			if (error != 0)
d355 2
a356 2
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_R)))
			return (error);
d358 1
a358 1
			return (EINVAL);
d363 2
a364 2
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_W)))
			return (error);
d366 3
a368 3
			return (EINVAL);
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
d371 1
a371 1
		wakeup((caddr_t)&sema[semid]);
d375 4
a378 4
		if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_W)))
			return (error);
		if ((error = copyin(arg, &real_arg, sizeof(real_arg))) != 0)
			return (error);
d380 1
a380 1
			error = copyin(&real_arg.array[i],
d383 1
a383 1
			if (error != 0)
d387 1
a387 1
		wakeup((caddr_t)&sema[semid]);
d391 1
a391 1
		return (EINVAL);
d394 1
a394 1
	if (error == 0)
d396 1
a396 1
	return (error);
d400 4
a403 1
sys_semget(struct proc *p, void *v, register_t *retval)
d405 1
a405 1
	struct sys_semget_args /* {
d410 1
a410 1
	int semid, error;
a413 1
	struct semid_ds *semaptr, *semaptr_new = NULL;
d416 3
a418 13
	DPRINTF(("semget(0x%x, %d, 0%o)\n", key, nsems, semflg));

	/*
	 * Preallocate space for the new semaphore.  If we are going
	 * to sleep, we want to sleep now to elliminate any race
	 * condition in allocating a semaphore with a specific key.
	 */
	if (key == IPC_PRIVATE || (semflg & IPC_CREAT)) {
		semaptr_new = pool_get(&sema_pool, PR_WAITOK);
		semaptr_new->sem_base = malloc(nsems * sizeof(struct sem),
		    M_SEM, M_WAITOK);
		bzero(semaptr_new->sem_base, nsems * sizeof(struct sem));
	}
d421 3
a423 3
		for (semid = 0, semaptr = NULL; semid < seminfo.semmni; semid++) {
			if ((semaptr = sema[semid]) != NULL &&
			    semaptr->sem_perm.key == key)
d426 5
a430 3
		if (semaptr != NULL) {
			DPRINTF(("found public key\n"));
			if ((error = ipcperm(cred, &semaptr->sem_perm,
d432 6
a437 5
				goto error;
			if (nsems > 0 && semaptr->sem_nsems < nsems) {
				DPRINTF(("too small\n"));
				error = EINVAL;
				goto error;
d440 4
a443 3
				DPRINTF(("not exclusive\n"));
				error = EEXIST;
				goto error;
d449 3
a451 1
	DPRINTF(("need to allocate the semid_ds\n"));
d454 5
a458 4
			DPRINTF(("nsems out of range (0<%d<=%d)\n", nsems,
			    seminfo.semmsl));
			error = EINVAL;
			goto error;
d461 5
a465 4
			DPRINTF(("not enough semaphores left (need %d, got %d)\n",
			    nsems, seminfo.semmns - semtot));
			error = ENOSPC;
			goto error;
d468 1
a468 1
			if ((semaptr = sema[semid]) == NULL)
d472 20
a491 17
			DPRINTF(("no more semid_ds's available\n"));
			error = ENOSPC;
			goto error;
		}
		DPRINTF(("semid %d is available\n", semid));
		semaptr_new->sem_perm.key = key;
		semaptr_new->sem_perm.cuid = cred->cr_uid;
		semaptr_new->sem_perm.uid = cred->cr_uid;
		semaptr_new->sem_perm.cgid = cred->cr_gid;
		semaptr_new->sem_perm.gid = cred->cr_gid;
		semaptr_new->sem_perm.mode = (semflg & 0777);
		semaptr_new->sem_perm.seq = semseqs[semid] =
		    (semseqs[semid] + 1) & 0x7fff;
		semaptr_new->sem_nsems = nsems;
		semaptr_new->sem_otime = 0;
		semaptr_new->sem_ctime = time.tv_sec;
		sema[semid] = semaptr_new;
d493 6
d500 4
a503 2
		DPRINTF(("didn't find it and wasn't asked to create it\n"));
		return (ENOENT);
d507 2
a508 8
	*retval = IXSEQ_TO_IPCID(semid, sema[semid]->sem_perm);
	return (0);
error:
	if (semaptr_new != NULL) {
		free(semaptr_new->sem_base, M_SEM);
		pool_put(&sema_pool, semaptr_new);
	}
	return (error);
d512 4
a515 1
sys_semop(struct proc *p, void *v, register_t *retval)
d517 1
a517 1
	struct sys_semop_args /* {
d524 4
a527 4
	struct sembuf *sops;
	struct semid_ds *semaptr;
	struct sembuf *sopptr = NULL;
	struct sem *semptr = NULL;
d530 1
a530 1
	int i, j, error;
d533 3
a535 1
	DPRINTF(("call to semop(%d, %p, %d)\n", semid, sops, nsops));
d540 1
a540 1
		return (EINVAL);
d542 2
a543 1
	if ((semaptr = sema[semid]) == NULL ||
d545 1
a545 1
		return (EINVAL);
d547 5
a551 3
	if ((error = ipcperm(cred, &semaptr->sem_perm, IPC_W))) {
		DPRINTF(("error = %d from ipaccess\n", error));
		return (error);
d554 5
a558 3
	if (nsops > seminfo.semopm) {
		DPRINTF(("too many sops (max=%d, nsops=%d)\n", seminfo.semopm, nsops));
		return (E2BIG);
d561 7
a567 7
	sops = malloc(nsops * sizeof(struct sembuf), M_SEM, M_WAITOK);
	error = copyin(SCARG(uap, sops), sops, nsops * sizeof(struct sembuf));
	if (error != 0) {
		DPRINTF(("error = %d from copyin(%p, %p, %d)\n", error,
		    SCARG(uap, sops), &sops, nsops * sizeof(struct sembuf)));
		free(sops, M_SEM);
		return (error);
d587 2
a588 4
			if (sopptr->sem_num >= semaptr->sem_nsems) {
				free(sops, M_SEM);
				return (EFBIG);
			}
d592 2
a593 1
			DPRINTF(("semop:  semaptr=%x, sem_base=%x, semptr=%x, sem[%d]=%d : op=%d, flag=%s\n",
d596 2
a597 1
			    (sopptr->sem_flg & IPC_NOWAIT) ? "nowait" : "wait"));
d602 3
a604 1
					DPRINTF(("semop:  can't do it now\n"));
d616 3
a618 1
					DPRINTF(("semop:  not zero now\n"));
d639 3
a641 1
		DPRINTF(("semop:  rollback 0 through %d\n", i - 1));
d650 2
a651 4
		if (sopptr->sem_flg & IPC_NOWAIT) {
			free(sops, M_SEM);
			return (EAGAIN);
		}
d658 4
a661 2
		DPRINTF(("semop:  good night!\n"));
		error = tsleep((caddr_t)&sema[semid], PLOCK | PCATCH,
d663 3
a665 1
		DPRINTF(("semop:  good morning (error=%d)!\n", error));
d669 5
a673 5
		if (error != 0) {
			free(sops, M_SEM);
			return (EINTR);
		}
		DPRINTF(("semop:  good morning!\n"));
d678 1
a678 1
		if (sema[semid] == NULL ||
d680 7
a686 2
			free(sops, M_SEM);
			return (EIDRM);
d716 1
a716 1
			error = semundo_adjust(p, &suptr, semid,
d718 1
a718 1
			if (error == 0)
d722 1
a722 1
			 * Uh-Oh!  We ran out of either sem_undo's or undo's.
d745 4
a748 3
			DPRINTF(("error = %d from semundo_adjust\n", error));
			free(sops, M_SEM);
			return (error);
a757 1
	free(sops, M_SEM);
d761 11
a771 3
		DPRINTF(("semop:  doing wakeup\n"));
		wakeup((caddr_t)&sema[semid]);
		DPRINTF(("semop:  back from wakeup\n"));
d773 3
a775 1
	DPRINTF(("semop:  done\n"));
d777 1
a777 1
	return (0);
d785 2
a786 1
semexit(struct proc *p)
d788 2
a789 2
	struct sem_undo *suptr;
	struct sem_undo **supptr;
d795 1
d815 5
a819 2
	DPRINTF(("proc @@%p has undo structure with %d entries\n", p,
	    suptr->un_cnt));
d833 2
a834 1
			if ((semaptr = sema[semid]) == NULL)
d839 2
a840 1
			DPRINTF(("semexit:  %p id=%d num=%d(adj=%d) ; sem=%d\n",
d844 2
a845 1
			    semaptr->sem_base[semnum].semval));
d853 8
a860 2
			wakeup((caddr_t)&sema[semid]);
			DPRINTF(("semexit:  back from wakeup\n"));
d867 4
a870 1
	DPRINTF(("removing vector\n"));
a871 108
	pool_put(&semu_pool, suptr);
	semutot--;
}

/*
 * Userland access to struct seminfo.
 */
int
sysctl_sysvsem(int *name, u_int namelen, void *oldp, size_t *oldlenp,
	void *newp, size_t newlen)
{
	int error, val;
	struct semid_ds **sema_new;
	unsigned short *newseqs;

	if (namelen != 2) {
		switch (name[0]) {
		case KERN_SEMINFO_SEMMNI:
		case KERN_SEMINFO_SEMMNS:
		case KERN_SEMINFO_SEMMNU:
		case KERN_SEMINFO_SEMMSL:
		case KERN_SEMINFO_SEMOPM:
		case KERN_SEMINFO_SEMUME:
		case KERN_SEMINFO_SEMUSZ:
		case KERN_SEMINFO_SEMVMX:
		case KERN_SEMINFO_SEMAEM:
			break;
		default:
                        return (ENOTDIR);       /* overloaded */
                }
        }

	switch (name[0]) {
	case KERN_SEMINFO_SEMMNI:
		val = seminfo.semmni;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semmni)
			return (error);

		if (val < seminfo.semmni || val > 0xffff)
			return (EINVAL);

		/* Expand semsegs and semseqs arrays */
		sema_new = malloc(val * sizeof(struct semid_ds *),
		    M_SEM, M_WAITOK);
		bcopy(sema, sema_new,
		    seminfo.semmni * sizeof(struct semid_ds *));
		bzero(sema_new + seminfo.semmni,
		    (val - seminfo.semmni) * sizeof(struct semid_ds *));
		newseqs = malloc(val * sizeof(unsigned short), M_SEM, M_WAITOK);
		bcopy(semseqs, newseqs,
		    seminfo.semmni * sizeof(unsigned short));
		bzero(newseqs + seminfo.semmni,
		    (val - seminfo.semmni) * sizeof(unsigned short));
		free(sema, M_SEM);
		free(semseqs, M_SEM);
		sema = sema_new;
		semseqs = newseqs;
		seminfo.semmni = val;
		return (0);
	case KERN_SEMINFO_SEMMNS:
		val = seminfo.semmns;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semmns)
			return (error);
		if (val < seminfo.semmns)
			return (EINVAL);	/* can't decrease semmns */
		seminfo.semmns = val;
		return (0);
	case KERN_SEMINFO_SEMMNU:
		val = seminfo.semmnu;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semmnu)
			return (error);
		if (val < seminfo.semmnu)
			return (EINVAL);	/* can't decrease semmnu */
		seminfo.semmnu = val;
		return (0);
	case KERN_SEMINFO_SEMMSL:
		val = seminfo.semmsl;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semmsl)
			return (error);
		if (val < seminfo.semmsl)
			return (EINVAL);	/* can't decrease semmsl */
		seminfo.semmsl = val;
		return (0);
	case KERN_SEMINFO_SEMOPM:
		val = seminfo.semopm;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)) ||
		    val == seminfo.semopm)
			return (error);
		if (val <= 0)
			return (EINVAL);	/* semopm must be >= 1 */
		seminfo.semopm = val;
		return (0);
	case KERN_SEMINFO_SEMUME:
		return (sysctl_rdint(oldp, oldlenp, newp, seminfo.semume));
	case KERN_SEMINFO_SEMUSZ:
		return (sysctl_rdint(oldp, oldlenp, newp, seminfo.semusz));
	case KERN_SEMINFO_SEMVMX:
		return (sysctl_rdint(oldp, oldlenp, newp, seminfo.semvmx));
	case KERN_SEMINFO_SEMAEM:
		return (sysctl_rdint(oldp, oldlenp, newp, seminfo.semaem));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
@


1.3.8.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_sem.c,v 1.3.8.5 2003/03/28 00:41:27 niklas Exp $	*/
d6 1
d8 10
a17 3
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
d19 10
a28 7
 * THE SOFTWARE IS PROVIDED "AS IS" AND TODD C. MILLER DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL TODD C. MILLER BE LIABLE
 * FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.3.8.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 1
a5 1
 * Copyright (c) 2002,2003 Todd C. Miller <Todd.Miller@@courtesan.com>
d11 7
a17 11
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F39502-99-1-0512.
d53 1
a53 1
SLIST_HEAD(, sem_undo) semu_list; /* list of undo structures */
d76 1
a76 1
	SLIST_INIT(&semu_list);
d86 1
a86 1
	struct sem_undo *suptr, *sutmp;
d98 2
a99 2
		sutmp = pool_get(&semu_pool, PR_WAITOK);
		SLIST_FOREACH(suptr, &semu_list, un_next) {
d101 1
a101 1
				pool_put(&semu_pool, sutmp);
d106 1
a106 1
		suptr = sutmp;
d110 2
a111 1
	SLIST_INSERT_HEAD(&semu_list, suptr, un_next);
d131 1
a131 1
		SLIST_FOREACH(suptr, &semu_list, un_next) {
d163 17
a179 1
			SLIST_REMOVE(&semu_list, suptr, sem_undo, un_next);
d205 1
a205 2
	struct sem_undo *suptr = SLIST_FIRST(&semu_list);
	struct sem_undo *suprev = SLIST_END(&semu_list);
d209 1
a209 1
	while (suptr != SLIST_END(&semu_list)) {
d226 3
a228 4
			struct sem_undo *sutmp = suptr;

			if (suptr == SLIST_FIRST(&semu_list))
				SLIST_REMOVE_HEAD(&semu_list, un_next);
d230 2
a231 3
				SLIST_REMOVE_NEXT(&semu_list, suprev, un_next);
			suptr = SLIST_NEXT(suptr, un_next);
			pool_put(&semu_pool, sutmp);
d235 1
a235 1
			suptr = SLIST_NEXT(suptr, un_next);
d275 1
a275 1
	if (semid < 0 || semid >= seminfo.semmni)
d295 1
a295 1
		wakeup(&sema[semid]);
d303 2
a304 1
		if ((error = copyin(real_arg.buf, &sbuf, sizeof(sbuf))) != 0)
d318 2
a319 1
		error = copyout(semaptr, real_arg.buf, sizeof(struct semid_ds));
d352 1
a352 1
			error = copyout(&semaptr->sem_base[i].semval,
d376 1
a376 1
		wakeup(&sema[semid]);
d386 1
a386 1
			    &semaptr->sem_base[i].semval,
d392 1
a392 1
		wakeup(&sema[semid]);
d423 1
a423 1
	 * to sleep, we want to sleep now to eliminate any race
a426 10
		if (nsems <= 0 || nsems > seminfo.semmsl) {
			DPRINTF(("nsems out of range (0<%d<=%d)\n", nsems,
			    seminfo.semmsl));
			return (EINVAL);
		}
		if (nsems > seminfo.semmns - semtot) {
			DPRINTF(("not enough semaphores left (need %d, got %d)\n",
			    nsems, seminfo.semmns - semtot));
			return (ENOSPC);
		}
d460 12
a518 2
#define	NSOPS	8
	struct sembuf sopbuf[NSOPS];
d527 2
a528 2
	u_int i, j;
	int do_wakeup, do_undos, error;
d530 1
a530 2
	DPRINTF(("call to semop(%d, %p, %u)\n", semid, SCARG(uap, sops),
	    nsops));
d534 1
a534 1
	if (semid < 0 || semid >= seminfo.semmni)
d546 2
a547 6
	if (nsops == 0) {
		*retval = 0;
		return (0);
	} else if (nsops > (u_int)seminfo.semopm) {
		DPRINTF(("too many sops (max=%d, nsops=%u)\n", seminfo.semopm,
		    nsops));
d551 1
a551 4
	if (nsops <= NSOPS)
		sops = sopbuf;
	else
		sops = malloc(nsops * sizeof(struct sembuf), M_SEM, M_WAITOK);
d554 1
a554 1
		DPRINTF(("error = %d from copyin(%p, %p, %u)\n", error,
d556 2
a557 1
		goto done2;
d578 2
a579 2
				error = EFBIG;
				goto done2;
d635 2
a636 2
			error = EAGAIN;
			goto done2;
d645 1
a645 1
		error = tsleep(&sema[semid], PLOCK | PCATCH,
d652 2
a653 2
			error = EINTR;
			goto done2;
d662 2
a663 2
			error = EIDRM;
			goto done2;
d707 9
a715 11
			if (i != 0) {
				for (j = i - 1; j >= 0; j--) {
					if ((sops[j].sem_flg & SEM_UNDO) == 0)
						continue;
					adjval = sops[j].sem_op;
					if (adjval == 0)
						continue;
					if (semundo_adjust(p, &suptr, semid,
					    sops[j].sem_num, adjval) != 0)
						panic("semop - can't undo undos");
				}
d723 2
a724 1
			goto done2;
d734 1
d739 1
a739 1
		wakeup(&sema[semid]);
d744 1
a744 4
done2:
	if (sops != sopbuf)
		free(sops, M_SEM);
	return (error);
d761 2
a762 1
	SLIST_FOREACH_PREVPTR(suptr, supptr, &semu_list, un_next) {
d812 1
a812 1
			wakeup(&sema[semid]);
d821 1
a821 1
	*supptr = SLIST_NEXT(suptr, un_next);
d887 1
a887 1
		if (val < seminfo.semmns || val > 0xffff)
d905 1
a905 1
		if (val < seminfo.semmsl || val > 0xffff)
@


1.3.8.8
log
@Merge with the trunk
@
text
@d503 1
a503 1
		syscallarg(size_t) nsops;
d508 1
a508 1
	size_t nsops = SCARG(uap, nsops);
d515 1
a515 1
	size_t i, j;
d518 2
a519 2
	DPRINTF(("call to semop(%d, %p, %lu)\n", semid, SCARG(uap, sops),
	    (u_long)nsops));
d538 3
a540 3
	} else if (nsops > (size_t)seminfo.semopm) {
		DPRINTF(("too many sops (max=%d, nsops=%lu)\n", seminfo.semopm,
		    (u_long)nsops));
d646 6
a668 11

		/*
		 * Is it really morning, or was our sleep interrupted?
		 * (Delayed check of tsleep() return code because we
		 * need to decrement sem[nz]cnt either way.)
		 */
		if (error != 0) {
			error = EINTR;
			goto done2;
		}
		DPRINTF(("semop:  good morning!\n"));
d765 4
a768 1
	 * If there is no undo vector, skip to the end.
d774 2
a775 1
	 * We now have an undo vector for this process.
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d278 180
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: sysv_sem.c,v 1.24 1995/10/07 06:28:42 mycroft Exp $	*/
d25 6
a30 1
int
a33 1
	vm_offset_t whocares1, whocares2;
d178 1
d283 1
a283 1
	void *v;
d322 1
a322 1
		if ((eval = ipcperm(cred, &semaptr->sem_perm, IPC_M)))
d574 2
a575 2
	register struct sembuf *sopptr;
	register struct sem *semptr;
d579 1
a579 1
	int all_ok, do_wakeup, do_undos;
d650 2
a651 1
				if (semptr->semval + sopptr->sem_op < 0) {
d834 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
