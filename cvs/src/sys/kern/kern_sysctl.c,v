head	1.322;
access;
symbols
	OPENBSD_6_1:1.322.0.2
	OPENBSD_6_1_BASE:1.322
	OPENBSD_6_0:1.306.0.2
	OPENBSD_6_0_BASE:1.306
	OPENBSD_5_9:1.299.0.2
	OPENBSD_5_9_BASE:1.299
	OPENBSD_5_8:1.287.0.4
	OPENBSD_5_8_BASE:1.287
	OPENBSD_5_7:1.283.0.2
	OPENBSD_5_7_BASE:1.283
	OPENBSD_5_6:1.260.0.4
	OPENBSD_5_6_BASE:1.260
	OPENBSD_5_5:1.244.0.4
	OPENBSD_5_5_BASE:1.244
	OPENBSD_5_4:1.240.0.2
	OPENBSD_5_4_BASE:1.240
	OPENBSD_5_3:1.231.0.2
	OPENBSD_5_3_BASE:1.231
	OPENBSD_5_2:1.226.0.2
	OPENBSD_5_2_BASE:1.226
	OPENBSD_5_1_BASE:1.212
	OPENBSD_5_1:1.212.0.2
	OPENBSD_5_0:1.206.0.2
	OPENBSD_5_0_BASE:1.206
	OPENBSD_4_9:1.197.0.2
	OPENBSD_4_9_BASE:1.197
	OPENBSD_4_8:1.191.0.2
	OPENBSD_4_8_BASE:1.191
	OPENBSD_4_7:1.180.0.2
	OPENBSD_4_7_BASE:1.180
	OPENBSD_4_6:1.175.0.4
	OPENBSD_4_6_BASE:1.175
	OPENBSD_4_5:1.168.0.2
	OPENBSD_4_5_BASE:1.168
	OPENBSD_4_4:1.161.0.2
	OPENBSD_4_4_BASE:1.161
	OPENBSD_4_3:1.160.0.2
	OPENBSD_4_3_BASE:1.160
	OPENBSD_4_2:1.155.0.2
	OPENBSD_4_2_BASE:1.155
	OPENBSD_4_1:1.148.0.2
	OPENBSD_4_1_BASE:1.148
	OPENBSD_4_0:1.142.0.2
	OPENBSD_4_0_BASE:1.142
	OPENBSD_3_9:1.138.0.2
	OPENBSD_3_9_BASE:1.138
	OPENBSD_3_8:1.128.0.2
	OPENBSD_3_8_BASE:1.128
	OPENBSD_3_7:1.124.0.2
	OPENBSD_3_7_BASE:1.124
	OPENBSD_3_6:1.118.0.2
	OPENBSD_3_6_BASE:1.118
	SMP_SYNC_A:1.111
	SMP_SYNC_B:1.111
	OPENBSD_3_5:1.104.0.2
	OPENBSD_3_5_BASE:1.104
	OPENBSD_3_4:1.89.0.2
	OPENBSD_3_4_BASE:1.89
	UBC_SYNC_A:1.81
	OPENBSD_3_3:1.79.0.2
	OPENBSD_3_3_BASE:1.79
	OPENBSD_3_2:1.75.0.2
	OPENBSD_3_2_BASE:1.75
	OPENBSD_3_1:1.64.0.2
	OPENBSD_3_1_BASE:1.64
	UBC_SYNC_B:1.75
	UBC:1.60.0.2
	UBC_BASE:1.60
	OPENBSD_3_0:1.58.0.2
	OPENBSD_3_0_BASE:1.58
	OPENBSD_2_9_BASE:1.41
	OPENBSD_2_9:1.41.0.2
	OPENBSD_2_8:1.36.0.2
	OPENBSD_2_8_BASE:1.36
	OPENBSD_2_7:1.34.0.2
	OPENBSD_2_7_BASE:1.34
	SMP:1.29.0.4
	SMP_BASE:1.29
	kame_19991208:1.29
	OPENBSD_2_6:1.29.0.2
	OPENBSD_2_6_BASE:1.29
	OPENBSD_2_5:1.27.0.2
	OPENBSD_2_5_BASE:1.27
	OPENBSD_2_4:1.26.0.2
	OPENBSD_2_4_BASE:1.26
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.21.0.2
	OPENBSD_2_2_BASE:1.21
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.322
date	2017.03.07.09.29.40;	author mpi;	state Exp;
branches;
next	1.321;
commitid	QgQyFPB2cBKh0tC3;

1.321
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.320;
commitid	CHRb0fCqa8XxUAMH;

1.320
date	2016.11.11.18.59.09;	author mikeb;	state Exp;
branches;
next	1.319;
commitid	ixIKRdtFTWeSJvZx;

1.319
date	2016.11.07.00.26.32;	author guenther;	state Exp;
branches;
next	1.318;
commitid	W7ztnDZwvjCaeQTS;

1.318
date	2016.10.24.04.38.44;	author dlg;	state Exp;
branches;
next	1.317;
commitid	FCHpeu0V7ZGrMD9k;

1.317
date	2016.10.22.04.39.18;	author guenther;	state Exp;
branches;
next	1.316;
commitid	vBbBuTBSgvjce3Sg;

1.316
date	2016.10.08.21.31.56;	author tedu;	state Exp;
branches;
next	1.315;
commitid	MxerhQPTWhS2Twct;

1.315
date	2016.10.08.21.27.32;	author tedu;	state Exp;
branches;
next	1.314;
commitid	R1bh7Z0QgTZ7BOcg;

1.314
date	2016.10.07.19.04.44;	author tedu;	state Exp;
branches;
next	1.313;
commitid	P3wH4sYsZgUq37HY;

1.313
date	2016.10.02.23.11.55;	author guenther;	state Exp;
branches;
next	1.312;
commitid	F8mRaOmEFbuy0fNX;

1.312
date	2016.09.25.15.23.37;	author deraadt;	state Exp;
branches;
next	1.311;
commitid	YxqfPf79WCjoxCH9;

1.311
date	2016.09.21.14.06.50;	author deraadt;	state Exp;
branches;
next	1.310;
commitid	i8Lki9zW9tZfkC2H;

1.310
date	2016.09.18.14.32.54;	author deraadt;	state Exp;
branches;
next	1.309;
commitid	oqDjDsCocwWgzHpt;

1.309
date	2016.09.07.17.30.12;	author natano;	state Exp;
branches;
next	1.308;
commitid	D0avTYSlvEmEjLyB;

1.308
date	2016.09.04.09.22.29;	author mpi;	state Exp;
branches;
next	1.307;
commitid	jBolvsPoQ0BaYiLs;

1.307
date	2016.08.23.23.28.02;	author tedu;	state Exp;
branches;
next	1.306;
commitid	nIfbjtBCGXU5qzrs;

1.306
date	2016.07.14.15.39.40;	author deraadt;	state Exp;
branches;
next	1.305;
commitid	OxTNcya21jtGbyEn;

1.305
date	2016.05.27.19.45.04;	author deraadt;	state Exp;
branches;
next	1.304;
commitid	nQEqvpt7rKDi6fz0;

1.304
date	2016.05.23.15.59.19;	author deraadt;	state Exp;
branches;
next	1.303;
commitid	FJTYRtmkwaCRMqKO;

1.303
date	2016.05.21.14.00.27;	author jsing;	state Exp;
branches;
next	1.302;
commitid	75VU4m1ZupzmtdjG;

1.302
date	2016.05.04.01.28.42;	author zhuk;	state Exp;
branches;
next	1.301;
commitid	BjLmO3uaQB8dONLL;

1.301
date	2016.04.25.20.00.33;	author tedu;	state Exp;
branches;
next	1.300;
commitid	MLNYUlvoOtU8VX0s;

1.300
date	2016.02.29.19.44.07;	author naddy;	state Exp;
branches;
next	1.299;
commitid	Tzte6JKABMyG38MY;

1.299
date	2015.12.05.20.54.34;	author kettenis;	state Exp;
branches;
next	1.298;
commitid	YiP0fXPgtrng9THV;

1.298
date	2015.11.01.19.03.33;	author semarie;	state Exp;
branches;
next	1.297;
commitid	VKRkUfXZQNJ8UQeY;

1.297
date	2015.10.25.20.39.54;	author deraadt;	state Exp;
branches;
next	1.296;
commitid	SIwCBDJKKae61tEi;

1.296
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.295;
commitid	av6ZVErLSWkVP5Zz;

1.295
date	2015.09.28.16.59.35;	author deraadt;	state Exp;
branches;
next	1.294;
commitid	2DjnSnX4H8dTmUWi;

1.294
date	2015.09.13.17.08.03;	author guenther;	state Exp;
branches;
next	1.293;
commitid	BssYI6s6zozAyfkk;

1.293
date	2015.09.11.15.29.47;	author deraadt;	state Exp;
branches;
next	1.292;
commitid	0NZe9BgjJety4Dtk;

1.292
date	2015.09.11.08.22.31;	author guenther;	state Exp;
branches;
next	1.291;
commitid	Lqreadw8v5IPAc0L;

1.291
date	2015.09.10.18.10.35;	author deraadt;	state Exp;
branches;
next	1.290;
commitid	pbNNrPaFfPV40pxN;

1.290
date	2015.09.03.12.13.13;	author mpi;	state Exp;
branches;
next	1.289;
commitid	yww6MTZF6RstClbE;

1.289
date	2015.08.28.04.38.47;	author guenther;	state Exp;
branches;
next	1.288;
commitid	plAZIJHa0HKzn8y4;

1.288
date	2015.08.22.20.18.49;	author deraadt;	state Exp;
branches;
next	1.287;
commitid	6NDuzTPjBp2GqkfQ;

1.287
date	2015.08.03.14.20.39;	author bluhm;	state Exp;
branches;
next	1.286;
commitid	FVozgWujZxpqygf2;

1.286
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	1.285;
commitid	CJwjm9NDWu6nJ6ES;

1.285
date	2015.05.18.19.10.35;	author bluhm;	state Exp;
branches;
next	1.284;
commitid	Sg4G0znjPV3gzUm3;

1.284
date	2015.03.28.23.50.55;	author bluhm;	state Exp;
branches;
next	1.283;
commitid	kVBWJiCghZrzYhp3;

1.283
date	2015.02.11.05.09.33;	author claudio;	state Exp;
branches;
next	1.282;
commitid	shw0pmjYusXvnxct;

1.282
date	2015.02.11.04.00.05;	author guenther;	state Exp;
branches;
next	1.281;
commitid	UMhfO4HVJxVHZvPj;

1.281
date	2015.02.11.03.03.08;	author guenther;	state Exp;
branches;
next	1.280;
commitid	F0jSFhaff58X5UIB;

1.280
date	2015.02.09.11.52.47;	author miod;	state Exp;
branches;
next	1.279;
commitid	3LyovzkL8t513Pbn;

1.279
date	2015.01.20.19.43.21;	author kettenis;	state Exp;
branches;
next	1.278;
commitid	Fn841MmVYz2JHvBP;

1.278
date	2015.01.13.10.07.58;	author mpf;	state Exp;
branches;
next	1.277;
commitid	IZ2rtJyRuzWF0F1j;

1.277
date	2014.12.12.07.45.46;	author tedu;	state Exp;
branches;
next	1.276;
commitid	tOiu53jgNjU0V5Os;

1.276
date	2014.12.12.03.04.11;	author uebayasi;	state Exp;
branches;
next	1.275;
commitid	DRLyTstixbXTsxR3;

1.275
date	2014.12.10.02.44.47;	author tedu;	state Exp;
branches;
next	1.274;
commitid	tsoJBlEBSyYO22RG;

1.274
date	2014.12.05.04.35.08;	author uebayasi;	state Exp;
branches;
next	1.273;
commitid	P7d8sJkf0Fz7Aoly;

1.273
date	2014.12.05.04.12.48;	author uebayasi;	state Exp;
branches;
next	1.272;
commitid	lSMz5LkZVlVJKmFM;

1.272
date	2014.11.19.21.17.37;	author tedu;	state Exp;
branches;
next	1.271;
commitid	hlrKMLSPAXSe0Tyq;

1.271
date	2014.11.19.18.04.54;	author tedu;	state Exp;
branches;
next	1.270;
commitid	DhpzIJGhCsFp0uYg;

1.270
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.269;
commitid	yv0ECmCdICvq576h;

1.269
date	2014.11.03.17.20.46;	author bluhm;	state Exp;
branches;
next	1.268;
commitid	Jo3b0hfgHpuqTRST;

1.268
date	2014.11.01.23.58.28;	author tedu;	state Exp;
branches;
next	1.267;
commitid	9PQjDNhyphSHE6E7;

1.267
date	2014.10.17.01.51.39;	author tedu;	state Exp;
branches;
next	1.266;
commitid	r6zxCLSQFWXeVG73;

1.266
date	2014.10.11.17.12.30;	author deraadt;	state Exp;
branches;
next	1.265;
commitid	il87miBjLKpme2E7;

1.265
date	2014.10.11.16.28.06;	author tedu;	state Exp;
branches;
next	1.264;
commitid	bu68m7FkSwmIteZe;

1.264
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.263;
commitid	uuiU9j2I8AUx0fez;

1.263
date	2014.09.04.19.14.47;	author miod;	state Exp;
branches;
next	1.262;
commitid	8mcKtR0tDvj5O8zk;

1.262
date	2014.08.20.06.23.03;	author mikeb;	state Exp;
branches;
next	1.261;
commitid	3nalvU8sn6rZiZ1d;

1.261
date	2014.08.18.05.11.03;	author dlg;	state Exp;
branches;
next	1.260;
commitid	hjFdrSJM3VTXJUZV;

1.260
date	2014.07.22.11.06.09;	author mpi;	state Exp;
branches;
next	1.259;
commitid	DQakU8LLWV6Iwx84;

1.259
date	2014.07.17.13.44.21;	author tedu;	state Exp;
branches;
next	1.258;
commitid	W8C7jbk8ZR98yjk5;

1.258
date	2014.07.13.16.41.21;	author claudio;	state Exp;
branches;
next	1.257;
commitid	04aN4E0CXyBXMp3X;

1.257
date	2014.07.13.15.29.04;	author tedu;	state Exp;
branches;
next	1.256;
commitid	bFFVdS3JEaMhyZxJ;

1.256
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.255;
commitid	QlVV51SZgNFxsXxC;

1.255
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.254;
commitid	EF98ch02VpFassUi;

1.254
date	2014.07.08.07.10.12;	author dlg;	state Exp;
branches;
next	1.253;
commitid	LjJqbuphCuSi7amX;

1.253
date	2014.07.04.05.58.31;	author guenther;	state Exp;
branches;
next	1.252;
commitid	vhXZZxMGVTWiFaF3;

1.252
date	2014.06.14.22.00.28;	author deraadt;	state Exp;
branches;
next	1.251;
commitid	JFVsoA8hXh15yuVi;

1.251
date	2014.06.14.21.59.38;	author deraadt;	state Exp;
branches;
next	1.250;
commitid	gEKZ9XZD7G3P4a0C;

1.250
date	2014.06.11.17.32.59;	author matthew;	state Exp;
branches;
next	1.249;
commitid	CUF9n302DYnH5nA4;

1.249
date	2014.05.17.17.26.24;	author guenther;	state Exp;
branches;
next	1.248;

1.248
date	2014.05.04.05.03.26;	author guenther;	state Exp;
branches;
next	1.247;

1.247
date	2014.05.03.23.30.04;	author guenther;	state Exp;
branches;
next	1.246;

1.246
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.245;

1.245
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.244;

1.244
date	2014.01.21.01.48.44;	author tedu;	state Exp;
branches;
next	1.243;

1.243
date	2014.01.20.21.19.28;	author guenther;	state Exp;
branches;
next	1.242;

1.242
date	2014.01.20.03.23.42;	author guenther;	state Exp;
branches;
next	1.241;

1.241
date	2013.10.22.16.40.26;	author guenther;	state Exp;
branches;
next	1.240;

1.240
date	2013.07.09.15.37.43;	author beck;	state Exp;
branches;
next	1.239;

1.239
date	2013.06.13.15.00.04;	author tedu;	state Exp;
branches;
next	1.238;

1.238
date	2013.06.11.21.51.55;	author tedu;	state Exp;
branches;
next	1.237;

1.237
date	2013.06.11.19.01.20;	author beck;	state Exp;
branches;
next	1.236;

1.236
date	2013.06.09.13.10.19;	author miod;	state Exp;
branches;
next	1.235;

1.235
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.234;

1.234
date	2013.04.06.03.44.34;	author tedu;	state Exp;
branches;
next	1.233;

1.233
date	2013.03.23.21.22.20;	author tedu;	state Exp;
branches;
next	1.232;

1.232
date	2013.03.20.03.43.08;	author deraadt;	state Exp;
branches;
next	1.231;

1.231
date	2013.02.11.11.11.42;	author mpi;	state Exp;
branches;
next	1.230;

1.230
date	2013.01.15.23.30.39;	author jcs;	state Exp;
branches;
next	1.229;

1.229
date	2012.12.30.00.58.19;	author guenther;	state Exp;
branches;
next	1.228;

1.228
date	2012.11.05.19.39.35;	author miod;	state Exp;
branches;
next	1.227;

1.227
date	2012.08.30.20.11.32;	author matthew;	state Exp;
branches;
next	1.226;

1.226
date	2012.06.02.05.44.27;	author guenther;	state Exp;
branches;
next	1.225;

1.225
date	2012.05.30.20.04.52;	author matthew;	state Exp;
branches;
next	1.224;

1.224
date	2012.05.25.04.39.41;	author guenther;	state Exp;
branches;
next	1.223;

1.223
date	2012.05.02.20.42.25;	author guenther;	state Exp;
branches;
next	1.222;

1.222
date	2012.05.01.03.43.23;	author guenther;	state Exp;
branches;
next	1.221;

1.221
date	2012.04.17.23.17.53;	author pirofti;	state Exp;
branches;
next	1.220;

1.220
date	2012.04.12.14.59.19;	author pirofti;	state Exp;
branches;
next	1.219;

1.219
date	2012.04.10.15.50.52;	author guenther;	state Exp;
branches;
next	1.218;

1.218
date	2012.03.28.16.01.30;	author guenther;	state Exp;
branches;
next	1.217;

1.217
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.216;

1.216
date	2012.03.13.17.28.32;	author tedu;	state Exp;
branches;
next	1.215;

1.215
date	2012.03.10.05.54.28;	author guenther;	state Exp;
branches;
next	1.214;

1.214
date	2012.02.20.22.23.39;	author guenther;	state Exp;
branches;
next	1.213;

1.213
date	2012.02.15.04.29.09;	author guenther;	state Exp;
branches;
next	1.212;

1.212
date	2012.01.21.16.30.31;	author guenther;	state Exp;
branches;
next	1.211;

1.211
date	2012.01.07.05.38.12;	author guenther;	state Exp;
branches;
next	1.210;

1.210
date	2011.12.14.07.32.16;	author guenther;	state Exp;
branches;
next	1.209;

1.209
date	2011.12.09.16.14.54;	author nicm;	state Exp;
branches;
next	1.208;

1.208
date	2011.09.18.13.23.38;	author miod;	state Exp;
branches;
next	1.207;

1.207
date	2011.09.18.01.54.41;	author guenther;	state Exp;
branches;
next	1.206;

1.206
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.205;

1.205
date	2011.06.27.03.40.35;	author guenther;	state Exp;
branches;
next	1.204;

1.204
date	2011.06.24.19.47.49;	author naddy;	state Exp;
branches;
next	1.203;

1.203
date	2011.06.09.21.10.55;	author sthen;	state Exp;
branches;
next	1.202;

1.202
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.201;

1.201
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.200;

1.200
date	2011.04.04.11.13.55;	author deraadt;	state Exp;
branches;
next	1.199;

1.199
date	2011.04.02.16.47.17;	author beck;	state Exp;
branches;
next	1.198;

1.198
date	2011.03.12.04.54.28;	author guenther;	state Exp;
branches;
next	1.197;

1.197
date	2011.02.16.10.37.45;	author mikeb;	state Exp;
branches;
next	1.196;

1.196
date	2010.12.14.20.26.44;	author mikeb;	state Exp;
branches;
next	1.195;

1.195
date	2010.11.19.18.35.16;	author mikeb;	state Exp;
branches;
next	1.194;

1.194
date	2010.11.02.09.36.09;	author dlg;	state Exp;
branches;
next	1.193;

1.193
date	2010.09.23.13.24.22;	author jsing;	state Exp;
branches;
next	1.192;

1.192
date	2010.08.19.18.14.14;	author kettenis;	state Exp;
branches;
next	1.191;

1.191
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.190;

1.190
date	2010.07.19.23.00.15;	author guenther;	state Exp;
branches;
next	1.189;

1.189
date	2010.07.10.21.29.37;	author guenther;	state Exp;
branches;
next	1.188;

1.188
date	2010.07.02.18.14.40;	author guenther;	state Exp;
branches;
next	1.187;

1.187
date	2010.06.30.19.57.05;	author deraadt;	state Exp;
branches;
next	1.186;

1.186
date	2010.06.29.16.39.22;	author guenther;	state Exp;
branches;
next	1.185;

1.185
date	2010.06.29.00.28.14;	author tedu;	state Exp;
branches;
next	1.184;

1.184
date	2010.06.19.14.44.44;	author thib;	state Exp;
branches;
next	1.183;

1.183
date	2010.05.02.11.15.29;	author kettenis;	state Exp;
branches;
next	1.182;

1.182
date	2010.04.20.20.49.33;	author deraadt;	state Exp;
branches;
next	1.181;

1.181
date	2010.03.24.23.18.17;	author tedu;	state Exp;
branches;
next	1.180;

1.180
date	2010.01.10.03.37.50;	author guenther;	state Exp;
branches;
next	1.179;

1.179
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.178;

1.178
date	2009.08.02.16.28.39;	author beck;	state Exp;
branches;
next	1.177;

1.177
date	2009.07.21.14.10.14;	author millert;	state Exp;
branches;
next	1.176;

1.176
date	2009.07.19.12.56.19;	author millert;	state Exp;
branches;
next	1.175;

1.175
date	2009.06.15.17.59.45;	author deraadt;	state Exp;
branches
	1.175.4.1;
next	1.174;

1.174
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.173;

1.173
date	2009.06.08.00.52.23;	author deraadt;	state Exp;
branches;
next	1.172;

1.172
date	2009.06.07.03.07.19;	author millert;	state Exp;
branches;
next	1.171;

1.171
date	2009.06.05.04.29.14;	author beck;	state Exp;
branches;
next	1.170;

1.170
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.169;

1.169
date	2009.04.19.17.53.38;	author deraadt;	state Exp;
branches;
next	1.168;

1.168
date	2009.01.21.21.02.40;	author miod;	state Exp;
branches;
next	1.167;

1.167
date	2008.10.31.17.18.24;	author deraadt;	state Exp;
branches;
next	1.166;

1.166
date	2008.10.31.17.17.08;	author deraadt;	state Exp;
branches;
next	1.165;

1.165
date	2008.10.31.17.17.05;	author deraadt;	state Exp;
branches;
next	1.164;

1.164
date	2008.10.31.17.15.30;	author deraadt;	state Exp;
branches;
next	1.163;

1.163
date	2008.10.09.07.48.55;	author kevlo;	state Exp;
branches;
next	1.162;

1.162
date	2008.10.07.02.20.11;	author deraadt;	state Exp;
branches;
next	1.161;

1.161
date	2008.06.09.07.07.16;	author djm;	state Exp;
branches;
next	1.160;

1.160
date	2008.02.09.15.10.58;	author kettenis;	state Exp;
branches;
next	1.159;

1.159
date	2007.12.23.01.59.58;	author dlg;	state Exp;
branches;
next	1.158;

1.158
date	2007.10.10.15.53.53;	author art;	state Exp;
branches;
next	1.157;

1.157
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.156;

1.156
date	2007.09.01.15.14.44;	author martin;	state Exp;
branches;
next	1.155;

1.155
date	2007.08.09.04.12.12;	author cnst;	state Exp;
branches;
next	1.154;

1.154
date	2007.06.01.17.29.10;	author beck;	state Exp;
branches;
next	1.153;

1.153
date	2007.05.29.00.17.32;	author thib;	state Exp;
branches;
next	1.152;

1.152
date	2007.05.16.17.27.30;	author art;	state Exp;
branches;
next	1.151;

1.151
date	2007.04.18.16.57.06;	author art;	state Exp;
branches;
next	1.150;

1.150
date	2007.04.12.22.14.15;	author tedu;	state Exp;
branches;
next	1.149;

1.149
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.148;

1.148
date	2007.02.20.17.42.29;	author deraadt;	state Exp;
branches;
next	1.147;

1.147
date	2007.01.12.07.41.31;	author art;	state Exp;
branches;
next	1.146;

1.146
date	2006.12.23.17.41.26;	author deraadt;	state Exp;
branches;
next	1.145;

1.145
date	2006.12.12.23.14.28;	author dim;	state Exp;
branches;
next	1.144;

1.144
date	2006.12.08.23.08.19;	author gwk;	state Exp;
branches;
next	1.143;

1.143
date	2006.11.29.12.24.17;	author miod;	state Exp;
branches;
next	1.142;

1.142
date	2006.05.28.19.41.42;	author dlg;	state Exp;
branches;
next	1.141;

1.141
date	2006.05.20.22.55.46;	author dlg;	state Exp;
branches;
next	1.140;

1.140
date	2006.05.08.22.51.18;	author gwk;	state Exp;
branches;
next	1.139;

1.139
date	2006.03.15.21.02.09;	author deraadt;	state Exp;
branches;
next	1.138;

1.138
date	2006.01.28.09.53.37;	author dlg;	state Exp;
branches;
next	1.137;

1.137
date	2006.01.19.17.08.40;	author grange;	state Exp;
branches;
next	1.136;

1.136
date	2005.11.28.00.14.29;	author jsg;	state Exp;
branches;
next	1.135;

1.135
date	2005.11.21.13.47.52;	author dlg;	state Exp;
branches;
next	1.134;

1.134
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.133;

1.133
date	2005.11.10.08.10.16;	author dlg;	state Exp;
branches;
next	1.132;

1.132
date	2005.11.04.21.47.57;	author miod;	state Exp;
branches;
next	1.131;

1.131
date	2005.09.25.20.48.23;	author miod;	state Exp;
branches;
next	1.130;

1.130
date	2005.09.20.23.01.06;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2005.09.20.21.04.15;	author miod;	state Exp;
branches;
next	1.128;

1.128
date	2005.07.31.04.36.51;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2005.06.08.22.33.27;	author millert;	state Exp;
branches;
next	1.126;

1.126
date	2005.06.04.05.10.40;	author tedu;	state Exp;
branches;
next	1.125;

1.125
date	2005.05.24.21.11.48;	author tedu;	state Exp;
branches;
next	1.124;

1.124
date	2005.03.10.17.26.10;	author tedu;	state Exp;
branches;
next	1.123;

1.123
date	2004.12.24.17.28.13;	author miod;	state Exp;
branches;
next	1.122;

1.122
date	2004.11.26.21.23.06;	author miod;	state Exp;
branches;
next	1.121;

1.121
date	2004.10.14.17.10.17;	author mickey;	state Exp;
branches;
next	1.120;

1.120
date	2004.09.23.21.08.54;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2004.09.15.17.50.33;	author grange;	state Exp;
branches;
next	1.118;

1.118
date	2004.07.28.17.15.12;	author tholo;	state Exp;
branches;
next	1.117;

1.117
date	2004.06.28.01.34.46;	author aaron;	state Exp;
branches;
next	1.116;

1.116
date	2004.06.25.08.41.19;	author art;	state Exp;
branches;
next	1.115;

1.115
date	2004.06.24.21.00.03;	author millert;	state Exp;
branches;
next	1.114;

1.114
date	2004.06.20.03.04.15;	author art;	state Exp;
branches;
next	1.113;

1.113
date	2004.06.16.18.14.12;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.111;

1.111
date	2004.06.09.20.18.28;	author art;	state Exp;
branches;
next	1.110;

1.110
date	2004.06.08.18.09.31;	author marc;	state Exp;
branches;
next	1.109;

1.109
date	2004.05.27.08.19.59;	author tedu;	state Exp;
branches;
next	1.108;

1.108
date	2004.05.23.19.41.23;	author tedu;	state Exp;
branches;
next	1.107;

1.107
date	2004.05.23.19.37.24;	author tedu;	state Exp;
branches;
next	1.106;

1.106
date	2004.04.19.22.52.33;	author tedu;	state Exp;
branches;
next	1.105;

1.105
date	2004.04.15.00.22.42;	author tedu;	state Exp;
branches;
next	1.104;

1.104
date	2004.02.29.12.14.05;	author weingart;	state Exp;
branches;
next	1.103;

1.103
date	2004.02.27.21.46.44;	author grange;	state Exp;
branches;
next	1.102;

1.102
date	2004.02.27.21.15.45;	author grange;	state Exp;
branches;
next	1.101;

1.101
date	2004.02.15.11.14.45;	author markus;	state Exp;
branches;
next	1.100;

1.100
date	2004.02.15.02.45.46;	author tedu;	state Exp;
branches;
next	1.99;

1.99
date	2004.02.14.15.09.22;	author grange;	state Exp;
branches;
next	1.98;

1.98
date	2004.01.07.21.51.30;	author millert;	state Exp;
branches;
next	1.97;

1.97
date	2004.01.07.21.30.59;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2004.01.07.19.34.03;	author millert;	state Exp;
branches;
next	1.95;

1.95
date	2004.01.07.03.37.57;	author millert;	state Exp;
branches;
next	1.94;

1.94
date	2004.01.07.02.13.51;	author millert;	state Exp;
branches;
next	1.93;

1.93
date	2003.12.18.23.46.20;	author tedu;	state Exp;
branches;
next	1.92;

1.92
date	2003.11.23.20.17.14;	author millert;	state Exp;
branches;
next	1.91;

1.91
date	2003.10.26.22.31.23;	author tedu;	state Exp;
branches;
next	1.90;

1.90
date	2003.10.24.19.05.21;	author tedu;	state Exp;
branches;
next	1.89;

1.89
date	2003.08.23.20.02.59;	author tedu;	state Exp;
branches;
next	1.88;

1.88
date	2003.08.23.19.21.15;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2003.08.23.18.12.20;	author fgsch;	state Exp;
branches;
next	1.86;

1.86
date	2003.08.21.18.56.07;	author tedu;	state Exp;
branches;
next	1.85;

1.85
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.84;

1.84
date	2003.08.06.21.08.07;	author millert;	state Exp;
branches;
next	1.83;

1.83
date	2003.06.10.21.50.26;	author mickey;	state Exp;
branches;
next	1.82;

1.82
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.81;

1.81
date	2003.05.03.21.14.59;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2003.04.25.20.06.41;	author grange;	state Exp;
branches;
next	1.79;

1.79
date	2003.01.21.16.59.23;	author markus;	state Exp;
branches;
next	1.78;

1.78
date	2003.01.15.23.41.56;	author millert;	state Exp;
branches;
next	1.77;

1.77
date	2003.01.13.06.04.16;	author art;	state Exp;
branches;
next	1.76;

1.76
date	2002.12.17.23.11.31;	author millert;	state Exp;
branches;
next	1.75;

1.75
date	2002.09.01.11.35.52;	author art;	state Exp;
branches;
next	1.74;

1.74
date	2002.08.23.15.33.12;	author art;	state Exp;
branches;
next	1.73;

1.73
date	2002.07.06.19.14.20;	author nordin;	state Exp;
branches;
next	1.72;

1.72
date	2002.06.24.11.09.01;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2002.06.11.11.14.29;	author beck;	state Exp;
branches;
next	1.70;

1.70
date	2002.06.09.05.46.15;	author art;	state Exp;
branches;
next	1.69;

1.69
date	2002.06.09.04.27.25;	author angelos;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.08.23.35.35;	author angelos;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.08.23.17.22;	author angelos;	state Exp;
branches;
next	1.66;

1.66
date	2002.06.08.22.24.47;	author art;	state Exp;
branches;
next	1.65;

1.65
date	2002.05.15.23.17.53;	author art;	state Exp;
branches;
next	1.64;

1.64
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.63;

1.63
date	2002.03.14.19.42.54;	author mickey;	state Exp;
branches;
next	1.62;

1.62
date	2002.03.01.02.52.51;	author provos;	state Exp;
branches;
next	1.61;

1.61
date	2002.02.23.08.11.05;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2001.11.28.13.47.39;	author art;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2001.09.28.01.42.54;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2001.09.07.22.03.21;	author angelos;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.18.03.32.16;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2001.07.17.20.57.49;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2001.07.13.23.46.12;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.27.07.21.27;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.27.04.49.46;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.24.16.00.47;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.22.21.32.58;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.03.18.40.23;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.03.04.41.33;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.03.03.53.57;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.03.03.28.41;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.14.08.03.14;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.14.07.18.05;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2001.05.11.06.38.47;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.07.22.16.35;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.04.06.23.41.02;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2001.03.23.23.36.39;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2001.03.16.08.49.09;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.31.09.59.51;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.04.06.04.42;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2000.06.18.17.59.55;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	2000.06.05.11.02.51;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2000.05.06.17.08.14;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2000.03.16.22.11.03;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2000.03.03.11.46.09;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2000.03.03.11.31.43;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2000.02.22.19.28.03;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	99.06.29.23.51.59;	author provos;	state Exp;
branches
	1.29.4.1;
next	1.28;

1.28
date	99.06.01.08.23.51;	author art;	state Exp;
branches;
next	1.27;

1.27
date	99.02.26.04.57.15;	author art;	state Exp;
branches;
next	1.26;

1.26
date	98.07.07.07.12.40;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	98.06.02.06.10.28;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	97.12.08.21.25.37;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	97.11.06.15.59.49;	author kstailey;	state Exp;
branches;
next	1.22;

1.22
date	97.11.06.05.58.19;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	97.10.06.20.19.58;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.10.06.15.12.25;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	97.09.03.13.51.08;	author kstailey;	state Exp;
branches;
next	1.18;

1.18
date	97.06.22.04.58.03;	author flipk;	state Exp;
branches;
next	1.17;

1.17
date	97.06.21.04.59.44;	author flipk;	state Exp;
branches;
next	1.16;

1.16
date	97.06.14.21.37.10;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.03.27.04.39.35;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.03.26.17.23.50;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.10.04.01.26.47;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.09.20.22.53.09;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.08.08.06.36.45;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	96.06.29.21.07.52;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	96.06.29.21.04.21;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.05.24.22.17.44;	author dm;	state Exp;
branches;
next	1.7;

1.7
date	96.05.23.08.33.15;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.23.15.03.52;	author dm;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.27.10;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.19.16.08.59;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.30.04.51.32;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.19.56;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches;
next	;

1.29.4.1
date	2000.02.20.11.57.17;	author niklas;	state Exp;
branches;
next	1.29.4.2;

1.29.4.2
date	2000.03.02.07.04.40;	author niklas;	state Exp;
branches;
next	1.29.4.3;

1.29.4.3
date	2000.03.24.09.09.25;	author niklas;	state Exp;
branches;
next	1.29.4.4;

1.29.4.4
date	2001.05.14.22.32.42;	author niklas;	state Exp;
branches;
next	1.29.4.5;

1.29.4.5
date	2001.07.04.10.48.27;	author niklas;	state Exp;
branches;
next	1.29.4.6;

1.29.4.6
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.29.4.7;

1.29.4.7
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.29.4.8;

1.29.4.8
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.29.4.9;

1.29.4.9
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.29.4.10;

1.29.4.10
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.29.4.11;

1.29.4.11
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.29.4.12;

1.29.4.12
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.29.4.13;

1.29.4.13
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.29.4.14;

1.29.4.14
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.29.4.15;

1.29.4.15
date	2004.03.14.22.08.21;	author niklas;	state Exp;
branches;
next	1.29.4.16;

1.29.4.16
date	2004.06.05.17.19.55;	author niklas;	state Exp;
branches;
next	1.29.4.17;

1.29.4.17
date	2004.06.05.23.13.01;	author niklas;	state Exp;
branches;
next	1.29.4.18;

1.29.4.18
date	2004.06.08.20.07.03;	author deraadt;	state Exp;
branches;
next	1.29.4.19;

1.29.4.19
date	2004.06.10.11.40.33;	author niklas;	state Exp;
branches;
next	1.29.4.20;

1.29.4.20
date	2004.06.11.05.29.25;	author drahn;	state Exp;
branches;
next	;

1.60.2.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.60.2.2;

1.60.2.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.60.2.3;

1.60.2.3
date	2003.05.19.22.31.10;	author tedu;	state Exp;
branches;
next	;

1.175.4.1
date	2009.12.01.23.37.51;	author william;	state Exp;
branches;
next	;


desc
@@


1.322
log
@Enforce that tcbtable and udbtable must be accessed with the NET_LOCK().

Get rid of the old splnet()/splx() dances.  What's protecting them right
now is the KERNEL_LOCK().  but since pf(4) look at these tables we want
to protect them in another way, hence the NET_LOCK(), at least as hint.

ok bluhm@@
@
text
@/*	$OpenBSD: kern_sysctl.c,v 1.321 2017/01/21 05:42:03 guenther Exp $	*/
/*	$NetBSD: kern_sysctl.c,v 1.17 1996/05/20 17:49:05 mrg Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Mike Karels at Berkeley Software Design, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_sysctl.c	8.4 (Berkeley) 4/14/94
 */

/*
 * sysctl system call.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/signalvar.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/vnode.h>
#include <sys/unistd.h>
#include <sys/buf.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/sysctl.h>
#include <sys/msgbuf.h>
#include <sys/vmmeter.h>
#include <sys/namei.h>
#include <sys/exec.h>
#include <sys/mbuf.h>
#include <sys/percpu.h>
#include <sys/sensors.h>
#include <sys/pipe.h>
#include <sys/eventvar.h>
#include <sys/socketvar.h>
#include <sys/socket.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/pledge.h>
#include <sys/timetc.h>
#include <sys/evcount.h>
#include <sys/un.h>
#include <sys/unpcb.h>
#include <sys/sched.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>
#include <dev/rndvar.h>

#include <net/route.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/in_pcb.h>
#include <netinet/ip6.h>
#include <netinet/tcp.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet6/ip6_var.h>

#ifdef DDB
#include <ddb/db_var.h>
#endif

#ifdef SYSVMSG
#include <sys/msg.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif

extern struct forkstat forkstat;
extern struct nchstats nchstats;
extern int nselcoll, fscale;
extern struct disklist_head disklist;
extern fixpt_t ccpu;
extern  long numvnodes;
extern u_int net_livelocks;

int allowkmem;

extern void nmbclust_update(void);

int sysctl_diskinit(int, struct proc *);
int sysctl_proc_args(int *, u_int, void *, size_t *, struct proc *);
int sysctl_proc_cwd(int *, u_int, void *, size_t *, struct proc *);
int sysctl_proc_nobroadcastkill(int *, u_int, void *, size_t, void *, size_t *,
	struct proc *);
int sysctl_proc_vmmap(int *, u_int, void *, size_t *, struct proc *);
int sysctl_intrcnt(int *, u_int, void *, size_t *);
int sysctl_sensors(int *, u_int, void *, size_t *, void *, size_t);
int sysctl_cptime2(int *, u_int, void *, size_t *, void *, size_t);

void fill_file(struct kinfo_file *, struct file *, struct filedesc *, int,
    struct vnode *, struct process *, struct proc *, struct socket *, int);
void fill_kproc(struct process *, struct kinfo_proc *, struct proc *, int);

int (*cpu_cpuspeed)(int *);

/*
 * Lock to avoid too many processes vslocking a large amount of memory
 * at the same time.
 */
struct rwlock sysctl_lock = RWLOCK_INITIALIZER("sysctllk");
struct rwlock sysctl_disklock = RWLOCK_INITIALIZER("sysctldlk");

int
sys_sysctl(struct proc *p, void *v, register_t *retval)
{
	struct sys_sysctl_args /* {
		syscallarg(const int *) name;
		syscallarg(u_int) namelen;
		syscallarg(void *) old;
		syscallarg(size_t *) oldlenp;
		syscallarg(void *) new;
		syscallarg(size_t) newlen;
	} */ *uap = v;
	int error, dolock = 1;
	size_t savelen = 0, oldlen = 0;
	sysctlfn *fn;
	int name[CTL_MAXNAME];

	if (SCARG(uap, new) != NULL &&
	    (error = suser(p, 0)))
		return (error);
	/*
	 * all top-level sysctl names are non-terminal
	 */
	if (SCARG(uap, namelen) > CTL_MAXNAME || SCARG(uap, namelen) < 2)
		return (EINVAL);
	error = copyin(SCARG(uap, name), name,
		       SCARG(uap, namelen) * sizeof(int));
	if (error)
		return (error);

	error = pledge_sysctl(p, SCARG(uap, namelen),
	    name, SCARG(uap, new));
	if (error)
		return (error);

	switch (name[0]) {
	case CTL_KERN:
		fn = kern_sysctl;
		break;
	case CTL_HW:
		fn = hw_sysctl;
		break;
	case CTL_VM:
		fn = uvm_sysctl;
		break;
	case CTL_NET:
		fn = net_sysctl;
		break;
	case CTL_FS:
		fn = fs_sysctl;
		break;
	case CTL_VFS:
		fn = vfs_sysctl;
		break;
	case CTL_MACHDEP:
		fn = cpu_sysctl;
		break;
#ifdef DEBUG
	case CTL_DEBUG:
		fn = debug_sysctl;
		break;
#endif
#ifdef DDB
	case CTL_DDB:
		fn = ddb_sysctl;
		break;
#endif
	default:
		return (EOPNOTSUPP);
	}

	if (SCARG(uap, oldlenp) &&
	    (error = copyin(SCARG(uap, oldlenp), &oldlen, sizeof(oldlen))))
		return (error);
	if (SCARG(uap, old) != NULL) {
		if ((error = rw_enter(&sysctl_lock, RW_WRITE|RW_INTR)) != 0)
			return (error);
		if (dolock) {
			if (atop(oldlen) > uvmexp.wiredmax - uvmexp.wired) {
				rw_exit_write(&sysctl_lock);
				return (ENOMEM);
			}
			error = uvm_vslock(p, SCARG(uap, old), oldlen,
			    PROT_READ | PROT_WRITE);
			if (error) {
				rw_exit_write(&sysctl_lock);
				return (error);
			}
		}
		savelen = oldlen;
	}
	error = (*fn)(&name[1], SCARG(uap, namelen) - 1, SCARG(uap, old),
	    &oldlen, SCARG(uap, new), SCARG(uap, newlen), p);
	if (SCARG(uap, old) != NULL) {
		if (dolock)
			uvm_vsunlock(p, SCARG(uap, old), savelen);
		rw_exit_write(&sysctl_lock);
	}
	if (error)
		return (error);
	if (SCARG(uap, oldlenp))
		error = copyout(&oldlen, SCARG(uap, oldlenp), sizeof(oldlen));
	return (error);
}

/*
 * Attributes stored in the kernel.
 */
char hostname[MAXHOSTNAMELEN];
int hostnamelen;
char domainname[MAXHOSTNAMELEN];
int domainnamelen;
long hostid;
char *disknames = NULL;
size_t disknameslen;
struct diskstats *diskstats = NULL;
size_t diskstatslen;
int securelevel;

/*
 * kernel related system variables.
 */
int
kern_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	int error, level, inthostid, stackgap;
	dev_t dev;
	extern int somaxconn, sominconn;
	extern int nosuidcoredump;
	extern int maxlocksperuid;
	extern int pool_debug;
	extern int uvm_wxabort;

	/* all sysctl names at this level are terminal except a ton of them */
	if (namelen != 1) {
		switch (name[0]) {
		case KERN_PROC:
		case KERN_PROF:
		case KERN_MALLOCSTATS:
		case KERN_TTY:
		case KERN_POOL:
		case KERN_PROC_ARGS:
		case KERN_PROC_CWD:
		case KERN_PROC_NOBROADCASTKILL:
		case KERN_PROC_VMMAP:
		case KERN_SYSVIPC_INFO:
		case KERN_SEMINFO:
		case KERN_SHMINFO:
		case KERN_INTRCNT:
		case KERN_WATCHDOG:
		case KERN_EVCOUNT:
		case KERN_TIMECOUNTER:
		case KERN_CPTIME2:
		case KERN_FILE:
			break;
		default:
			return (ENOTDIR);	/* overloaded */
		}
	}

	switch (name[0]) {
	case KERN_OSTYPE:
		return (sysctl_rdstring(oldp, oldlenp, newp, ostype));
	case KERN_OSRELEASE:
		return (sysctl_rdstring(oldp, oldlenp, newp, osrelease));
	case KERN_OSREV:
		return (sysctl_rdint(oldp, oldlenp, newp, OpenBSD));
	case KERN_OSVERSION:
		return (sysctl_rdstring(oldp, oldlenp, newp, osversion));
	case KERN_VERSION:
		return (sysctl_rdstring(oldp, oldlenp, newp, version));
	case KERN_MAXVNODES:
		return(sysctl_int(oldp, oldlenp, newp, newlen, &maxvnodes));
	case KERN_MAXPROC:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &maxprocess));
	case KERN_MAXFILES:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &maxfiles));
	case KERN_NFILES:
		return (sysctl_rdint(oldp, oldlenp, newp, numfiles));
	case KERN_TTYCOUNT:
		return (sysctl_rdint(oldp, oldlenp, newp, tty_count));
	case KERN_NUMVNODES:
		return (sysctl_rdint(oldp, oldlenp, newp, numvnodes));
	case KERN_ARGMAX:
		return (sysctl_rdint(oldp, oldlenp, newp, ARG_MAX));
	case KERN_NSELCOLL:
		return (sysctl_rdint(oldp, oldlenp, newp, nselcoll));
	case KERN_SECURELVL:
		level = securelevel;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &level)) ||
		    newp == NULL)
			return (error);
		if ((securelevel > 0 || level < -1) &&
		    level < securelevel && p->p_p->ps_pid != 1)
			return (EPERM);
		securelevel = level;
		return (0);
	case KERN_ALLOWKMEM:
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp,
			    allowkmem));
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &allowkmem));
	case KERN_HOSTNAME:
		error = sysctl_tstring(oldp, oldlenp, newp, newlen,
		    hostname, sizeof(hostname));
		if (newp && !error)
			hostnamelen = newlen;
		return (error);
	case KERN_DOMAINNAME:
		error = sysctl_tstring(oldp, oldlenp, newp, newlen,
		    domainname, sizeof(domainname));
		if (newp && !error)
			domainnamelen = newlen;
		return (error);
	case KERN_HOSTID:
		inthostid = hostid;  /* XXX assumes sizeof long <= sizeof int */
		error =  sysctl_int(oldp, oldlenp, newp, newlen, &inthostid);
		hostid = inthostid;
		return (error);
	case KERN_CLOCKRATE:
		return (sysctl_clockrate(oldp, oldlenp, newp));
	case KERN_BOOTTIME: {
		struct timeval bt;
		TIMESPEC_TO_TIMEVAL(&bt, &boottime);
		return (sysctl_rdstruct(oldp, oldlenp, newp, &bt, sizeof bt));
	  }
#ifndef SMALL_KERNEL
	case KERN_PROC:
		return (sysctl_doproc(name + 1, namelen - 1, oldp, oldlenp));
	case KERN_PROC_ARGS:
		return (sysctl_proc_args(name + 1, namelen - 1, oldp, oldlenp,
		     p));
	case KERN_PROC_CWD:
		return (sysctl_proc_cwd(name + 1, namelen - 1, oldp, oldlenp,
		     p));
	case KERN_PROC_NOBROADCASTKILL:
		return (sysctl_proc_nobroadcastkill(name + 1, namelen - 1,
		     newp, newlen, oldp, oldlenp, p));
	case KERN_PROC_VMMAP:
		return (sysctl_proc_vmmap(name + 1, namelen - 1, oldp, oldlenp,
		     p));
	case KERN_FILE:
		return (sysctl_file(name + 1, namelen - 1, oldp, oldlenp, p));
#endif
	case KERN_MBSTAT: {
		extern struct cpumem *mbstat;
		uint64_t counters[MBSTAT_COUNT];
		struct mbstat mbs;
		unsigned int i;

		memset(&mbs, 0, sizeof(mbs));
		counters_read(mbstat, counters, MBSTAT_COUNT);
		for (i = 0; i < MBSTAT_TYPES; i++)
			mbs.m_mtypes[i] = counters[i];

		mbs.m_drops = counters[MBSTAT_DROPS];
		mbs.m_wait = counters[MBSTAT_WAIT];
		mbs.m_drain = counters[MBSTAT_DRAIN];

		return (sysctl_rdstruct(oldp, oldlenp, newp,
		    &mbs, sizeof(mbs)));
	}
#if defined(GPROF) || defined(DDBPROF)
	case KERN_PROF:
		return (sysctl_doprof(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
	case KERN_POSIX1:
		return (sysctl_rdint(oldp, oldlenp, newp, _POSIX_VERSION));
	case KERN_NGROUPS:
		return (sysctl_rdint(oldp, oldlenp, newp, NGROUPS_MAX));
	case KERN_JOB_CONTROL:
		return (sysctl_rdint(oldp, oldlenp, newp, 1));
	case KERN_SAVED_IDS:
		return (sysctl_rdint(oldp, oldlenp, newp, 1));
	case KERN_MAXPARTITIONS:
		return (sysctl_rdint(oldp, oldlenp, newp, MAXPARTITIONS));
	case KERN_RAWPARTITION:
		return (sysctl_rdint(oldp, oldlenp, newp, RAW_PART));
	case KERN_MAXTHREAD:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &maxthread));
	case KERN_NTHREADS:
		return (sysctl_rdint(oldp, oldlenp, newp, nthreads));
	case KERN_SOMAXCONN:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &somaxconn));
	case KERN_SOMINCONN:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &sominconn));
	case KERN_NOSUIDCOREDUMP:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &nosuidcoredump));
	case KERN_FSYNC:
		return (sysctl_rdint(oldp, oldlenp, newp, 1));
	case KERN_SYSVMSG:
#ifdef SYSVMSG
		return (sysctl_rdint(oldp, oldlenp, newp, 1));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case KERN_SYSVSEM:
#ifdef SYSVSEM
		return (sysctl_rdint(oldp, oldlenp, newp, 1));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case KERN_SYSVSHM:
#ifdef SYSVSHM
		return (sysctl_rdint(oldp, oldlenp, newp, 1));
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
	case KERN_MSGBUFSIZE:
	case KERN_CONSBUFSIZE: {
		struct msgbuf *mp;
		mp = (name[0] == KERN_MSGBUFSIZE) ? msgbufp : consbufp;
		/*
		 * deal with cases where the message buffer has
		 * become corrupted.
		 */
		if (!mp || mp->msg_magic != MSG_MAGIC)
			return (ENXIO);
		return (sysctl_rdint(oldp, oldlenp, newp, mp->msg_bufs));
	}
	case KERN_CONSBUF:
		if ((error = suser(p, 0)))
			return (error);
		/* FALLTHROUGH */
	case KERN_MSGBUF: {
		struct msgbuf *mp;
		mp = (name[0] == KERN_MSGBUF) ? msgbufp : consbufp;
		/* see note above */
		if (!mp || mp->msg_magic != MSG_MAGIC)
			return (ENXIO);
		return (sysctl_rdstruct(oldp, oldlenp, newp, mp,
		    mp->msg_bufs + offsetof(struct msgbuf, msg_bufc)));
	}
	case KERN_MALLOCSTATS:
		return (sysctl_malloc(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen, p));
	case KERN_CPTIME:
	{
		CPU_INFO_ITERATOR cii;
		struct cpu_info *ci;
		long cp_time[CPUSTATES];
		int i;

		memset(cp_time, 0, sizeof(cp_time));

		CPU_INFO_FOREACH(cii, ci) {
			for (i = 0; i < CPUSTATES; i++)
				cp_time[i] += ci->ci_schedstate.spc_cp_time[i];
		}

		for (i = 0; i < CPUSTATES; i++)
			cp_time[i] /= ncpus;

		return (sysctl_rdstruct(oldp, oldlenp, newp, &cp_time,
		    sizeof(cp_time)));
	}
	case KERN_NCHSTATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &nchstats,
		    sizeof(struct nchstats)));
	case KERN_FORKSTAT:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &forkstat,
		    sizeof(struct forkstat)));
	case KERN_TTY:
		return (sysctl_tty(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
	case KERN_FSCALE:
		return (sysctl_rdint(oldp, oldlenp, newp, fscale));
	case KERN_CCPU:
		return (sysctl_rdint(oldp, oldlenp, newp, ccpu));
	case KERN_NPROCS:
		return (sysctl_rdint(oldp, oldlenp, newp, nprocesses));
	case KERN_POOL:
		return (sysctl_dopool(name + 1, namelen - 1, oldp, oldlenp));
	case KERN_STACKGAPRANDOM:
		stackgap = stackgap_random;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &stackgap);
		if (error)
			return (error);
		/*
		 * Safety harness.
		 */
		if ((stackgap < ALIGNBYTES && stackgap != 0) ||
		    !powerof2(stackgap) || stackgap >= MAXSSIZ)
			return (EINVAL);
		stackgap_random = stackgap;
		return (0);
#if defined(SYSVMSG) || defined(SYSVSEM) || defined(SYSVSHM)
	case KERN_SYSVIPC_INFO:
		return (sysctl_sysvipc(name + 1, namelen - 1, oldp, oldlenp));
#endif
	case KERN_SPLASSERT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &splassert_ctl));
#ifdef SYSVSEM
	case KERN_SEMINFO:
		return (sysctl_sysvsem(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
#ifdef SYSVSHM
	case KERN_SHMINFO:
		return (sysctl_sysvshm(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
#ifndef SMALL_KERNEL
	case KERN_INTRCNT:
		return (sysctl_intrcnt(name + 1, namelen - 1, oldp, oldlenp));
	case KERN_WATCHDOG:
		return (sysctl_wdog(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
	case KERN_MAXCLUSTERS:
		error = sysctl_int(oldp, oldlenp, newp, newlen, &nmbclust);
		if (!error)
			nmbclust_update();
		return (error);
#ifndef SMALL_KERNEL
	case KERN_EVCOUNT:
		return (evcount_sysctl(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
	case KERN_TIMECOUNTER:
		return (sysctl_tc(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
	case KERN_MAXLOCKSPERUID:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &maxlocksperuid));
	case KERN_CPTIME2:
		return (sysctl_cptime2(name + 1, namelen -1, oldp, oldlenp,
		    newp, newlen));
	case KERN_CACHEPCT: {
		u_int64_t dmapages;
		int opct, pgs;
		opct = bufcachepercent;
		error = sysctl_int(oldp, oldlenp, newp, newlen,
		    &bufcachepercent);
		if (error)
			return(error);
		if (bufcachepercent > 90 || bufcachepercent < 5) {
			bufcachepercent = opct;
			return (EINVAL);
		}
		dmapages = uvm_pagecount(&dma_constraint);
		if (bufcachepercent != opct) {
			pgs = bufcachepercent * dmapages / 100;
			bufadjust(pgs); /* adjust bufpages */
			bufhighpages = bufpages; /* set high water mark */
		}
		return(0);
	}
	case KERN_WXABORT:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &uvm_wxabort));
	case KERN_CONSDEV:
		if (cn_tab != NULL)
			dev = cn_tab->cn_dev;
		else
			dev = NODEV;
		return sysctl_rdstruct(oldp, oldlenp, newp, &dev, sizeof(dev));
	case KERN_NETLIVELOCKS:
		return (sysctl_rdint(oldp, oldlenp, newp, net_livelocks));
	case KERN_POOL_DEBUG: {
		int old_pool_debug = pool_debug;

		error = sysctl_int(oldp, oldlenp, newp, newlen,
		    &pool_debug);
		if (error == 0 && pool_debug != old_pool_debug)
			pool_reclaim_all();
		return (error);
	}
#ifdef PTRACE
	case KERN_GLOBAL_PTRACE: {
		extern int global_ptrace;

		return sysctl_int(oldp, oldlenp, newp, newlen, &global_ptrace);
	}
#endif
	case KERN_DNSJACKPORT: {
		extern uint16_t dnsjackport;
		int port = dnsjackport;
		if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &port)))
			return error;
		if (port < 0 || port > USHRT_MAX)
			return EINVAL;
		dnsjackport = port;
		return 0;
	}
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

/*
 * hardware related system variables.
 */
char *hw_vendor, *hw_prod, *hw_uuid, *hw_serial, *hw_ver;
int allowpowerdown = 1;

int
hw_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	extern char machine[], cpu_model[];
	int err, cpuspeed;

	/* all sysctl names at this level except sensors are terminal */
	if (name[0] != HW_SENSORS && namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case HW_MACHINE:
		return (sysctl_rdstring(oldp, oldlenp, newp, machine));
	case HW_MODEL:
		return (sysctl_rdstring(oldp, oldlenp, newp, cpu_model));
	case HW_NCPU:
		return (sysctl_rdint(oldp, oldlenp, newp, ncpus));
	case HW_NCPUFOUND:
		return (sysctl_rdint(oldp, oldlenp, newp, ncpusfound));
	case HW_BYTEORDER:
		return (sysctl_rdint(oldp, oldlenp, newp, BYTE_ORDER));
	case HW_PHYSMEM:
		return (sysctl_rdint(oldp, oldlenp, newp, ptoa(physmem)));
	case HW_USERMEM:
		return (sysctl_rdint(oldp, oldlenp, newp,
		    ptoa(physmem - uvmexp.wired)));
	case HW_PAGESIZE:
		return (sysctl_rdint(oldp, oldlenp, newp, PAGE_SIZE));
	case HW_DISKNAMES:
		err = sysctl_diskinit(0, p);
		if (err)
			return err;
		if (disknames)
			return (sysctl_rdstring(oldp, oldlenp, newp,
			    disknames));
		else
			return (sysctl_rdstring(oldp, oldlenp, newp, ""));
	case HW_DISKSTATS:
		err = sysctl_diskinit(1, p);
		if (err)
			return err;
		return (sysctl_rdstruct(oldp, oldlenp, newp, diskstats,
		    disk_count * sizeof(struct diskstats)));
	case HW_DISKCOUNT:
		return (sysctl_rdint(oldp, oldlenp, newp, disk_count));
	case HW_CPUSPEED:
		if (!cpu_cpuspeed)
			return (EOPNOTSUPP);
		err = cpu_cpuspeed(&cpuspeed);
		if (err)
			return err;
		return (sysctl_rdint(oldp, oldlenp, newp, cpuspeed));
#ifndef	SMALL_KERNEL
	case HW_SENSORS:
		return (sysctl_sensors(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
	case HW_SETPERF:
		return (sysctl_hwsetperf(oldp, oldlenp, newp, newlen));
	case HW_PERFPOLICY:
		return (sysctl_hwperfpolicy(oldp, oldlenp, newp, newlen));
#endif /* !SMALL_KERNEL */
	case HW_VENDOR:
		if (hw_vendor)
			return (sysctl_rdstring(oldp, oldlenp, newp,
			    hw_vendor));
		else
			return (EOPNOTSUPP);
	case HW_PRODUCT:
		if (hw_prod)
			return (sysctl_rdstring(oldp, oldlenp, newp, hw_prod));
		else
			return (EOPNOTSUPP);
	case HW_VERSION:
		if (hw_ver)
			return (sysctl_rdstring(oldp, oldlenp, newp, hw_ver));
		else
			return (EOPNOTSUPP);
	case HW_SERIALNO:
		if (hw_serial)
			return (sysctl_rdstring(oldp, oldlenp, newp,
			    hw_serial));
		else
			return (EOPNOTSUPP);
	case HW_UUID:
		if (hw_uuid)
			return (sysctl_rdstring(oldp, oldlenp, newp, hw_uuid));
		else
			return (EOPNOTSUPP);
	case HW_PHYSMEM64:
		return (sysctl_rdquad(oldp, oldlenp, newp,
		    ptoa((psize_t)physmem)));
	case HW_USERMEM64:
		return (sysctl_rdquad(oldp, oldlenp, newp,
		    ptoa((psize_t)physmem - uvmexp.wired)));
	case HW_ALLOWPOWERDOWN:
		if (securelevel > 0)
			return (sysctl_rdint(oldp, oldlenp, newp,
			    allowpowerdown));
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &allowpowerdown));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

#ifdef DEBUG
/*
 * Debugging related system variables.
 */
extern struct ctldebug debug0, debug1;
struct ctldebug debug2, debug3, debug4;
struct ctldebug debug5, debug6, debug7, debug8, debug9;
struct ctldebug debug10, debug11, debug12, debug13, debug14;
struct ctldebug debug15, debug16, debug17, debug18, debug19;
static struct ctldebug *debugvars[CTL_DEBUG_MAXID] = {
	&debug0, &debug1, &debug2, &debug3, &debug4,
	&debug5, &debug6, &debug7, &debug8, &debug9,
	&debug10, &debug11, &debug12, &debug13, &debug14,
	&debug15, &debug16, &debug17, &debug18, &debug19,
};
int
debug_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	struct ctldebug *cdp;

	/* all sysctl names at this level are name and field */
	if (namelen != 2)
		return (ENOTDIR);		/* overloaded */
	if (name[0] < 0 || name[0] >= nitems(debugvars))
		return (EOPNOTSUPP);
	cdp = debugvars[name[0]];
	if (cdp->debugname == 0)
		return (EOPNOTSUPP);
	switch (name[1]) {
	case CTL_DEBUG_NAME:
		return (sysctl_rdstring(oldp, oldlenp, newp, cdp->debugname));
	case CTL_DEBUG_VALUE:
		return (sysctl_int(oldp, oldlenp, newp, newlen, cdp->debugvar));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}
#endif /* DEBUG */

/*
 * Reads, or writes that lower the value
 */
int
sysctl_int_lower(void *oldp, size_t *oldlenp, void *newp, size_t newlen, int *valp)
{
	unsigned int oval = *valp, val = *valp;
	int error;

	if (newp == NULL)
		return (sysctl_rdint(oldp, oldlenp, newp, *valp));

	if ((error = sysctl_int(oldp, oldlenp, newp, newlen, &val)))
		return (error);
	if (val > oval)
		return (EPERM);		/* do not allow raising */
	*(unsigned int *)valp = val;
	return (0);
}

/*
 * Validate parameters and get old / set new parameters
 * for an integer-valued sysctl function.
 */
int
sysctl_int(void *oldp, size_t *oldlenp, void *newp, size_t newlen, int *valp)
{
	int error = 0;

	if (oldp && *oldlenp < sizeof(int))
		return (ENOMEM);
	if (newp && newlen != sizeof(int))
		return (EINVAL);
	*oldlenp = sizeof(int);
	if (oldp)
		error = copyout(valp, oldp, sizeof(int));
	if (error == 0 && newp)
		error = copyin(newp, valp, sizeof(int));
	return (error);
}

/*
 * As above, but read-only.
 */
int
sysctl_rdint(void *oldp, size_t *oldlenp, void *newp, int val)
{
	int error = 0;

	if (oldp && *oldlenp < sizeof(int))
		return (ENOMEM);
	if (newp)
		return (EPERM);
	*oldlenp = sizeof(int);
	if (oldp)
		error = copyout((caddr_t)&val, oldp, sizeof(int));
	return (error);
}

/*
 * Array of integer values.
 */
int
sysctl_int_arr(int **valpp, int *name, u_int namelen, void *oldp,
    size_t *oldlenp, void *newp, size_t newlen)
{
	if (namelen > 1)
		return (ENOTDIR);
	if (name[0] < 0 || valpp[name[0]] == NULL)
		return (EOPNOTSUPP);
	return (sysctl_int(oldp, oldlenp, newp, newlen, valpp[name[0]]));
}

/*
 * Validate parameters and get old / set new parameters
 * for an integer-valued sysctl function.
 */
int
sysctl_quad(void *oldp, size_t *oldlenp, void *newp, size_t newlen,
    int64_t *valp)
{
	int error = 0;

	if (oldp && *oldlenp < sizeof(int64_t))
		return (ENOMEM);
	if (newp && newlen != sizeof(int64_t))
		return (EINVAL);
	*oldlenp = sizeof(int64_t);
	if (oldp)
		error = copyout(valp, oldp, sizeof(int64_t));
	if (error == 0 && newp)
		error = copyin(newp, valp, sizeof(int64_t));
	return (error);
}

/*
 * As above, but read-only.
 */
int
sysctl_rdquad(void *oldp, size_t *oldlenp, void *newp, int64_t val)
{
	int error = 0;

	if (oldp && *oldlenp < sizeof(int64_t))
		return (ENOMEM);
	if (newp)
		return (EPERM);
	*oldlenp = sizeof(int64_t);
	if (oldp)
		error = copyout((caddr_t)&val, oldp, sizeof(int64_t));
	return (error);
}

/*
 * Validate parameters and get old / set new parameters
 * for a string-valued sysctl function.
 */
int
sysctl_string(void *oldp, size_t *oldlenp, void *newp, size_t newlen, char *str,
    int maxlen)
{
	return sysctl__string(oldp, oldlenp, newp, newlen, str, maxlen, 0);
}

int
sysctl_tstring(void *oldp, size_t *oldlenp, void *newp, size_t newlen,
    char *str, int maxlen)
{
	return sysctl__string(oldp, oldlenp, newp, newlen, str, maxlen, 1);
}

int
sysctl__string(void *oldp, size_t *oldlenp, void *newp, size_t newlen,
    char *str, int maxlen, int trunc)
{
	int len, error = 0;

	len = strlen(str) + 1;
	if (oldp && *oldlenp < len) {
		if (trunc == 0 || *oldlenp == 0)
			return (ENOMEM);
	}
	if (newp && newlen >= maxlen)
		return (EINVAL);
	if (oldp) {
		if (trunc && *oldlenp < len) {
			len = *oldlenp;
			error = copyout(str, oldp, len - 1);
			if (error == 0)
				error = copyout("", (char *)oldp + len - 1, 1);
		} else {
			error = copyout(str, oldp, len);
		}
	}
	*oldlenp = len;
	if (error == 0 && newp) {
		error = copyin(newp, str, newlen);
		str[newlen] = 0;
	}
	return (error);
}

/*
 * As above, but read-only.
 */
int
sysctl_rdstring(void *oldp, size_t *oldlenp, void *newp, const char *str)
{
	int len, error = 0;

	len = strlen(str) + 1;
	if (oldp && *oldlenp < len)
		return (ENOMEM);
	if (newp)
		return (EPERM);
	*oldlenp = len;
	if (oldp)
		error = copyout(str, oldp, len);
	return (error);
}

/*
 * Validate parameters and get old / set new parameters
 * for a structure oriented sysctl function.
 */
int
sysctl_struct(void *oldp, size_t *oldlenp, void *newp, size_t newlen, void *sp,
    int len)
{
	int error = 0;

	if (oldp && *oldlenp < len)
		return (ENOMEM);
	if (newp && newlen > len)
		return (EINVAL);
	if (oldp) {
		*oldlenp = len;
		error = copyout(sp, oldp, len);
	}
	if (error == 0 && newp)
		error = copyin(newp, sp, len);
	return (error);
}

/*
 * Validate parameters and get old parameters
 * for a structure oriented sysctl function.
 */
int
sysctl_rdstruct(void *oldp, size_t *oldlenp, void *newp, const void *sp,
    int len)
{
	int error = 0;

	if (oldp && *oldlenp < len)
		return (ENOMEM);
	if (newp)
		return (EPERM);
	*oldlenp = len;
	if (oldp)
		error = copyout(sp, oldp, len);
	return (error);
}

#ifndef SMALL_KERNEL
void
fill_file(struct kinfo_file *kf, struct file *fp, struct filedesc *fdp,
	  int fd, struct vnode *vp, struct process *pr, struct proc *p,
	  struct socket *so, int show_pointers)
{
	struct vattr va;

	memset(kf, 0, sizeof(*kf));

	kf->fd_fd = fd;		/* might not really be an fd */

	if (fp != NULL) {
		if (show_pointers)
			kf->f_fileaddr = PTRTOINT64(fp);
		kf->f_flag = fp->f_flag;
		kf->f_iflags = fp->f_iflags;
		kf->f_type = fp->f_type;
		kf->f_count = fp->f_count;
		if (show_pointers)
			kf->f_ucred = PTRTOINT64(fp->f_cred);
		kf->f_uid = fp->f_cred->cr_uid;
		kf->f_gid = fp->f_cred->cr_gid;
		if (show_pointers)
			kf->f_ops = PTRTOINT64(fp->f_ops);
		if (show_pointers)
			kf->f_data = PTRTOINT64(fp->f_data);
		kf->f_usecount = 0;

		if (suser(p, 0) == 0 || p->p_ucred->cr_uid == fp->f_cred->cr_uid) {
			kf->f_offset = fp->f_offset;
			kf->f_rxfer = fp->f_rxfer;
			kf->f_rwfer = fp->f_wxfer;
			kf->f_seek = fp->f_seek;
			kf->f_rbytes = fp->f_rbytes;
			kf->f_wbytes = fp->f_wbytes;
		} else
			kf->f_offset = -1;
	} else if (vp != NULL) {
		/* fake it */
		kf->f_type = DTYPE_VNODE;
		kf->f_flag = FREAD;
		if (fd == KERN_FILE_TRACE)
			kf->f_flag |= FWRITE;
	} else if (so != NULL) {
		/* fake it */
		kf->f_type = DTYPE_SOCKET;
	}

	/* information about the object associated with this file */
	switch (kf->f_type) {
	case DTYPE_VNODE:
		if (fp != NULL)
			vp = (struct vnode *)fp->f_data;

		if (show_pointers)
			kf->v_un = PTRTOINT64(vp->v_un.vu_socket);
		kf->v_type = vp->v_type;
		kf->v_tag = vp->v_tag;
		kf->v_flag = vp->v_flag;
		if (show_pointers)
			kf->v_data = PTRTOINT64(vp->v_data);
		if (show_pointers)
			kf->v_mount = PTRTOINT64(vp->v_mount);
		if (vp->v_mount)
			strlcpy(kf->f_mntonname,
			    vp->v_mount->mnt_stat.f_mntonname,
			    sizeof(kf->f_mntonname));

		if (VOP_GETATTR(vp, &va, p->p_ucred, p) == 0) {
			kf->va_fileid = va.va_fileid;
			kf->va_mode = MAKEIMODE(va.va_type, va.va_mode);
			kf->va_size = va.va_size;
			kf->va_rdev = va.va_rdev;
			kf->va_fsid = va.va_fsid & 0xffffffff;
			kf->va_nlink = va.va_nlink;
		}
		break;

	case DTYPE_SOCKET: {
		if (so == NULL)
			so = (struct socket *)fp->f_data;

		kf->so_type = so->so_type;
		kf->so_state = so->so_state;
		if (show_pointers)
			kf->so_pcb = PTRTOINT64(so->so_pcb);
		else
			kf->so_pcb = -1;
		kf->so_protocol = so->so_proto->pr_protocol;
		kf->so_family = so->so_proto->pr_domain->dom_family;
		kf->so_rcv_cc = so->so_rcv.sb_cc;
		kf->so_snd_cc = so->so_snd.sb_cc;
		if (isspliced(so)) {
			if (show_pointers)
				kf->so_splice =
				    PTRTOINT64(so->so_sp->ssp_socket);
			kf->so_splicelen = so->so_sp->ssp_len;
		} else if (issplicedback(so))
			kf->so_splicelen = -1;
		if (!so->so_pcb)
			break;
		switch (kf->so_family) {
		case AF_INET: {
			struct inpcb *inpcb = so->so_pcb;

			if (show_pointers)
				kf->inp_ppcb = PTRTOINT64(inpcb->inp_ppcb);
			kf->inp_lport = inpcb->inp_lport;
			kf->inp_laddru[0] = inpcb->inp_laddr.s_addr;
			kf->inp_fport = inpcb->inp_fport;
			kf->inp_faddru[0] = inpcb->inp_faddr.s_addr;
			kf->inp_rtableid = inpcb->inp_rtableid;
			if (so->so_type == SOCK_RAW)
				kf->inp_proto = inpcb->inp_ip.ip_p;
			if (so->so_proto->pr_protocol == IPPROTO_TCP) {
				struct tcpcb *tcpcb = (void *)inpcb->inp_ppcb;
				kf->t_rcv_wnd = tcpcb->rcv_wnd;
				kf->t_snd_wnd = tcpcb->snd_wnd;
				kf->t_snd_cwnd = tcpcb->snd_cwnd;
				kf->t_state = tcpcb->t_state;
			}
			break;
		    }
		case AF_INET6: {
			struct inpcb *inpcb = so->so_pcb;

			kf->inp_ppcb = PTRTOINT64(inpcb->inp_ppcb);
			kf->inp_lport = inpcb->inp_lport;
			kf->inp_laddru[0] = inpcb->inp_laddr6.s6_addr32[0];
			kf->inp_laddru[1] = inpcb->inp_laddr6.s6_addr32[1];
			kf->inp_laddru[2] = inpcb->inp_laddr6.s6_addr32[2];
			kf->inp_laddru[3] = inpcb->inp_laddr6.s6_addr32[3];
			kf->inp_fport = inpcb->inp_fport;
			kf->inp_faddru[0] = inpcb->inp_faddr6.s6_addr32[0];
			kf->inp_faddru[1] = inpcb->inp_faddr6.s6_addr32[1];
			kf->inp_faddru[2] = inpcb->inp_faddr6.s6_addr32[2];
			kf->inp_faddru[3] = inpcb->inp_faddr6.s6_addr32[3];
			kf->inp_rtableid = inpcb->inp_rtableid;
			if (so->so_type == SOCK_RAW)
				kf->inp_proto = inpcb->inp_ipv6.ip6_nxt;
			if (so->so_proto->pr_protocol == IPPROTO_TCP) {
				struct tcpcb *tcpcb = (void *)inpcb->inp_ppcb;
				kf->t_rcv_wnd = tcpcb->rcv_wnd;
				kf->t_snd_wnd = tcpcb->snd_wnd;
				kf->t_state = tcpcb->t_state;
			}
			break;
		    }
		case AF_UNIX: {
			struct unpcb *unpcb = so->so_pcb;

			kf->f_msgcount = unpcb->unp_msgcount;
			if (show_pointers) {
				kf->unp_conn	= PTRTOINT64(unpcb->unp_conn);
				kf->unp_refs	= PTRTOINT64(
				    SLIST_FIRST(&unpcb->unp_refs));
				kf->unp_nextref	= PTRTOINT64(
				    SLIST_NEXT(unpcb, unp_nextref));
				kf->v_un	= PTRTOINT64(unpcb->unp_vnode);
				kf->unp_addr	= PTRTOINT64(unpcb->unp_addr);
			}
			if (unpcb->unp_addr != NULL) {
				struct sockaddr_un *un = mtod(unpcb->unp_addr,
				    struct sockaddr_un *);
				memcpy(kf->unp_path, un->sun_path, un->sun_len
				    - offsetof(struct sockaddr_un,sun_path));
			}
			break;
		    }
		}
		break;
	    }

	case DTYPE_PIPE: {
		struct pipe *pipe = (struct pipe *)fp->f_data;

		if (show_pointers)
			kf->pipe_peer = PTRTOINT64(pipe->pipe_peer);
		kf->pipe_state = pipe->pipe_state;
		break;
	    }

	case DTYPE_KQUEUE: {
		struct kqueue *kqi = (struct kqueue *)fp->f_data;

		kf->kq_count = kqi->kq_count;
		kf->kq_state = kqi->kq_state;
		break;
	    }
	}

	/* per-process information for KERN_FILE_BY[PU]ID */
	if (pr != NULL) {
		kf->p_pid = pr->ps_pid;
		kf->p_uid = pr->ps_ucred->cr_uid;
		kf->p_gid = pr->ps_ucred->cr_gid;
		kf->p_tid = -1;
		strlcpy(kf->p_comm, pr->ps_comm, sizeof(kf->p_comm));
	}
	if (fdp != NULL)
		kf->fd_ofileflags = fdp->fd_ofileflags[fd];
}

/*
 * Get file structures.
 */
int
sysctl_file(int *name, u_int namelen, char *where, size_t *sizep,
    struct proc *p)
{
	struct kinfo_file *kf;
	struct filedesc *fdp;
	struct file *fp, *nfp;
	struct process *pr;
	size_t buflen, elem_size, elem_count, outsize;
	char *dp = where;
	int arg, i, error = 0, needed = 0, matched;
	u_int op;
	int show_pointers;

	if (namelen > 4)
		return (ENOTDIR);
	if (namelen < 4 || name[2] > sizeof(*kf))
		return (EINVAL);

	buflen = where != NULL ? *sizep : 0;
	op = name[0];
	arg = name[1];
	elem_size = name[2];
	elem_count = name[3];
	outsize = MIN(sizeof(*kf), elem_size);

	if (elem_size < 1)
		return (EINVAL);

	show_pointers = suser(curproc, 0) == 0;

	kf = malloc(sizeof(*kf), M_TEMP, M_WAITOK);

#define FILLIT2(fp, fdp, i, vp, pr, so) do {				\
	if (buflen >= elem_size && elem_count > 0) {			\
		fill_file(kf, fp, fdp, i, vp, pr, p, so, show_pointers);\
		error = copyout(kf, dp, outsize);			\
		if (error)						\
			break;						\
		dp += elem_size;					\
		buflen -= elem_size;					\
		elem_count--;						\
	}								\
	needed += elem_size;						\
} while (0)
#define FILLIT(fp, fdp, i, vp, pr) \
	FILLIT2(fp, fdp, i, vp, pr, NULL)
#define FILLSO(so) \
	FILLIT2(NULL, NULL, 0, NULL, NULL, so)

	switch (op) {
	case KERN_FILE_BYFILE:
		/* use the inp-tables to pick up closed connections, too */
		if (arg == DTYPE_SOCKET) {
			extern struct inpcbtable rawcbtable;
#ifdef INET6
			extern struct inpcbtable rawin6pcbtable;
#endif
			struct inpcb *inp;
			int s;

			NET_LOCK(s);
			TAILQ_FOREACH(inp, &tcbtable.inpt_queue, inp_queue)
				FILLSO(inp->inp_socket);
			TAILQ_FOREACH(inp, &udbtable.inpt_queue, inp_queue)
				FILLSO(inp->inp_socket);
			TAILQ_FOREACH(inp, &rawcbtable.inpt_queue, inp_queue)
				FILLSO(inp->inp_socket);
#ifdef INET6
			TAILQ_FOREACH(inp, &rawin6pcbtable.inpt_queue,
			    inp_queue)
				FILLSO(inp->inp_socket);
#endif
			NET_UNLOCK(s);
		}
		fp = LIST_FIRST(&filehead);
		/* don't FREF when f_count == 0 to avoid race in fdrop() */
		while (fp != NULL && fp->f_count == 0)
			fp = LIST_NEXT(fp, f_list);
		if (fp == NULL)
			break;
		FREF(fp);
		do {
			if (fp->f_count > 1 && /* 0, +1 for our FREF() */
			    (arg == 0 || fp->f_type == arg)) {
				int af, skip = 0;
				if (arg == DTYPE_SOCKET && fp->f_type == arg) {
					af = ((struct socket *)fp->f_data)->
					    so_proto->pr_domain->dom_family;
					if (af == AF_INET || af == AF_INET6)
						skip = 1;
				}
				if (!skip)
					FILLIT(fp, NULL, 0, NULL, NULL);
			}
			nfp = LIST_NEXT(fp, f_list);
			while (nfp != NULL && nfp->f_count == 0)
				nfp = LIST_NEXT(nfp, f_list);
			if (nfp != NULL)
				FREF(nfp);
			FRELE(fp, p);
			fp = nfp;
		} while (fp != NULL);
		break;
	case KERN_FILE_BYPID:
		/* A arg of -1 indicates all processes */
		if (arg < -1) {
			error = EINVAL;
			break;
		}
		matched = 0;
		LIST_FOREACH(pr, &allprocess, ps_list) {
			/*
			 * skip system, exiting, embryonic and undead
			 * processes
			 */
			if (pr->ps_flags & (PS_SYSTEM | PS_EMBRYO | PS_EXITING))
				continue;
			if (arg > 0 && pr->ps_pid != (pid_t)arg) {
				/* not the pid we are looking for */
				continue;
			}
			matched = 1;
			fdp = pr->ps_fd;
			if (pr->ps_textvp)
				FILLIT(NULL, NULL, KERN_FILE_TEXT, pr->ps_textvp, pr);
			if (fdp->fd_cdir)
				FILLIT(NULL, NULL, KERN_FILE_CDIR, fdp->fd_cdir, pr);
			if (fdp->fd_rdir)
				FILLIT(NULL, NULL, KERN_FILE_RDIR, fdp->fd_rdir, pr);
			if (pr->ps_tracevp)
				FILLIT(NULL, NULL, KERN_FILE_TRACE, pr->ps_tracevp, pr);
			for (i = 0; i < fdp->fd_nfiles; i++) {
				if ((fp = fdp->fd_ofiles[i]) == NULL)
					continue;
				if (!FILE_IS_USABLE(fp))
					continue;
				FILLIT(fp, fdp, i, NULL, pr);
			}
		}
		if (!matched)
			error = ESRCH;
		break;
	case KERN_FILE_BYUID:
		LIST_FOREACH(pr, &allprocess, ps_list) {
			/*
			 * skip system, exiting, embryonic and undead
			 * processes
			 */
			if (pr->ps_flags & (PS_SYSTEM | PS_EMBRYO | PS_EXITING))
				continue;
			if (arg >= 0 && pr->ps_ucred->cr_uid != (uid_t)arg) {
				/* not the uid we are looking for */
				continue;
			}
			fdp = pr->ps_fd;
			if (fdp->fd_cdir)
				FILLIT(NULL, NULL, KERN_FILE_CDIR, fdp->fd_cdir, pr);
			if (fdp->fd_rdir)
				FILLIT(NULL, NULL, KERN_FILE_RDIR, fdp->fd_rdir, pr);
			if (pr->ps_tracevp)
				FILLIT(NULL, NULL, KERN_FILE_TRACE, pr->ps_tracevp, pr);
			for (i = 0; i < fdp->fd_nfiles; i++) {
				if ((fp = fdp->fd_ofiles[i]) == NULL)
					continue;
				if (!FILE_IS_USABLE(fp))
					continue;
				FILLIT(fp, fdp, i, NULL, pr);
			}
		}
		break;
	default:
		error = EINVAL;
		break;
	}
	free(kf, M_TEMP, sizeof(*kf));

	if (!error) {
		if (where == NULL)
			needed += KERN_FILESLOP * elem_size;
		else if (*sizep < needed)
			error = ENOMEM;
		*sizep = needed;
	}

	return (error);
}

/*
 * try over estimating by 5 procs
 */
#define KERN_PROCSLOP	5

int
sysctl_doproc(int *name, u_int namelen, char *where, size_t *sizep)
{
	struct kinfo_proc *kproc = NULL;
	struct proc *p;
	struct process *pr;
	char *dp;
	int arg, buflen, doingzomb, elem_size, elem_count;
	int error, needed, op;
	int dothreads = 0;
	int show_pointers;

	dp = where;
	buflen = where != NULL ? *sizep : 0;
	needed = error = 0;

	if (namelen != 4 || name[2] < 0 || name[3] < 0 ||
	    name[2] > sizeof(*kproc))
		return (EINVAL);
	op = name[0];
	arg = name[1];
	elem_size = name[2];
	elem_count = name[3];

	dothreads = op & KERN_PROC_SHOW_THREADS;
	op &= ~KERN_PROC_SHOW_THREADS;

	show_pointers = suser(curproc, 0) == 0;

	if (where != NULL)
		kproc = malloc(sizeof(*kproc), M_TEMP, M_WAITOK);

	pr = LIST_FIRST(&allprocess);
	doingzomb = 0;
again:
	for (; pr != NULL; pr = LIST_NEXT(pr, ps_list)) {
		/* XXX skip processes in the middle of being zapped */
		if (pr->ps_pgrp == NULL)
			continue;

		/*
		 * Skip embryonic processes.
		 */
		if (pr->ps_flags & PS_EMBRYO)
			continue;

		/*
		 * TODO - make more efficient (see notes below).
		 */
		switch (op) {

		case KERN_PROC_PID:
			/* could do this with just a lookup */
			if (pr->ps_pid != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_PGRP:
			/* could do this by traversing pgrp */
			if (pr->ps_pgrp->pg_id != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_SESSION:
			if (pr->ps_session->s_leader == NULL ||
			    pr->ps_session->s_leader->ps_pid != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_TTY:
			if ((pr->ps_flags & PS_CONTROLT) == 0 ||
			    pr->ps_session->s_ttyp == NULL ||
			    pr->ps_session->s_ttyp->t_dev != (dev_t)arg)
				continue;
			break;

		case KERN_PROC_UID:
			if (pr->ps_ucred->cr_uid != (uid_t)arg)
				continue;
			break;

		case KERN_PROC_RUID:
			if (pr->ps_ucred->cr_ruid != (uid_t)arg)
				continue;
			break;

		case KERN_PROC_ALL:
			if (pr->ps_flags & PS_SYSTEM)
				continue;
			break;

		case KERN_PROC_KTHREAD:
			/* no filtering */
			break;

		default:
			error = EINVAL;
			goto err;
		}

		if (buflen >= elem_size && elem_count > 0) {
			fill_kproc(pr, kproc, NULL, show_pointers);
			error = copyout(kproc, dp, elem_size);
			if (error)
				goto err;
			dp += elem_size;
			buflen -= elem_size;
			elem_count--;
		}
		needed += elem_size;

		/* Skip per-thread entries if not required by op */
		if (!dothreads)
			continue;

		TAILQ_FOREACH(p, &pr->ps_threads, p_thr_link) {
			if (buflen >= elem_size && elem_count > 0) {
				fill_kproc(pr, kproc, p, show_pointers);
				error = copyout(kproc, dp, elem_size);
				if (error)
					goto err;
				dp += elem_size;
				buflen -= elem_size;
				elem_count--;
			}
			needed += elem_size;
		}
	}
	if (doingzomb == 0) {
		pr = LIST_FIRST(&zombprocess);
		doingzomb++;
		goto again;
	}
	if (where != NULL) {
		*sizep = dp - where;
		if (needed > *sizep) {
			error = ENOMEM;
			goto err;
		}
	} else {
		needed += KERN_PROCSLOP * elem_size;
		*sizep = needed;
	}
err:
	if (kproc)
		free(kproc, M_TEMP, sizeof(*kproc));
	return (error);
}

/*
 * Fill in a kproc structure for the specified process.
 */
void
fill_kproc(struct process *pr, struct kinfo_proc *ki, struct proc *p,
    int show_pointers)
{
	struct session *s = pr->ps_session;
	struct tty *tp;
	struct vmspace *vm = pr->ps_vmspace;
	struct timespec ut, st;
	int isthread;

	isthread = p != NULL;
	if (!isthread)
		p = pr->ps_mainproc;		/* XXX */

	FILL_KPROC(ki, strlcpy, p, pr, pr->ps_ucred, pr->ps_pgrp,
	    p, pr, s, vm, pr->ps_limit, pr->ps_sigacts, isthread,
	    show_pointers);

	/* stuff that's too painful to generalize into the macros */
	if (pr->ps_pptr)
		ki->p_ppid = pr->ps_pptr->ps_pid;
	if (s->s_leader)
		ki->p_sid = s->s_leader->ps_pid;

	if ((pr->ps_flags & PS_CONTROLT) && (tp = s->s_ttyp)) {
		ki->p_tdev = tp->t_dev;
		ki->p_tpgid = tp->t_pgrp ? tp->t_pgrp->pg_id : -1;
		if (show_pointers)
			ki->p_tsess = PTRTOINT64(tp->t_session);
	} else {
		ki->p_tdev = NODEV;
		ki->p_tpgid = -1;
	}

	/* fixups that can only be done in the kernel */
	if ((pr->ps_flags & PS_ZOMBIE) == 0) {
		if ((pr->ps_flags & PS_EMBRYO) == 0 && vm != NULL)
			ki->p_vm_rssize = vm_resident_count(vm);
		calctsru(isthread ? &p->p_tu : &pr->ps_tu, &ut, &st, NULL);
		ki->p_uutime_sec = ut.tv_sec;
		ki->p_uutime_usec = ut.tv_nsec/1000;
		ki->p_ustime_sec = st.tv_sec;
		ki->p_ustime_usec = st.tv_nsec/1000;

#ifdef MULTIPROCESSOR
		if (p->p_cpu != NULL)
			ki->p_cpuid = CPU_INFO_UNIT(p->p_cpu);
#endif
	}

	/* get %cpu and schedule state: just one thread or sum of all? */
	if (isthread) {
		ki->p_pctcpu = p->p_pctcpu;
		ki->p_stat   = p->p_stat;
	} else {
		ki->p_pctcpu = 0;
		ki->p_stat = (pr->ps_flags & PS_ZOMBIE) ? SDEAD : SIDL;
		TAILQ_FOREACH(p, &pr->ps_threads, p_thr_link) {
			ki->p_pctcpu += p->p_pctcpu;
			/* find best state: ONPROC > RUN > STOP > SLEEP > .. */
			if (p->p_stat == SONPROC || ki->p_stat == SONPROC)
				ki->p_stat = SONPROC;
			else if (p->p_stat == SRUN || ki->p_stat == SRUN)
				ki->p_stat = SRUN;
			else if (p->p_stat == SSTOP || ki->p_stat == SSTOP)
				ki->p_stat = SSTOP;
			else if (p->p_stat == SSLEEP)
				ki->p_stat = SSLEEP;
		}
	}
}

int
sysctl_proc_args(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    struct proc *cp)
{
	struct process *vpr;
	pid_t pid;
	struct ps_strings pss;
	struct iovec iov;
	struct uio uio;
	int error, cnt, op;
	size_t limit;
	char **rargv, **vargv;		/* reader vs. victim */
	char *rarg, *varg, *buf;
	struct vmspace *vm;
	vaddr_t ps_strings;

	if (namelen > 2)
		return (ENOTDIR);
	if (namelen < 2)
		return (EINVAL);

	pid = name[0];
	op = name[1];

	switch (op) {
	case KERN_PROC_ARGV:
	case KERN_PROC_NARGV:
	case KERN_PROC_ENV:
	case KERN_PROC_NENV:
		break;
	default:
		return (EOPNOTSUPP);
	}

	if ((vpr = prfind(pid)) == NULL)
		return (ESRCH);

	if (oldp == NULL) {
		if (op == KERN_PROC_NARGV || op == KERN_PROC_NENV)
			*oldlenp = sizeof(int);
		else
			*oldlenp = ARG_MAX;	/* XXX XXX XXX */
		return (0);
	}

	/* Either system process or exiting/zombie */
	if (vpr->ps_flags & (PS_SYSTEM | PS_EXITING))
		return (EINVAL);

	/* Execing - danger. */
	if ((vpr->ps_flags & PS_INEXEC))
		return (EBUSY);
	
	/* Only owner or root can get env */
	if ((op == KERN_PROC_NENV || op == KERN_PROC_ENV) &&
	    (vpr->ps_ucred->cr_uid != cp->p_ucred->cr_uid &&
	    (error = suser(cp, 0)) != 0))
		return (error);

	ps_strings = vpr->ps_strings;
	vm = vpr->ps_vmspace;
	vm->vm_refcnt++;
	vpr = NULL;

	buf = malloc(PAGE_SIZE, M_TEMP, M_WAITOK);

	iov.iov_base = &pss;
	iov.iov_len = sizeof(pss);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;
	uio.uio_offset = (off_t)ps_strings;
	uio.uio_resid = sizeof(pss);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = cp;

	if ((error = uvm_io(&vm->vm_map, &uio, 0)) != 0)
		goto out;

	if (op == KERN_PROC_NARGV) {
		error = sysctl_rdint(oldp, oldlenp, NULL, pss.ps_nargvstr);
		goto out;
	}
	if (op == KERN_PROC_NENV) {
		error = sysctl_rdint(oldp, oldlenp, NULL, pss.ps_nenvstr);
		goto out;
	}

	if (op == KERN_PROC_ARGV) {
		cnt = pss.ps_nargvstr;
		vargv = pss.ps_argvstr;
	} else {
		cnt = pss.ps_nenvstr;
		vargv = pss.ps_envstr;
	}

	/* -1 to have space for a terminating NUL */
	limit = *oldlenp - 1;
	*oldlenp = 0;

	rargv = oldp;

	/*
	 * *oldlenp - number of bytes copied out into readers buffer.
	 * limit - maximal number of bytes allowed into readers buffer.
	 * rarg - pointer into readers buffer where next arg will be stored.
	 * rargv - pointer into readers buffer where the next rarg pointer
	 *  will be stored.
	 * vargv - pointer into victim address space where the next argument
	 *  will be read.
	 */

	/* space for cnt pointers and a NULL */
	rarg = (char *)(rargv + cnt + 1);
	*oldlenp += (cnt + 1) * sizeof(char **);

	while (cnt > 0 && *oldlenp < limit) {
		size_t len, vstrlen;

		/* Write to readers argv */
		if ((error = copyout(&rarg, rargv, sizeof(rarg))) != 0)
			goto out;

		/* read the victim argv */
		iov.iov_base = &varg;
		iov.iov_len = sizeof(varg);
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(vaddr_t)vargv;
		uio.uio_resid = sizeof(varg);
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_READ;
		uio.uio_procp = cp;
		if ((error = uvm_io(&vm->vm_map, &uio, 0)) != 0)
			goto out;

		if (varg == NULL)
			break;

		/*
		 * read the victim arg. We must jump through hoops to avoid
		 * crossing a page boundary too much and returning an error.
		 */
more:
		len = PAGE_SIZE - (((vaddr_t)varg) & PAGE_MASK);
		/* leave space for the terminating NUL */
		iov.iov_base = buf;
		iov.iov_len = len;
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(vaddr_t)varg;
		uio.uio_resid = len;
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_READ;
		uio.uio_procp = cp;
		if ((error = uvm_io(&vm->vm_map, &uio, 0)) != 0)
			goto out;

		for (vstrlen = 0; vstrlen < len; vstrlen++) {
			if (buf[vstrlen] == '\0')
				break;
		}

		/* Don't overflow readers buffer. */
		if (*oldlenp + vstrlen + 1 >= limit) {
			error = ENOMEM;
			goto out;
		}

		if ((error = copyout(buf, rarg, vstrlen)) != 0)
			goto out;

		*oldlenp += vstrlen;
		rarg += vstrlen;

		/* The string didn't end in this page? */
		if (vstrlen == len) {
			varg += vstrlen;
			goto more;
		}

		/* End of string. Terminate it with a NUL */
		buf[0] = '\0';
		if ((error = copyout(buf, rarg, 1)) != 0)
			goto out;
		*oldlenp += 1;
		rarg += 1;

		vargv++;
		rargv++;
		cnt--;
	}

	if (*oldlenp >= limit) {
		error = ENOMEM;
		goto out;
	}

	/* Write the terminating null */
	rarg = NULL;
	error = copyout(&rarg, rargv, sizeof(rarg));

out:
	uvmspace_free(vm);
	free(buf, M_TEMP, PAGE_SIZE);
	return (error);
}

int
sysctl_proc_cwd(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    struct proc *cp)
{
	struct process *findpr;
	struct vnode *vp;
	pid_t pid;
	int error;
	size_t lenused, len;
	char *path, *bp, *bend;

	if (namelen > 1)
		return (ENOTDIR);
	if (namelen < 1)
		return (EINVAL);

	pid = name[0];
	if ((findpr = prfind(pid)) == NULL)
		return (ESRCH);

	if (oldp == NULL) {
		*oldlenp = MAXPATHLEN * 4;
		return (0);
	}

	/* Either system process or exiting/zombie */
	if (findpr->ps_flags & (PS_SYSTEM | PS_EXITING))
		return (EINVAL);

	/* Only owner or root can get cwd */
	if (findpr->ps_ucred->cr_uid != cp->p_ucred->cr_uid &&
	    (error = suser(cp, 0)) != 0)
		return (error);

	len = *oldlenp;
	if (len > MAXPATHLEN * 4)
		len = MAXPATHLEN * 4;
	else if (len < 2)
		return (ERANGE);
	*oldlenp = 0;

	/* snag a reference to the vnode before we can sleep */
	vp = findpr->ps_fd->fd_cdir;
	vref(vp);

	path = malloc(len, M_TEMP, M_WAITOK);

	bp = &path[len];
	bend = bp;
	*(--bp) = '\0';

	/* Same as sys__getcwd */
	error = vfs_getcwd_common(vp, NULL,
	    &bp, path, len / 2, GETCWD_CHECK_ACCESS, cp);
	if (error == 0) {
		*oldlenp = lenused = bend - bp;
		error = copyout(bp, oldp, lenused);
	}

	vrele(vp);
	free(path, M_TEMP, len);

	return (error);
}

int
sysctl_proc_nobroadcastkill(int *name, u_int namelen, void *newp, size_t newlen,
    void *oldp, size_t *oldlenp, struct proc *cp)
{
	struct process *findpr;
	pid_t pid;
	int error, flag;

	if (namelen > 1)
		return (ENOTDIR);
	if (namelen < 1)
		return (EINVAL);

	pid = name[0];
	if ((findpr = prfind(pid)) == NULL)
		return (ESRCH);

	/* Either system process or exiting/zombie */
	if (findpr->ps_flags & (PS_SYSTEM | PS_EXITING))
		return (EINVAL);

	/* Only root can change PS_NOBROADCASTKILL */
	if (newp != 0 && (error = suser(cp, 0)) != 0)
		return (error);

	/* get the PS_NOBROADCASTKILL flag */
	flag = findpr->ps_flags & PS_NOBROADCASTKILL ? 1 : 0;

	error = sysctl_int(oldp, oldlenp, newp, newlen, &flag);
	if (error == 0 && newp) {
		if (flag)
			atomic_setbits_int(&findpr->ps_flags,
			    PS_NOBROADCASTKILL);
		else
			atomic_clearbits_int(&findpr->ps_flags,
			    PS_NOBROADCASTKILL);
	}

	return (error);
}

/* Arbitrary but reasonable limit for one iteration. */
#define	VMMAP_MAXLEN	MAXPHYS

int
sysctl_proc_vmmap(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    struct proc *cp)
{
	struct process *findpr;
	pid_t pid;
	int error;
	size_t oldlen, len;
	struct kinfo_vmentry *kve, *ukve;
	u_long *ustart, start;

	if (namelen > 1)
		return (ENOTDIR);
	if (namelen < 1)
		return (EINVAL);

	/* Provide max buffer length as hint. */
	if (oldp == NULL) {
		if (oldlenp == NULL)
			return (EINVAL);
		else {
			*oldlenp = VMMAP_MAXLEN;
			return (0);
		}
	}

	pid = name[0];
	if (pid == cp->p_p->ps_pid) {
		/* Self process mapping. */
		findpr = cp->p_p;
	} else if (pid > 0) {
		if ((findpr = prfind(pid)) == NULL)
			return (ESRCH);

		/* Either system process or exiting/zombie */
		if (findpr->ps_flags & (PS_SYSTEM | PS_EXITING))
			return (EINVAL);

#if 1
		/* XXX Allow only root for now */
		if ((error = suser(cp, 0)) != 0)
			return (error);
#else
		/* Only owner or root can get vmmap */
		if (findpr->ps_ucred->cr_uid != cp->p_ucred->cr_uid &&
		    (error = suser(cp, 0)) != 0)
			return (error);
#endif
	} else {
		/* Only root can get kernel_map */
		if ((error = suser(cp, 0)) != 0)
			return (error);
		findpr = NULL;
	}

	/* Check the given size. */
	oldlen = *oldlenp;
	if (oldlen == 0 || oldlen % sizeof(*kve) != 0)
		return (EINVAL);

	/* Deny huge allocation. */
	if (oldlen > VMMAP_MAXLEN)
		return (EINVAL);

	/*
	 * Iterate from the given address passed as the first element's
	 * kve_start via oldp.
	 */
	ukve = (struct kinfo_vmentry *)oldp;
	ustart = &ukve->kve_start;
	error = copyin(ustart, &start, sizeof(start));
	if (error != 0)
		return (error);

	/* Allocate wired memory to not block. */
	kve = malloc(oldlen, M_TEMP, M_WAITOK);

	/* Set the base address and read entries. */
	kve[0].kve_start = start;
	len = oldlen;
	error = fill_vmmap(findpr, kve, &len);
	if (error != 0 && error != ENOMEM)
		goto done;
	if (len == 0)
		goto done;

	KASSERT(len <= oldlen);
	KASSERT((len % sizeof(struct kinfo_vmentry)) == 0);

	error = copyout(kve, oldp, len);

done:
	*oldlenp = len;

	free(kve, M_TEMP, oldlen);

	return (error);
}
#endif

/*
 * Initialize disknames/diskstats for export by sysctl. If update is set,
 * then we simply update the disk statistics information.
 */
int
sysctl_diskinit(int update, struct proc *p)
{
	struct diskstats *sdk;
	struct disk *dk;
	const char *duid;
	int i, tlen, l;

	if ((i = rw_enter(&sysctl_disklock, RW_WRITE|RW_INTR)) != 0)
		return i;

	if (disk_change) {
		for (dk = TAILQ_FIRST(&disklist), tlen = 0; dk;
		    dk = TAILQ_NEXT(dk, dk_link)) {
			if (dk->dk_name)
				tlen += strlen(dk->dk_name);
			tlen += 18;	/* label uid + separators */
		}
		tlen++;

		if (disknames)
			free(disknames, M_SYSCTL, disknameslen);
		if (diskstats)
			free(diskstats, M_SYSCTL, diskstatslen);
		diskstats = NULL;
		disknames = NULL;
		diskstats = mallocarray(disk_count, sizeof(struct diskstats),
		    M_SYSCTL, M_WAITOK);
		diskstatslen = disk_count * sizeof(struct diskstats);
		disknames = malloc(tlen, M_SYSCTL, M_WAITOK);
		disknameslen = tlen;
		disknames[0] = '\0';

		for (dk = TAILQ_FIRST(&disklist), i = 0, l = 0; dk;
		    dk = TAILQ_NEXT(dk, dk_link), i++) {
			duid = NULL;
			if (dk->dk_label && !duid_iszero(dk->dk_label->d_uid))
				duid = duid_format(dk->dk_label->d_uid);
			snprintf(disknames + l, tlen - l, "%s:%s,",
			    dk->dk_name ? dk->dk_name : "",
			    duid ? duid : "");
			l += strlen(disknames + l);
			sdk = diskstats + i;
			strlcpy(sdk->ds_name, dk->dk_name,
			    sizeof(sdk->ds_name));
			mtx_enter(&dk->dk_mtx);
			sdk->ds_busy = dk->dk_busy;
			sdk->ds_rxfer = dk->dk_rxfer;
			sdk->ds_wxfer = dk->dk_wxfer;
			sdk->ds_seek = dk->dk_seek;
			sdk->ds_rbytes = dk->dk_rbytes;
			sdk->ds_wbytes = dk->dk_wbytes;
			sdk->ds_attachtime = dk->dk_attachtime;
			sdk->ds_timestamp = dk->dk_timestamp;
			sdk->ds_time = dk->dk_time;
			mtx_leave(&dk->dk_mtx);
		}

		/* Eliminate trailing comma */
		if (l != 0)
			disknames[l - 1] = '\0';
		disk_change = 0;
	} else if (update) {
		/* Just update, number of drives hasn't changed */
		for (dk = TAILQ_FIRST(&disklist), i = 0; dk;
		    dk = TAILQ_NEXT(dk, dk_link), i++) {
			sdk = diskstats + i;
			strlcpy(sdk->ds_name, dk->dk_name,
			    sizeof(sdk->ds_name));
			mtx_enter(&dk->dk_mtx);
			sdk->ds_busy = dk->dk_busy;
			sdk->ds_rxfer = dk->dk_rxfer;
			sdk->ds_wxfer = dk->dk_wxfer;
			sdk->ds_seek = dk->dk_seek;
			sdk->ds_rbytes = dk->dk_rbytes;
			sdk->ds_wbytes = dk->dk_wbytes;
			sdk->ds_attachtime = dk->dk_attachtime;
			sdk->ds_timestamp = dk->dk_timestamp;
			sdk->ds_time = dk->dk_time;
			mtx_leave(&dk->dk_mtx);
		}
	}
	rw_exit_write(&sysctl_disklock);
	return 0;
}

#if defined(SYSVMSG) || defined(SYSVSEM) || defined(SYSVSHM)
int
sysctl_sysvipc(int *name, u_int namelen, void *where, size_t *sizep)
{
#ifdef SYSVSEM
	struct sem_sysctl_info *semsi;
#endif
#ifdef SYSVSHM
	struct shm_sysctl_info *shmsi;
#endif
	size_t infosize, dssize, tsize, buflen, bufsiz;
	int i, nds, error, ret;
	void *buf;

	if (namelen != 1)
		return (EINVAL);

	buflen = *sizep;

	switch (*name) {
	case KERN_SYSVIPC_MSG_INFO:
#ifdef SYSVMSG
		return (sysctl_sysvmsg(name, namelen, where, sizep));
#else
		return (EOPNOTSUPP);
#endif
	case KERN_SYSVIPC_SEM_INFO:
#ifdef SYSVSEM
		infosize = sizeof(semsi->seminfo);
		nds = seminfo.semmni;
		dssize = sizeof(semsi->semids[0]);
		break;
#else
		return (EOPNOTSUPP);
#endif
	case KERN_SYSVIPC_SHM_INFO:
#ifdef SYSVSHM
		infosize = sizeof(shmsi->shminfo);
		nds = shminfo.shmmni;
		dssize = sizeof(shmsi->shmids[0]);
		break;
#else
		return (EOPNOTSUPP);
#endif
	default:
		return (EINVAL);
	}
	tsize = infosize + (nds * dssize);

	/* Return just the total size required. */
	if (where == NULL) {
		*sizep = tsize;
		return (0);
	}

	/* Not enough room for even the info struct. */
	if (buflen < infosize) {
		*sizep = 0;
		return (ENOMEM);
	}
	bufsiz = min(tsize, buflen);
	buf = malloc(bufsiz, M_TEMP, M_WAITOK|M_ZERO);

	switch (*name) {
#ifdef SYSVSEM
	case KERN_SYSVIPC_SEM_INFO:
		semsi = (struct sem_sysctl_info *)buf;
		semsi->seminfo = seminfo;
		break;
#endif
#ifdef SYSVSHM
	case KERN_SYSVIPC_SHM_INFO:
		shmsi = (struct shm_sysctl_info *)buf;
		shmsi->shminfo = shminfo;
		break;
#endif
	}
	buflen -= infosize;

	ret = 0;
	if (buflen > 0) {
		/* Fill in the IPC data structures.  */
		for (i = 0; i < nds; i++) {
			if (buflen < dssize) {
				ret = ENOMEM;
				break;
			}
			switch (*name) {
#ifdef SYSVSEM
			case KERN_SYSVIPC_SEM_INFO:
				if (sema[i] != NULL)
					memcpy(&semsi->semids[i], sema[i],
					    dssize);
				else
					memset(&semsi->semids[i], 0, dssize);
				break;
#endif
#ifdef SYSVSHM
			case KERN_SYSVIPC_SHM_INFO:
				if (shmsegs[i] != NULL)
					memcpy(&shmsi->shmids[i], shmsegs[i],
					    dssize);
				else
					memset(&shmsi->shmids[i], 0, dssize);
				break;
#endif
			}
			buflen -= dssize;
		}
	}
	*sizep -= buflen;
	error = copyout(buf, where, *sizep);
	free(buf, M_TEMP, bufsiz);
	/* If copyout succeeded, use return code set earlier. */
	return (error ? error : ret);
}
#endif /* SYSVMSG || SYSVSEM || SYSVSHM */

#ifndef	SMALL_KERNEL

int
sysctl_intrcnt(int *name, u_int namelen, void *oldp, size_t *oldlenp)
{
	return (evcount_sysctl(name, namelen, oldp, oldlenp, NULL, 0));
}


int
sysctl_sensors(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	struct ksensor *ks;
	struct sensor *us;
	struct ksensordev *ksd;
	struct sensordev *usd;
	int dev, numt, ret;
	enum sensor_type type;

	if (namelen != 1 && namelen != 3)
		return (ENOTDIR);

	dev = name[0];
	if (namelen == 1) {
		ret = sensordev_get(dev, &ksd);
		if (ret)
			return (ret);

		/* Grab a copy, to clear the kernel pointers */
		usd = malloc(sizeof(*usd), M_TEMP, M_WAITOK|M_ZERO);
		usd->num = ksd->num;
		strlcpy(usd->xname, ksd->xname, sizeof(usd->xname));
		memcpy(usd->maxnumt, ksd->maxnumt, sizeof(usd->maxnumt));
		usd->sensors_count = ksd->sensors_count;

		ret = sysctl_rdstruct(oldp, oldlenp, newp, usd,
		    sizeof(struct sensordev));

		free(usd, M_TEMP, sizeof(*usd));
		return (ret);
	}

	type = name[1];
	numt = name[2];

	ret = sensor_find(dev, type, numt, &ks);
	if (ret)
		return (ret);

	/* Grab a copy, to clear the kernel pointers */
	us = malloc(sizeof(*us), M_TEMP, M_WAITOK|M_ZERO);
	memcpy(us->desc, ks->desc, sizeof(us->desc));
	us->tv = ks->tv;
	us->value = ks->value;
	us->type = ks->type;
	us->status = ks->status;
	us->numt = ks->numt;
	us->flags = ks->flags;

	ret = sysctl_rdstruct(oldp, oldlenp, newp, us,
	    sizeof(struct sensor));
	free(us, M_TEMP, sizeof(*us));
	return (ret);
}

#endif	/* SMALL_KERNEL */

int
sysctl_cptime2(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	int found = 0;

	if (namelen != 1)
		return (ENOTDIR);

	CPU_INFO_FOREACH(cii, ci) {
		if (name[0] == CPU_INFO_UNIT(ci)) {
			found = 1;
			break;
		}
	}
	if (!found)
		return (ENOENT);

	return (sysctl_rdstruct(oldp, oldlenp, newp,
	    &ci->ci_schedstate.spc_cp_time,
	    sizeof(ci->ci_schedstate.spc_cp_time)));
}
@


1.321
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.320 2016/11/11 18:59:09 mikeb Exp $	*/
d1287 1
a1287 1
			s = splnet();
d1299 1
a1299 1
			splx(s);
@


1.320
log
@Export p_cpuid via sysctl for all processes;  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.319 2016/11/07 00:26:32 guenther Exp $	*/
d1217 1
a1217 2
		strlcpy(kf->p_comm, pr->ps_mainproc->p_comm,
		    sizeof(kf->p_comm));
@


1.319
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.318 2016/10/24 04:38:44 dlg Exp $	*/
d1617 1
a1617 1
		if (isthread && p->p_cpu != NULL)
@


1.318
log
@move the mbstat structure to percpu counters

each cpus counters still have to be protected by splnet, but this
is better thana single set of counters protected by a global mutex.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.317 2016/10/22 04:39:18 guenther Exp $	*/
a1590 1
	ki->p_pid = pr->ps_pid;
d1988 1
a1988 1
	if (pid == cp->p_pid) {
@


1.317
log
@Factor out pr->ps_vmspace into a local variable for fill_kproc()

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.316 2016/10/08 21:31:56 tedu Exp $	*/
d65 1
d394 18
a411 3
	case KERN_MBSTAT:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &mbstat,
		    sizeof(mbstat)));
@


1.316
log
@upon further review, port numbers go all the way up to ushort max
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.315 2016/10/08 21:27:32 tedu Exp $	*/
d1562 1
d1571 1
a1571 1
	    p, pr, s, pr->ps_vmspace, pr->ps_limit, pr->ps_sigacts, isthread,
d1593 2
a1594 2
		if ((pr->ps_flags & PS_EMBRYO) == 0)
			ki->p_vm_rssize = vm_resident_count(pr->ps_vmspace);
@


1.315
log
@initialize the port variable before sysctl, since it's also read out.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.314 2016/10/07 19:04:44 tedu Exp $	*/
d614 1
a614 1
		if (port < 0 || port > SHRT_MAX)
@


1.314
log
@introduce a sysctl to hijack dns sockets. when set to a port number,
all dns socket connections will be redirected to localhost:port.
this could be a sockopt on the listening socket, but sysctl is
an easier interface to work with right now.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.313 2016/10/02 23:11:55 guenther Exp $	*/
d611 1
a611 1
		int port;
@


1.313
log
@Add va_nlink information to struct kinfo_file (so bump the shlib minor)

from Sebastien Marie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.312 2016/09/25 15:23:37 deraadt Exp $	*/
d609 10
@


1.312
log
@Make a move towards ending 4 decades of kernel snooping.

Add sysctl kern.allowkmem (default 0) which controls the ability to open
/dev/mem or /dev/kmem at securelevel > 0.  Over 15 years we converted 99%
of utilities in the tree to operate on sysctl-nodes (either by themselves
or via code hiding in the guts of -lkvm).

pstat -d and -v & procmap are affected and continued use of them will
require kern.allowkmem=1 in /etc/sysctl.conf.  acpidump (and it's
buddy sendbug) are affected, but we'll work out a solution soon.

There will be some impact in ports.

ok kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.311 2016/09/21 14:06:50 deraadt Exp $	*/
d1068 1
@


1.311
log
@sysctl KERN_ARND is no longer used (in ports, it only occurs in fallback
paths of libevent).  This interface was the first generation of what
eventually became getentropy(2) and arc4random(3) -- june 1997!
Ports scan by sthen, general agreement guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.310 2016/09/18 14:32:54 deraadt Exp $	*/
d121 2
d345 6
@


1.310
log
@option INSECURE is obsolete
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.309 2016/09/07 17:30:12 natano Exp $	*/
a412 13
	case KERN_ARND: {
		char buf[512];

		if (*oldlenp > sizeof(buf))
			return (EINVAL);
		if (oldp) {
			arc4random_buf(buf, *oldlenp);
			if ((error = copyout(buf, oldp, *oldlenp)))
				return (error);
			explicit_bzero(buf, sizeof(buf));
		}
		return (0);
	}
@


1.309
log
@Remove usermount remnants. ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.308 2016/09/04 09:22:29 mpi Exp $	*/
a261 3
#ifdef INSECURE
int securelevel = -1;
#else
a262 1
#endif
@


1.308
log
@Introduce Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

Currently only available on amd64 and guarded under DDBPROF.  Support
for other archs will follow soon.

A new sysctl knob, ddb.console, need to be set to 1 in securelevel 0
to be able to use this feature.

Inputs and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.307 2016/08/23 23:28:02 tedu Exp $	*/
a416 4
	case KERN_USERMOUNT: {
		int usermount = 0;
		return (sysctl_rdint(oldp, oldlenp, newp, usermount));
		}
@


1.307
log
@rename nfiles to numfiles to avoid shadowing and stretch out the name.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.306 2016/07/14 15:39:40 deraadt Exp $	*/
d392 1
a392 1
#ifdef GPROF
@


1.306
log
@kern.usermount=1 is unsafe for everyone, since it allows any non-pledged
program to call the mount/umount system calls.  There is no way any user
can be expected to keep their system safe / reliable with this feature.
Ignore setting to =1, and after release we'll delete the sysctl entirely.
ok lots of people
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.305 2016/05/27 19:45:04 deraadt Exp $	*/
d328 1
a328 1
		return (sysctl_rdint(oldp, oldlenp, newp, nfiles));
@


1.305
log
@W^X violations are no longer permitted by default.  A kernel log message
is generated, and mprotect/mmap return ENOTSUP.  If the sysctl(8) flag
kern.wxabort is set then a SIGABRT occurs instead, for gdb use or coredump
creation.

W^X violating programs can be permitted on a ffs/nfs filesystem-basis,
using the "wxallowed" mount option.  One day far in the future
upstream software developers will understand that W^X violations are a
tremendously risky practice and that style of programming will be
banished outright.  Until then, we recommend most users need to use the
wxallowed option on their /usr/local filesystem.  At least your other
filesystems don't permit such programs.

ok jca kettenis mlarkin natano
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.304 2016/05/23 15:59:19 deraadt Exp $	*/
d278 1
a278 1
	extern int usermount, nosuidcoredump;
d417 4
a420 2
	case KERN_USERMOUNT:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &usermount));
@


1.304
log
@remove the sysctl kern.random counters, since none of the remaining
ones are capable of giving valuable works vs does-not-work evidence.
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.303 2016/05/21 14:00:27 jsing Exp $	*/
d281 1
d594 2
@


1.303
log
@Cleanup some of the DUID code and refactor for readability.

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.302 2016/05/04 01:28:42 zhuk Exp $	*/
a417 3
	case KERN_RND:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &rndstats,
		    sizeof(rndstats)));
@


1.302
log
@Make KERN_FILE_BYPID return ESRCH when PID not found, both in sysctl and
offline paths. More polishing to come.

Input and okay bluhm@@ & kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.301 2016/04/25 20:00:33 tedu Exp $	*/
a2051 1
	struct disklabel *dl;
d2054 1
a2054 2
	char duid[17];
	u_int64_t uid = 0;
d2084 3
a2086 10
			dl = dk->dk_label;
			memset(duid, 0, sizeof(duid));
			if (dl && memcmp(dl->d_uid, &uid, sizeof(dl->d_uid))) {
				snprintf(duid, sizeof(duid), 
				    "%02hx%02hx%02hx%02hx"
				    "%02hx%02hx%02hx%02hx",
				    dl->d_uid[0], dl->d_uid[1], dl->d_uid[2],
				    dl->d_uid[3], dl->d_uid[4], dl->d_uid[5],
				    dl->d_uid[6], dl->d_uid[7]);
			}
d2088 2
a2089 1
			    dk->dk_name ? dk->dk_name : "", duid);
@


1.301
log
@boom goes the dynamite
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.300 2016/02/29 19:44:07 naddy Exp $	*/
d1221 1
a1221 1
	int arg, i, error = 0, needed = 0;
d1321 1
d1333 1
d1351 2
@


1.300
log
@delete the kern.emul/KERN_EMUL sysctl bits since there are no
emulations left; ok millert@@ deraadt@@, jmc@@ (man pages)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.299 2015/12/05 20:54:34 kettenis Exp $	*/
a84 1
#include <dev/systrace.h>
a1190 6
		break;
	    }
	case DTYPE_SYSTRACE: {
		struct fsystrace *f = (struct fsystrace *)fp->f_data;

		kf->str_npolicies = f->npolicies;
@


1.299
log
@Make sure we use the same cpu numbering for the kern.cptime2 sysctl as we
do for kern.proc.  Fixes the issue in top(1) where a cpu would seem to be idle
even though a thread was reported to be running on it.

ok mpi@@, tedu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.298 2015/11/01 19:03:33 semarie Exp $	*/
a131 1
int sysctl_emul(int *, u_int, void *, size_t *, void *, size_t);
a299 1
		case KERN_EMUL:
a557 3
	case KERN_EMUL:
		return (sysctl_emul(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
a2327 35
}

int
sysctl_emul(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	int enabled, error;
	struct emul *e;

	if (name[0] == KERN_EMUL_NUM) {
		if (namelen != 1)
			return (ENOTDIR);
		return (sysctl_rdint(oldp, oldlenp, newp, nexecs));
	}

	if (namelen != 2)
		return (ENOTDIR);
	if (name[0] > nexecs || name[0] < 0)
		return (EINVAL);
	e = execsw[name[0] - 1].es_emul;
	if (e == NULL)
		return (EINVAL);

	switch (name[1]) {
	case KERN_EMUL_NAME:
		return (sysctl_rdstring(oldp, oldlenp, newp, e->e_name));
	case KERN_EMUL_ENABLED:
		enabled = (e->e_flags & EMUL_ENABLED);
		error = sysctl_int(oldp, oldlenp, newp, newlen,
		    &enabled);
		e->e_flags = (enabled & EMUL_ENABLED);
		return (error);
	default:
		return (EINVAL);
	}
@


1.298
log
@refactor pledge_*_check and pledge_fail functions

- rename _check function without suffix: a "pledge" function called from
  anywhere is a "check" function.

- makes pledge_fail call the responsability to the _check function. remove it
  from caller.

- make proper use of (potential) returned error of _check() functions.

- adds pledge_kill() and pledge_protexec()

with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.297 2015/10/25 20:39:54 deraadt Exp $	*/
d2378 1
a2378 1
	int i;
a2382 2
	i = name[0];

d2384 2
a2385 1
		if (i-- == 0)
d2387 1
d2389 1
a2389 1
	if (i > 0)
@


1.297
log
@Fold "malloc" into "stdio" and -- recognizing that no program so far has
used less than "stdio" -- include all the "self" operations.  Instead of
different defines, use regular PLEDGE_* in the "p_pledgenote" variable
(which indicates the operation subtype a system call is performing).  Many
checks before easier to understand.  p_pledgenote can often be passed
directly to ktrace, so that kdump says:
 15565 test     CALL  pledge(0xa9a3f804c51,0)
 15565 test     STRU  pledge request="stdio"
 15565 test     RET   pledge 0
 15565 test     CALL  open(0xa9a3f804c57,0x2<O_RDWR>)
 15565 test     NAMI  "/tmp/testfile"
 15565 test     PLDG  open, "wpath", errno 1 Operation not permitted
with help from semarie, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.296 2015/10/09 01:10:27 deraadt Exp $	*/
d177 1
a177 1
	error = pledge_sysctl_check(p, SCARG(uap, namelen),
d180 1
a180 1
		return (pledge_fail(p, error, PLEDGE_STDIO));
@


1.296
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.295 2015/09/28 16:59:35 deraadt Exp $	*/
d177 4
a180 2
	if (pledge_sysctl_check(p, SCARG(uap, namelen), name, SCARG(uap, new)))
		return (pledge_fail(p, EPERM, PLEDGE_SELF));
@


1.295
log
@track sizes for free in sysctl_diskinit(); ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.294 2015/09/13 17:08:03 guenther Exp $	*/
d72 1
a72 1
#include <sys/tame.h>
d177 2
a178 2
	if (tame_sysctl_check(p, SCARG(uap, namelen), name, SCARG(uap, new)))
		return (tame_fail(p, EPERM, TAME_SELF));
@


1.294
log
@Rename __sysctl syscall to just sysctl, as the userland wrapper is no longer
necessary

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.293 2015/09/11 15:29:47 deraadt Exp $	*/
d259 1
d261 1
d2078 1
a2078 1
			free(disknames, M_SYSCTL, 0);
d2080 1
a2080 1
			free(diskstats, M_SYSCTL, 0);
d2085 1
d2087 1
@


1.293
log
@Convert _TM_ flags to TAME_ flags, collapsing the entire mapping
layer because the strings select the right options.  Mechanical
conversion.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.292 2015/09/11 08:22:31 guenther Exp $	*/
d149 1
a149 1
sys___sysctl(struct proc *p, void *v, register_t *retval)
d151 1
a151 1
	struct sys___sysctl_args /* {
@


1.292
log
@Only include <sys/tame.h> in the .c files that need it

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.291 2015/09/10 18:10:35 deraadt Exp $	*/
d178 1
a178 1
		return (tame_fail(p, EPERM, _TM_SELF));
@


1.291
log
@sizes for free(); ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.290 2015/09/03 12:13:13 mpi Exp $	*/
d72 1
@


1.290
log
@Fix !INET6 build.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.289 2015/08/28 04:38:47 guenther Exp $	*/
d2154 1
a2154 1
	size_t infosize, dssize, tsize, buflen;
d2204 2
a2205 1
	buf = malloc(min(tsize, buflen), M_TEMP, M_WAITOK|M_ZERO);
d2256 1
a2256 1
	free(buf, M_TEMP, 0);
@


1.289
log
@Rework the UNIX domain socket garbage collector, including ideas from
{Free,Net}BSD
 - when a socket is closed with fds in its input, defer closing them to
   a task to avoid recursing.  This eliminates the complicated extra
   reference taking which had a 37 line(!) comment explanation
 - move flags, counts, and links only needed for this from struct file to
   struct unpcb
 - document the flow of the mark/sweep collector

much help from claudio@@ who made me explain the GC to him until we trusted it
ok claudio@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.288 2015/08/22 20:18:49 deraadt Exp $	*/
d1272 4
a1275 1
			extern struct inpcbtable rawcbtable, rawin6pcbtable;
@


1.288
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.287 2015/08/03 14:20:39 bluhm Exp $	*/
a1023 1
		kf->f_msgcount = fp->f_msgcount;
d1156 1
@


1.287
log
@Unfortunately netstat did not show sockets without file descriptors
since it had been converted from kvm to sysctl.  This was hiding a
bunch of TCP states which are important for network debugging.
Loop over the internet PCB tables to fill the network information
into the KERN_FILE_BYFILE sysctl result.  Skip internet sockets
when looping over the file desciptors.
From markus@@; OK guenther@@; Go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.286 2015/07/19 02:35:35 deraadt Exp $	*/
a72 1
#include <sys/tame.h>
@


1.286
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.285 2015/05/18 19:10:35 bluhm Exp $	*/
d90 1
d96 2
d135 2
a136 2
void fill_file(struct kinfo_file *, struct file *, struct filedesc *,
    int, struct vnode *, struct process *, struct proc *, int);
d1010 1
a1010 1
	  int show_pointers)
d1051 3
d1086 2
a1087 1
		struct socket *so = (struct socket *)fp->f_data;
d1252 11
a1262 11
#define FILLIT(fp, fdp, i, vp, pr) do {				\
	if (buflen >= elem_size && elem_count > 0) {		\
		fill_file(kf, fp, fdp, i, vp, pr, p, show_pointers);	\
		error = copyout(kf, dp, outsize);		\
		if (error)					\
			break;					\
		dp += elem_size;				\
		buflen -= elem_size;				\
		elem_count--;					\
	}							\
	needed += elem_size;					\
d1264 4
d1271 20
d1292 1
a1292 1
                /* don't FREF when f_count == 0 to avoid race in fdrop() */
d1300 11
a1310 2
			    (arg == 0 || fp->f_type == arg))
				FILLIT(fp, NULL, 0, NULL, NULL);
@


1.285
log
@For each file in sysctl(KERN_FILE_BYFILE), FILLIT() calls fill_file(),
which calls VOP_GETATTR().  For NFS, that leads to nfs_getattr().
If the node's attributes are not in NFS's cache, nfs_getattr() will
invoke nfs_request() and the latter will sleep, allowing the file
pointer to disappear while we traverse the list.
This results in kernel crashes while running netstat or pstat -f.
Grab a reference to the file descriptor before calling FILLIT(),
and release it afterwards.  This way the file descriptor cannot
disappear while we sleep in nfs_getattr().
Analysis and fix from Pedro Martelletto; input and OK guenther@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.284 2015/03/28 23:50:55 bluhm Exp $	*/
d73 1
d173 3
@


1.284
log
@Replace the hand-crafted list of datagram unix domain sockets with
a SLIST.
OK mpi@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.283 2015/02/11 05:09:33 claudio Exp $	*/
d1214 1
a1214 1
	struct file *fp;
d1256 19
a1274 7
		LIST_FOREACH(fp, &filehead, f_list) {
			if (fp->f_count == 0)
				continue;
			if (arg != 0 && fp->f_type != arg)
				continue;
			FILLIT(fp, NULL, 0, NULL, NULL);
		}
@


1.283
log
@Extend struct kinfo_file a bit so that netstat has all the info it needs.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.282 2015/02/11 04:00:05 guenther Exp $	*/
d1149 4
a1152 2
				kf->unp_refs	= PTRTOINT64(unpcb->unp_refs);
				kf->unp_nextref	= PTRTOINT64(unpcb->unp_nextref);
@


1.282
log
@Prefer arg != 0 over arg for non-boolean.  nitted kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.281 2015/02/11 03:03:08 guenther Exp $	*/
d91 3
d1108 9
d1134 8
@


1.281
log
@sysctl({CTL_KERN, KERN_FILE, KERN_FILE_BYFILE}) previously required
the extra argument to be zero; instead, make it filter on the file
type (DTYPE_*) when non-zero to make claudio's netstat work easier.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.280 2015/02/09 11:52:47 miod Exp $	*/
d1237 1
a1237 1
			if (arg && fp->f_type != arg)
@


1.280
log
@Change the way stackgap_random is applied. Instead of applying it within the
fixed stack area of the exec'd image, and risking hitting process limits,
should we want to increase stackgap_random, the randomness is applied to the
stack region in the process' vmspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.279 2015/01/20 19:43:21 kettenis Exp $	*/
a1233 5
		if (arg != 0) {
			/* no arg in file mode */
			error = EINVAL;
			break;
		}
d1236 2
@


1.279
log
@Move ps_strings "after" the random stackgap.  This makes its location a
per-process value, and therefpore turns the VM_PSSTRINGS sysctl into a
per-process one as well.  This gets rid of a pointer to the bottom of the
stack at a fixed location.  Also clears the road for unmapping the stackgap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.278 2015/01/13 10:07:58 mpf Exp $	*/
a266 1
	extern int stackgap_random;
@


1.278
log
@Add dmesg -s support, to view the output of rc(8) system startup messages.
Help and feedback by Theo and Miod.
OK deraadt@@, manpage-ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.277 2014/12/12 07:45:46 tedu Exp $	*/
d1569 1
d1614 1
d1624 2
a1625 2
	uio.uio_iovcnt = 1;	
	uio.uio_offset = (off_t)(vaddr_t)PS_STRINGS;
@


1.277
log
@sysctl kern.global_ptrace.
controls whether you can ptrace any process with appropriate privileges
or only one own's children.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.276 2014/12/12 03:04:11 uebayasi Exp $	*/
d447 3
d454 1
a454 1
		if (!msgbufp || msgbufp->msg_magic != MSG_MAGIC)
d456 9
a464 2
		return (sysctl_rdint(oldp, oldlenp, newp, msgbufp->msg_bufs));
	case KERN_MSGBUF:
d466 1
a466 1
		if (!msgbufp || msgbufp->msg_magic != MSG_MAGIC)
d468 3
a470 2
		return (sysctl_rdstruct(oldp, oldlenp, newp, msgbufp,
		    msgbufp->msg_bufs + offsetof(struct msgbuf, msg_bufc)));
@


1.276
log
@sysctl_proc_vmmap(): Allow retrieving "self" VM mapping without privilege.

Previous version OK'ed by tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d595 7
@


1.275
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.274 2014/12/05 04:35:08 uebayasi Exp $	*/
d1879 4
a1882 6
	if (pid > 0) {
#if 1
		/* XXX Allow only root for now */
		if ((error = suser(cp, 0)) != 0)
			return (error);
#endif
d1890 5
d1899 1
@


1.274
log
@Allow only root to use KERN_PROC_VMMAP until it is really proven safe.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2134 1
a2134 1
					bcopy(sema[i], &semsi->semids[i],
d2143 1
a2143 1
					bcopy(shmsegs[i], &shmsi->shmids[i],
@


1.273
log
@Introduce a new sysctl to retrieve VM map entries

This adds a new sysctl KERN_PROC_VMMAP, which returns an array of VM map
entries of a specified process.  This prevents debuggers from iterating
vm_map_entry RB tree via kvm(3).

The name KERN_PROC_VMMAP and struct kinfo_vmentry are chosen from the same
function in FreeBSD.  struct kinfo_vmentry is revised to reduce size, because
OpenBSD does not keep track of filepaths.  The semantic is also changed to
return max buffer size as a hint, and start iteration at the specified base
address.

Much valuable input from deraadt@@, guenther@@, tedu@@

OK tedu@@ deraadt@@
@
text
@d1880 5
@


1.272
log
@missed a file when removing KERN_VNODE.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.271 2014/11/19 18:04:54 tedu Exp $	*/
d80 2
d122 1
d282 1
d372 3
d1845 93
@


1.271
log
@delete the KERN_VNODE sysctl. it fails to provide any isolation from the
kernel struct vnode defintion, and the only consumer (pstat) still needs
kvm to read much of the required information. no great loss to always use
kvm until there's a better replacement interface.
ok deraadt millert uebayasi
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.270 2014/11/16 12:31:00 deraadt Exp $	*/
a169 2
		if (name[1] == KERN_VNODE)	/* XXX */
			dolock = 0;
@


1.270
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.269 2014/11/03 17:20:46 bluhm Exp $	*/
a357 2
	case KERN_VNODE:
		return (sysctl_vnode(oldp, oldlenp, p));
@


1.269
log
@Put the socket splicing fields into a seperate struct sosplice that
gets only allocated when needed.  This way struct socket shrinks
from 472 to 392 bytes on amd64.  When splicing gets active, another
88 bytes are allocated for struct sosplice.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.268 2014/11/01 23:58:28 tedu Exp $	*/
d217 1
a217 1
			    VM_PROT_READ|VM_PROT_WRITE);
@


1.268
log
@add a few sizes to free
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.267 2014/10/17 01:51:39 tedu Exp $	*/
d1065 1
a1065 1
		if (so->so_splice) {
d1067 4
a1070 3
				kf->so_splice = PTRTOINT64(so->so_splice);
			kf->so_splicelen = so->so_splicelen;
		} else if (so->so_spliceback)
@


1.267
log
@redo the performance throttling in the kernel.
introduce a new sysctl, hw.perfpolicy, that governs the policy.
when set to anything other than manual, hw.setperf then becomes read only.
phessler was heading in this direction, but this is slightly different. :)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.266 2014/10/11 17:12:30 deraadt Exp $	*/
d1291 1
a1291 1
	free(kf, M_TEMP, 0);
d1454 1
a1454 1
		free(kproc, M_TEMP, 0);
d1735 1
a1735 1
	free(buf, M_TEMP, 0);
d1799 1
a1799 1
	free(path, M_TEMP, 0);
d2098 1
a2098 1
		free(usd, M_TEMP, 0);
d2121 1
a2121 1
	free(us, M_TEMP, 0);
@


1.266
log
@back out; does not even compile
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.264 2014/09/15 19:08:21 miod Exp $	*/
a129 2
void (*cpu_setperf)(int);
int perflevel = 100;
a649 5
#ifndef	SMALL_KERNEL
	case HW_SENSORS:
		return (sysctl_sensors(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
d657 4
d662 4
a665 12
		if (!cpu_setperf)
			return (EOPNOTSUPP);
		err = sysctl_int(oldp, oldlenp, newp, newlen, &perflevel);
		if (err)
			return err;
		if (perflevel > 100)
			perflevel = 100;
		if (perflevel < 0)
			perflevel = 0;
		if (newp)
			cpu_setperf(perflevel);
		return (0);
@


1.265
log
@resurrect a many year old diff. move CPU throttling into the kernel,
enabled by setting hw.setperf=-1. some other bugs preventing this from
going in before have been fixed. my thanks to phessler for keeping the
diff alive in the mean time. tested by several to not regress.
@
text
@a131 4
#ifndef SMALL_KERNEL
struct timeout setperf_to;
void auto_setperf(void *);
#endif
a256 59
#ifndef SMALL_KERNEL
void
auto_setperf(void *v)
{
	static uint64_t *idleticks, *totalticks;

	int i, j;
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;

	int speedup;
	uint64_t idle, total, allidle, alltotal;

	if (!auto_perfctl)
		return;
	if (!idleticks)
		if (!(idleticks = malloc(sizeof(*idleticks) * ncpusfound,
		    M_DEVBUF, M_NOWAIT | M_ZERO)))
			return;
	if (!totalticks)
		if (!(totalticks = malloc(sizeof(*totalticks) * ncpusfound,
		    M_DEVBUF, M_NOWAIT | M_ZERO))) {
			free(idleticks, M_DEVBUF, 0);
			return;
		}
	alltotal = allidle = 0;
	j = 0;
	speedup = 0;
	CPU_INFO_FOREACH(cii, ci) {
		total = 0;
		for (i = 0; i < CPUSTATES; i++) {
			total += ci->ci_schedstate.spc_cp_time[i];
		}
		total -= totalticks[j];
		idle = ci->ci_schedstate.spc_cp_time[CP_IDLE] - idleticks[j];
		if (idle < total / 3)
			speedup = 1;
		alltotal += total;
		allidle += idle;
		idleticks[j] += idle;
		totalticks[j] += total;

		j++;
	}
	if (allidle < alltotal / 2)
		speedup = 1;

	if (speedup && perflevel != 100) {
		perflevel = 100;
		cpu_setperf(perflevel);
	} else if (!speedup && perflevel != 0) {
		perflevel = 0;
		cpu_setperf(perflevel);
	}
	
	timeout_add_msec(&setperf_to, 100);
}
#endif /* !SMALL_KERNEL */

d611 1
a611 1
	int err, cpuspeed, newperf;
d667 1
a667 2
		newperf = perflevel;
		err = sysctl_int(oldp, oldlenp, newp, newlen, &newperf);
d670 6
a675 16
#ifndef SMALL_KERNEL
		if (newp) {
			if (newperf == -1) {
				auto_perfctl = 1;
				timeout_add_msec(&setperf_to, 200);
			} else {
				auto_perfctl = 0;
				if (newperf > 100)
					newperf = 100;
				if (newperf < 0)
					newperf = 0;
				perflevel = newperf;
				cpu_setperf(newperf);
			}
		}
#endif /* !SMALL_KERNEL */
@


1.264
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.263 2014/09/04 19:14:47 miod Exp $	*/
d132 4
d261 59
d674 1
a674 1
	int err, cpuspeed;
d730 2
a731 1
		err = sysctl_int(oldp, oldlenp, newp, newlen, &perflevel);
d734 16
a749 6
		if (perflevel > 100)
			perflevel = 100;
		if (perflevel < 0)
			perflevel = 0;
		if (newp)
			cpu_setperf(perflevel);
@


1.263
log
@Remove global cp_time[] array; no longer used now that all arches implement
cpu_info.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.262 2014/08/20 06:23:03 mikeb Exp $	*/
a60 1
#include <sys/dkstat.h>
d76 1
a76 1

@


1.262
log
@Bye bye /dev/crypto

The interface has been disabled by default for about 4 years and
currently there's not much value in having it around at all.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.261 2014/08/18 05:11:03 dlg Exp $	*/
a268 1
	extern long cp_time[CPUSTATES];
d467 1
@


1.261
log
@dont rely on mbuf.h to provide pool.h.

ok miod@@, who has offerred to help with any MD fallout
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.260 2014/07/22 11:06:09 mpi Exp $	*/
a270 5
#ifdef CRYPTO
	extern int usercrypto;
	extern int userasymcrypto;
	extern int cryptodevallowsoft;
#endif
a515 10
#endif
#ifdef CRYPTO
	case KERN_USERCRYPTO:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &usercrypto));
	case KERN_USERASYMCRYPTO:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &userasymcrypto));
	case KERN_CRYPTODEVALLOWSOFT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &cryptodevallowsoft));
@


1.260
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.259 2014/07/17 13:44:21 tedu Exp $	*/
d46 1
@


1.259
log
@zero random buf for sysctl too, just in case
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.258 2014/07/13 16:41:21 claudio Exp $	*/
a85 1
#include <netinet/in_systm.h>
@


1.258
log
@Introduce PS_NOBROADCASTKILL a process flag that excludes processes from
receiving broadcast signals (kill -1). The flag can be set via a new
sysctl KERN_PROC_NOBROADCASTKILL. This will be used by iscsid to survive
the mass killing by init(8) when terminating multi-user operations.
With and OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.257 2014/07/13 15:29:04 tedu Exp $	*/
d426 1
@


1.257
log
@use mallocarray where arguments are multipled. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.256 2014/07/12 18:43:32 tedu Exp $	*/
d119 2
d289 1
d378 3
d1826 41
@


1.256
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.255 2014/07/08 17:19:25 deraadt Exp $	*/
d1857 1
a1857 1
		diskstats = malloc(disk_count * sizeof(struct diskstats),
@


1.255
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.254 2014/07/08 07:10:12 dlg Exp $	*/
d1311 1
a1311 1
	free(kf, M_TEMP);
d1474 1
a1474 1
		free(kproc, M_TEMP);
d1755 1
a1755 1
	free(buf, M_TEMP);
d1819 1
a1819 1
	free(path, M_TEMP);
d1852 1
a1852 1
			free(disknames, M_SYSCTL);
d1854 1
a1854 1
			free(diskstats, M_SYSCTL);
d2032 1
a2032 1
	free(buf, M_TEMP);
d2077 1
a2077 1
		free(usd, M_TEMP);
d2100 1
a2100 1
	free(us, M_TEMP);
@


1.254
log
@pull the rx ring accounting out of the mbuf layer now that its all done
via if_rxring things. this effectively deprecates the third argument
for MCLGETI and m_clget and makes the mbuf layer no longer care about
interfaces and simplifies the allocation paths.

the timeout used to measure livelock has been moved to net/if.c.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.253 2014/07/04 05:58:31 guenther Exp $	*/
a57 1
#include <uvm/uvm_extern.h>
@


1.253
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.252 2014/06/14 22:00:28 deraadt Exp $	*/
d113 1
a113 1
extern u_int mcllivelocks;
d594 1
a594 1
		return (sysctl_rdint(oldp, oldlenp, newp, mcllivelocks));
@


1.252
log
@Rather than truncating KERN_ARND requests silently, return EINVAL
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.251 2014/06/14 21:59:38 deraadt Exp $	*/
d126 2
a127 2
    int, struct vnode *, struct proc *, struct proc *, int);
void fill_kproc(struct proc *, struct kinfo_proc *, int, int);
d1000 1
a1000 1
	  int fd, struct vnode *vp, struct proc *pp, struct proc *p,
d1171 7
a1177 6
	if (pp != NULL) {
		kf->p_pid = pp->p_p->ps_pid;
		kf->p_uid = pp->p_ucred->cr_uid;
		kf->p_gid = pp->p_ucred->cr_gid;
		kf->p_tid = pp->p_pid + THREAD_PID_OFFSET;
		strlcpy(kf->p_comm, pp->p_comm, sizeof(kf->p_comm));
a1192 1
	struct proc *pp;
d1219 1
a1219 1
#define FILLIT(fp, fdp, i, vp, pp) do {				\
d1221 1
a1221 1
		fill_file(kf, fp, fdp, i, vp, pp, p, show_pointers);	\
d1256 1
a1256 3
			pp = pr->ps_mainproc;
			if ((pr->ps_flags & (PS_SYSTEM | PS_EXITING))
			    || pp->p_stat == SIDL || pp->p_stat == SZOMB)
d1264 1
a1264 1
				FILLIT(NULL, NULL, KERN_FILE_TEXT, pr->ps_textvp, pp);
d1266 1
a1266 1
				FILLIT(NULL, NULL, KERN_FILE_CDIR, fdp->fd_cdir, pp);
d1268 1
a1268 1
				FILLIT(NULL, NULL, KERN_FILE_RDIR, fdp->fd_rdir, pp);
d1270 1
a1270 1
				FILLIT(NULL, NULL, KERN_FILE_TRACE, pr->ps_tracevp, pp);
d1276 1
a1276 1
				FILLIT(fp, fdp, i, NULL, pp);
a1281 1
			pp = pr->ps_mainproc;
d1286 1
a1286 2
			if ((pr->ps_flags & (PS_SYSTEM | PS_EXITING))
			    || pp->p_stat == SIDL || pp->p_stat == SZOMB)
d1294 1
a1294 1
				FILLIT(NULL, NULL, KERN_FILE_CDIR, fdp->fd_cdir, pp);
d1296 1
a1296 1
				FILLIT(NULL, NULL, KERN_FILE_RDIR, fdp->fd_rdir, pp);
d1298 1
a1298 1
				FILLIT(NULL, NULL, KERN_FILE_TRACE, pr->ps_tracevp, pp);
d1304 1
a1304 1
				FILLIT(fp, fdp, i, NULL, pp);
d1334 1
a1334 1
	struct proc *p, *pp;
a1369 2
		p = pr->ps_mainproc;

d1373 1
a1373 1
		if (p->p_stat == SIDL)
d1431 1
a1431 10
			fill_kproc(p, kproc, 0, show_pointers);
			/* Update %cpu for all threads */
			if (!dothreads) {
				TAILQ_FOREACH(pp, &pr->ps_threads,
				    p_thr_link) {
					if (pp == p)
						continue;
					kproc->p_pctcpu += pp->p_pctcpu;
				}
			}
d1447 1
a1447 1
				fill_kproc(p, kproc, 1, show_pointers);
d1483 1
a1483 1
fill_kproc(struct proc *p, struct kinfo_proc *ki, int isthread,
a1485 1
	struct process *pr = p->p_p;
d1489 5
d1517 2
a1518 2
	if (!P_ZOMBIE(p)) {
		if (p->p_stat != SIDL)
d1520 1
a1520 2

		calctsru(&p->p_tu, &ut, &st, NULL);
d1527 1
a1527 1
		if (p->p_cpu != NULL)
d1530 21
@


1.251
log
@temporarily (maybe 3 weeks?) crank KERN_ARND maximum buffer from 256
to 512, to make it easier for people to build to -current.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.250 2014/06/11 17:32:59 matthew Exp $	*/
d416 1
a416 1
			*oldlenp = sizeof(buf);
@


1.250
log
@Add bounds checks for CTL_DEBUG sysctl variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.249 2014/05/17 17:26:24 guenther Exp $	*/
d413 1
a413 1
		char buf[256];
@


1.249
log
@When looking at another process, use the data from struct process
instead of peeking into the thread level

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.248 2014/05/04 05:03:26 guenther Exp $	*/
d756 2
@


1.248
log
@Add PS_SYSTEM, the process-level mirror of the thread-level P_SYSTEM,
and FORK_SYSTEM as a flag to set them.  This eliminates needing to
peek into other processes threads in various places.  Inspired by NetBSD

ok miod@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.247 2014/05/03 23:30:04 guenther Exp $	*/
d337 1
a337 1
		    level < securelevel && p->p_pid != 1)
d1258 1
a1258 1
			if (arg > 0 && pp->p_pid != (pid_t)arg) {
d1262 1
a1262 1
			fdp = pp->p_fd;
d1290 1
a1290 1
			if (arg >= 0 && pp->p_ucred->cr_uid != (uid_t)arg) {
d1294 1
a1294 1
			fdp = pp->p_fd;
d1387 1
a1387 1
			if (p->p_pid != (pid_t)arg)
d1505 1
a1505 1
	    p, pr, s, p->p_vmspace, pr->ps_limit, pr->ps_sigacts, isthread,
d1528 1
a1528 1
			ki->p_vm_rssize = vm_resident_count(p->p_vmspace);
d1547 1
a1547 1
	struct proc *vp;
d1576 1
a1576 1
	if ((vp = pfind(pid)) == NULL)
d1588 1
a1588 1
	if (vp->p_p->ps_flags & (PS_SYSTEM | PS_EXITING))
d1592 1
a1592 1
	if ((vp->p_p->ps_flags & PS_INEXEC))
d1597 1
a1597 1
	    (vp->p_ucred->cr_uid != cp->p_ucred->cr_uid &&
d1601 1
a1601 1
	vm = vp->p_vmspace;
d1603 1
a1603 1
	vp = NULL;
d1753 1
a1753 1
	struct proc *findp;
d1766 1
a1766 1
	if ((findp = pfind(pid)) == NULL)
d1775 1
a1775 1
	if (findp->p_p->ps_flags & (PS_SYSTEM | PS_EXITING))
d1779 1
a1779 1
	if (findp->p_p->ps_ucred->cr_uid != cp->p_ucred->cr_uid &&
d1791 1
a1791 1
	vp = findp->p_fd->fd_cdir;
@


1.247
log
@If P_ZOMBIE(pr->ps_mainproc) is true, then (pr->ps_flags & PS_EXITING)
is, so eliminate the check of the former and instead use the EINVAL
error for the latter.  Also, consistently check for PS_EXITING
before check creds.

suggestion to split this from another diff miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.246 2014/03/30 21:54:48 guenther Exp $	*/
d1255 1
a1255 1
			if ((pp->p_flag & P_SYSTEM) || (pr->ps_flags & PS_EXITING)
d1287 1
a1287 1
			if ((pp->p_flag & P_SYSTEM) || (pr->ps_flags & PS_EXITING)
d1421 1
a1421 1
			if (p->p_flag & P_SYSTEM)
d1587 2
a1588 5
	if (vp->p_flag & P_SYSTEM)
		return (EINVAL);

	/* Exiting - don't bother, it will be gone soon anyway */
	if (vp->p_p->ps_flags & PS_EXITING)
d1774 2
a1775 5
	if (findp->p_flag & P_SYSTEM)
		return (EINVAL);

	/* Exiting - don't bother, it will be gone soon anyway */
	if (findp->p_p->ps_flags & PS_EXITING)
d1779 1
a1779 1
	if (findp->p_ucred->cr_uid != cp->p_ucred->cr_uid &&
@


1.246
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.245 2014/03/22 06:05:45 guenther Exp $	*/
d1587 1
a1587 1
	if (P_ZOMBIE(vp) || (vp->p_flag & P_SYSTEM))
d1592 1
a1592 1
		return (ESRCH);
d1777 5
a1781 1
	if (P_ZOMBIE(findp) || (findp->p_flag & P_SYSTEM))
a1787 4

	/* Exiting - don't bother, it will be gone soon anyway */
	if (findp->p_p->ps_flags & PS_EXITING)
		return (ESRCH);
@


1.245
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.244 2014/01/21 01:48:44 tedu Exp $	*/
d1411 1
a1411 1
			if (p->p_ucred->cr_uid != (uid_t)arg)
d1416 1
a1416 1
			if (p->p_cred->p_ruid != (uid_t)arg)
d1504 1
a1504 1
	FILL_KPROC(ki, strlcpy, p, pr, p->p_cred, p->p_ucred, pr->ps_pgrp,
@


1.244
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.243 2014/01/20 21:19:28 guenther Exp $	*/
d1505 1
a1505 1
	    p, pr, s, p->p_vmspace, pr->ps_limit, p->p_sigacts, isthread,
@


1.243
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.242 2014/01/20 03:23:42 guenther Exp $	*/
d469 1
a469 1
		bzero(cp_time, sizeof(cp_time));
d1861 2
a1862 2
			bzero(duid, sizeof(duid));
			if (dl && bcmp(dl->d_uid, &uid, sizeof(dl->d_uid))) {
d2010 1
a2010 1
					bzero(&semsi->semids[i], dssize);
d2019 1
a2019 1
					bzero(&shmsi->shmids[i], dssize);
@


1.242
log
@Move p_textvp from struct proc to struct process so that the exit code
can be further simplified.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.241 2013/10/22 16:40:26 guenther Exp $	*/
d1191 1
d1249 1
a1249 1
		LIST_FOREACH(pp, &allproc, p_list) {
d1252 1
a1252 1
			 * processes, as well as threads
d1254 2
a1255 2
			if ((pp->p_flag & P_SYSTEM) || (pp->p_flag & P_THREAD)
			    || (pp->p_p->ps_flags & PS_EXITING)
d1263 2
a1264 2
			if (pp->p_p->ps_textvp)
				FILLIT(NULL, NULL, KERN_FILE_TEXT, pp->p_p->ps_textvp, pp);
d1269 2
a1270 2
			if (pp->p_p->ps_tracevp)
				FILLIT(NULL, NULL, KERN_FILE_TRACE, pp->p_p->ps_tracevp, pp);
d1281 2
a1282 1
		LIST_FOREACH(pp, &allproc, p_list) {
d1285 1
a1285 1
			 * processes, as well as threads
d1287 1
a1287 2
			if ((pp->p_flag & P_SYSTEM) || (pp->p_flag & P_THREAD)
			    || (pp->p_p->ps_flags & PS_EXITING)
d1299 2
a1300 2
			if (pp->p_p->ps_tracevp)
				FILLIT(NULL, NULL, KERN_FILE_TRACE, pp->p_p->ps_tracevp, pp);
d1364 1
a1364 1
	p = LIST_FIRST(&allproc);
d1367 7
a1373 1
	for (; p != 0; p = LIST_NEXT(p, p_list)) {
a1379 5
		/* XXX skip processes in the middle of being zapped */
		pr = p->p_p;
		if (pr->ps_pgrp == NULL)
			continue;

d1434 25
a1458 1
		if ((p->p_flag & P_THREAD) == 0) {
d1460 1
a1460 10
				fill_kproc(p, kproc, 0, show_pointers);
				/* Update %cpu for all threads */
				if (!dothreads) {
					TAILQ_FOREACH(pp, &pr->ps_threads,
					    p_thr_link) {
						if (pp == p)
							continue;
						kproc->p_pctcpu += pp->p_pctcpu;
					}
				}
a1469 14
		/* Skip the second entry if not required by op */
		if (!dothreads)
			continue;

		if (buflen >= elem_size && elem_count > 0) {
			fill_kproc(p, kproc, 1, show_pointers);
			error = copyout(kproc, dp, elem_size);
			if (error)
				goto err;
			dp += elem_size;
			buflen -= elem_size;
			elem_count--;
		}
		needed += elem_size;
d1472 1
a1472 1
		p = LIST_FIRST(&zombproc);
@


1.241
log
@- add UNIX-domain socket info to struct kinfo_file2
- convert netstat from kvm_getfiles() to kvm_getfile2() using that
- delete kvm_getfiles() and KERN_FILE as no longer used (bump libkvm's major)
- rename kvm_getfile2() to kvm_getfiles(), kinfo_file2 to kinfo_file
  and KERN_FILE2 to KERN_FILE.

ok deraadt@@, millert@@
ports scan sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.240 2013/07/09 15:37:43 beck Exp $	*/
d1262 2
a1263 2
			if (pp->p_textvp)
				FILLIT(NULL, NULL, KERN_FILE_TEXT, pp->p_textvp, pp);
@


1.240
log
@back out the cache flipper temporarily to work out of tree.
will come back soon.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.236 2013/06/09 13:10:19 miod Exp $	*/
d75 1
d125 1
a125 1
void fill_file2(struct kinfo_file2 *, struct file *, struct filedesc *,
d297 1
a297 1
		case KERN_FILE2:
d376 2
a377 2
	case KERN_FILE2:
		return (sysctl_file2(name + 1, namelen - 1, oldp, oldlenp, p));
a378 2
	case KERN_FILE:
		return (sysctl_file(oldp, oldlenp, p));
a994 63
/*
 * Get file structures.
 */
int
sysctl_file(char *where, size_t *sizep, struct proc *p)
{
	int buflen, error;
	struct file *fp, cfile;
	char *start = where;
	struct ucred *cred = p->p_ucred;

	buflen = *sizep;
	if (where == NULL) {
		/*
		 * overestimate by KERN_FILESLOP files
		 */
		*sizep = sizeof(filehead) +
		    (nfiles + KERN_FILESLOP) * sizeof(struct file);
		return (0);
	}

	/*
	 * first copyout filehead
	 */
	if (buflen < sizeof(filehead)) {
		*sizep = 0;
		return (0);
	}
	error = copyout((caddr_t)&filehead, where, sizeof(filehead));
	if (error)
		return (error);
	buflen -= sizeof(filehead);
	where += sizeof(filehead);

	/*
	 * followed by an array of file structures
	 */
	LIST_FOREACH(fp, &filehead, f_list) {
		if (buflen < sizeof(struct file)) {
			*sizep = where - start;
			return (ENOMEM);
		}

		/* Only let the superuser or the owner see some information */
		bcopy(fp, &cfile, sizeof (struct file));
		if (suser(p, 0) != 0 && cred->cr_uid != fp->f_cred->cr_uid) {
			cfile.f_offset = (off_t)-1;
			cfile.f_rxfer = 0;
			cfile.f_wxfer = 0;
			cfile.f_seek = 0;
			cfile.f_rbytes = 0;
			cfile.f_wbytes = 0;
		}
		error = copyout(&cfile, where, sizeof (struct file));
		if (error)
			return (error);
		buflen -= sizeof(struct file);
		where += sizeof(struct file);
	}
	*sizep = where - start;
	return (0);
}

d997 1
a997 1
fill_file2(struct kinfo_file2 *kf, struct file *fp, struct filedesc *fdp,
d1078 2
d1082 2
d1125 13
a1137 2
			if (show_pointers)
				kf->unp_conn = PTRTOINT64(unpcb->unp_conn);
d1184 1
a1184 1
sysctl_file2(int *name, u_int namelen, char *where, size_t *sizep,
d1187 1
a1187 1
	struct kinfo_file2 *kf;
d1218 1
a1218 1
		fill_file2(kf, fp, fdp, i, vp, pp, p, show_pointers);	\
@


1.239
log
@beck would prefer to keep things just as they were for a while longer.
undo style changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.238 2013/06/11 21:51:55 tedu Exp $	*/
a112 1
extern psize_t b_dmapages_total, b_highpages_total, b_dmamaxpages;
d569 2
a570 2
		psize_t pgs;
		int opct;
d580 1
d582 1
a582 4
			pgs = (b_highpages_total + b_dmapages_total)
			    * bufcachepercent / 100;
			b_dmamaxpages = b_dmapages_total * bufcachepercent
			    / 100;
@


1.238
log
@sprinkle knf fairy dust over new buf code
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.237 2013/06/11 19:01:20 beck Exp $	*/
d582 4
a585 4
			pgs = (b_highpages_total + b_dmapages_total) *
			    bufcachepercent / 100;
			b_dmamaxpages = b_dmapages_total * bufcachepercent /
			    100;
@


1.237
log
@High memory page flipping for the buffer cache.

This change splits the buffer cache free lists into lists of dma reachable
buffers and high memory buffers based on the ranges returned by pmemrange.
Buffers move from dma to high memory as they age, but are flipped to dma
reachable memory if IO is needed to/from and high mem buffer. The total
amount of buffers  allocated is now bufcachepercent of both the dma and
the high memory region.

This change allows the use of large buffer caches on amd64 using more than
4 GB of memory

ok tedu@@ krw@@ - testing by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.236 2013/06/09 13:10:19 miod Exp $	*/
d582 4
a585 4
			pgs = (b_highpages_total + b_dmapages_total)
			    * bufcachepercent / 100;
			b_dmamaxpages = b_dmapages_total * bufcachepercent
			    / 100;
@


1.236
log
@Constify the mib argument of sysctl().
ok matthew@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.235 2013/06/03 16:55:22 guenther Exp $	*/
d113 1
d570 2
a571 2
		u_int64_t dmapages;
		int opct, pgs;
a580 1
		dmapages = uvm_pagecount(&dma_constraint);
d582 4
a585 1
			pgs = bufcachepercent * dmapages / 100;
@


1.235
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.234 2013/04/06 03:44:34 tedu Exp $	*/
d143 1
a143 1
		syscallarg(int *) name;
@


1.234
log
@rthreads are always enabled. remove the sysctl.
ok deraadt guenther kettenis matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.233 2013/03/23 21:22:20 tedu Exp $	*/
d359 5
a363 3
	case KERN_BOOTTIME:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &boottime,
		    sizeof(struct timeval)));
d1548 1
a1548 1
	struct timeval ut, st;
d1576 1
a1576 1
		calcru(&p->p_tu, &ut, &st, NULL);
d1578 1
a1578 1
		ki->p_uutime_usec = ut.tv_usec;
d1580 1
a1580 1
		ki->p_ustime_usec = st.tv_usec;
@


1.233
log
@pull the suser check for sysctl pointers up higher, out of the loops.
hide a few more pointery things.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.232 2013/03/20 03:43:08 deraadt Exp $	*/
a131 2
int rthreads_enabled = 1;

a565 3
	case KERN_RTHREADS:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &rthreads_enabled));
@


1.232
log
@When non-root asks sysctl for kinfo proc or file requests, do not fill in
any kernel addresses information.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.231 2013/02/11 11:11:42 mpi Exp $	*/
d124 4
d1065 2
a1066 1
	  int fd, struct vnode *vp, struct proc *pp, struct proc *p)
a1068 1
	int show_pointers = suser(curproc, 0) == 0;
d1247 1
d1264 2
d1270 1
a1270 1
		fill_file2(kf, fp, fdp, i, vp, pp, p);		\
d1393 1
d1410 2
d1486 1
a1486 1
				fill_kproc(p, kproc, 0);
d1510 1
a1510 1
			fill_kproc(p, kproc, 1);
d1545 2
a1546 1
fill_kproc(struct proc *p, struct kinfo_proc *ki, int isthread)
a1551 1
	int show_pointers = suser(curproc, 0) == 0;
@


1.231
log
@When information about threads are not requested sum the '%cpu' of
all threads in a process instead of returning only the '%cpu' for
the main thread.

This makes top(1) display the correct percentage of CPU usage for
threaded processes when theads are not displayed.

ok sthen@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.230 2013/01/15 23:30:39 jcs Exp $	*/
d1064 1
d1071 2
a1072 1
		kf->f_fileaddr = PTRTOINT64(fp);
d1078 2
a1079 1
		kf->f_ucred = PTRTOINT64(fp->f_cred);
d1082 4
a1085 2
		kf->f_ops = PTRTOINT64(fp->f_ops);
		kf->f_data = PTRTOINT64(fp->f_data);
d1111 2
a1112 1
		kf->v_un = PTRTOINT64(vp->v_un.vu_socket);
d1116 4
a1119 2
		kf->v_data = PTRTOINT64(vp->v_data);
		kf->v_mount = PTRTOINT64(vp->v_mount);
d1139 2
a1140 1
		kf->so_pcb = PTRTOINT64(so->so_pcb);
d1144 2
a1145 1
			kf->so_splice = PTRTOINT64(so->so_splice);
d1155 2
a1156 1
			kf->inp_ppcb = PTRTOINT64(inpcb->inp_ppcb);
d1184 2
a1185 1
			kf->unp_conn = PTRTOINT64(unpcb->unp_conn);
d1195 2
a1196 1
		kf->pipe_peer = PTRTOINT64(pipe->pipe_peer);
d1541 1
d1544 2
a1545 1
	    p, pr, s, p->p_vmspace, pr->ps_limit, p->p_sigacts, isthread);
d1557 2
a1558 1
		ki->p_tsess = PTRTOINT64(tp->t_session);
@


1.230
log
@restrict KERN_PROC_ARGS lookup of KERN_PROC_NENV and KERN_PROC_ENV
to process owner and root

ok deraadt millert guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.229 2012/12/30 00:58:19 guenther Exp $	*/
d1367 1
a1367 1
	struct proc *p;
d1464 9
@


1.229
log
@In sysctl_proc_cwd(), vref() the target proc's fd_cdir before calling
malloc(), so that it can't exit and be freed if we sleep.

(another sparc.p nightmare test case)
ok beck@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.228 2012/11/05 19:39:35 miod Exp $	*/
d1611 6
@


1.228
log
@unifdef -D __HAVE_TIMECOUNTER
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.227 2012/08/30 20:11:32 matthew Exp $	*/
d1765 1
d1804 4
d1815 1
a1815 1
	error = vfs_getcwd_common(findp->p_fd->fd_cdir, NULL,
d1822 1
@


1.227
log
@Remove a useless test for "elem_count < 0", which can never be true
because elem_count has an unsigned type (size_t).

Noted by Brad/Clang; no binary change on amd64 using GCC either.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.226 2012/06/02 05:44:27 guenther Exp $	*/
a72 1
#ifdef __HAVE_TIMECOUNTER
a73 1
#endif
a291 1
#ifdef __HAVE_TIMECOUNTER
a292 1
#endif
a555 1
#ifdef __HAVE_TIMECOUNTER
a558 1
#endif
@


1.226
log
@Committed the wrong version (an earlier try) of the KERN_FILE2 vs
rthreads fix.  Update to the correct one.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.225 2012/05/30 20:04:52 matthew Exp $	*/
d1249 1
a1249 1
	if (elem_size < 1 || elem_count < 0)
@


1.225
log
@Oops, when we moved _POSIX_SAVED_IDS from sys/unistd.h to unistd.h, it
silently changed sysctl kern.saved_ids from returning 1 to 0.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.224 2012/05/25 04:39:41 guenther Exp $	*/
d1291 1
a1291 1
			if ((pp->p_flag & (P_SYSTEM | P_WEXIT | P_THREAD))
d1323 1
a1323 1
			if ((pp->p_flag & (P_SYSTEM | P_WEXIT | P_THREAD))
@


1.224
log
@Change the KERN_FILE_BYPID and KERN_FILE_BYUID modes of the KERN_FILE2
sysctl() to be per-process instead of per-thread.  This means the
filedesc table has to really be per-process instead of per-thread,
so make it an error for the linux clone() emulation to try to do
otherwise.  This removes pointless duplication in fstat's output.

requested by jsing@@ and deraadt@@, ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.223 2012/05/02 20:42:25 guenther Exp $	*/
a394 1
#ifdef _POSIX_SAVED_IDS
a395 3
#else
		return (sysctl_rdint(oldp, oldlenp, newp, 0));
#endif
@


1.223
log
@Oops, previous change had some unrelated changes that shouldn't have been
committed; roll them back.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.222 2012/05/01 03:43:23 guenther Exp $	*/
d1291 5
a1295 2
			/* skip system, exiting, embryonic and undead processes */
			if ((pp->p_flag & P_SYSTEM) || (pp->p_flag & P_WEXIT)
d1323 5
a1327 2
			/* skip system, exiting, embryonic and undead processes */
			if ((pp->p_flag & P_SYSTEM) || (pp->p_flag & P_WEXIT)
@


1.222
log
@Eliminate the f_usecount ref count in struct file; instead of sleeping
at the top of closef() until all in-progress calls finish, just do the
advisory locking bits required of close() by POSIX and let whichever
thread has the last reference do the call to the file's fo_close()
method and the final cleanup.

lots of discussion with deraadt@@ and others; worked out with and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.221 2012/04/17 23:17:53 pirofti Exp $	*/
d1291 2
a1292 5
			/*
			 * skip system, exiting, embryonic and undead
			 * processes, as well as threads
			 */
			if ((pp->p_flag & (P_SYSTEM | P_WEXIT | P_THREAD))
d1320 2
a1321 5
			/*
			 * skip system, exiting, embryonic and undead
			 * processes, as well as threads
			 */
			if ((pp->p_flag & (P_SYSTEM | P_WEXIT | P_THREAD))
@


1.221
log
@Make it optional for kvm_getprocs() (and related sysctl) to return
thread information.

Add a KERN_PROC_SHOW_THREADS flag that has to be set in order to get the
thread info and make it off by default. This creates backwards compatibility
for applications that relied on a given size/number of items to be returned.

Modify ps(1) and top(1) accordingly.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.220 2012/04/12 14:59:19 pirofti Exp $	*/
d1091 1
a1091 1
		kf->f_usecount = fp->f_usecount;
d1291 5
a1295 2
			/* skip system, exiting, embryonic and undead processes */
			if ((pp->p_flag & P_SYSTEM) || (pp->p_flag & P_WEXIT)
d1323 5
a1327 2
			/* skip system, exiting, embryonic and undead processes */
			if ((pp->p_flag & P_SYSTEM) || (pp->p_flag & P_WEXIT)
@


1.220
log
@Add per thread accounting, mainly for usage & friends.

This expands the already bloated FILL_KPROC macro to take an extra
parameter that indicates if the callee is a thread or a process.

The userland bits are adjusted accordingly and ps(1) and top(1) now
display per thread usage times when -H is used.

Also pkill(1) had to be adjusted so that duplicates don't pop up.

libkvm does basically the same thing as the kernel bits.

Okay guenther@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.219 2012/04/10 15:50:52 guenther Exp $	*/
d1376 1
d1390 3
d1477 4
@


1.219
log
@Make the KERN_NPROCS and KERN_MAXPROC sysctl()s and the RLIMIT_NPROC rlimit
count processes instead of threads.  New sysctl()s KERN_NTHREADS and
KERN_MAXTHREAD count and limit threads.  The nprocs and maxproc kernel
variables are replaced by nprocess, maxprocess, nthreads, and maxthread.

ok tedu@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.218 2012/03/28 16:01:30 guenther Exp $	*/
d1461 12
d1474 1
a1474 1
			fill_kproc(p, kproc);
d1509 1
a1509 1
fill_kproc(struct proc *p, struct kinfo_proc *ki)
d1517 1
a1517 1
	    p, pr, s, p->p_vmspace, pr->ps_limit, p->p_sigacts);
@


1.218
log
@The kinfo_file2 structure's f_wbytes member was being filled with the
read byte count instead of the written byte count.

pointed out by paulm at tetrardus.net, ok dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.217 2012/03/23 15:51:26 guenther Exp $	*/
d319 1
a319 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &maxproc));
d404 4
d501 1
a501 1
		return (sysctl_rdint(oldp, oldlenp, newp, nprocs));
@


1.217
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.216 2012/03/13 17:28:32 tedu Exp $	*/
d1095 1
a1095 1
			kf->f_wbytes = fp->f_rbytes;
@


1.216
log
@0 is a valid uid for files sysctl, don't skip it.  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.215 2012/03/10 05:54:28 guenther Exp $	*/
d1501 1
a1501 1
	    p, pr, s, p->p_vmspace, pr->ps_limit, p->p_stats, p->p_sigacts);
d1524 1
a1524 1
		calcru(p, &ut, &st, NULL);
@


1.215
log
@Add PS_EXITING to better differentiate between the process exiting and
the main thread exiting.  c.f. regress/sys/kern/main-thread-exited/
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.214 2012/02/20 22:23:39 guenther Exp $	*/
d1321 1
a1321 1
			if (arg > 0 && pp->p_ucred->cr_uid != (uid_t)arg) {
@


1.214
log
@First steps for making ptrace work with rthreads:
 - move the P_TRACED and P_INEXEC flags, and p_oppid, p_ptmask, and
   p_ptstat member from struct proc to struct process
 - sort the PT_* requests into those that take a PID vs those that
   can also take a TID
 - stub in PT_GET_THREAD_FIRST and PT_GET_THREAD_NEXT

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.213 2012/02/15 04:29:09 guenther Exp $	*/
d1289 1
d1318 1
d1585 1
a1585 1
	if ((vp->p_flag & P_WEXIT))
d1773 1
a1773 1
	if (findp->p_flag & P_WEXIT)
@


1.213
log
@Enable rthreads by default

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.212 2012/01/21 16:30:31 guenther Exp $	*/
d1587 1
a1587 1
	if ((vp->p_flag & P_INEXEC))
@


1.212
log
@Make the KERN_FILE2 sysctl() report ENOMEM as documented in sysctl(3).

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.211 2012/01/07 05:38:12 guenther Exp $	*/
d130 1
a130 1
int rthreads_enabled = 0;
@


1.211
log
@Add rtable id and thread id to struct kinfo_proc (and fix process id)
and add an 'rtableid' keyword to ps.

Add rtable id, thread id, and socket splice info to struct kinfo_file2
and make fstat display socket splice information.

Remove old KVM_PROC2 and kinfo_proc2 interfaces; bump libkvm major

Socket splice info and corrections from bluhm@@  "Lovely" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.210 2011/12/14 07:32:16 guenther Exp $	*/
d1348 2
@


1.210
log
@Handle rthreads consistently in ktrace by moving the flags and vnode into
struct process; KTRFAC_ACTIVE becomes P_INKTR.  Also, save the credentials
used to open the file in sys_ktrace() and use them for all writes to the
vnode.

much feedback and ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.209 2011/12/09 16:14:54 nicm Exp $	*/
d1140 5
d1156 1
d1173 1
d1211 1
a1211 1
		kf->p_pid = pp->p_pid;
d1214 1
d1500 1
@


1.209
log
@Add new KERN_PROC_CWD sysctl to get the current working directory of a process.

ok guenther deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.208 2011/09/18 13:23:38 miod Exp $	*/
d1294 2
a1295 2
			if (pp->p_tracep)
				FILLIT(NULL, NULL, KERN_FILE_TRACE, pp->p_tracep, pp);
d1320 2
a1321 2
			if (pp->p_tracep)
				FILLIT(NULL, NULL, KERN_FILE_TRACE, pp->p_tracep, pp);
@


1.208
log
@Do not use the `hh' modifier in printf format strings, as the kernel printf
implementation does not support it and handles it as `h'.
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.207 2011/09/18 01:54:41 guenther Exp $	*/
d120 1
d286 1
d372 3
d1727 61
@


1.207
log
@Make sysctl__string() handle the truncated output case via two
copyout()s instead of altering the in-use variable, and to also
return the full length via oldlenp in that case as documented.

ok jsing@@ (problem pointed out by matthew@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.206 2011/07/05 04:48:02 guenther Exp $	*/
d1767 2
a1768 2
				    "%02hhx%02hhx%02hhx%02hhx"
				    "%02hhx%02hhx%02hhx%02hhx",
@


1.206
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.205 2011/06/27 03:40:35 guenther Exp $	*/
a907 1
	char c;
d918 4
a921 5
			/* save & zap NUL terminator while copying */
			c = str[*oldlenp-1];
			str[*oldlenp-1] = '\0';
			error = copyout(str, oldp, *oldlenp);
			str[*oldlenp-1] = c;
a922 1
			*oldlenp = len;
d926 1
@


1.205
log
@Make KERN_FILE and KERN_FILE2 behavior consistent: when the caller doesn't
have the necessary rights, return f_offset=-1 and f_seek=0.

ok tedu@@, matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.204 2011/06/24 19:47:49 naddy Exp $	*/
d48 1
d1486 1
a1486 1
	    p, pr, s, p->p_vmspace, pr->ps_limit, p->p_stats);
@


1.204
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.203 2011/06/09 21:10:55 sthen Exp $	*/
d1046 1
a1081 1
		kf->f_offset = fp->f_offset;
d1086 1
d1092 2
a1093 1
		}
@


1.203
log
@Don't copy the first octet of the source IPv6 address where the destination
address should be, fixes broken fstat output for v6 socket connections.

Problem noticed by dhill@@, ok todd@@, "i have no idea what that diff is
touching, but it sure looks ok" halex@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.202 2011/04/18 21:44:56 guenther Exp $	*/
d614 1
d720 6
@


1.202
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.200 2011/04/04 11:13:55 deraadt Exp $	*/
d1150 1
a1150 1
			kf->inp_faddru[0] = inpcb->inp_laddr6.s6_addr32[0];
@


1.201
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@a47 1
#include <sys/signalvar.h>
d1476 1
a1476 1
	    p, pr, s, p->p_vmspace, pr->ps_limit, p->p_stats, p->p_sigacts);
@


1.200
log
@sysctl kern.pool_debug=0 will disable POOL_DEBUG on the fly (still defaults
to on, if POOL_DEBUG is compiled in, so that boot-time pool corruption
can be found.  When the sysctl is turned off, performance is almost as
as good as compiling with POOL_DEBUG compiled out.  Not all pool page
headers can be purged of the magic checks.
performance tests by henning
ok ariane kettenis mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.199 2011/04/02 16:47:17 beck Exp $	*/
d48 1
d1477 1
a1477 1
	    p, pr, s, p->p_vmspace, pr->ps_limit, p->p_stats);
@


1.199
log
@Constrain the buffer cache to use only the dma reachable region of memory.
With this change bufcachepercent will be the percentage of dma reachable
memory that the buffer cache will attempt to use.
ok deraadt@@ thib@@ oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.198 2011/03/12 04:54:28 guenther Exp $	*/
d273 1
d595 9
@


1.198
log
@Replace the old, broken KERN_PROC ABI and its matching functions
in libkvm with the stable-ABI versions that are currently named
KERN_PROC2, kvm_get{proc,argv,envv}2().  The latter names and symbols
will continue to be supported for a few releases.

Committing now that they ports people have had a couple releases
to update pkgs that usd the old functions
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.197 2011/02/16 10:37:45 mikeb Exp $	*/
d567 1
d578 1
d580 1
a580 1
			pgs = bufcachepercent * physmem / 100;
@


1.197
log
@allow users to enable access to the /dev/crypto, but keep it turned off
by default, adjust comments in sysctl.conf;  ok markus, tedu, djm, miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.196 2010/12/14 20:26:44 mikeb Exp $	*/
a277 1
		case KERN_PROC2:
d364 1
a364 2
	case KERN_PROC2:
		return (sysctl_doproc(name, namelen, oldp, oldlenp));
d1324 1
a1324 1
#define KERN_PROCSLOP	(5 * sizeof (struct kinfo_proc))
d1329 1
a1329 2
	struct kinfo_proc2 *kproc2 = NULL;
	struct eproc *eproc = NULL;
d1334 1
a1334 1
	int error, needed, type, op;
a1338 1
	type = name[0];
d1340 11
a1350 18
	if (type == KERN_PROC) {
		if (namelen != 3 && !(namelen == 2 &&
		    (name[1] == KERN_PROC_ALL || name[1] == KERN_PROC_KTHREAD)))
			return (EINVAL);
		op = name[1];
		arg = op == KERN_PROC_ALL ? 0 : name[2];
		elem_size = elem_count = 0;
		eproc = malloc(sizeof(struct eproc), M_TEMP, M_WAITOK);
	} else /* if (type == KERN_PROC2) */ {
		if (namelen != 5 || name[3] < 0 || name[4] < 0 ||
		    name[3] > sizeof(*kproc2))
			return (EINVAL);
		op = name[1];
		arg = name[2];
		elem_size = name[3];
		elem_count = name[4];
		kproc2 = malloc(sizeof(struct kinfo_proc2), M_TEMP, M_WAITOK);
	}
d1410 1
d1414 1
d1419 9
a1427 33
		if (type == KERN_PROC) {
			if (buflen >= sizeof(struct kinfo_proc)) {
				fill_eproc(p, eproc);
				error = copyout((caddr_t)p,
				    &((struct kinfo_proc *)dp)->kp_proc,
				    sizeof(struct proc));
				if (error)
					goto err;
				error = copyout((caddr_t)eproc,
				    &((struct kinfo_proc *)dp)->kp_eproc,
				    sizeof(*eproc));
				if (error)
					goto err;
				dp += sizeof(struct kinfo_proc);
				buflen -= sizeof(struct kinfo_proc);
			}
			needed += sizeof(struct kinfo_proc);
		} else /* if (type == KERN_PROC2) */ {
			if (buflen >= elem_size && elem_count > 0) {
				fill_kproc2(p, kproc2);
				/*
				 * Copy out elem_size, but not larger than
				 * the size of a struct kinfo_proc2.
				 */
				error = copyout(kproc2, dp,
				    min(sizeof(*kproc2), elem_size));
				if (error)
					goto err;
				dp += elem_size;
				buflen -= elem_size;
				elem_count--;
			}
			needed += elem_size;
d1429 1
d1443 1
a1443 1
		needed += KERN_PROCSLOP;
d1447 2
a1448 4
	if (eproc)
		free(eproc, M_TEMP);
	if (kproc2)
		free(kproc2, M_TEMP);
d1453 1
a1453 58
 * Fill in an eproc structure for the specified process.
 */
void
fill_eproc(struct proc *p, struct eproc *ep)
{
	struct tty *tp;

	ep->e_paddr = p;
	ep->e_sess = p->p_p->ps_pgrp->pg_session;
	ep->e_pcred = *p->p_cred;
	ep->e_ucred = *p->p_ucred;
	if (p->p_stat == SIDL || P_ZOMBIE(p)) {
		ep->e_vm.vm_rssize = 0;
		ep->e_vm.vm_tsize = 0;
		ep->e_vm.vm_dsize = 0;
		ep->e_vm.vm_ssize = 0;
		bzero(&ep->e_pstats, sizeof(ep->e_pstats));
		ep->e_pstats_valid = 0;
	} else {
		struct vmspace *vm = p->p_vmspace;

		ep->e_vm.vm_rssize = vm_resident_count(vm);
		ep->e_vm.vm_tsize = vm->vm_tsize;
		ep->e_vm.vm_dsize = vm->vm_dused;
		ep->e_vm.vm_ssize = vm->vm_ssize;
		ep->e_pstats = *p->p_stats;
		ep->e_pstats_valid = 1;
	}
	if (p->p_p->ps_pptr)
		ep->e_ppid = p->p_p->ps_pptr->ps_pid;
	else
		ep->e_ppid = 0;
	ep->e_pgid = p->p_p->ps_pgrp->pg_id;
	ep->e_jobc = p->p_p->ps_pgrp->pg_jobc;
	if ((p->p_p->ps_flags & PS_CONTROLT) &&
	     (tp = ep->e_sess->s_ttyp)) {
		ep->e_tdev = tp->t_dev;
		ep->e_tpgid = tp->t_pgrp ? tp->t_pgrp->pg_id : NO_PID;
		ep->e_tsess = tp->t_session;
	} else
		ep->e_tdev = NODEV;
	ep->e_flag = ep->e_sess->s_ttyvp ? EPROC_CTTY : 0;
	if (SESS_LEADER(p->p_p))
		ep->e_flag |= EPROC_SLEADER;
	strncpy(ep->e_wmesg, p->p_wmesg ? p->p_wmesg : "", WMESGLEN);
	ep->e_wmesg[WMESGLEN] = '\0';
	ep->e_xsize = ep->e_xrssize = 0;
	ep->e_xccount = ep->e_xswrss = 0;
	strncpy(ep->e_login, ep->e_sess->s_login, MAXLOGNAME-1);
	ep->e_login[MAXLOGNAME-1] = '\0';
	strncpy(ep->e_emul, p->p_emul->e_name, EMULNAMELEN);
	ep->e_emul[EMULNAMELEN] = '\0';
	ep->e_maxrss = p->p_rlimit ? p->p_rlimit[RLIMIT_RSS].rlim_cur : 0;
	ep->e_limit = p->p_p->ps_limit;
}

/*
 * Fill in a kproc2 structure for the specified process.
d1456 1
a1456 1
fill_kproc2(struct proc *p, struct kinfo_proc2 *ki)
d1463 1
a1463 1
	FILL_KPROC2(ki, strlcpy, p, pr, p->p_cred, p->p_ucred, pr->ps_pgrp,
@


1.196
log
@disable access to the crypto(4) device from userland; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.195 2010/11/19 18:35:16 mikeb Exp $	*/
a513 2
		if (newp && newlen)
			return (EINVAL);
a515 2
		if (newp && newlen)
			return (EINVAL);
a518 2
		if (newp && newlen)
			return (EINVAL);
@


1.195
log
@Make KERN_CPTIME return an avarage number of ticks across all CPUs
tedu agreed with an idea, tested by Luis Useche and me; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.194 2010/11/02 09:36:09 dlg Exp $	*/
d514 2
d518 2
d523 2
@


1.194
log
@export the network livelock counter. part of a diff i committed the
userland side of.

pointed out by claudio@@ after i embarassed myself saying "yes, its there!"
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.193 2010/09/23 13:24:22 jsing Exp $	*/
d471 3
@


1.193
log
@Include the disklabel UID in hw.disknames.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.191 2010/07/26 01:56:27 guenther Exp $	*/
d113 1
d589 2
@


1.192
log
@Introduce an MI kern.consdev sysctl that will replace the MD
machdep.console_device that's only implemented on a few architectures.

ok deraadt@@, miod@@
@
text
@d1796 1
d1799 2
d1808 5
a1812 2
		    dk = TAILQ_NEXT(dk, dk_link))
			tlen += strlen(dk->dk_name) + 1;
d1828 12
a1839 2
			snprintf(disknames + l, tlen - l, "%s,",
			    dk->dk_name ? dk->dk_name : "");
@


1.191
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.190 2010/07/19 23:00:15 guenther Exp $	*/
d80 2
d261 1
d582 6
@


1.190
log
@Rollback the allproclk and fileheadlk addition.  When grabbing an
rwlock, the thread will release biglock if it sleeps, means that
atomicity from before the rw_enter() to after it is not guaranteed.
The change didn't address those, so pulling it until it does.

"go for it" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.189 2010/07/10 21:29:37 guenther Exp $	*/
d1319 1
d1358 2
a1359 1
		if (p->p_pgrp == NULL)
d1375 1
a1375 1
			if (p->p_pgrp->pg_id != (pid_t)arg)
d1380 2
a1381 2
			if (p->p_session->s_leader == NULL ||
			    p->p_session->s_leader->p_pid != (pid_t)arg)
d1386 3
a1388 3
			if ((p->p_flag & P_CONTROLT) == 0 ||
			    p->p_session->s_ttyp == NULL ||
			    p->p_session->s_ttyp->t_dev != (dev_t)arg)
d1480 1
a1480 1
	ep->e_sess = p->p_pgrp->pg_session;
d1500 2
a1501 2
	if (p->p_pptr)
		ep->e_ppid = p->p_pptr->p_pid;
d1504 3
a1506 3
	ep->e_pgid = p->p_pgrp->pg_id;
	ep->e_jobc = p->p_pgrp->pg_jobc;
	if ((p->p_flag & P_CONTROLT) &&
d1514 1
a1514 1
	if (SESS_LEADER(p))
d1534 2
d1539 2
a1540 2
	FILL_KPROC2(ki, strlcpy, p, p->p_p, p->p_cred, p->p_ucred, p->p_pgrp,
	    p, p->p_session, p->p_vmspace, p->p_p->ps_limit, p->p_stats);
d1543 4
a1546 4
	if (p->p_pptr)
		ki->p_ppid = p->p_pptr->p_pid;
	if (p->p_session->s_leader)
		ki->p_sid = p->p_session->s_leader->p_pid;
d1548 1
a1548 1
	if ((p->p_flag & P_CONTROLT) && (tp = p->p_session->s_ttyp)) {
@


1.189
log
@A process on the zombie list can have a NULL p_pgrp if it sleeps when
grabbing allproclk in proc_zap(); skip such processes in sysctl(KERN_PROC*)
and handle the NULL pointer in ddb's ps.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.188 2010/07/02 18:14:40 guenther Exp $	*/
d166 1
a166 4
		switch (name[1]) {	/* XXX */
		case KERN_VNODE:
		case KERN_FILE:
		case KERN_FILE2:
a167 2
			break;
		}
a1001 1
	rw_enter_read(&fileheadlk);
d1005 1
a1005 2
			error = ENOMEM;
			goto out;
d1019 1
a1019 1
			goto out;
d1024 1
a1024 3
out:
	rw_exit_read(&fileheadlk);
	return (error);
a1227 1
		rw_enter_read(&fileheadlk);
a1232 1
		rw_exit_read(&fileheadlk);
a1239 1
		rw_enter_read(&allproclk);
a1249 1
			fdplock(fdp);
a1264 1
			fdpunlock(fdp);
a1265 1
		rw_exit_read(&allproclk);
a1267 1
		rw_enter_read(&allproclk);
a1277 1
			fdplock(fdp);
a1290 1
			fdpunlock(fdp);
a1291 1
		rw_exit_read(&allproclk);
a1345 1
	rw_enter_read(&allproclk);
a1461 1
	rw_exit_read(&allproclk);
@


1.188
log
@Since fill_eproc() is no longer called from coredump(), it can be dropped
from small kernels
"yes" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.187 2010/06/30 19:57:05 deraadt Exp $	*/
d1375 5
@


1.187
log
@Add getsockopt SOL_SOCKET SO_PEERCRED support. This behaves similar to
getpeereid(2), but also supplies the remote pid.  This is supplied in
a 'struct sockpeercred' (unlike Linux -- they showed how little they
know about real unix by calling theirs 'struct ucred').
ok guenther ajacoutot
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.186 2010/06/29 16:39:22 guenther Exp $	*/
a1484 2
#endif	/* SMALL_KERNEL */

a1540 2

#ifndef	SMALL_KERNEL
@


1.186
log
@Fail instead of lying if a process asks sysctl()'s KERN_PROC2 or
KERN_FILE2 (or their libkvm wrappers) for more information than the
running implementation knows how to provide.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.185 2010/06/29 00:28:14 tedu Exp $	*/
d69 1
@


1.185
log
@Eliminate RTHREADS kernel option in favor of a sysctl.  The actual status
(not done) hasn't changed, but now it's less work to test things.
ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.184 2010/06/19 14:44:44 thib Exp $	*/
d1201 1
a1201 1
	if (namelen < 4)
d1355 2
a1356 1
		if (namelen != 5 || name[3] < 0 || name[4] < 0)
@


1.184
log
@Skip exiting procesess in sysctl_file2(). As processes in exit1()
do a pdfree() way before they remove themself from the allproc
list. This prevents a null deref found by todd@@.

Joint work with mikeb

OK millert@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.182 2010/04/20 20:49:33 deraadt Exp $	*/
d124 2
d562 3
@


1.183
log
@Use intermediate vaddr_t cast when casting a pointer to off_t.  Prevents
gcc4 from complaining about casting a pointer to an integer type of different
size.

ok guenther@@, jsg@@
@
text
@d1247 3
a1249 3
			/* skip system, embryonic and undead processes */
			if ((pp->p_flag & P_SYSTEM) ||
			    pp->p_stat == SIDL || pp->p_stat == SZOMB)
d1279 3
a1281 3
			/* skip system, embryonic and undead processes */
			if ((pp->p_flag & P_SYSTEM) ||
			    pp->p_stat == SIDL || pp->p_stat == SZOMB)
@


1.182
log
@Get rid of MAXSENSORDEVICES.  Gaps in sensordev lists are now handled
by returning ENXIO instead of ENOENT, to essentially indicate hotplug
sensor that has gone away.  Accessing beyond the end of the sensordev
list still returns ENOENT, so that you can see there are no further devices.
ok kettenis oga
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.181 2010/03/24 23:18:17 tedu Exp $	*/
d1649 1
a1649 1
	uio.uio_offset = (off_t)PS_STRINGS;
@


1.181
log
@Add a rwlock around the filehead and allproc lists, mainly to protect
list walkers in sysctl that can block.  As a reward, no more vslock.
With some feedback from art, guenther, phessler.  ok guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.180 2010/01/10 03:37:50 guenther Exp $	*/
d2011 3
a2013 3
		ksd = sensordev_get(dev);
		if (ksd == NULL)
			return (ENOENT);
d2032 3
a2034 3
	ks = sensor_find(dev, type, numt);
	if (ks == NULL)
		return (ENOENT);
@


1.180
log
@Reimplement kvm_getproc2()'s support for reading crash dumps and
/dev/mem to be direct instead of going through kvm_getprocs(), as
that function is going to get more an more broken as we move stuff
from struct proc to struct process for rthreads.  To minimize the
code copying, put the common logic of filling in a kinfo_proc2
structure into a macro FILL_KPROC2() in <sys/sysctl.h> for use from
both the kernel and user-space.  This also hides the KERN_PROC
#define behind "#if defined(_KERNEL)||defined(_LIBKVM)", as it's
deprecated.

Positive feedback from millert and blambert; so committing to unblock
further rthreads work.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.179 2009/08/09 10:40:17 blambert Exp $	*/
d163 4
a166 1
		if (name[1] == KERN_VNODE)	/* XXX */
d168 2
d1001 1
d1005 2
a1006 1
			return (ENOMEM);
d1020 1
a1020 1
			return (error);
d1025 3
a1027 1
	return (0);
d1231 1
d1237 1
d1245 1
d1256 1
d1272 1
d1274 1
d1277 1
d1288 1
d1302 1
d1304 1
d1358 1
d1470 1
@


1.179
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.178 2009/08/02 16:28:39 beck Exp $	*/
a103 2
#define	PTRTOINT64(_x)	((u_int64_t)(u_long)(_x))

d1527 2
a1528 15
	bzero(ki, sizeof(*ki));

	ki->p_paddr = PTRTOINT64(p);
	ki->p_fd = PTRTOINT64(p->p_fd);
	ki->p_stats = PTRTOINT64(p->p_stats);
	ki->p_limit = PTRTOINT64(p->p_p->ps_limit);
	ki->p_vmspace = PTRTOINT64(p->p_vmspace);
	ki->p_sigacts = PTRTOINT64(p->p_sigacts);
	ki->p_sess = PTRTOINT64(p->p_session);
	ki->p_tsess = 0;	/* may be changed if controlling tty below */
	ki->p_ru = PTRTOINT64(p->p_ru);

	ki->p_eflag = 0;
	ki->p_exitsig = p->p_exitsig;
	ki->p_flag = p->p_flag | P_INMEM;
d1530 1
a1530 1
	ki->p_pid = p->p_pid;
a1532 2
	else
		ki->p_ppid = 0;
a1534 5
	else
		ki->p_sid = 0;
	ki->p__pgid = p->p_pgrp->pg_id;

	ki->p_tpgid = -1;	/* may be changed if controlling tty below */
a1535 12
	ki->p_uid = p->p_ucred->cr_uid;
	ki->p_ruid = p->p_cred->p_ruid;
	ki->p_gid = p->p_ucred->cr_gid;
	ki->p_rgid = p->p_cred->p_rgid;
	ki->p_svuid = p->p_cred->p_svuid;
	ki->p_svgid = p->p_cred->p_svgid;

	memcpy(ki->p_groups, p->p_cred->pc_ucred->cr_groups,
	    min(sizeof(ki->p_groups), sizeof(p->p_cred->pc_ucred->cr_groups)));
	ki->p_ngroups = p->p_cred->pc_ucred->cr_ngroups;

	ki->p_jobc = p->p_pgrp->pg_jobc;
d1542 1
d1545 4
a1548 71
	ki->p_estcpu = p->p_estcpu;
	ki->p_rtime_sec = p->p_rtime.tv_sec;
	ki->p_rtime_usec = p->p_rtime.tv_usec;
	ki->p_cpticks = p->p_cpticks;
	ki->p_pctcpu = p->p_pctcpu;

	ki->p_uticks = p->p_uticks;
	ki->p_sticks = p->p_sticks;
	ki->p_iticks = p->p_iticks;

	ki->p_tracep = PTRTOINT64(p->p_tracep);
	ki->p_traceflag = p->p_traceflag;

	ki->p_siglist = p->p_siglist;
	ki->p_sigmask = p->p_sigmask;
	ki->p_sigignore = p->p_sigignore;
	ki->p_sigcatch = p->p_sigcatch;

	ki->p_stat = p->p_stat;
	ki->p_nice = p->p_nice;

	ki->p_xstat = p->p_xstat;
	ki->p_acflag = p->p_acflag;

	strlcpy(ki->p_emul, p->p_emul->e_name, sizeof(ki->p_emul));
	strlcpy(ki->p_comm, p->p_comm, sizeof(ki->p_comm));
	strncpy(ki->p_login, p->p_session->s_login,
	    min(sizeof(ki->p_login) - 1, sizeof(p->p_session->s_login)));

	if (p->p_stat == SIDL || P_ZOMBIE(p)) {
		ki->p_vm_rssize = 0;
		ki->p_vm_tsize = 0;
		ki->p_vm_dsize = 0;
		ki->p_vm_ssize = 0;
	} else {
		struct vmspace *vm = p->p_vmspace;

		ki->p_vm_rssize = vm_resident_count(vm);
		ki->p_vm_tsize = vm->vm_tsize;
		ki->p_vm_dsize = vm->vm_dused;
		ki->p_vm_ssize = vm->vm_ssize;
		ki->p_forw = ki->p_back = 0;
		ki->p_addr = PTRTOINT64(p->p_addr);
		ki->p_stat = p->p_stat;
		ki->p_swtime = p->p_swtime;
		ki->p_slptime = p->p_slptime;
		ki->p_schedflags = 0;
		ki->p_holdcnt = 1;
		ki->p_priority = p->p_priority;
		ki->p_usrpri = p->p_usrpri;
		if (p->p_wmesg)
			strlcpy(ki->p_wmesg, p->p_wmesg, sizeof(ki->p_wmesg));
		ki->p_wchan = PTRTOINT64(p->p_wchan);

	}

	if (p->p_session->s_ttyvp)
		ki->p_eflag |= EPROC_CTTY;
	if (SESS_LEADER(p))
		ki->p_eflag |= EPROC_SLEADER;
	if (p->p_rlimit)
		ki->p_rlim_rss_cur = p->p_rlimit[RLIMIT_RSS].rlim_cur;

	/* XXX Is this double check necessary? */
	if (P_ZOMBIE(p)) {
		ki->p_uvalid = 0;
	} else {
		ki->p_uvalid = 1;

		ki->p_ustart_sec = p->p_stats->p_start.tv_sec;
		ki->p_ustart_usec = p->p_stats->p_start.tv_usec;
a1555 20
		ki->p_uru_maxrss = p->p_stats->p_ru.ru_maxrss;
		ki->p_uru_ixrss = p->p_stats->p_ru.ru_ixrss;
		ki->p_uru_idrss = p->p_stats->p_ru.ru_idrss;
		ki->p_uru_isrss = p->p_stats->p_ru.ru_isrss;
		ki->p_uru_minflt = p->p_stats->p_ru.ru_minflt;
		ki->p_uru_majflt = p->p_stats->p_ru.ru_majflt;
		ki->p_uru_nswap = p->p_stats->p_ru.ru_nswap;
		ki->p_uru_inblock = p->p_stats->p_ru.ru_inblock;
		ki->p_uru_oublock = p->p_stats->p_ru.ru_oublock;
		ki->p_uru_msgsnd = p->p_stats->p_ru.ru_msgsnd;
		ki->p_uru_msgrcv = p->p_stats->p_ru.ru_msgrcv;
		ki->p_uru_nsignals = p->p_stats->p_ru.ru_nsignals;
		ki->p_uru_nvcsw = p->p_stats->p_ru.ru_nvcsw;
		ki->p_uru_nivcsw = p->p_stats->p_ru.ru_nivcsw;

		timeradd(&p->p_stats->p_cru.ru_utime,
			 &p->p_stats->p_cru.ru_stime, &ut);
		ki->p_uctime_sec = ut.tv_sec;
		ki->p_uctime_usec = ut.tv_usec;
		ki->p_cpuid = KI_NOCPU;
@


1.178
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.177 2009/07/21 14:10:14 millert Exp $	*/
a1971 3
#ifdef SYSVMSG
	struct msg_sysctl_info *msgsi;
#endif
d1990 1
a1990 4
		infosize = sizeof(msgsi->msginfo);
		nds = msginfo.msgmni;
		dssize = sizeof(msgsi->msgids[0]);
		break;
a2030 6
#ifdef SYSVMSG
	case KERN_SYSVIPC_MSG_INFO:
		msgsi = (struct msg_sysctl_info *)buf;
		msgsi->msginfo = msginfo;
		break;
#endif
a2054 5
#ifdef SYSVMSG
			case KERN_SYSVIPC_MSG_INFO:
				bcopy(&msqids[i], &msgsi->msgids[i], dssize);
				break;
#endif
@


1.177
log
@Handle the case where so_pcb is NULL.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.176 2009/07/19 12:56:19 millert Exp $	*/
d558 2
a559 2
		int opct = 0;

d561 1
a561 1
		    &opct);
d564 9
@


1.176
log
@Hook up "text" (executable) output and implement for fuser too.
Man page bits adapted from FreeBSD.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.175 2009/06/15 17:59:45 deraadt Exp $	*/
d1089 2
@


1.175
log
@No you cannot remove a sysctl mib once you add it.  It becomes ABI.  That
is how sysctl finds them, so it can *never* be renumbered again, and must
stay
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.174 2009/06/15 17:01:26 beck Exp $	*/
d1235 2
@


1.175.4.1
log
@MFC rev 1.177 by millert:

Handle the case where so_pcb is NULL.

ok sthen@@ millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.175 2009/06/15 17:59:45 deraadt Exp $	*/
a1088 2
		if (!so->so_pcb)
			break;
@


1.174
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.173 2009/06/08 00:52:23 deraadt Exp $	*/
d557 9
@


1.173
log
@some vnodes have a NULL mountpoint, so strlcpy of the f_mntonname if not advised
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.172 2009/06/07 03:07:19 millert Exp $	*/
a556 18
	case KERN_CACHEPCT: {
		int opct, pgs;
		opct = bufcachepercent;
		error = sysctl_int(oldp, oldlenp, newp, newlen,
		    &bufcachepercent);
		if (error)
			return(error);
		if (bufcachepercent > 90 || bufcachepercent < 5) {
			bufcachepercent = opct;
			return (EINVAL);
		}
		if (bufcachepercent != opct) {
			pgs = bufcachepercent * physmem / 100;
			bufadjust(pgs); /* adjust bufpages */
			bufhighpages = bufpages; /* set high water mark */
		}
		return(0);
	}
@


1.172
log
@Add KERN_FILE2 sysctl analogous to KERN_PROC2 but for file structures,
along with vnode type-specific info to make it more useful for fstat(1).
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.171 2009/06/05 04:29:14 beck Exp $	*/
d1076 4
a1079 2
		strlcpy(kf->f_mntonname, vp->v_mount->mnt_stat.f_mntonname,
		    sizeof(kf->f_mntonname));
@


1.171
log
@Dynamic buffer cache sizing.

This commit won't change the default behaviour of the system unless the
buffer cache size is increased with sysctl kern.bufcachepercent. By default
our buffer cache is 10% of memory, which with this commit is now treated
as a low water mark.  If the buffer cache size is increased, the new size
is treated as a high water mark and the buffer cache is permitted to grow
to that percentage of memory.

If the page daemon is invoked, the page daemon will ask the buffer cache
to relenquish pages. if the buffer cache has more than the low water mark it
will relenquish pages allowing them to be consumed by uvm. after a short
period the buffer cache will attempt to re-grow back to the high water mark.

This permits the use of a large buffer cache without penalizing the available
memory for other purposes.

Above the low water mark the buffer cache remains entirely subservient to
the page daemon, so if uvm requires pages, the buffer cache will abandon
them.

ok art@@ thib@@ oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.170 2009/06/03 21:30:20 beck Exp $	*/
d49 1
d66 5
d75 1
d80 9
d290 1
d365 2
d975 1
a975 1
		 * overestimate by 10 files
d977 2
a978 1
		*sizep = sizeof(filehead) + (nfiles + 10) * sizeof(struct file);
d1024 273
@


1.170
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.169 2009/04/19 17:53:38 deraadt Exp $	*/
d551 2
a552 1
			bufadjust(pgs);
@


1.169
log
@Count number of cpus found (potentially not attached) and store that
in sysctl hw.ncpufound; ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.168 2009/01/21 21:02:40 miod Exp $	*/
d538 17
@


1.168
log
@Pass the new pointer to sysctl_clockrate(), so that trying to change the
value of kern.clockrate with sysctl(3) correctly sets errno on failure.
PR #6040, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.167 2008/10/31 17:18:24 deraadt Exp $	*/
d567 2
@


1.167
log
@Do not assume that a pointer to another process will live over a set of
sleeping calls.  Since we are simply operating on another process'
vmspace, grab a (refcounted) copy of that pointer and use that instead.
originally spotted by kurt, discussed with art
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.164 2008/10/31 17:15:30 deraadt Exp $	*/
d335 1
a335 1
		return (sysctl_clockrate(oldp, oldlenp));
@


1.166
log
@accidental commit ... backout
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.163 2008/10/09 07:48:55 kevlo Exp $	*/
a1369 1
	int op;
d1373 1
a1373 1
	int error;
a1374 1
	int cnt;
d1376 2
a1377 2
	char *rarg, *varg;
	char *buf;
d1419 4
a1422 1
	vp->p_vmspace->vm_refcnt++;	/* XXX */
d1435 1
a1435 1
	if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio, 0)) != 0)
d1492 1
a1492 1
		if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio, 0)) != 0)
d1514 1
a1514 1
		if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio, 0)) != 0)
d1562 1
a1562 1
	uvmspace_free(vp->p_vmspace);
@


1.165
log
@accidental commit ... backout
@
text
@@


1.164
log
@kern_sysctl.c
@
text
@d1370 1
d1374 1
a1374 1
	int error, cnt, op;
d1376 1
d1378 2
a1379 2
	char *rarg, *varg, *buf;
	struct vmspace *vm;
d1421 1
a1421 4
	vm = vp->p_vmspace;
	vm->vm_refcnt++;
	vp = NULL;

d1434 1
a1434 1
	if ((error = uvm_io(&vm->vm_map, &uio, 0)) != 0)
d1491 1
a1491 1
		if ((error = uvm_io(&vm->vm_map, &uio, 0)) != 0)
d1513 1
a1513 1
		if ((error = uvm_io(&vm->vm_map, &uio, 0)) != 0)
d1561 1
a1561 1
	uvmspace_free(vm);
@


1.163
log
@pass NULL rather than 0 for interrupt time usage to calcru()

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.162 2008/10/07 02:20:11 deraadt Exp $	*/
a1369 1
	int op;
d1373 1
a1373 1
	int error;
a1374 1
	int cnt;
d1376 2
a1377 2
	char *rarg, *varg;
	char *buf;
d1419 4
a1422 1
	vp->p_vmspace->vm_refcnt++;	/* XXX */
d1435 1
a1435 1
	if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio, 0)) != 0)
d1492 1
a1492 1
		if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio, 0)) != 0)
d1514 1
a1514 1
		if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio, 0)) != 0)
d1562 1
a1562 1
	uvmspace_free(vp->p_vmspace);
@


1.162
log
@Do not display file offsets and a few other pieces of information, except
to the user or the superuser.  Display * for those fields instead.  From
PR 5113, but modified to use copyout correctly.
comments from tedu, ok from others
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.161 2008/06/09 07:07:16 djm Exp $	*/
d1331 1
a1331 1
		calcru(p, &ut, &st, 0);
@


1.161
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.160 2008/02/09 15:10:58 kettenis Exp $	*/
d350 1
a350 1
		return (sysctl_file(oldp, oldlenp));
d926 1
a926 1
sysctl_file(char *where, size_t *sizep)
d929 1
a929 1
	struct file *fp;
d931 1
d963 11
a973 1
		error = copyout((caddr_t)fp, where, sizeof (struct file));
@


1.160
log
@Introduce HW_PHYSMEM64 and HW_USERMEM64 sysctls, which don't overflow on
machines with more than 4GB of memory.  Make sysctl(8) print values obtained
using these sysctls for hw.physmem and hw.usermem.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.159 2007/12/23 01:59:58 dlg Exp $	*/
d390 1
a390 1
			arc4random_bytes(buf, *oldlenp);
@


1.159
log
@protect the disk statistics with a mutex.

ok tedu@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.158 2007/10/10 15:53:53 art Exp $	*/
d645 6
@


1.158
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.157 2007/09/07 15:00:20 art Exp $	*/
d1590 1
d1600 1
d1614 1
d1624 1
@


1.157
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.156 2007/09/01 15:14:44 martin Exp $	*/
d1283 1
a1283 3

		ki->p_forw = PTRTOINT64(p->p_forw);
		ki->p_back = PTRTOINT64(p->p_back);
@


1.156
log
@replace the machine dependant bytes-to-clicks macro by the MI ptoa()
version for i386

more architectures and ctob() replacement is being worked on

prodded by and ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.155 2007/08/09 04:12:12 cnst Exp $	*/
d1695 1
a1695 2
	buf = malloc(min(tsize, buflen), M_TEMP, M_WAITOK);
	bzero(buf, min(tsize, buflen));
d1793 1
a1793 2
		usd = malloc(sizeof(*usd), M_TEMP, M_WAITOK);
		bzero(usd, sizeof(*usd));
d1814 1
a1814 2
	us = malloc(sizeof(*us), M_TEMP, M_WAITOK);
	bzero(us, sizeof(*us));
@


1.155
log
@be more consistent in memcpy usage; no md5 change in .o; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.154 2007/06/01 17:29:10 beck Exp $	*/
d570 1
a570 1
		return (sysctl_rdint(oldp, oldlenp, newp, ctob(physmem)));
d573 1
a573 1
		    ctob(physmem - uvmexp.wired)));
@


1.154
log
@decouple the allocated number of vnodes from the "desiredvnodes" variable
which is used to size a zillion other things that increasing excessively
has been shown to cause problems - so that we may incrementally look at
increasing those other things without making the kernel unusable.

This diff effectivly increases the number of vnodes back to the number
of buffers, as in the earlier dynamic buffer cache commits, without
increasing anything else (namecache, softdeps, etc. etc.)

ok pedro@@ tedu@@ art@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.153 2007/05/29 00:17:32 thib Exp $	*/
d1818 1
a1818 1
	memcpy(us->desc, ks->desc, sizeof(ks->desc));
@


1.153
log
@Add a name argument to the RWLOCK_INITIALIZER macro.
Pick reasonble names for the locks involved..

ok tedu@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.152 2007/05/16 17:27:30 art Exp $	*/
d292 1
a292 1
		return(sysctl_int(oldp, oldlenp, newp, newlen, &desiredvnodes));
@


1.152
log
@The world of __HAVEs and __HAVE_NOTs is reducing. All architectures
have cpu_info now, so kill the option.

eyeballed by jsg@@ and grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.151 2007/04/18 16:57:06 art Exp $	*/
d114 2
a115 2
struct rwlock sysctl_lock = RWLOCK_INITIALIZER;
struct rwlock sysctl_disklock = RWLOCK_INITIALIZER;
@


1.151
log
@When vslocking memory for the sysctl make sure that we aren't trying
to wire more memory than we are allowed to.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.150 2007/04/12 22:14:15 tedu Exp $	*/
a435 1
#ifdef __HAVE_CPUINFO
d447 1
a447 2
	}
#endif
d450 1
a534 1
#ifdef __HAVE_CPUINFO
a537 1
#endif
a1289 1
#ifdef __HAVE_CPUINFO
a1290 3
#else
		ki->p_schedflags = p->p_schedflags;
#endif
a1868 1
#ifdef __HAVE_CPUINFO
a1892 1
#endif
@


1.150
log
@move p_limit and p_cred into struct process
leave macros behind for now to keep the commit small
ok art beck miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.149 2007/03/22 16:55:31 deraadt Exp $	*/
d191 4
@


1.149
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.148 2007/02/20 17:42:29 deraadt Exp $	*/
d1178 1
d1197 1
a1197 1
	ki->p_limit = PTRTOINT64(p->p_limit);
@


1.148
log
@for sensors do not leak kernel pointers when copying out to userland;
spotted by art, ok dlg art
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.147 2007/01/12 07:41:31 art Exp $	*/
d1779 4
a1782 2
	struct sensor *s, *tmps;
	struct sensordev *sd, *tmpsd;
d1791 2
a1792 2
		sd = sensordev_get(dev);
		if (sd == NULL)
d1796 6
a1801 4
		tmpsd = malloc(sizeof(*tmpsd), M_TEMP, M_WAITOK);
		bcopy(sd, tmpsd, sizeof(*tmpsd));
		bzero(&tmpsd->list, sizeof(tmpsd->list));
		bzero(&tmpsd->sensors_list, sizeof(tmpsd->sensors_list));
d1803 1
a1803 1
		ret = sysctl_rdstruct(oldp, oldlenp, newp, tmpsd,
d1806 1
a1806 1
		free(tmpsd, M_TEMP);
d1813 2
a1814 2
	s = sensor_find(dev, type, numt);
	if (s == NULL)
d1818 9
a1826 3
	tmps = malloc(sizeof(*tmps), M_TEMP, M_WAITOK);
	bcopy(s, tmps, sizeof(*tmps));
	bzero(&tmps->list, sizeof(tmps->list));
d1828 1
a1828 1
	ret = sysctl_rdstruct(oldp, oldlenp, newp, tmps,
d1830 1
a1830 1
	free(tmps, M_TEMP);
@


1.147
log
@Switch some lockmgr locks to rwlocks.
In this commit:
 - gdt lock on amd64
 - sysctl lock
 - malloc sysctl lock
 - disk sysctl lock
 - swap syscall lock

miod@@, pedro@@ ok (and "looks good" others@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.146 2006/12/23 17:41:26 deraadt Exp $	*/
d1779 3
a1781 3
	struct sensor *s;
	struct sensordev *sd;
	int dev;
a1782 1
	int numt;
d1793 11
a1803 2
		return (sysctl_rdstruct(oldp, oldlenp, newp, sd,
		    sizeof(struct sensordev)));
d1813 9
a1821 1
	return (sysctl_rdstruct(oldp, oldlenp, newp, s, sizeof(struct sensor)));
@


1.146
log
@kernel code implimemting the new two-level sensor api; written by
Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.145 2006/12/12 23:14:28 dim Exp $	*/
d114 2
a115 16
struct lock sysctl_lock, sysctl_disklock;

#if defined(KMEMSTATS) || defined(DIAGNOSTIC) || defined(FFS_SOFTUPDATES)
struct lock sysctl_kmemlock;
#endif

void
sysctl_init(void)
{
	lockinit(&sysctl_lock, PLOCK|PCATCH, "sysctl", 0, 0);
	lockinit(&sysctl_disklock, PLOCK|PCATCH, "sysctl_disklock", 0, 0);

#if defined(KMEMSTATS) || defined(DIAGNOSTIC) || defined(FFS_SOFTUPDATES)
	lockinit(&sysctl_kmemlock, PLOCK|PCATCH, "sysctl_kmemlock", 0, 0);
#endif
}
d188 1
a188 1
		if ((error = lockmgr(&sysctl_lock, LK_EXCLUSIVE, NULL)) != 0)
d194 1
a194 1
				lockmgr(&sysctl_lock, LK_RELEASE, NULL);
d205 1
a205 1
		lockmgr(&sysctl_lock, LK_RELEASE, NULL);
d1566 1
a1566 1
	if ((i = lockmgr(&sysctl_disklock, LK_EXCLUSIVE, NULL)) != 0)
d1627 1
a1627 1
	lockmgr(&sysctl_disklock, LK_RELEASE, NULL);
@


1.145
log
@Complete gwk's previous patch to stop setperf methods from returning
errors to userland: make all cpu_setperf functions return void.

Tested by many, ok gwk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.144 2006/12/08 23:08:19 gwk Exp $	*/
d1794 4
a1797 1
	int num;
d1799 1
a1799 1
	if (namelen != 1)
d1802 12
a1813 1
	num = name[0];
d1815 1
a1815 1
	s = sensor_get(num);
@


1.144
log
@A more permanent solution to setperf methods returning error values and
the higher level sysctl code passing them to userland. Distinct diff from
the one I passed around internally with less crazy semantics. Also nuke
some trailing spaces in a few places.
"just go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.143 2006/11/29 12:24:17 miod Exp $	*/
d107 1
a107 1
int (*cpu_setperf)(int);
@


1.143
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.142 2006/05/28 19:41:42 dlg Exp $	*/
d492 1
a492 1
#if defined(SYSVMSG) || defined(SYSVSEM) || defined(SYSVSHM)  
d567 1
a567 2
	int err;
	int cpuspeed;
d629 2
a630 3
			return (cpu_setperf(perflevel));
		else
			return (0);
d1714 1
a1714 1
	switch (*name) { 
d1744 1
a1744 1
			switch (*name) { 
@


1.142
log
@back out my last commit. art pointed out that sysctl cannot sleep when
copying out to userland, so my fix was useless bloat that didnt really do
anything. the problem instead appears to be a use after free in a driver
rather than bad interactions with sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.140 2006/05/08 22:51:18 gwk Exp $	*/
a1161 1
		PHOLD(p);	/* need for pstats */
a1167 1
		PRELE(p);
d1221 1
a1221 1
	ki->p_flag = p->p_flag;
d1309 1
a1309 1
		ki->p_holdcnt = p->p_holdcnt;
a1330 1
		PHOLD(p);	/* need for pstats */
a1363 1
		PRELE(p);
@


1.141
log
@It is possible for a sensor to be detached and freed while it is being
copied out to userland. If this happens we get a use after free and things
blow up. Prevent this by making a local copy of the sensor that cannot be
freed elsewhere in the kernel and copying that out instead.

found by mbalmer@@
ok deraadt@@ krw@@
@
text
@d1799 2
a1800 1
	struct sensor ls, *s;
d1805 3
a1807 1
	s = sensor_get(name[0]);
d1811 1
a1811 7
	/*
	 * Make a local copy of the sensor which cannot be freed by a driver
	 * while it's being copied to userland.
	 */
	bcopy(s, &ls, sizeof(ls));

	return (sysctl_rdstruct(oldp, oldlenp, newp, &ls, sizeof(ls)));
@


1.140
log
@Add smbios support for i386 and amd64, fix ipmi to use this new functionallity,
hook up some sysctls to add system vendor/product/version and UUID reporting.

"get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.139 2006/03/15 21:02:09 deraadt Exp $	*/
d1799 1
a1799 2
	struct sensor *s;
	int num;
d1804 1
a1804 3
	num = name[0];

	s = sensor_get(num);
d1808 7
a1814 1
	return (sysctl_rdstruct(oldp, oldlenp, newp, s, sizeof(struct sensor)));
@


1.139
log
@add sysctl_int_lower().  This can read, but can only write to a kernel
variable if the result is a lowering of the value; tested matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.138 2006/01/28 09:53:37 dlg Exp $	*/
d560 2
d633 27
@


1.138
log
@get rid of the sensors globals. theyre were only used by sysctl for
locating and finding the correct sensor to spit out. instead provide a
a sensor_get function that wraps up the access to the vars. theyre now
safe inside kern_sensors.c.

theres also a touch of whitespace tweaking

ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.137 2006/01/19 17:08:40 grange Exp $	*/
d675 20
@


1.137
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.136 2005/11/28 00:14:29 jsg Exp $	*/
d1750 1
a1750 1
	struct sensor *s = NULL;
a1756 4
	SLIST_FOREACH(s, &_sensors_list, list)
		if (s->num == num)
			return (sysctl_rdstruct(oldp, oldlenp, newp, s,
			    sizeof(struct sensor)));
d1758 5
a1762 1
	return (ENOENT);
@


1.136
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.135 2005/11/21 13:47:52 dlg Exp $	*/
a1756 3
	if (num < 0 || num >= _sensors_count)
		return (ENXIO);

d1759 2
a1760 1
			break;
d1762 1
a1762 1
	return (sysctl_rdstruct(oldp, oldlenp, newp, s, sizeof(struct sensor)));
@


1.135
log
@rename the sensor globals to names that are not obvious to avoid
collisions with local variable names someone might make. this has bitten
me twice now and caused me to lose about 4 hours scratching my head when
nsensors just magically corrupts and gets bigger. at least my ram isnt
screwed.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.134 2005/11/19 02:18:01 pedro Exp $	*/
d121 1
a121 1
sysctl_init()
d132 1
a132 4
sys___sysctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d134 1
a134 1
	register struct sys___sysctl_args /* {
d248 2
a249 8
kern_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d561 2
a562 8
hw_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d653 2
a654 8
debug_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d681 1
a681 6
sysctl_int(oldp, oldlenp, newp, newlen, valp)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	int *valp;
d701 1
a701 5
sysctl_rdint(oldp, oldlenp, newp, val)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	int val;
d719 2
a720 8
sysctl_int_arr(valpp, name, namelen, oldp, oldlenp, newp, newlen)
	int **valpp;
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
d734 2
a735 6
sysctl_quad(oldp, oldlenp, newp, newlen, valp)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	int64_t *valp;
d755 1
a755 5
sysctl_rdquad(oldp, oldlenp, newp, val)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	int64_t val;
d774 2
a775 7
sysctl_string(oldp, oldlenp, newp, newlen, str, maxlen)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	char *str;
	int maxlen;
d781 2
a782 7
sysctl_tstring(oldp, oldlenp, newp, newlen, str, maxlen)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	char *str;
	int maxlen;
d788 2
a789 8
sysctl__string(oldp, oldlenp, newp, newlen, str, maxlen, trunc)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	char *str;
	int maxlen;
	int trunc;
d824 1
a824 5
sysctl_rdstring(oldp, oldlenp, newp, str)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	const char *str;
d844 2
a845 7
sysctl_struct(oldp, oldlenp, newp, newlen, sp, len)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	void *sp;
	int len;
d867 2
a868 6
sysctl_rdstruct(oldp, oldlenp, newp, sp, len)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	const void *sp;
	int len;
d886 1
a886 3
sysctl_file(where, sizep)
	char *where;
	size_t *sizep;
d940 1
a940 5
sysctl_doproc(name, namelen, where, sizep)
	int *name;
	u_int namelen;
	char *where;
	size_t *sizep;
d1531 1
a1531 3
sysctl_diskinit(update, p)
	int update;
	struct proc *p;
d1604 1
a1604 5
sysctl_sysvipc(name, namelen, where, sizep)
	int *name;
	u_int namelen;
	void *where;
	size_t *sizep;
@


1.134
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.133 2005/11/10 08:10:16 dlg Exp $	*/
d1842 1
a1842 1
	if (num < 0 || num >= nsensors)
d1845 1
a1845 1
	SLIST_FOREACH(s, &sensors, list)
@


1.133
log
@split the sensors stuff out into a source file of its own.

tested on GENERIC and RAMDISK_CD to see if the small_kernel stuff stays
happy
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.132 2005/11/04 21:47:57 miod Exp $	*/
d205 1
a205 1
		if ((error = lockmgr(&sysctl_lock, LK_EXCLUSIVE, NULL, p)) != 0)
d211 1
a211 1
				lockmgr(&sysctl_lock, LK_RELEASE, NULL, p);
d222 1
a222 1
		lockmgr(&sysctl_lock, LK_RELEASE, NULL, p);
d1618 1
a1618 1
	if ((i = lockmgr(&sysctl_disklock, LK_EXCLUSIVE, NULL, p)) != 0)
d1679 1
a1679 1
	lockmgr(&sysctl_disklock, LK_RELEASE, NULL, p);
@


1.132
log
@Add an extra flags argument to uvm_io(), to specify whether we want to fix
the protection of the memory mapping we're doing I/O on, or if we want to
leave them as they are. This should only be necessary for breakpoint
insertion in code, so we'll only use it for ptrace requests.

Initially from art@@ after discussion with kettenis@@ millert@@ and I,
tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.131 2005/09/25 20:48:23 miod Exp $	*/
a1829 2
int nsensors = 0;
struct sensors_head sensors = SLIST_HEAD_INITIALIZER(&sensors);
@


1.131
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@

[complete diff this time]
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.130 2005/09/20 23:01:06 deraadt Exp $	*/
d1471 1
a1471 1
	if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio)) != 0)
d1528 1
a1528 1
		if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio)) != 0)
d1550 1
a1550 1
		if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio)) != 0)
@


1.130
log
@unbreak tree, how did you do that miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.128 2005/07/31 04:36:51 deraadt Exp $	*/
d463 1
a463 1
		for (CPU_INFO_FOREACH(cii, ci)) {
d1905 1
a1905 1
	for (CPU_INFO_FOREACH(cii, ci)) {
@


1.129
log
@Turn CPU_INFO_FOREACH into a real construct, like all queue(3) iterators,
instead of the contents of a for() loop. No functional change.
From the m88k SMP tree; ok art@@ deraadt@@
@
text
@d463 1
a463 1
		CPU_INFO_FOREACH(cii, ci) {
d1905 1
a1905 1
	CPU_INFO_FOREACH(cii, ci) {
@


1.128
log
@do not allocate huge kinfo_proc2 and eproc structures on the stack.
allocate them on startup if needed, and free them when done.
discussion with pascoe, tested by dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.127 2005/06/08 22:33:27 millert Exp $	*/
d463 1
a463 1
		for (CPU_INFO_FOREACH(cii, ci)) {
d1905 1
a1905 1
	for (CPU_INFO_FOREACH(cii, ci)) {
@


1.127
log
@Add KERN_CPTIME2 on systems where __HAVE_CPUINFO is defined, exposes
spc_cp_time member of struct schedstate_percpu (per-cpu stats).
From art@@ during the hackathon.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.126 2005/06/04 05:10:40 tedu Exp $	*/
d1021 2
a1022 2
	struct kinfo_proc2 kproc2;
	struct eproc eproc;
d1040 1
d1048 1
d1107 2
a1108 1
			return (EINVAL);
d1112 1
a1112 1
				fill_eproc(p, &eproc);
d1117 2
a1118 2
					return (error);
				error = copyout((caddr_t)&eproc,
d1120 1
a1120 1
				    sizeof(eproc));
d1122 1
a1122 1
					return (error);
d1129 1
a1129 1
				fill_kproc2(p, &kproc2);
d1134 2
a1135 2
				error = copyout(&kproc2, dp,
				    min(sizeof(kproc2), elem_size));
d1137 1
a1137 1
					return (error);
d1152 4
a1155 2
		if (needed > *sizep)
			return (ENOMEM);
d1160 6
a1165 1
	return (0);
@


1.126
log
@let the arc4random sysctl write out up to 256 bytes at once.
ok + input deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.125 2005/05/24 21:11:48 tedu Exp $	*/
d104 1
d292 1
d555 5
d1880 27
@


1.125
log
@add a new field to vm_space and use it to track the number of anon
pages a process uses.  this is now the userland "data size" value.
ok art deraadt tdeval.  thanks testers.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.124 2005/03/10 17:26:10 tedu Exp $	*/
d401 12
a412 2
	case KERN_ARND:
		return (sysctl_rdint(oldp, oldlenp, newp, arc4random()));
@


1.124
log
@split out uidinfo from kern_proc.c private, use it to store lock count,
restrict lock count per uid to a global limit, add sysctl to adjust limit.
this prevents a user from creating too many locks.  problem noticed
by devon o'dell.  ok deraadt miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.123 2004/12/24 17:28:13 miod Exp $	*/
d1168 1
a1168 1
		ep->e_vm.vm_dsize = vm->vm_dsize;
d1300 1
a1300 1
		ki->p_vm_dsize = vm->vm_dsize;
@


1.123
log
@Do not provide the KERN_EMUL, KERN_EVCOUNT, KERN_INTRCNT, KERN_PROC* and
HW_SENSORS sysctl trees if option SMALL_KERNEL.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.122 2004/11/26 21:23:06 miod Exp $	*/
d269 1
d541 2
@


1.122
log
@Kill __HAVE_EVCOUNT, now that all architectures provide them.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.121 2004/10/14 17:10:17 mickey Exp $	*/
d357 1
d364 1
d515 1
a517 1
#ifndef SMALL_KERNEL
a520 1
#endif
d524 1
d530 1
d534 1
d600 1
d604 1
d987 2
d1138 2
d1198 2
d1573 2
d1792 2
d1858 2
@


1.121
log
@a more reasonable limit for the stackgap_random; found by openbsd@@hunger.hu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.120 2004/09/23 21:08:54 deraadt Exp $	*/
a67 1
#ifdef __HAVE_EVCOUNT
a68 1
#endif
a285 1
#ifdef __HAVE_EVCOUNT
a286 1
#endif
a527 1
#ifdef __HAVE_EVCOUNT
a530 1
#endif
a1780 1
#ifdef __HAVE_EVCOUNT
a1781 35
#else
	extern int intrcnt[], eintrcnt[];
	extern char intrnames[], eintrnames[];
	char *intrname;
	int nintr, i;

	nintr = (off_t)(eintrcnt - intrcnt);

	if (name[0] != KERN_INTRCNT_NUM) {
		if (namelen != 2)
			return (ENOTDIR);
		if (name[1] < 0 || name[1] >= nintr)
			return (EINVAL);
		i = name[1];
	}

	switch (name[0]) {
	case KERN_INTRCNT_NUM:
		return (sysctl_rdint(oldp, oldlenp, NULL, nintr));
		break;
	case KERN_INTRCNT_CNT:
		return (sysctl_rdquad(oldp, oldlenp, NULL, intrcnt[i]));
	case KERN_INTRCNT_NAME:
		intrname = intrnames;
		while (i > 0) {
			intrname += strlen(intrname) + 1;
			i--;
			if (intrname > eintrnames)
				return (EINVAL);
		}
		return (sysctl_rdstring(oldp, oldlenp, NULL, intrname));
	default:
		return (EOPNOTSUPP);
	}
#endif
@


1.120
log
@change KERN_INTRCNT_CNT to return a quad; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.119 2004/09/15 17:50:33 grange Exp $	*/
d486 1
a486 1
		    !powerof2(stackgap) || stackgap >= 256 * 1024 * 1024)
@


1.119
log
@Check for num < 0 in sysctl_sensors(); from Patrick Latifi.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.118 2004/07/28 17:15:12 tholo Exp $	*/
d1810 1
a1810 1
		return (sysctl_rdint(oldp, oldlenp, NULL, intrcnt[i]));
@


1.118
log
@This touches only MI code, and adds new time keeping code.  The
code is all conditionalized on __HAVE_TIMECOUNTER, and not
enabled on any platforms.

adjtime(2) support exists, courtesy of nordin@@, sysctl(2) support
and a concept of quality for each time source attached exists.

High quality time sources exists for PIIX4 ACPI timer as well as
some AMD power management chips.  This will have to be redone
once we actually add ACPI support (at that time we need to use
the ACPI interfaces to get at these clocks).

ok art@@ ken@@ miod@@ jmc@@ and many more
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.117 2004/06/28 01:34:46 aaron Exp $	*/
d1840 1
a1840 1
	if (num >= nsensors)
@


1.117
log
@Add new, generic ``evcount'' event counter API to the kernel.  From art@@,
with modifications from me.  Includes code for generic interrupt counter
fetching via sysctl.  deraadt@@ tholo@@ drahn@@ millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.116 2004/06/25 08:41:19 art Exp $	*/
d65 3
d291 3
d535 5
@


1.116
log
@Instead of accessing ci_dev (that's an MI field), provide a marco that
translates a cpu_info structure into a human-readable cpu number.

drahn@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.115 2004/06/24 21:00:03 millert Exp $	*/
d65 3
d285 3
d526 5
d1776 3
d1812 1
@


1.115
log
@Remove the 8 page limit for sysctl_proc_args after discussing with Theo.
Add trivial support for passing a NULL pointer for the argv buffer;
currently just returns ARG_MAX for KERN_PROC_ARGV and KERN_PROC_ENV.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.114 2004/06/20 03:04:15 art Exp $	*/
d1337 1
a1337 1
			ki->p_cpuid = p->p_cpu->ci_dev.dv_unit;
@


1.114
log
@Another merge error from smp branch.
Found by otto@@drijf.net
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.113 2004/06/16 18:14:12 deraadt Exp $	*/
d1381 8
a1435 6

	if (limit > 8 * PAGE_SIZE) {
		/* Don't allow a denial of service. */
		error = E2BIG;
		goto out;
	}
@


1.113
log
@export cpu# instead of apid#; art ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.112 2004/06/13 21:49:26 niklas Exp $	*/
d432 1
a432 1
#ifdef MULTIPROCESSOR
@


1.112
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1337 1
a1337 1
			ki->p_cpuid = p->p_cpu->ci_cpuid;
@


1.111
log
@Merge in a piece of the SMP branch into HEAD.

Introduce the cpu_info structure, p_cpu field in struct proc and global
scheduling context and various changed code to deal with this. At the
moment no architecture uses this stuff yet, but it will allow us slow and
controlled migration to the new APIs.

All new code is ifdef:ed out.

ok deraadt@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.110 2004/06/08 18:09:31 marc Exp $	*/
d432 14
d1334 5
@


1.110
log
@pull ncpus support from smp tree into main branch.
remove alpha specific definition of ncpus.
OK (and tested on alpha) deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.109 2004/05/27 08:19:59 tedu Exp $	*/
d1264 3
d1268 1
@


1.109
log
@apm restores perflevel after resume; some cpus are forgetful.
update cpu even with 100 -> 100 setperf changes, in case saved value
has gotten out of sync.  from grange@@ ok deraadt@@ grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.108 2004/05/23 19:41:23 tedu Exp $	*/
d539 1
a539 1
		return (sysctl_rdint(oldp, oldlenp, newp, 1));	/* XXX */
@


1.108
log
@bad stuff escaped by accident
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.106 2004/04/19 22:52:33 tedu Exp $	*/
d103 1
a527 2
	static int perflevel = 100;
	int operflevel;
a578 1
		operflevel = perflevel;
a581 2
		if (perflevel == operflevel)
			return (0);
d586 4
a589 1
		return (cpu_setperf(perflevel));
@


1.107
log
@according to fork1(9), retval is optional.  make it so.
from form@@pdp-11.org.ru via mpech.  ok millert
@
text
@d528 1
d580 1
d584 2
d590 1
a590 4
		if (newp)
			return (cpu_setperf(perflevel));
		else
			return (0);
@


1.106
log
@introduce a new km_page allocator that gets pages from kernel_map using
an interrupt safe thread.
use this as the new backend for mbpool and mclpool, eliminating the mb_map.
introduce a sysctl kern.maxclusters which controls the limit of clusters
allocated.
testing by many people, works everywhere but m68k.  ok deraadt@@

this essentially deprecates the NMBCLUSTERS option, don't use it.
this should reduce pressure on the kmem_map and the uvm reserve of static
map entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.105 2004/04/15 00:22:42 tedu Exp $	*/
a527 1
	int operflevel;
a578 1
		operflevel = perflevel;
a581 2
		if (perflevel == operflevel)
			return (0);
d586 4
a589 1
		return (cpu_setperf(perflevel));
@


1.105
log
@rework access to emulations slightly in an effort to both merge and
separate exec format from emulation.  consistent naming of freebsd emuls.
not much in the way of functional changes yet.
testing and ok deraadt@@ and others along the way.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.104 2004/02/29 12:14:05 weingart Exp $	*/
d93 2
d500 5
@


1.104
log
@Check for negative numbers.

ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.103 2004/02/27 21:46:44 grange Exp $	*/
d1803 1
a1803 1
		return (sysctl_rdint(oldp, oldlenp, newp, nemuls));
d1808 4
a1811 1
	if (name[0] > nemuls || name[0] < 0)
a1812 1
	e = emulsw[name[0] - 1];
@


1.103
log
@Move setperf_prio to the machdep code, requested by deraadt@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.102 2004/02/27 21:15:45 grange Exp $	*/
d581 2
@


1.102
log
@Introduce simple priorities mechanism so that concurrent
hw.setperf handlers don't override each other.
Problem reported and tested by danh@@.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.101 2004/02/15 11:14:45 markus Exp $	*/
a100 1
int setperf_prio = 0;		/* for concurrent handlers */
@


1.101
log
@add sysctl_int_arr() API similar to BSD/OS; ok itojun, deraadt, miod, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.100 2004/02/15 02:45:46 tedu Exp $	*/
d101 1
@


1.100
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.99 2004/02/14 15:09:22 grange Exp $	*/
d679 20
@


1.99
log
@Simplify hw.{cpuspeed,setperf} api moving all the sysctl stuff
from the underlying callbacks.

Testing hppa mickey@@, ppc drahn@@
Ok markus@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.98 2004/01/07 21:51:30 millert Exp $	*/
d1531 2
d1534 2
a1535 1
			sdk->ds_xfer = dk->dk_xfer;
d1537 2
a1538 1
			sdk->ds_bytes = dk->dk_bytes;
d1553 2
d1556 2
a1557 1
			sdk->ds_xfer = dk->dk_xfer;
d1559 2
a1560 1
			sdk->ds_bytes = dk->dk_bytes;
@


1.98
log
@Add p_rlim_rss_cur for ps "lim" field.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.97 2004/01/07 21:30:59 markus Exp $	*/
d99 2
a100 2
int (*cpu_cpuspeed)(void *, size_t *, void *, size_t);
int (*cpu_setperf)(void *, size_t *, void *, size_t);
d519 3
d566 4
a569 1
		return (cpu_cpuspeed(oldp, oldlenp, newp, newlen));
d573 9
a581 1
		return (cpu_setperf(oldp, oldlenp, newp, newlen));
@


1.97
log
@no kern_watchdog for SMALL_KERNEL; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.96 2004/01/07 19:34:03 millert Exp $	*/
d1236 2
@


1.96
log
@Unbreak KERN_PROC_KTHREAD.  Explicitly list KERN_PROC_KTHREAD in
the sysctl_doproc() switch so it does not match the default case
(EINVAL).  deraadt@@ OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.95 2004/01/07 03:37:57 millert Exp $	*/
d490 1
d494 1
@


1.95
log
@Add p_emul to kinfo_proc2 for ps
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.94 2004/01/07 02:13:51 millert Exp $	*/
d998 3
@


1.94
log
@Implement KERN_PROC2 sysctl from NetBSD.  This will allow us to
have ps and friends be independent of changes in struct proc et al
in the kernel.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.93 2003/12/18 23:46:20 tedu Exp $	*/
d1193 1
@


1.93
log
@add new hw sysctls, cpuspeed and setperf to control cpu frequency.
convert longrun support to use new sysctls.
add enhanced speedstep support, based on code by Michael Eriksson.
idea, help testing & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.92 2003/11/23 20:17:14 millert Exp $	*/
d84 2
d267 1
d347 2
a348 1
		return (sysctl_doproc(name + 1, namelen - 1, oldp, oldlenp));
d919 1
a919 5
	register struct proc *p;
	register struct kinfo_proc *dp = (struct kinfo_proc *)where;
	register int needed = 0;
	int buflen = where != NULL ? *sizep : 0;
	int doingzomb;
d921 25
a945 5
	int error = 0;

	if (namelen != 2 && !(namelen == 1 &&
	    (name[0] == KERN_PROC_ALL || name[0] == KERN_PROC_KTHREAD)))
		return (EINVAL);
a956 1
		 * do by session.
d958 1
a958 1
		switch (name[0]) {
d962 1
a962 1
			if (p->p_pid != (pid_t)name[1])
d968 7
a974 1
			if (p->p_pgrp->pg_id != (pid_t)name[1])
d981 1
a981 1
			    p->p_session->s_ttyp->t_dev != (dev_t)name[1])
d986 1
a986 1
			if (p->p_ucred->cr_uid != (uid_t)name[1])
d991 1
a991 1
			if (p->p_cred->p_ruid != (uid_t)name[1])
d999 2
d1002 33
a1034 12
		if (buflen >= sizeof(struct kinfo_proc)) {
			fill_eproc(p, &eproc);
			error = copyout((caddr_t)p, &dp->kp_proc,
					sizeof(struct proc));
			if (error)
				return (error);
			error = copyout((caddr_t)&eproc, &dp->kp_eproc,
					sizeof(eproc));
			if (error)
				return (error);
			dp++;
			buflen -= sizeof(struct kinfo_proc);
a1035 1
		needed += sizeof(struct kinfo_proc);
d1043 1
a1043 1
		*sizep = (caddr_t)dp - where;
d1109 159
@


1.92
log
@Check correct array index KERN_VNODE; from Alistair Kerr
Closes PR 3571 as per on icb.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.91 2003/10/26 22:31:23 tedu Exp $	*/
d97 3
d554 8
@


1.91
log
@per deraadt@@ request, don't permit insanely large stackgap values.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.90 2003/10/24 19:05:21 tedu Exp $	*/
d153 1
a153 1
		if (name[2] == KERN_VNODE)	/* XXX */
@


1.90
log
@refactor stackgap sysctl.  prompted by a bug report from Michael Coulter.
ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.89 2003/08/23 20:02:59 tedu Exp $	*/
d450 1
a450 1
		    !powerof2(stackgap))
@


1.89
log
@remove native emulations from emulsw.  you can't change them and probably
aren't interested, so keep them out of the sysctl.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.88 2003/08/23 19:21:15 deraadt Exp $	*/
d247 1
a247 1
	int error, level, inthostid, oldsgap;
d442 4
a445 3
		oldsgap = stackgap_random;

		error = sysctl_int(oldp, oldlenp, newp, newlen, &stackgap_random);
d449 2
a450 4
		if ((stackgap_random < ALIGNBYTES && stackgap_random != 0) ||
		    !powerof2(stackgap_random) ||
		    stackgap_random > PAGE_SIZE * 2) {
			stackgap_random = oldsgap;
d452 2
a453 2
		}
		return (error);
@


1.88
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.87 2003/08/23 18:12:20 fgsch Exp $	*/
d1548 5
a1552 9
		if (e->e_flags & EMUL_NATIVE)
			return (sysctl_rdint(oldp, oldlenp, newp, 1));
		else {
			enabled = (e->e_flags & EMUL_ENABLED);
			error = sysctl_int(oldp, oldlenp, newp, newlen,
			    &enabled);
			e->e_flags = (enabled & EMUL_ENABLED);
			return (error);
		}
@


1.87
log
@allow disabling a emul after enabling it; tedu@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.85 2003/08/15 20:32:18 tedu Exp $	*/
d311 2
a312 2
		if ((securelevel > 0 || level < -1)
		    && level < securelevel && p->p_pid != 1)
@


1.86
log
@emulation is now controlled by sysctl.  changes:
add e_flags to struct emul.  this stores on/off and native flags.
check for emul enabled in check_exec().  gather all the emuls into a
emulsw so a sysctl can find them.  create sysctl.  move maxhdrsiz calcualation
into init_main so it cleans up sys_execve codepath.  teach sysctl utility
to grok kern.emul hierarchy.
requested and ok deraadt@@  some comments from mickey@@
@
text
@d1554 1
a1554 1
			e->e_flags |= (enabled & EMUL_ENABLED);
@


1.85
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.84 2003/08/06 21:08:07 millert Exp $	*/
d95 1
d272 1
d487 3
d1523 37
@


1.84
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.83 2003/06/10 21:50:26 mickey Exp $	*/
d137 1
a137 1
	    (error = suser(p->p_ucred, &p->p_acflag)))
@


1.83
log
@debug0 and debug1 are defined elsewhere -- make 'em extern here
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.82 2003/06/02 23:28:06 millert Exp $	*/
d1226 1
a1226 1
		*oldlenp += 1;;
@


1.82
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.81 2003/05/03 21:14:59 deraadt Exp $	*/
d557 2
a558 1
struct ctldebug debug0, debug1, debug2, debug3, debug4;
@


1.81
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.80 2003/04/25 20:06:41 grange Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.80
log
@sysctl front-end for the hardware monitoring sensors. This adds
new node hw.sensors; information from the sensors can be obtained
via hw.sensors.n, where n is a sensor number. All values are read only
for now. Documentation and back-end drivers are comming.
Tested by henning@@ and millert@@. Four oks from henning@@ and one
from millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.79 2003/01/21 16:59:23 markus Exp $	*/
d1287 1
a1287 1
			l += sprintf(disknames + l, "%s,",
d1289 1
@


1.79
log
@add kern.watchdog sysctl and generic watchdog interface;
based on feedback and discussions with mickey, henric, fgsch and jakob.
ok art@@, mickey@@, jakob@@, henric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.78 2003/01/15 23:41:56 millert Exp $	*/
d68 1
d98 1
d511 2
a512 2
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
d548 3
d1496 24
@


1.78
log
@Fix two minor nits; deraadt@@ OK
o Avoid taking the address of an array when we just want a pointer
o Use &array[1] not array + 1
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.77 2003/01/13 06:04:16 art Exp $	*/
d272 1
d484 3
@


1.77
log
@Sysctls for fetching intrcnt.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.76 2002/12/17 23:11:31 millert Exp $	*/
d146 1
a146 1
	error = copyin(SCARG(uap, name), &name,
d205 1
a205 1
	error = (*fn)(name + 1, SCARG(uap, namelen) - 1, SCARG(uap, old),
@


1.76
log
@Make SysV-style shared memory and semaphore limits sysctl'able.
Instead of allocating a static amount of memory for the data
structures via valloc() in allocsys(), allocate things dynamically
using pool(9) when possible and malloc(9) when not.  The various
members of struct seminfo and struct shminfo are in kern.seminfo
and kern.shminfo respectively (not all members of kern.seminfo are
changable).

The data structures used still leave something to be desired but
things are not made worse in that respect by this commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.75 2002/09/01 11:35:52 art Exp $	*/
d96 1
d271 1
d481 2
d1450 38
@


1.75
log
@Oppsie. Remove my debugging code.
noted by tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.74 2002/08/23 15:33:12 art Exp $	*/
d259 16
a274 5
	if (namelen != 1 && !(name[0] == KERN_PROC || name[0] == KERN_PROF ||
	    name[0] == KERN_MALLOCSTATS || name[0] == KERN_TTY ||
	    name[0] == KERN_POOL || name[0] == KERN_SYSVIPC_INFO ||
	    name[0] == KERN_PROC_ARGS))
		return (ENOTDIR);		/* overloaded */
d469 10
d1419 5
a1423 1
				bcopy(&sema[i], &semsi->semids[i], dssize);
d1428 5
a1432 1
				bcopy(&shmsegs[i], &shmsi->shmids[i], dssize);
@


1.74
log
@Use LIST_ macros for the list of all struct file.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.73 2002/07/06 19:14:20 nordin Exp $	*/
a314 1
		splassert(IPL_NET);
@


1.73
log
@Remove kernel support for NTP. ok deraadt@@ and tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.72 2002/06/24 11:09:01 art Exp $	*/
d843 1
a843 1
	for (fp = filehead.lh_first; fp != 0; fp = fp->f_list.le_next) {
@


1.72
log
@Redo the logic of reading of proc arguments to be more readable.
kjell@@ says that it fixes his problems, noone else responded.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.71 2002/06/11 11:14:29 beck Exp $	*/
a357 2
	case KERN_NTPTIME:
		return (sysctl_ntptime(oldp, oldlenp));
@


1.71
log
@kernel changes to make asymmetric crypto work in userland
- modify getfeat to return something more useful to us on devices
  (like lofn and everything else until jason fixes it) that can't
  do rsa stuff, etc and can only do mod_exp..
- error handling fixes so we correctly fail to software when we can't
  deal with a particular key size
- add sysctl kern.userasymcrypto to turn on/off userland asymmetric crypto
  via /dev/crypto - 1 == on, 0 == off, default is off
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.70 2002/06/09 05:46:15 art Exp $	*/
d1103 2
a1104 1
	limit = *oldlenp;
d1107 6
d1114 12
d1127 1
d1149 3
d1156 3
a1158 1
		len = round_page((vaddr_t)varg) - ((vaddr_t)varg);
d1171 2
a1172 3
		for (vstrlen = 0; vstrlen < (len - 1); vstrlen++) {
			if (buf[vstrlen] == '\0') {
				vstrlen++;
d1174 6
a1179 1
			}
d1185 1
a1186 1
		*oldlenp += vstrlen;
d1188 9
a1196 3
		/* Don't allow a denial of service. */
		if (vstrlen == len && len == 4 * PAGE_SIZE) {
			error = E2BIG;	/* XXX - ? */
d1198 2
a1199 1
		}
d1206 1
a1206 1
	if (*oldlenp == limit) {
@


1.70
log
@add struct pstats to struct eproc
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.69 2002/06/09 04:27:25 angelos Exp $	*/
d254 1
d451 3
@


1.69
log
@KERN_MBSTAT
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.68 2002/06/08 23:35:35 angelos Exp $	*/
d963 1
a963 3
fill_eproc(p, ep)
	register struct proc *p;
	register struct eproc *ep;
d965 1
a965 1
	register struct tty *tp;
d976 2
d979 1
a979 1
		register struct vmspace *vm = p->p_vmspace;
d981 1
d986 3
@


1.68
log
@TTYCOUNT and NUMVNODES.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.67 2002/06/08 23:17:22 angelos Exp $	*/
d67 1
d333 3
@


1.67
log
@Add read-only KERN_NFILES (number of open files).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.66 2002/06/08 22:24:47 art Exp $	*/
d91 1
d282 4
@


1.66
log
@Sysctl for getting process arguments and environment.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.65 2002/05/15 23:17:53 art Exp $	*/
d279 2
@


1.65
log
@Implement splassert() for sparc - a tool for finding problems related to
spl handling (already found 3 problems).

Man page in a few seconds.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.64 2002/03/14 20:31:31 mickey Exp $	*/
d66 1
d93 1
d255 1
a255 1
	/* all sysctl names at this level are terminal */
d258 2
a259 1
	    name[0] == KERN_POOL || name[0] == KERN_SYSVIPC_INFO))
d306 1
d320 3
d1000 164
@


1.64
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.63 2002/03/14 19:42:54 mickey Exp $	*/
d436 3
@


1.63
log
@version[] is externed in the systm.h and give it some const
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.62 2002/03/01 02:52:51 provos Exp $	*/
a243 1
	extern char ostype[], osrelease[], osversion[];
@


1.62
log
@sysctl for cryptodevallowsoft - /dev/crypto will allow the software engine
to be used if there are no hardware cards.  mostly for debugging and
regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.61 2002/02/23 08:11:05 deraadt Exp $	*/
d244 1
a244 1
	extern char ostype[], osrelease[], osversion[], version[];
d717 1
a717 1
	char *str;
d768 2
a769 1
	void *newp, *sp;
@


1.61
log
@sysctl kern.usercrypto
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.60 2001/11/28 13:47:39 art Exp $	*/
d251 1
d433 3
@


1.60
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.59 2001/11/06 19:53:20 miod Exp $	*/
d249 3
d428 4
@


1.60.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.60 2001/11/28 13:47:39 art Exp $	*/
a65 2
#include <sys/exec.h>
#include <sys/mbuf.h>
a89 1
extern  long numvnodes;
a91 1
int sysctl_proc_args(int *, u_int, void *, size_t *, struct proc *);
d244 1
a248 4
#ifdef CRYPTO
	extern int usercrypto;
	extern int cryptodevallowsoft;
#endif
d250 1
a250 1
	/* all sysctl names at this level are terminal except a ton of them */
d253 1
a253 2
	    name[0] == KERN_POOL || name[0] == KERN_SYSVIPC_INFO ||
	    name[0] == KERN_PROC_ARGS))
a272 6
	case KERN_NFILES:
		return (sysctl_rdint(oldp, oldlenp, newp, nfiles));
	case KERN_TTYCOUNT:
		return (sysctl_rdint(oldp, oldlenp, newp, tty_count));
	case KERN_NUMVNODES:
		return (sysctl_rdint(oldp, oldlenp, newp, numvnodes));
a299 1
		splassert(IPL_NET);
a312 3
	case KERN_PROC_ARGS:
		return (sysctl_proc_args(name + 1, namelen - 1, oldp, oldlenp,
		     p));
a314 3
	case KERN_MBSTAT:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &mbstat,
		    sizeof(mbstat)));
a425 10
#ifdef CRYPTO
	case KERN_USERCRYPTO:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &usercrypto));
	case KERN_CRYPTODEVALLOWSOFT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &cryptodevallowsoft));
#endif
	case KERN_SPLASSERT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &splassert_ctl));
d706 1
a706 1
	const char *str;
d757 1
a757 2
	void *newp;
	const void *sp;
d931 3
a933 1
fill_eproc(struct proc *p, struct eproc *ep)
d935 1
a935 1
	struct tty *tp;
a945 2
		bzero(&ep->e_pstats, sizeof(ep->e_pstats));
		ep->e_pstats_valid = 0;
d947 1
a947 1
		struct vmspace *vm = p->p_vmspace;
a948 1
		PHOLD(p);	/* need for pstats */
a952 3
		ep->e_pstats = *p->p_stats;
		ep->e_pstats_valid = 1;
		PRELE(p);
a978 164
}

int
sysctl_proc_args(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    struct proc *cp)
{
	struct proc *vp;
	pid_t pid;
	int op;
	struct ps_strings pss;
	struct iovec iov;
	struct uio uio;
	int error;
	size_t limit;
	int cnt;
	char **rargv, **vargv;		/* reader vs. victim */
	char *rarg, *varg;
	char *buf;

	if (namelen > 2)
		return (ENOTDIR);
	if (namelen < 2)
		return (EINVAL);

	pid = name[0];
	op = name[1];

	switch (op) {
	case KERN_PROC_ARGV:
	case KERN_PROC_NARGV:
	case KERN_PROC_ENV:
	case KERN_PROC_NENV:
		break;
	default:
		return (EOPNOTSUPP);
	}

	if ((vp = pfind(pid)) == NULL)
		return (ESRCH);

	if (P_ZOMBIE(vp) || (vp->p_flag & P_SYSTEM))
		return (EINVAL);

	/* Exiting - don't bother, it will be gone soon anyway */
	if ((vp->p_flag & P_WEXIT))
		return (ESRCH);

	/* Execing - danger. */
	if ((vp->p_flag & P_INEXEC))
		return (EBUSY);

	vp->p_vmspace->vm_refcnt++;	/* XXX */
	buf = malloc(PAGE_SIZE, M_TEMP, M_WAITOK);

	iov.iov_base = &pss;
	iov.iov_len = sizeof(pss);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;	
	uio.uio_offset = (off_t)PS_STRINGS;
	uio.uio_resid = sizeof(pss);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = cp;

	if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio)) != 0)
		goto out;

	if (op == KERN_PROC_NARGV) {
		error = sysctl_rdint(oldp, oldlenp, NULL, pss.ps_nargvstr);
		goto out;
	}
	if (op == KERN_PROC_NENV) {
		error = sysctl_rdint(oldp, oldlenp, NULL, pss.ps_nenvstr);
		goto out;
	}

	if (op == KERN_PROC_ARGV) {
		cnt = pss.ps_nargvstr;
		vargv = pss.ps_argvstr;
	} else {
		cnt = pss.ps_nenvstr;
		vargv = pss.ps_envstr;
	}

	limit = *oldlenp;
	*oldlenp = 0;

	rargv = oldp;
	rarg = (char *)(rargv + cnt + 1);

	while (cnt > 0 && *oldlenp < limit) {
		size_t len, vstrlen;

		/* Write to readers argv */
		if ((error = copyout(&rarg, rargv, sizeof(rarg))) != 0)
			goto out;

		/* read the victim argv */
		iov.iov_base = &varg;
		iov.iov_len = sizeof(varg);
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(vaddr_t)vargv;
		uio.uio_resid = sizeof(varg);
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_READ;
		uio.uio_procp = cp;
		if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio)) != 0)
			goto out;

		/*
		 * read the victim arg. We must jump through hoops to avoid
		 * crossing a page boundary too much and returning an error.
		 */
		len = round_page((vaddr_t)varg) - ((vaddr_t)varg);
		iov.iov_base = buf;
		iov.iov_len = len;
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(vaddr_t)varg;
		uio.uio_resid = len;
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_READ;
		uio.uio_procp = cp;
		if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio)) != 0)
			goto out;

		for (vstrlen = 0; vstrlen < (len - 1); vstrlen++) {
			if (buf[vstrlen] == '\0') {
				vstrlen++;
				break;
			}
		}

		if ((error = copyout(buf, rarg, vstrlen)) != 0)
			goto out;

		rarg += vstrlen;
		*oldlenp += vstrlen;

		/* Don't allow a denial of service. */
		if (vstrlen == len && len == 4 * PAGE_SIZE) {
			error = E2BIG;	/* XXX - ? */
			goto out;
		}

		vargv++;
		rargv++;
		cnt--;
	}

	if (*oldlenp == limit) {
		error = ENOMEM;
		goto out;
	}

	/* Write the terminating null */
	rarg = NULL;
	error = copyout(&rarg, rargv, sizeof(rarg));

out:
	uvmspace_free(vp->p_vmspace);
	free(buf, M_TEMP);
	return (error);
@


1.60.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.60.2.1 2002/06/11 03:29:40 art Exp $	*/
a253 1
	extern int userasymcrypto;
d314 1
d357 2
a449 3
	case KERN_USERASYMCRYPTO:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &userasymcrypto));
d841 1
a841 1
	LIST_FOREACH(fp, &filehead, f_list) {
d1099 1
a1099 2
	/* -1 to have space for a terminating NUL */
	limit = *oldlenp - 1;
a1101 6
	if (limit > 8 * PAGE_SIZE) {
		/* Don't allow a denial of service. */
		error = E2BIG;
		goto out;
	}

a1102 12

	/*
	 * *oldlenp - number of bytes copied out into readers buffer.
	 * limit - maximal number of bytes allowed into readers buffer.
	 * rarg - pointer into readers buffer where next arg will be stored.
	 * rargv - pointer into readers buffer where the next rarg pointer
	 *  will be stored.
	 * vargv - pointer into victim address space where the next argument
	 *  will be read.
	 */

	/* space for cnt pointers and a NULL */
a1103 1
	*oldlenp += (cnt + 1) * sizeof(char **);
a1124 3
		if (varg == NULL)
			break;

d1129 1
a1129 3
more:
		len = PAGE_SIZE - (((vaddr_t)varg) & PAGE_MASK);
		/* leave space for the terminating NUL */
d1142 3
a1144 2
		for (vstrlen = 0; vstrlen < len; vstrlen++) {
			if (buf[vstrlen] == '\0')
d1146 1
a1146 6
		}

		/* Don't overflow readers buffer. */
		if (*oldlenp + vstrlen + 1 >= limit) {
			error = ENOMEM;
			goto out;
d1152 1
a1153 1
		rarg += vstrlen;
d1155 4
a1158 4
		/* The string didn't end in this page? */
		if (vstrlen == len) {
			varg += vstrlen;
			goto more;
a1160 7
		/* End of string. Terminate it with a NUL */
		buf[0] = '\0';
		if ((error = copyout(buf, rarg, 1)) != 0)
			goto out;
		*oldlenp += 1;;
		rarg += 1;

d1166 1
a1166 1
	if (*oldlenp >= limit) {
@


1.60.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a67 1
#include <sys/sensors.h>
a95 2
int sysctl_intrcnt(int *, u_int, void *, size_t *);
int sysctl_sensors(int *, u_int, void *, size_t *, void *, size_t);
d145 1
a145 1
	error = copyin(SCARG(uap, name), name,
d204 1
a204 1
	error = (*fn)(&name[1], SCARG(uap, namelen) - 1, SCARG(uap, old),
d259 5
a263 18
	if (namelen != 1) {
		switch (name[0]) {
		case KERN_PROC:
		case KERN_PROF:
		case KERN_MALLOCSTATS:
		case KERN_TTY:
		case KERN_POOL:
		case KERN_PROC_ARGS:
		case KERN_SYSVIPC_INFO:
		case KERN_SEMINFO:
		case KERN_SHMINFO:
		case KERN_INTRCNT:
		case KERN_WATCHDOG:
			break;
		default:
			return (ENOTDIR);	/* overloaded */
		}
	}
a457 15
#ifdef SYSVSEM
	case KERN_SEMINFO:
		return (sysctl_sysvsem(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
#ifdef SYSVSHM
	case KERN_SHMINFO:
		return (sysctl_sysvshm(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
	case KERN_INTRCNT:
		return (sysctl_intrcnt(name + 1, namelen - 1, oldp, oldlenp));
	case KERN_WATCHDOG:
		return (sysctl_wdog(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
d480 2
a481 2
	/* all sysctl names at this level except sensors are terminal */
	if (name[0] != HW_SENSORS && namelen != 1)
a516 3
	case HW_SENSORS:
		return (sysctl_sensors(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
d1253 1
a1253 1
			snprintf(disknames + l, tlen - l, "%s,",
a1254 1
			l += strlen(disknames + l);
d1398 1
a1398 5
				if (sema[i] != NULL)
					bcopy(sema[i], &semsi->semids[i],
					    dssize);
				else
					bzero(&semsi->semids[i], dssize);
d1403 1
a1403 5
				if (shmsegs[i] != NULL)
					bcopy(shmsegs[i], &shmsi->shmids[i],
					    dssize);
				else
					bzero(&shmsi->shmids[i], dssize);
a1416 62

int
sysctl_intrcnt(int *name, u_int namelen, void *oldp, size_t *oldlenp)
{
	extern int intrcnt[], eintrcnt[];
	extern char intrnames[], eintrnames[];
	char *intrname;
	int nintr, i;

	nintr = (off_t)(eintrcnt - intrcnt);

	if (name[0] != KERN_INTRCNT_NUM) {
		if (namelen != 2)
			return (ENOTDIR);
		if (name[1] < 0 || name[1] >= nintr)
			return (EINVAL);
		i = name[1];
	}

	switch (name[0]) {
	case KERN_INTRCNT_NUM:
		return (sysctl_rdint(oldp, oldlenp, NULL, nintr));
		break;
	case KERN_INTRCNT_CNT:
		return (sysctl_rdint(oldp, oldlenp, NULL, intrcnt[i]));
	case KERN_INTRCNT_NAME:
		intrname = intrnames;
		while (i > 0) {
			intrname += strlen(intrname) + 1;
			i--;
			if (intrname > eintrnames)
				return (EINVAL);
		}
		return (sysctl_rdstring(oldp, oldlenp, NULL, intrname));
	default:
		return (EOPNOTSUPP);
	}
}

int nsensors = 0;
struct sensors_head sensors = SLIST_HEAD_INITIALIZER(&sensors);

int
sysctl_sensors(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	struct sensor *s = NULL;
	int num;

	if (namelen != 1)
		return (ENOTDIR);

	num = name[0];
	if (num >= nsensors)
		return (ENXIO);

	SLIST_FOREACH(s, &sensors, list)
		if (s->num == num)
			break;

	return (sysctl_rdstruct(oldp, oldlenp, newp, s, sizeof(struct sensor)));
}
@


1.59
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.58 2001/09/28 01:42:54 millert Exp $	*/
d190 4
a193 3
		if (dolock)
			if (uvm_vslock(p, SCARG(uap, old), oldlen,
			    VM_PROT_READ|VM_PROT_WRITE) != KERN_SUCCESS) {
d195 1
a195 1
				return EFAULT;
d197 1
@


1.58
log
@sysctl() support for getting the SYSV *info structs and the associated
SYSV structs.  To be used by ipcs(1).  Based on work by simonb@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.57 2001/09/07 22:03:21 angelos Exp $	*/
d60 1
a60 1
#include <vm/vm.h>
a65 2

#include <uvm/uvm_extern.h>
@


1.57
log
@Fix PR 2051, tested by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.56 2001/08/18 03:32:16 art Exp $	*/
d77 10
d253 1
a253 1
	    name[0] == KERN_POOL))
d422 4
d1049 131
@


1.56
log
@Add a possibility to add a random offset to the stack on exec. This makes
it slightly harder to write generic buffer overflows. This doesn't really
give any real security, but it raises the bar for script-kiddies and it's
really cheap.

The range of the random offsets is controlled by the sysctl
kern.stackgap_random (must be a power of 2).

This is disabled by default right now, but we'll set it to a reasonable value
(1024?) soon, after some more testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.55 2001/07/17 20:57:49 deraadt Exp $	*/
d458 5
a462 1
		return (sysctl_rdstring(oldp, oldlenp, newp, disknames));
@


1.55
log
@It takes a greek to put buffer overflow and unterminated string
handling into the kernel.  Stick with the complicated stuff dude,
breaking this simple shit is killing us!
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.54 2001/07/13 23:46:12 mickey Exp $	*/
d233 1
a233 1
	int error, level, inthostid;
d238 1
d398 14
@


1.54
log
@make kern_msgbuf work for sparc, i thought it worked for me before; from miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.53 2001/06/27 07:21:27 art Exp $	*/
d968 1
d979 1
@


1.53
log
@uvm_useracc is not necessary now that uvm_vslock knows how to fail.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.52 2001/06/27 04:49:46 art Exp $	*/
d373 1
a373 1
		    msgbufp->msg_bufs + sizeof(*msgbufp) - 1));
@


1.52
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.51 2001/06/24 16:00:47 art Exp $	*/
a179 3
		/* XXX - obsolete now that vslock returns an error? */
		if (!uvm_useracc(SCARG(uap, old), oldlen, B_WRITE))
			return (EFAULT);
@


1.51
log
@Add a sysctl for getting pool information out of the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.50 2001/06/22 21:32:58 mickey Exp $	*/
a66 1
#if defined(UVM)
a67 1
#endif
a147 1
#if defined(UVM)
a148 3
#else
		fn = vm_sysctl;
#endif
a179 1
#if defined(UVM)
a181 3
#else
		if (!useracc(SCARG(uap, old), oldlen, B_WRITE))
#endif
a185 1
#if defined(UVM)
a190 3
#else
			vslock(SCARG(uap, old), oldlen);
#endif
a196 1
#if defined(UVM)
a197 3
#else
			vsunlock(SCARG(uap, old), savelen);
#endif
a437 1
#if defined(UVM)
a439 4
#else
		return (sysctl_rdint(oldp, oldlenp, newp,
		    ctob(physmem - cnt.v_wire_count)));
#endif
@


1.50
log
@provide sysctl iface for msgbuf; raadtified
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.49 2001/06/03 18:40:23 deraadt Exp $	*/
d262 2
a263 1
	    name[0] == KERN_MALLOCSTATS || name[0] == KERN_TTY))
d416 2
@


1.49
log
@e_wmesg was not initialized in all cases; kirk.russell@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.48 2001/06/03 04:41:33 angelos Exp $	*/
d388 6
@


1.48
log
@Export nprocs.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.47 2001/06/03 03:53:57 angelos Exp $	*/
d954 2
a955 2
	if (p->p_wmesg)
		strncpy(ep->e_wmesg, p->p_wmesg, WMESGLEN);
@


1.47
log
@KERN_FSCALE and KERN_CCPU
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.46 2001/06/03 03:28:41 angelos Exp $	*/
d407 2
@


1.46
log
@Pass struct diskstats through sysctl, deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.45 2001/05/14 08:03:14 angelos Exp $	*/
d81 1
a81 1
extern int nselcoll;
d83 1
d403 4
@


1.45
log
@Use lockmgr locks for kern.malloc.kmemstat and
hw.diskstats/hw.disknames.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.44 2001/05/14 07:18:05 angelos Exp $	*/
d233 1
a233 1
struct disk *diskstats = NULL;
d459 1
a459 1
		    disk_count * sizeof(struct disk)));
d967 2
a968 1
	struct disk *dk, *ndk;
d985 1
a985 1
		diskstats = malloc(disk_count * sizeof(struct disk),
d993 8
a1000 11
			ndk = diskstats + i;
			bcopy(dk, ndk, sizeof(struct disk));

			/* Blank out some of the fields, just paranoid */
			bzero(&ndk->dk_link, sizeof(ndk->dk_link));
			bzero(&ndk->dk_lock, sizeof(struct lock));
			ndk->dk_labelsector = 0;
			ndk->dk_name = NULL;
			ndk->dk_driver = NULL;
			ndk->dk_label = NULL;
			ndk->dk_cpulabel = NULL;
d1011 8
a1018 11
			ndk = diskstats + i;
			bcopy(dk, ndk, sizeof(struct disk));

			/* Blank out some of the fields, just paranoid */
			bzero(&ndk->dk_link, sizeof(ndk->dk_link));
			bzero(&ndk->dk_lock, sizeof(struct lock));
			ndk->dk_labelsector = 0;
			ndk->dk_name = NULL;
			ndk->dk_driver = NULL;
			ndk->dk_label = NULL;
			ndk->dk_cpulabel = NULL;
@


1.44
log
@Disk statistics via sysctl, first pass (locking to come in a few, then
use a separate sub-structure for the statistics)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.43 2001/05/11 06:38:47 angelos Exp $	*/
d84 1
a84 1
int sysctl_diskinit(int);
d90 5
a94 1
struct lock sysctl_lock;
d100 5
a233 1

d389 1
a389 1
		    newp, newlen));
d450 1
a450 1
		err = sysctl_diskinit(0);
d455 1
a455 1
		err = sysctl_diskinit(1);
d963 1
a963 1
sysctl_diskinit(update)
d965 1
d970 3
d985 3
a987 9
		    M_SYSCTL, M_NOWAIT);
		if (diskstats == NULL)
			return ENOMEM;
		disknames = malloc(tlen, M_SYSCTL, M_NOWAIT);
		if (disknames == NULL) {
			free(diskstats, M_SYSCTL);
			diskstats = NULL;
			return ENOMEM;
		}
d1026 1
@


1.43
log
@kmemstats, nselcoll, forkstat, and nchstats structures through
sysctl. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.42 2001/05/07 22:16:35 art Exp $	*/
d59 1
d82 3
d223 3
d253 1
a253 1
			      name[0] == KERN_MALLOCSTATS))
d391 3
d414 1
d441 13
d650 1
a650 1
			/* XXX save & zap NUL terminator while copying */
d948 73
@


1.42
log
@Check for failure now that uvm_vslock can return one. Before this, there was
a risk that we could crash when doing physio/sysctl when the system was
completly out of RAM and swap.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.41 2001/04/06 23:41:02 art Exp $	*/
d63 2
d78 4
d246 1
a246 1
	    name[0] == KERN_MALLOCSTATS))
d268 2
d378 6
@


1.41
log
@Get rid of vm_pmap from struct vmspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.40 2001/03/23 23:36:39 millert Exp $	*/
d167 1
d177 5
a181 1
			uvm_vslock(p, SCARG(uap, old), oldlen, VM_PROT_NONE);
@


1.40
log
@Take vm_pmap out of struct vmspace if we are using UVM since UVM doesn't
use that.  Fixes size mismatch in i386 pmap.new kernel.
This requires that users rebuild libkvm and friends using the new headers
for ps et al to work with a new kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.39 2001/03/16 08:49:09 art Exp $	*/
a871 1
		/* ep->e_vm.vm_pmap = XXX; */
a878 3
#ifndef UVM
		ep->e_vm.vm_pmap = *vm->vm_map.pmap;
#endif
@


1.39
log
@Use a lockmgr lock for keeping down the vslocked memory in sysctl
instead of a home-brew equivalent.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.38 2001/01/31 09:59:51 deraadt Exp $	*/
d880 1
d882 1
@


1.38
log
@add kern.cp_time sysctl, to be used by various things
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.37 2001/01/04 06:04:42 angelos Exp $	*/
d77 2
a78 1
 * Locking and stats
d80 7
a86 5
static struct sysctl_lock {
	int	sl_lock;
	int	sl_want;
	int	sl_locked;
} memlock;
d172 2
a173 6
		while (memlock.sl_lock) {
			memlock.sl_want = 1;
			sleep((caddr_t)&memlock, PRIBIO+1);
			memlock.sl_locked++;
		}
		memlock.sl_lock = 1;
d191 1
a191 5
		memlock.sl_lock = 0;
		if (memlock.sl_want) {
			memlock.sl_want = 0;
			wakeup((caddr_t)&memlock);
		}
@


1.37
log
@sysctl_quad/sysctl_rdquad, and "malloc" node in kern sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.36 2000/06/18 17:59:55 niklas Exp $	*/
d62 1
d236 1
d240 1
a240 1
			      name[0] == KERN_MALLOCSTATS))
d367 3
@


1.36
log
@Mark kernel threads as system processes.  Make ps hide them by default,
show them with -k.  Do not try to show RSS based values for them as they
mess up column alignment.  vmstat -f now shows kernel threads separately
from rforks too.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.35 2000/06/05 11:02:51 art Exp $	*/
d237 2
a238 1
	if (namelen != 1 && !(name[0] == KERN_PROC || name[0] == KERN_PROF))
d362 3
d506 48
@


1.35
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.34 2000/05/06 17:08:14 deraadt Exp $	*/
d718 2
a719 1
	if (namelen != 2 && !(namelen == 1 && name[0] == KERN_PROC_ALL))
d762 5
@


1.34
log
@work around filleproc() vs exit1() race of p_rlimit
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.33 2000/03/16 22:11:03 art Exp $	*/
d809 1
a809 1
	if (p->p_stat == SIDL || p->p_stat == SZOMB) {
@


1.33
log
@Bring in some new UVM code from NetBSD (not current).

 - Introduce a new type of map that are interrupt safe and never allow faults
   in them. mb_map and kmem_map are made intrsafe.
 - Add "access protection" to uvm_vslock (to be passed down to uvm_fault and
   later to pmap_enter).
 - madvise(2) now works.
 - various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.32 2000/03/03 11:46:09 art Exp $	*/
d848 1
a848 1
	ep->e_maxrss = p->p_rlimit[RLIMIT_RSS].rlim_cur;
@


1.32
log
@Use the LIST_FIRST macro to get the head of zombproc list.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.31 2000/03/03 11:31:43 art Exp $	*/
d176 1
a176 1
			uvm_vslock(p, SCARG(uap, old), oldlen);
@


1.31
log
@Use LIST_ macros instead of internal field names to walk the allproc list.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.30 2000/02/22 19:28:03 deraadt Exp $	*/
d780 1
a780 1
		p = zombproc.lh_first;
@


1.30
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.29 1999/06/29 23:51:59 provos Exp $	*/
d720 1
a720 1
	p = allproc.lh_first;
d723 1
a723 1
	for (; p != 0; p = p->p_list.le_next) {
@


1.29
log
@add sysctl kern.arandom to get a random integer. useful when chrooted with
no /dev/arandom.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.28 1999/06/01 08:23:51 art Exp $	*/
d61 1
d353 8
@


1.29.4.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.29 1999/06/29 23:51:59 provos Exp $	*/
d383 1
a383 1
		return (sysctl_rdint(oldp, oldlenp, newp, ncpus));
@


1.29.4.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a60 1
#include <sys/msgbuf.h>
a351 8
	case KERN_MSGBUFSIZE:
		/*
		 * deal with cases where the message buffer has
		 * become corrupted.
		 */
		if (!msgbufp || msgbufp->msg_magic != MSG_MAGIC)
			return (ENXIO);
		return (sysctl_rdint(oldp, oldlenp, newp, msgbufp->msg_bufs));
@


1.29.4.3
log
@Sync with -current
@
text
@d176 1
a176 1
			uvm_vslock(p, SCARG(uap, old), oldlen, VM_PROT_NONE);
d720 1
a720 1
	p = LIST_FIRST(&allproc);
d723 1
a723 1
	for (; p != 0; p = LIST_NEXT(p, p_list)) {
d780 1
a780 1
		p = LIST_FIRST(&zombproc);
@


1.29.4.4
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.41 2001/04/06 23:41:02 art Exp $	*/
a61 1
#include <sys/dkstat.h>
d76 1
a76 2
 * Lock to avoid too many processes vslocking a large amount of memory
 * at the same time.
d78 5
a82 7
struct lock sysctl_lock;

void
sysctl_init()
{
	lockinit(&sysctl_lock, PLOCK|PCATCH, "sysctl", 0, 0);
}
d168 6
a173 2
		if ((error = lockmgr(&sysctl_lock, LK_EXCLUSIVE, NULL, p)) != 0)
			return (error);
d191 5
a195 1
		lockmgr(&sysctl_lock, LK_RELEASE, NULL, p);
a234 1
	extern long cp_time[CPUSTATES];
d237 1
a237 2
	if (namelen != 1 && !(name[0] == KERN_PROC || name[0] == KERN_PROF ||
	    name[0] == KERN_MALLOCSTATS))
a360 6
	case KERN_MALLOCSTATS:
		return (sysctl_malloc(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
	case KERN_CPTIME:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &cp_time,
		    sizeof(cp_time)));
a506 48
 * for an integer-valued sysctl function.
 */
int
sysctl_quad(oldp, oldlenp, newp, newlen, valp)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	int64_t *valp;
{
	int error = 0;

	if (oldp && *oldlenp < sizeof(int64_t))
		return (ENOMEM);
	if (newp && newlen != sizeof(int64_t))
		return (EINVAL);
	*oldlenp = sizeof(int64_t);
	if (oldp)
		error = copyout(valp, oldp, sizeof(int64_t));
	if (error == 0 && newp)
		error = copyin(newp, valp, sizeof(int64_t));
	return (error);
}

/*
 * As above, but read-only.
 */
int
sysctl_rdquad(oldp, oldlenp, newp, val)
	void *oldp;
	size_t *oldlenp;
	void *newp;
	int64_t val;
{
	int error = 0;

	if (oldp && *oldlenp < sizeof(int64_t))
		return (ENOMEM);
	if (newp)
		return (EPERM);
	*oldlenp = sizeof(int64_t);
	if (oldp)
		error = copyout((caddr_t)&val, oldp, sizeof(int64_t));
	return (error);
}

/*
 * Validate parameters and get old / set new parameters
d718 1
a718 2
	if (namelen != 2 && !(namelen == 1 &&
	    (name[0] == KERN_PROC_ALL || name[0] == KERN_PROC_KTHREAD)))
a762 5

		case KERN_PROC_ALL:
			if (p->p_flag & P_SYSTEM)
				continue;
			break;
d809 1
a809 1
	if (p->p_stat == SIDL || P_ZOMBIE(p)) {
d814 1
d822 1
d848 1
a848 1
	ep->e_maxrss = p->p_rlimit ? p->p_rlimit[RLIMIT_RSS].rlim_cur : 0;
@


1.29.4.5
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.29.4.4 2001/05/14 22:32:42 niklas Exp $	*/
a58 1
#include <sys/disk.h>
a62 2
#include <sys/vmmeter.h>
#include <sys/namei.h>
d64 1
d66 1
a75 8
extern struct forkstat forkstat;
extern struct nchstats nchstats;
extern int nselcoll, fscale;
extern struct disklist_head disklist;
extern fixpt_t ccpu;

int sysctl_diskinit(int, struct proc *);

d80 1
a80 5
struct lock sysctl_lock, sysctl_disklock;

#if defined(KMEMSTATS) || defined(DIAGNOSTIC) || defined(FFS_SOFTUPDATES)
struct lock sysctl_kmemlock;
#endif
a85 5
	lockinit(&sysctl_disklock, PLOCK|PCATCH, "sysctl_disklock", 0, 0);

#if defined(KMEMSTATS) || defined(DIAGNOSTIC) || defined(FFS_SOFTUPDATES)
	lockinit(&sysctl_kmemlock, PLOCK|PCATCH, "sysctl_kmemlock", 0, 0);
#endif
d130 1
d132 3
d166 6
d175 5
a179 5
			if (uvm_vslock(p, SCARG(uap, old), oldlen,
			    VM_PROT_READ|VM_PROT_WRITE) != KERN_SUCCESS) {
				lockmgr(&sysctl_lock, LK_RELEASE, NULL, p);
				return EFAULT;
			}
d186 1
d188 3
a207 2
char *disknames = NULL;
struct diskstats *diskstats = NULL;
d235 1
a235 2
	    name[0] == KERN_MALLOCSTATS || name[0] == KERN_TTY ||
	    name[0] == KERN_POOL))
a256 2
	case KERN_NSELCOLL:
		return (sysctl_rdint(oldp, oldlenp, newp, nselcoll));
a358 6
	case KERN_MSGBUF:
		/* see note above */
		if (!msgbufp || msgbufp->msg_magic != MSG_MAGIC)
			return (ENXIO);
		return (sysctl_rdstruct(oldp, oldlenp, newp, msgbufp,
		    msgbufp->msg_bufs + sizeof(*msgbufp) - 1));
d361 1
a361 1
		    newp, newlen, p));
a364 17
	case KERN_NCHSTATS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &nchstats,
		    sizeof(struct nchstats)));
	case KERN_FORKSTAT:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &forkstat,
		    sizeof(struct forkstat)));
	case KERN_TTY:
		return (sysctl_tty(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
	case KERN_FSCALE:
		return (sysctl_rdint(oldp, oldlenp, newp, fscale));
	case KERN_CCPU:
		return (sysctl_rdint(oldp, oldlenp, newp, ccpu));
	case KERN_NPROCS:
		return (sysctl_rdint(oldp, oldlenp, newp, nprocs));
	case KERN_POOL:
		return (sysctl_dopool(name + 1, namelen - 1, oldp, oldlenp));
a384 1
	int err;
d402 1
d405 4
a410 13
	case HW_DISKNAMES:
		err = sysctl_diskinit(0, p);
		if (err)
			return err;
		return (sysctl_rdstring(oldp, oldlenp, newp, disknames));
	case HW_DISKSTATS:
		err = sysctl_diskinit(1, p);
		if (err)
			return err;
		return (sysctl_rdstruct(oldp, oldlenp, newp, diskstats,
		    disk_count * sizeof(struct diskstats)));
	case HW_DISKCOUNT:
		return (sysctl_rdint(oldp, oldlenp, newp, disk_count));
d607 1
a607 1
			/* save & zap NUL terminator while copying */
d896 2
a897 2
	strncpy(ep->e_wmesg, p->p_wmesg ? p->p_wmesg : "", WMESGLEN);
	ep->e_wmesg[WMESGLEN] = '\0';
a904 67
}

/*
 * Initialize disknames/diskstats for export by sysctl. If update is set,
 * then we simply update the disk statistics information.
 */
int
sysctl_diskinit(update, p)
	int update;
	struct proc *p;
{
	struct diskstats *sdk;
	struct disk *dk;
	int i, tlen, l;

	if ((i = lockmgr(&sysctl_disklock, LK_EXCLUSIVE, NULL, p)) != 0)
		return i;

	if (disk_change) {
		for (dk = TAILQ_FIRST(&disklist), tlen = 0; dk;
		    dk = TAILQ_NEXT(dk, dk_link))
			tlen += strlen(dk->dk_name) + 1;

		if (disknames)
			free(disknames, M_SYSCTL);
		if (diskstats)
			free(diskstats, M_SYSCTL);
		diskstats = NULL;
		disknames = NULL;
		diskstats = malloc(disk_count * sizeof(struct diskstats),
		    M_SYSCTL, M_WAITOK);
		disknames = malloc(tlen, M_SYSCTL, M_WAITOK);

		for (dk = TAILQ_FIRST(&disklist), i = 0, l = 0; dk;
		    dk = TAILQ_NEXT(dk, dk_link), i++) {
			l += sprintf(disknames + l, "%s,",
			    dk->dk_name ? dk->dk_name : "");
			sdk = diskstats + i;
			sdk->ds_busy = dk->dk_busy;
			sdk->ds_xfer = dk->dk_xfer;
			sdk->ds_seek = dk->dk_seek;
			sdk->ds_bytes = dk->dk_bytes;
			sdk->ds_attachtime = dk->dk_attachtime;
			sdk->ds_timestamp = dk->dk_timestamp;
			sdk->ds_time = dk->dk_time;
		}

		/* Eliminate trailing comma */
		if (l != 0)
			disknames[l - 1] = '\0';
		disk_change = 0;
	} else if (update) {
		/* Just update, number of drives hasn't changed */
		for (dk = TAILQ_FIRST(&disklist), i = 0; dk;
		    dk = TAILQ_NEXT(dk, dk_link), i++) {
			sdk = diskstats + i;
			sdk->ds_busy = dk->dk_busy;
			sdk->ds_xfer = dk->dk_xfer;
			sdk->ds_seek = dk->dk_seek;
			sdk->ds_bytes = dk->dk_bytes;
			sdk->ds_attachtime = dk->dk_attachtime;
			sdk->ds_timestamp = dk->dk_timestamp;
			sdk->ds_time = dk->dk_time;
		}
	}
	lockmgr(&sysctl_disklock, LK_RELEASE, NULL, p);
	return 0;
@


1.29.4.6
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.29.4.5 2001/07/04 10:48:27 niklas Exp $	*/
a76 10
#ifdef SYSVMSG
#include <sys/msg.h>
#endif
#ifdef SYSVSEM
#include <sys/sem.h>
#endif
#ifdef SYSVSHM
#include <sys/shm.h>
#endif

d233 1
a233 1
	int error, level, inthostid, oldsgap;
a237 1
	extern int stackgap_random;
d242 1
a242 1
	    name[0] == KERN_POOL || name[0] == KERN_SYSVIPC_INFO))
d373 1
a373 1
		    msgbufp->msg_bufs + offsetof(struct msgbuf, msg_bufc)));
a396 18
	case KERN_STACKGAPRANDOM:
		oldsgap = stackgap_random;

		error = sysctl_int(oldp, oldlenp, newp, newlen, &stackgap_random);
		/*
		 * Safety harness.
		 */
		if ((stackgap_random < ALIGNBYTES && stackgap_random != 0) ||
		    !powerof2(stackgap_random) ||
		    stackgap_random > PAGE_SIZE * 2) {
			stackgap_random = oldsgap;
			return (EINVAL);
		}
		return (error);
#if defined(SYSVMSG) || defined(SYSVSEM) || defined(SYSVSHM)  
	case KERN_SYSVIPC_INFO:
		return (sysctl_sysvipc(name + 1, namelen - 1, oldp, oldlenp));
#endif
d443 1
a443 5
		if (disknames)
			return (sysctl_rdstring(oldp, oldlenp, newp,
			    disknames));
		else
			return (sysctl_rdstring(oldp, oldlenp, newp, ""));
a967 1
		tlen++;
a977 1
		disknames[0] = '\0';
a1013 131

#if defined(SYSVMSG) || defined(SYSVSEM) || defined(SYSVSHM)
int
sysctl_sysvipc(name, namelen, where, sizep)
	int *name;
	u_int namelen;
	void *where;
	size_t *sizep;
{
#ifdef SYSVMSG
	struct msg_sysctl_info *msgsi;
#endif
#ifdef SYSVSEM
	struct sem_sysctl_info *semsi;
#endif
#ifdef SYSVSHM
	struct shm_sysctl_info *shmsi;
#endif
	size_t infosize, dssize, tsize, buflen;
	int i, nds, error, ret;
	void *buf;

	if (namelen != 1)
		return (EINVAL);

	buflen = *sizep;

	switch (*name) {
	case KERN_SYSVIPC_MSG_INFO:
#ifdef SYSVMSG
		infosize = sizeof(msgsi->msginfo);
		nds = msginfo.msgmni;
		dssize = sizeof(msgsi->msgids[0]);
		break;
#else
		return (EOPNOTSUPP);
#endif
	case KERN_SYSVIPC_SEM_INFO:
#ifdef SYSVSEM
		infosize = sizeof(semsi->seminfo);
		nds = seminfo.semmni;
		dssize = sizeof(semsi->semids[0]);
		break;
#else
		return (EOPNOTSUPP);
#endif
	case KERN_SYSVIPC_SHM_INFO:
#ifdef SYSVSHM
		infosize = sizeof(shmsi->shminfo);
		nds = shminfo.shmmni;
		dssize = sizeof(shmsi->shmids[0]);
		break;
#else
		return (EOPNOTSUPP);
#endif
	default:
		return (EINVAL);
	}
	tsize = infosize + (nds * dssize);

	/* Return just the total size required. */
	if (where == NULL) {
		*sizep = tsize;
		return (0);
	}

	/* Not enough room for even the info struct. */
	if (buflen < infosize) {
		*sizep = 0;
		return (ENOMEM);
	}
	buf = malloc(min(tsize, buflen), M_TEMP, M_WAITOK);
	bzero(buf, min(tsize, buflen));

	switch (*name) { 
#ifdef SYSVMSG
	case KERN_SYSVIPC_MSG_INFO:
		msgsi = (struct msg_sysctl_info *)buf;
		msgsi->msginfo = msginfo;
		break;
#endif
#ifdef SYSVSEM
	case KERN_SYSVIPC_SEM_INFO:
		semsi = (struct sem_sysctl_info *)buf;
		semsi->seminfo = seminfo;
		break;
#endif
#ifdef SYSVSHM
	case KERN_SYSVIPC_SHM_INFO:
		shmsi = (struct shm_sysctl_info *)buf;
		shmsi->shminfo = shminfo;
		break;
#endif
	}
	buflen -= infosize;

	ret = 0;
	if (buflen > 0) {
		/* Fill in the IPC data structures.  */
		for (i = 0; i < nds; i++) {
			if (buflen < dssize) {
				ret = ENOMEM;
				break;
			}
			switch (*name) { 
#ifdef SYSVMSG
			case KERN_SYSVIPC_MSG_INFO:
				bcopy(&msqids[i], &msgsi->msgids[i], dssize);
				break;
#endif
#ifdef SYSVSEM
			case KERN_SYSVIPC_SEM_INFO:
				bcopy(&sema[i], &semsi->semids[i], dssize);
				break;
#endif
#ifdef SYSVSHM
			case KERN_SYSVIPC_SHM_INFO:
				bcopy(&shmsegs[i], &shmsi->shmids[i], dssize);
				break;
#endif
			}
			buflen -= dssize;
		}
	}
	*sizep -= buflen;
	error = copyout(buf, where, *sizep);
	free(buf, M_TEMP);
	/* If copyout succeeded, use return code set earlier. */
	return (error ? error : ret);
}
#endif /* SYSVMSG || SYSVSEM || SYSVSHM */
@


1.29.4.7
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 1
a60 1
#include <uvm/uvm_extern.h>
d66 2
@


1.29.4.8
log
@Merge in -current
@
text
@d190 3
a192 4
		if (dolock) {
			error = uvm_vslock(p, SCARG(uap, old), oldlen,
			    VM_PROT_READ|VM_PROT_WRITE);
			if (error) {
d194 1
a194 1
				return (error);
a195 1
		}
@


1.29.4.9
log
@Merge in trunk
@
text
@a248 4
#ifdef CRYPTO
	extern int usercrypto;
	extern int cryptodevallowsoft;
#endif
a424 7
#endif
#ifdef CRYPTO
	case KERN_USERCRYPTO:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &usercrypto));
	case KERN_CRYPTODEVALLOWSOFT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &cryptodevallowsoft));
@


1.29.4.10
log
@Merge in -current from about a week ago
@
text
@d244 1
d717 1
a717 1
	const char *str;
d768 1
a768 2
	void *newp;
	const void *sp;
@


1.29.4.11
log
@Sync the SMP branch with 3.3
@
text
@a65 2
#include <sys/exec.h>
#include <sys/mbuf.h>
a89 1
extern  long numvnodes;
a91 2
int sysctl_proc_args(int *, u_int, void *, size_t *, struct proc *);
int sysctl_intrcnt(int *, u_int, void *, size_t *);
d141 1
a141 1
	error = copyin(SCARG(uap, name), name,
d200 1
a200 1
	error = (*fn)(&name[1], SCARG(uap, namelen) - 1, SCARG(uap, old),
a249 1
	extern int userasymcrypto;
d253 5
a257 19
	/* all sysctl names at this level are terminal except a ton of them */
	if (namelen != 1) {
		switch (name[0]) {
		case KERN_PROC:
		case KERN_PROF:
		case KERN_MALLOCSTATS:
		case KERN_TTY:
		case KERN_POOL:
		case KERN_PROC_ARGS:
		case KERN_SYSVIPC_INFO:
		case KERN_SEMINFO:
		case KERN_SHMINFO:
		case KERN_INTRCNT:
		case KERN_WATCHDOG:
			break;
		default:
			return (ENOTDIR);	/* overloaded */
		}
	}
a275 6
	case KERN_NFILES:
		return (sysctl_rdint(oldp, oldlenp, newp, nfiles));
	case KERN_TTYCOUNT:
		return (sysctl_rdint(oldp, oldlenp, newp, tty_count));
	case KERN_NUMVNODES:
		return (sysctl_rdint(oldp, oldlenp, newp, numvnodes));
a315 3
	case KERN_PROC_ARGS:
		return (sysctl_proc_args(name + 1, namelen - 1, oldp, oldlenp,
		     p));
a317 3
	case KERN_MBSTAT:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &mbstat,
		    sizeof(mbstat)));
d339 2
a431 3
	case KERN_USERASYMCRYPTO:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
			    &userasymcrypto));
a435 18
	case KERN_SPLASSERT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &splassert_ctl));
#ifdef SYSVSEM
	case KERN_SEMINFO:
		return (sysctl_sysvsem(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
#ifdef SYSVSHM
	case KERN_SHMINFO:
		return (sysctl_sysvshm(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
#endif
	case KERN_INTRCNT:
		return (sysctl_intrcnt(name + 1, namelen - 1, oldp, oldlenp));
	case KERN_WATCHDOG:
		return (sysctl_wdog(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
d820 1
a820 1
	LIST_FOREACH(fp, &filehead, f_list) {
d942 3
a944 1
fill_eproc(struct proc *p, struct eproc *ep)
d946 1
a946 1
	struct tty *tp;
a956 2
		bzero(&ep->e_pstats, sizeof(ep->e_pstats));
		ep->e_pstats_valid = 0;
d958 1
a958 1
		struct vmspace *vm = p->p_vmspace;
a959 1
		PHOLD(p);	/* need for pstats */
a963 3
		ep->e_pstats = *p->p_stats;
		ep->e_pstats_valid = 1;
		PRELE(p);
a991 200
int
sysctl_proc_args(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    struct proc *cp)
{
	struct proc *vp;
	pid_t pid;
	int op;
	struct ps_strings pss;
	struct iovec iov;
	struct uio uio;
	int error;
	size_t limit;
	int cnt;
	char **rargv, **vargv;		/* reader vs. victim */
	char *rarg, *varg;
	char *buf;

	if (namelen > 2)
		return (ENOTDIR);
	if (namelen < 2)
		return (EINVAL);

	pid = name[0];
	op = name[1];

	switch (op) {
	case KERN_PROC_ARGV:
	case KERN_PROC_NARGV:
	case KERN_PROC_ENV:
	case KERN_PROC_NENV:
		break;
	default:
		return (EOPNOTSUPP);
	}

	if ((vp = pfind(pid)) == NULL)
		return (ESRCH);

	if (P_ZOMBIE(vp) || (vp->p_flag & P_SYSTEM))
		return (EINVAL);

	/* Exiting - don't bother, it will be gone soon anyway */
	if ((vp->p_flag & P_WEXIT))
		return (ESRCH);

	/* Execing - danger. */
	if ((vp->p_flag & P_INEXEC))
		return (EBUSY);

	vp->p_vmspace->vm_refcnt++;	/* XXX */
	buf = malloc(PAGE_SIZE, M_TEMP, M_WAITOK);

	iov.iov_base = &pss;
	iov.iov_len = sizeof(pss);
	uio.uio_iov = &iov;
	uio.uio_iovcnt = 1;	
	uio.uio_offset = (off_t)PS_STRINGS;
	uio.uio_resid = sizeof(pss);
	uio.uio_segflg = UIO_SYSSPACE;
	uio.uio_rw = UIO_READ;
	uio.uio_procp = cp;

	if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio)) != 0)
		goto out;

	if (op == KERN_PROC_NARGV) {
		error = sysctl_rdint(oldp, oldlenp, NULL, pss.ps_nargvstr);
		goto out;
	}
	if (op == KERN_PROC_NENV) {
		error = sysctl_rdint(oldp, oldlenp, NULL, pss.ps_nenvstr);
		goto out;
	}

	if (op == KERN_PROC_ARGV) {
		cnt = pss.ps_nargvstr;
		vargv = pss.ps_argvstr;
	} else {
		cnt = pss.ps_nenvstr;
		vargv = pss.ps_envstr;
	}

	/* -1 to have space for a terminating NUL */
	limit = *oldlenp - 1;
	*oldlenp = 0;

	if (limit > 8 * PAGE_SIZE) {
		/* Don't allow a denial of service. */
		error = E2BIG;
		goto out;
	}

	rargv = oldp;

	/*
	 * *oldlenp - number of bytes copied out into readers buffer.
	 * limit - maximal number of bytes allowed into readers buffer.
	 * rarg - pointer into readers buffer where next arg will be stored.
	 * rargv - pointer into readers buffer where the next rarg pointer
	 *  will be stored.
	 * vargv - pointer into victim address space where the next argument
	 *  will be read.
	 */

	/* space for cnt pointers and a NULL */
	rarg = (char *)(rargv + cnt + 1);
	*oldlenp += (cnt + 1) * sizeof(char **);

	while (cnt > 0 && *oldlenp < limit) {
		size_t len, vstrlen;

		/* Write to readers argv */
		if ((error = copyout(&rarg, rargv, sizeof(rarg))) != 0)
			goto out;

		/* read the victim argv */
		iov.iov_base = &varg;
		iov.iov_len = sizeof(varg);
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(vaddr_t)vargv;
		uio.uio_resid = sizeof(varg);
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_READ;
		uio.uio_procp = cp;
		if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio)) != 0)
			goto out;

		if (varg == NULL)
			break;

		/*
		 * read the victim arg. We must jump through hoops to avoid
		 * crossing a page boundary too much and returning an error.
		 */
more:
		len = PAGE_SIZE - (((vaddr_t)varg) & PAGE_MASK);
		/* leave space for the terminating NUL */
		iov.iov_base = buf;
		iov.iov_len = len;
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)(vaddr_t)varg;
		uio.uio_resid = len;
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_READ;
		uio.uio_procp = cp;
		if ((error = uvm_io(&vp->p_vmspace->vm_map, &uio)) != 0)
			goto out;

		for (vstrlen = 0; vstrlen < len; vstrlen++) {
			if (buf[vstrlen] == '\0')
				break;
		}

		/* Don't overflow readers buffer. */
		if (*oldlenp + vstrlen + 1 >= limit) {
			error = ENOMEM;
			goto out;
		}

		if ((error = copyout(buf, rarg, vstrlen)) != 0)
			goto out;

		*oldlenp += vstrlen;
		rarg += vstrlen;

		/* The string didn't end in this page? */
		if (vstrlen == len) {
			varg += vstrlen;
			goto more;
		}

		/* End of string. Terminate it with a NUL */
		buf[0] = '\0';
		if ((error = copyout(buf, rarg, 1)) != 0)
			goto out;
		*oldlenp += 1;;
		rarg += 1;

		vargv++;
		rargv++;
		cnt--;
	}

	if (*oldlenp >= limit) {
		error = ENOMEM;
		goto out;
	}

	/* Write the terminating null */
	rarg = NULL;
	error = copyout(&rarg, rargv, sizeof(rarg));

out:
	uvmspace_free(vp->p_vmspace);
	free(buf, M_TEMP);
	return (error);
}

d1172 1
a1172 5
				if (sema[i] != NULL)
					bcopy(sema[i], &semsi->semids[i],
					    dssize);
				else
					bzero(&semsi->semids[i], dssize);
d1177 1
a1177 5
				if (shmsegs[i] != NULL)
					bcopy(shmsegs[i], &shmsi->shmids[i],
					    dssize);
				else
					bzero(&shmsi->shmids[i], dssize);
a1190 38

int
sysctl_intrcnt(int *name, u_int namelen, void *oldp, size_t *oldlenp)
{
	extern int intrcnt[], eintrcnt[];
	extern char intrnames[], eintrnames[];
	char *intrname;
	int nintr, i;

	nintr = (off_t)(eintrcnt - intrcnt);

	if (name[0] != KERN_INTRCNT_NUM) {
		if (namelen != 2)
			return (ENOTDIR);
		if (name[1] < 0 || name[1] >= nintr)
			return (EINVAL);
		i = name[1];
	}

	switch (name[0]) {
	case KERN_INTRCNT_NUM:
		return (sysctl_rdint(oldp, oldlenp, NULL, nintr));
		break;
	case KERN_INTRCNT_CNT:
		return (sysctl_rdint(oldp, oldlenp, NULL, intrcnt[i]));
	case KERN_INTRCNT_NAME:
		intrname = intrnames;
		while (i > 0) {
			intrname += strlen(intrname) + 1;
			i--;
			if (intrname > eintrnames)
				return (EINVAL);
		}
		return (sysctl_rdstring(oldp, oldlenp, NULL, intrname));
	default:
		return (EOPNOTSUPP);
	}
}
@


1.29.4.12
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.29.4.11 2003/03/28 00:41:26 niklas Exp $	*/
a67 1
#include <sys/sensors.h>
a96 1
int sysctl_sensors(int *, u_int, void *, size_t *, void *, size_t);
d509 2
a510 2
	/* all sysctl names at this level except sensors are terminal */
	if (name[0] != HW_SENSORS && namelen != 1)
a545 3
	case HW_SENSORS:
		return (sysctl_sensors(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
d1282 1
a1282 1
			snprintf(disknames + l, tlen - l, "%s,",
a1283 1
			l += strlen(disknames + l);
a1490 24
}

int nsensors = 0;
struct sensors_head sensors = SLIST_HEAD_INITIALIZER(&sensors);

int
sysctl_sensors(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	struct sensor *s = NULL;
	int num;

	if (namelen != 1)
		return (ENOTDIR);

	num = name[0];
	if (num >= nsensors)
		return (ENXIO);

	SLIST_FOREACH(s, &sensors, list)
		if (s->num == num)
			break;

	return (sysctl_rdstruct(oldp, oldlenp, newp, s, sizeof(struct sensor)));
@


1.29.4.13
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.29.4.12 2003/05/13 19:21:28 ho Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.29.4.14
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a83 2
#define	PTRTOINT64(_x)	((u_int64_t)(u_long)(_x))

a94 4
int sysctl_emul(int *, u_int, void *, size_t *, void *, size_t);

int (*cpu_cpuspeed)(void *, size_t *, void *, size_t);
int (*cpu_setperf)(void *, size_t *, void *, size_t);
d137 1
a137 1
	    (error = suser(p, 0)))
d152 1
a152 1
		if (name[1] == KERN_VNODE)	/* XXX */
d246 1
a246 1
	int error, level, inthostid, stackgap;
a260 1
		case KERN_PROC2:
a270 1
		case KERN_EMUL:
d309 2
a310 2
		if ((securelevel > 0 || level < -1) &&
		    level < securelevel && p->p_pid != 1)
d339 1
a339 2
	case KERN_PROC2:
		return (sysctl_doproc(name, namelen, oldp, oldlenp));
d440 3
a442 4
		stackgap = stackgap_random;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &stackgap);
		if (error)
			return (error);
d446 4
a449 2
		if ((stackgap < ALIGNBYTES && stackgap != 0) ||
		    !powerof2(stackgap) || stackgap >= 256 * 1024 * 1024)
d451 2
a452 2
		stackgap_random = stackgap;
		return (0);
a481 1
#ifndef SMALL_KERNEL
a484 4
#endif
	case KERN_EMUL:
		return (sysctl_emul(name + 1, namelen - 1, oldp, oldlenp,
		    newp, newlen));
a546 8
	case HW_CPUSPEED:
		if (!cpu_cpuspeed)
			return (EOPNOTSUPP);
		return (cpu_cpuspeed(oldp, oldlenp, newp, newlen));
	case HW_SETPERF:
		if (!cpu_setperf)
			return (EOPNOTSUPP);
		return (cpu_setperf(oldp, oldlenp, newp, newlen));
d557 1
a557 2
extern struct ctldebug debug0, debug1;
struct ctldebug debug2, debug3, debug4;
d899 5
a903 1
	struct kinfo_proc2 kproc2;
d905 5
a909 25
	struct proc *p;
	char *dp;
	int arg, buflen, doingzomb, elem_size, elem_count;
	int error, needed, type, op;

	dp = where;
	buflen = where != NULL ? *sizep : 0;
	needed = error = 0;
	type = name[0];

	if (type == KERN_PROC) {
		if (namelen != 3 && !(namelen == 2 &&
		    (name[1] == KERN_PROC_ALL || name[1] == KERN_PROC_KTHREAD)))
			return (EINVAL);
		op = name[1];
		arg = op == KERN_PROC_ALL ? 0 : name[2];
		elem_size = elem_count = 0;
	} else /* if (type == KERN_PROC2) */ {
		if (namelen != 5 || name[3] < 0 || name[4] < 0)
			return (EINVAL);
		op = name[1];
		arg = name[2];
		elem_size = name[3];
		elem_count = name[4];
	}
d921 1
d923 1
a923 1
		switch (op) {
d927 1
a927 1
			if (p->p_pid != (pid_t)arg)
d933 1
a933 7
			if (p->p_pgrp->pg_id != (pid_t)arg)
				continue;
			break;

		case KERN_PROC_SESSION:
			if (p->p_session->s_leader == NULL ||
			    p->p_session->s_leader->p_pid != (pid_t)arg)
d940 1
a940 1
			    p->p_session->s_ttyp->t_dev != (dev_t)arg)
d945 1
a945 1
			if (p->p_ucred->cr_uid != (uid_t)arg)
d950 1
a950 1
			if (p->p_cred->p_ruid != (uid_t)arg)
a957 5
		case KERN_PROC_KTHREAD:
			/* no filtering */
			break;
		default:
			return (EINVAL);
d959 12
a970 33
		if (type == KERN_PROC) {
			if (buflen >= sizeof(struct kinfo_proc)) {
				fill_eproc(p, &eproc);
				error = copyout((caddr_t)p,
				    &((struct kinfo_proc *)dp)->kp_proc,
				    sizeof(struct proc));
				if (error)
					return (error);
				error = copyout((caddr_t)&eproc,
				    &((struct kinfo_proc *)dp)->kp_eproc,
				    sizeof(eproc));
				if (error)
					return (error);
				dp += sizeof(struct kinfo_proc);
				buflen -= sizeof(struct kinfo_proc);
			}
			needed += sizeof(struct kinfo_proc);
		} else /* if (type == KERN_PROC2) */ {
			if (buflen >= elem_size && elem_count > 0) {
				fill_kproc2(p, &kproc2);
				/*
				 * Copy out elem_size, but not larger than
				 * the size of a struct kinfo_proc2.
				 */
				error = copyout(&kproc2, dp,
				    min(sizeof(kproc2), elem_size));
				if (error)
					return (error);
				dp += elem_size;
				buflen -= elem_size;
				elem_count--;
			}
			needed += elem_size;
d972 1
d980 1
a980 1
		*sizep = dp - where;
a1047 162
/*
 * Fill in a kproc2 structure for the specified process.
 */
void
fill_kproc2(struct proc *p, struct kinfo_proc2 *ki)
{
	struct tty *tp;
	struct timeval ut, st;

	bzero(ki, sizeof(*ki));

	ki->p_paddr = PTRTOINT64(p);
	ki->p_fd = PTRTOINT64(p->p_fd);
	ki->p_stats = PTRTOINT64(p->p_stats);
	ki->p_limit = PTRTOINT64(p->p_limit);
	ki->p_vmspace = PTRTOINT64(p->p_vmspace);
	ki->p_sigacts = PTRTOINT64(p->p_sigacts);
	ki->p_sess = PTRTOINT64(p->p_session);
	ki->p_tsess = 0;	/* may be changed if controlling tty below */
	ki->p_ru = PTRTOINT64(p->p_ru);

	ki->p_eflag = 0;
	ki->p_exitsig = p->p_exitsig;
	ki->p_flag = p->p_flag;

	ki->p_pid = p->p_pid;
	if (p->p_pptr)
		ki->p_ppid = p->p_pptr->p_pid;
	else
		ki->p_ppid = 0;
	if (p->p_session->s_leader)
		ki->p_sid = p->p_session->s_leader->p_pid;
	else
		ki->p_sid = 0;
	ki->p__pgid = p->p_pgrp->pg_id;

	ki->p_tpgid = -1;	/* may be changed if controlling tty below */

	ki->p_uid = p->p_ucred->cr_uid;
	ki->p_ruid = p->p_cred->p_ruid;
	ki->p_gid = p->p_ucred->cr_gid;
	ki->p_rgid = p->p_cred->p_rgid;
	ki->p_svuid = p->p_cred->p_svuid;
	ki->p_svgid = p->p_cred->p_svgid;

	memcpy(ki->p_groups, p->p_cred->pc_ucred->cr_groups,
	    min(sizeof(ki->p_groups), sizeof(p->p_cred->pc_ucred->cr_groups)));
	ki->p_ngroups = p->p_cred->pc_ucred->cr_ngroups;

	ki->p_jobc = p->p_pgrp->pg_jobc;
	if ((p->p_flag & P_CONTROLT) && (tp = p->p_session->s_ttyp)) {
		ki->p_tdev = tp->t_dev;
		ki->p_tpgid = tp->t_pgrp ? tp->t_pgrp->pg_id : -1;
		ki->p_tsess = PTRTOINT64(tp->t_session);
	} else {
		ki->p_tdev = NODEV;
	}

	ki->p_estcpu = p->p_estcpu;
	ki->p_rtime_sec = p->p_rtime.tv_sec;
	ki->p_rtime_usec = p->p_rtime.tv_usec;
	ki->p_cpticks = p->p_cpticks;
	ki->p_pctcpu = p->p_pctcpu;

	ki->p_uticks = p->p_uticks;
	ki->p_sticks = p->p_sticks;
	ki->p_iticks = p->p_iticks;

	ki->p_tracep = PTRTOINT64(p->p_tracep);
	ki->p_traceflag = p->p_traceflag;

	ki->p_siglist = p->p_siglist;
	ki->p_sigmask = p->p_sigmask;
	ki->p_sigignore = p->p_sigignore;
	ki->p_sigcatch = p->p_sigcatch;

	ki->p_stat = p->p_stat;
	ki->p_nice = p->p_nice;

	ki->p_xstat = p->p_xstat;
	ki->p_acflag = p->p_acflag;

	strlcpy(ki->p_emul, p->p_emul->e_name, sizeof(ki->p_emul));
	strlcpy(ki->p_comm, p->p_comm, sizeof(ki->p_comm));
	strncpy(ki->p_login, p->p_session->s_login,
	    min(sizeof(ki->p_login) - 1, sizeof(p->p_session->s_login)));

	if (p->p_stat == SIDL || P_ZOMBIE(p)) {
		ki->p_vm_rssize = 0;
		ki->p_vm_tsize = 0;
		ki->p_vm_dsize = 0;
		ki->p_vm_ssize = 0;
	} else {
		struct vmspace *vm = p->p_vmspace;

		ki->p_vm_rssize = vm_resident_count(vm);
		ki->p_vm_tsize = vm->vm_tsize;
		ki->p_vm_dsize = vm->vm_dsize;
		ki->p_vm_ssize = vm->vm_ssize;

		ki->p_forw = PTRTOINT64(p->p_forw);
		ki->p_back = PTRTOINT64(p->p_back);
		ki->p_addr = PTRTOINT64(p->p_addr);
		ki->p_stat = p->p_stat;
		ki->p_swtime = p->p_swtime;
		ki->p_slptime = p->p_slptime;
		ki->p_schedflags = p->p_schedflags;
		ki->p_holdcnt = p->p_holdcnt;
		ki->p_priority = p->p_priority;
		ki->p_usrpri = p->p_usrpri;
		if (p->p_wmesg)
			strlcpy(ki->p_wmesg, p->p_wmesg, sizeof(ki->p_wmesg));
		ki->p_wchan = PTRTOINT64(p->p_wchan);

	}

	if (p->p_session->s_ttyvp)
		ki->p_eflag |= EPROC_CTTY;
	if (SESS_LEADER(p))
		ki->p_eflag |= EPROC_SLEADER;
	if (p->p_rlimit)
		ki->p_rlim_rss_cur = p->p_rlimit[RLIMIT_RSS].rlim_cur;

	/* XXX Is this double check necessary? */
	if (P_ZOMBIE(p)) {
		ki->p_uvalid = 0;
	} else {
		ki->p_uvalid = 1;

		PHOLD(p);	/* need for pstats */
		ki->p_ustart_sec = p->p_stats->p_start.tv_sec;
		ki->p_ustart_usec = p->p_stats->p_start.tv_usec;

		calcru(p, &ut, &st, 0);
		ki->p_uutime_sec = ut.tv_sec;
		ki->p_uutime_usec = ut.tv_usec;
		ki->p_ustime_sec = st.tv_sec;
		ki->p_ustime_usec = st.tv_usec;

		ki->p_uru_maxrss = p->p_stats->p_ru.ru_maxrss;
		ki->p_uru_ixrss = p->p_stats->p_ru.ru_ixrss;
		ki->p_uru_idrss = p->p_stats->p_ru.ru_idrss;
		ki->p_uru_isrss = p->p_stats->p_ru.ru_isrss;
		ki->p_uru_minflt = p->p_stats->p_ru.ru_minflt;
		ki->p_uru_majflt = p->p_stats->p_ru.ru_majflt;
		ki->p_uru_nswap = p->p_stats->p_ru.ru_nswap;
		ki->p_uru_inblock = p->p_stats->p_ru.ru_inblock;
		ki->p_uru_oublock = p->p_stats->p_ru.ru_oublock;
		ki->p_uru_msgsnd = p->p_stats->p_ru.ru_msgsnd;
		ki->p_uru_msgrcv = p->p_stats->p_ru.ru_msgrcv;
		ki->p_uru_nsignals = p->p_stats->p_ru.ru_nsignals;
		ki->p_uru_nvcsw = p->p_stats->p_ru.ru_nvcsw;
		ki->p_uru_nivcsw = p->p_stats->p_ru.ru_nivcsw;

		timeradd(&p->p_stats->p_cru.ru_utime,
			 &p->p_stats->p_cru.ru_stime, &ut);
		ki->p_uctime_sec = ut.tv_sec;
		ki->p_uctime_usec = ut.tv_usec;
		PRELE(p);
	}
}

d1225 1
a1225 1
		*oldlenp += 1;
a1516 33
}

int
sysctl_emul(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	int enabled, error;
	struct emul *e;

	if (name[0] == KERN_EMUL_NUM) {
		if (namelen != 1)
			return (ENOTDIR);
		return (sysctl_rdint(oldp, oldlenp, newp, nemuls));
	}

	if (namelen != 2)
		return (ENOTDIR);
	if (name[0] > nemuls || name[0] < 0)
		return (EINVAL);
	e = emulsw[name[0] - 1];

	switch (name[1]) {
	case KERN_EMUL_NAME:
		return (sysctl_rdstring(oldp, oldlenp, newp, e->e_name));
	case KERN_EMUL_ENABLED:
		enabled = (e->e_flags & EMUL_ENABLED);
		error = sysctl_int(oldp, oldlenp, newp, newlen,
		    &enabled);
		e->e_flags = (enabled & EMUL_ENABLED);
		return (error);
	default:
		return (EINVAL);
	}
@


1.29.4.15
log
@Some merged code from NetBSD, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.29.4.14 2004/02/19 10:56:37 niklas Exp $	*/
a1273 6
#ifdef MULTIPROCESSOR
		if (p->p_cpu != NULL)
			ki->p_cpuid = p->p_cpu->ci_cpuid;
		else
#endif
			ki->p_cpuid = KI_NOCPU;
@


1.29.4.16
log
@Make a few scheduling globals per-cpu, mostly NetBSD code
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.29.4.15 2004/03/14 22:08:21 niklas Exp $	*/
a1221 1
#ifndef MULTIPROCESSOR
a1222 1
#endif
@


1.29.4.17
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a92 2
extern void nmbclust_update(void);

d99 2
a100 3
int (*cpu_cpuspeed)(int *);
int (*cpu_setperf)(int);
int perflevel = 100;
a497 5
	case KERN_MAXCLUSTERS:
		error = sysctl_int(oldp, oldlenp, newp, newlen, &nmbclust);
		if (!error)
			nmbclust_update();
		return (error);
a518 1
	int cpuspeed;
d563 1
a563 4
		err = cpu_cpuspeed(&cpuspeed);
		if (err)
			return err;
		return (sysctl_rdint(oldp, oldlenp, newp, cpuspeed));
d567 1
a567 11
		err = sysctl_int(oldp, oldlenp, newp, newlen, &perflevel);
		if (err)
			return err;
		if (perflevel > 100)
			perflevel = 100;
		if (perflevel < 0)
			perflevel = 0;
		if (newp)
			return (cpu_setperf(perflevel));
		else
			return (0);
a667 20
 * Array of integer values.
 */
int
sysctl_int_arr(valpp, name, namelen, oldp, oldlenp, newp, newlen)
	int **valpp;
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	if (namelen > 1)
		return (ENOTDIR);
	if (name[0] < 0 || valpp[name[0]] == NULL)
		return (EOPNOTSUPP);
	return (sysctl_int(oldp, oldlenp, newp, newlen, valpp[name[0]]));
}

/*
a1524 2
			strlcpy(sdk->ds_name, dk->dk_name,
			    sizeof(sdk->ds_name));
d1526 1
a1526 2
			sdk->ds_rxfer = dk->dk_rxfer;
			sdk->ds_wxfer = dk->dk_wxfer;
d1528 1
a1528 2
			sdk->ds_rbytes = dk->dk_rbytes;
			sdk->ds_wbytes = dk->dk_wbytes;
a1542 2
			strlcpy(sdk->ds_name, dk->dk_name,
			    sizeof(sdk->ds_name));
d1544 1
a1544 2
			sdk->ds_rxfer = dk->dk_rxfer;
			sdk->ds_wxfer = dk->dk_wxfer;
d1546 1
a1546 2
			sdk->ds_rbytes = dk->dk_rbytes;
			sdk->ds_wbytes = dk->dk_wbytes;
d1767 1
a1767 1
		return (sysctl_rdint(oldp, oldlenp, newp, nexecs));
d1772 1
a1772 4
	if (name[0] > nexecs || name[0] < 0)
		return (EINVAL);
	e = execsw[name[0] - 1].es_emul;
	if (e == NULL)
d1774 1
@


1.29.4.18
log
@minimize diffs against kinfo_proc2 setup; markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.29.4.17 2004/06/05 23:13:01 niklas Exp $	*/
d1264 1
d1266 1
a1317 1
		ki->p_cpuid = KI_NOCPU;
d1321 1
d1323 1
@


1.29.4.19
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1263 3
#ifdef __HAVE_CPUINFO
		ki->p_schedflags = 0;
#else
a1264 1
#endif
@


1.29.4.20
log
@For MULTIPROCESSOR, sum the individual cpu's cp_time into the global cpu_time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.29.4.19 2004/06/10 11:40:33 niklas Exp $	*/
a431 14
#ifdef MULTIPROCESSOR
	{
		CPU_INFO_ITERATOR cii;
		struct cpu_info *ci;
		int i;

		bzero(cp_time, sizeof(cp_time));

		for (CPU_INFO_FOREACH(cii, ci)) {
			for (i = 0; i < CPUSTATES; i++)
				cp_time[i] += ci->ci_schedstate.spc_cp_time[i];
		}
	}
#endif
@


1.28
log
@remove the "ifdef pmap_resident_count" hack and replace it with a macro.
change some &vm->vm_pmap to vm->vm_map.pmap
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.27 1999/02/26 04:57:15 art Exp $	*/
d328 2
@


1.27
log
@compat with uvm sysctl, some uvm name changes, cnt.foo -> uvmexp.bar
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.26 1998/07/07 07:12:40 deraadt Exp $	*/
d807 1
a807 5
#ifdef pmap_resident_count
		ep->e_vm.vm_rssize = pmap_resident_count(&vm->vm_pmap); /*XXX*/
#else
		ep->e_vm.vm_rssize = vm->vm_rssize;
#endif
d811 1
a811 1
		ep->e_vm.vm_pmap = vm->vm_pmap;
@


1.26
log
@per XPG, gethostname() with a short buffer returns truncated data - not ENOMEM.
As permitted, make the truncated buffer be NUL terminated.
make getdomainname() match.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.25 1998/06/02 06:10:28 deraadt Exp $	*/
d62 4
d125 3
d129 1
d161 3
d165 1
d174 3
d178 1
d185 3
d189 1
d387 4
d393 1
@


1.25
log
@add sysctl and sysconf support for sysvsem, sysvshm, sysvmsg, and fsync; mostly from kleink
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.24 1997/12/08 21:25:37 deraadt Exp $	*/
d249 1
a249 1
		error = sysctl_string(oldp, oldlenp, newp, newlen,
d255 1
a255 1
		error = sysctl_string(oldp, oldlenp, newp, newlen,
d482 25
d508 1
d511 4
a514 2
	if (oldp && *oldlenp < len)
		return (ENOMEM);
d518 10
a527 2
		*oldlenp = len;
		error = copyout(str, oldp, len);
@


1.24
log
@add kern.nosuidcoredump to lock things out even more
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.23 1997/11/06 15:59:49 kstailey Exp $	*/
d310 20
@


1.23
log
@fix ps(1) LIM column
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.22 1997/11/06 05:58:19 csapuntz Exp $	*/
d213 1
a213 1
	extern int usermount;
d308 2
@


1.22
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.21 1997/10/06 20:19:58 deraadt Exp $	*/
d51 1
d758 1
@


1.21
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.19 1997/09/03 13:51:08 kstailey Exp $	*/
d113 1
a113 1
		if (name[2] != KERN_VNODE)	/* XXX */
d128 3
d270 1
a270 1
		return (sysctl_vnode(oldp, oldlenp));
@


1.20
log
@VFS Lite2 Changes
@
text
@d113 1
a113 1
		if (name[2] == KERN_VNODE)	/* XXX */
a127 3
	case CTL_VFS:
		fn = vfs_sysctl;
		break;
d267 1
a267 1
		return (sysctl_vnode(oldp, oldlenp, p));
@


1.19
log
@changes for ps "emul" option
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.18 1997/06/22 04:58:03 flipk Exp $	*/
d113 1
a113 1
		if (name[2] != KERN_VNODE)	/* XXX */
d128 3
d270 1
a270 1
		return (sysctl_vnode(oldp, oldlenp));
@


1.18
log
@wasn't a race after all. properly initialize event_q pointers so the
last one doesn't point off the end.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.16 1997/06/14 21:37:10 mickey Exp $	*/
d752 2
@


1.17
log
@revert, there's a nasty race condition here.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.15 1997/03/27 04:39:35 millert Exp $	*/
d63 1
d301 3
@


1.16
log
@split the treatment of the random events
event_q by flipk@@
spl fix by deraadt@@
gother statistics about whole processing
use 'sysctl kern.random' to view what had happened
also fix wrong vm.psstrings description
@
text
@a62 1
#include <dev/rndvar.h>
a299 3
	case KERN_RND:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &rndstats,
		    sizeof(rndstats)));
@


1.15
log
@Make kern.osrevision (sysctl) and /kern/osrev report value of
OpenBSD define, not BSD which is a bit more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.14 1997/03/26 17:23:50 deraadt Exp $	*/
d63 1
d301 3
@


1.14
log
@loginname copying in fill_eproc; gwing@@primenet.com.au
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.13 1996/10/04 01:26:47 deraadt Exp $	*/
d220 1
a220 1
		return (sysctl_rdint(oldp, oldlenp, newp, BSD));
@


1.13
log
@usermount sysctl, default to prevent users from using mount syscall
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.12 1996/09/20 22:53:09 deraadt Exp $	*/
d746 2
a748 1

@


1.12
log
@`solve' the syn bomb problem as well as currently known; add sysctl's for
SOMAXCONN (kern.somaxconn), SOMINCONN (kern.sominconn), and TCPTV_KEEP_INIT
(net.inet.tcp.keepinittime). when this is not enough (ie. overfull), start
doing tail drop, but slightly prefer the same port.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.11 1996/08/08 06:36:45 tholo Exp $	*/
d208 1
d298 2
@


1.11
log
@Make {,f}chown(2) behaviour POSIX.1 compliant with SUID / SGID files
Enable CTL_FS processing by sysctl(3)
Add CTL_FS request to disable clearing SUID / SGID bit when a files owner
or group is changed by root
Make sysctl(8) understand CTL_FS requests
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.10 1996/06/29 21:07:52 tholo Exp $	*/
d207 1
d293 4
@


1.10
log
@Add external declaration for osversion[]
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.9 1996/06/29 21:04:21 tholo Exp $	*/
a123 1
#ifdef notyet
a126 1
#endif
@


1.9
log
@MIssed this one in previous commit; make uname(1) and uname(3) do the
right thing for the version field
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.8 1996/05/24 22:17:44 dm Exp $	*/
d208 1
a208 1
	extern char ostype[], osrelease[], version[];
@


1.8
log
@When INSECURE is not defined, leave securelevel in the BSS so the kernel
binary is harder to patch.  (Basically undo last change).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.7 1996/05/23 08:33:15 deraadt Exp $	*/
d221 2
@


1.7
log
@force securelevel to 0
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.5 1996/04/21 22:27:10 deraadt Exp $	*/
d191 1
a191 1
int securelevel = 0;
@


1.6
log
@Allow the security level to be lowered when in security level 0
@
text
@d2 1
a2 1
/*	$NetBSD: kern_sysctl.c,v 1.16 1996/04/12 23:21:37 thorpej Exp $	*/
d191 1
a191 1
int securelevel;
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sysctl.c,v 1.4 1996/04/19 16:08:59 niklas Exp $	*/
d236 2
a237 1
		if (level < securelevel && p->p_pid != 1)
@


1.4
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: kern_sysctl.c,v 1.3 1996/03/30 04:51:32 mickey Exp $	*/
/*	$NetBSD: kern_sysctl.c,v 1.15 1996/02/27 04:20:40 jonathan Exp $	*/
d177 1
a177 2
	*retval = oldlen;
	return (0);
@


1.3
log
@Added: sysctl access to the ddb variables.
Fixed: "netbsd" strings in sym table handling routines.
now it is usefull to change max_{width,line} according
to your real console geometry, just w/ sysctl program.
@
text
@d1 2
a2 2
/*	$OpenBSD: kern_sysctl.c,v 1.2 1996/03/03 17:19:56 niklas Exp $	*/
/*	$NetBSD: kern_sysctl.c,v 1.14 1996/02/09 18:59:52 christos Exp $	*/
d290 2
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 4
d135 5
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: kern_sysctl.c,v 1.12 1995/10/07 06:28:27 mycroft Exp $	*/
a63 10
sysctlfn kern_sysctl;
sysctlfn hw_sysctl;
#ifdef DEBUG
sysctlfn debug_sysctl;
#endif
extern sysctlfn vm_sysctl;
extern sysctlfn fs_sysctl;
extern sysctlfn net_sysctl;
extern sysctlfn cpu_sysctl;

d88 1
a88 1
	size_t savelen, oldlen = 0;
d100 3
a102 2
	if (error =
	    copyin(SCARG(uap, name), &name, SCARG(uap, namelen) * sizeof(int)))
d157 1
a157 1
			vsunlock(SCARG(uap, old), savelen, B_WRITE);
d189 1
d290 1
d376 1
d401 1
d424 1
d454 1
d478 1
d506 1
d528 1
d553 2
a554 1
	if (error = copyout((caddr_t)&filehead, where, sizeof(filehead)))
d567 2
a568 1
		if (error = copyout((caddr_t)fp, where, sizeof (struct file)))
d582 1
d645 3
a647 2
			if (error = copyout((caddr_t)p, &dp->kp_proc,
			    sizeof(struct proc)))
d649 3
a651 2
			if (error = copyout((caddr_t)&eproc, &dp->kp_eproc,
			    sizeof(eproc)))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
