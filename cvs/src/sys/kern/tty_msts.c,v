head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.6
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.8
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.4
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.16.0.18
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.14
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.12
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.10
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.20
date	2015.12.21.21.49.02;	author sf;	state Exp;
branches;
next	1.19;
commitid	QfhbTzV3KV3v5lir;

1.19
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	3SGDR5EjcwE01W8S;

1.18
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.17;
commitid	uzzBR7hz9ncd4O6G;

1.17
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.16;
commitid	QlVV51SZgNFxsXxC;

1.16
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.02.21.17.35;	author ckuethe;	state Exp;
branches;
next	1.14;

1.14
date	2009.05.06.16.05.20;	author stevesk;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.26.02.25.36;	author cnst;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.12.16.45.38;	author stevesk;	state Exp;
branches;
next	1.11;

1.11
date	2009.01.12.15.54.13;	author stevesk;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.12.15.19.28;	author stevesk;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.01.02.10.54;	author stevesk;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.25.21.25.55;	author stevesk;	state Exp;
branches;
next	1.7;

1.7
date	2008.12.25.21.14.07;	author stevesk;	state Exp;
branches;
next	1.6;

1.6
date	2008.12.25.21.04.36;	author stevesk;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.11.17.11.36;	author mbalmer;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.06.08.51.44;	author mbalmer;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.06.13.11.51;	author mbalmer;	state Exp;
branches;
next	1.1;

1.1
date	2008.01.05.17.33.28;	author mbalmer;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Move ppp, nmea, endrun, and msts prototypes to tty.h

Fix inconsistent arguments for pppopen/pppclose/pppstart.
Use passed in argument p in pppopen instead of curproc.

"Looks good to me" deraadt@@
@
text
@/*	$OpenBSD: tty_msts.c,v 1.19 2014/11/03 03:08:00 deraadt Exp $ */

/*
 * Copyright (c) 2008 Marc Balmer <mbalmer@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 *  A tty line discipline to decode the Meinberg Standard Time String
 *  to get the time (http://www.meinberg.de/english/specs/timestr.htm).
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/sensors.h>
#include <sys/tty.h>
#include <sys/conf.h>
#include <sys/time.h>

#ifdef MSTS_DEBUG
#define DPRINTFN(n, x)	do { if (mstsdebug > (n)) printf x; } while (0)
int mstsdebug = 0;
#else
#define DPRINTFN(n, x)
#endif
#define DPRINTF(x)	DPRINTFN(0, x)

void	mstsattach(int);

#define MSTSMAX	32
#define MAXFLDS	4
#ifdef MSTS_DEBUG
#define TRUSTTIME	30
#else
#define TRUSTTIME	(10 * 60)	/* 10 minutes */
#endif

int msts_count, msts_nxid;

struct msts {
	char			cbuf[MSTSMAX];	/* receive buffer */
	struct ksensor		time;		/* the timedelta sensor */
	struct ksensor		signal;		/* signal status */
	struct ksensordev	timedev;
	struct timespec		ts;		/* current timestamp */
	struct timespec		lts;		/* timestamp of last <STX> */
	struct timeout		msts_tout;	/* invalidate sensor */
	int64_t			gap;		/* gap between two sentences */
	int64_t			last;		/* last time rcvd */
	int			sync;		/* if 1, waiting for <STX> */
	int			pos;		/* position in rcv buffer */
	int			no_pps;		/* no PPS although requested */
};

/* MSTS decoding */
void	msts_scan(struct msts *, struct tty *);
void	msts_decode(struct msts *, struct tty *, char *fld[], int fldcnt);

/* date and time conversion */
int	msts_date_to_nano(char *s, int64_t *nano);
int	msts_time_to_nano(char *s, int64_t *nano);

/* degrade the timedelta sensor */
void	msts_timeout(void *);

void
mstsattach(int dummy)
{
}

int
mstsopen(dev_t dev, struct tty *tp, struct proc *p)
{
	struct msts *np;
	int error;

	DPRINTF(("mstsopen\n"));
	if (tp->t_line == MSTSDISC)
		return ENODEV;
	if ((error = suser(p, 0)) != 0)
		return error;
	np = malloc(sizeof(struct msts), M_DEVBUF, M_WAITOK|M_ZERO);
	snprintf(np->timedev.xname, sizeof(np->timedev.xname), "msts%d",
	    msts_nxid++);
	msts_count++;
	np->time.status = SENSOR_S_UNKNOWN;
	np->time.type = SENSOR_TIMEDELTA;
#ifndef MSTS_DEBUG
	np->time.flags = SENSOR_FINVALID;
#endif
	sensor_attach(&np->timedev, &np->time);

	np->signal.type = SENSOR_PERCENT;
	np->signal.status = SENSOR_S_UNKNOWN;
	np->signal.value = 100000LL;
	strlcpy(np->signal.desc, "Signal", sizeof(np->signal.desc));
	sensor_attach(&np->timedev, &np->signal);

	np->sync = 1;
	tp->t_sc = (caddr_t)np;

	error = linesw[TTYDISC].l_open(dev, tp, p);
	if (error) {
		free(np, M_DEVBUF, sizeof(*np));
		tp->t_sc = NULL;
	} else {
		sensordev_install(&np->timedev);
		timeout_set(&np->msts_tout, msts_timeout, np);
	}

	return error;
}

int
mstsclose(struct tty *tp, int flags, struct proc *p)
{
	struct msts *np = (struct msts *)tp->t_sc;

	tp->t_line = TTYDISC;	/* switch back to termios */
	timeout_del(&np->msts_tout);
	sensordev_deinstall(&np->timedev);
	free(np, M_DEVBUF, sizeof(*np));
	tp->t_sc = NULL;
	msts_count--;
	if (msts_count == 0)
		msts_nxid = 0;
	return linesw[TTYDISC].l_close(tp, flags, p);
}

/* collect MSTS sentence from tty */
int
mstsinput(int c, struct tty *tp)
{
	struct msts *np = (struct msts *)tp->t_sc;
	struct timespec ts;
	int64_t gap;
	long tmin, tmax;

	switch (c) {
	case 2:		/* ASCII <STX> */
		nanotime(&ts);
		np->pos = np->sync = 0;
		gap = (ts.tv_sec * 1000000000LL + ts.tv_nsec) -
		    (np->lts.tv_sec * 1000000000LL + np->lts.tv_nsec);

		np->lts.tv_sec = ts.tv_sec;
		np->lts.tv_nsec = ts.tv_nsec;

		if (gap <= np->gap)
			break;

		np->ts.tv_sec = ts.tv_sec;
		np->ts.tv_nsec = ts.tv_nsec;
		np->gap = gap;

		/*
		 * If a tty timestamp is available, make sure its value is
		 * reasonable by comparing against the timestamp just taken.
		 * If they differ by more than 2 seconds, assume no PPS signal
		 * is present, note the fact, and keep using the timestamp
		 * value.  When this happens, the sensor state is set to
		 * CRITICAL later when the MSTS sentence is decoded.
		 */
		if (tp->t_flags & (TS_TSTAMPDCDSET | TS_TSTAMPDCDCLR |
		    TS_TSTAMPCTSSET | TS_TSTAMPCTSCLR)) {
			tmax = lmax(np->ts.tv_sec, tp->t_tv.tv_sec);
			tmin = lmin(np->ts.tv_sec, tp->t_tv.tv_sec);
			if (tmax - tmin > 1)
				np->no_pps = 1;
			else {
				np->ts.tv_sec = tp->t_tv.tv_sec;
				np->ts.tv_nsec = tp->t_tv.tv_usec *
				    1000L;
				np->no_pps = 0;
			}
		}
		break;
	case 3:		/* ASCII <ETX> */
		if (!np->sync) {
			np->cbuf[np->pos] = '\0';
			msts_scan(np, tp);
			np->sync = 1;
		}
		break;
	default:
		if (!np->sync && np->pos < (MSTSMAX - 1))
			np->cbuf[np->pos++] = c;
		break;
	}
	/* pass data to termios */
	return linesw[TTYDISC].l_rint(c, tp);
}

/* Scan the MSTS sentence just received */
void
msts_scan(struct msts *np, struct tty *tp)
{
	int fldcnt = 0, n;
	char *fld[MAXFLDS], *cs;

	/* split into fields */
	fld[fldcnt++] = &np->cbuf[0];
	for (cs = NULL, n = 0; n < np->pos && cs == NULL; n++) {
		switch (np->cbuf[n]) {
		case 3:		/* ASCII <ETX> */
			np->cbuf[n] = '\0';
			cs = &np->cbuf[n + 1];
			break;
		case ';':
			if (fldcnt < MAXFLDS) {
				np->cbuf[n] = '\0';
				fld[fldcnt++] = &np->cbuf[n + 1];
			} else {
				DPRINTF(("nr of fields in sentence exceeds "
				    "maximum of %d\n", MAXFLDS));
				return;
			}
			break;
		}
	}
	msts_decode(np, tp, fld, fldcnt);
}

/* Decode the time string */
void
msts_decode(struct msts *np, struct tty *tp, char *fld[], int fldcnt)
{
	int64_t date_nano, time_nano, msts_now;
	int jumped = 0;

	if (fldcnt != MAXFLDS) {
		DPRINTF(("msts: field count mismatch, %d\n", fldcnt));
		return;
	}
	if (msts_time_to_nano(fld[2], &time_nano)) {
		DPRINTF(("msts: illegal time, %s\n", fld[2]));
		return;
	}
	if (msts_date_to_nano(fld[0], &date_nano)) {
		DPRINTF(("msts: illegal date, %s\n", fld[0]));
		return;
	}
	msts_now = date_nano + time_nano;
	if ( fld[3][2] == ' ' )		/* received time in CET */
		msts_now = msts_now - 3600 * 1000000000LL;
	if ( fld[3][2] == 'S' )		/* received time in CEST */
		msts_now = msts_now - 2 * 3600 * 1000000000LL;
	if (msts_now <= np->last) {
		DPRINTF(("msts: time not monotonically increasing\n"));
		jumped = 1;
	}
	np->last = msts_now;
	np->gap = 0LL;
#ifdef MSTS_DEBUG
	if (np->time.status == SENSOR_S_UNKNOWN) {
		np->time.status = SENSOR_S_OK;
		timeout_add_sec(&np->msts_tout, TRUSTTIME);
	}
#endif

	np->time.value = np->ts.tv_sec * 1000000000LL +
	    np->ts.tv_nsec - msts_now;
	np->time.tv.tv_sec = np->ts.tv_sec;
	np->time.tv.tv_usec = np->ts.tv_nsec / 1000L;
	if (np->time.status == SENSOR_S_UNKNOWN) {
		np->time.status = SENSOR_S_OK;
		np->time.flags &= ~SENSOR_FINVALID;
		strlcpy(np->time.desc, "MSTS", sizeof(np->time.desc));
	}
	/*
	 * only update the timeout if the clock reports the time a valid,
	 * the status is reported in fld[3][0] and fld[3][1] as follows:
	 * fld[3][0] == '#'				critical
	 * fld[3][0] == ' ' && fld[3][1] == '*'		warning
	 * fld[3][0] == ' ' && fld[3][1] == ' '		ok
	 */
	if (fld[3][0] == ' ' && fld[3][1] == ' ') {
		np->time.status = SENSOR_S_OK;
		np->signal.status = SENSOR_S_OK;
	} else
		np->signal.status = SENSOR_S_WARN;

	if (jumped)
		np->time.status = SENSOR_S_WARN;
	if (np->time.status == SENSOR_S_OK)
		timeout_add_sec(&np->msts_tout, TRUSTTIME);

	/*
	 * If tty timestamping is requested, but no PPS signal is present, set
	 * the sensor state to CRITICAL.
	 */
	if (np->no_pps)
		np->time.status = SENSOR_S_CRIT;
}

/*
 * Convert date field from MSTS to nanoseconds since the epoch.
 * The string must be of the form D:DD.MM.YY .
 * Return 0 on success, -1 if illegal characters are encountered.
 */
int
msts_date_to_nano(char *s, int64_t *nano)
{
	struct clock_ymdhms ymd;
	time_t secs;
	char *p;
	int n;

	if (s[0] != 'D' || s[1] != ':' || s[4] != '.' || s[7] != '.')
		return -1;

	/* shift numbers to DDMMYY */
	s[0]=s[2];
	s[1]=s[3];
	s[2]=s[5];
	s[3]=s[6];
	s[4]=s[8];
	s[5]=s[9];
	s[6]='\0';

	/* make sure the input contains only numbers and is six digits long */
	for (n = 0, p = s; n < 6 && *p && *p >= '0' && *p <= '9'; n++, p++)
		;
	if (n != 6 || (*p != '\0'))
		return -1;

	ymd.dt_year = 2000 + (s[4] - '0') * 10 + (s[5] - '0');
	ymd.dt_mon = (s[2] - '0') * 10 + (s[3] - '0');
	ymd.dt_day = (s[0] - '0') * 10 + (s[1] - '0');
	ymd.dt_hour = ymd.dt_min = ymd.dt_sec = 0;

	secs = clock_ymdhms_to_secs(&ymd);
	*nano = secs * 1000000000LL;
	return 0;
}

/*
 * Convert time field from MSTS to nanoseconds since midnight.
 * The string must be of the form U:HH.MM.SS .
 * Return 0 on success, -1 if illegal characters are encountered.
 */
int
msts_time_to_nano(char *s, int64_t *nano)
{
	long fac = 36000L, div = 6L, secs = 0L;
	char ul = '2';
	int n;

	if (s[0] != 'U' || s[1] != ':' || s[4] != '.' || s[7] != '.')
		return -1;

	/* shift numbers to HHMMSS */
	s[0]=s[2];
	s[1]=s[3];
	s[2]=s[5];
	s[3]=s[6];
	s[4]=s[8];
	s[5]=s[9];
	s[6]='\0';

	for (n = 0, secs = 0; fac && *s && *s >= '0' && *s <= ul; s++, n++) {
		secs += (*s - '0') * fac;
		div = 16 - div;
		fac /= div;
		switch (n) {
		case 0:
			if (*s <= '1')
				ul = '9';
			else
				ul = '3';
			break;
		case 1:
		case 3:
			ul = '5';
			break;
		case 2:
		case 4:
			ul = '9';
			break;
		}
	}
	if (fac)
		return -1;

	if (*s != '\0')
		return -1;

	*nano = secs * 1000000000LL;
	return 0;
}

/*
 * Degrade the sensor state if we received no MSTS string for more than
 * TRUSTTIME seconds.
 */
void
msts_timeout(void *xnp)
{
	struct msts *np = xnp;

	if (np->time.status == SENSOR_S_OK) {
		np->time.status = SENSOR_S_WARN;
		/*
		 * further degrade in TRUSTTIME seconds if no new valid MSTS
		 * strings are received.
		 */
		timeout_add_sec(&np->msts_tout, TRUSTTIME);
	} else
		np->time.status = SENSOR_S_CRIT;
}
@


1.19
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.18 2014/09/14 14:17:26 jsg Exp $ */
a39 3
int	mstsopen(dev_t, struct tty *, struct proc *);
int	mstsclose(struct tty *, int, struct proc *);
int	mstsinput(int, struct tty *);
@


1.18
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.17 2014/07/12 18:43:32 tedu Exp $ */
d119 1
a119 1
		free(np, M_DEVBUF, 0);
d137 1
a137 1
	free(np, M_DEVBUF, 0);
@


1.17
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.16 2010/04/12 12:57:52 tedu Exp $ */
a25 1
#include <sys/proc.h>
@


1.16
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.15 2009/06/02 21:17:35 ckuethe Exp $ */
d120 1
a120 1
		free(np, M_DEVBUF);
d138 1
a138 1
	free(np, M_DEVBUF);
@


1.15
log
@Add some extra protection against non-monotonic timestamps. ok stevesk
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.14 2009/05/06 16:05:20 stevesk Exp $ */
d41 2
a42 2
int	mstsopen(dev_t, struct tty *);
int	mstsclose(struct tty *, int);
d88 1
a88 1
mstsopen(dev_t dev, struct tty *tp)
a89 1
	struct proc *p = curproc;
d118 1
a118 1
	error = linesw[TTYDISC].l_open(dev, tp);
d131 1
a131 1
mstsclose(struct tty *tp, int flags)
d143 1
a143 1
	return linesw[TTYDISC].l_close(tp, flags);
@


1.14
log
@remove erroneous fldcnt test.  fldcnt can never be 13 here.  this is
apparently a leftover from tty_nmea.c
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.13 2009/04/26 02:25:36 cnst Exp $ */
d172 1
a172 1
	
d246 1
d267 1
a267 1
		return;
a296 1
		timeout_add_sec(&np->msts_tout, TRUSTTIME);
d299 5
@


1.13
log
@don't zero sensor .value and .flags immediately after the allocation w/ M_ZERO; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.12 2009/01/12 16:45:38 stevesk Exp $ */
d284 1
a284 2
		if (fldcnt != 13)
			strlcpy(np->time.desc, "MSTS", sizeof(np->time.desc));
@


1.12
log
@make compile with #define MSTS_DEBUG; ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.11 2009/01/12 15:54:13 stevesk Exp $ */
a112 1
	np->signal.flags = 0;
@


1.11
log
@1) remove invalid comment since first field is not message type
   in msts
2) modify debug string to not print first field (which is not
   the sentence message type)
ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.10 2009/01/12 15:19:28 stevesk Exp $ */
a275 1
	np->gapno = 0;
@


1.10
log
@comment should be epoch not midnight; ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.9 2009/01/01 02:10:54 stevesk Exp $ */
d220 1
a220 1
	fld[fldcnt++] = &np->cbuf[0];	/* message type */
d232 2
a233 2
				DPRINTF(("nr of fields in %s sentence exceeds "
				    "maximum of %d\n", fld[0], MAXFLDS));
@


1.9
log
@use #define MAXFLDS vs. 4 here; ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.8 2008/12/25 21:25:55 stevesk Exp $ */
d312 1
a312 1
 * Convert date field from MSTS to nanoseconds since midnight.
@


1.8
log
@don't need #include <sys/queue.h>; ok mbalmer@@
CVS ---------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.7 2008/12/25 21:14:07 stevesk Exp $ */
d248 1
a248 1
	if (fldcnt != 4) {
@


1.7
log
@remove unused struct member; ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.6 2008/12/25 21:04:36 stevesk Exp $ */
a25 1
#include <sys/queue.h>
@


1.6
log
@spelling in comments; ok mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.5 2008/09/10 14:01:23 blambert Exp $ */
a69 1
	char			mode;		/* GPS mode */
@


1.5
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.4 2008/06/11 17:11:36 mbalmer Exp $ */
d68 1
a68 1
	int			pos;		/* positon in rcv buffer */
d306 1
a306 1
	 * If tty timestamping is requested, but not PPS signal is present, set
@


1.4
log
@Don't use the reference count to create the sensor name; we can end up
with sensors with the same name.  The sensor name is now ever increasing
unless the reference count drops to zero, in which case the naming restarts
at zero as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.3 2008/05/06 08:51:44 mbalmer Exp $ */
a55 1
static int t_trust;
a93 1
	struct timeval t;
a128 5

		/* convert timevals to hz */
		t.tv_sec = TRUSTTIME;
		t.tv_usec = 0;
		t_trust = tvtohz(&t);
d276 1
a276 1
		timeout_add(&np->msts_tout, t_trust);
d301 1
a301 1
		timeout_add(&np->msts_tout, t_trust);
d424 1
a424 1
		timeout_add(&np->msts_tout, t_trust);
@


1.3
log
@Report the clock status in a signal sensor, like all other timedeltas.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.2 2008/01/06 13:11:51 mbalmer Exp $ */
d55 1
a55 1
int msts_count;	/* this is wrong, it should really be a SLIST */
d105 2
a106 1
	    msts_count++);
d152 2
@


1.2
log
@Degrade the sensor state from OK to WARNING and CRITICAL after periods of
ten minutes (same behaviour as nmea(4)).  If the cable is pulled, the sensor
no longer keeps the OK status forever.  Tested with a PEX511 as MSTS sender.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_msts.c,v 1.1 2008/01/05 17:33:28 mbalmer Exp $ */
d61 1
d112 8
d304 1
d306 3
a308 1
	}
@


1.1
log
@Add support for the Meinberg Standard Time String format that all Meinberg
radio clocks can transmit over serial ports.  This is implemented as a
line discipline similar to nmea(4) and provides a timedelta sensor.

See http://www.meinberg.de/english/specs/timestr.htm for details on the
MSTS format.

ldattach(8) is extended to support the "msts" line discipline and two stopbits
(which some radio clocks, e.g. the C51 use).  Do a "make includes" before your
next system build.

Initially from Maurice Janssen based on nmea(4).  "go for it" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d49 5
d56 1
d64 1
d94 1
d118 1
a118 1
	} else
d120 8
d137 1
d268 7
d286 8
a293 5
	if (fld[3][0] == '#')
		np->time.status = SENSOR_S_CRIT;
	else if (fld[3][0] == ' ' && fld[3][1] == '*')
		np->time.status = SENSOR_S_WARN;
	else if (fld[3][0] == ' ' && fld[3][1] == ' ')
d295 2
a296 3
	else
		DPRINTF(("msts: unknown clock status indication\n"));

d399 20
@

