head	1.140;
access;
symbols
	OPENBSD_6_1:1.140.0.4
	OPENBSD_6_1_BASE:1.140
	OPENBSD_6_0:1.126.0.2
	OPENBSD_6_0_BASE:1.126
	OPENBSD_5_9:1.119.0.2
	OPENBSD_5_9_BASE:1.119
	OPENBSD_5_8:1.116.0.4
	OPENBSD_5_8_BASE:1.116
	OPENBSD_5_7:1.112.0.2
	OPENBSD_5_7_BASE:1.112
	OPENBSD_5_6:1.100.0.4
	OPENBSD_5_6_BASE:1.100
	OPENBSD_5_5:1.94.0.4
	OPENBSD_5_5_BASE:1.94
	OPENBSD_5_4:1.93.0.2
	OPENBSD_5_4_BASE:1.93
	OPENBSD_5_3:1.90.0.2
	OPENBSD_5_3_BASE:1.90
	OPENBSD_5_2:1.86.0.2
	OPENBSD_5_2_BASE:1.86
	OPENBSD_5_1_BASE:1.85
	OPENBSD_5_1:1.85.0.4
	OPENBSD_5_0:1.85.0.2
	OPENBSD_5_0_BASE:1.85
	OPENBSD_4_9:1.78.0.2
	OPENBSD_4_9_BASE:1.78
	OPENBSD_4_8:1.76.0.2
	OPENBSD_4_8_BASE:1.76
	OPENBSD_4_7:1.72.0.2
	OPENBSD_4_7_BASE:1.72
	OPENBSD_4_6:1.70.0.4
	OPENBSD_4_6_BASE:1.70
	OPENBSD_4_5:1.67.0.2
	OPENBSD_4_5_BASE:1.67
	OPENBSD_4_4:1.66.0.2
	OPENBSD_4_4_BASE:1.66
	OPENBSD_4_3:1.61.0.4
	OPENBSD_4_3_BASE:1.61
	OPENBSD_4_2:1.61.0.2
	OPENBSD_4_2_BASE:1.61
	OPENBSD_4_1:1.56.0.2
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.54.0.2
	OPENBSD_4_0_BASE:1.54
	OPENBSD_3_9:1.53.0.2
	OPENBSD_3_9_BASE:1.53
	OPENBSD_3_8:1.49.0.8
	OPENBSD_3_8_BASE:1.49
	OPENBSD_3_7:1.49.0.6
	OPENBSD_3_7_BASE:1.49
	OPENBSD_3_6:1.49.0.4
	OPENBSD_3_6_BASE:1.49
	SMP_SYNC_A:1.49
	SMP_SYNC_B:1.49
	OPENBSD_3_5:1.49.0.2
	OPENBSD_3_5_BASE:1.49
	OPENBSD_3_4:1.48.0.2
	OPENBSD_3_4_BASE:1.48
	UBC_SYNC_A:1.46
	OPENBSD_3_3:1.44.0.2
	OPENBSD_3_3_BASE:1.44
	OPENBSD_3_2:1.41.0.2
	OPENBSD_3_2_BASE:1.41
	OPENBSD_3_1:1.38.0.2
	OPENBSD_3_1_BASE:1.38
	UBC_SYNC_B:1.42
	UBC:1.37.0.2
	UBC_BASE:1.37
	OPENBSD_3_0:1.35.0.2
	OPENBSD_3_0_BASE:1.35
	OPENBSD_2_9_BASE:1.31
	OPENBSD_2_9:1.31.0.2
	OPENBSD_2_8:1.29.0.6
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.29.0.4
	OPENBSD_2_7_BASE:1.29
	SMP:1.29.0.2
	SMP_BASE:1.29
	kame_19991208:1.28
	OPENBSD_2_6:1.27.0.2
	OPENBSD_2_6_BASE:1.27
	OPENBSD_2_5:1.24.0.2
	OPENBSD_2_5_BASE:1.24
	OPENBSD_2_4:1.22.0.2
	OPENBSD_2_4_BASE:1.22
	OPENBSD_2_3:1.21.0.2
	OPENBSD_2_3_BASE:1.21
	OPENBSD_2_2:1.19.0.4
	OPENBSD_2_2_BASE:1.19
	OPENBSD_2_1:1.19.0.2
	OPENBSD_2_1_BASE:1.19
	OPENBSD_2_0:1.17.0.2
	OPENBSD_2_0_BASE:1.17
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.140
date	2017.03.20.00.05.21;	author kettenis;	state Exp;
branches;
next	1.139;
commitid	5AdaXa4DzaAK7ctr;

1.139
date	2017.03.05.00.45.30;	author guenther;	state Exp;
branches;
next	1.138;
commitid	UrlMJQwoMZBUiRfc;

1.138
date	2017.02.11.06.07.03;	author guenther;	state Exp;
branches;
next	1.137;
commitid	OiBrAXwVwm2V8QBT;

1.137
date	2017.02.08.21.04.44;	author guenther;	state Exp;
branches;
next	1.136;
commitid	dEdzKLuJq1QhgX4y;

1.136
date	2017.02.08.05.09.25;	author guenther;	state Exp;
branches;
next	1.135;
commitid	V3fgN8BO1mri8xSU;

1.135
date	2017.02.08.05.02.05;	author guenther;	state Exp;
branches;
next	1.134;
commitid	uR8XQWNN9LjTR5UO;

1.134
date	2017.02.08.04.55.38;	author guenther;	state Exp;
branches;
next	1.133;
commitid	z9rtKyqjo3FR5OzW;

1.133
date	2017.02.08.04.47.23;	author guenther;	state Exp;
branches;
next	1.132;
commitid	1StVREQjzq1gi6QM;

1.132
date	2017.02.08.04.34.29;	author guenther;	state Exp;
branches;
next	1.131;
commitid	v6BJE4JNZ5jMnrCa;

1.131
date	2017.02.05.19.51.27;	author guenther;	state Exp;
branches;
next	1.130;
commitid	vqPd8QuxVqyeSGCl;

1.130
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.129;
commitid	CHRb0fCqa8XxUAMH;

1.129
date	2016.11.07.00.26.32;	author guenther;	state Exp;
branches;
next	1.128;
commitid	W7ztnDZwvjCaeQTS;

1.128
date	2016.10.05.02.31.52;	author guenther;	state Exp;
branches;
next	1.127;
commitid	z4axJxYMv8DhHpqn;

1.127
date	2016.09.12.00.35.54;	author schwarze;	state Exp;
branches;
next	1.126;
commitid	MAdLLMbNUvgQU5Cb;

1.126
date	2016.06.11.21.04.08;	author kettenis;	state Exp;
branches
	1.126.2.1;
next	1.125;
commitid	kR3Yh5rV7pC71Hgx;

1.125
date	2016.06.08.12.07.52;	author kettenis;	state Exp;
branches;
next	1.124;
commitid	5qA5Z4vgpR8Lymww;

1.124
date	2016.05.30.21.31.29;	author deraadt;	state Exp;
branches;
next	1.123;
commitid	KDWNECRaSEemSTKP;

1.123
date	2016.05.30.21.25.48;	author deraadt;	state Exp;
branches;
next	1.122;
commitid	EKR1QpDNmTXzcvJY;

1.122
date	2016.05.30.21.22.45;	author deraadt;	state Exp;
branches;
next	1.121;
commitid	WldUSxuLRn3bASy2;

1.121
date	2016.05.10.18.39.51;	author deraadt;	state Exp;
branches;
next	1.120;
commitid	qfOifNidEGDB2jL1;

1.120
date	2016.02.28.15.46.18;	author naddy;	state Exp;
branches;
next	1.119;
commitid	iOuZImHZRAr7Hvd6;

1.119
date	2015.11.02.16.31.55;	author semarie;	state Exp;
branches
	1.119.2.1;
next	1.118;
commitid	PyvdcQVr9G4daVnG;

1.118
date	2015.10.28.11.59.08;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	cmXCM716J87UXzJu;

1.117
date	2015.09.28.20.32.59;	author deraadt;	state Exp;
branches;
next	1.116;
commitid	frMdHMPeIFVK1Idn;

1.116
date	2015.04.30.11.15.28;	author jsg;	state Exp;
branches;
next	1.115;
commitid	xrgh9wMFdQFwoJrl;

1.115
date	2015.04.30.03.11.21;	author guenther;	state Exp;
branches;
next	1.114;
commitid	hQUe1A4Rh3T3SSGr;

1.114
date	2015.04.26.05.30.42;	author guenther;	state Exp;
branches;
next	1.113;
commitid	lR750nXdHDqAi0V2;

1.113
date	2015.03.30.21.08.38;	author miod;	state Exp;
branches;
next	1.112;
commitid	UIgWyHZZqklZyLUa;

1.112
date	2015.02.10.23.39.57;	author guenther;	state Exp;
branches
	1.112.2.1;
next	1.111;
commitid	UcxLcRiXennHhB5Q;

1.111
date	2015.02.06.23.58.12;	author deraadt;	state Exp;
branches;
next	1.110;
commitid	Xlq9pdSoAVoFugi1;

1.110
date	2015.01.27.00.33.21;	author kurt;	state Exp;
branches;
next	1.109;
commitid	v8MPl9rEzXSw3YMR;

1.109
date	2015.01.20.19.43.21;	author kettenis;	state Exp;
branches;
next	1.108;
commitid	Fn841MmVYz2JHvBP;

1.108
date	2014.12.22.15.05.24;	author kettenis;	state Exp;
branches;
next	1.107;
commitid	GIeODhiEAi4N6bCP;

1.107
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.106;
commitid	P6Av4XGqOi3rFasL;

1.106
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.105;
commitid	yv0ECmCdICvq576h;

1.105
date	2014.11.14.23.26.48;	author tedu;	state Exp;
branches;
next	1.104;
commitid	Xw9eD6Y0JOIFIwDy;

1.104
date	2014.11.06.17.31.19;	author tedu;	state Exp;
branches;
next	1.103;
commitid	RVGH534ZSw92CmGn;

1.103
date	2014.11.06.17.23.40;	author millert;	state Exp;
branches;
next	1.102;
commitid	RlEvPKWWXEepkehs;

1.102
date	2014.11.06.16.43.42;	author tedu;	state Exp;
branches;
next	1.101;
commitid	oUBdV3MVQSY3FRSw;

1.101
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.100;
commitid	3SGDR5EjcwE01W8S;

1.100
date	2014.07.13.23.59.58;	author tedu;	state Exp;
branches
	1.100.4.1;
next	1.99;
commitid	cj6Q9NwR5jhdT18r;

1.99
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.98;
commitid	QlVV51SZgNFxsXxC;

1.98
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.97;
commitid	EF98ch02VpFassUi;

1.97
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.96;

1.96
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.95;

1.95
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.94;

1.94
date	2014.01.21.01.48.44;	author tedu;	state Exp;
branches;
next	1.93;

1.93
date	2013.07.04.17.37.05;	author tedu;	state Exp;
branches;
next	1.92;

1.92
date	2013.06.02.16.41.37;	author guenther;	state Exp;
branches;
next	1.91;

1.91
date	2013.03.28.16.55.25;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2013.01.15.01.34.27;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2012.09.17.17.11.49;	author matthew;	state Exp;
branches;
next	1.88;

1.88
date	2012.09.11.15.44.19;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2012.08.20.23.25.07;	author matthew;	state Exp;
branches;
next	1.86;

1.86
date	2012.03.09.13.01.28;	author ariane;	state Exp;
branches;
next	1.85;

1.85
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.84;

1.84
date	2011.07.04.22.53.53;	author tedu;	state Exp;
branches;
next	1.83;

1.83
date	2011.06.06.17.10.23;	author ariane;	state Exp;
branches;
next	1.82;

1.82
date	2011.05.24.15.27.36;	author ariane;	state Exp;
branches;
next	1.81;

1.81
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.80;

1.80
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.79;

1.79
date	2011.04.05.12.50.15;	author guenther;	state Exp;
branches;
next	1.78;

1.78
date	2010.12.15.04.59.52;	author tedu;	state Exp;
branches;
next	1.77;

1.77
date	2010.09.17.14.03.09;	author mikeb;	state Exp;
branches;
next	1.76;

1.76
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2010.07.24.09.50.45;	author guenther;	state Exp;
branches;
next	1.74;

1.74
date	2010.06.29.00.28.14;	author tedu;	state Exp;
branches;
next	1.73;

1.73
date	2010.05.02.11.15.29;	author kettenis;	state Exp;
branches;
next	1.72;

1.72
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.71;

1.71
date	2009.11.19.02.36.27;	author guenther;	state Exp;
branches;
next	1.70;

1.70
date	2009.06.06.21.25.19;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2009.03.08.14.28.52;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2009.03.05.19.52.24;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2008.11.10.03.56.16;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2008.07.18.16.58.06;	author kurt;	state Exp;
branches;
next	1.65;

1.65
date	2008.06.12.17.02.04;	author miod;	state Exp;
branches;
next	1.64;

1.64
date	2008.06.12.04.33.37;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2008.06.07.17.19.28;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2008.06.04.21.12.50;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.05.28.23.10.10;	author beck;	state Exp;
branches;
next	1.60;

1.60
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2007.03.20.12.32.07;	author thib;	state Exp;
branches;
next	1.58;

1.58
date	2007.03.14.16.41.15;	author kettenis;	state Exp;
branches;
next	1.57;

1.57
date	2007.03.13.19.34.44;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.14.18.00.27;	author jmc;	state Exp;
branches;
next	1.54;

1.54
date	2006.07.10.20.00.08;	author kettenis;	state Exp;
branches;
next	1.53;

1.53
date	2006.01.19.17.54.47;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.07.04.18.47;	author aaron;	state Exp;
branches;
next	1.51;

1.51
date	2006.01.06.06.46.04;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2005.11.11.16.41.24;	author drahn;	state Exp;
branches;
next	1.49;

1.49
date	2003.11.03.19.58.22;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.21.18.56.07;	author tedu;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2003.05.17.14.02.06;	author grange;	state Exp;
branches;
next	1.46;

1.46
date	2003.05.13.16.39.23;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2003.04.16.21.17.52;	author drahn;	state Exp;
branches;
next	1.44;

1.44
date	2003.02.18.03.54.40;	author drahn;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2002.11.22.22.10.21;	author drahn;	state Exp;
branches;
next	1.42;

1.42
date	2002.10.06.22.39.25;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2002.09.23.01.41.09;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2002.09.18.22.07.50;	author drahn;	state Exp;
branches;
next	1.39;

1.39
date	2002.08.22.22.04.42;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2001.11.15.06.22.30;	author art;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.19.13.28.43;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.08.11.23.14.22;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.30.11.58.36;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.22.14.14.07;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2001.01.22.14.25.03;	author art;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2001.01.16.15.49.00;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2000.01.01.21.11.18;	author mickey;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	99.11.25.13.41.30;	author art;	state Exp;
branches;
next	1.27;

1.27
date	99.08.12.20.37.16;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	99.07.20.12.14.34;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	99.06.01.17.54.31;	author pefo;	state Exp;
branches;
next	1.24;

1.24
date	99.02.10.08.07.20;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.01.11.05.12.22;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	98.07.28.00.13.02;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	98.03.06.21.49.50;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	98.02.22.01.13.12;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	96.12.23.02.42.43;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.11.24.18.31.25;	author etheisen;	state Exp;
branches;
next	1.17;

1.17
date	96.09.12.18.52.17;	author pefo;	state Exp;
branches;
next	1.16;

1.16
date	96.09.12.14.43.30;	author pefo;	state Exp;
branches;
next	1.15;

1.15
date	96.09.05.17.31.06;	author pefo;	state Exp;
branches;
next	1.14;

1.14
date	96.08.31.09.24.07;	author pefo;	state Exp;
branches;
next	1.13;

1.13
date	96.08.05.10.48.18;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.06.16.20.05.08;	author etheisen;	state Exp;
branches;
next	1.11;

1.11
date	96.06.15.07.30.05;	author etheisen;	state Exp;
branches;
next	1.10;

1.10
date	96.06.10.03.39.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.06.10.00.48.59;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.06.09.20.47.13;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.06.07.39.37;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	96.05.22.07.44.28;	author etheisen;	state Exp;
branches;
next	1.5;

1.5
date	96.04.18.17.15.52;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.15.58.33;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.17.19.37;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.07.09.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches;
next	;

1.29.2.1
date	2001.05.14.22.32.38;	author niklas;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2001.07.04.10.48.12;	author niklas;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2001.10.31.03.26.28;	author nate;	state Exp;
branches;
next	1.29.2.4;

1.29.2.4
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.29.2.5;

1.29.2.5
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.29.2.6;

1.29.2.6
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.29.2.7;

1.29.2.7
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.29.2.8;

1.29.2.8
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.29.2.9;

1.29.2.9
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.29.2.10;

1.29.2.10
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.29.2.11;

1.29.2.11
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	;

1.31.2.1
date	2001.08.17.23.39.28;	author jason;	state Exp;
branches;
next	;

1.37.2.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.37.2.3;

1.37.2.3
date	2003.05.19.22.31.09;	author tedu;	state Exp;
branches;
next	;

1.44.2.1
date	2003.11.03.22.07.49;	author margarida;	state Exp;
branches;
next	;

1.48.2.1
date	2003.11.03.23.23.50;	author brad;	state Exp;
branches;
next	;

1.100.4.1
date	2015.04.30.19.30.14;	author guenther;	state Exp;
branches;
next	;
commitid	nTc2xLlxh1k14nHx;

1.112.2.1
date	2015.04.30.19.29.04;	author guenther;	state Exp;
branches;
next	;
commitid	mjxDH1MJLAGx9TR9;

1.119.2.1
date	2017.03.21.21.11.09;	author benno;	state Exp;
branches;
next	;
commitid	QrCTgbHlh59dRIV1;

1.126.2.1
date	2017.03.21.21.11.48;	author benno;	state Exp;
branches;
next	;
commitid	xiU0ohEXWy7HON6g;


desc
@@


1.140
log
@Initialize the stack buffer used to build the auxiliary vector to zero to
avoid leaking the contents of the kernel stack into userspace.

ok guenther@@, deraadt@@
@
text
@/*	$OpenBSD: exec_elf.c,v 1.139 2017/03/05 00:45:30 guenther Exp $	*/

/*
 * Copyright (c) 1996 Per Fogelstrom
 * All rights reserved.
 *
 * Copyright (c) 1994 Christos Zoulas
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Copyright (c) 2001 Wasabi Systems, Inc.
 * All rights reserved.
 *
 * Written by Jason R. Thorpe for Wasabi Systems, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project by
 *	Wasabi Systems, Inc.
 * 4. The name of Wasabi Systems, Inc. may not be used to endorse
 *    or promote products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/core.h>
#include <sys/syslog.h>
#include <sys/exec.h>
#include <sys/exec_elf.h>
#include <sys/file.h>
#include <sys/ptrace.h>
#include <sys/syscall.h>
#include <sys/signalvar.h>
#include <sys/stat.h>
#include <sys/pledge.h>

#include <sys/mman.h>

#include <uvm/uvm_extern.h>

#include <machine/reg.h>
#include <machine/exec.h>

int	elf_load_file(struct proc *, char *, struct exec_package *,
	    struct elf_args *);
int	elf_check_header(Elf_Ehdr *);
int	elf_read_from(struct proc *, struct vnode *, u_long, void *, int);
void	elf_load_psection(struct exec_vmcmd_set *, struct vnode *,
	    Elf_Phdr *, Elf_Addr *, Elf_Addr *, int *, int);
int	coredump_elf(struct proc *, void *);
void	*elf_copyargs(struct exec_package *, struct ps_strings *, void *,
	    void *);
int	exec_elf_fixup(struct proc *, struct exec_package *);
int	elf_os_pt_note(struct proc *, struct exec_package *, Elf_Ehdr *,
	    char *, size_t, size_t);

extern char sigcode[], esigcode[], sigcoderet[];
#ifdef SYSCALL_DEBUG
extern char *syscallnames[];
#endif

/* round up and down to page boundaries. */
#define ELF_ROUND(a, b)		(((a) + (b) - 1) & ~((b) - 1))
#define ELF_TRUNC(a, b)		((a) & ~((b) - 1))

/*
 * We limit the number of program headers to 32, this should
 * be a reasonable limit for ELF, the most we have seen so far is 12
 */
#define ELF_MAX_VALID_PHDR 32

/*
 * How many entries are in the AuxInfo array we pass to the process?
 */
#define ELF_AUX_ENTRIES	8

/*
 * This is the OpenBSD ELF emul
 */
struct emul emul_elf = {
	"native",
	NULL,
	sendsig,
	SYS_syscall,
	SYS_MAXSYSCALL,
	sysent,
#ifdef SYSCALL_DEBUG
	syscallnames,
#else
	NULL,
#endif
	(sizeof(AuxInfo) * ELF_AUX_ENTRIES / sizeof(char *)),
	elf_copyargs,
	setregs,
	exec_elf_fixup,
	coredump_elf,
	sigcode,
	esigcode,
	sigcoderet,
	EMUL_ENABLED | EMUL_NATIVE,
};

/*
 * Copy arguments onto the stack in the normal way, but add some
 * space for extra information in case of dynamic binding.
 */
void *
elf_copyargs(struct exec_package *pack, struct ps_strings *arginfo,
		void *stack, void *argp)
{
	stack = copyargs(pack, arginfo, stack, argp);
	if (!stack)
		return (NULL);

	/*
	 * Push space for extra arguments on the stack needed by
	 * dynamically linked binaries.
	 */
	if (pack->ep_emul_arg != NULL) {
		pack->ep_emul_argp = stack;
		stack = (char *)stack + ELF_AUX_ENTRIES * sizeof (AuxInfo);
	}
	return (stack);
}

/*
 * Check header for validity; return 0 for ok, ENOEXEC if error
 */
int
elf_check_header(Elf_Ehdr *ehdr)
{
	/*
	 * We need to check magic, class size, endianess, and version before
	 * we look at the rest of the Elf_Ehdr structure. These few elements
	 * are represented in a machine independent fashion.
	 */
	if (!IS_ELF(*ehdr) ||
	    ehdr->e_ident[EI_CLASS] != ELF_TARG_CLASS ||
	    ehdr->e_ident[EI_DATA] != ELF_TARG_DATA ||
	    ehdr->e_ident[EI_VERSION] != ELF_TARG_VER)
		return (ENOEXEC);

	/* Now check the machine dependent header */
	if (ehdr->e_machine != ELF_TARG_MACH ||
	    ehdr->e_version != ELF_TARG_VER)
		return (ENOEXEC);

	/* Don't allow an insane amount of sections. */
	if (ehdr->e_phnum > ELF_MAX_VALID_PHDR)
		return (ENOEXEC);

	return (0);
}

/*
 * Load a psection at the appropriate address
 */
void
elf_load_psection(struct exec_vmcmd_set *vcset, struct vnode *vp,
    Elf_Phdr *ph, Elf_Addr *addr, Elf_Addr *size, int *prot, int flags)
{
	u_long msize, lsize, psize, rm, rf;
	long diff, offset, bdiff;
	Elf_Addr base;

	/*
	 * If the user specified an address, then we load there.
	 */
	if (*addr != ELF_NO_ADDR) {
		if (ph->p_align > 1) {
			*addr = ELF_TRUNC(*addr, ph->p_align);
			diff = ph->p_vaddr - ELF_TRUNC(ph->p_vaddr, ph->p_align);
			/* page align vaddr */
			base = *addr + trunc_page(ph->p_vaddr) 
			    - ELF_TRUNC(ph->p_vaddr, ph->p_align);
		} else {
			diff = 0;
			base = *addr + trunc_page(ph->p_vaddr) - ph->p_vaddr;
		}
	} else {
		*addr = ph->p_vaddr;
		if (ph->p_align > 1)
			*addr = ELF_TRUNC(*addr, ph->p_align);
		base = trunc_page(ph->p_vaddr);
		diff = ph->p_vaddr - *addr;
	}
	bdiff = ph->p_vaddr - trunc_page(ph->p_vaddr);

	/*
	 * Enforce W^X and map W|X segments without X permission
	 * initially.  The dynamic linker will make these read-only
	 * and add back X permission after relocation processing.
	 * Static executables with W|X segments will probably crash.
	 */
	*prot |= (ph->p_flags & PF_R) ? PROT_READ : 0;
	*prot |= (ph->p_flags & PF_W) ? PROT_WRITE : 0;
	if ((ph->p_flags & PF_W) == 0)
		*prot |= (ph->p_flags & PF_X) ? PROT_EXEC : 0;

	msize = ph->p_memsz + diff;
	offset = ph->p_offset - bdiff;
	lsize = ph->p_filesz + bdiff;
	psize = round_page(lsize);

	/*
	 * Because the pagedvn pager can't handle zero fill of the last
	 * data page if it's not page aligned we map the last page readvn.
	 */
	if (ph->p_flags & PF_W) {
		psize = trunc_page(lsize);
		if (psize > 0)
			NEW_VMCMD2(vcset, vmcmd_map_pagedvn, psize, base, vp,
			    offset, *prot, flags);
		if (psize != lsize) {
			NEW_VMCMD2(vcset, vmcmd_map_readvn, lsize - psize,
			    base + psize, vp, offset + psize, *prot, flags);
		}
	} else {
		NEW_VMCMD2(vcset, vmcmd_map_pagedvn, psize, base, vp, offset,
		    *prot, flags);
	}

	/*
	 * Check if we need to extend the size of the segment
	 */
	rm = round_page(*addr + ph->p_memsz + diff);
	rf = round_page(*addr + ph->p_filesz + diff);

	if (rm != rf) {
		NEW_VMCMD2(vcset, vmcmd_map_zero, rm - rf, rf, NULLVP, 0,
		    *prot, flags);
	}
	*size = msize;
}

/*
 * Read from vnode into buffer at offset.
 */
int
elf_read_from(struct proc *p, struct vnode *vp, u_long off, void *buf,
    int size)
{
	int error;
	size_t resid;

	if ((error = vn_rdwr(UIO_READ, vp, buf, size, off, UIO_SYSSPACE,
	    0, p->p_ucred, &resid, p)) != 0)
		return error;
	/*
	 * See if we got all of it
	 */
	if (resid != 0)
		return (ENOEXEC);
	return (0);
}

/*
 * Load a file (interpreter/library) pointed to by path [stolen from
 * coff_load_shlib()]. Made slightly generic so it might be used externally.
 */
int
elf_load_file(struct proc *p, char *path, struct exec_package *epp,
    struct elf_args *ap)
{
	int error, i;
	struct nameidata nd;
	Elf_Ehdr eh;
	Elf_Phdr *ph = NULL;
	u_long phsize;
	Elf_Addr addr;
	struct vnode *vp;
	Elf_Phdr *base_ph = NULL;
	struct interp_ld_sec {
		Elf_Addr vaddr;
		u_long memsz;
	} loadmap[ELF_MAX_VALID_PHDR];
	int nload, idx = 0;
	Elf_Addr pos;
	int file_align;
	int loop;
	size_t randomizequota = ELF_RANDOMIZE_LIMIT;

	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_SYSSPACE, path, p);
	nd.ni_pledge = PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0) {
		return (error);
	}
	vp = nd.ni_vp;
	if (vp->v_type != VREG) {
		error = EACCES;
		goto bad;
	}
	if ((error = VOP_GETATTR(vp, epp->ep_vap, p->p_ucred, p)) != 0)
		goto bad;
	if (vp->v_mount->mnt_flag & MNT_NOEXEC) {
		error = EACCES;
		goto bad;
	}
	if ((error = VOP_ACCESS(vp, VREAD, p->p_ucred, p)) != 0)
		goto bad1;
	if ((error = elf_read_from(p, nd.ni_vp, 0, &eh, sizeof(eh))) != 0)
		goto bad1;

	if (elf_check_header(&eh) || eh.e_type != ET_DYN) {
		error = ENOEXEC;
		goto bad1;
	}

	ph = mallocarray(eh.e_phnum, sizeof(Elf_Phdr), M_TEMP, M_WAITOK);
	phsize = eh.e_phnum * sizeof(Elf_Phdr);

	if ((error = elf_read_from(p, nd.ni_vp, eh.e_phoff, ph, phsize)) != 0)
		goto bad1;

	for (i = 0; i < eh.e_phnum; i++) {
		if (ph[i].p_type == PT_LOAD) {
			if (ph[i].p_filesz > ph[i].p_memsz)
				goto bad1;
			loadmap[idx].vaddr = trunc_page(ph[i].p_vaddr);
			loadmap[idx].memsz = round_page (ph[i].p_vaddr +
			    ph[i].p_memsz - loadmap[idx].vaddr);
			file_align = ph[i].p_align;
			idx++;
		}
	}
	nload = idx;

	/*
	 * Load the interpreter where a non-fixed mmap(NULL, ...)
	 * would (i.e. something safely out of the way).
	 */
	pos = uvm_map_hint(p->p_vmspace, PROT_EXEC, VM_MIN_ADDRESS,
	    VM_MAXUSER_ADDRESS);
	pos = ELF_ROUND(pos, file_align);

	loop = 0;
	for (i = 0; i < nload;/**/) {
		vaddr_t	addr;
		struct	uvm_object *uobj;
		off_t	uoff;
		size_t	size;

#ifdef this_needs_fixing
		if (i == 0) {
			uobj = &vp->v_uvm.u_obj;
			/* need to fix uoff */
		} else {
#endif
			uobj = NULL;
			uoff = 0;
#ifdef this_needs_fixing
		}
#endif

		addr = trunc_page(pos + loadmap[i].vaddr);
		size =  round_page(addr + loadmap[i].memsz) - addr;

		/* CRAP - map_findspace does not avoid daddr+BRKSIZ */
		if ((addr + size > (vaddr_t)p->p_vmspace->vm_daddr) &&
		    (addr < (vaddr_t)p->p_vmspace->vm_daddr + BRKSIZ))
			addr = round_page((vaddr_t)p->p_vmspace->vm_daddr +
			    BRKSIZ);

		if (uvm_map_mquery(&p->p_vmspace->vm_map, &addr, size,
		    (i == 0 ? uoff : UVM_UNKNOWN_OFFSET), 0) != 0) {
			if (loop == 0) {
				loop = 1;
				i = 0;
				pos = 0;
				continue;
			}
			error = ENOMEM;
			goto bad1;
		}
		if (addr != pos + loadmap[i].vaddr) {
			/* base changed. */
			pos = addr - trunc_page(loadmap[i].vaddr);
			pos = ELF_ROUND(pos,file_align);
			i = 0;
			continue;
		}

		i++;
	}

	/*
	 * Load all the necessary sections
	 */
	for (i = 0; i < eh.e_phnum; i++) {
		Elf_Addr size = 0;
		int prot = 0;
		int flags;

		switch (ph[i].p_type) {
		case PT_LOAD:
			if (base_ph == NULL) {
				flags = VMCMD_BASE;
				addr = pos;
				base_ph = &ph[i];
			} else {
				flags = VMCMD_RELATIVE;
				addr = ph[i].p_vaddr - base_ph->p_vaddr;
			}
			elf_load_psection(&epp->ep_vmcmds, nd.ni_vp,
			    &ph[i], &addr, &size, &prot, flags);
			/* If entry is within this section it must be text */
			if (eh.e_entry >= ph[i].p_vaddr &&
			    eh.e_entry < (ph[i].p_vaddr + size)) {
 				epp->ep_entry = addr + eh.e_entry -
				    ELF_TRUNC(ph[i].p_vaddr,ph[i].p_align);
				if (flags == VMCMD_RELATIVE)
					epp->ep_entry += pos;
				ap->arg_interp = pos;
			}
			addr += size;
			break;

		case PT_DYNAMIC:
		case PT_PHDR:
		case PT_NOTE:
			break;

		case PT_OPENBSD_RANDOMIZE:
			if (ph[i].p_memsz > randomizequota) {
				error = ENOMEM;
				goto bad1;
			}
			randomizequota -= ph[i].p_memsz;
			NEW_VMCMD(&epp->ep_vmcmds, vmcmd_randomize,
			    ph[i].p_memsz, ph[i].p_vaddr + pos, NULLVP, 0, 0);
			break;

		default:
			break;
		}
	}

	vn_marktext(nd.ni_vp);

bad1:
	VOP_CLOSE(nd.ni_vp, FREAD, p->p_ucred, p);
bad:
	free(ph, M_TEMP, phsize);

	vput(nd.ni_vp);
	return (error);
}

/*
 * Prepare an Elf binary's exec package
 *
 * First, set of the various offsets/lengths in the exec package.
 *
 * Then, mark the text image busy (so it can be demand paged) or error out if
 * this is not possible.  Finally, set up vmcmds for the text, data, bss, and
 * stack segments.
 */
int
exec_elf_makecmds(struct proc *p, struct exec_package *epp)
{
	Elf_Ehdr *eh = epp->ep_hdr;
	Elf_Phdr *ph, *pp, *base_ph = NULL;
	Elf_Addr phdr = 0, exe_base = 0;
	int error, i, has_phdr = 0;
	char *interp = NULL;
	u_long phsize;
	size_t randomizequota = ELF_RANDOMIZE_LIMIT;

	if (epp->ep_hdrvalid < sizeof(Elf_Ehdr))
		return (ENOEXEC);

	if (elf_check_header(eh) ||
	   (eh->e_type != ET_EXEC && eh->e_type != ET_DYN))
		return (ENOEXEC);

	/*
	 * check if vnode is in open for writing, because we want to demand-
	 * page out of it.  if it is, don't do it, for various reasons.
	 */
	if (epp->ep_vp->v_writecount != 0) {
#ifdef DIAGNOSTIC
		if (epp->ep_vp->v_flag & VTEXT)
			panic("exec: a VTEXT vnode has writecount != 0");
#endif
		return (ETXTBSY);
	}
	/*
	 * Allocate space to hold all the program headers, and read them
	 * from the file
	 */
	ph = mallocarray(eh->e_phnum, sizeof(Elf_Phdr), M_TEMP, M_WAITOK);
	phsize = eh->e_phnum * sizeof(Elf_Phdr);

	if ((error = elf_read_from(p, epp->ep_vp, eh->e_phoff, ph,
	    phsize)) != 0)
		goto bad;

	epp->ep_tsize = ELF_NO_ADDR;
	epp->ep_dsize = ELF_NO_ADDR;

	for (i = 0, pp = ph; i < eh->e_phnum; i++, pp++) {
		if (pp->p_type == PT_INTERP && !interp) {
			if (pp->p_filesz < 2 || pp->p_filesz > MAXPATHLEN)
				goto bad;
			interp = pool_get(&namei_pool, PR_WAITOK);
			if ((error = elf_read_from(p, epp->ep_vp,
			    pp->p_offset, interp, pp->p_filesz)) != 0) {
				goto bad;
			}
			if (interp[pp->p_filesz - 1] != '\0')
				goto bad;
		} else if (pp->p_type == PT_LOAD) {
			if (pp->p_filesz > pp->p_memsz) {
				error = EINVAL;
				goto bad;
			}
			if (base_ph == NULL)
				base_ph = pp;
		} else if (pp->p_type == PT_PHDR) {
			has_phdr = 1;
		}
	}

	if (eh->e_type == ET_DYN) {
		/* need phdr and load sections for PIE */
		if (!has_phdr || base_ph == NULL) {
			error = EINVAL;
			goto bad;
		}
		/* randomize exe_base for PIE */
		exe_base = uvm_map_pie(base_ph->p_align);
	}

	/*
	 * OK, we want a slightly different twist of the
	 * standard emulation package for "real" elf.
	 */
	epp->ep_emul = &emul_elf;

	/*
	 * Verify this is an OpenBSD executable.  If it's marked that way
	 * via a PT_NOTE then also check for a PT_OPENBSD_WXNEEDED segment.
	 */
	if (eh->e_ident[EI_OSABI] != ELFOSABI_OPENBSD && (error =
	    elf_os_pt_note(p, epp, epp->ep_hdr, "OpenBSD", 8, 4)) != 0) {
		goto bad;
	}

	/*
	 * Load all the necessary sections
	 */
	for (i = 0, pp = ph; i < eh->e_phnum; i++, pp++) {
		Elf_Addr addr, size = 0;
		int prot = 0;
		int flags = 0;

		switch (pp->p_type) {
		case PT_LOAD:
			if (exe_base != 0) {
				if (pp == base_ph) {
					flags = VMCMD_BASE;
					addr = exe_base;
				} else {
					flags = VMCMD_RELATIVE;
					addr = pp->p_vaddr - base_ph->p_vaddr;
				}
			} else
				addr = ELF_NO_ADDR;

			/*
			 * Calculates size of text and data segments
			 * by starting at first and going to end of last.
			 * 'rwx' sections are treated as data.
			 * this is correct for BSS_PLT, but may not be
			 * for DATA_PLT, is fine for TEXT_PLT.
			 */
			elf_load_psection(&epp->ep_vmcmds, epp->ep_vp,
			    pp, &addr, &size, &prot, flags);

			/*
			 * Update exe_base in case alignment was off.
			 * For PIE, addr is relative to exe_base so
			 * adjust it (non PIE exe_base is 0 so no change).
			 */
			if (flags == VMCMD_BASE)
				exe_base = addr;
			else
				addr += exe_base;

			/*
			 * Decide whether it's text or data by looking
			 * at the protection of the section
			 */
			if (prot & PROT_WRITE) {
				/* data section */
				if (epp->ep_dsize == ELF_NO_ADDR) {
					epp->ep_daddr = addr;
					epp->ep_dsize = size;
				} else {
					if (addr < epp->ep_daddr) {
						epp->ep_dsize =
						    epp->ep_dsize +
						    epp->ep_daddr -
						    addr;
						epp->ep_daddr = addr;
					} else
						epp->ep_dsize = addr+size -
						    epp->ep_daddr;
				}
			} else if (prot & PROT_EXEC) {
				/* text section */
				if (epp->ep_tsize == ELF_NO_ADDR) {
					epp->ep_taddr = addr;
					epp->ep_tsize = size;
				} else {
					if (addr < epp->ep_taddr) {
						epp->ep_tsize =
						    epp->ep_tsize +
						    epp->ep_taddr -
						    addr;
						epp->ep_taddr = addr;
					} else
						epp->ep_tsize = addr+size -
						    epp->ep_taddr;
				}
			}
			break;

		case PT_SHLIB:
			error = ENOEXEC;
			goto bad;

		case PT_INTERP:
			/* Already did this one */
		case PT_DYNAMIC:
		case PT_NOTE:
			break;

		case PT_PHDR:
			/* Note address of program headers (in text segment) */
			phdr = pp->p_vaddr;
			break;

		case PT_OPENBSD_RANDOMIZE:
			if (ph[i].p_memsz > randomizequota) {
				error = ENOMEM;
				goto bad;
			}
			randomizequota -= ph[i].p_memsz;
			NEW_VMCMD(&epp->ep_vmcmds, vmcmd_randomize,
			    ph[i].p_memsz, ph[i].p_vaddr + exe_base, NULLVP, 0, 0);
			break;

		default:
			/*
			 * Not fatal, we don't need to understand everything
			 * :-)
			 */
			break;
		}
	}

	phdr += exe_base;

	/*
	 * Strangely some linux programs may have all load sections marked
	 * writeable, in this case, textsize is not -1, but rather 0;
	 */
	if (epp->ep_tsize == ELF_NO_ADDR)
		epp->ep_tsize = 0;
	/*
	 * Another possibility is that it has all load sections marked
	 * read-only.  Fake a zero-sized data segment right after the
	 * text segment.
	 */
	if (epp->ep_dsize == ELF_NO_ADDR) {
		epp->ep_daddr = round_page(epp->ep_taddr + epp->ep_tsize);
		epp->ep_dsize = 0;
	}

	epp->ep_interp = interp;
	epp->ep_entry = eh->e_entry + exe_base;

	/*
	 * Check if we found a dynamically linked binary and arrange to load
	 * its interpreter when the exec file is released.
	 */
	if (interp || eh->e_type == ET_DYN) {
		struct elf_args *ap;

		ap = malloc(sizeof(*ap), M_TEMP, M_WAITOK);

		ap->arg_phaddr = phdr;
		ap->arg_phentsize = eh->e_phentsize;
		ap->arg_phnum = eh->e_phnum;
		ap->arg_entry = eh->e_entry + exe_base;
		ap->arg_interp = exe_base;

		epp->ep_emul_arg = ap;
		epp->ep_emul_argsize = sizeof *ap;
	}

	free(ph, M_TEMP, phsize);
	vn_marktext(epp->ep_vp);
	return (exec_setup_stack(p, epp));

bad:
	if (interp)
		pool_put(&namei_pool, interp);
	free(ph, M_TEMP, phsize);
	kill_vmcmds(&epp->ep_vmcmds);
	if (error == 0)
		return (ENOEXEC);
	return (error);
}

/*
 * Phase II of load. It is now safe to load the interpreter. Info collected
 * when loading the program is available for setup of the interpreter.
 */
int
exec_elf_fixup(struct proc *p, struct exec_package *epp)
{
	char	*interp;
	int	error = 0;
	struct	elf_args *ap;
	AuxInfo ai[ELF_AUX_ENTRIES], *a;

	if (epp->ep_emul_arg == NULL) {
		return (0);
	}

	interp = epp->ep_interp;
	ap = epp->ep_emul_arg;

	if (interp &&
	    (error = elf_load_file(p, interp, epp, ap)) != 0) {
		free(ap, M_TEMP, epp->ep_emul_argsize);
		pool_put(&namei_pool, interp);
		kill_vmcmds(&epp->ep_vmcmds);
		return (error);
	}
	/*
	 * We have to do this ourselves...
	 */
	error = exec_process_vmcmds(p, epp);

	/*
	 * Push extra arguments on the stack needed by dynamically
	 * linked binaries
	 */
	if (error == 0) {
		memset(&ai, 0, sizeof ai);
		a = ai;

		a->au_id = AUX_phdr;
		a->au_v = ap->arg_phaddr;
		a++;

		a->au_id = AUX_phent;
		a->au_v = ap->arg_phentsize;
		a++;

		a->au_id = AUX_phnum;
		a->au_v = ap->arg_phnum;
		a++;

		a->au_id = AUX_pagesz;
		a->au_v = PAGE_SIZE;
		a++;

		a->au_id = AUX_base;
		a->au_v = ap->arg_interp;
		a++;

		a->au_id = AUX_flags;
		a->au_v = 0;
		a++;

		a->au_id = AUX_entry;
		a->au_v = ap->arg_entry;
		a++;

		a->au_id = AUX_null;
		a->au_v = 0;
		a++;

		error = copyout(ai, epp->ep_emul_argp, sizeof ai);
	}
	free(ap, M_TEMP, epp->ep_emul_argsize);
	if (interp)
		pool_put(&namei_pool, interp);
	return (error);
}

int
elf_os_pt_note(struct proc *p, struct exec_package *epp, Elf_Ehdr *eh,
    char *os_name, size_t name_size, size_t desc_size)
{
	char pathbuf[MAXPATHLEN];
	Elf_Phdr *hph, *ph;
	Elf_Note *np = NULL;
	size_t phsize;
	int error;

	hph = mallocarray(eh->e_phnum, sizeof(Elf_Phdr), M_TEMP, M_WAITOK);
	phsize = eh->e_phnum * sizeof(Elf_Phdr);
	if ((error = elf_read_from(p, epp->ep_vp, eh->e_phoff,
	    hph, phsize)) != 0)
		goto out1;

	for (ph = hph;  ph < &hph[eh->e_phnum]; ph++) {
		if (ph->p_type == PT_OPENBSD_WXNEEDED) {
			int wxallowed = (epp->ep_vp->v_mount &&
			    (epp->ep_vp->v_mount->mnt_flag & MNT_WXALLOWED));
			
			if (!wxallowed) {
				error = copyinstr(epp->ep_name, &pathbuf,
				    sizeof(pathbuf), NULL);
				log(LOG_NOTICE,
				    "%s(%d): W^X binary outside wxallowed mountpoint\n",
				    error ? "" : pathbuf, p->p_p->ps_pid);
				error = EACCES;
				goto out1;
			}
			epp->ep_flags |= EXEC_WXNEEDED;
			break;
		}
	}

	for (ph = hph;  ph < &hph[eh->e_phnum]; ph++) {
		if (ph->p_type != PT_NOTE ||
		    ph->p_filesz > 1024 ||
		    ph->p_filesz < sizeof(Elf_Note) + name_size)
			continue;

		np = malloc(ph->p_filesz, M_TEMP, M_WAITOK);
		if ((error = elf_read_from(p, epp->ep_vp, ph->p_offset,
		    np, ph->p_filesz)) != 0)
			goto out2;

#if 0
		if (np->type != ELF_NOTE_TYPE_OSVERSION) {
			free(np, M_TEMP, ph->p_filesz);
			np = NULL;
			continue;
		}
#endif

		/* Check the name and description sizes. */
		if (np->namesz != name_size ||
		    np->descsz != desc_size)
			goto out3;

		if (memcmp((np + 1), os_name, name_size))
			goto out3;

		/* XXX: We could check for the specific emulation here */
		/* All checks succeeded. */
		error = 0;
		goto out2;
	}

out3:
	error = ENOEXEC;
out2:
	free(np, M_TEMP, ph->p_filesz);
out1:
	free(hph, M_TEMP, phsize);
	return error;
}

/*
 * Start of routines related to dumping core
 */

#ifdef SMALL_KERNEL
int
coredump_elf(struct proc *p, void *cookie)
{
	return EPERM;
}
#else /* !SMALL_KERNEL */

struct writesegs_state {
	off_t	notestart;
	off_t	secstart;
	off_t	secoff;
	struct	proc *p;
	void	*iocookie;
	Elf_Phdr *psections;
	size_t	psectionslen;
	size_t	notesize;
	int	npsections;
};

uvm_coredump_setup_cb	coredump_setup_elf;
uvm_coredump_walk_cb	coredump_walk_elf;

int	coredump_notes_elf(struct proc *, void *, size_t *);
int	coredump_note_elf(struct proc *, void *, size_t *);
int	coredump_writenote_elf(struct proc *, void *, Elf_Note *,
	    const char *, void *);

#define	ELFROUNDSIZE	4	/* XXX Should it be sizeof(Elf_Word)? */
#define	elfround(x)	roundup((x), ELFROUNDSIZE)

int
coredump_elf(struct proc *p, void *cookie)
{
#ifdef DIAGNOSTIC
	off_t offset;
#endif
	struct writesegs_state ws;
	size_t notesize;
	int error, i;

	ws.p = p;
	ws.iocookie = cookie;
	ws.psections = NULL;

	/*
	 * Walk the map to get all the segment offsets and lengths,
	 * write out the ELF header.
	 */
	error = uvm_coredump_walkmap(p, coredump_setup_elf,
	    coredump_walk_elf, &ws);
	if (error)
		goto out;

	error = coredump_write(cookie, UIO_SYSSPACE, ws.psections,
	    ws.psectionslen);
	if (error)
		goto out;

	/* Write out the notes. */
	error = coredump_notes_elf(p, cookie, &notesize);
	if (error)
		goto out;

#ifdef DIAGNOSTIC
	if (notesize != ws.notesize)
		panic("coredump: notesize changed: %zu != %zu",
		    ws.notesize, notesize);
	offset = ws.notestart + notesize;
	if (offset != ws.secstart)
		panic("coredump: offset %lld != secstart %lld",
		    (long long) offset, (long long) ws.secstart);
#endif

	/* Pass 3: finally, write the sections themselves. */
	for (i = 0; i < ws.npsections - 1; i++) {
		Elf_Phdr *pent = &ws.psections[i];
		if (pent->p_filesz == 0)
			continue;

#ifdef DIAGNOSTIC
		if (offset != pent->p_offset)
			panic("coredump: offset %lld != p_offset[%d] %lld",
			    (long long) offset, i,
			    (long long) pent->p_filesz);
#endif

		error = coredump_write(cookie, UIO_USERSPACE,
		    (void *)(vaddr_t)pent->p_vaddr, pent->p_filesz);
		if (error)
			goto out;

		coredump_unmap(cookie, (vaddr_t)pent->p_vaddr,
		    (vaddr_t)pent->p_vaddr + pent->p_filesz);

#ifdef DIAGNOSTIC
		offset += ws.psections[i].p_filesz;
#endif
	}

out:
	free(ws.psections, M_TEMP, ws.psectionslen);
	return (error);
}



int
coredump_setup_elf(int segment_count, void *cookie)
{
	Elf_Ehdr ehdr;
	struct writesegs_state *ws = cookie;
	Elf_Phdr *note;
	int error;

	/* Get the count of segments, plus one for the PT_NOTE */
	ws->npsections = segment_count + 1;

	/* Get the size of the notes. */
	error = coredump_notes_elf(ws->p, NULL, &ws->notesize);
	if (error)
		return error;

	/* Setup the ELF header */
	memset(&ehdr, 0, sizeof(ehdr));
	memcpy(ehdr.e_ident, ELFMAG, SELFMAG);
	ehdr.e_ident[EI_CLASS] = ELF_TARG_CLASS;
	ehdr.e_ident[EI_DATA] = ELF_TARG_DATA;
	ehdr.e_ident[EI_VERSION] = EV_CURRENT;
	/* XXX Should be the OSABI/ABI version of the executable. */
	ehdr.e_ident[EI_OSABI] = ELFOSABI_SYSV;
	ehdr.e_ident[EI_ABIVERSION] = 0;
	ehdr.e_type = ET_CORE;
	/* XXX This should be the e_machine of the executable. */
	ehdr.e_machine = ELF_TARG_MACH;
	ehdr.e_version = EV_CURRENT;
	ehdr.e_entry = 0;
	ehdr.e_phoff = sizeof(ehdr);
	ehdr.e_shoff = 0;
	ehdr.e_flags = 0;
	ehdr.e_ehsize = sizeof(ehdr);
	ehdr.e_phentsize = sizeof(Elf_Phdr);
	ehdr.e_phnum = ws->npsections;
	ehdr.e_shentsize = 0;
	ehdr.e_shnum = 0;
	ehdr.e_shstrndx = 0;

	/* Write out the ELF header. */
	error = coredump_write(ws->iocookie, UIO_SYSSPACE, &ehdr, sizeof(ehdr));
	if (error)
		return error;

	/*
	 * Allocate the segment header array and setup to collect
	 * the section sizes and offsets
	 */
	ws->psections = mallocarray(ws->npsections, sizeof(Elf_Phdr),
	    M_TEMP, M_WAITOK|M_ZERO);
	ws->psectionslen = ws->npsections * sizeof(Elf_Phdr);

	ws->notestart = sizeof(ehdr) + ws->psectionslen;
	ws->secstart = ws->notestart + ws->notesize;
	ws->secoff = ws->secstart;

	/* Fill in the PT_NOTE segment header in the last slot */
	note = &ws->psections[ws->npsections - 1];
	note->p_type = PT_NOTE;
	note->p_offset = ws->notestart;
	note->p_vaddr = 0;
	note->p_paddr = 0;
	note->p_filesz = ws->notesize;
	note->p_memsz = 0;
	note->p_flags = PF_R;
	note->p_align = ELFROUNDSIZE;

	return (0);
}

int
coredump_walk_elf(vaddr_t start, vaddr_t realend, vaddr_t end, vm_prot_t prot,
    int nsegment, void *cookie)
{
	struct writesegs_state *ws = cookie;
	Elf_Phdr phdr;
	vsize_t size, realsize;

	size = end - start;
	realsize = realend - start;

	phdr.p_type = PT_LOAD;
	phdr.p_offset = ws->secoff;
	phdr.p_vaddr = start;
	phdr.p_paddr = 0;
	phdr.p_filesz = realsize;
	phdr.p_memsz = size;
	phdr.p_flags = 0;
	if (prot & PROT_READ)
		phdr.p_flags |= PF_R;
	if (prot & PROT_WRITE)
		phdr.p_flags |= PF_W;
	if (prot & PROT_EXEC)
		phdr.p_flags |= PF_X;
	phdr.p_align = PAGE_SIZE;

	ws->secoff += phdr.p_filesz;
	ws->psections[nsegment] = phdr;

	return (0);
}

int
coredump_notes_elf(struct proc *p, void *iocookie, size_t *sizep)
{
	struct ps_strings pss;
	struct iovec iov;
	struct uio uio;
	struct elfcore_procinfo cpi;
	Elf_Note nhdr;
	struct process *pr = p->p_p;
	struct proc *q;
	size_t size, notesize;
	int error;

	size = 0;

	/* First, write an elfcore_procinfo. */
	notesize = sizeof(nhdr) + elfround(sizeof("OpenBSD")) +
	    elfround(sizeof(cpi));
	if (iocookie) {
		memset(&cpi, 0, sizeof(cpi));

		cpi.cpi_version = ELFCORE_PROCINFO_VERSION;
		cpi.cpi_cpisize = sizeof(cpi);
		cpi.cpi_signo = p->p_sisig;
		cpi.cpi_sigcode = p->p_sicode;

		cpi.cpi_sigpend = p->p_siglist;
		cpi.cpi_sigmask = p->p_sigmask;
		cpi.cpi_sigignore = pr->ps_sigacts->ps_sigignore;
		cpi.cpi_sigcatch = pr->ps_sigacts->ps_sigcatch;

		cpi.cpi_pid = pr->ps_pid;
		cpi.cpi_ppid = pr->ps_pptr->ps_pid;
		cpi.cpi_pgrp = pr->ps_pgid;
		if (pr->ps_session->s_leader)
			cpi.cpi_sid = pr->ps_session->s_leader->ps_pid;
		else
			cpi.cpi_sid = 0;

		cpi.cpi_ruid = p->p_ucred->cr_ruid;
		cpi.cpi_euid = p->p_ucred->cr_uid;
		cpi.cpi_svuid = p->p_ucred->cr_svuid;

		cpi.cpi_rgid = p->p_ucred->cr_rgid;
		cpi.cpi_egid = p->p_ucred->cr_gid;
		cpi.cpi_svgid = p->p_ucred->cr_svgid;

		(void)strlcpy(cpi.cpi_name, pr->ps_comm, sizeof(cpi.cpi_name));

		nhdr.namesz = sizeof("OpenBSD");
		nhdr.descsz = sizeof(cpi);
		nhdr.type = NT_OPENBSD_PROCINFO;

		error = coredump_writenote_elf(p, iocookie, &nhdr,
		    "OpenBSD", &cpi);
		if (error)
			return (error);
	}
	size += notesize;

	/* Second, write an NT_OPENBSD_AUXV note. */
	notesize = sizeof(nhdr) + elfround(sizeof("OpenBSD")) +
	    elfround(pr->ps_emul->e_arglen * sizeof(char *));
	if (iocookie) {
		iov.iov_base = &pss;
		iov.iov_len = sizeof(pss);
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_offset = (off_t)pr->ps_strings;
		uio.uio_resid = sizeof(pss);
		uio.uio_segflg = UIO_SYSSPACE;
		uio.uio_rw = UIO_READ;
		uio.uio_procp = NULL;

		error = uvm_io(&p->p_vmspace->vm_map, &uio, 0);
		if (error)
			return (error);

		if (pss.ps_envstr == NULL)
			return (EIO);

		nhdr.namesz = sizeof("OpenBSD");
		nhdr.descsz = pr->ps_emul->e_arglen * sizeof(char *);
		nhdr.type = NT_OPENBSD_AUXV;

		error = coredump_write(iocookie, UIO_SYSSPACE,
		    &nhdr, sizeof(nhdr));
		if (error)
			return (error);

		error = coredump_write(iocookie, UIO_SYSSPACE,
		    "OpenBSD", elfround(nhdr.namesz));
		if (error)
			return (error);

		error = coredump_write(iocookie, UIO_USERSPACE,
		    pss.ps_envstr + pss.ps_nenvstr + 1, nhdr.descsz);
		if (error)
			return (error);
	}
	size += notesize;

#ifdef PT_WCOOKIE
	notesize = sizeof(nhdr) + elfround(sizeof("OpenBSD")) +
	    elfround(sizeof(register_t));
	if (iocookie) {
		register_t wcookie;

		nhdr.namesz = sizeof("OpenBSD");
		nhdr.descsz = sizeof(register_t);
		nhdr.type = NT_OPENBSD_WCOOKIE;

		wcookie = process_get_wcookie(p);
		error = coredump_writenote_elf(p, iocookie, &nhdr,
		    "OpenBSD", &wcookie);
		if (error)
			return (error);
	}
	size += notesize;
#endif

	/*
	 * Now write the register info for the thread that caused the
	 * coredump.
	 */
	error = coredump_note_elf(p, iocookie, &notesize);
	if (error)
		return (error);
	size += notesize;

	/*
	 * Now, for each thread, write the register info and any other
	 * per-thread notes.  Since we're dumping core, all the other
	 * threads in the process have been stopped and the list can't
	 * change.
	 */
	TAILQ_FOREACH(q, &pr->ps_threads, p_thr_link) {
		if (q == p)		/* we've taken care of this thread */
			continue;
		error = coredump_note_elf(q, iocookie, &notesize);
		if (error)
			return (error);
		size += notesize;
	}

	*sizep = size;
	return (0);
}

int
coredump_note_elf(struct proc *p, void *iocookie, size_t *sizep)
{
	Elf_Note nhdr;
	int size, notesize, error;
	int namesize;
	char name[64+ELFROUNDSIZE];
	struct reg intreg;
#ifdef PT_GETFPREGS
	struct fpreg freg;
#endif

	size = 0;

	snprintf(name, sizeof(name)-ELFROUNDSIZE, "%s@@%d",
	    "OpenBSD", p->p_tid + THREAD_PID_OFFSET);
	namesize = strlen(name) + 1;
	memset(name + namesize, 0, elfround(namesize) - namesize);

	notesize = sizeof(nhdr) + elfround(namesize) + elfround(sizeof(intreg));
	if (iocookie) {
		error = process_read_regs(p, &intreg);
		if (error)
			return (error);

		nhdr.namesz = namesize;
		nhdr.descsz = sizeof(intreg);
		nhdr.type = NT_OPENBSD_REGS;

		error = coredump_writenote_elf(p, iocookie, &nhdr,
		    name, &intreg);
		if (error)
			return (error);

	}
	size += notesize;

#ifdef PT_GETFPREGS
	notesize = sizeof(nhdr) + elfround(namesize) + elfround(sizeof(freg));
	if (iocookie) {
		error = process_read_fpregs(p, &freg);
		if (error)
			return (error);

		nhdr.namesz = namesize;
		nhdr.descsz = sizeof(freg);
		nhdr.type = NT_OPENBSD_FPREGS;

		error = coredump_writenote_elf(p, iocookie, &nhdr, name, &freg);
		if (error)
			return (error);
	}
	size += notesize;
#endif

	*sizep = size;
	/* XXX Add hook for machdep per-LWP notes. */
	return (0);
}

int
coredump_writenote_elf(struct proc *p, void *cookie, Elf_Note *nhdr,
    const char *name, void *data)
{
	int error;

	error = coredump_write(cookie, UIO_SYSSPACE, nhdr, sizeof(*nhdr));
	if (error)
		return error;

	error = coredump_write(cookie, UIO_SYSSPACE, name,
	    elfround(nhdr->namesz));
	if (error)
		return error;

	return coredump_write(cookie, UIO_SYSSPACE, data, nhdr->descsz);
}
#endif /* !SMALL_KERNEL */
@


1.139
log
@Generating a coredump requires walking the map twice; change
uvm_coredump_walkmap() to do both with a callback in between
so it can hold locks/change state across the two.

ok stefan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.138 2017/02/11 06:07:03 guenther Exp $	*/
d805 1
@


1.138
log
@Correct the entry point and base address calculations for an
interpreter whose entry point isn't in its first PT_LOAD segment.

problem report and testing by patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.137 2017/02/08 21:04:44 guenther Exp $	*/
a935 8

struct countsegs_state {
	int	npsections;
};

int	coredump_countsegs_elf(struct proc *, void *,
	    struct uvm_coredump_state *);

d937 5
d943 3
a945 1
	off_t	secoff;
d948 2
a949 2
int	coredump_writeseghdrs_elf(struct proc *, void *,
	    struct uvm_coredump_state *);
d962 3
a964 3
	Elf_Ehdr ehdr;
	Elf_Phdr *psections = NULL;
	struct countsegs_state cs;
d966 1
a966 2
	off_t notestart, secstart, offset;
	size_t notesize, psectionslen;
d969 4
d974 2
a975 8
	 * We have to make a total of 3 passes across the map:
	 *
	 *	1. Count the number of map entries (the number of
	 *	   PT_LOAD sections).
	 *
	 *	2. Write the P-section headers.
	 *
	 *	3. Write the P-sections.
d977 2
a978 4

	/* Pass 1: count the entries. */
	cs.npsections = 0;
	error = uvm_coredump_walkmap(p, NULL, coredump_countsegs_elf, &cs);
d982 2
a983 5
	/* Count the PT_NOTE section. */
	cs.npsections++;

	/* Get the size of the notes. */
	error = coredump_notes_elf(p, NULL, &notesize);
a986 64
	memset(&ehdr, 0, sizeof(ehdr));
	memcpy(ehdr.e_ident, ELFMAG, SELFMAG);
	ehdr.e_ident[EI_CLASS] = ELF_TARG_CLASS;
	ehdr.e_ident[EI_DATA] = ELF_TARG_DATA;
	ehdr.e_ident[EI_VERSION] = EV_CURRENT;
	/* XXX Should be the OSABI/ABI version of the executable. */
	ehdr.e_ident[EI_OSABI] = ELFOSABI_SYSV;
	ehdr.e_ident[EI_ABIVERSION] = 0;
	ehdr.e_type = ET_CORE;
	/* XXX This should be the e_machine of the executable. */
	ehdr.e_machine = ELF_TARG_MACH;
	ehdr.e_version = EV_CURRENT;
	ehdr.e_entry = 0;
	ehdr.e_phoff = sizeof(ehdr);
	ehdr.e_shoff = 0;
	ehdr.e_flags = 0;
	ehdr.e_ehsize = sizeof(ehdr);
	ehdr.e_phentsize = sizeof(Elf_Phdr);
	ehdr.e_phnum = cs.npsections;
	ehdr.e_shentsize = 0;
	ehdr.e_shnum = 0;
	ehdr.e_shstrndx = 0;

	/* Write out the ELF header. */
	error = coredump_write(cookie, UIO_SYSSPACE, &ehdr, sizeof(ehdr));
	if (error)
		goto out;

	psections = mallocarray(cs.npsections, sizeof(Elf_Phdr),
	    M_TEMP, M_WAITOK|M_ZERO);
	psectionslen = cs.npsections * sizeof(Elf_Phdr);

	offset = sizeof(ehdr);
	notestart = offset + psectionslen;
	secstart = notestart + notesize;

	/* Pass 2: now write the P-section headers. */
	ws.secoff = secstart;
	ws.psections = psections;
	error = uvm_coredump_walkmap(p, cookie, coredump_writeseghdrs_elf, &ws);
	if (error)
		goto out;

	/* Write out the PT_NOTE header. */
	ws.psections->p_type = PT_NOTE;
	ws.psections->p_offset = notestart;
	ws.psections->p_vaddr = 0;
	ws.psections->p_paddr = 0;
	ws.psections->p_filesz = notesize;
	ws.psections->p_memsz = 0;
	ws.psections->p_flags = PF_R;
	ws.psections->p_align = ELFROUNDSIZE;

	error = coredump_write(cookie, UIO_SYSSPACE, psections, psectionslen);
	if (error)
		goto out;

#ifdef DIAGNOSTIC
	offset += psectionslen;
	if (offset != notestart)
		panic("coredump: offset %lld != notestart %lld",
		    (long long) offset, (long long) notestart);
#endif

d993 5
a997 2
	offset += notesize;
	if (offset != secstart)
d999 1
a999 1
		    (long long) offset, (long long) secstart);
d1003 3
a1005 2
	for (i = 0; i < cs.npsections - 1; i++) {
		if (psections[i].p_filesz == 0)
d1009 1
a1009 1
		if (offset != psections[i].p_offset)
d1012 1
a1012 1
			    (long long) psections[i].p_filesz);
d1016 1
a1016 2
		    (void *)(vaddr_t)psections[i].p_vaddr,
		    psections[i].p_filesz);
d1020 2
a1021 2
		coredump_unmap(cookie, (vaddr_t)psections[i].p_vaddr,
		    (vaddr_t)psections[i].p_vaddr + psections[i].p_filesz);
d1024 1
a1024 1
		offset += psections[i].p_filesz;
d1029 1
a1029 1
	free(psections, M_TEMP, psectionslen);
d1033 2
d1036 1
a1036 2
coredump_countsegs_elf(struct proc *p, void *iocookie,
    struct uvm_coredump_state *us)
d1038 64
a1101 1
	struct countsegs_state *cs = us->cookie;
a1102 1
	cs->npsections++;
d1107 2
a1108 2
coredump_writeseghdrs_elf(struct proc *p, void *iocookie,
    struct uvm_coredump_state *us)
d1110 1
a1110 1
	struct writesegs_state *ws = us->cookie;
d1114 2
a1115 2
	size = us->end - us->start;
	realsize = us->realend - us->start;
d1119 1
a1119 1
	phdr.p_vaddr = us->start;
d1124 1
a1124 1
	if (us->prot & PROT_READ)
d1126 1
a1126 1
	if (us->prot & PROT_WRITE)
d1128 1
a1128 1
	if (us->prot & PROT_EXEC)
d1133 1
a1133 1
	*ws->psections++ = phdr;
@


1.137
log
@Remove support for forcing the ELF interpreter to a specific address,
last used by COMPAT_SYSV which was removed in 2011.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.136 2017/02/08 05:09:25 guenther Exp $	*/
d463 3
a465 1
				ap->arg_interp = addr;
@


1.136
log
@In exec_elf.c: expand ELFNAME(), ELFNAME2(), and ELFNAMEEND() except
leaving out the size, so that
	ELFNAME2(exec,makecmds)
becomes
	exec_elf_makecmds
instead of
	exec_elf{32,64}_makecmds
and then delete the ELFNAME2() and ELFNAMEEND() macros.

Move the prototypes for functions local to exec_elf.c to there from
exec_elf.h.

Simplify the SMALL_KERNEL conditionals around the ELF coredump code.

Change exec_conf.c to use the size-generic names and macros

Remove exec_elf{32,64}.c and just build exec_elf.c; delete the
_KERN_DO_ELF and _KERN_DO_ELF64 #defines.

ok jca@@, encouragement from deraadt@@ and tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.135 2017/02/08 05:02:05 guenther Exp $	*/
d97 1
a97 1
	    struct elf_args *, Elf_Addr *);
d315 1
a315 1
    struct elf_args *ap, Elf_Addr *last)
d330 1
a330 1
	Elf_Addr pos = *last;
d381 1
a381 2
	 * If no position to load the interpreter was set by a probe
	 * function, pick the same address that a non-fixed mmap(0, ..)
d384 3
a386 4
	if (pos == ELF_NO_ADDR) {
		pos = uvm_map_hint(p->p_vmspace, PROT_EXEC,
		    VM_MIN_ADDRESS, VM_MAXUSER_ADDRESS);
	}
a387 2
	pos = ELF_ROUND(pos, file_align);
	*last = epp->ep_interp_pos = pos;
d421 1
a421 1
				*last = epp->ep_interp_pos = pos = 0;
a430 1
			epp->ep_interp_pos = *last = pos;
d450 1
a450 1
				addr = *last;
a494 1
	*last = addr;
d516 1
a516 1
	u_long pos = 0, phsize;
a588 1
	pos = ELF_NO_ADDR;
a750 1
		epp->ep_interp_pos = pos;
a777 1
	Elf_Addr	pos = epp->ep_interp_pos;
d787 1
a787 1
	    (error = elf_load_file(p, interp, epp, ap, &pos)) != 0) {
@


1.135
log
@Move ELF_AUX_ENTRIES from exec_elf.h to exec_elf.c; it's totally internal
and not something we guarantee to userspace

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.134 2017/02/08 04:55:38 guenther Exp $	*/
d96 12
a107 7
int ELFNAME(load_file)(struct proc *, char *, struct exec_package *,
	struct elf_args *, Elf_Addr *);
int ELFNAME(check_header)(Elf_Ehdr *);
int ELFNAME(read_from)(struct proc *, struct vnode *, u_long, void *, int);
void ELFNAME(load_psection)(struct exec_vmcmd_set *, struct vnode *,
	Elf_Phdr *, Elf_Addr *, Elf_Addr *, int *, int);
int ELFNAMEEND(coredump)(struct proc *, void *);
d132 1
a132 1
struct emul ELFNAMEEND(emul) = {
d145 1
a145 1
	ELFNAME(copyargs),
d147 2
a148 2
	ELFNAME2(exec,fixup),
	ELFNAMEEND(coredump),
d160 1
a160 1
ELFNAME(copyargs)(struct exec_package *pack, struct ps_strings *arginfo,
d182 1
a182 1
ELFNAME(check_header)(Elf_Ehdr *ehdr)
d211 2
a212 2
ELFNAME(load_psection)(struct exec_vmcmd_set *vcset, struct vnode *vp,
	Elf_Phdr *ph, Elf_Addr *addr, Elf_Addr *size, int *prot, int flags)
d292 2
a293 2
ELFNAME(read_from)(struct proc *p, struct vnode *vp, u_long off, void *buf,
	int size)
d314 2
a315 2
ELFNAME(load_file)(struct proc *p, char *path, struct exec_package *epp,
	struct elf_args *ap, Elf_Addr *last)
d353 1
a353 1
	if ((error = ELFNAME(read_from)(p, nd.ni_vp, 0, &eh, sizeof(eh))) != 0)
d356 1
a356 1
	if (ELFNAME(check_header)(&eh) || eh.e_type != ET_DYN) {
d364 1
a364 2
	if ((error = ELFNAME(read_from)(p, nd.ni_vp, eh.e_phoff, ph,
	    phsize)) != 0)
d461 1
a461 1
			ELFNAME(load_psection)(&epp->ep_vmcmds, nd.ni_vp,
d515 1
a515 1
ELFNAME2(exec,makecmds)(struct proc *p, struct exec_package *epp)
d528 1
a528 1
	if (ELFNAME(check_header)(eh) ||
d550 1
a550 1
	if ((error = ELFNAME(read_from)(p, epp->ep_vp, eh->e_phoff, ph,
d562 1
a562 1
			if ((error = ELFNAME(read_from)(p, epp->ep_vp,
d594 1
a594 1
	epp->ep_emul = &ELFNAMEEND(emul);
d602 1
a602 1
	    ELFNAME(os_pt_note)(p, epp, epp->ep_hdr, "OpenBSD", 8, 4)) != 0) {
d634 1
a634 1
			ELFNAME(load_psection)(&epp->ep_vmcmds, epp->ep_vp,
d780 1
a780 1
ELFNAME2(exec,fixup)(struct proc *p, struct exec_package *epp)
d796 1
a796 1
	    (error = ELFNAME(load_file)(p, interp, epp, ap, &pos)) != 0) {
d855 2
a856 2
ELFNAME(os_pt_note)(struct proc *p, struct exec_package *epp, Elf_Ehdr *eh,
	char *os_name, size_t name_size, size_t desc_size)
d866 1
a866 1
	if ((error = ELFNAME(read_from)(p, epp->ep_vp, eh->e_phoff,
d896 1
a896 1
		if ((error = ELFNAME(read_from)(p, epp->ep_vp, ph->p_offset,
d931 13
d948 1
a948 1
int	ELFNAMEEND(coredump_countsegs)(struct proc *, void *,
d956 1
a956 1
int	ELFNAMEEND(coredump_writeseghdrs)(struct proc *, void *,
d959 3
a961 3
int	ELFNAMEEND(coredump_notes)(struct proc *, void *, size_t *);
int	ELFNAMEEND(coredump_note)(struct proc *, void *, size_t *);
int	ELFNAMEEND(coredump_writenote)(struct proc *, void *, Elf_Note *,
d968 1
a968 1
ELFNAMEEND(coredump)(struct proc *p, void *cookie)
a969 3
#ifdef SMALL_KERNEL
	return EPERM;
#else
d991 1
a991 2
	error = uvm_coredump_walkmap(p, NULL,
	    ELFNAMEEND(coredump_countsegs), &cs);
d999 1
a999 1
	error = ELFNAMEEND(coredump_notes)(p, NULL, &notesize);
d1042 1
a1042 2
	error = uvm_coredump_walkmap(p, cookie,
	    ELFNAMEEND(coredump_writeseghdrs), &ws);
d1068 1
a1068 1
	error = ELFNAMEEND(coredump_notes)(p, cookie, &notesize);
a1107 1
#endif
d1111 1
a1111 1
ELFNAMEEND(coredump_countsegs)(struct proc *p, void *iocookie,
a1113 1
#ifndef SMALL_KERNEL
a1116 1
#endif
d1121 1
a1121 1
ELFNAMEEND(coredump_writeseghdrs)(struct proc *p, void *iocookie,
a1123 1
#ifndef SMALL_KERNEL
a1147 1
#endif
d1153 1
a1153 1
ELFNAMEEND(coredump_notes)(struct proc *p, void *iocookie, size_t *sizep)
a1154 1
#ifndef SMALL_KERNEL
d1205 1
a1205 1
		error = ELFNAMEEND(coredump_writenote)(p, iocookie, &nhdr,
d1265 1
a1265 1
		error = ELFNAMEEND(coredump_writenote)(p, iocookie, &nhdr,
d1277 1
a1277 1
	error = ELFNAMEEND(coredump_note)(p, iocookie, &notesize);
d1291 1
a1291 1
		error = ELFNAMEEND(coredump_note)(q, iocookie, &notesize);
a1297 1
#endif
d1302 1
a1302 1
ELFNAMEEND(coredump_note)(struct proc *p, void *iocookie, size_t *sizep)
a1303 1
#ifndef SMALL_KERNEL
d1330 1
a1330 1
		error = ELFNAMEEND(coredump_writenote)(p, iocookie, &nhdr,
d1349 1
a1349 2
		error = ELFNAMEEND(coredump_writenote)(p, iocookie, &nhdr,
		    name, &freg);
a1357 1
#endif
d1362 1
a1362 1
ELFNAMEEND(coredump_writenote)(struct proc *p, void *cookie, Elf_Note *nhdr,
a1364 3
#ifdef SMALL_KERNEL
	return EPERM;
#else
a1376 1
#endif
d1378 1
@


1.134
log
@Change ELFNAME(read_from)'s buf parameter to be void*, eliminating a cast
from all but one call

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.133 2017/02/08 04:47:23 guenther Exp $	*/
d118 5
@


1.133
log
@elf{32,64}_check_brand() isn't used; delete it

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.132 2017/02/08 04:34:29 guenther Exp $	*/
d99 1
a99 1
int ELFNAME(read_from)(struct proc *, struct vnode *, u_long, caddr_t, int);
d282 1
a282 1
ELFNAME(read_from)(struct proc *p, struct vnode *vp, u_long off, caddr_t buf,
d343 1
a343 2
	if ((error = ELFNAME(read_from)(p, nd.ni_vp, 0,
				    (caddr_t)&eh, sizeof(eh))) != 0)
d354 1
a354 1
	if ((error = ELFNAME(read_from)(p, nd.ni_vp, eh.e_phoff, (caddr_t)ph,
d541 1
a541 1
	if ((error = ELFNAME(read_from)(p, epp->ep_vp, eh->e_phoff, (caddr_t)ph,
d858 1
a858 1
	    (caddr_t)hph, phsize)) != 0)
d888 1
a888 1
		    (caddr_t)np, ph->p_filesz)) != 0)
@


1.132
log
@Provide size-generic ELF_NO_ADDR in <sys/exec_elf.h> and use that instead
of ELFDEFNNAME(NO_ADDR)

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.131 2017/02/05 19:51:27 guenther Exp $	*/
a843 12
}

/*
 * Older ELF binaries use EI_ABIVERSION (formerly EI_BRAND) to brand
 * executables.  Newer ELF binaries use EI_OSABI instead.
 */
char *
ELFNAME(check_brand)(Elf_Ehdr *eh)
{
	if (eh->e_ident[EI_ABIVERSION] == '\0')
		return (NULL);
	return (&eh->e_ident[EI_ABIVERSION]);
@


1.131
log
@Since we expect to never do binary compat with other OSes again,
delete the no-longer-used probe hook support.

ok mpi@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.130 2017/01/21 05:42:03 guenther Exp $	*/
d211 1
a211 1
	if (*addr != ELFDEFNNAME(NO_ADDR)) {
d377 1
a377 1
	if (pos == ELFDEFNNAME(NO_ADDR)) {
d546 2
a547 2
	epp->ep_tsize = ELFDEFNNAME(NO_ADDR);
	epp->ep_dsize = ELFDEFNNAME(NO_ADDR);
d587 1
a587 1
	pos = ELFDEFNNAME(NO_ADDR);
d617 1
a617 1
				addr = ELFDEFNNAME(NO_ADDR);
d645 1
a645 1
				if (epp->ep_dsize == ELFDEFNNAME(NO_ADDR)) {
d661 1
a661 1
				if (epp->ep_tsize == ELFDEFNNAME(NO_ADDR)) {
d718 1
a718 1
	if (epp->ep_tsize == ELFDEFNNAME(NO_ADDR))
d725 1
a725 1
	if (epp->ep_dsize == ELFDEFNNAME(NO_ADDR)) {
@


1.130
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.129 2016/11/07 00:26:32 guenther Exp $	*/
a95 8
struct ELFNAME(probe_entry) {
	int (*func)(struct proc *, struct exec_package *, char *,
	    u_long *);
} ELFNAME(probes)[] = {
	/* XXX - bogus, shouldn't be size independent.. */
	{ NULL }
};

d120 1
a120 1
 * This is the basic elf emul. elf_probe_funcs may change to other emuls.
d590 2
a591 7
	 * On the same architecture, we may be emulating different systems.
	 * See which one will accept this executable.
	 *
	 * Probe functions would normally see if the interpreter (if any)
	 * exists. Emulation packages may possibly replace the interpreter in
	 * *interp with a changed path (/emul/xxx/<path>), and also
	 * set the ep_emul field in the exec package structure.
d595 1
a595 6
		if (error == EACCES)
			goto bad;
		for (i = 0; ELFNAME(probes)[i].func != NULL && error; i++)
			error = (*ELFNAME(probes)[i].func)(p, epp, interp, &pos);
		if (error)
			goto bad;
@


1.129
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.128 2016/10/05 02:31:52 guenther Exp $	*/
d1219 1
a1219 1
		(void)strlcpy(cpi.cpi_name, p->p_comm, sizeof(cpi.cpi_name));
@


1.128
log
@Display/test/use the process PID, not the thread's TID, in a few places.

ok mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.127 2016/09/12 00:35:54 schwarze Exp $	*/
d1338 1
a1338 1
	    "OpenBSD", p->p_pid);
@


1.127
log
@When trying to run an ELF binary marked PT_OPENBSD_WXNEEDED from a
file system mounted without MNT_WXALLOWED, fail with EACCES rather
than with ENOEXEC, to discourage the shell from trying to run the
file as a shell script.
OK deraadt@@ millert@@; tedu@@ and halex@@ agreed with the general direction.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.126 2016/06/11 21:04:08 kettenis Exp $	*/
d902 1
a902 1
				    error ? "" : pathbuf, p->p_pid);
@


1.126
log
@Since epp->ep_name is a userland pointer, use copyinstr(9) to get a copy ok
the string into kernel space before logging the W^X binary warning.

ok jca@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.125 2016/06/08 12:07:52 kettenis Exp $	*/
d606 4
a609 3
	error = ENOEXEC;
	if (eh->e_ident[EI_OSABI] != ELFOSABI_OPENBSD &&
	    ELFNAME(os_pt_note)(p, epp, epp->ep_hdr, "OpenBSD", 8, 4) != 0) {
d903 1
a903 1
				error = ENOEXEC;
@


1.126.2.1
log
@OpenBSD 6.0 Errata 020: SECURITY FIX: March 20, 2017
MFC sys/kern/exec_elf.c exec_elf.c rev v 1.140 kettenis

    Initialize the stack buffer used to build the auxiliary vector to zero to
    avoid leaking the contents of the kernel stack into userspace.

    ok guenther@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.126 2016/06/11 21:04:08 kettenis Exp $	*/
a820 1
		memset(&ai, 0, sizeof ai);
@


1.125
log
@Enforce W^X and map W|X segments without X permission initially.  The
dynamic linker will make these read-only and add back X permission after
elocation processing.  Static executables with W|X segments will probably
crash.

ok deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.124 2016/05/30 21:31:29 deraadt Exp $	*/
d879 1
d897 2
d901 1
a901 1
				    epp->ep_name, p->p_pid);
@


1.124
log
@Identify W^X labelled binaries at execve() time based upon WX_OPENBSD_WXNEEDED
flag set by ld -zwxneeded.  Such binaries are allowed to run only on wxallowed
mountpoints.  They do not report mmap/mprotect problems.

Rate limit mmap/mprotect reports from other binaries.

These semantics are chosen to encourage progress in the ports ecosystem,
without overwhelming the developers who work in the area.
ok sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.122 2016/05/30 21:22:45 deraadt Exp $	*/
d239 6
d247 2
a248 1
	*prot |= (ph->p_flags & PF_X) ? PROT_EXEC : 0;
@


1.123
log
@backout to insert correct commit message
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.121 2016/05/10 18:39:51 deraadt Exp $	*/
d79 1
d882 17
@


1.122
log
@*** empty log message ***
@
text
@a78 1
#include <sys/syslog.h>
a880 17

	for (ph = hph;  ph < &hph[eh->e_phnum]; ph++) {
		if (ph->p_type == PT_OPENBSD_WXNEEDED) {
			int wxallowed = (epp->ep_vp->v_mount &&
			    (epp->ep_vp->v_mount->mnt_flag & MNT_WXALLOWED));
			
			if (!wxallowed) {
				log(LOG_NOTICE,
				    "%s(%d): W^X binary outside wxallowed mountpoint\n",
				    epp->ep_name, p->p_pid);
				error = ENOEXEC;
				goto out1;
			}
			epp->ep_flags |= EXEC_WXNEEDED;
			break;
		}
	}
@


1.121
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.120 2016/02/28 15:46:18 naddy Exp $	*/
d79 1
d882 17
@


1.120
log
@Support for running Linux binaries under emulation is going away.

Remove "option COMPAT_LINUX" and everything directly tied to it from the
kernel and the corresponding man page documentation.

ok visa@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.119 2015/11/02 16:31:55 semarie Exp $	*/
d111 1
a111 1
extern char sigcode[], esigcode[];
d148 1
@


1.119
log
@move the pledgenote annotation from `struct proc' to `struct nameidata'

pledgenote is used for annotate the policy for a namei context. So make it
tracking the nameidata.

It is expected for the caller to explicitly define the policy. It is a kernel
bug to not do so.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.118 2015/10/28 11:59:08 deraadt Exp $	*/
a94 4
#ifdef COMPAT_LINUX
#include <compat/linux/linux_exec.h>
#endif

a99 3
#ifdef COMPAT_LINUX
	{ linux_elf_probe },
#endif
@


1.119.2.1
log
@OpenBSD 5.9 Errata 037: SECURITY FIX: March 20, 2017
MFC sys/kern/exec_elf.c exec_elf.c rev v 1.140 kettenis
    Initialize the stack buffer used to build the auxiliary vector to zero to
    avoid leaking the contents of the kernel stack into userspace.

    ok guenther@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.119 2015/11/02 16:31:55 semarie Exp $	*/
a818 1
		memset(&ai, 0, sizeof ai);
@


1.118
log
@Paranoa: p_pledgenote the NAMEI for ld.so loading
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.117 2015/09/28 20:32:59 deraadt Exp $	*/
a330 1
	p->p_pledgenote = PLEDGE_RPATH;
d332 1
@


1.117
log
@Track size of an opaque allocation to pass to free() later
ok guenther tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.116 2015/04/30 11:15:28 jsg Exp $	*/
d86 1
d331 1
@


1.116
log
@Now we use p_filesz - 1 to test for NUL check that p_filesz is
at least two and while here allow the upper bound to be
MAXPATHLEN by changing a >= to > as suggested by krw@@ in a thread
on tech where Maxime Villard proposed additional PT_INTERP checks.

tested by and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.115 2015/04/30 03:11:21 guenther Exp $	*/
d762 1
d802 1
a802 1
		free(ap, M_TEMP, 0);
d853 1
a853 1
	free(ap, M_TEMP, 0);
@


1.115
log
@Error out if the PT_INTERP segment isn't NUL terminated

ok deraadt@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.114 2015/04/26 05:30:42 guenther Exp $	*/
d555 1
a555 1
			if (pp->p_filesz >= MAXPATHLEN)
@


1.114
log
@Require a PT_LOAD segment's p_filesz to be no larger than its p_memsz.

test cases provided by Alejandro Herna'ndez (nitrousenador (at) gmail.com)
ok deraadt@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.113 2015/03/30 21:08:38 miod Exp $	*/
d562 2
@


1.113
log
@Extend uvm_map_hint() to get an address range as extra arguments, and make
sure it will return an address within that range.

Use this in uaddr_rnd_select() to make sure we will not attempt to pick
an address beyond what we are allowed to map.

In my trees for 9 months, blackmailed s2k15 attendees into agreeing now would
be a good time to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.112 2015/02/10 23:39:57 guenther Exp $	*/
d365 2
d563 4
@


1.112
log
@Don't use an uninitialized variable when a PT_LOAD segment with
alignment 0 or 1 is encountered.  The result before was just a
spurious failure by execve(), though I had to manually mangle a
binary to hit this case: segments are all long-aligned or better
in practice.

uninitialized variable noted by Maxime Villard (rustyBSD (at) gmx.fr)
ok and prod jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.111 2015/02/06 23:58:12 deraadt Exp $	*/
d380 2
a381 1
		pos = uvm_map_hint(p->p_vmspace, PROT_EXEC);
@


1.112.2.1
log
@Backport r1.114-1.116 by myself and jsg:
Missing validity checks in the kernel ELF loader meant malformed binaries
could trigger kernel panics or view kernel memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.112 2015/02/10 23:39:57 guenther Exp $	*/
a364 2
			if (ph[i].p_filesz > ph[i].p_memsz)
				goto bad1;
d552 1
a552 1
			if (pp->p_filesz < 2 || pp->p_filesz > MAXPATHLEN)
a558 2
			if (interp[pp->p_filesz - 1] != '\0')
				goto bad;
a559 4
			if (pp->p_filesz > pp->p_memsz) {
				error = EINVAL;
				goto bad;
			}
@


1.111
log
@Raise ELF_RANDOMIZE_LIMIT to 64K, so that programs and libraries can
legitimately use random section variables without execve failures...
Because this section is not demand faulted, yield() every page during
the fill otherwise the costs are charged poorly.
ok tedu matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.110 2015/01/27 00:33:21 kurt Exp $	*/
d216 1
a216 1
	u_long uaddr, msize, lsize, psize, rm, rf;
d230 1
a230 4

			bdiff = ph->p_vaddr - trunc_page(ph->p_vaddr);

		} else
d232 2
d235 1
a235 1
		*addr = uaddr = ph->p_vaddr;
d237 3
a239 4
			*addr = ELF_TRUNC(uaddr, ph->p_align);
		base = trunc_page(uaddr);
		bdiff = uaddr - base;
		diff = uaddr - *addr;
d241 1
@


1.110
log
@Require EFT shared objects have a PT_PHDR entry to be considered
a pie binary. The kernel will now reject executing a typical shared
library with EINVAL. This breaks compatibility with initial static pie
binaries and requires a recent user-land prior to upgrading. In
addition, more fine grained errors can be returned from execve(2)
when errors occur while attempting to execute ELF objects.

okay guenther@@, kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.109 2015/01/20 19:43:21 kettenis Exp $	*/
a130 3

/* Limit on total PT_OPENBSD_RANDOMIZE bytes. */
#define ELF_RANDOMIZE_LIMIT 1024
@


1.109
log
@Move ps_strings "after" the random stackgap.  This makes its location a
per-process value, and therefpore turns the VM_PSSTRINGS sysctl into a
per-process one as well.  This gets rid of a pointer to the bottom of the
stack at a fixed location.  Also clears the road for unmapping the stackgap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.108 2014/12/22 15:05:24 kettenis Exp $	*/
d517 1
a517 1
	int error, i;
d566 2
d572 3
a574 2
		/* need load sections for PIE */
		if (base_ph == NULL)
d576 1
d769 3
a771 1
	return (ENOEXEC);
@


1.108
log
@Make it possible to execute PIE binaries that don't have an PT_INTERP segment
(and therefore no interpreter).  Necessary to make self-relocating "static"
PIE working.

This will also allow execution of shared libraries that have the 'x' bit set.
Those shouldn't exist, but unfortunately people outside OpenBSD think
differently which means third-party software sometimes installs shared
libraries with the 'x' bit set.

ok kurt@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.107 2014/12/16 18:30:03 tedu Exp $	*/
d1203 1
a1203 1
		uio.uio_offset = (off_t)(vaddr_t)PS_STRINGS;
@


1.107
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.106 2014/11/16 12:31:00 deraadt Exp $	*/
d176 1
a176 1
	if (pack->ep_interp != NULL) {
d570 2
a571 2
		/* need an interpreter and load sections for PIE */
		if (interp == NULL || base_ph == NULL)
d741 1
a741 1
	if (interp) {
d750 1
d776 1
a776 1
	int	error;
d781 1
a781 1
	if (epp->ep_interp == NULL) {
d788 2
a789 1
	if ((error = ELFNAME(load_file)(p, interp, epp, ap, &pos)) != 0) {
d842 2
a843 1
	pool_put(&namei_pool, interp);
@


1.106
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.105 2014/11/14 23:26:48 tedu Exp $	*/
d88 2
@


1.105
log
@prefer sizeof(*ptr) to sizeof(struct) for malloc and free
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.104 2014/11/06 17:31:19 tedu Exp $	*/
d245 3
a247 3
	*prot |= (ph->p_flags & PF_R) ? VM_PROT_READ : 0;
	*prot |= (ph->p_flags & PF_W) ? VM_PROT_WRITE : 0;
	*prot |= (ph->p_flags & PF_X) ? VM_PROT_EXECUTE : 0;
d382 1
a382 1
		pos = uvm_map_hint(p->p_vmspace, VM_PROT_EXECUTE);
d645 1
a645 1
			if (prot & VM_PROT_WRITE) {
d661 1
a661 1
			} else if (prot & VM_PROT_EXECUTE) {
d1114 1
a1114 1
	if (us->prot & VM_PROT_READ)
d1116 1
a1116 1
	if (us->prot & VM_PROT_WRITE)
d1118 1
a1118 1
	if (us->prot & VM_PROT_EXECUTE)
@


1.104
log
@printf debugging worked! figured out the bug (in free()) just after
committing the printfs. revert.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.103 2014/11/06 17:23:40 millert Exp $	*/
d742 1
a742 1
		ap = malloc(sizeof(struct elf_args), M_TEMP, M_WAITOK);
@


1.103
log
@Make better use of the value of psectionslen instead of recomputing
it multiple times.  Also remove an unused variable.  OK deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.102 2014/11/06 16:43:42 tedu Exp $	*/
a1004 1
	printf("coredump: malloc %zu bytes at %p\n", psectionslen, psections);
a1077 1
	printf("coredump: free %zu bytes at %p\n", psectionslen, psections);
@


1.102
log
@resort to printf debugging hints until we can figure this out. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.101 2014/11/03 03:08:00 deraadt Exp $	*/
d941 1
a941 1
	Elf_Phdr phdr, *psections;
a947 1
	psections = NULL;
a1001 5
	offset = sizeof(ehdr);

	notestart = offset + sizeof(phdr) * cs.npsections;
	secstart = notestart + notesize;

d1007 4
d1029 1
a1029 2
	error = coredump_write(cookie, UIO_SYSSPACE, psections,
	    cs.npsections * sizeof(Elf_Phdr));
d1034 1
a1034 1
	offset += cs.npsections * sizeof(Elf_Phdr);
@


1.101
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.100 2014/07/13 23:59:58 tedu Exp $	*/
d1011 1
d1082 1
@


1.100
log
@use mallocarray for multiplied value checking
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.99 2014/07/12 18:43:32 tedu Exp $	*/
d493 1
a493 1
	free(ph, M_TEMP, 0);
d753 1
a753 1
	free(ph, M_TEMP, 0);
d760 1
a760 1
	free(ph, M_TEMP, 0);
d882 1
a882 1
			free(np, M_TEMP, 0);
d905 1
a905 1
	free(np, M_TEMP, 0);
d907 1
a907 1
	free(hph, M_TEMP, 0);
d945 1
a945 1
	size_t notesize;
d1010 1
d1081 1
a1081 1
	free(psections, M_TEMP, 0);
@


1.100.4.1
log
@Backport r1.114-1.116 by myself and jsg:
Missing validity checks in the kernel ELF loader meant malformed binaries
could trigger kernel panics or view kernel memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.100 2014/07/13 23:59:58 tedu Exp $	*/
a366 2
			if (ph[i].p_filesz > ph[i].p_memsz)
				goto bad1;
d554 1
a554 1
			if (pp->p_filesz < 2 || pp->p_filesz > MAXPATHLEN)
a560 2
			if (interp[pp->p_filesz - 1] != '\0')
				goto bad;
a561 4
			if (pp->p_filesz > pp->p_memsz) {
				error = EINVAL;
				goto bad;
			}
@


1.99
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.98 2014/07/08 17:19:25 deraadt Exp $	*/
d358 1
a359 1
	ph = malloc(phsize, M_TEMP, M_WAITOK);
d542 1
a543 1
	ph = malloc(phsize, M_TEMP, M_WAITOK);
d863 1
a864 1
	hph = malloc(phsize, M_TEMP, M_WAITOK);
d1008 1
a1008 1
	psections = malloc(cs.npsections * sizeof(Elf_Phdr),
@


1.98
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.97 2014/03/30 21:54:48 guenther Exp $	*/
d493 1
a493 1
	free(ph, M_TEMP);
d753 1
a753 1
	free(ph, M_TEMP);
d760 1
a760 1
	free(ph, M_TEMP);
d786 1
a786 1
		free(ap, M_TEMP);
d837 1
a837 1
	free(ap, M_TEMP);
d882 1
a882 1
			free(np, M_TEMP);
d905 1
a905 1
	free(np, M_TEMP);
d907 1
a907 1
	free(hph, M_TEMP);
d1080 1
a1080 1
	free(psections, M_TEMP);
@


1.97
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.96 2014/03/26 05:23:42 guenther Exp $	*/
a87 1
#include <uvm/uvm_extern.h>
@


1.96
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.95 2014/03/22 06:05:45 guenther Exp $	*/
d1172 1
a1172 1
		cpi.cpi_ruid = p->p_cred->p_ruid;
d1174 1
a1174 1
		cpi.cpi_svuid = p->p_cred->p_svuid;
d1176 1
a1176 1
		cpi.cpi_rgid = p->p_cred->p_rgid;
d1178 1
a1178 1
		cpi.cpi_svgid = p->p_cred->p_svgid;
@


1.95
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.94 2014/01/21 01:48:44 tedu Exp $	*/
d1195 1
a1195 1
	    elfround(p->p_emul->e_arglen * sizeof(char *));
d1215 1
a1215 1
		nhdr.descsz = p->p_emul->e_arglen * sizeof(char *);
@


1.94
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.93 2013/07/04 17:37:05 tedu Exp $	*/
d1161 2
a1162 2
		cpi.cpi_sigignore = p->p_sigacts->ps_sigignore;
		cpi.cpi_sigcatch = p->p_sigacts->ps_sigcatch;
@


1.93
log
@now that free(null) is safe, delete checks
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.92 2013/06/02 16:41:37 guenther Exp $	*/
d894 1
a894 1
		if (bcmp((np + 1), os_name, name_size))
d1152 1
a1152 1
		bzero(&cpi, sizeof(cpi));
@


1.92
log
@Coredumping is now single-threaded, so update comment about locking
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.91 2013/03/28 16:55:25 deraadt Exp $	*/
d494 1
a494 2
	if (ph != NULL)
		free(ph, M_TEMP);
d906 1
a906 2
	if (np)
		free(np, M_TEMP);
d1081 1
a1081 2
	if (psections)
		free(psections, M_TEMP);
@


1.91
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.90 2013/01/15 01:34:27 deraadt Exp $	*/
d1268 3
a1270 2
	 * per-thread notes.  Since we're dumping core, we don't bother
	 * locking.
@


1.90
log
@Slice & dice coredump write requests into MAXPHYS blocks, and
yield between operations.  Re-grab the vnode every operation,
so that multiple coredumps can be saved at the same time.
ok guenther beck etc
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.89 2012/09/17 17:11:49 matthew Exp $	*/
a89 1
#include <machine/cpu.h>
@


1.89
log
@Recognize executables tagged with ELFOSABI_OPENBSD (such as generated
by the Go linker) as native executables even if they don't contain an
OpenBSD PT_NOTE segment.

Confirmed to fix Go by sthen
ok kettenis, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.88 2012/09/11 15:44:19 deraadt Exp $	*/
d1074 3
@


1.88
log
@Remove the 'OLF method' used for the transition from a.out to ELF and
for all the compat layers which are now gone.  Linux compat still works
because it always used another method in any case, and nothing looks at
p_os anymore.
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.87 2012/08/20 23:25:07 matthew Exp $	*/
d595 2
a596 1
	if (ELFNAME(os_pt_note)(p, epp, epp->ep_hdr, "OpenBSD", 8, 4) != 0) {
@


1.87
log
@Add support for .openbsd.randomdata sections and PT_OPENBSD_RANDOMIZE
segments to the kernel, ld (2.15), and ld.so.  Tested on alpha, amd64,
i386, macppc, and sparc64 (thanks naddy, mpi, and okan!).

Idea discussed for some time; committing now for further testing.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.86 2012/03/09 13:01:28 ariane Exp $	*/
a80 1
#include <sys/exec_olf.h>
d100 1
a100 1
	    u_long *, u_int8_t *);
a520 1
	u_int8_t os = OOS_NULL;
d595 5
a599 8
	p->p_os = OOS_OPENBSD;
#ifdef NATIVE_EXEC_ELF
	if (ELFNAME(os_pt_note)(p, epp, epp->ep_hdr, "OpenBSD", 8, 4) == 0) {
		goto native;
	}
#endif
	for (i = 0; ELFNAME(probes)[i].func != NULL && error; i++) {
		error = (*ELFNAME(probes)[i].func)(p, epp, interp, &pos, &os);
a600 8
	if (!error)
		p->p_os = os;
#ifndef NATIVE_EXEC_ELF
	else
		goto bad;
#else
native:
#endif /* NATIVE_EXEC_ELF */
a749 1
		ap->arg_os = os;
@


1.86
log
@New vmmap implementation.

no oks (it is really a pain to review properly)
extensively tested, I'm confident it'll be stable
'now is the time' from several icb inhabitants

Diff provides:
- ability to specify different allocators for different regions/maps
- a simpler implementation of the current allocator
- currently in compatibility mode: it will generate similar addresses
  as the old allocator
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.85 2011/07/05 04:48:02 guenther Exp $	*/
d133 3
d333 1
d476 10
d523 1
d708 10
@


1.85
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.84 2011/07/04 22:53:53 tedu Exp $	*/
d329 1
d381 1
a381 1
		pos = uvm_map_hint(p, VM_PROT_EXECUTE);
d386 1
d414 7
a420 8
		vm_map_lock(&p->p_vmspace->vm_map);
		if (uvm_map_findspace(&p->p_vmspace->vm_map, addr, size,
		    &addr, uobj, uoff, 0, UVM_FLAG_FIXED) == NULL) {
			if (uvm_map_findspace(&p->p_vmspace->vm_map, addr, size,
			    &addr, uobj, uoff, 0, 0) == NULL) {
				error = ENOMEM; /* XXX */
				vm_map_unlock(&p->p_vmspace->vm_map);
				goto bad1;
d422 3
a424 2
		} 
		vm_map_unlock(&p->p_vmspace->vm_map);
@


1.84
log
@remove compat_svr4 support.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.83 2011/06/06 17:10:23 ariane Exp $	*/
d1143 2
a1144 2
		cpi.cpi_signo = p->p_sigacts->ps_sig;
		cpi.cpi_sigcode = p->p_sigacts->ps_code;
d1148 2
a1149 2
		cpi.cpi_sigignore = p->p_sigignore;
		cpi.cpi_sigcatch = p->p_sigcatch;
@


1.83
log
@Backout vmmap in order to repair virtual address selection algorithms
outside the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.82 2011/05/24 15:27:36 ariane Exp $	*/
a98 4
#ifdef COMPAT_SVR4
#include <compat/svr4/svr4_exec.h>
#endif

a105 3
#endif
#ifdef COMPAT_SVR4
	{ svr4_elf_probe },
@


1.82
log
@Reimplement uvm/uvm_map.

vmmap is designed to perform address space randomized allocations,
without letting fragmentation of the address space go through the roof.

Some highlights:
- kernel address space randomization
- proper implementation of guardpages
- roughly 10% system time reduction during kernel build

Tested by alot of people on tech@@ and developers.
Theo's machines are still happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.81 2011/04/18 21:44:56 guenther Exp $	*/
a335 1
	int loop;
a391 1
	loop = 0;
d419 8
a426 7
		if (uvm_map_mquery(&p->p_vmspace->vm_map, &addr, size,
		    (i == 0 ? uoff : UVM_UNKNOWN_OFFSET), 0) != 0) {
			if (loop == 0) {
				loop = 1;
				i = 0;
				*last = epp->ep_interp_pos = pos = 0;
				continue;
d428 2
a429 3
			error = ENOMEM;
			goto bad1;
		}
@


1.81
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.79 2011/04/05 12:50:15 guenther Exp $	*/
d336 1
d393 1
d421 7
a427 8
		vm_map_lock(&p->p_vmspace->vm_map);
		if (uvm_map_findspace(&p->p_vmspace->vm_map, addr, size,
		    &addr, uobj, uoff, 0, UVM_FLAG_FIXED) == NULL) {
			if (uvm_map_findspace(&p->p_vmspace->vm_map, addr, size,
			    &addr, uobj, uoff, 0, 0) == NULL) {
				error = ENOMEM; /* XXX */
				vm_map_unlock(&p->p_vmspace->vm_map);
				goto bad1;
d429 3
a431 2
		} 
		vm_map_unlock(&p->p_vmspace->vm_map);
@


1.80
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d1150 2
a1151 2
		cpi.cpi_signo = p->p_sisig;
		cpi.cpi_sigcode = p->p_sicode;
d1155 2
a1156 2
		cpi.cpi_sigignore = p->p_sigacts->ps_sigignore;
		cpi.cpi_sigcatch = p->p_sigacts->ps_sigcatch;
@


1.79
log
@Push COMPAT_FREEBSD in front of a whale.  Buggy, out of date, no
one has been weeding it, and it makes life harder.

Toasts of Brennivin for its passing from many; diff ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.78 2010/12/15 04:59:52 tedu Exp $	*/
d1150 2
a1151 2
		cpi.cpi_signo = p->p_sigacts->ps_sig;
		cpi.cpi_sigcode = p->p_sigacts->ps_code;
d1155 2
a1156 2
		cpi.cpi_sigignore = p->p_sigignore;
		cpi.cpi_sigcatch = p->p_sigcatch;
@


1.78
log
@add a BRKSIZ define and use it for the heap gap constant, decoupling
heap gap from max data size.  nothing else changes yet.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.77 2010/09/17 14:03:09 mikeb Exp $	*/
a102 4
#ifdef COMPAT_FREEBSD
#include <compat/freebsd/freebsd_exec.h>
#endif

a107 3
#ifdef COMPAT_FREEBSD
	{ freebsd_elf_probe },
#endif
@


1.77
log
@don't forget to free program header sections when writing
core files.  fixes a local DoS that can be carried out by
an unprivileged user.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.76 2010/07/26 01:56:27 guenther Exp $	*/
d420 1
a420 1
		/* CRAP - map_findspace does not avoid daddr+MAXDSIZ */
d422 1
a422 1
		    (addr < (vaddr_t)p->p_vmspace->vm_daddr + MAXDSIZ))
d424 1
a424 1
			    MAXDSIZ);
@


1.76
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.75 2010/07/24 09:50:45 guenther Exp $	*/
d1081 2
@


1.75
log
@struct emul's e_arglen member is expected to count in units of
sizeof(char *), not in bytes, so we've been allocating and copying around
four or eight times as many bytes as we needed to

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.74 2010/06/29 00:28:14 tedu Exp $	*/
d1140 1
d1163 5
a1167 5
		cpi.cpi_pid = p->p_pid;
		cpi.cpi_ppid = p->p_pptr->p_pid;
		cpi.cpi_pgrp = p->p_pgid;
		if (p->p_session->s_leader)
			cpi.cpi_sid = p->p_session->s_leader->p_pid;
d1267 1
a1267 1
	TAILQ_FOREACH(q, &p->p_p->ps_threads, p_thr_link) {
@


1.74
log
@Eliminate RTHREADS kernel option in favor of a sysctl.  The actual status
(not done) hasn't changed, but now it's less work to test things.
ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.73 2010/05/02 11:15:29 kettenis Exp $	*/
d162 1
a162 1
	sizeof (AuxInfo) * ELF_AUX_ENTRIES,
@


1.73
log
@Use intermediate vaddr_t cast when casting a pointer to off_t.  Prevents
gcc4 from complaining about casting a pointer to an integer type of different
size.

ok guenther@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.72 2010/01/14 23:12:11 schwarze Exp $	*/
a1139 1
#ifdef RTHREADS
a1140 1
#endif
a1260 1
#ifdef RTHREADS
a1273 1
#endif
@


1.72
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.71 2009/11/19 02:36:27 guenther Exp $	*/
d1201 1
a1201 1
		uio.uio_offset = (off_t)PS_STRINGS;
@


1.71
log
@Dell's SVR4 apparently mapped page zero to the executable.  We don't
do that and, given the security issues it exacerbates, never will.
So document it and delete the disabled support.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.70 2009/06/06 21:25:19 deraadt Exp $	*/
d204 1
a204 1
	 * are represented in a machine independant fashion.
d212 1
a212 1
	/* Now check the machine dependant header */
d644 1
a644 1
			 * Update exe_base in case allignment was off.
@


1.70
log
@We need miod's no-coredumps-on-ramdisks diff, because we have grown the
media just a wee bit too much.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.69 2009/03/08 14:28:52 kettenis Exp $	*/
a754 9

#if defined(COMPAT_SVR4) && defined(i386) && 0	/* nothing sets OOS_DELL... */
#ifndef ELF_MAP_PAGE_ZERO
	/* Dell SVR4 maps page zero, yeuch! */
	if (p->p_os == OOS_DELL)
#endif
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, PAGE_SIZE, 0,
		    epp->ep_vp, 0, VM_PROT_READ);
#endif
@


1.69
log
@If a session leader exists s_leader is set to NULL, so don't dereference it
unconditionally.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.68 2009/03/05 19:52:24 kettenis Exp $	*/
d950 3
d1091 1
d1098 1
d1102 1
d1110 1
d1135 1
d1143 1
d1289 1
d1296 1
d1352 1
d1360 3
d1375 1
@


1.68
log
@Make ELF platforms generate ELF core dumps.  Somewhat based on code from
NetBSD.

ok kurt@@, drahn@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.67 2008/11/10 03:56:16 deraadt Exp $	*/
d1167 4
a1170 1
		cpi.cpi_sid = p->p_session->s_leader->p_pid;
@


1.67
log
@vm_map_lock() around calls to uvm_map_findspace(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.66 2008/07/18 16:58:06 kurt Exp $	*/
d34 35
d78 1
d83 1
d130 1
d166 1
d922 435
@


1.66
log
@Add support for the kernel to recognize, load and execute position
independent executables using the uvm_map_pie() function to
randomize the load address. okay miod@@, kettenis@@, drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.65 2008/06/12 17:02:04 miod Exp $	*/
d387 1
d393 1
d397 1
@


1.65
log
@Oops, do not dereference a NULL function pointer used as an array end
marker; found the hard way by sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.64 2008/06/12 04:33:37 miod Exp $	*/
d89 1
a89 1
int ELFNAME(check_header)(Elf_Ehdr *, int);
d160 1
a160 1
ELFNAME(check_header)(Elf_Ehdr *ehdr, int type)
a177 4
	/* Check the type */
	if (ehdr->e_type != type)
		return (ENOEXEC);

d326 1
a326 1
	if (ELFNAME(check_header)(&eh, ET_DYN)) {
d473 2
a474 2
	Elf_Phdr *ph, *pp;
	Elf_Addr phdr = 0;
d483 2
a484 1
	if (ELFNAME(check_header)(eh, ET_EXEC))
d512 2
a513 3
	for (i = 0; i < eh->e_phnum; i++) {
		pp = &ph[i];
		if (pp->p_type == PT_INTERP) {
d521 3
a523 1
			break;
d527 8
d569 1
d573 2
a574 2
	for (i = 0; i < eh->e_phnum; i++) {
		Elf_Addr addr = ELFDEFNNAME(NO_ADDR), size = 0;
d576 1
d578 12
a589 1
		pp = &ph[i];
a590 2
		switch (ph[i].p_type) {
		case PT_LOAD:
d599 12
a610 1
			    &ph[i], &addr, &size, &prot, 0);
d674 2
d693 1
a693 1
	epp->ep_entry = eh->e_entry;
d707 1
a707 1
		ap->arg_entry = eh->e_entry;
@


1.64
log
@Reorder foreign binaries probe list, so that more permissive ones are at the
end. Makes static linux binaries run again.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.63 2008/06/07 17:19:28 miod Exp $	*/
d552 1
a552 3
	for (i = 0;
	    i < sizeof(ELFNAME(probes)) / sizeof(ELFNAME(probes)[0]) && error;
	    i++) {
@


1.63
log
@Remove the OLF os bitmask field from the compat probe functions array;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.62 2008/06/04 21:12:50 deraadt Exp $	*/
d78 3
a82 3
#endif
#ifdef COMPAT_LINUX
	{ linux_elf_probe },
@


1.62
log
@olf support starts to die (easy stuff first); ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.61 2007/05/28 23:10:10 beck Exp $	*/
a72 1
	int os_mask;
d76 1
a76 1
	{ freebsd_elf_probe, 1 << OOS_FREEBSD },
d79 1
a79 3
	{ svr4_elf_probe,
	    1 << OOS_SVR4 | 1 << OOS_ESIX | 1 << OOS_SOLARIS | 1 << OOS_SCO |
	    1 << OOS_DELL | 1 << OOS_NCR },
d82 1
a82 1
	{ linux_elf_probe, 1 << OOS_LINUX },
d84 1
a84 1
	{ 0, 1 << OOS_OPENBSD }
d555 1
a555 4
		if (os == OOS_NULL || ((1 << os) & ELFNAME(probes)[i].os_mask))
			error = ELFNAME(probes)[i].func ?
			    (*ELFNAME(probes)[i].func)(p, epp, interp, &pos, &os) :
			    0;
d686 1
a686 1
#if defined(COMPAT_SVR4) && defined(i386)
@


1.61
log
@Maintaining a broken compatibility layer for a broken OS is not a productive
activity for anyone. Bye bye COMPAT_NETBSD. ok tedu@@, deraadt@@, and many others
in the hackathon room.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.60 2007/04/10 17:47:55 miod Exp $	*/
a92 1
int ELFNAME(olf_check_header)(Elf_Ehdr *, int, u_int8_t *);
a191 48
#ifndef	SMALL_KERNEL
/*
 * Check header for validity; return 0 for ok, ENOEXEC if error.
 * Remember OS tag for callers sake.
 */
int
ELFNAME(olf_check_header)(Elf_Ehdr *ehdr, int type, u_int8_t *os)
{
	int i;

	/*
	 * We need to check magic, class size, endianess, version, and OS
	 * before we look at the rest of the Elf_Ehdr structure. These few
	 * elements are represented in a machine independant fashion.
	 */
	if (!IS_OLF(*ehdr) ||
	    ehdr->e_ident[OI_CLASS] != ELF_TARG_CLASS ||
	    ehdr->e_ident[OI_DATA] != ELF_TARG_DATA ||
	    ehdr->e_ident[OI_VERSION] != ELF_TARG_VER)
		return (ENOEXEC);

	for (i = 0;
	    i < sizeof(ELFNAME(probes)) / sizeof(ELFNAME(probes)[0]);
	    i++) {
		if ((1 << ehdr->e_ident[OI_OS]) & ELFNAME(probes)[i].os_mask)
			goto os_ok;
	}
	return (ENOEXEC);

os_ok:
	/* Now check the machine dependant header */
	if (ehdr->e_machine != ELF_TARG_MACH ||
	    ehdr->e_version != ELF_TARG_VER)
		return (ENOEXEC);

	/* Check the type */
	if (ehdr->e_type != type)
		return (ENOEXEC);

	/* Don't allow an insane amount of sections. */
	if (ehdr->e_phnum > ELF_MAX_VALID_PHDR)
		return (ENOEXEC);

	*os = ehdr->e_ident[OI_OS];
	return (0);
}
#endif	/* !SMALL_KERNEL */

a302 3
#ifndef SMALL_KERNEL
	u_int8_t os;			/* Just a dummy in this routine */
#endif
d333 1
a333 5
	if (ELFNAME(check_header)(&eh, ET_DYN)
#ifndef SMALL_KERNEL
	    && ELFNAME(olf_check_header)(&eh, ET_DYN, &os)
#endif
	    ) {
d490 1
a490 5
	if (ELFNAME(check_header)(eh, ET_EXEC)
#ifndef SMALL_KERNEL
	    && ELFNAME(olf_check_header)(eh, ET_EXEC, &os)
#endif
	    )
@


1.60
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.59 2007/03/20 12:32:07 thib Exp $	*/
a69 4
#ifdef COMPAT_NETBSD
#include <compat/netbsd/netbsd_exec.h>
#endif

a85 3
#endif
#ifdef COMPAT_NETBSD
	{ netbsd_elf64_probe, 1 << OOS_NETBSD },
@


1.59
log
@zap unused variable.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.58 2007/03/14 16:41:15 kettenis Exp $	*/
d162 1
a162 1
		(char *)stack += ELF_AUX_ENTRIES * sizeof (AuxInfo);
d742 1
a742 1
	 * it's interpreter when the exec file is released.
@


1.58
log
@Clean up after miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.57 2007/03/13 19:34:44 miod Exp $	*/
a356 1
	char *bp = NULL;
a370 1
	bp = path;
@


1.57
log
@Don't bother checking for OLF binaries if option SMALL_KERNEL.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.56 2006/12/29 13:04:37 pedro Exp $	*/
d360 1
d362 1
@


1.56
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.55 2006/11/14 18:00:27 jmc Exp $	*/
d200 1
d246 1
d392 5
a396 2
	if (ELFNAME(check_header)(&eh, ET_DYN) &&
	    ELFNAME(olf_check_header)(&eh, ET_DYN, &os)) {
d553 5
a557 2
	if (ELFNAME(check_header)(eh, ET_EXEC) &&
	    ELFNAME(olf_check_header)(eh, ET_EXEC, &os))
@


1.55
log
@grammar, spelling, and style fixes from bret lambert;
kern_descrip.c change ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.54 2006/07/10 20:00:08 kettenis Exp $	*/
d162 1
a162 1
		stack += ELF_AUX_ENTRIES * sizeof (AuxInfo);
@


1.54
log
@Handle executables that have all load sections marked read-only.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.53 2006/01/19 17:54:47 mickey Exp $	*/
d642 1
a642 1
			 * Calcuates size of text and data segments
@


1.53
log
@redo (w/ proper changes everywhere ;):
take interp[MAXPATHLEN] off the stack.  from mickey, ok otto
while here, switch above from malloc to pool, remove stupid casts
tedu@@ miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.51 2006/01/06 06:46:04 tedu Exp $	*/
d719 9
@


1.52
log
@Backout last revision, it's broken.  Try pkg_add redhat_base-8.0p7 on i386
to see; page fault trap in linux_elf_probe (char *itp is being passed as NULL
and then "if (itp[0])" attempts to dereference it).  deraadt@@ "trash it asap"
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.50 2005/11/11 16:41:24 drahn Exp $	*/
d39 1
d397 1
a397 1
	ph = (Elf_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
d518 1
a518 1
		free((char *)ph, M_TEMP);
d541 1
a541 1
	char interp[MAXPATHLEN];
d568 1
a568 1
	ph = (Elf_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
a576 2
	interp[0] = '\0';

d580 1
a580 1
			if (pp->p_filesz >= sizeof(interp))
d582 1
d584 1
a584 1
			    pp->p_offset, (caddr_t)interp, pp->p_filesz)) != 0)
d586 1
d604 1
a604 1
	 * interp[] with a changed path (/emul/xxx/<path>), and also
d720 3
d727 1
a727 2
	if (interp[0]) {
		char *ip;
d730 1
a730 7
		ip = (char *)malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
		ap = (struct elf_args *)
		    malloc(sizeof(struct elf_args), M_TEMP, M_WAITOK);

		bcopy(interp, ip, MAXPATHLEN);
		epp->ep_interp = ip;
		epp->ep_interp_pos = pos;
d739 1
a739 4
		epp->ep_entry = eh->e_entry; /* keep check_exec() happy */
	} else {
		epp->ep_interp = NULL;
		epp->ep_entry = eh->e_entry;
d751 1
a751 1
	free((char *)ph, M_TEMP);
d756 3
a758 1
	free((char *)ph, M_TEMP);
d780 2
a781 2
	interp = (char *)epp->ep_interp;
	ap = (struct elf_args *)epp->ep_emul_arg;
d784 2
a785 2
		free((char *)ap, M_TEMP);
		free((char *)interp, M_TEMP);
d835 2
a836 2
	free((char *)ap, M_TEMP);
	free((char *)interp, M_TEMP);
d862 1
a862 1
	hph = (Elf_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
d873 1
a873 1
		np = (Elf_Note *)malloc(ph->p_filesz, M_TEMP, M_WAITOK);
@


1.51
log
@take interp[MAXPATHLEN] off the stack.  from mickey, ok otto
while here, switch above from malloc to pool, remove stupid casts
@
text
@a38 1
#include <sys/pool.h>
d396 1
a396 1
	ph = malloc(phsize, M_TEMP, M_WAITOK);
d517 1
a517 1
		free(ph, M_TEMP);
d540 1
a540 1
	char *interp = NULL;
d567 1
a567 1
	ph = malloc(phsize, M_TEMP, M_WAITOK);
d576 2
d581 1
a581 1
			if (pp->p_filesz >= MAXPATHLEN)
a582 1
			interp = pool_get(&namei_pool, PR_WAITOK);
d584 1
a584 1
			    pp->p_offset, interp, pp->p_filesz)) != 0) {
a585 1
			}
d603 1
a603 1
	 * *interp with a changed path (/emul/xxx/<path>), and also
a718 3
	epp->ep_interp = interp;
	epp->ep_entry = eh->e_entry;

d723 2
a724 1
	if (interp) {
d727 7
a733 1
		ap = malloc(sizeof(struct elf_args), M_TEMP, M_WAITOK);
d742 4
a745 1
		epp->ep_interp_pos = pos;
d757 1
a757 1
	free(ph, M_TEMP);
d762 1
a762 3
	if (interp)
		pool_put(&namei_pool, interp);
	free(ph, M_TEMP);
d784 2
a785 2
	interp = epp->ep_interp;
	ap = epp->ep_emul_arg;
d788 2
a789 2
		free(ap, M_TEMP);
		pool_put(&namei_pool, interp);
d839 2
a840 2
	free(ap, M_TEMP);
	pool_put(&namei_pool, interp);
d866 1
a866 1
	hph = malloc(phsize, M_TEMP, M_WAITOK);
d877 1
a877 1
		np = malloc(ph->p_filesz, M_TEMP, M_WAITOK);
@


1.50
log
@Allow binaries to run if all sections are marked writable
(some unusual linux binaries), ok deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.49 2003/11/03 19:58:22 tedu Exp $	*/
d39 1
d397 1
a397 1
	ph = (Elf_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
d518 1
a518 1
		free((char *)ph, M_TEMP);
d541 1
a541 1
	char interp[MAXPATHLEN];
d568 1
a568 1
	ph = (Elf_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
a576 2
	interp[0] = '\0';

d580 1
a580 1
			if (pp->p_filesz >= sizeof(interp))
d582 1
d584 1
a584 1
			    pp->p_offset, (caddr_t)interp, pp->p_filesz)) != 0)
d586 1
d604 1
a604 1
	 * interp[] with a changed path (/emul/xxx/<path>), and also
d720 3
d727 1
a727 2
	if (interp[0]) {
		char *ip;
d730 1
a730 7
		ip = (char *)malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
		ap = (struct elf_args *)
		    malloc(sizeof(struct elf_args), M_TEMP, M_WAITOK);

		bcopy(interp, ip, MAXPATHLEN);
		epp->ep_interp = ip;
		epp->ep_interp_pos = pos;
d739 1
a739 4
		epp->ep_entry = eh->e_entry; /* keep check_exec() happy */
	} else {
		epp->ep_interp = NULL;
		epp->ep_entry = eh->e_entry;
d751 1
a751 1
	free((char *)ph, M_TEMP);
d756 3
a758 1
	free((char *)ph, M_TEMP);
d780 2
a781 2
	interp = (char *)epp->ep_interp;
	ap = (struct elf_args *)epp->ep_emul_arg;
d784 2
a785 2
		free((char *)ap, M_TEMP);
		free((char *)interp, M_TEMP);
d835 2
a836 2
	free((char *)ap, M_TEMP);
	free((char *)interp, M_TEMP);
d862 1
a862 1
	hph = (Elf_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
d873 1
a873 1
		np = (Elf_Note *)malloc(ph->p_filesz, M_TEMP, M_WAITOK);
@


1.49
log
@verify exec headers before attempting malloc.  reported by Georgi Guninski.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.48 2003/08/21 18:56:07 tedu Exp $	*/
d711 7
@


1.48
log
@emulation is now controlled by sysctl.  changes:
add e_flags to struct emul.  this stores on/off and native flags.
check for emul enabled in check_exec().  gather all the emuls into a
emulsw so a sysctl can find them.  create sysctl.  move maxhdrsiz calcualation
into init_main so it cleans up sys_execve codepath.  teach sysctl utility
to grok kern.emul hierarchy.
requested and ok deraadt@@  some comments from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.47 2003/05/17 14:02:06 grange Exp $	*/
d866 1
@


1.48.2.1
log
@MFC:
Fix by tedu@@

verify exec headers before attempting malloc.  reported by Georgi Guninski.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.48 2003/08/21 18:56:07 tedu Exp $	*/
a865 1
		    ph->p_filesz > 1024 ||
@


1.47
log
@Typos; from Julien Bordet <zejames@@greyhats.org>
Close PR 3262
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.46 2003/05/13 16:39:23 millert Exp $	*/
d140 1
@


1.46
log
@Use EI_OSABI instead of EI_BRAND
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.45 2003/04/16 21:17:52 drahn Exp $	*/
d200 1
a200 1
 * Remeber OS tag for callers sake.
@


1.45
log
@Use uvm_findspace() to verify that the addresses allocated to ld.so are
not already used. limit nphdr to 32. ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.44 2003/02/18 03:54:40 drahn Exp $	*/
d836 4
d843 1
a843 1
	if (eh->e_ident[EI_BRAND] == '\0')
d845 1
a845 1
	return (&eh->e_ident[EI_BRAND]);
@


1.44
log
@Map just the requested pages not p_aligned pages. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.43 2002/11/22 22:10:21 drahn Exp $	*/
d114 6
d192 1
a192 1
	if (ehdr->e_phnum > 128)
d237 1
a237 1
	if (ehdr->e_phnum > 128)
d358 7
d401 69
a709 10

#if !defined(__mips__)
	/*
	 * If no position to load the interpreter was set by a probe
	 * function, pick the same address that a non-fixed mmap(0, ..)
	 * would (i.e. something safely out of the way).
	 */
	if (pos == ELFDEFNNAME(NO_ADDR))
		pos = round_page(epp->ep_daddr + MAXDSIZ);
#endif
@


1.44.2.1
log
@Pull patch from -current:
Fixed by tedu@@

verify exec headers before attempting malloc.  reported by Georgi Guninski.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.44 2003/02/18 03:54:40 drahn Exp $	*/
a788 1
		    ph->p_filesz > 1024 ||
@


1.43
log
@Allow more than two load sections on ELF executables, this limit
should not be required, and may be violated soon. With two fixes art
pointed out. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.42 2002/10/06 22:39:25 art Exp $	*/
d245 3
a247 2
	u_long uaddr, msize, psize, rm, rf;
	long diff, offset;
d256 6
d268 2
a276 2
	offset = ph->p_offset - diff;
	*size = ph->p_filesz + diff;
d278 3
a280 1
	psize = round_page(*size);
d287 1
a287 1
		psize = trunc_page(*size);
d289 1
a289 1
			NEW_VMCMD2(vcset, vmcmd_map_pagedvn, psize, *addr, vp,
d291 3
a293 3
		if (psize != *size) {
			NEW_VMCMD2(vcset, vmcmd_map_readvn, *size - psize,
			    *addr + psize, vp, offset + psize, *prot, flags);
d296 1
a296 1
		NEW_VMCMD2(vcset, vmcmd_map_pagedvn, psize, *addr, vp, offset,
d303 2
a304 2
	rm = round_page(*addr + msize);
	rf = round_page(*addr + *size);
a308 1
		*size = msize;
d310 1
@


1.42
log
@Move out the execution of vmcmds into a separate function.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.41 2002/09/23 01:41:09 art Exp $	*/
d447 1
a447 1
	int error, i, nload;
d540 1
a540 1
	for (i = nload = 0; i < eh->e_phnum; i++) {
d549 5
a553 2
			 * XXX
			 * Can handle only 2 sections: text and data
a554 2
			if (nload++ == 2)
				goto bad;
d559 1
a559 1
			 * at the entry point.
d561 3
a563 5
			if (eh->e_entry >= addr &&
			    eh->e_entry < (addr + size)) {
				epp->ep_taddr = addr;
				epp->ep_tsize = size;
				if (epp->ep_daddr == ELFDEFNNAME(NO_ADDR)) {
d566 26
a592 3
			} else {
				epp->ep_daddr = addr;
				epp->ep_dsize = size;
@


1.41
log
@Add support for vmcmds that load sections relative to a base section.
You mark one section with VMCMD_BASE and the rest are marked RELATIVE.
Use that to load ELF interpreter correctly in all cases.

Inspired by NetBSD. Great debugging help from drahn@@
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.40 2002/09/18 22:07:50 drahn Exp $	*/
d664 1
a664 1
	int	error, i;
a667 1
	struct exec_vmcmd *base_vc;
d669 1
a669 1
	if (epp->ep_interp == 0) {
d685 1
a685 17
	base_vc = NULL;
	for (i = 0; i < epp->ep_vmcmds.evs_used && !error; i++) {
		struct exec_vmcmd *vcp;
		vcp = &epp->ep_vmcmds.evs_cmds[i];

		if (vcp->ev_flags & VMCMD_RELATIVE) {
#ifdef DIAGNOSTIC
			if (base_vc == NULL)
				panic("sys_execve: RELATIVE without base");
#endif
			vcp->ev_addr += base_vc->ev_addr;
		}
		error = (*vcp->ev_proc)(p, vcp);
		if (vcp->ev_flags & VMCMD_BASE)
			base_vc = vcp;
	}
	kill_vmcmds(&epp->ep_vmcmds);
@


1.40
log
@Mark ELF ld.so as VTEXT to prevent the file from being overwritten.
ok deraadt@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.39 2002/08/22 22:04:42 art Exp $	*/
d102 1
a102 1
	Elf_Phdr *, Elf_Addr *, Elf_Addr *, int *);
d243 1
a243 1
	Elf_Phdr *ph, Elf_Addr *addr, Elf_Addr *size, int *prot)
d253 2
a254 2
			*addr = ELF_ROUND(*addr, ph->p_align);
			uaddr = ELF_TRUNC(ph->p_vaddr, ph->p_align);
d256 1
a256 2
			uaddr = ph->p_vaddr;
		diff = ph->p_vaddr - uaddr;
d279 3
a281 2
		NEW_VMCMD(vcset, vmcmd_map_pagedvn, psize, *addr, vp,
		    offset, *prot);
d283 2
a284 2
			NEW_VMCMD(vcset, vmcmd_map_readvn, *size - psize,
			    *addr + psize, vp, offset + psize, *prot);
d287 2
a288 2
		NEW_VMCMD(vcset, vmcmd_map_pagedvn, psize, *addr, vp, offset,
		    *prot);
d298 2
a299 2
		NEW_VMCMD(vcset, vmcmd_map_zero, rm - rf, rf, NULLVP, 0,
		    *prot);
d339 1
a339 1
	Elf_Addr addr = *last;
d342 1
d385 1
a385 4
#if defined(__mips__)
		if (*last == ELFDEFNNAME(NO_ADDR))
			addr = ELFDEFNNAME(NO_ADDR);	/* GRRRRR!!!!! */
#endif
d389 8
d398 1
a398 1
					&ph[i], &addr, &size, &prot);
d555 1
a555 1
			    &ph[i], &addr, &size, &prot);
d668 1
d686 1
d689 1
d691 7
a697 1
		vcp = &epp->ep_vmcmds.evs_cmds[i];
d699 2
@


1.39
log
@Change the vnode locking in exec to not keep the vnode locked almost all
the time.

This could lead to problems when a process wants to do an exec on the same
vnode it's being run from and needs to copy in arguments from an uncached
page in the data segment. When that happens uvm detects a vnode deadlock
and returns an error causing execve() return EFAULT.

This fixes the regress test in regress/sys/kern/exec_self

Also, initialize scriptvp early in exec_script because it could be
used uninitialized in a failure case.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.38 2002/03/14 01:27:03 millert Exp $	*/
d412 2
@


1.38
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.37 2001/11/15 06:22:30 art Exp $	*/
d315 1
a315 1
	    IO_NODELOCKED, p->p_ucred, &resid, p)) != 0)
@


1.37
log
@New function vn_marktext - mark a vnode as executing a text image.
Use where VTEXT was set in vnode flags before. Doesn't do anything else (yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.36 2001/11/06 19:53:20 miod Exp $	*/
d74 2
a75 2
	int (*func) __P((struct proc *, struct exec_package *, char *,
	    u_long *, u_int8_t *));
@


1.37.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.37 2001/11/15 06:22:30 art Exp $	*/
d74 2
a75 2
	int (*func)(struct proc *, struct exec_package *, char *,
	    u_long *, u_int8_t *);
@


1.37.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.37.2.1 2002/06/11 03:29:40 art Exp $	*/
d102 1
a102 1
	Elf_Phdr *, Elf_Addr *, Elf_Addr *, int *, int);
d243 1
a243 1
	Elf_Phdr *ph, Elf_Addr *addr, Elf_Addr *size, int *prot, int flags)
d253 2
a254 2
			*addr = ELF_TRUNC(*addr, ph->p_align);
			diff = ph->p_vaddr - ELF_TRUNC(ph->p_vaddr, ph->p_align);
d256 2
a257 1
			diff = 0;
d280 2
a281 3
		if (psize > 0)
			NEW_VMCMD2(vcset, vmcmd_map_pagedvn, psize, *addr, vp,
			    offset, *prot, flags);
d283 2
a284 2
			NEW_VMCMD2(vcset, vmcmd_map_readvn, *size - psize,
			    *addr + psize, vp, offset + psize, *prot, flags);
d287 2
a288 2
		NEW_VMCMD2(vcset, vmcmd_map_pagedvn, psize, *addr, vp, offset,
		    *prot, flags);
d298 2
a299 2
		NEW_VMCMD2(vcset, vmcmd_map_zero, rm - rf, rf, NULLVP, 0,
		    *prot, flags);
d315 1
a315 1
	    0, p->p_ucred, &resid, p)) != 0)
d339 1
a339 1
	Elf_Addr addr;
a341 1
	Elf_Phdr *base_ph = NULL;
d384 4
a387 1
		int flags;
a390 8
			if (base_ph == NULL) {
				flags = VMCMD_BASE;
				addr = *last;
				base_ph = &ph[i];
			} else {
				flags = VMCMD_RELATIVE;
				addr = ph[i].p_vaddr - base_ph->p_vaddr;
			}
d392 1
a392 1
			    &ph[i], &addr, &size, &prot, flags);
a412 2
	vn_marktext(nd.ni_vp);

d547 1
a547 1
			    &ph[i], &addr, &size, &prot, 0);
d656 1
a656 1
	int	error;
d661 1
a661 1
	if (epp->ep_interp == NULL) {
d677 7
a683 1
	error = exec_process_vmcmds(p, epp);
@


1.37.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a113 6
 * We limit the number of program headers to 32, this should
 * be a reasonable limit for ELF, the most we have seen so far is 12
 */
#define ELF_MAX_VALID_PHDR 32

/*
d186 1
a186 1
	if (ehdr->e_phnum > ELF_MAX_VALID_PHDR)
d231 1
a231 1
	if (ehdr->e_phnum > ELF_MAX_VALID_PHDR)
d245 2
a246 3
	u_long uaddr, msize, lsize, psize, rm, rf;
	long diff, offset, bdiff;
	Elf_Addr base;
a254 6
			/* page align vaddr */
			base = *addr + trunc_page(ph->p_vaddr) 
			    - ELF_TRUNC(ph->p_vaddr, ph->p_align);

			bdiff = ph->p_vaddr - trunc_page(ph->p_vaddr);

a260 2
		base = trunc_page(uaddr);
		bdiff = uaddr - base;
d268 2
d271 1
a271 3
	offset = ph->p_offset - bdiff;
	lsize = ph->p_filesz + bdiff;
	psize = round_page(lsize);
d278 1
a278 1
		psize = trunc_page(lsize);
d280 1
a280 1
			NEW_VMCMD2(vcset, vmcmd_map_pagedvn, psize, base, vp,
d282 3
a284 3
		if (psize != lsize) {
			NEW_VMCMD2(vcset, vmcmd_map_readvn, lsize - psize,
			    base + psize, vp, offset + psize, *prot, flags);
d287 1
a287 1
		NEW_VMCMD2(vcset, vmcmd_map_pagedvn, psize, base, vp, offset,
d294 2
a295 2
	rm = round_page(*addr + ph->p_memsz + diff);
	rf = round_page(*addr + ph->p_filesz + diff);
d300 1
a301 1
	*size = msize;
a342 7
	struct interp_ld_sec {
		Elf_Addr vaddr;
		u_long memsz;
	} loadmap[ELF_MAX_VALID_PHDR];
	int nload, idx = 0;
	Elf_Addr pos = *last;
	int file_align;
a378 69
	for (i = 0; i < eh.e_phnum; i++) {
		if (ph[i].p_type == PT_LOAD) {
			loadmap[idx].vaddr = trunc_page(ph[i].p_vaddr);
			loadmap[idx].memsz = round_page (ph[i].p_vaddr +
			    ph[i].p_memsz - loadmap[idx].vaddr);
			file_align = ph[i].p_align;
			idx++;
		}
	}
	nload = idx;

	/*
	 * If no position to load the interpreter was set by a probe
	 * function, pick the same address that a non-fixed mmap(0, ..)
	 * would (i.e. something safely out of the way).
	 */
	if (pos == ELFDEFNNAME(NO_ADDR)) {
		pos = uvm_map_hint(p, VM_PROT_EXECUTE);
	}

	pos = ELF_ROUND(pos, file_align);
	*last = epp->ep_interp_pos = pos;
	for (i = 0; i < nload;/**/) {
		vaddr_t	addr;
		struct	uvm_object *uobj;
		off_t	uoff;
		size_t	size;

#ifdef this_needs_fixing
		if (i == 0) {
			uobj = &vp->v_uvm.u_obj;
			/* need to fix uoff */
		} else {
#endif
			uobj = NULL;
			uoff = 0;
#ifdef this_needs_fixing
		}
#endif

		addr = trunc_page(pos + loadmap[i].vaddr);
		size =  round_page(addr + loadmap[i].memsz) - addr;

		/* CRAP - map_findspace does not avoid daddr+MAXDSIZ */
		if ((addr + size > (vaddr_t)p->p_vmspace->vm_daddr) &&
		    (addr < (vaddr_t)p->p_vmspace->vm_daddr + MAXDSIZ))
			addr = round_page((vaddr_t)p->p_vmspace->vm_daddr +
			    MAXDSIZ);

		if (uvm_map_findspace(&p->p_vmspace->vm_map, addr, size,
		    &addr, uobj, uoff, 0, UVM_FLAG_FIXED) == NULL) {
			if (uvm_map_findspace(&p->p_vmspace->vm_map, addr, size,
			    &addr, uobj, uoff, 0, 0) == NULL) {
				error = ENOMEM; /* XXX */
				goto bad1;
			}
		} 
		if (addr != pos + loadmap[i].vaddr) {
			/* base changed. */
			pos = addr - trunc_page(loadmap[i].vaddr);
			pos = ELF_ROUND(pos,file_align);
			epp->ep_interp_pos = *last = pos;
			i = 0;
			continue;
		}

		i++;
	}

d447 1
a447 1
	int error, i;
d540 1
a540 1
	for (i = 0; i < eh->e_phnum; i++) {
d549 2
a550 5
			 * Calcuates size of text and data segments
			 * by starting at first and going to end of last.
			 * 'rwx' sections are treated as data.
			 * this is correct for BSS_PLT, but may not be
			 * for DATA_PLT, is fine for TEXT_PLT.
d552 2
d558 1
a558 1
			 * at the protection of the section
d560 5
a564 3
			if (prot & VM_PROT_WRITE) {
				/* data section */
				if (epp->ep_dsize == ELFDEFNNAME(NO_ADDR)) {
a566 26
				} else {
					if (addr < epp->ep_daddr) {
						epp->ep_dsize =
						    epp->ep_dsize +
						    epp->ep_daddr -
						    addr;
						epp->ep_daddr = addr;
					} else
						epp->ep_dsize = addr+size -
						    epp->ep_daddr;
				}
			} else if (prot & VM_PROT_EXECUTE) {
				/* text section */
				if (epp->ep_tsize == ELFDEFNNAME(NO_ADDR)) {
					epp->ep_taddr = addr;
					epp->ep_tsize = size;
				} else {
					if (addr < epp->ep_taddr) {
						epp->ep_tsize =
						    epp->ep_tsize +
						    epp->ep_taddr -
						    addr;
						epp->ep_taddr = addr;
					} else
						epp->ep_tsize = addr+size -
						    epp->ep_taddr;
d568 3
d598 10
a732 4
/*
 * Older ELF binaries use EI_ABIVERSION (formerly EI_BRAND) to brand
 * executables.  Newer ELF binaries use EI_OSABI instead.
 */
d736 1
a736 1
	if (eh->e_ident[EI_ABIVERSION] == '\0')
d738 1
a738 1
	return (&eh->e_ident[EI_ABIVERSION]);
@


1.36
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.35 2001/09/19 13:28:43 art Exp $	*/
d639 1
a639 1
	epp->ep_vp->v_flag |= VTEXT;
@


1.35
log
@Unify elf32 and elf64 code with macros. This forced a renaming
of a few functions from elf32.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.34 2001/08/11 23:14:22 art Exp $	*/
d51 1
a51 1
#include <vm/vm.h>
@


1.34
log
@Why is it so popular to include <vm/*.h> everywhere?
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.33 2001/07/30 11:58:36 art Exp $	*/
a42 3

#if defined(_KERN_DO_ELF)

d69 5
a73 1
struct elf_probe_entry {
d77 2
a78 1
} elf_probes[] = {
d90 3
d96 7
a102 2
int elf_load_file __P((struct proc *, char *, struct exec_package *,
    struct elf_args *, u_long *));
d104 4
a107 5
int elf_check_header __P((Elf32_Ehdr *, int));
int olf_check_header __P((Elf32_Ehdr *, int, u_int8_t *));
int elf_read_from __P((struct proc *, struct vnode *, u_long, caddr_t, int));
void elf_load_psection __P((struct exec_vmcmd_set *, struct vnode *,
    Elf32_Phdr *, u_long *, u_long *, int *));
d109 3
a111 3
int exec_elf_fixup __P((struct proc *, struct exec_package *));

#define ELF_ALIGN(a, b) ((a) & ~((b) - 1))
d116 1
a116 7

extern char sigcode[], esigcode[];
#ifdef SYSCALL_DEBUG
extern char *syscallnames[];
#endif

struct emul emul_elf = {
d129 1
a129 1
	elf_copyargs,
d131 1
a131 1
	exec_elf_fixup,
a135 1

d141 2
a142 5
elf_copyargs(pack, arginfo, stack, argp)
	struct exec_package *pack;
	struct ps_strings *arginfo;
	void *stack;
	void *argp;
d150 1
a150 1
	 * dynamically linked binaries
a159 2
 * elf_check_header():
 *
d163 1
a163 3
elf_check_header(ehdr, type)
	Elf32_Ehdr *ehdr;
	int type;
d167 1
a167 1
	 * we look at the rest of the Elf32_Ehdr structure. These few elements
a192 2
 * olf_check_header():
 *
d197 1
a197 4
olf_check_header(ehdr, type, os)
	Elf32_Ehdr *ehdr;
	int type;
	u_int8_t *os;
d203 1
a203 1
	 * before we look at the rest of the Elf32_Ehdr structure. These few
d212 4
a215 2
	for (i = 0; i < sizeof elf_probes / sizeof elf_probes[0]; i++)
		if ((1 << ehdr->e_ident[OI_OS]) & elf_probes[i].os_mask)
d217 1
a238 2
 * elf_load_psection():
 * 
d242 2
a243 7
elf_load_psection(vcset, vp, ph, addr, size, prot)
	struct exec_vmcmd_set *vcset;
	struct vnode *vp;
	Elf32_Phdr *ph;
	u_long *addr;
	u_long *size;
	int *prot;
d251 1
a251 1
	if (*addr != ELF32_NO_ADDR) {
d253 2
a254 2
			*addr = ELF_ALIGN(*addr + ph->p_align, ph->p_align);
			uaddr = ELF_ALIGN(ph->p_vaddr, ph->p_align);
d261 1
a261 1
			*addr = ELF_ALIGN(uaddr, ph->p_align);
d276 1
a276 1
	 * data page if it's not page aligned we map the las page readvn.
d305 1
a305 3
 * elf_read_from():
 *
 *	Read from vnode into buffer at offset.
d308 2
a309 6
elf_read_from(p, vp, off, buf, size)
	struct proc *p;
	struct vnode *vp;
	u_long off;
	caddr_t buf;
	int size;
a325 2
 * elf_load_file():
 *
d330 2
a331 6
elf_load_file(p, path, epp, ap, last)
	struct proc *p;
	char *path;
	struct exec_package *epp;
	struct elf_args	*ap;
	u_long *last;
d335 2
a336 2
	Elf32_Ehdr eh;
	Elf32_Phdr *ph = NULL;
d339 1
a339 1
	u_long addr = *last;
d361 1
a361 1
	if ((error = elf_read_from(p, nd.ni_vp, 0,
d365 2
a366 2
	if (elf_check_header(&eh, ET_DYN) &&
	    olf_check_header(&eh, ET_DYN, &os)) {
d371 2
a372 2
	phsize = eh.e_phnum * sizeof(Elf32_Phdr);
	ph = (Elf32_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
d374 1
a374 1
	if ((error = elf_read_from(p, nd.ni_vp, eh.e_phoff, (caddr_t)ph,
d382 1
a382 1
		u_long size = 0;
d385 2
a386 2
		if (*last == ELF32_NO_ADDR)
			addr = ELF32_NO_ADDR;	/* GRRRRR!!!!! */
d391 2
a392 2
			elf_load_psection(&epp->ep_vmcmds, nd.ni_vp, &ph[i],
						&addr, &size, &prot);
d397 1
a397 1
				    ELF_ALIGN(ph[i].p_vaddr,ph[i].p_align);
d425 1
a425 1
 * exec_elf_makecmds(): Prepare an Elf binary's exec package
d434 1
a434 3
exec_elf_makecmds(p, epp)
	struct proc *p;
	struct exec_package *epp;
d436 3
a438 3
	Elf32_Ehdr *eh = epp->ep_hdr;
	Elf32_Phdr *ph, *pp;
	Elf32_Addr phdr = 0;
d444 1
a444 1
	if (epp->ep_hdrvalid < sizeof(Elf32_Ehdr))
d447 2
a448 2
	if (elf_check_header(eh, ET_EXEC) &&
	    olf_check_header(eh, ET_EXEC, &os))
d466 2
a467 2
	phsize = eh->e_phnum * sizeof(Elf32_Phdr);
	ph = (Elf32_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
d469 1
a469 1
	if ((error = elf_read_from(p, epp->ep_vp, eh->e_phoff, (caddr_t)ph,
d473 2
a474 2
	epp->ep_tsize = ELF32_NO_ADDR;
	epp->ep_dsize = ELF32_NO_ADDR;
d483 2
a484 2
			if ((error = elf_read_from(p, epp->ep_vp, pp->p_offset,
			    (caddr_t)interp, pp->p_filesz)) != 0)
d494 2
a495 2
	epp->ep_emul = &emul_elf;
	pos = ELF32_NO_ADDR;
d499 1
a499 2
	 * See which one will accept this executable. This currently only
	 * applies to Linux and SVR4 on the i386.
d508 11
a518 4
	for (i = 0; i < sizeof elf_probes / sizeof elf_probes[0] && error; i++)
		if (os == OOS_NULL || ((1 << os) & elf_probes[i].os_mask))
			error = elf_probes[i].func ?
			    (*elf_probes[i].func)(p, epp, interp, &pos, &os) :
d520 1
d526 2
a528 1

d533 1
a533 1
		u_long addr = ELF32_NO_ADDR, size = 0;
d546 2
a547 2
			elf_load_psection(&epp->ep_vmcmds, epp->ep_vp, &ph[i],
			    &addr, &size, &prot);
d556 4
d596 1
a596 1
	if (pos == ELF32_NO_ADDR)
d653 1
a653 3
exec_elf_fixup(p, epp)
	struct proc *p;
	struct exec_package *epp;
d659 1
a659 1
	u_long	pos = epp->ep_interp_pos;
d668 1
a668 1
	if ((error = elf_load_file(p, interp, epp, ap, &pos)) != 0) {
d732 1
a732 2
elf_check_brand(eh)
	Elf32_Ehdr *eh;
d739 56
a794 1
#endif /* _KERN_DO_ELF */
@


1.33
log
@Add a check for too big e_phnum that could cause us to malloc to
much and barf.
This should have been merged into this file from exec_elf64.c a long time ago.
Looking for volunteers to merge exec_elf.c and exec_elf64.c
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.32 2001/06/22 14:14:07 deraadt Exp $	*/
a54 2
#include <vm/vm_param.h>
#include <vm/vm_map.h>
@


1.32
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.31 2001/01/22 14:25:03 art Exp $	*/
d192 4
d237 4
@


1.31
log
@NATIVE_ELF -> NATIVE_EXEC_ELF (just some leftovers)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.30 2001/01/16 15:49:00 art Exp $	*/
d172 1
a172 1
        /*
d181 3
a183 3
                return (ENOEXEC);
        
        /* Now check the machine dependant header */
d186 1
a186 1
                return (ENOEXEC);
d188 1
a188 1
        /* Check the type */
d209 1
a209 1
        /*
d218 1
a218 1
                return (ENOEXEC);
d222 1
a222 1
                	goto os_ok;
d225 2
a226 2
os_ok:        
        /* Now check the machine dependant header */
d229 1
a229 1
                return (ENOEXEC);
d231 1
a231 1
        /* Check the type */
d286 1
a286 1
	if(ph->p_flags & PF_W) {
d290 1
a290 1
		if(psize != *size) {
d294 3
a296 4
	}
	else {
		 NEW_VMCMD(vcset, vmcmd_map_pagedvn, psize, *addr, vp, offset,
		     *prot);
d417 1
a417 1
                                        ELF_ALIGN(ph[i].p_vaddr,ph[i].p_align);
d566 2
a567 2
			if (eh->e_entry >= addr && eh->e_entry < (addr + size))
			    {
d634 1
a634 2
	}
	else {
d673 1
a673 1
	if(epp->ep_interp == 0) {
@


1.31.2.1
log
@Pull in patch from current:
Fix (art):
Add a check for too big e_phnum that could cause us to malloc to
much and barf.
This should have been merged into this file from exec_elf64.c a long time ago.
Looking for volunteers to merge exec_elf.c and exec_elf64.c
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.33 2001/07/30 11:58:36 art Exp $	*/
a191 4
	/* Don't allow an insane amount of sections. */
	if (ehdr->e_phnum > 128)
		return (ENOEXEC);

a232 4
		return (ENOEXEC);

	/* Don't allow an insane amount of sections. */
	if (ehdr->e_phnum > 128)
@


1.30
log
@Indentation nit.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.29 2000/01/01 21:11:18 mickey Exp $	*/
d539 1
a539 1
#ifndef NATIVE_ELF
d542 1
a542 1
#endif /* NATIVE_ELF */
@


1.29
log
@grammar in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.28 1999/11/25 13:41:30 art Exp $	*/
d703 1
a703 1
	if(error == 0) {
@


1.29.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.31 2001/01/22 14:25:03 art Exp $	*/
d539 1
a539 1
#ifndef NATIVE_EXEC_ELF
d542 1
a542 1
#endif /* NATIVE_EXEC_ELF */
d703 1
a703 1
	if (error == 0) {
@


1.29.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.29.2.1 2001/05/14 22:32:38 niklas Exp $	*/
d172 1
a172 1
	/*
d181 3
a183 3
		return (ENOEXEC);

	/* Now check the machine dependant header */
d186 1
a186 1
		return (ENOEXEC);
d188 1
a188 1
	/* Check the type */
d209 1
a209 1
	/*
d218 1
a218 1
		return (ENOEXEC);
d222 1
a222 1
			goto os_ok;
d225 2
a226 2
os_ok:
	/* Now check the machine dependant header */
d229 1
a229 1
		return (ENOEXEC);
d231 1
a231 1
	/* Check the type */
d286 1
a286 1
	if (ph->p_flags & PF_W) {
d290 1
a290 1
		if (psize != *size) {
d294 4
a297 3
	} else {
		NEW_VMCMD(vcset, vmcmd_map_pagedvn, psize, *addr, vp, offset,
		    *prot);
d418 1
a418 1
				    ELF_ALIGN(ph[i].p_vaddr,ph[i].p_align);
d567 2
a568 2
			if (eh->e_entry >= addr &&
			    eh->e_entry < (addr + size)) {
d635 2
a636 1
	} else {
d675 1
a675 1
	if (epp->ep_interp == 0) {
@


1.29.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.29.2.2 2001/07/04 10:48:12 niklas Exp $	*/
d43 3
d55 2
d74 1
a74 5
#ifdef COMPAT_NETBSD
#include <compat/netbsd/netbsd_exec.h>
#endif

struct ELFNAME(probe_entry) {
d78 1
a78 2
} ELFNAME(probes)[] = {
	/* XXX - bogus, shouldn't be size independent.. */
a89 3
#ifdef COMPAT_NETBSD
	{ netbsd_elf64_probe, 1 << OOS_NETBSD },
#endif
d93 16
a108 7
int ELFNAME(load_file)(struct proc *, char *, struct exec_package *,
	struct elf_args *, Elf_Addr *);
int ELFNAME(check_header)(Elf_Ehdr *, int);
int ELFNAME(olf_check_header)(Elf_Ehdr *, int, u_int8_t *);
int ELFNAME(read_from)(struct proc *, struct vnode *, u_long, caddr_t, int);
void ELFNAME(load_psection)(struct exec_vmcmd_set *, struct vnode *,
	Elf_Phdr *, Elf_Addr *, Elf_Addr *, int *);
d115 1
a115 8
/* round up and down to page boundaries. */
#define ELF_ROUND(a, b)		(((a) + (b) - 1) & ~((b) - 1))
#define ELF_TRUNC(a, b)		((a) & ~((b) - 1))

/*
 * This is the basic elf emul. elf_probe_funcs may change to other emuls.
 */
struct emul ELFNAMEEND(emul) = {
d128 1
a128 1
	ELFNAME(copyargs),
d130 1
a130 1
	ELFNAME2(exec,fixup),
d135 1
d141 5
a145 2
ELFNAME(copyargs)(struct exec_package *pack, struct ps_strings *arginfo,
		void *stack, void *argp)
d153 1
a153 1
	 * dynamically linked binaries.
d163 2
d168 3
a170 1
ELFNAME(check_header)(Elf_Ehdr *ehdr, int type)
d174 1
a174 1
	 * we look at the rest of the Elf_Ehdr structure. These few elements
a191 4
	/* Don't allow an insane amount of sections. */
	if (ehdr->e_phnum > 128)
		return (ENOEXEC);

d196 2
d202 4
a205 1
ELFNAME(olf_check_header)(Elf_Ehdr *ehdr, int type, u_int8_t *os)
d211 1
a211 1
	 * before we look at the rest of the Elf_Ehdr structure. These few
d220 2
a221 4
	for (i = 0;
	    i < sizeof(ELFNAME(probes)) / sizeof(ELFNAME(probes)[0]);
	    i++) {
		if ((1 << ehdr->e_ident[OI_OS]) & ELFNAME(probes)[i].os_mask)
a222 1
	}
a234 4
	/* Don't allow an insane amount of sections. */
	if (ehdr->e_phnum > 128)
		return (ENOEXEC);

d240 2
d245 7
a251 2
ELFNAME(load_psection)(struct exec_vmcmd_set *vcset, struct vnode *vp,
	Elf_Phdr *ph, Elf_Addr *addr, Elf_Addr *size, int *prot)
d259 1
a259 1
	if (*addr != ELFDEFNNAME(NO_ADDR)) {
d261 2
a262 2
			*addr = ELF_ROUND(*addr, ph->p_align);
			uaddr = ELF_TRUNC(ph->p_vaddr, ph->p_align);
d269 1
a269 1
			*addr = ELF_TRUNC(uaddr, ph->p_align);
d284 1
a284 1
	 * data page if it's not page aligned we map the last page readvn.
d313 3
a315 1
 * Read from vnode into buffer at offset.
d318 6
a323 2
ELFNAME(read_from)(struct proc *p, struct vnode *vp, u_long off, caddr_t buf,
	int size)
d340 2
d346 6
a351 2
ELFNAME(load_file)(struct proc *p, char *path, struct exec_package *epp,
	struct elf_args *ap, Elf_Addr *last)
d355 2
a356 2
	Elf_Ehdr eh;
	Elf_Phdr *ph = NULL;
d359 1
a359 1
	Elf_Addr addr = *last;
d381 1
a381 1
	if ((error = ELFNAME(read_from)(p, nd.ni_vp, 0,
d385 2
a386 2
	if (ELFNAME(check_header)(&eh, ET_DYN) &&
	    ELFNAME(olf_check_header)(&eh, ET_DYN, &os)) {
d391 2
a392 2
	phsize = eh.e_phnum * sizeof(Elf_Phdr);
	ph = (Elf_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
d394 1
a394 1
	if ((error = ELFNAME(read_from)(p, nd.ni_vp, eh.e_phoff, (caddr_t)ph,
d402 1
a402 1
		Elf_Addr size = 0;
d405 2
a406 2
		if (*last == ELFDEFNNAME(NO_ADDR))
			addr = ELFDEFNNAME(NO_ADDR);	/* GRRRRR!!!!! */
d411 2
a412 2
			ELFNAME(load_psection)(&epp->ep_vmcmds, nd.ni_vp,
					&ph[i], &addr, &size, &prot);
d417 1
a417 1
				    ELF_TRUNC(ph[i].p_vaddr,ph[i].p_align);
d445 1
a445 1
 * Prepare an Elf binary's exec package
d454 3
a456 1
ELFNAME2(exec,makecmds)(struct proc *p, struct exec_package *epp)
d458 3
a460 3
	Elf_Ehdr *eh = epp->ep_hdr;
	Elf_Phdr *ph, *pp;
	Elf_Addr phdr = 0;
d466 1
a466 1
	if (epp->ep_hdrvalid < sizeof(Elf_Ehdr))
d469 2
a470 2
	if (ELFNAME(check_header)(eh, ET_EXEC) &&
	    ELFNAME(olf_check_header)(eh, ET_EXEC, &os))
d488 2
a489 2
	phsize = eh->e_phnum * sizeof(Elf_Phdr);
	ph = (Elf_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
d491 1
a491 1
	if ((error = ELFNAME(read_from)(p, epp->ep_vp, eh->e_phoff, (caddr_t)ph,
d495 2
a496 2
	epp->ep_tsize = ELFDEFNNAME(NO_ADDR);
	epp->ep_dsize = ELFDEFNNAME(NO_ADDR);
d505 2
a506 2
			if ((error = ELFNAME(read_from)(p, epp->ep_vp,
			    pp->p_offset, (caddr_t)interp, pp->p_filesz)) != 0)
d516 2
a517 2
	epp->ep_emul = &ELFNAMEEND(emul);
	pos = ELFDEFNNAME(NO_ADDR);
d521 2
a522 1
	 * See which one will accept this executable.
d531 4
a534 11
#ifdef NATIVE_EXEC_ELF
	if (ELFNAME(os_pt_note)(p, epp, epp->ep_hdr, "OpenBSD", 8, 4) == 0) {
		goto native;
	}
#endif
	for (i = 0;
	    i < sizeof(ELFNAME(probes)) / sizeof(ELFNAME(probes)[0]) && error;
	    i++) {
		if (os == OOS_NULL || ((1 << os) & ELFNAME(probes)[i].os_mask))
			error = ELFNAME(probes)[i].func ?
			    (*ELFNAME(probes)[i].func)(p, epp, interp, &pos, &os) :
a535 1
	}
a540 2
#else
native:
d542 1
d547 1
a547 1
		Elf_Addr addr = ELFDEFNNAME(NO_ADDR), size = 0;
d560 2
a561 2
			ELFNAME(load_psection)(&epp->ep_vmcmds, epp->ep_vp,
			    &ph[i], &addr, &size, &prot);
a569 4
				if (epp->ep_daddr == ELFDEFNNAME(NO_ADDR)) {
					epp->ep_daddr = addr;
					epp->ep_dsize = size;
				}
d606 1
a606 1
	if (pos == ELFDEFNNAME(NO_ADDR))
d663 3
a665 1
ELFNAME2(exec,fixup)(struct proc *p, struct exec_package *epp)
d671 1
a671 1
	Elf_Addr	pos = epp->ep_interp_pos;
d680 1
a680 1
	if ((error = ELFNAME(load_file)(p, interp, epp, ap, &pos)) != 0) {
d744 2
a745 1
ELFNAME(check_brand)(Elf_Ehdr *eh)
d752 1
a752 56
int
ELFNAME(os_pt_note)(struct proc *p, struct exec_package *epp, Elf_Ehdr *eh,
	char *os_name, size_t name_size, size_t desc_size)
{
	Elf_Phdr *hph, *ph;
	Elf_Note *np = NULL;
	size_t phsize;
	int error;

	phsize = eh->e_phnum * sizeof(Elf_Phdr);
	hph = (Elf_Phdr *)malloc(phsize, M_TEMP, M_WAITOK);
	if ((error = ELFNAME(read_from)(p, epp->ep_vp, eh->e_phoff,
	    (caddr_t)hph, phsize)) != 0)
		goto out1;

	for (ph = hph;  ph < &hph[eh->e_phnum]; ph++) {
		if (ph->p_type != PT_NOTE ||
		    ph->p_filesz < sizeof(Elf_Note) + name_size)
			continue;

		np = (Elf_Note *)malloc(ph->p_filesz, M_TEMP, M_WAITOK);
		if ((error = ELFNAME(read_from)(p, epp->ep_vp, ph->p_offset,
		    (caddr_t)np, ph->p_filesz)) != 0)
			goto out2;

#if 0
		if (np->type != ELF_NOTE_TYPE_OSVERSION) {
			free(np, M_TEMP);
			np = NULL;
			continue;
		}
#endif

		/* Check the name and description sizes. */
		if (np->namesz != name_size ||
		    np->descsz != desc_size)
			goto out3;

		if (bcmp((np + 1), os_name, name_size))
			goto out3;

		/* XXX: We could check for the specific emulation here */
		/* All checks succeeded. */
		error = 0;
		goto out2;
	}

out3:
	error = ENOEXEC;
out2:
	if (np)
		free(np, M_TEMP);
out1:
	free(hph, M_TEMP);
	return error;
}
@


1.29.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
a51 1
#include <uvm/uvm_extern.h>
@


1.29.2.5
log
@Merge in -current
@
text
@d639 1
a639 1
	vn_marktext(epp->ep_vp);
@


1.29.2.6
log
@Merge in -current from about a week ago
@
text
@d74 2
a75 2
	int (*func)(struct proc *, struct exec_package *, char *,
	    u_long *, u_int8_t *);
@


1.29.2.7
log
@Sync the SMP branch with 3.3
@
text
@d102 1
a102 1
	Elf_Phdr *, Elf_Addr *, Elf_Addr *, int *, int);
d243 1
a243 1
	Elf_Phdr *ph, Elf_Addr *addr, Elf_Addr *size, int *prot, int flags)
d245 2
a246 3
	u_long uaddr, msize, lsize, psize, rm, rf;
	long diff, offset, bdiff;
	Elf_Addr base;
d253 2
a254 8
			*addr = ELF_TRUNC(*addr, ph->p_align);
			diff = ph->p_vaddr - ELF_TRUNC(ph->p_vaddr, ph->p_align);
			/* page align vaddr */
			base = *addr + trunc_page(ph->p_vaddr) 
			    - ELF_TRUNC(ph->p_vaddr, ph->p_align);

			bdiff = ph->p_vaddr - trunc_page(ph->p_vaddr);

d256 2
a257 1
			diff = 0;
a261 2
		base = trunc_page(uaddr);
		bdiff = uaddr - base;
d269 2
d272 1
a272 3
	offset = ph->p_offset - bdiff;
	lsize = ph->p_filesz + bdiff;
	psize = round_page(lsize);
d279 6
a284 7
		psize = trunc_page(lsize);
		if (psize > 0)
			NEW_VMCMD2(vcset, vmcmd_map_pagedvn, psize, base, vp,
			    offset, *prot, flags);
		if (psize != lsize) {
			NEW_VMCMD2(vcset, vmcmd_map_readvn, lsize - psize,
			    base + psize, vp, offset + psize, *prot, flags);
d287 2
a288 2
		NEW_VMCMD2(vcset, vmcmd_map_pagedvn, psize, base, vp, offset,
		    *prot, flags);
d294 2
a295 2
	rm = round_page(*addr + ph->p_memsz + diff);
	rf = round_page(*addr + ph->p_filesz + diff);
d298 3
a300 2
		NEW_VMCMD2(vcset, vmcmd_map_zero, rm - rf, rf, NULLVP, 0,
		    *prot, flags);
a301 1
	*size = msize;
d315 1
a315 1
	    0, p->p_ucred, &resid, p)) != 0)
d339 1
a339 1
	Elf_Addr addr;
a341 1
	Elf_Phdr *base_ph = NULL;
d384 4
a387 1
		int flags;
a390 8
			if (base_ph == NULL) {
				flags = VMCMD_BASE;
				addr = *last;
				base_ph = &ph[i];
			} else {
				flags = VMCMD_RELATIVE;
				addr = ph[i].p_vaddr - base_ph->p_vaddr;
			}
d392 1
a392 1
			    &ph[i], &addr, &size, &prot, flags);
a412 2
	vn_marktext(nd.ni_vp);

d439 1
a439 1
	int error, i;
d532 1
a532 1
	for (i = 0; i < eh->e_phnum; i++) {
d541 2
a542 5
			 * Calcuates size of text and data segments
			 * by starting at first and going to end of last.
			 * 'rwx' sections are treated as data.
			 * this is correct for BSS_PLT, but may not be
			 * for DATA_PLT, is fine for TEXT_PLT.
d544 2
d547 1
a547 1
			    &ph[i], &addr, &size, &prot, 0);
d550 1
a550 1
			 * at the protection of the section
d552 5
a556 3
			if (prot & VM_PROT_WRITE) {
				/* data section */
				if (epp->ep_dsize == ELFDEFNNAME(NO_ADDR)) {
a558 26
				} else {
					if (addr < epp->ep_daddr) {
						epp->ep_dsize =
						    epp->ep_dsize +
						    epp->ep_daddr -
						    addr;
						epp->ep_daddr = addr;
					} else
						epp->ep_dsize = addr+size -
						    epp->ep_daddr;
				}
			} else if (prot & VM_PROT_EXECUTE) {
				/* text section */
				if (epp->ep_tsize == ELFDEFNNAME(NO_ADDR)) {
					epp->ep_taddr = addr;
					epp->ep_tsize = size;
				} else {
					if (addr < epp->ep_taddr) {
						epp->ep_tsize =
						    epp->ep_tsize +
						    epp->ep_taddr -
						    addr;
						epp->ep_taddr = addr;
					} else
						epp->ep_tsize = addr+size -
						    epp->ep_taddr;
d560 3
d656 1
a656 1
	int	error;
d661 1
a661 1
	if (epp->ep_interp == NULL) {
d677 7
a683 1
	error = exec_process_vmcmds(p, epp);
@


1.29.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.29.2.7 2003/03/28 00:41:26 niklas Exp $	*/
a113 6
 * We limit the number of program headers to 32, this should
 * be a reasonable limit for ELF, the most we have seen so far is 12
 */
#define ELF_MAX_VALID_PHDR 32

/*
d186 1
a186 1
	if (ehdr->e_phnum > ELF_MAX_VALID_PHDR)
d231 1
a231 1
	if (ehdr->e_phnum > ELF_MAX_VALID_PHDR)
a351 7
	struct interp_ld_sec {
		Elf_Addr vaddr;
		u_long memsz;
	} loadmap[ELF_MAX_VALID_PHDR];
	int nload, idx = 0;
	Elf_Addr pos = *last;
	int file_align;
a387 69
	for (i = 0; i < eh.e_phnum; i++) {
		if (ph[i].p_type == PT_LOAD) {
			loadmap[idx].vaddr = trunc_page(ph[i].p_vaddr);
			loadmap[idx].memsz = round_page (ph[i].p_vaddr +
			    ph[i].p_memsz - loadmap[idx].vaddr);
			file_align = ph[i].p_align;
			idx++;
		}
	}
	nload = idx;

	/*
	 * If no position to load the interpreter was set by a probe
	 * function, pick the same address that a non-fixed mmap(0, ..)
	 * would (i.e. something safely out of the way).
	 */
	if (pos == ELFDEFNNAME(NO_ADDR)) {
		pos = uvm_map_hint(p, VM_PROT_EXECUTE);
	}

	pos = ELF_ROUND(pos, file_align);
	*last = epp->ep_interp_pos = pos;
	for (i = 0; i < nload;/**/) {
		vaddr_t	addr;
		struct	uvm_object *uobj;
		off_t	uoff;
		size_t	size;

#ifdef this_needs_fixing
		if (i == 0) {
			uobj = &vp->v_uvm.u_obj;
			/* need to fix uoff */
		} else {
#endif
			uobj = NULL;
			uoff = 0;
#ifdef this_needs_fixing
		}
#endif

		addr = trunc_page(pos + loadmap[i].vaddr);
		size =  round_page(addr + loadmap[i].memsz) - addr;

		/* CRAP - map_findspace does not avoid daddr+MAXDSIZ */
		if ((addr + size > (vaddr_t)p->p_vmspace->vm_daddr) &&
		    (addr < (vaddr_t)p->p_vmspace->vm_daddr + MAXDSIZ))
			addr = round_page((vaddr_t)p->p_vmspace->vm_daddr +
			    MAXDSIZ);

		if (uvm_map_findspace(&p->p_vmspace->vm_map, addr, size,
		    &addr, uobj, uoff, 0, UVM_FLAG_FIXED) == NULL) {
			if (uvm_map_findspace(&p->p_vmspace->vm_map, addr, size,
			    &addr, uobj, uoff, 0, 0) == NULL) {
				error = ENOMEM; /* XXX */
				goto bad1;
			}
		} 
		if (addr != pos + loadmap[i].vaddr) {
			/* base changed. */
			pos = addr - trunc_page(loadmap[i].vaddr);
			pos = ELF_ROUND(pos,file_align);
			epp->ep_interp_pos = *last = pos;
			i = 0;
			continue;
		}

		i++;
	}

d628 10
@


1.29.2.9
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a835 4
/*
 * Older ELF binaries use EI_ABIVERSION (formerly EI_BRAND) to brand
 * executables.  Newer ELF binaries use EI_OSABI instead.
 */
d839 1
a839 1
	if (eh->e_ident[EI_ABIVERSION] == '\0')
d841 1
a841 1
	return (&eh->e_ident[EI_ABIVERSION]);
@


1.29.2.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.29.2.9 2003/05/16 00:29:43 niklas Exp $	*/
d200 1
a200 1
 * Remember OS tag for callers sake.
@


1.29.2.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a139 1
	EMUL_ENABLED | EMUL_NATIVE,
a864 1
		    ph->p_filesz > 1024 ||
@


1.28
log
@Use PAGE_SIZE instead of NBPG.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.27 1999/08/12 20:37:16 niklas Exp $	*/
d689 1
a689 1
	 * We have to do this ourselfs...
@


1.27
log
@Probe svr4 before linux
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.26 1999/07/20 12:14:34 deraadt Exp $	*/
d646 1
a646 1
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, NBPG, 0,
d719 1
a719 1
		a->au_v = NBPG;
@


1.26
log
@correct os_mask handling for OLF; pefo
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.25 1999/06/01 17:54:31 pefo Exp $	*/
a81 3
#ifdef COMPAT_LINUX
	{ linux_elf_probe, 1 << OOS_LINUX },
#endif
d86 3
@


1.25
log
@Fix some mips -> __mips__ stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.24 1999/02/10 08:07:20 deraadt Exp $	*/
d80 1
a80 1
	{ freebsd_elf_probe, OOS_FREEBSD },
d83 1
a83 1
	{ linux_elf_probe, OOS_LINUX },
d90 1
a90 1
	{ 0, OOS_OPENBSD }
@


1.24
log
@branding support and freebsd elf
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.23 1999/01/11 05:12:22 millert Exp $	*/
d405 1
a405 1
#ifdef mips
d601 1
a601 1
#if !defined(mips)
@


1.23
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.22 1998/07/28 00:13:02 millert Exp $	*/
d70 4
d79 6
a89 3
#ifdef COMPAT_LINUX
	{ linux_elf_probe, OOS_LINUX },
#endif
d744 10
@


1.22
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.21 1998/03/06 21:49:50 niklas Exp $	*/
d474 1
a474 1
			panic("exec: a VTEXT vnode has writecount != 0\n");
@


1.21
log
@Ensure the correct probe will be run for an OLF binary
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.20 1998/02/22 01:13:12 niklas Exp $	*/
d320 1
a320 1
	int resid;
@


1.20
log
@Save possible OLF OS tag, or similar deduced ELF info for later perusal.
KNF.  This has been sitting for a long time in my tree now.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.19 1996/12/23 02:42:43 deraadt Exp $	*/
d70 5
a74 2
int (*elf_probe_funcs[]) __P((struct proc *, struct exec_package *, char *,
    u_long *, u_int8_t *)) = {
d76 3
a78 1
	svr4_elf_probe,
d81 1
a81 1
	linux_elf_probe
d83 1
a85 10
static int olf_os_accepted = 1 << OOS_OPENBSD |
#ifdef COMPAT_SVR4
    1 << OOS_SVR4 | 1 << OOS_ESIX | 1 << OOS_SOLARIS | 1 << OOS_SCO |
    1 << OOS_DELL | 1 << OOS_NCR |
#endif
#ifdef COMPAT_LINUX
    1 << OOS_LINUX |
#endif
    0;

d200 2
d210 1
a210 2
	    ehdr->e_ident[OI_VERSION] != ELF_TARG_VER ||
	    !(ehdr->e_ident[OI_OS] & olf_os_accepted))
d212 7
a218 1
        
d455 1
a455 1
	int error, i, n, nload;
d523 13
a535 10
	if (os == OOS_NULL &&
	    (n = sizeof elf_probe_funcs / sizeof elf_probe_funcs[0])) {
		error = ENOEXEC;
		for (i = 0; i < n && error; i++)
			error = elf_probe_funcs[i](p, epp, interp, &pos, &os);

		if (error)
			goto bad;
	}
	p->p_os = os;
d634 2
a635 1
#ifdef ELF_MAP_PAGE_ZERO
d637 4
a640 2
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, NBPG, 0, epp->ep_vp, 0,
	    VM_PROT_READ);
@


1.19
log
@use _{NLIST,KERN}_DO_{AOUT,ELF,ECOFF} to select binary types
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.18 1996/11/24 18:31:25 etheisen Exp $	*/
d70 2
a71 2
int (*elf_probe_funcs[]) __P((struct proc *, struct exec_package *,
			      char *, u_long *)) = {
d80 10
d91 1
a91 1
		       struct elf_args *, u_long *));
d94 1
a94 1
int olf_check_header __P((Elf32_Ehdr *, int));
d96 2
a97 2
void elf_load_psection __P((struct exec_vmcmd_set *,
	struct vnode *, Elf32_Phdr *, u_long *, u_long *, int *));
d124 1
a124 1
	sizeof(AuxInfo) * ELF_AUX_ENTRIES,
d146 1
a146 1
		return NULL;
d156 1
a156 1
	return stack;
d178 1
a178 1
                return ENOEXEC;
d183 1
a183 1
                return ENOEXEC;
d187 1
a187 1
		return ENOEXEC;
d189 1
a189 1
	return 0;
d195 2
a196 1
 * Check header for validity; return 0 for ok, ENOEXEC if error
d199 1
a199 1
olf_check_header(ehdr, type)
d202 1
d213 2
a214 2
	    ehdr->e_ident[OI_OS] != OOS_OPENBSD)
                return ENOEXEC;
d219 1
a219 1
                return ENOEXEC;
d223 1
a223 1
		return ENOEXEC;
d225 2
a226 1
	return 0;
d278 2
a279 1
		NEW_VMCMD(vcset, vmcmd_map_pagedvn, psize, *addr, vp, offset, *prot);
d281 2
a282 2
			NEW_VMCMD(vcset, vmcmd_map_readvn, *size - psize, *addr
+ psize, vp, offset + psize, *prot);
d286 2
a287 1
		 NEW_VMCMD(vcset, vmcmd_map_pagedvn, psize, *addr, vp, offset, *prot);
d297 2
a298 1
		NEW_VMCMD(vcset, vmcmd_map_zero, rm - rf, rf, NULLVP, 0, *prot);
d319 2
a320 3
	if ((error = vn_rdwr(UIO_READ, vp, buf, size,
			     off, UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred,
			     &resid, p)) != 0)
d326 2
a327 2
		return ENOEXEC;
	return 0;
d333 2
a334 3
 * Load a file (interpreter/library) pointed to by path
 * [stolen from coff_load_shlib()]. Made slightly generic
 * so it might be used externally.
d352 1
d357 1
a357 1
		return error;
d373 1
a373 1
				    (caddr_t) &eh, sizeof(eh))) != 0)
d376 2
a377 1
	if (elf_check_header(&eh, ET_DYN) && olf_check_header(&eh, ET_DYN)) {
d383 1
a383 1
	ph = (Elf32_Phdr *) malloc(phsize, M_TEMP, M_WAITOK);
d385 2
a386 2
	if ((error = elf_read_from(p, nd.ni_vp, eh.e_phoff,
				    (caddr_t) ph, phsize)) != 0)
d428 1
a428 1
		free((char *) ph, M_TEMP);
d432 1
a432 1
	return error;
d440 3
a442 4
 * Then, mark the text image busy (so it can be demand paged) or error
 * out if this is not possible.  Finally, set up vmcmds for the
 * text, data, bss, and stack segments.
 *
d455 1
d458 1
a458 1
		return ENOEXEC;
d460 3
a462 2
	if (elf_check_header(eh, ET_EXEC) && olf_check_header(eh, ET_EXEC))
		return ENOEXEC;
d465 2
a466 3
	 * check if vnode is in open for writing, because we want to
	 * demand-page out of it.  if it is, don't do it, for various
	 * reasons
d473 1
a473 1
		return ETXTBSY;
d480 1
a480 1
	ph = (Elf32_Phdr *) malloc(phsize, M_TEMP, M_WAITOK);
d482 2
a483 2
	if ((error = elf_read_from(p, epp->ep_vp, eh->e_phoff,
				    (caddr_t) ph, phsize)) != 0)
d497 1
a497 1
			    (caddr_t) interp, pp->p_filesz)) != 0)
d520 2
a521 1
	if ((n = sizeof elf_probe_funcs / sizeof elf_probe_funcs[0])) {
d524 1
a524 1
			error = elf_probe_funcs[i](p, epp, interp, &pos);
d529 1
d535 1
a535 1
		u_long  addr = ELF32_NO_ADDR, size = 0;
d548 2
a549 2
			elf_load_psection(&epp->ep_vmcmds, epp->ep_vp,
				&ph[i], &addr, &size, &prot);
d554 2
a555 1
			if (eh->e_entry >= addr && eh->e_entry < (addr + size)){
d581 2
a582 1
			 * Not fatal, we don't need to understand everything :-)
d606 3
a608 3
		ip = (char *) malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
		ap = (struct elf_args *) malloc(sizeof(struct elf_args),
						 M_TEMP, M_WAITOK);
d618 1
d634 1
a634 1
	free((char *) ph, M_TEMP);
d636 1
a636 1
	return exec_setup_stack(p, epp);
d639 1
a639 1
	free((char *) ph, M_TEMP);
d641 1
a641 1
	return ENOEXEC;
d660 1
a660 1
		return 0;
d664 1
a664 1
	ap = (struct elf_args *) epp->ep_emul_arg;
d667 2
a668 2
		free((char *) ap, M_TEMP);
		free((char *) interp, M_TEMP);
d670 1
a670 1
		return error;
d724 3
a726 3
	free((char *) ap, M_TEMP);
	free((char *) interp, M_TEMP);
	return error;
@


1.18
log
@OLF is ALIVE!
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.17 1996/09/12 18:52:17 pefo Exp $	*/
d43 3
a52 7
#if defined(COMPAT_LINUX) || defined(COMPAT_SVR4)	/*XXX should be */
#undef EXEC_ELF						/*XXX defined in */
#define EXEC_ELF					/*XXX machine/exec.h */
#endif							/*XXX instead ? */

#if defined(NATIVE_EXEC_ELF) || defined(EXEC_ELF)

d615 1
a615 1
	return exec_aout_setup_stack(p, epp);
d707 1
a707 1
#endif /* NATIVE_EXEC_ELF || EXEC_ELF */
@


1.17
log
@ok, must have read access at least.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.16 1996/09/12 14:43:30 pefo Exp $	*/
d44 1
d87 4
a90 3
static int elf_check_header __P((Elf32_Ehdr *, int));
static int elf_read_from __P((struct proc *, struct vnode *, u_long, caddr_t, int));
static void elf_load_psection __P((struct exec_vmcmd_set *,
d158 1
a158 1
static int
d187 34
d225 1
a225 1
static void
d296 1
a296 1
static int
d365 2
a366 1
	if ((error = elf_check_header(&eh, ET_DYN)) != 0)
d368 1
d448 1
a448 1
	if (elf_check_header(eh, ET_EXEC))
@


1.16
log
@remove excess tests...
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.15 1996/09/05 17:31:06 pefo Exp $	*/
d323 2
@


1.15
log
@ld has some funny things going with alignments...
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.14 1996/08/31 09:24:07 pefo Exp $	*/
a322 9
	if ((error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p)) != 0)
		goto bad;
	if ((epp->ep_vap->va_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) == 0) {
		error = EACCES;
		goto bad;
	}
	if ((error = VOP_OPEN(vp, FREAD, p->p_ucred, p)) != 0)
		goto bad;

@


1.14
log
@Cleanup exec
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.13 1996/08/05 10:48:18 niklas Exp $	*/
d352 4
@


1.13
log
@layout style nit (am I a pedant, or what?)
@
text
@d1 1
a1 2
/*	$OpenBSD: exec_elf.c,v 1.12 1996/06/16 20:05:08 etheisen Exp $	*/
/*	$NetBSD: exec_elf.c,v 1.6 1996/02/09 18:59:18 christos Exp $	*/
d4 3
d39 1
d44 1
d47 1
d83 2
a84 3
int elf_check_header __P((Elf32_Ehdr *, int));
int elf_load_file __P((struct proc *, char *, struct exec_vmcmd_set *,
		       u_long *, struct elf_args *, u_long *));
d86 2
a87 2
static int elf_read_from __P((struct proc *, struct vnode *, u_long,
	caddr_t, int));
d91 2
d119 1
d127 1
a127 1
 * extra information in case of dynamic binding.
a135 4
	size_t len;
	AuxInfo ai[ELF_AUX_ENTRIES], *a;
	struct elf_args *ap;

d141 2
a142 2
	 * Push extra arguments on the stack needed by dynamically
	 * linked binaries
d144 3
a146 40
	if ((ap = (struct elf_args *) pack->ep_emul_arg)) {
		a = ai;

		a->au_id = AUX_phdr;
		a->au_v = ap->arg_phaddr;
		a++;

		a->au_id = AUX_phent;
		a->au_v = ap->arg_phentsize;
		a++;

		a->au_id = AUX_phnum;
		a->au_v = ap->arg_phnum;
		a++;

		a->au_id = AUX_pagesz;
		a->au_v = NBPG;
		a++;

		a->au_id = AUX_base;
		a->au_v = ap->arg_interp;
		a++;

		a->au_id = AUX_flags;
		a->au_v = 0;
		a++;

		a->au_id = AUX_entry;
		a->au_v = ap->arg_entry;
		a++;

		a->au_id = AUX_null;
		a->au_v = 0;
		a++;

		free((char *) ap, M_TEMP);
		len = ELF_AUX_ENTRIES * sizeof (AuxInfo);
		if (copyout(ai, stack, len))
			return NULL;
		stack += len;
d156 1
a156 1
int
d162 3
a164 4
	 * We need to check magic, class size, endianess,
	 * and version before we look at the rest of the
	 * Elf32_Ehdr structure.  These few elements are
	 * represented in a machine independant fashion.
d262 1
a264 1
	struct proc *p;
d291 1
a291 1
elf_load_file(p, path, vcset, entry, ap, last)
d294 1
a294 2
	struct exec_vmcmd_set *vcset;
	u_long *entry;
d305 1
d308 1
a308 6
	/*
	 * 1. open file
	 * 2. read filehdr
	 * 3. map text, data, and bss out of it using VM_*
	 */
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, path, p);
d312 18
a329 2
	if ((error = elf_read_from(p, nd.ni_vp, 0, (caddr_t) &eh,
				    sizeof(eh))) != 0)
d332 4
d337 1
a337 1
		goto bad;
d344 1
a344 1
		goto bad;
d355 2
a356 2
			elf_load_psection(vcset, nd.ni_vp, &ph[i], &addr,
						&size, &prot);
d360 1
a360 1
 				*entry = addr + eh.e_entry -
d377 2
d384 1
a384 1
	vrele(nd.ni_vp);
d527 1
a527 1
		break;
d531 1
a531 2
			 * Not fatal, we don't need to understand everything
			 * :-)
d549 1
a549 1
	 * it's interpreter
d552 1
d555 1
d558 5
a562 6
		if ((error = elf_load_file(p, interp, &epp->ep_vmcmds,
				&epp->ep_entry, ap, &pos)) != 0) {
			free((char *) ap, M_TEMP);
			goto bad;
		}
		pos += phsize;
a563 1

d569 4
a572 1
	} else
d574 1
d590 85
@


1.12
log
@Whoops. Don't forget to take alignment into account when processing file.
Thanks Per.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.11 1996/06/15 07:30:05 etheisen Exp $	*/
d342 1
a342 1
	bp  = path;
@


1.11
log
@elf_check_header() is now fully functional.  Still need to add OS checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.10 1996/06/10 03:39:06 deraadt Exp $	*/
d380 2
a381 1
				*entry = addr + eh.e_entry - ph[i].p_vaddr;
@


1.10
log
@emul_elf has a name of "native"
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.9 1996/06/10 00:48:59 deraadt Exp $	*/
d188 1
a188 5
 * Check header for validity; return 0 of ok ENOEXEC if error
 *
 * XXX machine type needs to be moved to <machine/param.h> so
 * just one comparison can be done. Unfortunately, there is both
 * em_486 and em_386, so this would not work on the i386.
d191 2
a192 2
elf_check_header(eh, type)
	Elf32_Ehdr *eh;
d195 16
d212 2
a213 22
	if (!IS_ELF(eh[0]))
		return ENOEXEC;

	switch (eh->e_machine) {
	/* XXX */
#ifdef i386
	case EM_386:
	case EM_486:
#endif
#ifdef sparc
	case EM_SPARC:
#endif
#ifdef mips
	case EM_MIPS:
#endif
		break;

	default:
		return ENOEXEC;
	}

	if (eh->e_type != type)
@


1.9
log
@use a shorter emul name
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.8 1996/06/09 20:47:13 deraadt Exp $	*/
d99 1
a99 1
	"nativelf",
@


1.8
log
@emulation name is "native elf"
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.7 1996/06/06 07:39:37 pefo Exp $	*/
d99 1
a99 1
	"native elf",
@


1.7
log
@Paging exec_elf + mips enhancements
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.5 1996/04/18 17:15:52 niklas Exp $	*/
d99 6
a104 6
      "netbsd",
      NULL,
      sendsig,
      SYS_syscall,
      SYS_MAXSYSCALL,
      sysent,
d106 1
a106 1
      syscallnames,
d108 1
a108 1
      NULL,
d110 5
a114 5
      sizeof(AuxInfo) * ELF_AUX_ENTRIES,
      elf_copyargs,
      setregs,
      sigcode,
      esigcode,
d245 2
a246 2
         * If the user specified an address, then we load there.
         */
d273 1
a273 1
         */
d287 2
a288 2
         * Check if we need to extend the size of the segment
         */
d319 2
a320 2
         * See if we got all of it
         */
d352 4
a355 4
         * 1. open file
         * 2. read filehdr
         * 3. map text, data, and bss out of it using VM_*
         */
d375 2
a376 2
         * Load all the necessary sections
         */
d442 4
a445 4
         * check if vnode is in open for writing, because we want to
         * demand-page out of it.  if it is, don't do it, for various
         * reasons
         */
d454 3
a456 3
         * Allocate space to hold all the program headers, and read them
         * from the file
         */
d475 1
a475 1
				      (caddr_t) interp, pp->p_filesz)) != 0)
d508 2
a509 2
         * Load all the necessary sections
         */
d574 3
a576 3
         * Check if we found a dynamically linked binary and arrange to load
         * it's interpreter
         */
@


1.6
log
@Moved contents of elf_abi.h into exec_elf.h. Modified dependant files to
reflect this.
@
text
@d41 9
d90 29
d200 1
a200 1
	if (bcmp(eh->e_ident, ELFMAG, SELFMAG) != 0)
d212 3
d241 1
a241 1
	u_long uaddr, msize, rm, rf;
d268 1
d270 15
a284 1
	NEW_VMCMD(vcset, vmcmd_map_readvn, *size, *addr, vp, offset, *prot);
d350 1
a350 1
	bp = path;
d388 1
a388 1
				*entry = addr + eh.e_entry;
a421 1
 * XXX no demand paging (yet?)
d482 7
d563 1
d571 1
d613 1
@


1.5
log
@Rename the COMPAT_SVR4_MAP_PAGE_ZERO option to ELF_MAP_PAGE_ZERO as the
change affected all ELF formats
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.3 1996/03/03 17:19:37 niklas Exp $	*/
d162 1
a162 1
	if (bcmp(eh->e_ident, Elf32_e_ident, Elf32_e_siz) != 0)
d168 2
a169 2
	case Elf32_em_386:
	case Elf32_em_486:
d172 1
a172 1
	case Elf32_em_sparc:
d220 3
a222 3
	*prot |= (ph->p_flags & Elf32_pf_r) ? VM_PROT_READ : 0;
	*prot |= (ph->p_flags & Elf32_pf_w) ? VM_PROT_WRITE : 0;
	*prot |= (ph->p_flags & Elf32_pf_x) ? VM_PROT_EXECUTE : 0;
d308 1
a308 1
	if ((error = elf_check_header(&eh, Elf32_et_dyn)) != 0)
d326 1
a326 1
		case Elf32_pt_load:
d338 3
a340 3
		case Elf32_pt_dynamic:
		case Elf32_pt_phdr:
		case Elf32_pt_note:
d383 1
a383 1
	if (elf_check_header(eh, Elf32_et_exec))
d416 1
a416 1
		if (pp->p_type == Elf32_pt_interp) {
d455 1
a455 1
		case Elf32_pt_load:
d477 1
a477 1
		case Elf32_pt_shlib:
d481 1
a481 1
		case Elf32_pt_interp:
d483 2
a484 2
		case Elf32_pt_dynamic:
		case Elf32_pt_note:
d487 1
a487 1
		case Elf32_pt_phdr:
@


1.4
log
@Support mapping of page zero read-only if COMPAT_SVR4_MAP_PAGE_ZERO
is used.  Dell SVR4 behaved this way, and some binaries rely on such icky
behaviour.
@
text
@d534 1
a534 1
#ifdef COMPAT_SVR4_MAP_PAGE_ZERO
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d533 6
@


1.2
log
@from netbsd:
Don't rely on the protection bits of segments anymore to decide whether
it's text or data; use the entry point instead (this solves some trouble
with ELF executables with strange permissions)
Incorporate some fixes from r_friedl@@informatik.uni-kl.de sent to
netbsd-bugs a while ago
@
text
@d1 2
a2 1
/*	$NetBSD: exec_elf.c,v 1.4 1996/01/16 23:07:18 fvdl Exp $	*/
d59 2
a60 1
int (*elf_probe_funcs[])() = {
d69 4
d500 8
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: exec_elf.c,v 1.3 1995/09/16 00:28:08 thorpej Exp $	*/
a66 2
static int elf_set_segment __P((struct exec_package *, u_long, u_long,
	int));
a84 2
	char **cpp = stack;
	char *dp, *sp;
d86 1
a86 4
	void *nullp = NULL;
	int argc = arginfo->ps_nargvstr;
	int envc = arginfo->ps_nenvstr;
	AuxInfo *a;
d89 2
a90 25
	if (copyout(&argc, cpp++, sizeof(argc)))
		return NULL;

	dp = (char *) (cpp + argc + envc + 2 + pack->ep_emul->e_arglen);
	sp = argp;

	/* XXX don't copy them out, remap them! */
	arginfo->ps_argvstr = cpp; /* remember location of argv for later */

	for (; --argc >= 0; sp += len, dp += len)
		if (copyout(&dp, cpp++, sizeof(dp)) ||
		    copyoutstr(sp, dp, ARG_MAX, &len))
			return NULL;

	if (copyout(&nullp, cpp++, sizeof(nullp)))
		return NULL;

	arginfo->ps_envstr = cpp; /* remember location of envp for later */

	for (; --envc >= 0; sp += len, dp += len)
		if (copyout(&dp, cpp++, sizeof(dp)) ||
		    copyoutstr(sp, dp, ARG_MAX, &len))
			return NULL;

	if (copyout(&nullp, cpp++, sizeof(nullp)))
a96 1
	a = (AuxInfo *) cpp;
d98 1
d133 4
d138 1
a138 1
	return a;
a236 42
 * elf_set_segment():
 *
 * Decide if the segment is text or data, depending on the protection
 * and set it appropriately
 */
static int
elf_set_segment(epp, vaddr, size, prot)
	struct exec_package *epp;
	u_long vaddr;
	u_long size;
	int prot;
{
	/*
         * Kludge: Unfortunately the current implementation of
         * exec package assumes a single text and data segment.
         * In Elf we can have more, but here we limit ourselves
         * to two and hope :-(
         * We also assume that the text is r-x, and data is rwx or rw-.
         */
	switch (prot) {
	case (VM_PROT_READ | VM_PROT_EXECUTE):
		if (epp->ep_tsize != ELF32_NO_ADDR)
			return ENOEXEC;
		epp->ep_taddr = vaddr;
		epp->ep_tsize = size;
		break;

	case (VM_PROT_READ | VM_PROT_WRITE):
	case (VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE):
		if (epp->ep_dsize != ELF32_NO_ADDR)
			return ENOEXEC;
		epp->ep_daddr = vaddr;
		epp->ep_dsize = size;
		break;

	default:
		return ENOEXEC;
	}
	return 0;
}

/*
d260 1
a260 1
		return error;
d323 3
a325 2
			/* Assume that the text segment is r-x only */
			if ((prot & PROT_WRITE) == 0) {
d369 2
a370 1
	int error, i, n;
d442 1
a442 1
	for (i = 0; i < eh->e_phnum; i++) {
d450 6
d458 11
a468 3
			if ((error = elf_set_segment(epp, addr, size,
						      prot)) != 0)
				goto bad;
a477 1
		case Elf32_pt_phdr:
d481 5
a508 6
		/* Arrange to load the program headers. */
		pos = ELF_ALIGN(pos + NBPG, NBPG);
		ap->arg_phaddr = pos;
		NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_readvn, phsize,
			  pos, epp->ep_vp, eh->e_phoff,
			  VM_PROT_READ | VM_PROT_WRITE | VM_PROT_EXECUTE);
d510 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

