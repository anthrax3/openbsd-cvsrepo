head	1.91;
access;
symbols
	OPENBSD_6_1:1.87.0.6
	OPENBSD_6_1_BASE:1.87
	OPENBSD_6_0:1.87.0.2
	OPENBSD_6_0_BASE:1.87
	OPENBSD_5_9:1.86.0.2
	OPENBSD_5_9_BASE:1.86
	OPENBSD_5_8:1.85.0.4
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.84.0.2
	OPENBSD_5_7_BASE:1.84
	OPENBSD_5_6:1.83.0.4
	OPENBSD_5_6_BASE:1.83
	OPENBSD_5_5:1.81.0.4
	OPENBSD_5_5_BASE:1.81
	OPENBSD_5_4:1.78.0.2
	OPENBSD_5_4_BASE:1.78
	OPENBSD_5_3:1.76.0.8
	OPENBSD_5_3_BASE:1.76
	OPENBSD_5_2:1.76.0.6
	OPENBSD_5_2_BASE:1.76
	OPENBSD_5_1_BASE:1.76
	OPENBSD_5_1:1.76.0.4
	OPENBSD_5_0:1.76.0.2
	OPENBSD_5_0_BASE:1.76
	OPENBSD_4_9:1.75.0.4
	OPENBSD_4_9_BASE:1.75
	OPENBSD_4_8:1.75.0.2
	OPENBSD_4_8_BASE:1.75
	OPENBSD_4_7:1.74.0.6
	OPENBSD_4_7_BASE:1.74
	OPENBSD_4_6:1.74.0.8
	OPENBSD_4_6_BASE:1.74
	OPENBSD_4_5:1.74.0.4
	OPENBSD_4_5_BASE:1.74
	OPENBSD_4_4:1.74.0.2
	OPENBSD_4_4_BASE:1.74
	OPENBSD_4_3:1.73.0.2
	OPENBSD_4_3_BASE:1.73
	OPENBSD_4_2:1.70.0.2
	OPENBSD_4_2_BASE:1.70
	OPENBSD_4_1:1.69.0.2
	OPENBSD_4_1_BASE:1.69
	OPENBSD_4_0:1.67.0.2
	OPENBSD_4_0_BASE:1.67
	OPENBSD_3_9:1.64.0.2
	OPENBSD_3_9_BASE:1.64
	OPENBSD_3_8:1.61.0.2
	OPENBSD_3_8_BASE:1.61
	OPENBSD_3_7:1.60.0.4
	OPENBSD_3_7_BASE:1.60
	OPENBSD_3_6:1.60.0.2
	OPENBSD_3_6_BASE:1.60
	SMP_SYNC_A:1.58
	SMP_SYNC_B:1.58
	OPENBSD_3_5:1.58.0.2
	OPENBSD_3_5_BASE:1.58
	OPENBSD_3_4:1.56.0.2
	OPENBSD_3_4_BASE:1.56
	UBC_SYNC_A:1.49
	OPENBSD_3_3:1.46.0.2
	OPENBSD_3_3_BASE:1.46
	OPENBSD_3_2:1.44.0.2
	OPENBSD_3_2_BASE:1.44
	OPENBSD_3_1:1.40.0.2
	OPENBSD_3_1_BASE:1.40
	UBC_SYNC_B:1.45
	UBC:1.37.0.2
	UBC_BASE:1.37
	OPENBSD_3_0:1.35.0.2
	OPENBSD_3_0_BASE:1.35
	OPENBSD_2_9_BASE:1.31
	OPENBSD_2_9:1.31.0.2
	OPENBSD_2_8:1.30.0.2
	OPENBSD_2_8_BASE:1.30
	OPENBSD_2_7:1.29.0.2
	OPENBSD_2_7_BASE:1.29
	SMP:1.26.0.2
	SMP_BASE:1.26
	kame_19991208:1.26
	OPENBSD_2_6:1.25.0.4
	OPENBSD_2_6_BASE:1.25
	OPENBSD_2_5:1.25.0.2
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.23.0.4
	OPENBSD_2_4_BASE:1.23
	OPENBSD_2_3:1.23.0.2
	OPENBSD_2_3_BASE:1.23
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.91
date	2017.04.30.16.45.46;	author mpi;	state Exp;
branches;
next	1.90;
commitid	2Gtqjzrin9LL2yHk;

1.90
date	2017.04.30.13.04.49;	author mpi;	state Exp;
branches;
next	1.89;
commitid	xDPbcPU6tYP39nZG;

1.89
date	2017.04.27.11.48.08;	author mpi;	state Exp;
branches;
next	1.88;
commitid	1xNfz7QOeyAJY0UH;

1.88
date	2017.04.20.14.13.00;	author visa;	state Exp;
branches;
next	1.87;
commitid	GnoPKa34InShCqYl;

1.87
date	2016.05.17.23.43.47;	author bluhm;	state Exp;
branches;
next	1.86;
commitid	FQUHD8bvWBEOY9mu;

1.86
date	2015.09.29.03.19.24;	author guenther;	state Exp;
branches;
next	1.85;
commitid	yKdJafwKaYfM4gkS;

1.85
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.84;
commitid	p4LJxGKbi0BU2cG6;

1.84
date	2015.01.13.10.07.58;	author mpf;	state Exp;
branches;
next	1.83;
commitid	IZ2rtJyRuzWF0F1j;

1.83
date	2014.07.13.23.49.40;	author uebayasi;	state Exp;
branches;
next	1.82;
commitid	z6zKhO7L2b0jL3QY;

1.82
date	2014.07.11.14.36.44;	author uebayasi;	state Exp;
branches;
next	1.81;
commitid	V6bwQMCHbD31pEWD;

1.81
date	2013.12.12.21.00.09;	author guenther;	state Exp;
branches;
next	1.80;

1.80
date	2013.11.25.00.33.21;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2013.08.07.22.06.48;	author bluhm;	state Exp;
branches;
next	1.78;

1.78
date	2013.07.03.15.17.24;	author sf;	state Exp;
branches;
next	1.77;

1.77
date	2013.03.28.16.55.25;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2011.04.03.16.46.19;	author drahn;	state Exp;
branches;
next	1.75;

1.75
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.74;

1.74
date	2008.06.27.17.23.24;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2007.12.30.11.54.55;	author bluhm;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.08.04.15.10;	author ray;	state Exp;
branches;
next	1.71;

1.71
date	2007.09.01.11.54.49;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2007.04.26.20.28.25;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2006.12.11.05.08.18;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2006.11.17.09.21.52;	author jmc;	state Exp;
branches;
next	1.67;

1.67
date	2006.07.06.18.14.49;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2006.06.01.23.17.23;	author jason;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.29.20.33.15;	author jason;	state Exp;
branches;
next	1.64;

1.64
date	2005.12.27.18.35.34;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2005.12.09.09.09.52;	author jsg;	state Exp;
branches;
next	1.62;

1.62
date	2005.09.27.12.26.13;	author grunk;	state Exp;
branches;
next	1.61;

1.61
date	2005.04.14.21.58.50;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2004.07.20.20.19.52;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.58;

1.58
date	2004.01.03.14.08.53;	author espie;	state Exp;
branches;
next	1.57;

1.57
date	2003.12.21.15.30.21;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.28.01.52.17;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2003.05.29.14.41.53;	author ho;	state Exp;
branches;
next	1.53;

1.53
date	2003.05.27.21.03.49;	author henning;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.22.20.42.43;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2003.05.21.16.17.37;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2003.05.20.20.47.12;	author jason;	state Exp;
branches;
next	1.49;

1.49
date	2003.05.13.02.09.46;	author jason;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.10.21.44.53;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2003.05.06.12.22.08;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2003.01.13.18.32.03;	author weingart;	state Exp;
branches;
next	1.45;

1.45
date	2002.10.14.20.15.23;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.20.22.16.36;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.18.18.33.42;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.18.18.24.21;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.15.23.17.53;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.01.23.15.46.48;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.12.02.02.03.13;	author deraadt;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2001.11.15.07.57.29;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	2001.09.05.22.32.39;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.05.19.22.23;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.27.04.49.46;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.22.14.14.09;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2001.02.22.19.33.22;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.25.18.45.19;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	2000.03.13.04.05.15;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2000.03.02.10.50.29;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2000.02.22.19.28.04;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.12.02.00.23.35;	author deraadt;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	99.01.11.05.12.23;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	99.01.10.01.45.31;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	98.04.04.18.36.32;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.02.05.16.49.29;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.01.24.17.54.07;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	98.01.21.21.59.38;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.12.29.14.31.16;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.12.28.23.39.28;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	97.11.04.20.43.26;	author chuck;	state Exp;
branches;
next	1.16;

1.16
date	97.10.01.02.22.59;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	96.12.06.08.08.17;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	96.11.29.04.53.39;	author kstailey;	state Exp;
branches;
next	1.13;

1.13
date	96.11.24.04.29.48;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.11.24.00.42.04;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	96.10.19.10.02.49;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.07.28.01.05.48;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.07.23.23.54.19;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.07.19.23.13.39;	author dm;	state Exp;
branches;
next	1.7;

1.7
date	96.07.02.06.51.59;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.06.26.20.39.21;	author dm;	state Exp;
branches;
next	1.5;

1.5
date	96.05.02.13.12.20;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.27.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.19.16.09.03;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.13.38.52;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches;
next	;

1.26.2.1
date	2000.03.02.07.04.40;	author niklas;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2000.03.24.09.09.25;	author niklas;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2001.05.14.22.32.43;	author niklas;	state Exp;
branches;
next	1.26.2.4;

1.26.2.4
date	2001.07.04.10.48.32;	author niklas;	state Exp;
branches;
next	1.26.2.5;

1.26.2.5
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.26.2.6;

1.26.2.6
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.26.2.7;

1.26.2.7
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.26.2.8;

1.26.2.8
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.26.2.9;

1.26.2.9
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.26.2.10;

1.26.2.10
date	2003.04.04.14.59.13;	author niklas;	state Exp;
branches;
next	1.26.2.11;

1.26.2.11
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.26.2.12;

1.26.2.12
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.26.2.13;

1.26.2.13
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.26.2.14;

1.26.2.14
date	2003.05.18.18.16.45;	author niklas;	state Exp;
branches;
next	1.26.2.15;

1.26.2.15
date	2003.05.25.19.26.49;	author ho;	state Exp;
branches;
next	1.26.2.16;

1.26.2.16
date	2003.05.29.14.35.58;	author ho;	state Exp;
branches;
next	1.26.2.17;

1.26.2.17
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.26.2.18;

1.26.2.18
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	1.26.2.19;

1.26.2.19
date	2004.06.05.23.18.25;	author tedu;	state Exp;
branches;
next	;

1.37.2.1
date	2002.01.31.22.55.41;	author niklas;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.37.2.3;

1.37.2.3
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.37.2.4;

1.37.2.4
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.91
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: subr_prf.c,v 1.90 2017/04/30 13:04:49 mpi Exp $	*/
/*	$NetBSD: subr_prf.c,v 1.45 1997/10/24 18:14:25 chuck Exp $	*/

/*-
 * Copyright (c) 1986, 1988, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)subr_prf.c	8.3 (Berkeley) 1/21/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/reboot.h>
#include <sys/msgbuf.h>
#include <sys/proc.h>
#include <sys/ioctl.h>
#include <sys/vnode.h>
#include <sys/file.h>
#include <sys/tty.h>
#include <sys/tprintf.h>
#include <sys/syslog.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/mutex.h>

#include <dev/cons.h>

/*
 * note that stdarg.h and the ansi style va_start macro is used for both
 * ansi and traditional c compilers.
 */
#include <sys/stdarg.h>

#ifdef DDB
#include <ddb/db_output.h>	/* db_printf, db_putchar prototypes */
#include <ddb/db_var.h>		/* db_log, db_radix */
#endif


/*
 * defines
 */

/* flags for kprintf */
#define TOCONS		0x01	/* to the console */
#define TOTTY		0x02	/* to the process' tty */
#define TOLOG		0x04	/* to the kernel message buffer */
#define TOBUFONLY	0x08	/* to the buffer (only) [for snprintf] */
#define TODDB		0x10	/* to ddb console */
#define TOCOUNT		0x20	/* act like [v]snprintf */

/* max size buffer kprintf needs to print quad_t [size in base 8 + \0] */
#define KPRINTF_BUFSIZE		(sizeof(quad_t) * NBBY / 3 + 2)


/*
 * local prototypes
 */

int	 kprintf(const char *, int, void *, char *, va_list);
void	 kputchar(int, int, struct tty *);

struct mutex kprintf_mutex =
    MUTEX_INITIALIZER_FLAGS(IPL_HIGH, "kprintf", MTX_NOWITNESS);

/*
 * globals
 */

extern	int log_open;	/* subr_log: is /dev/klog open? */
const	char *panicstr; /* arg to first call to panic (used as a flag
			   to indicate that panic has already been called). */
#ifdef DDB
/*
 * Enter ddb on panic.
 */
int	db_panic = 1;

/*
 * db_console controls if we can be able to enter ddb by a special key
 * combination (machine dependent).
 * If DDB_SAFE_CONSOLE is defined in the kernel configuration it allows
 * to break into console during boot. It's _really_ useful when debugging
 * some things in the kernel that can cause init(8) to crash.
 */
#ifdef DDB_SAFE_CONSOLE
int	db_console = 1;
#else
int	db_console = 0;
#endif

/*
 * flag to indicate if we are currently in ddb (on some processor)
 */
int db_is_active;
#endif

/*
 * panic on spl assertion failure?
 */
int splassert_ctl = 1;

/*
 * v_putc: routine to putc on virtual console
 *
 * the v_putc pointer can be used to redirect the console cnputc elsewhere
 * [e.g. to a "virtual console"].
 */

void (*v_putc)(int) = cnputc;	/* start with cnputc (normal cons) */


/*
 * functions
 */

/*
 *	Partial support (the failure case) of the assertion facility
 *	commonly found in userland.
 */
void
__assert(const char *t, const char *f, int l, const char *e)
{

	panic(__KASSERTSTR, t, e, f, l);
}

/*
 * tablefull: warn that a system table is full
 */

void
tablefull(const char *tab)
{
	log(LOG_ERR, "%s: table is full\n", tab);
}

/*
 * panic: handle an unresolvable fatal error
 *
 * prints "panic: <message>" and reboots.   if called twice (i.e. recursive
 * call) we avoid trying to sync the disk and just reboot (to avoid
 * recursive panics).
 */

void
panic(const char *fmt, ...)
{
	static char panicbuf[512];
	int bootopt;
	va_list ap;

	/* do not trigger assertions, we know that we are inconsistent */
	splassert_ctl = 0;

	bootopt = RB_AUTOBOOT | RB_DUMP;
	va_start(ap, fmt);
	if (panicstr)
		bootopt |= RB_NOSYNC;
	else {
		vsnprintf(panicbuf, sizeof panicbuf, fmt, ap);
		panicstr = panicbuf;
	}
	va_end(ap);

	printf("panic: ");
	va_start(ap, fmt);
	vprintf(fmt, ap);
	printf("\n");
	va_end(ap);

#ifdef DDB
	if (db_panic)
		db_enter();
	else
		db_stack_dump();
#endif
	reboot(bootopt);
	/* NOTREACHED */
}

/*
 * We print only the function name. The file name is usually very long and
 * would eat tons of space in the kernel.
 */
void
splassert_fail(int wantipl, int haveipl, const char *func)
{

	printf("splassert: %s: want %d have %d\n", func, wantipl, haveipl);
	switch (splassert_ctl) {
	case 1:
		break;
	case 2:
#ifdef DDB
		db_stack_dump();
#endif
		break;
	case 3:
#ifdef DDB
		db_stack_dump();
		db_enter();
#endif
		break;
	default:
		panic("spl assertion failure in %s", func);
	}
}

/*
 * kernel logging functions: log, logpri, addlog
 */

/*
 * log: write to the log buffer
 *
 * => will not sleep [so safe to call from interrupt]
 * => will log to console if /dev/klog isn't open
 */

void
log(int level, const char *fmt, ...)
{
	int s;
	va_list ap;

	s = splhigh();
	logpri(level);		/* log the level first */
	va_start(ap, fmt);
	kprintf(fmt, TOLOG, NULL, NULL, ap);
	va_end(ap);
	splx(s);
	if (!log_open) {
		va_start(ap, fmt);
		kprintf(fmt, TOCONS, NULL, NULL, ap);
		va_end(ap);
	}
	logwakeup();		/* wake up anyone waiting for log msgs */
}

/*
 * logpri: log the priority level to the klog
 */

void
logpri(int level)
{
	char *p;
	char snbuf[KPRINTF_BUFSIZE];

	kputchar('<', TOLOG, NULL);
	snprintf(snbuf, sizeof snbuf, "%d", level);
	for (p = snbuf ; *p ; p++)
		kputchar(*p, TOLOG, NULL);
	kputchar('>', TOLOG, NULL);
}

/*
 * addlog: add info to previous log message
 */

int
addlog(const char *fmt, ...)
{
	int s;
	va_list ap;

	s = splhigh();
	va_start(ap, fmt);
	kprintf(fmt, TOLOG, NULL, NULL, ap);
	va_end(ap);
	splx(s);
	if (!log_open) {
		va_start(ap, fmt);
		kprintf(fmt, TOCONS, NULL, NULL, ap);
		va_end(ap);
	}
	logwakeup();
	return(0);
}


/*
 * kputchar: print a single character on console or user terminal.
 *
 * => if console, then the last MSGBUFS chars are saved in msgbuf
 *	for inspection later (e.g. dmesg/syslog)
 */
void
kputchar(int c, int flags, struct tty *tp)
{
	extern int msgbufmapped;
	int ddb_active = 0;

#ifdef DDB
	ddb_active = db_is_active;
#endif

	if (panicstr)
		constty = NULL;

	if ((flags & TOCONS) && tp == NULL && constty && !ddb_active) {
		tp = constty;
		flags |= TOTTY;
	}
	if ((flags & TOTTY) && tp && tputchar(c, tp) < 0 &&
	    (flags & TOCONS) && tp == constty)
		constty = NULL;
	if ((flags & TOLOG) &&
	    c != '\0' && c != '\r' && c != 0177 && msgbufmapped)
		msgbuf_putchar(msgbufp, c);
	if ((flags & TOCONS) && (constty == NULL || ddb_active) && c != '\0')
		(*v_putc)(c);
#ifdef DDB
	if (flags & TODDB)
		db_putchar(c);
#endif
}


/*
 * uprintf: print to the controlling tty of the current process
 *
 * => we may block if the tty queue is full
 * => no message is printed if the queue doesn't clear in a reasonable
 *	time
 */

void
uprintf(const char *fmt, ...)
{
	struct process *pr = curproc->p_p;
	va_list ap;

	if (pr->ps_flags & PS_CONTROLT && pr->ps_session->s_ttyvp) {
		va_start(ap, fmt);
		kprintf(fmt, TOTTY, pr->ps_session->s_ttyp, NULL, ap);
		va_end(ap);
	}
}

#if defined(NFSSERVER) || defined(NFSCLIENT)

/*
 * tprintf functions: used to send messages to a specific process
 *
 * usage:
 *   get a tpr_t handle on a process "p" by using "tprintf_open(p)"
 *   use the handle when calling "tprintf"
 *   when done, do a "tprintf_close" to drop the handle
 */

/*
 * tprintf_open: get a tprintf handle on a process "p"
 * XXX change s/proc/process
 *
 * => returns NULL if process can't be printed to
 */

tpr_t
tprintf_open(struct proc *p)
{
	struct process *pr = p->p_p;

	if (pr->ps_flags & PS_CONTROLT && pr->ps_session->s_ttyvp) {
		SESSHOLD(pr->ps_session);
		return ((tpr_t)pr->ps_session);
	}
	return ((tpr_t) NULL);
}

/*
 * tprintf_close: dispose of a tprintf handle obtained with tprintf_open
 */

void
tprintf_close(tpr_t sess)
{

	if (sess)
		SESSRELE((struct session *) sess);
}

/*
 * tprintf: given tprintf handle to a process [obtained with tprintf_open],
 * send a message to the controlling tty for that process.
 *
 * => also sends message to /dev/klog
 */
void
tprintf(tpr_t tpr, const char *fmt, ...)
{
	struct session *sess = (struct session *)tpr;
	struct tty *tp = NULL;
	int flags = TOLOG;
	va_list ap;

	logpri(LOG_INFO);
	if (sess && sess->s_ttyvp && ttycheckoutq(sess->s_ttyp, 0)) {
		flags |= TOTTY;
		tp = sess->s_ttyp;
	}
	va_start(ap, fmt);
	kprintf(fmt, flags, tp, NULL, ap);
	va_end(ap);
	logwakeup();
}

#endif	/* NFSSERVER || NFSCLIENT */


/*
 * ttyprintf: send a message to a specific tty
 *
 * => should be used only by tty driver or anything that knows the
 *	underlying tty will not be revoked(2)'d away.  [otherwise,
 *	use tprintf]
 */
void
ttyprintf(struct tty *tp, const char *fmt, ...)
{
	va_list ap;

	va_start(ap, fmt);
	kprintf(fmt, TOTTY, tp, NULL, ap);
	va_end(ap);
}

#ifdef DDB

/*
 * db_printf: printf for DDB (via db_putchar)
 */

int
db_printf(const char *fmt, ...)
{
	va_list ap;
	int retval;

	va_start(ap, fmt);
	retval = db_vprintf(fmt, ap);
	va_end(ap);
	return(retval);
}

int
db_vprintf(const char *fmt, va_list ap)
{
	int flags;

	flags = TODDB;
	if (db_log)
		flags |= TOLOG;
	return (kprintf(fmt, flags, NULL, NULL, ap));
}
#endif /* DDB */


/*
 * normal kernel printf functions: printf, vprintf, snprintf
 */

/*
 * printf: print a message to the console and the log
 */
int
printf(const char *fmt, ...)
{
	va_list ap;
	int retval;

	mtx_enter(&kprintf_mutex);

	va_start(ap, fmt);
	retval = kprintf(fmt, TOCONS | TOLOG, NULL, NULL, ap);
	va_end(ap);
	if (!panicstr)
		logwakeup();

	mtx_leave(&kprintf_mutex);

	return(retval);
}

/*
 * vprintf: print a message to the console and the log [already have a
 *	va_list]
 */

int
vprintf(const char *fmt, va_list ap)
{
	int retval;

	mtx_enter(&kprintf_mutex);

	retval = kprintf(fmt, TOCONS | TOLOG, NULL, NULL, ap);
	if (!panicstr)
		logwakeup();

	mtx_leave(&kprintf_mutex);

	return (retval);
}

/*
 * snprintf: print a message to a buffer
 */
int
snprintf(char *buf, size_t size, const char *fmt, ...)
{
	int retval;
	va_list ap;
	char *p;

	p = buf + size - 1;
	if (size < 1)
		p = buf;
	va_start(ap, fmt);
	retval = kprintf(fmt, TOBUFONLY | TOCOUNT, &p, buf, ap);
	va_end(ap);
	if (size > 0)
		*(p) = 0;	/* null terminate */
	return(retval);
}

/*
 * vsnprintf: print a message to a buffer [already have va_alist]
 */
int
vsnprintf(char *buf, size_t size, const char *fmt, va_list ap)
{
	int retval;
	char *p;

	p = buf + size - 1;
	if (size < 1)
		p = buf;
	retval = kprintf(fmt, TOBUFONLY | TOCOUNT, &p, buf, ap);
	if (size > 0)
		*(p) = 0;	/* null terminate */
	return(retval);
}

/*
 * kprintf: scaled down version of printf(3).
 *
 * this version based on vfprintf() from libc which was derived from
 * software contributed to Berkeley by Chris Torek.
 *
 * The additional format %b is supported to decode error registers.
 * Its usage is:
 *
 *	printf("reg=%b\n", regval, "<base><arg>*");
 *
 * where <base> is the output base expressed as a control character, e.g.
 * \10 gives octal; \20 gives hex.  Each arg is a sequence of characters,
 * the first of which gives the bit number to be inspected (origin 1), and
 * the next characters (up to a control character, i.e. a character <= 32),
 * give the name of the register.  Thus:
 *
 *	kprintf("reg=%b\n", 3, "\10\2BITTWO\1BITONE\n");
 *
 * would produce output:
 *
 *	reg=3<BITTWO,BITONE>
 *
 * To support larger integers (> 32 bits), %b formatting will also accept
 * control characters in the region 0x80 - 0xff.  0x80 refers to bit 0,
 * 0x81 refers to bit 1, and so on.  The equivalent string to the above is:
 *
 *	kprintf("reg=%b\n", 3, "\10\201BITTWO\200BITONE\n");
 *
 * and would produce the same output.
 *
 * Like the rest of printf, %b can be prefixed to handle various size
 * modifiers, eg. %b is for "int", %lb is for "long", and %llb supports
 * "long long".
 *
 * This code is large and complicated...
 */

/*
 * macros for converting digits to letters and vice versa
 */
#define	to_digit(c)	((c) - '0')
#define is_digit(c)	((unsigned)to_digit(c) <= 9)
#define	to_char(n)	((n) + '0')

/*
 * flags used during conversion.
 */
#define	ALT		0x001		/* alternate form */
#define	HEXPREFIX	0x002		/* add 0x or 0X prefix */
#define	LADJUST		0x004		/* left adjustment */
#define	LONGDBL		0x008		/* long double; unimplemented */
#define	LONGINT		0x010		/* long integer */
#define	QUADINT		0x020		/* quad integer */
#define	SHORTINT	0x040		/* short integer */
#define	ZEROPAD		0x080		/* zero (as opposed to blank) pad */
#define FPT		0x100		/* Floating point number */
#define SIZEINT		0x200		/* (signed) size_t */

	/*
	 * To extend shorts properly, we need both signed and unsigned
	 * argument extraction methods.
	 */
#define	SARG() \
	(flags&QUADINT ? va_arg(ap, quad_t) : \
	    flags&LONGINT ? va_arg(ap, long) : \
	    flags&SIZEINT ? va_arg(ap, ssize_t) : \
	    flags&SHORTINT ? (long)(short)va_arg(ap, int) : \
	    (long)va_arg(ap, int))
#define	UARG() \
	(flags&QUADINT ? va_arg(ap, u_quad_t) : \
	    flags&LONGINT ? va_arg(ap, u_long) : \
	    flags&SIZEINT ? va_arg(ap, size_t) : \
	    flags&SHORTINT ? (u_long)(u_short)va_arg(ap, int) : \
	    (u_long)va_arg(ap, u_int))

#define KPRINTF_PUTCHAR(C) do {					\
	int chr = (C);							\
	ret += 1;							\
	if (oflags & TOBUFONLY) {					\
		if ((vp != NULL) && (sbuf == tailp)) {			\
			if (!(oflags & TOCOUNT))				\
				goto overflow;				\
		} else							\
			*sbuf++ = chr;					\
	} else {							\
		kputchar(chr, oflags, (struct tty *)vp);			\
	}								\
} while(0)

int
kprintf(const char *fmt0, int oflags, void *vp, char *sbuf, va_list ap)
{
	char *fmt;		/* format string */
	int ch;			/* character from fmt */
	int n;			/* handy integer (short term usage) */
	char *cp = NULL;	/* handy char pointer (short term usage) */
	int flags;		/* flags as above */
	int ret;		/* return value accumulator */
	int width;		/* width from format (%8d), or 0 */
	int prec;		/* precision from format (%.3d), or -1 */
	char sign;		/* sign prefix (' ', '+', '-', or \0) */

	u_quad_t _uquad;	/* integer arguments %[diouxX] */
	enum { OCT, DEC, HEX } base;/* base for [diouxX] conversion */
	int dprec;		/* a copy of prec if [diouxX], 0 otherwise */
	int realsz;		/* field size expanded by dprec */
	int size = 0;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
	char buf[KPRINTF_BUFSIZE]; /* space for %c, %[diouxX] */
	char *tailp = NULL;	/* tail pointer for snprintf */

	if ((oflags & TOBUFONLY) && (vp != NULL))
		tailp = *(char **)vp;

	fmt = (char *)fmt0;
	ret = 0;

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
		while (*fmt != '%' && *fmt) {
			KPRINTF_PUTCHAR(*fmt++);
		}
		if (*fmt == 0)
			goto done;

		fmt++;		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';

rflag:		ch = *fmt++;
reswitch:	switch (ch) {
		/* XXX: non-standard '%b' format */
		case 'b': {
			char *b, *z;
			int tmp;
			_uquad = UARG();
			b = va_arg(ap, char *);
			if (*b == 8)
				snprintf(buf, sizeof buf, "%llo", _uquad);
			else if (*b == 10)
				snprintf(buf, sizeof buf, "%lld", _uquad);
			else if (*b == 16)
				snprintf(buf, sizeof buf, "%llx", _uquad);
			else
				break;
			b++;

			z = buf;
			while (*z) {
				KPRINTF_PUTCHAR(*z++);
			}

			if (_uquad) {
				tmp = 0;
				while ((n = *b++) != 0) {
					if (n & 0x80)
						n &= 0x7f;
					else if (n <= ' ')
						n = n - 1;
					if (_uquad & (1LL << n)) {
						KPRINTF_PUTCHAR(tmp ? ',':'<');
						while (*b > ' ' &&
						    (*b & 0x80) == 0) {
							KPRINTF_PUTCHAR(*b);
							b++;
						}
						tmp = 1;
					} else {
						while (*b > ' ' &&
						    (*b & 0x80) == 0)
							b++;
					}
				}
				if (tmp) {
					KPRINTF_PUTCHAR('>');
				}
			}
			continue;	/* no output */
		}

		case ' ':
			/*
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
				sign = ' ';
			goto rflag;
		case '#':
			flags |= ALT;
			goto rflag;
		case '*':
			/*
			 * ``A negative field width argument is taken as a
			 * - flag followed by a positive field width.''
			 *	-- ANSI X3J11
			 * They don't exclude field widths read from args.
			 */
			if ((width = va_arg(ap, int)) >= 0)
				goto rflag;
			width = -width;
			/* FALLTHROUGH */
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			if ((ch = *fmt++) == '*') {
				n = va_arg(ap, int);
				prec = n < 0 ? -1 : n;
				goto rflag;
			}
			n = 0;
			while (is_digit(ch)) {
				n = 10 * n + to_digit(ch);
				ch = *fmt++;
			}
			prec = n < 0 ? -1 : n;
			goto reswitch;
		case '0':
			/*
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit(ch);
				ch = *fmt++;
			} while (is_digit(ch));
			width = n;
			goto reswitch;
		case 'h':
			flags |= SHORTINT;
			goto rflag;
		case 'l':
			if (*fmt == 'l') {
				fmt++;
				flags |= QUADINT;
			} else {
				flags |= LONGINT;
			}
			goto rflag;
		case 'q':
			flags |= QUADINT;
			goto rflag;
		case 'z':
			flags |= SIZEINT;
			goto rflag;
		case 'c':
			*(cp = buf) = va_arg(ap, int);
			size = 1;
			sign = '\0';
			break;
		case 't':
			/* ptrdiff_t */
			/* FALLTHROUGH */
		case 'D':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			_uquad = SARG();
			if ((quad_t)_uquad < 0) {
				_uquad = -_uquad;
				sign = '-';
			}
			base = DEC;
			goto number;
		case 'n':
			/* %n is unsupported in the kernel; just skip it */
			if (flags & QUADINT)
				(void)va_arg(ap, quad_t *);
			else if (flags & LONGINT)
				(void)va_arg(ap, long *);
			else if (flags & SHORTINT)
				(void)va_arg(ap, short *);
			else if (flags & SIZEINT)
				(void)va_arg(ap, ssize_t *);
			else
				(void)va_arg(ap, int *);
			continue;	/* no output */
		case 'O':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			_uquad = UARG();
			base = OCT;
			goto nosign;
		case 'p':
			/*
			 * ``The argument shall be a pointer to void.  The
			 * value of the pointer is converted to a sequence
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			_uquad = (u_long)va_arg(ap, void *);
			base = HEX;
			xdigs = "0123456789abcdef";
			flags |= HEXPREFIX;
			ch = 'x';
			goto nosign;
		case 's':
			if ((cp = va_arg(ap, char *)) == NULL)
				cp = "(null)";
			if (prec >= 0) {
				/*
				 * can't use strlen; can only look for the
				 * NUL in the first `prec' characters, and
				 * strlen() will go further.
				 */
				char *p = memchr(cp, 0, prec);

				if (p != NULL) {
					size = p - cp;
					if (size > prec)
						size = prec;
				} else
					size = prec;
			} else
				size = strlen(cp);
			sign = '\0';
			break;
		case 'U':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			_uquad = UARG();
			base = DEC;
			goto nosign;
		case 'X':
			xdigs = "0123456789ABCDEF";
			goto hex;
		case 'x':
			xdigs = "0123456789abcdef";
hex:			_uquad = UARG();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0)
				flags |= HEXPREFIX;

			/* unsigned conversions */
nosign:			sign = '\0';
			/*
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
				flags &= ~ZEROPAD;

			/*
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 */
			cp = buf + KPRINTF_BUFSIZE;
			if (_uquad != 0 || prec != 0) {
				/*
				 * Unsigned mod is hard, and unsigned mod
				 * by a constant is easier than that by
				 * a variable; hence this switch.
				 */
				switch (base) {
				case OCT:
					do {
						*--cp = to_char(_uquad & 7);
						_uquad >>= 3;
					} while (_uquad);
					/* handle octal leading 0 */
					if (flags & ALT && *cp != '0')
						*--cp = '0';
					break;

				case DEC:
					/* many numbers are 1 digit */
					while (_uquad >= 10) {
						*--cp = to_char(_uquad % 10);
						_uquad /= 10;
					}
					*--cp = to_char(_uquad);
					break;

				case HEX:
					do {
						*--cp = xdigs[_uquad & 15];
						_uquad >>= 4;
					} while (_uquad);
					break;

				default:
					cp = "bug in kprintf: bad base";
					size = strlen(cp);
					goto skipsize;
				}
			}
			size = buf + KPRINTF_BUFSIZE - cp;
		skipsize:
			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
		}

		/*
		 * All reasonable formats wind up here.  At this point, `cp'
		 * points to a string which (if not flags&LADJUST) should be
		 * padded out to `width' places.  If flags&ZEROPAD, it should
		 * first be prefixed by any sign or other prefix; otherwise,
		 * it should be blank padded before the prefix is emitted.
		 * After any left-hand padding and prefixing, emit zeroes
		 * required by a decimal [diouxX] precision, then print the
		 * string proper, then emit zeroes required by any leftover
		 * floating precision; finally, if LADJUST, pad with blanks.
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
		if (sign)
			realsz++;
		else if (flags & HEXPREFIX)
			realsz+= 2;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0) {
			n = width - realsz;
			while (n-- > 0)
				KPRINTF_PUTCHAR(' ');
		}

		/* prefix */
		if (sign) {
			KPRINTF_PUTCHAR(sign);
		} else if (flags & HEXPREFIX) {
			KPRINTF_PUTCHAR('0');
			KPRINTF_PUTCHAR(ch);
		}

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD) {
			n = width - realsz;
			while (n-- > 0)
				KPRINTF_PUTCHAR('0');
		}

		/* leading zeroes from decimal precision */
		n = dprec - size;
		while (n-- > 0)
			KPRINTF_PUTCHAR('0');

		/* the string or number proper */
		while (size--)
			KPRINTF_PUTCHAR(*cp++);
		/* left-adjusting padding (always blank) */
		if (flags & LADJUST) {
			n = width - realsz;
			while (n-- > 0)
				KPRINTF_PUTCHAR(' ');
		}
	}

done:
	if ((oflags & TOBUFONLY) && (vp != NULL))
		*(char **)vp = sbuf;
overflow:
	return (ret);
	/* NOTREACHED */
}

#if __GNUC_PREREQ__(2,96)
/*
 * XXX - these functions shouldn't be in the kernel, but gcc 3.X feels like
 *       translating some printf calls to puts and since it doesn't seem
 *       possible to just turn off parts of those optimizations (some of
 *       them are really useful), we have to provide a dummy puts and putchar
 *	 that are wrappers around printf.
 */
int	puts(const char *);
int	putchar(int c);

int
puts(const char *str)
{
	printf("%s\n", str);

	return (0);
}

int
putchar(int c)
{
	printf("%c", c);

	return (c);
}


#endif
@


1.90
log
@Unifdef KGDB.

It doesn't compile und hasn't been working during the last decade.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.89 2017/04/27 11:48:08 mpi Exp $	*/
d204 1
a204 1
		Debugger();
d232 1
a232 1
		Debugger();
@


1.89
log
@Unifdef KADB.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.88 2017/04/20 14:13:00 visa Exp $	*/
a63 3
#ifdef KGDB
#include <sys/kgdb.h>
#endif
a201 3
#ifdef KGDB
	kgdb_panic();
#endif
@


1.88
log
@Tweak lock inits to make the system runnable with witness(4)
on amd64 and i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.87 2016/05/17 23:43:47 bluhm Exp $	*/
a206 4
#endif
#ifdef KADB
	if (boothowto & RB_KDB)
		kdbpanic();
@


1.87
log
@Allow sendsyslog(2) with LOG_CONS even when /dev/console has not
been opened during init(8).  Only log with cnwrite() if cn_devvp
exists, otherwise use cnputc() as fallback.  While there move extern
declarations to dev/cons.h.
input and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.86 2015/09/29 03:19:24 guenther Exp $	*/
d96 2
a97 1
struct mutex kprintf_mutex = MUTEX_INITIALIZER(IPL_HIGH);
@


1.86
log
@Delete the final, inscrutable NOSTRICT and VARARGS lint comments

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.85 2015/03/14 03:38:50 jsg Exp $	*/
a101 1
extern struct	tty *constty;	/* pointer to console "window" tty */
@


1.85
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.84 2015/01/13 10:07:58 mpf Exp $	*/
a896 1
			/* NOSTRICT */
@


1.84
log
@Add dmesg -s support, to view the output of rc(8) system startup messages.
Help and feedback by Theo and Miod.
OK deraadt@@, manpage-ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.83 2014/07/13 23:49:40 uebayasi Exp $	*/
a41 1
#include <sys/buf.h>
@


1.83
log
@KASSERTMSG(9): New kernel assertion with message

KASSERT() is annoying as it only prints the expression as a string.  If you
(developers) want to know a little more information, you have to do:

	#ifdef DIAGNOSTIC
		if (bad)
			panic(...);
	#endif

KASSERTMSG() replaces it into a single line:

		KASSERTMSG(!bad, ...);

Taken from NetBSD.

(There is a concern that KASSERT() messages are too long; consume more memory,
and not friendly for small monitors.  This have to be considered & revisited
later.)

"Like" from henning@@
Man page review & advices from jmc@@ and schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d352 1
a352 1
		msgbuf_putchar(c);
@


1.82
log
@reboot(9): Add MI reboot entry function

Now, for kernel to "reboot" (reboot, halt, or shutdown), MD boot(9) is called
in some places.  This change introduces a new MI function reboot(9) which is
simply a wrapper to call MD boot(9).

OK kettenis@@ deraadt@@
@
text
@d159 1
a159 2
	panic("kernel %sassertion \"%s\" failed: file \"%s\", line %d",
		t, e, f, l);
@


1.81
log
@Add db_vprintf(), and then use it in ACPI's db_disprint() instead of
formatting into a local buffer.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.80 2013/11/25 00:33:21 djm Exp $	*/
d220 2
a221 1
	boot(bootopt);
@


1.80
log
@disable %n in printf(9); there is no need for it in the kernel besides
making format-string vulnerabilities exploitable; inspired by similar
change made by Kees Cook to Linux; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.79 2013/08/07 22:06:48 bluhm Exp $	*/
d480 1
a480 1
	int flags, retval;
a481 3
	flags = TODDB;
	if (db_log)
		flags |= TOLOG;
d483 1
a483 1
	retval = kprintf(fmt, flags, NULL, NULL, ap);
d488 10
@


1.79
log
@After a panic, do not fill up the dmesg with splassert messages.
They scroll away the important information.  Disable splassert in
panic().
OK deraadt@@ uebayasi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.78 2013/07/03 15:17:24 sf Exp $	*/
d864 1
d866 1
a866 1
				*va_arg(ap, quad_t *) = ret;
d868 1
a868 1
				*va_arg(ap, long *) = ret;
d870 1
a870 1
				*va_arg(ap, short *) = ret;
d872 1
a872 1
				*va_arg(ap, ssize_t *) = ret;
d874 1
a874 1
				*va_arg(ap, int *) = ret;
@


1.78
log
@add support for %td for ptrdiff_t in kernel printf

this also adds support in gcc 4.x kprintf format checks

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.77 2013/03/28 16:55:25 deraadt Exp $	*/
d187 3
@


1.77
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.76 2011/04/03 16:46:19 drahn Exp $	*/
d845 3
@


1.76
log
@Allow kernel printfs to go to console if in ddb instead of being redirected
to xconsole. ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.75 2010/07/26 01:56:27 guenther Exp $	*/
a66 1
#include <machine/cpu.h>
@


1.75
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.74 2008/06/27 17:23:24 miod Exp $	*/
d126 5
d332 5
d340 2
a341 1
	if ((flags & TOCONS) && tp == NULL && constty) {
d351 1
a351 1
	if ((flags & TOCONS) && constty == NULL && c != '\0')
@


1.74
log
@Do not disallow kernel crash dumps on panic if swap encryption is enabled,
as dumpsys() will now clear the sensitive information.

ok djm@@ (and dumpsys changes too)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.73 2007/12/30 11:54:55 bluhm Exp $	*/
d360 1
a360 1
	struct proc *p = curproc;
d363 1
a363 1
	if (p->p_flag & P_CONTROLT && p->p_session->s_ttyvp) {
d365 1
a365 1
		kprintf(fmt, TOTTY, p->p_session->s_ttyp, NULL, ap);
d383 1
d391 1
d393 3
a395 3
	if (p->p_flag & P_CONTROLT && p->p_session->s_ttyvp) {
		SESSHOLD(p->p_session);
		return ((tpr_t) p->p_session);
@


1.73
log
@Remove unused variable consintr.  ok mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.72 2007/10/08 04:15:10 ray Exp $	*/
a72 3
#if defined(UVM_SWAP_ENCRYPT)
extern int uvm_doswapencrypt;
#endif
a184 4
#if defined(UVM_SWAP_ENCRYPT)
	if (uvm_doswapencrypt)
		bootopt &= ~RB_DUMP;
#endif
@


1.72
log
@Introduce %z for printf(9), like %z for printf(3).  Used to print
size_t and ssize_t variables.

OK miod and cthulhu.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.71 2007/09/01 11:54:49 miod Exp $	*/
a107 1
int	consintr = 1;	/* ok to handle console interrupts? */
d497 1
a497 1
	int savintr, retval;
a500 2
	savintr = consintr;		/* disable interrupts */
	consintr = 0;
a505 1
	consintr = savintr;		/* reenable interrupts */
d520 1
a520 1
	int savintr, retval;
a523 2
	savintr = consintr;		/* disable interrupts */
	consintr = 0;
a526 1
	consintr = savintr;		/* reenable interrupts */
@


1.71
log
@Remove support for ddb-only %r, %z, and the ddb-specific handling of %n from
the kernel printf. This will allow support for the real %z in the near future.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.70 2007/04/26 20:28:25 deraadt Exp $	*/
d636 1
d645 1
d651 1
d839 3
d866 2
@


1.70
log
@enable splassert (1) by default; requested and ok many
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.69 2006/12/11 05:08:18 deraadt Exp $	*/
d585 1
a585 3
 * Two additional formats:
 *
 * The format %b is supported to decode error registers.
a762 37
#ifdef DDB
		/* XXX: non-standard '%r' format (print int in db_radix) */
		case 'r':
			if ((oflags & TODDB) == 0)
				goto default_case;

			if (db_radix == 16)
				goto case_z;	/* signed hex */
			_uquad = SARG();
			if ((quad_t)_uquad < 0) {
				_uquad = -_uquad;
				sign = '-';
			}
			base = (db_radix == 8) ? OCT : DEC;
			goto number;


		/* XXX: non-standard '%z' format ("signed hex", a "hex %i")*/
		case 'z':
		case_z:
			if ((oflags & TODDB) == 0)
				goto default_case;

			xdigs = "0123456789abcdef";
			ch = 'x';	/* the 'x' in '0x' (below) */
			_uquad = SARG();
			base = HEX;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && _uquad != 0)
				flags |= HEXPREFIX;
			if ((quad_t)_uquad < 0) {
				_uquad = -_uquad;
				sign = '-';
			}
			goto number;
#endif

a853 22
#ifdef DDB
		/* XXX: non-standard '%n' format */
		/*
		 * XXX: HACK!   DDB wants '%n' to be a '%u' printed
		 * in db_radix format.   this should die since '%n'
		 * is already defined in standard printf to write
		 * the number of chars printed so far to the arg (which
		 * should be a pointer.
		 */
			if (oflags & TODDB) {
				if (db_radix == 16)
					ch = 'x';	/* convert to %x */
				else if (db_radix == 8)
					ch = 'o';	/* convert to %o */
				else
					ch = 'u';	/* convert to %u */

				/* ... and start again */
				goto reswitch;
			}

#endif
a982 3
#ifdef DDB
		default_case:	/* DDB */
#endif
@


1.69
log
@allow bit 32 to be printed; bug spotted and fix tested by dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.68 2006/11/17 09:21:52 jmc Exp $	*/
d135 1
a135 1
int splassert_ctl = 0;
@


1.68
log
@missing punctuation in comments; from bret lambert
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.67 2006/07/06 18:14:49 miod Exp $	*/
d742 1
a742 1
					else if (n < ' ')
@


1.67
log
@Make the ddb.log sysctl available as an in-ddb variable, $log, for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.66 2006/06/01 23:17:23 jason Exp $	*/
d1128 1
a1128 1
 *       them are really useful, we have to provide a dummy puts and putchar
@


1.66
log
@the bit shifted should be a type at least as wide as the comparison (u_quad_t)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.65 2006/05/29 20:33:15 jason Exp $	*/
d71 1
a71 1
extern	int db_radix;		/* XXX: for non-standard '%r' format */
@


1.65
log
@extend %b support so that it will allow for arguments with more than 32 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.64 2005/12/27 18:35:34 miod Exp $	*/
d744 1
a744 1
					if (_uquad & (1 << n)) {
@


1.64
log
@tprintf() is now only necessary for NFS, so do not compile it for kernels
which like NFSSERVER and NFSCLIENT.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.63 2005/12/09 09:09:52 jsg Exp $	*/
d604 12
d720 1
a720 1
			_uquad = va_arg(ap, u_int);
d740 5
a744 1
					if (_uquad & (1 << (n - 1))) {
d746 3
a748 2
						while ((n = *b) > ' ') {
							KPRINTF_PUTCHAR(n);
d753 2
a754 1
						while(*b > ' ')
@


1.63
log
@ansi and deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.62 2005/09/27 12:26:13 grunk Exp $	*/
d378 2
d442 2
@


1.62
log
@typo in comment: sprintf -> snprintf, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.61 2005/04/14 21:58:50 krw Exp $	*/
d156 1
a156 3
__assert(t, f, l, e)
	const char *t, *f, *e;
	int l;
d168 1
a168 2
tablefull(tab)
	const char *tab;
@


1.61
log
@Try to start log message buffer on a new line. Helps install scripts avoid
detecting phantom devices when scanning dmesg output.

Suggested by miod@@, ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.60 2004/07/20 20:19:52 art Exp $	*/
d86 1
a86 1
#define TOBUFONLY	0x08	/* to the buffer (only) [for sprintf] */
d487 1
a487 1
 * normal kernel printf functions: printf, vprintf, sprintf
@


1.60
log
@protect printf with a mutex instead of SIMPLELOCK.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.59 2004/06/13 21:49:26 niklas Exp $	*/
a337 1
	struct msgbuf *mbp;
d349 2
a350 15
	    c != '\0' && c != '\r' && c != 0177 && msgbufmapped) {
		mbp = msgbufp;
		if (mbp->msg_magic != MSG_MAGIC) {
			/* Nothing we can do */
		}
		mbp->msg_bufc[mbp->msg_bufx++] = c;
		mbp->msg_bufl = min(mbp->msg_bufl+1, mbp->msg_bufs);
		if (mbp->msg_bufx < 0 || mbp->msg_bufx >= mbp->msg_bufs)
			mbp->msg_bufx = 0;
		/* If the buffer is full, keep the most recent data. */
		if (mbp->msg_bufr == mbp->msg_bufx) {
			if (++mbp->msg_bufr >= mbp->msg_bufs)
				mbp->msg_bufr = 0;
		}
	}
@


1.59
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a49 1
#include <sys/simplelock.h>
d55 1
d101 1
a101 43
#ifdef MULTIPROCESSOR

#ifdef notdef

struct simplelock kprintf_slock;

#define KPRINTF_MUTEX_ENTER(s)						\
do {									\
	(s) = splhigh();						\
	simple_lock(&kprintf_slock);					\
} while (/*CONSTCOND*/0)

#define KPRINTF_MUTEX_EXIT(s)						\
do {									\
	simple_unlock(&kprintf_slock);					\
	splx((s));							\
} while (/*CONSTCOND*/0)

#else

struct __mp_lock kprintf_slock;

#define KPRINTF_MUTEX_ENTER(s)						\
do {									\
	(s) = splhigh();						\
	__mp_lock(&kprintf_slock);					\
} while (/*CONSTCOND*/0)

#define KPRINTF_MUTEX_EXIT(s)						\
do {									\
	__mp_unlock(&kprintf_slock);					\
	splx((s));							\
} while (/*CONSTCOND*/0)

#endif

#else

struct simplelock kprintf_slock;
#define KPRINTF_MUTEX_ENTER(s) (s) = splhigh()
#define KPRINTF_MUTEX_EXIT(s) splx((s))

#endif /* MULTIPROCESSOR */
a511 1
	int s;
d513 1
a513 1
	KPRINTF_MUTEX_ENTER(s);
d524 1
a524 1
	KPRINTF_MUTEX_EXIT(s);
d539 2
d547 3
@


1.58
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.57 2003/12/21 15:30:21 miod Exp $	*/
d50 1
d101 44
d554 3
d566 3
@


1.57
log
@Kill non-standard kernel printf %: braindead extension for good.
ok markus@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.56 2003/06/28 01:52:17 tedu Exp $	*/
d62 1
a62 1
#include <machine/stdarg.h>
@


1.56
log
@option to log ddb output to kernel message buffer, via sysctl ddb.log
ok deraadt@@ henric@@ djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.55 2003/06/02 23:28:06 millert Exp $	*/
a603 13
 * The format %: passes an additional format string and argument list
 * recursively.  Its usage is:
 *
 * fn(char *fmt, ...)
 * {
 *	va_list ap;
 *	va_start(ap, fmt);
 *	printf("prefix: %: suffix\n", fmt, ap);
 *	va_end(ap);
 * }
 *
 * this is the actual printf innards
 *
a703 10
		/* XXX: non-standard '%:' format */
#ifndef __powerpc__
		case ':':
			if (!(oflags & TOBUFONLY)) {
				cp = va_arg(ap, char *);
				kprintf(cp, oflags, vp,
				    NULL, va_arg(ap, va_list));
			}
			continue;	/* no output */
#endif
@


1.55
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.54 2003/05/29 14:41:53 ho Exp $	*/
d483 1
a483 1
	int retval;
d485 3
d489 1
a489 1
	retval = kprintf(fmt, TODDB, NULL, NULL, ap);
@


1.54
log
@Add kern.splassert=3. deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.53 2003/05/27 21:03:49 henning Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.53
log
@typos in comments; From: Bengt Wessling <bengt@@lemuria.org>, 10x
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.52 2003/05/22 20:42:43 deraadt Exp $	*/
d243 6
@


1.52
log
@remove sprintf() and vsprintf().  nothing in the kernel needs it.  if
some module does -- tough -- they can rewrite it using the safer versions.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.51 2003/05/21 16:17:37 art Exp $	*/
d64 1
a64 1
 * ansi and traditional c complers.
@


1.51
log
@Match vprintf prototype to userland and standards.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.50 2003/05/20 20:47:12 jason Exp $	*/
a532 42
}

__warn_references(sprintf,
    "warning: sprintf() is often misused, please use snprintf()");

/*
 * sprintf: print a message to a buffer
 */
int
sprintf(char *buf, const char *fmt, ...)
{
	int retval;
	va_list ap;

	va_start(ap, fmt);
	retval = kprintf(fmt, TOBUFONLY, NULL, buf, ap);
	va_end(ap);
	*(buf + retval) = 0;	/* null terminate */
	return(retval);
}

__warn_references(vsprintf,
    "warning: vsprintf() is often misused, please use vsnprintf()");

/*
 * vsprintf: print a message to the provided buffer [already have a
 *	va_list]
 */
int
vsprintf(char *buf, const char *fmt, va_list ap)
{
	int savintr;
	int len;

	savintr = consintr;		/* disable interrupts */
	consintr = 0;
	len = kprintf(fmt, TOBUFONLY, NULL, buf, ap);
	if (!panicstr)
		logwakeup();
	consintr = savintr;		/* reenable interrupts */
	buf[len] = 0;
	return (len);
@


1.50
log
@ansi and de-register; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.49 2003/05/13 02:09:46 jason Exp $	*/
d521 1
a521 1
void
d524 1
a524 1
	int savintr;
d528 1
a528 1
	kprintf(fmt, TOCONS | TOLOG, NULL, NULL, ap);
d532 1
@


1.49
log
@Kill a bunch more commons (very few left =)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.48 2003/05/10 21:44:53 deraadt Exp $	*/
d264 1
a264 1
	register int s;
d286 1
a286 2
logpri(level)
	int level;
d305 1
a305 1
	register int s;
d330 1
a330 4
kputchar(c, flags, tp)
	register int c;
	int flags;
	struct tty *tp;
d380 1
a380 1
	register struct proc *p = curproc;
d406 1
a406 2
tprintf_open(p)
	register struct proc *p;
d421 1
a421 2
tprintf_close(sess)
	tpr_t sess;
d437 1
a437 1
	register struct session *sess = (struct session *)tpr;
d522 1
a522 3
vprintf(fmt, ap)
	const char *fmt;
	va_list ap;
d561 1
a561 4
vsprintf(buf, fmt, ap)
	char *buf;
	const char *fmt;
	va_list ap;
d601 1
a601 5
vsnprintf(buf, size, fmt, ap)
	char *buf;
	size_t size;
	const char *fmt;
	va_list ap;
d706 1
a706 6
kprintf(fmt0, oflags, vp, sbuf, ap)
	const char *fmt0;
	int oflags;
	void *vp;
	char *sbuf;
	va_list ap;
@


1.48
log
@warn for strcpy|strcat|sprintf|vsprintf; ok art dhartmei pval, and either henning or pb, i cannot tell which it was
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.47 2003/05/06 12:22:08 deraadt Exp $	*/
d108 1
a108 1
struct	tty *constty;	/* pointer to console "window" tty */
@


1.47
log
@use snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.46 2003/01/13 18:32:03 weingart Exp $	*/
d542 3
d561 3
a567 1

@


1.46
log
@Fix kernel snprintf function(s) to be like
userland in return values.

deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.45 2002/10/14 20:15:23 art Exp $	*/
d201 1
a201 1
		vsprintf(panicbuf, fmt, ap);
d293 1
a293 1
	sprintf(snbuf, "%d", level);
d785 1
a785 1
				sprintf(buf, "%llo", _uquad);
d787 1
a787 1
				sprintf(buf, "%lld", _uquad);
d789 1
a789 1
				sprintf(buf, "%llx", _uquad);
@


1.45
log
@Stuff needed for gcc 3.X.

gcc has the nice feature of optimizing various common constructs into
more optimal ones, inlining various calls, etc. The problem with that
is that it assumes that we have a proper libc backing us. We really
don't want to loose all those features by defining -ffreestanding and
right now there is no way to just disable some of them, so we have to
make the kernel more libc-like in some aspects to make it work with
newer gcc.

rename putchar to kputchar because it was nothing like libc putchar (and
only internal to this function). Implement dummy putchar and puts (not
prototyped outside this file).
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.44 2002/05/20 22:16:36 art Exp $	*/
d91 1
d579 1
a579 1
	return (0);
d592 1
d594 1
a594 2
		return (-1);
	p = buf + size - 1;
d596 1
a596 1
	retval = kprintf(fmt, TOBUFONLY, &p, buf, ap);
d598 2
a599 1
	*(p) = 0;	/* null terminate */
d616 1
d618 4
a621 4
		return (-1);
	p = buf + size - 1;
	retval = kprintf(fmt, TOBUFONLY, &p, buf, ap);
	*(p) = 0;	/* null terminate */
d701 4
a704 2
#define KPRINTF_PUTCHAR(C) {						\
	if (oflags == TOBUFONLY) {					\
d706 4
a709 4
			ret += 1;		/* indicate error */	\
			goto overflow;					\
		}							\
		*sbuf++ = (C);						\
d711 1
a711 1
		kputchar((C), oflags, (struct tty *)vp);			\
d713 1
a713 1
}
d742 1
a742 1
	if (oflags == TOBUFONLY && (vp != NULL))
a752 1
			ret++;
d771 1
a771 1
			if (oflags != TOBUFONLY) {
a795 1
				ret++;
a802 1
						ret++;
a804 1
							ret++;
a814 1
					ret++;
a1132 3
		/* adjust ret */
		ret += width > realsz ? width : realsz;

d1172 1
a1172 1
	if ((oflags == TOBUFONLY) && (vp != NULL))
@


1.44
log
@Add one more level to the kern.splassert sysctl.
0 - do nothing.
1 - small message on error (function name and the levels).
2 - big message on error (function name, levels and traceback (if possible)).
3 - panic.
After suggestion from deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.43 2002/05/18 18:33:42 art Exp $	*/
d101 1
a101 2
void	 putchar(int, int, struct tty *);

d291 1
a291 1
	putchar('<', TOLOG, NULL);
d294 2
a295 2
		putchar(*p, TOLOG, NULL);
	putchar('>', TOLOG, NULL);
d324 1
a324 1
 * putchar: print a single character on console or user terminal.
d330 1
a330 1
putchar(c, flags, tp)
d706 1
a706 1
		putchar((C), oflags, (struct tty *)vp);			\
d1181 30
@


1.43
log
@dump the stack on splassert failure (XXX - need some kind of
rate limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.42 2002/05/18 18:24:21 art Exp $	*/
d237 4
a240 3
	if (splassert_ctl > 1) {
		panic("spl assertion failure in %s", func);
	} else {
d244 3
@


1.42
log
@If ddb.panic is disabled, print the stack trace before dumping.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.41 2002/05/15 23:17:53 art Exp $	*/
d241 1
a241 1
		/* Will print stack trace RSN. */
@


1.41
log
@Implement splassert() for sparc - a tool for finding problems related to
spl handling (already found 3 problems).

Man page in a few seconds.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.40 2002/03/15 18:19:52 millert Exp $	*/
d222 2
@


1.40
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.39 2002/03/14 01:27:04 millert Exp $	*/
d134 5
d224 18
@


1.39
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.38 2002/01/23 15:46:48 art Exp $	*/
a180 1
#ifdef __STDC__
a181 5
#else
panic(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a232 1
#ifdef __STDC__
a233 6
#else
log(level, fmt, va_alist)
	int level;
	char *fmt;
	va_dcl
#endif
a274 1
#ifdef __STDC__
a275 5
#else
addlog(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a352 1
#ifdef __STDC__
a353 5
#else
uprintf(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a411 1
#ifdef __STDC__
a412 6
#else
tprintf(tpr, fmt, va_alist)
	tpr_t tpr;
	char *fmt;
	va_dcl
#endif
a438 1
#ifdef __STDC__
a439 6
#else
ttyprintf(tp, fmt, va_alist)
	struct tty *tp;
	char *fmt;
	va_dcl
#endif
a454 1
#ifdef __STDC__
a455 5
#else
db_printf(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a476 1
#ifdef __STDC__
a477 5
#else
printf(fmt, va_alist)
	char *fmt;
	va_dcl
#endif
a516 1
#ifdef __STDC__
a517 6
#else
sprintf(buf, fmt, va_alist)
	char *buf;
	const char *cfmt;
	va_dcl
#endif
a556 1
#ifdef __STDC__
a557 7
#else
snprintf(buf, size, fmt, va_alist)
	char *buf;
	size_t size;
	const char *cfmt;
	va_dcl
#endif
@


1.38
log
@Allocate rusage, pgrp, ucred and session with pool.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.37 2001/12/02 02:03:13 deraadt Exp $	*/
d100 2
a101 2
int	 kprintf __P((const char *, int, void *, char *, va_list));
void	 putchar __P((int, int, struct tty *));
d140 1
a140 1
void (*v_putc) __P((int)) = cnputc;	/* start with cnputc (normal cons) */
@


1.37
log
@remove some XXX comments
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.36 2001/11/15 07:57:29 niklas Exp $	*/
d58 1
@


1.37.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.38 2002/01/23 15:46:48 art Exp $	*/
a57 1
#include <sys/pool.h>
@


1.37.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.37.2.1 2002/01/31 22:55:41 niklas Exp $	*/
d100 2
a101 2
int	 kprintf(const char *, int, void *, char *, va_list);
void	 putchar(int, int, struct tty *);
a133 5
 * panic on spl assertion failure?
 */
int splassert_ctl = 0;

/*
d140 1
a140 1
void (*v_putc)(int) = cnputc;	/* start with cnputc (normal cons) */
d181 1
d183 5
a222 2
	else
		db_stack_dump();
a227 22
 * We print only the function name. The file name is usually very long and
 * would eat tons of space in the kernel.
 */
void
splassert_fail(int wantipl, int haveipl, const char *func)
{

	printf("splassert: %s: want %d have %d\n", func, wantipl, haveipl);
	switch (splassert_ctl) {
	case 1:
		break;
	case 2:
#ifdef DDB
		db_stack_dump();
#endif
		break;
	default:
		panic("spl assertion failure in %s", func);
	}
}

/*
d239 1
d241 6
d288 1
d290 5
d372 1
d374 5
d437 1
d439 6
d471 1
d473 6
d494 1
d496 5
d522 1
d524 5
d568 1
d570 6
d615 1
d617 7
@


1.37.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.37.2.2 2002/06/11 03:29:40 art Exp $	*/
d101 2
a102 1
void	 kputchar(int, int, struct tty *);
d292 1
a292 1
	kputchar('<', TOLOG, NULL);
d295 2
a296 2
		kputchar(*p, TOLOG, NULL);
	kputchar('>', TOLOG, NULL);
d325 1
a325 1
 * kputchar: print a single character on console or user terminal.
d331 1
a331 1
kputchar(c, flags, tp)
d707 1
a707 1
		kputchar((C), oflags, (struct tty *)vp);			\
a1181 30

#if __GNUC_PREREQ__(2,96)
/*
 * XXX - these functions shouldn't be in the kernel, but gcc 3.X feels like
 *       translating some printf calls to puts and since it doesn't seem
 *       possible to just turn off parts of those optimizations (some of
 *       them are really useful, we have to provide a dummy puts and putchar
 *	 that are wrappers around printf.
 */
int	puts(const char *);
int	putchar(int c);

int
puts(const char *str)
{
	printf("%s\n", str);

	return (0);
}

int
putchar(int c)
{
	printf("%c", c);

	return (c);
}


#endif
@


1.37.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a90 1
#define TOCOUNT		0x20	/* act like [v]snprintf */
d107 1
a107 1
extern struct	tty *constty;	/* pointer to console "window" tty */
d200 1
a200 1
		vsnprintf(panicbuf, sizeof panicbuf, fmt, ap);
d292 1
a292 1
	snprintf(snbuf, sizeof snbuf, "%d", level);
a540 3
__warn_references(sprintf,
    "warning: sprintf() is often misused, please use snprintf()");

a556 3
__warn_references(vsprintf,
    "warning: vsprintf() is often misused, please use vsnprintf()");

d561 1
d578 1
a578 1
	return (len);
d591 2
a593 2
	if (size < 1)
		p = buf;
d595 1
a595 1
	retval = kprintf(fmt, TOBUFONLY | TOCOUNT, &p, buf, ap);
d597 1
a597 2
	if (size > 0)
		*(p) = 0;	/* null terminate */
d614 2
d617 2
a618 5
	if (size < 1)
		p = buf;
	retval = kprintf(fmt, TOBUFONLY | TOCOUNT, &p, buf, ap);
	if (size > 0)
		*(p) = 0;	/* null terminate */
d698 2
a699 4
#define KPRINTF_PUTCHAR(C) do {					\
	int chr = (C);							\
	ret += 1;							\
	if (oflags & TOBUFONLY) {					\
d701 4
a704 4
			if (!(oflags & TOCOUNT))				\
				goto overflow;				\
		} else							\
			*sbuf++ = chr;					\
d706 1
a706 1
		kputchar(chr, oflags, (struct tty *)vp);			\
d708 1
a708 1
} while(0)
d737 1
a737 1
	if ((oflags & TOBUFONLY) && (vp != NULL))
d748 1
d767 1
a767 1
			if (!(oflags & TOBUFONLY)) {
d781 1
a781 1
				snprintf(buf, sizeof buf, "%llo", _uquad);
d783 1
a783 1
				snprintf(buf, sizeof buf, "%lld", _uquad);
d785 1
a785 1
				snprintf(buf, sizeof buf, "%llx", _uquad);
d792 1
d800 1
d803 1
d814 1
d1133 3
d1175 1
a1175 1
	if ((oflags & TOBUFONLY) && (vp != NULL))
@


1.36
log
@remove statics
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.35 2001/09/05 22:32:39 deraadt Exp $	*/
a63 1
 * XXX: this requires that stdarg.h define: va_alist and va_dcl
d268 1
a268 1
void			/* XXXCDC: should be static? */
d758 1
a758 1
	char *cp;		/* handy char pointer (short term usage) */
d769 2
a770 2
	int size;		/* size of converted field or string */
	char *xdigs;		/* digits for [xX] conversion */
d772 1
a772 1
	char *tailp;		/* tail pointer for snprintf */
a773 1
	tailp = NULL;	/* XXX: shutup gcc */
a776 3
	cp = NULL;	/* XXX: shutup gcc */
	size = 0;	/* XXX: shutup gcc */

a778 2

	xdigs = NULL;		/* XXX: shut up gcc warning */
@


1.35
log
@make sure that va_start() has matching va_end()
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.34 2001/09/05 19:22:23 deraadt Exp $	*/
d100 2
a101 3
static int	 kprintf __P((const char *, int, void *,
		    char *, va_list));
static void	 putchar __P((int, int, struct tty *));
d320 1
a320 1
static void
d748 1
a748 1
static int
@


1.34
log
@use %ll instead of %q
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.33 2001/06/27 04:49:46 art Exp $	*/
d206 1
d256 1
a257 1
	va_end(ap);
d303 1
a304 1
	va_end(ap);
@


1.33
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.32 2001/06/22 14:14:09 deraadt Exp $	*/
d825 1
a825 1
				sprintf(buf, "%qo", _uquad);
d827 1
a827 1
				sprintf(buf, "%qd", _uquad);
d829 1
a829 1
				sprintf(buf, "%qx", _uquad);
@


1.32
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.31 2001/02/22 19:33:22 mickey Exp $	*/
d76 1
a76 1
#if defined(UVM) && defined(UVM_SWAP_ENCRYPT)
d195 1
a195 1
#if defined(UVM) && defined(UVM_SWAP_ENCRYPT)
@


1.31
log
@avoid sign extension for %b
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.30 2000/06/25 18:45:19 provos Exp $	*/
d100 2
a101 2
static int	 kprintf __P((const char *, int, void *, 
				char *, va_list));
d149 2
a150 2
 *      Partial support (the failure case) of the assertion facility
 *      commonly found in userland.
d177 1
a177 1
 * call) we avoid trying to sync the disk and just reboot (to avoid 
d348 5
a352 5
                /* If the buffer is full, keep the most recent data. */
                if (mbp->msg_bufr == mbp->msg_bufx) {
                         if (++mbp->msg_bufr >= mbp->msg_bufs)
                                mbp->msg_bufr = 0;
                }
d431 1
a431 1
 * tprintf: given tprintf handle to a process [obtained with tprintf_open], 
d572 3
a574 3
        char *buf;
        const char *cfmt;
        va_dcl
d619 4
a622 4
        char *buf;
        size_t size;
        const char *cfmt;
        va_dcl
d644 4
a647 4
        char *buf;
        size_t size;
        const char *fmt;
        va_list ap;
d663 1
a663 1
 * this version based on vfprintf() from libc which was derived from 
d810 1
a810 1
		case ':': 
d813 2
a814 2
				kprintf(cp, oflags, vp, 
					NULL, va_arg(ap, va_list));
d868 1
a868 1
			if ((oflags & TODDB) == 0) 
d870 1
a870 1
			
d885 1
a885 1
			if ((oflags & TODDB) == 0) 
@


1.30
log
@disable automatic crashdump when swap encryption is on
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.29 2000/03/13 04:05:15 millert Exp $	*/
d822 1
a822 1
			_uquad = va_arg(ap, int);
@


1.29
log
@Get rid of leading NULs in /kern/msgbuf.  If the msgbuf modified in between
reads at just the right time is is possible to get duplicate output but
in practice this is extremely rare.  Joint effort with Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.28 2000/03/02 10:50:29 art Exp $	*/
d76 3
d195 4
@


1.28
log
@Add an option DDB_SAFE_CONSOLE that defaults db_console to 1.
In many cases, setting db_console in /etc/rc is too late.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.27 2000/02/22 19:28:04 deraadt Exp $	*/
d338 1
@


1.27
log
@enlarge msgbuf, somewhat line netbsd did
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.26 1999/12/02 00:23:35 deraadt Exp $	*/
d112 3
d116 11
d128 1
@


1.26
log
@snprintf in kernel; assar@@stacken.kth.se
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.25 1999/01/11 05:12:23 millert Exp $	*/
d320 1
a320 2
			bzero((caddr_t) mbp, sizeof(*mbp));
			mbp->msg_magic = MSG_MAGIC;
d323 1
a323 1
		if (mbp->msg_bufx < 0 || mbp->msg_bufx >= MSG_BSIZE)
d325 5
@


1.26.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d320 2
a321 1
			/* Nothing we can do */
d324 1
a324 1
		if (mbp->msg_bufx < 0 || mbp->msg_bufx >= mbp->msg_bufs)
a325 5
                /* If the buffer is full, keep the most recent data. */
                if (mbp->msg_bufr == mbp->msg_bufx) {
                         if (++mbp->msg_bufr >= mbp->msg_bufs)
                                mbp->msg_bufr = 0;
                }
@


1.26.2.2
log
@Sync with -current
@
text
@a111 3
/*
 * Enter ddb on panic.
 */
a112 11

/*
 * db_console controls if we can be able to enter ddb by a special key
 * combination (machine dependent).
 * If DDB_SAFE_CONSOLE is defined in the kernel configuration it allows
 * to break into console during boot. It's _really_ useful when debugging
 * some things in the kernel that can cause init(8) to crash.
 */
#ifdef DDB_SAFE_CONSOLE
int	db_console = 1;
#else
a114 1
#endif
a322 1
		mbp->msg_bufl = min(mbp->msg_bufl+1, mbp->msg_bufs);
@


1.26.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.31 2001/02/22 19:33:22 mickey Exp $	*/
a75 3
#if defined(UVM) && defined(UVM_SWAP_ENCRYPT)
extern int uvm_doswapencrypt;
#endif
a191 4
#if defined(UVM) && defined(UVM_SWAP_ENCRYPT)
	if (uvm_doswapencrypt)
		bootopt &= ~RB_DUMP;
#endif
d815 1
a815 1
			_uquad = va_arg(ap, u_int);
@


1.26.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.26.2.3 2001/05/14 22:32:43 niklas Exp $	*/
d76 1
a76 1
#if defined(UVM_SWAP_ENCRYPT)
d100 2
a101 2
static int	 kprintf __P((const char *, int, void *,
		    char *, va_list));
d149 2
a150 2
 *	Partial support (the failure case) of the assertion facility
 *	commonly found in userland.
d177 1
a177 1
 * call) we avoid trying to sync the disk and just reboot (to avoid
d195 1
a195 1
#if defined(UVM_SWAP_ENCRYPT)
d348 5
a352 5
		/* If the buffer is full, keep the most recent data. */
		if (mbp->msg_bufr == mbp->msg_bufx) {
			if (++mbp->msg_bufr >= mbp->msg_bufs)
				mbp->msg_bufr = 0;
		}
d431 1
a431 1
 * tprintf: given tprintf handle to a process [obtained with tprintf_open],
d572 3
a574 3
	char *buf;
	const char *cfmt;
	va_dcl
d619 4
a622 4
	char *buf;
	size_t size;
	const char *cfmt;
	va_dcl
d644 4
a647 4
	char *buf;
	size_t size;
	const char *fmt;
	va_list ap;
d663 1
a663 1
 * this version based on vfprintf() from libc which was derived from
d810 1
a810 1
		case ':':
d813 2
a814 2
				kprintf(cp, oflags, vp,
				    NULL, va_arg(ap, va_list));
d868 1
a868 1
			if ((oflags & TODDB) == 0)
d870 1
a870 1

d885 1
a885 1
			if ((oflags & TODDB) == 0)
@


1.26.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.26.2.4 2001/07/04 10:48:32 niklas Exp $	*/
a205 1
	va_end(ap);
d255 1
a256 1
	splx(s);
d302 1
a303 1
	splx(s);
d825 1
a825 1
				sprintf(buf, "%llo", _uquad);
d827 1
a827 1
				sprintf(buf, "%lld", _uquad);
d829 1
a829 1
				sprintf(buf, "%llx", _uquad);
@


1.26.2.6
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 1
d100 3
a102 2
int	 kprintf __P((const char *, int, void *, char *, va_list));
void	 putchar __P((int, int, struct tty *));
d270 1
a270 1
void
d321 1
a321 1
void
d749 1
a749 1
int
d760 1
a760 1
	char *cp = NULL;	/* handy char pointer (short term usage) */
d771 2
a772 2
	int size = 0;		/* size of converted field or string */
	char *xdigs = NULL;	/* digits for [xX] conversion */
d774 1
a774 1
	char *tailp = NULL;	/* tail pointer for snprintf */
d776 1
d780 3
d785 2
@


1.26.2.7
log
@Merge in trunk
@
text
@a57 1
#include <sys/pool.h>
@


1.26.2.8
log
@Merge in -current from about a week ago
@
text
@d100 2
a101 2
int	 kprintf(const char *, int, void *, char *, va_list);
void	 putchar(int, int, struct tty *);
d140 1
a140 1
void (*v_putc)(int) = cnputc;	/* start with cnputc (normal cons) */
d181 1
d183 5
d239 1
d241 6
d288 1
d290 5
d372 1
d374 5
d437 1
d439 6
d471 1
d473 6
d494 1
d496 5
d522 1
d524 5
d568 1
d570 6
d615 1
d617 7
@


1.26.2.9
log
@Sync the SMP branch with 3.3
@
text
@a90 1
#define TOCOUNT		0x20	/* act like [v]snprintf */
d101 2
a102 1
void	 kputchar(int, int, struct tty *);
a133 5
 * panic on spl assertion failure?
 */
int splassert_ctl = 0;

/*
a216 2
	else
		db_stack_dump();
a221 22
 * We print only the function name. The file name is usually very long and
 * would eat tons of space in the kernel.
 */
void
splassert_fail(int wantipl, int haveipl, const char *func)
{

	printf("splassert: %s: want %d have %d\n", func, wantipl, haveipl);
	switch (splassert_ctl) {
	case 1:
		break;
	case 2:
#ifdef DDB
		db_stack_dump();
#endif
		break;
	default:
		panic("spl assertion failure in %s", func);
	}
}

/*
d263 1
a263 1
	kputchar('<', TOLOG, NULL);
d266 2
a267 2
		kputchar(*p, TOLOG, NULL);
	kputchar('>', TOLOG, NULL);
d296 1
a296 1
 * kputchar: print a single character on console or user terminal.
d302 1
a302 1
kputchar(c, flags, tp)
d550 1
a550 1
	return (len);
d563 2
a565 2
	if (size < 1)
		p = buf;
d567 1
a567 1
	retval = kprintf(fmt, TOBUFONLY | TOCOUNT, &p, buf, ap);
d569 1
a569 2
	if (size > 0)
		*(p) = 0;	/* null terminate */
d586 2
d589 2
a590 5
	if (size < 1)
		p = buf;
	retval = kprintf(fmt, TOBUFONLY | TOCOUNT, &p, buf, ap);
	if (size > 0)
		*(p) = 0;	/* null terminate */
d670 2
a671 4
#define KPRINTF_PUTCHAR(C) do {					\
	int chr = (C);							\
	ret += 1;							\
	if (oflags & TOBUFONLY) {					\
d673 4
a676 4
			if (!(oflags & TOCOUNT))				\
				goto overflow;				\
		} else							\
			*sbuf++ = chr;					\
d678 1
a678 1
		kputchar(chr, oflags, (struct tty *)vp);			\
d680 1
a680 1
} while(0)
d709 1
a709 1
	if ((oflags & TOBUFONLY) && (vp != NULL))
d720 1
d739 1
a739 1
			if (!(oflags & TOBUFONLY)) {
d764 1
d772 1
d775 1
d786 1
d1105 3
d1147 1
a1147 1
	if ((oflags & TOBUFONLY) && (vp != NULL))
a1152 30

#if __GNUC_PREREQ__(2,96)
/*
 * XXX - these functions shouldn't be in the kernel, but gcc 3.X feels like
 *       translating some printf calls to puts and since it doesn't seem
 *       possible to just turn off parts of those optimizations (some of
 *       them are really useful, we have to provide a dummy puts and putchar
 *	 that are wrappers around printf.
 */
int	puts(const char *);
int	putchar(int c);

int
puts(const char *str)
{
	printf("%s\n", str);

	return (0);
}

int
putchar(int c)
{
	printf("%c", c);

	return (c);
}


#endif
@


1.26.2.10
log
@MP lock around printf, so printf debugging execution on other CPUs is safe
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.26.2.9 2003/03/28 00:41:27 niklas Exp $	*/
a53 1
#include <sys/simplelock.h>
a103 23
#ifdef MULTIPROCESSOR

struct simplelock kprintf_slock = SLOCK_INITIALIZER;

#define KPRINTF_MUTEX_ENTER(s)						\
do {									\
	(s) = splhigh();						\
	simple_lock(&kprintf_slock);					\
} while (/*CONSTCOND*/0)

#define KPRINTF_MUTEX_EXIT(s)						\
do {									\
	simple_unlock(&kprintf_slock);					\
	splx((s));							\
} while (/*CONSTCOND*/0)

#else

#define KPRINTF_MUTEX_ENTER(s) (s) = splhigh()
#define KPRINTF_MUTEX_EXIT(s) splx((s))

#endif /* MULTIPROCESSOR */

a509 3
	int s;

	KPRINTF_MUTEX_ENTER(s);
a518 3

	KPRINTF_MUTEX_EXIT(s);

@


1.26.2.11
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.26.2.10 2003/04/04 14:59:13 niklas Exp $	*/
d225 1
a225 1
		vsnprintf(panicbuf, sizeof panicbuf, fmt, ap);
d317 1
a317 1
	snprintf(snbuf, sizeof snbuf, "%d", level);
a571 3
__warn_references(sprintf,
    "warning: sprintf() is often misused, please use snprintf()");

a587 3
__warn_references(vsprintf,
    "warning: vsprintf() is often misused, please use vsnprintf()");

d592 1
d815 1
a815 1
				snprintf(buf, sizeof buf, "%llo", _uquad);
d817 1
a817 1
				snprintf(buf, sizeof buf, "%lld", _uquad);
d819 1
a819 1
				snprintf(buf, sizeof buf, "%llx", _uquad);
@


1.26.2.12
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.26.2.11 2003/05/13 19:21:28 ho Exp $	*/
d107 1
a107 1
struct simplelock kprintf_slock;
@


1.26.2.13
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d132 1
a132 1
extern struct	tty *constty;	/* pointer to console "window" tty */
@


1.26.2.14
log
@Go back to defining simplelocks as noops, even if MULTIPROCESSOR.  Instead use
a new real simple recursive-lock capable lock implementation for the few
necessary locks (kernel, scheduler, tlb shootdown, printf and ddb MP).
This because we cannot trust the old fine-grained locks spread out all over
our kernel, and not really tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.26.2.13 2003/05/16 00:29:43 niklas Exp $	*/
a106 2
#ifdef notdef

a119 18

#else

struct __mp_lock kprintf_slock;

#define KPRINTF_MUTEX_ENTER(s)						\
do {									\
	(s) = splhigh();						\
	__mp_lock(&kprintf_slock);					\
} while (/*CONSTCOND*/0)

#define KPRINTF_MUTEX_EXIT(s)						\
do {									\
	__mp_unlock(&kprintf_slock);					\
	splx((s));							\
} while (/*CONSTCOND*/0)

#endif
@


1.26.2.15
log
@Add kern.splassert = 3, which works like level 2 but also drops into the
debugger. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.26.2.14 2003/05/18 18:16:45 niklas Exp $	*/
a288 6
	case 3:
#ifdef DDB
		db_stack_dump();
		Debugger();
		break;
#endif
@


1.26.2.16
log
@The 'break' should be outside #ifdef DDB here.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.26.2.15 2003/05/25 19:26:49 ho Exp $	*/
d293 1
a294 1
		break;
@


1.26.2.17
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.26.2.16 2003/05/29 14:35:58 ho Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
d65 1
a65 1
 * ansi and traditional c compilers.
d314 1
a314 1
	int s;
d336 2
a337 1
logpri(int level)
d356 1
a356 1
	int s;
d381 4
a384 1
kputchar(int c, int flags, struct tty *tp)
d434 1
a434 1
	struct proc *p = curproc;
d460 2
a461 1
tprintf_open(struct proc *p)
d476 2
a477 1
tprintf_close(tpr_t sess)
d493 1
a493 1
	struct session *sess = (struct session *)tpr;
d583 21
d605 1
a605 1
vprintf(const char *fmt, va_list ap)
d607 25
a631 1
	int savintr, retval;
d635 1
a635 1
	retval = kprintf(fmt, TOCONS | TOLOG, NULL, NULL, ap);
d639 2
a640 1
	return (retval);
d668 5
a672 1
vsnprintf(char *buf, size_t size, const char *fmt, va_list ap)
d777 6
a782 1
kprintf(const char *fmt0, int oflags, void *vp, char *sbuf, va_list ap)
@


1.26.2.18
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
a63 1
#include <sys/stdarg.h>
d527 1
a527 1
	int flags, retval;
a528 3
	flags = TODDB;
	if (db_log)
		flags |= TOLOG;
d530 1
a530 1
	retval = kprintf(fmt, flags, NULL, NULL, ap);
d651 13
d764 10
@


1.26.2.19
log
@few fixes to make non-smp compile
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.26.2.18 2004/02/19 10:56:38 niklas Exp $	*/
a138 1
struct simplelock kprintf_slock;
@


1.25
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.24 1999/01/10 01:45:31 niklas Exp $	*/
d97 1
a97 1
static int	 kprintf __P((const char *, int, struct tty *, 
d585 49
d709 11
a719 2
#define KPRINTF_PUTCHAR(C) \
	(oflags == TOBUFONLY) ? *sbuf++ = (C) : putchar((C), oflags, tp);
d721 2
a722 2
int
kprintf(fmt0, oflags, tp, sbuf, ap)
d725 1
a725 1
	struct tty *tp;
d746 5
d765 1
a766 1
			ret++;
d786 1
a786 1
				kprintf(cp, oflags, tp, 
d809 1
a810 1
				ret++;
d817 1
a818 1
						ret++;
d820 1
a821 1
							ret++;
d831 1
a832 1
					ret++;
d1150 3
d1189 1
a1190 4
		/* finally, adjust ret */
		ret += width > realsz ? width : realsz;

	}
d1192 3
@


1.24
log
@NUL terminate the buffer in vsprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.23 1998/04/04 18:36:32 deraadt Exp $	*/
d140 1
a140 1
	panic("kernel %sassertion \"%s\" failed: file \"%s\", line %d\n",
@


1.23
log
@default to console ddb off
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.22 1998/02/05 16:49:29 deraadt Exp $	*/
d572 1
d576 1
a576 1
	kprintf(fmt, TOBUFONLY, NULL, buf, ap);
d580 1
@


1.22
log
@rename ddb.panic_ddb, and add ddb.console. Now you can stop console ddb entry
with a sysctl. There will be architectures and drivers that lack function,
and I trust the maintainers of those will forget to add the code..
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.21 1998/01/24 17:54:07 niklas Exp $	*/
d113 1
a113 1
int	db_console = 1;
@


1.21
log
@NULL deref
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.20 1998/01/21 21:59:38 deraadt Exp $	*/
d112 2
a113 1
int	db_panic_ddb = 1;
d199 1
a199 1
	if (db_panic_ddb)
@


1.20
log
@support expanded panicstr; and add vsprintf back
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.19 1997/12/29 14:31:16 deraadt Exp $	*/
d517 2
a518 2
 * vprintf: print a message to the console and the log [already have
 *	va_alist]
d560 2
a561 2
 * vprintf: print a message to the console and the log [already have
 *	va_alist]
d574 1
a574 1
	kprintf(fmt, TOBUFONLY, NULL, NULL, ap);
@


1.19
log
@sysctl ddb.panic_ddb; felix@@mamba.pond.sub.org
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.18 1997/12/28 23:39:28 niklas Exp $	*/
d171 1
d176 1
d179 4
a182 2
	else
		panicstr = fmt;
d184 1
a185 1
	printf("panic: ");
d557 22
@


1.18
log
@Do not lose the first char in msgbuf
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.17 1997/11/04 20:43:26 chuck Exp $	*/
d111 3
d194 2
a195 1
	Debugger();
@


1.17
log
@import torek's vfprintf() from libc [renamed to kprintf and all
floating point stuff removed].

the new kprintf replaces the 3 different (and buggy) versions of
printf that were in the kernel before (kprintf, sprintf, and db_printf),
thus reducing duplicated code by 2/3's.   this fixes (or adds) several
printf formats.

XXX: new kprintf still supports several non-standard '%' formats:
  %: - passes an additional format string and argument list recursively
  %b - used to decode error registers
  %r - int, but print in radix "db_radix" [DDB only]
  %z - 'signed hex' [DDB only]
  %n - unsigned int, but print in radix "db_radix" [DDB only]

note that DDB's "%n" conflicts with standard "%n" which takes the
number of characters written so far and stores it into the integer
indicated by the "int *" pointer arg.  yuck!

while here, add comments for each function explaining what it is
supposed to do.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.45 1997/10/24 18:14:25 chuck Exp $	*/
a312 4
		} else {
			mbp->msg_bufc[mbp->msg_bufx++] = c;
			if (mbp->msg_bufx < 0 || mbp->msg_bufx >= MSG_BSIZE)
				mbp->msg_bufx = 0;
d314 3
@


1.16
log
@added 'q' modifier (64-bit integers) in kernel vsprintf/kprintf
@
text
@d1 2
a2 2
/*	$OpenBSD: subr_prf.c,v 1.15 1996/12/06 08:08:17 niklas Exp $	*/
/*	$NetBSD: subr_prf.c,v 1.25 1996/04/22 01:38:46 christos Exp $	*/
d62 3
a64 2
 * Note that stdarg.h and the ANSI style va_start macro is used for both
 * ANSI and traditional C compilers.
a67 3
#ifdef KADB
#include <machine/kdbparam.h>
#endif
d69 1
d72 4
a76 3
#define TOCONS	0x01
#define TOTTY	0x02
#define TOLOG	0x04
d78 22
a99 1
struct	tty *constty;			/* pointer to console "window" tty */
a100 1
void	(*v_putc) __P((int)) = cnputc;	/* routine to putc on virtual console */
d102 33
a134 3
static void putchar __P((int, int, struct tty *));
static char *ksprintn __P((u_long, int, int *));
void kprintf __P((const char *, int, struct tty *, va_list));
d136 3
a138 1
int consintr = 1;			/* Ok to handle console interrupts? */
d141 1
a141 2
 * Variable panicstr contains argument to first call to panic; used as flag
 * to indicate that the kernel has already called panic.
d143 7
a149 1
const char *panicstr;
d152 5
a156 3
 * Panic is called on unresolvable fatal errors.  It prints "panic: mesg",
 * and then reboots.  If we are called twice, then we avoid trying to sync
 * the disks as this often leads to recursive panics.
d158 1
a167 1
	static char panicbuf[1024];
a171 1
	va_start(ap, fmt);
d174 2
a175 4
	else {
		vsprintf(panicbuf, fmt, ap);
		panicstr = panicbuf;
	}
d177 4
a180 1
	printf("panic: %:\n", fmt, ap);
d197 1
a197 2
 *	Partial support (the failure case) of the assertion facility
 *	commonly found in userland.
d199 8
d208 33
a240 3
__assert(t, f, l, e)
	const char *t, *f, *e;
	int l;
d242 13
d256 24
a279 2
	panic("kernel %sassertion \"%s\" failed: file \"%s\", line %d\n",
	    t, e, f, l);
d282 1
d284 4
a287 1
 * Warn that a system table is full.
d289 5
a293 3
void
tablefull(tab)
	const char *tab;
d295 2
d298 27
a324 1
	log(LOG_ERR, "%s: table is full\n", tab);
d327 1
d329 5
a333 3
 * Uprintf prints to the controlling terminal for the current process.
 * It may block if the tty queue is overfull.  No message is printed if
 * the queue does not clear in a reasonable time.
d335 1
d350 1
a350 1
		kprintf(fmt, TOTTY, p->p_session->s_ttyp, ap);
d355 15
d382 4
d396 4
a399 2
 * tprintf prints on the controlling terminal associated
 * with the given session.
d422 1
a422 1
	kprintf(fmt, flags, tp, ap);
d427 1
d429 5
a433 3
 * Ttyprintf displays a message on a tty; it should be used only by
 * the tty driver, or anything that knows the underlying tty will not
 * be revoke(2)'d away.  Other callers should use tprintf.
d448 1
a448 1
	kprintf(fmt, TOTTY, tp, ap);
d452 1
a452 1
extern	int log_open;
d455 1
a455 3
 * Log writes to the log buffer, and guarantees not to sleep (so can be
 * called by interrupt routines).  If there is no process reading the
 * log yet, it writes to the console also.
d457 2
a458 1
void
d460 1
a460 1
log(int level, const char *fmt, ...)
d462 1
a462 2
log(level, fmt, va_alist)
	int level;
a466 1
	register int s;
d468 1
a469 2
	s = splhigh();
	logpri(level);
d471 1
a471 2
	kprintf(fmt, TOLOG, NULL, ap);
	splx(s);
d473 1
a473 6
	if (!log_open) {
		va_start(ap, fmt);
		kprintf(fmt, TOCONS, NULL, ap);
		va_end(ap);
	}
	logwakeup();
d476 2
a477 6
void
logpri(level)
	int level;
{
	register int ch;
	register char *p;
d479 3
a481 5
	putchar('<', TOLOG, NULL);
	for (p = ksprintn((u_long)level, 10, NULL); (ch = *p--) != 0;)
		putchar(ch, TOLOG, NULL);
	putchar('>', TOLOG, NULL);
}
d483 3
d488 1
a488 1
addlog(const char *fmt, ...)
d490 1
a490 1
addlog(fmt, va_alist)
a494 1
	register int s;
d496 1
d498 2
a499 1
	s = splhigh();
d501 1
a501 2
	kprintf(fmt, TOLOG, NULL, ap);
	splx(s);
d503 24
a526 7
	if (!log_open) {
		va_start(ap, fmt);
		kprintf(fmt, TOCONS, NULL, ap);
		va_end(ap);
	}
	logwakeup();
	return (0);
d529 3
d534 1
a534 1
printf(const char *fmt, ...)
d536 4
a539 3
printf(fmt, va_alist)
	char *fmt;
	va_dcl
d542 1
a543 1
	register int savintr;
a544 2
	savintr = consintr;		/* disable interrupts */
	consintr = 0;
d546 1
a546 1
	kprintf(fmt, TOCONS | TOLOG, NULL, ap);
d548 2
a549 4
	if (!panicstr)
		logwakeup();
	consintr = savintr;		/* reenable interrupts */
	return (0);
a551 3
#define FLAG_LONG 	0x1
#define FLAG_QUAD	0x2

d553 4
a556 1
 * Scaled down version of printf(3).
d588 7
a594 2
 * Space or zero padding and a field width are supported for the numeric
 * formats only.
d596 39
a634 4
void
kprintf(fmt, flags, tp, ap)
	register const char *fmt;
	int flags;
d636 1
d639 38
a676 5
	register char *p, *q;
	register int ch, n;
	u_int64_t ul;
	int base, lflag, tmp, width;
	char padc;
d678 2
a679 2
	for (;;) {
		padc = ' ';
d681 12
a692 23
		while ((ch = *(const u_char *)fmt++) != '%') {
			if (ch == '\0')
				return;
			putchar(ch, flags, tp);
		}
		lflag = 0;
reswitch:	switch (ch = *(const u_char *)fmt++) {
		case '\0':
			while(*--fmt != '%')
				;
			fmt++;
			putchar('%', flags, tp);
			continue;
		case '0':
			padc = '0';
			goto reswitch;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			for (width = 0;; ++fmt) {
				width = width * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
d694 15
a708 14
			goto reswitch;
		case 'l':
			lflag |= FLAG_LONG;
			goto reswitch;
		case 'q':
			lflag |= FLAG_QUAD;
			goto reswitch;
		case 'b':
			ul = va_arg(ap, int);
			p = va_arg(ap, char *);
			for (q = ksprintn(ul, *p++, NULL); (ch = *q--) != 0;)
				putchar(ch, flags, tp);

			if (!ul)
d710 1
d712 4
a715 9
			for (tmp = 0; (n = *p++) != 0;) {
				if (ul & (1 << (n - 1))) {
					putchar(tmp ? ',' : '<', flags, tp);
					for (; (n = *p) > ' '; ++p)
						putchar(n, flags, tp);
					tmp = 1;
				} else
					for (; *p > ' '; ++p)
						continue;
d717 22
a738 25
			if (tmp)
				putchar('>', flags, tp);
			break;
		case 'c':
			putchar(va_arg(ap, int), flags, tp);
			break;
		case ':':
			p = va_arg(ap, char *);
			kprintf(p, flags, tp, va_arg(ap, va_list));
			break;
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			while ((ch = *p++) != 0)
				putchar(ch, flags, tp);
			break;
		case 'd':
			if (lflag & FLAG_QUAD)
			  ul = va_arg(ap, int64_t);
			else
			  ul = lflag & FLAG_LONG ? 
			       va_arg(ap, long) : va_arg(ap, int);
			if ((int64_t)ul < 0) {
				putchar('-', flags, tp);
				ul = -(int64_t)ul;
d740 1
a740 47
			base = 10;
			goto number;
		case 'o':
			if (lflag & FLAG_QUAD)
			  ul = va_arg(ap, u_int64_t);
			else
			  ul = lflag & FLAG_LONG ?
			       va_arg(ap, u_long) : va_arg(ap, u_int);
			base = 8;
			goto number;
		case 'u':
			if (lflag & FLAG_QUAD)
			  ul = va_arg(ap, u_int64_t);
			else
			  ul = lflag & FLAG_LONG ?
			       va_arg(ap, u_long) : va_arg(ap, u_int);
			base = 10;
			goto number;
		case 'p':
			putchar('0', flags, tp);
			putchar('x', flags, tp);
			ul = (u_long)va_arg(ap, void *);
			base = 16;
			goto number;
		case 'x':
			if (lflag & FLAG_QUAD)
			  ul = va_arg(ap, u_int64_t);
			else
			  ul = lflag & FLAG_LONG ?
			       va_arg(ap, u_long) : va_arg(ap, u_int);
			base = 16;
number:			p = ksprintn(ul, base, &tmp);
			if (width && (width -= tmp) > 0)
				while (width--)
					putchar(padc, flags, tp);
			while ((ch = *p--) != 0)
				putchar(ch, flags, tp);
			break;
		default:
			putchar('%', flags, tp);
			if (lflag & FLAG_QUAD)
				putchar('q', flags, tp);
			if (lflag & FLAG_LONG)
				putchar('l', flags, tp);
			/* FALLTHROUGH */
		case '%':
			putchar(ch, flags, tp);
a741 2
	}
}
d743 15
a757 13
/*
 * Print a character on console or users terminal.  If destination is
 * the console then the last MSGBUFS characters are saved in msgbuf for
 * inspection later.
 */
static void
putchar(c, flags, tp)
	register int c;
	int flags;
	struct tty *tp;
{
	extern int msgbufmapped;
	register struct msgbuf *mbp;
a758 23
	if (panicstr)
		constty = NULL;
	if ((flags & TOCONS) && tp == NULL && constty) {
		tp = constty;
		flags |= TOTTY;
	}
	if ((flags & TOTTY) && tp && tputchar(c, tp) < 0 &&
	    (flags & TOCONS) && tp == constty)
		constty = NULL;
	if ((flags & TOLOG) &&
	    c != '\0' && c != '\r' && c != 0177 && msgbufmapped) {
		mbp = msgbufp;
		if (mbp->msg_magic != MSG_MAGIC) {
			bzero((caddr_t)mbp, sizeof(*mbp));
			mbp->msg_magic = MSG_MAGIC;
		}
		mbp->msg_bufc[mbp->msg_bufx++] = c;
		if (mbp->msg_bufx < 0 || mbp->msg_bufx >= MSG_BSIZE)
			mbp->msg_bufx = 0;
	}
	if ((flags & TOCONS) && constty == NULL && c != '\0')
		(*v_putc)(c);
}
d760 18
a777 10
/*
 * Scaled down version of sprintf(3).
 */
int
#ifdef __STDC__
vsprintf(char *buf, const char *cfmt, va_list ap)
#else
vsprintf(buf, cfmt, ap)
	char *buf, *cfmt;
	va_list ap;
a778 7
{
	register const char *fmt = cfmt;
	register char *p, *bp;
	register int ch, base;
	u_int64_t ul;
	int lflag, tmp, width;
	char padc;
d780 42
a821 15
	for (bp = buf; ; ) {
		padc = ' ';
		width = 0;
		while ((ch = *(const u_char *)fmt++) != '%')
			if ((*bp++ = ch) == '\0')
				return ((bp - buf) - 1);

		lflag = 0;
reswitch:	switch (ch = *(const u_char *)fmt++) {
		case '\0':
			while(*--fmt != '%')
				;
			while((*bp++ = *fmt++))
				;
			return ((bp - buf) - 1);
d823 7
a829 2
			padc = '0';
			goto reswitch;
d832 16
a847 5
			for (width = 0;; ++fmt) {
				width = width * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
d849 1
a849 1
			goto reswitch;
d851 2
a852 6
			lflag |= FLAG_QUAD;
			goto reswitch;
		case 'l':
			lflag |= FLAG_LONG;
			goto reswitch;
		/* case 'b': ... break; XXX */
d854 3
a856 8
			*bp++ = va_arg(ap, int);
			break;
		/* case 'r': ... break; XXX */
		case 's':
			p = va_arg(ap, char *);
			while ((*bp++ = *p++) != 0)
				continue;
			--bp;
d858 3
d862 5
a866 8
			if (lflag & FLAG_QUAD)
			  ul = va_arg(ap, int64_t);
			else
			  ul = lflag & FLAG_LONG ?
			       va_arg(ap, long) : va_arg(ap, int);
			if ((int64_t)ul < 0) {
				*bp++ = '-';
				ul = -(int64_t)ul;
d868 1
a868 1
			base = 10;
d870 35
a904 1
			break;
d906 38
a943 7
			if (lflag & FLAG_QUAD)
			  ul = va_arg(ap, u_int64_t);
			else
			  ul = lflag & FLAG_LONG ?
			       va_arg(ap, u_long) : va_arg(ap, u_int);
			base = 8;
			goto number;
d945 3
d949 71
a1019 7
			if (lflag & FLAG_QUAD)
			  ul = va_arg(ap, u_int64_t);
			else
			  ul = lflag & FLAG_LONG ?
			       va_arg(ap, u_long) : va_arg(ap, u_int);
			base = 10;
			goto number;
d1021 11
a1031 19
		case 'p':
			*bp++ = '0';
			*bp++ = 'x';
			ul = (u_long)va_arg(ap, void *);
			base = 16;
			goto number;
		case 'x':
			if (lflag & FLAG_QUAD)
			  ul = va_arg(ap, u_int64_t);
			else
			  ul = lflag & FLAG_LONG ?
			       va_arg(ap, u_long) : va_arg(ap, u_int);
			base = 16;
number:			p = ksprintn(ul, base, &tmp);
			if (width && (width -= tmp) > 0)
				while (width--)
					*bp++ = padc;
			while ((ch = *p--) != 0)
				*bp++ = ch;
a1032 9
		default:
			*bp++ = '%';
			if (lflag & FLAG_QUAD)
				*bp++ = 'q';
			if (lflag & FLAG_LONG)
				*bp++ = 'l';
			/* FALLTHROUGH */
		case '%':
			*bp++ = ch;
a1033 2
	}
}
d1035 56
a1090 11
int
#ifdef __STDC__
sprintf(char *buf, const char *cfmt, ...)
#else
sprintf(buf, cfmt, va_alist)
	char *buf, *cfmt;
	va_dcl
#endif
{
	va_list ap;
	int ret;
d1092 2
a1093 5
	va_start(ap, cfmt);
	ret = vsprintf(buf, cfmt, ap);
	va_end(ap);
	return(ret);
}
d1095 4
a1098 20
/*
 * Put a number (base <= 16) in a buffer in reverse order; return an
 * optional length and a pointer to the NULL terminated (preceded?)
 * buffer.
 */
static char *
ksprintn(ul, base, lenp)
	register u_long ul;
	register int base, *lenp;
{					/* A long in base 8, plus NULL. */
	static char buf[sizeof(long) * NBBY / 3 + 2];
	register char *p;

	p = buf;
	do {
		*++p = "0123456789abcdef"[ul % base];
	} while (ul /= base);
	if (lenp)
		*lenp = p - buf;
	return (p);
@


1.15
log
@-Wcast-qual cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.14 1996/11/29 04:53:39 kstailey Exp $	*/
d355 3
d403 1
a403 1
	u_long ul;
d436 4
a439 1
			lflag = 1;
d477 6
a482 2
			ul = lflag ? va_arg(ap, long) : va_arg(ap, int);
			if ((long)ul < 0) {
d484 1
a484 1
				ul = -(long)ul;
d489 5
a493 1
			ul = lflag ? va_arg(ap, u_long) : va_arg(ap, u_int);
d497 5
a501 1
			ul = lflag ? va_arg(ap, u_long) : va_arg(ap, u_int);
d511 5
a515 1
			ul = lflag ? va_arg(ap, u_long) : va_arg(ap, u_int);
d526 3
a528 1
			if (lflag)
d590 1
a590 1
	u_long ul;
d621 3
d625 1
a625 1
			lflag = 1;
d639 6
a644 2
			ul = lflag ? va_arg(ap, long) : va_arg(ap, int);
			if ((long)ul < 0) {
d646 1
a646 1
				ul = -(long)ul;
d652 5
a656 1
			ul = lflag ? va_arg(ap, u_long) : va_arg(ap, u_int);
d661 5
a665 1
			ul = lflag ? va_arg(ap, u_long) : va_arg(ap, u_int);
d676 5
a680 1
			ul = lflag ? va_arg(ap, u_long) : va_arg(ap, u_int);
d691 3
a693 1
			if (lflag)
@


1.14
log
@back out bitmask_snprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.13 1996/11/24 04:29:48 niklas Exp $	*/
d407 1
a407 1
		while ((ch = *(u_char *)fmt++) != '%') {
d413 1
a413 1
reswitch:	switch (ch = *(u_char *)fmt++) {
d573 1
a573 1
		while ((ch = *(u_char *)fmt++) != '%')
d578 1
a578 1
reswitch:	switch (ch = *(u_char *)fmt++) {
@


1.13
log
@Commented out a def, only referenced in out-commented code
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.12 1996/11/24 00:42:04 kstailey Exp $	*/
a77 6
/*
 * This is the size of the buffer that should be passed to ksnprintn().
 * It's the length of a long in base 8, plus NULL.
 */
#define KSNPRINTN_BUFSIZE      (sizeof(long) * NBBY / 3 + 2)

a694 71
}


/*
 * Print a bitmask into the provided buffer, and return a pointer
 * to that buffer.
 */
char *
bitmask_snprintf(ul, p, buf, buflen)
	u_long ul;
	const char *p;
	char *buf;
	size_t buflen;
{
	char *bp, *q;
	size_t left;
	register int n;
	int ch, tmp;
	/* char snbuf[KSNPRINTN_BUFSIZE]; */

	bp = buf;
	bzero(buf, buflen);

	/*
	 * Always leave room for the trailing NULL.
	 */
	left = buflen - 1;

	/*
	 * Print the value into the buffer.  Abort if there's not
	 * enough room.
	 */
	if (buflen < KSNPRINTN_BUFSIZE)
		return (buf);

	for (q = ksprintn(ul, *p++, NULL); /* , snbuf, sizeof(snbuf)); */
	     (ch = *q--) != 0;) {
		*bp++ = ch;
		left--;
	}

	/*
	 * If the value we printed was 0, or if we don't have room for
	 * "<x>", we're done.
	 */
	if (ul == 0 || left < 3)
		return (buf);

#define PUTBYTE(b, c, l)	\
	*(b)++ = (c);		\
	if (--(l) == 0)		\
		goto out;

	for (tmp = 0; (n = *p++) != 0;) {
		if (ul & (1 << (n - 1))) {
			PUTBYTE(bp, tmp ? ',' : '<', left);
				for (; (n = *p) > ' '; ++p) {
					PUTBYTE(bp, n, left);
				}
				tmp = 1;
		} else
			for (; *p > ' '; ++p)
				continue;
	}
	if (tmp)
		*bp = '>';

#undef PUTBYTE

 out:
	return (buf);
@


1.12
log
@added bitmap_snprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.11 1996/10/19 10:02:49 niklas Exp $	*/
d719 1
a719 1
	char snbuf[KSNPRINTN_BUFSIZE];
@


1.11
log
@__assert added, impl from netbsd, however put elsewhere. use it instead
of private versions (one even using the userland header) in if_sn.c
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.10 1996/07/28 01:05:48 deraadt Exp $	*/
d78 6
d701 71
@


1.10
log
@fix vsnprintf return val
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.9 1996/07/23 23:54:19 deraadt Exp $	*/
d135 14
@


1.9
log
@make printf/addlog return 0, for compat to userland
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.8 1996/07/19 23:13:39 dm Exp $	*/
d568 1
a568 1
			while(*bp++ = *fmt++)
d570 1
a570 1
			return;
@


1.8
log
@Fixed NetBSD pr #2633 (douzzer@@mit.edu)--Be slightly more reasonable
about something like printf ("bogus format %l");
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.7 1996/07/02 06:51:59 niklas Exp $	*/
d292 1
a292 1
void
d315 1
d318 1
a318 1
void
d338 1
@


1.7
log
@-Wall & -Wstrict-prototype fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.6 1996/06/26 20:39:21 dm Exp $	*/
d398 6
d563 6
@


1.6
log
@expand %d is panicstr
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.5 1996/05/02 13:12:20 deraadt Exp $	*/
d117 1
a117 1
		vsprintf (panicbuf, fmt, ap);
d641 4
a644 4
	va_start (ap, cfmt);
	ret = vsprintf (buf, cfmt, ap);
	va_end (ap);
	return (ret);
@


1.5
log
@sync syscalls, no sys/cpu.h
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_prf.c,v 1.4 1996/04/21 22:27:19 deraadt Exp $	*/
d108 1
d113 1
d116 4
a119 2
	else
		panicstr = fmt;
a120 1
	va_start(ap, fmt);
d534 1
a534 1
sprintf(char *buf, const char *cfmt, ...)
d536 1
a536 1
sprintf(buf, cfmt, va_alist)
d538 1
a538 1
	va_dcl
a545 1
	va_list ap;
a547 1
	va_start(ap, cfmt);
d627 18
a644 1
	va_end(ap);
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: subr_prf.c,v 1.3 1996/04/19 16:09:03 niklas Exp $	*/
/*	$NetBSD: subr_prf.c,v 1.24 1996/03/30 22:25:18 christos Exp $	*/
a57 1
#include <sys/cpu.h>
@


1.3
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: subr_prf.c,v 1.22 1996/03/14 19:01:11 christos Exp $	*/
d58 1
a99 4
#ifdef __GNUC__
volatile void boot(int flags);	/* boot() does not return */
volatile			/* panic() does not return */
#endif
a110 1
	static const char fm[] = "panic: %r\n";
d119 1
a119 1
	printf(fm, fmt, ap);
d359 1
a359 1
 * The format %r passes an additional format string and argument list
d366 1
a366 1
 *	printf("prefix: %r: suffix\n", fmt, ap);
d436 1
a436 1
		case 'r':
@


1.2
log
@From NetBSD: Merge with NetBSD 960217
@
text
@d1 2
a2 1
/*	$NetBSD: subr_prf.c,v 1.21 1996/02/09 19:00:01 christos Exp $	*/
d69 3
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: subr_prf.c,v 1.19 1995/06/16 10:52:17 cgd Exp $	*/
d58 2
d76 1
a76 2
extern	cnputc();			/* standard console putc */
int	(*v_putc)() = cnputc;		/* routine to putc on virtual console */
d78 3
a80 3
static void  putchar __P((int ch, int flags, struct tty *tp));
static char *ksprintn __P((u_long num, int base, int *len));
void kprintf __P((const char *fmt, int flags, struct tty *tp, va_list ap));
d105 1
d110 1
d119 1
a119 1
	printf("panic: %r\n", fmt, ap);
d157 1
d202 1
d233 1
d257 1
d285 1
a285 1
	for (p = ksprintn((u_long)level, 10, NULL); ch = *p--;)
d296 1
d321 1
d414 1
a414 1
			for (q = ksprintn(ul, *p++, NULL); ch = *q--;)
d420 1
a420 1
			for (tmp = 0; n = *p++;) {
d443 1
a443 1
			while (ch = *p++)
d475 1
a475 1
			while (ch = *p--)
d530 1
d536 1
d579 1
a579 1
			while (*bp++ = *p++)
d615 1
a615 1
			while (ch = *p--)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
