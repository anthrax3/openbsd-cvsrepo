head	1.67;
access;
symbols
	OPENBSD_6_1_BASE:1.67
	OPENBSD_6_0:1.65.0.2
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.63.0.4
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.63.0.6
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.60.0.4
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.56.0.6
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.56.0.2
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.55.0.2
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.54.0.2
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.2
	OPENBSD_5_0:1.50.0.2
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.46.0.4
	OPENBSD_4_9_BASE:1.46
	OPENBSD_4_8:1.46.0.2
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.39.0.4
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.30.0.4
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.28.0.6
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.4
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.26.0.10
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.8
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.6
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.20.0.4
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.21
	UBC:1.18.0.4
	UBC_BASE:1.18
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.12
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.10
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.8
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.6
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.67
date	2016.11.07.00.26.32;	author guenther;	state Exp;
branches;
next	1.66;
commitid	W7ztnDZwvjCaeQTS;

1.66
date	2016.09.02.18.11.28;	author tedu;	state Exp;
branches;
next	1.65;
commitid	rTRs82DQAsJjej88;

1.65
date	2016.03.30.07.49.11;	author guenther;	state Exp;
branches;
next	1.64;
commitid	CEQ2oOx0iodZAOMX;

1.64
date	2016.03.29.16.53.49;	author guenther;	state Exp;
branches;
next	1.63;
commitid	PFAolSpir2sbOZuU;

1.63
date	2015.03.02.20.46.50;	author guenther;	state Exp;
branches;
next	1.62;
commitid	zq3ATDtt3EFolfIj;

1.62
date	2015.01.17.17.49.26;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	buV4jzMNnBVDajYs;

1.61
date	2014.09.17.19.26.06;	author millert;	state Exp;
branches;
next	1.60;
commitid	yJt5bEm99YJcufDq;

1.60
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.59;

1.59
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2014.03.24.03.48.00;	author guenther;	state Exp;
branches;
next	1.57;

1.57
date	2014.03.24.00.19.48;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2013.04.06.03.44.34;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2012.10.01.00.08.42;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2012.04.12.10.11.41;	author mikeb;	state Exp;
branches;
next	1.53;

1.53
date	2012.04.10.15.50.52;	author guenther;	state Exp;
branches;
next	1.52;

1.52
date	2012.02.20.22.23.39;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2011.10.15.23.35.29;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2011.07.25.20.32.06;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2011.07.07.18.08.36;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2011.04.04.13.00.13;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2011.04.02.17.04.35;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2010.07.01.02.41.12;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2010.06.29.19.09.11;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2010.06.29.00.28.14;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.28.23.00.30;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.28.19.23.06;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.02.20.03.59;	author guenther;	state Exp;
branches
	1.39.4.1;
next	1.38;

1.38
date	2008.12.16.07.57.28;	author guenther;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2008.11.01.05.59.21;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.31.17.17.04;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2008.10.31.17.15.30;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.14.18.27.29;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.10.14.35.06;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.09.06.34.10;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2008.05.22.21.27.40;	author thib;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.03.08.05.43;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.03.18.09.08;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.28.00.14.29;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.01.18.06.03;	author henning;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.30.03.29.49;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.30.20.02.58;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.15.01.27.31;	author nordin;	state Exp;
branches;
next	1.20;

1.20
date	2002.01.23.15.46.48;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.12.22.56.55;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.22.23.55.24;	author art;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	2001.06.22.14.14.09;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.19.07.54.37;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.18.13.18.36;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.08.21.27.03;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.12.17.30.45;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	97.11.17.05.57.45;	author deraadt;	state Exp;
branches
	1.12.10.1;
next	1.11;

1.11
date	97.11.13.07.11.11;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.09.02.08.48.32;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.05.30.21.43.34;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.03.29.08.58.03;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.10.27.04.51.37;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.10.26.07.29.40;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.10.02.20.22.14;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.25.09.51.37;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.01.05.26.02;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.19.52;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches;
next	;

1.12.10.1
date	2001.05.14.22.32.41;	author niklas;	state Exp;
branches;
next	1.12.10.2;

1.12.10.2
date	2001.07.04.10.48.24;	author niklas;	state Exp;
branches;
next	1.12.10.3;

1.12.10.3
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.12.10.4;

1.12.10.4
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.12.10.5;

1.12.10.5
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.12.10.6;

1.12.10.6
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	;

1.18.4.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.18.4.3;

1.18.4.3
date	2003.05.19.22.31.10;	author tedu;	state Exp;
branches;
next	;

1.38.2.1
date	2010.01.29.21.33.30;	author sthen;	state Exp;
branches;
next	;

1.39.4.1
date	2010.01.29.21.33.13;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.67
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@/*	$OpenBSD: kern_prot.c,v 1.66 2016/09/02 18:11:28 tedu Exp $	*/
/*	$NetBSD: kern_prot.c,v 1.33 1996/02/09 18:59:42 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1990, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_prot.c	8.6 (Berkeley) 1/21/94
 */

/*
 * System calls related to processes and protection
 */

#include <sys/param.h>
#include <sys/acct.h>
#include <sys/systm.h>
#include <sys/ucred.h>
#include <sys/proc.h>
#include <sys/filedesc.h>
#include <sys/pool.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#ifdef	__HAVE_MD_TCB
# include <machine/tcb.h>
#endif

inline void
crset(struct ucred *newcr, const struct ucred *cr)
{
	KASSERT(cr->cr_ref > 0);
	memcpy(
	    (char *)newcr    + offsetof(struct ucred, cr_startcopy),
	    (const char *)cr + offsetof(struct ucred, cr_startcopy),
	    sizeof(*cr)      - offsetof(struct ucred, cr_startcopy));
}

int
sys_getpid(struct proc *p, void *v, register_t *retval)
{

	*retval = p->p_p->ps_pid;
	return (0);
}

int
sys_getthrid(struct proc *p, void *v, register_t *retval)
{

	*retval = p->p_tid + THREAD_PID_OFFSET;
	return (0);
}

int
sys_getppid(struct proc *p, void *v, register_t *retval)
{

	*retval = p->p_p->ps_pptr->ps_pid;
	return (0);
}

/* Get process group ID; note that POSIX getpgrp takes no parameter */
int
sys_getpgrp(struct proc *p, void *v, register_t *retval)
{

	*retval = p->p_p->ps_pgrp->pg_id;
	return (0);
}

/*
 * SysVR.4 compatible getpgid()
 */
int
sys_getpgid(struct proc *curp, void *v, register_t *retval)
{
	struct sys_getpgid_args /* {
		syscallarg(pid_t) pid;
	} */ *uap = v;
	struct process *targpr = curp->p_p;

	if (SCARG(uap, pid) == 0 || SCARG(uap, pid) == targpr->ps_pid)
		goto found;
	if ((targpr = prfind(SCARG(uap, pid))) == NULL)
		return (ESRCH);
	if (targpr->ps_session != curp->p_p->ps_session)
		return (EPERM);
found:
	*retval = targpr->ps_pgid;
	return (0);
}

int
sys_getsid(struct proc *curp, void *v, register_t *retval)
{
	struct sys_getsid_args /* {
		syscallarg(pid_t) pid;
	} */ *uap = v;
	struct process *targpr = curp->p_p;

	if (SCARG(uap, pid) == 0 || SCARG(uap, pid) == targpr->ps_pid)
		goto found;
	if ((targpr = prfind(SCARG(uap, pid))) == NULL)
		return (ESRCH);
	if (targpr->ps_session != curp->p_p->ps_session)
		return (EPERM);
found:
	/* Skip exiting processes */
	if (targpr->ps_pgrp->pg_session->s_leader == NULL)
		return (ESRCH);
	*retval = targpr->ps_pgrp->pg_session->s_leader->ps_pid;
	return (0);
}

int
sys_getuid(struct proc *p, void *v, register_t *retval)
{

	*retval = p->p_ucred->cr_ruid;
	return (0);
}

int
sys_geteuid(struct proc *p, void *v, register_t *retval)
{

	*retval = p->p_ucred->cr_uid;
	return (0);
}

int
sys_issetugid(struct proc *p, void *v, register_t *retval)
{
	if (p->p_p->ps_flags & PS_SUGIDEXEC)
		*retval = 1;
	else
		*retval = 0;
	return (0);
}

int
sys_getgid(struct proc *p, void *v, register_t *retval)
{

	*retval = p->p_ucred->cr_rgid;
	return (0);
}

/*
 * Get effective group ID.  The "egid" is groups[0], and could be obtained
 * via getgroups.  This syscall exists because it is somewhat painful to do
 * correctly in a library function.
 */
int
sys_getegid(struct proc *p, void *v, register_t *retval)
{

	*retval = p->p_ucred->cr_gid;
	return (0);
}

int
sys_getgroups(struct proc *p, void *v, register_t *retval)
{
	struct sys_getgroups_args /* {
		syscallarg(int) gidsetsize;
		syscallarg(gid_t *) gidset;
	} */ *uap = v;
	struct ucred *uc = p->p_ucred;
	u_int ngrp;
	int error;

	if ((ngrp = SCARG(uap, gidsetsize)) == 0) {
		*retval = uc->cr_ngroups;
		return (0);
	}
	if (ngrp < uc->cr_ngroups)
		return (EINVAL);
	ngrp = uc->cr_ngroups;
	error = copyout(uc->cr_groups, SCARG(uap, gidset),
	    ngrp * sizeof(gid_t));
	if (error)
		return (error);
	*retval = ngrp;
	return (0);
}

int
sys_setsid(struct proc *p, void *v, register_t *retval)
{
	struct session *newsess;
	struct pgrp *newpgrp;
	struct process *pr = p->p_p;
	pid_t pid = pr->ps_pid;

	newsess = pool_get(&session_pool, PR_WAITOK);
	timeout_set(&newsess->s_verauthto, zapverauth, newsess);
	newpgrp = pool_get(&pgrp_pool, PR_WAITOK);

	if (pr->ps_pgid == pid || pgfind(pid)) {
		pool_put(&pgrp_pool, newpgrp);
		pool_put(&session_pool, newsess);
		return (EPERM);
	} else {
		(void) enterpgrp(pr, pid, newpgrp, newsess);
		*retval = pid;
		return (0);
	}
}

/*
 * set process group (setpgid/old setpgrp)
 *
 * caller does setpgid(targpid, targpgid)
 *
 * pid must be caller or child of caller (ESRCH)
 * if a child
 *	pid must be in same session (EPERM)
 *	pid can't have done an exec (EACCES)
 * if pgid != pid
 * 	there must exist some pid in same session having pgid (EPERM)
 * pid must not be session leader (EPERM)
 */
int
sys_setpgid(struct proc *curp, void *v, register_t *retval)
{
	struct sys_setpgid_args /* {
		syscallarg(pid_t) pid;
		syscallarg(pid_t) pgid;
	} */ *uap = v;
	struct process *curpr = curp->p_p;
	struct process *targpr;		/* target process */
	struct pgrp *pgrp, *newpgrp;	/* target pgrp */
	pid_t pid, pgid;
	int error;

	pid = SCARG(uap, pid);
	pgid = SCARG(uap, pgid);

	if (pgid < 0)
		return (EINVAL);

	newpgrp = pool_get(&pgrp_pool, PR_WAITOK);

	if (pid != 0 && pid != curpr->ps_pid) {
		if ((targpr = prfind(pid)) == 0 || !inferior(targpr, curpr)) {
			error = ESRCH;
			goto out;
		}
		if (targpr->ps_session != curpr->ps_session) {
			error = EPERM;
			goto out;
		}
		if (targpr->ps_flags & PS_EXEC) {
			error = EACCES;
			goto out;
		}
	} else
		targpr = curpr;
	if (SESS_LEADER(targpr)) {
		error = EPERM;
		goto out;
	}
	if (pgid == 0)
		pgid = targpr->ps_pid;
	else if (pgid != targpr->ps_pid)
		if ((pgrp = pgfind(pgid)) == 0 ||
		    pgrp->pg_session != curpr->ps_session) {
			error = EPERM;
			goto out;
		}
	return (enterpgrp(targpr, pgid, newpgrp, NULL));
out:
	pool_put(&pgrp_pool, newpgrp);
	return (error);
}

int
sys_getresuid(struct proc *p, void *v, register_t *retval)
{
	struct sys_getresuid_args /* {
		syscallarg(uid_t *) ruid;
		syscallarg(uid_t *) euid;
		syscallarg(uid_t *) suid;
	} */ *uap = v;
	struct ucred *uc = p->p_ucred;
	uid_t *ruid, *euid, *suid;
	int error1 = 0, error2 = 0, error3 = 0;

	ruid = SCARG(uap, ruid);
	euid = SCARG(uap, euid);
	suid = SCARG(uap, suid);

	if (ruid != NULL)
		error1 = copyout(&uc->cr_ruid, ruid, sizeof(*ruid));
	if (euid != NULL)
		error2 = copyout(&uc->cr_uid, euid, sizeof(*euid));
	if (suid != NULL)
		error3 = copyout(&uc->cr_svuid, suid, sizeof(*suid));

	return (error1 ? error1 : error2 ? error2 : error3);
}

int
sys_setresuid(struct proc *p, void *v, register_t *retval)
{
	struct sys_setresuid_args /* {
		syscallarg(uid_t) ruid;
		syscallarg(uid_t) euid;
		syscallarg(uid_t) suid;
	} */ *uap = v;
	struct process *pr = p->p_p;
	struct ucred *pruc, *newcred, *uc = p->p_ucred;
	uid_t ruid, euid, suid;
	int error;

	ruid = SCARG(uap, ruid);
	euid = SCARG(uap, euid);
	suid = SCARG(uap, suid);

	/*
	 * make permission checks against the thread's ucred,
	 * but the actual changes will be to the process's ucred
	 */
	pruc = pr->ps_ucred;
	if ((ruid == (uid_t)-1 || ruid == pruc->cr_ruid) &&
	    (euid == (uid_t)-1 || euid == pruc->cr_uid) &&
	    (suid == (uid_t)-1 || suid == pruc->cr_svuid))
		return (0);			/* no change */

	/*
	 * Any of the real, effective, and saved uids may be changed
	 * to the current value of one of the three (root is not limited).
	 */
	if (ruid != (uid_t)-1 &&
	    ruid != uc->cr_ruid &&
	    ruid != uc->cr_uid &&
	    ruid != uc->cr_svuid &&
	    (error = suser(p, 0)))
		return (error);

	if (euid != (uid_t)-1 &&
	    euid != uc->cr_ruid &&
	    euid != uc->cr_uid &&
	    euid != uc->cr_svuid &&
	    (error = suser(p, 0)))
		return (error);

	if (suid != (uid_t)-1 &&
	    suid != uc->cr_ruid &&
	    suid != uc->cr_uid &&
	    suid != uc->cr_svuid &&
	    (error = suser(p, 0)))
		return (error);

	/*
	 * Copy credentials so other references do not see our changes.
	 * ps_ucred may change during the crget().
	 */
	newcred = crget();
	pruc = pr->ps_ucred;
	crset(newcred, pruc);

	/*
	 * Note that unlike the other set*uid() calls, each
	 * uid type is set independently of the others.
	 */
	if (ruid != (uid_t)-1)
		newcred->cr_ruid = ruid;
	if (euid != (uid_t)-1)
		newcred->cr_uid = euid;
	if (suid != (uid_t)-1)
		newcred->cr_svuid = suid;
	pr->ps_ucred = newcred;
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);

	/* now that we can sleep, transfer proc count to new user */
	if (ruid != (uid_t)-1 && ruid != pruc->cr_ruid) {
		chgproccnt(pruc->cr_ruid, -1);
		chgproccnt(ruid, 1);
	}
	crfree(pruc);

	return (0);
}

int
sys_getresgid(struct proc *p, void *v, register_t *retval)
{
	struct sys_getresgid_args /* {
		syscallarg(gid_t *) rgid;
		syscallarg(gid_t *) egid;
		syscallarg(gid_t *) sgid;
	} */ *uap = v;
	struct ucred *uc = p->p_ucred;
	gid_t *rgid, *egid, *sgid;
	int error1 = 0, error2 = 0, error3 = 0;

	rgid = SCARG(uap, rgid);
	egid = SCARG(uap, egid);
	sgid = SCARG(uap, sgid);

	if (rgid != NULL)
		error1 = copyout(&uc->cr_rgid, rgid, sizeof(*rgid));
	if (egid != NULL)
		error2 = copyout(&uc->cr_gid, egid, sizeof(*egid));
	if (sgid != NULL)
		error3 = copyout(&uc->cr_svgid, sgid, sizeof(*sgid));

	return (error1 ? error1 : error2 ? error2 : error3);
}

int
sys_setresgid(struct proc *p, void *v, register_t *retval)
{
	struct sys_setresgid_args /* {
		syscallarg(gid_t) rgid;
		syscallarg(gid_t) egid;
		syscallarg(gid_t) sgid;
	} */ *uap = v;
	struct process *pr = p->p_p;
	struct ucred *pruc, *newcred, *uc = p->p_ucred;
	gid_t rgid, egid, sgid;
	int error;

	rgid = SCARG(uap, rgid);
	egid = SCARG(uap, egid);
	sgid = SCARG(uap, sgid);

	/*
	 * make permission checks against the thread's ucred,
	 * but the actual changes will be to the process's ucred
	 */
	pruc = pr->ps_ucred;
	if ((rgid == (gid_t)-1 || rgid == pruc->cr_rgid) &&
	    (egid == (gid_t)-1 || egid == pruc->cr_gid) &&
	    (sgid == (gid_t)-1 || sgid == pruc->cr_svgid))
		return (0);			/* no change */

	/*
	 * Any of the real, effective, and saved gids may be changed
	 * to the current value of one of the three (root is not limited).
	 */
	if (rgid != (gid_t)-1 &&
	    rgid != uc->cr_rgid &&
	    rgid != uc->cr_gid &&
	    rgid != uc->cr_svgid &&
	    (error = suser(p, 0)))
		return (error);

	if (egid != (gid_t)-1 &&
	    egid != uc->cr_rgid &&
	    egid != uc->cr_gid &&
	    egid != uc->cr_svgid &&
	    (error = suser(p, 0)))
		return (error);

	if (sgid != (gid_t)-1 &&
	    sgid != uc->cr_rgid &&
	    sgid != uc->cr_gid &&
	    sgid != uc->cr_svgid &&
	    (error = suser(p, 0)))
		return (error);

	/*
	 * Copy credentials so other references do not see our changes.
	 * ps_ucred may change during the crget().
	 */
	newcred = crget();
	pruc = pr->ps_ucred;
	crset(newcred, pruc);

	/*
	 * Note that unlike the other set*gid() calls, each
	 * gid type is set independently of the others.
	 */
	if (rgid != (gid_t)-1)
		newcred->cr_rgid = rgid;
	if (egid != (gid_t)-1)
		newcred->cr_gid = egid;
	if (sgid != (gid_t)-1)
		newcred->cr_svgid = sgid;
	pr->ps_ucred = newcred;
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);
	crfree(pruc);
	return (0);
}

int
sys_setregid(struct proc *p, void *v, register_t *retval)
{
	struct sys_setregid_args /* {
		syscallarg(gid_t) rgid;
		syscallarg(gid_t) egid;
	} */ *uap = v;
	struct process *pr = p->p_p;
	struct ucred *pruc, *newcred, *uc = p->p_ucred;
	gid_t rgid, egid;
	int error;

	rgid = SCARG(uap, rgid);
	egid = SCARG(uap, egid);

	/*
	 * make permission checks against the thread's ucred,
	 * but the actual changes will be to the process's ucred
	 *
	 * The saved gid check here is complicated: we reset the
	 * saved gid to the real gid if the real gid is specified
	 * *and* either it's changing _or_ the saved gid won't equal
	 * the effective gid.  So, the svgid *won't* change when
	 * the rgid isn't specified or when the rgid isn't changing
	 * and the svgid equals the requested egid.
	 */
	pruc = pr->ps_ucred;
	if ((rgid == (gid_t)-1 || rgid == pruc->cr_rgid) &&
	    (egid == (gid_t)-1 || egid == pruc->cr_gid) &&
	    (rgid == (gid_t)-1 || (rgid == pruc->cr_rgid &&
	    pruc->cr_svgid == (egid != (gid_t)-1 ? egid : pruc->cr_gid))))
		return (0);			/* no change */

	/*
	 * Any of the real, effective, and saved gids may be changed
	 * to the current value of one of the three (root is not limited).
	 */
	if (rgid != (gid_t)-1 &&
	    rgid != uc->cr_rgid &&
	    rgid != uc->cr_gid &&
	    rgid != uc->cr_svgid &&
	    (error = suser(p, 0)))
		return (error);

	if (egid != (gid_t)-1 &&
	    egid != uc->cr_rgid &&
	    egid != uc->cr_gid &&
	    egid != uc->cr_svgid &&
	    (error = suser(p, 0)))
		return (error);

	/*
	 * Copy credentials so other references do not see our changes.
	 * ps_ucred may change during the crget().
	 */
	newcred = crget();
	pruc = pr->ps_ucred;
	crset(newcred, pruc);

	if (rgid != (gid_t)-1)
		newcred->cr_rgid = rgid;
	if (egid != (gid_t)-1)
		newcred->cr_gid = egid;

	/*
	 * The saved gid presents a bit of a dilemma, as it did not
	 * exist when setregid(2) was conceived.  We only set the saved
	 * gid when the real gid is specified and either its value would
	 * change, or where the saved and effective gids are different.
	 */
	if (rgid != (gid_t)-1 && (rgid != pruc->cr_rgid ||
	    pruc->cr_svgid != (egid != (gid_t)-1 ? egid : pruc->cr_gid)))
		newcred->cr_svgid = rgid;
	pr->ps_ucred = newcred;
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);
	crfree(pruc);
	return (0);
}

int
sys_setreuid(struct proc *p, void *v, register_t *retval)
{
	struct sys_setreuid_args /* {
		syscallarg(uid_t) ruid;
		syscallarg(uid_t) euid;
	} */ *uap = v;
	struct process *pr = p->p_p;
	struct ucred *pruc, *newcred, *uc = p->p_ucred;
	uid_t ruid, euid;
	int error;

	ruid = SCARG(uap, ruid);
	euid = SCARG(uap, euid);

	/*
	 * make permission checks against the thread's ucred,
	 * but the actual changes will be to the process's ucred
	 *
	 * The saved uid check here is complicated: we reset the
	 * saved uid to the real uid if the real uid is specified
	 * *and* either it's changing _or_ the saved uid won't equal
	 * the effective uid.  So, the svuid *won't* change when
	 * the ruid isn't specified or when the ruid isn't changing
	 * and the svuid equals the requested euid.
	 */
	pruc = pr->ps_ucred;
	if ((ruid == (uid_t)-1 || ruid == pruc->cr_ruid) &&
	    (euid == (uid_t)-1 || euid == pruc->cr_uid) &&
	    (ruid == (uid_t)-1 || (ruid == pruc->cr_ruid &&
	    pruc->cr_svuid == (euid != (uid_t)-1 ? euid : pruc->cr_uid))))
		return (0);			/* no change */

	/*
	 * Any of the real, effective, and saved uids may be changed
	 * to the current value of one of the three (root is not limited).
	 */
	if (ruid != (uid_t)-1 &&
	    ruid != uc->cr_ruid &&
	    ruid != uc->cr_uid &&
	    ruid != uc->cr_svuid &&
	    (error = suser(p, 0)))
		return (error);

	if (euid != (uid_t)-1 &&
	    euid != uc->cr_ruid &&
	    euid != uc->cr_uid &&
	    euid != uc->cr_svuid &&
	    (error = suser(p, 0)))
		return (error);

	/*
	 * Copy credentials so other references do not see our changes.
	 * ps_ucred may change during the crget().
	 */
	newcred = crget();
	pruc = pr->ps_ucred;
	crset(newcred, pruc);

	if (ruid != (uid_t)-1)
		newcred->cr_ruid = ruid;
	if (euid != (uid_t)-1)
		newcred->cr_uid = euid;

	/*
	 * The saved uid presents a bit of a dilemma, as it did not
	 * exist when setreuid(2) was conceived.  We only set the saved
	 * uid when the real uid is specified and either its value would
	 * change, or where the saved and effective uids are different.
	 */
	if (ruid != (uid_t)-1 && (ruid != pruc->cr_ruid ||
	    pruc->cr_svuid != (euid != (uid_t)-1 ? euid : pruc->cr_uid)))
		newcred->cr_svuid = ruid;
	pr->ps_ucred = newcred;
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);

	/* now that we can sleep, transfer proc count to new user */
	if (ruid != (uid_t)-1 && ruid != pruc->cr_ruid) {
		chgproccnt(pruc->cr_ruid, -1);
		chgproccnt(ruid, 1);
	}
	crfree(pruc);

	return (0);
}

int
sys_setuid(struct proc *p, void *v, register_t *retval)
{
	struct sys_setuid_args /* {
		syscallarg(uid_t) uid;
	} */ *uap = v;
	struct process *pr = p->p_p;
	struct ucred *pruc, *newcred, *uc = p->p_ucred;
	uid_t uid;
	int did_real, error;

	uid = SCARG(uap, uid);

	pruc = pr->ps_ucred;
	if (pruc->cr_uid == uid &&
	    pruc->cr_ruid == uid &&
	    pruc->cr_svuid == uid)
		return (0);

	if (uid != uc->cr_ruid &&
	    uid != uc->cr_svuid &&
	    uid != uc->cr_uid &&
	    (error = suser(p, 0)))
		return (error);

	/*
	 * Copy credentials so other references do not see our changes.
	 * ps_ucred may change during the crget().
	 */
	newcred = crget();
	pruc = pr->ps_ucred;
	crset(newcred, pruc);

	/*
	 * Everything's okay, do it.
	 */
	if (uid == pruc->cr_uid || suser(p, 0) == 0) {
		did_real = 1;
		newcred->cr_ruid = uid;
		newcred->cr_svuid = uid;
	} else
		did_real = 0;
	newcred->cr_uid = uid;
	pr->ps_ucred = newcred;
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);

	/*
	 * Transfer proc count to new user.
	 */
	if (did_real && uid != pruc->cr_ruid) {
		chgproccnt(pruc->cr_ruid, -1);
		chgproccnt(uid, 1);
	}
	crfree(pruc);

	return (0);
}

int
sys_seteuid(struct proc *p, void *v, register_t *retval)
{
	struct sys_seteuid_args /* {
		syscallarg(uid_t) euid;
	} */ *uap = v;
	struct process *pr = p->p_p;
	struct ucred *pruc, *newcred, *uc = p->p_ucred;
	uid_t euid;
	int error;

	euid = SCARG(uap, euid);

	if (pr->ps_ucred->cr_uid == euid)
		return (0);

	if (euid != uc->cr_ruid && euid != uc->cr_svuid &&
	    (error = suser(p, 0)))
		return (error);

	/*
	 * Copy credentials so other references do not see our changes.
	 * ps_ucred may change during the crget().
	 */
	newcred = crget();
	pruc = pr->ps_ucred;
	crset(newcred, pruc);
	newcred->cr_uid = euid;
	pr->ps_ucred = newcred;
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);
	crfree(pruc);
	return (0);
}

int
sys_setgid(struct proc *p, void *v, register_t *retval)
{
	struct sys_setgid_args /* {
		syscallarg(gid_t) gid;
	} */ *uap = v;
	struct process *pr = p->p_p;
	struct ucred *pruc, *newcred, *uc = p->p_ucred;
	gid_t gid;
	int error;

	gid = SCARG(uap, gid);

	pruc = pr->ps_ucred;
	if (pruc->cr_gid == gid &&
	    pruc->cr_rgid == gid &&
	    pruc->cr_svgid == gid)
		return (0);

	if (gid != uc->cr_rgid &&
	    gid != uc->cr_svgid &&
	    gid != uc->cr_gid &&
	    (error = suser(p, 0)))
		return (error);

	/*
	 * Copy credentials so other references do not see our changes.
	 * ps_ucred may change during the crget().
	 */
	newcred = crget();
	pruc = pr->ps_ucred;
	crset(newcred, pruc);

	if (gid == pruc->cr_gid || suser(p, 0) == 0) {
		newcred->cr_rgid = gid;
		newcred->cr_svgid = gid;
	}
	newcred->cr_gid = gid;
	pr->ps_ucred = newcred;
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);
	crfree(pruc);
	return (0);
}

int
sys_setegid(struct proc *p, void *v, register_t *retval)
{
	struct sys_setegid_args /* {
		syscallarg(gid_t) egid;
	} */ *uap = v;
	struct process *pr = p->p_p;
	struct ucred *pruc, *newcred, *uc = p->p_ucred;
	gid_t egid;
	int error;

	egid = SCARG(uap, egid);

	if (pr->ps_ucred->cr_gid == egid)
		return (0);

	if (egid != uc->cr_rgid && egid != uc->cr_svgid &&
	    (error = suser(p, 0)))
		return (error);

	/*
	 * Copy credentials so other references do not see our changes.
	 * ps_ucred may change during the crget().
	 */
	newcred = crget();
	pruc = pr->ps_ucred;
	crset(newcred, pruc);
	newcred->cr_gid = egid;
	pr->ps_ucred = newcred;
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);
	crfree(pruc);
	return (0);
}

int
sys_setgroups(struct proc *p, void *v, register_t *retval)
{
	struct sys_setgroups_args /* {
		syscallarg(int) gidsetsize;
		syscallarg(const gid_t *) gidset;
	} */ *uap = v;
	struct process *pr = p->p_p;
	struct ucred *pruc, *newcred;
	gid_t groups[NGROUPS_MAX];
	u_int ngrp;
	int error;

	if ((error = suser(p, 0)) != 0)
		return (error);
	ngrp = SCARG(uap, gidsetsize);
	if (ngrp > NGROUPS_MAX)
		return (EINVAL);
	error = copyin(SCARG(uap, gidset), groups, ngrp * sizeof(gid_t));
	if (error == 0) {
		newcred = crget();
		pruc = pr->ps_ucred;
		crset(newcred, pruc);
		memcpy(newcred->cr_groups, groups, ngrp * sizeof(gid_t));
		newcred->cr_ngroups = ngrp;
		pr->ps_ucred = newcred;
		atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);
		crfree(pruc);
	}
	return (error);
}

/*
 * Check if gid is a member of the group set.
 */
int
groupmember(gid_t gid, struct ucred *cred)
{
	gid_t *gp;
	gid_t *egp;

	if (cred->cr_gid == gid)
		return (1);
	egp = &(cred->cr_groups[cred->cr_ngroups]);
	for (gp = cred->cr_groups; gp < egp; gp++)
		if (*gp == gid)
			return (1);
	return (0);
}

/*
 * Test whether this process has special user powers.
 * Returns 0 or error.
 */
int
suser(struct proc *p, u_int flags)
{
	struct ucred *cred = p->p_ucred;

	if (cred->cr_uid == 0) {
		if (!(flags & SUSER_NOACCT))
			p->p_p->ps_acflag |= ASU;
		return (0);
	}
	return (EPERM);
}

/*
 * replacement for old suser, for callers who don't have a process
 */
int
suser_ucred(struct ucred *cred)
{
	if (cred->cr_uid == 0)
		return (0);
	return (EPERM);
}

/*
 * Allocate a zeroed cred structure.
 */
struct ucred *
crget(void)
{
	struct ucred *cr;

	cr = pool_get(&ucred_pool, PR_WAITOK|PR_ZERO);
	cr->cr_ref = 1;
	return (cr);
}

/*
 * Free a cred structure.
 * Throws away space when ref count gets to 0.
 */
void
crfree(struct ucred *cr)
{

	if (--cr->cr_ref == 0)
		pool_put(&ucred_pool, cr);
}

/*
 * Copy cred structure to a new one and free the old one.
 */
struct ucred *
crcopy(struct ucred *cr)
{
	struct ucred *newcr;

	if (cr->cr_ref == 1)
		return (cr);
	newcr = crget();
	*newcr = *cr;
	crfree(cr);
	newcr->cr_ref = 1;
	return (newcr);
}

/*
 * Dup cred struct to a new held one.
 */
struct ucred *
crdup(struct ucred *cr)
{
	struct ucred *newcr;

	newcr = crget();
	*newcr = *cr;
	newcr->cr_ref = 1;
	return (newcr);
}

/*
 * Convert the userspace xucred to a kernel ucred
 */
int
crfromxucred(struct ucred *cr, const struct xucred *xcr)
{
	if (xcr->cr_ngroups < 0 || xcr->cr_ngroups > NGROUPS_MAX)
		return (EINVAL);
	cr->cr_ref = 1;
	cr->cr_uid = xcr->cr_uid;
	cr->cr_gid = xcr->cr_gid;
	cr->cr_ngroups = xcr->cr_ngroups;
	memcpy(cr->cr_groups, xcr->cr_groups,
	    sizeof(cr->cr_groups[0]) * xcr->cr_ngroups);
	return (0);
}

/*
 * Get login name, if available.
 */
int
sys_getlogin59(struct proc *p, void *v, register_t *retval)
{
	struct sys_getlogin59_args /* {
		syscallarg(char *) namebuf;
		syscallarg(u_int) namelen;
	} */ *uap = v;
	struct session *s = p->p_p->ps_pgrp->pg_session;

	if (SCARG(uap, namelen) > sizeof(s->s_login))
		SCARG(uap, namelen) = sizeof(s->s_login);
	return (copyout((caddr_t)s->s_login,
	    (caddr_t)SCARG(uap, namebuf), SCARG(uap, namelen)));
}

/*
 * Get login name, if available.
 */
int
sys_getlogin_r(struct proc *p, void *v, register_t *retval)
{
	struct sys_getlogin_r_args /* {
		syscallarg(char *) namebuf;
		syscallarg(size_t) namelen;
	} */ *uap = v;
	size_t namelen = SCARG(uap, namelen);
	struct session *s = p->p_p->ps_pgrp->pg_session;
	int error;

	if (namelen > sizeof(s->s_login))
		namelen = sizeof(s->s_login);
	error = copyoutstr(s->s_login, SCARG(uap, namebuf), namelen, NULL);
	if (error == ENAMETOOLONG)
		error = ERANGE;
	*retval = error;
	return (0);
}

/*
 * Set login name.
 */
int
sys_setlogin(struct proc *p, void *v, register_t *retval)
{
	struct sys_setlogin_args /* {
		syscallarg(const char *) namebuf;
	} */ *uap = v;
	struct session *s = p->p_p->ps_pgrp->pg_session;
	char buf[sizeof(s->s_login)];
	int error;

	if ((error = suser(p, 0)) != 0)
		return (error);
	error = copyinstr(SCARG(uap, namebuf), buf, sizeof(buf), NULL);
	if (error == 0)
		strlcpy(s->s_login, buf, sizeof(s->s_login));
	else if (error == ENAMETOOLONG)
		error = EINVAL;
	return (error);
}

/*
 * Check if a process is allowed to raise its privileges.
 */
int
proc_cansugid(struct proc *p)
{
	/* ptrace(2)d processes shouldn't. */
	if ((p->p_p->ps_flags & PS_TRACED) != 0)
		return (0);

	/* processes with shared filedescriptors shouldn't. */
	if (p->p_fd->fd_refcnt > 1)
		return (0);

	/* Allow. */
	return (1);
}

/*
 * Set address of the proc's thread-control-block
 */
int
sys___set_tcb(struct proc *p, void *v, register_t *retval)
{
	struct sys___set_tcb_args /* {
		syscallarg(void *) tcb;
	} */ *uap = v;

	TCB_SET(p, SCARG(uap, tcb));
	return (0);
}

/*
 * Get address of the proc's thread-control-block
 */
int
sys___get_tcb(struct proc *p, void *v, register_t *retval)
{
	*retval = (register_t)TCB_GET(p);
	return (0);
}

/*
 * Refresh the thread's reference to the process's credentials
 */
void
dorefreshcreds(struct process *pr, struct proc *p)
{
	struct ucred *uc = p->p_ucred;

	KERNEL_LOCK();		/* XXX should be PROCESS_RLOCK(pr) */
	if (uc != pr->ps_ucred) {
		p->p_ucred = pr->ps_ucred;
		crhold(p->p_ucred);
		crfree(uc);
	}
	KERNEL_UNLOCK();
}
@


1.66
log
@add a concept of 'verified auth' to sessions. When set via ioctl,
the user and parent process are recorded. Later, this info may be tested
and used to bypass authorization requirements.
ie, doas won't ask for your password again.
Great idea from henning.
ok deraadt guenther henning
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.65 2016/03/30 07:49:11 guenther Exp $	*/
d81 1
a81 1
	*retval = p->p_pid + THREAD_PID_OFFSET;
@


1.65
log
@Add getlogin_r syscall that checks and returns errors like userspace
getlogin_r() API; keep existing syscall as getlogin59 for temporary compat.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.64 2016/03/29 16:53:49 guenther Exp $	*/
d228 1
@


1.64
log
@In setlogin(), don't change anything on error.

ok deraadt@@ krw@@ zhuk@@ jca@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.63 2015/03/02 20:46:50 guenther Exp $	*/
d1009 1
a1009 1
sys_getlogin(struct proc *p, void *v, register_t *retval)
d1011 1
a1011 1
	struct sys_getlogin_args /* {
d1021 23
@


1.63
log
@Return EINVAL if the creds supplied for NFS export have a cr_ngroups less
than zero or greater than NGROUPS_MAX

Fixes panic seen by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.62 2015/01/17 17:49:26 deraadt Exp $	*/
d1033 1
d1038 4
a1041 3
	error = copyinstr((caddr_t)SCARG(uap, namebuf), (caddr_t)s->s_login,
	    sizeof(s->s_login), NULL);
	if (error == ENAMETOOLONG)
@


1.62
log
@use NGROUPS_MAX
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.61 2014/09/17 19:26:06 millert Exp $	*/
d991 1
a991 1
void
d994 2
d1002 1
@


1.61
log
@The  2nd arg of setpgid(2) should be pid_t, not int.
No functional change as pid_t is defined as int32_t.
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.60 2014/04/18 11:51:17 guenther Exp $	*/
d863 1
a863 1
	gid_t groups[NGROUPS];
d870 1
a870 1
	if (ngrp > NGROUPS)
@


1.60
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.59 2014/03/30 21:54:48 guenther Exp $	*/
d259 1
a259 1
		syscallarg(int) pgid;
d264 2
a265 2
	pid_t pid;
	int pgid, error;
@


1.59
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.58 2014/03/24 03:48:00 guenther Exp $	*/
d59 10
a68 1
/* ARGSUSED */
a76 1
/* ARGSUSED */
a84 1
/* ARGSUSED */
a145 1
/* ARGSUSED */
a153 1
/* ARGSUSED */
a161 1
/* ARGSUSED */
a171 1
/* ARGSUSED */
a184 1
/* ARGSUSED */
a218 1
/* ARGSUSED */
a253 1
/* ARGSUSED */
a307 1
/* ARGSUSED */
a333 1
/* ARGSUSED */
d342 2
a343 1
	struct ucred *uc = p->p_ucred;
d351 8
a358 3
	if ((ruid == -1 || ruid == uc->cr_ruid) &&
	    (euid == -1 || euid == uc->cr_uid) &&
	    (suid == -1 || suid == uc->cr_svuid))
d388 1
d390 3
a392 1
	p->p_ucred = uc = crcopy(uc);
d398 2
a399 8
	if (ruid != (uid_t)-1 && ruid != uc->cr_ruid) {
		/*
		 * Transfer proc count to new user.
		 */
		(void)chgproccnt(uc->cr_ruid, -1);
		(void)chgproccnt(ruid, 1);
		uc->cr_ruid = ruid;
	}
d401 1
a401 1
		uc->cr_uid = euid;
d403 10
a412 1
		uc->cr_svuid = suid;
a413 1
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);
a416 1
/* ARGSUSED */
a442 1
/* ARGSUSED */
d451 2
a452 1
	struct ucred *uc = p->p_ucred;
d460 8
a467 3
	if ((rgid == -1 || rgid == uc->cr_rgid) &&
	    (egid == -1 || egid == uc->cr_gid) &&
	    (sgid == -1 || sgid == uc->cr_svgid))
d497 1
d499 3
a501 1
	p->p_ucred = uc = crcopy(uc);
d508 1
a508 1
		uc->cr_rgid = rgid;
d510 1
a510 1
		uc->cr_gid = egid;
d512 2
a513 2
		uc->cr_svgid = sgid;

d515 1
a518 1
/* ARGSUSED */
d526 2
a527 2
	struct ucred *uc = p->p_ucred;
	struct sys_setresgid_args sresgidargs;
d529 48
d578 4
a581 2
	rgid = SCARG(&sresgidargs, rgid) = SCARG(uap, rgid);
	egid = SCARG(&sresgidargs, egid) = SCARG(uap, egid);
d589 7
a595 7
	if (rgid != (gid_t)-1 && (rgid != uc->cr_rgid ||
	    uc->cr_svgid != (egid != (gid_t)-1 ? egid : uc->cr_gid)))
		SCARG(&sresgidargs, sgid) = rgid;
	else
		SCARG(&sresgidargs, sgid) = (gid_t)-1;

	return (sys_setresgid(p, &sresgidargs, retval));
a597 1
/* ARGSUSED */
d605 2
a606 2
	struct ucred *uc = p->p_ucred;
	struct sys_setresuid_args sresuidargs;
d608 48
d657 4
a660 2
	ruid = SCARG(&sresuidargs, ruid) = SCARG(uap, ruid);
	euid = SCARG(&sresuidargs, euid) = SCARG(uap, euid);
d668 12
a679 5
	if (ruid != (uid_t)-1 && (ruid != uc->cr_ruid ||
	    uc->cr_svuid != (euid != (uid_t)-1 ? euid : uc->cr_uid)))
		SCARG(&sresuidargs, suid) = ruid;
	else
		SCARG(&sresuidargs, suid) = (uid_t)-1;
d681 1
a681 1
	return (sys_setresuid(p, &sresuidargs, retval));
a683 1
/* ARGSUSED */
d690 2
a691 1
	struct ucred *uc = p->p_ucred;
d693 1
a693 1
	int error;
d697 4
a700 3
	if (uc->cr_uid == uid &&
	    uc->cr_ruid == uid &&
	    uc->cr_svuid == uid)
d711 1
d713 3
a715 1
	p->p_ucred = uc = crcopy(uc);
d720 16
a735 10
	if (uid == uc->cr_uid || suser(p, 0) == 0) {
		/*
		 * Transfer proc count to new user.
		 */
		if (uid != uc->cr_ruid) {
			(void)chgproccnt(uc->cr_ruid, -1);
			(void)chgproccnt(uid, 1);
		}
		uc->cr_ruid = uid;
		uc->cr_svuid = uid;
d737 1
a738 2
	uc->cr_uid = uid;
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);
a741 1
/* ARGSUSED */
d748 2
a749 1
	struct ucred *uc = p->p_ucred;
d755 1
a755 1
	if (uc->cr_uid == euid)
d764 1
d766 5
a770 2
	p->p_ucred = uc = crcopy(uc);
	uc->cr_uid = euid;
d772 1
a775 1
/* ARGSUSED */
d782 2
a783 1
	struct ucred *uc = p->p_ucred;
d789 4
a792 3
	if (uc->cr_gid == gid &&
	    uc->cr_rgid == gid &&
	    uc->cr_svgid == gid)
d803 1
d805 7
a811 5
	p->p_ucred = uc = crcopy(uc);

	if (gid == uc->cr_gid || suser(p, 0) == 0) {
		uc->cr_rgid = gid;
		uc->cr_svgid = gid;
d813 2
a814 2

	uc->cr_gid = gid;
d816 1
a819 1
/* ARGSUSED */
d826 2
a827 1
	struct ucred *uc = p->p_ucred;
d833 1
a833 1
	if (uc->cr_gid == egid)
d842 1
d844 5
a848 2
	p->p_ucred = uc = crcopy(uc);
	uc->cr_gid = egid;
d850 1
a853 1
/* ARGSUSED */
d861 3
a863 1
	struct ucred *uc = p->p_ucred;
d872 12
a883 7
	p->p_ucred = uc = crcopy(uc);
	error = copyin(SCARG(uap, gidset), uc->cr_groups, ngrp * sizeof(gid_t));
	if (error)
		return (error);
	uc->cr_ngroups = ngrp;
	atomic_setbits_int(&p->p_p->ps_flags, PS_SUGID);
	return (0);
a1004 1
/* ARGSUSED */
a1022 1
/* ARGSUSED */
d1081 17
@


1.58
log
@The kernel isn't involved in times(3); <sys/times.h> should never be
included there
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.57 2014/03/24 00:19:48 guenther Exp $	*/
a48 1
#include <sys/malloc.h>
d144 1
a144 1
	*retval = p->p_cred->p_ruid;
d173 1
a173 1
	*retval = p->p_cred->p_rgid;
d198 1
a198 1
	struct pcred *pc = p->p_cred;
d203 1
a203 1
		*retval = pc->pc_ucred->cr_ngroups;
d206 1
a206 1
	if (ngrp < pc->pc_ucred->cr_ngroups)
d208 3
a210 3
	ngrp = pc->pc_ucred->cr_ngroups;
	error = copyout((caddr_t)pc->pc_ucred->cr_groups,
	    (caddr_t)SCARG(uap, gidset), ngrp * sizeof(gid_t));
d317 1
a317 1
	struct pcred *pc = p->p_cred;
d326 1
a326 1
		error1 = copyout(&pc->p_ruid, ruid, sizeof(*ruid));
d328 1
a328 1
		error2 = copyout(&pc->pc_ucred->cr_uid, euid, sizeof(*euid));
d330 1
a330 1
		error3 = copyout(&pc->p_svuid, suid, sizeof(*suid));
d344 1
a344 1
	struct pcred *pc = p->p_cred;
d352 3
a354 3
	if ((ruid == -1 || ruid == pc->p_ruid) &&
	    (euid == -1 || euid == pc->pc_ucred->cr_uid) &&
	    (suid == -1 || suid == pc->p_svuid))
d362 3
a364 3
	    ruid != pc->p_ruid &&
	    ruid != pc->pc_ucred->cr_uid &&
	    ruid != pc->p_svuid &&
d369 3
a371 3
	    euid != pc->p_ruid &&
	    euid != pc->pc_ucred->cr_uid &&
	    euid != pc->p_svuid &&
d376 3
a378 3
	    suid != pc->p_ruid &&
	    suid != pc->pc_ucred->cr_uid &&
	    suid != pc->p_svuid &&
d383 5
d391 1
a391 1
	if (ruid != (uid_t)-1 && ruid != pc->p_ruid) {
d395 1
a395 1
		(void)chgproccnt(pc->p_ruid, -1);
d397 1
a397 8
		pc->p_ruid = ruid;
	}
	if (euid != (uid_t)-1 && euid != pc->pc_ucred->cr_uid) {
		/*
		 * Copy credentials so other references do not see our changes.
		 */
		pc->pc_ucred = crcopy(pc->pc_ucred);
		pc->pc_ucred->cr_uid = euid;
d399 4
a402 2
	if (suid != (uid_t)-1 && suid != pc->p_svuid)
		pc->p_svuid = suid;
d417 1
a417 1
	struct pcred *pc = p->p_cred;
d426 1
a426 1
		error1 = copyout(&pc->p_rgid, rgid, sizeof(*rgid));
d428 1
a428 1
		error2 = copyout(&pc->pc_ucred->cr_gid, egid, sizeof(*egid));
d430 1
a430 1
		error3 = copyout(&pc->p_svgid, sgid, sizeof(*sgid));
d444 1
a444 1
	struct pcred *pc = p->p_cred;
d452 3
a454 3
	if ((rgid == -1 || rgid == pc->p_rgid) &&
	    (egid == -1 || egid == pc->pc_ucred->cr_gid) &&
	    (sgid == -1 || sgid == pc->p_svgid))
d462 3
a464 3
	    rgid != pc->p_rgid &&
	    rgid != pc->pc_ucred->cr_gid &&
	    rgid != pc->p_svgid &&
d469 3
a471 3
	    egid != pc->p_rgid &&
	    egid != pc->pc_ucred->cr_gid &&
	    egid != pc->p_svgid &&
d476 3
a478 3
	    sgid != pc->p_rgid &&
	    sgid != pc->pc_ucred->cr_gid &&
	    sgid != pc->p_svgid &&
d483 5
d492 3
a494 8
		pc->p_rgid = rgid;
	if (egid != (gid_t)-1) {
		/*
		 * Copy credentials so other references do not see our changes.
		 */
		pc->pc_ucred = crcopy(pc->pc_ucred);
		pc->pc_ucred->cr_gid = egid;
	}
d496 1
a496 1
		pc->p_svgid = sgid;
d510 1
a510 1
	struct pcred *pc = p->p_cred;
d523 2
a524 2
	if (rgid != (gid_t)-1 && (rgid != pc->p_rgid ||
	    pc->p_svgid != (egid != (gid_t)-1 ? egid : pc->pc_ucred->cr_gid)))
d540 1
a540 1
	struct pcred *pc = p->p_cred;
d553 2
a554 2
	if (ruid != (uid_t)-1 && (ruid != pc->p_ruid ||
	    pc->p_svuid != (euid != (uid_t)-1 ? euid : pc->pc_ucred->cr_uid)))
d569 1
a569 1
	struct pcred *pc = p->p_cred;
d575 3
a577 3
	if (pc->pc_ucred->cr_uid == uid &&
	    pc->p_ruid == uid &&
	    pc->p_svuid == uid)
d580 3
a582 3
	if (uid != pc->p_ruid &&
	    uid != pc->p_svuid &&
	    uid != pc->pc_ucred->cr_uid &&
d587 5
d594 1
a594 2
	if (uid == pc->pc_ucred->cr_uid ||
	    suser(p, 0) == 0) {
d598 2
a599 2
		if (uid != pc->p_ruid) {
			(void)chgproccnt(pc->p_ruid, -1);
d602 2
a603 2
		pc->p_ruid = uid;
		pc->p_svuid = uid;
d606 1
a606 5
	/*
	 * Copy credentials so other references do not see our changes.
	 */
	pc->pc_ucred = crcopy(pc->pc_ucred);
	pc->pc_ucred->cr_uid = uid;
d618 1
a618 1
	struct pcred *pc = p->p_cred;
d624 1
a624 1
	if (pc->pc_ucred->cr_uid == euid)
d627 1
a627 1
	if (euid != pc->p_ruid && euid != pc->p_svuid &&
d634 2
a635 2
	pc->pc_ucred = crcopy(pc->pc_ucred);
	pc->pc_ucred->cr_uid = euid;
d647 1
a647 1
	struct pcred *pc = p->p_cred;
d653 3
a655 3
	if (pc->pc_ucred->cr_gid == gid &&
	    pc->p_rgid == gid &&
	    pc->p_svgid == gid)
d658 3
a660 3
	if (gid != pc->p_rgid &&
	    gid != pc->p_svgid &&
	    gid != pc->pc_ucred->cr_gid &&
a663 6
	if (gid == pc->pc_ucred->cr_gid ||
	    suser(p, 0) == 0) {
		pc->p_rgid = gid;
		pc->p_svgid = gid;
	}

d667 8
a674 2
	pc->pc_ucred = crcopy(pc->pc_ucred);
	pc->pc_ucred->cr_gid = gid;
d686 1
a686 1
	struct pcred *pc = p->p_cred;
d692 1
a692 1
	if (pc->pc_ucred->cr_gid == egid)
d695 1
a695 1
	if (egid != pc->p_rgid && egid != pc->p_svgid &&
d702 2
a703 2
	pc->pc_ucred = crcopy(pc->pc_ucred);
	pc->pc_ucred->cr_gid = egid;
d716 1
a716 1
	struct pcred *pc = p->p_cred;
d725 2
a726 3
	pc->pc_ucred = crcopy(pc->pc_ucred);
	error = copyin((caddr_t)SCARG(uap, gidset),
	    (caddr_t)pc->pc_ucred->cr_groups, ngrp * sizeof(gid_t));
d729 1
a729 1
	pc->pc_ucred->cr_ngroups = ngrp;
@


1.57
log
@Split the API: struct ucred remains the kernel internal structure while
struct xucred becomes the structure for syscalls (mount(2) and nfssvc(2)).

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.56 2013/04/06 03:44:34 tedu Exp $	*/
a48 1
#include <sys/times.h>
@


1.56
log
@rthreads are always enabled. remove the sysctl.
ok deraadt guenther kettenis matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.55 2012/10/01 00:08:42 guenther Exp $	*/
d837 14
@


1.55
log
@Make groupmember() check the effective gid too, so that the checks are
consistent when the effective gid isn't also a supplementary group.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.54 2012/04/12 10:11:41 mikeb Exp $	*/
a74 2
	if (!rthreads_enabled)
		return (ENOTSUP);
@


1.54
log
@move accounting flags to struct process; idea and ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.53 2012/04/10 15:50:52 guenther Exp $	*/
d748 2
@


1.53
log
@Make the KERN_NPROCS and KERN_MAXPROC sysctl()s and the RLIMIT_NPROC rlimit
count processes instead of threads.  New sysctl()s KERN_NTHREADS and
KERN_MAXTHREAD count and limit threads.  The nprocs and maxproc kernel
variables are replaced by nprocess, maxprocess, nthreads, and maxthread.

ok tedu@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.52 2012/02/20 22:23:39 guenther Exp $	*/
d766 1
a766 1
			p->p_acflag |= ASU;
@


1.52
log
@First steps for making ptrace work with rthreads:
 - move the P_TRACED and P_INEXEC flags, and p_oppid, p_ptmask, and
   p_ptstat member from struct proc to struct process
 - sort the PT_* requests into those that take a PID vs those that
   can also take a TID
 - stub in PT_GET_THREAD_FIRST and PT_GET_THREAD_NEXT

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.51 2011/10/15 23:35:29 guenther Exp $	*/
d394 2
a395 2
		(void)chgproccnt(pc->p_ruid, -p->p_p->ps_refcnt);
		(void)chgproccnt(ruid, p->p_p->ps_refcnt);
d599 2
a600 2
			(void)chgproccnt(pc->p_ruid, -p->p_p->ps_refcnt);
			(void)chgproccnt(uid, p->p_p->ps_refcnt);
@


1.51
log
@"TLS-lite": add kernel support for a per-thread userspace pointer,
for pointing to the thread-control-block.  Support for mapping this
to the correct hardware register can be added as it's finished;
start with support for amd64, sparc, and sparc64.  Includes syscalls
for getting and setting it (for a portable __errno implementation) as
well as creating a new thread with an initial value for it.

discussed with miod@@, kettenis@@, deraadt@@; committing to get the syscalls
in with the impending libc bump and do further refinements in tree
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.50 2011/07/25 20:32:06 tedu Exp $	*/
d887 1
a887 1
	if ((p->p_flag & P_TRACED) != 0)
@


1.50
log
@two more syscall functions that should have returned int, not pid_t
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.49 2011/07/07 18:08:36 tedu Exp $	*/
d57 4
d896 24
@


1.49
log
@effectively revert 1.44.  we don't need the compat_43 syscall returns ever.
getpid is smp safe again.  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.48 2011/04/04 13:00:13 guenther Exp $	*/
d98 1
a98 1
pid_t
d117 1
a117 1
pid_t
@


1.48
log
@Move P_EXEC flag from struct proc to process, so that setpgid() will
fail regardless of which rthread calls execve()

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.47 2011/04/02 17:04:35 guenther Exp $	*/
d62 1
a62 2
	retval[0] = p->p_p->ps_pid;
	retval[1] = p->p_p->ps_pptr->ps_pid;
d144 1
a144 2
	retval[0] = p->p_cred->p_ruid;
	retval[1] = p->p_ucred->cr_uid;
d173 1
a173 2
	retval[0] = p->p_cred->p_rgid;
	retval[1] = p->p_ucred->cr_gid;
@


1.47
log
@Move P_SUGID and P_SUGIDEXEC from struct proc to struct process, so
that you can't evade the checks by doing the dirty work in an rthread

ok blambert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.46 2010/07/26 01:56:27 guenther Exp $	*/
d287 1
a287 1
		if (targpr->ps_mainproc->p_flag & P_EXEC) {
@


1.46
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.45 2010/07/01 02:41:12 guenther Exp $	*/
d163 1
a163 1
	if (p->p_flag & P_SUGIDEXEC)
d407 1
a407 1
	atomic_setbits_int(&p->p_flag, P_SUGID);
d501 1
a501 1
	atomic_setbits_int(&p->p_flag, P_SUGID);
d610 1
a610 1
	atomic_setbits_int(&p->p_flag, P_SUGID);
d639 1
a639 1
	atomic_setbits_int(&p->p_flag, P_SUGID);
d678 1
a678 1
	atomic_setbits_int(&p->p_flag, P_SUGID);
d707 1
a707 1
	atomic_setbits_int(&p->p_flag, P_SUGID);
d734 1
a734 1
	atomic_setbits_int(&p->p_flag, P_SUGID);
@


1.45
log
@Always identify threads with THREAD_PID_OFFSET, so that there's no
way a kill() intended for a thread can result in a separate process
getting the signal.
ok tedu@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.44 2010/06/29 19:09:11 tedu Exp $	*/
d62 2
a63 2
	retval[0] = p->p_p->ps_mainproc->p_pid;
	retval[1] = p->p_p->ps_mainproc->p_pptr->p_pid;
d83 1
a83 1
	*retval = p->p_p->ps_mainproc->p_pptr->p_pid;
d92 1
a92 1
	*retval = p->p_pgrp->pg_id;
d105 1
a105 1
	struct proc *targp = curp;
d107 1
a107 1
	if (SCARG(uap, pid) == 0 || SCARG(uap, pid) == curp->p_pid)
d109 1
a109 1
	if ((targp = pfind(SCARG(uap, pid))) == NULL)
d111 1
a111 1
	if (targp->p_session != curp->p_session)
d114 1
a114 1
	*retval = targp->p_pgid;
d124 1
a124 1
	struct proc *targp = curp;
d126 1
a126 1
	if (SCARG(uap, pid) == 0 || SCARG(uap, pid) == curp->p_pid)
d128 1
a128 1
	if ((targp = pfind(SCARG(uap, pid))) == NULL)
d130 1
a130 1
	if (targp->p_session != curp->p_session)
d134 1
a134 1
	if (targp->p_pgrp->pg_session->s_leader == NULL)
d136 1
a136 1
	*retval = targp->p_pgrp->pg_session->s_leader->p_pid;
d226 2
d232 1
a232 1
	if (p->p_pgid == p->p_pid || pgfind(p->p_pid)) {
d237 2
a238 2
		(void) enterpgrp(p, p->p_pid, newpgrp, newsess);
		*retval = p->p_pid;
d264 2
a265 1
	struct proc *targp;		/* target process */
d278 2
a279 2
	if (pid != 0 && pid != curp->p_pid) {
		if ((targp = pfind(pid)) == 0 || !inferior(targp, curp)) {
d283 1
a283 1
		if (targp->p_session != curp->p_session) {
d287 1
a287 1
		if (targp->p_flag & P_EXEC) {
d292 2
a293 2
		targp = curp;
	if (SESS_LEADER(targp)) {
d298 2
a299 2
		pgid = targp->p_pid;
	else if (pgid != targp->p_pid)
d301 1
a301 1
		    pgrp->pg_session != curp->p_session) {
d305 1
a305 1
	return (enterpgrp(targp, pgid, newpgrp, NULL));
d849 1
d851 4
a854 4
	if (SCARG(uap, namelen) > sizeof (p->p_pgrp->pg_session->s_login))
		SCARG(uap, namelen) = sizeof (p->p_pgrp->pg_session->s_login);
	return (copyout((caddr_t) p->p_pgrp->pg_session->s_login,
	    (caddr_t) SCARG(uap, namebuf), SCARG(uap, namelen)));
d867 1
d872 2
a873 3
	error = copyinstr((caddr_t) SCARG(uap, namebuf),
	    (caddr_t) p->p_pgrp->pg_session->s_login,
	    sizeof (p->p_pgrp->pg_session->s_login), (size_t *)0);
@


1.44
log
@remove the compat43 ifdef around some code.  in effect, it's always been
in compat mode and there's no harm continuing that way.
ok dlg deraadt guenther miod thib
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.43 2010/06/29 00:28:14 tedu Exp $	*/
d74 1
a74 1
	*retval = p->p_pid + (p->p_flag & P_THREAD ? 0 : THREAD_PID_OFFSET);
@


1.43
log
@Eliminate RTHREADS kernel option in favor of a sysctl.  The actual status
(not done) hasn't changed, but now it's less work to test things.
ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.42 2010/06/28 23:00:30 guenther Exp $	*/
d62 1
a62 3
	*retval = p->p_p->ps_mainproc->p_pid;
#if defined(COMPAT_43) || defined(COMPAT_SUNOS) || defined(COMPAT_IBCS2) || \
    defined(COMPAT_FREEBSD) || defined(COMPAT_BSDOS)
a63 1
#endif
d145 1
a145 3
	*retval = p->p_cred->p_ruid;
#if defined(COMPAT_43) || defined(COMPAT_SUNOS) || defined(COMPAT_IBCS2) || \
    defined(COMPAT_FREEBSD) || defined(COMPAT_BSDOS)
a146 1
#endif
d175 1
a175 2
	*retval = p->p_cred->p_rgid;
#if defined(COMPAT_43) || defined(COMPAT_SUNOS) || defined(COMPAT_FREEBSD) || defined(COMPAT_BSDOS)
a176 1
#endif
@


1.42
log
@<sys/time.b> is for ftime(), which is just in libcompat and not the kernel,
so stop including it in kernel .c files.
"sure" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.41 2010/01/28 19:23:06 guenther Exp $	*/
a69 1
#ifdef RTHREADS
d75 2
a79 1
#endif
@


1.41
log
@Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.40 2010/01/14 23:12:11 schwarze Exp $	*/
a48 1
#include <sys/timeb.h>
@


1.40
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.39 2009/06/02 20:03:59 guenther Exp $	*/
d285 1
a285 1
		if ((targp = pfind(pid)) == 0 || !inferior(targp)) {
@


1.39
log
@ANSIfy
noted by Jonathan ARMANI, ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.38 2008/12/16 07:57:28 guenther Exp $	*/
d894 1
a894 1
	/* proceses with shared filedescriptors shouldn't. */
@


1.39.4.1
log
@Merge from -current:

----
Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
----

Requested by guenther@@. The hpux_compat change here is more
conservative than committed to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.39 2009/06/02 20:03:59 guenther Exp $	*/
d285 1
a285 1
		if ((targp = pfind(pid)) == 0 || !inferior(targp, curp)) {
@


1.38
log
@Move the functionality of psignal() to a new function ptsignal()
that takes an additional argument "type" that indicates whether the
signal is for the process, just a particular thread, or propagated
to a thread because it's not caught or blocked.  psignal() becomes
a wrapper that does the first of those.

So that sys_kill() can tell apart signals for the process and signals
for the process's original thread, the tid of the original thread
is defined as its pid + THREAD_PID_OFFSET.

ok tedu@@ art@@ andreas@@ kurt@@   "better early than late" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.37 2008/11/01 05:59:21 deraadt Exp $	*/
d74 1
a74 4
sys_getthrid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
@


1.38.2.1
log
@Merge from -current:

----
Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
----

Requested by guenther@@. The hpux_compat change here is more
conservative than committed to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.38 2008/12/16 07:57:28 guenther Exp $	*/
d288 1
a288 1
		if ((targp = pfind(pid)) == 0 || !inferior(targp, curp)) {
@


1.37
log
@change all callers of enterpgrp() to pre-allocate a pgrp or session if
it might be needed later -- before calling pfind(), so that enterpgrp()
can operate without sleeping
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.35 2008/10/31 17:15:30 deraadt Exp $	*/
d80 1
a80 1
	*retval = p->p_pid;
@


1.36
log
@accidental commit ... backout
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.34 2008/10/14 18:27:29 guenther Exp $	*/
d236 5
d243 2
d247 1
a247 1
		(void)enterpgrp(p, p->p_pid, 1);
d275 1
a275 1
	struct pgrp *pgrp;		/* target pgrp */
d277 1
a277 1
	int pgid;
d285 2
d288 12
a299 6
		if ((targp = pfind(pid)) == 0 || !inferior(targp))
			return (ESRCH);
		if (targp->p_session != curp->p_session)
			return (EPERM);
		if (targp->p_flag & P_EXEC)
			return (EACCES);
d302 4
a305 2
	if (SESS_LEADER(targp))
		return (EPERM);
d310 8
a317 3
		    pgrp->pg_session != curp->p_session)
			return (EPERM);
	return (enterpgrp(targp, pgid, 0));
@


1.35
log
@kern_sysctl.c
@
text
@a236 6
	struct session *nsess;
	struct pgrp *npgrp;

	nsess = pool_get(&session_pool, PR_WAITOK);
	npgrp = pool_get(&pgrp_pool, PR_WAITOK);

a237 2
		pool_put(&pgrp_pool, npgrp);
		pool_put(&session_pool, nsess);
d240 1
a240 1
		(void) enterpgrp(p, p->p_pid, npgrp, nsess);
d268 1
a268 1
	struct pgrp *pgrp, *npgrp;	/* target pgrp */
d270 1
a270 1
	int pgid, error;
a277 2
	npgrp = pool_get(&pgrp_pool, PR_WAITOK);

d279 6
a284 12
		if ((targp = pfind(pid)) == 0 || !inferior(targp)) {
			error = ESRCH;
			goto out;
		}
		if (targp->p_session != curp->p_session) {
			error = EPERM;
			goto out;
		}
		if (targp->p_flag & P_EXEC) {
			error = EACCES;
			goto out;
		}
d287 2
a288 4
	if (SESS_LEADER(targp)) {
		error = EPERM;
		goto out;
	}
d293 3
a295 9
		    pgrp->pg_session != curp->p_session) {
			error = EPERM;
			goto out;
		}
	return (enterpgrp(targp, pgid, npgrp, NULL));
out:
	if (npgrp)
		pool_put(&pgrp_pool, npgrp);
	return (error);
@


1.34
log
@Back-in; problems were apparently elsewhere.
Put a reference count in struct process to prevent use-after-free
if the main thread reaches the reaper ahead of some other thread
in the process.  Use the reference count to update the user process
count correctly when changin real uid.

"please re-commit before something else nasty comes in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.33 2008/10/10 14:35:06 deraadt Exp $	*/
d237 6
d244 2
d248 1
a248 1
		(void)enterpgrp(p, p->p_pid, 1);
d276 1
a276 1
	struct pgrp *pgrp;		/* target pgrp */
d278 1
a278 1
	int pgid;
d286 2
d289 12
a300 6
		if ((targp = pfind(pid)) == 0 || !inferior(targp))
			return (ESRCH);
		if (targp->p_session != curp->p_session)
			return (EPERM);
		if (targp->p_flag & P_EXEC)
			return (EACCES);
d303 4
a306 2
	if (SESS_LEADER(targp))
		return (EPERM);
d311 9
a319 3
		    pgrp->pg_session != curp->p_session)
			return (EPERM);
	return (enterpgrp(targp, pgid, 0));
@


1.33
log
@backout; is causing some people difficulty
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.31 2008/05/22 21:27:40 thib Exp $	*/
d380 2
a381 2
		(void)chgproccnt(pc->p_ruid, -1);
		(void)chgproccnt(ruid, 1);
d585 2
a586 2
			(void)chgproccnt(pc->p_ruid, -1);
			(void)chgproccnt(uid, 1);
@


1.32
log
@Use the reference count in struct process to update the proc count
for users by the correct amount when changing real UID on (r)threaded
processes.

ok art@@ tedu@@
@
text
@d380 2
a381 2
		(void)chgproccnt(pc->p_ruid, -p->p_p->ps_refcnt);
		(void)chgproccnt(ruid, p->p_p->ps_refcnt);
d585 2
a586 2
			(void)chgproccnt(pc->p_ruid, -p->p_p->ps_refcnt);
			(void)chgproccnt(uid, p->p_p->ps_refcnt);
@


1.31
log
@
use PR_ZERO instead of calling bzero directly
after pool_get();

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.30 2007/04/03 08:05:43 art Exp $	*/
d380 2
a381 2
		(void)chgproccnt(pc->p_ruid, -1);
		(void)chgproccnt(ruid, 1);
d585 2
a586 2
			(void)chgproccnt(pc->p_ruid, -1);
			(void)chgproccnt(uid, 1);
@


1.30
log
@Start moving state that is shared among threads in a process into
a new struct. Instead of doing a huge rename and deal with the fallout
for weeks, like other projects that need no mention, we will slowly and
carefully move things out of struct proc into a new struct process.

 - Create struct process and the infrastructure to create and remove them.
 - Move threads in a process into struct process.

deraadt@@, tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.29 2007/03/15 10:22:30 art Exp $	*/
d777 1
a777 2
	cr = pool_get(&ucred_pool, PR_WAITOK);
	bzero((caddr_t)cr, sizeof(*cr));
@


1.29
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.28 2005/12/03 18:09:08 tedu Exp $	*/
d63 1
a63 1
	*retval = p->p_thrparent->p_pid;
d66 1
a66 1
	retval[1] = p->p_thrparent->p_pptr->p_pid;
d90 1
a90 1
	*retval = p->p_pptr->p_pid;
@


1.28
log
@kernel support for threaded processes (rthreads).
uses rfork(RFTHREAD) to create threads, which are presently processes
that are a little more tightly bound together.  several new syscalls
added to facilitate a userland thread library.
all conditional on RTHREADS, currently disabled.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.27 2005/11/28 00:14:29 jsg Exp $	*/
d394 1
a394 1
	p->p_flag |= P_SUGID;
d488 1
a488 1
	p->p_flag |= P_SUGID;
d597 1
a597 1
	p->p_flag |= P_SUGID;
d626 1
a626 1
	p->p_flag |= P_SUGID;
d665 1
a665 1
	p->p_flag |= P_SUGID;
d694 1
a694 1
	p->p_flag |= P_SUGID;
d721 1
a721 1
	p->p_flag |= P_SUGID;
@


1.27
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.26 2003/09/01 18:06:03 henning Exp $	*/
d63 1
a63 1
	*retval = p->p_pid;
d66 1
a66 1
	retval[1] = p->p_pptr->p_pid;
d70 14
@


1.26
log
@match syscallargs comments with reality
from Patrick Latifi <patrick.l@@hermes.usherb.ca>
ok jason@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.25 2003/08/15 20:32:18 tedu Exp $	*/
d60 1
a60 4
sys_getpid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d73 1
a73 4
sys_getppid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d82 1
a82 4
sys_getpgrp(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d93 1
a93 4
sys_getpgid(curp, v, retval)
	struct proc *curp;
	void *v;
	register_t *retval;
d112 1
a112 4
sys_getsid(curp, v, retval)
	struct proc *curp;
	void *v;
	register_t *retval;
d135 1
a135 4
sys_getuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d148 1
a148 4
sys_geteuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d157 1
a157 4
sys_issetugid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d168 1
a168 4
sys_getgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d185 1
a185 4
sys_getegid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d193 1
a193 4
sys_getgroups(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d220 1
a220 4
sys_setsid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d247 1
a247 4
sys_setpgid(curp, v, retval)
	struct proc *curp;
	void *v;
	register_t *retval;
d286 1
a286 4
sys_getresuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d313 1
a313 4
sys_setresuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d386 1
a386 4
sys_getresgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d413 1
a413 4
sys_setresgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d480 1
a480 4
sys_setregid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d510 1
a510 4
sys_setreuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d540 1
a540 4
sys_setuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d589 1
a589 4
sys_seteuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d618 1
a618 4
sys_setgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d657 1
a657 4
sys_setegid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d686 1
a686 4
sys_setgroups(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d715 1
a715 3
groupmember(gid, cred)
	gid_t gid;
	struct ucred *cred;
d759 1
a759 1
crget()
d774 1
a774 2
crfree(cr)
	struct ucred *cr;
d785 1
a785 2
crcopy(cr)
	struct ucred *cr;
d802 1
a802 2
crdup(cr)
	struct ucred *cr;
d817 1
a817 4
sys_getlogin(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d835 1
a835 4
sys_setlogin(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
@


1.25
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.24 2003/06/02 23:28:05 millert Exp $	*/
d762 1
a762 1
		syscallarg(gid_t *) gidset;
d921 1
a921 1
		syscallarg(char *) namebuf;
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.23 2003/01/30 03:29:49 millert Exp $	*/
d386 1
a386 1
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
d393 1
a393 1
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
d400 1
a400 1
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
d492 1
a492 1
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
d499 1
a499 1
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
d506 1
a506 1
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
d619 1
a619 1
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
d626 1
a626 1
	    suser(pc->pc_ucred, &p->p_acflag) == 0) {
d667 1
a667 1
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
d703 1
a703 1
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
d707 1
a707 1
	    suser(pc->pc_ucred, &p->p_acflag) == 0) {
d741 1
a741 1
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
d768 1
a768 1
	if ((error = suser(pc->pc_ucred, &p->p_acflag)) != 0)
d802 1
a802 3
 * Test whether the specified credentials imply "super-user"
 * privilege; if so, and we have accounting info, set the flag
 * indicating use of super-powers.
d806 1
a806 3
suser(cred, acflag)
	struct ucred *cred;
	u_short *acflag;
d808 2
d811 2
a812 2
		if (acflag)
			*acflag |= ASU;
d819 11
d925 1
a925 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.23
log
@Bring back setreuid(2) and setregid(2) as first class syscalls
(but still implemented via setres[ug]id(2)).  Basically this just
moves them from COMPAT_43 into kern_prot.c.  Also fixes a typo in my
old implementation.  The userland portion will follow in a few days.
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.22 2002/10/30 20:02:58 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.22
log
@Implement setresuid(2), getresuid(2), setresgid(2), getresgid(2), based
partly on the Linux emul code and FreeBSD versions.
We need these for Linux, FreeBSD, and HP-UX emulation.
Also change sys_setreuid() and sys_setregid() to use uid_t and gid_t
respectively.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.21 2002/10/15 01:27:31 nordin Exp $	*/
d531 66
@


1.21
log
@Match reality by changing (u_int) -> (int) in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.20 2002/01/23 15:46:48 art Exp $	*/
d325 206
@


1.20
log
@Allocate rusage, pgrp, ucred and session with pool.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.19 2002/01/12 22:56:55 art Exp $	*/
d233 1
a233 1
		syscallarg(u_int) gidsetsize;
d493 1
a493 1
		syscallarg(u_int) gidsetsize;
@


1.19
log
@Don't cast return value from splx to (void) because splx doesn't return anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.18 2001/06/22 23:55:24 art Exp $	*/
d57 1
d560 1
a560 1
	MALLOC(cr, struct ucred *, sizeof(*cr), M_CRED, M_WAITOK);
a573 1
	int s;
a574 1
	s = splimp();				/* ??? */
d576 1
a576 2
		FREE((caddr_t)cr, M_CRED);
	splx(s);
@


1.18
log
@Try again. (this time it's tested).
Add proc_cansugid that checks if a process may raise it's privileges.
Rework exec to remove the old sugid workaround and check proc_cansugid
just before raising privileges.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.17 2001/06/22 14:14:09 deraadt Exp $	*/
d578 1
a578 1
	(void) splx(s);
@


1.18.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.20 2002/01/23 15:46:48 art Exp $	*/
a56 1
#include <sys/pool.h>
d559 1
a559 1
	cr = pool_get(&ucred_pool, PR_WAITOK);
d573 1
d575 1
d577 2
a578 1
		pool_put(&ucred_pool, cr);
@


1.18.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.18.4.1 2002/01/31 22:55:40 niklas Exp $	*/
d233 1
a233 1
		syscallarg(int) gidsetsize;
d493 1
a493 1
		syscallarg(int) gidsetsize;
@


1.18.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a324 272
}

/* ARGSUSED */
int
sys_getresuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_getresuid_args /* {
		syscallarg(uid_t *) ruid;
		syscallarg(uid_t *) euid;
		syscallarg(uid_t *) suid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	uid_t *ruid, *euid, *suid;
	int error1 = 0, error2 = 0, error3 = 0;

	ruid = SCARG(uap, ruid);
	euid = SCARG(uap, euid);
	suid = SCARG(uap, suid);

	if (ruid != NULL)
		error1 = copyout(&pc->p_ruid, ruid, sizeof(*ruid));
	if (euid != NULL)
		error2 = copyout(&pc->pc_ucred->cr_uid, euid, sizeof(*euid));
	if (suid != NULL)
		error3 = copyout(&pc->p_svuid, suid, sizeof(*suid));

	return (error1 ? error1 : error2 ? error2 : error3);
}

/* ARGSUSED */
int
sys_setresuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_setresuid_args /* {
		syscallarg(uid_t) ruid;
		syscallarg(uid_t) euid;
		syscallarg(uid_t) suid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	uid_t ruid, euid, suid;
	int error;

	ruid = SCARG(uap, ruid);
	euid = SCARG(uap, euid);
	suid = SCARG(uap, suid);

	if ((ruid == -1 || ruid == pc->p_ruid) &&
	    (euid == -1 || euid == pc->pc_ucred->cr_uid) &&
	    (suid == -1 || suid == pc->p_svuid))
		return (0);			/* no change */

	/*
	 * Any of the real, effective, and saved uids may be changed
	 * to the current value of one of the three (root is not limited).
	 */
	if (ruid != (uid_t)-1 &&
	    ruid != pc->p_ruid &&
	    ruid != pc->pc_ucred->cr_uid &&
	    ruid != pc->p_svuid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (euid != (uid_t)-1 &&
	    euid != pc->p_ruid &&
	    euid != pc->pc_ucred->cr_uid &&
	    euid != pc->p_svuid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (suid != (uid_t)-1 &&
	    suid != pc->p_ruid &&
	    suid != pc->pc_ucred->cr_uid &&
	    suid != pc->p_svuid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	/*
	 * Note that unlike the other set*uid() calls, each
	 * uid type is set independently of the others.
	 */
	if (ruid != (uid_t)-1 && ruid != pc->p_ruid) {
		/*
		 * Transfer proc count to new user.
		 */
		(void)chgproccnt(pc->p_ruid, -1);
		(void)chgproccnt(ruid, 1);
		pc->p_ruid = ruid;
	}
	if (euid != (uid_t)-1 && euid != pc->pc_ucred->cr_uid) {
		/*
		 * Copy credentials so other references do not see our changes.
		 */
		pc->pc_ucred = crcopy(pc->pc_ucred);
		pc->pc_ucred->cr_uid = euid;
	}
	if (suid != (uid_t)-1 && suid != pc->p_svuid)
		pc->p_svuid = suid;

	p->p_flag |= P_SUGID;
	return (0);
}

/* ARGSUSED */
int
sys_getresgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_getresgid_args /* {
		syscallarg(gid_t *) rgid;
		syscallarg(gid_t *) egid;
		syscallarg(gid_t *) sgid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	gid_t *rgid, *egid, *sgid;
	int error1 = 0, error2 = 0, error3 = 0;

	rgid = SCARG(uap, rgid);
	egid = SCARG(uap, egid);
	sgid = SCARG(uap, sgid);

	if (rgid != NULL)
		error1 = copyout(&pc->p_rgid, rgid, sizeof(*rgid));
	if (egid != NULL)
		error2 = copyout(&pc->pc_ucred->cr_gid, egid, sizeof(*egid));
	if (sgid != NULL)
		error3 = copyout(&pc->p_svgid, sgid, sizeof(*sgid));

	return (error1 ? error1 : error2 ? error2 : error3);
}

/* ARGSUSED */
int
sys_setresgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_setresgid_args /* {
		syscallarg(gid_t) rgid;
		syscallarg(gid_t) egid;
		syscallarg(gid_t) sgid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	gid_t rgid, egid, sgid;
	int error;

	rgid = SCARG(uap, rgid);
	egid = SCARG(uap, egid);
	sgid = SCARG(uap, sgid);

	if ((rgid == -1 || rgid == pc->p_rgid) &&
	    (egid == -1 || egid == pc->pc_ucred->cr_gid) &&
	    (sgid == -1 || sgid == pc->p_svgid))
		return (0);			/* no change */

	/*
	 * Any of the real, effective, and saved gids may be changed
	 * to the current value of one of the three (root is not limited).
	 */
	if (rgid != (gid_t)-1 &&
	    rgid != pc->p_rgid &&
	    rgid != pc->pc_ucred->cr_gid &&
	    rgid != pc->p_svgid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (egid != (gid_t)-1 &&
	    egid != pc->p_rgid &&
	    egid != pc->pc_ucred->cr_gid &&
	    egid != pc->p_svgid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (sgid != (gid_t)-1 &&
	    sgid != pc->p_rgid &&
	    sgid != pc->pc_ucred->cr_gid &&
	    sgid != pc->p_svgid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	/*
	 * Note that unlike the other set*gid() calls, each
	 * gid type is set independently of the others.
	 */
	if (rgid != (gid_t)-1)
		pc->p_rgid = rgid;
	if (egid != (gid_t)-1) {
		/*
		 * Copy credentials so other references do not see our changes.
		 */
		pc->pc_ucred = crcopy(pc->pc_ucred);
		pc->pc_ucred->cr_gid = egid;
	}
	if (sgid != (gid_t)-1)
		pc->p_svgid = sgid;

	p->p_flag |= P_SUGID;
	return (0);
}

/* ARGSUSED */
int
sys_setregid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_setregid_args /* {
		syscallarg(gid_t) rgid;
		syscallarg(gid_t) egid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	struct sys_setresgid_args sresgidargs;
	gid_t rgid, egid;

	rgid = SCARG(&sresgidargs, rgid) = SCARG(uap, rgid);
	egid = SCARG(&sresgidargs, egid) = SCARG(uap, egid);

	/*
	 * The saved gid presents a bit of a dilemma, as it did not
	 * exist when setregid(2) was conceived.  We only set the saved
	 * gid when the real gid is specified and either its value would
	 * change, or where the saved and effective gids are different.
	 */
	if (rgid != (gid_t)-1 && (rgid != pc->p_rgid ||
	    pc->p_svgid != (egid != (gid_t)-1 ? egid : pc->pc_ucred->cr_gid)))
		SCARG(&sresgidargs, sgid) = rgid;
	else
		SCARG(&sresgidargs, sgid) = (gid_t)-1;

	return (sys_setresgid(p, &sresgidargs, retval));
}

/* ARGSUSED */
int
sys_setreuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_setreuid_args /* {
		syscallarg(uid_t) ruid;
		syscallarg(uid_t) euid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	struct sys_setresuid_args sresuidargs;
	uid_t ruid, euid;

	ruid = SCARG(&sresuidargs, ruid) = SCARG(uap, ruid);
	euid = SCARG(&sresuidargs, euid) = SCARG(uap, euid);

	/*
	 * The saved uid presents a bit of a dilemma, as it did not
	 * exist when setreuid(2) was conceived.  We only set the saved
	 * uid when the real uid is specified and either its value would
	 * change, or where the saved and effective uids are different.
	 */
	if (ruid != (uid_t)-1 && (ruid != pc->p_ruid ||
	    pc->p_svuid != (euid != (uid_t)-1 ? euid : pc->pc_ucred->cr_uid)))
		SCARG(&sresuidargs, suid) = ruid;
	else
		SCARG(&sresuidargs, suid) = (uid_t)-1;

	return (sys_setresuid(p, &sresuidargs, retval));
@


1.17
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.16 2001/06/19 07:54:37 deraadt Exp $	*/
d56 1
d658 18
@


1.16
log
@no way, you are on drugs.  last commit revoked because it broke setuid majorly
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.14 2000/11/08 21:27:03 art Exp $	*/
d112 1
a112 1
        struct proc *targp = curp;
d127 8
a134 8
        struct proc *curp;
        void *v;
        register_t *retval;
{
        struct sys_getsid_args /* {
                syscallarg(pid_t) pid;
        } */ *uap = v;
        struct proc *targp = curp;
d505 1
a505 1
		       (caddr_t)pc->pc_ucred->cr_groups, ngrp * sizeof(gid_t));
@


1.15
log
@Add proc_cansugid used to check if a process should be allowed
to raise its privileges in exec.
@
text
@a55 1
#include <sys/filedesc.h>
a656 17
}

/*
 * Check if a process is allowed to raise its privileges.
 */
int
proc_cansugid(struct proc *p)
{
	/* ptrace(2)d processes shouldn't. */
	if ((p->p_flag & P_TRACED) != 0)
		return (EPERM);

	/* proceses with shared filedescriptors shouldn't. */
	if (p->p_fd->fd_refcnt > 1)
		return (EPERM);

	return (0);
@


1.14
log
@Cleanup.
Zap COMPAT_09.
Don't duplicate creds unless necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.13 2000/09/12 17:30:45 millert Exp $	*/
d56 1
d658 17
@


1.13
log
@o add missing getsid() prototype
o fix typo in getsid() that broke getsid(pid) where pid != 0
o cause getsid() and getpgid() to return EPERM if requesting the
  id of a session/process group not in the current session
o check for NULL session in getsid() for exiting processes
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.12 1997/11/17 05:57:45 deraadt Exp $	*/
d109 1
a109 1
	register struct sys_getpgid_args /* {
d131 1
a131 1
        register struct sys_getsid_args /* {
d230 1
a230 1
	register struct sys_getgroups_args /* {
d234 2
a235 2
	register struct pcred *pc = p->p_cred;
	register u_int ngrp;
d256 1
a256 1
	register struct proc *p;
d290 2
a291 2
	register struct sys_setpgid_args /* {
		syscallarg(int) pid;
d294 4
a297 2
	register struct proc *targp;		/* target process */
	register struct pgrp *pgrp;		/* target pgrp */
d299 2
a300 4
#ifdef COMPAT_09
	SCARG(uap, pid)  = (short) SCARG(uap, pid);		/* XXX */
	SCARG(uap, pgid) = (short) SCARG(uap, pgid);		/* XXX */
#endif
d302 1
a302 1
	if (SCARG(uap, pgid) < 0)
d305 2
a306 2
	if (SCARG(uap, pid) != 0 && SCARG(uap, pid) != curp->p_pid) {
		if ((targp = pfind(SCARG(uap, pid))) == 0 || !inferior(targp))
d316 4
a319 4
	if (SCARG(uap, pgid) == 0)
		SCARG(uap, pgid) = targp->p_pid;
	else if (SCARG(uap, pgid) != targp->p_pid)
		if ((pgrp = pgfind(SCARG(uap, pgid))) == 0 ||
d322 1
a322 1
	return (enterpgrp(targp, SCARG(uap, pgid), 0));
d335 2
a336 2
	register struct pcred *pc = p->p_cred;
	register uid_t uid;
a338 3
#ifdef COMPAT_09				/* XXX */
	uid = (u_short)SCARG(uap, uid);
#else
d340 6
a345 1
#endif
d351 1
d367 1
d387 2
a388 2
	register struct pcred *pc = p->p_cred;
	register uid_t euid;
a390 3
#ifdef COMPAT_09				/* XXX */
	euid = (u_short)SCARG(uap, euid);
#else
d392 4
a395 1
#endif
d399 1
d401 1
a401 2
	 * Everything's okay, do it.  Copy credentials so other references do
	 * not see our changes.
d419 2
a420 2
	register struct pcred *pc = p->p_cred;
	register gid_t gid;
a422 3
#ifdef COMPAT_09				/* XXX */
	gid = (u_short)SCARG(uap, gid);
#else
d424 6
a429 1
#endif
d435 1
d441 4
d461 2
a462 2
	register struct pcred *pc = p->p_cred;
	register gid_t egid;
a464 3
#ifdef COMPAT_09				/* XXX */
	egid = (u_short)SCARG(uap, egid);
#else
d466 4
a469 1
#endif
d473 4
d494 2
a495 2
	register struct pcred *pc = p->p_cred;
	register u_int ngrp;
d519 1
a519 1
	register struct ucred *cred;
d521 1
a521 1
	register gid_t *gp;
d556 1
a556 1
	register struct ucred *cr;
@


1.12
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.11 1997/11/13 07:11:11 deraadt Exp $	*/
d103 3
a105 3
int
sys_getpgid(p, v, retval)
	struct proc *p;
d112 1
d114 1
a114 1
	if (SCARG(uap, pid) == 0)
d116 1
a116 1
	if ((p = pfind(SCARG(uap, pid))) == 0)
d118 2
d121 2
a122 2
	*retval = p->p_pgid;
	return 0;
d125 3
a127 3
int
sys_getsid(p, v, retval)
        struct proc *p;
d134 1
d136 1
a136 1
	if (SCARG(uap, pid) == 0)
d138 1
a138 1
	if ((p == pfind(SCARG(uap, pid))) == 0)
d140 2
d143 5
a147 2
	*retval = p->p_pgrp->pg_session->s_leader->p_pid;
	return 0;
@


1.12.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.14 2000/11/08 21:27:03 art Exp $	*/
d103 3
a105 3
pid_t
sys_getpgid(curp, v, retval)
	struct proc *curp;
d109 1
a109 1
	struct sys_getpgid_args /* {
a111 1
        struct proc *targp = curp;
d113 1
a113 1
	if (SCARG(uap, pid) == 0 || SCARG(uap, pid) == curp->p_pid)
d115 1
a115 1
	if ((targp = pfind(SCARG(uap, pid))) == NULL)
a116 2
	if (targp->p_session != curp->p_session)
		return (EPERM);
d118 2
a119 2
	*retval = targp->p_pgid;
	return (0);
d122 3
a124 3
pid_t
sys_getsid(curp, v, retval)
        struct proc *curp;
d128 1
a128 1
        struct sys_getsid_args /* {
a130 1
        struct proc *targp = curp;
d132 1
a132 1
	if (SCARG(uap, pid) == 0 || SCARG(uap, pid) == curp->p_pid)
d134 1
a134 1
	if ((targp = pfind(SCARG(uap, pid))) == NULL)
a135 2
	if (targp->p_session != curp->p_session)
		return (EPERM);
d137 2
a138 5
	/* Skip exiting processes */
	if (targp->p_pgrp->pg_session->s_leader == NULL)
		return (ESRCH);
	*retval = targp->p_pgrp->pg_session->s_leader->p_pid;
	return (0);
d221 1
a221 1
	struct sys_getgroups_args /* {
d225 2
a226 2
	struct pcred *pc = p->p_cred;
	u_int ngrp;
d247 1
a247 1
	struct proc *p;
d281 2
a282 2
	struct sys_setpgid_args /* {
		syscallarg(pid_t) pid;
d285 2
a286 4
	struct proc *targp;		/* target process */
	struct pgrp *pgrp;		/* target pgrp */
	pid_t pid;
	int pgid;
d288 4
a291 2
	pid = SCARG(uap, pid);
	pgid = SCARG(uap, pgid);
d293 1
a293 1
	if (pgid < 0)
d296 2
a297 2
	if (pid != 0 && pid != curp->p_pid) {
		if ((targp = pfind(pid)) == 0 || !inferior(targp))
d307 4
a310 4
	if (pgid == 0)
		pgid = targp->p_pid;
	else if (pgid != targp->p_pid)
		if ((pgrp = pgfind(pgid)) == 0 ||
d313 1
a313 1
	return (enterpgrp(targp, pgid, 0));
d326 2
a327 2
	struct pcred *pc = p->p_cred;
	uid_t uid;
d330 3
d334 1
a334 6

	if (pc->pc_ucred->cr_uid == uid &&
	    pc->p_ruid == uid &&
	    pc->p_svuid == uid)
		return (0);

a339 1

a354 1

d374 2
a375 2
	struct pcred *pc = p->p_cred;
	uid_t euid;
d378 3
d382 1
a382 4

	if (pc->pc_ucred->cr_uid == euid)
		return (0);

a385 1

d387 2
a388 1
	 * Copy credentials so other references do not see our changes.
d406 2
a407 2
	struct pcred *pc = p->p_cred;
	gid_t gid;
d410 3
d414 1
a414 6

	if (pc->pc_ucred->cr_gid == gid &&
	    pc->p_rgid == gid &&
	    pc->p_svgid == gid)
		return (0);

a419 1

a424 4

	/*
	 * Copy credentials so other references do not see our changes.
	 */
d441 2
a442 2
	struct pcred *pc = p->p_cred;
	gid_t egid;
d445 3
d449 1
a449 4

	if (pc->pc_ucred->cr_gid == egid)
		return (0);

a452 4

	/*
	 * Copy credentials so other references do not see our changes.
	 */
d470 2
a471 2
	struct pcred *pc = p->p_cred;
	u_int ngrp;
d495 1
a495 1
	struct ucred *cred;
d497 1
a497 1
	gid_t *gp;
d532 1
a532 1
	struct ucred *cr;
@


1.12.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.12.10.1 2001/05/14 22:32:41 niklas Exp $	*/
a55 1
#include <sys/filedesc.h>
d112 1
a112 1
	struct proc *targp = curp;
d127 8
a134 8
	struct proc *curp;
	void *v;
	register_t *retval;
{
	struct sys_getsid_args /* {
		syscallarg(pid_t) pid;
	} */ *uap = v;
	struct proc *targp = curp;
d505 1
a505 1
	    (caddr_t)pc->pc_ucred->cr_groups, ngrp * sizeof(gid_t));
a656 18
}

/*
 * Check if a process is allowed to raise its privileges.
 */
int
proc_cansugid(struct proc *p)
{
	/* ptrace(2)d processes shouldn't. */
	if ((p->p_flag & P_TRACED) != 0)
		return (0);

	/* proceses with shared filedescriptors shouldn't. */
	if (p->p_fd->fd_refcnt > 1)
		return (0);

	/* Allow. */
	return (1);
@


1.12.10.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a56 1
#include <sys/pool.h>
d559 1
a559 1
	cr = pool_get(&ucred_pool, PR_WAITOK);
d573 1
d575 1
d577 2
a578 1
		pool_put(&ucred_pool, cr);
@


1.12.10.4
log
@Sync the SMP branch with 3.3
@
text
@d233 1
a233 1
		syscallarg(int) gidsetsize;
a328 272
sys_getresuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_getresuid_args /* {
		syscallarg(uid_t *) ruid;
		syscallarg(uid_t *) euid;
		syscallarg(uid_t *) suid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	uid_t *ruid, *euid, *suid;
	int error1 = 0, error2 = 0, error3 = 0;

	ruid = SCARG(uap, ruid);
	euid = SCARG(uap, euid);
	suid = SCARG(uap, suid);

	if (ruid != NULL)
		error1 = copyout(&pc->p_ruid, ruid, sizeof(*ruid));
	if (euid != NULL)
		error2 = copyout(&pc->pc_ucred->cr_uid, euid, sizeof(*euid));
	if (suid != NULL)
		error3 = copyout(&pc->p_svuid, suid, sizeof(*suid));

	return (error1 ? error1 : error2 ? error2 : error3);
}

/* ARGSUSED */
int
sys_setresuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_setresuid_args /* {
		syscallarg(uid_t) ruid;
		syscallarg(uid_t) euid;
		syscallarg(uid_t) suid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	uid_t ruid, euid, suid;
	int error;

	ruid = SCARG(uap, ruid);
	euid = SCARG(uap, euid);
	suid = SCARG(uap, suid);

	if ((ruid == -1 || ruid == pc->p_ruid) &&
	    (euid == -1 || euid == pc->pc_ucred->cr_uid) &&
	    (suid == -1 || suid == pc->p_svuid))
		return (0);			/* no change */

	/*
	 * Any of the real, effective, and saved uids may be changed
	 * to the current value of one of the three (root is not limited).
	 */
	if (ruid != (uid_t)-1 &&
	    ruid != pc->p_ruid &&
	    ruid != pc->pc_ucred->cr_uid &&
	    ruid != pc->p_svuid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (euid != (uid_t)-1 &&
	    euid != pc->p_ruid &&
	    euid != pc->pc_ucred->cr_uid &&
	    euid != pc->p_svuid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (suid != (uid_t)-1 &&
	    suid != pc->p_ruid &&
	    suid != pc->pc_ucred->cr_uid &&
	    suid != pc->p_svuid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	/*
	 * Note that unlike the other set*uid() calls, each
	 * uid type is set independently of the others.
	 */
	if (ruid != (uid_t)-1 && ruid != pc->p_ruid) {
		/*
		 * Transfer proc count to new user.
		 */
		(void)chgproccnt(pc->p_ruid, -1);
		(void)chgproccnt(ruid, 1);
		pc->p_ruid = ruid;
	}
	if (euid != (uid_t)-1 && euid != pc->pc_ucred->cr_uid) {
		/*
		 * Copy credentials so other references do not see our changes.
		 */
		pc->pc_ucred = crcopy(pc->pc_ucred);
		pc->pc_ucred->cr_uid = euid;
	}
	if (suid != (uid_t)-1 && suid != pc->p_svuid)
		pc->p_svuid = suid;

	p->p_flag |= P_SUGID;
	return (0);
}

/* ARGSUSED */
int
sys_getresgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_getresgid_args /* {
		syscallarg(gid_t *) rgid;
		syscallarg(gid_t *) egid;
		syscallarg(gid_t *) sgid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	gid_t *rgid, *egid, *sgid;
	int error1 = 0, error2 = 0, error3 = 0;

	rgid = SCARG(uap, rgid);
	egid = SCARG(uap, egid);
	sgid = SCARG(uap, sgid);

	if (rgid != NULL)
		error1 = copyout(&pc->p_rgid, rgid, sizeof(*rgid));
	if (egid != NULL)
		error2 = copyout(&pc->pc_ucred->cr_gid, egid, sizeof(*egid));
	if (sgid != NULL)
		error3 = copyout(&pc->p_svgid, sgid, sizeof(*sgid));

	return (error1 ? error1 : error2 ? error2 : error3);
}

/* ARGSUSED */
int
sys_setresgid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_setresgid_args /* {
		syscallarg(gid_t) rgid;
		syscallarg(gid_t) egid;
		syscallarg(gid_t) sgid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	gid_t rgid, egid, sgid;
	int error;

	rgid = SCARG(uap, rgid);
	egid = SCARG(uap, egid);
	sgid = SCARG(uap, sgid);

	if ((rgid == -1 || rgid == pc->p_rgid) &&
	    (egid == -1 || egid == pc->pc_ucred->cr_gid) &&
	    (sgid == -1 || sgid == pc->p_svgid))
		return (0);			/* no change */

	/*
	 * Any of the real, effective, and saved gids may be changed
	 * to the current value of one of the three (root is not limited).
	 */
	if (rgid != (gid_t)-1 &&
	    rgid != pc->p_rgid &&
	    rgid != pc->pc_ucred->cr_gid &&
	    rgid != pc->p_svgid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (egid != (gid_t)-1 &&
	    egid != pc->p_rgid &&
	    egid != pc->pc_ucred->cr_gid &&
	    egid != pc->p_svgid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	if (sgid != (gid_t)-1 &&
	    sgid != pc->p_rgid &&
	    sgid != pc->pc_ucred->cr_gid &&
	    sgid != pc->p_svgid &&
	    (error = suser(pc->pc_ucred, &p->p_acflag)))
		return (error);

	/*
	 * Note that unlike the other set*gid() calls, each
	 * gid type is set independently of the others.
	 */
	if (rgid != (gid_t)-1)
		pc->p_rgid = rgid;
	if (egid != (gid_t)-1) {
		/*
		 * Copy credentials so other references do not see our changes.
		 */
		pc->pc_ucred = crcopy(pc->pc_ucred);
		pc->pc_ucred->cr_gid = egid;
	}
	if (sgid != (gid_t)-1)
		pc->p_svgid = sgid;

	p->p_flag |= P_SUGID;
	return (0);
}

/* ARGSUSED */
int
sys_setregid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_setregid_args /* {
		syscallarg(gid_t) rgid;
		syscallarg(gid_t) egid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	struct sys_setresgid_args sresgidargs;
	gid_t rgid, egid;

	rgid = SCARG(&sresgidargs, rgid) = SCARG(uap, rgid);
	egid = SCARG(&sresgidargs, egid) = SCARG(uap, egid);

	/*
	 * The saved gid presents a bit of a dilemma, as it did not
	 * exist when setregid(2) was conceived.  We only set the saved
	 * gid when the real gid is specified and either its value would
	 * change, or where the saved and effective gids are different.
	 */
	if (rgid != (gid_t)-1 && (rgid != pc->p_rgid ||
	    pc->p_svgid != (egid != (gid_t)-1 ? egid : pc->pc_ucred->cr_gid)))
		SCARG(&sresgidargs, sgid) = rgid;
	else
		SCARG(&sresgidargs, sgid) = (gid_t)-1;

	return (sys_setresgid(p, &sresgidargs, retval));
}

/* ARGSUSED */
int
sys_setreuid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_setreuid_args /* {
		syscallarg(uid_t) ruid;
		syscallarg(uid_t) euid;
	} */ *uap = v;
	struct pcred *pc = p->p_cred;
	struct sys_setresuid_args sresuidargs;
	uid_t ruid, euid;

	ruid = SCARG(&sresuidargs, ruid) = SCARG(uap, ruid);
	euid = SCARG(&sresuidargs, euid) = SCARG(uap, euid);

	/*
	 * The saved uid presents a bit of a dilemma, as it did not
	 * exist when setreuid(2) was conceived.  We only set the saved
	 * uid when the real uid is specified and either its value would
	 * change, or where the saved and effective uids are different.
	 */
	if (ruid != (uid_t)-1 && (ruid != pc->p_ruid ||
	    pc->p_svuid != (euid != (uid_t)-1 ? euid : pc->pc_ucred->cr_uid)))
		SCARG(&sresuidargs, suid) = ruid;
	else
		SCARG(&sresuidargs, suid) = (uid_t)-1;

	return (sys_setresuid(p, &sresuidargs, retval));
}

/* ARGSUSED */
int
d493 1
a493 1
		syscallarg(int) gidsetsize;
@


1.12.10.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.12.10.4 2003/03/28 00:41:26 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12.10.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d386 1
a386 1
	    (error = suser(p, 0)))
d393 1
a393 1
	    (error = suser(p, 0)))
d400 1
a400 1
	    (error = suser(p, 0)))
d492 1
a492 1
	    (error = suser(p, 0)))
d499 1
a499 1
	    (error = suser(p, 0)))
d506 1
a506 1
	    (error = suser(p, 0)))
d619 1
a619 1
	    (error = suser(p, 0)))
d626 1
a626 1
	    suser(p, 0) == 0) {
d667 1
a667 1
	    (error = suser(p, 0)))
d703 1
a703 1
	    (error = suser(p, 0)))
d707 1
a707 1
	    suser(p, 0) == 0) {
d741 1
a741 1
	    (error = suser(p, 0)))
d762 1
a762 1
		syscallarg(const gid_t *) gidset;
d768 1
a768 1
	if ((error = suser(p, 0)) != 0)
d802 3
a804 1
 * Test whether this process has special user powers.
d808 3
a810 1
suser(struct proc *p, u_int flags)
a811 2
	struct ucred *cred = p->p_ucred;

d813 2
a814 2
		if (!(flags & SUSER_NOACCT))
			p->p_acflag |= ASU;
a820 11
 * replacement for old suser, for callers who don't have a process
 */
int
suser_ucred(struct ucred *cred)
{
	if (cred->cr_uid == 0)
		return (0);
	return (EPERM);
}

/*
d912 1
a912 1
		syscallarg(const char *) namebuf;
d916 1
a916 1
	if ((error = suser(p, 0)) != 0)
@


1.11
log
@add getsid(2), XPG4
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.10 1997/09/02 08:48:32 downsj Exp $	*/
d237 1
a237 1
			(caddr_t)SCARG(uap, gidset), ngrp * sizeof(gid_t));
@


1.10
log
@COMPAT_BSDOS exec and compat changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.9 1997/05/30 21:43:34 kstailey Exp $	*/
d122 19
d311 1
a311 1
	            pgrp->pg_session != curp->p_session)
@


1.9
log
@add getpgid(2) from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.8 1997/03/29 08:58:03 tholo Exp $	*/
d70 1
a70 1
    defined(COMPAT_FREEBSD)
d132 1
a132 1
    defined(COMPAT_FREEBSD)
d173 1
a173 1
#if defined(COMPAT_43) || defined(COMPAT_SUNOS) || defined(COMPAT_FREEBSD)
@


1.8
log
@Do return values from issetuid() correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.7 1996/10/27 04:51:37 tholo Exp $	*/
d98 22
@


1.7
log
@Allow set[gu]id() if the [gu]id we are trying to set is the saved [gu]id,
but only set effective [gu]id.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.6 1996/10/26 07:29:40 tholo Exp $	*/
d136 3
a138 1
		return (1);
@


1.6
log
@Verify that pgid argument to setpgid() is legal
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.5 1996/10/02 20:22:14 deraadt Exp $	*/
d293 1
d373 1
@


1.5
log
@copyinstr correctly; spotted by bitblt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.4 1996/08/25 09:51:37 deraadt Exp $	*/
d249 3
@


1.4
log
@issetugid() system call discovers if a process was started setuid or setgid
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.3 1996/08/01 05:26:02 tholo Exp $	*/
d581 1
a581 1
	    sizeof (p->p_pgrp->pg_session->s_login) - 1, (size_t *)0);
@


1.3
log
@Implemented _POSIX_SAVED_IDS behaviour according to 1003.1-1990, with
allowed extension from Appendix B, section 4.2.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_prot.c,v 1.2 1996/03/03 17:19:52 niklas Exp $	*/
d125 12
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d278 1
d283 14
a296 1
	 * Transfer proc count to new user.
a298 2
	(void)chgproccnt(pc->p_ruid, -1);
	(void)chgproccnt(uid, 1);
a300 2
	pc->p_ruid = uid;
	pc->p_svuid = uid;
d356 3
a358 1
	if (gid != pc->p_rgid && (error = suser(pc->pc_ucred, &p->p_acflag)))
d360 5
a366 2
	pc->p_rgid = gid;
	pc->p_svgid = gid;		/* ??? */
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: kern_prot.c,v 1.31 1995/10/10 01:26:53 mycroft Exp $	*/
d61 1
d77 1
d89 1
d101 1
d117 1
d129 1
d149 1
d160 1
d181 3
a183 2
	if (error = copyout((caddr_t)pc->pc_ucred->cr_groups,
	    (caddr_t)SCARG(uap, gidset), ngrp * sizeof(gid_t)))
d190 1
d220 1
d259 1
d296 1
d328 1
d357 1
d385 1
d399 1
a399 1
	if (error = suser(pc->pc_ucred, &p->p_acflag))
d405 3
a407 2
	if (error = copyin((caddr_t)SCARG(uap, gidset),
	    (caddr_t)pc->pc_ucred->cr_groups, ngrp * sizeof(gid_t)))
d417 1
d438 1
d518 1
d539 1
d550 1
a550 1
	if (error = suser(p->p_ucred, &p->p_acflag))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
