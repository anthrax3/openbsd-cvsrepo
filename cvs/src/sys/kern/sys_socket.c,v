head	1.31;
access;
symbols
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.2
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.14.0.16
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.14
	OPENBSD_5_0:1.14.0.12
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.10
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.8
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.6
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.8
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.6
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.4
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.10
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.8
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.6
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.12
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.10
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.8
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.6
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.4
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.2
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2017.07.20.08.25.17;	author mpi;	state Exp;
branches;
next	1.30;
commitid	OhWqkB2UDXUFxh1S;

1.30
date	2017.02.22.10.20.21;	author mpi;	state Exp;
branches;
next	1.29;
commitid	au80FD411JjCy2JB;

1.29
date	2017.02.14.09.46.21;	author mpi;	state Exp;
branches;
next	1.28;
commitid	4bln7omqWkS0RJo9;

1.28
date	2017.01.31.12.16.20;	author mpi;	state Exp;
branches;
next	1.27;
commitid	iS7YuY5nvwVZYxyO;

1.27
date	2017.01.25.21.59.41;	author mpi;	state Exp;
branches;
next	1.26;
commitid	ItvKRgru62mnNdnN;

1.26
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.25;
commitid	QqHqT2WhCBWqYgGJ;

1.25
date	2016.11.22.12.11.38;	author mpi;	state Exp;
branches;
next	1.24;
commitid	1eYjfhjvOxaukV3n;

1.24
date	2016.11.21.10.30.42;	author mpi;	state Exp;
branches;
next	1.23;
commitid	dsunvxH1DSUUN1eT;

1.23
date	2016.11.21.09.09.06;	author mpi;	state Exp;
branches;
next	1.22;
commitid	wuzpseLx3Ntn9R7b;

1.22
date	2016.10.06.17.02.10;	author bluhm;	state Exp;
branches;
next	1.21;
commitid	RiiPM07FzrJt63iz;

1.21
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.20;
commitid	Cl55DD2g2xm69E6W;

1.20
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.19;
commitid	hN5bFCE56DrAjl99;

1.19
date	2014.07.13.15.52.38;	author tedu;	state Exp;
branches;
next	1.18;
commitid	iyde0xIVfkKugN9I;

1.18
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2013.09.28.15.21.55;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2013.04.05.08.25.30;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2013.01.15.11.12.57;	author bluhm;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.22.07.47.22;	author otto;	state Exp;
branches;
next	1.13;

1.13
date	2008.10.02.14.40.22;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.26.23.53.33;	author kurt;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.13.10.33.14;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.14.12.38.47;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.14.11.04.04;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.01.20.54.34;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.19.08.34.53;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	97.08.31.20.42.23;	author deraadt;	state Exp;
branches
	1.3.12.1;
next	1.2;

1.2
date	97.02.24.14.19.59;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches;
next	;

1.3.12.1
date	2001.05.14.22.32.44;	author niklas;	state Exp;
branches;
next	1.3.12.2;

1.3.12.2
date	2001.07.04.10.48.36;	author niklas;	state Exp;
branches;
next	1.3.12.3;

1.3.12.3
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.3.12.4;

1.3.12.4
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Extend the scope of the socket lock in soo_stat() to protect `so_state'
and `so_rcv'.

ok bluhm@@, claudio@@, visa@@
@
text
@/*	$OpenBSD: sys_socket.c,v 1.30 2017/02/22 10:20:21 mpi Exp $	*/
/*	$NetBSD: sys_socket.c,v 1.13 1995/08/12 23:59:09 mycroft Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)sys_socket.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/file.h>
#include <sys/proc.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/ioctl.h>
#include <sys/poll.h>
#include <sys/stat.h>

#include <net/if.h>
#include <net/route.h>

struct	fileops socketops = {
	soo_read, soo_write, soo_ioctl, soo_poll, soo_kqfilter,
	soo_stat, soo_close
};

int
soo_read(struct file *fp, off_t *poff, struct uio *uio, struct ucred *cred)
{

	return (soreceive((struct socket *)fp->f_data, (struct mbuf **)NULL,
		uio, (struct mbuf **)NULL, (struct mbuf **)NULL, (int *)NULL,
		(socklen_t)0));
}

int
soo_write(struct file *fp, off_t *poff, struct uio *uio, struct ucred *cred)
{

	return (sosend((struct socket *)fp->f_data, (struct mbuf *)NULL,
		uio, (struct mbuf *)NULL, (struct mbuf *)NULL, 0));
}

int
soo_ioctl(struct file *fp, u_long cmd, caddr_t data, struct proc *p)
{
	struct socket *so = (struct socket *)fp->f_data;
	int s, error = 0;

	switch (cmd) {

	case FIONBIO:
		if (*(int *)data)
			so->so_state |= SS_NBIO;
		else
			so->so_state &= ~SS_NBIO;
		return (0);

	case FIOASYNC:
		if (*(int *)data) {
			so->so_state |= SS_ASYNC;
			so->so_rcv.sb_flags |= SB_ASYNC;
			so->so_snd.sb_flags |= SB_ASYNC;
		} else {
			so->so_state &= ~SS_ASYNC;
			so->so_rcv.sb_flags &= ~SB_ASYNC;
			so->so_snd.sb_flags &= ~SB_ASYNC;
		}
		return (0);

	case FIONREAD:
		*(int *)data = so->so_rcv.sb_datacc;
		return (0);

	case SIOCSPGRP:
		so->so_pgid = *(int *)data;
		so->so_siguid = p->p_ucred->cr_ruid;
		so->so_sigeuid = p->p_ucred->cr_uid;
		return (0);

	case SIOCGPGRP:
		*(int *)data = so->so_pgid;
		return (0);

	case SIOCATMARK:
		*(int *)data = (so->so_state&SS_RCVATMARK) != 0;
		return (0);
	}
	/*
	 * Interface/routing/protocol specific ioctls:
	 * interface and routing ioctls should have a
	 * different entry since a socket's unnecessary
	 */
	if (IOCGROUP(cmd) == 'i') {
		NET_LOCK(s);
		error = ifioctl(so, cmd, data, p);
		NET_UNLOCK(s);
		return (error);
	}
	if (IOCGROUP(cmd) == 'r')
		return (EOPNOTSUPP);
	s = solock(so);
	error = ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL, 
	    (struct mbuf *)cmd, (struct mbuf *)data, (struct mbuf *)NULL, p));
	sounlock(s);

	return (error);
}

int
soo_poll(struct file *fp, int events, struct proc *p)
{
	struct socket *so = fp->f_data;
	int revents = 0;
	int s;

	s = solock(so);
	if (events & (POLLIN | POLLRDNORM)) {
		if (soreadable(so))
			revents |= events & (POLLIN | POLLRDNORM);
	}
	/* NOTE: POLLHUP and POLLOUT/POLLWRNORM are mutually exclusive */
	if (so->so_state & SS_ISDISCONNECTED) {
		revents |= POLLHUP;
	} else if (events & (POLLOUT | POLLWRNORM)) {
		if (sowriteable(so))
			revents |= events & (POLLOUT | POLLWRNORM);
	}
	if (events & (POLLPRI | POLLRDBAND)) {
		if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
			revents |= events & (POLLPRI | POLLRDBAND);
	}
	if (revents == 0) {
		if (events & (POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND)) {
			selrecord(p, &so->so_rcv.sb_sel);
			so->so_rcv.sb_flagsintr |= SB_SEL;
		}
		if (events & (POLLOUT | POLLWRNORM)) {
			selrecord(p, &so->so_snd.sb_sel);
			so->so_snd.sb_flagsintr |= SB_SEL;
		}
	}
	sounlock(s);
	return (revents);
}

int
soo_stat(struct file *fp, struct stat *ub, struct proc *p)
{
	struct socket *so = fp->f_data;
	int s;

	memset(ub, 0, sizeof (*ub));
	ub->st_mode = S_IFSOCK;
	s = solock(so);
	if ((so->so_state & SS_CANTRCVMORE) == 0 || so->so_rcv.sb_cc != 0)
		ub->st_mode |= S_IRUSR | S_IRGRP | S_IROTH;
	if ((so->so_state & SS_CANTSENDMORE) == 0)
		ub->st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
	ub->st_uid = so->so_euid;
	ub->st_gid = so->so_egid;
	(void) ((*so->so_proto->pr_usrreq)(so, PRU_SENSE,
	    (struct mbuf *)ub, NULL, NULL, p));
	sounlock(s);
	return (0);
}

int
soo_close(struct file *fp, struct proc *p)
{
	int error = 0;

	if (fp->f_data)
		error = soclose(fp->f_data);
	fp->f_data = 0;
	return (error);
}
@


1.30
log
@Do not grab the NET_LOCK() when poll(2)ing on unix domain sockets.

Fix the 'X freeze' while scanning with wireless interfaces.  Problem
reported by pirofti@@.

ok tb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.29 2017/02/14 09:46:21 mpi Exp $	*/
d183 2
a184 2
	if ((so->so_state & SS_CANTRCVMORE) == 0 ||
	    so->so_rcv.sb_cc != 0)
a189 1
	s = solock(so);
@


1.29
log
@Wrap the NET_LOCK() into a per-socket solock() that does nothing for
unix domain sockets.

This should prevent the multiple deadlock related to unix domain sockets.

Inputs from millert@@ and bluhm@@, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.28 2017/01/31 12:16:20 mpi Exp $	*/
d145 1
a145 1
	NET_LOCK(s);
d171 1
a171 1
	NET_UNLOCK(s);
@


1.28
log
@Remove the inifioctl hack, checking for an unheld NET_LOCK() in
tsleep(9) & friends seem to only produce false positives and cannot
be easily disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.26 2016/12/19 08:36:49 mpi Exp $	*/
d130 1
a130 1
	NET_LOCK(s);
d133 1
a133 1
	NET_UNLOCK(s);
d190 1
a190 1
	NET_LOCK(s);
d193 1
a193 1
	NET_UNLOCK(s);
@


1.27
log
@Introduce a hack to remove false-positives when looking for memory
allocation that can sleep while holding the NET_LOCK().

To be removed once we're confident the remaining code paths are safe.

Discussed with deraadt@@
@
text
@a123 4
#if 1
		extern int inifioctl;
		inifioctl = 1;
#endif
a124 3
#if 1
		inifioctl = 0;
#endif
@


1.26
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.25 2016/11/22 12:11:38 mpi Exp $	*/
d124 4
d129 3
@


1.25
log
@Enforce that ifioctl() is called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.24 2016/11/21 10:30:42 mpi Exp $	*/
d123 1
a123 1
		s = splsoftnet();
d125 1
a125 1
		splx(s);
d130 1
a130 1
	s = splsoftnet();
d133 1
a133 1
	splx(s);
d145 1
a145 1
	s = splsoftnet();
d171 1
a171 1
	splx(s);
d190 1
a190 1
	s = splsoftnet();
d193 1
a193 1
	splx(s);
@


1.24
log
@Kill rtioctl() stub, returning EOPNOTSUPP since tree import.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.23 2016/11/21 09:09:06 mpi Exp $	*/
d122 6
a127 2
	if (IOCGROUP(cmd) == 'i')
		return (ifioctl(so, cmd, data, p));
@


1.23
log
@Enforce that pr_usrreq functions are called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.22 2016/10/06 17:02:10 bluhm Exp $	*/
d125 1
a125 1
		return (rtioctl(cmd, data, p));
@


1.22
log
@Separate splsoftnet() from variable initialization.
From mpi@@'s netlock diff; OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.21 2015/12/05 10:11:53 tedu Exp $	*/
d76 1
d126 2
a127 1
	return ((*so->so_proto->pr_usrreq)(so, PRU_CONTROL, 
d129 3
d175 1
d186 1
d189 1
@


1.21
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.20 2015/05/13 10:42:46 jsg Exp $	*/
d134 1
a134 1
	int s = splsoftnet();
d136 1
@


1.20
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.19 2014/07/13 15:52:38 tedu Exp $	*/
a54 1
/* ARGSUSED */
a63 1
/* ARGSUSED */
a183 1
/* ARGSUSED */
@


1.19
log
@bzero -> memset. for the speeds.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.18 2014/03/30 21:54:48 guenther Exp $	*/
d60 2
a61 2
	return (soreceive((struct socket *)fp->f_data, (struct mbuf **)0,
		uio, (struct mbuf **)0, (struct mbuf **)0, (int *)0,
d70 2
a71 2
	return (sosend((struct socket *)fp->f_data, (struct mbuf *)0,
		uio, (struct mbuf *)0, (struct mbuf *)0, 0));
d128 1
a128 1
	    (struct mbuf *)cmd, (struct mbuf *)data, (struct mbuf *)0, p));
@


1.18
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.17 2013/09/28 15:21:55 millert Exp $	*/
d172 1
a172 1
	bzero(ub, sizeof (*ub));
@


1.17
log
@poll(2) on a socket should set POLLHUP on EOF.  This makes the
behavior of socketpair(2) match that of pipe(2) when the other end
is closed.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.16 2013/04/05 08:25:30 tedu Exp $	*/
d106 1
a106 1
		so->so_siguid = p->p_cred->p_ruid;
@


1.16
log
@remove some obsolete casts
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.15 2013/01/15 11:12:57 bluhm Exp $	*/
d142 4
a145 1
	if (events & (POLLOUT | POLLWRNORM)) {
@


1.15
log
@Changing the socket buffer flags sb_flags was not interrupt safe
as |= and &= are non-atomic operations.  To avoid additional locks,
put the flags that have to be accessed from interrupt into a separate
sb_flagsintr 32 bit integer field.  sb_flagsintr is protected by
splsoftnet.
Input from miod@@ deraadt@@; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.14 2009/02/22 07:47:22 otto Exp $	*/
d134 1
a134 1
	struct socket *so = (struct socket *)fp->f_data;
d167 1
a167 1
	struct socket *so = (struct socket *)fp->f_data;
d169 1
a169 1
	bzero((caddr_t)ub, sizeof (*ub));
d179 1
a179 2
	    (struct mbuf *)ub, (struct mbuf *)0, 
	    (struct mbuf *)0, p));
d190 1
a190 1
		error = soclose((struct socket *)fp->f_data);
@


1.14
log
@fix PR 6082: do not create more fd's than will fit in the message on
the receiving side when passing fd's. ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.13 2008/10/02 14:40:22 deraadt Exp $	*/
d153 1
a153 1
			so->so_rcv.sb_flags |= SB_SEL;
d157 1
a157 1
			so->so_snd.sb_flags |= SB_SEL;
@


1.13
log
@A closed, disconnected, or otherwise failed socket is still a socket
and should return stat information instead of EINVAL from deep in the
guts of tcp_usrreq.  While there, put some more information into struct
stat, inspired by FreeBSD. EINVAL problem reported in PR 5943
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.12 2008/05/23 15:51:12 thib Exp $	*/
d61 2
a62 1
		uio, (struct mbuf **)0, (struct mbuf **)0, (int *)0));
@


1.12
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.11 2007/02/26 23:53:33 kurt Exp $	*/
d170 8
a177 1
	return ((*so->so_proto->pr_usrreq)(so, PRU_SENSE,
d180 1
@


1.11
log
@exclude control data from the number of bytes returned by FIONREAD ioctl()
by adding a sb_datacc count to sockbuf that counts data excluding
MT_CONTROL and MT_SONAME mbuf types.  w/help from deraadt@@.
okay deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.10 2005/12/13 10:33:14 jsg Exp $	*/
d127 1
a127 1
	    (struct mbuf *)cmd, (struct mbuf *)data, (struct mbuf *)0));
d172 1
a172 1
	    (struct mbuf *)0));
@


1.10
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.9 2003/09/23 16:51:12 millert Exp $	*/
d100 1
a100 1
		*(int *)data = so->so_rcv.sb_cc;
@


1.9
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.8 2003/06/02 23:28:06 millert Exp $	*/
d57 1
a57 5
soo_read(fp, poff, uio, cred)
	struct file *fp;
	off_t *poff;
	struct uio *uio;
	struct ucred *cred;
d66 1
a66 5
soo_write(fp, poff, uio, cred)
	struct file *fp;
	off_t *poff;
	struct uio *uio;
	struct ucred *cred;
d74 1
a74 5
soo_ioctl(fp, cmd, data, p)
	struct file *fp;
	u_long cmd;
	register caddr_t data;
	struct proc *p;
d76 1
a76 1
	register struct socket *so = (struct socket *)fp->f_data;
d131 1
a131 4
soo_poll(fp, events, p)
	struct file *fp;
	int events;
	struct proc *p;
d164 1
a164 4
soo_stat(fp, ub, p)
	struct file *fp;
	struct stat *ub;
	struct proc *p;
d177 1
a177 3
soo_close(fp, p)
	struct file *fp;
	struct proc *p;
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.7 2001/05/14 12:38:47 art Exp $	*/
d44 1
d51 1
a51 1
	soo_read, soo_write, soo_ioctl, soo_select, soo_kqfilter,
d143 1
a143 1
soo_select(fp, which, p)
d145 1
a145 1
	int which;
d148 20
a167 18
	register struct socket *so = (struct socket *)fp->f_data;
	register int s = splsoftnet();

	switch (which) {

	case FREAD:
		if (soreadable(so)) {
			splx(s);
			return (1);
		}
		selrecord(p, &so->so_rcv.sb_sel);
		so->so_rcv.sb_flags |= SB_SEL;
		break;

	case FWRITE:
		if (sowriteable(so)) {
			splx(s);
			return (1);
d169 3
a171 8
		selrecord(p, &so->so_snd.sb_sel);
		so->so_snd.sb_flags |= SB_SEL;
		break;

	case 0:
		if (so->so_oobmark || (so->so_state & SS_RCVATMARK)) {
			splx(s);
			return (1);
a172 3
		selrecord(p, &so->so_rcv.sb_sel);
		so->so_rcv.sb_flags |= SB_SEL;
		break;
d175 1
a175 1
	return (0);
@


1.7
log
@Add a fo_stat member to struct fileops. Used soon.
Also add a stat function for kqueue from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.6 2001/05/14 11:04:04 art Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@More generic arguments to soo_stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.5 2001/03/01 20:54:34 provos Exp $	*/
d55 1
a55 1
	soo_close
@


1.5
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.4 2000/04/19 08:34:53 csapuntz Exp $	*/
d188 4
a191 3
soo_stat(so, ub)
	register struct socket *so;
	register struct stat *ub;
d193 1
@


1.4
log
@

Change struct file interface methods read and write to pass file offset in
and out.

Make pread/pwrite in netbsd & linux thread safe - which is the whole point
anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.3 1997/08/31 20:42:23 deraadt Exp $	*/
d53 4
a56 2
struct	fileops socketops =
    { soo_read, soo_write, soo_ioctl, soo_select, soo_close };
@


1.3
log
@for non-tty TIOCSPGRP/F_SETOWN/FIOSETOWN pgid setting calls, store uid
and euid as well, then deliver them using new csignal() interface
which ensures that pgid setting process is permitted to signal the
pgid process(es). Thanks to newsham@@aloha.net for extensive help and
discussion.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.2 1997/02/24 14:19:59 niklas Exp $	*/
d58 1
a58 1
soo_read(fp, uio, cred)
d60 1
d71 1
a71 1
soo_write(fp, uio, cred)
d73 1
@


1.3.12.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.5 2001/03/01 20:54:34 provos Exp $	*/
d53 2
a54 4
struct	fileops socketops = {
	soo_read, soo_write, soo_ioctl, soo_select, soo_kqfilter,
	soo_close
};
d58 1
a58 1
soo_read(fp, poff, uio, cred)
a59 1
	off_t *poff;
d70 1
a70 1
soo_write(fp, poff, uio, cred)
a71 1
	off_t *poff;
@


1.3.12.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.3.12.1 2001/05/14 22:32:44 niklas Exp $	*/
d55 1
a55 1
	soo_stat, soo_close
d188 3
a190 4
soo_stat(fp, ub, p)
	struct file *fp;
	struct stat *ub;
	struct proc *p;
a191 1
	struct socket *so = (struct socket *)fp->f_data;
@


1.3.12.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.3.12.2 2001/07/04 10:48:36 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.12.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a43 1
#include <sys/poll.h>
d50 1
a50 1
	soo_read, soo_write, soo_ioctl, soo_poll, soo_kqfilter,
d142 1
a142 1
soo_poll(fp, events, p)
d144 1
a144 1
	int events;
d147 18
a164 20
	struct socket *so = (struct socket *)fp->f_data;
	int revents = 0;
	int s = splsoftnet();

	if (events & (POLLIN | POLLRDNORM)) {
		if (soreadable(so))
			revents |= events & (POLLIN | POLLRDNORM);
	}
	if (events & (POLLOUT | POLLWRNORM)) {
		if (sowriteable(so))
			revents |= events & (POLLOUT | POLLWRNORM);
	}
	if (events & (POLLPRI | POLLRDBAND)) {
		if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
			revents |= events & (POLLPRI | POLLRDBAND);
	}
	if (revents == 0) {
		if (events & (POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND)) {
			selrecord(p, &so->so_rcv.sb_sel);
			so->so_rcv.sb_flags |= SB_SEL;
d166 8
a173 3
		if (events & (POLLOUT | POLLWRNORM)) {
			selrecord(p, &so->so_snd.sb_sel);
			so->so_snd.sb_flags |= SB_SEL;
d175 3
d180 1
a180 1
	return (revents);
@


1.2
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: sys_socket.c,v 1.13 1995/08/12 23:59:09 mycroft Exp $	*/
d42 1
d116 2
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
