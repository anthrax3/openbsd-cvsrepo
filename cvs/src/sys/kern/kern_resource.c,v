head	1.57;
access;
symbols
	OPENBSD_6_1:1.57.0.4
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.55.0.4
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.54.0.6
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.50.0.4
	OPENBSD_5_6_BASE:1.50
	OPENBSD_5_5:1.49.0.4
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.42.0.2
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.40.0.4
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.2
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.4
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.36.0.4
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.2
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.33.0.8
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.4
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.32.0.4
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.31.0.6
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.21
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.6
	OPENBSD_2_8:1.12.0.4
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2016.09.15.02.00.16;	author dlg;	state Exp;
branches;
next	1.56;
commitid	RlO92XR575sygHqm;

1.56
date	2016.08.25.00.00.02;	author dlg;	state Exp;
branches;
next	1.55;
commitid	iTfOIfeIXH3Xx3fA;

1.55
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.54;
commitid	Cl55DD2g2xm69E6W;

1.54
date	2015.02.09.09.39.09;	author miod;	state Exp;
branches;
next	1.53;
commitid	Dny5EZ91sz8fb6Ea;

1.53
date	2014.12.19.05.59.21;	author tedu;	state Exp;
branches;
next	1.52;
commitid	zdJTCwdpqRUwO1SL;

1.52
date	2014.12.10.02.44.47;	author tedu;	state Exp;
branches;
next	1.51;
commitid	tsoJBlEBSyYO22RG;

1.51
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	yv0ECmCdICvq576h;

1.50
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.49;

1.49
date	2014.01.24.04.26.51;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2014.01.21.01.48.44;	author tedu;	state Exp;
branches;
next	1.47;

1.47
date	2014.01.20.21.19.28;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2013.10.25.04.42.48;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2013.09.14.03.06.41;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2013.09.14.01.35.00;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2013.08.13.05.52.23;	author guenther;	state Exp;
branches;
next	1.42;

1.42
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2013.04.01.01.07.34;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2012.04.10.15.50.52;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2012.03.19.09.05.39;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2011.03.07.07.07.13;	author guenther;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.29.20.14.46;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.04.02.48.56;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2008.05.22.17.04.59;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.12.22.14.15;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.28.00.14.29;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.29.03.20.41;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.11.23.02.30;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.11.22.55.22;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.01.18.06.03;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.15.01.27.31;	author nordin;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.02.21.56.30;	author nordin;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2002.07.21.21.29.33;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.25.14.54.00;	author art;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.12.20.21.56.19;	author nordin;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.10.19.20.39;	author art;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.27.04.49.44;	author art;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.05.26.04.10.26;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.05.08.34.18;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.03.11.31.43;	author art;	state Exp;
branches;
next	1.10;

1.10
date	99.11.05.01.18.01;	author mickey;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.07.15.14.07.41;	author art;	state Exp;
branches;
next	1.8;

1.8
date	99.02.26.05.10.40;	author art;	state Exp;
branches;
next	1.7;

1.7
date	96.11.24.23.33.43;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.07.27.11.07.30;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.02.09.23.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.20.10.54.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.17.19.53;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.19.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2000.03.24.09.09.24;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.05.14.22.32.41;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.07.04.10.48.25;	author niklas;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.10.2.8;

1.10.2.8
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.10.2.9;

1.10.2.9
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.10.2.10;

1.10.2.10
date	2004.06.05.23.18.25;	author tedu;	state Exp;
branches;
next	;

1.14.2.1
date	2002.10.13.20.56.46;	author miod;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.11.06.22.11.19;	author miod;	state Exp;
branches;
next	;

1.16.2.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	;

1.18.2.1
date	2002.10.13.20.54.54;	author miod;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.11.06.22.11.53;	author miod;	state Exp;
branches;
next	;

1.20.2.1
date	2002.11.04.15.03.32;	author jason;	state Exp;
branches;
next	;


desc
@@


1.57
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@/*	$OpenBSD: kern_resource.c,v 1.56 2016/08/25 00:00:02 dlg Exp $	*/
/*	$NetBSD: kern_resource.c,v 1.38 1996/10/23 07:19:38 matthias Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_resource.c	8.5 (Berkeley) 1/21/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/resourcevar.h>
#include <sys/pool.h>
#include <sys/proc.h>
#include <sys/ktrace.h>
#include <sys/sched.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

void	tuagg_sub(struct tusage *, struct proc *);

/*
 * Patchable maximum data and stack limits.
 */
rlim_t maxdmap = MAXDSIZ;
rlim_t maxsmap = MAXSSIZ;

/*
 * Resource controls and accounting.
 */

int
sys_getpriority(struct proc *curp, void *v, register_t *retval)
{
	struct sys_getpriority_args /* {
		syscallarg(int) which;
		syscallarg(id_t) who;
	} */ *uap = v;
	struct process *pr;
	int low = NZERO + PRIO_MAX + 1;

	switch (SCARG(uap, which)) {

	case PRIO_PROCESS:
		if (SCARG(uap, who) == 0)
			pr = curp->p_p;
		else
			pr = prfind(SCARG(uap, who));
		if (pr == NULL)
			break;
		if (pr->ps_nice < low)
			low = pr->ps_nice;
		break;

	case PRIO_PGRP: {
		struct pgrp *pg;

		if (SCARG(uap, who) == 0)
			pg = curp->p_p->ps_pgrp;
		else if ((pg = pgfind(SCARG(uap, who))) == NULL)
			break;
		LIST_FOREACH(pr, &pg->pg_members, ps_pglist)
			if (pr->ps_nice < low)
				low = pr->ps_nice;
		break;
	}

	case PRIO_USER:
		if (SCARG(uap, who) == 0)
			SCARG(uap, who) = curp->p_ucred->cr_uid;
		LIST_FOREACH(pr, &allprocess, ps_list)
			if (pr->ps_ucred->cr_uid == SCARG(uap, who) &&
			    pr->ps_nice < low)
				low = pr->ps_nice;
		break;

	default:
		return (EINVAL);
	}
	if (low == NZERO + PRIO_MAX + 1)
		return (ESRCH);
	*retval = low - NZERO;
	return (0);
}

int
sys_setpriority(struct proc *curp, void *v, register_t *retval)
{
	struct sys_setpriority_args /* {
		syscallarg(int) which;
		syscallarg(id_t) who;
		syscallarg(int) prio;
	} */ *uap = v;
	struct process *pr;
	int found = 0, error = 0;

	switch (SCARG(uap, which)) {

	case PRIO_PROCESS:
		if (SCARG(uap, who) == 0)
			pr = curp->p_p;
		else
			pr = prfind(SCARG(uap, who));
		if (pr == NULL)
			break;
		error = donice(curp, pr, SCARG(uap, prio));
		found++;
		break;

	case PRIO_PGRP: {
		struct pgrp *pg;
		 
		if (SCARG(uap, who) == 0)
			pg = curp->p_p->ps_pgrp;
		else if ((pg = pgfind(SCARG(uap, who))) == NULL)
			break;
		LIST_FOREACH(pr, &pg->pg_members, ps_pglist) {
			error = donice(curp, pr, SCARG(uap, prio));
			found++;
		}
		break;
	}

	case PRIO_USER:
		if (SCARG(uap, who) == 0)
			SCARG(uap, who) = curp->p_ucred->cr_uid;
		LIST_FOREACH(pr, &allprocess, ps_list)
			if (pr->ps_ucred->cr_uid == SCARG(uap, who)) {
				error = donice(curp, pr, SCARG(uap, prio));
				found++;
			}
		break;

	default:
		return (EINVAL);
	}
	if (found == 0)
		return (ESRCH);
	return (error);
}

int
donice(struct proc *curp, struct process *chgpr, int n)
{
	struct ucred *ucred = curp->p_ucred;
	struct proc *p;
	int s;

	if (ucred->cr_uid != 0 && ucred->cr_ruid != 0 &&
	    ucred->cr_uid != chgpr->ps_ucred->cr_uid &&
	    ucred->cr_ruid != chgpr->ps_ucred->cr_uid)
		return (EPERM);
	if (n > PRIO_MAX)
		n = PRIO_MAX;
	if (n < PRIO_MIN)
		n = PRIO_MIN;
	n += NZERO;
	if (n < chgpr->ps_nice && suser(curp, 0))
		return (EACCES);
	chgpr->ps_nice = n;
	SCHED_LOCK(s);
	TAILQ_FOREACH(p, &chgpr->ps_threads, p_thr_link)
		(void)resetpriority(p);
	SCHED_UNLOCK(s);
	return (0);
}

int
sys_setrlimit(struct proc *p, void *v, register_t *retval)
{
	struct sys_setrlimit_args /* {
		syscallarg(int) which;
		syscallarg(const struct rlimit *) rlp;
	} */ *uap = v;
	struct rlimit alim;
	int error;

	error = copyin((caddr_t)SCARG(uap, rlp), (caddr_t)&alim,
		       sizeof (struct rlimit));
	if (error)
		return (error);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_STRUCT))
		ktrrlimit(p, &alim);
#endif
	return (dosetrlimit(p, SCARG(uap, which), &alim));
}

int
dosetrlimit(struct proc *p, u_int which, struct rlimit *limp)
{
	struct rlimit *alimp;
	rlim_t maxlim;
	int error;

	if (which >= RLIM_NLIMITS || limp->rlim_cur > limp->rlim_max)
		return (EINVAL);

	alimp = &p->p_rlimit[which];
	if (limp->rlim_max > alimp->rlim_max)
		if ((error = suser(p, 0)) != 0)
			return (error);
	if (p->p_p->ps_limit->p_refcnt > 1) {
		struct plimit *l = p->p_p->ps_limit;

		/* limcopy() can sleep, so copy before decrementing refcnt */
		p->p_p->ps_limit = limcopy(l);
		limfree(l);
		alimp = &p->p_rlimit[which];
	}

	switch (which) {
	case RLIMIT_DATA:
		maxlim = maxdmap;
		break;
	case RLIMIT_STACK:
		maxlim = maxsmap;
		break;
	case RLIMIT_NOFILE:
		maxlim = maxfiles;
		break;
	case RLIMIT_NPROC:
		maxlim = maxprocess;
		break;
	default:
		maxlim = RLIM_INFINITY;
		break;
	}

	if (limp->rlim_max > maxlim)
		limp->rlim_max = maxlim;
	if (limp->rlim_cur > limp->rlim_max)
		limp->rlim_cur = limp->rlim_max;

	if (which == RLIMIT_STACK) {
		/*
		 * Stack is allocated to the max at exec time with only
		 * "rlim_cur" bytes accessible.  If stack limit is going
		 * up make more accessible, if going down make inaccessible.
		 */
		if (limp->rlim_cur != alimp->rlim_cur) {
			vaddr_t addr;
			vsize_t size;
			vm_prot_t prot;
			struct vmspace *vm = p->p_vmspace;

			if (limp->rlim_cur > alimp->rlim_cur) {
				prot = PROT_READ | PROT_WRITE;
				size = limp->rlim_cur - alimp->rlim_cur;
#ifdef MACHINE_STACK_GROWS_UP
				addr = (vaddr_t)vm->vm_maxsaddr +
				    alimp->rlim_cur;
#else
				addr = (vaddr_t)vm->vm_minsaddr -
				    limp->rlim_cur;
#endif
			} else {
				prot = PROT_NONE;
				size = alimp->rlim_cur - limp->rlim_cur;
#ifdef MACHINE_STACK_GROWS_UP
				addr = (vaddr_t)vm->vm_maxsaddr +
				    limp->rlim_cur;
#else
				addr = (vaddr_t)vm->vm_minsaddr -
				    alimp->rlim_cur;
#endif
			}
			addr = trunc_page(addr);
			size = round_page(size);
			(void) uvm_map_protect(&vm->vm_map,
					      addr, addr+size, prot, FALSE);
		}
	}

	*alimp = *limp;
	return (0);
}

int
sys_getrlimit(struct proc *p, void *v, register_t *retval)
{
	struct sys_getrlimit_args /* {
		syscallarg(int) which;
		syscallarg(struct rlimit *) rlp;
	} */ *uap = v;
	struct rlimit *alimp;
	int error;

	if (SCARG(uap, which) < 0 || SCARG(uap, which) >= RLIM_NLIMITS)
		return (EINVAL);
	alimp = &p->p_rlimit[SCARG(uap, which)];
	error = copyout(alimp, SCARG(uap, rlp), sizeof(struct rlimit));
#ifdef KTRACE
	if (error == 0 && KTRPOINT(p, KTR_STRUCT))
		ktrrlimit(p, alimp);
#endif
	return (error);
}

void
tuagg_sub(struct tusage *tup, struct proc *p)
{
	timespecadd(&tup->tu_runtime, &p->p_rtime, &tup->tu_runtime);
	tup->tu_uticks += p->p_uticks;
	tup->tu_sticks += p->p_sticks;
	tup->tu_iticks += p->p_iticks;
}

/*
 * Aggregate a single thread's immediate time counts into the running
 * totals for the thread and process
 */
void
tuagg_unlocked(struct process *pr, struct proc *p)
{
	tuagg_sub(&pr->ps_tu, p);
	tuagg_sub(&p->p_tu, p);
	timespecclear(&p->p_rtime);
	p->p_uticks = 0;
	p->p_sticks = 0;
	p->p_iticks = 0;
}

void
tuagg(struct process *pr, struct proc *p)
{
	int s;

	SCHED_LOCK(s);
	tuagg_unlocked(pr, p);
	SCHED_UNLOCK(s);
}

/*
 * Transform the running time and tick information in a struct tusage
 * into user, system, and interrupt time usage.
 */
void
calctsru(struct tusage *tup, struct timespec *up, struct timespec *sp,
    struct timespec *ip)
{
	u_quad_t st, ut, it;
	int freq;

	st = tup->tu_sticks;
	ut = tup->tu_uticks;
	it = tup->tu_iticks;

	if (st + ut + it == 0) {
		timespecclear(up);
		timespecclear(sp);
		if (ip != NULL)
			timespecclear(ip);
		return;
	}

	freq = stathz ? stathz : hz;

	st = st * 1000000000 / freq;
	sp->tv_sec = st / 1000000000;
	sp->tv_nsec = st % 1000000000;
	ut = ut * 1000000000 / freq;
	up->tv_sec = ut / 1000000000;
	up->tv_nsec = ut % 1000000000;
	if (ip != NULL) {
		it = it * 1000000000 / freq;
		ip->tv_sec = it / 1000000000;
		ip->tv_nsec = it % 1000000000;
	}
}

void
calcru(struct tusage *tup, struct timeval *up, struct timeval *sp,
    struct timeval *ip)
{
	struct timespec u, s, i;

	calctsru(tup, &u, &s, ip != NULL ? &i : NULL);
	TIMESPEC_TO_TIMEVAL(up, &u);
	TIMESPEC_TO_TIMEVAL(sp, &s);
	if (ip != NULL)
		TIMESPEC_TO_TIMEVAL(ip, &i);
}

int
sys_getrusage(struct proc *p, void *v, register_t *retval)
{
	struct sys_getrusage_args /* {
		syscallarg(int) who;
		syscallarg(struct rusage *) rusage;
	} */ *uap = v;
	struct rusage ru;
	int error;

	error = dogetrusage(p, SCARG(uap, who), &ru);
	if (error == 0) {
		error = copyout(&ru, SCARG(uap, rusage), sizeof(ru));
#ifdef KTRACE
		if (error == 0 && KTRPOINT(p, KTR_STRUCT))
			ktrrusage(p, &ru);
#endif
	}
	return (error);
}

int
dogetrusage(struct proc *p, int who, struct rusage *rup)
{
	struct process *pr = p->p_p;
	struct proc *q;

	switch (who) {

	case RUSAGE_SELF:
		/* start with the sum of dead threads, if any */
		if (pr->ps_ru != NULL)
			*rup = *pr->ps_ru;
		else
			memset(rup, 0, sizeof(*rup));

		/* add on all living threads */
		TAILQ_FOREACH(q, &pr->ps_threads, p_thr_link) {
			ruadd(rup, &q->p_ru);
			tuagg(pr, q);
		}

		calcru(&pr->ps_tu, &rup->ru_utime, &rup->ru_stime, NULL);
		break;

	case RUSAGE_THREAD:
		*rup = p->p_ru;
		calcru(&p->p_tu, &rup->ru_utime, &rup->ru_stime, NULL);
		break;

	case RUSAGE_CHILDREN:
		*rup = pr->ps_cru;
		break;

	default:
		return (EINVAL);
	}
	return (0);
}

void
ruadd(struct rusage *ru, struct rusage *ru2)
{
	long *ip, *ip2;
	int i;

	timeradd(&ru->ru_utime, &ru2->ru_utime, &ru->ru_utime);
	timeradd(&ru->ru_stime, &ru2->ru_stime, &ru->ru_stime);
	if (ru->ru_maxrss < ru2->ru_maxrss)
		ru->ru_maxrss = ru2->ru_maxrss;
	ip = &ru->ru_first; ip2 = &ru2->ru_first;
	for (i = &ru->ru_last - &ru->ru_first; i >= 0; i--)
		*ip++ += *ip2++;
}

struct pool plimit_pool;

/*
 * Make a copy of the plimit structure.
 * We share these structures copy-on-write after fork,
 * and copy when a limit is changed.
 */
struct plimit *
limcopy(struct plimit *lim)
{
	struct plimit *newlim;
	static int initialized;

	if (!initialized) {
		pool_init(&plimit_pool, sizeof(struct plimit), 0, IPL_NONE,
		    PR_WAITOK, "plimitpl", NULL);
		initialized = 1;
	}

	newlim = pool_get(&plimit_pool, PR_WAITOK);
	memcpy(newlim->pl_rlimit, lim->pl_rlimit,
	    sizeof(struct rlimit) * RLIM_NLIMITS);
	newlim->p_refcnt = 1;
	return (newlim);
}

void
limfree(struct plimit *lim)
{
	if (--lim->p_refcnt > 0)
		return;
	pool_put(&plimit_pool, lim);
}
@


1.56
log
@pool_setipl

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.55 2015/12/05 10:11:53 tedu Exp $	*/
d509 2
a510 3
		pool_init(&plimit_pool, sizeof(struct plimit), 0, 0, PR_WAITOK,
		    "plimitpl", NULL);
		pool_setipl(&plimit_pool, IPL_NONE);
@


1.55
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.54 2015/02/09 09:39:09 miod Exp $	*/
d511 1
@


1.54
log
@Stop using USRSTACK as the edge of the stack, but rather use the vmspace
vm_minsaddr or vm_maxsaddr, depending upon the direction the stack goes in.

This should have no effect on the existing behaviourrr.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.53 2014/12/19 05:59:21 tedu Exp $	*/
a120 1
/* ARGSUSED */
a202 1
/* ARGSUSED */
a313 1
/* ARGSUSED */
a419 1
/* ARGSUSED */
@


1.53
log
@start retiring the nointr allocator. specify PR_WAITOK as a flag as a
marker for which pools are not interrupt safe. ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.52 2014/12/10 02:44:47 tedu Exp $	*/
d282 1
d288 2
a289 1
				addr = USRSTACK + alimp->rlim_cur;
d291 2
a292 1
				addr = USRSTACK - limp->rlim_cur;
d298 2
a299 1
				addr = USRSTACK + limp->rlim_cur;
d301 2
a302 1
				addr = USRSTACK - alimp->rlim_cur;
d307 1
a307 1
			(void) uvm_map_protect(&p->p_vmspace->vm_map,
@


1.52
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.51 2014/11/16 12:31:00 deraadt Exp $	*/
d508 2
a509 2
		pool_init(&plimit_pool, sizeof(struct plimit), 0, 0, 0,
		    "plimitpl", &pool_allocator_nointr);
@


1.51
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.50 2014/03/30 21:54:48 guenther Exp $	*/
d514 1
a514 1
	bcopy(lim->pl_rlimit, newlim->pl_rlimit,
@


1.50
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.49 2014/01/24 04:26:51 guenther Exp $	*/
d284 1
a284 1
				prot = VM_PROT_READ|VM_PROT_WRITE;
d292 1
a292 1
				prot = VM_PROT_NONE;
@


1.49
log
@exit1() needs to do a final aggregation of the thread's [us]ticks
and runtime to the process totals.  Also, add ktracing of struct
rusage in wait4() and getrusage().

problem pointed out by tedu@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.48 2014/01/21 01:48:44 tedu Exp $	*/
d107 1
a107 1
			if (pr->ps_cred->pc_ucred->cr_uid == SCARG(uap, who) &&
d164 1
a164 1
			if (pr->ps_cred->pc_ucred->cr_uid == SCARG(uap, who)) {
d181 1
a181 1
	struct pcred *pcred = curp->p_cred;
d185 3
a187 3
	if (pcred->pc_ucred->cr_uid && pcred->p_ruid &&
	    pcred->pc_ucred->cr_uid != chgpr->ps_cred->pc_ucred->cr_uid &&
	    pcred->p_ruid != chgpr->ps_cred->pc_ucred->cr_uid)
@


1.48
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.47 2014/01/20 21:19:28 guenther Exp $	*/
a55 1
void	tuagg(struct process *, struct proc *);
d430 1
a430 1
	if (error == 0)
d432 5
@


1.47
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.46 2013/10/25 04:42:48 guenther Exp $	*/
d449 1
a449 1
			bzero(rup, sizeof(*rup));
@


1.46
log
@Move the declarations for dogetrusage(), itimerround(), and dowait4()
to sys/*.h headers so that the compat/linux code can use them.
Change dowait4() to not copyout() the status value, but rather leave
that for its caller, as compat/linux has to translate it, with the
side benefit of simplifying the native code.

Originally written months ago as part of the time_t work; long
memory, prodding, and ok from pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.45 2013/09/14 03:06:41 guenther Exp $	*/
a75 1
	struct proc *p;
d107 4
a110 5
		LIST_FOREACH(p, &allproc, p_list)
			if ((p->p_flag & P_THREAD) == 0 &&
			    p->p_ucred->cr_uid == SCARG(uap, who) &&
			    p->p_p->ps_nice < low)
				low = p->p_p->ps_nice;
d161 1
a161 2
	case PRIO_USER: {
		struct proc *p;
d164 3
a166 4
		LIST_FOREACH(p, &allproc, p_list)
			if ((p->p_flag & P_THREAD) == 0 &&
			    p->p_ucred->cr_uid == SCARG(uap, who)) {
				error = donice(curp, p->p_p, SCARG(uap, prio));
a169 1
	}
@


1.45
log
@Eliminate the unused retval argument from dogetrusage()
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.44 2013/09/14 01:35:00 guenther Exp $	*/
a422 2

int	dogetrusage(struct proc *, int, struct rusage *);
@


1.44
log
@Snapshots for all archs have been built, so remove the T32 code
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.43 2013/08/13 05:52:23 guenther Exp $	*/
d424 1
a424 1
int	dogetrusage(struct proc *, int, struct rusage *, register_t *);
d437 1
a437 1
	error = dogetrusage(p, SCARG(uap, who), &ru, retval);
d444 1
a444 1
dogetrusage(struct proc *p, int who, struct rusage *rup, register_t *retval)
@


1.43
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.42 2013/06/03 16:55:22 guenther Exp $	*/
a441 22

#ifdef T32
int
t32_sys_getrusage(struct proc *p, void *v, register_t *retval)
{
	struct sys_getrusage_args /* {
		syscallarg(int) who;
		syscallarg(struct rusage32 *) rusage;
	} */ *uap = v;
	struct rusage ru;
	int error;

	error = dogetrusage(p, SCARG(uap, who), &ru, retval);
	if (error == 0) {
		struct rusage32 ru32;

		RUSAGE_TO_32(&ru32, &ru);
		error = copyout(&ru32, SCARG(uap, rusage), sizeof(ru32));
	}
	return (error);
}
#endif
@


1.42
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.41 2013/04/01 01:07:34 guenther Exp $	*/
d424 1
d434 34
a469 2
	struct rusage ru;
	struct rusage *rup;
d471 1
a471 1
	switch (SCARG(uap, who)) {
d476 1
a476 1
			ru = *pr->ps_ru;
d478 1
a478 2
			bzero(&ru, sizeof(ru));
		rup = &ru;
d490 1
a490 1
		rup = &p->p_ru;
d495 1
a495 1
		rup = &pr->ps_cru;
d501 1
a501 2
	return (copyout((caddr_t)rup, (caddr_t)SCARG(uap, rusage),
	    sizeof (struct rusage)));
@


1.41
log
@Make setrlimit() return EINVAL if rlim_cur > rlim_max, per POSIX.
Use limfree() instead of decrementing the reference counter directly.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.40 2012/04/10 15:50:52 guenther Exp $	*/
d342 1
a342 1
	timeradd(&tup->tu_runtime, &p->p_rtime, &tup->tu_runtime);
d357 1
a357 1
	timerclear(&p->p_rtime);
d378 2
a379 2
calcru(struct tusage *tup, struct timeval *up, struct timeval *sp,
    struct timeval *ip)
d389 2
a390 2
		timerclear(up);
		timerclear(sp);
d392 1
a392 1
			timerclear(ip);
d398 6
a403 6
	st = st * 1000000 / freq;
	sp->tv_sec = st / 1000000;
	sp->tv_usec = st % 1000000;
	ut = ut * 1000000 / freq;
	up->tv_sec = ut / 1000000;
	up->tv_usec = ut % 1000000;
d405 3
a407 3
		it = it * 1000000 / freq;
		ip->tv_sec = it / 1000000;
		ip->tv_usec = it % 1000000;
d410 14
@


1.40
log
@Make the KERN_NPROCS and KERN_MAXPROC sysctl()s and the RLIMIT_NPROC rlimit
count processes instead of threads.  New sysctl()s KERN_NTHREADS and
KERN_MAXTHREAD count and limit threads.  The nprocs and maxproc kernel
variables are replaced by nprocess, maxprocess, nthreads, and maxthread.

ok tedu@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.39 2012/03/23 15:51:26 guenther Exp $	*/
d239 1
a239 1
	if (which >= RLIM_NLIMITS)
d243 1
a243 2
	if (limp->rlim_cur > alimp->rlim_max ||
	    limp->rlim_max > alimp->rlim_max)
d251 1
a251 1
		l->p_refcnt--;
@


1.39
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.38 2012/03/19 09:05:39 guenther Exp $	*/
d267 1
a267 1
		maxlim = maxproc;
@


1.38
log
@Add tracing and dumping of "pointer to struct" syscall arguments for
structs timespec, timeval, sigaction, and rlimit.

ok otto@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.37 2011/03/07 07:07:13 guenther Exp $	*/
d55 3
d340 34
d375 2
a376 2
 * Transform the running time and tick information in proc p into user,
 * system, and interrupt time usage.
d379 1
a379 1
calcru(struct proc *p, struct timeval *up, struct timeval *sp,
a383 1
	int s;
d385 3
a387 5
	s = splstatclock();
	st = p->p_sticks;
	ut = p->p_uticks;
	it = p->p_iticks;
	splx(s);
d421 1
d428 5
a432 3
		calcru(p, &p->p_stats->p_ru.ru_utime,
		    &p->p_stats->p_ru.ru_stime, NULL);
		ru = p->p_stats->p_ru;
d435 5
a439 1
		/* XXX add on already dead threads */
d441 1
a441 14
		/* add on other living threads */
		{
			struct proc *q;

			TAILQ_FOREACH(q, &pr->ps_threads, p_thr_link) {
				if (q == p || P_ZOMBIE(q))
					continue;
				/*
				 * XXX this is approximate: no call
				 * to calcru in other running threads
				 */
				ruadd(rup, &q->p_stats->p_ru);
			}
		}
d445 2
a446 3
		rup = &p->p_stats->p_ru;
		calcru(p, &rup->ru_utime, &rup->ru_stime, NULL);
		ru = *rup;
d450 1
a450 1
		rup = &p->p_stats->p_cru;
@


1.37
log
@The scheduling 'nice' value is per-process, not per-thread, so move it
into struct process.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.36 2010/07/26 01:56:27 guenther Exp $	*/
d47 1
d222 4
d323 2
d328 7
a334 2
	return (copyout((caddr_t)&p->p_rlimit[SCARG(uap, which)],
	    (caddr_t)SCARG(uap, rlp), sizeof (struct rlimit)));
@


1.36
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.35 2010/06/29 20:14:46 guenther Exp $	*/
d84 2
a85 4
		TAILQ_FOREACH(p, &pr->ps_threads, p_thr_link) {
			if (p->p_nice < low)
				low = p->p_nice;
		}
d96 2
a97 4
			TAILQ_FOREACH(p, &pr->ps_threads, p_thr_link) {
				if (p->p_nice < low)
					low = p->p_nice;
			}
d105 4
a108 3
			if (p->p_ucred->cr_uid == SCARG(uap, who) &&
			    p->p_nice < low)
				low = p->p_nice;
d196 1
a196 2
	/* XXX wrong: p_nice should be in process */
	if (n < chgpr->ps_mainproc->p_nice && suser(curp, 0))
d198 1
a198 1
	chgpr->ps_mainproc->p_nice = n;
@


1.35
log
@Eliminate struct plimit's PL_SHAREMOD flag: it was for COMPAT_IRIX
sproc() support, but we don't have COMPAT_IRIX.
ok krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.34 2010/01/04 02:48:56 guenther Exp $	*/
d71 1
d79 1
a79 1
			p = curp;
d81 2
a82 2
			p = pfind(SCARG(uap, who));
		if (p == 0)
d84 4
a87 1
		low = p->p_nice;
d94 1
a94 1
			pg = curp->p_pgrp;
d97 5
a101 4
		LIST_FOREACH(p, &pg->pg_members, p_pglist) {
			if (p->p_nice < low)
				low = p->p_nice;
		}
d132 1
a132 1
	struct proc *p;
d139 1
a139 1
			p = curp;
d141 2
a142 2
			p = pfind(SCARG(uap, who));
		if (p == 0)
d144 1
a144 1
		error = donice(curp, p, SCARG(uap, prio));
d152 1
a152 1
			pg = curp->p_pgrp;
d155 2
a156 2
		LIST_FOREACH(p, &pg->pg_members, p_pglist) {
			error = donice(curp, p, SCARG(uap, prio));
d162 2
a163 1
	case PRIO_USER:
d167 3
a169 2
			if (p->p_ucred->cr_uid == SCARG(uap, who)) {
				error = donice(curp, p, SCARG(uap, prio));
d173 1
d184 1
a184 1
donice(struct proc *curp, struct proc *chgp, int n)
d187 1
d191 2
a192 2
	    pcred->pc_ucred->cr_uid != chgp->p_ucred->cr_uid &&
	    pcred->p_ruid != chgp->p_ucred->cr_uid)
d199 2
a200 1
	if (n < chgp->p_nice && suser(curp, 0))
d202 1
a202 1
	chgp->p_nice = n;
d204 2
a205 1
	(void)resetpriority(chgp);
d378 2
d385 24
d411 1
@


1.34
log
@Don't decrement the refcnt on a plimits until after we're done
copying it, so that the process can't sleep in pool_get() and have
the source structure get pool_put() or modified behind its back.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.33 2008/05/22 17:04:59 thib Exp $	*/
d232 1
a232 2
	if (p->p_p->ps_limit->p_refcnt > 1 &&
	    (p->p_p->ps_limit->p_lflags & PL_SHAREMOD) == 0) {
a423 1
	newlim->p_lflags = 0;
@


1.33
log
@Use LIST_FOREACH() instead of handrolling.

From: Pierre Riteau pierre.riteau_att_gmail.com
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.32 2007/04/12 22:14:15 tedu Exp $	*/
d234 5
a238 2
		p->p_p->ps_limit->p_refcnt--;
		p->p_p->ps_limit = limcopy(p->p_p->ps_limit);
@


1.32
log
@move p_limit and p_cred into struct process
leave macros behind for now to keep the commit small
ok art beck miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.31 2005/11/28 00:14:29 jsg Exp $	*/
d103 1
a103 1
		for (p = LIST_FIRST(&allproc); p; p = LIST_NEXT(p, p_list))
d160 1
a160 1
		for (p = LIST_FIRST(&allproc); p; p = LIST_NEXT(p, p_list))
@


1.31
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.30 2005/05/29 03:20:41 deraadt Exp $	*/
d232 4
a235 4
	if (p->p_limit->p_refcnt > 1 &&
	    (p->p_limit->p_lflags & PL_SHAREMOD) == 0) {
		p->p_limit->p_refcnt--;
		p->p_limit = limcopy(p->p_limit);
@


1.30
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.28 2004/12/26 21:22:13 miod Exp $	*/
d65 1
a65 4
sys_getpriority(curp, v, retval)
	struct proc *curp;
	void *v;
	register_t *retval;
d67 1
a67 1
	register struct sys_getpriority_args /* {
d71 2
a72 2
	register struct proc *p;
	register int low = NZERO + PRIO_MAX + 1;
d87 1
a87 1
		register struct pgrp *pg;
d120 1
a120 4
sys_setpriority(curp, v, retval)
	struct proc *curp;
	void *v;
	register_t *retval;
d122 1
a122 1
	register struct sys_setpriority_args /* {
d127 1
a127 1
	register struct proc *p;
d144 1
a144 1
		register struct pgrp *pg;
d176 1
a176 3
donice(curp, chgp, n)
	register struct proc *curp, *chgp;
	register int n;
d178 1
a178 1
	register struct pcred *pcred = curp->p_cred;
d201 1
a201 4
sys_setrlimit(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d203 1
a203 1
	register struct sys_setrlimit_args /* {
d218 1
a218 4
dosetrlimit(p, which, limp)
	struct proc *p;
	u_int which;
	struct rlimit *limp;
d303 1
a303 4
sys_getrlimit(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d305 1
a305 1
	register struct sys_getrlimit_args /* {
d321 2
a322 5
calcru(p, up, sp, ip)
	struct proc *p;
	struct timeval *up;
	struct timeval *sp;
	struct timeval *ip;
d359 1
a359 4
sys_getrusage(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
d361 1
a361 1
	register struct sys_getrusage_args /* {
d365 1
a365 1
	register struct rusage *rup;
d386 1
a386 2
ruadd(ru, ru2)
	register struct rusage *ru, *ru2;
d388 2
a389 2
	register long *ip, *ip2;
	register int i;
@


1.29
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@d202 1
a202 1
	resetpriority(chgp);
@


1.28
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.27 2004/06/13 21:49:26 niklas Exp $	*/
d202 1
a202 1
	(void)resetpriority(chgp);
@


1.27
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d96 1
a96 1
		for (p = pg->pg_members.lh_first; p != 0; p = p->p_pglist.le_next) {
d156 1
a156 2
		for (p = pg->pg_members.lh_first; p != 0;
		    p = p->p_pglist.le_next) {
@


1.26
log
@Add id_t type as per POSIX and use it for [gs]etpriority(2).
OK henning@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.25 2003/12/11 22:55:22 millert Exp $	*/
d47 1
d188 1
d202 1
d204 1
@


1.25
log
@POSIX says rlim_t should be unsigned so make it u_quad_t.  Also add
POSIX-mandated RLIM_SAVED_MAX and RLIM_SAVED_CUR defines.  On OpenBSD
these are identical to RLIM_INFINITY as allowed by POSIX.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.24 2003/09/01 18:06:03 henning Exp $	*/
d71 1
a71 1
		syscallarg(int) who;
d129 1
a129 1
		syscallarg(int) who;
@


1.24
log
@match syscallargs comments with reality
from Patrick Latifi <patrick.l@@hermes.usherb.ca>
ok jason@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.23 2003/08/15 20:32:18 tedu Exp $	*/
a235 3
		return (EINVAL);

	if (limp->rlim_cur < 0 || limp->rlim_max < 0)
@


1.23
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.22 2003/06/02 23:28:05 millert Exp $	*/
d213 1
a213 1
		syscallarg(struct rlimit *) rlp;
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.21 2002/10/15 01:27:31 nordin Exp $	*/
d197 1
a197 1
	if (n < chgp->p_nice && suser(pcred->pc_ucred, &curp->p_acflag))
d244 1
a244 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.21
log
@Match reality by changing (u_int) -> (int) in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.20 2002/10/02 21:56:30 nordin Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.20
log
@Check for negative values. Inspiration from tedu <grendel@@zeitbombe.org>.
ok deraadt@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.19 2002/07/21 21:29:33 art Exp $	*/
d216 1
a216 1
		syscallarg(u_int) which;
@


1.20.2.1
log
@Pull in patch from current:
Fix (nordin):
Check for negative values. Inspiration from tedu <grendel@@zeitbombe.org>.
ok deraadt@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.21 2002/10/15 01:27:31 nordin Exp $	*/
d216 1
a216 1
		syscallarg(int) which;
@


1.19
log
@Map stack pages without VM_PROT_EXECUTE. Notice that right now this
doesn't do anything since no pmap implements exec protection yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.18 2002/01/25 14:54:00 art Exp $	*/
d327 1
a327 1
		syscallarg(u_int) which;
d331 1
a331 1
	if (SCARG(uap, which) >= RLIM_NLIMITS)
@


1.18
log
@Convert plimit allocations to pool.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.17 2001/12/20 21:56:19 nordin Exp $	*/
d292 1
a292 1
				prot = VM_PROT_ALL;
@


1.18.2.1
log
@MFC (nordin):
Check for negative values. Inspiration from tedu <grendel@@zeitbombe.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.18 2002/01/25 14:54:00 art Exp $	*/
d327 1
a327 1
		syscallarg(int) which;
d331 1
a331 1
	if (SCARG(uap, which) < 0 || SCARG(uap, which) >= RLIM_NLIMITS)
@


1.18.2.2
log
@MFC:
Check for negative values. Inspiration from tedu <grendel@@zeitbombe.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.18.2.1 2002/10/13 20:54:54 miod Exp $	*/
d216 1
a216 1
		syscallarg(int) which;
@


1.17
log
@Make user/system times increase monotonically. ok deraadt@@ and millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.16 2001/11/10 19:20:39 art Exp $	*/
d49 1
a49 1
#include <sys/malloc.h>
d428 2
d436 1
a436 2
limcopy(lim)
	struct plimit *lim;
d438 8
a445 1
	register struct plimit *newlim;
d447 1
a447 2
	MALLOC(newlim, struct plimit *, sizeof(struct plimit),
	    M_SUBPROC, M_WAITOK);
d456 1
a456 2
limfree(lim)
	struct plimit *lim;
a457 1

d460 1
a460 1
	FREE(lim, M_SUBPROC);
@


1.16
log
@Move maxdmap and maxsmap to kern_resource.c
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.15 2001/11/06 19:53:20 miod Exp $	*/
d343 4
a346 4
	register struct proc *p;
	register struct timeval *up;
	register struct timeval *sp;
	register struct timeval *ip;
d348 3
a350 4
	register u_quad_t u, st, ut, it, tot;
	register long sec, usec;
	register int s;
	struct timeval tv;
d358 3
a360 4
	tot = st + ut + it;
	if (tot == 0) {
		up->tv_sec = up->tv_usec = 0;
		sp->tv_sec = sp->tv_usec = 0;
d362 1
a362 1
			ip->tv_sec = ip->tv_usec = 0;
d366 3
a368 14
	sec = p->p_rtime.tv_sec;
	usec = p->p_rtime.tv_usec;
	if (p == curproc) {
		/*
		 * Adjust for the current time slice.  This is actually fairly
		 * important since the error here is on the order of a time
		 * quantum, which is much greater than the sampling error.
		 */
		microtime(&tv);
		sec += tv.tv_sec - runtime.tv_sec;
		usec += tv.tv_usec - runtime.tv_usec;
	}
	u = (u_quad_t) sec * 1000000 + usec;
	st = (u * st) / tot;
d371 1
a371 1
	ut = (u * ut) / tot;
d375 1
a375 1
		it = (u * it) / tot;
@


1.16.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.18 2002/01/25 14:54:00 art Exp $	*/
d49 1
a49 1
#include <sys/pool.h>
d343 9
a351 8
	struct proc *p;
	struct timeval *up;
	struct timeval *sp;
	struct timeval *ip;
{
	u_quad_t st, ut, it;
	int freq;
	int s;
d359 4
a362 3
	if (st + ut + it == 0) {
		timerclear(up);
		timerclear(sp);
d364 1
a364 1
			timerclear(ip);
d368 14
a381 3
	freq = stathz ? stathz : hz;

	st = st * 1000000 / freq;
d384 1
a384 1
	ut = ut * 1000000 / freq;
d388 1
a388 1
		it = it * 1000000 / freq;
a440 2
struct pool plimit_pool;

d447 2
a448 1
limcopy(struct plimit *lim)
d450 1
a450 2
	struct plimit *newlim;
	static int initialized;
d452 2
a453 7
	if (!initialized) {
		pool_init(&plimit_pool, sizeof(struct plimit), 0, 0, 0,
		    "plimitpl", &pool_allocator_nointr);
		initialized = 1;
	}

	newlim = pool_get(&plimit_pool, PR_WAITOK);
d462 2
a463 1
limfree(struct plimit *lim)
d465 1
d468 1
a468 1
	pool_put(&plimit_pool, lim);
@


1.16.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.16.2.1 2002/01/31 22:55:40 niklas Exp $	*/
d216 1
a216 1
		syscallarg(int) which;
d292 1
a292 1
				prot = VM_PROT_READ|VM_PROT_WRITE;
d327 1
a327 1
		syscallarg(int) which;
d331 1
a331 1
	if (SCARG(uap, which) < 0 || SCARG(uap, which) >= RLIM_NLIMITS)
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.14 2001/06/27 04:49:44 art Exp $	*/
d58 6
a235 1
	extern unsigned maxdmap, maxsmap;
@


1.14
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.13 2001/05/26 04:10:26 art Exp $	*/
a53 2

#include <vm/vm.h>
@


1.14.2.1
log
@MFC (nordin):
Check for negative values. Inspiration from tedu <grendel@@zeitbombe.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.14 2001/06/27 04:49:44 art Exp $	*/
d324 1
a324 1
		syscallarg(int) which;
d328 1
a328 1
	if (SCARG(uap, which) < 0 || SCARG(uap, which) >= RLIM_NLIMITS)
@


1.14.2.2
log
@MFC:
Check for negative values. Inspiration from tedu <grendel@@zeitbombe.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.14.2.1 2002/10/13 20:56:46 miod Exp $	*/
d212 1
a212 1
		syscallarg(int) which;
@


1.13
log
@Make it a bit more obvious what dosetrlimit does. (shrink).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.12 2000/05/05 08:34:18 art Exp $	*/
a56 1
#if defined(UVM)
a57 1
#endif
a306 1
#if defined(UVM)
a308 4
#else
			(void) vm_map_protect(&p->p_vmspace->vm_map,
					      addr, addr+size, prot, FALSE);
#endif
@


1.12
log
@Add limfree prototype to sys/recosurcevar.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.11 2000/03/03 11:31:43 art Exp $	*/
d233 1
a233 1
	register struct rlimit *alimp;
d235 1
d245 1
a245 1
	if (limp->rlim_cur > alimp->rlim_max || 
a248 2
	if (limp->rlim_cur > limp->rlim_max)
		limp->rlim_cur = limp->rlim_max;
a256 1

d258 10
a267 4
		if (limp->rlim_cur > maxdmap)
			limp->rlim_cur = maxdmap;
		if (limp->rlim_max > maxdmap)
			limp->rlim_max = maxdmap;
d269 4
d274 6
a279 5
	case RLIMIT_STACK:
		if (limp->rlim_cur > maxsmap)
			limp->rlim_cur = maxsmap;
		if (limp->rlim_max > maxsmap)
			limp->rlim_max = maxsmap;
d317 1
a317 1
		break;
a318 14
	case RLIMIT_NOFILE:
		if (limp->rlim_cur > maxfiles)
			limp->rlim_cur = maxfiles;
		if (limp->rlim_max > maxfiles)
			limp->rlim_max = maxfiles;
		break;

	case RLIMIT_NPROC:
		if (limp->rlim_cur > maxproc)
			limp->rlim_cur = maxproc;
		if (limp->rlim_max > maxproc)
			limp->rlim_max = maxproc;
		break;
	}
@


1.11
log
@Use LIST_ macros instead of internal field names to walk the allproc list.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.10 1999/11/05 01:18:01 mickey Exp $	*/
a60 1
void limfree __P((struct plimit *));
@


1.10
log
@more stack direction fixes; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.9 1999/07/15 14:07:41 art Exp $	*/
d108 1
a108 1
		for (p = allproc.lh_first; p != 0; p = p->p_list.le_next)
d169 1
a169 1
		for (p = allproc.lh_first; p != 0; p = p->p_list.le_next)
@


1.10.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d108 1
a108 1
		for (p = LIST_FIRST(&allproc); p; p = LIST_NEXT(p, p_list))
d169 1
a169 1
		for (p = LIST_FIRST(&allproc); p; p = LIST_NEXT(p, p_list))
@


1.10.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.12 2000/05/05 08:34:18 art Exp $	*/
d61 1
@


1.10.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.10.2.2 2001/05/14 22:32:41 niklas Exp $	*/
d57 1
d59 1
d233 1
a233 1
	struct rlimit *alimp;
a234 1
	rlim_t maxlim;
d244 1
a244 1
	if (limp->rlim_cur > alimp->rlim_max ||
d248 2
d258 1
d260 4
a263 1
		maxlim = maxdmap;
d265 1
d267 4
a270 19
		maxlim = maxsmap;
		break;
	case RLIMIT_NOFILE:
		maxlim = maxfiles;
		break;
	case RLIMIT_NPROC:
		maxlim = maxproc;
		break;
	default:
		maxlim = RLIM_INFINITY;
		break;
	}

	if (limp->rlim_max > maxlim)
		limp->rlim_max = maxlim;
	if (limp->rlim_cur > limp->rlim_max)
		limp->rlim_cur = limp->rlim_max;

	if (which == RLIMIT_STACK) {
d300 1
d303 4
d308 15
a323 1

@


1.10.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 2
a59 6
 * Patchable maximum data and stack limits.
 */
rlim_t maxdmap = MAXDSIZ;
rlim_t maxsmap = MAXSSIZ;

/*
d232 1
@


1.10.2.5
log
@Merge in trunk
@
text
@d49 1
a49 1
#include <sys/pool.h>
d343 9
a351 8
	struct proc *p;
	struct timeval *up;
	struct timeval *sp;
	struct timeval *ip;
{
	u_quad_t st, ut, it;
	int freq;
	int s;
d359 4
a362 3
	if (st + ut + it == 0) {
		timerclear(up);
		timerclear(sp);
d364 1
a364 1
			timerclear(ip);
d368 14
a381 3
	freq = stathz ? stathz : hz;

	st = st * 1000000 / freq;
d384 1
a384 1
	ut = ut * 1000000 / freq;
d388 1
a388 1
		it = it * 1000000 / freq;
a440 2
struct pool plimit_pool;

d447 2
a448 1
limcopy(struct plimit *lim)
d450 1
a450 2
	struct plimit *newlim;
	static int initialized;
d452 2
a453 7
	if (!initialized) {
		pool_init(&plimit_pool, sizeof(struct plimit), 0, 0, 0,
		    "plimitpl", &pool_allocator_nointr);
		initialized = 1;
	}

	newlim = pool_get(&plimit_pool, PR_WAITOK);
d462 2
a463 1
limfree(struct plimit *lim)
d465 1
d468 1
a468 1
	pool_put(&plimit_pool, lim);
@


1.10.2.6
log
@Sync the SMP branch with 3.3
@
text
@d216 1
a216 1
		syscallarg(int) which;
d292 1
a292 1
				prot = VM_PROT_READ|VM_PROT_WRITE;
d327 1
a327 1
		syscallarg(int) which;
d331 1
a331 1
	if (SCARG(uap, which) < 0 || SCARG(uap, which) >= RLIM_NLIMITS)
@


1.10.2.7
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.10.2.6 2003/03/28 00:41:26 niklas Exp $	*/
a190 1
	int s;
a203 1
	SCHED_LOCK(s);
a204 1
	SCHED_UNLOCK(s);
@


1.10.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.10.2.7 2003/05/15 04:08:02 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 1
a71 1
		syscallarg(id_t) who;
d129 1
a129 1
		syscallarg(id_t) who;
d198 1
a198 1
	if (n < chgp->p_nice && suser(curp, 0))
d216 1
a216 1
		syscallarg(const struct rlimit *) rlp;
d241 3
d247 1
a247 1
		if ((error = suser(p, 0)) != 0)
@


1.10.2.10
log
@few fixes to make non-smp compile
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.10.2.9 2004/02/19 10:56:37 niklas Exp $	*/
a46 1
#include <sys/sched.h>
@


1.9
log
@vm_offset_t -> {v,p}addr_t ; vm_size_t -> {v,p}size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.8 1999/02/26 05:10:40 art Exp $	*/
d285 3
d289 1
d293 3
d297 1
@


1.8
log
@uvm allocation and name changes
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.7 1996/11/24 23:33:43 millert Exp $	*/
d278 2
a279 2
			vm_offset_t addr;
			vm_size_t size;
@


1.7
log
@Sync with NetBSD.  Figure NZERO into priorities and that rlim_cur
and rlim_max are >0.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.6 1996/07/27 11:07:30 deraadt Exp $	*/
d57 4
d293 4
d299 1
@


1.6
log
@sec can be a long
@
text
@d1 2
a2 2
/*	$OpenBSD: kern_resource.c,v 1.5 1996/07/02 09:23:19 deraadt Exp $	*/
/*	$NetBSD: kern_resource.c,v 1.34.4.1 1996/06/13 23:31:14 jtc Exp $	*/
d73 1
a73 1
	register int low = PRIO_MAX + 1;
d113 1
a113 1
	if (low == PRIO_MAX + 1)
d115 1
a115 1
	*retval = low;
d195 1
d236 4
@


1.5
log
@unsigned usec can go negative, should be added in as is; netbsd pr#2585; Juergen.Fluk@@lrz.tu-muenchen.de
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.4 1996/06/20 10:54:36 deraadt Exp $	*/
d337 1
a337 2
	register u_long sec;
	register long usec;
@


1.4
log
@calcru() must calculate using u_quad_t to avoid overflows; netbsd pr#2496, brb@@exp.com
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_resource.c,v 1.3 1996/03/03 17:19:53 niklas Exp $	*/
d337 2
a338 1
	register u_long sec, usec;
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: kern_resource.c,v 1.34 1996/02/09 18:59:44 christos Exp $	*/
d368 1
a368 1
	u = sec * 1000000 + usec;
@


1.2
log
@from netbsd; limfree()
@
text
@d1 2
a2 1
/*	$NetBSD: kern_resource.c,v 1.32 1995/12/09 04:09:34 mycroft Exp $	*/
d57 1
a57 3
int	donice __P((struct proc *curp, struct proc *chgp, int n));
int	dosetrlimit __P((struct proc *p, u_int which, struct rlimit *limp));

d216 3
a218 2
	if (error = copyin((caddr_t)SCARG(uap, rlp), (caddr_t)&alim,
	    sizeof (struct rlimit)))
d238 1
a238 1
		if (error = suser(p->p_ucred, &p->p_acflag))
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: kern_resource.c,v 1.31 1995/10/07 06:28:23 mycroft Exp $	*/
d438 1
a438 1
	register struct plimit *copy;
d440 1
a440 1
	MALLOC(copy, struct plimit *, sizeof(struct plimit),
d442 1
a442 1
	bcopy(lim->pl_rlimit, copy->pl_rlimit,
d444 13
a456 3
	copy->p_lflags = 0;
	copy->p_refcnt = 1;
	return (copy);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
