head	1.65;
access;
symbols
	OPENBSD_6_2:1.65.0.4
	OPENBSD_6_2_BASE:1.65
	OPENBSD_6_1:1.63.0.6
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.63.0.2
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.54.0.4
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.46.0.6
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.45.0.8
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.6
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.4
	OPENBSD_5_0:1.45.0.2
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.43.0.2
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.40.0.2
	OPENBSD_4_7_BASE:1.40
	OPENBSD_4_6:1.39.0.4
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.38.0.6
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.4
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.38.0.2
	OPENBSD_4_3_BASE:1.38
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.35.0.4
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.19.0.6
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.21
	UBC:1.19.0.4
	UBC_BASE:1.19
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.17.0.10
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.17.0.8
	OPENBSD_2_7_BASE:1.17
	SMP:1.17.0.6
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.4
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.65
date	2017.08.29.02.51.27;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	rqeb3Cn0JHXrssFn;

1.64
date	2017.08.15.02.27.51;	author tedu;	state Exp;
branches;
next	1.63;
commitid	snBl6B8Aa3nsfiy5;

1.63
date	2016.04.29.14.40.36;	author beck;	state Exp;
branches;
next	1.62;
commitid	p3EbVWCYrcYkiFMB;

1.62
date	2016.04.28.14.25.08;	author beck;	state Exp;
branches;
next	1.61;
commitid	0n3rYqVGfgJRKpEF;

1.61
date	2016.04.25.20.00.33;	author tedu;	state Exp;
branches;
next	1.60;
commitid	MLNYUlvoOtU8VX0s;

1.60
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.59;
commitid	gAjwyca5TfuoJAhn;

1.59
date	2015.11.02.16.31.55;	author semarie;	state Exp;
branches;
next	1.58;
commitid	PyvdcQVr9G4daVnG;

1.58
date	2015.11.01.19.03.33;	author semarie;	state Exp;
branches;
next	1.57;
commitid	VKRkUfXZQNJ8UQeY;

1.57
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	av6ZVErLSWkVP5Zz;

1.56
date	2015.09.11.08.22.31;	author guenther;	state Exp;
branches;
next	1.55;
commitid	Lqreadw8v5IPAc0L;

1.55
date	2015.08.22.20.18.50;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	6NDuzTPjBp2GqkfQ;

1.54
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	CJwjm9NDWu6nJ6ES;

1.53
date	2015.04.23.02.55.15;	author jsg;	state Exp;
branches;
next	1.52;
commitid	DNOLgcIgVONrhDO8;

1.52
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.51;
commitid	p4LJxGKbi0BU2cG6;

1.51
date	2015.01.19.18.05.41;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	4pbL83QcUYsiMFjA;

1.50
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.49;
commitid	P6Av4XGqOi3rFasL;

1.49
date	2014.12.10.02.44.47;	author tedu;	state Exp;
branches;
next	1.48;
commitid	tsoJBlEBSyYO22RG;

1.48
date	2014.12.03.04.17.15;	author tedu;	state Exp;
branches;
next	1.47;
commitid	b8v07WEVit2qfL0U;

1.47
date	2014.03.25.04.04.36;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.30.04.53.09;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2011.07.22.00.22.57;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.07.23.45.00;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	2010.09.09.10.37.03;	author thib;	state Exp;
branches;
next	1.42;

1.42
date	2010.05.20.02.32.02;	author marco;	state Exp;
branches;
next	1.41;

1.41
date	2010.05.19.08.31.23;	author thib;	state Exp;
branches;
next	1.40;

1.40
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.39;

1.39
date	2009.03.09.16.56.55;	author blambert;	state Exp;
branches;
next	1.38;

1.38
date	2008.03.04.15.30.18;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.08.01.45.58;	author hshoexer;	state Exp;
branches;
next	1.36;

1.36
date	2007.08.07.07.41.59;	author thib;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.25.15.01.53;	author sturm;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.23.22.20.39;	author sturm;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.14.20.01.50;	author sturm;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.30.14.20.07;	author sturm;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.30.10.35.07;	author pedro;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.08.15.43.44;	author pedro;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.26.00.33.45;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2004.07.11.16.42.45;	author pedro;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.14.04.00.33;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.08.16.30.01;	author sturm;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.23.28.07;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.06.20.42.51;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.04.00.22.12;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2003.01.31.17.37.50;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.27.16.04.42;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.02.04.23.25;	author ericj;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.22.14.14.10;	author deraadt;	state Exp;
branches
	1.19.4.1;
next	1.18;

1.18
date	2000.11.10.18.15.48;	author art;	state Exp;
branches;
next	1.17;

1.17
date	99.04.16.14.04.41;	author deraadt;	state Exp;
branches
	1.17.6.1;
next	1.16;

1.16
date	99.01.11.05.12.24;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.08.07.01.56.11;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	98.01.09.16.21.56;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	98.01.09.15.16.20;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	98.01.09.02.11.07;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.11.06.05.58.27;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.10.06.20.20.11;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.15.12.40;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.06.18.17.37.38;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	97.05.21.14.51.26;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	97.03.01.23.03.38;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.11.06.06.51.45;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.11.06.03.54.01;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.10.28.02.57.18;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.20.27;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.47;	author deraadt;	state Exp;
branches;
next	;

1.17.6.1
date	2001.05.14.22.32.46;	author niklas;	state Exp;
branches;
next	1.17.6.2;

1.17.6.2
date	2001.07.04.10.48.52;	author niklas;	state Exp;
branches;
next	1.17.6.3;

1.17.6.3
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.17.6.4;

1.17.6.4
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.17.6.5;

1.17.6.5
date	2003.06.07.11.03.41;	author ho;	state Exp;
branches;
next	1.17.6.6;

1.17.6.6
date	2004.02.19.10.56.39;	author niklas;	state Exp;
branches;
next	1.17.6.7;

1.17.6.7
date	2004.06.05.23.13.03;	author niklas;	state Exp;
branches;
next	;

1.19.4.1
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.19.4.2;

1.19.4.2
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Remove old deactivated pledge path code.  A replacement mechanism is
being brewed.
ok beck
@
text
@/*	$OpenBSD: vfs_lookup.c,v 1.64 2017/08/15 02:27:51 tedu Exp $	*/
/*	$NetBSD: vfs_lookup.c,v 1.17 1996/02/09 19:00:59 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vfs_lookup.c	8.6 (Berkeley) 11/21/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/syslimits.h>
#include <sys/time.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/mount.h>
#include <sys/errno.h>
#include <sys/pool.h>
#include <sys/filedesc.h>
#include <sys/proc.h>
#include <sys/pledge.h>
#include <sys/file.h>
#include <sys/fcntl.h>

#ifdef KTRACE
#include <sys/ktrace.h>
#endif

void
ndinitat(struct nameidata *ndp, u_long op, u_long flags,
    enum uio_seg segflg, int dirfd, const char *namep, struct proc *p)
{
	memset(ndp, 0, sizeof(*ndp));
	ndp->ni_cnd.cn_nameiop = op;
	ndp->ni_cnd.cn_flags = flags;
	ndp->ni_segflg = segflg;
	ndp->ni_dirfd = dirfd;
	ndp->ni_dirp = namep;
	ndp->ni_cnd.cn_proc = p;
}

/*
 * Convert a pathname into a pointer to a vnode.
 *
 * The FOLLOW flag is set when symbolic links are to be followed
 * when they occur at the end of the name translation process.
 * Symbolic links are always followed for all other pathname
 * components other than the last.
 *
 * If the LOCKLEAF flag is set, a locked vnode is returned.
 *
 * The segflg defines whether the name is to be copied from user
 * space or kernel space.
 *
 * Overall outline of namei:
 *
 *	copy in name
 *	get starting directory
 *	while (!done && !error) {
 *		call lookup to search path.
 *		if symbolic link, massage name in buffer and continue
 *	}
 */
int
namei(struct nameidata *ndp)
{
	struct filedesc *fdp;		/* pointer to file descriptor state */
	char *cp;			/* pointer into pathname argument */
	struct vnode *dp;		/* the directory we are searching */
	struct iovec aiov;		/* uio for reading symbolic links */
	struct uio auio;
	int error, linklen;
	struct componentname *cnp = &ndp->ni_cnd;
	struct proc *p = cnp->cn_proc;

	ndp->ni_cnd.cn_cred = ndp->ni_cnd.cn_proc->p_ucred;
#ifdef DIAGNOSTIC
	if (!cnp->cn_cred || !cnp->cn_proc)
		panic ("namei: bad cred/proc");
	if (cnp->cn_nameiop & (~OPMASK))
		panic ("namei: nameiop contaminated with flags");
	if (cnp->cn_flags & OPMASK)
		panic ("namei: flags contaminated with nameiops");
#endif
	fdp = cnp->cn_proc->p_fd;

	/*
	 * Get a buffer for the name to be translated, and copy the
	 * name into the buffer.
	 */
	if ((cnp->cn_flags & HASBUF) == 0)
		cnp->cn_pnbuf = pool_get(&namei_pool, PR_WAITOK);
	if (ndp->ni_segflg == UIO_SYSSPACE)
		error = copystr(ndp->ni_dirp, cnp->cn_pnbuf,
			    MAXPATHLEN, &ndp->ni_pathlen);
	else
		error = copyinstr(ndp->ni_dirp, cnp->cn_pnbuf,
			    MAXPATHLEN, &ndp->ni_pathlen);

	/*
	 * Fail on null pathnames
	 */
	if (error == 0 && ndp->ni_pathlen == 1)
		error = ENOENT;

	if (error) {
fail:
		pool_put(&namei_pool, cnp->cn_pnbuf);
		ndp->ni_vp = NULL;
		return (error);
	}

#ifdef KTRACE
	if (KTRPOINT(cnp->cn_proc, KTR_NAMEI))
		ktrnamei(cnp->cn_proc, cnp->cn_pnbuf);
#endif

	/*
	 *  Strip trailing slashes, as requested
	 */
	if (cnp->cn_flags & STRIPSLASHES) {
		char *end = cnp->cn_pnbuf + ndp->ni_pathlen - 2;

		cp = end;
		while (cp >= cnp->cn_pnbuf && (*cp == '/'))
			cp--;

		/* Still some remaining characters in the buffer */
		if (cp >= cnp->cn_pnbuf) {
			ndp->ni_pathlen -= (end - cp);
			*(cp + 1) = '\0';
		}
	}

	ndp->ni_loopcnt = 0;

	/*
	 * Get starting point for the translation.
	 */
	if ((ndp->ni_rootdir = fdp->fd_rdir) == NULL)
		ndp->ni_rootdir = rootvnode;

	error = pledge_namei(p, ndp, cnp->cn_pnbuf);
	if (error)
		goto fail;

	/*
	 * Check if starting from root directory or current directory.
	 */
	if (cnp->cn_pnbuf[0] == '/') {
		dp = ndp->ni_rootdir;
		vref(dp);
	} else if (ndp->ni_dirfd == AT_FDCWD) {
		dp = fdp->fd_cdir;
		vref(dp);
	} else {
		struct file *fp = fd_getfile(fdp, ndp->ni_dirfd);
		if (fp == NULL) {
			pool_put(&namei_pool, cnp->cn_pnbuf);
			return (EBADF);
		}
		dp = (struct vnode *)fp->f_data;
		if (fp->f_type != DTYPE_VNODE || dp->v_type != VDIR) {
			pool_put(&namei_pool, cnp->cn_pnbuf);
			return (ENOTDIR);
		}
		vref(dp);
	}
	for (;;) {
		if (!dp->v_mount) {
			/* Give up if the directory is no longer mounted */
			pool_put(&namei_pool, cnp->cn_pnbuf);
			return (ENOENT);
		}
		cnp->cn_nameptr = cnp->cn_pnbuf;
		ndp->ni_startdir = dp;
		if ((error = vfs_lookup(ndp)) != 0) {
			pool_put(&namei_pool, cnp->cn_pnbuf);
			return (error);
		}
		/*
		 * If not a symbolic link, return search result.
		 */
		if ((cnp->cn_flags & ISSYMLINK) == 0) {
			if ((cnp->cn_flags & (SAVENAME | SAVESTART)) == 0)
				pool_put(&namei_pool, cnp->cn_pnbuf);
			else
				cnp->cn_flags |= HASBUF;
			return(0);
		}
		if ((cnp->cn_flags & LOCKPARENT) && (cnp->cn_flags & ISLASTCN))
			VOP_UNLOCK(ndp->ni_dvp, p);
		if (ndp->ni_loopcnt++ >= SYMLOOP_MAX) {
			error = ELOOP;
			break;
		}
		if (ndp->ni_pathlen > 1)
			cp = pool_get(&namei_pool, PR_WAITOK);
		else
			cp = cnp->cn_pnbuf;
		aiov.iov_base = cp;
		aiov.iov_len = MAXPATHLEN;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_offset = 0;
		auio.uio_rw = UIO_READ;
		auio.uio_segflg = UIO_SYSSPACE;
		auio.uio_procp = cnp->cn_proc;
		auio.uio_resid = MAXPATHLEN;
		error = VOP_READLINK(ndp->ni_vp, &auio, cnp->cn_cred);
		if (error) {
badlink:
			if (ndp->ni_pathlen > 1)
				pool_put(&namei_pool, cp);
			break;
		}
		linklen = MAXPATHLEN - auio.uio_resid;
		if (linklen == 0) {
			error = ENOENT;
			goto badlink;
		}
		if (linklen + ndp->ni_pathlen >= MAXPATHLEN) {
			error = ENAMETOOLONG;
			goto badlink;
		}
		if (ndp->ni_pathlen > 1) {
			memcpy(cp + linklen, ndp->ni_next, ndp->ni_pathlen);
			pool_put(&namei_pool, cnp->cn_pnbuf);
			cnp->cn_pnbuf = cp;
		} else
			cnp->cn_pnbuf[linklen] = '\0';
		ndp->ni_pathlen += linklen;
		vput(ndp->ni_vp);
		dp = ndp->ni_dvp;
		/*
		 * Check if root directory should replace current directory.
		 */
		if (cnp->cn_pnbuf[0] == '/') {
			vrele(dp);
			dp = ndp->ni_rootdir;
			vref(dp);
		}
	}
	pool_put(&namei_pool, cnp->cn_pnbuf);
	vrele(ndp->ni_dvp);
	vput(ndp->ni_vp);
	ndp->ni_vp = NULL;
	return (error);
}

/*
 * Search a pathname.
 * This is a very central and rather complicated routine.
 *
 * The pathname is pointed to by ni_cnd.cn_nameptr and is of length
 * ni_pathlen.  The starting directory is taken from ni_startdir. The
 * pathname is descended until done, or a symbolic link is encountered.
 * If the path is completed the flag ISLASTCN is set in ni_cnd.cn_flags.
 * If a symbolic link need interpretation is encountered, the flag ISSYMLINK
 * is set in ni_cnd.cn_flags.
 *
 * The flag argument is LOOKUP, CREATE, RENAME, or DELETE depending on
 * whether the name is to be looked up, created, renamed, or deleted.
 * When CREATE, RENAME, or DELETE is specified, information usable in
 * creating, renaming, or deleting a directory entry may be calculated.
 * If flag has LOCKPARENT or'ed into it, the parent directory is returned
 * locked. If flag has WANTPARENT or'ed into it, the parent directory is
 * returned unlocked. Otherwise the parent directory is not returned. If
 * the target of the pathname exists and LOCKLEAF is or'ed into the flag
 * the target is returned locked, otherwise it is returned unlocked.
 * When creating or renaming and LOCKPARENT is specified, the target may not
 * be ".".  When deleting and LOCKPARENT is specified, the target may be ".".
 *
 * Overall outline of lookup:
 *
 * dirloop:
 *	identify next component of name at ndp->ni_ptr
 *	handle degenerate case where name is null string
 *	if .. and crossing mount points and on mounted filesys, find parent
 *	call VOP_LOOKUP routine for next component name
 *	    directory vnode returned in ni_dvp, unlocked unless LOCKPARENT set
 *	    component vnode returned in ni_vp (if it exists), locked.
 *	if result vnode is mounted on and crossing mount points,
 *	    find mounted on vnode
 *	if more components of name, do next level at dirloop
 *	return the answer in ni_vp, locked if LOCKLEAF set
 *	    if LOCKPARENT set, return locked parent in ni_dvp
 *	    if WANTPARENT set, return unlocked parent in ni_dvp
 */
int
vfs_lookup(struct nameidata *ndp)
{
	char *cp;			/* pointer into pathname argument */
	struct vnode *dp = 0;		/* the directory we are searching */
	struct vnode *tdp;		/* saved dp */
	struct mount *mp;		/* mount table entry */
	int docache;			/* == 0 do not cache last component */
	int wantparent;			/* 1 => wantparent or lockparent flag */
	int rdonly;			/* lookup read-only flag bit */
	int error = 0;
	int dpunlocked = 0;		/* dp has already been unlocked */
	int slashes;
	struct componentname *cnp = &ndp->ni_cnd;
	struct proc *p = cnp->cn_proc;
	/*
	 * Setup: break out flag bits into variables.
	 */
	wantparent = cnp->cn_flags & (LOCKPARENT | WANTPARENT);
	docache = (cnp->cn_flags & NOCACHE) ^ NOCACHE;
	if (cnp->cn_nameiop == DELETE ||
	    (wantparent && cnp->cn_nameiop != CREATE))
		docache = 0;
	rdonly = cnp->cn_flags & RDONLY;
	ndp->ni_dvp = NULL;
	cnp->cn_flags &= ~ISSYMLINK;
	dp = ndp->ni_startdir;
	ndp->ni_startdir = NULLVP;
	vn_lock(dp, LK_EXCLUSIVE | LK_RETRY, p);

	/*
	 * If we have a leading string of slashes, remove them, and just make
	 * sure the current node is a directory.
	 */
	cp = cnp->cn_nameptr;
	if (*cp == '/') {
		do {
			cp++;
		} while (*cp == '/');
		ndp->ni_pathlen -= cp - cnp->cn_nameptr;
		cnp->cn_nameptr = cp;

		if (dp->v_type != VDIR) {
			error = ENOTDIR;
			goto bad;
		}

		/*
		 * If we've exhausted the path name, then just return the
		 * current node.  If the caller requested the parent node (i.e.
		 * it's a CREATE, DELETE, or RENAME), and we don't have one
		 * (because this is the root directory), then we must fail.
		 */
		if (cnp->cn_nameptr[0] == '\0') {
			if (ndp->ni_dvp == NULL && wantparent) {
				error = EISDIR;
				goto bad;
			}
			ndp->ni_vp = dp;
			cnp->cn_flags |= ISLASTCN;
			goto terminal;
		}
	}

dirloop:
	/*
	 * Search a new directory.
	 *
	 * The last component of the filename is left accessible via
	 * cnp->cn_nameptr for callers that need the name. Callers needing
	 * the name set the SAVENAME flag. When done, they assume
	 * responsibility for freeing the pathname buffer.
	 */
	cnp->cn_consume = 0;

	/* XXX: Figure out the length of the last component. */
	cp = cnp->cn_nameptr;
	while (*cp && (*cp != '/'))
		cp++;
	cnp->cn_namelen = cp - cnp->cn_nameptr;
	if (cnp->cn_namelen > NAME_MAX) {
		error = ENAMETOOLONG;
		goto bad;
	}

#ifdef NAMEI_DIAGNOSTIC
	{ char c = *cp;
	*cp = '\0';
	printf("{%s}: ", cnp->cn_nameptr);
	*cp = c; }
#endif
	ndp->ni_pathlen -= cnp->cn_namelen;
	ndp->ni_next = cp;
	/*
	 * If this component is followed by a slash, then move the pointer to
	 * the next component forward, and remember that this component must be
	 * a directory.
	 */
	if (*cp == '/') {
		do {
			cp++;
		} while (*cp == '/');
		slashes = cp - ndp->ni_next;
		ndp->ni_pathlen -= slashes;
		ndp->ni_next = cp;
		cnp->cn_flags |= REQUIREDIR;
	} else {
		slashes = 0;
		cnp->cn_flags &= ~REQUIREDIR;
	}
	/*
	 * We do special processing on the last component, whether or not it's
	 * a directory.  Cache all intervening lookups, but not the final one.
	 */
	if (*cp == '\0') {
		if (docache)
			cnp->cn_flags |= MAKEENTRY;
		else
			cnp->cn_flags &= ~MAKEENTRY;
		cnp->cn_flags |= ISLASTCN;
	} else {
		cnp->cn_flags |= MAKEENTRY;
		cnp->cn_flags &= ~ISLASTCN;
	}
	if (cnp->cn_namelen == 2 &&
	    cnp->cn_nameptr[1] == '.' && cnp->cn_nameptr[0] == '.')
		cnp->cn_flags |= ISDOTDOT;
	else
		cnp->cn_flags &= ~ISDOTDOT;

	/*
	 * Handle "..": two special cases.
	 * 1. If at root directory (e.g. after chroot)
	 *    or at absolute root directory
	 *    then ignore it so can't get out.
	 * 2. If this vnode is the root of a mounted
	 *    filesystem, then replace it with the
	 *    vnode which was mounted on so we take the
	 *    .. in the other file system.
	 */
	if (cnp->cn_flags & ISDOTDOT) {
		for (;;) {
			if (dp == ndp->ni_rootdir || dp == rootvnode) {
				ndp->ni_dvp = dp;
				ndp->ni_vp = dp;
				vref(dp);
				goto nextname;
			}
			if ((dp->v_flag & VROOT) == 0 ||
			    (cnp->cn_flags & NOCROSSMOUNT))
				break;
			tdp = dp;
			dp = dp->v_mount->mnt_vnodecovered;
			vput(tdp);
			vref(dp);
			vn_lock(dp, LK_EXCLUSIVE | LK_RETRY, p);
		}
	}

	/*
	 * We now have a segment name to search for, and a directory to search.
	 */
	ndp->ni_dvp = dp;
	ndp->ni_vp = NULL;
	cnp->cn_flags &= ~PDIRUNLOCK;

	if ((error = VOP_LOOKUP(dp, &ndp->ni_vp, cnp)) != 0) {
#ifdef DIAGNOSTIC
		if (ndp->ni_vp != NULL)
			panic("leaf should be empty");
#endif
#ifdef NAMEI_DIAGNOSTIC
			printf("not found\n");
#endif
		if (error != EJUSTRETURN)
			goto bad;
		/*
		 * If this was not the last component, or there were trailing
		 * slashes, then the name must exist.
		 */
		if (cnp->cn_flags & REQUIREDIR) {
			error = ENOENT;
			goto bad;
		}
		/*
		 * If creating and at end of pathname, then can consider
		 * allowing file to be created.
		 */
		if (rdonly || (ndp->ni_dvp->v_mount->mnt_flag & MNT_RDONLY)) {
			error = EROFS;
			goto bad;
		}
		/*
		 * We return with ni_vp NULL to indicate that the entry
		 * doesn't currently exist, leaving a pointer to the
		 * (possibly locked) directory inode in ndp->ni_dvp.
		 */
		if (cnp->cn_flags & SAVESTART) {
			ndp->ni_startdir = ndp->ni_dvp;
			vref(ndp->ni_startdir);
		}
		return (0);
	}
#ifdef NAMEI_DIAGNOSTIC
		printf("found\n");
#endif

	/*
	 * Take into account any additional components consumed by the
	 * underlying filesystem.  This will include any trailing slashes after
	 * the last component consumed.
	 */
	if (cnp->cn_consume > 0) {
		if (cnp->cn_consume >= slashes) {
			cnp->cn_flags &= ~REQUIREDIR;
		}

		ndp->ni_pathlen -= cnp->cn_consume - slashes;
		ndp->ni_next += cnp->cn_consume - slashes;
		cnp->cn_consume = 0;
		if (ndp->ni_next[0] == '\0')
			cnp->cn_flags |= ISLASTCN;
	}

	dp = ndp->ni_vp;
	/*
	 * Check to see if the vnode has been mounted on;
	 * if so find the root of the mounted file system.
	 */
	while (dp->v_type == VDIR && (mp = dp->v_mountedhere) &&
	    (cnp->cn_flags & NOCROSSMOUNT) == 0) {
		if (vfs_busy(mp, VB_READ|VB_WAIT))
			continue;
		VOP_UNLOCK(dp, p);
		error = VFS_ROOT(mp, &tdp);
		vfs_unbusy(mp);
		if (error) {
			dpunlocked = 1;
			goto bad2;
		}
		vrele(dp);
		ndp->ni_vp = dp = tdp;
	}

	/*
	 * Check for symbolic link.  Back up over any slashes that we skipped,
	 * as we will need them again.
	 */
	if ((dp->v_type == VLNK) && (cnp->cn_flags & (FOLLOW|REQUIREDIR))) {
		ndp->ni_pathlen += slashes;
		ndp->ni_next -= slashes;
		cnp->cn_flags |= ISSYMLINK;
		return (0);
	}

	/*
	 * Check for directory, if the component was followed by a series of
	 * slashes.
	 */
	if ((dp->v_type != VDIR) && (cnp->cn_flags & REQUIREDIR)) {
		error = ENOTDIR;
		goto bad2;
	}

nextname:
	/*
	 * Not a symbolic link.  If this was not the last component, then
	 * continue at the next component, else return.
	 */
	if (!(cnp->cn_flags & ISLASTCN)) {
		cnp->cn_nameptr = ndp->ni_next;
		vrele(ndp->ni_dvp);
		goto dirloop;
	}

terminal:
	/*
	 * Check for read-only file systems.
	 */
	if (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME) {
		/*
		 * Disallow directory write attempts on read-only
		 * file systems.
		 */
		if (rdonly || (dp->v_mount->mnt_flag & MNT_RDONLY) ||
		    (wantparent &&
		    (ndp->ni_dvp->v_mount->mnt_flag & MNT_RDONLY))) {
			error = EROFS;
			goto bad2;
		}
	}
	if (ndp->ni_dvp != NULL) {
		if (cnp->cn_flags & SAVESTART) {
			ndp->ni_startdir = ndp->ni_dvp;
			vref(ndp->ni_startdir);
		}
		if (!wantparent)
			vrele(ndp->ni_dvp);
	}
	if ((cnp->cn_flags & LOCKLEAF) == 0)
		VOP_UNLOCK(dp, p);
	return (0);

bad2:
	if ((cnp->cn_flags & LOCKPARENT) && (cnp->cn_flags & ISLASTCN) &&
	    ((cnp->cn_flags & PDIRUNLOCK) == 0))
		VOP_UNLOCK(ndp->ni_dvp, p);
	vrele(ndp->ni_dvp);
bad:
	if (dpunlocked)
		vrele(dp);
	else
		vput(dp);
	ndp->ni_vp = NULL;
	return (error);
}

/*
 * Reacquire a path name component.
 */
int
vfs_relookup(struct vnode *dvp, struct vnode **vpp, struct componentname *cnp)
{
	struct proc *p = cnp->cn_proc;
	struct vnode *dp = 0;		/* the directory we are searching */
	int wantparent;			/* 1 => wantparent or lockparent flag */
	int rdonly;			/* lookup read-only flag bit */
	int error = 0;
#ifdef NAMEI_DIAGNOSTIC
	char *cp;			/* DEBUG: check name ptr/len */
#endif

	/*
	 * Setup: break out flag bits into variables.
	 */
	wantparent = cnp->cn_flags & (LOCKPARENT|WANTPARENT);
	rdonly = cnp->cn_flags & RDONLY;
	cnp->cn_flags &= ~ISSYMLINK;
	dp = dvp;
	vn_lock(dp, LK_EXCLUSIVE | LK_RETRY, p);

/* dirloop: */
	/*
	 * Search a new directory.
	 *
	 * The last component of the filename is left accessible via
	 * cnp->cn_nameptr for callers that need the name. Callers needing
	 * the name set the SAVENAME flag. When done, they assume
	 * responsibility for freeing the pathname buffer.
	 */

#ifdef NAMEI_DIAGNOSTIC
	/* XXX: Figure out the length of the last component. */
	cp = cnp->cn_nameptr;
	while (*cp && (*cp != '/')) {
		cp++;
	}
	if (cnp->cn_namelen != cp - cnp->cn_nameptr)
		panic("relookup: bad len");
	if (*cp != 0)
		panic("relookup: not last component");
	printf("{%s}: ", cnp->cn_nameptr);
#endif

	/*
	 * Check for degenerate name (e.g. / or "")
	 * which is a way of talking about a directory,
	 * e.g. like "/." or ".".
	 */
	if (cnp->cn_nameptr[0] == '\0')
		panic("relookup: null name");

	if (cnp->cn_flags & ISDOTDOT)
		panic ("relookup: lookup on dot-dot");

	/*
	 * We now have a segment name to search for, and a directory to search.
	 */
	if ((error = VOP_LOOKUP(dp, vpp, cnp)) != 0) {
#ifdef DIAGNOSTIC
		if (*vpp != NULL)
			panic("leaf should be empty");
#endif
		if (error != EJUSTRETURN)
			goto bad;
		/*
		 * If creating and at end of pathname, then can consider
		 * allowing file to be created.
		 */
		if (rdonly || (dvp->v_mount->mnt_flag & MNT_RDONLY)) {
			error = EROFS;
			goto bad;
		}
		/* ASSERT(dvp == ndp->ni_startdir) */
		if (cnp->cn_flags & SAVESTART)
			vref(dvp);
		/*
		 * We return with ni_vp NULL to indicate that the entry
		 * doesn't currently exist, leaving a pointer to the
		 * (possibly locked) directory inode in ndp->ni_dvp.
		 */
		return (0);
	}
	dp = *vpp;

#ifdef DIAGNOSTIC
	/*
	 * Check for symbolic link
	 */
	if (dp->v_type == VLNK && (cnp->cn_flags & FOLLOW))
		panic ("relookup: symlink found.");
#endif

	/*
	 * Check for read-only file systems.
	 */
	if (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME) {
		/*
		 * Disallow directory write attempts on read-only
		 * file systems.
		 */
		if (rdonly || (dp->v_mount->mnt_flag & MNT_RDONLY) ||
		    (wantparent &&
		    (dvp->v_mount->mnt_flag & MNT_RDONLY))) {
			error = EROFS;
			goto bad2;
		}
	}
	/* ASSERT(dvp == ndp->ni_startdir) */
	if (cnp->cn_flags & SAVESTART)
		vref(dvp);
	if (!wantparent)
		vrele(dvp);
	if ((cnp->cn_flags & LOCKLEAF) == 0)
		VOP_UNLOCK(dp, p);
	return (0);

bad2:
	if ((cnp->cn_flags & LOCKPARENT) && (cnp->cn_flags & ISLASTCN))
		VOP_UNLOCK(dvp, p);
	vrele(dvp);
bad:
	vput(dp);
	*vpp = NULL;
	return (error);
}
@


1.64
log
@remove parens that were copied from ndinit's previous life as a macro
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.63 2016/04/29 14:40:36 beck Exp $	*/
a54 2
#include <sys/types.h>
#include <sys/malloc.h>
a59 36

void
push_component(struct nameidata *ndp, char *cp, size_t cplen)
{
	KASSERT(cplen < MAXPATHLEN);
	if (ndp->ni_p_size - ndp->ni_p_length <= cplen) {
		char *tmp = malloc(ndp->ni_p_size + MAXPATHLEN, M_TEMP, M_WAITOK);
		memcpy(tmp, ndp->ni_p_path, ndp->ni_p_length);
		ndp->ni_p_next = tmp + (ndp->ni_p_next - ndp->ni_p_path);
		ndp->ni_p_prev = tmp + (ndp->ni_p_prev - ndp->ni_p_path);
		free(ndp->ni_p_path, M_TEMP, ndp->ni_p_size);
		ndp->ni_p_path = tmp;
		ndp->ni_p_size += MAXPATHLEN;
	}
	memcpy(ndp->ni_p_next, cp, cplen);
	ndp->ni_p_prev = ndp->ni_p_next;
	ndp->ni_p_next += cplen;
	ndp->ni_p_length += cplen;
	*ndp->ni_p_next = '\0';
#ifdef NAMEI_DIAGNOSTIC_PLEDGE
	printf("push: ndp->ni_p_path = %s\n", ndp->ni_p_path);
#endif
}

void
pop_symlink(struct nameidata *ndp)
{
	KASSERT(ndp->ni_p_next != ndp->ni_p_prev);
	ndp->ni_p_length = ndp->ni_p_prev - ndp->ni_p_path;
	ndp->ni_p_next = ndp->ni_p_prev;
	*ndp->ni_p_next = '\0';
#ifdef NAMEI_DIAGNOSTIC_PLEDGE
	printf("pop: ndp->ni_p_path = %s\n", ndp->ni_p_path);
#endif
}

a106 6
	/*
	 * Should be 0, if not someone didn't init ndp with NDINIT,
	 * go find and murder the offender messily.
	 */
	KASSERT (ndp->ni_p_path == NULL && ndp->ni_p_size == 0);

a178 15
	 * Decide if we need to call pledge_namei_wlpath after namei lookup, if
	 * so give namei a place to store a path for it to look at.
	 */
	if (!ISSET(p->p_p->ps_flags, PS_COREDUMP) &&
	    ISSET(p->p_p->ps_flags, PS_PLEDGE) && p->p_p->ps_pledgepaths) {
		ndp->ni_p_path = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
		ndp->ni_p_next = ndp->ni_p_prev = ndp->ni_p_path;
		ndp->ni_p_size = MAXPATHLEN;
		ndp->ni_p_length = 0;
	} else {
		ndp->ni_p_path = NULL;
		ndp->ni_p_size = 0;
	}

	/*
a183 6
		if (ndp->ni_p_path != NULL) {
			*ndp->ni_p_path = '/';
			ndp->ni_p_next++;
			*ndp->ni_p_next = '\0';
			ndp->ni_p_length = 1;
		}
a189 1
			free(ndp->ni_p_path, M_TEMP, ndp->ni_p_size);
a194 1
			free(ndp->ni_p_path, M_TEMP, ndp->ni_p_size);
a202 1
			free(ndp->ni_p_path, M_TEMP, ndp->ni_p_size);
a208 1
			free(ndp->ni_p_path, M_TEMP, ndp->ni_p_size);
a215 13
			error = pledge_namei_wlpath(p, ndp);
			if (error) {
#ifdef NAMEI_DIAGNOSTIC_PLEDGE
				printf("pledge_namei error %d for path %s\n", error, ndp->ni_p_path);
#endif
				free(ndp->ni_p_path, M_TEMP, ndp->ni_p_size);
				pool_put(&namei_pool, cnp->cn_pnbuf);
				if (ndp->ni_vp)
					vput(ndp->ni_vp);
				ndp->ni_vp = NULL;
				return(error);
			}
			free(ndp->ni_p_path, M_TEMP, ndp->ni_p_size);
a272 7
			if (ndp->ni_p_path != NULL) {
				ndp->ni_p_next = ndp->ni_p_prev = ndp->ni_p_path;
				*ndp->ni_p_path = '/';
				ndp->ni_p_next++;
				*ndp->ni_p_next = '\0';
				ndp->ni_p_length = 1;
			}
a275 1
	free(ndp->ni_p_path, M_TEMP, ndp->ni_p_size);
a406 3
#ifdef NAMEI_DIAGNOSTIC_PLEDGE
	if (p && p->p_p && p->p_p->ps_pledgepaths)
#endif
a411 3
	if (ndp->ni_p_path != NULL)
		push_component(ndp, cnp->cn_nameptr, cnp->cn_namelen);

a492 3
#ifdef NAMEI_DIAGNOSTIC_PLEDGE
		if (p && p->p_p && p->p_p->ps_pledgepaths)
#endif
a524 3
#ifdef NAMEI_DIAGNOSTIC_PLEDGE
	if (p && p->p_p && p->p_p->ps_pledgepaths)
#endif
a572 2
		if (ndp->ni_p_path != NULL)
			pop_symlink(ndp);
a592 2
		if (ndp->ni_p_path != NULL)
			push_component(ndp, "/", 1);
d673 4
a676 14
#ifdef NAMEI_DIAGNOSTIC_PLEDGE
	if (p && p->p_p && p->p_p->ps_pledgepaths)
#endif
	{
		/* XXX: Figure out the length of the last component. */
		cp = cnp->cn_nameptr;
		while (*cp && (*cp != '/')) {
			cp++;
		}
		if (cnp->cn_namelen != cp - cnp->cn_nameptr)
			panic("relookup: bad len");
		if (*cp != 0)
			panic("relookup: not last component");
		printf("{%s}: ", cnp->cn_nameptr);
d678 5
@


1.63
log
@Fix some gibbering horrors due to uninitialized struct nameidata's

1) turn NDINITAT into a function and make the macros point to it
with the later goal of getting rid of them.

2) Sweep the kernel for places where people make a struct nameidata manually
on the stack and fill in what they hope are the required fields and count
on prayer and clean living to always get them right. Instead use NDINIT
everywhere. NFS was especially bad for this and there have likely
been things lurking there for a while.

3) Add a couple of strategic KASSERT's to catch future offenders.

ok krw@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.62 2016/04/28 14:25:08 beck Exp $	*/
d103 6
a108 6
	(ndp)->ni_cnd.cn_nameiop = op;
	(ndp)->ni_cnd.cn_flags = flags;
	(ndp)->ni_segflg = segflg;
	(ndp)->ni_dirfd = dirfd;
	(ndp)->ni_dirp = namep;
	(ndp)->ni_cnd.cn_proc = p;
@


1.62
log
@1) Split pledge whitelist path handling out of pledge_namei() and into
   pledge_namei_wlpath(). Call the wlpath check only at the end of namei
   after the namei lookup would otherwise succeed.
2) Add support to namei to keep the path that was looked up, without the
   symlinks in it, and use that path for whitelist path lookups. This
   means that paths in pledge whitelists will need to always be the
   real path to an intended file to whitelist, without symlinks. Any
   symlinks to the "real" file will then be allowed
ok deraadt@@ semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.61 2016/04/25 20:00:33 tedu Exp $	*/
d98 13
d144 6
@


1.61
log
@boom goes the dynamite
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.60 2016/03/19 12:04:15 natano Exp $	*/
d55 2
d63 35
d198 1
a198 1
	
d204 15
d224 6
d236 1
d242 1
d251 1
d258 1
d266 13
d283 1
a283 1
			return (0);
d336 7
d346 1
d478 3
d486 3
d570 4
a573 1
		printf("not found\n");
d605 4
a608 1
	printf("found\n");
d656 2
d678 2
d760 14
a773 4
	/* XXX: Figure out the length of the last component. */
	cp = cnp->cn_nameptr;
	while (*cp && (*cp != '/')) {
		cp++;
a774 5
	if (cnp->cn_namelen != cp - cnp->cn_nameptr)
		panic("relookup: bad len");
	if (*cp != 0)
		panic("relookup: not last component");
	printf("{%s}: ", cnp->cn_nameptr);
@


1.60
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.59 2015/11/02 16:31:55 semarie Exp $	*/
a59 4
#include "systrace.h"
#if NSYSTRACE > 0
#include <dev/systrace.h>
#endif
a134 4
#endif
#if NSYSTRACE > 0
	if (ISSET(cnp->cn_proc->p_flag, P_SYSTRACE))
		systrace_namei(ndp);
@


1.59
log
@move the pledgenote annotation from `struct proc' to `struct nameidata'

pledgenote is used for annotate the policy for a namei context. So make it
tracking the nameidata.

It is expected for the caller to explicitly define the policy. It is a kernel
bug to not do so.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.58 2015/11/01 19:03:33 semarie Exp $	*/
d219 1
a219 1
			VOP_UNLOCK(ndp->ni_dvp, 0, p);
d550 1
a550 1
		VOP_UNLOCK(dp, 0, p);
d617 1
a617 1
		VOP_UNLOCK(dp, 0, p);
d623 1
a623 1
		VOP_UNLOCK(ndp->ni_dvp, 0, p);
d751 1
a751 1
		VOP_UNLOCK(dp, 0, p);
d756 1
a756 1
		VOP_UNLOCK(dvp, 0, p);
@


1.58
log
@refactor pledge_*_check and pledge_fail functions

- rename _check function without suffix: a "pledge" function called from
  anywhere is a "check" function.

- makes pledge_fail call the responsability to the _check function. remove it
  from caller.

- make proper use of (potential) returned error of _check() functions.

- adds pledge_kill() and pledge_protexec()

with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.57 2015/10/09 01:10:27 deraadt Exp $	*/
d170 1
a170 1
	error = pledge_namei(p, cnp->cn_pnbuf);
@


1.57
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.56 2015/09/11 08:22:31 guenther Exp $	*/
d169 4
a172 5
 	if ((p->p_p->ps_flags & PS_PLEDGE)) {
		error = pledge_namei(p, cnp->cn_pnbuf);
		if (error)
			goto fail;
	}
@


1.56
log
@Only include <sys/tame.h> in the .c files that need it

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.55 2015/08/22 20:18:50 deraadt Exp $	*/
d52 1
a52 1
#include <sys/tame.h>
d169 2
a170 2
	if ((p->p_p->ps_flags & PS_TAMED)) {
		error = tame_namei(p, cnp->cn_pnbuf);
@


1.55
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.54 2015/07/19 02:35:35 deraadt Exp $	*/
d52 1
@


1.54
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.53 2015/04/23 02:55:15 jsg Exp $	*/
a53 1
#include <sys/tame.h>
@


1.53
log
@avoid an uneeded deref
ok blambert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.52 2015/03/14 03:38:51 jsg Exp $	*/
d54 1
d130 1
d169 6
@


1.52
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.51 2015/01/19 18:05:41 deraadt Exp $	*/
d665 1
a665 1
		*cp++;
@


1.51
log
@SYMLOOP_MAX == MAXSYMLINKS, so use SYMLOOP_MAX
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.50 2014/12/16 18:30:04 tedu Exp $	*/
a48 1
#include <sys/malloc.h>
@


1.50
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.49 2014/12/10 02:44:47 tedu Exp $	*/
d214 1
a214 1
		if (ndp->ni_loopcnt++ >= MAXSYMLINKS) {
@


1.49
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.48 2014/12/03 04:17:15 tedu Exp $	*/
d46 1
@


1.48
log
@stale header: this code hasn't used hash.h in a while
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.47 2014/03/25 04:04:36 guenther Exp $	*/
d247 1
a247 1
			bcopy(ndp->ni_next, cp + linklen, ndp->ni_pathlen);
@


1.47
log
@As long as we're pulling in "systrace.h", might as well conditionalize
the inclusion of <dev/systrace.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.46 2013/03/30 04:53:09 guenther Exp $	*/
a51 1
#include <sys/hash.h>
@


1.46
log
@Return ENOTDIR if an *at() syscall is passed a relative path and a
fd to resolve against that isn't a directory

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.45 2011/07/22 00:22:57 matthew Exp $	*/
d60 2
d63 1
a63 1
#include "systrace.h"
@


1.45
log
@Doh, fix a memory leak when an invalid file descriptor is passed to a
*at(2) function.

ok guenther@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.44 2011/07/07 23:45:00 matthew Exp $	*/
d177 1
a177 1
		if (fp == NULL || fp->f_type != DTYPE_VNODE) {
d182 1
a182 1
		if (dp->v_type != VDIR) {
d184 1
a184 1
			return (EBADF);
@


1.44
log
@Add new syscall entries to support the openat(2) family of functions
added in POSIX Issue 7: openat(), mknodat(), mkfifoat(), linkat(),
symlinkat(), unlinkat(), faccessat(), fstatat(), readlinkat(),
fchmodat(), fchownat(), utimensat(), renameat(), and mkdirat().

This diff mostly just refactors the existing sys_foo() logic into a
common dofooat() function that can then be called by both sys_foo()
and sys_fooat().  Some of the new system calls support new flags to
control their behavior, and proper support for these will be added in
subsequent diffs.

Incorporating suggestions from thib@@, guenther@@, and tedu@@.

ok tedu@@, thib@@, deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.43 2010/09/09 10:37:03 thib Exp $	*/
d177 2
a178 1
		if (fp == NULL || fp->f_type != DTYPE_VNODE)
d180 1
d182 2
a183 1
		if (dp->v_type != VDIR)
d185 1
@


1.43
log
@Rename lookup/relookup to vfs_lookup/vfs_relookup.

OK oga@@, beck@@, matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.42 2010/05/20 02:32:02 marco Exp $	*/
d53 2
d172 3
d176 6
a181 1
		dp = fdp->fd_cdir;
@


1.42
log
@Don't dereference cp to shut gcc4 up (the intent anyway).

ok drahn oga
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.41 2010/05/19 08:31:23 thib Exp $	*/
d182 1
a182 1
		if ((error = lookup(ndp)) != 0) {
d296 1
a296 1
lookup(struct nameidata *ndp)
d616 1
a616 1
relookup(struct vnode *dvp, struct vnode **vpp, struct componentname *cnp)
@


1.41
log
@clean up a few things that where left to rot after bob's vfs cache work.
sync a few comments to reality (or remove them), remove the cn_hash member
from struct componentname, spacing.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.40 2009/07/09 22:29:56 thib Exp $	*/
d372 2
a373 3
	while (*cp && (*cp != '/')) {
		*cp++;
	}
@


1.40
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.38 2008/03/04 15:30:18 deraadt Exp $	*/
a362 1
	 * The cn_hash value is for use by vfs_cache.
a367 1
	cp = NULL;
d369 6
a374 1
	cnp->cn_hash = hash32_stre(cnp->cn_nameptr, '/', &cp, HASHINIT);
d380 1
a624 1
	u_int32_t newhash;		/* DEBUG: check name hash */
a640 1
	 * The cn_hash value is for use by vfs_cache.
d646 1
d648 5
a652 4
	cp = NULL;
	newhash = hash32_stre(cnp->cn_nameptr, '/', &cp, HASHINIT);
	if (newhash != cnp->cn_hash)
		panic("relookup: bad hash");
d654 1
a654 1
		panic ("relookup: bad len");
@


1.39
log
@Clarify comment in namei(): the code commented doesn't check if the
path being looked up *is* a symlink, it checks if it *is not* a
symlink and returns the vnode looked up in that case.

ok thib@@
@
text
@d169 1
a169 1
		VREF(dp);
d172 1
a172 1
		VREF(dp);
d246 1
a246 1
			VREF(dp);
d437 1
a437 1
				VREF(dp);
d446 1
a446 1
			VREF(dp);
d491 1
a491 1
			VREF(ndp->ni_startdir);
d586 1
a586 1
			VREF(ndp->ni_startdir);
d687 1
a687 1
			VREF(dvp);
d722 1
a722 1
		VREF(dvp);
@


1.38
log
@Do not permit insertion of a "" symbolic link translation into the path
translation; abort with ENOENT; ok millert kettenis thib, pr #5752
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.37 2007/09/08 01:45:58 hshoexer Exp $	*/
d187 1
a187 1
		 * Check for symbolic link
@


1.37
log
@Sync description of lookup() a bit more to reality.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.36 2007/08/07 07:41:59 thib Exp $	*/
d223 4
@


1.36
log
@fix the "double-path" errors seen with getcwd by saving the orignal
buffer position in vfs_getcwd_getcache() and restoring it on error.
Use u_int32_t for the componentname hash, use the same type in
the diagnostic code in relookup() to prevent unsigned vs signed errors.

help, testing & ok kurt@@
ok millert@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.35 2006/06/25 15:01:53 sturm Exp $	*/
d256 6
a261 5
 * The pathname is pointed to by ni_ptr and is of length ni_pathlen.
 * The starting directory is taken from ni_startdir. The pathname is
 * descended until done, or a symbolic link is encountered. The variable
 * ni_more is clear if the path is completed; it is set to one if a
 * symbolic link needing interpretation is encountered.
@


1.35
log
@rename vfs_busy() flags VB_UMIGNORE/VB_UMWAIT to VB_NOWAIT/VB_WAIT

requested by and ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.34 2006/06/23 22:20:39 sturm Exp $	*/
d616 1
a616 1
	int newhash;			/* DEBUG: check name hash */
@


1.34
log
@namei() only returns locked vnodes if LOCKLEAF is set, be more clear
about this

ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.33 2006/06/14 20:01:50 sturm Exp $	*/
d518 1
a518 1
		if (vfs_busy(mp, VB_READ|VB_UMWAIT))
@


1.33
log
@move vfs_busy() to rwlocks and properly hide the locking api from vfs

ok tedu, pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.32 2006/04/30 14:20:07 sturm Exp $	*/
d62 1
a62 1
 * Convert a pathname into a pointer to a locked inode.
d68 2
@


1.32
log
@remove the simplelock argument from vfs_busy() which is currently not
used and will never be used this way in VFS

requested by and ok pedro, ok krw, biorn
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.31 2005/11/30 10:35:07 pedro Exp $	*/
d516 1
a516 1
		if (vfs_busy(mp, 0))
@


1.31
log
@No need for vfs_busy() and vfs_unbusy() to take a process pointer
anymore. Testing by jolan@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.30 2005/11/08 15:43:44 pedro Exp $	*/
d516 1
a516 1
		if (vfs_busy(mp, 0, NULL))
@


1.30
log
@Use ANSI function declarations and deregister, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.29 2005/05/26 00:33:45 pedro Exp $	*/
d516 1
a516 1
		if (vfs_busy(mp, 0, 0, p))
d520 1
a520 1
		vfs_unbusy(mp, p);
@


1.29
log
@RIP stackable filesystems, ok marius@@ tedu@@, discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.28 2004/07/11 16:42:45 pedro Exp $	*/
d82 1
a82 2
namei(ndp)
	register struct nameidata *ndp;
d84 3
a86 3
	register struct filedesc *fdp;	/* pointer to file descriptor state */
	register char *cp;		/* pointer into pathname argument */
	register struct vnode *dp;	/* the directory we are searching */
d289 1
a289 2
lookup(ndp)
	register struct nameidata *ndp;
d606 1
a606 3
relookup(dvp, vpp, cnp)
	struct vnode *dvp, **vpp;
	struct componentname *cnp;
d609 1
a609 1
	register struct vnode *dp = 0;	/* the directory we are searching */
a730 2


@


1.28
log
@save an (eventually existent) namei process context when going over
symbolic links. fixes pr 3842, ok tedu@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.27 2004/05/14 04:00:33 tedu Exp $	*/
a448 1
unionlookup:
a460 14
		if ((error == ENOENT) &&
		    (dp->v_flag & VROOT) &&
		    (dp->v_mount->mnt_flag & MNT_UNION)) {
			tdp = dp;
			dp = dp->v_mount->mnt_vnodecovered;
			if (cnp->cn_flags & PDIRUNLOCK)
				vrele(tdp);
			else
				vput(tdp);
			VREF(dp);
			vn_lock(dp, LK_EXCLUSIVE | LK_RETRY, p);
			goto unionlookup;
		}

@


1.27
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.26 2003/10/08 16:30:01 sturm Exp $	*/
d212 1
a212 1
		auio.uio_procp = (struct proc *)0;
@


1.26
log
@originally from cb@@netbsd.org, adapted by provos

itojun@@ ok

fix a race condition between path resolution in userland
and the subsequent namei(): inform the kernel portion of
valid filenames and then disallow symlink lookups for
those filenames by means of a hook in namei().
with suggestions from provos@@

also, add (currently unused) seqnr field to struct
systrace_replace, from provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.25 2003/06/02 23:28:07 millert Exp $	*/
d49 1
d110 1
a110 1
		MALLOC(cnp->cn_pnbuf, caddr_t, MAXPATHLEN, M_NAMEI, M_WAITOK);
d125 1
a125 1
		FREE(cnp->cn_pnbuf, M_NAMEI);
d176 1
a176 1
			FREE(cnp->cn_pnbuf, M_NAMEI);
d182 1
a182 1
			FREE(cnp->cn_pnbuf, M_NAMEI);
d190 1
a190 1
				FREE(cnp->cn_pnbuf, M_NAMEI);
d202 1
a202 1
			MALLOC(cp, char *, MAXPATHLEN, M_NAMEI, M_WAITOK);
d218 1
a218 1
				FREE(cp, M_NAMEI);
d228 1
a228 1
			FREE(cnp->cn_pnbuf, M_NAMEI);
d244 1
a244 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.24 2003/05/06 20:42:51 tedu Exp $	*/
d57 3
d132 4
@


1.24
log
@avoid doing a lookup on no longer mounted directories.
fixes a crash with forced unmounts.  from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.23 2003/05/04 00:22:12 tedu Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.23
log
@remove unused var docache from relookup. from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.22 2003/01/31 17:37:50 art Exp $	*/
d170 5
@


1.22
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.21 2002/08/27 16:04:42 mickey Exp $	*/
a619 1
	int docache;			/* == 0 do not cache last component */
a631 4
	docache = (cnp->cn_flags & NOCACHE) ^ NOCACHE;
	if (cnp->cn_nameiop == DELETE ||
	    (wantparent && cnp->cn_nameiop != CREATE))
		docache = 0;
@


1.21
log
@call ktrnamei() later, after cnp->cn_pnbuf has been made proper; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.20 2002/07/02 04:23:25 ericj Exp $	*/
d292 1
d443 2
d458 4
a461 1
			vput(tdp);
d526 1
d529 2
a530 1
		if (error)
d532 2
a533 1
		vput(dp);
d597 2
a598 1
	if ((cnp->cn_flags & LOCKPARENT) && (cnp->cn_flags & ISLASTCN))
d602 4
a605 1
	vput(dp);
@


1.20
log
@
use hash.h for nfs_hash as well as namei's hash
ok art@@ costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.19 2001/06/22 14:14:10 deraadt Exp $	*/
a117 5
#ifdef KTRACE
	if (KTRPOINT(cnp->cn_proc, KTR_NAMEI))
		ktrnamei(cnp->cn_proc, cnp->cn_pnbuf);
#endif

d129 5
@


1.19
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.18 2000/11/10 18:15:48 art Exp $	*/
d55 1
d284 2
a285 2
	register char *cp;		/* pointer into pathname argument */
	register struct vnode *dp = 0;	/* the directory we are searching */
d354 1
d356 1
a356 3
	cnp->cn_hash = 0;
	for (cp = cnp->cn_nameptr; *cp != '\0' && *cp != '/'; cp++)
		cnp->cn_hash += (unsigned char)*cp;
d640 2
a641 2
	for (newhash = 0, cp = cnp->cn_nameptr; *cp != 0 && *cp != '/'; cp++)
		newhash += (unsigned char)*cp;
@


1.19.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.19 2001/06/22 14:14:10 deraadt Exp $	*/
a54 1
#include <sys/hash.h>
d117 5
a133 5
#ifdef KTRACE
	if (KTRPOINT(cnp->cn_proc, KTR_NAMEI))
		ktrnamei(cnp->cn_proc, cnp->cn_pnbuf);
#endif

d283 2
a284 2
	char *cp;			/* pointer into pathname argument */
	struct vnode *dp = 0;		/* the directory we are searching */
a352 1
	cp = NULL;
d354 3
a356 1
	cnp->cn_hash = hash32_stre(cnp->cn_nameptr, '/', &cp, HASHINIT);
d640 2
a641 2
	cp = NULL;
	newhash = hash32_stre(cnp->cn_nameptr, '/', &cp, HASHINIT);
@


1.19.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a169 5
		if (!dp->v_mount) {
			/* Give up if the directory is no longer mounted */
			FREE(cnp->cn_pnbuf, M_NAMEI);
			return (ENOENT);
		}
a291 1
	int dpunlocked = 0;		/* dp has already been unlocked */
a441 2
	cnp->cn_flags &= ~PDIRUNLOCK;

d455 1
a455 4
			if (cnp->cn_flags & PDIRUNLOCK)
				vrele(tdp);
			else
				vput(tdp);
a519 1
		VOP_UNLOCK(dp, 0, p);
d522 1
a522 2
		if (error) {
			dpunlocked = 1;
d524 1
a524 2
		}
		vrele(dp);
d588 1
a588 2
	if ((cnp->cn_flags & LOCKPARENT) && (cnp->cn_flags & ISLASTCN) &&
	    ((cnp->cn_flags & PDIRUNLOCK) == 0))
d592 1
a592 4
	if (dpunlocked)
		vrele(dp);
	else
		vput(dp);
d607 1
d620 4
@


1.18
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.17 1999/04/16 14:04:41 deraadt Exp $	*/
d135 1
a135 1
	 *  Strip trailing slashes, as requested 
d141 2
a142 2
		while (cp >= cnp->cn_pnbuf &&
		       (*cp == '/')) cp--;
d150 1
a150 1
	
d262 1
a262 1
 * 
d517 2
a518 2
	       (cnp->cn_flags & NOCROSSMOUNT) == 0) {
		if (vfs_busy(mp, 0, 0, p)) 
d570 1
a570 1
		     (ndp->ni_dvp->v_mount->mnt_flag & MNT_RDONLY))) {
d710 1
a710 1
		     (dvp->v_mount->mnt_flag & MNT_RDONLY))) {
@


1.17
log
@ln bug fix
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.16 1999/01/11 05:12:24 millert Exp $	*/
d119 1
a119 1
		ktrnamei(cnp->cn_proc->p_tracep, cnp->cn_pnbuf);
@


1.17.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.18 2000/11/10 18:15:48 art Exp $	*/
d119 1
a119 1
		ktrnamei(cnp->cn_proc, cnp->cn_pnbuf);
@


1.17.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.17.6.1 2001/05/14 22:32:46 niklas Exp $	*/
d135 1
a135 1
	 *  Strip trailing slashes, as requested
d141 2
a142 2
		while (cp >= cnp->cn_pnbuf && (*cp == '/'))
			cp--;
d150 1
a150 1

d262 1
a262 1
 *
d517 2
a518 2
	    (cnp->cn_flags & NOCROSSMOUNT) == 0) {
		if (vfs_busy(mp, 0, 0, p))
d570 1
a570 1
		    (ndp->ni_dvp->v_mount->mnt_flag & MNT_RDONLY))) {
d710 1
a710 1
		    (dvp->v_mount->mnt_flag & MNT_RDONLY))) {
@


1.17.6.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a54 1
#include <sys/hash.h>
d117 5
a133 5
#ifdef KTRACE
	if (KTRPOINT(cnp->cn_proc, KTR_NAMEI))
		ktrnamei(cnp->cn_proc, cnp->cn_pnbuf);
#endif

d283 2
a284 2
	char *cp;			/* pointer into pathname argument */
	struct vnode *dp = 0;		/* the directory we are searching */
a290 1
	int dpunlocked = 0;		/* dp has already been unlocked */
a352 1
	cp = NULL;
d354 3
a356 1
	cnp->cn_hash = hash32_stre(cnp->cn_nameptr, '/', &cp, HASHINIT);
a441 2
	cnp->cn_flags &= ~PDIRUNLOCK;

d455 1
a455 4
			if (cnp->cn_flags & PDIRUNLOCK)
				vrele(tdp);
			else
				vput(tdp);
a519 1
		VOP_UNLOCK(dp, 0, p);
d522 1
a522 2
		if (error) {
			dpunlocked = 1;
d524 1
a524 2
		}
		vrele(dp);
d588 1
a588 2
	if ((cnp->cn_flags & LOCKPARENT) && (cnp->cn_flags & ISLASTCN) &&
	    ((cnp->cn_flags & PDIRUNLOCK) == 0))
d592 1
a592 4
	if (dpunlocked)
		vrele(dp);
	else
		vput(dp);
d640 2
a641 2
	cp = NULL;
	newhash = hash32_stre(cnp->cn_nameptr, '/', &cp, HASHINIT);
@


1.17.6.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.17.6.3 2003/03/28 00:41:27 niklas Exp $	*/
a169 5
		if (!dp->v_mount) {
			/* Give up if the directory is no longer mounted */
			FREE(cnp->cn_pnbuf, M_NAMEI);
			return (ENOENT);
		}
d620 1
d633 4
@


1.17.6.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.17.6.4 2003/05/13 19:21:28 ho Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.17.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a56 3
#include <dev/systrace.h>
#include "systrace.h"

a128 4
#endif
#if NSYSTRACE > 0
	if (ISSET(cnp->cn_proc->p_flag, P_SYSTRACE))
		systrace_namei(ndp);
@


1.17.6.7
log
@Merge with the trunk
@
text
@a48 1
#include <sys/pool.h>
d109 1
a109 1
		cnp->cn_pnbuf = pool_get(&namei_pool, PR_WAITOK);
d124 1
a124 1
		pool_put(&namei_pool, cnp->cn_pnbuf);
d175 1
a175 1
			pool_put(&namei_pool, cnp->cn_pnbuf);
d181 1
a181 1
			pool_put(&namei_pool, cnp->cn_pnbuf);
d189 1
a189 1
				pool_put(&namei_pool, cnp->cn_pnbuf);
d201 1
a201 1
			cp = pool_get(&namei_pool, PR_WAITOK);
d217 1
a217 1
				pool_put(&namei_pool, cp);
d227 1
a227 1
			pool_put(&namei_pool, cnp->cn_pnbuf);
d243 1
a243 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
@


1.16
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.15 1998/08/07 01:56:11 csapuntz Exp $	*/
d185 1
a185 1
		if ((cnp->cn_flags & LOCKPARENT) && ndp->ni_pathlen == 1)
@


1.15
log
@

Fix portal FS & PR #556

Basically, if file system consumes the slashes at the end of a component,
don't require that the component is a directory.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.14 1998/01/09 16:21:56 csapuntz Exp $	*/
d697 1
a697 1
		panic ("relookup: symlink found.\n");
@


1.14
log
@A better fix for the mkdir ("path/") bug. This fix strips the trailing slashes
(except in the case where the path is just /////) in the following three
cases:

1) The path in mkdir
2) The destination path in rename if the source was a directory
3) The destination path in link if the source was a directory

Note #3 isn't strictly necessary since most of our file systems don't
support hard links of directories anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.13 1998/01/09 15:16:20 csapuntz Exp $	*/
d500 4
@


1.13
log
@Back out changes to lookup( ). This breaks a whole bunch of other system
calls (like open, rename, link, symlink). Problem should probably be
fixed other ways.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.11 1997/11/06 05:58:27 csapuntz Exp $	*/
d133 18
@


1.12
log
@Fix for mkdir ("path/") problem
@
text
@a149 2


a290 6
	/* Make sure the current node is a directory */
	if (dp->v_type != VDIR) {
		error = ENOTDIR;
		goto bad;
	}

d292 2
a293 1
	 * If we have a leading string of slashes, remove them.
d303 4
d445 7
a451 4

#ifdef DIAGNOSTIC
		if (!(cnp->cn_flags & ISLASTCN)) {
			printf ("Just got an EJUSTRETURN for something which wasn't the last component. Bad news\n");
a452 2
#endif

@


1.11
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.10 1997/10/06 20:20:11 deraadt Exp $	*/
d150 2
d293 6
d300 1
a300 2
	 * If we have a leading string of slashes, remove them, and just make
	 * sure the current node is a directory.
a309 4
		if (dp->v_type != VDIR) {
			error = ENOTDIR;
			goto bad;
		}
d448 4
a451 7
		/*
		 * If this was not the last component, or there were trailing
		 * slashes, then the name must exist.
		 */
		if (cnp->cn_flags & REQUIREDIR) {
			error = ENOENT;
			goto bad;
d453 2
@


1.10
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.8 1997/06/18 17:37:38 tholo Exp $	*/
d91 1
d168 1
a168 1
			VOP_UNLOCK(ndp->ni_dvp);
d275 1
a275 1

d289 1
a289 1
	VOP_LOCK(dp);
d414 1
a414 1
			VOP_LOCK(dp);
d423 1
d439 1
a439 1
			VOP_LOCK(dp);
d496 1
a496 3
		if (mp->mnt_flag & MNT_MLOCK) {
			mp->mnt_flag |= MNT_MWAIT;
			sleep((caddr_t)mp, PVFS);
d498 3
a500 2
		}
		if ((error = VFS_ROOT(dp->v_mountedhere, &tdp)) != 0)
d562 1
a562 1
		VOP_UNLOCK(dp);
d567 1
a567 1
		VOP_UNLOCK(ndp->ni_dvp);
d583 1
d605 1
a605 1
	VOP_LOCK(dp);
d699 1
a699 1
		VOP_UNLOCK(dp);
d704 1
a704 1
		VOP_UNLOCK(dvp);
d711 2
@


1.9
log
@VFS Lite2 Changes
@
text
@a90 1
	struct proc *p = cnp->cn_proc;
d167 1
a167 1
			VOP_UNLOCK(ndp->ni_dvp, 0, p);
d274 1
a274 1
	struct proc *p = cnp->cn_proc;
d288 1
a288 1
	vn_lock(dp, LK_EXCLUSIVE | LK_RETRY, p);
d413 1
a413 1
			vn_lock(dp, LK_EXCLUSIVE | LK_RETRY, p);
a421 1
	ndp->ni_vp = NULL;
d437 1
a437 1
			vn_lock(dp, LK_EXCLUSIVE | LK_RETRY, p);
d494 3
a496 1
		if (vfs_busy(mp, 0, 0, p)) 
d498 2
a499 3
		error = VFS_ROOT(mp, &tdp);
		vfs_unbusy(mp, p);
		if (error)
d561 1
a561 1
		VOP_UNLOCK(dp, 0, p);
d566 1
a566 1
		VOP_UNLOCK(ndp->ni_dvp, 0, p);
a581 1
	struct proc *p = cnp->cn_proc;
d603 1
a603 1
	vn_lock(dp, LK_EXCLUSIVE | LK_RETRY, p);
d697 1
a697 1
		VOP_UNLOCK(dp, 0, p);
d702 1
a702 1
		VOP_UNLOCK(dvp, 0, p);
a708 2


@


1.8
log
@Switch to the NetBSD implementation of null path handling; by kleink@@NetBSD.org
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.7 1997/05/21 14:51:26 tholo Exp $	*/
d91 1
d168 1
a168 1
			VOP_UNLOCK(ndp->ni_dvp);
d275 1
a275 1

d289 1
a289 1
	VOP_LOCK(dp);
d414 1
a414 1
			VOP_LOCK(dp);
d423 1
d439 1
a439 1
			VOP_LOCK(dp);
d496 1
a496 3
		if (mp->mnt_flag & MNT_MLOCK) {
			mp->mnt_flag |= MNT_MWAIT;
			sleep((caddr_t)mp, PVFS);
d498 3
a500 2
		}
		if ((error = VFS_ROOT(dp->v_mountedhere, &tdp)) != 0)
d562 1
a562 1
		VOP_UNLOCK(dp);
d567 1
a567 1
		VOP_UNLOCK(ndp->ni_dvp);
d583 1
d605 1
a605 1
	VOP_LOCK(dp);
d699 1
a699 1
		VOP_UNLOCK(dp);
d704 1
a704 1
		VOP_UNLOCK(dvp);
d711 2
@


1.7
log
@Use vrele() if the vnode was not locked, not vput()
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.6 1997/03/01 23:03:38 tholo Exp $	*/
d89 1
a89 1
	int error, linklen, dironly = 0;
d126 1
d128 1
a128 1
		free(cnp->cn_pnbuf, M_NAMEI);
a131 17

	/*
	 * Ignore trailing /'s, except require the last path element
	 * to be a directory
	 */
	if (ndp->ni_pathlen > 2 && cnp->cn_pnbuf[ndp->ni_pathlen - 2] == '/') {
		/*
		 * Since the last name is no longer the terminal,
		 * force the FOLLOW flag
		 */
		cnp->cn_flags |= FOLLOW;
		dironly = 1;
		while (ndp->ni_pathlen > 2 &&
		       cnp->cn_pnbuf[ndp->ni_pathlen - 2] == '/')
			cnp->cn_pnbuf[--ndp->ni_pathlen - 1] = '\0';
	}

d139 10
a148 2
	dp = fdp->fd_cdir;
	VREF(dp);
a149 4
		/*
		 * Check if root directory should replace current directory.
		 * Done at start of translation and after symbolic link.
		 */
a150 9
		if (*(cnp->cn_nameptr) == '/') {
			vrele(dp);
			while (*(cnp->cn_nameptr) == '/') {
				cnp->cn_nameptr++;
				ndp->ni_pathlen--;
			}
			dp = ndp->ni_rootdir;
			VREF(dp);
		}
a159 13
			/*
			 * Check for directory if dironly
			 */
			if (dironly && ndp->ni_vp != NULL && ndp->ni_vp->v_type != VDIR) {
				if ((cnp->cn_flags & LOCKPARENT) && ndp->ni_pathlen == 1)
					VOP_UNLOCK(ndp->ni_dvp);
				if (cnp->cn_flags & LOCKLEAF)
					vput(ndp->ni_vp);
				else
					vrele(ndp->ni_vp);
				FREE(cnp->cn_pnbuf, M_NAMEI);
				return (ENOTDIR);
			}
d187 1
d189 1
a189 1
				free(cp, M_NAMEI);
a193 2
			if (ndp->ni_pathlen > 1)
				free(cp, M_NAMEI);
d195 1
a195 1
			break;
d206 8
d272 1
d290 34
d336 1
a336 1
	for (cp = cnp->cn_nameptr; *cp != 0 && *cp != '/'; cp++)
d351 31
a381 3
	cnp->cn_flags |= MAKEENTRY;
	if (*cp == '\0' && docache == 0)
		cnp->cn_flags &= ~MAKEENTRY;
a386 31
	if (*ndp->ni_next == 0)
		cnp->cn_flags |= ISLASTCN;
	else
		cnp->cn_flags &= ~ISLASTCN;


	/*
	 * Check for degenerate name (e.g. / or "")
	 * which is a way of talking about a directory,
	 * e.g. like "/." or ".".
	 */
	if (cnp->cn_nameptr[0] == '\0') {
		if (dp->v_type != VDIR) {
			error = ENOTDIR;
			goto bad;
		}
		if (cnp->cn_nameiop != LOOKUP) {
			error = EISDIR;
			goto bad;
		}
		if (wantparent) {
			ndp->ni_dvp = dp;
			VREF(dp);
		}
		ndp->ni_vp = dp;
		if (!(cnp->cn_flags & (LOCKPARENT | LOCKLEAF)))
			VOP_UNLOCK(dp);
		if (cnp->cn_flags & SAVESTART)
			panic("lookup: SAVESTART");
		return (0);
	}
d444 8
d475 3
a477 2
	 * Take into account any additional components consumed by
	 * the underlying filesystem.
d480 2
a481 3
		cnp->cn_nameptr += cnp->cn_consume;
		ndp->ni_next += cnp->cn_consume;
		ndp->ni_pathlen -= cnp->cn_consume;
d483 2
d506 2
a507 1
	 * Check for symbolic link
d509 3
a511 2
	if ((dp->v_type == VLNK) &&
	    ((cnp->cn_flags & FOLLOW) || *ndp->ni_next == '/')) {
d516 9
d527 2
a528 2
	 * Not a symbolic link.  If more pathname,
	 * continue at next component, else return.
d530 1
a530 1
	if (*ndp->ni_next == '/') {
a531 4
		while (*cnp->cn_nameptr == '/') {
			cnp->cn_nameptr++;
			ndp->ni_pathlen--;
		}
d535 2
d552 7
a558 3
	if (cnp->cn_flags & SAVESTART) {
		ndp->ni_startdir = ndp->ni_dvp;
		VREF(ndp->ni_startdir);
a559 2
	if (!wantparent)
		vrele(ndp->ni_dvp);
d565 1
a565 1
	if ((cnp->cn_flags & LOCKPARENT) && *ndp->ni_next == '\0')
d632 2
a633 16
	if (cnp->cn_nameptr[0] == '\0') {
		if (dp->v_type != VDIR) {
			error = ENOTDIR;
			goto bad;
		}
		if (cnp->cn_nameiop != LOOKUP || wantparent) {
			error = EISDIR;
			goto bad;
		}
		if (!(cnp->cn_flags & LOCKLEAF))
			VOP_UNLOCK(dp);
		*vpp = dp;
		if (cnp->cn_flags & SAVESTART)
			panic("lookup: SAVESTART");
		return (0);
	}
a693 1
	
@


1.6
log
@Don't dereference a vnode pointer that is NULL
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.5 1996/11/06 06:51:45 tholo Exp $	*/
d187 4
a190 1
				vput(ndp->ni_vp);
@


1.5
log
@Get vnode locking right when verifying pathnames ending in '/' are directories
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.4 1996/11/06 03:54:01 tholo Exp $	*/
d184 1
a184 1
			if (dironly && ndp->ni_vp->v_type != VDIR) {
@


1.4
log
@Temporarily disable special-case for trailing '/' in pathname lookups
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.3 1996/10/28 02:57:18 tholo Exp $	*/
d89 1
a89 4
	int error, linklen;
#if 0
	int dironly = 0;
#endif
a131 1
#if 0
a146 1
#endif
a180 1
#if 0
d185 1
a185 1
				if (cnp->cn_flags & LOCKPARENT)
d187 3
a189 4
				if (cnp->cn_flags & LOCKLEAF)
					VOP_UNLOCK(ndp->ni_vp);
				error = ENOTDIR;
				break;
a190 1
#endif
@


1.3
log
@Disallow null strings ("") as path names; ignore trailing / on path names,
but make sure the last element of such a path is a directory
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_lookup.c,v 1.2 1996/03/03 17:20:27 niklas Exp $	*/
d89 4
a92 1
	int error, linklen, dironly = 0;
d135 1
d151 1
d186 1
d198 1
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 1
a89 1
	int error, linklen;
d115 11
d131 17
a148 4
#ifdef KTRACE
	if (KTRPOINT(cnp->cn_proc, KTR_NAMEI))
		ktrnamei(cnp->cn_proc->p_tracep, cnp->cn_pnbuf);
#endif
d181 11
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: vfs_lookup.c,v 1.15 1995/03/08 01:20:50 cgd Exp $	*/
d149 1
a149 1
		if (error = lookup(ndp)) {
d182 2
a183 1
		if (error = VOP_READLINK(ndp->ni_vp, &auio, cnp->cn_cred)) {
d380 1
a380 1
	if (error = VOP_LOOKUP(dp, &ndp->ni_vp, cnp)) {
d447 1
a447 1
		if (error = VFS_ROOT(dp->v_mountedhere, &tdp))
d592 1
a592 1
	if (error = VOP_LOOKUP(dp, vpp, cnp)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
