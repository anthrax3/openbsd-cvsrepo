head	1.49;
access;
symbols
	OPENBSD_6_2:1.49.0.2
	OPENBSD_6_2_BASE:1.49
	OPENBSD_6_1:1.49.0.4
	OPENBSD_6_1_BASE:1.49
	OPENBSD_6_0:1.47.0.2
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.34.0.12
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.10
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.8
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.6
	OPENBSD_5_0:1.34.0.4
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.32.0.10
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.6
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.8
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.4
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.31.0.4
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.30.0.6
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.4
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.29.0.4
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.22
	UBC:1.20.0.4
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.4
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.49
date	2017.02.14.10.31.15;	author mpi;	state Exp;
branches;
next	1.48;
commitid	PmGi4EGraGC0Z0ml;

1.48
date	2016.09.24.18.35.52;	author tedu;	state Exp;
branches;
next	1.47;
commitid	1tGMcqbcyDEnrWA7;

1.47
date	2016.03.15.04.19.26;	author stefan;	state Exp;
branches;
next	1.46;
commitid	dVAAaMtSGQ5wNbP2;

1.46
date	2016.02.11.18.59.15;	author stefan;	state Exp;
branches;
next	1.45;
commitid	ccJ8uG9soPPhkMrA;

1.45
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.44;
commitid	fbhqfhfdKxBcsetK;

1.44
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.43;
commitid	p4LJxGKbi0BU2cG6;

1.43
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.42;
commitid	C5iGb36LQxjM60Q3;

1.42
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.41;
commitid	qHQiR2HLROzvZr7B;

1.41
date	2014.11.01.23.58.28;	author tedu;	state Exp;
branches;
next	1.40;
commitid	9PQjDNhyphSHE6E7;

1.40
date	2014.07.13.15.48.41;	author tedu;	state Exp;
branches;
next	1.39;
commitid	Szz2w3fAfwxRfkCN;

1.39
date	2014.07.13.15.29.04;	author tedu;	state Exp;
branches;
next	1.38;
commitid	bFFVdS3JEaMhyZxJ;

1.38
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.37;
commitid	QlVV51SZgNFxsXxC;

1.37
date	2013.10.19.09.24.57;	author reyk;	state Exp;
branches;
next	1.36;

1.36
date	2013.09.14.02.28.01;	author guenther;	state Exp;
branches;
next	1.35;

1.35
date	2013.08.13.05.52.23;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.07.16.21.47;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.06.19.20.24;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.12.16.15.49;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.16.17.27.30;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.28.00.14.29;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.28.02.11.33;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.09.20.18.28;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.31.11.10.41;	author markus;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.01.09.22.27.12;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.12.13.31.20;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.27.09.55.07;	author niklas;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2001.06.27.04.49.45;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.26.06.27.40;	author aaron;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.23.05.45.13;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.07.19.21.30;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.07.19.07.00;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.07.18.39.13;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.05.21.47.14;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.19.09.58.20;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2000.03.03.16.58.49;	author art;	state Exp;
branches;
next	1.10;

1.10
date	99.11.07.17.39.14;	author provos;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.04.28.09.28.15;	author art;	state Exp;
branches;
next	1.8;

1.8
date	99.02.26.04.56.02;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.02.26.03.16.47;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	98.07.28.00.13.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.05.11.05.41.59;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.02.24.14.19.56;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.27.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.17.05.09.13;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2000.03.24.09.09.24;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.05.14.22.32.41;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.07.04.10.48.26;	author niklas;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.10.2.8;

1.10.2.8
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.10.2.9;

1.10.2.9
date	2004.06.05.17.19.55;	author niklas;	state Exp;
branches;
next	1.10.2.10;

1.10.2.10
date	2004.06.08.20.15.48;	author drahn;	state Exp;
branches;
next	1.10.2.11;

1.10.2.11
date	2004.06.10.11.40.33;	author niklas;	state Exp;
branches;
next	;

1.20.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.20.4.3;

1.20.4.3
date	2003.05.19.22.31.10;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Convert most of the manual checks for CPU hogging to sched_pause().

The distinction between preempt() and yield() stays as it is usueful
to know if a thread decided to yield by itself or if the kernel told
him to go away.

ok tedu@@, guenther@@
@
text
@/*	$OpenBSD: kern_subr.c,v 1.48 2016/09/24 18:35:52 tedu Exp $	*/
/*	$NetBSD: kern_subr.c,v 1.15 1996/04/09 17:21:56 ragge Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_subr.c	8.3 (Berkeley) 1/21/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/sched.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/resourcevar.h>

int
uiomove(void *cp, size_t n, struct uio *uio)
{
	struct iovec *iov;
	size_t cnt;
	int error = 0;

#ifdef DIAGNOSTIC
	if (uio->uio_rw != UIO_READ && uio->uio_rw != UIO_WRITE)
		panic("uiomove: mode");
	if (uio->uio_segflg == UIO_USERSPACE && uio->uio_procp != curproc)
		panic("uiomove: proc");
#endif

	if (n > uio->uio_resid)
		n = uio->uio_resid;

	while (n > 0) {
		iov = uio->uio_iov;
		cnt = iov->iov_len;
		if (cnt == 0) {
			KASSERT(uio->uio_iovcnt > 0);
			uio->uio_iov++;
			uio->uio_iovcnt--;
			continue;
		}
		if (cnt > n)
			cnt = n;
		switch (uio->uio_segflg) {

		case UIO_USERSPACE:
			sched_pause(preempt);
			if (uio->uio_rw == UIO_READ)
				error = copyout(cp, iov->iov_base, cnt);
			else
				error = copyin(iov->iov_base, cp, cnt);
			if (error)
				return (error);
			break;

		case UIO_SYSSPACE:
			if (uio->uio_rw == UIO_READ)
				error = kcopy(cp, iov->iov_base, cnt);
			else
				error = kcopy(iov->iov_base, cp, cnt);
			if (error)
				return(error);
		}
		iov->iov_base = (caddr_t)iov->iov_base + cnt;
		iov->iov_len -= cnt;
		uio->uio_resid -= cnt;
		uio->uio_offset += cnt;
		cp = (caddr_t)cp + cnt;
		n -= cnt;
	}
	return (error);
}

/*
 * Give next character to user as result of read.
 */
int
ureadc(int c, struct uio *uio)
{
	struct iovec *iov;

	if (uio->uio_resid == 0)
#ifdef DIAGNOSTIC
		panic("ureadc: zero resid");
#else
		return (EINVAL);
#endif
again:
	if (uio->uio_iovcnt <= 0)
#ifdef DIAGNOSTIC
		panic("ureadc: non-positive iovcnt");
#else
		return (EINVAL);
#endif
	iov = uio->uio_iov;
	if (iov->iov_len <= 0) {
		uio->uio_iovcnt--;
		uio->uio_iov++;
		goto again;
	}
	switch (uio->uio_segflg) {

	case UIO_USERSPACE:
	{
		char tmp = c;

		if (copyout(&tmp, iov->iov_base, sizeof(char)) != 0)
			return (EFAULT);
	}
		break;

	case UIO_SYSSPACE:
		*(char *)iov->iov_base = c;
		break;
	}
	iov->iov_base = (caddr_t)iov->iov_base + 1;
	iov->iov_len--;
	uio->uio_resid--;
	uio->uio_offset++;
	return (0);
}

/*
 * General routine to allocate a hash table.
 */
void *
hashinit(int elements, int type, int flags, u_long *hashmask)
{
	u_long hashsize, i;
	LIST_HEAD(generic, generic) *hashtbl;

	if (elements <= 0)
		panic("hashinit: bad cnt");
	for (hashsize = 1; hashsize < elements; hashsize <<= 1)
		continue;
	hashtbl = mallocarray(hashsize, sizeof(*hashtbl), type, flags);
	if (hashtbl == NULL)
		return NULL;
	for (i = 0; i < hashsize; i++)
		LIST_INIT(&hashtbl[i]);
	*hashmask = hashsize - 1;
	return (hashtbl);
}

void
hashfree(void *hash, int elements, int type)
{
	u_long hashsize;
	LIST_HEAD(generic, generic) *hashtbl = hash;

	if (elements <= 0)
		panic("hashfree: bad cnt");
	for (hashsize = 1; hashsize < elements; hashsize <<= 1)
		continue;

	free(hashtbl, type, sizeof(*hashtbl) * hashsize);
}

/*
 * "startup hook" types, functions, and variables.
 */

struct hook_desc_head startuphook_list =
    TAILQ_HEAD_INITIALIZER(startuphook_list);

void *
hook_establish(struct hook_desc_head *head, int tail, void (*fn)(void *),
    void *arg)
{
	struct hook_desc *hdp;

	hdp = malloc(sizeof(*hdp), M_DEVBUF, M_NOWAIT);
	if (hdp == NULL)
		return (NULL);

	hdp->hd_fn = fn;
	hdp->hd_arg = arg;
	if (tail)
		TAILQ_INSERT_TAIL(head, hdp, hd_list);
	else
		TAILQ_INSERT_HEAD(head, hdp, hd_list);

	return (hdp);
}

void
hook_disestablish(struct hook_desc_head *head, void *vhook)
{
	struct hook_desc *hdp;

#ifdef DIAGNOSTIC
	for (hdp = TAILQ_FIRST(head); hdp != NULL;
	    hdp = TAILQ_NEXT(hdp, hd_list))
                if (hdp == vhook)
			break;
	if (hdp == NULL)
		return;
#endif
	hdp = vhook;
	TAILQ_REMOVE(head, hdp, hd_list);
	free(hdp, M_DEVBUF, sizeof(*hdp));
}

/*
 * Run hooks.  Startup hooks are invoked right after scheduler_start but
 * before root is mounted.  Shutdown hooks are invoked immediately before the
 * system is halted or rebooted, i.e. after file systems unmounted,
 * after crash dump done, etc.
 */
void
dohooks(struct hook_desc_head *head, int flags)
{
	struct hook_desc *hdp, *hdp_temp;

	if ((flags & HOOK_REMOVE) == 0) {
		TAILQ_FOREACH_SAFE(hdp, head, hd_list, hdp_temp) {
			(*hdp->hd_fn)(hdp->hd_arg);
		}
	} else {
		while ((hdp = TAILQ_FIRST(head)) != NULL) {
			TAILQ_REMOVE(head, hdp, hd_list);
			(*hdp->hd_fn)(hdp->hd_arg);
			if ((flags & HOOK_FREE) != 0)
				free(hdp, M_DEVBUF, sizeof(*hdp));
		}
	}
}
@


1.48
log
@introduce hashfree() function to free hash tables, with sizes.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.47 2016/03/15 04:19:26 stefan Exp $	*/
d79 1
a79 3
			if (curcpu()->ci_schedstate.spc_schedflags &
			    SPCF_SHOULDYIELD)
				preempt(NULL);
@


1.47
log
@Remove now unused legacy uiomovei() function.

All its callers got reviewed and converted to
use uiomove() properly.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.46 2016/02/11 18:59:15 stefan Exp $	*/
d177 14
@


1.46
log
@Make sure uiomove does not copy more than uio_resid bytes, as the manual
says. Move code belonging to diagnostics in the #ifdef DIAGNOSTIC part
and add a KASSERT that makes sure that we do not run beyond uio_iov.
Diff from Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.45 2015/12/11 16:07:02 mpi Exp $	*/
a105 9
}

int
uiomovei(void *cp, int n, struct uio *uio)
{
	if (n < 0)
		return 0;

	return uiomove(cp, (size_t)n, uio);
@


1.45
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.44 2015/03/14 03:38:50 jsg Exp $	*/
a53 3
	struct proc *p;

	p = uio->uio_procp;
d58 1
a58 1
	if (uio->uio_segflg == UIO_USERSPACE && p != curproc)
d61 5
a65 1
	while (n > 0 && uio->uio_resid) {
d69 1
@


1.44
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.43 2015/02/10 21:56:09 miod Exp $	*/
d187 1
a187 1
 * "Mountroot/startup hook" types, functions, and variables.
a191 2
struct hook_desc_head mountroothook_list =
    TAILQ_HEAD_INITIALIZER(mountroothook_list);
@


1.43
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.42 2014/12/10 15:29:53 mikeb Exp $	*/
a45 1
#include <sys/kernel.h>
@


1.42
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.41 2014/11/01 23:58:28 tedu Exp $	*/
d50 1
a50 1
uiomove(void *cp, int n, struct uio *uio)
d105 9
@


1.41
log
@add a few sizes to free
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.40 2014/07/13 15:48:41 tedu Exp $	*/
d179 1
a179 1
 * "Shutdown/startup hook" types, functions, and variables.
a183 2
struct hook_desc_head shutdownhook_list =
    TAILQ_HEAD_INITIALIZER(shutdownhook_list);
@


1.40
log
@trim some casts
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.39 2014/07/13 15:29:04 tedu Exp $	*/
d224 1
a224 1
	free(hdp, M_DEVBUF, 0);
d247 1
a247 1
				free(hdp, M_DEVBUF, 0);
@


1.39
log
@use mallocarray where arguments are multipled. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.38 2014/07/12 18:43:32 tedu Exp $	*/
d195 1
a195 1
	hdp = (struct hook_desc *)malloc(sizeof (*hdp), M_DEVBUF, M_NOWAIT);
@


1.38
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.37 2013/10/19 09:24:57 reyk Exp $	*/
d169 1
a169 1
	hashtbl = malloc(hashsize * sizeof(*hashtbl), type, flags);
@


1.37
log
@When hooks are called, allow them to disestablish themselves by using
the safe version to traverse the TAILQ list.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.36 2013/09/14 02:28:01 guenther Exp $	*/
d224 1
a224 1
	free(hdp, M_DEVBUF);
d247 1
a247 1
				free(hdp, M_DEVBUF);
@


1.36
log
@Correct the handling of I/O of >=2^32 bytes and the ktracing there of
by using size_t/ssize_t instead of int/u_int to handle I/O lengths in
uiomove(), vn_fsizechk(), and ktrgenio().  Eliminate the always-zero
'error' argument to ktrgenio() at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.35 2013/08/13 05:52:23 guenther Exp $	*/
d236 1
a236 1
	struct hook_desc *hdp;
d239 1
a239 1
		TAILQ_FOREACH(hdp, head, hd_list) {
@


1.35
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.34 2010/09/07 16:21:47 deraadt Exp $	*/
d53 1
a53 1
	u_int cnt;
d75 1
a75 1
		switch ((int)uio->uio_segflg) {
a76 1
		case UIO_USERSPACE | 0x10:
d134 1
a134 1
	switch ((int)uio->uio_segflg) {
a135 1
	case UIO_USERSPACE | 0x10:
@


1.34
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.33 2010/09/06 19:20:24 deraadt Exp $	*/
d75 1
a75 1
		switch (uio->uio_segflg) {
d77 1
d135 1
a135 1
	switch (uio->uio_segflg) {
d137 1
@


1.33
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.32 2008/06/12 16:15:49 marco Exp $	*/
a249 70
}

/*
 * "Power hook" types, functions, and variables.
 */

struct powerhook_desc {
	CIRCLEQ_ENTRY(powerhook_desc) sfd_list;
	void	(*sfd_fn)(int, void *);
	void	*sfd_arg;
};

CIRCLEQ_HEAD(, powerhook_desc) powerhook_list =
	CIRCLEQ_HEAD_INITIALIZER(powerhook_list);

void *
powerhook_establish(void (*fn)(int, void *), void *arg)
{
	struct powerhook_desc *ndp;

	ndp = (struct powerhook_desc *)
	    malloc(sizeof(*ndp), M_DEVBUF, M_NOWAIT);
	if (ndp == NULL)
		return NULL;

	ndp->sfd_fn = fn;
	ndp->sfd_arg = arg;
	CIRCLEQ_INSERT_HEAD(&powerhook_list, ndp, sfd_list);

	return (ndp);
}

void
powerhook_disestablish(void *vhook)
{
#ifdef DIAGNOSTIC
	struct powerhook_desc *dp;

	CIRCLEQ_FOREACH(dp, &powerhook_list, sfd_list)
                if (dp == vhook)
			break;
	if (dp == NULL)
		panic("powerhook_disestablish: hook not established");
#endif

	CIRCLEQ_REMOVE(&powerhook_list, (struct powerhook_desc *)vhook,
		sfd_list);
	free(vhook, M_DEVBUF);
}

/*
 * Run power hooks.
 */
void
dopowerhooks(int why)
{
	struct powerhook_desc *dp;
	int s;

	s = splhigh();
	if (why == DVACT_RESUME) {
		CIRCLEQ_FOREACH_REVERSE(dp, &powerhook_list, sfd_list) {
			(*dp->sfd_fn)(why, dp->sfd_arg);
		}
	} else {
		CIRCLEQ_FOREACH(dp, &powerhook_list, sfd_list) {
			(*dp->sfd_fn)(why, dp->sfd_arg);
		}
	}
	splx(s);
@


1.32
log
@Remove silly panic when disestablish cookie doesnt exist

ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.31 2007/05/16 17:27:30 art Exp $	*/
d310 1
a310 1
	if (why == PWR_RESUME) {
@


1.31
log
@The world of __HAVEs and __HAVE_NOTs is reducing. All architectures
have cpu_info now, so kill the option.

eyeballed by jsg@@ and grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.30 2005/11/28 00:14:29 jsg Exp $	*/
d220 1
a220 1
		panic("hook_disestablish: hook not established");
@


1.30
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.29 2004/11/28 02:11:33 deraadt Exp $	*/
a77 1
#ifdef __HAVE_CPUINFO
a79 3
#else
			if (p->p_schedflags & PSCHED_SHOULDYIELD)
#endif
@


1.29
log
@mountroothooks are called after the root filesystem is mounted.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.28 2004/06/13 21:49:26 niklas Exp $	*/
d50 1
a50 4
uiomove(cp, n, uio)
	register void *cp;
	register int n;
	register struct uio *uio;
d52 1
a52 1
	register struct iovec *iov;
d115 1
a115 3
ureadc(c, uio)
	register int c;
	register struct uio *uio;
d117 1
a117 1
	register struct iovec *iov;
d164 1
a164 3
hashinit(elements, type, flags, hashmask)
	int elements, type, flags;
	u_long *hashmask;
d194 2
a195 5
hook_establish(head, tail, fn, arg)
	struct hook_desc_head *head;
	int tail;
	void (*fn)(void *);
	void *arg;
d214 1
a214 3
hook_disestablish(head, vhook)
	struct hook_desc_head *head;
	void *vhook;
d270 1
a270 3
powerhook_establish(fn, arg)
	void (*fn)(int, void *);
	void *arg;
d287 1
a287 2
powerhook_disestablish(vhook)
	void *vhook;
d308 1
a308 2
dopowerhooks(why)
	int why;
@


1.28
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d197 2
@


1.27
log
@Merge in a piece of the SMP branch into HEAD.

Introduce the cpu_info structure, p_cpu field in struct proc and global
scheduling context and various changed code to deal with this. At the
moment no architecture uses this stuff yet, but it will allow us slow and
controlled migration to the new APIs.

All new code is ifdef:ed out.

ok deraadt@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.26 2003/10/31 11:10:41 markus Exp $	*/
d43 1
@


1.26
log
@allocate at least as much elements as requested in hashinit
fixes pr 3537, based on patch from daniel@@nofsk.nofsk.au.eu.org
ok millert@@, deraadt@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.25 2003/07/21 22:44:50 tedu Exp $	*/
d80 4
d85 1
@


1.25
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.24 2003/06/02 23:28:06 millert Exp $	*/
d167 1
a167 1
	long hashsize;
a168 1
	int i;
d172 1
a172 1
	for (hashsize = 1; hashsize <= elements; hashsize <<= 1)
d174 1
a174 2
	hashsize >>= 1;
	hashtbl = malloc((u_long)hashsize * sizeof(*hashtbl), type, flags);
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.23 2003/01/09 22:27:12 miod Exp $	*/
d50 1
a50 1
	register caddr_t cp;
d102 1
a102 1
		cp += cnt;
@


1.23
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.22 2002/07/12 13:31:20 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.22
log
@- Add a flags argument to dohooks.
  The flag can be either HOOK_REMOVE or HOOK_REMOVE|HOOK_FREE.
   o HOOK_REMOVE removes the hook from the list before executing it.
   o HOOK_FREE frees the hook after that.

- Let dostartuphooks use HOOK_REMOVE|HOOK_FREE so we can reclaim the memory.

- Let doshutdownhooks use HOOK_REMOVE so that when some shutdown hook
  panics (they do that all the #@@$%! time these days) we don't loop
  for ever. Don't HOOK_FREE, it doesn't matter and I don't want to add
  another possible panic condition for shutdown hooks.

- Actually free the pointer we're throwing away in hook_disestablish (I wonder
  how much memory this has leaked over the years).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.21 2002/03/14 01:27:04 millert Exp $	*/
d144 4
a147 1
		if (subyte(iov->iov_base, c) < 0)
d149 1
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.20 2001/07/27 09:55:07 niklas Exp $	*/
a221 1
#ifdef DIAGNOSTIC
d224 1
d232 3
a234 2

	TAILQ_REMOVE(head, (struct hook_desc *)vhook, hd_list);
d244 1
a244 2
dohooks(head)
	struct hook_desc_head *head;
d248 12
a259 3
	for (hdp = TAILQ_FIRST(head); hdp != NULL;
	    hdp = TAILQ_NEXT(hdp, hd_list))
		(*hdp->hd_fn)(hdp->hd_arg);
@


1.20
log
@Startup hooks.  Can be used for providing root/swap devices from device
systems which want configuration to finish late, like I2O.  Implemented via
a general hooks mechanism which the shutdown hooks have been converted to
use as well.  It even has manpages!
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.19 2001/06/27 04:49:45 art Exp $	*/
d198 1
a198 1
	void (*fn) __P((void *));
d259 1
a259 1
	void	(*sfd_fn) __P((int, void *));
d268 1
a268 1
	void (*fn) __P((int, void *));
@


1.20.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.20 2001/07/27 09:55:07 niklas Exp $	*/
d198 1
a198 1
	void (*fn)(void *);
d259 1
a259 1
	void	(*sfd_fn)(int, void *);
d268 1
a268 1
	void (*fn)(int, void *);
@


1.20.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.20.4.1 2002/06/11 03:29:40 art Exp $	*/
d222 1
a224 1
#ifdef DIAGNOSTIC
d232 2
a233 3
	hdp = vhook;
	TAILQ_REMOVE(head, hdp, hd_list);
	free(hdp, M_DEVBUF);
d243 2
a244 1
dohooks(struct hook_desc_head *head, int flags)
d248 3
a250 12
	if ((flags & HOOK_REMOVE) == 0) {
		TAILQ_FOREACH(hdp, head, hd_list) {
			(*hdp->hd_fn)(hdp->hd_arg);
		}
	} else {
		while ((hdp = TAILQ_FIRST(head)) != NULL) {
			TAILQ_REMOVE(head, hdp, hd_list);
			(*hdp->hd_fn)(hdp->hd_arg);
			if ((flags & HOOK_FREE) != 0)
				free(hdp, M_DEVBUF);
		}
	}
@


1.20.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d144 1
a144 4
	{
		char tmp = c;

		if (copyout(&tmp, iov->iov_base, sizeof(char)) != 0)
a145 1
	}
@


1.19
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.18 2001/06/26 06:27:40 aaron Exp $	*/
d186 1
a186 1
 * "Shutdown hook" types, functions, and variables.
d189 4
a192 9
struct shutdownhook_desc {
	LIST_ENTRY(shutdownhook_desc) sfd_list;
	void	(*sfd_fn) __P((void *));
	void	*sfd_arg;
};

LIST_HEAD(, shutdownhook_desc) shutdownhook_list;

int shutdownhooks_done;
d195 3
a197 1
shutdownhook_establish(fn, arg)
d201 1
a201 1
	struct shutdownhook_desc *ndp;
d203 10
a212 4
	ndp = (struct shutdownhook_desc *)
	    malloc(sizeof (*ndp), M_DEVBUF, M_NOWAIT);
	if (ndp == NULL)
		return NULL;
d214 1
a214 5
	ndp->sfd_fn = fn;
	ndp->sfd_arg = arg;
	LIST_INSERT_HEAD(&shutdownhook_list, ndp, sfd_list);

	return (ndp);
d218 2
a219 1
shutdownhook_disestablish(vhook)
d223 1
a223 1
	struct shutdownhook_desc *dp;
d225 3
a227 3
	for (dp = shutdownhook_list.lh_first; dp != NULL;
	    dp = dp->sfd_list.le_next)
                if (dp == vhook)
d229 2
a230 2
	if (dp == NULL)
		panic("shutdownhook_disestablish: hook not established");
d233 1
a233 1
	LIST_REMOVE((struct shutdownhook_desc *)vhook, sfd_list);
d237 2
a238 1
 * Run shutdown hooks.  Should be invoked immediately before the
d243 2
a244 1
doshutdownhooks()
d246 1
a246 4
	struct shutdownhook_desc *dp;

	if (shutdownhooks_done)
		return;
d248 3
a250 3
	for (dp = shutdownhook_list.lh_first; dp != NULL; dp =
	    dp->sfd_list.le_next)
		(*dp->sfd_fn)(dp->sfd_arg);
@


1.18
log
@Appease gcc by not using void pointers in arithmetic operations; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.17 2001/06/23 05:45:13 art Exp $	*/
a94 1
#if defined(UVM)
a100 7
#else
			if (uio->uio_rw == UIO_READ)
				bcopy((caddr_t)cp, iov->iov_base, cnt);
			else
				bcopy(iov->iov_base, (caddr_t)cp, cnt);
			break;
#endif
@


1.17
log
@Since malloc in hashinit can get M_NOWAIT flags, we should
check the return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.16 2000/09/07 19:21:30 art Exp $	*/
d110 1
a110 1
		iov->iov_base += cnt;
d160 1
a160 1
	iov->iov_base++;
@


1.16
log
@On resume run the powerhook in installation order.
(the powerhooks were always run in reverse order).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.15 2000/09/07 19:07:00 art Exp $	*/
d185 2
@


1.15
log
@Put powerhooks on a CIRCLEQ instead of LIST.
Use FOREACH macros instead of walking the list manually.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.14 2000/09/07 18:39:13 art Exp $	*/
d322 8
a329 2
	CIRCLEQ_FOREACH(dp, &powerhook_list, sfd_list) {
		(*dp->sfd_fn)(why, dp->sfd_arg);
@


1.14
log
@Run powerhooks at splhigh.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.13 2000/09/05 21:47:14 aaron Exp $	*/
d265 1
a265 1
	LIST_ENTRY(powerhook_desc) sfd_list;
d270 2
a271 1
LIST_HEAD(, powerhook_desc) powerhook_list;
d287 1
a287 1
	LIST_INSERT_HEAD(&powerhook_list, ndp, sfd_list);
d299 1
a299 2
	for (dp = powerhook_list.lh_first; dp != NULL;
	    dp = dp->sfd_list.le_next)
d306 2
a307 1
	LIST_REMOVE((struct powerhook_desc *)vhook, sfd_list);
d322 1
a322 3
	for (dp = LIST_FIRST(&powerhook_list); 
	     dp != NULL; 
	     dp = LIST_NEXT(dp, sfd_list)) {
@


1.13
log
@Wrap power hooks in splimp(), fixes WaveLAN suspend problem; thanks art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.12 2000/04/19 09:58:20 art Exp $	*/
d320 1
a320 1
	s = splimp();
@


1.12
log
@Remove the roundrobin_attempts hack and replace it with per-process scheduling
flags (much nicer for future smp work).
Add two generic functions yield() and preempt(). Use preepmt() in uio when
we are told to yield.
Based on my idea, code written by Jason Thorpe from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.11 2000/03/03 16:58:49 art Exp $	*/
d318 1
d320 1
d326 1
@


1.11
log
@If we attempted reschedule two times without suceeding, uiomove will yield,
giving other processes a chance to run.

A process feeding a huge buffer to {read,write}{,v} on a file that doesn't
need to wait for I/O, could have hogged a lot of cpu in the kernel, blocking
all userland activity.

Based on a similiar fix in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.10 1999/11/07 17:39:14 provos Exp $	*/
a51 4
void uio_yield __P((struct proc *));

#define UIO_NEED_YIELD (roundrobin_attempts >= 2)

d84 2
a85 2
			if (UIO_NEED_YIELD)
				uio_yield(p);
a164 14
}

void
uio_yield(p)
	struct proc *p;
{
	int s;

	p->p_priority = p->p_usrpri;
	s = splstatclock();
	setrunqueue(p);
	p->p_stats->p_ru.ru_nivcsw++;
	mi_switch();
	splx(s);
@


1.10
log
@add APM powerhooks.
from NetBSD, Sat Jun 26 08:25:25 1999 UTC by augustss:

Add powerhooks, i.e., the ability to register a function that will be
called when the machine does a suspend or resume.
XXX Will go away when Jason's kevents come to life.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.9 1999/04/28 09:28:15 art Exp $	*/
d49 6
d65 3
d72 2
a73 2
	if (uio->uio_segflg == UIO_USERSPACE && uio->uio_procp != curproc)
		panic("uiomove proc");
d88 2
d169 14
@


1.10.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a48 6
#include <sys/kernel.h>
#include <sys/resourcevar.h>

void uio_yield __P((struct proc *));

#define UIO_NEED_YIELD (roundrobin_attempts >= 2)
a58 3
	struct proc *p;

	p = uio->uio_procp;
d63 2
a64 2
	if (uio->uio_segflg == UIO_USERSPACE && p != curproc)
		panic("uiomove: proc");
a78 2
			if (UIO_NEED_YIELD)
				uio_yield(p);
a157 14
}

void
uio_yield(p)
	struct proc *p;
{
	int s;

	p->p_priority = p->p_usrpri;
	s = splstatclock();
	setrunqueue(p);
	p->p_stats->p_ru.ru_nivcsw++;
	mi_switch();
	splx(s);
@


1.10.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.16 2000/09/07 19:21:30 art Exp $	*/
d52 4
d88 2
a89 2
			if (p->p_schedflags & PSCHED_SHOULDYIELD)
				preempt(NULL);
d171 14
d283 1
a283 1
	CIRCLEQ_ENTRY(powerhook_desc) sfd_list;
d288 1
a288 2
CIRCLEQ_HEAD(, powerhook_desc) powerhook_list =
	CIRCLEQ_HEAD_INITIALIZER(powerhook_list);
d304 1
a304 1
	CIRCLEQ_INSERT_HEAD(&powerhook_list, ndp, sfd_list);
d316 2
a317 1
	CIRCLEQ_FOREACH(dp, &powerhook_list, sfd_list)
d324 1
a324 2
	CIRCLEQ_REMOVE(&powerhook_list, (struct powerhook_desc *)vhook,
		sfd_list);
a335 1
	int s;
d337 4
a340 9
	s = splhigh();
	if (why == PWR_RESUME) {
		CIRCLEQ_FOREACH_REVERSE(dp, &powerhook_list, sfd_list) {
			(*dp->sfd_fn)(why, dp->sfd_arg);
		}
	} else {
		CIRCLEQ_FOREACH(dp, &powerhook_list, sfd_list) {
			(*dp->sfd_fn)(why, dp->sfd_arg);
		}
a341 1
	splx(s);
@


1.10.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.10.2.2 2001/05/14 22:32:41 niklas Exp $	*/
d95 1
d102 7
d110 1
a110 1
		iov->iov_base = (caddr_t)iov->iov_base + cnt;
d160 1
a160 1
	iov->iov_base = (caddr_t)iov->iov_base + 1;
a184 2
	if (hashtbl == NULL)
		return NULL;
@


1.10.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.10.2.3 2001/07/04 10:48:26 niklas Exp $	*/
d186 1
a186 1
 * "Shutdown/startup hook" types, functions, and variables.
d189 9
a197 4
struct hook_desc_head startuphook_list =
    TAILQ_HEAD_INITIALIZER(startuphook_list);
struct hook_desc_head shutdownhook_list =
    TAILQ_HEAD_INITIALIZER(shutdownhook_list);
d200 1
a200 3
hook_establish(head, tail, fn, arg)
	struct hook_desc_head *head;
	int tail;
d204 1
a204 1
	struct hook_desc *hdp;
d206 4
a209 10
	hdp = (struct hook_desc *)malloc(sizeof (*hdp), M_DEVBUF, M_NOWAIT);
	if (hdp == NULL)
		return (NULL);

	hdp->hd_fn = fn;
	hdp->hd_arg = arg;
	if (tail)
		TAILQ_INSERT_TAIL(head, hdp, hd_list);
	else
		TAILQ_INSERT_HEAD(head, hdp, hd_list);
d211 5
a215 1
	return (hdp);
d219 1
a219 2
hook_disestablish(head, vhook)
	struct hook_desc_head *head;
d223 1
a223 1
	struct hook_desc *hdp;
d225 3
a227 3
	for (hdp = TAILQ_FIRST(head); hdp != NULL;
	    hdp = TAILQ_NEXT(hdp, hd_list))
                if (hdp == vhook)
d229 2
a230 2
	if (hdp == NULL)
		panic("hook_disestablish: hook not established");
d233 1
a233 1
	TAILQ_REMOVE(head, (struct hook_desc *)vhook, hd_list);
d237 1
a237 2
 * Run hooks.  Startup hooks are invoked right after scheduler_start but
 * before root is mounted.  Shutdown hooks are invoked immediately before the
d242 1
a242 2
dohooks(head)
	struct hook_desc_head *head;
d244 4
a247 1
	struct hook_desc *hdp;
d249 3
a251 3
	for (hdp = TAILQ_FIRST(head); hdp != NULL;
	    hdp = TAILQ_NEXT(hdp, hd_list))
		(*hdp->hd_fn)(hdp->hd_arg);
@


1.10.2.5
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d198 1
a198 1
	void (*fn)(void *);
d259 1
a259 1
	void	(*sfd_fn)(int, void *);
d268 1
a268 1
	void (*fn)(int, void *);
@


1.10.2.6
log
@Sync the SMP branch with 3.3
@
text
@d144 1
a144 4
	{
		char tmp = c;

		if (copyout(&tmp, iov->iov_base, sizeof(char)) != 0)
a145 1
	}
d222 1
a224 1
#ifdef DIAGNOSTIC
d232 2
a233 3
	hdp = vhook;
	TAILQ_REMOVE(head, hdp, hd_list);
	free(hdp, M_DEVBUF);
d243 2
a244 1
dohooks(struct hook_desc_head *head, int flags)
d248 3
a250 12
	if ((flags & HOOK_REMOVE) == 0) {
		TAILQ_FOREACH(hdp, head, hd_list) {
			(*hdp->hd_fn)(hdp->hd_arg);
		}
	} else {
		while ((hdp = TAILQ_FIRST(head)) != NULL) {
			TAILQ_REMOVE(head, hdp, hd_list);
			(*hdp->hd_fn)(hdp->hd_arg);
			if ((flags & HOOK_FREE) != 0)
				free(hdp, M_DEVBUF);
		}
	}
@


1.10.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.10.2.6 2003/03/28 00:41:26 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
	register void *cp;
d102 1
a102 1
		cp = (caddr_t)cp + cnt;
d167 1
a167 1
	u_long hashsize, i;
d169 1
d173 1
a173 1
	for (hashsize = 1; hashsize < elements; hashsize <<= 1)
d175 2
a176 1
	hashtbl = malloc(hashsize * sizeof(*hashtbl), type, flags);
@


1.10.2.9
log
@Make a few scheduling globals per-cpu, mostly NetBSD code
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.10.2.8 2004/02/19 10:56:37 niklas Exp $	*/
a79 4
#ifdef MULTIPROCESSOR
			if (curcpu()->ci_schedstate.spc_schedflags &
			    SPCF_SHOULDYIELD)
#else
a80 1
#endif
@


1.10.2.10
log
@Include sched.h in kern_ktrace and kern_subr since they use those
defines in the MULTIPROCESSOR cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.10.2.9 2004/06/05 17:19:55 niklas Exp $	*/
a42 1
#include <sys/sched.h>
@


1.10.2.11
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 1
a81 1
#ifdef __HAVE_CPUINFO
@


1.9
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.8 1999/02/26 04:56:02 art Exp $	*/
d251 66
@


1.8
log
@uvm uses kcopy when uiomoving from sysspace
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.7 1999/02/26 03:16:47 millert Exp $	*/
d164 1
a164 9
hashinit(elements, type, hashmask)
	int elements, type;
	u_long *hashmask;
{
	return newhashinit(elements, type, M_WAITOK, hashmask);
}

void *
newhashinit(elements, type, flags, hashmask)
@


1.7
log
@Add newhashinit(), which is identical to hashinit() except it takes a flags
arg for passing to malloc() (hashinit always uses M_WAITOK which is not
always what you want).  Everything that uses hashinit should really
get converted to newhashinit and then newhashinit can be renamed.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.6 1998/07/28 00:13:08 millert Exp $	*/
d88 8
d101 1
@


1.6
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.5 1998/05/11 05:41:59 deraadt Exp $	*/
d159 8
d176 1
a176 1
	hashtbl = malloc((u_long)hashsize * sizeof(*hashtbl), type, M_WAITOK);
@


1.5
log
@compile if iov_base is void *
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.4 1997/02/24 14:19:56 niklas Exp $	*/
d114 6
a119 2
	if (uio->uio_resid <= 0)
		panic("ureadc: non-positive resid");
d122 1
d124 3
@


1.4
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_subr.c,v 1.15 1996/04/09 17:21:56 ragge Exp $	*/
d133 1
a133 1
		*iov->iov_base = c;
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
@


1.2
log
@Removed vax ifdefed function from kern_subr.c (from NetBSD).
Do sync in the order of umount (vfs_syscals.c), as it was pointed
by someone in NetBSD's lists.
@
text
@d1 1
a1 1
/*	$NetBSD: kern_subr.c,v 1.14 1995/05/31 20:41:44 cgd Exp $	*/
@


1.1
log
@Initial revision
@
text
@a141 43
#ifdef vax	/* unused except by ct.c, other oddities XXX */
/*
 * Get next character written in by user from uio.
 */
int
uwritec(uio)
	struct uio *uio;
{
	register struct iovec *iov;
	register int c;

	if (uio->uio_resid <= 0)
		return (-1);
again:
	if (uio->uio_iovcnt <= 0)
		panic("ureadc: non-positive iovcnt");
	iov = uio->uio_iov;
	if (iov->iov_len == 0) {
		uio->uio_iov++;
		if (--uio->uio_iovcnt == 0)
			return (-1);
		goto again;
	}
	switch (uio->uio_segflg) {

	case UIO_USERSPACE:
		c = fubyte(iov->iov_base);
		break;

	case UIO_SYSSPACE:
		c = *(u_char *) iov->iov_base;
		break;
	}
	if (c < 0)
		return (-1);
	iov->iov_base++;
	iov->iov_len--;
	uio->uio_resid--;
	uio->uio_offset++;
	return (c);
}
#endif /* vax */

@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
