head	1.33;
access;
symbols
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.29.0.4
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.23.0.8
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.4
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.22.0.2
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.18.0.4
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.2
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.11.0.4
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.10.0.14
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.12
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.10
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.8
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.6
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.5.0.8
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.24
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.22
	OPENBSD_2_8:1.4.0.20
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.18
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.16
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.32;
commitid	CHRb0fCqa8XxUAMH;

1.32
date	2016.12.18.20.10.39;	author patrick;	state Exp;
branches;
next	1.31;
commitid	Sb1GGWQuFWF8863z;

1.31
date	2016.10.05.02.31.52;	author guenther;	state Exp;
branches;
next	1.30;
commitid	z4axJxYMv8DhHpqn;

1.30
date	2016.09.03.14.46.56;	author naddy;	state Exp;
branches;
next	1.29;
commitid	RpNaiU9Lz1B3rhqT;

1.29
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.28;
commitid	Cl55DD2g2xm69E6W;

1.28
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.27;
commitid	p4LJxGKbi0BU2cG6;

1.27
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.26;
commitid	uzzBR7hz9ncd4O6G;

1.26
date	2014.07.11.14.36.44;	author uebayasi;	state Exp;
branches;
next	1.25;
commitid	V6bwQMCHbD31pEWD;

1.25
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	EF98ch02VpFassUi;

1.24
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2012.08.07.05.16.54;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2012.07.09.15.43.36;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2011.06.26.22.40.00;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2010.07.28.16.15.25;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.28.15.59.38;	author kettenis;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.06.20.33.28;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2010.01.09.02.44.17;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2009.11.29.23.12.30;	author kettenis;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.25.11.01.14;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.10.11.22.10;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.04.03.09.30.15;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2005.11.28.00.14.29;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.13.22.45.11;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.13.06.11.11;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	96.08.26.09.16.01;	author deraadt;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	96.05.02.13.12.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.19.58;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches;
next	;

1.4.16.1
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.4.16.2;

1.4.16.2
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.4.16.3;

1.4.16.3
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.4.16.4;

1.4.16.4
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2003.05.19.22.31.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@/*	$OpenBSD: kern_xxx.c,v 1.32 2016/12/18 20:10:39 patrick Exp $	*/
/*	$NetBSD: kern_xxx.c,v 1.32 1996/04/22 01:38:41 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_xxx.c	8.2 (Berkeley) 11/14/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/reboot.h>
#include <sys/sysctl.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>

int
sys_reboot(struct proc *p, void *v, register_t *retval)
{
	struct sys_reboot_args /* {
		syscallarg(int) opt;
	} */ *uap = v;
	int error;

	if ((error = suser(p, 0)) != 0)
		return (error);

#ifdef MULTIPROCESSOR
	sched_stop_secondary_cpus();
	KASSERT(CPU_IS_PRIMARY(curcpu()));
#endif
	reboot(SCARG(uap, opt));
	/* NOTREACHED */
	return (0);
}

__dead void
reboot(int howto)
{
	KASSERT((howto & RB_NOSYNC) || curproc != NULL);

	stop_periodic_resettodr();

	boot(howto);
	/* NOTREACHED */
}

#if !defined(NO_PROPOLICE)
void __stack_smash_handler(char [], int __attribute__((unused)));

void
__stack_smash_handler(char func[], int damaged)
{
	panic("smashed stack in %s", func);
}
#endif

#ifdef SYSCALL_DEBUG
#include <sys/proc.h>

#define	SCDEBUG_CALLS		0x0001	/* show calls */
#define	SCDEBUG_RETURNS		0x0002	/* show returns */
#define	SCDEBUG_ALL		0x0004	/* even syscalls that are implemented */
#define	SCDEBUG_SHOWARGS	0x0008	/* show arguments to calls */

int	scdebug = SCDEBUG_CALLS|SCDEBUG_RETURNS|SCDEBUG_SHOWARGS;

void
scdebug_call(struct proc *p, register_t code, const register_t args[])
{
	struct process *pr;
	struct sysent *sy;
	struct emul *em;
	int i;

	if (!(scdebug & SCDEBUG_CALLS))
		return;

	pr = p->p_p;
	em = pr->ps_emul;
	sy = &em->e_sysent[code];
	if (!(scdebug & SCDEBUG_ALL || code < 0 || code >= em->e_nsysent ||
	     sy->sy_call == sys_nosys))
		return;

	printf("proc %d (%s): %s num ", pr->ps_pid, pr->ps_comm, em->e_name);
	if (code < 0 || code >= em->e_nsysent)
		printf("OUT OF RANGE (%ld)", code);
	else {
		printf("%ld call: %s", code, em->e_syscallnames[code]);
		if (scdebug & SCDEBUG_SHOWARGS) {
			printf("(");
			for (i = 0; i < sy->sy_argsize / sizeof(register_t);
			    i++)
				printf("%s0x%lx", i == 0 ? "" : ", ", args[i]);
			printf(")");
		}
	}
	printf("\n");
}

void
scdebug_ret(struct proc *p, register_t code, int error,
    const register_t retval[])
{
	struct process *pr;
	struct sysent *sy;
	struct emul *em;

	if (!(scdebug & SCDEBUG_RETURNS))
		return;

	pr = p->p_p;
	em = pr->ps_emul;
	sy = &em->e_sysent[code];
	if (!(scdebug & SCDEBUG_ALL || code < 0 || code >= em->e_nsysent ||
	    sy->sy_call == sys_nosys))
		return;
		
	printf("proc %d (%s): %s num ", pr->ps_pid, pr->ps_comm, em->e_name);
	if (code < 0 || code >= em->e_nsysent)
		printf("OUT OF RANGE (%ld)", code);
	else
		printf("%ld ret: err = %d, rv = 0x%lx,0x%lx", code,
		    error, retval[0], retval[1]);
	printf("\n");
}
#endif /* SYSCALL_DEBUG */
@


1.32
log
@Include sys/proc.h when compiled with SYSCALL_DEBUG to get access to
struct proc.  Also bump the printf of "code" to %ld and remove a few
casts to long as register_t is always long.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.31 2016/10/05 02:31:52 guenther Exp $	*/
d97 1
d105 2
a106 1
	em = p->p_p->ps_emul;
d111 2
a112 2
		
	printf("proc %d (%s): %s num ", p->p_p->ps_pid, p->p_comm, em->e_name);
d132 1
d139 2
a140 1
	em = p->p_p->ps_emul;
d146 1
a146 1
	printf("proc %d (%s): %s num ", p->p_p->ps_pid, p->p_comm, em->e_name);
@


1.31
log
@Display/test/use the process PID, not the thread's TID, in a few places.

ok mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.30 2016/09/03 14:46:56 naddy Exp $	*/
d85 2
d112 1
a112 1
		printf("OUT OF RANGE (%d)", code);
d114 1
a114 1
		printf("%d call: %s", code, em->e_syscallnames[code]);
d119 1
a119 2
				printf("%s0x%lx", i == 0 ? "" : ", ",
				    (long)args[i]);
d144 1
a144 1
		printf("OUT OF RANGE (%d)", code);
d146 2
a147 2
		printf("%d ret: err = %d, rv = 0x%lx,0x%lx", code,
		    error, (long)retval[0], (long)retval[1]);
@


1.30
log
@Write the system time back to the RTC every 30 minutes.
This fixes the problem that long-running machines which were not
shut down properly would reboot with a badly offset system time.

hints and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.29 2015/12/05 10:11:53 tedu Exp $	*/
d108 1
a108 1
	printf("proc %d (%s): %s num ", p->p_pid, p->p_comm, em->e_name);
d141 1
a141 1
	printf("proc %d (%s): %s num ", p->p_pid, p->p_comm, em->e_name);
@


1.29
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.28 2015/03/14 03:38:50 jsg Exp $	*/
d67 2
@


1.28
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.27 2014/09/14 14:17:25 jsg Exp $	*/
a42 1
/* ARGSUSED */
@


1.27
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.26 2014/07/11 14:36:44 uebayasi Exp $	*/
a41 2

#include <net/if.h>
@


1.26
log
@reboot(9): Add MI reboot entry function

Now, for kernel to "reboot" (reboot, halt, or shutdown), MD boot(9) is called
in some places.  This change introduces a new MI function reboot(9) which is
simply a wrapper to call MD boot(9).

OK kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a37 1
#include <sys/proc.h>
@


1.25
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.24 2014/03/26 05:23:42 guenther Exp $	*/
d62 2
a63 1
	boot(SCARG(uap, opt));
d65 9
@


1.24
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.23 2012/08/07 05:16:54 guenther Exp $	*/
a39 1
#include <uvm/uvm_extern.h>
@


1.23
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.22 2012/07/09 15:43:36 deraadt Exp $	*/
d95 1
a95 1
	em = p->p_emul;
d128 1
a128 1
	em = p->p_emul;
@


1.22
log
@In reboot, no need to sched_peg_curproc() to the primary, because
sched_stop_secondary_cpus() leaves us on the only cpu which is left.
ok kettenis haesbaert guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.21 2011/07/11 15:40:47 guenther Exp $	*/
d86 1
a86 1
scdebug_call(struct proc *p, register_t code, register_t args[])
d119 2
a120 1
scdebug_ret(struct proc *p, register_t code, int error, register_t retval[])
@


1.21
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.19 2011/06/26 22:40:00 deraadt Exp $	*/
a53 4
#ifdef MULTIPROCESSOR
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
#endif
a59 10
	/*
	 * Make sure this thread only runs on the primary cpu.
	 */
	CPU_INFO_FOREACH(cii, ci) {
		if (CPU_IS_PRIMARY(ci)) {
			sched_peg_curproc(ci);
			break;
		}
	}

d61 1
a62 1

a63 3

	atomic_clearbits_int(&p->p_flag, P_CPUPEG);	/* XXX */

@


1.20
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@a111 1
	KERNEL_LOCK();
d116 1
a116 1
		goto out;
a132 2
out:
	KERNEL_UNLOCK();
a143 1
	KERNEL_LOCK();
d148 1
a148 1
		goto out;
a156 2
out:
	KERNEL_UNLOCK();
@


1.19
log
@if_downall() cannot be done MI in sys_reboot() because vfs_shutdown()
might need network (ie. nfs).  Move the call to the MD boot() routines.
This cause for boot hangs diagnosed by kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.18 2010/07/28 16:15:25 deraadt Exp $	*/
d112 1
d117 1
a117 1
		return;
d134 2
d147 1
d152 1
a152 1
		return;
d161 2
@


1.18
log
@more #ifdef needed for the case of not pegging on a non-MP kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.17 2010/07/28 15:59:38 kettenis Exp $	*/
a75 2

	if_downall();
@


1.17
log
@It's pretty pointless to peg ourselves to the primary CPU if that's the
only one we have.

ok krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.16 2010/04/06 20:33:28 kettenis Exp $	*/
d54 1
d57 1
@


1.16
log
@Implement functions to take away the secondary CPUs from the scheduler and
give them back again, effectively stopping and starting these CPUs.  Use
the stop function in sys_reboot().

ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.15 2010/01/09 02:44:17 kettenis Exp $	*/
d61 1
a71 1
#ifdef MULTIPROCESSOR
@


1.15
log
@Add code to stop scheduling processes on CPUs, effectively halting that CPU.
Use this to do a shutdown with only the boot processor running.  This should
avoid nasty races during shutdown.

help from art@@, ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.14 2009/11/29 23:12:30 kettenis Exp $	*/
d71 3
a73 22
	/*
	 * Make sure we stop the secondary CPUs.
	 */
	CPU_INFO_FOREACH(cii, ci) {
		struct schedstate_percpu *spc = &ci->ci_schedstate;

		if (CPU_IS_PRIMARY(ci))
			continue;
		atomic_setbits_int(&spc->spc_schedflags, SPCF_SHOULDHALT);
	}
	CPU_INFO_FOREACH(cii, ci) {
		struct schedstate_percpu *spc = &ci->ci_schedstate;
		struct sleep_state sls;

		if (CPU_IS_PRIMARY(ci))
			continue;
		while ((spc->spc_schedflags & SPCF_HALTED) == 0) {
			sleep_setup(&sls, spc, PZERO, "schedstate");
			sleep_finish(&sls,
			    (spc->spc_schedflags & SPCF_HALTED) == 0);
		}
	}
@


1.14
log
@Backout previous commit.  There is a possible race which makes it possible
for sys_reboot() to hang forever.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.12 2009/08/10 11:22:10 deraadt Exp $	*/
d68 23
@


1.13
log
@Add a mechanism to stop the scheduler from scheduling processes on a
particular CPU such that it just sits and spins in the idle loop, effectively
halting that CPU.

ok deraadt@@, miod@@
@
text
@d56 1
a56 1
	int error, s;
a69 17

	/*
	 * Make sure we stop the secondary CPUs.
	 */
	s = splstatclock();
	CPU_INFO_FOREACH(cii, ci) {
		if (CPU_IS_PRIMARY(ci))
			continue;
		ci->ci_schedstate.spc_schedflags |= SPCF_SHOULDHALT;
	}
	CPU_INFO_FOREACH(cii, ci) {
		if (CPU_IS_PRIMARY(ci))
			continue;
		while ((ci->ci_schedstate.spc_schedflags & SPCF_HALTED) == 0)
			tsleep(&ci->ci_schedstate, PZERO, "schedstate", 0);
	}
	splx(s);
@


1.12
log
@At sys_reboot time, bring all the interfaces down so that their xxstop
functions are called, which will turn off DMA.  Receiving packets into
your memory after a system reboot is pretty nasty.  This will also mean
that the shutdown hooks can go; this solution is smaller.
ok henning miod dlg kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.11 2009/04/03 09:30:15 art Exp $	*/
d56 1
a56 1
	int error;
d70 17
@


1.11
log
@Make sure that sys_reboot runs on the primary cpu. Won't hurt when not
needed, but some machines seem to work much better with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.10 2005/11/28 00:14:29 jsg Exp $	*/
d45 2
d70 2
@


1.10
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.9 2003/08/15 20:32:18 tedu Exp $	*/
d52 2
d58 11
d70 3
@


1.9
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.8 2003/06/02 23:28:06 millert Exp $	*/
d47 1
a47 4
sys_reboot(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d79 1
a79 3
scdebug_call(p, code, args)
	struct proc *p;
	register_t code, args[];
d112 1
a112 5
scdebug_ret(p, code, error, retval)
	struct proc *p;
	register_t code;
	int error;
	register_t retval[];
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.7 2003/05/13 22:45:11 miod Exp $	*/
d57 1
a57 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.7
log
@Add option NO_PROPOLICE, which explicitely disables the use of the propolice
stack protection when building kernels. Intended to be used on installation
media, with tight space constraints - currently, only added where
SMALL_KERNEL was already defined.

Not thoroughly tested, but requested by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.6 2003/05/13 06:11:11 tedu Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@support for propolice in the kernel.
some style input itojun@@ tdeval@@ toby@@
tested, mostly by deraadt, on i386, macppc, vax, sparc64
ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.5 2001/11/06 19:53:20 miod Exp $	*/
d67 1
d75 1
a75 1

@


1.5
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.4 1996/08/26 09:16:01 deraadt Exp $	*/
d66 9
@


1.5.2.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a65 10

#if !defined(NO_PROPOLICE)
void __stack_smash_handler(char [], int __attribute__((unused)));

void
__stack_smash_handler(char func[], int damaged)
{
	panic("smashed stack in %s", func);
}
#endif
@


1.4
log
@fix syscall debugging
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.3 1996/05/02 13:12:17 deraadt Exp $	*/
d44 1
a44 1
#include <vm/vm.h>
@


1.4.16.1
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
#include <uvm/uvm_extern.h>
@


1.4.16.2
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@a66 10
#if !defined(NO_PROPOLICE)
void __stack_smash_handler(char [], int __attribute__((unused)));

void
__stack_smash_handler(char func[], int damaged)
{
	panic("smashed stack in %s", func);
}
#endif

@


1.4.16.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.4.16.2 2003/05/16 00:29:43 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4.16.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
a57 1
	if ((error = suser(p, 0)) != 0)
@


1.3
log
@sync syscalls, no sys/cpu.h
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_xxx.c,v 1.2 1996/03/03 17:19:58 niklas Exp $	*/
d90 1
a90 1
	     sy->sy_call == nosys))
d126 1
a126 1
	    sy->sy_call == nosys))
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: kern_xxx.c,v 1.31 1996/02/09 18:59:54 christos Exp $	*/
a45 1
#include <sys/cpu.h>
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: kern_xxx.c,v 1.29 1995/10/07 06:28:30 mycroft Exp $	*/
d46 1
a46 1

d62 1
a62 1
	if (error = suser(p->p_ucred, &p->p_acflag))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
