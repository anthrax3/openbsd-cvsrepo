head	1.93;
access;
symbols
	OPENBSD_6_2:1.93.0.4
	OPENBSD_6_2_BASE:1.93
	OPENBSD_6_1:1.91.0.4
	OPENBSD_6_1_BASE:1.91
	OPENBSD_6_0:1.90.0.2
	OPENBSD_6_0_BASE:1.90
	OPENBSD_5_9:1.88.0.2
	OPENBSD_5_9_BASE:1.88
	OPENBSD_5_8:1.88.0.4
	OPENBSD_5_8_BASE:1.88
	OPENBSD_5_7:1.87.0.2
	OPENBSD_5_7_BASE:1.87
	OPENBSD_5_6:1.85.0.4
	OPENBSD_5_6_BASE:1.85
	OPENBSD_5_5:1.84.0.4
	OPENBSD_5_5_BASE:1.84
	OPENBSD_5_4:1.81.0.2
	OPENBSD_5_4_BASE:1.81
	OPENBSD_5_3:1.78.0.2
	OPENBSD_5_3_BASE:1.78
	OPENBSD_5_2:1.74.0.2
	OPENBSD_5_2_BASE:1.74
	OPENBSD_5_1_BASE:1.72
	OPENBSD_5_1:1.72.0.4
	OPENBSD_5_0:1.72.0.2
	OPENBSD_5_0_BASE:1.72
	OPENBSD_4_9:1.71.0.2
	OPENBSD_4_9_BASE:1.71
	OPENBSD_4_8:1.70.0.4
	OPENBSD_4_8_BASE:1.70
	OPENBSD_4_7:1.70.0.2
	OPENBSD_4_7_BASE:1.70
	OPENBSD_4_6:1.68.0.6
	OPENBSD_4_6_BASE:1.68
	OPENBSD_4_5:1.68.0.2
	OPENBSD_4_5_BASE:1.68
	OPENBSD_4_4:1.66.0.2
	OPENBSD_4_4_BASE:1.66
	OPENBSD_4_3:1.65.0.2
	OPENBSD_4_3_BASE:1.65
	OPENBSD_4_2:1.64.0.2
	OPENBSD_4_2_BASE:1.64
	OPENBSD_4_1:1.60.0.2
	OPENBSD_4_1_BASE:1.60
	OPENBSD_4_0:1.59.0.2
	OPENBSD_4_0_BASE:1.59
	OPENBSD_3_9:1.58.0.2
	OPENBSD_3_9_BASE:1.58
	OPENBSD_3_8:1.52.0.4
	OPENBSD_3_8_BASE:1.52
	OPENBSD_3_7:1.52.0.2
	OPENBSD_3_7_BASE:1.52
	OPENBSD_3_6:1.50.0.2
	OPENBSD_3_6_BASE:1.50
	SMP_SYNC_A:1.43
	SMP_SYNC_B:1.43
	OPENBSD_3_5:1.42.0.4
	OPENBSD_3_5_BASE:1.42
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	UBC_SYNC_A:1.41
	OPENBSD_3_3:1.40.0.4
	OPENBSD_3_3_BASE:1.40
	OPENBSD_3_2:1.40.0.2
	OPENBSD_3_2_BASE:1.40
	OPENBSD_3_1:1.34.0.2
	OPENBSD_3_1_BASE:1.34
	UBC_SYNC_B:1.40
	UBC:1.30.0.2
	UBC_BASE:1.30
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.4
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	SMP:1.21.0.4
	SMP_BASE:1.21
	kame_19991208:1.21
	OPENBSD_2_6:1.21.0.2
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.20.0.4
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.15.0.4
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.93
date	2017.07.22.14.33.45;	author kettenis;	state Exp;
branches;
next	1.92;
commitid	9cBCcbWnmDjGC4fY;

1.92
date	2017.04.05.03.59.13;	author deraadt;	state Exp;
branches;
next	1.91;
commitid	lj8u63kQVA709JLS;

1.91
date	2016.09.04.09.22.29;	author mpi;	state Exp;
branches;
next	1.90;
commitid	jBolvsPoQ0BaYiLs;

1.90
date	2016.03.24.05.40.56;	author dlg;	state Exp;
branches;
next	1.89;
commitid	CSQLvLZrnfD7oOfw;

1.89
date	2016.03.20.07.56.08;	author uebayasi;	state Exp;
branches;
next	1.88;
commitid	TKHLMSkOKIynBe4v;

1.88
date	2015.06.11.16.03.04;	author mikeb;	state Exp;
branches;
next	1.87;
commitid	Sz3xmpXbu74b3jvv;

1.87
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.86;
commitid	uuiU9j2I8AUx0fez;

1.86
date	2014.09.04.19.14.47;	author miod;	state Exp;
branches;
next	1.85;
commitid	8mcKtR0tDvj5O8zk;

1.85
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.84;
commitid	EF98ch02VpFassUi;

1.84
date	2013.12.24.01.11.00;	author tedu;	state Exp;
branches;
next	1.83;

1.83
date	2013.10.08.03.50.07;	author guenther;	state Exp;
branches;
next	1.82;

1.82
date	2013.08.13.05.52.23;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2013.04.24.17.29.02;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	2013.03.28.16.55.25;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.78;

1.78
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.77;

1.77
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.76;

1.76
date	2012.11.05.19.39.34;	author miod;	state Exp;
branches;
next	1.75;

1.75
date	2012.08.02.03.18.48;	author guenther;	state Exp;
branches;
next	1.74;

1.74
date	2012.05.24.07.17.42;	author guenther;	state Exp;
branches;
next	1.73;

1.73
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2011.03.07.07.07.13;	author guenther;	state Exp;
branches;
next	1.71;

1.71
date	2010.08.20.22.03.22;	author matthew;	state Exp;
branches;
next	1.70;

1.70
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.69;

1.69
date	2009.11.04.19.14.10;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2009.01.21.21.02.39;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2008.10.04.15.21.59;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2008.03.15.21.21.09;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2007.10.10.15.53.53;	author art;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.16.17.27.30;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.17.17.57.32;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2007.03.25.11.35.01;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2006.12.24.20.29.45;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2006.06.14.19.52.07;	author otto;	state Exp;
branches;
next	1.58;

1.58
date	2006.01.20.07.53.48;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2006.01.13.22.02.37;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2006.01.03.18.22.31;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2005.11.28.00.14.28;	author jsg;	state Exp;
branches;
next	1.54;

1.54
date	2005.10.25.15.49.37;	author jmc;	state Exp;
branches;
next	1.53;

1.53
date	2005.10.03.01.19.44;	author aaron;	state Exp;
branches;
next	1.52;

1.52
date	2004.11.10.11.00.00;	author grange;	state Exp;
branches
	1.52.2.1
	1.52.4.1;
next	1.51;

1.51
date	2004.09.15.17.48.52;	author grange;	state Exp;
branches;
next	1.50;

1.50
date	2004.08.05.13.45.30;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2004.08.04.21.49.19;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2004.08.04.16.29.32;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.28.17.15.12;	author tholo;	state Exp;
branches;
next	1.46;

1.46
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.21.23.50.35;	author tholo;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.09.20.18.28;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.13.20.31.59;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2002.09.24.00.06.23;	author nordin;	state Exp;
branches;
next	1.39;

1.39
date	2002.07.06.19.14.20;	author nordin;	state Exp;
branches;
next	1.38;

1.38
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.07.21.20.02;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.07.08.16.26;	author nordin;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.24.21.53.12;	author espie;	state Exp;
branches;
next	1.34;

1.34
date	2002.02.18.03.45.08;	author nordin;	state Exp;
branches;
next	1.33;

1.33
date	2002.02.15.20.55.26;	author nordin;	state Exp;
branches;
next	1.32;

1.32
date	2002.02.15.01.59.26;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.02.06.07.41;	author nordin;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.14.03.42.16;	author nate;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.19.06.10.09;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.23.20.36.18;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2000.07.07.15.37.00;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.06.15.33.31;	author ho;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.05.08.10.56;	author pjanzen;	state Exp;
branches;
next	1.23;

1.23
date	2000.03.23.11.20.45;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2000.03.23.09.59.57;	author art;	state Exp;
branches;
next	1.21;

1.21
date	99.08.15.00.07.43;	author pjanzen;	state Exp;
branches
	1.21.4.1;
next	1.20;

1.20
date	98.08.27.05.00.17;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	98.08.27.00.44.41;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	98.02.08.22.41.34;	author tholo;	state Exp;
branches;
next	1.17;

1.17
date	97.12.30.19.07.29;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	97.11.23.03.19.17;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.01.25.23.35.58;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	97.01.25.23.31.47;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	96.09.09.04.50.33;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	96.06.09.03.47.29;	author briggs;	state Exp;
branches;
next	1.11;

1.11
date	96.05.03.07.42.39;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.05.02.13.12.09;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.04.21.22.26.53;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.04.19.16.08.50;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.03.03.17.19.41;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.02.25.23.00.25;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.02.25.09.55.50;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.01.29.23.05.06;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.01.29.07.03.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.30.09.24.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches;
next	;

1.21.4.1
date	2000.03.24.09.09.23;	author niklas;	state Exp;
branches;
next	1.21.4.2;

1.21.4.2
date	2001.05.14.22.32.39;	author niklas;	state Exp;
branches;
next	1.21.4.3;

1.21.4.3
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.21.4.4;

1.21.4.4
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.21.4.5;

1.21.4.5
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.21.4.6;

1.21.4.6
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.21.4.7;

1.21.4.7
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.21.4.8;

1.21.4.8
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.21.4.9;

1.21.4.9
date	2004.03.30.09.12.07;	author niklas;	state Exp;
branches;
next	1.21.4.10;

1.21.4.10
date	2004.06.05.17.19.55;	author niklas;	state Exp;
branches;
next	1.21.4.11;

1.21.4.11
date	2004.06.05.23.18.25;	author tedu;	state Exp;
branches;
next	1.21.4.12;

1.21.4.12
date	2004.06.06.05.22.51;	author tedu;	state Exp;
branches;
next	1.21.4.13;

1.21.4.13
date	2004.06.06.21.46.12;	author tedu;	state Exp;
branches;
next	1.21.4.14;

1.21.4.14
date	2004.06.10.11.40.33;	author niklas;	state Exp;
branches;
next	;

1.30.2.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.30.2.4;

1.30.2.4
date	2003.05.19.22.31.09;	author tedu;	state Exp;
branches;
next	;

1.52.2.1
date	2005.10.20.02.11.31;	author brad;	state Exp;
branches;
next	;

1.52.4.1
date	2005.11.01.00.58.07;	author brad;	state Exp;
branches;
next	;


desc
@@


1.93
log
@Introduce jiffies, a volatile unsigned long version of our ticks variable
for use by the linux compatibility APIs in drm(4).

While I hate infecting code in sys/kern with this, untangling all the
of having different types and different signedness is too much for me
right now.  The best strategy may be to change ticks itself to be long
but that needs some careful auditing.

ok deraadt@@
@
text
@/*	$OpenBSD: kern_clock.c,v 1.92 2017/04/05 03:59:13 deraadt Exp $	*/
/*	$NetBSD: kern_clock.c,v 1.34 1996/06/09 04:51:03 briggs Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_clock.c	8.5 (Berkeley) 1/21/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/kernel.h>
#include <sys/limits.h>
#include <sys/proc.h>
#include <sys/user.h>
#include <sys/resourcevar.h>
#include <sys/signalvar.h>
#include <sys/sysctl.h>
#include <sys/sched.h>
#include <sys/timetc.h>


#if defined(GPROF) || defined(DDBPROF)
#include <sys/gmon.h>
#endif

/*
 * Clock handling routines.
 *
 * This code is written to operate with two timers that run independently of
 * each other.  The main clock, running hz times per second, is used to keep
 * track of real time.  The second timer handles kernel and user profiling,
 * and does resource use estimation.  If the second timer is programmable,
 * it is randomized to avoid aliasing between the two clocks.  For example,
 * the randomization prevents an adversary from always giving up the cpu
 * just before its quantum expires.  Otherwise, it would never accumulate
 * cpu ticks.  The mean frequency of the second timer is stathz.
 *
 * If no second timer exists, stathz will be zero; in this case we drive
 * profiling and statistics off the main clock.  This WILL NOT be accurate;
 * do not do it unless absolutely necessary.
 *
 * The statistics clock may (or may not) be run at a higher rate while
 * profiling.  This profile clock runs at profhz.  We require that profhz
 * be an integral multiple of stathz.
 *
 * If the statistics clock is running fast, it must be divided by the ratio
 * profhz/stathz for statistics.  (For profiling, every tick counts.)
 */

/*
 * Bump a timeval by a small number of usec's.
 */
#define BUMPTIME(t, usec) { \
	volatile struct timeval *tp = (t); \
	long us; \
 \
	tp->tv_usec = us = tp->tv_usec + (usec); \
	if (us >= 1000000) { \
		tp->tv_usec = us - 1000000; \
		tp->tv_sec++; \
	} \
}

int	stathz;
int	schedhz;
int	profhz;
int	profprocs;
int	ticks;
static int psdiv, pscnt;		/* prof => stat divider */
int	psratio;			/* ratio: prof / stat */

void	*softclock_si;

volatile unsigned long jiffies;		/* XXX Linux API for drm(4) */

/*
 * Initialize clock frequencies and start both clocks running.
 */
void
initclocks(void)
{
	int i;

	softclock_si = softintr_establish(IPL_SOFTCLOCK, softclock, NULL);
	if (softclock_si == NULL)
		panic("initclocks: unable to register softclock intr");

	ticks = INT_MAX - (15 * 60 * hz);
	jiffies = ULONG_MAX - (10 * 60 * hz);

	/*
	 * Set divisors to 1 (normal case) and let the machine-specific
	 * code do its bit.
	 */
	psdiv = pscnt = 1;
	cpu_initclocks();

	/*
	 * Compute profhz/stathz, and fix profhz if needed.
	 */
	i = stathz ? stathz : hz;
	if (profhz == 0)
		profhz = i;
	psratio = profhz / i;

	/* For very large HZ, ensure that division by 0 does not occur later */
	if (tickadj == 0)
		tickadj = 1;

	inittimecounter();
}

/*
 * hardclock does the accounting needed for ITIMER_PROF and ITIMER_VIRTUAL.
 * We don't want to send signals with psignal from hardclock because it makes
 * MULTIPROCESSOR locking very complicated. Instead, to use an idea from
 * FreeBSD, we set a flag on the thread and when it goes to return to
 * userspace it signals itself.
 */

/*
 * The real-time timer, interrupting hz times per second.
 */
void
hardclock(struct clockframe *frame)
{
	struct proc *p;
	struct cpu_info *ci = curcpu();

	p = curproc;
	if (p && ((p->p_flag & (P_SYSTEM | P_WEXIT)) == 0)) {
		struct process *pr = p->p_p;

		/*
		 * Run current process's virtual and profile time, as needed.
		 */
		if (CLKF_USERMODE(frame) &&
		    timerisset(&pr->ps_timer[ITIMER_VIRTUAL].it_value) &&
		    itimerdecr(&pr->ps_timer[ITIMER_VIRTUAL], tick) == 0) {
			atomic_setbits_int(&p->p_flag, P_ALRMPEND);
			need_proftick(p);
		}
		if (timerisset(&pr->ps_timer[ITIMER_PROF].it_value) &&
		    itimerdecr(&pr->ps_timer[ITIMER_PROF], tick) == 0) {
			atomic_setbits_int(&p->p_flag, P_PROFPEND);
			need_proftick(p);
		}
	}

	/*
	 * If no separate statistics clock is available, run it from here.
	 */
	if (stathz == 0)
		statclock(frame);

	if (--ci->ci_schedstate.spc_rrticks <= 0)
		roundrobin(ci);

	/*
	 * If we are not the primary CPU, we're not allowed to do
	 * any more work.
	 */
	if (CPU_IS_PRIMARY(ci) == 0)
		return;

	tc_ticktock();
	ticks++;
	jiffies++;

	/*
	 * Update real-time timeout queue.
	 * Process callouts at a very low cpu priority, so we don't keep the
	 * relatively high clock interrupt priority any longer than necessary.
	 */
	if (timeout_hardclock_update())
		softintr_schedule(softclock_si);
}

/*
 * Compute number of hz in the specified amount of time.
 */
int
tvtohz(const struct timeval *tv)
{
	unsigned long nticks;
	time_t sec;
	long usec;

	/*
	 * If the number of usecs in the whole seconds part of the time
	 * fits in a long, then the total number of usecs will
	 * fit in an unsigned long.  Compute the total and convert it to
	 * ticks, rounding up and adding 1 to allow for the current tick
	 * to expire.  Rounding also depends on unsigned long arithmetic
	 * to avoid overflow.
	 *
	 * Otherwise, if the number of ticks in the whole seconds part of
	 * the time fits in a long, then convert the parts to
	 * ticks separately and add, using similar rounding methods and
	 * overflow avoidance.  This method would work in the previous
	 * case but it is slightly slower and assumes that hz is integral.
	 *
	 * Otherwise, round the time down to the maximum
	 * representable value.
	 *
	 * If ints have 32 bits, then the maximum value for any timeout in
	 * 10ms ticks is 248 days.
	 */
	sec = tv->tv_sec;
	usec = tv->tv_usec;
	if (sec < 0 || (sec == 0 && usec <= 0))
		nticks = 0;
	else if (sec <= LONG_MAX / 1000000)
		nticks = (sec * 1000000 + (unsigned long)usec + (tick - 1))
		    / tick + 1;
	else if (sec <= LONG_MAX / hz)
		nticks = sec * hz
		    + ((unsigned long)usec + (tick - 1)) / tick + 1;
	else
		nticks = LONG_MAX;
	if (nticks > INT_MAX)
		nticks = INT_MAX;
	return ((int)nticks);
}

int
tstohz(const struct timespec *ts)
{
	struct timeval tv;
	TIMESPEC_TO_TIMEVAL(&tv, ts);

	/* Round up. */
	if ((ts->tv_nsec % 1000) != 0) {
		tv.tv_usec += 1;
		if (tv.tv_usec >= 1000000) {
			tv.tv_usec -= 1000000;
			tv.tv_sec += 1;
		}
	}

	return (tvtohz(&tv));
}

/*
 * Start profiling on a process.
 *
 * Kernel profiling passes proc0 which never exits and hence
 * keeps the profile clock running constantly.
 */
void
startprofclock(struct process *pr)
{
	int s;

	if ((pr->ps_flags & PS_PROFIL) == 0) {
		atomic_setbits_int(&pr->ps_flags, PS_PROFIL);
		if (++profprocs == 1 && stathz != 0) {
			s = splstatclock();
			psdiv = pscnt = psratio;
			setstatclockrate(profhz);
			splx(s);
		}
	}
}

/*
 * Stop profiling on a process.
 */
void
stopprofclock(struct process *pr)
{
	int s;

	if (pr->ps_flags & PS_PROFIL) {
		atomic_clearbits_int(&pr->ps_flags, PS_PROFIL);
		if (--profprocs == 0 && stathz != 0) {
			s = splstatclock();
			psdiv = pscnt = 1;
			setstatclockrate(stathz);
			splx(s);
		}
	}
}

/*
 * Statistics clock.  Grab profile sample, and if divider reaches 0,
 * do process and kernel statistics.
 */
void
statclock(struct clockframe *frame)
{
#if defined(GPROF) || defined(DDBPROF)
	struct gmonparam *g;
	u_long i;
#endif
	struct cpu_info *ci = curcpu();
	struct schedstate_percpu *spc = &ci->ci_schedstate;
	struct proc *p = curproc;
	struct process *pr;

	/*
	 * Notice changes in divisor frequency, and adjust clock
	 * frequency accordingly.
	 */
	if (spc->spc_psdiv != psdiv) {
		spc->spc_psdiv = psdiv;
		spc->spc_pscnt = psdiv;
		if (psdiv == 1) {
			setstatclockrate(stathz);
		} else {
			setstatclockrate(profhz);			
		}
	}

	if (CLKF_USERMODE(frame)) {
		pr = p->p_p;
		if (pr->ps_flags & PS_PROFIL)
			addupc_intr(p, CLKF_PC(frame));
		if (--spc->spc_pscnt > 0)
			return;
		/*
		 * Came from user mode; CPU was in user state.
		 * If this process is being profiled record the tick.
		 */
		p->p_uticks++;
		if (pr->ps_nice > NZERO)
			spc->spc_cp_time[CP_NICE]++;
		else
			spc->spc_cp_time[CP_USER]++;
	} else {
#if defined(GPROF) || defined(DDBPROF)
		/*
		 * Kernel statistics are just like addupc_intr, only easier.
		 */
		g = ci->ci_gmon;
		if (g != NULL && g->state == GMON_PROF_ON) {
			i = CLKF_PC(frame) - g->lowpc;
			if (i < g->textsize) {
				i /= HISTFRACTION * sizeof(*g->kcount);
				g->kcount[i]++;
			}
		}
#endif
#if defined(PROC_PC)
		if (p != NULL && p->p_p->ps_flags & PS_PROFIL)
			addupc_intr(p, PROC_PC(p));
#endif
		if (--spc->spc_pscnt > 0)
			return;
		/*
		 * Came from kernel mode, so we were:
		 * - handling an interrupt,
		 * - doing syscall or trap work on behalf of the current
		 *   user process, or
		 * - spinning in the idle loop.
		 * Whichever it is, charge the time as appropriate.
		 * Note that we charge interrupts to the current process,
		 * regardless of whether they are ``for'' that process,
		 * so that we know how much of its real time was spent
		 * in ``non-process'' (i.e., interrupt) work.
		 */
		if (CLKF_INTR(frame)) {
			if (p != NULL)
				p->p_iticks++;
			spc->spc_cp_time[CP_INTR]++;
		} else if (p != NULL && p != spc->spc_idleproc) {
			p->p_sticks++;
			spc->spc_cp_time[CP_SYS]++;
		} else
			spc->spc_cp_time[CP_IDLE]++;
	}
	spc->spc_pscnt = psdiv;

	if (p != NULL) {
		p->p_cpticks++;
		/*
		 * If no schedclock is provided, call it here at ~~12-25 Hz;
		 * ~~16 Hz is best
		 */
		if (schedhz == 0) {
			if ((++curcpu()->ci_schedstate.spc_schedticks & 3) ==
			    0)
				schedclock(p);
		}
	}
}

/*
 * Return information about system clocks.
 */
int
sysctl_clockrate(char *where, size_t *sizep, void *newp)
{
	struct clockinfo clkinfo;

	/*
	 * Construct clockinfo structure.
	 */
	memset(&clkinfo, 0, sizeof clkinfo);
	clkinfo.tick = tick;
	clkinfo.tickadj = tickadj;
	clkinfo.hz = hz;
	clkinfo.profhz = profhz;
	clkinfo.stathz = stathz ? stathz : hz;
	return (sysctl_rdstruct(where, sizep, newp, &clkinfo, sizeof(clkinfo)));
}
@


1.92
log
@clear structure on the stack before copying out for sysctl.  At present
it has no pads, but a future ABI change could add something and leak
kernel memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.91 2016/09/04 09:22:29 mpi Exp $	*/
d106 2
d121 1
d200 1
@


1.91
log
@Introduce Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

Currently only available on amd64 and guarded under DDBPROF.  Support
for other archs will follow soon.

A new sysctl knob, ddb.console, need to be set to 1 in securelevel 0
to be able to use this feature.

Inputs and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.90 2016/03/24 05:40:56 dlg Exp $	*/
d427 1
@


1.90
log
@set ticks 15 seconds before its value wraps.

this helps us identify issues around ticks wrap in 15 minutes instead
of 240ish days. the change is inspired by something freebsd did as
a result of a ticks change they made that went horribly wrong.

lots of people said they wanted this
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.89 2016/03/20 07:56:08 uebayasi Exp $	*/
d54 1
a54 1
#ifdef GPROF
d320 1
a320 1
#ifdef GPROF
d359 1
a359 1
#ifdef GPROF
@


1.89
log
@Update ticks in hardclock().

OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.88 2015/06/11 16:03:04 mikeb Exp $	*/
d117 2
@


1.88
log
@Move hzto(9) to the attic;  OK dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.87 2014/09/15 19:08:21 miod Exp $	*/
d194 1
@


1.87
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.86 2014/09/04 19:14:47 miod Exp $	*/
a201 53
}

/*
 * Compute number of hz until specified time.  Used to
 * compute the second argument to timeout_add() from an absolute time.
 */
int
hzto(const struct timeval *tv)
{
	struct timeval now;
	unsigned long nticks;
	long sec, usec;

	/*
	 * If the number of usecs in the whole seconds part of the time
	 * difference fits in a long, then the total number of usecs will
	 * fit in an unsigned long.  Compute the total and convert it to
	 * ticks, rounding up and adding 1 to allow for the current tick
	 * to expire.  Rounding also depends on unsigned long arithmetic
	 * to avoid overflow.
	 *
	 * Otherwise, if the number of ticks in the whole seconds part of
	 * the time difference fits in a long, then convert the parts to
	 * ticks separately and add, using similar rounding methods and
	 * overflow avoidance.  This method would work in the previous
	 * case but it is slightly slower and assumes that hz is integral.
	 *
	 * Otherwise, round the time difference down to the maximum
	 * representable value.
	 *
	 * If ints have 32 bits, then the maximum value for any timeout in
	 * 10ms ticks is 248 days.
	 */
	getmicrotime(&now);
	sec = tv->tv_sec - now.tv_sec;
	usec = tv->tv_usec - now.tv_usec;
	if (usec < 0) {
		sec--;
		usec += 1000000;
	}
	if (sec < 0 || (sec == 0 && usec <= 0)) {
		nticks = 0;
	} else if (sec <= LONG_MAX / 1000000)
		nticks = (sec * 1000000 + (unsigned long)usec + (tick - 1))
		    / tick + 1;
	else if (sec <= LONG_MAX / hz)
		nticks = sec * hz
		    + ((unsigned long)usec + (tick - 1)) / tick + 1;
	else
		nticks = LONG_MAX;
	if (nticks > INT_MAX)
		nticks = INT_MAX;
	return ((int)nticks);
@


1.86
log
@Remove global cp_time[] array; no longer used now that all arches implement
cpu_info.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.85 2014/07/08 17:19:25 deraadt Exp $	*/
a41 1
#include <sys/dkstat.h>
@


1.85
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.84 2013/12/24 01:11:00 tedu Exp $	*/
a103 2

long cp_time[CPUSTATES];
@


1.84
log
@rename local ticks to nticks to avoid aliasing global. ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.83 2013/10/08 03:50:07 guenther Exp $	*/
a49 1
#include <uvm/uvm_extern.h>
@


1.83
log
@Fix delivery of SIGPROF and SIGVTALRM to threaded processes by having
hardclock() set a flag on the running thread and force AST processing,
and then have the thread signal itself from userret().

idea and flag names from FreeBSD
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.82 2013/08/13 05:52:23 guenther Exp $	*/
d216 1
a216 1
	unsigned long ticks;
d247 1
a247 1
		ticks = 0;
d249 1
a249 1
		ticks = (sec * 1000000 + (unsigned long)usec + (tick - 1))
d252 1
a252 1
		ticks = sec * hz
d255 4
a258 4
		ticks = LONG_MAX;
	if (ticks > INT_MAX)
		ticks = INT_MAX;
	return ((int)ticks);
d267 1
a267 1
	unsigned long ticks;
d294 1
a294 1
		ticks = 0;
d296 1
a296 1
		ticks = (sec * 1000000 + (unsigned long)usec + (tick - 1))
d299 1
a299 1
		ticks = sec * hz
d302 4
a305 4
		ticks = LONG_MAX;
	if (ticks > INT_MAX)
		ticks = INT_MAX;
	return ((int)ticks);
@


1.82
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.81 2013/04/24 17:29:02 matthew Exp $	*/
d147 3
a149 16
 * MULTIPROCESSOR locking very complicated. Instead we use a small trick
 * to send the signals safely and without blocking too many interrupts
 * while doing that (signal handling can be heavy).
 *
 * hardclock detects that the itimer has expired, and schedules a timeout
 * to deliver the signal. This works because of the following reasons:
 *  - The timeout can be scheduled with a 1 tick time because we're
 *    doing it before the timeout processing in hardclock. So it will
 *    be scheduled to run as soon as possible.
 *  - The timeout will be run in softclock which will run before we
 *    return to userland and process pending signals.
 *  - If the system is so busy that several VIRTUAL/PROF ticks are
 *    sent before softclock processing, we'll send only one signal.
 *    But if we'd send the signal from hardclock only one signal would
 *    be delivered to the user process. So userland will only see one
 *    signal anyway.
a151 16
void
virttimer_trampoline(void *v)
{
	struct process *pr = v;

	psignal(pr->ps_mainproc, SIGVTALRM);
}

void
proftimer_trampoline(void *v)
{
	struct process *pr = v;

	psignal(pr->ps_mainproc, SIGPROF);
}

d170 4
a173 2
		    itimerdecr(&pr->ps_timer[ITIMER_VIRTUAL], tick) == 0)
			timeout_add(&pr->ps_virt_to, 1);
d175 4
a178 2
		    itimerdecr(&pr->ps_timer[ITIMER_PROF], tick) == 0)
			timeout_add(&pr->ps_prof_to, 1);
@


1.81
log
@Add tstohz(9) as the timespec analog to tvtohz(9).

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.80 2013/03/28 16:55:25 deraadt Exp $	*/
d293 2
a294 1
	long sec, usec;
@


1.80
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.79 2013/03/12 09:37:16 mpi Exp $	*/
d330 18
@


1.79
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.78 2013/02/12 08:06:22 mpi Exp $	*/
a54 1
#include <machine/cpu.h>
@


1.78
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.77 2013/02/11 17:05:25 mpi Exp $	*/
d424 2
a425 2
		g = &_gmonparam;
		if (g->state == GMON_PROF_ON) {
@


1.77
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.76 2012/11/05 19:39:34 miod Exp $	*/
d424 2
a425 2
		g = ci->ci_gmon;
		if (g != NULL && g->state == GMON_PROF_ON) {
@


1.76
log
@unifdef -D __HAVE_TIMECOUNTER
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.75 2012/08/02 03:18:48 guenther Exp $	*/
d424 2
a425 2
		g = &_gmonparam;
		if (g->state == GMON_PROF_ON) {
@


1.75
log
@Apply profiling to all threads instead of just the thread that called
profil() by moving P_PROFIL from proc->p_flag to process->ps_flags with
matching adjustment in fork1() and exit1()

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.74 2012/05/24 07:17:42 guenther Exp $	*/
a52 1
#ifdef __HAVE_TIMECOUNTER
a53 1
#endif
a108 12
#ifndef __HAVE_TIMECOUNTER
int	tickfix, tickfixinterval;	/* used if tick not really integral */
static int tickfixcnt;			/* accumulated fractional error */

volatile time_t time_second;
volatile time_t time_uptime;

volatile struct	timeval time
	__attribute__((__aligned__(__alignof__(quad_t))));
volatile struct	timeval mono_time;
#endif

a141 1
#ifdef __HAVE_TIMECOUNTER
a142 1
#endif
a188 7
#ifndef __HAVE_TIMECOUNTER
	int delta;
	extern int tickdelta;
	extern long timedelta;
	extern int64_t ntp_tick_permanent;
	extern int64_t ntp_tick_acc;
#endif
a222 49
#ifndef __HAVE_TIMECOUNTER
	/*
	 * Increment the time-of-day.  The increment is normally just
	 * ``tick''.  If the machine is one which has a clock frequency
	 * such that ``hz'' would not divide the second evenly into
	 * milliseconds, a periodic adjustment must be applied.  Finally,
	 * if we are still adjusting the time (see adjtime()),
	 * ``tickdelta'' may also be added in.
	 */

	delta = tick;

	if (tickfix) {
		tickfixcnt += tickfix;
		if (tickfixcnt >= tickfixinterval) {
			delta++;
			tickfixcnt -= tickfixinterval;
		}
	}
	/* Imprecise 4bsd adjtime() handling */
	if (timedelta != 0) {
		delta += tickdelta;
		timedelta -= tickdelta;
	}

	/*
	 * ntp_tick_permanent accumulates the clock correction each
	 * tick. The unit is ns per tick shifted left 32 bits. If we have
	 * accumulated more than 1us, we bump delta in the right
	 * direction. Use a loop to avoid long long div; typically
	 * the loops will be executed 0 or 1 iteration.
	 */
	if (ntp_tick_permanent != 0) {
		ntp_tick_acc += ntp_tick_permanent;
		while (ntp_tick_acc >= (1000LL << 32)) {
			delta++;
			ntp_tick_acc -= (1000LL << 32);
		}
		while (ntp_tick_acc <= -(1000LL << 32)) {
			delta--;
			ntp_tick_acc += (1000LL << 32);
		}
	}

	BUMPTIME(&time, delta);
	BUMPTIME(&mono_time, delta);
	time_second = time.tv_sec;
	time_uptime = mono_time.tv_sec;
#else
a223 1
#endif
a494 73

#ifndef __HAVE_TIMECOUNTER
/*
 * Placeholders until everyone uses the timecounters code.
 * Won't improve anything except maybe removing a bunch of bugs in fixed code.
 */

void
getmicrotime(struct timeval *tvp)
{
	int s;

	s = splhigh();
	*tvp = time;
	splx(s);
}

void
nanotime(struct timespec *tsp)
{
	struct timeval tv;

	microtime(&tv);
	TIMEVAL_TO_TIMESPEC(&tv, tsp);
}

void
getnanotime(struct timespec *tsp)
{
	struct timeval tv;

	getmicrotime(&tv);
	TIMEVAL_TO_TIMESPEC(&tv, tsp);
}

void
nanouptime(struct timespec *tsp)
{
	struct timeval tv;

	microuptime(&tv);
	TIMEVAL_TO_TIMESPEC(&tv, tsp);
}


void
getnanouptime(struct timespec *tsp)
{
	struct timeval tv;

	getmicrouptime(&tv);
	TIMEVAL_TO_TIMESPEC(&tv, tsp);
}

void
microuptime(struct timeval *tvp)
{
	struct timeval tv;

	microtime(&tv);
	timersub(&tv, &boottime, tvp);
}

void
getmicrouptime(struct timeval *tvp)
{
	int s;

	s = splhigh();
	*tvp = mono_time;
	splx(s);
}
#endif /* __HAVE_TIMECOUNTER */
@


1.74
log
@On resume, run forward the monotonic and realtimes clocks instead of jumping
just the realtime clock, triggering and adjusting timeouts to reflect that.

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.73 2012/03/23 15:51:26 guenther Exp $	*/
d413 1
a413 1
startprofclock(struct proc *p)
d417 2
a418 2
	if ((p->p_flag & P_PROFIL) == 0) {
		atomic_setbits_int(&p->p_flag, P_PROFIL);
d432 1
a432 1
stopprofclock(struct proc *p)
d436 2
a437 2
	if (p->p_flag & P_PROFIL) {
		atomic_clearbits_int(&p->p_flag, P_PROFIL);
d461 1
d478 2
a479 1
		if (p->p_flag & P_PROFIL)
d488 1
a488 1
		if (p->p_p->ps_nice > NZERO)
d507 1
a507 1
		if (p != NULL && p->p_flag & P_PROFIL)
@


1.73
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.72 2011/03/07 07:07:13 guenther Exp $	*/
a131 3
#ifdef __HAVE_TIMECOUNTER
	extern void inittimecounter(void);
#endif
@


1.72
log
@The scheduling 'nice' value is per-process, not per-thread, so move it
into struct process.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.71 2010/08/20 22:03:22 matthew Exp $	*/
a172 4
 *  - The timeout structures can be in struct pstats because the timers
 *    can be only activated on curproc (never swapped). Swapout can
 *    only happen from a kernel thread and softclock runs before threads
 *    are scheduled.
d188 1
a188 1
	struct proc *p = v;
d190 1
a190 1
	psignal(p, SIGVTALRM);
d196 1
a196 1
	struct proc *p = v;
d198 1
a198 1
	psignal(p, SIGPROF);
d219 1
a219 1
		struct pstats *pstats;
a223 1
		pstats = p->p_stats;
d225 6
a230 6
		    timerisset(&pstats->p_timer[ITIMER_VIRTUAL].it_value) &&
		    itimerdecr(&pstats->p_timer[ITIMER_VIRTUAL], tick) == 0)
			timeout_add(&pstats->p_virt_to, 1);
		if (timerisset(&pstats->p_timer[ITIMER_PROF].it_value) &&
		    itimerdecr(&pstats->p_timer[ITIMER_PROF], tick) == 0)
			timeout_add(&pstats->p_prof_to, 1);
@


1.71
log
@Change hzto(9) and tvtohz(9) arguments to const pointers.

ok krw@@, "of course" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.70 2010/01/14 23:12:11 schwarze Exp $	*/
d494 1
a494 1
		if (p->p_nice > NZERO)
@


1.70
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.69 2009/11/04 19:14:10 kettenis Exp $	*/
d320 1
a320 1
hzto(struct timeval *tv)
d372 1
a372 1
tvtohz(struct timeval *tv)
@


1.69
log
@Get rid of __HAVE_GENERIC_SOFT_INTERRUPTS now that all our platforms support it.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.68 2009/01/21 21:02:39 miod Exp $	*/
d283 1
a283 1
	 * direction. Use a loop to avoid long long div; typicallly
@


1.68
log
@Pass the new pointer to sysctl_clockrate(), so that trying to change the
value of kern.clockrate with sysctl(3) correctly sets errno on failure.
PR #6040, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.67 2008/10/04 15:21:59 deraadt Exp $	*/
a122 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a123 12
void	generic_softclock(void *);

void
generic_softclock(void *ignore)
{
	/*
	 * XXX - don't commit, just a dummy wrapper until we learn everyone
	 *       deal with a changed proto for softclock().
	 */
	softclock();
}
#endif
d136 1
a136 2
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	softclock_si = softintr_establish(IPL_SOFTCLOCK, generic_softclock, NULL);
a138 1
#endif
d311 1
a311 2
	if (timeout_hardclock_update()) {
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a312 4
#else
		setsoftclock();
#endif
	}
@


1.67
log
@At clock initialization, if we discover that tickadj is 0 (due to very
high HZ) set it to 1, to avoid various divide-by-zero errors later
Based on discussion in PR 5511
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.66 2008/03/15 21:21:09 miod Exp $	*/
d580 1
a580 1
sysctl_clockrate(char *where, size_t *sizep)
d592 1
a592 1
	return (sysctl_rdstruct(where, sizep, NULL, &clkinfo, sizeof(clkinfo)));
@


1.66
log
@In statclock(), fix local index type in the profiling code. Avoids
out-of-bounds array accesses on some platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.65 2007/10/10 15:53:53 art Exp $	*/
d169 5
@


1.65
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.64 2007/05/16 17:27:30 art Exp $	*/
d479 1
a479 1
	int i;
@


1.64
log
@The world of __HAVEs and __HAVE_NOTs is reducing. All architectures
have cpu_info now, so kill the option.

eyeballed by jsg@@ and grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.63 2007/04/17 17:57:32 miod Exp $	*/
d549 1
a549 1
		} else if (p != NULL) {
@


1.63
log
@Don't bother performing ITIMER accounting on P_SYSTEM processes (i.e. kthreads).
ok art@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.62 2007/03/25 11:35:01 art Exp $	*/
a228 1
#ifdef __HAVE_CPUINFO
a229 1
#endif
a253 1
#if defined(__HAVE_CPUINFO)
a262 1
#endif
a480 1
#ifdef __HAVE_CPUINFO
a482 3
#else
	static int schedclk;
#endif
a484 1
#ifdef __HAVE_CPUINFO
a498 5
/* XXX Kludgey */
#define pscnt spc->spc_pscnt
#define cp_time spc->spc_cp_time
#endif

d502 1
a502 1
		if (--pscnt > 0)
d510 1
a510 1
			cp_time[CP_NICE]++;
d512 1
a512 1
			cp_time[CP_USER]++;
d531 1
a531 1
		if (--pscnt > 0)
d548 1
a548 1
			cp_time[CP_INTR]++;
d551 1
a551 1
			cp_time[CP_SYS]++;
d553 1
a553 1
			cp_time[CP_IDLE]++;
d555 1
a555 6
	pscnt = psdiv;

#ifdef __HAVE_CPUINFO
#undef pscnt
#undef cp_time
#endif
a563 1
#ifdef __HAVE_CPUINFO
a566 4
#else
			if ((++schedclk & 3) == 0)
				schedclock(p);
#endif
@


1.62
log
@Garbage collect CPU_CLOCKUPDATE since it was only used by i386.
from brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.61 2007/03/15 10:22:30 art Exp $	*/
d234 1
a234 1
	if (p && ((p->p_flag & P_WEXIT) == 0)) {
@


1.61
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.60 2006/12/24 20:29:45 miod Exp $	*/
a317 4
#endif

#ifdef CPU_CLOCKUPDATE
	CPU_CLOCKUPDATE();
@


1.60
log
@If <machine/cpu.h> defines PROC_PC to compute the userland pc from an exception
frame, use it to report profiling information via addupc_intr().
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.59 2006/06/14 19:52:07 otto Exp $	*/
d449 1
a449 1
		p->p_flag |= P_PROFIL;
d468 1
a468 1
		p->p_flag &= ~P_PROFIL;
@


1.59
log
@Introducing adjfreq(2), to adjust the clock frequency.
Loosely based on dragonfly code. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.58 2006/01/20 07:53:48 tedu Exp $	*/
d47 1
d544 4
@


1.58
log
@revert auto-skew.  some ntpd implementations interact poorly.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.57 2006/01/13 22:02:37 tedu Exp $	*/
d225 2
d290 19
@


1.57
log
@auto adjusting adjtime.  be more responsive to large clock deltas,
and attempt to compensate for incorrect clocks by adjusting ticks
slowly. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.56 2006/01/03 18:22:31 miod Exp $	*/
a222 1
	extern int tick_skew;
d275 1
a275 1
	delta = tick + tick_skew;
@


1.56
log
@Make #undef match its temporary #define.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.55 2005/11/28 00:14:28 jsg Exp $	*/
d223 1
d276 1
a276 1
	delta = tick;
@


1.55
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.54 2005/10/25 15:49:37 jmc Exp $	*/
d550 1
a550 1
#undef psdiv
@


1.54
log
@dont' -> don't in comments;
from ray lai;
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.53 2005/10/03 01:19:44 aaron Exp $	*/
d90 2
a91 2
	register volatile struct timeval *tp = (t); \
	register long us; \
d141 1
a141 1
initclocks()
d232 1
a232 1
		register struct pstats *pstats;
d321 1
a321 2
hzto(tv)
	struct timeval *tv;
d422 1
a422 2
startprofclock(p)
	register struct proc *p;
d441 1
a441 2
stopprofclock(p)
	register struct proc *p;
d577 1
a577 3
sysctl_clockrate(where, sizep)
	register char *where;
	size_t *sizep;
@


1.53
log
@In hardclock(), do not setup process virtual and profile timers if the process
is in the midst of exiting.  This solves a race condition that causes freed
memory to be left referenced in the master kernel timeout worklist, leading to
a uvm_fault (observed on an i386 MP system).  tedu@@, deraadt@@, miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.52 2004/11/10 11:00:00 grange Exp $	*/
d130 1
a130 1
	 * XXX - dont' commit, just a dummy wrapper until we learn everyone
@


1.52
log
@Diff from art@@:

Update ticks in timeout_hardclock_update to avoid errors in hardclock (this
is the third time we mess up here). ticks is only used for timeouts anyway.
At the same protect updating ticks with timeout_mutex and be slightly
more paranoid in timeout_hardclock_update.

ok tdeval@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.51 2004/09/15 17:48:52 grange Exp $	*/
d231 1
a231 1
	if (p) {
@


1.52.4.1
log
@MFC:
Fix by aaron@@

In hardclock(), do not setup process virtual and profile timers if the process
is in the midst of exiting.  This solves a race condition that causes freed
memory to be left referenced in the master kernel timeout worklist, leading to
a uvm_fault (observed on an i386 MP system).

ok deraadt@@ aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.52 2004/11/10 11:00:00 grange Exp $	*/
d231 1
a231 1
	if (p && ((p->p_flag & P_WEXIT) == 0)) {
@


1.52.2.1
log
@MFC:
Fix by aaron@@

In hardclock(), do not setup process virtual and profile timers if the process
is in the midst of exiting.  This solves a race condition that causes freed
memory to be left referenced in the master kernel timeout worklist, leading to
a uvm_fault (observed on an i386 MP system).

ok deraadt@@ aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.52 2004/11/10 11:00:00 grange Exp $	*/
d231 1
a231 1
	if (p && ((p->p_flag & P_WEXIT) == 0)) {
@


1.51
log
@Typo in #endif comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.50 2004/08/05 13:45:30 art Exp $	*/
a273 1
	ticks++;
@


1.50
log
@Fix typos. Found by Dries Schellekens
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.49 2004/08/04 21:49:19 art Exp $	*/
d669 1
a669 1
#endif /* __HAVE_TIMECOUNTERS */
@


1.49
log
@hardclock detects if ITIMER_VIRTUAL and ITIMER_PROF have expired and
sends SIGVTALRM and SIGPROF to the process if they had. There is a big
problem with calling psignal from hardclock on MULTIPROCESSOR machines
though. It means we need to protect all signal state in the process
with a lock because hardclock doesn't obtain KERNEL_LOCK. Trying to
track down all the tentacles of this quickly becomes very messy. What
saves us at the moment is that SCHED_LOCK (which is used to protect
parts of the signal state, but not all) happens to be recursive and
forgives small and big errors. That's about to change.

So instead of trying to hunt down all the locking problems here, just
make hardclock not send signals. Instead hardclock schedules a timeout
that will send the signal later. There are many reasons why this works
just as good as the previous code, all explained in a comment written
in big, friendly letters in kern_clock.

miod@@ ok noone else dared to ok this, but noone screamed in agony either.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.48 2004/08/04 16:29:32 art Exp $	*/
d181 2
a182 2
 * to deliver the signal. This works becuse of the following reasons:
 *  - The tiemout structures can be in struct pstats because the timers
@


1.48
log
@Even when we have timecounters we still have to do the check for secondary
cpus calling hardclock and the statclock emulation. Move some ifdef
__HAVE_TIMECOUNTER code.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.47 2004/07/28 17:15:12 tholo Exp $	*/
d174 41
d241 1
a241 1
			psignal(p, SIGVTALRM);
d244 1
a244 1
			psignal(p, SIGPROF);
@


1.47
log
@This touches only MI code, and adds new time keeping code.  The
code is all conditionalized on __HAVE_TIMECOUNTER, and not
enabled on any platforms.

adjtime(2) support exists, courtesy of nordin@@, sysctl(2) support
and a concept of quality for each time source attached exists.

High quality time sources exists for PIIX4 ACPI timer as well as
some AMD power management chips.  This will have to be redone
once we actually add ACPI support (at that time we need to use
the ACPI interfaces to get at these clocks).

ok art@@ ken@@ miod@@ jmc@@ and many more
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.46 2004/06/24 19:35:24 tholo Exp $	*/
d184 1
a187 1
#endif
a205 1
#ifndef __HAVE_TIMECOUNTER
d224 1
@


1.46
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.45 2004/06/21 23:50:35 tholo Exp $	*/
d52 3
d107 4
a113 2
long cp_time[CPUSTATES];

d120 1
d144 3
d168 3
d180 1
d187 1
d206 1
d234 1
a249 4
#ifdef notyet
	microset();
#endif

d254 3
d557 1
d628 1
@


1.45
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.44 2004/06/13 21:49:26 niklas Exp $	*/
d269 1
a271 1
	int s;
d293 3
a295 4
	s = splhigh();
	sec = tv->tv_sec - time.tv_sec;
	usec = tv->tv_usec - time.tv_usec;
	splx(s);
d540 71
@


1.44
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d109 3
d240 2
@


1.43
log
@Merge in a piece of the SMP branch into HEAD.

Introduce the cpu_info structure, p_cpu field in struct proc and global
scheduling context and various changed code to deal with this. At the
moment no architecture uses this stuff yet, but it will allow us slow and
controlled migration to the new APIs.

All new code is ifdef:ed out.

ok deraadt@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.42 2003/06/02 23:28:05 millert Exp $	*/
d195 1
a195 1
#ifdef __HAVE_CPUINFO
d198 7
d430 1
a430 1
			setstatclockrate(profhz);                       
d433 1
d494 1
a494 1
#undef pscnt
d506 2
a507 1
			if ((++curcpu()->ci_schedstate.spc_schedticks & 3) == 0)
@


1.42
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.41 2003/05/13 20:31:59 miod Exp $	*/
d162 1
a162 2
hardclock(frame)
	register struct clockframe *frame;
d164 2
a165 2
	register struct proc *p;
	register int delta;
d168 3
d195 5
d398 1
a398 2
statclock(frame)
	register struct clockframe *frame;
d401 2
a402 2
	register struct gmonparam *g;
	register int i;
d404 4
d409 21
a429 1
	register struct proc *p;
a431 1
		p = curproc;
a472 1
		p = curproc;
d485 5
d496 5
a500 1
		if (schedhz == 0)
d503 2
@


1.41
log
@Force "struct timeval time" variable to be aligned to an 8-bit boundary.
This is at least necessary for the sparc microtime() function, and was
only working before by goat luck. The recent commons removal triggered it.

__atribute__ syntax borrowed from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.40 2002/09/24 00:06:23 nordin Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.40
log
@Restore pentium_microtime, testing by henning@@, millert@@. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.39 2002/07/06 19:14:20 nordin Exp $	*/
d113 2
a114 1
volatile struct	timeval time;
@


1.39
log
@Remove kernel support for NTP. ok deraadt@@ and tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.38 2002/07/03 21:19:08 miod Exp $	*/
d226 4
@


1.38
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.37 2002/06/07 21:20:02 art Exp $	*/
a54 1
#include <sys/timex.h>
a86 173
#ifdef NTP	/* NTP phase-locked loop in kernel */
/*
 * Phase/frequency-lock loop (PLL/FLL) definitions
 *
 * The following variables are read and set by the ntp_adjtime() system
 * call.
 *
 * time_state shows the state of the system clock, with values defined
 * in the timex.h header file.
 *
 * time_status shows the status of the system clock, with bits defined
 * in the timex.h header file.
 *
 * time_offset is used by the PLL/FLL to adjust the system time in small
 * increments.
 *
 * time_constant determines the bandwidth or "stiffness" of the PLL.
 *
 * time_tolerance determines maximum frequency error or tolerance of the
 * CPU clock oscillator and is a property of the architecture; however,
 * in principle it could change as result of the presence of external
 * discipline signals, for instance.
 *
 * time_precision is usually equal to the kernel tick variable; however,
 * in cases where a precision clock counter or external clock is
 * available, the resolution can be much less than this and depend on
 * whether the external clock is working or not.
 *
 * time_maxerror is initialized by a ntp_adjtime() call and increased by
 * the kernel once each second to reflect the maximum error bound
 * growth.
 *
 * time_esterror is set and read by the ntp_adjtime() call, but
 * otherwise not used by the kernel.
 */
int time_state = TIME_OK;	/* clock state */
int time_status = STA_UNSYNC;	/* clock status bits */
long time_offset = 0;		/* time offset (us) */
long time_constant = 0;		/* pll time constant */
long time_tolerance = MAXFREQ;	/* frequency tolerance (scaled ppm) */
long time_precision;		/* clock precision (us) */
long time_maxerror = MAXPHASE;	/* maximum error (us) */
long time_esterror = MAXPHASE;	/* estimated error (us) */

/*
 * The following variables establish the state of the PLL/FLL and the
 * residual time and frequency offset of the local clock. The scale
 * factors are defined in the timex.h header file.
 *
 * time_phase and time_freq are the phase increment and the frequency
 * increment, respectively, of the kernel time variable.
 *
 * time_freq is set via ntp_adjtime() from a value stored in a file when
 * the synchronization daemon is first started. Its value is retrieved
 * via ntp_adjtime() and written to the file about once per hour by the
 * daemon.
 *
 * time_adj is the adjustment added to the value of tick at each timer
 * interrupt and is recomputed from time_phase and time_freq at each
 * seconds rollover.
 *
 * time_reftime is the second's portion of the system time at the last
 * call to ntp_adjtime(). It is used to adjust the time_freq variable
 * and to increase the time_maxerror as the time since last update
 * increases.
 */
long time_phase = 0;		/* phase offset (scaled us) */
long time_freq = 0;		/* frequency offset (scaled ppm) */
long time_adj = 0;		/* tick adjust (scaled 1 / hz) */
long time_reftime = 0;		/* time at last adjustment (s) */

#ifdef PPS_SYNC
/*
 * The following variables are used only if the kernel PPS discipline
 * code is configured (PPS_SYNC). The scale factors are defined in the
 * timex.h header file.
 *
 * pps_time contains the time at each calibration interval, as read by
 * microtime(). pps_count counts the seconds of the calibration
 * interval, the duration of which is nominally pps_shift in powers of
 * two.
 *
 * pps_offset is the time offset produced by the time median filter
 * pps_tf[], while pps_jitter is the dispersion (jitter) measured by
 * this filter.
 *
 * pps_freq is the frequency offset produced by the frequency median
 * filter pps_ff[], while pps_stabil is the dispersion (wander) measured
 * by this filter.
 *
 * pps_usec is latched from a high resolution counter or external clock
 * at pps_time. Here we want the hardware counter contents only, not the
 * contents plus the time_tv.usec as usual.
 *
 * pps_valid counts the number of seconds since the last PPS update. It
 * is used as a watchdog timer to disable the PPS discipline should the
 * PPS signal be lost.
 *
 * pps_glitch counts the number of seconds since the beginning of an
 * offset burst more than tick/2 from current nominal offset. It is used
 * mainly to suppress error bursts due to priority conflicts between the
 * PPS interrupt and timer interrupt.
 *
 * pps_intcnt counts the calibration intervals for use in the interval-
 * adaptation algorithm. It's just too complicated for words.
 */
struct timeval pps_time;	/* kernel time at last interval */
long pps_tf[] = {0, 0, 0};	/* pps time offset median filter (us) */
long pps_offset = 0;		/* pps time offset (us) */
long pps_jitter = MAXTIME;	/* time dispersion (jitter) (us) */
long pps_ff[] = {0, 0, 0};	/* pps frequency offset median filter */
long pps_freq = 0;		/* frequency offset (scaled ppm) */
long pps_stabil = MAXFREQ;	/* frequency dispersion (scaled ppm) */
long pps_usec = 0;		/* microsec counter at last interval */
long pps_valid = PPS_VALID;	/* pps signal watchdog counter */
int pps_glitch = 0;		/* pps signal glitch counter */
int pps_count = 0;		/* calibration interval counter (s) */
int pps_shift = PPS_SHIFT;	/* interval duration (s) (shift) */
int pps_intcnt = 0;		/* intervals at current duration */

/*
 * PPS signal quality monitors
 *
 * pps_jitcnt counts the seconds that have been discarded because the
 * jitter measured by the time median filter exceeds the limit MAXTIME
 * (100 us).
 *
 * pps_calcnt counts the frequency calibration intervals, which are
 * variable from 4 s to 256 s.
 *
 * pps_errcnt counts the calibration intervals which have been discarded
 * because the wander exceeds the limit MAXFREQ (100 ppm) or where the
 * calibration interval jitter exceeds two ticks.
 *
 * pps_stbcnt counts the calibration intervals that have been discarded
 * because the frequency wander exceeds the limit MAXFREQ / 4 (25 us).
 */
long pps_jitcnt = 0;		/* jitter limit exceeded */
long pps_calcnt = 0;		/* calibration intervals */
long pps_errcnt = 0;		/* calibration errors */
long pps_stbcnt = 0;		/* stability limit exceeded */
#endif /* PPS_SYNC */

#ifdef EXT_CLOCK
/*
 * External clock definitions
 *
 * The following definitions and declarations are used only if an
 * external clock is configured on the system.
 */
#define CLOCK_INTERVAL 30	/* CPU clock update interval (s) */

/*
 * The clock_count variable is set to CLOCK_INTERVAL at each PPS
 * interrupt and decremented once each second.
 */
int clock_count = 0;		/* CPU clock counter */

#ifdef HIGHBALL
/*
 * The clock_offset and clock_cpu variables are used by the HIGHBALL
 * interface. The clock_offset variable defines the offset between
 * system time and the HIGBALL counters. The clock_cpu variable contains
 * the offset between the system clock and the HIGHBALL clock for use in
 * disciplining the kernel time variable.
 */
extern struct timeval clock_offset; /* Highball clock offset */
long clock_cpu = 0;		/* CPU clock adjust */
#endif /* HIGHBALL */
#endif /* EXT_CLOCK */
#endif /* NTP */


a108 1
#ifndef NTP
a109 4
#else
int	fixtick;			/* used by NTP for same */
int	shifthz;
#endif
a158 28

#ifdef NTP
	if (time_precision == 0)
		time_precision = tick;

	switch (hz) {
	case 60:
	case 64:
		shifthz = SHIFT_SCALE - 6;
		break;
	case 96:
	case 100:
	case 128:
		shifthz = SHIFT_SCALE - 7;
		break;
	case 256:
		shifthz = SHIFT_SCALE - 8;
		break;
	case 1024:
		shifthz = SHIFT_SCALE - 10;
		break;
	case 1200:
		shifthz = SHIFT_SCALE - 11;
		break;
	default:
		panic("weird hz");
	}
#endif
a171 5
#ifdef NTP
	register int time_update;
	struct timeval newtime;
	register int ltemp;
#endif
a206 1
#ifndef NTP
a213 3
#else
	newtime = time;
#endif /* !NTP */
d224 1
a224 3
#ifndef NTP
	BUMPTIME(&time, delta);		/* XXX Now done using NTP code below */
#endif
a226 245
#ifdef NTP
	time_update = delta;

	/*
	 * Compute the phase adjustment. If the low-order bits
	 * (time_phase) of the update overflow, bump the high-order bits
	 * (time_update).
	 */
	time_phase += time_adj;
	if (time_phase <= -FINEUSEC) {
		ltemp = -time_phase >> SHIFT_SCALE;
		time_phase += ltemp << SHIFT_SCALE;
		time_update -= ltemp;
	} else if (time_phase >= FINEUSEC) {
		ltemp = time_phase >> SHIFT_SCALE;
		time_phase -= ltemp << SHIFT_SCALE;
		time_update += ltemp;
	}

#ifdef HIGHBALL
	/*
	 * If the HIGHBALL board is installed, we need to adjust the
	 * external clock offset in order to close the hardware feedback
	 * loop. This will adjust the external clock phase and frequency
	 * in small amounts. The additional phase noise and frequency
	 * wander this causes should be minimal. We also need to
	 * discipline the kernel time variable, since the PLL is used to
	 * discipline the external clock. If the Highball board is not
	 * present, we discipline kernel time with the PLL as usual. We
	 * assume that the external clock phase adjustment (time_update)
	 * and kernel phase adjustment (clock_cpu) are less than the
	 * value of tick.
	 */
	clock_offset.tv_usec += time_update;
	if (clock_offset.tv_usec >= 1000000) {
		clock_offset.tv_sec++;
		clock_offset.tv_usec -= 1000000;
	}
	if (clock_offset.tv_usec < 0) {
		clock_offset.tv_sec--;
		clock_offset.tv_usec += 1000000;
	}
	newtime.tv_usec += clock_cpu;
	clock_cpu = 0;
#else
	newtime.tv_usec += time_update;
#endif /* HIGHBALL */

	/*
	 * On rollover of the second the phase adjustment to be used for
	 * the next second is calculated. Also, the maximum error is
	 * increased by the tolerance. If the PPS frequency discipline
	 * code is present, the phase is increased to compensate for the
	 * CPU clock oscillator frequency error.
	 *
 	 * On a 32-bit machine and given parameters in the timex.h
	 * header file, the maximum phase adjustment is +-512 ms and
	 * maximum frequency offset is a tad less than) +-512 ppm. On a
	 * 64-bit machine, you shouldn't need to ask.
	 */
	if (newtime.tv_usec >= 1000000) {
		newtime.tv_usec -= 1000000;
		newtime.tv_sec++;
		time_maxerror += time_tolerance >> SHIFT_USEC;

		/*
		 * Leap second processing. If in leap-insert state at
		 * the end of the day, the system clock is set back one
		 * second; if in leap-delete state, the system clock is
		 * set ahead one second. The microtime() routine or
		 * external clock driver will insure that reported time
		 * is always monotonic. The ugly divides should be
		 * replaced.
		 */
		switch (time_state) {
		case TIME_OK:
			if (time_status & STA_INS)
				time_state = TIME_INS;
			else if (time_status & STA_DEL)
				time_state = TIME_DEL;
			break;

		case TIME_INS:
			if (newtime.tv_sec % 86400 == 0) {
				newtime.tv_sec--;
				time_state = TIME_OOP;
			}
			break;

		case TIME_DEL:
			if ((newtime.tv_sec + 1) % 86400 == 0) {
				newtime.tv_sec++;
				time_state = TIME_WAIT;
			}
			break;

		case TIME_OOP:
			time_state = TIME_WAIT;
			break;

		case TIME_WAIT:
			if (!(time_status & (STA_INS | STA_DEL)))
				time_state = TIME_OK;
			break;
		}

		/*
		 * Compute the phase adjustment for the next second. In
		 * PLL mode, the offset is reduced by a fixed factor
		 * times the time constant. In FLL mode the offset is
		 * used directly. In either mode, the maximum phase
		 * adjustment for each second is clamped so as to spread
		 * the adjustment over not more than the number of
		 * seconds between updates.
		 */
		if (time_offset < 0) {
			ltemp = -time_offset;
			if (!(time_status & STA_FLL))
				ltemp >>= SHIFT_KG + time_constant;
			if (ltemp > (MAXPHASE / MINSEC) << SHIFT_UPDATE)
				ltemp = (MAXPHASE / MINSEC) <<
				    SHIFT_UPDATE;
			time_offset += ltemp;
			time_adj = -ltemp << (shifthz - SHIFT_UPDATE);
		} else if (time_offset > 0) {
			ltemp = time_offset;
			if (!(time_status & STA_FLL))
				ltemp >>= SHIFT_KG + time_constant;
			if (ltemp > (MAXPHASE / MINSEC) << SHIFT_UPDATE)
				ltemp = (MAXPHASE / MINSEC) <<
				    SHIFT_UPDATE;
			time_offset -= ltemp;
			time_adj = ltemp << (shifthz - SHIFT_UPDATE);
		} else
			time_adj = 0;

		/*
		 * Compute the frequency estimate and additional phase
		 * adjustment due to frequency error for the next
		 * second. When the PPS signal is engaged, gnaw on the
		 * watchdog counter and update the frequency computed by
		 * the pll and the PPS signal.
		 */
#ifdef PPS_SYNC
		pps_valid++;
		if (pps_valid >= PPS_VALID) {
			pps_valid = PPS_VALID;	/* Avoid possible overflow */
			pps_jitter = MAXTIME;
			pps_stabil = MAXFREQ;
			time_status &= ~(STA_PPSSIGNAL | STA_PPSJITTER |
			    STA_PPSWANDER | STA_PPSERROR);
		}
		ltemp = time_freq + pps_freq;
#else
		ltemp = time_freq;
#endif /* PPS_SYNC */

		if (ltemp < 0)
			time_adj -= -ltemp >> (SHIFT_USEC - shifthz);
		else
			time_adj += ltemp >> (SHIFT_USEC - shifthz);
		time_adj += (long)fixtick << shifthz;

		/*
		 * When the CPU clock oscillator frequency is not a
		 * power of 2 in Hz, shifthz is only an approximate
		 * scale factor.
		 */
		switch (hz) {
		case 96:
		case 100:
			/*
			 * In the following code the overall gain is increased
			 * by a factor of 1.25, which results in a residual
			 * error less than 3 percent.
			 */
			if (time_adj < 0)
				time_adj -= -time_adj >> 2;
			else
				time_adj += time_adj >> 2;
			break;
		case 60:
			/*
			 * 60 Hz m68k and vaxes have a PLL gain factor of of
			 * 60/64 (15/16) of what it should be.  In the following code
			 * the overall gain is increased by a factor of 1.0625,
			 * (17/16) which results in a residual error of just less
			 * than 0.4 percent.
			 */
			if (time_adj < 0)
				time_adj -= -time_adj >> 4;
			else
				time_adj += time_adj >> 4;
			break;
		}

#ifdef EXT_CLOCK
		/*
		 * If an external clock is present, it is necessary to
		 * discipline the kernel time variable anyway, since not
		 * all system components use the microtime() interface.
		 * Here, the time offset between the external clock and
		 * kernel time variable is computed every so often.
		 */
		clock_count++;
		if (clock_count > CLOCK_INTERVAL) {
			clock_count = 0;
			microtime(&clock_ext);
			delta.tv_sec = clock_ext.tv_sec - newtime.tv_sec;
			delta.tv_usec = clock_ext.tv_usec - newtime.tv_usec;
			if (delta.tv_usec < 0)
				delta.tv_sec--;
			if (delta.tv_usec >= 500000) {
				delta.tv_usec -= 1000000;
				delta.tv_sec++;
			}
			if (delta.tv_usec < -500000) {
				delta.tv_usec += 1000000;
				delta.tv_sec--;
			}
			if (delta.tv_sec > 0 || (delta.tv_sec == 0 &&
			    delta.tv_usec > MAXPHASE) ||
			    delta.tv_sec < -1 || (delta.tv_sec == -1 &&
			    delta.tv_usec < -MAXPHASE)) {
				newtime = clock_ext;
				delta.tv_sec = 0;
				delta.tv_usec = 0;
			}
#ifdef HIGHBALL
			clock_cpu = delta.tv_usec;
#else /* HIGHBALL */
			hardupdate(delta.tv_usec);
#endif /* HIGHBALL */
		}
#endif /* EXT_CLOCK */
	}

#ifdef CPU_CLOCKUPDATE
	CPU_CLOCKUPDATE(&time, &newtime);
#else
	time = newtime;
#endif

#endif /* NTP */

a466 334


#ifdef NTP	/* NTP phase-locked loop in kernel */

/*
 * hardupdate() - local clock update
 *
 * This routine is called by ntp_adjtime() to update the local clock
 * phase and frequency. The implementation is of an adaptive-parameter,
 * hybrid phase/frequency-lock loop (PLL/FLL). The routine computes new
 * time and frequency offset estimates for each call. If the kernel PPS
 * discipline code is configured (PPS_SYNC), the PPS signal itself
 * determines the new time offset, instead of the calling argument.
 * Presumably, calls to ntp_adjtime() occur only when the caller
 * believes the local clock is valid within some bound (+-128 ms with
 * NTP). If the caller's time is far different than the PPS time, an
 * argument will ensue, and it's not clear who will lose.
 *
 * For uncompensated quartz crystal oscillatores and nominal update
 * intervals less than 1024 s, operation should be in phase-lock mode
 * (STA_FLL = 0), where the loop is disciplined to phase. For update
 * intervals greater than this, operation should be in frequency-lock
 * mode (STA_FLL = 1), where the loop is disciplined to frequency.
 *
 * Note: splclock() is in effect.
 */
void
hardupdate(offset)
	long offset;
{
	long ltemp, mtemp;

	if (!(time_status & STA_PLL) && !(time_status & STA_PPSTIME))
		return;
	ltemp = offset;
#ifdef PPS_SYNC
	if ((time_status & STA_PPSTIME) && (time_status & STA_PPSSIGNAL))
		ltemp = pps_offset;
#endif /* PPS_SYNC */

	/*
	 * Scale the phase adjustment and clamp to the operating range.
	 */
	if (ltemp > MAXPHASE)
		time_offset = MAXPHASE << SHIFT_UPDATE;
	else if (ltemp < -MAXPHASE)
		time_offset = -(MAXPHASE << SHIFT_UPDATE);
	else
		time_offset = ltemp << SHIFT_UPDATE;

	/*
	 * Select whether the frequency is to be controlled and in which
	 * mode (PLL or FLL). Clamp to the operating range. Ugly
	 * multiply/divide should be replaced someday.
	 */
	if (time_status & STA_FREQHOLD || time_reftime == 0)
		time_reftime = time.tv_sec;
	mtemp = time.tv_sec - time_reftime;
	time_reftime = time.tv_sec;
	if (time_status & STA_FLL) {
		if (mtemp >= MINSEC) {
			ltemp = ((time_offset / mtemp) << (SHIFT_USEC -
			    SHIFT_UPDATE));
			if (ltemp < 0)
				time_freq -= -ltemp >> SHIFT_KH;
			else
				time_freq += ltemp >> SHIFT_KH;
		}
	} else {
		if (mtemp < MAXSEC) {
			ltemp *= mtemp;
			if (ltemp < 0)
				time_freq -= -ltemp >> (time_constant +
				    time_constant + SHIFT_KF -
				    SHIFT_USEC);
			else
				time_freq += ltemp >> (time_constant +
				    time_constant + SHIFT_KF -
				    SHIFT_USEC);
		}
	}
	if (time_freq > time_tolerance)
		time_freq = time_tolerance;
	else if (time_freq < -time_tolerance)
		time_freq = -time_tolerance;
}

#ifdef PPS_SYNC
/*
 * hardpps() - discipline CPU clock oscillator to external PPS signal
 *
 * This routine is called at each PPS interrupt in order to discipline
 * the CPU clock oscillator to the PPS signal. It measures the PPS phase
 * and leaves it in a handy spot for the hardclock() routine. It
 * integrates successive PPS phase differences and calculates the
 * frequency offset. This is used in hardclock() to discipline the CPU
 * clock oscillator so that intrinsic frequency error is cancelled out.
 * The code requires the caller to capture the time and hardware counter
 * value at the on-time PPS signal transition.
 *
 * Note that, on some Unix systems, this routine runs at an interrupt
 * priority level higher than the timer interrupt routine hardclock().
 * Therefore, the variables used are distinct from the hardclock()
 * variables, except for certain exceptions: The PPS frequency pps_freq
 * and phase pps_offset variables are determined by this routine and
 * updated atomically. The time_tolerance variable can be considered a
 * constant, since it is infrequently changed, and then only when the
 * PPS signal is disabled. The watchdog counter pps_valid is updated
 * once per second by hardclock() and is atomically cleared in this
 * routine.
 */
void
hardpps(tvp, usec)
	struct timeval *tvp;		/* time at PPS */
	long usec;			/* hardware counter at PPS */
{
	long u_usec, v_usec, bigtick;
	long cal_sec, cal_usec;

	/*
	 * An occasional glitch can be produced when the PPS interrupt
	 * occurs in the hardclock() routine before the time variable is
	 * updated. Here the offset is discarded when the difference
	 * between it and the last one is greater than tick/2, but not
	 * if the interval since the first discard exceeds 30 s.
	 */
	time_status |= STA_PPSSIGNAL;
	time_status &= ~(STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR);
	pps_valid = 0;
	u_usec = -tvp->tv_usec;
	if (u_usec < -500000)
		u_usec += 1000000;
	v_usec = pps_offset - u_usec;
	if (v_usec < 0)
		v_usec = -v_usec;
	if (v_usec > (tick >> 1)) {
		if (pps_glitch > MAXGLITCH) {
			pps_glitch = 0;
			pps_tf[2] = u_usec;
			pps_tf[1] = u_usec;
		} else {
			pps_glitch++;
			u_usec = pps_offset;
		}
	} else
		pps_glitch = 0;

	/*
	 * A three-stage median filter is used to help deglitch the pps
	 * time. The median sample becomes the time offset estimate; the
	 * difference between the other two samples becomes the time
	 * dispersion (jitter) estimate.
	 */
	pps_tf[2] = pps_tf[1];
	pps_tf[1] = pps_tf[0];
	pps_tf[0] = u_usec;
	if (pps_tf[0] > pps_tf[1]) {
		if (pps_tf[1] > pps_tf[2]) {
			pps_offset = pps_tf[1];		/* 0 1 2 */
			v_usec = pps_tf[0] - pps_tf[2];
		} else if (pps_tf[2] > pps_tf[0]) {
			pps_offset = pps_tf[0];		/* 2 0 1 */
			v_usec = pps_tf[2] - pps_tf[1];
		} else {
			pps_offset = pps_tf[2];		/* 0 2 1 */
			v_usec = pps_tf[0] - pps_tf[1];
		}
	} else {
		if (pps_tf[1] < pps_tf[2]) {
			pps_offset = pps_tf[1];		/* 2 1 0 */
			v_usec = pps_tf[2] - pps_tf[0];
		} else  if (pps_tf[2] < pps_tf[0]) {
			pps_offset = pps_tf[0];		/* 1 0 2 */
			v_usec = pps_tf[1] - pps_tf[2];
		} else {
			pps_offset = pps_tf[2];		/* 1 2 0 */
			v_usec = pps_tf[1] - pps_tf[0];
		}
	}
	if (v_usec > MAXTIME)
		pps_jitcnt++;
	v_usec = (v_usec << PPS_AVG) - pps_jitter;
	if (v_usec < 0)
		pps_jitter -= -v_usec >> PPS_AVG;
	else
		pps_jitter += v_usec >> PPS_AVG;
	if (pps_jitter > (MAXTIME >> 1))
		time_status |= STA_PPSJITTER;

	/*
	 * During the calibration interval adjust the starting time when
	 * the tick overflows. At the end of the interval compute the
	 * duration of the interval and the difference of the hardware
	 * counters at the beginning and end of the interval. This code
	 * is deliciously complicated by the fact valid differences may
	 * exceed the value of tick when using long calibration
	 * intervals and small ticks. Note that the counter can be
	 * greater than tick if caught at just the wrong instant, but
	 * the values returned and used here are correct.
	 */
	bigtick = (long)tick << SHIFT_USEC;
	pps_usec -= pps_freq;
	if (pps_usec >= bigtick)
		pps_usec -= bigtick;
	if (pps_usec < 0)
		pps_usec += bigtick;
	pps_time.tv_sec++;
	pps_count++;
	if (pps_count < (1 << pps_shift))
		return;
	pps_count = 0;
	pps_calcnt++;
	u_usec = usec << SHIFT_USEC;
	v_usec = pps_usec - u_usec;
	if (v_usec >= bigtick >> 1)
		v_usec -= bigtick;
	if (v_usec < -(bigtick >> 1))
		v_usec += bigtick;
	if (v_usec < 0)
		v_usec = -(-v_usec >> pps_shift);
	else
		v_usec = v_usec >> pps_shift;
	pps_usec = u_usec;
	cal_sec = tvp->tv_sec;
	cal_usec = tvp->tv_usec;
	cal_sec -= pps_time.tv_sec;
	cal_usec -= pps_time.tv_usec;
	if (cal_usec < 0) {
		cal_usec += 1000000;
		cal_sec--;
	}
	pps_time = *tvp;

	/*
	 * Check for lost interrupts, noise, excessive jitter and
	 * excessive frequency error. The number of timer ticks during
	 * the interval may vary +-1 tick. Add to this a margin of one
	 * tick for the PPS signal jitter and maximum frequency
	 * deviation. If the limits are exceeded, the calibration
	 * interval is reset to the minimum and we start over.
	 */
	u_usec = (long)tick << 1;
	if (!((cal_sec == -1 && cal_usec > (1000000 - u_usec))
	    || (cal_sec == 0 && cal_usec < u_usec))
	    || v_usec > time_tolerance || v_usec < -time_tolerance) {
		pps_errcnt++;
		pps_shift = PPS_SHIFT;
		pps_intcnt = 0;
		time_status |= STA_PPSERROR;
		return;
	}

	/*
	 * A three-stage median filter is used to help deglitch the pps
	 * frequency. The median sample becomes the frequency offset
	 * estimate; the difference between the other two samples
	 * becomes the frequency dispersion (stability) estimate.
	 */
	pps_ff[2] = pps_ff[1];
	pps_ff[1] = pps_ff[0];
	pps_ff[0] = v_usec;
	if (pps_ff[0] > pps_ff[1]) {
		if (pps_ff[1] > pps_ff[2]) {
			u_usec = pps_ff[1];		/* 0 1 2 */
			v_usec = pps_ff[0] - pps_ff[2];
		} else if (pps_ff[2] > pps_ff[0]) {
			u_usec = pps_ff[0];		/* 2 0 1 */
			v_usec = pps_ff[2] - pps_ff[1];
		} else {
			u_usec = pps_ff[2];		/* 0 2 1 */
			v_usec = pps_ff[0] - pps_ff[1];
		}
	} else {
		if (pps_ff[1] < pps_ff[2]) {
			u_usec = pps_ff[1];		/* 2 1 0 */
			v_usec = pps_ff[2] - pps_ff[0];
		} else  if (pps_ff[2] < pps_ff[0]) {
			u_usec = pps_ff[0];		/* 1 0 2 */
			v_usec = pps_ff[1] - pps_ff[2];
		} else {
			u_usec = pps_ff[2];		/* 1 2 0 */
			v_usec = pps_ff[1] - pps_ff[0];
		}
	}

	/*
	 * Here the frequency dispersion (stability) is updated. If it
	 * is less than one-fourth the maximum (MAXFREQ), the frequency
	 * offset is updated as well, but clamped to the tolerance. It
	 * will be processed later by the hardclock() routine.
	 */
	v_usec = (v_usec >> 1) - pps_stabil;
	if (v_usec < 0)
		pps_stabil -= -v_usec >> PPS_AVG;
	else
		pps_stabil += v_usec >> PPS_AVG;
	if (pps_stabil > MAXFREQ >> 2) {
		pps_stbcnt++;
		time_status |= STA_PPSWANDER;
		return;
	}
	if (time_status & STA_PPSFREQ) {
		if (u_usec < 0) {
			pps_freq -= -u_usec >> PPS_AVG;
			if (pps_freq < -time_tolerance)
				pps_freq = -time_tolerance;
			u_usec = -u_usec;
		} else {
			pps_freq += u_usec >> PPS_AVG;
			if (pps_freq > time_tolerance)
				pps_freq = time_tolerance;
		}
	}

	/*
	 * Here the calibration interval is adjusted. If the maximum
	 * time difference is greater than tick / 4, reduce the interval
	 * by half. If this is not the case for four consecutive
	 * intervals, double the interval.
	 */
	if (u_usec << pps_shift > bigtick >> 2) {
		pps_intcnt = 0;
		if (pps_shift > PPS_SHIFT)
			pps_shift--;
	} else if (pps_intcnt >= 4) {
		pps_intcnt = 0;
		if (pps_shift < PPS_SHIFTMAX)
			pps_shift++;
	} else
		pps_intcnt++;
}
#endif /* PPS_SYNC */
#endif /* NTP  */

@


1.37
log
@Change addupc_intr to not use fuswintr and suswintr to update the profiling
info. Since we only use it to profile processes in user mode and there
is no way to get back user mode without going past the AST that will
write out the profiling info in a context where copyout works.

Sitting in my tree for ages.
Reviewed and with some suggestions from nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.36 2002/06/07 08:16:26 nordin Exp $	*/
d289 2
@


1.36
log
@Simplify so that we can remove CLKF_BASEPRI() and spllowersoftclock()
infrastructure. ok art@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.35 2002/04/24 21:53:12 espie Exp $	*/
d864 1
a864 1
			addupc_intr(p, CLKF_PC(frame), 1);
@


1.35
log
@Introduce a new file, machine/internal_types.h, to hold that specific arch
type characteristics.

internal_types.h will contain only settings invisible from standard C, e.g.,
in the __* or _[A-Z]* namespace, and be reused by files like limits.h.

This allows us to shorten machine/limits.h greatly, as all the common defines
are now in sys/limits.h, plus a small stub in internal_types.h.

Tested on all arches as far as I know.
Approved after discussion with art, millert, deraadt, and others.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.34 2002/02/18 03:45:08 nordin Exp $	*/
a693 8
		if (CLKF_BASEPRI(frame)) {
			/*
			 * Save the overhead of a software interrupt;
			 * it will happen as soon as we return, so do it now.
			 */
			spllowersoftclock();
			softclock();
		} else {
d695 1
a695 1
			softintr_schedule(softclock_si);
d697 1
a697 1
			setsoftclock();
a698 1
		}
@


1.34
log
@Don't do unnecessary normalization. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.33 2002/02/15 20:55:26 nordin Exp $	*/
d49 1
a58 1
#include <machine/limits.h>
@


1.33
log
@Improve comment. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.32 2002/02/15 01:59:26 art Exp $	*/
d797 1
a797 5
	if (usec < 0) {
		sec--;
		usec += 1000000;
	}
	if (sec < 0 || (sec == 0 && usec <= 0)) {
d799 1
a799 1
	} else if (sec <= LONG_MAX / 1000000)
@


1.32
log
@Add a tvtohz function. Like hzto, but doesn't subtract the current time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.31 2002/01/02 06:07:41 nordin Exp $	*/
d777 1
a777 1
	 * difference fits in a long, then the total number of usecs will
d784 1
a784 1
	 * the time difference fits in a long, then convert the parts to
d789 1
a789 1
	 * Otherwise, round the time difference down to the maximum
@


1.31
log
@Remove reference to timeout table. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.30 2001/12/14 03:42:16 nate Exp $	*/
d747 50
@


1.30
log
@New hz value needed by AlphaServer 1200 and a couple other machines
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.29 2001/11/06 19:53:20 miod Exp $	*/
a87 6
/*
 * TODO:
 *	allocate more timeout table slots when table overflows.
 */


d912 1
a912 1
 * intervals greater than thiss, operation should be in frequency-lock
@


1.30.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.31 2002/01/02 06:07:41 nordin Exp $	*/
d88 6
d918 1
a918 1
 * intervals greater than this, operation should be in frequency-lock
@


1.30.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.30.2.1 2002/01/31 22:55:40 niklas Exp $	*/
a48 1
#include <sys/limits.h>
d58 1
d694 8
d703 1
a703 1
		softintr_schedule(softclock_si);
d705 1
a705 1
		setsoftclock();
d707 1
a766 46
 * Compute number of hz in the specified amount of time.
 */
int
tvtohz(struct timeval *tv)
{
	unsigned long ticks;
	long sec, usec;

	/*
	 * If the number of usecs in the whole seconds part of the time
	 * fits in a long, then the total number of usecs will
	 * fit in an unsigned long.  Compute the total and convert it to
	 * ticks, rounding up and adding 1 to allow for the current tick
	 * to expire.  Rounding also depends on unsigned long arithmetic
	 * to avoid overflow.
	 *
	 * Otherwise, if the number of ticks in the whole seconds part of
	 * the time fits in a long, then convert the parts to
	 * ticks separately and add, using similar rounding methods and
	 * overflow avoidance.  This method would work in the previous
	 * case but it is slightly slower and assumes that hz is integral.
	 *
	 * Otherwise, round the time down to the maximum
	 * representable value.
	 *
	 * If ints have 32 bits, then the maximum value for any timeout in
	 * 10ms ticks is 248 days.
	 */
	sec = tv->tv_sec;
	usec = tv->tv_usec;
	if (sec < 0 || (sec == 0 && usec <= 0))
		ticks = 0;
	else if (sec <= LONG_MAX / 1000000)
		ticks = (sec * 1000000 + (unsigned long)usec + (tick - 1))
		    / tick + 1;
	else if (sec <= LONG_MAX / hz)
		ticks = sec * hz
		    + ((unsigned long)usec + (tick - 1)) / tick + 1;
	else
		ticks = LONG_MAX;
	if (ticks > INT_MAX)
		ticks = INT_MAX;
	return ((int)ticks);
}

/*
d827 1
a827 1
			addupc_intr(p, CLKF_PC(frame));
@


1.30.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.30.2.2 2002/06/11 03:29:40 art Exp $	*/
d55 1
d88 173
d283 1
d285 4
a288 2

long cp_time[CPUSTATES];
d336 28
d377 5
d417 1
d425 3
d438 3
a440 1
	BUMPTIME(&time, delta);
d443 237
d681 3
a683 1
	CPU_CLOCKUPDATE();
d686 2
d928 334
@


1.30.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 1
a113 2
volatile struct	timeval time
	__attribute__((__aligned__(__alignof__(quad_t))));
@


1.29
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.28 2001/08/19 06:10:09 art Exp $	*/
d362 3
@


1.28
log
@generic soft interrupts for softclock.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.27 2000/08/23 20:36:18 art Exp $	*/
d52 1
a52 1
#include <vm/vm.h>
@


1.27
log
@Move the updating of timeout queues to after ticks is incremented.
The older code actually ensured that no timeout would be too early, but
it violated the principle of least surprise by making it seem (when you
looked at the time variable) that every timeout was one tick late.
Also periodic timeouts (that readd themselves in the timeout function),
will now happen with the frequency you expect.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.26 2000/07/07 15:37:00 art Exp $	*/
d299 15
d320 7
a326 1
	register int i;
d702 1
a702 1
			(void)spllowersoftclock();
d704 4
a707 1
		} else
d709 2
@


1.26
log
@Make hzto return 0 for timeouts that should happen now or in the past.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.25 2000/07/06 15:33:31 ho Exp $	*/
d356 1
a356 1
	register int delta, needsoft;
a364 5
	/*
	 * Update real-time timeout queue.
	 */
	needsoft = timeout_hardclock_update();

d671 1
d675 1
a675 1
	if (needsoft) {
@


1.25
log
@Change splsoftclock() to spllowersoftclock(). (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.24 2000/07/05 08:10:56 pjanzen Exp $	*/
d700 2
a701 2
	register unsigned long ticks;
	register long sec, usec;
d732 2
a733 2
	if (sec < 0) {
		ticks = 1;
@


1.24
log
@Stop sleeps from returning early (by up to a clock tick).
From FreeBSD:  eventually, we should replace hzto() with something
like tvtohz() as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.23 2000/03/23 11:20:45 art Exp $	*/
d685 1
a685 1
			(void)splsoftclock();
@


1.23
log
@Update a comment to reflect reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.22 2000/03/23 09:59:57 art Exp $	*/
d58 1
d700 2
a701 1
	register long ticks, sec;
d705 6
a710 6
	 * If number of microseconds will fit in 32 bit arithmetic,
	 * then compute number of microseconds to time and scale to
	 * ticks.  Otherwise just compute number of hz in time, rounding
	 * times greater than representible to maximum value.  (We must
	 * compute in microseconds, because hz can be greater than 1000,
	 * and thus tick can be less than one millisecond).
d712 11
a722 5
	 * Delta times less than 14 hours can be computed ``exactly''.
	 * (Note that if hz would yeild a non-integral number of us per
	 * tick, i.e. tickfix is nonzero, timouts can be a tick longer
	 * than they should be.)  Maximum value for any timeout in 10ms
	 * ticks is 250 days.
d726 14
a739 5
	if (sec <= 0x7fffffff / 1000000 - 1)
		ticks = ((tv->tv_sec - time.tv_sec) * 1000000 +
			(tv->tv_usec - time.tv_usec)) / tick;
	else if (sec <= 0x7fffffff / hz)
		ticks = sec * hz;
d741 4
a744 3
		ticks = 0x7fffffff;
	splx(s);
	return (ticks);
@


1.22
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.21 1999/08/15 00:07:43 pjanzen Exp $	*/
d693 1
a693 1
 * compute third argument to timeout() from an absolute time.
@


1.21
log
@Adopt NetBSD fix for scheduler problems (nice was broken).  From the NetBSD
commit messages:

Scheduler bug fixes and reorganization
* fix the ancient nice(1) bug, where nice +20 processes incorrectly
  steal 10 - 20% of the CPU, (or even more depending on load average)
* provide a new schedclock() mechanism at a new clock at schedhz, so high
  platform hz values don't cause nice +0 processes to look like they are
  niced
* change the algorithm slightly, and reorganize the code a lot
* fix percent-CPU calculation bugs, and eliminate some no-op code

=== nice bug === Correctly divide the scheduler queues between niced and
compute-bound processes. The current nice weight of two (sort of, see
`algorithm change' below) neatly divides the USRPRI queues in half; this
should have been used to clip p_estcpu, instead of UCHAR_MAX.  Besides
being the wrong amount, clipping an unsigned char to UCHAR_MAX is a no-op,
and it was done after decay_cpu() which can only _reduce_ the value.  It
has to be kept <= NICE_WEIGHT * PRIO_MAX - PPQ or processes can
scheduler-penalize themselves onto the same queue as nice +20 processes.
(Or even a higher one.)

=== New schedclock() mechanism === Some platforms should be cutting down
stathz before hitting the scheduler, since the scheduler algorithm only
works right in the vicinity of 64 Hz. Rather than prescale hz, then scale
back and forth by 4 every time p_estcpu is touched (each occurance an
abstraction violation), use p_estcpu without scaling and require schedhz
to be generated directly at the right frequency. Use a default stathz (well,
actually, profhz) / 4, so nothing changes unless a platform defines schedhz
and a new clock.
[ To do:  Define these for alpha, where hz==1024, and nice was totally broke.]

=== Algorithm change === The nice value used to be added to the
exponentially-decayed scheduler history value p_estcpu, in _addition_ to
be incorporated directly (with greater weight) into the priority calculation.
At first glance, it appears to be a pointless increase of 1/8 the nice
effect (pri = p_estcpu/4 + nice*2), but it's actually at least 3x that
because it will ramp up linearly but be decayed only exponentially, thus
converging to an additional .75 nice for a loadaverage of one. I killed
this: it makes the behavior hard to control, almost impossible to analyze,
and the effect (~~nothing at for the first second, then somewhat increased
niceness after three seconds or more, depending on load average) pointless.

=== Other bugs === hz -> profhz in the p_pctcpu = f(p_cpticks) calcuation.
Collect scheduler functionality. Try to put each abstraction in just one
place.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.20 1998/08/27 05:00:17 deraadt Exp $	*/
d47 1
a47 1
#include <sys/callout.h>
a353 1
	register struct callout *p1;
a365 7
	 * At front of queue are some number of events which are ``due''.
	 * The time to these is <= 0 and if negative represents the
	 * number of ticks which have passed since it was supposed to happen.
	 * The rest of the q elements (times > 0) are events yet to happen,
	 * where the time for each is given as a delta from the previous.
	 * Decrementing just the first of these serves to decrement the time
	 * to all events.
d367 1
a367 8
	needsoft = 0;
	for (p1 = calltodo.c_next; p1 != NULL; p1 = p1->c_next) {
		if (--p1->c_time > 0)
			break;
		needsoft = 1;
		if (p1->c_time == 0)
			break;
	}
a691 108
 * Software (low priority) clock interrupt.
 * Run periodic events from timeout queue.
 */
/*ARGSUSED*/
void
softclock()
{
	register struct callout *c;
	register void *arg;
	register void (*func) __P((void *));
	register int s;

	s = splhigh();
	while ((c = calltodo.c_next) != NULL && c->c_time <= 0) {
		func = c->c_func;
		arg = c->c_arg;
		calltodo.c_next = c->c_next;
		c->c_next = callfree;
		callfree = c;
		splx(s);
		(*func)(arg);
		(void) splhigh();
	}
	splx(s);
}

/*
 * timeout --
 *	Execute a function after a specified length of time.
 *
 * untimeout --
 *	Cancel previous timeout function call.
 *
 *	See AT&T BCI Driver Reference Manual for specification.  This
 *	implementation differs from that one in that no identification
 *	value is returned from timeout, rather, the original arguments
 *	to timeout are used to identify entries for untimeout.
 */
void
timeout(ftn, arg, ticks)
	void (*ftn) __P((void *));
	void *arg;
	register int ticks;
{
	register struct callout *new, *p, *t;
	register int s;

	if (ticks <= 0)
		ticks = 1;

	/* Lock out the clock. */
	s = splhigh();

	/* Fill in the next free callout structure. */
	if (callfree == NULL)
		panic("timeout table full");
	new = callfree;
	callfree = new->c_next;
	new->c_arg = arg;
	new->c_func = ftn;

	/*
	 * The time for each event is stored as a difference from the time
	 * of the previous event on the queue.  Walk the queue, correcting
	 * the ticks argument for queue entries passed.  Correct the ticks
	 * value for the queue entry immediately after the insertion point
	 * as well.  Watch out for negative c_time values; these represent
	 * overdue events.
	 */
	for (p = &calltodo;
	    (t = p->c_next) != NULL && ticks > t->c_time; p = t)
		if (t->c_time > 0)
			ticks -= t->c_time;
	new->c_time = ticks;
	if (t != NULL)
		t->c_time -= ticks;

	/* Insert the new entry into the queue. */
	p->c_next = new;
	new->c_next = t;
	splx(s);
}

void
untimeout(ftn, arg)
	void (*ftn) __P((void *));
	void *arg;
{
	register struct callout *p, *t;
	register int s;

	s = splhigh();
	for (p = &calltodo; (t = p->c_next) != NULL; p = t)
		if (t->c_func == ftn && t->c_arg == arg) {
			/* Increment next entry's tick count. */
			if (t->c_next && t->c_time > 0)
				t->c_next->c_time += t->c_time;

			/* Move entry from callout queue to callfree queue. */
			p->c_next = t->c_next;
			t->c_next = callfree;
			callfree = t;
			break;
		}
	splx(s);
}

/*
a1208 39

#ifdef DDB
#include <machine/db_machdep.h>

#include <ddb/db_interface.h>
#include <ddb/db_access.h>
#include <ddb/db_sym.h>
#include <ddb/db_output.h>

void db_show_callout(addr, haddr, count, modif)
	db_expr_t addr; 
	int haddr; 
	db_expr_t count;
	char *modif;
{
	register struct callout *p1;
	register int	cum;
	register int	s;
	db_expr_t	offset;
	char		*name;

        db_printf("      cum     ticks      arg  func\n");
	s = splhigh();
	for (cum = 0, p1 = calltodo.c_next; p1; p1 = p1->c_next) {
		register int t = p1->c_time;

		if (t > 0)
			cum += t;

		db_find_sym_and_offset((db_addr_t)p1->c_func, &name, &offset);
		if (name == NULL)
			name = "?";

                db_printf("%9d %9d %8x  %s (%x)\n",
			  cum, t, p1->c_arg, name, p1->c_func);
	}
	splx(s);
}
#endif
@


1.21.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
a47 1
#include <sys/timeout.h>
d354 1
d367 7
d375 8
a382 1
	needsoft = timeout_hardclock_update();
d707 108
d816 1
a816 1
 * compute the second argument to timeout_add() from an absolute time.
d1332 39
@


1.21.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.27 2000/08/23 20:36:18 art Exp $	*/
a57 1
#include <machine/limits.h>
d355 1
a355 1
	register int delta;
d364 5
a674 1
	 * Update real-time timeout queue.
d678 1
a678 1
	if (timeout_hardclock_update()) {
d684 1
a684 1
			(void)spllowersoftclock();
d699 1
a699 2
	unsigned long ticks;
	long sec, usec;
d703 6
a708 6
	 * If the number of usecs in the whole seconds part of the time
	 * difference fits in a long, then the total number of usecs will
	 * fit in an unsigned long.  Compute the total and convert it to
	 * ticks, rounding up and adding 1 to allow for the current tick
	 * to expire.  Rounding also depends on unsigned long arithmetic
	 * to avoid overflow.
d710 5
a714 11
	 * Otherwise, if the number of ticks in the whole seconds part of
	 * the time difference fits in a long, then convert the parts to
	 * ticks separately and add, using similar rounding methods and
	 * overflow avoidance.  This method would work in the previous
	 * case but it is slightly slower and assumes that hz is integral.
	 *
	 * Otherwise, round the time difference down to the maximum
	 * representable value.
	 *
	 * If ints have 32 bits, then the maximum value for any timeout in
	 * 10ms ticks is 248 days.
d718 7
a724 1
	usec = tv->tv_usec - time.tv_usec;
d726 1
a726 17
	if (usec < 0) {
		sec--;
		usec += 1000000;
	}
	if (sec < 0 || (sec == 0 && usec <= 0)) {
		ticks = 0;
	} else if (sec <= LONG_MAX / 1000000)
		ticks = (sec * 1000000 + (unsigned long)usec + (tick - 1))
		    / tick + 1;
	else if (sec <= LONG_MAX / hz)
		ticks = sec * hz
		    + ((unsigned long)usec + (tick - 1)) / tick + 1;
	else
		ticks = LONG_MAX;
	if (ticks > INT_MAX)
		ticks = INT_MAX;
	return ((int)ticks);
@


1.21.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.21.4.2 2001/05/14 22:32:39 niklas Exp $	*/
a298 15
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
void	*softclock_si;
void	generic_softclock(void *);

void
generic_softclock(void *ignore)
{
	/*
	 * XXX - dont' commit, just a dummy wrapper until we learn everyone
	 *       deal with a changed proto for softclock().
	 */
	softclock();
}
#endif

d305 1
a305 7
	int i;

#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	softclock_si = softintr_establish(IPL_SOFTCLOCK, generic_softclock, NULL);
	if (softclock_si == NULL)
		panic("initclocks: unable to register softclock intr");
#endif
d681 1
a681 1
			spllowersoftclock();
d683 1
a683 4
		} else {
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
			softintr_schedule(softclock_si);
#else
a684 2
#endif
		}
@


1.21.4.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
#include <uvm/uvm_extern.h>
@


1.21.4.5
log
@Merge in trunk
@
text
@d88 6
a362 3
	case 1200:
		shifthz = SHIFT_SCALE - 11;
		break;
a769 46
 * Compute number of hz in the specified amount of time.
 */
int
tvtohz(struct timeval *tv)
{
	unsigned long ticks;
	long sec, usec;

	/*
	 * If the number of usecs in the whole seconds part of the time
	 * fits in a long, then the total number of usecs will
	 * fit in an unsigned long.  Compute the total and convert it to
	 * ticks, rounding up and adding 1 to allow for the current tick
	 * to expire.  Rounding also depends on unsigned long arithmetic
	 * to avoid overflow.
	 *
	 * Otherwise, if the number of ticks in the whole seconds part of
	 * the time fits in a long, then convert the parts to
	 * ticks separately and add, using similar rounding methods and
	 * overflow avoidance.  This method would work in the previous
	 * case but it is slightly slower and assumes that hz is integral.
	 *
	 * Otherwise, round the time down to the maximum
	 * representable value.
	 *
	 * If ints have 32 bits, then the maximum value for any timeout in
	 * 10ms ticks is 248 days.
	 */
	sec = tv->tv_sec;
	usec = tv->tv_usec;
	if (sec < 0 || (sec == 0 && usec <= 0))
		ticks = 0;
	else if (sec <= LONG_MAX / 1000000)
		ticks = (sec * 1000000 + (unsigned long)usec + (tick - 1))
		    / tick + 1;
	else if (sec <= LONG_MAX / hz)
		ticks = sec * hz
		    + ((unsigned long)usec + (tick - 1)) / tick + 1;
	else
		ticks = LONG_MAX;
	if (ticks > INT_MAX)
		ticks = INT_MAX;
	return ((int)ticks);
}

/*
d915 1
a915 1
 * intervals greater than this, operation should be in frequency-lock
@


1.21.4.6
log
@Sync the SMP branch with 3.3
@
text
@a48 1
#include <sys/limits.h>
d54 1
d58 1
d88 173
d283 1
d285 4
a288 2

long cp_time[CPUSTATES];
d336 28
d377 5
d417 1
d425 3
d438 3
a440 1
	BUMPTIME(&time, delta);
d443 237
d681 3
a683 1
	CPU_CLOCKUPDATE();
d686 2
d694 8
d703 1
a703 1
		softintr_schedule(softclock_si);
d705 1
a705 1
		setsoftclock();
d707 1
d873 1
a873 1
			addupc_intr(p, CLKF_PC(frame));
d937 334
@


1.21.4.7
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d113 1
a113 2
volatile struct	timeval time
	__attribute__((__aligned__(__alignof__(quad_t))));
@


1.21.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.21.4.7 2003/05/16 00:29:43 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.21.4.9
log
@who needs timetravel? not us!
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.21.4.8 2003/06/07 11:03:40 ho Exp $	*/
a168 1
	struct cpu_info *ci = curcpu();
a191 9

#if defined(MULTIPROCESSOR)
	/*
	 * If we are not the primary CPU, we're not allowed to do
	 * any more work.
	 */
	if (CPU_IS_PRIMARY(ci) == 0)
		return;
#endif
@


1.21.4.10
log
@Make a few scheduling globals per-cpu, mostly NetBSD code
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.21.4.9 2004/03/30 09:12:07 niklas Exp $	*/
a155 1
	rrticks_init = hz / 10;
a193 3
	if (--rrticks <= 0)
		roundrobin(ci);

d405 2
a406 2
	struct gmonparam *g;
	int i;
a407 4
#ifdef MULTIPROCESSOR
	struct cpu_info *ci = curcpu();
	struct schedstate_percpu *spc = &ci->ci_schedstate;
#else
d409 1
a409 23
#endif
	struct proc *p;

#ifdef MULTIPROCESSOR
	/*
	 * Notice changes in divisor frequency, and adjust clock
	 * frequency accordingly.
	 */
	if (spc->spc_psdiv != psdiv) {
		spc->spc_psdiv = psdiv;
		spc->spc_pscnt = psdiv;
		if (psdiv == 1) {
			setstatclockrate(stathz);
		} else {
			setstatclockrate(profhz);			
		}
	}

/* XXX Kludgey */
#define pscnt spc->spc_pscnt
#define cp_time spc->spc_cp_time

#endif
a465 5

#ifdef MULTIPROCESSOR
#undef psdiv
#undef cp_time
#endif
@


1.21.4.11
log
@few fixes to make non-smp compile
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.21.4.10 2004/06/05 17:19:55 niklas Exp $	*/
a169 1
#if defined(MULTIPROCESSOR)
a170 1
#endif
@


1.21.4.12
log
@tweak for non-smp case
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.21.4.11 2004/06/05 23:18:25 tedu Exp $	*/
d170 1
a171 2
#ifndef MULTIPROCESSOR
	extern int rrticks;
@


1.21.4.13
log
@don't rely on curcpu() and other fixes for non-mp
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.21.4.12 2004/06/06 05:22:51 tedu Exp $	*/
a169 1
#ifdef MULTIPROCESSOR
d171 1
a171 1
#else
a197 1
#if defined(MULTIPROCESSOR)
d201 1
a207 4
#else
	if (--rrticks <= 0)
		roundrobin(0);

@


1.21.4.14
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d156 1
d163 2
a164 1
hardclock(struct clockframe *frame)
d166 2
a167 2
	struct proc *p;
	int delta;
d170 1
a170 1
#ifdef __HAVE_CPUINFO
d172 2
d199 2
a200 2
#if defined(__HAVE_CPUINFO)
	if (--ci->ci_schedstate.spc_rrticks <= 0)
d209 4
d413 2
a414 1
statclock(struct clockframe *frame)
d420 1
a420 1
#ifdef __HAVE_CPUINFO
d426 1
a426 1
	struct proc *p = curproc;
d428 1
a428 1
#ifdef __HAVE_CPUINFO
d446 1
d450 1
d492 1
d505 1
a505 1
#ifdef __HAVE_CPUINFO
d516 1
a516 6
		if (schedhz == 0) {
#ifdef __HAVE_CPUINFO
			if ((++curcpu()->ci_schedstate.spc_schedticks & 3) ==
			    0)
				schedclock(p);
#else
a518 2
#endif
		}
@


1.20
log
@Undo changes which were not discussed.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.18 1998/02/08 22:41:34 tholo Exp $	*/
d55 1
d281 1
d907 1
a965 13
	/*
	 * We adjust the priority of the current process.  The priority of
	 * a process gets worse as it accumulates CPU time.  The cpu usage
	 * estimator (p_estcpu) is increased here.  The formula for computing
	 * priorities (in kern_synch.c) will compute a different value each
	 * time p_estcpu increases by 4.  The cpu usage estimator ramps up
	 * quite quickly when the process is running (linearly), and decays
	 * away exponentially, at a rate which is proportionally slower when
	 * the system is busy.  The basic principal is that the system will
	 * 90% forget that the process used a lot of CPU time in 5 * loadav
	 * seconds.  This causes the system to favor processes which haven't
	 * run much recently, and to round-robin among other processes.
	 */
d968 7
a974 7
		if (++p->p_estcpu == 0)
			p->p_estcpu--;
		if ((p->p_estcpu & 3) == 0) {
			resetpriority(p);
			if (p->p_priority >= PUSER)
				p->p_priority = p->p_usrpri;
		}
@


1.19
log
@defopt NTP
@
text
@a43 2
#include "opt_ntp.h"

@


1.18
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.17 1997/12/30 19:07:29 mickey Exp $	*/
d43 2
@


1.17
log
@make it compile w/ GPROF
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.16 1997/11/23 03:19:17 mickey Exp $	*/
d587 2
a588 1
		if (pps_valid == PPS_VALID) {
d1023 1
a1023 1
	if (time_status & STA_PPSTIME && time_status & STA_PPSSIGNAL)
@


1.16
log
@nuke prehistoric disk statistics
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.15 1997/01/25 23:35:58 tholo Exp $	*/
d902 1
@


1.15
log
@Don't do disruptive time corrections if tick size is not integral; from
Dennis Ferguson (NetBSD PR #2788)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.14 1997/01/25 23:31:47 tholo Exp $	*/
a903 1
	register int i;
a959 14

	/*
	 * XXX Support old-style instrumentation for now.
	 *
	 * We maintain statistics shown by user-level statistics
	 * programs:  the amount of time in each cpu state, and
	 * the amount of time each of DK_NDRIVE ``drives'' is busy.
	 *
	 * XXX	should either run linked list of drives, or (better)
	 *	grab timestamps in the start & done code.
	 */
	for (i = 0; i < DK_NDRIVE; i++)
		if (dk_busy & (1 << i))
			dk_time[i]++;
@


1.14
log
@Improve adjtime() for odd hz values; from Dennis Ferguson (NetBSD PR# 2787)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.13 1996/09/09 04:50:33 tholo Exp $	*/
d287 1
a287 1
static int tickfixcnt;			/* number of ticks since last fix */
d418 1
a418 1
		tickfixcnt++;
d420 2
a421 2
			delta += tickfix;
			tickfixcnt = 0;
@


1.13
log
@Don't claim a better precision than (1,000,000 / hz) us...
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.12 1996/06/09 03:47:29 briggs Exp $	*/
d429 1
a429 1
		delta = tick + tickdelta;
@


1.12
log
@Declare tickfixcnt only ifndef NTP.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.11 1996/05/03 07:42:39 niklas Exp $	*/
d132 1
a132 1
long time_precision = 1;	/* clock precision (us) */
d320 3
@


1.11
log
@Make pretty + update $NetBSD$ tag.  No functional change.
@
text
@d1 2
a2 2
/*	$OpenBSD: kern_clock.c,v 1.9 1996/04/21 22:26:53 deraadt Exp $	*/
/*	$NetBSD: kern_clock.c,v 1.33 1996/04/22 01:38:19 christos Exp $	*/
d286 1
d288 1
a288 1
#ifdef NTP
@


1.10
log
@sync syscalls, no sys/cpu.h
@
text
@d2 1
a2 1
/*	$NetBSD: kern_clock.c,v 1.31 1996/03/15 07:56:00 mycroft Exp $	*/
d646 1
a646 2
			delta.tv_usec = clock_ext.tv_usec -
			    newtime.tv_usec;
@


1.9
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.8 1996/04/19 16:08:50 niklas Exp $	*/
a51 1
#include <sys/cpu.h>
@


1.8
log
@NetBSD 960317 merge
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_clock.c,v 1.7 1996/03/03 17:19:41 niklas Exp $	*/
d356 1
d421 2
d481 1
a481 1
	time.tv_usec += clock_cpu;
d484 1
a484 1
	time.tv_usec += time_update;
d499 3
a501 3
	if (time.tv_usec >= 1000000) {
		time.tv_usec -= 1000000;
		time.tv_sec++;
d522 2
a523 2
			if (time.tv_sec % 86400 == 0) {
				time.tv_sec--;
d529 2
a530 2
			if ((time.tv_sec + 1) % 86400 == 0) {
				time.tv_sec++;
d646 1
a646 1
			delta.tv_sec = clock_ext.tv_sec - time.tv_sec;
d648 1
a648 1
			    time.tv_usec;
d663 1
a663 1
				time = clock_ext;
d675 6
@


1.7
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: kern_clock.c,v 1.23 1995/12/28 19:16:41 thorpej Exp $	*/
a43 17
/* Portions of this software are covered by the following: */
/******************************************************************************
 *                                                                            *
 * Copyright (c) David L. Mills 1993, 1994                                    *
 *                                                                            *
 * Permission to use, copy, modify, and distribute this software and its      *
 * documentation for any purpose and without fee is hereby granted, provided  *
 * that the above copyright notice appears in all copies and that both the    *
 * copyright notice and this permission notice appear in supporting           *
 * documentation, and that the name University of Delaware not be used in     *
 * advertising or publicity pertaining to distribution of the software        *
 * without specific, written prior permission.  The University of Delaware    *
 * makes no representations about the suitability this software for any       *
 * purpose.  It is provided "as is" without express or implied warranty.      *
 *                                                                            *
 *****************************************************************************/

a91 23
/*
 * Bump a timeval by a small number of usec's.
 */
#define BUMPTIME(t, usec) { \
	register volatile struct timeval *tp = (t); \
	register long us; \
 \
	tp->tv_usec = us = tp->tv_usec + (usec); \
	if (us >= 1000000) { \
		tp->tv_usec = us - 1000000; \
		tp->tv_sec++; \
	} \
}

int	stathz;
int	profhz;
int	profprocs;
int	ticks;
static int psdiv, pscnt;		/* prof => stat divider */
int	psratio;			/* ratio: prof / stat */

volatile struct	timeval time;
volatile struct	timeval mono_time;
d93 1
d95 1
a95 1
 * Phase-lock loop (PLL) definitions
d106 1
a106 1
 * time_offset is used by the PLL to adjust the system time in small
d122 2
a123 2
 * the kernel once each second to reflect the maximum error
 * bound growth.
d128 1
a129 1
int time_state = TIME_OK;	/* clock state */
d138 1
a138 1
 * The following variables establish the state of the PLL and the
d143 1
a143 2
 * increment, respectively, of the kernel time variable at each tick of
 * the clock.
d151 2
a152 1
 * interrupt and is recomputed at each timer interrupt.
d154 1
a154 1
 * time_reftime is the second's portion of the system time on the last
d159 1
a159 1
static long time_phase = 0;	/* phase offset (scaled us) */
d161 2
a162 2
static long time_adj = 0;	/* tick adjust (scaled 1 / hz) */
static long time_reftime = 0;	/* time at last adjustment (s) */
d166 3
a168 3
 * The following variables are used only if the if the kernel PPS
 * discipline code is configured (PPS_SYNC). The scale factors are
 * defined in the timex.h header file.
d171 3
a173 1
 * microtime().
d176 2
a177 2
 * pps_tf[], while pps_jitter is the dispersion measured by this
 * filter.
d180 2
a181 2
 * filter pps_ff[], while pps_stabil is the dispersion measured by
 * this filter.
a195 3
 * pps_count counts the seconds of the calibration interval, the
 * duration of which is pps_shift in powers of two.
 *
d200 1
d202 2
a203 2
long pps_jitter = MAXTIME;	/* pps time dispersion (jitter) (us) */
long pps_tf[] = {0, 0, 0};	/* pps time offset median filter (us) */
a205 1
long pps_ff[] = {0, 0, 0};	/* frequency offset median filter */
d236 1
d238 1
a238 1
 * hardupdate() - local clock update
d240 18
a257 17
 * This routine is called by ntp_adjtime() to update the local clock
 * phase and frequency. This is used to implement an adaptive-parameter,
 * first-order, type-II phase-lock loop. The code computes new time and
 * frequency offsets each time it is called. The hardclock() routine
 * amortizes these offsets at each tick interrupt. If the kernel PPS
 * discipline code is configured (PPS_SYNC), the PPS signal itself
 * determines the new time offset, instead of the calling argument.
 * Presumably, calls to ntp_adjtime() occur only when the caller
 * believes the local clock is valid within some bound (+-128 ms with
 * NTP). If the caller's time is far different than the PPS time, an
 * argument will ensue, and it's not clear who will lose.
 *
 * For default SHIFT_UPDATE = 12, the offset is limited to +-512 ms, the
 * maximum interval between updates is 4096 s and the maximum frequency
 * offset is +-31.25 ms/s.
 *
 * Note: splclock() is in effect.
d259 5
a263 5
void
hardupdate(offset)
	long offset;
{
	long ltemp, mtemp;
a264 13
	if (!(time_status & STA_PLL) && !(time_status & STA_PPSTIME))
		return;
	ltemp = offset;
#ifdef PPS_SYNC
	if (time_status & STA_PPSTIME && time_status & STA_PPSSIGNAL)
		ltemp = pps_offset;
#endif /* PPS_SYNC */
	if (ltemp > MAXPHASE)
		time_offset = MAXPHASE << SHIFT_UPDATE;
	else if (ltemp < -MAXPHASE)
		time_offset = -(MAXPHASE << SHIFT_UPDATE);
	else
		time_offset = ltemp << SHIFT_UPDATE;
d266 12
a277 33
	/*
	 * Select wether the frequency is to be controlled and in which
	 * mode (PLL or FLL). Clamp to the operating range. Ugly
	 * multiply/divide should be replaced someday.
	 */
	if (time_status * STA_FREQHOLD || time_reftime == 0)
		time_reftime = time.tv_sec;
	mtemp = time.tv_sec - time_reftime;
	time_reftime = time.tv_sec;
	if (time_status & STA_FLL) {
		if (mtemp >= MINSEC) {
			ltemp = ((time_offset / mtemp) << (SHIFT_USEC - SHIFT_UPDATE));
			if (ltemp < 0)
				time_freq -= -ltemp >> SHIFT_KH;
			else
				time_freq += ltemp >> SHIFT_KH;
		}
	}
	else {
		if (mtemp < MAXSEC) {
			ltemp *= mtemp;
			if (ltemp < 0)
				time_freq -= -ltemp >> (time_constant +
					time_constant + SHIFT_KF - SHIFT_USEC);
			else
				time_freq += ltemp >> (time_constant +
					time_constant + SHIFT_KF - SHIFT_USEC);
		}
	}
	if (time_freq > time_tolerance)
		time_freq = time_tolerance;
	else if (time_freq < -time_tolerance)
		time_freq = -time_tolerance;
d280 16
d318 22
d351 7
a357 4
	register int needsoft;
	int time_update;
	struct timeval newtime;
	long ltemp;
d402 6
a407 1
	 * Increment the time-of-day
d410 1
a410 1
	newtime = time;
d412 7
a418 2
	if (timedelta == 0) {
		time_update = tick;
d420 4
a423 2
	else {
		time_update = tick + tickdelta;
d426 12
a437 1
	BUMPTIME(&mono_time, time_update);
d440 3
a442 3
	 * Compute the phase adjustment.  If the low-order bits
	 * (time_phase) of the update overflow, bump the high-order
	 * bits (time_update).
d449 1
a449 2
	}
	else if (time_phase >= FINEUSEC) {
d455 29
a483 1
	newtime.tv_usec += time_update;
d491 8
a498 10
	 * With SHIFT_SCALE = 23, the maximum frequency adjustment is
	 * +-256 us per tick, or 25.6 ms/s at a clock frequency of 100
	 * Hz. The time contribution is shifted right a minimum of two
	 * bits, while the frequency contribution is a right shift.
	 * Thus, overflow is prevented if the frequency contribution is
	 * limited to half the maximum or 15.625 ms/s.
	 */
	if (newtime.tv_usec >= 1000000) {
		newtime.tv_usec -= 1000000;
		newtime.tv_sec++;
d500 51
d556 2
a557 1
				ltemp = (MAXPHASE / MINSEC) << SHIFT_UPDATE;
d559 2
a560 3
			time_adj = -ltemp << (SHIFT_SCALE - SHIFT_HZ - SHIFT_UPDATE);
		}
		else {
d565 2
a566 1
				ltemp = (MAXPHASE / MINSEC) << SHIFT_UPDATE;
d568 4
a571 3
			time_adj = ltemp << (SHIFT_SCALE - SHIFT_HZ - SHIFT_UPDATE);
		}
#ifdef PPS_SYNC
d573 5
a577 2
		 * Gnaw on the watchdog counter and update the frequency
		 * computed by the pll and the PPS signal
d579 1
d585 1
a585 1
					 STA_PPSWANDER | STA_PPSERROR);
d591 1
d593 1
a593 1
			time_adj -= -ltemp >> (SHIFT_USEC + SHIFT_HZ - SHIFT_SCALE);
d595 2
a596 1
			time_adj += ltemp >> (SHIFT_USEC + SHIFT_HZ - SHIFT_SCALE);
a597 1
#if SHIFT_HZ == 7
d600 2
a601 3
		 * power of two in Hz, the SHIFT_HZ is only an
		 * approximate scale factor. In the following code
		 * the overall gain is increased by a factor of 1.25.
d603 8
a610 1
		if (hz == 100) {
d615 14
a629 1
#endif /* SHIFT_HZ */
d631 1
d633 5
a637 7
		 * Leap second processing.  If in leap-insert state at
		 * the end of the day, the system clock is set back one
		 * second; if in leap-delete state, the system clock is
		 * set ahead one second.  The microtime() routine or
		 * external clock driver will insure that reported time
		 * is always monotonic.  The ugly divides should be
		 * replacesd.
d639 16
a654 13
		switch (time_state) {

		case TIME_OK:
			if (time_status & STA_INS)
				time_state = TIME_INS;
			else if (time_status & STA_DEL)
				time_state = TIME_DEL;
			break;

		case TIME_INS:
			if (newtime.tv_sec % 86400 == 0) {
				newtime.tv_sec--;
				time_state = TIME_OOP;
d656 7
a662 6
			break;

		case TIME_DEL:
			if ((newtime.tv_sec + 1) % 86400 == 0) {
				newtime.tv_sec++;
				time_state = TIME_WAIT;
d664 5
a668 10
			break;

		case TIME_OOP:
			time_state = TIME_WAIT;
			break;

		case TIME_WAIT:
			if (!(time_status & (STA_INS | STA_DEL)))
				time_state = TIME_OK;
			break;
d670 1
d672 2
a673 5
#ifdef CPU_CLOCKUPDATE
	CPU_CLOCKUPDATE(&time, &newtime);
#else
	time = newtime;
#endif
d808 1
a808 2
	register unsigned long ticks;
	register long sec, usec;
d812 6
a817 6
	 * If the number of usecs in the whole seconds part of the time
	 * difference fits in a long, then the total number of usecs will
	 * fit in an unsigned long.  Compute the total and convert it to
	 * ticks, rounding up and adding 1 to allow for the current tick
	 * to expire.  Rounding also depends on unsigned long arithmetic
	 * to avoid overflow.
d819 5
a823 11
	 * Otherwise, if the number of ticks in the whole seconds part of
	 * the time difference fits in a long, then convert the parts to
	 * ticks separately and add, using similar rounding methods and
	 * overflow avoidance.  This method would work in the previous
	 * case but it is slightly slower and assumes that hz is integral.
	 *
	 * Otherwise, round the time difference down to the maximum
	 * representable value.
	 *
	 * If ints have 32 bits, then the maximum value for any timeout in
	 * 10ms ticks is 248 days.
d825 1
a825 1
	s = splclock();
d827 7
a833 1
	usec = tv->tv_usec - time.tv_usec;
a834 19
	if (usec < 0) {
		sec--;
		usec += 1000000;
	}
	if (sec < 0) {
#ifdef DIAGNOSTIC
		printf("hzto: negative time difference %ld sec %ld usec\n",
		       sec, usec);
#endif
		ticks = 1;
	}
	else if (sec <= LONG_MAX / 1000000)
		ticks = (sec * 1000000 + (unsigned long)usec + (tick - 1)) / tick + 1;
	else if (sec <= LONG_MAX / hz)
		ticks = sec * hz + ((unsigned long)usec + (tick - 1)) / tick + 1;
	else
		ticks = LONG_MAX;
	if (ticks > INT_MAX)
		ticks = INT_MAX;
d990 334
d1337 2
a1339 1
	clkinfo.tick = tick;
@


1.6
log
@Make it possible for a port to do special time update handling
@
text
@d1 1
d68 4
d923 1
d943 1
d946 1
d948 5
a952 1
void db_show_callout(long addr, int haddr, int count, char *modif)
@


1.5
log
@Implement frequency-locked loop as in original code; was missing
@
text
@d574 3
d578 1
@


1.4
log
@Add kernel PLL for system clock
Add ntp_adjtime() and ntp_gettime() system calls
Mostly stolen from FreeBSD
@
text
@d311 8
d321 20
a340 10
	if (mtemp > MAXSEC)
		mtemp = 0;

	/* ugly multiply should be replaced */
	if (ltemp < 0)
		time_freq -= (-ltemp * mtemp) >> (time_constant +
		    time_constant + SHIFT_KF - SHIFT_USEC);
	else
		time_freq += (ltemp * mtemp) >> (time_constant +
		    time_constant + SHIFT_KF - SHIFT_USEC);
d479 5
a483 1
			ltemp = -time_offset >> (SHIFT_KG + time_constant);
d488 5
a492 1
			ltemp = time_offset >> (SHIFT_KG + time_constant);
d517 1
d530 2
@


1.3
log
@from netbsd:
fix off-by-one error in tickfix code.  (should increment when count >=
interval, because count goes from 0->(interval-1) to count interval
ticks.)
@
text
@d1 1
a1 1
/*	$NetBSD: kern_clock.c,v 1.24 1996/01/17 04:37:31 cgd Exp $	*/
d43 17
d67 1
a123 2
int	tickfix, tickfixinterval;	/* used if tick not really integral */
static int tickfixcnt;			/* number of ticks since last fix */
d129 201
d362 4
a365 3
	register int delta, needsoft;
	extern int tickdelta;
	extern long timedelta;
d410 1
a410 6
	 * Increment the time-of-day.  The increment is normally just
	 * ``tick''.  If the machine is one which has a clock frequency
	 * such that ``hz'' would not divide the second evenly into
	 * milliseconds, a periodic adjustment must be applied.  Finally,
	 * if we are still adjusting the time (see adjtime()),
	 * ``tickdelta'' may also be added in.
d413 4
a416 7
	delta = tick;
	if (tickfix) {
		tickfixcnt++;
		if (tickfixcnt >= tickfixinterval) {
			delta += tickfix;
			tickfixcnt = 0;
		}
d418 2
a419 2
	if (timedelta != 0) {
		delta = tick + tickdelta;
d422 124
a545 2
	BUMPTIME(&time, delta);
	BUMPTIME(&mono_time, delta);
d680 2
a681 1
	register long ticks, sec;
d685 6
a690 6
	 * If number of microseconds will fit in 32 bit arithmetic,
	 * then compute number of microseconds to time and scale to
	 * ticks.  Otherwise just compute number of hz in time, rounding
	 * times greater than representible to maximum value.  (We must
	 * compute in microseconds, because hz can be greater than 1000,
	 * and thus tick can be less than one millisecond).
d692 11
a702 5
	 * Delta times less than 14 hours can be computed ``exactly''.
	 * (Note that if hz would yeild a non-integral number of us per
	 * tick, i.e. tickfix is nonzero, timouts can be a tick longer
	 * than they should be.)  Maximum value for any timeout in 10ms
	 * ticks is 250 days.
d704 1
a704 1
	s = splhigh();
d706 17
a722 5
	if (sec <= 0x7fffffff / 1000000 - 1)
		ticks = ((tv->tv_sec - time.tv_sec) * 1000000 +
			(tv->tv_usec - time.tv_usec)) / tick;
	else if (sec <= 0x7fffffff / hz)
		ticks = sec * hz;
d724 3
a726 2
		ticks = 0x7fffffff;
	splx(s);
d894 1
a895 2
	clkinfo.tickadj = tickadj;
	clkinfo.hz = hz;
@


1.2
log
@from netbsd:
Move the old-style disk instrumentation "structures" to a central
location (sys/kern/subr_disk.c) and note that they should/will be
deprecated.
@
text
@d1 1
a1 1
/*	$NetBSD: kern_clock.c,v 1.23 1995/12/28 19:16:41 thorpej Exp $	*/
d203 1
a203 1
		if (tickfixcnt > tickfixinterval) {
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: kern_clock.c,v 1.22 1995/03/03 01:24:03 cgd Exp $	*/
a420 2
int	dk_ndrive = DK_NDRIVE;

d492 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
