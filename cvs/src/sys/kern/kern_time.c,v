head	1.99;
access;
symbols
	OPENBSD_6_2_BASE:1.99
	OPENBSD_6_1:1.99.0.4
	OPENBSD_6_1_BASE:1.99
	OPENBSD_6_0:1.97.0.2
	OPENBSD_6_0_BASE:1.97
	OPENBSD_5_9:1.96.0.2
	OPENBSD_5_9_BASE:1.96
	OPENBSD_5_8:1.91.0.4
	OPENBSD_5_8_BASE:1.91
	OPENBSD_5_7:1.89.0.2
	OPENBSD_5_7_BASE:1.89
	OPENBSD_5_6:1.88.0.4
	OPENBSD_5_6_BASE:1.88
	OPENBSD_5_5:1.87.0.4
	OPENBSD_5_5_BASE:1.87
	OPENBSD_5_4:1.80.0.2
	OPENBSD_5_4_BASE:1.80
	OPENBSD_5_3:1.76.0.2
	OPENBSD_5_3_BASE:1.76
	OPENBSD_5_2:1.75.0.2
	OPENBSD_5_2_BASE:1.75
	OPENBSD_5_1_BASE:1.71
	OPENBSD_5_1:1.71.0.8
	OPENBSD_5_0:1.71.0.6
	OPENBSD_5_0_BASE:1.71
	OPENBSD_4_9:1.71.0.4
	OPENBSD_4_9_BASE:1.71
	OPENBSD_4_8:1.71.0.2
	OPENBSD_4_8_BASE:1.71
	OPENBSD_4_7:1.68.0.2
	OPENBSD_4_7_BASE:1.68
	OPENBSD_4_6:1.66.0.4
	OPENBSD_4_6_BASE:1.66
	OPENBSD_4_5:1.65.0.2
	OPENBSD_4_5_BASE:1.65
	OPENBSD_4_4:1.64.0.2
	OPENBSD_4_4_BASE:1.64
	OPENBSD_4_3:1.63.0.2
	OPENBSD_4_3_BASE:1.63
	OPENBSD_4_2:1.62.0.2
	OPENBSD_4_2_BASE:1.62
	OPENBSD_4_1:1.61.0.2
	OPENBSD_4_1_BASE:1.61
	OPENBSD_4_0:1.59.0.2
	OPENBSD_4_0_BASE:1.59
	OPENBSD_3_9:1.54.0.2
	OPENBSD_3_9_BASE:1.54
	OPENBSD_3_8:1.48.0.2
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.45.0.4
	OPENBSD_3_7_BASE:1.45
	OPENBSD_3_6:1.45.0.2
	OPENBSD_3_6_BASE:1.45
	SMP_SYNC_A:1.40
	SMP_SYNC_B:1.40
	OPENBSD_3_5:1.39.0.2
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.38.0.2
	OPENBSD_3_4_BASE:1.38
	UBC_SYNC_A:1.32
	OPENBSD_3_3:1.32.0.4
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.29.0.2
	OPENBSD_3_1_BASE:1.29
	UBC_SYNC_B:1.32
	UBC:1.25.0.2
	UBC_BASE:1.25
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.4
	OPENBSD_2_8:1.23.0.2
	OPENBSD_2_8_BASE:1.23
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	SMP:1.16.0.2
	SMP_BASE:1.16
	kame_19991208:1.15
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.12.0.6
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.99
date	2017.01.24.00.58.55;	author mpi;	state Exp;
branches;
next	1.98;
commitid	r0ks7yUPmANG37rA;

1.98
date	2016.09.03.14.46.56;	author naddy;	state Exp;
branches;
next	1.97;
commitid	RpNaiU9Lz1B3rhqT;

1.97
date	2016.04.28.20.11.20;	author tedu;	state Exp;
branches;
next	1.96;
commitid	TqX35mEopXEKII9i;

1.96
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.95;
commitid	Cl55DD2g2xm69E6W;

1.95
date	2015.11.01.19.03.33;	author semarie;	state Exp;
branches;
next	1.94;
commitid	VKRkUfXZQNJ8UQeY;

1.94
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.93;
commitid	av6ZVErLSWkVP5Zz;

1.93
date	2015.09.11.08.22.31;	author guenther;	state Exp;
branches;
next	1.92;
commitid	Lqreadw8v5IPAc0L;

1.92
date	2015.08.22.20.18.49;	author deraadt;	state Exp;
branches;
next	1.91;
commitid	6NDuzTPjBp2GqkfQ;

1.91
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	1.90;
commitid	CJwjm9NDWu6nJ6ES;

1.90
date	2015.04.28.20.54.18;	author kettenis;	state Exp;
branches;
next	1.89;
commitid	7CnQnfSEWLVJajgr;

1.89
date	2014.12.07.02.58.14;	author deraadt;	state Exp;
branches;
next	1.88;
commitid	g65vZ4MmOYKW0eLb;

1.88
date	2014.05.15.04.36.33;	author guenther;	state Exp;
branches;
next	1.87;

1.87
date	2014.01.30.21.01.59;	author kettenis;	state Exp;
branches;
next	1.86;

1.86
date	2014.01.22.00.48.36;	author guenther;	state Exp;
branches;
next	1.85;

1.85
date	2013.10.25.04.42.48;	author guenther;	state Exp;
branches;
next	1.84;

1.84
date	2013.10.08.03.50.08;	author guenther;	state Exp;
branches;
next	1.83;

1.83
date	2013.10.06.01.27.50;	author guenther;	state Exp;
branches;
next	1.82;

1.82
date	2013.09.14.01.35.01;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2013.08.13.05.52.23;	author guenther;	state Exp;
branches;
next	1.80;

1.80
date	2013.06.17.19.11.54;	author guenther;	state Exp;
branches;
next	1.79;

1.79
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.78;

1.78
date	2013.06.02.20.59.09;	author guenther;	state Exp;
branches;
next	1.77;

1.77
date	2013.03.28.16.55.25;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2012.11.05.19.39.35;	author miod;	state Exp;
branches;
next	1.75;

1.75
date	2012.05.24.07.17.42;	author guenther;	state Exp;
branches;
next	1.74;

1.74
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.73;

1.73
date	2012.03.19.09.05.39;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2012.03.10.05.54.28;	author guenther;	state Exp;
branches;
next	1.71;

1.71
date	2010.06.30.01.47.35;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2010.06.28.21.23.20;	author art;	state Exp;
branches;
next	1.69;

1.69
date	2010.04.04.03.47.02;	author guenther;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.27.19.45.53;	author guenther;	state Exp;
branches;
next	1.67;

1.67
date	2009.10.16.19.29.41;	author martynas;	state Exp;
branches;
next	1.66;

1.66
date	2009.06.05.15.17.02;	author ckuethe;	state Exp;
branches;
next	1.65;

1.65
date	2008.09.19.23.36.24;	author djm;	state Exp;
branches;
next	1.64;

1.64
date	2008.04.04.22.48.02;	author dlg;	state Exp;
branches;
next	1.63;

1.63
date	2008.01.02.17.57.49;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2007.04.04.17.32.20;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2007.01.10.07.58.08;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2006.10.30.20.19.33;	author otto;	state Exp;
branches;
next	1.59;

1.59
date	2006.06.29.19.52.47;	author kettenis;	state Exp;
branches;
next	1.58;

1.58
date	2006.06.27.10.41.27;	author otto;	state Exp;
branches;
next	1.57;

1.57
date	2006.06.15.15.17.52;	author jsg;	state Exp;
branches;
next	1.56;

1.56
date	2006.06.14.19.52.07;	author otto;	state Exp;
branches;
next	1.55;

1.55
date	2006.06.04.18.47.33;	author otto;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.20.07.53.48;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2006.01.13.22.02.37;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2005.11.28.00.14.29;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2005.10.27.14.57.12;	author markus;	state Exp;
branches;
next	1.50;

1.50
date	2005.10.13.18.17.15;	author aaron;	state Exp;
branches;
next	1.49;

1.49
date	2005.10.10.07.23.02;	author otto;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.31.11.32.47;	author art;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2005.05.29.03.20.41;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.45;

1.45
date	2004.07.28.17.15.12;	author tholo;	state Exp;
branches
	1.45.4.1;
next	1.44;

1.44
date	2004.06.26.05.52.20;	author nordin;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.09.20.18.28;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.15.02.34.14;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2003.09.01.18.06.03;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2003.08.26.02.15.13;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2003.08.11.05.38.05;	author kevlo;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.19.07.24.08;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2002.10.02.17.43.38;	author nordin;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.25.22.18.27;	author nordin;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.11.06.07.45;	author nordin;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2002.02.17.06.11.05;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2002.02.15.18.51.20;	author pvalchev;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.15.15.59.11;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.12.19.06.47;	author nordin;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.06.25.03.28.03;	author csapuntz;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2000.10.10.13.36.49;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.07.15.19.04;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.06.15.33.31;	author ho;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.05.08.10.57;	author pjanzen;	state Exp;
branches;
next	1.19;

1.19
date	2000.03.23.16.54.44;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.23.15.55.52;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.17.22.24.26;	author jakob;	state Exp;
branches;
next	1.16;

1.16
date	2000.01.22.23.41.42;	author millert;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	99.12.06.19.36.42;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	99.06.06.19.21.34;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.06.06.19.15.03;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.02.20.14.51.56;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	98.02.08.22.41.35;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	97.10.17.04.41.10;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	97.04.28.01.33.47;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.04.26.10.38.30;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	97.04.23.09.52.03;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	97.04.20.20.49.42;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	97.03.16.01.18.48;	author flipk;	state Exp;
branches;
next	1.4;

1.4
date	97.02.22.08.28.28;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.03.31.13.15.23;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.19.57;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches;
next	;

1.16.2.1
date	2000.03.24.09.09.25;	author niklas;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.05.14.22.32.42;	author niklas;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2001.07.04.10.48.29;	author niklas;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.16.2.7;

1.16.2.7
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.16.2.8;

1.16.2.8
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.16.2.9;

1.16.2.9
date	2004.06.05.17.19.55;	author niklas;	state Exp;
branches;
next	1.16.2.10;

1.16.2.10
date	2004.06.05.23.13.01;	author niklas;	state Exp;
branches;
next	1.16.2.11;

1.16.2.11
date	2004.06.08.20.17.39;	author art;	state Exp;
branches;
next	1.16.2.12;

1.16.2.12
date	2004.06.10.11.40.33;	author niklas;	state Exp;
branches;
next	;

1.24.2.1
date	2002.10.07.20.54.54;	author miod;	state Exp;
branches;
next	;

1.25.2.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	;

1.29.2.1
date	2002.10.02.20.27.29;	author jason;	state Exp;
branches;
next	;

1.45.4.1
date	2005.10.20.02.10.21;	author brad;	state Exp;
branches;
next	;

1.48.2.1
date	2005.11.01.00.59.07;	author brad;	state Exp;
branches;
next	;


desc
@@


1.99
log
@Rename pfind(9) into tfind(9) to reflect that it deals with threads.

While here document prfind(9.

with and ok guenther@@
@
text
@/*	$OpenBSD: kern_time.c,v 1.98 2016/09/03 14:46:56 naddy Exp $	*/
/*	$NetBSD: kern_time.c,v 1.20 1996/02/18 11:57:06 fvdl Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_time.c	8.4 (Berkeley) 5/26/95
 */

#include <sys/param.h>
#include <sys/resourcevar.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/ktrace.h>
#include <sys/vnode.h>
#include <sys/signalvar.h>
#include <sys/pledge.h>
#include <sys/task.h>
#include <sys/timeout.h>
#include <sys/timetc.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>


int64_t adjtimedelta;		/* unapplied time correction (microseconds) */

/* 
 * Time of day and interval timer support.
 *
 * These routines provide the kernel entry points to get and set
 * the time-of-day and per-process interval timers.  Subroutines
 * here provide support for adding and subtracting timeval structures
 * and decrementing interval timers, optionally reloading the interval
 * timers when they expire.
 */

/* This function is used by clock_settime and settimeofday */
int
settime(struct timespec *ts)
{
	struct timespec now;

	/*
	 * Adjtime in progress is meaningless or harmful after
	 * setting the clock. Cancel adjtime and then set new time.
	 */
	adjtimedelta = 0;

	/*
	 * Don't allow the time to be set forward so far it will wrap
	 * and become negative, thus allowing an attacker to bypass
	 * the next check below.  The cutoff is 1 year before rollover
	 * occurs, so even if the attacker uses adjtime(2) to move
	 * the time past the cutoff, it will take a very long time
	 * to get to the wrap point.
	 *
	 * XXX: we check against UINT_MAX until we can figure out
	 *	how to deal with the hardware RTCs.
	 */
	if (ts->tv_sec > UINT_MAX - 365*24*60*60) {
		printf("denied attempt to set clock forward to %lld\n",
		    (long long)ts->tv_sec);
		return (EPERM);
	}
	/*
	 * If the system is secure, we do not allow the time to be
	 * set to an earlier value (it may be slowed using adjtime,
	 * but not set back). This feature prevent interlopers from
	 * setting arbitrary time stamps on files.
	 */
	nanotime(&now);
	if (securelevel > 1 && timespeccmp(ts, &now, <)) {
		printf("denied attempt to set clock back %lld seconds\n",
		    (long long)now.tv_sec - ts->tv_sec);
		return (EPERM);
	}

	tc_setrealtimeclock(ts);
	resettodr();

	return (0);
}

int
clock_gettime(struct proc *p, clockid_t clock_id, struct timespec *tp)
{
	struct bintime bt;
	struct proc *q;

	switch (clock_id) {
	case CLOCK_REALTIME:
		nanotime(tp);
		break;
	case CLOCK_UPTIME:
		binuptime(&bt);
		bintime_sub(&bt, &naptime);
		bintime2timespec(&bt, tp);
		break;
	case CLOCK_MONOTONIC:
		nanouptime(tp);
		break;
	case CLOCK_PROCESS_CPUTIME_ID:
		nanouptime(tp);
		timespecsub(tp, &curcpu()->ci_schedstate.spc_runtime, tp);
		timespecadd(tp, &p->p_p->ps_tu.tu_runtime, tp);
		timespecadd(tp, &p->p_rtime, tp);
		break;
	case CLOCK_THREAD_CPUTIME_ID:
		nanouptime(tp);
		timespecsub(tp, &curcpu()->ci_schedstate.spc_runtime, tp);
		timespecadd(tp, &p->p_tu.tu_runtime, tp);
		timespecadd(tp, &p->p_rtime, tp);
		break;
	default:
		/* check for clock from pthread_getcpuclockid() */
		if (__CLOCK_TYPE(clock_id) == CLOCK_THREAD_CPUTIME_ID) {
			q = tfind(__CLOCK_PTID(clock_id) - THREAD_PID_OFFSET);
			if (q == NULL || q->p_p != p->p_p)
				return (ESRCH);
			*tp = q->p_tu.tu_runtime;
		} else
			return (EINVAL);
	}
	return (0);
}

int
sys_clock_gettime(struct proc *p, void *v, register_t *retval)
{
	struct sys_clock_gettime_args /* {
		syscallarg(clockid_t) clock_id;
		syscallarg(struct timespec *) tp;
	} */ *uap = v;
	struct timespec ats;
	int error;

	memset(&ats, 0, sizeof(ats));
	if ((error = clock_gettime(p, SCARG(uap, clock_id), &ats)) != 0)
		return (error);

	error = copyout(&ats, SCARG(uap, tp), sizeof(ats));
#ifdef KTRACE
	if (error == 0 && KTRPOINT(p, KTR_STRUCT)) {
		KERNEL_LOCK();
		ktrabstimespec(p, &ats);
		KERNEL_UNLOCK();
	}
#endif
	return (error);
}

int
sys_clock_settime(struct proc *p, void *v, register_t *retval)
{
	struct sys_clock_settime_args /* {
		syscallarg(clockid_t) clock_id;
		syscallarg(const struct timespec *) tp;
	} */ *uap = v;
	struct timespec ats;
	clockid_t clock_id;
	int error;

	if ((error = suser(p, 0)) != 0)
		return (error);

	if ((error = copyin(SCARG(uap, tp), &ats, sizeof(ats))) != 0)
		return (error);

	clock_id = SCARG(uap, clock_id);
	switch (clock_id) {
	case CLOCK_REALTIME:
		if ((error = settime(&ats)) != 0)
			return (error);
		break;
	default:	/* Other clocks are read-only */
		return (EINVAL);
	}

	return (0);
}

int
sys_clock_getres(struct proc *p, void *v, register_t *retval)
{
	struct sys_clock_getres_args /* {
		syscallarg(clockid_t) clock_id;
		syscallarg(struct timespec *) tp;
	} */ *uap = v;
	clockid_t clock_id;
	struct timespec ts;
	struct proc *q;
	int error = 0;

	memset(&ts, 0, sizeof(ts));
	clock_id = SCARG(uap, clock_id);
	switch (clock_id) {
	case CLOCK_REALTIME:
	case CLOCK_MONOTONIC:
	case CLOCK_UPTIME:
	case CLOCK_PROCESS_CPUTIME_ID:
	case CLOCK_THREAD_CPUTIME_ID:
		ts.tv_sec = 0;
		ts.tv_nsec = 1000000000 / hz;
		break;
	default:
		/* check for clock from pthread_getcpuclockid() */
		if (__CLOCK_TYPE(clock_id) == CLOCK_THREAD_CPUTIME_ID) {
			q = tfind(__CLOCK_PTID(clock_id) - THREAD_PID_OFFSET);
			if (q == NULL || q->p_p != p->p_p)
				return (ESRCH);
			ts.tv_sec = 0;
			ts.tv_nsec = 1000000000 / hz;
		} else
			return (EINVAL);
	}

	if (SCARG(uap, tp)) {
		error = copyout(&ts, SCARG(uap, tp), sizeof (ts));
#ifdef KTRACE
		if (error == 0 && KTRPOINT(p, KTR_STRUCT)) {
			KERNEL_LOCK();
			ktrreltimespec(p, &ts);
			KERNEL_UNLOCK();
		}
#endif
	}

	return error;
}

int
sys_nanosleep(struct proc *p, void *v, register_t *retval)
{
	static int nanowait;
	struct sys_nanosleep_args/* {
		syscallarg(const struct timespec *) rqtp;
		syscallarg(struct timespec *) rmtp;
	} */ *uap = v;
	struct timespec rqt, rmt;
	struct timespec sts, ets;
	struct timespec *rmtp;
	struct timeval tv;
	int error, error1;

	rmtp = SCARG(uap, rmtp);
	error = copyin(SCARG(uap, rqtp), &rqt, sizeof(struct timespec));
	if (error)
		return (error);
#ifdef KTRACE
        if (KTRPOINT(p, KTR_STRUCT)) {
		KERNEL_LOCK();
		ktrreltimespec(p, &rqt);
		KERNEL_UNLOCK();
	}
#endif

	TIMESPEC_TO_TIMEVAL(&tv, &rqt);
	if (itimerfix(&tv))
		return (EINVAL);

	if (rmtp)
		getnanouptime(&sts);

	error = tsleep(&nanowait, PWAIT | PCATCH, "nanosleep",
	    MAX(1, tvtohz(&tv)));
	if (error == ERESTART)
		error = EINTR;
	if (error == EWOULDBLOCK)
		error = 0;

	if (rmtp) {
		getnanouptime(&ets);

		memset(&rmt, 0, sizeof(rmt));
		timespecsub(&ets, &sts, &sts);
		timespecsub(&rqt, &sts, &rmt);

		if (rmt.tv_sec < 0)
			timespecclear(&rmt);

		error1 = copyout(&rmt, rmtp, sizeof(rmt));
		if (error1 != 0)
			error = error1;
#ifdef KTRACE
		if (error1 == 0 && KTRPOINT(p, KTR_STRUCT)) {
			KERNEL_LOCK();
			ktrreltimespec(p, &rmt);
			KERNEL_UNLOCK();
		}
#endif
	}

	return error;
}

int
sys_gettimeofday(struct proc *p, void *v, register_t *retval)
{
	struct sys_gettimeofday_args /* {
		syscallarg(struct timeval *) tp;
		syscallarg(struct timezone *) tzp;
	} */ *uap = v;
	struct timeval atv;
	struct timeval *tp;
	struct timezone *tzp;
	int error = 0;

	tp = SCARG(uap, tp);
	tzp = SCARG(uap, tzp);

	if (tp) {
		memset(&atv, 0, sizeof(atv));
		microtime(&atv);
		if ((error = copyout(&atv, tp, sizeof (atv))))
			return (error);
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT)) {
			KERNEL_LOCK();
			ktrabstimeval(p, &atv);
			KERNEL_UNLOCK();
		}
#endif
	}
	if (tzp)
		error = copyout(&tz, tzp, sizeof (tz));
	return (error);
}

int
sys_settimeofday(struct proc *p, void *v, register_t *retval)
{
	struct sys_settimeofday_args /* {
		syscallarg(const struct timeval *) tv;
		syscallarg(const struct timezone *) tzp;
	} */ *uap = v;
	struct timezone atz;
	struct timeval atv;
	const struct timeval *tv;
	const struct timezone *tzp;
	int error;

	tv = SCARG(uap, tv);
	tzp = SCARG(uap, tzp);

	if ((error = suser(p, 0)))
		return (error);
	/* Verify all parameters before changing time. */
	if (tv && (error = copyin(tv, &atv, sizeof(atv))))
		return (error);
	if (tzp && (error = copyin(tzp, &atz, sizeof(atz))))
		return (error);
	if (tv) {
		struct timespec ts;

		TIMEVAL_TO_TIMESPEC(&atv, &ts);
		if ((error = settime(&ts)) != 0)
			return (error);
	}
	if (tzp)
		tz = atz;
	return (0);
}

int
sys_adjfreq(struct proc *p, void *v, register_t *retval)
{
	struct sys_adjfreq_args /* {
		syscallarg(const int64_t *) freq;
		syscallarg(int64_t *) oldfreq;
	} */ *uap = v;
	int error;
	int64_t f;
	const int64_t *freq = SCARG(uap, freq);
	int64_t *oldfreq = SCARG(uap, oldfreq);
	if (oldfreq) {
		if ((error = tc_adjfreq(&f, NULL)))
			return (error);
		if ((error = copyout(&f, oldfreq, sizeof(f))))
			return (error);
	}
	if (freq) {
		if ((error = suser(p, 0)))
			return (error);
		if ((error = copyin(freq, &f, sizeof(f))))
			return (error);
		if ((error = tc_adjfreq(NULL, &f)))
			return (error);
	}
	return (0);
}

int
sys_adjtime(struct proc *p, void *v, register_t *retval)
{
	struct sys_adjtime_args /* {
		syscallarg(const struct timeval *) delta;
		syscallarg(struct timeval *) olddelta;
	} */ *uap = v;
	const struct timeval *delta = SCARG(uap, delta);
	struct timeval *olddelta = SCARG(uap, olddelta);
	struct timeval atv;
	int error;

	error = pledge_adjtime(p, delta);
	if (error)
		return error;

	if (olddelta) {
		memset(&atv, 0, sizeof(atv));
		atv.tv_sec = adjtimedelta / 1000000;
		atv.tv_usec = adjtimedelta % 1000000;
		if (atv.tv_usec < 0) {
			atv.tv_usec += 1000000;
			atv.tv_sec--;
		}

		if ((error = copyout(&atv, olddelta, sizeof(struct timeval))))
			return (error);
	}

	if (delta) {
		if ((error = suser(p, 0)))
			return (error);

		if ((error = copyin(delta, &atv, sizeof(struct timeval))))
			return (error);

		/* XXX Check for overflow? */
		adjtimedelta = (int64_t)atv.tv_sec * 1000000 + atv.tv_usec;
	}

	return (0);
}


struct mutex itimer_mtx = MUTEX_INITIALIZER(IPL_CLOCK);

/*
 * Get value of an interval timer.  The process virtual and
 * profiling virtual time timers are kept internally in the
 * way they are specified externally: in time until they expire.
 *
 * The real time interval timer's it_value, in contrast, is kept as an 
 * absolute time rather than as a delta, so that it is easy to keep
 * periodic real-time signals from drifting.
 *
 * Virtual time timers are processed in the hardclock() routine of
 * kern_clock.c.  The real time timer is processed by a timeout
 * routine, called from the softclock() routine.  Since a callout
 * may be delayed in real time due to interrupt processing in the system,
 * it is possible for the real time timeout routine (realitexpire, given below),
 * to be delayed in real time past when it is supposed to occur.  It
 * does not suffice, therefore, to reload the real timer .it_value from the
 * real time timers .it_interval.  Rather, we compute the next time in
 * absolute time the timer should go off.
 */
int
sys_getitimer(struct proc *p, void *v, register_t *retval)
{
	struct sys_getitimer_args /* {
		syscallarg(int) which;
		syscallarg(struct itimerval *) itv;
	} */ *uap = v;
	struct itimerval aitv;
	int which;

	which = SCARG(uap, which);

	if (which < ITIMER_REAL || which > ITIMER_PROF)
		return (EINVAL);
	memset(&aitv, 0, sizeof(aitv));
	mtx_enter(&itimer_mtx);
	aitv.it_interval.tv_sec  = p->p_p->ps_timer[which].it_interval.tv_sec;
	aitv.it_interval.tv_usec = p->p_p->ps_timer[which].it_interval.tv_usec;
	aitv.it_value.tv_sec     = p->p_p->ps_timer[which].it_value.tv_sec;
	aitv.it_value.tv_usec    = p->p_p->ps_timer[which].it_value.tv_usec;
	mtx_leave(&itimer_mtx);

	if (which == ITIMER_REAL) {
		struct timeval now;

		getmicrouptime(&now);
		/*
		 * Convert from absolute to relative time in .it_value
		 * part of real time timer.  If time for real time timer
		 * has passed return 0, else return difference between
		 * current time and time for the timer to go off.
		 */
		if (timerisset(&aitv.it_value)) {
			if (timercmp(&aitv.it_value, &now, <))
				timerclear(&aitv.it_value);
			else
				timersub(&aitv.it_value, &now,
				    &aitv.it_value);
		}
	}

	return (copyout(&aitv, SCARG(uap, itv), sizeof (struct itimerval)));
}

int
sys_setitimer(struct proc *p, void *v, register_t *retval)
{
	struct sys_setitimer_args /* {
		syscallarg(int) which;
		syscallarg(const struct itimerval *) itv;
		syscallarg(struct itimerval *) oitv;
	} */ *uap = v;
	struct sys_getitimer_args getargs;
	struct itimerval aitv;
	const struct itimerval *itvp;
	struct itimerval *oitv;
	struct process *pr = p->p_p;
	int error;
	int timo;
	int which;

	which = SCARG(uap, which);
	oitv = SCARG(uap, oitv);

	if (which < ITIMER_REAL || which > ITIMER_PROF)
		return (EINVAL);
	itvp = SCARG(uap, itv);
	if (itvp && (error = copyin((void *)itvp, (void *)&aitv,
	    sizeof(struct itimerval))))
		return (error);
	if (oitv != NULL) {
		SCARG(&getargs, which) = which;
		SCARG(&getargs, itv) = oitv;
		if ((error = sys_getitimer(p, &getargs, retval)))
			return (error);
	}
	if (itvp == 0)
		return (0);
	if (itimerfix(&aitv.it_value) || itimerfix(&aitv.it_interval))
		return (EINVAL);
	if (which == ITIMER_REAL) {
		struct timeval ctv;

		timeout_del(&pr->ps_realit_to);
		getmicrouptime(&ctv);
		if (timerisset(&aitv.it_value)) {
			timo = tvtohz(&aitv.it_value);
			timeout_add(&pr->ps_realit_to, timo);
			timeradd(&aitv.it_value, &ctv, &aitv.it_value);
		}
		pr->ps_timer[ITIMER_REAL] = aitv;
	} else {
		itimerround(&aitv.it_interval);
		mtx_enter(&itimer_mtx);
		pr->ps_timer[which] = aitv;
		mtx_leave(&itimer_mtx);
	}

	return (0);
}

/*
 * Real interval timer expired:
 * send process whose timer expired an alarm signal.
 * If time is not set up to reload, then just return.
 * Else compute next time timer should go off which is > current time.
 * This is where delay in processing this timeout causes multiple
 * SIGALRM calls to be compressed into one.
 */
void
realitexpire(void *arg)
{
	struct process *pr = arg;
	struct itimerval *tp = &pr->ps_timer[ITIMER_REAL];

	prsignal(pr, SIGALRM);
	if (!timerisset(&tp->it_interval)) {
		timerclear(&tp->it_value);
		return;
	}
	for (;;) {
		struct timeval ctv, ntv;
		int timo;

		timeradd(&tp->it_value, &tp->it_interval, &tp->it_value);
		getmicrouptime(&ctv);
		if (timercmp(&tp->it_value, &ctv, >)) {
			ntv = tp->it_value;
			timersub(&ntv, &ctv, &ntv);
			timo = tvtohz(&ntv) - 1;
			if (timo <= 0)
				timo = 1;
			if ((pr->ps_flags & PS_EXITING) == 0)
				timeout_add(&pr->ps_realit_to, timo);
			return;
		}
	}
}

/*
 * Check that a timespec value is legit
 */
int
timespecfix(struct timespec *ts)
{
	if (ts->tv_sec < 0 ||
	    ts->tv_nsec < 0 || ts->tv_nsec >= 1000000000)
		return (EINVAL);
	if (ts->tv_sec > 100000000)
		ts->tv_sec = 100000000;
	return (0);
}

/*
 * Check that a proposed value to load into the .it_value or
 * .it_interval part of an interval timer is acceptable.
 */
int
itimerfix(struct timeval *tv)
{

	if (tv->tv_sec < 0 || tv->tv_sec > 100000000 ||
	    tv->tv_usec < 0 || tv->tv_usec >= 1000000)
		return (EINVAL);

	if (tv->tv_sec == 0 && tv->tv_usec != 0 && tv->tv_usec < tick)
		tv->tv_usec = tick;

	return (0);
}

/*
 * Nonzero timer interval smaller than the resolution of the
 * system clock are rounded up.
 */
void
itimerround(struct timeval *tv)
{
	if (tv->tv_sec == 0 && tv->tv_usec != 0 && tv->tv_usec < tick)
		tv->tv_usec = tick;
}

/*
 * Decrement an interval timer by a specified number
 * of microseconds, which must be less than a second,
 * i.e. < 1000000.  If the timer expires, then reload
 * it.  In this case, carry over (usec - old value) to
 * reduce the value reloaded into the timer so that
 * the timer does not drift.  This routine assumes
 * that it is called in a context where the timers
 * on which it is operating cannot change in value.
 */
int
itimerdecr(struct itimerval *itp, int usec)
{
	mtx_enter(&itimer_mtx);
	if (itp->it_value.tv_usec < usec) {
		if (itp->it_value.tv_sec == 0) {
			/* expired, and already in next interval */
			usec -= itp->it_value.tv_usec;
			goto expire;
		}
		itp->it_value.tv_usec += 1000000;
		itp->it_value.tv_sec--;
	}
	itp->it_value.tv_usec -= usec;
	usec = 0;
	if (timerisset(&itp->it_value)) {
		mtx_leave(&itimer_mtx);
		return (1);
	}
	/* expired, exactly at end of interval */
expire:
	if (timerisset(&itp->it_interval)) {
		itp->it_value = itp->it_interval;
		itp->it_value.tv_usec -= usec;
		if (itp->it_value.tv_usec < 0) {
			itp->it_value.tv_usec += 1000000;
			itp->it_value.tv_sec--;
		}
	} else
		itp->it_value.tv_usec = 0;		/* sec is already 0 */
	mtx_leave(&itimer_mtx);
	return (0);
}

/*
 * ratecheck(): simple time-based rate-limit checking.  see ratecheck(9)
 * for usage and rationale.
 */
int
ratecheck(struct timeval *lasttime, const struct timeval *mininterval)
{
	struct timeval tv, delta;
	int rv = 0;

	getmicrouptime(&tv);

	timersub(&tv, lasttime, &delta);

	/*
	 * check for 0,0 is so that the message will be seen at least once,
	 * even if interval is huge.
	 */
	if (timercmp(&delta, mininterval, >=) ||
	    (lasttime->tv_sec == 0 && lasttime->tv_usec == 0)) {
		*lasttime = tv;
		rv = 1;
	}

	return (rv);
}

/*
 * ppsratecheck(): packets (or events) per second limitation.
 */
int
ppsratecheck(struct timeval *lasttime, int *curpps, int maxpps)
{
	struct timeval tv, delta;
	int rv;

	microuptime(&tv);

	timersub(&tv, lasttime, &delta);

	/*
	 * check for 0,0 is so that the message will be seen at least once.
	 * if more than one second have passed since the last update of
	 * lasttime, reset the counter.
	 *
	 * we do increment *curpps even in *curpps < maxpps case, as some may
	 * try to use *curpps for stat purposes as well.
	 */
	if (maxpps == 0)
		rv = 0;
	else if ((lasttime->tv_sec == 0 && lasttime->tv_usec == 0) ||
	    delta.tv_sec >= 1) {
		*lasttime = tv;
		*curpps = 0;
		rv = 1;
	} else if (maxpps < 0)
		rv = 1;
	else if (*curpps < maxpps)
		rv = 1;
	else
		rv = 0;

#if 1 /*DIAGNOSTIC?*/
	/* be careful about wrap-around */
	if (*curpps + 1 > *curpps)
		*curpps = *curpps + 1;
#else
	/*
	 * assume that there's not too many calls to this function.
	 * not sure if the assumption holds, as it depends on *caller's*
	 * behavior, not the behavior of this function.
	 * IMHO it is wrong to make assumption on the caller's behavior,
	 * so the above #if is #if 1, not #ifdef DIAGNOSTIC.
	 */
	*curpps = *curpps + 1;
#endif

	return (rv);
}


#define RESETTODR_PERIOD	1800

void periodic_resettodr(void *);
void perform_resettodr(void *);

struct timeout resettodr_to = TIMEOUT_INITIALIZER(periodic_resettodr, NULL);
struct task resettodr_task = TASK_INITIALIZER(perform_resettodr, NULL);

void
periodic_resettodr(void *arg __unused)
{
	task_add(systq, &resettodr_task);
}

void
perform_resettodr(void *arg __unused)
{
	resettodr();
	timeout_add_sec(&resettodr_to, RESETTODR_PERIOD);
}

void
start_periodic_resettodr(void)
{
	timeout_add_sec(&resettodr_to, RESETTODR_PERIOD);
}

void
stop_periodic_resettodr(void)
{
	timeout_del(&resettodr_to);
	task_del(systq, &resettodr_task);
}
@


1.98
log
@Write the system time back to the RTC every 30 minutes.
This fixes the problem that long-running machines which were not
shut down properly would reboot with a badly offset system time.

hints and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.97 2016/04/28 20:11:20 tedu Exp $	*/
d144 1
a144 1
			q = pfind(__CLOCK_PTID(clock_id) - THREAD_PID_OFFSET);
d235 1
a235 1
			q = pfind(__CLOCK_PTID(clock_id) - THREAD_PID_OFFSET);
@


1.97
log
@careful study of the holy scrolls reveals that for pselect (and ppoll)
oversized timespecs should be clamped, not rejected.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.96 2015/12/05 10:11:53 tedu Exp $	*/
d44 2
d790 34
@


1.96
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.95 2015/11/01 19:03:33 semarie Exp $	*/
d627 1
a627 1
	if (ts->tv_sec < 0 || ts->tv_sec > 100000000 ||
d630 2
@


1.95
log
@refactor pledge_*_check and pledge_fail functions

- rename _check function without suffix: a "pledge" function called from
  anywhere is a "check" function.

- makes pledge_fail call the responsability to the _check function. remove it
  from caller.

- make proper use of (potential) returned error of _check() functions.

- adds pledge_kill() and pledge_protexec()

with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.94 2015/10/09 01:10:27 deraadt Exp $	*/
a151 1
/* ARGSUSED */
a176 1
/* ARGSUSED */
a255 1
/* ARGSUSED */
a320 1
/* ARGSUSED */
a353 1
/* ARGSUSED */
a388 1
/* ARGSUSED */
a416 1
/* ARGSUSED */
a481 1
/* ARGSUSED */
a525 1
/* ARGSUSED */
@


1.94
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.93 2015/09/11 08:22:31 guenther Exp $	*/
d436 3
a438 2
	if (pledge_adjtime_check(p, delta))
		return (EPERM);
@


1.93
log
@Only include <sys/tame.h> in the .c files that need it

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.92 2015/08/22 20:18:49 deraadt Exp $	*/
d43 1
a43 1
#include <sys/tame.h>
d436 1
a436 1
	if (tame_adjtime_check(p, delta))
@


1.92
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.91 2015/07/19 02:35:35 deraadt Exp $	*/
d43 1
@


1.91
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.90 2015/04/28 20:54:18 kettenis Exp $	*/
a42 1
#include <sys/tame.h>
@


1.90
log
@Protect the per-process itimerval structs with a mutex.  We update these
from hardclock() which runs without grabbing the kernel lock.  This means
that two threads could concurrently update the struct which could lead to
corruption of the value which in turn could stop the timer.  It could also
result in getitimer(2) returning a non-normalized value.

With help from guenther@@.

ok deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.89 2014/12/07 02:58:14 deraadt Exp $	*/
d43 1
d435 3
@


1.89
log
@typo; fix from Kaspars Bankovskis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.88 2014/05/15 04:36:33 guenther Exp $	*/
d463 2
a492 1
	int s;
d500 1
a500 1
	s = splclock();
d505 1
d525 1
a525 1
	splx(s);
a577 2
		int s;

d579 1
a579 1
		s = splclock();
d581 1
a581 1
		splx(s);
d679 1
a679 1

d691 2
a692 1
	if (timerisset(&itp->it_value))
d694 1
d706 1
@


1.88
log
@Prefer prsignal() to send process signals
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.87 2014/01/30 21:01:59 kettenis Exp $	*/
d468 1
a468 1
 * The real time interval timer's it_value, in contast, is kept as an 
@


1.87
log
@Simplyfy adjtime(2) by keeping track of the adjustment as a number of
microsecond in a 64-bit integer.  Fixes the issue where ntpd loses sync
because the struct timeval currently used to hold the adjustment is not
properly normalized after the changes guenther@@ made.

ok guenther@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.86 2014/01/22 00:48:36 guenther Exp $	*/
d601 1
a601 1
	psignal(pr->ps_mainproc, SIGALRM);
@


1.86
log
@timeval, timespec, and itimerval have padding on many archs.  If we're
going to copyout one, memset the structure and then set it member by member.
sys_adjtime() does that on copyin instead, as it already has to munge the
members as it goes.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.85 2013/10/25 04:42:48 guenther Exp $	*/
d49 1
a49 1
struct timeval adjtimedelta;		/* unapplied time correction */
d71 1
a71 2
	adjtimedelta.tv_usec = 0;
	adjtimedelta.tv_sec = 0;
a429 1
	struct timeval newdelta;
d432 1
d435 10
a444 3
	if (olddelta)
		if ((error = copyout(&adjtimedelta, olddelta,
		    sizeof(struct timeval))))
d446 1
d452 1
a452 2
		if ((error = copyin(delta, &newdelta,
		    sizeof(struct timeval))))
d455 3
a457 9
		/* Normalize the correction. */
		while (newdelta.tv_usec >= 1000000) {
			newdelta.tv_usec -= 1000000;
			newdelta.tv_sec += 1;
		}
		while (newdelta.tv_usec < 0) {
			newdelta.tv_usec += 1000000;
			newdelta.tv_sec -= 1;
		}
a458 3
		adjtimedelta.tv_sec  = newdelta.tv_sec;
		adjtimedelta.tv_usec = newdelta.tv_usec;
	}
@


1.85
log
@Move the declarations for dogetrusage(), itimerround(), and dowait4()
to sys/*.h headers so that the compat/linux code can use them.
Change dowait4() to not copyout() the status value, but rather leave
that for its caller, as compat/linux has to translate it, with the
side benefit of simplifying the native code.

Originally written months ago as part of the time_t work; long
memory, prodding, and ok from pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.84 2013/10/08 03:50:08 guenther Exp $	*/
d163 1
d221 1
d302 1
d341 1
d431 1
d445 1
a445 1
		if ((error = copyin(delta, &adjtimedelta,
a447 1
	}
d449 12
a460 8
	/* Normalize the correction. */
	while (adjtimedelta.tv_usec >= 1000000) {
		adjtimedelta.tv_usec -= 1000000;
		adjtimedelta.tv_sec += 1;
	}
	while (adjtimedelta.tv_usec < 0) {
		adjtimedelta.tv_usec += 1000000;
		adjtimedelta.tv_sec -= 1;
d501 1
d503 4
a506 1
	aitv = p->p_p->ps_timer[which];
@


1.84
log
@Fix delivery of SIGPROF and SIGVTALRM to threaded processes by having
hardclock() set a flag on the running thread and force AST processing,
and then have the thread signal itself from userret().

idea and flag names from FreeBSD
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.83 2013/10/06 01:27:50 guenther Exp $	*/
a49 2

void	itimerround(struct timeval *);
@


1.83
log
@Add CLOCK_UPTIME, a clock which measures time-running-not-suspended, so
that mlarkin@@ can fix programs that report rates-over-uptime.

ok kettenis@@
manpage corrections jmc@@ (which I've probably broken again)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.82 2013/09/14 01:35:01 guenther Exp $	*/
a573 4
		if (which == ITIMER_VIRTUAL)
			timeout_del(&pr->ps_virt_to);
		if (which == ITIMER_PROF)
			timeout_del(&pr->ps_prof_to);
@


1.82
log
@Snapshots for all archs have been built, so remove the T32 code
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.81 2013/08/13 05:52:23 guenther Exp $	*/
d114 1
d121 5
d226 1
@


1.81
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.80 2013/06/17 19:11:54 guenther Exp $	*/
a776 333
#ifdef T32
int
t32_sys_clock_gettime(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_clock_gettime_args /* {
		syscallarg(clockid_t) clock_id;
		syscallarg(struct timespec32 *) tp;
	} */ *uap = v;
	struct timespec ats;
	struct timespec32 ats32;
	int error;

	if ((error = clock_gettime(p, SCARG(uap, clock_id), &ats)) != 0)
		return (error);
	TIMESPEC_TO_32(&ats32, &ats);
	return (copyout(&ats32, SCARG(uap, tp), sizeof(ats32)));
}

int
t32_sys_clock_settime(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_clock_settime_args /* {
		syscallarg(clockid_t) clock_id;
		syscallarg(const struct timespec32 *) tp;
	} */ *uap = v;
	struct timespec ats;
	struct timespec32 ats32;
	clockid_t clock_id;
	int error;

	if ((error = suser(p, 0)) != 0)
		return (error);

	if ((error = copyin(SCARG(uap, tp), &ats32, sizeof(ats32))) != 0)
		return (error);
	TIMESPEC_FROM_32(&ats, &ats32);

	clock_id = SCARG(uap, clock_id);
	switch (clock_id) {
	case CLOCK_REALTIME:
		if ((error = settime(&ats)) != 0)
			return (error);
		break;
	default:	/* Other clocks are read-only */
		return (EINVAL);
	}

	return (0);
}

int
t32_sys_clock_getres(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_clock_getres_args /* {
		syscallarg(clockid_t) clock_id;
		syscallarg(struct timespec32 *) tp;
	} */ *uap = v;
	clockid_t clock_id;
	struct timespec32 ts;
	int error = 0;

	clock_id = SCARG(uap, clock_id);
	switch (clock_id) {
	case CLOCK_REALTIME:
	case CLOCK_MONOTONIC:
		ts.tv_sec = 0;
		ts.tv_nsec = 1000000000 / hz;
		break;
	default:
		return (EINVAL);
	}

	if (SCARG(uap, tp)) {
		error = copyout(&ts, SCARG(uap, tp), sizeof (ts));
#ifdef KTRACE
		if (error == 0 && KTRPOINT(p, KTR_STRUCT)) {
			KERNEL_LOCK();
			ktrreltimespec(p, &ts);
			KERNEL_UNLOCK();
		}
#endif
	}

	return error;
}
#endif /* T32 */

#if defined(T32) || defined(COMPAT_LINUX)
int
t32_sys_nanosleep(struct proc *p, void *v, register_t *retval)
{
	static int nanowait;
	struct t32_sys_nanosleep_args/* {
		syscallarg(const struct timespec32 *) rqtp;
		syscallarg(struct timespec32 *) rmtp;
	} */ *uap = v;
	struct timespec32 ts32;
	struct timespec rqt, rmt;
	struct timespec sts, ets;
	struct timespec32 *rmtp;
	struct timeval tv;
	int error, error1;

	rmtp = SCARG(uap, rmtp);
	error = copyin(SCARG(uap, rqtp), &ts32, sizeof(ts32));
	if (error)
		return (error);
	TIMESPEC_FROM_32(&rqt, &ts32);
#ifdef KTRACE
        if (KTRPOINT(p, KTR_STRUCT)) {
		KERNEL_LOCK();
		ktrreltimespec(p, &rqt);
		KERNEL_UNLOCK();
	}
#endif

	TIMESPEC_TO_TIMEVAL(&tv, &rqt);
	if (itimerfix(&tv))
		return (EINVAL);

	if (rmtp)
		getnanouptime(&sts);

	error = tsleep(&nanowait, PWAIT | PCATCH, "nanosleep",
	    MAX(1, tvtohz(&tv)));
	if (error == ERESTART)
		error = EINTR;
	if (error == EWOULDBLOCK)
		error = 0;

	if (rmtp) {
		getnanouptime(&ets);

		timespecsub(&ets, &sts, &sts);
		timespecsub(&rqt, &sts, &rmt);

		if (rmt.tv_sec < 0)
			timespecclear(&rmt);

		TIMESPEC_TO_32(&ts32, &rmt);
		error1 = copyout(&ts32, rmtp, sizeof(ts32));
		if (error1 != 0)
			error = error1;
#ifdef KTRACE
		if (error1 == 0 && KTRPOINT(p, KTR_STRUCT)) {
			KERNEL_LOCK();
			ktrreltimespec(p, &rmt);
			KERNEL_UNLOCK();
		}
#endif
	}

	return error;
}

/* ARGSUSED */
int
t32_sys_gettimeofday(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_gettimeofday_args /* {
		syscallarg(struct timeval32 *) tp;
		syscallarg(struct timezone *) tzp;
	} */ *uap = v;
	struct timeval atv;
	struct timeval32 atv32;
	struct timeval32 *tp;
	struct timezone *tzp;
	int error = 0;

	tp = SCARG(uap, tp);
	tzp = SCARG(uap, tzp);

	if (tp) {
		microtime(&atv);
		TIMEVAL_TO_32(&atv32, &atv);
		if ((error = copyout(&atv32, tp, sizeof (atv32))))
			return (error);
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT)) {
			KERNEL_LOCK();
			ktrabstimeval(p, &atv);
			KERNEL_UNLOCK();
		}
#endif
	}
	if (tzp)
		error = copyout(&tz, tzp, sizeof (tz));
	return (error);
}

/* ARGSUSED */
int
t32_sys_settimeofday(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_settimeofday_args /* {
		syscallarg(const struct timeval32 *) tv;
		syscallarg(const struct timezone *) tzp;
	} */ *uap = v;
	struct timezone atz;
	struct timeval32 atv;
	const struct timeval32 *tv;
	const struct timezone *tzp;
	int error;

	tv = SCARG(uap, tv);
	tzp = SCARG(uap, tzp);

	if ((error = suser(p, 0)))
		return (error);
	/* Verify all parameters before changing time. */
	if (tv && (error = copyin(tv, &atv, sizeof(atv))))
		return (error);
	if (tzp && (error = copyin(tzp, &atz, sizeof(atz))))
		return (error);
	if (tv) {
		struct timespec ts;

		TIMESPEC_FROM_TIMEVAL32(&ts, &atv);
		if ((error = settime(&ts)) != 0)
			return (error);
	}
	if (tzp)
		tz = atz;
	return (0);
}

int
t32_sys_getitimer(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_getitimer_args /* {
		syscallarg(int) which;
		syscallarg(struct itimerval32 *) itv;
	} */ *uap = v;
	struct itimerval aitv;
	struct itimerval32 aitv32;
	int s;
	int which;

	which = SCARG(uap, which);

	if (which < ITIMER_REAL || which > ITIMER_PROF)
		return (EINVAL);
	s = splclock();
	aitv = p->p_p->ps_timer[which];

	if (which == ITIMER_REAL) {
		struct timeval now;

		getmicrouptime(&now);
		/*
		 * Convert from absolute to relative time in .it_value
		 * part of real time timer.  If time for real time timer
		 * has passed return 0, else return difference between
		 * current time and time for the timer to go off.
		 */
		if (timerisset(&aitv.it_value)) {
			if (timercmp(&aitv.it_value, &now, <))
				timerclear(&aitv.it_value);
			else
				timersub(&aitv.it_value, &now,
				    &aitv.it_value);
		}
	}
	splx(s);
	ITIMERVAL_TO_32(&aitv32, &aitv);
	return (copyout(&aitv32, SCARG(uap, itv), sizeof(aitv32)));
}

/* ARGSUSED */
int
t32_sys_setitimer(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_setitimer_args /* {
		syscallarg(int) which;
		syscallarg(const struct itimerval32 *) itv;
		syscallarg(struct itimerval32 *) oitv;
	} */ *uap = v;
	struct t32_sys_getitimer_args getargs;
	struct itimerval aitv;
	struct itimerval32 aitv32;
	const struct itimerval32 *itvp;
	struct itimerval32 *oitv;
	struct process *pr = p->p_p;
	int error;
	int timo;
	int which;

	which = SCARG(uap, which);
	itvp = SCARG(uap, itv);
	oitv = SCARG(uap, oitv);

	if (which < ITIMER_REAL || which > ITIMER_PROF)
		return (EINVAL);
	if (itvp && (error = copyin(itvp, &aitv32, sizeof(aitv32))))
		return (error);
	if (oitv != NULL) {
		SCARG(&getargs, which) = which;
		SCARG(&getargs, itv) = oitv;
		if ((error = t32_sys_getitimer(p, &getargs, retval)))
			return (error);
	}
	if (itvp == 0)
		return (0);
	ITIMERVAL_FROM_32(&aitv, &aitv32);
	if (itimerfix(&aitv.it_value) || itimerfix(&aitv.it_interval))
		return (EINVAL);
	if (which == ITIMER_REAL) {
		struct timeval ctv;

		timeout_del(&pr->ps_realit_to);
		getmicrouptime(&ctv);
		if (timerisset(&aitv.it_value)) {
			timo = tvtohz(&aitv.it_value);
			timeout_add(&pr->ps_realit_to, timo);
			timeradd(&aitv.it_value, &ctv, &aitv.it_value);
		}
		pr->ps_timer[ITIMER_REAL] = aitv;
	} else {
		int s;

		itimerround(&aitv.it_interval);
		s = splclock();
		pr->ps_timer[which] = aitv;
		if (which == ITIMER_VIRTUAL)
			timeout_del(&pr->ps_virt_to);
		if (which == ITIMER_PROF)
			timeout_del(&pr->ps_prof_to);
		splx(s);
	}

	return (0);
}
#endif /* defined(T32) || defined(COMPAT_LINUX) */
@


1.80
log
@Add support for the _POSIX_CPUTIME and _POSIX_THREAD_CPUTIME options,
including CLOCK_{PROCESS,THREAD}_CPUTIME_ID constants and
{clock,pthread}_getcpuclockid() functions.

Worked out at t2k13 with help from tedu@@ and matthew@@ and testing by aja@@
ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.79 2013/06/03 16:55:22 guenther Exp $	*/
d84 2
a85 3
	 * XXX: we check against INT_MAX since on 64-bit
	 *	platforms, sizeof(int) != sizeof(long) and
	 *	time_t is 32 bits even when atv.tv_sec is 64 bits.
d87 1
a87 1
	if (ts->tv_sec > INT_MAX - 365*24*60*60) {
d776 334
@


1.79
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.78 2013/06/02 20:59:09 guenther Exp $	*/
d115 2
d124 1
a124 1
	case CLOCK_PROF:
d127 7
d137 8
a144 1
		return (EINVAL);
d214 1
d221 2
d227 9
a235 1
		return (EINVAL);
@


1.78
log
@Use long long and %lld for printing tv_sec values

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.77 2013/03/28 16:55:25 deraadt Exp $	*/
a114 2
	struct timeval tv;

d123 3
a125 5
		microuptime(&tv);
		timersub(&tv, &curcpu()->ci_schedstate.spc_runtime, &tv);
		timeradd(&tv, &p->p_rtime, &tv);
		tp->tv_sec = tv.tv_sec;
		tp->tv_nsec = tv.tv_usec * 1000;
@


1.77
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.76 2012/11/05 19:39:35 miod Exp $	*/
d89 2
a90 2
		printf("denied attempt to set clock forward to %ld\n",
		    ts->tv_sec);
d101 2
a102 2
		printf("denied attempt to set clock back %ld seconds\n",
		    now.tv_sec - ts->tv_sec);
@


1.76
log
@unifdef -D __HAVE_TIMECOUNTER
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.75 2012/05/24 07:17:42 guenther Exp $	*/
a47 1
#include <machine/cpu.h>
@


1.75
log
@On resume, run forward the monotonic and realtimes clocks instead of jumping
just the realtime clock, triggering and adjusting timeouts to reflect that.

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.74 2012/03/23 15:51:26 guenther Exp $	*/
a42 1
#ifdef __HAVE_TIMECOUNTER
a43 1
#endif
a49 1
#ifdef __HAVE_TIMECOUNTER
a50 7
#else
int	tickdelta;			/* current clock skew, us. per tick */
long	timedelta;			/* unapplied time correction, us. */
long	bigadj = 1000000;		/* use 10x skew above bigadj us. */
int64_t	ntp_tick_permanent;
int64_t	ntp_tick_acc;
#endif
a64 1
#ifdef __HAVE_TIMECOUNTER
a111 60
#else
int
settime(struct timespec *ts)
{
	struct timeval delta, tvv, *tv;
	int s;

	/* XXX - Ugh. */
	tv = &tvv;
	tvv.tv_sec = ts->tv_sec;
	tvv.tv_usec = ts->tv_nsec / 1000;

	/*
	 * Don't allow the time to be set forward so far it will wrap
	 * and become negative, thus allowing an attacker to bypass
	 * the next check below.  The cutoff is 1 year before rollover
	 * occurs, so even if the attacker uses adjtime(2) to move
	 * the time past the cutoff, it will take a very long time
	 * to get to the wrap point.
	 *
	 * XXX: we check against INT_MAX since on 64-bit
	 *	platforms, sizeof(int) != sizeof(long) and
	 *	time_t is 32 bits even when atv.tv_sec is 64 bits.
	 */
	if (tv->tv_sec > INT_MAX - 365*24*60*60) {
		printf("denied attempt to set clock forward to %ld\n",
		    tv->tv_sec);
		return (EPERM);
	}
	/*
	 * If the system is secure, we do not allow the time to be
	 * set to an earlier value (it may be slowed using adjtime,
	 * but not set back). This feature prevent interlopers from
	 * setting arbitrary time stamps on files.
	 */
	if (securelevel > 1 && timercmp(tv, &time, <)) {
		printf("denied attempt to set clock back %ld seconds\n",
		    time_second - tv->tv_sec);
		return (EPERM);
	}

	/* WHAT DO WE DO ABOUT PENDING REAL-TIME TIMEOUTS??? */
	s = splclock();
	timersub(tv, &time, &delta);
	time = *tv;
	timeradd(&boottime, &delta, &boottime);

	/*
	 * Adjtime in progress is meaningless or harmful after
	 * setting the clock.
	 */
	tickdelta = 0;
	timedelta = 0;

	splx(s);
	resettodr();

	return (0);
}
#endif
a375 18
#ifndef __HAVE_TIMECOUNTER
	int s;

	if (oldfreq) {
		f = ntp_tick_permanent * hz;
		if ((error = copyout(&f, oldfreq, sizeof(int64_t))))
			return (error);
	}
	if (freq) {
		if ((error = suser(p, 0)))
			return (error);
		if ((error = copyin(freq, &f, sizeof(int64_t))))
			return (error);
		s = splclock();
		ntp_tick_permanent = f / hz;
		splx(s);
	}
#else
a389 1
#endif
a402 1
#ifdef __HAVE_TIMECOUNTER
a428 66
#else
	struct timeval atv;
	long ndelta, ntickdelta, odelta;
	int s, error;

	if (!delta) {
		s = splclock();
		odelta = timedelta;
		splx(s);
		goto out;
	}
	if ((error = suser(p, 0)))
		return (error);
	if ((error = copyin(delta, &atv, sizeof(struct timeval))))
		return (error);

	/*
	 * Compute the total correction and the rate at which to apply it.
	 * Round the adjustment down to a whole multiple of the per-tick
	 * delta, so that after some number of incremental changes in
	 * hardclock(), tickdelta will become zero, lest the correction
	 * overshoot and start taking us away from the desired final time.
	 */
	if (atv.tv_sec > LONG_MAX / 1000000L)
		ndelta = LONG_MAX;
	else if (atv.tv_sec < LONG_MIN / 1000000L)
		ndelta = LONG_MIN;
	else {
		ndelta = atv.tv_sec * 1000000L;
		odelta = ndelta;
		ndelta += atv.tv_usec;
		if (atv.tv_usec > 0 && ndelta <= odelta)
			ndelta = LONG_MAX;
		else if (atv.tv_usec < 0 && ndelta >= odelta)
			ndelta = LONG_MIN;
	}

	if (ndelta > bigadj || ndelta < -bigadj)
		ntickdelta = 10 * tickadj;
	else
		ntickdelta = tickadj;
	if (ndelta % ntickdelta)
		ndelta = ndelta / ntickdelta * ntickdelta;

	/*
	 * To make hardclock()'s job easier, make the per-tick delta negative
	 * if we want time to run slower; then hardclock can simply compute
	 * tick + tickdelta, and subtract tickdelta from timedelta.
	 */
	if (ndelta < 0)
		ntickdelta = -ntickdelta;
	s = splclock();
	odelta = timedelta;
	timedelta = ndelta;
	tickdelta = ntickdelta;
	splx(s);

out:
	if (olddelta) {
		atv.tv_sec = odelta / 1000000;
		atv.tv_usec = odelta % 1000000;
		if ((error = copyout(&atv, olddelta, sizeof(struct timeval))))
			return (error);
	}
	return (0);
#endif
@


1.74
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.73 2012/03/19 09:05:39 guenther Exp $	*/
d118 1
a118 1
	tc_setclock(ts);
@


1.73
log
@Add tracing and dumping of "pointer to struct" syscall arguments for
structs timespec, timeval, sigaction, and rlimit.

ok otto@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.72 2012/03/10 05:54:28 guenther Exp $	*/
d591 1
a591 2
 * profiling virtual time timers are kept in the p_stats area, since
 * they can be swapped out.  These are kept internally in the
d594 1
a594 2
 * The real time interval timer is kept in the process table slot
 * for the process, and its value (it_value) is kept as an
d625 2
a636 1
		aitv = p->p_realtimer;
d644 1
a644 2
	} else
		aitv = p->p_stats->p_timer[which];
d662 1
d689 1
a689 1
		timeout_del(&p->p_realit_to);
d693 1
a693 1
			timeout_add(&p->p_realit_to, timo);
d696 1
a696 1
		p->p_realtimer = aitv;
d702 1
a702 1
		p->p_stats->p_timer[which] = aitv;
d704 1
a704 1
			timeout_del(&p->p_stats->p_virt_to);
d706 1
a706 1
			timeout_del(&p->p_stats->p_prof_to);
d724 2
a725 1
	struct proc *p;
d727 3
a729 4
	p = (struct proc *)arg;
	psignal(p, SIGALRM);
	if (!timerisset(&p->p_realtimer.it_interval)) {
		timerclear(&p->p_realtimer.it_value);
d736 1
a736 2
		timeradd(&p->p_realtimer.it_value,
		    &p->p_realtimer.it_interval, &p->p_realtimer.it_value);
d738 2
a739 2
		if (timercmp(&p->p_realtimer.it_value, &ctv, >)) {
			ntv = p->p_realtimer.it_value;
d744 2
a745 2
			if ((p->p_p->ps_flags & PS_EXITING) == 0)
				timeout_add(&p->p_realit_to, timo);
@


1.72
log
@Add PS_EXITING to better differentiate between the process exiting and
the main thread exiting.  c.f. regress/sys/kern/main-thread-exited/
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.71 2010/06/30 01:47:35 tedu Exp $	*/
d40 1
d223 9
a231 1
	return copyout(&ats, SCARG(uap, tp), sizeof(ats));
d287 1
a287 1
	if (SCARG(uap, tp))
d289 8
d320 7
d354 7
d386 7
@


1.71
log
@lots of SCARG simplification.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.70 2010/06/28 21:23:20 art Exp $	*/
d708 1
a708 1
			if ((p->p_flag & P_WEXIT) == 0)
@


1.70
log
@clock_gettime(CLOCK_PROF) didn't account for the time between the last
context switch and the call to clock_gettime.

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.69 2010/04/04 03:47:02 guenther Exp $	*/
d295 1
d299 2
a300 2
	error = copyin((const void *)SCARG(uap, rqtp), (void *)&rqt,
	    sizeof(struct timespec));
d308 1
a308 1
	if (SCARG(uap, rmtp))
d318 1
a318 1
	if (SCARG(uap, rmtp)) {
d327 1
a327 2
		error1 = copyout((void *)&rmt, (void *)SCARG(uap,rmtp),
		    sizeof(rmt));
d344 2
d348 4
a351 1
	if (SCARG(uap, tp)) {
d353 1
a353 2
		if ((error = copyout((void *)&atv, (void *)SCARG(uap, tp),
		    sizeof (atv))))
d356 2
a357 3
	if (SCARG(uap, tzp))
		error = copyout((void *)&tz, (void *)SCARG(uap, tzp),
		    sizeof (tz));
d371 2
d375 3
d381 1
a381 2
	if (SCARG(uap, tv) && (error = copyin((void *)SCARG(uap, tv),
	    (void *)&atv, sizeof(atv))))
d383 1
a383 2
	if (SCARG(uap, tzp) && (error = copyin((void *)SCARG(uap, tzp),
	    (void *)&atz, sizeof(atz))))
d385 1
a385 1
	if (SCARG(uap, tv)) {
d392 1
a392 1
	if (SCARG(uap, tzp))
d407 2
d412 1
a412 1
	if (SCARG(uap, oldfreq)) {
d414 1
a414 2
		if ((error = copyout((void *)&f, (void *)SCARG(uap, oldfreq),
		    sizeof(int64_t))))
d417 1
a417 1
	if (SCARG(uap, freq)) {
d420 1
a420 2
		if ((error = copyin((void *)SCARG(uap, freq), (void *)&f,
		    sizeof(int64_t))))
d427 2
a428 2
	if (SCARG(uap, oldfreq)) {
		if ((error = tc_adjfreq(&f, NULL)) != 0)
d430 1
a430 1
		if ((error = copyout(&f, SCARG(uap, oldfreq), sizeof(f))) != 0)
d433 1
a433 1
	if (SCARG(uap, freq)) {
d436 1
a436 1
		if ((error = copyin(SCARG(uap, freq), &f, sizeof(f))) != 0)
d438 1
a438 1
		if ((error = tc_adjfreq(NULL, &f)) != 0)
d453 2
d458 3
a460 3
	if (SCARG(uap, olddelta))
		if ((error = copyout((void *)&adjtimedelta,
		    (void *)SCARG(uap, olddelta), sizeof(struct timeval))))
d463 1
a463 1
	if (SCARG(uap, delta)) {
d467 2
a468 2
		if ((error = copyin((void *)SCARG(uap, delta),
		    (void *)&adjtimedelta, sizeof(struct timeval))))
d487 1
a487 1
	if (!SCARG(uap, delta)) {
d495 1
a495 2
	if ((error = copyin((void *)SCARG(uap, delta), (void *)&atv,
	    sizeof(struct timeval))))
d540 1
a540 1
	if (SCARG(uap, olddelta)) {
d543 1
a543 2
		if ((error = copyout((void *)&atv, (void *)SCARG(uap, olddelta),
		    sizeof(struct timeval))))
d582 3
d586 1
a586 1
	if (SCARG(uap, which) < ITIMER_REAL || SCARG(uap, which) > ITIMER_PROF)
d589 1
a589 1
	if (SCARG(uap, which) == ITIMER_REAL) {
d608 1
a608 1
		aitv = p->p_stats->p_timer[SCARG(uap, which)];
d610 1
a610 2
	return (copyout((void *)&aitv, (void *)SCARG(uap, itv),
	    sizeof (struct itimerval)));
d625 1
d628 4
d633 1
a633 1
	if (SCARG(uap, which) < ITIMER_REAL || SCARG(uap, which) > ITIMER_PROF)
d639 3
a641 3
	if (SCARG(uap, oitv) != NULL) {
		SCARG(&getargs, which) = SCARG(uap, which);
		SCARG(&getargs, itv) = SCARG(uap, oitv);
d649 1
a649 1
	if (SCARG(uap, which) == ITIMER_REAL) {
d665 2
a666 2
		p->p_stats->p_timer[SCARG(uap, which)] = aitv;
		if (SCARG(uap, which) == ITIMER_VIRTUAL)
d668 1
a668 1
		if (SCARG(uap, which) == ITIMER_PROF)
@


1.69
log
@clock_settime() should cancel an in-progress adjtime() just like
settimeofday() does, so move those bits into settime()

"I like it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.68 2009/11/27 19:45:53 guenther Exp $	*/
d186 2
d196 5
a200 2
		tp->tv_sec = p->p_rtime.tv_sec;
		tp->tv_nsec = p->p_rtime.tv_usec * 1000;
@


1.68
log
@Convert thrsleep() to an absolute timeout with clockid to eliminate a
race condition and prep for later support of pthread_condattr_setclock()

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.67 2009/10/16 19:29:41 martynas Exp $	*/
d51 10
d80 6
d168 8
a352 10
#ifdef __HAVE_TIMECOUNTER
struct timeval adjtimedelta;		/* unapplied time correction */
#else
int	tickdelta;			/* current clock skew, us. per tick */
long	timedelta;			/* unapplied time correction, us. */
long	bigadj = 1000000;		/* use 10x skew above bigadj us. */
int64_t	ntp_tick_permanent;
int64_t	ntp_tick_acc;
#endif

a375 14

		/*
		 * Adjtime in progress is meaningless or harmful after
		 * setting the clock. Cancel adjtime and then set new time.
		 */
#ifdef __HAVE_TIMECOUNTER
		adjtimedelta.tv_usec = 0;
		adjtimedelta.tv_sec = 0;
#else
		int s = splclock();
		tickdelta = 0;
		timedelta = 0;
		splx(s);
#endif
@


1.67
log
@cancel the timeout upon disabling profiling / virtual timer;  so
that the timeout doesn't happen if setitimer is called between the
profiling / virtual timer expires and the timeout is scheduled.
firefox triggered this Profiling timer expired problem when in
uthread execve signal was being delivered after timer has already
been disabled;  as reported on ports@@ recently.
special thanks to kettenis@@, kurt@@, guenther@@.
agreed by kettenis@@, tedu@@.  ok guenther@@.
reminded & ok fgs@@.  tested by ian@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.66 2009/06/05 15:17:02 ckuethe Exp $	*/
a158 1
/* ARGSUSED */
d160 1
a160 1
sys_clock_gettime(struct proc *p, void *v, register_t *retval)
a161 8
	struct sys_clock_gettime_args /* {
		syscallarg(clockid_t) clock_id;
		syscallarg(struct timespec *) tp;
	} */ *uap = v;
	clockid_t clock_id;
	struct timespec ats;

	clock_id = SCARG(uap, clock_id);
d164 1
a164 1
		nanotime(&ats);
d167 1
a167 1
		nanouptime(&ats);
d170 2
a171 2
		ats.tv_sec = p->p_rtime.tv_sec;
		ats.tv_nsec = p->p_rtime.tv_usec * 1000;
d176 16
d695 12
@


1.66
log
@abort any time adjustment in progress if the clock is set with settimeofday
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.65 2008/09/19 23:36:24 djm Exp $	*/
d641 4
@


1.65
log
@system/5918: fix clearing of ITIMER_VIRTUAL and ITIMER_PROF it_interval
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.64 2008/04/04 22:48:02 dlg Exp $	*/
d69 1
a69 1
	
d322 10
d356 14
a378 10
#ifdef __HAVE_TIMECOUNTER
struct timeval adjtimedelta;		/* unapplied time correction */
#else
int	tickdelta;			/* current clock skew, us. per tick */
long	timedelta;			/* unapplied time correction, us. */
long	bigadj = 1000000;		/* use 10x skew above bigadj us. */
int64_t	ntp_tick_permanent;
int64_t	ntp_tick_acc;
#endif

d495 1
a495 1
			ndelta = LONG_MAX;	
@


1.64
log
@ratecheck(9) only seems to be used to limit things to very coarse intervals
like .25 seconds or 5 seconds. the accuracy of microuptime is not really
needed then, so switch it to getmicrouptime.

ok henning@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.62 2007/04/04 17:32:20 art Exp $	*/
d691 2
a692 2
 * Timer interval smaller than the resolution of the system clock are
 * rounded up.
d697 1
a697 1
	if (tv->tv_sec == 0 && tv->tv_usec < tick)
@


1.63
log
@Do not lose nanosleep() return value in the last copyout if nonzero; PR#5697
@
text
@d752 1
a752 1
	microuptime(&tv);
@


1.62
log
@Implement clock_gettime(CLOCK_PROF) since it's so simple.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.61 2007/01/10 07:58:08 art Exp $	*/
d260 1
a260 1
	int error;
d290 1
a290 1
		error = copyout((void *)&rmt, (void *)SCARG(uap,rmtp),
d292 2
@


1.61
log
@Fix getitimer to use uptime as setitimer does. Fixes bad output from
getitimer when the clock on the machine has been reset.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.60 2006/10/30 20:19:33 otto Exp $	*/
d178 4
d213 1
a213 3
	case CLOCK_MONOTONIC:
		return (EINVAL);	/* read-only clock */
	default:
@


1.60
log
@Timecounter based implementation of adjfreq(2). Largely from art@@
Tested by various using not (yet) committed amd64 timecounter code.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.59 2006/06/29 19:52:47 kettenis Exp $	*/
d553 1
a553 1
		getmicrotime(&now);
@


1.59
log
@Normalize the correction passed to adjtime(2) before using it in the
__HAVE_TIMECOUNTER case.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.58 2006/06/27 10:41:27 otto Exp $	*/
d392 11
a402 3
		f = 0;
		if ((error = copyout((void *)&f, (void *)SCARG(uap, oldfreq),
		    sizeof(int64_t))))
@


1.58
log
@Adapt adjtime() code and put in a better stub for adjfreq() for the
timecounters case. adjfreq() does not work with timecounters, but
more is coming. with help from miod; tested by dlg@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.57 2006/06/15 15:17:52 jsg Exp $	*/
d426 9
@


1.57
log
@Make sys_adjfreq() compile on archs that use timecounters
(ie sgi).  Diff and request to commit from otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.56 2006/06/14 19:52:07 otto Exp $	*/
a364 1
#ifndef __HAVE_TIMECOUNTER
d369 1
a369 1
	int error, s;
d371 2
d390 7
a411 3
	if ((error = suser(p, 0)))
		return (error);

d417 8
a424 3
	if ((error = copyin((void *)SCARG(uap, delta), (void *)&adjtimedelta,
	    sizeof(struct timeval))))
		return (error);
@


1.56
log
@Introducing adjfreq(2), to adjust the clock frequency.
Loosely based on dragonfly code. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.55 2006/06/04 18:47:33 otto Exp $	*/
d365 1
d389 1
@


1.55
log
@Allow any user to request the current adjustment; ok henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.54 2006/01/20 07:53:48 tedu Exp $	*/
d357 2
d363 30
d484 1
@


1.54
log
@revert auto-skew.  some ntpd implementations interact poorly.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.53 2006/01/13 22:02:37 tedu Exp $	*/
d388 6
d441 1
@


1.53
log
@auto adjusting adjtime.  be more responsive to large clock deltas,
and attempt to compensate for incorrect clocks by adjusting ticks
slowly. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.52 2005/11/28 00:14:29 jsg Exp $	*/
a353 1
int	tick_skew;		/* constant adjustment applied to tick */
a383 1
	static int increase_skew;
d385 1
a385 1
	long secdelta, ndelta, ntickdelta, odelta;
a386 1
	int largeadj = 0;
d401 1
a401 10
	secdelta = atv.tv_sec;

	/* if this is going to take more than 4 hours, speed it up */
	if (secdelta / 1000000L > 4 * 3600L) {
		largeadj = 1;
		ndelta = LONG_MAX;
	} else if (secdelta / 1000000L < -4 * 3600L) {
		largeadj = 1;
		ndelta = LONG_MIN;
	} else if (secdelta > LONG_MAX / 1000000L) {
d403 1
a403 1
	} else if (secdelta < LONG_MIN / 1000000L) {
d405 2
a406 2
	} else {
		ndelta = secdelta * 1000000L;
d415 1
a415 3
	if (largeadj)
		ntickdelta = 100 * tickadj;
	else if (ndelta > bigadj || ndelta < -bigadj)
a418 2
	if (ntickdelta > tick / 4)
		ntickdelta = tick / 4;
d425 1
a425 3
	 * tick + tickdelta, and subtract tickdelta from timedelta.  If
	 * we notice we are sliding away from where we want to be,
	 * take notice so next time we can increase the adjustment.
d427 1
a427 1
	if (ndelta < 0) {
a428 10
		if (ndelta < timedelta)
			increase_skew--;
		else
			increase_skew++;
	} else {
		if (ndelta > timedelta)
			increase_skew++;
		else
			increase_skew--;
	}
a433 10

	if (increase_skew <= -5) {
		if (--tick_skew < -tick / 4)
			tick_skew = -tick / 4;
		increase_skew = 0;
	} else if (increase_skew >= 5) {
		if (++tick_skew > tick / 4)
			tick_skew = tick / 4;
		increase_skew = 0;
	}
@


1.52
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.51 2005/10/27 14:57:12 markus Exp $	*/
d354 1
d385 1
d387 1
a387 1
	long ndelta, ntickdelta, odelta;
d389 1
d404 10
a413 1
	if (atv.tv_sec > LONG_MAX / 1000000L)
d415 1
a415 1
	else if (atv.tv_sec < LONG_MIN / 1000000L)
d417 2
a418 2
	else {
		ndelta = atv.tv_sec * 1000000L;
d427 3
a429 1
	if (ndelta > bigadj || ndelta < -bigadj)
d433 2
d441 3
a443 1
	 * tick + tickdelta, and subtract tickdelta from timedelta.
d445 1
a445 1
	if (ndelta < 0)
d447 10
d462 10
@


1.51
log
@make sure ppsratecheck() returns 0 if maxpps is 0;
from alexander bluhm; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.50 2005/10/13 18:17:15 aaron Exp $	*/
d161 1
a161 4
sys_clock_gettime(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d163 1
a163 1
	register struct sys_clock_gettime_args /* {
d187 1
a187 4
sys_clock_settime(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d189 1
a189 1
	register struct sys_clock_settime_args /* {
d219 1
a219 4
sys_clock_getres(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d221 1
a221 1
	register struct sys_clock_getres_args /* {
d248 1
a248 4
sys_nanosleep(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d297 1
a297 4
sys_gettimeofday(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d299 1
a299 1
	register struct sys_gettimeofday_args /* {
d320 1
a320 4
sys_settimeofday(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d361 1
a361 4
sys_adjtime(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d363 1
a363 1
	register struct sys_adjtime_args /* {
d385 1
a385 1
	register long ndelta, ntickdelta, odelta;
d469 1
a469 4
sys_getitimer(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d471 1
a471 1
	register struct sys_getitimer_args /* {
d508 1
a508 4
sys_setitimer(p, v, retval)
	struct proc *p;
	register void *v;
	register_t *retval;
d510 1
a510 1
	register struct sys_setitimer_args /* {
d517 1
a517 1
	register const struct itimerval *itvp;
d569 1
a569 2
realitexpire(arg)
	void *arg;
d571 1
a571 1
	register struct proc *p;
d604 1
a604 2
itimerfix(tv)
	struct timeval *tv;
d622 1
a622 2
itimerround(tv)
	struct timeval *tv;
d639 1
a639 3
itimerdecr(itp, usec)
	register struct itimerval *itp;
	int usec;
d674 1
a674 3
ratecheck(lasttime, mininterval)
	struct timeval *lasttime;
	const struct timeval *mininterval;
d700 1
a700 4
ppsratecheck(lasttime, curpps, maxpps)
	struct timeval *lasttime;
	int *curpps;
	int maxpps;	/* maximum pps allowed */
@


1.50
log
@In realitexpire(), do not re-add the itimer timeout if the process is in
the midst of exiting.  This solves a race condition that causes freed memory
to be left referenced in the master kernel timeout worklist, leading to a
uvm_fault.  The same race condition was already fixed earlier in r1.53 of
kern_clock.c for the process virtual and profile timeout structs.

deraadt@@ ok, testing by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.49 2005/10/10 07:23:02 otto Exp $	*/
d754 3
a756 1
	if ((lasttime->tv_sec == 0 && lasttime->tv_usec == 0) ||
@


1.49
log
@Avoid arithmetic overflows in computation of adjtime(). Fixes adjusting in the
wrong direction for large offsets as nick@@ saw. With tom@@ and toby@@;
ok tdeval@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.48 2005/05/31 11:32:47 art Exp $	*/
d620 2
a621 1
			timeout_add(&p->p_realit_to, timo);
@


1.48
log
@Protect p_timer with splclock. It can be fiddled with in hardclock (but
only for curproc, that's why no SCHED_LOCK or similar is necessary).

miod@@ "appears to be harmless"
markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.46 2005/05/25 23:17:47 niklas Exp $	*/
d422 15
a436 2
	ndelta = atv.tv_sec * 1000000 + atv.tv_usec;
	if (ndelta > bigadj)
@


1.48.2.1
log
@MFC:
Fix by aaron@@

In realitexpire(), do not re-add the itimer timeout if the process is in
the midst of exiting.  This solves a race condition that causes freed memory
to be left referenced in the master kernel timeout worklist, leading to a
uvm_fault.

ok deraadt@@ aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.48 2005/05/31 11:32:47 art Exp $	*/
d607 1
a607 2
			if ((p->p_flag & P_WEXIT) == 0)
				timeout_add(&p->p_realit_to, timo);
@


1.47
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.45 2004/07/28 17:15:12 tholo Exp $	*/
d563 2
d566 1
d568 1
@


1.46
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@a562 2
		int s;

a563 1
		s = splclock();
a564 1
		splx(s);
@


1.45
log
@This touches only MI code, and adds new time keeping code.  The
code is all conditionalized on __HAVE_TIMECOUNTER, and not
enabled on any platforms.

adjtime(2) support exists, courtesy of nordin@@, sysctl(2) support
and a concept of quality for each time source attached exists.

High quality time sources exists for PIIX4 ACPI timer as well as
some AMD power management chips.  This will have to be redone
once we actually add ACPI support (at that time we need to use
the ACPI interfaces to get at these clocks).

ok art@@ ken@@ miod@@ jmc@@ and many more
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.44 2004/06/26 05:52:20 nordin Exp $	*/
d563 2
d566 1
d568 1
@


1.45.4.1
log
@MFC:
Fix by aaron@@

In realitexpire(), do not re-add the itimer timeout if the process is in
the midst of exiting.  This solves a race condition that causes freed memory
to be left referenced in the master kernel timeout worklist, leading to a
uvm_fault.

ok deraadt@@ aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.45 2004/07/28 17:15:12 tholo Exp $	*/
d603 1
a603 2
			if ((p->p_flag & P_WEXIT) == 0)
				timeout_add(&p->p_realit_to, timo);
@


1.44
log
@Don't sleep forever on short nanosleeps.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.43 2004/06/24 19:35:24 tholo Exp $	*/
d42 3
d64 43
d157 1
d369 3
d375 1
d388 17
d451 1
@


1.43
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.42 2004/06/21 23:50:36 tholo Exp $	*/
d237 2
a238 1
	error = tsleep(&nanowait, PWAIT | PCATCH, "nanosleep", tvtohz(&tv));
@


1.42
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.41 2004/06/13 21:49:26 niklas Exp $	*/
a47 1
int	settime(struct timeval *);
d62 1
a62 1
settime(struct timeval *tv)
d64 1
a64 1
	struct timeval delta;
d67 5
a105 12
#ifdef __HAVE_CPUINFO
	/*
	 * XXXSMP
	 * This is wrong.  We should traverse a list of all
	 * CPUs and add the delta to the runtime of those
	 * CPUs which have a process on them.
	 */
	timeradd(&curcpu()->ci_schedstate.spc_runtime, &delta,
	    &curcpu()->ci_schedstate.spc_runtime);
#else
	timeradd(&runtime, &delta, &runtime);
#endif
a123 1
	struct timeval atv;
a124 1
	int s;
d129 1
a129 1
		microtime(&atv);
d132 1
a132 4
		/* XXX "hz" granularity */
		s = splclock();
		atv = mono_time;
		splx(s);
a137 2
	TIMEVAL_TO_TIMESPEC(&atv,&ats);

d152 1
a153 2
	struct timeval atv;
	struct timespec ats;
d165 1
a165 2
		TIMESPEC_TO_TIMEVAL(&atv, &ats);
		if ((error = settime(&atv)) != 0)
d220 4
a223 4
	struct timespec rqt;
	struct timespec rmt;
	struct timeval stv, etv, atv;
	int error, s, timo;
d230 2
a231 2
	TIMESPEC_TO_TIMEVAL(&atv,&rqt)
	if (itimerfix(&atv))
d234 2
a235 11
	if (SCARG(uap, rmtp)) {
		s = splclock();
		stv = mono_time;
		splx(s);
	}

	timo = tvtohz(&atv);

	/* Avoid sleeping forever. */
	if (timo <= 0)
		timo = 1;
d237 1
a237 1
	error = tsleep(&nanowait, PWAIT | PCATCH, "nanosleep", timo);
d244 1
a244 1
		int error;
d246 2
a247 3
		s = splclock();
		etv = mono_time;
		splx(s);
d249 2
a250 2
		timersub(&etv, &stv, &stv);
		timersub(&atv, &stv, &atv);
a251 4
		if (atv.tv_sec < 0)
			timerclear(&atv);

		TIMEVAL_TO_TIMESPEC(&atv, &rmt);
d253 1
a253 3
		    sizeof(rmt));		
		if (error)
			return (error);
d296 1
a297 1
	struct timezone atz;
d310 4
a313 1
		if ((error = settime(&atv)) != 0)
d423 3
d434 1
a434 1
			if (timercmp(&aitv.it_value, &time, <))
d437 1
a437 1
				timersub(&aitv.it_value, &time,
d462 1
a462 1
	int s, error;
a480 1
	s = splclock();
d482 2
d485 1
d487 1
a487 4
			timeradd(&aitv.it_value, &time, &aitv.it_value);
			timo = hzto(&aitv.it_value);
			if (timo <= 0)
				timo = 1;
d489 1
d496 1
a496 1
	splx(s);
a512 1
	int s, timo;
d521 3
a523 1
		s = splclock();
d526 5
a530 2
		if (timercmp(&p->p_realtimer.it_value, &time, >)) {
			timo = hzto(&p->p_realtimer.it_value);
a533 1
			splx(s);
a535 1
		splx(s);
d552 3
d623 1
a623 1
	int s, rv = 0;
d625 1
a625 3
	s = splclock(); 
	tv = mono_time;
	splx(s);
d652 1
a652 1
	int s, rv;
d654 1
a654 3
	s = splclock(); 
	tv = mono_time;
	splx(s);
@


1.41
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 1
a93 1
		    time.tv_sec - tv->tv_sec);
@


1.40
log
@Merge in a piece of the SMP branch into HEAD.

Introduce the cpu_info structure, p_cpu field in struct proc and global
scheduling context and various changed code to deal with this. At the
moment no architecture uses this stuff yet, but it will allow us slow and
controlled migration to the new APIs.

All new code is ifdef:ed out.

ok deraadt@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.39 2004/02/15 02:34:14 tedu Exp $	*/
d102 1
a102 1
#ifdef __HAVE_CURCPU
@


1.39
log
@pretty code that's easier to read, same effect.
from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.38 2003/09/01 18:06:03 henning Exp $	*/
d102 10
d113 1
@


1.38
log
@match syscallargs comments with reality
from Patrick Latifi <patrick.l@@hermes.usherb.ca>
ok jason@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.37 2003/08/26 02:15:13 tedu Exp $	*/
d475 1
d487 6
a492 3
	if ((SCARG(uap, itv) = SCARG(uap, oitv)) &&
	    (error = sys_getitimer(p, uap, retval)))
		return (error);
@


1.37
log
@fix sys_clock_settime.  hint from nordin@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.36 2003/08/15 20:32:18 tedu Exp $	*/
d315 2
a316 2
		syscallarg(struct timeval *) tv;
		syscallarg(struct timezone *) tzp;
d352 1
a352 1
		syscallarg(struct timeval *) delta;
d472 1
a472 1
		syscallarg(struct itimerval *) itv;
@


1.36
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.35 2003/08/11 05:38:05 kevlo Exp $	*/
d164 3
a178 5

	if ((error = copyin(SCARG(uap, tp), &ats, sizeof(ats))) != 0)
		return (error);

	TIMESPEC_TO_TIMEVAL(&atv,&ats);
@


1.35
log
@implement CLOCK_MONOTONIC from NetBSD; ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.34 2003/06/02 23:28:06 millert Exp $	*/
d161 1
a161 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d180 2
d324 1
a324 1
	if ((error = suser(p->p_ucred, &p->p_acflag)))
d361 1
a361 1
	if ((error = suser(p->p_ucred, &p->p_acflag)))
@


1.34
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.33 2003/05/19 07:24:08 mickey Exp $	*/
d123 1
d126 11
a136 1
	if (clock_id != CLOCK_REALTIME)
d138 1
a139 1
	microtime(&atv);
d165 9
a173 1
	if (clock_id != CLOCK_REALTIME)
d175 1
d180 1
a180 5
	TIMESPEC_TO_TIMEVAL(&atv,&ats);

	error = settime(&atv);

	return (error);
d198 3
a200 4
	if (clock_id != CLOCK_REALTIME)
		return (EINVAL);

	if (SCARG(uap, tp)) {
d203 4
d208 1
a209 1
	}
@


1.33
log
@no need for nfs headers since nqnfs had been removed way long time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.32 2002/10/02 17:43:38 nordin Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.32
log
@which is int not u_int so check for negative values. ok deraadt@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.31 2002/07/25 22:18:27 nordin Exp $	*/
a48 6

#if defined(NFSCLIENT) || defined(NFSSERVER)
#include <nfs/rpcv2.h>
#include <nfs/nfsproto.h>
#include <nfs/nfs_var.h>
#endif
@


1.31
log
@Avoid time wrap at securelevel 2. ok millert@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.30 2002/06/11 06:07:45 nordin Exp $	*/
d423 1
a423 1
		syscallarg(u_int) which;
d429 1
a429 1
	if (SCARG(uap, which) > ITIMER_PROF)
d462 1
a462 1
		syscallarg(u_int) which;
d471 1
a471 1
	if (SCARG(uap, which) > ITIMER_PROF)
@


1.30
log
@Remove unnecessary spllowersoftclock(). ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.29 2002/03/14 01:27:04 millert Exp $	*/
d58 1
a58 1
void	settime(struct timeval *);
d72 2
a73 3
void
settime(tv)
	struct timeval *tv;
d78 29
d115 2
d172 1
a172 9
	/*
	 * If the system is secure, we do not allow the time to be
	 * set to an earlier value (it may be slowed using adjtime,
	 * but not set back). This feature prevent interlopers from
	 * setting arbitrary time stamps on files.
	 */
	if (securelevel > 1 && timercmp(&atv, &time, <))
		return (EPERM);
	settime(&atv);
d174 1
a174 1
	return (0);
d323 2
a324 29
		/*
		 * Don't allow the time to be set forward so far it will wrap
		 * and become negative, thus allowing an attacker to bypass
		 * the next check below.  The cutoff is 1 year before rollover
		 * occurs, so even if the attacker uses adjtime(2) to move
		 * the time past the cutoff, it will take a very long time
		 * to get to the wrap point.
		 *
		 * XXX: we check against INT_MAX since on 64-bit
		 *	platforms, sizeof(int) != sizeof(long) and
		 *	time_t is 32 bits even when atv.tv_sec is 64 bits.
		 */
		if (atv.tv_sec > INT_MAX - 365*24*60*60) {
			printf("denied attempt to set clock forward to %ld\n",
			    atv.tv_sec);
			return (EPERM);
		}
		/*
		 * If the system is secure, we do not allow the time to be
		 * set to an earlier value (it may be slowed using adjtime,
		 * but not set back). This feature prevent interlopers from
		 * setting arbitrary time stamps on files.
		 */
		if (securelevel > 1 && timercmp(&atv, &time, <)) {
			printf("denied attempt to set clock back %ld seconds\n",
			    time.tv_sec - atv.tv_sec);
			return (EPERM);
		}
		settime(&atv);
@


1.29
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.28 2002/02/17 06:11:05 art Exp $	*/
a82 1
	(void) spllowersoftclock();
@


1.29.2.1
log
@Pull in patch from current:
Fix (nordin):
which is int not u_int so check for negative values.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.29 2002/03/14 01:27:04 millert Exp $	*/
d429 1
a429 1
		syscallarg(int) which;
d435 1
a435 1
	if (SCARG(uap, which) < ITIMER_REAL || SCARG(uap, which) > ITIMER_PROF)
d468 1
a468 1
		syscallarg(int) which;
d477 1
a477 1
	if (SCARG(uap, which) < ITIMER_REAL || SCARG(uap, which) > ITIMER_PROF)
@


1.28
log
@Repeat. But this time get the math right and avoid sleeping forever.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.26 2002/02/15 15:59:11 art Exp $	*/
d58 2
a59 2
void	settime __P((struct timeval *));
void	itimerround __P((struct timeval *));
@


1.27
log
@undo latest commit for now, it breaks nanosleep
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.25 2001/12/12 19:06:47 nordin Exp $	*/
d192 1
a192 1
	register struct sys_nanosleep_args/* {
d198 1
a198 1
	struct timeval atv, utv;
d210 9
a218 7
	s = splclock();
	timeradd(&atv,&time,&atv);
	timo = hzto(&atv);
	splx(s);
	/* 
	 * Avoid inadvertantly sleeping forever
	 */
d232 1
a232 1
		utv = time;
d235 5
a239 3
		timersub(&atv, &utv, &utv);
		if (utv.tv_sec < 0)
			timerclear(&utv);
d241 1
a241 1
		TIMEVAL_TO_TIMESPEC(&utv, &rmt);
@


1.26
log
@Don't get confused in nanosleep(2) when the time changes.
There is no need to use 'time' when we can use 'mono_time'.
(oh and now it's faster too)
@
text
@d192 1
a192 1
	struct sys_nanosleep_args/* {
d198 1
a198 1
	struct timeval stv, etv, atv;
d210 9
a218 7
	if (SCARG(uap, rmtp)) {
		s = splclock();
		stv = mono_time;
		splx(s);
	}

	timo = tvtohz(&atv);
d230 1
a230 1
		etv = mono_time;
d233 3
a235 5
		timersub(&etv, &stv, &stv);
		timersub(&stv, &atv, &atv);

		if (atv.tv_sec < 0)
			timerclear(&atv);
d237 1
a237 1
		TIMEVAL_TO_TIMESPEC(&atv, &rmt);
@


1.25
log
@Handle itimer intervals smaller than the resolution of the clock; pr#2182.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.24 2001/06/25 03:28:03 csapuntz Exp $	*/
d192 1
a192 1
	register struct sys_nanosleep_args/* {
d198 1
a198 1
	struct timeval atv, utv;
d210 7
a216 9
	s = splclock();
	timeradd(&atv,&time,&atv);
	timo = hzto(&atv);
	splx(s);
	/* 
	 * Avoid inadvertantly sleeping forever
	 */
	if (timo <= 0)
		timo = 1;
d228 1
a228 1
		utv = time;
d231 5
a235 3
		timersub(&atv, &utv, &utv);
		if (utv.tv_sec < 0)
			timerclear(&utv);
d237 1
a237 1
		TIMEVAL_TO_TIMESPEC(&utv, &rmt);
@


1.25.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.25 2001/12/12 19:06:47 nordin Exp $	*/
d58 2
a59 2
void	settime(struct timeval *);
void	itimerround(struct timeval *);
d192 1
a192 1
	struct sys_nanosleep_args/* {
d198 1
a198 1
	struct timeval stv, etv, atv;
d210 7
a216 9
	if (SCARG(uap, rmtp)) {
		s = splclock();
		stv = mono_time;
		splx(s);
	}

	timo = tvtohz(&atv);

	/* Avoid sleeping forever. */
d230 1
a230 1
		etv = mono_time;
d233 3
a235 5
		timersub(&etv, &stv, &stv);
		timersub(&atv, &stv, &atv);

		if (atv.tv_sec < 0)
			timerclear(&atv);
d237 1
a237 1
		TIMEVAL_TO_TIMESPEC(&atv, &rmt);
@


1.25.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.25.2.1 2002/06/11 03:29:40 art Exp $	*/
d58 1
a58 1
int	settime(struct timeval *);
d72 3
a74 2
int
settime(struct timeval *tv)
a78 29
	/*
	 * Don't allow the time to be set forward so far it will wrap
	 * and become negative, thus allowing an attacker to bypass
	 * the next check below.  The cutoff is 1 year before rollover
	 * occurs, so even if the attacker uses adjtime(2) to move
	 * the time past the cutoff, it will take a very long time
	 * to get to the wrap point.
	 *
	 * XXX: we check against INT_MAX since on 64-bit
	 *	platforms, sizeof(int) != sizeof(long) and
	 *	time_t is 32 bits even when atv.tv_sec is 64 bits.
	 */
	if (tv->tv_sec > INT_MAX - 365*24*60*60) {
		printf("denied attempt to set clock forward to %ld\n",
		    tv->tv_sec);
		return (EPERM);
	}
	/*
	 * If the system is secure, we do not allow the time to be
	 * set to an earlier value (it may be slowed using adjtime,
	 * but not set back). This feature prevent interlopers from
	 * setting arbitrary time stamps on files.
	 */
	if (securelevel > 1 && timercmp(tv, &time, <)) {
		printf("denied attempt to set clock back %ld seconds\n",
		    time.tv_sec - tv->tv_sec);
		return (EPERM);
	}

d83 1
a87 2

	return (0);
d143 9
a151 1
	error = settime(&atv);
d153 1
a153 1
	return (error);
d302 29
a330 2
		if ((error = settime(&atv)) != 0)
			return (error);
d429 1
a429 1
		syscallarg(int) which;
d435 1
a435 1
	if (SCARG(uap, which) < ITIMER_REAL || SCARG(uap, which) > ITIMER_PROF)
d468 1
a468 1
		syscallarg(int) which;
d477 1
a477 1
	if (SCARG(uap, which) < ITIMER_REAL || SCARG(uap, which) > ITIMER_PROF)
@


1.24
log
@Remove NQNFS
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.23 2000/10/10 13:36:49 itojun Exp $	*/
d59 1
d497 2
a498 1
	} else
d500 1
d556 12
@


1.24.2.1
log
@Errata #032:
Incorrect argument checking in the setitimer(2) system call may allow an
attacker to write to kernel memory.
Fix (nordin):
which is int not u_int so check for negative values.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.24 2001/06/25 03:28:03 csapuntz Exp $	*/
d424 1
a424 1
		syscallarg(int) which;
d430 1
a430 1
	if (SCARG(uap, which) < ITIMER_REAL || SCARG(uap, which) > ITIMER_PROF)
d463 1
a463 1
		syscallarg(int) which;
d472 1
a472 1
	if (SCARG(uap, which) < ITIMER_REAL || SCARG(uap, which) > ITIMER_PROF)
@


1.23
log
@implement ppsratecheck(9).  from netbsd.
refer mono_time only once in ratecheck(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.22 2000/07/07 15:19:04 art Exp $	*/
a84 3
#	if defined(NFS) || defined(NFSSERVER)
		nqnfs_lease_updatetime(delta.tv_sec);
#	endif
@


1.22
log
@Be more paranoid about return values from hzto.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.21 2000/07/06 15:33:31 ho Exp $	*/
d610 1
a610 1
	struct timeval delta;
d614 4
a617 1
	timersub(&mono_time, lasttime, &delta);
d625 1
a625 1
		*lasttime = mono_time;
d628 18
d647 37
@


1.21
log
@Change splsoftclock() to spllowersoftclock(). (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.20 2000/07/05 08:10:57 pjanzen Exp $	*/
d215 1
d219 1
a219 1
	if (timo == 0)
a220 1
	splx(s);
d473 1
d493 4
a496 1
			timeout_add(&p->p_realit_to, hzto(&aitv.it_value));
d518 1
a518 1
	int s;
d531 4
a534 2
			timeout_add(&p->p_realit_to,
				    hzto(&p->p_realtimer.it_value));
d554 1
@


1.20
log
@Stop sleeps from returning early (by up to a clock tick).
From FreeBSD:  eventually, we should replace hzto() with something
like tvtohz() as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.19 2000/03/23 16:54:44 art Exp $	*/
d82 1
a82 1
	(void) splsoftclock();
@


1.19
log
@Don't reinitialize the tsleep and ITIMER_REAL timers all the time.
The function and the argument never change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.18 2000/03/23 15:55:52 art Exp $	*/
d538 1
a538 3
 * .it_interval part of an interval timer is acceptable, and
 * fix it to have at least minimal value (i.e. if it is less
 * than the resolution of the clock, round it up.)
a547 2
	if (tv->tv_sec == 0 && tv->tv_usec != 0 && tv->tv_usec < tick)
		tv->tv_usec = tick;
@


1.18
log
@Use the new timeout facilities for ITIMER_REAL.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.17 2000/03/17 22:24:26 jakob Exp $	*/
a491 1
			timeout_set(&p->p_realit_to, realitexpire, p);
@


1.17
log
@ratecheck - function to help implement rate-limited actions (from NetBSD)
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.16 2000/01/22 23:41:42 millert Exp $	*/
d489 1
a489 1
		untimeout(realitexpire, (void *)p);
d492 2
a493 1
			timeout(realitexpire, (void *)p, hzto(&aitv.it_value));
d528 2
a529 2
			timeout(realitexpire, (void *)p,
			    hzto(&p->p_realtimer.it_value));
@


1.16
log
@Don't allow the time to be set forward so far it will wrap and become negative,
thus allowing an attacker to bypass the next check below.  The cutoff is 1 year
before rollover occurs, so even if the attacker uses adjtime(2) to move the
time past the cutoff, it will take a very long time to get to the wrap point.
The actual check is tv_sec > INT_MAX - 365*24*60*60 because on 64 bit platforms
tv_sec is 64 bits but time_t is 32 bits.  This will need to be changed some
time in the future when the size of time_t changes.

Add a printf when a user tries to turn the clock backwards and securelevel > 1
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.15 1999/12/06 19:36:42 aaron Exp $	*/
d596 29
@


1.16.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d489 1
a489 1
		timeout_del(&p->p_realit_to);
d492 1
a492 1
			timeout_add(&p->p_realit_to, hzto(&aitv.it_value));
d527 2
a528 2
			timeout_add(&p->p_realit_to,
				    hzto(&p->p_realtimer.it_value));
a595 29
}

/*
 * ratecheck(): simple time-based rate-limit checking.  see ratecheck(9)
 * for usage and rationale.
 */
int
ratecheck(lasttime, mininterval)
	struct timeval *lasttime;
	const struct timeval *mininterval;
{
	struct timeval delta;
	int s, rv = 0;

	s = splclock(); 
	timersub(&mono_time, lasttime, &delta);

	/*
	 * check for 0,0 is so that the message will be seen at least once,
	 * even if interval is huge.
	 */
	if (timercmp(&delta, mininterval, >=) ||
	    (lasttime->tv_sec == 0 && lasttime->tv_usec == 0)) {
		*lasttime = mono_time;
		rv = 1;
	}
	splx(s);

	return (rv);
@


1.16.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.23 2000/10/10 13:36:49 itojun Exp $	*/
d82 1
a82 1
	(void) spllowersoftclock();
a214 1
	splx(s);
d218 1
a218 1
	if (timo <= 0)
d220 1
a472 1
	int timo;
d492 1
a492 4
			timo = hzto(&aitv.it_value);
			if (timo <= 0)
				timo = 1;
			timeout_add(&p->p_realit_to, timo);
d514 1
a514 1
	int s, timo;
d527 2
a528 4
			timo = hzto(&p->p_realtimer.it_value);
			if (timo <= 0)
				timo = 1;
			timeout_add(&p->p_realit_to, timo);
d538 3
a540 1
 * .it_interval part of an interval timer is acceptable.
d550 2
a551 1

d607 1
a607 1
	struct timeval tv, delta;
d611 1
a611 4
	tv = mono_time;
	splx(s);

	timersub(&tv, lasttime, &delta);
d619 1
a619 1
		*lasttime = tv;
a621 18

	return (rv);
}

/*
 * ppsratecheck(): packets (or events) per second limitation.
 */
int
ppsratecheck(lasttime, curpps, maxpps)
	struct timeval *lasttime;
	int *curpps;
	int maxpps;	/* maximum pps allowed */
{
	struct timeval tv, delta;
	int s, rv;

	s = splclock(); 
	tv = mono_time;
a622 37

	timersub(&tv, lasttime, &delta);

	/*
	 * check for 0,0 is so that the message will be seen at least once.
	 * if more than one second have passed since the last update of
	 * lasttime, reset the counter.
	 *
	 * we do increment *curpps even in *curpps < maxpps case, as some may
	 * try to use *curpps for stat purposes as well.
	 */
	if ((lasttime->tv_sec == 0 && lasttime->tv_usec == 0) ||
	    delta.tv_sec >= 1) {
		*lasttime = tv;
		*curpps = 0;
		rv = 1;
	} else if (maxpps < 0)
		rv = 1;
	else if (*curpps < maxpps)
		rv = 1;
	else
		rv = 0;

#if 1 /*DIAGNOSTIC?*/
	/* be careful about wrap-around */
	if (*curpps + 1 > *curpps)
		*curpps = *curpps + 1;
#else
	/*
	 * assume that there's not too many calls to this function.
	 * not sure if the assumption holds, as it depends on *caller's*
	 * behavior, not the behavior of this function.
	 * IMHO it is wrong to make assumption on the caller's behavior,
	 * so the above #if is #if 1, not #ifdef DIAGNOSTIC.
	 */
	*curpps = *curpps + 1;
#endif
@


1.16.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.16.2.2 2001/05/14 22:32:42 niklas Exp $	*/
d85 3
@


1.16.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a58 1
void	itimerround __P((struct timeval *));
d191 1
a191 1
	struct sys_nanosleep_args/* {
d197 1
a197 1
	struct timeval stv, etv, atv;
d209 7
a215 9
	if (SCARG(uap, rmtp)) {
		s = splclock();
		stv = mono_time;
		splx(s);
	}

	timo = tvtohz(&atv);

	/* Avoid sleeping forever. */
d229 1
a229 1
		etv = mono_time;
d232 3
a234 5
		timersub(&etv, &stv, &stv);
		timersub(&atv, &stv, &atv);

		if (atv.tv_sec < 0)
			timerclear(&atv);
d236 1
a236 1
		TIMEVAL_TO_TIMESPEC(&atv, &rmt);
d496 1
a496 2
	} else {
		itimerround(&aitv.it_interval);
a497 1
	}
a552 12
}

/*
 * Timer interval smaller than the resolution of the system clock are
 * rounded up.
 */
void
itimerround(tv)
	struct timeval *tv;
{
	if (tv->tv_sec == 0 && tv->tv_usec < tick)
		tv->tv_usec = tick;
@


1.16.2.5
log
@Merge in -current from about a week ago
@
text
@d58 2
a59 2
void	settime(struct timeval *);
void	itimerround(struct timeval *);
@


1.16.2.6
log
@Sync the SMP branch with 3.3
@
text
@d58 1
a58 1
int	settime(struct timeval *);
d72 3
a74 2
int
settime(struct timeval *tv)
a78 29
	/*
	 * Don't allow the time to be set forward so far it will wrap
	 * and become negative, thus allowing an attacker to bypass
	 * the next check below.  The cutoff is 1 year before rollover
	 * occurs, so even if the attacker uses adjtime(2) to move
	 * the time past the cutoff, it will take a very long time
	 * to get to the wrap point.
	 *
	 * XXX: we check against INT_MAX since on 64-bit
	 *	platforms, sizeof(int) != sizeof(long) and
	 *	time_t is 32 bits even when atv.tv_sec is 64 bits.
	 */
	if (tv->tv_sec > INT_MAX - 365*24*60*60) {
		printf("denied attempt to set clock forward to %ld\n",
		    tv->tv_sec);
		return (EPERM);
	}
	/*
	 * If the system is secure, we do not allow the time to be
	 * set to an earlier value (it may be slowed using adjtime,
	 * but not set back). This feature prevent interlopers from
	 * setting arbitrary time stamps on files.
	 */
	if (securelevel > 1 && timercmp(tv, &time, <)) {
		printf("denied attempt to set clock back %ld seconds\n",
		    time.tv_sec - tv->tv_sec);
		return (EPERM);
	}

d83 1
a87 2

	return (0);
d143 9
a151 1
	error = settime(&atv);
d153 1
a153 1
	return (error);
d302 29
a330 2
		if ((error = settime(&atv)) != 0)
			return (error);
d429 1
a429 1
		syscallarg(int) which;
d435 1
a435 1
	if (SCARG(uap, which) < ITIMER_REAL || SCARG(uap, which) > ITIMER_PROF)
d468 1
a468 1
		syscallarg(int) which;
d477 1
a477 1
	if (SCARG(uap, which) < ITIMER_REAL || SCARG(uap, which) > ITIMER_PROF)
@


1.16.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.16.2.6 2003/03/28 00:41:26 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d49 6
@


1.16.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a122 1
	int s;
d125 1
a125 11
	switch (clock_id) {
	case CLOCK_REALTIME:
		microtime(&atv);
		break;
	case CLOCK_MONOTONIC:
		/* XXX "hz" granularity */
		s = splclock();
		atv = mono_time;
		splx(s);
		break;
	default:
a126 1
	}
d128 1
d150 1
a150 1
	if ((error = suser(p, 0)) != 0)
d153 4
d160 3
a162 12
	clock_id = SCARG(uap, clock_id);
	switch (clock_id) {
	case CLOCK_REALTIME:
		TIMESPEC_TO_TIMEVAL(&atv, &ats);
		if ((error = settime(&atv)) != 0)
			return (error);
		break;
	case CLOCK_MONOTONIC:
		return (EINVAL);	/* read-only clock */
	default:
		return (EINVAL);
	}
d164 1
a164 1
	return (0);
d182 4
a185 3
	switch (clock_id) {
	case CLOCK_REALTIME:
	case CLOCK_MONOTONIC:
a187 4
		break;
	default:
		return (EINVAL);
	}
a188 1
	if (SCARG(uap, tp))
d190 1
d296 2
a297 2
		syscallarg(const struct timeval *) tv;
		syscallarg(const struct timezone *) tzp;
d303 1
a303 1
	if ((error = suser(p, 0)))
d333 1
a333 1
		syscallarg(const struct timeval *) delta;
d340 1
a340 1
	if ((error = suser(p, 0)))
d453 1
a453 1
		syscallarg(const struct itimerval *) itv;
@


1.16.2.9
log
@Make a few scheduling globals per-cpu, mostly NetBSD code
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.16.2.8 2004/02/19 10:56:37 niklas Exp $	*/
a65 3
#ifdef MULTIPROCESSOR
	struct cpu_info *ci;
#endif
a100 1
	(void)spllowersoftclock();
a101 11
#ifdef MULTIPROCESSOR
	/*
	 * XXXSMP
	 * This is wrong.  We should traverse a list of all
	 * CPUs and add the delta to the runtime of those
	 * CPUs which have a process on them.
	 */
	ci = curcpu();
	timeradd(&ci->ci_schedstate.spc_runtime, &delta,
	    &ci->ci_schedstate.spc_runtime);
#else
a102 1
#endif
@


1.16.2.10
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a490 1
	struct sys_getitimer_args getargs;
d502 3
a504 6
	if (SCARG(uap, oitv) != NULL) {
		SCARG(&getargs, which) = SCARG(uap, which);
		SCARG(&getargs, itv) = SCARG(uap, oitv);
		if ((error = sys_getitimer(p, &getargs, retval)))
			return (error);
	}
@


1.16.2.11
log
@Don't lower to softclock in settime. Sure, it's not very incorrect, but it
hardly buys us anything and it increases the diff.

niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.16.2.10 2004/06/05 23:13:01 niklas Exp $	*/
d104 1
@


1.16.2.12
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 3
d105 1
a105 1
#ifdef __HAVE_CPUINFO
d112 3
a114 2
	timeradd(&curcpu()->ci_schedstate.spc_runtime, &delta,
	    &curcpu()->ci_schedstate.spc_runtime);
@


1.15
log
@Implement compatibility for Linux stime() syscall.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.14 1999/06/06 19:21:34 deraadt Exp $	*/
d301 17
d323 3
a325 1
		if (securelevel > 1 && timercmp(&atv, &time, <))
d327 1
@


1.14
log
@-Wall sucks
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.13 1999/06/06 19:15:03 deraadt Exp $	*/
d58 1
a58 1
static void	settime __P((struct timeval *));
d71 1
a71 1
static void
@


1.13
log
@adjtime(2) did not return EFAULT for bad olddelta ptr; darrenr@@merlin.reed.wattle.id.au
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.12 1998/02/20 14:51:56 niklas Exp $	*/
d371 2
a372 2
		if (error = copyout((void *)&atv, (void *)SCARG(uap, olddelta),
		    sizeof(struct timeval)))
@


1.12
log
@Please GCC 2.8's harsher view of good style
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.11 1998/02/08 22:41:35 tholo Exp $	*/
d371 3
a373 2
		(void)copyout((void *)&atv, (void *)SCARG(uap, olddelta),
		    sizeof(struct timeval));
@


1.11
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.10 1997/10/17 04:41:10 millert Exp $	*/
d423 1
a423 1
		if (timerisset(&aitv.it_value))
d427 3
a429 1
				timersub(&aitv.it_value, &time, &aitv.it_value);
@


1.10
log
@Don't allow root to set the clock back in time if securelevel > 1.  This
got nuked when settime() was added.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.9 1997/04/28 01:33:47 niklas Exp $	*/
d448 1
a448 1
	register struct itimerval *itvp;
@


1.9
log
@The type of a pointer to const characters is not the same as a const pointer
to non-const characters.  Besides, the prototypes for copyin and friends, as
well as timeout/untimeout takes void *, not caddr_t (char *), so I matched
them.  Slight KNF.  This change makes it pass -Wcast-qual.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.8 1997/04/26 10:38:30 tholo Exp $	*/
d144 9
d155 1
a155 1
	return 0;
d299 9
a307 1
	if (SCARG(uap, tv))
d309 1
@


1.8
log
@First argument to nanosleep(2) is const; so is the first argument to
copyin(9).  Propagate this.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.7 1997/04/23 09:52:03 tholo Exp $	*/
d194 2
a195 2
	error = copyin((const caddr_t)SCARG(uap, rqtp), (caddr_t)&rqt,
		       sizeof(struct timespec));
d230 3
a232 3
		TIMEVAL_TO_TIMESPEC(&utv,&rmt);
		error = copyout((caddr_t)&rmt, (caddr_t)SCARG(uap,rmtp),
			sizeof(rmt));		
d256 1
a256 1
		if ((error = copyout((caddr_t)&atv, (caddr_t)SCARG(uap, tp),
d261 1
a261 1
		error = copyout((caddr_t)&tz, (caddr_t)SCARG(uap, tzp),
d284 2
a285 2
	if (SCARG(uap, tv) && (error = copyin((caddr_t)SCARG(uap, tv),
	    (caddr_t)&atv, sizeof(atv))))
d287 2
a288 2
	if (SCARG(uap, tzp) && (error = copyin((caddr_t)SCARG(uap, tzp),
	    (caddr_t)&atz, sizeof(atz))))
d318 1
a318 1
	if ((error = copyin((caddr_t)SCARG(uap, delta), (caddr_t)&atv,
d353 1
a353 1
		(void) copyout((caddr_t)&atv, (caddr_t)SCARG(uap, olddelta),
d413 1
a413 1
	return (copyout((caddr_t)&aitv, (caddr_t)SCARG(uap, itv),
d436 1
a436 1
	if (itvp && (error = copyin((caddr_t)itvp, (caddr_t)&aitv,
d448 1
a448 1
		untimeout(realitexpire, (caddr_t)p);
d451 1
a451 1
			timeout(realitexpire, (caddr_t)p, hzto(&aitv.it_value));
d486 1
a486 1
			timeout(realitexpire, (caddr_t)p,
@


1.7
log
@In nanosleep, use local error variable when storing rqtp in so that an error
from a failed tsleep will still be returned to the caller; from jtc@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.6 1997/04/20 20:49:42 tholo Exp $	*/
d186 1
a186 1
		syscallarg(struct timespec *) rqtp;
d194 1
a194 1
	error = copyin((caddr_t)SCARG(uap, rqtp), (caddr_t)&rqt,
@


1.6
log
@Add new POSIX 1003.1b related syscalls; from pk@@NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.5 1997/03/16 01:18:48 flipk Exp $	*/
d220 2
d233 2
@


1.5
log
@allow settimeofday() at securelevel < 2, rather than < 1.
the consensus was that it was too annoying to not be able to change
the clock at securelevel == 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.4 1997/02/22 08:28:28 millert Exp $	*/
d58 2
d70 166
d273 1
a273 1
	struct timeval atv, delta;
d275 1
a275 1
	int error, s;
d286 2
a287 22
	if (SCARG(uap, tv)) {
		/*
		 * If the system is secure, we do not allow the time to be
		 * set to an earlier value (it may be slowed using adjtime,
		 * but not set back). This feature prevent interlopers from
		 * setting arbitrary time stamps on files.
		 */
		if (securelevel > 1 && timercmp(&atv, &time, <))
			return (EPERM);
		/* WHAT DO WE DO ABOUT PENDING REAL-TIME TIMEOUTS??? */
		s = splclock();
		timersub(&atv, &time, &delta);
		time = atv;
		(void) splsoftclock();
		timeradd(&boottime, &delta, &boottime);
		timeradd(&runtime, &delta, &runtime);
# 		if defined(NFSCLIENT) || defined(NFSSERVER)
			nqnfs_lease_updatetime(delta.tv_sec);
#		endif
		splx(s);
		resettodr();
	}
@


1.4
log
@Upodate to lite2 -- don't allow setting back the clock if securelevel > 0
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_time.c,v 1.20 1996/02/18 11:57:06 fvdl Exp $	*/
d125 1
a125 1
		if (securelevel > 0 && timercmp(&atv, &time, <))
@


1.3
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
d36 1
a36 1
 *	@@(#)kern_time.c	8.1 (Berkeley) 6/10/93
d84 2
a85 3
		error = copyout((caddr_t)&atv, (caddr_t)SCARG(uap, tp),
				sizeof (atv));
		if (error)
d109 1
a109 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d119 8
d164 1
a164 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d166 2
a167 4

	error = copyin((caddr_t)SCARG(uap, delta), (caddr_t)&atv,
		       sizeof(struct timeval));
	if (error)
d296 1
a296 1
		untimeout(realitexpire, p);
d299 1
a299 1
			timeout(realitexpire, p, hzto(&aitv.it_value));
d334 1
a334 1
			timeout(realitexpire, p,
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$NetBSD: kern_time.c,v 1.19 1996/02/13 21:10:43 christos Exp $	*/
d50 2
d127 1
a127 1
			lease_updatetime(delta.tv_sec);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: kern_time.c,v 1.16 1995/10/07 06:28:28 mycroft Exp $	*/
d45 1
d50 4
d82 3
a84 2
		if (error = copyout((caddr_t)&atv, (caddr_t)SCARG(uap, tp),
		    sizeof (atv)))
d108 1
a108 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d155 1
a155 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d157 4
a160 2
	if (error = copyin((caddr_t)SCARG(uap, delta), (caddr_t)&atv,
	    sizeof(struct timeval)))
d262 1
a262 1
	void *v;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
