head	1.38;
access;
symbols
	OPENBSD_6_1:1.38.0.2
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.33.0.6
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.6
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.13
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.8
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.6
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.4
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.9.0.2
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.8.0.4
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2016.09.15.02.00.16;	author dlg;	state Exp;
branches;
next	1.37;
commitid	RlO92XR575sygHqm;

1.37
date	2016.08.25.00.01.13;	author dlg;	state Exp;
branches;
next	1.36;
commitid	qGDK47LQhxLxADuT;

1.36
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.35;
commitid	p4LJxGKbi0BU2cG6;

1.35
date	2014.12.19.05.59.21;	author tedu;	state Exp;
branches;
next	1.34;
commitid	zdJTCwdpqRUwO1SL;

1.34
date	2014.09.08.01.47.06;	author guenther;	state Exp;
branches;
next	1.33;
commitid	QKTb36RFnfteZJPE;

1.33
date	2013.09.24.09.20.12;	author espie;	state Exp;
branches;
next	1.32;

1.32
date	2013.06.03.15.54.48;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.28.03.27.46;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2012.08.23.06.12.49;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.07.13.42.53;	author thib;	state Exp;
branches;
next	1.28;

1.28
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.27;

1.27
date	2010.09.10.16.34.08;	author thib;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.14.21.24.08;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2008.05.16.17.45.37;	author thib;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.16.17.37.52;	author thib;	state Exp;
branches;
next	1.21;

1.21
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.29.16.25.07;	author thib;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.06.13.07.48;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.14.04.00.33;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.18.01.51.57;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.24.22.00.24;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.28.07;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.20.05.27.40;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.27.06;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.22.14.14.10;	author deraadt;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2000.09.27.16.13.46;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	99.02.19.18.02.48;	author art;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	98.02.20.14.51.59;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.58.27;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.20.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.12.39;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.02.24.14.20.02;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.11.11.15.35.19;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.13.38.56;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.47;	author deraadt;	state Exp;
branches;
next	;

1.9.6.1
date	2001.05.14.22.32.46;	author niklas;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2001.07.04.10.48.50;	author niklas;	state Exp;
branches;
next	1.9.6.3;

1.9.6.3
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.9.6.4;

1.9.6.4
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.9.6.5;

1.9.6.5
date	2003.06.07.11.03.41;	author ho;	state Exp;
branches;
next	1.9.6.6;

1.9.6.6
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	1.9.6.7;

1.9.6.7
date	2004.06.05.23.13.03;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.38
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@/*	$OpenBSD: vfs_init.c,v 1.37 2016/08/25 00:01:13 dlg Exp $	*/
/*	$NetBSD: vfs_init.c,v 1.6 1996/02/09 19:00:58 christos Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed
 * to Berkeley by John Heidemann of the UCLA Ficus project.
 *
 * Source: * @@(#)i405_init.c 2.10 92/04/27 UCLA Ficus project
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vfs_init.c	8.3 (Berkeley) 1/4/94
 */

#include <sys/param.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/pool.h>

struct pool namei_pool;

/* This defines the root filesystem. */
struct vnode *rootvnode;

/* Set up the filesystem operations for vnodes. */
#ifdef FFS
extern	const struct vfsops ffs_vfsops;
#endif

#ifdef MFS
extern	const struct vfsops mfs_vfsops;
#endif

#ifdef MSDOSFS
extern	const struct vfsops msdosfs_vfsops;
#endif

#ifdef NFSCLIENT
extern	const struct vfsops nfs_vfsops;
#endif

#ifdef CD9660
extern	const struct vfsops cd9660_vfsops;
#endif

#ifdef EXT2FS
extern	const struct vfsops ext2fs_vfsops;
#endif

#ifdef NTFS
extern  const struct vfsops ntfs_vfsops;
#endif

#ifdef UDF
extern  const struct vfsops udf_vfsops;
#endif

#ifdef FUSE
extern const struct vfsops fusefs_vfsops;
#endif

#ifdef TMPFS
extern  const struct vfsops tmpfs_vfsops;
#endif

/* Set up the filesystem operations for vnodes. */
static struct vfsconf vfsconflist[] = {
#ifdef FFS
        { &ffs_vfsops, MOUNT_FFS, 1, 0, MNT_LOCAL, NULL },
#endif

#ifdef MFS
        { &mfs_vfsops, MOUNT_MFS, 3, 0, MNT_LOCAL, NULL },
#endif

#ifdef EXT2FS
	{ &ext2fs_vfsops, MOUNT_EXT2FS, 17, 0, MNT_LOCAL, NULL },
#endif

#ifdef CD9660
        { &cd9660_vfsops, MOUNT_CD9660, 14, 0, MNT_LOCAL, NULL },
#endif

#ifdef MSDOSFS
        { &msdosfs_vfsops, MOUNT_MSDOS, 4, 0, MNT_LOCAL, NULL },
#endif

#ifdef NFSCLIENT
        { &nfs_vfsops, MOUNT_NFS, 2, 0, 0, NULL },
#endif

#ifdef NTFS
	{ &ntfs_vfsops, MOUNT_NTFS, 6, 0, MNT_LOCAL, NULL },
#endif

#ifdef UDF
	{ &udf_vfsops, MOUNT_UDF, 13, 0, MNT_LOCAL, NULL },
#endif

#ifdef FUSE
	{ &fusefs_vfsops, MOUNT_FUSEFS, 18, 0, MNT_LOCAL, NULL },
#endif

#ifdef TMPFS
	{ &tmpfs_vfsops, MOUNT_TMPFS, 19, 0, MNT_LOCAL, NULL },
#endif
};


/*
 * Initially the size of the list, vfsinit will set maxvfsconf
 * to the highest defined type number.
 */
int maxvfsconf = sizeof(vfsconflist) / sizeof(struct vfsconf);
struct vfsconf *vfsconf = vfsconflist;

/* Initialize the vnode structures and initialize each file system type. */
void
vfsinit(void)
{
	int i;
	struct vfsconf *vfsconflist;
	int vfsconflistlen;

	pool_init(&namei_pool, MAXPATHLEN, 0, IPL_NONE, PR_WAITOK, "namei",
	    NULL);

	/* Initialize the vnode table. */
	vntblinit();

	/* Initialize the vnode name cache. */
	nchinit();

	/*
	 * Stop using vfsconf and maxvfsconf as a temporary storage,
	 * set them to their correct values now.
	 */
	vfsconflist = vfsconf;
	vfsconflistlen = maxvfsconf;
	vfsconf = NULL;
	maxvfsconf = 0;

	for (i = 0; i < vfsconflistlen; i++)
		vfs_register(&vfsconflist[i]);
}
@


1.37
log
@pool_setipl

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.36 2015/03/14 03:38:51 jsg Exp $	*/
d151 2
a152 2
	pool_init(&namei_pool, MAXPATHLEN, 0, 0, PR_WAITOK, "namei", NULL);
	pool_setipl(&namei_pool, IPL_NONE);
@


1.36
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.35 2014/12/19 05:59:21 tedu Exp $	*/
d152 1
@


1.35
log
@start retiring the nointr allocator. specify PR_WAITOK as a flag as a
marker for which pools are not interrupt safe. ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.34 2014/09/08 01:47:06 guenther Exp $	*/
a43 1
#include <sys/systm.h>
@


1.34
log
@Delete procfs; it's always had races and is now unused: no one noticed for
months that I broke it before the 5.5 release.

confirmed as not being required by ports by sthen@@, ajacoutot@@, dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.33 2013/09/24 09:20:12 espie Exp $	*/
d152 1
a152 2
	pool_init(&namei_pool, MAXPATHLEN, 0, 0, 0, "namei",
	    &pool_allocator_nointr);
@


1.33
log
@a bit more tmpfs scaffolding (still not active, no kernel change)
reduces the actual diff needed, and allows one to build mount_tmpfs
without reinstalling the includes.

(still awaiting review on the uvm bits)

okay krw@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.32 2013/06/03 15:54:48 tedu Exp $	*/
a68 4
#ifdef PROCFS
extern	const struct vfsops procfs_vfsops;
#endif

a116 4
#endif

#ifdef PROCFS
        { &procfs_vfsops, MOUNT_PROCFS, 12, 0, 0, NULL },
@


1.32
log
@changes for isc fuse support. not enabled. ok beck deraadt.
from Sylvestre Gallon ccna.syl gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.31 2013/03/28 03:27:46 tedu Exp $	*/
d93 4
d137 4
@


1.31
log
@no need for vnode.h to include namei.h unconditionally
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.30 2012/08/23 06:12:49 deraadt Exp $	*/
d89 4
d129 4
@


1.30
log
@kill nnpfs dead
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.29 2011/04/07 13:42:53 thib Exp $	*/
d42 1
@


1.29
log
@merge vfs_conf.c and vfs_init.c and retire vfs_conf.c;

The contents belong togather a long with other crud,
that should get moved at some point.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.27 2010/09/10 16:34:08 thib Exp $	*/
a79 4
#ifdef NNPFS
extern  const struct vfsops nnpfs_vfsops;
#endif

a111 4
#endif

#ifdef NNPFS
	{ &nnpfs_vfsops, MOUNT_NNPFS, 21, 0, 0, NULL },
@


1.28
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@a41 1
#include <sys/time.h>
d43 1
a43 6
#include <sys/stat.h>
#include <sys/namei.h>
#include <sys/ucred.h>
#include <sys/buf.h>
#include <sys/errno.h>
#include <sys/malloc.h>
a44 1
#include <sys/systm.h>
d47 95
@


1.27
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.26 2010/09/06 23:44:10 thib Exp $	*/
a52 6
/* a list of lists of vnodeops defns */
extern struct vnodeopv_desc *vfs_opv_descs[];

/* and the operations they perform */
extern struct vnodeop_desc *vfs_op_descs[];

d55 1
a55 136
/*
 * This code doesn't work if the defn is **vnodop_defns with cc.
 * The problem is because of the compiler sometimes putting in an
 * extra level of indirection for arrays.  It's an interesting
 * "feature" of C.
 */
int vfs_opv_numops;

typedef int (*PFI)(void *);

/*
 * vfs_init.c
 *
 * Allocate and fill in operations vectors.
 *
 * An undocumented feature of this approach to defining operations is that
 * there can be multiple entries in vfs_opv_descs for the same operations
 * vector. This allows third parties to extend the set of operations
 * supported by another layer in a binary compatible way. For example,
 * assume that NFS needed to be modified to support Ficus. NFS has an entry
 * (probably nfs_vnopdeop_decls) declaring all the operations NFS supports by
 * default. Ficus could add another entry (ficus_nfs_vnodeop_decl_entensions)
 * listing those new operations Ficus adds to NFS, all without modifying the
 * NFS code. (Of course, the OTW NFS protocol still needs to be munged, but
 * that is a(whole)nother story.) This is a feature.
 */

/*
 * Allocate and init the vector, if it needs it.
 * Also handle backwards compatibility.
 */
void
vfs_opv_init_explicit(struct vnodeopv_desc *vfs_opv_desc)
{
	int (**opv_desc_vector)(void *);
	struct vnodeopv_entry_desc *opve_descp;

	opv_desc_vector = *(vfs_opv_desc->opv_desc_vector_p);

	if (opv_desc_vector == NULL) {
		/* XXX - shouldn't be M_VNODE */
		opv_desc_vector = malloc(vfs_opv_numops * sizeof(PFI),
		    M_VNODE, M_WAITOK|M_ZERO);
		*(vfs_opv_desc->opv_desc_vector_p) = opv_desc_vector;
	}

	for (opve_descp = vfs_opv_desc->opv_desc_ops;
	    opve_descp->opve_op; opve_descp++) {
		/*
		 * Sanity check:  is this operation listed
		 * in the list of operations?  We check this
		 * by seeing if its offset is zero.  Since
		 * the default routine should always be listed
		 * first, it should be the only one with a zero
		 * offset.  Any other operation with a zero
		 * offset is probably not listed in
		 * vfs_op_descs, and so is probably an error.
		 *
		 * A panic here means the layer programmer
		 * has committed the all-too common bug
		 * of adding a new operation to the layer's
		 * list of vnode operations but
		 * not adding the operation to the system-wide
		 * list of supported operations.
		 */
		if (opve_descp->opve_op->vdesc_offset == 0 &&
		    opve_descp->opve_op != VDESC(vop_default)) {                
			printf("operation %s not listed in %s.\n",
			    opve_descp->opve_op->vdesc_name, "vfs_op_descs");
			panic ("vfs_opv_init: bad operation");
		}

		/*
		 * Fill in this entry.
		 */
		opv_desc_vector[opve_descp->opve_op->vdesc_offset] =
		    opve_descp->opve_impl;
	}
}

void
vfs_opv_init_default(struct vnodeopv_desc *vfs_opv_desc)
{
	int j;
	int (**opv_desc_vector)(void *);

	opv_desc_vector = *(vfs_opv_desc->opv_desc_vector_p);

	/*
	 * Force every operations vector to have a default routine.
	 */
	if (opv_desc_vector[VOFFSET(vop_default)] == NULL)
		panic("vfs_opv_init: operation vector without default routine.");

	for (j = 0; j < vfs_opv_numops; j++)
		if (opv_desc_vector[j] == NULL)
			opv_desc_vector[j] =
			    opv_desc_vector[VOFFSET(vop_default)];
}

/* Initialize known vnode operations vectors. */
void
vfs_op_init(void)
{
	int i;

	/* Set all vnode vectors to a well known value. */
	for (i = 0; vfs_opv_descs[i]; i++)
		*(vfs_opv_descs[i]->opv_desc_vector_p) = NULL;

	/*
	 * Figure out how many ops there are by counting the table,
	 * and assign each its offset.
	 */
	for (vfs_opv_numops = 0, i = 0; vfs_op_descs[i]; i++) {
		vfs_op_descs[i]->vdesc_offset = vfs_opv_numops;
		vfs_opv_numops++;
	}

	/* Allocate the dynamic vectors and fill them in. */
	for (i = 0; vfs_opv_descs[i]; i++)
		vfs_opv_init_explicit(vfs_opv_descs[i]);

	/*
	 * Finally, go back and replace unfilled routines
	 * with their default.
	 */
	for (i = 0; vfs_opv_descs[i]; i++)
		vfs_opv_init_default(vfs_opv_descs[i]);

}


/*
 * Initialize the vnode structures and initialize each file system type.
 */
d66 1
a66 3
	/*
	 * Initialize the vnode table
	 */
d68 2
a69 3
	/*
	 * Initialize the vnode name cache
	 */
a70 4
	/*
	 * Build vnode operation vectors.
	 */
	vfs_op_init();
@


1.26
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.25 2010/01/14 23:12:11 schwarze Exp $	*/
d53 6
d61 136
a196 1
/* Initialize the vnode structures and initialize each file system type. */
d207 3
a209 1
	/* Initialize the vnode table. */
d211 3
a213 2

	/* Initialize the vnode name cache. */
d215 4
@


1.25
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.24 2009/01/14 21:24:08 fgsch Exp $	*/
a52 6
/* a list of lists of vnodeops defns */
extern struct vnodeopv_desc *vfs_opv_descs[];

/* and the operations they perform */
extern struct vnodeop_desc *vfs_op_descs[];

d55 1
a55 136
/*
 * This code doesn't work if the defn is **vnodop_defns with cc.
 * The problem is because of the compiler sometimes putting in an
 * extra level of indirection for arrays.  It's an interesting
 * "feature" of C.
 */
int vfs_opv_numops;

typedef int (*PFI)(void *);

/*
 * vfs_init.c
 *
 * Allocate and fill in operations vectors.
 *
 * An undocumented feature of this approach to defining operations is that
 * there can be multiple entries in vfs_opv_descs for the same operations
 * vector. This allows third parties to extend the set of operations
 * supported by another layer in a binary compatible way. For example,
 * assume that NFS needed to be modified to support Ficus. NFS has an entry
 * (probably nfs_vnopdeop_decls) declaring all the operations NFS supports by
 * default. Ficus could add another entry (ficus_nfs_vnodeop_decl_entensions)
 * listing those new operations Ficus adds to NFS, all without modifying the
 * NFS code. (Of course, the OTW NFS protocol still needs to be munged, but
 * that is a(whole)nother story.) This is a feature.
 */

/*
 * Allocate and init the vector, if it needs it.
 * Also handle backwards compatibility.
 */
void
vfs_opv_init_explicit(struct vnodeopv_desc *vfs_opv_desc)
{
	int (**opv_desc_vector)(void *);
	struct vnodeopv_entry_desc *opve_descp;

	opv_desc_vector = *(vfs_opv_desc->opv_desc_vector_p);

	if (opv_desc_vector == NULL) {
		/* XXX - shouldn't be M_VNODE */
		opv_desc_vector = malloc(vfs_opv_numops * sizeof(PFI),
		    M_VNODE, M_WAITOK|M_ZERO);
		*(vfs_opv_desc->opv_desc_vector_p) = opv_desc_vector;
	}

	for (opve_descp = vfs_opv_desc->opv_desc_ops;
	    opve_descp->opve_op; opve_descp++) {
		/*
		 * Sanity check:  is this operation listed
		 * in the list of operations?  We check this
		 * by seeing if its offset is zero.  Since
		 * the default routine should always be listed
		 * first, it should be the only one with a zero
		 * offset.  Any other operation with a zero
		 * offset is probably not listed in
		 * vfs_op_descs, and so is probably an error.
		 *
		 * A panic here means the layer programmer
		 * has committed the all-too common bug
		 * of adding a new operation to the layer's
		 * list of vnode operations but
		 * not adding the operation to the system-wide
		 * list of supported operations.
		 */
		if (opve_descp->opve_op->vdesc_offset == 0 &&
		    opve_descp->opve_op != VDESC(vop_default)) {                
			printf("operation %s not listed in %s.\n",
			    opve_descp->opve_op->vdesc_name, "vfs_op_descs");
			panic ("vfs_opv_init: bad operation");
		}

		/*
		 * Fill in this entry.
		 */
		opv_desc_vector[opve_descp->opve_op->vdesc_offset] =
		    opve_descp->opve_impl;
	}
}

void
vfs_opv_init_default(struct vnodeopv_desc *vfs_opv_desc)
{
	int j;
	int (**opv_desc_vector)(void *);

	opv_desc_vector = *(vfs_opv_desc->opv_desc_vector_p);

	/*
	 * Force every operations vector to have a default routine.
	 */
	if (opv_desc_vector[VOFFSET(vop_default)] == NULL)
		panic("vfs_opv_init: operation vector without default routine.");

	for (j = 0; j < vfs_opv_numops; j++)
		if (opv_desc_vector[j] == NULL)
			opv_desc_vector[j] =
			    opv_desc_vector[VOFFSET(vop_default)];
}

/* Initialize known vnode operations vectors. */
void
vfs_op_init(void)
{
	int i;

	/* Set all vnode vectors to a well known value. */
	for (i = 0; vfs_opv_descs[i]; i++)
		*(vfs_opv_descs[i]->opv_desc_vector_p) = NULL;

	/*
	 * Figure out how many ops there are by counting the table,
	 * and assign each its offset.
	 */
	for (vfs_opv_numops = 0, i = 0; vfs_op_descs[i]; i++) {
		vfs_op_descs[i]->vdesc_offset = vfs_opv_numops;
		vfs_opv_numops++;
	}

	/* Allocate the dynamic vectors and fill them in. */
	for (i = 0; vfs_opv_descs[i]; i++)
		vfs_opv_init_explicit(vfs_opv_descs[i]);

	/*
	 * Finally, go back and replace unfilled routines
	 * with their default.
	 */
	for (i = 0; vfs_opv_descs[i]; i++)
		vfs_opv_init_default(vfs_opv_descs[i]);

}


/*
 * Initialize the vnode structures and initialize each file system type.
 */
d66 1
a66 3
	/*
	 * Initialize the vnode table
	 */
d68 2
a69 3
	/*
	 * Initialize the vnode name cache
	 */
a70 4
	/*
	 * Build vnode operation vectors.
	 */
	vfs_op_init();
@


1.24
log
@correct test when checking the default operation entry.
from patrick keshishian <sidster at boxsoft dot com>
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.23 2008/05/16 17:45:37 thib Exp $	*/
d79 1
a79 1
 * supported by another layer in a binary compatibile way. For example,
d84 1
a84 1
 * NFS code. (Of couse, the OTW NFS protocol still needs to be munged, but
@


1.23
log
@merge vfs_opv_init into vfs_op_init and remove the former,
as they where called consecutively in vfs_init.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.22 2008/05/16 17:37:52 thib Exp $	*/
d127 1
a127 1
		    opve_descp->opve_op->vdesc_offset != VOFFSET(vop_default)) {
@


1.22
log
@
remove some old debug cruft, make some comments nicer
and shuffle declerations around.

OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.21 2008/05/08 17:45:45 thib Exp $	*/
d161 1
d163 1
a163 1
vfs_opv_init(void)
d167 4
d172 2
a173 1
	 * Allocate the dynamic vectors and fill them in.
d175 6
a189 1
}
a190 21
/*
 * Initialize known vnode operations vectors.
 */
void
vfs_op_init(void)
{
	int i;

	/*
	 * Set all vnode vectors to a well known value.
	 */
	for (i = 0; vfs_opv_descs[i]; i++)
		*(vfs_opv_descs[i]->opv_desc_vector_p) = NULL;
	/*
	 * Figure out how many ops there are by counting the table,
	 * and assign each its offset.
	 */
	for (vfs_opv_numops = 0, i = 0; vfs_op_descs[i]; i++) {
		vfs_op_descs[i]->vdesc_offset = vfs_opv_numops;
		vfs_opv_numops++;
	}
a218 1
	vfs_opv_init();   /* finish the job */
@


1.21
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.20 2007/09/07 15:00:20 art Exp $	*/
d53 2
a54 8
/*
 * Sigh, such primitive tools are these...
 */
#if 0
#define DODEBUG(A) A
#else
#define DODEBUG(A)
#endif
d56 1
a56 2
extern struct vnodeopv_desc *vfs_opv_descs[];
				/* a list of lists of vnodeops defns */
d58 3
a60 1
				/* and the operations they perform */
a104 2
		DODEBUG(printf("vector at %p allocated\n",
		    opv_desc_vector));
a187 1
	DODEBUG(printf("Vnode_interface_init.\n"));
a200 1
	DODEBUG(printf ("vfs_opv_numops=%d\n", vfs_opv_numops));
a202 4
/*
 * Routines having to do with the management of the vnode table.
 */
struct pool namei_pool;
@


1.20
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.19 2007/05/29 16:25:07 thib Exp $	*/
a74 12

/*
 * A miscellaneous routine.
 * A generic "default" routine that just returns an error.
 */
/*ARGSUSED*/
int
vn_default_error(void *v)
{

	return (EOPNOTSUPP);
}
@


1.19
log
@Nuke the predefined vattr, it was only used for !DIAGNOSTIC,
this shrinks the i386 RAMDISK a bit.
(Using the predefined vattr for GENERIC meant a growth of
 416bytes without any measurable perfomance gain).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.18 2005/11/06 13:07:48 pedro Exp $	*/
d120 1
a120 2
		    M_VNODE, M_WAITOK);
		bzero(opv_desc_vector, vfs_opv_numops * sizeof(PFI));
@


1.18
log
@Use ANSI-style function declarations, no binary change, okay jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.17 2004/05/14 04:00:33 tedu Exp $	*/
a227 2
struct vattr va_null;

a255 4
	/*
	 * Initialize each file system type.
	 */
	vattr_null(&va_null);
@


1.17
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.16 2003/08/18 01:51:57 tedu Exp $	*/
a39 1

d82 1
a82 2
vn_default_error(v)
	void *v;
d110 1
a110 2
vfs_opv_init_explicit(vfs_opv_desc)
	struct vnodeopv_desc *vfs_opv_desc;
d162 1
a162 2
vfs_opv_init_default(vfs_opv_desc)
	struct vnodeopv_desc *vfs_opv_desc;
d182 1
a182 1
vfs_opv_init()
d204 1
a204 1
vfs_op_init()
d236 1
a236 1
vfsinit()
@


1.16
log
@spelling in comment, jonathon gray
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.15 2003/07/24 22:00:24 mickey Exp $	*/
d51 1
d234 2
d245 3
@


1.15
log
@kill some externs that are not there anymore and had left other places for a better void ages ago
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.14 2003/06/02 23:28:07 millert Exp $	*/
d134 1
a134 1
		 * by seeing if its offest is zero.  Since
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.13 2002/05/20 05:27:40 mickey Exp $	*/
a230 2
extern struct vnodeops dead_vnodeops;
extern struct vnodeops spec_vnodeops;
@


1.13
log
@make it compile w/ debugging on
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.12 2002/03/14 01:27:06 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.11 2001/06/22 14:14:10 deraadt Exp $	*/
d130 1
a130 1
		    opv_desc_vector_p));
@


1.11
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.10 2000/09/27 16:13:46 mickey Exp $	*/
d78 1
a78 1
typedef int (*PFI) __P((void *));
d118 1
a118 1
	int (**opv_desc_vector) __P((void *));
d172 1
a172 1
	int (**opv_desc_vector) __P((void *));
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.11 2001/06/22 14:14:10 deraadt Exp $	*/
d78 1
a78 1
typedef int (*PFI)(void *);
d118 1
a118 1
	int (**opv_desc_vector)(void *);
d130 1
a130 1
		    opv_desc_vector));
d172 1
a172 1
	int (**opv_desc_vector)(void *);
@


1.10
log
@replace MALLOC/FREE w/ malloc/free for non-constant-sized memory allocations; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.9 1999/02/19 18:02:48 art Exp $	*/
d134 1
a134 2
	     opve_descp->opve_op;
	     opve_descp++) {
d184 1
a184 1
			opv_desc_vector[j] = 
@


1.9
log
@use vfs_register instead of the ugly hack to build vfsconf
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.8 1998/02/20 14:51:59 niklas Exp $	*/
d125 2
a126 2
		MALLOC(opv_desc_vector, PFI *,
		    vfs_opv_numops * sizeof(PFI), M_VNODE, M_WAITOK);
@


1.9.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.10 2000/09/27 16:13:46 mickey Exp $	*/
d125 2
a126 2
		opv_desc_vector = malloc(vfs_opv_numops * sizeof(PFI),
		    M_VNODE, M_WAITOK);
@


1.9.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.9.6.1 2001/05/14 22:32:46 niklas Exp $	*/
d134 2
a135 1
	    opve_descp->opve_op; opve_descp++) {
d185 1
a185 1
			opv_desc_vector[j] =
@


1.9.6.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 1
a78 1
typedef int (*PFI)(void *);
d118 1
a118 1
	int (**opv_desc_vector)(void *);
d172 1
a172 1
	int (**opv_desc_vector)(void *);
@


1.9.6.4
log
@Sync the SMP branch with 3.3
@
text
@d130 1
a130 1
		    opv_desc_vector));
@


1.9.6.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.9.6.4 2003/03/28 00:41:27 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d134 1
a134 1
		 * by seeing if its offset is zero.  Since
d231 2
@


1.9.6.7
log
@Merge with the trunk
@
text
@a50 1
#include <sys/pool.h>
a232 2
struct pool namei_pool;

a241 3

	pool_init(&namei_pool, MAXPATHLEN, 0, 0, 0, "namei",
	    &pool_allocator_nointr);
@


1.8
log
@Please GCC 2.8's harsher view of good style
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.7 1997/11/06 05:58:27 csapuntz Exp $	*/
d246 3
a248 2
	struct vfsconf *vfsp;
	int  i, maxtypenum;
a266 1
	maxtypenum = 0;
d268 11
a278 9
	for (vfsp = vfsconf, i = 1; i <= maxvfsconf; i++, vfsp++) {
		if (i < maxvfsconf)
			vfsp->vfc_next = vfsp + 1;
		if (maxtypenum <= vfsp->vfc_typenum)
			maxtypenum = vfsp->vfc_typenum + 1;
		(*vfsp->vfc_vfsops->vfs_init)(vfsp);
 	}
	/* next vfc_typenum to be used */
	maxvfsconf = maxtypenum;
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.6 1997/10/06 20:20:10 deraadt Exp $	*/
d78 1
a78 1
typedef (*PFI) __P((void *));
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.4 1997/02/24 14:20:02 niklas Exp $	*/
d246 2
a247 1
	struct vfsops **vfsp;
d266 11
a276 5
	for (vfsp = &vfssw[0]; vfsp < &vfssw[nvfssw]; vfsp++) {
		if (*vfsp == NULL)
			continue;
		(*(*vfsp)->vfs_init)();
	}
@


1.5
log
@VFS Lite2 Changes
@
text
@d246 1
a246 2
	struct vfsconf *vfsp;
	int  i, maxtypenum;
d265 5
a269 11
	maxtypenum = 0;

	for (vfsp = vfsconf, i = 1; i <= maxvfsconf; i++, vfsp++) {
		if (i < maxvfsconf)
			vfsp->vfc_next = vfsp + 1;
		if (maxtypenum <= vfsp->vfc_typenum)
			maxtypenum = vfsp->vfc_typenum + 1;
		(*vfsp->vfc_vfsops->vfs_init)(vfsp);
 	}
	/* next vfc_typenum to be used */
	maxvfsconf = maxtypenum;
@


1.4
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_init.c,v 1.6 1996/02/09 19:00:58 christos Exp $	*/
d246 2
a247 1
	struct vfsops **vfsp;
d266 11
a276 5
	for (vfsp = &vfssw[0]; vfsp < &vfssw[nvfssw]; vfsp++) {
		if (*vfsp == NULL)
			continue;
		(*(*vfsp)->vfs_init)();
	}
@


1.3
log
@export vfs_opv_init*
@
text
@d1 1
@


1.2
log
@From NetBSD: Merge with NetBSD 960217
@
text
@a78 5
void vfs_opv_init __P((void));
void vfs_opv_init_explicit __P((struct vnodeopv_desc *));
void vfs_opv_init_default __P((struct vnodeopv_desc *));
void vfs_op_init __P((void));

@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: vfs_init.c,v 1.4 1995/03/19 23:45:01 mycroft Exp $	*/
d54 1
d77 6
a82 1
typedef (*PFI)();   /* the standard Pointer to a Function returning an Int */
d88 1
d90 2
a91 1
vn_default_error()
d122 1
a122 1
	int (**opv_desc_vector)();
d177 1
a177 2
	int (**opv_desc_vector)();
	struct vnodeopv_entry_desc *opve_descp;
a241 1
extern void vclean();
d247 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
