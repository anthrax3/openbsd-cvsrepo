head	1.76;
access;
symbols
	OPENBSD_6_1:1.76.0.4
	OPENBSD_6_1_BASE:1.76
	OPENBSD_6_0:1.67.0.2
	OPENBSD_6_0_BASE:1.67
	OPENBSD_5_9:1.65.0.2
	OPENBSD_5_9_BASE:1.65
	OPENBSD_5_8:1.64.0.4
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.60.0.4
	OPENBSD_5_6_BASE:1.60
	OPENBSD_5_5:1.55.0.4
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.50.0.4
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.50.0.2
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.48.0.2
	OPENBSD_5_2_BASE:1.48
	OPENBSD_5_1_BASE:1.47
	OPENBSD_5_1:1.47.0.2
	OPENBSD_5_0:1.46.0.2
	OPENBSD_5_0_BASE:1.46
	OPENBSD_4_9:1.45.0.4
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.45.0.2
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.40.0.4
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.39.0.2
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.36.0.4
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.31.0.6
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.27.0.2
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.16
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.8.0.6
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.6.0.6
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.76
date	2017.02.04.07.42.52;	author guenther;	state Exp;
branches;
next	1.75;
commitid	ci3F0tVlYZmjHbyg;

1.75
date	2017.01.24.05.32.00;	author mpi;	state Exp;
branches;
next	1.74;
commitid	KfcP9FTEfsck0Mcw;

1.74
date	2017.01.24.04.50.48;	author mpi;	state Exp;
branches;
next	1.73;
commitid	7fSfbVLUln1cPk3S;

1.73
date	2017.01.24.00.58.55;	author mpi;	state Exp;
branches;
next	1.72;
commitid	r0ks7yUPmANG37rA;

1.72
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.71;
commitid	CHRb0fCqa8XxUAMH;

1.71
date	2016.11.07.00.26.32;	author guenther;	state Exp;
branches;
next	1.70;
commitid	W7ztnDZwvjCaeQTS;

1.70
date	2016.09.15.02.00.16;	author dlg;	state Exp;
branches;
next	1.69;
commitid	RlO92XR575sygHqm;

1.69
date	2016.09.02.18.11.28;	author tedu;	state Exp;
branches;
next	1.68;
commitid	rTRs82DQAsJjej88;

1.68
date	2016.08.25.00.00.02;	author dlg;	state Exp;
branches;
next	1.67;
commitid	iTfOIfeIXH3Xx3fA;

1.67
date	2016.06.27.19.55.02;	author jca;	state Exp;
branches;
next	1.66;
commitid	bjXjarVuCgiWznx4;

1.66
date	2016.03.04.14.09.37;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	97nacmRbEBM0nGGV;

1.65
date	2015.09.11.08.27.39;	author guenther;	state Exp;
branches;
next	1.64;
commitid	bZQWKjy0WH2n8wnf;

1.64
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.63;
commitid	p4LJxGKbi0BU2cG6;

1.63
date	2014.12.19.05.59.21;	author tedu;	state Exp;
branches;
next	1.62;
commitid	zdJTCwdpqRUwO1SL;

1.62
date	2014.12.10.02.44.47;	author tedu;	state Exp;
branches;
next	1.61;
commitid	tsoJBlEBSyYO22RG;

1.61
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.60;
commitid	3SGDR5EjcwE01W8S;

1.60
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.59;
commitid	QlVV51SZgNFxsXxC;

1.59
date	2014.07.04.05.58.30;	author guenther;	state Exp;
branches;
next	1.58;
commitid	vhXZZxMGVTWiFaF3;

1.58
date	2014.05.15.03.52.25;	author guenther;	state Exp;
branches;
next	1.57;

1.57
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.55;

1.55
date	2014.01.20.21.19.28;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2013.10.02.21.17.32;	author sf;	state Exp;
branches;
next	1.53;

1.53
date	2013.09.22.17.28.34;	author guenther;	state Exp;
branches;
next	1.52;

1.52
date	2013.08.12.20.43.28;	author bluhm;	state Exp;
branches;
next	1.51;

1.51
date	2013.08.08.23.25.06;	author syl;	state Exp;
branches;
next	1.50;

1.50
date	2013.02.17.17.39.29;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2013.02.09.20.56.35;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2012.04.10.15.50.52;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2011.09.18.23.20.54;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2011.03.07.07.07.13;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2010.07.19.23.00.15;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.10.21.29.37;	author guenther;	state Exp;
branches;
next	1.42;

1.42
date	2010.03.24.23.18.17;	author tedu;	state Exp;
branches;
next	1.41;

1.41
date	2010.01.28.19.23.06;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2009.04.15.10.47.46;	author art;	state Exp;
branches
	1.40.4.1;
next	1.39;

1.39
date	2008.11.01.05.59.21;	author deraadt;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2008.10.31.17.17.03;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2008.10.31.17.15.30;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.10.15.53.53;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2007.08.04.02.43.54;	author ckuethe;	state Exp;
branches;
next	1.33;

1.33
date	2007.04.03.08.05.43;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.22.06.55.03;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2005.12.04.05.49.12;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2005.12.03.18.09.08;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.28.00.14.28;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2005.07.04.00.20.42;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2005.07.03.22.56.07;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.10.17.26.10;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.18.15.10.24;	author markus;	state Exp;
branches;
next	1.22;

1.22
date	2004.10.04.12.03.45;	author pedro;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.25.20.50.51;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.22.15.42.11;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.29.17.19.42;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.12.22.49.53;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.12.22.44.12;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.12.19.56.03;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.25.15.00.26;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.23.15.46.48;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.23.00.39.47;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.16.20.50.17;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.23.18.42.06;	author art;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	2000.06.05.11.02.50;	author art;	state Exp;
branches;
next	1.6;

1.6
date	99.04.28.09.28.14;	author art;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	98.03.02.07.19.11;	author todd;	state Exp;
branches;
next	1.4;

1.4
date	98.02.20.13.47.22;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.11.24.03.22.41;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.19.51;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches;
next	;

1.6.4.1
date	2001.05.14.22.32.41;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2004.04.21.09.40.50;	author niklas;	state Exp;
branches;
next	;

1.8.6.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.8.6.3;

1.8.6.3
date	2003.05.19.22.31.10;	author tedu;	state Exp;
branches;
next	;

1.39.2.1
date	2010.01.29.21.33.30;	author sthen;	state Exp;
branches;
next	;

1.40.4.1
date	2010.01.29.21.33.13;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.76
log
@Update usage for ps/w to match previous commit
@
text
@/*	$OpenBSD: kern_proc.c,v 1.75 2017/01/24 05:32:00 mpi Exp $	*/
/*	$NetBSD: kern_proc.c,v 1.14 1996/02/09 18:59:41 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_proc.c	8.4 (Berkeley) 1/4/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/acct.h>
#include <sys/wait.h>
#include <sys/file.h>
#include <ufs/ufs/quota.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/signalvar.h>
#include <sys/pool.h>

#define	UIHASH(uid)	(&uihashtbl[(uid) & uihash])
LIST_HEAD(uihashhead, uidinfo) *uihashtbl;
u_long uihash;		/* size of hash table - 1 */

/*
 * Other process lists
 */
struct tidhashhead *tidhashtbl;
u_long tidhash;
struct pidhashhead *pidhashtbl;
u_long pidhash;
struct pgrphashhead *pgrphashtbl;
u_long pgrphash;
struct processlist allprocess;
struct processlist zombprocess;
struct proclist allproc;

struct pool proc_pool;
struct pool process_pool;
struct pool rusage_pool;
struct pool ucred_pool;
struct pool pgrp_pool;
struct pool session_pool;

static void orphanpg(struct pgrp *);
#ifdef DEBUG
void pgrpdump(void);
#endif

/*
 * Initialize global process hashing structures.
 */
void
procinit(void)
{
	LIST_INIT(&allprocess);
	LIST_INIT(&zombprocess);
	LIST_INIT(&allproc);


	tidhashtbl = hashinit(maxthread / 4, M_PROC, M_NOWAIT, &tidhash);
	pidhashtbl = hashinit(maxprocess / 4, M_PROC, M_NOWAIT, &pidhash);
	pgrphashtbl = hashinit(maxprocess / 4, M_PROC, M_NOWAIT, &pgrphash);
	uihashtbl = hashinit(maxprocess / 16, M_PROC, M_NOWAIT, &uihash);
	if (!tidhashtbl || !pidhashtbl || !pgrphashtbl || !uihashtbl)
		panic("procinit: malloc");

	pool_init(&proc_pool, sizeof(struct proc), 0, IPL_NONE,
	    PR_WAITOK, "procpl", NULL);
	pool_init(&process_pool, sizeof(struct process), 0, IPL_NONE,
	    PR_WAITOK, "processpl", NULL);
	pool_init(&rusage_pool, sizeof(struct rusage), 0, IPL_NONE,
	    PR_WAITOK, "zombiepl", NULL);
	pool_init(&ucred_pool, sizeof(struct ucred), 0, IPL_NONE,
	    PR_WAITOK, "ucredpl", NULL);
	pool_init(&pgrp_pool, sizeof(struct pgrp), 0, IPL_NONE,
	    PR_WAITOK, "pgrppl", NULL);
	pool_init(&session_pool, sizeof(struct session), 0, IPL_NONE,
	    PR_WAITOK, "sessionpl", NULL);
}

struct uidinfo *
uid_find(uid_t uid)
{
	struct uidinfo *uip, *nuip;
	struct uihashhead *uipp;

	uipp = UIHASH(uid);
	LIST_FOREACH(uip, uipp, ui_hash)
		if (uip->ui_uid == uid)
			break;
	if (uip)
		return (uip);
	nuip = malloc(sizeof(*nuip), M_PROC, M_WAITOK|M_ZERO);
	LIST_FOREACH(uip, uipp, ui_hash)
		if (uip->ui_uid == uid)
			break;
	if (uip) {
		free(nuip, M_PROC, sizeof(*nuip));
		return (uip);
	}
	nuip->ui_uid = uid;
	LIST_INSERT_HEAD(uipp, nuip, ui_hash);

	return (nuip);
}

/*
 * Change the count associated with number of threads
 * a given user is using.
 */
int
chgproccnt(uid_t uid, int diff)
{
	struct uidinfo *uip;

	uip = uid_find(uid);
	uip->ui_proccnt += diff;
	if (uip->ui_proccnt < 0)
		panic("chgproccnt: procs < 0");
	return (uip->ui_proccnt);
}

/*
 * Is pr an inferior of parent?
 */
int
inferior(struct process *pr, struct process *parent)
{

	for (; pr != parent; pr = pr->ps_pptr)
		if (pr->ps_pid == 0 || pr->ps_pid == 1)
			return (0);
	return (1);
}

/*
 * Locate a proc (thread) by number
 */
struct proc *
tfind(pid_t tid)
{
	struct proc *p;

	LIST_FOREACH(p, TIDHASH(tid), p_hash)
		if (p->p_tid == tid)
			return (p);
	return (NULL);
}

/*
 * Locate a process by number
 */
struct process *
prfind(pid_t pid)
{
	struct process *pr;

	LIST_FOREACH(pr, PIDHASH(pid), ps_hash)
		if (pr->ps_pid == pid)
			return (pr);
	return (NULL);
}

/*
 * Locate a process group by number
 */
struct pgrp *
pgfind(pid_t pgid)
{
	struct pgrp *pgrp;

	LIST_FOREACH(pgrp, PGRPHASH(pgid), pg_hash)
		if (pgrp->pg_id == pgid)
			return (pgrp);
	return (NULL);
}

/*
 * Locate a zombie process
 */
struct process *
zombiefind(pid_t pid)
{
	struct process *pr;

	LIST_FOREACH(pr, &zombprocess, ps_list)
		if (pr->ps_pid == pid)
			return (pr);
	return (NULL);
}

/*
 * Move p to a new or existing process group (and session)
 * Caller provides a pre-allocated pgrp and session that should
 * be freed if they are not used.
 * XXX need proctree lock
 */
int
enterpgrp(struct process *pr, pid_t pgid, struct pgrp *newpgrp,
    struct session *newsess)
{
	struct pgrp *pgrp = pgfind(pgid);

#ifdef DIAGNOSTIC
	if (pgrp != NULL && newsess)	/* firewalls */
		panic("enterpgrp: setsid into non-empty pgrp");
	if (SESS_LEADER(pr))
		panic("enterpgrp: session leader attempted setpgrp");
#endif
	if (pgrp == NULL) {
		/*
		 * new process group
		 */
#ifdef DIAGNOSTIC
		if (pr->ps_pid != pgid)
			panic("enterpgrp: new pgrp and pid != pgid");
#endif

		pgrp = newpgrp;
		if (newsess) {
			/*
			 * new session
			 */
			newsess->s_leader = pr;
			newsess->s_count = 1;
			newsess->s_ttyvp = NULL;
			newsess->s_ttyp = NULL;
			memcpy(newsess->s_login, pr->ps_session->s_login,
			    sizeof(newsess->s_login));
			atomic_clearbits_int(&pr->ps_flags, PS_CONTROLT);
			pgrp->pg_session = newsess;
#ifdef DIAGNOSTIC
			if (pr != curproc->p_p)
				panic("enterpgrp: mksession but not curproc");
#endif
		} else {
			pgrp->pg_session = pr->ps_session;
			pgrp->pg_session->s_count++;
		}
		pgrp->pg_id = pgid;
		LIST_INIT(&pgrp->pg_members);
		LIST_INSERT_HEAD(PGRPHASH(pgid), pgrp, pg_hash);
		pgrp->pg_jobc = 0;
	} else if (pgrp == pr->ps_pgrp) {
		if (newsess)
			pool_put(&session_pool, newsess);
		pool_put(&pgrp_pool, newpgrp);
		return (0);
	} else {
		if (newsess)
			pool_put(&session_pool, newsess);
		pool_put(&pgrp_pool, newpgrp);
	}

	/*
	 * Adjust eligibility of affected pgrps to participate in job control.
	 * Increment eligibility counts before decrementing, otherwise we
	 * could reach 0 spuriously during the first call.
	 */
	fixjobc(pr, pgrp, 1);
	fixjobc(pr, pr->ps_pgrp, 0);

	LIST_REMOVE(pr, ps_pglist);
	if (LIST_EMPTY(&pr->ps_pgrp->pg_members))
		pgdelete(pr->ps_pgrp);
	pr->ps_pgrp = pgrp;
	LIST_INSERT_HEAD(&pgrp->pg_members, pr, ps_pglist);
	return (0);
}

/*
 * remove process from process group
 */
void
leavepgrp(struct process *pr)
{

	if (pr->ps_session->s_verauthppid == pr->ps_pid)
		zapverauth(pr->ps_session);
	LIST_REMOVE(pr, ps_pglist);
	if (LIST_EMPTY(&pr->ps_pgrp->pg_members))
		pgdelete(pr->ps_pgrp);
	pr->ps_pgrp = 0;
}

/*
 * delete a process group
 */
void
pgdelete(struct pgrp *pgrp)
{

	if (pgrp->pg_session->s_ttyp != NULL && 
	    pgrp->pg_session->s_ttyp->t_pgrp == pgrp)
		pgrp->pg_session->s_ttyp->t_pgrp = NULL;
	LIST_REMOVE(pgrp, pg_hash);
	SESSRELE(pgrp->pg_session);
	pool_put(&pgrp_pool, pgrp);
}

void
zapverauth(void *v)
{
	struct session *sess = v;
	sess->s_verauthuid = 0;
	sess->s_verauthppid = 0;
}

/*
 * Adjust pgrp jobc counters when specified process changes process group.
 * We count the number of processes in each process group that "qualify"
 * the group for terminal job control (those with a parent in a different
 * process group of the same session).  If that count reaches zero, the
 * process group becomes orphaned.  Check both the specified process'
 * process group and that of its children.
 * entering == 0 => pr is leaving specified group.
 * entering == 1 => pr is entering specified group.
 * XXX need proctree lock
 */
void
fixjobc(struct process *pr, struct pgrp *pgrp, int entering)
{
	struct pgrp *hispgrp;
	struct session *mysession = pgrp->pg_session;

	/*
	 * Check pr's parent to see whether pr qualifies its own process
	 * group; if so, adjust count for pr's process group.
	 */
	if ((hispgrp = pr->ps_pptr->ps_pgrp) != pgrp &&
	    hispgrp->pg_session == mysession) {
		if (entering)
			pgrp->pg_jobc++;
		else if (--pgrp->pg_jobc == 0)
			orphanpg(pgrp);
	}

	/*
	 * Check this process' children to see whether they qualify
	 * their process groups; if so, adjust counts for children's
	 * process groups.
	 */
	LIST_FOREACH(pr, &pr->ps_children, ps_sibling)
		if ((hispgrp = pr->ps_pgrp) != pgrp &&
		    hispgrp->pg_session == mysession &&
		    (pr->ps_flags & PS_ZOMBIE) == 0) {
			if (entering)
				hispgrp->pg_jobc++;
			else if (--hispgrp->pg_jobc == 0)
				orphanpg(hispgrp);
		}
}

/* 
 * A process group has become orphaned;
 * if there are any stopped processes in the group,
 * hang-up all process in that group.
 */
static void
orphanpg(struct pgrp *pg)
{
	struct process *pr;

	LIST_FOREACH(pr, &pg->pg_members, ps_pglist) {
		if (pr->ps_mainproc->p_stat == SSTOP) {
			LIST_FOREACH(pr, &pg->pg_members, ps_pglist) {
				prsignal(pr, SIGHUP);
				prsignal(pr, SIGCONT);
			}
			return;
		}
	}
}

#ifdef DDB
void 
proc_printit(struct proc *p, const char *modif,
    int (*pr)(const char *, ...) __attribute__((__format__(__kprintf__,1,2))))
{
	static const char *const pstat[] = {
		"idle", "run", "sleep", "stop", "zombie", "dead", "onproc"
	};
	char pstbuf[5];
	const char *pst = pstbuf;


	if (p->p_stat < 1 || p->p_stat > sizeof(pstat) / sizeof(pstat[0]))
		snprintf(pstbuf, sizeof(pstbuf), "%d", p->p_stat);
	else
		pst = pstat[(int)p->p_stat - 1];

	(*pr)("PROC (%s) pid=%d stat=%s\n", p->p_p->ps_comm, p->p_tid, pst);
	(*pr)("    flags process=%b proc=%b\n",
	    p->p_p->ps_flags, PS_BITS, p->p_flag, P_BITS);
	(*pr)("    pri=%u, usrpri=%u, nice=%d\n",
	    p->p_priority, p->p_usrpri, p->p_p->ps_nice);
	(*pr)("    forw=%p, list=%p,%p\n",
	    TAILQ_NEXT(p, p_runq), p->p_list.le_next, p->p_list.le_prev);
	(*pr)("    process=%p user=%p, vmspace=%p\n",
	    p->p_p, p->p_addr, p->p_vmspace);
	(*pr)("    estcpu=%u, cpticks=%d, pctcpu=%u.%u\n",
	    p->p_estcpu, p->p_cpticks, p->p_pctcpu / 100, p->p_pctcpu % 100);
	(*pr)("    user=%u, sys=%u, intr=%u\n",
	    p->p_uticks, p->p_sticks, p->p_iticks);
}
#include <machine/db_machdep.h>

#include <ddb/db_output.h>

void
db_show_all_procs(db_expr_t addr, int haddr, db_expr_t count, char *modif)
{
	char *mode;
	int skipzomb = 0;
	struct proc *p;
	struct process *pr, *ppr;
    
	if (modif[0] == 0)
		modif[0] = 'n';			/* default == normal mode */

	mode = "mawno";
	while (*mode && *mode != modif[0])
		mode++;
	if (*mode == 0 || *mode == 'm') {
		db_printf("usage: show all procs [/a] [/n] [/w]\n");
		db_printf("\t/a == show process address info\n");
		db_printf("\t/n == show normal process info [default]\n");
		db_printf("\t/w == show process pgrp/wait info\n");
		db_printf("\t/o == show normal info for non-idle SONPROC\n");
		return;
	}
	
	pr = LIST_FIRST(&allprocess);

	switch (*mode) {

	case 'a':
		db_printf("    TID  %-9s  %18s  %18s  %18s\n",
		    "COMMAND", "STRUCT PROC *", "UAREA *", "VMSPACE/VM_MAP");
		break;
	case 'n':
		db_printf("   PID  %6s  %5s  %5s  S  %10s  %-12s  %-15s\n",
		    "TID", "PPID", "UID", "FLAGS", "WAIT", "COMMAND");
		break;
	case 'w':
		db_printf("    TID  %-15s  %-5s  %18s  %s\n",
		    "COMMAND", "PGRP", "WAIT-CHANNEL", "WAIT-MSG");
		break;
	case 'o':
		skipzomb = 1;
		db_printf("    TID  %5s  %5s  %10s %10s  %3s  %-30s\n",
		    "PID", "UID", "PRFLAGS", "PFLAGS", "CPU", "COMMAND");
		break;
	}

	while (pr != NULL) {
		ppr = pr->ps_pptr;

		TAILQ_FOREACH(p, &pr->ps_threads, p_thr_link) {
			if (p->p_stat) {
				if (*mode == 'o') {
					if (p->p_stat != SONPROC)
						continue;
					if (p->p_cpu != NULL && p->p_cpu->
					    ci_schedstate.spc_idleproc == p)
						continue;
				}

				if (*mode == 'n') {
					db_printf("%c%5d  ", (p == curproc ?
					    '*' : ' '), pr->ps_pid);
				} else {
					db_printf("%c%6d  ", (p == curproc ?
					    '*' : ' '), p->p_tid);
				}

				switch (*mode) {

				case 'a':
					db_printf("%-9.9s  %18p  %18p  %18p\n",
					    pr->ps_comm, p, p->p_addr, p->p_vmspace);
					break;

				case 'n':
					db_printf("%6d  %5d  %5d  %d  %#10x  "
					    "%-12.12s  %-15s\n",
					    p->p_tid, ppr ? ppr->ps_pid : -1,
					    pr->ps_ucred->cr_ruid, p->p_stat,
					    p->p_flag | pr->ps_flags,
					    (p->p_wchan && p->p_wmesg) ?
						p->p_wmesg : "", pr->ps_comm);
					break;

				case 'w':
					db_printf("%-15s  %-5d  %18p  %s\n",
					    pr->ps_comm, (pr->ps_pgrp ?
						pr->ps_pgrp->pg_id : -1),
					    p->p_wchan,
					    (p->p_wchan && p->p_wmesg) ?
						p->p_wmesg : "");
					break;

				case 'o':
					db_printf("%5d  %5d  %#10x %#10x  %3d"
					    "  %-31s\n",
					    pr->ps_pid, pr->ps_ucred->cr_ruid,
					    pr->ps_flags, p->p_flag,
					    CPU_INFO_UNIT(p->p_cpu),
					    pr->ps_comm);
					break;

				}
			}
		}
		pr = LIST_NEXT(pr, ps_list);
		if (pr == NULL && skipzomb == 0) {
			skipzomb = 1;
			pr = LIST_FIRST(&zombprocess);
		}
	}
}
#endif

#ifdef DEBUG
void
pgrpdump(void)
{
	struct pgrp *pgrp;
	struct process *pr;
	int i;

	for (i = 0; i <= pgrphash; i++) {
		if (!LIST_EMPTY(&pgrphashtbl[i])) {
			printf("\tindx %d\n", i);
			LIST_FOREACH(pgrp, &pgrphashtbl[i], pg_hash) {
				printf("\tpgrp %p, pgid %d, sess %p, sesscnt %d, mem %p\n",
				    pgrp, pgrp->pg_id, pgrp->pg_session,
				    pgrp->pg_session->s_count,
				    LIST_FIRST(&pgrp->pg_members));
				LIST_FOREACH(pr, &pgrp->pg_members, ps_pglist) {
					printf("\t\tpid %d addr %p pgrp %p\n", 
					    pr->ps_pid, pr, pr->ps_pgrp);
				}
			}
		}
	}
}
#endif /* DEBUG */
@


1.75
log
@Display process group in "ps /w" since they got removed from "ps /n".

While here fix the formating of /w /o and /a.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.74 2017/01/24 04:50:48 mpi Exp $	*/
d460 1
a460 1
		db_printf("\t/w == show process wait/emul info\n");
@


1.74
log
@Display the thread ID (TID) rather than the process group ID (PGRP)
in ddb(4)'s default 'ps' view.

This allow to use 'tr /p' easily now that it requires a TID.

With inputs from guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.73 2017/01/24 00:58:55 mpi Exp $	*/
d470 1
a470 1
		db_printf("   TID  %-10s  %18s  %18s  %18s\n",
d478 2
a479 2
		db_printf("   TID  %-16s  %-8s  %18s  %s\n",
		    "COMMAND", "EMUL", "WAIT-CHANNEL", "WAIT-MSG");
d483 1
a483 1
		db_printf("   TID  %5s  %5s  %10s %10s  %3s  %-31s\n",
d512 1
a512 1
					db_printf("%-10.10s  %18p  %18p  %18p\n",
d527 5
a531 3
					db_printf("%-16s  %-8s  %18p  %s\n", pr->ps_comm,
					    pr->ps_emul->e_name, p->p_wchan,
					    (p->p_wchan && p->p_wmesg) ? 
@


1.73
log
@Rename pfind(9) into tfind(9) to reflect that it deals with threads.

While here document prfind(9.

with and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.72 2017/01/21 05:42:03 guenther Exp $	*/
d474 2
a475 2
		db_printf("   PID  %5s  %5s  %5s  S  %10s  %-12s  %-16s\n",
		    "PPID", "PGRP", "UID", "FLAGS", "WAIT", "COMMAND");
d500 8
a507 2
				db_printf("%c%5d  ", p == curproc ? '*' : ' ',
				    *mode == 'n' ? pr->ps_pid : p->p_tid);
d517 3
a519 4
					db_printf("%5d  %5d  %5d  %d  %#10x  "
					    "%-12.12s  %-16s\n",
					    ppr ? ppr->ps_pid : -1,
					    pr->ps_pgrp ? pr->ps_pgrp->pg_id : -1,
@


1.72
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.71 2016/11/07 00:26:32 guenther Exp $	*/
d172 1
a172 1
pfind(pid_t tid)
@


1.71
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.70 2016/09/15 02:00:16 dlg Exp $	*/
d424 1
a424 1
	(*pr)("PROC (%s) tid=%d stat=%s\n", p->p_comm, p->p_tid, pst);
d507 1
a507 1
					    p->p_comm, p, p->p_addr, p->p_vmspace);
d518 1
a518 1
						p->p_wmesg : "", p->p_comm);
d522 1
a522 1
					db_printf("%-16s  %-8s  %18p  %s\n", p->p_comm,
d534 1
a534 1
					    p->p_comm);
@


1.70
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.69 2016/09/02 18:11:28 tedu Exp $	*/
d59 2
d92 2
a93 1
	pidhashtbl = hashinit(maxthread / 4, M_PROC, M_NOWAIT, &pidhash);
d96 1
a96 1
	if (!pidhashtbl || !pgrphashtbl || !uihashtbl)
d172 1
a172 1
pfind(pid_t pid)
d176 2
a177 2
	LIST_FOREACH(p, PIDHASH(pid), p_hash)
		if (p->p_pid == pid)
d188 1
a188 1
	struct proc *p;
d190 3
a192 3
	LIST_FOREACH(p, PIDHASH(pid), p_hash)
		if (p->p_pid == pid)
			return (p->p_flag & P_THREAD ? NULL : p->p_p);
d219 1
a219 1
		if (pr->ps_mainproc->p_pid == pid)
d424 1
a424 1
	(*pr)("PROC (%s) pid=%d stat=%s\n", p->p_comm, p->p_pid, pst);
d474 1
a474 1
		db_printf("   TID  %5s  %5s  %5s  S  %10s  %-12s  %-16s\n",
d501 1
a501 1
					p->p_pid);
@


1.69
log
@add a concept of 'verified auth' to sessions. When set via ioctl,
the user and parent process are recorded. Later, this info may be tested
and used to bypass authorization requirements.
ie, doas won't ask for your password again.
Great idea from henning.
ok deraadt guenther henning
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.68 2016/08/25 00:00:02 dlg Exp $	*/
d96 12
a107 18
	pool_init(&proc_pool, sizeof(struct proc), 0, 0, PR_WAITOK,
	    "procpl", NULL);
	pool_setipl(&proc_pool, IPL_NONE);
	pool_init(&process_pool, sizeof(struct process), 0, 0, PR_WAITOK,
	    "processpl", NULL);
	pool_setipl(&process_pool, IPL_NONE);
	pool_init(&rusage_pool, sizeof(struct rusage), 0, 0, PR_WAITOK,
	    "zombiepl", NULL);
	pool_setipl(&rusage_pool, IPL_NONE);
	pool_init(&ucred_pool, sizeof(struct ucred), 0, 0, PR_WAITOK,
	    "ucredpl", NULL);
	pool_setipl(&ucred_pool, IPL_NONE);
	pool_init(&pgrp_pool, sizeof(struct pgrp), 0, 0, PR_WAITOK,
	    "pgrppl", NULL);
	pool_setipl(&pgrp_pool, IPL_NONE);
	pool_init(&session_pool, sizeof(struct session), 0, 0, PR_WAITOK,
	    "sessionpl", NULL);
	pool_setipl(&session_pool, IPL_NONE);
@


1.68
log
@pool_setipl

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.67 2016/06/27 19:55:02 jca Exp $	*/
d313 2
d334 8
@


1.67
log
@Repair kill(2) on zombie processes.

kill(2) is supposed to find zombie processes, this probably got broken
when the process reaper was introduced.  As a temporary(tm) workaround,
walk the list of zombie processes if we can't find the target pid in the
main process list.

Problem with zsh initially reported by Geoff Wozniak on misc@@, analysis
done by naddy@@.  ok kettenis@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.66 2016/03/04 14:09:37 deraadt Exp $	*/
d98 1
d101 1
d104 1
d107 1
d110 1
d113 1
@


1.66
log
@repair documentation for inferior(); from Michal Mazurek
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.65 2015/09/11 08:27:39 guenther Exp $	*/
d204 14
@


1.65
log
@Add ddb ps/o, displaying just the non-idle on-proc threads

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.64 2015/03/14 03:38:50 jsg Exp $	*/
d153 1
a153 1
 * Is p an inferior of parent?
@


1.64
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.63 2014/12/19 05:59:21 tedu Exp $	*/
d419 1
a419 1
	int doingzomb = 0;
d426 1
a426 1
	mode = "mawn";
d434 1
d443 1
a443 1
		db_printf("   PID  %-10s  %18s  %18s  %18s\n",
d447 1
a447 1
		db_printf("   PID  %5s  %5s  %5s  S  %10s  %-12s  %-16s\n",
d451 1
a451 1
		db_printf("   PID  %-16s  %-8s  %18s  %s\n",
d454 5
d466 7
d501 9
d514 2
a515 2
		if (pr == NULL && doingzomb == 0) {
			doingzomb = 1;
@


1.63
log
@start retiring the nointr allocator. specify PR_WAITOK as a flag as a
marker for which pools are not interrupt safe. ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.62 2014/12/10 02:44:47 tedu Exp $	*/
a412 1
#include <ddb/db_interface.h>
@


1.62
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.61 2014/11/03 03:08:00 deraadt Exp $	*/
d96 12
a107 12
	pool_init(&proc_pool, sizeof(struct proc), 0, 0, 0, "procpl",
	    &pool_allocator_nointr);
	pool_init(&process_pool, sizeof(struct process), 0, 0, 0, "processpl",
	    &pool_allocator_nointr);
	pool_init(&rusage_pool, sizeof(struct rusage), 0, 0, 0, "zombiepl",
	    &pool_allocator_nointr);
	pool_init(&ucred_pool, sizeof(struct ucred), 0, 0, 0, "ucredpl",
	    &pool_allocator_nointr);
	pool_init(&pgrp_pool, sizeof(struct pgrp), 0, 0, 0, "pgrppl",
	    &pool_allocator_nointr);
	pool_init(&session_pool, sizeof(struct session), 0, 0, 0, "sessionpl",
	    &pool_allocator_nointr);
@


1.61
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.60 2014/07/12 18:43:32 tedu Exp $	*/
d243 1
a243 1
			bcopy(pr->ps_session->s_login, newsess->s_login,
@


1.60
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.59 2014/07/04 05:58:30 guenther Exp $	*/
d127 1
a127 1
		free(nuip, M_PROC, 0);
@


1.59
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.58 2014/05/15 03:52:25 guenther Exp $	*/
d127 1
a127 1
		free(nuip, M_PROC);
@


1.58
log
@Move from struct proc to process the reference-count-holding pointers
to the process's vmspace and filedescs.  struct proc continues to
keep copies of the pointers, copying them on fork, clearing them
on exit, and (for vmspace) refreshing on exec.
Also, make uvm_swapout_threads() thread aware, eliminating p_swtime
in kernel.

particular testing by ajacoutot@@ and sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.57 2014/03/30 21:54:48 guenther Exp $	*/
d351 1
a351 1
		    P_ZOMBIE(pr->ps_mainproc) == 0) {
@


1.57
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.56 2014/03/26 05:23:42 guenther Exp $	*/
d406 2
a407 3
	(*pr)("    estcpu=%u, cpticks=%d, pctcpu=%u.%u, swtime=%u\n",
	    p->p_estcpu, p->p_cpticks, p->p_pctcpu / 100, p->p_pctcpu % 100,
	    p->p_swtime);
@


1.56
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.55 2014/01/20 21:19:28 guenther Exp $	*/
a72 1
struct pool pcred_pool;
a107 2
	pool_init(&pcred_pool, sizeof(struct pcred), 0, 0, 0, "pcredpl",
	    &pool_allocator_nointr);
d477 1
a477 1
					    pr->ps_cred->p_ruid, p->p_stat,
@


1.55
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.54 2013/10/02 21:17:32 sf Exp $	*/
d488 1
a488 1
					    p->p_emul->e_name, p->p_wchan,
@


1.54
log
@format string fix: p_*ticks are u_int
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.53 2013/09/22 17:28:34 guenther Exp $	*/
d63 2
a65 1
struct proclist zombproc;
d86 2
a88 1
	LIST_INIT(&zombproc);
d442 1
a442 1
	p = LIST_FIRST(&allproc);
d460 1
a460 2
	while (p != 0) {
		pr = p->p_p;
a461 1
		if (p->p_stat) {
d463 29
a491 27
			db_printf("%c%5d  ", p == curproc ? '*' : ' ',
				p->p_pid);

			switch (*mode) {

			case 'a':
				db_printf("%-10.10s  %18p  %18p  %18p\n",
				    p->p_comm, p, p->p_addr, p->p_vmspace);
				break;

			case 'n':
				db_printf("%5d  %5d  %5d  %d  %#10x  "
				    "%-12.12s  %-16s\n",
				    ppr ? ppr->ps_pid : -1,
				    pr->ps_pgrp ? pr->ps_pgrp->pg_id : -1,
				    pr->ps_cred->p_ruid, p->p_stat,
				    p->p_flag | p->p_p->ps_flags,
				    (p->p_wchan && p->p_wmesg) ?
					p->p_wmesg : "", p->p_comm);
				break;

			case 'w':
				db_printf("%-16s  %-8s  %18p  %s\n", p->p_comm,
				    p->p_emul->e_name, p->p_wchan,
				    (p->p_wchan && p->p_wmesg) ? 
					p->p_wmesg : "");
				break;
d493 1
d496 2
a497 2
		p = LIST_NEXT(p, p_list);
		if (p == 0 && doingzomb == 0) {
d499 1
a499 1
			p = LIST_FIRST(&zombproc);
@


1.53
log
@Stop merging the per-thread and per-process flags when reporting
them via sysctl(KERN_PROC).  In struct kinfo_proc the per-process
flags move to p_psflags, leaving the per-thread flags in p_flags.
Flag descriptions in ps(1) updated to be less obtuse.

discussed with matthew@@ some time ago; ok jca@@, manpage bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.52 2013/08/12 20:43:28 bluhm Exp $	*/
d410 1
a410 1
	(*pr)("    user=%llu, sys=%llu, intr=%llu\n",
@


1.52
log
@The ps flags are split between thread and process.  It is useful
for ddb to show both.  So or them together in the ps overview and
list them explicitly for the specific thread.  Also sync the ddb
bit names with the define names.
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.51 2013/08/08 23:25:06 syl Exp $	*/
d400 1
a400 1
	    p->p_p->ps_flags, P_BITS, p->p_flag, P_BITS);
@


1.51
log
@Uncomment kprintf format attributes for sys/kern

tested on vax (gcc3) ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.50 2013/02/17 17:39:29 miod Exp $	*/
d398 3
a400 2
	(*pr)("PROC (%s) pid=%d stat=%s flags=%b\n",
	    p->p_comm, p->p_pid, pst, p->p_flag, P_BITS);
d478 2
a479 1
				    pr->ps_cred->p_ruid, p->p_stat, p->p_flag,
@


1.50
log
@Comment out recently added __attribute__((__format__(__kprintf__))) annotations
in MI code; gcc 2.95 does not accept such annotation for function pointer
declarations, only function prototypes.
To be uncommented once gcc 2.95 bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.49 2013/02/09 20:56:35 miod Exp $	*/
d384 1
a384 1
    int (*pr)(const char *, ...) /* __attribute__((__format__(__kprintf__,1,2))) */)
@


1.49
log
@Add explicit __attribute__ ((__format__(__kprintf__)))) to the functions and
function pointer arguments which are {used as,} wrappers around the kernel
printf function.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.48 2012/04/10 15:50:52 guenther Exp $	*/
d384 1
a384 1
    int (*pr)(const char *, ...) __attribute__((__format__(__kprintf__,1,2))))
@


1.48
log
@Make the KERN_NPROCS and KERN_MAXPROC sysctl()s and the RLIMIT_NPROC rlimit
count processes instead of threads.  New sysctl()s KERN_NTHREADS and
KERN_MAXTHREAD count and limit threads.  The nprocs and maxproc kernel
variables are replaced by nprocess, maxprocess, nthreads, and maxthread.

ok tedu@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.47 2011/09/18 23:20:54 miod Exp $	*/
d383 2
a384 1
proc_printit(struct proc *p, const char *modif, int (*pr)(const char *, ...))
@


1.47
log
@%, is not a valid format specifier
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.46 2011/03/07 07:07:13 guenther Exp $	*/
d89 3
a91 3
	pidhashtbl = hashinit(maxproc / 4, M_PROC, M_NOWAIT, &pidhash);
	pgrphashtbl = hashinit(maxproc / 4, M_PROC, M_NOWAIT, &pgrphash);
	uihashtbl = hashinit(maxproc / 16, M_PROC, M_NOWAIT, &uihash);
@


1.46
log
@The scheduling 'nice' value is per-process, not per-thread, so move it
into struct process.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.45 2010/07/26 01:56:27 guenther Exp $	*/
d405 1
a405 1
	(*pr)("    estcpu=%u, cpticks=%d, pctcpu=%u.%u%, swtime=%u\n",
@


1.45
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.44 2010/07/19 23:00:15 guenther Exp $	*/
d400 1
a400 1
	    p->p_priority, p->p_usrpri, p->p_nice);
@


1.44
log
@Rollback the allproclk and fileheadlk addition.  When grabbing an
rwlock, the thread will release biglock if it sleeps, means that
atomicity from before the rw_enter() to after it is not guaranteed.
The change didn't address those, so pulling it until it does.

"go for it" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.43 2010/07/10 21:29:37 guenther Exp $	*/
d138 1
a138 1
 * Change the count associated with number of processes
d157 1
a157 1
inferior(struct proc *p, struct proc *parent)
d160 2
a161 2
	for (; p != parent; p = p->p_pptr)
		if (p->p_pid == 0 || p->p_pid == 1)
d167 1
a167 1
 * Locate a process by number
d181 14
d212 1
d215 1
a215 1
enterpgrp(struct proc *p, pid_t pgid, struct pgrp *newpgrp,
d223 1
a223 1
	if (SESS_LEADER(p))
a226 1
		struct proc *np;
d231 1
a231 1
		if (p->p_pid != pgid)
a234 7
		if ((np = pfind(p->p_pid)) == NULL || np != p) {
			pool_put(&pgrp_pool, newpgrp);
			if (newsess)
				pool_put(&session_pool, newsess);
			return (ESRCH);
		}

d240 1
a240 1
			newsess->s_leader = p;
d244 1
a244 1
			bcopy(p->p_session->s_login, newsess->s_login,
d246 1
a246 1
			atomic_clearbits_int(&p->p_flag, P_CONTROLT);
d249 2
a250 2
			if (p != curproc)
				panic("enterpgrp: mksession and p != curproc");
d253 1
a253 1
			pgrp->pg_session = p->p_session;
d260 1
a260 1
	} else if (pgrp == p->p_pgrp) {
d276 2
a277 2
	fixjobc(p, pgrp, 1);
	fixjobc(p, p->p_pgrp, 0);
d279 5
a283 5
	LIST_REMOVE(p, p_pglist);
	if (LIST_EMPTY(&p->p_pgrp->pg_members))
		pgdelete(p->p_pgrp);
	p->p_pgrp = pgrp;
	LIST_INSERT_HEAD(&pgrp->pg_members, p, p_pglist);
d290 2
a291 2
int
leavepgrp(struct proc *p)
d294 4
a297 5
	LIST_REMOVE(p, p_pglist);
	if (LIST_EMPTY(&p->p_pgrp->pg_members))
		pgdelete(p->p_pgrp);
	p->p_pgrp = 0;
	return (0);
d322 3
a324 2
 * entering == 0 => p is leaving specified group.
 * entering == 1 => p is entering specified group.
d327 1
a327 1
fixjobc(struct proc *p, struct pgrp *pgrp, int entering)
d333 2
a334 2
	 * Check p's parent to see whether p qualifies its own process
	 * group; if so, adjust count for p's process group.
d336 1
a336 1
	if ((hispgrp = p->p_pptr->p_pgrp) != pgrp &&
d349 2
a350 2
	LIST_FOREACH(p, &p->p_children, p_sibling)
		if ((hispgrp = p->p_pgrp) != pgrp &&
d352 1
a352 1
		    P_ZOMBIE(p) == 0) {
d368 1
a368 1
	struct proc *p;
d370 5
a374 5
	LIST_FOREACH(p, &pg->pg_members, p_pglist) {
		if (p->p_stat == SSTOP) {
			LIST_FOREACH(p, &pg->pg_members, p_pglist) {
				psignal(p, SIGHUP);
				psignal(p, SIGCONT);
d391 1
d403 2
a404 2
	(*pr)("    user=%p, vmspace=%p\n",
	    p->p_addr, p->p_vmspace);
d421 2
a422 1
	struct proc *p, *pp;
d457 2
a458 1
		pp = p->p_pptr;
d474 3
a476 3
				    pp ? pp->p_pid : -1,
				    p->p_pgrp ? p->p_pgrp->pg_id : -1,
				    p->p_cred->p_ruid, p->p_stat, p->p_flag,
d504 1
a504 1
	struct proc *p;
d515 1
a515 1
				LIST_FOREACH(p, &pgrp->pg_members, p_pglist) {
d517 1
a517 1
					    p->p_pid, p, p->p_pgrp);
@


1.43
log
@A process on the zombie list can have a NULL p_pgrp if it sleeps when
grabbing allproclk in proc_zap(); skip such processes in sysctl(KERN_PROC*)
and handle the NULL pointer in ddb's ps.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.42 2010/03/24 23:18:17 tedu Exp $	*/
a42 1
#include <sys/rwlock.h>
a63 1
struct rwlock allproclk;
a85 1
	rw_init(&allproclk, "allproc");
@


1.42
log
@Add a rwlock around the filehead and allproc lists, mainly to protect
list walkers in sysctl that can block.  As a reward, no more vslock.
With some feedback from art, guenther, phessler.  ok guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.41 2010/01/28 19:23:06 guenther Exp $	*/
d467 2
a468 1
				    pp ? pp->p_pid : -1, p->p_pgrp->pg_id,
@


1.41
log
@Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.40 2009/04/15 10:47:46 art Exp $	*/
d43 1
d65 1
d88 1
@


1.40
log
@Misplaced comment.
From Kirill Timofeev
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.39 2008/11/01 05:59:21 deraadt Exp $	*/
d154 1
a154 1
 * Is p an inferior of the current process?
d157 1
a157 1
inferior(struct proc *p)
d160 2
a161 2
	for (; p != curproc; p = p->p_pptr)
		if (p->p_pid == 0)
@


1.40.4.1
log
@Merge from -current:

----
Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
----

Requested by guenther@@. The hpux_compat change here is more
conservative than committed to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.40 2009/04/15 10:47:46 art Exp $	*/
d154 1
a154 1
 * Is p an inferior of parent?
d157 1
a157 1
inferior(struct proc *p, struct proc *parent)
d160 2
a161 2
	for (; p != parent; p = p->p_pptr)
		if (p->p_pid == 0 || p->p_pid == 1)
@


1.39
log
@change all callers of enterpgrp() to pre-allocate a pgrp or session if
it might be needed later -- before calling pfind(), so that enterpgrp()
can operate without sleeping
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.37 2008/10/31 17:15:30 deraadt Exp $	*/
a110 4
/*
 * Change the count associated with number of processes
 * a given user is using.
 */
d137 4
@


1.39.2.1
log
@Merge from -current:

----
Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
----

Requested by guenther@@. The hpux_compat change here is more
conservative than committed to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.39 2008/11/01 05:59:21 deraadt Exp $	*/
d154 1
a154 1
 * Is p an inferior of parent?
d157 1
a157 1
inferior(struct proc *p, struct proc *parent)
d160 2
a161 2
	for (; p != parent; p = p->p_pptr)
		if (p->p_pid == 0 || p->p_pid == 1)
@


1.38
log
@accidental commit ... backout
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.36 2007/10/10 15:53:53 art Exp $	*/
d196 2
d200 2
a201 1
enterpgrp(struct proc *p, pid_t pgid, int mksess)
d206 1
a206 1
	if (pgrp != NULL && mksess)	/* firewalls */
a211 1
		pid_t savepid = p->p_pid;
d220 5
a224 1
		if ((np = pfind(savepid)) == NULL || np != p)
d226 1
a226 3
		pgrp = pool_get(&pgrp_pool, PR_WAITOK);
		if (mksess) {
			struct session *sess;
d228 2
d233 6
a238 7
			sess = pool_get(&session_pool, PR_WAITOK);
			sess->s_leader = p;
			sess->s_count = 1;
			sess->s_ttyvp = NULL;
			sess->s_ttyp = NULL;
			bcopy(p->p_session->s_login, sess->s_login,
			    sizeof(sess->s_login));
d240 1
a240 1
			pgrp->pg_session = sess;
d253 4
a256 1
	} else if (pgrp == p->p_pgrp)
d258 5
@


1.37
log
@kern_sysctl.c
@
text
@a195 2
 * Caller provides a pre-allocated pgrp and session that should
 * be freed if they are not used.
d198 1
a198 1
enterpgrp(struct proc *p, pid_t pgid, struct pgrp *npgrp, struct session *nsess)
d203 1
a203 1
	if (pgrp != NULL && nsess)	/* firewalls */
d218 1
a218 5

		if ((np = pfind(savepid)) == NULL || np != p) {
			pool_put(&pgrp_pool, npgrp);
			if (nsess)
				pool_put(&session_pool, nsess);
d220 3
a222 1
		}
a223 2
		pgrp = npgrp;
		if (nsess) {
d227 7
a233 6
			nsess->s_leader = p;
			nsess->s_count = 1;
			nsess->s_ttyvp = NULL;
			nsess->s_ttyp = NULL;
			bcopy(p->p_session->s_login, nsess->s_login,
			    sizeof(nsess->s_login));
d235 1
a235 1
			pgrp->pg_session = nsess;
d248 1
a248 4
	} else if (pgrp == p->p_pgrp) {
		if (nsess)
			pool_put(&session_pool, nsess);
		pool_put(&pgrp_pool, npgrp);
a249 5
	} else {
		if (nsess)
			pool_put(&session_pool, nsess);
		pool_put(&pgrp_pool, npgrp);
	}
d438 3
a440 10
#ifdef MULTIPROCESSOR
			if (p == curproc) {
				if (p->p_cpu == curcpu())
					db_printf("%2d", curcpu()->ci_cpuid);
				else
					db_printf(" *");
			} else
#endif
				db_printf(" %c", p == curproc ? '*' : ' ');
			db_printf("%5d  ",p->p_pid);
@


1.36
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.35 2007/09/07 15:00:20 art Exp $	*/
d196 2
d200 1
a200 1
enterpgrp(struct proc *p, pid_t pgid, int mksess)
d205 1
a205 1
	if (pgrp != NULL && mksess)	/* firewalls */
d220 5
a224 1
		if ((np = pfind(savepid)) == NULL || np != p)
d226 1
a226 3
		pgrp = pool_get(&pgrp_pool, PR_WAITOK);
		if (mksess) {
			struct session *sess;
d228 2
d233 6
a238 7
			sess = pool_get(&session_pool, PR_WAITOK);
			sess->s_leader = p;
			sess->s_count = 1;
			sess->s_ttyvp = NULL;
			sess->s_ttyp = NULL;
			bcopy(p->p_session->s_login, sess->s_login,
			    sizeof(sess->s_login));
d240 1
a240 1
			pgrp->pg_session = sess;
d253 4
a256 1
	} else if (pgrp == p->p_pgrp)
d258 5
d451 10
a460 3
			db_printf("%c%5d  ", p == curproc ? '*' : ' ',
				p->p_pid);

@


1.35
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.34 2007/08/04 02:43:54 ckuethe Exp $	*/
d380 2
a381 2
	(*pr)("    forw=%p, back=%p, list=%p,%p\n",
	    p->p_forw, p->p_back, p->p_list.le_next, p->p_list.le_prev);
@


1.34
log
@Allow ddb>ps to print the full name of the wait state. Things like
"flt_noram1" would get truncated otherwise.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.33 2007/04/03 08:05:43 art Exp $	*/
d127 1
a127 2
	MALLOC(nuip, struct uidinfo *, sizeof(*nuip), M_PROC, M_WAITOK);
	/* may have slept, have to check again */
a134 1
	bzero(nuip, sizeof(*nuip));
@


1.33
log
@Start moving state that is shared among threads in a process into
a new struct. Instead of doing a huge rename and deal with the fallout
for weeks, like other projects that need no mention, we will slowly and
carefully move things out of struct proc into a new struct process.

 - Create struct process and the infrastructure to create and remove them.
 - Move threads in a process into struct process.

deraadt@@, tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.32 2007/03/15 10:22:30 art Exp $	*/
d427 1
a427 1
		db_printf("   PID  %5s  %5s  %5s  S  %10s  %-9s  %-16s\n",
d452 1
a452 1
				    "%-9.9s  %-16s\n",
@


1.32
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.31 2005/12/22 06:55:03 tedu Exp $	*/
d67 1
d96 2
@


1.31
log
@fix memory leak conditions in thrsleep and significantly simplify
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.30 2005/12/04 05:49:12 deraadt Exp $	*/
d233 1
a233 1
			p->p_flag &= ~P_CONTROLT;
@


1.30
log
@older gcc (like real C) does not let you declare local variables after
doing functional code; ie. LIST_INIT()
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.29 2005/12/03 18:09:08 tedu Exp $	*/
a83 4
#ifdef RTHREADS
	extern struct pool sleeper_pool;
#endif

a105 4
#ifdef RTHREADS
	pool_init(&sleeper_pool, sizeof(struct twaitnode), 0, 0, 0, "thrwaitpl",
	    &pool_allocator_nointr);
#endif
@


1.29
log
@kernel support for threaded processes (rthreads).
uses rfork(RFTHREAD) to create threads, which are presently processes
that are a little more tightly bound together.  several new syscalls
added to facilitate a userland thread library.
all conditional on RTHREADS, currently disabled.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.28 2005/11/28 00:14:28 jsg Exp $	*/
d84 3
a90 3
#ifdef RTHREADS
	extern struct pool sleeper_pool;
#endif
@


1.28
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.27 2005/07/04 00:20:42 tedu Exp $	*/
d88 4
d110 4
@


1.27
log
@oops, kernel free needs two args.  thanks pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.26 2005/07/03 22:56:07 tedu Exp $	*/
d82 1
a82 1
procinit()
d156 1
a156 2
inferior(p)
	register struct proc *p;
d169 1
a169 2
pfind(pid)
	register pid_t pid;
d171 1
a171 1
	register struct proc *p;
d183 1
a183 2
pgfind(pgid)
	register pid_t pgid;
d185 1
a185 1
	register struct pgrp *pgrp;
d197 1
a197 4
enterpgrp(p, pgid, mksess)
	register struct proc *p;
	pid_t pgid;
	int mksess;
d199 1
a199 1
	register struct pgrp *pgrp = pgfind(pgid);
d221 1
a221 1
			register struct session *sess;
d270 1
a270 2
leavepgrp(p)
	register struct proc *p;
d284 1
a284 2
pgdelete(pgrp)
	register struct pgrp *pgrp;
d306 1
a306 4
fixjobc(p, pgrp, entering)
	register struct proc *p;
	register struct pgrp *pgrp;
	int entering;
d308 2
a309 2
	register struct pgrp *hispgrp;
	register struct session *mysession = pgrp->pg_session;
d345 1
a345 2
orphanpg(pg)
	struct pgrp *pg;
d347 1
a347 1
	register struct proc *p;
d395 1
a395 5
db_show_all_procs(addr, haddr, count, modif)
	db_expr_t addr;
	int haddr;
	db_expr_t count;
	char *modif;
d476 1
a476 1
pgrpdump()
d478 3
a480 3
	register struct pgrp *pgrp;
	register struct proc *p;
	register int i;
@


1.26
log
@malloc(M_WAITOK) implies sleeping, so we have to double check that
somebody else didn't beat us in uid_find().
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.25 2005/03/10 17:26:10 tedu Exp $	*/
d88 5
a92 3
	pidhashtbl = hashinit(maxproc / 4, M_PROC, M_WAITOK, &pidhash);
	pgrphashtbl = hashinit(maxproc / 4, M_PROC, M_WAITOK, &pgrphash);
	uihashtbl = hashinit(maxproc / 16, M_PROC, M_WAITOK, &uihash);
d130 1
a130 1
		free(nuip);
@


1.25
log
@split out uidinfo from kern_proc.c private, use it to store lock count,
restrict lock count per uid to a global limit, add sysctl to adjust limit.
this prevents a user from creating too many locks.  problem noticed
by devon o'dell.  ok deraadt miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.24 2004/12/26 21:22:13 miod Exp $	*/
d113 1
a113 1
	struct uidinfo *uip;
d122 12
a133 4
	MALLOC(uip, struct uidinfo *, sizeof(*uip), M_PROC, M_WAITOK);
	bzero(uip, sizeof(*uip));
	LIST_INSERT_HEAD(uipp, uip, ui_hash);
	uip->ui_uid = uid;
d135 1
a135 1
	return (uip);
@


1.24
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.23 2004/11/18 15:10:24 markus Exp $	*/
a51 8
/*
 * Structure associated with user caching.
 */
struct uidinfo {
	LIST_ENTRY(uidinfo) ui_hash;
	uid_t	ui_uid;
	long	ui_proccnt;
};
d110 2
a111 4
int
chgproccnt(uid, diff)
	uid_t	uid;
	int	diff;
d113 2
a114 2
	register struct uidinfo *uip;
	register struct uihashhead *uipp;
d120 2
a121 15
	if (uip) {
		uip->ui_proccnt += diff;
		if (uip->ui_proccnt > 0)
			return (uip->ui_proccnt);
		if (uip->ui_proccnt < 0)
			panic("chgproccnt: procs < 0");
		LIST_REMOVE(uip, ui_hash);
		FREE(uip, M_PROC);
		return (0);
	}
	if (diff <= 0) {
		if (diff == 0)
			return(0);
		panic("chgproccnt: lost user");
	}
d123 1
d126 14
a139 2
	uip->ui_proccnt = diff;
	return (diff);
@


1.23
log
@handle SONPROC; ok aaron, deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.22 2004/10/04 12:03:45 pedro Exp $	*/
d127 1
a127 1
	for (uip = uipp->lh_first; uip != 0; uip = uip->ui_hash.le_next)
d175 1
a175 1
	for (p = PIDHASH(pid)->lh_first; p != 0; p = p->p_hash.le_next)
d190 1
a190 1
	for (pgrp = PGRPHASH(pgid)->lh_first; pgrp != 0; pgrp = pgrp->pg_hash.le_next)
d265 1
a265 1
	if (p->p_pgrp->pg_members.lh_first == 0)
d281 1
a281 1
	if (p->p_pgrp->pg_members.lh_first == 0)
d339 1
a339 1
	for (p = p->p_children.lh_first; p != 0; p = p->p_sibling.le_next)
d361 1
a361 1
	for (p = pg->pg_members.lh_first; p != 0; p = p->p_pglist.le_next) {
d363 1
a363 2
			for (p = pg->pg_members.lh_first; p != 0;
			    p = p->p_pglist.le_next) {
d499 1
a499 1
		if ((pgrp = pgrphashtbl[i].lh_first) != NULL) {
d501 1
a501 1
			for (; pgrp != 0; pgrp = pgrp->pg_hash.le_next) {
d505 2
a506 3
				    pgrp->pg_members.lh_first);
				for (p = pgrp->pg_members.lh_first; p != 0;
				    p = p->p_pglist.le_next) {
@


1.22
log
@cacheing -> caching
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.21 2004/07/25 20:50:51 tedu Exp $	*/
d378 1
a378 1
		"idle", "run", "sleep", "stop", "zombie", "dead"
@


1.21
log
@move db_show_all_procs to kern_proc.c, proc_printit goes in DDB too.
shuffle functions around so that scheduler is all together.
no real functional changes. ok art@@ testing miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.20 2004/07/22 15:42:11 art Exp $	*/
d53 1
a53 1
 * Structure associated with user cacheing.
@


1.20
log
@SIMPLELOCK -> mutex for the lock around deadproc list.
Also move the whole deadproc infrastructure to kern_exit, it's only used
there.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.19 2004/06/13 21:49:26 niklas Exp $	*/
d373 1
d402 88
@


1.19
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a80 10
/*
 * Locking of this proclist is special; it's accessed in a
 * critical section of process exit, and thus locking it can't
 * modify interrupt state.  We use a simple spin lock for this
 * proclist.  Processes on this proclist are also on zombproc;
 * we use the p_hash member to linkup to deadproc.
 */
struct SIMPLELOCK deadproc_slock;
struct proclist deadproc;		/* dead, but not yet undead */

a94 3

	LIST_INIT(&deadproc);
	SIMPLE_LOCK_INIT(&deadproc_slock);
@


1.18
log
@The Sxxx proc state defines start at 1, not 0.  Also make the const
usage more correct and fix a signed/unsigned format mismatch.
Based on a patch from Patrick Latifi.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.17 2003/06/02 23:28:05 millert Exp $	*/
d88 1
a88 1
struct simplelock deadproc_slock;
d107 1
a107 1
	simple_lock_init(&deadproc_slock);
@


1.17
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.16 2003/05/12 22:49:53 art Exp $	*/
d389 1
a389 1
	const static char *pstat[] = {
d395 1
a395 1
	if (p->p_stat > sizeof(pstat)/sizeof(*pstat))
d398 1
a398 1
		pst = pstat[(int)p->p_stat];
d408 1
a408 1
	(*pr)("    estcpu=%u, cpticks=%d, pctcpu=%d.%d%, swtime=%u\n",
@


1.16
log
@Quoting Theo: Do not approve diffs when you're hungover.
Accessing p_md members from MI code is not legal.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.15 2003/05/12 22:44:12 tedu Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.15
log
@use snprintf. ok mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.14 2003/05/12 19:56:03 mickey Exp $	*/
d410 2
a411 2
	(*pr)("    user=%p, vmspace=%p, md_regs=%p\n",
	    p->p_addr, p->p_vmspace, p->p_md.md_regs);
@


1.14
log
@sho proc [addr] to print some proc's field; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.13 2002/03/14 01:27:04 millert Exp $	*/
d400 1
a400 1
		sprintf(pstbuf, "%d", p->p_stat);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.12 2002/01/25 15:00:26 art Exp $	*/
d388 29
@


1.12
log
@poolify pcreds.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.11 2002/01/23 15:46:48 art Exp $	*/
d95 1
a95 1
static void orphanpg __P((struct pgrp *));
d97 1
a97 1
void pgrpdump __P((void));
@


1.11
log
@Allocate rusage, pgrp, ucred and session with pool.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.10 2002/01/23 00:39:47 art Exp $	*/
d83 1
d126 2
@


1.10
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.9 2002/01/16 20:50:17 miod Exp $	*/
d79 4
d117 9
a125 1
		&pool_allocator_nointr);
d239 1
a239 2
		MALLOC(pgrp, struct pgrp *, sizeof(struct pgrp), M_PGRP,
		    M_WAITOK);
d246 1
a246 2
			MALLOC(sess, struct session *, sizeof(struct session),
			    M_SESSION, M_WAITOK);
d313 2
a314 3
	if (--pgrp->pg_session->s_count == 0)
		FREE(pgrp->pg_session, M_SESSION);
	FREE(pgrp, M_PGRP);
@


1.9
log
@Don't include <sys/map.h> when you don't need what's in it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.8 2001/03/23 18:42:06 art Exp $	*/
d113 1
a113 1
		0, pool_page_alloc_nointr, pool_page_free_nointr, M_PROC);
@


1.8
log
@Use pool to allocate processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.7 2000/06/05 11:02:50 art Exp $	*/
a40 1
#include <sys/map.h>
@


1.8.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.12 2002/01/25 15:00:26 art Exp $	*/
d41 1
a79 5
struct pool rusage_pool;
struct pool ucred_pool;
struct pool pgrp_pool;
struct pool session_pool;
struct pool pcred_pool;
d114 1
a114 11
	    &pool_allocator_nointr);
	pool_init(&rusage_pool, sizeof(struct rusage), 0, 0, 0, "zombiepl",
	    &pool_allocator_nointr);
	pool_init(&ucred_pool, sizeof(struct ucred), 0, 0, 0, "ucredpl",
	    &pool_allocator_nointr);
	pool_init(&pgrp_pool, sizeof(struct pgrp), 0, 0, 0, "pgrppl",
	    &pool_allocator_nointr);
	pool_init(&session_pool, sizeof(struct session), 0, 0, 0, "sessionpl",
	    &pool_allocator_nointr);
	pool_init(&pcred_pool, sizeof(struct pcred), 0, 0, 0, "pcredpl",
	    &pool_allocator_nointr);
d228 2
a229 1
		pgrp = pool_get(&pgrp_pool, PR_WAITOK);
d236 2
a237 1
			sess = pool_get(&session_pool, PR_WAITOK);
d304 3
a306 2
	SESSRELE(pgrp->pg_session);
	pool_put(&pgrp_pool, pgrp);
@


1.8.6.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.8.6.1 2002/01/31 22:55:40 niklas Exp $	*/
d95 1
a95 1
static void orphanpg(struct pgrp *);
d97 1
a97 1
void pgrpdump(void);
@


1.8.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a387 29
}

void 
proc_printit(struct proc *p, const char *modif, int (*pr)(const char *, ...))
{
	const static char *pstat[] = {
		"idle", "run", "sleep", "stop", "zombie", "dead"
	};
	char pstbuf[5];
	const char *pst = pstbuf;

	if (p->p_stat > sizeof(pstat)/sizeof(*pstat))
		snprintf(pstbuf, sizeof(pstbuf), "%d", p->p_stat);
	else
		pst = pstat[(int)p->p_stat];

	(*pr)("PROC (%s) pid=%d stat=%s flags=%b\n",
	    p->p_comm, p->p_pid, pst, p->p_flag, P_BITS);
	(*pr)("    pri=%u, usrpri=%u, nice=%d\n",
	    p->p_priority, p->p_usrpri, p->p_nice);
	(*pr)("    forw=%p, back=%p, list=%p,%p\n",
	    p->p_forw, p->p_back, p->p_list.le_next, p->p_list.le_prev);
	(*pr)("    user=%p, vmspace=%p\n",
	    p->p_addr, p->p_vmspace);
	(*pr)("    estcpu=%u, cpticks=%d, pctcpu=%d.%d%, swtime=%u\n",
	    p->p_estcpu, p->p_cpticks, p->p_pctcpu / 100, p->p_pctcpu % 100,
	    p->p_swtime);
	(*pr)("    user=%llu, sys=%llu, intr=%llu\n",
	    p->p_uticks, p->p_sticks, p->p_iticks);
@


1.7
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.6 1999/04/28 09:28:14 art Exp $	*/
d55 1
d79 2
d112 3
@


1.6
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.5 1998/03/02 07:19:11 todd Exp $	*/
d78 10
d102 4
d342 1
a342 1
		    p->p_stat != SZOMB) {
@


1.6.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.8 2001/03/23 18:42:06 art Exp $	*/
a54 1
#include <sys/pool.h>
a77 12
struct pool proc_pool;

/*
 * Locking of this proclist is special; it's accessed in a
 * critical section of process exit, and thus locking it can't
 * modify interrupt state.  We use a simple spin lock for this
 * proclist.  Processes on this proclist are also on zombproc;
 * we use the p_hash member to linkup to deadproc.
 */
struct simplelock deadproc_slock;
struct proclist deadproc;		/* dead, but not yet undead */

a91 4

	LIST_INIT(&deadproc);
	simple_lock_init(&deadproc_slock);

a94 3

	pool_init(&proc_pool, sizeof(struct proc), 0, 0, 0, "procpl",
		0, pool_page_alloc_nointr, pool_page_free_nointr, M_PROC);
d328 1
a328 1
		    P_ZOMBIE(p) == 0) {
@


1.6.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a79 5
struct pool rusage_pool;
struct pool ucred_pool;
struct pool pgrp_pool;
struct pool session_pool;
struct pool pcred_pool;
d114 1
a114 11
	    &pool_allocator_nointr);
	pool_init(&rusage_pool, sizeof(struct rusage), 0, 0, 0, "zombiepl",
	    &pool_allocator_nointr);
	pool_init(&ucred_pool, sizeof(struct ucred), 0, 0, 0, "ucredpl",
	    &pool_allocator_nointr);
	pool_init(&pgrp_pool, sizeof(struct pgrp), 0, 0, 0, "pgrppl",
	    &pool_allocator_nointr);
	pool_init(&session_pool, sizeof(struct session), 0, 0, 0, "sessionpl",
	    &pool_allocator_nointr);
	pool_init(&pcred_pool, sizeof(struct pcred), 0, 0, 0, "pcredpl",
	    &pool_allocator_nointr);
d228 2
a229 1
		pgrp = pool_get(&pgrp_pool, PR_WAITOK);
d236 2
a237 1
			sess = pool_get(&session_pool, PR_WAITOK);
d304 3
a306 2
	SESSRELE(pgrp->pg_session);
	pool_put(&pgrp_pool, pgrp);
@


1.6.4.3
log
@Merge in -current from about a week ago
@
text
@d95 1
a95 1
static void orphanpg(struct pgrp *);
d97 1
a97 1
void pgrpdump(void);
@


1.6.4.4
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@a389 29
void 
proc_printit(struct proc *p, const char *modif, int (*pr)(const char *, ...))
{
	const static char *pstat[] = {
		"idle", "run", "sleep", "stop", "zombie", "dead"
	};
	char pstbuf[5];
	const char *pst = pstbuf;

	if (p->p_stat > sizeof(pstat)/sizeof(*pstat))
		snprintf(pstbuf, sizeof(pstbuf), "%d", p->p_stat);
	else
		pst = pstat[(int)p->p_stat];

	(*pr)("PROC (%s) pid=%d stat=%s flags=%b\n",
	    p->p_comm, p->p_pid, pst, p->p_flag, P_BITS);
	(*pr)("    pri=%u, usrpri=%u, nice=%d\n",
	    p->p_priority, p->p_usrpri, p->p_nice);
	(*pr)("    forw=%p, back=%p, list=%p,%p\n",
	    p->p_forw, p->p_back, p->p_list.le_next, p->p_list.le_prev);
	(*pr)("    user=%p, vmspace=%p\n",
	    p->p_addr, p->p_vmspace);
	(*pr)("    estcpu=%u, cpticks=%d, pctcpu=%d.%d%, swtime=%u\n",
	    p->p_estcpu, p->p_cpticks, p->p_pctcpu / 100, p->p_pctcpu % 100,
	    p->p_swtime);
	(*pr)("    user=%llu, sys=%llu, intr=%llu\n",
	    p->p_uticks, p->p_sticks, p->p_iticks);
}

@


1.6.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.6.4.4 2003/05/16 00:29:43 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d389 1
a389 1
	static const char *const pstat[] = {
d395 1
a395 1
	if (p->p_stat < 1 || p->p_stat > sizeof(pstat) / sizeof(pstat[0]))
d398 1
a398 1
		pst = pstat[(int)p->p_stat - 1];
d408 1
a408 1
	(*pr)("    estcpu=%u, cpticks=%d, pctcpu=%u.%u%, swtime=%u\n",
@


1.6.4.7
log
@deadproc mgmt is outside biglock, make its lock a real one
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.6.4.6 2004/02/19 10:56:37 niklas Exp $	*/
d88 1
a88 1
struct SIMPLELOCK deadproc_slock;
d107 1
a107 1
	SIMPLE_LOCK_INIT(&deadproc_slock);
@


1.5
log
@Please gcc 2.8
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.4 1998/02/20 13:47:22 niklas Exp $	*/
d92 3
a94 3
	pidhashtbl = hashinit(maxproc / 4, M_PROC, &pidhash);
	pgrphashtbl = hashinit(maxproc / 4, M_PROC, &pgrphash);
	uihashtbl = hashinit(maxproc / 16, M_PROC, &uihash);
@


1.4
log
@Please GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.3 1997/11/24 03:22:41 deraadt Exp $	*/
d365 1
a365 1
	register i;
@


1.3
log
@fix memory leak; hbriceno@@lcs.mit.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_proc.c,v 1.2 1996/03/03 17:19:51 niklas Exp $	*/
d313 1
a313 1
	    hispgrp->pg_session == mysession)
d318 1
d328 1
a328 1
		    p->p_stat != SZOMB)
d333 1
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d206 2
a209 2
		if ((np = pfind(savepid)) == NULL || np != p)
			return (ESRCH);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: kern_proc.c,v 1.12 1995/03/19 23:44:49 mycroft Exp $	*/
d78 5
a288 2
static void orphanpg();

d358 1
d366 1
a366 1
		if (pgrp = pgrphashtbl[i].lh_first) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

