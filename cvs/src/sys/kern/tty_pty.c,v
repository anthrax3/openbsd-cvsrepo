head	1.80;
access;
symbols
	OPENBSD_6_1:1.79.0.4
	OPENBSD_6_1_BASE:1.79
	OPENBSD_6_0:1.78.0.2
	OPENBSD_6_0_BASE:1.78
	OPENBSD_5_9:1.76.0.2
	OPENBSD_5_9_BASE:1.76
	OPENBSD_5_8:1.70.0.6
	OPENBSD_5_8_BASE:1.70
	OPENBSD_5_7:1.70.0.2
	OPENBSD_5_7_BASE:1.70
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.63.0.4
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.59.0.4
	OPENBSD_5_4_BASE:1.59
	OPENBSD_5_3:1.59.0.2
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.58.0.2
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.57
	OPENBSD_5_1:1.57.0.4
	OPENBSD_5_0:1.57.0.2
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.52.0.2
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.51.0.2
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.43.0.2
	OPENBSD_4_7_BASE:1.43
	OPENBSD_4_6:1.38.0.8
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.4
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.33.0.4
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.33.0.2
	OPENBSD_4_0_BASE:1.33
	OPENBSD_3_9:1.32.0.2
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.25.0.2
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.8.0.4
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.16
	OPENBSD_2_8:1.7.0.14
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.10
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.80
date	2017.07.04.17.29.51;	author tedu;	state Exp;
branches;
next	1.79;
commitid	d9jT22ARe1rvdMve;

1.79
date	2017.02.11.19.51.06;	author guenther;	state Exp;
branches;
next	1.78;
commitid	dp1qF9REvzwtzfTw;

1.78
date	2016.05.24.16.09.07;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	fXA64S3toS3jz7A7;

1.77
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.76;
commitid	gAjwyca5TfuoJAhn;

1.76
date	2016.01.28.18.02.36;	author stefan;	state Exp;
branches;
next	1.75;
commitid	fsgmOcbYuputR8vV;

1.75
date	2016.01.14.09.44.08;	author sf;	state Exp;
branches;
next	1.74;
commitid	ufhpvQnfS1RjjAYf;

1.74
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.73;
commitid	Cl55DD2g2xm69E6W;

1.73
date	2015.11.02.16.31.55;	author semarie;	state Exp;
branches;
next	1.72;
commitid	PyvdcQVr9G4daVnG;

1.72
date	2015.10.28.11.22.08;	author deraadt;	state Exp;
branches;
next	1.71;
commitid	fGRHbMGA6huab4SX;

1.71
date	2015.09.28.19.16.04;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	zbtPPj2yLF2rwpjO;

1.70
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.69;
commitid	C5iGb36LQxjM60Q3;

1.69
date	2014.11.18.23.55.01;	author krw;	state Exp;
branches;
next	1.68;
commitid	Qb045HZ5OhQfU69H;

1.68
date	2014.07.13.15.29.04;	author tedu;	state Exp;
branches;
next	1.67;
commitid	bFFVdS3JEaMhyZxJ;

1.67
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.66;
commitid	QlVV51SZgNFxsXxC;

1.66
date	2014.07.09.15.46.22;	author tedu;	state Exp;
branches;
next	1.65;
commitid	uvHu90KgKRPsOij7;

1.65
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.64;

1.64
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.63;

1.63
date	2013.12.13.19.55.12;	author naddy;	state Exp;
branches;
next	1.62;

1.62
date	2013.10.11.12.44.13;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	2013.10.06.01.10.53;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2013.10.04.17.52.55;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2013.01.02.16.14.56;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.02.22.20.08;	author nicm;	state Exp;
branches;
next	1.55;

1.55
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.53;

1.53
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.52;

1.52
date	2010.09.24.02.59.39;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2010.08.06.00.00.41;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.49;

1.49
date	2010.07.21.18.48.01;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.02.19.57.15;	author tedu;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.28.14.13.36;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.02.20.20.23;	author nicm;	state Exp;
branches;
next	1.43;

1.43
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.42;

1.42
date	2009.10.31.12.00.08;	author fgsch;	state Exp;
branches;
next	1.41;

1.41
date	2009.10.30.16.41.10;	author nicm;	state Exp;
branches;
next	1.40;

1.40
date	2009.10.14.07.19.05;	author nicm;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.29.17.26.09;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.02.11.39.38;	author stefan;	state Exp;
branches;
next	1.37;

1.37
date	2008.05.07.09.35.52;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2008.04.10.19.55.41;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.29.00.17.32;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2006.03.04.19.33.21;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.18.23.42.12;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.21.12.43.49;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.21.01.16.02;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.26.00.33.45;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.28.15.43.24;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.19.01.44.07;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.07.03.42.45;	author pat;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.22.06.13.08;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.21.12.10.20;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.09.08.55.41;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.11.18.04.36;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.04.11.16.41.30;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.02.23.21.17.54;	author beck;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.10.21.06.50;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.10.01.31.21;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.10.01.19.47;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.03.16.44.51;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.22.01.03.12;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.14.23.14.30;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.27.05;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.17.07.07.49;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.19.18.52.05;	author mickey;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	97.11.30.21.41.03;	author deraadt;	state Exp;
branches
	1.7.10.1;
next	1.6;

1.6
date	97.11.13.03.11.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.02.24.14.20.00;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.06.10.07.26.23;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.27.31;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.13.38.54;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches;
next	;

1.7.10.1
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.7.10.2;

1.7.10.2
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.7.10.3;

1.7.10.3
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.7.10.4;

1.7.10.4
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.7.10.5;

1.7.10.5
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	1.7.10.6;

1.7.10.6
date	2004.06.05.23.13.02;	author niklas;	state Exp;
branches;
next	;

1.8.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.80
log
@some of this code was written in an era when spaces cost extra.
add a little breathing room.
@
text
@/*	$OpenBSD: tty_pty.c,v 1.79 2017/02/11 19:51:06 guenther Exp $	*/
/*	$NetBSD: tty_pty.c,v 1.33.4.1 1996/06/02 09:08:11 mrg Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tty_pty.c	8.4 (Berkeley) 2/20/95
 */

/*
 * Pseudo-teletype Driver
 * (Actually two drivers, requiring two entries in 'cdevsw')
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/mount.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/vnode.h>
#include <sys/signalvar.h>
#include <sys/conf.h>
#include <sys/stat.h>
#include <sys/sysctl.h>
#include <sys/poll.h>
#include <sys/pledge.h>
#include <sys/rwlock.h>

#define BUFSIZ 100		/* Chunk size iomoved to/from user */

/*
 * pts == /dev/tty[p-zP-T][0-9a-zA-Z]
 * ptc == /dev/pty[p-zP-T][0-9a-zA-Z]
 */

/* XXX this needs to come from somewhere sane, and work with MAKEDEV */
#define TTY_LETTERS "pqrstuvwxyzPQRST"
#define TTY_SUFFIX "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

static int pts_major;

struct	pt_softc {
	struct	tty *pt_tty;
	int	pt_flags;
	struct	selinfo pt_selr, pt_selw;
	u_char	pt_send;
	u_char	pt_ucntl;
	char	pty_pn[11];
	char	pty_sn[11];
};

#define	NPTY_MIN		8	/* number of initial ptys */
#define NPTY_MAX		992	/* maximum number of ptys supported */

static struct pt_softc **pt_softc = NULL;	/* pty array */
static int npty = 0;				/* size of pty array */
static int maxptys = NPTY_MAX;			/* maximum number of ptys */
/* for pty array */
struct rwlock pt_softc_lock = RWLOCK_INITIALIZER("ptarrlk");

#define	PF_PKT		0x08		/* packet mode */
#define	PF_STOPPED	0x10		/* user told stopped */
#define	PF_REMOTE	0x20		/* remote and flow controlled input */
#define	PF_NOSTOP	0x40
#define PF_UCNTL	0x80		/* user control mode */

void	ptyattach(int);
void	ptcwakeup(struct tty *, int);
struct tty *ptytty(dev_t);
void	ptsstart(struct tty *);
int	sysctl_pty(int *, u_int, void *, size_t *, void *, size_t);

void	filt_ptcrdetach(struct knote *);
int	filt_ptcread(struct knote *, long);
void	filt_ptcwdetach(struct knote *);
int	filt_ptcwrite(struct knote *, long);

static struct pt_softc **ptyarralloc(int);
static int check_pty(int);

static gid_t tty_gid = TTY_GID;

void	ptydevname(int, struct pt_softc *);
dev_t	pty_getfree(void);

void	ptmattach(int);
int	ptmopen(dev_t, int, int, struct proc *);
int	ptmclose(dev_t, int, int, struct proc *);
int	ptmioctl(dev_t, u_long, caddr_t, int, struct proc *p);
static int ptm_vn_open(struct nameidata *);

void
ptydevname(int minor, struct pt_softc *pti)
{
	char buf[11] = "/dev/XtyXX";
	int i, j;

	i = minor / (sizeof(TTY_SUFFIX) - 1);
	j = minor % (sizeof(TTY_SUFFIX) - 1);
	if (i >= sizeof(TTY_LETTERS) - 1) {
		pti->pty_pn[0] = '\0';
		pti->pty_sn[0] = '\0';
		return;
	}
	buf[5] = 'p';
	buf[8] = TTY_LETTERS[i];
	buf[9] = TTY_SUFFIX[j];
	memcpy(pti->pty_pn, buf, sizeof(buf));
	buf[5] = 't';
	memcpy(pti->pty_sn, buf, sizeof(buf));
}

/*
 * Allocate and zero array of nelem elements.
 */
struct pt_softc **
ptyarralloc(int nelem)
{
	struct pt_softc **pt;

	pt = mallocarray(nelem, sizeof(struct pt_softc *), M_DEVBUF,
	    M_WAITOK|M_ZERO);
	return pt;
}

/*
 * Check if the minor is correct and ensure necessary structures
 * are properly allocated.
 */
int
check_pty(int minor)
{
	struct pt_softc *pti;

	rw_enter_write(&pt_softc_lock);
	if (minor >= npty) {
		struct pt_softc **newpt;
		int newnpty;

		/* check if the requested pty can be granted */
		if (minor >= maxptys)
			goto limit_reached;

		/* grow pty array by powers of two, up to maxptys */
		for (newnpty = npty; newnpty <= minor; newnpty *= 2)
			;

		if (newnpty > maxptys)
			newnpty = maxptys;
		newpt = ptyarralloc(newnpty);

		memcpy(newpt, pt_softc, npty * sizeof(struct pt_softc *));
		free(pt_softc, M_DEVBUF, npty * sizeof(struct pt_softc *));
		pt_softc = newpt;
		npty = newnpty;
	}

	/*
	 * If the entry is not yet allocated, allocate one.
	 */
	if (!pt_softc[minor]) {
		pti = malloc(sizeof(struct pt_softc), M_DEVBUF,
		    M_WAITOK|M_ZERO);
		pti->pt_tty = ttymalloc(1000000);
		ptydevname(minor, pti);
		pt_softc[minor] = pti;
	}
	rw_exit_write(&pt_softc_lock);
	return (0);
limit_reached:
	rw_exit_write(&pt_softc_lock);
	tablefull("pty");
	return (ENXIO);
}

/*
 * Establish n (or default if n is 1) ptys in the system.
 */
void
ptyattach(int n)
{
	/* maybe should allow 0 => none? */
	if (n <= 1)
		n = NPTY_MIN;
	pt_softc = ptyarralloc(n);
	npty = n;

	/*
	 * If we have pty, we need ptm too.
	 */
	ptmattach(1);
}

int
ptsopen(dev_t dev, int flag, int devtype, struct proc *p)
{
	struct pt_softc *pti;
	struct tty *tp;
	int error;

	if ((error = check_pty(minor(dev))))
		return (error);

	pti = pt_softc[minor(dev)];
	if (!pti->pt_tty) {
		tp = pti->pt_tty = ttymalloc(1000000);
	} else
		tp = pti->pt_tty;
	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
		ttychars(tp);		/* Set up default chars */
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		tp->t_cflag = TTYDEF_CFLAG;
		tp->t_ispeed = tp->t_ospeed = B115200;
		ttsetwater(tp);		/* would be done in xxparam() */
	} else if (tp->t_state & TS_XCLUDE && suser(p, 0) != 0)
		return (EBUSY);
	if (tp->t_oproc)			/* Ctrlr still around. */
		tp->t_state |= TS_CARR_ON;
	while ((tp->t_state & TS_CARR_ON) == 0) {
		tp->t_state |= TS_WOPEN;
		if (flag & FNONBLOCK)
			break;
		error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
				 ttopen, 0);
		if (error)
			return (error);
	}
	error = (*linesw[tp->t_line].l_open)(dev, tp, p);
	ptcwakeup(tp, FREAD|FWRITE);
	return (error);
}

int
ptsclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct pt_softc *pti = pt_softc[minor(dev)];
	struct tty *tp = pti->pt_tty;
	int error;

	error = (*linesw[tp->t_line].l_close)(tp, flag, p);
	error |= ttyclose(tp);
	ptcwakeup(tp, FREAD|FWRITE);
	return (error);
}

int
ptsread(dev_t dev, struct uio *uio, int flag)
{
	struct proc *p = curproc;
	struct process *pr = p->p_p;
	struct pt_softc *pti = pt_softc[minor(dev)];
	struct tty *tp = pti->pt_tty;
	int error = 0;

again:
	if (pti->pt_flags & PF_REMOTE) {
		while (isbackground(pr, tp)) {
			if ((pr->ps_sigacts->ps_sigignore & sigmask(SIGTTIN)) ||
			    (p->p_sigmask & sigmask(SIGTTIN)) ||
			    pr->ps_pgrp->pg_jobc == 0 ||
			    pr->ps_flags & PS_PPWAIT)
				return (EIO);
			pgsignal(pr->ps_pgrp, SIGTTIN, 1);
			error = ttysleep(tp, &lbolt,
			    TTIPRI | PCATCH, ttybg, 0);
			if (error)
				return (error);
		}
		if (tp->t_canq.c_cc == 0) {
			if (flag & IO_NDELAY)
				return (EWOULDBLOCK);
			error = ttysleep(tp, &tp->t_canq,
			    TTIPRI | PCATCH, ttyin, 0);
			if (error)
				return (error);
			goto again;
		}
		while (tp->t_canq.c_cc > 1 && uio->uio_resid > 0)
			if (ureadc(getc(&tp->t_canq), uio) < 0) {
				error = EFAULT;
				break;
			}
		if (tp->t_canq.c_cc == 1)
			(void) getc(&tp->t_canq);
		if (tp->t_canq.c_cc)
			return (error);
	} else
		if (tp->t_oproc)
			error = (*linesw[tp->t_line].l_read)(tp, uio, flag);
	ptcwakeup(tp, FWRITE);
	return (error);
}

/*
 * Write to pseudo-tty.
 * Wakeups of controlling tty will happen
 * indirectly, when tty driver calls ptsstart.
 */
int
ptswrite(dev_t dev, struct uio *uio, int flag)
{
	struct pt_softc *pti = pt_softc[minor(dev)];
	struct tty *tp = pti->pt_tty;

	if (tp->t_oproc == 0)
		return (EIO);
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

/*
 * Start output on pseudo-tty.
 * Wake up process polling or sleeping for input from controlling tty.
 */
void
ptsstart(struct tty *tp)
{
	struct pt_softc *pti = pt_softc[minor(tp->t_dev)];

	if (tp->t_state & TS_TTSTOP)
		return;
	if (pti->pt_flags & PF_STOPPED) {
		pti->pt_flags &= ~PF_STOPPED;
		pti->pt_send = TIOCPKT_START;
	}
	ptcwakeup(tp, FREAD);
}

int
ptsstop(struct tty *tp, int flush)
{
	struct pt_softc *pti = pt_softc[minor(tp->t_dev)];
	int flag;

	/* note: FLUSHREAD and FLUSHWRITE already ok */
	if (flush == 0) {
		flush = TIOCPKT_STOP;
		pti->pt_flags |= PF_STOPPED;
	} else
		pti->pt_flags &= ~PF_STOPPED;
	pti->pt_send |= flush;
	/* change of perspective */
	flag = 0;
	if (flush & FREAD)
		flag |= FWRITE;
	if (flush & FWRITE)
		flag |= FREAD;
	ptcwakeup(tp, flag);
	return 0;
}

void
ptcwakeup(struct tty *tp, int flag)
{
	struct pt_softc *pti = pt_softc[minor(tp->t_dev)];

	if (flag & FREAD) {
		selwakeup(&pti->pt_selr);
		wakeup(&tp->t_outq.c_cf);
	}
	if (flag & FWRITE) {
		selwakeup(&pti->pt_selw);
		wakeup(&tp->t_rawq.c_cf);
	}
}

int ptcopen(dev_t, int, int, struct proc *);

int
ptcopen(dev_t dev, int flag, int devtype, struct proc *p)
{
	struct pt_softc *pti;
	struct tty *tp;
	int error;

	if ((error = check_pty(minor(dev))))
		return (error);

	pti = pt_softc[minor(dev)];
	if (!pti->pt_tty) {
		tp = pti->pt_tty = ttymalloc(1000000);
	} else
		tp = pti->pt_tty;
	if (tp->t_oproc)
		return (EIO);
	tp->t_oproc = ptsstart;
	(void)(*linesw[tp->t_line].l_modem)(tp, 1);
	tp->t_lflag &= ~EXTPROC;
	pti->pt_flags = 0;
	pti->pt_send = 0;
	pti->pt_ucntl = 0;
	return (0);
}

int
ptcclose(dev_t dev, int flag, int devtype, struct proc *p)
{
	struct pt_softc *pti = pt_softc[minor(dev)];
	struct tty *tp = pti->pt_tty;

	(void)(*linesw[tp->t_line].l_modem)(tp, 0);
	tp->t_state &= ~TS_CARR_ON;
	tp->t_oproc = 0;		/* mark closed */
	return (0);
}

int
ptcread(dev_t dev, struct uio *uio, int flag)
{
	struct pt_softc *pti = pt_softc[minor(dev)];
	struct tty *tp = pti->pt_tty;
	char buf[BUFSIZ];
	int error = 0, cc, bufcc = 0;

	/*
	 * We want to block until the slave
	 * is open, and there's something to read;
	 * but if we lost the slave or we're NBIO,
	 * then return the appropriate error instead.
	 */
	for (;;) {
		if (tp->t_state & TS_ISOPEN) {
			if (pti->pt_flags & PF_PKT && pti->pt_send) {
				error = ureadc((int)pti->pt_send, uio);
				if (error)
					return (error);
				if (pti->pt_send & TIOCPKT_IOCTL) {
					cc = MIN(uio->uio_resid,
						sizeof(tp->t_termios));
					error = uiomove(&tp->t_termios, cc, uio);
					if (error)
						return (error);
				}
				pti->pt_send = 0;
				return (0);
			}
			if (pti->pt_flags & PF_UCNTL && pti->pt_ucntl) {
				error = ureadc((int)pti->pt_ucntl, uio);
				if (error)
					return (error);
				pti->pt_ucntl = 0;
				return (0);
			}
			if (tp->t_outq.c_cc && (tp->t_state & TS_TTSTOP) == 0)
				break;
		}
		if ((tp->t_state & TS_CARR_ON) == 0)
			return (0);	/* EOF */
		if (flag & IO_NDELAY)
			return (EWOULDBLOCK);
		error = tsleep(&tp->t_outq.c_cf, TTIPRI | PCATCH,
		    ttyin, 0);
		if (error)
			return (error);
	}
	if (pti->pt_flags & (PF_PKT|PF_UCNTL))
		error = ureadc(0, uio);
	while (uio->uio_resid > 0 && error == 0) {
		cc = MIN(uio->uio_resid, BUFSIZ);
		cc = q_to_b(&tp->t_outq, buf, cc);
		if (cc > bufcc)
			bufcc = cc;
		if (cc <= 0)
			break;
		error = uiomove(buf, cc, uio);
	}
	ttwakeupwr(tp);
	if (bufcc)
		explicit_bzero(buf, bufcc);
	return (error);
}


int
ptcwrite(dev_t dev, struct uio *uio, int flag)
{
	struct pt_softc *pti = pt_softc[minor(dev)];
	struct tty *tp = pti->pt_tty;
	u_char *cp = NULL;
	int cc = 0, bufcc = 0;
	u_char buf[BUFSIZ];
	size_t cnt = 0;
	int error = 0;

again:
	if ((tp->t_state & TS_ISOPEN) == 0)
		goto block;
	if (pti->pt_flags & PF_REMOTE) {
		if (tp->t_canq.c_cc)
			goto block;
		while (uio->uio_resid > 0 && tp->t_canq.c_cc < TTYHOG(tp) - 1) {
			if (cc == 0) {
				cc = MIN(uio->uio_resid, BUFSIZ);
				cc = min(cc, TTYHOG(tp) - 1 - tp->t_canq.c_cc);
				if (cc > bufcc)
					bufcc = cc;
				cp = buf;
				error = uiomove(cp, cc, uio);
				if (error)
					goto done;
				/* check again for safety */
				if ((tp->t_state & TS_ISOPEN) == 0) {
					error = EIO;
					goto done;
				}
			}
			if (cc)
				(void) b_to_q((char *)cp, cc, &tp->t_canq);
			cc = 0;
		}
		(void) putc(0, &tp->t_canq);
		ttwakeup(tp);
		wakeup(&tp->t_canq);
		goto done;
	}
	do {
		if (cc == 0) {
			cc = MIN(uio->uio_resid, BUFSIZ);
			if (cc > bufcc)
				bufcc = cc;
			cp = buf;
			error = uiomove(cp, cc, uio);
			if (error)
				goto done;
			/* check again for safety */
			if ((tp->t_state & TS_ISOPEN) == 0) {
				error = EIO;
				goto done;
			}
		}
		bufcc = cc;
		while (cc > 0) {
			if ((tp->t_rawq.c_cc + tp->t_canq.c_cc) >= TTYHOG(tp) - 2 &&
			   (tp->t_canq.c_cc > 0 || !ISSET(tp->t_lflag, ICANON))) {
				wakeup(&tp->t_rawq);
				goto block;
			}
			(*linesw[tp->t_line].l_rint)(*cp++, tp);
			cnt++;
			cc--;
		}
		cc = 0;
	} while (uio->uio_resid > 0);
	goto done;
block:
	/*
	 * Come here to wait for slave to open, for space
	 * in outq, or space in rawq.
	 */
	if ((tp->t_state & TS_CARR_ON) == 0) {
		error = EIO;
		goto done;
	}
	if (flag & IO_NDELAY) {
		/* adjust for data copied in but not written */
		uio->uio_resid += cc;
		if (cnt == 0)
			error = EWOULDBLOCK;
		goto done;
	}
	error = tsleep(&tp->t_rawq.c_cf, TTOPRI | PCATCH,
	    ttyout, 0);
	if (error == 0)
		goto again;

	/* adjust for data copied in but not written */
	uio->uio_resid += cc;
done:
	if (bufcc)
		explicit_bzero(buf, bufcc);
	return (error);
}

int
ptcpoll(dev_t dev, int events, struct proc *p)
{
	struct pt_softc *pti = pt_softc[minor(dev)];
	struct tty *tp = pti->pt_tty;
	int revents = 0, s;

	if (!ISSET(tp->t_state, TS_ISOPEN) && ISSET(tp->t_state, TS_CARR_ON))
		goto notopen;

	if (events & (POLLIN | POLLRDNORM)) {
		/*
		 * Need to protect access to t_outq
		 */
		s = spltty();
		if ((tp->t_outq.c_cc && !ISSET(tp->t_state, TS_TTSTOP)) ||
		    ((pti->pt_flags & PF_PKT) && pti->pt_send) ||
		    ((pti->pt_flags & PF_UCNTL) && pti->pt_ucntl))
			revents |= events & (POLLIN | POLLRDNORM);
		splx(s);
	}
	/* NOTE: POLLHUP and POLLOUT/POLLWRNORM are mutually exclusive */
	if (!ISSET(tp->t_state, TS_CARR_ON)) {
		revents |= POLLHUP;
	} else if (events & (POLLOUT | POLLWRNORM)) {
		if ((pti->pt_flags & PF_REMOTE) ?
		    (tp->t_canq.c_cc == 0) :
		    ((tp->t_rawq.c_cc + tp->t_canq.c_cc < TTYHOG(tp) - 2) ||
		    (tp->t_canq.c_cc == 0 && ISSET(tp->t_lflag, ICANON))))
			revents |= events & (POLLOUT | POLLWRNORM);
	}
	if (events & (POLLPRI | POLLRDBAND)) {
		/* If in packet or user control mode, check for data. */
		if (((pti->pt_flags & PF_PKT) && pti->pt_send) ||
		    ((pti->pt_flags & PF_UCNTL) && pti->pt_ucntl))
			revents |= events & (POLLPRI | POLLRDBAND);
	}

	if (revents == 0) {
notopen:
		if (events & (POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND))
			selrecord(p, &pti->pt_selr);
		if (events & (POLLOUT | POLLWRNORM))
			selrecord(p, &pti->pt_selw);
	}

	return (revents);
}

void
filt_ptcrdetach(struct knote *kn)
{
	struct pt_softc *pti = (struct pt_softc *)kn->kn_hook;
	int s;

	s = spltty();
	SLIST_REMOVE(&pti->pt_selr.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_ptcread(struct knote *kn, long hint)
{
	struct pt_softc *pti = (struct pt_softc *)kn->kn_hook;
	struct tty *tp;

	tp = pti->pt_tty;
	kn->kn_data = 0;

	if (ISSET(tp->t_state, TS_ISOPEN)) {
		if (!ISSET(tp->t_state, TS_TTSTOP))
			kn->kn_data = tp->t_outq.c_cc;
		if (((pti->pt_flags & PF_PKT) && pti->pt_send) ||
		    ((pti->pt_flags & PF_UCNTL) && pti->pt_ucntl))
			kn->kn_data++;
	}
	return (kn->kn_data > 0);
}

void
filt_ptcwdetach(struct knote *kn)
{
	struct pt_softc *pti = (struct pt_softc *)kn->kn_hook;
	int s;

	s = spltty();
	SLIST_REMOVE(&pti->pt_selw.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_ptcwrite(struct knote *kn, long hint)
{
	struct pt_softc *pti = (struct pt_softc *)kn->kn_hook;
	struct tty *tp;

	tp = pti->pt_tty;
	kn->kn_data = 0;

	if (ISSET(tp->t_state, TS_ISOPEN)) {
		if (ISSET(pti->pt_flags, PF_REMOTE)) {
			if (tp->t_canq.c_cc == 0)
				kn->kn_data = tp->t_canq.c_cn;
		} else if (tp->t_rawq.c_cc + tp->t_canq.c_cc < TTYHOG(tp)-2)
			kn->kn_data = tp->t_canq.c_cn -
			    (tp->t_rawq.c_cc + tp->t_canq.c_cc);
	}

	return (kn->kn_data > 0);
}

struct filterops ptcread_filtops =
	{ 1, NULL, filt_ptcrdetach, filt_ptcread };
struct filterops ptcwrite_filtops =
	{ 1, NULL, filt_ptcwdetach, filt_ptcwrite };

int
ptckqfilter(dev_t dev, struct knote *kn)
{
	struct pt_softc *pti = pt_softc[minor(dev)];
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &pti->pt_selr.si_note;
		kn->kn_fop = &ptcread_filtops;
		break;
	case EVFILT_WRITE:
		klist = &pti->pt_selw.si_note;
		kn->kn_fop = &ptcwrite_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)pti;

	s = spltty();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

struct tty *
ptytty(dev_t dev)
{
	struct pt_softc *pti = pt_softc[minor(dev)];
	struct tty *tp = pti->pt_tty;

	return (tp);
}

int
ptyioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct pt_softc *pti = pt_softc[minor(dev)];
	struct tty *tp = pti->pt_tty;
	u_char *cc = tp->t_cc;
	int stop, error;

	/*
	 * IF CONTROLLER STTY THEN MUST FLUSH TO PREVENT A HANG.
	 * ttywflush(tp) will hang if there are characters in the outq.
	 */
	if (cmd == TIOCEXT) {
		/*
		 * When the EXTPROC bit is being toggled, we need
		 * to send an TIOCPKT_IOCTL if the packet driver
		 * is turned on.
		 */
		if (*(int *)data) {
			if (pti->pt_flags & PF_PKT) {
				pti->pt_send |= TIOCPKT_IOCTL;
				ptcwakeup(tp, FREAD);
			}
			tp->t_lflag |= EXTPROC;
		} else {
			if ((tp->t_lflag & EXTPROC) &&
			    (pti->pt_flags & PF_PKT)) {
				pti->pt_send |= TIOCPKT_IOCTL;
				ptcwakeup(tp, FREAD);
			}
			tp->t_lflag &= ~EXTPROC;
		}
		return(0);
	} else if (cdevsw[major(dev)].d_open == ptcopen)
		switch (cmd) {

		case TIOCGPGRP:
			/*
			 * We avoid calling ttioctl on the controller since,
			 * in that case, tp must be the controlling terminal.
			 */
			*(int *)data = tp->t_pgrp ? tp->t_pgrp->pg_id : 0;
			return (0);

		case TIOCPKT:
			if (*(int *)data) {
				if (pti->pt_flags & PF_UCNTL)
					return (EINVAL);
				pti->pt_flags |= PF_PKT;
			} else
				pti->pt_flags &= ~PF_PKT;
			return (0);

		case TIOCUCNTL:
			if (*(int *)data) {
				if (pti->pt_flags & PF_PKT)
					return (EINVAL);
				pti->pt_flags |= PF_UCNTL;
			} else
				pti->pt_flags &= ~PF_UCNTL;
			return (0);

		case TIOCREMOTE:
			if (*(int *)data)
				pti->pt_flags |= PF_REMOTE;
			else
				pti->pt_flags &= ~PF_REMOTE;
			ttyflush(tp, FREAD|FWRITE);
			return (0);

		case TIOCSETD:
		case TIOCSETA:
		case TIOCSETAW:
		case TIOCSETAF:
			ndflush(&tp->t_outq, tp->t_outq.c_cc);
			break;

		case TIOCSIG:
			if (*(unsigned int *)data >= NSIG ||
			    *(unsigned int *)data == 0)
				return(EINVAL);
			if ((tp->t_lflag & NOFLSH) == 0)
				ttyflush(tp, FREAD|FWRITE);
			pgsignal(tp->t_pgrp, *(unsigned int *)data, 1);
			if ((*(unsigned int *)data == SIGINFO) &&
			    ((tp->t_lflag & NOKERNINFO) == 0))
				ttyinfo(tp);
			return (0);

		case FIONREAD:
			/*
			 * FIONREAD on the master side must return the amount
			 * in the output queue rather than the input.
			 */
			*(int *)data = tp->t_outq.c_cc;
			return (0);
		}
	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error < 0)
		 error = ttioctl(tp, cmd, data, flag, p);
	if (error < 0) {
		if (pti->pt_flags & PF_UCNTL &&
		    (cmd & ~0xff) == UIOCCMD(0)) {
			if (cmd & 0xff) {
				pti->pt_ucntl = (u_char)cmd;
				ptcwakeup(tp, FREAD);
			}
			return (0);
		}
		error = ENOTTY;
	}
	/*
	 * If external processing and packet mode send ioctl packet.
	 */
	if ((tp->t_lflag & EXTPROC) && (pti->pt_flags & PF_PKT)) {
		switch (cmd) {
		case TIOCSETA:
		case TIOCSETAW:
		case TIOCSETAF:
			pti->pt_send |= TIOCPKT_IOCTL;
			ptcwakeup(tp, FREAD);
		default:
			break;
		}
	}
	stop = (tp->t_iflag & IXON) && CCEQ(cc[VSTOP], CTRL('s')) &&
	    CCEQ(cc[VSTART], CTRL('q'));
	if (pti->pt_flags & PF_NOSTOP) {
		if (stop) {
			pti->pt_send &= ~TIOCPKT_NOSTOP;
			pti->pt_send |= TIOCPKT_DOSTOP;
			pti->pt_flags &= ~PF_NOSTOP;
			ptcwakeup(tp, FREAD);
		}
	} else {
		if (!stop) {
			pti->pt_send &= ~TIOCPKT_DOSTOP;
			pti->pt_send |= TIOCPKT_NOSTOP;
			pti->pt_flags |= PF_NOSTOP;
			ptcwakeup(tp, FREAD);
		}
	}
	return (error);
}

/*
 * Return pty-related information.
 */
int
sysctl_pty(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

/*
 * Check if a pty is free to use.
 */
static int
pty_isfree_locked(int minor)
{
	struct pt_softc *pt = pt_softc[minor];

	return (pt == NULL || pt->pt_tty == NULL ||
	    pt->pt_tty->t_oproc == NULL);
}

static int
pty_isfree(int minor)
{
	int isfree;

	rw_enter_read(&pt_softc_lock);
	isfree = pty_isfree_locked(minor);
	rw_exit_read(&pt_softc_lock);
	return(isfree);
}

dev_t
pty_getfree(void)
{
	int i;

	rw_enter_read(&pt_softc_lock);
	for (i = 0; i < npty; i++) {
		if (pty_isfree_locked(i))
			break;
	}
	rw_exit_read(&pt_softc_lock);
	return (makedev(pts_major, i));
}

/*
 * Hacked up version of vn_open. We _only_ handle ptys and only open
 * them with FREAD|FWRITE and never deal with creat or stuff like that.
 *
 * We need it because we have to fake up root credentials to open the pty.
 */
static int
ptm_vn_open(struct nameidata *ndp)
{
	struct proc *p = ndp->ni_cnd.cn_proc;
	struct ucred *cred;
	struct vattr vattr;
	struct vnode *vp;
	int error;

	if ((error = namei(ndp)) != 0)
		return (error);
	vp = ndp->ni_vp;
	if (vp->v_type != VCHR) {
		error = EINVAL;
		goto bad;
	}

	/*
	 * Get us a fresh cred with root privileges.
	 */
	cred = crget();
	error = VOP_OPEN(vp, FREAD|FWRITE, cred, p);
	if (!error) {
		/* update atime/mtime */
		VATTR_NULL(&vattr);
		getnanotime(&vattr.va_atime);
		vattr.va_mtime = vattr.va_atime;
		vattr.va_vaflags |= VA_UTIMES_NULL;
		(void)VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
	crfree(cred);

	if (error)
		goto bad;

	vp->v_writecount++;

	return (0);
bad:
	vput(vp);
	return (error);
}

void
ptmattach(int n)
{
	/* find the major and minor of the pty devices */
	int i;

	for (i = 0; i < nchrdev; i++)
		if (cdevsw[i].d_open == ptsopen)
			break;

	if (i == nchrdev)
		panic("ptmattach: Can't find pty slave in cdevsw");

	pts_major = i;
}

int
ptmopen(dev_t dev, int flag, int mode, struct proc *p)
{
	return(0);
}


int
ptmclose(dev_t dev, int flag, int mode, struct proc *p)
{
	return (0);
}

int
ptmioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	dev_t newdev, error;
	struct pt_softc * pti;
	struct nameidata cnd, snd;
	struct filedesc *fdp = p->p_fd;
	struct file *cfp = NULL, *sfp = NULL;
	int cindx, sindx;
	uid_t uid;
	gid_t gid;
	struct vattr vattr;
	struct ucred *cred;
	struct ptmget *ptm = (struct ptmget *)data;

	switch (cmd) {
	case PTMGET:
		fdplock(fdp);
		/* Grab two filedescriptors. */
		if ((error = falloc(p, 0, &cfp, &cindx)) != 0) {
			fdpunlock(fdp);
			break;
		}
		if ((error = falloc(p, 0, &sfp, &sindx)) != 0) {
			fdremove(fdp, cindx);
			closef(cfp, p);
			fdpunlock(fdp);
			break;
		}

retry:
		/* Find and open a free master pty. */
		newdev = pty_getfree();
		if ((error = check_pty(minor(newdev))))
			goto bad;
		pti = pt_softc[minor(newdev)];
		NDINIT(&cnd, LOOKUP, NOFOLLOW|LOCKLEAF, UIO_SYSSPACE,
		    pti->pty_pn, p);
		cnd.ni_pledge = PLEDGE_RPATH | PLEDGE_WPATH;
		if ((error = ptm_vn_open(&cnd)) != 0) {
			/*
			 * Check if the master open failed because we lost
			 * the race to grab it.
			 */
			if (error == EIO && !pty_isfree(minor(newdev)))
				goto retry;
			goto bad;
		}
		cfp->f_flag = FREAD|FWRITE;
		cfp->f_type = DTYPE_VNODE;
		cfp->f_ops = &vnops;
		cfp->f_data = (caddr_t) cnd.ni_vp;
		VOP_UNLOCK(cnd.ni_vp, p);

		/*
		 * Open the slave.
		 * namei -> setattr -> unlock -> revoke -> vrele ->
		 * namei -> open -> unlock
		 * Three stage rocket:
		 * 1. Change the owner and permissions on the slave.
		 * 2. Revoke all the users of the slave.
		 * 3. open the slave.
		 */
		NDINIT(&snd, LOOKUP, NOFOLLOW|LOCKLEAF, UIO_SYSSPACE,
		    pti->pty_sn, p);
		snd.ni_pledge = PLEDGE_RPATH | PLEDGE_WPATH;
		if ((error = namei(&snd)) != 0)
			goto bad;
		if ((snd.ni_vp->v_mount->mnt_flag & MNT_RDONLY) == 0) {
			gid = tty_gid;
			/* get real uid */
			uid = p->p_ucred->cr_ruid;

			VATTR_NULL(&vattr);
			vattr.va_uid = uid;
			vattr.va_gid = gid;
			vattr.va_mode = (S_IRUSR|S_IWUSR|S_IWGRP) & ALLPERMS;
			/* Get a fake cred to pretend we're root. */
			cred = crget();
			error = VOP_SETATTR(snd.ni_vp, &vattr, cred, p);
			crfree(cred);
			if (error) {
				vput(snd.ni_vp);
				goto bad;
			}
		}
		VOP_UNLOCK(snd.ni_vp, p);
		if (snd.ni_vp->v_usecount > 1 ||
		    (snd.ni_vp->v_flag & (VALIASED)))
			VOP_REVOKE(snd.ni_vp, REVOKEALL);

		/*
		 * The vnode is useless after the revoke, we need to
		 * namei again.
		 */
		vrele(snd.ni_vp);

		NDINIT(&snd, LOOKUP, NOFOLLOW|LOCKLEAF, UIO_SYSSPACE,
		    pti->pty_sn, p);
		snd.ni_pledge = PLEDGE_RPATH | PLEDGE_WPATH;
		/* now open it */
		if ((error = ptm_vn_open(&snd)) != 0)
			goto bad;
		sfp->f_flag = FREAD|FWRITE;
		sfp->f_type = DTYPE_VNODE;
		sfp->f_ops = &vnops;
		sfp->f_data = (caddr_t) snd.ni_vp;
		VOP_UNLOCK(snd.ni_vp, p);

		/* now, put the indexen and names into struct ptmget */
		ptm->cfd = cindx;
		ptm->sfd = sindx;
		memcpy(ptm->cn, pti->pty_pn, sizeof(pti->pty_pn));
		memcpy(ptm->sn, pti->pty_sn, sizeof(pti->pty_sn));

		/* mark the files mature now that we've passed all errors */
		FILE_SET_MATURE(cfp, p);
		FILE_SET_MATURE(sfp, p);

		fdpunlock(fdp);
		break;
	default:
		error = EINVAL;
		break;
	}
	return (error);
bad:
	fdremove(fdp, cindx);
	closef(cfp, p);
	fdremove(fdp, sindx);
	closef(sfp, p);
	fdpunlock(fdp);
	return (error);
}
@


1.79
log
@Add a flags argument to falloc() that lets it optionally set the
close-on-exec flag on the newly allocated fd.  Make falloc()'s
return arguments non-optional: assert that they're not NULL.

ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.78 2016/05/24 16:09:07 deraadt Exp $	*/
d250 1
a250 1
	} else if (tp->t_state&TS_XCLUDE && suser(p, 0) != 0)
d256 1
a256 1
		if (flag&FNONBLOCK)
d456 2
a457 2
		if (tp->t_state&TS_ISOPEN) {
			if (pti->pt_flags&PF_PKT && pti->pt_send) {
d471 1
a471 1
			if (pti->pt_flags&PF_UCNTL && pti->pt_ucntl) {
d478 1
a478 1
			if (tp->t_outq.c_cc && (tp->t_state&TS_TTSTOP) == 0)
d481 1
a481 1
		if ((tp->t_state&TS_CARR_ON) == 0)
d520 1
a520 1
	if ((tp->t_state&TS_ISOPEN) == 0)
d536 1
a536 1
				if ((tp->t_state&TS_ISOPEN) == 0) {
d560 1
a560 1
			if ((tp->t_state&TS_ISOPEN) == 0) {
d584 1
a584 1
	if ((tp->t_state&TS_CARR_ON) == 0) {
d843 1
a843 1
			if ((tp->t_lflag&NOFLSH) == 0)
d847 1
a847 1
			    ((tp->t_lflag&NOKERNINFO) == 0))
d876 1
a876 1
	if ((tp->t_lflag&EXTPROC) && (pti->pt_flags & PF_PKT)) {
@


1.78
log
@Remove two sysctls which were introduced only for development of the
ptm/pty subsystem, and got left behind.
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.77 2016/03/19 12:04:15 natano Exp $	*/
d1058 1
a1058 1
		if ((error = falloc(p, &cfp, &cindx)) != 0) {
d1062 1
a1062 1
		if ((error = falloc(p, &sfp, &sindx)) != 0) {
@


1.77
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.76 2016/01/28 18:02:36 stefan Exp $	*/
a913 2
	int error, oldmax;

a917 22
	case KERN_TTY_MAXPTYS:
		if (!newp)
			return (sysctl_rdint(oldp, oldlenp, newp, maxptys));
		rw_enter_write(&pt_softc_lock);
		oldmax = maxptys;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &maxptys);
		/*
		 * We can't set the max lower than the current active
		 * value or to a value bigger than NPTY_MAX.
		 */
		if (error == 0 && (maxptys > NPTY_MAX || maxptys < npty)) {
			maxptys = oldmax;
			error = ERANGE;
		}
		rw_exit_write(&pt_softc_lock);
		return (error);
	case KERN_TTY_NPTYS:
		return (sysctl_rdint(oldp, oldlenp, newp, npty));
#ifdef notyet
	case KERN_TTY_GID:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &tty_gid));
#endif
@


1.76
log
@Convert to uiomove. Diff from Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.75 2016/01/14 09:44:08 sf Exp $	*/
d1115 1
a1115 1
		VOP_UNLOCK(cnd.ni_vp, 0, p);
d1149 1
a1149 1
		VOP_UNLOCK(snd.ni_vp, 0, p);
d1170 1
a1170 1
		VOP_UNLOCK(snd.ni_vp, 0, p);
@


1.75
log
@Increase buffer sizes and watermarks for tty and ppp

Use 115200 the default speed for buffer sizing in ttymalloc(). A lot
of devices call ttymalloc(0) so this affects quite a few of them.

Increases the buffer size for 9600 < baud <= 115200 from 1k to 4k.

Make ppp use the lo/hi watermarks from the tty layer which are
adjusted according to speed + buffer size. The previous fixed values
of 100 and 400 were way too small

Make pty call ttymalloc() with baud == 1000000, which is the common
value used in the tree for "fast".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.74 2015/12/05 10:11:53 tedu Exp $	*/
d464 1
a464 1
					error = uiomovei(&tp->t_termios, cc, uio);
d499 1
a499 1
		error = uiomovei(buf, cc, uio);
d532 1
a532 1
				error = uiomovei(cp, cc, uio);
d556 1
a556 1
			error = uiomovei(cp, cc, uio);
@


1.74
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.73 2015/11/02 16:31:55 semarie Exp $	*/
d196 1
a196 1
		pti->pt_tty = ttymalloc(0);
d238 1
a238 1
		tp = pti->pt_tty = ttymalloc(0);
d248 1
a248 1
		tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
d415 1
a415 1
		tp = pti->pt_tty = ttymalloc(0);
@


1.73
log
@move the pledgenote annotation from `struct proc' to `struct nameidata'

pledgenote is used for annotate the policy for a namei context. So make it
tracking the nameidata.

It is expected for the caller to explicitly define the policy. It is a kernel
bug to not do so.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.72 2015/10/28 11:22:08 deraadt Exp $	*/
a225 1
/*ARGSUSED*/
a402 1
/*ARGSUSED*/
a428 1
/*ARGSUSED*/
a761 1
/*ARGSUSED*/
@


1.72
log
@There are three situations where pty ioctl's result in a NDINIT.
NDINIT should be preceded by setting pledgenote to indicate what
the operation is for.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.71 2015/09/28 19:16:04 deraadt Exp $	*/
a1102 1
		p->p_pledgenote = PLEDGE_RPATH | PLEDGE_WPATH;
d1105 1
a1129 1
		p->p_pledgenote = PLEDGE_RPATH | PLEDGE_WPATH;
d1132 1
a1163 1
		p->p_pledgenote = PLEDGE_RPATH | PLEDGE_WPATH;
d1166 1
@


1.71
log
@easy size for free(); ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.70 2015/02/10 21:56:10 miod Exp $	*/
d58 1
d1103 1
d1130 1
d1164 1
@


1.70
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.69 2014/11/18 23:55:01 krw Exp $	*/
d184 1
a184 1
		free(pt_softc, M_DEVBUF, 0);
@


1.69
log
@Nuke yet more obvious #include duplications.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.68 2014/07/13 15:29:04 tedu Exp $	*/
d466 1
a466 1
					error = uiomove(&tp->t_termios, cc, uio);
d501 1
a501 1
		error = uiomove(buf, cc, uio);
d534 1
a534 1
				error = uiomove(cp, cc, uio);
d558 1
a558 1
			error = uiomove(cp, cc, uio);
@


1.68
log
@use mallocarray where arguments are multipled. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.67 2014/07/12 18:43:32 tedu Exp $	*/
a53 1
#include <sys/uio.h>
@


1.67
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.66 2014/07/09 15:46:22 tedu Exp $	*/
d153 1
a153 1
	pt = malloc(nelem * sizeof(struct pt_softc *), M_DEVBUF,
@


1.66
log
@use explicit_bzero for stack and freed variables
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.65 2014/03/30 21:54:48 guenther Exp $	*/
d185 1
a185 1
		free(pt_softc, M_DEVBUF);
@


1.65
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.64 2014/03/22 06:05:45 guenther Exp $	*/
d506 1
a506 1
		bzero(buf, bufcc);
d607 1
a607 1
		bzero(buf, bufcc);
@


1.64
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.63 2013/12/13 19:55:12 naddy Exp $	*/
d1136 1
a1136 1
			uid = p->p_cred->p_ruid;
@


1.63
log
@Remove the 4.3BSD tty(4) compatibility shims.  RIP.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.62 2013/10/11 12:44:13 millert Exp $	*/
d294 1
a294 1
			if ((p->p_sigacts->ps_sigignore & sigmask(SIGTTIN)) ||
@


1.62
log
@poll(2) on a closed tty should return POLLIN|POLLHUP in revents
when events is set to POLLIN and POLLHUP when events is set to
POLLOUT.  In the pty case we need to be careful to only treat the
pty as closed if carrier is on.  This fixes a hang on close problem
seen with ssh and xterm.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.60 2013/10/04 17:52:55 millert Exp $	*/
a835 4
#ifdef COMPAT_OLDTTY
		case TIOCSETP:
		case TIOCSETN:
#endif
a884 9
#ifdef COMPAT_OLDTTY
		case TIOCSETP:
		case TIOCSETN:
		case TIOCSETC:
		case TIOCSLTC:
		case TIOCLBIS:
		case TIOCLBIC:
		case TIOCLSET:
#endif
@


1.61
log
@Back out POLLHUP change until a problem with xterm hanging on close
is fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.59 2013/01/02 16:14:56 millert Exp $	*/
d618 1
a618 4
	if (!ISSET(tp->t_state, TS_CARR_ON))
		return (POLLHUP);

	if (!ISSET(tp->t_state, TS_ISOPEN))
d632 4
a635 1
	if (events & (POLLOUT | POLLWRNORM)) {
@


1.60
log
@poll(2) on a closed tty should return POLLIN|POLLHUP in revents
when events is set to POLLIN and POLLHUP when events is set to
POLLOUT.  OK deraadt@@
@
text
@d618 3
d635 1
a635 4
	/* NOTE: POLLHUP and POLLOUT/POLLWRNORM are mutually exclusive */
	if (!ISSET(tp->t_state, TS_CARR_ON)) {
		revents |= POLLHUP;
	} else if (events & (POLLOUT | POLLWRNORM)) {
@


1.59
log
@Fix a bug in ptcwrite() that could result in up to 100 lost bytes
when we block due to hitting the TTYHOG limit.  OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.58 2012/04/22 05:43:14 guenther Exp $	*/
a617 3
	if (!ISSET(tp->t_state, TS_CARR_ON))
		return (POLLHUP);

d632 4
a635 1
	if (events & (POLLOUT | POLLWRNORM)) {
@


1.58
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.57 2011/07/05 04:48:02 guenther Exp $	*/
d553 1
a553 1
	while (uio->uio_resid > 0) {
d580 1
a580 1
	}
@


1.57
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.56 2011/07/02 22:20:08 nicm Exp $	*/
d1193 2
a1194 2
		FILE_SET_MATURE(cfp);
		FILE_SET_MATURE(sfp);
@


1.56
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.55 2011/04/18 21:44:56 guenther Exp $	*/
d294 1
a294 1
			if ((p->p_sigignore & sigmask(SIGTTIN)) ||
@


1.55
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.53 2011/04/03 14:56:28 guenther Exp $	*/
d744 1
a744 1
		return (1);
@


1.54
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d294 1
a294 1
			if ((p->p_sigacts->ps_sigignore & sigmask(SIGTTIN)) ||
@


1.53
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.52 2010/09/24 02:59:39 deraadt Exp $	*/
d294 1
a294 1
			if ((p->p_sigignore & sigmask(SIGTTIN)) ||
@


1.52
log
@dead store; found by clang
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.51 2010/08/06 00:00:41 miod Exp $	*/
d297 1
a297 1
			    p->p_flag & P_PPWAIT)
@


1.51
log
@Every time you ignore uiomove() return value, $DEITY kills a little
$ADORABLE_FELINE.

ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.50 2010/07/26 01:56:27 guenther Exp $	*/
a1094 1
	error = 0;
@


1.50
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.49 2010/07/21 18:48:01 nicm Exp $	*/
d467 3
a469 1
					uiomove(&tp->t_termios, cc, uio);
@


1.49
log
@ptm needs no read/write, just use enodev.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.48 2010/07/02 19:57:15 tedu Exp $	*/
d286 1
d293 1
a293 1
		while (isbackground(p, tp)) {
d296 1
a296 1
			    p->p_pgrp->pg_jobc == 0 ||
d299 1
a299 1
			pgsignal(p->p_pgrp, SIGTTIN, 1);
@


1.48
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.47 2010/07/02 17:27:01 nicm Exp $	*/
a120 3
int	ptmread(dev_t, struct uio *, int);
int	ptmwrite(dev_t, struct uio *, int);
int	ptmwrite(dev_t, struct uio *, int);
a121 1
int	ptmpoll(dev_t, int, struct proc *p);
a1077 12
ptmread(dev_t dev, struct uio *uio, int ioflag)
{
	return (EIO);
}

int
ptmwrite(dev_t dev, struct uio *uio, int ioflag)
{
	return (EIO);
}

int
a1207 6
}

int
ptmpoll(dev_t dev, int events, struct proc *p)
{
	return (seltrue(dev, events, p));
@


1.47
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.46 2010/06/28 14:13:36 deraadt Exp $	*/
a803 15
#ifdef COMPAT_SUNOS
		    {
			/*
			 * I'm not sure about SunOS TIOCGPGRP semantics
			 * on PTYs, but it's something like this:
			 */
			extern struct emul emul_sunos;
			if (p->p_emul == &emul_sunos) {
				if (tp->t_pgrp == 0)
					return (EIO);
				*(int *)data = tp->t_pgrp->pg_id;
				return (0);
			}
		    }
#endif
@


1.46
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.45 2010/04/12 12:57:52 tedu Exp $	*/
d505 1
a505 7
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (tp->t_state&TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup(&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
@


1.45
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.44 2010/04/02 20:20:23 nicm Exp $	*/
d200 1
a200 1
		pti->pt_tty = ttymalloc();
d243 1
a243 1
		tp = pti->pt_tty = ttymalloc();
d420 1
a420 1
		tp = pti->pt_tty = ttymalloc();
d535 1
a535 1
		while (uio->uio_resid > 0 && tp->t_canq.c_cc < TTYHOG - 1) {
d538 1
a538 1
				cc = min(cc, TTYHOG - 1 - tp->t_canq.c_cc);
d577 1
a577 1
			if ((tp->t_rawq.c_cc + tp->t_canq.c_cc) >= TTYHOG - 2 &&
d645 1
a645 1
		    ((tp->t_rawq.c_cc + tp->t_canq.c_cc < TTYHOG - 2) ||
d721 1
a721 1
		} else if (tp->t_rawq.c_cc + tp->t_canq.c_cc < TTYHOG-2)
@


1.44
log
@Add a case so that FIONREAD on the master side of a pty returns the size
of the output queue (that is, the data coming from the program on the
slave side) rather than falling through to ttioctl which returns the
size of the input queue (the amount written to the master).

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.43 2009/11/09 17:53:39 nicm Exp $	*/
d268 1
a268 1
	error = (*linesw[tp->t_line].l_open)(dev, tp);
d280 1
a280 1
	error = (*linesw[tp->t_line].l_close)(tp, flag);
@


1.43
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.42 2009/10/31 12:00:08 fgsch Exp $	*/
d879 9
a887 1
			return(0);
@


1.42
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.41 2009/10/30 16:41:10 nicm Exp $	*/
a397 1
		KNOTE(&pti->pt_selr.si_note, 0);
a401 1
		KNOTE(&pti->pt_selw.si_note, 0);
a510 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.41
log
@Add missing KNOTE() calls after selwakeup() in ptcread() (to wake up writers
after the master side of the pty has finished reading) and in ttyflush().

ok tedu millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.40 2009/10/14 07:19:05 nicm Exp $	*/
d255 1
a255 1
	} else if (tp->t_state&TS_XCLUDE && p->p_ucred->cr_uid != 0)
@


1.40
log
@Remove a redundant if (maxpty == npty) in check_pty - this is also tested by
the two ifs at the start of the function and both variables are only altered
under pt_softc_lock so cannot change between the checks.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.39 2009/09/29 17:26:09 deraadt Exp $	*/
d513 1
@


1.39
log
@Having pty_isfree_locked() be inlined may make pty allocation a tiny
bit faster, but come on, inlining is supposed to be reserved only
for things which *critically* need it.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.38 2008/08/02 11:39:38 stefan Exp $	*/
a186 4

		if (maxptys == npty) {
			goto limit_reached;
		}
@


1.38
log
@Fix integer truncation in pcread() and ptcwrite(). ok miod, otto, deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.37 2008/05/07 09:35:52 deraadt Exp $	*/
d988 1
a988 1
static __inline int
d992 1
@


1.37
log
@check TIOCSIG for 0 and do not send that to psignal() and pgsignal()
ok fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.36 2008/04/10 19:55:41 deraadt Exp $	*/
d474 1
a474 1
					cc = min(uio->uio_resid,
d503 1
a503 1
		cc = min(uio->uio_resid, BUFSIZ);
d532 1
a532 1
	int cnt = 0;
d543 1
a543 1
				cc = min(uio->uio_resid, BUFSIZ);
d568 1
a568 1
			cc = min(uio->uio_resid, BUFSIZ);
@


1.36
log
@scrub local stack-based buffers in the tty subsystem.  tested by a lot of
developers.  if you notice tty weirdnesses in the next few months, talk to
me
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.35 2007/09/07 15:00:20 art Exp $	*/
d812 1
a812 2
	} else
	if (cdevsw[major(dev)].d_open == ptcopen)
d876 2
a877 1
			if (*(unsigned int *)data >= NSIG)
@


1.35
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.34 2007/05/29 00:17:32 thib Exp $	*/
d459 1
a459 1
	int error = 0, cc;
d503 4
a506 1
		cc = q_to_b(&tp->t_outq, buf, min(uio->uio_resid, BUFSIZ));
d518 2
d530 2
a531 2
	int cc = 0;
	u_char locbuf[BUFSIZ];
d545 3
a547 1
				cp = locbuf;
d550 1
a550 1
					return (error);
d552 4
a555 2
				if ((tp->t_state&TS_ISOPEN) == 0)
					return (EIO);
d564 1
a564 1
		return (0);
d569 3
a571 1
			cp = locbuf;
d574 1
a574 1
				return (error);
d576 4
a579 2
			if ((tp->t_state&TS_ISOPEN) == 0)
				return (EIO);
d581 1
d594 1
a594 1
	return (0);
d600 4
a603 2
	if ((tp->t_state&TS_CARR_ON) == 0)
		return (EIO);
d608 2
a609 2
			return (EWOULDBLOCK);
		return (0);
d613 9
a621 6
	if (error) {
		/* adjust for data copied in but not written */
		uio->uio_resid += cc;
		return (error);
	}
	goto again;
@


1.34
log
@Add a name argument to the RWLOCK_INITIALIZER macro.
Pick reasonble names for the locks involved..

ok tedu@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.33 2006/03/04 19:33:21 miod Exp $	*/
d157 2
a158 2
	pt = malloc(nelem * sizeof(struct pt_softc *), M_DEVBUF, M_WAITOK);
	bzero(pt, nelem * sizeof(struct pt_softc *));
d202 2
a203 3
		MALLOC(pti, struct pt_softc *, sizeof(struct pt_softc),
		    M_DEVBUF, M_WAITOK);
		bzero(pti, sizeof(struct pt_softc));
@


1.33
log
@Typos grab bag of the month, eyeballed by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.32 2006/01/18 23:42:12 miod Exp $	*/
d90 2
a91 1
struct rwlock pt_softc_lock = RWLOCK_INITIALIZER;  /* for pty array */
@


1.32
log
@Fix logic botch when checking for COMPAT_SUNOS binary specifics; repairs
some TIOCGPGRP result fallout.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.31 2005/12/21 12:43:49 jsg Exp $	*/
d814 1
a814 1
			 * We aviod calling ttioctl on the controller since,
@


1.31
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.30 2005/11/21 01:16:02 millert Exp $	*/
d799 1
a799 1
			{
d805 5
a809 4
			if (p->p_emul == &emul_sunos && tp->t_pgrp == 0)
				return (EIO);
			*(int *)data = tp->t_pgrp->pg_id;
			return (0);
d811 1
@


1.30
log
@Fix a crash in ptmioctl() in the error path when the master has
been opened but the slave cannot be.  We can't do the FILE_SET_MATURE
until we are past all possible error paths since it calls FRELE(),
resulting in a reference count of 0, which closef() panics on #ifdef
DIAGNOSTIC.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.29 2005/05/26 00:33:45 pedro Exp $	*/
d236 1
a236 4
ptsopen(dev, flag, devtype, p)
	dev_t dev;
	int flag, devtype;
	struct proc *p;
d239 1
a239 1
	register struct tty *tp;
d278 1
a278 4
ptsclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d280 2
a281 2
	register struct pt_softc *pti = pt_softc[minor(dev)];
	register struct tty *tp = pti->pt_tty;
d291 1
a291 4
ptsread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d294 2
a295 2
	register struct pt_softc *pti = pt_softc[minor(dev)];
	register struct tty *tp = pti->pt_tty;
d343 1
a343 4
ptswrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d345 2
a346 2
	register struct pt_softc *pti = pt_softc[minor(dev)];
	register struct tty *tp = pti->pt_tty;
d358 1
a358 2
ptsstart(tp)
	struct tty *tp;
d360 1
a360 1
	register struct pt_softc *pti = pt_softc[minor(tp->t_dev)];
d372 1
a372 3
ptsstop(tp, flush)
	register struct tty *tp;
	int flush;
d395 1
a395 3
ptcwakeup(tp, flag)
	struct tty *tp;
	int flag;
d415 1
a415 4
ptcopen(dev, flag, devtype, p)
	dev_t dev;
	int flag, devtype;
	struct proc *p;
d418 1
a418 1
	register struct tty *tp;
d442 1
a442 4
ptcclose(dev, flag, devtype, p)
	dev_t dev;
	int flag, devtype;
	struct proc *p;
d444 2
a445 2
	register struct pt_softc *pti = pt_softc[minor(dev)];
	register struct tty *tp = pti->pt_tty;
d454 1
a454 4
ptcread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d456 2
a457 2
	register struct pt_softc *pti = pt_softc[minor(dev)];
	register struct tty *tp = pti->pt_tty;
d520 1
a520 4
ptcwrite(dev, uio, flag)
	dev_t dev;
	register struct uio *uio;
	int flag;
d522 4
a525 4
	register struct pt_softc *pti = pt_softc[minor(dev)];
	register struct tty *tp = pti->pt_tty;
	register u_char *cp = NULL;
	register int cc = 0;
d751 1
a751 2
ptytty(dev)
	dev_t dev;
d753 2
a754 2
	register struct pt_softc *pti = pt_softc[minor(dev)];
	register struct tty *tp = pti->pt_tty;
d761 1
a761 6
ptyioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d763 3
a765 3
	register struct pt_softc *pti = pt_softc[minor(dev)];
	register struct tty *tp = pti->pt_tty;
	register u_char *cc = tp->t_cc;
@


1.29
log
@RIP stackable filesystems, ok marius@@ tedu@@, discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.28 2005/01/28 15:43:24 millert Exp $	*/
a1177 1
		FILE_SET_MATURE(cfp);
a1230 1
		FILE_SET_MATURE(sfp);
d1237 4
@


1.28
log
@When setting kern.tty.maxptys, store the old value in oldp, not
random stack garbage.  Rename DEFAULT_NPTYS and DEFAULT_MAXPTYS to
NPTY_MIN and NPTY_MAX to better match their function and don't allow
setting kern.tty.maxptys > NPTY_MAX.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.27 2004/12/19 01:44:07 millert Exp $	*/
d1213 1
a1213 1
		    (snd.ni_vp->v_flag & (VALIASED | VLAYER)))
@


1.27
log
@Set atime and mtime when giving out a new pty.  With help from tholo@@
and OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.26 2004/12/07 03:42:45 pat Exp $	*/
d84 2
a85 2
#define	DEFAULT_NPTYS		8	/* default number of initial ptys */
#define DEFAULT_MAXPTYS		992	/* default maximum number of ptys */
d89 1
a89 1
static int maxptys = DEFAULT_MAXPTYS;		/* maximum number of ptys */
d224 1
a224 1
		n = DEFAULT_NPTYS;
d965 1
a965 2
	int err;
	int newmax;
a973 3
		err = sysctl_int(oldp, oldlenp, newp, newlen, &newmax);
		if (err)
			return (err);
d975 2
d978 2
a979 2
		 * We can't set the max lower than the current
		 * active value or to a value bigger than a dev_t minor
d981 4
a984 4
		if (newmax <= USHRT_MAX && newmax > npty)
			maxptys = newmax;
		else
			err = EINVAL;
d986 1
a986 1
		return(err);
@


1.26
log
@* add a missing vput() if VOP_SETATTR() fails.

ok tedu pedro millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.25 2004/07/22 06:13:08 tedu Exp $	*/
a1045 1
	struct vnode *vp;
d1048 2
d1065 8
@


1.25
log
@remove p arg from fdplock
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.24 2004/07/21 12:10:20 art Exp $	*/
d1199 2
a1200 1
			if (error)
d1202 1
@


1.24
log
@I was wrong. The assymetry created by the proc argument to rw_enter_write
is horrible and doesn't add anything.

Remove it.
XXX - the fdplock macro will need a separate cleanup.

niklas@@ markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.23 2004/07/09 08:55:41 niklas Exp $	*/
d1136 1
a1136 1
		fdplock(fdp, p);
@


1.23
log
@go away statics
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.22 2004/04/11 18:04:36 millert Exp $	*/
d170 1
a170 1
	rw_enter_write(&pt_softc_lock, curproc);
d978 1
a978 1
		rw_enter_write(&pt_softc_lock, curproc);
@


1.22
log
@Crank max ptys to 992.  We now have 62 pty/tty pairs for each letter
instead of 16.  E.g. it is now /dev/{p,t}typ[0-9a-zA-z] instead of just
/dev/{p,t}typ[0-9a-f].  This requires that you update MAKEDEV and run:
# cd /dev && ./MAKEDEV pty0 && rm -f [pt]ty[rq]*
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.21 2004/04/11 16:41:30 millert Exp $	*/
d151 1
a151 1
static struct pt_softc **
d165 1
a165 1
static int
@


1.21
log
@Fix calculation of the index into TTY_LETTERS.  This only worked
because sizeof(TTY_LETTERS) == sizeof(TTY_SUFFIX).
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.20 2004/02/23 21:17:54 beck Exp $	*/
d64 2
a65 2
 * pts == /dev/tty[p-zP-T][0-9a-f]
 * ptc == /dev/pty[p-zP-T][0-9a-f]
d70 1
a70 1
#define TTY_SUFFIX "0123456789abcdef"
d85 1
a85 1
#define DEFAULT_MAXPTYS		256	/* default maximum number of ptys */
@


1.20
log
@Make sure we allow for the time when check_pty has not yet been called
before we get invoked, by making sure getfree thinks an unused and
unallocated pt_softc entry is actually free rather than following NULL.
ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.19 2004/02/10 21:06:50 millert Exp $	*/
d133 1
a133 1
	i = minor / (sizeof(TTY_LETTERS) - 1);
@


1.19
log
@Fix off-by-one wrt TTY_LETTERS and minor being out of bounds.  Missed
when I fixed the other TTY_LETTERS/TTY_SUFFIX off-by-ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.18 2004/02/10 01:31:21 millert Exp $	*/
d1008 2
a1009 1
	return (pt->pt_tty == NULL || pt->pt_tty->t_oproc == NULL);
@


1.18
log
@Add the ptm device to pty(4).  By opening /dev/ptm and using the PTMGET
ioctl(2), an unprivileged process may allocate a pty and have its owner
and mode set appropriately.  This means that programs such as xterm and
screen no longer need to be setuid.  Programs using the openpty()
function require zero changes and will "just work".

Designed by beck@@ and deraadt@@; changes by beck@@ with cleanup (and
a rewrite of the vnode bits) by art@@ and tweaks/bugfixes by me.
Tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.17 2004/02/10 01:19:47 millert Exp $	*/
d135 1
a135 1
	if (i >= sizeof(TTY_LETTERS)) {
@


1.17
log
@Dynamically allocate space for ptys; adapted from NetBSD by beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.16 2003/10/03 16:44:51 miod Exp $	*/
d42 2
d48 1
d56 1
d64 2
a65 2
 * pts == /dev/tty[pqrs]?
 * ptc == /dev/pty[pqrs]?
d67 7
d80 2
d85 1
a85 1
#define	DEFAULT_MAXPTYS		256	/* default maximum number of ptys */
d112 36
d205 1
d227 5
d316 2
a317 2
			error = ttysleep(tp, &lbolt, 
					 TTIPRI | PCATCH, ttybg, 0);
d325 1
a325 1
					 TTIPRI | PCATCH, ttyin, 0);
d522 1
a522 1
			       ttyin, 0);
d625 1
a625 1
		       ttyout, 0);
d653 2
a654 2
		     ((pti->pt_flags & PF_PKT) && pti->pt_send) ||
		     ((pti->pt_flags & PF_UCNTL) && pti->pt_ucntl))
d660 3
a662 3
		     (tp->t_canq.c_cc == 0) :
		     ((tp->t_rawq.c_cc + tp->t_canq.c_cc < TTYHOG - 2) ||
		      (tp->t_canq.c_cc == 0 && ISSET(tp->t_lflag, ICANON))))
d668 1
a668 1
		     ((pti->pt_flags & PF_UCNTL) && pti->pt_ucntl))
d880 1
a880 1
		case TIOCSETP:		
d919 1
a919 1
		switch(cmd) {
d938 2
a939 2
	stop = (tp->t_iflag & IXON) && CCEQ(cc[VSTOP], CTRL('s')) 
		&& CCEQ(cc[VSTART], CTRL('q'));
d991 4
d999 251
@


1.16
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.15 2003/09/23 16:51:12 millert Exp $	*/
d53 1
d55 1
d69 9
a77 2
} *pt_softc;
int	npty;
d89 1
d96 70
d170 1
a170 2
ptyattach(n)
	int n;
a171 2
#define	DEFAULT_NPTY	32

d174 2
a175 3
		n = DEFAULT_NPTY;
	pt_softc = malloc(n * sizeof(struct pt_softc), M_DEVBUF, M_WAITOK);
	bzero(pt_softc, n * sizeof(struct pt_softc));
d190 4
a193 3
	if (minor(dev) >= npty)
		return (ENXIO);
	pti = &pt_softc[minor(dev)];
d231 1
a231 1
	register struct pt_softc *pti = &pt_softc[minor(dev)];
d248 1
a248 1
	register struct pt_softc *pti = &pt_softc[minor(dev)];
d302 1
a302 1
	register struct pt_softc *pti = &pt_softc[minor(dev)];
d318 1
a318 1
	register struct pt_softc *pti = &pt_softc[minor(tp->t_dev)];
d334 1
a334 1
	struct pt_softc *pti = &pt_softc[minor(tp->t_dev)];
d359 1
a359 1
	struct pt_softc *pti = &pt_softc[minor(tp->t_dev)];
d384 4
d389 1
a389 3
	if (minor(dev) >= npty)
		return (ENXIO);
	pti = &pt_softc[minor(dev)];
d412 1
a412 1
	register struct pt_softc *pti = &pt_softc[minor(dev)];
d427 1
a427 1
	register struct pt_softc *pti = &pt_softc[minor(dev)];
d496 1
a496 1
	register struct pt_softc *pti = &pt_softc[minor(dev)];
d582 1
a582 1
	struct pt_softc *pti = &pt_softc[minor(dev)];
d698 1
a698 1
	struct pt_softc *pti = &pt_softc[minor(dev)];
d728 1
a728 1
	register struct pt_softc *pti = &pt_softc[minor(dev)];
d743 1
a743 1
	register struct pt_softc *pti = &pt_softc[minor(dev)];
d901 39
@


1.15
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.14 2003/07/22 01:03:12 mickey Exp $	*/
d119 1
a119 3
		tty_attach(tp);
	}
	else
d313 1
a313 3
		tty_attach(tp);
	}
	else
@


1.14
log
@make it compile again damnit; from slash@@peereboom.us
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.13 2003/07/21 22:44:50 tedu Exp $	*/
d53 1
d237 1
a237 1
 * Wake up process selecting or sleeping for input from controlling tty.
d505 1
a505 4
ptcselect(dev, rw, p)
	dev_t dev;
	int rw;
	struct proc *p;
d507 6
a512 3
	register struct pt_softc *pti = &pt_softc[minor(dev)];
	register struct tty *tp = pti->pt_tty;
	int s;
d514 2
a515 3
	if ((tp->t_state&TS_CARR_ON) == 0)
		return (1);
	switch (rw) {
d517 1
a517 1
	case FREAD:
d519 1
a519 1
		 * Need to block timeouts (ttrstart).
d522 4
a525 5
		if ((tp->t_state&TS_ISOPEN) &&
		     tp->t_outq.c_cc && (tp->t_state&TS_TTSTOP) == 0) {
			splx(s);
			return (1);
		}
d527 22
a548 1
		/* FALLTHROUGH */
d550 1
a550 26
	case 0:					/* exceptional */
		if ((tp->t_state&TS_ISOPEN) &&
		    (((pti->pt_flags & PF_PKT) && pti->pt_send) ||
		     ((pti->pt_flags & PF_UCNTL) && pti->pt_ucntl)))
			return (1);
		selrecord(p, &pti->pt_selr);
		break;


	case FWRITE:
		if (tp->t_state&TS_ISOPEN) {
			if (pti->pt_flags & PF_REMOTE) {
			    if (tp->t_canq.c_cc == 0)
				return (1);
			} else {
			    if (tp->t_rawq.c_cc + tp->t_canq.c_cc < TTYHOG-2)
				    return (1);
			    if (tp->t_canq.c_cc == 0 && ISSET(tp->t_lflag, ICANON))
				    return (1);
			}
		}
		selrecord(p, &pti->pt_selw);
		break;

	}
	return (0);
@


1.13
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.12 2003/06/14 23:14:30 mickey Exp $	*/
d645 1
a645 1
	kn->kn_hook = pti;
@


1.12
log
@doing kqueue on the master side of the pty returns events
for the slave size as described in the pr3209.
the regress has been created to verify for the conditions.
from wayne@@epipe.com.au
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.11 2003/06/02 23:28:06 millert Exp $	*/
d139 1
a139 1
		error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH,
d185 1
a185 1
			error = ttysleep(tp, (caddr_t)&lbolt, 
d193 1
a193 1
			error = ttysleep(tp, (caddr_t)&tp->t_canq,
d287 1
a287 1
		wakeup((caddr_t)&tp->t_outq.c_cf);
d292 1
a292 1
		wakeup((caddr_t)&tp->t_rawq.c_cf);
d371 1
a371 2
					uiomove((caddr_t) &tp->t_termios,
						cc, uio);
d390 1
a390 1
		error = tsleep((caddr_t)&tp->t_outq.c_cf, TTIPRI | PCATCH,
d406 1
a406 1
			wakeup((caddr_t)&tp->t_outq);
d439 1
a439 1
				error = uiomove((caddr_t)cp, cc, uio);
d452 1
a452 1
		wakeup((caddr_t)&tp->t_canq);
d459 1
a459 1
			error = uiomove((caddr_t)cp, cc, uio);
d469 1
a469 1
				wakeup((caddr_t)&tp->t_rawq);
d493 1
a493 1
	error = tsleep((caddr_t)&tp->t_rawq.c_cf, TTOPRI | PCATCH,
d645 1
a645 1
	kn->kn_hook = (caddr_t)pti;
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.10 2002/03/14 01:27:05 millert Exp $	*/
d80 5
d288 1
d293 1
d559 95
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.9 2002/02/17 07:07:49 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@ICANON is a t_lflag, not t_iflag; neelnatu@@yahoo.com
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.8 2001/07/19 18:52:05 mickey Exp $	*/
d79 4
a82 4
void	ptyattach __P((int));
void	ptcwakeup __P((struct tty *, int));
struct tty *ptytty __P((dev_t));
void	ptsstart __P((struct tty *));
d294 1
a294 1
int ptcopen __P((dev_t, int, int, struct proc *));
@


1.8
log
@make number of ptys configurable; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.7 1997/11/30 21:41:03 deraadt Exp $	*/
d466 1
a466 1
			   (tp->t_canq.c_cc > 0 || !(tp->t_iflag&ICANON))) {
d545 1
a545 1
			    if (tp->t_canq.c_cc == 0 && (tp->t_iflag&ICANON))
@


1.8.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.8 2001/07/19 18:52:05 mickey Exp $	*/
d79 4
a82 4
void	ptyattach(int);
void	ptcwakeup(struct tty *, int);
struct tty *ptytty(dev_t);
void	ptsstart(struct tty *);
d294 1
a294 1
int ptcopen(dev_t, int, int, struct proc *);
d466 1
a466 1
			   (tp->t_canq.c_cc > 0 || !ISSET(tp->t_lflag, ICANON))) {
d545 1
a545 1
			    if (tp->t_canq.c_cc == 0 && ISSET(tp->t_lflag, ICANON))
@


1.7
log
@fix TIOCGPGRP in sunos emulation
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.6 1997/11/13 03:11:17 millert Exp $	*/
a42 1
#include "pty.h"		/* XXX */
d52 1
a57 7


#if NPTY == 1
#undef NPTY
#define	NPTY	32		/* crude XXX */
#endif

d70 2
a71 2
} pt_softc[NPTY];		/* XXX */
int	npty = NPTY;		/* for pstat -t */
a90 1
#ifdef notyet
d97 1
a98 1
#endif
@


1.7.10.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.7 1997/11/30 21:41:03 deraadt Exp $	*/
d43 1
a52 1
#include <sys/malloc.h>
d58 7
d77 2
a78 2
} *pt_softc;
int	npty;
d98 1
a104 1
	bzero(pt_softc, n * sizeof(struct pt_softc));
d106 1
@


1.7.10.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d466 1
a466 1
			   (tp->t_canq.c_cc > 0 || !ISSET(tp->t_lflag, ICANON))) {
d545 1
a545 1
			    if (tp->t_canq.c_cc == 0 && ISSET(tp->t_lflag, ICANON))
@


1.7.10.3
log
@Merge in -current from about a week ago
@
text
@d79 4
a82 4
void	ptyattach(int);
void	ptcwakeup(struct tty *, int);
struct tty *ptytty(dev_t);
void	ptsstart(struct tty *);
d294 1
a294 1
int ptcopen(dev_t, int, int, struct proc *);
@


1.7.10.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.7.10.3 2002/03/28 11:43:04 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.10.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a52 1
#include <sys/poll.h>
a79 5
void	filt_ptcrdetach(struct knote *);
int	filt_ptcread(struct knote *, long);
void	filt_ptcwdetach(struct knote *);
int	filt_ptcwrite(struct knote *, long);

d113 3
a115 1
	} else
d134 1
a134 1
		error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
d180 1
a180 1
			error = ttysleep(tp, &lbolt, 
d188 1
a188 1
			error = ttysleep(tp, &tp->t_canq,
d231 1
a231 1
 * Wake up process polling or sleeping for input from controlling tty.
d282 1
a282 2
		wakeup(&tp->t_outq.c_cf);
		KNOTE(&pti->pt_selr.si_note, 0);
d286 1
a286 2
		wakeup(&tp->t_rawq.c_cf);
		KNOTE(&pti->pt_selw.si_note, 0);
d307 3
a309 1
	} else
d364 2
a365 1
					uiomove(&tp->t_termios, cc, uio);
d384 1
a384 1
		error = tsleep(&tp->t_outq.c_cf, TTIPRI | PCATCH,
d400 1
a400 1
			wakeup(&tp->t_outq);
d433 1
a433 1
				error = uiomove(cp, cc, uio);
d446 1
a446 1
		wakeup(&tp->t_canq);
d453 1
a453 1
			error = uiomove(cp, cc, uio);
d463 1
a463 1
				wakeup(&tp->t_rawq);
d487 1
a487 1
	error = tsleep(&tp->t_rawq.c_cf, TTOPRI | PCATCH,
d498 4
a501 1
ptcpoll(dev_t dev, int events, struct proc *p)
d503 3
a505 3
	struct pt_softc *pti = &pt_softc[minor(dev)];
	struct tty *tp = pti->pt_tty;
	int revents = 0, s;
d507 3
a509 2
	if (!ISSET(tp->t_state, TS_CARR_ON))
		return (POLLHUP);
d511 1
a511 4
	if (!ISSET(tp->t_state, TS_ISOPEN))
		goto notopen;

	if (events & (POLLIN | POLLRDNORM)) {
d513 1
a513 1
		 * Need to protect access to t_outq
d516 5
a520 4
		if ((tp->t_outq.c_cc && !ISSET(tp->t_state, TS_TTSTOP)) ||
		     ((pti->pt_flags & PF_PKT) && pti->pt_send) ||
		     ((pti->pt_flags & PF_UCNTL) && pti->pt_ucntl))
			revents |= events & (POLLIN | POLLRDNORM);
d522 1
a522 22
	}
	if (events & (POLLOUT | POLLWRNORM)) {
		if ((pti->pt_flags & PF_REMOTE) ?
		     (tp->t_canq.c_cc == 0) :
		     ((tp->t_rawq.c_cc + tp->t_canq.c_cc < TTYHOG - 2) ||
		      (tp->t_canq.c_cc == 0 && ISSET(tp->t_lflag, ICANON))))
			revents |= events & (POLLOUT | POLLWRNORM);
	}
	if (events & (POLLPRI | POLLRDBAND)) {
		/* If in packet or user control mode, check for data. */
		if (((pti->pt_flags & PF_PKT) && pti->pt_send) ||
		     ((pti->pt_flags & PF_UCNTL) && pti->pt_ucntl))
			revents |= events & (POLLPRI | POLLRDBAND);
	}

	if (revents == 0) {
notopen:
		if (events & (POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND))
			selrecord(p, &pti->pt_selr);
		if (events & (POLLOUT | POLLWRNORM))
			selrecord(p, &pti->pt_selw);
	}
d524 7
a530 2
	return (revents);
}
a531 5
void
filt_ptcrdetach(struct knote *kn)
{
	struct pt_softc *pti = (struct pt_softc *)kn->kn_hook;
	int s;
d533 14
a546 13
	s = spltty();
	SLIST_REMOVE(&pti->pt_selr.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_ptcread(struct knote *kn, long hint)
{
	struct pt_softc *pti = (struct pt_softc *)kn->kn_hook;
	struct tty *tp;

	tp = pti->pt_tty;
	kn->kn_data = 0;
a547 6
	if (ISSET(tp->t_state, TS_ISOPEN)) {
		if (!ISSET(tp->t_state, TS_TTSTOP))
			kn->kn_data = tp->t_outq.c_cc;
		if (((pti->pt_flags & PF_PKT) && pti->pt_send) ||
		    ((pti->pt_flags & PF_UCNTL) && pti->pt_ucntl))
			kn->kn_data++;
d549 1
a549 33
	return (kn->kn_data > 0);
}

void
filt_ptcwdetach(struct knote *kn)
{
	struct pt_softc *pti = (struct pt_softc *)kn->kn_hook;
	int s;

	s = spltty();
	SLIST_REMOVE(&pti->pt_selw.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_ptcwrite(struct knote *kn, long hint)
{
	struct pt_softc *pti = (struct pt_softc *)kn->kn_hook;
	struct tty *tp;

	tp = pti->pt_tty;
	kn->kn_data = 0;

	if (ISSET(tp->t_state, TS_ISOPEN)) {
		if (ISSET(pti->pt_flags, PF_REMOTE)) {
			if (tp->t_canq.c_cc == 0)
				kn->kn_data = tp->t_canq.c_cn;
		} else if (tp->t_rawq.c_cc + tp->t_canq.c_cc < TTYHOG-2)
			kn->kn_data = tp->t_canq.c_cn -
			    (tp->t_rawq.c_cc + tp->t_canq.c_cc);
	}

	return (kn->kn_data > 0);
a551 33
struct filterops ptcread_filtops =
	{ 1, NULL, filt_ptcrdetach, filt_ptcread };
struct filterops ptcwrite_filtops =
	{ 1, NULL, filt_ptcwdetach, filt_ptcwrite };

int
ptckqfilter(dev_t dev, struct knote *kn)
{
	struct pt_softc *pti = &pt_softc[minor(dev)];
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &pti->pt_selr.si_note;
		kn->kn_fop = &ptcread_filtops;
		break;
	case EVFILT_WRITE:
		klist = &pti->pt_selw.si_note;
		kn->kn_fop = &ptcwrite_filtops;
		break;
	default:
		return (1);
	}

	kn->kn_hook = (caddr_t)pti;

	s = spltty();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}
@


1.7.10.6
log
@Merge with the trunk
@
text
@a41 2
#include <sys/namei.h>
#include <sys/mount.h>
a45 1
#include <sys/filedesc.h>
a52 2
#include <sys/stat.h>
#include <sys/sysctl.h>
a53 1
#include <sys/rwlock.h>
d58 2
a59 2
 * pts == /dev/tty[p-zP-T][0-9a-zA-Z]
 * ptc == /dev/pty[p-zP-T][0-9a-zA-Z]
a60 7

/* XXX this needs to come from somewhere sane, and work with MAKEDEV */
#define TTY_LETTERS "pqrstuvwxyzPQRST"
#define TTY_SUFFIX "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

static int pts_major;

d67 2
a68 11
	char	pty_pn[11];
	char	pty_sn[11];
};

#define	DEFAULT_NPTYS		8	/* default number of initial ptys */
#define DEFAULT_MAXPTYS		992	/* default maximum number of ptys */

static struct pt_softc **pt_softc = NULL;	/* pty array */
static int npty = 0;				/* size of pty array */
static int maxptys = DEFAULT_MAXPTYS;		/* maximum number of ptys */
struct rwlock pt_softc_lock = RWLOCK_INITIALIZER;  /* for pty array */
a79 1
int	sysctl_pty(int *, u_int, void *, size_t *, void *, size_t);
a85 107
static struct pt_softc **ptyarralloc(int);
static int check_pty(int);

static gid_t tty_gid = TTY_GID;

void	ptydevname(int, struct pt_softc *);
dev_t	pty_getfree(void);

void	ptmattach(int);
int	ptmopen(dev_t, int, int, struct proc *);
int	ptmclose(dev_t, int, int, struct proc *);
int	ptmread(dev_t, struct uio *, int);
int	ptmwrite(dev_t, struct uio *, int);
int	ptmwrite(dev_t, struct uio *, int);
int	ptmioctl(dev_t, u_long, caddr_t, int, struct proc *p);
int	ptmpoll(dev_t, int, struct proc *p);
static int ptm_vn_open(struct nameidata *);

void
ptydevname(int minor, struct pt_softc *pti)
{
	char buf[11] = "/dev/XtyXX";
	int i, j;

	i = minor / (sizeof(TTY_SUFFIX) - 1);
	j = minor % (sizeof(TTY_SUFFIX) - 1);
	if (i >= sizeof(TTY_LETTERS) - 1) {
		pti->pty_pn[0] = '\0';
		pti->pty_sn[0] = '\0';
		return;
	}
	buf[5] = 'p';
	buf[8] = TTY_LETTERS[i];
	buf[9] = TTY_SUFFIX[j];
	memcpy(pti->pty_pn, buf, sizeof(buf));
	buf[5] = 't';
	memcpy(pti->pty_sn, buf, sizeof(buf));
}

/*
 * Allocate and zero array of nelem elements.
 */
static struct pt_softc **
ptyarralloc(int nelem)
{
	struct pt_softc **pt;

	pt = malloc(nelem * sizeof(struct pt_softc *), M_DEVBUF, M_WAITOK);
	bzero(pt, nelem * sizeof(struct pt_softc *));
	return pt;
}

/*
 * Check if the minor is correct and ensure necessary structures
 * are properly allocated.
 */
static int
check_pty(int minor)
{
	struct pt_softc *pti;

	rw_enter_write(&pt_softc_lock, curproc);
	if (minor >= npty) {
		struct pt_softc **newpt;
		int newnpty;

		/* check if the requested pty can be granted */
		if (minor >= maxptys)
			goto limit_reached;

		/* grow pty array by powers of two, up to maxptys */
		for (newnpty = npty; newnpty <= minor; newnpty *= 2)
			;

		if (newnpty > maxptys)
			newnpty = maxptys;
		newpt = ptyarralloc(newnpty);

		if (maxptys == npty) {
			goto limit_reached;
		}

		memcpy(newpt, pt_softc, npty * sizeof(struct pt_softc *));
		free(pt_softc, M_DEVBUF);
		pt_softc = newpt;
		npty = newnpty;
	}

	/*
	 * If the entry is not yet allocated, allocate one.
	 */
	if (!pt_softc[minor]) {
		MALLOC(pti, struct pt_softc *, sizeof(struct pt_softc),
		    M_DEVBUF, M_WAITOK);
		bzero(pti, sizeof(struct pt_softc));
		pti->pt_tty = ttymalloc();
		ptydevname(minor, pti);
		pt_softc[minor] = pti;
	}
	rw_exit_write(&pt_softc_lock);
	return (0);
limit_reached:
	rw_exit_write(&pt_softc_lock);
	tablefull("pty");
	return (ENXIO);
}

d90 2
a91 1
ptyattach(int n)
d93 2
d97 3
a99 2
		n = DEFAULT_NPTYS;
	pt_softc = ptyarralloc(n);
a100 5

	/*
	 * If we have pty, we need ptm too.
	 */
	ptmattach(1);
d114 3
a116 4
	if ((error = check_pty(minor(dev))))
		return (error);

	pti = pt_softc[minor(dev)];
d154 1
a154 1
	register struct pt_softc *pti = pt_softc[minor(dev)];
d171 1
a171 1
	register struct pt_softc *pti = pt_softc[minor(dev)];
d184 2
a185 2
			error = ttysleep(tp, &lbolt,
			    TTIPRI | PCATCH, ttybg, 0);
d193 1
a193 1
			    TTIPRI | PCATCH, ttyin, 0);
d225 1
a225 1
	register struct pt_softc *pti = pt_softc[minor(dev)];
d241 1
a241 1
	register struct pt_softc *pti = pt_softc[minor(tp->t_dev)];
d257 1
a257 1
	struct pt_softc *pti = pt_softc[minor(tp->t_dev)];
d282 1
a282 1
	struct pt_softc *pti = pt_softc[minor(tp->t_dev)];
a306 1
	int error;
d308 3
a310 4
	if ((error = check_pty(minor(dev))))
		return (error);

	pti = pt_softc[minor(dev)];
d333 1
a333 1
	register struct pt_softc *pti = pt_softc[minor(dev)];
d348 1
a348 1
	register struct pt_softc *pti = pt_softc[minor(dev)];
d388 1
a388 1
		    ttyin, 0);
d417 1
a417 1
	register struct pt_softc *pti = pt_softc[minor(dev)];
d491 1
a491 1
	    ttyout, 0);
d503 1
a503 1
	struct pt_softc *pti = pt_softc[minor(dev)];
d519 2
a520 2
		    ((pti->pt_flags & PF_PKT) && pti->pt_send) ||
		    ((pti->pt_flags & PF_UCNTL) && pti->pt_ucntl))
d526 3
a528 3
		    (tp->t_canq.c_cc == 0) :
		    ((tp->t_rawq.c_cc + tp->t_canq.c_cc < TTYHOG - 2) ||
		    (tp->t_canq.c_cc == 0 && ISSET(tp->t_lflag, ICANON))))
d534 1
a534 1
		    ((pti->pt_flags & PF_UCNTL) && pti->pt_ucntl))
d619 1
a619 1
	struct pt_softc *pti = pt_softc[minor(dev)];
d649 1
a649 1
	register struct pt_softc *pti = pt_softc[minor(dev)];
d664 1
a664 1
	register struct pt_softc *pti = pt_softc[minor(dev)];
d746 1
a746 1
		case TIOCSETP:
d785 1
a785 1
		switch (cmd) {
d804 2
a805 2
	stop = (tp->t_iflag & IXON) && CCEQ(cc[VSTOP], CTRL('s')) &&
	    CCEQ(cc[VSTART], CTRL('q'));
a821 295
}

/*
 * Return pty-related information.
 */
int
sysctl_pty(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	int err;
	int newmax;

	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case KERN_TTY_MAXPTYS:
		if (!newp)
			return (sysctl_rdint(oldp, oldlenp, newp, maxptys));
		err = sysctl_int(oldp, oldlenp, newp, newlen, &newmax);
		if (err)
			return (err);
		rw_enter_write(&pt_softc_lock, curproc);
		/*
		 * We can't set the max lower than the current
		 * active value or to a value bigger than a dev_t minor
		 */
		if (newmax <= USHRT_MAX && newmax > npty)
			maxptys = newmax;
		else
			err = EINVAL;
		rw_exit_write(&pt_softc_lock);
		return(err);
	case KERN_TTY_NPTYS:
		return (sysctl_rdint(oldp, oldlenp, newp, npty));
#ifdef notyet
	case KERN_TTY_GID:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &tty_gid));
#endif
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

/*
 * Check if a pty is free to use.
 */
static __inline int
pty_isfree_locked(int minor)
{
	struct pt_softc *pt = pt_softc[minor];
	return (pt == NULL || pt->pt_tty == NULL ||
	    pt->pt_tty->t_oproc == NULL);
}

static int
pty_isfree(int minor)
{
	int isfree;

	rw_enter_read(&pt_softc_lock);
	isfree = pty_isfree_locked(minor);
	rw_exit_read(&pt_softc_lock);
	return(isfree);
}

dev_t
pty_getfree(void)
{
	int i;

	rw_enter_read(&pt_softc_lock);
	for (i = 0; i < npty; i++) {
		if (pty_isfree_locked(i))
			break;
	}
	rw_exit_read(&pt_softc_lock);
	return (makedev(pts_major, i));
}

/*
 * Hacked up version of vn_open. We _only_ handle ptys and only open
 * them with FREAD|FWRITE and never deal with creat or stuff like that.
 *
 * We need it because we have to fake up root credentials to open the pty.
 */
static int
ptm_vn_open(struct nameidata *ndp)
{
	struct vnode *vp;
	struct proc *p = ndp->ni_cnd.cn_proc;
	struct ucred *cred;
	int error;

	if ((error = namei(ndp)) != 0)
		return (error);
	vp = ndp->ni_vp;
	if (vp->v_type != VCHR) {
		error = EINVAL;
		goto bad;
	}

	/*
	 * Get us a fresh cred with root privileges.
	 */
	cred = crget();
	error = VOP_OPEN(vp, FREAD|FWRITE, cred, p);
	crfree(cred);

	if (error)
		goto bad;

	vp->v_writecount++;

	return (0);
bad:
	vput(vp);
	return (error);
}

void
ptmattach(int n)
{
	/* find the major and minor of the pty devices */
	int i;

	for (i = 0; i < nchrdev; i++)
		if (cdevsw[i].d_open == ptsopen)
			break;

	if (i == nchrdev)
		panic("ptmattach: Can't find pty slave in cdevsw");

	pts_major = i;
}

int
ptmopen(dev_t dev, int flag, int mode, struct proc *p)
{
	return(0);
}


int
ptmclose(dev_t dev, int flag, int mode, struct proc *p)
{
	return (0);
}

int
ptmread(dev_t dev, struct uio *uio, int ioflag)
{
	return (EIO);
}

int
ptmwrite(dev_t dev, struct uio *uio, int ioflag)
{
	return (EIO);
}

int
ptmioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	dev_t newdev, error;
	struct pt_softc * pti;
	struct nameidata cnd, snd;
	struct filedesc *fdp = p->p_fd;
	struct file *cfp = NULL, *sfp = NULL;
	int cindx, sindx;
	uid_t uid;
	gid_t gid;
	struct vattr vattr;
	struct ucred *cred;
	struct ptmget *ptm = (struct ptmget *)data;

	error = 0;
	switch (cmd) {
	case PTMGET:
		fdplock(fdp, p);
		/* Grab two filedescriptors. */
		if ((error = falloc(p, &cfp, &cindx)) != 0) {
			fdpunlock(fdp);
			break;
		}
		if ((error = falloc(p, &sfp, &sindx)) != 0) {
			fdremove(fdp, cindx);
			closef(cfp, p);
			fdpunlock(fdp);
			break;
		}

retry:
		/* Find and open a free master pty. */
		newdev = pty_getfree();
		if ((error = check_pty(minor(newdev))))
			goto bad;
		pti = pt_softc[minor(newdev)];
		NDINIT(&cnd, LOOKUP, NOFOLLOW|LOCKLEAF, UIO_SYSSPACE,
		    pti->pty_pn, p);
		if ((error = ptm_vn_open(&cnd)) != 0) {
			/*
			 * Check if the master open failed because we lost
			 * the race to grab it.
			 */
			if (error == EIO && !pty_isfree(minor(newdev)))
				goto retry;
			goto bad;
		}
		cfp->f_flag = FREAD|FWRITE;
		cfp->f_type = DTYPE_VNODE;
		cfp->f_ops = &vnops;
		cfp->f_data = (caddr_t) cnd.ni_vp;
		VOP_UNLOCK(cnd.ni_vp, 0, p);
		FILE_SET_MATURE(cfp);

		/*
		 * Open the slave.
		 * namei -> setattr -> unlock -> revoke -> vrele ->
		 * namei -> open -> unlock
		 * Three stage rocket:
		 * 1. Change the owner and permissions on the slave.
		 * 2. Revoke all the users of the slave.
		 * 3. open the slave.
		 */
		NDINIT(&snd, LOOKUP, NOFOLLOW|LOCKLEAF, UIO_SYSSPACE,
		    pti->pty_sn, p);
		if ((error = namei(&snd)) != 0)
			goto bad;
		if ((snd.ni_vp->v_mount->mnt_flag & MNT_RDONLY) == 0) {
			gid = tty_gid;
			/* get real uid */
			uid = p->p_cred->p_ruid;

			VATTR_NULL(&vattr);
			vattr.va_uid = uid;
			vattr.va_gid = gid;
			vattr.va_mode = (S_IRUSR|S_IWUSR|S_IWGRP) & ALLPERMS;
			/* Get a fake cred to pretend we're root. */
			cred = crget();
			error = VOP_SETATTR(snd.ni_vp, &vattr, cred, p);
			crfree(cred);
			if (error)
				goto bad;
		}
		VOP_UNLOCK(snd.ni_vp, 0, p);
		if (snd.ni_vp->v_usecount > 1 ||
		    (snd.ni_vp->v_flag & (VALIASED | VLAYER)))
			VOP_REVOKE(snd.ni_vp, REVOKEALL);

		/*
		 * The vnode is useless after the revoke, we need to
		 * namei again.
		 */
		vrele(snd.ni_vp);

		NDINIT(&snd, LOOKUP, NOFOLLOW|LOCKLEAF, UIO_SYSSPACE,
		    pti->pty_sn, p);
		/* now open it */
		if ((error = ptm_vn_open(&snd)) != 0)
			goto bad;
		sfp->f_flag = FREAD|FWRITE;
		sfp->f_type = DTYPE_VNODE;
		sfp->f_ops = &vnops;
		sfp->f_data = (caddr_t) snd.ni_vp;
		VOP_UNLOCK(snd.ni_vp, 0, p);
		FILE_SET_MATURE(sfp);

		/* now, put the indexen and names into struct ptmget */
		ptm->cfd = cindx;
		ptm->sfd = sindx;
		memcpy(ptm->cn, pti->pty_pn, sizeof(pti->pty_pn));
		memcpy(ptm->sn, pti->pty_sn, sizeof(pti->pty_sn));

		fdpunlock(fdp);
		break;
	default:
		error = EINVAL;
		break;
	}
	return (error);
bad:
	fdremove(fdp, cindx);
	closef(cfp, p);
	fdremove(fdp, sindx);
	closef(sfp, p);
	fdpunlock(fdp);
	return (error);
}

int
ptmpoll(dev_t dev, int events, struct proc *p)
{
	return (seltrue(dev, events, p));
@


1.6
log
@EXTPROC fix from lite2.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.5 1997/02/24 14:20:00 niklas Exp $	*/
d619 13
@


1.5
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: tty_pty.c,v 1.33.4.1 1996/06/02 09:08:11 mrg Exp $	*/
d36 1
a36 1
 *	@@(#)tty_pty.c	8.2 (Berkeley) 9/23/93
d606 1
a606 1
			if ((tp->t_state & EXTPROC) &&
@


1.4
log
@tty_init/attach/detach()
@
text
@d1 1
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$NetBSD: tty_pty.c,v 1.33 1996/03/30 22:24:45 christos Exp $	*/
d122 1
a122 1
	if (!pti->pt_tty)
d124 2
d316 1
a316 1
	if (!pti->pt_tty)
d318 2
@


1.2
log
@From NetBSD: Merge with NetBSD 960217
@
text
@d1 1
a1 1
/*	$NetBSD: tty_pty.c,v 1.32 1996/02/09 19:00:41 christos Exp $	*/
d55 1
a56 2
#undef NPTY	/* XXX */
#include <kern/kern_conf.h>
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: tty_pty.c,v 1.30 1995/10/10 01:27:03 mycroft Exp $	*/
a48 1
#include <sys/conf.h>
d53 6
d86 4
a89 1
void	ptsstop __P((struct tty *, int));
d110 1
d144 3
a146 2
		if (error = ttysleep(tp, (caddr_t)&tp->t_rawq, TTIPRI | PCATCH,
		    ttopen, 0))
d154 1
d162 1
a162 1
	int err;
d164 2
a165 2
	err = (*linesw[tp->t_line].l_close)(tp, flag);
	err |= ttyclose(tp);
d167 1
a167 1
	return (err);
d170 1
d190 3
a192 2
			if (error = ttysleep(tp, (caddr_t)&lbolt, 
			    TTIPRI | PCATCH, ttybg, 0))
d198 3
a200 2
			if (error = ttysleep(tp, (caddr_t)&tp->t_canq,
			    TTIPRI | PCATCH, ttyin, 0))
d225 1
d258 26
d330 1
d332 1
a332 1
ptcclose(dev)
d334 2
d346 1
d372 2
a373 1
					uiomove(&tp->t_termios, cc, uio);
d392 3
a394 2
		if (error = tsleep((caddr_t)&tp->t_outq.c_cf, TTIPRI | PCATCH,
		    ttyin, 0))
a414 77
void
ptsstop(tp, flush)
	register struct tty *tp;
	int flush;
{
	struct pt_softc *pti = &pt_softc[minor(tp->t_dev)];
	int flag;

	/* note: FLUSHREAD and FLUSHWRITE already ok */
	if (flush == 0) {
		flush = TIOCPKT_STOP;
		pti->pt_flags |= PF_STOPPED;
	} else
		pti->pt_flags &= ~PF_STOPPED;
	pti->pt_send |= flush;
	/* change of perspective */
	flag = 0;
	if (flush & FREAD)
		flag |= FWRITE;
	if (flush & FWRITE)
		flag |= FREAD;
	ptcwakeup(tp, flag);
}

ptcselect(dev, rw, p)
	dev_t dev;
	int rw;
	struct proc *p;
{
	register struct pt_softc *pti = &pt_softc[minor(dev)];
	register struct tty *tp = pti->pt_tty;
	int s;

	if ((tp->t_state&TS_CARR_ON) == 0)
		return (1);
	switch (rw) {

	case FREAD:
		/*
		 * Need to block timeouts (ttrstart).
		 */
		s = spltty();
		if ((tp->t_state&TS_ISOPEN) &&
		     tp->t_outq.c_cc && (tp->t_state&TS_TTSTOP) == 0) {
			splx(s);
			return (1);
		}
		splx(s);
		/* FALLTHROUGH */

	case 0:					/* exceptional */
		if ((tp->t_state&TS_ISOPEN) &&
		    (pti->pt_flags&PF_PKT && pti->pt_send ||
		     pti->pt_flags&PF_UCNTL && pti->pt_ucntl))
			return (1);
		selrecord(p, &pti->pt_selr);
		break;


	case FWRITE:
		if (tp->t_state&TS_ISOPEN) {
			if (pti->pt_flags & PF_REMOTE) {
			    if (tp->t_canq.c_cc == 0)
				return (1);
			} else {
			    if (tp->t_rawq.c_cc + tp->t_canq.c_cc < TTYHOG-2)
				    return (1);
			    if (tp->t_canq.c_cc == 0 && (tp->t_iflag&ICANON))
				    return (1);
			}
		}
		selrecord(p, &pti->pt_selw);
		break;

	}
	return (0);
}
d416 1
d424 1
a424 1
	register u_char *cp;
d495 3
a497 2
	if (error = tsleep((caddr_t)&tp->t_rawq.c_cf, TTOPRI | PCATCH,
	    ttyout, 0)) {
d505 56
d572 1
d648 1
a648 1
#if defined(COMPAT_43) || defined(COMPAT_FREEBSD)
d692 1
a692 1
#if defined(COMPAT_43) || defined(COMPAT_FREEBSD)
a694 2
#endif
#if defined(COMPAT_43) || defined(COMPAT_SUNOS) || defined(COMPAT_FREEBSD)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
