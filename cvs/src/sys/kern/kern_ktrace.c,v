head	1.92;
access;
symbols
	OPENBSD_6_2_BASE:1.92
	OPENBSD_6_1:1.91.0.4
	OPENBSD_6_1_BASE:1.91
	OPENBSD_6_0:1.88.0.2
	OPENBSD_6_0_BASE:1.88
	OPENBSD_5_9:1.86.0.2
	OPENBSD_5_9_BASE:1.86
	OPENBSD_5_8:1.75.0.4
	OPENBSD_5_8_BASE:1.75
	OPENBSD_5_7:1.73.0.2
	OPENBSD_5_7_BASE:1.73
	OPENBSD_5_6:1.69.0.4
	OPENBSD_5_6_BASE:1.69
	OPENBSD_5_5:1.63.0.4
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.60.0.2
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.58.0.4
	OPENBSD_5_3_BASE:1.58
	OPENBSD_5_2:1.58.0.2
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.2
	OPENBSD_5_0:1.54.0.2
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.49.0.4
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.46.0.6
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.46.0.2
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.42.0.4
	OPENBSD_4_3_BASE:1.42
	OPENBSD_4_2:1.42.0.2
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.41.0.2
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.40.0.2
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.39.0.2
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.36.0.2
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.34.0.2
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.33.0.2
	OPENBSD_3_6_BASE:1.33
	SMP_SYNC_A:1.32
	SMP_SYNC_B:1.32
	OPENBSD_3_5:1.31.0.4
	OPENBSD_3_5_BASE:1.31
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.29
	OPENBSD_3_3:1.29.0.4
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	UBC_SYNC_B:1.29
	UBC:1.25.0.2
	UBC_BASE:1.25
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	SMP:1.11.0.6
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.92
date	2017.08.12.00.03.10;	author tedu;	state Exp;
branches;
next	1.91;
commitid	cUT8xG3ajI2ygOIy;

1.91
date	2017.02.14.10.31.15;	author mpi;	state Exp;
branches;
next	1.90;
commitid	PmGi4EGraGC0Z0ml;

1.90
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.89;
commitid	CHRb0fCqa8XxUAMH;

1.89
date	2016.11.07.00.26.32;	author guenther;	state Exp;
branches;
next	1.88;
commitid	W7ztnDZwvjCaeQTS;

1.88
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.87;
commitid	gAjwyca5TfuoJAhn;

1.87
date	2016.03.06.20.25.27;	author guenther;	state Exp;
branches;
next	1.86;
commitid	PPKYgV5KWXY1sNxp;

1.86
date	2015.12.06.17.50.21;	author deraadt;	state Exp;
branches;
next	1.85;
commitid	fXd8HOPcFESXsWp4;

1.85
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.84;
commitid	Cl55DD2g2xm69E6W;

1.84
date	2015.11.11.02.57.48;	author deraadt;	state Exp;
branches;
next	1.83;
commitid	8yfNfGS05XqB6D8w;

1.83
date	2015.11.02.16.31.55;	author semarie;	state Exp;
branches;
next	1.82;
commitid	PyvdcQVr9G4daVnG;

1.82
date	2015.10.28.11.16.23;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	cD68SvW63AWONvtm;

1.81
date	2015.10.25.20.39.54;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	SIwCBDJKKae61tEi;

1.80
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.79;
commitid	av6ZVErLSWkVP5Zz;

1.79
date	2015.10.02.05.07.41;	author guenther;	state Exp;
branches;
next	1.78;
commitid	m4jkpHQAAdeQKWoV;

1.78
date	2015.09.13.17.08.03;	author guenther;	state Exp;
branches;
next	1.77;
commitid	BssYI6s6zozAyfkk;

1.77
date	2015.09.07.15.38.45;	author guenther;	state Exp;
branches;
next	1.76;
commitid	P4QdNgT9HBzXxQ5B;

1.76
date	2015.08.22.20.18.49;	author deraadt;	state Exp;
branches;
next	1.75;
commitid	6NDuzTPjBp2GqkfQ;

1.75
date	2015.08.01.20.12.34;	author guenther;	state Exp;
branches;
next	1.74;
commitid	3SYmvvxJ3bYO2xFc;

1.74
date	2015.07.19.04.45.25;	author guenther;	state Exp;
branches;
next	1.73;
commitid	ZlSuHVkn9uJBlE0T;

1.73
date	2014.12.29.05.29.27;	author miod;	state Exp;
branches;
next	1.72;
commitid	UbmX4MifiudCV4qQ;

1.72
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.71;
commitid	P6Av4XGqOi3rFasL;

1.71
date	2014.12.10.02.44.47;	author tedu;	state Exp;
branches;
next	1.70;
commitid	tsoJBlEBSyYO22RG;

1.70
date	2014.10.26.20.34.37;	author guenther;	state Exp;
branches;
next	1.69;
commitid	6k2aYQUeHGBWmleI;

1.69
date	2014.07.13.15.46.21;	author uebayasi;	state Exp;
branches;
next	1.68;
commitid	Scu6CelRPdB3AwwA;

1.68
date	2014.07.13.15.00.40;	author tedu;	state Exp;
branches;
next	1.67;
commitid	7E1o7NIDvSyD48ls;

1.67
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.66;
commitid	QlVV51SZgNFxsXxC;

1.66
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	EF98ch02VpFassUi;

1.65
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.64;

1.64
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.63;

1.63
date	2014.01.21.01.48.44;	author tedu;	state Exp;
branches;
next	1.62;

1.62
date	2014.01.20.21.19.28;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2013.09.14.02.28.01;	author guenther;	state Exp;
branches;
next	1.60;

1.60
date	2013.06.01.16.27.37;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2013.06.01.09.49.50;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2012.04.10.20.39.37;	author mikeb;	state Exp;
branches;
next	1.57;

1.57
date	2012.03.19.09.05.39;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2011.12.14.07.32.16;	author guenther;	state Exp;
branches;
next	1.55;

1.55
date	2011.11.21.03.01.20;	author djm;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.08.19.28.36;	author otto;	state Exp;
branches;
next	1.52;

1.52
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.02.16.29.20;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2011.04.02.17.04.35;	author guenther;	state Exp;
branches;
next	1.49;

1.49
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.31.12.00.08;	author fgsch;	state Exp;
branches;
next	1.47;

1.47
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.46;

1.46
date	2008.11.01.21.35.35;	author pedro;	state Exp;
branches;
next	1.45;

1.45
date	2008.10.31.17.17.02;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2008.10.31.17.15.30;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2008.05.22.17.04.59;	author thib;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.16.17.27.30;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.14.09.16.55;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2006.05.17.02.11.25;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2006.02.27.00.34.33;	author niklas;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.28.00.14.28;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.15.23.05.37;	author pedro;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.10.21.05.27;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2005.06.02.17.32.02;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.09.20.18.28;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.01.18.06.03;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.27.02.15.52;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.06.15.41.46;	author mpech;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2002.02.22.19.19.28;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.06.26.06.27.38;	author aaron;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.06.22.14.14.08;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.10.18.15.46;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.27.16.13.46;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.29.17.46.28;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.21.07.39.15;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.20.10.03.42;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.19.10.56.41;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.19.10.13.22;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.19.08.35.37;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.18.16.22.16;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.06.13.25.26;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.03.11.31.42;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.02.11.20.34.04;	author deraadt;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	98.06.02.14.50.47;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	98.02.03.19.06.23;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.11.14.23.40.55;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.11.11.13.50.13;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.11.06.05.58.16;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.20.19.53;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.15.12.18;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.17.19.46;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.10.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches;
next	;

1.11.6.1
date	2000.03.24.09.09.24;	author niklas;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2001.05.14.22.32.40;	author niklas;	state Exp;
branches;
next	1.11.6.3;

1.11.6.3
date	2001.07.04.10.48.21;	author niklas;	state Exp;
branches;
next	1.11.6.4;

1.11.6.4
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.11.6.5;

1.11.6.5
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.11.6.6;

1.11.6.6
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.11.6.7;

1.11.6.7
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.11.6.8;

1.11.6.8
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.11.6.9;

1.11.6.9
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.11.6.10;

1.11.6.10
date	2004.06.05.17.19.55;	author niklas;	state Exp;
branches;
next	1.11.6.11;

1.11.6.11
date	2004.06.08.20.15.48;	author drahn;	state Exp;
branches;
next	1.11.6.12;

1.11.6.12
date	2004.06.10.11.40.33;	author niklas;	state Exp;
branches;
next	;

1.24.2.1
date	2002.06.27.08.21.32;	author miod;	state Exp;
branches;
next	;

1.25.2.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	;

1.27.2.1
date	2002.06.28.15.10.26;	author jason;	state Exp;
branches;
next	;


desc
@@


1.92
log
@add a fktrace syscall that takes a file descriptor instead of a name.
libc and man page parts to come.
ok guenther
@
text
@/*	$OpenBSD: kern_ktrace.c,v 1.91 2017/02/14 10:31:15 mpi Exp $	*/
/*	$NetBSD: kern_ktrace.c,v 1.23 1996/02/09 18:59:36 christos Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_ktrace.c	8.2 (Berkeley) 9/23/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/sched.h>
#include <sys/file.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/ktrace.h>
#include <sys/malloc.h>
#include <sys/syslog.h>
#include <sys/sysctl.h>
#include <sys/pledge.h>

#include <sys/mount.h>
#include <sys/syscall.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>

void	ktrinitheaderraw(struct ktr_header *, uint, pid_t, pid_t);
void	ktrinitheader(struct ktr_header *, struct proc *, int);
void	ktrstart(struct proc *, struct vnode *, struct ucred *);
int	ktrops(struct proc *, struct process *, int, int, struct vnode *,
	    struct ucred *);
int	ktrsetchildren(struct proc *, struct process *, int, int,
	    struct vnode *, struct ucred *);
int	ktrwrite(struct proc *, struct ktr_header *, const void *, size_t);
int	ktrwrite2(struct proc *, struct ktr_header *, const void *, size_t,
	    const void *, size_t);
int	ktrwriteraw(struct proc *, struct vnode *, struct ucred *,
	    struct ktr_header *, struct iovec *);
int	ktrcanset(struct proc *, struct process *);

/*
 * Clear the trace settings in a correct way (to avoid races).
 */
void
ktrcleartrace(struct process *pr)
{
	struct vnode *vp;
	struct ucred *cred;

	if (pr->ps_tracevp != NULL) {
		vp = pr->ps_tracevp;
		cred = pr->ps_tracecred;

		pr->ps_traceflag = 0;
		pr->ps_tracevp = NULL;
		pr->ps_tracecred = NULL;

		vrele(vp);
		crfree(cred);
	}
}

/*
 * Change the trace setting in a correct way (to avoid races).
 */
void
ktrsettrace(struct process *pr, int facs, struct vnode *newvp,
    struct ucred *newcred)
{
	struct vnode *oldvp;
	struct ucred *oldcred;

	KASSERT(newvp != NULL);
	KASSERT(newcred != NULL);

	pr->ps_traceflag |= facs;

	/* nothing to change about where the trace goes? */
	if (pr->ps_tracevp == newvp && pr->ps_tracecred == newcred)
		return;	

	vref(newvp);
	crhold(newcred);

	oldvp = pr->ps_tracevp;
	oldcred = pr->ps_tracecred;

	pr->ps_tracevp = newvp;
	pr->ps_tracecred = newcred;

	if (oldvp != NULL) {
		vrele(oldvp);
		crfree(oldcred);
	}
}

void
ktrinitheaderraw(struct ktr_header *kth, uint type, pid_t pid, pid_t tid)
{
	memset(kth, 0, sizeof(struct ktr_header));
	kth->ktr_type = type;
	nanotime(&kth->ktr_time);
	kth->ktr_pid = pid;
	kth->ktr_tid = tid;
}

void
ktrinitheader(struct ktr_header *kth, struct proc *p, int type)
{
	struct process *pr = p->p_p;

	ktrinitheaderraw(kth, type, pr->ps_pid, p->p_tid + THREAD_PID_OFFSET);
	memcpy(kth->ktr_comm, pr->ps_comm, MAXCOMLEN);
}

void
ktrstart(struct proc *p, struct vnode *vp, struct ucred *cred)
{
	struct ktr_header kth;

	ktrinitheaderraw(&kth, htobe32(KTR_START), -1, -1);
	ktrwriteraw(p, vp, cred, &kth, NULL);
}

void
ktrsyscall(struct proc *p, register_t code, size_t argsize, register_t args[])
{
	struct	ktr_header kth;
	struct	ktr_syscall *ktp;
	size_t len = sizeof(struct ktr_syscall) + argsize;
	register_t *argp;
	u_int nargs = 0;
	int i;

	if (code == SYS_sysctl) {
		/*
		 * The sysctl encoding stores the mib[]
		 * array because it is interesting.
		 */
		if (args[1] > 0)
			nargs = lmin(args[1], CTL_MAXNAME);
		len += nargs * sizeof(int);
	}
	atomic_setbits_int(&p->p_flag, P_INKTR);
	ktrinitheader(&kth, p, KTR_SYSCALL);
	ktp = malloc(len, M_TEMP, M_WAITOK);
	ktp->ktr_code = code;
	ktp->ktr_argsize = argsize;
	argp = (register_t *)((char *)ktp + sizeof(struct ktr_syscall));
	for (i = 0; i < (argsize / sizeof *argp); i++)
		*argp++ = args[i];
	if (nargs && copyin((void *)args[0], argp, nargs * sizeof(int)))
		memset(argp, 0, nargs * sizeof(int));
	ktrwrite(p, &kth, ktp, len);
	free(ktp, M_TEMP, len);
	atomic_clearbits_int(&p->p_flag, P_INKTR);
}

void
ktrsysret(struct proc *p, register_t code, int error,
    const register_t retval[2])
{
	struct ktr_header kth;
	struct ktr_sysret ktp;
	int len;

	atomic_setbits_int(&p->p_flag, P_INKTR);
	ktrinitheader(&kth, p, KTR_SYSRET);
	ktp.ktr_code = code;
	ktp.ktr_error = error;
	if (error)
		len = 0;
	else if (code == SYS_lseek)
		/* the one exception: lseek on ILP32 needs more */
		len = sizeof(long long);
	else
		len = sizeof(register_t);
	ktrwrite2(p, &kth, &ktp, sizeof(ktp), retval, len);
	atomic_clearbits_int(&p->p_flag, P_INKTR);
}

void
ktrnamei(struct proc *p, char *path)
{
	struct ktr_header kth;

	atomic_setbits_int(&p->p_flag, P_INKTR);
	ktrinitheader(&kth, p, KTR_NAMEI);
	ktrwrite(p, &kth, path, strlen(path));
	atomic_clearbits_int(&p->p_flag, P_INKTR);
}

void
ktrgenio(struct proc *p, int fd, enum uio_rw rw, struct iovec *iov,
    ssize_t len)
{
	struct ktr_header kth;
	struct ktr_genio ktp;
	caddr_t cp;
	int count;
	int buflen;

	atomic_setbits_int(&p->p_flag, P_INKTR);

	/* beware overflow */
	if (len > PAGE_SIZE)
		buflen = PAGE_SIZE;
	else
		buflen = len + sizeof(struct ktr_genio);

	ktrinitheader(&kth, p, KTR_GENIO);
	ktp.ktr_fd = fd;
	ktp.ktr_rw = rw;

	cp = malloc(buflen, M_TEMP, M_WAITOK);
	while (len > 0) {
		/*
		 * Don't allow this process to hog the cpu when doing
		 * huge I/O.
		 */
		sched_pause(preempt);

		count = lmin(iov->iov_len, buflen);
		if (count > len)
			count = len;
		if (copyin(iov->iov_base, cp, count))
			break;

		if (ktrwrite2(p, &kth, &ktp, sizeof(ktp), cp, count) != 0)
			break;

		iov->iov_len -= count;
		iov->iov_base = (caddr_t)iov->iov_base + count;

		if (iov->iov_len == 0)
			iov++;

		len -= count;
	}

	free(cp, M_TEMP, buflen);
	atomic_clearbits_int(&p->p_flag, P_INKTR);
}

void
ktrpsig(struct proc *p, int sig, sig_t action, int mask, int code,
    siginfo_t *si)
{
	struct ktr_header kth;
	struct ktr_psig kp;

	atomic_setbits_int(&p->p_flag, P_INKTR);
	ktrinitheader(&kth, p, KTR_PSIG);
	kp.signo = (char)sig;
	kp.action = action;
	kp.mask = mask;
	kp.code = code;
	kp.si = *si;

	ktrwrite(p, &kth, &kp, sizeof(kp));
	atomic_clearbits_int(&p->p_flag, P_INKTR);
}

void
ktrstruct(struct proc *p, const char *name, const void *data, size_t datalen)
{
	struct ktr_header kth;

	KERNEL_ASSERT_LOCKED();
	atomic_setbits_int(&p->p_flag, P_INKTR);
	ktrinitheader(&kth, p, KTR_STRUCT);
	
	if (data == NULL)
		datalen = 0;
	ktrwrite2(p, &kth, name, strlen(name) + 1, data, datalen);
	atomic_clearbits_int(&p->p_flag, P_INKTR);
}

int
ktruser(struct proc *p, const char *id, const void *addr, size_t len)
{
	struct ktr_header kth;
	struct ktr_user ktp;
	int error;
	void *memp;
#define	STK_PARAMS	128
	long long stkbuf[STK_PARAMS / sizeof(long long)];

	if (!KTRPOINT(p, KTR_USER))
		return (0);
	if (len > KTR_USER_MAXLEN)
		return (EINVAL);

	atomic_setbits_int(&p->p_flag, P_INKTR);
	ktrinitheader(&kth, p, KTR_USER);
	memset(ktp.ktr_id, 0, KTR_USER_MAXIDLEN);
	error = copyinstr(id, ktp.ktr_id, KTR_USER_MAXIDLEN, NULL);
	if (error == 0) {
		if (len > sizeof(stkbuf))
			memp = malloc(len, M_TEMP, M_WAITOK);
		else
			memp = stkbuf;
		error = copyin(addr, memp, len);
		if (error == 0)
			ktrwrite2(p, &kth, &ktp, sizeof(ktp), memp, len);
		if (memp != stkbuf)
			free(memp, M_TEMP, len);
	}
	atomic_clearbits_int(&p->p_flag, P_INKTR);
	return (error);
}

void
ktrexec(struct proc *p, int type, const char *data, ssize_t len)
{
	struct ktr_header kth;
	int count;
	int buflen;
	
	assert(type == KTR_EXECARGS || type == KTR_EXECENV);
	atomic_setbits_int(&p->p_flag, P_INKTR);

	/* beware overflow */
	if (len > PAGE_SIZE)
		buflen = PAGE_SIZE;
	else
		buflen = len;

	ktrinitheader(&kth, p, type);

	while (len > 0) {
		/*
		 * Don't allow this process to hog the cpu when doing
		 * huge I/O.
		 */
		sched_pause(preempt);

		count = lmin(len, buflen);
		if (ktrwrite(p, &kth, data, count) != 0)
			break;

		len -= count;
		data += count;
	}

	atomic_clearbits_int(&p->p_flag, P_INKTR);
}

void
ktrpledge(struct proc *p, int error, uint64_t code, int syscall)
{
	struct ktr_header kth;
	struct ktr_pledge kp;

	atomic_setbits_int(&p->p_flag, P_INKTR);
	ktrinitheader(&kth, p, KTR_PLEDGE);
	kp.error = error;
	kp.code = code;
	kp.syscall = syscall;

	ktrwrite(p, &kth, &kp, sizeof(kp));
	atomic_clearbits_int(&p->p_flag, P_INKTR);
}

/* Interface and common routines */

int
doktrace(struct vnode *vp, int ops, int facs, pid_t pid, struct proc *p)
{
	struct process *pr = NULL;
	struct ucred *cred = NULL;
	struct pgrp *pg;
	int descend = ops & KTRFLAG_DESCEND;
	int ret = 0;
	int error = 0;

	facs = facs & ~((unsigned)KTRFAC_ROOT);
	ops = KTROP(ops);

	if (ops != KTROP_CLEAR) {
		/*
		 * an operation which requires a file argument.
		 */
		cred = p->p_ucred;
		if (!vp) {
			error = EINVAL;
			goto done;
		}
		if (vp->v_type != VREG) {
			error = EACCES;
			goto done;
		}
	}
	/*
	 * Clear all uses of the tracefile
	 */
	if (ops == KTROP_CLEARFILE) {
		LIST_FOREACH(pr, &allprocess, ps_list) {
			if (pr->ps_tracevp == vp) {
				if (ktrcanset(p, pr))
					ktrcleartrace(pr);
				else
					error = EPERM;
			}
		}
		goto done;
	}
	/*
	 * need something to (un)trace (XXX - why is this here?)
	 */
	if (!facs) {
		error = EINVAL;
		goto done;
	}
	if (ops == KTROP_SET) {
		if (suser(p, 0) == 0)
			facs |= KTRFAC_ROOT;
		ktrstart(p, vp, cred);
	}
	/*
	 * do it
	 */
	if (pid < 0) {
		/*
		 * by process group
		 */
		pg = pgfind(-pid);
		if (pg == NULL) {
			error = ESRCH;
			goto done;
		}
		LIST_FOREACH(pr, &pg->pg_members, ps_pglist) {
			if (descend)
				ret |= ktrsetchildren(p, pr, ops, facs, vp,
				    cred);
			else
				ret |= ktrops(p, pr, ops, facs, vp, cred);
		}
	} else {
		/*
		 * by pid
		 */
		pr = prfind(pid);
		if (pr == NULL) {
			error = ESRCH;
			goto done;
		}
		if (descend)
			ret |= ktrsetchildren(p, pr, ops, facs, vp, cred);
		else
			ret |= ktrops(p, pr, ops, facs, vp, cred);
	}
	if (!ret)
		error = EPERM;
done:
	return (error);
}

/*
 * ktrace system call
 */
int
sys_ktrace(struct proc *p, void *v, register_t *retval)
{
	struct sys_ktrace_args /* {
		syscallarg(const char *) fname;
		syscallarg(int) ops;
		syscallarg(int) facs;
		syscallarg(pid_t) pid;
	} */ *uap = v;
	struct vnode *vp = NULL;
	const char *fname = SCARG(uap, fname);
	struct ucred *cred = NULL;
	int error;

	if (fname) {
		struct nameidata nd;

		cred = p->p_ucred;
		NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, fname, p);
		nd.ni_pledge = PLEDGE_CPATH | PLEDGE_WPATH;
		if ((error = vn_open(&nd, FWRITE|O_NOFOLLOW, 0)) != 0)
			return error;
		vp = nd.ni_vp;

		VOP_UNLOCK(vp, p);
	}

	error = doktrace(vp, SCARG(uap, ops), SCARG(uap, facs),
	    SCARG(uap, pid), p);
	if (vp != NULL)
		(void)vn_close(vp, FWRITE, cred, p);

	return error;
}

int
sys_fktrace(struct proc *p, void *v, register_t *retval)
{
	struct sys_fktrace_args /* {
		syscallarg(int) fd;
		syscallarg(int) ops;
		syscallarg(int) facs;
		syscallarg(pid_t) pid;
	} */ *uap = v;
	struct vnode *vp = NULL;
	int fd = SCARG(uap, fd);
	struct file *fp;
	int error;

	if (fd != -1) {
		if ((error = getvnode(p, fd, &fp)) != 0)
			return error;
		vp = fp->f_data;
		vref(vp);
		FRELE(fp, p);
	}

	error = doktrace(vp, SCARG(uap, ops), SCARG(uap, facs),
	    SCARG(uap, pid), p);
	if (vp != NULL)
		vrele(vp);
	
	return error;
}

int
ktrops(struct proc *curp, struct process *pr, int ops, int facs,
    struct vnode *vp, struct ucred *cred)
{
	if (!ktrcanset(curp, pr))
		return (0);
	if (ops == KTROP_SET)
		ktrsettrace(pr, facs, vp, cred);
	else {	
		/* KTROP_CLEAR */
		pr->ps_traceflag &= ~facs;
		if ((pr->ps_traceflag & KTRFAC_MASK) == 0) {
			/* cleared all the facility bits, so stop completely */
			ktrcleartrace(pr);
		}
	}

	return (1);
}

int
ktrsetchildren(struct proc *curp, struct process *top, int ops, int facs,
    struct vnode *vp, struct ucred *cred)
{
	struct process *pr;
	int ret = 0;

	pr = top;
	for (;;) {
		ret |= ktrops(curp, pr, ops, facs, vp, cred);
		/*
		 * If this process has children, descend to them next,
		 * otherwise do any siblings, and if done with this level,
		 * follow back up the tree (but not past top).
		 */
		if (!LIST_EMPTY(&pr->ps_children))
			pr = LIST_FIRST(&pr->ps_children);
		else for (;;) {
			if (pr == top)
				return (ret);
			if (LIST_NEXT(pr, ps_sibling) != NULL) {
				pr = LIST_NEXT(pr, ps_sibling);
				break;
			}
			pr = pr->ps_pptr;
		}
	}
	/*NOTREACHED*/
}

int
ktrwrite(struct proc *p, struct ktr_header *kth, const void *aux, size_t len)
{
	struct vnode *vp = p->p_p->ps_tracevp;
	struct ucred *cred = p->p_p->ps_tracecred;
	struct iovec data[2];
	int error;

	if (vp == NULL)
		return 0;
	crhold(cred);
	data[0].iov_base = (void *)aux;
	data[0].iov_len = len;
	data[1].iov_len = 0;
	kth->ktr_len = len;
	error = ktrwriteraw(p, vp, cred, kth, data);
	crfree(cred);
	return (error);
}

int
ktrwrite2(struct proc *p, struct ktr_header *kth, const void *aux1,
    size_t len1, const void *aux2, size_t len2)
{
	struct vnode *vp = p->p_p->ps_tracevp;
	struct ucred *cred = p->p_p->ps_tracecred;
	struct iovec data[2];
	int error;

	if (vp == NULL)
		return 0;
	crhold(cred);
	data[0].iov_base = (void *)aux1;
	data[0].iov_len = len1;
	data[1].iov_base = (void *)aux2;
	data[1].iov_len = len2;
	kth->ktr_len = len1 + len2;
	error = ktrwriteraw(p, vp, cred, kth, data);
	crfree(cred);
	return (error);
}

int
ktrwriteraw(struct proc *curp, struct vnode *vp, struct ucred *cred,
    struct ktr_header *kth, struct iovec *data)
{
	struct uio auio;
	struct iovec aiov[3];
	struct process *pr;
	int error;

	auio.uio_iov = &aiov[0];
	auio.uio_offset = 0;
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_rw = UIO_WRITE;
	aiov[0].iov_base = (caddr_t)kth;
	aiov[0].iov_len = sizeof(struct ktr_header);
	auio.uio_resid = sizeof(struct ktr_header);
	auio.uio_iovcnt = 1;
	auio.uio_procp = curp;
	if (kth->ktr_len > 0) {
		aiov[1] = data[0];
		aiov[2] = data[1];
		auio.uio_iovcnt++;
		if (aiov[2].iov_len > 0)
			auio.uio_iovcnt++;
		auio.uio_resid += kth->ktr_len;
	}
	vget(vp, LK_EXCLUSIVE | LK_RETRY, curp);
	error = VOP_WRITE(vp, &auio, IO_UNIT|IO_APPEND, cred);
	if (!error) {
		vput(vp);
		return (0);
	}
	/*
	 * If error encountered, give up tracing on this vnode.
	 */
	log(LOG_NOTICE, "ktrace write failed, errno %d, tracing stopped\n",
	    error);
	LIST_FOREACH(pr, &allprocess, ps_list)
		if (pr->ps_tracevp == vp && pr->ps_tracecred == cred)
			ktrcleartrace(pr);

	vput(vp);
	return (error);
}

/*
 * Return true if caller has permission to set the ktracing state
 * of target.  Essentially, the target can't possess any
 * more permissions than the caller.  KTRFAC_ROOT signifies that
 * root previously set the tracing status on the target process, and 
 * so, only root may further change it.
 *
 * TODO: check groups.  use caller effective gid.
 */
int
ktrcanset(struct proc *callp, struct process *targetpr)
{
	struct ucred *caller = callp->p_ucred;
	struct ucred *target = targetpr->ps_ucred;

	if ((caller->cr_uid == target->cr_ruid &&
	    target->cr_ruid == target->cr_svuid &&
	    caller->cr_rgid == target->cr_rgid &&	/* XXX */
	    target->cr_rgid == target->cr_svgid &&
	    (targetpr->ps_traceflag & KTRFAC_ROOT) == 0 &&
	    !ISSET(targetpr->ps_flags, PS_SUGID)) ||
	    caller->cr_uid == 0)
		return (1);

	return (0);
}
@


1.91
log
@Convert most of the manual checks for CPU hogging to sched_pause().

The distinction between preempt() and yield() stays as it is usueful
to know if a thread decided to yield by itself or if the kernel told
him to go away.

ok tedu@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.90 2017/01/21 05:42:03 guenther Exp $	*/
a394 3
/*
 * ktrace system call
 */
d396 1
a396 1
sys_ktrace(struct proc *p, void *v, register_t *retval)
a397 7
	struct sys_ktrace_args /* {
		syscallarg(const char *) fname;
		syscallarg(int) ops;
		syscallarg(int) facs;
		syscallarg(pid_t) pid;
	} */ *uap = v;
	struct vnode *vp = NULL;
d401 1
a401 3
	int facs = SCARG(uap, facs) & ~((unsigned) KTRFAC_ROOT);
	int ops = KTROP(SCARG(uap, ops));
	int descend = SCARG(uap, ops) & KTRFLAG_DESCEND;
d404 3
a406 1
	struct nameidata nd;
d413 2
a414 4
		NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, fname),
		    p);
		nd.ni_pledge = PLEDGE_CPATH | PLEDGE_WPATH;
		if ((error = vn_open(&nd, FWRITE|O_NOFOLLOW, 0)) != 0)
d416 1
a416 3
		vp = nd.ni_vp;

		VOP_UNLOCK(vp, p);
d451 1
a451 1
	if (SCARG(uap, pid) < 0) {
d455 1
a455 1
		pg = pgfind(-SCARG(uap, pid));
d471 1
a471 1
		pr = prfind(SCARG(uap, pid));
d484 65
d550 3
a552 2
		(void) vn_close(vp, FWRITE, cred, p);
	return (error);
@


1.90
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.89 2016/11/07 00:26:32 guenther Exp $	*/
d249 1
a249 2
		if (curcpu()->ci_schedstate.spc_schedflags & SPCF_SHOULDYIELD)
			preempt(NULL);
d364 1
a364 2
		if (curcpu()->ci_schedstate.spc_schedflags & SPCF_SHOULDYIELD)
			preempt(NULL);
@


1.89
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.88 2016/03/19 12:04:15 natano Exp $	*/
d138 4
a141 3
	ktrinitheaderraw(kth, type, p->p_p->ps_pid,
	    p->p_tid + THREAD_PID_OFFSET);
	memcpy(kth->ktr_comm, p->p_comm, MAXCOMLEN);
@


1.88
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.87 2016/03/06 20:25:27 guenther Exp $	*/
d139 1
a139 1
	    p->p_pid + THREAD_PID_OFFSET);
@


1.87
log
@No more compat emulations, so remove ktrace EMUL records and the baggage
for generating and parsing them.

ok mpi@@ naddy@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.86 2015/12/06 17:50:21 deraadt Exp $	*/
d431 1
a431 1
		VOP_UNLOCK(vp, 0, p);
@


1.86
log
@Change kernel internal pledge variables to 64bit (to prepare for more
extensions).  This change is exposed in ktrace.out files
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.85 2015/12/05 10:11:53 tedu Exp $	*/
a57 1
void	ktremulraw(struct proc *, struct process *, pid_t);
d162 1
a162 1
	if (code == SYS_sysctl && (p->p_p->ps_emul->e_flags & EMUL_NATIVE)) {
d164 1
a164 1
		 * The native sysctl encoding stores the mib[]
a220 23
ktremulraw(struct proc *curp, struct process *pr, pid_t tid)
{
	struct ktr_header kth;
	char *emul = pr->ps_emul->e_name;
	struct iovec data[2];

	ktrinitheaderraw(&kth, KTR_EMUL, pr->ps_pid, tid);
	data[0].iov_base = emul;
	data[0].iov_len = strlen(emul);
	data[1].iov_len = 0;
	kth.ktr_len = data[0].iov_len;
	ktrwriteraw(curp, pr->ps_tracevp, pr->ps_tracecred, &kth, data);
}

void
ktremul(struct proc *p)
{
	atomic_setbits_int(&p->p_flag, P_INKTR);
	ktremulraw(p, p->p_p, p->p_pid + THREAD_PID_OFFSET);
	atomic_clearbits_int(&p->p_flag, P_INKTR);
}

void
a519 7

	/*
	 * Emit an emulation record every time there is a ktrace
	 * change/attach request.
	 */
	if (pr->ps_traceflag & KTRFAC_EMUL)
		ktremulraw(curp, pr, -1);
@


1.85
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.84 2015/11/11 02:57:48 deraadt Exp $	*/
d403 1
a403 1
ktrpledge(struct proc *p, int error, int code, int syscall)
@


1.84
log
@ktrace vnodes do not need to be opened with FREAD, as they are
only written to.  (Will keep an eye out for NFS surprises)
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.83 2015/11/02 16:31:55 semarie Exp $	*/
a422 1
/* ARGSUSED */
@


1.83
log
@move the pledgenote annotation from `struct proc' to `struct nameidata'

pledgenote is used for annotate the policy for a namei context. So make it
tracking the nameidata.

It is expected for the caller to explicitly define the policy. It is a kernel
bug to not do so.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.82 2015/10/28 11:16:23 deraadt Exp $	*/
d452 1
a452 1
		if ((error = vn_open(&nd, FREAD|FWRITE|O_NOFOLLOW, 0)) != 0)
d525 1
a525 1
		(void) vn_close(vp, FREAD|FWRITE, cred, p);
@


1.82
log
@Though sys_ktrace is not yet pledge allowed, prepare by setting
p_pledgenote as required.
XXX open question to guenther regarding FREAD to vnopen() / vnclose()
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.81 2015/10/25 20:39:54 deraadt Exp $	*/
a448 1
		p->p_pledgenote = PLEDGE_CPATH | PLEDGE_WPATH;
d451 1
@


1.81
log
@Fold "malloc" into "stdio" and -- recognizing that no program so far has
used less than "stdio" -- include all the "self" operations.  Instead of
different defines, use regular PLEDGE_* in the "p_pledgenote" variable
(which indicates the operation subtype a system call is performing).  Many
checks before easier to understand.  p_pledgenote can often be passed
directly to ktrace, so that kdump says:
 15565 test     CALL  pledge(0xa9a3f804c51,0)
 15565 test     STRU  pledge request="stdio"
 15565 test     RET   pledge 0
 15565 test     CALL  open(0xa9a3f804c57,0x2<O_RDWR>)
 15565 test     NAMI  "/tmp/testfile"
 15565 test     PLDG  open, "wpath", errno 1 Operation not permitted
with help from semarie, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.80 2015/10/09 01:10:27 deraadt Exp $	*/
d449 1
a449 1
		p->p_pledgenote = PLEDGE_CPATH;
@


1.80
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.79 2015/10/02 05:07:41 guenther Exp $	*/
d47 1
d402 16
d449 1
a449 1
		p->p_pledgenote = TMN_CPATH;
@


1.79
log
@Add ktracing of argv and envp to execve(2), with envp not traced by default

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.78 2015/09/13 17:08:03 guenther Exp $	*/
d432 1
a432 1
		p->p_tamenote = TMN_CPATH;
@


1.78
log
@Rename __sysctl syscall to just sysctl, as the userland wrapper is no longer
necessary

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.77 2015/09/07 15:38:45 guenther Exp $	*/
d364 36
@


1.77
log
@Delete ktracing of context switches: it's unused, and not particularly useful,
and doing VOP_WRITE() from inside tsleep/msleep makes the locking too
complicated, making it harder to move forward on MP changes.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.76 2015/08/22 20:18:49 deraadt Exp $	*/
d162 1
a162 1
	if (code == SYS___sysctl && (p->p_p->ps_emul->e_flags & EMUL_NATIVE)) {
@


1.76
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.75 2015/08/01 20:12:34 guenther Exp $	*/
a311 15
	atomic_clearbits_int(&p->p_flag, P_INKTR);
}

void
ktrcsw(struct proc *p, int out, int user)
{
	struct ktr_header kth;
	struct ktr_csw kc;

	atomic_setbits_int(&p->p_flag, P_INKTR);
	ktrinitheader(&kth, p, KTR_CSW);
	kc.out = out;
	kc.user = user;

	ktrwrite(p, &kth, &kc, sizeof(kc));
@


1.75
log
@Fix free() of uninitialized variable introduced in previous commit.
Eliminate the goto that I tripped on.

problem noted by Mark Latimer (mark.latimer (at) gmail.com)
ok miod@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.74 2015/07/19 04:45:25 guenther Exp $	*/
d387 1
a387 1
sys_ktrace(struct proc *curp, void *v, register_t *retval)
d410 2
a411 1
		cred = curp->p_ucred;
d413 1
a413 1
		    curp);
d418 1
a418 1
		VOP_UNLOCK(vp, 0, curp);
d430 1
a430 1
				if (ktrcanset(curp, pr))
d446 1
a446 1
		if (suser(curp, 0) == 0)
d448 1
a448 1
		ktrstart(curp, vp, cred);
d464 1
a464 1
				ret |= ktrsetchildren(curp, pr, ops, facs, vp,
d467 1
a467 1
				ret |= ktrops(curp, pr, ops, facs, vp, cred);
d479 1
a479 1
			ret |= ktrsetchildren(curp, pr, ops, facs, vp, cred);
d481 1
a481 1
			ret |= ktrops(curp, pr, ops, facs, vp, cred);
d487 1
a487 1
		(void) vn_close(vp, FREAD|FWRITE, cred, curp);
@


1.74
log
@Make KTR_SYSRET records variables variables sized, leaving out the
retval on error, including a long long retval on successful lseek(),
and including a register_t retval for other successes.  This fixes
lseek reporting on ILP32 archs.

While here, reworking internal kern_ktrace.c bits to be able to pass
two buffers to ktrwriteraw(), so we can avoid mallocing a buffer
in some cases and so that KTR_GENIO logs are split at PAGE_SIZE,
not PAGE_SIZE-sizeof(struct ktrgenio)

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.73 2014/12/29 05:29:27 miod Exp $	*/
d364 11
a374 15
	if (error)
		goto out;

	if (len > sizeof(stkbuf))
		memp = malloc(len, M_TEMP, M_WAITOK);
	else
		memp = stkbuf;
	error = copyin(addr, memp, len);
	if (error)
		goto out;

	ktrwrite2(p, &kth, &ktp, sizeof(ktp), memp, len);
out:
	if (memp != stkbuf)
		free(memp, M_TEMP, len);
@


1.73
log
@Explicitely include <uvm/uvm_extern.h> in order to build on variable page size
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.72 2014/12/16 18:30:04 tedu Exp $	*/
d62 3
a64 1
int	ktrwrite(struct proc *, struct ktr_header *, void *);
d66 1
a66 1
	    struct ktr_header *, void *);
d181 1
a181 2
	kth.ktr_len = len;
	ktrwrite(p, &kth, ktp);
d187 2
a188 1
ktrsysret(struct proc *p, register_t code, int error, register_t retval)
d192 1
d198 8
a205 5
	ktp.ktr_retval = error == 0 ? retval : 0;

	kth.ktr_len = sizeof(struct ktr_sysret);

	ktrwrite(p, &kth, &ktp);
d216 1
a216 3
	kth.ktr_len = strlen(path);

	ktrwrite(p, &kth, path);
d225 1
d228 5
a232 3
	kth.ktr_len = strlen(emul);

	ktrwriteraw(curp, pr->ps_tracevp, pr->ps_tracecred, &kth, emul);
d248 1
a248 1
	struct ktr_genio *ktp;
d251 1
a251 1
	int mlen, buflen;
d256 1
a256 1
	if (len > PAGE_SIZE - sizeof(struct ktr_genio))
d262 2
a263 7
	mlen = buflen;
	ktp = malloc(mlen, M_TEMP, M_WAITOK);
	ktp->ktr_fd = fd;
	ktp->ktr_rw = rw;

	cp = (caddr_t)((char *)ktp + sizeof (struct ktr_genio));
	buflen -= sizeof(struct ktr_genio);
d265 1
d280 1
a280 3
		kth.ktr_len = count + sizeof(struct ktr_genio);

		if (ktrwrite(p, &kth, ktp) != 0)
d292 1
a292 1
	free(ktp, M_TEMP, mlen);
a309 1
	kth.ktr_len = sizeof(struct ktr_psig);
d311 1
a311 1
	ktrwrite(p, &kth, &kp);
d319 1
a319 1
	struct	ktr_csw kc;
a324 1
	kth.ktr_len = sizeof(struct ktr_csw);
d326 1
a326 1
	ktrwrite(p, &kth, &kc);
a333 2
	void *buf;
	size_t buflen;
d341 1
a341 8
	buflen = strlen(name) + 1 + datalen;
	buf = malloc(buflen, M_TEMP, M_WAITOK);
	strlcpy(buf, name, buflen);
	memcpy(buf + strlen(name) + 1, data, datalen);
	kth.ktr_len = buflen;

	ktrwrite(p, &kth, buf);
	free(buf, M_TEMP, buflen);
d349 1
a349 1
	struct ktr_user *ktp;
a351 1
	size_t size;
d358 1
a358 1
		return EINVAL;
d362 2
a363 9
	size = sizeof(*ktp) + len;
	memp = NULL;
	if (size > sizeof(stkbuf)) {
		memp = malloc(sizeof(*ktp) + len, M_TEMP, M_WAITOK);
		ktp = (struct ktr_user *)memp;
	} else
		ktp = (struct ktr_user *)stkbuf;
	memset(ktp->ktr_id, 0, KTR_USER_MAXIDLEN);
	error = copyinstr(id, ktp->ktr_id, KTR_USER_MAXIDLEN, NULL);
d365 1
a365 1
	    goto out;
d367 5
a371 1
	error = copyin(addr, (void *)(ktp + 1), len);
d374 2
a375 2
	kth.ktr_len = sizeof(*ktp) + len;
	ktrwrite(p, &kth, ktp);
d377 2
a378 2
	if (memp != NULL)
		free(memp, M_TEMP, sizeof(*ktp) + len);
d552 22
a573 1
ktrwrite(struct proc *p, struct ktr_header *kth, void *aux)
d577 1
d583 6
a588 1
	error = ktrwriteraw(p, vp, cred, kth, aux);
d595 1
a595 1
    struct ktr_header *kth, void *aux)
d598 1
a598 1
	struct iovec aiov[2];
d612 2
d615 2
a616 2
		aiov[1].iov_base = aux;
		aiov[1].iov_len = kth->ktr_len;
@


1.72
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.71 2014/12/10 02:44:47 tedu Exp $	*/
d51 2
@


1.71
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.70 2014/10/26 20:34:37 guenther Exp $	*/
d42 1
@


1.70
log
@Now that threads hold their own reference to their ucreds, sys_ktrace()
doesn't need to hold an extra reference during the call

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.69 2014/07/13 15:46:21 uebayasi Exp $	*/
d135 1
a135 1
	bcopy(p->p_comm, kth->ktr_comm, MAXCOMLEN);
d344 1
a344 1
	bcopy(data, buf + strlen(name) + 1, datalen);
@


1.69
log
@KERNEL_ASSERT_LOCKED(9): Assertion for kernel lock (Rev. 3)

This adds a new assertion macro, KERNEL_ASSERT_LOCKED(), to assert that
kernel_lock is held.  In the long process of removing kernel_lock, there will
be a lot (hundreds or thousands) of use of this; virtually almost all functions
in !MP-safe subsystems should have this assertion.  Thus this assertion should
have a short, good name.

Not only that "KERNEL_ASSERT_LOCKED" is consistent with other KERNEL_* and
SCHED_ASSERT_LOCKED() macros.

Input from dlg@@ guenther@@ kettenis@@.

OK dlg@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a425 1
		crhold(cred);
a501 2
	if (cred != NULL)
		crfree(cred);
@


1.68
log
@pass the size to free in some of the obvious cases
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.67 2014/07/12 18:43:32 tedu Exp $	*/
d335 1
a335 3
#ifdef MULTIPROCESSOR
	KASSERT(__mp_lock_held(&kernel_lock) > 0);
#endif
@


1.67
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.66 2014/07/08 17:19:25 deraadt Exp $	*/
d178 1
a178 1
	free(ktp, M_TEMP, 0);
d241 1
a241 1
	int buflen;
d252 2
a253 1
	ktp = malloc(buflen, M_TEMP, M_WAITOK);
d288 1
a288 1
	free(ktp, M_TEMP, 0);
d350 1
a350 1
	free(buf, M_TEMP, 0);
d391 1
a391 1
		free(memp, M_TEMP, 0);
@


1.66
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.65 2014/03/30 21:54:48 guenther Exp $	*/
d178 1
a178 1
	free(ktp, M_TEMP);
d287 1
a287 1
	free(ktp, M_TEMP);
d349 1
a349 1
	free(buf, M_TEMP);
d390 1
a390 1
		free(memp, M_TEMP);
@


1.65
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.64 2014/03/26 05:23:42 guenther Exp $	*/
a49 2

#include <uvm/uvm_extern.h>
@


1.64
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.63 2014/01/21 01:48:44 tedu Exp $	*/
d638 2
a639 2
	struct pcred *caller = callp->p_cred;
	struct pcred *target = targetpr->ps_cred;
d641 4
a644 4
	if ((caller->pc_ucred->cr_uid == target->p_ruid &&
	    target->p_ruid == target->p_svuid &&
	    caller->p_rgid == target->p_rgid &&	/* XXX */
	    target->p_rgid == target->p_svgid &&
d647 1
a647 1
	    caller->pc_ucred->cr_uid == 0)
@


1.63
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.62 2014/01/20 21:19:28 guenther Exp $	*/
d53 1
d56 1
d123 1
a123 1
ktrinitheader(struct ktr_header *kth, struct proc *p, int type)
d128 9
a136 2
	kth->ktr_pid = p->p_p->ps_pid;
	kth->ktr_tid = p->p_pid + THREAD_PID_OFFSET;
d145 1
a145 6
	memset(&kth, 0, sizeof(kth));
	kth.ktr_type = htobe32(KTR_START);
	nanotime(&kth.ktr_time);
	kth.ktr_pid = (pid_t)-1;
	kth.ktr_tid = (pid_t)-1;
	atomic_setbits_int(&p->p_flag, P_INKTR);
a146 1
	atomic_clearbits_int(&p->p_flag, P_INKTR);
d159 1
a159 1
	if (code == SYS___sysctl && (p->p_emul->e_flags & EMUL_NATIVE)) {
d176 1
a176 3
	if (code == SYS___sysctl && (p->p_emul->e_flags & EMUL_NATIVE) &&
	    nargs &&
	    copyin((void *)args[0], argp, nargs * sizeof(int)))
d216 1
a216 1
ktremul(struct proc *p, char *emul)
d219 1
d221 1
a221 2
	atomic_setbits_int(&p->p_flag, P_INKTR);
	ktrinitheader(&kth, p, KTR_EMUL);
d224 8
a231 1
	ktrwrite(p, &kth, emul);
a423 1
	atomic_setbits_int(&curp->p_flag, P_INKTR);
a507 1
	atomic_clearbits_int(&curp->p_flag, P_INKTR);
a514 2
	struct proc *p;

d529 2
a530 5
	 * Emit an emulation record, every time there is a ktrace
	 * change/attach request. 
	 * XXX an EMUL record for each thread?  Perhaps should have
	 * XXX a record type to say "this pid is really a thread of this
	 * XXX other pid" and only generate an EMUL record for the main pid
d532 2
a533 3
	TAILQ_FOREACH(p, &pr->ps_threads, p_thr_link)
		if (KTRPOINT(p, KTR_EMUL))
			ktremul(p, p->p_emul->e_name);
d584 1
a584 1
ktrwriteraw(struct proc *p, struct vnode *vp, struct ucred *cred,
d600 1
a600 1
	auio.uio_procp = p;
d607 1
a607 1
	vget(vp, LK_EXCLUSIVE | LK_RETRY, p);
@


1.62
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.61 2013/09/14 02:28:01 guenther Exp $	*/
d123 1
a123 1
	bzero(kth, sizeof (struct ktr_header));
d136 1
a136 1
	bzero(&kth, sizeof (kth));
d176 1
a176 1
		bzero(argp, nargs * sizeof(int));
d372 1
a372 1
	bzero(ktp->ktr_id, KTR_USER_MAXIDLEN);
@


1.61
log
@Correct the handling of I/O of >=2^32 bytes and the ktracing there of
by using size_t/ssize_t instead of int/u_int to handle I/O lengths in
uiomove(), vn_fsizechk(), and ktrgenio().  Eliminate the always-zero
'error' argument to ktrgenio() at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.60 2013/06/01 16:27:37 tedu Exp $	*/
a405 1
	struct proc *p = NULL;
d439 4
a442 4
		LIST_FOREACH(p, &allproc, p_list) {
			if (p->p_p->ps_tracevp == vp) {
				if (ktrcanset(curp, p->p_p))
					ktrcleartrace(p->p_p);
d589 1
d618 3
a620 3
	LIST_FOREACH(p, &allproc, p_list)
		if (p->p_p->ps_tracevp == vp && p->p_p->ps_tracecred == cred)
			ktrcleartrace(p->p_p);
@


1.60
log
@always implement stub utrace syscall, but keep the body #ifdef KTRACE
ok guenther matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.59 2013/06/01 09:49:50 miod Exp $	*/
d162 1
a162 1
			nargs = min(args[1], CTL_MAXNAME);
d228 2
a229 2
ktrgenio(struct proc *p, int fd, enum uio_rw rw, struct iovec *iov, int len,
    int error)
d234 1
a234 1
	int resid = len, count;
a236 3
	if (error)
		return;

d239 5
a243 1
	buflen = min(PAGE_SIZE, len + sizeof(struct ktr_genio));
d253 1
a253 1
	while (resid > 0) {
d261 3
a263 3
		count = min(iov->iov_len, buflen);
		if (count > resid)
			count = resid;
d278 1
a278 1
		resid -= count;
@


1.59
log
@Add utrace(2), a system call allowing for userland to send its own ktrace
records. From FreeBSD via otto@@, with tweaks suggested by guenther@@.
Commite on behalf of otto@@ who is not around, to ride the libc minor bump.
Causes a librthread minor bump as well (new syscall).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.58 2012/04/10 20:39:37 mikeb Exp $	*/
a649 16
}

/*
 * utrace system call
 */
/* ARGSUSED */
int
sys_utrace(struct proc *curp, void *v, register_t *retval)
{
	struct sys_utrace_args /* {
		syscallarg(const char *) label;
		syscallarg(const void *) addr;
		syscallarg(size_t) len;
	} */ *uap = v;
	return (ktruser(curp, SCARG(uap, label), SCARG(uap, addr),
	    SCARG(uap, len)));
@


1.58
log
@Add a start record to the ktrace and use a special magic string "KTR"
to identify ktrace files.  kdump(1) will now refuse to operate on
trace data without the start record and as a bonus will print only
PID, unless an -H flag is specified to print PID/TID pairs.  Initial
diff, input from and ok deraadt, guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.57 2012/03/19 09:05:39 guenther Exp $	*/
a34 2
#ifdef KTRACE

d346 43
d652 15
a666 1
#endif
@


1.57
log
@Add tracing and dumping of "pointer to struct" syscall arguments for
structs timespec, timeval, sigaction, and rlimit.

ok otto@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.56 2011/12/14 07:32:16 guenther Exp $	*/
d56 1
d61 3
a63 1
int	ktrwrite(struct proc *, struct ktr_header *);
d127 19
a145 3
	microtime(&kth->ktr_time);
	kth->ktr_pid = p->p_pid;
	bcopy(p->p_comm, kth->ktr_comm, MAXCOMLEN);	
a178 1
	kth.ktr_buf = (caddr_t)ktp;
d180 1
a180 1
	ktrwrite(p, &kth);
a196 1
	kth.ktr_buf = (caddr_t)&ktp;
d199 1
a199 1
	ktrwrite(p, &kth);
a210 1
	kth.ktr_buf = path;
d212 1
a212 1
	ktrwrite(p, &kth);
a223 1
	kth.ktr_buf = emul;
d225 1
a225 1
	ktrwrite(p, &kth);
a250 2
	kth.ktr_buf = (caddr_t)ktp;

d270 1
a270 1
		if (ktrwrite(p, &kth) != 0)
a283 1
	
a299 1
	kth.ktr_buf = (caddr_t)&kp;
d302 1
a302 1
	ktrwrite(p, &kth);
a315 1
	kth.ktr_buf = (caddr_t)&kc;
d318 1
a318 1
	ktrwrite(p, &kth);
a340 1
	kth.ktr_buf = buf;
d343 1
a343 1
	ktrwrite(p, &kth);
d415 6
a420 3
	if (ops == KTROP_SET && suser(curp, 0) == 0)
		facs |= KTRFAC_ROOT;
	/* 
d436 1
a436 1
			else 
a438 1
					
d528 1
a528 1
ktrwrite(struct proc *p, struct ktr_header *kth)
a529 3
	struct uio auio;
	struct iovec aiov[2];
	int error;
d532 1
d536 14
d561 1
a561 1
		aiov[1].iov_base = kth->ktr_buf;
a564 1
	crhold(cred);
a566 1
	crfree(cred);
d577 1
a577 1
		if (p->p_p->ps_tracevp == vp)
@


1.56
log
@Handle rthreads consistently in ktrace by moving the flags and vnode into
struct process; KTRFAC_ACTIVE becomes P_INKTR.  Also, save the credentials
used to open the file in sys_ktrace() and use them for all writes to the
vnode.

much feedback and ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.55 2011/11/21 03:01:20 djm Exp $	*/
d319 3
@


1.55
log
@fix small (one stack word) kmem->user leak - the syscall code does
not zero retval when returning an error, so don't copy it back to a
ktracer in this case.

dropped by R00T-DUDE in his "Unusual and Hilarious Vulnerabilities" talk
at Ruxcon 2011; ok guenther@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.54 2011/07/11 15:40:47 guenther Exp $	*/
d55 7
a61 6
void ktrinitheader(struct ktr_header *, struct proc *, int);
int ktrops(struct proc *, struct proc *, int, int, struct vnode *);
int ktrsetchildren(struct proc *, struct process *, int, int,
			struct vnode *);
int ktrwrite(struct proc *, struct ktr_header *);
int ktrcanset(struct proc *, struct proc *);
d64 1
a64 1
 * Change the trace vnode in a correct way (to avoid races).
d67 1
a67 1
ktrsettracevnode(struct proc *p, struct vnode *newvp)
d70 1
d72 34
a105 2
	if (p->p_tracep == newvp)	/* avoid work */
		return;
d107 2
a108 2
	if (newvp != NULL)
		vref(newvp);
d110 2
a111 2
	vp = p->p_tracep;
	p->p_tracep = newvp;
d113 4
a116 2
	if (vp != NULL)
		vrele(vp);
d148 1
a148 1
	p->p_traceflag |= KTRFAC_ACTIVE;
d164 1
a164 1
	p->p_traceflag &= ~KTRFAC_ACTIVE;
d173 1
a173 1
	p->p_traceflag |= KTRFAC_ACTIVE;
d183 1
a183 1
	p->p_traceflag &= ~KTRFAC_ACTIVE;
d191 1
a191 1
	p->p_traceflag |= KTRFAC_ACTIVE;
d197 1
a197 1
	p->p_traceflag &= ~KTRFAC_ACTIVE;
d205 1
a205 1
	p->p_traceflag |= KTRFAC_ACTIVE;
d211 1
a211 1
	p->p_traceflag &= ~KTRFAC_ACTIVE;
d227 1
a227 1
	p->p_traceflag |= KTRFAC_ACTIVE;
d270 1
a270 1
	p->p_traceflag &= ~KTRFAC_ACTIVE;
d281 1
a281 1
	p->p_traceflag |= KTRFAC_ACTIVE;
d292 1
a292 1
	p->p_traceflag &= ~KTRFAC_ACTIVE;
d301 1
a301 1
	p->p_traceflag |= KTRFAC_ACTIVE;
d309 1
a309 1
	p->p_traceflag &= ~KTRFAC_ACTIVE;
d319 1
a319 1
	p->p_traceflag |= KTRFAC_ACTIVE;
d333 1
a333 1
	p->p_traceflag &= ~KTRFAC_ACTIVE;
d354 1
d363 1
a363 1
	curp->p_traceflag |= KTRFAC_ACTIVE;
d368 2
d372 2
a373 4
		if ((error = vn_open(&nd, FREAD|FWRITE|O_NOFOLLOW, 0)) != 0) {
			curp->p_traceflag &= ~KTRFAC_ACTIVE;
			return (error);
		}
d378 2
a379 3
			(void) vn_close(vp, FREAD|FWRITE, curp->p_ucred, curp);
			curp->p_traceflag &= ~KTRFAC_ACTIVE;
			return (EACCES);
d387 4
a390 5
			if (p->p_tracep == vp) {
				if (ktrcanset(curp, p)) {
					p->p_traceflag = 0;
					ktrsettracevnode(p, NULL);
				} else
d403 2
d419 2
a420 1
				ret |= ktrsetchildren(curp, pr, ops, facs, vp);
d422 1
a422 2
				TAILQ_FOREACH(p, &pr->ps_threads, p_thr_link)
					ret |= ktrops(curp, p, ops, facs, vp);
d435 1
a435 1
			ret |= ktrsetchildren(curp, pr, ops, facs, vp);
d437 1
a437 3
			TAILQ_FOREACH(p, &pr->ps_threads, p_thr_link) {
				ret |= ktrops(curp, p, ops, facs, vp);
		}
d443 4
a446 2
		(void) vn_close(vp, FWRITE, curp->p_ucred, curp);
	curp->p_traceflag &= ~KTRFAC_ACTIVE;
d451 2
a452 1
ktrops(struct proc *curp, struct proc *p, int ops, int facs, struct vnode *vp)
d454 1
d456 1
a456 1
	if (!ktrcanset(curp, p))
d458 3
a460 6
	if (ops == KTROP_SET) {
		ktrsettracevnode(p, vp);
		p->p_traceflag |= facs;
		if (suser(curp, 0) == 0)
			p->p_traceflag |= KTRFAC_ROOT;
	} else {	
d462 4
a465 4
		if (((p->p_traceflag &= ~facs) & KTRFAC_MASK) == 0) {
			/* no more tracing */
			p->p_traceflag = 0;
			ktrsettracevnode(p, NULL);
d472 3
d476 3
a478 2
	if (KTRPOINT(p, KTR_EMUL))
		ktremul(p, p->p_emul->e_name);
d485 1
a485 1
    struct vnode *vp)
a487 1
	struct proc *p;
d492 1
a492 2
		TAILQ_FOREACH(p, &pr->ps_threads, p_thr_link)
			ret |= ktrops(curp, p, ops, facs, vp);
d519 2
a520 1
	struct vnode *vp = p->p_tracep;
d539 1
d541 2
a542 1
	error = VOP_WRITE(vp, &auio, IO_UNIT|IO_APPEND, p->p_ucred);
d552 3
a554 6
	LIST_FOREACH(p, &allproc, p_list) {
		if (p->p_tracep == vp) {
			p->p_traceflag = 0;
			ktrsettracevnode(p, NULL);
		}
	}
d570 1
a570 1
ktrcanset(struct proc *callp, struct proc *targetp)
d573 1
a573 1
	struct pcred *target = targetp->p_cred;
d579 2
a580 2
	    (targetp->p_traceflag & KTRFAC_ROOT) == 0 &&
	    !ISSET(targetp->p_p->ps_flags, PS_SUGID)) ||
@


1.54
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.51 2011/06/02 16:29:20 deraadt Exp $	*/
d141 1
a141 1
	ktp.ktr_retval = retval;
@


1.53
log
@Support sending struct info to kdump. So far for struct stat and
struct sockaddress; mostly from freebsd. ok deraadt@@ tedu@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.52 2011/07/07 18:11:24 art Exp $	*/
a102 1
	KERNEL_LOCK();
a128 1
	KERNEL_UNLOCK();
a136 2
	KERNEL_LOCK();

a147 1
	KERNEL_UNLOCK();
@


1.52
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.51 2011/06/02 16:29:20 deraadt Exp $	*/
d278 24
@


1.51
log
@We will ignore retval2; it is not an issue
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.50 2011/04/02 17:04:35 guenther Exp $	*/
d103 1
d130 1
d139 2
d152 1
@


1.50
log
@Move P_SUGID and P_SUGIDEXEC from struct proc to struct process, so
that you can't evade the checks by doing the dirty work in an rthread

ok blambert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.49 2010/07/26 01:56:27 guenther Exp $	*/
d141 1
a141 1
	ktp.ktr_retval = retval;		/* what about val2 ? */
@


1.49
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.48 2009/10/31 12:00:08 fgsch Exp $	*/
d518 1
a518 1
	    !ISSET(targetp->p_flag, P_SUGID)) ||
@


1.48
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.47 2009/07/09 22:29:56 thib Exp $	*/
d57 1
a57 1
int ktrsetchildren(struct proc *, struct proc *, int, int,
d293 1
d356 1
a356 1
		LIST_FOREACH(p, &pg->pg_members, p_pglist)
d358 1
a358 1
				ret |= ktrsetchildren(curp, p, ops, facs, vp);
d360 3
a362 1
				ret |= ktrops(curp, p, ops, facs, vp);
d368 2
a369 2
		p = pfind(SCARG(uap, pid));
		if (p == NULL) {
d374 1
a374 1
			ret |= ktrsetchildren(curp, p, ops, facs, vp);
d376 3
a378 1
			ret |= ktrops(curp, p, ops, facs, vp);
d420 1
a420 1
ktrsetchildren(struct proc *curp, struct proc *top, int ops, int facs,
d423 1
d427 1
a427 1
	p = top;
d429 2
a430 1
		ret |= ktrops(curp, p, ops, facs, vp);
d436 2
a437 2
		if (!LIST_EMPTY(&p->p_children))
			p = LIST_FIRST(&p->p_children);
d439 1
a439 1
			if (p == top)
d441 2
a442 2
			if (LIST_NEXT(p, p_sibling) != NULL) {
				p = LIST_NEXT(p, p_sibling);
d445 1
a445 1
			p = p->p_pptr;
@


1.47
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.45 2008/10/31 17:17:02 deraadt Exp $	*/
d393 1
a393 1
		if (curp->p_ucred->cr_uid == 0)
@


1.46
log
@Grab a reference to the trace vnode of the process when traversing the
global process list and calling ktrsettracevnode() in ktrwrite(), so
that we don't sleep in vrele(). Discussed with deraadt@@, okay beck@@,
tedu@@ and thib@@.
@
text
@d74 1
a74 1
		VREF(newvp);
@


1.45
log
@accidental commit ... backout
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.43 2008/05/22 17:04:59 thib Exp $	*/
d469 1
a469 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d471 4
a474 3
	VOP_UNLOCK(vp, 0, p);
	if (!error)
		return 0;
d487 2
a488 1
	return error;
@


1.44
log
@kern_sysctl.c
@
text
@d56 1
a56 1
int ktrops(struct proc *, struct proc *, int, int, struct vnode *, int *);
d58 1
a58 1
			struct vnode *, int *);
a63 1
 * Returns 1 if a vrele() should be done later.
d65 1
a65 1
int
d71 1
a71 1
		return (0);
d80 1
a80 2
		return (1);	/* caller must do a vrele() after */
	return (0);
d297 1
a297 1
	int ret = 0, nvrele = 0;
d329 1
a329 1
					nvrele += ktrsettracevnode(p, NULL);
d357 1
a357 2
				ret |= ktrsetchildren(curp, p, ops, facs, vp,
				    &nvrele);
d359 2
a360 1
				ret |= ktrops(curp, p, ops, facs, vp, &nvrele);
d371 1
a371 1
			ret |= ktrsetchildren(curp, p, ops, facs, vp, &nvrele);
d373 1
a373 1
			ret |= ktrops(curp, p, ops, facs, vp, &nvrele);
d378 1
a378 3
	if (vp != NULL) {
		while (nvrele--)
			vrele(vp);
a379 1
	}
d385 1
a385 2
ktrops(struct proc *curp, struct proc *p, int ops, int facs, struct vnode *vp,
    int *vrelep)
d387 1
d391 1
a391 1
		*vrelep += ktrsettracevnode(p, vp);
d400 1
a400 1
			*vrelep += ktrsettracevnode(p, NULL);
d416 1
a416 1
    struct vnode *vp, int *vrelep)
d423 1
a423 1
		ret |= ktrops(curp, p, ops, facs, vp, vrelep);
d449 1
a449 1
	int error, nvrele = 0;
d482 1
a482 1
			nvrele += ktrsettracevnode(p, NULL);
a484 2
	while (nvrele--)
		vrele(vp);
@


1.43
log
@Use LIST_FOREACH() instead of handrolling.

From: Pierre Riteau pierre.riteau_att_gmail.com
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.42 2007/05/16 17:27:30 art Exp $	*/
d56 1
a56 1
int ktrops(struct proc *, struct proc *, int, int, struct vnode *);
d58 1
a58 1
			struct vnode *);
d64 1
d66 1
a66 1
void
d72 1
a72 1
		return;
d81 2
a82 1
		vrele(vp);
d299 1
a299 1
	int ret = 0;
d331 1
a331 1
					ktrsettracevnode(p, NULL);
d359 2
a360 1
				ret |= ktrsetchildren(curp, p, ops, facs, vp);
d362 1
a362 2
				ret |= ktrops(curp, p, ops, facs, vp);
					
d373 1
a373 1
			ret |= ktrsetchildren(curp, p, ops, facs, vp);
d375 1
a375 1
			ret |= ktrops(curp, p, ops, facs, vp);
d380 3
a382 1
	if (vp != NULL)
d384 1
d390 2
a391 1
ktrops(struct proc *curp, struct proc *p, int ops, int facs, struct vnode *vp)
a392 1

d396 1
a396 1
		ktrsettracevnode(p, vp);
d405 1
a405 1
			ktrsettracevnode(p, NULL);
d421 1
a421 1
    struct vnode *vp)
d428 1
a428 1
		ret |= ktrops(curp, p, ops, facs, vp);
d454 1
a454 1
	int error;
d487 1
a487 1
			ktrsettracevnode(p, NULL);
d490 2
@


1.42
log
@The world of __HAVEs and __HAVE_NOTs is reducing. All architectures
have cpu_info now, so kill the option.

eyeballed by jsg@@ and grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.41 2006/11/14 09:16:55 deraadt Exp $	*/
d325 1
a325 1
		for (p = LIST_FIRST(&allproc); p; p = LIST_NEXT(p, p_list)) {
d479 1
a479 1
	for (p = LIST_FIRST(&allproc); p != NULL; p = LIST_NEXT(p, p_list)) {
@


1.41
log
@properly check for native emulation binaries, so that the correct sysctl
mib numbers are appended to the syscall record; broken by niklas in 1.39
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.40 2006/05/17 02:11:25 tedu Exp $	*/
a209 1
#ifdef __HAVE_CPUINFO
a210 3
#else
		if (p->p_schedflags & PSCHED_SHOULDYIELD)
#endif
@


1.40
log
@change ktr_len to size_t.  put ktr_type after comm for better alignment
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.39 2006/02/27 00:34:33 niklas Exp $	*/
a101 1
	extern struct emul emul_native;
d103 5
a107 1
	if (p->p_emul == &emul_native && code == SYS___sysctl) {
d120 2
a121 1
	if (p->p_emul == &emul_native && code == SYS___sysctl && nargs &&
@


1.39
log
@When checking syscall numbers, qualify the test with the emulation as well.
fixes potential panics on emulated binaries. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.38 2005/11/28 00:14:28 jsg Exp $	*/
d98 1
a98 1
	unsigned int len = sizeof(struct ktr_syscall) + argsize;
d253 1
a253 1
	kth.ktr_len = sizeof (struct ktr_psig);
d270 1
a270 1
	kth.ktr_len = sizeof (struct ktr_csw);
@


1.38
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.37 2005/11/15 23:05:37 pedro Exp $	*/
d102 1
d104 1
a104 1
	if (code == SYS___sysctl) {
d117 1
a117 1
	if (code == SYS___sysctl && nargs &&
@


1.37
log
@Save process context in ktrwrite(), as it may be needed for locking
purposes by the file system specific write routine. Fixes PR 4612.
Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.36 2005/09/10 21:05:27 deraadt Exp $	*/
d66 1
a66 3
ktrsettracevnode(p, newvp)
	struct proc *p;
	struct vnode *newvp;
d84 1
a84 4
ktrinitheader(kth, p, type)
	struct ktr_header *kth;
	struct proc *p;
	int type;
d94 1
a94 5
ktrsyscall(p, code, argsize, args)
	struct proc *p;
	register_t code;
	size_t argsize;
	register_t args[];
d127 1
a127 5
ktrsysret(p, code, error, retval)
	struct proc *p;
	register_t code;
	int error;
	register_t retval;
d146 1
a146 3
ktrnamei(p, path)
	struct proc *p;
	char *path;
d160 1
a160 3
ktremul(p, emul)
	struct proc *p;
	char *emul;
d174 2
a175 6
ktrgenio(p, fd, rw, iov, len, error)
	struct proc *p;
	int fd;
	enum uio_rw rw;
	struct iovec *iov;
	int len, error;
d238 2
a239 6
ktrpsig(p, sig, action, mask, code, si)
	struct proc *p;
	int sig;
	sig_t action;
	int mask, code;
	siginfo_t *si;
d259 1
a259 3
ktrcsw(p, out, user)
	struct proc *p;
	int out, user;
d282 1
a282 4
sys_ktrace(curp, v, retval)
	struct proc *curp;
	void *v;
	register_t *retval;
d384 1
a384 4
ktrops(curp, p, ops, facs, vp)
	struct proc *p, *curp;
	int ops, facs;
	struct vnode *vp;
d414 2
a415 4
ktrsetchildren(curp, top, ops, facs, vp)
	struct proc *curp, *top;
	int ops, facs;
	struct vnode *vp;
d444 1
a444 3
ktrwrite(p, kth)
	struct proc *p;
	struct ktr_header *kth;
d498 1
a498 2
ktrcanset(callp, targetp)
	struct proc *callp, *targetp;
@


1.36
log
@do not trust user input for sysctl.  constrain arguments passed to ktrace
to CTL_MAXNAME; ok espie uwe
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.35 2005/06/02 17:32:02 mickey Exp $	*/
d498 1
a498 1
	auio.uio_procp = (struct proc *)0;
@


1.35
log
@for sysctl syscall pass the mib[] back to kdump to parse;
always print () on syscalls w/ void args even (deraadt version)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.34 2004/12/26 21:22:13 miod Exp $	*/
d47 1
d109 1
d112 5
a116 2
	if (code == SYS___sysctl)
		len += args[1] * sizeof(int);
d125 3
a127 3
	if (code == SYS___sysctl &&
	    copyin((void *)args[0], argp, args[1] * sizeof(int)))
		bzero(argp, args[1] * sizeof(int));
@


1.34
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.33 2004/06/13 21:49:26 niklas Exp $	*/
d49 1
d110 2
d120 3
@


1.33
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d373 1
a373 1
		for (p = pg->pg_members.lh_first; p != 0; p = p->p_pglist.le_next)
d452 2
a453 2
		if (p->p_children.lh_first)
			p = p->p_children.lh_first;
d457 2
a458 2
			if (p->p_sibling.le_next) {
				p = p->p_sibling.le_next;
@


1.32
log
@Merge in a piece of the SMP branch into HEAD.

Introduce the cpu_info structure, p_cpu field in struct proc and global
scheduling context and various changed code to deal with this. At the
moment no architecture uses this stuff yet, but it will allow us slow and
controlled migration to the new APIs.

All new code is ifdef:ed out.

ok deraadt@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.31 2003/09/01 18:06:03 henning Exp $	*/
d40 1
@


1.31
log
@match syscallargs comments with reality
from Patrick Latifi <patrick.l@@hermes.usherb.ca>
ok jason@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.30 2003/06/02 23:28:05 millert Exp $	*/
d214 3
d218 1
@


1.30
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.29 2002/06/27 02:15:52 deraadt Exp $	*/
d299 1
a299 1
		syscallarg(char *) fname;
@


1.29
log
@do not permit ktrace on P_SUGID; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.28 2002/06/06 15:41:46 mpech Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.28
log
@Fix *documentation*: one arg of the ktrace(2) is pid_t not int, found while
have fun w/ pid_t cleanups.

millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.27 2002/03/14 01:27:04 millert Exp $	*/
d533 2
a534 1
	    (targetp->p_traceflag & KTRFAC_ROOT) == 0) ||
@


1.27
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.26 2002/02/22 19:19:28 deraadt Exp $	*/
d306 1
a306 1
		syscallarg(int) pid;
@


1.27.2.1
log
@pull in patch from current:
Fix (deraadt):
do not permit ktrace on P_SUGID; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.27 2002/03/14 01:27:04 millert Exp $	*/
d533 1
a533 2
	    (targetp->p_traceflag & KTRFAC_ROOT) == 0 &&
	    !ISSET(targetp->p_flag, P_SUGID)) ||
@


1.26
log
@include a siginfo_t with ktrace PSIG information, so that kdump can print
fault addresses and other information. (a small bug exists: in some signal
delivery cases, two PSIG records may be inserted, because postsig() is
unaware a PSIG record has already been placed.  but this small bug can
stay since the siginfo_t information helps us find and fix other bugs)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.25 2001/11/06 19:53:20 miod Exp $	*/
d56 6
a61 6
void ktrinitheader __P((struct ktr_header *, struct proc *, int));
int ktrops __P((struct proc *, struct proc *, int, int, struct vnode *));
int ktrsetchildren __P((struct proc *, struct proc *, int, int,
			struct vnode *));
int ktrwrite __P((struct proc *, struct ktr_header *));
int ktrcanset __P((struct proc *, struct proc *));
@


1.25
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.24 2001/06/26 06:27:38 aaron Exp $	*/
d247 1
a247 1
ktrpsig(p, sig, action, mask, code)
d252 1
d255 1
a255 1
	struct ktr_psig	kp;
d263 1
@


1.25.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.25 2001/11/06 19:53:20 miod Exp $	*/
d56 6
a61 6
void ktrinitheader(struct ktr_header *, struct proc *, int);
int ktrops(struct proc *, struct proc *, int, int, struct vnode *);
int ktrsetchildren(struct proc *, struct proc *, int, int,
			struct vnode *);
int ktrwrite(struct proc *, struct ktr_header *);
int ktrcanset(struct proc *, struct proc *);
d247 1
a247 1
ktrpsig(p, sig, action, mask, code, si)
a251 1
	siginfo_t *si;
d254 1
a254 1
	struct ktr_psig kp;
a261 1
	kp.si = *si;
d304 1
a304 1
		syscallarg(pid_t) pid;
@


1.25.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.25.2.1 2002/06/11 03:29:40 art Exp $	*/
d533 1
a533 2
	    (targetp->p_traceflag & KTRFAC_ROOT) == 0 &&
	    !ISSET(targetp->p_flag, P_SUGID)) ||
@


1.24
log
@Appease gcc by not using void pointers in arithmetic operations; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.23 2001/06/22 14:14:08 deraadt Exp $	*/
d54 1
a54 1
#include <vm/vm.h>
@


1.24.2.1
log
@Errata #026:
Do not permit ktrace on P_SUGID
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.29 2002/06/27 02:15:52 deraadt Exp $	*/
a55 2
#define ISSET(t, f)    ((t) & (f))

d531 1
a531 2
	    (targetp->p_traceflag & KTRFAC_ROOT) == 0 &&
	    !ISSET(targetp->p_flag, P_SUGID)) ||
@


1.23
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.22 2000/11/10 18:15:46 art Exp $	*/
d233 1
a233 1
		iov->iov_base += count;
d538 1
a538 1
#endif@


1.22
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.21 2000/09/27 16:13:46 mickey Exp $	*/
d528 5
a532 5
	     target->p_ruid == target->p_svuid &&
	     caller->p_rgid == target->p_rgid &&	/* XXX */
	     target->p_rgid == target->p_svgid &&
	     (targetp->p_traceflag & KTRFAC_ROOT) == 0) ||
	     caller->pc_ucred->cr_uid == 0)
@


1.21
log
@replace MALLOC/FREE w/ malloc/free for non-constant-sized memory allocations; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.20 2000/04/29 17:46:28 millert Exp $	*/
d60 1
a60 1
int ktrwrite __P((struct vnode *, struct ktr_header *));
d100 2
a101 2
ktrsyscall(vp, code, argsize, args)
	struct vnode *vp;
a108 1
	struct proc *p = curproc;	/* XXX */
d122 1
a122 1
	ktrwrite(vp, &kth);
d128 2
a129 2
ktrsysret(vp, code, error, retval)
	struct vnode *vp;
a135 1
	struct proc *p = curproc;	/* XXX */
d146 1
a146 1
	ktrwrite(vp, &kth);
d151 2
a152 2
ktrnamei(vp, path)
	struct vnode *vp;
a155 1
	struct proc *p = curproc;	/* XXX */
d162 1
a162 1
	ktrwrite(vp, &kth);
d167 2
a168 2
ktremul(vp, emul)
	struct vnode *vp;
a171 1
	struct proc *p = curproc;       /* XXX */
d178 1
a178 1
	ktrwrite(vp, &kth);
d183 2
a184 2
ktrgenio(vp, fd, rw, iov, len, error)
	struct vnode *vp;
a193 1
	struct proc *p = curproc;	/* XXX */
d229 1
a229 1
		if (ktrwrite(vp, &kth) != 0)
d247 2
a248 2
ktrpsig(vp, sig, action, mask, code)
	struct vnode *vp;
a254 1
	struct proc *p = curproc;	/* XXX */
d265 1
a265 1
	ktrwrite(vp, &kth);
d270 2
a271 2
ktrcsw(vp, out, user)
	struct vnode *vp;
a275 1
	struct proc *p = curproc;	/* XXX */
d284 1
a284 1
	ktrwrite(vp, &kth);
d427 1
a427 1
		ktremul(p->p_tracep, p->p_emul->e_name);
d465 2
a466 2
ktrwrite(vp, kth)
	struct vnode *vp;
a470 1
	struct proc *p = curproc;	/* XXX */
d472 1
d538 1
a538 1
#endif
@


1.20
log
@ktrace(2) should not follow symbolic links; from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.19 2000/04/21 07:39:15 deraadt Exp $	*/
d115 1
a115 1
	MALLOC(ktp, struct ktr_syscall *, len, M_TEMP, M_WAITOK);
d124 1
a124 1
	FREE(ktp, M_TEMP);
d209 1
a209 1
	MALLOC(ktp, struct ktr_genio *, buflen, M_TEMP, M_WAITOK);
d246 1
a246 1
	FREE(ktp, M_TEMP);
@


1.19
log
@do not declare and use a local variable which conflicts with a global
variable which is used by a macro when VM is used instead of UVM.  very
cute, Art -- 10 points for artistic expression.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.18 2000/04/20 10:03:42 art Exp $	*/
d330 1
a330 1
		if ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0) {
@


1.18
log
@Add a function "ktrsettracevnode", that changes the ktrace vnode for a process
in a correct way. Use it in all places where the vnode was changed.
(most of the earlier code was incorrect and had races).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.17 2000/04/19 10:56:41 art Exp $	*/
d197 1
a197 1
	int resid = len, cnt;
d226 4
a229 4
		cnt = min(iov->iov_len, buflen);
		if (cnt > resid)
			cnt = resid;
		if (copyin(iov->iov_base, cp, cnt))
d232 1
a232 1
		kth.ktr_len = cnt + sizeof(struct ktr_genio);
d237 2
a238 2
		iov->iov_len -= cnt;
		iov->iov_base += cnt;
d243 1
a243 1
		resid -= cnt;
@


1.17
log
@Unbreak genio (how could I commit that garbage?).

Let ktrwrite return an error if the write failed so that we won't loop in
genio writing to a full disk (or whatever other error happened).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.16 2000/04/19 10:13:22 art Exp $	*/
d63 23
a349 1
					p->p_tracep = NULL;
d351 1
a351 1
				        vrele(vp);
d416 1
a416 9
		if (p->p_tracep != vp) { 
			/*
			 * if trace file already in use, relinquish
			 */
			if (p->p_tracep != NULL)
				vrele(p->p_tracep);
			VREF(vp);
			p->p_tracep = vp;
		}
d425 1
a425 4
			if (p->p_tracep != NULL) {
				vrele(p->p_tracep);
				p->p_tracep = NULL;
			}
a509 1
			p->p_tracep = NULL;
d511 1
a511 1
			vrele(vp);
@


1.16
log
@When logging genio, check if we need to yield in the same way as in uiomove.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.15 2000/04/19 08:35:37 art Exp $	*/
d60 1
a60 1
void ktrwrite __P((struct vnode *, struct ktr_header *));
a190 1
	kth.ktr_len = buflen;
d193 1
a194 1
	buflen -= sizeof(struct ktr_genio);
d202 1
d204 2
d207 11
a217 3
			goto done;
		ktrwrite(vp, &kth);
		if ((iov->iov_len -= cnt) <= 0)
d219 2
d222 1
a222 1
done:
d460 1
a460 1
void
d471 1
a471 1
		return;
d491 1
a491 1
		return;
d504 2
@


1.15
log
@Don't abuse malloc to allocate small fixed-size structs that we can keep on the stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.14 2000/04/18 16:22:16 art Exp $	*/
d197 6
@


1.14
log
@If the user does a huge I/O split the genio logging into smaller chunks
to avoid allocating a huge buffer which could lead to kmem starvation.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.13 2000/04/06 13:25:26 art Exp $	*/
d56 1
a56 1
struct ktr_header *ktrgetheader __P((struct proc *, int));
d63 3
a65 2
struct ktr_header *
ktrgetheader(p, type)
a68 4
	struct ktr_header *kth;

	MALLOC(kth, struct ktr_header *, sizeof (struct ktr_header), 
		M_TEMP, M_WAITOK);
d73 1
a73 2
	bcopy(p->p_comm, kth->ktr_comm, MAXCOMLEN);
	return (kth);
d83 1
a83 1
	struct	ktr_header *kth;
d91 1
a91 1
	kth = ktrgetheader(p, KTR_SYSCALL);
d98 3
a100 3
	kth->ktr_buf = (caddr_t)ktp;
	kth->ktr_len = len;
	ktrwrite(vp, kth);
a101 1
	FREE(kth, M_TEMP);
d112 1
a112 1
	struct ktr_header *kth;
d117 1
a117 1
	kth = ktrgetheader(p, KTR_SYSRET);
d122 2
a123 2
	kth->ktr_buf = (caddr_t)&ktp;
	kth->ktr_len = sizeof(struct ktr_sysret);
d125 1
a125 2
	ktrwrite(vp, kth);
	FREE(kth, M_TEMP);
d134 1
a134 1
	struct ktr_header *kth;
d138 3
a140 3
	kth = ktrgetheader(p, KTR_NAMEI);
	kth->ktr_len = strlen(path);
	kth->ktr_buf = path;
d142 1
a142 2
	ktrwrite(vp, kth);
	FREE(kth, M_TEMP);
d151 1
a151 1
	struct ktr_header *kth;
d155 3
a157 3
	kth = ktrgetheader(p, KTR_EMUL);
	kth->ktr_len = strlen(emul);
	kth->ktr_buf = emul;
d159 1
a159 2
	ktrwrite(vp, kth);
	FREE(kth, M_TEMP);
d171 1
a171 1
	struct ktr_header *kth;
d185 1
a185 1
	kth = ktrgetheader(p, KTR_GENIO);
d189 3
a191 2
	kth->ktr_buf = (caddr_t)ktp;
	kth->ktr_len = buflen;
d200 1
a200 1
		ktrwrite(vp, kth);
a205 1
	FREE(kth, M_TEMP);
d217 1
a217 1
	struct ktr_header *kth;
d222 1
a222 1
	kth = ktrgetheader(p, KTR_PSIG);
d227 2
a228 2
	kth->ktr_buf = (caddr_t)&kp;
	kth->ktr_len = sizeof (struct ktr_psig);
d230 1
a230 2
	ktrwrite(vp, kth);
	FREE(kth, M_TEMP);
d239 1
a239 1
	struct ktr_header *kth;
d244 1
a244 1
	kth = ktrgetheader(p, KTR_CSW);
d247 2
a248 2
	kth->ktr_buf = (caddr_t)&kc;
	kth->ktr_len = sizeof (struct ktr_csw);
d250 1
a250 2
	ktrwrite(vp, kth);
	FREE(kth, M_TEMP);
@


1.13
log
@Random cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.12 2000/03/03 11:31:42 art Exp $	*/
d54 2
d184 2
a185 1
	
d188 1
d190 3
d194 1
a194 2
	MALLOC(ktp, struct ktr_genio *, sizeof(struct ktr_genio) + len,
		M_TEMP, M_WAITOK);
d197 3
d201 2
d204 2
a205 3
		if ((cnt = iov->iov_len) > resid)
			cnt = resid;
		if (copyin(iov->iov_base, cp, (unsigned)cnt))
d207 3
a209 3
		cp += cnt;
		resid -= cnt;
		iov++;
a210 4
	kth->ktr_buf = (caddr_t)ktp;
	kth->ktr_len = sizeof (struct ktr_genio) + len;

	ktrwrite(vp, kth);
d212 1
a213 1
	FREE(ktp, M_TEMP);
d215 1
@


1.12
log
@Use LIST_ macros instead of internal field names to walk the allproc list.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.11 1999/02/11 20:34:04 deraadt Exp $	*/
d54 1
a54 1
struct ktr_header *ktrgetheader __P((int));
d62 2
a63 1
ktrgetheader(type)
d66 1
a66 2
	register struct ktr_header *kth;
	struct proc *p = curproc;	/* XXX */
d87 1
a87 1
	register unsigned int len = sizeof(struct ktr_syscall) + argsize;
d93 1
a93 1
	kth = ktrgetheader(KTR_SYSCALL);
d120 1
a120 1
	kth = ktrgetheader(KTR_SYSRET);
d142 1
a142 1
	kth = ktrgetheader(KTR_NAMEI);
d160 1
a160 1
	kth = ktrgetheader(KTR_EMUL);
d174 1
a174 1
	register struct iovec *iov;
d178 3
a180 3
	register struct ktr_genio *ktp;
	register caddr_t cp;
	register int resid = len, cnt;
d186 1
a186 1
	kth = ktrgetheader(KTR_GENIO);
d223 1
a223 1
	kth = ktrgetheader(KTR_PSIG);
d246 1
a246 1
	kth = ktrgetheader(KTR_CSW);
d269 1
a269 1
	register struct sys_ktrace_args /* {
d275 1
a275 1
	register struct vnode *vp = NULL;
d419 2
a420 2
	register struct proc *p;
	register int ret = 0;
d448 1
a448 1
	register struct ktr_header *kth;
d452 1
a452 1
	register struct proc *p = curproc;	/* XXX */
d504 2
a505 2
	register struct pcred *caller = callp->p_cred;
	register struct pcred *target = targetp->p_cred;
@


1.11
log
@do not copyout uninitialized memory; arnej@@math.ntnu.no
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.10 1998/06/02 14:50:47 csapuntz Exp $	*/
d309 1
a309 1
		for (p = allproc.lh_first; p != 0; p = p->p_list.le_next) {
d482 1
a482 1
	for (p = allproc.lh_first; p != 0; p = p->p_list.le_next) {
@


1.11.6.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d309 1
a309 1
		for (p = LIST_FIRST(&allproc); p; p = LIST_NEXT(p, p_list)) {
d482 1
a482 1
	for (p = LIST_FIRST(&allproc); p != NULL; p = LIST_NEXT(p, p_list)) {
@


1.11.6.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.22 2000/11/10 18:15:46 art Exp $	*/
d54 1
a54 3
#include <vm/vm.h>

void ktrinitheader __P((struct ktr_header *, struct proc *, int));
d58 1
a58 1
int ktrwrite __P((struct proc *, struct ktr_header *));
d61 3
a63 7
/*
 * Change the trace vnode in a correct way (to avoid races).
 */
void
ktrsettracevnode(p, newvp)
	struct proc *p;
	struct vnode *newvp;
d65 2
a66 4
	struct vnode *vp;

	if (p->p_tracep == newvp)	/* avoid work */
		return;
d68 2
a69 16
	if (newvp != NULL)
		VREF(newvp);

	vp = p->p_tracep;
	p->p_tracep = newvp;

	if (vp != NULL)
		vrele(vp);
}

void
ktrinitheader(kth, p, type)
	struct ktr_header *kth;
	struct proc *p;
	int type;
{
d74 2
a75 1
	bcopy(p->p_comm, kth->ktr_comm, MAXCOMLEN);	
d79 2
a80 2
ktrsyscall(p, code, argsize, args)
	struct proc *p;
d85 1
a85 1
	struct	ktr_header kth;
d87 2
a88 1
	unsigned int len = sizeof(struct ktr_syscall) + argsize;
d93 2
a94 2
	ktrinitheader(&kth, p, KTR_SYSCALL);
	ktp = malloc(len, M_TEMP, M_WAITOK);
d100 5
a104 4
	kth.ktr_buf = (caddr_t)ktp;
	kth.ktr_len = len;
	ktrwrite(p, &kth);
	free(ktp, M_TEMP);
d109 2
a110 2
ktrsysret(p, code, error, retval)
	struct proc *p;
d115 1
a115 1
	struct ktr_header kth;
d117 1
d120 1
a120 1
	ktrinitheader(&kth, p, KTR_SYSRET);
d125 2
a126 2
	kth.ktr_buf = (caddr_t)&ktp;
	kth.ktr_len = sizeof(struct ktr_sysret);
d128 2
a129 1
	ktrwrite(p, &kth);
d134 2
a135 2
ktrnamei(p, path)
	struct proc *p;
d138 2
a139 1
	struct ktr_header kth;
d142 3
a144 3
	ktrinitheader(&kth, p, KTR_NAMEI);
	kth.ktr_len = strlen(path);
	kth.ktr_buf = path;
d146 2
a147 1
	ktrwrite(p, &kth);
d152 2
a153 2
ktremul(p, emul)
	struct proc *p;
d156 2
a157 1
	struct ktr_header kth;
d160 3
a162 3
	ktrinitheader(&kth, p, KTR_EMUL);
	kth.ktr_len = strlen(emul);
	kth.ktr_buf = emul;
d164 2
a165 1
	ktrwrite(p, &kth);
d170 2
a171 2
ktrgenio(p, fd, rw, iov, len, error)
	struct proc *p;
d174 1
a174 1
	struct iovec *iov;
d177 6
a182 6
	struct ktr_header kth;
	struct ktr_genio *ktp;
	caddr_t cp;
	int resid = len, count;
	int buflen;

a184 1

d186 3
a188 5

	buflen = min(PAGE_SIZE, len + sizeof(struct ktr_genio));

	ktrinitheader(&kth, p, KTR_GENIO);
	ktp = malloc(buflen, M_TEMP, M_WAITOK);
a190 3

	kth.ktr_buf = (caddr_t)ktp;

a191 2
	buflen -= sizeof(struct ktr_genio);

d193 7
a199 25
		/*
		 * Don't allow this process to hog the cpu when doing
		 * huge I/O.
		 */
		if (p->p_schedflags & PSCHED_SHOULDYIELD)
			preempt(NULL);

		count = min(iov->iov_len, buflen);
		if (count > resid)
			count = resid;
		if (copyin(iov->iov_base, cp, count))
			break;

		kth.ktr_len = count + sizeof(struct ktr_genio);

		if (ktrwrite(p, &kth) != 0)
			break;

		iov->iov_len -= count;
		iov->iov_base += count;

		if (iov->iov_len == 0)
			iov++;

		resid -= count;
d201 2
d204 4
a207 1
	free(ktp, M_TEMP);
a208 1
	
d212 2
a213 2
ktrpsig(p, sig, action, mask, code)
	struct proc *p;
d218 1
a218 1
	struct ktr_header kth;
d220 1
d223 1
a223 1
	ktrinitheader(&kth, p, KTR_PSIG);
d228 2
a229 2
	kth.ktr_buf = (caddr_t)&kp;
	kth.ktr_len = sizeof (struct ktr_psig);
d231 2
a232 1
	ktrwrite(p, &kth);
d237 2
a238 2
ktrcsw(p, out, user)
	struct proc *p;
d241 1
a241 1
	struct ktr_header kth;
d243 1
d246 1
a246 1
	ktrinitheader(&kth, p, KTR_CSW);
d249 2
a250 2
	kth.ktr_buf = (caddr_t)&kc;
	kth.ktr_len = sizeof (struct ktr_csw);
d252 2
a253 1
	ktrwrite(p, &kth);
d269 1
a269 1
	struct sys_ktrace_args /* {
d275 1
a275 1
	struct vnode *vp = NULL;
d292 1
a292 1
		if ((error = vn_open(&nd, FREAD|FWRITE|O_NOFOLLOW, 0)) != 0) {
d312 1
d314 1
a314 1
					ktrsettracevnode(p, NULL);
d379 9
a387 1
		ktrsettracevnode(p, vp);
d396 4
a399 1
			ktrsettracevnode(p, NULL);
d408 1
a408 1
		ktremul(p, p->p_emul->e_name);
d419 2
a420 2
	struct proc *p;
	int ret = 0;
d445 4
a448 4
int
ktrwrite(p, kth)
	struct proc *p;
	struct ktr_header *kth;
d452 1
a453 1
	struct vnode *vp = p->p_tracep;
d456 1
a456 1
		return 0;
d476 1
a476 1
		return 0;
d484 1
d486 1
a486 1
			ktrsettracevnode(p, NULL);
a488 2

	return error;
d504 2
a505 2
	struct pcred *caller = callp->p_cred;
	struct pcred *target = targetp->p_cred;
@


1.11.6.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.11.6.2 2001/05/14 22:32:40 niklas Exp $	*/
d233 1
a233 1
		iov->iov_base = (caddr_t)iov->iov_base + count;
d528 5
a532 5
	    target->p_ruid == target->p_svuid &&
	    caller->p_rgid == target->p_rgid &&	/* XXX */
	    target->p_rgid == target->p_svgid &&
	    (targetp->p_traceflag & KTRFAC_ROOT) == 0) ||
	    caller->pc_ucred->cr_uid == 0)
@


1.11.6.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 1
#include <uvm/uvm_extern.h>
@


1.11.6.5
log
@Merge in trunk
@
text
@d247 1
a247 1
ktrpsig(p, sig, action, mask, code, si)
a251 1
	siginfo_t *si;
d254 1
a254 1
	struct ktr_psig kp;
a261 1
	kp.si = *si;
@


1.11.6.6
log
@Merge in -current from about a week ago
@
text
@d56 6
a61 6
void ktrinitheader(struct ktr_header *, struct proc *, int);
int ktrops(struct proc *, struct proc *, int, int, struct vnode *);
int ktrsetchildren(struct proc *, struct proc *, int, int,
			struct vnode *);
int ktrwrite(struct proc *, struct ktr_header *);
int ktrcanset(struct proc *, struct proc *);
@


1.11.6.7
log
@Sync the SMP branch with 3.3
@
text
@d306 1
a306 1
		syscallarg(pid_t) pid;
d533 1
a533 2
	    (targetp->p_traceflag & KTRFAC_ROOT) == 0 &&
	    !ISSET(targetp->p_flag, P_SUGID)) ||
@


1.11.6.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.11.6.7 2003/03/28 00:41:26 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.6.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d299 1
a299 1
		syscallarg(const char *) fname;
@


1.11.6.10
log
@Make a few scheduling globals per-cpu, mostly NetBSD code
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.11.6.9 2004/02/19 10:56:37 niklas Exp $	*/
a213 3
#ifdef MULTIPROCESSOR
		if (curcpu()->ci_schedstate.spc_schedflags & SPCF_SHOULDYIELD)
#else
a214 1
#endif
@


1.11.6.11
log
@Include sched.h in kern_ktrace and kern_subr since they use those
defines in the MULTIPROCESSOR cases.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.11.6.10 2004/06/05 17:19:55 niklas Exp $	*/
a39 1
#include <sys/sched.h>
@


1.11.6.12
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d215 1
a215 1
#ifdef __HAVE_CPUINFO
@


1.10
log
@

Integrated fix from NetBSD kern/5357.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.9 1998/02/03 19:06:23 deraadt Exp $	*/
d70 1
@


1.9
log
@bad types; wileyc@@sekiya.twics.co.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.8 1997/11/14 23:40:55 csapuntz Exp $	*/
d313 1
a313 2
					(void) vn_close(vp, FREAD|FWRITE,
						p->p_ucred, p);
@


1.8
log
@Fixed up a VOP_UNLOCK call so that it uses the correction proc *
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.7 1997/11/11 13:50:13 niklas Exp $	*/
d86 1
a86 1
	register len = sizeof(struct ktr_syscall) + argsize;
@


1.7
log
@uninitialized variable
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.6 1997/11/06 05:58:16 csapuntz Exp $	*/
d275 1
a275 1
	register struct proc *p = curproc;	/* XXX */
d297 1
a297 2
		/* FIXME: Should be curp?? */
		VOP_UNLOCK(vp, 0, p);
@


1.6
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.5 1997/10/06 20:19:53 deraadt Exp $	*/
d275 1
a275 1
	register struct proc *p;
@


1.5
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_ktrace.c,v 1.3 1996/03/03 17:19:46 niklas Exp $	*/
d296 3
a298 1
		VOP_UNLOCK(vp);
d473 1
a473 1
	VOP_LOCK(vp);
d475 1
a475 1
	VOP_UNLOCK(vp);
@


1.4
log
@VFS Lite2 Changes
@
text
@d296 1
a296 3

		/* FIXME: Should be curp?? */
		VOP_UNLOCK(vp, 0, p);
d471 1
a471 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d473 1
a473 1
	VOP_UNLOCK(vp, 0, p);
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d296 3
a298 1
		VOP_UNLOCK(vp);
d473 1
a473 1
	VOP_LOCK(vp);
d475 1
a475 1
	VOP_UNLOCK(vp);
@


1.2
log
@from netbsd; emulation records
@
text
@d1 2
a2 1
/*	$NetBSD: kern_ktrace.c,v 1.21 1995/10/22 00:35:06 christos Exp $	*/
d54 7
d277 1
a277 1
	int facs = SCARG(uap, facs) & ~KTRFAC_ROOT;
d291 1
a291 1
		if (error = vn_open(&nd, FREAD|FWRITE, 0)) {
d412 1
d444 1
d499 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: kern_ktrace.c,v 1.20 1995/10/07 06:28:16 mycroft Exp $	*/
d393 7
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
