head	1.51;
access;
symbols
	OPENBSD_6_1:1.51.0.6
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.51.0.4
	OPENBSD_6_0_BASE:1.51
	OPENBSD_5_9:1.51.0.2
	OPENBSD_5_9_BASE:1.51
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.37.0.4
	OPENBSD_5_6_BASE:1.37
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.30.0.4
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.2
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.29.0.6
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.4
	OPENBSD_5_0:1.29.0.2
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.28.0.18
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.16
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.12
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.14
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.10
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.8
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.6
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.4
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.26.0.6
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.4
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.25.0.6
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.22
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.6.0.4
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.4.0.6
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.51
date	2015.08.29.05.40.01;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	qStrsYMepraR0xeU;

1.50
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.49;
commitid	p4LJxGKbi0BU2cG6;

1.49
date	2015.02.16.05.23.43;	author miod;	state Exp;
branches;
next	1.48;
commitid	D0AQaqVlrMaE1lBP;

1.48
date	2015.02.09.11.52.47;	author miod;	state Exp;
branches;
next	1.47;
commitid	3LyovzkL8t513Pbn;

1.47
date	2015.02.06.23.58.12;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	Xlq9pdSoAVoFugi1;

1.46
date	2014.12.17.06.58.11;	author guenther;	state Exp;
branches;
next	1.45;
commitid	DImukoCWyTxwdbuh;

1.45
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.44;
commitid	P6Av4XGqOi3rFasL;

1.44
date	2014.12.15.02.24.23;	author guenther;	state Exp;
branches;
next	1.43;
commitid	ZxaujiOM0aYQRjFY;

1.43
date	2014.12.10.02.44.46;	author tedu;	state Exp;
branches;
next	1.42;
commitid	tsoJBlEBSyYO22RG;

1.42
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.41;
commitid	Z1vcFtHO8wRH0yRt;

1.41
date	2014.11.16.23.54.56;	author guenther;	state Exp;
branches;
next	1.40;
commitid	ILNkG6lvVerMONFR;

1.40
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.39;
commitid	yv0ECmCdICvq576h;

1.39
date	2014.11.14.23.26.48;	author tedu;	state Exp;
branches;
next	1.38;
commitid	Xw9eD6Y0JOIFIwDy;

1.38
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.37;
commitid	3SGDR5EjcwE01W8S;

1.37
date	2014.07.13.15.29.04;	author tedu;	state Exp;
branches;
next	1.36;
commitid	bFFVdS3JEaMhyZxJ;

1.36
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.35;
commitid	QlVV51SZgNFxsXxC;

1.35
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	EF98ch02VpFassUi;

1.34
date	2014.07.02.06.09.49;	author matthew;	state Exp;
branches;
next	1.33;
commitid	mswsoyQHeu5M87iU;

1.33
date	2014.05.29.05.05.34;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2014.03.28.17.57.11;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.15.05.30.53;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2012.08.20.23.25.07;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.29.12.16.17;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2006.11.14.18.00.27;	author jmc;	state Exp;
branches;
next	1.27;

1.27
date	2006.07.26.19.11.01;	author sturm;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.23.10.14.49;	author hshoexer;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.09.00.48.42;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2002.12.19.00.57.07;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2002.11.06.00.17.28;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2002.10.07.23.31.42;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.06.22.39.25;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2002.10.02.23.56.32;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.21.21.29.33;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.28.13.47.39;	author art;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.11.27.05.27.11;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.07.01.18.01;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.27.04.49.40;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.22.14.14.08;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.22.16.08.01;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.06.16.19.52;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.26.14.01.39;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.11.05.01.18.01;	author mickey;	state Exp;
branches
	1.7.2.1
	1.7.4.1;
next	1.6;

1.6
date	99.02.26.05.14.27;	author art;	state Exp;
branches;
next	1.5;

1.5
date	98.07.28.00.13.01;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.02.24.14.19.56;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	97.02.14.16.39.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.12.23.02.42.44;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.43;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.32.39;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.48.13;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2002.03.06.02.13.22;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.7.2.8;

1.7.2.8
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	;

1.7.4.1
date	2000.11.07.15.53.41;	author jason;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2003.05.19.22.31.09;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.51
log
@size for free()
@
text
@/*	$OpenBSD: exec_subr.c,v 1.50 2015/03/14 03:38:50 jsg Exp $	*/
/*	$NetBSD: exec_subr.c,v 1.9 1994/12/04 03:10:42 mycroft Exp $	*/

/*
 * Copyright (c) 1993, 1994 Christopher G. Demetriou
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/vnode.h>
#include <sys/exec.h>
#include <sys/mman.h>
#include <sys/resourcevar.h>

#include <uvm/uvm_extern.h>

#ifdef DEBUG
/*
 * new_vmcmd():
 *	create a new vmcmd structure and fill in its fields based
 *	on function call arguments.  make sure objects ref'd by
 *	the vmcmd are 'held'.
 *
 * If not debugging, this is a macro, so it's expanded inline.
 */

void
new_vmcmd(struct exec_vmcmd_set *evsp,
    int (*proc)(struct proc *, struct exec_vmcmd *), u_long len, u_long addr,
    struct vnode *vp, u_long offset, u_int prot, int flags)
{
	struct exec_vmcmd    *vcp;

	if (evsp->evs_used >= evsp->evs_cnt)
		vmcmdset_extend(evsp);
	vcp = &evsp->evs_cmds[evsp->evs_used++];
	vcp->ev_proc = proc;
	vcp->ev_len = len;
	vcp->ev_addr = addr;
	if ((vcp->ev_vp = vp) != NULL)
		vref(vp);
	vcp->ev_offset = offset;
	vcp->ev_prot = prot;
	vcp->ev_flags = flags;
}
#endif /* DEBUG */

void
vmcmdset_extend(struct exec_vmcmd_set *evsp)
{
	struct exec_vmcmd *nvcp;
	u_int ocnt;

#ifdef DIAGNOSTIC
	if (evsp->evs_used < evsp->evs_cnt)
		panic("vmcmdset_extend: not necessary");
#endif

	ocnt = evsp->evs_cnt;
	KASSERT(ocnt > 0);
	/* figure out number of entries in new set */
	evsp->evs_cnt += ocnt;

	/* reallocate the command set */
	nvcp = mallocarray(evsp->evs_cnt, sizeof(*nvcp), M_EXEC,
	    M_WAITOK);
	memcpy(nvcp, evsp->evs_cmds, ocnt * sizeof(*nvcp));
	if (evsp->evs_cmds != evsp->evs_start)
		free(evsp->evs_cmds, M_EXEC, ocnt * sizeof(*nvcp));
	evsp->evs_cmds = nvcp;
}

void
kill_vmcmds(struct exec_vmcmd_set *evsp)
{
	struct exec_vmcmd *vcp;
	int i;

	for (i = 0; i < evsp->evs_used; i++) {
		vcp = &evsp->evs_cmds[i];
		if (vcp->ev_vp != NULLVP)
			vrele(vcp->ev_vp);
	}

	/*
	 * Free old vmcmds and reset the array.
	 */
	evsp->evs_used = 0;
	if (evsp->evs_cmds != evsp->evs_start)
		free(evsp->evs_cmds, M_EXEC,
		    evsp->evs_cnt * sizeof(struct exec_vmcmd));
	evsp->evs_cmds = evsp->evs_start;
	evsp->evs_cnt = EXEC_DEFAULT_VMCMD_SETSIZE;
}

int
exec_process_vmcmds(struct proc *p, struct exec_package *epp)
{
	struct exec_vmcmd *base_vc = NULL;
	int error = 0;
	int i;

	for (i = 0; i < epp->ep_vmcmds.evs_used && !error; i++) {
		struct exec_vmcmd *vcp;

		vcp = &epp->ep_vmcmds.evs_cmds[i];

		if (vcp->ev_flags & VMCMD_RELATIVE) {
#ifdef DIAGNOSTIC
			if (base_vc == NULL)
				panic("exec_process_vmcmds: RELATIVE no base");
#endif
			vcp->ev_addr += base_vc->ev_addr;
		}
		error = (*vcp->ev_proc)(p, vcp);
		if (vcp->ev_flags & VMCMD_BASE) {
			base_vc = vcp;
		}
	}

	kill_vmcmds(&epp->ep_vmcmds);

	return (error);
}

/*
 * vmcmd_map_pagedvn():
 *	handle vmcmd which specifies that a vnode should be mmap'd.
 *	appropriate for handling demand-paged text and data segments.
 */

int
vmcmd_map_pagedvn(struct proc *p, struct exec_vmcmd *cmd)
{
	/*
	 * note that if you're going to map part of a process as being
	 * paged from a vnode, that vnode had damn well better be marked as
	 * VTEXT.  that's handled in the routine which sets up the vmcmd to
	 * call this routine.
	 */
	struct uvm_object *uobj;
	int error;

	/*
	 * map the vnode in using uvm_map.
	 */

	if (cmd->ev_len == 0)
		return (0);
	if (cmd->ev_offset & PAGE_MASK)
		return (EINVAL);
	if (cmd->ev_addr & PAGE_MASK)
		return (EINVAL);
	if (cmd->ev_len & PAGE_MASK)
		return (EINVAL);

	/*
	 * first, attach to the object
	 */

	uobj = uvn_attach(cmd->ev_vp, PROT_READ | PROT_EXEC);
	if (uobj == NULL)
		return (ENOMEM);

	/*
	 * do the map
	 */

	error = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr, cmd->ev_len,
	    uobj, cmd->ev_offset, 0,
	    UVM_MAPFLAG(cmd->ev_prot, PROT_MASK, MAP_INHERIT_COPY,
	    MADV_NORMAL, UVM_FLAG_COPYONW|UVM_FLAG_FIXED));

	/*
	 * check for error
	 */

	if (error) {
		/*
		 * error: detach from object
		 */
		uobj->pgops->pgo_detach(uobj);
	}

	return (error);
}

/*
 * vmcmd_map_readvn():
 *	handle vmcmd which specifies that a vnode should be read from.
 *	appropriate for non-demand-paged text/data segments, i.e. impure
 *	objects (a la OMAGIC and NMAGIC).
 */

int
vmcmd_map_readvn(struct proc *p, struct exec_vmcmd *cmd)
{
	int error;
	vm_prot_t prot;

	if (cmd->ev_len == 0)
		return (0);

	prot = cmd->ev_prot;

	cmd->ev_addr = trunc_page(cmd->ev_addr); /* required by uvm_map */
	error = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr,
	    round_page(cmd->ev_len), NULL, UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(prot | PROT_WRITE, PROT_MASK, MAP_INHERIT_COPY,
	    MADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW));

	if (error)
		return (error);

	error = vn_rdwr(UIO_READ, cmd->ev_vp, (caddr_t)cmd->ev_addr,
	    cmd->ev_len, cmd->ev_offset, UIO_USERSPACE, IO_UNIT,
	    p->p_ucred, NULL, p);
	if (error)
		return (error);

	if ((prot & PROT_WRITE) == 0) {
		/*
		 * we had to map in the area at PROT_WRITE so that vn_rdwr()
		 * could write to it.   however, the caller seems to want
		 * it mapped read-only, so now we are going to have to call
		 * uvm_map_protect() to fix up the protection.  ICK.
		 */
		return (uvm_map_protect(&p->p_vmspace->vm_map,
		    trunc_page(cmd->ev_addr),
		    round_page(cmd->ev_addr + cmd->ev_len),
		    prot, FALSE));
	}
	return (0);
}

/*
 * vmcmd_map_zero():
 *	handle vmcmd which specifies a zero-filled address space region.
 */

int
vmcmd_map_zero(struct proc *p, struct exec_vmcmd *cmd)
{
	if (cmd->ev_len == 0)
		return (0);
	
	cmd->ev_addr = trunc_page(cmd->ev_addr); /* required by uvm_map */
	return (uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr,
	    round_page(cmd->ev_len), NULL, UVM_UNKNOWN_OFFSET, 0,
	    UVM_MAPFLAG(cmd->ev_prot, PROT_MASK, MAP_INHERIT_COPY,
	    MADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_COPYONW)));
}

/*
 * vmcmd_randomize():
 *	handle vmcmd which specifies a randomized address space region.
 */

int
vmcmd_randomize(struct proc *p, struct exec_vmcmd *cmd)
{
	char *buf;
	int error;
	size_t off = 0, len;

	if (cmd->ev_len == 0)
		return (0);
	if (cmd->ev_len > ELF_RANDOMIZE_LIMIT)
		return (EINVAL);

	buf = malloc(PAGE_SIZE, M_TEMP, M_WAITOK);
	len = cmd->ev_len;
	do {
		size_t sublen = MIN(len, PAGE_SIZE);

		arc4random_buf(buf, sublen);
		error = copyout(buf, (void *)cmd->ev_addr + off, sublen);
		if (error)
			break;
		off += sublen;
		len -= sublen;
		if (len)
			yield();
	} while (len);
	free(buf, M_TEMP, PAGE_SIZE);

	return (error);
}

/*
 * exec_setup_stack(): Set up the stack segment for an executable.
 *
 * Note that the ep_ssize parameter must be set to be the current stack
 * limit; this is adjusted in the body of execve() to yield the
 * appropriate stack segment usage once the argument length is
 * calculated.
 *
 * This function returns an int for uniformity with other (future) formats'
 * stack setup functions.  They might have errors to return.
 */

int
exec_setup_stack(struct proc *p, struct exec_package *epp)
{
	vaddr_t sgap;

#ifdef MACHINE_STACK_GROWS_UP
	epp->ep_maxsaddr = USRSTACK;
	epp->ep_minsaddr = USRSTACK + MAXSSIZ;
#else
	epp->ep_maxsaddr = USRSTACK - MAXSSIZ;
	epp->ep_minsaddr = USRSTACK;
#endif
	epp->ep_ssize = round_page(p->p_rlimit[RLIMIT_STACK].rlim_cur);

	if (stackgap_random != 0) {
		sgap = arc4random() & (stackgap_random - 1);
		sgap = trunc_page(sgap);

#ifdef MACHINE_STACK_GROWS_UP
		epp->ep_maxsaddr += sgap;
		epp->ep_minsaddr += sgap;
#else
		epp->ep_maxsaddr -= sgap;
		epp->ep_minsaddr -= sgap;
#endif
	}

	/*
	 * set up commands for stack.  note that this takes *two*, one to
	 * map the part of the stack which we can access, and one to map
	 * the part which we can't.
	 *
	 * arguably, it could be made into one, but that would require the
	 * addition of another mapping proc, which is unnecessary
	 *
	 * note that in memory, things assumed to be: 0 ....... ep_maxsaddr
	 * <stack> ep_minsaddr
	 */
#ifdef MACHINE_STACK_GROWS_UP
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero,
	    ((epp->ep_minsaddr - epp->ep_ssize) - epp->ep_maxsaddr),
	    epp->ep_maxsaddr + epp->ep_ssize, NULLVP, 0, PROT_NONE);
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, epp->ep_ssize,
	    epp->ep_maxsaddr, NULLVP, 0,
	    PROT_READ | PROT_WRITE);
#else
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero,
	    ((epp->ep_minsaddr - epp->ep_ssize) - epp->ep_maxsaddr),
	    epp->ep_maxsaddr, NULLVP, 0, PROT_NONE);
	NEW_VMCMD(&epp->ep_vmcmds, vmcmd_map_zero, epp->ep_ssize,
	    (epp->ep_minsaddr - epp->ep_ssize), NULLVP, 0,
	    PROT_READ | PROT_WRITE);
#endif

	return (0);
}
@


1.50
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.49 2015/02/16 05:23:43 miod Exp $	*/
d118 2
a119 1
		free(evsp->evs_cmds, M_EXEC, 0);
@


1.49
log
@In exec_setup_stack(), move the stack in the right direction if
MACHINE_STACK_GROWS_UP.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.48 2015/02/09 11:52:47 miod Exp $	*/
a38 1
#include <sys/filedesc.h>
@


1.48
log
@Change the way stackgap_random is applied. Instead of applying it within the
fixed stack area of the exec'd image, and risking hitting process limits,
should we want to increase stackgap_random, the randomness is applied to the
stack region in the process' vmspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.47 2015/02/06 23:58:12 deraadt Exp $	*/
d348 4
d354 1
@


1.47
log
@Raise ELF_RANDOMIZE_LIMIT to 64K, so that programs and libraries can
legitimately use random section variables without execve failures...
Because this section is not demand faulted, yield() every page during
the fill otherwise the costs are charged poorly.
ok tedu matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.46 2014/12/17 06:58:11 guenther Exp $	*/
d333 1
d343 8
@


1.46
log
@Prefer MADV_* over POSIX_MADV_* in kernel for consistency: the latter
doesn't have all the values and therefore can't be used everywhere.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.45 2014/12/16 18:30:03 tedu Exp $	*/
d292 1
d296 1
a296 1
	if (cmd->ev_len > 1024)
d299 15
a313 4
	buf = malloc(cmd->ev_len, M_TEMP, M_WAITOK);
	arc4random_buf(buf, cmd->ev_len);
	error = copyout(buf, (void *)cmd->ev_addr, cmd->ev_len);
	free(buf, M_TEMP, cmd->ev_len);
@


1.45
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.44 2014/12/15 02:24:23 guenther Exp $	*/
d200 1
a200 1
	    POSIX_MADV_NORMAL, UVM_FLAG_COPYONW|UVM_FLAG_FIXED));
d238 1
a238 2
	    POSIX_MADV_NORMAL,
	    UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW));
d279 1
a279 1
	    POSIX_MADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_COPYONW)));
@


1.44
log
@Use MAP_INHERIT_* for the 'inh' argument to the UMV_MAPFLAG() macro,
eliminating the must-be-kept-in-sync UVM_INH_* macros

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.43 2014/12/10 02:44:46 tedu Exp $	*/
d43 2
@


1.43
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.42 2014/11/18 02:37:31 tedu Exp $	*/
d197 1
a197 1
	    UVM_MAPFLAG(cmd->ev_prot, PROT_MASK, UVM_INH_COPY,
d235 1
a235 1
	    UVM_MAPFLAG(prot | PROT_WRITE, PROT_MASK, UVM_INH_COPY,
d277 1
a277 1
	    UVM_MAPFLAG(cmd->ev_prot, PROT_MASK, UVM_INH_COPY,
@


1.42
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.41 2014/11/16 23:54:56 guenther Exp $	*/
d94 1
a94 1
	bcopy(evsp->evs_cmds, nvcp, (ocnt * sizeof(*nvcp)));
@


1.41
log
@Delete a comment that was obsoleted by the switch to UVM
vmcmd_map_zero() just returns the result of uvm_map(), so make it a tail call
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.40 2014/11/16 12:31:00 deraadt Exp $	*/
a42 2

#include <dev/rndvar.h>
@


1.40
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.39 2014/11/14 23:26:48 tedu Exp $	*/
d267 1
a267 2
 *	handle vmcmd which specifies a zero-filled address space region.  The
 *	address range must be first allocated, then protected appropriately.
a272 2
	int error;

d277 1
a277 1
	error = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr,
d280 1
a280 6
	    POSIX_MADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_COPYONW));

	if (error)
		return error;

	return (0);
@


1.39
log
@prefer sizeof(*ptr) to sizeof(struct) for malloc and free
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.38 2014/11/03 03:08:00 deraadt Exp $	*/
d189 1
a189 1
	uobj = uvn_attach(cmd->ev_vp, VM_PROT_READ|VM_PROT_EXECUTE);
d199 2
a200 2
	    UVM_MAPFLAG(cmd->ev_prot, VM_PROT_ALL, UVM_INH_COPY,
	    UVM_ADV_NORMAL, UVM_FLAG_COPYONW|UVM_FLAG_FIXED));
d237 2
a238 2
	    UVM_MAPFLAG(prot | UVM_PROT_WRITE, UVM_PROT_ALL, UVM_INH_COPY,
	    UVM_ADV_NORMAL,
d250 1
a250 1
	if ((prot & VM_PROT_WRITE) == 0) {
d282 2
a283 2
	    UVM_MAPFLAG(cmd->ev_prot, UVM_PROT_ALL, UVM_INH_COPY,
	    UVM_ADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_COPYONW));
d354 1
a354 1
	    epp->ep_maxsaddr + epp->ep_ssize, NULLVP, 0, VM_PROT_NONE);
d357 1
a357 1
	    VM_PROT_READ|VM_PROT_WRITE);
d361 1
a361 1
	    epp->ep_maxsaddr, NULLVP, 0, VM_PROT_NONE);
d364 1
a364 1
	    VM_PROT_READ|VM_PROT_WRITE);
@


1.38
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.37 2014/07/13 15:29:04 tedu Exp $	*/
d94 1
a94 1
	nvcp = mallocarray(evsp->evs_cnt, sizeof(struct exec_vmcmd), M_EXEC,
d96 1
a96 1
	bcopy(evsp->evs_cmds, nvcp, (ocnt * sizeof(struct exec_vmcmd)));
d98 1
a98 1
		free(evsp->evs_cmds, M_EXEC, ocnt * sizeof(struct exec_vmcmd));
@


1.37
log
@use mallocarray where arguments are multipled. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.36 2014/07/12 18:43:32 tedu Exp $	*/
d98 1
a98 1
		free(evsp->evs_cmds, M_EXEC, 0);
d310 1
a310 1
	free(buf, M_TEMP, 0);
@


1.36
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.35 2014/07/08 17:19:25 deraadt Exp $	*/
d94 1
a94 1
	nvcp = malloc(evsp->evs_cnt * sizeof(struct exec_vmcmd), M_EXEC,
@


1.35
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.34 2014/07/02 06:09:49 matthew Exp $	*/
d98 1
a98 1
		free(evsp->evs_cmds, M_EXEC);
d119 1
a119 1
		free(evsp->evs_cmds, M_EXEC);
d310 1
a310 1
	free(buf, M_TEMP);
@


1.34
log
@Use real parameter types for u{dv,vn}_attach() instead of void *

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.33 2014/05/29 05:05:34 guenther Exp $	*/
a43 1
#include <uvm/uvm_extern.h>
@


1.33
log
@When vmcmd_map_readvn() maps in the page it reads into, it forces
it to be writable but otherwise uses the correct final permissions.
Ergo, it only needs to call uvm_map_protect() if the requested
permissions didn't include UVM_PROT_WRITE.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.32 2014/03/28 17:57:11 mpi Exp $	*/
d190 1
a190 1
	uobj = uvn_attach((void *)cmd->ev_vp, VM_PROT_READ|VM_PROT_EXECUTE);
@


1.32
log
@Reduce uvm include madness.  Use <uvm/uvm_extern.h> instead of
<uvm/uvm.h> if possible and remove double inclusions.

ok beck@@, mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.31 2013/10/15 05:30:53 deraadt Exp $	*/
d251 1
a251 1
	if (cmd->ev_prot != (VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE)) {
d253 1
a253 1
		 * we had to map in the area at PROT_ALL so that vn_rdwr()
@


1.31
log
@repair typo talking about a.out
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.30 2012/08/20 23:25:07 matthew Exp $	*/
d44 1
a44 1
#include <uvm/uvm.h>
@


1.30
log
@Add support for .openbsd.randomdata sections and PT_OPENBSD_RANDOMIZE
segments to the kernel, ld (2.15), and ld.so.  Tested on alpha, amd64,
i386, macppc, and sparc64 (thanks naddy, mpi, and okan!).

Idea discussed for some time; committing now for further testing.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.29 2011/06/29 12:16:17 tedu Exp $	*/
d317 1
a317 2
 * exec_setup_stack(): Set up the stack segment for an a.out
 * executable.
@


1.29
log
@ansi with a little knf.  ok deraadt jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.28 2006/11/14 18:00:27 jmc Exp $	*/
d45 1
d290 24
@


1.28
log
@grammar, spelling, and style fixes from bret lambert;
kern_descrip.c change ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.27 2006/07/26 19:11:01 sturm Exp $	*/
d57 3
a59 9
new_vmcmd(evsp, proc, len, addr, vp, offset, prot, flags)
	struct	exec_vmcmd_set *evsp;
	int	(*proc)(struct proc * p, struct exec_vmcmd *);
	u_long	len;
	u_long	addr;
	struct	vnode *vp;
	u_long	offset;
	u_int	prot;
	int	flags;
d78 1
a78 2
vmcmdset_extend(evsp)
	struct	exec_vmcmd_set *evsp;
d161 1
a161 3
vmcmd_map_pagedvn(p, cmd)
	struct proc *p;
	struct exec_vmcmd *cmd;
d177 1
a177 1
		return(0);
d179 1
a179 1
		return(EINVAL);
d181 1
a181 1
		return(EINVAL);
d183 1
a183 1
		return(EINVAL);
d189 1
a189 1
	uobj = uvn_attach((void *) cmd->ev_vp, VM_PROT_READ|VM_PROT_EXECUTE);
d191 1
a191 1
		return(ENOMEM);
d272 1
a272 3
vmcmd_map_zero(p, cmd)
	struct proc *p;
	struct exec_vmcmd *cmd;
d305 1
a305 3
exec_setup_stack(p, epp)
	struct proc *p;
	struct exec_package *epp;
d344 1
a344 1
	return 0;
@


1.27
log
@don't call vn_rdwr() with IO_NODELOCKED when the vnode actually isn't
locked; with this diff VFSDEBUG kernels can boot again

ok pedro, thib (who came up with the same diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.26 2004/11/23 10:14:49 hshoexer Exp $	*/
d173 1
a173 1
	 * note that if you're going to map part of an process as being
@


1.26
log
@fix typo in comment

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.25 2003/05/09 00:48:42 art Exp $	*/
d254 1
a254 1
	    cmd->ev_len, cmd->ev_offset, UIO_USERSPACE, IO_UNIT|IO_NODELOCKED,
@


1.25
log
@vmcmd_map_readvn - don't map the initial mapping with X unless the
final protection has an X. Doesn't really change anything except reducing
I$ flushing.

niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.24 2002/12/19 00:57:07 mickey Exp $	*/
d122 1
a122 1
	 * Free old vmcmds and restet the array.
@


1.24
log
@simplify stack grownups (growndowns are not touched)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.23 2002/11/06 00:17:28 art Exp $	*/
d231 1
d233 1
a233 3
vmcmd_map_readvn(p, cmd)
	struct proc *p;
	struct exec_vmcmd *cmd;
d236 1
d240 3
a242 1
	
d246 1
a246 1
	    UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_COPY,
d269 1
a269 1
		    cmd->ev_prot, FALSE));
@


1.23
log
@Eliminate the use of KERN_SUCCESS outside of uvm/

Also uvm_map returns KERN_* codes that are directly mapped to
errnos, so we can return them instead of doing some attempt to
translation.

drahn@@ "I see no problem" pval@@ "makes sense"
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.22 2002/10/07 23:31:42 art Exp $	*/
d320 2
a321 1
	epp->ep_maxsaddr = USRSTACK + MAXSSIZ;
d324 1
a325 1
	epp->ep_minsaddr = USRSTACK;
d341 2
a342 2
	    (epp->ep_maxsaddr - (epp->ep_minsaddr + epp->ep_ssize)),
	    epp->ep_minsaddr + epp->ep_ssize, NULLVP, 0, VM_PROT_NONE);
d344 1
a344 1
	    epp->ep_minsaddr, NULLVP, 0,
@


1.22
log
@Remove a diagnostic check that I added when reorganizing the code.
It triggers on ppc and while the check itself is correct, it's better to
fix the bug before breaking peoples systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.21 2002/10/06 22:39:25 art Exp $	*/
d179 1
a179 1
	int retval;
d206 1
a206 1
	retval = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr, cmd->ev_len,
d215 6
a220 2
	if (retval == KERN_SUCCESS)
		return(0);
d222 1
a222 6
	/*
	 * error: detach from object
	 */

	uobj->pgops->pgo_detach(uobj);
	return(EINVAL);
@


1.21
log
@Move out the execution of vmcmds into a separate function.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.20 2002/10/02 23:56:32 mickey Exp $	*/
a151 4
#ifdef DIAGNOSTIC
			if (base_vc != NULL)
				panic("exec_process_vmcmds: multiple BASE");
#endif
@


1.20
log
@make it compile w/ DEBUG by syncing w/ exec.h; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.19 2002/07/21 21:29:33 art Exp $	*/
d110 1
a110 2
kill_vmcmds(evsp)
	struct	exec_vmcmd_set *evsp;
d129 34
@


1.19
log
@Map stack pages without VM_PROT_EXECUTE. Notice that right now this
doesn't do anything since no pmap implements exec protection yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.18 2002/03/14 01:27:04 millert Exp $	*/
d57 1
a57 1
new_vmcmd(evsp, proc, len, addr, vp, offset, prot)
d65 1
d79 1
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.17 2001/12/19 08:58:06 art Exp $	*/
d314 1
a314 1
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
d321 1
a321 1
	    VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE);
@


1.17
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.14 2001/11/07 01:18:01 art Exp $	*/
d59 1
a59 1
	int	(*proc) __P((struct proc * p, struct exec_vmcmd *));
@


1.16
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.15 2001/11/27 05:27:11 art Exp $	*/
d141 6
d148 1
a148 1
	int error;
a169 1
	VREF(cmd->ev_vp);
d175 1
a175 1
	error = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr, cmd->ev_len,
d180 10
a189 3
	if (error) {
		uobj->pgops->pgo_detach(uobj);
	}
d191 2
a192 1
	return(error);
@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.16 2001/11/28 13:47:39 art Exp $	*/
d59 1
a59 1
	int	(*proc)(struct proc * p, struct exec_vmcmd *);
@


1.16.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.16.2.1 2002/06/11 03:29:40 art Exp $	*/
d57 1
a57 1
new_vmcmd(evsp, proc, len, addr, vp, offset, prot, flags)
a64 1
	int	flags;
a77 1
	vcp->ev_flags = flags;
d108 2
a109 1
kill_vmcmds(struct exec_vmcmd_set *evsp)
a129 30
int
exec_process_vmcmds(struct proc *p, struct exec_package *epp)
{
	struct exec_vmcmd *base_vc = NULL;
	int error = 0;
	int i;

	for (i = 0; i < epp->ep_vmcmds.evs_used && !error; i++) {
		struct exec_vmcmd *vcp;

		vcp = &epp->ep_vmcmds.evs_cmds[i];

		if (vcp->ev_flags & VMCMD_RELATIVE) {
#ifdef DIAGNOSTIC
			if (base_vc == NULL)
				panic("exec_process_vmcmds: RELATIVE no base");
#endif
			vcp->ev_addr += base_vc->ev_addr;
		}
		error = (*vcp->ev_proc)(p, vcp);
		if (vcp->ev_flags & VMCMD_BASE) {
			base_vc = vcp;
		}
	}

	kill_vmcmds(&epp->ep_vmcmds);

	return (error);
}

d301 1
a301 1
	    VM_PROT_READ|VM_PROT_WRITE);
d308 1
a308 1
	    VM_PROT_READ|VM_PROT_WRITE);
@


1.16.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d210 1
a210 1
	return (error);
a218 1

d220 3
a222 1
vmcmd_map_readvn(struct proc *p, struct exec_vmcmd *cmd)
a224 1
	vm_prot_t prot;
d228 1
a228 3

	prot = cmd->ev_prot;

d232 1
a232 1
	    UVM_MAPFLAG(prot | UVM_PROT_WRITE, UVM_PROT_ALL, UVM_INH_COPY,
d255 1
a255 1
		    prot, FALSE));
d308 1
a308 2
	epp->ep_maxsaddr = USRSTACK;
	epp->ep_minsaddr = USRSTACK + MAXSSIZ;
d311 1
a312 1
#endif
d328 2
a329 2
	    ((epp->ep_minsaddr - epp->ep_ssize) - epp->ep_maxsaddr),
	    epp->ep_maxsaddr + epp->ep_ssize, NULLVP, 0, VM_PROT_NONE);
d331 1
a331 1
	    epp->ep_maxsaddr, NULLVP, 0,
@


1.15
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.14 2001/11/07 01:18:01 art Exp $	*/
a140 6
	/*
	 * note that if you're going to map part of an process as being
	 * paged from a vnode, that vnode had damn well better be marked as
	 * VTEXT.  that's handled in the routine which sets up the vmcmd to
	 * call this routine.
	 */
d142 1
a142 1
	int retval;
d170 1
a170 1
	retval = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr, cmd->ev_len,
d175 3
a177 3
	/*
	 * check for error
	 */
d179 1
a179 9
	if (retval == KERN_SUCCESS)
		return(0);

	/*
	 * error: detach from object
	 */

	uobj->pgops->pgo_detach(uobj);
	return(EINVAL);
d196 1
a196 1
		return(KERN_SUCCESS); /* XXXCDC: should it happen? */
d206 1
a206 1
		return error;
d212 1
a212 1
		return error;
d221 1
a221 1
		return(uvm_map_protect(&p->p_vmspace->vm_map,
a224 2
	} else {
		return(KERN_SUCCESS);
d226 1
d243 1
a243 1
		return(KERN_SUCCESS); /* XXXCDC: should it happen? */
d254 1
a254 1
	return(KERN_SUCCESS);
@


1.14
log
@Add an alignment argument to uvm_map that specifies an alignment hint
for the virtual address.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.13 2001/11/06 19:53:20 miod Exp $	*/
d170 1
@


1.13
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.12 2001/06/27 04:49:40 art Exp $	*/
d176 1
a176 1
	    uobj, cmd->ev_offset,
d213 1
a213 1
	    round_page(cmd->ev_len), NULL, UVM_UNKNOWN_OFFSET,
d261 1
a261 1
	    round_page(cmd->ev_len), NULL, UVM_UNKNOWN_OFFSET,
@


1.12
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.11 2001/06/22 14:14:08 deraadt Exp $	*/
a42 2

#include <vm/vm.h>
@


1.11
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.10 2001/02/22 16:08:01 art Exp $	*/
a45 1
#if defined(UVM)
a46 1
#endif
a148 1
#if defined(UVM)
a194 5
#else
	return vm_mmap(&p->p_vmspace->vm_map, &cmd->ev_addr, cmd->ev_len,
	    cmd->ev_prot, VM_PROT_ALL, MAP_FIXED|MAP_COPY, (caddr_t)cmd->ev_vp,
	    cmd->ev_offset);
#endif
a209 1
#if defined(UVM)
a219 4
#else
	error = vm_allocate(&p->p_vmspace->vm_map, &cmd->ev_addr,
	    cmd->ev_len, 0);
#endif
a228 1
#if defined(UVM)
a242 4
#else
	return vm_map_protect(&p->p_vmspace->vm_map, trunc_page(cmd->ev_addr),
	    round_page(cmd->ev_addr + cmd->ev_len), cmd->ev_prot, FALSE);
#endif
a257 1
#if defined(UVM)
a266 4
#else
	error = vm_allocate(&p->p_vmspace->vm_map, &cmd->ev_addr,
	    cmd->ev_len, 0);
#endif
a269 4
#if !defined(UVM)
	return vm_map_protect(&p->p_vmspace->vm_map, trunc_page(cmd->ev_addr),
	    round_page(cmd->ev_addr + cmd->ev_len), cmd->ev_prot, FALSE);
#else
a270 1
#endif
@


1.10
log
@ELF uses more than 5 vmcmds by default, so grow the default vmcmd set size
to 8.

At the same time it seemed like a good idea to avoid to always malloc a
new vmcmd array, so put the default sized array into struct exec_vmcmd_set.

We might want to make a linked list of vmcmd arrays or exec_vmcmd_sets instead
of reallocating them some time in the future, but right now this seems like a
waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.9 2000/11/06 16:19:52 art Exp $	*/
d104 1
a104 1
		      M_WAITOK);
d152 1
a152 1
        struct uvm_object *uobj;
d159 4
a162 4
        if (cmd->ev_len == 0)
                return(0);
        if (cmd->ev_offset & PAGE_MASK)
                return(EINVAL);
d172 3
a174 3
        uobj = uvn_attach((void *) cmd->ev_vp, VM_PROT_READ|VM_PROT_EXECUTE);
        if (uobj == NULL)
                return(ENOMEM);
d180 4
a183 4
	retval = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr, cmd->ev_len, 
		uobj, cmd->ev_offset, 
		UVM_MAPFLAG(cmd->ev_prot, VM_PROT_ALL, UVM_INH_COPY, 
			UVM_ADV_NORMAL, UVM_FLAG_COPYONW|UVM_FLAG_FIXED));
d223 5
a227 5
	error = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr, 
			round_page(cmd->ev_len), NULL, UVM_UNKNOWN_OFFSET, 
			UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_COPY,
			UVM_ADV_NORMAL,
			UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW));
d250 4
a253 4
		return(uvm_map_protect(&p->p_vmspace->vm_map, 
				trunc_page(cmd->ev_addr),
				round_page(cmd->ev_addr + cmd->ev_len),
				cmd->ev_prot, FALSE));
d281 4
a284 5
	error = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr, 
			round_page(cmd->ev_len), NULL, UVM_UNKNOWN_OFFSET, 
			UVM_MAPFLAG(cmd->ev_prot, UVM_PROT_ALL, UVM_INH_COPY,
			UVM_ADV_NORMAL,
			UVM_FLAG_FIXED|UVM_FLAG_COPYONW));
@


1.9
log
@Don't bomb when the length of pagedvn vm_cmd is not page aligned.
Other commands were checked and look safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.8 2000/09/26 14:01:39 art Exp $	*/
d97 2
d100 1
a100 2
	ocnt = evsp->evs_cnt;
	evsp->evs_cnt += ocnt ? ocnt : EXEC_DEFAULT_VMCMD_SETSIZE;
d102 1
a102 1
	/* allocate it */
d105 2
a106 3
	/* free the old struct, if there was one, and record the new one */
	if (ocnt) {
		bcopy(evsp->evs_cmds, nvcp, (ocnt * sizeof(struct exec_vmcmd)));
a107 1
	}
a117 3
	if (evsp->evs_cnt == 0)
		return;

d123 9
a131 2
	evsp->evs_used = evsp->evs_cnt = 0;
	free(evsp->evs_cmds, M_EXEC);
@


1.8
log
@Don't use MALLOC/FREE on variable sized allocations.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.7 1999/11/05 01:18:01 mickey Exp $	*/
a155 1
	/* checks imported from uvm_mmap, needed? */
d161 2
@


1.7
log
@more stack direction fixes; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.6 1999/02/26 05:14:27 art Exp $	*/
d102 2
a103 3
	MALLOC(nvcp, struct exec_vmcmd *, 
	    (evsp->evs_cnt * sizeof(struct exec_vmcmd)), M_EXEC, M_WAITOK);

d107 1
a107 1
		FREE(evsp->evs_cmds, M_EXEC);
d128 1
a128 1
	FREE(evsp->evs_cmds, M_EXEC);
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.10 2001/02/22 16:08:01 art Exp $	*/
d97 1
d99 1
a99 3
	KASSERT(ocnt > 0);
	/* figure out number of entries in new set */
	evsp->evs_cnt += ocnt;
d101 9
a109 6
	/* reallocate the command set */
	nvcp = malloc(evsp->evs_cnt * sizeof(struct exec_vmcmd), M_EXEC,
		      M_WAITOK);
	bcopy(evsp->evs_cmds, nvcp, (ocnt * sizeof(struct exec_vmcmd)));
	if (evsp->evs_cmds != evsp->evs_start)
		free(evsp->evs_cmds, M_EXEC);
d120 3
d128 2
a129 9

	/*
	 * Free old vmcmds and restet the array.
	 */
	evsp->evs_used = 0;
	if (evsp->evs_cmds != evsp->evs_start)
		free(evsp->evs_cmds, M_EXEC);
	evsp->evs_cmds = evsp->evs_start;
	evsp->evs_cnt = EXEC_DEFAULT_VMCMD_SETSIZE;
d157 1
a162 2
		return(EINVAL);
	if (cmd->ev_len & PAGE_MASK)
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.7.2.1 2001/05/14 22:32:39 niklas Exp $	*/
d46 1
d48 1
d104 1
a104 1
	    M_WAITOK);
d151 2
a152 1
	struct uvm_object *uobj;
d159 4
a162 4
	if (cmd->ev_len == 0)
		return(0);
	if (cmd->ev_offset & PAGE_MASK)
		return(EINVAL);
d172 3
a174 3
	uobj = uvn_attach((void *) cmd->ev_vp, VM_PROT_READ|VM_PROT_EXECUTE);
	if (uobj == NULL)
		return(ENOMEM);
d180 4
a183 4
	retval = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr, cmd->ev_len,
	    uobj, cmd->ev_offset,
	    UVM_MAPFLAG(cmd->ev_prot, VM_PROT_ALL, UVM_INH_COPY,
	    UVM_ADV_NORMAL, UVM_FLAG_COPYONW|UVM_FLAG_FIXED));
d198 5
d218 1
d223 10
a232 6
	error = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr,
	    round_page(cmd->ev_len), NULL, UVM_UNKNOWN_OFFSET,
	    UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_COPY,
	    UVM_ADV_NORMAL,
	    UVM_FLAG_FIXED|UVM_FLAG_OVERLAY|UVM_FLAG_COPYONW));

d242 1
d250 4
a253 4
		return(uvm_map_protect(&p->p_vmspace->vm_map,
		    trunc_page(cmd->ev_addr),
		    round_page(cmd->ev_addr + cmd->ev_len),
		    cmd->ev_prot, FALSE));
d257 4
d276 1
d281 10
a290 5
	error = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr,
	    round_page(cmd->ev_len), NULL, UVM_UNKNOWN_OFFSET,
	    UVM_MAPFLAG(cmd->ev_prot, UVM_PROT_ALL, UVM_INH_COPY,
	    UVM_ADV_NORMAL, UVM_FLAG_FIXED|UVM_FLAG_COPYONW));

d294 4
d299 1
@


1.7.2.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 2
d178 1
a178 1
	    uobj, cmd->ev_offset, 0,
d215 1
a215 1
	    round_page(cmd->ev_len), NULL, UVM_UNKNOWN_OFFSET, 0,
d263 1
a263 1
	    round_page(cmd->ev_len), NULL, UVM_UNKNOWN_OFFSET, 0,
@


1.7.2.4
log
@Merge in -current
@
text
@d141 6
d148 1
a148 1
	int error;
a169 1
	VREF(cmd->ev_vp);
d175 1
a175 1
	error = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr, cmd->ev_len,
d180 10
a189 3
	if (error) {
		uobj->pgops->pgo_detach(uobj);
	}
d191 2
a192 1
	return(error);
d209 1
a209 1
		return (0);
d219 1
a219 1
		return (error);
d225 1
a225 1
		return (error);
d234 1
a234 1
		return (uvm_map_protect(&p->p_vmspace->vm_map,
d238 2
a240 1
	return (0);
d257 1
a257 1
		return (0);
d268 1
a268 1
	return (0);
@


1.7.2.5
log
@Merge in trunk
@
text
@a140 6
	/*
	 * note that if you're going to map part of an process as being
	 * paged from a vnode, that vnode had damn well better be marked as
	 * VTEXT.  that's handled in the routine which sets up the vmcmd to
	 * call this routine.
	 */
d142 1
a142 1
	int retval;
d164 1
d170 1
a170 1
	retval = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr, cmd->ev_len,
d175 3
a177 10
	/*
	 * check for error
	 */

	if (retval == KERN_SUCCESS)
		return(0);

	/*
	 * error: detach from object
	 */
d179 1
a179 2
	uobj->pgops->pgo_detach(uobj);
	return(EINVAL);
@


1.7.2.6
log
@Merge in -current from about a week ago
@
text
@d59 1
a59 1
	int	(*proc)(struct proc * p, struct exec_vmcmd *);
@


1.7.2.7
log
@Sync the SMP branch with 3.3
@
text
@d57 1
a57 1
new_vmcmd(evsp, proc, len, addr, vp, offset, prot, flags)
a64 1
	int	flags;
a77 1
	vcp->ev_flags = flags;
d108 2
a109 1
kill_vmcmds(struct exec_vmcmd_set *evsp)
a129 30
int
exec_process_vmcmds(struct proc *p, struct exec_package *epp)
{
	struct exec_vmcmd *base_vc = NULL;
	int error = 0;
	int i;

	for (i = 0; i < epp->ep_vmcmds.evs_used && !error; i++) {
		struct exec_vmcmd *vcp;

		vcp = &epp->ep_vmcmds.evs_cmds[i];

		if (vcp->ev_flags & VMCMD_RELATIVE) {
#ifdef DIAGNOSTIC
			if (base_vc == NULL)
				panic("exec_process_vmcmds: RELATIVE no base");
#endif
			vcp->ev_addr += base_vc->ev_addr;
		}
		error = (*vcp->ev_proc)(p, vcp);
		if (vcp->ev_flags & VMCMD_BASE) {
			base_vc = vcp;
		}
	}

	kill_vmcmds(&epp->ep_vmcmds);

	return (error);
}

d148 1
a148 1
	int error;
d175 1
a175 1
	error = uvm_map(&p->p_vmspace->vm_map, &cmd->ev_addr, cmd->ev_len,
d184 6
a189 6
	if (error) {
		/*
		 * error: detach from object
		 */
		uobj->pgops->pgo_detach(uobj);
	}
d191 2
a192 1
	return (error);
d290 1
a290 2
	epp->ep_maxsaddr = USRSTACK;
	epp->ep_minsaddr = USRSTACK + MAXSSIZ;
d293 1
a294 1
#endif
d310 2
a311 2
	    ((epp->ep_minsaddr - epp->ep_ssize) - epp->ep_maxsaddr),
	    epp->ep_maxsaddr + epp->ep_ssize, NULLVP, 0, VM_PROT_NONE);
d313 2
a314 2
	    epp->ep_maxsaddr, NULLVP, 0,
	    VM_PROT_READ|VM_PROT_WRITE);
d321 1
a321 1
	    VM_PROT_READ|VM_PROT_WRITE);
@


1.7.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.7.2.7 2003/03/28 00:41:26 niklas Exp $	*/
a230 1

d232 3
a234 1
vmcmd_map_readvn(struct proc *p, struct exec_vmcmd *cmd)
a236 1
	vm_prot_t prot;
d240 1
a240 3

	prot = cmd->ev_prot;

d244 1
a244 1
	    UVM_MAPFLAG(prot | UVM_PROT_WRITE, UVM_PROT_ALL, UVM_INH_COPY,
d267 1
a267 1
		    prot, FALSE));
@


1.7.4.1
log
@Pull in patch from current:
Errata (033):
Invalid fields in the exec header could cause a crash.
Fix (art):
Don't bomb when the length of pagedvn vm_cmd is not page aligned.
Other commands were checked and look safe.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.9 2000/11/06 16:19:52 art Exp $	*/
d157 1
a162 2
		return(EINVAL);
	if (cmd->ev_len & PAGE_MASK)
@


1.6
log
@a new way of mapping in exec for uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.5 1998/07/28 00:13:01 millert Exp $	*/
d318 3
d322 1
d337 8
d351 1
@


1.5
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.4 1997/02/24 14:19:56 niklas Exp $	*/
d46 4
d149 47
d199 1
d215 12
d229 1
d239 16
d257 1
d273 12
d287 1
d291 1
d294 3
@


1.4
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_subr.c,v 1.9 1994/12/04 03:10:42 mycroft Exp $	*/
d170 1
a170 1
	    p->p_ucred, (int *)0, p);
@


1.3
log
@round RLIMIT_STACK; problem spotted by jfw@@jfwhome.funhousecom
@
text
@d1 1
@


1.2
log
@use _{NLIST,KERN}_DO_{AOUT,ELF,ECOFF} to select binary types
@
text
@d220 1
a220 1
	epp->ep_ssize = p->p_rlimit[RLIMIT_STACK].rlim_cur;
@


1.1
log
@Initial revision
@
text
@d41 1
d197 44
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
