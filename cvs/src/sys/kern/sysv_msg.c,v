head	1.33;
access;
symbols
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.6
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.4
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.2
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.6
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.23.0.4
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.8
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.6
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.4
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.18.0.6
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.4
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.10
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.4
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.6.0.2
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2016.09.15.02.00.16;	author dlg;	state Exp;
branches;
next	1.32;
commitid	RlO92XR575sygHqm;

1.32
date	2016.08.30.07.40.35;	author dlg;	state Exp;
branches;
next	1.31;
commitid	JbWQykeZEbgGzoLE;

1.31
date	2015.10.07.14.49.04;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	a9ZaMLuMuLRnJvUh;

1.30
date	2014.12.19.05.59.21;	author tedu;	state Exp;
branches;
next	1.29;
commitid	zdJTCwdpqRUwO1SL;

1.29
date	2014.12.10.02.44.47;	author tedu;	state Exp;
branches;
next	1.28;
commitid	tsoJBlEBSyYO22RG;

1.28
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.27;
commitid	QlVV51SZgNFxsXxC;

1.27
date	2014.03.18.06.59.00;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.28.16.58.45;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2012.02.05.18.12.10;	author blambert;	state Exp;
branches;
next	1.24;

1.24
date	2011.05.20.16.06.25;	author blambert;	state Exp;
branches;
next	1.23;

1.23
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.02.12.11.16;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.14.23.08.04;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.13.10.33.14;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.15.11.24.46;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.14.23.40.27;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2002.12.22.04.55.05;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.22.04.52.10;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.27.05;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.12.22.50.12;	author millert;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.06.22.14.14.09;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.16.17.14.35;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.08.09.21.44.24;	author deraadt;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	99.04.18.18.24.40;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.02.04.18.48.25;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.06.11.18.32.14;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.05.11.16.40.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.05.11.06.13.46;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.20.05;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches;
next	;

1.8.4.1
date	2001.07.04.10.48.38;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.8.4.4;

1.8.4.4
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.8.4.5;

1.8.4.5
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.33
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@/*	$OpenBSD: sysv_msg.c,v 1.32 2016/08/30 07:40:35 dlg Exp $	*/
/*	$NetBSD: sysv_msg.c,v 1.19 1996/02/09 19:00:18 christos Exp $	*/
/*
 * Copyright (c) 2009 Bret S. Lambert <blambert@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Implementation of SVID messages
 *
 * Author:  Daniel Boulet
 *
 * Copyright 1993 Daniel Boulet and RTMX Inc.
 *
 * This system call was implemented by Daniel Boulet under contract from RTMX.
 *
 * Redistribution and use in source forms, with and without modification,
 * are permitted provided that this entire comment appears intact.
 *
 * Redistribution in binary form may occur without any restrictions.
 * Obviously, it would be nice if you gave credit where credit is due
 * but requiring it would be too onerous.
 *
 * This software is provided ``AS IS'' without any warranties of any kind.
 */

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/mount.h>
#include <sys/msg.h>
#include <sys/pool.h>
#include <sys/proc.h>
#include <sys/queue.h>
#include <sys/syscallargs.h>
#include <sys/sysctl.h>
#include <sys/systm.h>
#include <sys/uio.h>

struct que *que_create(key_t, struct ucred *, int);
struct que *que_lookup(int);
struct que *que_key_lookup(key_t);
void que_wakewriters(void);
void que_free(struct que *);
struct msg *msg_create(struct que *);
void msg_free(struct msg *);
void msg_enqueue(struct que *, struct msg *, struct proc *);
void msg_dequeue(struct que *, struct msg *, struct proc *);
struct msg *msg_lookup(struct que *, int);
int msg_copyin(struct msg *, const char *, size_t, struct proc *);
int msg_copyout(struct msg *, char *, size_t *, struct proc *);

struct	pool sysvmsgpl;
struct	msginfo msginfo;

TAILQ_HEAD(, que) msg_queues;

int num_ques;
int num_msgs;
int sequence;
int maxmsgs;

void
msginit(void)
{
	msginfo.msgmax = MSGMAX;
	msginfo.msgmni = MSGMNI;
	msginfo.msgmnb = MSGMNB;
	msginfo.msgtql = MSGTQL;
	msginfo.msgssz = MSGSSZ;
	msginfo.msgseg = MSGSEG;

	pool_init(&sysvmsgpl, sizeof(struct msg), 0, IPL_NONE, PR_WAITOK,
	    "sysvmsgpl", NULL);

	TAILQ_INIT(&msg_queues);

	num_ques = 0;
	num_msgs = 0;
	sequence = 1;
	maxmsgs = 0;
}

int
sys_msgctl(struct proc *p, void *v, register_t *retval)
{
	struct sys_msgctl_args /* {
		syscallarg(int) msqid;
		syscallarg(int) cmd;
		syscallarg(struct msqid_ds *) buf;
	} */ *uap = v;

	return (msgctl1(p, SCARG(uap, msqid), SCARG(uap, cmd),
	    (caddr_t)SCARG(uap, buf), copyin, copyout));
}

int
msgctl1(struct proc *p, int msqid, int cmd, caddr_t buf,
    int (*ds_copyin)(const void *, void *, size_t),
    int (*ds_copyout)(const void *, void *, size_t))
{
	struct msqid_ds tmp;
	struct ucred *cred = p->p_ucred;
	struct que *que;
	int error = 0;

	if ((que = que_lookup(msqid)) == NULL)
		return (EINVAL);

	QREF(que);

	switch (cmd) {

	case IPC_RMID:
		if ((error = ipcperm(cred, &que->msqid_ds.msg_perm, IPC_M)))
			goto out;

		TAILQ_REMOVE(&msg_queues, que, que_next);
		que->que_flags |= MSGQ_DYING;

		/* lose interest in the queue and wait for others to too */
		if (--que->que_references > 0) {
			wakeup(que);
			tsleep(&que->que_references, PZERO, "msgqrm", 0);
		}

		que_free(que);

		return (0);

	case IPC_SET:
		if ((error = ipcperm(cred, &que->msqid_ds.msg_perm, IPC_M)))
			goto out;
		if ((error = ds_copyin(buf, &tmp, sizeof(struct msqid_ds))))
			goto out;

		/* only superuser can bump max bytes in queue */
		if (tmp.msg_qbytes > que->msqid_ds.msg_qbytes &&
		    cred->cr_uid != 0) {
			error = EPERM;
			goto out;
		}

		/* restrict max bytes in queue to system limit */
		if (tmp.msg_qbytes > msginfo.msgmnb)
			tmp.msg_qbytes = msginfo.msgmnb;

		/* can't reduce msg_bytes to 0 */
		if (tmp.msg_qbytes == 0) {
			error = EINVAL;		/* non-standard errno! */
			goto out;
		}

		que->msqid_ds.msg_perm.uid = tmp.msg_perm.uid;
		que->msqid_ds.msg_perm.gid = tmp.msg_perm.gid;
		que->msqid_ds.msg_perm.mode =
		    (que->msqid_ds.msg_perm.mode & ~0777) |
		    (tmp.msg_perm.mode & 0777);
		que->msqid_ds.msg_qbytes = tmp.msg_qbytes;
		que->msqid_ds.msg_ctime = time_second;
		break;

	case IPC_STAT:
		if ((error = ipcperm(cred, &que->msqid_ds.msg_perm, IPC_R)))
			goto out;
		error = ds_copyout(&que->msqid_ds, buf,
		    sizeof(struct msqid_ds));
		break;

	default:
		error = EINVAL;
		break;
	}
out:
	QRELE(que);

	return (error);
}

int
sys_msgget(struct proc *p, void *v, register_t *retval)
{
	struct sys_msgget_args /* {
		syscallarg(key_t) key;
		syscallarg(int) msgflg;
	} */ *uap = v;
	struct ucred *cred = p->p_ucred;
	struct que *que;
	key_t key = SCARG(uap, key);
	int msgflg = SCARG(uap, msgflg);
	int error = 0;

again:
	if (key != IPC_PRIVATE) {
		que = que_key_lookup(key);
		if (que) {
			if ((msgflg & IPC_CREAT) && (msgflg & IPC_EXCL))
				return (EEXIST);
			if ((error = ipcperm(cred, &que->msqid_ds.msg_perm,
			    msgflg & 0700)))
				return (error);
			goto found;
		}
	}

	/* don't create a new message queue if the caller doesn't want to */
	if (key != IPC_PRIVATE && !(msgflg & IPC_CREAT))
		return (ENOENT);

	/* enforce limits on the maximum number of message queues */
	if (num_ques >= msginfo.msgmni)
		return (ENOSPC);

	/*
	 * if que_create returns NULL, it means that a que with an identical
	 * key was created while this process was sleeping, so start over
	 */
	if ((que = que_create(key, cred, msgflg & 0777)) == NULL)
		goto again;

found:
	*retval = IXSEQ_TO_IPCID(que->que_ix, que->msqid_ds.msg_perm);
	return (error);
}

#define	MSGQ_SPACE(q)	((q)->msqid_ds.msg_qbytes - (q)->msqid_ds.msg_cbytes)

int
sys_msgsnd(struct proc *p, void *v, register_t *retval)
{
	struct sys_msgsnd_args /* {
		syscallarg(int) msqid;
		syscallarg(const void *) msgp;
		syscallarg(size_t) msgsz;
		syscallarg(int) msgflg;
	} */ *uap = v;
	struct ucred *cred = p->p_ucred;
	struct que *que;
	struct msg *msg;
	size_t msgsz = SCARG(uap, msgsz);
	int error;

	if ((que = que_lookup(SCARG(uap, msqid))) == NULL)
		return (EINVAL);

	if (msgsz > que->msqid_ds.msg_qbytes || msgsz > msginfo.msgmax)
		return (EINVAL);

	if ((error = ipcperm(cred, &que->msqid_ds.msg_perm, IPC_W)))
		return (error);

	QREF(que);

	while (MSGQ_SPACE(que) < msgsz || num_msgs >= msginfo.msgtql) {

		if (SCARG(uap, msgflg) & IPC_NOWAIT) {
			error = EAGAIN;
			goto out;
		}

		/* notify world that process may wedge here */
		if (num_msgs >= msginfo.msgtql)
			maxmsgs = 1;

		que->que_flags |= MSGQ_WRITERS;
		if ((error = tsleep(que, PZERO|PCATCH, "msgwait", 0)))
			goto out;

		if (que->que_flags & MSGQ_DYING) {
			error = EIDRM;
			goto out;
		}
	}

	/* if msg_create returns NULL, the queue is being removed */
	if ((msg = msg_create(que)) == NULL) {
		error = EIDRM;
		goto out;
	}

	/* msg_copyin frees msg on error */
	if ((error = msg_copyin(msg, (const char *)SCARG(uap, msgp), msgsz, p)))
		goto out;

	msg_enqueue(que, msg, p);

	if (que->que_flags & MSGQ_READERS) {
		que->que_flags &= ~MSGQ_READERS;
		wakeup(que);
	}

	if (que->que_flags & MSGQ_DYING) {
		error = EIDRM;
		wakeup(que);
	}
out:
	QRELE(que);

	return (error);
}

int
sys_msgrcv(struct proc *p, void *v, register_t *retval)
{
	struct sys_msgrcv_args /* {
		syscallarg(int) msqid;
		syscallarg(void *) msgp;
		syscallarg(size_t) msgsz;
		syscallarg(long) msgtyp;
		syscallarg(int) msgflg;
	} */ *uap = v;
	struct ucred *cred = p->p_ucred;
	char *msgp = SCARG(uap, msgp);
	struct que *que;
	struct msg *msg;
	size_t msgsz = SCARG(uap, msgsz);
	long msgtyp = SCARG(uap, msgtyp);
	int error;

	if ((que = que_lookup(SCARG(uap, msqid))) == NULL)
		return (EINVAL);

	if ((error = ipcperm(cred, &que->msqid_ds.msg_perm, IPC_R)))
		return (error);

	QREF(que);

	/* msg_lookup handles matching; sleeping gets handled here */
	while ((msg = msg_lookup(que, msgtyp)) == NULL) {

		if (SCARG(uap, msgflg) & IPC_NOWAIT) {
			error = ENOMSG;
			goto out;
		}

		que->que_flags |= MSGQ_READERS;
		if ((error = tsleep(que, PZERO|PCATCH, "msgwait", 0)))
			goto out;

		/* make sure the queue still alive */
		if (que->que_flags & MSGQ_DYING) {
			error = EIDRM;
			goto out;
		}
	}

	/* if msg_copyout fails, keep the message around so it isn't lost */
	if ((error = msg_copyout(msg, msgp, &msgsz, p)))
		goto out;

	msg_dequeue(que, msg, p);
	msg_free(msg);

	if (que->que_flags & MSGQ_WRITERS) {
		que->que_flags &= ~MSGQ_WRITERS;
		wakeup(que);
	}

	/* ensure processes waiting on the global limit don't wedge */
	if (maxmsgs) {
		maxmsgs = 0;
		que_wakewriters();
	}

	*retval = msgsz;
out:
	QRELE(que);

	return (error);
}

/*
 * que management functions
 */

struct que *
que_create(key_t key, struct ucred *cred, int mode)
{
	struct que *que, *que2;
	int nextix = 1;

	que = malloc(sizeof(*que), M_TEMP, M_WAIT|M_ZERO);

	/* if malloc slept, a queue with the same key may have been created */
	if (que_key_lookup(key)) {
		free(que, M_TEMP, sizeof *que);
		return (NULL);
	}

	/* find next available "index" */
	TAILQ_FOREACH(que2, &msg_queues, que_next) {
		if (nextix < que2->que_ix)
			break;
		nextix = que2->que_ix + 1;
	}
	que->que_ix = nextix;

	que->msqid_ds.msg_perm.key = key;
	que->msqid_ds.msg_perm.cuid = cred->cr_uid;
	que->msqid_ds.msg_perm.uid = cred->cr_uid;
	que->msqid_ds.msg_perm.cgid = cred->cr_gid;
	que->msqid_ds.msg_perm.gid = cred->cr_gid;
	que->msqid_ds.msg_perm.mode = mode & 0777;
	que->msqid_ds.msg_perm.seq = ++sequence & 0x7fff;
	que->msqid_ds.msg_qbytes = msginfo.msgmnb;
	que->msqid_ds.msg_ctime = time_second;

	TAILQ_INIT(&que->que_msgs);

	/* keep queues in "index" order */
	if (que2)
		TAILQ_INSERT_BEFORE(que2, que, que_next);
	else
		TAILQ_INSERT_TAIL(&msg_queues, que, que_next);
	num_ques++;

	return (que);
}

struct que *
que_lookup(int id)
{
	struct que *que;

	TAILQ_FOREACH(que, &msg_queues, que_next)
		if (que->que_ix == IPCID_TO_IX(id))
			break;

	/* don't return queues marked for removal */
	if (que && que->que_flags & MSGQ_DYING)
		return (NULL);

	return (que);
}

struct que *
que_key_lookup(key_t key)
{
	struct que *que;

	if (key == IPC_PRIVATE)
		return (NULL);

	TAILQ_FOREACH(que, &msg_queues, que_next)
		if (que->msqid_ds.msg_perm.key == key)
			break;

	/* don't return queues marked for removal */
	if (que && que->que_flags & MSGQ_DYING)
		return (NULL);

	return (que);
}

void
que_wakewriters(void)
{
	struct que *que;

	TAILQ_FOREACH(que, &msg_queues, que_next) {
		if (que->que_flags & MSGQ_WRITERS) {
			que->que_flags &= ~MSGQ_WRITERS;
			wakeup(que);
		}
	}
}

void
que_free(struct que *que)
{
	struct msg *msg;
#ifdef DIAGNOSTIC
	if (que->que_references > 0)
		panic("freeing message queue with active references");
#endif

	while ((msg = TAILQ_FIRST(&que->que_msgs))) {
		TAILQ_REMOVE(&que->que_msgs, msg, msg_next);
		msg_free(msg);
	}
	free(que, M_TEMP, sizeof *que);
	num_ques--;
}

/*
 * msg management functions
 */

struct msg *
msg_create(struct que *que)
{
	struct msg *msg;

	msg = pool_get(&sysvmsgpl, PR_WAITOK|PR_ZERO);

	/* if the queue has died during allocation, return NULL */
	if (que->que_flags & MSGQ_DYING) {
		pool_put(&sysvmsgpl, msg);
		wakeup(que);
		return(NULL);
	}

	num_msgs++;

	return (msg);
}

struct msg *
msg_lookup(struct que *que, int msgtyp)
{
	struct msg *msg;

	/*
	 * Three different matches are performed based on the value of msgtyp:
	 * 1) msgtyp > 0 => match exactly
	 * 2) msgtyp = 0 => match any
	 * 3) msgtyp < 0 => match any up to absolute value of msgtyp
	 */
	TAILQ_FOREACH(msg, &que->que_msgs, msg_next)
		if (msgtyp == 0 || msgtyp == msg->msg_type ||
		    (msgtyp < 0 && -msgtyp <= msg->msg_type))
			break;

	return (msg);
}

void
msg_free(struct msg *msg)
{
	m_freem(msg->msg_data);
	pool_put(&sysvmsgpl, msg);
	num_msgs--;
}

void
msg_enqueue(struct que *que, struct msg *msg, struct proc *p)
{
	que->msqid_ds.msg_cbytes += msg->msg_len;
	que->msqid_ds.msg_qnum++;
	que->msqid_ds.msg_lspid = p->p_p->ps_pid;
	que->msqid_ds.msg_stime = time_second;

	TAILQ_INSERT_TAIL(&que->que_msgs, msg, msg_next);
}

void
msg_dequeue(struct que *que, struct msg *msg, struct proc *p)
{
	que->msqid_ds.msg_cbytes -= msg->msg_len;
	que->msqid_ds.msg_qnum--;
	que->msqid_ds.msg_lrpid = p->p_p->ps_pid;
	que->msqid_ds.msg_rtime = time_second;

	TAILQ_REMOVE(&que->que_msgs, msg, msg_next);
}

/*
 * The actual I/O routines. A note concerning the layout of SysV msg buffers:
 *
 * The data to be copied is laid out as a single userspace buffer, with a
 * long preceding an opaque buffer of len bytes. The long value ends
 * up being the message type, which needs to be copied separately from
 * the buffer data, which is stored in in mbufs.
 */

int
msg_copyin(struct msg *msg, const char *ubuf, size_t len, struct proc *p)
{
	struct mbuf **mm, *m;
	size_t xfer;
	int error;

	if (msg == NULL)
		panic ("msg NULL");

	if ((error = copyin(ubuf, &msg->msg_type, sizeof(long)))) {
		msg_free(msg);
		return (error);
	}

	if (msg->msg_type < 0) {
		msg_free(msg);
		return (EINVAL);
	}

	ubuf += sizeof(long);

	msg->msg_len = 0;
	mm = &msg->msg_data;

	while (msg->msg_len < len) {
		m = m_get(M_WAIT, MT_DATA);
		if (len >= MINCLSIZE) {
			MCLGET(m, M_WAIT);
			xfer = min(len, MCLBYTES);
		} else {
			xfer = min(len, MLEN);
		}
		m->m_len = xfer;
		msg->msg_len += xfer;
		*mm = m;
		mm = &m->m_next;
	}

	for (m = msg->msg_data; m; m = m->m_next) {
		if ((error = copyin(ubuf, mtod(m, void *), m->m_len))) {
			msg_free(msg);
			return (error);
		}
		ubuf += m->m_len;
	}

	return (0);
}

int
msg_copyout(struct msg *msg, char *ubuf, size_t *len, struct proc *p)
{
	struct mbuf *m;
	size_t xfer;
	int error;

#ifdef DIAGNOSTIC
	if (msg->msg_len > MSGMAX)
		panic("SysV message longer than MSGMAX");
#endif

	/* silently truncate messages too large for user buffer */
	xfer = min(*len, msg->msg_len);

	if ((error = copyout(&msg->msg_type, ubuf, sizeof(long))))
		return (error);

	ubuf += sizeof(long);
	*len = xfer;

	for (m = msg->msg_data; m; m = m->m_next) {
		if ((error = copyout(mtod(m, void *), ubuf, m->m_len)))
			return (error);
		ubuf += m->m_len;
	}

	return (0);
}

int
sysctl_sysvmsg(int *name, u_int namelen, void *where, size_t *sizep)
{
	struct msg_sysctl_info *info;
	struct que *que;
	size_t infolen;
	int error;

	switch (*name) {
	case KERN_SYSVIPC_MSG_INFO:

		if (namelen != 1)
			return (ENOTDIR);

		/*
		 * The userland ipcs(1) utility expects to be able
		 * to iterate over at least msginfo.msgmni queues,
		 * even if those queues don't exist. This is an
		 * artifact of the previous implementation of
		 * message queues; for now, emulate this behavior
		 * until a more thorough fix can be made.
		 */
		infolen = sizeof(msginfo) +
		    msginfo.msgmni * sizeof(struct msqid_ds);
		if (where == NULL) {
			*sizep = infolen;
			return (0);
		}

		/*
		 * More special-casing due to previous implementation:
		 * if the caller just wants the msginfo struct, then
		 * sizep will point to the value sizeof(struct msginfo).
		 * In that case, only copy out the msginfo struct to
		 * the caller.
		 */
		if (*sizep == sizeof(struct msginfo))
			return (copyout(&msginfo, where, sizeof(msginfo)));

		info = malloc(infolen, M_TEMP, M_WAIT|M_ZERO);

		/* if the malloc slept, this may have changed */
		infolen = sizeof(msginfo) +
		    msginfo.msgmni * sizeof(struct msqid_ds);

		if (*sizep < infolen) {
			free(info, M_TEMP, 0);
			return (ENOMEM);
		}

		memcpy(&info->msginfo, &msginfo, sizeof(struct msginfo));

		/*
		 * Special case #3: the previous array-based implementation
		 * exported the array indices and userland has come to rely
		 * upon these indices, so keep behavior consisitent.
		 */
		TAILQ_FOREACH(que, &msg_queues, que_next)
			memcpy(&info->msgids[que->que_ix], &que->msqid_ds,
			    sizeof(struct msqid_ds));

		error = copyout(info, where, infolen);

		free(info, M_TEMP, 0);

		return (error);

	default:
		return (EINVAL);
	}
}
@


1.32
log
@pool_setipl

ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.31 2015/10/07 14:49:04 deraadt Exp $	*/
d83 2
a84 3
	pool_init(&sysvmsgpl, sizeof(struct msg), 0, 0, PR_WAITOK, "sysvmsgpl",
	    NULL);
	pool_setipl(&sysvmsgpl, IPL_NONE);
@


1.31
log
@easy free sizes; ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.30 2014/12/19 05:59:21 tedu Exp $	*/
d85 1
@


1.30
log
@start retiring the nointr allocator. specify PR_WAITOK as a flag as a
marker for which pools are not interrupt safe. ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.29 2014/12/10 02:44:47 tedu Exp $	*/
d396 1
a396 1
		free(que, M_TEMP, 0);
d491 1
a491 1
	free(que, M_TEMP, 0);
@


1.29
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.28 2014/07/12 18:43:32 tedu Exp $	*/
d83 2
a84 2
	pool_init(&sysvmsgpl, sizeof(struct msg), 0, 0, 0, "sysvmsgpl",
	    &pool_allocator_nointr);
@


1.28
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.27 2014/03/18 06:59:00 guenther Exp $	*/
d706 1
a706 1
		bcopy(&msginfo, &info->msginfo, sizeof(struct msginfo));
d714 1
a714 1
			bcopy(&que->msqid_ds, &info->msgids[que->que_ix],
@


1.27
log
@In prep for killing ps_mainproc, use pr->ps_pid instead of
pr->ps_mainproc->p_pid to get the PID.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.26 2013/03/28 16:58:45 deraadt Exp $	*/
d396 1
a396 1
		free(que, M_TEMP);
d491 1
a491 1
	free(que, M_TEMP);
d702 1
a702 1
			free(info, M_TEMP);
d719 1
a719 1
		free(info, M_TEMP);
@


1.26
log
@sys/param.h gets you sys/types.h automatically
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.25 2012/02/05 18:12:10 blambert Exp $	*/
d550 1
a550 1
	que->msqid_ds.msg_lspid = p->p_p->ps_mainproc->p_pid;
d561 1
a561 1
	que->msqid_ds.msg_lrpid = p->p_p->ps_mainproc->p_pid;
@


1.25
log
@Fix SysV message queue identifiers.

Found and diagnosed by Alexis Fouilhe hyjial at gmail dot com

input miod@@ guenther@@
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.24 2011/05/20 16:06:25 blambert Exp $	*/
a37 1
#include <sys/types.h>
@


1.24
log
@Avoid panic'ing on a bad pointer passed in by callers of msgsnd;
uiomove() will do the right thing in that case.

"This fix is right" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.23 2010/01/14 23:12:11 schwarze Exp $	*/
d233 1
a233 1
	*retval = que->que_id;
d390 2
a391 1
	struct que *que;
d401 8
d421 5
a425 1
	TAILQ_INSERT_TAIL(&msg_queues, que, que_next);
d437 1
a437 1
		if (que->que_id == id)
d527 1
a527 1
	 * 2> msgtyp = 0 => match any
d663 1
a663 1
	int error, i = 0;
d709 5
d715 1
a715 1
			bcopy(&que->msqid_ds, &info->msgids[i++],
@


1.23
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.22 2009/08/09 10:40:17 blambert Exp $	*/
a252 3

	if (SCARG(uap, msgp) == NULL)
		panic("NULL userbuffer");
@


1.22
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.21 2009/06/02 12:11:16 guenther Exp $	*/
d563 1
a563 1
 * up being the message type, which needs to be copied seperately from
@


1.21
log
@msgctl(), shmctl(), semctl() all have operations that are supposed
to return pids, not thread ids, so record the former when performing
operations.

ok blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.20 2007/10/14 23:08:04 fgsch Exp $	*/
d3 15
a17 1

d38 1
a38 4
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/msg.h>
d40 1
a40 1

d42 4
d47 3
d51 22
a72 15
#ifdef MSG_DEBUG
#define	DPRINTF(x)	printf x
#else
#define	DPRINTF(x)
#endif

int nfree_msgmaps;		/* # of free map entries */
short free_msgmaps;		/* head of linked list of free map entries */
struct msg *free_msghdrs;	/* list of free msg headers */
char *msgpool;			/* MSGMAX byte long msg buffer pool */
struct msgmap *msgmaps;		/* MSGSEG msgmap structures */
struct msg *msghdrs;		/* MSGTQL msg headers */
struct msqid_ds *msqids;	/* MSGMNI msqid_ds struct's */

void msg_freehdr(struct msg *);
d77 16
a92 74
	int i;

	/*
	 * msginfo.msgssz should be a power of two for efficiency reasons.
	 * It is also pretty silly if msginfo.msgssz is less than 8
	 * or greater than about 256 so ...
	 */

	i = 8;
	while (i < 1024 && i != msginfo.msgssz)
		i <<= 1;

    	if (i != msginfo.msgssz)
		panic("msginfo.msgssz %d not a small power of 2", msginfo.msgssz);
	if (msginfo.msgseg > 32767)
		panic("msginfo.msgseg %d > 32767", msginfo.msgseg);

	if (msgmaps == NULL)
		panic("msgmaps is NULL");

	for (i = 0; i < msginfo.msgseg; i++) {
		if (i > 0)
			msgmaps[i-1].next = i;
		msgmaps[i].next = -1;	/* implies entry is available */
	}
	free_msgmaps = 0;
	nfree_msgmaps = msginfo.msgseg;

	if (msghdrs == NULL)
		panic("msghdrs is NULL");

	for (i = 0; i < msginfo.msgtql; i++) {
		msghdrs[i].msg_type = 0;
		if (i > 0)
			msghdrs[i-1].msg_next = &msghdrs[i];
		msghdrs[i].msg_next = NULL;
    	}
	free_msghdrs = &msghdrs[0];

	if (msqids == NULL)
		panic("msqids is NULL");

	for (i = 0; i < msginfo.msgmni; i++) {
		msqids[i].msg_qbytes = 0;	/* implies entry is available */
		msqids[i].msg_perm.seq = 0;	/* reset to a known value */
	}
}

void
msg_freehdr(struct msg *msghdr)
{
	while (msghdr->msg_ts > 0) {
		short next;

#ifdef DIAGNOSTIC
		if (msghdr->msg_spot < 0 || msghdr->msg_spot >= msginfo.msgseg)
			panic("msghdr->msg_spot out of range");
#endif
		next = msgmaps[msghdr->msg_spot].next;
		msgmaps[msghdr->msg_spot].next = free_msgmaps;
		free_msgmaps = msghdr->msg_spot;
		nfree_msgmaps++;
		msghdr->msg_spot = next;
		if (msghdr->msg_ts >= msginfo.msgssz)
			msghdr->msg_ts -= msginfo.msgssz;
		else
			msghdr->msg_ts = 0;
	}
#ifdef DIAGNOSTIC
	if (msghdr->msg_spot != -1)
		panic("msghdr->msg_spot != -1");
#endif
	msghdr->msg_next = free_msghdrs;
	free_msghdrs = msghdr;
d113 1
d115 2
a116 3
	struct msqid_ds msqbuf, *msqptr;
	struct msg *msghdr;
	int ix, error = 0;
d118 2
a119 1
	DPRINTF(("call to msgctl(%d, %d, %p)\n", msqid, cmd, buf));
d121 1
a121 1
	ix = IPCID_TO_IX(msqid);
d123 1
a123 5
	if (ix < 0 || ix >= msginfo.msgmni) {
		DPRINTF(("msqid (%d) out of range (0<=msqid<%d)\n", ix,
		    msginfo.msgmni));
		return (EINVAL);
	}
d125 3
a127 1
	msqptr = &msqids[ix];
d129 2
a130 8
	if (msqptr->msg_qbytes == 0) {
		DPRINTF(("no such msqid\n"));
		return (EINVAL);
	}
	if (msqptr->msg_perm.seq != IPCID_TO_SEQ(msqid)) {
		DPRINTF(("wrong sequence number\n"));
		return (EINVAL);
	}
d132 4
a135 15
	switch (cmd) {
	case IPC_RMID:
		if ((error = ipcperm(cred, &msqptr->msg_perm, IPC_M)) != 0)
			return (error);
		/* Free the message headers */
		msghdr = msqptr->msg_first;
		while (msghdr != NULL) {
			struct msg *msghdr_tmp;

			/* Free the segments of each message */
			msqptr->msg_cbytes -= msghdr->msg_ts;
			msqptr->msg_qnum--;
			msghdr_tmp = msghdr;
			msghdr = msghdr->msg_next;
			msg_freehdr(msghdr_tmp);
d138 3
a140 9
#ifdef DIAGNOSTIC
		if (msqptr->msg_cbytes != 0)
			panic("sys_msgctl: msg_cbytes is screwed up");
		if (msqptr->msg_qnum != 0)
			panic("sys_msgctl: msg_qnum is screwed up");
#endif
		msqptr->msg_qbytes = 0;	/* Mark it as free */
		wakeup(msqptr);
		break;
d143 29
a171 23
		if ((error = ipcperm(cred, &msqptr->msg_perm, IPC_M)))
			return (error);
		if ((error = ds_copyin(buf, &msqbuf, sizeof(msqbuf))) != 0)
			return (error);
		if (msqbuf.msg_qbytes > msqptr->msg_qbytes &&
		    cred->cr_uid != 0)
			return (EPERM);
		if (msqbuf.msg_qbytes > msginfo.msgmnb) {
			DPRINTF(("can't increase msg_qbytes beyond %d "
			    "(truncating)\n", msginfo.msgmnb));
			/* silently restrict qbytes to system limit */
			msqbuf.msg_qbytes = msginfo.msgmnb;
		}
		if (msqbuf.msg_qbytes == 0) {
			DPRINTF(("can't reduce msg_qbytes to 0\n"));
			return (EINVAL);	/* non-standard errno! */
		}
		msqptr->msg_perm.uid = msqbuf.msg_perm.uid;
		msqptr->msg_perm.gid = msqbuf.msg_perm.gid;
		msqptr->msg_perm.mode = (msqptr->msg_perm.mode & ~0777) |
		    (msqbuf.msg_perm.mode & 0777);
		msqptr->msg_qbytes = msqbuf.msg_qbytes;
		msqptr->msg_ctime = time_second;
d175 4
a178 5
		if ((error = ipcperm(cred, &msqptr->msg_perm, IPC_R))) {
			DPRINTF(("requester doesn't have read access\n"));
			return (error);
		}
		error = ds_copyout(msqptr, buf, sizeof(struct msqid_ds));
d182 2
a183 2
		DPRINTF(("invalid command %d\n", cmd));
		return (EINVAL);
d185 3
d198 3
a200 2
	int msqid, eval;
	int key = SCARG(uap, key);
d202 1
a202 4
	struct ucred *cred = p->p_ucred;
	struct msqid_ds *msqptr = NULL;

	DPRINTF(("msgget(0x%x, 0%o)\n", key, msgflg));
d204 1
d206 3
a208 10
		for (msqid = 0; msqid < msginfo.msgmni; msqid++) {
			msqptr = &msqids[msqid];
			if (msqptr->msg_qbytes != 0 &&
			    msqptr->msg_perm.key == key)
				break;
		}
		if (msqid < msginfo.msgmni) {
			DPRINTF(("found public key\n"));
			if ((msgflg & IPC_CREAT) && (msgflg & IPC_EXCL)) {
				DPRINTF(("not exclusive\n"));
d210 3
a212 6
			}
			if ((eval = ipcperm(cred, &msqptr->msg_perm, msgflg & 0700 ))) {
				DPRINTF(("requester doesn't have 0%o access\n",
				    msgflg & 0700));
				return (eval);
			}
d217 2
a218 39
	DPRINTF(("need to allocate the msqid_ds\n"));
	if (key == IPC_PRIVATE || (msgflg & IPC_CREAT)) {
		for (msqid = 0; msqid < msginfo.msgmni; msqid++) {
			/*
			 * Look for an unallocated and unlocked msqid_ds.
			 * msqid_ds's can be locked by msgsnd or msgrcv while
			 * they are copying the message in/out.  We can't
			 * re-use the entry until they release it.
			 */
			msqptr = &msqids[msqid];
			if (msqptr->msg_qbytes == 0 &&
			    (msqptr->msg_perm.mode & MSG_LOCKED) == 0)
				break;
		}
		if (msqid == msginfo.msgmni) {
			DPRINTF(("no more msqid_ds's available\n"));
			return (ENOSPC);	
		}
		DPRINTF(("msqid %d is available\n", msqid));
		msqptr->msg_perm.key = key;
		msqptr->msg_perm.cuid = cred->cr_uid;
		msqptr->msg_perm.uid = cred->cr_uid;
		msqptr->msg_perm.cgid = cred->cr_gid;
		msqptr->msg_perm.gid = cred->cr_gid;
		msqptr->msg_perm.mode = (msgflg & 0777);
		/* Make sure that the returned msqid is unique */
		msqptr->msg_perm.seq = (msqptr->msg_perm.seq + 1) & 0x7fff;
		msqptr->msg_first = NULL;
		msqptr->msg_last = NULL;
		msqptr->msg_cbytes = 0;
		msqptr->msg_qnum = 0;
		msqptr->msg_qbytes = msginfo.msgmnb;
		msqptr->msg_lspid = 0;
		msqptr->msg_lrpid = 0;
		msqptr->msg_stime = 0;
		msqptr->msg_rtime = 0;
		msqptr->msg_ctime = time_second;
	} else {
		DPRINTF(("didn't find it and wasn't asked to create it\n"));
d220 11
a230 1
	}
d233 2
a234 3
	/* Construct the unique msqid */
	*retval = IXSEQ_TO_IPCID(msqid, msqptr->msg_perm);
	return (0);
d237 2
d248 3
a250 2
	int msqid = SCARG(uap, msqid);
	const char *user_msgp = SCARG(uap, msgp);
d252 9
a260 15
	int msgflg = SCARG(uap, msgflg);
	int segs_needed, eval;
	struct ucred *cred = p->p_ucred;
	struct msqid_ds *msqptr;
	struct msg *msghdr;
	short next;

	DPRINTF(("call to msgsnd(%d, %p, %d, %d)\n", msqid, user_msgp, msgsz,
	    msgflg));

	msqid = IPCID_TO_IX(msqid);

	if (msqid < 0 || msqid >= msginfo.msgmni) {
		DPRINTF(("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
		    msginfo.msgmni));
d262 25
d289 4
a292 4
	msqptr = &msqids[msqid];
	if (msqptr->msg_qbytes == 0) {
		DPRINTF(("no such message queue id\n"));
		return (EINVAL);
d294 10
a303 3
	if (msqptr->msg_perm.seq != IPCID_TO_SEQ(SCARG(uap, msqid))) {
		DPRINTF(("wrong sequence number\n"));
		return (EINVAL);
d306 3
a308 3
	if ((eval = ipcperm(cred, &msqptr->msg_perm, IPC_W))) {
		DPRINTF(("requester doesn't have write access\n"));
		return (eval);
d310 31
d342 2
a343 5
	segs_needed = (msgsz + msginfo.msgssz - 1) / msginfo.msgssz;
	DPRINTF(("msgsz=%d, msgssz=%d, segs_needed=%d\n", msgsz,
	    msginfo.msgssz, segs_needed));
	for (;;) {
		int need_more_resources = 0;
d345 4
a348 4
		/*
		 * check msgsz [cannot be negative since it is unsigned]
		 * (inside this loop in case msg_qbytes changes while we sleep)
		 */
d350 3
a352 60
		if (msgsz > msqptr->msg_qbytes) {
			DPRINTF(("msgsz > msqptr->msg_qbytes\n"));
			return (EINVAL);
		}

		if (msqptr->msg_perm.mode & MSG_LOCKED) {
			DPRINTF(("msqid is locked\n"));
			need_more_resources = 1;
		}
		if (msgsz + msqptr->msg_cbytes > msqptr->msg_qbytes) {
			DPRINTF(("msgsz + msg_cbytes > msg_qbytes\n"));
			need_more_resources = 1;
		}
		if (segs_needed > nfree_msgmaps) {
			DPRINTF(("segs_needed > nfree_msgmaps\n"));
			need_more_resources = 1;
		}
		if (free_msghdrs == NULL) {
			DPRINTF(("no more msghdrs\n"));
			need_more_resources = 1;
		}

		if (need_more_resources) {
			int we_own_it;

			if ((msgflg & IPC_NOWAIT) != 0) {
				DPRINTF(("need more resources but caller "
				    "doesn't want to wait\n"));
				return (EAGAIN);
			}

			if ((msqptr->msg_perm.mode & MSG_LOCKED) != 0) {
				DPRINTF(("we don't own the msqid_ds\n"));
				we_own_it = 0;
			} else {
				/* Force later arrivals to wait for our
				   request */
				DPRINTF(("we own the msqid_ds\n"));
				msqptr->msg_perm.mode |= MSG_LOCKED;
				we_own_it = 1;
			}
			DPRINTF(("goodnight\n"));
			eval = tsleep(msqptr, (PZERO - 4) | PCATCH,
			    "msgwait", 0);
			DPRINTF(("good morning, eval=%d\n", eval));
			if (we_own_it)
				msqptr->msg_perm.mode &= ~MSG_LOCKED;
			if (eval != 0) {
				DPRINTF(("msgsnd: interrupted system call\n"));
				return (EINTR);
			}

			/*
			 * Make sure that the msq queue still exists
			 */

			if (msqptr->msg_qbytes == 0) {
				DPRINTF(("msqid deleted\n"));
				return (EIDRM);
			}
d354 4
a357 3
		} else {
			DPRINTF(("got all the resources that we need\n"));
			break;
d361 11
a371 4
	/*
	 * We have the resources that we need.
	 * Make sure!
	 */
d373 5
a377 10
#ifdef DIAGNOSTIC
	if (msqptr->msg_perm.mode & MSG_LOCKED)
		panic("msg_perm.mode & MSG_LOCKED");
	if (segs_needed > nfree_msgmaps)
		panic("segs_needed > nfree_msgmaps");
	if (msgsz + msqptr->msg_cbytes > msqptr->msg_qbytes)
		panic("msgsz + msg_cbytes > msg_qbytes");
	if (free_msghdrs == NULL)
		panic("no more msghdrs");
#endif
d379 3
a381 4
	/*
	 * Re-lock the msqid_ds in case we page-fault when copying in the
	 * message
	 */
d383 2
a384 5
#ifdef DIAGNOSTIC
	if ((msqptr->msg_perm.mode & MSG_LOCKED) != 0)
		panic("msqid_ds is already locked");
#endif
	msqptr->msg_perm.mode |= MSG_LOCKED;
d386 3
a388 3
	/*
	 * Allocate a message header
	 */
d390 4
a393 4
	msghdr = free_msghdrs;
	free_msghdrs = msghdr->msg_next;
	msghdr->msg_spot = -1;
	msghdr->msg_ts = msgsz;
d395 1
a395 3
	/*
	 * Allocate space for the message
	 */
d397 4
a400 20
	while (segs_needed > 0) {
#ifdef DIAGNOSTIC
		if (nfree_msgmaps <= 0)
			panic("not enough msgmaps");
		if (free_msgmaps == -1)
			panic("nil free_msgmaps");
#endif
		next = free_msgmaps;
#ifdef DIAGNOSTIC
		if (next <= -1)
			panic("next too low #1");
		if (next >= msginfo.msgseg)
			panic("next out of range #1");
#endif
		DPRINTF(("allocating segment %d to message\n", next));
		free_msgmaps = msgmaps[next].next;
		nfree_msgmaps--;
		msgmaps[next].next = msghdr->msg_spot;
		msghdr->msg_spot = next;
		segs_needed--;
d403 49
a451 3
	/*
	 * Copy in the message type
	 */
d453 2
a454 9
	if ((eval = copyin(user_msgp, &msghdr->msg_type,
	    sizeof(msghdr->msg_type))) != 0) {
		DPRINTF(("error %d copying the message type\n", eval));
		msg_freehdr(msghdr);
		msqptr->msg_perm.mode &= ~MSG_LOCKED;
		wakeup(msqptr);
		return (eval);
	}
	user_msgp += sizeof(msghdr->msg_type);
d456 4
a459 3
	/*
	 * Validate the message type
	 */
d461 5
a465 6
	if (msghdr->msg_type < 1) {
		msg_freehdr(msghdr);
		msqptr->msg_perm.mode &= ~MSG_LOCKED;
		wakeup(msqptr);
		DPRINTF(("mtype (%d) < 1\n", msghdr->msg_type));
		return (EINVAL);
d467 1
d469 4
a472 11
	/*
	 * Copy in the message body
	 */

	next = msghdr->msg_spot;
	while (msgsz > 0) {
		size_t tlen;
		if (msgsz > msginfo.msgssz)
			tlen = msginfo.msgssz;
		else
			tlen = msgsz;
d474 2
a475 4
		if (next <= -1)
			panic("next too low #2");
		if (next >= msginfo.msgseg)
			panic("next out of range #2");
d477 4
a480 12
		if ((eval = copyin(user_msgp, &msgpool[next * msginfo.msgssz],
		    tlen)) != 0) {
			DPRINTF(("error %d copying in message segment\n",
			    eval));
			msg_freehdr(msghdr);
			msqptr->msg_perm.mode &= ~MSG_LOCKED;
			wakeup(msqptr);
			return (eval);
		}
		msgsz -= tlen;
		user_msgp += tlen;
		next = msgmaps[next].next;
d482 7
a488 7
#ifdef DIAGNOSTIC
	if (next != -1)
		panic("didn't use all the msg segments");
#endif
	/*
	 * We've got the message.  Unlock the msqid_ds.
	 */
d490 4
a493 1
	msqptr->msg_perm.mode &= ~MSG_LOCKED;
d495 1
a495 3
	/*
	 * Make sure that the msqid_ds is still allocated.
	 */
d497 5
a501 4
	if (msqptr->msg_qbytes == 0) {
		msg_freehdr(msghdr);
		wakeup(msqptr);
		return (EIDRM);
d504 10
d515 4
a518 1
	 * Put the message into the queue
d520 4
d525 2
a526 13
	if (msqptr->msg_first == NULL) {
		msqptr->msg_first = msghdr;
		msqptr->msg_last = msghdr;
	} else {
		msqptr->msg_last->msg_next = msghdr;
		msqptr->msg_last = msghdr;
	}
	msqptr->msg_last->msg_next = NULL;

	msqptr->msg_cbytes += msghdr->msg_ts;
	msqptr->msg_qnum++;
	msqptr->msg_lspid = p->p_p->ps_mainproc->p_pid;
	msqptr->msg_stime = time_second;
d528 28
a555 3
	wakeup(msqptr);
	*retval = 0;
	return (0);
d558 9
d568 1
a568 1
sys_msgrcv(struct proc *p, void *v, register_t *retval)
d570 10
a579 28
	struct sys_msgrcv_args /* {
		syscallarg(int) msqid;
		syscallarg(void *) msgp;
		syscallarg(size_t) msgsz;
		syscallarg(long) msgtyp;
		syscallarg(int) msgflg;
	} */ *uap = v;
	int msqid = SCARG(uap, msqid);
	char *user_msgp = SCARG(uap, msgp);
	size_t msgsz = SCARG(uap, msgsz);
	long msgtyp = SCARG(uap, msgtyp);
	int msgflg = SCARG(uap, msgflg);
	size_t len;
	struct ucred *cred = p->p_ucred;
	struct msqid_ds *msqptr;
	struct msg *msghdr;
	int eval;
	short next;

	DPRINTF(("call to msgrcv(%d, %p, %d, %ld, %d)\n", msqid, user_msgp,
	    msgsz, msgtyp, msgflg));

	msqid = IPCID_TO_IX(msqid);

	if (msqid < 0 || msqid >= msginfo.msgmni) {
		DPRINTF(("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
		    msginfo.msgmni));
		return (EINVAL);
d582 2
a583 3
	msqptr = &msqids[msqid];
	if (msqptr->msg_qbytes == 0) {
		DPRINTF(("no such message queue id\n"));
d586 18
a603 3
	if (msqptr->msg_perm.seq != IPCID_TO_SEQ(SCARG(uap, msqid))) {
		DPRINTF(("wrong sequence number\n"));
		return (EINVAL);
d606 6
a611 3
	if ((eval = ipcperm(cred, &msqptr->msg_perm, IPC_R))) {
		DPRINTF(("requester doesn't have read access\n"));
		return (eval);
d614 9
a622 7
#if 0
	/* cannot happen, msgsz is unsigned */
	if (msgsz < 0) {
		DPRINTF(("msgsz < 0\n"));
		return (EINVAL);
	}
#endif
a623 17
	msghdr = NULL;
	while (msghdr == NULL) {
		if (msgtyp == 0) {
			msghdr = msqptr->msg_first;
			if (msghdr != NULL) {
				if (msgsz < msghdr->msg_ts &&
				    (msgflg & MSG_NOERROR) == 0) {
					DPRINTF(("first message on the queue "
					    "is too big (want %d, got %d)\n",
					    msgsz, msghdr->msg_ts));
					return (E2BIG);
				}
				if (msqptr->msg_first == msqptr->msg_last) {
					msqptr->msg_first = NULL;
					msqptr->msg_last = NULL;
				} else {
					msqptr->msg_first = msghdr->msg_next;
d625 2
a626 2
					if (msqptr->msg_first == NULL)
						panic("msg_first/last screwed up #1");
a627 5
				}
			}
		} else {
			struct msg *previous;
			struct msg **prev;
d629 14
a642 51
			for (previous = NULL, prev = &msqptr->msg_first;
			    (msghdr = *prev) != NULL;
			    previous = msghdr, prev = &msghdr->msg_next) {
				/*
				 * Is this message's type an exact match or is
				 * this message's type less than or equal to
				 * the absolute value of a negative msgtyp?
				 * Note that the second half of this test can
				 * NEVER be true if msgtyp is positive since
				 * msg_type is always positive!
				 */

				if (msgtyp == msghdr->msg_type ||
				    msghdr->msg_type <= -msgtyp) {
					DPRINTF(("found message type %d, "
					    "requested %d\n", msghdr->msg_type,
					    msgtyp));
					if (msgsz < msghdr->msg_ts &&
					    (msgflg & MSG_NOERROR) == 0) {
						DPRINTF(("requested message on "
						    "the queue is too big "
						    "(want %d, got %d)\n",
						    msgsz, msghdr->msg_ts));
						return (E2BIG);
					}
					*prev = msghdr->msg_next;
					if (msghdr == msqptr->msg_last) {
						if (previous == NULL) {
#ifdef DIAGNOSTIC
							if (prev !=
							    &msqptr->msg_first)
								panic("msg_first/last screwed up #2");
#endif
							msqptr->msg_first =
							    NULL;
							msqptr->msg_last =
							    NULL;
						} else {
#ifdef DIAGNOSTIC
							if (prev ==
							    &msqptr->msg_first)
								panic("msg_first/last screwed up #3");
#endif
							msqptr->msg_last =
							    previous;
						}
					}
					break;
				}
			}
		}
d644 2
a645 5
		/*
		 * We've either extracted the msghdr for the appropriate
		 * message or there isn't one.
		 * If there is one then bail out of this loop.
		 */
d647 7
a653 2
		if (msghdr != NULL)
			break;
d655 2
a656 3
		/*
		 * Hmph!  No message found.  Does the user want to wait?
		 */
d658 2
a659 5
		if ((msgflg & IPC_NOWAIT) != 0) {
			DPRINTF(("no appropriate message found (msgtyp=%d)\n",
			    msgtyp));
			return (ENOMSG);
		}
d662 6
a667 1
		 * Wait for something to happen
d669 5
a673 9

		DPRINTF(("msgrcv: goodnight\n"));
		eval = tsleep(msqptr, (PZERO - 4) | PCATCH, "msgwait",
		    0);
		DPRINTF(("msgrcv: good morning (eval=%d)\n", eval));

		if (eval != 0) {
			DPRINTF(("msgsnd: interrupted system call\n"));
			return (EINTR);
d677 5
a681 1
		 * Make sure that the msq queue still exists
d683 2
d686 1
a686 6
		if (msqptr->msg_qbytes == 0 ||
		    msqptr->msg_perm.seq != IPCID_TO_SEQ(SCARG(uap, msqid))) {
			DPRINTF(("msqid deleted\n"));
			return (EIDRM);
		}
	}
d688 3
a690 5
	/*
	 * Return the message to the user.
	 *
	 * First, do the bookkeeping (before we risk being interrupted).
	 */
d692 4
a695 4
	msqptr->msg_cbytes -= msghdr->msg_ts;
	msqptr->msg_qnum--;
	msqptr->msg_lrpid = p->p_p->ps_mainproc->p_pid;
	msqptr->msg_rtime = time_second;
d697 1
a697 5
	/*
	 * Make msgsz the actual amount that we'll be returning.
	 * Note that this effectively truncates the message if it is too long
	 * (since msgsz is never increased).
	 */
d699 3
a701 4
	DPRINTF(("found a message, msgsz=%d, msg_ts=%d\n", msgsz,
	    msghdr->msg_ts));
	if (msgsz > msghdr->msg_ts)
		msgsz = msghdr->msg_ts;
d703 1
a703 3
	/*
	 * Return the type to the user.
	 */
d705 1
a705 9
	eval = copyout(&msghdr->msg_type, user_msgp,
	    sizeof(msghdr->msg_type));
	if (eval != 0) {
		DPRINTF(("error (%d) copying out message type\n", eval));
		msg_freehdr(msghdr);
		wakeup(msqptr);
		return (eval);
	}
	user_msgp += sizeof(msghdr->msg_type);
d707 1
a707 3
	/*
	 * Return the segments to the user
	 */
d709 2
a710 25
	next = msghdr->msg_spot;
	for (len = 0; len < msgsz; len += msginfo.msgssz) {
		size_t tlen;

		if (msgsz - len > msginfo.msgssz)
			tlen = msginfo.msgssz;
		else
			tlen = msgsz - len;
#ifdef DIAGNOSTIC
		if (next <= -1)
			panic("next too low #3");
		if (next >= msginfo.msgseg)
			panic("next out of range #3");
#endif
		eval = copyout(&msgpool[next * msginfo.msgssz],
		    user_msgp, tlen);
		if (eval != 0) {
			DPRINTF(("error (%d) copying out message segment\n",
			    eval));
			msg_freehdr(msghdr);
			wakeup(msqptr);
			return (eval);
		}
		user_msgp += tlen;
		next = msgmaps[next].next;
a711 9

	/*
	 * Done, return the actual number of bytes copied out.
	 */

	msg_freehdr(msghdr);
	wakeup(msqptr);
	*retval = msgsz;
	return (0);
@


1.20
log
@remove tests for EIDRM and ENOMSG existence now that they're in the tree.
miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.19 2005/12/13 10:33:14 jsg Exp $	*/
d601 1
a601 1
	msqptr->msg_lspid = p->p_pid;
d796 1
a796 1
	msqptr->msg_lrpid = p->p_pid;
@


1.19
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.18 2004/07/15 11:24:46 millert Exp $	*/
a36 8
#endif

/* XXX - OpenBSD doesn't have EIDRM or ENOMSG */
#ifndef	EIDRM
#define	EIDRM	EINVAL
#endif
#ifndef	ENOMSG
#define	ENOMSG	EAGAIN
@


1.18
log
@Rename structs oipc_perm, omsqid_ds, osemid_ds, oshmid_ds to ipc_perm23,
etc to avoid confusion and for consistency with the *35 ones.
Remove *n2o functions that don't belong outside of compat.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.17 2004/07/14 23:40:27 millert Exp $	*/
d58 1
a58 1
msginit()
d60 1
a60 1
	register int i;
d109 1
a109 2
msg_freehdr(msghdr)
	struct msg *msghdr;
d137 1
a137 4
sys_msgctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d139 1
a139 1
	register struct sys_msgctl_args /* {
d150 3
a152 7
msgctl1(p, msqid, cmd, buf, ds_copyin, ds_copyout)
	struct proc *p;
	int msqid;
	int cmd;
	caddr_t buf;
	int (*ds_copyin)(const void *, void *, size_t);
	int (*ds_copyout)(const void *, void *, size_t);
d249 1
a249 4
sys_msgget(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d251 1
a251 1
	register struct sys_msgget_args /* {
d259 1
a259 1
	register struct msqid_ds *msqptr = NULL;
d334 1
a334 4
sys_msgsnd(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d336 1
a336 1
	register struct sys_msgsnd_args /* {
d348 2
a349 2
	register struct msqid_ds *msqptr;
	register struct msg *msghdr;
d618 1
a618 4
sys_msgrcv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d620 1
a620 1
	register struct sys_msgrcv_args /* {
d634 2
a635 2
	register struct msqid_ds *msqptr;
	register struct msg *msghdr;
@


1.17
log
@Move the guts of the {sem,msg,shm}ctl system calls into a new function
which also takes two function pointers for copyin/copyout.  For the
real syscalls these are just the normal copyin/copyout functions.
For the compat routines, these are funtions that convert between
the new and old foo_ds structs automagically.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.16 2004/06/21 23:50:36 tholo Exp $	*/
a134 22
}

void
msqid_n2o(n, o)
	struct msqid_ds *n;
	struct omsqid_ds *o;
{
	o->msg_first = n->msg_first;
	o->msg_last = n->msg_last;
	o->msg_cbytes = n->msg_cbytes;
	o->msg_qnum = n->msg_qnum;
	o->msg_qbytes = n->msg_qbytes;
	o->msg_lspid = n->msg_lspid;
	o->msg_lrpid = n->msg_lrpid;
	o->msg_stime = n->msg_stime;
	o->msg_pad1 = n->msg_pad1;
	o->msg_rtime = n->msg_rtime;
	o->msg_pad2 = n->msg_pad2;
	o->msg_ctime = n->msg_ctime;
	o->msg_pad3 = n->msg_pad3;
	bcopy(n->msg_pad4, o->msg_pad4, sizeof o->msg_pad4);
	ipc_n2o(&n->msg_perm, &o->msg_perm);
@


1.16
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.15 2003/07/21 22:44:50 tedu Exp $	*/
d170 14
a183 3
	int msqid = SCARG(uap, msqid);
	int cmd = SCARG(uap, cmd);
	struct msqid_ds *user_msqptr = SCARG(uap, buf);
d185 3
a187 3
	int rval, eval;
	struct msqid_ds msqbuf;
	register struct msqid_ds *msqptr;
d189 1
a189 1
	DPRINTF(("call to msgctl(%d, %d, %p)\n", msqid, cmd, user_msqptr));
d191 1
a191 1
	msqid = IPCID_TO_IX(msqid);
d193 2
a194 2
	if (msqid < 0 || msqid >= msginfo.msgmni) {
		DPRINTF(("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
d199 1
a199 1
	msqptr = &msqids[msqid];
d205 1
a205 1
	if (msqptr->msg_perm.seq != IPCID_TO_SEQ(SCARG(uap, msqid))) {
a209 3
	eval = 0;
	rval = 0;

a210 1

d212 2
a213 4
	{
		struct msg *msghdr;
		if ((eval = ipcperm(cred, &msqptr->msg_perm, IPC_M)) != 0)
			return (eval);
a232 1

a233 1

a234 2
	}

d238 6
a243 5
		if ((eval = ipcperm(cred, &msqptr->msg_perm, IPC_M)))
			return (eval);
		if ((eval = copyin(user_msqptr, &msqbuf, sizeof(msqbuf))) != 0)
			return (eval);
		if (msqbuf.msg_qbytes > msqptr->msg_qbytes && cred->cr_uid != 0)
d255 2
a256 2
		msqptr->msg_perm.uid = msqbuf.msg_perm.uid;	/* change owner */
		msqptr->msg_perm.gid = msqbuf.msg_perm.gid;	/* change owner */
d264 1
a264 1
		if ((eval = ipcperm(cred, &msqptr->msg_perm, IPC_R))) {
d266 1
a266 1
			return (eval);
d268 1
a268 2
		eval = copyout(msqptr, user_msqptr,
		    sizeof(struct msqid_ds));
d275 1
a275 4

	if (eval == 0)
		*retval = rval;
	return (eval);
@


1.15
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.14 2002/12/22 04:55:05 millert Exp $	*/
d258 1
a258 1
		msqptr->msg_ctime = time.tv_sec;
d356 1
a356 1
		msqptr->msg_ctime = time.tv_sec;
d648 1
a648 1
	msqptr->msg_stime = time.tv_sec;
d846 1
a846 1
	msqptr->msg_rtime = time.tv_sec;
@


1.14
log
@Cosmetic changes:
o Add a DPRINTF macro instead of using debugging #ifdefs all over the place
o KNF says to use "return (foo)" not "return(foo)"
o #define EIDRM and ENOMSG at the top instead of using #ifdefs to work
  around the fact that we don't have them later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.13 2002/12/22 04:52:10 millert Exp $	*/
d231 1
a231 1
		wakeup((caddr_t)msqptr);
d266 1
a266 1
		eval = copyout((caddr_t)msqptr, user_msqptr,
d469 1
a469 1
			eval = tsleep((caddr_t)msqptr, (PZERO - 4) | PCATCH,
d565 1
a565 1
		wakeup((caddr_t)msqptr);
d577 1
a577 1
		wakeup((caddr_t)msqptr);
d605 1
a605 1
			wakeup((caddr_t)msqptr);
d628 1
a628 1
		wakeup((caddr_t)msqptr);
d650 1
a650 1
	wakeup((caddr_t)msqptr);
d817 1
a817 1
		eval = tsleep((caddr_t)msqptr, (PZERO - 4) | PCATCH, "msgwait",
d863 1
a863 1
	eval = copyout((caddr_t)&msghdr->msg_type, user_msgp,
d868 1
a868 1
		wakeup((caddr_t)msqptr);
d891 1
a891 1
		eval = copyout((caddr_t)&msgpool[next * msginfo.msgssz],
d897 1
a897 1
			wakeup((caddr_t)msqptr);
d909 1
a909 1
	wakeup((caddr_t)msqptr);
@


1.13
log
@Clear the high bit of ipc_perm.seq so msgget(3) never returns a
negative message queue id; Vladimir B.Grebenschikov
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.12 2002/03/14 01:27:05 millert Exp $	*/
d33 13
a45 2
#define MSG_DEBUG
#undef MSG_DEBUG_OK
d178 1
a178 3
#ifdef MSG_DEBUG_OK
	printf("call to msgctl(%d, %d, %p)\n", msqid, cmd, user_msqptr);
#endif
d183 3
a185 5
#ifdef MSG_DEBUG_OK
		printf("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
		    msginfo.msgmni);
#endif
		return(EINVAL);
d191 2
a192 4
#ifdef MSG_DEBUG_OK
		printf("no such msqid\n");
#endif
		return(EINVAL);
d195 2
a196 4
#ifdef MSG_DEBUG_OK
		printf("wrong sequence number\n");
#endif
		return(EINVAL);
d208 1
a208 1
			return(eval);
d238 1
a238 1
			return(eval);
d240 1
a240 1
			return(eval);
d242 1
a242 1
			return(EPERM);
d244 4
a247 5
#ifdef MSG_DEBUG_OK
			printf("can't increase msg_qbytes beyond %d (truncating)\n",
			    msginfo.msgmnb);
#endif
			msqbuf.msg_qbytes = msginfo.msgmnb;	/* silently restrict qbytes to system limit */
d250 2
a251 4
#ifdef MSG_DEBUG_OK
			printf("can't reduce msg_qbytes to 0\n");
#endif
			return(EINVAL);		/* non-standard errno! */
d253 2
a254 2
		msqptr->msg_perm.uid = msqbuf.msg_perm.uid;	/* change the owner */
		msqptr->msg_perm.gid = msqbuf.msg_perm.gid;	/* change the owner */
d263 2
a264 4
#ifdef MSG_DEBUG_OK
			printf("requester doesn't have read access\n");
#endif
			return(eval);
d271 2
a272 4
#ifdef MSG_DEBUG_OK
		printf("invalid command %d\n", cmd);
#endif
		return(EINVAL);
d277 1
a277 1
	return(eval);
d296 1
a296 3
#ifdef MSG_DEBUG_OK
	printf("msgget(0x%x, 0%o)\n", key, msgflg);
#endif
d306 1
a306 3
#ifdef MSG_DEBUG_OK
			printf("found public key\n");
#endif
d308 2
a309 4
#ifdef MSG_DEBUG_OK
				printf("not exclusive\n");
#endif
				return(EEXIST);
d312 3
a314 5
#ifdef MSG_DEBUG_OK
				printf("requester doesn't have 0%o access\n",
				    msgflg & 0700);
#endif
				return(eval);
d320 1
a320 3
#ifdef MSG_DEBUG_OK
	printf("need to allocate the msqid_ds\n");
#endif
d335 2
a336 4
#ifdef MSG_DEBUG_OK
			printf("no more msqid_ds's available\n");
#endif
			return(ENOSPC);	
d338 1
a338 3
#ifdef MSG_DEBUG_OK
		printf("msqid %d is available\n", msqid);
#endif
d358 2
a359 4
#ifdef MSG_DEBUG_OK
		printf("didn't find it and wasn't asked to create it\n");
#endif
		return(ENOENT);
d365 1
a365 1
	return(0);
d390 2
a391 4
#ifdef MSG_DEBUG_OK
	printf("call to msgsnd(%d, %p, %d, %d)\n", msqid, user_msgp, msgsz,
	    msgflg);
#endif
d396 3
a398 5
#ifdef MSG_DEBUG_OK
		printf("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
		    msginfo.msgmni);
#endif
		return(EINVAL);
d403 2
a404 4
#ifdef MSG_DEBUG_OK
		printf("no such message queue id\n");
#endif
		return(EINVAL);
d407 2
a408 4
#ifdef MSG_DEBUG_OK
		printf("wrong sequence number\n");
#endif
		return(EINVAL);
d412 2
a413 4
#ifdef MSG_DEBUG_OK
		printf("requester doesn't have write access\n");
#endif
		return(eval);
d417 2
a418 4
#ifdef MSG_DEBUG_OK
	printf("msgsz=%d, msgssz=%d, segs_needed=%d\n", msgsz, msginfo.msgssz,
	    segs_needed);
#endif
d428 2
a429 4
#ifdef MSG_DEBUG_OK
			printf("msgsz > msqptr->msg_qbytes\n");
#endif
			return(EINVAL);
d433 1
a433 3
#ifdef MSG_DEBUG_OK
			printf("msqid is locked\n");
#endif
d437 1
a437 3
#ifdef MSG_DEBUG_OK
			printf("msgsz + msg_cbytes > msg_qbytes\n");
#endif
d441 1
a441 3
#ifdef MSG_DEBUG_OK
			printf("segs_needed > nfree_msgmaps\n");
#endif
d445 1
a445 3
#ifdef MSG_DEBUG_OK
			printf("no more msghdrs\n");
#endif
d453 3
a455 4
#ifdef MSG_DEBUG_OK
				printf("need more resources but caller doesn't want to wait\n");
#endif
				return(EAGAIN);
d459 1
a459 3
#ifdef MSG_DEBUG_OK
				printf("we don't own the msqid_ds\n");
#endif
d464 1
a464 3
#ifdef MSG_DEBUG_OK
				printf("we own the msqid_ds\n");
#endif
d468 1
a468 3
#ifdef MSG_DEBUG_OK
			printf("goodnight\n");
#endif
d471 1
a471 3
#ifdef MSG_DEBUG_OK
			printf("good morning, eval=%d\n", eval);
#endif
d475 2
a476 4
#ifdef MSG_DEBUG_OK
				printf("msgsnd:  interrupted system call\n");
#endif
				return(EINTR);
d484 2
a485 11
#ifdef MSG_DEBUG_OK
				printf("msqid deleted\n");
#endif
				/* The SVID says to return EIDRM. */
#ifdef EIDRM
				return(EIDRM);
#else
				/* Unfortunately, BSD doesn't define that code
				   yet! */
				return(EINVAL);
#endif
d489 1
a489 3
#ifdef MSG_DEBUG_OK
			printf("got all the resources that we need\n");
#endif
d548 1
a548 3
#ifdef MSG_DEBUG_OK
		printf("allocating segment %d to message\n", next);
#endif
d562 1
a562 3
#ifdef MSG_DEBUG_OK
		printf("error %d copying the message type\n", eval);
#endif
d566 1
a566 1
		return(eval);
d578 2
a579 4
#ifdef MSG_DEBUG_OK
		printf("mtype (%d) < 1\n", msghdr->msg_type);
#endif
		return(EINVAL);
d601 2
a602 3
#ifdef MSG_DEBUG_OK
			printf("error %d copying in message segment\n", eval);
#endif
d606 1
a606 1
			return(eval);
d629 1
a629 7
		/* The SVID says to return EIDRM. */
#ifdef EIDRM
		return(EIDRM);
#else
		/* Unfortunately, BSD doesn't define that code yet! */
		return(EINVAL);
#endif
d652 1
a652 1
	return(0);
d680 2
a681 4
#ifdef MSG_DEBUG_OK
	printf("call to msgrcv(%d, %p, %d, %ld, %d)\n", msqid, user_msgp,
	    msgsz, msgtyp, msgflg);
#endif
d686 3
a688 5
#ifdef MSG_DEBUG_OK
		printf("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
		    msginfo.msgmni);
#endif
		return(EINVAL);
d693 2
a694 4
#ifdef MSG_DEBUG_OK
		printf("no such message queue id\n");
#endif
		return(EINVAL);
d697 2
a698 4
#ifdef MSG_DEBUG_OK
		printf("wrong sequence number\n");
#endif
		return(EINVAL);
d702 2
a703 4
#ifdef MSG_DEBUG_OK
		printf("requester doesn't have read access\n");
#endif
		return(eval);
d709 2
a710 4
#ifdef MSG_DEBUG_OK
		printf("msgsz < 0\n");
#endif
		return(EINVAL);
d721 4
a724 5
#ifdef MSG_DEBUG_OK
					printf("first message on the queue is too big (want %d, got %d)\n",
					    msgsz, msghdr->msg_ts);
#endif
					return(E2BIG);
d755 3
a757 4
#ifdef MSG_DEBUG_OK
					printf("found message type %d, requested %d\n",
					    msghdr->msg_type, msgtyp);
#endif
d760 5
a764 5
#ifdef MSG_DEBUG_OK
						printf("requested message on the queue is too big (want %d, got %d)\n",
						    msgsz, msghdr->msg_ts);
#endif
						return(E2BIG);
d807 3
a809 11
#ifdef MSG_DEBUG_OK
			printf("no appropriate message found (msgtyp=%d)\n",
			    msgtyp);
#endif
			/* The SVID says to return ENOMSG. */
#ifdef ENOMSG
			return(ENOMSG);
#else
			/* Unfortunately, BSD doesn't define that code yet! */
			return(EAGAIN);
#endif
d816 1
a816 3
#ifdef MSG_DEBUG_OK
		printf("msgrcv:  goodnight\n");
#endif
d819 1
a819 3
#ifdef MSG_DEBUG_OK
		printf("msgrcv:  good morning (eval=%d)\n", eval);
#endif
d822 2
a823 4
#ifdef MSG_DEBUG_OK
			printf("msgsnd:  interrupted system call\n");
#endif
			return(EINTR);
d832 2
a833 10
#ifdef MSG_DEBUG_OK
			printf("msqid deleted\n");
#endif
			/* The SVID says to return EIDRM. */
#ifdef EIDRM
			return(EIDRM);
#else
			/* Unfortunately, BSD doesn't define that code yet! */
			return(EINVAL);
#endif
d854 2
a855 4
#ifdef MSG_DEBUG_OK
	printf("found a message, msgsz=%d, msg_ts=%d\n", msgsz,
	    msghdr->msg_ts);
#endif
d866 1
a866 3
#ifdef MSG_DEBUG_OK
		printf("error (%d) copying out message type\n", eval);
#endif
d869 1
a869 1
		return(eval);
d894 2
a895 4
#ifdef MSG_DEBUG_OK
			printf("error (%d) copying out message segment\n",
			    eval);
#endif
d898 1
a898 1
			return(eval);
d911 1
a911 1
	return(0);
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.11 2001/08/12 22:50:12 millert Exp $	*/
d364 1
a364 1
		msqptr->msg_perm.seq++;
@


1.11
log
@Don't allocate globals in include files, use extern declarations.
Move the actual variables into their respective .c files.
As a bonus, remove semmap which is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.10 2001/06/22 14:14:09 deraadt Exp $	*/
d44 1
a44 1
void msg_freehdr __P((struct msg *));
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.11 2001/08/12 22:50:12 millert Exp $	*/
d44 1
a44 1
void msg_freehdr(struct msg *);
@


1.11.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d33 2
a34 13
#ifdef MSG_DEBUG
#define	DPRINTF(x)	printf x
#else
#define	DPRINTF(x)
#endif

/* XXX - OpenBSD doesn't have EIDRM or ENOMSG */
#ifndef	EIDRM
#define	EIDRM	EINVAL
#endif
#ifndef	ENOMSG
#define	ENOMSG	EAGAIN
#endif
d167 3
a169 1
	DPRINTF(("call to msgctl(%d, %d, %p)\n", msqid, cmd, user_msqptr));
d174 5
a178 3
		DPRINTF(("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
		    msginfo.msgmni));
		return (EINVAL);
d184 4
a187 2
		DPRINTF(("no such msqid\n"));
		return (EINVAL);
d190 4
a193 2
		DPRINTF(("wrong sequence number\n"));
		return (EINVAL);
d205 1
a205 1
			return (eval);
d235 1
a235 1
			return (eval);
d237 1
a237 1
			return (eval);
d239 1
a239 1
			return (EPERM);
d241 5
a245 4
			DPRINTF(("can't increase msg_qbytes beyond %d "
			    "(truncating)\n", msginfo.msgmnb));
			/* silently restrict qbytes to system limit */
			msqbuf.msg_qbytes = msginfo.msgmnb;
d248 4
a251 2
			DPRINTF(("can't reduce msg_qbytes to 0\n"));
			return (EINVAL);	/* non-standard errno! */
d253 2
a254 2
		msqptr->msg_perm.uid = msqbuf.msg_perm.uid;	/* change owner */
		msqptr->msg_perm.gid = msqbuf.msg_perm.gid;	/* change owner */
d263 4
a266 2
			DPRINTF(("requester doesn't have read access\n"));
			return (eval);
d273 4
a276 2
		DPRINTF(("invalid command %d\n", cmd));
		return (EINVAL);
d281 1
a281 1
	return (eval);
d300 3
a302 1
	DPRINTF(("msgget(0x%x, 0%o)\n", key, msgflg));
d312 3
a314 1
			DPRINTF(("found public key\n"));
d316 4
a319 2
				DPRINTF(("not exclusive\n"));
				return (EEXIST);
d322 5
a326 3
				DPRINTF(("requester doesn't have 0%o access\n",
				    msgflg & 0700));
				return (eval);
d332 3
a334 1
	DPRINTF(("need to allocate the msqid_ds\n"));
d349 4
a352 2
			DPRINTF(("no more msqid_ds's available\n"));
			return (ENOSPC);	
d354 3
a356 1
		DPRINTF(("msqid %d is available\n", msqid));
d364 1
a364 1
		msqptr->msg_perm.seq = (msqptr->msg_perm.seq + 1) & 0x7fff;
d376 4
a379 2
		DPRINTF(("didn't find it and wasn't asked to create it\n"));
		return (ENOENT);
d385 1
a385 1
	return (0);
d410 4
a413 2
	DPRINTF(("call to msgsnd(%d, %p, %d, %d)\n", msqid, user_msgp, msgsz,
	    msgflg));
d418 5
a422 3
		DPRINTF(("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
		    msginfo.msgmni));
		return (EINVAL);
d427 4
a430 2
		DPRINTF(("no such message queue id\n"));
		return (EINVAL);
d433 4
a436 2
		DPRINTF(("wrong sequence number\n"));
		return (EINVAL);
d440 4
a443 2
		DPRINTF(("requester doesn't have write access\n"));
		return (eval);
d447 4
a450 2
	DPRINTF(("msgsz=%d, msgssz=%d, segs_needed=%d\n", msgsz,
	    msginfo.msgssz, segs_needed));
d460 4
a463 2
			DPRINTF(("msgsz > msqptr->msg_qbytes\n"));
			return (EINVAL);
d467 3
a469 1
			DPRINTF(("msqid is locked\n"));
d473 3
a475 1
			DPRINTF(("msgsz + msg_cbytes > msg_qbytes\n"));
d479 3
a481 1
			DPRINTF(("segs_needed > nfree_msgmaps\n"));
d485 3
a487 1
			DPRINTF(("no more msghdrs\n"));
d495 4
a498 3
				DPRINTF(("need more resources but caller "
				    "doesn't want to wait\n"));
				return (EAGAIN);
d502 3
a504 1
				DPRINTF(("we don't own the msqid_ds\n"));
d509 3
a511 1
				DPRINTF(("we own the msqid_ds\n"));
d515 3
a517 1
			DPRINTF(("goodnight\n"));
d520 3
a522 1
			DPRINTF(("good morning, eval=%d\n", eval));
d526 4
a529 2
				DPRINTF(("msgsnd: interrupted system call\n"));
				return (EINTR);
d537 11
a547 2
				DPRINTF(("msqid deleted\n"));
				return (EIDRM);
d551 3
a553 1
			DPRINTF(("got all the resources that we need\n"));
d612 3
a614 1
		DPRINTF(("allocating segment %d to message\n", next));
d628 3
a630 1
		DPRINTF(("error %d copying the message type\n", eval));
d634 1
a634 1
		return (eval);
d646 4
a649 2
		DPRINTF(("mtype (%d) < 1\n", msghdr->msg_type));
		return (EINVAL);
d671 3
a673 2
			DPRINTF(("error %d copying in message segment\n",
			    eval));
d677 1
a677 1
			return (eval);
d700 7
a706 1
		return (EIDRM);
d729 1
a729 1
	return (0);
d757 4
a760 2
	DPRINTF(("call to msgrcv(%d, %p, %d, %ld, %d)\n", msqid, user_msgp,
	    msgsz, msgtyp, msgflg));
d765 5
a769 3
		DPRINTF(("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
		    msginfo.msgmni));
		return (EINVAL);
d774 4
a777 2
		DPRINTF(("no such message queue id\n"));
		return (EINVAL);
d780 4
a783 2
		DPRINTF(("wrong sequence number\n"));
		return (EINVAL);
d787 4
a790 2
		DPRINTF(("requester doesn't have read access\n"));
		return (eval);
d796 4
a799 2
		DPRINTF(("msgsz < 0\n"));
		return (EINVAL);
d810 5
a814 4
					DPRINTF(("first message on the queue "
					    "is too big (want %d, got %d)\n",
					    msgsz, msghdr->msg_ts));
					return (E2BIG);
d845 4
a848 3
					DPRINTF(("found message type %d, "
					    "requested %d\n", msghdr->msg_type,
					    msgtyp));
d851 5
a855 5
						DPRINTF(("requested message on "
						    "the queue is too big "
						    "(want %d, got %d)\n",
						    msgsz, msghdr->msg_ts));
						return (E2BIG);
d898 11
a908 3
			DPRINTF(("no appropriate message found (msgtyp=%d)\n",
			    msgtyp));
			return (ENOMSG);
d915 3
a917 1
		DPRINTF(("msgrcv: goodnight\n"));
d920 3
a922 1
		DPRINTF(("msgrcv: good morning (eval=%d)\n", eval));
d925 4
a928 2
			DPRINTF(("msgsnd: interrupted system call\n"));
			return (EINTR);
d937 10
a946 2
			DPRINTF(("msqid deleted\n"));
			return (EIDRM);
d967 4
a970 2
	DPRINTF(("found a message, msgsz=%d, msg_ts=%d\n", msgsz,
	    msghdr->msg_ts));
d981 3
a983 1
		DPRINTF(("error (%d) copying out message type\n", eval));
d986 1
a986 1
		return (eval);
d1011 4
a1014 2
			DPRINTF(("error (%d) copying out message segment\n",
			    eval));
d1017 1
a1017 1
			return (eval);
d1030 1
a1030 1
	return (0);
@


1.10
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.9 2001/05/16 17:14:35 millert Exp $	*/
d39 4
@


1.9
log
@Create COMPAT_25 and move ogetfsstat, ostatfs and ostatfs into it.
Create COMPAT_23 and move __osemctl, omsgctl, oshmctl there.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.8 1999/08/09 21:44:24 deraadt Exp $	*/
d828 2
a829 2
			     (msghdr = *prev) != NULL;
			     previous = msghdr, prev = &msghdr->msg_next) {
@


1.8
log
@unique panic messages
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.7 1999/04/18 18:24:40 deraadt Exp $	*/
d40 1
a40 1
static void msg_freehdr __P((struct msg *));
d93 1
a93 1
static void
a141 136
}

int
sys_omsgctl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sys_msgctl_args /* {
		syscallarg(int) msqid;
		syscallarg(int) cmd;
		syscallarg(struct msqid_ds *) buf;
	} */ *uap = v;
	int msqid = SCARG(uap, msqid);
	int cmd = SCARG(uap, cmd);
	struct msqid_ds *user_msqptr = SCARG(uap, buf);
	struct ucred *cred = p->p_ucred;
	int rval, eval;
	struct omsqid_ds omsqbuf;
	register struct msqid_ds *msqptr;

#ifdef MSG_DEBUG_OK
	printf("call to msgctl(%d, %d, %p)\n", msqid, cmd, user_msqptr);
#endif

	msqid = IPCID_TO_IX(msqid);

	if (msqid < 0 || msqid >= msginfo.msgmni) {
#ifdef MSG_DEBUG_OK
		printf("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
		    msginfo.msgmni);
#endif
		return(EINVAL);
	}

	msqptr = &msqids[msqid];

	if (msqptr->msg_qbytes == 0) {
#ifdef MSG_DEBUG_OK
		printf("no such msqid\n");
#endif
		return(EINVAL);
	}
	if (msqptr->msg_perm.seq != IPCID_TO_SEQ(SCARG(uap, msqid))) {
#ifdef MSG_DEBUG_OK
		printf("wrong sequence number\n");
#endif
		return(EINVAL);
	}

	eval = 0;
	rval = 0;

	switch (cmd) {

	case IPC_RMID:
	{
		struct msg *msghdr;
		if ((eval = ipcperm(cred, &msqptr->msg_perm, IPC_M)) != 0)
			return(eval);
		/* Free the message headers */
		msghdr = msqptr->msg_first;
		while (msghdr != NULL) {
			struct msg *msghdr_tmp;

			/* Free the segments of each message */
			msqptr->msg_cbytes -= msghdr->msg_ts;
			msqptr->msg_qnum--;
			msghdr_tmp = msghdr;
			msghdr = msghdr->msg_next;
			msg_freehdr(msghdr_tmp);
		}

#ifdef DIAGNOSTIC
		if (msqptr->msg_cbytes != 0)
			panic("sys_omsgctl: msg_cbytes is screwed up");
		if (msqptr->msg_qnum != 0)
			panic("sys_omsgctl: msg_qnum is screwed up");
#endif

		msqptr->msg_qbytes = 0;	/* Mark it as free */

		wakeup((caddr_t)msqptr);
	}

		break;

	case IPC_SET:
		if ((eval = ipcperm(cred, &msqptr->msg_perm, IPC_M)))
			return(eval);
		if ((eval = copyin(user_msqptr, &omsqbuf, sizeof(omsqbuf))) != 0)
			return(eval);
		if (omsqbuf.msg_qbytes > msqptr->msg_qbytes && cred->cr_uid != 0)
			return(EPERM);
		if (omsqbuf.msg_qbytes > msginfo.msgmnb) {
#ifdef MSG_DEBUG_OK
			printf("can't increase msg_qbytes beyond %d (truncating)\n",
			    msginfo.msgmnb);
#endif
			omsqbuf.msg_qbytes = msginfo.msgmnb;	/* silently restrict qbytes to system limit */
		}
		if (omsqbuf.msg_qbytes == 0) {
#ifdef MSG_DEBUG_OK
			printf("can't reduce msg_qbytes to 0\n");
#endif
			return(EINVAL);		/* non-standard errno! */
		}
		msqptr->msg_perm.uid = omsqbuf.msg_perm.uid;	/* change the owner */
		msqptr->msg_perm.gid = omsqbuf.msg_perm.gid;	/* change the owner */
		msqptr->msg_perm.mode = (msqptr->msg_perm.mode & ~0777) |
		    (omsqbuf.msg_perm.mode & 0777);
		msqptr->msg_qbytes = omsqbuf.msg_qbytes;
		msqptr->msg_ctime = time.tv_sec;
		break;

	case IPC_STAT:
		if ((eval = ipcperm(cred, &msqptr->msg_perm, IPC_R))) {
#ifdef MSG_DEBUG_OK
			printf("requester doesn't have read access\n");
#endif
			return(eval);
		}
		msqid_n2o(msqptr, &omsqbuf);
		eval = copyout((caddr_t)&omsqbuf, user_msqptr, sizeof omsqbuf);
		break;

	default:
#ifdef MSG_DEBUG_OK
		printf("invalid command %d\n", cmd);
#endif
		return(EINVAL);
	}

	if (eval == 0)
		*retval = rval;
	return(eval);
@


1.8.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.8 1999/08/09 21:44:24 deraadt Exp $	*/
d40 1
a40 1
void msg_freehdr __P((struct msg *));
d93 1
a93 1
void
d145 136
d964 2
a965 2
			    (msghdr = *prev) != NULL;
			    previous = msghdr, prev = &msghdr->msg_next) {
@


1.8.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.8.4.1 2001/07/04 10:48:38 niklas Exp $	*/
a38 4
char *msgpool;			/* MSGMAX byte long msg buffer pool */
struct msgmap *msgmaps;		/* MSGSEG msgmap structures */
struct msg *msghdrs;		/* MSGTQL msg headers */
struct msqid_ds *msqids;	/* MSGMNI msqid_ds struct's */
@


1.8.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
void msg_freehdr(struct msg *);
@


1.8.4.4
log
@Sync the SMP branch with 3.3
@
text
@d33 2
a34 13
#ifdef MSG_DEBUG
#define	DPRINTF(x)	printf x
#else
#define	DPRINTF(x)
#endif

/* XXX - OpenBSD doesn't have EIDRM or ENOMSG */
#ifndef	EIDRM
#define	EIDRM	EINVAL
#endif
#ifndef	ENOMSG
#define	ENOMSG	EAGAIN
#endif
d167 3
a169 1
	DPRINTF(("call to msgctl(%d, %d, %p)\n", msqid, cmd, user_msqptr));
d174 5
a178 3
		DPRINTF(("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
		    msginfo.msgmni));
		return (EINVAL);
d184 4
a187 2
		DPRINTF(("no such msqid\n"));
		return (EINVAL);
d190 4
a193 2
		DPRINTF(("wrong sequence number\n"));
		return (EINVAL);
d205 1
a205 1
			return (eval);
d235 1
a235 1
			return (eval);
d237 1
a237 1
			return (eval);
d239 1
a239 1
			return (EPERM);
d241 5
a245 4
			DPRINTF(("can't increase msg_qbytes beyond %d "
			    "(truncating)\n", msginfo.msgmnb));
			/* silently restrict qbytes to system limit */
			msqbuf.msg_qbytes = msginfo.msgmnb;
d248 4
a251 2
			DPRINTF(("can't reduce msg_qbytes to 0\n"));
			return (EINVAL);	/* non-standard errno! */
d253 2
a254 2
		msqptr->msg_perm.uid = msqbuf.msg_perm.uid;	/* change owner */
		msqptr->msg_perm.gid = msqbuf.msg_perm.gid;	/* change owner */
d263 4
a266 2
			DPRINTF(("requester doesn't have read access\n"));
			return (eval);
d273 4
a276 2
		DPRINTF(("invalid command %d\n", cmd));
		return (EINVAL);
d281 1
a281 1
	return (eval);
d300 3
a302 1
	DPRINTF(("msgget(0x%x, 0%o)\n", key, msgflg));
d312 3
a314 1
			DPRINTF(("found public key\n"));
d316 4
a319 2
				DPRINTF(("not exclusive\n"));
				return (EEXIST);
d322 5
a326 3
				DPRINTF(("requester doesn't have 0%o access\n",
				    msgflg & 0700));
				return (eval);
d332 3
a334 1
	DPRINTF(("need to allocate the msqid_ds\n"));
d349 4
a352 2
			DPRINTF(("no more msqid_ds's available\n"));
			return (ENOSPC);	
d354 3
a356 1
		DPRINTF(("msqid %d is available\n", msqid));
d364 1
a364 1
		msqptr->msg_perm.seq = (msqptr->msg_perm.seq + 1) & 0x7fff;
d376 4
a379 2
		DPRINTF(("didn't find it and wasn't asked to create it\n"));
		return (ENOENT);
d385 1
a385 1
	return (0);
d410 4
a413 2
	DPRINTF(("call to msgsnd(%d, %p, %d, %d)\n", msqid, user_msgp, msgsz,
	    msgflg));
d418 5
a422 3
		DPRINTF(("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
		    msginfo.msgmni));
		return (EINVAL);
d427 4
a430 2
		DPRINTF(("no such message queue id\n"));
		return (EINVAL);
d433 4
a436 2
		DPRINTF(("wrong sequence number\n"));
		return (EINVAL);
d440 4
a443 2
		DPRINTF(("requester doesn't have write access\n"));
		return (eval);
d447 4
a450 2
	DPRINTF(("msgsz=%d, msgssz=%d, segs_needed=%d\n", msgsz,
	    msginfo.msgssz, segs_needed));
d460 4
a463 2
			DPRINTF(("msgsz > msqptr->msg_qbytes\n"));
			return (EINVAL);
d467 3
a469 1
			DPRINTF(("msqid is locked\n"));
d473 3
a475 1
			DPRINTF(("msgsz + msg_cbytes > msg_qbytes\n"));
d479 3
a481 1
			DPRINTF(("segs_needed > nfree_msgmaps\n"));
d485 3
a487 1
			DPRINTF(("no more msghdrs\n"));
d495 4
a498 3
				DPRINTF(("need more resources but caller "
				    "doesn't want to wait\n"));
				return (EAGAIN);
d502 3
a504 1
				DPRINTF(("we don't own the msqid_ds\n"));
d509 3
a511 1
				DPRINTF(("we own the msqid_ds\n"));
d515 3
a517 1
			DPRINTF(("goodnight\n"));
d520 3
a522 1
			DPRINTF(("good morning, eval=%d\n", eval));
d526 4
a529 2
				DPRINTF(("msgsnd: interrupted system call\n"));
				return (EINTR);
d537 11
a547 2
				DPRINTF(("msqid deleted\n"));
				return (EIDRM);
d551 3
a553 1
			DPRINTF(("got all the resources that we need\n"));
d612 3
a614 1
		DPRINTF(("allocating segment %d to message\n", next));
d628 3
a630 1
		DPRINTF(("error %d copying the message type\n", eval));
d634 1
a634 1
		return (eval);
d646 4
a649 2
		DPRINTF(("mtype (%d) < 1\n", msghdr->msg_type));
		return (EINVAL);
d671 3
a673 2
			DPRINTF(("error %d copying in message segment\n",
			    eval));
d677 1
a677 1
			return (eval);
d700 7
a706 1
		return (EIDRM);
d729 1
a729 1
	return (0);
d757 4
a760 2
	DPRINTF(("call to msgrcv(%d, %p, %d, %ld, %d)\n", msqid, user_msgp,
	    msgsz, msgtyp, msgflg));
d765 5
a769 3
		DPRINTF(("msqid (%d) out of range (0<=msqid<%d)\n", msqid,
		    msginfo.msgmni));
		return (EINVAL);
d774 4
a777 2
		DPRINTF(("no such message queue id\n"));
		return (EINVAL);
d780 4
a783 2
		DPRINTF(("wrong sequence number\n"));
		return (EINVAL);
d787 4
a790 2
		DPRINTF(("requester doesn't have read access\n"));
		return (eval);
d796 4
a799 2
		DPRINTF(("msgsz < 0\n"));
		return (EINVAL);
d810 5
a814 4
					DPRINTF(("first message on the queue "
					    "is too big (want %d, got %d)\n",
					    msgsz, msghdr->msg_ts));
					return (E2BIG);
d845 4
a848 3
					DPRINTF(("found message type %d, "
					    "requested %d\n", msghdr->msg_type,
					    msgtyp));
d851 5
a855 5
						DPRINTF(("requested message on "
						    "the queue is too big "
						    "(want %d, got %d)\n",
						    msgsz, msghdr->msg_ts));
						return (E2BIG);
d898 11
a908 3
			DPRINTF(("no appropriate message found (msgtyp=%d)\n",
			    msgtyp));
			return (ENOMSG);
d915 3
a917 1
		DPRINTF(("msgrcv: goodnight\n"));
d920 3
a922 1
		DPRINTF(("msgrcv: good morning (eval=%d)\n", eval));
d925 4
a928 2
			DPRINTF(("msgsnd: interrupted system call\n"));
			return (EINTR);
d937 10
a946 2
			DPRINTF(("msqid deleted\n"));
			return (EIDRM);
d967 4
a970 2
	DPRINTF(("found a message, msgsz=%d, msg_ts=%d\n", msgsz,
	    msghdr->msg_ts));
d981 3
a983 1
		DPRINTF(("error (%d) copying out message type\n", eval));
d986 1
a986 1
		return (eval);
d1011 4
a1014 2
			DPRINTF(("error (%d) copying out message segment\n",
			    eval));
d1017 1
a1017 1
			return (eval);
d1030 1
a1030 1
	return (0);
@


1.8.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d231 1
a231 1
		wakeup(msqptr);
d266 1
a266 1
		eval = copyout(msqptr, user_msqptr,
d469 1
a469 1
			eval = tsleep(msqptr, (PZERO - 4) | PCATCH,
d565 1
a565 1
		wakeup(msqptr);
d577 1
a577 1
		wakeup(msqptr);
d605 1
a605 1
			wakeup(msqptr);
d628 1
a628 1
		wakeup(msqptr);
d650 1
a650 1
	wakeup(msqptr);
d817 1
a817 1
		eval = tsleep(msqptr, (PZERO - 4) | PCATCH, "msgwait",
d863 1
a863 1
	eval = copyout(&msghdr->msg_type, user_msgp,
d868 1
a868 1
		wakeup(msqptr);
d891 1
a891 1
		eval = copyout(&msgpool[next * msginfo.msgssz],
d897 1
a897 1
			wakeup(msqptr);
d909 1
a909 1
	wakeup(msqptr);
@


1.7
log
@incorrect range checking, output buf oflow; futatuki@@fureai.or.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.6 1999/02/04 18:48:25 deraadt Exp $	*/
d217 1
a217 1
			panic("msg_cbytes is screwed up");
d219 1
a219 1
			panic("msg_qnum is screwed up");
d353 1
a353 1
			panic("msg_cbytes is screwed up");
d355 1
a355 1
			panic("msg_qnum is screwed up");
@


1.6
log
@wrap noise in DIAGNOSTIC
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.5 1998/06/11 18:32:14 deraadt Exp $	*/
d1130 1
a1130 1
		if (msgsz > msginfo.msgssz)
d1133 1
a1133 1
			tlen = msgsz;
@


1.5
log
@change ipc.h to use uid_t and friends, and then build compat system calls for the old ushort based ipc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.4 1998/05/11 16:40:45 deraadt Exp $	*/
a55 5
    	if (i != msginfo.msgssz) {
		printf("msginfo.msgssz=%d (0x%x)\n", msginfo.msgssz,
		    msginfo.msgssz);
		panic("msginfo.msgssz not a small power of 2");
	}
d57 4
a60 4
	if (msginfo.msgseg > 32767) {
		printf("msginfo.msgseg=%d\n", msginfo.msgseg);
		panic("msginfo.msgseg > 32767");
	}
d99 2
d103 1
d114 1
d117 1
d215 1
d220 1
d351 1
d356 1
d695 1
d704 1
d711 1
d714 1
d731 1
d736 1
d738 1
d743 1
d795 1
d800 1
d815 1
d818 1
a818 1

d953 1
d956 1
d992 1
d996 1
d1002 1
d1006 1
d1134 1
d1139 1
@


1.4
log
@extra const
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.3 1998/05/11 06:13:46 deraadt Exp $	*/
d120 156
@


1.3
log
@const a few more calls
@
text
@d1 1
a1 1
/*	$OpenBSD: sysv_msg.c,v 1.2 1996/03/03 17:20:05 niklas Exp $	*/
d373 1
a373 1
	char *user_msgp = SCARG(uap, msgp);
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d368 1
a368 1
		syscallarg(void *) msgp;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: sysv_msg.c,v 1.17 1995/10/07 06:28:40 mycroft Exp $	*/
d40 3
a42 1
int
a45 1
	vm_offset_t whocares1, whocares2;
d137 1
a137 1
	int i, rval, eval;
d178 1
a178 1
		if ((eval = ipcperm(cred, &msqptr->msg_perm, IPC_M)))
d270 1
a270 1
	register struct msqid_ds *msqptr;
d427 1
a427 1
		 * check msgsz
d431 1
a431 1
		if (msgsz < 0 || msgsz > msqptr->msg_qbytes) {
d754 2
d762 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
