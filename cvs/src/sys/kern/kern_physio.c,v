head	1.43;
access;
symbols
	OPENBSD_6_2:1.43.0.12
	OPENBSD_6_2_BASE:1.43
	OPENBSD_6_1:1.43.0.10
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.43.0.6
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.39.0.14
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.10
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.8
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.6
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.4
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.28.0.8
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.6
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.24.0.4
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.2
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.22.0.8
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.6
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.4
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.42;
commitid	p4LJxGKbi0BU2cG6;

1.42
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	yv0ECmCdICvq576h;

1.41
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.40;
commitid	uzzBR7hz9ncd4O6G;

1.40
date	2014.07.13.23.49.40;	author uebayasi;	state Exp;
branches;
next	1.39;
commitid	z6zKhO7L2b0jL3QY;

1.39
date	2011.07.18.02.49.20;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	2011.07.07.16.50.15;	author beck;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.07.08.55.38;	author dhill;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.06.21.06.14;	author beck;	state Exp;
branches;
next	1.35;

1.35
date	2011.07.05.10.04.27;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	2011.07.05.09.46.11;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	2011.05.08.09.07.06;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	2010.07.01.21.27.39;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2010.06.23.14.18.32;	author thib;	state Exp;
branches;
next	1.29;

1.29
date	2009.06.04.21.27.14;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.21.02.28.47;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.29.12.24.17;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.11.15.17.25.40;	author jmc;	state Exp;
branches;
next	1.24;

1.24
date	2005.12.08.14.02.47;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.28.00.14.28;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2003.11.08.19.17.28;	author jmc;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.10.17.37.51;	author art;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.11.28.13.47.39;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.15.23.15.15;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.09.15.33.02;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.27.04.49.44;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.26.06.27.39;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.22.14.14.09;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.07.22.16.35;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.09.16.46.52;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.16.22.11.04;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.12.02.20.39.32;	author art;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.11.05.01.19.13;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.02.26.05.13.22;	author art;	state Exp;
branches;
next	1.4;

1.4
date	97.07.25.03.25.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.25.02.44.22;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.19.50;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2000.03.24.09.09.24;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.05.14.22.32.41;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.07.04.10.48.23;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.7.2.8;

1.7.2.8
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.7.2.9;

1.7.2.9
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.43
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: kern_physio.c,v 1.42 2014/11/16 12:31:00 deraadt Exp $	*/
/*	$NetBSD: kern_physio.c,v 1.28 1997/05/19 10:43:28 pk Exp $	*/

/*-
 * Copyright (c) 1994 Christopher G. Demetriou
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_physio.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/pool.h>

#include <uvm/uvm_extern.h>

/*
 * The routines implemented in this file are described in:
 *	Leffler, et al.: The Design and Implementation of the 4.3BSD
 *	    UNIX Operating System (Addison Welley, 1989)
 * on pages 231-233.
 */

/*
 * Do "physical I/O" on behalf of a user.  "Physical I/O" is I/O directly
 * from the raw device to user buffers, and bypasses the buffer cache.
 *
 * Comments in brackets are from Leffler, et al.'s pseudo-code implementation.
 */
int
physio(void (*strategy)(struct buf *), dev_t dev, int flags,
    void (*minphys)(struct buf *), struct uio *uio)
{
	struct iovec *iovp;
	struct proc *p = curproc;
	int error, done, i, s, todo;
	struct buf *bp;

	if ((uio->uio_offset % DEV_BSIZE) != 0)
		return (EINVAL);

	error = 0;
	flags &= B_READ | B_WRITE;

	/* Create a buffer. */
	s = splbio();
	bp = pool_get(&bufpool, PR_WAITOK | PR_ZERO);

	/* [set up the fixed part of the buffer for a transfer] */
	bp->b_vnbufs.le_next = NOLIST;
	bp->b_dev = dev;
	bp->b_error = 0;
	bp->b_proc = p;
	bp->b_flags = B_BUSY;
	LIST_INIT(&bp->b_dep);
	splx(s);

	/*
	 * [while there are data to transfer and no I/O error]
	 * Note that I/O errors are handled with a 'goto' at the bottom
	 * of the 'while' loop.
	 */
	for (i = 0; i < uio->uio_iovcnt; i++) {
		iovp = &uio->uio_iov[i];
		while (iovp->iov_len > 0) {
			void *map = NULL;

			/*
			 * [mark the buffer busy for physical I/O]
			 * (i.e. set B_PHYS (because it's an I/O to user
			 * memory), and B_RAW, because B_RAW is to be
			 * "Set by physio for raw transfers.", in addition
			 * to the "busy" and read/write flag.)
			 */
			CLR(bp->b_flags, B_DONE | B_ERROR);
			bp->b_flags |= (B_BUSY | B_PHYS | B_RAW | flags);

			/* [set up the buffer for a maximum-sized transfer] */
			bp->b_blkno = btodb(uio->uio_offset);

			/*
			 * Because iov_len is unsigned but b_bcount is signed,
			 * an overflow is possible. Therefore bound to MAXPHYS
			 * before calling minphys.
			 */
			if (iovp->iov_len > MAXPHYS)
				bp->b_bcount = MAXPHYS;
			else
				bp->b_bcount = iovp->iov_len;

			/*
			 * [call minphys to bound the transfer size]
			 * and remember the amount of data to transfer,
			 * for later comparison.
			 */
			(*minphys)(bp);
			todo = bp->b_bcount;
			KASSERTMSG(todo >= 0, "minphys broken");
			KASSERTMSG(todo <= MAXPHYS, "minphys broken");

			/*
			 * [lock the part of the user address space involved
			 *    in the transfer]
			 * Beware vmapbuf(); it clobbers b_data and
			 * saves it in b_saveaddr.  However, vunmapbuf()
			 * restores it.
			 */
			error = uvm_vslock_device(p, iovp->iov_base, todo,
			    (flags & B_READ) ?
			    PROT_READ | PROT_WRITE : PROT_READ, &map);
			if (error)
				goto done;
			if (map) {
				bp->b_data = map;
			} else {
				bp->b_data = iovp->iov_base;
				vmapbuf(bp, todo);
			}

			/* [call strategy to start the transfer] */
			(*strategy)(bp);

			/*
			 * Note that the raise/wait/lower/get error
			 * steps below would be done by biowait(), but
			 * we want to unlock the address space before
			 * we lower the priority.
			 *
			 * [raise the priority level to splbio]
			 */
			s = splbio();

			/* [wait for the transfer to complete] */
			while ((bp->b_flags & B_DONE) == 0)
				tsleep(bp, PRIBIO + 1, "physio", 0);

			/* Mark it busy again, so nobody else will use it. */
			bp->b_flags |= B_BUSY;

			/* [lower the priority level] */
			splx(s);

			/*
			 * [unlock the part of the address space previously
			 *    locked]
			 */
			if (!map)
				vunmapbuf(bp, todo);
			uvm_vsunlock_device(p, iovp->iov_base, todo, map);

			/* remember error value (save a splbio/splx pair) */
			if (bp->b_flags & B_ERROR)
				error = (bp->b_error ? bp->b_error : EIO);

			/*
			 * [deduct the transfer size from the total number
			 *    of data to transfer]
			 */
			done = bp->b_bcount - bp->b_resid;
			KASSERTMSG(done >= 0, "strategy broken");
			KASSERTMSG(done <= todo, "strategy broken");
			iovp->iov_len -= done;
			iovp->iov_base = (caddr_t)iovp->iov_base + done;
			uio->uio_offset += done;
			uio->uio_resid -= done;

			/*
			 * Now, check for an error.
			 * Also, handle weird end-of-disk semantics.
			 */
			if (error || done < todo)
				goto done;
		}
	}

done:
	/*
	 * [clean up the state of the buffer]
	 */
	s = splbio();
	/* XXXCDC: is this necessary? */
	if (bp->b_vp)
		brelvp(bp);
	splx(s);
	pool_put(&bufpool, bp);

	return (error);
}

/*
 * Leffler, et al., says on p. 231:
 * "The minphys() routine is called by physio() to adjust the
 * size of each I/O transfer before the latter is passed to
 * the strategy routine..."
 *
 * so, just adjust the buffer's count accounting to MAXPHYS here,
 * and return the new count;
 */
void
minphys(struct buf *bp)
{

	if (bp->b_bcount > MAXPHYS)
		bp->b_bcount = MAXPHYS;
}
@


1.42
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.41 2014/09/14 14:17:25 jsg Exp $	*/
a43 1
#include <sys/conf.h>
@


1.41
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.40 2014/07/13 23:49:40 uebayasi Exp $	*/
d142 1
a142 1
			    VM_PROT_READ | VM_PROT_WRITE : VM_PROT_READ, &map);
@


1.40
log
@KASSERTMSG(9): New kernel assertion with message

KASSERT() is annoying as it only prints the expression as a string.  If you
(developers) want to know a little more information, you have to do:

	#ifdef DIAGNOSTIC
		if (bad)
			panic(...);
	#endif

KASSERTMSG() replaces it into a single line:

		KASSERTMSG(!bad, ...);

Taken from NetBSD.

(There is a concern that KASSERT() messages are too long; consume more memory,
and not friendly for small monitors.  This have to be considered & revisited
later.)

"Like" from henning@@
Man page review & advices from jmc@@ and schwarze@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a44 1
#include <sys/proc.h>
@


1.39
log
@Revert vnd(4) to its older less strict behavior.

Verified by deraadt@@ to fix distrib/sgi/iso.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.38 2011/07/07 16:50:15 beck Exp $	*/
d131 2
a132 6
#ifdef DIAGNOSTIC
			if (todo < 0)
				panic("todo < 0; minphys broken");
			if (todo > MAXPHYS)
				panic("todo > MAXPHYS; minphys broken");
#endif
d193 2
a194 6
#ifdef DIAGNOSTIC
			if (done < 0)
				panic("done < 0; strategy broken");
			if (done > todo)
				panic("done > todo; strategy broken");
#endif
@


1.38
log
@set flags correctly in physio - now with actual clearing of B_DONE and B_ERROR
between re-use of the same buffer to re-call strategy() - large dd's now
work again which were broken by my last commit of this.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.37 2011/07/07 08:55:38 dhill Exp $	*/
a201 2
			if ((done % DEV_BSIZE) != 0)
				panic("(done % DEV_BSIZE) != 0; strategy broken");
@


1.37
log
@back out last change;  it caused dd on usb drive to lock the machine.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.36 2011/07/06 21:06:14 beck Exp $	*/
d108 2
a109 1
			bp->b_flags = B_BUSY | B_PHYS | B_RAW | flags;
@


1.36
log
@stylistic clean of buffer flags assignment to be more obviously not a
destructive assignment of flags.
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.35 2011/07/05 10:04:27 matthew Exp $	*/
d108 1
a108 1
			bp->b_flags |= (B_BUSY | B_PHYS | B_RAW | flags);
@


1.35
log
@If uvm_vslock_device() fails, just exit the loop.  None of the
after_unlock code is needed if this happens, and running it was even
wrong because we weren't setting b_resid, so uio_offset (and higher
up, f_offset) would be incorrectly adjusted.

Discussed with deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.34 2011/07/05 09:46:11 matthew Exp $	*/
d108 1
a108 1
			bp->b_flags = B_BUSY | B_PHYS | B_RAW | flags;
@


1.34
log
@Enforce that raw disk I/O is only initiated on block boundaries in
physio().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.33 2011/05/08 09:07:06 dlg Exp $	*/
d147 2
a148 5
			if (error) {
				bp->b_flags |= B_ERROR;
				bp->b_error = error;
				goto after_unlock;
			}
a185 1
after_unlock:
@


1.33
log
@because bufs now come out of a pool rather than a global list of staticly
allocated structs, they wont be shared. we dont have to do the silly
B_WANTED dance anymore. get rid of a bunch of comments that talk about
how we're stealing from the swapper, which is a lie now.

tweaks from oga@@ scrutiny by matthew@@
ok miod@@ oga@@ thib@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.32 2010/09/22 01:18:57 matthew Exp $	*/
d72 3
d205 2
@


1.32
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.31 2010/07/01 21:27:39 art Exp $	*/
a54 4
 *
 * The routines "getphysbuf" and "putphysbuf" steal and return a swap
 * buffer.  Leffler, et al., says that swap buffers are used to do the
 * I/O, so raw I/O requests don't have to be single-threaded.
a56 3
struct buf *getphysbuf(void);
void putphysbuf(struct buf *bp);

a75 3
	bp = getphysbuf();

	/* [raise the processor priority level to splbio;] */
d77 1
a77 14

	/* [while the buffer is marked busy] */
	while (bp->b_flags & B_BUSY) {
		/* [mark the buffer wanted] */
		bp->b_flags |= B_WANTED;
		/* [wait until the buffer is available] */
		tsleep(bp, PRIBIO+1, "physbuf", 0);
	}

	/* Mark it busy, so nobody else will use it. */
	bp->b_flags |= B_BUSY;

	/* [lower the priority level] */
	splx(s);
d80 1
d84 1
d86 1
a219 2
	 * Remember if somebody wants it, so we can wake them up below.
	 * Also, if we had to steal it, give it back.
a221 35
	bp->b_flags &= ~(B_BUSY | B_PHYS | B_RAW);
	putphysbuf(bp);
	splx(s);

	return (error);
}

/*
 * Get a swap buffer structure, for use in physical I/O.
 * Mostly taken from /sys/vm/swap_pager.c, except that it no longer
 * records buffer list-empty conditions, and sleeps at PRIBIO + 1,
 * rather than PSWP + 1 (and on a different wchan).
 */
struct buf *
getphysbuf(void)
{
	struct buf *bp;

	bp = pool_get(&bufpool, PR_WAITOK | PR_ZERO);
	bp->b_vnbufs.le_next = NOLIST;

	return (bp);
}

/*
 * Get rid of a swap buffer structure which has been used in physical I/O.
 * Mostly taken from /sys/vm/swap_pager.c, except that it now uses
 * wakeup() rather than the VM-internal thread_wakeup(), and that the caller
 * must mask disk interrupts, rather than putphysbuf() itself.
 */
void
putphysbuf(struct buf *bp)
{
	splassert(IPL_BIO);

d225 2
d228 1
a228 5
#ifdef DIAGNOSTIC
	if (bp->b_flags & B_WANTED)
		panic("putphysbuf: private buf B_WANTED");
#endif
	pool_put(&bufpool, bp);
@


1.31
log
@Implement vs{,un}lock_device and use it for physio.

Just like normal vs{,un}lock, but in case the pages we get are not dma
accessible, we bounce them, if they are dma acessible, the functions behave
exactly like normal vslock. The plan for the future is to have fault_wire
allocate dma acessible pages so that we don't need to bounce (especially
in cases where the same buffer is reused for physio over and over again),
but for now, keep it as simple as possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.30 2010/06/23 14:18:32 thib Exp $	*/
d71 1
a71 1
physio(void (*strategy)(struct buf *), struct buf *bp, dev_t dev, int flags,
d76 2
a77 1
	int error, done, i, nobuf, s, todo;
d82 2
a83 3
	/* Make sure we have a buffer, creating one if necessary. */
	if ((nobuf = (bp == NULL)) != 0)
		bp = getphysbuf();
d245 1
a245 12
	if (nobuf)
		putphysbuf(bp);
	else {
		/*
		 * [if another process is waiting for the raw I/O buffer,
		 *    wake up processes waiting to do physical I/O]
		 */
		if (bp->b_flags & B_WANTED) {
			bp->b_flags &= ~B_WANTED;
			wakeup(bp);
		}
	}
@


1.30
log
@No need to do the splbio/splx dance around the pool_get in
getphysbuf() as the bufpool is already protected.

From Matthew Dempsky <matthew at dempsky dot org>
OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.29 2009/06/04 21:27:14 oga Exp $	*/
d116 2
a128 1
			bp->b_data = iovp->iov_base;
d161 1
a161 1
			error = uvm_vslock(p, bp->b_data, todo,
d163 1
a163 1
			    VM_PROT_READ | VM_PROT_WRITE : VM_PROT_READ);
d169 6
a174 1
			vmapbuf(bp, todo);
d203 3
a205 2
			vunmapbuf(bp, todo);
			uvm_vsunlock(p, bp->b_data, todo);
@


1.29
log
@obvious shrinkage.

ok krw@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.28 2007/05/26 20:26:51 pedro Exp $	*/
a264 1
	int s;
a265 1
	s = splbio();
a266 2
	splx(s);

@


1.28
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.27 2006/12/21 02:28:47 krw Exp $	*/
d268 1
a268 1
	bp = pool_get(&bufpool, PR_WAITOK);
a270 3
	bzero(bp, sizeof(*bp));

	/* XXXCDC: are the following two lines necessary? */
@


1.27
log
@'tranfer' -> 'transfer' in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.26 2006/11/29 12:24:17 miod Exp $	*/
d265 1
d267 1
d269 2
d288 2
@


1.26
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.25 2006/11/15 17:25:40 jmc Exp $	*/
d140 1
a140 1
			 * [call minphys to bound the tranfer size]
@


1.25
log
@typos; from bret lambert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.24 2005/12/08 14:02:47 krw Exp $	*/
a159 1
			PHOLD(p);
a199 1
			PRELE(p);
@


1.24
log
@Don't panic for pathological i/o sizes unless minphys() really is
broken. Eliminate an unneeded variable and potential conversion issues
in SCIOCCOMMAND code before calling physio.

Similar to what NetBSD does.

Fixes cdda2wav vs "Billie Holiday - Songs for Distingue Lovers"
problem noted by Alexandre Ratchov.  Tested by Alexandre.

ok marco@@ pedro@@ deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.23 2005/11/28 00:14:28 jsg Exp $	*/
d119 1
a119 1
			 * memory, and B_RAW, because B_RAW is to be
d245 1
a245 1
		 *    wake up processes waiting to do physical I/O;
@


1.23
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.22 2003/11/08 19:17:28 jmc Exp $	*/
a126 1
			bp->b_bcount = iovp->iov_len;
d128 10
@


1.22
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.21 2003/07/21 22:44:50 tedu Exp $	*/
d71 2
a72 7
physio(strategy, bp, dev, flags, minphys, uio)
	void (*strategy)(struct buf *);
	struct buf *bp;
	dev_t dev;
	int flags;
	void (*minphys)(struct buf *);
	struct uio *uio;
d255 1
a255 1
getphysbuf()
d275 1
a275 2
putphysbuf(bp)
	struct buf *bp;
d298 1
a298 2
minphys(bp)
	struct buf *bp;
@


1.21
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.20 2003/06/02 23:28:05 millert Exp $	*/
d283 1
a283 1
	/* XXXCDC: is this necesary? */
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.19 2002/03/14 01:27:04 millert Exp $	*/
d98 1
a98 1
		tsleep((caddr_t)bp, PRIBIO+1, "physbuf", 0);
d182 1
a182 1
				tsleep((caddr_t) bp, PRIBIO + 1, "physio", 0);
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.18 2001/12/10 17:37:51 art Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.18
log
@No need for uvm_useracc here now. vslock catches those problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.17 2001/11/28 13:47:39 art Exp $	*/
d65 2
a66 2
struct buf *getphysbuf __P((void));
void putphysbuf __P((struct buf *bp));
d76 1
a76 1
	void (*strategy) __P((struct buf *));
d80 1
a80 1
	void (*minphys) __P((struct buf *));
@


1.18.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.18 2001/12/10 17:37:51 art Exp $	*/
d65 2
a66 2
struct buf *getphysbuf(void);
void putphysbuf(struct buf *bp);
d76 1
a76 1
	void (*strategy)(struct buf *);
d80 1
a80 1
	void (*minphys)(struct buf *);
@


1.17
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.16 2001/11/15 23:15:15 art Exp $	*/
a88 15

	/*
	 * [check user read/write access to the data buffer]
	 *
	 * Check each iov one by one.  Note that we know if we're reading or
	 * writing, so we ignore the uio's rw parameter.  Also note that if
	 * we're doing a read, that's a *write* to user-space.
	 */
	if (uio->uio_segflg == UIO_USERSPACE)
		for (i = 0; i < uio->uio_iovcnt; i++)
			/* XXX - obsolete now that vslock can error? */
			if (!uvm_useracc(uio->uio_iov[i].iov_base,
			    uio->uio_iov[i].iov_len,
			    (flags == B_READ) ? B_WRITE : B_READ))
				return (EFAULT);
@


1.16
log
@Remove creds from struct buf, move the creds that nfs need into the nfs node.
While in the area, convert nfs node allocation from malloc to pool and do
some cleanups.
Based on the UBC changes in NetBSD. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.15 2001/11/09 15:33:02 art Exp $	*/
d176 4
a179 3
			if (uvm_vslock(p, bp->b_data, todo, (flags & B_READ) ?
			    VM_PROT_READ | VM_PROT_WRITE : VM_PROT_READ) !=
			    KERN_SUCCESS) {
d181 1
a181 1
				bp->b_error = EFAULT;
@


1.15
log
@Use bufpool, not malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.14 2001/11/06 19:53:20 miod Exp $	*/
a285 1
	bp->b_rcred = bp->b_wcred = NOCRED;
@


1.14
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.13 2001/06/27 04:49:44 art Exp $	*/
d50 1
a50 1
#include <sys/malloc.h>
d282 1
a282 1
	bp = malloc(sizeof(*bp), M_TEMP, M_WAITOK);
d306 1
d309 2
a310 1
	free(bp, M_TEMP);
@


1.13
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.12 2001/06/26 06:27:39 aaron Exp $	*/
a50 2

#include <vm/vm.h>
@


1.12
log
@Appease gcc by not using void pointers in arithmetic operations; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.11 2001/06/22 14:14:09 deraadt Exp $	*/
a53 1
#if defined(UVM)
a54 1
#endif
a100 1
#if defined(UVM) /* XXXCDC: map not locked, rethink */
a105 6
#else
			if (!useracc(uio->uio_iov[i].iov_base,
			    uio->uio_iov[i].iov_len,
			    (flags == B_READ) ? B_WRITE : B_READ))
				return (EFAULT);
#endif
a177 1
#if defined(UVM)
a184 3
#else
			vslock(bp->b_data, todo);
#endif
a214 1
#if defined(UVM)
a216 3
#else
			vsunlock(bp->b_data, todo);
#endif
a282 12
#if !defined(UVM)
	int s;

	s = splbio();
	while (bswlist.b_actf == NULL) {
		bswlist.b_flags |= B_WANTED;
		tsleep((caddr_t)&bswlist, PRIBIO + 1, "getphys", 0);
	}
	bp = bswlist.b_actf;
	bswlist.b_actf = bp->b_actf;
	splx(s);
#else
d290 1
a290 1
#endif
a303 10
#if !defined(UVM)
	bp->b_actf = bswlist.b_actf;
	bswlist.b_actf = bp;
	if (bp->b_vp)
		brelvp(bp);
	if (bswlist.b_flags & B_WANTED) {
		bswlist.b_flags &= ~B_WANTED;
		wakeup(&bswlist);
	}
#else
a310 1
#endif
@


1.11
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.10 2001/05/07 22:16:35 art Exp $	*/
d252 1
a252 1
			iovp->iov_base += done;
@


1.10
log
@Check for failure now that uvm_vslock can return one. Before this, there was
a risk that we could crash when doing physio/sysctl when the system was
completly out of RAM and swap.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.9 2000/11/09 16:46:52 art Exp $	*/
d106 2
a107 2
				     uio->uio_iov[i].iov_len,
				     (flags == B_READ) ? B_WRITE : B_READ))
d252 3
a254 3
                        iovp->iov_base += done;
                        uio->uio_offset += done;
                        uio->uio_resid -= done;
d304 7
a310 7
        while (bswlist.b_actf == NULL) {
                bswlist.b_flags |= B_WANTED;
                tsleep((caddr_t)&bswlist, PRIBIO + 1, "getphys", 0);
        }
        bp = bswlist.b_actf;
        bswlist.b_actf = bp->b_actf;
        splx(s);
d334 8
a341 8
        bp->b_actf = bswlist.b_actf;
        bswlist.b_actf = bp;
        if (bp->b_vp)
                brelvp(bp);
        if (bswlist.b_flags & B_WANTED) {
                bswlist.b_flags &= ~B_WANTED;
                wakeup(&bswlist);
        }
@


1.9
log
@Use PHOLD/PRELE instead of manually fiddling with p_holdcnt.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.8 2000/03/16 22:11:04 art Exp $	*/
d104 1
d188 7
a194 2
                        uvm_vslock(p, bp->b_data, todo, (flags & B_READ) ?
				VM_PROT_READ | VM_PROT_WRITE : VM_PROT_READ);
d230 1
@


1.8
log
@Bring in some new UVM code from NetBSD (not current).

 - Introduce a new type of map that are interrupt safe and never allow faults
   in them. mb_map and kmem_map are made intrsafe.
 - Add "access protection" to uvm_vslock (to be passed down to uvm_fault and
   later to pmap_enter).
 - madvise(2) now works.
 - various cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.7 1999/12/02 20:39:32 art Exp $	*/
d185 1
a185 1
			p->p_holdcnt++;
d227 1
a227 1
			p->p_holdcnt--;
@


1.7
log
@Init the buffer dependency list.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.6 1999/11/05 01:19:13 mickey Exp $	*/
d187 2
a188 1
			uvm_vslock(p, bp->b_data, todo);
@


1.7.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d187 1
a187 2
                        uvm_vslock(p, bp->b_data, todo, (flags & B_READ) ?
				VM_PROT_READ | VM_PROT_WRITE : VM_PROT_READ);
@


1.7.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.9 2000/11/09 16:46:52 art Exp $	*/
d185 1
a185 1
			PHOLD(p);
d227 1
a227 1
			PRELE(p);
@


1.7.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.7.2.2 2001/05/14 22:32:41 niklas Exp $	*/
d54 1
d56 1
d103 1
a103 1
			/* XXX - obsolete now that vslock can error? */
d105 5
d113 1
d186 6
a191 7
			if (uvm_vslock(p, bp->b_data, todo, (flags & B_READ) ?
			    VM_PROT_READ | VM_PROT_WRITE : VM_PROT_READ) !=
			    KERN_SUCCESS) {
				bp->b_flags |= B_ERROR;
				bp->b_error = EFAULT;
				goto after_unlock;
			}
d222 1
d224 3
a226 1
after_unlock:
d245 3
a247 3
			iovp->iov_base = (caddr_t)iovp->iov_base + done;
			uio->uio_offset += done;
			uio->uio_resid -= done;
d293 12
d312 1
a312 1

d326 10
d343 1
@


1.7.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 3
a52 1
#include <sys/pool.h>
d284 1
a284 1
	bp = pool_get(&bufpool, PR_WAITOK);
a307 1
#ifdef DIAGNOSTIC
d310 1
a310 2
#endif
	pool_put(&bufpool, bp);
@


1.7.2.5
log
@Merge in -current
@
text
@d176 3
a178 4
			error = uvm_vslock(p, bp->b_data, todo,
			    (flags & B_READ) ?
			    VM_PROT_READ | VM_PROT_WRITE : VM_PROT_READ);
			if (error) {
d180 1
a180 1
				bp->b_error = error;
d286 1
@


1.7.2.6
log
@Merge in trunk
@
text
@d90 15
@


1.7.2.7
log
@Merge in -current from about a week ago
@
text
@d65 2
a66 2
struct buf *getphysbuf(void);
void putphysbuf(struct buf *bp);
d76 1
a76 1
	void (*strategy)(struct buf *);
d80 1
a80 1
	void (*minphys)(struct buf *);
@


1.7.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.7.2.7 2002/03/28 11:43:04 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d98 1
a98 1
		tsleep(bp, PRIBIO+1, "physbuf", 0);
d182 1
a182 1
				tsleep(bp, PRIBIO + 1, "physio", 0);
d283 1
a283 1
	/* XXXCDC: is this necessary? */
@


1.6
log
@s/memset/bzero/; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.5 1999/02/26 05:13:22 art Exp $	*/
d140 1
@


1.5
log
@mostly name changes and allocation chnges for uvm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.4 1997/07/25 03:25:32 deraadt Exp $	*/
d305 1
a305 1
	memset(bp, 0, sizeof(*bp));
@


1.4
log
@indent properly
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.3 1997/07/25 02:44:22 mickey Exp $	*/
d50 1
d54 4
d103 6
d113 1
d185 3
d189 1
d220 3
d224 1
d291 1
d302 9
d324 1
a324 1

d333 9
@


1.3
log
@from netbsd: check user access rights only if UIO_USERSPACE
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_physio.c,v 1.2 1996/03/03 17:19:50 niklas Exp $	*/
d99 2
a100 2
				     uio->uio_iov[i].iov_len,
				     (flags == B_READ) ? B_WRITE : B_READ))
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: kern_physio.c,v 1.26 1996/02/04 02:15:51 christos Exp $	*/
d96 6
a101 4
	for (i = 0; i < uio->uio_iovcnt; i++)
		if (!useracc(uio->uio_iov[i].iov_base, uio->uio_iov[i].iov_len,
		    (flags == B_READ) ? B_WRITE : B_READ))
			return (EFAULT);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: kern_physio.c,v 1.25 1995/10/10 02:51:45 mycroft Exp $	*/
d51 2
d102 1
a102 1
	if (nobuf = (bp == NULL))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
