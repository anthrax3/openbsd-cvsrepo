head	1.45;
access;
symbols
	OPENBSD_6_2:1.45.0.4
	OPENBSD_6_2_BASE:1.45
	OPENBSD_6_1:1.44.0.8
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.44.0.4
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.43.0.6
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.37.0.10
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.8
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.6
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.4
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.36.0.8
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.6
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.2
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.4
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.35.0.4
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.34.0.10
	OPENBSD_4_3_BASE:1.34
	OPENBSD_4_2:1.34.0.8
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.34.0.6
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.34.0.4
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.33.0.10
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.33.0.8
	OPENBSD_3_7_BASE:1.33
	OPENBSD_3_6:1.33.0.6
	OPENBSD_3_6_BASE:1.33
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	OPENBSD_3_5:1.33.0.4
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.32
	OPENBSD_3_3:1.31.0.4
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.31.0.2
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	UBC_SYNC_B:1.31
	UBC:1.26.0.4
	UBC_BASE:1.26
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.19.0.4
	OPENBSD_2_7_BASE:1.19
	SMP:1.19.0.2
	SMP_BASE:1.19
	kame_19991208:1.18
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.15.0.6
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.15.0.4
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.11.0.4
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10;
locks; strict;
comment	@ * @;


1.45
date	2017.04.30.16.45.46;	author mpi;	state Exp;
branches;
next	1.44;
commitid	2Gtqjzrin9LL2yHk;

1.44
date	2015.09.11.07.13.58;	author miod;	state Exp;
branches;
next	1.43;
commitid	WZlt70060zREibS9;

1.43
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	3SGDR5EjcwE01W8S;

1.42
date	2014.07.23.20.49.53;	author mpi;	state Exp;
branches;
next	1.41;
commitid	t7AzIIEPGdREabqe;

1.41
date	2014.07.13.15.29.04;	author tedu;	state Exp;
branches;
next	1.40;
commitid	bFFVdS3JEaMhyZxJ;

1.40
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.39;
commitid	QlVV51SZgNFxsXxC;

1.39
date	2014.01.21.01.48.44;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2013.12.12.20.56.01;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2011.06.01.04.35.22;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.02.12.46.33;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2008.03.24.21.35.03;	author maja;	state Exp;
branches;
next	1.34;

1.34
date	2005.12.09.09.09.52;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.02.21.14.47;	author maja;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.03.21.14.59;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2002.07.29.23.18.57;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2002.07.25.01.26.01;	author nordin;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.02.12.59.58;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.14.03.16.09;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.13.07.14.39;	author miod;	state Exp;
branches
	1.26.4.1;
next	1.25;

1.25
date	2001.02.13.14.43.57;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.05.19.24.07;	author maja;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.04.21.42.10;	author maja;	state Exp;
branches;
next	1.22;

1.22
date	2000.08.08.21.42.40;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.06.00.59.01;	author todd;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.19.17.07.05;	author maja;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.08.23.23.37;	author d;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	99.10.04.20.04.31;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.08.17.11.02.40;	author art;	state Exp;
branches;
next	1.16;

1.16
date	99.04.28.18.01.22;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	98.03.03.05.43.03;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	98.03.03.05.16.19;	author ryker;	state Exp;
branches;
next	1.13;

1.13
date	98.01.04.10.39.04;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.01.04.01.21.21;	author maja;	state Exp;
branches;
next	1.11;

1.11
date	96.11.21.12.47.16;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.09.06.15.35.09;	author maja;	state Exp;
branches;
next	1.9;

1.9
date	96.09.06.12.43.41;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.09.06.08.53.43;	author maja;	state Exp;
branches;
next	1.7;

1.7
date	96.09.02.02.46.39;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.15.13.49.50;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.07.27.11.27.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.07.02.06.52.00;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.06.27.08.43.06;	author maja;	state Exp;
branches;
next	1.2;

1.2
date	96.06.26.09.55.53;	author maja;	state Exp;
branches;
next	1.1;

1.1
date	96.06.23.19.34.30;	author maja;	state Exp;
branches;
next	;

1.19.2.1
date	2001.05.14.22.32.43;	author niklas;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.07.04.10.48.32;	author niklas;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.19.2.6;

1.19.2.6
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	;

1.26.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.26.4.2;

1.26.4.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.26.4.3;

1.26.4.3
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: subr_userconf.c,v 1.44 2015/09/11 07:13:58 miod Exp $	*/

/*
 * Copyright (c) 1996-2001 Mats O Jansson <moj@@stacken.kth.se>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/time.h>

#include <dev/cons.h>

extern char *locnames[];
extern short locnamp[];
extern short cfroots[];
extern int cfroots_size;
extern int pv_size;
extern short pv[];
extern struct timezone tz;
extern char *pdevnames[];
extern int pdevnames_size;
extern struct pdevinit pdevinit[];

int userconf_base = 16;				/* Base for "large" numbers */
int userconf_maxdev = -1;			/* # of used device slots   */
int userconf_totdev = -1;			/* # of device slots        */
int userconf_maxlocnames = -1;			/* # of locnames            */
int userconf_cnt = -1;				/* Line counter for ...     */
int userconf_lines = 12;			/* ... # of lines per page  */
int userconf_histlen = 0;
int userconf_histcur = 0;
char userconf_history[1024];
int userconf_histsz = sizeof(userconf_history);
char userconf_argbuf[40];			/* Additional input         */
char userconf_cmdbuf[40];			/* Command line             */
char userconf_histbuf[40];

void userconf_init(void);
int userconf_more(void);
void userconf_modify(char *, long *, long);
void userconf_hist_cmd(char);
void userconf_hist_int(long);
void userconf_hist_eoc(void);
void userconf_pnum(long);
void userconf_pdevnam(short);
void userconf_pdev(short);
int userconf_number(char *, long *, long);
int userconf_device(char *, long *, short *, short *);
int userconf_attr(char *, long *);
void userconf_change(int);
void userconf_disable(int);
void userconf_enable(int);
void userconf_help(void);
void userconf_list(void);
void userconf_show(void);
void userconf_common_attr_val(short, long *, char);
void userconf_show_attr(char *);
void userconf_common_dev(char *, int, short, short, char);
void userconf_common_attr(char *, int, char);
void userconf_add_read(char *, char, char *, int, long *);
void userconf_add(char *, int, short, short);
int userconf_parse(char *);

#define UC_CHANGE 'c'
#define UC_DISABLE 'd'
#define UC_ENABLE 'e'
#define UC_FIND 'f'
#define UC_SHOW 's'

char *userconf_cmds[] = {
	"add",		"a",
	"base",		"b",
	"change",	"c",
#if defined(DDB)
	"ddb",		"D",
#endif
	"disable",	"d",
	"enable",	"e",
	"exit",		"q",
	"find",		"f",
	"help",		"h",
	"list",		"l",
	"lines",	"L",
	"quit",		"q",
	"show",		"s",
	"timezone",	"t",
	"verbose",	"v",
	"?",		"h",
	"",		 "",
};

void
userconf_init(void)
{
	int i = 0;
	struct cfdata *cd;
	int   ln;

	while (cfdata[i].cf_attach != 0) {
		userconf_maxdev = i;
		userconf_totdev = i;

		cd = &cfdata[i];
		ln = cd->cf_locnames;
		while (locnamp[ln] != -1) {
			if (locnamp[ln] > userconf_maxlocnames)
				userconf_maxlocnames = locnamp[ln];
			ln++;
		}
		i++;
	}

	while (cfdata[i].cf_attach == 0) {
		userconf_totdev = i;
		i++;
	}
	userconf_totdev = userconf_totdev - 1;
}

int
userconf_more(void)
{
	int quit = 0;
	char c = '\0';

	if (userconf_cnt != -1) {
		if (userconf_cnt == userconf_lines) {
			printf("--- more ---");
			c = cngetc();
			userconf_cnt = 0;
			printf("\r            \r");
		}
		userconf_cnt++;
		if (c == 'q' || c == 'Q')
			quit = 1;
	}
	return (quit);
}

void
userconf_hist_cmd(char cmd)
{
	userconf_histcur = userconf_histlen;
	if (userconf_histcur < userconf_histsz) {
		userconf_history[userconf_histcur] = cmd;
		userconf_histcur++;
	}
}

void
userconf_hist_int(long val)
{
	snprintf(userconf_histbuf, sizeof userconf_histbuf, " %ld", val);
	if (userconf_histcur + strlen(userconf_histbuf) < userconf_histsz) {
		bcopy(userconf_histbuf,
		    &userconf_history[userconf_histcur],
		    strlen(userconf_histbuf));
		userconf_histcur = userconf_histcur + strlen(userconf_histbuf);
	}
}

void
userconf_hist_eoc(void)
{
	if (userconf_histcur < userconf_histsz) {
		userconf_history[userconf_histcur] = '\n';
		userconf_histcur++;
		userconf_histlen = userconf_histcur;
	}
}

void
userconf_pnum(long val)
{
	if (val > -2 && val < 16) {
		printf("%ld",val);
		return;
	}

	switch (userconf_base) {
	case 8:
		printf("0%lo",val);
		break;
	case 10:
		printf("%ld",val);
		break;
	case 16:
	default:
		printf("0x%lx",val);
		break;
	}
}

void
userconf_pdevnam(short dev)
{
	struct cfdata *cd;

	cd = &cfdata[dev];
	printf("%s", cd->cf_driver->cd_name);
	switch (cd->cf_fstate) {
	case FSTATE_NOTFOUND:
	case FSTATE_DNOTFOUND:
		printf("%d", cd->cf_unit);
		break;
	case FSTATE_FOUND:
		printf("*FOUND*");
		break;
	case FSTATE_STAR:
	case FSTATE_DSTAR:
		printf("*");
		break;
	default:
		printf("*UNKNOWN*");
		break;
	}
}

void
userconf_pdev(short devno)
{
	struct cfdata *cd;
	short *p;
	long  *l;
	int   ln;
	char c;

	if (devno > userconf_maxdev && devno <= userconf_totdev) {
		printf("%3d free slot (for add)\n", devno);
		return;
	}

	if (devno > userconf_totdev &&
	    devno <= userconf_totdev+pdevnames_size) {
		printf("%3d %s count %d", devno,
		    pdevnames[devno-userconf_totdev-1],
		    abs(pdevinit[devno-userconf_totdev-1].pdev_count));
		if (pdevinit[devno-userconf_totdev-1].pdev_count < 1)
			printf(" disable");
		printf(" (pseudo device)\n");
		return;
	}

	if (devno >  userconf_maxdev) {
		printf("Unknown devno (max is %d)\n", userconf_maxdev);
		return;
	}

	cd = &cfdata[devno];

	printf("%3d ", devno);
	userconf_pdevnam(devno);
	printf(" at");
	c = ' ';
	p = cd->cf_parents;
	if (*p == -1)
		printf(" root");
	while (*p != -1) {
		printf("%c", c);
		userconf_pdevnam(*p++);
		c = '|';
	}
	switch (cd->cf_fstate) {
	case FSTATE_NOTFOUND:
	case FSTATE_FOUND:
	case FSTATE_STAR:
		break;
	case FSTATE_DNOTFOUND:
	case FSTATE_DSTAR:
		printf(" disable");
		break;
	default:
		printf(" ???");
		break;
	}
	l = cd->cf_loc;
	ln = cd->cf_locnames;
	while (locnamp[ln] != -1) {
		printf(" %s ", locnames[locnamp[ln]]);
		ln++;
		userconf_pnum(*l++);
	}
	printf(" flags 0x%x\n", cd->cf_flags);
}

int
userconf_number(char *c, long *val, long limit)
{
	u_long num = 0;
	int neg = 0;
	int base = 10;

	if (*c == '-') {
		neg = 1;
		c++;
	}
	if (*c == '0') {
		base = 8;
		c++;
		if (*c == 'x' || *c == 'X') {
			base = 16;
			c++;
		}
	}
	while (*c != '\n' && *c != '\t' && *c != ' ' && *c != '\0') {
		u_char cc = *c;

		if (cc >= '0' && cc <= '9')
			cc = cc - '0';
		else if (cc >= 'a' && cc <= 'f')
			cc = cc - 'a' + 10;
		else if (cc >= 'A' && cc <= 'F')
			cc = cc - 'A' + 10;
		else
			return (-1);

		if (cc > base)
			return (-1);
		num = num * base + cc;
		c++;
	}

	if (neg && num > limit)	/* overflow */
		return (1);
	*val = neg ? - num : num;
	return (0);
}

int
userconf_device(char *cmd, long *len, short *unit, short *state)
{
	short u = 0, s = FSTATE_FOUND;
	int l = 0;
	char *c;

	c = cmd;
	while (*c >= 'a' && *c <= 'z') {
		l++;
		c++;
	}
	if (*c == '*') {
		s = FSTATE_STAR;
		c++;
	} else {
		while (*c >= '0' && *c <= '9') {
			s = FSTATE_NOTFOUND;
			u = u*10 + *c - '0';
			c++;
		}
	}
	while (*c == ' ' || *c == '\t' || *c == '\n')
		c++;

	if (*c == '\0') {
		*len = l;
		*unit = u;
		*state = s;
		return(0);
	}

	return(-1);
}

int
userconf_attr(char *cmd, long *val)
{
	char *c;
	short attr = -1, i = 0, l = 0;

	c = cmd;
	while (*c != ' ' && *c != '\t' && *c != '\n' && *c != '\0') {
		c++;
		l++;
	}

	while (i <= userconf_maxlocnames) {
		if (strlen(locnames[i]) == l) {
			if (strncasecmp(cmd, locnames[i], l) == 0)
				attr = i;
		}
		i++;
	}

	if (attr == -1) {
		return (-1);
	}

	*val = attr;

	return(0);
}

void
userconf_modify(char *item, long *val, long limit)
{
	int ok = 0;
	long a;
	char *c;
	int i;

	while (!ok) {
		printf("%s [", item);
		userconf_pnum(*val);
		printf("] ? ");

		i = getsn(userconf_argbuf, sizeof(userconf_argbuf));

		c = userconf_argbuf;
		while (*c == ' ' || *c == '\t' || *c == '\n') c++;

		if (*c != '\0') {
			if (userconf_number(c, &a, limit) == 0) {
				*val = a;
				ok = 1;
			} else {
				printf("Unknown argument\n");
			}
		} else {
			ok = 1;
		}
	}
}

void
userconf_change(int devno)
{
	struct cfdata *cd;
	char c = '\0';
	long  *l, tmp;
	int   ln;

	if (devno <=  userconf_maxdev) {
		userconf_pdev(devno);

		while (c != 'y' && c != 'Y' && c != 'n' && c != 'N') {
			printf("change (y/n) ?");
			c = cngetc();
			printf("\n");
		}

		if (c == 'y' || c == 'Y') {
			int share = 0, i, lklen;
			long *lk;

			/* XXX add cmd 'c' <devno> */
			userconf_hist_cmd('c');
			userconf_hist_int(devno);

			cd = &cfdata[devno];
			l = cd->cf_loc;
			ln = cd->cf_locnames;

			/*
			 * Search for some other driver sharing this
			 * locator table. if one does, we may need to
			 * replace the locators with a malloc'd copy.
			 */
			for (i = 0; cfdata[i].cf_driver; i++)
				if (i != devno && cfdata[i].cf_loc == l)
					share = 1;
			if (share) {
				for (i = 0; locnamp[ln+i] != -1 ; i++)
					;
				lk = l = mallocarray(i, sizeof(long),
				    M_TEMP, M_NOWAIT);
				if (lk == NULL) {
					printf("out of memory.\n");
					return;
				}
				lklen = i * sizeof(long);
				bcopy(cd->cf_loc, l, lklen);
			}

			while (locnamp[ln] != -1) {
				userconf_modify(locnames[locnamp[ln]], l,
				    LONG_MAX);

				/* XXX add *l */
				userconf_hist_int(*l);

				ln++;
				l++;
			}
			tmp = cd->cf_flags;
			userconf_modify("flags", &tmp, INT_MAX);
			userconf_hist_int(tmp);
			cd->cf_flags = tmp;

			if (share) {
				if (memcmp(cd->cf_loc, lk, lklen))
					cd->cf_loc = lk;
				else
					free(lk, M_TEMP, lklen);
			}

			printf("%3d ", devno);
			userconf_pdevnam(devno);
			printf(" changed\n");
			userconf_pdev(devno);
		}
		return;
	}

	if (devno > userconf_maxdev && devno <= userconf_totdev) {
		printf("%3d can't change free slot\n", devno);
		return;
	}

	if (devno > userconf_totdev &&
	    devno <= userconf_totdev+pdevnames_size) {
		userconf_pdev(devno);
		while (c != 'y' && c != 'Y' && c != 'n' && c != 'N') {
			printf("change (y/n) ?");
			c = cngetc();
			printf("\n");
		}

		if (c == 'y' || c == 'Y') {
			/* XXX add cmd 'c' <devno> */
			userconf_hist_cmd('c');
			userconf_hist_int(devno);

			tmp = pdevinit[devno-userconf_totdev-1].pdev_count;
			userconf_modify("count", &tmp, INT_MAX);
			userconf_hist_int(tmp);
			pdevinit[devno-userconf_totdev-1].pdev_count = tmp;

			printf("%3d %s changed\n", devno,
			    pdevnames[devno-userconf_totdev-1]);
			userconf_pdev(devno);

			/* XXX add eoc */
			userconf_hist_eoc();
		}
		return;
	}

	printf("Unknown devno (max is %d)\n", userconf_totdev+pdevnames_size);
}

void
userconf_disable(int devno)
{
	int done = 0;

	if (devno <= userconf_maxdev) {
		switch (cfdata[devno].cf_fstate) {
		case FSTATE_NOTFOUND:
			cfdata[devno].cf_fstate = FSTATE_DNOTFOUND;
			break;
		case FSTATE_STAR:
			cfdata[devno].cf_fstate = FSTATE_DSTAR;
			break;
		case FSTATE_DNOTFOUND:
		case FSTATE_DSTAR:
			done = 1;
			break;
		default:
			printf("Error unknown state\n");
			break;
		}

		printf("%3d ", devno);
		userconf_pdevnam(devno);
		if (done) {
			printf(" already");
		} else {
			/* XXX add cmd 'd' <devno> eoc */
			userconf_hist_cmd('d');
			userconf_hist_int(devno);
			userconf_hist_eoc();
		}
		printf(" disabled\n");

		return;
	}

	if (devno > userconf_maxdev && devno <= userconf_totdev) {
		printf("%3d can't disable free slot\n", devno);
		return;
	}

	if (devno > userconf_totdev &&
	    devno <= userconf_totdev+pdevnames_size) {
		printf("%3d %s", devno, pdevnames[devno-userconf_totdev-1]);
		if (pdevinit[devno-userconf_totdev-1].pdev_count < 1) {
			printf(" already ");
		} else {
			pdevinit[devno-userconf_totdev-1].pdev_count *= -1;
			/* XXX add cmd 'd' <devno> eoc */
			userconf_hist_cmd('d');
			userconf_hist_int(devno);
			userconf_hist_eoc();
		}
		printf(" disabled\n");
		return;
	}

	printf("Unknown devno (max is %d)\n", userconf_totdev+pdevnames_size);
}

void
userconf_enable(int devno)
{
	int done = 0;

	if (devno <= userconf_maxdev) {
		switch (cfdata[devno].cf_fstate) {
		case FSTATE_DNOTFOUND:
			cfdata[devno].cf_fstate = FSTATE_NOTFOUND;
			break;
		case FSTATE_DSTAR:
			cfdata[devno].cf_fstate = FSTATE_STAR;
			break;
		case FSTATE_NOTFOUND:
		case FSTATE_STAR:
			done = 1;
			break;
		default:
			printf("Error unknown state\n");
			break;
		}

		printf("%3d ", devno);
		userconf_pdevnam(devno);
		if (done) {
			printf(" already");
		} else {
			/* XXX add cmd 'e' <devno> eoc */
			userconf_hist_cmd('e');
			userconf_hist_int(devno);
			userconf_hist_eoc();
		}
		printf(" enabled\n");
		return;
	}

	if (devno > userconf_maxdev && devno <= userconf_totdev) {
		printf("%3d can't enable free slot\n", devno);
		return;
	}

	if (devno > userconf_totdev &&
	    devno <= userconf_totdev+pdevnames_size) {
		printf("%3d %s", devno, pdevnames[devno-userconf_totdev-1]);
		if (pdevinit[devno-userconf_totdev-1].pdev_count > 0) {
			printf(" already");
		} else {
			pdevinit[devno-userconf_totdev-1].pdev_count *= -1;
			/* XXX add cmd 'e' <devno> eoc */
			userconf_hist_cmd('e');
			userconf_hist_int(devno);
			userconf_hist_eoc();
		}
		printf(" enabled\n");
		return;
	}

	printf("Unknown devno (max is %d)\n", userconf_totdev+pdevnames_size);
}

void
userconf_help(void)
{
	int j = 0, k;

	printf("command   args                description\n");
	while (*userconf_cmds[j] != '\0') {
		printf("%s", userconf_cmds[j]);
		k = strlen(userconf_cmds[j]);
		while (k < 10) {
			printf(" ");
			k++;
		}
		switch (*userconf_cmds[j+1]) {
		case 'L':
			printf("[count]             number of lines before more");
			break;
		case 'a':
			printf("dev                 add a device");
			break;
		case 'b':
			printf("8|10|16             base on large numbers");
			break;
		case 'c':
			printf("devno|dev           change devices");
			break;
#if defined(DDB)
		case 'D':
			printf("                    enter ddb");
			break;
#endif
		case 'd':
			printf("attr val|devno|dev  disable devices");
			break;
		case 'e':
			printf("attr val|devno|dev  enable devices");
			break;
		case 'f':
			printf("devno|dev           find devices");
			break;
		case 'h':
			printf("                    this message");
			break;
		case 'l':
			printf("                    list configuration");
			break;
		case 'q':
			printf("                    leave UKC");
			break;
		case 's':
			printf("[attr [val]]        "
			   "show attributes (or devices with an attribute)");
			break;
		case 't':
			printf("[mins [dst]]        set timezone/dst");
			break;
		case 'v':
			printf("                    toggle verbose booting");
			break;
		default:
			printf("                    don't know");
			break;
		}
		printf("\n");
		j += 2;
	}
}

void
userconf_list(void)
{
	int i = 0;

	userconf_cnt = 0;

	while (i <= (userconf_totdev+pdevnames_size)) {
		if (userconf_more())
			break;
		userconf_pdev(i++);
	}

	userconf_cnt = -1;
}

void
userconf_show(void)
{
	int i = 0;

	userconf_cnt = 0;

	while (i <= userconf_maxlocnames) {
		if (userconf_more())
			break;
		printf("%s\n", locnames[i++]);
	}

	userconf_cnt = -1;
}

void
userconf_common_attr_val(short attr, long *val, char routine)
{
	struct cfdata *cd;
	long  *l;
	int   ln;
	int i = 0, quit = 0;

	userconf_cnt = 0;

	while (i <= userconf_maxdev) {
		cd = &cfdata[i];
		l = cd->cf_loc;
		ln = cd->cf_locnames;
		while (locnamp[ln] != -1) {
			if (locnamp[ln] == attr) {
				if (val == NULL) {
					quit = userconf_more();
					userconf_pdev(i);
				} else {
					if (*val == *l) {
						quit = userconf_more();
						switch (routine) {
						case UC_ENABLE:
							userconf_enable(i);
							break;
						case UC_DISABLE:
							userconf_disable(i);
							break;
						case UC_SHOW:
							userconf_pdev(i);
							break;
						default:
							printf("Unknown routine /%c/\n",
							    routine);
							break;
						}
					}
				}
			}
			if (quit)
				break;
			ln++;
			l++;
		}
		if (quit)
			break;
		i++;
	}

	userconf_cnt = -1;
}

void
userconf_show_attr(char *cmd)
{
	char *c;
	short attr = -1, i = 0, l = 0;
	long a;

	c = cmd;
	while (*c != ' ' && *c != '\t' && *c != '\n' && *c != '\0') {
		c++;
		l++;
	}
	while (*c == ' ' || *c == '\t' || *c == '\n') {
		c++;
	}
	while (i <= userconf_maxlocnames) {
		if (strlen(locnames[i]) == l) {
			if (strncasecmp(cmd, locnames[i], l) == 0) {
				attr = i;
			}
		}
		i++;
	}

	if (attr == -1) {
		printf("Unknown attribute\n");
		return;
	}

	if (*c == '\0') {
		userconf_common_attr_val(attr, NULL, UC_SHOW);
	} else {
		if (userconf_number(c, &a, INT_MAX) == 0) {
			userconf_common_attr_val(attr, &a, UC_SHOW);
		} else {
			printf("Unknown argument\n");
		}
	}
}

void
userconf_common_dev(char *dev, int len, short unit, short state, char routine)
{
	int i = 0;

	switch (routine) {
	case UC_CHANGE:
		break;
	default:
		userconf_cnt = 0;
		break;
	}

	while (cfdata[i].cf_attach != 0) {
		if (strlen(cfdata[i].cf_driver->cd_name) == len) {

			/*
			 * Ok, if device name is correct
			 *  If state == FSTATE_FOUND, look for "dev"
			 *  If state == FSTATE_STAR, look for "dev*"
			 *  If state == FSTATE_NOTFOUND, look for "dev0"
			 */
			if (strncasecmp(dev, cfdata[i].cf_driver->cd_name,
					len) == 0 &&
			    (state == FSTATE_FOUND ||
			     (state == FSTATE_STAR &&
			      (cfdata[i].cf_fstate == FSTATE_STAR ||
			       cfdata[i].cf_fstate == FSTATE_DSTAR)) ||
			     (state == FSTATE_NOTFOUND &&
			      cfdata[i].cf_unit == unit &&
			      (cfdata[i].cf_fstate == FSTATE_NOTFOUND ||
			       cfdata[i].cf_fstate == FSTATE_DNOTFOUND)))) {
				if (userconf_more())
					break;
				switch (routine) {
				case UC_CHANGE:
					userconf_change(i);
					break;
				case UC_ENABLE:
					userconf_enable(i);
					break;
				case UC_DISABLE:
					userconf_disable(i);
					break;
				case UC_FIND:
					userconf_pdev(i);
					break;
				default:
					printf("Unknown routine /%c/\n",
					    routine);
					break;
				}
			}
		}
		i++;
	}

	for (i = 0; i < pdevnames_size; i++) {
		if (strncasecmp(dev, pdevnames[i], len) == 0 &&
		    state == FSTATE_FOUND) {
			switch(routine) {
			case UC_CHANGE:
				userconf_change(userconf_totdev+1+i);
				break;
			case UC_ENABLE:
				userconf_enable(userconf_totdev+1+i);
				break;
			case UC_DISABLE:
				userconf_disable(userconf_totdev+1+i);
				break;
			case UC_FIND:
				userconf_pdev(userconf_totdev+1+i);
				break;
			default:
				printf("Unknown pseudo routine /%c/\n",routine);
				break;
			}
		}
	}

	switch (routine) {
	case UC_CHANGE:
		break;
	default:
		userconf_cnt = -1;
		break;
	}
}

void
userconf_common_attr(char *cmd, int attr, char routine)
{
	char *c;
	short l = 0;
	long a;

	c = cmd;
	while (*c != ' ' && *c != '\t' && *c != '\n' && *c != '\0') {
		c++;
		l++;
	}
	while (*c == ' ' || *c == '\t' || *c == '\n')
		c++;

	if (*c == '\0') {
		printf("Value missing for attribute\n");
		return;
	}

	if (userconf_number(c, &a, INT_MAX) == 0) {
		userconf_common_attr_val(attr, &a, routine);
	} else {
		printf("Unknown argument\n");
	}
}

void
userconf_add_read(char *prompt, char field, char *dev, int len, long *val)
{
	int ok = 0;
	long a;
	char *c;
	int i;

	*val = -1;

	while (!ok) {
		printf("%s ? ", prompt);

		i = getsn(userconf_argbuf, sizeof(userconf_argbuf));

		c = userconf_argbuf;
		while (*c == ' ' || *c == '\t' || *c == '\n')
			c++;

		if (*c != '\0') {
			if (userconf_number(c, &a, INT_MAX) == 0) {
				if (a > userconf_maxdev) {
					printf("Unknown devno (max is %d)\n",
					    userconf_maxdev);
				} else if (strncasecmp(dev,
				    cfdata[a].cf_driver->cd_name, len) != 0 &&
				    field == 'a') {
					printf("Not same device type\n");
				} else {
					*val = a;
					ok = 1;
				}
			} else if (*c == '?') {
				userconf_common_dev(dev, len, 0,
				    FSTATE_FOUND, UC_FIND);
			} else if (*c == 'q' || *c == 'Q') {
				ok = 1;
			} else {
				printf("Unknown argument\n");
			}
		} else {
			ok = 1;
		}
	}
}

void
userconf_add(char *dev, int len, short unit, short state)
{
	int found = 0;
	struct cfdata new;
	int max_unit, star_unit;
	long i = 0, val, orig;

	memset(&new, 0, sizeof(struct cfdata));

	if (userconf_maxdev == userconf_totdev) {
		printf("No more space for new devices.\n");
		return;
	}

	if (state == FSTATE_FOUND) {
		printf("Device not complete number or * is missing\n");
		return;
	}

	for (i = 0; cfdata[i].cf_driver; i++)
		if (strlen(cfdata[i].cf_driver->cd_name) == len &&
		    strncasecmp(dev, cfdata[i].cf_driver->cd_name, len) == 0)
			found = 1;

	if (!found) {
		printf("No device of this type exists.\n");
		return;
	}

	userconf_add_read("Clone Device (DevNo, 'q' or '?')",
	    'a', dev, len, &val);

	if (val != -1) {
		orig = val;
		new = cfdata[val];
		new.cf_unit = unit;
		new.cf_fstate = state;
		userconf_add_read("Insert before Device (DevNo, 'q' or '?')",
		    'i', dev, len, &val);
	}

	if (val != -1) {
		/* XXX add cmd 'a' <orig> <val> eoc */
		userconf_hist_cmd('a');
		userconf_hist_int(orig);
		userconf_hist_int(unit);
		userconf_hist_int(state);
		userconf_hist_int(val);
		userconf_hist_eoc();

		/* Insert the new record */
		for (i = userconf_maxdev; val <= i; i--)
			cfdata[i+1] = cfdata[i];
		cfdata[val] = new;

		/* Fix indexs in pv */
		for (i = 0; i < pv_size; i++) {
			if (pv[i] != -1 && pv[i] >= val)
				pv[i]++;
		}

		/* Fix indexs in cfroots */
		for (i = 0; i < cfroots_size; i++) {
			if (cfroots[i] != -1 && cfroots[i] >= val)
				cfroots[i]++;
		}

		userconf_maxdev++;

		max_unit = -1;

		/* Find max unit number of the device type */

		i = 0;
		while (cfdata[i].cf_attach != 0) {
			if (strlen(cfdata[i].cf_driver->cd_name) == len &&
			    strncasecmp(dev, cfdata[i].cf_driver->cd_name,
			    len) == 0) {
				switch (cfdata[i].cf_fstate) {
				case FSTATE_NOTFOUND:
				case FSTATE_DNOTFOUND:
					if (cfdata[i].cf_unit > max_unit)
						max_unit = cfdata[i].cf_unit;
					break;
				default:
					break;
				}
			}
			i++;
		}

		/*
		 * For all * entries set unit number to max+1, and update
		 * cf_starunit1 if necessary.
		 */
		max_unit++;
		star_unit = -1;

		i = 0;
		while (cfdata[i].cf_attach != 0) {
			if (strlen(cfdata[i].cf_driver->cd_name) == len &&
			    strncasecmp(dev, cfdata[i].cf_driver->cd_name,
			    len) == 0) {
				switch (cfdata[i].cf_fstate) {
				case FSTATE_NOTFOUND:
				case FSTATE_DNOTFOUND:
					if (cfdata[i].cf_unit > star_unit)
						star_unit = cfdata[i].cf_unit;
					break;
				default:
					break;
				}
			}
			i++;
		}
		star_unit++;

		i = 0;
		while (cfdata[i].cf_attach != 0) {
			if (strlen(cfdata[i].cf_driver->cd_name) == len &&
			    strncasecmp(dev, cfdata[i].cf_driver->cd_name,
			    len) == 0) {
				switch (cfdata[i].cf_fstate) {
				case FSTATE_STAR:
				case FSTATE_DSTAR:
					cfdata[i].cf_unit = max_unit;
					if (cfdata[i].cf_starunit1 < star_unit)
						cfdata[i].cf_starunit1 =
						    star_unit;
					break;
				default:
					break;
				}
			}
			i++;
		}
		userconf_pdev(val);
	}

	/* cf_attach, cf_driver, cf_unit, cf_fstate, cf_loc, cf_flags,
	   cf_parents, cf_locnames, and cf_locnames */
}

int
userconf_parse(char *cmd)
{
	char *c, *v;
	int i = 0, j = 0, k;
	long a;
	short unit, state;

	c = cmd;
	while (*c == ' ' || *c == '\t')
		c++;
	v = c;
	while (*c != ' ' && *c != '\t' && *c != '\n' && *c != '\0') {
		c++;
		i++;
	}

	k = -1;
	while (*userconf_cmds[j] != '\0') {
		if (strlen(userconf_cmds[j]) == i) {
			if (strncasecmp(v, userconf_cmds[j], i) == 0)
				k = j;
		}
		j += 2;
	}

	while (*c == ' ' || *c == '\t' || *c == '\n')
		c++;

	if (k == -1) {
		if (*v != '\n')
			printf("Unknown command, try help\n");
	} else {
		switch (*userconf_cmds[k+1]) {
		case 'L':
			if (*c == '\0')
				printf("Argument expected\n");
			else if (userconf_number(c, &a, INT_MAX) == 0)
				userconf_lines = a;
			else
				printf("Unknown argument\n");
			break;
		case 'a':
			if (*c == '\0')
				printf("Dev expected\n");
			else if (userconf_device(c, &a, &unit, &state) == 0)
				userconf_add(c, a, unit, state);
			else
				printf("Unknown argument\n");
			break;
		case 'b':
			if (*c == '\0')
				printf("8|10|16 expected\n");
			else if (userconf_number(c, &a, INT_MAX) == 0) {
				if (a == 8 || a == 10 || a == 16) {
					userconf_base = a;
				} else {
					printf("8|10|16 expected\n");
				}
			} else
				printf("Unknown argument\n");
			break;
		case 'c':
			if (*c == '\0')
				printf("DevNo or Dev expected\n");
			else if (userconf_number(c, &a, INT_MAX) == 0)
				userconf_change(a);
			else if (userconf_device(c, &a, &unit, &state) == 0)
				userconf_common_dev(c, a, unit, state, UC_CHANGE);
			else
				printf("Unknown argument\n");
			break;
#if defined(DDB)
		case 'D':
			db_enter();
			break;
#endif
		case 'd':
			if (*c == '\0')
				printf("Attr, DevNo or Dev expected\n");
			else if (userconf_attr(c, &a) == 0)
				userconf_common_attr(c, a, UC_DISABLE);
			else if (userconf_number(c, &a, INT_MAX) == 0)
				userconf_disable(a);
			else if (userconf_device(c, &a, &unit, &state) == 0)
				userconf_common_dev(c, a, unit, state, UC_DISABLE);
			else
				printf("Unknown argument\n");
			break;
		case 'e':
			if (*c == '\0')
				printf("Attr, DevNo or Dev expected\n");
			else if (userconf_attr(c, &a) == 0)
				userconf_common_attr(c, a, UC_ENABLE);
			else if (userconf_number(c, &a, INT_MAX) == 0)
				userconf_enable(a);
			else if (userconf_device(c, &a, &unit, &state) == 0)
				userconf_common_dev(c, a, unit, state, UC_ENABLE);
			else
				printf("Unknown argument\n");
			break;
		case 'f':
			if (*c == '\0')
				printf("DevNo or Dev expected\n");
			else if (userconf_number(c, &a, INT_MAX) == 0)
				userconf_pdev(a);
			else if (userconf_device(c, &a, &unit, &state) == 0)
				userconf_common_dev(c, a, unit, state, UC_FIND);
			else
				printf("Unknown argument\n");
			break;
		case 'h':
			userconf_help();
			break;
		case 'l':
			if (*c == '\0')
				userconf_list();
			else
				printf("Unknown argument\n");
			break;
		case 'q':
			/* XXX add cmd 'q' eoc */
			userconf_hist_cmd('q');
			userconf_hist_eoc();
			return(-1);
			break;
		case 's':
			if (*c == '\0')
				userconf_show();
			else
				userconf_show_attr(c);
			break;
		case 't':
			if (*c == '\0' ||
			    userconf_number(c, &a, INT_MAX) == 0) {
				if (*c != '\0') {
					tz.tz_minuteswest = a;
					while (*c != '\n' && *c != '\t' &&
					    *c != ' ' && *c != '\0')
						c++;
					while (*c == '\t' || *c == ' ')
						c++;
					if (*c != '\0' && userconf_number(c,
					    &a, INT_MAX) == 0)
						tz.tz_dsttime = a;
					userconf_hist_cmd('t');
					userconf_hist_int(tz.tz_minuteswest);
					userconf_hist_int(tz.tz_dsttime);
					userconf_hist_eoc();
				}
				printf("timezone = %d, dst = %d\n",
				    tz.tz_minuteswest, tz.tz_dsttime);
			} else
				printf("Unknown argument\n");
			break;
		case 'v':
			autoconf_verbose = !autoconf_verbose;
			printf("autoconf verbose %sabled\n",
			    autoconf_verbose ? "en" : "dis");
			break;
		default:
			printf("Unknown command\n");
			break;
		}
	}
	return(0);
}

void
user_config(void)
{
	userconf_init();
	printf("User Kernel Config\n");

	cnpollc(1);
	while (1) {
		printf("UKC> ");
		if (getsn(userconf_cmdbuf, sizeof(userconf_cmdbuf)) > 0 &&
		    userconf_parse(userconf_cmdbuf))
			break;
	}
	cnpollc(0);

	printf("Continuing...\n");
}
@


1.44
log
@Change device locators type from int to long, for the sake of 64-bit ports
without proper device trees.

Be sure to build and install config(8) and rerun it before attempting to build
a kernel.

ok kettenis@@ deraadt@@ jasper@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.43 2014/11/03 03:08:00 deraadt Exp $	*/
d1259 1
a1259 1
			Debugger();
@


1.43
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.42 2014/07/23 20:49:53 mpi Exp $	*/
d64 1
a64 1
void userconf_modify(char *, int *);
d66 1
a66 1
void userconf_hist_int(int);
d68 1
a68 1
void userconf_pnum(int);
d71 3
a73 4
int userconf_number(char *, int *);
int userconf_device(char *, int *, short *, short *);
int userconf_attr(char *, int *);
void userconf_modify(char *, int *);
d80 1
a80 1
void userconf_common_attr_val(short, int *, char);
d84 1
a84 1
void userconf_add_read(char *, char, char *, int, int *);
d175 1
a175 1
userconf_hist_int(int val)
d177 1
a177 1
	snprintf(userconf_histbuf, sizeof userconf_histbuf, " %d",val);
d197 1
a197 1
userconf_pnum(int val)
d200 1
a200 1
		printf("%d",val);
d206 1
a206 1
		printf("0%o",val);
d209 1
a209 1
		printf("%d",val);
d213 1
a213 1
		printf("0x%x",val);
d248 1
a248 1
	int   *l;
d311 1
a311 1
userconf_number(char *c, int *val)
d313 1
a313 1
	u_int num = 0;
d347 1
a347 1
	if (neg && num > INT_MAX)	/* overflow */
d354 1
a354 1
userconf_device(char *cmd, int *len, short *unit, short *state)
d389 1
a389 1
userconf_attr(char *cmd, int *val)
d418 1
a418 1
userconf_modify(char *item, int *val)
d421 1
a421 1
	int a;
d436 1
a436 1
			if (userconf_number(c, &a) == 0) {
d453 1
a453 1
	int   *l;
d466 2
a467 1
			int share = 0, i, *lk, lklen;
d488 1
a488 1
				lk = l = mallocarray(i, sizeof(int),
d494 1
a494 1
				lklen = i * sizeof(int);
d499 2
a500 1
				userconf_modify(locnames[locnamp[ln]], l);
d508 4
a511 2
			userconf_modify("flags", &cd->cf_flags);
			userconf_hist_int(cd->cf_flags);
d547 4
a550 3
			userconf_modify("count",
			    &pdevinit[devno-userconf_totdev-1].pdev_count);
			userconf_hist_int(pdevinit[devno-userconf_totdev-1].pdev_count);
d787 1
a787 1
userconf_common_attr_val(short attr, int *val, char routine)
d790 1
a790 1
	int   *l;
d844 1
a844 1
	int a;
d871 1
a871 1
		if (userconf_number(c, &a) == 0) {
d973 1
a973 1
	int a;
d988 1
a988 1
	if (userconf_number(c, &a) == 0) {
d996 1
a996 1
userconf_add_read(char *prompt, char field, char *dev, int len, int *val)
d999 1
a999 1
	int a;
d1015 1
a1015 1
			if (userconf_number(c, &a) == 0) {
d1044 1
a1044 1
	int i = 0, found = 0;
d1046 2
a1047 1
	int  val, max_unit, star_unit, orig;
d1189 2
a1190 1
	int i = 0, j = 0, k, a;
d1222 1
a1222 1
			else if (userconf_number(c, &a) == 0)
d1238 1
a1238 1
			else if (userconf_number(c, &a) == 0) {
d1250 1
a1250 1
			else if (userconf_number(c, &a) == 0)
d1267 1
a1267 1
			else if (userconf_number(c, &a) == 0)
d1279 1
a1279 1
			else if (userconf_number(c, &a) == 0)
d1289 1
a1289 1
			else if (userconf_number(c, &a) == 0)
d1318 2
a1319 1
			if (*c == '\0' || userconf_number(c, &a) == 0) {
d1327 2
a1328 2
					if (*c != '\0' &&
					    userconf_number(c, &a) == 0)
@


1.42
log
@Set the console input in polling mode before entering ukc.

ok miod@@, deraadt@@, shadchin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.41 2014/07/13 15:29:04 tedu Exp $	*/
d467 1
a467 1
			int share = 0, i, *lk;
d494 2
a495 1
				bcopy(cd->cf_loc, l, sizeof(int) * i);
d511 1
a511 1
				if (memcmp(cd->cf_loc, lk, sizeof(int) * i))
d514 1
a514 1
					free(lk, M_TEMP, 0);
@


1.41
log
@use mallocarray where arguments are multipled. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.40 2014/07/12 18:43:32 tedu Exp $	*/
d1351 1
d1358 2
@


1.40
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.39 2014/01/21 01:48:44 tedu Exp $	*/
d488 1
a488 1
				lk = l = (int *)malloc(sizeof(int) * i,
@


1.39
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.38 2013/12/12 20:56:01 guenther Exp $	*/
d513 1
a513 1
					free(lk, M_TEMP);
@


1.38
log
@printf(variable) --> printf("%s", variable)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.37 2011/06/01 04:35:22 matthew Exp $	*/
d510 1
a510 1
				if (bcmp(cd->cf_loc, lk, sizeof(int) * i))
d1043 1
a1043 1
	bzero(&new, sizeof(struct cfdata));
@


1.37
log
@Kill the nearly-15-years-dead cf_ivstubs field from struct cfdata.

ok miod@@, deraadt@@

N.B.: If you're following -current, you MUST recompile config(8) and
re-config your kernel or else ioconf.c will fail to compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.36 2009/06/02 12:46:33 deraadt Exp $	*/
d688 1
a688 1
		printf(userconf_cmds[j]);
@


1.36
log
@truncated format strings; found by Parfait and gcc
ok maja oga guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.35 2008/03/24 21:35:03 maja Exp $	*/
d1176 1
a1176 1
	   cf_parents, cf_locnames, cf_locnames and cf_ivstubs */
@


1.35
log
@Make it possible to disable/enable pseudo devices in UKC, config file and
at config -e. -moj  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.34 2005/12/09 09:09:52 jsg Exp $	*/
d604 1
a604 1
		printf("%3d %", devno, pdevnames[devno-userconf_totdev-1]);
d664 1
a664 1
		printf("%3d %", devno, pdevnames[devno-userconf_totdev-1]);
@


1.34
log
@ansi and deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.33 2003/06/02 21:14:47 maja Exp $	*/
d260 1
a260 1
		printf("%3d %s count %d (pseudo device)\n", devno,
d262 4
a265 1
		    pdevinit[devno-userconf_totdev-1].pdev_count);
d604 11
a614 2
		printf("%3d %s can't disable pseudo device\n", devno,
		    pdevnames[devno-userconf_totdev-1]);
d664 11
a674 2
		printf("%3d %s can't enable pseudo device\n", devno,
		    pdevnames[devno-userconf_totdev-1]);
@


1.33
log
@remove clause 3 and 4. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.32 2003/05/03 21:14:59 deraadt Exp $	*/
d118 1
a118 1
userconf_init()
d146 1
a146 1
userconf_more()
d166 1
a166 2
userconf_hist_cmd(cmd)
	char cmd;
d176 1
a176 2
userconf_hist_int(val)
	int val;
d188 1
a188 1
userconf_hist_eoc()
d198 1
a198 2
userconf_pnum(val)
	int val;
d220 1
a220 2
userconf_pdevnam(dev)
	short dev;
d245 1
a245 2
userconf_pdev(devno)
	short devno;
d309 1
a309 3
userconf_number(c, val)
	char *c;
	int *val;
d352 1
a352 4
userconf_device(cmd, len, unit, state)
	char *cmd;
	int *len;
	short *unit, *state;
d387 1
a387 3
userconf_attr(cmd, val)
	char *cmd;
	int *val;
d416 1
a416 3
userconf_modify(item, val)
	char *item;
	int  *val;
d447 1
a447 2
userconf_change(devno)
	int devno;
d558 1
a558 2
userconf_disable(devno)
	int devno;
d610 1
a610 2
userconf_enable(devno)
	int devno;
d661 1
a661 1
userconf_help()
d729 1
a729 1
userconf_list()
d745 1
a745 1
userconf_show()
d761 1
a761 4
userconf_common_attr_val(attr, val, routine)
	short attr;
	int   *val;
	char  routine;
d814 1
a814 2
userconf_show_attr(cmd)
	char *cmd;
d854 1
a854 5
userconf_common_dev(dev, len, unit, state, routine)
	char *dev;
	int len;
	short unit, state;
	char routine;
d943 1
a943 4
userconf_common_attr(cmd, attr, routine)
	char *cmd;
	int attr;
	char routine;
d970 1
a970 6
userconf_add_read(prompt, field, dev, len, val)
	char *prompt;
	char field;
	char *dev;
	int len;
	int *val;
d1016 1
a1016 4
userconf_add(dev, len, unit, state)
	char *dev;
	int len;
	short unit, state;
d1159 1
a1159 2
userconf_parse(cmd)
	char *cmd;
d1325 1
a1325 1
user_config()
@


1.32
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.31 2002/07/29 23:18:57 art Exp $	*/
a14 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Mats O Jansson.
 * 4. The name of the author may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
@


1.31
log
@Try to gracefully handle out of memory conditions.
Not that it will help much, but what the hell.
noticed by: tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.30 2002/07/25 01:26:01 nordin Exp $	*/
d186 1
a186 1
	sprintf(userconf_histbuf," %d",val);
@


1.30
log
@Modify lvalue only once between sequence points. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.29 2002/05/02 12:59:58 miod Exp $	*/
d508 4
@


1.29
log
@In UKC, when adding a fixed unit device (foo0) by cloning a star device
(foo*), be sure to update all cf_starunit1 fields for related star devices,
so that they will not compete for the foo0 probe.

This fixes the new sparc bsd.scsi3 behaviour.

Tested by brad@@ and myself, ok maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.28 2002/03/14 03:16:09 millert Exp $	*/
d1111 1
a1111 1
				pv[i] = pv[i]++;
d1117 1
a1117 1
				cfroots[i] = cfroots[i]++;
@


1.28
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.27 2002/03/14 01:27:04 millert Exp $	*/
d1058 1
a1058 1
	int  val, max_unit, orig;
d1144 6
a1149 1
		/* For all * entries set unit number to max+1 */
d1151 18
a1168 1
		max_unit++;
d1179 3
d1192 1
a1192 1
	/* cf_attach, cf_driver, cf_unit, cf_state, cf_loc, cf_flags,
@


1.27
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.26 2001/06/13 07:14:39 miod Exp $	*/
d70 1
a70 1
void userconf_modify(char *, int*);
@


1.26
log
@Repair bad printf (-Wall cleanup)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.25 2001/02/13 14:43:57 deraadt Exp $	*/
d68 26
a93 26
void userconf_init __P((void));
int userconf_more __P((void));
void userconf_modify __P((char *, int*));
void userconf_hist_cmd __P((char));
void userconf_hist_int __P((int));
void userconf_hist_eoc __P((void));
void userconf_pnum __P((int));
void userconf_pdevnam __P((short));
void userconf_pdev __P((short));
int userconf_number __P((char *, int *));
int userconf_device __P((char *, int *, short *, short *));
int userconf_attr __P((char *, int *));
void userconf_modify __P((char *, int *));
void userconf_change __P((int));
void userconf_disable __P((int));
void userconf_enable __P((int));
void userconf_help __P((void));
void userconf_list __P((void));
void userconf_show __P((void));
void userconf_common_attr_val __P((short, int *, char));
void userconf_show_attr __P((char *));
void userconf_common_dev __P((char *, int, short, short, char));
void userconf_common_attr __P((char *, int, char));
void userconf_add_read __P((char *, char, char *, int, int *));
void userconf_add __P((char *, int, short, short));
int userconf_parse __P((char *));
@


1.26.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.26 2001/06/13 07:14:39 miod Exp $	*/
d68 26
a93 26
void userconf_init(void);
int userconf_more(void);
void userconf_modify(char *, int *);
void userconf_hist_cmd(char);
void userconf_hist_int(int);
void userconf_hist_eoc(void);
void userconf_pnum(int);
void userconf_pdevnam(short);
void userconf_pdev(short);
int userconf_number(char *, int *);
int userconf_device(char *, int *, short *, short *);
int userconf_attr(char *, int *);
void userconf_modify(char *, int *);
void userconf_change(int);
void userconf_disable(int);
void userconf_enable(int);
void userconf_help(void);
void userconf_list(void);
void userconf_show(void);
void userconf_common_attr_val(short, int *, char);
void userconf_show_attr(char *);
void userconf_common_dev(char *, int, short, short, char);
void userconf_common_attr(char *, int, char);
void userconf_add_read(char *, char, char *, int, int *);
void userconf_add(char *, int, short, short);
int userconf_parse(char *);
d1058 1
a1058 1
	int  val, max_unit, star_unit, orig;
d1144 2
a1145 4
		/*
		 * For all * entries set unit number to max+1, and update
		 * cf_starunit1 if necessary.
		 */
a1146 20
		star_unit = -1;

		i = 0;
		while (cfdata[i].cf_attach != 0) {
			if (strlen(cfdata[i].cf_driver->cd_name) == len &&
			    strncasecmp(dev, cfdata[i].cf_driver->cd_name,
			    len) == 0) {
				switch (cfdata[i].cf_fstate) {
				case FSTATE_NOTFOUND:
				case FSTATE_DNOTFOUND:
					if (cfdata[i].cf_unit > star_unit)
						star_unit = cfdata[i].cf_unit;
					break;
				default:
					break;
				}
			}
			i++;
		}
		star_unit++;
a1156 3
					if (cfdata[i].cf_starunit1 < star_unit)
						cfdata[i].cf_starunit1 =
						    star_unit;
d1167 1
a1167 1
	/* cf_attach, cf_driver, cf_unit, cf_fstate, cf_loc, cf_flags,
@


1.26.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.26.4.1 2002/06/11 03:29:40 art Exp $	*/
a507 4
				if (lk == NULL) {
					printf("out of memory.\n");
					return;
				}
d1111 1
a1111 1
				pv[i]++;
d1117 1
a1117 1
				cfroots[i]++;
@


1.26.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d186 1
a186 1
	snprintf(userconf_histbuf, sizeof userconf_histbuf, " %d",val);
@


1.25
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.24 2001/02/05 19:24:07 maja Exp $	*/
d729 1
a729 1
			printf("[attr [val]]        ",
@


1.24
log
@If kernel is compile with support for DDB add a ddb command to enter
ddb from boot -c. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.23 2001/02/04 21:42:10 maja Exp $	*/
d187 1
a187 1
	if ((userconf_histcur + strlen(userconf_histbuf)) < userconf_histsz) {
d189 2
a190 2
		      &userconf_history[userconf_histcur],
		      strlen(userconf_histbuf));
d211 14
a224 13
	} else {
		switch (userconf_base) {
		case 8:
			printf("0%o",val);
			break;
		case 10:
			printf("%d",val);
			break;
		case 16:
		default:
			printf("0x%x",val);
			break;
		}
d264 1
a264 1
	if ((devno > userconf_maxdev) && (devno <= userconf_totdev)) {
d269 2
a270 2
	if ((devno > userconf_totdev) &&
	    (devno <= (userconf_totdev+pdevnames_size))) {
d272 2
a273 2
		       pdevnames[devno-userconf_totdev-1],
		       pdevinit[devno-userconf_totdev-1].pdev_count);
a475 1

d486 1
a486 1
			
d490 1
a490 1
			
d512 2
a513 3
				userconf_modify(locnames[locnamp[ln]],
						l);
				
d516 1
a516 1
				
a533 2

			
d538 1
a538 1
	if ((devno > userconf_maxdev) && (devno <= userconf_totdev)) {
d543 2
a544 3
	if ((devno > userconf_totdev) &&
	    (devno <= (userconf_totdev+pdevnames_size))) {
			
a545 1
			
a552 1

d558 1
a558 1
					&pdevinit[devno-userconf_totdev-1].pdev_count);
d560 1
a560 1
			
d562 1
a562 1
				pdevnames[devno-userconf_totdev-1]);
d612 1
a612 1
	if ((devno > userconf_maxdev) && (devno <= userconf_totdev)) {
d617 4
a620 4
	if ((devno > userconf_totdev) &&
	    (devno <= (userconf_totdev+pdevnames_size))) {
		printf("%3d %s can't disable pseudo device\n", devno, 
			pdevnames[devno-userconf_totdev-1]);
d632 1
a632 1
	
a660 1

d664 1
a664 1
	if ((devno > userconf_maxdev) && (devno <= userconf_totdev)) {
d669 4
a672 4
	if ((devno > userconf_totdev) &&
	    (devno <= (userconf_totdev+pdevnames_size))) {
		printf("%3d %s can't enable pseudo device\n", devno, 
			pdevnames[devno-userconf_totdev-1]);
d729 1
a729 1
			printf("[attr [val]]        %s",
d938 2
a939 2
		if ((strncasecmp(dev, pdevnames[i], len) == 0) &&
		    (state == FSTATE_FOUND)) {
d984 1
a984 1
	while (*c == ' ' || *c == '\t' || *c == '\n') {
d986 1
a986 1
	}
d1020 2
a1021 1
		while (*c == ' ' || *c == '\t' || *c == '\n') c++;
d1030 1
a1030 1
					field == 'a') {
a1094 1
		
d1102 1
a1102 1
		
d1110 1
a1110 1
			if ((pv[i] != -1) && (pv[i] >= val))
d1116 1
a1116 1
			if ((cfroots[i] != -1) && (cfroots[i] >= val))
d1306 2
a1307 2
				        tz.tz_minuteswest = a;
					while (*c != '\n' && *c != '\t' && 
d1312 1
a1312 1
					if (*c != '\0' && 
d1322 1
a1322 1
			} else 
@


1.23
log
@Add support for pseudo devices. Based on the new code in config.

N.B. this change requires the kernel to be configured with a new
     config since it need new information from ioconf.c.

-moj ok @@deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.22 2000/08/08 21:42:40 deraadt Exp $	*/
d105 3
d712 5
d1250 5
@


1.22
log
@permit changing flags
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.21 2000/07/06 00:59:01 todd Exp $	*/
d4 1
a4 1
 * Copyright (c) 1996 Mats O Jansson <moj@@stacken.kth.se>
d50 3
d260 13
d533 35
a569 1
			
d571 1
a571 2
	} else {
		printf("Unknown devno (max is %d)\n", userconf_maxdev);
d573 2
d611 14
a624 2
	} else {
		printf("Unknown devno (max is %d)\n", userconf_maxdev);
d626 2
d664 14
a677 2
	} else {
		printf("Unknown devno (max is %d)\n", userconf_maxdev);
d679 2
d753 1
a753 1
	while (cfdata[i].cf_attach != 0) {
d934 23
@


1.21
log
@printf %s
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.20 2000/05/19 17:07:05 maja Exp $	*/
d296 1
a296 1
	printf("\n");
d502 2
@


1.20
log
@Add enable to history when enable command i used. Reported by itojun@@ and David Brownlee <abs@@mono.org>. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.19 2000/01/08 23:23:37 d Exp $	*/
a1230 2
	char prompt[] = "UKC> ";

d1235 1
a1235 1
		printf(prompt);
@


1.19
log
@Allow UKC to change tz with 'timezone' command.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.18 1999/10/04 20:04:31 deraadt Exp $	*/
d592 1
a592 1
			userconf_hist_cmd('d');
@


1.19.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.25 2001/02/13 14:43:57 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 1996-2001 Mats O Jansson <moj@@stacken.kth.se>
a49 3
extern char *pdevnames[];
extern int pdevnames_size;
extern struct pdevinit pdevinit[];
a101 3
#if defined(DDB)
	"ddb",		"D",
#endif
d181 1
a181 1
	if (userconf_histcur + strlen(userconf_histbuf) < userconf_histsz) {
d183 2
a184 2
		    &userconf_history[userconf_histcur],
		    strlen(userconf_histbuf));
d205 13
a217 14
		return;
	}

	switch (userconf_base) {
	case 8:
		printf("0%o",val);
		break;
	case 10:
		printf("%d",val);
		break;
	case 16:
	default:
		printf("0x%x",val);
		break;
a256 13
	if (devno > userconf_maxdev && devno <= userconf_totdev) {
		printf("%3d free slot (for add)\n", devno);
		return;
	}

	if (devno > userconf_totdev &&
	    devno <= userconf_totdev+pdevnames_size) {
		printf("%3d %s count %d (pseudo device)\n", devno,
		    pdevnames[devno-userconf_totdev-1],
		    pdevinit[devno-userconf_totdev-1].pdev_count);
		return;
	}

d296 1
a296 1
	printf(" flags 0x%x\n", cd->cf_flags);
d456 1
d467 1
a467 1

d471 1
a471 1

d493 3
a495 2
				userconf_modify(locnames[locnamp[ln]], l);

d498 1
a498 1

a501 2
			userconf_modify("flags", &cd->cf_flags);
			userconf_hist_int(cd->cf_flags);
a513 30
		}
		return;
	}

	if (devno > userconf_maxdev && devno <= userconf_totdev) {
		printf("%3d can't change free slot\n", devno);
		return;
	}

	if (devno > userconf_totdev &&
	    devno <= userconf_totdev+pdevnames_size) {
		userconf_pdev(devno);
		while (c != 'y' && c != 'Y' && c != 'n' && c != 'N') {
			printf("change (y/n) ?");
			c = cngetc();
			printf("\n");
		}

		if (c == 'y' || c == 'Y') {
			/* XXX add cmd 'c' <devno> */
			userconf_hist_cmd('c');
			userconf_hist_int(devno);

			userconf_modify("count",
			    &pdevinit[devno-userconf_totdev-1].pdev_count);
			userconf_hist_int(pdevinit[devno-userconf_totdev-1].pdev_count);

			printf("%3d %s changed\n", devno,
			    pdevnames[devno-userconf_totdev-1]);
			userconf_pdev(devno);
d517 1
d519 2
a520 1
		return;
a521 2

	printf("Unknown devno (max is %d)\n", userconf_totdev+pdevnames_size);
d558 2
a559 14

		return;
	}

	if (devno > userconf_maxdev && devno <= userconf_totdev) {
		printf("%3d can't disable free slot\n", devno);
		return;
	}

	if (devno > userconf_totdev &&
	    devno <= userconf_totdev+pdevnames_size) {
		printf("%3d %s can't disable pseudo device\n", devno,
		    pdevnames[devno-userconf_totdev-1]);
		return;
a560 2

	printf("Unknown devno (max is %d)\n", userconf_totdev+pdevnames_size);
d568 1
a568 1

d592 1
a592 1
			userconf_hist_cmd('e');
d597 2
a598 6
		return;
	}

	if (devno > userconf_maxdev && devno <= userconf_totdev) {
		printf("%3d can't enable free slot\n", devno);
		return;
a599 9

	if (devno > userconf_totdev &&
	    devno <= userconf_totdev+pdevnames_size) {
		printf("%3d %s can't enable pseudo device\n", devno,
		    pdevnames[devno-userconf_totdev-1]);
		return;
	}

	printf("Unknown devno (max is %d)\n", userconf_totdev+pdevnames_size);
a627 5
#if defined(DDB)
		case 'D':
			printf("                    enter ddb");
			break;
#endif
d647 1
a647 1
			printf("[attr [val]]        ",
d672 1
a672 1
	while (i <= (userconf_totdev+pdevnames_size)) {
a854 23
	for (i = 0; i < pdevnames_size; i++) {
		if (strncasecmp(dev, pdevnames[i], len) == 0 &&
		    state == FSTATE_FOUND) {
			switch(routine) {
			case UC_CHANGE:
				userconf_change(userconf_totdev+1+i);
				break;
			case UC_ENABLE:
				userconf_enable(userconf_totdev+1+i);
				break;
			case UC_DISABLE:
				userconf_disable(userconf_totdev+1+i);
				break;
			case UC_FIND:
				userconf_pdev(userconf_totdev+1+i);
				break;
			default:
				printf("Unknown pseudo routine /%c/\n",routine);
				break;
			}
		}
	}

d879 1
a879 1
	while (*c == ' ' || *c == '\t' || *c == '\n')
d881 1
a881 1

d915 1
a915 2
		while (*c == ' ' || *c == '\t' || *c == '\n')
			c++;
d924 1
a924 1
				    field == 'a') {
d989 1
d997 1
a997 1

d1005 1
a1005 1
			if (pv[i] != -1 && pv[i] >= val)
d1011 1
a1011 1
			if (cfroots[i] != -1 && cfroots[i] >= val)
a1137 5
#if defined(DDB)
		case 'D':
			Debugger();
			break;
#endif
d1196 2
a1197 2
					tz.tz_minuteswest = a;
					while (*c != '\n' && *c != '\t' &&
d1202 1
a1202 1
					if (*c != '\0' &&
d1212 1
a1212 1
			} else
d1231 2
d1237 1
a1237 1
		printf("UKC> ");
@


1.19.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.19.2.1 2001/05/14 22:32:43 niklas Exp $	*/
d729 1
a729 1
			printf("[attr [val]]        "
@


1.19.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 26
a93 26
void userconf_init(void);
int userconf_more(void);
void userconf_modify(char *, int *);
void userconf_hist_cmd(char);
void userconf_hist_int(int);
void userconf_hist_eoc(void);
void userconf_pnum(int);
void userconf_pdevnam(short);
void userconf_pdev(short);
int userconf_number(char *, int *);
int userconf_device(char *, int *, short *, short *);
int userconf_attr(char *, int *);
void userconf_modify(char *, int *);
void userconf_change(int);
void userconf_disable(int);
void userconf_enable(int);
void userconf_help(void);
void userconf_list(void);
void userconf_show(void);
void userconf_common_attr_val(short, int *, char);
void userconf_show_attr(char *);
void userconf_common_dev(char *, int, short, short, char);
void userconf_common_attr(char *, int, char);
void userconf_add_read(char *, char, char *, int, int *);
void userconf_add(char *, int, short, short);
int userconf_parse(char *);
@


1.19.2.4
log
@Sync the SMP branch with 3.3
@
text
@a507 4
				if (lk == NULL) {
					printf("out of memory.\n");
					return;
				}
d1058 1
a1058 1
	int  val, max_unit, star_unit, orig;
d1111 1
a1111 1
				pv[i]++;
d1117 1
a1117 1
				cfroots[i]++;
d1144 2
a1145 4
		/*
		 * For all * entries set unit number to max+1, and update
		 * cf_starunit1 if necessary.
		 */
a1146 20
		star_unit = -1;

		i = 0;
		while (cfdata[i].cf_attach != 0) {
			if (strlen(cfdata[i].cf_driver->cd_name) == len &&
			    strncasecmp(dev, cfdata[i].cf_driver->cd_name,
			    len) == 0) {
				switch (cfdata[i].cf_fstate) {
				case FSTATE_NOTFOUND:
				case FSTATE_DNOTFOUND:
					if (cfdata[i].cf_unit > star_unit)
						star_unit = cfdata[i].cf_unit;
					break;
				default:
					break;
				}
			}
			i++;
		}
		star_unit++;
a1156 3
					if (cfdata[i].cf_starunit1 < star_unit)
						cfdata[i].cf_starunit1 =
						    star_unit;
d1167 1
a1167 1
	/* cf_attach, cf_driver, cf_unit, cf_fstate, cf_loc, cf_flags,
@


1.19.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.19.2.4 2003/03/28 00:41:27 niklas Exp $	*/
d186 1
a186 1
	snprintf(userconf_histbuf, sizeof userconf_histbuf, " %d",val);
@


1.19.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.19.2.5 2003/05/13 19:21:28 ho Exp $	*/
d15 6
@


1.18
log
@save user configuration in some magic buffer, which config -e can read; maja
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.17 1999/08/17 11:02:40 art Exp $	*/
d39 1
d49 1
d111 1
d650 3
d1192 22
@


1.17
log
@initialize an incorrectly uninitialized variable
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.16 1999/04/28 18:01:22 deraadt Exp $	*/
d55 4
d61 1
d66 3
d163 34
d464 5
a468 1

d492 4
d511 4
d546 1
a546 1
		if (done)
d548 6
d585 1
a585 1
		if (done)
d587 6
d917 2
a918 1
				    cfdata[a].cf_driver->cd_name, len) != 0) {
d946 1
a946 1
	int  val, max_unit;
d956 1
a956 1
		printf("Device not complete number or * is missing/n");
d974 1
d983 9
a991 1

d1176 3
@


1.16
log
@add autoconfig_verbose toggling command to boot_config
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.15 1998/03/03 05:43:03 deraadt Exp $	*/
d138 1
a138 1
	char c;
@


1.15
log
@cleanup printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.14 1998/03/03 05:16:19 ryker Exp $	*/
d101 1
d541 1
a541 1
		k=strlen(userconf_cmds[j]);
d581 3
d1107 5
@


1.14
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.13 1998/01/04 10:39:04 deraadt Exp $	*/
d547 1
a547 2
			printf("[count]             %s",
			    "number of lines before more");
d556 1
a556 1
			printf("devno|dev           %s devices","change");
d559 1
a559 1
			printf("attr val|devno|dev  %s devices","disable");
d562 1
a562 1
			printf("attr val|devno|dev  %s devices","enable");
d565 1
a565 1
			printf("devno|dev           %s devices","find");
d568 1
a568 1
			printf("                    %s","this message");
d571 1
a571 1
			printf("                    %s","list configuration");
d574 1
a574 1
			printf("                    %s","leave UKC");
d581 1
a581 1
			printf("                    %s","don't know");
@


1.13
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.12 1998/01/04 01:21:21 maja Exp $	*/
d547 1
a547 1
			printf("[count]             ",
@


1.12
log
@Added support for enable/disable attr value. eg disable irq 10. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.11 1996/11/21 12:47:16 mickey Exp $	*/
d90 1
a90 1
        "base",         "b",
d110 1
a110 1
	int   ln;		
d112 1
a112 2
	while(cfdata[i].cf_attach != 0) {
		
d117 1
a117 1
		ln=cd->cf_locnames;
d119 1
a119 1
			if (locnamp[ln] > userconf_maxlocnames) {
a120 1
			};
d126 1
a126 1
	while(cfdata[i].cf_attach == 0) {
a129 1
	
d147 2
a148 1
		if (c == 'q' || c == 'Q') quit = 1;
d150 1
a150 1
	return(quit);
d160 1
a160 1
		switch(userconf_base) {
d182 2
a183 2
	printf(cd->cf_driver->cd_name);
	switch(cd->cf_fstate) {
d186 1
a186 1
		printf("%d",cd->cf_unit);
d189 1
a189 1
	  	printf("*FOUND*");
d208 1
a208 1
	int   ln;		
d212 1
a212 1
		printf("Unknown devno (max is %d)\n",userconf_maxdev);
d218 1
a218 1
	printf("%3d ",devno);
d221 4
a224 3
	c=' ';
	p=cd->cf_parents;
	if (*p == -1) printf(" root");
d226 1
a226 1
		printf("%c",c);
d228 3
a230 3
		c='|';
	};
	switch(cd->cf_fstate) {
d232 2
a233 2
        case FSTATE_FOUND:
        case FSTATE_STAR:
d236 1
a236 1
        case FSTATE_DSTAR:
d239 1
a239 1
        default:
d243 2
a244 2
	l=cd->cf_loc;
	ln=cd->cf_locnames;
d246 1
a246 1
		printf(" %s ",locnames[locnamp[ln]]);
a250 1

d274 1
a274 1
	while (*c != '\n' && *c != '\t' && *c != ' ' && *c != '\000') {
d291 2
a292 2
	
	if (neg && num > INT_MAX)       /* overflow */
a293 1
	
d295 1
a295 2

	return(0);
d309 4
a312 1
	while(*c >= 'a' && *c <= 'z') { l++; c++; };
d317 1
a317 1
		while(*c >= '0' && *c <= '9') {
d319 1
a319 1
			u=u*10 + *c - '0';
d321 1
a321 1
		};
d323 2
a324 1
	while(*c == ' ' || *c == '\t' || *c == '\n') c++;
d326 1
a326 1
	if (*c == '\000') {
d343 1
a343 1
	
d345 3
a347 2
	while (*c != ' ' && *c != '\t' && *c != '\n' && *c != '\000') {
		c++; l++;
d349 2
a350 2
	
	while(i <= userconf_maxlocnames) {
d352 1
a352 1
			if (strncasecmp(cmd,locnames[i],l) == 0) {
a353 1
			}
d377 2
a378 2
	while(!ok) {
		printf("%s [",item);
d382 1
a382 1
		i = getsn(userconf_argbuf,sizeof(userconf_argbuf));
d387 2
a388 2
		if (*c != '\000') {
			if (userconf_number(c,&a) == 0) {
d405 1
a405 1
	char c = '\000';
d407 1
a407 1
	int   ln;		
d413 1
a413 1
		while(c != 'y' && c != 'Y' && c != 'n' && c != 'N') {
d421 1
a421 1
			
d423 2
a424 2
			l=cd->cf_loc;
			ln=cd->cf_locnames;
d441 1
a441 1
 
d448 1
a448 1
			
d456 1
a456 1
			printf("%3d ",devno);
a459 1
			
a460 1

d462 1
a462 1
		printf("Unknown devno (max is %d)\n",userconf_maxdev);
a463 1

d471 1
a471 1
	
d473 1
a473 2

		switch(cfdata[devno].cf_fstate) { 
d489 1
a489 1
		printf("%3d ",devno);
d491 2
a492 1
		if (done) printf(" already");
a493 1
		
d495 1
a495 1
		printf("Unknown devno (max is %d)\n",userconf_maxdev);
a496 1

d506 1
a506 2

		switch(cfdata[devno].cf_fstate) { 
d522 1
a522 1
		printf("%3d ",devno);
d524 2
a525 1
		if (done) printf(" already");
a526 1
		
d528 1
a528 1
		printf("Unknown devno (max is %d)\n",userconf_maxdev);
a529 1

d535 1
a535 1
	int j = 0,k;
d538 1
a538 1
	while(*userconf_cmds[j] != '\000') {
d541 5
a545 2
		while (k < 10) { printf(" "); k++; }
		switch(*userconf_cmds[j+1]) {
d548 1
a548 1
			       "number of lines before more");
d586 1
a586 1
		j++; j++;
a587 1
	
d597 3
a599 2
	while(cfdata[i].cf_attach != 0) {
		if (userconf_more()) break;
d601 1
a601 1
	};
d613 4
a616 3
	while(i <= userconf_maxlocnames) {
		if (userconf_more()) break;
		printf("%s\n",locnames[i++]);
d630 1
a630 1
	int   ln;		
d632 1
a632 1
	
d635 1
a635 1
	while(i <= userconf_maxdev) {
d637 2
a638 2
		l=cd->cf_loc;
		ln=cd->cf_locnames;
d647 1
a647 1
						switch(routine) {
d659 1
a659 1
							       routine);
d665 2
a666 1
			if (quit) break;
d670 2
a671 1
		if (quit) break;
d685 1
a685 1
	
d687 3
a689 2
	while (*c != ' ' && *c != '\t' && *c != '\n' && *c != '\000') {
		c++; l++;
d694 1
a694 2
	
	while(i <= userconf_maxlocnames) {
d696 1
a696 1
			if (strncasecmp(cmd,locnames[i],l) == 0) {
d708 2
a709 2
	if (*c == '\000') {
		userconf_common_attr_val(attr,NULL,UC_SHOW);
d711 2
a712 2
		if (userconf_number(c,&a) == 0) {
			userconf_common_attr_val(attr,&a,UC_SHOW);
d728 1
a728 1
	switch(routine) {
d736 1
a736 2
	while(cfdata[i].cf_attach != 0) {

d740 1
a740 1
			 * Ok, if device name is correct 
d745 1
a745 1
			if (strncasecmp(dev,cfdata[i].cf_driver->cd_name,
d755 3
a757 2
			  	if (userconf_more()) break;
				switch(routine) {
d772 1
a772 1
					       routine);
d778 1
d780 1
a780 3
	};

	switch(routine) {
a786 1

d798 1
a798 1
	
d800 3
a802 2
	while (*c != ' ' && *c != '\t' && *c != '\n' && *c != '\000') {
		c++; l++;
d807 1
a807 2
	
	if (*c == '\000') {
d812 2
a813 2
	if (userconf_number(c,&a) == 0) {
		userconf_common_attr_val(attr,&a,routine);
d820 1
a820 1
userconf_add_read(prompt,field,dev,len,val)
d834 2
a835 2
	while(!ok) {
		printf("%s ? ",prompt);
d837 1
a837 1
		i = getsn(userconf_argbuf,sizeof(userconf_argbuf));
d842 3
a844 3
		if (*c != '\000') {
			if (userconf_number(c,&a) == 0) {
				if (a >  userconf_maxdev) {
d846 1
a846 1
					       userconf_maxdev);
d848 1
a848 2
					   cfdata[a].cf_driver->cd_name,
					   len) != 0) {
d855 2
a856 2
				userconf_common_dev(dev,len,0,
						    FSTATE_FOUND,UC_FIND);
d869 1
a869 1
userconf_add(dev,len,unit,state)
d879 1
a879 1
	
d892 1
a892 1
		    strncasecmp(dev,cfdata[i].cf_driver->cd_name,len) == 0)
d899 1
a899 1
	
d901 2
a902 2
			  'a',dev,len,&val);
	
a903 1

a906 1

d908 1
a908 2
				  'i',dev,len,&val);

d914 1
a914 2

		for (i = userconf_maxdev; val <= i; i--) {
a915 1
		}
a918 1
		
d920 1
a920 1
			if ((pv[i] != -1) && (pv[i] >= val)) {
a921 1
			}
a924 1
		
d926 1
a926 1
			if ((cfroots[i] != -1) && (cfroots[i] >= val)) {
a927 1
			}
d935 1
a935 1
		
d937 1
a937 1
		while(cfdata[i].cf_attach != 0) {
d939 2
a940 3
			    strncasecmp(dev,
					cfdata[i].cf_driver->cd_name,
					len) == 0) {
d957 1
a957 1
		
d959 1
a959 1
		while(cfdata[i].cf_attach != 0) {
d961 2
a962 3
			    strncasecmp(dev,
					cfdata[i].cf_driver->cd_name,
					len) == 0) {
a973 1
		
a974 1

a978 1

d990 2
a991 1
	while (*c == ' ' || *c == '\t') c++;
d993 3
a995 2
	while (*c != ' ' && *c != '\t' && *c != '\n' && *c != '\000') {
	  c++; i++;
d999 1
a999 1
	while(*userconf_cmds[j] != '\000') {
d1001 1
a1001 1
			if (strncasecmp(v,userconf_cmds[j],i) == 0) {
a1002 1
			}
d1004 1
a1004 1
		j++; j++;
d1007 1
a1007 1
	while (*c == ' ' || *c == '\t' || *c == '\n') {
d1009 1
a1009 2
	}
	
d1011 1
a1011 1
		if (*v != '\n') {
a1012 1
		};
d1014 1
a1014 1
		switch(*userconf_cmds[k+1]) {
d1016 1
a1016 1
			if (*c == '\000') {
d1018 1
a1018 1
			} else if (userconf_number(c,&a) == 0) {
d1020 1
a1020 1
			} else {
a1021 1
			}
d1024 1
a1024 1
			if (*c == '\000') {
d1026 3
a1028 3
			} else if (userconf_device(c,&a,&unit,&state) == 0) {
				userconf_add(c,a,unit,state);
			} else {
a1029 1
			}
d1032 1
a1032 1
			if (*c == '\000') {
d1034 1
a1034 1
			} else if (userconf_number(c,&a) == 0) {
d1040 1
a1040 1
			} else {
a1041 1
			}
d1044 1
a1044 1
			if (*c == '\000') {
d1046 1
a1046 1
			} else if (userconf_number(c,&a) == 0) {
d1048 3
a1050 3
			} else if (userconf_device(c,&a,&unit,&state) == 0) {
				userconf_common_dev(c,a,unit,state,UC_CHANGE);
			} else {
a1051 1
			}
d1054 1
a1054 1
			if (*c == '\000') {
d1056 3
a1058 3
			} else if (userconf_attr(c,&a) == 0) {
				userconf_common_attr(c,a,UC_DISABLE);
			} else if (userconf_number(c,&a) == 0) {
d1060 3
a1062 3
			} else if (userconf_device(c,&a,&unit,&state) == 0) {
				userconf_common_dev(c,a,unit,state,UC_DISABLE);
			} else {
a1063 1
			}
d1066 1
a1066 1
			if (*c == '\000') {
d1068 3
a1070 3
			} else if (userconf_attr(c,&a) == 0) {
				userconf_common_attr(c,a,UC_ENABLE);
			} else if (userconf_number(c,&a) == 0) {
d1072 3
a1074 3
			} else if (userconf_device(c,&a,&unit,&state) == 0) {
				userconf_common_dev(c,a,unit,state,UC_ENABLE);
			} else {
a1075 1
			}
d1078 1
a1078 1
			if (*c == '\000') {
d1080 1
a1080 1
			} else if (userconf_number(c,&a) == 0) {
d1082 3
a1084 3
			} else if (userconf_device(c,&a,&unit,&state) == 0) {
				userconf_common_dev(c,a,unit,state,UC_FIND);
			} else {
a1085 1
			}
d1091 1
a1091 1
			if (*c == '\000') {
d1093 1
a1093 1
			} else {
a1094 1
			}
d1100 1
a1100 1
			if (*c == '\000') {
d1102 1
a1102 1
			} else {	
a1103 1
			}
d1117 1
a1117 1
	
d1120 1
a1120 1
	
@


1.11
log
@export struct cfdata cfdata[];
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.10 1996/09/06 15:35:09 maja Exp $	*/
d66 1
d74 1
a74 1
void userconf_show_attr_val __P((short, int *));
d77 1
d86 1
a220 17
/*
	printf("%3d",devno);
	switch(cd->cf_fstate) {
	case FSTATE_NOTFOUND:
        case FSTATE_FOUND:
        case FSTATE_STAR:
		printf(" E ");
		break;
	case FSTATE_DNOTFOUND:
        case FSTATE_DSTAR:
		printf(" D ");
		break;
        default:
		printf(" ? ");
		break;
	}
*/		
d336 31
d544 1
a544 1
	printf("command   args          description\n");
d551 2
a552 1
			printf("[count]       number of lines before more");
d555 1
a555 1
			printf("dev           add a device");
d558 1
a558 1
			printf("8|10|16       base on large numbers");
d561 1
a561 1
			printf("devno|dev     %s devices","change");
d564 1
a564 1
			printf("devno|dev     %s devices","disable");
d567 1
a567 1
			printf("devno|dev     %s devices","enable");
d570 1
a570 1
			printf("devno|dev     %s devices","find");
d573 1
a573 1
			printf("              %s","this message");
d576 1
a576 1
			printf("              %s","list configuration");
d579 1
a579 1
			printf("              %s","leave UKC");
d582 1
a582 1
			printf("[attr [val]]  %s",
d586 1
a586 1
			printf("              %s","don't know");
d626 1
a626 1
userconf_show_attr_val(attr, val)
d629 1
d650 15
a664 1
						userconf_pdev(i);
d710 1
a710 1
		userconf_show_attr_val(attr,NULL);
d713 1
a713 1
			userconf_show_attr_val(attr,&a);
d793 30
d1078 3
a1080 1
				printf("DevNo or Dev expected\n");
d1091 3
a1093 1
				printf("DevNo or Dev expected\n");
@


1.10
log
@Fixed another bug niklas found. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.9 1996/09/06 12:43:41 niklas Exp $	*/
a43 1
extern struct cfdata cfdata[];
@


1.9
log
@Call me "Pedant"! prototype mismatches fixed and unused var removed
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.8 1996/09/06 08:53:43 maja Exp $	*/
d817 1
a817 1
	struct cfdata new = {0};
d820 2
@


1.8
log
@Added support for add device in subr_userconf. Not perfect but a good start.
This needed changes in config, so if your kernel uses BOOT_CONFIG you need
to rebuild config before a new kernel can be built. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.7 1996/09/02 02:46:39 deraadt Exp $	*/
d760 1
d810 1
a817 1
	char cmd;
@


1.7
log
@loop till quit
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.6 1996/08/15 13:49:50 niklas Exp $	*/
d45 13
a57 9
extern cfroots[];

int userconf_base = 16;
int userconf_maxdev = -1;
int userconf_maxlocnames = -1;
int userconf_cnt = -1;
int userconf_lines = 12;
char userconf_argbuf[40];
char userconf_cmdbuf[40];
d77 2
d87 1
a87 1
/*	"add",		"a", */
d113 1
d125 7
d218 2
d235 1
a235 1
		
d246 13
d537 3
d760 174
d974 9
@


1.6
log
@-Wall, -Wstrict-prototypes and some KNF cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.5 1996/07/27 11:27:43 deraadt Exp $	*/
d865 1
a865 3
	printf(prompt);
	while (getsn(userconf_cmdbuf, sizeof(userconf_cmdbuf)) != 0) {
		if (userconf_parse(userconf_cmdbuf)) break;
d867 3
@


1.5
log
@subr_userconf.c only for BOOT_CONFIG option
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.4 1996/07/02 06:52:00 niklas Exp $	*/
d40 2
d55 20
d97 1
a101 2
	short *p;
	int   *l;
d139 1
d141 1
a141 1
int val;
d143 1
a143 1
	if (val > -2 & val < 16) {
d161 1
d163 1
a163 1
short dev;
d187 1
d189 1
a189 1
short devno;
d242 3
a244 3
userconf_number(c,val)
char *c;
int *val;
d262 1
a262 1
	while (*c != '\n' & *c != '\t' & *c != ' ' & *c != '\000') {
d289 4
a292 4
userconf_device(cmd,len,unit,state)
char *cmd;
int *len;
short *unit, *state;
d299 1
a299 1
	while(*c >= 'a' & *c <= 'z') { l++; c++; };
d304 1
a304 1
		while(*c >= '0' & *c <= '9') {
d322 1
d324 2
a325 2
char *item;
int  *val;
d355 1
d357 1
a357 1
int devno;
d424 1
d426 1
a426 1
int devno;
d459 1
d461 1
a461 1
int devno;
d494 1
d546 2
a547 2
userconf_list(count)
int count;
d561 1
d576 1
d578 2
a579 2
short attr;
int   *val;
d615 1
d617 1
a617 1
char *cmd;
d624 1
a624 1
	while (*c != ' ' & *c != '\t' & *c != '\n' & *c != '\000') {
d656 6
a661 5
userconf_common_dev(dev,len,unit,state,routine)
char *dev;
int len;
short unit, state;
char routine;
d730 1
a730 1
char *cmd;
d732 1
a732 1
	char *c,*v;
a860 1
	int  i;
d866 2
a867 2
	while (i = getsn(userconf_cmdbuf,sizeof(userconf_cmdbuf)) != 0) {
		if (userconf_parse(&userconf_cmdbuf)) break;
@


1.4
log
@-Wall & -Wstrict-prototype fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.3 1996/06/27 08:43:06 maja Exp $	*/
a34 1
#ifdef BOOT_CONFIG
a839 7
#else BOOT_CONFIG
void
user_config()
{
	printf("User Kernel Config isn't supported in this kernel\n");
}
#endif
@


1.3
log
@More bugs fixed. Replaced lots of "|" and "&" with the correct "||" and "&&".
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.2 1996/06/26 09:55:53 maja Exp $	*/
d37 1
d825 1
d842 1
@


1.2
log
@New safer userconf_number, more can be terminated with q, if more than one
device uses the same slots, allocates new space. /moj
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.1 1996/06/23 19:34:30 maja Exp $	*/
d113 1
a113 1
		if (c == 'q' | c == 'Q') quit = 1;
d233 1
a233 1
		if (*c == 'x' || *c == 'X')
d235 2
a236 1
		c++;
d241 1
a241 8
		if (base > 10) {
			if (cc >= 'a' && cc <= 'f')
				cc = cc - 'a' + 10;
			else if (cc >= 'A' && cc <= 'F')
				cc = cc - 'A' + 10;
			else
				return (-1);
		} else
d243 7
d286 1
a286 1
	while(*c == ' ' | *c == '\t' | *c == '\n') c++;
d315 1
a315 1
		while (*c == ' ' | *c == '\t' | *c == '\n') c++;
d342 1
a342 1
		while(c != 'y' & c != 'Y' & c != 'n' & c != 'N') {
d348 1
a348 1
		if (c == 'y' | c == 'Y') {
d595 1
a595 1
	while (*c == ' ' | *c == '\t' | *c == '\n') {
d651 8
a658 8
					len) == 0 &
			    (state == FSTATE_FOUND |
			     (state == FSTATE_STAR &
			      (cfdata[i].cf_fstate == FSTATE_STAR |
			       cfdata[i].cf_fstate == FSTATE_DSTAR)) |
			     (state == FSTATE_NOTFOUND &
			      cfdata[i].cf_unit == unit &
			      (cfdata[i].cf_fstate == FSTATE_NOTFOUND |
d704 1
a704 1
	while (*c == ' ' | *c == '\t') c++;
d706 1
a706 1
	while (*c != ' ' & *c != '\t' & *c != '\n' & *c != '\000') {
d720 1
a720 1
	while (*c == ' ' | *c == '\t' | *c == '\n') {
d743 1
a743 1
				if (a == 8 | a == 10 | a == 16) {
@


1.1
log
@Added support for user modifiable kernel at boot (-c) /maja
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_userconf.c,v 1.0 1996/06/22 19:12:48 maja Exp $	*/
d38 1
d45 7
a51 6
int	userconf_base = 16;
int	userconf_maxdev = -1;
int	userconf_maxlocnames = -1;
int	userconf_cnt = -1;
int	userconf_lines = 12;
char	userconf_cmdbuf[40];
d99 1
d102 1
d110 1
a110 1
			printf("\r");
d113 1
d115 1
d122 1
a122 1
		printf(" %d",val);
d126 1
a126 1
			printf(" 0%o",val);
d129 1
a129 1
			printf(" %d",val);
d133 1
a133 1
			printf(" 0x%x",val);
a177 3

	userconf_more();

d209 1
a209 1
		printf(" %s",locnames[locnamp[ln]]);
d222 17
a238 3
	u_int number=0;
	int base=10;
	int neg=1;
d240 12
a251 25
	if (*c == '0') base = 8;
	while (*c != ' ' & *c != '\t' & *c != '\n' & *c != '\000') {
		if (*c == '-') {
			neg = neg*-1;
		} 
		else if (*c >= '0' & *c <= '9') {
			number=number*base + (*c - '0');
		}
		else if (*c == '8' | *c == '9') {
			if (base == 8) return(-1);
			number=number*base + (*c - '0');
		}
		else if (*c >= 'A' & *c <= 'F') {
			if (base < 16) return(-1);
			number=number*base + (*c - 'A' + 10);
		}
		else if (*c >= 'a' & *c <= 'f') {
			if (base < 16) return(-1);
			number=number*base + (*c - 'a' + 10);
		}
		else if (*c == 'x' | *c == 'X') {
			base=16;
		} else {
			return(-1);
		}
d254 5
a259 1
	*val=(int)(number*neg);
d301 2
a302 1
	int ok = 0, a;
d311 1
a311 1
		i = getsn(userconf_cmdbuf,sizeof(userconf_cmdbuf));
d313 1
a313 1
		c = userconf_cmdbuf;
d348 1
d354 16
d376 7
d400 1
d413 1
a413 1
			printf("Already disabled\n");
d422 1
d434 1
d447 1
a447 1
			printf("Already enabled\n");
d456 1
d482 1
a482 1
			printf("devno|dev     %s","change");
d485 1
a485 1
			printf("devno|dev     %s","disable");
d488 1
a488 1
			printf("devno|dev     %s","enable");
d491 1
a491 1
			printf("devno|dev     %s","find");
d503 2
a504 1
			printf("[attr [val]]  show known attributes");
d524 1
d527 1
a527 1
	
a528 1

d538 1
a538 1
		userconf_more();
d552 2
a553 2
	int i = 0;

d563 1
d567 1
d572 1
d576 1
a580 1

d642 7
d652 8
a659 3
			     ((cfdata[i].cf_unit == unit |
			       cfdata[i].cf_fstate == FSTATE_STAR) &
			      cfdata[i].cf_fstate == state))) {
d825 1
a825 1
	static char prompt[] = "UKC> ";
@

