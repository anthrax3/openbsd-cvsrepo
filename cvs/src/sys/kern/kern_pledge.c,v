head	1.220;
access;
symbols
	OPENBSD_6_1:1.201.0.4
	OPENBSD_6_1_BASE:1.201
	OPENBSD_6_0:1.178.0.2
	OPENBSD_6_0_BASE:1.178
	OPENBSD_5_9:1.149.0.2
	OPENBSD_5_9_BASE:1.149;
locks; strict;
comment	@ * @;


1.220
date	2017.09.08.05.36.53;	author deraadt;	state Exp;
branches;
next	1.219;
commitid	uRv5pa9QDlZaYgwD;

1.219
date	2017.08.29.02.51.27;	author deraadt;	state Exp;
branches;
next	1.218;
commitid	rqeb3Cn0JHXrssFn;

1.218
date	2017.08.21.14.40.07;	author florian;	state Exp;
branches;
next	1.217;
commitid	y5L7AliJiMtTzhWG;

1.217
date	2017.07.28.02.14.56;	author rob;	state Exp;
branches;
next	1.216;
commitid	vVqHCwLc7GfZZuaI;

1.216
date	2017.06.29.04.10.07;	author deraadt;	state Exp;
branches;
next	1.215;
commitid	xmEskh3NewsIPRH3;

1.215
date	2017.06.21.17.13.20;	author deraadt;	state Exp;
branches;
next	1.214;
commitid	wWLoMRPj7uiJ0Psk;

1.214
date	2017.06.19.18.35.05;	author bluhm;	state Exp;
branches;
next	1.213;
commitid	pHSm4b13EzRXRRMH;

1.213
date	2017.06.12.21.55.16;	author deraadt;	state Exp;
branches;
next	1.212;
commitid	UdKSsVMuzS7C8Qc0;

1.212
date	2017.06.07.20.53.59;	author bluhm;	state Exp;
branches;
next	1.211;
commitid	LIcASwnR6ZAP0y3z;

1.211
date	2017.06.03.04.34.41;	author tb;	state Exp;
branches;
next	1.210;
commitid	JjJlnDrAN0xDbR0j;

1.210
date	2017.05.30.15.04.45;	author deraadt;	state Exp;
branches;
next	1.209;
commitid	XqeZIsi4AmIC4ShK;

1.209
date	2017.05.21.13.00.53;	author visa;	state Exp;
branches;
next	1.208;
commitid	CQbxXzxDtYW7UvJn;

1.208
date	2017.05.02.16.46.00;	author natano;	state Exp;
branches;
next	1.207;
commitid	ZIo4V3mrqBu7zaHV;

1.207
date	2017.04.29.08.02.56;	author mpi;	state Exp;
branches;
next	1.206;
commitid	frh8RnmPioYGd86x;

1.206
date	2017.04.28.13.50.55;	author mpi;	state Exp;
branches;
next	1.205;
commitid	34WECc0W9rocx17W;

1.205
date	2017.04.20.15.21.53;	author deraadt;	state Exp;
branches;
next	1.204;
commitid	mIX424WlgAu5BXMd;

1.204
date	2017.04.17.20.22.14;	author deraadt;	state Exp;
branches;
next	1.203;
commitid	Uxx6T6zUj3sw8WYA;

1.203
date	2017.04.13.04.06.46;	author guenther;	state Exp;
branches;
next	1.202;
commitid	SVe5BdUCNRQed2sI;

1.202
date	2017.04.11.15.55.41;	author bluhm;	state Exp;
branches;
next	1.201;
commitid	Jy5OOgEggfF9xJiT;

1.201
date	2017.03.30.15.22.07;	author deraadt;	state Exp;
branches;
next	1.200;
commitid	6rvXFHs2jNkgGWv2;

1.200
date	2017.03.28.16.03.31;	author bluhm;	state Exp;
branches;
next	1.199;
commitid	lW4ywU8x2rjiucZt;

1.199
date	2017.03.27.00.33.15;	author deraadt;	state Exp;
branches;
next	1.198;
commitid	0B9RwVlkD9KDvlp6;

1.198
date	2017.03.26.22.47.45;	author deraadt;	state Exp;
branches;
next	1.197;
commitid	CVm2Pv2ZgetsGrXy;

1.197
date	2017.03.26.22.42.36;	author deraadt;	state Exp;
branches;
next	1.196;
commitid	laIJMi2sVV9aveyl;

1.196
date	2017.03.18.01.50.21;	author deraadt;	state Exp;
branches;
next	1.195;
commitid	dIINu50FCDJ7qu2s;

1.195
date	2017.03.14.16.49.18;	author florian;	state Exp;
branches;
next	1.194;
commitid	2mayoU4ARx5d5J7b;

1.194
date	2017.03.11.16.54.54;	author deraadt;	state Exp;
branches;
next	1.193;
commitid	5EPwUtXadln6JycN;

1.193
date	2017.03.11.07.03.38;	author deraadt;	state Exp;
branches;
next	1.192;
commitid	MtyAsuIJjkFUxXV1;

1.192
date	2017.01.23.05.49.24;	author deraadt;	state Exp;
branches;
next	1.191;
commitid	wK1ncmQiDZQwqLOn;

1.191
date	2017.01.23.04.25.05;	author deraadt;	state Exp;
branches;
next	1.190;
commitid	NeJrtXDNhZqhGXfa;

1.190
date	2017.01.23.03.17.55;	author deraadt;	state Exp;
branches;
next	1.189;
commitid	OBp6UhIi7kOGsa7Y;

1.189
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.188;
commitid	CHRb0fCqa8XxUAMH;

1.188
date	2016.11.13.00.40.09;	author tb;	state Exp;
branches;
next	1.187;
commitid	fewwOf7VnhuhZ56W;

1.187
date	2016.10.27.10.48.25;	author schwarze;	state Exp;
branches;
next	1.186;
commitid	FxmBgvltNmLwfH0K;

1.186
date	2016.10.21.06.56.38;	author mlarkin;	state Exp;
branches;
next	1.185;
commitid	5xh9q2ooOi34uhvF;

1.185
date	2016.10.06.04.39.30;	author jsg;	state Exp;
branches;
next	1.184;
commitid	01p6AvFzXfFk2DQt;

1.184
date	2016.10.05.05.22.02;	author guenther;	state Exp;
branches;
next	1.183;
commitid	MwcLLRyNBvUrrYA1;

1.183
date	2016.09.17.00.42.35;	author tedu;	state Exp;
branches;
next	1.182;
commitid	WXKcqASY5efUKj2J;

1.182
date	2016.09.04.17.22.40;	author jsing;	state Exp;
branches;
next	1.181;
commitid	NpC0d7eh7RcmjtSO;

1.181
date	2016.08.31.07.22.43;	author ratchov;	state Exp;
branches;
next	1.180;
commitid	u524ZaNwqXxsCXa2;

1.180
date	2016.07.28.12.12.16;	author mikeb;	state Exp;
branches;
next	1.179;
commitid	XBr0OuD99GMVz0wl;

1.179
date	2016.07.28.12.08.14;	author mikeb;	state Exp;
branches;
next	1.178;
commitid	DybuCYH7FsRJfhfz;

1.178
date	2016.07.12.06.06.34;	author deraadt;	state Exp;
branches;
next	1.177;
commitid	1e6KLdI5HA86JAGg;

1.177
date	2016.07.11.19.11.34;	author deraadt;	state Exp;
branches;
next	1.176;
commitid	Ho293WXn8SHug0M7;

1.176
date	2016.07.10.14.21.24;	author semarie;	state Exp;
branches;
next	1.175;
commitid	yj80kuEv3HwDAI4l;

1.175
date	2016.07.10.00.39.23;	author guenther;	state Exp;
branches;
next	1.174;
commitid	FzoudwT6V4RHXslw;

1.174
date	2016.07.03.04.36.08;	author semarie;	state Exp;
branches;
next	1.173;
commitid	sZFqhpjiVWq1IcpS;

1.173
date	2016.06.28.04.27.58;	author semarie;	state Exp;
branches;
next	1.172;
commitid	FgqRAzc0xe4tZ4mZ;

1.172
date	2016.06.27.16.49.45;	author jsing;	state Exp;
branches;
next	1.171;
commitid	iLjJpmaJ0JoxMuMA;

1.171
date	2016.06.27.16.33.48;	author jca;	state Exp;
branches;
next	1.170;
commitid	s8BpQvqrMutiVjd6;

1.170
date	2016.06.07.01.31.54;	author tedu;	state Exp;
branches;
next	1.169;
commitid	37V3kDRiYRccnYvB;

1.169
date	2016.05.31.22.14.43;	author deraadt;	state Exp;
branches;
next	1.168;
commitid	0oNnIcgqQW50Cm5L;

1.168
date	2016.05.31.22.12.26;	author deraadt;	state Exp;
branches;
next	1.167;
commitid	0EyYiD0wCrSLXuqy;

1.167
date	2016.05.27.16.33.55;	author deraadt;	state Exp;
branches;
next	1.166;
commitid	iPBEcwpdgONWUYo2;

1.166
date	2016.05.15.05.04.28;	author semarie;	state Exp;
branches;
next	1.165;
commitid	8tdCXjy9WyUFioOZ;

1.165
date	2016.04.28.14.25.08;	author beck;	state Exp;
branches;
next	1.164;
commitid	0n3rYqVGfgJRKpEF;

1.164
date	2016.04.25.10.01.23;	author semarie;	state Exp;
branches;
next	1.163;
commitid	3A9w9iSsCkGrcqCA;

1.163
date	2016.04.25.09.58.23;	author semarie;	state Exp;
branches;
next	1.162;
commitid	EW1bZ60HnNSj106o;

1.162
date	2016.03.30.07.49.11;	author guenther;	state Exp;
branches;
next	1.161;
commitid	CEQ2oOx0iodZAOMX;

1.161
date	2016.03.25.17.25.36;	author semarie;	state Exp;
branches;
next	1.160;
commitid	TOZqMqOlxGSqBhSm;

1.160
date	2016.03.22.05.59.17;	author deraadt;	state Exp;
branches;
next	1.159;
commitid	ESpxhxktzSkckfx4;

1.159
date	2016.03.21.22.41.29;	author bluhm;	state Exp;
branches;
next	1.158;
commitid	hneUpr7ZOJCeNeHP;

1.158
date	2016.03.16.06.46.39;	author ratchov;	state Exp;
branches;
next	1.157;
commitid	QZGe5AFBhlhD5xcQ;

1.157
date	2016.03.15.15.10.09;	author semarie;	state Exp;
branches;
next	1.156;
commitid	Th4AyvBX1MPbeeFx;

1.156
date	2016.03.15.15.05.23;	author semarie;	state Exp;
branches;
next	1.155;
commitid	kCr4yxJis73LXrbV;

1.155
date	2016.03.13.18.40.52;	author semarie;	state Exp;
branches;
next	1.154;
commitid	yxP6413IL5JOCDUx;

1.154
date	2016.03.13.15.27.21;	author semarie;	state Exp;
branches;
next	1.153;
commitid	KNBbiKg8GYi1Wyv4;

1.153
date	2016.03.13.15.05.15;	author semarie;	state Exp;
branches;
next	1.152;
commitid	AeOtP3SAdu1bKca6;

1.152
date	2016.03.13.14.27.18;	author semarie;	state Exp;
branches;
next	1.151;
commitid	VIFODf0QDKzYBcDG;

1.151
date	2016.03.13.04.51.59;	author semarie;	state Exp;
branches;
next	1.150;
commitid	BbyfkOyoaKp5jehx;

1.150
date	2016.03.11.05.57.16;	author semarie;	state Exp;
branches;
next	1.149;
commitid	goPKoPASETuT6gCA;

1.149
date	2016.02.17.21.52.06;	author millert;	state Exp;
branches
	1.149.2.1;
next	1.148;
commitid	6VMdrVNrQFY1Adtn;

1.148
date	2016.01.19.07.31.48;	author ratchov;	state Exp;
branches;
next	1.147;
commitid	ll83SmPiyauiq0H4;

1.147
date	2016.01.18.17.19.55;	author deraadt;	state Exp;
branches;
next	1.146;
commitid	lIKbvXlSvQGKVUsG;

1.146
date	2016.01.09.06.13.43;	author semarie;	state Exp;
branches;
next	1.145;
commitid	dcaV4x1VpVc8yivT;

1.145
date	2016.01.08.11.20.58;	author reyk;	state Exp;
branches;
next	1.144;
commitid	75vkfVJpzZUMdF67;

1.144
date	2016.01.06.18.43.10;	author tedu;	state Exp;
branches;
next	1.143;
commitid	rC240Waw3PaWLN59;

1.143
date	2016.01.06.17.59.30;	author tedu;	state Exp;
branches;
next	1.142;
commitid	vtbNHxTkwTC4OW91;

1.142
date	2016.01.06.09.09.16;	author kettenis;	state Exp;
branches;
next	1.141;
commitid	nVj87EkrOwcIg67T;

1.141
date	2016.01.05.18.09.24;	author deraadt;	state Exp;
branches;
next	1.140;
commitid	e5AGF5X2u9cspDYu;

1.140
date	2015.12.27.16.36.07;	author tb;	state Exp;
branches;
next	1.139;
commitid	Dj2lXkuSpkQRvNTp;

1.139
date	2015.12.27.01.37.46;	author deraadt;	state Exp;
branches;
next	1.138;
commitid	8yUT5d2AHmgy56mc;

1.138
date	2015.12.23.21.07.57;	author deraadt;	state Exp;
branches;
next	1.137;
commitid	fsbPPeDgilsDO8Wa;

1.137
date	2015.12.23.20.09.47;	author ratchov;	state Exp;
branches;
next	1.136;
commitid	TJwaJ3CAQL8SUKln;

1.136
date	2015.12.06.17.50.21;	author deraadt;	state Exp;
branches;
next	1.135;
commitid	fXd8HOPcFESXsWp4;

1.135
date	2015.12.05.19.21.49;	author deraadt;	state Exp;
branches;
next	1.134;
commitid	eQhdDl807KhzbwF4;

1.134
date	2015.12.04.16.56.35;	author deraadt;	state Exp;
branches;
next	1.133;
commitid	zy01jD2QnNASjRvC;

1.133
date	2015.12.04.13.05.34;	author semarie;	state Exp;
branches;
next	1.132;
commitid	skL5eGv1OJIjmM4H;

1.132
date	2015.12.04.07.33.05;	author deraadt;	state Exp;
branches;
next	1.131;
commitid	FCPi32lyPV1UcS6e;

1.131
date	2015.12.04.06.01.55;	author deraadt;	state Exp;
branches;
next	1.130;
commitid	oQjlkJ8lhns4ZFDC;

1.130
date	2015.12.03.16.50.44;	author bluhm;	state Exp;
branches;
next	1.129;
commitid	ku8NxdT795Pqq7fK;

1.129
date	2015.12.03.16.05.51;	author benno;	state Exp;
branches;
next	1.128;
commitid	GNtsAtS3ozmSA14H;

1.128
date	2015.11.29.03.23.19;	author deraadt;	state Exp;
branches;
next	1.127;
commitid	oXd0ywHfW0rhQqNv;

1.127
date	2015.11.29.01.15.49;	author benno;	state Exp;
branches;
next	1.126;
commitid	w9LQyEzvPFgBiJ80;

1.126
date	2015.11.28.18.10.12;	author benno;	state Exp;
branches;
next	1.125;
commitid	QkvnB3mbZvtyr79o;

1.125
date	2015.11.27.18.54.47;	author jca;	state Exp;
branches;
next	1.124;
commitid	WBEhJFXZ52BRlxTZ;

1.124
date	2015.11.25.15.53.01;	author deraadt;	state Exp;
branches;
next	1.123;
commitid	Llmkj66mwRt1eT7J;

1.123
date	2015.11.24.23.59.22;	author deraadt;	state Exp;
branches;
next	1.122;
commitid	yUsxyREKtyEcbCjj;

1.122
date	2015.11.23.21.32.29;	author deraadt;	state Exp;
branches;
next	1.121;
commitid	gj0NwH8xq0ceW6rh;

1.121
date	2015.11.23.07.23.24;	author deraadt;	state Exp;
branches;
next	1.120;
commitid	MBBZwNRrbm9MvyIf;

1.120
date	2015.11.22.18.50.45;	author deraadt;	state Exp;
branches;
next	1.119;
commitid	saZZl3xEdKL3gf30;

1.119
date	2015.11.22.18.48.16;	author deraadt;	state Exp;
branches;
next	1.118;
commitid	nZ0JxmsHBprkG4qn;

1.118
date	2015.11.20.20.59.52;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	9cCBoA1QHPMh78R8;

1.117
date	2015.11.20.16.06.54;	author deraadt;	state Exp;
branches;
next	1.116;
commitid	286NXZOWU0sYXBvc;

1.116
date	2015.11.20.07.15.30;	author deraadt;	state Exp;
branches;
next	1.115;
commitid	Ifznv9HMHMddHBOE;

1.115
date	2015.11.18.08.24.22;	author semarie;	state Exp;
branches;
next	1.114;
commitid	UoU7wlG0nheL5cpK;

1.114
date	2015.11.17.15.03.53;	author sthen;	state Exp;
branches;
next	1.113;
commitid	ukYsu38MUOPjFXp1;

1.113
date	2015.11.17.04.09.35;	author deraadt;	state Exp;
branches;
next	1.112;
commitid	XLCpauaH7FJ25Ymq;

1.112
date	2015.11.16.21.20.20;	author deraadt;	state Exp;
branches;
next	1.111;
commitid	fYnmWsiHLFCIXXWX;

1.111
date	2015.11.16.18.29.35;	author deraadt;	state Exp;
branches;
next	1.110;
commitid	2cmB9LfHejDl4UoQ;

1.110
date	2015.11.16.17.41.45;	author pascal;	state Exp;
branches;
next	1.109;
commitid	ZPF7R19NYsT6V78r;

1.109
date	2015.11.14.22.23.22;	author deraadt;	state Exp;
branches;
next	1.108;
commitid	tkunitxnSEUu2zs1;

1.108
date	2015.11.14.07.02.23;	author deraadt;	state Exp;
branches;
next	1.107;
commitid	VxY68y32N4VzXf03;

1.107
date	2015.11.13.17.12.01;	author deraadt;	state Exp;
branches;
next	1.106;
commitid	3HyMIGcppkucI3xT;

1.106
date	2015.11.10.04.30.59;	author guenther;	state Exp;
branches;
next	1.105;
commitid	GTAoVjpQRAdNHXVz;

1.105
date	2015.11.05.15.10.11;	author semarie;	state Exp;
branches;
next	1.104;
commitid	y3ICP5kBCePGycAx;

1.104
date	2015.11.04.21.24.23;	author tedu;	state Exp;
branches;
next	1.103;
commitid	TzmafWIW8RVaz5nL;

1.103
date	2015.11.04.19.18.21;	author semarie;	state Exp;
branches;
next	1.102;
commitid	vBRhWmu934UECzGG;

1.102
date	2015.11.03.16.14.14;	author deraadt;	state Exp;
branches;
next	1.101;
commitid	0guBDAktsQ8jv0a9;

1.101
date	2015.11.02.23.17.23;	author tedu;	state Exp;
branches;
next	1.100;
commitid	c0m1eqObl1CevjOZ;

1.100
date	2015.11.02.17.53.00;	author semarie;	state Exp;
branches;
next	1.99;
commitid	lE1pQRFRNhrMeRvW;

1.99
date	2015.11.02.16.31.55;	author semarie;	state Exp;
branches;
next	1.98;
commitid	PyvdcQVr9G4daVnG;

1.98
date	2015.11.02.15.33.40;	author deraadt;	state Exp;
branches;
next	1.97;
commitid	dqHEpVMkeanzvjcc;

1.97
date	2015.11.01.19.03.33;	author semarie;	state Exp;
branches;
next	1.96;
commitid	VKRkUfXZQNJ8UQeY;

1.96
date	2015.11.01.15.43.50;	author deraadt;	state Exp;
branches;
next	1.95;
commitid	7oe8J5HFEmNQx8ki;

1.95
date	2015.11.01.13.01.58;	author semarie;	state Exp;
branches;
next	1.94;
commitid	5MRjBtbyYiJ3NorZ;

1.94
date	2015.10.31.21.53.53;	author deraadt;	state Exp;
branches;
next	1.93;
commitid	NXVhBaHxlxrKIneC;

1.93
date	2015.10.31.02.46.23;	author deraadt;	state Exp;
branches;
next	1.92;
commitid	MDdQ0z7CTldnmQ3F;

1.92
date	2015.10.29.15.04.54;	author deraadt;	state Exp;
branches;
next	1.91;
commitid	7OAFUm3t9mMfzbOr;

1.91
date	2015.10.29.12.51.06;	author deraadt;	state Exp;
branches;
next	1.90;
commitid	nl1K5EmvhHMG89VX;

1.90
date	2015.10.28.17.38.52;	author deraadt;	state Exp;
branches;
next	1.89;
commitid	f19IHuJ4qlcKplZR;

1.89
date	2015.10.28.15.33.44;	author semarie;	state Exp;
branches;
next	1.88;
commitid	lTVMRpHtZydKPvC1;

1.88
date	2015.10.28.14.07.58;	author semarie;	state Exp;
branches;
next	1.87;
commitid	W9UmY0OlrfwaLfRF;

1.87
date	2015.10.28.13.59.07;	author semarie;	state Exp;
branches;
next	1.86;
commitid	xCqhsa07qivG0JT0;

1.86
date	2015.10.28.13.42.57;	author semarie;	state Exp;
branches;
next	1.85;
commitid	y5Letx8vfaxqIArb;

1.85
date	2015.10.28.13.36.38;	author semarie;	state Exp;
branches;
next	1.84;
commitid	xFyFRcktMpm6VKgW;

1.84
date	2015.10.28.12.17.20;	author deraadt;	state Exp;
branches;
next	1.83;
commitid	zkbQCjO85aouBbdV;

1.83
date	2015.10.28.12.03.39;	author deraadt;	state Exp;
branches;
next	1.82;
commitid	mkxJ3rVL6ZrebUew;

1.82
date	2015.10.28.09.35.03;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	BU4sDqoQByjs9eTM;

1.81
date	2015.10.28.02.12.54;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	5Of1yP8do9mIELz3;

1.80
date	2015.10.26.17.52.19;	author deraadt;	state Exp;
branches;
next	1.79;
commitid	I9wjWUEPAwimcRFR;

1.79
date	2015.10.26.12.13.45;	author deraadt;	state Exp;
branches;
next	1.78;
commitid	kRiKuZSAxYDDPtlb;

1.78
date	2015.10.26.11.17.52;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	lE9hFu0XD39YNtcZ;

1.77
date	2015.10.26.11.11.45;	author deraadt;	state Exp;
branches;
next	1.76;
commitid	mVi5MegIKDjBUba4;

1.76
date	2015.10.26.07.44.43;	author semarie;	state Exp;
branches;
next	1.75;
commitid	bntEeJIIMTas2PqV;

1.75
date	2015.10.26.07.24.20;	author semarie;	state Exp;
branches;
next	1.74;
commitid	9KmnG31nIVcQPeid;

1.74
date	2015.10.25.20.39.54;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	SIwCBDJKKae61tEi;

1.73
date	2015.10.25.17.45.29;	author deraadt;	state Exp;
branches;
next	1.72;
commitid	Yos3wgCrSjTdd7Hx;

1.72
date	2015.10.25.11.09.28;	author semarie;	state Exp;
branches;
next	1.71;
commitid	E9AxvjZMNAtcnK4C;

1.71
date	2015.10.25.10.30.58;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	Ug4vdcV83xAv1ShR;

1.70
date	2015.10.25.01.57.09;	author millert;	state Exp;
branches;
next	1.69;
commitid	NEpv19MiqZgXVE8u;

1.69
date	2015.10.25.00.02.00;	author nicm;	state Exp;
branches;
next	1.68;
commitid	xARxcYKCw5PncbTN;

1.68
date	2015.10.23.15.53.49;	author deraadt;	state Exp;
branches;
next	1.67;
commitid	GPkowIqCgE0Qs3Lr;

1.67
date	2015.10.23.10.22.29;	author claudio;	state Exp;
branches;
next	1.66;
commitid	T6PH2wUDdHyRNguI;

1.66
date	2015.10.23.01.10.01;	author deraadt;	state Exp;
branches;
next	1.65;
commitid	KqW7FHnhlWUon4U2;

1.65
date	2015.10.23.00.56.52;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	EgiP6irB9JuODp8E;

1.64
date	2015.10.22.11.01.43;	author deraadt;	state Exp;
branches;
next	1.63;
commitid	NGqioqjPPCIRl5U7;

1.63
date	2015.10.22.10.35.23;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	nfa7E9LntEvxdj61;

1.62
date	2015.10.20.18.04.03;	author deraadt;	state Exp;
branches;
next	1.61;
commitid	cbpu7TMBEmsrNLlG;

1.61
date	2015.10.20.17.44.48;	author reyk;	state Exp;
branches;
next	1.60;
commitid	Locw3cafvzfNncLh;

1.60
date	2015.10.20.06.40.00;	author semarie;	state Exp;
branches;
next	1.59;
commitid	cZnfuIvm8DKmhV1I;

1.59
date	2015.10.20.05.18.34;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	Ue4okQy0e6XdV0TN;

1.58
date	2015.10.20.01.44.00;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	GxCldWSIRJP5XzFU;

1.57
date	2015.10.19.16.20.56;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	sVeL1j6b8BQqT1qn;

1.56
date	2015.10.19.12.55.32;	author nicm;	state Exp;
branches;
next	1.55;
commitid	Y09ns9Zf165yUO7S;

1.55
date	2015.10.18.20.15.10;	author deraadt;	state Exp;
branches;
next	1.54;
commitid	Nk95LvaVIfrgXtf6;

1.54
date	2015.10.18.05.26.55;	author semarie;	state Exp;
branches;
next	1.53;
commitid	vI7WMFKKR27g98c6;

1.53
date	2015.10.18.04.21.39;	author deraadt;	state Exp;
branches;
next	1.52;
commitid	vCbDpeKI6BJlopTX;

1.52
date	2015.10.18.03.30.01;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	X5CwZ71xUlTEhywY;

1.51
date	2015.10.18.01.53.31;	author deraadt;	state Exp;
branches;
next	1.50;
commitid	0elKrL4hLhdhrQ1N;

1.50
date	2015.10.18.01.07.19;	author doug;	state Exp;
branches;
next	1.49;
commitid	B1HAebZQW7NPDAEi;

1.49
date	2015.10.18.00.04.43;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	19QhHGSTTsDpRV7q;

1.48
date	2015.10.17.23.50.04;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	mqfG6OyFWxeA5tsp;

1.47
date	2015.10.17.23.12.46;	author deraadt;	state Exp;
branches;
next	1.46;
commitid	fcQfOgPb2DtouEh6;

1.46
date	2015.10.17.23.04.06;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	gxSO5Bd5gPrU3HJ7;

1.45
date	2015.10.17.23.01.37;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	PBIFBbbwlsk0b4QV;

1.44
date	2015.10.17.22.58.30;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	6dMGrzB6Ijvd6YaC;

1.43
date	2015.10.17.22.54.23;	author deraadt;	state Exp;
branches;
next	1.42;
commitid	47s1RsxdU6dPy3RA;

1.42
date	2015.10.17.04.31.10;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	Mtvd1mUbQyyWut09;

1.41
date	2015.10.17.00.58.50;	author jca;	state Exp;
branches;
next	1.40;
commitid	h9coXuZzKWICcd7R;

1.40
date	2015.10.16.23.00.01;	author jca;	state Exp;
branches;
next	1.39;
commitid	QVUIzfC2yNLadobr;

1.39
date	2015.10.16.17.03.31;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	QWRDzXbOdu3kTOVW;

1.38
date	2015.10.16.15.39.14;	author nicm;	state Exp;
branches;
next	1.37;
commitid	kZqVGzh4ryAALox9;

1.37
date	2015.10.16.14.20.48;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	yVnjzzs6daFs3rs2;

1.36
date	2015.10.16.14.04.11;	author semarie;	state Exp;
branches;
next	1.35;
commitid	ENshdJQqoaKdbEvO;

1.35
date	2015.10.16.14.00.37;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	tCSNr0rL6O1C2oew;

1.34
date	2015.10.16.13.59.58;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	27n9uk20lQwXnF4V;

1.33
date	2015.10.16.13.37.43;	author millert;	state Exp;
branches;
next	1.32;
commitid	H99PcNtHGZMrNl2r;

1.32
date	2015.10.16.06.42.02;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	otSSB7pYrMOthDQ1;

1.31
date	2015.10.16.06.40.53;	author doug;	state Exp;
branches;
next	1.30;
commitid	5EHsT5abowrCmFLb;

1.30
date	2015.10.15.17.55.41;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	x6rZQcS0Ssgsyu4j;

1.29
date	2015.10.15.17.50.05;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	bCht4yhZK99Uy0FQ;

1.28
date	2015.10.15.04.58.54;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	L0rvQfcxXo8ObD9V;

1.27
date	2015.10.14.23.15.37;	author sthen;	state Exp;
branches;
next	1.26;
commitid	WlLcgx2sWGeIXroF;

1.26
date	2015.10.14.22.34.47;	author millert;	state Exp;
branches;
next	1.25;
commitid	KtwHpwhia2cafGfL;

1.25
date	2015.10.14.14.24.03;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	fihBIqC2Qdmk6hpM;

1.24
date	2015.10.14.04.05.43;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	sobNsy6XvdbDvcT1;

1.23
date	2015.10.14.03.27.02;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	s5w93dunH5d3uH4W;

1.22
date	2015.10.13.20.00.49;	author deraadt;	state Exp;
branches;
next	1.21;
commitid	cbcL6Laxi5CQMQZd;

1.21
date	2015.10.13.18.42.06;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	khMOmzGQrP0EHQ05;

1.20
date	2015.10.13.18.38.34;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	uvH0P2wNO4rhzJxg;

1.19
date	2015.10.13.16.09.24;	author deraadt;	state Exp;
branches;
next	1.18;
commitid	jmVv3Dh9DqvD3r0d;

1.18
date	2015.10.13.00.03.42;	author doug;	state Exp;
branches;
next	1.17;
commitid	j6WtpFgg70oKfNvZ;

1.17
date	2015.10.12.23.16.23;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	0VngfHd0Hu8PDa5r;

1.16
date	2015.10.12.21.43.20;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	e47IViSbp5KA4A7N;

1.15
date	2015.10.11.16.19.48;	author semarie;	state Exp;
branches;
next	1.14;
commitid	VwJyGvgPnzx7Z03F;

1.14
date	2015.10.11.16.01.06;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	k2yVK5VvWkcmEYyI;

1.13
date	2015.10.11.15.40.48;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	9i8OBwF3jf8c9Cb6;

1.12
date	2015.10.11.15.25.39;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	Npdoyc6KwjTQwDWS;

1.11
date	2015.10.11.01.56.56;	author guenther;	state Exp;
branches;
next	1.10;
commitid	b7YO1SWN27gSiXsj;

1.10
date	2015.10.10.19.15.53;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	VEvHhDJs1Ztu1WUX;

1.9
date	2015.10.10.16.35.08;	author deraadt;	state Exp;
branches;
next	1.8;
commitid	EF2rFPwyXxtcv9Sh;

1.8
date	2015.10.10.14.48.03;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	OFrghLj9XzwcxOJ4;

1.7
date	2015.10.10.14.46.15;	author deraadt;	state Exp;
branches;
next	1.6;
commitid	lDLsX85yoZrvGrDS;

1.6
date	2015.10.09.23.55.03;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	xJO135yQ1KjvxFYJ;

1.5
date	2015.10.09.17.18.20;	author deraadt;	state Exp;
branches;
next	1.4;
commitid	EjcrnDKf1z91KDse;

1.4
date	2015.10.09.05.30.03;	author deraadt;	state Exp;
branches;
next	1.3;
commitid	2OjRc0zgcc3zTio6;

1.3
date	2015.10.09.02.44.22;	author deraadt;	state Exp;
branches;
next	1.2;
commitid	y7wmIACXag7cLNGJ;

1.2
date	2015.10.09.02.36.46;	author deraadt;	state Exp;
branches;
next	1.1;
commitid	LPpUMPCj34rQj5q6;

1.1
date	2015.10.09.01.17.21;	author deraadt;	state Exp;
branches;
next	;
commitid	6ulbDS81ej0XxvnS;

1.149.2.1
date	2016.03.16.08.30.01;	author semarie;	state Exp;
branches;
next	;
commitid	Edj0IQdmBJDhfjuM;


desc
@@


1.220
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: kern_pledge.c,v 1.219 2017/08/29 02:51:27 deraadt Exp $	*/

/*
 * Copyright (c) 2015 Nicholas Marriott <nicm@@openbsd.org>
 * Copyright (c) 2015 Theo de Raadt <deraadt@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>

#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/fcntl.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/namei.h>
#include <sys/socketvar.h>
#include <sys/vnode.h>
#include <sys/mbuf.h>
#include <sys/mman.h>
#include <sys/sysctl.h>
#include <sys/syslog.h>
#include <sys/ktrace.h>
#include <sys/acct.h>

#include <sys/ioctl.h>
#include <sys/termios.h>
#include <sys/tty.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <sys/mtio.h>
#include <sys/audioio.h>
#include <net/bpf.h>
#include <net/route.h>
#include <net/if.h>
#include <net/if_var.h>
#include <netinet/in.h>
#include <netinet6/in6_var.h>
#include <netinet6/nd6.h>
#include <netinet/tcp.h>
#include <net/pfvar.h>

#include <sys/conf.h>
#include <sys/specdev.h>
#include <sys/signal.h>
#include <sys/signalvar.h>
#include <sys/syscall.h>
#include <sys/syscallargs.h>
#include <sys/systm.h>

#include <dev/biovar.h>

#define PLEDGENAMES
#include <sys/pledge.h>

#include "audio.h"
#include "bpfilter.h"
#include "pf.h"
#include "pty.h"

#if defined(__amd64__) || defined(__i386__)
#include "vmm.h"
#if NVMM > 0
#include <machine/conf.h>
#endif
#endif

#if defined(__amd64__) || defined(__i386__) || \
    defined(__loongson__) || defined(__macppc__) || \
    defined(__sparc64__)
#include "drm.h"
#endif

uint64_t pledgereq_flags(const char *req);
int canonpath(const char *input, char *buf, size_t bufsize);

/* #define DEBUG_PLEDGE */
#ifdef DEBUG_PLEDGE
int debug_pledge = 1;
#define DPRINTF(x...)    do { if (debug_pledge) printf(x); } while (0)
#define DNPRINTF(n,x...) do { if (debug_pledge >= (n)) printf(x); } while (0)
#else
#define DPRINTF(x...)
#define DNPRINTF(n,x...)
#endif

/*
 * Ordered in blocks starting with least risky and most required.
 */
const uint64_t pledge_syscalls[SYS_MAXSYSCALL] = {
	/*
	 * Minimum required
	 */
	[SYS_exit] = PLEDGE_ALWAYS,
	[SYS_kbind] = PLEDGE_ALWAYS,
	[SYS___get_tcb] = PLEDGE_ALWAYS,
	[SYS_pledge] = PLEDGE_ALWAYS,
	[SYS_sendsyslog] = PLEDGE_ALWAYS,	/* stack protector reporting */
	[SYS_thrkill] = PLEDGE_ALWAYS,		/* raise, abort, stack pro */
	[SYS_utrace] = PLEDGE_ALWAYS,		/* ltrace(1) from ld.so */

	/* "getting" information about self is considered safe */
	[SYS_getuid] = PLEDGE_STDIO,
	[SYS_geteuid] = PLEDGE_STDIO,
	[SYS_getresuid] = PLEDGE_STDIO,
	[SYS_getgid] = PLEDGE_STDIO,
	[SYS_getegid] = PLEDGE_STDIO,
	[SYS_getresgid] = PLEDGE_STDIO,
	[SYS_getgroups] = PLEDGE_STDIO,
	[SYS_getlogin_r] = PLEDGE_STDIO,
	[SYS_getpgrp] = PLEDGE_STDIO,
	[SYS_getpgid] = PLEDGE_STDIO,
	[SYS_getppid] = PLEDGE_STDIO,
	[SYS_getsid] = PLEDGE_STDIO,
	[SYS_getthrid] = PLEDGE_STDIO,
	[SYS_getrlimit] = PLEDGE_STDIO,
	[SYS_getrtable] = PLEDGE_STDIO,
	[SYS_gettimeofday] = PLEDGE_STDIO,
	[SYS_getdtablecount] = PLEDGE_STDIO,
	[SYS_getrusage] = PLEDGE_STDIO,
	[SYS_issetugid] = PLEDGE_STDIO,
	[SYS_clock_getres] = PLEDGE_STDIO,
	[SYS_clock_gettime] = PLEDGE_STDIO,
	[SYS_getpid] = PLEDGE_STDIO,

	/*
	 * Almost exclusively read-only, Very narrow subset.
	 * Use of "route", "inet", "dns", "ps", or "vminfo"
	 * expands access.
	 */
	[SYS_sysctl] = PLEDGE_STDIO,

	/* Support for malloc(3) family of operations */
	[SYS_getentropy] = PLEDGE_STDIO,
	[SYS_madvise] = PLEDGE_STDIO,
	[SYS_minherit] = PLEDGE_STDIO,
	[SYS_mmap] = PLEDGE_STDIO,
	[SYS_mprotect] = PLEDGE_STDIO,
	[SYS_mquery] = PLEDGE_STDIO,
	[SYS_munmap] = PLEDGE_STDIO,
	[SYS_msync] = PLEDGE_STDIO,
	[SYS_break] = PLEDGE_STDIO,

	[SYS_umask] = PLEDGE_STDIO,

	/* read/write operations */
	[SYS_read] = PLEDGE_STDIO,
	[SYS_readv] = PLEDGE_STDIO,
	[SYS_pread] = PLEDGE_STDIO,
	[SYS_preadv] = PLEDGE_STDIO,
	[SYS_write] = PLEDGE_STDIO,
	[SYS_writev] = PLEDGE_STDIO,
	[SYS_pwrite] = PLEDGE_STDIO,
	[SYS_pwritev] = PLEDGE_STDIO,
	[SYS_recvmsg] = PLEDGE_STDIO,
	[SYS_recvfrom] = PLEDGE_STDIO | PLEDGE_YPACTIVE,
	[SYS_ftruncate] = PLEDGE_STDIO,
	[SYS_lseek] = PLEDGE_STDIO,
	[SYS_fpathconf] = PLEDGE_STDIO,

	/*
	 * Address selection required a network pledge ("inet",
	 * "unix", "dns".
	 */
	[SYS_sendto] = PLEDGE_STDIO | PLEDGE_YPACTIVE,

	/*
	 * Address specification required a network pledge ("inet",
	 * "unix", "dns".  SCM_RIGHTS requires "sendfd" or "recvfd".
	 */
	[SYS_sendmsg] = PLEDGE_STDIO,

	/* Common signal operations */
	[SYS_nanosleep] = PLEDGE_STDIO,
	[SYS_sigaltstack] = PLEDGE_STDIO,
	[SYS_sigprocmask] = PLEDGE_STDIO,
	[SYS_sigsuspend] = PLEDGE_STDIO,
	[SYS_sigaction] = PLEDGE_STDIO,
	[SYS_sigreturn] = PLEDGE_STDIO,
	[SYS_sigpending] = PLEDGE_STDIO,
	[SYS_getitimer] = PLEDGE_STDIO,
	[SYS_setitimer] = PLEDGE_STDIO,

	/*
	 * To support event driven programming.
	 */
	[SYS_poll] = PLEDGE_STDIO,
	[SYS_ppoll] = PLEDGE_STDIO,
	[SYS_kevent] = PLEDGE_STDIO,
	[SYS_kqueue] = PLEDGE_STDIO,
	[SYS_select] = PLEDGE_STDIO,
	[SYS_pselect] = PLEDGE_STDIO,

	[SYS_fstat] = PLEDGE_STDIO,
	[SYS_fsync] = PLEDGE_STDIO,

	[SYS_setsockopt] = PLEDGE_STDIO,	/* narrow whitelist */
	[SYS_getsockopt] = PLEDGE_STDIO,	/* narrow whitelist */

	/* F_SETOWN requires PLEDGE_PROC */
	[SYS_fcntl] = PLEDGE_STDIO,

	[SYS_close] = PLEDGE_STDIO,
	[SYS_dup] = PLEDGE_STDIO,
	[SYS_dup2] = PLEDGE_STDIO,
	[SYS_dup3] = PLEDGE_STDIO,
	[SYS_closefrom] = PLEDGE_STDIO,
	[SYS_shutdown] = PLEDGE_STDIO,
	[SYS_fchdir] = PLEDGE_STDIO,	/* XXX consider tightening */

	[SYS_pipe] = PLEDGE_STDIO,
	[SYS_pipe2] = PLEDGE_STDIO,
	[SYS_socketpair] = PLEDGE_STDIO,

	[SYS_wait4] = PLEDGE_STDIO,

	/*
	 * Can kill self with "stdio".  Killing another pid
	 * requires "proc"
	 */
	[SYS_kill] = PLEDGE_STDIO,

	/*
	 * FIONREAD/FIONBIO for "stdio"
	 * Other ioctl are selectively allowed based upon other pledges.
	 */
	[SYS_ioctl] = PLEDGE_STDIO,

	/*
	 * Path access/creation calls encounter many extensive
	 * checks are done during namei()
	 */
	[SYS_open] = PLEDGE_STDIO,
	[SYS_stat] = PLEDGE_STDIO,
	[SYS_access] = PLEDGE_STDIO,
	[SYS_readlink] = PLEDGE_STDIO,

	[SYS_adjtime] = PLEDGE_STDIO,   /* setting requires "settime" */
	[SYS_adjfreq] = PLEDGE_SETTIME,
	[SYS_settimeofday] = PLEDGE_SETTIME,

	/*
	 * Needed by threaded programs
	 * XXX should we have a new "threads"?
	 */
	[SYS___tfork] = PLEDGE_STDIO,
	[SYS_sched_yield] = PLEDGE_STDIO,
	[SYS_futex] = PLEDGE_STDIO,
	[SYS___thrsleep] = PLEDGE_STDIO,
	[SYS___thrwakeup] = PLEDGE_STDIO,
	[SYS___threxit] = PLEDGE_STDIO,
	[SYS___thrsigdivert] = PLEDGE_STDIO,

	[SYS_fork] = PLEDGE_PROC,
	[SYS_vfork] = PLEDGE_PROC,
	[SYS_setpgid] = PLEDGE_PROC,
	[SYS_setsid] = PLEDGE_PROC,

	[SYS_setrlimit] = PLEDGE_PROC | PLEDGE_ID,
	[SYS_getpriority] = PLEDGE_PROC | PLEDGE_ID,

	[SYS_setpriority] = PLEDGE_PROC | PLEDGE_ID,

	[SYS_setuid] = PLEDGE_ID,
	[SYS_seteuid] = PLEDGE_ID,
	[SYS_setreuid] = PLEDGE_ID,
	[SYS_setresuid] = PLEDGE_ID,
	[SYS_setgid] = PLEDGE_ID,
	[SYS_setegid] = PLEDGE_ID,
	[SYS_setregid] = PLEDGE_ID,
	[SYS_setresgid] = PLEDGE_ID,
	[SYS_setgroups] = PLEDGE_ID,
	[SYS_setlogin] = PLEDGE_ID,

	[SYS_execve] = PLEDGE_EXEC,

	[SYS_chdir] = PLEDGE_RPATH,
	[SYS_openat] = PLEDGE_RPATH | PLEDGE_WPATH,
	[SYS_fstatat] = PLEDGE_RPATH | PLEDGE_WPATH,
	[SYS_faccessat] = PLEDGE_RPATH | PLEDGE_WPATH,
	[SYS_readlinkat] = PLEDGE_RPATH | PLEDGE_WPATH,
	[SYS_lstat] = PLEDGE_RPATH | PLEDGE_WPATH | PLEDGE_TMPPATH,
	[SYS_truncate] = PLEDGE_WPATH,
	[SYS_rename] = PLEDGE_RPATH | PLEDGE_CPATH,
	[SYS_rmdir] = PLEDGE_CPATH,
	[SYS_renameat] = PLEDGE_CPATH,
	[SYS_link] = PLEDGE_CPATH,
	[SYS_linkat] = PLEDGE_CPATH,
	[SYS_symlink] = PLEDGE_CPATH,
	[SYS_symlinkat] = PLEDGE_CPATH,
	[SYS_unlink] = PLEDGE_CPATH | PLEDGE_TMPPATH,
	[SYS_unlinkat] = PLEDGE_CPATH,
	[SYS_mkdir] = PLEDGE_CPATH,
	[SYS_mkdirat] = PLEDGE_CPATH,

	[SYS_mkfifo] = PLEDGE_DPATH,
	[SYS_mknod] = PLEDGE_DPATH,

	[SYS_revoke] = PLEDGE_TTY,	/* also requires PLEDGE_RPATH */

	/*
	 * Classify as RPATH|WPATH, because of path information leakage.
	 * WPATH due to unknown use of mk*temp(3) on non-/tmp paths..
	 */
	[SYS___getcwd] = PLEDGE_RPATH | PLEDGE_WPATH,

	/* Classify as RPATH, because these leak path information */
	[SYS_getdents] = PLEDGE_RPATH,
	[SYS_getfsstat] = PLEDGE_RPATH,
	[SYS_statfs] = PLEDGE_RPATH,
	[SYS_fstatfs] = PLEDGE_RPATH,
	[SYS_pathconf] = PLEDGE_RPATH,

	[SYS_utimes] = PLEDGE_FATTR,
	[SYS_futimes] = PLEDGE_FATTR,
	[SYS_utimensat] = PLEDGE_FATTR,
	[SYS_futimens] = PLEDGE_FATTR,
	[SYS_chmod] = PLEDGE_FATTR,
	[SYS_fchmod] = PLEDGE_FATTR,
	[SYS_fchmodat] = PLEDGE_FATTR,
	[SYS_chflags] = PLEDGE_FATTR,
	[SYS_chflagsat] = PLEDGE_FATTR,
	[SYS_fchflags] = PLEDGE_FATTR,

	[SYS_chown] = PLEDGE_CHOWN,
	[SYS_fchownat] = PLEDGE_CHOWN,
	[SYS_lchown] = PLEDGE_CHOWN,
	[SYS_fchown] = PLEDGE_CHOWN,

	[SYS_socket] = PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS | PLEDGE_YPACTIVE,
	[SYS_connect] = PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS | PLEDGE_YPACTIVE,
	[SYS_bind] = PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS | PLEDGE_YPACTIVE,
	[SYS_getsockname] = PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS | PLEDGE_YPACTIVE,

	[SYS_listen] = PLEDGE_INET | PLEDGE_UNIX,
	[SYS_accept4] = PLEDGE_INET | PLEDGE_UNIX,
	[SYS_accept] = PLEDGE_INET | PLEDGE_UNIX,
	[SYS_getpeername] = PLEDGE_INET | PLEDGE_UNIX,

	[SYS_flock] = PLEDGE_FLOCK | PLEDGE_YPACTIVE,

	[SYS_swapctl] = PLEDGE_VMINFO,	/* XXX should limit to "get" operations */
};

static const struct {
	char *name;
	uint64_t flags;
} pledgereq[] = {
	{ "audio",		PLEDGE_AUDIO },
	{ "bpf",		PLEDGE_BPF },
	{ "chown",		PLEDGE_CHOWN | PLEDGE_CHOWNUID },
	{ "cpath",		PLEDGE_CPATH },
	{ "disklabel",		PLEDGE_DISKLABEL },
	{ "dns",		PLEDGE_DNS },
	{ "dpath",		PLEDGE_DPATH },
	{ "drm",		PLEDGE_DRM },
	{ "exec",		PLEDGE_EXEC },
	{ "fattr",		PLEDGE_FATTR | PLEDGE_CHOWN },
	{ "flock",		PLEDGE_FLOCK },
	{ "getpw",		PLEDGE_GETPW },
	{ "id",			PLEDGE_ID },
	{ "inet",		PLEDGE_INET },
	{ "mcast",		PLEDGE_MCAST },
	{ "pf",			PLEDGE_PF },
	{ "proc",		PLEDGE_PROC },
	{ "prot_exec",		PLEDGE_PROTEXEC },
	{ "ps",			PLEDGE_PS },
	{ "recvfd",		PLEDGE_RECVFD },
	{ "route",		PLEDGE_ROUTE },
	{ "rpath",		PLEDGE_RPATH },
	{ "sendfd",		PLEDGE_SENDFD },
	{ "settime",		PLEDGE_SETTIME },
	{ "stdio",		PLEDGE_STDIO },
	{ "tape",		PLEDGE_TAPE },
	{ "tmppath",		PLEDGE_TMPPATH },
	{ "tty",		PLEDGE_TTY },
	{ "unix",		PLEDGE_UNIX },
	{ "vminfo",		PLEDGE_VMINFO },
	{ "vmm",		PLEDGE_VMM },
	{ "wpath",		PLEDGE_WPATH },
};

int
sys_pledge(struct proc *p, void *v, register_t *retval)
{
	struct sys_pledge_args /* {
		syscallarg(const char *)request;
		syscallarg(const char **)paths;
	} */	*uap = v;
	struct process *pr = p->p_p;
	uint64_t flags = 0;
	int error;

	if (SCARG(uap, request)) {
		size_t rbuflen;
		char *rbuf, *rp, *pn;
		uint64_t f;

		rbuf = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
		error = copyinstr(SCARG(uap, request), rbuf, MAXPATHLEN,
		    &rbuflen);
		if (error) {
			free(rbuf, M_TEMP, MAXPATHLEN);
			return (error);
		}
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrstruct(p, "pledgereq", rbuf, rbuflen-1);
#endif

		for (rp = rbuf; rp && *rp && error == 0; rp = pn) {
			pn = strchr(rp, ' ');	/* find terminator */
			if (pn) {
				while (*pn == ' ')
					*pn++ = '\0';
			}

			if ((f = pledgereq_flags(rp)) == 0) {
				free(rbuf, M_TEMP, MAXPATHLEN);
				return (EINVAL);
			}
			flags |= f;
		}
		free(rbuf, M_TEMP, MAXPATHLEN);

		/*
		 * if we are already pledged, allow only promises reductions.
		 * flags doesn't contain flags outside _USERSET: they will be
		 * relearned.
		 */
		if (ISSET(pr->ps_flags, PS_PLEDGE) &&
		    (((flags | pr->ps_pledge) != pr->ps_pledge)))
			return (EPERM);
	}

	if (SCARG(uap, paths))
		return (EINVAL);

	if (SCARG(uap, request)) {
		pr->ps_pledge = flags;
		pr->ps_flags |= PS_PLEDGE;
	}

	return (0);
}

int
pledge_syscall(struct proc *p, int code, uint64_t *tval)
{
	p->p_pledge_syscall = code;
	*tval = 0;

	if (code < 0 || code > SYS_MAXSYSCALL - 1)
		return (EINVAL);

	if (pledge_syscalls[code] == PLEDGE_ALWAYS)
		return (0);

	if (p->p_p->ps_pledge & pledge_syscalls[code])
		return (0);

	*tval = pledge_syscalls[code];
	return (EPERM);
}

int
pledge_fail(struct proc *p, int error, uint64_t code)
{
	char *codes = "";
	int i;
	struct sigaction sa;

	/* Print first matching pledge */
	for (i = 0; code && pledgenames[i].bits != 0; i++)
		if (pledgenames[i].bits & code) {
			codes = pledgenames[i].name;
			break;
		}
	log(LOG_ERR, "%s(%d): syscall %d \"%s\"\n",
	    p->p_p->ps_comm, p->p_p->ps_pid, p->p_pledge_syscall, codes);
	p->p_p->ps_acflag |= APLEDGE;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_PLEDGE))
		ktrpledge(p, error, code, p->p_pledge_syscall);
#endif
	/* Send uncatchable SIGABRT for coredump */
	memset(&sa, 0, sizeof sa);
	sa.sa_handler = SIG_DFL;
	setsigvec(p, SIGABRT, &sa);
	psignal(p, SIGABRT);

	p->p_p->ps_pledge = 0;		/* Disable all PLEDGE_ flags */
	return (error);
}

/*
 * Need to make it more obvious that one cannot get through here
 * without the right flags set
 */
int
pledge_namei(struct proc *p, struct nameidata *ni, char *origpath)
{
	char path[PATH_MAX];
	int error;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0 ||
	    (p->p_p->ps_flags & PS_COREDUMP))
		return (0);

	if (!ni || (ni->ni_pledge == 0))
		panic("ni_pledge");

	/* Doing a permitted execve() */
	if ((ni->ni_pledge & PLEDGE_EXEC) &&
	    (p->p_p->ps_pledge & PLEDGE_EXEC))
		return (0);

	error = canonpath(origpath, path, sizeof(path));
	if (error)
		return (error);

	/* Detect what looks like a mkstemp(3) family operation */
	if ((p->p_p->ps_pledge & PLEDGE_TMPPATH) &&
	    (p->p_pledge_syscall == SYS_open) &&
	    (ni->ni_pledge & PLEDGE_CPATH) &&
	    strncmp(path, "/tmp/", sizeof("/tmp/") - 1) == 0) {
		return (0);
	}

	/* Allow unlinking of a mkstemp(3) file...
	 * Good opportunity for strict checks here.
	 */
	if ((p->p_p->ps_pledge & PLEDGE_TMPPATH) &&
	    (p->p_pledge_syscall == SYS_unlink) &&
	    strncmp(path, "/tmp/", sizeof("/tmp/") - 1) == 0) {
		return (0);
	}

	/* Whitelisted paths */
	switch (p->p_pledge_syscall) {
	case SYS_access:
		/* tzset() needs this. */
		if ((ni->ni_pledge == PLEDGE_RPATH) &&
		    strcmp(path, "/etc/localtime") == 0)
			return (0);

		/* when avoiding YP mode, getpw* functions touch this */
		if (ni->ni_pledge == PLEDGE_RPATH &&
		    strcmp(path, "/var/run/ypbind.lock") == 0) {
			if (p->p_p->ps_pledge & PLEDGE_GETPW)
				return (0);
			else
				return (pledge_fail(p, error, PLEDGE_GETPW));
		}
		break;
	case SYS_open:
		/* daemon(3) or other such functions */
		if ((ni->ni_pledge & ~(PLEDGE_RPATH | PLEDGE_WPATH)) == 0 &&
		    strcmp(path, "/dev/null") == 0) {
			return (0);
		}

		/* readpassphrase(3), getpass(3) */
		if ((p->p_p->ps_pledge & PLEDGE_TTY) &&
		    (ni->ni_pledge & ~(PLEDGE_RPATH | PLEDGE_WPATH)) == 0 &&
		    strcmp(path, "/dev/tty") == 0) {
			return (0);
		}

		/* getpw* and friends need a few files */
		if ((ni->ni_pledge == PLEDGE_RPATH) &&
		    (p->p_p->ps_pledge & PLEDGE_GETPW)) {
			if (strcmp(path, "/etc/spwd.db") == 0)
				return (EPERM); /* don't call pledge_fail */
			if (strcmp(path, "/etc/pwd.db") == 0)
				return (0);
			if (strcmp(path, "/etc/group") == 0)
				return (0);
			if (strcmp(path, "/etc/netid") == 0)
				return (0);
		}

		/* DNS needs /etc/{resolv.conf,hosts,services}. */
		if ((ni->ni_pledge == PLEDGE_RPATH) &&
		    (p->p_p->ps_pledge & PLEDGE_DNS)) {
			if (strcmp(path, "/etc/resolv.conf") == 0)
				return (0);
			if (strcmp(path, "/etc/hosts") == 0)
				return (0);
			if (strcmp(path, "/etc/services") == 0)
				return (0);
		}

		if ((ni->ni_pledge == PLEDGE_RPATH) &&
		    (p->p_p->ps_pledge & PLEDGE_GETPW)) {
			if (strcmp(path, "/var/run/ypbind.lock") == 0) {
				/*
				 * XXX
				 * The current hack for YP support in "getpw"
				 * is to enable some "inet" features until
				 * next pledge call.  This is not considered
				 * worse than pre-pledge, but is a work in
				 * progress, needing a clever design.
				 */
				p->p_p->ps_pledge |= PLEDGE_YPACTIVE;
				return (0);
			}
			if (strncmp(path, "/var/yp/binding/",
			    sizeof("/var/yp/binding/") - 1) == 0)
				return (0);
		}

		/* tzset() needs these. */
		if ((ni->ni_pledge == PLEDGE_RPATH) &&
		    strncmp(path, "/usr/share/zoneinfo/",
		    sizeof("/usr/share/zoneinfo/") - 1) == 0)
			return (0);
		if ((ni->ni_pledge == PLEDGE_RPATH) &&
		    strcmp(path, "/etc/localtime") == 0)
			return (0);

		break;
	case SYS_readlink:
		/* Allow /etc/malloc.conf for malloc(3). */
		if ((ni->ni_pledge == PLEDGE_RPATH) &&
		    strcmp(path, "/etc/malloc.conf") == 0)
			return (0);
		break;
	case SYS_stat:
		/* DNS needs /etc/resolv.conf. */
		if ((ni->ni_pledge == PLEDGE_RPATH) &&
		    (p->p_p->ps_pledge & PLEDGE_DNS) &&
		    strcmp(path, "/etc/resolv.conf") == 0)
			return (0);
		break;
	}

	/*
	 * Ensure each flag of p_pledgenote has counterpart allowing it in
	 * ps_pledge
	 */
	if (ni->ni_pledge & ~p->p_p->ps_pledge)
		return (pledge_fail(p, EPERM, (ni->ni_pledge & ~p->p_p->ps_pledge)));

	return (0);
}

/*
 * Only allow reception of safe file descriptors.
 */
int
pledge_recvfd(struct proc *p, struct file *fp)
{
	struct vnode *vp;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);
	if ((p->p_p->ps_pledge & PLEDGE_RECVFD) == 0)
		return pledge_fail(p, EPERM, PLEDGE_RECVFD);

	switch (fp->f_type) {
	case DTYPE_SOCKET:
	case DTYPE_PIPE:
		return (0);
	case DTYPE_VNODE:
		vp = fp->f_data;

		if (vp->v_type != VDIR)
			return (0);
		break;
	}
	return pledge_fail(p, EINVAL, PLEDGE_RECVFD);
}

/*
 * Only allow sending of safe file descriptors.
 */
int
pledge_sendfd(struct proc *p, struct file *fp)
{
	struct vnode *vp;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);
	if ((p->p_p->ps_pledge & PLEDGE_SENDFD) == 0)
		return pledge_fail(p, EPERM, PLEDGE_SENDFD);

	switch (fp->f_type) {
	case DTYPE_SOCKET:
	case DTYPE_PIPE:
		return (0);
	case DTYPE_VNODE:
		vp = fp->f_data;

		if (vp->v_type != VDIR)
			return (0);
		break;
	}
	return pledge_fail(p, EINVAL, PLEDGE_SENDFD);
}

int
pledge_sysctl(struct proc *p, int miblen, int *mib, void *new)
{
	char	buf[80];
	int	i;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if (new)
		return pledge_fail(p, EFAULT, 0);

	/* routing table observation */
	if ((p->p_p->ps_pledge & PLEDGE_ROUTE)) {
		if ((miblen == 6 || miblen == 7) &&
		    mib[0] == CTL_NET && mib[1] == PF_ROUTE &&
		    mib[2] == 0 &&
		    mib[4] == NET_RT_DUMP)
			return (0);

		if (miblen == 6 &&
		    mib[0] == CTL_NET && mib[1] == PF_ROUTE &&
		    mib[2] == 0 &&
		    (mib[3] == 0 || mib[3] == AF_INET6 || mib[3] == AF_INET) &&
		    mib[4] == NET_RT_TABLE)
			return (0);

		if (miblen == 7 &&		/* exposes MACs */
		    mib[0] == CTL_NET && mib[1] == PF_ROUTE &&
		    mib[2] == 0 &&
		    (mib[3] == 0 || mib[3] == AF_INET6 || mib[3] == AF_INET) &&
		    mib[4] == NET_RT_FLAGS && mib[5] == RTF_LLINFO)
			return (0);
	}

	if (p->p_p->ps_pledge & (PLEDGE_PS | PLEDGE_VMINFO)) {
		if (miblen == 2 &&		/* kern.fscale */
		    mib[0] == CTL_KERN && mib[1] == KERN_FSCALE)
			return (0);
		if (miblen == 2 &&		/* kern.boottime */
		    mib[0] == CTL_KERN && mib[1] == KERN_BOOTTIME)
			return (0);
		if (miblen == 2 &&		/* kern.consdev */
		    mib[0] == CTL_KERN && mib[1] == KERN_CONSDEV)
			return (0);
		if (miblen == 2 &&			/* kern.cptime */
		    mib[0] == CTL_KERN && mib[1] == KERN_CPTIME)
			return (0);
		if (miblen == 3 &&			/* kern.cptime2 */
		    mib[0] == CTL_KERN && mib[1] == KERN_CPTIME2)
			return (0);
	}

	if ((p->p_p->ps_pledge & PLEDGE_PS)) {
		if (miblen == 4 &&		/* kern.procargs.* */
		    mib[0] == CTL_KERN && mib[1] == KERN_PROC_ARGS &&
		    (mib[3] == KERN_PROC_ARGV || mib[3] == KERN_PROC_ENV))
			return (0);
		if (miblen == 6 &&		/* kern.proc.* */
		    mib[0] == CTL_KERN && mib[1] == KERN_PROC)
			return (0);
		if (miblen == 3 &&		/* kern.proc_cwd.* */
		    mib[0] == CTL_KERN && mib[1] == KERN_PROC_CWD)
			return (0);
		if (miblen == 2 &&		/* hw.physmem */
		    mib[0] == CTL_HW && mib[1] == HW_PHYSMEM64)
			return (0);
		if (miblen == 2 &&		/* kern.ccpu */
		    mib[0] == CTL_KERN && mib[1] == KERN_CCPU)
			return (0);
		if (miblen == 2 &&		/* vm.maxslp */
		    mib[0] == CTL_VM && mib[1] == VM_MAXSLP)
			return (0);
	}

	if ((p->p_p->ps_pledge & PLEDGE_VMINFO)) {
		if (miblen == 2 &&		/* vm.uvmexp */
		    mib[0] == CTL_VM && mib[1] == VM_UVMEXP)
			return (0);
		if (miblen == 3 &&		/* vfs.generic.bcachestat */
		    mib[0] == CTL_VFS && mib[1] == VFS_GENERIC &&
		    mib[2] == VFS_BCACHESTAT)
			return (0);
	}

	if ((p->p_p->ps_pledge & (PLEDGE_ROUTE | PLEDGE_INET | PLEDGE_DNS))) {
		if (miblen == 6 &&		/* getifaddrs() */
		    mib[0] == CTL_NET && mib[1] == PF_ROUTE &&
		    mib[2] == 0 &&
		    (mib[3] == 0 || mib[3] == AF_INET6 || mib[3] == AF_INET) &&
		    mib[4] == NET_RT_IFLIST)
			return (0);
	}

	if ((p->p_p->ps_pledge & PLEDGE_DISKLABEL)) {
		if (miblen == 2 &&		/* kern.rawpartition */
		    mib[0] == CTL_KERN &&
		    mib[1] == KERN_RAWPARTITION)
			return (0);
		if (miblen == 2 &&		/* kern.maxpartitions */
		    mib[0] == CTL_KERN &&
		    mib[1] == KERN_MAXPARTITIONS)
			return (0);
#ifdef CPU_CHR2BLK
		if (miblen == 3 &&		/* machdep.chr2blk */
		    mib[0] == CTL_MACHDEP &&
		    mib[1] == CPU_CHR2BLK)
			return (0);
#endif /* CPU_CHR2BLK */
	}

	if (miblen >= 3 &&			/* ntpd(8) to read sensors */
	    mib[0] == CTL_HW && mib[1] == HW_SENSORS)
		return (0);

	if (miblen == 2 &&		/* getdomainname() */
	    mib[0] == CTL_KERN && mib[1] == KERN_DOMAINNAME)
		return (0);
	if (miblen == 2 &&		/* gethostname() */
	    mib[0] == CTL_KERN && mib[1] == KERN_HOSTNAME)
		return (0);
	if (miblen == 6 &&		/* if_nameindex() */
	    mib[0] == CTL_NET && mib[1] == PF_ROUTE &&
	    mib[2] == 0 && mib[3] == 0 && mib[4] == NET_RT_IFNAMES)
		return (0);
	if (miblen == 2 &&		/* uname() */
	    mib[0] == CTL_KERN && mib[1] == KERN_OSTYPE)
		return (0);
	if (miblen == 2 &&		/* uname() */
	    mib[0] == CTL_KERN && mib[1] == KERN_OSRELEASE)
		return (0);
	if (miblen == 2 &&		/* uname() */
	    mib[0] == CTL_KERN && mib[1] == KERN_OSVERSION)
		return (0);
	if (miblen == 2 &&		/* uname() */
	    mib[0] == CTL_KERN && mib[1] == KERN_VERSION)
		return (0);
	if (miblen == 2 &&		/* kern.clockrate */
	    mib[0] == CTL_KERN && mib[1] == KERN_CLOCKRATE)
		return (0);
	if (miblen == 2 &&		/* kern.argmax */
	    mib[0] == CTL_KERN && mib[1] == KERN_ARGMAX)
		return (0);
	if (miblen == 2 &&		/* kern.ngroups */
	    mib[0] == CTL_KERN && mib[1] == KERN_NGROUPS)
		return (0);
	if (miblen == 2 &&		/* kern.sysvshm */
	    mib[0] == CTL_KERN && mib[1] == KERN_SYSVSHM)
		return (0);
	if (miblen == 2 &&		/* kern.posix1version */
	    mib[0] == CTL_KERN && mib[1] == KERN_POSIX1)
		return (0);
	if (miblen == 2 &&		/* uname() */
	    mib[0] == CTL_HW && mib[1] == HW_MACHINE)
		return (0);
	if (miblen == 2 &&		/* getpagesize() */
	    mib[0] == CTL_HW && mib[1] == HW_PAGESIZE)
		return (0);
	if (miblen == 2 &&		/* setproctitle() */
	    mib[0] == CTL_VM && mib[1] == VM_PSSTRINGS)
		return (0);
	if (miblen == 2 &&		/* hw.ncpu */
	    mib[0] == CTL_HW && mib[1] == HW_NCPU)
		return (0);
	if (miblen == 2 &&		/* vm.loadavg / getloadavg(3) */
	    mib[0] == CTL_VM && mib[1] == VM_LOADAVG)
		return (0);

	snprintf(buf, sizeof(buf), "%s(%d): sysctl %d:",
	    p->p_p->ps_comm, p->p_p->ps_pid, miblen);
	for (i = 0; i < miblen; i++) {
		char *p = buf + strlen(buf);
		snprintf(p, sizeof(buf) - (p - buf), " %d", mib[i]);
	}
	log(LOG_ERR, "%s\n", buf);

	return pledge_fail(p, EINVAL, 0);
}

int
pledge_chown(struct proc *p, uid_t uid, gid_t gid)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if (p->p_p->ps_pledge & PLEDGE_CHOWNUID)
		return (0);

	if (uid != -1 && uid != p->p_ucred->cr_uid)
		return (EPERM);
	if (gid != -1 && !groupmember(gid, p->p_ucred))
		return (EPERM);
	return (0);
}

int
pledge_adjtime(struct proc *p, const void *v)
{
	const struct timeval *delta = v;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if ((p->p_p->ps_pledge & PLEDGE_SETTIME))
		return (0);
	if (delta)
		return (EPERM);
	return (0);
}

int
pledge_sendit(struct proc *p, const void *to)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if ((p->p_p->ps_pledge & (PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS | PLEDGE_YPACTIVE)))
		return (0);		/* may use address */
	if (to == NULL)
		return (0);		/* behaves just like write */
	return pledge_fail(p, EPERM, PLEDGE_INET);
}

int
pledge_ioctl(struct proc *p, long com, struct file *fp)
{
	struct vnode *vp = NULL;
	int error = EPERM;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	/*
	 * The ioctl's which are always allowed.
	 */
	switch (com) {
	case FIONREAD:
	case FIONBIO:
	case FIOCLEX:
	case FIONCLEX:
		return (0);
	}

	/* fp != NULL was already checked */
	if (fp->f_type == DTYPE_VNODE) {
		vp = fp->f_data;
		if (vp->v_type == VBAD)
			return (ENOTTY);
	}

	if ((p->p_p->ps_pledge & PLEDGE_INET)) {
		switch (com) {
		case SIOCATMARK:
		case SIOCGIFGROUP:
			if (fp->f_type == DTYPE_SOCKET)
				return (0);
			break;
		}
	}

#if NBPFILTER > 0
	if ((p->p_p->ps_pledge & PLEDGE_BPF)) {
		switch (com) {
		case BIOCGSTATS:	/* bpf: tcpdump privsep on ^C */
			if (fp->f_type == DTYPE_VNODE &&
			    fp->f_ops->fo_ioctl == vn_ioctl &&
			    vp->v_type == VCHR &&
			    cdevsw[major(vp->v_rdev)].d_open == bpfopen)
				return (0);
			break;
		}
	}
#endif /* NBPFILTER > 0 */

	if ((p->p_p->ps_pledge & PLEDGE_TAPE)) {
		switch (com) {
		case MTIOCGET:
		case MTIOCTOP:
			/* for pax(1) and such, checking tapes... */
			if (fp->f_type == DTYPE_VNODE &&
			    vp->v_type == VCHR) {
				if (vp->v_flag & VISTTY)
					return (ENOTTY);
				else
					return (0);
			}
			break;
		}
	}

#if NDRM > 0
	if ((p->p_p->ps_pledge & PLEDGE_DRM)) {
		if ((fp->f_type == DTYPE_VNODE) &&
		    (vp->v_type == VCHR) &&
		    (cdevsw[major(vp->v_rdev)].d_open == drmopen)) {
			error = pledge_ioctl_drm(p, com, vp->v_rdev);
			if (error == 0)
				return 0;
		}
	}
#endif /* NDRM > 0 */

#if NAUDIO > 0
	if ((p->p_p->ps_pledge & PLEDGE_AUDIO)) {
		switch (com) {
		case AUDIO_GETPOS:
		case AUDIO_GETPAR:
		case AUDIO_SETPAR:
		case AUDIO_START:
		case AUDIO_STOP:
			if (fp->f_type == DTYPE_VNODE &&
			    vp->v_type == VCHR &&
			    cdevsw[major(vp->v_rdev)].d_open == audioopen)
				return (0);
		}
	}
#endif /* NAUDIO > 0 */

	if ((p->p_p->ps_pledge & PLEDGE_DISKLABEL)) {
		switch (com) {
		case DIOCGDINFO:
		case DIOCGPDINFO:
		case DIOCRLDINFO:
		case DIOCWDINFO:
		case BIOCDISK:
		case BIOCINQ:
		case BIOCINSTALLBOOT:
		case BIOCVOL:
			if (fp->f_type == DTYPE_VNODE &&
			    ((vp->v_type == VCHR &&
			    cdevsw[major(vp->v_rdev)].d_type == D_DISK) ||
			    (vp->v_type == VBLK &&
			    bdevsw[major(vp->v_rdev)].d_type == D_DISK)))
				return (0);
			break;
		case DIOCMAP:
			if (fp->f_type == DTYPE_VNODE &&
			    vp->v_type == VCHR &&
			    cdevsw[major(vp->v_rdev)].d_ioctl == diskmapioctl)
				return (0);
			break;
		}
	}

#if NPF > 0
	if ((p->p_p->ps_pledge & PLEDGE_PF)) {
		switch (com) {
		case DIOCADDRULE:
		case DIOCGETSTATUS:
		case DIOCNATLOOK:
		case DIOCRADDTABLES:
		case DIOCRCLRADDRS:
		case DIOCRCLRTABLES:
		case DIOCRCLRTSTATS:
		case DIOCRGETTSTATS:
		case DIOCRSETADDRS:
		case DIOCXBEGIN:
		case DIOCXCOMMIT:
		case DIOCKILLSRCNODES:
			if ((fp->f_type == DTYPE_VNODE) &&
			    (vp->v_type == VCHR) &&
			    (cdevsw[major(vp->v_rdev)].d_open == pfopen))
				return (0);
			break;
		}
	}
#endif

	if ((p->p_p->ps_pledge & PLEDGE_TTY)) {
		switch (com) {
#if NPTY > 0
		case PTMGET:
			if ((p->p_p->ps_pledge & PLEDGE_RPATH) == 0)
				break;
			if ((p->p_p->ps_pledge & PLEDGE_WPATH) == 0)
				break;
			if (fp->f_type != DTYPE_VNODE || vp->v_type != VCHR)
				break;
			if (cdevsw[major(vp->v_rdev)].d_open != ptmopen)
				break;
			return (0);
#endif /* NPTY > 0 */
		case TIOCSPGRP:
			if ((p->p_p->ps_pledge & PLEDGE_PROC) == 0)
				break;
			/* FALLTHROUGH */
		case TIOCFLUSH:		/* getty, telnet */
		case TIOCGPGRP:
		case TIOCGETA:
		case TIOCGWINSZ:	/* ENOTTY return for non-tty */
		case TIOCSTAT:		/* csh */
			if (fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
				return (0);
			return (ENOTTY);
		case TIOCSWINSZ:
		case TIOCEXT:		/* mail, libedit .. */
		case TIOCCBRK:		/* cu */
		case TIOCSBRK:		/* cu */
		case TIOCCDTR:		/* cu */
		case TIOCSDTR:		/* cu */
		case TIOCEXCL:		/* cu */
		case TIOCSETA:		/* cu, ... */
		case TIOCSETAW:		/* cu, ... */
		case TIOCSETAF:		/* tcsetattr TCSAFLUSH, script */
		case TIOCSCTTY:		/* forkpty(3), login_tty(3), ... */
			if (fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
				return (0);
			break;
		}
	}

	if ((p->p_p->ps_pledge & PLEDGE_ROUTE)) {
		switch (com) {
		case SIOCGIFADDR:
		case SIOCGIFAFLAG_IN6:
		case SIOCGIFALIFETIME_IN6:
		case SIOCGIFDESCR:
		case SIOCGIFFLAGS:
		case SIOCGIFMETRIC:
		case SIOCGIFGMEMB:
		case SIOCGIFRDOMAIN:
		case SIOCGIFDSTADDR_IN6:
		case SIOCGIFNETMASK_IN6:
		case SIOCGIFXFLAGS:
		case SIOCGNBRINFO_IN6:
		case SIOCGIFINFO_IN6:
		case SIOCGIFMEDIA:
			if (fp->f_type == DTYPE_SOCKET)
				return (0);
			break;
		}
	}

#if NVMM > 0
	if ((p->p_p->ps_pledge & PLEDGE_VMM)) {
		if ((fp->f_type == DTYPE_VNODE) &&
		    (vp->v_type == VCHR) &&
		    (cdevsw[major(vp->v_rdev)].d_open == vmmopen)) {
			error = pledge_ioctl_vmm(p, com);
			if (error == 0)
				return 0;
		}
	}
#endif

	return pledge_fail(p, error, PLEDGE_TTY);
}

int
pledge_sockopt(struct proc *p, int set, int level, int optname)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	/* Always allow these, which are too common to reject */
	switch (level) {
	case SOL_SOCKET:
		switch (optname) {
		case SO_RCVBUF:
		case SO_ERROR:
			return 0;
		}
		break;
	}

	if ((p->p_p->ps_pledge & (PLEDGE_INET|PLEDGE_UNIX|PLEDGE_DNS|PLEDGE_YPACTIVE)) == 0)
		return pledge_fail(p, EPERM, PLEDGE_INET);
	/* In use by some service libraries */
	switch (level) {
	case SOL_SOCKET:
		switch (optname) {
		case SO_TIMESTAMP:
			return 0;
		}
		break;
	}

	/* DNS resolver may do these requests */
	if ((p->p_p->ps_pledge & PLEDGE_DNS)) {
		switch (level) {
		case IPPROTO_IPV6:
			switch (optname) {
			case IPV6_RECVPKTINFO:
			case IPV6_USE_MIN_MTU:
				return (0);
			}
		}
	}

	/* YP may do these requests */
	if (p->p_p->ps_pledge & PLEDGE_YPACTIVE) {
		switch (level) {
		case IPPROTO_IP:
			switch (optname) {
			case IP_PORTRANGE:
				return (0);
			}
			break;

		case IPPROTO_IPV6:
			switch (optname) {
			case IPV6_PORTRANGE:
				return (0);
			}
			break;
		}
	}

	if ((p->p_p->ps_pledge & (PLEDGE_INET|PLEDGE_UNIX)) == 0)
		return pledge_fail(p, EPERM, PLEDGE_INET);
	switch (level) {
	case SOL_SOCKET:
		switch (optname) {
		case SO_RTABLE:
			return pledge_fail(p, EINVAL, PLEDGE_INET);
		}
		return (0);
	}

	if ((p->p_p->ps_pledge & PLEDGE_INET) == 0)
		return pledge_fail(p, EPERM, PLEDGE_INET);
	switch (level) {
	case IPPROTO_TCP:
		switch (optname) {
		case TCP_NODELAY:
		case TCP_MD5SIG:
		case TCP_SACK_ENABLE:
		case TCP_MAXSEG:
		case TCP_NOPUSH:
			return (0);
		}
		break;
	case IPPROTO_IP:
		switch (optname) {
		case IP_OPTIONS:
			if (!set)
				return (0);
			break;
		case IP_TOS:
		case IP_TTL:
		case IP_MINTTL:
		case IP_IPDEFTTL:
		case IP_PORTRANGE:
		case IP_RECVDSTADDR:
		case IP_RECVDSTPORT:
			return (0);
		case IP_MULTICAST_IF:
		case IP_MULTICAST_TTL:
		case IP_MULTICAST_LOOP:
		case IP_ADD_MEMBERSHIP:
		case IP_DROP_MEMBERSHIP:
			if (p->p_p->ps_pledge & PLEDGE_MCAST)
				return (0);
			break;
		}
		break;
	case IPPROTO_ICMP:
		break;
	case IPPROTO_IPV6:
		switch (optname) {
		case IPV6_TCLASS:
		case IPV6_UNICAST_HOPS:
		case IPV6_MINHOPCOUNT:
		case IPV6_RECVHOPLIMIT:
		case IPV6_PORTRANGE:
		case IPV6_RECVPKTINFO:
		case IPV6_RECVDSTPORT:
#ifdef notyet
		case IPV6_V6ONLY:
#endif
			return (0);
		case IPV6_MULTICAST_IF:
		case IPV6_MULTICAST_HOPS:
		case IPV6_MULTICAST_LOOP:
		case IPV6_JOIN_GROUP:
		case IPV6_LEAVE_GROUP:
			if (p->p_p->ps_pledge & PLEDGE_MCAST)
				return (0);
			break;
		}
		break;
	case IPPROTO_ICMPV6:
		break;
	}
	return pledge_fail(p, EPERM, PLEDGE_INET);
}

int
pledge_socket(struct proc *p, int domain, int state)
{
	if (! ISSET(p->p_p->ps_flags, PS_PLEDGE))
		return 0;

	if (ISSET(state, SS_DNS)) {
		if (ISSET(p->p_p->ps_pledge, PLEDGE_DNS))
			return 0;
		return pledge_fail(p, EPERM, PLEDGE_DNS);
	}

	switch (domain) {
	case -1:		/* accept on any domain */
		return (0);
	case AF_INET:
	case AF_INET6:
		if (ISSET(p->p_p->ps_pledge, PLEDGE_INET) ||
		    ISSET(p->p_p->ps_pledge, PLEDGE_YPACTIVE))
			return 0;
		return pledge_fail(p, EPERM, PLEDGE_INET);

	case AF_UNIX:
		if (ISSET(p->p_p->ps_pledge, PLEDGE_UNIX))
			return 0;
		return pledge_fail(p, EPERM, PLEDGE_UNIX);
	}

	return pledge_fail(p, EINVAL, PLEDGE_INET);
}

int
pledge_flock(struct proc *p)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if ((p->p_p->ps_pledge & PLEDGE_FLOCK))
		return (0);
	return (pledge_fail(p, EPERM, PLEDGE_FLOCK));
}

int
pledge_swapctl(struct proc *p)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);
	return (EPERM);
}

/* bsearch over pledgereq. return flags value if found, 0 else */
uint64_t
pledgereq_flags(const char *req_name)
{
	int base = 0, cmp, i, lim;

	for (lim = nitems(pledgereq); lim != 0; lim >>= 1) {
		i = base + (lim >> 1);
		cmp = strcmp(req_name, pledgereq[i].name);
		if (cmp == 0)
			return (pledgereq[i].flags);
		if (cmp > 0) { /* not found before, move right */
			base = i + 1;
			lim--;
		} /* else move left */
	}
	return (0);
}

int
pledge_fcntl(struct proc *p, int cmd)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);
	if ((p->p_p->ps_pledge & PLEDGE_PROC) == 0 && cmd == F_SETOWN)
		return pledge_fail(p, EPERM, PLEDGE_PROC);
	return (0);
}

int
pledge_kill(struct proc *p, pid_t pid)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return 0;
	if (p->p_p->ps_pledge & PLEDGE_PROC)
		return 0;
	if (pid == 0 || pid == p->p_p->ps_pid)
		return 0;
	return pledge_fail(p, EPERM, PLEDGE_PROC);
}

int
pledge_protexec(struct proc *p, int prot)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return 0;
	if (!(p->p_p->ps_pledge & PLEDGE_PROTEXEC) && (prot & PROT_EXEC))
		return pledge_fail(p, EPERM, PLEDGE_PROTEXEC);
	return 0;
}

int
canonpath(const char *input, char *buf, size_t bufsize)
{
	const char *p;
	char *q;

	/* can't canon relative paths, don't bother */
	if (input[0] != '/') {
		if (strlcpy(buf, input, bufsize) >= bufsize)
			return ENAMETOOLONG;
		return 0;
	}

	p = input;
	q = buf;
	while (*p && (q - buf < bufsize)) {
		if (p[0] == '/' && (p[1] == '/' || p[1] == '\0')) {
			p += 1;

		} else if (p[0] == '/' && p[1] == '.' &&
		    (p[2] == '/' || p[2] == '\0')) {
			p += 2;

		} else if (p[0] == '/' && p[1] == '.' && p[2] == '.' &&
		    (p[3] == '/' || p[3] == '\0')) {
			p += 3;
			if (q != buf)	/* "/../" at start of buf */
				while (*--q != '/')
					continue;

		} else {
			*q++ = *p++;
		}
	}
	if ((*p == '\0') && (q - buf < bufsize)) {
		*q = 0;
		return 0;
	} else
		return ENAMETOOLONG;
}
@


1.219
log
@Remove old deactivated pledge path code.  A replacement mechanism is
being brewed.
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.218 2017/08/21 14:40:07 florian Exp $	*/
a20 1
#include <sys/types.h>
@


1.218
log
@Allow SIOCGIFAFLAG_IN6 and SIOCGIFALIFETIME_IN6 ioctls with
pledge("route"). These are read only and expose only minimal kernel
code.

slaacd(8) needs this on startup and when an interface gains the
autoconf6 flag to get lifetime and autoconf information about already
configured addresses.

OK deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.217 2017/07/28 02:14:56 rob Exp $	*/
a88 4
int substrcmp(const char *p1, size_t s1, const char *p2, size_t s2);
int resolvpath(struct proc *p, char **rdir, size_t *rdirlen, char **cwd,
    size_t *cwdlen, char *path, size_t pathlen, char **resolved,
    size_t *resolvedlen);
d449 1
a449 2
	if (SCARG(uap, paths)) {
#if 1
a450 87
#else
		const char **u = SCARG(uap, paths), *sp;
		struct whitepaths *wl;
		char *path, *rdir = NULL, *cwd = NULL;
		size_t pathlen, rdirlen, cwdlen;

		size_t maxargs = 0;
		int i, error;

		if (pr->ps_pledgepaths)
			return (EPERM);

		/* Count paths */
		for (i = 0; i < PLEDGE_MAXPATHS; i++) {
			if ((error = copyin(u + i, &sp, sizeof(sp))) != 0)
				return (error);
			if (sp == NULL)
				break;
		}
		if (i == PLEDGE_MAXPATHS)
			return (E2BIG);

		wl = malloc(sizeof *wl + sizeof(struct whitepath) * (i+1),
		    M_TEMP, M_WAITOK | M_ZERO);
		wl->wl_size = sizeof *wl + sizeof(struct whitepath) * (i+1);
		wl->wl_count = i;
		wl->wl_ref = 1;

		path = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);

		/* Copy in */
		for (i = 0; i < wl->wl_count; i++) {
			char *resolved = NULL;
			size_t resolvedlen;

			if ((error = copyin(u + i, &sp, sizeof(sp))) != 0)
				break;
			if (sp == NULL)
				break;
			if ((error = copyinstr(sp, path, MAXPATHLEN, &pathlen)) != 0)
				break;
#ifdef KTRACE
			if (KTRPOINT(p, KTR_STRUCT))
				ktrstruct(p, "pledgepath", path, pathlen-1);
#endif

			error = resolvpath(p, &rdir, &rdirlen, &cwd, &cwdlen,
			    path, pathlen, &resolved, &resolvedlen);

			if (error != 0)
				/* resolved is allocated only if !error */
				break;

			maxargs += resolvedlen;
			if (maxargs > ARG_MAX) {
				error = E2BIG;
				free(resolved, M_TEMP, resolvedlen);
				break;
			}
			wl->wl_paths[i].name = resolved;
			wl->wl_paths[i].len = resolvedlen;
		}
		free(rdir, M_TEMP, rdirlen);
		free(cwd, M_TEMP, cwdlen);
		free(path, M_TEMP, MAXPATHLEN);

		if (error) {
			for (i = 0; i < wl->wl_count; i++)
				free(wl->wl_paths[i].name,
				    M_TEMP, wl->wl_paths[i].len);
			free(wl, M_TEMP, wl->wl_size);
			return (error);
		}
		pr->ps_pledgepaths = wl;

#ifdef DEBUG_PLEDGE
		/* print paths registered as whilelisted (viewed as without chroot) */
		DNPRINTF(1, "pledge: %s(%d): paths loaded:\n", pr->ps_comm,
		    pr->ps_pid);
		for (i = 0; i < wl->wl_count; i++)
			if (wl->wl_paths[i].name)
				DNPRINTF(1, "pledge: %d=\"%s\" [%lld]\n", i,
				    wl->wl_paths[i].name,
				    (long long)wl->wl_paths[i].len);
#endif
#endif
	}
a661 87
 * wlpath lookup - only done after namei lookup has succeeded on the last compoent of
 * a namei lookup, with a possibly non-canonicalized path given in "origpath" from namei.
 */
int
pledge_namei_wlpath(struct proc *p, struct nameidata *ni)
{
	struct whitepaths *wl = p->p_p->ps_pledgepaths;
	char *rdir = NULL, *cwd = NULL, *resolved = NULL;
	size_t rdirlen = 0, cwdlen = 0, resolvedlen = 0;
	int i, error, pardir_found;

	/*
	 * If a whitelist is set, compare canonical paths.  Anything
	 * not on the whitelist gets ENOENT.
	 */
	if (ni->ni_p_path == NULL)
		return(0);

	KASSERT(wl != NULL);

	// XXX change later or more help from namei?
	error = resolvpath(p, &rdir, &rdirlen, &cwd, &cwdlen,
	    ni->ni_p_path, ni->ni_p_length+1, &resolved, &resolvedlen);

	free(rdir, M_TEMP, rdirlen);
	free(cwd, M_TEMP, cwdlen);

	if (error != 0)
		/* resolved is allocated only if !error */
		return (error);

	/* print resolved path (viewed as without chroot) */
	DNPRINTF(2, "pledge_namei: resolved=\"%s\" [%lld] strlen=%lld\n",
	    resolved, (long long)resolvedlen,
	    (long long)strlen(resolved));

	error = ENOENT;
	pardir_found = 0;
	for (i = 0; i < wl->wl_count && wl->wl_paths[i].name && error; i++) {
		int substr = substrcmp(wl->wl_paths[i].name,
		    wl->wl_paths[i].len - 1, resolved, resolvedlen - 1);

		/* print check between registered wl_path and resolved */
		DNPRINTF(3,
		    "pledge: check: \"%s\" (%ld) \"%s\" (%ld) = %d\n",
		    wl->wl_paths[i].name, wl->wl_paths[i].len - 1,
		    resolved, resolvedlen - 1,
		    substr);

		/* wl_paths[i].name is a substring of resolved */
		if (substr == 1) {
			u_char term = resolved[wl->wl_paths[i].len - 1];

			if (term == '\0' || term == '/' ||
			    wl->wl_paths[i].name[1] == '\0')
				error = 0;

			/* resolved is a substring of wl_paths[i].name */
		} else if (substr == 2) {
			u_char term = wl->wl_paths[i].name[resolvedlen - 1];

			if (resolved[1] == '\0' || term == '/')
				pardir_found = 1;
		}
	}
	if (pardir_found)
		switch (p->p_pledge_syscall) {
		case SYS_stat:
		case SYS_lstat:
		case SYS_fstatat:
		case SYS_fstat:
			ni->ni_pledge |= PLEDGE_STATLIE;
			error = 0;
		}

#ifdef DEBUG_PLEDGE
	if (error == ENOENT)
		/* print the path that is reported as ENOENT */
		DNPRINTF(1, "pledge: %s(%d): wl_path ENOENT: \"%s\"\n",
		    p->p_p->ps_comm, p->p_p->ps_pid, resolved);
#endif

	free(resolved, M_TEMP, resolvedlen);
	return (error);			/* Don't hint why it failed */
}

/*
a1402 14
void
pledge_dropwpaths(struct process *pr)
{
	if (pr->ps_pledgepaths && --pr->ps_pledgepaths->wl_ref == 0) {
		struct whitepaths *wl = pr->ps_pledgepaths;
		int i;

		for (i = 0; i < wl->wl_count; i++)
			free(wl->wl_paths[i].name, M_TEMP, wl->wl_paths[i].len);
		free(wl, M_TEMP, wl->wl_size);
	}
	pr->ps_pledgepaths = NULL;
}

a1441 140
}

int
substrcmp(const char *p1, size_t s1, const char *p2, size_t s2)
{
	size_t i;
	for (i = 0; i < s1 || i < s2; i++) {
		if (p1[i] != p2[i])
			break;
	}
	if (i == s1) {
		return (1);	/* string1 is a subpath of string2 */
	} else if (i == s2)
		return (2);	/* string2 is a subpath of string1 */
	else
		return (0);	/* no subpath */
}

int
resolvpath(struct proc *p,
    char **rdir, size_t *rdirlen,
    char **cwd, size_t *cwdlen,
    char *path, size_t pathlen,
    char **resolved, size_t *resolvedlen)
{
	int error;
	char *abspath = NULL, *canopath = NULL, *fullpath = NULL;
	size_t abspathlen, canopathlen = 0, fullpathlen = 0, canopathlen_exact;

	/* 1. get an absolute path (inside any chroot) : path -> abspath */
	if (path[0] != '/') {
		/* path is relative: prepend cwd */

		/* get cwd first (if needed) */
		if (*cwd == NULL) {
			char *rawcwd, *bp, *bpend;
			size_t rawcwdlen = MAXPATHLEN * 4;

			rawcwd = malloc(rawcwdlen, M_TEMP, M_WAITOK);
			bp = &rawcwd[rawcwdlen];
			bpend = bp;
			*(--bp) = '\0';

			error = vfs_getcwd_common(p->p_fd->fd_cdir,
			    NULL, &bp, rawcwd, rawcwdlen/2,
			    GETCWD_CHECK_ACCESS, p);
			if (error) {
				free(rawcwd, M_TEMP, rawcwdlen);
				goto out;
			}

			/* NUL is included */
			*cwdlen = (bpend - bp);
			*cwd = malloc(*cwdlen, M_TEMP, M_WAITOK);
			memcpy(*cwd, bp, *cwdlen);

			free(rawcwd, M_TEMP, rawcwdlen);
		}

		/* NUL included in *cwdlen and pathlen */
		abspathlen = *cwdlen + pathlen;
		abspath = malloc(abspathlen, M_TEMP, M_WAITOK);
		snprintf(abspath, abspathlen, "%s/%s", *cwd, path);

	} else {
		/* path is absolute */
		abspathlen = pathlen;
		abspath = malloc(abspathlen, M_TEMP, M_WAITOK);
		memcpy(abspath, path, pathlen);
	}

	/* 2. canonization: abspath -> canopath */
	canopathlen = abspathlen;
	canopath = malloc(canopathlen, M_TEMP, M_WAITOK);
	error = canonpath(abspath, canopath, canopathlen);

	/* free abspath now as we don't need it after */
	free(abspath, M_TEMP, abspathlen);

	/* error in canonpath() call (should not happen, but keep safe) */
	if (error != 0)
		goto out;

	/* check the canopath size */
	canopathlen_exact = strlen(canopath) + 1;
	if (canopathlen_exact > MAXPATHLEN) {
		error = ENAMETOOLONG;
		goto out;
	}

	/* 3. preprend *rdir if chrooted : canonpath -> fullpath */
	if (p->p_fd->fd_rdir != NULL) {
		if (*rdir == NULL) {
			char *rawrdir, *bp, *bpend;
			size_t rawrdirlen = MAXPATHLEN * 4;

			rawrdir = malloc(rawrdirlen, M_TEMP, M_WAITOK);
			bp = &rawrdir[rawrdirlen];
			bpend = bp;
			*(--bp) = '\0';

			error = vfs_getcwd_common(p->p_fd->fd_rdir,
			    rootvnode, &bp, rawrdir, rawrdirlen/2,
			    GETCWD_CHECK_ACCESS, p);
			if (error) {
				free(rawrdir, M_TEMP, rawrdirlen);
				goto out;
			}

			/* NUL is included */
			*rdirlen = (bpend - bp);
			*rdir = malloc(*rdirlen, M_TEMP, M_WAITOK);
			memcpy(*rdir, bp, *rdirlen);

			free(rawrdir, M_TEMP, rawrdirlen);
		}

		/*
		 * NUL is included in *rdirlen and canopathlen_exact.
		 * doesn't add "/" between them, as canopath is absolute.
		 */
		fullpathlen = *rdirlen + canopathlen_exact - 1;
		fullpath = malloc(fullpathlen, M_TEMP, M_WAITOK);
		snprintf(fullpath, fullpathlen, "%s%s", *rdir, canopath);

	} else {
		/* not chrooted: only reduce canopath to exact length */
		fullpathlen = canopathlen_exact;
		fullpath = malloc(fullpathlen, M_TEMP, M_WAITOK);
		memcpy(fullpath, canopath, fullpathlen);
	}

	*resolvedlen = fullpathlen;
	*resolved = fullpath;

out:
	free(canopath, M_TEMP, canopathlen);
	if (error != 0)
		free(fullpath, M_TEMP, fullpathlen);
	return error;
@


1.217
log
@Allow SIOCGIFDESCR with "route" promise in preparation for pledging snmpd.

ok deraadt@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.216 2017/06/29 04:10:07 deraadt Exp $	*/
d1308 2
@


1.216
log
@Due to risks known for decades, TIOCSTI now performs no action, and simply
returns EIO.  The base system has been cleaned of TIOCSTI uses (collaboration
between anton and I), and the ports tree appears mostly clean.  A few
stragglers may be discovered and cleaned up later...
In a month or so, we should see if the #define can be removed entirely.
ok anton tedu, support from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.215 2017/06/21 17:13:20 deraadt Exp $	*/
d1308 1
@


1.215
log
@Permit TIOCSTAT on a tty.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.214 2017/06/19 18:35:05 bluhm Exp $	*/
a1275 5
		case TIOCSTI:		/* ksh? csh? */
			if ((p->p_p->ps_pledge & PLEDGE_PROC) &&
			    fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
				return (0);
			break;
@


1.214
log
@Terminate pledge log(9) with newline.  This fixes dmesg(8) output.
found by regress/sys/kern/pledge/generic; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.213 2017/06/12 21:55:16 deraadt Exp $	*/
d1289 1
@


1.213
log
@Pledge is fairly done, so the kernel printf's can be converted to log()
calls.  They'll be a little less visible, but still in the system logs.
ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.212 2017/06/07 20:53:59 bluhm Exp $	*/
d584 1
a584 1
	log(LOG_ERR, "%s(%d): syscall %d \"%s\"",
d1068 1
a1068 1
	log(LOG_ERR, "%s", buf);
@


1.212
log
@Add an acct(5) flag for pledge violations.  Then lastcomm(1) shows
when something went wrong.  This allows to monitor whether the
system is under attack and that the attack has been prevented by
OpenBSD pledge(2).
OK deraadt@@ millert@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.211 2017/06/03 04:34:41 tb Exp $	*/
d34 1
d584 2
a585 2
	printf("%s(%d): syscall %d \"%s\"\n", p->p_p->ps_comm, p->p_p->ps_pid,
	    p->p_pledge_syscall, codes);
d897 1
d1062 7
a1068 4
	printf("%s(%d): sysctl %d:", p->p_p->ps_comm, p->p_p->ps_pid, miblen);
	for (i = 0; i < miblen; i++)
		printf(" %d", mib[i]);
	printf("\n");
@


1.211
log
@Avoid printing garbage when aborting a program that tries to use a
prohibited sysctl.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.210 2017/05/30 15:04:45 deraadt Exp $	*/
d35 1
d585 1
@


1.210
log
@getrtable() is now permitted in "stdio".  It carries no risk factors.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.209 2017/05/21 13:00:53 visa Exp $	*/
d894 2
d1058 5
a1062 3
	printf("%s(%d): sysctl %d: %d %d %d %d %d %d\n",
	    p->p_p->ps_comm, p->p_p->ps_pid, miblen, mib[0], mib[1],
	    mib[2], mib[3], mib[4], mib[5]);
@


1.209
log
@Enable radeondrm(4) on loongson to get accelerated graphics
with the RS780E chipset.

OK kettenis@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.208 2017/05/02 16:46:00 natano Exp $	*/
d132 1
@


1.208
log
@Stricter pledge for bpf. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.207 2017/04/29 08:02:56 mpi Exp $	*/
d80 2
a81 1
    defined(__macppc__) || defined(__sparc64__)
@


1.207
log
@Mark futex(2) as PLEDGE_STDIO like all other thread-related syscalls.

From semarie@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.206 2017/04/28 13:50:55 mpi Exp $	*/
d1146 3
a1148 1
			    fp->f_ops->fo_ioctl == vn_ioctl)
@


1.206
log
@Add futex(2) syscall based on a sane subset of its Linux equivalent.

The syscall is marked NOLOCK and only FUTEX_WAIT grabs the KERNEL_LOCK()
because of PCATCH and the signal nightmare.

Serialization of threads is currently done with a global & exclusive
rwlock.

Note that the current implementation still use copyin(9) which is not
guaranteed to be atomic.  Committing now such that remaining issues can
be addressed in-tree.

With inputs from guenther@@, kettenis@@ and visa@@.

ok deraadt@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.205 2017/04/20 15:21:53 deraadt Exp $	*/
d261 1
a262 1
	[SYS_futex] = PLEDGE_ALWAYS,
@


1.205
log
@only 32 bits of the pledgecode were passed up via ktrace
from Anton Lindqvist
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.204 2017/04/17 20:22:14 deraadt Exp $	*/
d262 1
@


1.204
log
@matthieu@@ observes % pax (without any arguments) hits pledge violation,
because it tries MTIOCTOP against stdin, the tty.  It is very inconvenient
to use isatty to distinguish this difference in userland, so return ENOTTY
for tty devices.
ok natano
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.203 2017/04/13 04:06:46 guenther Exp $	*/
d548 1
a548 1
pledge_syscall(struct proc *p, int code, int *tval)
@


1.203
log
@Delete the getlogin59 syscall, which was last used one year, two releases,
and four libc major versions ago

ok sthen@@ jsing@@ deraadt@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.202 2017/04/11 15:55:41 bluhm Exp $	*/
d1158 6
a1163 3
			    vp->v_type == VCHR &&
			    (vp->v_flag & VISTTY) == 0)
				return (0);
@


1.202
log
@Add SIOCATMARK to allow pledge("inet") programs to call sockatmark(3).
from Matthias Pitzl; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.201 2017/03/30 15:22:07 deraadt Exp $	*/
a123 1
	[SYS_getlogin59] = PLEDGE_STDIO,
@


1.201
log
@correct NBPFILTER #ifdef's
from sthen and others
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.200 2017/03/28 16:03:31 bluhm Exp $	*/
d1133 1
@


1.200
log
@Allow the multicast ttl/hops and loop options with the mcast pledge.
from Matthias Pitzl; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.199 2017/03/27 00:33:15 deraadt Exp $	*/
d1140 1
a1140 1
#if BPFFILTER > 0
d1150 1
a1150 1
#endif /* BPFFILTER > 0 */
@


1.199
log
@wrap bpf pledge code in #if BPFFILTER
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.198 2017/03/26 22:47:45 deraadt Exp $	*/
d1423 2
d1448 2
@


1.198
log
@Inside pledge_ioctl, wrap #if's around the complete sub-blocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.197 2017/03/26 22:42:36 deraadt Exp $	*/
d68 1
d1140 1
d1150 1
@


1.197
log
@For the tape ioctls, recognize that block devices don't exist anymore.
Also fail if the descriptor is actually a tty.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.196 2017/03/18 01:50:21 deraadt Exp $	*/
d1162 1
a1163 1
#if NDRM > 0
d1171 1
a1172 1
	}
d1174 1
a1175 1
#if NAUDIO > 0
d1187 1
a1188 1
	}
d1216 1
a1217 1
#if NPF > 0
d1237 1
a1238 1
	}
d1306 1
a1307 1
#if NVMM > 0
d1315 1
a1316 1
	}
@


1.196
log
@The "ioctl" pledge which was had functionality split out into "tape",
"bpf", and "inet" can finally go away.  Use a snapshot if you get into
trouble, most likely in pax..
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.195 2017/03/14 16:49:18 florian Exp $	*/
d1155 2
a1156 1
			    (vp->v_type == VCHR || vp->v_type == VBLK))
@


1.195
log
@Allow SIOCGIFXFLAGS in pledge("route") along side SIOCGIFFLAGS, needed
for upcoming IPv6 stateless address autoconfiguration daemon to see
if autoconfiguration and autoconfprivacy are enabled.
Input semarie@@; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.194 2017/03/11 16:54:54 deraadt Exp $	*/
a374 1
	{ "ioctl",		PLEDGE_TAPE },		/* Remove Mar 20 2017 */
@


1.194
log
@pax conversion was missed; give this another week
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.193 2017/03/11 07:03:38 deraadt Exp $	*/
d1296 1
@


1.193
log
@remove pledge "ioctl" backwards compat
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.192 2017/01/23 05:49:24 deraadt Exp $	*/
d375 1
@


1.192
log
@Backwards compat for pledge "ioctl" for about a week
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.191 2017/01/23 04:25:05 deraadt Exp $	*/
a374 1
	{ "ioctl",		PLEDGE_TAPE },		/* Remove Feb 1 2017 */
@


1.191
log
@Split pledge "ioctl" into "tape" and "bpf", and allow SIOCGIFGROUP only
upon "inet".  Adjust the 4 programs that care about this.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.190 2017/01/23 03:17:55 deraadt Exp $	*/
d375 1
@


1.190
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.189 2017/01/21 05:42:03 guenther Exp $	*/
d238 1
a238 2
	 * A few non-tty ioctl available using "ioctl"
	 * tty-centric ioctl available using "tty"
d362 1
a374 1
	{ "ioctl",		PLEDGE_IOCTL },
d386 1
d1130 1
a1130 5
	/*
	 * Further sets of ioctl become available, but are checked a
	 * bit more carefully against the vnode.
	 */
	if ((p->p_p->ps_pledge & PLEDGE_IOCTL)) {
d1132 2
a1133 4
		case TIOCGETA:
		case TIOCGPGRP:
		case TIOCGWINSZ:	/* ENOTTY return for non-tty */
			if (fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
d1135 6
a1140 1
			return (ENOTTY);
d1146 5
a1157 5
		case SIOCGIFGROUP:
			if ((p->p_p->ps_pledge & PLEDGE_INET) &&
			    fp->f_type == DTYPE_SOCKET)
				return (0);
			break;
d1316 1
a1316 1
	return pledge_fail(p, error, PLEDGE_IOCTL);
@


1.189
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.188 2016/11/13 00:40:09 tb Exp $	*/
d1604 5
a1608 5
        if ((*p == '\0') && (q - buf < bufsize)) {
                *q = 0;
                return 0;
        } else
                return ENAMETOOLONG;
@


1.188
log
@Fix typo in comment: it's vm.loadavg, not kern.loadavg.

From patrick keshishian
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.187 2016/10/27 10:48:25 schwarze Exp $	*/
d528 1
a528 1
		DNPRINTF(1, "pledge: %s(%d): paths loaded:\n", p->p_comm,
d579 1
a579 1
	printf("%s(%d): syscall %d \"%s\"\n", p->p_comm, p->p_p->ps_pid,
d827 1
a827 1
		    p->p_comm, p->p_p->ps_pid, resolved);
d1054 1
a1054 1
	    p->p_comm, p->p_p->ps_pid, miblen, mib[0], mib[1],
@


1.187
log
@For consistency, allow symlinkat(2) in the same way as symlink(2);
no need to wait until the first program using it breaks...
"could make sense" semarie@@ (and thanks for the cluestick)
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.186 2016/10/21 06:56:38 mlarkin Exp $	*/
d1049 1
a1049 1
	if (miblen == 2 &&		/* kern.loadavg / getloadavg(3) */
@


1.186
log
@
pledge changes needed to support pledging vmd(8) on i386, forthcoming.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.185 2016/10/06 04:39:30 jsg Exp $	*/
d303 1
@


1.185
log
@In pledge_namei_wlpath() if resolvpath() errors out early it will not
set variables that will be later used as the size argument to
free(NULL calls.  This should be harmless as free returns early if the
address is NULL without checking the size.  Initialise these variables
before the call to ensure they are never passed to another function
uninitialised.

ok tedu@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.184 2016/10/05 05:22:02 guenther Exp $	*/
d71 1
a71 1
#if defined(__amd64__)
@


1.184
log
@Display the process's PID with p->p_p->ps_pid, not p->p_pid.
Use a local variable struct process *pr to simplify expressions

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.183 2016/09/17 00:42:35 tedu Exp $	*/
d755 1
a755 1
	size_t rdirlen, cwdlen, resolvedlen;
@


1.183
log
@NPF > 0 is a better test than SMALL for presence of pf.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.182 2016/09/04 17:22:40 jsing Exp $	*/
d401 1
d442 2
a443 2
		if (ISSET(p->p_p->ps_flags, PS_PLEDGE) &&
		    (((flags | p->p_p->ps_pledge) != p->p_p->ps_pledge)))
d459 1
a459 1
		if (p->p_p->ps_pledgepaths)
d523 1
a523 1
		p->p_p->ps_pledgepaths = wl;
d528 1
a528 1
		    p->p_pid);
d539 2
a540 2
		p->p_p->ps_pledge = flags;
		p->p_p->ps_flags |= PS_PLEDGE;
d578 1
a578 1
	printf("%s(%d): syscall %d \"%s\"\n", p->p_comm, p->p_pid,
d765 1
a765 1
	KASSERT(p->p_p->ps_pledgepaths);
d826 1
a826 1
		    p->p_comm, p->p_pid, resolved);
d1053 1
a1053 1
	    p->p_comm, p->p_pid, miblen, mib[0], mib[1],
@


1.182
log
@Remove sys_o58_kill since OpenBSD 6.0 has been tagged/released.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.181 2016/08/31 07:22:43 ratchov Exp $	*/
d68 1
d1215 1
a1215 1
#ifndef SMALL_KERNEL
d1235 1
a1235 1
#endif /* !SMALL_KERNEL */
@


1.181
log
@Delete unused ioctls and associated macros. Move macros that are still
used internally by low-level drivers from sys/audioio.h to
dev/audio_if.h instead of deleting them.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.178 2016/07/12 06:06:34 deraadt Exp $	*/
a232 1
	[SYS_o58_kill] = PLEDGE_STDIO,
@


1.180
log
@Revert previous commit
@
text
@a1179 5
		case AUDIO_SETINFO:
		case AUDIO_GETINFO:
		case AUDIO_GETENC:
		case AUDIO_SETFD:
		case AUDIO_GETPROPS:
@


1.179
log
@Convert ifq_deq_{begin,rollback,commit} dance to a single ifq_dequeue
@
text
@d385 1
a385 1
	{ "stdio",		PLEDGE_STDIO|PLEDGE_RECVFD },
@


1.178
log
@remove more noisy messages in "sendfd" and "recvfd"
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.177 2016/07/11 19:11:34 deraadt Exp $	*/
d385 1
a385 1
	{ "stdio",		PLEDGE_STDIO },
@


1.177
log
@be less noisy on console in case of "recvfd" refusal
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.176 2016/07/10 14:21:24 semarie Exp $	*/
d838 1
a838 2
	struct vnode *vp = NULL;
	char *vtypes[] = { VTYPE_NAMES };
a855 1
	printf("recvfd type %d %s\n", fp->f_type, vp ? vtypes[vp->v_type] : "");
d865 1
a865 2
	struct vnode *vp = NULL;
	char *vtypes[] = { VTYPE_NAMES };
d869 1
a869 3

	if ((p->p_p->ps_pledge & PLEDGE_SENDFD) == 0) {
		printf("sendmsg not allowed\n");
a870 1
	}
a882 1
	printf("sendfd type %d %s\n", fp->f_type, vp ? vtypes[vp->v_type] : "");
@


1.176
log
@pledge: use uint64_t instead of int for temporary storing a 64bit integer

affects only 32 bits platform (like i386).

problem spotted and diff from pelikan@@

ok deraadt@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.175 2016/07/10 00:39:23 guenther Exp $	*/
d843 1
a843 2
	if ((p->p_p->ps_pledge & PLEDGE_RECVFD) == 0) {
		printf("recvmsg not allowed\n");
a844 1
	}
@


1.175
log
@Paranoia: check KTRPOINT() before calling ktrpledge() to guarantee we
can't (in the future) loop from ktrace writing hitting a pledge condition.

diff from Michal Mazurek (akfaew (at) jasminek.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.174 2016/07/03 04:36:08 semarie Exp $	*/
d82 1
a82 1
int pledgereq_flags(const char *req);
d407 1
a407 1
		int f;
d1518 1
a1518 1
int
@


1.174
log
@introduces new promise "chown" to allow changing owner/group with *chown(2) family

it splits PLEDGE_FATTR in two ("fattr" stills grant the 2 flags, so no functional changes):
  - PLEDGE_CHOWN : to be able to call *chown(2) syscalls
  - PLEDGE_FATTR : the rest

it introduces "chown" which grant:
  - PLEDGE_CHOWN : be able to call *chown(2)
  - PLEDGE_CHOWNUID : be able to modifying owner/group

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.173 2016/06/28 04:27:58 semarie Exp $	*/
d580 2
a581 1
	ktrpledge(p, error, code, p->p_pledge_syscall);
@


1.173
log
@in pledgereq (the array for doing correspondance between textual promise as in pledge(2) and internal PLEDGE_* flag), the flags member should be a uint64_t and not a int.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.172 2016/06/27 16:49:45 jsing Exp $	*/
d336 5
a340 4
	[SYS_chown] = PLEDGE_FATTR,
	[SYS_fchownat] = PLEDGE_FATTR,
	[SYS_lchown] = PLEDGE_FATTR,
	[SYS_fchown] = PLEDGE_FATTR,
d362 1
d369 1
a369 1
	{ "fattr",		PLEDGE_FATTR },
d1069 3
@


1.172
log
@Restore the sys_o58_kill system call.

By keeping both the new (sys_kill/sys_thrkill) and old (sys_o58_kill)
system calls for the OpenBSD 6.0 release, code that uses either of these
mechanisms will work on both of the supported OpenBSD releases. This
provides a clean transition for runtimes that make direct system calls
(namely the Go programming language).

This requires a minimal amount of non-intrusive code and does not block
development progress within OpenBSD.

ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.171 2016/06/27 16:33:48 jca Exp $	*/
d358 1
a358 1
	int flags;
@


1.171
log
@Implement IPV6_MINHOPCOUNT support.

Useful to implement GTSM support in daemons such as bgpd(8). Diff from
2013 revived by renato@@.  Input from bluhm@@, ok bluhm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.170 2016/06/07 01:31:54 tedu Exp $	*/
d233 1
@


1.170
log
@per trending style, add continue to empty loops.
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.169 2016/05/31 22:14:43 deraadt Exp $	*/
d1437 1
@


1.169
log
@sys_o58_kill is no longer needed for compat.
ok guenther sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.168 2016/05/31 22:12:26 deraadt Exp $	*/
d1602 1
a1602 1
					;
@


1.168
log
@sys_osendsyslog can go away; we have transitioned to the new version with
a flags argument
ok guenther sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.167 2016/05/27 16:33:55 deraadt Exp $	*/
a232 1
	[SYS_o58_kill] = PLEDGE_STDIO,
@


1.167
log
@rename(2) operation requires "rpath cpath" at the underlying operation
(the src path lookup is considered a rpath operation)
noticed by kristaps, discussed with semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.166 2016/05/15 05:04:28 semarie Exp $	*/
a110 1
	[SYS_osendsyslog] = PLEDGE_ALWAYS,	/* obsolete sendsyslog */
@


1.166
log
@remove chroot(2) from allowed syscalls under pledge(2).

please note that chrooted process are still possible with pledge(2), but only
if the chroot(2) is done *before* calling pledge(2). Once pledged, no more
chroot(2) call are permitted.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.165 2016/04/28 14:25:08 beck Exp $	*/
d298 1
a298 1
	[SYS_rename] = PLEDGE_CPATH,
@


1.165
log
@1) Split pledge whitelist path handling out of pledge_namei() and into
   pledge_namei_wlpath(). Call the wlpath check only at the end of namei
   after the namei lookup would otherwise succeed.
2) Add support to namei to keep the path that was looked up, without the
   symlinks in it, and use that path for whitelist path lookups. This
   means that paths in pledge whitelists will need to always be the
   real path to an intended file to whitelist, without symlinks. Any
   symlinks to the "real" file will then be allowed
ok deraadt@@ semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.164 2016/04/25 10:01:23 semarie Exp $	*/
a310 2

	[SYS_chroot] = PLEDGE_ID,	/* also requires PLEDGE_PROC */
@


1.164
log
@simplifies the check for allowing only promises
reductions.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.163 2016/04/25 09:58:23 semarie Exp $	*/
d742 15
d761 4
a764 5
	if (p->p_p->ps_pledgepaths) {
		struct whitepaths *wl = p->p_p->ps_pledgepaths;
		char *rdir = NULL, *cwd = NULL, *resolved = NULL;
		size_t rdirlen, cwdlen, resolvedlen;
		int i, error, pardir_found;
d766 3
a768 2
		error = resolvpath(p, &rdir, &rdirlen, &cwd, &cwdlen,
		    origpath, strlen(origpath)+1, &resolved, &resolvedlen);
d770 6
a775 2
		free(rdir, M_TEMP, rdirlen);
		free(cwd, M_TEMP, cwdlen);
d777 21
a797 3
		if (error != 0)
			/* resolved is allocated only if !error */
			return (error);
d799 3
a801 25
		/* print resolved path (viewed as without chroot) */
		DNPRINTF(2, "pledge_namei: resolved=\"%s\" [%lld] strlen=%lld\n",
		    resolved, (long long)resolvedlen,
		    (long long)strlen(resolved));

		error = ENOENT;
		pardir_found = 0;
		for (i = 0; i < wl->wl_count && wl->wl_paths[i].name && error; i++) {
			int substr = substrcmp(wl->wl_paths[i].name,
			    wl->wl_paths[i].len - 1, resolved, resolvedlen - 1);

			/* print check between registered wl_path and resolved */
			DNPRINTF(3,
			    "pledge: check: \"%s\" (%ld) \"%s\" (%ld) = %d\n",
			    wl->wl_paths[i].name, wl->wl_paths[i].len - 1,
			    resolved, resolvedlen - 1,
			    substr);

			/* wl_paths[i].name is a substring of resolved */
			if (substr == 1) {
				u_char term = resolved[wl->wl_paths[i].len - 1];

				if (term == '\0' || term == '/' ||
				    wl->wl_paths[i].name[1] == '\0')
					error = 0;
d804 2
a805 2
			} else if (substr == 2) {
				u_char term = wl->wl_paths[i].name[resolvedlen - 1];
d807 12
a818 3
				if (resolved[1] == '\0' || term == '/')
					pardir_found = 1;
			}
a819 9
		if (pardir_found)
			switch (p->p_pledge_syscall) {
			case SYS_stat:
			case SYS_lstat:
			case SYS_fstatat:
			case SYS_fstat:
				ni->ni_pledge |= PLEDGE_STATLIE;
				error = 0;
			}
d822 4
a825 4
		if (error == ENOENT)
			/* print the path that is reported as ENOENT */
			DNPRINTF(1, "pledge: %s(%d): wl_path ENOENT: \"%s\"\n",
			    p->p_comm, p->p_pid, resolved);
d828 2
a829 5
		free(resolved, M_TEMP, resolvedlen);
		return (error);			/* Don't hint why it failed */
	}

	return (0);
@


1.163
log
@removes an unneeded check on flags (used historically when tame(2) was using
bitflags)

ok deraadt@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.162 2016/03/30 07:49:11 guenther Exp $	*/
d437 8
a444 10
		if ((p->p_p->ps_flags & PS_PLEDGE)) {
			/* Already pledged, only allow reductions */
			if (((flags | p->p_p->ps_pledge) & PLEDGE_USERSET) !=
			    (p->p_p->ps_pledge & PLEDGE_USERSET)) {
				return (EPERM);
			}

			flags &= p->p_p->ps_pledge;
			flags &= PLEDGE_USERSET;	/* Relearn _ACTIVE */
		}
@


1.162
log
@Add getlogin_r syscall that checks and returns errors like userspace
getlogin_r() API; keep existing syscall as getlogin59 for temporary compat.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.161 2016/03/25 17:25:36 semarie Exp $	*/
a435 3

		if (flags & ~PLEDGE_USERSET)
			return (EINVAL);
@


1.161
log
@Silences compiler warnings, about used uninitialized variables. These lengths
are passed uninitialized to free(9) only when pointers are NULL.

found by jsg@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.160 2016/03/22 05:59:17 deraadt Exp $	*/
d123 2
a124 1
	[SYS_getlogin] = PLEDGE_STDIO,
@


1.160
log
@allow fpathconf() in stdio mode, since it is an innocuous query
system call.  discussed with semarie and everyone else during
the 5.9 lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.159 2016/03/21 22:41:29 bluhm Exp $	*/
d1636 1
a1636 1
	size_t abspathlen, canopathlen, fullpathlen, canopathlen_exact;
@


1.159
log
@Rename the system call sendsyslog2 to sendsyslog.  Keep the old one
as osendsyslog for a while.  The three argument variant is the only
one that will stay.
input kettenis@@;  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.158 2016/03/16 06:46:39 ratchov Exp $	*/
d171 1
@


1.158
log
@Expose new audio ioctls that do one thing only: start and stop DMA,
set and get parameters. This is much simpler.

ok semarie, armani, tweaks from jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.156 2016/03/15 15:05:23 semarie Exp $	*/
d111 1
a111 1
	[SYS_sendsyslog2] = PLEDGE_ALWAYS,	/* stack protector reporting */
@


1.157
log
@pledge: wl_paths: resolvpath() logic error

prepend chroot value *after* canonization and not before.
@
text
@d1173 4
@


1.156
log
@pledge: wl_paths: corrects a memory leak in error code path and an evaluation
order ("a += b > c" is the same as "a += (b > c)" which is wrong here)

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.155 2016/03/13 18:40:52 semarie Exp $	*/
d1630 2
a1631 2
	char *fullpath = NULL, *rawcanopath = NULL, *canopath = NULL;
	size_t fullpathlen, rawcanopathlen, canopathlen;
d1633 1
a1633 32
	/* 1. get rdir if chrooted */
	if (p->p_fd->fd_rdir != NULL) {
		if (*rdir == NULL) {
			char *rawrdir, *bp, *bpend;
			size_t rawrdirlen = MAXPATHLEN * 4;

			rawrdir = malloc(rawrdirlen, M_TEMP, M_WAITOK);
			bp = &rawrdir[rawrdirlen];
			bpend = bp;
			*(--bp) = '\0';

			error = vfs_getcwd_common(p->p_fd->fd_rdir,
			    rootvnode, &bp, rawrdir, rawrdirlen/2,
			    GETCWD_CHECK_ACCESS, p);
			if (error) {
				free(rawrdir, M_TEMP, rawrdirlen);
				goto out;
			}

			/* NUL is included */
			*rdirlen = (bpend - bp);
			*rdir = malloc(*rdirlen, M_TEMP, M_WAITOK);
			memcpy(*rdir, bp, *rdirlen);

			free(rawrdir, M_TEMP, rawrdirlen);
		}
	} else {
		if (*rdir == NULL)
			*rdirlen = 0;	/* ensure rdirlen value is initialized */
	}

	/* 2. resolv: path -> fullpath */
d1635 1
a1635 1
		/* path is relative: prepend cwd (rootvnode based) */
d1648 1
a1648 1
			    rootvnode, &bp, rawcwd, rawcwdlen/2,
d1664 3
a1666 11
		fullpathlen = *cwdlen + pathlen;
		fullpath = malloc(fullpathlen, M_TEMP, M_WAITOK);
		snprintf(fullpath, fullpathlen, "%s/%s", *cwd, path);

	} else if (p->p_fd->fd_rdir) {
		/* path is absolute and we are chrooted : prepend *rdir */

		/* NUL included in *rdirlen and pathlen (and no '/' between them) */
		fullpathlen = *rdirlen + pathlen - 1;
		fullpath = malloc(fullpathlen, M_TEMP, M_WAITOK);
		snprintf(fullpath, fullpathlen, "%s%s", *rdir, path);
d1670 3
a1672 3
		fullpathlen = pathlen;
		fullpath = malloc(fullpathlen, M_TEMP, M_WAITOK);
		memcpy(fullpath, path, pathlen);
d1675 9
a1683 4
	/* 3. canonization: fullpath -> rawcanopath */
	rawcanopathlen = fullpathlen;
	rawcanopath = malloc(rawcanopathlen, M_TEMP, M_WAITOK);
	error = canonpath(fullpath, rawcanopath, rawcanopathlen);
d1687 48
a1734 4
	/* 4. output a fresh allocated path: rawcanopath -> canopath */
	canopathlen = strlen(rawcanopath) + 1; /* NUL */
	canopath = malloc(canopathlen, M_TEMP, M_WAITOK);
	memcpy(canopath, rawcanopath, canopathlen);
d1736 2
a1737 2
	*resolvedlen = canopathlen;
	*resolved = canopath;
d1740 1
a1740 2
	free(rawcanopath, M_TEMP, rawcanopathlen);
	free(fullpath, M_TEMP, fullpathlen);
d1742 1
a1742 1
		free(canopath, M_TEMP, canopathlen);
@


1.155
log
@keep disabled wl_paths for now. the expensiveness impact need to be better
considered.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.154 2016/03/13 15:27:21 semarie Exp $	*/
d506 2
a507 1
			if (maxargs += resolvedlen > ARG_MAX) {
d509 1
@


1.154
log
@reenable wl_paths (whitelisted-paths) in pledge(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.153 2016/03/13 15:05:15 semarie Exp $	*/
d451 3
d535 1
@


1.153
log
@pledge: replace #if 0 printf with DNPRINTF macro
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.152 2016/03/13 14:27:18 semarie Exp $	*/
a450 2
		return (EINVAL);
#if 0
a531 1
#endif
@


1.152
log
@pledge: let wl_paths works well with chroot

it factorizes path resolution in resolvpath() function, and use it in
sys_pledge() and pledge_namei().

please note that wl_paths is still disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.151 2016/03/13 04:51:59 semarie Exp $	*/
d89 10
d524 2
a525 1
#if 0
d527 2
a528 1
		printf("pledge: %s(%d): paths loaded:\n", p->p_comm, p->p_pid);
d531 2
a532 1
				printf("pledge: %d=%s [%lld]\n", i, wl->wl_paths[i].name,
a761 1
#if 0
d763 3
a765 3
		printf("pledge_namei: resolved=%s [%lld] strlen=%lld\n",
		    resolved, (long long)resolvedlen, (long long)strlen(resolved));
#endif
d772 1
a772 1
#if 0
d774 2
a775 1
			printf("pledge: check: %s (%ld) %s (%ld) = %d\n",
d779 1
a779 1
#endif
d805 2
a806 1
#if 0
d809 2
a810 2
			printf("pledge: %s(%d): wl_path: %s\n", p->p_comm,
			    p->p_pid, resolved);
d812 1
@


1.151
log
@corrects on off-by-one error in pledge_namei()

- rewrite canonpath() to not require extra byte before shrinking
- make canonpath() error not fatal for the caller (proposition from tedu@@)

ok millert@@ tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.150 2016/03/11 05:57:16 semarie Exp $	*/
d85 3
d445 4
a448 2
		char *cwdpath = NULL, *path;
		size_t cwdpathlen = MAXPATHLEN * 4, cwdlen, len, maxargs = 0;
d474 2
a475 2
			char *fullpath = NULL, *builtpath = NULL, *canopath = NULL, *cwd;
			size_t builtlen = 0;
d481 1
a481 1
			if ((error = copyinstr(sp, path, MAXPATHLEN, &len)) != 0)
d485 1
a485 1
				ktrstruct(p, "pledgepath", path, len-1);
d488 5
a492 38
			/* If path is relative, prepend cwd */
			if (path[0] != '/') {
				if (cwdpath == NULL) {
					char *bp, *bpend;

					cwdpath = malloc(cwdpathlen, M_TEMP, M_WAITOK);
					bp = &cwdpath[cwdpathlen];
					bpend = bp;
					*(--bp) = '\0';

					error = vfs_getcwd_common(p->p_fd->fd_cdir,
					    NULL, &bp, cwdpath, cwdpathlen/2,
					    GETCWD_CHECK_ACCESS, p);
					if (error)
						break;
					cwd = bp;
					cwdlen = (bpend - bp);
				}

				/* NUL included in cwd component */
				builtlen = cwdlen + 1 + strlen(path);
				if (builtlen > PATH_MAX) {
					error = ENAMETOOLONG;
					break;
				}
				builtpath = malloc(builtlen, M_TEMP, M_WAITOK);
				snprintf(builtpath, builtlen, "%s/%s", cwd, path);
				// printf("pledge: builtpath = %s\n", builtpath);
				fullpath = builtpath;
			} else
				fullpath = path;

			canopath = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
			error = canonpath(fullpath, canopath, MAXPATHLEN);

			free(builtpath, M_TEMP, builtlen);
			if (error != 0) {
				free(canopath, M_TEMP, MAXPATHLEN);
a493 3
			}

			len = strlen(canopath) + 1;
d495 1
a495 4
			//printf("pledge: canopath = %s %lld strlen %lld\n", canopath,
			//    (long long)len, (long long)strlen(canopath));

			if (maxargs += len > ARG_MAX) {
d499 2
a500 4
			wl->wl_paths[i].name = malloc(len, M_TEMP, M_WAITOK);
			memcpy(wl->wl_paths[i].name, canopath, len);
			wl->wl_paths[i].len = len;
			free(canopath, M_TEMP, MAXPATHLEN);
d502 2
a504 1
		free(cwdpath, M_TEMP, cwdpathlen);
d515 1
d519 1
a519 1
				printf("pledge: %d=%s %lld\n", i, wl->wl_paths[i].name,
d735 2
a736 2
		char *fullpath, *builtpath = NULL, *canopath = NULL;
		size_t builtlen = 0, canopathlen;
d739 2
a740 3
		if (origpath[0] != '/') {
			char *cwdpath, *cwd, *bp, *bpend;
			size_t cwdpathlen = MAXPATHLEN * 4, cwdlen;
d742 2
a743 4
			cwdpath = malloc(cwdpathlen, M_TEMP, M_WAITOK);
			bp = &cwdpath[cwdpathlen];
			bpend = bp;
			*(--bp) = '\0';
d745 3
a747 9
			error = vfs_getcwd_common(p->p_fd->fd_cdir,
			    NULL, &bp, cwdpath, cwdpathlen/2,
			    GETCWD_CHECK_ACCESS, p);
			if (error) {
				free(cwdpath, M_TEMP, cwdpathlen);
				return (error);
			}
			cwd = bp;
			cwdlen = (bpend - bp);
d749 5
a753 23
			/* NUL included in cwd component */
			builtlen = cwdlen + 1 + strlen(origpath);
			builtpath = malloc(builtlen, M_TEMP, M_WAITOK);
			snprintf(builtpath, builtlen, "%s/%s", cwd, origpath);
			fullpath = builtpath;
			free(cwdpath, M_TEMP, cwdpathlen);

			//printf("namei: builtpath = %s %lld strlen %lld\n", builtpath,
			//    (long long)builtlen, (long long)strlen(builtpath));
		} else
			fullpath = path;

		canopath = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
		error = canonpath(fullpath, canopath, MAXPATHLEN);

		free(builtpath, M_TEMP, builtlen);
		if (error != 0) {
			free(canopath, M_TEMP, MAXPATHLEN);
			return (pledge_fail(p, error, 0));
		}

		//printf("namei: canopath = %s strlen %lld\n", canopath,
		//    (long long)strlen(canopath));
a755 1
		canopathlen = strlen(canopath);
d759 9
a767 8
			    wl->wl_paths[i].len - 1, canopath, canopathlen);

			//printf("pledge: check: %s [%ld] %s [%ld] = %d\n",
			//    wl->wl_paths[i].name, wl->wl_paths[i].len - 1,
			//    canopath, canopathlen,
			//    substr);

			/* wl_paths[i].name is a substring of canopath */
d769 1
a769 1
				u_char term = canopath[wl->wl_paths[i].len - 1];
d775 1
a775 1
			/* canopath is a substring of wl_paths[i].name */
d777 1
a777 1
				u_char term = wl->wl_paths[i].name[canopathlen];
d779 1
a779 1
				if (canopath[1] == '\0' || term == '/')
d792 7
a798 1
		free(canopath, M_TEMP, MAXPATHLEN);
d1602 115
@


1.150
log
@pledge: define the meaning of passing NULL to one arguments of pledge(2) as "I
don't want to change the current value"

it changes only the `request' argument behaviour when NULL is passed:
previously it was traited as "" was passed.

with help from jmc@@ for man-page
OK tb@@ on previous version
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.149 2016/02/17 21:52:06 millert Exp $	*/
d638 1
a638 1
		return (pledge_fail(p, error, 0));
d1605 2
a1606 1
	char *p, *q, *s, *end;
d1611 2
a1612 2
			return (ENAMETOOLONG);
		return (0);
d1615 5
a1619 3
	/* easiest to work with strings always ending in '/' */
	if (snprintf(buf, bufsize, "%s/", input) >= bufsize)
		return (ENAMETOOLONG);
a1620 6
	/* after this we will only be shortening the string. */
	p = buf;
	q = p;
	while (*p) {
		if (p[0] == '/' && p[1] == '/') {
			p += 1;
d1622 1
a1622 1
		    p[2] == '/') {
d1624 8
d1636 5
a1640 32
	*q = 0;

	end = buf + strlen(buf);
	s = buf;
	p = s;
	while (1) {
		/* find "/../" (where's strstr when you need it?) */
		while (p < end) {
			if (p[0] == '/' && strncmp(p + 1, "../", 3) == 0)
				break;
			p++;
		}
		if (p == end)
			break;
		if (p == s) {
			memmove(s, p + 3, end - p - 3 + 1);
			end -= 3;
		} else {
			/* s starts with '/', so we know there's one
			 * somewhere before p. */
			q = p - 1;
			while (*q != '/')
				q--;
			memmove(q, p + 3, end - p - 3 + 1);
			end -= p + 3 - q;
			p = q;
		}
	}
	if (end > s + 1)
		*(end - 1) = 0; /* remove trailing '/' */

	return 0;
@


1.149
log
@Return ENOTTY for TIOCFLUSH when allowed by pledge but the fd is
not a tty.  Fixes a pledge failure in telnet when piping the output.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.148 2016/01/19 07:31:48 ratchov Exp $	*/
a420 1
	}
d422 9
a430 2
	if (flags & ~PLEDGE_USERSET)
		return (EINVAL);
d432 2
a433 5
	if ((p->p_p->ps_flags & PS_PLEDGE)) {
		/* Already pledged, only allow reductions */
		if (((flags | p->p_p->ps_pledge) & PLEDGE_USERSET) !=
		    (p->p_p->ps_pledge & PLEDGE_USERSET)) {
			return (EPERM);
a434 3

		flags &= p->p_p->ps_pledge;
		flags &= PLEDGE_USERSET;		/* Relearn _ACTIVE */
d559 5
a563 2
	p->p_p->ps_pledge = flags;
	p->p_p->ps_flags |= PS_PLEDGE;
@


1.149.2.1
log
@Incorrect path processing in pledge_namei() could result in unexpected
program termination of pledge(2)'d programs.

Expand path variable size to +1 in order to add extra byte for canonpath()
processing.

-current was fixed by a large rewrite of canonpath().

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.149 2016/02/17 21:52:06 millert Exp $	*/
d618 1
a618 1
	char path[PATH_MAX + 1];
@


1.148
log
@Check if the vnode type is VBAD (corresponds to disconnected
usb devices) and return ENOTTY rather than terminating the
caller program. Found by Michael Reed <m.reed at mykolab.com>

ok semarie, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.147 2016/01/18 17:19:55 deraadt Exp $	*/
d1293 1
a1309 1
		case TIOCFLUSH:		/* getty */
@


1.147
log
@Add SYS_truncate as a "wpath" operation.  Omission noticed by tb and sthen.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.146 2016/01/09 06:13:43 semarie Exp $	*/
d1153 1
a1153 1
	if (fp->f_type == DTYPE_VNODE)
d1155 3
@


1.146
log
@drop "abort" promise, and make it the default behaviour.
The current code has already setted it by default since 1.74

any pledge failure tries to make a coredump (default rules for coredump still
applies: so setuid binaries don't create them locally).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.145 2016/01/08 11:20:58 reyk Exp $	*/
d282 1
@


1.145
log
@Add "vmm" pledge to allow restricted ioctl access to /dev/vmm.

This will allow to pledge vmd(8)'s vmm and vm processes, so that VMs
themselves run "sandboxed", including their host-side virtio layer.
It will remain disabled for now (in userland) to not get into the way
of ongoing development and upcoming changes in vmd and the ioctl
interface.

OK mlarkin@@ deraadt@@ "kernel side in, but not the callers in userland"
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.144 2016/01/06 18:43:10 tedu Exp $	*/
a346 1
	{ "abort",		0 },	/* XXX reserve for later */
a558 1
	p->p_p->ps_pledge |= PLEDGE_COREDUMP;	/* XXX temporary */
d587 1
d600 5
a604 10
	if (p->p_p->ps_pledge & PLEDGE_COREDUMP) {
		/* Core dump requested */
		struct sigaction sa;

		memset(&sa, 0, sizeof sa);
		sa.sa_handler = SIG_DFL;
		setsigvec(p, SIGABRT, &sa);
		psignal(p, SIGABRT);
	} else
		psignal(p, SIGKILL);
d620 2
a621 1
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
a625 3

	if (ni->ni_pledge == PLEDGE_COREDUMP)
		return (0);			/* Allow a coredump */
@


1.144
log
@turn off the whitepath code for now; we're not sure it's ready for release
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.143 2016/01/06 17:59:30 tedu Exp $	*/
d70 7
d376 1
d1337 12
@


1.143
log
@remove unnecessary casts where the incoming type is void *.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.142 2016/01/06 09:09:16 kettenis Exp $	*/
d430 2
d547 1
@


1.142
log
@Add pledge "drm", which allows a subset of the drm(4) ioctls.  These are
basically only the ioctls that Linux allows on the so-called "render nodes".
For now, it also allows DRM_IOCTL_GET_MAGIC and DRM_IOCTL_GEM_OPEN, as we
don't implement prime/dma-buf yet in OpenBSD.  That still leaves a big gaping
hole, so they will be removed as soon as we can.

Based on a diff by robert@@, who did all the heavy lifting by studying the
behaviour of the chromium GPU process, with some further suggestions by
deraadt@@.

ok jsg@@, deraadt@@, robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.141 2016/01/05 18:09:24 deraadt Exp $	*/
d874 1
a874 1
		vp = (struct vnode *)fp->f_data;
d906 1
a906 1
		vp = (struct vnode *)fp->f_data;
d1150 1
a1150 1
		vp = (struct vnode *)fp->f_data;
@


1.141
log
@annoying whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.140 2015/12/27 16:36:07 tb Exp $	*/
d70 5
d346 1
d1132 1
d1184 12
d1328 1
a1328 1
	return pledge_fail(p, EPERM, PLEDGE_IOCTL);
@


1.140
log
@Add missing #include "audio.h".  Fixes sndiod pledge issue reported by
timo.myyra () wickedbsd ! net, thanks!
While there, remove extraneous "pty.h".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.139 2015/12/27 01:37:46 deraadt Exp $	*/
d79 1
a79 1
	 * Minimum required 
d159 1
a159 1
	/* Common signal operations */ 
@


1.139
log
@wrap "audio" pledge code in NAUDIO > 0, because there are a few
GENERIC kernels which lack audio drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.138 2015/12/23 21:07:57 deraadt Exp $	*/
d67 1
a67 1
#include "pty.h"
@


1.138
log
@pledge "audio" code block must be !SMALL_KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.137 2015/12/23 20:09:47 ratchov Exp $	*/
d68 1
d1178 1
a1178 1
#ifndef SMALL_KERNEL
d1191 1
a1191 1
#endif /* !SMALL_KERNEL */
@


1.137
log
@If PLEDGE_AUDIO is set, allow audio(4) ioctls necessary
to use raw audio devices.

ok deraadt, semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.136 2015/12/06 17:50:21 deraadt Exp $	*/
d1177 1
d1190 1
@


1.136
log
@Change kernel internal pledge variables to 64bit (to prepare for more
extensions).  This change is exposed in ktrace.out files
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.135 2015/12/05 19:21:49 deraadt Exp $	*/
d43 1
d1173 15
@


1.135
log
@Study of kernel code complete. Permit ioctl SIOCGIFMEDIA for pledge
"route", which krw and mestre will be able to use in dhclient(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.134 2015/12/04 16:56:35 deraadt Exp $	*/
d75 1
a75 1
const u_int pledge_syscalls[SYS_MAXSYSCALL] = {
d371 1
a371 1
	int flags = 0;
d566 1
a566 1
pledge_fail(struct proc *p, int error, int code)
@


1.134
log
@allow utrace(2) by default.
conversation with jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.133 2015/12/04 13:05:34 semarie Exp $	*/
d1283 1
@


1.133
log
@remove PLEDGE_INET granting when using "getpw" in YP environnment

it makes PLEDGE_YPACTIVE enough for doing required networking with YP. It
should permit to bring YP internals into the light.

discuted with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.132 2015/12/04 07:33:05 deraadt Exp $	*/
d86 1
@


1.132
log
@Add pledge "dpath", which provides access to mknod(2) and mkfifo(2).
This will be required to keep pax/tar/cpio at otherwise very high levels
of pledge (and we will see where else it is beneficial).
Allocate a bit for pledge "audio", which will be coming soon.
good discussions with semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.131 2015/12/04 06:01:55 deraadt Exp $	*/
d315 2
a316 2
	[SYS_bind] = PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS,
	[SYS_getsockname] = PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS,
d707 1
a707 2
				p->p_p->ps_pledge |=
				    PLEDGE_YPACTIVE | PLEDGE_INET;
d1112 1
a1112 1
	if ((p->p_p->ps_pledge & (PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS)))
d1308 1
a1308 1
	if ((p->p_p->ps_pledge & (PLEDGE_INET|PLEDGE_UNIX|PLEDGE_DNS)) == 0)
d1329 19
@


1.131
log
@Do not think atomicity is required here.  In any case, prepare for
ps_pledge to become 64-bits over the next few days (things are getting
a bit tight; most newer pledges will be quite device-driver specific)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.130 2015/12/03 16:50:44 bluhm Exp $	*/
d278 3
d333 1
d337 1
@


1.130
log
@Remove the /usr/share/nls/ exception from pledge(2).  The libc
native language support was deleted a month ago at u2k15.
OK semarie@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.129 2015/12/03 16:05:51 benno Exp $	*/
d702 2
a703 2
				atomic_setbits_int(&p->p_p->ps_pledge,
				    PLEDGE_YPACTIVE | PLEDGE_INET);
@


1.129
log
@pledge(pf) needs to allow DIOCKILLSRCNODES, used in relayd.
ok deaadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.128 2015/11/29 03:23:19 deraadt Exp $	*/
a717 7
			return (0);

		/* /usr/share/nls/../libc.cat has to succeed for strerror(3). */
		if ((ni->ni_pledge == PLEDGE_RPATH) &&
		    strncmp(path, "/usr/share/nls/",
		    sizeof("/usr/share/nls/") - 1) == 0 &&
		    strcmp(path + strlen(path) - 9, "/libc.cat") == 0)
@


1.128
log
@On a SMALL_KERNEL, pledge "pf" has to be a no-op.  We cannot match
the device node (since it does not exist...)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.127 2015/11/29 01:15:49 benno Exp $	*/
d1217 1
@


1.127
log
@Add pledge "pf" which allows ioctls on pf(4). This will be used by
relayd and other programs manipulating the packet filter.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.126 2015/11/28 18:10:12 benno Exp $	*/
d1204 1
d1223 1
@


1.126
log
@pledge: allow getsockopt IP_IPDEFTTL with promise inet
then relayd's host check engine can be pledged.
ok reyk@@, approach suggested by deraadt@@ weeks ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.125 2015/11/27 18:54:47 jca Exp $	*/
d51 1
d341 1
d1203 21
d1309 1
a1309 1
	 	return pledge_fail(p, EPERM, PLEDGE_INET);
d1502 1
a1502 1
        if (!(p->p_p->ps_pledge & PLEDGE_PROTEXEC) && (prot & PROT_EXEC))
@


1.125
log
@Two additional ioctls for pledge("disklabel"), needed by installboot.

Committing on behalf of tb@@, problem reported by Rolf Sommerhalder on misc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.124 2015/11/25 15:53:01 deraadt Exp $	*/
d1342 1
@


1.124
log
@permit kern.maxpartitions
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.123 2015/11/24 23:59:22 deraadt Exp $	*/
d1181 1
d1183 1
@


1.123
log
@Add sendsyslog2(), which accepts the syslog/openlog "logopt" flag
LOG_CONS. If syslogd is not accepting messages, direct them to the console.
This allows us to remove the direct /dev/console opening code from the
bowels of libc.  Of course, that forgotten code was exposed by pledge.
ok kettenis millert beck
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.122 2015/11/23 21:32:29 deraadt Exp $	*/
d1003 4
@


1.122
log
@the "getpw" test for /dev/tty is only needed for readpassphrase(3),
getpass(3), so don't specifically allow it for "rpath" (rpath will
accept it in the end, unless it is on the whitelist)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.121 2015/11/23 07:23:24 deraadt Exp $	*/
d83 1
d641 9
@


1.121
log
@need sys/device.h
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.120 2015/11/22 18:50:45 deraadt Exp $	*/
d648 2
a649 2
		/* readpassphrase(3), getpw*(3) */
		if ((p->p_p->ps_pledge & (PLEDGE_TTY | PLEDGE_GETPW)) &&
@


1.120
log
@For "disklabel", allow sysctl mach.chr2kblk and ioctl BIOCINQ/BIOCVOL
also, to satisfy midlayers that some fs/install tools need.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.119 2015/11/22 18:48:16 deraadt Exp $	*/
d39 1
@


1.119
log
@"getpw" should also allow access to /etc/netid
discovered by rpe
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.118 2015/11/20 20:59:52 deraadt Exp $	*/
d58 3
d993 6
d1166 2
@


1.118
log
@Permit msync(2) in the "stdio" set; only a few programs use it related
to mmap, but thinking about it nothing feels risky
Long discussions with florian
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.117 2015/11/20 16:06:54 deraadt Exp $	*/
d659 2
@


1.117
log
@Add pledge "disklabel", which allows sysctl kern.rawpartition, a
few disklabel ioctls, and the DIOCMAP ioctl against /dev/diskmap used
to translate duid numbers into partitions.
This will allow pledging of at least 12 disk/filesystem aware
programs; due to the negative impact that diff will wait a bit so
everyone has a chance to update their kernels.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.116 2015/11/20 07:15:30 deraadt Exp $	*/
d119 1
@


1.116
log
@Exempt accept(2) from the pledge_socket() check part of the "domain"
check.  You cannot open a socket in a domain unless permitted -- but
you need to be able to accept one if the code flow asks for that to
happen.  The most recent check is too tight. We may need to iterate the
policy here until we hit the right vibe...
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.115 2015/11/18 08:24:22 semarie Exp $	*/
d39 2
d324 1
d982 7
d1143 22
@


1.115
log
@check domain and state of socket against pledge promise.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.114 2015/11/17 15:03:53 sthen Exp $	*/
d1332 2
@


1.114
log
@backout removal of SYS_break from stdio, suggested by deraadt@@

ports using base gcc with PCH include: boost, keepassx, wxWidgets, jdk
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.113 2015/11/17 04:09:35 deraadt Exp $	*/
d1320 1
a1320 1
pledge_socket(struct proc *p, int dns)
d1322 22
a1343 2
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);
d1345 1
a1345 5
	if (dns && (p->p_p->ps_pledge & PLEDGE_DNS))
		return (0);
	if ((p->p_p->ps_pledge & (PLEDGE_INET|PLEDGE_UNIX|PLEDGE_YPACTIVE)))
		return (0);
	return pledge_fail(p, EPERM, dns ? PLEDGE_DNS : PLEDGE_INET);
@


1.113
log
@Allow sysctl kern.clockrate, kern.argmax, kern.ngroups, kern.sysvshm,
and kern.posix1version.  Enough to satisfy getconf, and I hope we
don't need to add much more after this.
Largely from jca
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.112 2015/11/16 21:20:20 deraadt Exp $	*/
d117 1
@


1.112
log
@Allow TIOCEXT in pledge "tty"
Discussed with millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.111 2015/11/16 18:29:35 deraadt Exp $	*/
d982 1
a982 1
	if (miblen == 2 &&			/* getdomainname() */
d985 1
a985 1
	if (miblen == 2 &&			/* gethostname() */
d992 1
a992 1
	if (miblen == 2 &&			/* uname() */
d995 1
a995 1
	if (miblen == 2 &&			/* uname() */
d998 1
a998 1
	if (miblen == 2 &&			/* uname() */
d1001 1
a1001 1
	if (miblen == 2 &&			/* uname() */
d1004 1
a1004 1
	if (miblen == 2 &&			/* kern.clockrate */
d1007 13
a1019 1
	if (miblen == 2 &&			/* uname() */
d1022 1
a1022 1
	if (miblen == 2 &&			/* getpagesize() */
d1025 1
a1025 1
	if (miblen == 2 &&			/* setproctitle() */
d1028 1
a1028 1
	if (miblen == 2 &&			/* hw.ncpu */
@


1.111
log
@Permit revoke(2) for a pledge "rpath tty"
ok millert semarie tedu guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.110 2015/11/16 17:41:45 pascal Exp $	*/
d1155 1
@


1.110
log
@brk/sbrk's use case is way too narrow to be a default stdio pledge.

Since this only affects base gcc and the ports most in need of PCHs are
compiled with ports compilers anyway, let's see what happens if we break it.

discussed with and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.109 2015/11/14 22:23:22 deraadt Exp $	*/
d269 2
@


1.109
log
@Add pathconf() to pledge "rpath"; ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.108 2015/11/14 07:02:23 deraadt Exp $	*/
a116 1
	[SYS_break] = PLEDGE_STDIO,
@


1.108
log
@For pledge "stdio", allow the break(2) system call which backends the brk/sbrk
library routines.  The manpage declares, in bold:

     The brk() and sbrk() functions are historical curiosities left over from
     earlier days before the advent of virtual memory management.

In our base tree, only one program uses these functions -- cc1 in the
gcc toolset.  A historical curiosity using a historical curiosity, how
quaint.  brk is used because precompiled c headers are not position
independent.  Another program which relies upon brk is emacs.  Other
uses of brk are EXCEEDINGLY RARE, because most software grew up and
use modern practices such as malloc and mmap, thereby gaining ASLR
benefits.  Position independence has become an important part of
mitigations.  These two programs fight such improvements.

Permitting brk/sbrk allows the large attack surface of cc1 to be pledged.

"I would rather have cc1 pledged than purity in pledge" guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.107 2015/11/13 17:12:01 deraadt Exp $	*/
d282 1
@


1.107
log
@All setsockopt IPPROTO_IPV6 IPV6_TCLASS (v4 calls this IP_TOS)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.106 2015/11/10 04:30:59 guenther Exp $	*/
d117 1
@


1.106
log
@Split the intra-thread functionality from kill(2) into its own syscall
thrkill(2), rolling the kill(2) syscall number with the ABI change to
avoid breaking binaries during during the transition.  thrkill(2) includes
a 'tcb' argument that eliminates the need for locking in pthread_kill()
and simplifies pthread_cancel().  Switch __stack_smash_handler() to use
thrkill(2) and explicitly unblock SIGABRT.

Minor bump to both libc and libpthread: make sure you install a new kernel!

ok semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.105 2015/11/05 15:10:11 semarie Exp $	*/
d1278 1
@


1.105
log
@revert sys/kern/kern_pledge.c 1.103 and reenable pledge in pwd_mkdb

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.104 2015/11/04 21:24:23 tedu Exp $	*/
d77 1
d194 1
d1369 1
a1369 1
	if (pid == 0 || pid == p->p_p->ps_pid || pid > THREAD_PID_OFFSET)
@


1.104
log
@pledge_ioctl only takes files, adjust prototype. ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.103 2015/11/04 19:18:21 semarie Exp $	*/
a601 12
	/* Blacklisted paths */
	switch (p->p_pledge_syscall) {
	case SYS_stat:
	case SYS_lstat:
	case SYS_fstatat:
	case SYS_fstat:
		break;
	default:
		if (strcmp(path, "/etc/spwd.db") == 0)
			return (EPERM);
	}

d644 2
@


1.103
log
@move /etc/spwd.db blacklist outside PLEDGE_GETPW check.
so that all pledged programs would get it instead of only ones with PLEDGE_GETPW.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.102 2015/11/03 16:14:14 deraadt Exp $	*/
d1076 1
a1076 1
pledge_ioctl(struct proc *p, long com, void *v)
a1077 1
	struct file *fp = v;
d1095 2
a1096 1
	vp = (struct vnode *)fp->f_data;
@


1.102
log
@pledge_aftersyscall has been reduced to one case, "getpw", to open a
window for chatting to ypserv.  This can be done in pledge_namei, so
improve system call performance by removing the pledge_aftersyscall hook.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.101 2015/11/02 23:17:23 tedu Exp $	*/
d602 12
a655 2
			if (strcmp(path, "/etc/spwd.db") == 0)
				return (EPERM);
@


1.101
log
@some tweaks to the signal code.
allow signals to any thread (they'll be checked within process later).
guenther also notes the pid check should be process pid, not proc pid.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.100 2015/11/02 17:53:00 semarie Exp $	*/
a525 1
	p->p_pledgeafter = 0;	/* XX optimise? */
d666 10
a675 1
				p->p_pledgeafter |= PLEDGE_YPACTIVE;
a816 7
}

void
pledge_aftersyscall(struct proc *p, int code, int error)
{
	if ((p->p_pledgeafter & PLEDGE_YPACTIVE) && error == 0)
		atomic_setbits_int(&p->p_p->ps_pledge, PLEDGE_YPACTIVE | PLEDGE_INET);
@


1.100
log
@use binary-search for pledge-request

(semblable diff proposed by Peter J. Philipp)

"no problem" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.99 2015/11/02 16:31:55 semarie Exp $	*/
d1366 1
a1366 1
	if (pid == 0 || pid == p->p_pid || pid == p->p_pid + THREAD_PID_OFFSET)
@


1.99
log
@move the pledgenote annotation from `struct proc' to `struct nameidata'

pledgenote is used for annotate the policy for a namei context. So make it
tracking the nameidata.

It is expected for the caller to explicitly define the policy. It is a kernel
bug to not do so.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.98 2015/11/02 15:33:40 deraadt Exp $	*/
d61 1
d314 2
a315 6
	{ "stdio",		PLEDGE_STDIO },
	{ "rpath",		PLEDGE_RPATH },
	{ "wpath",		PLEDGE_WPATH },
	{ "tmppath",		PLEDGE_TMPPATH },
	{ "inet",		PLEDGE_INET },
	{ "unix",		PLEDGE_UNIX },
d317 3
d321 2
a322 2
	{ "sendfd",		PLEDGE_SENDFD },
	{ "recvfd",		PLEDGE_RECVFD },
a323 2
	{ "id",			PLEDGE_ID },
	{ "route",		PLEDGE_ROUTE },
a324 1
	{ "tty",		PLEDGE_TTY },
a325 3
	{ "exec",		PLEDGE_EXEC },
	{ "cpath",		PLEDGE_CPATH },
	{ "fattr",		PLEDGE_FATTR },
a326 1
	{ "flock",		PLEDGE_FLOCK },
d328 9
d338 1
a338 2
	{ "settime",		PLEDGE_SETTIME },
	{ "abort",		0 },	/* XXX reserve for later */
d354 1
a354 1
		int f, i;
d375 1
a375 7
			for (f = i = 0; i < nitems(pledgereq); i++) {
				if (strcmp(rp, pledgereq[i].name) == 0) {
					f = pledgereq[i].flags;
					break;
				}
			}
			if (f == 0) {
d1328 19
@


1.98
log
@also handle the kill(self) case for threads; from Theo Buehler
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.97 2015/11/01 19:03:33 semarie Exp $	*/
d28 1
d531 1
a531 1
	p->p_pledgenote = p->p_pledgeafter = 0;	/* XX optimise? */
d585 1
a585 1
pledge_namei(struct proc *p, char *origpath)
d593 4
a596 1
	if (p->p_pledgenote == PLEDGE_COREDUMP)
d600 1
a600 1
	if ((p->p_pledgenote & PLEDGE_EXEC) &&
d611 1
a611 1
	    (p->p_pledgenote & PLEDGE_CPATH) &&
d629 1
a629 1
		if ((p->p_pledgenote == PLEDGE_RPATH) &&
d635 1
a635 1
		if ((p->p_pledgenote & ~(PLEDGE_RPATH | PLEDGE_WPATH)) == 0 &&
d642 1
a642 1
		    (p->p_pledgenote & ~(PLEDGE_RPATH | PLEDGE_WPATH)) == 0 &&
d648 1
a648 1
		if ((p->p_pledgenote == PLEDGE_RPATH) &&
d659 1
a659 1
		if ((p->p_pledgenote == PLEDGE_RPATH) &&
d669 1
a669 1
		if ((p->p_pledgenote == PLEDGE_RPATH) &&
d681 1
a681 1
		if ((p->p_pledgenote == PLEDGE_RPATH) &&
d685 1
a685 1
		if ((p->p_pledgenote == PLEDGE_RPATH) &&
d690 1
a690 1
		if ((p->p_pledgenote == PLEDGE_RPATH) &&
d699 1
a699 1
		if ((p->p_pledgenote == PLEDGE_RPATH) &&
d705 1
a705 1
		if ((p->p_pledgenote == PLEDGE_RPATH) &&
d716 2
a717 12
	if (p->p_pledgenote & ~p->p_p->ps_pledge)
		return (pledge_fail(p, EPERM, (p->p_pledgenote &
		    ~p->p_p->ps_pledge)));

	/* generic check for unsetted p_pledgenote */
	if (p->p_pledgenote == 0) {
		//printf("pledge_namei: %s(%d): syscall %d p_pledgenote=0\n",
		//    p->p_comm, p->p_pid, p->p_pledge_syscall);

		if ((p->p_p->ps_pledge & (PLEDGE_RPATH | PLEDGE_WPATH | PLEDGE_CPATH)) == 0)
			return (pledge_fail(p, EPERM, PLEDGE_RPATH));
	}
d806 1
a806 1
				p->p_pledgenote |= PLEDGE_STATLIE;
@


1.97
log
@refactor pledge_*_check and pledge_fail functions

- rename _check function without suffix: a "pledge" function called from
  anywhere is a "check" function.

- makes pledge_fail call the responsability to the _check function. remove it
  from caller.

- make proper use of (potential) returned error of _check() functions.

- adds pledge_kill() and pledge_protexec()

with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.96 2015/11/01 15:43:50 deraadt Exp $	*/
d1358 1
a1358 1
	if (pid == 0 || pid == p->p_pid)
@


1.96
log
@Do not need to check the pledge control bits for system calls that are
PLEDGE_ALWAYS.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.95 2015/11/01 13:01:58 semarie Exp $	*/
d31 1
d528 1
a528 1
pledge_check(struct proc *p, int code, int *tval)
d589 3
d833 1
a833 1
pledge_recvfd_check(struct proc *p, struct file *fp)
d864 1
a864 1
pledge_sendfd_check(struct proc *p, struct file *fp)
d893 1
a893 1
pledge_sysctl_check(struct proc *p, int miblen, int *mib, void *new)
d899 1
a899 1
		return (EFAULT);
d1031 1
a1031 1
	return (EPERM);
d1035 1
a1035 1
pledge_chown_check(struct proc *p, uid_t uid, gid_t gid)
d1048 1
a1048 1
pledge_adjtime_check(struct proc *p, const void *v)
d1058 1
a1058 1
		return (EFAULT);
d1063 1
a1063 1
pledge_sendit_check(struct proc *p, const void *to)
d1072 1
a1072 1
	return (EPERM);
d1076 1
a1076 1
pledge_ioctl_check(struct proc *p, long com, void *v)
d1197 1
a1197 1
pledge_sockopt_check(struct proc *p, int set, int level, int optname)
d1214 1
a1214 1
	 	return (EINVAL);
d1238 1
a1238 1
		return (EINVAL);
d1243 1
a1243 1
			return (EINVAL);
d1249 1
a1249 1
		return (EINVAL);
d1306 1
a1306 1
	return (EPERM);
d1310 1
a1310 1
pledge_socket_check(struct proc *p, int dns)
d1319 1
a1319 1
	return (EPERM);
d1323 1
a1323 1
pledge_flock_check(struct proc *p)
d1334 1
a1334 1
pledge_swapctl_check(struct proc *p)
d1342 1
a1342 1
pledge_fcntl_check(struct proc *p, int cmd)
d1346 2
a1347 3
	if ((p->p_p->ps_pledge & PLEDGE_PROC) == 0 &&
	    cmd == F_SETOWN)
		return (EPERM);
d1349 22
@


1.95
log
@uniformize "always allowed syscalls" with pledge

- use a proper name PLEDGE_ALWAYS (suggested by derradt@@)
- unify the check for allowing it in order to allow all of them

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.94 2015/10/31 21:53:53 deraadt Exp $	*/
d536 1
a536 1
	if ((p->p_p->ps_pledge == 0) && (pledge_syscalls[code] == PLEDGE_ALWAYS))
@


1.94
log
@oops, forgot pselect!  crazy how many interface the kernel has here.
It is just risk, risk, risk, risk.  Is there anyway to unify them?
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.93 2015/10/31 02:46:23 deraadt Exp $	*/
d69 5
a73 5
	[SYS_exit] = 0xffffffff,
	[SYS_kbind] = 0xffffffff,
	[SYS___get_tcb] = 0xffffffff,
	[SYS_pledge] = 0xffffffff,
	[SYS_sendsyslog] = 0xffffffff,	/* stack protector reporting */
d536 1
a536 2
	if ((p->p_p->ps_pledge == 0) &&
	    (code == SYS_exit || code == SYS_kbind))
@


1.93
log
@expose the sysctl backing getloadavg(3) all the time, now that more
consumers have been found.  Spotted by Nathanael Rensen
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.92 2015/10/29 15:04:54 deraadt Exp $	*/
d161 1
@


1.92
log
@Add some setsockopt hacks for libisc, aka John Frum
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.91 2015/10/29 12:51:06 deraadt Exp $	*/
a929 3
		if (miblen == 2 &&		/* kern.loadavg */
		    mib[0] == CTL_VM && mib[1] == VM_LOADAVG)
			return (0);
d1019 3
@


1.91
log
@Reorder system call table into sequential blocks of alike-functionality
and similar usage cases.  Should provide abit more clarity for those
who read the kernel code.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.90 2015/10/28 17:38:52 deraadt Exp $	*/
d1219 12
@


1.90
log
@cleanup indentation and comments in sysctl whitelist
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.89 2015/10/28 15:33:44 semarie Exp $	*/
d62 3
d66 3
d72 2
d75 1
d97 17
a114 1
	[SYS_sysctl] = PLEDGE_STDIO,	/* read-only; narrow subset */
d116 13
a128 2
	[SYS_setsockopt] = PLEDGE_STDIO,	/* white list */
	[SYS_getsockopt] = PLEDGE_STDIO,
d130 5
a134 1
	[SYS_fchdir] = PLEDGE_STDIO,	/* careful of directory fd inside jails */
d136 5
a140 7
	/* needed by threaded programs */
	[SYS___tfork] = PLEDGE_PROC,
	[SYS_sched_yield] = PLEDGE_STDIO,
	[SYS___thrsleep] = PLEDGE_STDIO,
	[SYS___thrwakeup] = PLEDGE_STDIO,
	[SYS___threxit] = PLEDGE_STDIO,
	[SYS___thrsigdivert] = PLEDGE_STDIO,
d142 1
a142 1
	[SYS_sendsyslog] = PLEDGE_STDIO,
d153 3
a155 8
	[SYS_pledge] = PLEDGE_STDIO,

	[SYS_wait4] = PLEDGE_STDIO,

	[SYS_adjtime] = PLEDGE_STDIO,	/* read-only, unless "settime" */
	[SYS_adjfreq] = PLEDGE_SETTIME,
	[SYS_settimeofday] = PLEDGE_SETTIME,

d162 9
d177 1
a177 11
	[SYS_read] = PLEDGE_STDIO,
	[SYS_readv] = PLEDGE_STDIO,
	[SYS_pread] = PLEDGE_STDIO,
	[SYS_preadv] = PLEDGE_STDIO,
	[SYS_write] = PLEDGE_STDIO,
	[SYS_writev] = PLEDGE_STDIO,
	[SYS_pwrite] = PLEDGE_STDIO,
	[SYS_pwritev] = PLEDGE_STDIO,
	[SYS_ftruncate] = PLEDGE_STDIO,
	[SYS_lseek] = PLEDGE_STDIO,
	[SYS_fstat] = PLEDGE_STDIO,
a178 2
	[SYS_fcntl] = PLEDGE_STDIO,
	[SYS_fsync] = PLEDGE_STDIO,
a181 1
	[SYS_getdents] = PLEDGE_STDIO,
d183 38
a220 4
	[SYS_sendto] = PLEDGE_STDIO | PLEDGE_YPACTIVE,
	[SYS_sendmsg] = PLEDGE_STDIO,
	[SYS_recvmsg] = PLEDGE_STDIO,
	[SYS_recvfrom] = PLEDGE_STDIO | PLEDGE_YPACTIVE,
a225 1
	[SYS_kill] = PLEDGE_STDIO | PLEDGE_PROC,
a229 1
	/* XXX we should limit the power for the "proc"-only case */
a244 16
	/* FIONREAD/FIONBIO, plus further checks in pledge_ioctl_check() */
	[SYS_ioctl] = PLEDGE_STDIO | PLEDGE_IOCTL | PLEDGE_TTY,

	[SYS_getentropy] = PLEDGE_STDIO,
	[SYS_madvise] = PLEDGE_STDIO,
	[SYS_minherit] = PLEDGE_STDIO,
	[SYS_mmap] = PLEDGE_STDIO,
	[SYS_mprotect] = PLEDGE_STDIO,
	[SYS_mquery] = PLEDGE_STDIO,
	[SYS_munmap] = PLEDGE_STDIO,

	[SYS_open] = PLEDGE_STDIO,		/* further checks in namei */
	[SYS_stat] = PLEDGE_STDIO,		/* further checks in namei */
	[SYS_access] = PLEDGE_STDIO,		/* further checks in namei */
	[SYS_readlink] = PLEDGE_STDIO,		/* further checks in namei */

a245 1
	[SYS_chroot] = PLEDGE_ID,
d262 2
d271 1
@


1.89
log
@merge whitelisted r/w paths and rd paths switch to only one. It becomes
possible due to the move of failing case later.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.88 2015/10/28 14:07:58 semarie Exp $	*/
d865 1
a865 1
		if (miblen == 7 &&			/* exposes MACs */
d874 1
a874 1
		if (miblen == 2 &&			/* kern.fscale */
d877 1
a877 1
		if (miblen == 2 &&			/* kern.boottime */
d880 1
a880 1
		if (miblen == 2 &&			/* kern.consdev */
d883 1
a883 1
		if (miblen == 2 &&			/* kern.loadavg */
d895 1
a895 1
		if (miblen == 4 &&			/* kern.procargs.* */
d899 1
a899 1
		if (miblen == 6 &&			/* kern.proc.* */
d902 1
a902 1
		if (miblen == 3 &&			/* kern.proc_cwd.* */
d905 1
a905 1
		if (miblen == 2 &&			/* hw.physmem */
d908 1
a908 1
		if (miblen == 2 &&			/* kern.ccpu */
d911 1
a911 1
		if (miblen == 2 &&			/* vm.maxslp */
d917 1
a917 1
		if (miblen == 2 &&			/* vm.uvmexp */
d920 1
a920 1
		if (miblen == 3 &&			/* vfs.generic.bcachestat */
d935 1
a935 2
	/* used by ntpd(8) to read sensors. */
	if (miblen >= 3 &&
@


1.88
log
@make sys_chroot() only allowed to be used when pledged, with "rpath id proc".

the previous check in pledge_namei() was incomplete. For using SYS_chroot we
needed "id", and we could have passed pledge_namei() just with "rpath" (without
using the now removed whitelisted entry).

the check for "rpath id proc" is now done using p_pledgenote: pledge_namei()
will check that the pledgenote is permitted by your pledge.

"go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.87 2015/10/28 13:59:07 semarie Exp $	*/
d570 1
a570 1
	/* Whitelisted read/write paths */
d572 6
a590 2
		break;
	}
a591 9
	/* Whitelisted read-only paths */
	switch (p->p_pledge_syscall) {
	case SYS_access:
		/* tzset() needs this. */
		if ((p->p_pledgenote == PLEDGE_RPATH) &&
		    strcmp(path, "/etc/localtime") == 0)
			return (0);
		break;
	case SYS_open:
@


1.87
log
@refactor pledge_namei() a bit

- remove all explicit checks that ensure p_pledgenote have counterpart in
  ps_pledge by one unique check. It makes management of explicit whitelisted
  operations on some paths more simple to manage. And now, we can use
  p_pledgenote for more fined checking in namei usage.

- add special case for unsetted p_pledgenote: the behaviour is the same as
  previously (we allow the operation with "rpath", "wpath" or "cpath" request)
  but it should be changed soon to be more strict.

"go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.86 2015/10/28 13:42:57 semarie Exp $	*/
a657 5
			return (0);
		break;
	case SYS_chroot:
		/* Allowed for "proc id" */
		if ((p->p_p->ps_pledge & PLEDGE_PROC))
@


1.86
log
@canonpath() error isn't related to p_pledgenote requirement (only possible
error currently is ENAMETOOLONG), so don't use p_pledgenote when failing.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.85 2015/10/28 13:36:38 semarie Exp $	*/
a552 6
	/* chmod(2), chflags(2), ... */
	if ((p->p_pledgenote & PLEDGE_FATTR) &&
	    (p->p_p->ps_pledge & PLEDGE_FATTR) == 0) {
		return (pledge_fail(p, EPERM, PLEDGE_FATTR));
	}

a569 5
	/* open, mkdir, or other path creation operation */
	if ((p->p_pledgenote & PLEDGE_CPATH) &&
	    ((p->p_p->ps_pledge & PLEDGE_CPATH) == 0))
		return (pledge_fail(p, EPERM, PLEDGE_CPATH));

a587 5
	/* ensure PLEDGE_WPATH request for doing write */
	if ((p->p_pledgenote & PLEDGE_WPATH) &&
	    (p->p_p->ps_pledge & PLEDGE_WPATH) == 0)
		return (pledge_fail(p, EPERM, PLEDGE_WPATH));

d667 16
a682 4
	/* ensure PLEDGE_RPATH request for doing read */
	if ((p->p_pledgenote & PLEDGE_RPATH) &&
	    (p->p_p->ps_pledge & PLEDGE_RPATH) == 0)
		return (pledge_fail(p, EPERM, PLEDGE_RPATH));
d778 1
a778 8
	if (p->p_p->ps_pledge & PLEDGE_RPATH)
		return (0);
	if (p->p_p->ps_pledge & PLEDGE_WPATH)
		return (0);
	if (p->p_p->ps_pledge & PLEDGE_CPATH)
		return (0);

	return (pledge_fail(p, EPERM, p->p_pledgenote));
@


1.85
log
@in pledge_namei(), move PLEDGE_EXEC check sooner: it doesn't depend of path
processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.84 2015/10/28 12:17:20 deraadt Exp $	*/
d551 1
a551 1
		return (pledge_fail(p, error, p->p_pledgenote));
d735 1
a735 1
			return (pledge_fail(p, error, p->p_pledgenote));
@


1.84
log
@Prevent F_SETOWN, unless a "proc" pledge was made.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.83 2015/10/28 12:03:39 deraadt Exp $	*/
d544 5
a579 5

	/* Doing a permitted execve() */
	if ((p->p_pledgenote & PLEDGE_EXEC) &&
	    (p->p_p->ps_pledge & PLEDGE_EXEC))
		return (0);
@


1.83
log
@The short-lived dnssocket/dnsconnect calls are being required because we
suspect everyone has upgraded through the approx week-long window since
SOCK_DNS became available and the libc resolver started using them.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.82 2015/10/28 09:35:03 deraadt Exp $	*/
d1298 11
@


1.82
log
@kern.cptime is length 2
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.81 2015/10/28 02:12:54 deraadt Exp $	*/
a247 4

	/* XXX remove this, and the code in uipc_syscalls.c */
	[SYS_dnssocket] = PLEDGE_DNS,
	[SYS_dnsconnect] = PLEDGE_DNS,
@


1.81
log
@support kern.cptime also
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.80 2015/10/26 17:52:19 deraadt Exp $	*/
d911 1
a911 1
		if (miblen == 3 &&			/* kern.cptime */
@


1.80
log
@Add ppoll() to "stdio"
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.79 2015/10/26 12:13:45 deraadt Exp $	*/
d910 3
@


1.79
log
@Allow NET_RT_IFLIST in pledge "dns" as well
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.78 2015/10/26 11:17:52 deraadt Exp $	*/
d124 1
@


1.78
log
@If the system call is entirely unpermitted, code will be 0, and there is
no pledge to recommend.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.77 2015/10/26 11:11:45 deraadt Exp $	*/
d947 1
a947 1
	if ((p->p_p->ps_pledge & (PLEDGE_ROUTE | PLEDGE_INET))) {
@


1.77
log
@add setreuid/setregid to "id"
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.76 2015/10/26 07:44:43 semarie Exp $	*/
d505 1
d509 3
a511 2
	for (i = 0; pledgenames[i].bits != 0; i++)
		if (pledgenames[i].bits & code)
d513 1
d515 1
a515 1
	    p->p_pledge_syscall, pledgenames[i].name);
@


1.76
log
@change some pledge_fail() error/code

- for PLEDGE_FATTR: the code is more accurate to be PLEDGE_FATTR, has
  p->p_pledgenote could have multiple bits inside, and it is the lake of
  PLEDGE_FATTR that make the check fail.

- for PLEDGE_RECVFD and PLEDGE_SENDFD, change the error to be EINVAL: we fail,
  not because of lake of PLEDGE_RECVFD / PLEDGE_SENDFD permission, but because
  the value passed is invalid in pledged program (for example trying to send a
  VDIR).

"go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.75 2015/10/26 07:24:20 semarie Exp $	*/
d172 1
d176 1
@


1.75
log
@make pledge_check(), used for syscall check with pledge, returns an error and
provide the required pledge request for pledge_fail().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.74 2015/10/25 20:39:54 deraadt Exp $	*/
d549 1
a549 1
		return (pledge_fail(p, EPERM, p->p_pledgenote));
d825 1
a825 1
	return pledge_fail(p, EPERM, PLEDGE_RECVFD);
d857 1
a857 1
	return pledge_fail(p, EPERM, PLEDGE_SENDFD);
@


1.74
log
@Fold "malloc" into "stdio" and -- recognizing that no program so far has
used less than "stdio" -- include all the "self" operations.  Instead of
different defines, use regular PLEDGE_* in the "p_pledgenote" variable
(which indicates the operation subtype a system call is performing).  Many
checks before easier to understand.  p_pledgenote can often be passed
directly to ktrace, so that kdump says:
 15565 test     CALL  pledge(0xa9a3f804c51,0)
 15565 test     STRU  pledge request="stdio"
 15565 test     RET   pledge 0
 15565 test     CALL  open(0xa9a3f804c57,0x2<O_RDWR>)
 15565 test     NAMI  "/tmp/testfile"
 15565 test     PLDG  open, "wpath", errno 1 Operation not permitted
with help from semarie, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.73 2015/10/25 17:45:29 deraadt Exp $	*/
d480 1
a480 1
pledge_check(struct proc *p, int code)
d484 1
d487 7
d496 2
a497 3
	if (p->p_p->ps_pledge == 0)
		return (code == SYS_exit || code == SYS_kbind);
	return (p->p_p->ps_pledge & pledge_syscalls[code]);
@


1.73
log
@pledge_sockopt_check is shared between setsockopt/getsockopt.  nicm
found the first case of "get allowed, set not allowed".  Tiny
refactoring of that.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.72 2015/10/25 11:09:28 semarie Exp $	*/
d54 1
d67 23
a89 23
	[SYS_getuid] = PLEDGE_SELF,
	[SYS_geteuid] = PLEDGE_SELF,
	[SYS_getresuid] = PLEDGE_SELF,
	[SYS_getgid] = PLEDGE_SELF,
	[SYS_getegid] = PLEDGE_SELF,
	[SYS_getresgid] = PLEDGE_SELF,
	[SYS_getgroups] = PLEDGE_SELF,
	[SYS_getlogin] = PLEDGE_SELF,
	[SYS_getpgrp] = PLEDGE_SELF,
	[SYS_getpgid] = PLEDGE_SELF,
	[SYS_getppid] = PLEDGE_SELF,
	[SYS_getsid] = PLEDGE_SELF,
	[SYS_getthrid] = PLEDGE_SELF,
	[SYS_getrlimit] = PLEDGE_SELF,
	[SYS_gettimeofday] = PLEDGE_SELF,
	[SYS_getdtablecount] = PLEDGE_SELF,
	[SYS_getrusage] = PLEDGE_SELF,
	[SYS_issetugid] = PLEDGE_SELF,
	[SYS_clock_getres] = PLEDGE_SELF,
	[SYS_clock_gettime] = PLEDGE_SELF,
	[SYS_getpid] = PLEDGE_SELF,
	[SYS_umask] = PLEDGE_SELF,
	[SYS_sysctl] = PLEDGE_SELF,	/* read-only; narrow subset */
d91 2
a92 2
	[SYS_setsockopt] = PLEDGE_SELF,	/* white list */
	[SYS_getsockopt] = PLEDGE_SELF,
d94 1
a94 1
	[SYS_fchdir] = PLEDGE_SELF,	/* careful of directory fd inside jails */
d98 16
a113 16
	[SYS_sched_yield] = PLEDGE_SELF,
	[SYS___thrsleep] = PLEDGE_SELF,
	[SYS___thrwakeup] = PLEDGE_SELF,
	[SYS___threxit] = PLEDGE_SELF,
	[SYS___thrsigdivert] = PLEDGE_SELF,

	[SYS_sendsyslog] = PLEDGE_SELF,
	[SYS_nanosleep] = PLEDGE_SELF,
	[SYS_sigaltstack] = PLEDGE_SELF,
	[SYS_sigprocmask] = PLEDGE_SELF,
	[SYS_sigsuspend] = PLEDGE_SELF,
	[SYS_sigaction] = PLEDGE_SELF,
	[SYS_sigreturn] = PLEDGE_SELF,
	[SYS_sigpending] = PLEDGE_SELF,
	[SYS_getitimer] = PLEDGE_SELF,
	[SYS_setitimer] = PLEDGE_SELF,
d115 1
a115 1
	[SYS_pledge] = PLEDGE_SELF,
d117 1
a117 1
	[SYS_wait4] = PLEDGE_SELF,
d119 1
a119 1
	[SYS_adjtime] = PLEDGE_SELF,	/* read-only, unless "settime" */
d123 34
a156 34
	[SYS_poll] = PLEDGE_RW,
	[SYS_kevent] = PLEDGE_RW,
	[SYS_kqueue] = PLEDGE_RW,
	[SYS_select] = PLEDGE_RW,

	[SYS_close] = PLEDGE_RW,
	[SYS_dup] = PLEDGE_RW,
	[SYS_dup2] = PLEDGE_RW,
	[SYS_dup3] = PLEDGE_RW,
	[SYS_closefrom] = PLEDGE_RW,
	[SYS_shutdown] = PLEDGE_RW,
	[SYS_read] = PLEDGE_RW,
	[SYS_readv] = PLEDGE_RW,
	[SYS_pread] = PLEDGE_RW,
	[SYS_preadv] = PLEDGE_RW,
	[SYS_write] = PLEDGE_RW,
	[SYS_writev] = PLEDGE_RW,
	[SYS_pwrite] = PLEDGE_RW,
	[SYS_pwritev] = PLEDGE_RW,
	[SYS_ftruncate] = PLEDGE_RW,
	[SYS_lseek] = PLEDGE_RW,
	[SYS_fstat] = PLEDGE_RW,

	[SYS_fcntl] = PLEDGE_RW,
	[SYS_fsync] = PLEDGE_RW,
	[SYS_pipe] = PLEDGE_RW,
	[SYS_pipe2] = PLEDGE_RW,
	[SYS_socketpair] = PLEDGE_RW,
	[SYS_getdents] = PLEDGE_RW,

	[SYS_sendto] = PLEDGE_RW | PLEDGE_YP_ACTIVE,
	[SYS_sendmsg] = PLEDGE_RW,
	[SYS_recvmsg] = PLEDGE_RW,
	[SYS_recvfrom] = PLEDGE_RW | PLEDGE_YP_ACTIVE,
d162 1
a162 1
	[SYS_kill] = PLEDGE_SELF | PLEDGE_PROC,
d167 1
a167 1
	/* XXX we should limit the power for the "proc"-only case */ 
d182 1
a182 1
	[SYS_ioctl] = PLEDGE_RW | PLEDGE_IOCTL | PLEDGE_TTY,
d184 12
a195 12
	[SYS_getentropy] = PLEDGE_MALLOC,
	[SYS_madvise] = PLEDGE_MALLOC,
	[SYS_minherit] = PLEDGE_MALLOC,
	[SYS_mmap] = PLEDGE_MALLOC,
	[SYS_mprotect] = PLEDGE_MALLOC,
	[SYS_mquery] = PLEDGE_MALLOC,
	[SYS_munmap] = PLEDGE_MALLOC,

	[SYS_open] = PLEDGE_SELF,			/* further checks in namei */
	[SYS_stat] = PLEDGE_SELF,			/* further checks in namei */
	[SYS_access] = PLEDGE_SELF,		/* further checks in namei */
	[SYS_readlink] = PLEDGE_SELF,		/* further checks in namei */
d241 2
a242 2
	[SYS_socket] = PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS | PLEDGE_YP_ACTIVE,
	[SYS_connect] = PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS | PLEDGE_YP_ACTIVE,
d255 1
a255 1
	[SYS_flock] = PLEDGE_FLOCK | PLEDGE_YP_ACTIVE,
d264 10
a273 12
	{ "malloc",		PLEDGE_SELF | PLEDGE_MALLOC },
	{ "rw",			PLEDGE_SELF | PLEDGE_RW },
	{ "stdio",		PLEDGE_SELF | PLEDGE_MALLOC | PLEDGE_RW },
	{ "rpath",		PLEDGE_SELF | PLEDGE_RW | PLEDGE_RPATH },
	{ "wpath",		PLEDGE_SELF | PLEDGE_RW | PLEDGE_WPATH },
	{ "tmppath",		PLEDGE_SELF | PLEDGE_RW | PLEDGE_TMPPATH },
	{ "inet",		PLEDGE_SELF | PLEDGE_RW | PLEDGE_INET },
	{ "unix",		PLEDGE_SELF | PLEDGE_RW | PLEDGE_UNIX },
	{ "dns",		PLEDGE_SELF | PLEDGE_MALLOC | PLEDGE_DNS },
	{ "getpw",		PLEDGE_SELF | PLEDGE_MALLOC | PLEDGE_RW | PLEDGE_GETPW },
	{ "sendfd",		PLEDGE_RW | PLEDGE_SENDFD },
	{ "recvfd",		PLEDGE_RW | PLEDGE_RECVFD },
a281 1
	{ "abort",		PLEDGE_ABORT },
d288 1
d474 1
d496 13
a508 2
	printf("%s(%d): syscall %d\n", p->p_comm, p->p_pid, p->p_pledge_syscall);
	if (p->p_p->ps_pledge & PLEDGE_ABORT) {	/* Core dump requested */
d530 1
d532 1
a532 1
	if (p->p_pledgenote == TMN_COREDUMP)
d535 3
a537 2
	if (canonpath(origpath, path, sizeof(path)) != 0)
		return (pledge_fail(p, EPERM, PLEDGE_RPATH));
d539 2
a540 1
	if ((p->p_pledgenote & TMN_FATTR) &&
d542 1
a542 3
		printf("%s(%d): inode syscall%d, not allowed\n",
		    p->p_comm, p->p_pid, p->p_pledge_syscall);
		return (pledge_fail(p, EPERM, PLEDGE_FATTR));
d548 1
a548 1
	    (p->p_pledgenote & TMN_CPATH) &&
d563 1
a563 1
	if ((p->p_pledgenote & TMN_CPATH) &&
d568 1
a568 1
	if ((p->p_pledgenote & TMN_XPATH) &&
d576 1
a576 1
		if ((p->p_pledgenote & ~(TMN_RPATH | TMN_WPATH)) == 0 &&
d583 1
a583 1
		    (p->p_pledgenote & ~(TMN_RPATH | TMN_WPATH)) == 0 &&
d591 1
a591 1
	if ((p->p_pledgenote & TMN_WPATH) &&
d599 1
a599 1
		if ((p->p_pledgenote == TMN_RPATH) &&
d605 1
a605 1
		if ((p->p_pledgenote == TMN_RPATH) &&
d616 1
a616 1
		if ((p->p_pledgenote == TMN_RPATH) &&
d626 1
a626 1
		if ((p->p_pledgenote == TMN_RPATH) &&
d629 1
a629 1
				p->p_pledgeafter |= TMA_YPLOCK;
d638 1
a638 1
		if ((p->p_pledgenote == TMN_RPATH) &&
d642 1
a642 1
		if ((p->p_pledgenote == TMN_RPATH) &&
d647 1
a647 1
		if ((p->p_pledgenote == TMN_RPATH) &&
d656 1
a656 1
		if ((p->p_pledgenote == TMN_RPATH) &&
d662 1
a662 1
		if ((p->p_pledgenote == TMN_RPATH) &&
d675 1
a675 1
	if ((p->p_pledgenote & TMN_RPATH) &&
d726 1
a726 1
			return (pledge_fail(p, EPERM, PLEDGE_RPATH));
d766 1
a766 1
				p->p_pledgenote |= TMN_STATLIE;
d780 1
a780 1
	return (pledge_fail(p, EPERM, PLEDGE_RPATH));
d786 2
a787 2
	if ((p->p_pledgeafter & TMA_YPLOCK) && error == 0)
		atomic_setbits_int(&p->p_p->ps_pledge, PLEDGE_YP_ACTIVE | PLEDGE_INET);
d990 1
a990 1
	return (EFAULT);
d1264 1
a1264 1
	if ((p->p_p->ps_pledge & (PLEDGE_INET|PLEDGE_UNIX|PLEDGE_YP_ACTIVE)))
@


1.72
log
@reorder some checks in pledge_namei() in order to properly work.

mainly move read/write whitelisted paths that should be *before* checking if
you have PLEDGE_WPATH.

with and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.71 2015/10/25 10:30:58 deraadt Exp $	*/
d1144 1
a1144 1
pledge_sockopt_check(struct proc *p, int level, int optname)
d1152 2
a1153 2
	        switch (optname) {
	        case SO_RCVBUF:
d1155 3
a1157 3
	                return 0;
	        }
	        break;
d1165 5
a1169 5
	        switch (optname) {
	        case SO_TIMESTAMP:
	                return 0;
	        }
	        break;
d1199 1
a1199 1
			if (p->p_pledge_syscall == SYS_getsockopt)
@


1.71
log
@ps(1) needs sysctl KERN_PROC_CWD exposed as well in the pledge "ps" set.
hit by czarkoff
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.70 2015/10/25 01:57:09 millert Exp $	*/
d560 19
d583 1
a583 1
	/* Read-only paths used occasionally by libc */
a591 6
		/* daemon(3) or other such functions */
		if ((p->p_pledgenote & ~(TMN_RPATH | TMN_WPATH)) == 0 &&
		    strcmp(path, "/dev/null") == 0) {
			return (0);
		}

a602 7
		/* "YP server for domain %s not responding, still trying" */
		if ((p->p_p->ps_pledge & PLEDGE_GETPW) &&
		    (p->p_pledgenote & ~(TMN_RPATH | TMN_WPATH)) == 0 &&
		    strcmp(path, "/dev/tty") == 0) {
			return (0);
		}

a640 6
		/* Allow opening r/w on /dev/tty when "tty" is specified. */
		if ((p->p_p->ps_pledge & PLEDGE_TTY) &&
		    (p->p_pledgenote & ~(TMN_RPATH | TMN_WPATH)) == 0 &&
		    strcmp(path, "/dev/tty") == 0) {
			return (0);
		}
@


1.70
log
@For SYS_open let the /dev/null special case match if any TMN_RPATH,
TMN_WPATH or both are set in p_pledgenote.  Matches the style used
for /dev/tty special cases (among others).  From deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.69 2015/10/25 00:02:00 nicm Exp $	*/
d898 3
@


1.69
log
@Allow getsockopt(IP_OPTIONS) (with inet), needed by portmap (for RPC).

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.68 2015/10/23 15:53:49 deraadt Exp $	*/
d574 3
a576 4
		if ((p->p_pledgenote == TMN_RPATH ||
		    p->p_pledgenote == TMN_WPATH)) {
			if (strcmp(path, "/dev/null") == 0)
				return (0);
@


1.68
log
@Allow SIOCGIFINFO_IN6
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.67 2015/10/23 10:22:29 claudio Exp $	*/
d1196 4
@


1.67
log
@Introduce a new sysctl NET_RT_IFNAMES that returns only ifnames to ifindex
mappings. This will be used by if_nameindex(3), if_nametoindex(3) and
if_indextoname(3) soon to fix the issues in pledge because of inet6 link
local addressing.
OK mpi@@ benno@@ deraadt@@
The libc version will follow soon so better start updating your kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.66 2015/10/23 01:10:01 deraadt Exp $	*/
a1123 1
		case SIOCGIFDSTADDR_IN6:
d1126 3
a1129 1
		case SIOCGIFRDOMAIN:
d1131 1
a1131 1
		case SIOCGIFGMEMB:
@


1.66
log
@Add 3 new pledge requests.  "ps" exposes enough sysctl information for
ps-style programs (there are quite a few in the tree, including tmux).
"vminfo" exposes a bit more system operation information, which many
observation programs want (such as top).  settime allows setting the system
time, and will be used to pledge-protect the last ntpd process.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.64 2015/10/22 11:01:43 deraadt Exp $	*/
d940 4
@


1.65
log
@Allow hw.ncpu sysctl (a few reasons showed up in my mailbox rapidly..)
@
text
@a88 1
	[SYS_adjtime] = PLEDGE_SELF,	/* read-only */
d118 4
d197 1
d255 2
d287 3
d656 5
d874 47
d996 2
d1255 8
@


1.64
log
@Further study shows "route" should allow all address families in NET_RT_DUMP
With benno
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.63 2015/10/22 10:35:23 deraadt Exp $	*/
d903 3
@


1.63
log
@After some consideration, simply allow TIOCSCTTY in the "tty" pledge.
Discussion with nicm.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.62 2015/10/20 18:04:03 deraadt Exp $	*/
a841 1
		    (mib[3] == 0 || mib[3] == AF_INET6 || mib[3] == AF_INET) &&
@


1.62
log
@At guenther's suggestion replace dnssocket() with a SOCK_DNS flag on
socket().  Without pledge, all other socket behaviours become permitted,
except this one case: connect/send* only works to *:53.  In pledge mode,
a very few are further restricted.  Some backwards compatibility for
the dnssocket/dnsconnect calls will remain in the tree temporarily so
that people can build through the transition.
ok tedu guenther semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.61 2015/10/20 17:44:48 reyk Exp $	*/
a1024 5
		case TIOCSCTTY:		/* tmux etc */
			if ((p->p_p->ps_pledge & PLEDGE_ID) &&
			    fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
				return (0);
			break;
d1045 1
@


1.61
log
@Add SIOCGIFGMEMB to "route" (returns a list of all interfaces who are
member of the given group).  This is used by some parse.y.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.60 2015/10/20 06:40:00 semarie Exp $	*/
a235 1
	/* XXX remove PLEDGE_DNS from socket/connect in 1 week */
d238 2
d241 1
a245 1
	[SYS_bind] = PLEDGE_INET | PLEDGE_UNIX,
a248 1
	[SYS_getsockname] = PLEDGE_INET | PLEDGE_UNIX,
a938 13
pledge_recvit_check(struct proc *p, const void *from)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if ((p->p_p->ps_pledge & (PLEDGE_INET | PLEDGE_UNIX)))
		return (0);		/* may use address */
	if (from == NULL)
		return (0);		/* behaves just like read */
	return (EPERM);
}

int
d944 1
a944 1
	if ((p->p_p->ps_pledge & (PLEDGE_INET | PLEDGE_UNIX)))
d1093 1
a1093 1
	        return (EPERM);
d1105 1
a1105 1
		return (EPERM);
d1110 1
a1110 1
			return (EPERM);
d1116 1
a1116 1
		return (EPERM);
d1173 1
a1173 1
pledge_dns_check(struct proc *p, in_port_t port)
d1178 3
a1180 1
	if ((p->p_p->ps_pledge & PLEDGE_INET))
a1181 2
	if ((p->p_p->ps_pledge & PLEDGE_DNS) && port == htons(53))
		return (0);	/* Allow a DNS connect outbound */
@


1.60
log
@clear whitelisted-paths view in pledge.

the following diff adds a clear view of whitelisted-paths in pledge.

before, whitelisting "/usr/local/bin" path would make only "/usr/local/bin"
VNODE was present and let "/usr/local", "/usr", and "/" been ENOENT. It was a
somehow odd filesystem hierarchy, and it breaks realpath(3).

with this diff, the directories that are one of the parents of a
whitelisted-directory become visible to stat(2) related syscalls, but only
with restricted permissions: stat(2) will lie a bit, and saying they owned by
root:wheel and mode is --x--x--x. Note that only stat(2) is affected by this
"view", and the owner/mode aren't effectively changed: it is just a "lie".

while here, refactor a bit pledge_namei() in order to avoid multiple for-loop
on whitelisted-path array.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.59 2015/10/20 05:18:34 deraadt Exp $	*/
d1078 1
@


1.59
log
@allow SO_ERROR all the time
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.58 2015/10/20 01:44:00 deraadt Exp $	*/
d59 1
d661 2
a662 2
		size_t builtlen = 0;
		int i, error;
d708 2
d711 10
a720 2
			if (strncmp(canopath, wl->wl_paths[i].name,
			    wl->wl_paths[i].len - 1) == 0) {
d726 7
d735 9
d1283 16
@


1.58
log
@Always allow the setsockopt & getsockopt system calls... however, in the
default case only allows SOL_SOCKET SO_RCVBUF which is very common in
network-facing daemons.  Many of them manage this on a socket after
dropping abilities which can get them _new_ sockets.. syslogd, bgpd,
relayd, etc etc.  Other sockopts still require specific pledges.
Tested by bluhm.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.57 2015/10/19 16:20:56 deraadt Exp $	*/
d1071 1
@


1.57
log
@Allow setpriority in "proc" as well, since a few shells have "nice"
builtin.  make a note that setpriority() should be weakened, unless "id"
is also present.
pointed out by Theo Buehler
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.56 2015/10/19 12:55:32 nicm Exp $	*/
d90 3
a247 2
	[SYS_setsockopt] = PLEDGE_INET | PLEDGE_UNIX,
	[SYS_getsockopt] = PLEDGE_INET | PLEDGE_UNIX,
d1061 1
a1061 1
pledge_setsockopt_check(struct proc *p, int level, int optname)
d1066 24
a1089 1
	/* common case for PLEDGE_UNIX and PLEDGE_INET */
a1100 1

@


1.56
log
@Print vnode type for sendfd/recvfd not file type, ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.55 2015/10/18 20:15:10 deraadt Exp $	*/
d159 3
a169 1
	[SYS_setpriority] = PLEDGE_ID,
@


1.55
log
@Instead of fragile CMSG parsing, control pledge "sendfd" and "recvfd"
in unp_internalize and unp_externalize.
ok kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.54 2015/10/18 05:26:55 semarie Exp $	*/
d741 1
a741 1
	struct vnode *vp;
d762 1
a762 1
	printf("recvfd type %d %s\n", fp->f_type, vtypes[fp->f_type]);
d772 1
a772 1
	struct vnode *vp;
d789 1
a789 1
	
d794 1
a794 1
	printf("sendfd type %d %s\n", fp->f_type, vtypes[fp->f_type]);
@


1.54
log
@move SS_DNS socket check from kern_plegde.c to sys_generic.c

this check has nothing to do with pledge(2). make it lives in sys_ioctl() call.

while here, move the (fp == NULL) check early and remove duplicate check from
pledge_ioctl_check().

ok guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.53 2015/10/18 04:21:39 deraadt Exp $	*/
d736 1
a736 9
 * By default, only the advisory cmsg's can be received from the kernel,
 * such as TIMESTAMP ntpd.
 *
 * If PLEDGE_RECVFD is set SCM_RIGHTS is also allowed in for a carefully
 * selected set of descriptors (specifically to exclude directories).
 *
 * This results in a kill upon recv, if some other process on the system
 * send a SCM_RIGHTS to an open socket of some sort.  That will discourage
 * leaving such sockets lying around...
d739 1
a739 1
pledge_cmsg_recv(struct proc *p, struct mbuf *control)
d741 2
a742 5
	struct msghdr tmp;
	struct cmsghdr *cmsg;
	int *fdp, fd;
	struct file *fp;
	int nfds, i;
d746 3
a748 12

	/* Scan the cmsg */
	memset(&tmp, 0, sizeof(tmp));
	tmp.msg_control = mtod(control, struct cmsghdr *);
	tmp.msg_controllen = control->m_len;
	cmsg = CMSG_FIRSTHDR(&tmp);

	while (cmsg != NULL) {
		if (cmsg->cmsg_level == SOL_SOCKET &&
		    cmsg->cmsg_type == SCM_RIGHTS)
			break;
		cmsg = CMSG_NXTHDR(&tmp, cmsg);
d751 3
a753 2
	/* No SCM_RIGHTS found -> OK */
	if (cmsg == NULL)
d755 2
d758 3
a760 29
	if ((p->p_p->ps_pledge & PLEDGE_RECVFD) == 0)
		return pledge_fail(p, EPERM, PLEDGE_RECVFD);

	/* In OpenBSD, a CMSG only contains one SCM_RIGHTS.  Check it. */
	fdp = (int *)CMSG_DATA(cmsg);
	nfds = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(*cmsg))) /
	    sizeof(struct file *);
	for (i = 0; i < nfds; i++) {
		struct vnode *vp;

		fd = *fdp++;
		fp = fd_getfile(p->p_fd, fd);
		if (fp == NULL)
			return pledge_fail(p, EBADF, PLEDGE_RECVFD);

		/* Only allow passing of sockets, pipes, and pure files */
		switch (fp->f_type) {
		case DTYPE_SOCKET:
		case DTYPE_PIPE:
			continue;
		case DTYPE_VNODE:
			vp = (struct vnode *)fp->f_data;
			if (vp->v_type == VREG)
				continue;
			break;
		default:
			break;
		}
		return pledge_fail(p, EPERM, PLEDGE_RECVFD);
d762 2
a763 1
	return (0);
d767 1
a767 4
 * When pledged, default prevents sending of a cmsg.
 *
 * Unlike pledge_cmsg_recv pledge_cmsg_send is called with individual
 * cmsgs one per mbuf. So no need to loop or scan.
d770 1
a770 1
pledge_cmsg_send(struct proc *p, struct mbuf *control)
d772 2
a773 4
	struct cmsghdr *cmsg;
	int *fdp, fd;
	struct file *fp;
	int nfds, i;
d778 2
a779 9
	/* Scan the cmsg */
	cmsg = mtod(control, struct cmsghdr *);

	/* Contains no SCM_RIGHTS, so OK */
	if (!(cmsg->cmsg_level == SOL_SOCKET &&
	    cmsg->cmsg_type == SCM_RIGHTS))
		return (0);

	if ((p->p_p->ps_pledge & PLEDGE_SENDFD) == 0)
d781 1
d783 10
a792 27
	/* In OpenBSD, a CMSG only contains one SCM_RIGHTS.  Check it. */
	fdp = (int *)CMSG_DATA(cmsg);
	nfds = (cmsg->cmsg_len - CMSG_ALIGN(sizeof(*cmsg))) /
	    sizeof(struct file *);
	for (i = 0; i < nfds; i++) {
		struct vnode *vp;

		fd = *fdp++;
		fp = fd_getfile(p->p_fd, fd);
		if (fp == NULL)
			return pledge_fail(p, EBADF, PLEDGE_SENDFD);

		/* Only allow passing of sockets, pipes, and pure files */
		switch (fp->f_type) {
		case DTYPE_SOCKET:
		case DTYPE_PIPE:
			continue;
		case DTYPE_VNODE:
			vp = (struct vnode *)fp->f_data;
			if (vp->v_type == VREG)
				continue;
			break;
		default:
			break;
		}
		/* Not allowed to send a bad fd type */
		return pledge_fail(p, EPERM, PLEDGE_SENDFD);
d794 2
a795 1
	return (0);
d994 1
a994 1
		                break;
d996 1
a996 1
		                break;
@


1.53
log
@getting sloppy, lost a }
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.52 2015/10/18 03:30:01 deraadt Exp $	*/
a1008 7
	if (fp->f_type == DTYPE_SOCKET) {
		struct socket *so = fp->f_data;

		if (so->so_state & SS_DNS)
			return (EINVAL);
	}

d1023 1
a1023 2
	if (fp == NULL)
		return (EBADF);
@


1.52
log
@Move your drink further away...  When a program pledged "getpw" fails to
get a response from a YP server, it will open "/dev/tty" and spit out:
    'YP server for domain %s not responding, still trying'
For now allow open of /dev/tty for "getpw".  I hope to re-architect the
libc:YP communication protocol (strategy similar to syslog->sendsyslog,
isatty->fcntl, dnssocket/dnsconnect) and then we can reevaluate this.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.51 2015/10/18 01:53:31 deraadt Exp $	*/
d583 1
@


1.51
log
@TIOCSTI and TIOCSCTTY; oops got the condition backwards.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.50 2015/10/18 01:07:19 doug Exp $	*/
d578 6
d594 1
d605 1
@


1.50
log
@Allow read/write access to /dev/tty when using "tty" pledge.

Without this change, you need "rpath" and "wpath" to open /dev/tty.  Some
applications explicitly open /dev/tty, but deraadt@@ found the most
common use is indirectly via readpassphrase().

tweak and ok deraadt@@
pre-tweak ok millert@@, semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.49 2015/10/18 00:04:43 deraadt Exp $	*/
d1072 1
a1072 1
			if ((p->p_p->ps_pledge & PLEDGE_PROC) == 0 &&
d1077 1
a1077 1
			if ((p->p_p->ps_pledge & PLEDGE_ID) == 0 &&
@


1.49
log
@Add two new system calls: dnssocket() and dnsconnect().  This creates a
SS_DNS tagged socket which has limited functionality (for example, you
cannot accept on them...)  The libc resolver will switch to using these,
therefore pledge can identify a DNS transaction better.
ok tedu guenther kettenis beck and others
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.48 2015/10/17 23:50:04 deraadt Exp $	*/
d613 7
@


1.48
log
@naddy asks me if __tfork should be allowed by "proc".  yes!
We may need a better semantic later ("thread"?), but this allows
progress, and people can report their experiences.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.47 2015/10/17 23:12:46 deraadt Exp $	*/
d28 1
d145 1
a145 1
	[SYS_sendto] = PLEDGE_RW | PLEDGE_DNS_ACTIVE | PLEDGE_YP_ACTIVE,
d148 1
a148 1
	[SYS_recvfrom] = PLEDGE_RW | PLEDGE_DNS_ACTIVE | PLEDGE_YP_ACTIVE,
d230 6
a235 2
	[SYS_socket] = PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS_ACTIVE | PLEDGE_YP_ACTIVE,
	[SYS_connect] = PLEDGE_INET | PLEDGE_UNIX | PLEDGE_DNS_ACTIVE | PLEDGE_YP_ACTIVE,
d261 1
a261 1
	{ "dns",		PLEDGE_SELF | PLEDGE_MALLOC | PLEDGE_DNSPATH },
d580 2
a581 3
		    (p->p_p->ps_pledge & PLEDGE_DNSPATH)) {
			if (strcmp(path, "/etc/resolv.conf") == 0) {
				p->p_pledgeafter |= TMA_DNSRESOLV;
a582 1
			}
d623 3
a625 6
		    (p->p_p->ps_pledge & PLEDGE_DNSPATH)) {
			if (strcmp(path, "/etc/resolv.conf") == 0) {
				p->p_pledgeafter |= TMA_DNSRESOLV;
				return (0);
			}
		}
a716 2
	if ((p->p_pledgeafter & TMA_DNSRESOLV) && error == 0)
		atomic_setbits_int(&p->p_p->ps_pledge, PLEDGE_DNS_ACTIVE);
d940 1
d962 1
a962 1
pledge_connect_check(struct proc *p)
a966 3
	if ((p->p_p->ps_pledge & PLEDGE_DNS_ACTIVE))
		return (0);	/* A port check happens inside sys_connect() */

d968 1
a968 18
		return (0);
	return (EPERM);
}

int
pledge_recvfrom_check(struct proc *p, void *v)
{
	struct sockaddr *from = v;

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);

	if ((p->p_p->ps_pledge & PLEDGE_DNS_ACTIVE) && from == NULL)
		return (0);
	if (p->p_p->ps_pledge & PLEDGE_INET)
		return (0);
	if (p->p_p->ps_pledge & PLEDGE_UNIX)
		return (0);
d970 1
a970 1
		return (0);		/* behaves just like write */
d975 1
a975 1
pledge_sendto_check(struct proc *p, const void *v)
a976 2
	const struct sockaddr *to = v;

d980 2
a981 7
	if ((p->p_p->ps_pledge & PLEDGE_DNS_ACTIVE) && to == NULL)
		return (0);

	if ((p->p_p->ps_pledge & PLEDGE_INET))
		return (0);
	if ((p->p_p->ps_pledge & PLEDGE_UNIX))
		return (0);
a987 13
pledge_socket_check(struct proc *p, int domain)
{
	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);
	if ((p->p_p->ps_pledge & (PLEDGE_INET | PLEDGE_UNIX)))
		return (0);
	if ((p->p_p->ps_pledge & PLEDGE_DNS_ACTIVE) &&
	    (domain == AF_INET || domain == AF_INET6))
		return (0);
	return (EPERM);
}

int
d993 7
d1200 1
a1200 1
	if ((p->p_p->ps_pledge & PLEDGE_DNS_ACTIVE) && port == htons(53))
d1210 1
@


1.47
log
@Allow the nasty ioctl TIOCSTI in "tty", but also require the "proc"
permission.  For now, we'll tighten it down further later.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.46 2015/10/17 23:04:06 deraadt Exp $	*/
d92 1
@


1.46
log
@better wording in a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.45 2015/10/17 23:01:37 deraadt Exp $	*/
a1096 1
#if notyet
d1098 2
a1099 1
			if (fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
a1101 1
#endif
@


1.45
log
@Unify TIOCGPGRP/TIOCGWINSZ/TIOCGWINSZ behaviour regarding ENOTTY return.
(both "tty" and "ioctl" allow these; they should behave the same)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.44 2015/10/17 22:58:30 deraadt Exp $	*/
d1059 1
a1059 1
		case TIOCGWINSZ:	/* ENOTTY for return for non-tty */
d1114 1
a1114 1
		case TIOCGWINSZ:	/* ENOTTY for return for non-tty */
@


1.44
log
@Allow TIOCSCTTY on tty devices, if the pledge says "tty id"
worked out with nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.43 2015/10/17 22:54:23 deraadt Exp $	*/
d1058 2
a1062 5
		case TIOCGPGRP:
		case TIOCGWINSZ:	/* various programs */
			if (fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
				return (0);
			break;
d1114 1
a1114 1
		case TIOCGWINSZ:	/* various programs */
@


1.43
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.42 2015/10/17 04:31:10 deraadt Exp $	*/
d1106 5
@


1.42
log
@Add pledge "id" support.  This request permits setuid/seteuid/setresuid,
setgid/setegid/setresgid, setgroups, setlogin, and setpriority.

setrlimit and getpriority are also allowed (they are also in "proc")

some of these were previously permitted in "proc" but have been removed.
this seperation is intentional.  "proc" is intended for reasoning about
the relationship of a process "with other processes", whereas "id" deals
the powerful/dangerous concept of unix ids.  "id" will see some action
very soon.

ok gilles tedu semarie doug
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.41 2015/10/17 00:58:50 jca Exp $	*/
d152 1
a152 1
	[SYS_kill] = PLEDGE_SELF | PLEDGE_PROC,	
d628 1
a628 1
	/* ensure PLEDGE_RPATH request for doing read */	
d1195 1
a1195 1
		}		
@


1.41
log
@Allow a few 'get' ioctls for pledge("route").  route6d will soon use this.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.40 2015/10/16 23:00:01 jca Exp $	*/
a149 1
	[SYS_kill] = PLEDGE_SELF | PLEDGE_PROC,	
d152 14
a165 1
	[SYS_setrlimit] = PLEDGE_PROC,
a168 4
	[SYS_setgroups] = PLEDGE_PROC,
	[SYS_setresgid] = PLEDGE_PROC,
	[SYS_setresuid] = PLEDGE_PROC,

d260 1
@


1.40
log
@Also allow 6 as a miblen for NET_RT_DUMP, not all users specify a rtable.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.39 2015/10/16 17:03:31 deraadt Exp $	*/
d1126 1
d1128 2
@


1.39
log
@Repair the pty check for kernels without pty support.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.38 2015/10/16 15:39:14 nicm Exp $	*/
d854 1
a854 1
		if (miblen == 7 &&
@


1.38
log
@Allow PTMGET with "tty rpath wpath" but restrict only to /dev/ptm by
checking cdevsw. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.37 2015/10/16 14:20:48 deraadt Exp $	*/
d55 2
d1079 1
d1090 1
@


1.37
log
@Always allow a r/w opening of /dev/null though the namei check.  This
pattern is common, especially because of daemon(3) usage.  Will probably
help some daemons move their pledge() calls further upwards.
ok doug,
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.36 2015/10/16 14:04:11 semarie Exp $	*/
d35 1
d46 2
d1077 10
@


1.36
log
@delete pledge_bind_check() function and remove pledge_bind_check() call from sys_bind().

bind(2) still require PLEDGE_INET or PLEDGE_UNIX in order to be called, due to
SYS_bind entry in pledge_syscalls array. The diff restores also the ability for
PLEDGE_UNIX to call bind(2) (pledge_bind_check function missed that).

problem spotted by doug@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.35 2015/10/16 14:00:37 deraadt Exp $	*/
d540 7
@


1.35
log
@Place TIOCSTI reminder block better
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.33 2015/10/16 13:37:43 millert Exp $	*/
a1001 11
		return (0);
	return (EPERM);
}

int
pledge_bind_check(struct proc *p, const void *v)
{

	if ((p->p_p->ps_flags & PS_PLEDGE) == 0)
		return (0);
	if ((p->p_p->ps_pledge & PLEDGE_INET))
@


1.34
log
@For "tty" pledges, treat TIOCGPGRP and TIOCGWINSZ like TIOCGETA -
returning ENOTTY instead of killing the process.
@
text
@d1078 6
a1093 6
#if notyet
		case TIOCSTI:		/* ksh? csh? */
			if (fp->f_type == DTYPE_VNODE && (vp->v_flag & VISTTY))
				return (0);
			break;
#endif
@


1.33
log
@Implement real "flock" request and add it to userland programs that
use pledge and file locking.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.32 2015/10/16 06:42:02 deraadt Exp $	*/
d1082 1
d1084 1
a1093 2
		case TIOCGPGRP:
		case TIOCGWINSZ:	/* various programs */
@


1.32
log
@FIOSETOWN/FIOGETOWN were added to "ioctl", but study finds no programs
currently needing them.  delete 'em for now.
ok doug
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.31 2015/10/16 06:40:53 doug Exp $	*/
d227 1
a227 1
	[SYS_flock] = PLEDGE_RW | PLEDGE_CPATH,
d256 1
a256 1
	{ "flock",		PLEDGE_RW | PLEDGE_CPATH },
d1210 10
@


1.31
log
@Add TIOCCBRK and TIOCSDTR to the whitelist for pledge ioctl.

cu(1) uses these.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.30 2015/10/15 17:55:41 deraadt Exp $	*/
a1046 3
		case FIOSETOWN:
		case FIOGETOWN:
			return (0);
@


1.30
log
@Add TIOCFLUSH to "tty" in support of tcflush()
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.29 2015/10/15 17:50:05 deraadt Exp $	*/
d1098 1
d1101 1
@


1.29
log
@Exposing FIOASYNC in pledge "ioctl" is a mistake; remove it, cannot find safe uses of it
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.28 2015/10/15 04:58:54 deraadt Exp $	*/
d1104 1
@


1.28
log
@FIOCLEX & FIONCLEX should be in base ioctl set
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.27 2015/10/14 23:15:37 sthen Exp $	*/
a1046 1
		case FIOASYNC:
@


1.27
log
@FALTHROUGH->FALLTHROUGH in comment, ok deraadt a few days ago
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.26 2015/10/14 22:34:47 millert Exp $	*/
d1032 2
a1046 2
		case FIOCLEX:
		case FIONCLEX:
@


1.26
log
@Add a dummy "flock" request that will allow file locking.  It is
not currently enforced but we want the kernel to be able to parse
it for an upcoming diff in the next few days.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.25 2015/10/14 14:24:03 deraadt Exp $	*/
d1085 1
a1085 1
			/* FALTHROUGH */
@


1.25
log
@When pledged with "fattr", allow chown to supplimentary groups.  This
came out of a discussion regarding "sort foo -o foo".
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.24 2015/10/14 04:05:43 deraadt Exp $	*/
d227 1
a227 2
	/* XXX getpw for the ypbind.lock; all other flock users have cpath */
	[SYS_flock] = PLEDGE_GETPW | PLEDGE_CPATH,
d256 1
@


1.24
log
@pledge "tty" can allow ioctl TIOCEXCL on a tty
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.23 2015/10/14 03:27:02 deraadt Exp $	*/
d913 12
@


1.23
log
@sendmsg() is allowed to pass cmsg's which are not CMSG_RIGHTS - last
refactoring inverted the checks; spotted by sthen in ping6.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.22 2015/10/13 20:00:49 deraadt Exp $	*/
d1089 1
@


1.22
log
@3 more headers required for one stinking inet6 ioctl..
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.21 2015/10/13 18:42:06 deraadt Exp $	*/
a788 3
	if ((p->p_p->ps_pledge & PLEDGE_SENDFD) == 0)
		return pledge_fail(p, EPERM, PLEDGE_SENDFD);

d796 3
@


1.21
log
@Allow ioctl SIOCGNBRINFO_IN6 in case of "route", for use by ndp.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.20 2015/10/13 18:38:34 deraadt Exp $	*/
d39 1
d41 2
@


1.20
log
@NET_RT_FLAGS must also accept a proto selection.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.19 2015/10/13 16:09:24 deraadt Exp $	*/
d1100 1
@


1.19
log
@allow getsockopt IP_RECVDSTPORT & IPV6_RECVDSTPORT for an "inet" pledge
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.18 2015/10/13 00:03:42 doug Exp $	*/
d855 2
a856 1
		    mib[2] == 0 && mib[3] == AF_INET &&
@


1.18
log
@Pledge "fattr" request should allow fchflags().

"add it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.17 2015/10/12 23:16:23 deraadt Exp $	*/
d1145 1
d1163 1
@


1.17
log
@pledge "proc" request should allow setsid()
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.16 2015/10/12 21:43:20 deraadt Exp $	*/
d206 1
@


1.16
log
@Remove the "cmsg" attribute, as promised.  Use "sendfd" or "recvfd",
depending on what you need.  inet/inet6 cmsg's come through unmolested --
that is something to consider later.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.15 2015/10/11 16:19:48 semarie Exp $	*/
d144 1
@


1.15
log
@add a missed check for PLEDGE_RPATH when reading a file.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.14 2015/10/11 16:01:06 deraadt Exp $	*/
a239 1
/*X*/	{ "cmsg",		PLEDGE_UNIX | PLEDGE_INET | PLEDGE_SENDFD | PLEDGE_RECVFD },
@


1.14
log
@sigaltstack is directly used by setjmp on some architectures. it only
refers to the process itself.  pledge should allow it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.13 2015/10/11 15:40:48 deraadt Exp $	*/
d602 5
@


1.13
log
@put TIOCSWINSZ in the right block "tty", not in "ioctl".  this happened
because the "route' tests were placed between the two, creating
confusion.  fix that while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.12 2015/10/11 15:25:39 deraadt Exp $	*/
d92 1
@


1.12
log
@In pledge "tty", allow TIOCSWINSZ.  stty(1) is the obvious silly use.
The more important use will be tmux(1) and other active window size
controlling programs. There seems little risk in exposing this small
tty setting alongside the tcsetattr() family.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.11 2015/10/11 01:56:56 guenther Exp $	*/
a1033 1
		case TIOCSWINSZ:
a1056 11
	if ((p->p_p->ps_pledge & PLEDGE_ROUTE)) {
		switch (com) {
		case SIOCGIFADDR:
		case SIOCGIFFLAGS:
		case SIOCGIFRDOMAIN:
			if (fp->f_type == DTYPE_SOCKET)
				return (0);
			break;
		}
	}

d1075 1
d1082 11
@


1.11
log
@__get_tcb() is needed for errno access in threaded programs on some archs.
Make it always available.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.10 2015/10/10 19:15:53 deraadt Exp $	*/
d1034 1
@


1.10
log
@For pledge, sigsuspend() should is affecting the behaviour a process itself,
so we should allow it for 'self'.
ok djm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.9 2015/10/10 16:35:08 deraadt Exp $	*/
d54 1
@


1.9
log
@shuffle #ifdef TIOCSTI block to avoid a future /*FALLTHROUGH*/ mistake.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.8 2015/10/10 14:48:03 deraadt Exp $	*/
d92 1
a141 1
	[SYS_sigsuspend] = PLEDGE_PROC,
@


1.8
log
@allow sysctl of kern.clockrate
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.7 2015/10/10 14:46:15 deraadt Exp $	*/
a1076 2
		case TIOCGPGRP:
		case TIOCGWINSZ:	/* various programs */
d1079 3
d1083 2
@


1.7
log
@I forgot execve would go through the namei codepath, so a program marked
"stdio rpath" this would fail to execve.  pre-indicate exec actions to the
namei checker to allow them through.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.6 2015/10/09 23:55:03 deraadt Exp $	*/
d883 3
@


1.6
log
@Allow kill(self, sig) in pledge SELF also.  the stack protector, abort(),
and readpassphrase() in particular use this.
ok millert tedu semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.5 2015/10/09 17:18:20 deraadt Exp $	*/
d515 5
@


1.5
log
@Have not come up with a great pattern for flock() yet.  flock() is permitted
by "getpw" because libc getpw*/getgr* use open() of /var/run/ypbind.lock plus
flock() to detect YP running.  The kernel observes this dance to "open up" the
YP door (ugliness should drive us to rewrite this mechanism from SunOS later).

however, flock is also used independently.  Current users are
    htpasswd mail skeyinit tmux authpf pwd_mkdb ldapd smtpd ypbind
    login_token mail.local lockspool
Let's enable flock() for "cpath", and see if that helps these programs,
otherwise we'll try "wpath" next.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.4 2015/10/09 05:30:03 deraadt Exp $	*/
d139 1
a139 1
	[SYS_kill] = PLEDGE_PROC,
@


1.4
log
@shortcircuit TIOCGETA to directly return ENOTTY for non-ttys.  It could
be called against a non-tty fd, so as to test "is this a tty".  Discovered
by sthen and rob pierce at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.3 2015/10/09 02:44:22 deraadt Exp $	*/
d220 2
a221 1
	[SYS_flock] = PLEDGE_GETPW,
@


1.3
log
@stardate 93370.16: a whitespace appears to have entered our quadrant...
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.2 2015/10/09 02:36:46 deraadt Exp $	*/
d1019 3
d1065 3
@


1.2
log
@multicast test backwards; noted by renato
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_pledge.c,v 1.1 2015/10/09 01:17:21 deraadt Exp $	*/
d1142 1
a1142 1
			if (p->p_p->ps_pledge & PLEDGE_MCAST))
@


1.1
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_tame.c,v 1.71 2015/10/09 01:10:27 deraadt Exp $	*/
d1122 1
a1122 1
			if ((p->p_p->ps_pledge & PLEDGE_MCAST) == 0)
d1142 1
a1142 1
			if ((p->p_p->ps_pledge & PLEDGE_MCAST) == 0)
@

