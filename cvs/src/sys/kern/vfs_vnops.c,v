head	1.87;
access;
symbols
	OPENBSD_6_1:1.87.0.4
	OPENBSD_6_1_BASE:1.87
	OPENBSD_6_0:1.85.0.2
	OPENBSD_6_0_BASE:1.85
	OPENBSD_5_9:1.83.0.2
	OPENBSD_5_9_BASE:1.83
	OPENBSD_5_8:1.82.0.4
	OPENBSD_5_8_BASE:1.82
	OPENBSD_5_7:1.80.0.2
	OPENBSD_5_7_BASE:1.80
	OPENBSD_5_6:1.78.0.4
	OPENBSD_5_6_BASE:1.78
	OPENBSD_5_5:1.75.0.4
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.73.0.2
	OPENBSD_5_4_BASE:1.73
	OPENBSD_5_3:1.71.0.4
	OPENBSD_5_3_BASE:1.71
	OPENBSD_5_2:1.71.0.2
	OPENBSD_5_2_BASE:1.71
	OPENBSD_5_1_BASE:1.70
	OPENBSD_5_1:1.70.0.2
	OPENBSD_5_0:1.68.0.2
	OPENBSD_5_0_BASE:1.68
	OPENBSD_4_9:1.65.0.4
	OPENBSD_4_9_BASE:1.65
	OPENBSD_4_8:1.65.0.2
	OPENBSD_4_8_BASE:1.65
	OPENBSD_4_7:1.64.0.2
	OPENBSD_4_7_BASE:1.64
	OPENBSD_4_6:1.62.0.6
	OPENBSD_4_6_BASE:1.62
	OPENBSD_4_5:1.62.0.2
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.59.0.2
	OPENBSD_4_4_BASE:1.59
	OPENBSD_4_3:1.58.0.4
	OPENBSD_4_3_BASE:1.58
	OPENBSD_4_2:1.58.0.2
	OPENBSD_4_2_BASE:1.58
	OPENBSD_4_1:1.54.0.2
	OPENBSD_4_1_BASE:1.54
	OPENBSD_4_0:1.53.0.2
	OPENBSD_4_0_BASE:1.53
	OPENBSD_3_9:1.48.0.2
	OPENBSD_3_9_BASE:1.48
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.45.0.4
	OPENBSD_3_7_BASE:1.45
	OPENBSD_3_6:1.45.0.2
	OPENBSD_3_6_BASE:1.45
	SMP_SYNC_A:1.44
	SMP_SYNC_B:1.44
	OPENBSD_3_5:1.44.0.2
	OPENBSD_3_5_BASE:1.44
	OPENBSD_3_4:1.43.0.2
	OPENBSD_3_4_BASE:1.43
	UBC_SYNC_A:1.41
	OPENBSD_3_3:1.41.0.6
	OPENBSD_3_3_BASE:1.41
	OPENBSD_3_2:1.41.0.4
	OPENBSD_3_2_BASE:1.41
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	UBC_SYNC_B:1.41
	UBC:1.38.0.2
	UBC_BASE:1.38
	OPENBSD_3_0:1.33.0.2
	OPENBSD_3_0_BASE:1.33
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_8:1.26.0.4
	OPENBSD_2_8_BASE:1.26
	OPENBSD_2_7:1.26.0.2
	OPENBSD_2_7_BASE:1.26
	SMP:1.23.0.2
	SMP_BASE:1.23
	kame_19991208:1.23
	OPENBSD_2_6:1.22.0.2
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.15.0.2
	OPENBSD_2_3_BASE:1.15
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.87
date	2016.09.30.10.55.22;	author jca;	state Exp;
branches;
next	1.86;
commitid	cUkb7n9jckkdArDf;

1.86
date	2016.09.30.10.53.11;	author jca;	state Exp;
branches;
next	1.85;
commitid	0vR6CgsTIrsXpLEf;

1.85
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.84;
commitid	wHLNY5GFNXJSFYaC;

1.84
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.83;
commitid	gAjwyca5TfuoJAhn;

1.83
date	2016.01.06.17.59.30;	author tedu;	state Exp;
branches;
next	1.82;
commitid	vtbNHxTkwTC4OW91;

1.82
date	2015.05.01.01.30.58;	author millert;	state Exp;
branches;
next	1.81;
commitid	QXOJtYQx3rj1zO0b;

1.81
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.80;
commitid	p4LJxGKbi0BU2cG6;

1.80
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.79;
commitid	P6Av4XGqOi3rFasL;

1.79
date	2014.11.03.21.28.35;	author tedu;	state Exp;
branches;
next	1.78;
commitid	EkuwmBeHv2Tqmdnx;

1.78
date	2014.07.13.15.00.40;	author tedu;	state Exp;
branches;
next	1.77;
commitid	7E1o7NIDvSyD48ls;

1.77
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.76;
commitid	QlVV51SZgNFxsXxC;

1.76
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.75;
commitid	EF98ch02VpFassUi;

1.75
date	2014.01.24.06.00.01;	author guenther;	state Exp;
branches;
next	1.74;

1.74
date	2013.09.14.02.28.01;	author guenther;	state Exp;
branches;
next	1.73;

1.73
date	2013.06.05.01.26.00;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2013.03.30.06.32.25;	author tedu;	state Exp;
branches;
next	1.71;

1.71
date	2012.07.11.12.39.20;	author guenther;	state Exp;
branches;
next	1.70;

1.70
date	2011.11.27.21.31.08;	author guenther;	state Exp;
branches;
next	1.69;

1.69
date	2011.11.07.17.50.17;	author guenther;	state Exp;
branches;
next	1.68;

1.68
date	2011.07.09.01.28.48;	author matthew;	state Exp;
branches;
next	1.67;

1.67
date	2011.07.06.09.14.26;	author matthew;	state Exp;
branches;
next	1.66;

1.66
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.64;

1.64
date	2010.01.08.19.18.21;	author stsp;	state Exp;
branches;
next	1.63;

1.63
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.62;

1.62
date	2009.01.29.22.08.45;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2009.01.24.23.25.17;	author thib;	state Exp;
branches;
next	1.60;

1.60
date	2008.09.19.12.24.55;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2008.04.08.14.46.45;	author thib;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.14.20.36.34;	author otto;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.01.22.30.46;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.05.12.03.04;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2007.03.21.17.29.32;	author thib;	state Exp;
branches;
next	1.54;

1.54
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.53;

1.53
date	2006.06.02.20.25.09;	author pedro;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.01.21.50.48;	author pedro;	state Exp;
branches;
next	1.51;

1.51
date	2006.04.23.17.36.09;	author pedro;	state Exp;
branches;
next	1.50;

1.50
date	2006.04.23.17.35.08;	author pedro;	state Exp;
branches;
next	1.49;

1.49
date	2006.04.23.17.30.56;	author pedro;	state Exp;
branches;
next	1.48;

1.48
date	2005.12.04.19.04.13;	author pedro;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.20.21.55.15;	author pedro;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.28.07.30.25;	author marius;	state Exp;
branches;
next	1.45;

1.45
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.02.23.28.07;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.17.18.22.25;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.14.01.27.06;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.10.18.45.34;	author art;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.15.06.22.30;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2001.07.16.18.25.43;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.27.04.49.48;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.22.14.14.11;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.14.12.38.47;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.14.12.11.53;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.01.20.54.34;	author provos;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.21.21.49.57;	author provos;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.25.02.10.04;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.21.15.47.28;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.19.08.34.53;	author csapuntz;	state Exp;
branches;
next	1.23;

1.23
date	99.11.13.03.48.09;	author angelos;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	99.08.26.08.07.10;	author art;	state Exp;
branches;
next	1.21;

1.21
date	99.07.18.01.20.22;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.02.26.04.51.17;	author art;	state Exp;
branches;
next	1.19;

1.19
date	98.12.05.17.16.54;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	98.12.05.16.44.09;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	98.08.06.19.34.29;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	98.07.28.00.13.04;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.01.15.01.24.40;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	98.01.09.16.33.49;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	97.12.10.19.44.09;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.12.10.19.39.41;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.12.10.19.31.17;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.12.10.19.15.09;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.11.06.05.58.29;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.10.24.09.04.26;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.20.20.15;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.15.12.45;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.08.04.08.24.54;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.07.15.16.06.17;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.07.11.02.15.49;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.20.28;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.48;	author deraadt;	state Exp;
branches;
next	;

1.23.2.1
date	2001.05.14.22.32.46;	author niklas;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2001.07.04.10.48.56;	author niklas;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.23.2.5;

1.23.2.5
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.23.2.6;

1.23.2.6
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.23.2.7;

1.23.2.7
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.23.2.8;

1.23.2.8
date	2003.06.07.11.03.41;	author ho;	state Exp;
branches;
next	1.23.2.9;

1.23.2.9
date	2004.02.19.10.56.39;	author niklas;	state Exp;
branches;
next	;

1.38.2.1
date	2002.06.11.03.29.41;	author art;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2002.11.04.18.02.31;	author art;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2004.02.21.00.20.21;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.87
log
@Drop a now unneeded variable initialization; spotted by bluhm@@
@
text
@/*	$OpenBSD: vfs_vnops.c,v 1.86 2016/09/30 10:53:11 jca Exp $	*/
/*	$NetBSD: vfs_vnops.c,v 1.20 1996/02/04 02:18:41 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vfs_vnops.c	8.5 (Berkeley) 12/8/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/proc.h>
#include <sys/resourcevar.h>
#include <sys/signalvar.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/lock.h>
#include <sys/vnode.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/cdio.h>
#include <sys/poll.h>
#include <sys/filedesc.h>
#include <sys/specdev.h>
#include <sys/unistd.h>

int vn_read(struct file *, off_t *, struct uio *, struct ucred *);
int vn_write(struct file *, off_t *, struct uio *, struct ucred *);
int vn_poll(struct file *, int, struct proc *);
int vn_kqfilter(struct file *, struct knote *);
int vn_closefile(struct file *, struct proc *);

struct 	fileops vnops =
	{ vn_read, vn_write, vn_ioctl, vn_poll, vn_kqfilter, vn_statfile,
	  vn_closefile };

/*
 * Common code for vnode open operations.
 * Check permissions, and call the VOP_OPEN or VOP_CREATE routine.
 */
int
vn_open(struct nameidata *ndp, int fmode, int cmode)
{
	struct vnode *vp;
	struct proc *p = ndp->ni_cnd.cn_proc;
	struct ucred *cred = p->p_ucred;
	struct vattr va;
	struct cloneinfo *cip;
	int error;

	if ((fmode & (FREAD|FWRITE)) == 0)
		return (EINVAL);
	if ((fmode & (O_TRUNC | FWRITE)) == O_TRUNC)
		return (EINVAL);
	if (fmode & O_CREAT) {
		ndp->ni_cnd.cn_nameiop = CREATE;
		ndp->ni_cnd.cn_flags = LOCKPARENT | LOCKLEAF;
		if ((fmode & O_EXCL) == 0 && (fmode & O_NOFOLLOW) == 0)
			ndp->ni_cnd.cn_flags |= FOLLOW;
		if ((error = namei(ndp)) != 0)
			return (error);

		if (ndp->ni_vp == NULL) {
			VATTR_NULL(&va);
			va.va_type = VREG;
			va.va_mode = cmode;
			if (fmode & O_EXCL)
				va.va_vaflags |= VA_EXCLUSIVE;
			error = VOP_CREATE(ndp->ni_dvp, &ndp->ni_vp,
					   &ndp->ni_cnd, &va);
			if (error)
				return (error);
			fmode &= ~O_TRUNC;
			vp = ndp->ni_vp;
		} else {
			VOP_ABORTOP(ndp->ni_dvp, &ndp->ni_cnd);
			if (ndp->ni_dvp == ndp->ni_vp)
				vrele(ndp->ni_dvp);
			else
				vput(ndp->ni_dvp);
			ndp->ni_dvp = NULL;
			vp = ndp->ni_vp;
			if (fmode & O_EXCL) {
				error = EEXIST;
				goto bad;
			}
			fmode &= ~O_CREAT;
		}
	} else {
		ndp->ni_cnd.cn_nameiop = LOOKUP;
		ndp->ni_cnd.cn_flags =
		    ((fmode & O_NOFOLLOW) ? NOFOLLOW : FOLLOW) | LOCKLEAF;
		if ((error = namei(ndp)) != 0)
			return (error);
		vp = ndp->ni_vp;
	}
	if (vp->v_type == VSOCK) {
		error = EOPNOTSUPP;
		goto bad;
	}
	if (vp->v_type == VLNK) {
		error = ELOOP;
		goto bad;
	}
	if ((fmode & O_DIRECTORY) && vp->v_type != VDIR) {
		error = ENOTDIR;
		goto bad;
	}
	if ((fmode & O_CREAT) == 0) {
		if (fmode & FREAD) {
			if ((error = VOP_ACCESS(vp, VREAD, cred, p)) != 0)
				goto bad;
		}
		if (fmode & FWRITE) {
			if (vp->v_type == VDIR) {
				error = EISDIR;
				goto bad;
			}
			if ((error = vn_writechk(vp)) != 0 ||
			    (error = VOP_ACCESS(vp, VWRITE, cred, p)) != 0)
				goto bad;
		}
	}
	if ((fmode & O_TRUNC) && vp->v_type == VREG) {
		VATTR_NULL(&va);
		va.va_size = 0;
		if ((error = VOP_SETATTR(vp, &va, cred, p)) != 0)
			goto bad;
	}
	if ((error = VOP_OPEN(vp, fmode, cred, p)) != 0)
		goto bad;

	if (vp->v_flag & VCLONED) {
		cip = (struct cloneinfo *)vp->v_data;

		vp->v_flag &= ~VCLONED;

		ndp->ni_vp = cip->ci_vp;	/* return cloned vnode */
		vp->v_data = cip->ci_data;	/* restore v_data */
		VOP_UNLOCK(vp, p);		/* keep a reference */
		vp = ndp->ni_vp;		/* for the increment below */

		free(cip, M_TEMP, sizeof(*cip));
	}

	if (fmode & FWRITE)
		vp->v_writecount++;
	return (0);
bad:
	vput(vp);
	return (error);
}

/*
 * Check for write permissions on the specified vnode.
 * Prototype text segments cannot be written.
 */
int
vn_writechk(struct vnode *vp)
{
	/*
	 * Disallow write attempts on read-only file systems;
	 * unless the file is a socket or a block or character
	 * device resident on the file system.
	 */
	if (vp->v_mount->mnt_flag & MNT_RDONLY) {
		switch (vp->v_type) {
		case VREG:
		case VDIR:
		case VLNK:
			return (EROFS);
		case VNON:
		case VCHR:
		case VSOCK:
		case VFIFO:
		case VBAD:
		case VBLK:
			break;
		}
	}
	/*
	 * If there's shared text associated with
	 * the vnode, try to free it up once.  If
	 * we fail, we can't allow writing.
	 */
	if ((vp->v_flag & VTEXT) && !uvm_vnp_uncache(vp))
		return (ETXTBSY);

	return (0);
}

/*
 * Check whether a write operation would exceed the file size rlimit
 * for the process, if one should be applied for this operation.
 * If a partial write should take place, the uio is adjusted and the
 * amount by which the request would have exceeded the limit is returned
 * via the 'overrun' argument.
 */
int
vn_fsizechk(struct vnode *vp, struct uio *uio, int ioflag, ssize_t *overrun)
{
	struct proc *p = uio->uio_procp;

	*overrun = 0;
	if (vp->v_type == VREG && p != NULL && !(ioflag & IO_NOLIMIT)) {
		rlim_t limit = p->p_rlimit[RLIMIT_FSIZE].rlim_cur;

		/* if already at or over the limit, send the signal and fail */
		if (uio->uio_offset >= limit) {
			psignal(p, SIGXFSZ);
			return (EFBIG);
		}

		/* otherwise, clamp the write to stay under the limit */
		if (uio->uio_resid > limit - uio->uio_offset) {
			*overrun = uio->uio_resid - (limit - uio->uio_offset);
			uio->uio_resid = limit - uio->uio_offset;
		}
	}

	return (0);
}


/*
 * Mark a vnode as being the text image of a running process.
 */
void
vn_marktext(struct vnode *vp)
{
	vp->v_flag |= VTEXT;
}

/*
 * Vnode close call
 */
int
vn_close(struct vnode *vp, int flags, struct ucred *cred, struct proc *p)
{
	int error;

	if (flags & FWRITE)
		vp->v_writecount--;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	error = VOP_CLOSE(vp, flags, cred, p);
	vput(vp);
	return (error);
}

/*
 * Package up an I/O request on a vnode into a uio and do it.
 */
int
vn_rdwr(enum uio_rw rw, struct vnode *vp, caddr_t base, int len, off_t offset,
    enum uio_seg segflg, int ioflg, struct ucred *cred, size_t *aresid,
    struct proc *p)
{
	struct uio auio;
	struct iovec aiov;
	int error;

	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	aiov.iov_base = base;
	aiov.iov_len = len;
	auio.uio_resid = len;
	auio.uio_offset = offset;
	auio.uio_segflg = segflg;
	auio.uio_rw = rw;
	auio.uio_procp = p;

	if ((ioflg & IO_NODELOCKED) == 0)
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (rw == UIO_READ) {
		error = VOP_READ(vp, &auio, ioflg, cred);
	} else {
		error = VOP_WRITE(vp, &auio, ioflg, cred);
	}
	if ((ioflg & IO_NODELOCKED) == 0)
		VOP_UNLOCK(vp, p);

	if (aresid)
		*aresid = auio.uio_resid;
	else
		if (auio.uio_resid && error == 0)
			error = EIO;
	return (error);
}

/*
 * File table vnode read routine.
 */
int
vn_read(struct file *fp, off_t *poff, struct uio *uio, struct ucred *cred)
{
	struct vnode *vp = fp->f_data;
	int error;
	size_t count = uio->uio_resid;
	struct proc *p = uio->uio_procp;

	/* no wrap around of offsets except on character devices */
	if (vp->v_type != VCHR && count > LLONG_MAX - *poff)
		return (EINVAL);

	if (vp->v_type == VDIR)
		return (EISDIR);

	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	uio->uio_offset = *poff;
	error = VOP_READ(vp, uio, (fp->f_flag & FNONBLOCK) ? IO_NDELAY : 0,
	    cred);
	*poff += count - uio->uio_resid;
	VOP_UNLOCK(vp, p);
	return (error);
}

/*
 * File table vnode write routine.
 */
int
vn_write(struct file *fp, off_t *poff, struct uio *uio, struct ucred *cred)
{
	struct vnode *vp = fp->f_data;
	struct proc *p = uio->uio_procp;
	int error, ioflag = IO_UNIT;
	size_t count;

	/* note: pwrite/pwritev are unaffected by O_APPEND */
	if (vp->v_type == VREG && (fp->f_flag & O_APPEND) &&
	    poff == &fp->f_offset)
		ioflag |= IO_APPEND;
	if (fp->f_flag & FNONBLOCK)
		ioflag |= IO_NDELAY;
	if ((fp->f_flag & FFSYNC) ||
	    (vp->v_mount && (vp->v_mount->mnt_flag & MNT_SYNCHRONOUS)))
		ioflag |= IO_SYNC;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	uio->uio_offset = *poff;
	count = uio->uio_resid;
	error = VOP_WRITE(vp, uio, ioflag, cred);
	if (ioflag & IO_APPEND)
		*poff = uio->uio_offset;
	else
		*poff += count - uio->uio_resid;
	VOP_UNLOCK(vp, p);
	return (error);
}

/*
 * File table wrapper for vn_stat
 */
int
vn_statfile(struct file *fp, struct stat *sb, struct proc *p)
{
	struct vnode *vp = fp->f_data;
	return vn_stat(vp, sb, p);
}

/*
 * vnode stat routine.
 */
int
vn_stat(struct vnode *vp, struct stat *sb, struct proc *p)
{
	struct vattr va;
	int error;
	mode_t mode;

	error = VOP_GETATTR(vp, &va, p->p_ucred, p);
	if (error)
		return (error);
	/*
	 * Copy from vattr table
	 */
	memset(sb, 0, sizeof(*sb));
	sb->st_dev = va.va_fsid;
	sb->st_ino = va.va_fileid;
	mode = va.va_mode;
	switch (vp->v_type) {
	case VREG:
		mode |= S_IFREG;
		break;
	case VDIR:
		mode |= S_IFDIR;
		break;
	case VBLK:
		mode |= S_IFBLK;
		break;
	case VCHR:
		mode |= S_IFCHR;
		break;
	case VLNK:
		mode |= S_IFLNK;
		break;
	case VSOCK:
		mode |= S_IFSOCK;
		break;
	case VFIFO:
		mode |= S_IFIFO;
		break;
	default:
		return (EBADF);
	}
	sb->st_mode = mode;
	sb->st_nlink = va.va_nlink;
	sb->st_uid = va.va_uid;
	sb->st_gid = va.va_gid;
	sb->st_rdev = va.va_rdev;
	sb->st_size = va.va_size;
	sb->st_atim.tv_sec  = va.va_atime.tv_sec;
	sb->st_atim.tv_nsec = va.va_atime.tv_nsec;
	sb->st_mtim.tv_sec  = va.va_mtime.tv_sec;
	sb->st_mtim.tv_nsec = va.va_mtime.tv_nsec;
	sb->st_ctim.tv_sec  = va.va_ctime.tv_sec;
	sb->st_ctim.tv_nsec = va.va_ctime.tv_nsec;
	sb->st_blksize = va.va_blocksize;
	sb->st_flags = va.va_flags;
	sb->st_gen = va.va_gen;
	sb->st_blocks = va.va_bytes / S_BLKSIZE;
	return (0);
}

/*
 * File table vnode ioctl routine.
 */
int
vn_ioctl(struct file *fp, u_long com, caddr_t data, struct proc *p)
{
	struct vnode *vp = fp->f_data;
	struct vattr vattr;
	int error;

	switch (vp->v_type) {

	case VREG:
	case VDIR:
		if (com == FIONREAD) {
			error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
			if (error)
				return (error);
			*(int *)data = vattr.va_size - fp->f_offset;
			return (0);
		}
		if (com == FIONBIO || com == FIOASYNC)  /* XXX */
			return (0);			/* XXX */
		/* FALLTHROUGH */
	default:
		return (ENOTTY);
		
	case VFIFO:
	case VCHR:
	case VBLK:
		error = VOP_IOCTL(vp, com, data, fp->f_flag, p->p_ucred, p);
		if (error == 0 && com == TIOCSCTTY) {
			struct session *s = p->p_p->ps_session;
			struct vnode *ovp = s->s_ttyvp;
			s->s_ttyvp = vp;
			vref(vp);
			if (ovp)
				vrele(ovp);
		}
		return (error);
	}
}

/*
 * File table vnode poll routine.
 */
int
vn_poll(struct file *fp, int events, struct proc *p)
{
	return (VOP_POLL(fp->f_data, fp->f_flag, events, p));
}

/*
 * Check that the vnode is still valid, and if so
 * acquire requested lock.
 */
int
vn_lock(struct vnode *vp, int flags, struct proc *p)
{
	int error;

	do {
		if (vp->v_flag & VXLOCK) {
			vp->v_flag |= VXWANT;
			tsleep(vp, PINOD, "vn_lock", 0);
			error = ENOENT;
		} else {
			error = VOP_LOCK(vp, flags, p);
			if (error == 0)
				return (error);
		}
	} while (flags & LK_RETRY);
	return (error);
}

/*
 * File table vnode close routine.
 */
int
vn_closefile(struct file *fp, struct proc *p)
{
	struct vnode *vp = fp->f_data;
	struct flock lf;
	
	if ((fp->f_iflags & FIF_HASLOCK)) {
		lf.l_whence = SEEK_SET;
		lf.l_start = 0;
		lf.l_len = 0;
		lf.l_type = F_UNLCK;
		(void) VOP_ADVLOCK(vp, (caddr_t)fp, F_UNLCK, &lf, F_FLOCK);
	}

	return (vn_close(vp, fp->f_flag, fp->f_cred, p));
}

int
vn_kqfilter(struct file *fp, struct knote *kn)
{
	return (VOP_KQFILTER(fp->f_data, kn));
}

/*
 * Common code for vnode access operations.
 */

/* Check if a directory can be found inside another in the hierarchy */
int
vn_isunder(struct vnode *lvp, struct vnode *rvp, struct proc *p)
{
	int error;

	error = vfs_getcwd_common(lvp, rvp, NULL, NULL, MAXPATHLEN/2, 0, p);

	if (!error)
		return (1);

	return (0);
}
@


1.86
log
@Make read(2) return EISDIR on directories.

Years ago Theo made read(2) return 0 on directories, instead of dumping
the directory content.  Another behavior is allowed as an extension by
POSIX, returning an EISDIR error, as used on a few other systems.  This
behavior is deemed more useful as it helps spotting errors.  This
implies that it might break some setups.

Ports bulk builds by ajacoutot@@ and naddy@@, ok millert@@ bluhm@@ naddy@@
deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.85 2016/06/19 11:54:33 natano Exp $	*/
d331 1
a331 1
	int error = 0;
@


1.85
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.84 2016/03/19 12:04:15 natano Exp $	*/
d339 3
d344 2
a345 3
	if (vp->v_type != VDIR)
		error = VOP_READ(vp, uio,
		    (fp->f_flag & FNONBLOCK) ? IO_NDELAY : 0, cred);
@


1.84
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.83 2016/01/06 17:59:30 tedu Exp $	*/
a515 3
	if ((flags & LK_RECURSEFAIL) == 0)
		flags |= LK_CANRECURSE;
	
@


1.83
log
@remove unnecessary casts where the incoming type is void *.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.82 2015/05/01 01:30:58 millert Exp $	*/
d174 1
a174 1
		VOP_UNLOCK(vp, 0, p);		/* keep a reference */
d314 1
a314 1
		VOP_UNLOCK(vp, 0, p);
d345 1
a345 1
	VOP_UNLOCK(vp, 0, p);
d377 1
a377 1
	VOP_UNLOCK(vp, 0, p);
@


1.82
log
@Pass fflag to VOP_POLL so vfs fifo functions can get at the file
flags to check FREAD/FWRITE if needed.  This will be used by fifo_poll
to avoid checking the write end of the fifo when the fd is read-only.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.81 2015/03/14 03:38:51 jsg Exp $	*/
d330 1
a330 1
	struct vnode *vp = (struct vnode *)fp->f_data;
d355 1
a355 1
	struct vnode *vp = (struct vnode *)fp->f_data;
d387 1
a387 1
	struct vnode *vp = (struct vnode *)fp->f_data;
d461 1
a461 1
	struct vnode *vp = ((struct vnode *)fp->f_data);
d504 1
a504 1
	return (VOP_POLL(((struct vnode *)fp->f_data), fp->f_flag, events, p));
d556 1
a556 1
	return (VOP_KQFILTER(((struct vnode *)fp->f_data), kn));
@


1.81
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.80 2014/12/16 18:30:04 tedu Exp $	*/
d504 1
a504 1
	return (VOP_POLL(((struct vnode *)fp->f_data), events, p));
@


1.80
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.79 2014/11/03 21:28:35 tedu Exp $	*/
a45 1
#include <sys/buf.h>
@


1.79
log
@include sys/unistd.h where needed instead of indirect reliance. ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.78 2014/07/13 15:00:40 tedu Exp $	*/
d52 1
@


1.78
log
@pass the size to free in some of the obvious cases
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.77 2014/07/12 18:43:32 tedu Exp $	*/
d59 1
@


1.77
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.76 2014/07/08 17:19:25 deraadt Exp $	*/
d176 1
a176 1
		free(cip, M_TEMP, 0);
@


1.76
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.75 2014/01/24 06:00:01 guenther Exp $	*/
d176 1
a176 1
		free(cip, M_TEMP);
@


1.75
log
@Copy timespecs member by member in fo_stat callback functions, to avoid
leaking values in the padding bytes on LP64.  Also, vn_stat() was lacking
the zero-fill to clean its padding.

ok kettenis@@ deraadt@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.74 2013/09/14 02:28:01 guenther Exp $	*/
a58 2

#include <uvm/uvm_extern.h>
@


1.74
log
@Correct the handling of I/O of >=2^32 bytes and the ktracing there of
by using size_t/ssize_t instead of int/u_int to handle I/O lengths in
uiomove(), vn_fsizechk(), and ktrgenio().  Eliminate the always-zero
'error' argument to ktrgenio() at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.73 2013/06/05 01:26:00 guenther Exp $	*/
d408 1
d443 6
a448 3
	sb->st_atim = va.va_atime;
	sb->st_mtim = va.va_mtime;
	sb->st_ctim = va.va_ctime;
@


1.73
log
@Move FHASLOCK from f_flag to f_iflags, freeing up a bit for passing
O_* flags and eliminating an XXX comment.

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.72 2013/03/30 06:32:25 tedu Exp $	*/
d235 1
a235 1
vn_fsizechk(struct vnode *vp, struct uio *uio, int ioflag, int *overrun)
@


1.72
log
@vrele() is a tricky beast. it can sleep if the refcount hits zero,
leaving us with a free type function that isn't atomic. deal with this
by erasing any reachable pointers to the vnode first, then free it.
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.71 2012/07/11 12:39:20 guenther Exp $	*/
d539 1
a539 1
	if ((fp->f_flag & FHASLOCK)) {
@


1.71
log
@If the current offset is strictly less than the process filesize
rlimit, then a write that would take it over the limit should be
clamped, making it a partial write.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.70 2011/11/27 21:31:08 guenther Exp $	*/
d485 1
a485 2
			if (s->s_ttyvp)
				vrele(s->s_ttyvp);
d488 2
@


1.70
log
@When checking for offset wrap around in vn_read(), compare against
LLONG_MAX instead of SSIZE_MAX

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.69 2011/11/07 17:50:17 guenther Exp $	*/
d48 2
d226 33
@


1.69
log
@Make pwrite/pwritev ignore the O_APPEND flag.
Detect attempts to wrap the file offset by reading past the max (except
for character devices).

ok matthew@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.68 2011/07/09 01:28:48 matthew Exp $	*/
d302 1
a302 1
	if (vp->v_type != VCHR && count > SSIZE_MAX - *poff)
@


1.68
log
@Add support for the O_CLOEXEC and O_DIRECTORY flags introduced in
POSIX Issue 7.

Requested by oga@@ (and maybe djm@@); ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.67 2011/07/06 09:14:26 matthew Exp $	*/
d298 1
a298 1
	size_t count;
d301 4
a306 1
	count = uio->uio_resid;
d326 3
a328 1
	if (vp->v_type == VREG && (fp->f_flag & O_APPEND))
@


1.67
log
@Minor turd polishing: hold the vnode lock in vn_rdwr() only while
necessary.

"ok ... wait wait WAIT!! ... oh, yeah, it's fine, ok" guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.66 2011/07/04 20:35:35 deraadt Exp $	*/
d136 4
@


1.66
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.65 2010/07/26 01:56:27 guenther Exp $	*/
a257 2
	if ((ioflg & IO_NODELOCKED) == 0)
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d267 3
d275 3
a282 2
	if ((ioflg & IO_NODELOCKED) == 0)
		VOP_UNLOCK(vp, 0, p);
@


1.65
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.64 2010/01/08 19:18:21 stsp Exp $	*/
d56 1
a58 1
#include <miscfs/specfs/specdev.h>
@


1.64
log
@As advertised in the man page, make open(2) return ELOOP (instead
of EMLINK) if the O_NOFOLLOW flag is set and the target is a symlink.
Aligns with Solaris and Linux behaviour.

ok tedu@@ thib@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.63 2009/07/09 22:29:56 thib Exp $	*/
d438 4
a441 3
			if (p->p_session->s_ttyvp)
				vrele(p->p_session->s_ttyvp);
			p->p_session->s_ttyvp = vp;
@


1.63
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.61 2009/01/24 23:25:17 thib Exp $	*/
d135 1
a135 1
		error = EMLINK;
@


1.62
log
@Switch struct stat's timespec members to the names standardized in
POSIX 1003.1-2008, with compatibility macros for the names used in
previous version of OpenBSD.  Update all the references in the
kernel to use the new, standard member names.

ok'ed by miod@@, otto@@; ports build test by naddy@@
@
text
@d441 1
a441 1
			VREF(vp);
@


1.61
log
@propagate the O_EXCL flag down to the file systems, by setting
VA_EXCLUSIVE. Handle this in NFS, also in NFS use arc4random()
for the create verifier instead of an uninitialized long and
the address of the first interface (which is likely to be lo0).

Lifted from NetBSD with small tweaks;
"looks good", miod@@
OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.60 2008/09/19 12:24:55 art Exp $	*/
d396 3
a398 3
	sb->st_atimespec = va.va_atime;
	sb->st_mtimespec = va.va_mtime;
	sb->st_ctimespec = va.va_ctime;
@


1.60
log
@Fix a bunch of problems and races with posix file locking.

- file descriptor table becomes the owner of the lock instead of the proc.
- When grabbing the lock, we check if the fd hasn't changed under our
  feet, this is more or less impossible to solve without a hack like
  this. I've banged my head against the wall, I figured out a solution,
  but implementing it correctly would cost me 12 gray hairs. Screw it,
  this is ugly, but it works.
- Wait until usecount drains before releasing the posix lock in closef.
- Add missing FREF/FRELE to sys_flock
- keep the pid in the flock struct instead of abusing the fact that we
  used to use the proc as the lock owner.

Pointed out by and discussed with Al Viro, big thanks.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.59 2008/04/08 14:46:45 thib Exp $	*/
d100 2
@


1.59
log
@bring cloning up too date; Munge it so it will work with atleast
oga@@'s upcoming DRM changes and too some degree ratchov@@'s audio
work. It still works for bpf's though.

Parts from ratchov@@; fstat(1) parts from Pedro Martelletto;
tested by many, ok'ed by a few;
"get going with cloning" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.58 2007/06/14 20:36:34 otto Exp $	*/
d55 1
d486 12
a497 2
	return (vn_close(((struct vnode *)fp->f_data), fp->f_flag,
		fp->f_cred, p));
@


1.58
log
@Forgotten hackton diff: bounds check for seek on special devices
with a disklabel.  Original diff from pedro@@; ok pedro@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.57 2007/06/01 22:30:46 deraadt Exp $	*/
d80 1
d160 1
a160 1
		struct cloneinfo *cip = (struct cloneinfo *) vp->v_data;
d163 5
a167 4
		ndp->ni_vp = cip->ci_vp; /* return cloned vnode */
		vp->v_data = cip->ci_data; /* restore v_data */
		VOP_UNLOCK(vp, 0, p); /* keep a reference */
		vp = ndp->ni_vp; /* for the increment below */
@


1.57
log
@FIBMAP is used by nothing; checked by miod and pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.56 2007/05/05 12:03:04 art Exp $	*/
a63 1
int vn_ioctl(struct file *, u_long, caddr_t, struct proc *);
@


1.56
log
@vn_access hasn't been used for ages and it's just a wrapper with
locking around VOP_ACCESS. It can go.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.55 2007/03/21 17:29:32 thib Exp $	*/
a422 3
		if (com == FIBMAP)
			return VOP_IOCTL(vp, com, data, fp->f_flag,
					 p->p_ucred, p);
@


1.55
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.54 2007/01/16 17:52:18 thib Exp $	*/
a499 14
int
vn_access(struct vnode *vp, int mode)
{
	struct proc *p = curproc;
	int error;

	if ((error = vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p)))
		return (error);

	error = VOP_ACCESS(vp, mode, p->p_ucred, p);
	VOP_UNLOCK(vp, 0, p);

	return (error);
}
@


1.54
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.53 2006/06/02 20:25:09 pedro Exp $	*/
a467 2
		if ((flags & LK_INTERLOCK) == 0)
			simple_lock(&vp->v_interlock);
a469 1
			simple_unlock(&vp->v_interlock);
d473 1
a473 1
			error = VOP_LOCK(vp, flags | LK_INTERLOCK, p);
a476 1
		flags &= ~LK_INTERLOCK;
@


1.53
log
@Add a clonable devices implementation. Hacked along with thib@@, input
from krw@@ and toby@@, subliminal prodding from dlg@@, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.52 2006/05/01 21:50:48 pedro Exp $	*/
a98 1
			VOP_LEASE(ndp->ni_dvp, p, cred, LEASE_WRITE);
a150 3
		VOP_UNLOCK(vp, 0, p);				/* XXX */
		VOP_LEASE(vp, p, cred, LEASE_WRITE);
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);	/* XXX */
a290 1
	VOP_LEASE(vp, uio->uio_procp, cred, LEASE_READ);
a319 1
	VOP_LEASE(vp, uio->uio_procp, cred, LEASE_WRITE);
@


1.52
log
@Move vn_isunder() to vfs_vnops.c, that's the place for vn_* functions
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.51 2006/04/23 17:36:09 pedro Exp $	*/
d43 1
d57 1
d162 13
@


1.51
log
@'fall into' -> FALLTHROUGH
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.50 2006/04/23 17:35:08 pedro Exp $	*/
d508 14
@


1.50
log
@Remove unnecessary ARGSUSED comment
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.49 2006/04/23 17:30:56 pedro Exp $	*/
d419 1
a419 2
		/* fall into... */

@


1.49
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.48 2005/12/04 19:04:13 pedro Exp $	*/
a486 1
/*ARGSUSED*/
@


1.48
log
@Add vn_access(), discussed with and okay uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.47 2005/11/20 21:55:15 pedro Exp $	*/
d182 3
a184 1
		case VREG: case VDIR: case VLNK:
d186 6
a191 2
		case VNON: case VCHR: case VSOCK:
		case VFIFO: case VBAD: case VBLK:
@


1.47
log
@Use ANSI function declarations and deregister, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.46 2005/05/28 07:30:25 marius Exp $	*/
d486 18
@


1.46
log
@have vn_close() lock the vnode before calling VOP_CLOSE().

fix the acct_*() code so that we always have a proc to lock on.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.45 2004/07/13 21:04:29 millert Exp $	*/
d57 6
a62 9
int	vn_read(struct file *fp, off_t *off, struct uio *uio, 
	    struct ucred *cred);
int	vn_write(struct file *fp, off_t *off, struct uio *uio, 
	    struct ucred *cred);
int	vn_poll(struct file *fp, int events, struct proc *p);
int	vn_kqfilter(struct file *fp, struct knote *kn);
int 	vn_closefile(struct file *fp, struct proc *p);
int	vn_ioctl(struct file *fp, u_long com, caddr_t data,
	    struct proc *p);
d73 5
a77 7
vn_open(ndp, fmode, cmode)
	register struct nameidata *ndp;
	int fmode, cmode;
{
	register struct vnode *vp;
	register struct proc *p = ndp->ni_cnd.cn_proc;
	register struct ucred *cred = p->p_ucred;
d173 1
a173 2
vn_writechk(vp)
	register struct vnode *vp;
a174 1

d204 1
a204 2
vn_marktext(vp)
	struct vnode *vp;
d213 1
a213 5
vn_close(vp, flags, cred, p)
	register struct vnode *vp;
	int flags;
	struct ucred *cred;
	struct proc *p;
d229 3
a231 11
vn_rdwr(rw, vp, base, len, offset, segflg, ioflg, cred, aresid, p)
	enum uio_rw rw;
	struct vnode *vp;
	caddr_t base;
	int len;
	off_t offset;
	enum uio_seg segflg;
	int ioflg;
	struct ucred *cred;
	size_t *aresid;
	struct proc *p;
d267 1
a267 5
vn_read(fp, poff, uio, cred)
	struct file *fp;
	off_t *poff;
	struct uio *uio;
	struct ucred *cred;
d269 1
a269 1
	register struct vnode *vp = (struct vnode *)fp->f_data;
d290 1
a290 5
vn_write(fp, poff, uio, cred)
	struct file *fp;
	off_t *poff;
	struct uio *uio;
	struct ucred *cred;
d292 1
a292 1
	register struct vnode *vp = (struct vnode *)fp->f_data;
d321 1
a321 4
vn_statfile(fp, sb, p)
	struct file *fp;
	struct stat *sb;
	struct proc *p;
a323 1

d331 1
a331 4
vn_stat(vp, sb, p)
	struct vnode *vp;
	register struct stat *sb;
	struct proc *p;
d391 1
a391 5
vn_ioctl(fp, com, data, p)
	struct file *fp;
	u_long com;
	caddr_t data;
	struct proc *p;
d393 1
a393 1
	register struct vnode *vp = ((struct vnode *)fp->f_data);
d436 1
a436 4
vn_poll(fp, events, p)
	struct file *fp;
	int events;
	struct proc *p;
a437 1

d475 1
a475 3
vn_closefile(fp, p)
	struct file *fp;
	struct proc *p;
a476 1

@


1.45
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.44 2003/09/23 16:51:12 millert Exp $	*/
d231 1
d233 1
a233 1
	vrele(vp);
@


1.44
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.43 2003/07/21 22:44:50 tedu Exp $	*/
d369 1
a369 1
	u_short mode;
@


1.43
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.42 2003/06/02 23:28:07 millert Exp $	*/
d53 1
d61 1
a61 1
int	vn_select(struct file *fp, int which, struct proc *p);
d68 1
a68 1
	{ vn_read, vn_write, vn_ioctl, vn_select, vn_kqfilter, vn_statfile,
d471 1
a471 1
 * File table vnode select routine.
d474 1
a474 1
vn_select(fp, which, p)
d476 1
a476 1
	int which;
d480 1
a480 2
	return (VOP_SELECT(((struct vnode *)fp->f_data), which, fp->f_flag,
			   fp->f_cred, p));
@


1.42
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.41 2002/03/17 18:22:25 art Exp $	*/
d501 1
a501 1
			tsleep((caddr_t)vp, PINOD, "vn_lock", 0);
@


1.41
log
@Since LK_RECURSEFAIL and LK_CANRECURSE contradict each other
(although they are not opposites), avoid setting LK_CANRECURSE if
LK_RECURSEFAIL is set in the caller.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.40 2002/03/14 01:27:06 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.40
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.39 2001/12/19 08:58:06 art Exp $	*/
d492 1
a492 4
vn_lock(vp, flags, p)
	struct vnode *vp;
	int flags;
	struct proc *p;
d495 3
d508 1
a508 1
			error = VOP_LOCK(vp, flags | LK_INTERLOCK | LK_CANRECURSE, p);
@


1.39
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.35 2001/11/15 06:22:30 art Exp $	*/
d60 9
a68 9
int	vn_read __P((struct file *fp, off_t *off, struct uio *uio, 
	    struct ucred *cred));
int	vn_write __P((struct file *fp, off_t *off, struct uio *uio, 
	    struct ucred *cred));
int	vn_select __P((struct file *fp, int which, struct proc *p));
int	vn_kqfilter __P((struct file *fp, struct knote *kn));
int 	vn_closefile __P((struct file *fp, struct proc *p));
int	vn_ioctl __P((struct file *fp, u_long com, caddr_t data,
	    struct proc *p));
@


1.38
log
@Don't sleep on VXLOCK if LK_NOWAIT.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.37 2001/12/10 02:19:34 art Exp $	*/
a167 5
	if (vp->v_type == VREG &&
	    uvn_attach(vp, fmode & FWRITE ? VM_PROT_WRITE : 0) == NULL) {
		error = EIO;
		goto bad;
	}
d200 3
a202 2
	 * If the vnode is in use as a process's text,
	 * we can't allow writing.
d204 1
a204 1
	if (vp->v_flag & VTEXT)
a216 17
	if ((vp->v_flag & VTEXT) == 0) {
		uvmexp.vnodepages -= vp->v_uobj.uo_npages;
		uvmexp.vtextpages += vp->v_uobj.uo_npages;
#if 0
	/*
	 * Doesn't help much because the pager is borked and ubc_flush is
	 * slow.
	 */
#ifdef PMAP_PREFER
		/*
		 * Get rid of any cached reads from this vnode.
		 * exec can't respect PMAP_PREFER when mapping the text.
		 */
		ubc_flush(&vp->v_uobj, 0, 0);
#endif
#endif
	}
a502 4
			if (flags & LK_NOWAIT) {
				simple_unlock(&vp->v_interlock);
				return (EBUSY);
			}
@


1.38.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.38 2001/12/10 18:45:34 art Exp $	*/
d60 9
a68 9
int	vn_read(struct file *fp, off_t *off, struct uio *uio, 
	    struct ucred *cred);
int	vn_write(struct file *fp, off_t *off, struct uio *uio, 
	    struct ucred *cred);
int	vn_select(struct file *fp, int which, struct proc *p);
int	vn_kqfilter(struct file *fp, struct knote *kn);
int 	vn_closefile(struct file *fp, struct proc *p);
int	vn_ioctl(struct file *fp, u_long com, caddr_t data,
	    struct proc *p);
d513 4
a516 1
vn_lock(struct vnode *vp, int flags, struct proc *p)
a518 3

	if ((flags & LK_RECURSEFAIL) == 0)
		flags |= LK_CANRECURSE;
d533 1
a533 1
			error = VOP_LOCK(vp, flags | LK_INTERLOCK, p);
@


1.38.2.2
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.38.2.1 2002/06/11 03:29:41 art Exp $	*/
d222 2
a223 2
		uvmexp.filepages -= vp->v_uobj.uo_npages;
		uvmexp.execpages += vp->v_uobj.uo_npages;
@


1.38.2.3
log
@add VEXECMAP.  also make sure to modify filepages count only in the not
execpages case in uvm_pageremove().
this actually appears to solve the swap freak out problems.  sitting on it for
a long time, never checked if it worked.  sigh.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.38.2.2 2002/11/04 18:02:31 art Exp $	*/
a213 12
void
vn_markexec(vp)
	struct vnode *vp;
{
	if ((vp->v_flag & VEXECMAP) == 0) {
		uvmexp.filepages -= vp->v_uobj.uo_npages;
		uvmexp.execpages += vp->v_uobj.uo_npages;
	}
	vp->v_flag |= VEXECMAP;
}


d217 1
a217 1
int
d221 16
a236 3
	if (vp->v_writecount != 0) {
		KASSERT((vp->v_flag & VTEXT) == 0);
		return (ETXTBSY);
a238 2
	vn_markexec(vp);
	return (0);
@


1.37
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.36 2001/11/27 05:27:12 art Exp $	*/
d524 4
@


1.36
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.35 2001/11/15 06:22:30 art Exp $	*/
d222 2
a223 2
		uvmexp.vnodepages -= vp->v_uvm.u_obj.uo_npages;
		uvmexp.vtextpages += vp->v_uvm.u_obj.uo_npages;
d234 1
a234 1
		ubc_flush(&vp->v_uvm.u_obj, 0, 0);
@


1.35
log
@New function vn_marktext - mark a vnode as executing a text image.
Use where VTEXT was set in vnode flags before. Doesn't do anything else (yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.34 2001/11/06 19:53:20 miod Exp $	*/
d168 5
d205 2
a206 3
	 * If there's shared text associated with
	 * the vnode, try to free it up once.  If
	 * we fail, we can't allow writing.
d208 1
a208 1
	if ((vp->v_flag & VTEXT) && !uvm_vnp_uncache(vp))
d221 17
@


1.34
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.33 2001/07/16 18:25:43 millert Exp $	*/
d208 10
@


1.33
log
@Ignore O_TRUNC on open() if we are not opening a regular file.
csapuntz@@ OK'd
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.32 2001/06/27 04:49:48 art Exp $	*/
a56 2

#include <vm/vm.h>
@


1.32
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.31 2001/06/22 14:14:11 deraadt Exp $	*/
d159 1
a159 1
	if (fmode & O_TRUNC) {
@


1.31
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.30 2001/05/14 12:38:47 art Exp $	*/
a59 1
#if defined(UVM)
a60 1
#endif
a205 1
#if defined(UVM)
d208 1
a208 4
#else
	if ((vp->v_flag & VTEXT) && !vnode_pager_uncache(vp))
		return (ETXTBSY);
#endif
@


1.30
log
@Add a fo_stat member to struct fileops. Used soon.
Also add a stat function for kqueue from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.29 2001/05/14 12:11:53 art Exp $	*/
d67 1
a67 1
            struct ucred *cred));
d451 1
a451 1
			return (0);                     /* XXX */
@


1.29
log
@Implement a wrapper round vn_stat that takes the same arguments
as soo_stat and pipe_stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.28 2001/03/01 20:54:34 provos Exp $	*/
d75 2
a76 1
	{ vn_read, vn_write, vn_ioctl, vn_select, vn_kqfilter, vn_closefile };
@


1.28
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.27 2000/11/21 21:49:57 provos Exp $	*/
d345 15
a359 1
 * File table vnode stat routine.
@


1.27
log
@support for kernel events on vnodes, from jlemon@@freebsd.org, okay art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.26 2000/04/25 02:10:04 deraadt Exp $	*/
a63 3
#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>

d69 1
d75 1
a75 20
	{ vn_read, vn_write, vn_ioctl, vn_select, vn_closefile };

static int	filt_nullattach(struct knote *kn);
static int	filt_vnattach(struct knote *kn);
static void	filt_vndetach(struct knote *kn);
static int	filt_vnode(struct knote *kn, long hint);
static int	filt_vnread(struct knote *kn, long hint);

struct filterops vn_filtops =
	{ 1, filt_vnattach, filt_vndetach, filt_vnode };

/*
 * XXX
 * filt_vnread is ufs-specific, so the attach routine should really
 * switch out to different filterops based on the vn filetype
 */
struct filterops vn_rwfiltops[] = {
	{ 1, filt_vnattach, filt_vndetach, filt_vnread },
	{ 1, filt_nullattach, NULL, NULL },
};
a512 50
static int
filt_vnattach(struct knote *kn)
{
	struct vnode *vp;

	if (kn->kn_fp->f_type != DTYPE_VNODE)
		return (EBADF);

	vp = (struct vnode *)kn->kn_fp->f_data;

	/*
	 * XXX
	 * this is a hack simply to cause the filter attach to fail
	 * for non-ufs filesystems, until the support for them is done.
	 */
	if ((vp)->v_tag != VT_UFS || (vp)->v_type == VFIFO)
		return (EOPNOTSUPP);

	simple_lock(&vp->v_selectinfo.vsi_lock);
	SLIST_INSERT_HEAD(&vp->v_selectinfo.vsi_selinfo.si_note, kn, kn_selnext);
	simple_unlock(&vp->v_selectinfo.vsi_lock);

	return (0);
}

static void
filt_vndetach(struct knote *kn)
{
	struct vnode *vp = (struct vnode *)kn->kn_fp->f_data;

	simple_lock(&vp->v_selectinfo.vsi_lock);
	SLIST_REMOVE(&vp->v_selectinfo.vsi_selinfo.si_note,
	    kn, knote, kn_selnext);
	simple_unlock(&vp->v_selectinfo.vsi_lock);
}

static int
filt_vnode(struct knote *kn, long hint)
{
	if (kn->kn_sfflags & hint)
		kn->kn_fflags |= hint;
	return (kn->kn_fflags != 0);
}

static int
filt_nullattach(struct knote *kn)
{
	return (ENXIO);
}

d514 2
a515 2
static int
filt_vnread(struct knote *kn, long hint)
d517 1
a517 5
	struct vnode *vp = (struct vnode *)kn->kn_fp->f_data;
	struct inode *ip = VTOI(vp);

	kn->kn_data = ip->i_ffs_size - kn->kn_fp->f_offset;
	return (kn->kn_data != 0);
@


1.26
log
@non-O_NOFOLLOW error introduced by accident, this is fragile code..
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.25 2000/04/21 15:47:28 millert Exp $	*/
d64 3
d79 19
d532 61
@


1.25
log
@Change kernel-only open flag FNOSYMLINK to userland-visible O_NOFOLLOW;
adapated from FreeBSD.  Also change O_FSYNC to the more standard O_SYNC
and document it.  open(2) needs some real examples for proper usage,
to come later.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.24 2000/04/19 08:34:53 csapuntz Exp $	*/
d126 1
@


1.24
log
@

Change struct file interface methods read and write to pass file offset in
and out.

Make pread/pwrite in netbsd & linux thread safe - which is the whole point
anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.23 1999/11/13 03:48:09 angelos Exp $	*/
d98 1
a98 2
		if (((fmode & O_EXCL) == 0) &&
		    ((fmode & FNOSYMLINK) == 0))
a125 7
			if ((ndp->ni_vp->v_type == VLNK) &&
			    ((fmode & FNOSYMLINK) != 0)) {
				error = EFTYPE;
				goto bad;
			}

			fmode &= ~O_CREAT;
d129 2
a130 1
		ndp->ni_cnd.cn_flags = FOLLOW | LOCKLEAF;
d139 4
d326 1
a326 1
	if ((fp->f_flag & O_FSYNC) ||
@


1.23
log
@FIBMAP ioctl from Linux, only usable on ISO 9660 FS. Note that the lba
returned is in 512-byte sectors, so if you're going to use it for
things like DVD, you need to divide the result by 4 (for 2048-byte
sectors). OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.22 1999/08/26 08:07:10 art Exp $	*/
d64 9
d287 1
a287 1
vn_read(fp, uio, cred)
d289 1
d300 1
a300 1
	uio->uio_offset = fp->f_offset;
d305 1
a305 1
	fp->f_offset += count - uio->uio_resid;
d314 1
a314 1
vn_write(fp, uio, cred)
d316 1
d334 1
a334 1
	uio->uio_offset = fp->f_offset;
d338 1
a338 1
		fp->f_offset = uio->uio_offset;
d340 1
a340 1
		fp->f_offset += count - uio->uio_resid;
d436 3
a438 3
		if (com == FIONBIO || com == FIOASYNC)	/* XXX */
			return (0);			/* XXX */
		/* fall into ... */
d442 1
a442 1

@


1.23.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.28 2001/03/01 20:54:34 provos Exp $	*/
a63 10
int	vn_read __P((struct file *fp, off_t *off, struct uio *uio, 
	    struct ucred *cred));
int	vn_write __P((struct file *fp, off_t *off, struct uio *uio, 
            struct ucred *cred));
int	vn_select __P((struct file *fp, int which, struct proc *p));
int	vn_kqfilter __P((struct file *fp, struct knote *kn));
int 	vn_closefile __P((struct file *fp, struct proc *p));
int	vn_ioctl __P((struct file *fp, u_long com, caddr_t data,
	    struct proc *p));

d65 1
a65 1
	{ vn_read, vn_write, vn_ioctl, vn_select, vn_kqfilter, vn_closefile };
d89 2
a90 1
		if ((fmode & O_EXCL) == 0 && (fmode & O_NOFOLLOW) == 0)
d118 6
d128 1
a128 2
		ndp->ni_cnd.cn_flags =
		    ((fmode & O_NOFOLLOW) ? NOFOLLOW : FOLLOW) | LOCKLEAF;
a136 4
	if (vp->v_type == VLNK) {
		error = EMLINK;
		goto bad;
	}
d278 1
a278 1
vn_read(fp, poff, uio, cred)
a279 1
	off_t *poff;
d290 1
a290 1
	uio->uio_offset = *poff;
d295 1
a295 1
	*poff += count - uio->uio_resid;
d304 1
a304 1
vn_write(fp, poff, uio, cred)
a305 1
	off_t *poff;
d318 1
a318 1
	if ((fp->f_flag & FFSYNC) ||
d323 1
a323 1
	uio->uio_offset = *poff;
d327 1
a327 1
		*poff = uio->uio_offset;
d329 1
a329 1
		*poff += count - uio->uio_resid;
d425 3
a427 3
		if (com == FIONBIO || com == FIOASYNC)  /* XXX */
			return (0);                     /* XXX */
		/* fall into... */
d431 1
a431 1
		
a500 7
}

/*ARGSUSED*/
int
vn_kqfilter(struct file *fp, struct knote *kn)
{
	return (VOP_KQFILTER(((struct vnode *)fp->f_data), kn));
@


1.23.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.23.2.1 2001/05/14 22:32:46 niklas Exp $	*/
d60 1
d62 1
d67 1
a67 1
	    struct ucred *cred));
d75 1
a75 2
	{ vn_read, vn_write, vn_ioctl, vn_select, vn_kqfilter, vn_statfile,
	  vn_closefile };
d207 1
d210 4
a213 1

d345 1
a345 15
 * File table wrapper for vn_stat
 */
int
vn_statfile(fp, sb, p)
	struct file *fp;
	struct stat *sb;
	struct proc *p;
{
	struct vnode *vp = (struct vnode *)fp->f_data;

	return vn_stat(vp, sb, p);
}

/*
 * vnode stat routine.
d436 1
a436 1
			return (0);			/* XXX */
@


1.23.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.23.2.2 2001/07/04 10:48:56 niklas Exp $	*/
d159 1
a159 1
	if ((fmode & O_TRUNC) && vp->v_type == VREG) {
@


1.23.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 2
@


1.23.2.5
log
@Merge in -current
@
text
@a167 5
	if (vp->v_type == VREG &&
	    uvn_attach(vp, fmode & FWRITE ? VM_PROT_WRITE : 0) == NULL) {
		error = EIO;
		goto bad;
	}
d200 3
a202 2
	 * If the vnode is in use as a process's text,
	 * we can't allow writing.
d204 1
a204 1
	if (vp->v_flag & VTEXT)
a207 27
}

/*
 * Mark a vnode as being the text image of a running process.
 */
void
vn_marktext(vp)
	struct vnode *vp;
{
	if ((vp->v_flag & VTEXT) == 0) {
		uvmexp.vnodepages -= vp->v_uvm.u_obj.uo_npages;
		uvmexp.vtextpages += vp->v_uvm.u_obj.uo_npages;
#if 0
	/*
	 * Doesn't help much because the pager is borked and ubc_flush is
	 * slow.
	 */
#ifdef PMAP_PREFER
		/*
		 * Get rid of any cached reads from this vnode.
		 * exec can't respect PMAP_PREFER when mapping the text.
		 */
		ubc_flush(&vp->v_uvm.u_obj, 0, 0);
#endif
#endif
	}
	vp->v_flag |= VTEXT;
@


1.23.2.6
log
@Merge in trunk
@
text
@d168 5
d205 2
a206 3
	 * If there's shared text associated with
	 * the vnode, try to free it up once.  If
	 * we fail, we can't allow writing.
d208 1
a208 1
	if ((vp->v_flag & VTEXT) && !uvm_vnp_uncache(vp))
d221 17
@


1.23.2.7
log
@Merge in -current from about a week ago
@
text
@d60 9
a68 9
int	vn_read(struct file *fp, off_t *off, struct uio *uio, 
	    struct ucred *cred);
int	vn_write(struct file *fp, off_t *off, struct uio *uio, 
	    struct ucred *cred);
int	vn_select(struct file *fp, int which, struct proc *p);
int	vn_kqfilter(struct file *fp, struct knote *kn);
int 	vn_closefile(struct file *fp, struct proc *p);
int	vn_ioctl(struct file *fp, u_long com, caddr_t data,
	    struct proc *p);
d492 4
a495 1
vn_lock(struct vnode *vp, int flags, struct proc *p)
a497 3

	if ((flags & LK_RECURSEFAIL) == 0)
		flags |= LK_CANRECURSE;
d508 1
a508 1
			error = VOP_LOCK(vp, flags | LK_INTERLOCK, p);
@


1.23.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.23.2.7 2002/03/28 11:43:04 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.23.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a52 1
#include <sys/poll.h>
d60 1
a60 1
int	vn_poll(struct file *fp, int events, struct proc *p);
d67 1
a67 1
	{ vn_read, vn_write, vn_ioctl, vn_poll, vn_kqfilter, vn_statfile,
d470 1
a470 1
 * File table vnode poll routine.
d473 1
a473 1
vn_poll(fp, events, p)
d475 1
a475 1
	int events;
d479 2
a480 1
	return (VOP_POLL(((struct vnode *)fp->f_data), events, p));
d501 1
a501 1
			tsleep(vp, PINOD, "vn_lock", 0);
@


1.22
log
@change a & to &&. From dima@@best.net
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.21 1999/07/18 01:20:22 deraadt Exp $	*/
d56 1
d422 3
@


1.21
log
@ugly C
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.20 1999/02/26 04:51:17 art Exp $	*/
d117 1
a117 1
			if ((ndp->ni_vp->v_type == VLNK) &
@


1.20
log
@adaptation to uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.19 1998/12/05 17:16:54 csapuntz Exp $	*/
d379 1
a379 1
	};
@


1.19
log
@

Reinstate supposed dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.18 1998/12/05 16:44:09 csapuntz Exp $	*/
d59 4
d198 4
d204 1
@


1.18
log
@

Dead code elimination
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.17 1998/08/06 19:34:29 csapuntz Exp $	*/
d466 1
@


1.17
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.16 1998/07/28 00:13:04 millert Exp $	*/
a465 1
			error = ENOENT;
@


1.16
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.15 1998/01/15 01:24:40 csapuntz Exp $	*/
d468 1
a468 1
			error = VOP_LOCK(vp, flags | LK_INTERLOCK, p);
@


1.15
log
@Re-enabled write protection on read-only file system mounts. Thanks to
Niels for pointing this one out.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.14 1998/01/09 16:33:49 csapuntz Exp $	*/
d231 1
a231 1
	int *aresid;
d274 2
a275 1
	int count, error = 0;
d301 2
a302 1
	int count, error, ioflag = IO_UNIT;
@


1.14
log
@Get rid of dumping across symlinks. Races can cause this to be problematic
from a security standpoint (i.e. arbitrary files on the FS can be wiped out).
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.13 1997/12/10 19:44:09 deraadt Exp $	*/
a174 1
#if 0
a188 1
#endif
@


1.13
log
@extra ()
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.12 1997/12/10 19:39:41 millert Exp $	*/
d84 2
a85 1
		if ((fmode & O_EXCL) == 0)
d89 1
d113 6
@


1.12
log
@Remove special case for O_TRUNC that is irelevant now that
we disallow O_TRUNC with O_RDONLY.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.11 1997/12/10 19:31:17 deraadt Exp $	*/
d79 1
a79 1
	if (fmode & (O_TRUNC | FWRITE) == O_TRUNC)
@


1.11
log
@try again; proactively check that O_TRUNC has FWRITE
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.10 1997/12/10 19:15:09 deraadt Exp $	*/
d129 1
a129 1
		if (fmode & (FWRITE | O_TRUNC)) {
@


1.10
log
@only permit O_TRUNC if FWRITE is set; chatted about by millert and myself for nearly an hour
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.9 1997/11/06 05:58:29 csapuntz Exp $	*/
d79 2
d129 1
a129 1
		if ((fmode & (FWRITE | O_TRUNC)) == (FWRITE | O_TRUNC)) {
d142 1
a142 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);				/* XXX */
@


1.9
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.8 1997/10/24 09:04:26 deraadt Exp $	*/
d127 1
a127 1
		if (fmode & (FWRITE | O_TRUNC)) {
@


1.8
log
@prevent open() with wrong flags
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.7 1997/10/06 20:20:15 deraadt Exp $	*/
d138 1
a138 1
		VOP_UNLOCK(vp);				/* XXX */
d140 1
a140 1
		VOP_LOCK(vp);				/* XXX */
d158 1
a158 2
 * The read-only status of the file system is checked.
 * Also, prototype text segments cannot be written.
d165 1
d180 1
d231 1
a231 1
		VOP_LOCK(vp);
d252 1
a252 1
		VOP_UNLOCK(vp);
d267 1
d270 1
a270 1
	VOP_LOCK(vp);
d277 1
a277 1
	VOP_UNLOCK(vp);
d291 1
d298 3
d302 1
a302 1
	VOP_LOCK(vp);
d310 1
a310 1
	VOP_UNLOCK(vp);
d435 30
@


1.7
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.5 1997/08/04 08:24:54 deraadt Exp $	*/
d77 2
@


1.6
log
@VFS Lite2 Changes
@
text
@d136 1
a136 1
		VOP_UNLOCK(vp, 0, p);				/* XXX */
d138 1
a138 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);				/* XXX */
d156 2
a157 1
 * Prototype text segments cannot be written.
a163 1
#if 0
a177 1
#endif
d228 1
a228 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d249 1
a249 1
		VOP_UNLOCK(vp, 0, p);
a263 1
	struct proc *p = uio->uio_procp;
d266 1
a266 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d273 1
a273 1
	VOP_UNLOCK(vp, 0, p);
a286 1
	struct proc *p = uio->uio_procp;
a292 3
	if ((fp->f_flag & O_FSYNC) ||
	    (vp->v_mount && (vp->v_mount->mnt_flag & MNT_SYNCHRONOUS)))
		ioflag |= IO_SYNC;
d294 1
a294 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d302 1
a302 1
	VOP_UNLOCK(vp, 0, p);
a426 30
}

/*
 * Check that the vnode is still valid, and if so
 * acquire requested lock.
 */
int
vn_lock(vp, flags, p)
	struct vnode *vp;
	int flags;
	struct proc *p;
{
	int error;
	
	do {
		if ((flags & LK_INTERLOCK) == 0)
			simple_lock(&vp->v_interlock);
		if (vp->v_flag & VXLOCK) {
			vp->v_flag |= VXWANT;
			simple_unlock(&vp->v_interlock);
			tsleep((caddr_t)vp, PINOD, "vn_lock", 0);
			error = ENOENT;
		} else {
			error = VOP_LOCK(vp, flags | LK_INTERLOCK, p);
			if (error == 0)
				return (error);
		}
		flags &= ~LK_INTERLOCK;
	} while (flags & LK_RETRY);
	return (error);
@


1.5
log
@let us all try this for a while, and argue amongst ourselves.
make a read(2) on an open'd directory return 0 bytes. always.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.4 1997/07/15 16:06:17 deraadt Exp $	*/
d136 1
a136 1
		VOP_UNLOCK(vp);				/* XXX */
d138 1
a138 1
		VOP_LOCK(vp);				/* XXX */
d156 1
a156 2
 * The read-only status of the file system is checked.
 * Also, prototype text segments cannot be written.
d163 1
d178 1
d229 1
a229 1
		VOP_LOCK(vp);
d250 1
a250 1
		VOP_UNLOCK(vp);
d265 1
d268 1
a268 1
	VOP_LOCK(vp);
d275 1
a275 1
	VOP_UNLOCK(vp);
d289 1
d296 3
d300 1
a300 1
	VOP_LOCK(vp);
d308 1
a308 1
	VOP_UNLOCK(vp);
d433 30
@


1.4
log
@cannot do this; flipk has found test cases where this fails
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_vnops.c,v 1.2 1996/03/03 17:20:28 niklas Exp $	*/
d263 1
a263 1
	int count, error;
d269 3
a271 2
	error = VOP_READ(vp, uio, (fp->f_flag & FNONBLOCK) ? IO_NDELAY : 0,
		cred);
@


1.3
log
@Do not force FOLLOW (to follow symbolic links) when creating new files
@
text
@a79 1
#if 0
a81 1
#endif
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
d83 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: vfs_vnops.c,v 1.19 1995/05/23 06:11:29 mycroft Exp $	*/
d66 1
d82 1
a82 1
		if (error = namei(ndp))
d89 3
a91 2
			if (error = VOP_CREATE(ndp->ni_dvp, &ndp->ni_vp,
			    &ndp->ni_cnd, &va))
d112 1
a112 1
		if (error = namei(ndp))
d122 1
a122 1
			if (error = VOP_ACCESS(vp, VREAD, cred, p))
d130 2
a131 2
			if ((error = vn_writechk(vp)) ||
			    (error = VOP_ACCESS(vp, VWRITE, cred, p)))
d141 1
a141 1
		if (error = VOP_SETATTR(vp, &va, cred, p))
d144 1
a144 1
	if (error = VOP_OPEN(vp, fmode, cred, p))
d159 1
d173 3
d191 1
d210 1
d256 1
d279 1
d308 1
d371 1
d387 2
a388 1
			if (error = VOP_GETATTR(vp, &vattr, p->p_ucred, p))
d417 1
d425 1
a425 1
		fp->f_cred, p));
d431 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
