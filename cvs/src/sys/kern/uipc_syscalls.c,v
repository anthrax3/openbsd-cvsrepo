head	1.156;
access;
symbols
	OPENBSD_6_1:1.151.0.4
	OPENBSD_6_1_BASE:1.151
	OPENBSD_6_0:1.132.0.2
	OPENBSD_6_0_BASE:1.132
	OPENBSD_5_9:1.131.0.2
	OPENBSD_5_9_BASE:1.131
	OPENBSD_5_8:1.106.0.4
	OPENBSD_5_8_BASE:1.106
	OPENBSD_5_7:1.99.0.2
	OPENBSD_5_7_BASE:1.99
	OPENBSD_5_6:1.91.0.4
	OPENBSD_5_6_BASE:1.91
	OPENBSD_5_5:1.89.0.4
	OPENBSD_5_5_BASE:1.89
	OPENBSD_5_4:1.88.0.2
	OPENBSD_5_4_BASE:1.88
	OPENBSD_5_3:1.87.0.2
	OPENBSD_5_3_BASE:1.87
	OPENBSD_5_2:1.86.0.2
	OPENBSD_5_2_BASE:1.86
	OPENBSD_5_1_BASE:1.84
	OPENBSD_5_1:1.84.0.2
	OPENBSD_5_0:1.82.0.2
	OPENBSD_5_0_BASE:1.82
	OPENBSD_4_9:1.78.0.2
	OPENBSD_4_9_BASE:1.78
	OPENBSD_4_8:1.76.0.2
	OPENBSD_4_8_BASE:1.76
	OPENBSD_4_7:1.74.0.2
	OPENBSD_4_7_BASE:1.74
	OPENBSD_4_6:1.70.0.6
	OPENBSD_4_6_BASE:1.70
	OPENBSD_4_5:1.70.0.2
	OPENBSD_4_5_BASE:1.70
	OPENBSD_4_4:1.68.0.2
	OPENBSD_4_4_BASE:1.68
	OPENBSD_4_3:1.66.0.6
	OPENBSD_4_3_BASE:1.66
	OPENBSD_4_2:1.66.0.4
	OPENBSD_4_2_BASE:1.66
	OPENBSD_4_1:1.66.0.2
	OPENBSD_4_1_BASE:1.66
	OPENBSD_4_0:1.63.0.2
	OPENBSD_4_0_BASE:1.63
	OPENBSD_3_9:1.62.0.2
	OPENBSD_3_9_BASE:1.62
	OPENBSD_3_8:1.61.0.2
	OPENBSD_3_8_BASE:1.61
	OPENBSD_3_7:1.60.0.4
	OPENBSD_3_7_BASE:1.60
	OPENBSD_3_6:1.60.0.2
	OPENBSD_3_6_BASE:1.60
	SMP_SYNC_A:1.59
	SMP_SYNC_B:1.59
	OPENBSD_3_5:1.57.0.2
	OPENBSD_3_5_BASE:1.57
	OPENBSD_3_4:1.56.0.2
	OPENBSD_3_4_BASE:1.56
	UBC_SYNC_A:1.53
	OPENBSD_3_3:1.53.0.4
	OPENBSD_3_3_BASE:1.53
	OPENBSD_3_2:1.53.0.2
	OPENBSD_3_2_BASE:1.53
	OPENBSD_3_1:1.51.0.2
	OPENBSD_3_1_BASE:1.51
	UBC_SYNC_B:1.53
	UBC:1.46.0.2
	UBC_BASE:1.46
	OPENBSD_3_0:1.42.0.2
	OPENBSD_3_0_BASE:1.42
	OPENBSD_2_9_BASE:1.36
	OPENBSD_2_9:1.36.0.2
	OPENBSD_2_8:1.32.0.2
	OPENBSD_2_8_BASE:1.32
	OPENBSD_2_7:1.30.0.4
	OPENBSD_2_7_BASE:1.30
	SMP:1.30.0.2
	SMP_BASE:1.30
	kame_19991208:1.29
	OPENBSD_2_6:1.28.0.2
	OPENBSD_2_6_BASE:1.28
	OPENBSD_2_5:1.19.0.2
	OPENBSD_2_5_BASE:1.19
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.156
date	2017.07.24.15.07.39;	author mpi;	state Exp;
branches;
next	1.155;
commitid	sWjyMVIO3fjuYxMz;

1.155
date	2017.07.20.18.40.16;	author bluhm;	state Exp;
branches;
next	1.154;
commitid	vHqRWS39NLwQlIma;

1.154
date	2017.07.19.06.52.41;	author claudio;	state Exp;
branches;
next	1.153;
commitid	8Q4y3QpgKRt3I9HF;

1.153
date	2017.07.12.09.25.47;	author mpi;	state Exp;
branches;
next	1.152;
commitid	foyQ3hCrSXR9x6rR;

1.152
date	2017.07.03.23.05.21;	author bluhm;	state Exp;
branches;
next	1.151;
commitid	0nas2PoPrSR7sJg2;

1.151
date	2017.03.27.11.45.49;	author bluhm;	state Exp;
branches
	1.151.4.1;
next	1.150;
commitid	P5fIAO7fo6lur3NB;

1.150
date	2017.02.14.09.46.21;	author mpi;	state Exp;
branches;
next	1.149;
commitid	4bln7omqWkS0RJo9;

1.149
date	2017.02.11.19.51.06;	author guenther;	state Exp;
branches;
next	1.148;
commitid	dp1qF9REvzwtzfTw;

1.148
date	2017.01.26.01.58.00;	author dhill;	state Exp;
branches;
next	1.147;
commitid	AIZiGinHdOVad0a1;

1.147
date	2017.01.25.07.35.31;	author deraadt;	state Exp;
branches;
next	1.146;
commitid	3whYYWTSXjbgegYK;

1.146
date	2017.01.25.06.15.50;	author mpi;	state Exp;
branches;
next	1.145;
commitid	X7Hk1efefaYrWlw3;

1.145
date	2017.01.24.05.44.09;	author mpi;	state Exp;
branches;
next	1.144;
commitid	c7K5PKDh48RAkh0y;

1.144
date	2016.12.29.12.12.43;	author mpi;	state Exp;
branches;
next	1.143;
commitid	RhxGXGNe4WuNtTZs;

1.143
date	2016.12.19.08.36.49;	author mpi;	state Exp;
branches;
next	1.142;
commitid	QqHqT2WhCBWqYgGJ;

1.142
date	2016.11.29.10.22.30;	author jsg;	state Exp;
branches;
next	1.141;
commitid	ZQetSMB5ilG2z10X;

1.141
date	2016.11.28.13.55.43;	author mpi;	state Exp;
branches;
next	1.140;
commitid	kNuYJ2U19s5SClMB;

1.140
date	2016.11.21.09.09.06;	author mpi;	state Exp;
branches;
next	1.139;
commitid	wuzpseLx3Ntn9R7b;

1.139
date	2016.11.09.09.39.43;	author mpi;	state Exp;
branches;
next	1.138;
commitid	FmtWU2fX12C6VzsR;

1.138
date	2016.10.23.17.06.40;	author naddy;	state Exp;
branches;
next	1.137;
commitid	XxepW1WJNjLrJfB1;

1.137
date	2016.10.23.03.22.37;	author deraadt;	state Exp;
branches;
next	1.136;
commitid	ZeFXuoTAiCvbncS4;

1.136
date	2016.10.23.00.42.49;	author tedu;	state Exp;
branches;
next	1.135;
commitid	kHLBBRdgl75UAZxt;

1.135
date	2016.10.08.02.16.43;	author guenther;	state Exp;
branches;
next	1.134;
commitid	MFxpqYD0syIKuFdZ;

1.134
date	2016.10.07.19.04.44;	author tedu;	state Exp;
branches;
next	1.133;
commitid	P3wH4sYsZgUq37HY;

1.133
date	2016.08.09.02.25.35;	author guenther;	state Exp;
branches;
next	1.132;
commitid	EtP812RgLMeBT5zT;

1.132
date	2016.05.18.01.13.13;	author millert;	state Exp;
branches;
next	1.131;
commitid	9XBfOUSLFa6tUPsR;

1.131
date	2016.01.08.05.50.08;	author guenther;	state Exp;
branches;
next	1.130;
commitid	FKvKJJpfDXTtCmCA;

1.130
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.129;
commitid	Cl55DD2g2xm69E6W;

1.129
date	2015.11.21.08.02.43;	author semarie;	state Exp;
branches;
next	1.128;
commitid	ZyyhpNZOIOSei0Bm;

1.128
date	2015.11.20.23.16.00;	author deraadt;	state Exp;
branches;
next	1.127;
commitid	e4AdCRh18nUxwCR6;

1.127
date	2015.11.20.07.15.30;	author deraadt;	state Exp;
branches;
next	1.126;
commitid	Ifznv9HMHMddHBOE;

1.126
date	2015.11.19.05.38.26;	author semarie;	state Exp;
branches;
next	1.125;
commitid	xx0Il1fW3JcUN9KA;

1.125
date	2015.11.18.08.24.22;	author semarie;	state Exp;
branches;
next	1.124;
commitid	UoU7wlG0nheL5cpK;

1.124
date	2015.11.08.23.23.12;	author tedu;	state Exp;
branches;
next	1.123;
commitid	XprwDUbRdIgbS3qy;

1.123
date	2015.11.01.19.03.33;	author semarie;	state Exp;
branches;
next	1.122;
commitid	VKRkUfXZQNJ8UQeY;

1.122
date	2015.10.28.16.03.08;	author semarie;	state Exp;
branches;
next	1.121;
commitid	rrwNdLSNQYYCQLMb;

1.121
date	2015.10.28.12.03.39;	author deraadt;	state Exp;
branches;
next	1.120;
commitid	mkxJ3rVL6ZrebUew;

1.120
date	2015.10.26.12.17.03;	author tedu;	state Exp;
branches;
next	1.119;
commitid	22Gl4tQHvRvwHXZw;

1.119
date	2015.10.25.20.39.54;	author deraadt;	state Exp;
branches;
next	1.118;
commitid	SIwCBDJKKae61tEi;

1.118
date	2015.10.25.17.45.29;	author deraadt;	state Exp;
branches;
next	1.117;
commitid	Yos3wgCrSjTdd7Hx;

1.117
date	2015.10.20.18.04.03;	author deraadt;	state Exp;
branches;
next	1.116;
commitid	cbpu7TMBEmsrNLlG;

1.116
date	2015.10.20.01.44.00;	author deraadt;	state Exp;
branches;
next	1.115;
commitid	GxCldWSIRJP5XzFU;

1.115
date	2015.10.18.20.15.10;	author deraadt;	state Exp;
branches;
next	1.114;
commitid	Nk95LvaVIfrgXtf6;

1.114
date	2015.10.18.00.04.43;	author deraadt;	state Exp;
branches;
next	1.113;
commitid	19QhHGSTTsDpRV7q;

1.113
date	2015.10.16.14.04.11;	author semarie;	state Exp;
branches;
next	1.112;
commitid	ENshdJQqoaKdbEvO;

1.112
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.111;
commitid	av6ZVErLSWkVP5Zz;

1.111
date	2015.10.06.14.55.41;	author claudio;	state Exp;
branches;
next	1.110;
commitid	aKDI9c1pZxa7lXR3;

1.110
date	2015.09.29.16.55.58;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	WGwGYDTbEj7sz1CB;

1.109
date	2015.09.11.15.29.47;	author deraadt;	state Exp;
branches;
next	1.108;
commitid	0NZe9BgjJety4Dtk;

1.108
date	2015.09.11.08.22.31;	author guenther;	state Exp;
branches;
next	1.107;
commitid	Lqreadw8v5IPAc0L;

1.107
date	2015.08.22.20.18.49;	author deraadt;	state Exp;
branches;
next	1.106;
commitid	6NDuzTPjBp2GqkfQ;

1.106
date	2015.07.28.05.50.41;	author guenther;	state Exp;
branches;
next	1.105;
commitid	6ofl1o2NCJLJenZf;

1.105
date	2015.07.27.04.01.51;	author guenther;	state Exp;
branches;
next	1.104;
commitid	vWLTdh3UGs8674HR;

1.104
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	1.103;
commitid	CJwjm9NDWu6nJ6ES;

1.103
date	2015.07.17.15.23.59;	author guenther;	state Exp;
branches;
next	1.102;
commitid	lV8YltGllqtUkaqL;

1.102
date	2015.05.21.13.35.15;	author nicm;	state Exp;
branches;
next	1.101;
commitid	7Rh2e5ry18vHQ4zq;

1.101
date	2015.05.06.08.52.17;	author mpi;	state Exp;
branches;
next	1.100;
commitid	8Nt1erARPXBfs0Oe;

1.100
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.99;
commitid	p4LJxGKbi0BU2cG6;

1.99
date	2015.01.19.19.57.59;	author guenther;	state Exp;
branches;
next	1.98;
commitid	5dezMzwaABWSQArv;

1.98
date	2015.01.19.19.47.29;	author guenther;	state Exp;
branches;
next	1.97;
commitid	U7w7DWvXJdCXa8Ao;

1.97
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.96;
commitid	20ZyHa9gTJxHxhwD;

1.96
date	2014.12.11.19.21.57;	author tedu;	state Exp;
branches;
next	1.95;
commitid	KtikWduHBwfG1emb;

1.95
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.94;
commitid	zM5ckwX4kwwmipG0;

1.94
date	2014.12.02.01.21.35;	author guenther;	state Exp;
branches;
next	1.93;
commitid	SqjPdGqLCH4ZqUJB;

1.93
date	2014.09.09.02.07.17;	author guenther;	state Exp;
branches;
next	1.92;
commitid	8mNtcvWyqXdDfneL;

1.92
date	2014.08.31.01.42.36;	author guenther;	state Exp;
branches;
next	1.91;
commitid	zF5A8BuuSSyqaDyM;

1.91
date	2014.07.13.15.00.40;	author tedu;	state Exp;
branches;
next	1.90;
commitid	7E1o7NIDvSyD48ls;

1.90
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.89;
commitid	QlVV51SZgNFxsXxC;

1.89
date	2013.09.14.02.28.02;	author guenther;	state Exp;
branches;
next	1.88;

1.88
date	2013.04.05.08.25.30;	author tedu;	state Exp;
branches;
next	1.87;

1.87
date	2012.10.17.05.07.55;	author guenther;	state Exp;
branches;
next	1.86;

1.86
date	2012.05.06.20.25.27;	author matthew;	state Exp;
branches;
next	1.85;

1.85
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.84;

1.84
date	2011.12.03.12.38.30;	author fgsch;	state Exp;
branches;
next	1.83;

1.83
date	2011.10.23.15.11.14;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2011.07.08.20.54.03;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2011.07.08.19.28.38;	author otto;	state Exp;
branches;
next	1.80;

1.80
date	2011.07.08.05.01.27;	author matthew;	state Exp;
branches;
next	1.79;

1.79
date	2011.04.04.12.44.10;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2010.09.22.04.57.55;	author matthew;	state Exp;
branches;
next	1.77;

1.77
date	2010.09.20.07.18.03;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.75;

1.75
date	2010.06.30.19.57.05;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2009.12.23.07.40.31;	author guenther;	state Exp;
branches;
next	1.73;

1.73
date	2009.11.27.20.05.50;	author guenther;	state Exp;
branches;
next	1.72;

1.72
date	2009.11.23.13.18.16;	author jacekm;	state Exp;
branches;
next	1.71;

1.71
date	2009.08.10.16.49.39;	author thib;	state Exp;
branches;
next	1.70;

1.70
date	2009.02.22.07.47.22;	author otto;	state Exp;
branches;
next	1.69;

1.69
date	2008.12.16.07.57.28;	author guenther;	state Exp;
branches;
next	1.68;

1.68
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.67;

1.67
date	2008.04.06.19.42.16;	author stefan;	state Exp;
branches;
next	1.66;

1.66
date	2006.10.23.07.13.56;	author henning;	state Exp;
branches;
next	1.65;

1.65
date	2006.10.21.02.18.00;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2006.10.18.14.43.45;	author kurt;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.26.17.47.10;	author mickey;	state Exp;
branches;
next	1.62;

1.62
date	2006.01.05.05.05.07;	author jsg;	state Exp;
branches;
next	1.61;

1.61
date	2005.07.06.20.41.44;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2004.07.22.06.13.08;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2004.04.12.23.58.10;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2004.04.01.23.56.05;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.06.04.18.18;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2003.09.01.18.06.03;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2003.06.02.23.28.07;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.23.22.21.44;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2002.05.23.14.59.24;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.12.16.38.39;	author art;	state Exp;
branches;
next	1.50;

1.50
date	2002.02.12.13.05.31;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.11.12.34.30;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.08.13.53.28;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.27.22.49.35;	author fgsch;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.02.18.07.32;	author provos;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2001.11.28.13.49.08;	author provos;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.27.15.51.36;	author provos;	state Exp;
branches;
next	1.43;

1.43
date	2001.10.26.12.03.27;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2001.09.17.19.37.59;	author jason;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.26.19.56.52;	author dugsong;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.22.14.14.10;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.16.12.52.58;	author ho;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.14.13.43.54;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2001.02.19.18.21.30;	author art;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2001.02.09.00.04.16;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.16.20.02.19;	author provos;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.10.18.15.48;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.12.09.58.05;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.27.16.13.46;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2000.01.17.18.16.48;	author deraadt;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	99.12.08.06.50.17;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	99.07.13.15.17.51;	author provos;	state Exp;
branches;
next	1.27;

1.27
date	99.06.15.17.46.32;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.06.11.18.10.24;	author provos;	state Exp;
branches;
next	1.25;

1.25
date	99.06.08.17.13.08;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	99.06.08.16.05.22;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.06.07.20.46.09;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	99.06.07.07.17.42;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	99.06.07.01.40.01;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.06.07.01.38.44;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	99.02.15.21.28.23;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	99.02.15.20.00.50;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	99.02.14.21.11.01;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	99.02.14.19.24.05;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.02.14.19.02.20;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	99.02.11.05.33.09;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.09.14.23.35.01;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	98.08.05.16.35.44;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	98.08.05.16.05.18;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.07.28.19.47.08;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.07.28.04.29.45;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.07.28.00.12.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	98.02.08.22.41.36;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	97.12.16.22.59.12;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.06.05.03.20.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.27.14.47.01;	author shawn;	state Exp;
branches;
next	1.3;

1.3
date	96.05.18.01.46.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.17.20.21;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.47;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.47;	author deraadt;	state Exp;
branches;
next	;

1.30.2.1
date	2001.05.14.22.32.45;	author niklas;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2001.07.04.10.48.46;	author niklas;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.30.2.4;

1.30.2.4
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.30.2.5;

1.30.2.5
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.30.2.6;

1.30.2.6
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.30.2.7;

1.30.2.7
date	2003.06.07.11.03.41;	author ho;	state Exp;
branches;
next	1.30.2.8;

1.30.2.8
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	1.30.2.9;

1.30.2.9
date	2004.06.05.23.13.02;	author niklas;	state Exp;
branches;
next	;

1.36.2.1
date	2001.12.02.18.25.32;	author miod;	state Exp;
branches;
next	;

1.42.2.1
date	2001.12.03.04.42.33;	author jason;	state Exp;
branches;
next	;

1.46.2.1
date	2002.01.31.22.55.41;	author niklas;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.46.2.3;

1.46.2.3
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	;

1.151.4.1
date	2017.08.01.22.10.56;	author bluhm;	state Exp;
branches;
next	1.151.4.2;
commitid	pp706vo87SsWWpGc;

1.151.4.2
date	2017.08.01.22.21.24;	author bluhm;	state Exp;
branches;
next	;
commitid	HcMcg3wyQj09bXAj;


desc
@@


1.156
log
@Extend the scope of the socket lock to protect `so_state' in connect(2).

As a side effect, soconnect() and soconnect2() now expect a locked socket,
so update all the callers.

ok bluhm@@
@
text
@/*	$OpenBSD: uipc_syscalls.c,v 1.155 2017/07/20 18:40:16 bluhm Exp $	*/
/*	$NetBSD: uipc_syscalls.c,v 1.19 1996/02/09 19:00:48 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)uipc_syscalls.c	8.4 (Berkeley) 2/21/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/filedesc.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/event.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/signalvar.h>
#include <sys/pledge.h>
#include <sys/unpcb.h>
#include <sys/un.h>
#ifdef KTRACE
#include <sys/ktrace.h>
#endif

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <sys/domain.h>
#include <netinet/in.h>
#include <net/route.h>

/*
 * System call interface to the socket abstraction.
 */
extern	struct fileops socketops;

int	copyaddrout(struct proc *, struct mbuf *, struct sockaddr *, socklen_t,
	    socklen_t *);

uint16_t dnsjackport;

int
sys_socket(struct proc *p, void *v, register_t *retval)
{
	struct sys_socket_args /* {
		syscallarg(int) domain;
		syscallarg(int) type;
		syscallarg(int) protocol;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct socket *so;
	struct file *fp;
	int type = SCARG(uap, type);
	int domain = SCARG(uap, domain);
	int fd, error, ss = 0;

	if ((type & SOCK_DNS) && !(domain == AF_INET || domain == AF_INET6))
		return (EINVAL);

	if (ISSET(type, SOCK_DNS))
		ss |= SS_DNS;
	error = pledge_socket(p, domain, ss);
	if (error)
		return (error);

	fdplock(fdp);
	error = falloc(p, (type & SOCK_CLOEXEC) ? UF_EXCLOSE : 0, &fp, &fd);
	fdpunlock(fdp);
	if (error != 0)
		goto out;

	fp->f_flag = FREAD | FWRITE | (type & SOCK_NONBLOCK ? FNONBLOCK : 0);
	fp->f_type = DTYPE_SOCKET;
	fp->f_ops = &socketops;
	error = socreate(SCARG(uap, domain), &so,
	    type & ~(SOCK_CLOEXEC | SOCK_NONBLOCK | SOCK_DNS), SCARG(uap, protocol));
	if (error) {
		fdplock(fdp);
		fdremove(fdp, fd);
		closef(fp, p);
		fdpunlock(fdp);
	} else {
		if (type & SOCK_NONBLOCK)
			so->so_state |= SS_NBIO;
		so->so_state |= ss;
		fp->f_data = so;
		FILE_SET_MATURE(fp, p);
		*retval = fd;
	}
out:
	return (error);
}

static inline int
isdnssocket(struct socket *so)
{
	return (so->so_state & SS_DNS);
}

/* For SS_DNS sockets, only allow port DNS (port 53) */ 
static int
dns_portcheck(struct proc *p, struct socket *so, void *nam, u_int *namelen)
{
	int error = EINVAL;

	switch (so->so_proto->pr_domain->dom_family) {
	case AF_INET:
		if (*namelen < sizeof(struct sockaddr_in))
			break;
		if (((struct sockaddr_in *)nam)->sin_port == htons(53))
			error = 0;
		if (dnsjackport) {
			struct sockaddr_in sin;
			memset(&sin, 0, sizeof(sin));
			sin.sin_len = sizeof(sin);
			sin.sin_family = AF_INET;
			sin.sin_port = htons(dnsjackport);
			sin.sin_addr.s_addr = INADDR_LOOPBACK;
			memcpy(nam, &sin, sizeof(sin));
			*namelen = sizeof(sin);
		}
		break;
#ifdef INET6
	case AF_INET6:
		if (*namelen < sizeof(struct sockaddr_in6))
			break;
		if (((struct sockaddr_in6 *)nam)->sin6_port == htons(53))
			error = 0;
		if (dnsjackport) {
			struct sockaddr_in6 sin6;
			memset(&sin6, 0, sizeof(sin6));
			sin6.sin6_len = sizeof(sin6);
			sin6.sin6_family = AF_INET6;
			sin6.sin6_port = htons(dnsjackport);
			sin6.sin6_addr = in6addr_loopback;
			memcpy(nam, &sin6, sizeof(sin6));
			*namelen = sizeof(sin6);
		}
#endif
	}
	if (error && p->p_p->ps_flags & PS_PLEDGE)
		return (pledge_fail(p, EPERM, PLEDGE_DNS));
	return error;
}

int
sys_bind(struct proc *p, void *v, register_t *retval)
{
	struct sys_bind_args /* {
		syscallarg(int) s;
		syscallarg(const struct sockaddr *) name;
		syscallarg(socklen_t) namelen;
	} */ *uap = v;
	struct file *fp;
	struct mbuf *nam;
	struct socket *so;
	int error;

	if ((error = getsock(p, SCARG(uap, s), &fp)) != 0)
		return (error);
	so = fp->f_data;
	error = pledge_socket(p, so->so_proto->pr_domain->dom_family,
	    so->so_state);
	if (error)
		goto out;
	error = sockargs(&nam, SCARG(uap, name), SCARG(uap, namelen),
	    MT_SONAME);
	if (error)
		goto out;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_STRUCT))
		ktrsockaddr(p, mtod(nam, caddr_t), SCARG(uap, namelen));
#endif
	error = sobind(so, nam, p);
	m_freem(nam);
out:
	FRELE(fp, p);
	return (error);
}

int
sys_listen(struct proc *p, void *v, register_t *retval)
{
	struct sys_listen_args /* {
		syscallarg(int) s;
		syscallarg(int) backlog;
	} */ *uap = v;
	struct file *fp;
	struct socket *so;
	int error;

	if ((error = getsock(p, SCARG(uap, s), &fp)) != 0)
		return (error);
	so = fp->f_data;
	error = solisten(so, SCARG(uap, backlog));
	FRELE(fp, p);
	return (error);
}

int
sys_accept(struct proc *p, void *v, register_t *retval)
{
	struct sys_accept_args /* {
		syscallarg(int) s;
		syscallarg(struct sockaddr *) name;
		syscallarg(socklen_t *) anamelen;
	} */ *uap = v;

	return (doaccept(p, SCARG(uap, s), SCARG(uap, name),
	    SCARG(uap, anamelen), SOCK_NONBLOCK_INHERIT, retval));
}

int
sys_accept4(struct proc *p, void *v, register_t *retval)
{
	struct sys_accept4_args /* {
		syscallarg(int) s;
		syscallarg(struct sockaddr *) name;
		syscallarg(socklen_t *) anamelen;
		syscallarg(socklen_t *) int flags;
	} */ *uap = v;

	if (SCARG(uap, flags) & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))
		return (EINVAL);

	return (doaccept(p, SCARG(uap, s), SCARG(uap, name),
	    SCARG(uap, anamelen), SCARG(uap, flags), retval));
}

int
doaccept(struct proc *p, int sock, struct sockaddr *name, socklen_t *anamelen,
    int flags, register_t *retval)
{
	struct filedesc *fdp = p->p_fd;
	struct file *fp, *headfp;
	struct mbuf *nam;
	socklen_t namelen;
	int error, s, tmpfd;
	struct socket *head, *so;
	int nflag;

	if (name && (error = copyin(anamelen, &namelen, sizeof (namelen))))
		return (error);
	if ((error = getsock(p, sock, &fp)) != 0)
		return (error);

	headfp = fp;

	fdplock(fdp);
	error = falloc(p, (flags & SOCK_CLOEXEC) ? UF_EXCLOSE : 0, &fp, &tmpfd);
	fdpunlock(fdp);
	if (error) {
		FRELE(headfp, p);
		return (error);
	}

	nam = m_get(M_WAIT, MT_SONAME);

	head = headfp->f_data;
	s = solock(head);
	if (isdnssocket(head) || (head->so_options & SO_ACCEPTCONN) == 0) {
		error = EINVAL;
		goto out;
	}
	if ((head->so_state & SS_NBIO) && head->so_qlen == 0) {
		if (head->so_state & SS_CANTRCVMORE)
			error = ECONNABORTED;
		else
			error = EWOULDBLOCK;
		goto out;
	}
	while (head->so_qlen == 0 && head->so_error == 0) {
		if (head->so_state & SS_CANTRCVMORE) {
			head->so_error = ECONNABORTED;
			break;
		}
		error = sosleep(head, &head->so_timeo, PSOCK | PCATCH, "netcon",
		    0);
		if (error)
			goto out;
	}
	if (head->so_error) {
		error = head->so_error;
		head->so_error = 0;
		goto out;
	}

	/*
	 * Do not sleep after we have taken the socket out of the queue.
	 */
	so = TAILQ_FIRST(&head->so_q);
	if (soqremque(so, 1) == 0)
		panic("accept");

	/* Figure out whether the new socket should be non-blocking. */
	nflag = flags & SOCK_NONBLOCK_INHERIT ? (headfp->f_flag & FNONBLOCK)
	    : (flags & SOCK_NONBLOCK ? FNONBLOCK : 0);

	/* connection has been removed from the listen queue */
	KNOTE(&head->so_rcv.sb_sel.si_note, NOTE_SUBMIT);

	fp->f_type = DTYPE_SOCKET;
	fp->f_flag = FREAD | FWRITE | nflag;
	fp->f_ops = &socketops;
	error = soaccept(so, nam);
	if (!error && name != NULL)
		error = copyaddrout(p, nam, name, namelen, anamelen);
	if (!error) {
		if (nflag & FNONBLOCK)
			so->so_state |= SS_NBIO;
		else
			so->so_state &= ~SS_NBIO;
		fp->f_data = so;
		FILE_SET_MATURE(fp, p);
		*retval = tmpfd;
	}
out:
	sounlock(s);
	m_freem(nam);
	if (error) {
		fdplock(fdp);
		fdremove(fdp, tmpfd);
		closef(fp, p);
		fdpunlock(fdp);
	}
	FRELE(headfp, p);
	return (error);
}

int
sys_connect(struct proc *p, void *v, register_t *retval)
{
	struct sys_connect_args /* {
		syscallarg(int) s;
		syscallarg(const struct sockaddr *) name;
		syscallarg(socklen_t) namelen;
	} */ *uap = v;
	struct file *fp;
	struct socket *so;
	struct mbuf *nam = NULL;
	int error, s, interrupted = 0;

	if ((error = getsock(p, SCARG(uap, s), &fp)) != 0)
		return (error);
	so = fp->f_data;
	s = solock(so);
	if (so->so_state & SS_ISCONNECTING) {
		error = EALREADY;
		goto out;
	}
	error = sockargs(&nam, SCARG(uap, name), SCARG(uap, namelen),
	    MT_SONAME);
	if (error)
		goto out;
	error = pledge_socket(p, so->so_proto->pr_domain->dom_family,
	    so->so_state);
	if (error)
		goto out;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_STRUCT))
		ktrsockaddr(p, mtod(nam, caddr_t), SCARG(uap, namelen));
#endif

	if (isdnssocket(so)) {
		u_int namelen = nam->m_len;
		error = dns_portcheck(p, so, mtod(nam, void *), &namelen);
		if (error)
			goto out;
		nam->m_len = namelen;
	}

	error = soconnect(so, nam);
	if (error)
		goto bad;
	if ((so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING)) {
		error = EINPROGRESS;
		goto out;
	}
	while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) {
		error = sosleep(so, &so->so_timeo, PSOCK | PCATCH,
		    "netcon2", 0);
		if (error) {
			if (error == EINTR || error == ERESTART)
				interrupted = 1;
			break;
		}
	}
	if (error == 0) {
		error = so->so_error;
		so->so_error = 0;
	}
bad:
	if (!interrupted)
		so->so_state &= ~SS_ISCONNECTING;
out:
	sounlock(s);
	FRELE(fp, p);
	m_freem(nam);
	if (error == ERESTART)
		error = EINTR;
	return (error);
}

int
sys_socketpair(struct proc *p, void *v, register_t *retval)
{
	struct sys_socketpair_args /* {
		syscallarg(int) domain;
		syscallarg(int) type;
		syscallarg(int) protocol;
		syscallarg(int *) rsv;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp1, *fp2;
	struct socket *so1, *so2;
	int s, type, cloexec, nonblock, fflag, error, sv[2];

	type  = SCARG(uap, type) & ~(SOCK_CLOEXEC | SOCK_NONBLOCK);
	cloexec = (SCARG(uap, type) & SOCK_CLOEXEC) ? UF_EXCLOSE : 0;
	nonblock = SCARG(uap, type) &  SOCK_NONBLOCK;
	fflag = FREAD | FWRITE | (nonblock ? FNONBLOCK : 0);

	error = socreate(SCARG(uap, domain), &so1, type, SCARG(uap, protocol));
	if (error)
		return (error);
	error = socreate(SCARG(uap, domain), &so2, type, SCARG(uap, protocol));
	if (error)
		goto free1;

	s = solock(so1);
	error = soconnect2(so1, so2);
	sounlock(s);
	if (error != 0)
		goto free2;

	if ((SCARG(uap, type) & SOCK_TYPE_MASK) == SOCK_DGRAM) {
		/*
		 * Datagram socket connection is asymmetric.
		 */
		s = solock(so2);
		error = soconnect2(so2, so1);
		sounlock(s);
		if (error != 0)
			goto free2;
	}
	fdplock(fdp);
	if ((error = falloc(p, cloexec, &fp1, &sv[0])) != 0)
		goto free3;
	fp1->f_flag = fflag;
	fp1->f_type = DTYPE_SOCKET;
	fp1->f_ops = &socketops;
	fp1->f_data = so1;
	if ((error = falloc(p, cloexec, &fp2, &sv[1])) != 0)
		goto free4;
	fp2->f_flag = fflag;
	fp2->f_type = DTYPE_SOCKET;
	fp2->f_ops = &socketops;
	fp2->f_data = so2;
	error = copyout(sv, SCARG(uap, rsv), 2 * sizeof (int));
	if (error == 0) {
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrfds(p, sv, 2);
#endif
		if (nonblock) {
			(*fp1->f_ops->fo_ioctl)(fp1, FIONBIO, (caddr_t)&type,
			    p);
			(*fp2->f_ops->fo_ioctl)(fp2, FIONBIO, (caddr_t)&type,
			    p);
		}
		FILE_SET_MATURE(fp1, p);
		FILE_SET_MATURE(fp2, p);
		fdpunlock(fdp);
		return (0);
	}
	fdremove(fdp, sv[1]);
	closef(fp2, p);
	so2 = NULL;
free4:
	fdremove(fdp, sv[0]);
	closef(fp1, p);
	so1 = NULL;
free3:
	fdpunlock(fdp);
free2:
	if (so2 != NULL)
		(void)soclose(so2);
free1:
	if (so1 != NULL)
		(void)soclose(so1);
	return (error);
}

int
sys_sendto(struct proc *p, void *v, register_t *retval)
{
	struct sys_sendto_args /* {
		syscallarg(int) s;
		syscallarg(const void *) buf;
		syscallarg(size_t) len;
		syscallarg(int) flags;
		syscallarg(const struct sockaddr *) to;
		syscallarg(socklen_t) tolen;
	} */ *uap = v;
	struct msghdr msg;
	struct iovec aiov;

	msg.msg_name = (caddr_t)SCARG(uap, to);
	msg.msg_namelen = SCARG(uap, tolen);
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	msg.msg_control = 0;
	msg.msg_flags = 0;
	aiov.iov_base = (char *)SCARG(uap, buf);
	aiov.iov_len = SCARG(uap, len);
	return (sendit(p, SCARG(uap, s), &msg, SCARG(uap, flags), retval));
}

int
sys_sendmsg(struct proc *p, void *v, register_t *retval)
{
	struct sys_sendmsg_args /* {
		syscallarg(int) s;
		syscallarg(const struct msghdr *) msg;
		syscallarg(int) flags;
	} */ *uap = v;
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *iov;
	int error;

	error = copyin(SCARG(uap, msg), &msg, sizeof (msg));
	if (error)
		return (error);
#ifdef KTRACE
	if (KTRPOINT(p, KTR_STRUCT))
		ktrmsghdr(p, &msg);
#endif

	if (msg.msg_iovlen > IOV_MAX)
		return (EMSGSIZE);
	if (msg.msg_iovlen > UIO_SMALLIOV)
		iov = mallocarray(msg.msg_iovlen, sizeof(struct iovec),
		    M_IOV, M_WAITOK);
	else
		iov = aiov;
	if (msg.msg_iovlen &&
	    (error = copyin(msg.msg_iov, iov,
		    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)))))
		goto done;
#ifdef KTRACE
	if (msg.msg_iovlen && KTRPOINT(p, KTR_STRUCT))
		ktriovec(p, iov, msg.msg_iovlen);
#endif
	msg.msg_iov = iov;
	msg.msg_flags = 0;
	error = sendit(p, SCARG(uap, s), &msg, SCARG(uap, flags), retval);
done:
	if (iov != aiov)
		free(iov, M_IOV, sizeof(struct iovec) * msg.msg_iovlen);
	return (error);
}

int
sendit(struct proc *p, int s, struct msghdr *mp, int flags, register_t *retsize)
{
	struct file *fp;
	struct uio auio;
	struct iovec *iov;
	int i;
	struct mbuf *to, *control;
	struct socket *so;
	size_t len;
	int error;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
	int iovlen = 0;
#endif

	to = NULL;

	if ((error = getsock(p, s, &fp)) != 0)
		return (error);
	so = fp->f_data;

	error = pledge_sendit(p, mp->msg_name);
	if (error)
		goto bad;

	auio.uio_iov = mp->msg_iov;
	auio.uio_iovcnt = mp->msg_iovlen;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_rw = UIO_WRITE;
	auio.uio_procp = p;
	auio.uio_offset = 0;			/* XXX */
	auio.uio_resid = 0;
	iov = mp->msg_iov;
	for (i = 0; i < mp->msg_iovlen; i++, iov++) {
		/* Don't allow sum > SSIZE_MAX */
		if (iov->iov_len > SSIZE_MAX ||
		    (auio.uio_resid += iov->iov_len) > SSIZE_MAX) {
			error = EINVAL;
			goto bad;
		}
	}
	if (mp->msg_name) {
		error = sockargs(&to, mp->msg_name, mp->msg_namelen,
		    MT_SONAME);
		if (error)
			goto bad;
		if (isdnssocket(so)) {
			u_int namelen = mp->msg_namelen;
			error = dns_portcheck(p, so, mtod(to, caddr_t),
			    &namelen);
			if (error)
				goto bad;
			mp->msg_namelen = namelen;
		}
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
		 	ktrsockaddr(p, mtod(to, caddr_t), mp->msg_namelen);
#endif
	}
	if (mp->msg_control) {
		if (mp->msg_controllen < CMSG_ALIGN(sizeof(struct cmsghdr))) {
			error = EINVAL;
			goto bad;
		}
		error = sockargs(&control, mp->msg_control,
		    mp->msg_controllen, MT_CONTROL);
		if (error)
			goto bad;
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT) && mp->msg_controllen)
			ktrcmsghdr(p, mtod(control, char *),
			    mp->msg_controllen);
#endif
	} else
		control = 0;
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO)) {
		ktriov = mallocarray(auio.uio_iovcnt, sizeof(struct iovec),
		    M_TEMP, M_WAITOK);
		iovlen = auio.uio_iovcnt * sizeof (struct iovec);

		memcpy(ktriov, auio.uio_iov, iovlen);
	}
#endif
	len = auio.uio_resid;
	error = sosend(fp->f_data, to, &auio, NULL, control, flags);
	if (error) {
		if (auio.uio_resid != len && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
		if (error == EPIPE && (flags & MSG_NOSIGNAL) == 0)
			ptsignal(p, SIGPIPE, STHREAD);
	}
	if (error == 0) {
		*retsize = len - auio.uio_resid;
		fp->f_wxfer++;
		fp->f_wbytes += *retsize;
	}
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p, s, UIO_WRITE, ktriov, *retsize);
		free(ktriov, M_TEMP, iovlen);
	}
#endif
bad:
	FRELE(fp, p);
	m_freem(to);
	return (error);
}

int
sys_recvfrom(struct proc *p, void *v, register_t *retval)
{
	struct sys_recvfrom_args /* {
		syscallarg(int) s;
		syscallarg(void *) buf;
		syscallarg(size_t) len;
		syscallarg(int) flags;
		syscallarg(struct sockaddr *) from;
		syscallarg(socklen_t *) fromlenaddr;
	} */ *uap = v;
	struct msghdr msg;
	struct iovec aiov;
	int error;

	if (SCARG(uap, fromlenaddr)) {
		error = copyin(SCARG(uap, fromlenaddr),
		    &msg.msg_namelen, sizeof (msg.msg_namelen));
		if (error)
			return (error);
	} else
		msg.msg_namelen = 0;
	msg.msg_name = (caddr_t)SCARG(uap, from);
	msg.msg_iov = &aiov;
	msg.msg_iovlen = 1;
	aiov.iov_base = SCARG(uap, buf);
	aiov.iov_len = SCARG(uap, len);
	msg.msg_control = 0;
	msg.msg_flags = SCARG(uap, flags);
	return (recvit(p, SCARG(uap, s), &msg,
	    (caddr_t)SCARG(uap, fromlenaddr), retval));
}

int
sys_recvmsg(struct proc *p, void *v, register_t *retval)
{
	struct sys_recvmsg_args /* {
		syscallarg(int) s;
		syscallarg(struct msghdr *) msg;
		syscallarg(int) flags;
	} */ *uap = v;
	struct msghdr msg;
	struct iovec aiov[UIO_SMALLIOV], *uiov, *iov;
	int error;

	error = copyin(SCARG(uap, msg), &msg, sizeof (msg));
	if (error)
		return (error);

	if (msg.msg_iovlen > IOV_MAX)
		return (EMSGSIZE);
	if (msg.msg_iovlen > UIO_SMALLIOV)
		iov = mallocarray(msg.msg_iovlen, sizeof(struct iovec),
		    M_IOV, M_WAITOK);
	else
		iov = aiov;
	msg.msg_flags = SCARG(uap, flags);
	if (msg.msg_iovlen > 0) {
		error = copyin(msg.msg_iov, iov,
		    msg.msg_iovlen * sizeof(struct iovec));
		if (error)
			goto done;
	}
	uiov = msg.msg_iov;
	msg.msg_iov = iov;
	if ((error = recvit(p, SCARG(uap, s), &msg, NULL, retval)) == 0) {
		msg.msg_iov = uiov;
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT)) {
			ktrmsghdr(p, &msg);
			if (msg.msg_iovlen)
				ktriovec(p, iov, msg.msg_iovlen);
		}
#endif
		error = copyout(&msg, SCARG(uap, msg), sizeof(msg));
	}
done:
	if (iov != aiov)
		free(iov, M_IOV, sizeof(struct iovec) * msg.msg_iovlen);
	return (error);
}

int
recvit(struct proc *p, int s, struct msghdr *mp, caddr_t namelenp,
    register_t *retsize)
{
	struct file *fp;
	struct uio auio;
	struct iovec *iov;
	int i;
	size_t len;
	int error;
	struct mbuf *from = NULL, *control = NULL;
#ifdef KTRACE
	struct iovec *ktriov = NULL;
	int iovlen = 0;
#endif

	if ((error = getsock(p, s, &fp)) != 0)
		return (error);

	auio.uio_iov = mp->msg_iov;
	auio.uio_iovcnt = mp->msg_iovlen;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_rw = UIO_READ;
	auio.uio_procp = p;
	auio.uio_offset = 0;			/* XXX */
	auio.uio_resid = 0;
	iov = mp->msg_iov;
	for (i = 0; i < mp->msg_iovlen; i++, iov++) {
		/* Don't allow sum > SSIZE_MAX */
		if (iov->iov_len > SSIZE_MAX ||
		    (auio.uio_resid += iov->iov_len) > SSIZE_MAX) {
			error = EINVAL;
			goto out;
		}
	}
#ifdef KTRACE
	if (KTRPOINT(p, KTR_GENIO)) {
		ktriov = mallocarray(auio.uio_iovcnt, sizeof(struct iovec),
		    M_TEMP, M_WAITOK);
		iovlen = auio.uio_iovcnt * sizeof (struct iovec);

		memcpy(ktriov, auio.uio_iov, iovlen);
	}
#endif
	len = auio.uio_resid;
	error = soreceive(fp->f_data, &from, &auio, NULL,
			  mp->msg_control ? &control : NULL,
			  &mp->msg_flags,
			  mp->msg_control ? mp->msg_controllen : 0);
	if (error) {
		if (auio.uio_resid != len && (error == ERESTART ||
		    error == EINTR || error == EWOULDBLOCK))
			error = 0;
	}
#ifdef KTRACE
	if (ktriov != NULL) {
		if (error == 0)
			ktrgenio(p, s, UIO_READ, ktriov, len - auio.uio_resid);
		free(ktriov, M_TEMP, iovlen);
	}
#endif
	if (error)
		goto out;
	*retsize = len - auio.uio_resid;
	if (mp->msg_name) {
		socklen_t alen;

		if (from == NULL)
			alen = 0;
		else {
			alen = from->m_len;
			error = copyout(mtod(from, caddr_t), mp->msg_name,
			    MIN(alen, mp->msg_namelen));
			if (error)
				goto out;
#ifdef KTRACE
			if (KTRPOINT(p, KTR_STRUCT))
				ktrsockaddr(p, mtod(from, caddr_t), alen);
#endif
		}
		mp->msg_namelen = alen;
		if (namelenp &&
		    (error = copyout(&alen, namelenp, sizeof(alen)))) {
			goto out;
		}
	}
	if (mp->msg_control) {
		len = mp->msg_controllen;
		if (len <= 0 || control == NULL)
			len = 0;
		else {
			struct mbuf *m = control;
			caddr_t cp = mp->msg_control;

			do {
				i = m->m_len;
				if (len < i) {
					mp->msg_flags |= MSG_CTRUNC;
					i = len;
				}
				error = copyout(mtod(m, caddr_t), cp, i);
#ifdef KTRACE
				if (KTRPOINT(p, KTR_STRUCT) && error == 0 && i)
					ktrcmsghdr(p, mtod(m, char *), i);
#endif
				if (m->m_next)
					i = ALIGN(i);
				cp += i;
				len -= i;
				if (error != 0 || len <= 0)
					break;
			} while ((m = m->m_next) != NULL);
			len = cp - (caddr_t)mp->msg_control;
		}
		mp->msg_controllen = len;
	}
	if (!error) {
		fp->f_rxfer++;
		fp->f_rbytes += *retsize;
	}
out:
	FRELE(fp, p);
	m_freem(from);
	m_freem(control);
	return (error);
}

int
sys_shutdown(struct proc *p, void *v, register_t *retval)
{
	struct sys_shutdown_args /* {
		syscallarg(int) s;
		syscallarg(int) how;
	} */ *uap = v;
	struct file *fp;
	int error;

	if ((error = getsock(p, SCARG(uap, s), &fp)) != 0)
		return (error);
	error = soshutdown(fp->f_data, SCARG(uap, how));
	FRELE(fp, p);
	return (error);
}

int
sys_setsockopt(struct proc *p, void *v, register_t *retval)
{
	struct sys_setsockopt_args /* {
		syscallarg(int) s;
		syscallarg(int) level;
		syscallarg(int) name;
		syscallarg(const void *) val;
		syscallarg(socklen_t) valsize;
	} */ *uap = v;
	struct file *fp;
	struct mbuf *m = NULL;
	int error;


	if ((error = getsock(p, SCARG(uap, s), &fp)) != 0)
		return (error);
	error = pledge_sockopt(p, 1, SCARG(uap, level), SCARG(uap, name));
	if (error)
		goto bad;
	if (SCARG(uap, valsize) > MCLBYTES) {
		error = EINVAL;
		goto bad;
	}
	if (SCARG(uap, val)) {
		m = m_get(M_WAIT, MT_SOOPTS);
		if (SCARG(uap, valsize) > MLEN) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				error = ENOBUFS;
				goto bad;
			}
		}
		if (m == NULL) {
			error = ENOBUFS;
			goto bad;
		}
		error = copyin(SCARG(uap, val), mtod(m, caddr_t),
		    SCARG(uap, valsize));
		if (error) {
			goto bad;
		}
		m->m_len = SCARG(uap, valsize);
	}
	error = sosetopt(fp->f_data, SCARG(uap, level), SCARG(uap, name), m);
	m = NULL;
bad:
	m_freem(m);
	FRELE(fp, p);
	return (error);
}

int
sys_getsockopt(struct proc *p, void *v, register_t *retval)
{
	struct sys_getsockopt_args /* {
		syscallarg(int) s;
		syscallarg(int) level;
		syscallarg(int) name;
		syscallarg(void *) val;
		syscallarg(socklen_t *) avalsize;
	} */ *uap = v;
	struct file *fp;
	struct mbuf *m = NULL;
	socklen_t valsize;
	int error;

	if ((error = getsock(p, SCARG(uap, s), &fp)) != 0)
		return (error);
	error = pledge_sockopt(p, 0, SCARG(uap, level), SCARG(uap, name));
	if (error)
		goto out;
	if (SCARG(uap, val)) {
		error = copyin(SCARG(uap, avalsize),
		    &valsize, sizeof (valsize));
		if (error)
			goto out;
	} else
		valsize = 0;
	if ((error = sogetopt(fp->f_data, SCARG(uap, level),
	    SCARG(uap, name), &m)) == 0 && SCARG(uap, val) && valsize &&
	    m != NULL) {
		if (valsize > m->m_len)
			valsize = m->m_len;
		error = copyout(mtod(m, caddr_t), SCARG(uap, val), valsize);
		if (error == 0)
			error = copyout(&valsize,
			    SCARG(uap, avalsize), sizeof (valsize));
	}
out:
	FRELE(fp, p);
	m_free(m);
	return (error);
}

/*
 * Get socket name.
 */
int
sys_getsockname(struct proc *p, void *v, register_t *retval)
{
	struct sys_getsockname_args /* {
		syscallarg(int) fdes;
		syscallarg(struct sockaddr *) asa;
		syscallarg(socklen_t *) alen;
	} */ *uap = v;
	struct file *fp;
	struct socket *so;
	struct mbuf *m = NULL;
	socklen_t len;
	int error, s;

	if ((error = getsock(p, SCARG(uap, fdes), &fp)) != 0)
		return (error);
	error = copyin(SCARG(uap, alen), &len, sizeof (len));
	if (error)
		goto bad;
	so = fp->f_data;
	error = pledge_socket(p, -1, so->so_state);
	if (error)
		goto bad;
	m = m_getclr(M_WAIT, MT_SONAME);
	s = solock(so);
	error = (*so->so_proto->pr_usrreq)(so, PRU_SOCKADDR, 0, m, 0, p);
	sounlock(s);
	if (error)
		goto bad;
	error = copyaddrout(p, m, SCARG(uap, asa), len, SCARG(uap, alen));
bad:
	FRELE(fp, p);
	m_freem(m);
	return (error);
}

/*
 * Get name of peer for connected socket.
 */
int
sys_getpeername(struct proc *p, void *v, register_t *retval)
{
	struct sys_getpeername_args /* {
		syscallarg(int) fdes;
		syscallarg(struct sockaddr *) asa;
		syscallarg(socklen_t *) alen;
	} */ *uap = v;
	struct file *fp;
	struct socket *so;
	struct mbuf *m = NULL;
	socklen_t len;
	int error, s;

	if ((error = getsock(p, SCARG(uap, fdes), &fp)) != 0)
		return (error);
	so = fp->f_data;
	error = pledge_socket(p, -1, so->so_state);
	if (error)
		goto bad;
	if ((so->so_state & SS_ISCONNECTED) == 0) {
		error = ENOTCONN;
		goto bad;
	}
	error = copyin(SCARG(uap, alen), &len, sizeof (len));
	if (error)
		goto bad;
	m = m_getclr(M_WAIT, MT_SONAME);
	s = solock(so);
	error = (*so->so_proto->pr_usrreq)(so, PRU_PEERADDR, 0, m, 0, p);
	sounlock(s);
	if (error)
		goto bad;
	error = copyaddrout(p, m, SCARG(uap, asa), len, SCARG(uap, alen));
bad:
	FRELE(fp, p);
	m_freem(m);
	return (error);
}

int
sockargs(struct mbuf **mp, const void *buf, size_t buflen, int type)
{
	struct sockaddr *sa;
	struct mbuf *m;
	int error;

	/*
	 * We can't allow socket names > UCHAR_MAX in length, since that
	 * will overflow sa_len. Also, control data more than MCLBYTES in
	 * length is just too much.
	 * Memory for sa_len and sa_family must exist.
	 */
	if ((buflen > (type == MT_SONAME ? UCHAR_MAX : MCLBYTES)) ||
	    (type == MT_SONAME && buflen < offsetof(struct sockaddr, sa_data)))
		return (EINVAL);

	/* Allocate an mbuf to hold the arguments. */
	m = m_get(M_WAIT, type);
	if (buflen > MLEN) {
		MCLGET(m, M_WAITOK);
		if ((m->m_flags & M_EXT) == 0) {
			m_free(m);
			return ENOBUFS;
		}
	}
	m->m_len = buflen;
	error = copyin(buf, mtod(m, caddr_t), buflen);
	if (error) {
		(void) m_free(m);
		return (error);
	}
	*mp = m;
	if (type == MT_SONAME) {
		sa = mtod(m, struct sockaddr *);
		sa->sa_len = buflen;
	}
	return (0);
}

int
getsock(struct proc *p, int fdes, struct file **fpp)
{
	struct file *fp;

	if ((fp = fd_getfile(p->p_fd, fdes)) == NULL)
		return (EBADF);
	if (fp->f_type != DTYPE_SOCKET)
		return (ENOTSOCK);
	FREF(fp);
	*fpp = fp;

	return (0);
}

int
sys_setrtable(struct proc *p, void *v, register_t *retval)
{
	struct sys_setrtable_args /* {
		syscallarg(int) rtableid;
	} */ *uap = v;
	int rtableid, error;

	rtableid = SCARG(uap, rtableid);

	if (p->p_p->ps_rtableid == (u_int)rtableid)
		return (0);
	if (p->p_p->ps_rtableid != 0 && (error = suser(p, 0)) != 0)
		return (error);
	if (rtableid < 0 || !rtable_exists((u_int)rtableid))
		return (EINVAL);

	p->p_p->ps_rtableid = (u_int)rtableid;
	return (0);
}

int
sys_getrtable(struct proc *p, void *v, register_t *retval)
{
	*retval = (int)p->p_p->ps_rtableid;
	return (0);
}

int
copyaddrout(struct proc *p, struct mbuf *name, struct sockaddr *sa,
    socklen_t buflen, socklen_t *outlen)
{
	int error;
	socklen_t namelen = name->m_len;

	/* SHOULD COPY OUT A CHAIN HERE */
	error = copyout(mtod(name, caddr_t), sa, MIN(buflen, namelen));
	if (error == 0) {
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrsockaddr(p, mtod(name, caddr_t), namelen);
#endif
		error = copyout(&namelen, outlen, sizeof(*outlen));
	}

	return (error);
}
@


1.155
log
@When receiving a struct sockaddr from userland, enforce that memory
for sa_len and sa_family is provided.  This will make handling of
socket name mbufs within the kernel safer.
issue reported by Ilja Van Sprundel; OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.154 2017/07/19 06:52:41 claudio Exp $	*/
d376 1
d378 2
a379 2
		FRELE(fp, p);
		return (EALREADY);
d384 1
a384 1
		goto bad;
d388 1
a388 1
		goto bad;
d397 2
a398 5
		if (error) {
			FRELE(fp, p);
			m_freem(nam);
			return (error);
		}
d406 2
a407 3
		FRELE(fp, p);
		m_freem(nam);
		return (EINPROGRESS);
a408 1
	s = solock(so);
a421 1
	sounlock(s);
d425 2
d446 1
a446 1
	int type, cloexec, nonblock, fflag, error, sv[2];
d460 4
a463 1
	if ((error = soconnect2(so1, so2)) != 0)
d470 4
a473 1
		 if ((error = soconnect2(so2, so1)) != 0)
@


1.154
log
@Move KTRPOINT call up. The lenght variable i is getting aligned and so
uninitialised data can be dumped into the ktrace message.
Found by Ilja Van Sprundel
OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.153 2017/07/12 09:25:47 mpi Exp $	*/
d1116 1
d1118 2
a1119 1
	if (buflen > (type == MT_SONAME ? UCHAR_MAX : MCLBYTES))
@


1.153
log
@Do not call fo_ioctl() in syscall that do, or will, take the socket
lock.

Prevents a future lock recursion since soo_ioctl() will need to grab
the lock.

ok bluhm@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.152 2017/07/03 23:05:21 bluhm Exp $	*/
d885 4
a894 4
#ifdef KTRACE
				if (KTRPOINT(p, KTR_STRUCT) && i)
					ktrcmsghdr(p, mtod(m, char *), i);
#endif
@


1.152
log
@Do not grab the socket lock in doaccept() twice.  Pass NOTE_SUBMIT
to KNOTE() as we are already holding the lock.  Fixes "panic:
rw_enter: netlock locking against myself" reported by Gregor Best
and reproduced with src/regress/lib/libtls/gotls.
OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.151 2017/03/27 11:45:49 bluhm Exp $	*/
a112 1
		fp->f_data = so;
d114 1
a114 1
			(*fp->f_ops->fo_ioctl)(fp, FIONBIO, (caddr_t)&type, p);
d116 1
a334 1
	fp->f_data = so;
d339 5
a343 1
		(*fp->f_ops->fo_ioctl)(fp, FIONBIO, (caddr_t)&nflag, p);
@


1.151
log
@Reorder FREF() and FRELE() in a way that the the global variable
syslogf always points to a file object with increased reference
count.  This makes the implementation independent from the fact
whether changing the reference counter may sleep.
pointed out by Mateusz Guzik; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.150 2017/02/14 09:46:21 mpi Exp $	*/
d330 1
a330 1
	KNOTE(&head->so_rcv.sb_sel.si_note, 0);
@


1.151.4.1
log
@Move KTRPOINT call up. The lenght variable i is getting aligned and so
uninitialised data can be dumped into the ktrace message.
Found by Ilja Van Sprundel
errata 018
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.151 2017/03/27 11:45:49 bluhm Exp $	*/
a881 4
#ifdef KTRACE
				if (KTRPOINT(p, KTR_STRUCT) && error == 0 && i)
					ktrcmsghdr(p, mtod(m, char *), i);
#endif
d888 4
@


1.151.4.2
log
@When receiving a struct sockaddr from userland, enforce that memory
for sa_len and sa_family is provided.  This will make handling of
socket name mbufs within the kernel safer.
issue reported by Ilja Van Sprundel
errata 020
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.151.4.1 2017/08/01 22:10:56 bluhm Exp $	*/
a1112 1
	 * Memory for sa_len and sa_family must exist.
d1114 1
a1114 2
	if ((buflen > (type == MT_SONAME ? UCHAR_MAX : MCLBYTES)) ||
	    (type == MT_SONAME && buflen < offsetof(struct sockaddr, sa_data)))
@


1.150
log
@Wrap the NET_LOCK() into a per-socket solock() that does nothing for
unix domain sockets.

This should prevent the multiple deadlock related to unix domain sockets.

Inputs from millert@@ and bluhm@@, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.149 2017/02/11 19:51:06 guenther Exp $	*/
d1149 1
a1150 1
	FREF(fp);
@


1.149
log
@Add a flags argument to falloc() that lets it optionally set the
close-on-exec flag on the newly allocated fd.  Make falloc()'s
return arguments non-optional: assert that they're not NULL.

ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.148 2017/01/26 01:58:00 dhill Exp $	*/
d288 1
a288 2
	
	NET_LOCK(s);
d290 1
d307 2
a308 2
		error = rwsleep(&head->so_timeo, &netlock, PSOCK | PCATCH,
		    "netcon", 0);
d345 1
a345 1
	NET_UNLOCK(s);
d409 1
a409 1
	NET_LOCK(s);
d411 1
a411 1
		error = rwsleep(&so->so_timeo, &netlock, PSOCK | PCATCH,
d423 1
a423 1
	NET_UNLOCK(s);
d1047 1
a1047 1
	NET_LOCK(s);
d1049 1
a1049 1
	NET_UNLOCK(s);
d1090 1
a1090 1
	NET_LOCK(s);
d1092 1
a1092 1
	NET_UNLOCK(s);
@


1.148
log
@Allocate the mbuf before the netlock.  While here, move the setting of
nflag closer to where its value is used.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.147 2017/01/25 07:35:31 deraadt Exp $	*/
d97 1
a97 3
	error = falloc(p, &fp, &fd);
	if (error == 0 && (type & SOCK_CLOEXEC))
		fdp->fd_ofileflags[fd] |= UF_EXCLOSE;
d280 1
a280 3
	error = falloc(p, &fp, &tmpfd);
	if (!error && (flags & SOCK_CLOEXEC))
		fdp->fd_ofileflags[tmpfd] |= UF_EXCLOSE;
d446 1
a446 1
	int type, flags, fflag, error, sv[2];
d449 3
a451 2
	flags = SCARG(uap, type) &  (SOCK_CLOEXEC | SOCK_NONBLOCK);
	fflag = FREAD | FWRITE | (flags & SOCK_NONBLOCK ? FNONBLOCK : 0);
d471 1
a471 1
	if ((error = falloc(p, &fp1, &sv[0])) != 0)
d477 1
a477 1
	if ((error = falloc(p, &fp2, &sv[1])) != 0)
a482 4
	if (flags & SOCK_CLOEXEC) {
		fdp->fd_ofileflags[sv[0]] |= UF_EXCLOSE;
		fdp->fd_ofileflags[sv[1]] |= UF_EXCLOSE;
	}
d489 2
a490 2
		if (flags & SOCK_NONBLOCK) {
			(*fp1->f_ops->fo_ioctl)(fp1, FIONBIO, (caddr_t)&flags,
d492 1
a492 1
			(*fp2->f_ops->fo_ioctl)(fp2, FIONBIO, (caddr_t)&flags,
@


1.147
log
@Allocate and connect sockets first, then upon success create file
descriptors so that the NET_LOCK is satisfied.
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.146 2017/01/25 06:15:50 mpi Exp $	*/
d268 1
a268 1
	struct mbuf *nam = NULL;
d291 2
a292 1
redo:
a321 18
	/* Figure out whether the new socket should be non-blocking. */
	nflag = flags & SOCK_NONBLOCK_INHERIT ? (headfp->f_flag & FNONBLOCK)
	    : (flags & SOCK_NONBLOCK ? FNONBLOCK : 0);

	nam = m_get(M_WAIT, MT_SONAME);

	/*
	 * Check whether the queue emptied while we slept: m_get() may have
	 * blocked, allowing the connection to be reset or another thread or
	 * process to accept it.  If so, start over.
	 */
	if (head->so_qlen == 0) {
		NET_UNLOCK(s);
		m_freem(nam);
		nam = NULL;
		goto redo;
	}

d328 4
@


1.146
log
@Enable the NET_LOCK(), take 2.

Recursions are currently known and marked a XXXSMP.

Please report any assert to bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.145 2017/01/24 05:44:09 mpi Exp $	*/
d476 10
d488 1
a488 1
		goto free2;
d494 1
a494 1
		goto free3;
a502 9
	if ((error = soconnect2(so1, so2)) != 0)
		goto free4;
	if ((SCARG(uap, type) & SOCK_TYPE_MASK) == SOCK_DGRAM) {
		/*
		 * Datagram socket connection is asymmetric.
		 */
		 if ((error = soconnect2(so2, so1)) != 0)
			goto free4;
	}
a519 1
free4:
d523 1
a523 1
free3:
d527 2
a531 1
	fdpunlock(fdp);
@


1.145
log
@In accept(2) and accept4(2) allocate a new file descriptor before
checking if the socket head's queue is empty and possibly sleeping.

This way we avoid lock ordering problems as the NET_LOCK() and
fdplock() won't be held at the same time.

Note that socketpair(2) and close(2) are the two remaining syscalls
holding these locks at the same time.  They both respect the same
order: fdplock() then NET_LOCK().

Initial deadlock reported by kettenis@@ and ajacoutot@@.

ok bluhm@@, guenther@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.144 2016/12/29 12:12:43 mpi Exp $	*/
d310 1
a310 1
		error = tsleep(&head->so_timeo, PSOCK | PCATCH,
d428 1
a428 1
		error = tsleep(&so->so_timeo, PSOCK | PCATCH,
@


1.144
log
@Change NET_LOCK()/NET_UNLOCK() to be simple wrappers around
splsoftnet()/splx() until the known issues are fixed.

In other words, stop using a rwlock since it creates a deadlock when
chrome is used.

Issue reported by Dimitris Papastamos and kettenis@@

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.143 2016/12/19 08:36:49 mpi Exp $	*/
d268 1
a268 1
	struct mbuf *nam;
d280 11
d296 1
a296 1
		goto bad;
d303 1
a303 1
		goto bad;
d312 2
a313 3
		if (error) {
			goto bad;
		}
d318 1
a318 1
		goto bad;
a324 14
	fdplock(fdp);
	error = falloc(p, &fp, &tmpfd);
	if (error == 0 && (flags & SOCK_CLOEXEC))
		fdp->fd_ofileflags[tmpfd] |= UF_EXCLOSE;
	fdpunlock(fdp);
	if (error != 0) {
		/*
		 * Probably ran out of file descriptors.  Wakeup
		 * so some other process might have a chance at it.
		 */
		wakeup_one(&head->so_timeo);
		goto bad;
	}

d328 3
a330 3
	 * Check whether the queue emptied while we slept: falloc() or
	 * m_get() may have blocked, allowing the connection to be reset
	 * or another thread or process to accept it.  If so, start over.
d335 1
a335 4
		fdplock(fdp);
		fdremove(fdp, tmpfd);
		closef(fp, p);
		fdpunlock(fdp);
d356 8
a363 1

a364 3
		/* if an error occurred, free the file descriptor */
		NET_UNLOCK(s);
		m_freem(nam);
a368 1
		goto out;
a369 7
	(*fp->f_ops->fo_ioctl)(fp, FIONBIO, (caddr_t)&nflag, p);
	FILE_SET_MATURE(fp, p);
	*retval = tmpfd;
	m_freem(nam);
bad:
	NET_UNLOCK(s);
out:
@


1.143
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.142 2016/11/29 10:22:30 jsg Exp $	*/
d299 1
a299 1
		error = rwsleep(&head->so_timeo, &netlock, PSOCK | PCATCH,
d439 1
a439 1
		error = rwsleep(&so->so_timeo, &netlock, PSOCK | PCATCH,
@


1.142
log
@m_free() and m_freem() test for NULL.  Simplify callers which had their own
NULL tests.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.141 2016/11/28 13:55:43 mpi Exp $	*/
d281 1
a281 1
	s = splsoftnet();
d299 2
a300 1
		error = tsleep(&head->so_timeo, PSOCK | PCATCH, "netcon", 0);
d337 1
a337 1
		splx(s);
d366 1
a366 1
		splx(s);
d379 1
a379 1
	splx(s);
d437 1
a437 1
	s = splsoftnet();
d439 2
a440 1
		error = tsleep(&so->so_timeo, PSOCK | PCATCH, "netcon2", 0);
d451 1
a451 1
	splx(s);
d1077 1
a1077 1
	s = splsoftnet();
d1079 1
a1079 1
	splx(s);
d1120 1
a1120 1
	s = splsoftnet();
d1122 1
a1122 1
	splx(s);
@


1.141
log
@Remove NULL checks before m_free{m,}().

ok reyk@@, rzalamena@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.140 2016/11/21 09:09:06 mpi Exp $	*/
d454 1
a454 2
	if (nam)
		m_freem(nam);
@


1.140
log
@Enforce that pr_usrreq functions are called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.139 2016/11/09 09:39:43 mpi Exp $	*/
d724 1
a724 2
	if (to)
		m_freem(to);
d932 2
a933 4
	if (from)
		m_freem(from);
	if (control)
		m_freem(control);
d1001 1
a1001 2
	if (m)
		m_freem(m);
d1045 1
a1045 2
	if (m != NULL)
		(void)m_free(m);
@


1.139
log
@Do not call splsoftnet() recursively, this won't work with a lock.

closef() on a socket will call soclose() which call splsoftnet().  So
make sure we release the IPL level first in error paths.

Found by Nils Frohberg while testing another diff.

ok mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.138 2016/10/23 17:06:40 naddy Exp $	*/
d1069 1
a1069 1
	int error;
d1081 1
d1083 1
d1089 1
a1089 2
	if (m)
		m_freem(m);
d1108 1
a1108 1
	int error;
d1124 1
d1126 1
@


1.138
log
@unbreak by fixing obvious pastos
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.137 2016/10/23 03:22:37 deraadt Exp $	*/
a278 1
	s = splsoftnet();
a279 6
	head = fp->f_data;

	if (isdnssocket((struct socket *)fp->f_data)) {
		error = EINVAL;
		goto bad;
	}
d281 3
a283 1
	if ((head->so_options & SO_ACCEPTCONN) == 0) {
d309 1
a309 1
	
d336 1
d365 2
d371 1
a371 4
	} else {
		(*fp->f_ops->fo_ioctl)(fp, FIONBIO, (caddr_t)&nflag, p);
		FILE_SET_MATURE(fp, p);
		*retval = tmpfd;
d373 3
d379 1
@


1.137
log
@handle non-INET6 kernels in some way
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.136 2016/10/23 00:42:49 tedu Exp $	*/
d165 1
a165 1
			sin6.sin6_family = AF_INET;
@


1.136
log
@dns hijacking must be af specific. move it into the port check function,
and redirect inet6 sockets to the ::1 flavor of localhost.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.135 2016/10/08 02:16:43 guenther Exp $	*/
d155 1
d171 1
@


1.135
log
@Add ktracing of the fds returned by pipe() and socketpair()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.134 2016/10/07 19:04:44 tedu Exp $	*/
d134 1
a134 1
dns_portcheck(struct proc *p, struct socket *so, void *nam, size_t namelen)
d136 2
d140 1
a140 1
		if (namelen < sizeof(struct sockaddr_in))
d143 11
a153 1
			return (0);
d156 1
a156 1
		if (namelen < sizeof(struct sockaddr_in6))
d159 11
a169 1
			return (0);
d171 1
a171 1
	if (p->p_p->ps_flags & PS_PLEDGE)
d173 1
a173 1
	return (EINVAL);	
d417 2
a418 1
		error = dns_portcheck(p, so, mtod(nam, void *), nam->m_len);
d424 1
a424 10
		if (dnsjackport) {
			struct sockaddr_in sin;
			memset(&sin, 0, sizeof(sin));
			sin.sin_len = sizeof(sin);
			sin.sin_family = AF_INET;
			sin.sin_port = htons(dnsjackport);
			sin.sin_addr.s_addr = INADDR_LOOPBACK;
			memcpy(mtod(nam, void *), &sin, sizeof(sin));
			nam->m_len = sizeof(sin);
		}
d663 1
d665 1
a665 1
			    mp->msg_namelen);
d668 1
@


1.134
log
@introduce a sysctl to hijack dns sockets. when set to a port number,
all dns socket connections will be redirected to localhost:port.
this could be a sockopt on the listening socket, but sysctl is
an easier interface to work with right now.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.133 2016/08/09 02:25:35 guenther Exp $	*/
d499 4
@


1.133
log
@When interrupted, connect() should leave the socket connecting in the
background, similar to a non-blocking socket.  Return EALREADY whenever
already connecting, not just for non-blocking sockets.  Fix from {Free,Net}BSD

Prompted by a report from Michael Reed (m.reed (at) mykolab.com)
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.132 2016/05/18 01:13:13 millert Exp $	*/
d70 2
d400 10
@


1.132
log
@Remove unnecessary cast of buflen to u_int in sockargs().  This was
missed when buflen was promoted to size_t.  OK tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.131 2016/01/08 05:50:08 guenther Exp $	*/
d370 1
a370 1
	int error, s;
d375 1
a375 1
	if ((so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING)) {
d412 3
a414 1
		if (error)
d416 1
d424 2
a425 1
	so->so_state &= ~SS_ISCONNECTING;
@


1.131
log
@On the recvmsg() side, cmsgs are in mbuf chains, not a contiguous buffer.
ktrace each cmsg instead of reading beyond the end of the first cmsg.

problem report and testing by abieber@@
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.130 2015/12/05 10:11:53 tedu Exp $	*/
d1113 1
a1113 1
	if ((u_int)buflen > MLEN) {
@


1.130
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.129 2015/11/21 08:02:43 semarie Exp $	*/
a867 4
#ifdef KTRACE
			if (KTRPOINT(p, KTR_STRUCT) && len)
				ktrcmsghdr(p, mtod(control, char *), len);
#endif
d881 4
@


1.129
log
@remove completely pledge_socket() from listen(2) and accept(2).

with pledge_socket(p, -1, state) we only check for "dns" promise against SS_DNS
socket. But it isn't possible to pass a SS_DNS socket to listen(2) or accept(2)
(EINVAL). So this deeper check is a bit useless...

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.128 2015/11/20 23:16:00 deraadt Exp $	*/
a151 1
/* ARGSUSED */
a186 1
/* ARGSUSED */
a358 1
/* ARGSUSED */
a902 1
/* ARGSUSED */
a919 1
/* ARGSUSED */
a972 1
/* ARGSUSED */
a1019 1
/* ARGSUSED */
a1057 1
/* ARGSUSED */
a1148 1
/* ARGSUSED */
a1169 1
/* ARGSUSED */
@


1.128
log
@Neuter the pledge domain checking for listen, getpeername, and getsockname
also.  The idea is much like rpath is with files, you get an fd and then
you can play with it somewhat.  In the socket space once you have a fd, you
can play with it somewhat.  So you cannot bind, but you can accept.  You
can listen, getpeername, getsockname, and of course set/getsockopt is
somewhat available..  yes, this makes pledge the anti-capsicum, kind of
like salt from Secovlje.. reasoning due to a conversation with tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.127 2015/11/20 07:15:30 deraadt Exp $	*/
a202 3
	error = pledge_socket(p, -1, so->so_state);
	if (error)
		goto out;
a203 1
out:
a258 3
	error = pledge_socket(p, -1, head->so_state);
	if (error)
		goto bad;
@


1.127
log
@Exempt accept(2) from the pledge_socket() check part of the "domain"
check.  You cannot open a socket in a domain unless permitted -- but
you need to be able to accept one if the code flow asks for that to
happen.  The most recent check is too tight. We may need to iterate the
policy here until we hit the right vibe...
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.126 2015/11/19 05:38:26 semarie Exp $	*/
d203 1
a203 2
	error = pledge_socket(p, so->so_proto->pr_domain->dom_family,
	    so->so_state);
d1054 1
a1054 2
	error = pledge_socket(p, so->so_proto->pr_domain->dom_family,
	    so->so_state);
d1090 1
a1090 2
	error = pledge_socket(p, so->so_proto->pr_domain->dom_family,
	    so->so_state);
@


1.126
log
@corrects leaks refs to files introduced by my previous commit for pledge_socket.

reported by Mateusz Guzik with a diff.
this one is a slightly modified version.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.125 2015/11/18 08:24:22 semarie Exp $	*/
d264 1
a264 2
	error = pledge_socket(p, head->so_proto->pr_domain->dom_family,
	    head->so_state);
@


1.125
log
@check domain and state of socket against pledge promise.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.124 2015/11/08 23:23:12 tedu Exp $	*/
d172 1
a172 1
		return (error);
d175 2
a176 1
	if (error == 0) {
d178 2
a179 2
		if (KTRPOINT(p, KTR_STRUCT))
			ktrsockaddr(p, mtod(nam, caddr_t), SCARG(uap, namelen));
d181 3
a183 3
		error = sobind(so, nam, p);
		m_freem(nam);
	}
d206 1
a206 1
		return (error);
d208 1
d1096 1
a1096 1
		return (error);
d1098 2
a1099 2
		FRELE(fp, p);
		return (ENOTCONN);
@


1.124
log
@pull initialization up before poosible goto bad, from Mark Latimer
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.123 2015/11/01 19:03:33 semarie Exp $	*/
d83 1
a83 1
	int fd, error;
d87 4
a90 1
	error = pledge_socket(p, type & SOCK_DNS);
d116 1
a116 2
		if (type & SOCK_DNS)
			so->so_state |= SS_DNS;
d163 1
d168 5
d180 1
a180 1
		error = sobind(fp->f_data, nam, p);
d196 1
d201 6
a206 1
	error = solisten(fp->f_data, SCARG(uap, backlog));
d262 4
d393 4
d1054 4
d1091 4
@


1.123
log
@refactor pledge_*_check and pledge_fail functions

- rename _check function without suffix: a "pledge" function called from
  anywhere is a "check" function.

- makes pledge_fail call the responsability to the _check function. remove it
  from caller.

- make proper use of (potential) returned error of _check() functions.

- adds pledge_kill() and pledge_protexec()

with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.122 2015/10/28 16:03:08 semarie Exp $	*/
d243 5
a251 3
	headfp = fp;
	s = splsoftnet();
	head = fp->f_data;
@


1.122
log
@more accurate pledge_fail() error and code for sys_socket

- use the error returned by pledge_socket_check()
- make the code to reflect the socket request (set code to PLEDGE_DNS for
  dns-scoket, and to PLEDGE_INET else)
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.121 2015/10/28 12:03:39 deraadt Exp $	*/
d87 1
a87 1
	error = pledge_socket_check(p, type & SOCK_DNS);
d89 1
a89 2
		return (pledge_fail(p, error,
		    (type & SOCK_DNS) ? PLEDGE_DNS : PLEDGE_INET));
d589 2
a590 3
	error = pledge_sendit_check(p, mp->msg_name);
	if (error) {
		error = pledge_fail(p, error, PLEDGE_STDIO);
a591 1
	}
d925 2
a926 3
	error = pledge_sockopt_check(p, 1, SCARG(uap, level), SCARG(uap, name));
	if (error) {
		error = pledge_fail(p, error, PLEDGE_INET);
a927 1
	}
d979 2
a980 3
	error = pledge_sockopt_check(p, 0, SCARG(uap, level), SCARG(uap, name));
	if (error) {
		error = pledge_fail(p, error, PLEDGE_INET);
a981 1
	}
@


1.121
log
@The short-lived dnssocket/dnsconnect calls are being required because we
suspect everyone has upgraded through the approx week-long window since
SOCK_DNS became available and the libc resolver started using them.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.120 2015/10/26 12:17:03 tedu Exp $	*/
d89 2
a90 1
		return (pledge_fail(p, EPERM, PLEDGE_DNS));
@


1.120
log
@dns check needs to be done on the kernel address after copyin
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.119 2015/10/25 20:39:54 deraadt Exp $	*/
a69 14
/* XXX dnssocket() - temporary backwards compat */
int
sys_dnssocket(struct proc *p, void *v, register_t *retval)
{
	struct sys_socket_args /* {
		syscallarg(int) domain;
		syscallarg(int) type;
		syscallarg(int) protocol;
	} */ *uap = v;

	SCARG(uap, type) |= SOCK_DNS;
	return sys_socket(p, v, retval);
}

a345 7
}

/* XXX dnsconnect() - temporary backwards compat */
int
sys_dnsconnect(struct proc *p, void *v, register_t *retval)
{
	return sys_connect(p, v, retval);
@


1.119
log
@Fold "malloc" into "stdio" and -- recognizing that no program so far has
used less than "stdio" -- include all the "self" operations.  Instead of
different defines, use regular PLEDGE_* in the "p_pledgenote" variable
(which indicates the operation subtype a system call is performing).  Many
checks before easier to understand.  p_pledgenote can often be passed
directly to ktrace, so that kdump says:
 15565 test     CALL  pledge(0xa9a3f804c51,0)
 15565 test     STRU  pledge request="stdio"
 15565 test     RET   pledge 0
 15565 test     CALL  open(0xa9a3f804c57,0x2<O_RDWR>)
 15565 test     NAMI  "/tmp/testfile"
 15565 test     PLDG  open, "wpath", errno 1 Operation not permitted
with help from semarie, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.118 2015/10/25 17:45:29 deraadt Exp $	*/
a609 5
	if (mp->msg_name && mp->msg_namelen && isdnssocket(so)) {
		error = dns_portcheck(p, so, mp->msg_name, mp->msg_namelen);
		if (error)
			return (error);
	}
d637 6
@


1.118
log
@pledge_sockopt_check is shared between setsockopt/getsockopt.  nicm
found the first case of "get allowed, set not allowed".  Tiny
refactoring of that.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.117 2015/10/20 18:04:03 deraadt Exp $	*/
d615 3
a617 2
	if (pledge_sendit_check(p, mp->msg_name)) {
		error = pledge_fail(p, EPERM, PLEDGE_RW);
@


1.117
log
@At guenther's suggestion replace dnssocket() with a SOCK_DNS flag on
socket().  Without pledge, all other socket behaviours become permitted,
except this one case: connect/send* only works to *:53.  In pledge mode,
a very few are further restricted.  Some backwards compatibility for
the dnssocket/dnsconnect calls will remain in the tree temporarily so
that people can build through the transition.
ok tedu guenther semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.116 2015/10/20 01:44:00 deraadt Exp $	*/
d946 1
a946 1
	error = pledge_sockopt_check(p, SCARG(uap, level), SCARG(uap, name));
d1002 1
a1002 1
	error = pledge_sockopt_check(p, SCARG(uap, level), SCARG(uap, name));
@


1.116
log
@Always allow the setsockopt & getsockopt system calls... however, in the
default case only allows SOL_SOCKET SO_RCVBUF which is very common in
network-facing daemons.  Many of them manage this on a socket after
dropping abilities which can get them _new_ sockets.. syslogd, bgpd,
relayd, etc etc.  Other sockopts still require specific pledges.
Tested by bluhm.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.115 2015/10/18 20:15:10 deraadt Exp $	*/
d58 2
a68 2
int	socketit(struct proc *p, void *v, register_t *retval, int);
int	connectit(struct proc *p, void *v, register_t *retval, int);
d70 1
d74 8
a81 1
	return socketit(p, v, retval, 1);
a86 6
	return socketit(p, v, retval, 0);
}

int
socketit(struct proc *p, void *v, register_t *retval, int dns)
{
d99 1
a99 1
	if (dns && !(domain == AF_INET || domain == AF_INET6))
d101 3
d117 1
a117 1
	    type & ~(SOCK_CLOEXEC | SOCK_NONBLOCK), SCARG(uap, protocol));
d127 1
a127 1
		if (dns)
d142 21
a178 4
	if (isdnssocket((struct socket *)fp->f_data)) {
		FRELE(fp, p);
		return (EINVAL);
	}
d362 1
a362 1
/* ARGSUSED */
d366 1
a366 1
	return connectit(p, v, retval, 1);
a372 6
	return connectit(p, v, retval, 0);
}

int
connectit(struct proc *p, void *v, register_t *retval, int dns)
{
a385 5
	if ((dns && !isdnssocket(so)) || (!dns && isdnssocket(so))) {
		FRELE(fp, p);
		return EINVAL;
	}

d398 10
d596 1
d608 6
a613 3
	if (mp->msg_name && isdnssocket((struct socket *)fp->f_data)) {
		error = EINVAL;
		goto bad;
a798 8
	if (mp->msg_name && isdnssocket((struct socket *)fp->f_data)) {
		FRELE(fp, p);
		return (EINVAL);
	}
	if (pledge_recvit_check(p, mp->msg_name)) {
		FRELE(fp, p);
		return (pledge_fail(p, EPERM, PLEDGE_RW));
	}
d946 3
a948 6
	if (isdnssocket((struct socket *)fp->f_data)) {
		error = EINVAL;
		goto bad;
	}
	if (pledge_sockopt_check(p, SCARG(uap, level), SCARG(uap, name))) {
		error = pledge_fail(p, EPERM, PLEDGE_INET);
d1002 3
a1004 6
	if (pledge_sockopt_check(p, SCARG(uap, level), SCARG(uap, name))) {
		error = pledge_fail(p, EPERM, PLEDGE_INET);
		goto out;
	}
	if (isdnssocket((struct socket *)fp->f_data)) {
		error = EINVAL;
@


1.115
log
@Instead of fragile CMSG parsing, control pledge "sendfd" and "recvfd"
in unp_internalize and unp_externalize.
ok kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.114 2015/10/18 00:04:43 deraadt Exp $	*/
d933 1
a933 1
	if (pledge_setsockopt_check(p, SCARG(uap, level), SCARG(uap, name))) {
d988 4
@


1.114
log
@Add two new system calls: dnssocket() and dnsconnect().  This creates a
SS_DNS tagged socket which has limited functionality (for example, you
cannot accept on them...)  The libc resolver will switch to using these,
therefore pledge can identify a DNS transaction better.
ok tedu guenther kettenis beck and others
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.113 2015/10/16 14:04:11 semarie Exp $	*/
a634 6

		if (pledge_cmsg_send(p, control)) {
			m_free(control);
			error = EPERM;
			goto bad;
		}
a866 4
				}
				if (pledge_cmsg_recv(p, m)) {
					error = EPERM;
					goto out;
@


1.113
log
@delete pledge_bind_check() function and remove pledge_bind_check() call from sys_bind().

bind(2) still require PLEDGE_INET or PLEDGE_UNIX in order to be called, due to
SYS_bind entry in pledge_syscalls array. The diff restores also the ability for
PLEDGE_UNIX to call bind(2) (pledge_bind_check function missed that).

problem spotted by doug@@
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.112 2015/10/09 01:10:27 deraadt Exp $	*/
d67 8
d79 6
d94 1
d97 2
a98 2
	if (pledge_socket_check(p, SCARG(uap, domain)))
		return (pledge_fail(p, EPERM, PLEDGE_UNIX));
d122 2
d131 7
d153 4
d235 4
d342 7
d351 6
a366 3
	if (pledge_connect_check(p))
		return (pledge_fail(p, EPERM, PLEDGE_UNIX));

d370 5
a511 3
	if (pledge_sendto_check(p, SCARG(uap, to)))
		return (pledge_fail(p, EPERM, PLEDGE_UNIX));

a542 3
	if (pledge_sendto_check(p, msg.msg_name))
		return (pledge_fail(p, EPERM, PLEDGE_UNIX));

d586 9
a694 3
	if (pledge_recvfrom_check(p, SCARG(uap, from)))
		return (pledge_fail(p, EPERM, PLEDGE_UNIX));

a728 3
	if (pledge_recvfrom_check(p, msg.msg_name))
		return (pledge_fail(p, EPERM, PLEDGE_UNIX));

d780 9
a935 2
	if (pledge_setsockopt_check(p, SCARG(uap, level), SCARG(uap, name)))
		return (pledge_fail(p, EPERM, PLEDGE_INET));
d939 8
d998 4
@


1.112
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.111 2015/10/06 14:55:41 claudio Exp $	*/
a125 3

	if (pledge_bind_check(p, SCARG(uap, name)))
		return (pledge_fail(p, EPERM, PLEDGE_UNIX));
@


1.111
log
@Rework the tame cmsg handler to make it work both ways. While on recv one
mbuf blob with all the cmsgs inside while on send cmsgs in an mbuf chain,
one mbuf per message. Adjust the calls accordingly.
Putting it in so deraadt@@ can move forward.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.110 2015/09/29 16:55:58 deraadt Exp $	*/
d48 1
a48 1
#include <sys/tame.h>
d82 2
a83 2
	if (tame_socket_check(p, SCARG(uap, domain)))
		return (tame_fail(p, EPERM, TAME_UNIX));
d127 2
a128 2
	if (tame_bind_check(p, SCARG(uap, name)))
		return (tame_fail(p, EPERM, TAME_UNIX));
d325 2
a326 2
	if (tame_connect_check(p))
		return (tame_fail(p, EPERM, TAME_UNIX));
d468 2
a469 2
	if (tame_sendto_check(p, SCARG(uap, to)))
		return (tame_fail(p, EPERM, TAME_UNIX));
d502 2
a503 2
	if (tame_sendto_check(p, msg.msg_name))
		return (tame_fail(p, EPERM, TAME_UNIX));
d589 1
a589 1
		if (tame_cmsg_send(p, control)) {
d648 2
a649 2
	if (tame_recvfrom_check(p, SCARG(uap, from)))
		return (tame_fail(p, EPERM, TAME_UNIX));
d685 2
a686 2
	if (tame_recvfrom_check(p, msg.msg_name))
		return (tame_fail(p, EPERM, TAME_UNIX));
d824 1
a824 1
				if (tame_cmsg_recv(p, m)) {
d886 2
a887 2
	if (tame_setsockopt_check(p, SCARG(uap, level), SCARG(uap, name)))
		return (tame_fail(p, EPERM, TAME_INET));
@


1.110
log
@Save a lot of people grief.  tame()'d CMSG reception is busted and it
will take some time to fix it.  Problem appears to be that the control mbuf
is not normalized into flat memory.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.109 2015/09/11 15:29:47 deraadt Exp $	*/
d589 1
a589 1
		if (tame_cmsg_send(p, control, mp->msg_controllen)) {
d591 1
d824 4
a827 2
//				if (tame_cmsg_recv(p, control, mp->msg_controllen))
//					goto out;
@


1.109
log
@Convert _TM_ flags to TAME_ flags, collapsing the entire mapping
layer because the strings select the right options.  Mechanical
conversion.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.108 2015/09/11 08:22:31 guenther Exp $	*/
d823 2
a824 2
				if (tame_cmsg_recv(p, control, mp->msg_controllen))
					goto out;
@


1.108
log
@Only include <sys/tame.h> in the .c files that need it

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.107 2015/08/22 20:18:49 deraadt Exp $	*/
d83 1
a83 1
		return (tame_fail(p, EPERM, _TM_UNIX));
d128 1
a128 1
		return (tame_fail(p, EPERM, _TM_UNIX));
d326 1
a326 1
		return (tame_fail(p, EPERM, _TM_UNIX));
d469 1
a469 1
		return (tame_fail(p, EPERM, _TM_UNIX));
d503 1
a503 1
		return (tame_fail(p, EPERM, _TM_UNIX));
d648 1
a648 1
		return (tame_fail(p, EPERM, _TM_UNIX));
d685 1
a685 1
		return (tame_fail(p, EPERM, _TM_UNIX));
d884 1
a884 1
		return (tame_fail(p, EPERM, _TM_INET));
@


1.107
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.106 2015/07/28 05:50:41 guenther Exp $	*/
d48 1
@


1.106
log
@Add ktracing of structs iovec, msghdr, and cmsghdr for {,p}{read,write}v(),
sendmsg(), and recvmsg().  For cmsghdr, the len, level, and type are always
shown, and for SOL_SOCKET,SCM_RIGHTS the fd numbers being passed are shown.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.105 2015/07/27 04:01:51 guenther Exp $	*/
a47 1
#include <sys/tame.h>
@


1.105
log
@tame check of msghdr should be done after checking for copyin failure

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.104 2015/07/19 02:35:35 deraadt Exp $	*/
d497 4
d516 4
d583 5
d705 7
d813 4
@


1.104
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.103 2015/07/17 15:23:59 guenther Exp $	*/
d495 2
a500 2
	if (error)
		return (error);
d668 2
a673 2
	if (error)
		return (error);
@


1.103
log
@In socketpair(), need to mask the type argument when testing for dgram.

based on jeremy@@'s diff
ok jeremy@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.102 2015/05/21 13:35:15 nicm Exp $	*/
d48 1
d82 3
d127 3
d325 3
d468 3
d495 4
d575 5
d634 3
d668 4
d799 2
d858 3
@


1.102
log
@Rename caddr_t p to cp in an inner block to avoid aliasing the outer
struct proc *p, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.101 2015/05/06 08:52:17 mpi Exp $	*/
d406 1
a406 1
	if (SCARG(uap, type) == SOCK_DGRAM) {
@


1.101
log
@Pass a thread pointer instead of its file descriptor table to getsock(9).

Diff from Vitaliy Makkoveev.

Manpage tweak and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.100 2015/03/14 03:38:51 jsg Exp $	*/
d762 1
a762 1
			caddr_t p = mp->msg_control;
d770 1
a770 1
				error = copyout(mtod(m, caddr_t), p, i);
d773 1
a773 1
				p += i;
d778 1
a778 1
			len = p - (caddr_t)mp->msg_control;
@


1.100
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.99 2015/01/19 19:57:59 guenther Exp $	*/
d123 1
a123 1
	if ((error = getsock(p->p_fd, SCARG(uap, s), &fp)) != 0)
d150 1
a150 1
	if ((error = getsock(p->p_fd, SCARG(uap, s), &fp)) != 0)
d201 1
a201 1
	if ((error = getsock(fdp, sock, &fp)) != 0)
d318 1
a318 1
	if ((error = getsock(p->p_fd, SCARG(uap, s), &fp)) != 0)
d521 1
a521 1
	if ((error = getsock(p->p_fd, s, &fp)) != 0)
d687 1
a687 1
	if ((error = getsock(p->p_fd, s, &fp)) != 0)
d806 1
a806 1
	if ((error = getsock(p->p_fd, SCARG(uap, s), &fp)) != 0)
d828 1
a828 1
	if ((error = getsock(p->p_fd, SCARG(uap, s), &fp)) != 0)
d879 1
a879 1
	if ((error = getsock(p->p_fd, SCARG(uap, s), &fp)) != 0)
d923 1
a923 1
	if ((error = getsock(p->p_fd, SCARG(uap, fdes), &fp)) != 0)
d959 1
a959 1
	if ((error = getsock(p->p_fd, SCARG(uap, fdes), &fp)) != 0)
d1019 1
a1019 1
getsock(struct filedesc *fdp, int fdes, struct file **fpp)
d1023 1
a1023 1
	if ((fp = fd_getfile(fdp, fdes)) == NULL)
@


1.99
log
@Move doaccept() declaration from its .c file to sys/socketvar.h for use
by compat/linux
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.98 2015/01/19 19:47:29 guenther Exp $	*/
a40 1
#include <sys/buf.h>
@


1.98
log
@Delete ABI compat for osockaddr: 20 years and many ABI bumps since sa_len added

ok krw@@ bluhm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.97 2014/12/13 21:05:33 doug Exp $	*/
a66 2
int	doaccept(struct proc *, int, struct sockaddr *, socklen_t *, int,
	    register_t *);
@


1.97
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.96 2014/12/11 19:21:57 tedu Exp $	*/
a1015 4
#if BYTE_ORDER != BIG_ENDIAN
		if (sa->sa_family == 0 && sa->sa_len < AF_MAX)
			sa->sa_family = sa->sa_len;
#endif
@


1.96
log
@convert bcopy to memcpy/memmove. ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.95 2014/12/09 07:05:06 doug Exp $	*/
d565 2
a568 1
		ktriov = malloc(iovlen, M_TEMP, M_WAITOK);
d710 2
a713 1
		ktriov = malloc(iovlen, M_TEMP, M_WAITOK);
@


1.95
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.94 2014/12/02 01:21:35 guenther Exp $	*/
d568 1
a568 1
		bcopy(auio.uio_iov, ktriov, iovlen);
d712 1
a712 1
		bcopy(auio.uio_iov, ktriov, iovlen);
@


1.94
log
@In sys_socket() and doaccept(), gotta skip setting the close-on-exec
flag if the falloc() fails

reported by Carlin Bingham (cb (at) viennan.net)
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.93 2014/09/09 02:07:17 guenther Exp $	*/
d490 1
a490 1
		iov = malloc(sizeof(struct iovec) * msg.msg_iovlen,
d650 1
a650 1
		iov = malloc(sizeof(struct iovec) * msg.msg_iovlen,
@


1.93
log
@Delete the SS_ISCONFIRMING flag that supported delayed connection
confirmation: it was only used for netiso, which was deleted a *decade* ago

ok mpi@@ claudio@@  ports scan by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.92 2014/08/31 01:42:36 guenther Exp $	*/
d86 1
a86 1
	if (type & SOCK_CLOEXEC)
d243 1
a243 1
	if (flags & SOCK_CLOEXEC)
@


1.92
log
@Add additional kernel interfaces for setting close-on-exec on fds
when creating them: pipe2(), dup3(), accept4(), MSG_CMSG_CLOEXEC,
SOCK_CLOEXEC.  Includes SOCK_NONBLOCK support.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.91 2014/07/13 15:00:40 tedu Exp $	*/
d963 1
a963 1
	if ((so->so_state & (SS_ISCONNECTED|SS_ISCONFIRMING)) == 0) {
@


1.91
log
@pass the size to free in some of the obvious cases
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.90 2014/07/12 18:43:32 tedu Exp $	*/
d40 1
d65 4
a68 2
int copyaddrout(struct proc *, struct mbuf *, struct sockaddr *, socklen_t,
    socklen_t *);
d81 1
d86 2
d92 1
a92 1
	fp->f_flag = FREAD|FWRITE;
d95 2
a96 2
	error = socreate(SCARG(uap, domain), &so, SCARG(uap, type),
			 SCARG(uap, protocol));
d104 2
d168 27
d202 1
a202 2
	if (SCARG(uap, name) && (error = copyin(SCARG(uap, anamelen),
	    &namelen, sizeof (namelen))))
d204 1
a204 1
	if ((error = getsock(p->p_fd, SCARG(uap, s), &fp)) != 0)
d237 3
a239 2
	/* Take note if socket was non-blocking. */
	nflag = (headfp->f_flag & FNONBLOCK);
d241 1
a241 1
	fdplock(p->p_fd);
d243 3
a245 1
	fdpunlock(p->p_fd);
d264 2
a265 2
		fdplock(p->p_fd);
		fdremove(p->p_fd, tmpfd);
d267 1
a267 1
		fdpunlock(p->p_fd);
d286 2
a287 4
	if (!error && SCARG(uap, name)) {
		error = copyaddrout(p, nam, SCARG(uap, name), namelen,
		    SCARG(uap, anamelen));
	}
d291 2
a292 2
		fdplock(p->p_fd);
		fdremove(p->p_fd, tmpfd);
d294 1
a294 1
		fdpunlock(p->p_fd);
d296 1
d377 1
a377 1
	int fd, error, sv[2];
d379 5
a383 2
	error = socreate(SCARG(uap, domain), &so1, SCARG(uap, type),
	    SCARG(uap, protocol));
d386 1
a386 2
	error = socreate(SCARG(uap, domain), &so2, SCARG(uap, type),
	    SCARG(uap, protocol));
d391 1
a391 1
	if ((error = falloc(p, &fp1, &fd)) != 0)
d393 1
a393 2
	sv[0] = fd;
	fp1->f_flag = FREAD|FWRITE;
d397 1
a397 1
	if ((error = falloc(p, &fp2, &fd)) != 0)
d399 1
a399 1
	fp2->f_flag = FREAD|FWRITE;
d403 4
a406 1
	sv[1] = fd;
d418 6
@


1.90
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.89 2013/09/14 02:28:02 guenther Exp $	*/
d457 1
a457 1
		free(iov, M_IOV, 0);
d473 1
d519 1
a519 1
		int iovlen = auio.uio_iovcnt * sizeof (struct iovec);
d543 1
a543 1
		free(ktriov, M_TEMP, 0);
d623 1
a623 1
		free(iov, M_IOV, 0);
d640 1
d663 1
a663 1
		int iovlen = auio.uio_iovcnt * sizeof (struct iovec);
d683 1
a683 1
		free(ktriov, M_TEMP, 0);
@


1.89
log
@Correct the handling of I/O of >=2^32 bytes and the ktracing there of
by using size_t/ssize_t instead of int/u_int to handle I/O lengths in
uiomove(), vn_fsizechk(), and ktrgenio().  Eliminate the always-zero
'error' argument to ktrgenio() at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.88 2013/04/05 08:25:30 tedu Exp $	*/
d457 1
a457 1
		free(iov, M_IOV);
d542 1
a542 1
		free(ktriov, M_TEMP);
d622 1
a622 1
		free(iov, M_IOV);
d681 1
a681 1
		free(ktriov, M_TEMP);
@


1.88
log
@remove some obsolete casts
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.87 2012/10/17 05:07:55 guenther Exp $	*/
d541 1
a541 1
			ktrgenio(p, s, UIO_WRITE, ktriov, *retsize, error);
d680 1
a680 2
			ktrgenio(p, s, UIO_READ, ktriov,
			    len - auio.uio_resid, error);
@


1.87
log
@In sys_accept(), don't sleep between pulling the new socket from the
queue and calling soaccept(), so that the socket can't get torn down
by a TCP RST in the middle and trigger "panic: soaccept: !NOFDREF", as
seen by halex@@

Analysis, original diff, and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.86 2012/05/06 20:25:27 matthew Exp $	*/
d121 1
a121 1
			 MT_SONAME);
d293 1
a293 1
			 MT_SONAME);
d310 1
a310 2
		error = tsleep(&so->so_timeo, PSOCK | PCATCH,
		    "netcon2", 0);
d344 1
a344 1
			 SCARG(uap, protocol));
d348 1
a348 1
			 SCARG(uap, protocol));
d497 1
a497 1
				 MT_SONAME);
d511 1
a511 1
				 mp->msg_controllen, MT_CONTROL);
d610 1
a610 1
		    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
d680 2
a681 2
			ktrgenio(p, s, UIO_READ,
				ktriov, len - auio.uio_resid, error);
d724 1
a724 2
				error = copyout(mtod(m, caddr_t), p,
				    (unsigned)i);
d808 1
a808 2
	error = sosetopt(fp->f_data, SCARG(uap, level),
			 SCARG(uap, name), m);
@


1.86
log
@Change accept(), recvfrom(), recvmsg(), getsockname(), and
getpeername() to return the untruncated address length in *addrlen
instead of the number of bytes copied out.  This matches POSIX's
requirements and allows userland applications to detect when the
returned address was truncated.

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.85 2012/04/22 05:43:14 guenther Exp $	*/
d175 1
a202 11
	/*
	 * At this point we know that there is at least one connection
	 * ready to be accepted. Remove it from the queue prior to
	 * allocating the file descriptor for it since falloc() may
	 * block allowing another process to accept the connection
	 * instead.
	 */
	so = TAILQ_FIRST(&head->so_q);
	if (soqremque(so, 1) == 0)
		panic("accept");

d204 1
a204 1
	nflag = (fp->f_flag & FNONBLOCK);
d211 2
a212 4
		 * Probably ran out of file descriptors. Put the
		 * unaccepted connection back onto the queue and
		 * do another wakeup so some other process might
		 * have a chance at it.
a213 1
		soqinsque(head, so, 1);
d218 23
a247 1
	nam = m_get(M_WAIT, MT_SONAME);
@


1.85
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.84 2011/12/03 12:38:30 fgsch Exp $	*/
d64 3
d124 2
a125 2
	if (KTRPOINT(p, KTR_STRUCT))
		ktrsockaddr(p, mtod(nam, caddr_t), SCARG(uap, namelen));
d241 2
a242 12
		if (namelen > nam->m_len)
			namelen = nam->m_len;
		/* SHOULD COPY OUT A CHAIN HERE */
		if ((error = copyout(mtod(nam, caddr_t),
		    SCARG(uap, name), namelen)) == 0) {
#ifdef KTRACE
			if (KTRPOINT(p, KTR_STRUCT))
				ktrsockaddr(p, mtod(nam, caddr_t), namelen);
#endif
			error = copyout(&namelen, SCARG(uap, anamelen),
			    sizeof (*SCARG(uap, anamelen)));
		}
d686 1
a686 1
			alen = MIN(from->m_len, mp->msg_namelen);
d688 1
a688 1
			    alen);
a694 1

d881 1
a881 10
	if (len > m->m_len)
		len = m->m_len;
	error = copyout(mtod(m, caddr_t), SCARG(uap, asa), len);
	if (error == 0) {
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrsockaddr(p, mtod(m, caddr_t), len);
#endif
		error = copyout(&len, SCARG(uap, alen), sizeof (len));
	}
d921 1
a921 10
	if (len > m->m_len)
		len = m->m_len;
	error = copyout(mtod(m, caddr_t), SCARG(uap, asa), len);
	if (error == 0) {
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrsockaddr(p, mtod(m, caddr_t), len);
#endif
		error = copyout(&len, SCARG(uap, alen), sizeof (len));
	}
d1013 20
@


1.84
log
@add support for MSG_NOSIGNAL.
linux bits compiled on i386 by sebastia@@, mikeb@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.83 2011/10/23 15:11:14 deraadt Exp $	*/
d95 1
a95 1
		FILE_SET_MATURE(fp);
d127 1
a127 1
	FRELE(fp);
d145 1
a145 1
	FRELE(fp);
d259 1
a259 1
		FILE_SET_MATURE(fp);
d265 1
a265 1
	FRELE(headfp);
d287 1
a287 1
		FRELE(fp);
d302 1
a302 1
		FRELE(fp);
d320 1
a320 1
	FRELE(fp);
d377 2
a378 2
		FILE_SET_MATURE(fp1);
		FILE_SET_MATURE(fp2);
d545 1
a545 1
	FRELE(fp);
d742 1
a742 1
	FRELE(fp);
d764 1
a764 1
	FRELE(fp);
d815 1
a815 1
	FRELE(fp);
d855 1
a855 1
	FRELE(fp);
d900 1
a900 1
	FRELE(fp);
d928 1
a928 1
		FRELE(fp);
d949 1
a949 1
	FRELE(fp);
@


1.83
log
@shorten periods of fdplock() in accept() and socket(), so that greater
concurrency is possible in the future.  discussed with guenther and
matthew.  ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.82 2011/07/08 20:54:03 deraadt Exp $	*/
d529 1
a529 1
		if (error == EPIPE)
@


1.82
log
@Remove COMPAT_OLDSOCK since no nothing sets MSG_COMPAT anymore.
The song and dance for handling 16-bit af_family on big-endian
machines remains untouched.
ok claudio miod tedu guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.81 2011/07/08 19:28:38 otto Exp $	*/
d78 4
a82 2
	if ((error = falloc(p, &fp, &fd)) != 0)
		goto out;
d89 1
d92 1
a98 1
	fdpunlock(fdp);
d214 3
a216 1
	if ((error = falloc(p, &fp, &tmpfd)) != 0) {
d225 1
a225 1
		goto unlock;
a226 1
	*retval = tmpfd;
d251 1
a251 1
	/* if an error occurred, free the file descriptor */
d253 2
d257 1
d260 1
a262 2
unlock:
	fdpunlock(p->p_fd);
@


1.81
log
@Support sending struct info to kdump. So far for struct stat and
struct sockaddress; mostly from freebsd. ok deraadt@@ tedu@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.80 2011/07/08 05:01:27 matthew Exp $	*/
a412 1
#ifdef COMPAT_OLDSOCK
a413 1
#endif
a445 1
#ifdef COMPAT_OLDSOCK
a446 1
#endif
d499 1
a499 5
		if (mp->msg_controllen < CMSG_ALIGN(sizeof(struct cmsghdr))
#ifdef COMPAT_OLDSOCK
		    && mp->msg_flags != MSG_COMPAT
#endif
		) {
a506 11
#ifdef COMPAT_OLDSOCK
		if (mp->msg_flags == MSG_COMPAT) {
			struct cmsghdr *cm;

			M_PREPEND(control, sizeof(*cm), M_WAIT);
			cm = mtod(control, struct cmsghdr *);
			cm->cmsg_len = control->m_len;
			cm->cmsg_level = SOL_SOCKET;
			cm->cmsg_type = SCM_RIGHTS;
		}
#endif
a599 3
#ifdef COMPAT_OLDSOCK
	msg.msg_flags = SCARG(uap, flags) &~ MSG_COMPAT;
#else
a600 1
#endif
d687 3
a689 11
			/* save sa_len before it is destroyed by MSG_COMPAT */
			alen = mp->msg_namelen;
			if (alen > from->m_len)
				alen = from->m_len;
			/* else if alen < from->m_len ??? */
#ifdef COMPAT_OLDSOCK
			if (mp->msg_flags & MSG_COMPAT)
				mtod(from, struct osockaddr *)->sa_family =
				    mtod(from, struct sockaddr *)->sa_family;
#endif
			error = copyout(mtod(from, caddr_t), mp->msg_name, alen);
a700 5
#ifdef COMPAT_OLDSOCK
			if (mp->msg_flags & MSG_COMPAT)
				error = 0;	/* old recvfrom didn't check */
			else
#endif
a704 20
#ifdef COMPAT_OLDSOCK
		/*
		 * We assume that old recvmsg calls won't receive access
		 * rights and other control info, esp. as control info
		 * is always optional and those options didn't exist in 4.3.
		 * If we receive rights, trim the cmsghdr; anything else
		 * is tossed.
		 */
		if (control && mp->msg_flags & MSG_COMPAT) {
			if (mtod(control, struct cmsghdr *)->cmsg_level !=
			    SOL_SOCKET ||
			    mtod(control, struct cmsghdr *)->cmsg_type !=
			    SCM_RIGHTS) {
				mp->msg_controllen = 0;
				goto out;
			}
			control->m_len -= sizeof (struct cmsghdr);
			control->m_data += sizeof (struct cmsghdr);
		}
#endif
d981 1
a981 1
#if defined(COMPAT_OLDSOCK) && BYTE_ORDER != BIG_ENDIAN
@


1.80
log
@Remove the sys_opipe() kernel entry point.  sys_pipe() is the future.

While here, switch compat_linux to just use sys_pipe() rather than
incorrectly wrapping sys_opipe().

ok tedu@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.79 2011/04/04 12:44:10 deraadt Exp $	*/
d117 4
d238 5
a242 1
		    SCARG(uap, name), namelen)) == 0)
d245 1
d288 4
d497 4
d723 5
d942 5
a946 1
	if (error == 0)
d948 1
d991 5
a995 1
	if (error == 0)
d997 1
@


1.79
log
@COMPAT_O47 (kernel getpeereid, which was replaced by libc getpeereid)
can go away
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.78 2010/09/22 04:57:55 matthew Exp $	*/
a885 24
	return (error);
}

int
sys_pipe(struct proc *p, void *v, register_t *retval)
{
	struct sys_pipe_args /* {
		syscallarg(int *) fdp;
	} */ *uap = v;
	int error, fds[2];
	register_t rval[2];

	if ((error = sys_opipe(p, v, rval)) != 0)
		return (error);

	fds[0] = rval[0];
	fds[1] = rval[1];
	error = copyout(fds, SCARG(uap, fdp), 2 * sizeof (int));
	if (error) {
		fdplock(p->p_fd);
		fdrelease(p, fds[0]);
		fdrelease(p, fds[1]);
		fdpunlock(p->p_fd);
	}
@


1.78
log
@Fix a locking bug in accept(2) caught by sthen@@ using my strict
locking diff.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.77 2010/09/20 07:18:03 deraadt Exp $	*/
a994 47

#ifdef COMPAT_O47
/*
 * Get eid of peer for connected socket.
 */
/* ARGSUSED */
int
compat_o47_sys_getpeereid(struct proc *p, void *v, register_t *retval)
{
	struct compat_o47_sys_getpeereid_args /* {
		syscallarg(int) fdes;
		syscallarg(uid_t *) euid;
		syscallarg(gid_t *) egid;
	} */ *uap = v;
	struct file *fp;
	struct socket *so;
	struct mbuf *m = NULL;
	struct sockpeercred *id;
	int error;

	if ((error = getsock(p->p_fd, SCARG(uap, fdes), &fp)) != 0)
		return (error);
	so = fp->f_data;
	if (so->so_proto != pffindtype(AF_LOCAL, SOCK_STREAM)) {
		FRELE(fp);
		return (EOPNOTSUPP);
	}
	m = m_getclr(M_WAIT, MT_SONAME);
	if (m == NULL) {
		error = ENOBUFS;
		goto bad;
	}	
	error = (*so->so_proto->pr_usrreq)(so, PRU_PEEREID, 0, m, 0, p);
	if (!error && m->m_len != sizeof(struct sockpeercred))
		error = EOPNOTSUPP;
	if (error)
		goto bad;
	id = mtod(m, struct sockpeercred *);
	error = copyout(&(id->uid), SCARG(uap, euid), sizeof(uid_t));
	if (error == 0)
		error = copyout(&(id->gid), SCARG(uap, egid), sizeof(gid_t));
bad:
	FRELE(fp);
	m_freem(m);
	return (error);
}
#endif /* COMPAT_O47 */
@


1.77
log
@Move getpeereid(2) into COMPAT_O47.  In 4.8 and onwards it is library
code using socket options.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.76 2010/07/03 04:44:51 guenther Exp $	*/
d216 1
a216 1
		goto bad;
d246 2
a248 1
	fdpunlock(p->p_fd);
@


1.76
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.75 2010/06/30 19:57:05 deraadt Exp $	*/
d995 1
d1001 1
a1001 1
sys_getpeereid(struct proc *p, void *v, register_t *retval)
d1003 1
a1003 1
	struct sys_getpeereid_args /* {
d1040 1
@


1.75
log
@Add getsockopt SOL_SOCKET SO_PEERCRED support. This behaves similar to
getpeereid(2), but also supplies the remote pid.  This is supplied in
a 'struct sockpeercred' (unlike Linux -- they showed how little they
know about real unix by calling theirs 'struct ucred').
ok guenther ajacoutot
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.74 2009/12/23 07:40:31 guenther Exp $	*/
d1099 1
a1099 1
sys_setrdomain(struct proc *p, void *v, register_t *retval)
d1101 2
a1102 2
	struct sys_setrdomain_args /* {
		syscallarg(int) rdomain;
d1104 1
a1104 1
	int rdomain, error;
d1106 1
a1106 1
	rdomain = SCARG(uap, rdomain);
d1108 1
a1108 1
	if (p->p_p->ps_rdomain == (u_int)rdomain)
d1110 1
a1110 1
	if (p->p_p->ps_rdomain != 0 && (error = suser(p, 0)) != 0)
d1112 1
a1112 1
	if (rdomain < 0 || !rtable_exists((u_int)rdomain))
d1115 1
a1115 1
	p->p_p->ps_rdomain = (u_int)rdomain;
d1121 1
a1121 1
sys_getrdomain(struct proc *p, void *v, register_t *retval)
d1123 1
a1123 1
	*retval = (int)p->p_p->ps_rdomain;
@


1.74
log
@The process's rdomain should be, well, per-process and not per-rthread,
so put it in struct process instead of struct proc.  While at it,
move the p_emul member inside struct proc so that it gets copied
automatically instead of requiring manual assignment.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.73 2009/11/27 20:05:50 guenther Exp $	*/
d1010 1
a1010 1
	struct unpcbid *id;
d1026 1
a1026 1
	if (!error && m->m_len != sizeof(struct unpcbid))
d1030 2
a1031 2
	id = mtod(m, struct unpcbid *);
	error = copyout(&(id->unp_euid), SCARG(uap, euid), sizeof(uid_t));
d1033 1
a1033 1
		error = copyout(&(id->unp_egid), SCARG(uap, egid), sizeof(gid_t));
@


1.73
log
@Add setrdomain() and getrdomain() system calls.  Committing now to
catch the libc major bump per request from deraadt@@

Diff by reyk.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.72 2009/11/23 13:18:16 jacekm Exp $	*/
d1108 1
a1108 1
	if (p->p_rdomain == (u_int)rdomain)
d1110 1
a1110 1
	if (p->p_rdomain != 0 && (error = suser(p, 0)) != 0)
d1115 1
a1115 1
	p->p_rdomain = (u_int)rdomain;
d1123 1
a1123 1
	*retval = (int)p->p_rdomain;
@


1.72
log
@Replace in-line implementation of soqinsque with a call to soqinsque.

"looks right" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.71 2009/08/10 16:49:39 thib Exp $	*/
d57 2
d1094 30
@


1.71
log
@Don't use char arrays for sleep wchans and reuse them.
just use strings and make things unique.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.69 2008/12/16 07:57:28 guenther Exp $	*/
d212 1
a212 4
		so->so_head = head;
		head->so_qlen++;
		so->so_onq = &head->so_q;
		TAILQ_INSERT_HEAD(so->so_onq, so, so_qe);
@


1.70
log
@fix PR 6082: do not create more fd's than will fit in the message on
the receiving side when passing fd's. ok deraadt@@ kettenis@@
@
text
@d179 1
a179 1
		error = tsleep(&head->so_timeo, PSOCK | PCATCH, netcon, 0);
d290 1
a290 1
		    netcon, 0);
@


1.69
log
@Move the functionality of psignal() to a new function ptsignal()
that takes an additional argument "type" that indicates whether the
signal is for the process, just a particular thread, or propagated
to a thread because it's not caught or blocked.  psignal() becomes
a wrapper that does the first of those.

So that sys_kill() can tell apart signals for the process and signals
for the process's original thread, the tid of the original thread
is defined as its pid + THREAD_PID_OFFSET.

ok tedu@@ art@@ andreas@@ kurt@@   "better early than late" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.68 2008/05/23 15:51:12 thib Exp $	*/
d669 2
a670 1
			  &mp->msg_flags);
@


1.68
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.67 2008/04/06 19:42:16 stefan Exp $	*/
d526 1
a526 1
			psignal(p, SIGPIPE);
@


1.67
log
@In sendit(), len should be size_t, not int. Could cause it to return
wrong values on 64-bit machines otherwise. ok millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.66 2006/10/23 07:13:56 henning Exp $	*/
d115 1
a115 1
		error = sobind(fp->f_data, nam);
d937 1
a937 1
	error = (*so->so_proto->pr_usrreq)(so, PRU_SOCKADDR, 0, m, 0);
d981 1
a981 1
	error = (*so->so_proto->pr_usrreq)(so, PRU_PEERADDR, 0, m, 0);
d1025 1
a1025 1
	error = (*so->so_proto->pr_usrreq)(so, PRU_PEEREID, 0, m, 0);
@


1.66
log
@fix control message length check, needs CMSG_ALIGN()
reported by ryo@@nerv.org to netbsd, noticed by miod, ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.65 2006/10/21 02:18:00 tedu Exp $	*/
d453 2
a454 1
	int len, error;
@


1.65
log
@tbert sent me a diff to change some 0 to NULL
i got carried away and deleted a whole bunch of useless casts
this is C, not C++.  ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.64 2006/10/18 14:43:45 kurt Exp $	*/
d485 1
a485 1
		if (mp->msg_controllen < sizeof(struct cmsghdr)
@


1.64
log
@Return ECONNABORTED when a non-blocking socket has been shutdown() for
receives. Previously a non-blocking socket would mask this error by
returning EWOULDBLOCK and mislead applications to think accept() may
eventually succeed. Corrects a pthreads deadlock reported by Tero Koskinen
<tero.koskinen at iki.fi> okay kettenis@@, theo@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.63 2006/03/26 17:47:10 mickey Exp $	*/
d115 1
a115 1
		error = sobind((struct socket *)fp->f_data, nam);
d135 1
a135 1
	error = solisten((struct socket *)fp->f_data, SCARG(uap, backlog));
d162 1
a162 1
	head = (struct socket *)fp->f_data;
d270 1
a270 1
	so = (struct socket *)fp->f_data;
d519 1
a519 2
	error = sosend((struct socket *)fp->f_data, to, &auio,
	    NULL, control, flags);
d666 2
a667 2
	error = soreceive((struct socket *)fp->f_data, &from, &auio,
			  NULL, mp->msg_control ? &control : NULL,
d701 1
a701 2
			error = copyout(mtod(from, caddr_t),
			    mp->msg_name, alen);
d742 1
a742 1
			caddr_t p = (caddr_t)mp->msg_control;
d789 1
a789 1
	error = soshutdown((struct socket *)fp->f_data, SCARG(uap, how));
d835 1
a835 1
	error = sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
d864 2
a865 2
		error = copyin((caddr_t)SCARG(uap, avalsize),
		    (caddr_t)&valsize, sizeof (valsize));
d870 1
a870 1
	if ((error = sogetopt((struct socket *)fp->f_data, SCARG(uap, level),
d877 2
a878 2
			error = copyout((caddr_t)&valsize,
			    (caddr_t)SCARG(uap, avalsize), sizeof (valsize));
d883 1
a883 1
		(void) m_free(m);
d901 1
a901 2
	error = copyout((caddr_t)fds, (caddr_t)SCARG(uap, fdp),
	    2 * sizeof (int));
d931 1
a931 1
	error = copyin((caddr_t)SCARG(uap, alen), (caddr_t)&len, sizeof (len));
d934 1
a934 1
	so = (struct socket *)fp->f_data;
d941 1
a941 1
	error = copyout(mtod(m, caddr_t), (caddr_t)SCARG(uap, asa), len);
d943 1
a943 2
		error = copyout((caddr_t)&len, (caddr_t)SCARG(uap, alen),
		    sizeof (len));
d971 1
a971 1
	so = (struct socket *)fp->f_data;
d976 1
a976 1
	error = copyin((caddr_t)SCARG(uap, alen), (caddr_t)&len, sizeof (len));
d985 1
a985 1
	error = copyout(mtod(m, caddr_t), (caddr_t)SCARG(uap, asa), len);
d987 1
a987 2
		error = copyout((caddr_t)&len, (caddr_t)SCARG(uap, alen),
		    sizeof (len));
d1014 1
a1014 1
	so = (struct socket *)fp->f_data;
d1030 1
a1030 2
	error = copyout((caddr_t)&(id->unp_euid),
		(caddr_t)SCARG(uap, euid), sizeof(uid_t));
d1032 1
a1032 2
		error = copyout((caddr_t)&(id->unp_egid),
		    (caddr_t)SCARG(uap, egid), sizeof(gid_t));
@


1.63
log
@do per file io accounting and show that in fstat as well; pedro@@ marco@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.62 2006/01/05 05:05:07 jsg Exp $	*/
d168 4
a171 1
		error = EWOULDBLOCK;
@


1.62
log
@ansi/deregister
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.61 2005/07/06 20:41:44 krw Exp $	*/
d525 1
a525 1
	if (error == 0)
d527 3
d761 4
@


1.61
log
@Eliminate a couple of 'msg.msg_iovlen < 0' tests. msg_iovlen is
unsigned.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.60 2004/07/22 06:13:08 tedu Exp $	*/
d63 1
a63 4
sys_socket(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d65 1
a65 1
	register struct sys_socket_args /* {
d99 1
a99 4
sys_bind(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d101 1
a101 1
	register struct sys_bind_args /* {
d124 1
a124 4
sys_listen(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d126 1
a126 1
	register struct sys_listen_args /* {
d141 1
a141 4
sys_accept(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d253 1
a253 4
sys_connect(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d307 1
a307 4
sys_socketpair(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d309 1
a309 1
	register struct sys_socketpair_args /* {
d315 1
a315 1
	register struct filedesc *fdp = p->p_fd;
d379 1
a379 4
sys_sendto(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d381 1
a381 1
	register struct sys_sendto_args /* {
d406 1
a406 4
sys_sendmsg(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d408 1
a408 1
	register struct sys_sendmsg_args /* {
d443 1
a443 6
sendit(p, s, mp, flags, retsize)
	struct proc *p;
	int s;
	struct msghdr *mp;
	int flags;
	register_t *retsize;
d496 1
a496 1
			register struct cmsghdr *cm;
d542 1
a542 4
sys_recvfrom(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d544 1
a544 1
	register struct sys_recvfrom_args /* {
d575 1
a575 4
sys_recvmsg(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d577 1
a577 1
	register struct sys_recvmsg_args /* {
d620 2
a621 6
recvit(p, s, mp, namelenp, retsize)
	struct proc *p;
	int s;
	struct msghdr *mp;
	caddr_t namelenp;
	register_t *retsize;
d625 2
a626 2
	register struct iovec *iov;
	register int i;
d770 1
a770 4
sys_shutdown(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d788 1
a788 4
sys_setsockopt(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d839 1
a839 4
sys_getsockopt(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d882 1
a882 1
	register struct sys_pipe_args /* {
d909 1
a909 4
sys_getsockname(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d950 1
a950 4
sys_getpeername(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d958 1
a958 1
	register struct socket *so;
d994 1
a994 4
sys_getpeereid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
@


1.60
log
@remove p arg from fdplock
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.59 2004/04/12 23:58:10 tedu Exp $	*/
d444 1
a444 1
	if (msg.msg_iovlen < 0 || msg.msg_iovlen > IOV_MAX)
d624 1
a624 1
	if (msg.msg_iovlen < 0 || msg.msg_iovlen > IOV_MAX)
@


1.59
log
@make sockargs take void *, combine a len check.
from pedro martelletto, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.58 2004/04/01 23:56:05 tedu Exp $	*/
d78 1
a78 1
	fdplock(fdp, p);
d213 1
a213 1
	fdplock(p->p_fd, p);
d347 1
a347 1
	fdplock(fdp, p);
d944 1
a944 1
		fdplock(p->p_fd, p);
@


1.58
log
@use NULL for ptrs.  parts from Joris Vink
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.57 2004/01/06 04:18:18 tedu Exp $	*/
d118 1
a118 1
	error = sockargs(&nam, (caddr_t)SCARG(uap, name), SCARG(uap, namelen),
d287 1
a287 1
	error = sockargs(&nam, (caddr_t)SCARG(uap, name), SCARG(uap, namelen),
d1094 1
a1094 5
sockargs(mp, buf, buflen, type)
	struct mbuf **mp;
	caddr_t buf;
	socklen_t buflen;
	int type;
d1102 2
a1103 1
	 * will overflow sa_len.
d1105 1
a1105 3
	if (type == MT_SONAME && (u_int)buflen > UCHAR_MAX)
		return (EINVAL);
	if ((u_int)buflen > MCLBYTES)
a1125 1

@


1.57
log
@lock filedesc before manipulating.  avoids some rare races.
testing for quite some time by brad + otto
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.56 2003/09/01 18:06:03 henning Exp $	*/
d722 1
a722 1
		if (from == 0)
d773 1
a773 1
		if (len <= 0 || control == 0)
@


1.56
log
@match syscallargs comments with reality
from Patrick Latifi <patrick.l@@hermes.usherb.ca>
ok jason@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.55 2003/07/21 22:44:50 tedu Exp $	*/
d78 2
d81 1
a81 1
		return (error);
d95 2
d213 1
d257 1
d346 2
d375 2
a376 1
		return (error);
d389 1
d944 1
d947 1
@


1.55
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.54 2003/06/02 23:28:07 millert Exp $	*/
d105 1
a105 1
		syscallarg(struct sockaddr *) name;
d266 1
a266 1
		syscallarg(struct sockaddr *) name;
d394 1
a394 1
		syscallarg(caddr_t) buf;
d397 1
a397 1
		syscallarg(struct sockaddr *) to;
d424 1
a424 1
		syscallarg(caddr_t) msg;
d568 1
a568 1
		syscallarg(caddr_t) buf;
d829 1
a829 1
		syscallarg(caddr_t) val;
d883 1
a883 1
		syscallarg(caddr_t) val;
d952 1
a952 1
		syscallarg(caddr_t) asa;
d996 1
a996 1
		syscallarg(caddr_t) asa;
@


1.54
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.53 2002/08/23 22:21:44 art Exp $	*/
d89 1
a89 1
		fp->f_data = (caddr_t)so;
d163 2
a164 2
	if (SCARG(uap, name) && (error = copyin((caddr_t)SCARG(uap, anamelen),
	    (caddr_t)&namelen, sizeof (namelen))))
d184 1
a184 2
		error = tsleep((caddr_t)&head->so_timeo, PSOCK | PCATCH,
		    netcon, 0);
d231 1
a231 1
	fp->f_data = (caddr_t)so;
d239 2
a240 3
		    (caddr_t)SCARG(uap, name), namelen)) == 0)
			error = copyout((caddr_t)&namelen,
			    (caddr_t)SCARG(uap, anamelen),
d295 1
a295 1
		error = tsleep((caddr_t)&so->so_timeo, PSOCK | PCATCH,
d346 1
a346 1
	fp1->f_data = (caddr_t)so1;
d352 1
a352 1
	fp2->f_data = (caddr_t)so2;
d363 1
a363 2
	error = copyout((caddr_t)sv, (caddr_t)SCARG(uap, rsv),
	    2 * sizeof (int));
d431 1
a431 1
	error = copyin(SCARG(uap, msg), (caddr_t)&msg, sizeof (msg));
d442 2
a443 2
	    (error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)))))
d531 1
a531 1
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
d579 2
a580 2
		error = copyin((caddr_t)SCARG(uap, fromlenaddr),
		    (caddr_t)&msg.msg_namelen, sizeof (msg.msg_namelen));
d611 1
a611 2
	error = copyin((caddr_t)SCARG(uap, msg), (caddr_t)&msg,
	    sizeof (msg));
d627 1
a627 1
		error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
d634 1
a634 1
	if ((error = recvit(p, SCARG(uap, s), &msg, (caddr_t)0, retval)) == 0) {
d636 1
a636 2
		error = copyout((caddr_t)&msg, (caddr_t)SCARG(uap, msg),
		    sizeof(msg));
d686 1
a686 1
		bcopy((caddr_t)auio.uio_iov, (caddr_t)ktriov, iovlen);
d726 1
a726 1
			    (caddr_t)mp->msg_name, alen);
d732 1
a732 1
		    (error = copyout((caddr_t)&alen, namelenp, sizeof(alen)))) {
@


1.53
log
@Just like getvnode, make getsock FREF the file so that we can't get away
with not refing it.

Eyeballed by lurene@@daemonkitty.net, fries@@, nordin@@ and fries@@
Some additional cleanups by nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.52 2002/05/23 14:59:24 art Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.52
log
@In sys_accept don't FILE_SET_MATURE the file if we got an error and we've freed it.
Noticed by enami@@netbsd in a recent discussion on tech-kern@@netbsd.
Thanks to miod@@ for helping me understand my code and realize that
what the discussion was originally about (a diff by itojun@@) didn't apply
to us because I tweaked the semantics of closef() to solve the problem
automagically for us (and I forgot about it).
miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.51 2002/02/12 16:38:39 art Exp $	*/
a117 1
	FREF(fp);
a143 1
	FREF(fp);
a171 1
	FREF(fp);
d283 2
a284 1
	if ((so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING))
d286 1
a286 1
	FREF(fp);
d481 2
d496 4
a499 2
		    (auio.uio_resid += iov->iov_len) > SSIZE_MAX)
			return (EINVAL);
a500 1
	FREF(fp);
d504 3
a506 6
		if (error) {
			FRELE(fp);
			return (error);
		}
	} else
		to = 0;
d667 1
a667 1
	struct mbuf *from = 0, *control = 0;
d685 4
a688 2
		    (auio.uio_resid += iov->iov_len) > SSIZE_MAX)
			return (EINVAL);
a689 1
	FREF(fp);
a821 1
	FREF(fp);
d847 4
a850 3
	if (SCARG(uap, valsize) > MCLBYTES)
		return (EINVAL);
	FREF(fp);
a901 1
	FREF(fp);
a971 1
	FREF(fp);
d1017 2
a1018 1
	if ((so->so_state & (SS_ISCONNECTED|SS_ISCONFIRMING)) == 0)
d1020 1
a1020 1
	FREF(fp);
d1064 2
a1065 1
	if (so->so_proto != pffindtype(AF_LOCAL, SOCK_STREAM))
d1067 1
a1067 1
	FREF(fp);
d1148 2
@


1.51
log
@Fix my total blackout of the brain.
I rearrange half of this function to properly handle unlocking in one
error case, then I forget to handle that error case.
I even had a regression test written for this!

In other words: fix accept(2) to unlock when it runs out of fds.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.50 2002/02/12 13:05:31 art Exp $	*/
d256 2
a259 1
	FILE_SET_MATURE(fp);
@


1.50
log
@Fix all users of getsock to use FREF/FRELE properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.49 2002/02/11 12:34:30 art Exp $	*/
d229 1
a229 2
		splx(s);
		return (error);
@


1.49
log
@In {send,recv}msg allow zero sized message. We can have control data.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.48 2002/02/08 13:53:28 art Exp $	*/
d118 1
d121 5
a125 4
	if (error)
		return (error);
	error = sobind((struct socket *)fp->f_data, nam);
	m_freem(nam);
d145 4
a148 1
	return (solisten((struct socket *)fp->f_data, SCARG(uap, backlog)));
d157 1
a157 1
	register struct sys_accept_args /* {
d162 1
a162 1
	struct file *fp;
d174 2
d179 2
a180 2
		splx(s);
		return (EINVAL);
d183 2
a184 2
		splx(s);
		return (EWOULDBLOCK);
d194 1
a194 2
			splx(s);
			return (error);
d200 1
a200 2
		splx(s);
		return (error);
d259 2
d262 1
a262 1
	FILE_SET_MATURE(fp);
d273 1
a273 1
	register struct sys_connect_args /* {
d279 2
a280 2
	register struct socket *so;
	struct mbuf *nam;
d288 1
d292 1
a292 1
		return (error);
d297 1
d315 3
a317 1
	m_freem(nam);
d467 1
a467 1
	register struct proc *p;
d469 1
a469 1
	register struct msghdr *mp;
d475 2
a476 2
	register struct iovec *iov;
	register int i;
d499 1
d503 2
a504 1
		if (error)
d506 1
d563 1
d657 1
a657 1
	register struct proc *p;
d659 1
a659 1
	register struct msghdr *mp;
d690 1
d799 1
d814 1
a814 1
	register struct sys_shutdown_args /* {
d823 4
a826 1
	return (soshutdown((struct socket *)fp->f_data, SCARG(uap, how)));
d836 1
a836 1
	register struct sys_setsockopt_args /* {
d851 1
d857 2
a858 2
				m_freem(m);
				return (ENOBUFS);
d861 4
a864 2
		if (m == NULL)
			return (ENOBUFS);
d868 1
a868 2
			(void) m_free(m);
			return (error);
d872 8
a879 2
	return (sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
			 SCARG(uap, name), m));
d889 1
a889 1
	register struct sys_getsockopt_args /* {
d903 1
d908 1
a908 1
			return (error);
d921 2
d961 1
a961 1
	register struct sys_getsockname_args /* {
d967 2
a968 2
	register struct socket *so;
	struct mbuf *m;
d974 1
d977 1
a977 1
		return (error);
d990 3
a992 1
	m_freem(m);
d1006 1
a1006 1
	register struct sys_getpeername_args /* {
d1013 1
a1013 1
	struct mbuf *m;
d1022 1
d1025 1
a1025 1
		return (error);
d1037 1
d1052 1
a1052 1
	register struct sys_getpeereid_args /* {
d1058 2
a1059 2
	register struct socket *so;
	struct mbuf *m;
d1068 1
d1070 4
a1073 2
	if (m == NULL)
		return (ENOBUFS);
d1086 1
d1098 2
a1099 2
	register struct sockaddr *sa;
	register struct mbuf *m;
d1140 1
a1140 4
getsock(fdp, fdes, fpp)
	struct filedesc *fdp;
	int fdes;
	struct file **fpp;
d1142 1
a1142 1
	register struct file *fp;
@


1.48
log
@- Rename FILE_{,UN}USE to FREF and FRELE. USE is a bad verb and we don't have
  the same semantics as NetBSD anyway, so it's good to avoid name collissions.
- Always fdremove before freeing the file, not the other way around.
- falloc FREFs the file.
- have FILE_SET_MATURE FRELE the file (It feels like a good ortogonality to
  falloc FREFing the file).
- Use closef as much as possible instead of ffree in error paths of
  falloc:ing functions. closef is much more careful with the fd and can
  deal with the fd being forcibly closed by dup2. Also try to avoid
  manually calling *fo_close when closef can do that for us (this makes
  some error paths mroe complicated (sys_socketpair and sys_pipe), but
  others become simpler (sys_open)).
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.47 2001/12/27 22:49:35 fgsch Exp $	*/
d432 1
a432 1
	if (msg.msg_iovlen <= 0 || msg.msg_iovlen > IOV_MAX)
d603 1
a603 1
	register int error;
d609 1
a609 1
	if (msg.msg_iovlen <= 0 || msg.msg_iovlen > IOV_MAX)
d621 6
a628 4
	error = copyin((caddr_t)uiov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
	if (error)
		goto done;
@


1.47
log
@makes a new accept() socket have the nonblock behavior.

slightly modified version from the original diff by theo, based
on comments by niels@@ and deraadt@@; both ok'ed.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.46 2001/12/02 18:07:32 provos Exp $	*/
d91 1
a91 1
		ffree(fp);
d251 1
a251 1
		ffree(fp);
d362 3
a364 3
	FILE_SET_MATURE(fp1);
	FILE_SET_MATURE(fp2);
	if (error == 0)
d366 1
a367 1
	ffree(fp2);
d369 2
a371 1
	ffree(fp1);
d373 2
d376 2
a377 1
	(void)soclose(so2);
d379 2
a380 1
	(void)soclose(so1);
@


1.46
log
@release the right descriptors when pipe fails; bug report from
marcodsl@@swbell.net
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.45 2001/11/28 13:49:08 provos Exp $	*/
d162 1
d209 3
d233 1
a233 1
	fp->f_flag = FREAD|FWRITE;
@


1.46.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.47 2001/12/27 22:49:35 fgsch Exp $	*/
a161 1
	int nflag;
a207 3
	/* Take note if socket was non-blocking. */
	nflag = (fp->f_flag & FNONBLOCK);

d229 1
a229 1
	fp->f_flag = FREAD | FWRITE | nflag;
@


1.46.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.46.2.1 2002/01/31 22:55:41 niklas Exp $	*/
d91 1
a91 1
		closef(fp, p);
a117 1
	FREF(fp);
d120 4
a123 5
	if (error == 0) {
		error = sobind((struct socket *)fp->f_data, nam);
		m_freem(nam);
	}
	FRELE(fp);
d143 1
a143 4
	FREF(fp);
	error = solisten((struct socket *)fp->f_data, SCARG(uap, backlog));
	FRELE(fp);
	return (error);
d152 1
a152 1
	struct sys_accept_args /* {
d157 1
a157 1
	struct file *fp, *headfp;
a168 2
	FREF(fp);
	headfp = fp;
d172 2
a173 2
		error = EINVAL;
		goto bad;
d176 2
a177 2
		error = EWOULDBLOCK;
		goto bad;
d187 2
a188 1
			goto bad;
d194 2
a195 1
		goto bad;
d224 2
a225 1
		goto bad;
d251 1
a251 3
		closef(fp, p);
	} else {
		FILE_SET_MATURE(fp);
a253 1
bad:
d255 1
a255 1
	FRELE(headfp);
d266 1
a266 1
	struct sys_connect_args /* {
d272 2
a273 2
	struct socket *so;
	struct mbuf *nam = NULL;
a280 1
	FREF(fp);
d284 1
a284 1
		goto bad;
a288 1
		FRELE(fp);
d306 1
a306 3
	FRELE(fp);
	if (nam)
		m_freem(nam);
d362 3
a364 3
	if (error == 0) {
		FILE_SET_MATURE(fp1);
		FILE_SET_MATURE(fp2);
a365 1
	}
d367 1
a368 2
	closef(fp2, p);
	so2 = NULL;
d370 1
a371 2
	closef(fp1, p);
	so1 = NULL;
d373 1
a373 2
	if (so2 != NULL)
		(void)soclose(so2);
d375 1
a375 2
	if (so1 != NULL)
		(void)soclose(so1);
d427 1
a427 1
	if (msg.msg_iovlen < 0 || msg.msg_iovlen > IOV_MAX)
d451 1
a451 1
	struct proc *p;
d453 1
a453 1
	struct msghdr *mp;
d459 2
a460 2
	struct iovec *iov;
	int i;
a482 1
	FREF(fp);
d486 1
a486 2
		if (error) {
			FRELE(fp);
a487 1
		}
a543 1
	FRELE(fp);
d598 1
a598 1
	int error;
d604 1
a604 1
	if (msg.msg_iovlen < 0 || msg.msg_iovlen > IOV_MAX)
a615 6
	if (msg.msg_iovlen > 0) {
		error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
		    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
		if (error)
			goto done;
	}
d618 4
d635 1
a635 1
	struct proc *p;
d637 1
a637 1
	struct msghdr *mp;
a667 1
	FREF(fp);
a775 1
	FRELE(fp);
d790 1
a790 1
	struct sys_shutdown_args /* {
d799 1
a799 4
	FREF(fp);
	error = soshutdown((struct socket *)fp->f_data, SCARG(uap, how));
	FRELE(fp);
	return (error);
d809 1
a809 1
	struct sys_setsockopt_args /* {
a823 1
	FREF(fp);
d829 2
a830 2
				error = ENOBUFS;
				goto bad;
d833 2
a834 4
		if (m == NULL) {
			error = ENOBUFS;
			goto bad;
		}
d838 2
a839 1
			goto bad;
d843 2
a844 8
	error = sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
			 SCARG(uap, name), m);
	m = NULL;
bad:
	if (m)
		m_freem(m);
	FRELE(fp);
	return (error);
d854 1
a854 1
	struct sys_getsockopt_args /* {
a867 1
	FREF(fp);
d872 1
a872 1
			goto out;
a884 2
out:
	FRELE(fp);
d923 1
a923 1
	struct sys_getsockname_args /* {
d929 2
a930 2
	struct socket *so;
	struct mbuf *m = NULL;
a935 1
	FREF(fp);
d938 1
a938 1
		goto bad;
d951 1
a951 3
	FRELE(fp);
	if (m)
		m_freem(m);
d965 1
a965 1
	struct sys_getpeername_args /* {
d972 1
a972 1
	struct mbuf *m = NULL;
a980 1
	FREF(fp);
d983 1
a983 1
		goto bad;
a994 1
	FRELE(fp);
d1009 1
a1009 1
	struct sys_getpeereid_args /* {
d1015 2
a1016 2
	struct socket *so;
	struct mbuf *m = NULL;
a1024 1
	FREF(fp);
d1026 2
a1027 4
	if (m == NULL) {
		error = ENOBUFS;
		goto bad;
	}	
a1039 1
	FRELE(fp);
d1051 2
a1052 2
	struct sockaddr *sa;
	struct mbuf *m;
d1093 4
a1096 1
getsock(struct filedesc *fdp, int fdes, struct file **fpp)
d1098 1
a1098 1
	struct file *fp;
@


1.46.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.46.2.2 2002/06/11 03:29:40 art Exp $	*/
d118 1
d145 1
d174 1
d286 1
a286 2
	if ((so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING)) {
		FRELE(fp);
d288 1
a288 1
	}
a482 2
	to = NULL;

d496 2
a497 4
		    (auio.uio_resid += iov->iov_len) > SSIZE_MAX) {
			error = EINVAL;
			goto bad;
		}
d499 1
d503 6
a508 3
		if (error)
			goto bad;
	}
d669 1
a669 1
	struct mbuf *from = NULL, *control = NULL;
d687 2
a688 4
		    (auio.uio_resid += iov->iov_len) > SSIZE_MAX) {
			error = EINVAL;
			goto out;
		}
d690 1
d823 1
d849 3
a851 4
	if (SCARG(uap, valsize) > MCLBYTES) {
		error = EINVAL;
		goto bad;
	}
d903 1
d974 1
d1020 1
a1020 2
	if ((so->so_state & (SS_ISCONNECTED|SS_ISCONFIRMING)) == 0) {
		FRELE(fp);
d1022 1
a1022 1
	}
d1066 1
a1066 2
	if (so->so_proto != pffindtype(AF_LOCAL, SOCK_STREAM)) {
		FRELE(fp);
d1068 1
a1068 1
	}
a1148 2
	FREF(fp);

@


1.45
log
@avoid "thundering herd" problem in accept by waking just one process.
based on freebsd.  okay art@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.44 2001/11/27 15:51:36 provos Exp $	*/
d887 1
a887 4
sys_pipe(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d903 2
a904 2
		fdrelease(p, retval[0]);
		fdrelease(p, retval[1]);
@


1.44
log
@change socket connection queues to use TAILQ_

from NetBSD:
Wed Jan  7 23:47:08 1998 UTC by thorpej

Make insertion and removal of sockets from the partial and incoming
connections queues O(C) rather than O(N).
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.43 2001/10/26 12:03:27 art Exp $	*/
d161 1
a161 1
	register struct socket *so;
d169 2
a170 2
	so = (struct socket *)fp->f_data;
	if ((so->so_options & SO_ACCEPTCONN) == 0) {
d174 1
a174 1
	if ((so->so_state & SS_NBIO) && so->so_qlen == 0) {
d178 3
a180 3
	while (so->so_qlen == 0 && so->so_error == 0) {
		if (so->so_state & SS_CANTRCVMORE) {
			so->so_error = ECONNABORTED;
d183 1
a183 1
		error = tsleep((caddr_t)&so->so_timeo, PSOCK | PCATCH,
d190 3
a192 3
	if (so->so_error) {
		error = so->so_error;
		so->so_error = 0;
d196 12
d209 11
d226 1
a226 7
	KNOTE(&so->so_rcv.sb_sel.si_note, 0);

	{ struct socket *aso = TAILQ_FIRST(&so->so_q);
	  if (soqremque(aso, 1) == 0)
		panic("accept");
	  so = aso;
	}
@


1.43
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.42 2001/09/20 17:02:31 mpech Exp $	*/
d205 1
a205 1
	{ struct socket *aso = so->so_q;
@


1.42
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.41 2001/09/17 19:37:59 jason Exp $	*/
d94 1
d234 1
d341 2
d1082 1
a1082 2
	if ((unsigned)fdes >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fdes]) == NULL)
@


1.42.2.1
log
@Pull in patch from current:
Fix (provos):
release the right descriptors when pipe fails; bug report from
marcodsl@@swbell.net
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.46 2001/12/02 18:07:32 provos Exp $	*/
d866 4
a869 1
sys_pipe(struct proc *p, void *v, register_t *retval)
d885 2
a886 2
		fdrelease(p, fds[0]);
		fdrelease(p, fds[1]);
@


1.41
log
@Don't treated return length of recvfrom() as a size_t... it's a socklen_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.40 2001/06/26 19:56:52 dugsong Exp $	*/
d226 1
a226 1
	/* if an error occured, free the file descriptor */
@


1.40
log
@implement djb's getpeereid(2), to allow local-domain servers to determine client credentials. mostly from superscript.com. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.39 2001/06/22 14:14:10 deraadt Exp $	*/
d672 4
a675 3
		len = mp->msg_namelen;
		if (len <= 0 || from == 0)
			len = 0;
d678 4
a681 3
			if (len > from->m_len)
				len = from->m_len;
			/* else if len < from->m_len ??? */
d688 1
a688 1
			    (caddr_t)mp->msg_name, (unsigned)len);
d692 1
a692 1
		mp->msg_namelen = len;
d694 1
a694 1
		    (error = copyout((caddr_t)&len, namelenp, sizeof (int)))) {
@


1.39
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.38 2001/05/16 12:52:58 ho Exp $	*/
d52 1
d970 45
@


1.38
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.37 2001/05/14 13:43:54 art Exp $	*/
d182 1
a182 1
			       netcon, 0);
d271 1
a271 1
			       netcon, 0);
d440 1
a440 1
	
d500 1
a500 1
		       NULL, control, flags);
d543 1
a543 2
			       (caddr_t)&msg.msg_namelen,
			       sizeof (msg.msg_namelen));
d556 1
a556 1
		       (caddr_t)SCARG(uap, fromlenaddr), retval));
d575 1
a575 1
		       sizeof (msg));
d593 1
a593 1
		       (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
d625 1
a625 1
	
d675 1
a675 1
		        /* save sa_len before it is destroyed by MSG_COMPAT */
d808 1
a808 1
			       SCARG(uap, valsize));
d842 1
a842 1
			       (caddr_t)&valsize, sizeof (valsize));
d876 1
a876 1
	
@


1.37
log
@gc OLD_PIPE.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.36 2001/02/19 18:21:30 art Exp $	*/
d482 4
a485 9
			if (control == 0) {
				error = ENOBUFS;
				goto bad;
			} else {
				cm = mtod(control, struct cmsghdr *);
				cm->cmsg_len = control->m_len;
				cm->cmsg_level = SOL_SOCKET;
				cm->cmsg_type = SCM_RIGHTS;
			}
a916 2
	if (m == NULL)
		return (ENOBUFS);
a960 2
	if (m == NULL)
		return (ENOBUFS);
@


1.36
log
@Indentation nit.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.35 2001/02/09 00:04:16 itojun Exp $	*/
a892 49

#ifdef OLD_PIPE

/* ARGSUSED */
int
sys_opipe(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct filedesc *fdp = p->p_fd;
	struct file *rf, *wf;
	struct socket *rso, *wso;
	int fd, error;

	if ((error = socreate(AF_UNIX, &rso, SOCK_STREAM, 0)) != 0)
		return (error);
	if ((error = socreate(AF_UNIX, &wso, SOCK_STREAM, 0)) != 0)
		goto free1;
	if ((error = falloc(p, &rf, &fd)) != 0)
		goto free2;
	retval[0] = fd;
	rf->f_flag = FREAD;
	rf->f_type = DTYPE_SOCKET;
	rf->f_ops = &socketops;
	rf->f_data = (caddr_t)rso;
	if ((error = falloc(p, &wf, &fd)) != 0)
		goto free3;
	wf->f_flag = FWRITE;
	wf->f_type = DTYPE_SOCKET;
	wf->f_ops = &socketops;
	wf->f_data = (caddr_t)wso;
	retval[1] = fd;
	if ((error = unp_connect2(wso, rso)) != 0)
		goto free4;
	return (0);
free4:
	ffree(wf);
	fdremove(fdp, retval[1]);
free3:
	ffree(rf);
	fdremove(fdp, retval[0]);
free2:
	(void)soclose(wso);
free1:
	(void)soclose(rso);
	return (error);
}
#endif
@


1.36.2.1
log
@Errata #19
Incorrect use of pipe(2) can panic the kernel.
Fix (niels):
Release the right descriptors when pipe fails; bug report from
marcodsl@@swbell.net
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.36 2001/02/19 18:21:30 art Exp $	*/
d869 4
a872 1
sys_pipe(struct proc *p, void *v, register_t *retval)
d888 2
a889 2
		fdrelease(p, fds[0]);
		fdrelease(p, fds[1]);
@


1.35
log
@return error from soaccept() upwards.  part of accept(2) fix against RST
right after handshake.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.34 2000/11/16 20:02:19 provos Exp $	*/
d404 1
a404 1
		iov = malloc( sizeof(struct iovec) * msg.msg_iovlen,
@


1.34
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.33 2000/11/10 18:15:48 art Exp $	*/
d214 2
a215 2
	(void) soaccept(so, nam);
	if (SCARG(uap, name)) {
d224 5
@


1.33
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.32 2000/10/12 09:58:05 itojun Exp $	*/
d46 1
d199 4
d208 1
@


1.32
log
@allow buflen > MLEN for !SO_NAME case (like ancillary data, necessary for
IPv6 advanced API).
sync with netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.31 2000/09/27 16:13:46 mickey Exp $	*/
d507 1
a507 2
			ktrgenio(p->p_tracep, s, UIO_WRITE,
				ktriov, *retsize, error);
d657 1
a657 1
			ktrgenio(p->p_tracep, s, UIO_READ,
@


1.31
log
@replace MALLOC/FREE w/ malloc/free for non-constant-sized memory allocations; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.30 2000/01/17 18:16:48 deraadt Exp $	*/
d1034 7
a1040 6
	if (buflen > MLEN) {
#ifdef COMPAT_OLDSOCK
		if (type == MT_SONAME && buflen <= 112)
			buflen = MLEN;		/* unix domain compat. hack */
		else
#endif
d1042 9
a1051 3
	m = m_get(M_WAIT, type);
	if (m == NULL)
		return (ENOBUFS);
@


1.30
log
@oops, another syscall pipe() botch; karls@@inet.no
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.29 1999/12/08 06:50:17 itojun Exp $	*/
d393 2
a394 2
		MALLOC(iov, struct iovec *,
		       sizeof(struct iovec) * msg.msg_iovlen, M_IOV, M_WAITOK);
d408 1
a408 1
		FREE(iov, M_IOV);
d488 1
a488 1
		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
d509 1
a509 1
		FREE(ktriov, M_TEMP);
d577 2
a578 2
		MALLOC(iov, struct iovec *,
		       sizeof(struct iovec) * msg.msg_iovlen, M_IOV, M_WAITOK);
d599 1
a599 1
		FREE(iov, M_IOV);
d642 1
a642 1
		MALLOC(ktriov, struct iovec *, iovlen, M_TEMP, M_WAITOK);
d660 1
a660 1
		FREE(ktriov, M_TEMP);
@


1.30.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.36 2001/02/19 18:21:30 art Exp $	*/
a45 1
#include <sys/event.h>
a197 4

	/* connection has been removed from the listen queue */
	KNOTE(&so->so_rcv.sb_sel.si_note, 0);

a202 1

d208 2
a209 2
	error = soaccept(so, nam);
	if (!error && SCARG(uap, name)) {
a218 5
	/* if an error occured, free the file descriptor */
	if (error) {
		fdremove(p->p_fd, tmpfd);
		ffree(fp);
	}
d393 2
a394 2
		iov = malloc(sizeof(struct iovec) * msg.msg_iovlen,
		    M_IOV, M_WAITOK);
d408 1
a408 1
		free(iov, M_IOV);
d488 1
a488 1
		ktriov = malloc(iovlen, M_TEMP, M_WAITOK);
d507 3
a509 2
			ktrgenio(p, s, UIO_WRITE, ktriov, *retsize, error);
		free(ktriov, M_TEMP);
d577 2
a578 2
		iov = malloc(sizeof(struct iovec) * msg.msg_iovlen,
		    M_IOV, M_WAITOK);
d599 1
a599 1
		free(iov, M_IOV);
d642 1
a642 1
		ktriov = malloc(iovlen, M_TEMP, M_WAITOK);
d658 1
a658 1
			ktrgenio(p, s, UIO_READ,
d660 1
a660 1
		free(ktriov, M_TEMP);
d1034 6
a1039 5
	/*
	 * We can't allow socket names > UCHAR_MAX in length, since that
	 * will overflow sa_len.
	 */
	if (type == MT_SONAME && (u_int)buflen > UCHAR_MAX)
d1041 1
a1041 4
	if ((u_int)buflen > MCLBYTES)
		return (EINVAL);

	/* Allocate an mbuf to hold the arguments. */
d1043 2
a1044 7
	if ((u_int)buflen > MLEN) {
		MCLGET(m, M_WAITOK);
		if ((m->m_flags & M_EXT) == 0) {
			m_free(m);
			return ENOBUFS;
		}
	}
@


1.30.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.30.2.1 2001/05/14 22:32:45 niklas Exp $	*/
a51 1
#include <sys/unpcb.h>
d182 1
a182 1
		    netcon, 0);
d271 1
a271 1
		    netcon, 0);
d440 1
a440 1

d482 9
a490 4
			cm = mtod(control, struct cmsghdr *);
			cm->cmsg_len = control->m_len;
			cm->cmsg_level = SOL_SOCKET;
			cm->cmsg_type = SCM_RIGHTS;
d505 1
a505 1
	    NULL, control, flags);
d548 2
a549 1
		    (caddr_t)&msg.msg_namelen, sizeof (msg.msg_namelen));
d562 1
a562 1
	    (caddr_t)SCARG(uap, fromlenaddr), retval));
d581 1
a581 1
	    sizeof (msg));
d599 1
a599 1
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
d631 1
a631 1

d681 1
a681 1
			/* save sa_len before it is destroyed by MSG_COMPAT */
d814 1
a814 1
		    SCARG(uap, valsize));
d848 1
a848 1
		    (caddr_t)&valsize, sizeof (valsize));
d882 1
a882 1

d894 49
d971 2
d1017 2
a1027 45
bad:
	m_freem(m);
	return (error);
}

/*
 * Get eid of peer for connected socket.
 */
/* ARGSUSED */
int
sys_getpeereid(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sys_getpeereid_args /* {
		syscallarg(int) fdes;
		syscallarg(uid_t *) euid;
		syscallarg(gid_t *) egid;
	} */ *uap = v;
	struct file *fp;
	register struct socket *so;
	struct mbuf *m;
	struct unpcbid *id;
	int error;

	if ((error = getsock(p->p_fd, SCARG(uap, fdes), &fp)) != 0)
		return (error);
	so = (struct socket *)fp->f_data;
	if (so->so_proto != pffindtype(AF_LOCAL, SOCK_STREAM))
		return (EOPNOTSUPP);
	m = m_getclr(M_WAIT, MT_SONAME);
	if (m == NULL)
		return (ENOBUFS);
	error = (*so->so_proto->pr_usrreq)(so, PRU_PEEREID, 0, m, 0);
	if (!error && m->m_len != sizeof(struct unpcbid))
		error = EOPNOTSUPP;
	if (error)
		goto bad;
	id = mtod(m, struct unpcbid *);
	error = copyout((caddr_t)&(id->unp_euid),
		(caddr_t)SCARG(uap, euid), sizeof(uid_t));
	if (error == 0)
		error = copyout((caddr_t)&(id->unp_egid),
		    (caddr_t)SCARG(uap, egid), sizeof(gid_t));
@


1.30.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.30.2.2 2001/07/04 10:48:46 niklas Exp $	*/
a93 1
		FILE_SET_MATURE(fp);
d226 1
a226 1
	/* if an error occurred, free the file descriptor */
a232 1
	FILE_SET_MATURE(fp);
a338 2
	FILE_SET_MATURE(fp1);
	FILE_SET_MATURE(fp2);
d672 3
a674 4
		socklen_t alen;

		if (from == 0)
			alen = 0;
d677 3
a679 4
			alen = mp->msg_namelen;
			if (alen > from->m_len)
				alen = from->m_len;
			/* else if alen < from->m_len ??? */
d686 1
a686 1
			    (caddr_t)mp->msg_name, alen);
d690 1
a690 1
		mp->msg_namelen = alen;
d692 1
a692 1
		    (error = copyout((caddr_t)&alen, namelenp, sizeof(alen)))) {
d1076 2
a1077 1
	if ((fp = fd_getfile(fdp, fdes)) == NULL)
@


1.30.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d161 1
a161 1
	struct socket *head, *so;
d169 2
a170 2
	head = (struct socket *)fp->f_data;
	if ((head->so_options & SO_ACCEPTCONN) == 0) {
d174 1
a174 1
	if ((head->so_state & SS_NBIO) && head->so_qlen == 0) {
d178 3
a180 3
	while (head->so_qlen == 0 && head->so_error == 0) {
		if (head->so_state & SS_CANTRCVMORE) {
			head->so_error = ECONNABORTED;
d183 1
a183 1
		error = tsleep((caddr_t)&head->so_timeo, PSOCK | PCATCH,
d190 3
a192 3
	if (head->so_error) {
		error = head->so_error;
		head->so_error = 0;
a195 12
	
	/*
	 * At this point we know that there is at least one connection
	 * ready to be accepted. Remove it from the queue prior to
	 * allocating the file descriptor for it since falloc() may
	 * block allowing another process to accept the connection
	 * instead.
	 */
	so = TAILQ_FIRST(&head->so_q);
	if (soqremque(so, 1) == 0)
		panic("accept");

a196 11
		/*
		 * Probably ran out of file descriptors. Put the
		 * unaccepted connection back onto the queue and
		 * do another wakeup so some other process might
		 * have a chance at it.
		 */
		so->so_head = head;
		head->so_qlen++;
		so->so_onq = &head->so_q;
		TAILQ_INSERT_HEAD(so->so_onq, so, so_qe);
		wakeup_one(&head->so_timeo);
d203 7
a209 1
	KNOTE(&head->so_rcv.sb_sel.si_note, 0);
d870 4
a873 1
sys_pipe(struct proc *p, void *v, register_t *retval)
d889 2
a890 2
		fdrelease(p, fds[0]);
		fdrelease(p, fds[1]);
@


1.30.2.5
log
@Merge in trunk
@
text
@d91 1
a91 1
		closef(fp, p);
a117 1
	FREF(fp);
d120 4
a123 5
	if (error == 0) {
		error = sobind((struct socket *)fp->f_data, nam);
		m_freem(nam);
	}
	FRELE(fp);
d143 1
a143 4
	FREF(fp);
	error = solisten((struct socket *)fp->f_data, SCARG(uap, backlog));
	FRELE(fp);
	return (error);
d152 1
a152 1
	struct sys_accept_args /* {
d157 1
a157 1
	struct file *fp, *headfp;
a161 1
	int nflag;
a167 2
	FREF(fp);
	headfp = fp;
d171 2
a172 2
		error = EINVAL;
		goto bad;
d175 2
a176 2
		error = EWOULDBLOCK;
		goto bad;
d186 2
a187 1
			goto bad;
d193 2
a194 1
		goto bad;
a207 3
	/* Take note if socket was non-blocking. */
	nflag = (fp->f_flag & FNONBLOCK);

d220 2
a221 1
		goto bad;
d229 1
a229 1
	fp->f_flag = FREAD | FWRITE | nflag;
d247 1
a247 1
		closef(fp, p);
d250 1
a251 3
bad:
	splx(s);
	FRELE(headfp);
d262 1
a262 1
	struct sys_connect_args /* {
d268 2
a269 2
	struct socket *so;
	struct mbuf *nam = NULL;
a276 1
	FREF(fp);
d280 1
a280 1
		goto bad;
a284 1
		FRELE(fp);
d302 1
a302 3
	FRELE(fp);
	if (nam)
		m_freem(nam);
d358 3
a360 3
	if (error == 0) {
		FILE_SET_MATURE(fp1);
		FILE_SET_MATURE(fp2);
a361 1
	}
d363 1
a364 2
	closef(fp2, p);
	so2 = NULL;
d366 1
a367 2
	closef(fp1, p);
	so1 = NULL;
d369 1
a369 2
	if (so2 != NULL)
		(void)soclose(so2);
d371 1
a371 2
	if (so1 != NULL)
		(void)soclose(so1);
d423 1
a423 1
	if (msg.msg_iovlen < 0 || msg.msg_iovlen > IOV_MAX)
d447 1
a447 1
	struct proc *p;
d449 1
a449 1
	struct msghdr *mp;
d455 2
a456 2
	struct iovec *iov;
	int i;
a478 1
	FREF(fp);
d482 1
a482 2
		if (error) {
			FRELE(fp);
a483 1
		}
a539 1
	FRELE(fp);
d594 1
a594 1
	int error;
d600 1
a600 1
	if (msg.msg_iovlen < 0 || msg.msg_iovlen > IOV_MAX)
a611 6
	if (msg.msg_iovlen > 0) {
		error = copyin((caddr_t)msg.msg_iov, (caddr_t)iov,
		    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)));
		if (error)
			goto done;
	}
d614 4
d631 1
a631 1
	struct proc *p;
d633 1
a633 1
	struct msghdr *mp;
a663 1
	FREF(fp);
a771 1
	FRELE(fp);
d786 1
a786 1
	struct sys_shutdown_args /* {
d795 1
a795 4
	FREF(fp);
	error = soshutdown((struct socket *)fp->f_data, SCARG(uap, how));
	FRELE(fp);
	return (error);
d805 1
a805 1
	struct sys_setsockopt_args /* {
a819 1
	FREF(fp);
d825 2
a826 2
				error = ENOBUFS;
				goto bad;
d829 2
a830 4
		if (m == NULL) {
			error = ENOBUFS;
			goto bad;
		}
d834 2
a835 1
			goto bad;
d839 2
a840 8
	error = sosetopt((struct socket *)fp->f_data, SCARG(uap, level),
			 SCARG(uap, name), m);
	m = NULL;
bad:
	if (m)
		m_freem(m);
	FRELE(fp);
	return (error);
d850 1
a850 1
	struct sys_getsockopt_args /* {
a863 1
	FREF(fp);
d868 1
a868 1
			goto out;
a880 2
out:
	FRELE(fp);
d919 1
a919 1
	struct sys_getsockname_args /* {
d925 2
a926 2
	struct socket *so;
	struct mbuf *m = NULL;
a931 1
	FREF(fp);
d934 1
a934 1
		goto bad;
d947 1
a947 3
	FRELE(fp);
	if (m)
		m_freem(m);
d961 1
a961 1
	struct sys_getpeername_args /* {
d968 1
a968 1
	struct mbuf *m = NULL;
a976 1
	FREF(fp);
d979 1
a979 1
		goto bad;
a990 1
	FRELE(fp);
d1005 1
a1005 1
	struct sys_getpeereid_args /* {
d1011 2
a1012 2
	struct socket *so;
	struct mbuf *m = NULL;
a1020 1
	FREF(fp);
d1022 2
a1023 4
	if (m == NULL) {
		error = ENOBUFS;
		goto bad;
	}	
a1035 1
	FRELE(fp);
d1047 2
a1048 2
	struct sockaddr *sa;
	struct mbuf *m;
d1089 4
a1092 1
getsock(struct filedesc *fdp, int fdes, struct file **fpp)
d1094 1
a1094 1
	struct file *fp;
@


1.30.2.6
log
@Sync the SMP branch with 3.3
@
text
@d118 1
d145 1
d174 1
a255 2
	} else {
		FILE_SET_MATURE(fp);
d258 1
d285 1
a285 2
	if ((so->so_state & SS_NBIO) && (so->so_state & SS_ISCONNECTING)) {
		FRELE(fp);
d287 1
a287 1
	}
a481 2
	to = NULL;

d495 2
a496 4
		    (auio.uio_resid += iov->iov_len) > SSIZE_MAX) {
			error = EINVAL;
			goto bad;
		}
d498 1
d502 6
a507 3
		if (error)
			goto bad;
	}
d668 1
a668 1
	struct mbuf *from = NULL, *control = NULL;
d686 2
a687 4
		    (auio.uio_resid += iov->iov_len) > SSIZE_MAX) {
			error = EINVAL;
			goto out;
		}
d689 1
d822 1
d848 3
a850 4
	if (SCARG(uap, valsize) > MCLBYTES) {
		error = EINVAL;
		goto bad;
	}
d902 1
d973 1
d1019 1
a1019 2
	if ((so->so_state & (SS_ISCONNECTED|SS_ISCONFIRMING)) == 0) {
		FRELE(fp);
d1021 1
a1021 1
	}
d1065 1
a1065 2
	if (so->so_proto != pffindtype(AF_LOCAL, SOCK_STREAM)) {
		FRELE(fp);
d1067 1
a1067 1
	}
a1147 2
	FREF(fp);

@


1.30.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.30.2.6 2003/03/28 00:41:27 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.30.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a77 2
	fdplock(fdp, p);

d79 1
a79 1
		goto out;
d89 1
a89 1
		fp->f_data = so;
a92 2
out:
	fdpunlock(fdp);
d105 1
a105 1
		syscallarg(const struct sockaddr *) name;
d163 2
a164 2
	if (SCARG(uap, name) && (error = copyin(SCARG(uap, anamelen),
	    &namelen, sizeof (namelen))))
d184 2
a185 1
		error = tsleep(&head->so_timeo, PSOCK | PCATCH, netcon, 0);
a209 1
	fdplock(p->p_fd, p);
d232 1
a232 1
	fp->f_data = so;
d240 3
a242 2
		    SCARG(uap, name), namelen)) == 0)
			error = copyout(&namelen, SCARG(uap, anamelen),
a253 1
	fdpunlock(p->p_fd);
d268 1
a268 1
		syscallarg(const struct sockaddr *) name;
d297 1
a297 1
		error = tsleep(&so->so_timeo, PSOCK | PCATCH,
a341 2

	fdplock(fdp, p);
d348 1
a348 1
	fp1->f_data = so1;
d354 1
a354 1
	fp2->f_data = so2;
d365 2
a366 1
	error = copyout(sv, SCARG(uap, rsv), 2 * sizeof (int));
d370 1
a370 2
		fdpunlock(fdp);
		return (0);
a382 1
	fdpunlock(fdp);
d397 1
a397 1
		syscallarg(const void *) buf;
d400 1
a400 1
		syscallarg(const struct sockaddr *) to;
d427 1
a427 1
		syscallarg(const struct msghdr *) msg;
d434 1
a434 1
	error = copyin(SCARG(uap, msg), &msg, sizeof (msg));
d445 2
a446 2
	    (error = copyin(msg.msg_iov, iov,
		    (unsigned)(msg.msg_iovlen * sizeof (struct iovec)))))
d534 1
a534 1
		bcopy(auio.uio_iov, ktriov, iovlen);
d571 1
a571 1
		syscallarg(void *) buf;
d582 2
a583 2
		error = copyin(SCARG(uap, fromlenaddr),
		    &msg.msg_namelen, sizeof (msg.msg_namelen));
d614 2
a615 1
	error = copyin(SCARG(uap, msg), &msg, sizeof (msg));
d631 1
a631 1
		error = copyin(msg.msg_iov, iov,
d638 1
a638 1
	if ((error = recvit(p, SCARG(uap, s), &msg, NULL, retval)) == 0) {
d640 2
a641 1
		error = copyout(&msg, SCARG(uap, msg), sizeof(msg));
d691 1
a691 1
		bcopy(auio.uio_iov, ktriov, iovlen);
d731 1
a731 1
			    mp->msg_name, alen);
d737 1
a737 1
		    (error = copyout(&alen, namelenp, sizeof(alen)))) {
d834 1
a834 1
		syscallarg(const void *) val;
d888 1
a888 1
		syscallarg(void *) val;
a938 1
		fdplock(p->p_fd, p);
a940 1
		fdpunlock(p->p_fd);
d957 1
a957 1
		syscallarg(struct sockaddr *) asa;
d1001 1
a1001 1
		syscallarg(struct sockaddr *) asa;
@


1.30.2.9
log
@Merge with the trunk
@
text
@d118 1
a118 1
	error = sockargs(&nam, SCARG(uap, name), SCARG(uap, namelen),
d287 1
a287 1
	error = sockargs(&nam, SCARG(uap, name), SCARG(uap, namelen),
d722 1
a722 1
		if (from == NULL)
d773 1
a773 1
		if (len <= 0 || control == NULL)
d1094 5
a1098 1
sockargs(struct mbuf **mp, const void *buf, size_t buflen, int type)
d1106 1
a1106 2
	 * will overflow sa_len. Also, control data more than MCLBYTES in
	 * length is just too much.
d1108 3
a1110 1
	if (buflen > (type == MT_SONAME ? UCHAR_MAX : MCLBYTES))
d1131 1
@


1.29
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.28 1999/07/13 15:17:51 provos Exp $	*/
d870 1
a870 1
	if ((error = sys_opipe(p, v, rval)) == -1)
@


1.28
log
@introduce fdremove() to mark a file descriptor as unused. fdremove makes
sure that the fd_freefile hints stay in sync, otherwise free file
descriptors might not be overlooked by fdalloc(); ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.27 1999/06/15 17:46:32 deraadt Exp $	*/
d721 19
a739 6
			if (len >= control->m_len)
				len = control->m_len;
			else
				mp->msg_flags |= MSG_CTRUNC;
			error = copyout((caddr_t)mtod(control, caddr_t),
			    (caddr_t)mp->msg_control, (unsigned)len);
d790 1
a790 1
	if (SCARG(uap, valsize) > MLEN)
d794 7
@


1.27
log
@do not mangle retval, makes return value sane; problem found by millert
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.26 1999/06/11 18:10:24 provos Exp $	*/
d88 1
a88 1
		fdp->fd_ofiles[fd] = NULL;
d331 1
a331 1
	fdp->fd_ofiles[sv[1]] = NULL;
d334 1
a334 1
	fdp->fd_ofiles[sv[0]] = NULL;
d901 1
a901 1
	fdp->fd_ofiles[retval[1]] = NULL;
d904 1
a904 1
	fdp->fd_ofiles[retval[0]] = NULL;
@


1.26
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.25 1999/06/08 17:13:08 deraadt Exp $	*/
d847 2
a848 2
	int error;
	int fds[2];
d850 1
a850 1
	if ((error = sys_opipe(p, v, retval)) == -1)
d853 2
a854 2
	fds[0] = retval[0];
	fds[1] = retval[1];
@


1.25
log
@copy int sized objects, not register_t sized objects in pipe()
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.24 1999/06/08 16:05:22 deraadt Exp $	*/
d854 1
a854 1
	fds[1] = retval[0];
@


1.24
log
@better fd leak prevention
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.23 1999/06/07 20:46:09 deraadt Exp $	*/
d848 1
d853 3
a855 1
	error = copyout((caddr_t)retval, (caddr_t)SCARG(uap, fdp),
@


1.23
log
@need seperate sys_pipe() versions, for pipeclose() or soclose() calls
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.22 1999/06/07 07:17:42 deraadt Exp $	*/
a837 3

#ifdef OLD_PIPE

a843 1
	register struct filedesc *fdp = p->p_fd;
d855 2
a856 6
		soclose((struct socket *)(fdp->fd_ofiles[retval[0]]->f_data));
		ffree(fdp->fd_ofiles[retval[0]]);
		fdp->fd_ofiles[retval[0]] = NULL;
		soclose((struct socket *)(fdp->fd_ofiles[retval[1]]->f_data));
		ffree(fdp->fd_ofiles[retval[1]]);
		fdp->fd_ofiles[retval[1]] = NULL;
d860 2
@


1.22
log
@replacement pipe() system call; copies data into place inside kernel, so
that EFAULT return value is possible
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.19 1999/02/15 21:28:23 millert Exp $	*/
d838 3
d859 1
d862 1
a868 1
#ifdef OLD_PIPE
@


1.21
log
@do not leak file descriptors if copyout() fails
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.20 1999/06/07 01:38:44 deraadt Exp $	*/
d838 26
d867 1
a867 1
sys_pipe(p, v, retval)
@


1.20
log
@store NULL in fd_ofiles
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.19 1999/02/15 21:28:23 millert Exp $	*/
d327 2
a328 1
	return (error);
@


1.19
log
@sendto(2) takes a socklen_t as well
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.18 1999/02/15 20:00:50 millert Exp $	*/
d88 1
a88 1
		fdp->fd_ofiles[fd] = 0;
d330 1
a330 1
	fdp->fd_ofiles[sv[1]] = 0;
d333 1
a333 1
	fdp->fd_ofiles[sv[0]] = 0;
d873 1
a873 1
	fdp->fd_ofiles[retval[1]] = 0;
d876 1
a876 1
	fdp->fd_ofiles[retval[0]] = 0;
@


1.18
log
@use socklen_t
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.17 1999/02/14 21:11:01 millert Exp $	*/
d353 1
a353 1
		syscallarg(int) tolen;
@


1.17
log
@Use IOV_MAX, not the deprecated UIO_MAXIOV
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.16 1999/02/14 19:24:05 millert Exp $	*/
d107 1
a107 1
		syscallarg(int) namelen;
d152 1
a152 1
		syscallarg(int *) anamelen;
d156 2
a157 1
	int namelen, error, s, tmpfd;
d160 3
a162 7
	if (SCARG(uap, name)) {
		if ((error = copyin((caddr_t)SCARG(uap, anamelen),
		    (caddr_t)&namelen, sizeof (namelen))))
			return (error);
		if (namelen < 0)
			return (EFAULT);
	}
d214 1
a214 1
		    (caddr_t)SCARG(uap, name), (u_int)namelen)) == 0)
d234 1
a234 1
		syscallarg(int) namelen;
d529 1
a529 1
		syscallarg(int *) fromlenaddr;
d614 2
a615 1
	int len, error;
d768 1
a768 1
		syscallarg(int) valsize;
d783 1
a783 1
			       (u_int)SCARG(uap, valsize));
d806 1
a806 1
		syscallarg(int *) avalsize;
d810 2
a811 1
	int valsize, error;
a821 2
	if (valsize < 0)
		return (EFAULT);
d827 1
a827 2
		error = copyout(mtod(m, caddr_t), SCARG(uap, val),
		    (u_int)valsize);
d898 1
a898 1
		syscallarg(int *) alen;
d903 2
a904 1
	int len, error;
a910 2
	if (len < 0)
		return (EFAULT);
d920 1
a920 1
	error = copyout(mtod(m, caddr_t), (caddr_t)SCARG(uap, asa), (u_int)len);
d942 1
a942 1
		syscallarg(int *) alen;
d947 2
a948 1
	int len, error;
a957 2
	if (len < 0)
		return (EFAULT);
d966 1
a966 1
	error = copyout(mtod(m, caddr_t), (caddr_t)SCARG(uap, asa), (u_int)len);
d979 2
a980 1
	int buflen, type;
d986 1
a986 1
	if ((u_int)buflen > MLEN) {
d988 1
a988 1
		if (type == MT_SONAME && (u_int)buflen <= 112)
d998 1
a998 1
	error = copyin(buf, mtod(m, caddr_t), (u_int)buflen);
@


1.16
log
@Don't do range checking on namelen unless name is non-NULL, otherwise
namelen is uninitialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.15 1999/02/14 19:02:20 millert Exp $	*/
d392 1
a392 1
	if (msg.msg_iovlen <= 0 || msg.msg_iovlen > UIO_MAXIOV)
d576 1
a576 1
	if (msg.msg_iovlen <= 0 || msg.msg_iovlen > UIO_MAXIOV)
@


1.15
log
@readv/writev with iov_len == 0 is legal (was already ok in uipc_syscalls.c).
Make the check more readable by comparing against SSIZE_MAX instead
of checking for wraparound.  This is safe because SSIZE_MAX * 2 <=
SIZE_T_MAX.  Fixes recno problems in the db routines exposed by a
perl test.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.14 1999/02/11 05:33:09 deraadt Exp $	*/
d159 7
a165 5
	if (SCARG(uap, name) && (error = copyin((caddr_t)SCARG(uap, anamelen),
	    (caddr_t)&namelen, sizeof (namelen))))
		return (error);
	if (namelen < 0)
		return (EFAULT);
@


1.14
log
@avoid insane lengths for various syscalls
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.13 1998/09/14 23:35:01 provos Exp $	*/
d442 2
a443 2
		if ((ssize_t)(auio.uio_resid += iov->iov_len) <= 0 &&
		    (iov->iov_base != 0 || iov->iov_len != 0))
d633 2
a634 2
		if ((ssize_t)(auio.uio_resid += iov->iov_len) <= 0 &&
		    (iov->iov_base != 0 || iov->iov_len != 0))
@


1.13
log
@allow the recvfrom (fd, NULL, 0, MSG_PEEK, ...) again, pr 584.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.12 1998/08/05 16:35:44 millert Exp $	*/
d162 2
d680 1
a680 1
					(caddr_t)mp->msg_name, (unsigned)len);
d821 2
d912 2
d960 2
d971 3
a973 3
	if (error)
		goto bad;
	error = copyout((caddr_t)&len, (caddr_t)SCARG(uap, alen), sizeof (len));
@


1.12
log
@return EMSGSIZE, not EINVAL is msg_iovlen <= 0 as per XPG 4.2
When comparing against UIO_SMALLIOV/UIO_MAXIOV check for >, not >=
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.11 1998/08/05 16:05:18 millert Exp $	*/
d440 2
a441 1
		if ((ssize_t)(auio.uio_resid += iov->iov_len) <= 0)
d631 2
a632 1
		if ((ssize_t)(auio.uio_resid += iov->iov_len) <= 0)
@


1.11
log
@delete bogus casts of msg_iovlen to u_int since msg_iovlen is already a u_int
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.10 1998/07/28 19:47:08 millert Exp $	*/
d388 3
a390 5
	if (msg.msg_iovlen <= 0)
		return (EINVAL);
	if (msg.msg_iovlen >= UIO_SMALLIOV) {
		if (msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
d393 1
a393 1
	} else
d571 3
a573 5
	if (msg.msg_iovlen <= 0)
		return (EINVAL);
	if (msg.msg_iovlen >= UIO_SMALLIOV) {
		if (msg.msg_iovlen >= UIO_MAXIOV)
			return (EMSGSIZE);
d576 1
a576 1
	} else
@


1.10
log
@For read, write, send, sendto, recv, recvfrom return EINVAL is size arg > SSIZE_MAX.  For readv, writev, sendmsg, recvmsg return EINVAL if sum of the  over iov_len values overflows an ssize_t.  Based on what XPG 4.2 says (though XPG is not entirely consistent here).  Basically since the return value is ssize_t allowing size > SSIZE_MAX is bad since people who (incorrectly mind you) check the return value for < 0 instead of == -1 will have bad things happen to them.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.9 1998/07/28 04:29:45 millert Exp $	*/
d390 2
a391 2
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
d394 1
a394 2
		       sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		       M_WAITOK);
d575 2
a576 2
	if ((u_int)msg.msg_iovlen >= UIO_SMALLIOV) {
		if ((u_int)msg.msg_iovlen >= UIO_MAXIOV)
d579 1
a579 2
		       sizeof(struct iovec) * (u_int)msg.msg_iovlen, M_IOV,
		       M_WAITOK);
@


1.9
log
@Don't assume uio_resid can go negative when detecting oflow
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.8 1998/07/28 00:12:56 millert Exp $	*/
d442 2
a443 1
		if (auio.uio_resid + iov->iov_len < auio.uio_resid)
a444 1
		auio.uio_resid += iov->iov_len;
d635 2
a636 1
		if (auio.uio_resid + iov->iov_len < auio.uio_resid)
a637 1
		auio.uio_resid += iov->iov_len;
@


1.8
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.7 1998/02/08 22:41:36 tholo Exp $	*/
d442 1
a442 1
		if ((auio.uio_resid += iov->iov_len) < 0)
d444 1
d635 1
a635 1
		if ((auio.uio_resid += iov->iov_len) < 0)
d637 1
@


1.7
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.6 1997/12/16 22:59:12 provos Exp $	*/
d388 2
d573 2
@


1.6
log
@evaluate length before doing compat stuff which might overwrite the
length field we are going to evaluate. From FreeBSD, originally submitted
by: pb@@fasterix.freenix.org (Pierre Beyssac)
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.5 1997/06/05 03:20:47 deraadt Exp $	*/
d106 1
a106 1
		syscallarg(caddr_t) name;
d115 1
a115 1
	error = sockargs(&nam, SCARG(uap, name), SCARG(uap, namelen),
d151 1
a151 1
		syscallarg(caddr_t) name;
d232 1
a232 1
		syscallarg(caddr_t) name;
d245 1
a245 1
	error = sockargs(&nam, SCARG(uap, name), SCARG(uap, namelen),
d351 1
a351 1
		syscallarg(caddr_t) to;
d357 1
a357 1
	msg.msg_name = SCARG(uap, to);
d365 1
a365 1
	aiov.iov_base = SCARG(uap, buf);
d526 1
a526 1
		syscallarg(caddr_t) from;
d541 1
a541 1
	msg.msg_name = SCARG(uap, from);
@


1.5
log
@delete cannot happen code
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.4 1996/08/27 14:47:01 shawn Exp $	*/
d666 4
a674 3
			if (len > from->m_len)
				len = from->m_len;
			/* else if len < from->m_len ??? */
@


1.4
log
@New fast pipe(2) from freebsd without fancy vm stuff.

The old pipes can be used with the "OLD_PIPE" config option.
@
text
@d1 1
a1 1
/*	$OpenBSD: uipc_syscalls.c,v 1.3 1996/05/18 01:46:56 deraadt Exp $	*/
a439 5
#if 0
		/* cannot happen; iov_len is unsigned */
		if (iov->iov_len < 0)
			return (EINVAL);
#endif
a629 5
#if 0
		/* cannot happen iov_len is unsigned */
		if (iov->iov_len < 0)
			return (EINVAL);
#endif
@


1.3
log
@socketpair() is not a hack in libc like pipe()
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d842 1
d888 1
@


1.2
log
@From NetBSD: 960217 merge
@
text
@a325 2
	retval[0] = sv[0];		/* XXX ??? */
	retval[1] = sv[1];		/* XXX ??? */
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: uipc_syscalls.c,v 1.17 1995/10/10 01:27:05 mycroft Exp $	*/
d50 2
a61 6
#if defined(COMPAT_43) || defined(COMPAT_SUNOS) || defined(COMPAT_LINUX) || \
    defined(COMPAT_HPUX) || defined(COMPAT_FREEBSD)
#define COMPAT_OLDSOCK
#define MSG_COMPAT	0x8000
#endif

d80 1
a80 1
	if (error = falloc(p, &fp, &fd))
d85 3
a87 2
	if (error = socreate(SCARG(uap, domain), &so, SCARG(uap, type),
	    SCARG(uap, protocol))) {
d113 1
a113 1
	if (error = getsock(p->p_fd, SCARG(uap, s), &fp))
d115 3
a117 2
	if (error = sockargs(&nam, SCARG(uap, name), SCARG(uap, namelen),
	    MT_SONAME))
d138 1
a138 1
	if (error = getsock(p->p_fd, SCARG(uap, s), &fp))
d162 1
a162 1
	if (error = getsock(p->p_fd, SCARG(uap, s), &fp))
d179 3
a181 2
		if (error = tsleep((caddr_t)&so->so_timeo, PSOCK | PCATCH,
		    netcon, 0)) {
d192 1
a192 1
	if (error = falloc(p, &fp, &tmpfd)) {
d240 1
a240 1
	if (error = getsock(p->p_fd, SCARG(uap, s), &fp))
d245 3
a247 2
	if (error = sockargs(&nam, SCARG(uap, name), SCARG(uap, namelen),
	    MT_SONAME))
d257 4
a260 3
	while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0)
		if (error = tsleep((caddr_t)&so->so_timeo, PSOCK | PCATCH,
		    netcon, 0))
d262 1
d293 3
a295 2
	if (error = socreate(SCARG(uap, domain), &so1, SCARG(uap, type),
	    SCARG(uap, protocol)))
d297 3
a299 2
	if (error = socreate(SCARG(uap, domain), &so2, SCARG(uap, type),
	    SCARG(uap, protocol)))
d301 1
a301 1
	if (error = falloc(p, &fp1, &fd))
d308 1
a308 1
	if (error = falloc(p, &fp2, &fd))
d315 1
a315 1
	if (error = soconnect2(so1, so2))
d321 1
a321 1
		 if (error = soconnect2(so2, so1))
d387 2
a388 1
	if (error = copyin(SCARG(uap, msg), (caddr_t)&msg, sizeof (msg)))
d431 1
a431 1
	if (error = getsock(p->p_fd, s, &fp))
d442 2
d446 1
d451 3
a453 2
		if (error = sockargs(&to, mp->msg_name, mp->msg_namelen,
		    MT_SONAME))
d466 3
a468 2
		if (error = sockargs(&control, mp->msg_control,
		    mp->msg_controllen, MT_CONTROL))
d497 3
a499 2
	if (error = sosend((struct socket *)fp->f_data, to, &auio,
	    (struct mbuf *)0, control, flags)) {
d541 4
a544 2
		if (error = copyin((caddr_t)SCARG(uap, fromlenaddr),
		    (caddr_t)&msg.msg_namelen, sizeof (msg.msg_namelen)))
d556 1
a556 1
	    (caddr_t)SCARG(uap, fromlenaddr), retval));
d574 3
a576 2
	if (error = copyin((caddr_t)SCARG(uap, msg), (caddr_t)&msg,
	    sizeof (msg)))
d593 3
a595 2
	if (error = copyin((caddr_t)uiov, (caddr_t)iov,
	    (unsigned)(msg.msg_iovlen * sizeof (struct iovec))))
d626 1
a626 1
	if (error = getsock(p->p_fd, s, &fp))
d637 2
d641 1
d654 4
a657 3
	if (error = soreceive((struct socket *)fp->f_data, &from, &auio,
	    (struct mbuf **)0, mp->msg_control ? &control : (struct mbuf **)0,
	    &mp->msg_flags)) {
d686 3
a688 2
			if (error = copyout(mtod(from, caddr_t),
			    (caddr_t)mp->msg_name, (unsigned)len))
d758 1
a758 1
	if (error = getsock(p->p_fd, SCARG(uap, s), &fp))
d781 1
a781 1
	if (error = getsock(p->p_fd, SCARG(uap, s), &fp))
d789 3
a791 2
		if (error = copyin(SCARG(uap, val), mtod(m, caddr_t),
		    (u_int)SCARG(uap, valsize))) {
d798 1
a798 1
	    SCARG(uap, name), m));
d819 1
a819 1
	if (error = getsock(p->p_fd, SCARG(uap, s), &fp))
d822 3
a824 2
		if (error = copyin((caddr_t)SCARG(uap, avalsize),
		    (caddr_t)&valsize, sizeof (valsize)))
d856 1
a856 1
	if (error = socreate(AF_UNIX, &rso, SOCK_STREAM, 0))
d858 1
a858 1
	if (error = socreate(AF_UNIX, &wso, SOCK_STREAM, 0))
d860 1
a860 1
	if (error = falloc(p, &rf, &fd))
d867 1
a867 1
	if (error = falloc(p, &wf, &fd))
d874 1
a874 1
	if (error = unp_connect2(wso, rso))
d910 1
a910 1
	if (error = getsock(p->p_fd, SCARG(uap, fdes), &fp))
d912 2
a913 2
	if (error = copyin((caddr_t)SCARG(uap, alen), (caddr_t)&len,
	    sizeof (len)))
d919 2
a920 1
	if (error = (*so->so_proto->pr_usrreq)(so, PRU_SOCKADDR, 0, m, 0))
d953 1
a953 1
	if (error = getsock(p->p_fd, SCARG(uap, fdes), &fp))
d958 2
a959 2
	if (error =
	    copyin((caddr_t)SCARG(uap, alen), (caddr_t)&len, sizeof (len)))
d964 2
a965 1
	if (error = (*so->so_proto->pr_usrreq)(so, PRU_PEERADDR, 0, m, 0))
d969 2
a970 2
	if (error =
	    copyout(mtod(m, caddr_t), (caddr_t)SCARG(uap, asa), (u_int)len))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
