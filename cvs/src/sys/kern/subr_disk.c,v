head	1.230;
access;
symbols
	OPENBSD_6_1:1.228.0.4
	OPENBSD_6_1_BASE:1.228
	OPENBSD_6_0:1.227.0.2
	OPENBSD_6_0_BASE:1.227
	OPENBSD_5_9:1.223.0.2
	OPENBSD_5_9_BASE:1.223
	OPENBSD_5_8:1.187.0.4
	OPENBSD_5_8_BASE:1.187
	OPENBSD_5_7:1.180.0.2
	OPENBSD_5_7_BASE:1.180
	OPENBSD_5_6:1.168.0.4
	OPENBSD_5_6_BASE:1.168
	OPENBSD_5_5:1.163.0.4
	OPENBSD_5_5_BASE:1.163
	OPENBSD_5_4:1.150.0.2
	OPENBSD_5_4_BASE:1.150
	OPENBSD_5_3:1.147.0.2
	OPENBSD_5_3_BASE:1.147
	OPENBSD_5_2:1.145.0.2
	OPENBSD_5_2_BASE:1.145
	OPENBSD_5_1_BASE:1.143
	OPENBSD_5_1:1.143.0.2
	OPENBSD_5_0:1.131.0.2
	OPENBSD_5_0_BASE:1.131
	OPENBSD_4_9:1.114.0.2
	OPENBSD_4_9_BASE:1.114
	OPENBSD_4_8:1.104.0.2
	OPENBSD_4_8_BASE:1.104
	OPENBSD_4_7:1.99.0.2
	OPENBSD_4_7_BASE:1.99
	OPENBSD_4_6:1.95.0.4
	OPENBSD_4_6_BASE:1.95
	OPENBSD_4_5:1.84.0.2
	OPENBSD_4_5_BASE:1.84
	OPENBSD_4_4:1.79.0.2
	OPENBSD_4_4_BASE:1.79
	OPENBSD_4_3:1.68.0.2
	OPENBSD_4_3_BASE:1.68
	OPENBSD_4_2:1.64.0.2
	OPENBSD_4_2_BASE:1.64
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.29.0.4
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.6
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.21
	UBC:1.20.0.4
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_8:1.18.0.4
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	SMP:1.17.0.2
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.16.0.8
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.6
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.16.0.4
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.16.0.2
	OPENBSD_2_3_BASE:1.16
	OPENBSD_2_2:1.15.0.2
	OPENBSD_2_2_BASE:1.15
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.230
date	2017.05.04.22.47.27;	author deraadt;	state Exp;
branches;
next	1.229;
commitid	h72QEcy0gESNuyF9;

1.229
date	2017.04.20.14.13.00;	author visa;	state Exp;
branches;
next	1.228;
commitid	GnoPKa34InShCqYl;

1.228
date	2016.09.02.09.44.27;	author tom;	state Exp;
branches;
next	1.227;
commitid	RrsNJTg3xyoaWJm2;

1.227
date	2016.05.21.14.22.31;	author jsing;	state Exp;
branches;
next	1.226;
commitid	bvUHjRhYmMVln8zj;

1.226
date	2016.05.21.14.00.27;	author jsing;	state Exp;
branches;
next	1.225;
commitid	75VU4m1ZupzmtdjG;

1.225
date	2016.05.20.14.01.27;	author jsing;	state Exp;
branches;
next	1.224;
commitid	E4nOSKi6JSAy2O09;

1.224
date	2016.05.19.21.31.04;	author kettenis;	state Exp;
branches;
next	1.223;
commitid	NXa9irc9PMg7JEgA;

1.223
date	2016.02.08.22.12.51;	author krw;	state Exp;
branches;
next	1.222;
commitid	N5yue45Qo60XSGSw;

1.222
date	2015.12.24.20.14.07;	author krw;	state Exp;
branches;
next	1.221;
commitid	EqY87tWvAH4Fo2tF;

1.221
date	2015.12.24.18.03.03;	author krw;	state Exp;
branches;
next	1.220;
commitid	tbcDMNza3QRe7dws;

1.220
date	2015.09.25.11.56.21;	author krw;	state Exp;
branches;
next	1.219;
commitid	fRdI5H9C2tUJeV7W;

1.219
date	2015.09.24.19.28.33;	author krw;	state Exp;
branches;
next	1.218;
commitid	tv9K7MeyIhMhM2TZ;

1.218
date	2015.09.24.11.12.56;	author krw;	state Exp;
branches;
next	1.217;
commitid	XJVLu6S9uihJauIc;

1.217
date	2015.09.15.05.35.42;	author yasuoka;	state Exp;
branches;
next	1.216;
commitid	cHlJHWd3FSwRwyu9;

1.216
date	2015.09.13.14.38.17;	author krw;	state Exp;
branches;
next	1.215;
commitid	c0XpqHGmLc5SimVj;

1.215
date	2015.09.13.12.53.08;	author krw;	state Exp;
branches;
next	1.214;
commitid	4CCbjaLmEQx7b0nk;

1.214
date	2015.09.11.17.51.30;	author krw;	state Exp;
branches;
next	1.213;
commitid	lOcTk2xATbbJFa98;

1.213
date	2015.09.11.15.04.01;	author krw;	state Exp;
branches;
next	1.212;
commitid	MIFbZMJgYA89qw4y;

1.212
date	2015.09.11.14.54.46;	author krw;	state Exp;
branches;
next	1.211;
commitid	3xioOMwXDj5GVN1W;

1.211
date	2015.09.11.14.14.36;	author krw;	state Exp;
branches;
next	1.210;
commitid	YaLuOE7fpNHJxIT7;

1.210
date	2015.09.11.14.08.22;	author krw;	state Exp;
branches;
next	1.209;
commitid	wqzDAKngczEeO6gH;

1.209
date	2015.09.11.12.40.05;	author krw;	state Exp;
branches;
next	1.208;
commitid	ZEDMwVQMKRVyogDl;

1.208
date	2015.09.11.11.04.40;	author krw;	state Exp;
branches;
next	1.207;
commitid	BkgyklSGtkRytHdk;

1.207
date	2015.09.11.09.44.28;	author krw;	state Exp;
branches;
next	1.206;
commitid	KKHDZbT8JNlKjxXK;

1.206
date	2015.09.11.09.22.07;	author krw;	state Exp;
branches;
next	1.205;
commitid	x30WcDtqPKJZFBBw;

1.205
date	2015.09.11.08.06.48;	author krw;	state Exp;
branches;
next	1.204;
commitid	svSqHoehR0wJUz8Y;

1.204
date	2015.09.10.16.30.23;	author krw;	state Exp;
branches;
next	1.203;
commitid	9pWIHufyPNBOOdoM;

1.203
date	2015.09.10.14.28.17;	author krw;	state Exp;
branches;
next	1.202;
commitid	uaY2IS0JsuWLMJ5D;

1.202
date	2015.09.10.14.11.53;	author krw;	state Exp;
branches;
next	1.201;
commitid	UZpD5JcZRo1En43j;

1.201
date	2015.09.09.19.43.26;	author krw;	state Exp;
branches;
next	1.200;
commitid	lz3oEjH1SVZuaiNa;

1.200
date	2015.09.01.01.06.35;	author deraadt;	state Exp;
branches;
next	1.199;
commitid	N4DMSTSh6mKeNT7P;

1.199
date	2015.09.01.00.27.10;	author krw;	state Exp;
branches;
next	1.198;
commitid	2MigJ7LW2PUZKsdp;

1.198
date	2015.09.01.00.17.15;	author krw;	state Exp;
branches;
next	1.197;
commitid	WSbZcsgEwPzMZQqi;

1.197
date	2015.08.31.15.47.51;	author krw;	state Exp;
branches;
next	1.196;
commitid	FnAWN1viLM9tGd3T;

1.196
date	2015.08.31.14.02.36;	author krw;	state Exp;
branches;
next	1.195;
commitid	G6uSDoLOvBQptH8R;

1.195
date	2015.08.30.17.19.51;	author krw;	state Exp;
branches;
next	1.194;
commitid	FgloMAVj2gRz5kcK;

1.194
date	2015.08.30.15.35.05;	author krw;	state Exp;
branches;
next	1.193;
commitid	8IEjpWqegW1T1f6L;

1.193
date	2015.08.29.20.48.55;	author krw;	state Exp;
branches;
next	1.192;
commitid	oKRLTqZbCDiWsSat;

1.192
date	2015.08.28.22.42.05;	author krw;	state Exp;
branches;
next	1.191;
commitid	QuzAeIw93F1vn4fx;

1.191
date	2015.08.28.11.12.57;	author krw;	state Exp;
branches;
next	1.190;
commitid	iHWOoBvwy2DeOqK3;

1.190
date	2015.08.26.15.36.46;	author krw;	state Exp;
branches;
next	1.189;
commitid	V9uUuj5LanpaRaWO;

1.189
date	2015.08.24.23.03.11;	author krw;	state Exp;
branches;
next	1.188;
commitid	S3K355GugHBZQx9M;

1.188
date	2015.08.12.22.37.32;	author krw;	state Exp;
branches;
next	1.187;
commitid	hlnL1Ya0myk6Bukt;

1.187
date	2015.07.29.00.15.36;	author krw;	state Exp;
branches;
next	1.186;
commitid	8Nntd66UoO224sVp;

1.186
date	2015.07.28.23.10.13;	author krw;	state Exp;
branches;
next	1.185;
commitid	2ZlqzujqgUBa7WzI;

1.185
date	2015.07.26.14.01.07;	author krw;	state Exp;
branches;
next	1.184;
commitid	tUcQArFS2DKwAoyh;

1.184
date	2015.07.23.18.02.59;	author krw;	state Exp;
branches;
next	1.183;
commitid	q5wcyDnmemhtL3T8;

1.183
date	2015.05.09.17.11.26;	author krw;	state Exp;
branches;
next	1.182;
commitid	XgIfRGTOOf864WwV;

1.182
date	2015.03.15.15.13.31;	author krw;	state Exp;
branches;
next	1.181;
commitid	2bAMbroPqagfx7Xw;

1.181
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.180;
commitid	p4LJxGKbi0BU2cG6;

1.180
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.179;
commitid	MyKPm9Q3dQu92BiX;

1.179
date	2014.12.30.04.00.33;	author krw;	state Exp;
branches;
next	1.178;
commitid	ofG0ylNs0Jlq0JBC;

1.178
date	2014.12.28.18.32.12;	author krw;	state Exp;
branches;
next	1.177;
commitid	RExZ0ctpNnrtdDu7;

1.177
date	2014.12.20.15.54.48;	author krw;	state Exp;
branches;
next	1.176;
commitid	asJKlsFGpkZvDWRu;

1.176
date	2014.12.20.13.45.15;	author kettenis;	state Exp;
branches;
next	1.175;
commitid	T5MSdEUcLDiJXwc2;

1.175
date	2014.12.20.13.37.32;	author krw;	state Exp;
branches;
next	1.174;
commitid	NVR8H603CQkESQNG;

1.174
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.173;
commitid	P6Av4XGqOi3rFasL;

1.173
date	2014.11.03.21.00.27;	author tedu;	state Exp;
branches;
next	1.172;
commitid	529xUok1zuM2EpDj;

1.172
date	2014.11.03.16.55.21;	author tedu;	state Exp;
branches;
next	1.171;
commitid	N3XUefUKOpSZQ0qN;

1.171
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.170;
commitid	3SGDR5EjcwE01W8S;

1.170
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.169;
commitid	uzzBR7hz9ncd4O6G;

1.169
date	2014.08.30.10.44.01;	author miod;	state Exp;
branches;
next	1.168;
commitid	ufag0E85kLt8ZNJV;

1.168
date	2014.07.13.15.32.28;	author miod;	state Exp;
branches;
next	1.167;
commitid	PkUmoT9mKpliN2oG;

1.167
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.166;
commitid	QlVV51SZgNFxsXxC;

1.166
date	2014.07.12.17.50.36;	author jsing;	state Exp;
branches;
next	1.165;
commitid	nPK7q3X6YNJWqmQF;

1.165
date	2014.07.11.14.36.44;	author uebayasi;	state Exp;
branches;
next	1.164;
commitid	V6bwQMCHbD31pEWD;

1.164
date	2014.07.02.09.59.43;	author dlg;	state Exp;
branches;
next	1.163;
commitid	nKxQOAoASGVe3Zad;

1.163
date	2014.01.24.10.25.56;	author krw;	state Exp;
branches;
next	1.162;

1.162
date	2014.01.23.00.32.57;	author krw;	state Exp;
branches;
next	1.161;

1.161
date	2014.01.22.03.46.48;	author krw;	state Exp;
branches;
next	1.160;

1.160
date	2014.01.21.01.48.44;	author tedu;	state Exp;
branches;
next	1.159;

1.159
date	2013.11.20.23.52.42;	author dlg;	state Exp;
branches;
next	1.158;

1.158
date	2013.11.18.17.45.01;	author deraadt;	state Exp;
branches;
next	1.157;

1.157
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.156;

1.156
date	2013.10.20.13.15.35;	author krw;	state Exp;
branches;
next	1.155;

1.155
date	2013.10.19.09.32.15;	author krw;	state Exp;
branches;
next	1.154;

1.154
date	2013.10.14.23.35.53;	author krw;	state Exp;
branches;
next	1.153;

1.153
date	2013.10.07.22.11.49;	author krw;	state Exp;
branches;
next	1.152;

1.152
date	2013.09.03.17.48.26;	author krw;	state Exp;
branches;
next	1.151;

1.151
date	2013.08.08.23.25.06;	author syl;	state Exp;
branches;
next	1.150;

1.150
date	2013.07.03.15.21.40;	author sf;	state Exp;
branches;
next	1.149;

1.149
date	2013.06.11.16.42.16;	author deraadt;	state Exp;
branches;
next	1.148;

1.148
date	2013.04.24.08.31.06;	author blambert;	state Exp;
branches;
next	1.147;

1.147
date	2013.02.17.17.39.29;	author miod;	state Exp;
branches;
next	1.146;

1.146
date	2013.02.09.20.56.35;	author miod;	state Exp;
branches;
next	1.145;

1.145
date	2012.04.07.16.48.38;	author krw;	state Exp;
branches;
next	1.144;

1.144
date	2012.03.31.23.10.34;	author krw;	state Exp;
branches;
next	1.143;

1.143
date	2012.02.10.18.41.36;	author phessler;	state Exp;
branches;
next	1.142;

1.142
date	2012.01.21.17.09.02;	author krw;	state Exp;
branches;
next	1.141;

1.141
date	2012.01.21.16.30.10;	author jsing;	state Exp;
branches;
next	1.140;

1.140
date	2012.01.16.16.29.49;	author jsing;	state Exp;
branches;
next	1.139;

1.139
date	2012.01.13.14.39.31;	author jsing;	state Exp;
branches;
next	1.138;

1.138
date	2012.01.13.14.16.51;	author jsing;	state Exp;
branches;
next	1.137;

1.137
date	2012.01.11.15.40.36;	author jsing;	state Exp;
branches;
next	1.136;

1.136
date	2012.01.11.15.17.48;	author jsing;	state Exp;
branches;
next	1.135;

1.135
date	2011.12.28.16.02.45;	author jsing;	state Exp;
branches;
next	1.134;

1.134
date	2011.12.28.14.34.13;	author jsing;	state Exp;
branches;
next	1.133;

1.133
date	2011.09.21.21.43.57;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2011.09.18.13.23.38;	author miod;	state Exp;
branches;
next	1.131;

1.131
date	2011.07.26.12.32.14;	author krw;	state Exp;
branches;
next	1.130;

1.130
date	2011.07.06.16.36.52;	author krw;	state Exp;
branches;
next	1.129;

1.129
date	2011.07.06.04.49.36;	author matthew;	state Exp;
branches;
next	1.128;

1.128
date	2011.07.05.04.05.04;	author matthew;	state Exp;
branches;
next	1.127;

1.127
date	2011.06.30.16.28.05;	author matthew;	state Exp;
branches;
next	1.126;

1.126
date	2011.06.19.04.53.17;	author matthew;	state Exp;
branches;
next	1.125;

1.125
date	2011.06.19.04.51.06;	author matthew;	state Exp;
branches;
next	1.124;

1.124
date	2011.06.19.04.11.48;	author matthew;	state Exp;
branches;
next	1.123;

1.123
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.122;

1.122
date	2011.06.01.17.57.51;	author matthew;	state Exp;
branches;
next	1.121;

1.121
date	2011.04.28.17.50.17;	author marco;	state Exp;
branches;
next	1.120;

1.120
date	2011.04.26.17.20.20;	author jsing;	state Exp;
branches;
next	1.119;

1.119
date	2011.04.16.03.21.16;	author krw;	state Exp;
branches;
next	1.118;

1.118
date	2011.04.15.14.57.29;	author krw;	state Exp;
branches;
next	1.117;

1.117
date	2011.03.19.01.21.57;	author krw;	state Exp;
branches;
next	1.116;

1.116
date	2011.03.17.21.44.10;	author krw;	state Exp;
branches;
next	1.115;

1.115
date	2011.03.14.17.20.00;	author krw;	state Exp;
branches;
next	1.114;

1.114
date	2010.11.24.15.31.34;	author jsing;	state Exp;
branches;
next	1.113;

1.113
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.112;

1.112
date	2010.09.24.07.08.50;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2010.09.23.18.49.39;	author oga;	state Exp;
branches;
next	1.110;

1.110
date	2010.09.23.13.20.36;	author jsing;	state Exp;
branches;
next	1.109;

1.109
date	2010.09.08.15.16.22;	author jsing;	state Exp;
branches;
next	1.108;

1.108
date	2010.09.08.14.47.12;	author jsing;	state Exp;
branches;
next	1.107;

1.107
date	2010.09.01.20.16.51;	author miod;	state Exp;
branches;
next	1.106;

1.106
date	2010.08.30.16.53.28;	author jsing;	state Exp;
branches;
next	1.105;

1.105
date	2010.08.18.14.04.16;	author jasper;	state Exp;
branches;
next	1.104;

1.104
date	2010.06.27.00.14.06;	author jsing;	state Exp;
branches;
next	1.103;

1.103
date	2010.05.03.15.27.28;	author jsing;	state Exp;
branches;
next	1.102;

1.102
date	2010.04.28.12.54.04;	author jsing;	state Exp;
branches;
next	1.101;

1.101
date	2010.04.25.06.15.17;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.99;

1.99
date	2010.01.14.23.12.11;	author schwarze;	state Exp;
branches;
next	1.98;

1.98
date	2010.01.11.05.37.28;	author krw;	state Exp;
branches;
next	1.97;

1.97
date	2009.08.13.15.23.11;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2009.08.09.14.06.52;	author marco;	state Exp;
branches;
next	1.95;

1.95
date	2009.06.17.01.30.30;	author thib;	state Exp;
branches;
next	1.94;

1.94
date	2009.06.14.00.09.40;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.05.00.41.13;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2009.06.04.21.13.02;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2009.06.03.22.09.30;	author thib;	state Exp;
branches;
next	1.90;

1.90
date	2009.06.03.06.25.27;	author marco;	state Exp;
branches;
next	1.89;

1.89
date	2009.06.03.03.14.28;	author thib;	state Exp;
branches;
next	1.88;

1.88
date	2009.05.15.01.57.16;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2009.05.13.01.14.19;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2009.05.03.06.45.58;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2009.03.28.14.58.10;	author dlg;	state Exp;
branches;
next	1.84;

1.84
date	2009.02.09.20.00.48;	author otto;	state Exp;
branches;
next	1.83;

1.83
date	2008.11.21.23.51.30;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2008.08.25.11.27.00;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2008.08.22.03.19.02;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2008.08.08.23.49.53;	author krw;	state Exp;
branches;
next	1.79;

1.79
date	2008.06.25.15.26.43;	author reyk;	state Exp;
branches;
next	1.78;

1.78
date	2008.06.12.06.58.39;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2008.06.11.12.35.46;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.10.20.50.23;	author beck;	state Exp;
branches;
next	1.75;

1.75
date	2008.06.10.20.14.36;	author beck;	state Exp;
branches;
next	1.74;

1.74
date	2008.05.23.00.51.33;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2008.04.07.23.10.24;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2008.03.31.23.56.29;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2008.03.31.22.27.41;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2008.03.30.20.24.32;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2008.03.23.17.05.40;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2007.12.23.01.59.58;	author dlg;	state Exp;
branches;
next	1.67;

1.67
date	2007.12.16.20.57.17;	author otto;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.09.11.32.57;	author jsing;	state Exp;
branches;
next	1.65;

1.65
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.64;

1.64
date	2007.08.05.04.26.21;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2007.08.05.03.24.58;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.25.16.11.42;	author otto;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.20.18.15.47;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.17.00.27.30;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.10.16.37.09;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.09.23.35.23;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.09.23.06.45;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.09.17.18.36;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.09.06.03.24;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2007.06.09.04.08.37;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.09.03.56.48;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.09.03.53.17;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.06.22.04.11;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.06.16.49.51;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.06.16.39.49;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.05.00.38.23;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.04.22.07.59;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.02.02.35.27;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.01.19.06.28;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.29.06.28.15;	author otto;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.18.16.26.38;	author drahn;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.18.07.37.18;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.15.01.58.06;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.10.06.02.04;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.05.12.43.35;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.04.23.21.23;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.04.03.44.45;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.03.30.00.38.56;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2007.03.27.18.04.01;	author thib;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.11.18.58.59;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2005.12.09.09.09.52;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.01.03.43.24;	author pedro;	state Exp;
branches;
next	1.27;

1.27
date	2004.10.25.19.53.52;	author pedro;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.15.02.45.46;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.21.21.00.14;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.25.20.52.57;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.14.07.16.12;	author angelos;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2000.11.07.16.58.01;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.09.19.26.35;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	99.11.17.04.31.22;	author d;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	97.11.23.03.19.18;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.08.07.09.27.01;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	97.05.22.05.34.56;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.05.12.22.43.55;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.04.06.20.59.40;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.02.24.14.19.57;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.01.05.11.09.03;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.11.06.01.36.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.08.17.05.53.59;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.08.08.23.26.16;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.23.23.54.19;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.27.15;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.02.29.13.38.51;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.20.21.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.30.09.24.37;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches;
next	;

1.17.2.1
date	2001.05.14.22.32.42;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2001.07.04.10.48.29;	author niklas;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.17.2.5;

1.17.2.5
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.17.2.6;

1.17.2.6
date	2004.06.05.23.13.01;	author niklas;	state Exp;
branches;
next	;

1.20.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	;


desc
@@


1.230
log
@Also pass the blk offset to disk_unbusy(), so that it can pass it to
the random subsystem as entropy.  This value is pretty much unknown,
and anyways our entropy input ring does not saturate from knowns.
ok mikeb djm
@
text
@/*	$OpenBSD: subr_disk.c,v 1.229 2017/04/20 14:13:00 visa Exp $	*/
/*	$NetBSD: subr_disk.c,v 1.17 1996/03/16 23:17:08 christos Exp $	*/

/*
 * Copyright (c) 1995 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_disksubr.c	8.5 (Berkeley) 1/21/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/fcntl.h>
#include <sys/buf.h>
#include <sys/stat.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/time.h>
#include <sys/disklabel.h>
#include <sys/conf.h>
#include <sys/lock.h>
#include <sys/disk.h>
#include <sys/reboot.h>
#include <sys/dkio.h>
#include <sys/vnode.h>
#include <sys/task.h>
#include <sys/stdint.h>

#include <sys/socket.h>
#include <sys/socketvar.h>

#include <net/if.h>

#include <dev/rndvar.h>
#include <dev/cons.h>

#include <lib/libz/zlib.h>

#include "softraid.h"

#ifdef DEBUG
#define DPRINTF(x...)	printf(x)
#else
#define DPRINTF(x...)
#endif

/*
 * A global list of all disks attached to the system.  May grow or
 * shrink over time.
 */
struct	disklist_head disklist;	/* TAILQ_HEAD */
int	disk_count;		/* number of drives in global disklist */
int	disk_change;		/* set if a disk has been attached/detached
				 * since last we looked at this variable. This
				 * is reset by hw_sysctl()
				 */

#define DUID_SIZE 8

u_char	bootduid[DUID_SIZE];	/* DUID of boot disk. */
u_char	rootduid[DUID_SIZE];	/* DUID of root disk. */

/* softraid callback, do not use! */
void (*softraid_disk_attach)(struct disk *, int);

void sr_map_root(void);

struct disk_attach_task {
	struct task task;
	struct disk *dk;
};

void disk_attach_callback(void *);

int spoofgptlabel(struct buf *, void (*)(struct buf *), struct disklabel *);

int gpt_chk_mbr(struct dos_partition *, u_int64_t);
int gpt_chk_hdr(struct gpt_header *, struct disklabel *);
int gpt_chk_parts(struct gpt_header *, struct gpt_partition *);
int gpt_get_fstype(struct uuid *);

int duid_equal(u_char *, u_char *);

/*
 * Compute checksum for disk label.
 */
u_int
dkcksum(struct disklabel *lp)
{
	u_int16_t *start, *end;
	u_int16_t sum = 0;

	start = (u_int16_t *)lp;
	end = (u_int16_t *)&lp->d_partitions[lp->d_npartitions];
	while (start < end)
		sum ^= *start++;
	return (sum);
}

int
initdisklabel(struct disklabel *lp)
{
	int i;

	/* minimal requirements for archetypal disk label */
	if (lp->d_secsize < DEV_BSIZE)
		lp->d_secsize = DEV_BSIZE;
	if (DL_GETDSIZE(lp) == 0)
		DL_SETDSIZE(lp, MAXDISKSIZE);
	if (lp->d_secpercyl == 0)
		return (ERANGE);
	lp->d_npartitions = MAXPARTITIONS;
	for (i = 0; i < RAW_PART; i++) {
		DL_SETPSIZE(&lp->d_partitions[i], 0);
		DL_SETPOFFSET(&lp->d_partitions[i], 0);
	}
	if (DL_GETPSIZE(&lp->d_partitions[RAW_PART]) == 0)
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	DL_SETBSTART(lp, 0);
	DL_SETBEND(lp, DL_GETDSIZE(lp));
	lp->d_version = 1;
	lp->d_bbsize = 8192;
	lp->d_sbsize = 64*1024;			/* XXX ? */
	return (0);
}

/*
 * Check an incoming block to make sure it is a disklabel, convert it to
 * a newer version if needed, etc etc.
 */
int
checkdisklabel(void *rlp, struct disklabel *lp, u_int64_t boundstart,
    u_int64_t boundend)
{
	struct disklabel *dlp = rlp;
	struct __partitionv0 *v0pp;
	struct partition *pp;
	u_int64_t disksize;
	int error = 0;
	int i;

	if (dlp->d_magic != DISKMAGIC || dlp->d_magic2 != DISKMAGIC)
		error = ENOENT;	/* no disk label */
	else if (dlp->d_npartitions > MAXPARTITIONS)
		error = E2BIG;	/* too many partitions */
	else if (dlp->d_secpercyl == 0)
		error = EINVAL;	/* invalid label */
	else if (dlp->d_secsize == 0)
		error = ENOSPC;	/* disk too small */
	else if (dkcksum(dlp) != 0)
		error = EINVAL;	/* incorrect checksum */

	if (error) {
		u_int16_t *start, *end, sum = 0;

		/* If it is byte-swapped, attempt to convert it */
		if (swap32(dlp->d_magic) != DISKMAGIC ||
		    swap32(dlp->d_magic2) != DISKMAGIC ||
		    swap16(dlp->d_npartitions) > MAXPARTITIONS)
			return (error);

		/*
		 * Need a byte-swap aware dkcksum variant
		 * inlined, because dkcksum uses a sub-field
		 */
		start = (u_int16_t *)dlp;
		end = (u_int16_t *)&dlp->d_partitions[
		    swap16(dlp->d_npartitions)];
		while (start < end)
			sum ^= *start++;
		if (sum != 0)
			return (error);

		dlp->d_magic = swap32(dlp->d_magic);
		dlp->d_type = swap16(dlp->d_type);

		/* d_typename and d_packname are strings */

		dlp->d_secsize = swap32(dlp->d_secsize);
		dlp->d_nsectors = swap32(dlp->d_nsectors);
		dlp->d_ntracks = swap32(dlp->d_ntracks);
		dlp->d_ncylinders = swap32(dlp->d_ncylinders);
		dlp->d_secpercyl = swap32(dlp->d_secpercyl);
		dlp->d_secperunit = swap32(dlp->d_secperunit);

		/* d_uid is a string */

		dlp->d_acylinders = swap32(dlp->d_acylinders);

		dlp->d_flags = swap32(dlp->d_flags);

		for (i = 0; i < NDDATA; i++)
			dlp->d_drivedata[i] = swap32(dlp->d_drivedata[i]);

		dlp->d_secperunith = swap16(dlp->d_secperunith);
		dlp->d_version = swap16(dlp->d_version);

		for (i = 0; i < NSPARE; i++)
			dlp->d_spare[i] = swap32(dlp->d_spare[i]);

		dlp->d_magic2 = swap32(dlp->d_magic2);

		dlp->d_npartitions = swap16(dlp->d_npartitions);
		dlp->d_bbsize = swap32(dlp->d_bbsize);
		dlp->d_sbsize = swap32(dlp->d_sbsize);

		for (i = 0; i < MAXPARTITIONS; i++) {
			pp = &dlp->d_partitions[i];
			pp->p_size = swap32(pp->p_size);
			pp->p_offset = swap32(pp->p_offset);
			if (dlp->d_version == 0) {
				v0pp = (struct __partitionv0 *)pp;
				v0pp->p_fsize = swap32(v0pp->p_fsize);
			} else {
				pp->p_offseth = swap16(pp->p_offseth);
				pp->p_sizeh = swap16(pp->p_sizeh);
			}
			pp->p_cpg = swap16(pp->p_cpg);
		}

		dlp->d_checksum = 0;
		dlp->d_checksum = dkcksum(dlp);
		error = 0;
	}

	/* XXX should verify lots of other fields and whine a lot */

	/* Initial passed in lp contains the real disk size. */
	disksize = DL_GETDSIZE(lp);

	if (lp != dlp)
		*lp = *dlp;

	if (lp->d_version == 0) {
		lp->d_version = 1;
		lp->d_secperunith = 0;

		v0pp = (struct __partitionv0 *)lp->d_partitions;
		pp = lp->d_partitions;
		for (i = 0; i < lp->d_npartitions; i++, pp++, v0pp++) {
			pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(v0pp->
			    p_fsize, v0pp->p_frag);
			pp->p_offseth = 0;
			pp->p_sizeh = 0;
		}
	}

#ifdef DEBUG
	if (DL_GETDSIZE(lp) != disksize)
		printf("on-disk disklabel has incorrect disksize (%llu)\n",
		    DL_GETDSIZE(lp));
	if (DL_GETPSIZE(&lp->d_partitions[RAW_PART]) != disksize)
		printf("on-disk disklabel RAW_PART has incorrect size (%llu)\n",
		    DL_GETPSIZE(&lp->d_partitions[RAW_PART]));
	if (DL_GETPOFFSET(&lp->d_partitions[RAW_PART]) != 0)
		printf("on-disk disklabel RAW_PART offset != 0 (%llu)\n",
		    DL_GETPOFFSET(&lp->d_partitions[RAW_PART]));
#endif
	DL_SETDSIZE(lp, disksize);
	DL_SETPSIZE(&lp->d_partitions[RAW_PART], disksize);
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	DL_SETBSTART(lp, boundstart);
	DL_SETBEND(lp, boundend < DL_GETDSIZE(lp) ? boundend : DL_GETDSIZE(lp));

	lp->d_checksum = 0;
	lp->d_checksum = dkcksum(lp);
	return (0);
}

/*
 * Read a disk sector.
 */
int
readdisksector(struct buf *bp, void (*strat)(struct buf *),
    struct disklabel *lp, u_int64_t sector)
{
	bp->b_blkno = DL_SECTOBLK(lp, sector);
	bp->b_bcount = lp->d_secsize;
	bp->b_error = 0;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE | B_ERROR);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);

	(*strat)(bp);

	return (biowait(bp));
}

/*
 * If dos partition table requested, attempt to load it and
 * find disklabel inside a DOS partition. Return buffer
 * for use in signalling errors if requested.
 *
 * We would like to check if each MBR has a valid BOOT_MAGIC, but
 * we cannot because it doesn't always exist. So.. we assume the
 * MBR is valid.
 */
int
readdoslabel(struct buf *bp, void (*strat)(struct buf *),
    struct disklabel *lp, daddr_t *partoffp, int spoofonly)
{
	struct disklabel *gptlp;
	u_int64_t dospartoff = 0, dospartend = DL_GETBEND(lp);
	int i, ourpart = -1, wander = 1, n = 0, loop = 0, offset;
	struct dos_partition dp[NDOSPART], *dp2;
	u_int64_t sector = DOSBBSECTOR;
	u_int32_t extoff = 0;
	int error;

	if (lp->d_secpercyl == 0)
		return (EINVAL);	/* invalid label */
	if (lp->d_secsize == 0)
		return (ENOSPC);	/* disk too small */

	/* do DOS partitions in the process of getting disklabel? */

	/*
	 * Read dos partition table, follow extended partitions.
	 * Map the partitions to disklabel entries i-p
	 */
	while (wander && loop < DOS_MAXEBR) {
		loop++;
		wander = 0;
		if (sector < extoff)
			sector = extoff;

		/* read MBR/EBR */
		error = readdisksector(bp, strat, lp, sector);
		if (error) {
/*wrong*/		if (partoffp)
/*wrong*/			*partoffp = -1;
			return (error);
		}

		bcopy(bp->b_data + DOSPARTOFF, dp, sizeof(dp));

		if (n == 0 && sector == DOSBBSECTOR) {
			u_int16_t mbrtest;

			/* Check the end of sector marker. */
			mbrtest = ((bp->b_data[510] << 8) & 0xff00) |
			    (bp->b_data[511] & 0xff);
			if (mbrtest != 0x55aa)
				goto notmbr;

			if (gpt_chk_mbr(dp, DL_GETDSIZE(lp)) != 0)
				goto notgpt;

			gptlp = malloc(sizeof(struct disklabel), M_DEVBUF,
			    M_NOWAIT);
			if (gptlp == NULL)
				return (ENOMEM);
			*gptlp = *lp;
			error = spoofgptlabel(bp, strat, gptlp);
			if (error == 0) {
				dospartoff = DL_GETBSTART(gptlp);
				dospartend = DL_GETBEND(gptlp);
				if (partoffp) {
					if (dospartoff == 0)
						return (ENXIO);
					else
						goto notfat;
				}
				*lp = *gptlp;
				free(gptlp, M_DEVBUF,
				    sizeof(struct disklabel));
				goto notfat;
			} else {
				free(gptlp, M_DEVBUF,
				    sizeof(struct disklabel));
				goto notmbr;
			}
		}

notgpt:
		if (ourpart == -1) {
			/* Search for our MBR partition */
			for (dp2=dp, i=0; i < NDOSPART && ourpart == -1;
			    i++, dp2++)
				if (letoh32(dp2->dp_size) &&
				    dp2->dp_typ == DOSPTYP_OPENBSD)
					ourpart = i;
			if (ourpart == -1)
				goto donot;
			/*
			 * This is our MBR partition. need sector
			 * address for SCSI/IDE, cylinder for
			 * ESDI/ST506/RLL
			 */
			dp2 = &dp[ourpart];
			dospartoff = letoh32(dp2->dp_start) + sector;
			dospartend = dospartoff + letoh32(dp2->dp_size);

			/*
			 * Record the OpenBSD partition's placement (in
			 * 512-byte blocks!) for the caller. No need to
			 * finish spoofing.
			 */
			if (partoffp) {
				*partoffp = DL_SECTOBLK(lp, dospartoff);
				return (0);
			}

			if (lp->d_ntracks == 0)
				lp->d_ntracks = dp2->dp_ehd + 1;
			if (lp->d_nsectors == 0)
				lp->d_nsectors = DPSECT(dp2->dp_esect);
			if (lp->d_secpercyl == 0)
				lp->d_secpercyl = lp->d_ntracks *
				    lp->d_nsectors;
		}
donot:
		/*
		 * In case the disklabel read below fails, we want to
		 * provide a fake label in i-p.
		 */
		for (dp2=dp, i=0; i < NDOSPART; i++, dp2++) {
			struct partition *pp;
			u_int8_t fstype;

			if (dp2->dp_typ == DOSPTYP_OPENBSD ||
			    dp2->dp_typ == DOSPTYP_EFI)
				continue;
			if (letoh32(dp2->dp_size) > DL_GETDSIZE(lp))
				continue;
			if (letoh32(dp2->dp_start) > DL_GETDSIZE(lp))
				continue;
			if (letoh32(dp2->dp_size) == 0)
				continue;

			switch (dp2->dp_typ) {
			case DOSPTYP_UNUSED:
				fstype = FS_UNUSED;
				break;

			case DOSPTYP_LINUX:
				fstype = FS_EXT2FS;
				break;

			case DOSPTYP_NTFS:
				fstype = FS_NTFS;
				break;

			case DOSPTYP_EFISYS:
			case DOSPTYP_FAT12:
			case DOSPTYP_FAT16S:
			case DOSPTYP_FAT16B:
			case DOSPTYP_FAT16L:
			case DOSPTYP_FAT32:
			case DOSPTYP_FAT32L:
				fstype = FS_MSDOS;
				break;
			case DOSPTYP_EXTEND:
			case DOSPTYP_EXTENDL:
				sector = letoh32(dp2->dp_start) + extoff;
				if (!extoff) {
					extoff = letoh32(dp2->dp_start);
					sector = 0;
				}
				wander = 1;
				continue;
				break;
			default:
				fstype = FS_OTHER;
				break;
			}

			/*
			 * Don't set fstype/offset/size when just looking for
			 * the offset of the OpenBSD partition. It would
			 * invalidate the disklabel checksum!
			 *
			 * Don't try to spoof more than 8 partitions, i.e.
			 * 'i' -'p'.
			 */
			if (partoffp || n >= 8)
				continue;

			pp = &lp->d_partitions[8+n];
			n++;
			pp->p_fstype = fstype;
			if (letoh32(dp2->dp_start))
				DL_SETPOFFSET(pp,
				    letoh32(dp2->dp_start) + sector);
			DL_SETPSIZE(pp, letoh32(dp2->dp_size));
		}
	}

notmbr:
	if (n == 0 && sector == DOSBBSECTOR && ourpart == -1) {
		u_int16_t fattest;

		/* Check for a valid initial jmp instruction. */
		switch ((u_int8_t)bp->b_data[0]) {
		case 0xeb:
			/*
			 * Two-byte jmp instruction. The 2nd byte is the number
			 * of bytes to jmp and the 3rd byte must be a NOP.
			 */
			if ((u_int8_t)bp->b_data[2] != 0x90)
				goto notfat;
			break;
		case 0xe9:
			/*
			 * Three-byte jmp instruction. The next two bytes are a
			 * little-endian 16 bit value.
			 */
			break;
		default:
			goto notfat;
			break;
		}

		/* Check for a valid bytes per sector value. */
		fattest = ((bp->b_data[12] << 8) & 0xff00) |
		    (bp->b_data[11] & 0xff);
		if (fattest < 512 || fattest > 4096 || (fattest % 512 != 0))
			goto notfat;

		if (partoffp)
			return (ENXIO);	/* No place for disklabel on FAT! */

		DL_SETPSIZE(&lp->d_partitions['i' - 'a'],
		    DL_GETPSIZE(&lp->d_partitions[RAW_PART]));
		DL_SETPOFFSET(&lp->d_partitions['i' - 'a'], 0);
		lp->d_partitions['i' - 'a'].p_fstype = FS_MSDOS;

		spoofonly = 1;	/* No disklabel to read from disk. */
	}

notfat:
	/* record the OpenBSD partition's placement for the caller */
	if (partoffp)
		*partoffp = DL_SECTOBLK(lp, dospartoff);
	else {
		DL_SETBSTART(lp, dospartoff);
		DL_SETBEND(lp, (dospartend < DL_GETDSIZE(lp)) ? dospartend :
		    DL_GETDSIZE(lp));
	}

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		return (0);

	error = readdisksector(bp, strat, lp, dospartoff +
	    DL_BLKTOSEC(lp, DOS_LABELSECTOR));
	if (error)
		return (bp->b_error);

	offset = DL_BLKOFFSET(lp, DOS_LABELSECTOR);
	error = checkdisklabel(bp->b_data + offset, lp,
	    DL_GETBSTART((struct disklabel*)(bp->b_data+offset)),
	    DL_GETBEND((struct disklabel *)(bp->b_data+offset)));

	return (error);
}

/*
 * Returns 0 if the MBR with the provided partition array is a GPT protective
 * MBR, and returns 1 otherwise. A GPT protective MBR would have one and only
 * one MBR partition, an EFI partition that either covers the whole disk or as
 * much of it as is possible with a 32bit size field.
 *
 * NOTE: MS always uses a size of UINT32_MAX for the EFI partition!**
 */
int
gpt_chk_mbr(struct dos_partition *dp, u_int64_t dsize)
{
	struct dos_partition *dp2;
	int efi, found, i;
	u_int32_t psize;

	found = efi = 0;
	for (dp2=dp, i=0; i < NDOSPART; i++, dp2++) {
		if (dp2->dp_typ == DOSPTYP_UNUSED)
			continue;
		found++;
		if (dp2->dp_typ != DOSPTYP_EFI)
			continue;
		psize = letoh32(dp2->dp_size);
		if (psize == (dsize - 1) ||
		    psize == UINT32_MAX) {
			if (letoh32(dp2->dp_start) == 1)
				efi++;
		}
	}
	if (found == 1 && efi == 1)
		return (0);

	return (1);
}

int
gpt_chk_hdr(struct gpt_header *gh, struct disklabel *lp)
{
	uint64_t ghpartlba;
	uint64_t ghlbaend, ghlbastart;
	uint32_t orig_gh_csum;
	uint32_t ghsize, ghpartsize, ghpartspersec;

	if (letoh64(gh->gh_sig) != GPTSIGNATURE)
		return (EINVAL);

	if (letoh32(gh->gh_rev) != GPTREVISION)
		return (EINVAL);

	ghsize = letoh32(gh->gh_size);
	ghpartsize = letoh32(gh->gh_part_size);
	ghpartspersec = lp->d_secsize / ghpartsize;
	ghpartlba = letoh64(gh->gh_part_lba);
	ghlbaend = letoh64(gh->gh_lba_end);
	ghlbastart = letoh64(gh->gh_lba_start);

	if (ghsize < GPTMINHDRSIZE || ghsize > sizeof(struct gpt_header))
		return (EINVAL);

	orig_gh_csum = gh->gh_csum;
	gh->gh_csum = 0;
	gh->gh_csum = crc32(0, (unsigned char *)gh, ghsize);

	if (orig_gh_csum != gh->gh_csum)
		return (EINVAL);

	if (ghlbastart >= DL_GETDSIZE(lp) ||
	    ghlbaend >= DL_GETDSIZE(lp) ||
	    ghpartlba >= DL_GETDSIZE(lp))
		return (EINVAL);

	/*
	* Size per partition entry shall be 128*(2**n) with n >= 0.
	* We don't support partition entries larger than block size.
	*/
	if (ghpartsize % GPTMINPARTSIZE || ghpartsize > lp->d_secsize
	    || ghpartspersec == 0) {
		DPRINTF("invalid partition size\n");
		return (EINVAL);
	}

	/* XXX: we don't support multiples of GPTMINPARTSIZE yet */
	if (ghpartsize != GPTMINPARTSIZE) {
		DPRINTF("partition sizes larger than %d bytes are not "
		    "supported", GPTMINPARTSIZE);
		return (EINVAL);
	}

	if (letoh64(gh->gh_lba_alt) >= DL_GETDSIZE(lp)) {
		DPRINTF("alternate header's position is bogus\n");
		return (EINVAL);
	}

	return 0;
}

int
gpt_chk_parts(struct gpt_header *gh, struct gpt_partition *gp)
{
	u_int32_t checksum;
	checksum = crc32(0, (unsigned char *)gp,
	    letoh32(gh->gh_part_num) * letoh32(gh->gh_part_size));

	if (checksum != gh->gh_part_csum)
		return (EINVAL);

	return 0;
}

int
gpt_get_fstype(struct uuid *uuid_part)
{
	static int init = 0;
	static struct uuid uuid_openbsd, uuid_msdos, uuid_chromefs,
	    uuid_linux, uuid_hfs, uuid_unused, uuid_efi_system;
	static const uint8_t gpt_uuid_openbsd[] = GPT_UUID_OPENBSD;
	static const uint8_t gpt_uuid_msdos[] = GPT_UUID_MSDOS;
	static const uint8_t gpt_uuid_chromerootfs[] = GPT_UUID_CHROMEROOTFS;
	static const uint8_t gpt_uuid_linux[] = GPT_UUID_LINUX;
	static const uint8_t gpt_uuid_hfs[] = GPT_UUID_APPLE_HFS;
	static const uint8_t gpt_uuid_unused[] = GPT_UUID_UNUSED;
	static const uint8_t gpt_uuid_efi_system[] = GPT_UUID_EFI_SYSTEM;

	if (init == 0) {
		uuid_dec_be(gpt_uuid_openbsd, &uuid_openbsd);
		uuid_dec_be(gpt_uuid_msdos, &uuid_msdos);
		uuid_dec_be(gpt_uuid_chromerootfs, &uuid_chromefs);
		uuid_dec_be(gpt_uuid_linux, &uuid_linux);
		uuid_dec_be(gpt_uuid_hfs, &uuid_hfs);
		uuid_dec_be(gpt_uuid_unused, &uuid_unused);
		uuid_dec_be(gpt_uuid_efi_system, &uuid_efi_system);
		init = 1;
	}

	if (!memcmp(uuid_part, &uuid_unused, sizeof(struct uuid)))
		return FS_UNUSED;
	else if (!memcmp(uuid_part, &uuid_openbsd, sizeof(struct uuid)))
		return FS_BSDFFS;
	else if (!memcmp(uuid_part, &uuid_msdos, sizeof(struct uuid)))
		return FS_MSDOS;
	else if (!memcmp(uuid_part, &uuid_chromefs, sizeof(struct uuid)))
		return FS_EXT2FS;
	else if (!memcmp(uuid_part, &uuid_linux, sizeof(struct uuid)))
		return FS_EXT2FS;
	else if (!memcmp(uuid_part, &uuid_hfs, sizeof(struct uuid)))
		return FS_HFS;
	else if (!memcmp(uuid_part, &uuid_efi_system, sizeof(struct uuid)))
		return FS_MSDOS;
	else
		return FS_OTHER;
}

/*
 * Spoof a disklabel based on the GPT information on the disk.
 */
int
spoofgptlabel(struct buf *bp, void (*strat)(struct buf *),
    struct disklabel *lp)
{
	static const u_int8_t gpt_uuid_openbsd[] = GPT_UUID_OPENBSD;
	struct gpt_header gh;
	struct uuid uuid_part, uuid_openbsd;
	struct gpt_partition *gp, *gp_tmp;
	struct partition *pp;
	size_t gpsz;
	u_int64_t ghlbaend, ghlbastart, gptpartoff, gptpartend, sector;
	u_int64_t start, end;
	int i, altheader = 0, error, n;
	uint32_t ghpartnum;

	uuid_dec_be(gpt_uuid_openbsd, &uuid_openbsd);

	for (sector = GPTSECTOR; ; sector = DL_GETDSIZE(lp)-1, altheader = 1) {
		uint64_t ghpartlba;
		uint32_t ghpartsize;
		uint32_t ghpartspersec;

		error = readdisksector(bp, strat, lp, sector);
		if (error) {
			DPRINTF("error reading from disk\n");
			return (error);
		}

		bcopy(bp->b_data, &gh, sizeof(gh));

		if (gpt_chk_hdr(&gh, lp)) {
			if (altheader) {
				DPRINTF("alternate header also broken\n");
				return (EINVAL);
			}
			continue;
		}

		ghpartsize = letoh32(gh.gh_part_size);
		ghpartspersec = lp->d_secsize / ghpartsize;
		ghpartnum = letoh32(gh.gh_part_num);
		ghpartlba = letoh64(gh.gh_part_lba);
		ghlbaend = letoh64(gh.gh_lba_end);
		ghlbastart = letoh64(gh.gh_lba_start);

		/* read GPT partition entry array */
		gp = mallocarray(ghpartnum, sizeof(struct gpt_partition),
		    M_DEVBUF, M_NOWAIT|M_ZERO);
		if (gp == NULL)
			return (ENOMEM);
		gpsz = ghpartnum * sizeof(struct gpt_partition);

		/*
		* XXX:	Fails if # of partition entries is not a multiple of
		*	ghpartspersec.
		*/
		sector = ghpartlba;
		for (i = 0; i < ghpartnum / ghpartspersec; i++, sector++) {
			error = readdisksector(bp, strat, lp, sector);
			if (error) {
				free(gp, M_DEVBUF, gpsz);
				return (error);
			}

			bcopy(bp->b_data, gp + i * ghpartspersec,
			    ghpartspersec * sizeof(struct gpt_partition));
		}

		if (gpt_chk_parts(&gh, gp)) {
			free(gp, M_DEVBUF, gpsz);
			if (altheader) {
				DPRINTF("alternate partition entries are also "
				    "broken\n");
				return (EINVAL);
			}
			continue;
		}
		break;
	}

	/* Find OpenBSD partition and spoof others along the way. */
	n = 0;
	gptpartoff = 0;
	gptpartend = DL_GETBEND(lp);
	for (gp_tmp = gp, i = 0; i < ghpartnum; gp_tmp++, i++) {
		start = letoh64(gp_tmp->gp_lba_start);
		end = letoh64(gp_tmp->gp_lba_end);
		if (start > end || start < ghlbastart || end > ghlbaend)
			continue; /* entry invalid */

		uuid_dec_le(&gp_tmp->gp_type, &uuid_part);
		if (!memcmp(&uuid_part, &uuid_openbsd, sizeof(struct uuid))) {
			if (gptpartoff == 0) {
				gptpartoff = start;
				gptpartend = end + 1;
			}
			continue; /* Do *NOT* spoof OpenBSD partitions! */
		}

		 /*
		 * Don't try to spoof more than 8 partitions, i.e.
		 * 'i' -'p'.
		 */
		if (n >= 8)
			continue;

		pp = &lp->d_partitions[8+n];
		n++;
		pp->p_fstype = gpt_get_fstype(&uuid_part);
		DL_SETPOFFSET(pp, start);
		DL_SETPSIZE(pp, end - start + 1);
	}

	free(gp, M_DEVBUF, gpsz);

	DL_SETBSTART(lp, gptpartoff);
	DL_SETBEND(lp, (gptpartend < DL_GETDSIZE(lp)) ? gptpartend :
	    DL_GETDSIZE(lp));

	return (0);
}

/*
 * Check new disk label for sensibility before setting it.
 */
int
setdisklabel(struct disklabel *olp, struct disklabel *nlp, u_int openmask)
{
	struct partition *opp, *npp;
	struct disk *dk;
	int i;

	/* sanity clause */
	if (nlp->d_secpercyl == 0 || nlp->d_secsize == 0 ||
	    (nlp->d_secsize % DEV_BSIZE) != 0)
		return (EINVAL);

	/* special case to allow disklabel to be invalidated */
	if (nlp->d_magic == 0xffffffff) {
		*olp = *nlp;
		return (0);
	}

	if (nlp->d_magic != DISKMAGIC || nlp->d_magic2 != DISKMAGIC ||
	    dkcksum(nlp) != 0)
		return (EINVAL);

	/* XXX missing check if other dos partitions will be overwritten */

	for (i = 0; i < MAXPARTITIONS; i++) {
		opp = &olp->d_partitions[i];
		npp = &nlp->d_partitions[i];
		if ((openmask & (1 << i)) &&
		    (DL_GETPOFFSET(npp) != DL_GETPOFFSET(opp) ||
		    DL_GETPSIZE(npp) < DL_GETPSIZE(opp)))
			return (EBUSY);
		/*
		 * Copy internally-set partition information
		 * if new label doesn't include it.		XXX
		 */
		if (npp->p_fstype == FS_UNUSED && opp->p_fstype != FS_UNUSED) {
			npp->p_fragblock = opp->p_fragblock;
			npp->p_cpg = opp->p_cpg;
		}
	}

	/* Generate a UID if the disklabel does not already have one. */
	if (duid_iszero(nlp->d_uid)) {
		do {
			arc4random_buf(nlp->d_uid, sizeof(nlp->d_uid));
			TAILQ_FOREACH(dk, &disklist, dk_link)
				if (dk->dk_label &&
				    duid_equal(dk->dk_label->d_uid, nlp->d_uid))
					break;
		} while (dk != NULL || duid_iszero(nlp->d_uid));
	}

	/* Preserve the disk size and RAW_PART values. */
	DL_SETDSIZE(nlp, DL_GETDSIZE(olp));
	npp = &nlp->d_partitions[RAW_PART];
	DL_SETPOFFSET(npp, 0);
	DL_SETPSIZE(npp, DL_GETDSIZE(nlp));

	nlp->d_checksum = 0;
	nlp->d_checksum = dkcksum(nlp);
	*olp = *nlp;

	disk_change = 1;

	return (0);
}

/*
 * Determine the size of the transfer, and make sure it is within the
 * boundaries of the partition. Adjust transfer if needed, and signal errors or
 * early completion.
 */
int
bounds_check_with_label(struct buf *bp, struct disklabel *lp)
{
	struct partition *p = &lp->d_partitions[DISKPART(bp->b_dev)];
	daddr_t partblocks, sz;

	/* Avoid division by zero, negative offsets, and negative sizes. */
	if (lp->d_secpercyl == 0 || bp->b_blkno < 0 || bp->b_bcount < 0)
		goto bad;

	/* Ensure transfer is a whole number of aligned sectors. */
	if ((bp->b_blkno % DL_BLKSPERSEC(lp)) != 0 ||
	    (bp->b_bcount % lp->d_secsize) != 0)
		goto bad;

	/* Ensure transfer starts within partition boundary. */
	partblocks = DL_SECTOBLK(lp, DL_GETPSIZE(p));
	if (bp->b_blkno > partblocks)
		goto bad;

	/* If exactly at end of partition or null transfer, return EOF. */
	if (bp->b_blkno == partblocks || bp->b_bcount == 0)
		goto done;

	/* Truncate request if it extends past the end of the partition. */
	sz = bp->b_bcount >> DEV_BSHIFT;
	if (sz > partblocks - bp->b_blkno) {
		sz = partblocks - bp->b_blkno;
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	return (0);

 bad:
	bp->b_error = EINVAL;
	bp->b_flags |= B_ERROR;
 done:
	bp->b_resid = bp->b_bcount;
	return (-1);
}

/*
 * Disk error is the preface to plaintive error messages
 * about failing disk transfers.  It prints messages of the form

hp0g: hard error reading fsbn 12345 of 12344-12347 (hp0 bn %d cn %d tn %d sn %d)

 * if the offset of the error in the transfer and a disk label
 * are both available.  blkdone should be -1 if the position of the error
 * is unknown; the disklabel pointer may be null from drivers that have not
 * been converted to use them.  The message is printed with printf
 * if pri is LOG_PRINTF, otherwise it uses log at the specified priority.
 * The message should be completed (with at least a newline) with printf
 * or addlog, respectively.  There is no trailing space.
 */
void
diskerr(struct buf *bp, char *dname, char *what, int pri, int blkdone,
    struct disklabel *lp)
{
	int unit = DISKUNIT(bp->b_dev), part = DISKPART(bp->b_dev);
	int (*pr)(const char *, ...) __attribute__((__format__(__kprintf__,1,2)));
	char partname = 'a' + part;
	daddr_t sn;

	if (pri != LOG_PRINTF) {
		log(pri, "%s", "");
		pr = addlog;
	} else
		pr = printf;
	(*pr)("%s%d%c: %s %sing fsbn ", dname, unit, partname, what,
	    bp->b_flags & B_READ ? "read" : "writ");
	sn = bp->b_blkno;
	if (bp->b_bcount <= DEV_BSIZE)
		(*pr)("%lld", (long long)sn);
	else {
		if (blkdone >= 0) {
			sn += blkdone;
			(*pr)("%lld of ", (long long)sn);
		}
		(*pr)("%lld-%lld", (long long)bp->b_blkno,
		    (long long)(bp->b_blkno + (bp->b_bcount - 1) / DEV_BSIZE));
	}
	if (lp && (blkdone >= 0 || bp->b_bcount <= lp->d_secsize)) {
		sn += DL_SECTOBLK(lp, DL_GETPOFFSET(&lp->d_partitions[part]));
		(*pr)(" (%s%d bn %lld; cn %lld", dname, unit, (long long)sn,
		    (long long)(sn / DL_SECTOBLK(lp, lp->d_secpercyl)));
		sn %= DL_SECTOBLK(lp, lp->d_secpercyl);
		(*pr)(" tn %lld sn %lld)",
		    (long long)(sn / DL_SECTOBLK(lp, lp->d_nsectors)),
		    (long long)(sn % DL_SECTOBLK(lp, lp->d_nsectors)));
	}
}

/*
 * Initialize the disklist.  Called by main() before autoconfiguration.
 */
void
disk_init(void)
{

	TAILQ_INIT(&disklist);
	disk_count = disk_change = 0;
}

int
disk_construct(struct disk *diskp)
{
	rw_init_flags(&diskp->dk_lock, "dklk", RWL_IS_VNODE);
	mtx_init(&diskp->dk_mtx, IPL_BIO);

	diskp->dk_flags |= DKF_CONSTRUCTED;

	return (0);
}

/*
 * Attach a disk.
 */
void
disk_attach(struct device *dv, struct disk *diskp)
{
	int majdev;

	if (!ISSET(diskp->dk_flags, DKF_CONSTRUCTED))
		disk_construct(diskp);

	/*
	 * Allocate and initialize the disklabel structures.  Note that
	 * it's not safe to sleep here, since we're probably going to be
	 * called during autoconfiguration.
	 */
	diskp->dk_label = malloc(sizeof(struct disklabel), M_DEVBUF,
	    M_NOWAIT|M_ZERO);
	if (diskp->dk_label == NULL)
		panic("disk_attach: can't allocate storage for disklabel");

	/*
	 * Set the attached timestamp.
	 */
	microuptime(&diskp->dk_attachtime);

	/*
	 * Link into the disklist.
	 */
	TAILQ_INSERT_TAIL(&disklist, diskp, dk_link);
	++disk_count;
	disk_change = 1;

	/*
	 * Store device structure and number for later use.
	 */
	diskp->dk_device = dv;
	diskp->dk_devno = NODEV;
	if (dv != NULL) {
		majdev = findblkmajor(dv);
		if (majdev >= 0)
			diskp->dk_devno =
			    MAKEDISKDEV(majdev, dv->dv_unit, RAW_PART);

		if (diskp->dk_devno != NODEV) {
			struct disk_attach_task *dat;

			dat = malloc(sizeof(*dat), M_TEMP, M_WAITOK);

			/* XXX: Assumes dk is part of the device softc. */
			device_ref(dv);
			dat->dk = diskp;

			task_set(&dat->task, disk_attach_callback, dat);
			task_add(systq, &dat->task);
		}
	}

	if (softraid_disk_attach)
		softraid_disk_attach(diskp, 1);
}

void
disk_attach_callback(void *xdat)
{
	struct disk_attach_task *dat = xdat;
	struct disk *dk = dat->dk;
	struct disklabel dl;
	char errbuf[100];

	free(dat, M_TEMP, sizeof(*dat));

	if (dk->dk_flags & (DKF_OPENED | DKF_NOLABELREAD))
		goto done;

	/* Read disklabel. */
	if (disk_readlabel(&dl, dk->dk_devno, errbuf, sizeof(errbuf)) == NULL) {
		add_timer_randomness(dl.d_checksum);
		dk->dk_flags |= DKF_LABELVALID;
	}

done:
	dk->dk_flags |= DKF_OPENED;
	device_unref(dk->dk_device);
	wakeup(dk);
}

/*
 * Detach a disk.
 */
void
disk_detach(struct disk *diskp)
{

	if (softraid_disk_attach)
		softraid_disk_attach(diskp, -1);

	/*
	 * Free the space used by the disklabel structures.
	 */
	free(diskp->dk_label, M_DEVBUF, sizeof(*diskp->dk_label));

	/*
	 * Remove from the disklist.
	 */
	TAILQ_REMOVE(&disklist, diskp, dk_link);
	disk_change = 1;
	if (--disk_count < 0)
		panic("disk_detach: disk_count < 0");
}

int
disk_openpart(struct disk *dk, int part, int fmt, int haslabel)
{
	KASSERT(part >= 0 && part < MAXPARTITIONS);

	/* Unless opening the raw partition, check that the partition exists. */
	if (part != RAW_PART && (!haslabel ||
	    part >= dk->dk_label->d_npartitions ||
	    dk->dk_label->d_partitions[part].p_fstype == FS_UNUSED))
		return (ENXIO);

	/* Ensure the partition doesn't get changed under our feet. */
	switch (fmt) {
	case S_IFCHR:
		dk->dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		dk->dk_bopenmask |= (1 << part);
		break;
	}
	dk->dk_openmask = dk->dk_copenmask | dk->dk_bopenmask;

	return (0);
}

void
disk_closepart(struct disk *dk, int part, int fmt)
{
	KASSERT(part >= 0 && part < MAXPARTITIONS);

	switch (fmt) {
	case S_IFCHR:
		dk->dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		dk->dk_bopenmask &= ~(1 << part);
		break;
	}
	dk->dk_openmask = dk->dk_copenmask | dk->dk_bopenmask;
}

void
disk_gone(int (*open)(dev_t, int, int, struct proc *), int unit)
{
	int bmaj, cmaj, mn;

	/* Locate the lowest minor number to be detached. */
	mn = DISKMINOR(unit, 0);

	for (bmaj = 0; bmaj < nblkdev; bmaj++)
		if (bdevsw[bmaj].d_open == open)
			vdevgone(bmaj, mn, mn + MAXPARTITIONS - 1, VBLK);
	for (cmaj = 0; cmaj < nchrdev; cmaj++)
		if (cdevsw[cmaj].d_open == open)
			vdevgone(cmaj, mn, mn + MAXPARTITIONS - 1, VCHR);
}

/*
 * Increment a disk's busy counter.  If the counter is going from
 * 0 to 1, set the timestamp.
 */
void
disk_busy(struct disk *diskp)
{

	/*
	 * XXX We'd like to use something as accurate as microtime(),
	 * but that doesn't depend on the system TOD clock.
	 */
	mtx_enter(&diskp->dk_mtx);
	if (diskp->dk_busy++ == 0)
		microuptime(&diskp->dk_timestamp);
	mtx_leave(&diskp->dk_mtx);
}

/*
 * Decrement a disk's busy counter, increment the byte count, total busy
 * time, and reset the timestamp.
 */
void
disk_unbusy(struct disk *diskp, long bcount, daddr_t blkno, int read)
{
	struct timeval dv_time, diff_time;

	mtx_enter(&diskp->dk_mtx);

	if (diskp->dk_busy-- == 0)
		printf("disk_unbusy: %s: dk_busy < 0\n", diskp->dk_name);

	microuptime(&dv_time);

	timersub(&dv_time, &diskp->dk_timestamp, &diff_time);
	timeradd(&diskp->dk_time, &diff_time, &diskp->dk_time);

	diskp->dk_timestamp = dv_time;
	if (bcount > 0) {
		if (read) {
			diskp->dk_rbytes += bcount;
			diskp->dk_rxfer++;
		} else {
			diskp->dk_wbytes += bcount;
			diskp->dk_wxfer++;
		}
	} else
		diskp->dk_seek++;

	mtx_leave(&diskp->dk_mtx);

	add_disk_randomness(bcount ^ diff_time.tv_usec ^
	    (blkno >> 32) ^ (blkno & 0xffffffff));
}

int
disk_lock(struct disk *dk)
{
	return (rw_enter(&dk->dk_lock, RW_WRITE|RW_INTR));
}

void
disk_lock_nointr(struct disk *dk)
{
	rw_enter_write(&dk->dk_lock);
}

void
disk_unlock(struct disk *dk)
{
	rw_exit_write(&dk->dk_lock);
}

int
dk_mountroot(void)
{
	char errbuf[100];
	int part = DISKPART(rootdev);
	int (*mountrootfn)(void);
	struct disklabel dl;
	char *error;

	error = disk_readlabel(&dl, rootdev, errbuf, sizeof(errbuf));
	if (error)
		panic("%s", error);

	if (DL_GETPSIZE(&dl.d_partitions[part]) == 0)
		panic("root filesystem has size 0");
	switch (dl.d_partitions[part].p_fstype) {
#ifdef EXT2FS
	case FS_EXT2FS:
		{
		extern int ext2fs_mountroot(void);
		mountrootfn = ext2fs_mountroot;
		}
		break;
#endif
#ifdef FFS
	case FS_BSDFFS:
		{
		extern int ffs_mountroot(void);
		mountrootfn = ffs_mountroot;
		}
		break;
#endif
#ifdef CD9660
	case FS_ISO9660:
		{
		extern int cd9660_mountroot(void);
		mountrootfn = cd9660_mountroot;
		}
		break;
#endif
	default:
#ifdef FFS
		{
		extern int ffs_mountroot(void);

		printf("filesystem type %d not known.. assuming ffs\n",
		    dl.d_partitions[part].p_fstype);
		mountrootfn = ffs_mountroot;
		}
#else
		panic("disk 0x%x filesystem type %d not known",
		    rootdev, dl.d_partitions[part].p_fstype);
#endif
	}
	return (*mountrootfn)();
}

struct device *
getdisk(char *str, int len, int defpart, dev_t *devp)
{
	struct device *dv;

	if ((dv = parsedisk(str, len, defpart, devp)) == NULL) {
		printf("use one of: exit");
		TAILQ_FOREACH(dv, &alldevs, dv_list) {
			if (dv->dv_class == DV_DISK)
				printf(" %s[a-p]", dv->dv_xname);
#if defined(NFSCLIENT)
			if (dv->dv_class == DV_IFNET)
				printf(" %s", dv->dv_xname);
#endif
		}
		printf("\n");
	}
	return (dv);
}

struct device *
parsedisk(char *str, int len, int defpart, dev_t *devp)
{
	struct device *dv;
	int majdev, part = defpart;
	char c;

	if (len == 0)
		return (NULL);
	c = str[len-1];
	if (c >= 'a' && (c - 'a') < MAXPARTITIONS) {
		part = c - 'a';
		len -= 1;
	}

	TAILQ_FOREACH(dv, &alldevs, dv_list) {
		if (dv->dv_class == DV_DISK &&
		    strncmp(str, dv->dv_xname, len) == 0 &&
		    dv->dv_xname[len] == '\0') {
			majdev = findblkmajor(dv);
			if (majdev < 0)
				return NULL;
			*devp = MAKEDISKDEV(majdev, dv->dv_unit, part);
			break;
		}
#if defined(NFSCLIENT)
		if (dv->dv_class == DV_IFNET &&
		    strncmp(str, dv->dv_xname, len) == 0 &&
		    dv->dv_xname[len] == '\0') {
			*devp = NODEV;
			break;
		}
#endif
	}

	return (dv);
}

void
setroot(struct device *bootdv, int part, int exitflags)
{
	int majdev, unit, len, s, slept = 0;
	struct swdevt *swp;
	struct device *rootdv, *dv;
	dev_t nrootdev, nswapdev = NODEV, temp = NODEV;
	struct ifnet *ifp = NULL;
	struct disk *dk;
	char buf[128];
#if defined(NFSCLIENT)
	extern char *nfsbootdevname;
#endif

	/* Ensure that all disk attach callbacks have completed. */
	do {
		TAILQ_FOREACH(dk, &disklist, dk_link) {
			if (dk->dk_devno != NODEV &&
			    (dk->dk_flags & DKF_OPENED) == 0) {
				tsleep(dk, 0, "dkopen", hz);
				slept++;
				break;
			}
		}
	} while (dk != NULL && slept < 5);

	if (slept == 5) {
		printf("disklabels not read:");
		TAILQ_FOREACH(dk, &disklist, dk_link)
			if (dk->dk_devno != NODEV &&
			    (dk->dk_flags & DKF_OPENED) == 0)
				printf(" %s", dk->dk_name);
		printf("\n");
	}

	if (duid_iszero(bootduid)) {
		/* Locate DUID for boot disk since it was not provided. */
		TAILQ_FOREACH(dk, &disklist, dk_link)
			if (dk->dk_device == bootdv)
				break;
		if (dk && (dk->dk_flags & DKF_LABELVALID))
			bcopy(dk->dk_label->d_uid, bootduid, sizeof(bootduid));
	} else if (bootdv == NULL) {
		/* Locate boot disk based on the provided DUID. */
		TAILQ_FOREACH(dk, &disklist, dk_link)
			if (duid_equal(dk->dk_label->d_uid, bootduid))
				break;
		if (dk && (dk->dk_flags & DKF_LABELVALID))
			bootdv = dk->dk_device;
	}
	bcopy(bootduid, rootduid, sizeof(rootduid));

#if NSOFTRAID > 0
	sr_map_root();
#endif

	/*
	 * If `swap generic' and we couldn't determine boot device,
	 * ask the user.
	 */
	dk = NULL;
	if (mountroot == NULL && bootdv == NULL)
		boothowto |= RB_ASKNAME;
	if (boothowto & RB_ASKNAME) {
		while (1) {
			printf("root device");
			if (bootdv != NULL) {
				printf(" (default %s", bootdv->dv_xname);
				if (bootdv->dv_class == DV_DISK)
					printf("%c", 'a' + part);
				printf(")");
			}
			printf(": ");
			s = splhigh();
			cnpollc(1);
			len = getsn(buf, sizeof(buf));
			cnpollc(0);
			splx(s);
			if (strcmp(buf, "exit") == 0)
				reboot(exitflags);
			if (len == 0 && bootdv != NULL) {
				strlcpy(buf, bootdv->dv_xname, sizeof buf);
				len = strlen(buf);
			}
			if (len > 0 && buf[len - 1] == '*') {
				buf[--len] = '\0';
				dv = getdisk(buf, len, part, &nrootdev);
				if (dv != NULL) {
					rootdv = dv;
					nswapdev = nrootdev;
					goto gotswap;
				}
			}
			dv = getdisk(buf, len, part, &nrootdev);
			if (dv != NULL) {
				rootdv = dv;
				break;
			}
		}

		if (rootdv->dv_class == DV_IFNET)
			goto gotswap;

		/* try to build swap device out of new root device */
		while (1) {
			printf("swap device");
			if (rootdv != NULL)
				printf(" (default %s%s)", rootdv->dv_xname,
				    rootdv->dv_class == DV_DISK ? "b" : "");
			printf(": ");
			s = splhigh();
			cnpollc(1);
			len = getsn(buf, sizeof(buf));
			cnpollc(0);
			splx(s);
			if (strcmp(buf, "exit") == 0)
				reboot(exitflags);
			if (len == 0 && rootdv != NULL) {
				switch (rootdv->dv_class) {
				case DV_IFNET:
					nswapdev = NODEV;
					break;
				case DV_DISK:
					nswapdev = MAKEDISKDEV(major(nrootdev),
					    DISKUNIT(nrootdev), 1);
					if (nswapdev == nrootdev)
						continue;
					break;
				default:
					break;
				}
				break;
			}
			dv = getdisk(buf, len, 1, &nswapdev);
			if (dv) {
				if (dv->dv_class == DV_IFNET)
					nswapdev = NODEV;
				if (nswapdev == nrootdev)
					continue;
				break;
			}
		}
gotswap:
		rootdev = nrootdev;
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		swdevt[1].sw_dev = NODEV;
#if defined(NFSCLIENT)
	} else if (mountroot == nfs_mountroot) {
		rootdv = bootdv;
		rootdev = dumpdev = swapdev = NODEV;
#endif
	} else if (mountroot == NULL && rootdev == NODEV) {
		/*
		 * `swap generic'
		 */
		rootdv = bootdv;

		if (bootdv->dv_class == DV_DISK) {
			if (!duid_iszero(rootduid)) {
				TAILQ_FOREACH(dk, &disklist, dk_link)
					if ((dk->dk_flags & DKF_LABELVALID) &&
					    dk->dk_label && duid_equal(
					    dk->dk_label->d_uid, rootduid))
						break;
				if (dk == NULL)
					panic("root device (%s) not found",
					    duid_format(rootduid));
				rootdv = dk->dk_device;
			}
		}

		majdev = findblkmajor(rootdv);
		if (majdev >= 0) {
			/*
			 * Root and swap are on the disk.
			 * Assume swap is on partition b.
			 */
			rootdev = MAKEDISKDEV(majdev, rootdv->dv_unit, part);
			nswapdev = MAKEDISKDEV(majdev, rootdv->dv_unit, 1);
		} else {
			/*
			 * Root and swap are on a net.
			 */
			nswapdev = NODEV;
		}
		dumpdev = nswapdev;
		swdevt[0].sw_dev = nswapdev;
		/* swdevt[1].sw_dev = NODEV; */
	} else {
		/* Completely pre-configured, but we want rootdv .. */
		majdev = major(rootdev);
		if (findblkname(majdev) == NULL)
			return;
		unit = DISKUNIT(rootdev);
		part = DISKPART(rootdev);
		snprintf(buf, sizeof buf, "%s%d%c",
		    findblkname(majdev), unit, 'a' + part);
		rootdv = parsedisk(buf, strlen(buf), 0, &nrootdev);
		if (rootdv == NULL)
			panic("root device (%s) not found", buf);
	}

	if (rootdv && rootdv == bootdv && rootdv->dv_class == DV_IFNET)
		ifp = ifunit(rootdv->dv_xname);
	else if (bootdv && bootdv->dv_class == DV_IFNET)
		ifp = ifunit(bootdv->dv_xname);

	if (ifp)
		if_addgroup(ifp, "netboot");

	switch (rootdv->dv_class) {
#if defined(NFSCLIENT)
	case DV_IFNET:
		mountroot = nfs_mountroot;
		nfsbootdevname = rootdv->dv_xname;
		return;
#endif
	case DV_DISK:
		mountroot = dk_mountroot;
		part = DISKPART(rootdev);
		break;
	default:
		printf("can't figure root, hope your kernel is right\n");
		return;
	}

	printf("root on %s%c", rootdv->dv_xname, 'a' + part);

	if (dk && dk->dk_device == rootdv)
		printf(" (%s.%c)", duid_format(rootduid), 'a' + part);

	/*
	 * Make the swap partition on the root drive the primary swap.
	 */
	for (swp = swdevt; swp->sw_dev != NODEV; swp++) {
		if (major(rootdev) == major(swp->sw_dev) &&
		    DISKUNIT(rootdev) == DISKUNIT(swp->sw_dev)) {
			temp = swdevt[0].sw_dev;
			swdevt[0].sw_dev = swp->sw_dev;
			swp->sw_dev = temp;
			break;
		}
	}
	if (swp->sw_dev != NODEV) {
		/*
		 * If dumpdev was the same as the old primary swap device,
		 * move it to the new primary swap device.
		 */
		if (temp == dumpdev)
			dumpdev = swdevt[0].sw_dev;
	}
	if (swdevt[0].sw_dev != NODEV)
		printf(" swap on %s%d%c", findblkname(major(swdevt[0].sw_dev)),
		    DISKUNIT(swdevt[0].sw_dev),
		    'a' + DISKPART(swdevt[0].sw_dev));
	if (dumpdev != NODEV)
		printf(" dump on %s%d%c", findblkname(major(dumpdev)),
		    DISKUNIT(dumpdev), 'a' + DISKPART(dumpdev));
	printf("\n");
}

extern struct nam2blk nam2blk[];

int
findblkmajor(struct device *dv)
{
	char buf[16], *p;
	int i;

	if (strlcpy(buf, dv->dv_xname, sizeof buf) >= sizeof buf)
		return (-1);
	for (p = buf; *p; p++)
		if (*p >= '0' && *p <= '9')
			*p = '\0';

	for (i = 0; nam2blk[i].name; i++)
		if (!strcmp(buf, nam2blk[i].name))
			return (nam2blk[i].maj);
	return (-1);
}

char *
findblkname(int maj)
{
	int i;

	for (i = 0; nam2blk[i].name; i++)
		if (nam2blk[i].maj == maj)
			return (nam2blk[i].name);
	return (NULL);
}

char *
disk_readlabel(struct disklabel *dl, dev_t dev, char *errbuf, size_t errsize)
{
	struct vnode *vn;
	dev_t chrdev, rawdev;
	int error;

	chrdev = blktochr(dev);
	rawdev = MAKEDISKDEV(major(chrdev), DISKUNIT(chrdev), RAW_PART);

#ifdef DEBUG
	printf("dev=0x%x chrdev=0x%x rawdev=0x%x\n", dev, chrdev, rawdev);
#endif

	if (cdevvp(rawdev, &vn)) {
		snprintf(errbuf, errsize,
		    "cannot obtain vnode for 0x%x/0x%x", dev, rawdev);
		return (errbuf);
	}

	error = VOP_OPEN(vn, FREAD, NOCRED, curproc);
	if (error) {
		snprintf(errbuf, errsize,
		    "cannot open disk, 0x%x/0x%x, error %d",
		    dev, rawdev, error);
		goto done;
	}

	error = VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)dl, FREAD, NOCRED, curproc);
	if (error) {
		snprintf(errbuf, errsize,
		    "cannot read disk label, 0x%x/0x%x, error %d",
		    dev, rawdev, error);
	}
done:
	VOP_CLOSE(vn, FREAD, NOCRED, curproc);
	vput(vn);
	if (error)
		return (errbuf);
	return (NULL);
}

int
disk_map(char *path, char *mappath, int size, int flags)
{
	struct disk *dk, *mdk;
	u_char uid[8];
	char c, part;
	int i;

	/*
	 * Attempt to map a request for a disklabel UID to the correct device.
	 * We should be supplied with a disklabel UID which has the following
	 * format:
	 *
	 * [disklabel uid] . [partition]
	 *
	 * Alternatively, if the DM_OPENPART flag is set the disklabel UID can
	 * based passed on its own.
	 */

	if (strchr(path, '/') != NULL)
		return -1;

	/* Verify that the device name is properly formed. */
	if (!((strlen(path) == 16 && (flags & DM_OPENPART)) ||
	    (strlen(path) == 18 && path[16] == '.')))
		return -1;

	/* Get partition. */
	if (flags & DM_OPENPART)
		part = 'a' + RAW_PART;
	else
		part = path[17];

	if (part < 'a' || part >= 'a' + MAXPARTITIONS)
		return -1;

	/* Derive label UID. */
	memset(uid, 0, sizeof(uid));
	for (i = 0; i < 16; i++) {
		c = path[i];
		if (c >= '0' && c <= '9')
			c -= '0';
		else if (c >= 'a' && c <= 'f')
			c -= ('a' - 10);
		else
			return -1;

		uid[i / 2] <<= 4;
		uid[i / 2] |= c & 0xf;
	}

	mdk = NULL;
	TAILQ_FOREACH(dk, &disklist, dk_link) {
		if ((dk->dk_flags & DKF_LABELVALID) && dk->dk_label &&
		    memcmp(dk->dk_label->d_uid, uid,
		    sizeof(dk->dk_label->d_uid)) == 0) {
			/* Fail if there are duplicate UIDs! */
			if (mdk != NULL)
				return -1;
			mdk = dk;
		}
	}

	if (mdk == NULL || mdk->dk_name == NULL)
		return -1;

	snprintf(mappath, size, "/dev/%s%s%c",
	    (flags & DM_OPENBLCK) ? "" : "r", mdk->dk_name, part);

	return 0;
}

/*
 * Lookup a disk device and verify that it has completed attaching.
 */
struct device *
disk_lookup(struct cfdriver *cd, int unit)
{
	struct device *dv;
	struct disk *dk;

	dv = device_lookup(cd, unit);
	if (dv == NULL)
		return (NULL);

	TAILQ_FOREACH(dk, &disklist, dk_link)
		if (dk->dk_device == dv)
			break;

	if (dk == NULL) {
		device_unref(dv);
		return (NULL);
	}

	return (dv);
}

int
duid_equal(u_char *duid1, u_char *duid2)
{
	return (memcmp(duid1, duid2, DUID_SIZE) == 0);
}

int
duid_iszero(u_char *duid)
{
	u_char zeroduid[DUID_SIZE];

	memset(zeroduid, 0, sizeof(zeroduid));

	return (duid_equal(duid, zeroduid));
}

const char *
duid_format(u_char *duid)
{
	static char duid_str[17];

	snprintf(duid_str, sizeof(duid_str),
	    "%02hx%02hx%02hx%02hx%02hx%02hx%02hx%02hx",
	    duid[0], duid[1], duid[2], duid[3],
	    duid[4], duid[5], duid[6], duid[7]);

	return (duid_str);
}
@


1.229
log
@Tweak lock inits to make the system runnable with witness(4)
on amd64 and i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.228 2016/09/02 09:44:27 tom Exp $	*/
d1248 1
a1248 1
disk_unbusy(struct disk *diskp, long bcount, int read)
d1276 2
a1277 1
	add_disk_randomness(bcount ^ diff_time.tv_usec);
@


1.228
log
@Don't bother with 'ghpartnum' in gpt_chk_hdr(); it's not used

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.227 2016/05/21 14:22:31 jsing Exp $	*/
d1049 1
a1049 1
	rw_init(&diskp->dk_lock, "dklk");
@


1.227
log
@Fix logic bug in DUID generation - we want to generate DUIDs until we have
one that is not a duplicate and not a zero DUID.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.226 2016/05/21 14:00:27 jsing Exp $	*/
d631 1
a631 1
	uint32_t ghsize, ghpartsize, ghpartspersec, ghpartnum;
a641 1
	ghpartnum = letoh32(gh->gh_part_num);
@


1.226
log
@Cleanup some of the DUID code and refactor for readability.

ok krw@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.225 2016/05/20 14:01:27 jsing Exp $	*/
d920 1
a920 1
		} while (dk != NULL && duid_iszero(nlp->d_uid));
@


1.225
log
@Remove dead assignment/unused variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.224 2016/05/19 21:31:04 kettenis Exp $	*/
d90 4
a93 2
u_char	bootduid[8];		/* DUID of boot disk. */
u_char	rootduid[8];		/* DUID of root disk. */
d114 2
a875 1
	u_int64_t uid;
d913 1
a913 2
	uid = 0;
	if (memcmp(nlp->d_uid, &uid, sizeof(nlp->d_uid)) == 0) {
d917 2
a918 2
				if (dk->dk_label && memcmp(dk->dk_label->d_uid,
				    nlp->d_uid, sizeof(nlp->d_uid)) == 0)
d920 1
a920 2
		} while (dk != NULL &&
		    memcmp(nlp->d_uid, &uid, sizeof(nlp->d_uid)) == 0);
a1421 1
	u_char duid[8];
d1448 1
a1448 2
	memset(duid, 0, sizeof(duid));
	if (memcmp(bootduid, duid, sizeof(bootduid)) == 0) {
d1458 1
a1458 2
			if (memcmp(dk->dk_label->d_uid, bootduid,
			    sizeof(bootduid)) == 0)
d1572 1
a1572 2
			memset(&duid, 0, sizeof(duid));
			if (memcmp(rootduid, &duid, sizeof(rootduid)) != 0) {
d1575 2
a1576 2
					    dk->dk_label && memcmp(dk->dk_label->d_uid,
					    &rootduid, sizeof(rootduid)) == 0)
d1579 2
a1580 5
					panic("root device (%02hx%02hx%02hx%02hx"
					    "%02hx%02hx%02hx%02hx) not found",
					    rootduid[0], rootduid[1], rootduid[2],
					    rootduid[3], rootduid[4], rootduid[5],
					    rootduid[6], rootduid[7]);
d1643 1
a1643 4
		printf(" (%02hx%02hx%02hx%02hx%02hx%02hx%02hx%02hx.%c)",
		    rootduid[0], rootduid[1], rootduid[2], rootduid[3],
		    rootduid[4], rootduid[5], rootduid[6], rootduid[7],
		    'a' + part);
d1843 29
@


1.224
log
@Let setroot() pick the boot disk based on the DUID provided in bootduid if
a boot disk has not been selected by its caller.

ok jsing@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.223 2016/02/08 22:12:51 krw Exp $	*/
d1124 1
a1125 2
	struct disklabel dl;
	dev_t dev;
a1132 1
	dev = dk->dk_devno;
@


1.223
log
@"exceeds past the end" -> "extends past the end" in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.222 2015/12/24 20:14:07 krw Exp $	*/
a1449 1
	/* Locate DUID for boot disk if not already provided. */
d1452 1
d1458 8
@


1.222
log
@Make gpt_chk_mbr() instances even more identicaller by always
returning 0 or 1 since only boolean checks of the result are done.
No need for EINVAL as a return value.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.221 2015/12/24 18:03:03 krw Exp $	*/
d966 1
a966 1
	/* Truncate request if it exceeds past the end of the partition. */
@


1.221
log
@Make all instances of gpt_chk_mbr() identical (bar static vs
non-static) by passing disk size as 2nd parameter instead of the
different structures holding the disk size info. The fifth copy of
gpt_chk_mbr() in fdisk is a little specialer. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.220 2015/09/25 11:56:21 krw Exp $	*/
d618 1
a618 1
	return (EINVAL);
@


1.220
log
@Don't immediately try to checksum the GPT header using the size
field from the GPT header being checksum'd. First make sure the
size is in a valid range. In particular ensure it won't cause crc32()
to run off the end of the GPT header being checksum'd. Also check
GPT signature and version first. These checks were inadvertantly
moved after the checksumming.

This should fix the system crash reported by Ze Loff on bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.219 2015/09/24 19:28:33 krw Exp $	*/
d107 1
a107 1
int gpt_chk_mbr(struct dos_partition *, struct disklabel *);
d374 1
a374 1
			if (gpt_chk_mbr(dp, lp) != 0)
d595 1
a595 1
gpt_chk_mbr(struct dos_partition *dp, struct disklabel *lp)
a597 1
	u_int64_t dsize;
a607 1
		dsize = DL_GETDSIZE(lp);
@


1.219
log
@Move declaration of readdisksector() to disklabel.h. This makes it
available to other areas of the kernel suffering from an overburden
of buf tweaking to read a disk sector.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.218 2015/09/24 11:12:56 krw Exp $	*/
d628 1
a628 1
	uint32_t orig_gh_csum = gh->gh_csum;
a630 7
	gh->gh_csum = 0;
	gh->gh_csum = crc32(0, (unsigned char *)gh,
	    letoh32(gh->gh_size));

	if (orig_gh_csum != gh->gh_csum)
		return (EINVAL);

a633 1
	/* we only support version 1.0 */
d645 8
a652 5
	/*
	 * Header size must be greater than or equal to 92 and less
	 * than or equal to the logical block size.
	 */
	if (ghsize < GPTMINHDRSIZE || ghsize > lp->d_secsize)
@


1.218
log
@A couple of missing letoh32() conversions of GPT header fields in
gpt_chk_hdr() and gpt_chk_parts().

Spotted when investigating zeloff's GPT bug report.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.217 2015/09/15 05:35:42 yasuoka Exp $	*/
a104 2
int readdisksector(struct buf *, void (*)(struct buf *), struct disklabel *,
    u_int64_t);
@


1.217
log
@Unbeak boot from GPT partition.  Reported by Henrik Friedrichsen.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.216 2015/09/13 14:38:17 krw Exp $	*/
d634 2
a635 1
	gh->gh_csum = crc32(0, (unsigned char *)gh, gh->gh_size);
d697 1
a697 1
	    gh->gh_part_num * gh->gh_part_size);
@


1.216
log
@Move prototype for spoofgptlabel() from disklabel.h to subr_disk.c.
It's a helper function for readdoslabel(). Not something called
outside of subr_disk.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.215 2015/09/13 12:53:08 krw Exp $	*/
d387 1
a387 1
				dospartoff = DL_GETBEND(gptlp);
@


1.215
log
@Rename readgptlabel() to spoofgptlabel() because that's what we
really want it to do. Handle all the actual disklabel reading in
readdoslabel().  Makes the code much simpler to understand.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.214 2015/09/11 17:51:30 krw Exp $	*/
d107 1
@


1.214
log
@Hoist all the GPT header checks into gpt_chk_header(). Tweak remaining
logic a bit so that an invalid primary header/partition entries
table does not cause readgptlabel() to exit before the secondary
header is tried.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.213 2015/09/11 15:04:01 krw Exp $	*/
d331 1
d374 18
a391 13
			if (gpt_chk_mbr(dp, lp) == 0) {
				error = readgptlabel(bp, strat, lp,
				    partoffp ? &dospartoff : NULL, spoofonly);
				if (error == 0) {
					if (partoffp)
						*partoffp = dospartoff;
					return (0);
				} else {
					/* Restore all potentially tweakee's */
					dospartoff = 0;
					DL_SETBSTART(lp, 0);
					DL_SETBEND(lp, DL_GETDSIZE(lp));
					goto notmbr;
d393 8
d404 1
d747 1
a747 5
 * If gpt partition table requested, attempt to load it and
 * find disklabel inside a GPT partition. Return buffer
 * for use in signalling errors if requested.
 *
 * XXX: readgptlabel() is based on readdoslabel(), so they should be merged
d750 2
a751 2
readgptlabel(struct buf *bp, void (*strat)(struct buf *),
    struct disklabel *lp, daddr_t *partoffp, int spoofonly)
d761 1
a761 1
	int i, altheader = 0, error, n, offset;
a773 2
	/*wrong*/	if (partoffp)
	/*wrong*/		*partoffp = -1;
a808 2
	/*wrong*/		if (partoffp)
	/*wrong*/			*partoffp = -1;
d848 1
a848 10
		/*
		 * In case the disklabel read below fails, we want to
		 * provide a fake label in i-p.
		 */

		/*
		 * Don't set fstype/offset/size when just looking for
		 * the offset of the OpenBSD partition. It would
		 * invalidate the disklabel checksum!
		 *
d852 1
a852 1
		if (partoffp || n >= 8)
a861 3
	if (gptpartoff == 0)
		spoofonly = 1;	/* No disklabel to read from disk. */

d864 3
a866 12
	/* record the OpenBSD partition's placement for the caller */
	if (partoffp)
		*partoffp = DL_SECTOBLK(lp, gptpartoff);
	else {
		DL_SETBSTART(lp, gptpartoff);
		DL_SETBEND(lp, (gptpartend < DL_GETDSIZE(lp)) ? gptpartend :
		    DL_GETDSIZE(lp));
	}

	/* don't read the on-disk label if we are in spoofed-only mode */
	if (spoofonly)
		return (0);
d868 1
a868 11
	error = readdisksector(bp, strat, lp, gptpartoff +
	    DL_BLKTOSEC(lp, DOS_LABELSECTOR));
	if (error)
		return (bp->b_error);

	offset = DL_BLKOFFSET(lp, DOS_LABELSECTOR);
	error = checkdisklabel(bp->b_data + offset, lp,
	    DL_GETBSTART((struct disklabel*)(bp->b_data+offset)),
	    DL_GETBEND((struct disklabel *)(bp->b_data+offset)));

	return (error);
@


1.213
log
@Move all prototypes of gpt helper functions to top of file. Rename
get_fstype() to gpt_get_fstype() as it moves.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.212 2015/09/11 14:54:46 krw Exp $	*/
d109 1
a109 1
int gpt_chk_hdr(struct gpt_header *);
d610 1
a610 1
gpt_chk_hdr(struct gpt_header *gh)
d612 5
a616 1
	u_int32_t orig_gh_csum = gh->gh_csum;
d623 49
a756 1
		uint32_t ghsize;
a768 14
		ghsize = letoh32(gh.gh_size);
		ghpartsize = letoh32(gh.gh_part_size);
		ghpartspersec = lp->d_secsize / ghpartsize;
		ghpartnum = letoh32(gh.gh_part_num);
		ghpartlba = letoh64(gh.gh_part_lba);
		ghlbaend = letoh64(gh.gh_lba_end);
		ghlbastart = letoh64(gh.gh_lba_start);

		if (letoh64(gh.gh_sig) != GPTSIGNATURE)
			return (EINVAL);

		/* we only support version 1.0 */
		if (letoh32(gh.gh_rev) != GPTREVISION)
			return (EINVAL);
d770 1
a770 2
		if (gpt_chk_hdr(&gh)) {
			/* header broken, using alternate header */
a774 7

			if (letoh64(gh.gh_lba_alt) >= DL_GETDSIZE(lp)) {
				DPRINTF("alternate header's position is "
				    "bogus\n");
				return (EINVAL);
			}

d778 6
a783 28
		/*
		 * Header size must be greater than or equal to 92 and less
		 * than or equal to the logical block size.
		 */
		if (ghsize < GPTMINHDRSIZE || ghsize > lp->d_secsize)
			return (EINVAL);

		if (ghlbastart >= DL_GETDSIZE(lp) ||
		    ghlbaend >= DL_GETDSIZE(lp) ||
		    ghpartlba >= DL_GETDSIZE(lp))
			return (EINVAL);

		/*
		* Size per partition entry shall be 128*(2**n) with n >= 0.
		* We don't support partition entries larger than block size.
		*/
		if (ghpartsize % GPTMINPARTSIZE || ghpartsize > lp->d_secsize
		    || ghpartspersec == 0) {
			DPRINTF("invalid partition size\n");
			return (EINVAL);
		}

		/* XXX: we don't support multiples of GPTMINPARTSIZE yet */
		if (ghpartsize != GPTMINPARTSIZE) {
			DPRINTF("partition sizes larger than %d bytes are not "
			    "supported", GPTMINPARTSIZE);
			return (EINVAL);
		}
a810 2
			DPRINTF("partition entries broken, using alternate "
			    "header\n");
a811 1

a816 1

@


1.212
log
@Shuffle some variables around, add a couple, and eliminate hordes
of repeated lehto32() and lehtoh64() in readgptlabel() to make code
more readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.211 2015/09/11 14:14:36 krw Exp $	*/
d107 1
d109 3
a571 4
int gpt_chk_hdr(struct gpt_header *);
int gpt_chk_parts(struct gpt_header *, struct gpt_partition *);
int get_fstype(struct uuid *);

d636 1
a636 1
get_fstype(struct uuid *uuid_part)
d855 1
a855 1
		pp->p_fstype = get_fstype(&uuid_part);
@


1.211
log
@Move initialization of count of spoofed GPT partitions closer
to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.210 2015/09/11 14:08:22 krw Exp $	*/
d695 2
a696 1
	u_int64_t gptpartoff, gptpartend, sector;
d698 1
d703 1
a705 1
		uint32_t ghpartnum;
d721 3
d755 3
a757 3
		if (letoh64(gh.gh_lba_start) >= DL_GETDSIZE(lp) ||
		    letoh64(gh.gh_lba_end) >= DL_GETDSIZE(lp) ||
		    letoh64(gh.gh_part_lba) >= DL_GETDSIZE(lp))
d788 1
a788 1
		sector = letoh64(gh.gh_part_lba);
d822 4
a825 4
	for (gp_tmp = gp, i = 0; i < letoh32(gh.gh_part_num); gp_tmp++, i++) {
		if (letoh64(gp_tmp->gp_lba_start) > letoh64(gp_tmp->gp_lba_end)
		    || letoh64(gp_tmp->gp_lba_start) < letoh64(gh.gh_lba_start)
		    || letoh64(gp_tmp->gp_lba_end) > letoh64(gh.gh_lba_end))
d831 2
a832 2
				gptpartoff = letoh64(gp_tmp->gp_lba_start);
				gptpartend = letoh64(gp_tmp->gp_lba_end) + 1;
d856 2
a857 3
		DL_SETPOFFSET(pp, letoh64(gp_tmp->gp_lba_start));
		DL_SETPSIZE(pp, letoh64(gp_tmp->gp_lba_end)
		    - letoh64(gp_tmp->gp_lba_start) + 1);
@


1.210
log
@GPT partitions cannot start at offset 0. Eliminate the variable
tracking our discovery of the first OpenBSD partition (ourpart) and
just use the variable holding the offset of the first OpenBSD
partition (gptpartoff).

Move initialization of gptpartoff and gptpartend closer to their
use and set them when the first OpenBSD partition is found. Thus
eliminating a later 'if' statement.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.209 2015/09/11 12:40:05 krw Exp $	*/
d696 1
a696 1
	int i, altheader = 0, error, n = 0, offset;
d814 1
@


1.209
log
@KNF shuffling of local declarations in readgptlabel().
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.208 2015/09/11 11:04:40 krw Exp $	*/
d695 2
a696 2
	u_int64_t gptpartoff = 0, gptpartend = DL_GETBEND(lp), sector;
	int i, altheader = 0, error, n = 0, ourpart = -1, offset;
d814 2
d824 4
a827 2
			if (ourpart == -1)
				ourpart = i; /* found it */
d855 1
a855 6
	if (ourpart != -1) {
		/* found our OpenBSD partition, so use it */
		gp_tmp = &gp[ourpart];
		gptpartoff = letoh64(gp_tmp->gp_lba_start);
		gptpartend = letoh64(gp_tmp->gp_lba_end) + 1;
	} else
@


1.208
log
@readgptlabel() is called from readdoslabel() so there is no need
for readgptlable() to re-check that the label d_secpercyl and
d_secsize are not 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.207 2015/09/11 09:44:28 krw Exp $	*/
d689 1
d691 1
d693 1
d695 2
a696 8
	struct uuid uuid_part, uuid_openbsd;
	struct partition *pp;

	u_int64_t sector;
	u_int64_t gptpartoff = 0, gptpartend = DL_GETBEND(lp);
	int i, altheader = 0, error, n=0, ourpart = -1, offset;

	static const u_int8_t gpt_uuid_openbsd[] = GPT_UUID_OPENBSD;
@


1.207
log
@Spoof EFI SYSTEM GPT partitions as MSDOS partitions. As is done
with MBR EFI SYSTEM partitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.206 2015/09/11 09:22:07 krw Exp $	*/
a701 5

	if (lp->d_secpercyl == 0)
		return (EINVAL);	/* invalid label */
	if (lp->d_secsize == 0)
		return (ENOSPC);	/* disk too small */
@


1.206
log
@Eliminate use-once variable in readgptlabel() and just use the
function value the variable was being set to.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.205 2015/09/11 08:06:48 krw Exp $	*/
d640 1
a640 1
	    uuid_linux, uuid_hfs, uuid_unused;
d647 1
d656 1
d672 2
@


1.205
log
@Don't spoof GPT OpenBSD partitions. Simply record and use the first one
found, as is done in MBR processing.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.204 2015/09/10 16:30:23 krw Exp $	*/
a695 1
	u_int8_t fstype;
a834 1
		fstype = get_fstype(&uuid_part);
d849 1
a849 1
		pp->p_fstype = fstype;
@


1.204
log
@Now that the GPT code tries really hard not to get in the way and
accidentally capture disks ...

Eliminate kernel option GPT and associated #ifdef GPT/#endif. Let
everybody get on the GPT bandwagon and we'll see what wheels fly
off.

Requested by & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.203 2015/09/10 14:28:17 krw Exp $	*/
d827 3
a829 1
			ourpart = i; /* found it */
@


1.203
log
@Call readgptlabel() from readdoslabel() instead of MD readdisklabel().

Call it if and only if there is an MBR on sector 0 that contains 1
and only 1 partition; that partition is an EFI partition; and it
covers the entire disk or as much of the disk as can be covered in
an MBR partition.

Be paranoid about restoring any possible tweaks to the label being
built in the case that readgptlabel() fails, and in that case return
to the readdoslabel() code.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.202 2015/09/10 14:11:53 krw Exp $	*/
a68 1
#ifdef GPT
a69 1
#endif
a106 1
#ifdef GPT
a107 1
#endif
a368 1
#ifdef GPT
a383 1
#endif
a567 2
#ifdef GPT

a889 2

#endif
@


1.202
log
@Don't stop spoofing GPT partitions when the OpenBSD partition is
found. Keep going until we spoof 8 or run out of partitions needing
spoofing.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.201 2015/09/09 19:43:26 krw Exp $	*/
d59 1
d109 3
d373 17
d579 37
@


1.201
log
@No need to set d_npartitions in readdoslabel() or readgptlabel().
It has already been initialized in the MD readdisklabel() routines
when they call initdisklabel().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.200 2015/09/01 01:06:35 deraadt Exp $	*/
d768 2
a769 3
	/* find OpenBSD partition */
	for (gp_tmp = gp, i = 0; i < letoh32(gh.gh_part_num) && ourpart == -1;
	    gp_tmp++, i++) {
@


1.200
log
@a white space krw could not see
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.199 2015/09/01 00:27:10 krw Exp $	*/
a484 4
	if (partoffp == NULL)
		/* Must not modify *lp when partoffp is set. */
		lp->d_npartitions = MAXPARTITIONS;

a812 4

	if (!partoffp)
		/* Must not modify *lp when partoffp is set. */
		lp->d_npartitions = MAXPARTITIONS;
@


1.199
log
@'bogous' is bogus spelling of 'bogus' in debug message.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.198 2015/09/01 00:17:15 krw Exp $	*/
d1783 1
a1783 1
                else
@


1.198
log
@Missing letoh64() when checking value of gh_lba_alt.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.197 2015/08/31 15:47:51 krw Exp $	*/
d695 1
a695 1
				    "bogous\n");
@


1.197
log
@Abstract 5 identical code blocks into a readdisksector() function.
Cleaner, clearer and less error prone.

Tested by bmercer@@ as part of a larger diff, of which this is the
last part.

reads ok to jsing@@ kettenis@@. ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.196 2015/08/31 14:02:36 krw Exp $	*/
d693 1
a693 1
			if (gh.gh_lba_alt >= DL_GETDSIZE(lp)) {
@


1.196
log
@Rejig the the expression calculating of the address of the disk
sector containing the disklabel, eliminating an unnecessary " *
DL_BLKSPERSEC()".

Tested by bmercer@@ as part of larger diff.

Idea from & reads ok to jsing@@. ok kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.195 2015/08/30 17:19:51 krw Exp $	*/
d106 3
d297 18
d352 1
a352 7
		bp->b_blkno = DL_SECTOBLK(lp, sector);
		bp->b_bcount = lp->d_secsize;
		bp->b_error = 0; /* B_ERROR and b_error may have stale data. */
		CLR(bp->b_flags, B_READ | B_WRITE | B_DONE | B_ERROR);
		SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
		(*strat)(bp);
		error = biowait(bp);
d544 3
a546 8
	bp->b_blkno = DL_SECTOBLK(lp, dospartoff + DL_BLKTOSEC(lp,
	    DOS_LABELSECTOR));
	bp->b_bcount = lp->d_secsize;
	bp->b_error = 0; /* B_ERROR and b_error may have stale data. */
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE | B_ERROR);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp))
d665 1
a665 9
		/* read header record */
		bp->b_blkno = DL_SECTOBLK(lp, sector);
		bp->b_bcount = lp->d_secsize;
		bp->b_error = 0; /* B_ERROR and b_error may have stale data. */
		CLR(bp->b_flags, B_READ | B_WRITE | B_DONE | B_ERROR);
		SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
		(*strat)(bp);
		error = biowait(bp);

d744 1
a744 9
			/* read partition record */
			bp->b_blkno = DL_SECTOBLK(lp, sector);
			bp->b_bcount = lp->d_secsize;
			/* B_ERROR and b_error may have stale data. */
			bp->b_error = 0;
			CLR(bp->b_flags, B_READ | B_WRITE | B_DONE | B_ERROR);
			SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
			(*strat)(bp);
			error = biowait(bp);
d837 3
a839 8
	bp->b_blkno = DL_SECTOBLK(lp, gptpartoff + DL_BLKTOSEC(lp,
	    DOS_LABELSECTOR));
	bp->b_bcount = lp->d_secsize;
	bp->b_error = 0; /* B_ERROR and b_error may have stale data. */
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE | B_ERROR);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
	(*strat)(bp);
	if (biowait(bp))
@


1.195
log
@In readgptlabel() avoid pointless conversions from sector counts
to daddr_t counts and back again. And rename 'part_blkno' to
'sector' to mirror readdoslabel() changes and make code clearer.

Reads ok to jsing@@ and kettenis@@. Tested by bmercer@@ as part of
larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.194 2015/08/30 15:35:05 krw Exp $	*/
d529 2
a530 2
	bp->b_blkno = DL_BLKTOSEC(lp, DL_SECTOBLK(lp, dospartoff) +
	    DOS_LABELSECTOR) * DL_BLKSPERSEC(lp);
d843 2
a844 2
	bp->b_blkno = DL_BLKTOSEC(lp, DL_SECTOBLK(lp, gptpartoff) +
	    DOS_LABELSECTOR) * DL_BLKSPERSEC(lp);
@


1.194
log
@Eliminate a couple of extraneous DL_SECTOBLK() calls.

The disklabel is either 0 bytes into a 512-byte disk sector, or 512
bytes into a larger disk sector. The address of the disk sector
read is irrelevant.

Pointed out by jsing@@ I think. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.191 2015/08/28 11:12:57 krw Exp $	*/
d635 1
a635 1
	daddr_t part_blkno;
d649 1
a649 2
	for (part_blkno = DL_SECTOBLK(lp, GPTSECTOR); ;
	    part_blkno = DL_SECTOBLK(lp, DL_GETDSIZE(lp)-1), altheader = 1) {
d656 1
a656 1
		bp->b_blkno = DL_BLKTOSEC(lp, part_blkno) * DL_BLKSPERSEC(lp);
d740 2
a741 2
		for (i = 0; i < ghpartnum / ghpartspersec; i++) {
			part_blkno = DL_SECTOBLK(lp, letoh64(gh.gh_part_lba)+i);
d743 1
a743 2
			bp->b_blkno = DL_BLKTOSEC(lp, part_blkno) *
			    DL_BLKSPERSEC(lp);
@


1.193
log
@In readgptlabel() the block offsets of the GPT header and GPT partition
entries within a disk sector are always 0. i.e. both must start on a
sector boundary. So stop calculating the offset value and adding it to
b_data when pulling data out of the buf.

Part of larger refactoring, eyed by jsing@@, tested by bmercer@@ as
part of that larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.192 2015/08/28 22:42:05 krw Exp $	*/
d539 1
a539 2
	offset = DL_BLKOFFSET(lp, DL_SECTOBLK(lp, dospartoff) +
	    DOS_LABELSECTOR);
d855 1
a855 2
	offset = DL_BLKOFFSET(lp, DL_SECTOBLK(lp, gptpartoff) +
	    DOS_LABELSECTOR);
@


1.192
log
@Move label 'offset' calculation out of the buf setup logic and
closer to where it is used. It isn't part of the setup and we want
to abstract the setup.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.191 2015/08/28 11:12:57 krw Exp $	*/
a658 1
		offset = DL_BLKOFFSET(lp, part_blkno);
d673 1
a673 1
		bcopy(bp->b_data + offset, &gh, sizeof(gh));
a746 1
			offset = DL_BLKOFFSET(lp, part_blkno);
d761 1
a761 1
			bcopy(bp->b_data + offset, gp + i * ghpartspersec,
@


1.191
log
@Rename 'part_blkno' to 'sector' as it has not held DEV_BSIZE values in
some time.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.190 2015/08/26 15:36:46 krw Exp $	*/
a530 2
	offset = DL_BLKOFFSET(lp, DL_SECTOBLK(lp, dospartoff) +
	    DOS_LABELSECTOR);
d539 2
a849 2
	offset = DL_BLKOFFSET(lp, DL_SECTOBLK(lp, gptpartoff) +
	    DOS_LABELSECTOR);
d858 2
@


1.190
log
@Enhance setdisklabel() to ensure that the disk size and 'C'
partition information of the in-memory disklabel remains correct.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.189 2015/08/24 23:03:11 krw Exp $	*/
d309 1
a309 1
	daddr_t part_blkno = DOSBBSECTOR;
d327 2
a328 2
		if (part_blkno < extoff)
			part_blkno = extoff;
d331 1
a331 1
		bp->b_blkno = DL_SECTOBLK(lp, part_blkno);
d346 1
a346 1
		if (n == 0 && part_blkno == DOSBBSECTOR) {
d371 1
a371 1
			dospartoff = letoh32(dp2->dp_start) + part_blkno;
d435 1
a435 1
				part_blkno = letoh32(dp2->dp_start) + extoff;
d438 1
a438 1
					part_blkno = 0;
d464 1
a464 1
				    letoh32(dp2->dp_start) + part_blkno);
d474 1
a474 1
	if (n == 0 && part_blkno == DOSBBSECTOR && ourpart == -1) {
@


1.189
log
@Fix GPT code to work with non-DEV_BSIZE disks.

Part of GPT refactoring that was backed out at c2k15.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.188 2015/08/12 22:37:32 krw Exp $	*/
d926 6
@


1.188
log
@Remove last two 'uses' of d_subtype in tree. No point in setting
it to 0 immediately after a bzero() of the entire label. Nor in
swapping endianness since nobody looks at it. Don't touch the actual
field in disklabel. Yet.

ok deraadt@@ as part of larger diff that needs splitting up.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.187 2015/07/29 00:15:36 krw Exp $	*/
d650 2
a651 6
	/*
	 * XXX: We should not trust the primary header and instead
	 * use the last LBA of the disk, as defined in the standard.
	 */
	for (part_blkno = GPTSECTOR; ; part_blkno = gh.gh_lba_alt,
	    altheader = 1) {
d655 1
d677 1
d707 1
a707 1
		if (ghsize < GPTMINHDRSIZE || ghsize > DEV_BSIZE)
d719 2
a720 3
		if (ghpartsize % GPTMINPARTSIZE
		    || ghpartsize > DEV_BSIZE
		    || GPT_PARTSPERSEC(&gh) == 0) {
d726 1
a726 1
		if (letoh32(gh.gh_part_size) != GPTMINPARTSIZE) {
d733 2
a734 1
		gp = mallocarray(ghpartnum, sizeof(struct gpt_partition), M_DEVBUF, M_NOWAIT|M_ZERO);
d740 2
a741 2
		* XXX: Fails if # of partition entries is no multiple of
		* GPT_PARTSPERSEC(&gh)
d743 2
a744 3
		for (i = 0; i < ghpartnum / GPT_PARTSPERSEC(&gh);
		     i++) {
			part_blkno = letoh64(gh.gh_part_lba) + i;
d763 2
a764 3
			bcopy(bp->b_data + offset, gp +
			    i * GPT_PARTSPERSEC(&gh), GPT_PARTSPERSEC(&gh) *
			    sizeof(struct gpt_partition));
@


1.187
log
@Zap a couple of extra blank lines that keep showing up in diffs I'm
trying to build.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.186 2015/07/28 23:10:13 krw Exp $	*/
a198 1
		dlp->d_subtype = swap16(dlp->d_subtype);
@


1.186
log
@Convert sectors to DEV_BSIZE block values were necessary to find,
read and validate disklabels on GPT partitioned disks. Makes it much
more likely GPT partitioned disks with non-512-byte sectors will
work.

Part of the larger reverted GPT work.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.185 2015/07/26 14:01:07 krw Exp $	*/
a541 1

a681 1

@


1.185
log
@Always initialize the b_error field and B_ERROR flag before using
a buf.  Otherwise stale data might cause a successful I/O to be
seen as a failed I/O.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.184 2015/07/23 18:02:59 krw Exp $	*/
d844 1
a844 1
		*partoffp = gptpartoff;
d855 4
a858 3
	bp->b_blkno = DL_BLKTOSEC(lp, gptpartoff + DOS_LABELSECTOR) *
	    DL_BLKSPERSEC(lp);
	offset = DL_BLKOFFSET(lp, gptpartoff + DOS_LABELSECTOR);
d867 5
a871 2
	/* sub-GPT disklabels are always at a LABELOFFSET of 0 */
	return checkdisklabel(bp->b_data + offset, lp, gptpartoff, gptpartend);
@


1.184
log
@Revert attempted GPT code cleanup. Too much code, too little testing.

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.183 2015/05/09 17:11:26 krw Exp $	*/
d535 2
a536 1
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
d859 2
a860 1
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
@


1.183
log
@Cleanup/rejig GPT code to be more readable, support different endian
archs and different sized disk sectors. Make MBR have higher priority
than GPT. Add many paranoia checks and associated DPRINTF's to make
further development easier. Keep everything hidden behind #ifdef
GPT.

Tested and ok doug@@ mpi@@. Nothing bad seen by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.182 2015/03/15 15:13:31 krw Exp $	*/
a516 8
#ifdef GPT
	if (n == 0 && part_blkno == DOSBBSECTOR && ourpart == -1) {
		error = readgptlabel(bp, strat, lp, partoffp, spoofonly);
		if (error == 0)
			return (0);
	}
#endif

d551 16
a566 5
int gpt_get_fstype(struct uuid *);
int gpt_get_hdr(struct buf *, void (*strat)(struct buf *),
    struct disklabel *, u_int64_t, struct gpt_header *);
struct gpt_partition *gpt_get_partition_table(dev_t, void (*)(struct buf *),
    struct disklabel *, struct gpt_header *, u_int64_t *);
d569 14
a582 1
gpt_get_fstype(struct uuid *uuid_part)
d585 2
a586 2
	static struct uuid uuid_openbsd, uuid_msdos, uuid_chromerootfs,
	    uuid_chromekernelfs, uuid_linux, uuid_hfs, uuid_unused;
a589 1
	static const uint8_t gpt_uuid_chromekernelfs[] = GPT_UUID_CHROMEKERNELFS;
d597 1
a597 2
		uuid_dec_be(gpt_uuid_chromerootfs, &uuid_chromerootfs);
		uuid_dec_be(gpt_uuid_chromekernelfs, &uuid_chromekernelfs);
d605 1
a605 1
		return (FS_UNUSED);
d607 1
a607 1
		return (FS_BSDFFS);
d609 3
a611 5
		return (FS_MSDOS);
	else if (!memcmp(uuid_part, &uuid_chromerootfs, sizeof(struct uuid)))
		return (FS_EXT2FS);
	else if (!memcmp(uuid_part, &uuid_chromekernelfs, sizeof(struct uuid)))
		return (FS_MSDOS);
d613 1
a613 1
		return (FS_EXT2FS);
d615 3
a617 200
		return (FS_HFS);
	else {
		DPRINTF("Unknown GUID: %02x%02x%02x%02x-%02x%02x-%02x%02x-"
		    "%02x%02x-%02x%02x%02x%02x%02x%02x\n",
		    *(((u_int8_t *)uuid_part) + 0),
		    *(((u_int8_t *)uuid_part) + 1),
		    *(((u_int8_t *)uuid_part) + 2),
		    *(((u_int8_t *)uuid_part) + 3),
		    *(((u_int8_t *)uuid_part) + 4),
		    *(((u_int8_t *)uuid_part) + 5),
		    *(((u_int8_t *)uuid_part) + 6),
		    *(((u_int8_t *)uuid_part) + 7),
		    *(((u_int8_t *)uuid_part) + 8),
		    *(((u_int8_t *)uuid_part) + 9),
		    *(((u_int8_t *)uuid_part) + 10),
		    *(((u_int8_t *)uuid_part) + 11),
		    *(((u_int8_t *)uuid_part) + 12),
		    *(((u_int8_t *)uuid_part) + 13),
		    *(((u_int8_t *)uuid_part) + 14),
		    *(((u_int8_t *)uuid_part) + 15)
		    );
		return (FS_OTHER);
	}
}

int
gpt_get_hdr(struct buf *bp, void (*strat)(struct buf *),
    struct disklabel *lp, u_int64_t gptlba, struct gpt_header *gh)
{
	u_int64_t partlastlba;
	int error, partspersec;
	u_int32_t orig_gh_csum, new_gh_csum;

	bp->b_blkno = DL_SECTOBLK(lp, gptlba);
	bp->b_bcount = lp->d_secsize;
	bp->b_error = 0; /* B_ERROR and b_error may have stale data. */
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE | B_ERROR);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);

	DPRINTF("gpt header being read from LBA %llu\n", gptlba);

	(*strat)(bp);

	error = biowait(bp);
	if (error) {
		DPRINTF("error reading gpt from disk (%d)\n", error);
		return (1);
	}
	memcpy(gh, bp->b_data, sizeof(struct gpt_header));

	if (letoh64(gh->gh_sig) != GPTSIGNATURE) {
		DPRINTF("gpt signature: expected 0x%llx, got 0x%llx\n",
		    GPTSIGNATURE, letoh64(gh->gh_sig));
		return (1);
	}

	if (letoh32(gh->gh_rev) != GPTREVISION) {
		DPRINTF("gpt revision: expected 0x%x, got 0x%x\n",
		    GPTREVISION, letoh32(gh->gh_rev));
		return (1);
	}

	if (letoh64(gh->gh_lba_self) != gptlba) {
		DPRINTF("gpt self lba: expected %lld, got %llu\n",
		    gptlba, letoh64(gh->gh_lba_self));
		return (1);
	}

	if (letoh32(gh->gh_size) != GPTMINHDRSIZE) {
		DPRINTF("gpt header size: expected %u, got %u\n",
		    GPTMINHDRSIZE, letoh32(gh->gh_size));
		return (1);
	}

	if (letoh32(gh->gh_part_size) != GPTMINPARTSIZE) {
		DPRINTF("gpt partition entry size: expected %u, got %u\n",
		    GPTMINPARTSIZE, letoh32(gh->gh_part_size));
		return (1);
	}

	if (letoh32(gh->gh_part_num) > GPTPARTITIONS) {
		DPRINTF("gpt partition count: expected <= %u, got %u\n",
		    GPTPARTITIONS, letoh32(gh->gh_part_num));
		return (1);
	}

	orig_gh_csum = gh->gh_csum;
	gh->gh_csum = 0;
	new_gh_csum = crc32(0, (unsigned char *)gh, letoh32(gh->gh_size));
	gh->gh_csum = orig_gh_csum;
	if (letoh32(orig_gh_csum) != new_gh_csum) {
		DPRINTF("gpt header checksum: expected 0x%x, got 0x%x\n",
		    new_gh_csum, orig_gh_csum);
		return (1);
	}

	if (letoh64(gh->gh_lba_end) >= DL_GETDSIZE(lp)) {
		DPRINTF("gpt last usable LBA: expected < %lld, got %llu\n",
		    DL_GETDSIZE(lp), letoh64(gh->gh_lba_end));
		return (1);
	}

	if (letoh64(gh->gh_lba_start) >= letoh64(gh->gh_lba_end)) {
		DPRINTF("gpt first usable LBA: expected < %llu, got %llu\n",
		    letoh64(gh->gh_lba_end), letoh64(gh->gh_lba_start));
		return (1);
	}

	if (letoh64(gh->gh_part_lba) <= letoh64(gh->gh_lba_end) &&
	    letoh64(gh->gh_part_lba) >= letoh64(gh->gh_lba_start)) {
		DPRINTF("gpt partition table start LBA: expected < %llu or "
		    "> %llu, got %llu\n", letoh64(gh->gh_lba_start),
		    letoh64(gh->gh_lba_end), letoh64(gh->gh_part_lba));
		return (1);
	}

	partspersec = lp->d_secsize / letoh32(gh->gh_part_size);
	partlastlba = letoh64(gh->gh_part_lba) +
	    ((letoh32(gh->gh_part_num) + partspersec - 1) / partspersec) - 1;
	if (partlastlba <= letoh64(gh->gh_lba_end) &&
	    partlastlba >= letoh64(gh->gh_lba_start)) {
		DPRINTF("gpt partition table last LBA: expected < %llu or "
		    "> %llu, got %llu\n", letoh64(gh->gh_lba_start),
		    letoh64(gh->gh_lba_end), partlastlba);
		return (1);
	}

	/*
	 * Other possible paranoia checks:
	 *	1) partition table starts before primary gpt lba.
	 *	2) partition table extends into lowest partition.
	 *	3) alt partition table starts before gh_lba_end.
	 */
	return (0);
}

struct gpt_partition *
gpt_get_partition_table(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp, struct gpt_header *gh, u_int64_t *gpsz)
{
	struct buf *bp;
	unsigned char *gp;
	int error, secs;
	uint32_t partspersec;
	uint32_t checksum;

	partspersec = lp->d_secsize / letoh32(gh->gh_part_size);
	if (partspersec * letoh32(gh->gh_part_size) != lp->d_secsize) {
		DPRINTF("gpt partition table entry invalid size %u.\n",
		    letoh32(gh->gh_part_size));
		return (NULL);
	}
	secs = (letoh32(gh->gh_part_num) + partspersec - 1) / partspersec;

	gp = mallocarray(secs, lp->d_secsize, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (gp == NULL) {
		DPRINTF("gpt partition table can't be allocated\n");
		return (NULL);
	}
	*gpsz = secs * lp->d_secsize;

	bp = geteblk((int)*gpsz);
	bp->b_dev = dev;

	bp->b_blkno = DL_SECTOBLK(lp, letoh64(gh->gh_part_lba));
	bp->b_bcount = *gpsz;
	/* B_ERROR and b_error may have stale data. */
	bp->b_error = 0;
	CLR(bp->b_flags, B_READ | B_WRITE | B_DONE | B_ERROR);
	SET(bp->b_flags, B_BUSY | B_READ | B_RAW);

	DPRINTF("gpt partition table being read from LBA %llu\n",
	    letoh64(gh->gh_part_lba));

	(*strat)(bp);

	error = biowait(bp);
	if (error) {
		DPRINTF("gpt partition table read error %d\n", error);
		free(gp, M_DEVBUF, *gpsz);
		gp = NULL;
		goto done;
	}

	checksum = crc32(0, bp->b_data, letoh32(gh->gh_part_num) *
	    letoh32(gh->gh_part_size));
	if (checksum == letoh32(gh->gh_part_csum))
		memcpy(gp, bp->b_data, *gpsz);
	else {
		DPRINTF("gpt partition table checksum: expected %x, got %x\n",
		    checksum, letoh32(gh->gh_part_csum));
		free(gp, M_DEVBUF, *gpsz);
		gp = NULL;
	}

done:
	bp->b_flags |= B_INVAL;
	brelse(bp);

	return ((struct gpt_partition *)gp);
d628 2
a629 2
readgptlabel(struct buf *bp, void (*strat)(struct buf *), struct disklabel *lp,
    daddr_t *partoffp, int spoofonly)
d631 1
a631 1
	struct gpt_header gh, altgh;
d633 1
d636 5
a641 3
	u_int64_t gpsz;
	u_int64_t gptpartoff = 0, gptpartend = DL_GETBEND(lp);
	int i, error, n=0, ourpart = -1, offset, ghinvalid, altghinvalid;
d651 132
a782 6
	ghinvalid = gpt_get_hdr(bp, strat, lp, GPTSECTOR, &gh);
	altghinvalid = gpt_get_hdr(bp, strat, lp, DL_GETDSIZE(lp) - 1, &altgh);
	if (ghinvalid && altghinvalid)
		return(EINVAL);
	if (ghinvalid)
		gh = altgh;
d784 4
a787 3
	gp = gpt_get_partition_table(bp->b_dev, strat, lp, &gh, &gpsz);
	if (gp == NULL)
		return (EINVAL);
d806 1
a806 1
		fstype = gpt_get_fstype(&uuid_part);
a834 2
	free(gp, M_DEVBUF, gpsz);

d839 1
d843 1
a843 1
		*partoffp = DL_SECTOBLK(lp, gptpartoff);
d854 3
a856 4
	bp->b_blkno = DL_BLKTOSEC(lp, DL_SECTOBLK(lp, gptpartoff) +
	    DOS_LABELSECTOR) * DL_BLKSPERSEC(lp);
	offset = DL_BLKOFFSET(lp, DL_SECTOBLK(lp, gptpartoff) +
	    DOS_LABELSECTOR);
d865 1
a865 5
	error = checkdisklabel(bp->b_data + offset, lp,
	    DL_GETBSTART((struct disklabel*)(bp->b_data+offset)),
	    DL_GETBEND((struct disklabel *)(bp->b_data+offset)));

	return (error);
@


1.182
log
@Bring back '#include <lib/libz/zlib.h>', but inside #ifdev GPT. GPT
routines use crc32().

ok jsg@@ doug@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.181 2015/03/14 03:38:50 jsg Exp $	*/
d517 8
d559 5
a563 16
int gpt_chk_hdr(struct gpt_header *);
int gpt_chk_parts(struct gpt_header *, struct gpt_partition *);
int get_fstype(struct uuid *);

int
gpt_chk_hdr(struct gpt_header *gh)
{
	u_int32_t orig_gh_csum = gh->gh_csum;
	gh->gh_csum = 0;
	gh->gh_csum = crc32(0, (unsigned char *)gh, gh->gh_size);

	if (orig_gh_csum != gh->gh_csum)
		return (EINVAL);

	return 0;
}
d566 1
a566 14
gpt_chk_parts(struct gpt_header *gh, struct gpt_partition *gp)
{
	u_int32_t checksum;
	checksum = crc32(0, (unsigned char *)gp,
	    gh->gh_part_num * gh->gh_part_size);

	if (checksum != gh->gh_part_csum)
		return (EINVAL);

	return 0;
}

int
get_fstype(struct uuid *uuid_part)
d569 2
a570 2
	static struct uuid uuid_openbsd, uuid_msdos, uuid_chromefs,
	    uuid_linux, uuid_hfs, uuid_unused;
d574 1
d582 2
a583 1
		uuid_dec_be(gpt_uuid_chromerootfs, &uuid_chromefs);
d591 1
a591 1
		return FS_UNUSED;
d593 1
a593 1
		return FS_BSDFFS;
d595 5
a599 3
		return FS_MSDOS;
	else if (!memcmp(uuid_part, &uuid_chromefs, sizeof(struct uuid)))
		return FS_EXT2FS;
d601 1
a601 1
		return FS_EXT2FS;
d603 200
a802 3
		return FS_HFS;
	else
		return FS_OTHER;
d813 2
a814 2
readgptlabel(struct buf *bp, void (*strat)(struct buf *),
    struct disklabel *lp, daddr_t *partoffp, int spoofonly)
d816 1
a816 1
	struct gpt_header gh;
a817 1
	size_t gpsz;
d820 2
a821 2

	daddr_t part_blkno;
d823 1
a823 3
	int i, altheader = 0, error, n=0, ourpart = -1, offset;

	static const u_int8_t gpt_uuid_openbsd[] = GPT_UUID_OPENBSD;
d833 6
a838 19
	/*
	 * XXX: We should not trust the primary header and instead
	 * use the last LBA of the disk, as defined in the standard.
	 */
	for (part_blkno = GPTSECTOR; ; part_blkno = gh.gh_lba_alt,
	    altheader = 1) {
		uint32_t ghsize;
		uint32_t ghpartsize;
		uint32_t ghpartnum;

		/* read header record */
		bp->b_blkno = DL_BLKTOSEC(lp, part_blkno) * DL_BLKSPERSEC(lp);
		offset = DL_BLKOFFSET(lp, part_blkno);
		bp->b_bcount = lp->d_secsize;
		bp->b_error = 0; /* B_ERROR and b_error may have stale data. */
		CLR(bp->b_flags, B_READ | B_WRITE | B_DONE | B_ERROR);
		SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
		(*strat)(bp);
		error = biowait(bp);
d840 3
a842 117
		if (error) {
			DPRINTF("error reading from disk\n");
	/*wrong*/	if (partoffp)
	/*wrong*/		*partoffp = -1;
			return (error);
		}

		bcopy(bp->b_data + offset, &gh, sizeof(gh));
		ghsize = letoh32(gh.gh_size);
		ghpartsize = letoh32(gh.gh_part_size);
		ghpartnum = letoh32(gh.gh_part_num);


		if (letoh64(gh.gh_sig) != GPTSIGNATURE)
			return (EINVAL);

		/* we only support version 1.0 */
		if (letoh32(gh.gh_rev) != GPTREVISION)
			return (EINVAL);

		if (gpt_chk_hdr(&gh)) {
			/* header broken, using alternate header */
			if (altheader) {
				DPRINTF("alternate header also broken\n");
				return (EINVAL);
			}

			if (gh.gh_lba_alt >= DL_GETDSIZE(lp)) {
				DPRINTF("alternate header's position is "
				    "bogous\n");
				return (EINVAL);
			}

			continue;
		}

		/*
		 * Header size must be greater than or equal to 92 and less
		 * than or equal to the logical block size.
		 */
		if (ghsize < GPTMINHDRSIZE || ghsize > DEV_BSIZE)
			return (EINVAL);

		if (letoh64(gh.gh_lba_start) >= DL_GETDSIZE(lp) ||
		    letoh64(gh.gh_lba_end) >= DL_GETDSIZE(lp) ||
		    letoh64(gh.gh_part_lba) >= DL_GETDSIZE(lp))
			return (EINVAL);

		/*
		* Size per partition entry shall be 128*(2**n) with n >= 0.
		* We don't support partition entries larger than block size.
		*/
		if (ghpartsize % GPTMINPARTSIZE
		    || ghpartsize > DEV_BSIZE
		    || GPT_PARTSPERSEC(&gh) == 0) {
			DPRINTF("invalid partition size\n");
			return (EINVAL);
		}

		/* XXX: we don't support multiples of GPTMINPARTSIZE yet */
		if (letoh32(gh.gh_part_size) != GPTMINPARTSIZE) {
			DPRINTF("partition sizes larger than %d bytes are not "
			    "supported", GPTMINPARTSIZE);
			return (EINVAL);
		}

		/* read GPT partition entry array */
		gp = mallocarray(ghpartnum, sizeof(struct gpt_partition), M_DEVBUF, M_NOWAIT|M_ZERO);
		if (gp == NULL)
			return (ENOMEM);
		gpsz = ghpartnum * sizeof(struct gpt_partition);

		/*
		* XXX: Fails if # of partition entries is no multiple of
		* GPT_PARTSPERSEC(&gh)
		*/
		for (i = 0; i < ghpartnum / GPT_PARTSPERSEC(&gh);
		     i++) {
			part_blkno = letoh64(gh.gh_part_lba) + i;
			/* read partition record */
			bp->b_blkno = DL_BLKTOSEC(lp, part_blkno) *
			    DL_BLKSPERSEC(lp);
			offset = DL_BLKOFFSET(lp, part_blkno);
			bp->b_bcount = lp->d_secsize;
			/* B_ERROR and b_error may have stale data. */
			bp->b_error = 0;
			CLR(bp->b_flags, B_READ | B_WRITE | B_DONE | B_ERROR);
			SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
			(*strat)(bp);
			error = biowait(bp);
			if (error) {
	/*wrong*/		if (partoffp)
	/*wrong*/			*partoffp = -1;
				free(gp, M_DEVBUF, gpsz);
				return (error);
			}

			bcopy(bp->b_data + offset, gp +
			    i * GPT_PARTSPERSEC(&gh), GPT_PARTSPERSEC(&gh) *
			    sizeof(struct gpt_partition));
		}

		if (gpt_chk_parts(&gh, gp)) {
			DPRINTF("partition entries broken, using alternate "
			    "header\n");
			free(gp, M_DEVBUF, gpsz);

			if (altheader) {
				DPRINTF("alternate partition entries are also "
				    "broken\n");
				return (EINVAL);
			}

			continue;
		}
		break;
	}
d861 1
a861 1
		fstype = get_fstype(&uuid_part);
d890 2
a895 1
	free(gp, M_DEVBUF, gpsz);
d899 1
a899 1
		*partoffp = gptpartoff;
d910 4
a913 3
	bp->b_blkno = DL_BLKTOSEC(lp, gptpartoff + DOS_LABELSECTOR) *
	    DL_BLKSPERSEC(lp);
	offset = DL_BLKOFFSET(lp, gptpartoff + DOS_LABELSECTOR);
d922 5
a926 1
	return checkdisklabel(bp->b_data + offset, lp, gptpartoff, gptpartend);
@


1.181
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.180 2015/01/27 03:17:36 dlg Exp $	*/
d67 4
@


1.180
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.179 2014/12/30 04:00:33 krw Exp $	*/
a66 2

#include <lib/libz/zlib.h>
@


1.179
log
@Rework disklabel reading taskq to plug holes pointed out by jsing@@.

Diff from dlg@@.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.178 2014/12/28 18:32:12 krw Exp $	*/
d102 1
a102 1
void disk_attach_callback(void *, void *);
d1108 1
a1108 1
			task_set(&dat->task, disk_attach_callback, dat, NULL);
d1118 1
a1118 1
disk_attach_callback(void *xdat, void *null)
@


1.178
log
@Replace last workq in tree (reading disklabels from newly attached
disks) with taskq. Diff originally from blambert@@.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.177 2014/12/20 15:54:48 krw Exp $	*/
a91 2
struct task disktask;

d97 5
a1041 1
	task_set(&disktask, disk_attach_callback, NULL, NULL);
d1098 13
a1111 2
	if (diskp->dk_devno != NODEV)
		task_add(systq, &disktask);
d1118 1
a1118 1
disk_attach_callback(void *arg1, void *arg2)
d1120 2
a1123 1
	struct disk *dk;
d1126 1
a1126 2
	/* Read disklabel(s) for newly-attached disk(s) */
	TAILQ_FOREACH(dk, &disklist, dk_link) {
d1128 2
a1129 2
		if (dk->dk_devno == NODEV)
			continue;
d1131 6
a1136 12
		/* XXX: Assumes dk is part of the device softc. */
		device_ref(dk->dk_device);

		if (dk->dk_flags & (DKF_OPENED | DKF_NOLABELREAD))
			goto done;

		/* Read disklabel. */
		dev = dk->dk_devno;
		if (disk_readlabel(&dl, dev, errbuf, sizeof(errbuf)) == NULL) {
			add_timer_randomness(dl.d_checksum);
			dk->dk_flags |= DKF_LABELVALID;
		}
d1139 3
a1141 4
		dk->dk_flags |= DKF_OPENED;
		device_unref(dk->dk_device);
		wakeup(dk);
	}
@


1.177
log
@Zap a sneaky trailing blank that was hiding in plain view.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.176 2014/12/20 13:45:15 kettenis Exp $	*/
d58 1
a58 1
#include <sys/workq.h>
d92 2
d1039 1
d1098 1
a1098 2
		workq_add_task(NULL, 0, disk_attach_callback,
		    (void *)(long)(diskp->dk_devno), NULL);
d1110 1
a1110 1
	dev_t dev = (dev_t)(long)arg1;
d1112 1
a1112 1
	/* Locate disk associated with device no. */
a1113 5
		if (dk->dk_devno == dev)
			break;
	}
	if (dk == NULL)
		return;
d1115 5
a1119 2
	/* XXX: Assumes dk is part of the device softc. */
	device_ref(dk->dk_device);
d1121 2
a1122 2
	if (dk->dk_flags & (DKF_OPENED | DKF_NOLABELREAD))
		goto done;
d1124 6
a1129 5
	/* Read disklabel. */
	if (disk_readlabel(&dl, dev, errbuf, sizeof(errbuf)) == NULL) {
		add_timer_randomness(dl.d_checksum);
		dk->dk_flags |= DKF_LABELVALID;
	}
d1132 4
a1135 3
	dk->dk_flags |= DKF_OPENED;
	device_unref(dk->dk_device);
	wakeup(dk);
@


1.176
log
@Zap local variable that shadows another local variable.  Fixes a panic caused
by passing random stack garbage as the size to free(9).

From David Imhoff
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.175 2014/12/20 13:37:32 krw Exp $	*/
d700 1
a700 1
		/* 
@


1.175
log
@Zap a bunch of leading/trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.174 2014/12/16 18:30:04 tedu Exp $	*/
a652 1
		size_t gpsz;
@


1.174
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.173 2014/11/03 21:00:27 tedu Exp $	*/
d534 1
a534 1
	
d617 1
a617 1
 * 
d644 2
a645 2
	/* 
	 * XXX: We should not trust the primary header and instead 
d648 1
a648 1
	for (part_blkno = GPTSECTOR; ; part_blkno = gh.gh_lba_alt, 
d691 1
a691 1
			
d695 1
a695 1
				return (EINVAL); 
d723 1
a723 1
		
d996 1
a996 1
    	int (*pr)(const char *, ...) __attribute__((__format__(__kprintf__,1,2)));
@


1.173
log
@correct test logic. ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.172 2014/11/03 16:55:21 tedu Exp $	*/
d1474 1
a1474 1
			cnpollc(TRUE);
d1476 1
a1476 1
			cnpollc(FALSE);
d1511 1
a1511 1
			cnpollc(TRUE);
d1513 1
a1513 1
			cnpollc(FALSE);
@


1.172
log
@deobfuscate by pulling le conversions up. use mallocarray.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.171 2014/11/03 03:08:00 deraadt Exp $	*/
d705 1
a705 1
		if (ghsize < GPTMINHDRSIZE && ghsize > DEV_BSIZE)
@


1.171
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.170 2014/09/14 14:17:25 jsg Exp $	*/
d650 5
d673 4
d705 1
a705 2
		if (letoh32(gh.gh_size) < GPTMINHDRSIZE
		    && letoh32(gh.gh_size) > DEV_BSIZE)
d717 2
a718 2
		if (letoh32(gh.gh_part_size) % GPTMINPARTSIZE
		    || letoh32(gh.gh_part_size) > DEV_BSIZE
d732 1
a732 2
		gpsz = letoh32(gh.gh_part_num) * sizeof(struct gpt_partition);
		gp = malloc(gpsz, M_DEVBUF, M_NOWAIT|M_ZERO);
d735 1
d741 1
a741 1
		for (i = 0; i < letoh32(gh.gh_part_num) / GPT_PARTSPERSEC(&gh);
@


1.170
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.169 2014/08/30 10:44:01 miod Exp $	*/
d1142 1
a1142 1
	free(diskp->dk_label, M_DEVBUF, 0);
@


1.169
log
@Recognize EFI protective and system partitions. Do not put disklabel entries
for the protective ones when creating a fake label, but do, for the system
ones, so that we may eventually copy boot code to them.

From Markus Mueller
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.168 2014/07/13 15:32:28 miod Exp $	*/
a56 1
#include <sys/proc.h>
@


1.168
log
@Initial support to read GPT partition tables in the kernel, if option GPT.
Contributed by Markus Mueller; code based upon Bitrig's GPT support, with
stricter GPT structures validation and support for alternate header places.

ok deraadt@@ jsing@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.167 2014/07/12 18:43:32 tedu Exp $	*/
d396 2
a397 1
			if (dp2->dp_typ == DOSPTYP_OPENBSD)
d419 1
@


1.167
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.166 2014/07/12 17:50:36 jsing Exp $	*/
d69 2
d73 6
d540 314
@


1.166
log
@Remove the temporary dospartoff work around.

From Markus Mueller.

ok krw@@ miod@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.165 2014/07/11 14:36:44 uebayasi Exp $	*/
d819 1
a819 1
	free(diskp->dk_label, M_DEVBUF);
@


1.165
log
@reboot(9): Add MI reboot entry function

Now, for kernel to "reboot" (reboot, halt, or shutdown), MD boot(9) is called
in some places.  This change introduces a new MI function reboot(9) which is
simply a wrapper to call MD boot(9).

OK kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a528 18
	/* XXX Remove after 5.5. It's meant for a short sharp transition! */
	if (error == ENOENT && lp->d_secsize != DEV_BSIZE) {
		/*
		 * Try looking at the (wrong but previously used) location
		 * specified if dospartoff is considered a DEV_BSIZE address.
		 */
		bp->b_blkno = DL_BLKTOSEC(lp, dospartoff + DOS_LABELSECTOR) *
		    DL_BLKSPERSEC(lp);
		offset = DL_BLKOFFSET(lp, dospartoff + DOS_LABELSECTOR);
		bp->b_bcount = lp->d_secsize;
		CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
		SET(bp->b_flags, B_BUSY | B_READ | B_RAW);
		(*strat)(bp);
		if (biowait(bp))
			return (bp->b_error);
		error = checkdisklabel(bp->b_data + offset, lp, dospartoff,
		    dospartend);
	}
@


1.164
log
@this doesnt talk to uvm directly, so doesnt need uvm_extern.h

deraadt says go ahead
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.163 2014/01/24 10:25:56 krw Exp $	*/
d1166 1
a1166 1
				boot(exitflags);
d1203 1
a1203 1
				boot(exitflags);
@


1.163
log
@When a disklabel is read from a MBR partitioned disk, don't
replace the OpenBSD bounds with the A6 MBR partition limits. Thus
preserving any changes the user makes with the 'b' command in
disklabel.

Reported, tested & ok blambert@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.162 2014/01/23 00:32:57 krw Exp $	*/
a59 1
#include <uvm/uvm_extern.h>
@


1.162
log
@Delete spurious if statement.

ok phessler@@ deraadt@@ jsing@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.161 2014/01/22 03:46:48 krw Exp $	*/
d526 4
a529 1
	error = checkdisklabel(bp->b_data + offset, lp, dospartoff, dospartend);
@


1.161
log
@Write disklabel in correct spot on devices with non-512-byte sectors.

For now and until 5.5 is cut, also read from current/incorrect spot
so people don't immediately lose their existing disklabels on such
devices.

Problem spotted by David Vasek.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.160 2014/01/21 01:48:44 tedu Exp $	*/
a237 3

	if (error)
		return (error);
@


1.160
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.159 2013/11/20 23:52:42 dlg Exp $	*/
d321 2
a322 3
		/* read boot record */
		bp->b_blkno = DL_BLKTOSEC(lp, part_blkno) * DL_BLKSPERSEC(lp);
		offset = DL_BLKOFFSET(lp, part_blkno) + DOSPARTOFF;
d335 1
a335 1
		bcopy(bp->b_data + offset, dp, sizeof(dp));
d365 9
a373 3
			/* found our OpenBSD partition, finish up */
			if (partoffp)
				goto notfat;
d507 1
a507 1
		*partoffp = dospartoff;
d518 4
a521 3
	bp->b_blkno = DL_BLKTOSEC(lp, dospartoff + DOS_LABELSECTOR) *
	    DL_BLKSPERSEC(lp);
	offset = DL_BLKOFFSET(lp, dospartoff + DOS_LABELSECTOR);
d529 21
a549 2
	/* sub-MBR disklabels are always at a LABELOFFSET of 0 */
	return checkdisklabel(bp->b_data + offset, lp, dospartoff, dospartend);
@


1.159
log
@now that all the direct users of disksort have been removed, we can now
safely remove disksort.

most hardware and pretty much all of the kernel has moved to logical
block addressing when dealing with disks, so the assumptions disksort
was built against arent useful these days. it also has bad edge cases
with lots of sequential writes being able to starve other io requests
in the system. these issues have been addressed by becks nscan
implementation, which disksort was previously deprecated in favour
of.

this removes the guts of disksort and the bufq wrapper around it.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.158 2013/11/18 17:45:01 deraadt Exp $	*/
d574 1
a574 1
	if (bcmp(nlp->d_uid, &uid, sizeof(nlp->d_uid)) == 0) {
d578 1
a578 1
				if (dk->dk_label && bcmp(dk->dk_label->d_uid,
d582 1
a582 1
		    bcmp(nlp->d_uid, &uid, sizeof(nlp->d_uid)) == 0);
d1105 2
a1106 2
	bzero(duid, sizeof(duid));
	if (bcmp(bootduid, duid, sizeof(bootduid)) == 0) {
d1222 2
a1223 2
			bzero(&duid, sizeof(duid));
			if (bcmp(rootduid, &duid, sizeof(rootduid)) != 0) {
d1226 1
a1226 1
					    dk->dk_label && bcmp(dk->dk_label->d_uid,
d1442 1
a1442 1
	bzero(uid, sizeof(uid));
d1459 1
a1459 1
		    bcmp(dk->dk_label->d_uid, uid,
@


1.158
log
@panic expects a format string
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.157 2013/11/01 17:36:19 krw Exp $	*/
a93 93
 * Seek sort for disks.  We depend on the driver which calls us using b_resid
 * as the current cylinder number.
 *
 * The argument ap structure holds a b_actf activity chain pointer on which we
 * keep two queues, sorted in ascending cylinder order.  The first queue holds
 * those requests which are positioned after the current cylinder (in the first
 * request); the second holds requests which came in after their cylinder number
 * was passed.  Thus we implement a one way scan, retracting after reaching the
 * end of the drive to the first request on the second queue, at which time it
 * becomes the first queue.
 *
 * A one-way scan is natural because of the way UNIX read-ahead blocks are
 * allocated.
 */

void
disksort(struct buf *ap, struct buf *bp)
{
	struct buf *bq;

	/* If the queue is empty, then it's easy. */
	if (ap->b_actf == NULL) {
		bp->b_actf = NULL;
		ap->b_actf = bp;
		return;
	}

	/*
	 * If we lie after the first (currently active) request, then we
	 * must locate the second request list and add ourselves to it.
	 */
	bq = ap->b_actf;
	if (bp->b_cylinder < bq->b_cylinder) {
		while (bq->b_actf) {
			/*
			 * Check for an ``inversion'' in the normally ascending
			 * cylinder numbers, indicating the start of the second
			 * request list.
			 */
			if (bq->b_actf->b_cylinder < bq->b_cylinder) {
				/*
				 * Search the second request list for the first
				 * request at a larger cylinder number.  We go
				 * before that; if there is no such request, we
				 * go at end.
				 */
				do {
					if (bp->b_cylinder <
					    bq->b_actf->b_cylinder)
						goto insert;
					if (bp->b_cylinder ==
					    bq->b_actf->b_cylinder &&
					    bp->b_blkno < bq->b_actf->b_blkno)
						goto insert;
					bq = bq->b_actf;
				} while (bq->b_actf);
				goto insert;		/* after last */
			}
			bq = bq->b_actf;
		}
		/*
		 * No inversions... we will go after the last, and
		 * be the first request in the second request list.
		 */
		goto insert;
	}
	/*
	 * Request is at/after the current request...
	 * sort in the first request list.
	 */
	while (bq->b_actf) {
		/*
		 * We want to go after the current request if there is an
		 * inversion after it (i.e. it is the end of the first
		 * request list), or if the next request is a larger cylinder
		 * than our request.
		 */
		if (bq->b_actf->b_cylinder < bq->b_cylinder ||
		    bp->b_cylinder < bq->b_actf->b_cylinder ||
		    (bp->b_cylinder == bq->b_actf->b_cylinder &&
		    bp->b_blkno < bq->b_actf->b_blkno))
			goto insert;
		bq = bq->b_actf;
	}
	/*
	 * Neither a second list nor a larger request... we go at the end of
	 * the first list, which is the same as the end of the whole schebang.
	 */
insert:	bp->b_actf = bq->b_actf;
	bq->b_actf = bp;
}

/*
a629 3
	/* calculate cylinder for disksort to order transfers with */
	bp->b_cylinder = (bp->b_blkno + DL_SECTOBLK(lp, DL_GETPOFFSET(p))) /
	    DL_SECTOBLK(lp, lp->d_secpercyl);
@


1.157
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.156 2013/10/20 13:15:35 krw Exp $	*/
d1060 1
a1060 1
		panic(error);
@


1.156
log
@KNF a long line.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.155 2013/10/19 09:32:15 krw Exp $	*/
d768 1
a768 1
		(*pr)("%lld", sn);
d772 1
a772 1
			(*pr)("%lld of ", sn);
d774 2
a775 2
		(*pr)("%lld-%lld", bp->b_blkno,
		    bp->b_blkno + (bp->b_bcount - 1) / DEV_BSIZE);
d779 2
a780 2
		(*pr)(" (%s%d bn %lld; cn %lld", dname, unit, sn,
		    sn / DL_SECTOBLK(lp, lp->d_secpercyl));
d782 3
a784 2
		(*pr)(" tn %lld sn %lld)", sn / DL_SECTOBLK(lp, lp->d_nsectors),
		    sn % DL_SECTOBLK(lp, lp->d_nsectors));
@


1.155
log
@Use daddr_t * instead of int * for the partoffp parameter to
readdoslabel(). Ditto all the MD variables whose addresses are passed
to readdoslabel() via partoffp.

Fix some 512-byte block vs disk sector confusion in hppa and sgi.
All the DL_GETxxxxx() defines return disk sector values. All
DL_SETxxxx() take disk sector values. These changes should be no-ops
until a drive using non-512-byte-sectors is encountered.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.154 2013/10/14 23:35:53 krw Exp $	*/
d651 2
a652 1
		if ((openmask & (1 << i)) && (DL_GETPOFFSET(npp) != DL_GETPOFFSET(opp) ||
@


1.154
log
@Display correct values (i.e. blocks where blocks are meant) in
diskerr() messages by doing DL_SECTOBLK() dance repeatedly.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.153 2013/10/07 22:11:49 krw Exp $	*/
d388 1
a388 1
    struct disklabel *lp, int *partoffp, int spoofonly)
@


1.153
log
@disk sizes, partition sizes and partition offsets are u_int64_t
values rather than daddr_t values. So use u_int64_t to store them
and %llu to print them in checkdisklabel().
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.152 2013/09/03 17:48:26 krw Exp $	*/
d777 1
a777 1
		sn += DL_GETPOFFSET(&lp->d_partitions[part]);
d779 4
a782 4
		    sn / lp->d_secpercyl);
		sn %= lp->d_secpercyl;
		(*pr)(" tn %lld sn %lld)", sn / lp->d_nsectors,
		    sn % lp->d_nsectors);
@


1.152
log
@When a partition is changing to UNUSED, we try to save kernel-set
values for the p_fragblock and p_cpg fields. But we were saving the
info for open partitions only. Instead, look at all partitions.
And stop discarding the new partition type.

In addition to general betterness, this lets you change the RAW_PART
partition (a.k.a. 'c') to UNUSED. This problem was pointed out by
Federico Giannici via misc@@.

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.151 2013/08/08 23:25:06 syl Exp $	*/
d241 1
a241 1
	daddr_t disksize;
d357 1
a357 1
		printf("on-disk disklabel has incorrect disksize (%lld)\n",
d360 1
a360 1
		printf("on-disk disklabel RAW_PART has incorrect size (%lld)\n",
d363 1
a363 1
		printf("on-disk disklabel RAW_PART offset != 0 (%lld)\n",
@


1.151
log
@Uncomment kprintf format attributes for sys/kern

tested on vax (gcc3) ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.150 2013/07/03 15:21:40 sf Exp $	*/
d648 1
a648 5
	while (openmask != 0) {
		i = ffs(openmask) - 1;
		openmask &= ~(1 << i);
		if (nlp->d_npartitions <= i)
			return (EBUSY);
d651 2
a652 2
		if (DL_GETPOFFSET(npp) != DL_GETPOFFSET(opp) ||
		    DL_GETPSIZE(npp) < DL_GETPSIZE(opp))
a658 1
			npp->p_fstype = opp->p_fstype;
@


1.150
log
@don't use empty format string

this is necessary to enable -Wformat or -Wno-error=format

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.149 2013/06/11 16:42:16 deraadt Exp $	*/
d759 1
a759 1
    	int (*pr)(const char *, ...) /* __attribute__((__format__(__kprintf__,1,2))) */;
@


1.149
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.148 2013/04/24 08:31:06 blambert Exp $	*/
d764 1
a764 2
		static const char fmt[] = "";
		log(pri, fmt);
@


1.148
log
@When attaching disks, feed the disklabel's checksum to
the random pool as unique-esque-but-not-secret data.

inspired by conversations with tedu@@/deraadt@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.147 2013/02/17 17:39:29 miod Exp $	*/
d241 1
a241 1
	daddr64_t disksize;
d393 1
a393 1
	daddr64_t part_blkno = DOSBBSECTOR;
d700 1
a700 1
	daddr64_t partblocks, sz;
d761 1
a761 1
	daddr64_t sn;
@


1.147
log
@Comment out recently added __attribute__((__format__(__kprintf__))) annotations
in MI code; gcc 2.95 does not accept such annotation for function pointer
declarations, only function prototypes.
To be uncommented once gcc 2.95 bites the dust.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.146 2013/02/09 20:56:35 miod Exp $	*/
d889 2
a890 1
	if (disk_readlabel(&dl, dev, errbuf, sizeof(errbuf)) == NULL)
d892 1
@


1.146
log
@Add explicit __attribute__ ((__format__(__kprintf__)))) to the functions and
function pointer arguments which are {used as,} wrappers around the kernel
printf function.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.145 2012/04/07 16:48:38 krw Exp $	*/
d759 1
a759 1
    	int (*pr)(const char *, ...) __attribute__((__format__(__kprintf__,1,2)));
@


1.145
log
@Tweak FAT detection/usage. Recognize 'bare' FAT media that lacks
the 0x55aa signature. Don't try FAT detection if we have found an
OpenBSD MBR partition. Don't try to read a disklabel from 'bare'
FAT media. There can't be one.

Finally, don't allow the writing of a disklabel on 'bare' FAT media.
There is no safe spot for it, and splatting it in the middle of the
FAT structures has not proved helpful.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.144 2012/03/31 23:10:34 krw Exp $	*/
d759 1
a759 1
	int (*pr)(const char *, ...);
@


1.144
log
@Some whitespace/paren tweaks. Rename the mbr testing variable from
'fattest' to 'mbrtest'. No change to .o.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.143 2012/02/10 18:41:36 phessler Exp $	*/
d438 1
a438 1
				goto notfat;
a544 3
	if (partoffp)
		/* dospartoff has been set and we must not modify *lp. */
		goto notfat;
d546 4
a549 1
	lp->d_npartitions = MAXPARTITIONS;
d551 1
a551 1
	if (n == 0 && part_blkno == DOSBBSECTOR) {
d581 3
a583 1
		/* Looks like a FAT filesystem. Spoof 'i'. */
d588 2
d591 1
@


1.143
log
@DUIDs are only valid when booting off of a disk, so make sure we are
actually doing so before using them

OK deraadt@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.142 2012/01/21 17:09:02 krw Exp $	*/
d432 1
a432 1
			u_int16_t fattest;
d435 1
a435 1
			fattest = ((bp->b_data[510] << 8) & 0xff00) |
d437 1
a437 1
			if (fattest != 0x55aa)
d593 2
a594 2
		DL_SETBEND(lp,
		    dospartend < DL_GETDSIZE(lp) ? dospartend : DL_GETDSIZE(lp));
@


1.142
log
@When disklabels can't be read before attempting to mount root, make
the message less scary and print out the failing devices to improve
troubleshooting.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.141 2012/01/21 16:30:10 jsing Exp $	*/
d1313 17
a1329 14
		bzero(&duid, sizeof(duid));
		if (bcmp(rootduid, &duid, sizeof(rootduid)) != 0) {
			TAILQ_FOREACH(dk, &disklist, dk_link)
				if ((dk->dk_flags & DKF_LABELVALID) &&
				    dk->dk_label && bcmp(dk->dk_label->d_uid,
				    &rootduid, sizeof(rootduid)) == 0)
					break;
			if (dk == NULL)
				panic("root device (%02hx%02hx%02hx%02hx"
				    "%02hx%02hx%02hx%02hx) not found",
				    rootduid[0], rootduid[1], rootduid[2],
				    rootduid[3], rootduid[4], rootduid[5],
				    rootduid[6], rootduid[7]);
			rootdv = dk->dk_device;
@


1.141
log
@Do not wait for DKF_OPENED to be set if we never actually created a
callback for this disk.

Fixes an issue found by krw on macppc.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.140 2012/01/16 16:29:49 jsing Exp $	*/
d1188 8
a1195 2
	if (slept == 5)
		printf("not all disklabels read successfully\n");
@


1.140
log
@Ensure that all disk attach callbacks have completed before attempting
to locate the root via DUID.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.139 2012/01/13 14:39:31 jsing Exp $	*/
d1179 2
a1180 1
			if ((dk->dk_flags & DKF_OPENED) == 0) {
@


1.139
log
@Always set DKF_OPENED in the disk attach callback.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.138 2012/01/13 14:16:51 jsing Exp $	*/
d1164 1
a1164 1
	int majdev, unit, len, s;
d1175 14
@


1.138
log
@Restore previous behaviour - only print the DUID if we used it to
select root.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.136 2012/01/11 15:17:48 jsing Exp $	*/
d874 1
a874 2
	if (dk == NULL || (dk->dk_flags & (DKF_OPENED | DKF_NOLABELREAD))) {
		wakeup(dk);
a875 1
	}
d880 3
d886 2
a888 1

@


1.137
log
@If the DUID of the boot disk has not been provided, attempt to locate it
via the boot device. This allows root on softraid to work on most
architectures. For architectures that cannot clearly identify their boot
device, the DUID of the boot disk can still be passed from the boot loader,
as is already done for amd64 and i386.

Based on a suggestion from kettenis@@

ok krw@@
@
text
@d1167 1
a1167 1
	struct disk *dk = NULL;
d1193 1
a1302 1
			bcopy(rootduid, duid, sizeof(duid));
d1363 1
a1363 1
	if (dk != NULL && bcmp(rootduid, &duid, sizeof(rootduid)) == 0)
@


1.136
log
@Move softraid root mapping to later in the boot process - this will allow
us to play some tricks in setroot().
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.135 2011/12/28 16:02:45 jsing Exp $	*/
d83 1
d1173 11
@


1.135
log
@Avoid the use of an invalid disklabel by setting a DK_LABELVALID flag
if we correctly read and validated the disklabel. Always check that this
flag is set before using the DUID from the disklabel.

Discussed with deraadt@@

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.134 2011/12/28 14:34:13 jsing Exp $	*/
d70 2
d88 2
d1171 4
@


1.134
log
@An all-zero DUID is considered to be a blank DUID - ensure that we do not
generate one.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.132 2011/09/18 13:23:38 miod Exp $	*/
d869 2
a870 1
	if (dk == NULL || (dk->dk_flags & (DKF_OPENED | DKF_NOLABELREAD)))
d872 1
d878 2
a879 1
	disk_readlabel(&dl, dev, errbuf, sizeof(errbuf));
d883 1
d1272 2
a1273 1
				if (dk->dk_label && bcmp(dk->dk_label->d_uid,
d1505 2
a1506 1
		if (dk->dk_label && bcmp(dk->dk_label->d_uid, uid,
@


1.133
log
@Move the prototype for disk_readlabel to the .h file so that hibernate
can get at it.
ok jsing
@
text
@d230 2
a231 2
checkdisklabel(void *rlp, struct disklabel *lp,
	u_int64_t boundstart, u_int64_t boundend)
d668 2
a669 1
		} while (dk != NULL);
@


1.132
log
@Do not use the `hh' modifier in printf format strings, as the kernel printf
implementation does not support it and handles it as `h'.
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.131 2011/07/26 12:32:14 krw Exp $	*/
a85 1
char *disk_readlabel(struct disklabel *, dev_t, char *, size_t);
@


1.131
log
@No need to byte-swap d_checksum just before setting it to zero.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.130 2011/07/06 16:36:52 krw Exp $	*/
d1272 2
a1273 2
				panic("root device (%02hhx%02hhx%02hhx%02hhx"
				    "%02hhx%02hhx%02hhx%02hhx) not found",
d1339 1
a1339 1
		printf(" (%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx%02hhx.%c)",
@


1.130
log
@On several archs (e.g. hppa, sgi, macppc) readdoslabel() is called after an attempt to
read a native label fails. Reset B_ERROR/b_error on buf to ensure any i/o failure on
that first attempt is forgiven. A la the dkcsum() fix to recover from a disk error.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.129 2011/07/06 04:49:36 matthew Exp $	*/
a301 1
		dlp->d_checksum = swap16(dlp->d_checksum);
@


1.129
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.128 2011/07/05 04:05:04 matthew Exp $	*/
d415 2
a416 1
		CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
@


1.128
log
@Add checks for sector-alignment and whole number of sectors to
bounds_check_with_label() and generally cleanup the code while here.

ok krw@@ ("I like this a *lot*"); "i like it" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.127 2011/06/30 16:28:05 matthew Exp $	*/
d720 1
a720 1
	return (1);
@


1.127
log
@Refactor some common open/close/detach disk driver code into
subr_disk.c.  For now just the MI disk drivers.

ok deraadt@@, krw@@; jsing@@ liked the approach too
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.126 2011/06/19 04:53:17 matthew Exp $	*/
d690 1
a690 1
	daddr64_t sz = howmany(bp->b_bcount, DEV_BSIZE);
d692 2
a693 2
	/* Avoid division by zero, negative offsets and negative sizes. */
	if (lp->d_secpercyl == 0 || bp->b_blkno < 0 || sz < 0)
d696 9
a704 11
	/* beyond partition? */
	if (bp->b_blkno + sz > DL_SECTOBLK(lp, DL_GETPSIZE(p))) {
		sz = DL_SECTOBLK(lp, DL_GETPSIZE(p)) - bp->b_blkno;
		if (sz == 0) {
			/* If exactly at end of disk, return EOF. */
			bp->b_resid = bp->b_bcount;
			return (-1);
		}
		if (sz < 0)
			/* If past end of disk, return EINVAL. */
			goto bad;
d706 8
a713 1
		/* Otherwise, truncate request. */
d722 1
a722 1
bad:
d725 2
@


1.126
log
@Minor cleanup for disk_lock() and disk_unlock().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.125 2011/06/19 04:51:06 matthew Exp $	*/
d897 57
@


1.125
log
@Add disk_lock_nointr() as a way to acquire the disk lock without being
interrupted by signals.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.124 2011/06/19 04:11:48 matthew Exp $	*/
d956 1
a956 5
	int error;

	error = rw_enter(&dk->dk_lock, RW_WRITE|RW_INTR);

	return (error);
d968 1
a968 1
	rw_exit(&dk->dk_lock);
@


1.124
log
@Kill the "lockname" argument to disk_construct().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.123 2011/06/03 21:14:11 matthew Exp $	*/
d961 6
@


1.123
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.122 2011/06/01 17:57:51 matthew Exp $	*/
d787 1
a787 1
disk_construct(struct disk *diskp, char *lockname)
d806 1
a806 1
		disk_construct(diskp, diskp->dk_name);
@


1.122
log
@Add device_ref/device_unref calls to prevent a possible use-after-free
issue in disk_attach_callback.  Assumes that the struct disk is part
of the driver's softc, but this is always true in practice.

Still other scary use-after-free races lying around here though...

ok jsing@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.121 2011/04/28 17:50:17 marco Exp $	*/
d687 1
a687 1
bounds_check_with_label(struct buf *bp, struct disklabel *lp, int wlabel)
@


1.121
log
@spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.120 2011/04/26 17:20:20 jsing Exp $	*/
d865 3
d871 2
@


1.120
log
@Allow the root device to be identified via its disklabel UID.

ok deraadt@@ marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.118 2011/04/15 14:57:29 krw Exp $	*/
d793 1
a793 1
	    
d1006 1
a1006 1
		{ 
d1014 1
a1014 1
		panic("disk 0x%x filesystem type %d not known", 
@


1.119
log
@Use 'CLR(<buf>->b_flags, B_READ | B_WRITE | B_DONE)' regardless of
what the previous IO was. Less chance of copy and paste errors.
Suggested by miod@@.
@
text
@d81 2
d1087 2
d1194 16
d1266 6
@


1.118
log
@In days of yore one could arbitrarily whack buffer flags. Those days
are past. Use CLR() and SET() to modify necessary flags while leaving
the flags used by the buffer cache in peace.

Should make bufcache code much less confused about the state of the
bufs used in reading/writing disklabels. Other such flag abuses no
doubt await a visit.

Errors in original diff found by miod@@.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.117 2011/03/19 01:21:57 krw Exp $	*/
d413 1
a413 1
		CLR(bp->b_flags, B_WRITE | B_DONE);
d599 1
a599 1
	CLR(bp->b_flags, B_WRITE | B_DONE);
@


1.117
log
@Repair spoofing. We want to start at 'i', not 'j'.

Spotted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.116 2011/03/17 21:44:10 krw Exp $	*/
d413 2
a414 1
		bp->b_flags = B_BUSY | B_READ | B_RAW;
d599 2
a600 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
@


1.116
log
@Uncommitted bits. Spotted by deraadt@@, who theorizes I have insuffient
sushi level.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.115 2011/03/14 17:20:00 krw Exp $	*/
a484 1
				n++;
a488 1
				n++;
a492 1
				n++;
a501 1
				n++;
a514 1
				n++;
d530 1
@


1.115
log
@Don't confuse limiting spoofed partitions with limiting how many
EBRs to follow looking for the OpenBSD partition.  Just stop spoofing
if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.114 2010/11/24 15:31:34 jsing Exp $	*/
d403 1
a403 1
	while (wander && loop < 8) {
@


1.114
log
@Ensure that hw.disknames gets updated whenever a disklabel is set, since
the disklabel UID may have changed.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.113 2010/11/18 21:13:19 miod Exp $	*/
d403 1
a403 1
	while (wander && n < 8 && loop < 8) {
d469 2
a470 2
		for (dp2=dp, i=0; i < NDOSPART && n < 8; i++, dp2++) {
			struct partition *pp = &lp->d_partitions[8+n];
d527 3
d531 1
a531 1
			if (partoffp)
d534 1
@


1.113
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.112 2010/09/24 07:08:50 deraadt Exp $	*/
d671 3
@


1.112
log
@Fixes before-boot umass hangs on units without media.
In disk_readlabel() if the ioctl fails don't forget to close the disk.
Avoid sharing a static error buffer between a workq and mountroot since
they can compete.  Pass the dev_t to the workq inside one of the arguments
without a malloc'd object.
ok miod dlg krw
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.111 2010/09/23 18:49:39 oga Exp $	*/
a56 1
#include <sys/dkstat.h>		/* XXX */
@


1.111
log
@The only sensible argument for VOP_* calls that take a struct proc pointer is
curproc. A bunch of callers were passing in 0 (not even NULL, 0) as this
pointer, which was fine until the called vnode function tried to do
something with it. Typically, this code was then copy/pasted to various
parts of the tree.

Accept the facts of life and switch all of these over to passing curproc
for now until the argument can be removed.

Discovered by stsp trying to create a softraid on top of a vnd, which
crashed with a NULL deref in vndioctl.

softraid bits tested by mikeb and jsing. raidframe bits tested by pea,
matthieu and naddy. The rest tested by at least thib, jsing and myself.

ok thib@@, jsing@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.110 2010/09/23 13:20:36 jsing Exp $	*/
d85 1
a85 1
char *disk_readlabel(struct disklabel *, dev_t);
a797 1
	dev_t *dev;
d835 3
a837 8
	if (diskp->dk_devno != NODEV) {
		dev = malloc(sizeof(dev_t), M_DEVBUF, M_NOWAIT);
		if (dev == NULL)
			panic("failed to allocate memory for dev no");
		*dev = diskp->dk_devno;
		if (workq_add_task(NULL, 0, disk_attach_callback, dev, NULL))
			free(dev, M_DEVBUF);
	}
d846 1
d849 1
a849 1
	dev_t dev = *((dev_t *)arg1);
d857 1
a857 1
		goto done;
d860 1
a860 1
	disk_readlabel(&dl, dev);
a861 3

done:
	free(arg1, M_DEVBUF);
d961 1
d967 1
a967 1
	error = disk_readlabel(&dl, rootdev);
d1305 1
a1305 1
disk_readlabel(struct disklabel *dl, dev_t dev)
a1306 1
	static char errbuf[100];
d1319 1
a1319 1
		snprintf(errbuf, sizeof(errbuf),
d1326 1
a1326 1
		snprintf(errbuf, sizeof(errbuf),
d1329 1
a1329 1
		return (errbuf);
d1334 1
a1334 1
		snprintf(errbuf, sizeof(errbuf),
a1336 1
		return (errbuf);
d1338 4
a1341 6

	error = VOP_CLOSE(vn, FREAD, NOCRED, curproc);
	if (error) {
		snprintf(errbuf, sizeof(errbuf),
		    "cannot close disk, 0x%x/0x%x, error %d",
		    dev, rawdev, error);
a1342 4
	}

	vput(vn);

@


1.110
log
@When a disk is attached create a workq task to read the disklabel,
providing the DKF_NOLABELREAD flag is not set. This provides the kernel
with the actual disklabel which includes the disklabel UID.

ok deraadt@@ miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.109 2010/09/08 15:16:22 jsing Exp $	*/
d1340 1
a1340 1
	error = VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)dl, FREAD, NOCRED, 0);
d1348 1
a1348 1
	error = VOP_CLOSE(vn, FREAD, NOCRED, 0);
@


1.109
log
@Introduce a disk_lookup() function which calls device_lookup(), before
verifying that the resulting device is present on the disklist. This
avoids a race whereby the disk driver can be accessed as soon as the
softc has been allocated, but before the disk has completed
initialisation and has called disk_attach() (up until this point
dk_label is still a null pointer).

Cut cd(4), sd(4) and wd(4) across to disk_lookup(). All callers of
disk_attach() need to be tested and cut over in due course.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.108 2010/09/08 14:47:12 jsing Exp $	*/
d60 1
d86 1
d798 1
d836 8
d847 23
@


1.108
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.106 2010/08/30 16:53:28 jsing Exp $	*/
d1396 25
@


1.107
log
@Do not panic in parsedisk() for ``second class'' block devices (which we can't
root off), return NULL instead.
@
text
@d793 1
a793 1
disk_attach(struct disk *diskp)
d795 1
a795 2
	struct device *dv;
	dev_t *dev;
d823 1
a823 1
	 * Lookup and store device number for later use.
d825 8
a832 4
	dev = &diskp->dk_devno;
	dv = parsedisk(diskp->dk_name, strlen(diskp->dk_name), RAW_PART, dev);
	if (dv == NULL)
		diskp->dk_devno = NODEV;
@


1.106
log
@Add a device number to struct disk and populate it on disk attach. Whilst
here also expose disklist for future use.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.104 2010/06/27 00:14:06 jsing Exp $	*/
d1026 1
a1026 1
				panic("parsedisk");
@


1.105
log
@- fix compilation of kernel without FFS...don't ask ;-)

ok jsing@@
@
text
@d795 2
d822 8
@


1.104
log
@Factor out code used to read a disklabel. We'll be making use of this soon.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.100 2010/04/23 15:25:21 jsing Exp $	*/
d968 2
a969 2
		panic("disk 0x%x/0x%x filesystem type %d not known", 
		    rootdev, rrootdev, dl.d_partitions[part].p_fstype);
@


1.103
log
@Provide a disk_map() function which attempts to map a disklabel UID to the
actual device. If successful, the real path is returned via mappath. Soon
to be used by several other diffs.

ok krw@@
@
text
@d84 2
a921 1
	dev_t rawdev, rrootdev;
d925 1
a925 9
	struct vnode *vn;
	int error;

	rrootdev = blktochr(rootdev);
	rawdev = MAKEDISKDEV(major(rrootdev), DISKUNIT(rootdev), RAW_PART);
#ifdef DEBUG
	printf("rootdev=0x%x rrootdev=0x%x rawdev=0x%x\n", rootdev,
	    rrootdev, rawdev);
#endif
d927 1
a927 10
	/*
	 * open device, ioctl for the disklabel, and close it.
	 */
	if (cdevvp(rawdev, &vn))
		panic("cannot obtain vnode for 0x%x/0x%x", rootdev, rrootdev);
	error = VOP_OPEN(vn, FREAD, NOCRED, curproc);
	if (error)
		panic("cannot open disk, 0x%x/0x%x, error %d",
		    rootdev, rrootdev, error);
	error = VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)&dl, FREAD, NOCRED, 0);
d929 1
a929 7
		panic("cannot read disk label, 0x%x/0x%x, error %d",
		    rootdev, rrootdev, error);
	error = VOP_CLOSE(vn, FREAD, NOCRED, 0);
	if (error)
		panic("cannot close disk , 0x%x/0x%x, error %d",
		    rootdev, rrootdev, error);
	vput(vn);
d1261 50
@


1.102
log
@When setting a disklabel automatically generate a new UID if it does not
already have one.

ok krw@@
@
text
@d605 1
a605 2
 * Check new disk label for sensibility
 * before setting it.
d611 1
a611 1
	struct disk *dk = NULL;
d1284 71
@


1.101
log
@introducing a 64-bit type to the disklabel structure leads some architectures
to pad-align the size of the structure; it grows, the disklabel ioctl's are
break ABI.  Change the uid to a character array.  this also simplifies some
other stuff
ok jsing
@
text
@d611 3
a614 1
	struct partition *opp, *npp;
d653 13
@


1.100
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.98 2010/01/11 05:37:28 krw Exp $	*/
d281 1
a281 1
		dlp->d_label_uid = swap64(dlp->d_label_uid);
@


1.99
log
@fix typos in comments, no code changes;
from Brad Tilley <brad at 16systems dot com>;
ok oga@@
@
text
@d281 1
a281 2
		dlp->d_sparespertrack = swap16(dlp->d_sparespertrack);
		dlp->d_sparespercyl = swap16(dlp->d_sparespercyl);
a284 2
		dlp->d_rpm = swap16(dlp->d_rpm);
		dlp->d_interleave = swap16(dlp->d_interleave);
@


1.98
log
@Negative offset or negative size in a buf is invalid. Treat just like other
invalid offsets and sizes: reject the i/o.

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.97 2009/08/13 15:23:11 deraadt Exp $	*/
d257 1
a257 1
		 * Need a byte-swap aware dkcksum varient
@


1.97
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.96 2009/08/09 14:06:52 marco Exp $	*/
d671 2
a672 2
	/* avoid division by zero */
	if (lp->d_secpercyl == 0)
a673 3

	if (bp->b_blkno < 0 || sz < 0)
		panic("bounds_check_with_label %lld %lld\n", bp->b_blkno, sz);
@


1.96
log
@Make dk_mmountroot use vnodes instead of d_open/d_close.  This does ugly
things to softraid.

ok jsing thib krw beck oga
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.95 2009/06/17 01:30:30 thib Exp $	*/
d193 1
a193 1
char *
d204 1
a204 1
		return ("invalid geometry");
d218 1
a218 1
	return (NULL);
d225 1
a225 1
char *
d233 1
a233 1
	char *msg = NULL;
d237 1
a237 1
		msg = "no disk label";
d239 1
a239 1
		msg = "invalid label, partition count > MAXPARTITIONS";
d241 1
a241 1
		msg = "invalid label, d_secpercyl == 0";
d243 1
a243 1
		msg = "invalid label, d_secsize == 0";
d245 1
a245 1
		msg = "invalid label, incorrect checksum";
d247 1
a247 1
	if (msg) {
d254 1
a254 1
			return (msg);
d266 1
a266 1
			return (msg);
d322 1
a322 1
		msg = NULL;
d327 2
a328 2
	if (msg)
		return (msg);
d369 1
a369 1
	return (msg);
d381 1
a381 1
char *
d390 1
d393 1
a393 1
		return ("invalid label, d_secpercyl == 0");
d395 1
a395 1
		return ("invalid label, d_secsize == 0");
d415 2
a416 1
		if (biowait(bp)) {
d419 1
a419 1
			return ("dos partition I/O error");
d592 1
a592 1
		return (NULL);		/* jump to the checkdisklabel below?? */
d601 1
a601 1
		return ("disk label I/O error");
@


1.95
log
@Revert bufq's. this is inline with the major midlayer reverts that
have been going on. this appears to bring us back to stable state.

lots of testing by oga and ariane and my self.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.94 2009/06/14 00:09:40 deraadt Exp $	*/
d59 1
d914 1
d927 3
a929 2
	error = (cdevsw[major(rrootdev)].d_open)(rawdev, FREAD,
	    S_IFCHR, curproc);
d933 1
a933 2
	error = (cdevsw[major(rrootdev)].d_ioctl)(rawdev, DIOCGDINFO,
	    (caddr_t)&dl, FREAD, curproc);
d937 5
a941 2
	(void) (cdevsw[major(rrootdev)].d_close)(rawdev, FREAD,
	    S_IFCHR, curproc);
@


1.94
log
@Don't mess with the bounds in the lp if *partoffp is non-NULL, since this
indicates that writedisklabel is trying to find the location for writing
the label.  If the lp is messed with, an invalid checksum is written.
done with miod and kettenis, lots of moaning and gnashing of teeth, etc
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.93 2009/06/05 00:41:13 deraadt Exp $	*/
a770 4
	diskp->dk_bufq = bufq_init(BUFQ_DEFAULT);
	if (diskp->dk_bufq == NULL)
		return (1);

d784 1
a784 2
		if (disk_construct(diskp, diskp->dk_name))
			panic("disk_attach: can't construct disk");
a825 2

	bufq_destroy(diskp->dk_bufq);
@


1.93
log
@Clamp the ending bound to the size of the disk.  This makes disklabel -A
still do the right thing if the MBR has a lie in it
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.92 2009/06/04 21:13:02 deraadt Exp $	*/
a577 3
	DL_SETBSTART(lp, dospartoff);
	DL_SETBEND(lp, dospartend < DL_GETDSIZE(lp) ? dospartend : DL_GETDSIZE(lp));

d581 5
d589 1
a589 1
		return (NULL);
@


1.92
log
@Recycle four ancient fields in the disklabel structure, replacing them with
bounds information, ie. the zone of the disk that OpenBSD can use.  Have each
pre-disklabel parser (MBR, DPME, or per-arch MD disklabel parsers) figure out
this area and pass it up to userland.  Then, delete all the same disk parsing
code from disklabel(8) since the kernel passes it up.  Lots and lots of - signs
in the disklabel(8) code.
Tested on as many platforms as possible, the fallout will be repaired as time
goes on.  To test, use disklabel -d <drive> and validate that the bounds do not
overlap any boot blocks.  This same information is used by disklabel -A...
OK for the concept from krw, miod, and drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.91 2009/06/03 22:09:30 thib Exp $	*/
d364 1
a364 1
	DL_SETBEND(lp, boundend);
d579 1
a579 1
	DL_SETBEND(lp, dospartend);
@


1.91
log
@add a flexible buffer queue (bufq) api, based on the never used
one by tedu@@. It doesn't do anything smart yet, it just uses
plain old disksort. we also keep the old method of queueing bufs
since some miods have crazy MD drivers that need some love.

ok beck@@, art@@
tested by many on many archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.89 2009/06/03 03:14:28 thib Exp $	*/
d212 2
d225 2
a226 1
checkdisklabel(void *rlp, struct disklabel *lp)
a286 4
		dlp->d_trackskew = swap16(dlp->d_trackskew);
		dlp->d_cylskew = swap16(dlp->d_cylskew);
		dlp->d_headswitch = swap32(dlp->d_headswitch);
		dlp->d_trkseek = swap32(dlp->d_trkseek);
d363 2
d384 2
d387 1
a388 4
	daddr64_t part_blkno = DOSBBSECTOR;
	int dospartoff = 0, i, ourpart = -1;
	int wander = 1, n = 0, loop = 0;
	int offset;
d447 1
d578 2
d599 1
a599 1
	return checkdisklabel(bp->b_data + offset, lp);
@


1.90
log
@Add a callback specifically for softraid.  If you touch this kittens will
be murdered and theo will visit with a 2x4.

ok deraadt
@
text
@d765 5
a769 1
	
d783 2
a784 1
		disk_construct(diskp, diskp->dk_name);
d826 2
@


1.89
log
@remove the never used bufq_ code.

ok oga@@
'dance for me' blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.87 2009/05/13 01:14:19 deraadt Exp $	*/
d80 3
d802 3
d813 3
@


1.88
log
@Validate the main MBR minimally; if it does not have the AA55 thingy we must
not read garbage values as partitions... which we then put into the spoofed
label... and which would lead disklabel -A to make surprising decisions.
earlier versions which did too much validation tested by many
@
text
@a967 57
struct bufq *
bufq_default_alloc(void)
{
	struct bufq_default *bq;

	bq = malloc(sizeof(*bq), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (bq == NULL)
		panic("bufq_default_alloc: no memory");

	bq->bufq.bufq_free = bufq_default_free;
	bq->bufq.bufq_add = bufq_default_add;
	bq->bufq.bufq_get = bufq_default_get;

	return ((struct bufq *)bq);
}

void
bufq_default_free(struct bufq *bq)
{
	free(bq, M_DEVBUF);
}

void
bufq_default_add(struct bufq *bq, struct buf *bp)
{
	struct bufq_default *bufq = (struct bufq_default *)bq;
	struct proc *p = bp->b_proc;
	struct buf *head;

	if (p == NULL || p->p_nice < NZERO)
		head = &bufq->bufq_head[0];
	else if (p->p_nice == NZERO)
		head = &bufq->bufq_head[1];
	else
		head = &bufq->bufq_head[2];

	disksort(head, bp);
}

struct buf *
bufq_default_get(struct bufq *bq)
{
	struct bufq_default *bufq = (struct bufq_default *)bq;
	struct buf *bp, *head;
	int i;

	for (i = 0; i < 3; i++) {
		head = &bufq->bufq_head[i];
		if ((bp = head->b_actf))
			break;
	}
	if (bp == NULL)
		return (NULL);
	head->b_actf = bp->b_actf;
	return (bp);
}

@


1.87
log
@initialize d_npartitions to MAXPARTITIONS always; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.86 2009/05/03 06:45:58 krw Exp $	*/
d418 10
a564 6
			goto notfat;

		/* Check the end of sector marker. */
		fattest = ((bp->b_data[510] << 8) & 0xff00) |
		    (bp->b_data[511] & 0xff);
		if (fattest != 0x55aa)
@


1.86
log
@Discovering an extended MBR partition and setting 'wander' to 1
should not stop the spoofing process. Setting 'wander' means when
we are done with this MBR, read the next one.

Problem noted and fix tested by Nick Guenther.

ok weingart@@ (I think), deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.85 2009/03/28 14:58:10 dlg Exp $	*/
d201 1
a201 1
	lp->d_npartitions = RAW_PART + 1;
@


1.85
log
@use a static and unique string as the disk lock name, so if we're waiting
on the disk lock we can find that code rather than wondering where "sd0"
gets passed to tsleep.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.84 2009/02/09 20:00:48 otto Exp $	*/
d498 1
d507 3
a509 3
			 * Don't set fstype/offset/size when wandering or just
			 * looking for the offset of the OpenBSD partition. It
			 * would invalidate the disklabel checksum!
d511 1
a511 1
			if (wander || partoffp)
@


1.84
log
@two more consistency checks for a disklabel, to prevent havoc later
on; prompted by Thorsten Glaser; ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.83 2008/11/21 23:51:30 krw Exp $	*/
d755 1
a755 1
	rw_init(&diskp->dk_lock, lockname);
@


1.83
log
@Relax sanity check so any two-byte jmp followed by a NOP, or any
three-byte jmp will be acceptable as the preamble to a FAT boot
sector for the purposes of spoofing an 'i' partition. Problem noted
most recently by mbalmer@@.

Fixes mbalmer@@, fkr@@ and jmc@@'s Nokia E71 phones.

"seems silly" tedu@@ "disgusting" deraadt@@ "makes sense" fkr@@
ok jmc@@ "looks ok" weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.82 2008/08/25 11:27:00 krw Exp $	*/
d232 5
a236 1
		msg = "unreasonable partition count";
d238 1
a238 1
		msg = "disk label corrupted";
@


1.82
log
@If partoffp is non-NULL then readdoslabel() is just looking for the
correct address to write the passed label. Don't spoof partitions
while looking for the address, as this could result in an invalid
label being written out.

"That looks right" deraadt@@ "Looks good to me" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.81 2008/08/22 03:19:02 deraadt Exp $	*/
d525 17
a541 4
		/* Check for a short jump instruction. */
		fattest = ((bp->b_data[0] << 8) & 0xff00) |
		    (bp->b_data[2] & 0xff);
		if (fattest != 0xeb90 && fattest != 0xe900)
d543 2
@


1.81
log
@simplification, and repair findblkmajor for name## lookups; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.80 2008/08/08 23:49:53 krw Exp $	*/
d450 1
d463 1
a463 1
				pp->p_fstype = FS_UNUSED;
d468 1
a468 1
				pp->p_fstype = FS_EXT2FS;
d473 1
a473 1
				pp->p_fstype = FS_NTFS;
d483 1
a483 1
				pp->p_fstype = FS_MSDOS;
d496 1
a496 1
				pp->p_fstype = FS_OTHER;
d502 3
a504 3
			 * There is no need to set the offset/size when
			 * wandering; it would also invalidate the
			 * disklabel checksum.
d506 1
a506 1
			if (wander)
d509 1
d516 4
@


1.80
log
@Admit b_blkno means block number; a block is DEV_BSIZE (a.k.a.
512) bytes; ffs is inextricably tied to using b_blkno and disklabel
always uses sectorsize units.

Thus use DEV_BSIZE units for all fields describing ffs filesystems
and convert to/from sectors where required. This enables the creation
and use of ffs filesystems on non-512 byte sectorsize devices.

This diff allows i386 and sgi (the two test platforms) to find
disklabels that are not on a sectorsize boundary. Same change to
further archs coming.

This is a no-op on 512-byte sectorsize devices.

This work triggered by jsing@@'s need to create ffs filesystems on
sgi cdroms so we can create cdrom install media for sgi.

sgi testing by jsing@@

ok jsing@@ pedro@@ "looks sane" beck@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.79 2008/06/25 15:26:43 reyk Exp $	*/
d1019 1
a1020 1
	int majdev, part;
d1028 1
a1028 3
	} else
		part = defpart;

d1258 1
a1258 1
	char *name = dv->dv_xname;
d1261 6
d1268 1
a1268 1
		if (!strncmp(name, nam2blk[i].name, strlen(nam2blk[i].name)))
@


1.79
log
@allow to install and boot the OpenBSD A6 partition and disklabel in an
extended DOS partition.  the concept of extended partitions is very
simple, it is just another mbr at the partition offset (well, the
standard "EBR" is a linked list with a few limitations, but this diff
works with both variants).

this diff has been in the snapshots for a while.

with input from weingart@@ and krw@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.78 2008/06/12 06:58:39 deraadt Exp $	*/
d381 1
d401 2
a402 1
		bp->b_blkno = part_blkno;
d412 1
a412 1
		bcopy(bp->b_data + DOSPARTOFF, dp, sizeof(dp));
d553 3
a555 1
	bp->b_blkno = dospartoff + DOS_LABELSECTOR;
d563 1
a563 1
	return checkdisklabel(bp->b_data, lp);
a626 1
#define blockpersec(count, lp) ((count) * (((lp)->d_secsize) / DEV_BSIZE))
d638 2
a639 2
	if (bp->b_blkno + sz > blockpersec(DL_GETPSIZE(p), lp)) {
		sz = blockpersec(DL_GETPSIZE(p), lp) - bp->b_blkno;
d654 2
a655 2
	bp->b_cylinder = (bp->b_blkno + blockpersec(DL_GETPOFFSET(p), lp)) /
	    blockpersec(lp->d_secpercyl, lp);
@


1.78
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.75 2008/06/10 20:14:36 beck Exp $	*/
d412 1
a412 1
		if (ourpart == -1 && part_blkno == DOSBBSECTOR) {
a456 5
			if (letoh32(dp2->dp_start))
				DL_SETPOFFSET(pp,
				    letoh32(dp2->dp_start) + part_blkno);

			DL_SETPSIZE(pp, letoh32(dp2->dp_size));
d497 13
@


1.77
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.74 2008/05/23 00:51:33 krw Exp $	*/
d402 1
a402 1
		bp->b_flags = B_BUSY | B_READ;
d545 1
a545 1
	bp->b_flags = B_BUSY | B_READ;
@


1.76
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.75 2008/06/10 20:14:36 beck Exp $	*/
d402 1
a402 1
		bp->b_flags = B_BUSY | B_READ | B_RAW;
d545 1
a545 1
	bp->b_flags = B_BUSY | B_READ | B_RAW;
@


1.75
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.74 2008/05/23 00:51:33 krw Exp $	*/
d545 1
a545 1
	bp->b_flags = B_BUSY | B_READ;
@


1.74
log
@Make rd act more like a 'normal' disk device, allowing the elimination of
'fakerootdev' hackery. This allows us to bring back miod@@'s r1.70 subr_disk.c
change to avoid the GENERIC dance when rootdev has been initialized. This
in turn re-enables raidframe root devices.

Add a nice panic if rootdev can't be initialized, displaying the name of the
device that didn't work rather than just blowing up by de-referencing NULL.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.73 2008/04/07 23:10:24 krw Exp $	*/
d402 1
a402 1
		bp->b_flags = B_BUSY | B_READ;
@


1.73
log
@Compare device names consistantly in parsedisk().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.72 2008/03/31 23:56:29 deraadt Exp $	*/
a983 4
#ifdef RAMDISK_HOOKS
static struct device fakerdrootdev = { DV_DISK, {}, NULL, 0, "rd0", NULL };
#endif

a990 3
#ifdef RAMDISK_HOOKS
		printf(" %s[a-p]", fakerdrootdev.dv_xname);
#endif
a1019 6
#ifdef RAMDISK_HOOKS
	if (strncmp(str, fakerdrootdev.dv_xname, len) == 0) {
		dv = &fakerdrootdev;
		goto gotdisk;
	}
#endif
a1024 3
#ifdef RAMDISK_HOOKS
gotdisk:
#endif
a1056 6
#ifdef RAMDISK_HOOKS
	bootdv = &fakerdrootdev;
	mountroot = NULL;
	part = 0;
#endif

d1152 1
a1152 1
	} else if (mountroot == NULL) {
d1154 1
a1154 2
		 * `swap generic' or RAMDISK_HOOKS -- use the
		 * device we were told to
d1184 2
@


1.72
log
@nope, sorry, the miod/naddy raidframe change breaks almost all ramdisks.
the basic idea is that ramdisks boot the same way as swap generic -- this
commit also improves the comment in that area.  in this case the one
outlier is raidframe, and those who use it will no longer be able to
put off repairing it -- raidframe must follow the same setroot() / bootdv
API that everything else in the system uses.

debugged with krw
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.71 2008/03/31 22:27:41 deraadt Exp $	*/
d1028 1
a1028 1
	if (strcmp(str, fakerdrootdev.dv_xname) == 0) {
@


1.71
log
@Refine "netboot" interface group semantics to indicate the interface we
booted from to the most precision; preferring the boot device, or if that
is not known, the root device
discussed with miod and reyk
tested by beck
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.70 2008/03/30 20:24:32 miod Exp $	*/
d1174 5
a1178 2
	} else if (mountroot == NULL && rootdev == NODEV) {
		/* `swap generic': Use the device the ROM told us to use */
@


1.70
log
@Do not do the ``swap generic'' behaviour if rootdev != NODEV when entering
setroot(), as this neuters RAIDframe autoconfiguration; found the hard way
by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.69 2008/03/23 17:05:40 deraadt Exp $	*/
d61 5
d1067 1
d1205 8
@


1.69
log
@setroot() is supposed to be safe in all cases, so kill the special cases
for RB_DFLTROOT; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.68 2007/12/23 01:59:58 dlg Exp $	*/
d1168 1
a1168 1
	} else if (mountroot == NULL) {
@


1.68
log
@protect the disk statistics with a mutex.

ok tedu@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.67 2007/12/16 20:57:17 otto Exp $	*/
a1065 3

	if (boothowto & RB_DFLTROOT)
		return;
@


1.67
log
@panic on negative blkno or size; ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.66 2007/11/09 11:32:57 jsing Exp $	*/
d715 1
d788 2
a789 1
	if (diskp->dk_busy++ == 0) {
d791 1
a791 1
	}
d803 2
d824 2
@


1.66
log
@Make disklabel aware of NTFS.

ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.65 2007/09/07 15:00:20 art Exp $	*/
d617 3
@


1.65
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.64 2007/08/05 04:26:21 krw Exp $	*/
d466 5
@


1.64
log
@Move some printf's about disklabel disksize and RAW_PART size/offset
under #ifdef DEBUG. Adjust the verbiage. Some minor tweaks while in
the area.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.63 2007/08/05 03:24:58 krw Exp $	*/
d728 2
a729 1
	diskp->dk_label = malloc(sizeof(struct disklabel), M_DEVBUF, M_NOWAIT);
a732 2
	bzero(diskp->dk_label, sizeof(struct disklabel));

d913 1
a913 1
	bq = malloc(sizeof(*bq), M_DEVBUF, M_NOWAIT);
a916 1
	memset(bq, 0, sizeof(*bq));
@


1.63
log
@Use d_partitions[DISKPART(dev)] rather that d_partitions +
DISKPART(dev). Thus making the idiom the same everywhere.

pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.62 2007/06/25 16:11:42 otto Exp $	*/
d318 1
a318 1
	/* Initial passed in lp contains the real disk size */
d338 1
a338 1
#ifdef noonecares
d340 8
a347 2
		printf("new disklabel disk size different %lld != %lld\n",
		    DL_GETDSIZE(lp), disksize);
d350 1
a350 9

	if (DL_GETPSIZE(&lp->d_partitions[RAW_PART]) != DL_GETDSIZE(lp))
		printf("new disklabel raw disk size different %lld != %lld\n",
		    DL_GETPSIZE(&lp->d_partitions[RAW_PART]), DL_GETDSIZE(lp));
	DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));

	if (DL_GETPOFFSET(&lp->d_partitions[RAW_PART]) != 0)
		printf("new disklabel raw disk offset different %lld != %lld\n",
		    DL_GETPOFFSET(&lp->d_partitions[RAW_PART]), 0);
d541 1
a541 1
	return checkdisklabel(bp->b_data + 0, lp);
@


1.62
log
@use daddr64_t for size in bounds_check_with_label(); prompted by miod@@;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.61 2007/06/20 18:15:47 deraadt Exp $	*/
d608 1
a608 1
	struct partition *p = lp->d_partitions + DISKPART(bp->b_dev);
@


1.61
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.60 2007/06/17 00:27:30 deraadt Exp $	*/
d609 1
a609 1
	int sz = howmany(bp->b_bcount, DEV_BSIZE);
@


1.60
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.59 2007/06/10 16:37:09 deraadt Exp $	*/
d371 1
a371 2
    struct disklabel *lp, struct cpu_disklabel *osdep,
    int *partoffp, int *cylp, int spoofonly)
d376 1
a376 1
	int dospartoff = 0, cyl, i, ourpart = -1;
a384 1
	cyl = DOS_LABELSECTOR / lp->d_secpercyl;
a399 1
		bp->b_cylinder = part_blkno / lp->d_secpercyl;
a424 1
			cyl = DPCYL(dp2->dp_scyl, dp2->dp_ssect);
a529 2
	if (cylp)
		*cylp = cyl;
a535 1
	bp->b_cylinder = cyl;
d551 1
a551 2
setdisklabel(struct disklabel *olp, struct disklabel *nlp,
    u_int openmask, struct cpu_disklabel *osdep)
d605 1
a605 2
bounds_check_with_label(struct buf *bp, struct disklabel *lp,
    struct cpu_disklabel *osdep, int wlabel)
d731 1
a731 3
	diskp->dk_cpulabel = malloc(sizeof(struct cpu_disklabel), M_DEVBUF,
	    M_NOWAIT);
	if ((diskp->dk_label == NULL) || (diskp->dk_cpulabel == NULL))
a734 1
	bzero(diskp->dk_cpulabel, sizeof(struct cpu_disklabel));
a759 1
	free(diskp->dk_cpulabel, M_DEVBUF);
@


1.59
log
@when we change fields in the label to version 1, fix the checksum (but only
if it was ok beforehands)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.58 2007/06/09 23:35:23 krw Exp $	*/
d184 26
d211 2
a212 3
 * Convert an on-disk disklabel to a kernel disklabel, converting versions
 * as required and applying constraints that kernel disklabels are guaranteed
 * to satisfy.
d214 2
a215 2
void
disklabeltokernlabel(struct disklabel *lp)
d217 22
a238 3
	struct __partitionv0 *v0pp = (struct __partitionv0 *)lp->d_partitions;
	struct partition *pp = lp->d_partitions;
	int i, oversion = lp->d_version, changed = 0, okbefore = 0;
d240 67
a306 2
	if (dkcksum(lp) == 0)
		okbefore = 1;
d308 17
a324 1
	if (oversion == 0) {
a326 2
		changed = 1;
	}
d328 3
a330 2
	for (i = 0; i < MAXPARTITIONS; i++, pp++, v0pp++) {
		if (oversion == 0) {
d336 73
d410 1
a410 2
#ifdef notyet
		/* XXX this should not be here */
d412 86
a497 15
		/* In a V1 label no partition extends past DL_GETSIZE(lp) - 1. */
		if (DL_GETPOFFSET(pp) > DL_GETDSIZE(lp)) {
			pp->p_fstype = FS_UNUSED;
			DL_SETPSIZE(pp, 0);
			DL_SETPOFFSET(pp, 0);
		} else if (DL_GETPOFFSET(pp) + DL_GETPSIZE(pp) > DL_GETDSIZE(lp)) {
			daddr64_t sz;

			printf("%lld %lld %lld\n",
			    DL_GETPOFFSET(pp), DL_GETPSIZE(pp),
			    DL_GETPOFFSET(pp) + DL_GETPSIZE(pp),
			    DL_GETDSIZE(lp));
			pp->p_fstype = FS_UNUSED;
			sz = DL_GETDSIZE(lp) - DL_GETPOFFSET(pp);
			DL_SETPSIZE(pp, sz);
a498 1
#endif
d500 1
d502 26
a527 9
	/* XXX this should not be here */
	if (DL_GETPOFFSET(&lp->d_partitions[RAW_PART]) != 0) {
		DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
		changed = 1;
	}
	if (changed && okbefore) {
		lp->d_checksum = 0;
		lp->d_checksum = dkcksum(lp);
d529 22
@


1.58
log
@blocks/sectors != blocks/blocks. Fix calculation of b_cylinder in
bounds_check_with_label(). Tweak error path to eliminate duplicate
code.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.57 2007/06/09 23:06:45 krw Exp $	*/
d194 4
a197 1
	int i, oversion = lp->d_version;
d202 1
d236 9
a244 2
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
@


1.57
log
@The differences in the last non-homogeneous bounds_check_with_label()
routines (alpha, vax) prove to be not worth keeping. Move
bounds_check_with_label() into the MI world. Eliminate unreliable and
almost certainly useless checks for overwriting a disklabel.

After discussion with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.56 2007/06/09 17:18:36 deraadt Exp $	*/
d304 1
a304 2
	if (lp->d_secpercyl == 0) {
		bp->b_error = EINVAL;
a305 1
	}
d315 1
a315 1
		if (sz < 0) {
a316 1
			bp->b_error = EINVAL;
d318 1
a318 1
		}
d325 1
a325 1
	    lp->d_secpercyl;
d329 1
@


1.56
log
@silently whack wrong-sized C partitions
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.55 2007/06/09 06:03:24 deraadt Exp $	*/
d288 46
@


1.55
log
@handle C non-0 start after doing v1 converstion.. sigh
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.54 2007/06/09 04:08:37 deraadt Exp $	*/
d232 2
a233 5
	if (DL_GETPOFFSET(&lp->d_partitions[RAW_PART]) != 0) {
		printf("disklabeltokernlabel: Your raw partition MUST start at 0\n");
		DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	}
@


1.54
log
@by hand i carefully found that all the differences in setdisklabel()
implimentations were simply either missing code, or spacing and such.
setdisklabel() can become MI now.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.53 2007/06/09 03:56:48 deraadt Exp $	*/
a200 7
	/* XXX this should not be here */
	if (DL_GETPOFFSET(&lp->d_partitions[RAW_PART]) != 0) {
		printf("disklabeltokernlabel: Your raw partition MUST start at 0\n");
		DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
		DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	}

d229 7
@


1.53
log
@be even more forceful with RAW_PART (and note this is the wrong, and temporary, place
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.52 2007/06/09 03:53:17 deraadt Exp $	*/
d237 54
@


1.52
log
@push RAW_PART to 0 if it is non-zero, and bitch
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.51 2007/06/06 22:04:11 deraadt Exp $	*/
d201 1
d205 1
d216 3
a218 1
#ifdef notyet  /* older broken sparc/sparc64 fake cyl-based disklabels fool this */
@


1.51
log
@fix format strings for block #'s now that they are 64 bit; ok tedu (who
also spotted one more)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.50 2007/06/06 17:15:13 deraadt Exp $	*/
d199 5
@


1.50
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.49 2007/06/06 16:49:51 deraadt Exp $	*/
d274 1
a274 1
		(*pr)(" (%s%d bn %lld; cn %d", dname, unit, sn,
d277 2
a278 1
		(*pr)(" tn %d sn %d)", sn / lp->d_nsectors, sn % lp->d_nsectors);
@


1.49
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.48 2007/06/06 16:39:49 deraadt Exp $	*/
d251 1
a251 1
	int sn;
d263 1
a263 1
		(*pr)("%d", sn);
d267 1
a267 1
			(*pr)("%d of ", sn);
d269 1
a269 1
		(*pr)("%d-%d", bp->b_blkno,
d274 1
a274 1
		(*pr)(" (%s%d bn %d; cn %d", dname, unit, sn,
@


1.48
log
@even more problems with disk size consistancy checks
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.47 2007/06/05 00:38:23 deraadt Exp $	*/
d225 1
a226 1
		}
@


1.47
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.45 2007/06/02 02:35:27 krw Exp $	*/
d209 1
a214 1
#ifdef notyet  /* older broken sparc/sparc64 fake cyl-based disklabels fool this */
@


1.46
log
@disable a part of the label validation because some Sun systems
have contradictory information in their cyl-based labels
@
text
@d209 2
a210 2
		/* In a V1 label no partition extends past DL_SIZE(lp) - 1. */
		if (DL_POFFSET(pp) >= DL_DSIZE(lp)) {
d212 4
a215 4
			pp->p_offset = pp->p_offseth = 0;
			pp->p_size = pp->p_sizeh = 0;
#ifdef notyet	/* older broken sparc/sparc64 fake cyl-based disklabels fool this */
		} else if ((DL_POFFSET(pp) + DL_PSIZE(pp)) > DL_DSIZE(lp)) {
d218 4
d223 3
a225 4
			sz = DL_DSIZE(lp) - DL_POFFSET(pp);
			pp->p_size = sz & 0xffffffff;
			pp->p_sizeh = (sz >> 32) & 0xffff;
#endif /* notyet */
d273 1
a273 1
		sn += lp->d_partitions[part].p_offset;
d458 1
a458 1
	if (dl.d_partitions[part].p_size == 0)
@


1.45
log
@Rename cvtdisklabelv1 -> disklabeltokernlabel. It does more than just
convert version 0 to version 1 disklabels.

Suggested by deraadt@@.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.44 2007/06/01 19:06:28 krw Exp $	*/
a193 1
	daddr64_t sz;
d214 1
d216 2
d222 1
@


1.44
log
@Add two constraints to V1 disklabels:

1) All partitions must start before the end of the disk.  2) All
partitions must end at or before the end of the disk.

Partitions not satisfying these constraints will be truncated and
marked FS_UNUSED.

ok otto@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.43 2007/05/29 06:28:15 otto Exp $	*/
d185 3
a187 1
 * Convert an old disklabel to a v1 disklabel
d190 1
a190 1
cvtdisklabelv1(struct disklabel *lp)
@


1.43
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.42 2007/05/18 16:26:38 drahn Exp $	*/
d190 9
a198 1
	int i;
d200 7
a206 2
	if (lp->d_version == 1)
		return;
d208 11
a218 11
	lp->d_version = 1;
	lp->d_secperunith = 0;
	for (i = 0; i < MAXPARTITIONS; i++) {
		struct partition *pp = &lp->d_partitions[i];
		struct __partitionv0 *v0pp = (struct __partitionv0 *)
		    &lp->d_partitions[i];

		pp->p_fragblock = DISKLABELV1_FFS_FRAGBLOCK(v0pp->p_fsize,
		    v0pp->p_frag);
		pp->p_offseth = 0;
		pp->p_sizeh = 0;	
@


1.42
log
@Dont write to the string passed to parsedisk(), ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.41 2007/05/18 07:37:18 deraadt Exp $	*/
d182 25
@


1.41
log
@in case of pre-configured nfs, we must assume that the bootdv is the rootdv
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.40 2007/05/15 01:58:06 deraadt Exp $	*/
d545 1
a545 1
	char *cp, c;
d550 1
a550 2
	cp = str + len - 1;
	c = *cp;
d553 1
a553 1
		*cp = '\0';
d566 2
a567 1
		    strcmp(str, dv->dv_xname) == 0) {
d579 2
a580 1
		    strcmp(str, dv->dv_xname) == 0) {
a586 1
	*cp = c;
@


1.40
log
@now that setroot() prints nice things like:
  root on sd0a swap on sd0b dump on sd0b
we can skip printing:
  rootdev=0x400 rrootdev=0xd00 rawdev=0xd02
ok miod, no objections from other lazy slackers
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.39 2007/05/10 06:02:04 deraadt Exp $	*/
d703 1
@


1.39
log
@also print where (primary) swap and dumps are; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.38 2007/05/05 12:43:35 art Exp $	*/
d391 1
d394 1
@


1.38
log
@Kill disk_find and disk_resetstat that noone uses. If you ever need
them, they are still in cvs.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.37 2007/05/04 23:21:23 deraadt Exp $	*/
a713 1
			dumpdev = nswapdev;
d718 1
a718 1
			nswapdev = dumpdev = NODEV;
d720 1
a744 1
		printf("root on %s%c\n", rootdv->dv_xname, 'a' + part);
d751 2
d773 8
@


1.37
log
@when we are in ramdisk mode, we must also disable any previous mountroot
setting that pre-setroot() code did (for instance a network boot)
found by phessler, tested by reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.36 2007/05/04 19:30:55 deraadt Exp $	*/
a245 19
/*
 * Searches the disklist for the disk corresponding to the
 * name provided.
 */
struct disk *
disk_find(char *name)
{
	struct disk *diskp;

	if ((name == NULL) || (disk_count <= 0))
		return (NULL);

	TAILQ_FOREACH(diskp, &disklist, dk_link)
		if (strcmp(diskp->dk_name, name) == 0)
			return (diskp);

	return (NULL);
}

a378 25

/*
 * Reset the metrics counters on the given disk.  Note that we cannot
 * reset the busy counter, as it may case a panic in disk_unbusy().
 * We also must avoid playing with the timestamp information, as it
 * may skew any pending transfer results.
 */
void
disk_resetstat(struct disk *diskp)
{
	int s = splbio();

	diskp->dk_rxfer = 0;
	diskp->dk_rbytes = 0;
	diskp->dk_wxfer = 0;
	diskp->dk_wbytes = 0;
	diskp->dk_seek = 0;

	microuptime(&diskp->dk_attachtime);

	timerclear(&diskp->dk_time);

	splx(s);
}

@


1.36
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.35 2007/05/04 03:44:45 deraadt Exp $	*/
d649 1
@


1.35
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.34 2007/03/30 00:38:56 dlg Exp $	*/
d815 25
@


1.34
log
@replace lockmgr locks with rwlocks. these are no longer recursive, but they
weren't used recursively anyway.

tested by hsoexer@@ fkr@@  ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.33 2007/03/27 18:04:01 thib Exp $	*/
d49 1
d55 1
d59 1
d62 1
d554 261
@


1.33
log
@Remove an #ifdef LFS chunk from dk_mountroot();

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.32 2006/05/11 18:58:59 miod Exp $	*/
d264 1
a264 2
	lockinit(&diskp->dk_lock, PRIBIO | PCATCH, lockname,
		 0, LK_CANRECURSE);
d384 1
a384 1
	error = lockmgr(&dk->dk_lock, LK_EXCLUSIVE, NULL);
d392 1
a392 1
	lockmgr(&dk->dk_lock, LK_RELEASE, NULL);
@


1.32
log
@One more (!foo & BAR) bogus test.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.31 2005/12/09 09:09:52 jsg Exp $	*/
a466 8
		}
		break;
#endif
#ifdef LFS
	case FS_BSDLFS:
		{
		extern int lfs_mountroot(void);
		mountrootfn = lfs_mountroot;
@


1.31
log
@ansi and deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.30 2005/11/19 02:18:01 pedro Exp $	*/
d279 1
a279 1
	if (!diskp->dk_flags & DKF_CONSTRUCTED)
@


1.30
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.29 2004/12/26 21:22:13 miod Exp $	*/
d88 1
a88 2
disksort(ap, bp)
	register struct buf *ap, *bp;
d90 1
a90 1
	register struct buf *bq;
d168 1
a168 2
dkcksum(lp)
	register struct disklabel *lp;
d170 2
a171 2
	register u_int16_t *start, *end;
	register u_int16_t sum = 0;
d195 2
a196 5
diskerr(bp, dname, what, pri, blkdone, lp)
	register struct buf *bp;
	char *dname, *what;
	int pri, blkdone;
	register struct disklabel *lp;
d199 1
a199 1
	register int (*pr)(const char *, ...);
d235 1
a235 1
disk_init()
d247 1
a247 2
disk_find(name)
	char *name;
d262 1
a262 3
disk_construct(diskp, lockname)
	struct disk *diskp;
	char *lockname;
d276 1
a276 2
disk_attach(diskp)
	struct disk *diskp;
d313 1
a313 2
disk_detach(diskp)
	struct disk *diskp;
d336 1
a336 2
disk_busy(diskp)
	struct disk *diskp;
d353 1
a353 4
disk_unbusy(diskp, bcount, read)
	struct disk *diskp;
	long bcount;
	int read;
d381 1
a381 2
disk_lock(dk)
	struct disk *dk;
d391 1
a391 2
disk_unlock(dk)
	struct disk *dk;
d403 1
a403 2
disk_resetstat(diskp)
	struct disk *diskp;
d422 1
a422 1
dk_mountroot()
@


1.29
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.28 2004/11/01 03:43:24 pedro Exp $	*/
a393 1

d400 1
a400 1
	error = lockmgr(&dk->dk_lock, LK_EXCLUSIVE, 0, curproc);
d409 1
a409 1
	lockmgr(&dk->dk_lock, LK_RELEASE, 0, curproc);
a410 1

@


1.28
log
@check for malloc() in bufq_default_alloc(), ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.27 2004/10/25 19:53:52 pedro Exp $	*/
d260 1
a260 2
	for (diskp = disklist.tqh_first; diskp != NULL;
	    diskp = diskp->dk_link.tqe_next)
@


1.27
log
@remove dead 'ifdef tahoe' code, ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.26 2004/06/24 19:35:24 tholo Exp $	*/
d529 3
@


1.26
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.25 2004/02/15 02:45:46 tedu Exp $	*/
a227 3
#ifdef tahoe
		sn *= DEV_BSIZE / lp->d_secsize;		/* XXX */
#endif
@


1.25
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.24 2004/01/21 21:00:14 tedu Exp $	*/
a290 1
	int s;
d312 1
a312 3
	s = splclock();
	diskp->dk_attachtime = mono_time;
	splx(s);
a352 1
	int s;
d359 1
a359 3
		s = splclock();
		diskp->dk_timestamp = mono_time;
		splx(s);
a372 1
	int s;
d378 1
a378 3
	s = splclock();
	dv_time = mono_time;
	splx(s);
d428 1
a428 1
	int s = splbio(), t;
d436 1
a436 3
	t = splclock();
	diskp->dk_attachtime = mono_time;
	splx(t);
@


1.24
log
@dynamic bufq support.  basically a nullop.  ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.23 2003/06/25 20:52:57 tedu Exp $	*/
d374 1
a374 1
disk_unbusy(diskp, bcount)
d377 1
d394 9
a402 4
		diskp->dk_bytes += bcount;
		diskp->dk_xfer++;
	}
	diskp->dk_seek++;
d439 4
a442 2
	diskp->dk_xfer = 0;
	diskp->dk_bytes = 0;
@


1.23
log
@implement new means of manipulating buf queues, bufq.
accessed with BUFQ macros, bufq structs support extensible, potentially
changable algorithms and queue formats.  the current default scheme
should support nice priority based queuing, but is missing some vfs_bio.c
support.
only on wd.c for now, other drivers are easy converts.
as a side bonus, this makes the driver code look cleaner.
idea for the name comes from netbsd, but this scheme is incompatible.
thanks to various people for testing.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.22 2003/06/02 23:28:06 millert Exp $	*/
d527 20
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.21 2002/03/14 01:27:04 millert Exp $	*/
d527 35
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.20 2001/05/14 07:16:12 angelos Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.20
log
@Set a flag whenever a disk is added/removed, so sysctl knows when to
update settings.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.19 2000/11/07 16:58:01 art Exp $	*/
d208 1
a208 1
	register int (*pr) __P((const char *, ...));
d456 1
a456 1
	int (*mountrootfn) __P((void));
d487 1
a487 1
		extern int ext2fs_mountroot __P((void));
d495 1
a495 1
		extern int ffs_mountroot __P((void));
d503 1
a503 1
		extern int lfs_mountroot __P((void));
d511 1
a511 1
		extern int cd9660_mountroot __P((void));
d519 1
a519 1
		extern int ffs_mountroot __P((void));
@


1.20.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.20 2001/05/14 07:16:12 angelos Exp $	*/
d208 1
a208 1
	register int (*pr)(const char *, ...);
d456 1
a456 1
	int (*mountrootfn)(void);
d487 1
a487 1
		extern int ext2fs_mountroot(void);
d495 1
a495 1
		extern int ffs_mountroot(void);
d503 1
a503 1
		extern int lfs_mountroot(void);
d511 1
a511 1
		extern int cd9660_mountroot(void);
d519 1
a519 1
		extern int ffs_mountroot(void);
@


1.19
log
@No need for extern struct proc *curproc.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.18 2000/04/09 19:26:35 csapuntz Exp $	*/
d70 4
d251 1
a251 1
	disk_count = 0;
d326 1
d347 1
@


1.18
log
@

Move a locking function that was spread throughout disk device drivers into
the disk structure.

The locking was mostly used in disk device drivers to prevent multiple
disklabel operations from going on simultaneously against the device.

Added disk_construct(), a constructor for the disk structure, that
initializes the lock structure in disk. It is called by default in
disk_attach() if it hasn't been called yet.

Added disk_lock and disk_unlock
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.17 1999/11/17 04:31:22 d Exp $	*/
a450 1
	extern struct proc *curproc;
@


1.17
log
@allow to compile without -DFFS. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.16 1997/11/23 03:19:18 mickey Exp $	*/
d56 1
d60 1
d271 13
d293 3
d398 20
@


1.17.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.19 2000/11/07 16:58:01 art Exp $	*/
a55 1
#include <sys/lock.h>
a58 1
#include <sys/proc.h>
a268 13
int
disk_construct(diskp, lockname)
	struct disk *diskp;
	char *lockname;
{
	lockinit(&diskp->dk_lock, PRIBIO | PCATCH, lockname,
		 0, LK_CANRECURSE);
	
	diskp->dk_flags |= DKF_CONSTRUCTED;
	    
	return (0);
}

a277 3
	if (!diskp->dk_flags & DKF_CONSTRUCTED)
		disk_construct(diskp, diskp->dk_name);

a380 20

int
disk_lock(dk)
	struct disk *dk;
{
	int error;

	error = lockmgr(&dk->dk_lock, LK_EXCLUSIVE, 0, curproc);

	return (error);
}

void
disk_unlock(dk)
	struct disk *dk;
{
	lockmgr(&dk->dk_lock, LK_RELEASE, 0, curproc);
}


d413 1
@


1.17.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.17.2.1 2001/05/14 22:32:42 niklas Exp $	*/
a69 4
int	disk_change;		/* set if a disk has been attached/detached
				 * since last we looked at this variable. This
				 * is reset by hw_sysctl()
				 */
d247 1
a247 1
	disk_count = disk_change = 0;
a321 1
	disk_change = 1;
a341 1
	disk_change = 1;
@


1.17.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d208 1
a208 1
	register int (*pr)(const char *, ...);
d456 1
a456 1
	int (*mountrootfn)(void);
d487 1
a487 1
		extern int ext2fs_mountroot(void);
d495 1
a495 1
		extern int ffs_mountroot(void);
d503 1
a503 1
		extern int lfs_mountroot(void);
d511 1
a511 1
		extern int cd9660_mountroot(void);
d519 1
a519 1
		extern int ffs_mountroot(void);
@


1.17.2.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.17.2.3 2002/03/28 11:43:04 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.17.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a526 55
}

struct bufq *
bufq_default_alloc(void)
{
	struct bufq_default *bq;

	bq = malloc(sizeof(*bq), M_DEVBUF, M_NOWAIT);
	memset(bq, 0, sizeof(*bq));
	bq->bufq.bufq_free = bufq_default_free;
	bq->bufq.bufq_add = bufq_default_add;
	bq->bufq.bufq_get = bufq_default_get;

	return ((struct bufq *)bq);
}

void
bufq_default_free(struct bufq *bq)
{
	free(bq, M_DEVBUF);
}

void
bufq_default_add(struct bufq *bq, struct buf *bp)
{
	struct bufq_default *bufq = (struct bufq_default *)bq;
	struct proc *p = bp->b_proc;
	struct buf *head;

	if (p == NULL || p->p_nice < NZERO)
		head = &bufq->bufq_head[0];
	else if (p->p_nice == NZERO)
		head = &bufq->bufq_head[1];
	else
		head = &bufq->bufq_head[2];

	disksort(head, bp);
}

struct buf *
bufq_default_get(struct bufq *bq)
{
	struct bufq_default *bufq = (struct bufq_default *)bq;
	struct buf *bp, *head;
	int i;

	for (i = 0; i < 3; i++) {
		head = &bufq->bufq_head[i];
		if ((bp = head->b_actf))
			break;
	}
	if (bp == NULL)
		return (NULL);
	head->b_actf = bp->b_actf;
	return (bp);
@


1.17.2.6
log
@Merge with the trunk
@
text
@d374 1
a374 1
disk_unbusy(diskp, bcount, read)
a376 1
	int read;
d393 4
a396 9
		if (read) {
			diskp->dk_rbytes += bcount;
			diskp->dk_rxfer++;
		} else {
			diskp->dk_wbytes += bcount;
			diskp->dk_wxfer++;
		}
	} else
		diskp->dk_seek++;
d433 2
a434 4
	diskp->dk_rxfer = 0;
	diskp->dk_rbytes = 0;
	diskp->dk_wxfer = 0;
	diskp->dk_wbytes = 0;
@


1.16
log
@nuke prehistoric disk statistics
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.15 1997/08/07 09:27:01 niklas Exp $	*/
d474 1
d482 4
@


1.15
log
@I know u_short will always be 16 bits, call me a pedant..
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.14 1997/05/22 05:34:56 deraadt Exp $	*/
a69 13
 * Old-style disk instrumentation structures.  These will go away
 * someday.
 */
long	dk_seek[DK_NDRIVE];
long	dk_time[DK_NDRIVE];
long	dk_wds[DK_NDRIVE];
long	dk_wpms[DK_NDRIVE];
long	dk_xfer[DK_NDRIVE];
int	dk_busy;
int	dk_ndrive;
int	dkn;			/* number of slots filled so far */

/*
a245 1
	dk_ndrive = DK_NDRIVE;		/* XXX */
@


1.14
log
@missing cr
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.13 1997/05/12 22:43:55 deraadt Exp $	*/
d183 2
a184 2
	register u_short *start, *end;
	register u_short sum = 0;
d186 2
a187 2
	start = (u_short *)lp;
	end = (u_short *)&lp->d_partitions[lp->d_npartitions];
@


1.13
log
@for miniroot, translate swap to ffs
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.12 1997/04/06 20:59:40 deraadt Exp $	*/
d491 1
a491 1
		printf("filesystem type %d not known.. assuming ffs",
@


1.12
log
@bad dkpart(), bad dkunit(), bad bad bad
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.11 1997/02/24 14:19:57 niklas Exp $	*/
d488 4
a491 1
		panic("filesystem type %d not known",
d493 2
@


1.11
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: subr_disk.c,v 1.17 1996/03/16 23:17:08 christos Exp $	*/
a175 5
/* encoding of disk minor numbers, should be elsewhere... */
#define dkunit(dev)		(minor(dev) >> 3)
#define dkpart(dev)		(minor(dev) & 07)
#define dkminor(unit, part)	(((unit) << 3) | (part))

d214 1
a214 1
	int unit = dkunit(bp->b_dev), part = dkpart(bp->b_dev);
@


1.10
log
@Remove lots of timer_state structs as they just ate memory and only a few was
ever used.  Now a single state is kept for net, tty and disk events resp.
Also, call the randomness from disk_unbusy instead of biodone, as biodone
gets a lot of virtual events (from virtual filesystems etc), and as a bonus:
feed xfer time and size into the entropy pool too.
@
text
@d1 1
@


1.9
log
@dk_mountroot() uses ioctl to read disklabel
@
text
@d59 2
d395 2
@


1.8
log
@do not panic for common driver bugs
@
text
@d48 1
d50 1
d54 1
d56 1
d418 74
@


1.7
log
@approximate seeks; banshee@@gabriella.abattoir.com
@
text
@d374 1
a374 1
		panic("disk_unbusy: %s: dk_busy < 0", diskp->dk_name);
@


1.6
log
@make printf/addlog return 0, for compat to userland
@
text
@d388 1
d405 1
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d213 1
a213 1
	register void (*pr) __P((const char *, ...));
@


1.4
log
@From NetBSD: Merge with NetBSD 960217
@
text
@d1 1
a1 1
/*	$NetBSD: subr_disk.c,v 1.16 1996/02/09 18:59:56 christos Exp $	*/
d218 2
a219 1
		log(pri, "");
@


1.3
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 1
a1 1
/*	$NetBSD: subr_disk.c,v 1.15 1996/01/07 22:03:49 thorpej Exp $	*/
d318 1
a318 1
 * Detatch a disk.
d321 1
a321 1
disk_detatch(diskp)
d336 1
a336 1
		panic("disk_detatch: disk_count < 0");
@


1.2
log
@from netbsd:
Move the old-style disk instrumentation "structures" to a central
location (sys/kern/subr_disk.c) and note that they should/will be
deprecated.
@
text
@d1 1
a1 1
/*	$NetBSD: subr_disk.c,v 1.14 1995/12/28 19:16:39 thorpej Exp $	*/
d4 1
d46 2
d49 2
d52 1
a52 1
#include <sys/syslog.h>
d56 7
d72 1
a72 1
int	dk_ndrive = DK_NDRIVE;
d245 166
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: subr_disk.c,v 1.13 1995/03/29 20:57:35 mycroft Exp $	*/
d48 14
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
