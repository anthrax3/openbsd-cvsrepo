head	1.133;
access;
symbols
	OPENBSD_6_1_BASE:1.133
	OPENBSD_6_0:1.132.0.2
	OPENBSD_6_0_BASE:1.132
	OPENBSD_5_9:1.129.0.2
	OPENBSD_5_9_BASE:1.129
	OPENBSD_5_8:1.122.0.4
	OPENBSD_5_8_BASE:1.122
	OPENBSD_5_7:1.121.0.2
	OPENBSD_5_7_BASE:1.121
	OPENBSD_5_6:1.113.0.4
	OPENBSD_5_6_BASE:1.113
	OPENBSD_5_5:1.104.0.4
	OPENBSD_5_5_BASE:1.104
	OPENBSD_5_4:1.99.0.2
	OPENBSD_5_4_BASE:1.99
	OPENBSD_5_3:1.96.0.2
	OPENBSD_5_3_BASE:1.96
	OPENBSD_5_2:1.95.0.2
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.93
	OPENBSD_5_1:1.93.0.4
	OPENBSD_5_0:1.93.0.2
	OPENBSD_5_0_BASE:1.93
	OPENBSD_4_9:1.88.0.4
	OPENBSD_4_9_BASE:1.88
	OPENBSD_4_8:1.88.0.2
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.84.0.2
	OPENBSD_4_7_BASE:1.84
	OPENBSD_4_6:1.79.0.6
	OPENBSD_4_6_BASE:1.79
	OPENBSD_4_5:1.79.0.2
	OPENBSD_4_5_BASE:1.79
	OPENBSD_4_4:1.77.0.2
	OPENBSD_4_4_BASE:1.77
	OPENBSD_4_3:1.74.0.2
	OPENBSD_4_3_BASE:1.74
	OPENBSD_4_2:1.72.0.2
	OPENBSD_4_2_BASE:1.72
	OPENBSD_4_1:1.71.0.4
	OPENBSD_4_1_BASE:1.71
	OPENBSD_4_0:1.71.0.2
	OPENBSD_4_0_BASE:1.71
	OPENBSD_3_9:1.69.0.2
	OPENBSD_3_9_BASE:1.69
	OPENBSD_3_8:1.68.0.4
	OPENBSD_3_8_BASE:1.68
	OPENBSD_3_7:1.68.0.2
	OPENBSD_3_7_BASE:1.68
	OPENBSD_3_6:1.65.0.2
	OPENBSD_3_6_BASE:1.65
	SMP_SYNC_A:1.64
	SMP_SYNC_B:1.64
	OPENBSD_3_5:1.64.0.2
	OPENBSD_3_5_BASE:1.64
	OPENBSD_3_4:1.60.0.2
	OPENBSD_3_4_BASE:1.60
	UBC_SYNC_A:1.57
	OPENBSD_3_3:1.57.0.2
	OPENBSD_3_3_BASE:1.57
	OPENBSD_3_2:1.55.0.2
	OPENBSD_3_2_BASE:1.55
	OPENBSD_3_1:1.51.0.2
	OPENBSD_3_1_BASE:1.51
	UBC_SYNC_B:1.55
	UBC:1.48.0.2
	UBC_BASE:1.48
	OPENBSD_3_0:1.47.0.2
	OPENBSD_3_0_BASE:1.47
	OPENBSD_2_9_BASE:1.43
	OPENBSD_2_9:1.43.0.2
	OPENBSD_2_8:1.41.0.2
	OPENBSD_2_8_BASE:1.41
	OPENBSD_2_7:1.39.0.2
	OPENBSD_2_7_BASE:1.39
	SMP:1.38.0.2
	SMP_BASE:1.38
	kame_19991208:1.38
	OPENBSD_2_6:1.37.0.2
	OPENBSD_2_6_BASE:1.37
	OPENBSD_2_5:1.36.0.6
	OPENBSD_2_5_BASE:1.36
	OPENBSD_2_4:1.36.0.4
	OPENBSD_2_4_BASE:1.36
	OPENBSD_2_3:1.36.0.2
	OPENBSD_2_3_BASE:1.36
	OPENBSD_2_2:1.30.0.2
	OPENBSD_2_2_BASE:1.30
	OPENBSD_2_1:1.27.0.2
	OPENBSD_2_1_BASE:1.27
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.133
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.132;
commitid	CHRb0fCqa8XxUAMH;

1.132
date	2016.07.10.00.39.31;	author millert;	state Exp;
branches;
next	1.131;
commitid	QLZEYd7LlO7UBFx1;

1.131
date	2016.05.17.23.43.47;	author bluhm;	state Exp;
branches;
next	1.130;
commitid	FQUHD8bvWBEOY9mu;

1.130
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.129;
commitid	gAjwyca5TfuoJAhn;

1.129
date	2016.01.28.18.02.36;	author stefan;	state Exp;
branches;
next	1.128;
commitid	fsgmOcbYuputR8vV;

1.128
date	2016.01.14.09.44.08;	author sf;	state Exp;
branches;
next	1.127;
commitid	ufhpvQnfS1RjjAYf;

1.127
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.126;
commitid	Cl55DD2g2xm69E6W;

1.126
date	2015.11.02.16.31.55;	author semarie;	state Exp;
branches;
next	1.125;
commitid	PyvdcQVr9G4daVnG;

1.125
date	2015.10.28.11.17.24;	author deraadt;	state Exp;
branches;
next	1.124;
commitid	5ecbDxPPTexm1UhA;

1.124
date	2015.08.28.03.49.34;	author deraadt;	state Exp;
branches;
next	1.123;
commitid	xUvZC7YyOKqhzsqV;

1.123
date	2015.08.26.21.21.57;	author deraadt;	state Exp;
branches;
next	1.122;
commitid	hqfC3dziM67ofaKH;

1.122
date	2015.07.20.22.28.57;	author sf;	state Exp;
branches;
next	1.121;
commitid	0jNvJBFsXwToDgPd;

1.121
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.120;
commitid	C5iGb36LQxjM60Q3;

1.120
date	2015.01.13.10.07.58;	author mpf;	state Exp;
branches;
next	1.119;
commitid	IZ2rtJyRuzWF0F1j;

1.119
date	2014.12.17.19.42.15;	author tedu;	state Exp;
branches;
next	1.118;
commitid	G4ldVK4QwvfU3tRp;

1.118
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.117;
commitid	P6Av4XGqOi3rFasL;

1.117
date	2014.12.10.02.44.47;	author tedu;	state Exp;
branches;
next	1.116;
commitid	tsoJBlEBSyYO22RG;

1.116
date	2014.12.01.07.51.47;	author deraadt;	state Exp;
branches;
next	1.115;
commitid	zmRPEs8OxngYg6L4;

1.115
date	2014.11.18.01.59.58;	author tedu;	state Exp;
branches;
next	1.114;
commitid	QaUV8T8O3wiE3EX1;

1.114
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.113;
commitid	uuiU9j2I8AUx0fez;

1.113
date	2014.07.13.15.29.04;	author tedu;	state Exp;
branches;
next	1.112;
commitid	bFFVdS3JEaMhyZxJ;

1.112
date	2014.07.13.14.56.56;	author guenther;	state Exp;
branches;
next	1.111;
commitid	elNUuCoxK8inPN7t;

1.111
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.110;
commitid	QlVV51SZgNFxsXxC;

1.110
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.109;
commitid	EF98ch02VpFassUi;

1.109
date	2014.07.04.05.58.31;	author guenther;	state Exp;
branches;
next	1.108;
commitid	vhXZZxMGVTWiFaF3;

1.108
date	2014.06.06.22.44.18;	author matthew;	state Exp;
branches;
next	1.107;
commitid	lTnAMeRqbbMolWSQ;

1.107
date	2014.05.30.02.12.04;	author tedu;	state Exp;
branches;
next	1.106;

1.106
date	2014.05.25.18.57.07;	author guenther;	state Exp;
branches;
next	1.105;

1.105
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.104;

1.104
date	2013.12.16.18.46.39;	author millert;	state Exp;
branches;
next	1.103;

1.103
date	2013.12.13.19.55.12;	author naddy;	state Exp;
branches;
next	1.102;

1.102
date	2013.10.11.12.44.12;	author millert;	state Exp;
branches;
next	1.101;

1.101
date	2013.10.06.01.10.53;	author millert;	state Exp;
branches;
next	1.100;

1.100
date	2013.10.04.17.52.55;	author millert;	state Exp;
branches;
next	1.99;

1.99
date	2013.06.10.04.44.30;	author guenther;	state Exp;
branches;
next	1.98;

1.98
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.97;

1.97
date	2013.04.24.09.52.54;	author nicm;	state Exp;
branches;
next	1.96;

1.96
date	2013.01.17.21.24.58;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2012.04.22.02.26.11;	author matthew;	state Exp;
branches;
next	1.94;

1.94
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.93;

1.93
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.92;

1.92
date	2011.07.02.22.20.08;	author nicm;	state Exp;
branches;
next	1.91;

1.91
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.90;

1.90
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.89;

1.89
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.88;

1.88
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.86;

1.86
date	2010.06.28.14.13.35;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.84;

1.84
date	2009.11.27.09.18.01;	author sobrado;	state Exp;
branches;
next	1.83;

1.83
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.82;

1.82
date	2009.10.30.16.41.10;	author nicm;	state Exp;
branches;
next	1.81;

1.81
date	2009.10.28.16.56.46;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2009.07.19.08.16.06;	author blambert;	state Exp;
branches;
next	1.79;

1.79
date	2008.12.24.11.20.31;	author kettenis;	state Exp;
branches;
next	1.78;

1.78
date	2008.11.11.15.33.02;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2008.07.28.06.13.22;	author stefan;	state Exp;
branches;
next	1.76;

1.76
date	2008.05.23.16.42.03;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2008.04.10.19.55.41;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2007.10.29.14.12.19;	author chl;	state Exp;
branches;
next	1.73;

1.73
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.72;

1.72
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2006.06.17.00.47.16;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2006.04.27.19.30.28;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2005.12.21.12.43.49;	author jsg;	state Exp;
branches;
next	1.68;

1.68
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2004.11.18.15.10.24;	author markus;	state Exp;
branches;
next	1.66;

1.66
date	2004.09.19.21.34.43;	author mickey;	state Exp;
branches;
next	1.65;

1.65
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.64;

1.64
date	2004.03.19.19.03.07;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2004.02.10.01.19.47;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2003.10.03.16.44.51;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2003.08.23.19.21.15;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.02.23.28.06;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2002.12.20.19.44.23;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2002.12.12.04.17.14;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2002.07.30.00.17.10;	author nordin;	state Exp;
branches;
next	1.54;

1.54
date	2002.07.11.22.48.51;	author art;	state Exp;
branches;
next	1.53;

1.53
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2002.06.11.05.06.18;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2002.03.14.01.27.05;	author millert;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2002.01.30.20.45.35;	author nordin;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.27.22.34.36;	author nordin;	state Exp;
branches;
next	1.48;

1.48
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2001.10.07.22.27.01;	author art;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2001.09.28.13.04.39;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2001.07.05.10.12.24;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.14.07.15.33;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.02.08.04.04;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.01.20.54.34;	author provos;	state Exp;
branches;
next	1.41;

1.41
date	2000.07.19.13.37.28;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2000.06.05.11.02.51;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2000.03.23.17.20.23;	author art;	state Exp;
branches;
next	1.38;

1.38
date	99.11.25.13.41.31;	author art;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	99.06.01.08.23.52;	author art;	state Exp;
branches;
next	1.36;

1.36
date	98.03.28.10.03.04;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	98.02.20.14.51.58;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	98.02.03.19.06.26;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	97.11.13.09.10.57;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	97.11.13.03.56.55;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	97.11.06.05.58.21;	author csapuntz;	state Exp;
branches;
next	1.30;

1.30
date	97.10.21.07.22.13;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	97.10.06.20.20.04;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	97.10.06.15.12.31;	author csapuntz;	state Exp;
branches;
next	1.27;

1.27
date	97.03.26.18.03.57;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.01.12.09.08.27;	author tholo;	state Exp;
branches;
next	1.25;

1.25
date	97.01.05.11.09.02;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	96.12.19.07.54.06;	author tholo;	state Exp;
branches;
next	1.23;

1.23
date	96.12.17.19.19.33;	author tholo;	state Exp;
branches;
next	1.22;

1.22
date	96.12.17.19.15.24;	author tholo;	state Exp;
branches;
next	1.21;

1.21
date	96.12.16.20.04.54;	author tholo;	state Exp;
branches;
next	1.20;

1.20
date	96.12.08.14.25.48;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	96.11.11.04.28.16;	author tholo;	state Exp;
branches;
next	1.18;

1.18
date	96.11.09.18.55.45;	author tholo;	state Exp;
branches;
next	1.17;

1.17
date	96.11.09.18.46.54;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	96.11.06.08.37.39;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.11.05.04.49.16;	author tholo;	state Exp;
branches;
next	1.14;

1.14
date	96.11.05.04.42.30;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	96.11.04.09.00.09;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.11.04.03.28.07;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.10.19.13.26.01;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.08.29.07.46.35;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.08.01.14.17.20;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.07.31.18.34.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.17.05.25.03;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.06.10.07.26.22;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.24.21.26.36;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.27.28;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.17.20.09;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.12.21.11.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.46;	author deraadt;	state Exp;
branches;
next	;

1.38.2.1
date	2000.03.24.09.09.25;	author niklas;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2001.05.14.22.32.44;	author niklas;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2001.07.04.10.48.41;	author niklas;	state Exp;
branches;
next	1.38.2.4;

1.38.2.4
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.38.2.5;

1.38.2.5
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.38.2.6;

1.38.2.6
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.38.2.7;

1.38.2.7
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.38.2.8;

1.38.2.8
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.38.2.9;

1.38.2.9
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.38.2.10;

1.38.2.10
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.38.2.11;

1.38.2.11
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	1.38.2.12;

1.38.2.12
date	2004.06.05.23.13.02;	author niklas;	state Exp;
branches;
next	;

1.47.2.1
date	2002.01.02.20.19.10;	author jason;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2002.08.02.08.09.18;	author miod;	state Exp;
branches;
next	;

1.48.2.1
date	2002.01.31.22.55.41;	author niklas;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.48.2.3;

1.48.2.3
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.48.2.4;

1.48.2.4
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;

1.51.2.1
date	2002.08.02.16.09.15;	author jason;	state Exp;
branches;
next	;


desc
@@


1.133
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@/*	$OpenBSD: tty.c,v 1.132 2016/07/10 00:39:31 millert Exp $	*/
/*	$NetBSD: tty.c,v 1.68.4.2 1996/06/06 16:04:52 thorpej Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1990, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tty.c	8.8 (Berkeley) 1/21/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/proc.h>
#define	TTYDEFCHARS
#include <sys/tty.h>
#undef	TTYDEFCHARS
#include <sys/file.h>
#include <sys/conf.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/syslog.h>
#include <sys/malloc.h>
#include <sys/msgbuf.h>
#include <sys/signalvar.h>
#include <sys/resourcevar.h>
#include <sys/sysctl.h>
#include <sys/pool.h>
#include <sys/poll.h>
#include <sys/unistd.h>
#include <sys/pledge.h>

#include <sys/namei.h>

#include <uvm/uvm_extern.h>

#include <dev/cons.h>
#include <dev/rndvar.h>

#include "pty.h"

static int ttnread(struct tty *);
static void ttyblock(struct tty *);
void ttyunblock(struct tty *);
static void ttyecho(int, struct tty *);
static void ttyrubo(struct tty *, int);
void	ttkqflush(struct klist *klist);
int	filt_ttyread(struct knote *kn, long hint);
void 	filt_ttyrdetach(struct knote *kn);
int	filt_ttywrite(struct knote *kn, long hint);
void 	filt_ttywdetach(struct knote *kn);
void	ttystats_init(struct itty **, size_t *);

/* Symbolic sleep message strings. */
char ttclos[]	= "ttycls";
char ttopen[]	= "ttyopn";
char ttybg[]	= "ttybg";
char ttyin[]	= "ttyin";
char ttyout[]	= "ttyout";

/*
 * Table with character classes and parity. The 8th bit indicates parity,
 * the 7th bit indicates the character is an alphameric or underscore (for
 * ALTWERASE), and the low 6 bits indicate delay type.  If the low 6 bits
 * are 0 then the character needs no special processing on output; classes
 * other than 0 might be translated or (not currently) require delays.
 */
#define	E	0x00	/* Even parity. */
#define	O	0x80	/* Odd parity. */
#define	PARITY(c)	(char_type[c] & O)

#define	ALPHA	0x40	/* Alpha or underscore. */
#define	ISALPHA(c)	(char_type[(c) & TTY_CHARMASK] & ALPHA)

#define	CCLASSMASK	0x3f
#define	CCLASS(c)	(char_type[c] & CCLASSMASK)

#define	BS	BACKSPACE
#define	CC	CONTROL
#define	CR	RETURN
#define	NA	ORDINARY | ALPHA
#define	NL	NEWLINE
#define	NO	ORDINARY
#define	TB	TAB
#define	VT	VTAB

u_char const char_type[] = {
	E|CC, O|CC, O|CC, E|CC, O|CC, E|CC, E|CC, O|CC,	/* nul - bel */
	O|BS, E|TB, E|NL, O|CC, E|VT, O|CR, O|CC, E|CC, /* bs - si */
	O|CC, E|CC, E|CC, O|CC, E|CC, O|CC, O|CC, E|CC, /* dle - etb */
	E|CC, O|CC, O|CC, E|CC, O|CC, E|CC, E|CC, O|CC, /* can - us */
	O|NO, E|NO, E|NO, O|NO, E|NO, O|NO, O|NO, E|NO, /* sp - ' */
	E|NO, O|NO, O|NO, E|NO, O|NO, E|NO, E|NO, O|NO, /* ( - / */
	E|NA, O|NA, O|NA, E|NA, O|NA, E|NA, E|NA, O|NA, /* 0 - 7 */
	O|NA, E|NA, E|NO, O|NO, E|NO, O|NO, O|NO, E|NO, /* 8 - ? */
	O|NO, E|NA, E|NA, O|NA, E|NA, O|NA, O|NA, E|NA, /* @@ - G */
	E|NA, O|NA, O|NA, E|NA, O|NA, E|NA, E|NA, O|NA, /* H - O */
	E|NA, O|NA, O|NA, E|NA, O|NA, E|NA, E|NA, O|NA, /* P - W */
	O|NA, E|NA, E|NA, O|NO, E|NO, O|NO, O|NO, O|NA, /* X - _ */
	E|NO, O|NA, O|NA, E|NA, O|NA, E|NA, E|NA, O|NA, /* ` - g */
	O|NA, E|NA, E|NA, O|NA, E|NA, O|NA, O|NA, E|NA, /* h - o */
	O|NA, E|NA, E|NA, O|NA, E|NA, O|NA, O|NA, E|NA, /* p - w */
	E|NA, O|NA, O|NA, E|NO, O|NO, E|NO, E|NO, O|CC, /* x - del */
	/*
	 * Meta chars; should be settable per character set;
	 * for now, treat them all as normal characters.
	 */
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
	NA,   NA,   NA,   NA,   NA,   NA,   NA,   NA,
};
#undef	BS
#undef	CC
#undef	CR
#undef	NA
#undef	NL
#undef	NO
#undef	TB
#undef	VT

#define	islower(c)	((c) >= 'a' && (c) <= 'z')
#define	isupper(c)	((c) >= 'A' && (c) <= 'Z')

#define	tolower(c)	((c) - 'A' + 'a')
#define	toupper(c)	((c) - 'a' + 'A')

struct ttylist_head ttylist;	/* TAILQ_HEAD */
int tty_count;

int64_t tk_cancc, tk_nin, tk_nout, tk_rawcc;

/*
 * Initial open of tty, or (re)entry to standard tty line discipline.
 */
int
ttyopen(dev_t device, struct tty *tp, struct proc *p)
{
	int s;

	s = spltty();
	tp->t_dev = device;
	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		SET(tp->t_state, TS_ISOPEN);
		memset(&tp->t_winsize, 0, sizeof(tp->t_winsize));
		tp->t_column = 0;
	}
	CLR(tp->t_state, TS_WOPEN);
	splx(s);
	return (0);
}

/*
 * Handle close() on a tty line: flush and set to initial state,
 * bumping generation number so that pending read/write calls
 * can detect recycling of the tty.
 */
int
ttyclose(struct tty *tp)
{
	if (constty == tp)
		constty = NULL;

	ttyflush(tp, FREAD | FWRITE);

	tp->t_gen++;
	tp->t_pgrp = NULL;
	if (tp->t_session)
		SESSRELE(tp->t_session);
	tp->t_session = NULL;
	tp->t_state = 0;
	return (0);
}

#define	FLUSHQ(q) {							\
	if ((q)->c_cc)							\
		ndflush(q, (q)->c_cc);					\
}

/* Is 'c' a line delimiter ("break" character)? */
#define	TTBREAKC(c, lflag)						\
	((c) == '\n' || (((c) == cc[VEOF] || (c) == cc[VEOL] ||		\
	((c) == cc[VEOL2] && (lflag & IEXTEN))) && (c) != _POSIX_VDISABLE))


/*
 * Process input of a single character received on a tty.
 */
int
ttyinput(int c, struct tty *tp)
{
	int iflag, lflag;
	u_char *cc;
	int i, error;
	int s;

	add_tty_randomness(tp->t_dev << 8 | c);
	/*
	 * If receiver is not enabled, drop it.
	 */
	if (!ISSET(tp->t_cflag, CREAD))
		return (0);

	/*
	 * If input is pending take it first.
	 */
	lflag = tp->t_lflag;
	s = spltty();
	if (ISSET(lflag, PENDIN))
		ttypend(tp);
	splx(s);
	/*
	 * Gather stats.
	 */
	if (ISSET(lflag, ICANON)) {
		++tk_cancc;
		++tp->t_cancc;
	} else {
		++tk_rawcc;
		++tp->t_rawcc;
	}
	++tk_nin;

	/* Handle exceptional conditions (break, parity, framing). */
	cc = tp->t_cc;
	iflag = tp->t_iflag;
	if ((error = (ISSET(c, TTY_ERRORMASK))) != 0) {
		CLR(c, TTY_ERRORMASK);
		if (ISSET(error, TTY_FE) && !c) {	/* Break. */
			if (ISSET(iflag, IGNBRK))
				return (0);
			ttyflush(tp, FREAD | FWRITE);
			if (ISSET(iflag, BRKINT)) {
			    pgsignal(tp->t_pgrp, SIGINT, 1);
			    goto endcase;
			}
			else if (ISSET(iflag, PARMRK))
				goto parmrk;
		} else if ((ISSET(error, TTY_PE) && ISSET(iflag, INPCK)) ||
		    ISSET(error, TTY_FE)) {
			if (ISSET(iflag, IGNPAR))
				goto endcase;
			else if (ISSET(iflag, PARMRK)) {
parmrk:				(void)putc(0377 | TTY_QUOTE, &tp->t_rawq);
				if (ISSET(iflag, ISTRIP) || c != 0377)
					(void)putc(0 | TTY_QUOTE, &tp->t_rawq);
				(void)putc(c | TTY_QUOTE, &tp->t_rawq);
				goto endcase;
			} else
				c = 0;
		}
	}
	if (c == 0377 && !ISSET(iflag, ISTRIP) && ISSET(iflag, PARMRK))
		goto parmrk;

	/*
	 * In tandem mode, check high water mark.
	 */
	if (ISSET(iflag, IXOFF) || ISSET(tp->t_cflag, CHWFLOW))
		ttyblock(tp);
	if (!ISSET(tp->t_state, TS_TYPEN) && ISSET(iflag, ISTRIP))
		CLR(c, 0x80);
	if (!ISSET(lflag, EXTPROC)) {
		/*
		 * Check for literal nexting very first
		 */
		if (ISSET(tp->t_state, TS_LNCH)) {
			SET(c, TTY_QUOTE);
			CLR(tp->t_state, TS_LNCH);
		}
		/*
		 * Scan for special characters.  This code
		 * is really just a big case statement with
		 * non-constant cases.  The bottom of the
		 * case statement is labeled ``endcase'', so goto
		 * it after a case match, or similar.
		 */

		/*
		 * Control chars which aren't controlled
		 * by ICANON, ISIG, or IXON.
		 */
		if (ISSET(lflag, IEXTEN)) {
			if (CCEQ(cc[VLNEXT], c)) {
				if (ISSET(lflag, ECHO)) {
					if (ISSET(lflag, ECHOE)) {
						(void)ttyoutput('^', tp);
						(void)ttyoutput('\b', tp);
					} else
						ttyecho(c, tp);
				}
				SET(tp->t_state, TS_LNCH);
				goto endcase;
			}
			if (CCEQ(cc[VDISCARD], c)) {
				if (ISSET(lflag, FLUSHO))
					CLR(tp->t_lflag, FLUSHO);
				else {
					ttyflush(tp, FWRITE);
					ttyecho(c, tp);
					if (tp->t_rawq.c_cc + tp->t_canq.c_cc)
						ttyretype(tp);
					SET(tp->t_lflag, FLUSHO);
				}
				goto startoutput;
			}
		}
		/*
		 * Signals.
		 */
		if (ISSET(lflag, ISIG)) {
			if (CCEQ(cc[VINTR], c) || CCEQ(cc[VQUIT], c)) {
				if (!ISSET(lflag, NOFLSH))
					ttyflush(tp, FREAD | FWRITE);
				ttyecho(c, tp);
				pgsignal(tp->t_pgrp,
				    CCEQ(cc[VINTR], c) ? SIGINT : SIGQUIT, 1);
				goto endcase;
			}
			if (CCEQ(cc[VSUSP], c)) {
				if (!ISSET(lflag, NOFLSH))
					ttyflush(tp, FREAD);
				ttyecho(c, tp);
				pgsignal(tp->t_pgrp, SIGTSTP, 1);
				goto endcase;
			}
		}
		/*
		 * Handle start/stop characters.
		 */
		if (ISSET(iflag, IXON)) {
			if (CCEQ(cc[VSTOP], c)) {
				if (!ISSET(tp->t_state, TS_TTSTOP)) {
					SET(tp->t_state, TS_TTSTOP);
					(*cdevsw[major(tp->t_dev)].d_stop)(tp,
					   0);
					return (0);
				}
				if (!CCEQ(cc[VSTART], c))
					return (0);
				/*
				 * if VSTART == VSTOP then toggle
				 */
				goto endcase;
			}
			if (CCEQ(cc[VSTART], c))
				goto restartoutput;
		}
		/*
		 * IGNCR, ICRNL, & INLCR
		 */
		if (c == '\r') {
			if (ISSET(iflag, IGNCR))
				goto endcase;
			else if (ISSET(iflag, ICRNL))
				c = '\n';
		} else if (c == '\n' && ISSET(iflag, INLCR))
			c = '\r';
	}
	if (!ISSET(tp->t_lflag, EXTPROC) && ISSET(lflag, ICANON)) {
		/*
		 * From here on down canonical mode character
		 * processing takes place.
		 */
		/*
		 * upper case or specials with IUCLC and XCASE
		 */
		if (ISSET(lflag, XCASE) && ISSET(iflag, IUCLC)) {
			if (ISSET(tp->t_state, TS_BKSL)) {
				CLR(tp->t_state, TS_BKSL);
				switch (c) {
				case '\'':
					c = '`';
					break;
				case '!':
					c = '|';
					break;
				case '^':
					c = '~';
					break;
				case '(':
					c = '{';
					break;
				case ')':
					c = '}';
					break;
				}
			}
			else if (c == '\\') {
				SET(tp->t_state, TS_BKSL);
				goto endcase;
			}
			else if (isupper(c))
				c = tolower(c);
		}
		else if (ISSET(iflag, IUCLC) && isupper(c))
			c = tolower(c);
		/*
		 * erase (^H / ^?)
		 */
		if (CCEQ(cc[VERASE], c)) {
			if (tp->t_rawq.c_cc)
				ttyrub(unputc(&tp->t_rawq), tp);
			goto endcase;
		}
		/*
		 * kill (^U)
		 */
		if (CCEQ(cc[VKILL], c)) {
			if (ISSET(lflag, ECHOKE) &&
			    tp->t_rawq.c_cc == tp->t_rocount &&
			    !ISSET(lflag, ECHOPRT))
				while (tp->t_rawq.c_cc)
					ttyrub(unputc(&tp->t_rawq), tp);
			else {
				ttyecho(c, tp);
				if (ISSET(lflag, ECHOK) ||
				    ISSET(lflag, ECHOKE))
					ttyecho('\n', tp);
				FLUSHQ(&tp->t_rawq);
				tp->t_rocount = 0;
			}
			CLR(tp->t_state, TS_LOCAL);
			goto endcase;
		}
		/*
		 * word erase (^W)
		 */
		if (CCEQ(cc[VWERASE], c) && ISSET(lflag, IEXTEN)) {
			int alt = ISSET(lflag, ALTWERASE);
			int ctype;

			/*
			 * erase whitespace
			 */
			while ((c = unputc(&tp->t_rawq)) == ' ' || c == '\t')
				ttyrub(c, tp);
			if (c == -1)
				goto endcase;
			/*
			 * erase last char of word and remember the
			 * next chars type (for ALTWERASE)
			 */
			ttyrub(c, tp);
			c = unputc(&tp->t_rawq);
			if (c == -1)
				goto endcase;
			if (c == ' ' || c == '\t') {
				(void)putc(c, &tp->t_rawq);
				goto endcase;
			}
			ctype = ISALPHA(c);
			/*
			 * erase rest of word
			 */
			do {
				ttyrub(c, tp);
				c = unputc(&tp->t_rawq);
				if (c == -1)
					goto endcase;
			} while (c != ' ' && c != '\t' &&
			    (alt == 0 || ISALPHA(c) == ctype));
			(void)putc(c, &tp->t_rawq);
			goto endcase;
		}
		/*
		 * reprint line (^R)
		 */
		if (CCEQ(cc[VREPRINT], c) && ISSET(lflag, IEXTEN)) {
			ttyretype(tp);
			goto endcase;
		}
		/*
		 * ^T - kernel info and generate SIGINFO
		 */
		if (CCEQ(cc[VSTATUS], c) && ISSET(lflag, IEXTEN)) {
			if (ISSET(lflag, ISIG))
				pgsignal(tp->t_pgrp, SIGINFO, 1);
			if (!ISSET(lflag, NOKERNINFO))
				ttyinfo(tp);
			goto endcase;
		}
	}
	/*
	 * Check for input buffer overflow
	 */
	if (tp->t_rawq.c_cc + tp->t_canq.c_cc >= TTYHOG(tp)) {
		if (ISSET(iflag, IMAXBEL)) {
			if (tp->t_outq.c_cc < tp->t_hiwat)
				(void)ttyoutput(CTRL('g'), tp);
		} else
			ttyflush(tp, FREAD | FWRITE);
		goto endcase;
	}
	/*
	 * Put data char in q for user and
	 * wakeup on seeing a line delimiter.
	 */
	if (putc(c, &tp->t_rawq) >= 0) {
		if (!ISSET(lflag, ICANON)) {
			ttwakeup(tp);
			ttyecho(c, tp);
			goto endcase;
		}
		if (TTBREAKC(c, lflag)) {
			tp->t_rocount = 0;
			catq(&tp->t_rawq, &tp->t_canq);
			ttwakeup(tp);
		} else if (tp->t_rocount++ == 0)
			tp->t_rocol = tp->t_column;
		if (ISSET(tp->t_state, TS_ERASE)) {
			/*
			 * end of prterase \.../
			 */
			CLR(tp->t_state, TS_ERASE);
			(void)ttyoutput('/', tp);
		}
		i = tp->t_column;
		ttyecho(c, tp);
		if (CCEQ(cc[VEOF], c) && ISSET(lflag, ECHO)) {
			/*
			 * Place the cursor over the '^' of the ^D.
			 */
			i = min(2, tp->t_column - i);
			while (i > 0) {
				(void)ttyoutput('\b', tp);
				i--;
			}
		}
	}
endcase:
	/*
	 * IXANY means allow any character to restart output.
	 */
	if (ISSET(tp->t_state, TS_TTSTOP) &&
	    !ISSET(iflag, IXANY) && cc[VSTART] != cc[VSTOP])
		return (0);
restartoutput:
	CLR(tp->t_lflag, FLUSHO);
	CLR(tp->t_state, TS_TTSTOP);
startoutput:
	return (ttstart(tp));
}

/*
 * Output a single character on a tty, doing output processing
 * as needed (expanding tabs, newline processing, etc.).
 * Returns < 0 if succeeds, otherwise returns char to resend.
 * Must be recursive.
 */
int
ttyoutput(int c, struct tty *tp)
{
	long oflag;
	int col, notout, s, c2;

	oflag = tp->t_oflag;
	if (!ISSET(oflag, OPOST)) {
		tk_nout++;
		tp->t_outcc++;
		if (!ISSET(tp->t_lflag, FLUSHO) && putc(c, &tp->t_outq))
			return (c);
		return (-1);
	}
	/*
	 * Do tab expansion if OXTABS is set.  Special case if we external
	 * processing, we don't do the tab expansion because we'll probably
	 * get it wrong.  If tab expansion needs to be done, let it happen
	 * externally.
	 */
	CLR(c, ~TTY_CHARMASK);
	if (c == '\t' &&
	    ISSET(oflag, OXTABS) && !ISSET(tp->t_lflag, EXTPROC)) {
		c = 8 - (tp->t_column & 7);
		if (ISSET(tp->t_lflag, FLUSHO)) {
			notout = 0;
		} else {
			s = spltty();		/* Don't interrupt tabs. */
			notout = b_to_q("        ", c, &tp->t_outq);
			c -= notout;
			tk_nout += c;
			tp->t_outcc += c;
			splx(s);
		}
		tp->t_column += c;
		return (notout ? '\t' : -1);
	}
	if (c == CEOT && ISSET(oflag, ONOEOT))
		return (-1);

	/*
	 * Newline translation: if ONLCR is set,
	 * translate newline into "\r\n".  If OCRNL
	 * is set, translate '\r' into '\n'.
	 */
	if (c == '\n' && ISSET(tp->t_oflag, ONLCR)) {
		tk_nout++;
		tp->t_outcc++;
		if (!ISSET(tp->t_lflag, FLUSHO) && putc('\r', &tp->t_outq))
			return (c);
		tp->t_column = 0;
	}
	else if (c == '\r' && ISSET(tp->t_oflag, OCRNL))
		c = '\n';

	if (ISSET(tp->t_oflag, OLCUC) && islower(c))
		c = toupper(c);
	else if (ISSET(tp->t_oflag, OLCUC) && ISSET(tp->t_lflag, XCASE)) {
		c2 = c;
		switch (c) {
		case '`':
			c2 = '\'';
			break;
		case '|':
			c2 = '!';
			break;
		case '~':
			c2 = '^';
			break;
		case '{':
			c2 = '(';
			break;
		case '}':
			c2 = ')';
			break;
		}
		if (c == '\\' || isupper(c) || c != c2) {
			tk_nout++;
			tp->t_outcc++;
			if (putc('\\', &tp->t_outq))
				return (c);
			c = c2;
		}
	}
	if (ISSET(tp->t_oflag, ONOCR) && c == '\r' && tp->t_column == 0)
		return (-1);

	tk_nout++;
	tp->t_outcc++;
	if (!ISSET(tp->t_lflag, FLUSHO) && putc(c, &tp->t_outq))
		return (c);

	col = tp->t_column;
	switch (CCLASS(c)) {
	case BACKSPACE:
		if (col > 0)
			--col;
		break;
	case CONTROL:
		break;
	case NEWLINE:
		if (ISSET(tp->t_oflag, ONLRET) || ISSET(tp->t_oflag, OCRNL))
			col = 0;
		break;
	case RETURN:
		col = 0;
		break;
	case ORDINARY:
		++col;
		break;
	case TAB:
		col = (col + 8) & ~7;
		break;
	}
	tp->t_column = col;
	return (-1);
}

/*
 * Ioctls for all tty devices.  Called after line-discipline specific ioctl
 * has been called to do discipline-specific functions and/or reject any
 * of these ioctl commands.
 */
int
ttioctl(struct tty *tp, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	extern int nlinesw;
	struct process *pr = p->p_p;
	int s, error;

	/* If the ioctl involves modification, hang if in the background. */
	switch (cmd) {
	case  TIOCFLUSH:
	case  TIOCDRAIN:
	case  TIOCSBRK:
	case  TIOCCBRK:
	case  TIOCSETA:
	case  TIOCSETD:
	case  TIOCSETAF:
	case  TIOCSETAW:
	case  TIOCSPGRP:
	case  TIOCSTAT:
	case  TIOCSTI:
	case  TIOCSWINSZ:
		while (isbackground(pr, tp) &&
		    (pr->ps_flags & PS_PPWAIT) == 0 &&
		    (pr->ps_sigacts->ps_sigignore & sigmask(SIGTTOU)) == 0 &&
		    (p->p_sigmask & sigmask(SIGTTOU)) == 0) {
			if (pr->ps_pgrp->pg_jobc == 0)
				return (EIO);
			pgsignal(pr->ps_pgrp, SIGTTOU, 1);
			error = ttysleep(tp, &lbolt, TTOPRI | PCATCH,
			    ttybg, 0);
			if (error)
				return (error);
		}
		break;
	}

	switch (cmd) {			/* Process the ioctl. */
	case FIOASYNC:			/* set/clear async i/o */
		s = spltty();
		if (*(int *)data)
			SET(tp->t_state, TS_ASYNC);
		else
			CLR(tp->t_state, TS_ASYNC);
		splx(s);
		break;
	case FIONBIO:			/* set/clear non-blocking i/o */
		break;			/* XXX: delete. */
	case FIONREAD:			/* get # bytes to read */
		s = spltty();
		*(int *)data = ttnread(tp);
		splx(s);
		break;
	case TIOCEXCL:			/* set exclusive use of tty */
		s = spltty();
		SET(tp->t_state, TS_XCLUDE);
		splx(s);
		break;
	case TIOCFLUSH: {		/* flush buffers */
		int flags = *(int *)data;

		if (flags == 0)
			flags = FREAD | FWRITE;
		else
			flags &= FREAD | FWRITE;
		ttyflush(tp, flags);
		break;
	}
	case TIOCCONS: {		/* become virtual console */
		if (*(int *)data) {
			struct nameidata nid;

			if (constty != NULL && constty != tp &&
			    ISSET(constty->t_state, TS_CARR_ON | TS_ISOPEN) ==
			    (TS_CARR_ON | TS_ISOPEN))
				return (EBUSY);

			/* ensure user can open the real console */
			NDINIT(&nid, LOOKUP, FOLLOW, UIO_SYSSPACE, "/dev/console", p);
			nid.ni_pledge = PLEDGE_RPATH | PLEDGE_WPATH;
			error = namei(&nid);
			if (error)
				return (error);
			vn_lock(nid.ni_vp, LK_EXCLUSIVE | LK_RETRY, p);
			error = VOP_ACCESS(nid.ni_vp, VREAD, p->p_ucred, p);
			VOP_UNLOCK(nid.ni_vp, p);
			vrele(nid.ni_vp);
			if (error)
				return (error);

			constty = tp;
		} else if (tp == constty)
			constty = NULL;
		break;
	}
	case TIOCDRAIN:			/* wait till output drained */
		if ((error = ttywait(tp)) != 0)
			return (error);
		break;
	case TIOCGETA: {		/* get termios struct */
		struct termios *t = (struct termios *)data;

		memcpy(t, &tp->t_termios, sizeof(struct termios));
		break;
	}
	case TIOCGETD:			/* get line discipline */
		*(int *)data = tp->t_line;
		break;
	case TIOCGWINSZ:		/* get window size */
		*(struct winsize *)data = tp->t_winsize;
		break;
	case TIOCGTSTAMP:
		s = spltty();
		*(struct timeval *)data = tp->t_tv;
		splx(s);
		break;
	case TIOCGPGRP:			/* get pgrp of tty */
		if (!isctty(pr, tp) && suser(p, 0))
			return (ENOTTY);
		*(int *)data = tp->t_pgrp ? tp->t_pgrp->pg_id : NO_PID;
		break;
	case TIOCGSID:			/* get sid of tty */
		if (!isctty(pr, tp))
			return (ENOTTY);
		*(int *)data = tp->t_session->s_leader->ps_pid;
		break;
#ifdef TIOCHPCL
	case TIOCHPCL:			/* hang up on last close */
		s = spltty();
		SET(tp->t_cflag, HUPCL);
		splx(s);
		break;
#endif
	case TIOCNXCL:			/* reset exclusive use of tty */
		s = spltty();
		CLR(tp->t_state, TS_XCLUDE);
		splx(s);
		break;
	case TIOCOUTQ:			/* output queue size */
		*(int *)data = tp->t_outq.c_cc;
		break;
	case TIOCSETA:			/* set termios struct */
	case TIOCSETAW:			/* drain output, set */
	case TIOCSETAF: {		/* drn out, fls in, set */
		struct termios *t = (struct termios *)data;

		s = spltty();
		if (cmd == TIOCSETAW || cmd == TIOCSETAF) {
			if ((error = ttywait(tp)) != 0) {
				splx(s);
				return (error);
			}
			if (cmd == TIOCSETAF)
				ttyflush(tp, FREAD);
		}
		if (!ISSET(t->c_cflag, CIGNORE)) {
			/*
			 * Some minor validation is necessary.
			 */
			if (t->c_ispeed < 0 || t->c_ospeed < 0) {
				splx(s);
				return (EINVAL);
			}
			/*
			 * Set device hardware.
			 */
			if (tp->t_param && (error = (*tp->t_param)(tp, t))) {
				splx(s);
				return (error);
			} else {
				if (!ISSET(tp->t_state, TS_CARR_ON) &&
				    ISSET(tp->t_cflag, CLOCAL) &&
				    !ISSET(t->c_cflag, CLOCAL)) {
					CLR(tp->t_state, TS_ISOPEN);
					SET(tp->t_state, TS_WOPEN);
					ttwakeup(tp);
				}
				tp->t_cflag = t->c_cflag;
				tp->t_ispeed = t->c_ispeed;
				tp->t_ospeed = t->c_ospeed;
				if (t->c_ospeed == 0 && tp->t_session &&
				    tp->t_session->s_leader)
					prsignal(tp->t_session->s_leader,
					    SIGHUP);
			}
			ttsetwater(tp);
		}
		if (cmd != TIOCSETAF) {
			if (ISSET(t->c_lflag, ICANON) !=
			    ISSET(tp->t_lflag, ICANON)) {
				if (ISSET(t->c_lflag, ICANON)) {
					SET(tp->t_lflag, PENDIN);
					ttwakeup(tp);
				} else {
					struct clist tq;

					catq(&tp->t_rawq, &tp->t_canq);
					tq = tp->t_rawq;
					tp->t_rawq = tp->t_canq;
					tp->t_canq = tq;
					CLR(tp->t_lflag, PENDIN);
				}
			}
		}
		tp->t_iflag = t->c_iflag;
		tp->t_oflag = t->c_oflag;
		/*
		 * Make the EXTPROC bit read only.
		 */
		if (ISSET(tp->t_lflag, EXTPROC))
			SET(t->c_lflag, EXTPROC);
		else
			CLR(t->c_lflag, EXTPROC);
		tp->t_lflag = t->c_lflag | ISSET(tp->t_lflag, PENDIN);
		memcpy(tp->t_cc, t->c_cc, sizeof(t->c_cc));
		splx(s);
		break;
	}
	case TIOCSETD: {		/* set line discipline */
		int t = *(int *)data;
		dev_t device = tp->t_dev;

		if ((u_int)t >= nlinesw)
			return (ENXIO);
		if (t != tp->t_line) {
			s = spltty();
			(*linesw[tp->t_line].l_close)(tp, flag, p);
			error = (*linesw[t].l_open)(device, tp, p);
			if (error) {
				(*linesw[tp->t_line].l_open)(device, tp, p);
				splx(s);
				return (error);
			}
			tp->t_line = t;
			splx(s);
		}
		break;
	}
	case TIOCSTART:			/* start output, like ^Q */
		s = spltty();
		if (ISSET(tp->t_state, TS_TTSTOP) ||
		    ISSET(tp->t_lflag, FLUSHO)) {
			CLR(tp->t_lflag, FLUSHO);
			CLR(tp->t_state, TS_TTSTOP);
			ttstart(tp);
		}
		splx(s);
		break;
	case TIOCSTI:			/* simulate terminal input */
		if (p->p_ucred->cr_uid && (flag & FREAD) == 0)
			return (EPERM);
		if (p->p_ucred->cr_uid && !isctty(pr, tp))
			return (EACCES);
		(*linesw[tp->t_line].l_rint)(*(u_char *)data, tp);
		break;
	case TIOCSTOP:			/* stop output, like ^S */
		s = spltty();
		if (!ISSET(tp->t_state, TS_TTSTOP)) {
			SET(tp->t_state, TS_TTSTOP);
			(*cdevsw[major(tp->t_dev)].d_stop)(tp, 0);
		}
		splx(s);
		break;
	case TIOCSCTTY:			/* become controlling tty */
		/* Session ctty vnode pointer set in vnode layer. */
		if (!SESS_LEADER(pr) ||
		    ((pr->ps_session->s_ttyvp || tp->t_session) &&
		     (tp->t_session != pr->ps_session)))
			return (EPERM);
		if (tp->t_session)
			SESSRELE(tp->t_session);
		SESSHOLD(pr->ps_session);
		tp->t_session = pr->ps_session;
		tp->t_pgrp = pr->ps_pgrp;
		pr->ps_session->s_ttyp = tp;
		atomic_setbits_int(&pr->ps_flags, PS_CONTROLT);
		break;
	case TIOCSPGRP: {		/* set pgrp of tty */
		struct pgrp *pgrp = pgfind(*(int *)data);

		if (!isctty(pr, tp))
			return (ENOTTY);
		else if (pgrp == NULL)
			return (EINVAL);
		else if (pgrp->pg_session != pr->ps_session)
			return (EPERM);
		tp->t_pgrp = pgrp;
		break;
	}
	case TIOCSTAT:			/* get load avg stats */
		ttyinfo(tp);
		break;
	case TIOCSWINSZ:		/* set window size */
		if (bcmp((caddr_t)&tp->t_winsize, data,
		    sizeof (struct winsize))) {
			tp->t_winsize = *(struct winsize *)data;
			pgsignal(tp->t_pgrp, SIGWINCH, 1);
		}
		break;
	case TIOCSTSTAMP: {
		struct tstamps *ts = (struct tstamps *)data;

		s = spltty();
		CLR(tp->t_flags, TS_TSTAMPDCDSET);
		CLR(tp->t_flags, TS_TSTAMPCTSSET);
		CLR(tp->t_flags, TS_TSTAMPDCDCLR);
		CLR(tp->t_flags, TS_TSTAMPCTSCLR);
		if (ISSET(ts->ts_set, TIOCM_CAR))
			SET(tp->t_flags, TS_TSTAMPDCDSET);
		if (ISSET(ts->ts_set, TIOCM_CTS))
			SET(tp->t_flags, TS_TSTAMPCTSSET);
		if (ISSET(ts->ts_clr, TIOCM_CAR))
			SET(tp->t_flags, TS_TSTAMPDCDCLR);
		if (ISSET(ts->ts_clr, TIOCM_CTS))
			SET(tp->t_flags, TS_TSTAMPCTSCLR);
		splx(s);
		break;
	}
	default:
		return (-1);
	}
	return (0);
}

int
ttpoll(dev_t device, int events, struct proc *p)
{
	struct tty *tp;
	int revents, s;

	tp = (*cdevsw[major(device)].d_tty)(device);

	revents = 0;
	s = spltty();
	if (events & (POLLIN | POLLRDNORM)) {
		if (ttnread(tp) > 0 || (!ISSET(tp->t_cflag, CLOCAL) &&
		    !ISSET(tp->t_state, TS_CARR_ON)))
			revents |= events & (POLLIN | POLLRDNORM);
	}
	/* NOTE: POLLHUP and POLLOUT/POLLWRNORM are mutually exclusive */
	if (!ISSET(tp->t_cflag, CLOCAL) && !ISSET(tp->t_state, TS_CARR_ON)) {
		revents |= POLLHUP;
	} else if (events & (POLLOUT | POLLWRNORM)) {
		if (tp->t_outq.c_cc <= tp->t_lowat)
			revents |= events & (POLLOUT | POLLWRNORM);
	}
	if (revents == 0) {
		if (events & (POLLIN | POLLRDNORM))
			selrecord(p, &tp->t_rsel);
		if (events & (POLLOUT | POLLWRNORM))
			selrecord(p, &tp->t_wsel);
	}
	splx(s);
	return (revents);
}

struct filterops ttyread_filtops =
	{ 1, NULL, filt_ttyrdetach, filt_ttyread };
struct filterops ttywrite_filtops =
	{ 1, NULL, filt_ttywdetach, filt_ttywrite };

int
ttkqfilter(dev_t dev, struct knote *kn)
{
	struct tty *tp = (*cdevsw[major(dev)].d_tty)(dev);
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &tp->t_rsel.si_note;
		kn->kn_fop = &ttyread_filtops;
		break;
	case EVFILT_WRITE:
		klist = &tp->t_wsel.si_note;
		kn->kn_fop = &ttywrite_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)((u_long)dev);

	s = spltty();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

void
ttkqflush(struct klist *klist)
{
	struct knote *kn, *kn1;

	SLIST_FOREACH_SAFE(kn, klist, kn_selnext, kn1) {
		SLIST_REMOVE(klist, kn, knote, kn_selnext);
		kn->kn_hook = (caddr_t)((u_long)NODEV);
		kn->kn_flags |= EV_EOF;
		knote_activate(kn);
	}
}

void
filt_ttyrdetach(struct knote *kn)
{
	dev_t dev = (dev_t)((u_long)kn->kn_hook);
	struct tty *tp;
	int s;

	if (dev == NODEV)
		return;
	tp = (*cdevsw[major(dev)].d_tty)(dev);

	s = spltty();
	SLIST_REMOVE(&tp->t_rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_ttyread(struct knote *kn, long hint)
{
	dev_t dev = (dev_t)((u_long)kn->kn_hook);
	struct tty *tp;
	int s;

	if (dev == NODEV) {
		kn->kn_flags |= EV_EOF;
		return (1);
	}
	tp = (*cdevsw[major(dev)].d_tty)(dev);

	s = spltty();
	kn->kn_data = ttnread(tp);
	splx(s);
	if (!ISSET(tp->t_cflag, CLOCAL) && !ISSET(tp->t_state, TS_CARR_ON)) {
		kn->kn_flags |= EV_EOF;
		return (1);
	}
	return (kn->kn_data > 0);
}

void
filt_ttywdetach(struct knote *kn)
{
	dev_t dev = (dev_t)((u_long)kn->kn_hook);
	struct tty *tp;
	int s;

	if (dev == NODEV)
		return;
	tp = (*cdevsw[major(dev)].d_tty)(dev);

	s = spltty();
	SLIST_REMOVE(&tp->t_wsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_ttywrite(struct knote *kn, long hint)
{
	dev_t dev = (dev_t)((u_long)kn->kn_hook);
	struct tty *tp;
	int canwrite, s;

	if (dev == NODEV) {
		kn->kn_flags |= EV_EOF;
		return (1);
	}
	tp = (*cdevsw[major(dev)].d_tty)(dev);

	s = spltty();
	kn->kn_data = tp->t_outq.c_cn - tp->t_outq.c_cc;
	canwrite = (tp->t_outq.c_cc <= tp->t_lowat);
	splx(s);
	return (canwrite);
}

static int
ttnread(struct tty *tp)
{
	int nread;

	splassert(IPL_TTY);

	if (ISSET(tp->t_lflag, PENDIN))
		ttypend(tp);
	nread = tp->t_canq.c_cc;
	if (!ISSET(tp->t_lflag, ICANON)) {
		nread += tp->t_rawq.c_cc;
		if (nread < tp->t_cc[VMIN] && !tp->t_cc[VTIME])
			nread = 0;
	}
	return (nread);
}

/*
 * Wait for output to drain.
 */
int
ttywait(struct tty *tp)
{
	int error, s;

	error = 0;
	s = spltty();
	while ((tp->t_outq.c_cc || ISSET(tp->t_state, TS_BUSY)) &&
	    (ISSET(tp->t_state, TS_CARR_ON) || ISSET(tp->t_cflag, CLOCAL)) &&
	    tp->t_oproc) {
		(*tp->t_oproc)(tp);
		if ((tp->t_outq.c_cc || ISSET(tp->t_state, TS_BUSY)) &&
		    (ISSET(tp->t_state, TS_CARR_ON) || ISSET(tp->t_cflag, CLOCAL))
		    && tp->t_oproc) {
			SET(tp->t_state, TS_ASLEEP);
			error = ttysleep(tp, &tp->t_outq, TTOPRI | PCATCH, ttyout, 0);
			if (error)
				break;
		} else
			break;
	}
	splx(s);
	return (error);
}

/*
 * Flush if successfully wait.
 */
int
ttywflush(struct tty *tp)
{
	int error;

	if ((error = ttywait(tp)) == 0)
		ttyflush(tp, FREAD);
	return (error);
}

/*
 * Flush tty read and/or write queues, notifying anyone waiting.
 */
void
ttyflush(struct tty *tp, int rw)
{
	int s;

	s = spltty();
	if (rw & FREAD) {
		FLUSHQ(&tp->t_canq);
		FLUSHQ(&tp->t_rawq);
		tp->t_rocount = 0;
		tp->t_rocol = 0;
		CLR(tp->t_state, TS_LOCAL);
		ttyunblock(tp);
		ttwakeup(tp);
	}
	if (rw & FWRITE) {
		CLR(tp->t_state, TS_TTSTOP);
		(*cdevsw[major(tp->t_dev)].d_stop)(tp, rw);
		FLUSHQ(&tp->t_outq);
		wakeup((caddr_t)&tp->t_outq);
		selwakeup(&tp->t_wsel);
	}
	splx(s);
}

/*
 * Copy in the default termios characters.
 */
void
ttychars(struct tty *tp)
{

	memcpy(tp->t_cc, ttydefchars, sizeof(ttydefchars));
}

/*
 * Send stop character on input overflow.
 */
static void
ttyblock(struct tty *tp)
{
	int total;

	total = tp->t_rawq.c_cc + tp->t_canq.c_cc;
	if (tp->t_rawq.c_cc > TTYHOG(tp)) {
		ttyflush(tp, FREAD | FWRITE);
		CLR(tp->t_state, TS_TBLOCK);
	}
	/*
	 * Block further input iff: current input > threshold
	 * AND input is available to user program.
	 */
	if ((total >= TTYHOG(tp) / 2 &&
	     !ISSET(tp->t_state, TS_TBLOCK) &&
	     !ISSET(tp->t_lflag, ICANON)) || tp->t_canq.c_cc > 0) {
		if (ISSET(tp->t_iflag, IXOFF) &&
		    tp->t_cc[VSTOP] != _POSIX_VDISABLE &&
		    putc(tp->t_cc[VSTOP], &tp->t_outq) == 0) {
			SET(tp->t_state, TS_TBLOCK);
			ttstart(tp);
		}
		/* Try to block remote output via hardware flow control. */
		if (ISSET(tp->t_cflag, CHWFLOW) && tp->t_hwiflow &&
		    (*tp->t_hwiflow)(tp, 1) != 0)
			SET(tp->t_state, TS_TBLOCK);
	}
}

void
ttrstrt(void *tp_arg)
{
	struct tty *tp;
	int s;

#ifdef DIAGNOSTIC
	if (tp_arg == NULL)
		panic("ttrstrt");
#endif
	tp = tp_arg;
	s = spltty();

	CLR(tp->t_state, TS_TIMEOUT);
	ttstart(tp);

	splx(s);
}

int
ttstart(struct tty *tp)
{

	if (tp->t_oproc != NULL)	/* XXX: Kludge for pty. */
		(*tp->t_oproc)(tp);
	return (0);
}

/*
 * "close" a line discipline
 */
int
ttylclose(struct tty *tp, int flag, struct proc *p)
{

	if (flag & FNONBLOCK)
		ttyflush(tp, FREAD | FWRITE);
	else
		ttywflush(tp);
	return (0);
}

/*
 * Handle modem control transition on a tty.
 * Flag indicates new state of carrier.
 * Returns 0 if the line should be turned off, otherwise 1.
 */
int
ttymodem(struct tty *tp, int flag)
{

	if (!ISSET(tp->t_state, TS_WOPEN) && ISSET(tp->t_cflag, MDMBUF)) {
		/*
		 * MDMBUF: do flow control according to carrier flag
		 */
		if (flag) {
			CLR(tp->t_state, TS_TTSTOP);
			ttstart(tp);
		} else if (!ISSET(tp->t_state, TS_TTSTOP)) {
			SET(tp->t_state, TS_TTSTOP);
			(*cdevsw[major(tp->t_dev)].d_stop)(tp, 0);
		}
	} else if (flag == 0) {
		/*
		 * Lost carrier.
		 */
		CLR(tp->t_state, TS_CARR_ON);
		if (ISSET(tp->t_state, TS_ISOPEN) &&
		    !ISSET(tp->t_cflag, CLOCAL)) {
			if (tp->t_session && tp->t_session->s_leader)
				prsignal(tp->t_session->s_leader, SIGHUP);
			ttyflush(tp, FREAD | FWRITE);
			return (0);
		}
	} else {
		/*
		 * Carrier now on.
		 */
		SET(tp->t_state, TS_CARR_ON);
		ttwakeup(tp);
	}
	return (1);
}

/*
 * Default modem control routine (for other line disciplines).
 * Return argument flag, to turn off device on carrier drop.
 */
int
nullmodem(struct tty *tp, int flag)
{

	if (flag)
		SET(tp->t_state, TS_CARR_ON);
	else {
		CLR(tp->t_state, TS_CARR_ON);
		if (ISSET(tp->t_state, TS_ISOPEN) &&
		    !ISSET(tp->t_cflag, CLOCAL)) {
			if (tp->t_session && tp->t_session->s_leader)
				prsignal(tp->t_session->s_leader, SIGHUP);
			ttyflush(tp, FREAD | FWRITE);
			return (0);
		}
	}
	return (1);
}

/*
 * Reinput pending characters after state switch
 * call at spltty().
 */
void
ttypend(struct tty *tp)
{
	struct clist tq;
	int c;

	splassert(IPL_TTY);

	CLR(tp->t_lflag, PENDIN);
	SET(tp->t_state, TS_TYPEN);
	tq = tp->t_rawq;
	tp->t_rawq.c_cc = 0;
	tp->t_rawq.c_cf = tp->t_rawq.c_cl = 0;
	while ((c = getc(&tq)) >= 0)
		ttyinput(c, tp);
	CLR(tp->t_state, TS_TYPEN);
}

void ttvtimeout(void *);

void
ttvtimeout(void *arg)
{
	struct tty *tp = (struct tty *)arg;

	wakeup(&tp->t_rawq);
}

/*
 * Process a read call on a tty device.
 */
int
ttread(struct tty *tp, struct uio *uio, int flag)
{
	struct timeout *stime = NULL;
	struct proc *p = curproc;
	struct process *pr = p->p_p;
	int s, first, error = 0;
	u_char *cc = tp->t_cc;
	struct clist *qp;
	int last_cc = 0;
	long lflag;
	int c;

loop:	lflag = tp->t_lflag;
	s = spltty();
	/*
	 * take pending input first
	 */
	if (ISSET(lflag, PENDIN))
		ttypend(tp);
	splx(s);

	/*
	 * Hang process if it's in the background.
	 */
	if (isbackground(pr, tp)) {
		if ((pr->ps_sigacts->ps_sigignore & sigmask(SIGTTIN)) ||
		   (p->p_sigmask & sigmask(SIGTTIN)) ||
		    pr->ps_flags & PS_PPWAIT || pr->ps_pgrp->pg_jobc == 0) {
			error = EIO;
			goto out;
		}
		pgsignal(pr->ps_pgrp, SIGTTIN, 1);
		error = ttysleep(tp, &lbolt, TTIPRI | PCATCH, ttybg, 0);
		if (error)
			goto out;
		goto loop;
	}

	s = spltty();
	if (!ISSET(lflag, ICANON)) {
		int m = cc[VMIN];
		long t;

		/*
		 * Note - since cc[VTIME] is a u_char, this won't overflow
		 * until we have 32-bit longs and a hz > 8388608.
		 * Hopefully this code and 32-bit longs are obsolete by then.
		 */
		t = cc[VTIME] * hz / 10;

		qp = &tp->t_rawq;
		/*
		 * Check each of the four combinations.
		 * (m > 0 && t == 0) is the normal read case.
		 * It should be fairly efficient, so we check that and its
		 * companion case (m == 0 && t == 0) first.
		 */
		if (t == 0) {
			if (qp->c_cc < m)
				goto sleep;
			goto read;
		}
		if (m > 0) {
			if (qp->c_cc <= 0)
				goto sleep;
			if (qp->c_cc >= m)
				goto read;
			if (stime == NULL) {
alloc_timer:
				stime = malloc(sizeof(*stime), M_TEMP, M_WAITOK);
				timeout_set(stime, ttvtimeout, tp);
				timeout_add(stime, t);
			} else if (qp->c_cc > last_cc) {
				/* got a character, restart timer */
				timeout_add(stime, t);
			}
		} else {	/* m == 0 */
			if (qp->c_cc > 0)
				goto read;
			if (stime == NULL) {
				goto alloc_timer;
			}
		}
		last_cc = qp->c_cc;
		if (stime && !timeout_triggered(stime)) {
			goto sleep;
		}
	} else if ((qp = &tp->t_canq)->c_cc <= 0) {
		int carrier;

sleep:
		/*
		 * If there is no input, sleep on rawq
		 * awaiting hardware receipt and notification.
		 * If we have data, we don't need to check for carrier.
		 */
		carrier = ISSET(tp->t_state, TS_CARR_ON) ||
		    ISSET(tp->t_cflag, CLOCAL);
		if (!carrier && ISSET(tp->t_state, TS_ISOPEN)) {
			splx(s);
			error = 0;
			goto out;
		}
		if (flag & IO_NDELAY) {
			splx(s);
			error = EWOULDBLOCK;
			goto out;
		}
		error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
		    carrier ? ttyin : ttopen, 0);
		splx(s);
		if (stime && timeout_triggered(stime))
			error = EWOULDBLOCK;
		if (cc[VMIN] == 0 && error == EWOULDBLOCK) {
			error = 0;
			goto out;
		}
		if (error && error != EWOULDBLOCK)
			goto out;
		error = 0;
		goto loop;
	}
read:
	splx(s);

	/*
	 * Input present, check for input mapping and processing.
	 */
	first = 1;
	while ((c = getc(qp)) >= 0) {
		/*
		 * delayed suspend (^Y)
		 */
		if (CCEQ(cc[VDSUSP], c) &&
		    ISSET(lflag, IEXTEN | ISIG) == (IEXTEN | ISIG)) {
			pgsignal(tp->t_pgrp, SIGTSTP, 1);
			if (first) {
				error = ttysleep(tp, &lbolt, TTIPRI | PCATCH,
				    ttybg, 0);
				if (error)
					break;
				goto loop;
			}
			break;
		}
		/*
		 * Interpret EOF only in canonical mode.
		 */
		if (CCEQ(cc[VEOF], c) && ISSET(lflag, ICANON))
			break;
		/*
		 * Give user character.
		 */
 		error = ureadc(c, uio);
		if (error)
			break;
 		if (uio->uio_resid == 0)
			break;
		/*
		 * In canonical mode check for a "break character"
		 * marking the end of a "line of input".
		 */
		if (ISSET(lflag, ICANON) && TTBREAKC(c, lflag))
			break;
		first = 0;
	}
	/*
	 * Look to unblock output now that (presumably)
	 * the input queue has gone down.
	 */
	s = spltty();
	if (tp->t_rawq.c_cc < TTYHOG(tp)/5)
		ttyunblock(tp);
	splx(s);

out:
	if (stime) {
		timeout_del(stime);
		free(stime, M_TEMP, sizeof(*stime));
	}
	return (error);
}

/* Call at spltty */
void
ttyunblock(struct tty *tp)
{
	u_char *cc = tp->t_cc;

	splassert(IPL_TTY);

	if (ISSET(tp->t_state, TS_TBLOCK)) {
		if (ISSET(tp->t_iflag, IXOFF) &&
		    cc[VSTART] != _POSIX_VDISABLE &&
		    putc(cc[VSTART], &tp->t_outq) == 0) {
			CLR(tp->t_state, TS_TBLOCK);
			ttstart(tp);
		}
		/* Try to unblock remote output via hardware flow control. */
		if (ISSET(tp->t_cflag, CHWFLOW) && tp->t_hwiflow &&
		    (*tp->t_hwiflow)(tp, 0) != 0)
			CLR(tp->t_state, TS_TBLOCK);
	}
}

/*
 * Check the output queue on tp for space for a kernel message (from uprintf
 * or tprintf).  Allow some space over the normal hiwater mark so we don't
 * lose messages due to normal flow control, but don't let the tty run amok.
 * Sleeps here are not interruptible, but we return prematurely if new signals
 * arrive.
 */
int
ttycheckoutq(struct tty *tp, int wait)
{
	int hiwat, s, oldsig;

	hiwat = tp->t_hiwat;
	s = spltty();
	oldsig = wait ? curproc->p_siglist : 0;
	if (tp->t_outq.c_cc > hiwat + TTHIWATMINSPACE)
		while (tp->t_outq.c_cc > hiwat) {
			ttstart(tp);
			if (wait == 0 || curproc->p_siglist != oldsig) {
				splx(s);
				return (0);
			}
			SET(tp->t_state, TS_ASLEEP);
			tsleep(&tp->t_outq, PZERO - 1, "ttckoutq", hz);
		}
	splx(s);
	return (1);
}

/*
 * Process a write call on a tty device.
 */
int
ttwrite(struct tty *tp, struct uio *uio, int flag)
{
	u_char *cp = NULL;
	int cc, ce, obufcc = 0;
	struct proc *p;
	struct process *pr;
	int i, hiwat, error, s;
	size_t cnt;
	u_char obuf[OBUFSIZ];

	hiwat = tp->t_hiwat;
	cnt = uio->uio_resid;
	error = 0;
	cc = 0;
loop:
	s = spltty();
	if (!ISSET(tp->t_state, TS_CARR_ON) &&
	    !ISSET(tp->t_cflag, CLOCAL)) {
		if (ISSET(tp->t_state, TS_ISOPEN)) {
			splx(s);
			error = EIO;
			goto done;
		} else if (flag & IO_NDELAY) {
			splx(s);
			error = EWOULDBLOCK;
			goto out;
		} else {
			/* Sleep awaiting carrier. */
			error = ttysleep(tp,
			    &tp->t_rawq, TTIPRI | PCATCH, ttopen, 0);
			splx(s);
			if (error)
				goto out;
			goto loop;
		}
	}
	splx(s);
	/*
	 * Hang the process if it's in the background.
	 */
	p = curproc;
	pr = p->p_p;
	if (isbackground(pr, tp) &&
	    ISSET(tp->t_lflag, TOSTOP) && (pr->ps_flags & PS_PPWAIT) == 0 &&
	    (pr->ps_sigacts->ps_sigignore & sigmask(SIGTTOU)) == 0 &&
	    (p->p_sigmask & sigmask(SIGTTOU)) == 0) {
		if (pr->ps_pgrp->pg_jobc == 0) {
			error = EIO;
			goto out;
		}
		pgsignal(pr->ps_pgrp, SIGTTOU, 1);
		error = ttysleep(tp, &lbolt, TTIPRI | PCATCH, ttybg, 0);
		if (error)
			goto out;
		goto loop;
	}
	/*
	 * Process the user's data in at most OBUFSIZ chunks.  Perform any
	 * output translation.  Keep track of high water mark, sleep on
	 * overflow awaiting device aid in acquiring new space.
	 */
	while (uio->uio_resid > 0 || cc > 0) {
		if (ISSET(tp->t_lflag, FLUSHO)) {
			uio->uio_resid = 0;
			goto done;
		}
		if (tp->t_outq.c_cc > hiwat)
			goto ovhiwat;
		/*
		 * Grab a hunk of data from the user, unless we have some
		 * leftover from last time.
		 */
		if (cc == 0) {
			cc = MIN(uio->uio_resid, OBUFSIZ);
			cp = obuf;
			error = uiomove(cp, cc, uio);
			if (error) {
				cc = 0;
				break;
			}
			if (cc > obufcc)
				obufcc = cc;

			/* duplicate /dev/console output into console buffer */
			if (consbufp && cn_tab &&
			    cn_tab->cn_dev == tp->t_dev && tp->t_gen == 0) {
				int i;
				for (i = 0; i < cc; i++) {
					char c = cp[i];
					if (c != '\0' && c != '\r' && c != 0177)
						msgbuf_putchar(consbufp, c);
				}
			}
		}
		/*
		 * If nothing fancy need be done, grab those characters we
		 * can handle without any of ttyoutput's processing and
		 * just transfer them to the output q.  For those chars
		 * which require special processing (as indicated by the
		 * bits in char_type), call ttyoutput.  After processing
		 * a hunk of data, look for FLUSHO so ^O's will take effect
		 * immediately.
		 */
		while (cc > 0) {
			if (!ISSET(tp->t_oflag, OPOST))
				ce = cc;
			else {
				ce = cc - scanc((u_int)cc, cp, char_type,
				    CCLASSMASK);
				/*
				 * If ce is zero, then we're processing
				 * a special character through ttyoutput.
				 */
				if (ce == 0) {
					tp->t_rocount = 0;
					if (ttyoutput(*cp, tp) >= 0) {
						/* out of space */
						goto ovhiwat;
					}
					cp++;
					cc--;
					if (ISSET(tp->t_lflag, FLUSHO) ||
					    tp->t_outq.c_cc > hiwat)
						goto ovhiwat;
					continue;
				}
			}
			/*
			 * A bunch of normal characters have been found.
			 * Transfer them en masse to the output queue and
			 * continue processing at the top of the loop.
			 * If there are any further characters in this
			 * <= OBUFSIZ chunk, the first should be a character
			 * requiring special handling by ttyoutput.
			 */
			tp->t_rocount = 0;
			i = b_to_q(cp, ce, &tp->t_outq);
			ce -= i;
			tp->t_column += ce;
			cp += ce, cc -= ce, tk_nout += ce;
			tp->t_outcc += ce;
			if (i > 0) {
				/* out of space */
				goto ovhiwat;
			}
			if (ISSET(tp->t_lflag, FLUSHO) ||
			    tp->t_outq.c_cc > hiwat)
				break;
		}
		ttstart(tp);
	}
out:
	/*
	 * If cc is nonzero, we leave the uio structure inconsistent, as the
	 * offset and iov pointers have moved forward, but it doesn't matter
	 * (the call will either return short or restart with a new uio).
	 */
	uio->uio_resid += cc;
done:
	if (obufcc)
		explicit_bzero(obuf, obufcc);
	return (error);

ovhiwat:
	ttstart(tp);
	s = spltty();
	/*
	 * This can only occur if FLUSHO is set in t_lflag,
	 * or if ttstart/oproc is synchronous (or very fast).
	 */
	if (tp->t_outq.c_cc <= hiwat) {
		splx(s);
		goto loop;
	}
	if (flag & IO_NDELAY) {
		splx(s);
		uio->uio_resid += cc;
		if (obufcc)
			explicit_bzero(obuf, obufcc);
		return (uio->uio_resid == cnt ? EWOULDBLOCK : 0);
	}
	SET(tp->t_state, TS_ASLEEP);
	error = ttysleep(tp, &tp->t_outq, TTOPRI | PCATCH, ttyout, 0);
	splx(s);
	if (error)
		goto out;
	goto loop;
}

/*
 * Rubout one character from the rawq of tp
 * as cleanly as possible.
 */
void
ttyrub(int c, struct tty *tp)
{
	u_char *cp;
	int savecol;
	int tabc, s;

	if (!ISSET(tp->t_lflag, ECHO) || ISSET(tp->t_lflag, EXTPROC))
		return;
	CLR(tp->t_lflag, FLUSHO);
	if (ISSET(tp->t_lflag, ECHOE)) {
		if (tp->t_rocount == 0) {
			/*
			 * Screwed by ttwrite; retype
			 */
			ttyretype(tp);
			return;
		}
		if (c == ('\t' | TTY_QUOTE) || c == ('\n' | TTY_QUOTE))
			ttyrubo(tp, 2);
		else {
			CLR(c, ~TTY_CHARMASK);
			switch (CCLASS(c)) {
			case ORDINARY:
				ttyrubo(tp, 1);
				break;
			case BACKSPACE:
			case CONTROL:
			case NEWLINE:
			case RETURN:
			case VTAB:
				if (ISSET(tp->t_lflag, ECHOCTL))
					ttyrubo(tp, 2);
				break;
			case TAB:
				if (tp->t_rocount < tp->t_rawq.c_cc) {
					ttyretype(tp);
					return;
				}
				s = spltty();
				savecol = tp->t_column;
				SET(tp->t_state, TS_CNTTB);
				SET(tp->t_lflag, FLUSHO);
				tp->t_column = tp->t_rocol;
				for (cp = firstc(&tp->t_rawq, &tabc); cp;
				    cp = nextc(&tp->t_rawq, cp, &tabc))
					ttyecho(tabc, tp);
				CLR(tp->t_lflag, FLUSHO);
				CLR(tp->t_state, TS_CNTTB);
				splx(s);

				/* savecol will now be length of the tab. */
				savecol -= tp->t_column;
				tp->t_column += savecol;
				if (savecol > 8)
					savecol = 8;	/* overflow screw */
				while (--savecol >= 0)
					(void)ttyoutput('\b', tp);
				break;
			default:			/* XXX */
#define	PANICSTR	"ttyrub: would panic c = %d, val = %d\n"
				(void)printf(PANICSTR, c, CCLASS(c));
#ifdef notdef
				panic(PANICSTR, c, CCLASS(c));
#endif
			}
		}
	} else if (ISSET(tp->t_lflag, ECHOPRT)) {
		if (!ISSET(tp->t_state, TS_ERASE)) {
			SET(tp->t_state, TS_ERASE);
			(void)ttyoutput('\\', tp);
		}
		ttyecho(c, tp);
	} else
		ttyecho(tp->t_cc[VERASE], tp);
	--tp->t_rocount;
}

/*
 * Back over cnt characters, erasing them.
 */
static void
ttyrubo(struct tty *tp, int cnt)
{

	while (cnt-- > 0) {
		(void)ttyoutput('\b', tp);
		(void)ttyoutput(' ', tp);
		(void)ttyoutput('\b', tp);
	}
}

/*
 * ttyretype --
 *	Reprint the rawq line.  Note, it is assumed that c_cc has already
 *	been checked.
 */
void
ttyretype(struct tty *tp)
{
	u_char *cp;
	int s, c;

	/* Echo the reprint character. */
	if (tp->t_cc[VREPRINT] != _POSIX_VDISABLE)
		ttyecho(tp->t_cc[VREPRINT], tp);

	(void)ttyoutput('\n', tp);

	s = spltty();
	for (cp = firstc(&tp->t_canq, &c); cp; cp = nextc(&tp->t_canq, cp, &c))
		ttyecho(c, tp);
	for (cp = firstc(&tp->t_rawq, &c); cp; cp = nextc(&tp->t_rawq, cp, &c))
		ttyecho(c, tp);
	CLR(tp->t_state, TS_ERASE);
	splx(s);

	tp->t_rocount = tp->t_rawq.c_cc;
	tp->t_rocol = 0;
}

/*
 * Echo a typed character to the terminal.
 */
static void
ttyecho(int c, struct tty *tp)
{

	if (!ISSET(tp->t_state, TS_CNTTB))
		CLR(tp->t_lflag, FLUSHO);
	if ((!ISSET(tp->t_lflag, ECHO) &&
	    (!ISSET(tp->t_lflag, ECHONL) || c != '\n')) ||
	    ISSET(tp->t_lflag, EXTPROC))
		return;
	if (((ISSET(tp->t_lflag, ECHOCTL) &&
	     (ISSET(c, TTY_CHARMASK) <= 037 && c != '\t' && c != '\n')) ||
	    ISSET(c, TTY_CHARMASK) == 0177)) {
		(void)ttyoutput('^', tp);
		CLR(c, ~TTY_CHARMASK);
		if (c == 0177)
			c = '?';
		else
			c += 'A' - 1;
	}
	(void)ttyoutput(c, tp);
}

/*
 * Wakeup any writers if necessary.
 */
void
ttwakeupwr(struct tty *tp)
{

	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (ISSET(tp->t_state, TS_ASLEEP)) {
			CLR(tp->t_state, TS_ASLEEP);
			wakeup(&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
}

/*
 * Wake up any readers on a tty.
 */
void
ttwakeup(struct tty *tp)
{

	selwakeup(&tp->t_rsel);
	if (ISSET(tp->t_state, TS_ASYNC))
		pgsignal(tp->t_pgrp, SIGIO, 1);
	wakeup((caddr_t)&tp->t_rawq);
}

/*
 * Look up a code for a specified speed in a conversion table;
 * used by drivers to map software speed values to hardware parameters.
 */
int
ttspeedtab(int speed, const struct speedtab *table)
{

	for ( ; table->sp_speed != -1; table++)
		if (table->sp_speed == speed)
			return (table->sp_code);
	return (-1);
}

/*
 * Set tty hi and low water marks.
 *
 * Try to arrange the dynamics so there's about one second
 * from hi to low water.
 */
void
ttsetwater(struct tty *tp)
{
	int cps, x;

#define CLAMP(x, h, l)	((x) > h ? h : ((x) < l) ? l : (x))

	cps = tp->t_ospeed / 10;
	tp->t_lowat = x = CLAMP(cps / 2, TTMAXLOWAT, TTMINLOWAT);
	x += cps;
	tp->t_hiwat = CLAMP(x, tp->t_outq.c_cn - TTHIWATMINSPACE, TTMINHIWAT);
#undef	CLAMP
}

/*
 * Get the total estcpu for a process, summing across threads.
 * Returns true if at least one thread is runnable/running.
 */
static int
process_sum(struct process *pr, fixpt_t *estcpup)
{
	struct proc *p;
	fixpt_t estcpu;
	int ret;

	ret = 0;
	estcpu = 0;
	TAILQ_FOREACH(p, &pr->ps_threads, p_thr_link) {
		if (p->p_stat == SRUN || p->p_stat == SONPROC)
			ret = 1;
		estcpu += p->p_pctcpu;
	}

	*estcpup = estcpu;
	return (ret);
}

/*
 * Report on state of foreground process group.
 */
void
ttyinfo(struct tty *tp)
{
	struct process *pr, *pickpr;
	struct proc *p, *pick;
	struct timespec utime, stime;
	int tmp;

	if (ttycheckoutq(tp,0) == 0)
		return;

	/* Print load average. */
	tmp = (averunnable.ldavg[0] * 100 + FSCALE / 2) >> FSHIFT;
	ttyprintf(tp, "load: %d.%02d ", tmp / 100, tmp % 100);

	if (tp->t_session == NULL)
		ttyprintf(tp, "not a controlling terminal\n");
	else if (tp->t_pgrp == NULL)
		ttyprintf(tp, "no foreground process group\n");
	else if ((pr = LIST_FIRST(&tp->t_pgrp->pg_members)) == NULL)
empty:		ttyprintf(tp, "empty foreground process group\n");
	else {
		const char *state;
		fixpt_t pctcpu, pctcpu2;
		int run, run2;
		int calc_pctcpu;
		long rss;

		/*
		 * Pick the most active process:
		 *  - prefer at least one running/runnable thread
		 *  - prefer higher total pctcpu
		 *  - prefer non-zombie
		 * Otherwise take the most recently added to this process group
		 */
		pickpr = pr;
		run = process_sum(pickpr, &pctcpu);
		while ((pr = LIST_NEXT(pr, ps_pglist)) != NULL) {
			run2 = process_sum(pr, &pctcpu2);
			if (run) {
				/*
				 * pick is running; is p running w/same or
				 * more cpu?
				 */
				if (run2 && pctcpu2 >= pctcpu)
					goto update_pickpr;
				continue;
			}
			/* pick isn't running; is p running *or* w/more cpu? */
			if (run2 || pctcpu2 > pctcpu)
				goto update_pickpr;

			/* if p has less cpu or is zombie, then it's worse */
			if (pctcpu2 < pctcpu || (pr->ps_flags & PS_ZOMBIE))
				continue;
update_pickpr:
			pickpr = pr;
			run = run2;
			pctcpu = pctcpu2;
		}

		/* Calculate percentage cpu, resident set size. */
		calc_pctcpu = (pctcpu * 10000 + FSCALE / 2) >> FSHIFT;
		rss = (pickpr->ps_flags & (PS_EMBRYO | PS_ZOMBIE)) ? 0 :
		    vm_resident_count(pickpr->ps_vmspace);

		calctsru(&pickpr->ps_tu, &utime, &stime, NULL);

		/* Round up and print user time. */
		utime.tv_nsec += 5000000;
		if (utime.tv_nsec >= 1000000000) {
			utime.tv_sec += 1;
			utime.tv_nsec -= 1000000000;
		}

		/* Round up and print system time. */
		stime.tv_nsec += 5000000;
		if (stime.tv_nsec >= 1000000000) {
			stime.tv_sec += 1;
			stime.tv_nsec -= 1000000000;
		}

		/*
		 * Find the most active thread:
		 *  - prefer runnable
		 *  - prefer higher pctcpu
		 *  - prefer living
		 * Otherwise take the newest thread
		 */
		pick = p = TAILQ_FIRST(&pickpr->ps_threads);
		if (p == NULL)
			goto empty;
		run = p->p_stat == SRUN || p->p_stat == SONPROC;
		pctcpu = p->p_pctcpu;
		while ((p = TAILQ_NEXT(p, p_thr_link)) != NULL) {
			run2 = p->p_stat == SRUN || p->p_stat == SONPROC;
			pctcpu2 = p->p_pctcpu;
			if (run) {
				/*
				 * pick is running; is p running w/same or
				 * more cpu?
				 */
				if (run2 && pctcpu2 >= pctcpu)
					goto update_pick;
				continue;
			}
			/* pick isn't running; is p running *or* w/more cpu? */
			if (run2 || pctcpu2 > pctcpu)
				goto update_pick;

			/* if p has less cpu or is exiting, then it's worse */
			if (pctcpu2 < pctcpu || p->p_flag & P_WEXIT)
				continue;
update_pick:
			pick = p;
			run = run2;
			pctcpu = p->p_pctcpu;
		}
		state = pick->p_stat == SONPROC ? "running" :
		        pick->p_stat == SRUN ? "runnable" :
		        pick->p_wmesg ? pick->p_wmesg : "iowait";

		ttyprintf(tp,
		    " cmd: %s %d [%s] %lld.%02ldu %lld.%02lds %d%% %ldk\n",
		    pickpr->ps_comm, pickpr->ps_pid, state,
		    (long long)utime.tv_sec, utime.tv_nsec / 10000000,
		    (long long)stime.tv_sec, stime.tv_nsec / 10000000,
		    calc_pctcpu / 100, rss);
	}
	tp->t_rocount = 0;	/* so pending input will be retyped if BS */
}

/*
 * Output char to tty; console putchar style.
 */
int
tputchar(int c, struct tty *tp)
{
	int s;

	s = spltty();
	if (ISSET(tp->t_state, TS_ISOPEN) == 0 ||
	    !(ISSET(tp->t_state, TS_CARR_ON) || ISSET(tp->t_cflag, CLOCAL))) {
		splx(s);
		return (-1);
	}
	if (c == '\n')
		(void)ttyoutput('\r', tp);
	(void)ttyoutput(c, tp);
	ttstart(tp);
	splx(s);
	return (0);
}

/*
 * Sleep on chan, returning ERESTART if tty changed while we napped and
 * returning any errors (e.g. EINTR/ETIMEDOUT) reported by tsleep.  If
 * the tty is revoked, restarting a pending call will redo validation done
 * at the start of the call.
 */
int
ttysleep(struct tty *tp, void *chan, int pri, char *wmesg, int timo)
{
	int error;
	short gen;

	gen = tp->t_gen;
	if ((error = tsleep(chan, pri, wmesg, timo)) != 0)
		return (error);
	return (tp->t_gen == gen ? 0 : ERESTART);
}

/*
 * Initialise the global tty list.
 */
void
tty_init(void)
{

	TAILQ_INIT(&ttylist);
	tty_count = 0;
}

/*
 * Allocate a tty structure and its associated buffers, and attach it to the
 * tty list.
 */
struct tty *
ttymalloc(int baud)
{
	struct tty *tp;

	tp = malloc(sizeof(struct tty), M_TTYS, M_WAITOK|M_ZERO);

	if (baud == 0)
		baud = 115200;

	if (baud <= 9600)
		tp->t_qlen = 1024;
	else if (baud <= 115200)
		tp->t_qlen = 4096;
	else
		tp->t_qlen = 8192;
	clalloc(&tp->t_rawq, tp->t_qlen, 1);
	clalloc(&tp->t_canq, tp->t_qlen, 1);
	/* output queue doesn't need quoting */
	clalloc(&tp->t_outq, tp->t_qlen, 0);

	TAILQ_INSERT_TAIL(&ttylist, tp, tty_link);
	++tty_count;
	timeout_set(&tp->t_rstrt_to, ttrstrt, tp);

	return(tp);
}


/*
 * Free a tty structure and its buffers, after removing it from the tty list.
 */
void
ttyfree(struct tty *tp)
{

	--tty_count;
#ifdef DIAGNOSTIC
	if (tty_count < 0)
		panic("ttyfree: tty_count < 0");
#endif
	TAILQ_REMOVE(&ttylist, tp, tty_link);

	ttkqflush(&tp->t_rsel.si_note);
	ttkqflush(&tp->t_wsel.si_note);

	clfree(&tp->t_rawq);
	clfree(&tp->t_canq);
	clfree(&tp->t_outq);
	free(tp, M_TTYS, sizeof(*tp));
}

void
ttystats_init(struct itty **ttystats, size_t *ttystatssiz)
{
	struct itty *itp;
	struct tty *tp;

	*ttystatssiz = tty_count * sizeof(struct itty);
	*ttystats = mallocarray(tty_count, sizeof(struct itty),
	    M_SYSCTL, M_WAITOK|M_ZERO);
	for (tp = TAILQ_FIRST(&ttylist), itp = *ttystats; tp;
	    tp = TAILQ_NEXT(tp, tty_link), itp++) {
		itp->t_dev = tp->t_dev;
		itp->t_rawq_c_cc = tp->t_rawq.c_cc;
		itp->t_canq_c_cc = tp->t_canq.c_cc;
		itp->t_outq_c_cc = tp->t_outq.c_cc;
		itp->t_hiwat = tp->t_hiwat;
		itp->t_lowat = tp->t_lowat;
		itp->t_column = tp->t_column;
		itp->t_state = tp->t_state;
		itp->t_session = tp->t_session;
		if (tp->t_pgrp)
			itp->t_pgrp_pg_id = tp->t_pgrp->pg_id;
		else
			itp->t_pgrp_pg_id = 0;
		itp->t_line = tp->t_line;
	}
}

/*
 * Return tty-related information.
 */
int
sysctl_tty(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	int err;

	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case KERN_TTY_TKNIN:
		return (sysctl_rdquad(oldp, oldlenp, newp, tk_nin));
	case KERN_TTY_TKNOUT:
		return (sysctl_rdquad(oldp, oldlenp, newp, tk_nout));
	case KERN_TTY_TKRAWCC:
		return (sysctl_rdquad(oldp, oldlenp, newp, tk_rawcc));
	case KERN_TTY_TKCANCC:
		return (sysctl_rdquad(oldp, oldlenp, newp, tk_cancc));
	case KERN_TTY_INFO:
	    {
		struct itty *ttystats;
		size_t ttystatssiz;

		ttystats_init(&ttystats, &ttystatssiz);
		err = sysctl_rdstruct(oldp, oldlenp, newp, ttystats,
		    tty_count * sizeof(struct itty));
		free(ttystats, M_SYSCTL, ttystatssiz);
		return (err);
	    }
	default:
#if NPTY > 0
		return (sysctl_pty(name, namelen, oldp, oldlenp, newp, newlen));
#else
		return (EOPNOTSUPP);
#endif
	}
	/* NOTREACHED */
}

void
ttytstamp(struct tty *tp, int octs, int ncts, int odcd, int ndcd)
{
	int doit = 0;

	if (ncts ^ octs)
		doit |= ncts ? ISSET(tp->t_flags, TS_TSTAMPCTSSET) :
		    ISSET(tp->t_flags, TS_TSTAMPCTSCLR);
	if (ndcd ^ odcd)
		doit |= ndcd ? ISSET(tp->t_flags, TS_TSTAMPDCDSET) :
		    ISSET(tp->t_flags, TS_TSTAMPDCDCLR);

	if (doit)
		microtime(&tp->t_tv);
}
@


1.132
log
@POSIX specifies that if a processing calling tcsetpgrp() is in the
background it shall receive SIGTTOU.  Handle TIOCSPGRP like we do
the other tty ioctls that change the terminal.  OK deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.131 2016/05/17 23:43:47 bluhm Exp $	*/
d2258 1
a2258 1
		    pick->p_comm, pickpr->ps_pid, state,
@


1.131
log
@Allow sendsyslog(2) with LOG_CONS even when /dev/console has not
been opened during init(8).  Only log with cnwrite() if cn_devvp
exists, otherwise use cnputc() as fallback.  While there move extern
declarations to dev/cons.h.
input and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.130 2016/03/19 12:04:15 natano Exp $	*/
a733 1
#ifdef notdef
a734 1
#endif
@


1.130
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.129 2016/01/28 18:02:36 stefan Exp $	*/
a203 2
	extern struct tty *constty;	/* Temporary virtual console. */

a719 1
	extern struct tty *constty;	/* Temporary virtual console. */
@


1.129
log
@Convert to uiomove. Diff from Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.128 2016/01/14 09:44:08 sf Exp $	*/
d806 1
a806 1
			VOP_UNLOCK(nid.ni_vp, 0, p);
@


1.128
log
@Increase buffer sizes and watermarks for tty and ppp

Use 115200 the default speed for buffer sizing in ttymalloc(). A lot
of devices call ttymalloc(0) so this affects quite a few of them.

Increases the buffer size for 9600 < baud <= 115200 from 1k to 4k.

Make ppp use the lo/hi watermarks from the tty layer which are
adjusted according to speed + buffer size. The previous fixed values
of 100 and 400 were way too small

Make pty call ttymalloc() with baud == 1000000, which is the common
value used in the tree for "fast".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.127 2015/12/05 10:11:53 tedu Exp $	*/
d1785 1
a1785 1
			error = uiomovei(cp, cc, uio);
@


1.127
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.126 2015/11/02 16:31:55 semarie Exp $	*/
d2333 4
a2336 1
	if (baud <= 115200)
d2338 2
@


1.126
log
@move the pledgenote annotation from `struct proc' to `struct nameidata'

pledgenote is used for annotate the policy for a namei context. So make it
tracking the nameidata.

It is expected for the caller to explicitly define the policy. It is a kernel
bug to not do so.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.125 2015/10/28 11:17:24 deraadt Exp $	*/
a718 1
/* ARGSUSED */
@


1.125
log
@TIOCCONS will probably never be permitted, but it is good style to set
p_pledgenote before NDINIT()
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.124 2015/08/28 03:49:34 deraadt Exp $	*/
a799 1
			p->p_pledgenote = PLEDGE_RPATH | PLEDGE_WPATH;
d801 1
@


1.124
log
@Modify ttystats_init() to tell us about the buffer size, so that we
can pass the size to free()
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.123 2015/08/26 21:21:57 deraadt Exp $	*/
d62 1
d800 1
@


1.123
log
@two simple free() sizes
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.122 2015/07/20 22:28:57 sf Exp $	*/
d82 1
a82 1
void	ttystats_init(struct itty **);
d2373 1
a2373 1
ttystats_init(struct itty **ttystats)
d2378 1
d2424 1
d2426 1
a2426 1
		ttystats_init(&ttystats);
d2429 1
a2429 1
		free(ttystats, M_SYSCTL, 0);
@


1.122
log
@Fix tty hiwat handling a bit

- Introduce new defines TTHIWATMINSPACE, TTMINHIWAT for some magic values
  that are used in tty.c.
- Remove hiwat adjustments in ttwrite(). This fixes this codepath not
  being interrupt safe.
- Change ttysetwater() to keep at least TTHIWATMINSPACE space above the high
  water mark. This makes it consistent with ttycheckoutq(). Without this
  change, the hiwat adjustment change above causes deadlocks in pty.

ok kspillner@@
commit it now deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.121 2015/02/10 21:56:10 miod Exp $	*/
d1649 1
a1649 1
		free(stime, M_TEMP, 0);
d2369 1
a2369 1
	free(tp, M_TTYS, 0);
@


1.121
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.120 2015/01/13 10:07:58 mpf Exp $	*/
d1691 1
a1691 1
	if (tp->t_outq.c_cc > hiwat + 200)
d1826 1
a1826 1
						goto overfull;
d1852 1
a1852 1
				goto overfull;
a1871 9
overfull:
	/*
	 * Since we are using ring buffers, if we can't insert any more into
	 * the output queue, we can assume the ring is full and that someone
	 * forgot to set the high water mark correctly.  We set it and then
	 * proceed as normal.
	 */
	hiwat = tp->t_outq.c_cc - 1;

d2108 1
a2108 1
	tp->t_hiwat = CLAMP(x, tp->t_outq.c_cn, 100);
@


1.120
log
@Add dmesg -s support, to view the output of rc(8) system startup messages.
Help and feedback by Theo and Miod.
OK deraadt@@, manpage-ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.119 2014/12/17 19:42:15 tedu Exp $	*/
d1784 1
a1784 1
			error = uiomove(cp, cc, uio);
@


1.119
log
@remove lock.h from uvm_extern.h. another holdover from the simpletonlock
era. fix uvm including c files to include lock.h or atomic.h as necessary.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.118 2014/12/16 18:30:04 tedu Exp $	*/
d55 1
d67 1
d1791 11
@


1.118
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.117 2014/12/10 02:44:47 tedu Exp $	*/
d52 1
@


1.117
log
@convert bcopy to memcpy. ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.116 2014/12/01 07:51:47 deraadt Exp $	*/
d62 2
@


1.116
log
@clist's chained, and could get fairly long which is why there was a
dynamic clamping mechanism.  In the (new? has it already been 20 years?)
world of tty ring buffers, c_cn is the maximum...

There could be some ugly limit elsewhere, which may cause a deadlock
(dug as deep as my patience allows), so please report any sort
of new console or xterm issues that show up, such as tty lockups or high
cpu utilization..
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.115 2014/11/18 01:59:58 tedu Exp $	*/
d817 1
a817 1
		bcopy(&tp->t_termios, t, sizeof(struct termios));
d929 1
a929 1
		bcopy(t->c_cc, tp->t_cc, sizeof(t->c_cc));
d1287 1
a1287 1
	bcopy(ttydefchars, tp->t_cc, sizeof(ttydefchars));
@


1.115
log
@include unistd.h instead of picking it up accidentally. noted by jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.114 2014/09/15 19:08:21 miod Exp $	*/
d2094 1
a2094 1
	int cps, x, omost;
d2101 1
a2101 2
	omost = MIN(tp->t_outq.c_cn - 200, tp->t_outq.c_cn);
	tp->t_hiwat = CLAMP(x, omost, 100);
@


1.114
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.113 2014/07/13 15:29:04 tedu Exp $	*/
d59 1
@


1.113
log
@use mallocarray where arguments are multipled. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.112 2014/07/13 14:56:56 guenther Exp $	*/
a48 1
#include <sys/dkstat.h>
@


1.112
log
@If the only process in the pgrp is in the middle of exiting, it might
not have any threads left.  Treat that the same as an empty pgrp.

encountered by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.111 2014/07/12 18:43:32 tedu Exp $	*/
d2372 1
a2372 1
	*ttystats = malloc(tty_count * sizeof(struct itty),
@


1.111
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.110 2014/07/08 17:19:25 deraadt Exp $	*/
d2152 1
a2152 1
		ttyprintf(tp, "empty foreground process group\n");
d2222 2
@


1.110
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.109 2014/07/04 05:58:31 guenther Exp $	*/
d1644 1
a1644 1
		free(stime, M_TEMP);
d2361 1
a2361 1
	free(tp, M_TTYS);
d2419 1
a2419 1
		free(ttystats, M_SYSCTL);
@


1.109
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.108 2014/06/06 22:44:18 matthew Exp $	*/
a62 1
#include <uvm/uvm_extern.h>
@


1.108
log
@Allocate the struct itty array in ttystats_init() with M_ZERO.

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.107 2014/05/30 02:12:04 tedu Exp $	*/
d2186 1
a2186 1
			if (pctcpu2 < pctcpu || P_ZOMBIE(pr->ps_mainproc))
d2196 1
a2196 2
		rss = (!P_ZOMBIE(pickpr->ps_mainproc) &&
		    pickpr->ps_mainproc->p_stat != SIDL) ? 0 :
@


1.107
log
@explicit_bzero for clearing stack variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.106 2014/05/25 18:57:07 guenther Exp $	*/
d2373 1
a2373 1
	    M_SYSCTL, M_WAITOK);
@


1.106
log
@Handle threaded processes correctly when processing kerninfo status requests
(aka ^T), summing CPU and check runnable/running status of all threads.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.105 2014/03/22 06:05:45 guenther Exp $	*/
d183 1
a183 1
		bzero(&tp->t_winsize, sizeof(tp->t_winsize));
d1854 1
a1854 1
		bzero(obuf, obufcc);
d1881 1
a1881 1
			bzero(obuf, obufcc);
@


1.105
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.104 2013/12/16 18:46:39 millert Exp $	*/
a72 1
static int proc_compare(struct proc *, struct proc *);
d2108 23
d2136 2
a2137 2
	struct process *pr;
	struct proc *pick;
d2155 4
a2158 1
		int pctcpu;
d2161 32
a2192 4
		/* Pick interesting process. */
		for (pick = NULL; pr != NULL; pr = LIST_NEXT(pr, ps_pglist))
			if (proc_compare(pick, pr->ps_mainproc))
				pick = pr->ps_mainproc;
d2195 4
a2198 3
		pctcpu = (pick->p_pctcpu * 10000 + FSCALE / 2) >> FSHIFT;
		rss = pick->p_stat == SIDL || P_ZOMBIE(pick) ? 0 :
		    vm_resident_count(pick->p_vmspace);
d2200 1
a2200 1
		calctsru(&pick->p_p->ps_tu, &utime, &stime, NULL);
d2216 38
d2256 1
a2256 4
		    pick->p_comm, pick->p_pid,
		    pick->p_stat == SONPROC ? "running" :
		    pick->p_stat == SRUN ? "runnable" :
		    pick->p_wmesg ? pick->p_wmesg : "iowait",
d2259 1
a2259 1
		    pctcpu / 100, rss);
a2261 72
}

/*
 * Returns 1 if p2 is "better" than p1
 *
 * The algorithm for picking the "interesting" process is thus:
 *
 *	1) Only foreground processes are eligible - implied.
 *	2) Runnable processes are favored over anything else.  The runner
 *	   with the highest cpu utilization is picked (p_estcpu).  Ties are
 *	   broken by picking the highest pid.
 *	3) The sleeper with the shortest sleep time is next.  With ties,
 *	   we pick out just "short-term" sleepers (P_SINTR == 0).
 *	4) Further ties are broken by picking the highest pid.
 */
#define ISRUN(p)	(((p)->p_stat == SRUN) || ((p)->p_stat == SIDL) || \
			 ((p)->p_stat == SONPROC))
#define TESTAB(a, b)    ((a)<<1 | (b))
#define ONLYA   2
#define ONLYB   1
#define BOTH    3

static int
proc_compare(struct proc *p1, struct proc *p2)
{

	if (p1 == NULL)
		return (1);
	/*
	 * see if at least one of them is runnable
	 */
	switch (TESTAB(ISRUN(p1), ISRUN(p2))) {
	case ONLYA:
		return (0);
	case ONLYB:
		return (1);
	case BOTH:
		/*
		 * tie - favor one with highest recent cpu utilization
		 */
		if (p2->p_estcpu > p1->p_estcpu)
			return (1);
		if (p1->p_estcpu > p2->p_estcpu)
			return (0);
		return (p2->p_pid > p1->p_pid);	/* tie - return highest pid */
	}
	/*
 	 * weed out zombies
	 */
	switch (TESTAB(P_ZOMBIE(p1), P_ZOMBIE(p2))) {
	case ONLYA:
		return (1);
	case ONLYB:
		return (0);
	case BOTH:
		return (p2->p_pid > p1->p_pid); /* tie - return highest pid */
	}
	/*
	 * pick the one with the smallest sleep time
	 */
	if (p2->p_slptime > p1->p_slptime)
		return (0);
	if (p1->p_slptime > p2->p_slptime)
		return (1);
	/*
	 * favor one sleeping in a non-interruptible sleep
	 */
	if (p1->p_flag & P_SINTR && (p2->p_flag & P_SINTR) == 0)
		return (1);
	if (p2->p_flag & P_SINTR && (p1->p_flag & P_SINTR) == 0)
		return (0);
	return (p2->p_pid > p1->p_pid);		/* tie - return highest pid */
@


1.104
log
@Restore TIOCGSID ioctl that was removed along with the 4.3BSD tty(4)
compat.  This will be used to implement tcgetsid() in the future.
OK kettenis@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.103 2013/12/13 19:55:12 naddy Exp $	*/
d742 1
a742 1
		    (p->p_sigacts->ps_sigignore & sigmask(SIGTTOU)) == 0 &&
d1493 1
a1493 1
		if ((p->p_sigacts->ps_sigignore & sigmask(SIGTTIN)) ||
d1750 1
a1750 1
	    (p->p_sigacts->ps_sigignore & sigmask(SIGTTOU)) == 0 &&
@


1.103
log
@Remove the 4.3BSD tty(4) compatibility shims.  RIP.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.102 2013/10/11 12:44:12 millert Exp $	*/
d837 5
@


1.102
log
@poll(2) on a closed tty should return POLLIN|POLLHUP in revents
when events is set to POLLIN and POLLHUP when events is set to
POLLOUT.  In the pty case we need to be careful to only treat the
pty as closed if carrier is on.  This fixes a hang on close problem
seen with ssh and xterm.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.100 2013/10/04 17:52:55 millert Exp $	*/
a185 3
#ifdef COMPAT_OLDTTY
		tp->t_flags = 0;
#endif
a739 10
#ifdef COMPAT_OLDTTY
	case  TIOCLBIC:
	case  TIOCLBIS:
	case  TIOCLSET:
	case  TIOCSETC:
	case OTIOCSETD:
	case  TIOCSETN:
	case  TIOCSETP:
	case  TIOCSLTC:
#endif
a1030 3
#ifdef COMPAT_OLDTTY
		return (ttcompat(tp, cmd, data, flag, p));
#else
a1031 1
#endif
@


1.101
log
@Back out POLLHUP change until a problem with xterm hanging on close
is fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.99 2013/06/10 04:44:30 guenther Exp $	*/
d1068 4
a1071 1
	if (events & (POLLOUT | POLLWRNORM)) {
@


1.100
log
@poll(2) on a closed tty should return POLLIN|POLLHUP in revents
when events is set to POLLIN and POLLHUP when events is set to
POLLOUT.  OK deraadt@@
@
text
@d1068 1
a1068 4
	/* NOTE: POLLHUP and POLLOUT/POLLWRNORM are mutually exclusive */
	if (!ISSET(tp->t_cflag, CLOCAL) && !ISSET(tp->t_state, TS_CARR_ON)) {
		revents |= POLLHUP;
	} else if (events & (POLLOUT | POLLWRNORM)) {
@


1.99
log
@Switch from timeval to timespec introduced format error; fix by prepping
for big time_t and casting to long long

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.98 2013/06/03 16:55:22 guenther Exp $	*/
d1068 4
a1071 1
	if (events & (POLLOUT | POLLWRNORM)) {
@


1.98
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.97 2013/04/24 09:52:54 nicm Exp $	*/
d2172 1
a2172 1
		    " cmd: %s %d [%s] %ld.%02ldu %ld.%02lds %d%% %ldk\n",
d2177 3
a2179 2
		    utime.tv_sec, utime.tv_nsec / 10000000,
		    stime.tv_sec, stime.tv_nsec / 10000000, pctcpu / 100, rss);
@


1.97
log
@When a ucom(4) is removed, it frees the tty with ttyfree(). However if
anyone is waiting with kqueue their knotes may still have a reference to
the tty and later try to use it in the filt_tty* functions.

To avoid this, walk the knotes in ttyfree(), remove them from the tty's
list and invalidate them by setting kn_hook to NODEV. The filter
functions can then check for this and safely ignore the knotes.

ok tedu matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.96 2013/01/17 21:24:58 deraadt Exp $	*/
d2125 1
a2125 1
	struct timeval utime, stime;
d2155 1
a2155 1
		calcru(&pick->p_p->ps_tu, &utime, &stime, NULL);
d2158 2
a2159 2
		utime.tv_usec += 5000;
		if (utime.tv_usec >= 1000000) {
d2161 1
a2161 1
			utime.tv_usec -= 1000000;
d2165 2
a2166 2
		stime.tv_usec += 5000;
		if (stime.tv_usec >= 1000000) {
d2168 1
a2168 1
			stime.tv_usec -= 1000000;
d2177 2
a2178 2
		    utime.tv_sec, utime.tv_usec / 10000,
		    stime.tv_sec, stime.tv_usec / 10000, pctcpu / 100, rss);
@


1.96
log
@Ensure the tty hiwat is less than the size of the ring buffer (since
we do not grow space like clist chains).  Clamp it a bit more precisely,
ensuring a bit of space for kernel ^T handling and such.  It was definately
wrong, and we can tune this if required later.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.95 2012/04/22 02:26:11 matthew Exp $	*/
d74 1
d1117 13
d1133 6
a1138 2
	struct tty *tp = (*cdevsw[major(dev)].d_tty)(dev);
	int s = spltty();
d1140 1
d1149 1
a1149 1
	struct tty *tp = (*cdevsw[major(dev)].d_tty)(dev);
d1152 6
d1172 6
a1177 2
	struct tty *tp = (*cdevsw[major(dev)].d_tty)(dev);
	int s = spltty();
d1179 1
d1188 1
a1188 1
	struct tty *tp = (*cdevsw[major(dev)].d_tty)(dev);
d1191 6
d2347 3
@


1.95
log
@Reset t_column to 0 when initializing a tty.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.94 2012/03/23 15:51:26 guenther Exp $	*/
d2069 1
a2069 1
	int cps, x;
d2076 2
a2077 2
	x = CLAMP(x, TTMAXHIWAT, TTMINHIWAT);
	tp->t_hiwat = roundup(x, CBSIZE);
@


1.94
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.93 2011/07/05 04:48:02 guenther Exp $	*/
d184 1
@


1.93
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.92 2011/07/02 22:20:08 nicm Exp $	*/
d2118 1
a2118 1
		calcru(pick, &utime, &stime, NULL);
@


1.92
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.91 2011/04/18 21:44:56 guenther Exp $	*/
d753 1
a753 1
		    (p->p_sigignore & sigmask(SIGTTOU)) == 0 &&
d1465 1
a1465 1
		if ((p->p_sigignore & sigmask(SIGTTIN)) ||
d1722 1
a1722 1
	    (p->p_sigignore & sigmask(SIGTTOU)) == 0 &&
@


1.91
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.89 2011/04/03 14:56:28 guenther Exp $	*/
d1102 1
a1102 1
		return (1);
@


1.90
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d753 1
a753 1
		    (p->p_sigacts->ps_sigignore & sigmask(SIGTTOU)) == 0 &&
d1465 1
a1465 1
		if ((p->p_sigacts->ps_sigignore & sigmask(SIGTTIN)) ||
d1722 1
a1722 1
	    (p->p_sigacts->ps_sigignore & sigmask(SIGTTOU)) == 0 &&
@


1.89
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.88 2010/07/26 01:56:27 guenther Exp $	*/
d753 1
a753 1
		    (p->p_sigignore & sigmask(SIGTTOU)) == 0 &&
d1465 1
a1465 1
		if ((p->p_sigignore & sigmask(SIGTTIN)) ||
d1722 1
a1722 1
	    (p->p_sigignore & sigmask(SIGTTOU)) == 0 &&
@


1.88
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.87 2010/07/02 17:27:01 nicm Exp $	*/
d752 1
a752 1
		    (p->p_flag & P_PPWAIT) == 0 &&
d1467 1
a1467 1
		    p->p_flag & P_PPWAIT || pr->ps_pgrp->pg_jobc == 0) {
d1721 1
a1721 1
	    ISSET(tp->t_lflag, TOSTOP) && (p->p_flag & P_PPWAIT) == 0 &&
@


1.87
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.86 2010/06/28 14:13:35 deraadt Exp $	*/
d722 1
d751 1
a751 1
		while (isbackground(p, tp) &&
d755 1
a755 1
			if (p->p_pgrp->pg_jobc == 0)
d757 1
a757 1
			pgsignal(p->p_pgrp, SIGTTOU, 1);
d845 1
a845 1
		if (!isctty(p, tp) && suser(p, 0))
d905 1
a905 1
					psignal(tp->t_session->s_leader,
d974 1
a974 1
		if (p->p_ucred->cr_uid && !isctty(p, tp))
d988 3
a990 3
		if (!SESS_LEADER(p) ||
		    ((p->p_session->s_ttyvp || tp->t_session) &&
		     (tp->t_session != p->p_session)))
d994 5
a998 5
		SESSHOLD(p->p_session);
		tp->t_session = p->p_session;
		tp->t_pgrp = p->p_pgrp;
		p->p_session->s_ttyp = tp;
		atomic_setbits_int(&p->p_flag, P_CONTROLT);
d1003 1
a1003 1
		if (!isctty(p, tp))
d1007 1
a1007 1
		else if (pgrp->pg_session != p->p_session)
d1367 1
a1367 1
				psignal(tp->t_session->s_leader, SIGHUP);
d1396 1
a1396 1
				psignal(tp->t_session->s_leader, SIGHUP);
d1444 1
d1464 1
a1464 1
	if (isbackground(p, tp)) {
d1467 1
a1467 1
		    p->p_flag & P_PPWAIT || p->p_pgrp->pg_jobc == 0) {
d1471 1
a1471 1
		pgsignal(p->p_pgrp, SIGTTIN, 1);
d1683 1
d1719 2
a1720 1
	if (isbackground(p, tp) &&
d1724 1
a1724 1
		if (p->p_pgrp->pg_jobc == 0) {
d1728 1
a1728 1
		pgsignal(p->p_pgrp, SIGTTOU, 1);
d2086 2
a2087 1
	struct proc *p, *pick;
d2102 1
a2102 1
	else if ((p = LIST_FIRST(&tp->t_pgrp->pg_members)) == NULL)
d2109 3
a2111 3
		for (pick = NULL; p != 0; p = LIST_NEXT(p, p_pglist))
			if (proc_compare(pick, p))
				pick = p;
@


1.86
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.85 2010/04/12 12:57:52 tedu Exp $	*/
d2010 16
@


1.85
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.84 2009/11/27 09:18:01 sobrado Exp $	*/
d529 1
a529 1
	if (tp->t_rawq.c_cc + tp->t_canq.c_cc >= TTYHOG) {
d1272 1
a1272 1
	if (tp->t_rawq.c_cc > TTYHOG) {
d1280 1
a1280 1
	if ((total >= TTYHOG / 2 &&
d1609 1
a1609 1
	if (tp->t_rawq.c_cc < TTYHOG/5)
d2253 1
a2253 1
ttymalloc(void)
d2259 6
a2264 3
	/* XXX: default to 1024 chars for now */
	clalloc(&tp->t_rawq, 1024, 1);
	clalloc(&tp->t_canq, 1024, 1);
d2266 1
a2266 1
	clalloc(&tp->t_outq, 1024, 0);
@


1.84
log
@typo in documentation; missing full stop.

from Dawe.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.83 2009/11/09 17:53:39 nicm Exp $	*/
d175 1
a175 1
ttyopen(dev_t device, struct tty *tp)
d948 2
a949 2
			(*linesw[tp->t_line].l_close)(tp, flag);
			error = (*linesw[t].l_open)(device, tp);
d951 1
a951 1
				(void)(*linesw[tp->t_line].l_open)(device, tp);
d1328 1
a1328 1
ttylclose(struct tty *tp, int flag)
@


1.83
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.82 2009/10/30 16:41:10 nicm Exp $	*/
d879 1
a879 1
			 * Some minor validation is neccessary.
@


1.82
log
@Add missing KNOTE() calls after selwakeup() in ptcread() (to wake up writers
after the master side of the pty has finished reading) and in ttyflush().

ok tedu millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.81 2009/10/28 16:56:46 deraadt Exp $	*/
a1248 1
		KNOTE(&tp->t_wsel.si_note, 0);
a2022 1
	KNOTE(&tp->t_rsel.si_note, 0);
@


1.81
log
@For the TIOCSET* ioctls, validate that the tty speeds are positive (since
they are signed int)
ok miod guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.80 2009/07/19 08:16:06 blambert Exp $	*/
d1249 1
@


1.80
log
@clalloc() can't fail, so there's no need to handle failure cases.
Change to void function.
Also, no need to have global tty stats pointer, so just return it
from clalloc, as the caller frees it immediately anyway.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.79 2008/12/24 11:20:31 kettenis Exp $	*/
d878 7
@


1.79
log
@EVFILT_WRITE filters should return the amount of space remaining in the
write buffer, not the amount of space used.  It is debatable wether the
size of the write buffer is set by the size of the buffer or the high water
mark.  For now, go with the former since that seems to be more consistent
with what the pipe and socet code does.  It is also what NetBSD does.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.78 2008/11/11 15:33:02 deraadt Exp $	*/
d78 1
a78 1
int	ttystats_init(void);
d2287 2
a2288 4
struct itty *ttystats;

int
ttystats_init(void)
d2293 1
a2293 1
	ttystats = malloc(tty_count * sizeof(struct itty),
d2295 1
a2295 1
	for (tp = TAILQ_FIRST(&ttylist), itp = ttystats; tp;
a2311 1
	return (0);
d2336 4
a2339 3
		err = ttystats_init();
		if (err)
			return (err);
d2344 1
@


1.78
log
@for ^T support, grab all the information from the process before going
into a potentially sleeping function... ok tedu.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.77 2008/07/28 06:13:22 stefan Exp $	*/
d1150 1
d1152 5
a1156 2
	kn->kn_data = tp->t_outq.c_cc;
	return (kn->kn_data <= tp->t_lowat);
@


1.77
log
@Fix integer truncation in ttwrite(). ok deraadt, miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.76 2008/05/23 16:42:03 deraadt Exp $	*/
d2074 3
d2082 4
a2085 4
		ttyprintf(tp, " cmd: %s %d [%s] ", pick->p_comm, pick->p_pid,
		    pick->p_stat == SONPROC ? "running" :
		    pick->p_stat == SRUN ? "runnable" :
		    pick->p_wmesg ? pick->p_wmesg : "iowait");
a2094 2
		ttyprintf(tp, "%ld.%02ldu ", utime.tv_sec,
		    utime.tv_usec / 10000);
a2101 2
		ttyprintf(tp, "%ld.%02lds ", stime.tv_sec,
		    stime.tv_usec / 10000);
d2103 8
a2110 7
#define	pgtok(a)	(((u_long) ((a) * PAGE_SIZE) / 1024))
		/* Print percentage cpu, resident set size. */
		tmp = (pick->p_pctcpu * 10000 + FSCALE / 2) >> FSHIFT;
		ttyprintf(tp, "%d%% %ldk\n",
		    tmp / 100,
		    pick->p_stat == SIDL || P_ZOMBIE(pick) ? 0 :
			vm_resident_count(pick->p_vmspace));
@


1.76
log
@tputchar() can put characters on the tty output queue if clocal is set,
fixing (status) ^T support on some ttys without carrier
ok pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.75 2008/04/10 19:55:41 deraadt Exp $	*/
d1670 2
a1671 1
	int i, hiwat, cnt, error, s;
d1736 1
a1736 1
			cc = min(uio->uio_resid, OBUFSIZ);
@


1.75
log
@scrub local stack-based buffers in the tty subsystem.  tested by a lot of
developers.  if you notice tty weirdnesses in the next few months, talk to
me
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.74 2007/10/29 14:12:19 chl Exp $	*/
d2195 2
a2196 2
	if (ISSET(tp->t_state,
	    TS_CARR_ON | TS_ISOPEN) != (TS_CARR_ON | TS_ISOPEN)) {
@


1.74
log
@MALLOC/FREE -> malloc/free
replace an hard coded value with M_WAITOK

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.73 2007/09/07 15:00:20 art Exp $	*/
d1668 1
a1668 1
	int cc, ce;
d1683 2
a1684 1
			return (EIO);
d1726 1
a1726 1
			return (0);
d1742 2
d1809 3
d1837 2
@


1.73
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.72 2007/03/15 10:22:30 art Exp $	*/
d2271 1
a2271 1
	FREE(tp, M_TTYS);
@


1.72
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.71 2006/06/17 00:47:16 deraadt Exp $	*/
d2238 2
a2239 2
	MALLOC(tp, struct tty *, sizeof(struct tty), M_TTYS, M_WAITOK);
	bzero(tp, sizeof *tp);
@


1.71
log
@avoid missing events for timestamping (dcd change at same time as cts);
mrd@@alkemio.org
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.70 2006/04/27 19:30:28 deraadt Exp $	*/
d990 1
a990 1
		p->p_flag |= P_CONTROLT;
@


1.70
log
@create a (very simple) method for timestamping CTS & DCD events on ttys,
using ioctl TIOCSTSTAMP & TIOCGTSTAMP.  to be used later for gps monitoring
type things; ok kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.69 2005/12/21 12:43:49 jsg Exp $	*/
d2348 7
a2354 7
	if (ncts ^ octs) {
		doit = (ncts && ISSET(tp->t_flags, TS_TSTAMPCTSSET)) ||
		    (!ncts && ISSET(tp->t_flags, TS_TSTAMPCTSCLR));
	} else if (ndcd ^ odcd) {
		doit = (ndcd && ISSET(tp->t_flags, TS_TSTAMPDCDSET)) ||
		    (!ndcd && ISSET(tp->t_flags, TS_TSTAMPDCDCLR));
	}
@


1.69
log
@ansi/deregister. No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.68 2004/12/26 21:22:13 miod Exp $	*/
d838 5
d1014 19
d2341 16
@


1.68
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.67 2004/11/18 15:10:24 markus Exp $	*/
d175 1
a175 3
ttyopen(device, tp)
	dev_t device;
	register struct tty *tp;
d199 1
a199 2
ttyclose(tp)
	register struct tty *tp;
d232 1
a232 3
ttyinput(c, tp)
	register int c;
	register struct tty *tp;
d234 2
a235 2
	register int iflag, lflag;
	register u_char *cc;
d594 1
a594 3
ttyoutput(c, tp)
	register int c;
	register struct tty *tp;
d596 2
a597 2
	register long oflag;
	register int col, notout, s, c2;
d718 1
a718 6
ttioctl(tp, cmd, data, flag, p)
	register struct tty *tp;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d787 1
a787 1
		register int flags = *(int *)data;
d861 1
a861 1
		register struct termios *t = (struct termios *)data;
d929 1
a929 1
		register int t = *(int *)data;
d988 1
a988 1
		register struct pgrp *pgrp = pgfind(*(int *)data);
d1020 1
a1020 4
ttpoll(device, events, p)
	dev_t device;
	int events;
	struct proc *p;
d1054 1
a1054 3
ttkqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
d1122 1
a1122 3
filt_ttywrite(kn, hint)
	struct knote *kn;
	long hint;
d1132 1
a1132 2
ttnread(tp)
	struct tty *tp;
d1153 1
a1153 2
ttywait(tp)
	register struct tty *tp;
d1181 1
a1181 2
ttywflush(tp)
	struct tty *tp;
d1194 1
a1194 3
ttyflush(tp, rw)
	register struct tty *tp;
	int rw;
d1196 1
a1196 1
	register int s;
d1222 1
a1222 2
ttychars(tp)
	struct tty *tp;
d1232 1
a1232 2
ttyblock(tp)
	register struct tty *tp;
d1234 1
a1234 1
	register int total;
d1262 1
a1262 2
ttrstrt(tp_arg)
	void *tp_arg;
d1281 1
a1281 2
ttstart(tp)
	struct tty *tp;
d1293 1
a1293 3
ttylclose(tp, flag)
	struct tty *tp;
	int flag;
d1309 1
a1309 3
ttymodem(tp, flag)
	register struct tty *tp;
	int flag;
d1350 1
a1350 3
nullmodem(tp, flag)
	register struct tty *tp;
	int flag;
d1404 1
a1404 4
ttread(tp, uio, flag)
	register struct tty *tp;
	struct uio *uio;
	int flag;
d1616 1
a1616 3
ttycheckoutq(tp, wait)
	register struct tty *tp;
	int wait;
d1641 1
a1641 4
ttwrite(tp, uio, flag)
	struct tty *tp;
	struct uio *uio;
	int flag;
d1822 1
a1822 3
ttyrub(c, tp)
	int c;
	register struct tty *tp;
d1824 2
a1825 2
	register u_char *cp;
	register int savecol;
d1903 1
a1903 3
ttyrubo(tp, cnt)
	register struct tty *tp;
	int cnt;
d1919 1
a1919 2
ttyretype(tp)
	register struct tty *tp;
d1921 1
a1921 1
	register u_char *cp;
d1946 1
a1946 3
ttyecho(c, tp)
	register int c;
	register struct tty *tp;
d1972 1
a1972 2
ttwakeup(tp)
	register struct tty *tp;
d1987 1
a1987 3
ttspeedtab(speed, table)
	int speed;
	const struct speedtab *table;
d2003 1
a2003 2
ttsetwater(tp)
	struct tty *tp;
d2005 1
a2005 1
	register int cps, x;
d2021 1
a2021 2
ttyinfo(tp)
	register struct tty *tp;
d2023 1
a2023 1
	register struct proc *p, *pick;
d2103 1
a2103 2
proc_compare(p1, p2)
	register struct proc *p1, *p2;
d2158 1
a2158 3
tputchar(c, tp)
	int c;
	struct tty *tp;
d2160 1
a2160 1
	register int s;
d2183 1
a2183 5
ttysleep(tp, chan, pri, wmesg, timo)
	struct tty *tp;
	void *chan;
	int pri, timo;
	char *wmesg;
d2198 1
a2198 1
tty_init()
d2210 1
a2210 1
ttymalloc()
d2234 1
a2234 2
ttyfree(tp)
	struct tty *tp;
d2284 2
a2285 7
sysctl_tty(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
@


1.67
log
@handle SONPROC; ok aaron, deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.66 2004/09/19 21:34:43 mickey Exp $	*/
d2092 1
a2092 1
	else if ((p = tp->t_pgrp->pg_members.lh_first) == 0)
d2096 1
a2096 1
		for (pick = NULL; p != 0; p = p->p_pglist.le_next)
@


1.66
log
@constify speedtabs and make ttspeedtab() take a const struct speedtab *
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.65 2004/06/13 21:49:26 niklas Exp $	*/
d2149 2
a2150 1
#define ISRUN(p)	(((p)->p_stat == SRUN) || ((p)->p_stat == SIDL))
@


1.65
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2039 1
a2039 1
	register struct speedtab *table;
@


1.64
log
@check for CLOCAL flag in right variable; from sq@@oganer.net
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.63 2004/02/10 01:19:47 millert Exp $	*/
d2101 2
a2102 1
		    pick->p_stat == SRUN ? "running" :
@


1.63
log
@Dynamically allocate space for ptys; adapted from NetBSD by beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.62 2003/10/03 16:44:51 miod Exp $	*/
d1120 1
a1120 1
	if (!ISSET(tp->t_state, CLOCAL) && !ISSET(tp->t_state, TS_CARR_ON)) {
@


1.62
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.61 2003/09/23 16:51:12 millert Exp $	*/
d66 2
d2375 3
d2379 1
@


1.61
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.60 2003/08/23 19:21:15 deraadt Exp $	*/
d2263 2
a2264 39
 * Attach a tty to the tty list.
 *
 * This should be called ONLY once per real tty (including pty's).
 * eg, on the sparc, the keyboard and mouse have struct tty's that are
 * distinctly NOT usable as tty's, and thus should not be attached to
 * the ttylist.  This is why this call is not done from ttymalloc().
 *
 * Device drivers should attach tty's at a similar time that they are
 * ttymalloc()'ed, or, for the case of statically allocated struct tty's
 * either in the attach or (first) open routine.
 */
void
tty_attach(tp)
	struct tty *tp;
{

	TAILQ_INSERT_TAIL(&ttylist, tp, tty_link);
	++tty_count;
	timeout_set(&tp->t_rstrt_to, ttrstrt, tp);
}

/*
 * Remove a tty from the tty list.
 */
void
tty_detach(tp)
	struct tty *tp;
{

	--tty_count;
#ifdef DIAGNOSTIC
	if (tty_count < 0)
		panic("tty_detach: tty_count < 0");
#endif
	TAILQ_REMOVE(&ttylist, tp, tty_link);
}

/*
 * Allocate a tty structure and its associated buffers.
d2278 5
d2286 1
d2288 1
a2288 4
 * Free a tty structure and its buffers.
 *
 * Be sure to call tty_detach() for any tty that has been
 * tty_attach()ed.
d2294 7
@


1.60
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.59 2003/08/15 20:32:18 tedu Exp $	*/
d59 1
d1030 1
a1030 1
ttselect(device, rw, p)
d1032 1
a1032 1
	int rw;
d1035 2
a1036 2
	register struct tty *tp;
	int nread, s;
d1040 1
d1042 14
a1055 15
	switch (rw) {
	case FREAD:
		nread = ttnread(tp);
		if (nread > 0 || (!ISSET(tp->t_cflag, CLOCAL) &&
				  !ISSET(tp->t_state, TS_CARR_ON)))
			goto win;
		selrecord(p, &tp->t_rsel);
		break;
	case FWRITE:
		if (tp->t_outq.c_cc <= tp->t_lowat) {
win:			splx(s);
			return (1);
		}
		selrecord(p, &tp->t_wsel);
		break;
d1058 1
a1058 1
	return (0);
@


1.59
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.58 2003/06/02 23:28:06 millert Exp $	*/
d1178 2
a1179 2
	    (ISSET(tp->t_state, TS_CARR_ON) || ISSET(tp->t_cflag, CLOCAL))
	    && tp->t_oproc) {
@


1.58
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.57 2002/12/20 19:44:23 millert Exp $	*/
d848 1
a848 1
		if (!isctty(p, tp) && suser(p->p_ucred, &p->p_acflag))
@


1.57
log
@Clear error before jumping back to the input loop.  If error was set
to EWOULDBLOCK it would otherwise not get cleared;  Jim Geovedi
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.56 2002/12/12 04:17:14 deraadt Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.56
log
@can now get _ttylist via sysctl; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.55 2002/07/30 00:17:10 nordin Exp $	*/
d1560 1
@


1.55
log
@Release sessions to avoid memory leak. From NetBSD. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.54 2002/07/11 22:48:51 art Exp $	*/
d79 1
d2337 30
d2379 2
d2393 8
@


1.54
log
@Make sure to protect ttypend with spltty all the time.
Implemented with paranoia.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.53 2002/07/03 21:19:08 miod Exp $	*/
d62 1
d213 2
d991 2
@


1.53
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.52 2002/06/11 05:06:18 art Exp $	*/
d239 1
d247 1
d252 1
d255 1
d786 1
d788 1
d1110 1
d1112 1
d1114 1
d1150 2
@


1.52
log
@splassert(IPL_TTY) where comments tell us we should
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.51 2002/03/14 01:27:05 millert Exp $	*/
d167 2
@


1.51
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.50 2002/01/30 20:45:35 nordin Exp $	*/
d1389 1
a1389 2
ttypend(tp)
	register struct tty *tp;
d1392 3
a1394 1
	register int c;
d1606 1
a1606 2
ttyunblock(tp)
	struct tty *tp;
d1609 2
@


1.51.2.1
log
@Pull in patch from current:
Fix (nordin):
Release sessions to avoid memory leak. From NetBSD. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.51 2002/03/14 01:27:05 millert Exp $	*/
a61 1
#include <sys/pool.h>
a209 2
	if (tp->t_session)
		SESSRELE(tp->t_session);
a979 2
		if (tp->t_session)
			SESSRELE(tp->t_session);
@


1.50
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.49 2001/12/27 22:34:36 nordin Exp $	*/
d68 10
a77 10
static int ttnread __P((struct tty *));
static void ttyblock __P((struct tty *));
void ttyunblock __P((struct tty *));
static void ttyecho __P((int, struct tty *));
static void ttyrubo __P((struct tty *, int));
static int proc_compare __P((struct proc *, struct proc *));
int	filt_ttyread __P((struct knote *kn, long hint));
void 	filt_ttyrdetach __P((struct knote *kn));
int	filt_ttywrite __P((struct knote *kn, long hint));
void 	filt_ttywdetach __P((struct knote *kn));
@


1.49
log
@Increment reference count when copying session pointer pr#2112. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.48 2001/11/06 19:53:20 miod Exp $	*/
a157 5

/* Macros to clear/set/test flags. */
#define	SET(t, f)	(t) |= (f)
#define	CLR(t, f)	(t) &= ~((unsigned)(f))
#define	ISSET(t, f)	((t) & (f))
@


1.48
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.47 2001/10/07 22:27:01 art Exp $	*/
d985 1
@


1.48.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.50 2002/01/30 20:45:35 nordin Exp $	*/
d159 5
a984 1
		SESSHOLD(p->p_session);
@


1.48.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.48.2.1 2002/01/31 22:55:41 niklas Exp $	*/
d68 10
a77 10
static int ttnread(struct tty *);
static void ttyblock(struct tty *);
void ttyunblock(struct tty *);
static void ttyecho(int, struct tty *);
static void ttyrubo(struct tty *, int);
static int proc_compare(struct proc *, struct proc *);
int	filt_ttyread(struct knote *kn, long hint);
void 	filt_ttyrdetach(struct knote *kn);
int	filt_ttywrite(struct knote *kn, long hint);
void 	filt_ttywdetach(struct knote *kn);
@


1.48.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.48.2.2 2002/06/11 03:29:40 art Exp $	*/
a61 1
#include <sys/pool.h>
a167 2
int64_t tk_cancc, tk_nin, tk_nout, tk_rawcc;

a209 2
	if (tp->t_session)
		SESSRELE(tp->t_session);
a236 1
	int s;
a243 1

a247 1
	s = spltty();
a249 1
	splx(s);
a779 1
		s = spltty();
a780 1
		splx(s);
a979 2
		if (tp->t_session)
			SESSRELE(tp->t_session);
a1101 1
	int s;
a1102 1
	s = spltty();
a1103 1
	splx(s);
a1139 2
	splassert(IPL_TTY);

d1389 2
a1390 1
ttypend(struct tty *tp)
d1393 1
a1393 3
	int c;

	splassert(IPL_TTY);
d1605 2
a1606 1
ttyunblock(struct tty *tp)
a1608 2

	splassert(IPL_TTY);
@


1.48.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a78 1
int	ttystats_init(void);
a1558 1
		error = 0;
a2335 30
struct itty *ttystats;

int
ttystats_init(void)
{
	struct itty *itp;
	struct tty *tp;

	ttystats = malloc(tty_count * sizeof(struct itty),
	    M_SYSCTL, M_WAITOK);
	for (tp = TAILQ_FIRST(&ttylist), itp = ttystats; tp;
	    tp = TAILQ_NEXT(tp, tty_link), itp++) {
		itp->t_dev = tp->t_dev;
		itp->t_rawq_c_cc = tp->t_rawq.c_cc;
		itp->t_canq_c_cc = tp->t_canq.c_cc;
		itp->t_outq_c_cc = tp->t_outq.c_cc;
		itp->t_hiwat = tp->t_hiwat;
		itp->t_lowat = tp->t_lowat;
		itp->t_column = tp->t_column;
		itp->t_state = tp->t_state;
		itp->t_session = tp->t_session;
		if (tp->t_pgrp)
			itp->t_pgrp_pg_id = tp->t_pgrp->pg_id;
		else
			itp->t_pgrp_pg_id = 0;
		itp->t_line = tp->t_line;
	}
	return (0);
}

a2347 2
	int err;

a2359 8
	case KERN_TTY_INFO:
		err = ttystats_init();
		if (err)
			return (err);
		err = sysctl_rdstruct(oldp, oldlenp, newp, ttystats,
		    tty_count * sizeof(struct itty));
		free(ttystats, M_SYSCTL);
		return (err);
@


1.47
log
@Setting the VTIME to a value larger than 214 lead to an integer overflow
in the calculation of the sleep timeout which could lead to a panic.

Instead of doing the very error-prone, and in more than one way incorrect,
sleep time calculation, allocate an external timeout and let it wake us.

Reported by: Raan Young <raan@@graand-visions.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.46 2001/09/28 13:04:39 art Exp $	*/
d65 1
a65 1
#include <vm/vm.h>
@


1.47.2.1
log
@Pull in patch from current:
Fix (nordin):
Increment reference count when copying session pointer pr#2112. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.47 2001/10/07 22:27:01 art Exp $	*/
a984 1
		SESSHOLD(p->p_session);
@


1.47.2.2
log
@MFC (nordin):
Release sessions to avoid memory leak. From NetBSD. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.47.2.1 2002/01/02 20:19:10 jason Exp $	*/
a61 1
#include <sys/pool.h>
a214 2
	if (tp->t_session)
		SESSRELE(tp->t_session);
a984 2
		if (tp->t_session)
			SESSRELE(tp->t_session);
@


1.46
log
@Random cleanup (I don't like Ms in my tree).
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.45 2001/07/05 10:12:24 art Exp $	*/
d1409 10
d1428 2
a1429 5
	register struct clist *qp;
	register int c;
	register long lflag;
	register u_char *cc = tp->t_cc;
	register struct proc *p = curproc;
d1431 5
a1435 3
	struct timeval stime;
	int has_stime = 0, last_cc = 0;
	long slp = 0;
d1452 4
a1455 2
		    p->p_flag & P_PPWAIT || p->p_pgrp->pg_jobc == 0)
			return (EIO);
d1459 1
a1459 1
			return (error);
d1466 8
a1473 1
		long t = cc[VTIME];
a1480 2
		 * For the other two cases, we compute the target sleep time
		 * into slp.
a1486 3
		t *= 100000;		/* time in us */
#define diff(t1, t2) (((t1).tv_sec - (t2).tv_sec) * 1000000 + \
			 ((t1).tv_usec - (t2).tv_usec))
d1492 5
a1496 5
			if (!has_stime) {
				/* first character, start timer */
				has_stime = 1;
				stime = time;
				slp = t;
d1499 1
a1499 5
				stime = time;
				slp = t;
			} else {
				/* nothing, check expiration */
				slp = t - diff(time, stime);
d1504 3
a1506 6
			if (!has_stime) {
				has_stime = 1;
				stime = time;
				slp = t;
			} else
				slp = t - diff(time, stime);
d1509 1
a1509 11
#undef diff
		if (slp > 0) {
			/*
			 * Rounding down may make us wake up just short
			 * of the target, so we round up.
			 * The formula is ceiling(slp * hz/1000000).
			 * 32-bit arithmetic is enough for hz < 169.
			 *
			 * Also, use plain wakeup() not ttwakeup().
			 */
			slp = (long) (((u_long)slp * hz) + 999999) / 1000000;
d1525 2
a1526 1
			return (0);	/* EOF */
d1530 2
a1531 1
			return (EWOULDBLOCK);
d1534 1
a1534 1
		    carrier ? ttyin : ttopen, slp);
d1536 6
a1541 2
		if (cc[VMIN] == 0 && error == EWOULDBLOCK)
			return (0);
d1543 1
a1543 1
			return (error);
d1598 6
@


1.45
log
@Get rid of REAL_CLISTS. It was never implemented and the tentacles are
everywhhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.44 2001/05/14 07:15:33 angelos Exp $	*/
d1656 2
a1657 2
	register struct tty *tp;
	register struct uio *uio;
d1660 3
a1662 3
	register u_char *cp = NULL;
	register int cc, ce;
	register struct proc *p;
@


1.44
log
@tty stats sysctl, deraadt@@ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.43 2001/03/02 08:04:04 art Exp $	*/
a82 3
#ifdef REAL_CLISTS
char ttybuf[]	= "ttybuf";
#endif
a1756 8
#ifdef REAL_CLISTS
						/* No Clists, wait a bit. */
						ttstart(tp);
						if (error = ttysleep(tp, &lbolt,
						    TTOPRI | PCATCH, ttybuf, 0))
							break;
						goto loop;
#else
a1758 1
#endif
a1782 8
#ifdef REAL_CLISTS
				/* No Clists, wait a bit. */
				ttstart(tp);
				if (error = ttysleep(tp,
				    &lbolt, TTOPRI | PCATCH, ttybuf, 0))
					break;
				goto loop;
#else
a1784 1
#endif
a1800 1
#ifndef REAL_CLISTS
a1808 1
#endif
@


1.43
log
@Casting magic to avoid warnings on alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.42 2001/03/01 20:54:34 provos Exp $	*/
d61 1
d2333 30
@


1.42
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.41 2000/07/19 13:37:28 art Exp $	*/
d1083 1
a1083 1
	kn->kn_hook = (caddr_t)dev;
d1095 1
a1095 1
	dev_t dev = (dev_t)kn->kn_hook;
d1106 1
a1106 1
	dev_t dev = (dev_t)kn->kn_hook;
d1120 1
a1120 1
	dev_t dev = (dev_t)kn->kn_hook;
d1133 1
a1133 1
	dev_t dev = (dev_t)kn->kn_hook;
@


1.41
log
@Many drivers use a timeout on ttrstrt, make this a generic interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.40 2000/06/05 11:02:51 art Exp $	*/
d73 4
d1056 84
d2026 1
@


1.40
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.39 2000/03/23 17:20:23 art Exp $	*/
d2191 1
@


1.39
log
@Iiieeek! This kludge was almost funny.

Probably something from the stone age. Kill it.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.38 1999/11/25 13:41:31 art Exp $	*/
d2037 1
a2037 1
		    pick->p_stat == SIDL || pick->p_stat == SZOMB ? 0 :
d2090 1
a2090 1
	switch (TESTAB(p1->p_stat == SZOMB, p2->p_stat == SZOMB)) {
@


1.38
log
@Use PAGE_SIZE instead of NBPG.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.37 1999/06/01 08:23:52 art Exp $	*/
a1557 2
			timeout((void (*)__P((void *)))wakeup,
			    (void *)&tp->t_outq, hz);
d1559 1
a1559 1
			tsleep(&tp->t_outq, PZERO - 1, "ttckoutq", 0);
@


1.38.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1558 2
d1561 1
a1561 1
			tsleep(&tp->t_outq, PZERO - 1, "ttckoutq", hz);
@


1.38.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.43 2001/03/02 08:04:04 art Exp $	*/
a72 4
int	filt_ttyread __P((struct knote *kn, long hint));
void 	filt_ttyrdetach __P((struct knote *kn));
int	filt_ttywrite __P((struct knote *kn, long hint));
void 	filt_ttywdetach __P((struct knote *kn));
a1051 84
struct filterops ttyread_filtops =
	{ 1, NULL, filt_ttyrdetach, filt_ttyread };
struct filterops ttywrite_filtops =
	{ 1, NULL, filt_ttywdetach, filt_ttywrite };

int
ttkqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
{
	struct tty *tp = (*cdevsw[major(dev)].d_tty)(dev);
	struct klist *klist;
	int s;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &tp->t_rsel.si_note;
		kn->kn_fop = &ttyread_filtops;
		break;
	case EVFILT_WRITE:
		klist = &tp->t_wsel.si_note;
		kn->kn_fop = &ttywrite_filtops;
		break;
	default:
		return (1);
	}

	kn->kn_hook = (caddr_t)((u_long)dev);

	s = spltty();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}

void
filt_ttyrdetach(struct knote *kn)
{
	dev_t dev = (dev_t)((u_long)kn->kn_hook);
	struct tty *tp = (*cdevsw[major(dev)].d_tty)(dev);
	int s = spltty();

	SLIST_REMOVE(&tp->t_rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_ttyread(struct knote *kn, long hint)
{
	dev_t dev = (dev_t)((u_long)kn->kn_hook);
	struct tty *tp = (*cdevsw[major(dev)].d_tty)(dev);

	kn->kn_data = ttnread(tp);
	if (!ISSET(tp->t_state, CLOCAL) && !ISSET(tp->t_state, TS_CARR_ON)) {
		kn->kn_flags |= EV_EOF;
		return (1);
	}
	return (kn->kn_data > 0);
}

void
filt_ttywdetach(struct knote *kn)
{
	dev_t dev = (dev_t)((u_long)kn->kn_hook);
	struct tty *tp = (*cdevsw[major(dev)].d_tty)(dev);
	int s = spltty();

	SLIST_REMOVE(&tp->t_wsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_ttywrite(kn, hint)
	struct knote *kn;
	long hint;
{
	dev_t dev = (dev_t)((u_long)kn->kn_hook);
	struct tty *tp = (*cdevsw[major(dev)].d_tty)(dev);

	kn->kn_data = tp->t_outq.c_cc;
	return (kn->kn_data <= tp->t_lowat);
}

a1937 1
	KNOTE(&tp->t_rsel.si_note, 0);
d2037 1
a2037 1
		    pick->p_stat == SIDL || P_ZOMBIE(pick) ? 0 :
d2090 1
a2090 1
	switch (TESTAB(P_ZOMBIE(p1), P_ZOMBIE(p2))) {
a2190 1
	timeout_set(&tp->t_rstrt_to, ttrstrt, tp);
@


1.38.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.38.2.2 2001/05/14 22:32:44 niklas Exp $	*/
a60 1
#include <sys/sysctl.h>
a2331 30
}

/*
 * Return tty-related information.
 */
int
sysctl_tty(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case KERN_TTY_TKNIN:
		return (sysctl_rdquad(oldp, oldlenp, newp, tk_nin));
	case KERN_TTY_TKNOUT:
		return (sysctl_rdquad(oldp, oldlenp, newp, tk_nout));
	case KERN_TTY_TKRAWCC:
		return (sysctl_rdquad(oldp, oldlenp, newp, tk_rawcc));
	case KERN_TTY_TKCANCC:
		return (sysctl_rdquad(oldp, oldlenp, newp, tk_cancc));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
@


1.38.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.38.2.3 2001/07/04 10:48:41 niklas Exp $	*/
d83 3
a1411 10
void ttvtimeout(void *);

void
ttvtimeout(void *arg)
{
	struct tty *tp = (struct tty *)arg;

	wakeup(&tp->t_rawq);
}

d1421 5
a1425 2
	struct timeout *stime = NULL;
	struct proc *p = curproc;
d1427 3
a1429 5
	u_char *cc = tp->t_cc;
	struct clist *qp;
	int last_cc = 0;
	long lflag;
	int c;
d1446 2
a1447 4
		    p->p_flag & P_PPWAIT || p->p_pgrp->pg_jobc == 0) {
			error = EIO;
			goto out;
		}
d1451 1
a1451 1
			goto out;
d1458 1
a1458 8
		long t;

		/*
		 * Note - since cc[VTIME] is a u_char, this won't overflow
		 * until we have 32-bit longs and a hz > 8388608.
		 * Hopefully this code and 32-bit longs are obsolete by then.
		 */
		t = cc[VTIME] * hz / 10;
d1466 2
d1474 3
d1482 5
a1486 5
			if (stime == NULL) {
alloc_timer:
				stime = malloc(sizeof(*stime), M_TEMP, M_WAITOK);
				timeout_set(stime, ttvtimeout, tp);
				timeout_add(stime, t);
d1489 5
a1493 1
				timeout_add(stime, t);
d1498 6
a1503 3
			if (stime == NULL) {
				goto alloc_timer;
			}
d1506 11
a1516 1
		if (stime && !timeout_triggered(stime)) {
d1532 1
a1532 2
			error = 0;
			goto out;
d1536 1
a1536 2
			error = EWOULDBLOCK;
			goto out;
d1539 1
a1539 1
		    carrier ? ttyin : ttopen, 0);
d1541 2
a1542 6
		if (stime && timeout_triggered(stime))
			error = EWOULDBLOCK;
		if (cc[VMIN] == 0 && error == EWOULDBLOCK) {
			error = 0;
			goto out;
		}
d1544 1
a1544 1
			goto out;
a1598 6

out:
	if (stime) {
		timeout_del(stime);
		free(stime, M_TEMP);
	}
d1659 2
a1660 2
	struct tty *tp;
	struct uio *uio;
d1663 3
a1665 3
	u_char *cp = NULL;
	int cc, ce;
	struct proc *p;
d1760 8
d1770 1
d1795 8
d1805 1
d1822 1
d1831 1
@


1.38.2.5
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 1
a65 1
#include <uvm/uvm_extern.h>
@


1.38.2.6
log
@Merge in trunk
@
text
@d159 5
a984 1
		SESSHOLD(p->p_session);
@


1.38.2.7
log
@Merge in -current from about a week ago
@
text
@d68 10
a77 10
static int ttnread(struct tty *);
static void ttyblock(struct tty *);
void ttyunblock(struct tty *);
static void ttyecho(int, struct tty *);
static void ttyrubo(struct tty *, int);
static int proc_compare(struct proc *, struct proc *);
int	filt_ttyread(struct knote *kn, long hint);
void 	filt_ttyrdetach(struct knote *kn);
int	filt_ttywrite(struct knote *kn, long hint);
void 	filt_ttywdetach(struct knote *kn);
@


1.38.2.8
log
@Sync the SMP branch with 3.3
@
text
@a61 1
#include <sys/pool.h>
a77 1
int	ttystats_init(void);
a167 2
int64_t tk_cancc, tk_nin, tk_nout, tk_rawcc;

a209 2
	if (tp->t_session)
		SESSRELE(tp->t_session);
a236 1
	int s;
a243 1

a247 1
	s = spltty();
a249 1
	splx(s);
a779 1
		s = spltty();
a780 1
		splx(s);
a979 2
		if (tp->t_session)
			SESSRELE(tp->t_session);
a1101 1
	int s;
a1102 1
	s = spltty();
a1103 1
	splx(s);
a1139 2
	splassert(IPL_TTY);

d1389 2
a1390 1
ttypend(struct tty *tp)
d1393 1
a1393 3
	int c;

	splassert(IPL_TTY);
a1539 1
		error = 0;
d1605 2
a1606 1
ttyunblock(struct tty *tp)
a1609 2
	splassert(IPL_TTY);

a2315 30
struct itty *ttystats;

int
ttystats_init(void)
{
	struct itty *itp;
	struct tty *tp;

	ttystats = malloc(tty_count * sizeof(struct itty),
	    M_SYSCTL, M_WAITOK);
	for (tp = TAILQ_FIRST(&ttylist), itp = ttystats; tp;
	    tp = TAILQ_NEXT(tp, tty_link), itp++) {
		itp->t_dev = tp->t_dev;
		itp->t_rawq_c_cc = tp->t_rawq.c_cc;
		itp->t_canq_c_cc = tp->t_canq.c_cc;
		itp->t_outq_c_cc = tp->t_outq.c_cc;
		itp->t_hiwat = tp->t_hiwat;
		itp->t_lowat = tp->t_lowat;
		itp->t_column = tp->t_column;
		itp->t_state = tp->t_state;
		itp->t_session = tp->t_session;
		if (tp->t_pgrp)
			itp->t_pgrp_pg_id = tp->t_pgrp->pg_id;
		else
			itp->t_pgrp_pg_id = 0;
		itp->t_line = tp->t_line;
	}
	return (0);
}

a2327 2
	int err;

a2339 8
	case KERN_TTY_INFO:
		err = ttystats_init();
		if (err)
			return (err);
		err = sysctl_rdstruct(oldp, oldlenp, newp, ttystats,
		    tty_count * sizeof(struct itty));
		free(ttystats, M_SYSCTL);
		return (err);
@


1.38.2.9
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.38.2.8 2003/03/28 00:41:27 niklas Exp $	*/
d2102 1
a2102 2
		    pick->p_stat == SONPROC ? "running" :
		    pick->p_stat == SRUN ? "runnable" :
@


1.38.2.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.38.2.9 2003/05/15 04:08:02 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.38.2.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a58 1
#include <sys/poll.h>
d848 1
a848 1
		if (!isctty(p, tp) && suser(p, 0))
d1029 1
a1029 1
ttpoll(device, events, p)
d1031 1
a1031 1
	int events;
d1034 2
a1035 2
	struct tty *tp;
	int revents, s;
a1038 1
	revents = 0;
d1040 15
a1054 14
	if (events & (POLLIN | POLLRDNORM)) {
		if (ttnread(tp) > 0 || (!ISSET(tp->t_cflag, CLOCAL) &&
		    !ISSET(tp->t_state, TS_CARR_ON)))
			revents |= events & (POLLIN | POLLRDNORM);
	}
	if (events & (POLLOUT | POLLWRNORM)) {
		if (tp->t_outq.c_cc <= tp->t_lowat)
			revents |= events & (POLLOUT | POLLWRNORM);
	}
	if (revents == 0) {
		if (events & (POLLIN | POLLRDNORM))
			selrecord(p, &tp->t_rsel);
		if (events & (POLLOUT | POLLWRNORM))
			selrecord(p, &tp->t_wsel);
d1057 1
a1057 1
	return (revents);
d1178 2
a1179 2
	    (ISSET(tp->t_state, TS_CARR_ON) || ISSET(tp->t_cflag, CLOCAL)) &&
	    tp->t_oproc) {
d2263 39
a2301 2
 * Allocate a tty structure and its associated buffers, and attach it to the
 * tty list.
a2314 5

	TAILQ_INSERT_TAIL(&ttylist, tp, tty_link);
	++tty_count;
	timeout_set(&tp->t_rstrt_to, ttrstrt, tp);

a2317 1

d2319 4
a2322 1
 * Free a tty structure and its buffers, after removing it from the tty list.
a2327 7

	--tty_count;
#ifdef DIAGNOSTIC
	if (tty_count < 0)
		panic("ttyfree: tty_count < 0");
#endif
	TAILQ_REMOVE(&ttylist, tp, tty_link);
@


1.38.2.12
log
@Merge with the trunk
@
text
@a65 2
#include "pty.h"

d1118 1
a1118 1
	if (!ISSET(tp->t_cflag, CLOCAL) && !ISSET(tp->t_state, TS_CARR_ON)) {
a2373 3
#if NPTY > 0
		return (sysctl_pty(name, namelen, oldp, oldlenp, newp, newlen));
#else
a2374 1
#endif
@


1.37
log
@remove the "ifdef pmap_resident_count" hack and replace it with a macro.
change some &vm->vm_pmap to vm->vm_map.pmap
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.36 1998/03/28 10:03:04 deraadt Exp $	*/
d2034 1
a2034 1
#define	pgtok(a)	(((u_long) ((a) * NBPG) / 1024))
@


1.36
log
@nasty indent
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.35 1998/02/20 14:51:58 niklas Exp $	*/
d2040 1
a2040 6
#ifdef pmap_resident_count
			pgtok(pmap_resident_count(&pick->p_vmspace->vm_pmap))
#else
			pgtok(pick->p_vmspace->vm_rssize)
#endif
			);
@


1.35
log
@Please GCC 2.8's harsher view of good style
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.34 1998/02/03 19:06:26 deraadt Exp $	*/
d763 2
a764 2
			error = ttysleep(tp,
					 &lbolt, TTOPRI | PCATCH, ttybg, 0);
@


1.34
log
@bad types; wileyc@@sekiya.twics.co.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.33 1997/11/13 09:10:57 deraadt Exp $	*/
d903 1
a903 1
			    ISSET(tp->t_lflag, ICANON))
d916 1
d1473 2
a1474 2
				error = ttysleep(tp, &lbolt,
						 TTIPRI | PCATCH, ttybg, 0);
@


1.33
log
@Count characters even when !OPOST and FLUSHO.
Don't output the \r for ONLCR if FLUSHO; mycroft
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.32 1997/11/13 03:56:55 deraadt Exp $	*/
d1310 1
a1310 1
	register c;
@


1.32
log
@in ttywait(), double check if we need to sleep before sleeping
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.31 1997/11/06 05:58:21 csapuntz Exp $	*/
a601 4
		if (ISSET(tp->t_lflag, FLUSHO))
			return (-1);
		if (putc(c, &tp->t_outq))
			return (c);
d604 2
d642 1
a642 1
		if (putc('\r', &tp->t_outq))
@


1.31
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.30 1997/10/21 07:22:13 niklas Exp $	*/
d1085 8
a1092 3
		SET(tp->t_state, TS_ASLEEP);
		error = ttysleep(tp, &tp->t_outq, TTOPRI | PCATCH, ttyout, 0);
		if (error)
@


1.30
log
@When the input queues are flushed on a blocked tty, make sure to unblock
it, if it's currently in a blocked state due to input flow control.  This
was typically seen with drivers implementing th t_hwiflow function, and
starting of ppp (line discipline changes flushes the input queue).
Independently discovered and fixed slightly different than NetBSD PR#4227.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.29 1997/10/06 20:20:04 deraadt Exp $	*/
d816 1
a816 1
			VOP_LOCK(nid.ni_vp);
d818 1
a818 1
			VOP_UNLOCK(nid.ni_vp);
@


1.29
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.27 1997/03/26 18:03:57 deraadt Exp $	*/
d69 1
d1125 1
d1503 14
a1516 1
	if (ISSET(tp->t_state, TS_TBLOCK) && tp->t_rawq.c_cc < TTYHOG/5) {
a1527 2
	splx(s);
	return (error);
@


1.28
log
@VFS Lite2 Changes
@
text
@d815 1
a815 1
			vn_lock(nid.ni_vp, LK_EXCLUSIVE | LK_RETRY, p);
d817 1
a817 1
			VOP_UNLOCK(nid.ni_vp, 0, p);
@


1.27
log
@proper english
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.26 1997/01/12 09:08:27 tholo Exp $	*/
d815 1
a815 1
			VOP_LOCK(nid.ni_vp);
d817 1
a817 1
			VOP_UNLOCK(nid.ni_vp);
@


1.26
log
@Be more Posixly correct; from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.25 1997/01/05 11:09:02 niklas Exp $	*/
d242 1
a242 1
	 * If receiver is not enable, drop it.
@


1.25
log
@Remove lots of timer_state structs as they just ate memory and only a few was
ever used.  Now a single state is kept for net, tty and disk events resp.
Also, call the randomness from disk_unbusy instead of biodone, as biodone
gets a lot of virtual events (from virtual filesystems etc), and as a bonus:
feed xfer time and size into the entropy pool too.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.24 1996/12/19 07:54:06 tholo Exp $	*/
d223 1
a223 1
#define	TTBREAKC(c)							\
d225 1
a225 1
	(c) == cc[VEOL2]) && (c) != _POSIX_VDISABLE))
d271 1
a271 1
				goto endcase;
d273 4
a276 4
			if (ISSET(iflag, BRKINT) &&
			    ISSET(lflag, ISIG) &&
			    (cc[VINTR] != _POSIX_VDISABLE))
				c = cc[VINTR];
d469 1
a469 1
		if (CCEQ(cc[VWERASE], c)) {
d509 1
a509 1
		if (CCEQ(cc[VREPRINT], c)) {
d516 1
a516 1
		if (CCEQ(cc[VSTATUS], c)) {
d545 1
a545 1
		if (TTBREAKC(c)) {
d758 1
a758 1
		    p->p_pgrp->pg_jobc && (p->p_flag & P_PPWAIT) == 0 &&
d761 2
d1285 2
a1286 1
		if (!ISSET(tp->t_cflag, CLOCAL)) {
d1289 1
d1463 2
a1464 1
		if (CCEQ(cc[VDSUSP], c) && ISSET(lflag, ISIG)) {
d1492 1
a1492 1
		if (ISSET(lflag, ICANON) && TTBREAKC(c))
d1598 5
a1602 2
	    (p->p_sigmask & sigmask(SIGTTOU)) == 0 &&
	     p->p_pgrp->pg_jobc) {
@


1.24
log
@Really set column to 0 when outputting a carriage return...
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.23 1996/12/17 19:19:33 tholo Exp $	*/
d240 1
a240 1
	add_tty_randomness(tp->t_dev, c);
@


1.23
log
@Fix oversight in column handling with OCRNL enabled
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.22 1996/12/17 19:15:24 tholo Exp $	*/
d645 1
a645 1
		col = 0;
@


1.22
log
@Reset output column when outputting \r with ONLCR
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.21 1996/12/16 20:04:54 tholo Exp $	*/
d696 1
a696 1
		if (ISSET(tp->t_oflag, ONLRET))
@


1.21
log
@Implement more tty flags for better portability from other systems:

	XCASE - canonical input/output processing
	IUCLC - translate uppercase to lowercase on input
	OLCUC - translate lowercase to uppercase on output
	OCRNL - translate carriage return to newline on output
	ONOCR - do not output carriage return at column 0
	ONLRET - newline performs carriage return function

In addition the tty compatibility interface supports LCASE properly.

Look at termios(4) for a more complete description of the above flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.20 1996/12/08 14:25:48 niklas Exp $	*/
d645 1
@


1.20
log
@-Wcast-qual happiness
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.19 1996/11/11 04:28:16 tholo Exp $	*/
d161 6
d406 33
d597 1
a597 1
	register int col, notout, s;
d637 2
a638 1
	 * translate newline into "\r\n".
d646 35
d695 3
@


1.19
log
@Flush input and output in receipt of break (unless break is ignored)
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.18 1996/11/09 18:55:45 tholo Exp $	*/
d109 1
a109 1
char const char_type[] = {
d1560 2
a1561 2
				ce = cc - scanc((u_int)cc, cp,
				   (u_char *)char_type, CCLASSMASK);
@


1.18
log
@Implement CREAD
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.17 1996/11/09 18:46:54 tholo Exp $	*/
d266 2
a267 1
			else if (ISSET(iflag, BRKINT) &&
@


1.17
log
@Use passed-in process, not curproc to determine if the process is in the
background
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.16 1996/11/06 08:37:39 deraadt Exp $	*/
d235 5
@


1.16
log
@0377 handling in ISTRIP/PARMRK mode
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.15 1996/11/05 04:49:16 tholo Exp $	*/
d672 1
a672 1
		while (isbackground(curproc, tp) &&
@


1.15
log
@Add more cases that should generate SIGTTOU
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.14 1996/11/05 04:42:30 tholo Exp $	*/
d267 2
a268 2
		} else if ((ISSET(error, TTY_PE) &&
			    ISSET(iflag, INPCK)) || ISSET(error, TTY_FE)) {
d273 2
a274 1
				(void)putc(0 | TTY_QUOTE, &tp->t_rawq);
d281 3
@


1.14
log
@Correct error returns from tcsetpgrp() aka ioctl(, TIOCSPGRP, )
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.13 1996/11/04 09:00:09 deraadt Exp $	*/
d645 3
@


1.13
log
@support _POSIX_VDISABLE for VEOF and VEOL too
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.12 1996/11/04 03:28:07 deraadt Exp $	*/
d899 3
a901 1
		else if (pgrp == NULL || pgrp->pg_session != p->p_session)
@


1.12
log
@If VMIN=0, and timer>0 and expires, read should return 0
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.10 1996/08/29 07:46:35 deraadt Exp $	*/
d218 2
a219 2
	((c) == '\n' || ((c) == cc[VEOF] ||				\
	(c) == cc[VEOL] || (((c) == cc[VEOL2]) && (c) != _POSIX_VDISABLE)))
@


1.11
log
@random device is permanent now.
@
text
@d1348 2
@


1.10
log
@rnd -> random
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.9 1996/08/01 14:17:20 mickey Exp $	*/
a64 3

#include "random.h"
#if NRANDOM > 0
a65 1
#endif
a233 1
#if NRANDOM > 0
a234 1
#endif
@


1.9
log
@xconsole was broken after last patch (UCONSOLE zap).
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.8 1996/07/31 18:34:36 deraadt Exp $	*/
d66 2
a67 2
#include "rnd.h"
#if NRND
d238 1
a238 1
#if NRND
@


1.8
log
@TIOCCONS must be able to VOP_ACCESS() /dev/console to succeed; fixes DOS attack
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.7 1996/06/17 05:25:03 downsj Exp $	*/
d714 2
a715 11
		struct nameidata nid;

		/* ensure user can open the real console */
		NDINIT(&nid, LOOKUP, FOLLOW, UIO_SYSSPACE, "/dev/console", p);
		error = namei(&nid);
		if (error)
			return (error);
		error = VOP_ACCESS(nid.ni_vp, VREAD, p->p_ucred, p);
		vrele(nid.ni_vp);
		if (error)
			return (error);
d717 1
a717 2
		if (*(int *)data) {
			if (constty && constty != tp &&
d721 13
@


1.7
log
@Change from my, umm, BSD/OS tree: allow root to run TIOCGPGRP on anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.6 1996/06/10 07:26:22 deraadt Exp $	*/
d62 2
d713 13
a725 1
	case TIOCCONS:			/* become virtual console */
a730 4
#ifndef	UCONSOLE
			if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
				return (error);
#endif
d735 1
@


1.6
log
@tty_init/attach/detach()
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.4 1996/04/21 22:27:28 deraadt Exp $	*/
d742 1
a742 1
		if (!isctty(p, tp))
@


1.5
log
@Supply randomness source for the rnd device.
@
text
@d2 1
a2 1
/*	$NetBSD: tty.c,v 1.68 1996/03/29 01:55:12 christos Exp $	*/
d163 3
d2040 48
d2107 3
d2113 1
a2113 1
struct tty *tp;
d2115 1
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.c,v 1.3 1996/03/03 17:20:09 niklas Exp $	*/
d64 5
d233 3
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: tty.c,v 1.66 1996/02/09 19:00:38 christos Exp $	*/
d1882 1
a1882 1
		ttyprintf(tp, "%d.%02du ", utime.tv_sec,
d1891 1
a1891 1
		ttyprintf(tp, "%d.%02ds ", stime.tv_sec,
d1894 1
a1894 1
#define	pgtok(a)	(((a) * NBPG) / 1024)
d1897 1
a1897 1
		ttyprintf(tp, "%d%% %dk\n",
@


1.2
log
@from netbsd; Correct test for ECHONL (from der Mouse; PR#1922).
@
text
@d1 2
a2 1
/*	$NetBSD: tty.c,v 1.64 1996/01/10 20:52:27 pk Exp $	*/
d59 2
d64 5
a68 5
static int	proc_compare __P((struct proc *p1, struct proc *p2));
static int	ttnread __P((struct tty *));
static void	ttyblock __P((struct tty *tp));
static void	ttyecho __P((int, struct tty *tp));
static void	ttyrubo __P((struct tty *, int));
d155 1
a155 1
#define	CLR(t, f)	(t) &= ~(f)
d173 1
a173 2
#if defined(COMPAT_43) || defined(COMPAT_SUNOS) || defined(COMPAT_SVR4) || \
    defined(COMPAT_FREEBSD)
d213 1
a213 1
	(c) == cc[VEOL] || (c) == cc[VEOL2]) && (c) != _POSIX_VDISABLE)
d226 1
a226 1
	int i, err;
d249 1
a249 1
	if (err = (ISSET(c, TTY_ERRORMASK))) {
d251 1
a251 1
		if (ISSET(err, TTY_FE) && !c) {	/* Break. */
d260 2
a261 2
		} else if (ISSET(err, TTY_PE) &&
		    ISSET(iflag, INPCK) || ISSET(err, TTY_FE)) {
d648 1
a648 2
#if defined(COMPAT_43) || defined(COMPAT_SUNOS) || defined(COMPAT_SVR4) || \
    defined(COMPAT_FREEBSD)
d663 3
a665 2
			if (error = ttysleep(tp,
			    &lbolt, TTOPRI | PCATCH, ttybg, 0))
d707 1
a707 1
			if (error = suser(p->p_ucred, &p->p_acflag))
d715 1
a715 1
		if (error = ttywait(tp))
d757 1
a757 1
			if (error = ttywait(tp)) {
d867 2
a868 2
		    (p->p_session->s_ttyvp || tp->t_session) &&
		    (tp->t_session != p->p_session))
d896 1
a896 2
#if defined(COMPAT_43) || defined(COMPAT_SUNOS) || defined(COMPAT_SVR4) || \
    defined(COMPAT_FREEBSD)
d920 2
a921 2
		if (nread > 0 || !ISSET(tp->t_cflag, CLOCAL) &&
		    !ISSET(tp->t_state, TS_CARR_ON))
d970 2
a971 2
		if (error = ttysleep(tp,
		    &tp->t_outq, TTOPRI | PCATCH, ttyout, 0))
d1050 3
a1052 3
	if (total >= TTYHOG / 2 &&
	    !ISSET(tp->t_state, TS_TBLOCK) &&
	    !ISSET(tp->t_lflag, ICANON) || tp->t_canq.c_cc > 0) {
d1216 1
a1216 1
	int has_stime = 0, last_cc;
d1237 2
a1238 1
		if (error = ttysleep(tp, &lbolt, TTIPRI | PCATCH, ttybg, 0))
d1347 3
a1349 2
				if (error = ttysleep(tp,
				    &lbolt, TTIPRI | PCATCH, ttybg, 0))
d1439 1
a1439 1
	register u_char *cp;
d1481 2
a1482 1
		if (error = ttysleep(tp, &lbolt, TTIPRI | PCATCH, ttybg, 0))
d1775 2
a1776 2
	if (ISSET(tp->t_lflag, ECHOCTL) &&
	    (ISSET(c, TTY_CHARMASK) <= 037 && c != '\t' && c != '\n' ||
d1896 1
a1896 1
		tmp = pick->p_pctcpu * 10000 + FSCALE / 2 >> FSHIFT;
d2023 1
a2023 1
	if (error = tsleep(chan, pri, wmesg, timo))
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: tty.c,v 1.63 1995/10/10 01:26:57 mycroft Exp $	*/
d1768 1
a1768 1
	    (!ISSET(tp->t_lflag, ECHONL) || c == '\n')) ||
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
