head	1.271;
access;
symbols
	OPENBSD_6_1_BASE:1.271
	OPENBSD_6_0:1.263.0.2
	OPENBSD_6_0_BASE:1.263
	OPENBSD_5_9:1.251.0.2
	OPENBSD_5_9_BASE:1.251
	OPENBSD_5_8:1.222.0.4
	OPENBSD_5_8_BASE:1.222
	OPENBSD_5_7:1.216.0.2
	OPENBSD_5_7_BASE:1.216
	OPENBSD_5_6:1.208.0.4
	OPENBSD_5_6_BASE:1.208
	OPENBSD_5_5:1.202.0.4
	OPENBSD_5_5_BASE:1.202
	OPENBSD_5_4:1.193.0.2
	OPENBSD_5_4_BASE:1.193
	OPENBSD_5_3:1.190.0.2
	OPENBSD_5_3_BASE:1.190
	OPENBSD_5_2:1.187.0.2
	OPENBSD_5_2_BASE:1.187
	OPENBSD_5_1_BASE:1.180
	OPENBSD_5_1:1.180.0.2
	OPENBSD_5_0:1.178.0.2
	OPENBSD_5_0_BASE:1.178
	OPENBSD_4_9:1.165.0.2
	OPENBSD_4_9_BASE:1.165
	OPENBSD_4_8:1.163.0.2
	OPENBSD_4_8_BASE:1.163
	OPENBSD_4_7:1.159.0.2
	OPENBSD_4_7_BASE:1.159
	OPENBSD_4_6:1.155.0.4
	OPENBSD_4_6_BASE:1.155
	OPENBSD_4_5:1.152.0.2
	OPENBSD_4_5_BASE:1.152
	OPENBSD_4_4:1.148.0.2
	OPENBSD_4_4_BASE:1.148
	OPENBSD_4_3:1.145.0.2
	OPENBSD_4_3_BASE:1.145
	OPENBSD_4_2:1.141.0.2
	OPENBSD_4_2_BASE:1.141
	OPENBSD_4_1:1.139.0.2
	OPENBSD_4_1_BASE:1.139
	OPENBSD_4_0:1.137.0.2
	OPENBSD_4_0_BASE:1.137
	OPENBSD_3_9:1.131.0.2
	OPENBSD_3_9_BASE:1.131
	OPENBSD_3_8:1.126.0.2
	OPENBSD_3_8_BASE:1.126
	OPENBSD_3_7:1.119.0.2
	OPENBSD_3_7_BASE:1.119
	OPENBSD_3_6:1.117.0.2
	OPENBSD_3_6_BASE:1.117
	SMP_SYNC_A:1.111
	SMP_SYNC_B:1.111
	OPENBSD_3_5:1.108.0.2
	OPENBSD_3_5_BASE:1.108
	OPENBSD_3_4:1.107.0.2
	OPENBSD_3_4_BASE:1.107
	UBC_SYNC_A:1.103
	OPENBSD_3_3:1.98.0.4
	OPENBSD_3_3_BASE:1.98
	OPENBSD_3_2:1.98.0.2
	OPENBSD_3_2_BASE:1.98
	OPENBSD_3_1:1.95.0.2
	OPENBSD_3_1_BASE:1.95
	UBC_SYNC_B:1.98
	UBC:1.83.0.2
	UBC_BASE:1.83
	OPENBSD_3_0:1.80.0.2
	OPENBSD_3_0_BASE:1.80
	OPENBSD_2_9_BASE:1.70
	OPENBSD_2_9:1.70.0.2
	OPENBSD_2_8:1.65.0.4
	OPENBSD_2_8_BASE:1.65
	OPENBSD_2_7:1.65.0.2
	OPENBSD_2_7_BASE:1.65
	SMP:1.62.0.2
	SMP_BASE:1.62
	kame_19991208:1.60
	OPENBSD_2_6:1.59.0.2
	OPENBSD_2_6_BASE:1.59
	OPENBSD_2_5:1.56.0.2
	OPENBSD_2_5_BASE:1.56
	OPENBSD_2_4:1.46.0.2
	OPENBSD_2_4_BASE:1.46
	OPENBSD_2_3:1.40.0.2
	OPENBSD_2_3_BASE:1.40
	OPENBSD_2_2:1.27.0.2
	OPENBSD_2_2_BASE:1.27
	OPENBSD_2_1:1.25.0.2
	OPENBSD_2_1_BASE:1.25
	OPENBSD_2_0:1.15.0.2
	OPENBSD_2_0_BASE:1.15
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.271
date	2017.02.15.03.36.58;	author guenther;	state Exp;
branches;
next	1.270;
commitid	SFXrYyJvyRJC2Fch;

1.270
date	2017.02.11.19.51.06;	author guenther;	state Exp;
branches;
next	1.269;
commitid	dp1qF9REvzwtzfTw;

1.269
date	2017.01.23.22.34.10;	author deraadt;	state Exp;
branches;
next	1.268;
commitid	99bh3dETE3sAQhkj;

1.268
date	2017.01.15.23.18.05;	author bluhm;	state Exp;
branches;
next	1.267;
commitid	0SyY1JeavaPEHaok;

1.267
date	2017.01.10.20.13.17;	author bluhm;	state Exp;
branches;
next	1.266;
commitid	vtGLaeQRpGKx8qFo;

1.266
date	2017.01.10.19.48.32;	author bluhm;	state Exp;
branches;
next	1.265;
commitid	nzxicVheAaFpfTKW;

1.265
date	2016.09.10.16.53.30;	author natano;	state Exp;
branches;
next	1.264;
commitid	OheBN9SCINTycSAi;

1.264
date	2016.09.07.17.30.12;	author natano;	state Exp;
branches;
next	1.263;
commitid	D0avTYSlvEmEjLyB;

1.263
date	2016.07.14.15.39.40;	author deraadt;	state Exp;
branches;
next	1.262;
commitid	OxTNcya21jtGbyEn;

1.262
date	2016.07.12.20.53.04;	author millert;	state Exp;
branches;
next	1.261;
commitid	A4r1TwSioTgWFcHv;

1.261
date	2016.07.06.19.26.35;	author millert;	state Exp;
branches;
next	1.260;
commitid	sMNNMIa1A13iONHY;

1.260
date	2016.07.03.04.36.08;	author semarie;	state Exp;
branches;
next	1.259;
commitid	sZFqhpjiVWq1IcpS;

1.259
date	2016.06.27.04.26.41;	author semarie;	state Exp;
branches;
next	1.258;
commitid	YdoXx2ZyHgouolTX;

1.258
date	2016.06.27.04.14.38;	author semarie;	state Exp;
branches;
next	1.257;
commitid	bvgQ8k1FXWGUPfPl;

1.257
date	2016.06.26.14.27.14;	author semarie;	state Exp;
branches;
next	1.256;
commitid	6hy5JDkOeUpSvBMc;

1.256
date	2016.06.01.22.54.45;	author millert;	state Exp;
branches;
next	1.255;
commitid	ztPr6qRv8lWuiQng;

1.255
date	2016.05.27.19.45.04;	author deraadt;	state Exp;
branches;
next	1.254;
commitid	nQEqvpt7rKDi6fz0;

1.254
date	2016.05.15.05.04.28;	author semarie;	state Exp;
branches;
next	1.253;
commitid	8tdCXjy9WyUFioOZ;

1.253
date	2016.03.27.11.39.37;	author bluhm;	state Exp;
branches;
next	1.252;
commitid	C0IKsjKoZxFScK3M;

1.252
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.251;
commitid	gAjwyca5TfuoJAhn;

1.251
date	2016.01.06.17.59.30;	author tedu;	state Exp;
branches;
next	1.250;
commitid	vtbNHxTkwTC4OW91;

1.250
date	2016.01.02.00.24.16;	author deraadt;	state Exp;
branches;
next	1.249;
commitid	p4uEnUfNtF3tqlyi;

1.249
date	2015.12.16.15.52.51;	author semarie;	state Exp;
branches;
next	1.248;
commitid	9DwgBFiJ4EOJMa7U;

1.248
date	2015.12.16.08.27.32;	author semarie;	state Exp;
branches;
next	1.247;
commitid	MqPT11x46Aeq2eiI;

1.247
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.246;
commitid	Cl55DD2g2xm69E6W;

1.246
date	2015.12.04.07.33.05;	author deraadt;	state Exp;
branches;
next	1.245;
commitid	FCPi32lyPV1UcS6e;

1.245
date	2015.11.20.07.11.52;	author deraadt;	state Exp;
branches;
next	1.244;
commitid	rSZnfzPYBavVnmaH;

1.244
date	2015.11.20.06.29.56;	author jsg;	state Exp;
branches;
next	1.243;
commitid	DYGnwC02VxsOasxU;

1.243
date	2015.11.18.06.57.24;	author deraadt;	state Exp;
branches;
next	1.242;
commitid	vKLXsxJUFVLzOAOb;

1.242
date	2015.11.16.18.29.35;	author deraadt;	state Exp;
branches;
next	1.241;
commitid	2cmB9LfHejDl4UoQ;

1.241
date	2015.11.16.18.25.18;	author deraadt;	state Exp;
branches;
next	1.240;
commitid	RK8KWmucfXbJMP5B;

1.240
date	2015.11.14.22.23.22;	author deraadt;	state Exp;
branches;
next	1.239;
commitid	tkunitxnSEUu2zs1;

1.239
date	2015.11.02.16.31.55;	author semarie;	state Exp;
branches;
next	1.238;
commitid	PyvdcQVr9G4daVnG;

1.238
date	2015.11.01.19.03.33;	author semarie;	state Exp;
branches;
next	1.237;
commitid	VKRkUfXZQNJ8UQeY;

1.237
date	2015.10.28.18.41.16;	author deraadt;	state Exp;
branches;
next	1.236;
commitid	FaFCCPFjWNYTRA8L;

1.236
date	2015.10.28.14.17.52;	author semarie;	state Exp;
branches;
next	1.235;
commitid	yoRkkdI7D0TLJnTK;

1.235
date	2015.10.28.14.07.58;	author semarie;	state Exp;
branches;
next	1.234;
commitid	W9UmY0OlrfwaLfRF;

1.234
date	2015.10.28.11.18.58;	author deraadt;	state Exp;
branches;
next	1.233;
commitid	0CAMD9icFtRoLcGq;

1.233
date	2015.10.25.20.39.54;	author deraadt;	state Exp;
branches;
next	1.232;
commitid	SIwCBDJKKae61tEi;

1.232
date	2015.10.20.06.40.00;	author semarie;	state Exp;
branches;
next	1.231;
commitid	cZnfuIvm8DKmhV1I;

1.231
date	2015.10.16.13.37.43;	author millert;	state Exp;
branches;
next	1.230;
commitid	H99PcNtHGZMrNl2r;

1.230
date	2015.10.14.14.24.03;	author deraadt;	state Exp;
branches;
next	1.229;
commitid	fihBIqC2Qdmk6hpM;

1.229
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.228;
commitid	av6ZVErLSWkVP5Zz;

1.228
date	2015.10.06.14.39.07;	author deraadt;	state Exp;
branches;
next	1.227;
commitid	z0sHmlifEUHqed1t;

1.227
date	2015.08.31.16.13.11;	author deraadt;	state Exp;
branches;
next	1.226;
commitid	0APotwkjGNMGKTxs;

1.226
date	2015.08.31.16.07.12;	author deraadt;	state Exp;
branches;
next	1.225;
commitid	xIsp4QnIJaN0EFZ1;

1.225
date	2015.08.31.00.45.09;	author deraadt;	state Exp;
branches;
next	1.224;
commitid	VQ4lRF8TTy34XbyF;

1.224
date	2015.08.30.05.38.38;	author deraadt;	state Exp;
branches;
next	1.223;
commitid	9xFH3Y1MpDqSyvpY;

1.223
date	2015.08.22.20.18.50;	author deraadt;	state Exp;
branches;
next	1.222;
commitid	6NDuzTPjBp2GqkfQ;

1.222
date	2015.07.20.21.31.57;	author deraadt;	state Exp;
branches;
next	1.221;
commitid	FPsn4WttAlQkJPOb;

1.221
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	1.220;
commitid	CJwjm9NDWu6nJ6ES;

1.220
date	2015.05.07.08.53.33;	author mpi;	state Exp;
branches;
next	1.219;
commitid	c9ymkCbPubGplOgk;

1.219
date	2015.04.30.09.20.51;	author mpi;	state Exp;
branches;
next	1.218;
commitid	ngMdImGL4WWFm6gy;

1.218
date	2015.04.17.04.43.20;	author guenther;	state Exp;
branches;
next	1.217;
commitid	zOwbm07fp3gPB2qr;

1.217
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.216;
commitid	p4LJxGKbi0BU2cG6;

1.216
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.215;
commitid	P6Av4XGqOi3rFasL;

1.215
date	2014.12.08.20.56.11;	author guenther;	state Exp;
branches;
next	1.214;
commitid	W5ntmn0jpthTCbn0;

1.214
date	2014.11.14.23.26.48;	author tedu;	state Exp;
branches;
next	1.213;
commitid	Xw9eD6Y0JOIFIwDy;

1.213
date	2014.11.03.21.28.35;	author tedu;	state Exp;
branches;
next	1.212;
commitid	EkuwmBeHv2Tqmdnx;

1.212
date	2014.11.03.03.08.00;	author deraadt;	state Exp;
branches;
next	1.211;
commitid	3SGDR5EjcwE01W8S;

1.211
date	2014.10.22.21.43.16;	author millert;	state Exp;
branches;
next	1.210;
commitid	k1y32GFQr1q8OfHn;

1.210
date	2014.10.13.15.23.34;	author millert;	state Exp;
branches;
next	1.209;
commitid	9mJ5N6DCPU4sge7J;

1.209
date	2014.09.18.02.15.04;	author uebayasi;	state Exp;
branches;
next	1.208;
commitid	jXXUqzREIi58BEkt;

1.208
date	2014.07.12.18.43.32;	author tedu;	state Exp;
branches;
next	1.207;
commitid	QlVV51SZgNFxsXxC;

1.207
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.206;
commitid	EF98ch02VpFassUi;

1.206
date	2014.05.25.18.46.44;	author guenther;	state Exp;
branches;
next	1.205;

1.205
date	2014.04.12.14.18.11;	author espie;	state Exp;
branches;
next	1.204;

1.204
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.203;

1.203
date	2014.03.08.22.54.30;	author tedu;	state Exp;
branches;
next	1.202;

1.202
date	2014.01.21.01.48.45;	author tedu;	state Exp;
branches;
next	1.201;

1.201
date	2014.01.20.03.33.29;	author guenther;	state Exp;
branches;
next	1.200;

1.200
date	2013.12.01.16.40.56;	author krw;	state Exp;
branches;
next	1.199;

1.199
date	2013.10.25.14.56.52;	author millert;	state Exp;
branches;
next	1.198;

1.198
date	2013.09.14.01.35.01;	author guenther;	state Exp;
branches;
next	1.197;

1.197
date	2013.08.16.08.33.20;	author guenther;	state Exp;
branches;
next	1.196;

1.196
date	2013.08.14.05.26.14;	author guenther;	state Exp;
branches;
next	1.195;

1.195
date	2013.08.13.05.52.24;	author guenther;	state Exp;
branches;
next	1.194;

1.194
date	2013.08.08.20.19.13;	author guenther;	state Exp;
branches;
next	1.193;

1.193
date	2013.06.05.01.26.00;	author guenther;	state Exp;
branches;
next	1.192;

1.192
date	2013.04.15.15.32.19;	author jsing;	state Exp;
branches;
next	1.191;

1.191
date	2013.03.28.02.39.17;	author guenther;	state Exp;
branches;
next	1.190;

1.190
date	2013.01.30.18.21.08;	author matthew;	state Exp;
branches;
next	1.189;

1.189
date	2012.09.10.11.10.59;	author jsing;	state Exp;
branches;
next	1.188;

1.188
date	2012.09.10.02.21.56;	author deraadt;	state Exp;
branches;
next	1.187;

1.187
date	2012.07.11.23.07.19;	author guenther;	state Exp;
branches;
next	1.186;

1.186
date	2012.07.10.17.00.55;	author guenther;	state Exp;
branches;
next	1.185;

1.185
date	2012.07.08.10.55.10;	author guenther;	state Exp;
branches;
next	1.184;

1.184
date	2012.05.21.16.41.03;	author matthew;	state Exp;
branches;
next	1.183;

1.183
date	2012.05.14.02.41.13;	author guenther;	state Exp;
branches;
next	1.182;

1.182
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.181;

1.181
date	2012.03.19.09.05.39;	author guenther;	state Exp;
branches;
next	1.180;

1.180
date	2011.11.06.15.09.02;	author guenther;	state Exp;
branches;
next	1.179;

1.179
date	2011.11.05.15.47.37;	author guenther;	state Exp;
branches;
next	1.178;

1.178
date	2011.07.25.19.51.24;	author miod;	state Exp;
branches;
next	1.177;

1.177
date	2011.07.18.00.16.54;	author matthew;	state Exp;
branches;
next	1.176;

1.176
date	2011.07.14.18.03.06;	author matthew;	state Exp;
branches;
next	1.175;

1.175
date	2011.07.12.23.36.40;	author matthew;	state Exp;
branches;
next	1.174;

1.174
date	2011.07.09.05.46.26;	author matthew;	state Exp;
branches;
next	1.173;

1.173
date	2011.07.09.05.31.26;	author matthew;	state Exp;
branches;
next	1.172;

1.172
date	2011.07.09.01.28.48;	author matthew;	state Exp;
branches;
next	1.171;

1.171
date	2011.07.08.19.28.38;	author otto;	state Exp;
branches;
next	1.170;

1.170
date	2011.07.08.04.23.24;	author matthew;	state Exp;
branches;
next	1.169;

1.169
date	2011.07.07.23.45.00;	author matthew;	state Exp;
branches;
next	1.168;

1.168
date	2011.07.06.04.49.13;	author guenther;	state Exp;
branches;
next	1.167;

1.167
date	2011.07.06.04.41.16;	author matthew;	state Exp;
branches;
next	1.166;

1.166
date	2011.07.05.21.38.58;	author matthew;	state Exp;
branches;
next	1.165;

1.165
date	2010.10.28.15.02.41;	author millert;	state Exp;
branches;
next	1.164;

1.164
date	2010.10.27.17.11.08;	author deraadt;	state Exp;
branches;
next	1.163;

1.163
date	2010.07.01.22.03.32;	author krw;	state Exp;
branches;
next	1.162;

1.162
date	2010.07.01.17.31.22;	author krw;	state Exp;
branches;
next	1.161;

1.161
date	2010.06.29.17.13.59;	author tedu;	state Exp;
branches;
next	1.160;

1.160
date	2010.06.29.04.07.39;	author tedu;	state Exp;
branches;
next	1.159;

1.159
date	2009.10.31.12.00.08;	author fgsch;	state Exp;
branches;
next	1.158;

1.158
date	2009.09.08.17.41.20;	author miod;	state Exp;
branches;
next	1.157;

1.157
date	2009.09.02.19.05.44;	author fgsch;	state Exp;
branches;
next	1.156;

1.156
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.155;

1.155
date	2009.06.04.00.24.02;	author blambert;	state Exp;
branches;
next	1.154;

1.154
date	2009.06.03.03.57.20;	author blambert;	state Exp;
branches;
next	1.153;

1.153
date	2009.06.02.03.04.09;	author blambert;	state Exp;
branches;
next	1.152;

1.152
date	2008.11.11.02.11.25;	author tedu;	state Exp;
branches;
next	1.151;

1.151
date	2008.11.01.20.34.09;	author deraadt;	state Exp;
branches;
next	1.150;

1.150
date	2008.10.31.16.49.17;	author deraadt;	state Exp;
branches;
next	1.149;

1.149
date	2008.08.08.19.49.09;	author thib;	state Exp;
branches;
next	1.148;

1.148
date	2008.07.28.14.21.17;	author thib;	state Exp;
branches;
next	1.147;

1.147
date	2008.06.13.01.59.45;	author rainer;	state Exp;
branches;
next	1.146;

1.146
date	2008.05.22.17.04.59;	author thib;	state Exp;
branches;
next	1.145;

1.145
date	2008.01.22.14.33.40;	author millert;	state Exp;
branches;
next	1.144;

1.144
date	2007.11.28.16.56.46;	author tedu;	state Exp;
branches;
next	1.143;

1.143
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.142;

1.142
date	2007.08.30.12.35.27;	author thib;	state Exp;
branches;
next	1.141;

1.141
date	2007.08.06.16.58.26;	author millert;	state Exp;
branches;
next	1.140;

1.140
date	2007.06.14.20.36.34;	author otto;	state Exp;
branches;
next	1.139;

1.139
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.138;

1.138
date	2006.11.24.17.04.20;	author art;	state Exp;
branches;
next	1.137;

1.137
date	2006.06.25.15.01.54;	author sturm;	state Exp;
branches;
next	1.136;

1.136
date	2006.06.14.20.01.50;	author sturm;	state Exp;
branches;
next	1.135;

1.135
date	2006.05.27.17.37.42;	author sturm;	state Exp;
branches;
next	1.134;

1.134
date	2006.04.30.14.20.07;	author sturm;	state Exp;
branches;
next	1.133;

1.133
date	2006.04.19.11.55.55;	author pedro;	state Exp;
branches;
next	1.132;

1.132
date	2006.03.26.17.47.10;	author mickey;	state Exp;
branches;
next	1.131;

1.131
date	2006.01.07.07.39.55;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2005.11.30.10.35.08;	author pedro;	state Exp;
branches;
next	1.129;

1.129
date	2005.11.27.12.37.58;	author pedro;	state Exp;
branches;
next	1.128;

1.128
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.127;

1.127
date	2005.11.08.15.43.44;	author pedro;	state Exp;
branches;
next	1.126;

1.126
date	2005.07.03.20.13.59;	author drahn;	state Exp;
branches;
next	1.125;

1.125
date	2005.06.17.20.39.14;	author millert;	state Exp;
branches;
next	1.124;

1.124
date	2005.05.27.23.44.05;	author marius;	state Exp;
branches;
next	1.123;

1.123
date	2005.05.27.20.20.23;	author pedro;	state Exp;
branches;
next	1.122;

1.122
date	2005.05.27.17.31.47;	author pedro;	state Exp;
branches;
next	1.121;

1.121
date	2005.05.26.00.33.45;	author pedro;	state Exp;
branches;
next	1.120;

1.120
date	2005.05.24.05.34.54;	author pedro;	state Exp;
branches;
next	1.119;

1.119
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.118;

1.118
date	2004.09.16.10.37.41;	author pedro;	state Exp;
branches;
next	1.117;

1.117
date	2004.08.05.04.46.26;	author tedu;	state Exp;
branches;
next	1.116;

1.116
date	2004.07.22.06.13.08;	author tedu;	state Exp;
branches;
next	1.115;

1.115
date	2004.07.18.12.05.07;	author avsm;	state Exp;
branches;
next	1.114;

1.114
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.113;

1.113
date	2004.07.03.18.14.02;	author pedro;	state Exp;
branches;
next	1.112;

1.112
date	2004.06.21.23.50.36;	author tholo;	state Exp;
branches;
next	1.111;

1.111
date	2004.05.14.04.00.33;	author tedu;	state Exp;
branches;
next	1.110;

1.110
date	2004.05.10.22.36.21;	author pedro;	state Exp;
branches;
next	1.109;

1.109
date	2004.04.13.00.15.28;	author tedu;	state Exp;
branches;
next	1.108;

1.108
date	2004.01.06.04.18.18;	author tedu;	state Exp;
branches;
next	1.107;

1.107
date	2003.09.01.18.06.03;	author henning;	state Exp;
branches;
next	1.106;

1.106
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.105;

1.105
date	2003.07.18.16.43.32;	author tedu;	state Exp;
branches;
next	1.104;

1.104
date	2003.06.02.23.28.07;	author millert;	state Exp;
branches;
next	1.103;

1.103
date	2003.05.06.20.52.14;	author tedu;	state Exp;
branches;
next	1.102;

1.102
date	2003.05.05.00.21.52;	author tedu;	state Exp;
branches;
next	1.101;

1.101
date	2003.05.01.21.13.05;	author tedu;	state Exp;
branches;
next	1.100;

1.100
date	2003.04.11.01.48.41;	author tedu;	state Exp;
branches;
next	1.99;

1.99
date	2003.04.10.02.06.00;	author tedu;	state Exp;
branches;
next	1.98;

1.98
date	2002.10.02.21.56.30;	author nordin;	state Exp;
branches;
next	1.97;

1.97
date	2002.08.23.15.39.31;	author art;	state Exp;
branches;
next	1.96;

1.96
date	2002.07.12.14.02.22;	author art;	state Exp;
branches;
next	1.95;

1.95
date	2002.03.14.01.27.06;	author millert;	state Exp;
branches
	1.95.2.1;
next	1.94;

1.94
date	2002.02.22.20.37.45;	author drahn;	state Exp;
branches;
next	1.93;

1.93
date	2002.02.12.18.41.21;	author art;	state Exp;
branches;
next	1.92;

1.92
date	2002.02.08.19.58.03;	author art;	state Exp;
branches;
next	1.91;

1.91
date	2002.02.08.19.47.50;	author art;	state Exp;
branches;
next	1.90;

1.90
date	2002.02.08.18.58.51;	author art;	state Exp;
branches;
next	1.89;

1.89
date	2002.02.08.13.53.28;	author art;	state Exp;
branches;
next	1.88;

1.88
date	2002.02.05.16.02.27;	author art;	state Exp;
branches;
next	1.87;

1.87
date	2002.02.04.11.43.16;	author art;	state Exp;
branches;
next	1.86;

1.86
date	2002.01.21.18.50.45;	author millert;	state Exp;
branches;
next	1.85;

1.85
date	2002.01.18.01.36.29;	author mickey;	state Exp;
branches;
next	1.84;

1.84
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.83;

1.83
date	2001.11.27.05.27.12;	author art;	state Exp;
branches
	1.83.2.1;
next	1.82;

1.82
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2001.10.26.12.03.27;	author art;	state Exp;
branches;
next	1.80;

1.80
date	2001.07.26.20.24.47;	author millert;	state Exp;
branches
	1.80.2.1;
next	1.79;

1.79
date	2001.07.26.02.10.41;	author assar;	state Exp;
branches;
next	1.78;

1.78
date	2001.06.27.04.49.48;	author art;	state Exp;
branches;
next	1.77;

1.77
date	2001.06.22.14.14.11;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2001.05.23.13.15.07;	author art;	state Exp;
branches;
next	1.75;

1.75
date	2001.05.16.17.14.36;	author millert;	state Exp;
branches;
next	1.74;

1.74
date	2001.05.16.05.07.52;	author millert;	state Exp;
branches;
next	1.73;

1.73
date	2001.05.14.15.11.15;	author art;	state Exp;
branches;
next	1.72;

1.72
date	2001.05.14.14.55.48;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2001.05.13.02.40.46;	author millert;	state Exp;
branches;
next	1.70;

1.70
date	2001.04.04.20.19.02;	author gluk;	state Exp;
branches;
next	1.69;

1.69
date	2001.03.16.16.24.57;	author art;	state Exp;
branches;
next	1.68;

1.68
date	2001.02.21.23.24.30;	author csapuntz;	state Exp;
branches;
next	1.67;

1.67
date	2001.02.20.01.50.09;	author assar;	state Exp;
branches;
next	1.66;

1.66
date	2001.02.12.07.03.13;	author fgsch;	state Exp;
branches;
next	1.65;

1.65
date	2000.04.20.06.32.00;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2000.04.15.19.52.48;	author csapuntz;	state Exp;
branches;
next	1.63;

1.63
date	2000.03.03.11.31.43;	author art;	state Exp;
branches;
next	1.62;

1.62
date	2000.02.07.04.55.19;	author assar;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2000.02.01.04.03.14;	author assar;	state Exp;
branches;
next	1.60;

1.60
date	99.12.06.07.28.06;	author art;	state Exp;
branches;
next	1.59;

1.59
date	99.07.30.18.27.47;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	99.07.13.15.17.51;	author provos;	state Exp;
branches;
next	1.57;

1.57
date	99.05.31.17.34.48;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	99.02.26.04.51.17;	author art;	state Exp;
branches;
next	1.55;

1.55
date	99.02.15.16.46.57;	author art;	state Exp;
branches;
next	1.54;

1.54
date	99.02.15.16.41.37;	author art;	state Exp;
branches;
next	1.53;

1.53
date	99.01.19.20.52.47;	author art;	state Exp;
branches;
next	1.52;

1.52
date	99.01.10.22.47.08;	author art;	state Exp;
branches;
next	1.51;

1.51
date	98.12.28.19.56.22;	author art;	state Exp;
branches;
next	1.50;

1.50
date	98.12.23.10.53.06;	author art;	state Exp;
branches;
next	1.49;

1.49
date	98.12.21.13.08.49;	author art;	state Exp;
branches;
next	1.48;

1.48
date	98.12.10.23.48.13;	author art;	state Exp;
branches;
next	1.47;

1.47
date	98.11.12.04.30.01;	author csapuntz;	state Exp;
branches;
next	1.46;

1.46
date	98.09.27.03.23.47;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	98.08.17.23.26.17;	author csapuntz;	state Exp;
branches;
next	1.44;

1.44
date	98.08.17.22.19.06;	author csapuntz;	state Exp;
branches;
next	1.43;

1.43
date	98.07.13.05.43.10;	author csapuntz;	state Exp;
branches;
next	1.42;

1.42
date	98.07.13.02.11.30;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	98.04.25.07.14.47;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	98.04.06.09.00.58;	author niklas;	state Exp;
branches;
next	1.39;

1.39
date	98.03.25.19.44.50;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	98.02.16.21.56.29;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	98.01.09.16.21.55;	author csapuntz;	state Exp;
branches;
next	1.36;

1.36
date	98.01.02.05.42.49;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	97.12.11.03.16.34;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	97.12.09.09.34.36;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	97.11.24.22.42.38;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	97.11.20.07.15.38;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	97.11.18.06.59.59;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	97.11.17.07.46.24;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	97.11.17.06.00.52;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	97.11.06.05.58.29;	author csapuntz;	state Exp;
branches;
next	1.27;

1.27
date	97.10.06.20.20.14;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.10.06.15.12.43;	author csapuntz;	state Exp;
branches;
next	1.25;

1.25
date	97.03.02.09.38.35;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	97.02.26.16.38.20;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	97.02.14.17.20.09;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.02.13.02.45.43;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	97.02.02.00.32.02;	author tholo;	state Exp;
branches;
next	1.20;

1.20
date	97.01.26.05.18.29;	author downsj;	state Exp;
branches;
next	1.19;

1.19
date	97.01.25.00.27.31;	author dm;	state Exp;
branches;
next	1.18;

1.18
date	97.01.02.12.20.40;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	96.10.27.08.02.32;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	96.10.26.07.27.01;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	96.10.04.01.26.48;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.09.24.02.40.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.09.24.02.38.30;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.08.08.06.36.47;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	96.08.08.04.23.03;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	96.08.02.19.59.01;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	96.06.02.16.24.42;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.05.14.18.24.21;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.05.02.13.09.53;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.27.39;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.17.05.09.14;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.02.29.13.38.58;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	95.11.13.04.05.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.09.06.08.38;	author chuck;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.48;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.48;	author deraadt;	state Exp;
branches;
next	;

1.62.2.1
date	2000.03.24.09.09.26;	author niklas;	state Exp;
branches;
next	1.62.2.2;

1.62.2.2
date	2001.05.14.22.32.46;	author niklas;	state Exp;
branches;
next	1.62.2.3;

1.62.2.3
date	2001.07.04.10.48.55;	author niklas;	state Exp;
branches;
next	1.62.2.4;

1.62.2.4
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.62.2.5;

1.62.2.5
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.62.2.6;

1.62.2.6
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.62.2.7;

1.62.2.7
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.62.2.8;

1.62.2.8
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.62.2.9;

1.62.2.9
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.62.2.10;

1.62.2.10
date	2003.05.13.19.21.29;	author ho;	state Exp;
branches;
next	1.62.2.11;

1.62.2.11
date	2003.06.07.11.03.41;	author ho;	state Exp;
branches;
next	1.62.2.12;

1.62.2.12
date	2004.02.19.10.56.39;	author niklas;	state Exp;
branches;
next	1.62.2.13;

1.62.2.13
date	2004.06.05.23.13.03;	author niklas;	state Exp;
branches;
next	;

1.80.2.1
date	2002.10.13.20.56.46;	author miod;	state Exp;
branches;
next	;

1.83.2.1
date	2002.01.31.22.55.41;	author niklas;	state Exp;
branches;
next	1.83.2.2;

1.83.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.83.2.3;

1.83.2.3
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.83.2.4;

1.83.2.4
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;

1.95.2.1
date	2002.10.13.20.54.54;	author miod;	state Exp;
branches;
next	;


desc
@@


1.271
log
@Threads share filedesc, so we can walk allprocess instead of allproc

ok mpi@@ millert@@
@
text
@/*	$OpenBSD: vfs_syscalls.c,v 1.270 2017/02/11 19:51:06 guenther Exp $	*/
/*	$NetBSD: vfs_syscalls.c,v 1.71 1996/04/23 10:29:02 mycroft Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vfs_syscalls.c	8.28 (Berkeley) 12/10/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/filedesc.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/sysctl.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/lock.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/pledge.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/dkio.h>
#include <sys/disklabel.h>
#include <sys/ktrace.h>
#include <sys/unistd.h>
#include <sys/specdev.h>

#include <sys/syscallargs.h>

extern int suid_clear;

static int change_dir(struct nameidata *, struct proc *);

void checkdirs(struct vnode *);

int copyout_statfs(struct statfs *, void *, struct proc *);

int doopenat(struct proc *, int, const char *, int, mode_t, register_t *);
int domknodat(struct proc *, int, const char *, mode_t, dev_t);
int dolinkat(struct proc *, int, const char *, int, const char *, int);
int dosymlinkat(struct proc *, const char *, int, const char *);
int dounlinkat(struct proc *, int, const char *, int);
int dofaccessat(struct proc *, int, const char *, int, int);
int dofstatat(struct proc *, int, const char *, struct stat *, int);
int doreadlinkat(struct proc *, int, const char *, char *, size_t,
    register_t *);
int dochflagsat(struct proc *, int, const char *, u_int, int);
int dovchflags(struct proc *, struct vnode *, u_int);
int dofchmodat(struct proc *, int, const char *, mode_t, int);
int dofchownat(struct proc *, int, const char *, uid_t, gid_t, int);
int dorenameat(struct proc *, int, const char *, int, const char *);
int domkdirat(struct proc *, int, const char *, mode_t);
int doutimensat(struct proc *, int, const char *, struct timespec [2], int);
int dovutimens(struct proc *, struct vnode *, struct timespec [2]);
int dofutimens(struct proc *, int, struct timespec [2]);

/*
 * Virtual File System System Calls
 */

/*
 * Mount a file system.
 */
int
sys_mount(struct proc *p, void *v, register_t *retval)
{
	struct sys_mount_args /* {
		syscallarg(const char *) type;
		syscallarg(const char *) path;
		syscallarg(int) flags;
		syscallarg(void *) data;
	} */ *uap = v;
	struct vnode *vp;
	struct mount *mp;
	int error, mntflag = 0;
	char fstypename[MFSNAMELEN];
	char fspath[MNAMELEN];
	struct nameidata nd;
	struct vfsconf *vfsp;
	int flags = SCARG(uap, flags);

	if ((error = suser(p, 0)))
		return (error);

	/*
	 * Mount points must fit in MNAMELEN, not MAXPATHLEN.
	 */
	error = copyinstr(SCARG(uap, path), fspath, MNAMELEN, NULL);
	if (error)
		return(error);

	/*
	 * Get vnode to be covered
	 */
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_SYSSPACE, fspath, p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if (flags & MNT_UPDATE) {
		if ((vp->v_flag & VROOT) == 0) {
			vput(vp);
			return (EINVAL);
		}
		mp = vp->v_mount;
		vfsp = mp->mnt_vfc;
		mntflag = mp->mnt_flag;
		/*
		 * We only allow the filesystem to be reloaded if it
		 * is currently mounted read-only.
		 */
		if ((flags & MNT_RELOAD) &&
		    ((mp->mnt_flag & MNT_RDONLY) == 0)) {
			vput(vp);
			return (EOPNOTSUPP);	/* Needs translation */
		}

		if ((error = vfs_busy(mp, VB_READ|VB_NOWAIT)) != 0) {
			vput(vp);
			return (error);
		}
		mp->mnt_flag |= flags & (MNT_RELOAD | MNT_UPDATE);
		goto update;
	}
	/*
	 * Do not allow disabling of permission checks unless exec and access to
	 * device files is disabled too.
	 */
	if ((flags & MNT_NOPERM) &&
	    (flags & (MNT_NODEV | MNT_NOEXEC)) != (MNT_NODEV | MNT_NOEXEC)) {
		vput(vp);
		return (EPERM);
	}
	if ((error = vinvalbuf(vp, V_SAVE, p->p_ucred, p, 0, 0)) != 0) {
		vput(vp);
		return (error);
	}
	if (vp->v_type != VDIR) {
		vput(vp);
		return (ENOTDIR);
	}
	error = copyinstr(SCARG(uap, type), fstypename, MFSNAMELEN, NULL);
	if (error) {
		vput(vp);
		return (error);
	}
	for (vfsp = vfsconf; vfsp; vfsp = vfsp->vfc_next) {
		if (!strcmp(vfsp->vfc_name, fstypename))
			break;
	}

	if (vfsp == NULL) {
		vput(vp);
		return (EOPNOTSUPP);
	}

	if (vp->v_mountedhere != NULL) {
		vput(vp);
		return (EBUSY);
	}

	/*
	 * Allocate and initialize the file system.
	 */
	mp = malloc(sizeof(*mp), M_MOUNT, M_WAITOK|M_ZERO);
	(void) vfs_busy(mp, VB_READ|VB_NOWAIT);
	mp->mnt_op = vfsp->vfc_vfsops;
	mp->mnt_vfc = vfsp;
	mp->mnt_flag |= (vfsp->vfc_flags & MNT_VISFLAGMASK);
	strncpy(mp->mnt_stat.f_fstypename, vfsp->vfc_name, MFSNAMELEN);
	mp->mnt_vnodecovered = vp;
	mp->mnt_stat.f_owner = p->p_ucred->cr_uid;
update:
	/*
	 * Set the mount level flags.
	 */
	if (flags & MNT_RDONLY)
		mp->mnt_flag |= MNT_RDONLY;
	else if (mp->mnt_flag & MNT_RDONLY)
		mp->mnt_flag |= MNT_WANTRDWR;
	mp->mnt_flag &=~ (MNT_NOSUID | MNT_NOEXEC | MNT_WXALLOWED | MNT_NODEV |
	    MNT_SYNCHRONOUS | MNT_ASYNC | MNT_SOFTDEP | MNT_NOATIME |
	    MNT_NOPERM | MNT_FORCE);
	mp->mnt_flag |= flags & (MNT_NOSUID | MNT_NOEXEC | MNT_WXALLOWED |
	    MNT_NODEV | MNT_SYNCHRONOUS | MNT_ASYNC | MNT_SOFTDEP |
	    MNT_NOATIME | MNT_NOPERM | MNT_FORCE);
	/*
	 * Mount the filesystem.
	 */
	error = VFS_MOUNT(mp, fspath, SCARG(uap, data), &nd, p);
	if (!error) {
		mp->mnt_stat.f_ctime = time_second;
	}
	if (mp->mnt_flag & MNT_UPDATE) {
		vput(vp);
		if (mp->mnt_flag & MNT_WANTRDWR)
			mp->mnt_flag &= ~MNT_RDONLY;
		mp->mnt_flag &=~
		    (MNT_UPDATE | MNT_RELOAD | MNT_FORCE | MNT_WANTRDWR);
		if (error)
			mp->mnt_flag = mntflag;

		if ((mp->mnt_flag & MNT_RDONLY) == 0) {
			if (mp->mnt_syncer == NULL)
				error = vfs_allocate_syncvnode(mp);
		} else {
			if (mp->mnt_syncer != NULL)
				vgone(mp->mnt_syncer);
			mp->mnt_syncer = NULL;
		}

		vfs_unbusy(mp);
		return (error);
	}

	vp->v_mountedhere = mp;

	/*
	 * Put the new filesystem on the mount list after root.
	 */
	cache_purge(vp);
	if (!error) {
		vfsp->vfc_refcount++;
		TAILQ_INSERT_TAIL(&mountlist, mp, mnt_list);
		checkdirs(vp);
		VOP_UNLOCK(vp, p);
		if ((mp->mnt_flag & MNT_RDONLY) == 0)
			error = vfs_allocate_syncvnode(mp);
		vfs_unbusy(mp);
		(void) VFS_STATFS(mp, &mp->mnt_stat, p);
		if ((error = VFS_START(mp, 0, p)) != 0)
			vrele(vp);
	} else {
		mp->mnt_vnodecovered->v_mountedhere = NULL;
		vfs_unbusy(mp);
		free(mp, M_MOUNT, sizeof(*mp));
		vput(vp);
	}
	return (error);
}

/*
 * Scan all active processes to see if any of them have a current
 * or root directory onto which the new filesystem has just been
 * mounted. If so, replace them with the new mount point, keeping
 * track of how many were replaced.  That's the number of references
 * the old vnode had that we've replaced, so finish by vrele()'ing
 * it that many times.  This puts off any possible sleeping until
 * we've finished walking the allprocess list.
 */
void
checkdirs(struct vnode *olddp)
{
	struct filedesc *fdp;
	struct vnode *newdp;
	struct process *pr;
	u_int  free_count = 0;

	if (olddp->v_usecount == 1)
		return;
	if (VFS_ROOT(olddp->v_mountedhere, &newdp))
		panic("mount: lost mount");
	LIST_FOREACH(pr, &allprocess, ps_list) {
		fdp = pr->ps_fd;
		if (fdp->fd_cdir == olddp) {
			free_count++;
			vref(newdp);
			fdp->fd_cdir = newdp;
		}
		if (fdp->fd_rdir == olddp) {
			free_count++;
			vref(newdp);
			fdp->fd_rdir = newdp;
		}
	}
	if (rootvnode == olddp) {
		free_count++;
		vref(newdp);
		rootvnode = newdp;
	}
	while (free_count-- > 0)
		vrele(olddp);
	vput(newdp);
}

/*
 * Unmount a file system.
 *
 * Note: unmount takes a path to the vnode mounted on as argument,
 * not special file (as before).
 */
int
sys_unmount(struct proc *p, void *v, register_t *retval)
{
	struct sys_unmount_args /* {
		syscallarg(const char *) path;
		syscallarg(int) flags;
	} */ *uap = v;
	struct vnode *vp;
	struct mount *mp;
	int error;
	struct nameidata nd;

	if ((error = suser(p, 0)) != 0)
		return (error);

	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	mp = vp->v_mount;

	/*
	 * Don't allow unmounting the root file system.
	 */
	if (mp->mnt_flag & MNT_ROOTFS) {
		vput(vp);
		return (EINVAL);
	}

	/*
	 * Must be the root of the filesystem
	 */
	if ((vp->v_flag & VROOT) == 0) {
		vput(vp);
		return (EINVAL);
	}
	vput(vp);

	if (vfs_busy(mp, VB_WRITE|VB_WAIT))
		return (EBUSY);

	return (dounmount(mp, SCARG(uap, flags) & MNT_FORCE, p));
}

/*
 * Do the actual file system unmount.
 */
int
dounmount(struct mount *mp, int flags, struct proc *p)
{
	struct vnode *coveredvp;
	int error;
	int hadsyncer = 0;

	mp->mnt_flag &=~ MNT_ASYNC;
	cache_purgevfs(mp);	/* remove cache entries for this file sys */
	if (mp->mnt_syncer != NULL) {
		hadsyncer = 1;
		vgone(mp->mnt_syncer);
		mp->mnt_syncer = NULL;
	}
	if (((mp->mnt_flag & MNT_RDONLY) ||
	    (error = VFS_SYNC(mp, MNT_WAIT, p->p_ucred, p)) == 0) ||
	    (flags & MNT_FORCE))
		error = VFS_UNMOUNT(mp, flags, p);

	if (error && !(flags & MNT_DOOMED)) {
		if ((mp->mnt_flag & MNT_RDONLY) == 0 && hadsyncer)
			(void) vfs_allocate_syncvnode(mp);
		vfs_unbusy(mp);
		return (error);
	}

	TAILQ_REMOVE(&mountlist, mp, mnt_list);
	if ((coveredvp = mp->mnt_vnodecovered) != NULLVP) {
		coveredvp->v_mountedhere = NULL;
		vrele(coveredvp);
	}

	mp->mnt_vfc->vfc_refcount--;

	if (!LIST_EMPTY(&mp->mnt_vnodelist))
		panic("unmount: dangling vnode");

	vfs_unbusy(mp);
	free(mp, M_MOUNT, sizeof(*mp));

	return (0);
}

/*
 * Sync each mounted filesystem.
 */
#ifdef DEBUG
int syncprt = 0;
struct ctldebug debug0 = { "syncprt", &syncprt };
#endif

int
sys_sync(struct proc *p, void *v, register_t *retval)
{
	struct mount *mp;
	int asyncflag;

	TAILQ_FOREACH_REVERSE(mp, &mountlist, mntlist, mnt_list) {
		if (vfs_busy(mp, VB_READ|VB_NOWAIT))
			continue;
		if ((mp->mnt_flag & MNT_RDONLY) == 0) {
			asyncflag = mp->mnt_flag & MNT_ASYNC;
			mp->mnt_flag &= ~MNT_ASYNC;
			uvm_vnp_sync(mp);
			VFS_SYNC(mp, MNT_NOWAIT, p->p_ucred, p);
			if (asyncflag)
				mp->mnt_flag |= MNT_ASYNC;
		}
		vfs_unbusy(mp);
	}

	return (0);
}

/*
 * Change filesystem quotas.
 */
int
sys_quotactl(struct proc *p, void *v, register_t *retval)
{
	struct sys_quotactl_args /* {
		syscallarg(const char *) path;
		syscallarg(int) cmd;
		syscallarg(int) uid;
		syscallarg(char *) arg;
	} */ *uap = v;
	struct mount *mp;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	mp = nd.ni_vp->v_mount;
	vrele(nd.ni_vp);
	return (VFS_QUOTACTL(mp, SCARG(uap, cmd), SCARG(uap, uid),
	    SCARG(uap, arg), p));
}

int
copyout_statfs(struct statfs *sp, void *uaddr, struct proc *p)
{
	size_t co_sz1 = offsetof(struct statfs, f_fsid);
	size_t co_off2 = co_sz1 + sizeof(fsid_t);
	size_t co_sz2 = sizeof(struct statfs) - co_off2;
	char *s, *d;
	int error;

	/* Don't let non-root see filesystem id (for NFS security) */
	if (suser(p, 0)) {
		fsid_t fsid;

		s = (char *)sp;
		d = (char *)uaddr;

		memset(&fsid, 0, sizeof(fsid));

		if ((error = copyout(s, d, co_sz1)) != 0)
			return (error);
		if ((error = copyout(&fsid, d + co_sz1, sizeof(fsid))) != 0)
			return (error);
		return (copyout(s + co_off2, d + co_off2, co_sz2));
	}

	return (copyout(sp, uaddr, sizeof(*sp)));
}

/*
 * Get filesystem statistics.
 */
int
sys_statfs(struct proc *p, void *v, register_t *retval)
{
	struct sys_statfs_args /* {
		syscallarg(const char *) path;
		syscallarg(struct statfs *) buf;
	} */ *uap = v;
	struct mount *mp;
	struct statfs *sp;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	nd.ni_pledge = PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	mp = nd.ni_vp->v_mount;
	sp = &mp->mnt_stat;
	vrele(nd.ni_vp);
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;

	return (copyout_statfs(sp, SCARG(uap, buf), p));
}

/*
 * Get filesystem statistics.
 */
int
sys_fstatfs(struct proc *p, void *v, register_t *retval)
{
	struct sys_fstatfs_args /* {
		syscallarg(int) fd;
		syscallarg(struct statfs *) buf;
	} */ *uap = v;
	struct file *fp;
	struct mount *mp;
	struct statfs *sp;
	int error;

	if ((error = getvnode(p, SCARG(uap, fd), &fp)) != 0)
		return (error);
	mp = ((struct vnode *)fp->f_data)->v_mount;
	if (!mp) {
		FRELE(fp, p);
		return (ENOENT);
	}
	sp = &mp->mnt_stat;
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp, p);
	if (error)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;

	return (copyout_statfs(sp, SCARG(uap, buf), p));
}

/*
 * Get statistics on all filesystems.
 */
int
sys_getfsstat(struct proc *p, void *v, register_t *retval)
{
	struct sys_getfsstat_args /* {
		syscallarg(struct statfs *) buf;
		syscallarg(size_t) bufsize;
		syscallarg(int) flags;
	} */ *uap = v;
	struct mount *mp;
	struct statfs *sp;
	struct statfs *sfsp;
	size_t count, maxcount;
	int error, flags = SCARG(uap, flags);

	maxcount = SCARG(uap, bufsize) / sizeof(struct statfs);
	sfsp = SCARG(uap, buf);
	count = 0;

	TAILQ_FOREACH(mp, &mountlist, mnt_list) {
		if (vfs_busy(mp, VB_READ|VB_NOWAIT))
			continue;
		if (sfsp && count < maxcount) {
			sp = &mp->mnt_stat;

			/* Refresh stats unless MNT_NOWAIT is specified */
			if (flags != MNT_NOWAIT &&
			    flags != MNT_LAZY &&
			    (flags == MNT_WAIT ||
			    flags == 0) &&
			    (error = VFS_STATFS(mp, sp, p))) {
				vfs_unbusy(mp);
				continue;
			}

			sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
#if notyet
			if (mp->mnt_flag & MNT_SOFTDEP)
				sp->f_eflags = STATFS_SOFTUPD;
#endif
			error = (copyout_statfs(sp, sfsp, p));
			if (error) {
				vfs_unbusy(mp);
				return (error);
			}
			sfsp++;
		}
		count++;
		vfs_unbusy(mp);
	}

	if (sfsp && count > maxcount)
		*retval = maxcount;
	else
		*retval = count;

	return (0);
}

/*
 * Change current working directory to a given file descriptor.
 */
int
sys_fchdir(struct proc *p, void *v, register_t *retval)
{
	struct sys_fchdir_args /* {
		syscallarg(int) fd;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct vnode *vp, *tdp, *old_cdir;
	struct mount *mp;
	struct file *fp;
	int error;

	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return (EBADF);
	vp = fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type != VDIR)
		return (ENOTDIR);
	vref(vp);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p);

	while (!error && (mp = vp->v_mountedhere) != NULL) {
		if (vfs_busy(mp, VB_READ|VB_WAIT))
			continue;
		error = VFS_ROOT(mp, &tdp);
		vfs_unbusy(mp);
		if (error)
			break;
		vput(vp);
		vp = tdp;
	}
	if (error) {
		vput(vp);
		return (error);
	}
	VOP_UNLOCK(vp, p);
	old_cdir = fdp->fd_cdir;
	fdp->fd_cdir = vp;
	vrele(old_cdir);
	return (0);
}

/*
 * Change current working directory (``.'').
 */
int
sys_chdir(struct proc *p, void *v, register_t *retval)
{
	struct sys_chdir_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct vnode *old_cdir;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	nd.ni_pledge = PLEDGE_RPATH;
	if ((error = change_dir(&nd, p)) != 0)
		return (error);
	old_cdir = fdp->fd_cdir;
	fdp->fd_cdir = nd.ni_vp;
	vrele(old_cdir);
	return (0);
}

/*
 * Change notion of root (``/'') directory.
 */
int
sys_chroot(struct proc *p, void *v, register_t *retval)
{
	struct sys_chroot_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct vnode *old_cdir, *old_rdir;
	int error;
	struct nameidata nd;

	if ((error = suser(p, 0)) != 0)
		return (error);
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = change_dir(&nd, p)) != 0)
		return (error);
	if (fdp->fd_rdir != NULL) {
		/*
		 * A chroot() done inside a changed root environment does
		 * an automatic chdir to avoid the out-of-tree experience.
		 */
		vref(nd.ni_vp);
		old_rdir = fdp->fd_rdir;
		old_cdir = fdp->fd_cdir;
		fdp->fd_rdir = fdp->fd_cdir = nd.ni_vp;
		vrele(old_rdir);
		vrele(old_cdir);
	} else
		fdp->fd_rdir = nd.ni_vp;
	return (0);
}

/*
 * Common routine for chroot and chdir.
 */
static int
change_dir(struct nameidata *ndp, struct proc *p)
{
	struct vnode *vp;
	int error;

	if ((error = namei(ndp)) != 0)
		return (error);
	vp = ndp->ni_vp;
	if (vp->v_type != VDIR)
		error = ENOTDIR;
	else
		error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p);
	if (error)
		vput(vp);
	else
		VOP_UNLOCK(vp, p);
	return (error);
}

/*
 * Check permissions, allocate an open file structure,
 * and call the device open routine if any.
 */
int
sys_open(struct proc *p, void *v, register_t *retval)
{
	struct sys_open_args /* {
		syscallarg(const char *) path;
		syscallarg(int) flags;
		syscallarg(mode_t) mode;
	} */ *uap = v;

	return (doopenat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, flags),
	    SCARG(uap, mode), retval));
}

int
sys_openat(struct proc *p, void *v, register_t *retval)
{
	struct sys_openat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(int) flags;
		syscallarg(mode_t) mode;
	} */ *uap = v;

	return (doopenat(p, SCARG(uap, fd), SCARG(uap, path),
	    SCARG(uap, flags), SCARG(uap, mode), retval));
}

int
doopenat(struct proc *p, int fd, const char *path, int oflags, mode_t mode,
    register_t *retval)
{
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	struct vattr vattr;
	int flags, cmode;
	int type, indx, error, localtrunc = 0;
	struct flock lf;
	struct nameidata nd;
	int ni_pledge = 0;

	if (oflags & (O_EXLOCK | O_SHLOCK)) {
		error = pledge_flock(p);
		if (error != 0)
			return (error);
	}

	fdplock(fdp);

	if ((error = falloc(p, (oflags & O_CLOEXEC) ? UF_EXCLOSE : 0, &fp,
	    &indx)) != 0)
		goto out;
	flags = FFLAGS(oflags);
	if (flags & FREAD)
		ni_pledge |= PLEDGE_RPATH;
	if (flags & FWRITE)
		ni_pledge |= PLEDGE_WPATH;
	if (oflags & O_CREAT)
		ni_pledge |= PLEDGE_CPATH;

	cmode = ((mode &~ fdp->fd_cmask) & ALLPERMS) &~ S_ISTXT;
	if ((p->p_p->ps_flags & PS_PLEDGE))
		cmode &= ACCESSPERMS;
	NDINITAT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, fd, path, p);
	nd.ni_pledge = ni_pledge;
	p->p_dupfd = -1;			/* XXX check for fdopen */
	if ((flags & O_TRUNC) && (flags & (O_EXLOCK | O_SHLOCK))) {
		localtrunc = 1;
		flags &= ~O_TRUNC;	/* Must do truncate ourselves */
	}
	if ((error = vn_open(&nd, flags, cmode)) != 0) {
		if (error == ENODEV &&
		    p->p_dupfd >= 0 &&			/* XXX from fdopen */
		    (error =
			dupfdopen(p, indx, flags)) == 0) {
			closef(fp, p);
			*retval = indx;
			goto out;
		}
		if (error == ERESTART)
			error = EINTR;
		fdremove(fdp, indx);
		closef(fp, p);
		goto out;
	}
	p->p_dupfd = 0;
	vp = nd.ni_vp;
	fp->f_flag = flags & FMASK;
	fp->f_type = DTYPE_VNODE;
	fp->f_ops = &vnops;
	fp->f_data = vp;
	if (flags & (O_EXLOCK | O_SHLOCK)) {
		lf.l_whence = SEEK_SET;
		lf.l_start = 0;
		lf.l_len = 0;
		if (flags & O_EXLOCK)
			lf.l_type = F_WRLCK;
		else
			lf.l_type = F_RDLCK;
		type = F_FLOCK;
		if ((flags & FNONBLOCK) == 0)
			type |= F_WAIT;
		VOP_UNLOCK(vp, p);
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, type);
		if (error) {
			/* closef will vn_close the file for us. */
			fdremove(fdp, indx);
			closef(fp, p);
			goto out;
		}
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
		fp->f_iflags |= FIF_HASLOCK;
	}
	if (localtrunc) {
		if ((fp->f_flag & FWRITE) == 0)
			error = EACCES;
		else if (vp->v_mount->mnt_flag & MNT_RDONLY)
			error = EROFS;
		else if (vp->v_type == VDIR)
			error = EISDIR;
		else if ((error = vn_writechk(vp)) == 0) {
			VATTR_NULL(&vattr);
			vattr.va_size = 0;
			error = VOP_SETATTR(vp, &vattr, fp->f_cred, p);
		}
		if (error) {
			VOP_UNLOCK(vp, p);
			/* closef will close the file for us. */
			fdremove(fdp, indx);
			closef(fp, p);
			goto out;
		}
	}
	VOP_UNLOCK(vp, p);
	*retval = indx;
	FILE_SET_MATURE(fp, p);
out:
	fdpunlock(fdp);
	return (error);
}

/*
 * Get file handle system call
 */
int
sys_getfh(struct proc *p, void *v, register_t *retval)
{
	struct sys_getfh_args /* {
		syscallarg(const char *) fname;
		syscallarg(fhandle_t *) fhp;
	} */ *uap = v;
	struct vnode *vp;
	fhandle_t fh;
	int error;
	struct nameidata nd;

	/*
	 * Must be super user
	 */
	error = suser(p, 0);
	if (error)
		return (error);
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, fname), p);
	error = namei(&nd);
	if (error)
		return (error);
	vp = nd.ni_vp;
	memset(&fh, 0, sizeof(fh));
	fh.fh_fsid = vp->v_mount->mnt_stat.f_fsid;
	error = VFS_VPTOFH(vp, &fh.fh_fid);
	vput(vp);
	if (error)
		return (error);
	error = copyout(&fh, SCARG(uap, fhp), sizeof(fh));
	return (error);
}

/*
 * Open a file given a file handle.
 *
 * Check permissions, allocate an open file structure,
 * and call the device open routine if any.
 */
int
sys_fhopen(struct proc *p, void *v, register_t *retval)
{
	struct sys_fhopen_args /* {
		syscallarg(const fhandle_t *) fhp;
		syscallarg(int) flags;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp = NULL;
	struct mount *mp;
	struct ucred *cred = p->p_ucred;
	int flags;
	int type, indx, error=0;
	struct flock lf;
	struct vattr va;
	fhandle_t fh;

	/*
	 * Must be super user
	 */
	if ((error = suser(p, 0)))
		return (error);

	flags = FFLAGS(SCARG(uap, flags));
	if ((flags & (FREAD | FWRITE)) == 0)
		return (EINVAL);
	if ((flags & O_CREAT))
		return (EINVAL);

	fdplock(fdp);
	if ((error = falloc(p, (flags & O_CLOEXEC) ? UF_EXCLOSE : 0, &fp,
	    &indx)) != 0) {
		fp = NULL;
		goto bad;
	}

	if ((error = copyin(SCARG(uap, fhp), &fh, sizeof(fhandle_t))) != 0)
		goto bad;

	if ((mp = vfs_getvfs(&fh.fh_fsid)) == NULL) {
		error = ESTALE;
		goto bad;
	}

	if ((error = VFS_FHTOVP(mp, &fh.fh_fid, &vp)) != 0) {
		vp = NULL;	/* most likely unnecessary sanity for bad: */
		goto bad;
	}

	/* Now do an effective vn_open */

	if (vp->v_type == VSOCK) {
		error = EOPNOTSUPP;
		goto bad;
	}
	if ((flags & O_DIRECTORY) && vp->v_type != VDIR) {
		error = ENOTDIR;
		goto bad;
	}
	if (flags & FREAD) {
		if ((error = VOP_ACCESS(vp, VREAD, cred, p)) != 0)
			goto bad;
	}
	if (flags & (FWRITE | O_TRUNC)) {
		if (vp->v_type == VDIR) {
			error = EISDIR;
			goto bad;
		}
		if ((error = VOP_ACCESS(vp, VWRITE, cred, p)) != 0 ||
		    (error = vn_writechk(vp)) != 0)
			goto bad;
	}
	if (flags & O_TRUNC) {
		VATTR_NULL(&va);
		va.va_size = 0;
		if ((error = VOP_SETATTR(vp, &va, cred, p)) != 0)
			goto bad;
	}
	if ((error = VOP_OPEN(vp, flags, cred, p)) != 0)
		goto bad;
	if (flags & FWRITE)
		vp->v_writecount++;

	/* done with modified vn_open, now finish what sys_open does. */

	fp->f_flag = flags & FMASK;
	fp->f_type = DTYPE_VNODE;
	fp->f_ops = &vnops;
	fp->f_data = vp;
	if (flags & (O_EXLOCK | O_SHLOCK)) {
		lf.l_whence = SEEK_SET;
		lf.l_start = 0;
		lf.l_len = 0;
		if (flags & O_EXLOCK)
			lf.l_type = F_WRLCK;
		else
			lf.l_type = F_RDLCK;
		type = F_FLOCK;
		if ((flags & FNONBLOCK) == 0)
			type |= F_WAIT;
		VOP_UNLOCK(vp, p);
		error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, type);
		if (error) {
			vp = NULL;	/* closef will vn_close the file */
			goto bad;
		}
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
		fp->f_iflags |= FIF_HASLOCK;
	}
	VOP_UNLOCK(vp, p);
	*retval = indx;
	FILE_SET_MATURE(fp, p);

	fdpunlock(fdp);
	return (0);

bad:
	if (fp) {
		fdremove(fdp, indx);
		closef(fp, p);
		if (vp != NULL)
			vput(vp);
	}
	fdpunlock(fdp);
	return (error);
}

int
sys_fhstat(struct proc *p, void *v, register_t *retval)
{
	struct sys_fhstat_args /* {
		syscallarg(const fhandle_t *) fhp;
		syscallarg(struct stat *) sb;
	} */ *uap = v;
	struct stat sb;
	int error;
	fhandle_t fh;
	struct mount *mp;
	struct vnode *vp;

	/*
	 * Must be super user
	 */
	if ((error = suser(p, 0)))
		return (error);

	if ((error = copyin(SCARG(uap, fhp), &fh, sizeof(fhandle_t))) != 0)
		return (error);

	if ((mp = vfs_getvfs(&fh.fh_fsid)) == NULL)
		return (ESTALE);
	if ((error = VFS_FHTOVP(mp, &fh.fh_fid, &vp)))
		return (error);
	error = vn_stat(vp, &sb, p);
	vput(vp);
	if (error)
		return (error);
	error = copyout(&sb, SCARG(uap, sb), sizeof(sb));
	return (error);
}

int
sys_fhstatfs(struct proc *p, void *v, register_t *retval)
{
	struct sys_fhstatfs_args /* {
		syscallarg(const fhandle_t *) fhp;
		syscallarg(struct statfs *) buf;
	} */ *uap = v;
	struct statfs *sp;
	fhandle_t fh;
	struct mount *mp;
	struct vnode *vp;
	int error;

	/*
	 * Must be super user
	 */
	if ((error = suser(p, 0)))
		return (error);

	if ((error = copyin(SCARG(uap, fhp), &fh, sizeof(fhandle_t))) != 0)
		return (error);

	if ((mp = vfs_getvfs(&fh.fh_fsid)) == NULL)
		return (ESTALE);
	if ((error = VFS_FHTOVP(mp, &fh.fh_fid, &vp)))
		return (error);
	mp = vp->v_mount;
	sp = &mp->mnt_stat;
	vput(vp);
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
	return (copyout(sp, SCARG(uap, buf), sizeof(*sp)));
}

/*
 * Create a special file or named pipe.
 */
int
sys_mknod(struct proc *p, void *v, register_t *retval)
{
	struct sys_mknod_args /* {
		syscallarg(const char *) path;
		syscallarg(mode_t) mode;
		syscallarg(int) dev;
	} */ *uap = v;

	return (domknodat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, mode),
	    SCARG(uap, dev)));
}

int
sys_mknodat(struct proc *p, void *v, register_t *retval)
{
	struct sys_mknodat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(mode_t) mode;
		syscallarg(dev_t) dev;
	} */ *uap = v;

	return (domknodat(p, SCARG(uap, fd), SCARG(uap, path),
	    SCARG(uap, mode), SCARG(uap, dev)));
}

int
domknodat(struct proc *p, int fd, const char *path, mode_t mode, dev_t dev)
{
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;

	if (dev == VNOVAL)
		return (EINVAL);
	NDINITAT(&nd, CREATE, LOCKPARENT, UIO_USERSPACE, fd, path, p);
	nd.ni_pledge = PLEDGE_DPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if (!S_ISFIFO(mode) || dev != 0) {
		if ((nd.ni_dvp->v_mount->mnt_flag & MNT_NOPERM) == 0 &&
		    (error = suser(p, 0)) != 0)
			goto out;
		if (p->p_fd->fd_rdir) {
			error = EINVAL;
			goto out;
		}
	}
	if (vp != NULL)
		error = EEXIST;
	else {
		VATTR_NULL(&vattr);
		vattr.va_mode = (mode & ALLPERMS) &~ p->p_fd->fd_cmask;
		if ((p->p_p->ps_flags & PS_PLEDGE))
			vattr.va_mode &= ACCESSPERMS;
		vattr.va_rdev = dev;

		switch (mode & S_IFMT) {
		case S_IFMT:	/* used by badsect to flag bad sectors */
			vattr.va_type = VBAD;
			break;
		case S_IFCHR:
			vattr.va_type = VCHR;
			break;
		case S_IFBLK:
			vattr.va_type = VBLK;
			break;
		case S_IFIFO:
#ifndef FIFO
			error = EOPNOTSUPP;
			break;
#else
			if (dev == 0) {
				vattr.va_type = VFIFO;
				break;
			}
			/* FALLTHROUGH */
#endif /* FIFO */
		default:
			error = EINVAL;
			break;
		}
	}
out:
	if (!error) {
		error = VOP_MKNOD(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &vattr);
	} else {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		if (vp)
			vrele(vp);
	}
	return (error);
}

/*
 * Create a named pipe.
 */
int
sys_mkfifo(struct proc *p, void *v, register_t *retval)
{
	struct sys_mkfifo_args /* {
		syscallarg(const char *) path;
		syscallarg(mode_t) mode;
	} */ *uap = v;

	return (domknodat(p, AT_FDCWD, SCARG(uap, path),
	    (SCARG(uap, mode) & ALLPERMS) | S_IFIFO, 0));
}

int
sys_mkfifoat(struct proc *p, void *v, register_t *retval)
{
	struct sys_mkfifoat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(mode_t) mode;
	} */ *uap = v;

	return (domknodat(p, SCARG(uap, fd), SCARG(uap, path),
	    (SCARG(uap, mode) & ALLPERMS) | S_IFIFO, 0));
}

/*
 * Make a hard file link.
 */
int
sys_link(struct proc *p, void *v, register_t *retval)
{
	struct sys_link_args /* {
		syscallarg(const char *) path;
		syscallarg(const char *) link;
	} */ *uap = v;

	return (dolinkat(p, AT_FDCWD, SCARG(uap, path), AT_FDCWD,
	    SCARG(uap, link), AT_SYMLINK_FOLLOW));
}

int
sys_linkat(struct proc *p, void *v, register_t *retval)
{
	struct sys_linkat_args /* {
		syscallarg(int) fd1;
		syscallarg(const char *) path1;
		syscallarg(int) fd2;
		syscallarg(const char *) path2;
		syscallarg(int) flag;
	} */ *uap = v;

	return (dolinkat(p, SCARG(uap, fd1), SCARG(uap, path1),
	    SCARG(uap, fd2), SCARG(uap, path2), SCARG(uap, flag)));
}

int
dolinkat(struct proc *p, int fd1, const char *path1, int fd2,
    const char *path2, int flag)
{
	struct vnode *vp;
	struct nameidata nd;
	int error, follow;
	int flags;

	if (flag & ~AT_SYMLINK_FOLLOW)
		return (EINVAL);

	follow = (flag & AT_SYMLINK_FOLLOW) ? FOLLOW : NOFOLLOW;
	NDINITAT(&nd, LOOKUP, follow, UIO_USERSPACE, fd1, path1, p);
	nd.ni_pledge = PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;

	flags = LOCKPARENT;
	if (vp->v_type == VDIR) {
		flags |= STRIPSLASHES;
	}

	NDINITAT(&nd, CREATE, flags, UIO_USERSPACE, fd2, path2, p);
	nd.ni_pledge = PLEDGE_CPATH;
	if ((error = namei(&nd)) != 0)
		goto out;
	if (nd.ni_vp) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vrele(nd.ni_vp);
		error = EEXIST;
		goto out;
	}
	error = VOP_LINK(nd.ni_dvp, vp, &nd.ni_cnd);
out:
	vrele(vp);
	return (error);
}

/*
 * Make a symbolic link.
 */
int
sys_symlink(struct proc *p, void *v, register_t *retval)
{
	struct sys_symlink_args /* {
		syscallarg(const char *) path;
		syscallarg(const char *) link;
	} */ *uap = v;

	return (dosymlinkat(p, SCARG(uap, path), AT_FDCWD, SCARG(uap, link)));
}

int
sys_symlinkat(struct proc *p, void *v, register_t *retval)
{
	struct sys_symlinkat_args /* {
		syscallarg(const char *) path;
		syscallarg(int) fd;
		syscallarg(const char *) link;
	} */ *uap = v;

	return (dosymlinkat(p, SCARG(uap, path), SCARG(uap, fd),
	    SCARG(uap, link)));
}

int
dosymlinkat(struct proc *p, const char *upath, int fd, const char *link)
{
	struct vattr vattr;
	char *path;
	int error;
	struct nameidata nd;

	path = pool_get(&namei_pool, PR_WAITOK);
	error = copyinstr(upath, path, MAXPATHLEN, NULL);
	if (error)
		goto out;
	NDINITAT(&nd, CREATE, LOCKPARENT, UIO_USERSPACE, fd, link, p);
	nd.ni_pledge = PLEDGE_CPATH;
	if ((error = namei(&nd)) != 0)
		goto out;
	if (nd.ni_vp) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vrele(nd.ni_vp);
		error = EEXIST;
		goto out;
	}
	VATTR_NULL(&vattr);
	vattr.va_mode = ACCESSPERMS &~ p->p_fd->fd_cmask;
	error = VOP_SYMLINK(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &vattr, path);
out:
	pool_put(&namei_pool, path);
	return (error);
}

/*
 * Delete a name from the filesystem.
 */
int
sys_unlink(struct proc *p, void *v, register_t *retval)
{
	struct sys_unlink_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;

	return (dounlinkat(p, AT_FDCWD, SCARG(uap, path), 0));
}

int
sys_unlinkat(struct proc *p, void *v, register_t *retval)
{
	struct sys_unlinkat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(int) flag;
	} */ *uap = v;

	return (dounlinkat(p, SCARG(uap, fd), SCARG(uap, path),
	    SCARG(uap, flag)));
}

int
dounlinkat(struct proc *p, int fd, const char *path, int flag)
{
	struct vnode *vp;
	int error;
	struct nameidata nd;

	if (flag & ~AT_REMOVEDIR)
		return (EINVAL);

	NDINITAT(&nd, DELETE, LOCKPARENT | LOCKLEAF, UIO_USERSPACE,
	    fd, path, p);
	nd.ni_pledge = PLEDGE_CPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;

	if (flag & AT_REMOVEDIR) {
		if (vp->v_type != VDIR) {
			error = ENOTDIR;
			goto out;
		}
		/*
		 * No rmdir "." please.
		 */
		if (nd.ni_dvp == vp) {
			error = EINVAL;
			goto out;
		}
	}

	/*
	 * The root of a mounted filesystem cannot be deleted.
	 */
	if (vp->v_flag & VROOT)
		error = EBUSY;
out:
	if (!error) {
		if (flag & AT_REMOVEDIR) {
			error = VOP_RMDIR(nd.ni_dvp, nd.ni_vp, &nd.ni_cnd);
		} else {
			(void)uvm_vnp_uncache(vp);
			error = VOP_REMOVE(nd.ni_dvp, nd.ni_vp, &nd.ni_cnd);
		}
	} else {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vput(vp);
	}
	return (error);
}

/*
 * Reposition read/write file offset.
 */
int
sys_lseek(struct proc *p, void *v, register_t *retval)
{
	struct sys_lseek_args /* {
		syscallarg(int) fd;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
		syscallarg(int) whence;
	} */ *uap = v;
	struct ucred *cred = p->p_ucred;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vattr vattr;
	struct vnode *vp;
	off_t offarg, newoff;
	int error, special;

	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
		return (EBADF);
	if (fp->f_type != DTYPE_VNODE)
		return (ESPIPE);
	vp = fp->f_data;
	if (vp->v_type == VFIFO)
		return (ESPIPE);
	FREF(fp);
	if (vp->v_type == VCHR)
		special = 1;
	else
		special = 0;
	offarg = SCARG(uap, offset);

	switch (SCARG(uap, whence)) {
	case SEEK_CUR:
		newoff = fp->f_offset + offarg;
		break;
	case SEEK_END:
		error = VOP_GETATTR(vp, &vattr, cred, p);
		if (error)
			goto bad;
		newoff = offarg + (off_t)vattr.va_size;
		break;
	case SEEK_SET:
		newoff = offarg;
		break;
	default:
		error = EINVAL;
		goto bad;
	}
	if (!special) {
		if (newoff < 0) {
			error = EINVAL;
			goto bad;
		}
	}
	*(off_t *)retval = fp->f_offset = newoff;
	fp->f_seek++;
	error = 0;
 bad:
	FRELE(fp, p);
	return (error);
}

/*
 * Check access permissions.
 */
int
sys_access(struct proc *p, void *v, register_t *retval)
{
	struct sys_access_args /* {
		syscallarg(const char *) path;
		syscallarg(int) amode;
	} */ *uap = v;

	return (dofaccessat(p, AT_FDCWD, SCARG(uap, path),
	    SCARG(uap, amode), 0));
}

int
sys_faccessat(struct proc *p, void *v, register_t *retval)
{
	struct sys_faccessat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(int) amode;
		syscallarg(int) flag;
	} */ *uap = v;

	return (dofaccessat(p, SCARG(uap, fd), SCARG(uap, path),
	    SCARG(uap, amode), SCARG(uap, flag)));
}

int
dofaccessat(struct proc *p, int fd, const char *path, int amode, int flag)
{
	struct vnode *vp;
	struct ucred *newcred, *oldcred;
	struct nameidata nd;
	int error;

	if (amode & ~(R_OK | W_OK | X_OK))
		return (EINVAL);
	if (flag & ~AT_EACCESS)
		return (EINVAL);

	newcred = NULL;
	oldcred = p->p_ucred;

	/*
	 * If access as real ids was requested and they really differ,
	 * give the thread new creds with them reset
	 */
	if ((flag & AT_EACCESS) == 0 &&
	    (oldcred->cr_uid != oldcred->cr_ruid ||
	    (oldcred->cr_gid != oldcred->cr_rgid))) {
		p->p_ucred = newcred = crdup(oldcred);
		newcred->cr_uid = newcred->cr_ruid;
		newcred->cr_gid = newcred->cr_rgid;
	}

	NDINITAT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE, fd, path, p);
	nd.ni_pledge = PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0)
		goto out;
	vp = nd.ni_vp;

	/* Flags == 0 means only check for existence. */
	if (amode) {
		int vflags = 0;

		if (amode & R_OK)
			vflags |= VREAD;
		if (amode & W_OK)
			vflags |= VWRITE;
		if (amode & X_OK)
			vflags |= VEXEC;

		error = VOP_ACCESS(vp, vflags, p->p_ucred, p);
		if (!error && (vflags & VWRITE))
			error = vn_writechk(vp);
	}
	vput(vp);
out:
	if (newcred != NULL) {
		p->p_ucred = oldcred;
		crfree(newcred);
	}
	return (error);
}

/*
 * Get file status; this version follows links.
 */
int
sys_stat(struct proc *p, void *v, register_t *retval)
{
	struct sys_stat_args /* {
		syscallarg(const char *) path;
		syscallarg(struct stat *) ub;
	} */ *uap = v;

	return (dofstatat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, ub), 0));
}

int
sys_fstatat(struct proc *p, void *v, register_t *retval)
{
	struct sys_fstatat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(struct stat *) buf;
		syscallarg(int) flag;
	} */ *uap = v;

	return (dofstatat(p, SCARG(uap, fd), SCARG(uap, path),
	    SCARG(uap, buf), SCARG(uap, flag)));
}

int
dofstatat(struct proc *p, int fd, const char *path, struct stat *buf, int flag)
{
	struct stat sb;
	int error, follow;
	struct nameidata nd;

	if (flag & ~AT_SYMLINK_NOFOLLOW)
		return (EINVAL);


	follow = (flag & AT_SYMLINK_NOFOLLOW) ? NOFOLLOW : FOLLOW;
	NDINITAT(&nd, LOOKUP, follow | LOCKLEAF, UIO_USERSPACE, fd, path, p);
	nd.ni_pledge = PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	error = vn_stat(nd.ni_vp, &sb, p);
	vput(nd.ni_vp);
	if (error)
		return (error);
	if (nd.ni_pledge & PLEDGE_STATLIE) {
		if (S_ISDIR(sb.st_mode)) {
			sb.st_mode &= ~ALLPERMS;
			sb.st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
			sb.st_uid = 0;
			sb.st_gid = 0;
			sb.st_gen = 0;
		} else
			return (ENOENT);
	}
	/* Don't let non-root see generation numbers (for NFS security) */
	if (suser(p, 0))
		sb.st_gen = 0;
	error = copyout(&sb, buf, sizeof(sb));
#ifdef KTRACE
	if (error == 0 && KTRPOINT(p, KTR_STRUCT))
		ktrstat(p, &sb);
#endif
	return (error);
}

/*
 * Get file status; this version does not follow links.
 */
int
sys_lstat(struct proc *p, void *v, register_t *retval)
{
	struct sys_lstat_args /* {
		syscallarg(const char *) path;
		syscallarg(struct stat *) ub;
	} */ *uap = v;

	return (dofstatat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, ub),
	    AT_SYMLINK_NOFOLLOW));
}

/*
 * Get configurable pathname variables.
 */
int
sys_pathconf(struct proc *p, void *v, register_t *retval)
{
	struct sys_pathconf_args /* {
		syscallarg(const char *) path;
		syscallarg(int) name;
	} */ *uap = v;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	nd.ni_pledge = PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	error = VOP_PATHCONF(nd.ni_vp, SCARG(uap, name), retval);
	vput(nd.ni_vp);
	return (error);
}

/*
 * Return target name of a symbolic link.
 */
int
sys_readlink(struct proc *p, void *v, register_t *retval)
{
	struct sys_readlink_args /* {
		syscallarg(const char *) path;
		syscallarg(char *) buf;
		syscallarg(size_t) count;
	} */ *uap = v;

	return (doreadlinkat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, buf),
	    SCARG(uap, count), retval));
}

int
sys_readlinkat(struct proc *p, void *v, register_t *retval)
{
	struct sys_readlinkat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(char *) buf;
		syscallarg(size_t) count;
	} */ *uap = v;

	return (doreadlinkat(p, SCARG(uap, fd), SCARG(uap, path),
	    SCARG(uap, buf), SCARG(uap, count), retval));
}

int
doreadlinkat(struct proc *p, int fd, const char *path, char *buf,
    size_t count, register_t *retval)
{
	struct vnode *vp;
	struct iovec aiov;
	struct uio auio;
	int error;
	struct nameidata nd;

	NDINITAT(&nd, LOOKUP, NOFOLLOW | LOCKLEAF, UIO_USERSPACE, fd, path, p);
	nd.ni_pledge = PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if (vp->v_type != VLNK)
		error = EINVAL;
	else {
		aiov.iov_base = buf;
		aiov.iov_len = count;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_offset = 0;
		auio.uio_rw = UIO_READ;
		auio.uio_segflg = UIO_USERSPACE;
		auio.uio_procp = p;
		auio.uio_resid = count;
		error = VOP_READLINK(vp, &auio, p->p_ucred);
		*retval = count - auio.uio_resid;
	}
	vput(vp);
	return (error);
}

/*
 * Change flags of a file given a path name.
 */
int
sys_chflags(struct proc *p, void *v, register_t *retval)
{
	struct sys_chflags_args /* {
		syscallarg(const char *) path;
		syscallarg(u_int) flags;
	} */ *uap = v;

	return (dochflagsat(p, AT_FDCWD, SCARG(uap, path),
	    SCARG(uap, flags), 0));
}

int
sys_chflagsat(struct proc *p, void *v, register_t *retval)
{
	struct sys_chflagsat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(u_int) flags;
		syscallarg(int) atflags;
	} */ *uap = v;

	return (dochflagsat(p, SCARG(uap, fd), SCARG(uap, path),
	    SCARG(uap, flags), SCARG(uap, atflags)));
}

int
dochflagsat(struct proc *p, int fd, const char *path, u_int flags, int atflags)
{
	struct nameidata nd;
	int error, follow;

	if (atflags & ~AT_SYMLINK_NOFOLLOW)
		return (EINVAL);

	follow = (atflags & AT_SYMLINK_NOFOLLOW) ? NOFOLLOW : FOLLOW;
	NDINITAT(&nd, LOOKUP, follow, UIO_USERSPACE, fd, path, p);
	nd.ni_pledge = PLEDGE_FATTR | PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	return (dovchflags(p, nd.ni_vp, flags));
}

/*
 * Change flags of a file given a file descriptor.
 */
int
sys_fchflags(struct proc *p, void *v, register_t *retval)
{
	struct sys_fchflags_args /* {
		syscallarg(int) fd;
		syscallarg(u_int) flags;
	} */ *uap = v;
	struct file *fp;
	struct vnode *vp;
	int error;

	if ((error = getvnode(p, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = fp->f_data;
	vref(vp);
	FRELE(fp, p);
	return (dovchflags(p, vp, SCARG(uap, flags)));
}

int
dovchflags(struct proc *p, struct vnode *vp, u_int flags)
{
	struct vattr vattr;
	int error;

	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount && vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else if (flags == VNOVAL)
		error = EINVAL;
	else {
		if (suser(p, 0)) {
			if ((error = VOP_GETATTR(vp, &vattr, p->p_ucred, p))
			    != 0)
				goto out;
			if (vattr.va_type == VCHR || vattr.va_type == VBLK) {
				error = EINVAL;
				goto out;
			}
		}
		VATTR_NULL(&vattr);
		vattr.va_flags = flags;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
out:
	vput(vp);
	return (error);
}

/*
 * Change mode of a file given path name.
 */
int
sys_chmod(struct proc *p, void *v, register_t *retval)
{
	struct sys_chmod_args /* {
		syscallarg(const char *) path;
		syscallarg(mode_t) mode;
	} */ *uap = v;

	return (dofchmodat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, mode), 0));
}

int
sys_fchmodat(struct proc *p, void *v, register_t *retval)
{
	struct sys_fchmodat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(mode_t) mode;
		syscallarg(int) flag;
	} */ *uap = v;

	return (dofchmodat(p, SCARG(uap, fd), SCARG(uap, path),
	    SCARG(uap, mode), SCARG(uap, flag)));
}

int
dofchmodat(struct proc *p, int fd, const char *path, mode_t mode, int flag)
{
	struct vnode *vp;
	struct vattr vattr;
	int error, follow;
	struct nameidata nd;

	if (mode & ~(S_IFMT | ALLPERMS))
		return (EINVAL);
	if ((p->p_p->ps_flags & PS_PLEDGE))
		mode &= ACCESSPERMS;
	if (flag & ~AT_SYMLINK_NOFOLLOW)
		return (EINVAL);

	follow = (flag & AT_SYMLINK_NOFOLLOW) ? NOFOLLOW : FOLLOW;
	NDINITAT(&nd, LOOKUP, follow, UIO_USERSPACE, fd, path, p);
	nd.ni_pledge = PLEDGE_FATTR | PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		VATTR_NULL(&vattr);
		vattr.va_mode = mode & ALLPERMS;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
	vput(vp);
	return (error);
}

/*
 * Change mode of a file given a file descriptor.
 */
int
sys_fchmod(struct proc *p, void *v, register_t *retval)
{
	struct sys_fchmod_args /* {
		syscallarg(int) fd;
		syscallarg(mode_t) mode;
	} */ *uap = v;
	struct vattr vattr;
	struct vnode *vp;
	struct file *fp;
	mode_t mode = SCARG(uap, mode);
	int error;

	if (mode & ~(S_IFMT | ALLPERMS))
		return (EINVAL);
	if ((p->p_p->ps_flags & PS_PLEDGE))
		mode &= ACCESSPERMS;

	if ((error = getvnode(p, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = fp->f_data;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount && vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		VATTR_NULL(&vattr);
		vattr.va_mode = mode & ALLPERMS;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
	VOP_UNLOCK(vp, p);
	FRELE(fp, p);
	return (error);
}

/*
 * Set ownership given a path name.
 */
int
sys_chown(struct proc *p, void *v, register_t *retval)
{
	struct sys_chown_args /* {
		syscallarg(const char *) path;
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
	} */ *uap = v;

	return (dofchownat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, uid),
	    SCARG(uap, gid), 0));
}

int
sys_fchownat(struct proc *p, void *v, register_t *retval)
{
	struct sys_fchownat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
		syscallarg(int) flag;
	} */ *uap = v;

	return (dofchownat(p, SCARG(uap, fd), SCARG(uap, path),
	    SCARG(uap, uid), SCARG(uap, gid), SCARG(uap, flag)));
}

int
dofchownat(struct proc *p, int fd, const char *path, uid_t uid, gid_t gid,
    int flag)
{
	struct vnode *vp;
	struct vattr vattr;
	int error, follow;
	struct nameidata nd;
	mode_t mode;

	if (flag & ~AT_SYMLINK_NOFOLLOW)
		return (EINVAL);

	follow = (flag & AT_SYMLINK_NOFOLLOW) ? NOFOLLOW : FOLLOW;
	NDINITAT(&nd, LOOKUP, follow, UIO_USERSPACE, fd, path, p);
	nd.ni_pledge = PLEDGE_CHOWN | PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		if ((error = pledge_chown(p, uid, gid)))
			goto out;
		if ((uid != -1 || gid != -1) &&
		    (vp->v_mount->mnt_flag & MNT_NOPERM) == 0 &&
		    (suser(p, 0) || suid_clear)) {
			error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
			if (error)
				goto out;
			mode = vattr.va_mode & ~(VSUID | VSGID);
			if (mode == vattr.va_mode)
				mode = VNOVAL;
		} else
			mode = VNOVAL;
		VATTR_NULL(&vattr);
		vattr.va_uid = uid;
		vattr.va_gid = gid;
		vattr.va_mode = mode;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
out:
	vput(vp);
	return (error);
}

/*
 * Set ownership given a path name, without following links.
 */
int
sys_lchown(struct proc *p, void *v, register_t *retval)
{
	struct sys_lchown_args /* {
		syscallarg(const char *) path;
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;
	mode_t mode;
	uid_t uid = SCARG(uap, uid);
	gid_t gid = SCARG(uap, gid);

	NDINIT(&nd, LOOKUP, NOFOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	nd.ni_pledge = PLEDGE_CHOWN | PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		if ((error = pledge_chown(p, uid, gid)))
			goto out;
		if ((uid != -1 || gid != -1) &&
		    (vp->v_mount->mnt_flag & MNT_NOPERM) == 0 &&
		    (suser(p, 0) || suid_clear)) {
			error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
			if (error)
				goto out;
			mode = vattr.va_mode & ~(VSUID | VSGID);
			if (mode == vattr.va_mode)
				mode = VNOVAL;
		} else
			mode = VNOVAL;
		VATTR_NULL(&vattr);
		vattr.va_uid = uid;
		vattr.va_gid = gid;
		vattr.va_mode = mode;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
out:
	vput(vp);
	return (error);
}

/*
 * Set ownership given a file descriptor.
 */
int
sys_fchown(struct proc *p, void *v, register_t *retval)
{
	struct sys_fchown_args /* {
		syscallarg(int) fd;
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct file *fp;
	mode_t mode;
	uid_t uid = SCARG(uap, uid);
	gid_t gid = SCARG(uap, gid);

	if ((error = getvnode(p, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = fp->f_data;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		if ((error = pledge_chown(p, uid, gid)))
			goto out;
		if ((uid != -1 || gid != -1) &&
		    (vp->v_mount->mnt_flag & MNT_NOPERM) == 0 &&
		    (suser(p, 0) || suid_clear)) {
			error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
			if (error)
				goto out;
			mode = vattr.va_mode & ~(VSUID | VSGID);
			if (mode == vattr.va_mode)
				mode = VNOVAL;
		} else
			mode = VNOVAL;
		VATTR_NULL(&vattr);
		vattr.va_uid = uid;
		vattr.va_gid = gid;
		vattr.va_mode = mode;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
out:
	VOP_UNLOCK(vp, p);
	FRELE(fp, p);
	return (error);
}

/*
 * Set the access and modification times given a path name.
 */
int
sys_utimes(struct proc *p, void *v, register_t *retval)
{
	struct sys_utimes_args /* {
		syscallarg(const char *) path;
		syscallarg(const struct timeval *) tptr;
	} */ *uap = v;

	struct timespec ts[2];
	struct timeval tv[2];
	const struct timeval *tvp;
	int error;

	tvp = SCARG(uap, tptr);
	if (tvp != NULL) {
		error = copyin(tvp, tv, sizeof(tv));
		if (error)
			return (error);
		TIMEVAL_TO_TIMESPEC(&tv[0], &ts[0]);
		TIMEVAL_TO_TIMESPEC(&tv[1], &ts[1]);
	} else
		ts[0].tv_nsec = ts[1].tv_nsec = UTIME_NOW;

	return (doutimensat(p, AT_FDCWD, SCARG(uap, path), ts, 0));
}

int
sys_utimensat(struct proc *p, void *v, register_t *retval)
{
	struct sys_utimensat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(const struct timespec *) times;
		syscallarg(int) flag;
	} */ *uap = v;

	struct timespec ts[2];
	const struct timespec *tsp;
	int error;

	tsp = SCARG(uap, times);
	if (tsp != NULL) {
		error = copyin(tsp, ts, sizeof(ts));
		if (error)
			return (error);
	} else
		ts[0].tv_nsec = ts[1].tv_nsec = UTIME_NOW;

	return (doutimensat(p, SCARG(uap, fd), SCARG(uap, path), ts,
	    SCARG(uap, flag)));
}

int
doutimensat(struct proc *p, int fd, const char *path,
    struct timespec ts[2], int flag)
{
	struct vnode *vp;
	int error, follow;
	struct nameidata nd;

	if (flag & ~AT_SYMLINK_NOFOLLOW)
		return (EINVAL);

	follow = (flag & AT_SYMLINK_NOFOLLOW) ? NOFOLLOW : FOLLOW;
	NDINITAT(&nd, LOOKUP, follow, UIO_USERSPACE, fd, path, p);
	nd.ni_pledge = PLEDGE_FATTR | PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;

	return (dovutimens(p, vp, ts));
}

int
dovutimens(struct proc *p, struct vnode *vp, struct timespec ts[2])
{
	struct vattr vattr;
	struct timespec now;
	int error;

#ifdef KTRACE
	/* if they're both UTIME_NOW, then don't report either */
	if ((ts[0].tv_nsec != UTIME_NOW || ts[1].tv_nsec != UTIME_NOW) &&
	    KTRPOINT(p, KTR_STRUCT)) {
		ktrabstimespec(p, &ts[0]);
		ktrabstimespec(p, &ts[1]);
	}
#endif

	VATTR_NULL(&vattr);

	/*  make sure ctime is updated even if neither mtime nor atime is */
	vattr.va_vaflags = VA_UTIMES_CHANGE;

	if (ts[0].tv_nsec == UTIME_NOW || ts[1].tv_nsec == UTIME_NOW) {
		if (ts[0].tv_nsec == UTIME_NOW && ts[1].tv_nsec == UTIME_NOW)
			vattr.va_vaflags |= VA_UTIMES_NULL;

		getnanotime(&now);
		if (ts[0].tv_nsec == UTIME_NOW)
			ts[0] = now;
		if (ts[1].tv_nsec == UTIME_NOW)
			ts[1] = now;
	}

	if (ts[0].tv_nsec != UTIME_OMIT) {
		if (ts[0].tv_nsec < 0 || ts[0].tv_nsec >= 1000000000) {
			vrele(vp);
			return (EINVAL);
		}
		vattr.va_atime = ts[0];
	}
	if (ts[1].tv_nsec != UTIME_OMIT) {
		if (ts[1].tv_nsec < 0 || ts[1].tv_nsec >= 1000000000) {
			vrele(vp);
			return (EINVAL);
		}
		vattr.va_mtime = ts[1];
	}

	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	vput(vp);
	return (error);
}

/*
 * Set the access and modification times given a file descriptor.
 */
int
sys_futimes(struct proc *p, void *v, register_t *retval)
{
	struct sys_futimes_args /* {
		syscallarg(int) fd;
		syscallarg(const struct timeval *) tptr;
	} */ *uap = v;
	struct timeval tv[2];
	struct timespec ts[2];
	const struct timeval *tvp;
	int error;

	tvp = SCARG(uap, tptr);
	if (tvp != NULL) {
		error = copyin(tvp, tv, sizeof(tv));
		if (error)
			return (error);
		TIMEVAL_TO_TIMESPEC(&tv[0], &ts[0]);
		TIMEVAL_TO_TIMESPEC(&tv[1], &ts[1]);
	} else
		ts[0].tv_nsec = ts[1].tv_nsec = UTIME_NOW;

	return (dofutimens(p, SCARG(uap, fd), ts));
}

int
sys_futimens(struct proc *p, void *v, register_t *retval)
{
	struct sys_futimens_args /* {
		syscallarg(int) fd;
		syscallarg(const struct timespec *) times;
	} */ *uap = v;
	struct timespec ts[2];
	const struct timespec *tsp;
	int error;

	tsp = SCARG(uap, times);
	if (tsp != NULL) {
		error = copyin(tsp, ts, sizeof(ts));
		if (error)
			return (error);
	} else
		ts[0].tv_nsec = ts[1].tv_nsec = UTIME_NOW;

	return (dofutimens(p, SCARG(uap, fd), ts));
}

int
dofutimens(struct proc *p, int fd, struct timespec ts[2])
{
	struct file *fp;
	struct vnode *vp;
	int error;

	if ((error = getvnode(p, fd, &fp)) != 0)
		return (error);
	vp = fp->f_data;
	vref(vp);
	FRELE(fp, p);

	return (dovutimens(p, vp, ts));
}

/*
 * Truncate a file given its path name.
 */
int
sys_truncate(struct proc *p, void *v, register_t *retval)
{
	struct sys_truncate_args /* {
		syscallarg(const char *) path;
		syscallarg(int) pad;
		syscallarg(off_t) length;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	nd.ni_pledge = PLEDGE_FATTR | PLEDGE_RPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_type == VDIR)
		error = EISDIR;
	else if ((error = VOP_ACCESS(vp, VWRITE, p->p_ucred, p)) == 0 &&
	    (error = vn_writechk(vp)) == 0) {
		VATTR_NULL(&vattr);
		vattr.va_size = SCARG(uap, length);
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
	vput(vp);
	return (error);
}

/*
 * Truncate a file given a file descriptor.
 */
int
sys_ftruncate(struct proc *p, void *v, register_t *retval)
{
	struct sys_ftruncate_args /* {
		syscallarg(int) fd;
		syscallarg(int) pad;
		syscallarg(off_t) length;
	} */ *uap = v;
	struct vattr vattr;
	struct vnode *vp;
	struct file *fp;
	off_t len;
	int error;

	if ((error = getvnode(p, SCARG(uap, fd), &fp)) != 0)
		return (error);
	len = SCARG(uap, length);
	if ((fp->f_flag & FWRITE) == 0 || len < 0) {
		error = EINVAL;
		goto bad;
	}
	vp = fp->f_data;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_type == VDIR)
		error = EISDIR;
	else if ((error = vn_writechk(vp)) == 0) {
		VATTR_NULL(&vattr);
		vattr.va_size = len;
		error = VOP_SETATTR(vp, &vattr, fp->f_cred, p);
	}
	VOP_UNLOCK(vp, p);
bad:
	FRELE(fp, p);
	return (error);
}

/*
 * Sync an open file.
 */
int
sys_fsync(struct proc *p, void *v, register_t *retval)
{
	struct sys_fsync_args /* {
		syscallarg(int) fd;
	} */ *uap = v;
	struct vnode *vp;
	struct file *fp;
	int error;

	if ((error = getvnode(p, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = fp->f_data;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	error = VOP_FSYNC(vp, fp->f_cred, MNT_WAIT, p);
#ifdef FFS_SOFTUPDATES
	if (error == 0 && vp->v_mount && (vp->v_mount->mnt_flag & MNT_SOFTDEP))
		error = softdep_fsync(vp);
#endif

	VOP_UNLOCK(vp, p);
	FRELE(fp, p);
	return (error);
}

/*
 * Rename files.  Source and destination must either both be directories,
 * or both not be directories.  If target is a directory, it must be empty.
 */
int
sys_rename(struct proc *p, void *v, register_t *retval)
{
	struct sys_rename_args /* {
		syscallarg(const char *) from;
		syscallarg(const char *) to;
	} */ *uap = v;

	return (dorenameat(p, AT_FDCWD, SCARG(uap, from), AT_FDCWD,
	    SCARG(uap, to)));
}

int
sys_renameat(struct proc *p, void *v, register_t *retval)
{
	struct sys_renameat_args /* {
		syscallarg(int) fromfd;
		syscallarg(const char *) from;
		syscallarg(int) tofd;
		syscallarg(const char *) to;
	} */ *uap = v;

	return (dorenameat(p, SCARG(uap, fromfd), SCARG(uap, from),
	    SCARG(uap, tofd), SCARG(uap, to)));
}

int
dorenameat(struct proc *p, int fromfd, const char *from, int tofd,
    const char *to)
{
	struct vnode *tvp, *fvp, *tdvp;
	struct nameidata fromnd, tond;
	int error;
	int flags;

	NDINITAT(&fromnd, DELETE, WANTPARENT | SAVESTART, UIO_USERSPACE,
	    fromfd, from, p);
	fromnd.ni_pledge = PLEDGE_RPATH | PLEDGE_CPATH;
	if ((error = namei(&fromnd)) != 0)
		return (error);
	fvp = fromnd.ni_vp;

	flags = LOCKPARENT | LOCKLEAF | NOCACHE | SAVESTART;
	/*
	 * rename("foo/", "bar/");  is  OK
	 */
	if (fvp->v_type == VDIR)
		flags |= STRIPSLASHES;

	NDINITAT(&tond, RENAME, flags, UIO_USERSPACE, tofd, to, p);
	tond.ni_pledge = PLEDGE_CPATH;
	if ((error = namei(&tond)) != 0) {
		VOP_ABORTOP(fromnd.ni_dvp, &fromnd.ni_cnd);
		vrele(fromnd.ni_dvp);
		vrele(fvp);
		goto out1;
	}
	tdvp = tond.ni_dvp;
	tvp = tond.ni_vp;
	if (tvp != NULL) {
		if (fvp->v_type == VDIR && tvp->v_type != VDIR) {
			error = ENOTDIR;
			goto out;
		} else if (fvp->v_type != VDIR && tvp->v_type == VDIR) {
			error = EISDIR;
			goto out;
		}
	}
	if (fvp == tdvp)
		error = EINVAL;
	/*
	 * If source is the same as the destination (that is the
	 * same inode number)
	 */
	if (fvp == tvp)
		error = -1;
out:
	if (!error) {
		if (tvp) {
			(void)uvm_vnp_uncache(tvp);
		}
		error = VOP_RENAME(fromnd.ni_dvp, fromnd.ni_vp, &fromnd.ni_cnd,
				   tond.ni_dvp, tond.ni_vp, &tond.ni_cnd);
	} else {
		VOP_ABORTOP(tond.ni_dvp, &tond.ni_cnd);
		if (tdvp == tvp)
			vrele(tdvp);
		else
			vput(tdvp);
		if (tvp)
			vput(tvp);
		VOP_ABORTOP(fromnd.ni_dvp, &fromnd.ni_cnd);
		vrele(fromnd.ni_dvp);
		vrele(fvp);
	}
	vrele(tond.ni_startdir);
	pool_put(&namei_pool, tond.ni_cnd.cn_pnbuf);
out1:
	if (fromnd.ni_startdir)
		vrele(fromnd.ni_startdir);
	pool_put(&namei_pool, fromnd.ni_cnd.cn_pnbuf);
	if (error == -1)
		return (0);
	return (error);
}

/*
 * Make a directory file.
 */
int
sys_mkdir(struct proc *p, void *v, register_t *retval)
{
	struct sys_mkdir_args /* {
		syscallarg(const char *) path;
		syscallarg(mode_t) mode;
	} */ *uap = v;

	return (domkdirat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, mode)));
}

int
sys_mkdirat(struct proc *p, void *v, register_t *retval)
{
	struct sys_mkdirat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(mode_t) mode;
	} */ *uap = v;

	return (domkdirat(p, SCARG(uap, fd), SCARG(uap, path),
	    SCARG(uap, mode)));
}

int
domkdirat(struct proc *p, int fd, const char *path, mode_t mode)
{
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;

	NDINITAT(&nd, CREATE, LOCKPARENT | STRIPSLASHES, UIO_USERSPACE,
	    fd, path, p);
	nd.ni_pledge = PLEDGE_CPATH;
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if (vp != NULL) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vrele(vp);
		return (EEXIST);
	}
	VATTR_NULL(&vattr);
	vattr.va_type = VDIR;
	vattr.va_mode = (mode & ACCESSPERMS) &~ p->p_fd->fd_cmask;
	error = VOP_MKDIR(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &vattr);
	if (!error)
		vput(nd.ni_vp);
	return (error);
}

/*
 * Remove a directory file.
 */
int
sys_rmdir(struct proc *p, void *v, register_t *retval)
{
	struct sys_rmdir_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;

	return (dounlinkat(p, AT_FDCWD, SCARG(uap, path), AT_REMOVEDIR));
}

/*
 * Read a block of directory entries in a file system independent format.
 */
int
sys_getdents(struct proc *p, void *v, register_t *retval)
{
	struct sys_getdents_args /* {
		syscallarg(int) fd;
		syscallarg(void *) buf;
		syscallarg(size_t) buflen;
	} */ *uap = v;
	struct vnode *vp;
	struct file *fp;
	struct uio auio;
	struct iovec aiov;
	size_t buflen;
	int error, eofflag;

	buflen = SCARG(uap, buflen);

	if (buflen > INT_MAX)
		return EINVAL;
	if ((error = getvnode(p, SCARG(uap, fd), &fp)) != 0)
		return (error);
	if ((fp->f_flag & FREAD) == 0) {
		error = EBADF;
		goto bad;
	}
	if (fp->f_offset < 0) {
		error = EINVAL;
		goto bad;
	}
	vp = fp->f_data;
	if (vp->v_type != VDIR) {
		error = EINVAL;
		goto bad;
	}
	aiov.iov_base = SCARG(uap, buf);
	aiov.iov_len = buflen;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;
	auio.uio_resid = buflen;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	auio.uio_offset = fp->f_offset;
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag);
	fp->f_offset = auio.uio_offset;
	VOP_UNLOCK(vp, p);
	if (error)
		goto bad;
	*retval = buflen - auio.uio_resid;
bad:
	FRELE(fp, p);
	return (error);
}

/*
 * Set the mode mask for creation of filesystem nodes.
 */
int
sys_umask(struct proc *p, void *v, register_t *retval)
{
	struct sys_umask_args /* {
		syscallarg(mode_t) newmask;
	} */ *uap = v;
	struct filedesc *fdp;

	fdp = p->p_fd;
	*retval = fdp->fd_cmask;
	fdp->fd_cmask = SCARG(uap, newmask) & ACCESSPERMS;
	return (0);
}

/*
 * Void all references to file by ripping underlying filesystem
 * away from vnode.
 */
int
sys_revoke(struct proc *p, void *v, register_t *retval)
{
	struct sys_revoke_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;
	struct vnode *vp;
	struct vattr vattr;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	nd.ni_pledge = PLEDGE_RPATH | PLEDGE_TTY;
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if (vp->v_type != VCHR || (u_int)major(vp->v_rdev) >= nchrdev ||
	    cdevsw[major(vp->v_rdev)].d_type != D_TTY) {
		error = ENOTTY;
		goto out;
	}
	if ((error = VOP_GETATTR(vp, &vattr, p->p_ucred, p)) != 0)
		goto out;
	if (p->p_ucred->cr_uid != vattr.va_uid &&
	    (error = suser(p, 0)))
		goto out;
	if (vp->v_usecount > 1 || (vp->v_flag & (VALIASED)))
		VOP_REVOKE(vp, REVOKEALL);
out:
	vrele(vp);
	return (error);
}

/*
 * Convert a user file descriptor to a kernel file entry.
 *
 * On return *fpp is FREF:ed.
 */
int
getvnode(struct proc *p, int fd, struct file **fpp)
{
	struct file *fp;
	struct vnode *vp;

	if ((fp = fd_getfile(p->p_fd, fd)) == NULL)
		return (EBADF);

	if (fp->f_type != DTYPE_VNODE)
		return (EINVAL);

	vp = fp->f_data;
	if (vp->v_type == VBAD)
		return (EBADF);

	FREF(fp);
	*fpp = fp;

	return (0);
}

/*
 * Positional read system call.
 */
int
sys_pread(struct proc *p, void *v, register_t *retval)
{
	struct sys_pread_args /* {
		syscallarg(int) fd;
		syscallarg(void *) buf;
		syscallarg(size_t) nbyte;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
	} */ *uap = v;
	struct iovec iov;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	off_t offset;
	int fd = SCARG(uap, fd);

	if ((fp = fd_getfile_mode(fdp, fd, FREAD)) == NULL)
		return (EBADF);

	vp = fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO ||
	    (vp->v_flag & VISTTY)) {
		return (ESPIPE);
	}

	iov.iov_base = SCARG(uap, buf);
	iov.iov_len = SCARG(uap, nbyte);

	offset = SCARG(uap, offset);
	if (offset < 0 && vp->v_type != VCHR)
		return (EINVAL);

	FREF(fp);

	/* dofilereadv() will FRELE the descriptor for us */
	return (dofilereadv(p, fd, fp, &iov, 1, 0, &offset, retval));
}

/*
 * Positional scatter read system call.
 */
int
sys_preadv(struct proc *p, void *v, register_t *retval)
{
	struct sys_preadv_args /* {
		syscallarg(int) fd;
		syscallarg(const struct iovec *) iovp;
		syscallarg(int) iovcnt;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	off_t offset;
	int fd = SCARG(uap, fd);

	if ((fp = fd_getfile_mode(fdp, fd, FREAD)) == NULL)
		return (EBADF);

	vp = fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO ||
	    (vp->v_flag & VISTTY)) {
		return (ESPIPE);
	}

	offset = SCARG(uap, offset);
	if (offset < 0 && vp->v_type != VCHR)
		return (EINVAL);

	FREF(fp);

	/* dofilereadv() will FRELE the descriptor for us */
	return (dofilereadv(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt), 1,
	    &offset, retval));
}

/*
 * Positional write system call.
 */
int
sys_pwrite(struct proc *p, void *v, register_t *retval)
{
	struct sys_pwrite_args /* {
		syscallarg(int) fd;
		syscallarg(const void *) buf;
		syscallarg(size_t) nbyte;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
	} */ *uap = v;
	struct iovec iov;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	off_t offset;
	int fd = SCARG(uap, fd);

	if ((fp = fd_getfile_mode(fdp, fd, FWRITE)) == NULL)
		return (EBADF);

	vp = fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO ||
	    (vp->v_flag & VISTTY)) {
		return (ESPIPE);
	}

	iov.iov_base = (void *)SCARG(uap, buf);
	iov.iov_len = SCARG(uap, nbyte);

	offset = SCARG(uap, offset);
	if (offset < 0 && vp->v_type != VCHR)
		return (EINVAL);

	FREF(fp);

	/* dofilewritev() will FRELE the descriptor for us */
	return (dofilewritev(p, fd, fp, &iov, 1, 0, &offset, retval));
}

/*
 * Positional gather write system call.
 */
int
sys_pwritev(struct proc *p, void *v, register_t *retval)
{
	struct sys_pwritev_args /* {
		syscallarg(int) fd;
		syscallarg(const struct iovec *) iovp;
		syscallarg(int) iovcnt;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	off_t offset;
	int fd = SCARG(uap, fd);

	if ((fp = fd_getfile_mode(fdp, fd, FWRITE)) == NULL)
		return (EBADF);

	vp = fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO ||
	    (vp->v_flag & VISTTY)) {
		return (ESPIPE);
	}

	offset = SCARG(uap, offset);
	if (offset < 0 && vp->v_type != VCHR)
		return (EINVAL);

	FREF(fp);

	/* dofilewritev() will FRELE the descriptor for us */
	return (dofilewritev(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
	    1, &offset, retval));
}
@


1.270
log
@Add a flags argument to falloc() that lets it optionally set the
close-on-exec flag on the newly allocated fd.  Make falloc()'s
return arguments non-optional: assert that they're not NULL.

ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.269 2017/01/23 22:34:10 deraadt Exp $	*/
d283 1
a283 1
 * we've finished walking the allproc list.
d290 1
a290 1
	struct proc *p;
d297 2
a298 2
	LIST_FOREACH(p, &allproc, p_list) {
		fdp = p->p_fd;
@


1.269
log
@Avoid curproc dance in dupfdopen(), by passing a struct proc *
ok guenther mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.268 2017/01/15 23:18:05 bluhm Exp $	*/
d805 2
a806 1
	if ((error = falloc(p, &fp, &indx)) != 0)
a815 3
	if (flags & O_CLOEXEC)
		fdp->fd_ofileflags[indx] |= UF_EXCLOSE;

d971 2
a972 1
	if ((error = falloc(p, &fp, &indx)) != 0) {
a975 2
	if (flags & O_CLOEXEC)
		fdp->fd_ofileflags[indx] |= UF_EXCLOSE;
@


1.268
log
@When traversing the mount list, the current mount point is locked
with vfs_busy().  If the FOREACH_SAFE macro is used, the next pointer
is not locked and could be freed by another process.  Unless
necessary, do not use _SAFE as it is unsafe.  In vfs_unmountall()
the current pointer is actullay freed.  Add a comment that this
race has to be fixed later.
OK krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.267 2017/01/10 20:13:17 bluhm Exp $	*/
d832 1
a832 1
			dupfdopen(fdp, indx, p->p_dupfd, flags)) == 0) {
@


1.267
log
@Fix white spaces.  No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.266 2017/01/10 19:48:32 bluhm Exp $	*/
d428 1
a428 1
	struct mount *mp, *nmp;
d431 1
a431 1
	TAILQ_FOREACH_REVERSE_SAFE(mp, &mountlist, mntlist, mnt_list, nmp) {
d573 1
a573 1
	struct mount *mp, *nmp;
d583 1
a583 1
	TAILQ_FOREACH_SAFE(mp, &mountlist, mnt_list, nmp) {
@


1.266
log
@Remove the unused olddp parameter from function dounmount().
OK mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.265 2016/09/10 16:53:30 natano Exp $	*/
d261 2
a262 2
 		if ((mp->mnt_flag & MNT_RDONLY) == 0)
 			error = vfs_allocate_syncvnode(mp);
d381 3
a383 3
 	mp->mnt_flag &=~ MNT_ASYNC;
 	cache_purgevfs(mp);	/* remove cache entries for this file sys */
 	if (mp->mnt_syncer != NULL) {
d385 1
a385 1
 		vgone(mp->mnt_syncer);
d390 2
a391 2
 	    (flags & MNT_FORCE))
 		error = VFS_UNMOUNT(mp, flags, p);
d393 3
a395 3
 	if (error && !(flags & MNT_DOOMED)) {
 		if ((mp->mnt_flag & MNT_RDONLY) == 0 && hadsyncer)
 			(void) vfs_allocate_syncvnode(mp);
d403 2
a404 2
 		vrele(coveredvp);
 	}
d596 1
a596 1
 				continue;
a2968 1

@


1.265
log
@Add a noperm mount flag for FFS to be used for building release sets
without root privileges. This is only the kernel/mount flag; additional
work in the build Makefile's will be necessary such that the files in
$DESTDIR are created with correct permissions.

tedu couldn't find anything wrong with it in a quick review
idea & ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.264 2016/09/07 17:30:12 natano Exp $	*/
d368 1
a368 1
	return (dounmount(mp, SCARG(uap, flags) & MNT_FORCE, p, vp));
d375 1
a375 1
dounmount(struct mount *mp, int flags, struct proc *p, struct vnode *olddp)
@


1.264
log
@Remove usermount remnants. ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.263 2016/07/14 15:39:40 deraadt Exp $	*/
d159 9
d217 1
a217 1
	    MNT_FORCE);
d220 1
a220 1
	    MNT_NOATIME | MNT_FORCE);
a1177 6
	if (!S_ISFIFO(mode) || dev != 0) {
		if ((error = suser(p, 0)) != 0)
			return (error);
		if (p->p_fd->fd_rdir)
			return (EINVAL);
	}
d1185 9
d1229 1
d2064 1
d2116 1
d2166 1
@


1.263
log
@kern.usermount=1 is unsafe for everyone, since it allows any non-pledged
program to call the mount/umount system calls.  There is no way any user
can be expected to keep their system safe / reliable with this feature.
Ignore setting to =1, and after release we'll delete the sysctl entirely.
ok lots of people
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.262 2016/07/12 20:53:04 millert Exp $	*/
a112 1
	struct vattr va;
a151 23
		/*
		 * Only root, or the user that did the original mount is
		 * permitted to update it.
		 */
		if (mp->mnt_stat.f_owner != p->p_ucred->cr_uid &&
		    (error = suser(p, 0))) {
			vput(vp);
			return (error);
		}
		/*
		 * Do not allow NFS export by non-root users. Silently
		 * enforce MNT_NOSUID and MNT_NODEV for non-root users, and
		 * inherit MNT_NOEXEC from the mount point.
		 */
		if (suser(p, 0) != 0) {
			if (flags & MNT_EXPORTED) {
				vput(vp);
				return (EPERM);
			}
			flags |= MNT_NOSUID | MNT_NODEV;
			if (mntflag & MNT_NOEXEC)
				flags |= MNT_NOEXEC;
		}
a158 24
	/*
	 * If the user is not root, ensure that they own the directory
	 * onto which we are attempting to mount.
	 */
	if ((error = VOP_GETATTR(vp, &va, p->p_ucred, p)) ||
	    (va.va_uid != p->p_ucred->cr_uid &&
	    (error = suser(p, 0)))) {
		vput(vp);
		return (error);
	}
	/*
	 * Do not allow NFS export by non-root users. Silently
	 * enforce MNT_NOSUID and MNT_NODEV for non-root users, and inherit
	 * MNT_NOEXEC from the mount point.
	 */
	if (suser(p, 0) != 0) {
		if (flags & MNT_EXPORTED) {
			vput(vp);
			return (EPERM);
		}
		flags |= MNT_NOSUID | MNT_NODEV;
		if (vp->v_mount->mnt_flag & MNT_NOEXEC)
			flags |= MNT_NOEXEC;
	}
d329 3
a337 10

	/*
	 * Only root, or the user that did the original mount is
	 * permitted to unmount this filesystem.
	 */
	if ((mp->mnt_stat.f_owner != p->p_ucred->cr_uid) &&
	    (error = suser(p, 0))) {
		vput(vp);
		return (error);
	}
@


1.262
log
@The only valid flag for unmount(2) is MNT_FORCE, ignore any others.
Fixes a crash when MNT_DOOMED is passed in the flags to unmount(2)
found by NCC Group.  OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.261 2016/07/06 19:26:35 millert Exp $	*/
a65 1
int	usermount = 0;		/* sysctl: by default, users may not mount */
d118 1
a118 1
	if (usermount == 0 && (error = suser(p, 0)))
@


1.261
log
@Return EINVAL for mknod/mknodat when dev is -1 (aka VNOVAL).
OK beck@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.260 2016/07/03 04:36:08 semarie Exp $	*/
d415 1
a415 1
	return (dounmount(mp, SCARG(uap, flags), p, vp));
@


1.260
log
@introduces new promise "chown" to allow changing owner/group with *chown(2) family

it splits PLEDGE_FATTR in two ("fattr" stills grant the 2 flags, so no functional changes):
  - PLEDGE_CHOWN : to be able to call *chown(2) syscalls
  - PLEDGE_FATTR : the rest

it introduces "chown" which grant:
  - PLEDGE_CHOWN : be able to call *chown(2)
  - PLEDGE_CHOWNUID : be able to modifying owner/group

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.259 2016/06/27 04:26:41 semarie Exp $	*/
d1231 2
@


1.259
log
@dovutimens: call vrele(9) before returning EINVAL

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.258 2016/06/27 04:14:38 semarie Exp $	*/
d2094 1
a2094 1
	nd.ni_pledge = PLEDGE_FATTR | PLEDGE_RPATH;
d2145 1
a2145 1
	nd.ni_pledge = PLEDGE_FATTR | PLEDGE_RPATH;
@


1.258
log
@sys_revoke: call vrele() before returning ENOTTY

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.257 2016/06/26 14:27:14 semarie Exp $	*/
d2335 2
a2336 1
		if (ts[0].tv_nsec < 0 || ts[0].tv_nsec >= 1000000000)
d2338 1
d2342 2
a2343 1
		if (ts[1].tv_nsec < 0 || ts[1].tv_nsec >= 1000000000)
d2345 1
@


1.257
log
@use error code path instead of return early without calling VOP_ABORTOP() and
vrele()/vput().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.256 2016/06/01 22:54:45 millert Exp $	*/
d2799 4
a2802 2
	    cdevsw[major(vp->v_rdev)].d_type != D_TTY)
		return (ENOTTY);
@


1.256
log
@rmdir(2) should return EINVAL not EBUSY when trying to remove ".".
This brings us back in conformance with POSIX rmdir(2) and rmdirat(2).
OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.255 2016/05/27 19:45:04 deraadt Exp $	*/
d1257 2
a1258 1
			return (EOPNOTSUPP);
@


1.255
log
@W^X violations are no longer permitted by default.  A kernel log message
is generated, and mprotect/mmap return ENOTSUP.  If the sysctl(8) flag
kern.wxabort is set then a SIGABRT occurs instead, for gdb use or coredump
creation.

W^X violating programs can be permitted on a ffs/nfs filesystem-basis,
using the "wxallowed" mount option.  One day far in the future
upstream software developers will understand that W^X violations are a
tremendously risky practice and that style of programming will be
banished outright.  Until then, we recommend most users need to use the
wxallowed option on their /usr/local filesystem.  At least your other
filesystems don't permit such programs.

ok jca kettenis mlarkin natano
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.254 2016/05/15 05:04:28 semarie Exp $	*/
d1499 1
a1499 1
			error = EBUSY;
@


1.254
log
@remove chroot(2) from allowed syscalls under pledge(2).

please note that chrooted process are still possible with pledge(2), but only
if the chroot(2) is done *before* calling pledge(2). Once pledged, no more
chroot(2) call are permitted.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.253 2016/03/27 11:39:37 bluhm Exp $	*/
d255 1
a255 1
	mp->mnt_flag &=~ (MNT_NOSUID | MNT_NOEXEC | MNT_NODEV |
d258 1
a258 1
	mp->mnt_flag |= flags & (MNT_NOSUID | MNT_NOEXEC |
@


1.253
log
@When pulling and unmounting an umass USB stick, the file system
could end up in an inconsistent state.  The fstype dependent
mp->mnt_data was NULL, but the general mp was still listed as a
valid mount point.  Next access to the file system would crash with
a NULL pointer dereference.
If closing the device fails, the mount point must go away anyway.
There is nothing we can do about it.  Remove the workaround for the
EIO error in the general unmount code, but do not generate any error
in the file system specific unmount functions.
OK natano@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.252 2016/03/19 12:04:15 natano Exp $	*/
a757 1
	nd.ni_pledge = PLEDGE_ID | PLEDGE_PROC | PLEDGE_RPATH;
@


1.252
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.251 2016/01/06 17:59:30 tedu Exp $	*/
d440 1
a440 1
 	if (error && error != EIO && !(flags & MNT_DOOMED)) {
@


1.251
log
@remove unnecessary casts where the incoming type is void *.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.250 2016/01/02 00:24:16 deraadt Exp $	*/
d300 1
a300 1
		VOP_UNLOCK(vp, 0, p);
d708 1
a708 1
	VOP_UNLOCK(vp, 0, p);
d796 1
a796 1
		VOP_UNLOCK(vp, 0, p);
d908 1
a908 1
		VOP_UNLOCK(vp, 0, p);
d932 1
a932 1
			VOP_UNLOCK(vp, 0, p);
d939 1
a939 1
	VOP_UNLOCK(vp, 0, p);
d1092 1
a1092 1
		VOP_UNLOCK(vp, 0, p);
d1101 1
a1101 1
	VOP_UNLOCK(vp, 0, p);
d2043 1
a2043 1
	VOP_UNLOCK(vp, 0, p);
d2221 1
a2221 1
	VOP_UNLOCK(vp, 0, p);
d2487 1
a2487 1
	VOP_UNLOCK(vp, 0, p);
d2516 1
a2516 1
	VOP_UNLOCK(vp, 0, p);
d2752 1
a2752 1
	VOP_UNLOCK(vp, 0, p);
@


1.250
log
@mmcc noticed that nd.ni_pledge was uninitialized in doopenat() for the
oflags & 3 == 3 case. Therefore this depends on vn_open() blocking the
operation later.  Probably this meant the ni_pledge request would be too
high, causing transient operation failure, rather than transient operation
passage).  Instead of initializing based on the oflags value use the
result of FFLAGS().  I should have done this from the start.
ok semarie
[oflags & 3 == 3 is major dejavu for me]
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.249 2015/12/16 15:52:51 semarie Exp $	*/
d687 1
a687 1
	vp = (struct vnode *)fp->f_data;
d1553 1
a1553 1
	vp = (struct vnode *)fp->f_data;
d2034 1
a2034 1
	vp = (struct vnode *)fp->f_data;
d2197 1
a2197 1
	vp = (struct vnode *)fp->f_data;
d2413 1
a2413 1
	vp = (struct vnode *)fp->f_data;
d2478 1
a2478 1
	vp = (struct vnode *)fp->f_data;
d2508 1
a2508 1
	vp = (struct vnode *)fp->f_data;
d2830 1
a2830 1
	vp = (struct vnode *)fp->f_data;
d2863 1
a2863 1
	vp = (struct vnode *)fp->f_data;
d2904 1
a2904 1
	vp = (struct vnode *)fp->f_data;
d2944 1
a2944 1
	vp = (struct vnode *)fp->f_data;
d2985 1
a2985 1
	vp = (struct vnode *)fp->f_data;
@


1.249
log
@in pledged process, setuid/setgid/sticky bits should be ignored.

enforce it for open(2) when used with O_CREAT and mode.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.248 2015/12/16 08:27:32 semarie Exp $	*/
d843 1
a843 15
	int ni_pledge;

	switch (oflags & O_ACCMODE) {
	case O_RDONLY:
		ni_pledge = PLEDGE_RPATH;
		break;
	case O_WRONLY:
		ni_pledge = PLEDGE_WPATH;
		break;
	case O_RDWR:
		ni_pledge = PLEDGE_RPATH | PLEDGE_WPATH;
		break;
	}
	if (oflags & O_CREAT)
		ni_pledge |= PLEDGE_CPATH;
d856 7
@


1.248
log
@in pledged process, setuid/setgid/sticky bits should be ignored.

enforce it for mkfifo(2) and mknod(2) (with "dpath" promise).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.247 2015/12/05 10:11:53 tedu Exp $	*/
d874 2
@


1.247
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.246 2015/12/04 07:33:05 deraadt Exp $	*/
d1247 2
@


1.246
log
@Add pledge "dpath", which provides access to mknod(2) and mkfifo(2).
This will be required to keep pax/tar/cpio at otherwise very high levels
of pledge (and we will see where else it is beneficial).
Allocate a bit for pledge "audio", which will be coming soon.
good discussions with semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.245 2015/11/20 07:11:52 deraadt Exp $	*/
a99 1
/* ARGSUSED */
a365 1
/* ARGSUSED */
a471 1
/* ARGSUSED */
a497 1
/* ARGSUSED */
a550 1
/* ARGSUSED */
a579 1
/* ARGSUSED */
a672 1
/* ARGSUSED */
a717 1
/* ARGSUSED */
a742 1
/* ARGSUSED */
a1123 1
/* ARGSUSED */
a1157 1
/* ARGSUSED */
a1195 1
/* ARGSUSED */
a1290 1
/* ARGSUSED */
a1318 1
/* ARGSUSED */
a1392 1
/* ARGSUSED */
a1453 1
/* ARGSUSED */
a1686 1
/* ARGSUSED */
a1755 1
/* ARGSUSED */
a1770 1
/* ARGSUSED */
a1793 1
/* ARGSUSED */
a1955 1
/* ARGSUSED */
a2016 1
/* ARGSUSED */
a2053 1
/* ARGSUSED */
a2130 1
/* ARGSUSED */
a2181 1
/* ARGSUSED */
a2231 1
/* ARGSUSED */
a2359 1
/* ARGSUSED */
a2425 1
/* ARGSUSED */
a2459 1
/* ARGSUSED */
a2498 1
/* ARGSUSED */
a2527 1
/* ARGSUSED */
a2636 1
/* ARGSUSED */
a2695 1
/* ARGSUSED */
a2784 1
/* ARGSUSED */
@


1.245
log
@VISTTY check in revoke() is not working well for the non-indirected
/dev/console case, so go back to doing the direct D_TTY check.
signed over a few times with guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.244 2015/11/20 06:29:56 jsg Exp $	*/
d1250 1
@


1.244
log
@Fix whitespace.  No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.243 2015/11/18 06:57:24 deraadt Exp $	*/
d45 1
d61 1
d2834 3
a2838 4
	if (!(vp->v_flag & VISTTY)) {
		error = ENOTTY;
		goto out;
	}
@


1.243
log
@In sys_revoke, inspect the VISTTY flag on the backside of VOP_GETATTR,
because that shows the /dev/console translated vnode.
You either already know the story, or you don't want to know.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.242 2015/11/16 18:29:35 deraadt Exp $	*/
d276 8
a283 8
 		if ((mp->mnt_flag & MNT_RDONLY) == 0) {
 			if (mp->mnt_syncer == NULL)
 				error = vfs_allocate_syncvnode(mp);
 		} else {
 			if (mp->mnt_syncer != NULL)
 				vgone(mp->mnt_syncer);
 			mp->mnt_syncer = NULL;
 		}
@


1.242
log
@Permit revoke(2) for a pledge "rpath tty"
ok millert semarie tedu guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.240 2015/11/14 22:23:22 deraadt Exp $	*/
a2831 2
	if (!(vp->v_flag & VISTTY))
		return (ENOTTY);
d2834 4
@


1.241
log
@Only perform revoke(2) on tty cdevs.  Others paths return ENOTTY.
ok millert semarie tedu guenther
@
text
@d2828 1
@


1.240
log
@Add pathconf() to pledge "rpath"; ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.239 2015/11/02 16:31:55 semarie Exp $	*/
d2831 2
@


1.239
log
@move the pledgenote annotation from `struct proc' to `struct nameidata'

pledgenote is used for annotate the policy for a namei context. So make it
tracking the nameidata.

It is expected for the caller to explicitly define the policy. It is a kernel
bug to not do so.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.238 2015/11/01 19:03:33 semarie Exp $	*/
d1799 1
@


1.238
log
@refactor pledge_*_check and pledge_fail functions

- rename _check function without suffix: a "pledge" function called from
  anywhere is a "check" function.

- makes pledge_fail call the responsability to the _check function. remove it
  from caller.

- make proper use of (potential) returned error of _check() functions.

- adds pledge_kill() and pledge_protexec()

with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.237 2015/10/28 18:41:16 deraadt Exp $	*/
a565 1
	p->p_pledgenote = PLEDGE_RPATH;
d567 1
a734 1
	p->p_pledgenote = PLEDGE_RPATH;
d737 1
a762 1
	p->p_pledgenote = PLEDGE_ID | PLEDGE_PROC | PLEDGE_RPATH;
d765 1
d850 1
d854 1
a854 1
		p->p_pledgenote = PLEDGE_RPATH;
d857 1
a857 1
		p->p_pledgenote = PLEDGE_WPATH;
d860 1
a860 1
		p->p_pledgenote = PLEDGE_RPATH | PLEDGE_WPATH;
d864 1
a864 1
		p->p_pledgenote |= PLEDGE_CPATH;
d882 1
a1308 1
	p->p_pledgenote = PLEDGE_CPATH | PLEDGE_RPATH;
a1369 1
	p->p_pledgenote = PLEDGE_RPATH;
d1371 1
a1380 1
	p->p_pledgenote = PLEDGE_CPATH;
d1382 1
a1440 1
	p->p_pledgenote = PLEDGE_CPATH;
d1442 1
a1499 1
	p->p_pledgenote = PLEDGE_CPATH;
d1502 1
a1666 1
	p->p_pledgenote = PLEDGE_RPATH;
d1668 1
a1737 1
	p->p_pledgenote = PLEDGE_RPATH;
d1739 1
d1746 1
a1746 1
	if (p->p_pledgenote & PLEDGE_STATLIE) {
a1846 1
	p->p_pledgenote = PLEDGE_RPATH;
d1848 1
a1909 1
	p->p_pledgenote = PLEDGE_FATTR | PLEDGE_RPATH;
d1911 1
a2013 1
	p->p_pledgenote = PLEDGE_FATTR | PLEDGE_RPATH;
d2015 1
a2114 1
	p->p_pledgenote = PLEDGE_FATTR | PLEDGE_RPATH;
d2116 1
a2166 1
	p->p_pledgenote = PLEDGE_FATTR | PLEDGE_RPATH;
d2168 1
a2317 1
	p->p_pledgenote = PLEDGE_FATTR | PLEDGE_RPATH;
d2319 1
a2462 1
	p->p_pledgenote = PLEDGE_FATTR | PLEDGE_RPATH;
d2464 1
a2589 1
	p->p_pledgenote = PLEDGE_RPATH | PLEDGE_CPATH;
d2592 1
a2603 1
	p->p_pledgenote = PLEDGE_CPATH;
d2605 1
a2696 1
	p->p_pledgenote = PLEDGE_CPATH;
d2699 1
@


1.237
log
@mkdir is PLEDGE_CPATH, not PLEDGE_CPATH | PLEDGE_RPATH...
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.236 2015/10/28 14:17:52 semarie Exp $	*/
d866 1
a866 1
		error = pledge_flock_check(p);
d2123 1
a2123 1
		if ((error = pledge_chown_check(p, uid, gid)))
d2175 1
a2175 1
		if ((error = pledge_chown_check(p, uid, gid)))
d2225 1
a2225 1
		if ((error = pledge_chown_check(p, uid, gid)))
@


1.236
log
@remove duplicate setting of p_pledgenote:

- in sys_access() which call dofaccessat() and where the same note is already setted
- in sys_mkdir() which call domkdirat() and where the same note is already setted
- in sys_rmdir() which call dounlinkat() and where the same note is already setted

it makes the p_pledgenote affectation be near NDINIT/NDINITAT call.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.235 2015/10/28 14:07:58 semarie Exp $	*/
d2696 1
a2696 1
	p->p_pledgenote = PLEDGE_CPATH | PLEDGE_RPATH;
@


1.235
log
@make sys_chroot() only allowed to be used when pledged, with "rpath id proc".

the previous check in pledge_namei() was incomplete. For using SYS_chroot we
needed "id", and we could have passed pledge_namei() just with "rpath" (without
using the now removed whitelisted entry).

the check for "rpath id proc" is now done using p_pledgenote: pledge_namei()
will check that the pledgenote is permitted by your pledge.

"go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.234 2015/10/28 11:18:58 deraadt Exp $	*/
a1619 1
	p->p_pledgenote = PLEDGE_RPATH;
a2671 1
	p->p_pledgenote = PLEDGE_CPATH | PLEDGE_RPATH;
a2730 1
	p->p_pledgenote = PLEDGE_CPATH;
@


1.234
log
@Set pledgenote to PLEDGE_RPATH in chdir & chroot
noticed by semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.233 2015/10/25 20:39:54 deraadt Exp $	*/
d763 1
a763 1
	p->p_pledgenote = PLEDGE_RPATH;
@


1.233
log
@Fold "malloc" into "stdio" and -- recognizing that no program so far has
used less than "stdio" -- include all the "self" operations.  Instead of
different defines, use regular PLEDGE_* in the "p_pledgenote" variable
(which indicates the operation subtype a system call is performing).  Many
checks before easier to understand.  p_pledgenote can often be passed
directly to ktrace, so that kdump says:
 15565 test     CALL  pledge(0xa9a3f804c51,0)
 15565 test     STRU  pledge request="stdio"
 15565 test     RET   pledge 0
 15565 test     CALL  open(0xa9a3f804c57,0x2<O_RDWR>)
 15565 test     NAMI  "/tmp/testfile"
 15565 test     PLDG  open, "wpath", errno 1 Operation not permitted
with help from semarie, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.232 2015/10/20 06:40:00 semarie Exp $	*/
d735 1
d763 1
@


1.232
log
@clear whitelisted-paths view in pledge.

the following diff adds a clear view of whitelisted-paths in pledge.

before, whitelisting "/usr/local/bin" path would make only "/usr/local/bin"
VNODE was present and let "/usr/local", "/usr", and "/" been ENOENT. It was a
somehow odd filesystem hierarchy, and it breaks realpath(3).

with this diff, the directories that are one of the parents of a
whitelisted-directory become visible to stat(2) related syscalls, but only
with restricted permissions: stat(2) will lie a bit, and saying they owned by
root:wheel and mode is --x--x--x. Note that only stat(2) is affected by this
"view", and the owner/mode aren't effectively changed: it is just a "lie".

while here, refactor a bit pledge_namei() in order to avoid multiple for-loop
on whitelisted-path array.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.231 2015/10/16 13:37:43 millert Exp $	*/
d566 1
a566 1
	p->p_pledgenote = TMN_RPATH;
d851 1
a851 1
		p->p_pledgenote = TMN_RPATH;
d854 1
a854 1
		p->p_pledgenote = TMN_WPATH;
d857 1
a857 1
		p->p_pledgenote = TMN_RPATH | TMN_WPATH;
d861 1
a861 1
		p->p_pledgenote |= TMN_CPATH;
d1305 1
a1305 1
	p->p_pledgenote = TMN_CPATH | TMN_RPATH;
d1367 1
a1367 1
	p->p_pledgenote = TMN_RPATH;
d1378 1
a1378 1
	p->p_pledgenote = TMN_CPATH;
d1438 1
a1438 1
	p->p_pledgenote = TMN_CPATH;
d1497 1
a1497 1
	p->p_pledgenote = TMN_CPATH;
d1618 1
a1618 1
	p->p_pledgenote = TMN_RPATH;
d1665 1
a1665 1
	p->p_pledgenote = TMN_RPATH;
d1736 1
a1736 1
	p->p_pledgenote = TMN_RPATH;
d1744 1
a1744 1
	if (p->p_pledgenote & TMN_STATLIE) {
d1845 1
a1845 1
	p->p_pledgenote = TMN_RPATH;
d1908 1
a1908 1
	p->p_pledgenote = TMN_FATTR | TMN_RPATH;
d2012 1
a2012 1
	p->p_pledgenote = TMN_FATTR | TMN_RPATH;
d2113 1
a2113 1
	p->p_pledgenote = TMN_FATTR | TMN_RPATH;
d2165 1
a2165 1
	p->p_pledgenote = TMN_FATTR | TMN_RPATH;
d2316 1
a2316 1
	p->p_pledgenote = TMN_FATTR | TMN_RPATH;
d2461 1
a2461 1
	p->p_pledgenote = TMN_FATTR | TMN_RPATH;
d2588 1
a2588 1
	p->p_pledgenote = TMN_RPATH | TMN_CPATH;
d2602 1
a2602 1
	p->p_pledgenote = TMN_CPATH;
d2671 1
a2671 1
	p->p_pledgenote = TMN_CPATH | TMN_RPATH;
d2696 1
a2696 1
	p->p_pledgenote = TMN_CPATH | TMN_RPATH;
d2731 1
a2731 1
	p->p_pledgenote = TMN_CPATH;
@


1.231
log
@Implement real "flock" request and add it to userland programs that
use pledge and file locking.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.230 2015/10/14 14:24:03 deraadt Exp $	*/
d1744 10
@


1.230
log
@When pledged with "fattr", allow chown to supplimentary groups.  This
came out of a discussion regarding "sort foo -o foo".
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.229 2015/10/09 01:10:27 deraadt Exp $	*/
d862 6
@


1.229
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.228 2015/10/06 14:39:07 deraadt Exp $	*/
d52 1
d2106 1
a2106 4
		if ((p->p_p->ps_flags & PS_PLEDGE) &&
		    ((uid != -1 && uid != p->p_ucred->cr_uid) ||
		     (gid != -1 && gid != p->p_ucred->cr_gid))) {
			error = EPERM;
a2107 1
		}
d2158 1
a2158 4
		if ((p->p_p->ps_flags & PS_PLEDGE) &&
		    ((uid != -1 && uid != p->p_ucred->cr_uid) ||
		     (gid != -1 && gid != p->p_ucred->cr_gid))) {
			error = EPERM;
a2159 1
		}
d2208 1
a2208 4
		if ((p->p_p->ps_flags & PS_PLEDGE) &&
		    ((uid != -1 && uid != p->p_ucred->cr_uid) ||
		     (gid != -1 && gid != p->p_ucred->cr_gid))) {
			error = EPERM;
a2209 1
		}
@


1.228
log
@rmdir() is just a CPATH operation; remove RPATH marker that snuck in.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.227 2015/08/31 16:13:11 deraadt Exp $	*/
d565 1
a565 1
	p->p_tamenote = TMN_RPATH;
d850 1
a850 1
		p->p_tamenote = TMN_RPATH;
d853 1
a853 1
		p->p_tamenote = TMN_WPATH;
d856 1
a856 1
		p->p_tamenote = TMN_RPATH | TMN_WPATH;
d860 1
a860 1
		p->p_tamenote |= TMN_CPATH;
d1298 1
a1298 1
	p->p_tamenote = TMN_CPATH | TMN_RPATH;
d1360 1
a1360 1
	p->p_tamenote = TMN_RPATH;
d1371 1
a1371 1
	p->p_tamenote = TMN_CPATH;
d1431 1
a1431 1
	p->p_tamenote = TMN_CPATH;
d1490 1
a1490 1
	p->p_tamenote = TMN_CPATH;
d1611 1
a1611 1
	p->p_tamenote = TMN_RPATH;
d1658 1
a1658 1
	p->p_tamenote = TMN_RPATH;
d1729 1
a1729 1
	p->p_tamenote = TMN_RPATH;
d1828 1
a1828 1
	p->p_tamenote = TMN_RPATH;
d1891 1
a1891 1
	p->p_tamenote = TMN_FATTR | TMN_RPATH;
d1989 1
a1989 1
	if ((p->p_p->ps_flags & PS_TAMED))
d1995 1
a1995 1
	p->p_tamenote = TMN_FATTR | TMN_RPATH;
d2031 1
a2031 1
	if ((p->p_p->ps_flags & PS_TAMED))
d2096 1
a2096 1
	p->p_tamenote = TMN_FATTR | TMN_RPATH;
d2105 1
a2105 1
		if ((p->p_p->ps_flags & PS_TAMED) &&
d2152 1
a2152 1
	p->p_tamenote = TMN_FATTR | TMN_RPATH;
d2161 1
a2161 1
		if ((p->p_p->ps_flags & PS_TAMED) &&
d2215 1
a2215 1
		if ((p->p_p->ps_flags & PS_TAMED) &&
d2311 1
a2311 1
	p->p_tamenote = TMN_FATTR | TMN_RPATH;
d2456 1
a2456 1
	p->p_tamenote = TMN_FATTR | TMN_RPATH;
d2583 1
a2583 1
	p->p_tamenote = TMN_RPATH | TMN_CPATH;
d2597 1
a2597 1
	p->p_tamenote = TMN_CPATH;
d2666 1
a2666 1
	p->p_tamenote = TMN_CPATH | TMN_RPATH;
d2691 1
a2691 1
	p->p_tamenote = TMN_CPATH | TMN_RPATH;
d2726 1
a2726 1
	p->p_tamenote = TMN_CPATH;
@


1.227
log
@In tame mode, return EPERM for *chown if uid/gid change is not towards
cr_uid/cr_gid (effective ids).  Thus, chown(, -1,-1) should work OK, so
should chown(, me, -1), etc.  With this commited, more people can test.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.226 2015/08/31 16:07:12 deraadt Exp $	*/
d2726 1
a2726 1
	p->p_tamenote = TMN_CPATH | TMN_RPATH;
@


1.226
log
@Rather than killing when *chmod is asked to do setuid/setgid, clear
those bits in the request and continue.  This is a better posix-subset
to give to programs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.225 2015/08/31 00:45:09 deraadt Exp $	*/
d2105 6
d2112 1
a2112 1
		    (suser(p, 0) || (p->p_p->ps_flags & PS_TAMED) || suid_clear)) {
d2161 6
d2168 1
a2168 1
		    (suser(p, 0) || (p->p_p->ps_flags & PS_TAMED) || suid_clear)) {
d2215 6
d2222 1
a2222 1
		    (suser(p, 0) || (p->p_p->ps_flags & PS_TAMED) || suid_clear)) {
@


1.225
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.224 2015/08/30 05:38:38 deraadt Exp $	*/
d1989 2
a1990 3
	if ((p->p_p->ps_flags & PS_TAMED) &&
	    (mode & (S_ISUID|S_ISGID)))
		return (tame_fail(p, EPERM, TAME_FATTR));
d2031 2
a2032 3
	if ((p->p_p->ps_flags & PS_TAMED) &&
	    (mode & (S_ISUID|S_ISGID|S_ISTXT)))
		return (tame_fail(p, EPERM, TAME_FATTR));
@


1.224
log
@For *chmod, allow S_ISTXT in tame mode.  I am evaluating what to
do about S_ISUID and SISGID... maybe we should mask them and allow
the operation to happen?
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.223 2015/08/22 20:18:50 deraadt Exp $	*/
d2115 1
a2115 2
		}
		else
d2165 1
a2165 2
		}
		else
@


1.223
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.222 2015/07/20 21:31:57 deraadt Exp $	*/
d1990 1
a1990 1
	    (mode & (S_ISUID|S_ISGID|S_ISTXT)))
@


1.222
log
@Move the construction of p_tamenote from sys_open() to doopenat(), so that
it also applies to sys_openat().
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.221 2015/07/19 02:35:35 deraadt Exp $	*/
d565 1
d849 3
d853 2
d856 1
a856 1
		p->p_tamenote |= TMN_WRITE;
d860 1
a860 1
		p->p_tamenote |= TMN_CREAT;
a1203 1
	p->p_tamenote |= TMN_IMODIFY;
d1298 1
a1298 1
	p->p_tamenote |= TMN_CREAT;
a1327 1
	p->p_tamenote |= TMN_CREAT;
d1360 1
d1371 1
a1402 1
	p->p_tamenote |= TMN_CREAT;
d1431 1
a1463 1
	p->p_tamenote |= TMN_CREAT;
d1490 1
d1611 1
d1658 1
d1727 1
d1729 1
d1828 1
a1862 1
	p->p_tamenote |= TMN_IMODIFY;
d1891 1
a1961 1
	p->p_tamenote |= TMN_IMODIFY;
d1989 3
d1996 1
d2027 1
d2030 1
a2030 1
	if (SCARG(uap, mode) & ~(S_IFMT | ALLPERMS))
d2032 3
d2044 1
a2044 1
		vattr.va_mode = SCARG(uap, mode) & ALLPERMS;
a2064 1
	p->p_tamenote |= TMN_IMODIFY;
d2098 1
d2108 1
a2108 1
		    (suser(p, 0) || suid_clear)) {
d2149 1
a2149 1
	p->p_tamenote |= TMN_IMODIFY;
d2159 1
a2159 1
		    (suser(p, 0) || suid_clear)) {
d2208 1
a2208 1
		    (suser(p, 0) || suid_clear)) {
a2245 1
	p->p_tamenote |= TMN_IMODIFY;
d2297 1
d2442 1
a2442 1
	p->p_tamenote |= TMN_IMODIFY;
a2541 1
	p->p_tamenote |= TMN_IMODIFY;
d2569 1
d2583 1
d2652 1
a2652 1
	p->p_tamenote |= TMN_CREAT;
d2677 1
d2712 1
a2712 1
	p->p_tamenote |= TMN_CREAT;
a2806 1
	p->p_tamenote |= TMN_CREAT;
@


1.221
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.220 2015/05/07 08:53:33 mpi Exp $	*/
a814 10
	int flags = SCARG(uap, flags);

	switch (flags & O_ACCMODE) {
	case O_WRONLY:
	case O_RDWR:
		p->p_tamenote |= TMN_WRITE;
		break;
	}
	if (flags & O_CREAT)
		p->p_tamenote |= TMN_CREAT;
d846 9
@


1.220
log
@Pass a thread pointer instead of its file descriptor table to getvnode(9).

Input and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.219 2015/04/30 09:20:51 mpi Exp $	*/
d815 10
d1199 1
d1294 1
d1324 1
d1398 1
d1459 1
d1853 1
d1952 1
d2048 1
d2132 1
d2229 1
d2425 1
d2525 1
d2634 1
d2693 1
d2788 1
@


1.219
log
@Indroduce fd_getfile_mode() and use it were fd_getfile() is directly
followed by a mode check.  This will simplify the ref/unref dance as
soon as fd_getfile() will increment fp's reference counter.

Idea from and ok guenther@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.218 2015/04/17 04:43:20 guenther Exp $	*/
d594 1
a594 1
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
d1886 1
a1886 1
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
d2002 1
a2002 1
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
d2164 1
a2164 1
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
d2379 1
a2379 1
	if ((error = getvnode(p->p_fd, fd, &fp)) != 0)
d2440 1
a2440 1
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
d2476 1
a2476 1
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
d2695 1
a2695 1
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
d2786 1
a2786 1
getvnode(struct filedesc *fdp, int fd, struct file **fpp)
d2791 1
a2791 1
	if ((fp = fd_getfile(fdp, fd)) == NULL)
@


1.218
log
@Tweaks utimensat/futimens handling to always update ctime, even when both
atime and mtime are UTIME_OMIT (at least for ufs, tmpfs, and ext2fs), and
to correctly handle a timestamp of -1.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.217 2015/03/14 03:38:51 jsg Exp $	*/
d2827 1
a2827 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FREAD) == 0)
d2868 1
a2868 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FREAD) == 0)
d2908 1
a2908 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FWRITE) == 0)
d2949 1
a2949 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FWRITE) == 0)
@


1.217
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.216 2014/12/16 18:30:04 tedu Exp $	*/
d2286 4
d2301 10
a2310 14
	/*
	 * XXX: Ideally the filesystem code would check tv_nsec ==
	 * UTIME_OMIT instead of tv_sec == VNOVAL, but until then we
	 * need to fudge tv_sec if it happens to equal VNOVAL.
	 */
	if (ts[0].tv_nsec == UTIME_OMIT)
		ts[0].tv_sec = VNOVAL;
	else if (ts[0].tv_sec == VNOVAL)
		ts[0].tv_sec = VNOVAL - 1;

	if (ts[1].tv_nsec == UTIME_OMIT)
		ts[1].tv_sec = VNOVAL;
	else if (ts[1].tv_sec == VNOVAL)
		ts[1].tv_sec = VNOVAL - 1;
d2315 1
a2315 3
	else {
		vattr.va_atime = ts[0];
		vattr.va_mtime = ts[1];
a2316 1
	}
@


1.216
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.215 2014/12/08 20:56:11 guenther Exp $	*/
a54 1
#include <sys/dirent.h>
@


1.215
log
@Add chflagsat(), modeled on fchmodat() with name to match FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.214 2014/11/14 23:26:48 tedu Exp $	*/
d48 1
@


1.214
log
@prefer sizeof(*ptr) to sizeof(struct) for malloc and free
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.213 2014/11/03 21:28:35 tedu Exp $	*/
d80 2
a1829 1
/* ARGSUSED */
d1837 22
a1858 3
	struct vnode *vp;
	struct vattr vattr;
	int error;
d1860 1
a1860 1
	u_int flags = SCARG(uap, flags);
d1862 5
a1866 1
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
d1869 1
a1869 22
	vp = nd.ni_vp;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else if (flags == VNOVAL)
		error = EINVAL;
	else {
		if (suser(p, 0)) {
			if ((error = VOP_GETATTR(vp, &vattr, p->p_ucred, p)) != 0)
				goto out;
			if (vattr.va_type == VCHR || vattr.va_type == VBLK) {
				error = EINVAL;
				goto out;
			}
		}
		VATTR_NULL(&vattr);
		vattr.va_flags = flags;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
out:
	vput(vp);
	return (error);
a1874 1
/* ARGSUSED */
d1882 1
a1882 1
	struct vattr vattr;
a1883 1
	struct file *fp;
a1884 1
	u_int flags = SCARG(uap, flags);
d1888 12
a1899 1
	vp = (struct vnode *)fp->f_data;
d1920 1
a1920 2
	VOP_UNLOCK(vp, 0, p);
	FRELE(fp, p);
@


1.213
log
@include sys/unistd.h where needed instead of indirect reliance. ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.212 2014/11/03 03:08:00 deraadt Exp $	*/
d235 1
a235 2
	mp = (struct mount *)malloc((u_long)sizeof(struct mount),
		M_MOUNT, M_WAITOK|M_ZERO);
d306 1
a306 1
		free(mp, M_MOUNT, sizeof(struct mount));
d456 1
a456 1
	free(mp, M_MOUNT, sizeof(struct mount));
@


1.212
log
@pass size argument to free()
ok doug tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.211 2014/10/22 21:43:16 millert Exp $	*/
d58 1
@


1.211
log
@Extend domknodat() to support S_IFIFO directly and remove domkfifoat().
Both sys_mkfifo(2) and sys_mkfifoat(2) could be replace by libc wrappers
using mknodat(2) at a later date if we desire.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.210 2014/10/13 15:23:34 millert Exp $	*/
d306 1
a306 1
		free(mp, M_MOUNT, 0);
d456 1
a456 1
	free(mp, M_MOUNT, 0);
@


1.210
log
@POSIX says that mknod(2) should support fifos.  OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.209 2014/09/18 02:15:04 uebayasi Exp $	*/
a71 1
int domkfifoat(struct proc *, int, const char *, mode_t);
d1175 1
a1175 1
 * Create a special file.
d1213 6
a1218 6
	if (S_ISFIFO(mode) && dev == 0)
		return (domkfifoat(p, fd, path, mode));
	if ((error = suser(p, 0)) != 0)
		return (error);
	if (p->p_fd->fd_rdir)
		return (EINVAL);
d1240 10
d1281 2
a1282 1
	return (domkfifoat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, mode)));
d1294 2
a1295 31
	return (domkfifoat(p, SCARG(uap, fd), SCARG(uap, path),
	    SCARG(uap, mode)));
}

int
domkfifoat(struct proc *p, int fd, const char *path, mode_t mode)
{
#ifndef FIFO
	return (EOPNOTSUPP);
#else
	struct vattr vattr;
	int error;
	struct nameidata nd;

	NDINITAT(&nd, CREATE, LOCKPARENT, UIO_USERSPACE, fd, path, p);
	if ((error = namei(&nd)) != 0)
		return (error);
	if (nd.ni_vp != NULL) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vrele(nd.ni_vp);
		return (EEXIST);
	}
	VATTR_NULL(&vattr);
	vattr.va_type = VFIFO;
	vattr.va_mode = (mode & ALLPERMS) &~ p->p_fd->fd_cmask;
	return (VOP_MKNOD(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &vattr));
#endif /* FIFO */
@


1.209
log
@Correct argument name (int flags -> int amode) in sys_access().

OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.208 2014/07/12 18:43:32 tedu Exp $	*/
d1214 2
@


1.208
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.207 2014/07/08 17:19:25 deraadt Exp $	*/
d1603 1
a1603 1
		syscallarg(int) flags;
d1607 1
a1607 1
	    SCARG(uap, flags), 0));
@


1.207
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.206 2014/05/25 18:46:44 guenther Exp $	*/
d307 1
a307 1
		free(mp, M_MOUNT);
d457 1
a457 1
	free(mp, M_MOUNT);
@


1.206
log
@In access(), use the real UID/GID for the path search too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.205 2014/04/12 14:18:11 espie Exp $	*/
d45 1
a59 3

#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>
@


1.205
log
@revert falloc change, as it causes all new processes to get stuck after a while
(race condition ?)

problem noticed by me, aja, sthen, brynet, rpe.

vanishing after this revert, okay aja@@, sthen@@

tedu, you probably want to look into re-checking the fcreate/fpublish addition
first, then if it's stable, see about tweaking doopenat ?
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.204 2014/03/30 21:54:48 guenther Exp $	*/
d1630 2
a1632 1
	struct nameidata nd;
d1639 15
d1656 1
a1656 1
		return (error);
a1660 1
		struct ucred *cred = p->p_ucred;
a1662 8
		crhold(cred);

		if (!(flag & AT_EACCESS)) {
			cred = crcopy(cred);
			cred->cr_uid = cred->cr_ruid;
			cred->cr_gid = cred->cr_rgid;
		}

d1670 1
a1670 1
		error = VOP_ACCESS(vp, vflags, cred, p);
a1672 2

		crfree(cred);
d1675 5
@


1.204
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.203 2014/03/08 22:54:30 tedu Exp $	*/
d844 1
a844 1
	int type, indx, error, fpuberr, localtrunc = 0;
d850 1
a850 1
	if ((error = fcreate(p, &fp)) != 0)
d853 2
d863 1
a863 16

	fdpunlock(fdp);
	error = vn_open(&nd, flags, cmode);
	fdplock(fdp);

	if ((fpuberr = fpublish(p, fp, &indx)) != 0) {
		/* should never happen; just in case */
		if (error == 0)
			vn_close(nd.ni_vp, flags & FMASK, p->p_ucred, p);
		closef(fp, p);
		error = fpuberr;
		goto out;
	}
	if (flags & O_CLOEXEC)
		fdp->fd_ofileflags[indx] |= UF_EXCLOSE;
	if (error != 0) {
@


1.203
log
@split falloc into two functions, the allocation and the publication.
the first part is likely to fail, but we can generally prevent the second
part from failing.
use these two functions to drop the fdp lock around vn_open in sys_open,
but still maintain the original semantics of allocate then open.
the goal here is to fix the blocked fifo deadlock in a threaded program.

testing volunteers in short supply, resorting to conscription
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.202 2014/01/21 01:48:45 tedu Exp $	*/
d1665 2
a1666 2
			cred->cr_uid = p->p_cred->p_ruid;
			cred->cr_gid = p->p_cred->p_rgid;
@


1.202
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.201 2014/01/20 03:33:29 guenther Exp $	*/
d844 1
a844 1
	int type, indx, error, localtrunc = 0;
d850 1
a850 1
	if ((error = falloc(p, &fp, &indx)) != 0)
a852 2
	if (flags & O_CLOEXEC)
		fdp->fd_ofileflags[indx] |= UF_EXCLOSE;
d861 16
a876 1
	if ((error = vn_open(&nd, flags, cmode)) != 0) {
@


1.201
log
@Fix comment
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.200 2013/12/01 16:40:56 krw Exp $	*/
d961 1
a961 1
	bzero(&fh, sizeof(fh));
@


1.200
log
@Change 'mountlist' from CIRCLEQ to TAILQ. Be paranoid and
use TAILQ_*_SAFE more than might be needed.

Bulk ports build by sthen@@ showed nobody sticking their fingers
so deep into the kernel.

Feedback and suggestions from millert@@. ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.199 2013/10/25 14:56:52 millert Exp $	*/
d322 1
a322 1
 * we've finished walking the allprocs list.
@


1.199
log
@fix comment
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.198 2013/09/14 01:35:01 guenther Exp $	*/
d297 1
a297 1
		CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
d447 1
a447 1
	CIRCLEQ_REMOVE(&mountlist, mp, mnt_list);
d479 2
a480 4
	for (mp = CIRCLEQ_LAST(&mountlist); mp != CIRCLEQ_END(&mountlist);
	    mp = nmp) {
		if (vfs_busy(mp, VB_READ|VB_NOWAIT)) {
			nmp = CIRCLEQ_PREV(mp, mnt_list);
a481 1
		}
a489 1
		nmp = CIRCLEQ_PREV(mp, mnt_list);
d633 2
a634 4
	for (mp = CIRCLEQ_FIRST(&mountlist); mp != CIRCLEQ_END(&mountlist);
	    mp = nmp) {
		if (vfs_busy(mp, VB_READ|VB_NOWAIT)) {
			nmp = CIRCLEQ_NEXT(mp, mnt_list);
a635 1
		}
a644 1
				nmp = CIRCLEQ_NEXT(mp, mnt_list);
a661 1
		nmp = CIRCLEQ_NEXT(mp, mnt_list);
@


1.198
log
@Snapshots for all archs have been built, so remove the T32 code
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.197 2013/08/16 08:33:20 guenther Exp $	*/
d2943 1
a2943 1
	/* dofilewrite() will FRELE the descriptor for us */
@


1.197
log
@Tweak the getdents() kernel prototype to use "void *"
Provide a declaration for userspace
Fix the kernel's sanity check on the buflen argument

lack of prototype pointed out by sthen@@ and landry@@
ok kettenis@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.196 2013/08/14 05:26:14 guenther Exp $	*/
a2987 246
#ifdef T32
int copyout_stat32(struct stat *, void *, struct proc *);
int dofstatat32(struct proc *, int, const char *, struct stat32 *, int);

int
dofstatat32(struct proc *p, int fd, const char *path, struct stat32 *buf,
    int flag)
{
	struct stat sb;
	int error, follow;
	struct nameidata nd;

	if (flag & ~AT_SYMLINK_NOFOLLOW)
		return (EINVAL);

	follow = (flag & AT_SYMLINK_NOFOLLOW) ? NOFOLLOW : FOLLOW;
	NDINITAT(&nd, LOOKUP, follow | LOCKLEAF, UIO_USERSPACE, fd, path, p);
	if ((error = namei(&nd)) != 0)
		return (error);
	error = vn_stat(nd.ni_vp, &sb, p);
	vput(nd.ni_vp);
	if (error)
		return (error);
	return (copyout_stat32(&sb, buf, p));
}

int
t32_sys_stat(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_stat_args /* {
		syscallarg(const char *) path;
		syscallarg(struct stat32 *) ub;
	} */ *uap = v;

	return (dofstatat32(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, ub), 0));
}

int
copyout_stat32(struct stat *sp, void *uaddr, struct proc *p)
{
	struct stat32 sb32;
	int error;

	STAT_TO_32(&sb32, sp);

	/* Don't let non-root see generation numbers (for NFS security) */
	if (suser(p, 0))
		sb32.st_gen = 0;
	error = copyout(&sb32, uaddr, sizeof(sb32));
#ifdef KTRACE
	if (error == 0 && KTRPOINT(p, KTR_STRUCT))
		ktrstat(p, sp);
#endif
	return (error);
}

int
t32_sys_fstatat(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_fstatat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(struct stat32 *) buf;
		syscallarg(int) flag;
	} */ *uap = v;

	return (dofstatat32(p, SCARG(uap, fd), SCARG(uap, path),
	    SCARG(uap, buf), SCARG(uap, flag)));
}

int
t32_sys_lstat(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_lstat_args /* {
		syscallarg(const char *) path;
		syscallarg(struct stat32 *) ub;
	} */ *uap = v;

	return (dofstatat32(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, ub),
	    AT_SYMLINK_NOFOLLOW));
}

/* ARGSUSED */
int
t32_sys_utimes(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_utimes_args /* {
		syscallarg(const char *) path;
		syscallarg(const struct timeval32 *) tptr;
	} */ *uap = v;

	struct timespec ts[2];
	struct timeval32 tv[2];
	const struct timeval32 *tvp;
	int error;

	tvp = SCARG(uap, tptr);
	if (tvp != NULL) {
		error = copyin(tvp, tv, sizeof(tv));
		if (error)
			return (error);
		TIMESPEC_FROM_TIMEVAL32(&ts[0], &tv[0]);
		TIMESPEC_FROM_TIMEVAL32(&ts[1], &tv[1]);
	} else
		ts[0].tv_nsec = ts[1].tv_nsec = UTIME_NOW;

	return (doutimensat(p, AT_FDCWD, SCARG(uap, path), ts, 0));
}

int
t32_sys_utimensat(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_utimensat_args /* {
		syscallarg(int) fd;
		syscallarg(const char *) path;
		syscallarg(const struct timespec32 *) times;
		syscallarg(int) flag;
	} */ *uap = v;

	struct timespec ts[2];
	struct timespec32 ts32[2];
	const struct timespec32 *tsp;
	int error;

	tsp = SCARG(uap, times);
	if (tsp != NULL) {
		error = copyin(tsp, ts32, sizeof(ts32));
		if (error)
			return (error);
		TIMESPEC_FROM_32(&ts[0], &ts32[0]);
		TIMESPEC_FROM_32(&ts[1], &ts32[1]);
	} else
		ts[0].tv_nsec = ts[1].tv_nsec = UTIME_NOW;

	return (doutimensat(p, SCARG(uap, fd), SCARG(uap, path), ts,
	    SCARG(uap, flag)));
}

/* ARGSUSED */
int
t32_sys_futimes(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_futimes_args /* {
		syscallarg(int) fd;
		syscallarg(const struct timeval32 *) tptr;
	} */ *uap = v;
	struct timeval32 tv[2];
	struct timespec ts[2];
	const struct timeval32 *tvp;
	int error;

	tvp = SCARG(uap, tptr);
	if (tvp != NULL) {
		error = copyin(tvp, tv, sizeof(tv));
		if (error)
			return (error);
		TIMESPEC_FROM_TIMEVAL32(&ts[0], &tv[0]);
		TIMESPEC_FROM_TIMEVAL32(&ts[1], &tv[1]);
	} else
		ts[0].tv_nsec = ts[1].tv_nsec = UTIME_NOW;

	return (dofutimens(p, SCARG(uap, fd), ts));
}

int
t32_sys_futimens(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_futimens_args /* {
		syscallarg(int) fd;
		syscallarg(const struct timespec32 *) times;
	} */ *uap = v;
	struct timespec ts[2];
	struct timespec32 ts32[2];
	const struct timespec32 *tsp;
	int error;

	tsp = SCARG(uap, times);
	if (tsp != NULL) {
		error = copyin(tsp, ts32, sizeof(ts32));
		if (error)
			return (error);
		TIMESPEC_FROM_32(&ts[0], &ts32[0]);
		TIMESPEC_FROM_32(&ts[1], &ts32[1]);
	} else
		ts[0].tv_nsec = ts[1].tv_nsec = UTIME_NOW;

	return (dofutimens(p, SCARG(uap, fd), ts));
}

int
t32_sys_getdirentries(struct proc *p, void *v, register_t *retval)
{
	struct t32_sys_getdirentries_args /* {
		syscallarg(int) fd;
		syscallarg(char *) buf;
		syscallarg(int) count;
		syscallarg(off_t *) basep;
	} */ *uap = v;
	struct vnode *vp;
	struct file *fp;
	struct uio auio;
	struct iovec aiov;
	off_t off;
	int error, count, eofflag;

	count = SCARG(uap, count);
	if (count < 0)
		return EINVAL;
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	if ((fp->f_flag & FREAD) == 0) {
		error = EBADF;
		goto bad;
	}
	if (fp->f_offset < 0) {
		error = EINVAL;
		goto bad;
	}
	vp = fp->f_data;
	if (vp->v_type != VDIR) {
		error = EINVAL;
		goto bad;
	}
	aiov.iov_base = SCARG(uap, buf);
	aiov.iov_len = count;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_rw = UIO_READ;
	auio.uio_segflg = UIO_USERSPACE | 0x10;		/* XXX */
	auio.uio_procp = p;
	auio.uio_resid = count;
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	off = auio.uio_offset = fp->f_offset;
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag);
	fp->f_offset = auio.uio_offset;
	VOP_UNLOCK(vp, 0, p);
	if (error)
		goto bad;
	*retval = count - auio.uio_resid;
bad:
	FRELE(fp, p);
	if (!error)
		error = copyout(&off, SCARG(uap, basep), sizeof(off_t));
	return (error);
}
#endif
@


1.196
log
@The last user of the old __tfork() was updated to the current one,
so COMPAT_O51 can go.  The complete ABI role means COMPAT_O53 can
be removed as well.

ok jsing@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.195 2013/08/13 05:52:24 guenther Exp $	*/
d2692 1
a2692 1
		syscallarg(struct dirent *) buf;
d2704 1
a2704 1
	if (buflen < 0)
@


1.195
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.194 2013/08/08 20:19:13 guenther Exp $	*/
a70 3
#ifdef COMPAT_O53
int copyout_statfs53(struct statfs *, void *, struct proc *);
#endif
a680 185

#ifdef COMPAT_O53
int
copyout_statfs53(struct statfs *sp, void *uaddr, struct proc *p)
{
	struct statfs53 st;

	/* make sure any padding in the changed area is zeroed */
	memset(&st, 0, sizeof(st));
	memcpy(&st, sp, offsetof(struct statfs53, f_owner) +
	    sizeof(st.f_owner));
	st.f_ctime = sp->f_ctime;
	memcpy(&st.f_fstypename,  &sp->f_fstypename,  sizeof(st.f_fstypename));
	memcpy(&st.f_mntonname,   &sp->f_mntonname,   sizeof(st.f_mntonname));
	memcpy(&st.f_mntfromname, &sp->f_mntfromname, sizeof(st.f_mntfromname));
	memcpy(&st.mount_info,    &sp->mount_info,    sizeof(st.mount_info));

	/* Don't let non-root see filesystem id (for NFS security) */
	if (suser(p, 0))
		memset(&st.f_fsid, 0, sizeof(st.f_fsid));

	return (copyout(&st, uaddr, sizeof(st)));
}

/*
 * Get filesystem statistics.
 */
/* ARGSUSED */
int
compat_o53_sys_statfs(struct proc *p, void *v, register_t *retval)
{
	struct compat_o53_sys_statfs_args /* {
		syscallarg(const char *) path;
		syscallarg(struct statfs53 *) buf;
	} */ *uap = v;
	struct mount *mp;
	struct statfs *sp;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	mp = nd.ni_vp->v_mount;
	sp = &mp->mnt_stat;
	vrele(nd.ni_vp);
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;

	return (copyout_statfs53(sp, SCARG(uap, buf), p));
}

/*
 * Get filesystem statistics.
 */
/* ARGSUSED */
int
compat_o53_sys_fstatfs(struct proc *p, void *v, register_t *retval)
{
	struct compat_o53_sys_fstatfs_args /* {
		syscallarg(int) fd;
		syscallarg(struct statfs53 *) buf;
	} */ *uap = v;
	struct file *fp;
	struct mount *mp;
	struct statfs *sp;
	int error;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	mp = ((struct vnode *)fp->f_data)->v_mount;
	if (!mp) {
		FRELE(fp, p);
		return (ENOENT);
	}
	sp = &mp->mnt_stat;
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp, p);
	if (error)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;

	return (copyout_statfs53(sp, SCARG(uap, buf), p));
}

int
compat_o53_sys_getfsstat(struct proc *p, void *v, register_t *retval)
{
	struct compat_o53_sys_getfsstat_args /* {
		syscallarg(struct statfs53 *) buf;
		syscallarg(size_t) bufsize;
		syscallarg(int) flags;
	} */ *uap = v;
	struct mount *mp, *nmp;
	struct statfs *sp;
	struct statfs53 *sfsp;
	size_t count, maxcount;
	int error, flags = SCARG(uap, flags);

	maxcount = SCARG(uap, bufsize) / sizeof(struct statfs53);
	sfsp = SCARG(uap, buf);
	count = 0;

	for (mp = CIRCLEQ_FIRST(&mountlist); mp != CIRCLEQ_END(&mountlist);
	    mp = nmp) {
		if (vfs_busy(mp, VB_READ|VB_NOWAIT)) {
			nmp = CIRCLEQ_NEXT(mp, mnt_list);
			continue;
		}
		if (sfsp && count < maxcount) {
			sp = &mp->mnt_stat;

			/* Refresh stats unless MNT_NOWAIT is specified */
			if (flags != MNT_NOWAIT &&
			    flags != MNT_LAZY &&
			    (flags == MNT_WAIT ||
			    flags == 0) &&
			    (error = VFS_STATFS(mp, sp, p))) {
				nmp = CIRCLEQ_NEXT(mp, mnt_list);
				vfs_unbusy(mp);
 				continue;
			}

			sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
#if notyet
			if (mp->mnt_flag & MNT_SOFTDEP)
				sp->f_eflags = STATFS_SOFTUPD;
#endif
			error = (copyout_statfs53(sp, sfsp, p));
			if (error) {
				vfs_unbusy(mp);
				return (error);
			}
			sfsp++;
		}
		count++;
		nmp = CIRCLEQ_NEXT(mp, mnt_list);
		vfs_unbusy(mp);
	}

	if (sfsp && count > maxcount)
		*retval = maxcount;
	else
		*retval = count;

	return (0);
}

/* ARGSUSED */
int
compat_o53_sys_fhstatfs(struct proc *p, void *v, register_t *retval)
{
	struct compat_o53_sys_fhstatfs_args /* {
		syscallarg(const fhandle_t *) fhp;
		syscallarg(struct statfs53 *) buf;
	} */ *uap = v;
	struct statfs *sp;
	fhandle_t fh;
	struct mount *mp;
	struct vnode *vp;
	int error;

	/*
	 * Must be super user
	 */
	if ((error = suser(p, 0)))
		return (error);

	if ((error = copyin(SCARG(uap, fhp), &fh, sizeof(fhandle_t))) != 0)
		return (error);

	if ((mp = vfs_getvfs(&fh.fh_fsid)) == NULL)
		return (ESTALE);
	if ((error = VFS_FHTOVP(mp, &fh.fh_fid, &vp)))
		return (error);
	mp = vp->v_mount;
	sp = &mp->mnt_stat;
	vput(vp);
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
		return (error);
	sp->f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
	return (copyout_statfs53(sp, SCARG(uap, buf), p));
}
#endif /* COMPAT_O53 */
@


1.194
log
@Drop the retval argument from do*at() functions which don't use it.

ok kettenis@@ mpi@@ deraadt@@ millert@@ miod@@ matthew@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.193 2013/06/05 01:26:00 guenther Exp $	*/
a74 3
int getdirentries_internal(struct proc *, int, char *, int, off_t *,
    register_t *);

d2876 1
a2876 2
getdirentries_internal(struct proc *p, int fd, char *buf, int count,
    off_t *basep, register_t *retval)
d2878 5
d2887 1
d2890 3
a2892 1
	if (count < 0)
d2894 1
a2894 1
	if ((error = getvnode(p->p_fd, fd, &fp)) != 0)
d2904 1
a2904 1
	vp = (struct vnode *)fp->f_data;
d2909 2
a2910 2
	aiov.iov_base = buf;
	aiov.iov_len = count;
d2916 1
a2916 1
	auio.uio_resid = count;
d2918 2
a2919 2
	*basep = auio.uio_offset = fp->f_offset;
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, 0, 0);
d2924 1
a2924 1
	*retval = count - auio.uio_resid;
a2929 19
int
sys_getdirentries(struct proc *p, void *v, register_t *retval)
{
	struct sys_getdirentries_args /* {
		syscallarg(int) fd;
		syscallarg(char *) buf;
		syscallarg(int) count;
		syscallarg(off_t *) basep;
	} */ *uap = v;
	int error;
	off_t off;

	error = getdirentries_internal(p, SCARG(uap, fd), SCARG(uap, buf),
	    SCARG(uap, count), &off, retval);
	if (!error)
		error = copyout(&off, SCARG(uap, basep), sizeof(off_t));
	return error;
}

d3175 247
@


1.193
log
@Move FHASLOCK from f_flag to f_iflags, freeing up a bit for passing
O_* flags and eliminating an XXX comment.

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.192 2013/04/15 15:32:19 jsing Exp $	*/
d79 7
a85 9
int domknodat(struct proc *, int, const char *, mode_t, dev_t, register_t *);
int domkfifoat(struct proc *, int, const char *, mode_t, register_t *);
int dolinkat(struct proc *, int, const char *, int, const char *, int,
    register_t *);
int dosymlinkat(struct proc *, const char *, int, const char *, register_t *);
int dounlinkat(struct proc *, int, const char *, int, register_t *);
int dofaccessat(struct proc *, int, const char *, int, int, register_t *);
int dofstatat(struct proc *, int, const char *, struct stat *, int,
    register_t *);
d88 7
a94 11
int dofchmodat(struct proc *, int, const char *, mode_t, int, register_t *);
int dofchownat(struct proc *, int, const char *, uid_t, gid_t, int,
    register_t *);
int dorenameat(struct proc *, int, const char *, int, const char *,
    register_t *);
int domkdirat(struct proc *, int, const char *, mode_t, register_t *);
int doutimensat(struct proc *, int, const char *, struct timespec [2],
    int, register_t *);
int dovutimens(struct proc *, struct vnode *, struct timespec [2],
    register_t *);
int dofutimens(struct proc *, int, struct timespec [2], register_t *);
d1391 1
a1391 1
	    SCARG(uap, dev), retval));
d1405 1
a1405 1
	    SCARG(uap, mode), SCARG(uap, dev), retval));
d1409 1
a1409 2
domknodat(struct proc *p, int fd, const char *path, mode_t mode, dev_t dev,
    register_t *retval)
d1472 1
a1472 2
	return (domkfifoat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, mode),
	    retval));
d1485 1
a1485 1
	    SCARG(uap, mode), retval));
d1489 1
a1489 1
domkfifoat(struct proc *p, int fd, const char *path, mode_t mode, register_t *retval)
d1530 1
a1530 1
	    SCARG(uap, link), AT_SYMLINK_FOLLOW, retval));
d1545 1
a1545 1
	    SCARG(uap, fd2), SCARG(uap, path2), SCARG(uap, flag), retval));
d1550 1
a1550 1
    const char *path2, int flag, register_t *retval)
d1602 1
a1602 2
	return (dosymlinkat(p, SCARG(uap, path), AT_FDCWD, SCARG(uap, link),
	    retval));
d1615 1
a1615 1
	    SCARG(uap, link), retval));
d1619 1
a1619 2
dosymlinkat(struct proc *p, const char *upath, int fd, const char *link,
    register_t *retval)
d1662 1
a1662 1
	return (dounlinkat(p, AT_FDCWD, SCARG(uap, path), 0, retval));
d1675 1
a1675 1
	    SCARG(uap, flag), retval));
d1679 1
a1679 2
dounlinkat(struct proc *p, int fd, const char *path, int flag,
    register_t *retval)
d1809 1
a1809 1
	    SCARG(uap, flags), 0, retval));
d1823 1
a1823 1
	    SCARG(uap, amode), SCARG(uap, flag), retval));
d1827 1
a1827 2
dofaccessat(struct proc *p, int fd, const char *path, int amode, int flag,
    register_t *retval)
d1885 1
a1885 2
	return (dofstatat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, ub), 0,
	    retval));
d1899 1
a1899 1
	    SCARG(uap, buf), SCARG(uap, flag), retval));
d1903 1
a1903 2
dofstatat(struct proc *p, int fd, const char *path, struct stat *buf,
    int flag, register_t *retval)
d1944 1
a1944 1
	    AT_SYMLINK_NOFOLLOW, retval));
d2135 1
a2135 2
	return (dofchmodat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, mode),
	    0, retval));
d2149 1
a2149 1
	    SCARG(uap, mode), SCARG(uap, flag), retval));
d2153 1
a2153 2
dofchmodat(struct proc *p, int fd, const char *path, mode_t mode, int flag,
    register_t *retval)
d2231 1
a2231 1
	    SCARG(uap, gid), 0, retval));
d2246 1
a2246 1
	    SCARG(uap, uid), SCARG(uap, gid), SCARG(uap, flag), retval));
d2251 1
a2251 1
    int flag, register_t *retval)
d2419 1
a2419 1
	return (doutimensat(p, AT_FDCWD, SCARG(uap, path), ts, 0, retval));
d2445 1
a2445 1
	    SCARG(uap, flag), retval));
d2450 1
a2450 1
    struct timespec ts[2], int flag, register_t *retval)
d2465 1
a2465 1
	return (dovutimens(p, vp, ts, retval));
d2469 1
a2469 2
dovutimens(struct proc *p, struct vnode *vp, struct timespec ts[2],
    register_t *retval)
d2549 1
a2549 1
	return (dofutimens(p, SCARG(uap, fd), ts, retval));
d2571 1
a2571 1
	return (dofutimens(p, SCARG(uap, fd), ts, retval));
d2575 1
a2575 1
dofutimens(struct proc *p, int fd, struct timespec ts[2], register_t *retval)
d2587 1
a2587 1
	return (dovutimens(p, vp, ts, retval));
d2707 1
a2707 1
	    SCARG(uap, to), retval));
d2721 1
a2721 1
	    SCARG(uap, tofd), SCARG(uap, to), retval));
d2726 1
a2726 1
    const char *to, register_t *retval)
d2814 1
a2814 2
	return (domkdirat(p, AT_FDCWD, SCARG(uap, path), SCARG(uap, mode),
	    retval));
d2827 1
a2827 1
	    SCARG(uap, mode), retval));
d2831 1
a2831 2
domkdirat(struct proc *p, int fd, const char *path, mode_t mode,
    register_t *retval)
d2872 1
a2872 2
	return (dounlinkat(p, AT_FDCWD, SCARG(uap, path), AT_REMOVEDIR,
	    retval));
@


1.192
log
@Add an f_mntfromspec member to struct statfs, which specifies the name of
the special provided when the mount was requested. This may be the same as
the special that was actually used for the mount (e.g. in the case of a
device node) or it may be different (e.g. in the case of a DUID).

Whilst here, change f_ctime to a 64 bit type and remove the pointless
f_spare members.

Compatibility goo courtesy of guenther@@

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.191 2013/03/28 02:39:17 guenther Exp $	*/
d1110 1
a1110 1
		fp->f_flag |= FHASLOCK;
d1292 1
a1292 1
		fp->f_flag |= FHASLOCK;
@


1.191
log
@When updating fd_cdir or fd_rdir, put the new pointer in place
_before_ vrele()'ing the old one, so that you can't catch the process
with a vnode with no references.

Similarly, in checkdirs(), just count the needed releases and do
them all at the end.  (I think I saw this in FreeBSD.)

Original problem encountered by landry@@ (yay for backtrace)
ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.190 2013/01/30 18:21:08 matthew Exp $	*/
d71 3
d693 185
@


1.190
log
@In doreadlinkat(), only access auio.uio_resid if it's already been
initialized.  (In the case where it wasn't initialized, the computed
*retval ends up getting clobbered by the EINVAL error anyway so it's
not an info leak, but it's still technically undefined behavior.)

pointed out by Maxime Villard on tech
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.189 2012/09/10 11:10:59 jsing Exp $	*/
d327 5
a331 1
 * mounted. If so, replace them with the new mount point.
d337 1
a337 1
	struct vnode *newdp, *vp;
d339 1
a344 1
again:
d348 1
a348 1
			vp = fdp->fd_cdir;
a350 2
			if (vrele(vp))
				goto again;
d353 1
a353 1
			vp = fdp->fd_rdir;
a355 2
			if (vrele(vp))
				goto again;
d359 1
a359 1
		vrele(rootvnode);
d363 2
d702 1
a702 1
	struct vnode *vp, *tdp;
d731 1
a731 1
	vrele(fdp->fd_cdir);
d733 1
d748 1
d756 1
a756 1
	vrele(fdp->fd_cdir);
d758 1
d773 1
a787 2
		vrele(fdp->fd_rdir);
		vrele(fdp->fd_cdir);
d789 7
a795 3
		fdp->fd_cdir = nd.ni_vp;
	}
	fdp->fd_rdir = nd.ni_vp;
@


1.189
log
@Cleanup VFS mount string handling:

- Avoid using copyinstr() without checking the return value.

- sys_mount() has already copied the path in, so pass this to the
  filesystem mount code so that it does not have to copy it in again.

- Avoid copyinstr()/bzero() dance when we can simply bzero() and strlcpy().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.187 2012/07/11 23:07:19 guenther Exp $	*/
d1846 1
a1848 1
	*retval = count - auio.uio_resid;
@


1.188
log
@delete compat_o48_sys_getdirentries; ok guenther
@
text
@d272 1
a272 1
	error = VFS_MOUNT(mp, SCARG(uap, path), SCARG(uap, data), &nd, p);
@


1.187
log
@Revert the blocked FIFO open fix, as there's either a race in the
ref-count handling under handling, or blambert@@ is messing with my head
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.184 2012/05/21 16:41:03 matthew Exp $	*/
a2767 23

#ifdef COMPAT_O48
int
compat_o48_sys_getdirentries(struct proc *p, void *v, register_t *retval)
{
	struct compat_o48_sys_getdirentries_args /* {
		syscallarg(int) fd;
		syscallarg(char *) buf;
		syscallarg(int) count;
		syscallarg(long *) basep;
	} */ *uap = v;
	int error;
	off_t off;

	error = getdirentries_internal(p, SCARG(uap, fd), SCARG(uap, buf),
	    SCARG(uap, count), &off, retval);
	if (!error) {
		long loff = (long)off;
		error = copyout(&loff, SCARG(uap, basep), sizeof(long));
	}
	return error;
}
#endif
@


1.186
log
@Don't release a FILE that wan't allocated.  Found by benno@@

ok matthew@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.185 2012/07/08 10:55:10 guenther Exp $	*/
d859 3
a861 4
	if ((error = falloc(p, &fp, &indx)) != 0) {
		fdpunlock(fdp);
		return (error);
	}
a864 1
	fdpunlock(fdp);
a873 1
		fdplock(fdp);
d876 3
a878 1
		    (error = dupfdopen(p, indx, fp, flags)) == 0) {
d884 3
a886 1
		goto err;
d908 4
a911 3
			/* FRELE will vn_close the file for us. */
			fdplock(fdp);
			goto err;
d930 4
a933 3
			/* FRELE will close the file for us. */
			fdplock(fdp);
			goto err;
a938 8
	return (0);

err:
	/* only remove the fd if the file didn't change behind out back */
	if (fdp->fd_ofiles[indx] == fp) {
		fdremove(fdp, indx);
		FRELE(fp, p);
	}
a940 1
	FRELE(fp, p);
@


1.185
log
@Don't hold the fd-table lock across vn_open(), as opening a FIFO may block.
Having done that, dupfdopen() has to handle a possible race.

ok matthew@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.184 2012/05/21 16:41:03 matthew Exp $	*/
d859 4
a862 2
	if ((error = falloc(p, &fp, &indx)) != 0)
		goto out;
@


1.184
log
@Cleanup O_CLOEXEC handling and make sure UF_EXCLOSE is set correctly
when opening /dev/fd/* (i.e., UF_EXCLOSE is now set iff O_CLOEXEC is
set, rather than copying UF_EXCLOSE from the file descriptor being
dup'd).

Also, add support for O_CLOEXEC and O_DIRECTORY to fhopen().

ok krw, guenther; feedback from millert; testing and bug finding by krw
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.183 2012/05/14 02:41:13 guenther Exp $	*/
a858 1

d864 1
d874 1
d877 1
a877 3
		    (error =
			dupfdopen(fdp, indx, p->p_dupfd, flags)) == 0) {
			closef(fp, p);
d883 1
a883 3
		fdremove(fdp, indx);
		closef(fp, p);
		goto out;
d905 3
a907 4
			/* closef will vn_close the file for us. */
			fdremove(fdp, indx);
			closef(fp, p);
			goto out;
d926 3
a928 4
			/* closef will close the file for us. */
			fdremove(fdp, indx);
			closef(fp, p);
			goto out;
d934 8
d944 1
@


1.183
log
@Remove the "vn_open() returning ENXIO means dup+close" hook that
was used by the now defunct portalfs.  Zero out fd_ofileflags[fd]
when allocating an fd instead of when releasing it.

ok krw@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.182 2012/04/22 05:43:14 guenther Exp $	*/
d862 3
a865 1
	flags = FFLAGS(oflags);
a936 2
	if (flags & O_CLOEXEC)
		fdp->fd_ofileflags[indx] |= UF_EXCLOSE;
d1022 2
d1042 4
@


1.182
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.181 2012/03/19 09:05:39 guenther Exp $	*/
d872 1
a872 1
		if ((error == ENODEV || error == ENXIO) &&
d875 1
a875 1
			dupfdopen(fdp, indx, p->p_dupfd, flags, error)) == 0) {
@


1.181
log
@Add tracing and dumping of "pointer to struct" syscall arguments for
structs timespec, timeval, sigaction, and rlimit.

ok otto@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.180 2011/11/06 15:09:02 guenther Exp $	*/
d610 1
a610 1
		FRELE(fp);
d615 1
a615 1
	FRELE(fp);
d938 1
a938 1
	FILE_SET_MATURE(fp);
d1094 1
a1094 1
	FILE_SET_MATURE(fp);
d1602 1
a1602 1
	FRELE(fp);
d1931 1
a1931 1
	FRELE(fp);
d2027 1
a2027 1
	FRELE(fp);
d2202 1
a2202 1
	FRELE(fp);
d2400 1
a2400 1
	FRELE(fp);
d2475 1
a2475 1
	FRELE(fp);
d2504 1
a2504 1
	FRELE(fp);
d2740 1
a2740 1
	FRELE(fp);
@


1.180
log
@Negative offsets to pread/pwrite-family are only legal for character devices.

Pointed out by Alexander Polakov (polachok at gmail.com)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.179 2011/11/05 15:47:37 guenther Exp $	*/
d2289 9
@


1.179
log
@ttys can't seek, so make pread/pwrite/preadv/pwritev fail with ESPIPE
on them too

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.178 2011/07/25 19:51:24 miod Exp $	*/
d2888 2
d2927 4
a2932 2
	offset = SCARG(uap, offset);

d2972 4
a2977 2
	offset = SCARG(uap, offset);

d3012 4
a3016 2

	offset = SCARG(uap, offset);
@


1.178
log
@Make sure vfsp is not used uninitialized in the mount -o update case;
ok krw@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.177 2011/07/18 00:16:54 matthew Exp $	*/
d2879 2
a2880 1
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
d2920 2
a2921 1
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
d2960 2
a2961 1
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
d3001 2
a3002 1
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
@


1.177
log
@Add support for UTIME_OMIT and UTIME_NOW to utimensat(2), add the
futimens(2) system call, and refactor futimes(2) to share the same
code.  (As with other openat(2) system call stuff, this is not exposed
to userland yet.)

naddy@@ pointed out rsync expects UTIME_* if openat(2) is available
tweaks and ok guenther@@; tested by naddy@@ in a bulk build
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.176 2011/07/14 18:03:06 matthew Exp $	*/
d149 1
@


1.176
log
@Add support for AT_REMOVEDIR to unlinkat(2), and switch sys_rmdir() to
use it.

ok tedu@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.175 2011/07/12 23:36:40 matthew Exp $	*/
d93 1
a93 1
int doutimensat(struct proc *, int, const char *, const struct timeval *,
d95 3
d2217 1
d2227 4
a2230 2
		tvp = tv;
	}
d2232 1
a2232 1
	return (doutimensat(p, AT_FDCWD, SCARG(uap, path), tvp, 0, retval));
a2244 1
	struct timeval tv[2];
a2245 1
	const struct timeval *tvp = NULL;
d2254 2
a2255 6
		tv[0].tv_sec = ts[0].tv_sec;
		tv[0].tv_usec = ts[0].tv_nsec / 1000;
		tv[1].tv_sec = ts[1].tv_sec;
		tv[1].tv_usec = ts[1].tv_nsec / 1000;
		tvp = tv;
	}
d2257 1
a2257 1
	return (doutimensat(p, SCARG(uap, fd), SCARG(uap, path), tvp,
d2263 1
a2263 1
    const struct timeval *tvp, int flag, register_t *retval)
a2265 2
	struct timeval tv[2];
	struct vattr vattr;
a2271 13
	VATTR_NULL(&vattr);
	if (tvp == NULL) {
		getmicrotime(&tv[0]);
		tv[1] = tv[0];
		vattr.va_vaflags |= VA_UTIMES_NULL;
	} else {
		bcopy(tvp, tv, sizeof(tv));
		/* XXX workaround timeval matching the VFS constant VNOVAL */
		if (tv[0].tv_sec == VNOVAL)
			tv[0].tv_sec = VNOVAL - 1;
		if (tv[1].tv_sec == VNOVAL)
			tv[1].tv_sec = VNOVAL - 1;
	}
d2277 39
d2320 2
a2321 4
		vattr.va_atime.tv_sec = tv[0].tv_sec;
		vattr.va_atime.tv_nsec = tv[0].tv_usec * 1000;
		vattr.va_mtime.tv_sec = tv[1].tv_sec;
		vattr.va_mtime.tv_nsec = tv[1].tv_usec * 1000;
a2338 1
	struct vnode *vp;
d2340 26
a2365 1
	struct vattr vattr;
a2366 1
	struct file *fp;
d2368 3
a2370 8
	VATTR_NULL(&vattr);
	if (SCARG(uap, tptr) == NULL) {
		getmicrotime(&tv[0]);
		tv[1] = tv[0];
		vattr.va_vaflags |= VA_UTIMES_NULL;
	} else {
		error = copyin(SCARG(uap, tptr), tv,
		    sizeof(tv));
d2373 14
a2386 7
		/* XXX workaround timeval matching the VFS constant VNOVAL */
		if (tv[0].tv_sec == VNOVAL)
			tv[0].tv_sec = VNOVAL - 1;
		if (tv[1].tv_sec == VNOVAL)
			tv[1].tv_sec = VNOVAL - 1;
	}
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
d2389 1
a2389 11
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
	if (vp->v_mount && vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		vattr.va_atime.tv_sec = tv[0].tv_sec;
		vattr.va_atime.tv_nsec = tv[0].tv_usec * 1000;
		vattr.va_mtime.tv_sec = tv[1].tv_sec;
		vattr.va_mtime.tv_nsec = tv[1].tv_usec * 1000;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
	VOP_UNLOCK(vp, 0, p);
d2391 2
a2392 1
	return (error);
@


1.175
log
@Fix typo that caused fchownat(2) and fchmodat(2) to try to dereference
symbolic links even when the AT_SYMLINK_NOFOLLOW flag is passed.

noticed by naddy@@ testing gnulib
ok deraadt@@ and presumably tedu@@ (who wrote a similar diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.174 2011/07/09 05:46:26 matthew Exp $	*/
d1490 2
a1491 3
	/* XXX: Support AT_REMOVEDIR. */
	if (flag != 0)
		return (ENOTSUP);
d1499 14
d1516 11
a1526 1
	if (vp->v_flag & VROOT) {
a1532 2
		error = EBUSY;
		goto out;
a1533 5

	(void)uvm_vnp_uncache(vp);

	error = VOP_REMOVE(nd.ni_dvp, nd.ni_vp, &nd.ni_cnd);
out:
a2639 3
	struct vnode *vp;
	int error;
	struct nameidata nd;
d2641 2
a2642 33
	NDINIT(&nd, DELETE, LOCKPARENT | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	if (vp->v_type != VDIR) {
		error = ENOTDIR;
		goto out;
	}
	/*
	 * No rmdir "." please.
	 */
	if (nd.ni_dvp == vp) {
		error = EBUSY;
		goto out;
	}
	/*
	 * The root of a mounted filesystem cannot be deleted.
	 */
	if (vp->v_flag & VROOT)
		error = EBUSY;
out:
	if (!error) {
		error = VOP_RMDIR(nd.ni_dvp, nd.ni_vp, &nd.ni_cnd);
	} else {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		vput(vp);
	}
	return (error);
@


1.174
log
@Fix up previous diff: use COMPAT_O48 instead of COMPAT_48, add option
to GENERIC, wrap compat_o48_sys_getdirentries() with an appropriate
#ifdef, and use struct compat_o48_sys_getdirentries_args instead of
struct sys_getdirentries_args.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.173 2011/07/09 05:31:26 matthew Exp $	*/
d1960 1
a1960 1
	NDINITAT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, fd, path, p);
d2057 1
a2057 1
	NDINITAT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, fd, path, p);
@


1.173
log
@More syscalls.master cleanup:

sys_osigaltstack() is 7 years old and no longer needed; all glory to
the sys_sigaltstack()!

sys_ogetdirentries() is about 9 months old, but still acceptable
within our release cycle; move from STD to COMPAT_48 to make this
clearer for tedu@@ next year.

sys_sbrk() and sys_sstk() are completely obsolete: all they do is
return ENOSYS.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.172 2011/07/09 01:28:48 matthew Exp $	*/
d2733 1
d2735 1
a2735 1
compat_48_sys_getdirentries(struct proc *p, void *v, register_t *retval)
d2737 1
a2737 1
	struct sys_getdirentries_args /* {
d2754 1
@


1.172
log
@Add support for the O_CLOEXEC and O_DIRECTORY flags introduced in
POSIX Issue 7.

Requested by oga@@ (and maybe djm@@); ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.171 2011/07/08 19:28:38 otto Exp $	*/
d2734 1
a2734 1
sys_ogetdirentries(struct proc *p, void *v, register_t *retval)
@


1.171
log
@Support sending struct info to kdump. So far for struct stat and
struct sockaddress; mostly from freebsd. ok deraadt@@ tedu@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.170 2011/07/08 04:23:24 matthew Exp $	*/
d931 2
@


1.170
log
@Add support for the AT_EACCESS, AT_SYMLINK_NOFOLLOW, and
AT_SYMLINK_FOLLOW flags.  Refactor sys_lstat to call dofstatat() with
AT_SYMLINK_NOFOLLOW.  Fix sys_link() to use AT_SYMLINK_FOLLOW when
calling dolinkat().

Additionally, fix a bug in VOP_ACCESS() where we might sleep while not
holding a reference count on the ucred object we pass down.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.169 2011/07/07 23:45:00 matthew Exp $	*/
d56 1
d1714 4
@


1.169
log
@Add new syscall entries to support the openat(2) family of functions
added in POSIX Issue 7: openat(), mknodat(), mkfifoat(), linkat(),
symlinkat(), unlinkat(), faccessat(), fstatat(), readlinkat(),
fchmodat(), fchownat(), utimensat(), renameat(), and mkdirat().

This diff mostly just refactors the existing sys_foo() logic into a
common dofooat() function that can then be called by both sys_foo()
and sys_fooat().  Some of the new system calls support new flags to
control their behavior, and proper support for these will be added in
subsequent diffs.

Incorporating suggestions from thib@@, guenther@@, and tedu@@.

ok tedu@@, thib@@, deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.168 2011/07/06 04:49:13 guenther Exp $	*/
d1329 1
a1329 1
	    SCARG(uap, link), 0, retval));
d1353 1
a1353 1
	int error;
d1356 2
a1357 3
	/* XXX: Support AT_SYMLINK_FOLLOW. */
	if (flag != 0)
		return (ENOTSUP);
d1359 2
a1360 1
	NDINITAT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, fd1, path1, p);
a1615 1
	struct ucred *cred = p->p_ucred;
d1617 1
a1617 1
	int error, flags, t_gid, t_uid;
d1622 3
a1624 7
	/* XXX: Support AT_EACCESS. */
	if (flag != 0)
		return (ENOTSUP);
	t_uid = cred->cr_uid;
	t_gid = cred->cr_gid;
	cred->cr_uid = p->p_cred->p_ruid;
	cred->cr_gid = p->p_cred->p_rgid;
d1627 1
a1627 1
		goto out1;
d1632 11
a1642 1
		flags = 0;
d1644 1
a1644 1
			flags |= VREAD;
d1646 1
a1646 1
			flags |= VWRITE;
d1648 1
a1648 1
			flags |= VEXEC;
d1650 2
a1651 2
		error = VOP_ACCESS(vp, flags, cred, p);
		if (!error && (flags & VWRITE))
d1653 2
a1656 3
out1:
	cred->cr_uid = t_uid;
	cred->cr_gid = t_gid;
d1695 1
a1695 1
	int error;
d1698 2
a1699 3
	/* XXX: Support AT_SYMLINK_NOFOLLOW (and make lstat use this??) */
	if (flag != 0)
		return (ENOTSUP);
d1701 2
a1702 1
	NDINITAT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE, fd, path, p);
a1726 3
	struct stat sb;
	int error;
	struct nameidata nd;
d1728 2
a1729 13
	NDINIT(&nd, LOOKUP, NOFOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	error = vn_stat(nd.ni_vp, &sb, p);
	vput(nd.ni_vp);
	if (error)
		return (error);
	/* Don't let non-root see generation numbers (for NFS security) */
	if (suser(p, 0))
		sb.st_gen = 0;
	error = copyout(&sb, SCARG(uap, ub), sizeof(sb));
	return (error);
d1944 1
a1944 1
	int error;
d1949 2
a1950 3
	/* XXX: Support AT_SYMLINK_NOFOLLOW. */
	if (flag != 0)
		return (ENOTSUP);
d1952 1
d2042 1
a2042 1
	int error;
d2046 2
a2047 3
	/* XXX: Support AT_SYMLINK_NOFOLLOW. */
	if (flag != 0)
		return (ENOTSUP);
d2049 1
d2245 1
a2245 1
	int error;
d2248 2
a2249 3
	/* XXX: Support AT_SYMLINK_NOFOLLOW. */
	if (flag != 0)
		return (ENOTSUP);
d2264 2
a2265 1
	NDINITAT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, fd, path, p);
@


1.168
log
@Return the correct error for fchdir(not_file_or_dir)

ok matthew@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.167 2011/07/06 04:41:16 matthew Exp $	*/
d74 21
d821 23
d858 3
a860 3
	flags = FFLAGS(SCARG(uap, flags));
	cmode = ((SCARG(uap, mode) &~ fdp->fd_cmask) & ALLPERMS) &~ S_ISTXT;
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
d1186 23
d1218 1
a1218 1
	NDINIT(&nd, CREATE, LOCKPARENT, UIO_USERSPACE, SCARG(uap, path), p);
d1226 2
a1227 2
		vattr.va_mode = (SCARG(uap, mode) & ALLPERMS) &~ p->p_fd->fd_cmask;
		vattr.va_rdev = SCARG(uap, dev);
d1229 1
a1229 1
		switch (SCARG(uap, mode) & S_IFMT) {
a1264 3
#ifndef FIFO
	return (EOPNOTSUPP);
#else
d1269 24
d1297 1
a1297 1
	NDINIT(&nd, CREATE, LOCKPARENT, UIO_USERSPACE, SCARG(uap, path), p);
d1311 1
a1311 1
	vattr.va_mode = (SCARG(uap, mode) & ALLPERMS) &~ p->p_fd->fd_cmask;
d1327 24
d1356 5
a1360 1
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
d1370 1
a1370 1
	NDINIT(&nd, CREATE, flags, UIO_USERSPACE, SCARG(uap, link), p);
d1400 22
d1428 1
a1428 1
	error = copyinstr(SCARG(uap, path), path, MAXPATHLEN, NULL);
d1431 1
a1431 1
	NDINIT(&nd, CREATE, LOCKPARENT, UIO_USERSPACE, SCARG(uap, link), p);
d1462 21
d1487 6
a1492 2
	NDINIT(&nd, DELETE, LOCKPARENT | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
d1593 23
a1619 1
	int userflags = SCARG(uap, flags);
d1621 1
a1621 1
	if (userflags & ~(R_OK | W_OK | X_OK))
d1623 3
d1630 1
a1630 2
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
d1636 1
a1636 1
	if (userflags) {
d1638 1
a1638 1
		if (userflags & R_OK)
d1640 1
a1640 1
		if (userflags & W_OK)
d1642 1
a1642 1
		if (userflags & X_OK)
d1667 23
d1694 5
a1698 2
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
d1708 1
a1708 1
	error = copyout(&sb, SCARG(uap, ub), sizeof(sb));
d1777 23
a1804 1
	size_t count = SCARG(uap, count);
d1806 1
a1806 2
	NDINIT(&nd, LOOKUP, NOFOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
d1813 1
a1813 1
		aiov.iov_base = SCARG(uap, buf);
d1929 23
d1957 1
a1957 1
	if (SCARG(uap, mode) & ~(S_IFMT | ALLPERMS))
d1959 3
d1963 1
a1963 1
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
d1972 1
a1972 1
		vattr.va_mode = SCARG(uap, mode) & ALLPERMS;
d2026 24
a2054 2
	uid_t uid = SCARG(uap, uid);
	gid_t gid = SCARG(uap, gid);
d2056 5
a2060 1
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
d2200 52
d2258 4
d2263 1
a2263 1
	if (SCARG(uap, tptr) == NULL) {
d2268 1
a2268 4
		error = copyin(SCARG(uap, tptr), tv,
		    sizeof(tv));
		if (error)
			return (error);
d2275 1
a2275 1
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
d2459 23
d2487 2
a2488 2
	NDINIT(&fromnd, DELETE, WANTPARENT | SAVESTART, UIO_USERSPACE,
	    SCARG(uap, from), p);
d2500 1
a2500 2
	NDINIT(&tond, RENAME, flags,
	    UIO_USERSPACE, SCARG(uap, to), p);
d2567 22
d2594 2
a2595 2
	NDINIT(&nd, CREATE, LOCKPARENT | STRIPSLASHES,
	    UIO_USERSPACE, SCARG(uap, path), p);
d2610 1
a2610 1
	vattr.va_mode = (SCARG(uap, mode) & ACCESSPERMS) &~ p->p_fd->fd_cmask;
@


1.167
log
@VOP_GETATTR() can sleep when accessing a file over NFS, so use
FREF()/FRELE() in lseek() so our struct file doesn't disappear in the
mean time.

Incorporating suggestions from tedu@@ and guenther@@; ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.166 2011/07/05 21:38:58 matthew Exp $	*/
d679 2
a680 2
	if ((error = getvnode(fdp, SCARG(uap, fd), &fp)) != 0)
		return (error);
d682 2
a684 1
	FRELE(fp);
d686 1
a686 4
	if (vp->v_type != VDIR)
		error = ENOTDIR;
	else
		error = VOP_ACCESS(vp, VEXEC, p->p_ucred, p);
@


1.166
log
@Don't worry about lseek(2)ing past the end of raw disk devices.  The
disk drivers are now smart enough to handle this correctly, as they
need to also handle pread(2)/pwrite(2).

ok deraadt@@, krw@@; ok marco@@ on an similar, earlier diff
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.165 2010/10/28 15:02:41 millert Exp $	*/
d1384 1
d1396 1
a1396 2
		error = VOP_GETATTR((struct vnode *)fp->f_data, &vattr,
				    cred, p);
d1398 1
a1398 1
			return (error);
d1405 2
a1406 1
		return (EINVAL);
d1409 4
a1412 2
		if (newoff < 0)
			return (EINVAL);
d1416 4
a1419 1
	return (0);
@


1.165
log
@Change basep parameter of getdirentries() to be off_t *, not long *
so it works correctly with large offsets (and matches other systems).
This requires adding a new getdirentries syscall, with the old one
renamed to ogetdirentries.  All in-tree consumers of getdirentries()
have been updated.  Bump libc and libpthread major numbers.
OK and with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.164 2010/10/27 17:11:08 deraadt Exp $	*/
d1392 1
a1392 1
		newoff = fp->f_offset + offarg;;
a1409 12
	} else {
		/*
		 * Make sure the user don't seek beyond the end of the
		 * partition.
		 */
		struct partinfo dpart;
		error = vn_ioctl(fp, DIOCGPART, (void *)&dpart, p);
		if (!error) {
			if (newoff >= DL_GETPSIZE(dpart.part) *
			    dpart.disklab->d_secsize)
					return (EINVAL);
		}
@


1.164
log
@The previous two commits cannot be right.  If in fact offsets > 4GB are
causing problems, then it is nonsense to instead fail at the 2GB line.
Much more discussion needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.161 2010/06/29 17:13:59 tedu Exp $	*/
d71 3
d2295 2
a2296 1
sys_getdirentries(struct proc *p, void *v, register_t *retval)
a2297 6
	struct sys_getdirentries_args /* {
		syscallarg(int) fd;
		syscallarg(char *) buf;
		syscallarg(int) count;
		syscallarg(long *) basep;
	} */ *uap = v;
a2301 1
	long loff;
d2304 1
a2304 1
	if (SCARG(uap, count) < 0)
d2306 1
a2306 1
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
d2312 4
d2321 2
a2322 2
	aiov.iov_base = SCARG(uap, buf);
	aiov.iov_len = SCARG(uap, count);
d2328 1
a2328 1
	auio.uio_resid = SCARG(uap, count);
d2330 1
a2330 1
	loff = auio.uio_offset = fp->f_offset;
d2336 1
a2336 3
	error = copyout(&loff, SCARG(uap, basep),
	    sizeof(long));
	*retval = SCARG(uap, count) - auio.uio_resid;
d2340 40
@


1.163
log
@Oops. Lost the < 0 check on file position I had in the circulated
diff. A bit of paranoia suggested by beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.162 2010/07/01 17:31:22 krw Exp $	*/
a2312 4
		goto bad;
	}
	if ((fp->f_offset < 0) || (fp->f_offset > LONG_MAX)) {
		error = EINVAL;
@


1.162
log
@Return EINVAL if the file position is greater than LONG_MAX, since
otherwise truncation will occur on archs where LONG LONG and LONG
are not the same.

Noticed at n2k10. Error return suggested by deraadt@@.

ok beck@@ millert@@ deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.161 2010/06/29 17:13:59 tedu Exp $	*/
d2315 1
a2315 1
	if (fp->f_offset > LONG_MAX) {
@


1.161
log
@Remove the "if the string address faulted, see if it looks like an int"
4.3 compat code in mount.  This is a flag day for those of you still running
4.3 BSD binaries on your vaxen. :)
ok deraadt dlg guenther thib
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.160 2010/06/29 04:07:39 tedu Exp $	*/
d2313 4
@


1.160
log
@eliminate some very redundant SCARG usage.  ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.159 2009/10/31 12:00:08 fgsch Exp $	*/
a90 3
#ifdef COMPAT_43
	u_long fstypenum = 0;
#endif
a195 19
#ifdef COMPAT_43
		/*
		 * Historically filesystem types were identified by number.
		 * If we get an integer for the filesystem type instead of a
		 * string, we check to see if it matches one of the historic
		 * filesystem types.
		 */
		fstypenum = (u_long)SCARG(uap, type);

		for (vfsp = vfsconf; vfsp; vfsp = vfsp->vfc_next)
			if (vfsp->vfc_typenum == fstypenum)
				break;
		if (vfsp == NULL) {
			vput(vp);
			return (ENODEV);
		}
		strncpy(fstypename, vfsp->vfc_name, MFSNAMELEN);

#else
a197 1
#endif
@


1.159
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.158 2009/09/08 17:41:20 miod Exp $	*/
d90 1
a90 1
	int error, flag = 0;
d99 1
d118 1
a118 1
	if (SCARG(uap, flags) & MNT_UPDATE) {
d124 1
a124 1
		flag = mp->mnt_flag;
d129 1
a129 1
		if ((SCARG(uap, flags) & MNT_RELOAD) &&
d150 1
a150 1
			if (SCARG(uap, flags) & MNT_EXPORTED) {
d154 3
a156 3
			SCARG(uap, flags) |= MNT_NOSUID | MNT_NODEV;
			if (flag & MNT_NOEXEC)
				SCARG(uap, flags) |= MNT_NOEXEC;
d162 1
a162 1
		mp->mnt_flag |= SCARG(uap, flags) & (MNT_RELOAD | MNT_UPDATE);
d181 1
a181 1
		if (SCARG(uap, flags) & MNT_EXPORTED) {
d185 1
a185 1
		SCARG(uap, flags) |= MNT_NOSUID | MNT_NODEV;
d187 1
a187 1
			SCARG(uap, flags) |= MNT_NOEXEC;
d253 1
a253 1
	if (SCARG(uap, flags) & MNT_RDONLY)
d260 1
a260 1
	mp->mnt_flag |= SCARG(uap, flags) & (MNT_NOSUID | MNT_NOEXEC |
d277 1
a277 1
			mp->mnt_flag = flag;
d310 1
a310 1
		mp->mnt_vnodecovered->v_mountedhere = (struct mount *)0;
d1462 1
d1464 1
a1464 1
	if (SCARG(uap, flags) & ~(R_OK | W_OK | X_OK))
d1477 1
a1477 1
	if (SCARG(uap, flags)) {
d1479 1
a1479 1
		if (SCARG(uap, flags) & R_OK)
d1481 1
a1481 1
		if (SCARG(uap, flags) & W_OK)
d1483 1
a1483 1
		if (SCARG(uap, flags) & X_OK)
d1597 1
d1608 1
a1608 1
		aiov.iov_len = SCARG(uap, count);
d1615 1
a1615 1
		auio.uio_resid = SCARG(uap, count);
d1619 1
a1619 1
	*retval = SCARG(uap, count) - auio.uio_resid;
d1638 1
d1647 1
a1647 1
	else if (SCARG(uap, flags) == VNOVAL)
d1659 1
a1659 1
		vattr.va_flags = SCARG(uap, flags);
d1682 1
d1690 1
a1690 1
	else if (SCARG(uap, flags) == VNOVAL)
d1703 1
a1703 1
		vattr.va_flags = SCARG(uap, flags);
d1799 2
d1810 1
a1810 1
		if ((SCARG(uap, uid) != -1 || SCARG(uap, gid) != -1) &&
d1822 2
a1823 2
		vattr.va_uid = SCARG(uap, uid);
		vattr.va_gid = SCARG(uap, gid);
d1849 2
d1860 1
a1860 1
		if ((SCARG(uap, uid) != -1 || SCARG(uap, gid) != -1) &&
d1872 2
a1873 2
		vattr.va_uid = SCARG(uap, uid);
		vattr.va_gid = SCARG(uap, gid);
d1899 2
d1909 1
a1909 1
		if ((SCARG(uap, uid) != -1 || SCARG(uap, gid) != -1) &&
d1920 2
a1921 2
		vattr.va_uid = SCARG(uap, uid);
		vattr.va_gid = SCARG(uap, gid);
@


1.158
log
@copyout() the correct size in sys_fhstatfs(), broken since 1.138.
ok millert@@ blambert@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.157 2009/09/02 19:05:44 fgsch Exp $	*/
d148 1
a148 1
		if (p->p_ucred->cr_uid != 0) {
d179 1
a179 1
	if (p->p_ucred->cr_uid != 0) {
@


1.157
log
@check if we have access to the vnode before checking if we can write to
it. thib@@ ok'd the idea and an earlier diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.156 2009/07/09 22:29:56 thib Exp $	*/
d1119 1
a1119 1
	struct sys_fhstatfs_args /*
d1148 1
a1148 1
	return (copyout(sp, SCARG(uap, buf), sizeof(sp)));
@


1.156
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.154 2009/06/03 03:57:20 blambert Exp $	*/
d1021 2
a1022 2
		if ((error = vn_writechk(vp)) != 0 ||
		    (error = VOP_ACCESS(vp, VWRITE, cred, p)) != 0)
d1483 4
a1486 2
		if ((flags & VWRITE) == 0 || (error = vn_writechk(vp)) == 0)
			error = VOP_ACCESS(vp, flags, cred, p);
d2046 2
a2047 2
	else if ((error = vn_writechk(vp)) == 0 &&
	    (error = VOP_ACCESS(vp, VWRITE, p->p_ucred, p)) == 0) {
@


1.155
log
@Put readv/writev changes back in, as they no longer hang ckuethe's ntpd.

Special thanks to ckuethe's ntpd for noticing the problem.

ok deraadt@@
@
text
@d338 1
a338 1
			VREF(newdp);
d345 1
a345 1
			VREF(newdp);
d353 1
a353 1
		VREF(newdp);
d701 1
a701 1
	VREF(vp);
d779 1
a779 1
		VREF(nd.ni_vp);
@


1.154
log
@Revert readv/writev changes, as they trigger an apparent file descriptor
deadlock for ckuethe@@

"if you have to revert, you have to revert" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.153 2009/06/02 03:04:09 blambert Exp $	*/
d2442 1
d2459 3
d2466 2
a2467 3
	/* dofileread() will FRELE the descriptor for us */
	return (dofileread(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &offset, retval));
d2504 1
a2504 1
	return (dofilereadv(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
d2521 1
d2538 3
d2546 1
a2546 2
	return (dofilewrite(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &offset, retval));
d2584 1
a2584 1
	    &offset, retval));
@


1.153
log
@dofile{read,write} are essentially identical to their iovec equivalents,
dofile{read,write}v, so remove the former and rework it so that everything
uses the latter

"nice" deraadt@@ "reads ok" oga@@ spastic 'OMG Ponies!!!!' weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.152 2008/11/11 02:11:25 tedu Exp $	*/
a2441 1
	struct iovec iov;
a2457 2
	iov.iov_base = (void *)SCARG(uap, buf);
	iov.iov_len = SCARG(uap, nbyte);
d2462 3
a2464 2
	/* dofilereadv() will FRELE the descriptor for us */
	return (dofilereadv(p, fd, fp, &iov, 1, &offset, retval));
a2517 1
	struct iovec iov;
a2535 2
	iov.iov_base = (void *)SCARG(uap, buf);
	iov.iov_len = SCARG(uap, nbyte);
d2538 3
a2540 2
	/* dofilewritev() will FRELE the descriptor for us */
	return (dofilewritev(p, fd, fp, &iov, 1, &offset, retval));
@


1.152
log
@make sure that any messing we do with a process's directories happens atomically and not after sleeping.
ok deraadt pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.151 2008/11/01 20:34:09 deraadt Exp $	*/
d2442 1
d2459 2
d2465 2
a2466 3
	/* dofileread() will FRELE the descriptor for us */
	return (dofileread(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &offset, retval));
d2520 1
d2539 2
d2543 2
a2544 3
	/* dofilewrite() will FRELE the descriptor for us */
	return (dofilewrite(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &offset, retval));
@


1.151
log
@change vrele() to return an int.  if it returns 0, it can gaurantee that
it did not sleep.  this is used to avoid checkdirs() to avoid having
to restart the allproc walk every time through
idea from tedu, ok thib pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.150 2008/10/31 16:49:17 deraadt Exp $	*/
d326 1
a326 1
	struct vnode *newdp;
a327 1
	int slept;
d337 1
a337 1
			slept = vrele(fdp->fd_cdir);
d340 1
a340 1
			if (slept)
d344 1
a344 1
			slept = vrele(fdp->fd_rdir);
d347 1
a347 1
			if (slept)
@


1.150
log
@checkdirs() walks allproc and calls sleeping functions if directories have
to be snapped.  Change it so that everytime it sleeps it restarts from the
top of the list.
ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.149 2008/08/08 19:49:09 thib Exp $	*/
d328 1
d338 1
a338 1
			vrele(fdp->fd_cdir);
d341 2
a342 1
			goto again;
d345 1
a345 1
			vrele(fdp->fd_rdir);
d348 2
a349 1
			goto again;
@


1.149
log
@remove an if notyet block from sys_fstatfs(), that will never be needed,
softupdates are reported too statfs via other means. missed this block
in in rev1.148 where the same block was removed from sys_statfs().
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.148 2008/07/28 14:21:17 thib Exp $	*/
d333 1
d340 1
d346 1
@


1.148
log
@
remove an #if noyet block that will never be needed.
softupdates are reported too statfs via the mount point flags
or the mount_info part of statfs;

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.147 2008/06/13 01:59:45 rainer Exp $	*/
d607 1
a607 4
#if notyet
	if (mp->mnt_flag & MNT_SOFTDEP)
		sp->f_eflags = STATFS_SOFTUPD;
#endif
@


1.147
log
@Delete vfs_bufstats() leftovers and unbreak compile with -DDEBUG

Ok reyk@@, "kill kill kill" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.146 2008/05/22 17:04:59 thib Exp $	*/
d574 1
a574 4
#if notyet
	if (mp->mnt_flag & MNT_SOFTDEP)
		sp->f_eflags = STATFS_SOFTUPD;
#endif
@


1.146
log
@Use LIST_FOREACH() instead of handrolling.

From: Pierre Riteau pierre.riteau_att_gmail.com
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.145 2008/01/22 14:33:40 millert Exp $	*/
a491 4
#ifdef DEBUG
	if (syncprt)
		vfs_bufstats();
#endif /* DEBUG */
@


1.145
log
@Fix a double VOP_UNLOCK() that was introduced into the error path
in rev 1.141.  From Christian Ehrhardt and Pedro Martelletto.
OK hshoexer@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.144 2007/11/28 16:56:46 tedu Exp $	*/
d333 1
a333 1
	for (p = LIST_FIRST(&allproc); p != 0; p = LIST_NEXT(p, p_list)) {
@


1.144
log
@a few more places where getmicrotime is good enough. ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.143 2007/09/07 15:00:20 art Exp $	*/
d1060 2
a1061 1
		if (error)
d1063 1
@


1.143
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.142 2007/08/30 12:35:27 thib Exp $	*/
d1940 1
a1940 1
		microtime(&tv[0]);
d1991 1
a1991 1
		microtime(&tv[0]);
@


1.142
log
@Fix lock ordering problems when updating mount points, in some
cases we could end up releasing an unlocked lock.

fixes pr's 5534 and 5564, confirmed by submitters.
thanks!.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.141 2007/08/06 16:58:26 millert Exp $	*/
d240 1
a240 2
		M_MOUNT, M_WAITOK);
	bzero((char *)mp, (u_long)sizeof(struct mount));
@


1.141
log
@Fix error path in sys_fhopen() if VOP_ADVLOCK fails.  Spotted by aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.140 2007/06/14 20:36:34 otto Exp $	*/
a160 1
		VOP_UNLOCK(vp, 0, p);
d271 1
a271 1
		vrele(vp);
@


1.140
log
@Forgotten hackton diff: bounds check for seek on special devices
with a disklabel.  Original diff from pedro@@; ok pedro@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.139 2007/01/16 17:52:18 thib Exp $	*/
d1062 2
a1063 6
		if (error) {
			/* closef will vn_close the file for us. */
			fdremove(fdp, indx);
			closef(fp, p);
			return (error);
		}
@


1.139
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.138 2006/11/24 17:04:20 art Exp $	*/
d54 2
d1402 1
d1416 2
d1420 1
a1420 3
		if (!special && fp->f_offset + SCARG(uap, offset) < 0)
			return (EINVAL);
		fp->f_offset += SCARG(uap, offset);
d1427 1
a1427 3
		if (!special && (off_t)vattr.va_size + SCARG(uap, offset) < 0)
			return (EINVAL);
		fp->f_offset = SCARG(uap, offset) + vattr.va_size;
d1430 1
a1430 3
		if (!special && SCARG(uap, offset) < 0)
			return (EINVAL);
		fp->f_offset = SCARG(uap, offset);
d1435 17
a1451 1
	*(off_t *)retval = fp->f_offset;
@


1.138
log
@When copying out struct statfs to userland, we need to zero out the fsid
field unless it's root that's asking. This far, this has been done by
putting a struct statfs on the stack and modifying it.

struct statfs is large. Large things on the stack are bad. Create
copyout_statfs() that copies out a struct statfs to userland, does the
necessary root check and gives userland what it needs withtout wasting
stack space.

pedro@@, deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.137 2006/06/25 15:01:54 sturm Exp $	*/
a891 1
		VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a1030 3
		VOP_UNLOCK(vp, 0, p);				/* XXX */
		VOP_LEASE(vp, p, cred, LEASE_WRITE);
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);	/* XXX */
a1205 1
		VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
a1251 1
	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
a1294 2
	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a1335 1
	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
a1377 2
	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a1631 1
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a1673 1
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a1721 1
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a1755 1
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a1790 1
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a1838 1
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a1885 1
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a1948 1
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a1998 1
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a2034 1
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a2073 1
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
a2175 3
		VOP_LEASE(tdvp, p, p->p_ucred, LEASE_WRITE);
		if (fromnd.ni_dvp != tdvp)
			VOP_LEASE(fromnd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
a2177 1
			VOP_LEASE(tvp, p, p->p_ucred, LEASE_WRITE);
a2236 1
	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
a2279 2
		VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
		VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
@


1.137
log
@rename vfs_busy() flags VB_UMIGNORE/VB_UMWAIT to VB_NOWAIT/VB_WAIT

requested by and ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.136 2006/06/14 20:01:50 sturm Exp $	*/
d67 2
d525 28
a567 1
	struct statfs sb;
d582 1
a582 7
	/* Don't let non-root see filesystem id (for NFS security) */
	if (suser(p, 0)) {
		bcopy(sp, &sb, sizeof(sb));
		sb.f_fsid.val[0] = sb.f_fsid.val[1] = 0;
		sp = &sb;
	}
	return (copyout(sp, SCARG(uap, buf), sizeof(*sp)));
a599 1
	struct statfs sb;
d618 1
a618 7
	/* Don't let non-root see filesystem id (for NFS security) */
	if (suser(p, 0)) {
		bcopy(sp, &sb, sizeof(sb));
		sb.f_fsid.val[0] = sb.f_fsid.val[1] = 0;
		sp = &sb;
	}
	return (copyout(sp, SCARG(uap, buf), sizeof(*sp)));
a633 1
	struct statfs sb;
d667 1
a667 6
			if (suser(p, 0)) {
				bcopy(sp, &sb, sizeof(sb));
				sb.f_fsid.val[0] = sb.f_fsid.val[1] = 0;
				sp = &sb;
			}
			error = copyout(sp, sfsp, sizeof(*sp));
d1134 1
a1134 1
	struct statfs sp;
d1154 1
d1156 1
a1156 1
	if ((error = VFS_STATFS(mp, &sp, p)) != 0)
d1158 2
a1159 2
	sp.f_flags = mp->mnt_flag & MNT_VISFLAGMASK;
	return (copyout(&sp, SCARG(uap, buf), sizeof(sp)));
@


1.136
log
@move vfs_busy() to rwlocks and properly hide the locking api from vfs

ok tedu, pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.135 2006/05/27 17:37:42 sturm Exp $	*/
d153 1
a153 1
		if ((error = vfs_busy(mp, VB_READ|VB_UMIGNORE)) != 0) {
d239 1
a239 1
	(void) vfs_busy(mp, VB_READ|VB_UMIGNORE);
d405 1
a405 1
	if (vfs_busy(mp, VB_WRITE|VB_UMWAIT))
d474 1
a474 1
		if (vfs_busy(mp, VB_READ|VB_UMIGNORE)) {
d629 1
a629 1
		if (vfs_busy(mp, VB_READ|VB_UMIGNORE)) {
d705 1
a705 1
		if (vfs_busy(mp, VB_READ|VB_UMWAIT))
@


1.135
log
@remove useless error check and irritating comment

ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.134 2006/04/30 14:20:07 sturm Exp $	*/
d153 1
a153 1
		if ((error = vfs_busy(mp, LK_NOWAIT)) != 0) {
d239 1
a239 2
	lockinit(&mp->mnt_lock, PVFS, "vfslock", 0, 0);
	(void) vfs_busy(mp, LK_NOWAIT);
d405 1
a405 1
	if (vfs_busy(mp, LK_EXCLUSIVE))
d436 1
a436 1
		lockmgr(&mp->mnt_lock, LK_RELEASE | LK_INTERLOCK, NULL);
d451 1
a451 1
	lockmgr(&mp->mnt_lock, LK_RELEASE | LK_INTERLOCK, NULL);
d474 1
a474 1
		if (vfs_busy(mp, LK_NOWAIT)) {
d629 1
a629 1
		if (vfs_busy(mp, LK_NOWAIT)) {
d705 1
a705 1
		if (vfs_busy(mp, 0))
@


1.134
log
@remove the simplelock argument from vfs_busy() which is currently not
used and will never be used this way in VFS

requested by and ok pedro, ok krw, biorn
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.133 2006/04/19 11:55:55 pedro Exp $	*/
d240 1
a240 3
	/* This error never happens, but it makes auditing easier */
	if ((error = vfs_busy(mp, LK_NOWAIT)))
		return (error);
@


1.133
log
@Remove unused mount list simple_lock() goo
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.132 2006/03/26 17:47:10 mickey Exp $	*/
d153 1
a153 1
		if ((error = vfs_busy(mp, LK_NOWAIT, NULL)) != 0) {
d241 1
a241 1
	if ((error = vfs_busy(mp, LK_NOWAIT, NULL)))
d408 1
a408 1
	if (vfs_busy(mp, LK_EXCLUSIVE, NULL))
d477 1
a477 1
		if (vfs_busy(mp, LK_NOWAIT, NULL)) {
d632 1
a632 1
		if (vfs_busy(mp, LK_NOWAIT, NULL)) {
d708 1
a708 1
		if (vfs_busy(mp, 0, NULL))
@


1.132
log
@do per file io accounting and show that in fstat as well; pedro@@ marco@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.131 2006/01/07 07:39:55 deraadt Exp $	*/
a299 1
		simple_lock(&mountlist_slock);
a300 1
		simple_unlock(&mountlist_slock);
d435 1
a435 1
	simple_lock(&mountlist_slock);
d439 1
a439 2
		lockmgr(&mp->mnt_lock, LK_RELEASE | LK_INTERLOCK,
		    &mountlist_slock);
d442 1
d448 1
d450 1
d453 2
a454 1
	lockmgr(&mp->mnt_lock, LK_RELEASE | LK_INTERLOCK, &mountlist_slock);
d456 1
a474 1
	simple_lock(&mountlist_slock);
d477 1
a477 1
		if (vfs_busy(mp, LK_NOWAIT, &mountlist_slock)) {
a488 1
		simple_lock(&mountlist_slock);
a491 1
	simple_unlock(&mountlist_slock);
d629 1
a629 1
	simple_lock(&mountlist_slock);
d632 1
a632 1
		if (vfs_busy(mp, LK_NOWAIT, &mountlist_slock)) {
a644 1
				simple_lock(&mountlist_slock);
a667 1
		simple_lock(&mountlist_slock);
d671 1
a671 1
	simple_unlock(&mountlist_slock);
d676 1
@


1.131
log
@p_dupfd need only be -1, nothing else.  but this is nothing like what aaron has coming...
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.130 2005/11/30 10:35:08 pedro Exp $	*/
d1442 1
@


1.130
log
@No need for vfs_busy() and vfs_unbusy() to take a process pointer
anymore. Testing by jolan@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.129 2005/11/27 12:37:58 pedro Exp $	*/
d838 1
a838 1
	p->p_dupfd = -indx - 1;			/* XXX check for fdopen */
@


1.129
log
@Don't set MNT_UPDATE and MNT_RELOAD before acquiring the mount point
lock. Fixes a race as seen on PR kern/4915. Okay miod@@ and joris@@,
tested by krw@@ and hshoexer@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.128 2005/11/19 02:18:01 pedro Exp $	*/
d153 1
a153 1
		if ((error = vfs_busy(mp, LK_NOWAIT, 0, p)) != 0) {
d241 1
a241 1
	if ((error = vfs_busy(mp, LK_NOWAIT, 0, p)))
d288 1
a288 1
		vfs_unbusy(mp, p);
d307 1
a307 1
		vfs_unbusy(mp, p);
d313 1
a313 1
		vfs_unbusy(mp, p);
d410 1
a410 1
	if (vfs_busy(mp, LK_EXCLUSIVE, NULL, p))
d476 1
a476 1
		if (vfs_busy(mp, LK_NOWAIT, &mountlist_slock, p)) {
d490 1
a490 1
		vfs_unbusy(mp, p);
d633 1
a633 1
		if (vfs_busy(mp, LK_NOWAIT, &mountlist_slock, p)) {
d648 1
a648 1
				vfs_unbusy(mp, p);
d664 1
a664 1
				vfs_unbusy(mp, p);
d672 1
a672 1
		vfs_unbusy(mp, p);
d710 1
a710 1
		if (vfs_busy(mp, 0, 0, p))
d713 1
a713 1
		vfs_unbusy(mp, p);
@


1.128
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.127 2005/11/08 15:43:44 pedro Exp $	*/
d129 1
a129 2
		mp->mnt_flag |=
		    SCARG(uap, flags) & (MNT_RELOAD | MNT_UPDATE);
d158 1
@


1.127
log
@Use ANSI function declarations and deregister, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.126 2005/07/03 20:13:59 drahn Exp $	*/
d442 1
a442 1
		    &mountlist_slock, p);
d453 1
a453 1
	lockmgr(&mp->mnt_lock, LK_RELEASE | LK_INTERLOCK, &mountlist_slock, p);
@


1.126
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.125 2005/06/17 20:39:14 millert Exp $	*/
d76 1
a76 4
sys_mount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d78 1
a78 1
	register struct sys_mount_args /* {
d84 2
a85 2
	register struct vnode *vp;
	register struct mount *mp;
d326 1
a326 2
checkdirs(olddp)
	struct vnode *olddp;
d365 1
a365 4
sys_unmount(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d367 1
a367 1
	register struct sys_unmount_args /* {
d371 1
a371 1
	register struct vnode *vp;
d468 1
a468 4
sys_sync(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d470 1
a470 1
	register struct mount *mp, *nmp;
d506 1
a506 4
sys_quotactl(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d508 1
a508 1
	register struct sys_quotactl_args /* {
d514 1
a514 1
	register struct mount *mp;
d532 1
a532 4
sys_statfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d534 1
a534 1
	register struct sys_statfs_args /* {
d538 2
a539 2
	register struct mount *mp;
	register struct statfs *sp;
d571 1
a571 4
sys_fstatfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d613 1
a613 4
sys_getfsstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d615 1
a615 1
	register struct sys_getfsstat_args /* {
d620 2
a621 2
	register struct mount *mp, *nmp;
	register struct statfs *sp;
d687 1
a687 4
sys_fchdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d734 1
a734 4
sys_chdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d739 1
a739 1
	register struct filedesc *fdp = p->p_fd;
d757 1
a757 4
sys_chroot(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d762 1
a762 1
	register struct filedesc *fdp = p->p_fd;
d790 1
a790 3
change_dir(ndp, p)
	register struct nameidata *ndp;
	struct proc *p;
d814 1
a814 4
sys_open(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d919 1
a919 4
sys_getfh(p, v, retval)
	struct proc *p;
	register void *v;
	register_t *retval;
d921 1
a921 1
	register struct sys_getfh_args /* {
d925 1
a925 1
	register struct vnode *vp;
d959 1
a959 4
sys_fhopen(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d961 1
a961 1
	register struct sys_fhopen_args /* {
d1088 1
a1088 4
sys_fhstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1090 1
a1090 1
	register struct sys_fhstat_args /* {
d1123 1
a1123 4
sys_fhstatfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1125 1
a1125 1
	register struct sys_fhstatfs_args /*
d1161 1
a1161 4
sys_mknod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1163 1
a1163 1
	register struct sys_mknod_args /* {
d1168 1
a1168 1
	register struct vnode *vp;
d1223 1
a1223 4
sys_mkfifo(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1228 1
a1228 1
	register struct sys_mkfifo_args /* {
d1261 1
a1261 4
sys_link(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1263 1
a1263 1
	register struct sys_link_args /* {
d1267 1
a1267 1
	register struct vnode *vp;
d1308 1
a1308 4
sys_symlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1310 1
a1310 1
	register struct sys_symlink_args /* {
d1350 1
a1350 4
sys_unlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1355 1
a1355 1
	register struct vnode *vp;
d1392 1
a1392 4
sys_lseek(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1394 1
a1394 1
	register struct sys_lseek_args /* {
d1401 2
a1402 2
	register struct filedesc *fdp = p->p_fd;
	register struct file *fp;
d1449 1
a1449 4
sys_access(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1451 1
a1451 1
	register struct sys_access_args /* {
d1455 2
a1456 2
	register struct ucred *cred = p->p_ucred;
	register struct vnode *vp;
d1496 1
a1496 4
sys_stat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1498 1
a1498 1
	register struct sys_stat_args /* {
d1526 1
a1526 4
sys_lstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1528 1
a1528 1
	register struct sys_lstat_args /* {
d1556 1
a1556 4
sys_pathconf(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1558 1
a1558 1
	register struct sys_pathconf_args /* {
d1579 1
a1579 4
sys_readlink(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1581 1
a1581 1
	register struct sys_readlink_args /* {
d1586 1
a1586 1
	register struct vnode *vp;
d1621 1
a1621 4
sys_chflags(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1623 1
a1623 1
	register struct sys_chflags_args /* {
d1627 1
a1627 1
	register struct vnode *vp;
d1665 1
a1665 4
sys_fchflags(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1710 1
a1710 4
sys_chmod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1712 1
a1712 1
	register struct sys_chmod_args /* {
d1716 1
a1716 1
	register struct vnode *vp;
d1746 1
a1746 4
sys_fchmod(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1782 1
a1782 4
sys_chown(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1784 1
a1784 1
	register struct sys_chown_args /* {
d1789 1
a1789 1
	register struct vnode *vp;
d1831 1
a1831 4
sys_lchown(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1833 1
a1833 1
	register struct sys_lchown_args /* {
d1838 1
a1838 1
	register struct vnode *vp;
d1880 1
a1880 4
sys_fchown(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1928 1
a1928 4
sys_utimes(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1930 1
a1930 1
	register struct sys_utimes_args /* {
d1934 1
a1934 1
	register struct vnode *vp;
a1974 1

d1980 1
a1980 4
sys_futimes(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1982 1
a1982 1
	register struct sys_futimes_args /* {
d2032 1
a2032 4
sys_truncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d2034 1
a2034 1
	register struct sys_truncate_args /* {
d2039 1
a2039 1
	register struct vnode *vp;
d2067 1
a2067 4
sys_ftruncate(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d2108 1
a2108 4
sys_fsync(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d2138 1
a2138 4
sys_rename(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d2140 1
a2140 1
	register struct sys_rename_args /* {
d2144 1
a2144 1
	register struct vnode *tvp, *fvp, *tdvp;
d2228 1
a2228 4
sys_mkdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d2230 1
a2230 1
	register struct sys_mkdir_args /* {
d2234 1
a2234 1
	register struct vnode *vp;
d2268 1
a2268 4
sys_rmdir(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d2273 1
a2273 1
	register struct vnode *vp;
d2318 1
a2318 4
sys_getdirentries(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d2373 1
a2373 4
sys_umask(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d2378 1
a2378 1
	register struct filedesc *fdp;
d2392 1
a2392 4
sys_revoke(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d2394 1
a2394 1
	register struct sys_revoke_args /* {
d2397 1
a2397 1
	register struct vnode *vp;
d2424 1
a2424 4
getvnode(fdp, fd, fpp)
	struct filedesc *fdp;
	struct file **fpp;
	int fd;
d2449 1
a2449 4
sys_pread(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d2487 1
a2487 4
sys_preadv(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d2525 1
a2525 4
sys_pwrite(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
a2558 1

d2563 1
a2563 4
sys_pwritev(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
@


1.125
log
@remove undelete syscall
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.124 2005/05/27 23:44:05 marius Exp $	*/
a53 1
#include <sys/extattr.h>
a2747 402

#ifdef UFS_EXTATTR
/*
 * Syscall to push extended attribute configuration information into the
 * VFS.  Accepts a path, which it converts to a mountpoint, as well as
 * a command (int cmd), and attribute name and misc data.  For now, the
 * attribute name is left in userspace for consumption by the VFS_op.
 * It will probably be changed to be copied into sysspace by the
 * syscall in the future, once issues with various consumers of the
 * attribute code have raised their hands.
 *
 * Currently this is used only by UFS Extended Attributes.
 */
int
sys_extattrctl(struct proc *p, void *v, register_t *reval)
{
	struct sys_extattrctl_args /* {
		syscallarg(const char *) path;
		syscallarg(int) cmd;
		syscallarg(const char *) filename;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
	} */ *uap = v;
	struct vnode *filename_vp;
	struct nameidata nd;
	struct mount *mp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	/*
	 * SCARG(uap, attrname) not always defined.  We check again later
	 * when we invoke the VFS call so as to pass in NULL there if needed.
	 */
	if (SCARG(uap, attrname) != NULL) {
		error = copyinstr(SCARG(uap, attrname), attrname,
		    EXTATTR_MAXNAMELEN, NULL);
		if (error)
			return (error);
	}

	/*
	 * SCARG(uap, filename) not always defined.  If it is, grab
	 * a vnode lock, which VFS_EXTATTRCTL() will later release.
	 */
	filename_vp = NULL;
	if (SCARG(uap, filename) != NULL) {
		NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
		    SCARG(uap, filename), p);
		if ((error = namei(&nd)) != 0)
			return (error);
		filename_vp = nd.ni_vp;
	}

	/* SCARG(uap, path) always defined. */
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0) {
		if (filename_vp != NULL)
			vput(filename_vp);
		return (error);
	}

	mp = nd.ni_vp->v_mount;
	if (error) {
		if (filename_vp != NULL)
			vput(filename_vp);
		return (error);
	}

	if (SCARG(uap, attrname) != NULL) {
		error = VFS_EXTATTRCTL(mp, SCARG(uap, cmd), filename_vp,
		    SCARG(uap, attrnamespace), attrname, p);
	} else {
		error = VFS_EXTATTRCTL(mp, SCARG(uap, cmd), filename_vp,
		    SCARG(uap, attrnamespace), NULL, p);
	}

	/*
	 * VFS_EXTATTRCTL will have unlocked, but not de-ref'd,
	 * filename_vp, so vrele it if it is defined.
	 */
	if (filename_vp != NULL)
		vrele(filename_vp);

	return (error);
}

/*-
 * Set a named extended attribute on a file or directory
 * 
 * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",
 *            kernelspace string pointer "attrname", userspace buffer
 *            pointer "data", buffer length "nbytes", thread "td".
 * Returns: 0 on success, an error number otherwise
 * Locks: none
 * References: vp must be a valid reference for the duration of the call
 */
static int
extattr_set_vp(struct vnode *vp, int attrnamespace, const char *attrname,
    void *data, size_t nbytes, struct proc *p, register_t *retval)
{
	struct uio auio;
	struct iovec aiov;
	ssize_t cnt;
	int error;

	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	aiov.iov_base = data;
	aiov.iov_len = nbytes;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_offset = 0;
	if (nbytes > INT_MAX) {
		error = EINVAL;
		goto done;
	}
	auio.uio_resid = nbytes;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;
	cnt = nbytes;

	error = VOP_SETEXTATTR(vp, attrnamespace, attrname, &auio,
	    p->p_ucred, p);
	cnt -= auio.uio_resid;
	retval[0] = cnt;

done:
	VOP_UNLOCK(vp, 0, p);
	return (error);
}

int
sys_extattr_set_file(struct proc *p, void *v, register_t *retval)
{
	struct sys_extattr_set_file_args /* {
		syscallarg(const char *) path;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct nameidata nd;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);

	error = extattr_set_vp(nd.ni_vp, SCARG(uap, attrnamespace), attrname,
	    SCARG(uap, data), SCARG(uap, nbytes), p, retval);

	vrele(nd.ni_vp);
	return (error);
}

int
sys_extattr_set_fd(struct proc *p, void *v, register_t *retval)
{
	struct sys_extattr_set_fd_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct file *fp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	error = extattr_set_vp((struct vnode *)fp->f_data,
	    SCARG(uap, attrnamespace), attrname, SCARG(uap, data),
	    SCARG(uap, nbytes), p, retval);
	FRELE(fp);

	return (error);
}

/*-
 * Get a named extended attribute on a file or directory
 * 
 * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",
 *            kernelspace string pointer "attrname", userspace buffer
 *            pointer "data", buffer length "nbytes", thread "td".
 * Returns: 0 on success, an error number otherwise
 * Locks: none
 * References: vp must be a valid reference for the duration of the call
 */
static int
extattr_get_vp(struct vnode *vp, int attrnamespace, const char *attrname,
    void *data, size_t nbytes, struct proc *p, register_t *retval)
{
	struct uio auio;
	struct iovec aiov;
	ssize_t cnt;
	size_t size;
	int error;

	VOP_LEASE(vp, p, p->p_ucred, LEASE_READ);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	/*
	 * Slightly unusual semantics: if the user provides a NULL data
	 * pointer, they don't want to receive the data, just the
	 * maximum read length.
	 */
	if (data != NULL) {
		aiov.iov_base = data;
		aiov.iov_len = nbytes;
		auio.uio_iov = &aiov;
		auio.uio_offset = 0;
		if (nbytes > INT_MAX) {
			error = EINVAL;
			goto done;
		}
		auio.uio_resid = nbytes;
		auio.uio_rw = UIO_READ;
		auio.uio_segflg = UIO_USERSPACE;
		auio.uio_procp = p;
		cnt = nbytes;
		error = VOP_GETEXTATTR(vp, attrnamespace, attrname, &auio,
		    NULL, p->p_ucred, p);
		cnt -= auio.uio_resid;
		retval[0] = cnt;
	} else {
		error = VOP_GETEXTATTR(vp, attrnamespace, attrname, NULL,
		    &size, p->p_ucred, p);
		retval[0] = size;
	}
done:
	VOP_UNLOCK(vp, 0, p);
	return (error);
}

int
sys_extattr_get_file(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_get_file_args /* {
		syscallarg(const char *) path;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct nameidata nd;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);

	error = extattr_get_vp(nd.ni_vp, SCARG(uap, attrnamespace), attrname,
	    SCARG(uap, data), SCARG(uap, nbytes), p, retval);

	vrele(nd.ni_vp);
	return (error);
}

int
sys_extattr_get_fd(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_get_fd_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct file *fp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	error = extattr_get_vp((struct vnode *)fp->f_data,
	    SCARG(uap, attrnamespace), attrname, SCARG(uap, data),
	    SCARG(uap, nbytes), p, retval);
	FRELE(fp);

	return (error);
}

/*
 * extattr_delete_vp(): Delete a named extended attribute on a file or
 *                      directory
 * 
 * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",
 *            kernelspace string pointer "attrname", proc "p"
 * Returns: 0 on success, an error number otherwise
 * Locks: none
 * References: vp must be a valid reference for the duration of the call
 */
static int
extattr_delete_vp(struct vnode *vp, int attrnamespace, const char *attrname,
    struct proc *p)
{
	int error;

	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	error = VOP_SETEXTATTR(vp, attrnamespace, attrname, NULL,
	    p->p_ucred, p);

	VOP_UNLOCK(vp, 0, p);
	return (error);
}

int
sys_extattr_delete_file(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_delete_file_args /* {
		syscallarg(const char *) path;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
	} */ *uap = v;
	struct nameidata nd;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	     NULL);
	if (error)
		return(error);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return(error);

	error = extattr_delete_vp(nd.ni_vp, SCARG(uap, attrnamespace),
	    attrname, p);

	vrele(nd.ni_vp);
	return(error);
}

int
sys_extattr_delete_fd(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_delete_fd_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
	} */ *uap = v; 
	struct file *fp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	error = extattr_delete_vp((struct vnode *)fp->f_data,
	    SCARG(uap, attrnamespace), attrname, p);
	FRELE(fp);

	return (error);
}
#endif 
@


1.124
log
@remove some dead code.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.123 2005/05/27 20:20:23 pedro Exp $	*/
a1403 13
}

/*
 * Delete a whiteout from the filesystem.
 */
/* ARGSUSED */
int
sys_undelete(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	return (ENOSYS);
@


1.123
log
@remove references of VOP_WHITEOUT from the kernel, okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.122 2005/05/27 17:31:47 pedro Exp $	*/
a2502 2
	if (error)
		goto bad;
@


1.122
log
@prepare the removal of sys_undelete(), make it a stub, okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.121 2005/05/26 00:33:45 pedro Exp $	*/
a1222 1
	int whiteout = 0;
a1238 1
		whiteout = 0;
a1249 3
		case S_IFWHT:
			whiteout = 1;
			break;
d1257 1
a1257 9
		if (whiteout) {
			error = VOP_WHITEOUT(nd.ni_dvp, &nd.ni_cnd, CREATE);
			if (error)
				VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
			vput(nd.ni_dvp);
		} else {
			error = VOP_MKNOD(nd.ni_dvp, &nd.ni_vp,
						&nd.ni_cnd, &vattr);
		}
@


1.121
log
@RIP stackable filesystems, ok marius@@ tedu@@, discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.120 2005/05/24 05:34:54 pedro Exp $	*/
d1429 1
a1429 28
	register struct sys_undelete_args /* {
		syscallarg(const char *) path;
	} */ *uap = v;
	int error;
	struct nameidata nd;

	NDINIT(&nd, DELETE, LOCKPARENT|DOWHITEOUT, UIO_USERSPACE,
	    SCARG(uap, path), p);
	error = namei(&nd);
	if (error)
		return (error);

	if (nd.ni_vp != NULLVP || !(nd.ni_cnd.cn_flags & ISWHITEOUT)) {
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
		if (nd.ni_dvp == nd.ni_vp)
			vrele(nd.ni_dvp);
		else
			vput(nd.ni_dvp);
		if (nd.ni_vp)
			vrele(nd.ni_vp);
		return (EEXIST);
	}

	VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
	if ((error = VOP_WHITEOUT(nd.ni_dvp, &nd.ni_cnd, DELETE)) != 0)
		VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
	vput(nd.ni_dvp);
	return (error);
@


1.120
log
@when a device vnode associated with a mount point disappears, mark the
filesystem as doomed and unmount it
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.119 2004/12/26 21:22:13 miod Exp $	*/
a68 11
 * Redirection info so we don't have to include the union fs routines in
 * the kernel directly.  This way, we can build unionfs as an LKM.  The
 * pointer gets filled in later, when we modload the LKM, or when the
 * compiled-in unionfs code gets initialized.  For now, we just set
 * it to a stub routine.
 */

int (*union_check_p)(struct proc *, struct vnode **,
    struct file *, struct uio, int *) = NULL;

/*
d262 4
a265 1
	    MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC | MNT_SOFTDEP |
a266 3
	mp->mnt_flag |= SCARG(uap, flags) & (MNT_NOSUID | MNT_NOEXEC |
	    MNT_NODEV | MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC |
	    MNT_SOFTDEP | MNT_NOATIME | MNT_FORCE);
a2525 1
unionread:
a2544 4
	if ((SCARG(uap, count) == auio.uio_resid) &&
	    union_check_p &&
	    (union_check_p(p, &vp, fp, auio, &error) != 0))
		goto unionread;
a2546 12

	if ((SCARG(uap, count) == auio.uio_resid) &&
	    (vp->v_flag & VROOT) &&
	    (vp->v_mount->mnt_flag & MNT_UNION)) {
		struct vnode *tvp = vp;
		vp = vp->v_mount->mnt_vnodecovered;
		VREF(vp);
		fp->f_data = vp;
		fp->f_offset = 0;
		vrele(tvp);
		goto unionread;
	}
d2603 1
a2603 1
	if (vp->v_usecount > 1 || (vp->v_flag & (VALIASED | VLAYER)))
@


1.119
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.118 2004/09/16 10:37:41 pedro Exp $	*/
d457 1
a457 1
 	if (error) {
@


1.118
log
@check for VBAD vnodes on getvnode(). ok andreas@@, tedu@@ and marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.117 2004/08/05 04:46:26 tedu Exp $	*/
d470 1
a470 1
	if (mp->mnt_vnodelist.lh_first != NULL)
@


1.117
log
@don't attempt to put processes back in a directory after unmount.
it could never always work, and worse, may cause other bugs/crashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.116 2004/07/22 06:13:08 tedu Exp $	*/
d2650 1
d2654 1
d2657 5
@


1.116
log
@remove p arg from fdplock
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.115 2004/07/18 12:05:07 avsm Exp $	*/
a441 1
	struct proc *p2;
a465 23
		if (olddp) {
			/* 
			 * Try to put processes back in a real directory
			 * after a forced unmount.
			 * XXX We're not holding a ref on olddp, which may
			 * change, so compare id numbers.
			 */
			LIST_FOREACH(p2, &allproc, p_list) {
				struct filedesc *fdp = p2->p_fd;
				if (fdp->fd_cdir &&
				    fdp->fd_cdir->v_id == olddp->v_id) {
					vrele(fdp->fd_cdir);
					vref(coveredvp);
					fdp->fd_cdir = coveredvp;
				}
				if (fdp->fd_rdir &&
				    fdp->fd_rdir->v_id == olddp->v_id) {
					vrele(fdp->fd_rdir);
					vref(coveredvp);
					fdp->fd_rdir = coveredvp;
				}
			}
		}
@


1.115
log
@return EINVAL if ftruncate(2) is passed a negative offset
ok millert@@, miod@@, marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.114 2004/07/13 21:04:29 millert Exp $	*/
d902 1
a902 1
	fdplock(fdp, p);
d1066 1
a1066 1
	fdplock(fdp, p);
@


1.114
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.113 2004/07/03 18:14:02 pedro Exp $	*/
d2281 1
d2286 2
a2287 1
	if ((fp->f_flag & FWRITE) == 0) {
d2298 1
a2298 1
		vattr.va_size = SCARG(uap, length);
@


1.113
log
@if vinvalbuf() fails, unlock the vnode and release it. ok marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.112 2004/06/21 23:50:36 tholo Exp $	*/
d891 1
a891 1
		syscallarg(int) mode;
d1252 1
a1252 1
		syscallarg(int) mode;
d1333 1
a1333 1
		syscallarg(int) mode;
d1893 1
a1893 1
		syscallarg(int) mode;
d1932 1
a1932 1
		syscallarg(int) mode;
d1978 1
a1978 1
	u_short mode;
d2030 1
a2030 1
	u_short mode;
d2082 1
a2082 1
	u_short mode;
d2443 1
a2443 1
		syscallarg(int) mode;
d2615 1
a2615 1
		syscallarg(int) newmask;
@


1.112
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.111 2004/05/14 04:00:33 tedu Exp $	*/
d200 2
a201 1
	if ((error = vinvalbuf(vp, V_SAVE, p->p_ucred, p, 0, 0)) != 0)
d203 1
@


1.111
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.110 2004/05/10 22:36:21 pedro Exp $	*/
a109 1
	struct timeval tv;
d281 1
a281 2
		microtime(&tv);
		mp->mnt_stat.f_ctime = tv.tv_sec;
@


1.110
log
@when doing user mounts, inherit the MNT_NOEXEC flag from the covered
vnode's mount point. this makes it impossible for a user to bypass the
noexec protection of a mount point by null-mounting it on top of itself.

ok tedu@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.109 2004/04/13 00:15:28 tedu Exp $	*/
d52 1
d1428 1
a1428 1
	MALLOC(path, char *, MAXPATHLEN, M_NAMEI, M_WAITOK);
d1450 1
a1450 1
	FREE(path, M_NAMEI);
d2421 1
a2421 1
	FREE(tond.ni_cnd.cn_pnbuf, M_NAMEI);
d2425 1
a2425 1
	FREE(fromnd.ni_cnd.cn_pnbuf, M_NAMEI);
@


1.109
log
@useless caddr_t cast removal.  same md5s.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.108 2004/01/06 04:18:18 tedu Exp $	*/
d157 2
a158 1
		 * enforce MNT_NOSUID and MNT_NODEV for non-root users.
d166 2
d188 2
a189 1
	 * enforce MNT_NOSUID and MNT_NODEV for non-root users.
d197 2
@


1.108
log
@lock filedesc before manipulating.  avoids some rare races.
testing for quite some time by brad + otto
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.107 2003/09/01 18:06:03 henning Exp $	*/
d322 1
a322 1
		free((caddr_t)mp, M_MOUNT);
d490 1
a490 1
	free((caddr_t)mp, M_MOUNT);
d604 1
a604 1
		bcopy((caddr_t)sp, (caddr_t)&sb, sizeof(sb));
d608 1
a608 1
	return (copyout((caddr_t)sp, (caddr_t)SCARG(uap, buf), sizeof(*sp)));
d650 1
a650 1
		bcopy((caddr_t)sp, (caddr_t)&sb, sizeof(sb));
d654 1
a654 1
	return (copyout((caddr_t)sp, (caddr_t)SCARG(uap, buf), sizeof(*sp)));
d674 1
a674 1
	caddr_t sfsp;
d679 1
a679 1
	sfsp = (caddr_t)SCARG(uap, buf);
d709 1
a709 1
				bcopy((caddr_t)sp, (caddr_t)&sb, sizeof(sb));
d713 1
a713 1
			error = copyout((caddr_t)sp, sfsp, sizeof(*sp));
d718 1
a718 1
			sfsp += sizeof(*sp);
d928 1
a928 1
	fp->f_data = (caddr_t)vp;
d1010 1
a1010 1
	bzero((caddr_t)&fh, sizeof(fh));
d1016 1
a1016 1
	error = copyout((caddr_t)&fh, (caddr_t)SCARG(uap, fhp), sizeof (fh));
d1116 1
a1116 1
	fp->f_data = (caddr_t)vp;
d1671 1
a1671 1
	error = copyout((caddr_t)&sb, (caddr_t)SCARG(uap, ub), sizeof (sb));
d1704 1
a1704 1
	error = copyout((caddr_t)&sb, (caddr_t)SCARG(uap, ub), sizeof (sb));
d2133 2
a2134 2
		error = copyin((caddr_t)SCARG(uap, tptr), (caddr_t)tv,
		    sizeof (tv));
d2189 2
a2190 2
		error = copyin((caddr_t)SCARG(uap, tptr), (caddr_t)tv,
		    sizeof (tv));
d2585 1
a2585 1
		fp->f_data = (caddr_t) vp;
d2590 1
a2590 1
	error = copyout((caddr_t)&loff, (caddr_t)SCARG(uap, basep),
@


1.107
log
@match syscallargs comments with reality
from Patrick Latifi <patrick.l@@hermes.usherb.ca>
ok jason@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.106 2003/08/15 20:32:18 tedu Exp $	*/
d895 2
d898 1
a898 1
		return (error);
d915 1
a915 1
			return (0);
d921 1
a921 1
		return (error);
d946 1
a946 1
			return (error);
d969 1
a969 1
			return (error);
d975 3
a977 1
	return (0);
d1059 5
a1063 2
	if ((error = falloc(p, &fp, &indx)) != 0)
		return (error);
d1142 2
d1147 7
a1153 4
	fdremove(fdp, indx);
	closef(fp, p);
	if (vp != NULL)
		vput(vp);
@


1.106
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.105 2003/07/18 16:43:32 tedu Exp $	*/
d93 2
a94 2
		syscallarg(char *) type;
		syscallarg(char *) path;
d380 1
a380 1
		syscallarg(char *) path;
d551 1
a551 1
		syscallarg(char *) path;
d554 1
a554 1
		syscallarg(caddr_t) arg;
d580 1
a580 1
		syscallarg(char *) path;
d794 1
a794 1
		syscallarg(char *) path;
d820 1
a820 1
		syscallarg(char *) path;
d882 1
a882 1
		syscallarg(char *) path;
d986 1
a986 1
		syscallarg(char *) fname;
d1232 1
a1232 1
		syscallarg(char *) path;
d1313 1
a1313 1
		syscallarg(char *) path;
d1351 2
a1352 2
		syscallarg(char *) path;
		syscallarg(char *) link;
d1401 2
a1402 2
		syscallarg(char *) path;
		syscallarg(char *) link;
d1446 1
a1446 1
		syscallarg(char *) path;
d1486 1
a1486 1
		syscallarg(char *) path;
d1591 1
a1591 1
		syscallarg(char *) path;
d1641 1
a1641 1
		syscallarg(char *) path;
d1674 1
a1674 1
		syscallarg(char *) path;
d1707 1
a1707 1
		syscallarg(char *) path;
d1733 1
a1733 1
		syscallarg(char *) path;
d1778 2
a1779 2
		syscallarg(char *) path;
		syscallarg(unsigned int) flags;
d1826 1
a1826 1
		syscallarg(unsigned int) flags;
d1873 1
a1873 1
		syscallarg(char *) path;
d1951 3
a1953 3
		syscallarg(char *) path;
		syscallarg(int) uid;
		syscallarg(int) gid;
d2003 3
a2005 3
		syscallarg(char *) path;
		syscallarg(int) uid;
		syscallarg(int) gid;
d2056 2
a2057 2
		syscallarg(int) uid;
		syscallarg(int) gid;
d2106 2
a2107 2
		syscallarg(char *) path;
		syscallarg(struct timeval *) tptr;
d2163 1
a2163 1
		syscallarg(struct timeval *) tptr;
d2217 1
a2217 1
		syscallarg(char *) path;
d2330 2
a2331 2
		syscallarg(char *) from;
		syscallarg(char *) to;
d2423 1
a2423 1
		syscallarg(char *) path;
d2466 1
a2466 1
		syscallarg(char *) path;
d2618 1
a2618 1
		syscallarg(char *) path;
d2998 2
a2999 2
		syscallarg(struct iovec *) iovp;
		syscallarg(int) iovcnt;
d3176 1
a3176 1
		syscallarg(int) fd;
@


1.105
log
@check v_mount for NULL before using. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.104 2003/06/02 23:28:07 millert Exp $	*/
d111 1
a111 1
	if (usermount == 0 && (error = suser(p->p_ucred, &p->p_acflag)))
d151 1
a151 1
		    (error = suser(p->p_ucred, &p->p_acflag))) {
d179 1
a179 1
	    (error = suser(p->p_ucred, &p->p_acflag)))) {
d400 1
a400 1
	    (error = suser(p->p_ucred, &p->p_acflag))) {
d603 1
a603 1
	if (suser(p->p_ucred, &p->p_acflag)) {
d649 1
a649 1
	if (suser(p->p_ucred, &p->p_acflag)) {
d708 1
a708 1
			if (suser(p->p_ucred, &p->p_acflag)) {
d826 1
a826 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d997 1
a997 1
	error = suser(p->p_ucred, &p->p_acflag);
d1046 1
a1046 1
	if ((error = suser(p->p_ucred, &p->p_acflag)))
d1165 1
a1165 1
	if ((error = suser(p->p_ucred, &p->p_acflag)))
d1203 1
a1203 1
	if ((error = suser(p->p_ucred, &p->p_acflag)))
d1242 1
a1242 1
	if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d1657 1
a1657 1
	if (suser(p->p_ucred, &p->p_acflag))
d1690 1
a1690 1
	if (suser(p->p_ucred, &p->p_acflag))
d1797 1
a1797 1
		if (suser(p->p_ucred, &p->p_acflag)) {
d1843 1
a1843 1
		if (suser(p->p_ucred, &p->p_acflag)) {
d1971 1
a1971 1
		    (suser(p->p_ucred, &p->p_acflag) || suid_clear)) {
d2023 1
a2023 1
		    (suser(p->p_ucred, &p->p_acflag) || suid_clear)) {
d2074 1
a2074 1
		    (suser(p->p_ucred, &p->p_acflag) || suid_clear)) {
d2632 1
a2632 1
	    (error = suser(p->p_ucred, &p->p_acflag)))
@


1.104
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.103 2003/05/06 20:52:14 tedu Exp $	*/
d634 4
d1838 1
a1838 1
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
d1928 1
a1928 1
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
d2192 1
a2192 1
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
@


1.103
log
@attempt to put a process's cwd back in place after a forced umount.
won't always work, but it's the best we can do for now.  this covers
at least some of the failure cases the previous commit to vfs_lookup.c
checks for.
ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.102 2003/05/05 00:21:52 tedu Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.102
log
@fix test for restoring mnt_syncer in dounmount.
ok and input csapuntz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.101 2003/05/01 21:13:05 tedu Exp $	*/
d429 1
a429 1
	return (dounmount(mp, SCARG(uap, flags), p));
d436 1
a436 1
dounmount(struct mount *mp, int flags, struct proc *p)
d439 1
d464 24
a487 1
		coveredvp->v_mountedhere = (struct mount *)0;
@


1.101
log
@several related changes:
vfs_subr.c:
	add a missing simple_lock_init for vnode interlock
	try to avoid reclaiming locked or layered vnodes
	initialize vnlock pointer to NULL
	remove old code to free vnlock, never used
	lockinit the new vnode lock
vfs_syscalls.c:
	support for VLAYER flag
vnode_if.sh:
	support for splitting VDESC flags
vnode_if.src:
	split VDESC flags
	WILLPUT is the combination of WILLRELE and WILLUNLOCK
	most uses for WILLRELE become WILLPUT
vnode.h:
	add v_lock to struct vnode
	add VLAYER flag
	update for new VDESC flags
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.100 2003/04/11 01:48:41 tedu Exp $	*/
d440 1
d444 2
a445 1
 	if (mp->mnt_syncer != NULL)
d447 2
d455 1
a455 1
 		if ((mp->mnt_flag & MNT_RDONLY) == 0 && mp->mnt_syncer == NULL)
@


1.100
log
@zombies can't live allproc list.  art fixed the real problem a while ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.99 2003/04/10 02:06:00 tedu Exp $	*/
d2606 1
a2606 1
	if (vp->v_usecount > 1 || (vp->v_flag & VALIASED))
@


1.99
log
@don't try to update directories on zombies.  pr2030.  ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.98 2002/10/02 21:56:30 nordin Exp $	*/
a349 2
		if (P_ZOMBIE(p))
			continue;
@


1.98
log
@Check for negative values. Inspiration from tedu <grendel@@zeitbombe.org>.
ok deraadt@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.97 2002/08/23 15:39:31 art Exp $	*/
d350 2
a351 4
		/*
		 * XXX - we have a race with fork here. We should probably
		 *       check if the process is SIDL before we fiddle with it.
		 */
@


1.97
log
@Cleanup change. Since almost all callers (except one) of getvnode did a FREF
on the returned file, do the FREF inside getvnode so that people can't
get away with avoiding FREF and FRELE.

Eyeballed by various people.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.96 2002/07/12 14:02:22 art Exp $	*/
d2497 1
a2497 1
		syscallarg(u_int) count;
d2507 2
@


1.96
log
@Change the locking on the mountpoint slightly. Instead of using mnt_lock
to get shared locks for lookup and get the exclusive lock only with
LK_DRAIN on unmount and do the real exclusive locking with flags in
mnt_flags, we now use shared locks for lookup and an exclusive lock for
unmount.

This is accomplished by slightly changing the semantics of vfs_busy.
Old vfs_busy behavior:
 - with LK_NOWAIT set in flags, a shared lock was obtained if the
   mountpoint wasn't being unmounted, otherwise we just returned an error.
 - with no flags, a shared lock was obtained if the mountpoint was being
   unmounted, otherwise we slept until the unmount was done and returned
   an error.
LK_NOWAIT was used for sync(2) and some statistics code where it isn't really
critical that we get the correct results.
0 was used in fchdir and lookup where it's critical that we get the right
directory vnode for the filesystem root.

After this change vfs_busy keeps the same behavior for no flags and LK_NOWAIT.
But if some other flags are passed into it, they are passed directly
into lockmgr (actually LK_SLEEPFAIL is always added to those flags because
if we sleep for the lock, that means someone was holding the exclusive lock
and the exclusive lock is only held when the filesystem is being unmounted.

More changes:
 dounmount must now be called with the exclusive lock held. (before this
 the caller was supposed to hold the vfs_busy lock, but that wasn't always
 true).
 Zap some (now) unused mount flags.
And the highlight of this change:
 Add some vfs_busy calls to match some vfs_unbusy calls, especially in
 sys_mount. (lockmgr doesn't detect the case where we release a lock noone
 holds (it will do that soon)).

If you've seen hangs on reboot with mfs this should solve it (I repeat this
for the fourth time now, but this time I spent two months fixing and
redesigning this and reading the code so this time I must have gotten
this right).
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.95 2002/03/14 01:27:06 millert Exp $	*/
a614 1
	FREF(fp);
a729 1
	/* No need to FREF/FRELE since we VREF the vnode here. */
d732 1
a1810 1
	FREF(fp);
a1900 1
	FREF(fp);
a2042 1
	FREF(fp);
a2164 1
	FREF(fp);
d2242 4
a2245 3
	if ((fp->f_flag & FWRITE) == 0)
		return (EINVAL);
	FREF(fp);
d2257 1
a2280 1
	FREF(fp);
d2509 4
a2512 3
	if ((fp->f_flag & FREAD) == 0)
		return (EBADF);
	FREF(fp);
d2617 2
d2632 1
d2634 1
a2986 1
	FREF(fp);
a3108 1
	FREF(fp);
a3196 1
	FREF(fp);
@


1.95
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.94 2002/02/22 20:37:45 drahn Exp $	*/
d170 4
d251 3
a253 1
	vfs_busy(mp, LK_NOWAIT, 0, p);
d430 1
a430 1
	if (vfs_busy(mp, 0, NULL, p))
d440 1
a440 4
dounmount(mp, flags, p)
	register struct mount *mp;
	int flags;
	struct proc *p;
a444 4
	simple_lock(&mountlist_slock);
	mp->mnt_flag |= MNT_UNMOUNT;
	vfs_unbusy(mp, p);
	lockmgr(&mp->mnt_lock, LK_DRAIN | LK_INTERLOCK, &mountlist_slock, p);
d457 1
a457 2
		mp->mnt_flag &= ~MNT_UNMOUNT;
		lockmgr(&mp->mnt_lock, LK_RELEASE | LK_INTERLOCK | LK_REENABLE,
a458 3
		if (mp->mnt_flag & MNT_MWAIT)
			wakeup((caddr_t)mp);
		mp->mnt_flag &= ~MNT_MWAIT;
a469 2
	if (mp->mnt_flag & MNT_MWAIT)
		wakeup((caddr_t)mp);
@


1.95.2.1
log
@MFC (nordin):
Check for negative values. Inspiration from tedu <grendel@@zeitbombe.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.95 2002/03/14 01:27:06 millert Exp $	*/
d2508 1
a2508 1
		syscallarg(int) count;
a2517 2
	if (SCARG(uap, count) < 0)
		return EINVAL;
@


1.94
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.93 2002/02/12 18:41:21 art Exp $	*/
d67 1
a67 1
static int change_dir __P((struct nameidata *, struct proc *));
d69 1
a69 1
void checkdirs __P((struct vnode *));
d79 2
a80 2
int (*union_check_p) __P((struct proc *, struct vnode **,
    struct file *, struct uio, int *)) = NULL;
@


1.93
log
@More FREF/FRELE protection. This time all users of getvnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.92 2002/02/08 19:58:03 art Exp $	*/
d57 1
d2808 405
@


1.92
log
@Require a FREFd file in dofilewrite{,v}.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.91 2002/02/08 19:47:50 art Exp $	*/
d607 1
a607 1
	register struct sys_fstatfs_args /* {
d613 1
a613 1
	register struct statfs *sp;
d621 4
a624 1
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
d729 1
a729 1
	register struct filedesc *fdp = p->p_fd;
d737 1
d1807 1
a1807 1
	register struct sys_fchflags_args /* {
d1818 1
d1842 1
d1895 1
a1895 1
	register struct sys_fchmod_args /* {
d1909 1
d1921 1
d2039 1
a2039 1
	register struct sys_fchown_args /* {
d2044 1
a2044 1
	register struct vnode *vp;
d2052 1
d2077 1
d2151 1
a2151 1
	register struct vnode *vp;
d2175 1
d2189 1
d2241 1
a2241 1
	register struct sys_ftruncate_args /* {
d2255 1
d2267 1
d2284 1
a2284 1
	register struct vnode *vp;
d2290 1
d2300 1
d2504 1
a2504 1
	register struct sys_getdirentries_args /* {
d2521 1
d2524 4
a2527 2
	if (vp->v_type != VDIR)
		return (EINVAL);
d2542 1
a2542 1
		return (error);
d2548 1
a2548 1
		return (error);
d2564 2
@


1.91
log
@require a FREFd fp in dofilereadv. Fix some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.90 2002/02/08 18:58:51 art Exp $	*/
d2724 1
a2724 1
	int error, fd = SCARG(uap, fd);
d2733 1
a2733 2
		error = ESPIPE;
		goto out;
d2736 2
d2740 1
a2740 1
	/* dofilewrite() will unuse the descriptor for us */
a2742 3

 out:
	return (error);
d2766 1
a2766 1
	int error, fd = SCARG(uap, fd);
d2775 1
a2775 2
		error = ESPIPE;
		goto out;
d2778 2
d2782 1
a2782 1
	/* dofilewritev() will unuse the descriptor for us */
a2784 3

 out:
	return (error);
@


1.90
log
@simplify sys_pread a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.89 2002/02/08 13:53:28 art Exp $	*/
d2658 1
a2658 1
	/* dofileread() will unuse the descriptor for us */
d2683 1
a2683 1
	int error, fd = SCARG(uap, fd);
d2692 1
a2692 2
		error = ESPIPE;
		goto out;
d2695 2
d2699 1
a2699 1
	/* dofilereadv() will unuse the descriptor for us */
a2701 3

 out:
	return (error);
@


1.89
log
@- Rename FILE_{,UN}USE to FREF and FRELE. USE is a bad verb and we don't have
  the same semantics as NetBSD anyway, so it's good to avoid name collissions.
- Always fdremove before freeing the file, not the other way around.
- falloc FREFs the file.
- have FILE_SET_MATURE FRELE the file (It feels like a good ortogonality to
  falloc FREFing the file).
- Use closef as much as possible instead of ffree in error paths of
  falloc:ing functions. closef is much more careful with the fd and can
  deal with the fd being forcibly closed by dup2. Also try to avoid
  manually calling *fo_close when closef can do that for us (this makes
  some error paths mroe complicated (sys_socketpair and sys_pipe), but
  others become simpler (sys_open)).
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.88 2002/02/05 16:02:27 art Exp $	*/
a2648 2
	FREF(fp);

a2650 1
		FRELE(fp);
d2655 2
@


1.88
log
@Add counting of temporary references to a struct file (as opposed to references
from fd tables and other long-lived objects). This is to avoid races between
using a file descriptor and having another process (with shared fd table)
close it. We use a separate refence count so that error values from close(2)
will be correctly returned to the caller of close(2).

The macros for those reference counts are FILE_USE(fp) and FILE_UNUSE(fp).

Make sure that the cases where closef can be called "incorrectly" (most notably
dup2(2)) are handled.

Right now only callers of closef (and {,p}read) use FILE_{,UN}USE correctly,
more fixes incoming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.87 2002/02/04 11:43:16 art Exp $	*/
a876 2
	FILE_USE(fp);

d896 1
a897 1
		fdremove(fdp, indx);
d920 1
a920 3
			(void) vn_close(vp, fp->f_flag, fp->f_cred, p);
			FILE_UNUSE(fp);
			ffree(fp);
d922 1
d943 1
a943 3
			(void) vn_close(vp, fp->f_flag, fp->f_cred, p);
			FILE_UNUSE(fp);
			ffree(fp);
d945 1
a951 1
	FILE_UNUSE(fp);
d1103 1
a1103 2
			(void) vn_close(vp, fp->f_flag, fp->f_cred, p);
			ffree(fp);
d1105 1
a1116 1
	ffree(fp);
d1118 1
d2649 1
a2649 1
	FILE_USE(fp);
d2653 1
a2653 1
		FILE_UNUSE(fp);
a2703 3
#if notyet
	FILE_UNUSE(fp, p);
#endif
a2746 3
#if notyet
	FILE_UNUSE(fp, p);
#endif
a2790 3
#if notyet
	FILE_UNUSE(fp, p);
#endif
@


1.87
log
@Don't ffree the newly allocated file before calling dupfdopen.
In some cases that could cause dupfdopen->fd_getfile to access freed memory
setting fd_ofiles[fd] to NULL is not a solution because that would cause
a race condition.

Free the new file after dupfdopen and use closef (because it will be necessary
in the future.

XXX - consider more cleanup of the code around dupfdopen.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.86 2002/01/21 18:50:45 millert Exp $	*/
d877 2
d923 1
d947 1
d956 1
d2647 1
a2647 1
	int error, fd = SCARG(uap, fd);
d2654 2
d2658 2
a2659 2
		error = ESPIPE;
		goto out;
a2666 6

 out:
#if notyet
	FILE_UNUSE(fp, p);
#endif
	return (error);
@


1.86
log
@Mount points must fit in MNAMELEN, not MAXPATHLEN so use copyinstr()
to detect whether the path passed in from userland is too long.
Based on a patch from peterw AT ifost.org.au.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.85 2002/01/18 01:36:29 mickey Exp $	*/
a885 1
		ffree(fp);
d890 1
d896 1
@


1.85
log
@record ctime for the mountpoint, mount time or last mount update; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.84 2001/12/19 08:58:06 art Exp $	*/
d108 1
d118 7
d127 1
a127 2
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
	    SCARG(uap, path), p);
@


1.84
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.82 2001/11/06 19:53:20 miod Exp $	*/
d111 1
d264 4
@


1.83
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d496 1
a1066 7

	if (vp->v_type == VREG &&
	    uvn_attach(vp, flags & FWRITE ? VM_PROT_WRITE : 0) == NULL) {
		error = EIO;
		goto bad;
	}

d1478 2
d2341 1
@


1.83.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.86 2002/01/21 18:50:45 millert Exp $	*/
a107 1
	char fspath[MNAMELEN];
a110 1
	struct timeval tv;
a115 7
	 * Mount points must fit in MNAMELEN, not MAXPATHLEN.
	 */
	error = copyinstr(SCARG(uap, path), fspath, MNAMELEN, NULL);
	if (error)
		return(error);

	/*
d118 2
a119 1
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_SYSSPACE, fspath, p);
a262 4
	if (!error) {
		microtime(&tv);
		mp->mnt_stat.f_ctime = tv.tv_sec;
	}
@


1.83.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.83.2.1 2002/01/31 22:55:41 niklas Exp $	*/
a56 1
#include <sys/extattr.h>
d66 1
a66 1
static int change_dir(struct nameidata *, struct proc *);
d68 1
a68 1
void checkdirs(struct vnode *);
d78 2
a79 2
int (*union_check_p)(struct proc *, struct vnode **,
    struct file *, struct uio, int *) = NULL;
d606 1
a606 1
	struct sys_fstatfs_args /* {
d612 1
a612 1
	struct statfs *sp;
d620 1
a620 4
	FREF(fp);
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp);
	if (error)
d725 1
a725 1
	struct filedesc *fdp = p->p_fd;
a732 1
	/* No need to FREF/FRELE since we VREF the vnode here. */
d885 1
a889 1
			closef(fp, p);
a895 1
		closef(fp, p);
d918 2
a919 1
			/* closef will vn_close the file for us. */
a920 1
			closef(fp, p);
d941 2
a942 1
			/* closef will close the file for us. */
a943 1
			closef(fp, p);
d1108 2
a1109 1
			/* closef will vn_close the file for us. */
a1110 1
			closef(fp, p);
d1122 1
a1123 1
	closef(fp, p);
d1806 1
a1806 1
	struct sys_fchflags_args /* {
a1816 1
	FREF(fp);
a1839 1
	FRELE(fp);
d1892 1
a1892 1
	struct sys_fchmod_args /* {
a1905 1
	FREF(fp);
a1916 1
	FRELE(fp);
d2034 1
a2034 1
	struct sys_fchown_args /* {
d2039 1
a2039 1
	struct vnode *vp;
a2046 1
	FREF(fp);
a2070 1
	FRELE(fp);
d2144 1
a2144 1
	struct vnode *vp;
a2167 1
	FREF(fp);
a2180 1
	FRELE(fp);
d2232 1
a2232 1
	struct sys_ftruncate_args /* {
a2245 1
	FREF(fp);
a2256 1
	FRELE(fp);
d2273 1
a2273 1
	struct vnode *vp;
a2278 1
	FREF(fp);
a2287 1
	FRELE(fp);
d2490 1
a2490 1
	struct sys_getdirentries_args /* {
a2506 1
	FREF(fp);
d2509 2
a2510 4
	if (vp->v_type != VDIR) {
		error = EINVAL;
		goto bad;
	}
d2525 1
a2525 1
		goto bad;
d2531 1
a2531 1
		goto bad;
a2546 2
bad:
	FRELE(fp);
d2644 1
a2644 1
	int fd = SCARG(uap, fd);
d2653 2
a2654 1
		return (ESPIPE);
d2659 1
a2659 3
	FREF(fp);

	/* dofileread() will FRELE the descriptor for us */
d2662 6
d2690 1
a2690 1
	int fd = SCARG(uap, fd);
d2699 2
a2700 1
		return (ESPIPE);
a2702 2
	FREF(fp);

d2705 1
a2705 1
	/* dofilereadv() will FRELE the descriptor for us */
d2708 6
d2736 1
a2736 1
	int fd = SCARG(uap, fd);
d2745 2
a2746 1
		return (ESPIPE);
a2748 2
	FREF(fp);

d2751 1
a2751 1
	/* dofilewrite() will FRELE the descriptor for us */
d2754 6
d2783 1
a2783 1
	int fd = SCARG(uap, fd);
d2792 2
a2793 1
		return (ESPIPE);
a2795 2
	FREF(fp);

d2798 1
a2798 1
	/* dofilewritev() will FRELE the descriptor for us */
a2800 402
}

#ifdef UFS_EXTATTR
/*
 * Syscall to push extended attribute configuration information into the
 * VFS.  Accepts a path, which it converts to a mountpoint, as well as
 * a command (int cmd), and attribute name and misc data.  For now, the
 * attribute name is left in userspace for consumption by the VFS_op.
 * It will probably be changed to be copied into sysspace by the
 * syscall in the future, once issues with various consumers of the
 * attribute code have raised their hands.
 *
 * Currently this is used only by UFS Extended Attributes.
 */
int
sys_extattrctl(struct proc *p, void *v, register_t *reval)
{
	struct sys_extattrctl_args /* {
		syscallarg(const char *) path;
		syscallarg(int) cmd;
		syscallarg(const char *) filename;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
	} */ *uap = v;
	struct vnode *filename_vp;
	struct nameidata nd;
	struct mount *mp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	/*
	 * SCARG(uap, attrname) not always defined.  We check again later
	 * when we invoke the VFS call so as to pass in NULL there if needed.
	 */
	if (SCARG(uap, attrname) != NULL) {
		error = copyinstr(SCARG(uap, attrname), attrname,
		    EXTATTR_MAXNAMELEN, NULL);
		if (error)
			return (error);
	}

	/*
	 * SCARG(uap, filename) not always defined.  If it is, grab
	 * a vnode lock, which VFS_EXTATTRCTL() will later release.
	 */
	filename_vp = NULL;
	if (SCARG(uap, filename) != NULL) {
		NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
		    SCARG(uap, filename), p);
		if ((error = namei(&nd)) != 0)
			return (error);
		filename_vp = nd.ni_vp;
	}

	/* SCARG(uap, path) always defined. */
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0) {
		if (filename_vp != NULL)
			vput(filename_vp);
		return (error);
	}

	mp = nd.ni_vp->v_mount;
	if (error) {
		if (filename_vp != NULL)
			vput(filename_vp);
		return (error);
	}

	if (SCARG(uap, attrname) != NULL) {
		error = VFS_EXTATTRCTL(mp, SCARG(uap, cmd), filename_vp,
		    SCARG(uap, attrnamespace), attrname, p);
	} else {
		error = VFS_EXTATTRCTL(mp, SCARG(uap, cmd), filename_vp,
		    SCARG(uap, attrnamespace), NULL, p);
	}

	/*
	 * VFS_EXTATTRCTL will have unlocked, but not de-ref'd,
	 * filename_vp, so vrele it if it is defined.
	 */
	if (filename_vp != NULL)
		vrele(filename_vp);

	return (error);
}

/*-
 * Set a named extended attribute on a file or directory
 * 
 * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",
 *            kernelspace string pointer "attrname", userspace buffer
 *            pointer "data", buffer length "nbytes", thread "td".
 * Returns: 0 on success, an error number otherwise
 * Locks: none
 * References: vp must be a valid reference for the duration of the call
 */
static int
extattr_set_vp(struct vnode *vp, int attrnamespace, const char *attrname,
    void *data, size_t nbytes, struct proc *p, register_t *retval)
{
	struct uio auio;
	struct iovec aiov;
	ssize_t cnt;
	int error;

	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	aiov.iov_base = data;
	aiov.iov_len = nbytes;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_offset = 0;
	if (nbytes > INT_MAX) {
		error = EINVAL;
		goto done;
	}
	auio.uio_resid = nbytes;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;
	cnt = nbytes;

	error = VOP_SETEXTATTR(vp, attrnamespace, attrname, &auio,
	    p->p_ucred, p);
	cnt -= auio.uio_resid;
	retval[0] = cnt;

done:
	VOP_UNLOCK(vp, 0, p);
	return (error);
}

int
sys_extattr_set_file(struct proc *p, void *v, register_t *retval)
{
	struct sys_extattr_set_file_args /* {
		syscallarg(const char *) path;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct nameidata nd;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);

	error = extattr_set_vp(nd.ni_vp, SCARG(uap, attrnamespace), attrname,
	    SCARG(uap, data), SCARG(uap, nbytes), p, retval);

	vrele(nd.ni_vp);
	return (error);
}

int
sys_extattr_set_fd(struct proc *p, void *v, register_t *retval)
{
	struct sys_extattr_set_fd_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(struct iovec *) iovp;
		syscallarg(int) iovcnt;
	} */ *uap = v;
	struct file *fp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	FREF(fp);
	error = extattr_set_vp((struct vnode *)fp->f_data,
	    SCARG(uap, attrnamespace), attrname, SCARG(uap, data),
	    SCARG(uap, nbytes), p, retval);
	FRELE(fp);

	return (error);
}

/*-
 * Get a named extended attribute on a file or directory
 * 
 * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",
 *            kernelspace string pointer "attrname", userspace buffer
 *            pointer "data", buffer length "nbytes", thread "td".
 * Returns: 0 on success, an error number otherwise
 * Locks: none
 * References: vp must be a valid reference for the duration of the call
 */
static int
extattr_get_vp(struct vnode *vp, int attrnamespace, const char *attrname,
    void *data, size_t nbytes, struct proc *p, register_t *retval)
{
	struct uio auio;
	struct iovec aiov;
	ssize_t cnt;
	size_t size;
	int error;

	VOP_LEASE(vp, p, p->p_ucred, LEASE_READ);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	/*
	 * Slightly unusual semantics: if the user provides a NULL data
	 * pointer, they don't want to receive the data, just the
	 * maximum read length.
	 */
	if (data != NULL) {
		aiov.iov_base = data;
		aiov.iov_len = nbytes;
		auio.uio_iov = &aiov;
		auio.uio_offset = 0;
		if (nbytes > INT_MAX) {
			error = EINVAL;
			goto done;
		}
		auio.uio_resid = nbytes;
		auio.uio_rw = UIO_READ;
		auio.uio_segflg = UIO_USERSPACE;
		auio.uio_procp = p;
		cnt = nbytes;
		error = VOP_GETEXTATTR(vp, attrnamespace, attrname, &auio,
		    NULL, p->p_ucred, p);
		cnt -= auio.uio_resid;
		retval[0] = cnt;
	} else {
		error = VOP_GETEXTATTR(vp, attrnamespace, attrname, NULL,
		    &size, p->p_ucred, p);
		retval[0] = size;
	}
done:
	VOP_UNLOCK(vp, 0, p);
	return (error);
}

int
sys_extattr_get_file(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_get_file_args /* {
		syscallarg(const char *) path;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct nameidata nd;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);

	error = extattr_get_vp(nd.ni_vp, SCARG(uap, attrnamespace), attrname,
	    SCARG(uap, data), SCARG(uap, nbytes), p, retval);

	vrele(nd.ni_vp);
	return (error);
}

int
sys_extattr_get_fd(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_get_fd_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct file *fp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	FREF(fp);
	error = extattr_get_vp((struct vnode *)fp->f_data,
	    SCARG(uap, attrnamespace), attrname, SCARG(uap, data),
	    SCARG(uap, nbytes), p, retval);
	FRELE(fp);

	return (error);
}

/*
 * extattr_delete_vp(): Delete a named extended attribute on a file or
 *                      directory
 * 
 * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",
 *            kernelspace string pointer "attrname", proc "p"
 * Returns: 0 on success, an error number otherwise
 * Locks: none
 * References: vp must be a valid reference for the duration of the call
 */
static int
extattr_delete_vp(struct vnode *vp, int attrnamespace, const char *attrname,
    struct proc *p)
{
	int error;

	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	error = VOP_SETEXTATTR(vp, attrnamespace, attrname, NULL,
	    p->p_ucred, p);

	VOP_UNLOCK(vp, 0, p);
	return (error);
}

int
sys_extattr_delete_file(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_delete_file_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
	} */ *uap = v;
	struct nameidata nd;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	     NULL);
	if (error)
		return(error);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return(error);

	error = extattr_delete_vp(nd.ni_vp, SCARG(uap, attrnamespace),
	    attrname, p);

	vrele(nd.ni_vp);
	return(error);
}

int
sys_extattr_delete_fd(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_delete_fd_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
	} */ *uap = v; 
	struct file *fp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	FREF(fp);
	error = extattr_delete_vp((struct vnode *)fp->f_data,
	    SCARG(uap, attrnamespace), attrname, p);
	FRELE(fp);
d2802 4
a2807 1
#endif 
@


1.83.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.83.2.2 2002/06/11 03:29:40 art Exp $	*/
a169 4
		if ((error = vfs_busy(mp, LK_NOWAIT, 0, p)) != 0) {
			vput(vp);
			return (error);
		}
d247 1
a247 3
	/* This error never happens, but it makes auditing easier */
	if ((error = vfs_busy(mp, LK_NOWAIT, 0, p)))
		return (error);
d424 1
a424 1
	if (vfs_busy(mp, LK_EXCLUSIVE, NULL, p))
d434 4
a437 1
dounmount(struct mount *mp, int flags, struct proc *p)
d442 4
d458 2
a459 1
		lockmgr(&mp->mnt_lock, LK_RELEASE | LK_INTERLOCK,
d461 3
d475 2
d621 1
d737 1
a739 1
	FRELE(fp);
d1823 1
d1914 1
d2057 1
d2180 1
d2258 3
a2260 4
	if ((fp->f_flag & FWRITE) == 0) {
		error = EINVAL;
		goto bad;
	}
a2271 1
bad:
d2295 1
d2511 1
a2511 1
		syscallarg(int) count;
a2520 2
	if (SCARG(uap, count) < 0)
		return EINVAL;
d2523 3
a2525 4
	if ((fp->f_flag & FREAD) == 0) {
		error = EBADF;
		goto bad;
	}
a2629 2
 *
 * On return *fpp is FREF:ed.
a2642 1
	FREF(fp);
a2643 1

d2996 1
d3119 1
d3208 1
@


1.83.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d350 4
d433 1
a433 1
	return (dounmount(mp, SCARG(uap, flags), p, vp));
d440 1
a440 1
dounmount(struct mount *mp, int flags, struct proc *p, struct vnode *olddp)
a442 1
	struct proc *p2;
a443 1
	int hadsyncer = 0;
d447 1
a447 2
 	if (mp->mnt_syncer != NULL) {
		hadsyncer = 1;
a448 2
		mp->mnt_syncer = NULL;
	}
d455 1
a455 1
 		if ((mp->mnt_flag & MNT_RDONLY) == 0 && hadsyncer)
d463 1
a463 24
		if (olddp) {
			/* 
			 * Try to put processes back in a real directory
			 * after a forced unmount.
			 * XXX We're not holding a ref on olddp, which may
			 * change, so compare id numbers.
			 */
			LIST_FOREACH(p2, &allproc, p_list) {
				struct filedesc *fdp = p2->p_fd;
				if (fdp->fd_cdir &&
				    fdp->fd_cdir->v_id == olddp->v_id) {
					vrele(fdp->fd_cdir);
					vref(coveredvp);
					fdp->fd_cdir = coveredvp;
				}
				if (fdp->fd_rdir &&
				    fdp->fd_rdir->v_id == olddp->v_id) {
					vrele(fdp->fd_rdir);
					vref(coveredvp);
					fdp->fd_rdir = coveredvp;
				}
			}
		}
		coveredvp->v_mountedhere = NULL;
d2613 1
a2613 1
	if (vp->v_usecount > 1 || (vp->v_flag & (VALIASED | VLAYER)))
@


1.82
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.81 2001/10/26 12:03:27 art Exp $	*/
a495 1
			uvm_vnp_sync(mp);
d1066 7
a1483 2
	(void)uvm_vnp_uncache(vp);

a2344 1
			(void)uvm_vnp_uncache(tvp);
@


1.81
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.80 2001/07/26 20:24:47 millert Exp $	*/
d60 1
a60 1
#include <vm/vm.h>
a61 2

#include <uvm/uvm_extern.h>
@


1.80
log
@Back out changes to symlink and mknod that were not well tested.
A simple mknod at causes a kernel panic (uvm_fault).
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.78 2001/06/27 04:49:48 art Exp $	*/
d940 1
d1102 1
d1511 1
a1511 2
	if ((u_int)SCARG(uap, fd) >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[SCARG(uap, fd)]) == NULL)
d2603 1
a2603 1
	if ((u_int)fd >= fdp->fd_nfiles || (fp = fdp->fd_ofiles[fd]) == NULL)
d2633 3
a2635 6
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
	    (fp->f_flag & FREAD) == 0)
a2637 4
#if notyet
	FILE_USE(fp);
#endif

d2679 3
a2681 6
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
	    (fp->f_flag & FREAD) == 0)
a2683 4
#if notyet
	FILE_USE(fp);
#endif

d2725 3
a2727 6
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
	    (fp->f_flag & FWRITE) == 0)
a2729 4
#if notyet
	FILE_USE(fp);
#endif

d2772 3
a2774 6
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
	    (fp->f_flag & FWRITE) == 0)
a2776 3
#if notyet
	FILE_USE(fp);
#endif
@


1.80.2.1
log
@MFC (nordin):
Check for negative values. Inspiration from tedu <grendel@@zeitbombe.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.80 2001/07/26 20:24:47 millert Exp $	*/
d2479 1
a2479 1
		syscallarg(int) count;
a2488 2
	if (SCARG(uap, count) < 0)
		return EINVAL;
@


1.79
log
@change vop_symlink and vop_mknod to return vpp (the created node)
refed, so that the caller can actually use it.  update callers and
file systems that implement these vnode operations

ok'd by art
@
text
@a1251 2
			if (error == 0)
				vput(nd.ni_vp);
d1302 1
a1302 4
	error = VOP_MKNOD(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &vattr);
	if (error == 0)
		vput(nd.ni_vp);
	return (error);
a1395 2
	if (error == 0)
		vput(nd.ni_vp);
@


1.78
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.77 2001/06/22 14:14:11 deraadt Exp $	*/
d1252 2
d1304 4
a1307 1
	return (VOP_MKNOD(nd.ni_dvp, &nd.ni_vp, &nd.ni_cnd, &vattr));
d1401 2
@


1.77
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.76 2001/05/23 13:15:07 art Exp $	*/
a62 1
#if defined(UVM)
a63 1
#endif
a435 3
#if !defined(UVM)
 	vnode_pager_umount(mp);	/* release cached vnodes */
#endif
a497 1
#if defined(UVM)
a498 1
#endif
a1477 1
#if defined(UVM)
a1478 3
#else
	(void)vnode_pager_uncache(vp);
#endif
a2341 1
#if defined(UVM)
a2342 3
#else
			(void)vnode_pager_uncache(tvp); /* XXX - I think we need this */
#endif
@


1.76
log
@Indentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.75 2001/05/16 17:14:36 millert Exp $	*/
d75 1
a75 1
 * Redirection info so we don't have to include the union fs routines in 
d82 2
a83 2
int (*union_check_p) __P((struct proc *, struct vnode **, 
			   struct file *, struct uio, int *)) = NULL;
d174 1
a174 1
	     (error = suser(p->p_ucred, &p->p_acflag)))) {
d203 1
a203 1
		 */     
d205 1
a205 1
		
d261 1
a261 1
	    MNT_NODEV | MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC | 
d445 1
a445 1
	     (error = VFS_SYNC(mp, MNT_WAIT, p->p_ucred, p)) == 0) ||
d495 1
a495 1
	     mp = nmp) {
d660 1
a660 1
	     mp = nmp) {
d672 1
a672 1
			     flags == 0) &&
d740 1
a740 1
		if (vfs_busy(mp, 0, 0, p)) 
d972 1
a972 1
	if(error)
d2039 1
a2039 1
        u_short mode;
d2041 4
a2044 4
        if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
                return (error);
        vp = (struct vnode *)fp->f_data;
        VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
d2046 3
a2048 3
        if (vp->v_mount->mnt_flag & MNT_RDONLY)
                error = EROFS;
        else {
d2051 14
a2064 15
                        error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
                        if (error)
                                goto out;
                        mode = vattr.va_mode & ~(VSUID | VSGID);
                        if (mode == vattr.va_mode)
                                mode = VNOVAL;
                }
                else
                        mode = VNOVAL;
                VATTR_NULL(&vattr);
                vattr.va_uid = SCARG(uap, uid);
                vattr.va_gid = SCARG(uap, gid);
                vattr.va_mode = mode;
                error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
        }
d2066 2
a2067 2
        VOP_UNLOCK(vp, 0, p);
        return (error);
d2069 1
d2076 24
a2099 24
        struct proc *p;
        void *v;
        register_t *retval;
{
        register struct sys_utimes_args /* {
                syscallarg(char *) path;
                syscallarg(struct timeval *) tptr;
        } */ *uap = v;
        register struct vnode *vp;
        struct timeval tv[2];
        struct vattr vattr;
        int error;
        struct nameidata nd;

        VATTR_NULL(&vattr);
        if (SCARG(uap, tptr) == NULL) {
                microtime(&tv[0]);
                tv[1] = tv[0];
                vattr.va_vaflags |= VA_UTIMES_NULL;
        } else {
                error = copyin((caddr_t)SCARG(uap, tptr), (caddr_t)tv,
                               sizeof (tv));
                if (error)
                        return (error);
d2105 6
a2110 6
        }
        NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
        if ((error = namei(&nd)) != 0)
                return (error);
        vp = nd.ni_vp;
        VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
d2112 9
a2120 9
        if (vp->v_mount->mnt_flag & MNT_RDONLY)
                error = EROFS;
        else {
                vattr.va_atime.tv_sec = tv[0].tv_sec;
                vattr.va_atime.tv_nsec = tv[0].tv_usec * 1000;
                vattr.va_mtime.tv_sec = tv[1].tv_sec;
                vattr.va_mtime.tv_nsec = tv[1].tv_usec * 1000;
                error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
        }
d2122 1
a2122 1
        return (error);
d2153 1
a2153 1
			       sizeof (tv));
d2314 1
a2314 1
        /*	
d2321 1
a2321 1
	       UIO_USERSPACE, SCARG(uap, to), p);
d2404 2
a2405 3

	NDINIT(&nd, CREATE, LOCKPARENT | STRIPSLASHES, 
	       UIO_USERSPACE, SCARG(uap, path), p);
d2630 16
a2645 16
        struct proc *p;
        void *v;
        register_t *retval;
{
        struct sys_pread_args /* {
                syscallarg(int) fd;
                syscallarg(void *) buf;
                syscallarg(size_t) nbyte;
                syscallarg(int) pad;
                syscallarg(off_t) offset;
        } */ *uap = v;
        struct filedesc *fdp = p->p_fd;
        struct file *fp;
        struct vnode *vp;
        off_t offset;
        int error, fd = SCARG(uap, fd);
d2647 2
a2648 2
        if ((u_int)fd >= fdp->fd_nfiles ||
            (fp = fdp->fd_ofiles[fd]) == NULL ||
d2650 1
a2650 1
            (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
d2652 2
a2653 2
            (fp->f_flag & FREAD) == 0)
                return (EBADF);
d2656 1
a2656 1
        FILE_USE(fp);
d2659 5
a2663 5
        vp = (struct vnode *)fp->f_data;
        if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
                error = ESPIPE;
                goto out;
        }
d2665 1
a2665 1
        offset = SCARG(uap, offset);
d2667 3
a2669 3
        /* dofileread() will unuse the descriptor for us */
        return (dofileread(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
            &offset, retval));
d2673 1
a2673 1
        FILE_UNUSE(fp, p);
d2675 1
a2675 1
        return (error);
d2683 16
a2698 16
        struct proc *p;
        void *v;
        register_t *retval;
{
        struct sys_preadv_args /* {
                syscallarg(int) fd;
                syscallarg(const struct iovec *) iovp;
                syscallarg(int) iovcnt;
                syscallarg(int) pad;
                syscallarg(off_t) offset;
        } */ *uap = v;
        struct filedesc *fdp = p->p_fd;
        struct file *fp;
        struct vnode *vp;
        off_t offset;
        int error, fd = SCARG(uap, fd);
d2700 2
a2701 2
        if ((u_int)fd >= fdp->fd_nfiles ||
            (fp = fdp->fd_ofiles[fd]) == NULL ||
d2703 1
a2703 1
            (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
d2705 2
a2706 2
            (fp->f_flag & FREAD) == 0)
                return (EBADF);
d2709 1
a2709 1
        FILE_USE(fp);
d2712 5
a2716 5
        vp = (struct vnode *)fp->f_data;
        if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
                error = ESPIPE;
                goto out;
        }
d2718 1
a2718 1
        offset = SCARG(uap, offset);
d2720 3
a2722 3
        /* dofilereadv() will unuse the descriptor for us */
        return (dofilereadv(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
            &offset, retval));
d2726 1
a2726 1
        FILE_UNUSE(fp, p);
d2728 1
a2728 1
        return (error);
d2736 16
a2751 16
        struct proc *p;
        void *v;
        register_t *retval;
{
        struct sys_pwrite_args /* {
                syscallarg(int) fd;
                syscallarg(const void *) buf;
                syscallarg(size_t) nbyte;
                syscallarg(int) pad;
                syscallarg(off_t) offset;
        } */ *uap = v;
        struct filedesc *fdp = p->p_fd;
        struct file *fp;
        struct vnode *vp;
        off_t offset;
        int error, fd = SCARG(uap, fd);
d2753 2
a2754 2
        if ((u_int)fd >= fdp->fd_nfiles ||
            (fp = fdp->fd_ofiles[fd]) == NULL ||
d2756 1
a2756 1
            (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
d2758 2
a2759 2
            (fp->f_flag & FWRITE) == 0)
                return (EBADF);
d2762 1
a2762 1
        FILE_USE(fp);
d2765 5
a2769 5
        vp = (struct vnode *)fp->f_data;
        if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
                error = ESPIPE;
                goto out;
        }
d2771 1
a2771 1
        offset = SCARG(uap, offset);
d2773 3
a2775 3
        /* dofilewrite() will unuse the descriptor for us */
        return (dofilewrite(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
            &offset, retval));
d2779 1
a2779 1
        FILE_UNUSE(fp, p);
d2781 1
a2781 1
        return (error);
d2790 16
a2805 16
        struct proc *p;
        void *v;
        register_t *retval;
{
        struct sys_pwritev_args /* {
                syscallarg(int) fd;
                syscallarg(const struct iovec *) iovp;
                syscallarg(int) iovcnt;
                syscallarg(int) pad;
                syscallarg(off_t) offset;
        } */ *uap = v;
        struct filedesc *fdp = p->p_fd;
        struct file *fp;
        struct vnode *vp;
        off_t offset;
        int error, fd = SCARG(uap, fd);
d2807 2
a2808 2
        if ((u_int)fd >= fdp->fd_nfiles ||
            (fp = fdp->fd_ofiles[fd]) == NULL ||
d2810 1
a2810 1
            (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
d2812 2
a2813 2
            (fp->f_flag & FWRITE) == 0)
                return (EBADF);
d2816 1
a2816 1
        FILE_USE(fp);
d2818 11
a2828 11
        vp = (struct vnode *)fp->f_data;
        if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
                error = ESPIPE;
                goto out;
        }

        offset = SCARG(uap, offset);

        /* dofilewritev() will unuse the descriptor for us */
        return (dofilewritev(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
            &offset, retval));
d2832 1
a2832 1
        FILE_UNUSE(fp, p);
d2834 1
a2834 1
        return (error);
a2835 1

@


1.75
log
@Create COMPAT_25 and move ogetfsstat, ostatfs and ostatfs into it.
Create COMPAT_23 and move __osemctl, omsgctl, oshmctl there.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.74 2001/05/16 05:07:52 millert Exp $	*/
d2618 1
a2618 2
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL)
@


1.74
log
@kill COMPAT_{09,10,11} kernel options.  We still need kern_info_09.c and kern_ipc_10.c for other compat modules.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.73 2001/05/14 15:11:15 art Exp $	*/
a72 1
void statfs_to_ostatfs __P((struct proc *, struct mount *, struct statfs *, struct ostatfs *));
a2625 173

/*
 * At some point (before 2.6 is released), these will move to
 * sys/compat/vfs_syscalls_25.c
 */

/*
 * Convert struct statfs -> struct ostatfs
 */
void
statfs_to_ostatfs(p, mp, sp, osp)
	struct proc *p;
	struct mount *mp;
	struct statfs *sp;
	struct ostatfs *osp;
{
#ifdef COMPAT_43
	osp->f_type = mp->mnt_vfc->vfc_typenum;
#else
	osp->f_type = 0;
#endif
	osp->f_flags = mp->mnt_flag & 0xffff;
	osp->f_bsize = sp->f_bsize;
	osp->f_iosize = sp->f_iosize;
	osp->f_blocks = sp->f_blocks;
	osp->f_bfree = sp->f_bfree;
	osp->f_bavail = sp->f_bavail;
	osp->f_files = sp->f_files;
	osp->f_ffree = sp->f_ffree;
	/* Don't let non-root see filesystem id (for NFS security) */
	if (suser(p->p_ucred, &p->p_acflag))
		osp->f_fsid.val[0] = osp->f_fsid.val[1] = 0;
	else
		bcopy(&sp->f_fsid, &osp->f_fsid, sizeof(osp->f_fsid));
	osp->f_owner = sp->f_owner;
	osp->f_syncwrites = sp->f_syncwrites;
	osp->f_asyncwrites = sp->f_asyncwrites;
	bcopy(sp->f_fstypename, osp->f_fstypename, MFSNAMELEN);
	bcopy(sp->f_mntonname, osp->f_mntonname, MNAMELEN);
	bcopy(sp->f_mntfromname, osp->f_mntfromname, MNAMELEN);
}

/*
 * Get filesystem statistics.
 */
/* ARGSUSED */
int
sys_ostatfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sys_ostatfs_args /* {
		syscallarg(char *) path;
		syscallarg(struct ostatfs *) buf;
	} */ *uap = v;
	register struct mount *mp;
	register struct statfs *sp;
	struct ostatfs osb;
	int error;
	struct nameidata nd;

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	mp = nd.ni_vp->v_mount;
	sp = &mp->mnt_stat;
	vrele(nd.ni_vp);
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
		return (error);

	statfs_to_ostatfs(p, mp, sp, &osb);
	return (copyout((caddr_t)&osb, (caddr_t)SCARG(uap, buf), sizeof(osb)));
}

/*
 * Get filesystem statistics.
 */
/* ARGSUSED */
int
sys_ofstatfs(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sys_ofstatfs_args /* {
		syscallarg(int) fd;
		syscallarg(struct ostatfs *) buf;
	} */ *uap = v;
	struct file *fp;
	struct mount *mp;
	register struct statfs *sp;
	struct ostatfs osb;
	int error;

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	mp = ((struct vnode *)fp->f_data)->v_mount;
	sp = &mp->mnt_stat;
	if ((error = VFS_STATFS(mp, sp, p)) != 0)
		return (error);

	statfs_to_ostatfs(p, mp, sp, &osb);
	return (copyout((caddr_t)&osb, (caddr_t)SCARG(uap, buf), sizeof(osb)));
}

/*
 * Get statistics on all filesystems.
 */
int
sys_ogetfsstat(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sys_ogetfsstat_args /* {
		syscallarg(struct ostatfs *) buf;
		syscallarg(long) bufsize;
		syscallarg(int) flags;
	} */ *uap = v;
	register struct mount *mp, *nmp;
	register struct statfs *sp;
	struct ostatfs osb;
	caddr_t sfsp;
	long count, maxcount;
	int error, flags = SCARG(uap, flags);

	maxcount = SCARG(uap, bufsize) / sizeof(struct ostatfs);
	sfsp = (caddr_t)SCARG(uap, buf);
	count = 0;
	simple_lock(&mountlist_slock);
	for (mp = CIRCLEQ_FIRST(&mountlist); mp != CIRCLEQ_END(&mountlist);
	     mp = nmp) {
		if (vfs_busy(mp, LK_NOWAIT, &mountlist_slock, p)) {
			nmp = CIRCLEQ_NEXT(mp, mnt_list);
			continue;
		}
		if (sfsp && count < maxcount) {
			sp = &mp->mnt_stat;

			/* Refresh stats unless MNT_NOWAIT is specified */
			if (flags != MNT_NOWAIT &&
			    flags != MNT_LAZY &&
			    (flags == MNT_WAIT ||
			     flags == 0) &&
			    (error = VFS_STATFS(mp, sp, p))) {
				simple_lock(&mountlist_slock);
				nmp = CIRCLEQ_NEXT(mp, mnt_list);
				vfs_unbusy(mp, p);
 				continue;
			}

			statfs_to_ostatfs(p, mp, sp, &osb);
			error = copyout((caddr_t)&osb, sfsp, sizeof(osb));
			if (error) {
				vfs_unbusy(mp, p);
				return (error);
			}
			sfsp += sizeof(osb);
		}
		count++;
		simple_lock(&mountlist_slock);
		nmp = CIRCLEQ_NEXT(mp, mnt_list);
		vfs_unbusy(mp, p);
	}
	simple_unlock(&mountlist_slock);
	if (sfsp && count > maxcount)
		*retval = maxcount;
	else
		*retval = count;
	return (0);
}

@


1.73
log
@Isn't copy 'n paste a great invention?
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.72 2001/05/14 14:55:48 art Exp $	*/
d109 1
a109 1
#if defined(COMPAT_09) || defined(COMPAT_43)
d198 1
a198 1
#if defined(COMPAT_09) || defined(COMPAT_43)
a220 6
#ifdef	COMPAT_10
	/* Accept "ufs" as an alias for "ffs" */
	if (!strncmp(fstypename, "ufs", MFSNAMELEN)) {
		strncpy( fstypename, "ffs", MFSNAMELEN);
	}
#endif
d228 1
a228 1
		return EOPNOTSUPP;
d2643 1
a2643 1
#if defined(COMPAT_09) || defined(COMPAT_43)
@


1.72
log
@Remove some unnecessary code + some random cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.71 2001/05/13 02:40:46 millert Exp $	*/
a1018 1
	struct file *nfp;
d1036 1
a1036 1
	if ((error = falloc(p, &nfp, &indx)) != 0)
d1038 1
a1038 1
	fp = nfp;
@


1.71
log
@Add pad argument for p{read,write}v? to the syscall args comment for
consistency with syscallargs.h as well as sys_lseek.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.70 2001/04/04 20:19:02 gluk Exp $	*/
d864 1
a864 1
	register struct sys_open_args /* {
d869 3
a871 3
	register struct filedesc *fdp = p->p_fd;
	register struct file *fp;
	register struct vnode *vp;
a873 1
	struct file *nfp;
d878 1
a878 1
	if ((error = falloc(p, &nfp, &indx)) != 0)
d880 1
a880 1
	fp = nfp;
@


1.70
log
@Add "softdep" option to mount. Update from rw/async to softdep
and otherwise are disabled.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.69 2001/03/16 16:24:57 art Exp $	*/
d2822 1
d2875 1
d2928 1
d2982 1
@


1.69
log
@Use CIRCLEQ macros for mountlist.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.68 2001/02/21 23:24:30 csapuntz Exp $	*/
d145 1
a145 1
		    SCARG(uap, flags) & (MNT_RELOAD | MNT_FORCE | MNT_UPDATE);
d265 2
a266 1
	    MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC | MNT_NOATIME);
d268 2
a269 1
	    MNT_NODEV | MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC | MNT_NOATIME);
@


1.68
log
@

Latest soft updates from FreeBSD/Kirk McKusick

Snapshot-related code has been commented out.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.67 2001/02/20 01:50:09 assar Exp $	*/
d499 2
a500 1
	for (mp = mountlist.cqh_last; mp != (void *)&mountlist; mp = nmp) {
d502 1
a502 1
			nmp = mp->mnt_list.cqe_prev;
d516 1
a516 1
		nmp = mp->mnt_list.cqe_prev;
d664 2
a665 1
	for (mp = mountlist.cqh_first; mp != (void *)&mountlist; mp = nmp) {
d667 1
a667 1
			nmp = mp->mnt_list.cqe_next;
d680 1
a680 1
				nmp = mp->mnt_list.cqe_next;
d704 1
a704 1
		nmp = mp->mnt_list.cqe_next;
d2764 2
a2765 1
	for (mp = mountlist.cqh_first; mp != (void *)&mountlist; mp = nmp) {
d2767 1
a2767 1
			nmp = mp->mnt_list.cqe_next;
d2780 1
a2780 1
				nmp = mp->mnt_list.cqe_next;
d2795 1
a2795 1
		nmp = mp->mnt_list.cqe_next;
@


1.67
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.66 2001/02/12 07:03:13 fgsch Exp $	*/
d2283 4
a2286 3
	if (error == 0 && bioops.io_fsync != NULL &&
	    vp->v_mount && (vp->v_mount->mnt_flag & MNT_SOFTDEP))
		error = (*bioops.io_fsync)(vp);
@


1.66
log
@Check if softdep is enabled for this fs before calling softdep's
fsync; art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.65 2000/04/20 06:32:00 deraadt Exp $	*/
d104 1
a104 1
		syscallarg(caddr_t) data;
@


1.65
log
@p{read,write}{,v} from csapuntz, partial NetBSD origin I think
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.64 2000/04/15 19:52:48 csapuntz Exp $	*/
d2282 3
a2284 2
	if ((error = VOP_FSYNC(vp, fp->f_cred, MNT_WAIT, p)) == 0 &&
	    bioops.io_fsync != NULL)
@


1.64
log
@

Fix sys_sync to actually sync all file systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.63 2000/03/03 11:31:43 art Exp $	*/
d2800 210
@


1.63
log
@Use LIST_ macros instead of internal field names to walk the allproc list.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.62 2000/02/07 04:55:19 assar Exp $	*/
d501 1
a501 1
			nmp = mp->mnt_list.cqe_next;
d515 1
a515 1
		nmp = mp->mnt_list.cqe_next;
@


1.62
log
@(sys_getfh): moved here from nfs_syscalls.c
(sys_fhopen, sys_fhstat, sys_fhstatfs): new system calls that use file
handles instead of file names.  largely based on NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.61 2000/02/01 04:03:14 assar Exp $	*/
d339 5
a343 1
	for (p = allproc.lh_first; p != 0; p = p->p_list.le_next) {
@


1.62.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d339 1
a339 5
	for (p = LIST_FIRST(&allproc); p != 0; p = LIST_NEXT(p, p_list)) {
		/*
		 * XXX - we have a race with fork here. We should probably
		 *       check if the process is SIDL before we fiddle with it.
		 */
@


1.62.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.70 2001/04/04 20:19:02 gluk Exp $	*/
d104 1
a104 1
		syscallarg(void *) data;
d145 1
a145 1
		    SCARG(uap, flags) & (MNT_RELOAD | MNT_UPDATE);
d265 1
a265 2
	    MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC | MNT_SOFTDEP |
	    MNT_NOATIME | MNT_FORCE);
d267 1
a267 2
	    MNT_NODEV | MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC | 
	    MNT_SOFTDEP | MNT_NOATIME | MNT_FORCE);
d499 1
a499 2
	for (mp = CIRCLEQ_LAST(&mountlist); mp != CIRCLEQ_END(&mountlist);
	     mp = nmp) {
d501 1
a501 1
			nmp = CIRCLEQ_PREV(mp, mnt_list);
d515 1
a515 1
		nmp = CIRCLEQ_PREV(mp, mnt_list);
d663 1
a663 2
	for (mp = CIRCLEQ_FIRST(&mountlist); mp != CIRCLEQ_END(&mountlist);
	     mp = nmp) {
d665 1
a665 1
			nmp = CIRCLEQ_NEXT(mp, mnt_list);
d678 1
a678 1
				nmp = CIRCLEQ_NEXT(mp, mnt_list);
d702 1
a702 1
		nmp = CIRCLEQ_NEXT(mp, mnt_list);
d2282 3
a2284 5
	error = VOP_FSYNC(vp, fp->f_cred, MNT_WAIT, p);
#ifdef FFS_SOFTUPDATES
	if (error == 0 && vp->v_mount && (vp->v_mount->mnt_flag & MNT_SOFTDEP))
		error = softdep_fsync(vp);
#endif
d2760 1
a2760 2
	for (mp = CIRCLEQ_FIRST(&mountlist); mp != CIRCLEQ_END(&mountlist);
	     mp = nmp) {
d2762 1
a2762 1
			nmp = CIRCLEQ_NEXT(mp, mnt_list);
d2775 1
a2775 1
				nmp = CIRCLEQ_NEXT(mp, mnt_list);
d2790 1
a2790 1
		nmp = CIRCLEQ_NEXT(mp, mnt_list);
a2799 210


/*
 * Positional read system call.
 */
int
sys_pread(p, v, retval)
        struct proc *p;
        void *v;
        register_t *retval;
{
        struct sys_pread_args /* {
                syscallarg(int) fd;
                syscallarg(void *) buf;
                syscallarg(size_t) nbyte;
                syscallarg(off_t) offset;
        } */ *uap = v;
        struct filedesc *fdp = p->p_fd;
        struct file *fp;
        struct vnode *vp;
        off_t offset;
        int error, fd = SCARG(uap, fd);

        if ((u_int)fd >= fdp->fd_nfiles ||
            (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
            (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
            (fp->f_flag & FREAD) == 0)
                return (EBADF);

#if notyet
        FILE_USE(fp);
#endif

        vp = (struct vnode *)fp->f_data;
        if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
                error = ESPIPE;
                goto out;
        }

        offset = SCARG(uap, offset);

        /* dofileread() will unuse the descriptor for us */
        return (dofileread(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
            &offset, retval));

 out:
#if notyet
        FILE_UNUSE(fp, p);
#endif
        return (error);
}

/*
 * Positional scatter read system call.
 */
int
sys_preadv(p, v, retval)
        struct proc *p;
        void *v;
        register_t *retval;
{
        struct sys_preadv_args /* {
                syscallarg(int) fd;
                syscallarg(const struct iovec *) iovp;
                syscallarg(int) iovcnt;
                syscallarg(off_t) offset;
        } */ *uap = v;
        struct filedesc *fdp = p->p_fd;
        struct file *fp;
        struct vnode *vp;
        off_t offset;
        int error, fd = SCARG(uap, fd);

        if ((u_int)fd >= fdp->fd_nfiles ||
            (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
            (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
            (fp->f_flag & FREAD) == 0)
                return (EBADF);

#if notyet
        FILE_USE(fp);
#endif

        vp = (struct vnode *)fp->f_data;
        if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
                error = ESPIPE;
                goto out;
        }

        offset = SCARG(uap, offset);

        /* dofilereadv() will unuse the descriptor for us */
        return (dofilereadv(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
            &offset, retval));

 out:
#if notyet
        FILE_UNUSE(fp, p);
#endif
        return (error);
}

/*
 * Positional write system call.
 */
int
sys_pwrite(p, v, retval)
        struct proc *p;
        void *v;
        register_t *retval;
{
        struct sys_pwrite_args /* {
                syscallarg(int) fd;
                syscallarg(const void *) buf;
                syscallarg(size_t) nbyte;
                syscallarg(off_t) offset;
        } */ *uap = v;
        struct filedesc *fdp = p->p_fd;
        struct file *fp;
        struct vnode *vp;
        off_t offset;
        int error, fd = SCARG(uap, fd);

        if ((u_int)fd >= fdp->fd_nfiles ||
            (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
            (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
            (fp->f_flag & FWRITE) == 0)
                return (EBADF);

#if notyet
        FILE_USE(fp);
#endif

        vp = (struct vnode *)fp->f_data;
        if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
                error = ESPIPE;
                goto out;
        }

        offset = SCARG(uap, offset);

        /* dofilewrite() will unuse the descriptor for us */
        return (dofilewrite(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
            &offset, retval));

 out:
#if notyet
        FILE_UNUSE(fp, p);
#endif
        return (error);
}


/*
 * Positional gather write system call.
 */
int
sys_pwritev(p, v, retval)
        struct proc *p;
        void *v;
        register_t *retval;
{
        struct sys_pwritev_args /* {
                syscallarg(int) fd;
                syscallarg(const struct iovec *) iovp;
                syscallarg(int) iovcnt;
                syscallarg(off_t) offset;
        } */ *uap = v;
        struct filedesc *fdp = p->p_fd;
        struct file *fp;
        struct vnode *vp;
        off_t offset;
        int error, fd = SCARG(uap, fd);

        if ((u_int)fd >= fdp->fd_nfiles ||
            (fp = fdp->fd_ofiles[fd]) == NULL ||
#if notyet
            (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
#endif
            (fp->f_flag & FWRITE) == 0)
                return (EBADF);

#if notyet
        FILE_USE(fp);
#endif
        vp = (struct vnode *)fp->f_data;
        if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
                error = ESPIPE;
                goto out;
        }

        offset = SCARG(uap, offset);

        /* dofilewritev() will unuse the descriptor for us */
        return (dofilewritev(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
            &offset, retval));

 out:
#if notyet
        FILE_UNUSE(fp, p);
#endif
        return (error);
}

@


1.62.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.62.2.2 2001/05/14 22:32:46 niklas Exp $	*/
d63 1
d65 1
d73 1
d76 1
a76 1
 * Redirection info so we don't have to include the union fs routines in
d83 2
a84 2
int (*union_check_p) __P((struct proc *, struct vnode **,
    struct file *, struct uio, int *)) = NULL;
d109 1
a109 1
#ifdef COMPAT_43
d175 1
a175 1
	    (error = suser(p->p_ucred, &p->p_acflag)))) {
d198 1
a198 1
#ifdef COMPAT_43
d204 1
a204 1
		 */
d206 1
a206 1

d221 6
d234 1
a234 1
		return (EOPNOTSUPP);
d268 1
a268 1
	    MNT_NODEV | MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC |
d445 3
d452 1
a452 1
	    (error = VFS_SYNC(mp, MNT_WAIT, p->p_ucred, p)) == 0) ||
d502 1
a502 1
	    mp = nmp) {
d510 1
d512 1
d667 1
a667 1
	    mp = nmp) {
d679 1
a679 1
			    flags == 0) &&
d747 1
a747 1
		if (vfs_busy(mp, 0, 0, p))
d864 1
a864 1
	struct sys_open_args /* {
d869 3
a871 3
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
d874 1
d879 1
a879 1
	if ((error = falloc(p, &fp, &indx)) != 0)
d881 1
a881 1

d980 1
a980 1
	if (error)
d1020 1
d1038 1
a1038 1
	if ((error = falloc(p, &fp, &indx)) != 0)
d1040 1
a1040 1

d1494 1
d1496 3
d2048 1
a2048 1
	u_short mode;
d2050 4
a2053 4
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = (struct vnode *)fp->f_data;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
d2055 3
a2057 3
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
d2060 15
a2074 14
			error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
			if (error)
				goto out;
			mode = vattr.va_mode & ~(VSUID | VSGID);
			if (mode == vattr.va_mode)
				mode = VNOVAL;
		} else
			mode = VNOVAL;
		VATTR_NULL(&vattr);
		vattr.va_uid = SCARG(uap, uid);
		vattr.va_gid = SCARG(uap, gid);
		vattr.va_mode = mode;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
d2076 2
a2077 2
	VOP_UNLOCK(vp, 0, p);
	return (error);
a2078 1

d2085 24
a2108 24
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sys_utimes_args /* {
		syscallarg(char *) path;
		syscallarg(struct timeval *) tptr;
	} */ *uap = v;
	register struct vnode *vp;
	struct timeval tv[2];
	struct vattr vattr;
	int error;
	struct nameidata nd;

	VATTR_NULL(&vattr);
	if (SCARG(uap, tptr) == NULL) {
		microtime(&tv[0]);
		tv[1] = tv[0];
		vattr.va_vaflags |= VA_UTIMES_NULL;
	} else {
		error = copyin((caddr_t)SCARG(uap, tptr), (caddr_t)tv,
		    sizeof (tv));
		if (error)
			return (error);
d2114 6
a2119 6
	}
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
d2121 9
a2129 9
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		vattr.va_atime.tv_sec = tv[0].tv_sec;
		vattr.va_atime.tv_nsec = tv[0].tv_usec * 1000;
		vattr.va_mtime.tv_sec = tv[1].tv_sec;
		vattr.va_mtime.tv_nsec = tv[1].tv_usec * 1000;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
d2131 1
a2131 1
	return (error);
d2162 1
a2162 1
		    sizeof (tv));
d2323 1
a2323 1
	/*
d2330 1
a2330 1
	    UIO_USERSPACE, SCARG(uap, to), p);
d2362 1
d2364 3
d2413 3
a2415 2
	NDINIT(&nd, CREATE, LOCKPARENT | STRIPSLASHES,
	    UIO_USERSPACE, SCARG(uap, path), p);
d2627 2
a2628 1
	if ((u_int)fd >= fdp->fd_nfiles || (fp = fdp->fd_ofiles[fd]) == NULL)
d2637 75
a2711 1
 * Positional read system call.
d2713 1
d2715 1
a2715 1
sys_pread(p, v, retval)
d2720 1
a2720 1
	struct sys_pread_args /* {
d2722 1
a2722 4
		syscallarg(void *) buf;
		syscallarg(size_t) nbyte;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
a2723 1
	struct filedesc *fdp = p->p_fd;
d2725 104
a2828 3
	struct vnode *vp;
	off_t offset;
	int error, fd = SCARG(uap, fd);
d2830 2
a2831 2
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
d2833 1
a2833 1
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
d2835 2
a2836 2
	    (fp->f_flag & FREAD) == 0)
		return (EBADF);
d2839 1
a2839 1
	FILE_USE(fp);
d2842 11
a2852 11
	vp = (struct vnode *)fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
		error = ESPIPE;
		goto out;
	}

	offset = SCARG(uap, offset);

	/* dofileread() will unuse the descriptor for us */
	return (dofileread(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &offset, retval));
d2856 1
a2856 1
	FILE_UNUSE(fp, p);
d2858 1
a2858 1
	return (error);
d2866 15
a2880 16
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_preadv_args /* {
		syscallarg(int) fd;
		syscallarg(const struct iovec *) iovp;
		syscallarg(int) iovcnt;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	off_t offset;
	int error, fd = SCARG(uap, fd);
d2882 2
a2883 2
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
d2885 1
a2885 1
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
d2887 2
a2888 2
	    (fp->f_flag & FREAD) == 0)
		return (EBADF);
d2891 1
a2891 1
	FILE_USE(fp);
d2894 11
a2904 11
	vp = (struct vnode *)fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
		error = ESPIPE;
		goto out;
	}

	offset = SCARG(uap, offset);

	/* dofilereadv() will unuse the descriptor for us */
	return (dofilereadv(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
	    &offset, retval));
d2908 1
a2908 1
	FILE_UNUSE(fp, p);
d2910 1
a2910 1
	return (error);
d2918 15
a2932 16
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_pwrite_args /* {
		syscallarg(int) fd;
		syscallarg(const void *) buf;
		syscallarg(size_t) nbyte;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	off_t offset;
	int error, fd = SCARG(uap, fd);
d2934 2
a2935 2
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
d2937 1
a2937 1
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
d2939 2
a2940 2
	    (fp->f_flag & FWRITE) == 0)
		return (EBADF);
d2943 1
a2943 1
	FILE_USE(fp);
d2946 11
a2956 11
	vp = (struct vnode *)fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
		error = ESPIPE;
		goto out;
	}

	offset = SCARG(uap, offset);

	/* dofilewrite() will unuse the descriptor for us */
	return (dofilewrite(p, fd, fp, SCARG(uap, buf), SCARG(uap, nbyte),
	    &offset, retval));
d2960 1
a2960 1
	FILE_UNUSE(fp, p);
d2962 1
a2962 1
	return (error);
d2971 15
a2985 16
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_pwritev_args /* {
		syscallarg(int) fd;
		syscallarg(const struct iovec *) iovp;
		syscallarg(int) iovcnt;
		syscallarg(int) pad;
		syscallarg(off_t) offset;
	} */ *uap = v;
	struct filedesc *fdp = p->p_fd;
	struct file *fp;
	struct vnode *vp;
	off_t offset;
	int error, fd = SCARG(uap, fd);
d2987 2
a2988 2
	if ((u_int)fd >= fdp->fd_nfiles ||
	    (fp = fdp->fd_ofiles[fd]) == NULL ||
d2990 1
a2990 1
	    (fp->f_iflags & FIF_WANTCLOSE) != 0 ||
d2992 2
a2993 2
	    (fp->f_flag & FWRITE) == 0)
		return (EBADF);
d2996 1
a2996 1
	FILE_USE(fp);
d2998 11
a3008 11
	vp = (struct vnode *)fp->f_data;
	if (fp->f_type != DTYPE_VNODE || vp->v_type == VFIFO) {
		error = ESPIPE;
		goto out;
	}

	offset = SCARG(uap, offset);

	/* dofilewritev() will unuse the descriptor for us */
	return (dofilewritev(p, fd, fp, SCARG(uap, iovp), SCARG(uap, iovcnt),
	    &offset, retval));
d3012 1
a3012 1
	FILE_UNUSE(fp, p);
d3014 1
a3014 1
	return (error);
d3016 1
@


1.62.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.62.2.3 2001/07/04 10:48:55 niklas Exp $	*/
a939 1
	FILE_SET_MATURE(fp);
a1100 1
	FILE_SET_MATURE(fp);
d1509 2
a1510 1
	if ((fp = fd_getfile(fdp, SCARG(uap, fd))) == NULL)
d2602 1
a2602 1
	if ((fp = fd_getfile(fdp, fd)) == NULL)
d2632 6
a2637 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FREAD) == 0)
d2639 4
d2685 6
a2690 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FREAD) == 0)
d2692 4
d2738 6
a2743 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FWRITE) == 0)
d2745 4
d2792 6
a2797 3
	if ((fp = fd_getfile(fdp, fd)) == NULL)
		return (EBADF);
	if ((fp->f_flag & FWRITE) == 0)
d2800 3
@


1.62.2.5
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 3
a63 1
#include <sys/sysctl.h>
@


1.62.2.6
log
@Merge in -current
@
text
@d496 1
a1066 7

	if (vp->v_type == VREG &&
	    uvn_attach(vp, flags & FWRITE ? VM_PROT_WRITE : 0) == NULL) {
		error = EIO;
		goto bad;
	}

d1478 2
d2341 1
@


1.62.2.7
log
@Merge in trunk
@
text
@a56 1
#include <sys/extattr.h>
a107 1
	char fspath[MNAMELEN];
a110 1
	struct timeval tv;
a115 7
	 * Mount points must fit in MNAMELEN, not MAXPATHLEN.
	 */
	error = copyinstr(SCARG(uap, path), fspath, MNAMELEN, NULL);
	if (error)
		return(error);

	/*
d118 2
a119 1
	NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_SYSSPACE, fspath, p);
a262 4
	if (!error) {
		microtime(&tv);
		mp->mnt_stat.f_ctime = tv.tv_sec;
	}
a495 1
			uvm_vnp_sync(mp);
d594 1
a594 1
	struct sys_fstatfs_args /* {
d600 1
a600 1
	struct statfs *sp;
d608 1
a608 4
	FREF(fp);
	error = VFS_STATFS(mp, sp, p);
	FRELE(fp);
	if (error)
d713 1
a713 1
	struct filedesc *fdp = p->p_fd;
a720 1
	/* No need to FREF/FRELE since we VREF the vnode here. */
d873 1
a877 1
			closef(fp, p);
a883 1
		closef(fp, p);
d906 2
a907 1
			/* closef will vn_close the file for us. */
a908 1
			closef(fp, p);
d929 2
a930 1
			/* closef will close the file for us. */
a931 1
			closef(fp, p);
d1066 7
d1096 2
a1097 1
			/* closef will vn_close the file for us. */
a1098 1
			closef(fp, p);
d1110 1
a1111 1
	closef(fp, p);
a1483 2
	(void)uvm_vnp_uncache(vp);

d1794 1
a1794 1
	struct sys_fchflags_args /* {
a1804 1
	FREF(fp);
a1827 1
	FRELE(fp);
d1880 1
a1880 1
	struct sys_fchmod_args /* {
a1893 1
	FREF(fp);
a1904 1
	FRELE(fp);
d2022 1
a2022 1
	struct sys_fchown_args /* {
d2027 1
a2027 1
	struct vnode *vp;
a2034 1
	FREF(fp);
a2058 1
	FRELE(fp);
d2132 1
a2132 1
	struct vnode *vp;
a2155 1
	FREF(fp);
a2168 1
	FRELE(fp);
d2220 1
a2220 1
	struct sys_ftruncate_args /* {
a2233 1
	FREF(fp);
a2244 1
	FRELE(fp);
d2261 1
a2261 1
	struct vnode *vp;
a2266 1
	FREF(fp);
a2275 1
	FRELE(fp);
a2344 1
			(void)uvm_vnp_uncache(tvp);
d2478 1
a2478 1
	struct sys_getdirentries_args /* {
a2494 1
	FREF(fp);
d2497 2
a2498 4
	if (vp->v_type != VDIR) {
		error = EINVAL;
		goto bad;
	}
d2513 1
a2513 1
		goto bad;
d2519 1
a2519 1
		goto bad;
a2534 2
bad:
	FRELE(fp);
d2632 1
a2632 1
	int fd = SCARG(uap, fd);
d2641 2
a2642 1
		return (ESPIPE);
d2647 1
a2647 3
	FREF(fp);

	/* dofileread() will FRELE the descriptor for us */
d2650 6
d2678 1
a2678 1
	int fd = SCARG(uap, fd);
d2687 2
a2688 1
		return (ESPIPE);
a2690 2
	FREF(fp);

d2693 1
a2693 1
	/* dofilereadv() will FRELE the descriptor for us */
d2696 6
d2724 1
a2724 1
	int fd = SCARG(uap, fd);
d2733 2
a2734 1
		return (ESPIPE);
a2736 2
	FREF(fp);

d2739 1
a2739 1
	/* dofilewrite() will FRELE the descriptor for us */
d2742 6
d2771 1
a2771 1
	int fd = SCARG(uap, fd);
d2780 2
a2781 1
		return (ESPIPE);
a2783 2
	FREF(fp);

d2786 1
a2786 1
	/* dofilewritev() will FRELE the descriptor for us */
a2788 402
}

#ifdef UFS_EXTATTR
/*
 * Syscall to push extended attribute configuration information into the
 * VFS.  Accepts a path, which it converts to a mountpoint, as well as
 * a command (int cmd), and attribute name and misc data.  For now, the
 * attribute name is left in userspace for consumption by the VFS_op.
 * It will probably be changed to be copied into sysspace by the
 * syscall in the future, once issues with various consumers of the
 * attribute code have raised their hands.
 *
 * Currently this is used only by UFS Extended Attributes.
 */
int
sys_extattrctl(struct proc *p, void *v, register_t *reval)
{
	struct sys_extattrctl_args /* {
		syscallarg(const char *) path;
		syscallarg(int) cmd;
		syscallarg(const char *) filename;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
	} */ *uap = v;
	struct vnode *filename_vp;
	struct nameidata nd;
	struct mount *mp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	/*
	 * SCARG(uap, attrname) not always defined.  We check again later
	 * when we invoke the VFS call so as to pass in NULL there if needed.
	 */
	if (SCARG(uap, attrname) != NULL) {
		error = copyinstr(SCARG(uap, attrname), attrname,
		    EXTATTR_MAXNAMELEN, NULL);
		if (error)
			return (error);
	}

	/*
	 * SCARG(uap, filename) not always defined.  If it is, grab
	 * a vnode lock, which VFS_EXTATTRCTL() will later release.
	 */
	filename_vp = NULL;
	if (SCARG(uap, filename) != NULL) {
		NDINIT(&nd, LOOKUP, FOLLOW | LOCKLEAF, UIO_USERSPACE,
		    SCARG(uap, filename), p);
		if ((error = namei(&nd)) != 0)
			return (error);
		filename_vp = nd.ni_vp;
	}

	/* SCARG(uap, path) always defined. */
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0) {
		if (filename_vp != NULL)
			vput(filename_vp);
		return (error);
	}

	mp = nd.ni_vp->v_mount;
	if (error) {
		if (filename_vp != NULL)
			vput(filename_vp);
		return (error);
	}

	if (SCARG(uap, attrname) != NULL) {
		error = VFS_EXTATTRCTL(mp, SCARG(uap, cmd), filename_vp,
		    SCARG(uap, attrnamespace), attrname, p);
	} else {
		error = VFS_EXTATTRCTL(mp, SCARG(uap, cmd), filename_vp,
		    SCARG(uap, attrnamespace), NULL, p);
	}

	/*
	 * VFS_EXTATTRCTL will have unlocked, but not de-ref'd,
	 * filename_vp, so vrele it if it is defined.
	 */
	if (filename_vp != NULL)
		vrele(filename_vp);

	return (error);
}

/*-
 * Set a named extended attribute on a file or directory
 * 
 * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",
 *            kernelspace string pointer "attrname", userspace buffer
 *            pointer "data", buffer length "nbytes", thread "td".
 * Returns: 0 on success, an error number otherwise
 * Locks: none
 * References: vp must be a valid reference for the duration of the call
 */
static int
extattr_set_vp(struct vnode *vp, int attrnamespace, const char *attrname,
    void *data, size_t nbytes, struct proc *p, register_t *retval)
{
	struct uio auio;
	struct iovec aiov;
	ssize_t cnt;
	int error;

	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	aiov.iov_base = data;
	aiov.iov_len = nbytes;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_offset = 0;
	if (nbytes > INT_MAX) {
		error = EINVAL;
		goto done;
	}
	auio.uio_resid = nbytes;
	auio.uio_rw = UIO_WRITE;
	auio.uio_segflg = UIO_USERSPACE;
	auio.uio_procp = p;
	cnt = nbytes;

	error = VOP_SETEXTATTR(vp, attrnamespace, attrname, &auio,
	    p->p_ucred, p);
	cnt -= auio.uio_resid;
	retval[0] = cnt;

done:
	VOP_UNLOCK(vp, 0, p);
	return (error);
}

int
sys_extattr_set_file(struct proc *p, void *v, register_t *retval)
{
	struct sys_extattr_set_file_args /* {
		syscallarg(const char *) path;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct nameidata nd;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);

	error = extattr_set_vp(nd.ni_vp, SCARG(uap, attrnamespace), attrname,
	    SCARG(uap, data), SCARG(uap, nbytes), p, retval);

	vrele(nd.ni_vp);
	return (error);
}

int
sys_extattr_set_fd(struct proc *p, void *v, register_t *retval)
{
	struct sys_extattr_set_fd_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(struct iovec *) iovp;
		syscallarg(int) iovcnt;
	} */ *uap = v;
	struct file *fp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	FREF(fp);
	error = extattr_set_vp((struct vnode *)fp->f_data,
	    SCARG(uap, attrnamespace), attrname, SCARG(uap, data),
	    SCARG(uap, nbytes), p, retval);
	FRELE(fp);

	return (error);
}

/*-
 * Get a named extended attribute on a file or directory
 * 
 * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",
 *            kernelspace string pointer "attrname", userspace buffer
 *            pointer "data", buffer length "nbytes", thread "td".
 * Returns: 0 on success, an error number otherwise
 * Locks: none
 * References: vp must be a valid reference for the duration of the call
 */
static int
extattr_get_vp(struct vnode *vp, int attrnamespace, const char *attrname,
    void *data, size_t nbytes, struct proc *p, register_t *retval)
{
	struct uio auio;
	struct iovec aiov;
	ssize_t cnt;
	size_t size;
	int error;

	VOP_LEASE(vp, p, p->p_ucred, LEASE_READ);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	/*
	 * Slightly unusual semantics: if the user provides a NULL data
	 * pointer, they don't want to receive the data, just the
	 * maximum read length.
	 */
	if (data != NULL) {
		aiov.iov_base = data;
		aiov.iov_len = nbytes;
		auio.uio_iov = &aiov;
		auio.uio_offset = 0;
		if (nbytes > INT_MAX) {
			error = EINVAL;
			goto done;
		}
		auio.uio_resid = nbytes;
		auio.uio_rw = UIO_READ;
		auio.uio_segflg = UIO_USERSPACE;
		auio.uio_procp = p;
		cnt = nbytes;
		error = VOP_GETEXTATTR(vp, attrnamespace, attrname, &auio,
		    NULL, p->p_ucred, p);
		cnt -= auio.uio_resid;
		retval[0] = cnt;
	} else {
		error = VOP_GETEXTATTR(vp, attrnamespace, attrname, NULL,
		    &size, p->p_ucred, p);
		retval[0] = size;
	}
done:
	VOP_UNLOCK(vp, 0, p);
	return (error);
}

int
sys_extattr_get_file(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_get_file_args /* {
		syscallarg(const char *) path;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct nameidata nd;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);

	error = extattr_get_vp(nd.ni_vp, SCARG(uap, attrnamespace), attrname,
	    SCARG(uap, data), SCARG(uap, nbytes), p, retval);

	vrele(nd.ni_vp);
	return (error);
}

int
sys_extattr_get_fd(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_get_fd_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
	} */ *uap = v;
	struct file *fp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	FREF(fp);
	error = extattr_get_vp((struct vnode *)fp->f_data,
	    SCARG(uap, attrnamespace), attrname, SCARG(uap, data),
	    SCARG(uap, nbytes), p, retval);
	FRELE(fp);

	return (error);
}

/*
 * extattr_delete_vp(): Delete a named extended attribute on a file or
 *                      directory
 * 
 * Arguments: unlocked vnode "vp", attribute namespace "attrnamespace",
 *            kernelspace string pointer "attrname", proc "p"
 * Returns: 0 on success, an error number otherwise
 * Locks: none
 * References: vp must be a valid reference for the duration of the call
 */
static int
extattr_delete_vp(struct vnode *vp, int attrnamespace, const char *attrname,
    struct proc *p)
{
	int error;

	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);

	error = VOP_SETEXTATTR(vp, attrnamespace, attrname, NULL,
	    p->p_ucred, p);

	VOP_UNLOCK(vp, 0, p);
	return (error);
}

int
sys_extattr_delete_file(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_delete_file_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
	} */ *uap = v;
	struct nameidata nd;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	     NULL);
	if (error)
		return(error);

	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return(error);

	error = extattr_delete_vp(nd.ni_vp, SCARG(uap, attrnamespace),
	    attrname, p);

	vrele(nd.ni_vp);
	return(error);
}

int
sys_extattr_delete_fd(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	struct sys_extattr_delete_fd_args /* {
		syscallarg(int) fd;
		syscallarg(int) attrnamespace;
		syscallarg(const char *) attrname;
	} */ *uap = v; 
	struct file *fp;
	char attrname[EXTATTR_MAXNAMELEN];
	int error;

	error = copyinstr(SCARG(uap, attrname), attrname, EXTATTR_MAXNAMELEN,
	    NULL);
	if (error)
		return (error);

	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);

	FREF(fp);
	error = extattr_delete_vp((struct vnode *)fp->f_data,
	    SCARG(uap, attrnamespace), attrname, p);
	FRELE(fp);
d2790 4
a2795 1
#endif 
@


1.62.2.8
log
@Merge in -current from about a week ago
@
text
@d67 1
a67 1
static int change_dir(struct nameidata *, struct proc *);
d69 1
a69 1
void checkdirs(struct vnode *);
d79 2
a80 2
int (*union_check_p)(struct proc *, struct vnode **,
    struct file *, struct uio, int *) = NULL;
@


1.62.2.9
log
@Sync the SMP branch with 3.3
@
text
@a169 4
		if ((error = vfs_busy(mp, LK_NOWAIT, 0, p)) != 0) {
			vput(vp);
			return (error);
		}
d247 1
a247 3
	/* This error never happens, but it makes auditing easier */
	if ((error = vfs_busy(mp, LK_NOWAIT, 0, p)))
		return (error);
d424 1
a424 1
	if (vfs_busy(mp, LK_EXCLUSIVE, NULL, p))
d434 4
a437 1
dounmount(struct mount *mp, int flags, struct proc *p)
d442 4
d458 2
a459 1
		lockmgr(&mp->mnt_lock, LK_RELEASE | LK_INTERLOCK,
d461 3
d475 2
d622 1
d738 1
a740 1
	FRELE(fp);
d1819 1
d1910 1
d2053 1
d2176 1
d2254 3
a2256 4
	if ((fp->f_flag & FWRITE) == 0) {
		error = EINVAL;
		goto bad;
	}
a2267 1
bad:
d2291 1
d2508 1
a2508 1
		syscallarg(int) count;
a2517 2
	if (SCARG(uap, count) < 0)
		return EINVAL;
d2520 3
a2522 4
	if ((fp->f_flag & FREAD) == 0) {
		error = EBADF;
		goto bad;
	}
a2626 2
 *
 * On return *fpp is FREF:ed.
a2639 1
	FREF(fp);
a2640 1

d2993 1
d3116 1
d3205 1
@


1.62.2.10
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.62.2.9 2003/03/28 00:41:27 niklas Exp $	*/
d350 4
d433 1
a433 1
	return (dounmount(mp, SCARG(uap, flags), p, vp));
d440 1
a440 1
dounmount(struct mount *mp, int flags, struct proc *p, struct vnode *olddp)
a442 1
	struct proc *p2;
a443 1
	int hadsyncer = 0;
d447 1
a447 2
 	if (mp->mnt_syncer != NULL) {
		hadsyncer = 1;
a448 2
		mp->mnt_syncer = NULL;
	}
d455 1
a455 1
 		if ((mp->mnt_flag & MNT_RDONLY) == 0 && hadsyncer)
d463 1
a463 24
		if (olddp) {
			/* 
			 * Try to put processes back in a real directory
			 * after a forced unmount.
			 * XXX We're not holding a ref on olddp, which may
			 * change, so compare id numbers.
			 */
			LIST_FOREACH(p2, &allproc, p_list) {
				struct filedesc *fdp = p2->p_fd;
				if (fdp->fd_cdir &&
				    fdp->fd_cdir->v_id == olddp->v_id) {
					vrele(fdp->fd_cdir);
					vref(coveredvp);
					fdp->fd_cdir = coveredvp;
				}
				if (fdp->fd_rdir &&
				    fdp->fd_rdir->v_id == olddp->v_id) {
					vrele(fdp->fd_rdir);
					vref(coveredvp);
					fdp->fd_rdir = coveredvp;
				}
			}
		}
		coveredvp->v_mountedhere = NULL;
d2610 1
a2610 1
	if (vp->v_usecount > 1 || (vp->v_flag & (VALIASED | VLAYER)))
@


1.62.2.11
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.62.2.10 2003/05/13 19:21:29 ho Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.62.2.12
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 2
a94 2
		syscallarg(const char *) type;
		syscallarg(const char *) path;
d111 1
a111 1
	if (usermount == 0 && (error = suser(p, 0)))
d151 1
a151 1
		    (error = suser(p, 0))) {
d179 1
a179 1
	    (error = suser(p, 0)))) {
d380 1
a380 1
		syscallarg(const char *) path;
d400 1
a400 1
	    (error = suser(p, 0))) {
d551 1
a551 1
		syscallarg(const char *) path;
d554 1
a554 1
		syscallarg(char *) arg;
d580 1
a580 1
		syscallarg(const char *) path;
d603 1
a603 1
	if (suser(p, 0)) {
a633 4
	if (!mp) {
		FRELE(fp);
		return (ENOENT);
	}
d645 1
a645 1
	if (suser(p, 0)) {
d704 1
a704 1
			if (suser(p, 0)) {
d790 1
a790 1
		syscallarg(const char *) path;
d816 1
a816 1
		syscallarg(const char *) path;
d822 1
a822 1
	if ((error = suser(p, 0)) != 0)
d878 1
a878 1
		syscallarg(const char *) path;
a890 2
	fdplock(fdp, p);

d892 1
a892 1
		goto out;
d909 1
a909 1
			goto out;
d915 1
a915 1
		goto out;
d940 1
a940 1
			goto out;
d963 1
a963 1
			goto out;
d969 1
a969 3
out:
	fdpunlock(fdp);
	return (error);
d982 1
a982 1
		syscallarg(const char *) fname;
d993 1
a993 1
	error = suser(p, 0);
d1042 1
a1042 1
	if ((error = suser(p, 0)))
d1051 2
a1052 5
	fdplock(fdp, p);
	if ((error = falloc(p, &fp, &indx)) != 0) {
		fp = NULL;
		goto bad;
	}
a1130 2

	fdpunlock(fdp);
d1134 4
a1137 7
	if (fp) {
		fdremove(fdp, indx);
		closef(fp, p);
		if (vp != NULL)
			vput(vp);
	}
	fdpunlock(fdp);
d1161 1
a1161 1
	if ((error = suser(p, 0)))
d1199 1
a1199 1
	if ((error = suser(p, 0)))
d1228 1
a1228 1
		syscallarg(const char *) path;
d1238 1
a1238 1
	if ((error = suser(p, 0)) != 0)
d1309 1
a1309 1
		syscallarg(const char *) path;
d1347 2
a1348 2
		syscallarg(const char *) path;
		syscallarg(const char *) link;
d1397 2
a1398 2
		syscallarg(const char *) path;
		syscallarg(const char *) link;
d1442 1
a1442 1
		syscallarg(const char *) path;
d1482 1
a1482 1
		syscallarg(const char *) path;
d1587 1
a1587 1
		syscallarg(const char *) path;
d1637 1
a1637 1
		syscallarg(const char *) path;
d1653 1
a1653 1
	if (suser(p, 0))
d1670 1
a1670 1
		syscallarg(const char *) path;
d1686 1
a1686 1
	if (suser(p, 0))
d1703 1
a1703 1
		syscallarg(const char *) path;
d1729 1
a1729 1
		syscallarg(const char *) path;
d1774 2
a1775 2
		syscallarg(const char *) path;
		syscallarg(u_int) flags;
d1793 1
a1793 1
		if (suser(p, 0)) {
d1822 1
a1822 1
		syscallarg(u_int) flags;
d1834 1
a1834 1
	if (vp->v_mount && vp->v_mount->mnt_flag & MNT_RDONLY)
d1839 1
a1839 1
		if (suser(p, 0)) {
d1869 1
a1869 1
		syscallarg(const char *) path;
d1924 1
a1924 1
	if (vp->v_mount && vp->v_mount->mnt_flag & MNT_RDONLY)
d1947 3
a1949 3
		syscallarg(const char *) path;
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
d1967 1
a1967 1
		    (suser(p, 0) || suid_clear)) {
d1999 3
a2001 3
		syscallarg(const char *) path;
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
d2019 1
a2019 1
		    (suser(p, 0) || suid_clear)) {
d2052 2
a2053 2
		syscallarg(uid_t) uid;
		syscallarg(gid_t) gid;
d2070 1
a2070 1
		    (suser(p, 0) || suid_clear)) {
d2102 2
a2103 2
		syscallarg(const char *) path;
		syscallarg(const struct timeval *) tptr;
d2159 1
a2159 1
		syscallarg(const struct timeval *) tptr;
d2188 1
a2188 1
	if (vp->v_mount && vp->v_mount->mnt_flag & MNT_RDONLY)
d2213 1
a2213 1
		syscallarg(const char *) path;
d2326 2
a2327 2
		syscallarg(const char *) from;
		syscallarg(const char *) to;
d2419 1
a2419 1
		syscallarg(const char *) path;
d2462 1
a2462 1
		syscallarg(const char *) path;
d2614 1
a2614 1
		syscallarg(const char *) path;
d2628 1
a2628 1
	    (error = suser(p, 0)))
d2994 2
a2995 2
		syscallarg(void *) data;
		syscallarg(size_t) nbytes;
d3172 1
a3172 1
		syscallarg(const char *) path;
@


1.62.2.13
log
@Merge with the trunk
@
text
@a51 1
#include <sys/pool.h>
d157 1
a157 2
		 * enforce MNT_NOSUID and MNT_NODEV for non-root users, and
		 * inherit MNT_NOEXEC from the mount point.
a164 2
			if (flag & MNT_NOEXEC)
				SCARG(uap, flags) |= MNT_NOEXEC;
d185 1
a185 2
	 * enforce MNT_NOSUID and MNT_NODEV for non-root users, and inherit
	 * MNT_NOEXEC from the mount point.
a192 2
		if (vp->v_mount->mnt_flag & MNT_NOEXEC)
			SCARG(uap, flags) |= MNT_NOEXEC;
d322 1
a322 1
		free(mp, M_MOUNT);
d490 1
a490 1
	free(mp, M_MOUNT);
d604 1
a604 1
		bcopy(sp, &sb, sizeof(sb));
d608 1
a608 1
	return (copyout(sp, SCARG(uap, buf), sizeof(*sp)));
d650 1
a650 1
		bcopy(sp, &sb, sizeof(sb));
d654 1
a654 1
	return (copyout(sp, SCARG(uap, buf), sizeof(*sp)));
d674 1
a674 1
	struct statfs *sfsp;
d679 1
a679 1
	sfsp = SCARG(uap, buf);
d709 1
a709 1
				bcopy(sp, &sb, sizeof(sb));
d713 1
a713 1
			error = copyout(sp, sfsp, sizeof(*sp));
d718 1
a718 1
			sfsp++;
d928 1
a928 1
	fp->f_data = vp;
d1010 1
a1010 1
	bzero(&fh, sizeof(fh));
d1016 1
a1016 1
	error = copyout(&fh, SCARG(uap, fhp), sizeof(fh));
d1116 1
a1116 1
	fp->f_data = vp;
d1421 1
a1421 1
	path = pool_get(&namei_pool, PR_WAITOK);
d1443 1
a1443 1
	pool_put(&namei_pool, path);
d1671 1
a1671 1
	error = copyout(&sb, SCARG(uap, ub), sizeof(sb));
d1704 1
a1704 1
	error = copyout(&sb, SCARG(uap, ub), sizeof(sb));
d2133 2
a2134 2
		error = copyin(SCARG(uap, tptr), tv,
		    sizeof(tv));
d2189 2
a2190 2
		error = copyin(SCARG(uap, tptr), tv,
		    sizeof(tv));
d2414 1
a2414 1
	pool_put(&namei_pool, tond.ni_cnd.cn_pnbuf);
d2418 1
a2418 1
	pool_put(&namei_pool, fromnd.ni_cnd.cn_pnbuf);
d2585 1
a2585 1
		fp->f_data = vp;
d2590 1
a2590 1
	error = copyout(&loff, SCARG(uap, basep),
@


1.61
log
@remove superflous declaration of vnops, it's now in <sys/file.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.60 1999/12/06 07:28:06 art Exp $	*/
d948 245
@


1.60
log
@Yet another solution to the mfs unmount/kill race (not ugly this time).
Require that the mount point is vfs_busy on entry to dounmount.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.59 1999/07/30 18:27:47 deraadt Exp $	*/
a869 1
	extern struct fileops vnops;
@


1.59
log
@do not permit regular users to chflags/fchflags on chr or blk devices --
even if they happen to own them at the moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.58 1999/07/13 15:17:51 provos Exp $	*/
d415 4
a434 6
	if (mp->mnt_flag & MNT_UNMOUNT) {
		mp->mnt_flag |= MNT_MWAIT;
		simple_unlock(&mountlist_slock);
		sleep(mp, PVFS);
		return ENOENT;
	}
d436 1
@


1.58
log
@introduce fdremove() to mark a file descriptor as unused. fdremove makes
sure that the fd_freefile hints stay in sync, otherwise free file
descriptors might not be overlooked by fdalloc(); ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.57 1999/05/31 17:34:48 millert Exp $	*/
d1533 8
d1545 1
d1579 9
d1592 1
@


1.57
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.56 1999/02/26 04:51:17 art Exp $	*/
d895 1
a895 1
		fdp->fd_ofiles[indx] = NULL;
d920 1
a920 1
			fdp->fd_ofiles[indx] = NULL;
d943 1
a943 1
			fdp->fd_ofiles[indx] = NULL;
@


1.56
log
@adaptation to uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.55 1999/02/15 16:46:57 art Exp $	*/
d73 1
a251 1
	mp->mnt_stat.f_type = vfsp->vfc_typenum;
d646 1
a646 1
		syscallarg(long) bufsize;
d651 1
d653 2
a654 3
	long count, maxcount, error;
	struct statfs sb;
	int  flags = SCARG(uap, flags);
d2361 171
@


1.55
log
@reorder some flag handling in unmount for safer locking
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.54 1999/02/15 16:41:37 art Exp $	*/
d63 4
d440 1
d442 1
d504 3
d1243 3
d1247 1
d2089 6
a2094 1
		if (tvp)
d2096 1
@


1.54
log
@Fail correctly when trying to match a filesystem on the old typenum
and the typenum is out of range
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.53 1999/01/19 20:52:47 art Exp $	*/
d428 1
a429 1
		mp->mnt_flag |= MNT_MWAIT;
d448 1
a450 1
		mp->mnt_flag &= ~MNT_UNMOUNT;
@


1.53
log
@Single Unix specification 2 says that rmdir(".") should suceed or give EBUSY
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.52 1999/01/10 22:47:08 art Exp $	*/
d202 8
a209 9
		if (fstypenum < maxvfsconf) {
			for (vfsp = vfsconf; vfsp; vfsp = vfsp->vfc_next)
				if (vfsp->vfc_typenum == fstypenum)
					break;
			if (vfsp == NULL) {
				vput(vp);
				return (ENODEV);
			}
			strncpy(fstypename, vfsp->vfc_name, MFSNAMELEN);
a210 1
		}
@


1.52
log
@remove unnecessary declaration of dounmount
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.51 1998/12/28 19:56:22 art Exp $	*/
d2179 1
a2179 1
		error = EINVAL;
@


1.51
log
@remove old leftovers from lite2 upgrade
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.50 1998/12/23 10:53:06 art Exp $	*/
a68 1
int dounmount __P((struct mount *, int, struct proc *));
@


1.50
log
@Opps. the flag that says that we are sleeping is MNT_MWAIT, not MNT_WAIT
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.49 1998/12/21 13:08:49 art Exp $	*/
d732 1
a732 11
	while (!error && (mp = vp->v_mountedhere) != NULL) {
		if (mp->mnt_flag & MNT_MLOCK) {
			mp->mnt_flag |= MNT_MWAIT;
			sleep((caddr_t)mp, PVFS);
			continue;
		}
		if ((error = VFS_ROOT(mp, &tdp)) != 0)
			break;
		vput(vp);
		vp = tdp;
	}
@


1.49
log
@return EOPNOTSUPP when there is no support for this filesystem in the kernel.
This is what most mount_* expect.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.48 1998/12/10 23:48:13 art Exp $	*/
d432 1
a432 1
		mp->mnt_flag |= MNT_WAIT;
@


1.48
log
@Several fixes to dounmount.
 - Check for MNT_UNMOUNT before doing the actual unmount. It shouldn't
   matter for normal unmounts that go through sys_unmount, because they
   won't be able to do a lookup on the mountpoint when it's being unmounted,
   but mfs calls dounmount directly (and there was still a race).
 - clear the MNT_UNMOUNT flag after reenabling the lock (almost impossible
   race).
 - clear the MNT_MWAIT flag after doing a wakeup on the mountpoint.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.47 1998/11/12 04:30:01 csapuntz Exp $	*/
d232 1
a232 1
		return (ENODEV);
@


1.47
log
@

Integrate latest soft updates patches for McKusick.

Integrate cleaner ffs mount code from FreeBSD. Most notably, this mount
code prevents you from mounting an unclean file system read-write.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.46 1998/09/27 03:23:47 millert Exp $	*/
d430 6
a450 1
		mp->mnt_flag &= ~MNT_UNMOUNT;
d453 1
d456 1
@


1.46
log
@Only update vfs_refcount when the mount succeeds and MNT_UPDATE not set.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.45 1998/08/17 23:26:17 csapuntz Exp $	*/
d569 4
d609 4
d656 4
a659 1
			if ((flags != MNT_NOWAIT) &&
d668 4
d2009 4
a2012 1
	error = VOP_FSYNC(vp, fp->f_cred, MNT_WAIT, p);
@


1.45
log
@

Make sure the file system is unbusied on error.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.44 1998/08/17 22:19:06 csapuntz Exp $	*/
a249 1
	vfsp->vfc_refcount++;
d300 1
@


1.44
log
@

Fix turd left over from soft updates patch.

MNT_LAZY is not a bit flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.43 1998/07/13 05:43:10 csapuntz Exp $	*/
d663 2
a664 1
			if (error)
d666 1
@


1.43
log
@


Part 1) of a fix to the "mount /mnt /mnt" problem.

Don't mount the file system in the kernel name space before calling VFS_MOUNT.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.42 1998/07/13 02:11:30 millert Exp $	*/
d633 1
d646 3
a648 7
			/*
 			 * If MNT_NOWAIT or MNT_LAZY is specified, do not
 			 * refresh the fsstat cache. MNT_NOWAIT or MNT_LAZY
 			 * overrides MNT_WAIT.
  			 */
 			if (((SCARG(uap, flags) & (MNT_LAZY|MNT_NOWAIT)) == 0 ||
			    (SCARG(uap, flags) & MNT_WAIT)) &&
d655 1
@


1.42
log
@ftpd: sleep for an indeterminate amount for non-existant logins
      to simulate a crypt, like login does.
Use SEEK_* not L_* and kill some 0L's used in lseek while we're there.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.41 1998/04/25 07:14:47 deraadt Exp $	*/
a253 1
	vp->v_mountedhere = mp;
d293 3
@


1.41
log
@readlink() 3rd param is size_t; XPG
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.40 1998/04/06 09:00:58 niklas Exp $	*/
d1267 1
a1267 1
	case L_INCR:
d1272 1
a1272 1
	case L_XTND:
d1281 1
a1281 1
	case L_SET:
@


1.40
log
@Missing wakeup in unmount error case, yet another amiga release staller :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.39 1998/03/25 19:44:50 deraadt Exp $	*/
d1447 1
a1447 1
		syscallarg(int) count;
@


1.39
log
@for *utimes(), deal with tv_sec == VNOVAL; problem noted by syssgm@@dtir.qld.gov.au
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.38 1998/02/16 21:56:29 millert Exp $	*/
d446 2
@


1.38
log
@Make "flags" field in f?chflags(2) consistent--unsigned int
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.37 1998/01/09 16:21:55 csapuntz Exp $	*/
d1813 5
d1869 5
@


1.37
log
@A better fix for the mkdir ("path/") bug. This fix strips the trailing slashes
(except in the case where the path is just /////) in the following three
cases:

1) The path in mkdir
2) The destination path in rename if the source was a directory
3) The destination path in link if the source was a directory

Note #3 isn't strictly necessary since most of our file systems don't
support hard links of directories anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.36 1998/01/02 05:42:49 deraadt Exp $	*/
d1489 1
a1489 1
		syscallarg(int) flags;
d1527 1
a1527 1
		syscallarg(int) flags;
@


1.36
log
@make {f,}chflags(.., -1) return EINVAL because -1 is VNOVAL; problem noted by provos
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.35 1997/12/11 03:16:34 deraadt Exp $	*/
d1066 1
d1072 7
a1078 1
	NDINIT(&nd, CREATE, LOCKPARENT, UIO_USERSPACE, SCARG(uap, link), p);
d2003 1
d2010 10
a2019 2
	NDINIT(&tond, RENAME, LOCKPARENT | LOCKLEAF | NOCACHE | SAVESTART,
	    UIO_USERSPACE, SCARG(uap, to), p);
d2096 3
a2098 1
	NDINIT(&nd, CREATE, LOCKPARENT, UIO_USERSPACE, SCARG(uap, path), p);
@


1.35
log
@do not clear setuid/setgid for *chmod(-1,-1); pointed out by provos
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.34 1997/12/09 09:34:36 deraadt Exp $	*/
d1497 2
d1534 2
@


1.34
log
@fix O_TRUNC and O_{SH,EX}LOCK properly; problem found by provos
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.33 1997/11/24 22:42:38 niklas Exp $	*/
d1648 2
a1649 2
		if (suser(p->p_ucred, &p->p_acflag) ||
		    suid_clear) {
d1700 2
a1701 2
		if (suser(p->p_ucred, &p->p_acflag) ||
		    suid_clear) {
d1751 2
a1752 2
                if (suser(p->p_ucred, &p->p_acflag) ||
                    suid_clear) {
@


1.33
log
@Fix non-DIAGNOSTIC (and non-COMPAT*) compilation
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.32 1997/11/20 07:15:38 millert Exp $	*/
a904 2
		VATTR_NULL(&vattr);
		vattr.va_size = 0;
d906 11
a916 1
		error = VOP_SETATTR(vp, &vattr, fp->f_cred, p);
d918 1
@


1.32
log
@Fix for open(2) when O_TRUNC and O_??LOCK are used together.  I
ran the fix by Kirk, who said it was an OK solution and pointed
out two problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.31 1997/11/18 06:59:59 millert Exp $	*/
d105 1
d107 1
@


1.31
log
@Use 0177777, not 07777 as the mask to check for EINVAL.  This allows
one to use the st_mode field in struct stat as an argument to f?chmod().
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.30 1997/11/17 07:46:24 deraadt Exp $	*/
d841 1
d844 1
a844 1
	int type, indx, error;
d856 4
d901 12
@


1.30
log
@only consider 9 bits for the umask
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.29 1997/11/17 06:00:52 deraadt Exp $	*/
d1532 1
a1532 1
	if (SCARG(uap, mode) & ~ALLPERMS)
d1571 1
a1571 1
	if (SCARG(uap, mode) & ~ALLPERMS)
@


1.29
log
@make chmod() and fchmod() return EINVAL for bad mode bits
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.28 1997/11/06 05:58:29 csapuntz Exp $	*/
d2210 1
a2210 1
	fdp->fd_cmask = SCARG(uap, newmask) & ALLPERMS;
@


1.28
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.27 1997/10/06 20:20:14 deraadt Exp $	*/
d1532 3
d1570 3
@


1.27
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.25 1997/03/02 09:38:35 millert Exp $	*/
d105 1
a105 1
	u_long fsindex = 0;
d109 1
d160 1
a160 1
		VOP_UNLOCK(vp);
d199 12
a210 4
		fsindex = (u_long)SCARG(uap, type);
		if (fsindex >= nvfssw || vfssw[fsindex] == NULL) {
			vput(vp);
			return (ENODEV);
a211 1
		strncpy(fstypename, vfssw[fsindex]->vfs_name, MFSNAMELEN);
d223 2
a224 3
	for (fsindex = 0; fsindex < nvfssw; fsindex++)
		if (vfssw[fsindex] != NULL &&
		    !strncmp(vfssw[fsindex]->vfs_name, fstypename, MFSNAMELEN))
d226 3
a228 1
	if (fsindex >= nvfssw) {
d232 1
d244 8
a251 8
	mp->mnt_op = vfssw[fsindex];
	if ((error = vfs_lock(mp)) != 0) {
		free((caddr_t)mp, M_MOUNT);
		vput(vp);
		return (error);
	}
	/* Do this early in case we block later. */
	vfssw[fsindex]->vfs_refcount++;
d279 11
d297 1
d299 1
d301 4
a304 2
		VOP_UNLOCK(vp);
		vfs_unlock(mp);
d306 2
a307 1
		error = VFS_START(mp, 0, p);
d310 1
a310 2
		vfssw[fsindex]->vfs_refcount--;
		vfs_unlock(mp);
d425 1
a425 3
	coveredvp = mp->mnt_vnodecovered;
	if (vfs_busy(mp))
		return (EBUSY);
d427 32
a458 26
	if ((error = vfs_lock(mp)) != 0)
		return (error);

	mp->mnt_flag &=~ MNT_ASYNC;
	vnode_pager_umount(mp);	/* release cached vnodes */
	cache_purgevfs(mp);	/* remove cache entries for this file sys */
	if ((error = VFS_SYNC(mp, MNT_WAIT, p->p_ucred, p)) == 0 ||
	    (flags & MNT_FORCE))
		error = VFS_UNMOUNT(mp, flags, p);
	mp->mnt_flag &= ~MNT_UNMOUNT;
	vfs_unbusy(mp);
	if (error) {
		vfs_unlock(mp);
	} else {
		CIRCLEQ_REMOVE(&mountlist, mp, mnt_list);
		if (coveredvp != NULLVP) {
			vrele(coveredvp);
			coveredvp->v_mountedhere = (struct mount *)0;
		}
		mp->mnt_op->vfs_refcount--;
		vfs_unlock(mp);
		if (mp->mnt_vnodelist.lh_first != NULL)
			panic("unmount: dangling vnode");
		free((caddr_t)mp, M_MOUNT);
	}
	return (error);
d479 1
d481 5
a485 11
		/*
		 * Get the next pointer in case we hang on vfs_busy
		 * while we are being unmounted.
		 */
		nmp = mp->mnt_list.cqe_prev;
		/*
		 * The lock check below is to avoid races with mount
		 * and unmount.
		 */
		if ((mp->mnt_flag & (MNT_MLOCK|MNT_RDONLY|MNT_MPBUSY)) == 0 &&
		    !vfs_busy(mp)) {
a490 6
			/*
			 * Get the next pointer again, as the next filesystem
			 * might have been unmounted while we were sync'ing.
			 */
			nmp = mp->mnt_list.cqe_prev;
			vfs_unbusy(mp);
d492 3
d496 2
d622 1
a622 1
	register struct mount *mp;
d630 8
a637 5
	for (count = 0, mp = mountlist.cqh_first;
	     mp != (void *)&mountlist;
	     mp = mp->mnt_list.cqe_next) {
		if (sfsp && count < maxcount &&
		    ((mp->mnt_flag & MNT_MLOCK) == 0)) {
d640 5
a644 4
			 * If MNT_NOWAIT is specified, do not refresh the
			 * fsstat cache. MNT_WAIT overrides MNT_NOWAIT.
			 */
			if (((SCARG(uap, flags) & MNT_NOWAIT) == 0 ||
d646 6
a651 2
			    (error = VFS_STATFS(mp, sp, p)))
				continue;
d664 3
d668 1
d699 1
a699 1
	VOP_LOCK(vp);
d715 10
a724 1
	VOP_UNLOCK(vp);
d726 1
a726 1
		vrele(vp);
d729 1
a815 1
	VOP_UNLOCK(vp);
d817 3
a819 1
		vrele(vp);
d886 1
a886 1
		VOP_UNLOCK(vp);
d894 1
a894 1
		VOP_LOCK(vp);
d897 1
a897 1
	VOP_UNLOCK(vp);
d1466 1
a1466 1
	VOP_LOCK(vp);
d1501 1
a1501 1
	VOP_LOCK(vp);
d1509 1
a1509 1
	VOP_UNLOCK(vp);
d1537 1
a1537 1
	VOP_LOCK(vp);
d1572 1
a1572 1
	VOP_LOCK(vp);
d1580 1
a1580 1
	VOP_UNLOCK(vp);
d1610 1
a1610 1
	VOP_LOCK(vp);
d1662 1
a1662 1
	VOP_LOCK(vp);
d1707 1
a1707 1
	u_short mode;
d1709 25
a1733 25
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = (struct vnode *)fp->f_data;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	VOP_LOCK(vp);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		if (suser(p->p_ucred, &p->p_acflag) ||
		    suid_clear) {
			error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
			if (error)
				goto out;
			mode = vattr.va_mode & ~(VSUID | VSGID);
			if (mode == vattr.va_mode)
				mode = VNOVAL;
		}
		else
			mode = VNOVAL;
		VATTR_NULL(&vattr);
		vattr.va_uid = SCARG(uap, uid);
		vattr.va_gid = SCARG(uap, gid);
		vattr.va_mode = mode;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
d1735 2
a1736 2
	VOP_UNLOCK(vp);
	return (error);
a1737 1

d1744 40
a1783 40
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sys_utimes_args /* {
		syscallarg(char *) path;
		syscallarg(struct timeval *) tptr;
	} */ *uap = v;
	register struct vnode *vp;
	struct timeval tv[2];
	struct vattr vattr;
	int error;
	struct nameidata nd;

	VATTR_NULL(&vattr);
	if (SCARG(uap, tptr) == NULL) {
		microtime(&tv[0]);
		tv[1] = tv[0];
		vattr.va_vaflags |= VA_UTIMES_NULL;
	} else {
		error = copyin((caddr_t)SCARG(uap, tptr), (caddr_t)tv,
			       sizeof (tv));
		if (error)
			return (error);
	}
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	VOP_LOCK(vp);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		vattr.va_atime.tv_sec = tv[0].tv_sec;
		vattr.va_atime.tv_nsec = tv[0].tv_usec * 1000;
		vattr.va_mtime.tv_sec = tv[1].tv_sec;
		vattr.va_mtime.tv_nsec = tv[1].tv_usec * 1000;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
d1785 1
a1785 1
	return (error);
d1788 1
d1824 1
a1824 1
	VOP_LOCK(vp);
d1834 1
a1834 1
	VOP_UNLOCK(vp);
d1863 1
a1863 1
	VOP_LOCK(vp);
d1902 1
a1902 1
	VOP_LOCK(vp);
d1910 1
a1910 1
	VOP_UNLOCK(vp);
d1934 1
a1934 1
	VOP_LOCK(vp);
d1936 1
a1936 1
	VOP_UNLOCK(vp);
d2157 1
a2157 1
	VOP_LOCK(vp);
d2159 1
a2159 1
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, (u_long *)0, 0);
d2161 1
a2161 1
	VOP_UNLOCK(vp);
a2230 4
	if (vp->v_type != VCHR && vp->v_type != VBLK) {
		error = EINVAL;
		goto out;
	}
d2237 1
a2237 1
		vgoneall(vp);
@


1.26
log
@VFS Lite2 Changes
@
text
@d105 1
a105 1
	u_long fstypenum = 0;
a108 1
	struct vfsconf *vfsp;
d159 1
a159 1
		VOP_UNLOCK(vp, 0, p);
d198 4
a201 12
		fstypenum = (u_long)SCARG(uap, type);
		
		if (fstypenum < maxvfsconf) {
			for (vfsp = vfsconf; vfsp; vfsp = vfsp->vfc_next)
				if (vfsp->vfc_typenum == fstypenum)
					break;
			if (vfsp == NULL) {
				vput(vp);
				return (ENODEV);
			}
			strncpy(fstypename, vfsp->vfc_name, MFSNAMELEN);

d203 1
d215 3
a217 2
	for (vfsp = vfsconf; vfsp; vfsp = vfsp->vfc_next) {
		if (!strcmp(vfsp->vfc_name, fstypename))
d219 1
a219 3
	}

	if (vfsp == NULL) {
a222 1

d234 8
a241 8
	lockinit(&mp->mnt_lock, PVFS, "vfslock", 0, 0);
	vfs_busy(mp, LK_NOWAIT, 0, p);
	mp->mnt_op = vfsp->vfc_vfsops;
	mp->mnt_vfc = vfsp;
	vfsp->vfc_refcount++;
	mp->mnt_stat.f_type = vfsp->vfc_typenum;
	mp->mnt_flag |= (vfsp->vfc_flags & MNT_VISFLAGMASK);
	strncpy(mp->mnt_stat.f_fstypename, vfsp->vfc_name, MFSNAMELEN);
a268 11

 		if ((mp->mnt_flag & MNT_RDONLY) == 0) {
 			if (mp->mnt_syncer == NULL)
 				error = vfs_allocate_syncvnode(mp);
 		} else {
 			if (mp->mnt_syncer != NULL)
 				vgone(mp->mnt_syncer);
 			mp->mnt_syncer = NULL;
 		}

		vfs_unbusy(mp, p);
a275 1
		simple_lock(&mountlist_slock);
a276 1
		simple_unlock(&mountlist_slock);
d278 2
a279 4
		VOP_UNLOCK(vp, 0, p);
 		if ((mp->mnt_flag & MNT_RDONLY) == 0)
 			error = vfs_allocate_syncvnode(mp);
		vfs_unbusy(mp, p);
d281 1
a281 2
		if ((error = VFS_START(mp, 0, p)) != 0)
			vrele(vp);
d284 2
a285 1
		vfs_unbusy(mp, p);
d400 3
a402 1
	simple_lock(&mountlist_slock);
d404 26
a429 32
	lockmgr(&mp->mnt_lock, LK_DRAIN | LK_INTERLOCK, &mountlist_slock, p);
 	mp->mnt_flag &=~ MNT_ASYNC;
 	vnode_pager_umount(mp);	/* release cached vnodes */
 	cache_purgevfs(mp);	/* remove cache entries for this file sys */
 	if (mp->mnt_syncer != NULL)
 		vgone(mp->mnt_syncer);
	if (((mp->mnt_flag & MNT_RDONLY) ||
	     (error = VFS_SYNC(mp, MNT_WAIT, p->p_ucred, p)) == 0) ||
 	    (flags & MNT_FORCE))
 		error = VFS_UNMOUNT(mp, flags, p);
	simple_lock(&mountlist_slock);
 	if (error) {
 		if ((mp->mnt_flag & MNT_RDONLY) == 0 && mp->mnt_syncer == NULL)
 			(void) vfs_allocate_syncvnode(mp);
		mp->mnt_flag &= ~MNT_UNMOUNT;
		lockmgr(&mp->mnt_lock, LK_RELEASE | LK_INTERLOCK | LK_REENABLE,
		    &mountlist_slock, p);
		return (error);
	}
	CIRCLEQ_REMOVE(&mountlist, mp, mnt_list);
	if ((coveredvp = mp->mnt_vnodecovered) != NULLVP) {
		coveredvp->v_mountedhere = (struct mount *)0;
 		vrele(coveredvp);
 	}
	mp->mnt_vfc->vfc_refcount--;
	if (mp->mnt_vnodelist.lh_first != NULL)
		panic("unmount: dangling vnode");
	lockmgr(&mp->mnt_lock, LK_RELEASE | LK_INTERLOCK, &mountlist_slock, p);
	if (mp->mnt_flag & MNT_MWAIT)
		wakeup((caddr_t)mp);
	free((caddr_t)mp, M_MOUNT);
	return (0);
a449 1
	simple_lock(&mountlist_slock);
d451 11
a461 5
		if (vfs_busy(mp, LK_NOWAIT, &mountlist_slock, p)) {
			nmp = mp->mnt_list.cqe_next;
			continue;
		}
		if ((mp->mnt_flag & MNT_RDONLY) == 0) {
d467 6
a473 3
		simple_lock(&mountlist_slock);
		nmp = mp->mnt_list.cqe_next;
		vfs_unbusy(mp, p);
a474 2
	simple_unlock(&mountlist_slock);

d599 1
a599 1
	register struct mount *mp, *nmp;
d607 5
a611 8
	count = 0;
	simple_lock(&mountlist_slock);
	for (mp = mountlist.cqh_first; mp != (void *)&mountlist; mp = nmp) {
		if (vfs_busy(mp, LK_NOWAIT, &mountlist_slock, p)) {
			nmp = mp->mnt_list.cqe_next;
			continue;
		}
		if (sfsp && count < maxcount) {
d614 4
a617 5
 			 * If MNT_NOWAIT or MNT_LAZY is specified, do not
 			 * refresh the fsstat cache. MNT_NOWAIT or MNT_LAZY
 			 * overrides MNT_WAIT.
  			 */
 			if (((SCARG(uap, flags) & (MNT_LAZY|MNT_NOWAIT)) == 0 ||
d619 2
a620 6
			    (error = VFS_STATFS(mp, sp, p))) {
				simple_lock(&mountlist_slock);
				nmp = mp->mnt_list.cqe_next;
				vfs_unbusy(mp, p);
 				continue;
			}
a632 3
		simple_lock(&mountlist_slock);
		nmp = mp->mnt_list.cqe_next;
		vfs_unbusy(mp, p);
a633 1
	simple_unlock(&mountlist_slock);
d664 1
a664 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d680 1
a680 10
	while (!error && (mp = vp->v_mountedhere) != NULL) {
		if (vfs_busy(mp, 0, 0, p)) 
			continue;
		error = VFS_ROOT(mp, &tdp);
		vfs_unbusy(mp, p);
		if (error)
			break;
		vput(vp);
		vp = tdp;
	}
d682 1
a682 1
		vput(vp);
a684 1
	VOP_UNLOCK(vp, 0, p);
d771 1
d773 1
a773 3
		vput(vp);
	else
		VOP_UNLOCK(vp, 0, p);
d840 1
a840 1
		VOP_UNLOCK(vp, 0, p);
d848 1
a848 1
		vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d851 1
a851 1
	VOP_UNLOCK(vp, 0, p);
d1420 1
a1420 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1455 1
a1455 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1463 1
a1463 1
	VOP_UNLOCK(vp, 0, p);
d1491 1
a1491 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1526 1
a1526 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1534 1
a1534 1
	VOP_UNLOCK(vp, 0, p);
d1564 1
a1564 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1616 1
a1616 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1661 1
a1661 1
        u_short mode;
d1663 25
a1687 25
        if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
                return (error);
        vp = (struct vnode *)fp->f_data;
        VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
        if (vp->v_mount->mnt_flag & MNT_RDONLY)
                error = EROFS;
        else {
                if (suser(p->p_ucred, &p->p_acflag) ||
                    suid_clear) {
                        error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
                        if (error)
                                goto out;
                        mode = vattr.va_mode & ~(VSUID | VSGID);
                        if (mode == vattr.va_mode)
                                mode = VNOVAL;
                }
                else
                        mode = VNOVAL;
                VATTR_NULL(&vattr);
                vattr.va_uid = SCARG(uap, uid);
                vattr.va_gid = SCARG(uap, gid);
                vattr.va_mode = mode;
                error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
        }
d1689 2
a1690 2
        VOP_UNLOCK(vp, 0, p);
        return (error);
d1692 1
d1699 40
a1738 40
        struct proc *p;
        void *v;
        register_t *retval;
{
        register struct sys_utimes_args /* {
                syscallarg(char *) path;
                syscallarg(struct timeval *) tptr;
        } */ *uap = v;
        register struct vnode *vp;
        struct timeval tv[2];
        struct vattr vattr;
        int error;
        struct nameidata nd;

        VATTR_NULL(&vattr);
        if (SCARG(uap, tptr) == NULL) {
                microtime(&tv[0]);
                tv[1] = tv[0];
                vattr.va_vaflags |= VA_UTIMES_NULL;
        } else {
                error = copyin((caddr_t)SCARG(uap, tptr), (caddr_t)tv,
                               sizeof (tv));
                if (error)
                        return (error);
        }
        NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
        if ((error = namei(&nd)) != 0)
                return (error);
        vp = nd.ni_vp;
        VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
        if (vp->v_mount->mnt_flag & MNT_RDONLY)
                error = EROFS;
        else {
                vattr.va_atime.tv_sec = tv[0].tv_sec;
                vattr.va_atime.tv_nsec = tv[0].tv_usec * 1000;
                vattr.va_mtime.tv_sec = tv[1].tv_sec;
                vattr.va_mtime.tv_nsec = tv[1].tv_usec * 1000;
                error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
        }
d1740 1
a1740 1
        return (error);
a1742 1

d1778 1
a1778 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1788 1
a1788 1
	VOP_UNLOCK(vp, 0, p);
d1817 1
a1817 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1856 1
a1856 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1864 1
a1864 1
	VOP_UNLOCK(vp, 0, p);
d1888 1
a1888 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d1890 1
a1890 1
	VOP_UNLOCK(vp, 0, p);
d2111 1
a2111 1
	vn_lock(vp, LK_EXCLUSIVE | LK_RETRY, p);
d2113 1
a2113 1
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, 0, 0);
d2115 1
a2115 1
	VOP_UNLOCK(vp, 0, p);
d2185 4
d2195 1
a2195 1
		VOP_REVOKE(vp, REVOKEALL);
@


1.25
log
@Add noatime option to not update atime on files in a filesystem (unless
ctime or mtime has changed).  Useful for laptops and news servers.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.24 1997/02/26 16:38:20 niklas Exp $	*/
d105 1
a105 1
	u_long fsindex = 0;
d109 1
d160 1
a160 1
		VOP_UNLOCK(vp);
d199 12
a210 4
		fsindex = (u_long)SCARG(uap, type);
		if (fsindex >= nvfssw || vfssw[fsindex] == NULL) {
			vput(vp);
			return (ENODEV);
a211 1
		strncpy(fstypename, vfssw[fsindex]->vfs_name, MFSNAMELEN);
d223 2
a224 3
	for (fsindex = 0; fsindex < nvfssw; fsindex++)
		if (vfssw[fsindex] != NULL &&
		    !strncmp(vfssw[fsindex]->vfs_name, fstypename, MFSNAMELEN))
d226 3
a228 1
	if (fsindex >= nvfssw) {
d232 1
d244 8
a251 8
	mp->mnt_op = vfssw[fsindex];
	if ((error = vfs_lock(mp)) != 0) {
		free((caddr_t)mp, M_MOUNT);
		vput(vp);
		return (error);
	}
	/* Do this early in case we block later. */
	vfssw[fsindex]->vfs_refcount++;
d279 11
d297 1
d299 1
d301 4
a304 2
		VOP_UNLOCK(vp);
		vfs_unlock(mp);
d306 2
a307 1
		error = VFS_START(mp, 0, p);
d310 1
a310 2
		vfssw[fsindex]->vfs_refcount--;
		vfs_unlock(mp);
d425 1
a425 3
	coveredvp = mp->mnt_vnodecovered;
	if (vfs_busy(mp))
		return (EBUSY);
d427 32
a458 26
	if ((error = vfs_lock(mp)) != 0)
		return (error);

	mp->mnt_flag &=~ MNT_ASYNC;
	vnode_pager_umount(mp);	/* release cached vnodes */
	cache_purgevfs(mp);	/* remove cache entries for this file sys */
	if ((error = VFS_SYNC(mp, MNT_WAIT, p->p_ucred, p)) == 0 ||
	    (flags & MNT_FORCE))
		error = VFS_UNMOUNT(mp, flags, p);
	mp->mnt_flag &= ~MNT_UNMOUNT;
	vfs_unbusy(mp);
	if (error) {
		vfs_unlock(mp);
	} else {
		CIRCLEQ_REMOVE(&mountlist, mp, mnt_list);
		if (coveredvp != NULLVP) {
			vrele(coveredvp);
			coveredvp->v_mountedhere = (struct mount *)0;
		}
		mp->mnt_op->vfs_refcount--;
		vfs_unlock(mp);
		if (mp->mnt_vnodelist.lh_first != NULL)
			panic("unmount: dangling vnode");
		free((caddr_t)mp, M_MOUNT);
	}
	return (error);
d479 1
d481 5
a485 11
		/*
		 * Get the next pointer in case we hang on vfs_busy
		 * while we are being unmounted.
		 */
		nmp = mp->mnt_list.cqe_prev;
		/*
		 * The lock check below is to avoid races with mount
		 * and unmount.
		 */
		if ((mp->mnt_flag & (MNT_MLOCK|MNT_RDONLY|MNT_MPBUSY)) == 0 &&
		    !vfs_busy(mp)) {
a490 6
			/*
			 * Get the next pointer again, as the next filesystem
			 * might have been unmounted while we were sync'ing.
			 */
			nmp = mp->mnt_list.cqe_prev;
			vfs_unbusy(mp);
d492 3
d496 2
d622 1
a622 1
	register struct mount *mp;
d630 8
a637 5
	for (count = 0, mp = mountlist.cqh_first;
	     mp != (void *)&mountlist;
	     mp = mp->mnt_list.cqe_next) {
		if (sfsp && count < maxcount &&
		    ((mp->mnt_flag & MNT_MLOCK) == 0)) {
d640 5
a644 4
			 * If MNT_NOWAIT is specified, do not refresh the
			 * fsstat cache. MNT_WAIT overrides MNT_NOWAIT.
			 */
			if (((SCARG(uap, flags) & MNT_NOWAIT) == 0 ||
d646 6
a651 2
			    (error = VFS_STATFS(mp, sp, p)))
				continue;
d664 3
d668 1
d699 1
a699 1
	VOP_LOCK(vp);
d715 10
a724 1
	VOP_UNLOCK(vp);
d726 1
a726 1
		vrele(vp);
d729 1
a815 1
	VOP_UNLOCK(vp);
d817 3
a819 1
		vrele(vp);
d886 1
a886 1
		VOP_UNLOCK(vp);
d894 1
a894 1
		VOP_LOCK(vp);
d897 1
a897 1
	VOP_UNLOCK(vp);
d1466 1
a1466 1
	VOP_LOCK(vp);
d1501 1
a1501 1
	VOP_LOCK(vp);
d1509 1
a1509 1
	VOP_UNLOCK(vp);
d1537 1
a1537 1
	VOP_LOCK(vp);
d1572 1
a1572 1
	VOP_LOCK(vp);
d1580 1
a1580 1
	VOP_UNLOCK(vp);
d1610 1
a1610 1
	VOP_LOCK(vp);
d1662 1
a1662 1
	VOP_LOCK(vp);
d1707 1
a1707 1
	u_short mode;
d1709 25
a1733 25
	if ((error = getvnode(p->p_fd, SCARG(uap, fd), &fp)) != 0)
		return (error);
	vp = (struct vnode *)fp->f_data;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	VOP_LOCK(vp);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		if (suser(p->p_ucred, &p->p_acflag) ||
		    suid_clear) {
			error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
			if (error)
				goto out;
			mode = vattr.va_mode & ~(VSUID | VSGID);
			if (mode == vattr.va_mode)
				mode = VNOVAL;
		}
		else
			mode = VNOVAL;
		VATTR_NULL(&vattr);
		vattr.va_uid = SCARG(uap, uid);
		vattr.va_gid = SCARG(uap, gid);
		vattr.va_mode = mode;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
d1735 2
a1736 2
	VOP_UNLOCK(vp);
	return (error);
a1737 1

d1744 40
a1783 40
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sys_utimes_args /* {
		syscallarg(char *) path;
		syscallarg(struct timeval *) tptr;
	} */ *uap = v;
	register struct vnode *vp;
	struct timeval tv[2];
	struct vattr vattr;
	int error;
	struct nameidata nd;

	VATTR_NULL(&vattr);
	if (SCARG(uap, tptr) == NULL) {
		microtime(&tv[0]);
		tv[1] = tv[0];
		vattr.va_vaflags |= VA_UTIMES_NULL;
	} else {
		error = copyin((caddr_t)SCARG(uap, tptr), (caddr_t)tv,
			       sizeof (tv));
		if (error)
			return (error);
	}
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, SCARG(uap, path), p);
	if ((error = namei(&nd)) != 0)
		return (error);
	vp = nd.ni_vp;
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	VOP_LOCK(vp);
	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		error = EROFS;
	else {
		vattr.va_atime.tv_sec = tv[0].tv_sec;
		vattr.va_atime.tv_nsec = tv[0].tv_usec * 1000;
		vattr.va_mtime.tv_sec = tv[1].tv_sec;
		vattr.va_mtime.tv_nsec = tv[1].tv_usec * 1000;
		error = VOP_SETATTR(vp, &vattr, p->p_ucred, p);
	}
d1785 1
a1785 1
	return (error);
d1788 1
d1824 1
a1824 1
	VOP_LOCK(vp);
d1834 1
a1834 1
	VOP_UNLOCK(vp);
d1863 1
a1863 1
	VOP_LOCK(vp);
d1902 1
a1902 1
	VOP_LOCK(vp);
d1910 1
a1910 1
	VOP_UNLOCK(vp);
d1934 1
a1934 1
	VOP_LOCK(vp);
d1936 1
a1936 1
	VOP_UNLOCK(vp);
d2157 1
a2157 1
	VOP_LOCK(vp);
d2159 1
a2159 1
	error = VOP_READDIR(vp, &auio, fp->f_cred, &eofflag, (u_long *)0, 0);
d2161 1
a2161 1
	VOP_UNLOCK(vp);
a2230 4
	if (vp->v_type != VCHR && vp->v_type != VBLK) {
		error = EINVAL;
		goto out;
	}
d2237 1
a2237 1
		vgoneall(vp);
@


1.24
log
@From tholo: Do not do strict POSIX offset checking on character devices.
This fixes the problem of not being able to read kernel virtual memory on
the alpha, thus breaking things like ps etc.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.23 1997/02/14 17:20:09 deraadt Exp $	*/
d254 1
a254 1
	    MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC);
d256 1
a256 1
	    MNT_NODEV | MNT_SYNCHRONOUS | MNT_UNION | MNT_ASYNC);
@


1.23
log
@hide fsid in getfsstat too, clone of millert fix, problem spotted by bitblt
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.22 1997/02/13 02:45:43 millert Exp $	*/
d1169 1
a1169 1
	int error;
d1179 4
d1185 1
a1185 1
		if (fp->f_offset + SCARG(uap, offset) < 0)
d1194 1
a1194 1
		if ((off_t)vattr.va_size + SCARG(uap, offset) < 0)
d1199 1
a1199 1
		if (SCARG(uap, offset) < 0)
@


1.22
log
@Don't expose f_fsid to non-root.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.21 1997/02/02 00:32:02 tholo Exp $	*/
d603 1
d622 5
@


1.21
log
@Prevent seeking to negative offsets when seeking from the end of a file;
noticed by Tim Newsham <newsham@@aloha.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.20 1997/01/26 05:18:29 downsj Exp $	*/
d529 1
d540 6
d567 1
d576 6
@


1.20
log
@Add lchown(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.19 1997/01/25 00:27:31 dm Exp $	*/
d1170 1
a1170 1
		if (vattr.va_size + SCARG(uap, offset) < 0)
@


1.19
log
@Only disclose generation number to root.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.18 1997/01/02 12:20:40 mickey Exp $	*/
d1536 52
@


1.18
log
@pulled out the duplicated, conditional code from both kern/vfs_syscalls.c
and compat/common/vfs_syscalls_43.c and placed a single copy of that code
into miscfs/union/union_subr.c (seemed like a good place to put it, since
it's union-fs related).
as a side effect you can build unionfs in lkm.
(netbsd pr#2950, Paul Goyette <paul@@pgoyette.bdt.com>)
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.17 1996/10/27 08:02:32 tholo Exp $	*/
d1261 3
d1294 3
@


1.17
log
@Better error checking for lseek(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.16 1996/10/26 07:27:01 tholo Exp $	*/
d72 11
d2006 1
a2006 1
	register struct vnode *vp;
a2035 6

#ifdef UNION
{
	extern int (**union_vnodeop_p) __P((void *));
	extern struct vnode *union_dircache __P((struct vnode *));

d2037 5
a2041 37
	    (vp->v_op == union_vnodeop_p)) {
		struct vnode *lvp;

		lvp = union_dircache(vp);
		if (lvp != NULLVP) {
			struct vattr va;

			/*
			 * If the directory is opaque,
			 * then don't show lower entries
			 */
			error = VOP_GETATTR(vp, &va, fp->f_cred, p);
			if (va.va_flags & OPAQUE) {
				vput(lvp);
				lvp = NULL;
			}
		}
		
		if (lvp != NULLVP) {
			error = VOP_OPEN(lvp, FREAD, fp->f_cred, p);
			VOP_UNLOCK(lvp);

			if (error) {
				vrele(lvp);
				return (error);
			}
			fp->f_data = (caddr_t) lvp;
			fp->f_offset = 0;
			error = vn_close(vp, FREAD, fp->f_cred, p);
			if (error)
				return (error);
			vp = lvp;
			goto unionread;
		}
	}
}
#endif /* UNION */
@


1.16
log
@rename(from, to) where from and to are the name file (linked) is a no-op
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.15 1996/10/04 01:26:48 deraadt Exp $	*/
d1137 1
d1145 3
d1150 2
d1159 2
d1164 2
@


1.15
log
@usermount sysctl, default to prevent users from using mount syscall
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.14 1996/09/24 02:40:12 deraadt Exp $	*/
d1838 1
a1838 2
	 * same inode number with the same name in the same directory),
	 * then there is nothing to do.
d1840 1
a1840 4
	if (fvp == tvp && fromnd.ni_dvp == tdvp &&
	    fromnd.ni_cnd.cn_namelen == tond.ni_cnd.cn_namelen &&
	    !bcmp(fromnd.ni_cnd.cn_nameptr, tond.ni_cnd.cn_nameptr,
	      fromnd.ni_cnd.cn_namelen))
@


1.14
log
@no mknod in chroot
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.13 1996/09/24 02:38:30 deraadt Exp $	*/
d64 1
d98 3
@


1.13
log
@unescapeable chroot; thanks to nirva and asriel for helping
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.12 1996/08/08 06:36:47 tholo Exp $	*/
d844 2
@


1.12
log
@Make {,f}chown(2) behaviour POSIX.1 compliant with SUID / SGID files
Enable CTL_FS processing by sysctl(3)
Add CTL_FS request to disable clearing SUID / SGID bit when a files owner
or group is changed by root
Make sysctl(8) understand CTL_FS requests
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.11 1996/08/08 04:23:03 tholo Exp $	*/
d704 5
a708 1
	if (fdp->fd_rdir != NULL)
d710 4
@


1.11
log
@Lose the SUID bit if owner changes in {,f}chown
Lose the SGID bit if group changes in {,f}chown
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.10 1996/08/02 19:59:01 tholo Exp $	*/
d63 2
d1503 10
a1512 9
		error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
		if (error)
			goto out;
		mode = vattr.va_mode;
		if (vattr.va_uid != SCARG(uap, uid))
			mode &= ~VSUID;
		if (vattr.va_gid != SCARG(uap, gid))
			mode &= ~VSGID;
		if (mode == vattr.va_mode)
d1554 10
a1563 9
		error = VOP_GETATTR(vp, &vattr, p->p_ucred, p);
		if (error)
			goto out;
		mode = vattr.va_mode;
		if (vattr.va_uid != SCARG(uap, uid))
			mode &= ~VSUID;
		if (vattr.va_gid != SCARG(uap, gid))
			mode &= ~VSGID;
		if (mode == vattr.va_mode)
@


1.10
log
@Return EINVAL for invalid mode flags to access(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.9 1996/06/02 16:24:42 niklas Exp $	*/
d1490 1
d1501 10
d1514 1
d1517 1
d1541 1
d1551 10
d1564 1
d1567 1
@


1.9
log
@explictly state getvnode's  return type
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.8 1996/05/14 18:24:21 mickey Exp $	*/
d1167 2
@


1.8
log
@fix NetBSD PR#1145.
@
text
@d1 1
a1 1
/*	$OpenBSD: vfs_syscalls.c,v 1.6 1996/04/21 22:27:39 deraadt Exp $	*/
d2097 1
@


1.7
log
@Implement futimes()
@
text
@d568 1
a568 1
	register struct mount *mp, *nmp;
d575 3
a577 3
	for (count = 0,
	     mp = mountlist.cqh_first; mp != (void *)&mountlist; mp = nmp) {
		nmp = mp->mnt_list.cqe_next;
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: vfs_syscalls.c,v 1.5 1996/04/17 05:09:14 mickey Exp $	*/
/*	$NetBSD: vfs_syscalls.c,v 1.70 1996/03/22 06:51:04 thorpej Exp $	*/
d1522 1
d1524 1
a1524 1
	struct vnode *vp;
a1525 1
	int error;
d1545 1
a1545 1
 * Set the access and modification times of a file.
d1569 1
a1569 2
	}
	else {
d1591 49
@


1.5
log
@Removed vax ifdefed function from kern_subr.c (from NetBSD).
Do sync in the order of umount (vfs_syscals.c), as it was pointed
by someone in NetBSD's lists.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: vfs_syscalls.c,v 1.68 1996/02/09 19:01:05 christos Exp $	*/
d897 3
a907 3
#ifndef FIFO
	return (EOPNOTSUPP);
#else
d1093 2
a1094 2
	if (vp->v_flag & VTEXT)
		(void)vnode_pager_uncache(vp);
@


1.4
log
@From NetBSD: Merge with NetBSD 960217
@
text
@d1 1
d433 1
a433 1
	for (mp = mountlist.cqh_first; mp != (void *)&mountlist; mp = nmp) {
d438 1
a438 1
		nmp = mp->mnt_list.cqe_next;
d454 1
a454 1
			nmp = mp->mnt_list.cqe_next;
@


1.3
log
@indenting error thing that is making my diffs look confusing
@
text
@d1 1
a1 1
/*	$NetBSD: vfs_syscalls.c,v 1.58 1995/11/07 22:41:02 gwr Exp $	*/
d62 4
a65 1
static int change_dir __P((struct nameidata *ndp, struct proc *p));
d75 1
d89 2
a90 2
	int error, flag;
	u_long fsindex;
d100 1
a100 1
	if (error = namei(&nd))
d165 1
a165 1
	if (error = vinvalbuf(vp, V_SAVE, p->p_ucred, p, 0, 0))
d171 2
a172 2
	if (error = copyinstr(SCARG(uap, type), fstypename, MFSNAMELEN,
	    (size_t *)0)) {
d217 1
a217 1
	if (error = vfs_lock(mp)) {
d279 1
d319 1
d336 1
a336 1
	if (error = namei(&nd))
d373 1
d386 1
a386 1
	if (error = vfs_lock(mp))
d423 1
d468 1
d485 1
a485 1
	if (error = namei(&nd))
d497 1
d513 1
a513 1
	if (error = namei(&nd))
d518 1
a518 1
	if (error = VFS_STATFS(mp, sp, p))
d528 1
d543 1
a543 1
	if (error = getvnode(p->p_fd, SCARG(uap, fd), &fp))
d547 1
a547 1
	if (error = VFS_STATFS(mp, sp, p))
d556 1
d589 2
a590 1
			if (error = copyout((caddr_t)sp, sfsp, sizeof(*sp)))
d607 1
d622 1
a622 1
	if (error = getvnode(fdp, SCARG(uap, fd), &fp))
d637 1
a637 1
		if (error = VFS_ROOT(mp, &tdp))
d656 1
d671 1
a671 1
	if (error = change_dir(&nd, p))
d682 1
d695 1
a695 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d699 1
a699 1
	if (error = change_dir(&nd, p))
d718 1
a718 1
	if (error = namei(ndp))
d735 1
d756 1
a756 1
	if (error = falloc(p, &nfp, &indx))
d763 1
a763 1
	if (error = vn_open(&nd, flags, cmode)) {
d795 2
a796 1
		if (error = VOP_ADVLOCK(vp, (caddr_t)fp, F_SETLK, &lf, type)) {
d814 1
d828 1
a828 1
	int whiteout;
d831 1
a831 1
	if (error = suser(p->p_ucred, &p->p_acflag))
d834 1
a834 1
	if (error = namei(&nd))
d890 1
d908 1
a908 1
	if (error = namei(&nd))
d931 1
d946 1
a946 1
	if (error = namei(&nd))
d949 12
a960 23
	if (vp->v_type != VDIR ||
	    (error = suser(p->p_ucred, &p->p_acflag)) == 0) {
		nd.ni_cnd.cn_nameiop = CREATE;
		nd.ni_cnd.cn_flags = LOCKPARENT;
		nd.ni_dirp = SCARG(uap, link);
		if ((error = namei(&nd)) == 0) {
			if (nd.ni_vp != NULL)
				error = EEXIST;
			if (!error) {
				VOP_LEASE(nd.ni_dvp, p, p->p_ucred,
				    LEASE_WRITE);
				VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
				error = VOP_LINK(nd.ni_dvp, vp, &nd.ni_cnd);
			} else {
				VOP_ABORTOP(nd.ni_dvp, &nd.ni_cnd);
				if (nd.ni_dvp == nd.ni_vp)
					vrele(nd.ni_dvp);
				else
					vput(nd.ni_dvp);
				if (nd.ni_vp)
					vrele(nd.ni_vp);
			}
		}
d962 4
d974 1
d990 2
a991 1
	if (error = copyinstr(SCARG(uap, path), path, MAXPATHLEN, (size_t *)0))
d994 1
a994 1
	if (error = namei(&nd))
d1019 1
d1049 1
a1049 1
	if (error = VOP_WHITEOUT(nd.ni_dvp, &nd.ni_cnd, DELETE))
d1059 1
d1072 3
a1074 2
	NDINIT(&nd, DELETE, LOCKPARENT, UIO_USERSPACE, SCARG(uap, path), p);
	if (error = namei(&nd))
a1076 2
	VOP_LEASE(vp, p, p->p_ucred, LEASE_WRITE);
	VOP_LOCK(vp);
d1078 4
a1081 15
	if (vp->v_type != VDIR ||
	    (error = suser(p->p_ucred, &p->p_acflag)) == 0) {
		/*
		 * The root of a mounted filesystem cannot be deleted.
		 */
		if (vp->v_flag & VROOT)
			error = EBUSY;
		else
			(void)vnode_pager_uncache(vp);
	}

	if (!error) {
		VOP_LEASE(nd.ni_dvp, p, p->p_ucred, LEASE_WRITE);
		error = VOP_REMOVE(nd.ni_dvp, nd.ni_vp, &nd.ni_cnd);
	} else {
d1087 3
a1089 2
		if (vp != NULLVP)
			vput(vp);
d1091 7
d1104 1
d1132 3
a1134 2
		if (error =
		    VOP_GETATTR((struct vnode *)fp->f_data, &vattr, cred, p))
d1151 1
d1172 1
a1172 1
	if (error = namei(&nd))
d1199 1
d1215 1
a1215 1
	if (error = namei(&nd))
d1229 1
d1239 1
a1240 2
	struct vnode *vp, *dvp;
	struct stat sb, sb1;
d1243 1
a1243 1
	NDINIT(&nd, LOOKUP, NOFOLLOW | LOCKLEAF | LOCKPARENT, UIO_USERSPACE,
d1245 5
a1249 1
	if (error = namei(&nd))
a1250 32
	/*
	 * For symbolic links, always return the attributes of its
	 * containing directory, except for mode, size, and links.
	 */
	vp = nd.ni_vp;
	dvp = nd.ni_dvp;
	if (vp->v_type != VLNK) {
		if (dvp == vp)
			vrele(dvp);
		else
			vput(dvp);
		error = vn_stat(vp, &sb, p);
		vput(vp);
		if (error)
			return (error);
	} else {
		error = vn_stat(dvp, &sb, p);
		vput(dvp);
		if (error) {
			vput(vp);
			return (error);
		}
		error = vn_stat(vp, &sb1, p);
		vput(vp);
		if (error)
			return (error);
		sb.st_mode &= ~S_IFDIR;
		sb.st_mode |= S_IFLNK;
		sb.st_nlink = sb1.st_nlink;
		sb.st_size = sb1.st_size;
		sb.st_blocks = sb1.st_blocks;
	}
d1259 1
d1274 1
a1274 1
	if (error = namei(&nd))
d1285 1
d1304 1
a1304 1
	if (error = namei(&nd))
d1330 1
d1346 1
a1346 1
	if (error = namei(&nd))
d1366 1
d1381 1
a1381 1
	if (error = getvnode(p->p_fd, SCARG(uap, fd), &fp))
d1401 1
d1417 1
a1417 1
	if (error = namei(&nd))
d1437 1
d1452 1
a1452 1
	if (error = getvnode(p->p_fd, SCARG(uap, fd), &fp))
d1472 1
d1489 1
a1489 1
	if (error = namei(&nd))
d1510 1
d1526 1
a1526 1
	if (error = getvnode(p->p_fd, SCARG(uap, fd), &fp))
d1547 1
d1568 7
a1574 3
	} else if (error = copyin((caddr_t)SCARG(uap, tptr), (caddr_t)tv,
	    sizeof (tv)))
  		return (error);
d1576 1
a1576 1
	if (error = namei(&nd))
d1584 4
a1587 4
		vattr.va_atime.ts_sec = tv[0].tv_sec;
		vattr.va_atime.ts_nsec = tv[0].tv_usec * 1000;
		vattr.va_mtime.ts_sec = tv[1].tv_sec;
		vattr.va_mtime.ts_nsec = tv[1].tv_usec * 1000;
d1598 1
d1615 1
a1615 1
	if (error = namei(&nd))
d1636 1
d1652 1
a1652 1
	if (error = getvnode(p->p_fd, SCARG(uap, fd), &fp))
d1674 1
d1687 1
a1687 1
	if (error = getvnode(p->p_fd, SCARG(uap, fd), &fp))
d1701 1
d1717 1
a1717 1
	if (error = namei(&fromnd))
d1722 1
a1722 1
	if (error = namei(&tond)) {
d1787 1
d1803 1
a1803 1
	if (error = namei(&nd))
d1829 1
d1844 1
a1844 1
	if (error = namei(&nd))
d1882 1
d1901 1
a1901 1
	if (error = getvnode(p->p_fd, SCARG(uap, fd), &fp))
d1927 1
a1927 1
	extern int (**union_vnodeop_p)();
d2011 1
d2026 1
a2026 1
	if (error = namei(&nd))
d2033 1
a2033 1
	if (error = VOP_GETATTR(vp, &vattr, p->p_ucred, p))
@


1.2
log
@ufs vs ffs compat stuff from Gordon Ross.    Gordon says:

	This allows the 1.0 version of /sbin/mount to work with the latest
	kernels.  (Being unable to mount disks is a real drag...)
@
text
@d1 1
a1 1
/*	$NetBSD: vfs_syscalls.c,v 1.57 1995/10/07 06:28:51 mycroft Exp $	*/
d188 1
a188 1
	/* Accept "ufs" as a synonym for "ffs" */
@


1.1
log
@Initial revision
@
text
@d187 6
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
