head	1.209;
access;
symbols
	OPENBSD_6_1:1.208.0.4
	OPENBSD_6_1_BASE:1.208
	OPENBSD_6_0:1.202.0.2
	OPENBSD_6_0_BASE:1.202
	OPENBSD_5_9:1.192.0.2
	OPENBSD_5_9_BASE:1.192
	OPENBSD_5_8:1.183.0.4
	OPENBSD_5_8_BASE:1.183
	OPENBSD_5_7:1.178.0.2
	OPENBSD_5_7_BASE:1.178
	OPENBSD_5_6:1.173.0.4
	OPENBSD_5_6_BASE:1.173
	OPENBSD_5_5:1.158.0.4
	OPENBSD_5_5_BASE:1.158
	OPENBSD_5_4:1.152.0.2
	OPENBSD_5_4_BASE:1.152
	OPENBSD_5_3:1.148.0.2
	OPENBSD_5_3_BASE:1.148
	OPENBSD_5_2:1.143.0.2
	OPENBSD_5_2_BASE:1.143
	OPENBSD_5_1_BASE:1.133
	OPENBSD_5_1:1.133.0.2
	OPENBSD_5_0:1.126.0.2
	OPENBSD_5_0_BASE:1.126
	OPENBSD_4_9:1.116.0.4
	OPENBSD_4_9_BASE:1.116
	OPENBSD_4_8:1.116.0.2
	OPENBSD_4_8_BASE:1.116
	OPENBSD_4_7:1.107.0.2
	OPENBSD_4_7_BASE:1.107
	OPENBSD_4_6:1.105.0.4
	OPENBSD_4_6_BASE:1.105
	OPENBSD_4_5:1.102.0.2
	OPENBSD_4_5_BASE:1.102
	OPENBSD_4_4:1.99.0.2
	OPENBSD_4_4_BASE:1.99
	OPENBSD_4_3:1.97.0.2
	OPENBSD_4_3_BASE:1.97
	OPENBSD_4_2:1.94.0.2
	OPENBSD_4_2_BASE:1.94
	OPENBSD_4_1:1.87.0.2
	OPENBSD_4_1_BASE:1.87
	OPENBSD_4_0:1.84.0.2
	OPENBSD_4_0_BASE:1.84
	OPENBSD_3_9:1.81.0.2
	OPENBSD_3_9_BASE:1.81
	OPENBSD_3_8:1.76.0.2
	OPENBSD_3_8_BASE:1.76
	OPENBSD_3_7:1.73.0.2
	OPENBSD_3_7_BASE:1.73
	OPENBSD_3_6:1.72.0.2
	OPENBSD_3_6_BASE:1.72
	SMP_SYNC_A:1.70
	SMP_SYNC_B:1.70
	OPENBSD_3_5:1.69.0.2
	OPENBSD_3_5_BASE:1.69
	OPENBSD_3_4:1.68.0.2
	OPENBSD_3_4_BASE:1.68
	UBC_SYNC_A:1.62
	OPENBSD_3_3:1.61.0.4
	OPENBSD_3_3_BASE:1.61
	OPENBSD_3_2:1.61.0.2
	OPENBSD_3_2_BASE:1.61
	OPENBSD_3_1:1.56.0.2
	OPENBSD_3_1_BASE:1.56
	UBC_SYNC_B:1.61
	UBC:1.50.0.2
	UBC_BASE:1.50
	OPENBSD_3_0:1.49.0.2
	OPENBSD_3_0_BASE:1.49
	OPENBSD_2_9_BASE:1.42
	OPENBSD_2_9:1.42.0.2
	OPENBSD_2_8:1.38.0.2
	OPENBSD_2_8_BASE:1.38
	OPENBSD_2_7:1.37.0.2
	OPENBSD_2_7_BASE:1.37
	SMP:1.35.0.2
	SMP_BASE:1.35
	kame_19991208:1.35
	OPENBSD_2_6:1.34.0.2
	OPENBSD_2_6_BASE:1.34
	OPENBSD_2_5:1.33.0.2
	OPENBSD_2_5_BASE:1.33
	OPENBSD_2_4:1.30.0.2
	OPENBSD_2_4_BASE:1.30
	OPENBSD_2_3:1.26.0.2
	OPENBSD_2_3_BASE:1.26
	OPENBSD_2_2:1.21.0.2
	OPENBSD_2_2_BASE:1.21
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.209
date	2017.04.13.03.52.25;	author guenther;	state Exp;
branches;
next	1.208;
commitid	ziRFTEFDWOo0M88l;

1.208
date	2017.01.24.00.58.55;	author mpi;	state Exp;
branches;
next	1.207;
commitid	r0ks7yUPmANG37rA;

1.207
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.206;
commitid	CHRb0fCqa8XxUAMH;

1.206
date	2016.10.05.02.31.52;	author guenther;	state Exp;
branches;
next	1.205;
commitid	z4axJxYMv8DhHpqn;

1.205
date	2016.09.15.02.00.16;	author dlg;	state Exp;
branches;
next	1.204;
commitid	RlO92XR575sygHqm;

1.204
date	2016.09.04.17.22.40;	author jsing;	state Exp;
branches;
next	1.203;
commitid	NpC0d7eh7RcmjtSO;

1.203
date	2016.08.25.00.00.02;	author dlg;	state Exp;
branches;
next	1.202;
commitid	iTfOIfeIXH3Xx3fA;

1.202
date	2016.07.14.05.55.08;	author guenther;	state Exp;
branches;
next	1.201;
commitid	lclMlOztWVAw0FCc;

1.201
date	2016.07.06.15.53.01;	author tedu;	state Exp;
branches;
next	1.200;
commitid	dZWS1TCbA5Wj2uVG;

1.200
date	2016.06.27.19.55.02;	author jca;	state Exp;
branches;
next	1.199;
commitid	bjXjarVuCgiWznx4;

1.199
date	2016.06.27.16.49.45;	author jsing;	state Exp;
branches;
next	1.198;
commitid	iLjJpmaJ0JoxMuMA;

1.198
date	2016.06.11.21.41.50;	author tedu;	state Exp;
branches;
next	1.197;
commitid	4Z8htjp4xIxRa3O4;

1.197
date	2016.05.31.22.14.43;	author deraadt;	state Exp;
branches;
next	1.196;
commitid	0oNnIcgqQW50Cm5L;

1.196
date	2016.03.29.08.46.08;	author mpi;	state Exp;
branches;
next	1.195;
commitid	Yyb4nhV2PH21mCBk;

1.195
date	2016.03.26.21.38.54;	author beck;	state Exp;
branches;
next	1.194;
commitid	vSiAnuF9EtJVz8Fi;

1.194
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.193;
commitid	gAjwyca5TfuoJAhn;

1.193
date	2016.03.09.13.38.50;	author mpi;	state Exp;
branches;
next	1.192;
commitid	THpTza9IRRtZUKne;

1.192
date	2016.01.09.06.13.43;	author semarie;	state Exp;
branches
	1.192.2.1;
next	1.191;
commitid	dcaV4x1VpVc8yivT;

1.191
date	2015.12.05.10.11.53;	author tedu;	state Exp;
branches;
next	1.190;
commitid	Cl55DD2g2xm69E6W;

1.190
date	2015.11.10.04.30.59;	author guenther;	state Exp;
branches;
next	1.189;
commitid	GTAoVjpQRAdNHXVz;

1.189
date	2015.11.02.16.31.55;	author semarie;	state Exp;
branches;
next	1.188;
commitid	PyvdcQVr9G4daVnG;

1.188
date	2015.11.01.19.03.33;	author semarie;	state Exp;
branches;
next	1.187;
commitid	VKRkUfXZQNJ8UQeY;

1.187
date	2015.10.25.20.39.54;	author deraadt;	state Exp;
branches;
next	1.186;
commitid	SIwCBDJKKae61tEi;

1.186
date	2015.10.10.19.12.39;	author deraadt;	state Exp;
branches;
next	1.185;
commitid	wE7YCHu4znQvSIRB;

1.185
date	2015.10.09.23.55.03;	author deraadt;	state Exp;
branches;
next	1.184;
commitid	xJO135yQ1KjvxFYJ;

1.184
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.183;
commitid	av6ZVErLSWkVP5Zz;

1.183
date	2015.07.27.18.22.37;	author deraadt;	state Exp;
branches
	1.183.4.1;
next	1.182;
commitid	4VS4Pd5BumhjJccK;

1.182
date	2015.07.20.00.19.14;	author beck;	state Exp;
branches;
next	1.181;
commitid	wsL8bs3upVMoJtyJ;

1.181
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	1.180;
commitid	CJwjm9NDWu6nJ6ES;

1.180
date	2015.05.05.02.13.46;	author guenther;	state Exp;
branches;
next	1.179;
commitid	dNPv28CJI5BxtRGW;

1.179
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.178;
commitid	p4LJxGKbi0BU2cG6;

1.178
date	2015.02.09.13.41.24;	author pelikan;	state Exp;
branches;
next	1.177;
commitid	A5GI5pfcmwpscN1L;

1.177
date	2014.12.19.05.59.21;	author tedu;	state Exp;
branches;
next	1.176;
commitid	zdJTCwdpqRUwO1SL;

1.176
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.175;
commitid	P6Av4XGqOi3rFasL;

1.175
date	2014.11.16.05.42.21;	author guenther;	state Exp;
branches;
next	1.174;
commitid	xuyVjwR0omX0ygFF;

1.174
date	2014.08.10.23.44.20;	author bluhm;	state Exp;
branches;
next	1.173;
commitid	s25WVLmmAbhQNgyg;

1.173
date	2014.07.13.16.41.21;	author claudio;	state Exp;
branches;
next	1.172;
commitid	04aN4E0CXyBXMp3X;

1.172
date	2014.07.13.15.46.21;	author uebayasi;	state Exp;
branches;
next	1.171;
commitid	Scu6CelRPdB3AwwA;

1.171
date	2014.07.12.21.21.19;	author matthew;	state Exp;
branches;
next	1.170;
commitid	hPWqptyZtIqB8x1B;

1.170
date	2014.07.11.08.18.31;	author guenther;	state Exp;
branches;
next	1.169;
commitid	zJyOCNTjgsYVGLiw;

1.169
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.168;
commitid	EF98ch02VpFassUi;

1.168
date	2014.07.04.05.58.30;	author guenther;	state Exp;
branches;
next	1.167;
commitid	vhXZZxMGVTWiFaF3;

1.167
date	2014.06.21.20.58.30;	author guenther;	state Exp;
branches;
next	1.166;
commitid	IvlsVYNsU5F7UWHE;

1.166
date	2014.05.04.05.03.26;	author guenther;	state Exp;
branches;
next	1.165;

1.165
date	2014.05.04.03.53.37;	author deraadt;	state Exp;
branches;
next	1.164;

1.164
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.163;

1.163
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.162;

1.162
date	2014.03.26.05.27.18;	author guenther;	state Exp;
branches;
next	1.161;

1.161
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.160;

1.160
date	2014.03.24.03.48.00;	author guenther;	state Exp;
branches;
next	1.159;

1.159
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.158;

1.158
date	2014.02.09.11.17.19;	author kettenis;	state Exp;
branches;
next	1.157;

1.157
date	2014.01.21.01.48.44;	author tedu;	state Exp;
branches;
next	1.156;

1.156
date	2014.01.20.21.19.28;	author guenther;	state Exp;
branches;
next	1.155;

1.155
date	2013.10.08.03.50.07;	author guenther;	state Exp;
branches;
next	1.154;

1.154
date	2013.10.08.03.36.48;	author guenther;	state Exp;
branches;
next	1.153;

1.153
date	2013.10.06.19.44.42;	author guenther;	state Exp;
branches;
next	1.152;

1.152
date	2013.06.01.04.05.26;	author tedu;	state Exp;
branches;
next	1.151;

1.151
date	2013.04.29.17.06.20;	author matthew;	state Exp;
branches;
next	1.150;

1.150
date	2013.04.06.06.08.20;	author tedu;	state Exp;
branches;
next	1.149;

1.149
date	2013.03.28.16.55.25;	author deraadt;	state Exp;
branches;
next	1.148;

1.148
date	2013.02.08.04.30.37;	author guenther;	state Exp;
branches;
next	1.147;

1.147
date	2013.01.15.02.03.38;	author deraadt;	state Exp;
branches;
next	1.146;

1.146
date	2013.01.15.01.34.27;	author deraadt;	state Exp;
branches;
next	1.145;

1.145
date	2012.12.02.07.03.32;	author guenther;	state Exp;
branches;
next	1.144;

1.144
date	2012.10.17.04.48.52;	author guenther;	state Exp;
branches;
next	1.143;

1.143
date	2012.07.11.08.45.21;	author guenther;	state Exp;
branches;
next	1.142;

1.142
date	2012.06.06.04.47.43;	author guenther;	state Exp;
branches;
next	1.141;

1.141
date	2012.04.13.16.37.51;	author kettenis;	state Exp;
branches;
next	1.140;

1.140
date	2012.04.12.10.11.41;	author mikeb;	state Exp;
branches;
next	1.139;

1.139
date	2012.04.11.15.28.50;	author kettenis;	state Exp;
branches;
next	1.138;

1.138
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.137;

1.137
date	2012.03.19.09.05.39;	author guenther;	state Exp;
branches;
next	1.136;

1.136
date	2012.03.10.06.27.21;	author guenther;	state Exp;
branches;
next	1.135;

1.135
date	2012.03.10.05.54.28;	author guenther;	state Exp;
branches;
next	1.134;

1.134
date	2012.02.20.22.23.39;	author guenther;	state Exp;
branches;
next	1.133;

1.133
date	2012.01.25.06.12.13;	author guenther;	state Exp;
branches;
next	1.132;

1.132
date	2012.01.17.02.34.18;	author guenther;	state Exp;
branches;
next	1.131;

1.131
date	2011.12.11.19.42.28;	author guenther;	state Exp;
branches;
next	1.130;

1.130
date	2011.11.22.23.20.19;	author joshe;	state Exp;
branches;
next	1.129;

1.129
date	2011.11.16.20.50.19;	author deraadt;	state Exp;
branches;
next	1.128;

1.128
date	2011.11.09.20.57.38;	author guenther;	state Exp;
branches;
next	1.127;

1.127
date	2011.09.20.10.07.37;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.125;

1.125
date	2011.07.09.05.31.26;	author matthew;	state Exp;
branches;
next	1.124;

1.124
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.123;

1.123
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.122;

1.122
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.121;

1.121
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.120;

1.120
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.119;

1.119
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.118;

1.118
date	2011.04.02.17.04.35;	author guenther;	state Exp;
branches;
next	1.117;

1.117
date	2011.03.07.07.07.13;	author guenther;	state Exp;
branches;
next	1.116;

1.116
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.115;

1.115
date	2010.07.02.19.57.15;	author tedu;	state Exp;
branches;
next	1.114;

1.114
date	2010.07.01.02.41.12;	author guenther;	state Exp;
branches;
next	1.113;

1.113
date	2010.06.30.01.47.35;	author tedu;	state Exp;
branches;
next	1.112;

1.112
date	2010.06.29.20.48.50;	author guenther;	state Exp;
branches;
next	1.111;

1.111
date	2010.06.29.02.46.43;	author tedu;	state Exp;
branches;
next	1.110;

1.110
date	2010.06.29.00.28.14;	author tedu;	state Exp;
branches;
next	1.109;

1.109
date	2010.06.28.23.00.30;	author guenther;	state Exp;
branches;
next	1.108;

1.108
date	2010.05.18.22.26.10;	author tedu;	state Exp;
branches;
next	1.107;

1.107
date	2009.11.27.19.43.55;	author guenther;	state Exp;
branches;
next	1.106;

1.106
date	2009.11.04.19.14.10;	author kettenis;	state Exp;
branches;
next	1.105;

1.105
date	2009.06.06.21.25.19;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2009.06.05.03.57.32;	author ray;	state Exp;
branches;
next	1.103;

1.103
date	2009.03.05.19.52.24;	author kettenis;	state Exp;
branches;
next	1.102;

1.102
date	2009.01.29.22.18.06;	author guenther;	state Exp;
branches;
next	1.101;

1.101
date	2008.12.16.07.57.28;	author guenther;	state Exp;
branches;
next	1.100;

1.100
date	2008.10.03.04.22.37;	author guenther;	state Exp;
branches;
next	1.99;

1.99
date	2008.06.10.20.41.52;	author hshoexer;	state Exp;
branches;
next	1.98;

1.98
date	2008.05.22.17.04.59;	author thib;	state Exp;
branches;
next	1.97;

1.97
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.96;

1.96
date	2007.11.19.17.47.47;	author millert;	state Exp;
branches;
next	1.95;

1.95
date	2007.09.01.15.14.44;	author martin;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.30.07.42.52;	author moritz;	state Exp;
branches;
next	1.93;

1.93
date	2007.05.29.00.26.29;	author jcs;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.29.00.03.18;	author tedu;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.08.14.16.36;	author miod;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.08.11.16.31;	author art;	state Exp;
branches;
next	1.89;

1.89
date	2007.04.03.08.05.43;	author art;	state Exp;
branches;
next	1.88;

1.88
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.87;

1.87
date	2007.02.06.18.42.37;	author art;	state Exp;
branches;
next	1.86;

1.86
date	2007.01.17.23.08.18;	author art;	state Exp;
branches;
next	1.85;

1.85
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.84;

1.84
date	2006.06.15.20.08.01;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2006.06.07.18.58.39;	author miod;	state Exp;
branches;
next	1.82;

1.82
date	2006.03.04.10.22.20;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2006.02.20.19.39.11;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2006.01.18.23.42.12;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2005.12.22.06.58.20;	author tedu;	state Exp;
branches;
next	1.78;

1.78
date	2005.12.03.18.09.08;	author tedu;	state Exp;
branches;
next	1.77;

1.77
date	2005.11.28.00.14.29;	author jsg;	state Exp;
branches;
next	1.76;

1.76
date	2005.06.17.22.33.34;	author niklas;	state Exp;
branches;
next	1.75;

1.75
date	2005.05.29.03.20.41;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.73;

1.73
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2004.07.04.13.35.01;	author niklas;	state Exp;
branches;
next	1.71;

1.71
date	2004.06.13.21.49.26;	author niklas;	state Exp;
branches;
next	1.70;

1.70
date	2004.04.06.17.24.11;	author mickey;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.14.05.23.25;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2003.09.01.18.06.03;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.66;

1.66
date	2003.08.04.16.27.01;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2003.08.03.19.25.49;	author millert;	state Exp;
branches;
next	1.64;

1.64
date	2003.07.21.22.44.50;	author tedu;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2003.05.03.21.14.59;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2002.10.01.17.33.39;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2002.07.14.02.44.30;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.11.08.19.17;	author art;	state Exp;
branches;
next	1.58;

1.58
date	2002.05.08.19.24.42;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2002.04.18.08.25.04;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2002.03.14.01.27.04;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2002.02.22.19.19.28;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2002.01.31.02.12.18;	author weingart;	state Exp;
branches;
next	1.53;

1.53
date	2002.01.23.00.39.47;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2002.01.19.19.00.14;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2002.01.07.16.16.32;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2001.09.21.21.36.48;	author deraadt;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2001.09.20.23.30.29;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2001.08.09.14.44.42;	author niklas;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.27.04.49.44;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.22.14.14.09;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.18.09.00.24;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2001.05.16.05.07.52;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2001.04.02.21.43.12;	author niklas;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2001.02.19.10.21.48;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2000.11.16.20.02.17;	author provos;	state Exp;
branches;
next	1.39;

1.39
date	2000.11.10.18.15.47;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2000.06.05.11.02.50;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2000.04.21.15.47.27;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2000.03.03.11.31.43;	author art;	state Exp;
branches;
next	1.35;

1.35
date	99.11.05.01.18.01;	author mickey;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	99.07.18.17.05.13;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	99.02.26.05.10.40;	author art;	state Exp;
branches;
next	1.32;

1.32
date	99.02.18.00.01.38;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	99.02.17.23.27.38;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	98.06.07.20.17.25;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	98.05.30.20.54.42;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	98.05.18.21.41.45;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.05.17.19.38.43;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.02.20.14.46.18;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	98.01.09.16.41.09;	author csapuntz;	state Exp;
branches;
next	1.24;

1.24
date	98.01.09.16.33.48;	author csapuntz;	state Exp;
branches;
next	1.23;

1.23
date	97.12.08.21.25.36;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	97.11.06.05.58.18;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	97.10.06.20.19.56;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	97.10.06.15.12.21;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	97.09.15.05.46.13;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.09.12.02.47.34;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.08.31.20.42.18;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.02.01.21.49.41;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.01.27.22.48.36;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.01.27.01.15.32;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.10.27.08.01.26;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	96.10.27.04.56.51;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	96.10.27.03.48.29;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	96.10.27.02.26.55;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	96.10.26.07.28.13;	author tholo;	state Exp;
branches;
next	1.8;

1.8
date	96.10.20.07.37.22;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.10.18.06.08.40;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.09.03.11.01.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.09.03.05.01.45;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.02.13.12.13;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.17.19.54;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.05.16.18.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.44;	author deraadt;	state Exp;
branches;
next	;

1.35.2.1
date	2000.03.24.09.09.24;	author niklas;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	2001.05.14.22.32.41;	author niklas;	state Exp;
branches;
next	1.35.2.3;

1.35.2.3
date	2001.07.04.10.48.25;	author niklas;	state Exp;
branches;
next	1.35.2.4;

1.35.2.4
date	2001.10.31.03.26.29;	author nate;	state Exp;
branches;
next	1.35.2.5;

1.35.2.5
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.35.2.6;

1.35.2.6
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.35.2.7;

1.35.2.7
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.35.2.8;

1.35.2.8
date	2003.03.28.00.41.26;	author niklas;	state Exp;
branches;
next	1.35.2.9;

1.35.2.9
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.35.2.10;

1.35.2.10
date	2003.05.15.04.08.02;	author niklas;	state Exp;
branches;
next	1.35.2.11;

1.35.2.11
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.35.2.12;

1.35.2.12
date	2004.02.19.10.56.37;	author niklas;	state Exp;
branches;
next	1.35.2.13;

1.35.2.13
date	2004.06.05.23.13.01;	author niklas;	state Exp;
branches;
next	1.35.2.14;

1.35.2.14
date	2004.06.05.23.18.25;	author tedu;	state Exp;
branches;
next	1.35.2.15;

1.35.2.15
date	2004.06.06.21.46.12;	author tedu;	state Exp;
branches;
next	1.35.2.16;

1.35.2.16
date	2004.06.06.22.27.47;	author niklas;	state Exp;
branches;
next	;

1.42.2.1
date	2002.02.21.00.10.38;	author miod;	state Exp;
branches;
next	;

1.49.2.1
date	2002.02.21.04.14.57;	author jason;	state Exp;
branches;
next	;

1.50.2.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.50.2.2;

1.50.2.2
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.50.2.3;

1.50.2.3
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.50.2.4;

1.50.2.4
date	2003.05.19.22.31.10;	author tedu;	state Exp;
branches;
next	;

1.183.4.1
date	2016.07.14.02.46.11;	author tedu;	state Exp;
branches;
next	;
commitid	kzYtCgZfgZewqezu;

1.192.2.1
date	2016.07.14.02.45.23;	author tedu;	state Exp;
branches;
next	;
commitid	iy5C78vcnVfjlmst;


desc
@@


1.209
log
@Provide mips64 with kernel-facing TCB_{GET,SET} macros that store it
in struct mdproc.  With that, all archs have those and the __HAVE_MD_TCB
macro can be unifdef'ed as always defined.

ok kettenis@@ visa@@ jsing@@
@
text
@/*	$OpenBSD: kern_sig.c,v 1.208 2017/01/24 00:58:55 mpi Exp $	*/
/*	$NetBSD: kern_sig.c,v 1.54 1996/04/22 01:38:32 christos Exp $	*/

/*
 * Copyright (c) 1997 Theo de Raadt. All rights reserved. 
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_sig.c	8.7 (Berkeley) 4/18/94
 */

#define	SIGPROP		/* include signal properties table */
#include <sys/param.h>
#include <sys/signalvar.h>
#include <sys/resourcevar.h>
#include <sys/queue.h>
#include <sys/namei.h>
#include <sys/vnode.h>
#include <sys/event.h>
#include <sys/proc.h>
#include <sys/systm.h>
#include <sys/acct.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/kernel.h>
#include <sys/wait.h>
#include <sys/ktrace.h>
#include <sys/stat.h>
#include <sys/core.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/ptrace.h>
#include <sys/sched.h>
#include <sys/user.h>
#include <sys/syslog.h>
#include <sys/pledge.h>

#include <sys/mount.h>
#include <sys/syscallargs.h>

#include <uvm/uvm_extern.h>
#include <machine/tcb.h>

int	filt_sigattach(struct knote *kn);
void	filt_sigdetach(struct knote *kn);
int	filt_signal(struct knote *kn, long hint);

struct filterops sig_filtops =
	{ 0, filt_sigattach, filt_sigdetach, filt_signal };

void proc_stop(struct proc *p, int);
void proc_stop_sweep(void *);
struct timeout proc_stop_to;

int cansignal(struct proc *, struct process *, int);

struct pool sigacts_pool;	/* memory pool for sigacts structures */

/*
 * Can thread p, send the signal signum to process qr?
 */
int
cansignal(struct proc *p, struct process *qr, int signum)
{
	struct process *pr = p->p_p;
	struct ucred *uc = p->p_ucred;
	struct ucred *quc = qr->ps_ucred;

	if (uc->cr_uid == 0)
		return (1);		/* root can always signal */

	if (pr == qr)
		return (1);		/* process can always signal itself */

	/* optimization: if the same creds then the tests below will pass */
	if (uc == quc)
		return (1);

	if (signum == SIGCONT && qr->ps_session == pr->ps_session)
		return (1);		/* SIGCONT in session */

	/*
	 * Using kill(), only certain signals can be sent to setugid
	 * child processes
	 */
	if (qr->ps_flags & PS_SUGID) {
		switch (signum) {
		case 0:
		case SIGKILL:
		case SIGINT:
		case SIGTERM:
		case SIGALRM:
		case SIGSTOP:
		case SIGTTIN:
		case SIGTTOU:
		case SIGTSTP:
		case SIGHUP:
		case SIGUSR1:
		case SIGUSR2:
			if (uc->cr_ruid == quc->cr_ruid ||
			    uc->cr_uid == quc->cr_ruid)
				return (1);
		}
		return (0);
	}

	if (uc->cr_ruid == quc->cr_ruid ||
	    uc->cr_ruid == quc->cr_svuid ||
	    uc->cr_uid == quc->cr_ruid ||
	    uc->cr_uid == quc->cr_svuid)
		return (1);
	return (0);
}

/*
 * Initialize signal-related data structures.
 */
void
signal_init(void)
{
	timeout_set(&proc_stop_to, proc_stop_sweep, NULL);

	pool_init(&sigacts_pool, sizeof(struct sigacts), 0, IPL_NONE,
	    PR_WAITOK, "sigapl", NULL);
}

/*
 * Create an initial sigacts structure, using the same signal state
 * as p.
 */
struct sigacts *
sigactsinit(struct process *pr)
{
	struct sigacts *ps;

	ps = pool_get(&sigacts_pool, PR_WAITOK);
	memcpy(ps, pr->ps_sigacts, sizeof(struct sigacts));
	ps->ps_refcnt = 1;
	return (ps);
}

/*
 * Share a sigacts structure.
 */
struct sigacts *
sigactsshare(struct process *pr)
{
	struct sigacts *ps = pr->ps_sigacts;

	ps->ps_refcnt++;
	return ps;
}

/*
 * Initialize a new sigaltstack structure.
 */
void
sigstkinit(struct sigaltstack *ss)
{
	ss->ss_flags = SS_DISABLE;
	ss->ss_size = 0;
	ss->ss_sp = 0;
}

/*
 * Make this process not share its sigacts, maintaining all
 * signal state.
 */
void
sigactsunshare(struct process *pr)
{
	struct sigacts *newps;

	if (pr->ps_sigacts->ps_refcnt == 1)
		return;

	newps = sigactsinit(pr);
	sigactsfree(pr);
	pr->ps_sigacts = newps;
}

/*
 * Release a sigacts structure.
 */
void
sigactsfree(struct process *pr)
{
	struct sigacts *ps = pr->ps_sigacts;

	if (--ps->ps_refcnt > 0)
		return;

	pr->ps_sigacts = NULL;

	pool_put(&sigacts_pool, ps);
}

int
sys_sigaction(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigaction_args /* {
		syscallarg(int) signum;
		syscallarg(const struct sigaction *) nsa;
		syscallarg(struct sigaction *) osa;
	} */ *uap = v;
	struct sigaction vec;
#ifdef KTRACE
	struct sigaction ovec;
#endif
	struct sigaction *sa;
	const struct sigaction *nsa;
	struct sigaction *osa;
	struct sigacts *ps = p->p_p->ps_sigacts;
	int signum;
	int bit, error;

	signum = SCARG(uap, signum);
	nsa = SCARG(uap, nsa);
	osa = SCARG(uap, osa);

	if (signum <= 0 || signum >= NSIG ||
	    (nsa && (signum == SIGKILL || signum == SIGSTOP)))
		return (EINVAL);
	sa = &vec;
	if (osa) {
		sa->sa_handler = ps->ps_sigact[signum];
		sa->sa_mask = ps->ps_catchmask[signum];
		bit = sigmask(signum);
		sa->sa_flags = 0;
		if ((ps->ps_sigonstack & bit) != 0)
			sa->sa_flags |= SA_ONSTACK;
		if ((ps->ps_sigintr & bit) == 0)
			sa->sa_flags |= SA_RESTART;
		if ((ps->ps_sigreset & bit) != 0)
			sa->sa_flags |= SA_RESETHAND;
		if ((ps->ps_siginfo & bit) != 0)
			sa->sa_flags |= SA_SIGINFO;
		if (signum == SIGCHLD) {
			if ((ps->ps_flags & SAS_NOCLDSTOP) != 0)
				sa->sa_flags |= SA_NOCLDSTOP;
			if ((ps->ps_flags & SAS_NOCLDWAIT) != 0)
				sa->sa_flags |= SA_NOCLDWAIT;
		}
		if ((sa->sa_mask & bit) == 0)
			sa->sa_flags |= SA_NODEFER;
		sa->sa_mask &= ~bit;
		error = copyout(sa, osa, sizeof (vec));
		if (error)
			return (error);
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ovec = vec;
#endif
	}
	if (nsa) {
		error = copyin(nsa, sa, sizeof (vec));
		if (error)
			return (error);
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrsigaction(p, sa);
#endif
		setsigvec(p, signum, sa);
	}
#ifdef KTRACE
	if (osa && KTRPOINT(p, KTR_STRUCT))
		ktrsigaction(p, &ovec);
#endif
	return (0);
}

void
setsigvec(struct proc *p, int signum, struct sigaction *sa)
{
	struct sigacts *ps = p->p_p->ps_sigacts;
	int bit;
	int s;

	bit = sigmask(signum);
	/*
	 * Change setting atomically.
	 */
	s = splhigh();
	ps->ps_sigact[signum] = sa->sa_handler;
	if ((sa->sa_flags & SA_NODEFER) == 0)
		sa->sa_mask |= sigmask(signum);
	ps->ps_catchmask[signum] = sa->sa_mask &~ sigcantmask;
	if (signum == SIGCHLD) {
		if (sa->sa_flags & SA_NOCLDSTOP)
			atomic_setbits_int(&ps->ps_flags, SAS_NOCLDSTOP);
		else
			atomic_clearbits_int(&ps->ps_flags, SAS_NOCLDSTOP);
		/*
		 * If the SA_NOCLDWAIT flag is set or the handler
		 * is SIG_IGN we reparent the dying child to PID 1
		 * (init) which will reap the zombie.  Because we use
		 * init to do our dirty work we never set SAS_NOCLDWAIT
		 * for PID 1.
		 * XXX exit1 rework means this is unnecessary?
		 */
		if (initprocess->ps_sigacts != ps &&
		    ((sa->sa_flags & SA_NOCLDWAIT) ||
		    sa->sa_handler == SIG_IGN))
			atomic_setbits_int(&ps->ps_flags, SAS_NOCLDWAIT);
		else
			atomic_clearbits_int(&ps->ps_flags, SAS_NOCLDWAIT);
	}
	if ((sa->sa_flags & SA_RESETHAND) != 0)
		ps->ps_sigreset |= bit;
	else
		ps->ps_sigreset &= ~bit;
	if ((sa->sa_flags & SA_SIGINFO) != 0)
		ps->ps_siginfo |= bit;
	else
		ps->ps_siginfo &= ~bit;
	if ((sa->sa_flags & SA_RESTART) == 0)
		ps->ps_sigintr |= bit;
	else
		ps->ps_sigintr &= ~bit;
	if ((sa->sa_flags & SA_ONSTACK) != 0)
		ps->ps_sigonstack |= bit;
	else
		ps->ps_sigonstack &= ~bit;
	/*
	 * Set bit in ps_sigignore for signals that are set to SIG_IGN,
	 * and for signals set to SIG_DFL where the default is to ignore.
	 * However, don't put SIGCONT in ps_sigignore,
	 * as we have to restart the process.
	 */
	if (sa->sa_handler == SIG_IGN ||
	    (sigprop[signum] & SA_IGNORE && sa->sa_handler == SIG_DFL)) {
		atomic_clearbits_int(&p->p_siglist, bit);	
		if (signum != SIGCONT)
			ps->ps_sigignore |= bit;	/* easier in psignal */
		ps->ps_sigcatch &= ~bit;
	} else {
		ps->ps_sigignore &= ~bit;
		if (sa->sa_handler == SIG_DFL)
			ps->ps_sigcatch &= ~bit;
		else
			ps->ps_sigcatch |= bit;
	}
	splx(s);
}

/*
 * Initialize signal state for process 0;
 * set to ignore signals that are ignored by default.
 */
void
siginit(struct process *pr)
{
	struct sigacts *ps = pr->ps_sigacts;
	int i;

	for (i = 0; i < NSIG; i++)
		if (sigprop[i] & SA_IGNORE && i != SIGCONT)
			ps->ps_sigignore |= sigmask(i);
	ps->ps_flags = SAS_NOCLDWAIT | SAS_NOCLDSTOP;
}

/*
 * Reset signals for an exec by the specified thread.
 */
void
execsigs(struct proc *p)
{
	struct sigacts *ps;
	int nc, mask;

	sigactsunshare(p->p_p);
	ps = p->p_p->ps_sigacts;

	/*
	 * Reset caught signals.  Held signals remain held
	 * through p_sigmask (unless they were caught,
	 * and are now ignored by default).
	 */
	while (ps->ps_sigcatch) {
		nc = ffs((long)ps->ps_sigcatch);
		mask = sigmask(nc);
		ps->ps_sigcatch &= ~mask;
		if (sigprop[nc] & SA_IGNORE) {
			if (nc != SIGCONT)
				ps->ps_sigignore |= mask;
			atomic_clearbits_int(&p->p_siglist, mask);
		}
		ps->ps_sigact[nc] = SIG_DFL;
	}
	/*
	 * Reset stack state to the user stack.
	 * Clear set of signals caught on the signal stack.
	 */
	sigstkinit(&p->p_sigstk);
	ps->ps_flags &= ~SAS_NOCLDWAIT;
	if (ps->ps_sigact[SIGCHLD] == SIG_IGN)
		ps->ps_sigact[SIGCHLD] = SIG_DFL;
}

/*
 * Manipulate signal mask.
 * Note that we receive new mask, not pointer,
 * and return old mask as return value;
 * the library stub does the rest.
 */
int
sys_sigprocmask(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigprocmask_args /* {
		syscallarg(int) how;
		syscallarg(sigset_t) mask;
	} */ *uap = v;
	int error = 0;
	sigset_t mask;

	*retval = p->p_sigmask;
	mask = SCARG(uap, mask) &~ sigcantmask;

	switch (SCARG(uap, how)) {
	case SIG_BLOCK:
		atomic_setbits_int(&p->p_sigmask, mask);
		break;
	case SIG_UNBLOCK:
		atomic_clearbits_int(&p->p_sigmask, mask);
		break;
	case SIG_SETMASK:
		p->p_sigmask = mask;
		break;
	default:
		error = EINVAL;
		break;
	}
	return (error);
}

int
sys_sigpending(struct proc *p, void *v, register_t *retval)
{

	*retval = p->p_siglist;
	return (0);
}

/*
 * Temporarily replace calling proc's signal mask for the duration of a
 * system call.  Original signal mask will be restored by userret().
 */
void
dosigsuspend(struct proc *p, sigset_t newmask)
{
	KASSERT(p == curproc);

	p->p_oldmask = p->p_sigmask;
	atomic_setbits_int(&p->p_flag, P_SIGSUSPEND);
	p->p_sigmask = newmask;
}

/*
 * Suspend process until signal, providing mask to be set
 * in the meantime.  Note nonstandard calling convention:
 * libc stub passes mask, not pointer, to save a copyin.
 */
int
sys_sigsuspend(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigsuspend_args /* {
		syscallarg(int) mask;
	} */ *uap = v;
	struct process *pr = p->p_p;
	struct sigacts *ps = pr->ps_sigacts;

	dosigsuspend(p, SCARG(uap, mask) &~ sigcantmask);
	while (tsleep(ps, PPAUSE|PCATCH, "pause", 0) == 0)
		/* void */;
	/* always return EINTR rather than ERESTART... */
	return (EINTR);
}

int
sigonstack(size_t stack)
{
	const struct sigaltstack *ss = &curproc->p_sigstk;

	return (ss->ss_flags & SS_DISABLE ? 0 :
	    (stack - (size_t)ss->ss_sp < ss->ss_size));
}

int
sys_sigaltstack(struct proc *p, void *v, register_t *retval)
{
	struct sys_sigaltstack_args /* {
		syscallarg(const struct sigaltstack *) nss;
		syscallarg(struct sigaltstack *) oss;
	} */ *uap = v;
	struct sigaltstack ss;
	const struct sigaltstack *nss;
	struct sigaltstack *oss;
	int onstack = sigonstack(PROC_STACK(p));
	int error;

	nss = SCARG(uap, nss);
	oss = SCARG(uap, oss);

	if (oss != NULL) {
		ss = p->p_sigstk;
		if (onstack)
			ss.ss_flags |= SS_ONSTACK;
		if ((error = copyout(&ss, oss, sizeof(ss))))
			return (error);
	}
	if (nss == NULL)
		return (0);
	error = copyin(nss, &ss, sizeof(ss));
	if (error)
		return (error);
	if (onstack)
		return (EPERM);
	if (ss.ss_flags & ~SS_DISABLE)
		return (EINVAL);
	if (ss.ss_flags & SS_DISABLE) {
		p->p_sigstk.ss_flags = ss.ss_flags;
		return (0);
	}
	if (ss.ss_size < MINSIGSTKSZ)
		return (ENOMEM);
	p->p_sigstk = ss;
	return (0);
}

int
sys_kill(struct proc *cp, void *v, register_t *retval)
{
	struct sys_kill_args /* {
		syscallarg(int) pid;
		syscallarg(int) signum;
	} */ *uap = v;
	struct process *pr;
	int pid = SCARG(uap, pid);
	int signum = SCARG(uap, signum);
	int error;
	int zombie = 0;

	if ((error = pledge_kill(cp, pid)) != 0)
		return (error);
	if (((u_int)signum) >= NSIG)
		return (EINVAL);
	if (pid > 0) {
		if ((pr = prfind(pid)) == NULL) {
			if ((pr = zombiefind(pid)) == NULL)
				return (ESRCH);
			else
				zombie = 1;
		}
		if (!cansignal(cp, pr, signum))
			return (EPERM);

		/* kill single process */
		if (signum && !zombie)
			prsignal(pr, signum);
		return (0);
	}
	switch (pid) {
	case -1:		/* broadcast signal */
		return (killpg1(cp, signum, 0, 1));
	case 0:			/* signal own process group */
		return (killpg1(cp, signum, 0, 0));
	default:		/* negative explicit process group */
		return (killpg1(cp, signum, -pid, 0));
	}
}

int
sys_thrkill(struct proc *cp, void *v, register_t *retval)
{
	struct sys_thrkill_args /* {
		syscallarg(pid_t) tid;
		syscallarg(int) signum;
		syscallarg(void *) tcb;
	} */ *uap = v;
	struct proc *p;
	int tid = SCARG(uap, tid);
	int signum = SCARG(uap, signum);
	void *tcb;

	if (((u_int)signum) >= NSIG)
		return (EINVAL);
	if (tid > THREAD_PID_OFFSET) {
		if ((p = tfind(tid - THREAD_PID_OFFSET)) == NULL)
			return (ESRCH);

		/* can only kill threads in the same process */
		if (p->p_p != cp->p_p)
			return (ESRCH);
	} else if (tid == 0)
		p = cp;
	else
		return (EINVAL);

	/* optionally require the target thread to have the given tcb addr */
	tcb = SCARG(uap, tcb);
	if (tcb != NULL && tcb != TCB_GET(p))
		return (ESRCH);

	if (signum)
		ptsignal(p, signum, STHREAD);
	return (0);
}

/*
 * Common code for kill process group/broadcast kill.
 * cp is calling process.
 */
int
killpg1(struct proc *cp, int signum, int pgid, int all)
{
	struct process *pr;
	struct pgrp *pgrp;
	int nfound = 0;

	if (all)
		/* 
		 * broadcast
		 */
		LIST_FOREACH(pr, &allprocess, ps_list) {
			if (pr->ps_pid <= 1 ||
			    pr->ps_flags & (PS_SYSTEM | PS_NOBROADCASTKILL) ||
			    pr == cp->p_p || !cansignal(cp, pr, signum))
				continue;
			nfound++;
			if (signum)
				prsignal(pr, signum);
		}
	else {
		if (pgid == 0)
			/*
			 * zero pgid means send to my process group.
			 */
			pgrp = cp->p_p->ps_pgrp;
		else {
			pgrp = pgfind(pgid);
			if (pgrp == NULL)
				return (ESRCH);
		}
		LIST_FOREACH(pr, &pgrp->pg_members, ps_pglist) {
			if (pr->ps_pid <= 1 || pr->ps_flags & PS_SYSTEM ||
			    !cansignal(cp, pr, signum))
				continue;
			nfound++;
			if (signum)
				prsignal(pr, signum);
		}
	}
	return (nfound ? 0 : ESRCH);
}

#define CANDELIVER(uid, euid, pr) \
	(euid == 0 || \
	(uid) == (pr)->ps_ucred->cr_ruid || \
	(uid) == (pr)->ps_ucred->cr_svuid || \
	(uid) == (pr)->ps_ucred->cr_uid || \
	(euid) == (pr)->ps_ucred->cr_ruid || \
	(euid) == (pr)->ps_ucred->cr_svuid || \
	(euid) == (pr)->ps_ucred->cr_uid)

/*
 * Deliver signum to pgid, but first check uid/euid against each
 * process and see if it is permitted.
 */
void
csignal(pid_t pgid, int signum, uid_t uid, uid_t euid)
{
	struct pgrp *pgrp;
	struct process *pr;

	if (pgid == 0)
		return;
	if (pgid < 0) {
		pgid = -pgid;
		if ((pgrp = pgfind(pgid)) == NULL)
			return;
		LIST_FOREACH(pr, &pgrp->pg_members, ps_pglist)
			if (CANDELIVER(uid, euid, pr))
				prsignal(pr, signum);
	} else {
		if ((pr = prfind(pgid)) == NULL)
			return;
		if (CANDELIVER(uid, euid, pr))
			prsignal(pr, signum);
	}
}

/*
 * Send a signal to a process group.
 */
void
gsignal(int pgid, int signum)
{
	struct pgrp *pgrp;

	if (pgid && (pgrp = pgfind(pgid)))
		pgsignal(pgrp, signum, 0);
}

/*
 * Send a signal to a process group.  If checktty is 1,
 * limit to members which have a controlling terminal.
 */
void
pgsignal(struct pgrp *pgrp, int signum, int checkctty)
{
	struct process *pr;

	if (pgrp)
		LIST_FOREACH(pr, &pgrp->pg_members, ps_pglist)
			if (checkctty == 0 || pr->ps_flags & PS_CONTROLT)
				prsignal(pr, signum);
}

/*
 * Send a signal caused by a trap to the current thread
 * If it will be caught immediately, deliver it with correct code.
 * Otherwise, post it normally.
 */
void
trapsignal(struct proc *p, int signum, u_long trapno, int code,
    union sigval sigval)
{
	struct process *pr = p->p_p;
	struct sigacts *ps = pr->ps_sigacts;
	int mask;

	mask = sigmask(signum);
	if ((pr->ps_flags & PS_TRACED) == 0 &&
	    (ps->ps_sigcatch & mask) != 0 &&
	    (p->p_sigmask & mask) == 0) {
#ifdef KTRACE
		if (KTRPOINT(p, KTR_PSIG)) {
			siginfo_t si;

			initsiginfo(&si, signum, trapno, code, sigval);
			ktrpsig(p, signum, ps->ps_sigact[signum],
			    p->p_sigmask, code, &si);
		}
#endif
		p->p_ru.ru_nsignals++;
		(*pr->ps_emul->e_sendsig)(ps->ps_sigact[signum], signum,
		    p->p_sigmask, trapno, code, sigval);
		atomic_setbits_int(&p->p_sigmask, ps->ps_catchmask[signum]);
		if ((ps->ps_sigreset & mask) != 0) {
			ps->ps_sigcatch &= ~mask;
			if (signum != SIGCONT && sigprop[signum] & SA_IGNORE)
				ps->ps_sigignore |= mask;
			ps->ps_sigact[signum] = SIG_DFL;
		}
	} else {
		p->p_sisig = signum;
		p->p_sitrapno = trapno;	/* XXX for core dump/debugger */
		p->p_sicode = code;
		p->p_sigval = sigval;

		/*
		 * Signals like SIGBUS and SIGSEGV should not, when
		 * generated by the kernel, be ignorable or blockable.
		 * If it is and we're not being traced, then just kill
		 * the process.
		 */
		if ((pr->ps_flags & PS_TRACED) == 0 &&
		    (sigprop[signum] & SA_KILL) &&
		    ((p->p_sigmask & mask) || (ps->ps_sigignore & mask)))
			sigexit(p, signum);
		ptsignal(p, signum, STHREAD);
	}
}

/*
 * Send the signal to the process.  If the signal has an action, the action
 * is usually performed by the target process rather than the caller; we add
 * the signal to the set of pending signals for the process.
 *
 * Exceptions:
 *   o When a stop signal is sent to a sleeping process that takes the
 *     default action, the process is stopped without awakening it.
 *   o SIGCONT restarts stopped processes (or puts them back to sleep)
 *     regardless of the signal action (eg, blocked or ignored).
 *
 * Other ignored signals are discarded immediately.
 */
void
psignal(struct proc *p, int signum)
{
	ptsignal(p, signum, SPROCESS);
}

/*
 * type = SPROCESS	process signal, can be diverted (sigwait())
 *	XXX if blocked in all threads, mark as pending in struct process
 * type = STHREAD	thread signal, but should be propagated if unhandled
 * type = SPROPAGATED	propagated to this thread, so don't propagate again
 */
void
ptsignal(struct proc *p, int signum, enum signal_type type)
{
	int s, prop;
	sig_t action;
	int mask;
	struct process *pr = p->p_p;
	struct proc *q;
	int wakeparent = 0;

#ifdef DIAGNOSTIC
	if ((u_int)signum >= NSIG || signum == 0)
		panic("psignal signal number");
#endif

	/* Ignore signal if the target process is exiting */
	if (pr->ps_flags & PS_EXITING)
		return;

	mask = sigmask(signum);

	if (type == SPROCESS) {
		/* Accept SIGKILL to coredumping processes */
		if (pr->ps_flags & PS_COREDUMP && signum == SIGKILL) {
			if (pr->ps_single != NULL)
				p = pr->ps_single;
			atomic_setbits_int(&p->p_siglist, mask);
			return;
		}

		/*
		 * If the current thread can process the signal
		 * immediately (it's unblocked) then have it take it.
		 */
		q = curproc;
		if (q != NULL && q->p_p == pr && (q->p_flag & P_WEXIT) == 0 &&
		    (q->p_sigmask & mask) == 0)
			p = q;
		else {
			/*
			 * A process-wide signal can be diverted to a
			 * different thread that's in sigwait() for this
			 * signal.  If there isn't such a thread, then
			 * pick a thread that doesn't have it blocked so
			 * that the stop/kill consideration isn't
			 * delayed.  Otherwise, mark it pending on the
			 * main thread.
			 */
			TAILQ_FOREACH(q, &pr->ps_threads, p_thr_link) {
				/* ignore exiting threads */
				if (q->p_flag & P_WEXIT)
					continue;

				/* skip threads that have the signal blocked */
				if ((q->p_sigmask & mask) != 0)
					continue;

				/* okay, could send to this thread */
				p = q;

				/*
				 * sigsuspend, sigwait, ppoll/pselect, etc?
				 * Definitely go to this thread, as it's
				 * already blocked in the kernel.
				 */
				if (q->p_flag & P_SIGSUSPEND)
					break;
			}
		}
	}

	if (type != SPROPAGATED)
		KNOTE(&pr->ps_klist, NOTE_SIGNAL | signum);

	prop = sigprop[signum];

	/*
	 * If proc is traced, always give parent a chance.
	 */
	if (pr->ps_flags & PS_TRACED) {
		action = SIG_DFL;
		atomic_setbits_int(&p->p_siglist, mask);
	} else {
		/*
		 * If the signal is being ignored,
		 * then we forget about it immediately.
		 * (Note: we don't set SIGCONT in ps_sigignore,
		 * and if it is set to SIG_IGN,
		 * action will be SIG_DFL here.)
		 */
		if (pr->ps_sigacts->ps_sigignore & mask)
			return;
		if (p->p_sigmask & mask) {
			action = SIG_HOLD;
		} else if (pr->ps_sigacts->ps_sigcatch & mask) {
			action = SIG_CATCH;
		} else {
			action = SIG_DFL;

			if (prop & SA_KILL && pr->ps_nice > NZERO)
				 pr->ps_nice = NZERO;

			/*
			 * If sending a tty stop signal to a member of an
			 * orphaned process group, discard the signal here if
			 * the action is default; don't stop the process below
			 * if sleeping, and don't clear any pending SIGCONT.
			 */
			if (prop & SA_TTYSTOP && pr->ps_pgrp->pg_jobc == 0)
				return;
		}

		atomic_setbits_int(&p->p_siglist, mask);
	}

	if (prop & SA_CONT)
		atomic_clearbits_int(&p->p_siglist, stopsigmask);

	if (prop & SA_STOP) {
		atomic_clearbits_int(&p->p_siglist, contsigmask);
		atomic_clearbits_int(&p->p_flag, P_CONTINUED);
	}

	/*
	 * XXX delay processing of SA_STOP signals unless action == SIG_DFL?
	 */
	if (prop & (SA_CONT | SA_STOP) && type != SPROPAGATED)
		TAILQ_FOREACH(q, &pr->ps_threads, p_thr_link)
			if (q != p)
				ptsignal(q, signum, SPROPAGATED);

	/*
	 * Defer further processing for signals which are held,
	 * except that stopped processes must be continued by SIGCONT.
	 */
	if (action == SIG_HOLD && ((prop & SA_CONT) == 0 || p->p_stat != SSTOP))
		return;

	SCHED_LOCK(s);

	switch (p->p_stat) {

	case SSLEEP:
		/*
		 * If process is sleeping uninterruptibly
		 * we can't interrupt the sleep... the signal will
		 * be noticed when the process returns through
		 * trap() or syscall().
		 */
		if ((p->p_flag & P_SINTR) == 0)
			goto out;
		/*
		 * Process is sleeping and traced... make it runnable
		 * so it can discover the signal in issignal() and stop
		 * for the parent.
		 */
		if (pr->ps_flags & PS_TRACED)
			goto run;
		/*
		 * If SIGCONT is default (or ignored) and process is
		 * asleep, we are finished; the process should not
		 * be awakened.
		 */
		if ((prop & SA_CONT) && action == SIG_DFL) {
			atomic_clearbits_int(&p->p_siglist, mask);
			goto out;
		}
		/*
		 * When a sleeping process receives a stop
		 * signal, process immediately if possible.
		 */
		if ((prop & SA_STOP) && action == SIG_DFL) {
			/*
			 * If a child holding parent blocked,
			 * stopping could cause deadlock.
			 */
			if (pr->ps_flags & PS_PPWAIT)
				goto out;
			atomic_clearbits_int(&p->p_siglist, mask);
			p->p_xstat = signum;
			proc_stop(p, 0);
			goto out;
		}
		/*
		 * All other (caught or default) signals
		 * cause the process to run.
		 */
		goto runfast;
		/*NOTREACHED*/

	case SSTOP:
		/*
		 * If traced process is already stopped,
		 * then no further action is necessary.
		 */
		if (pr->ps_flags & PS_TRACED)
			goto out;

		/*
		 * Kill signal always sets processes running.
		 */
		if (signum == SIGKILL) {
			atomic_clearbits_int(&p->p_flag, P_SUSPSIG);
			goto runfast;
		}

		if (prop & SA_CONT) {
			/*
			 * If SIGCONT is default (or ignored), we continue the
			 * process but don't leave the signal in p_siglist, as
			 * it has no further action.  If SIGCONT is held, we
			 * continue the process and leave the signal in
			 * p_siglist.  If the process catches SIGCONT, let it
			 * handle the signal itself.  If it isn't waiting on
			 * an event, then it goes back to run state.
			 * Otherwise, process goes back to sleep state.
			 */
			atomic_setbits_int(&p->p_flag, P_CONTINUED);
			atomic_clearbits_int(&p->p_flag, P_SUSPSIG);
			wakeparent = 1;
			if (action == SIG_DFL)
				atomic_clearbits_int(&p->p_siglist, mask);
			if (action == SIG_CATCH)
				goto runfast;
			if (p->p_wchan == 0)
				goto run;
			p->p_stat = SSLEEP;
			goto out;
		}

		if (prop & SA_STOP) {
			/*
			 * Already stopped, don't need to stop again.
			 * (If we did the shell could get confused.)
			 */
			atomic_clearbits_int(&p->p_siglist, mask);
			goto out;
		}

		/*
		 * If process is sleeping interruptibly, then simulate a
		 * wakeup so that when it is continued, it will be made
		 * runnable and can look at the signal.  But don't make
		 * the process runnable, leave it stopped.
		 */
		if (p->p_wchan && p->p_flag & P_SINTR)
			unsleep(p);
		goto out;

	case SONPROC:
		signotify(p);
		/* FALLTHROUGH */
	default:
		/*
		 * SRUN, SIDL, SDEAD do nothing with the signal,
		 * other than kicking ourselves if we are running.
		 * It will either never be noticed, or noticed very soon.
		 */
		goto out;
	}
	/*NOTREACHED*/

runfast:
	/*
	 * Raise priority to at least PUSER.
	 */
	if (p->p_priority > PUSER)
		p->p_priority = PUSER;
run:
	setrunnable(p);
out:
	SCHED_UNLOCK(s);
	if (wakeparent)
		wakeup(pr->ps_pptr);
}

/*
 * If the current process has received a signal (should be caught or cause
 * termination, should interrupt current syscall), return the signal number.
 * Stop signals with default action are processed immediately, then cleared;
 * they aren't returned.  This is checked after each entry to the system for
 * a syscall or trap (though this can usually be done without calling issignal
 * by checking the pending signal masks in the CURSIG macro.) The normal call
 * sequence is
 *
 *	while (signum = CURSIG(curproc))
 *		postsig(signum);
 *
 * Assumes that if the P_SINTR flag is set, we're holding both the
 * kernel and scheduler locks.
 */
int
issignal(struct proc *p)
{
	struct process *pr = p->p_p;
	int signum, mask, prop;
	int dolock = (p->p_flag & P_SINTR) == 0;
	int s;

	for (;;) {
		mask = p->p_siglist & ~p->p_sigmask;
		if (pr->ps_flags & PS_PPWAIT)
			mask &= ~stopsigmask;
		if (mask == 0)	 	/* no signal to send */
			return (0);
		signum = ffs((long)mask);
		mask = sigmask(signum);
		atomic_clearbits_int(&p->p_siglist, mask);

		/*
		 * We should see pending but ignored signals
		 * only if PS_TRACED was on when they were posted.
		 */
		if (mask & pr->ps_sigacts->ps_sigignore &&
		    (pr->ps_flags & PS_TRACED) == 0)
			continue;

		if ((pr->ps_flags & (PS_TRACED | PS_PPWAIT)) == PS_TRACED) {
			/*
			 * If traced, always stop, and stay
			 * stopped until released by the debugger.
			 */
			p->p_xstat = signum;

			if (dolock)
				KERNEL_LOCK();
			single_thread_set(p, SINGLE_PTRACE, 0);
			if (dolock)
				KERNEL_UNLOCK();

			if (dolock)
				SCHED_LOCK(s);
			proc_stop(p, 1);
			if (dolock)
				SCHED_UNLOCK(s);

			if (dolock)
				KERNEL_LOCK();
			single_thread_clear(p, 0);
			if (dolock)
				KERNEL_UNLOCK();

			/*
			 * If we are no longer being traced, or the parent
			 * didn't give us a signal, look for more signals.
			 */
			if ((pr->ps_flags & PS_TRACED) == 0 || p->p_xstat == 0)
				continue;

			/*
			 * If the new signal is being masked, look for other
			 * signals.
			 */
			signum = p->p_xstat;
			mask = sigmask(signum);
			if ((p->p_sigmask & mask) != 0)
				continue;

			/* take the signal! */
			atomic_clearbits_int(&p->p_siglist, mask);
		}

		prop = sigprop[signum];

		/*
		 * Decide whether the signal should be returned.
		 * Return the signal's number, or fall through
		 * to clear it from the pending mask.
		 */
		switch ((long)pr->ps_sigacts->ps_sigact[signum]) {
		case (long)SIG_DFL:
			/*
			 * Don't take default actions on system processes.
			 */
			if (pr->ps_pid <= 1) {
#ifdef DIAGNOSTIC
				/*
				 * Are you sure you want to ignore SIGSEGV
				 * in init? XXX
				 */
				printf("Process (pid %d) got signal"
				    " %d\n", pr->ps_pid, signum);
#endif
				break;		/* == ignore */
			}
			/*
			 * If there is a pending stop signal to process
			 * with default action, stop here,
			 * then clear the signal.  However,
			 * if process is member of an orphaned
			 * process group, ignore tty stop signals.
			 */
			if (prop & SA_STOP) {
				if (pr->ps_flags & PS_TRACED ||
		    		    (pr->ps_pgrp->pg_jobc == 0 &&
				    prop & SA_TTYSTOP))
					break;	/* == ignore */
				p->p_xstat = signum;
				if (dolock)
					SCHED_LOCK(s);
				proc_stop(p, 1);
				if (dolock)
					SCHED_UNLOCK(s);
				break;
			} else if (prop & SA_IGNORE) {
				/*
				 * Except for SIGCONT, shouldn't get here.
				 * Default action is to ignore; drop it.
				 */
				break;		/* == ignore */
			} else
				goto keep;
			/*NOTREACHED*/
		case (long)SIG_IGN:
			/*
			 * Masking above should prevent us ever trying
			 * to take action on an ignored signal other
			 * than SIGCONT, unless process is traced.
			 */
			if ((prop & SA_CONT) == 0 &&
			    (pr->ps_flags & PS_TRACED) == 0)
				printf("issignal\n");
			break;		/* == ignore */
		default:
			/*
			 * This signal has an action, let
			 * postsig() process it.
			 */
			goto keep;
		}
	}
	/* NOTREACHED */

keep:
	atomic_setbits_int(&p->p_siglist, mask); /*leave the signal for later */
	return (signum);
}

/*
 * Put the argument process into the stopped state and notify the parent
 * via wakeup.  Signals are handled elsewhere.  The process must not be
 * on the run queue.
 */
void
proc_stop(struct proc *p, int sw)
{
	struct process *pr = p->p_p;
	extern void *softclock_si;

#ifdef MULTIPROCESSOR
	SCHED_ASSERT_LOCKED();
#endif

	p->p_stat = SSTOP;
	atomic_clearbits_int(&pr->ps_flags, PS_WAITED);
	atomic_setbits_int(&pr->ps_flags, PS_STOPPED);
	atomic_setbits_int(&p->p_flag, P_SUSPSIG);
	if (!timeout_pending(&proc_stop_to)) {
		timeout_add(&proc_stop_to, 0);
		/*
		 * We need this soft interrupt to be handled fast.
		 * Extra calls to softclock don't hurt.
		 */
                softintr_schedule(softclock_si);
	}
	if (sw)
		mi_switch();
}

/*
 * Called from a timeout to send signals to the parents of stopped processes.
 * We can't do this in proc_stop because it's called with nasty locks held
 * and we would need recursive scheduler lock to deal with that.
 */
void
proc_stop_sweep(void *v)
{
	struct process *pr;

	LIST_FOREACH(pr, &allprocess, ps_list) {
		if ((pr->ps_flags & PS_STOPPED) == 0)
			continue;
		atomic_clearbits_int(&pr->ps_flags, PS_STOPPED);

		if ((pr->ps_pptr->ps_sigacts->ps_flags & SAS_NOCLDSTOP) == 0)
			prsignal(pr->ps_pptr, SIGCHLD);
		wakeup(pr->ps_pptr);
	}
}

/*
 * Take the action for the specified signal
 * from the current set of pending signals.
 */
void
postsig(int signum)
{
	struct proc *p = curproc;
	struct process *pr = p->p_p;
	struct sigacts *ps = pr->ps_sigacts;
	sig_t action;
	u_long trapno;
	int mask, returnmask;
	union sigval sigval;
	int s, code;

#ifdef DIAGNOSTIC
	if (signum == 0)
		panic("postsig");
#endif

	KERNEL_LOCK();

	mask = sigmask(signum);
	atomic_clearbits_int(&p->p_siglist, mask);
	action = ps->ps_sigact[signum];
	sigval.sival_ptr = 0;

	if (p->p_sisig != signum) {
		trapno = 0;
		code = SI_USER;
		sigval.sival_ptr = 0;
	} else {
		trapno = p->p_sitrapno;
		code = p->p_sicode;
		sigval = p->p_sigval;
	}

#ifdef KTRACE
	if (KTRPOINT(p, KTR_PSIG)) {
		siginfo_t si;
		
		initsiginfo(&si, signum, trapno, code, sigval);
		ktrpsig(p, signum, action, p->p_flag & P_SIGSUSPEND ?
		    p->p_oldmask : p->p_sigmask, code, &si);
	}
#endif
	if (action == SIG_DFL) {
		/*
		 * Default action, where the default is to kill
		 * the process.  (Other cases were ignored above.)
		 */
		sigexit(p, signum);
		/* NOTREACHED */
	} else {
		/*
		 * If we get here, the signal must be caught.
		 */
#ifdef DIAGNOSTIC
		if (action == SIG_IGN || (p->p_sigmask & mask))
			panic("postsig action");
#endif
		/*
		 * Set the new mask value and also defer further
		 * occurrences of this signal.
		 *
		 * Special case: user has done a sigpause.  Here the
		 * current mask is not of interest, but rather the
		 * mask from before the sigpause is what we want
		 * restored after the signal processing is completed.
		 */
#ifdef MULTIPROCESSOR
		s = splsched();
#else
		s = splhigh();
#endif
		if (p->p_flag & P_SIGSUSPEND) {
			atomic_clearbits_int(&p->p_flag, P_SIGSUSPEND);
			returnmask = p->p_oldmask;
		} else {
			returnmask = p->p_sigmask;
		}
		atomic_setbits_int(&p->p_sigmask, ps->ps_catchmask[signum]);
		if ((ps->ps_sigreset & mask) != 0) {
			ps->ps_sigcatch &= ~mask;
			if (signum != SIGCONT && sigprop[signum] & SA_IGNORE)
				ps->ps_sigignore |= mask;
			ps->ps_sigact[signum] = SIG_DFL;
		}
		splx(s);
		p->p_ru.ru_nsignals++;
		if (p->p_sisig == signum) {
			p->p_sisig = 0;
			p->p_sitrapno = 0;
			p->p_sicode = SI_USER;
			p->p_sigval.sival_ptr = NULL;
		}

		(*pr->ps_emul->e_sendsig)(action, signum, returnmask, trapno,
		    code, sigval);
	}

	KERNEL_UNLOCK();
}

/*
 * Force the current process to exit with the specified signal, dumping core
 * if appropriate.  We bypass the normal tests for masked and caught signals,
 * allowing unrecoverable failures to terminate the process without changing
 * signal state.  Mark the accounting record with the signal termination.
 * If dumping core, save the signal number for the debugger.  Calls exit and
 * does not return.
 */
void
sigexit(struct proc *p, int signum)
{
	/* Mark process as going away */
	atomic_setbits_int(&p->p_flag, P_WEXIT);

	p->p_p->ps_acflag |= AXSIG;
	if (sigprop[signum] & SA_CORE) {
		p->p_sisig = signum;

		/* if there are other threads, pause them */
		if (P_HASSIBLING(p))
			single_thread_set(p, SINGLE_SUSPEND, 0);

		if (coredump(p) == 0)
			signum |= WCOREFLAG;
	}
	exit1(p, W_EXITCODE(0, signum), EXIT_NORMAL);
	/* NOTREACHED */
}

int nosuidcoredump = 1;

struct coredump_iostate {
	struct proc *io_proc;
	struct vnode *io_vp;
	struct ucred *io_cred;
	off_t io_offset;
};

/*
 * Dump core, into a file named "progname.core", unless the process was
 * setuid/setgid.
 */
int
coredump(struct proc *p)
{
#ifdef SMALL_KERNEL
	return EPERM;
#else
	struct process *pr = p->p_p;
	struct vnode *vp;
	struct ucred *cred = p->p_ucred;
	struct vmspace *vm = p->p_vmspace;
	struct nameidata nd;
	struct vattr vattr;
	struct coredump_iostate	io;
	int error, len, incrash = 0;
	char name[MAXPATHLEN];
	const char *dir = "/var/crash";

	if (pr->ps_emul->e_coredump == NULL)
		return (EINVAL);

	pr->ps_flags |= PS_COREDUMP;

	/*
	 * If the process has inconsistant uids, nosuidcoredump
	 * determines coredump placement policy.
	 */
	if (((pr->ps_flags & PS_SUGID) && (error = suser(p, 0))) ||
	   ((pr->ps_flags & PS_SUGID) && nosuidcoredump)) {
		if (nosuidcoredump == 3 || nosuidcoredump == 2)
			incrash = 1;
		else
			return (EPERM);
	}

	/* Don't dump if will exceed file size limit. */
	if (USPACE + ptoa(vm->vm_dsize + vm->vm_ssize) >=
	    p->p_rlimit[RLIMIT_CORE].rlim_cur)
		return (EFBIG);

	if (incrash && nosuidcoredump == 3) {
		/*
		 * If the program directory does not exist, dumps of
		 * that core will silently fail.
		 */
		len = snprintf(name, sizeof(name), "%s/%s/%u.core",
		    dir, pr->ps_comm, pr->ps_pid);
	} else if (incrash && nosuidcoredump == 2)
		len = snprintf(name, sizeof(name), "%s/%s.core",
		    dir, pr->ps_comm);
	else
		len = snprintf(name, sizeof(name), "%s.core", pr->ps_comm);
	if (len >= sizeof(name))
		return (EACCES);

	/*
	 * Control the UID used to write out.  The normal case uses
	 * the real UID.  If the sugid case is going to write into the
	 * controlled directory, we do so as root.
	 */
	if (incrash == 0) {
		cred = crdup(cred);
		cred->cr_uid = cred->cr_ruid;
		cred->cr_gid = cred->cr_rgid;
	} else {
		if (p->p_fd->fd_rdir) {
			vrele(p->p_fd->fd_rdir);
			p->p_fd->fd_rdir = NULL;
		}
		p->p_ucred = crdup(p->p_ucred);
		crfree(cred);
		cred = p->p_ucred;
		crhold(cred);
		cred->cr_uid = 0;
		cred->cr_gid = 0;
	}

	NDINIT(&nd, LOOKUP, NOFOLLOW, UIO_SYSSPACE, name, p);

	error = vn_open(&nd, O_CREAT | FWRITE | O_NOFOLLOW, S_IRUSR | S_IWUSR);

	if (error)
		goto out;

	/*
	 * Don't dump to non-regular files, files with links, or files
	 * owned by someone else.
	 */
	vp = nd.ni_vp;
	if ((error = VOP_GETATTR(vp, &vattr, cred, p)) != 0) {
		VOP_UNLOCK(vp, p);
		vn_close(vp, FWRITE, cred, p);
		goto out;
	}
	if (vp->v_type != VREG || vattr.va_nlink != 1 ||
	    vattr.va_mode & ((VREAD | VWRITE) >> 3 | (VREAD | VWRITE) >> 6) ||
	    vattr.va_uid != cred->cr_uid) {
		error = EACCES;
		VOP_UNLOCK(vp, p);
		vn_close(vp, FWRITE, cred, p);
		goto out;
	}
	VATTR_NULL(&vattr);
	vattr.va_size = 0;
	VOP_SETATTR(vp, &vattr, cred, p);
	pr->ps_acflag |= ACORE;

	io.io_proc = p;
	io.io_vp = vp;
	io.io_cred = cred;
	io.io_offset = 0;
	VOP_UNLOCK(vp, p);
	vref(vp);
	error = vn_close(vp, FWRITE, cred, p);
	if (error == 0)
		error = (*pr->ps_emul->e_coredump)(p, &io);
	vrele(vp);
out:
	crfree(cred);
	return (error);
#endif
}

#ifndef SMALL_KERNEL
int
coredump_write(void *cookie, enum uio_seg segflg, const void *data, size_t len)
{
	struct coredump_iostate *io = cookie;
	off_t coffset = 0;
	size_t csize;
	int chunk, error;

	csize = len;
	do {
		if (io->io_proc->p_siglist & sigmask(SIGKILL))
			return (EINTR);

		/* Rest of the loop sleeps with lock held, so... */
		yield();

		chunk = MIN(csize, MAXPHYS);
		error = vn_rdwr(UIO_WRITE, io->io_vp,
		    (caddr_t)data + coffset, chunk,
		    io->io_offset + coffset, segflg,
		    IO_UNIT, io->io_cred, NULL, io->io_proc);
		if (error) {
			struct process *pr = io->io_proc->p_p;
			if (error == ENOSPC)
				log(LOG_ERR, "coredump of %s(%d) failed, filesystem full\n",
				    pr->ps_comm, pr->ps_pid);
			else
				log(LOG_ERR, "coredump of %s(%d), write failed: errno %d\n",
				    pr->ps_comm, pr->ps_pid, error);
			return (error);
		}

		coffset += chunk;
		csize -= chunk;
	} while (csize > 0);

	io->io_offset += len;
	return (0);
}

void
coredump_unmap(void *cookie, vaddr_t start, vaddr_t end)
{
	struct coredump_iostate *io = cookie;

	uvm_unmap(&io->io_proc->p_vmspace->vm_map, start, end);
}

#endif	/* !SMALL_KERNEL */

/*
 * Nonexistent system call-- signal process (may want to handle it).
 * Flag error in case process won't see signal immediately (blocked or ignored).
 */
int
sys_nosys(struct proc *p, void *v, register_t *retval)
{

	ptsignal(p, SIGSYS, STHREAD);
	return (ENOSYS);
}

int
sys___thrsigdivert(struct proc *p, void *v, register_t *retval)
{
	static int sigwaitsleep;
	struct sys___thrsigdivert_args /* {
		syscallarg(sigset_t) sigmask;
		syscallarg(siginfo_t *) info;
		syscallarg(const struct timespec *) timeout;
	} */ *uap = v;
	struct process *pr = p->p_p;
	sigset_t *m;
	sigset_t mask = SCARG(uap, sigmask) &~ sigcantmask;
	siginfo_t si;
	uint64_t to_ticks = 0;
	int timeinvalid = 0;
	int error = 0;

	memset(&si, 0, sizeof(si));

	if (SCARG(uap, timeout) != NULL) {
		struct timespec ts;
		if ((error = copyin(SCARG(uap, timeout), &ts, sizeof(ts))) != 0)
			return (error);
#ifdef KTRACE
		if (KTRPOINT(p, KTR_STRUCT))
			ktrreltimespec(p, &ts);
#endif
		if (ts.tv_nsec < 0 || ts.tv_nsec >= 1000000000)
			timeinvalid = 1;
		else {
			to_ticks = (uint64_t)hz * ts.tv_sec +
			    ts.tv_nsec / (tick * 1000);
			if (to_ticks > INT_MAX)
				to_ticks = INT_MAX;
			if (to_ticks == 0 && ts.tv_nsec)
				to_ticks = 1;
		}
	}

	dosigsuspend(p, p->p_sigmask &~ mask);
	for (;;) {
		si.si_signo = CURSIG(p);
		if (si.si_signo != 0) {
			sigset_t smask = sigmask(si.si_signo);
			if (smask & mask) {
				if (p->p_siglist & smask)
					m = &p->p_siglist;
				else if (pr->ps_mainproc->p_siglist & smask)
					m = &pr->ps_mainproc->p_siglist;
				else {
					/* signal got eaten by someone else? */
					continue;
				}
				atomic_clearbits_int(m, smask);
				error = 0;
				break;
			}
		}

		/* per-POSIX, delay this error until after the above */
		if (timeinvalid)
			error = EINVAL;

		if (SCARG(uap, timeout) != NULL && to_ticks == 0)
			error = EAGAIN;

		if (error != 0)
			break;

		error = tsleep(&sigwaitsleep, PPAUSE|PCATCH, "sigwait",
		    (int)to_ticks);
	}

	if (error == 0) {
		*retval = si.si_signo;
		if (SCARG(uap, info) != NULL)
			error = copyout(&si, SCARG(uap, info), sizeof(si));
	} else if (error == ERESTART && SCARG(uap, timeout) != NULL) {
		/*
		 * Restarting is wrong if there's a timeout, as it'll be
		 * for the same interval again
		 */
		error = EINTR;
	}

	return (error);
}

void
initsiginfo(siginfo_t *si, int sig, u_long trapno, int code, union sigval val)
{
	memset(si, 0, sizeof(*si));

	si->si_signo = sig;
	si->si_code = code;
	if (code == SI_USER) {
		si->si_value = val;
	} else {
		switch (sig) {
		case SIGSEGV:
		case SIGILL:
		case SIGBUS:
		case SIGFPE:
			si->si_addr = val.sival_ptr;
			si->si_trapno = trapno;
			break;
		case SIGXFSZ:
			break;
		}
	}
}

int
filt_sigattach(struct knote *kn)
{
	struct process *pr = curproc->p_p;

	if (kn->kn_id >= NSIG)
		return EINVAL;

	kn->kn_ptr.p_process = pr;
	kn->kn_flags |= EV_CLEAR;		/* automatically set */

	/* XXX lock the proc here while adding to the list? */
	SLIST_INSERT_HEAD(&pr->ps_klist, kn, kn_selnext);

	return (0);
}

void
filt_sigdetach(struct knote *kn)
{
	struct process *pr = kn->kn_ptr.p_process;

	SLIST_REMOVE(&pr->ps_klist, kn, knote, kn_selnext);
}

/*
 * signal knotes are shared with proc knotes, so we apply a mask to
 * the hint in order to differentiate them from process hints.  This
 * could be avoided by using a signal-specific knote list, but probably
 * isn't worth the trouble.
 */
int
filt_signal(struct knote *kn, long hint)
{

	if (hint & NOTE_SIGNAL) {
		hint &= ~NOTE_SIGNAL;

		if (kn->kn_id == hint)
			kn->kn_data++;
	}
	return (kn->kn_data != 0);
}

void
userret(struct proc *p)
{
	int sig;

	/* send SIGPROF or SIGVTALRM if their timers interrupted this thread */
	if (p->p_flag & P_PROFPEND) {
		atomic_clearbits_int(&p->p_flag, P_PROFPEND);
		KERNEL_LOCK();
		psignal(p, SIGPROF);
		KERNEL_UNLOCK();
	}
	if (p->p_flag & P_ALRMPEND) {
		atomic_clearbits_int(&p->p_flag, P_ALRMPEND);
		KERNEL_LOCK();
		psignal(p, SIGVTALRM);
		KERNEL_UNLOCK();
	}

	while ((sig = CURSIG(p)) != 0)
		postsig(sig);

	/*
	 * If P_SIGSUSPEND is still set here, then we still need to restore
	 * the original sigmask before returning to userspace.  Also, this
	 * might unmask some pending signals, so we need to check a second
	 * time for signals to post.
	 */
	if (p->p_flag & P_SIGSUSPEND) {
		atomic_clearbits_int(&p->p_flag, P_SIGSUSPEND);
		p->p_sigmask = p->p_oldmask;

		while ((sig = CURSIG(p)) != 0)
			postsig(sig);
	}

	if (p->p_flag & P_SUSPSINGLE) {
		KERNEL_LOCK();
		single_thread_check(p, 0);
		KERNEL_UNLOCK();
	}

	p->p_cpu->ci_schedstate.spc_curpriority = p->p_priority = p->p_usrpri;
}

int
single_thread_check(struct proc *p, int deep)
{
	struct process *pr = p->p_p;

	if (pr->ps_single != NULL && pr->ps_single != p) {
		do {
			int s;

			/* if we're in deep, we need to unwind to the edge */
			if (deep) {
				if (pr->ps_flags & PS_SINGLEUNWIND)
					return (ERESTART);
				if (pr->ps_flags & PS_SINGLEEXIT)
					return (EINTR);
			}

			if (--pr->ps_singlecount == 0)
				wakeup(&pr->ps_singlecount);
			if (pr->ps_flags & PS_SINGLEEXIT)
				exit1(p, 0, EXIT_THREAD_NOCHECK);

			/* not exiting and don't need to unwind, so suspend */
			SCHED_LOCK(s);
			p->p_stat = SSTOP;
			mi_switch();
			SCHED_UNLOCK(s);
		} while (pr->ps_single != NULL);
	}

	return (0);
}

/*
 * Stop other threads in the process.  The mode controls how and
 * where the other threads should stop:
 *  - SINGLE_SUSPEND: stop wherever they are, will later either be told to exit
 *    (by setting to SINGLE_EXIT) or be released (via single_thread_clear())
 *  - SINGLE_PTRACE: stop wherever they are, will wait for them to stop
 *    later (via single_thread_wait()) and released as with SINGLE_SUSPEND
 *  - SINGLE_UNWIND: just unwind to kernel boundary, will be told to exit
 *    or released as with SINGLE_SUSPEND
 *  - SINGLE_EXIT: unwind to kernel boundary and exit
 */
int
single_thread_set(struct proc *p, enum single_thread_mode mode, int deep)
{
	struct process *pr = p->p_p;
	struct proc *q;
	int error;

	KERNEL_ASSERT_LOCKED();

	if ((error = single_thread_check(p, deep)))
		return error;

	switch (mode) {
	case SINGLE_SUSPEND:
	case SINGLE_PTRACE:
		break;
	case SINGLE_UNWIND:
		atomic_setbits_int(&pr->ps_flags, PS_SINGLEUNWIND);
		break;
	case SINGLE_EXIT:
		atomic_setbits_int(&pr->ps_flags, PS_SINGLEEXIT);
		atomic_clearbits_int(&pr->ps_flags, PS_SINGLEUNWIND);
		break;
#ifdef DIAGNOSTIC
	default:
		panic("single_thread_mode = %d", mode);
#endif
	}
	pr->ps_single = p;
	pr->ps_singlecount = 0;
	TAILQ_FOREACH(q, &pr->ps_threads, p_thr_link) {
		int s;

		if (q == p)
			continue;
		if (q->p_flag & P_WEXIT) {
			if (mode == SINGLE_EXIT) {
				SCHED_LOCK(s);
				if (q->p_stat == SSTOP) {
					setrunnable(q);
					pr->ps_singlecount++;
				}
				SCHED_UNLOCK(s);
			}
			continue;
		}
		SCHED_LOCK(s);
		atomic_setbits_int(&q->p_flag, P_SUSPSINGLE);
		switch (q->p_stat) {
		case SIDL:
		case SRUN:
			pr->ps_singlecount++;
			break;
		case SSLEEP:
			/* if it's not interruptible, then just have to wait */
			if (q->p_flag & P_SINTR) {
				/* merely need to suspend?  just stop it */
				if (mode == SINGLE_SUSPEND ||
				    mode == SINGLE_PTRACE) {
					q->p_stat = SSTOP;
					break;
				}
				/* need to unwind or exit, so wake it */
				setrunnable(q);
			}
			pr->ps_singlecount++;
			break;
		case SSTOP:
			if (mode == SINGLE_EXIT) {
				setrunnable(q);
				pr->ps_singlecount++;
			}
			break;
		case SDEAD:
			break;
		case SONPROC:
			pr->ps_singlecount++;
			signotify(q);
			break;
		}
		SCHED_UNLOCK(s);
	}

	if (mode != SINGLE_PTRACE)
		single_thread_wait(pr);

	return 0;
}

void
single_thread_wait(struct process *pr)
{
	/* wait until they're all suspended */
	while (pr->ps_singlecount > 0)
		tsleep(&pr->ps_singlecount, PUSER, "suspend", 0);
}

void
single_thread_clear(struct proc *p, int flag)
{
	struct process *pr = p->p_p;
	struct proc *q;

	KASSERT(pr->ps_single == p);
	KERNEL_ASSERT_LOCKED();

	pr->ps_single = NULL;
	atomic_clearbits_int(&pr->ps_flags, PS_SINGLEUNWIND | PS_SINGLEEXIT);
	TAILQ_FOREACH(q, &pr->ps_threads, p_thr_link) {
		int s;

		if (q == p || (q->p_flag & P_SUSPSINGLE) == 0)
			continue;
		atomic_clearbits_int(&q->p_flag, P_SUSPSINGLE);

		/*
		 * if the thread was only stopped for single threading
		 * then clearing that either makes it runnable or puts
		 * it back into some sleep queue
		 */
		SCHED_LOCK(s);
		if (q->p_stat == SSTOP && (q->p_flag & flag) == 0) {
			if (q->p_wchan == 0)
				setrunnable(q);
			else
				q->p_stat = SSLEEP;
		}
		SCHED_UNLOCK(s);
	}
}
@


1.208
log
@Rename pfind(9) into tfind(9) to reflect that it deals with threads.

While here document prfind(9.

with and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.207 2017/01/21 05:42:03 guenther Exp $	*/
d71 1
a71 4

#ifdef  __HAVE_MD_TCB
# include <machine/tcb.h>
#endif
@


1.207
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.206 2016/10/05 02:31:52 guenther Exp $	*/
d620 1
a620 1
		if ((p = pfind(tid - THREAD_PID_OFFSET)) == NULL)
@


1.206
log
@Display/test/use the process PID, not the thread's TID, in a few places.

ok mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.205 2016/09/15 02:00:16 dlg Exp $	*/
d1514 1
a1514 1
		    dir, p->p_comm, pr->ps_pid);
d1517 1
a1517 1
		    dir, p->p_comm);
d1519 1
a1519 1
		len = snprintf(name, sizeof(name), "%s.core", p->p_comm);
d1614 1
d1617 1
a1617 1
				    io->io_proc->p_comm, io->io_proc->p_p->ps_pid);
d1620 1
a1620 1
				    io->io_proc->p_comm, io->io_proc->p_p->ps_pid, error);
@


1.205
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.204 2016/09/04 17:22:40 jsing Exp $	*/
d752 1
a752 1
 * Send a signal caused by a trap to the current process.
d1206 1
a1206 1
			if (p->p_pid <= 1) {
d1212 2
a1213 2
				printf("Process (pid %d) got signal %d\n",
				    p->p_pid, signum);
d1514 1
a1514 1
		    dir, p->p_comm, p->p_pid);
d1616 1
a1616 1
				    io->io_proc->p_comm, io->io_proc->p_pid);
d1619 1
a1619 1
				    io->io_proc->p_comm, io->io_proc->p_pid, error);
@


1.204
log
@Remove sys_o58_kill since OpenBSD 6.0 has been tagged/released.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.203 2016/08/25 00:00:02 dlg Exp $	*/
d155 2
a156 3
	pool_init(&sigacts_pool, sizeof(struct sigacts), 0, 0, PR_WAITOK,
	    "sigapl", NULL);
	pool_setipl(&sigacts_pool, IPL_NONE);
@


1.203
log
@pool_setipl

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.202 2016/07/14 05:55:08 guenther Exp $	*/
a560 57
}

int
sys_o58_kill(struct proc *cp, void *v, register_t *retval)
{
	struct sys_o58_kill_args /* {
		syscallarg(int) pid;
		syscallarg(int) signum;
	} */ *uap = v;
	struct proc *p;
	int pid = SCARG(uap, pid);
	int signum = SCARG(uap, signum);
	int error;

	if (pid <= THREAD_PID_OFFSET && (error = pledge_kill(cp, pid)) != 0)
		return (error);
	if (((u_int)signum) >= NSIG)
		return (EINVAL);
	if (pid > 0) {
		enum signal_type type = SPROCESS;

		/*
		 * If the target pid is > THREAD_PID_OFFSET then this
		 * must be a kill of another thread in the same process.
		 * Otherwise, this is a process kill and the target must
		 * be a main thread.
		 */
		if (pid > THREAD_PID_OFFSET) {
			if ((p = pfind(pid - THREAD_PID_OFFSET)) == NULL)
				return (ESRCH);
			if (p->p_p != cp->p_p)
				return (ESRCH);
			type = STHREAD;
		} else {
			/* XXX use prfind() */
			if ((p = pfind(pid)) == NULL)
				return (ESRCH);
			if (p->p_flag & P_THREAD)
				return (ESRCH);
			if (!cansignal(cp, p->p_p, signum))
				return (EPERM);
		}

		/* kill single process or thread */
		if (signum)
			ptsignal(p, signum, type);
		return (0);
	}
	switch (pid) {
	case -1:		/* broadcast signal */
		return (killpg1(cp, signum, 0, 1));
	case 0:			/* signal own process group */
		return (killpg1(cp, signum, 0, 0));
	default:		/* negative explicit process group */
		return (killpg1(cp, signum, -pid, 0));
	}
	/* NOTREACHED */
@


1.202
log
@Prevent silly states via knotes on pids > 2^32 and on nonexistent signals.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.201 2016/07/06 15:53:01 tedu Exp $	*/
d157 1
@


1.201
log
@fix several places where calculating ticks could overflow.
it's not enough to assign to an unsigned type because if the arithmetic
overflows the compiler may decide to do anything. so change all the
long long casts to uint64_t so that we start with the right type.
reported by Tim Newsham of NCC.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.200 2016/06/27 19:55:02 jca Exp $	*/
d1826 3
@


1.200
log
@Repair kill(2) on zombie processes.

kill(2) is supposed to find zombie processes, this probably got broken
when the process reaper was introduced.  As a temporary(tm) workaround,
walk the list of zombie processes if we can't find the target pid in the
main process list.

Problem with zsh initially reported by Geoff Wozniak on misc@@, analysis
done by naddy@@.  ok kettenis@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.199 2016/06/27 16:49:45 jsing Exp $	*/
d1723 1
a1723 1
	long long to_ticks = 0;
d1740 1
a1740 1
			to_ticks = (long long)hz * ts.tv_sec +
@


1.199
log
@Restore the sys_o58_kill system call.

By keeping both the new (sys_kill/sys_thrkill) and old (sys_o58_kill)
system calls for the OpenBSD 6.0 release, code that uses either of these
mechanisms will work on both of the supported OpenBSD releases. This
provides a clean transition for runtimes that make direct system calls
(namely the Go programming language).

This requires a minimal amount of non-intrusive code and does not block
development progress within OpenBSD.

ok deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.196 2016/03/29 08:46:08 mpi Exp $	*/
d630 1
d637 6
a642 2
		if ((pr = prfind(pid)) == NULL)
			return (ESRCH);
d647 1
a647 1
		if (signum)
@


1.198
log
@if the timeout rounds to zero, make it one tick, otherwise we sleep
forever. noticed by Davin McCall.
while here, if the timeout actually is zero, return appropriate error.
ok guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.197 2016/05/31 22:14:43 deraadt Exp $	*/
d560 57
@


1.197
log
@sys_o58_kill is no longer needed for compat.
ok guenther sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.196 2016/03/29 08:46:08 mpi Exp $	*/
d1682 2
d1710 3
@


1.196
log
@Use a macro to check if a thread has a sibling.

Note that without locking a thread cannot claim that it is part
of a multi-threaded process using this macro.

Suggested by miod@@, ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.195 2016/03/26 21:38:54 beck Exp $	*/
a559 57
}

int
sys_o58_kill(struct proc *cp, void *v, register_t *retval)
{
	struct sys_o58_kill_args /* {
		syscallarg(int) pid;
		syscallarg(int) signum;
	} */ *uap = v;
	struct proc *p;
	int pid = SCARG(uap, pid);
	int signum = SCARG(uap, signum);
	int error;

	if (pid <= THREAD_PID_OFFSET && (error = pledge_kill(cp, pid)) != 0)
		return (error);
	if (((u_int)signum) >= NSIG)
		return (EINVAL);
	if (pid > 0) {
		enum signal_type type = SPROCESS;

		/*
		 * If the target pid is > THREAD_PID_OFFSET then this
		 * must be a kill of another thread in the same process.
		 * Otherwise, this is a process kill and the target must
		 * be a main thread.
		 */
		if (pid > THREAD_PID_OFFSET) {
			if ((p = pfind(pid - THREAD_PID_OFFSET)) == NULL)
				return (ESRCH);
			if (p->p_p != cp->p_p)
				return (ESRCH);
			type = STHREAD;
		} else {
			/* XXX use prfind() */
			if ((p = pfind(pid)) == NULL)
				return (ESRCH);
			if (p->p_flag & P_THREAD)
				return (ESRCH);
			if (!cansignal(cp, p->p_p, signum))
				return (EPERM);
		}

		/* kill single process or thread */
		if (signum)
			ptsignal(p, signum, type);
		return (0);
	}
	switch (pid) {
	case -1:		/* broadcast signal */
		return (killpg1(cp, signum, 0, 1));
	case 0:			/* signal own process group */
		return (killpg1(cp, signum, 0, 0));
	default:		/* negative explicit process group */
		return (killpg1(cp, signum, -pid, 0));
	}
	/* NOTREACHED */
@


1.195
log
@add newline on the end of the failure message
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.194 2016/03/19 12:04:15 natano Exp $	*/
d1498 1
a1498 2
		if (TAILQ_FIRST(&p->p_p->ps_threads) != p ||
		    TAILQ_NEXT(p, p_thr_link) != NULL)
@


1.194
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.193 2016/03/09 13:38:50 mpi Exp $	*/
d1668 1
a1668 1
				log(LOG_ERR, "coredump of %s(%d) failed, filesystem full",
d1671 1
a1671 1
				log(LOG_ERR, "coredump of %s(%d), write failed: errno %d",
@


1.193
log
@Correct some comments and definitions, from Michal Mazurek.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.192 2016/01/09 06:13:43 semarie Exp $	*/
d1611 1
a1611 1
		VOP_UNLOCK(vp, 0, p);
d1619 1
a1619 1
		VOP_UNLOCK(vp, 0, p);
d1632 1
a1632 1
	VOP_UNLOCK(vp, 0, p);
@


1.192
log
@drop "abort" promise, and make it the default behaviour.
The current code has already setted it by default since 1.74

any pledge failure tries to make a coredump (default rules for coredump still
applies: so setuid binaries don't create them locally).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.191 2015/12/05 10:11:53 tedu Exp $	*/
d899 1
a899 1
	/* Ignore signal if we are exiting */
d983 1
a983 1
			if (prop & SA_KILL &&  pr->ps_nice > NZERO)
@


1.192.2.1
log
@backport timeout overflow fixes:
fix several places where calculating ticks could overflow.
it's not enough to assign to an unsigned type because if the arithmetic
overflows the compiler may decide to do anything. so change all the
long long casts to uint64_t so that we start with the right type.
reported by Tim Newsham of NCC.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.192 2016/01/09 06:13:43 semarie Exp $	*/
d1719 1
a1719 1
	uint64_t to_ticks = 0;
d1736 1
a1736 1
			to_ticks = (uint64_t)hz * ts.tv_sec +
@


1.191
log
@remove stale lint annotations
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.190 2015/11/10 04:30:59 guenther Exp $	*/
a1598 1
	nd.ni_pledge = PLEDGE_COREDUMP;
@


1.190
log
@Split the intra-thread functionality from kill(2) into its own syscall
thrkill(2), rolling the kill(2) syscall number with the ABI change to
avoid breaking binaries during during the transition.  thrkill(2) includes
a 'tcb' argument that eliminates the need for locking in pthread_kill()
and simplifies pthread_cancel().  Switch __stack_smash_handler() to use
thrkill(2) and explicitly unblock SIGABRT.

Minor bump to both libc and libpthread: make sure you install a new kernel!

ok semarie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.189 2015/11/02 16:31:55 semarie Exp $	*/
a229 1
/* ARGSUSED */
a467 1
/* ARGSUSED */
a494 1
/* ARGSUSED */
a1698 1
/* ARGSUSED */
@


1.189
log
@move the pledgenote annotation from `struct proc' to `struct nameidata'

pledgenote is used for annotate the policy for a namei context. So make it
tracking the nameidata.

It is expected for the caller to explicitly define the policy. It is a kernel
bug to not do so.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.188 2015/11/01 19:03:33 semarie Exp $	*/
d72 4
a564 1
/* ARGSUSED */
d566 1
a566 1
sys_kill(struct proc *cp, void *v, register_t *retval)
d568 1
a568 1
	struct sys_kill_args /* {
d577 1
a577 1
	if ((error = pledge_kill(cp, pid)) != 0)
d620 74
@


1.188
log
@refactor pledge_*_check and pledge_fail functions

- rename _check function without suffix: a "pledge" function called from
  anywhere is a "check" function.

- makes pledge_fail call the responsability to the _check function. remove it
  from caller.

- make proper use of (potential) returned error of _check() functions.

- adds pledge_kill() and pledge_protexec()

with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.187 2015/10/25 20:39:54 deraadt Exp $	*/
a1523 1
	p->p_pledgenote = PLEDGE_COREDUMP;
d1525 1
@


1.187
log
@Fold "malloc" into "stdio" and -- recognizing that no program so far has
used less than "stdio" -- include all the "self" operations.  Instead of
different defines, use regular PLEDGE_* in the "p_pledgenote" variable
(which indicates the operation subtype a system call is performing).  Many
checks before easier to understand.  p_pledgenote can often be passed
directly to ktrace, so that kdump says:
 15565 test     CALL  pledge(0xa9a3f804c51,0)
 15565 test     STRU  pledge request="stdio"
 15565 test     RET   pledge 0
 15565 test     CALL  open(0xa9a3f804c57,0x2<O_RDWR>)
 15565 test     NAMI  "/tmp/testfile"
 15565 test     PLDG  open, "wpath", errno 1 Operation not permitted
with help from semarie, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.186 2015/10/10 19:12:39 deraadt Exp $	*/
d572 1
d574 2
a575 9
	if (cp->p_p->ps_flags & PS_PLEDGE) {
		/* PLEDGE_PROC is required to signal another pid */
		if ((cp->p_p->ps_pledge & PLEDGE_PROC) ||
		    pid == cp->p_pid || pid == 0)
			;
		else
			return pledge_fail(cp, EPERM, PLEDGE_PROC);
	}

@


1.186
log
@pid 0 also implies self, so allow that for the pledge case.  Found in
a refactoring being done for the bc/dc relationship with otto.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.185 2015/10/09 23:55:03 deraadt Exp $	*/
d579 1
a579 1
			return pledge_fail(cp, EPERM, PLEDGE_SELF);
d1530 1
a1530 1
	p->p_pledgenote = TMN_COREDUMP;
@


1.185
log
@Allow kill(self, sig) in pledge SELF also.  the stack protector, abort(),
and readpassphrase() in particular use this.
ok millert tedu semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.184 2015/10/09 01:10:27 deraadt Exp $	*/
d575 2
a576 1
		if ((cp->p_p->ps_pledge & PLEDGE_PROC) || pid == cp->p_pid)
@


1.184
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.183 2015/07/27 18:22:37 deraadt Exp $	*/
d65 1
d572 8
@


1.183
log
@Rather than disabling tame to coredump, leave it enabled but flag that
a coredump is happening.  This improves behaviour while threaded.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.182 2015/07/20 00:19:14 beck Exp $	*/
d1520 1
a1520 1
	p->p_tamenote = TMN_COREDUMP;
@


1.183.4.1
log
@backport timeout overflow fixes:
fix several places where calculating ticks could overflow.
it's not enough to assign to an unsigned type because if the arithmetic
overflows the compiler may decide to do anything. so change all the
long long casts to uint64_t so that we start with the right type.
reported by Tim Newsham of NCC.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.183 2015/07/27 18:22:37 deraadt Exp $	*/
d1643 1
a1643 1
	uint64_t to_ticks = 0;
d1660 1
a1660 1
			to_ticks = (uint64_t)hz * ts.tv_sec +
@


1.182
log
@Fix annoying console spew when we can't write the core file. use log instead.
ok krw@@ sthen@@ comments from deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.181 2015/07/19 02:35:35 deraadt Exp $	*/
a1423 1
		atomic_clearbits_int(&p->p_p->ps_flags, PS_TAMED);
d1520 1
@


1.181
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.180 2015/05/05 02:13:46 guenther Exp $	*/
d64 1
d1590 6
a1595 5
			printf("pid %d (%s): %s write of %lu@@%p"
			    " at %lld failed: %d\n",
			    io->io_proc->p_pid, io->io_proc->p_comm,
			    segflg == UIO_USERSPACE ? "user" : "system",
			    len, data, (long long)io->io_offset, error);
@


1.180
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.179 2015/03/14 03:38:50 jsg Exp $	*/
d1423 1
@


1.179
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.178 2015/02/09 13:41:24 pelikan Exp $	*/
d1460 3
a1560 39
	return (error);
#endif
}

int
coredump_trad(struct proc *p, void *cookie)
{
#ifdef SMALL_KERNEL
	return EPERM;
#else
	struct coredump_iostate *io = cookie;
	struct vmspace *vm = io->io_proc->p_vmspace;
	struct vnode *vp = io->io_vp;
	struct ucred *cred = io->io_cred;
	struct core core;
	int error;

	core.c_midmag = 0;
	strlcpy(core.c_name, p->p_comm, sizeof(core.c_name));
	core.c_nseg = 0;
	core.c_signo = p->p_sisig;
	core.c_ucode = p->p_sitrapno;
	core.c_cpusize = 0;
	core.c_tsize = (u_long)ptoa(vm->vm_tsize);
	core.c_dsize = (u_long)ptoa(vm->vm_dsize);
	core.c_ssize = (u_long)round_page(ptoa(vm->vm_ssize));
	error = cpu_coredump(p, vp, cred, &core);
	if (error)
		return (error);
	/*
	 * uvm_coredump() spits out all appropriate segments.
	 * All that's left to do is to write the core header.
	 */
	error = uvm_coredump(p, vp, cred, &core);
	if (error)
		return (error);
	error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&core,
	    (int)core.c_hdrsize, (off_t)0,
	    UIO_SYSSPACE, IO_UNIT, cred, NULL, p);
@


1.178
log
@make sigprocmask(2) not take the kernel lock

Tests on a 4-core CPU show setjmp(3) run four times as fast under load.

discussed on tech@@ some time ago, now by kettenis and guenther, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.177 2014/12/19 05:59:21 tedu Exp $	*/
a50 1
#include <sys/buf.h>
@


1.177
log
@start retiring the nointr allocator. specify PR_WAITOK as a flag as a
marker for which pools are not interrupt safe. ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.176 2014/12/16 18:30:04 tedu Exp $	*/
a441 1
	int s;
d445 1
a445 2
	mask = SCARG(uap, mask);
	s = splhigh();
d449 1
a449 1
		p->p_sigmask |= mask &~ sigcantmask;
d452 1
a452 1
		p->p_sigmask &= ~mask;
d455 1
a455 1
		p->p_sigmask = mask &~ sigcantmask;
a460 1
	splx(s);
d754 1
a754 1
		p->p_sigmask |= ps->ps_catchmask[signum];
d1378 1
a1378 1
		p->p_sigmask |= ps->ps_catchmask[signum];
@


1.176
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.175 2014/11/16 05:42:21 guenther Exp $	*/
d150 2
a151 2
	pool_init(&sigacts_pool, sizeof(struct sigacts), 0, 0, 0, "sigapl",
	    &pool_allocator_nointr);
@


1.175
log
@Rework the __thrsigdivert (aka sigwait()) handling: instead of interfering
in ptsignal(), which broke ptrace() in various circumstances, act more like
sigsuspend() by updating the signal mask and picking off waited for signals
when one occurs.  Don't always restart when an unwaited-for-but-handled
signal occurs, as that screws with both timeout calculation and cancellation.

main problem noted by jmatthew@@
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.174 2014/08/10 23:44:20 bluhm Exp $	*/
d68 2
@


1.174
log
@Write the core file of a non-suid process into the current directory
even if sysctl kern.nosuidcoredump has been set to 2 or 3.  This
allows a regular user to debug his programs again.
OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.173 2014/07/13 16:41:21 claudio Exp $	*/
d839 1
a839 2
		 * immediately, either because it's sigwait()ing
		 * on it or has it unblocked, then have it take it.
d843 1
a843 1
		    ((q->p_sigdivert & mask) || (q->p_sigmask & mask) == 0))
d860 13
a872 3
				/* sigwait: definitely go to this thread */
				if (q->p_sigdivert & mask) {
					p = q;
a873 5
				}

				/* unblocked: possibly go to this thread */
				if ((q->p_sigmask & mask) == 0)
					p = q;
a884 2
	 * XXX give sigwait() priority until it's fixed to do this
	 * XXX from issignal/postsig
d886 1
a886 6
	if (p->p_sigdivert & mask) {
		p->p_sigwait = signum;
		atomic_clearbits_int(&p->p_sigdivert, ~0);
		action = SIG_CATCH;
		wakeup(&p->p_sigdivert);
	} else if (pr->ps_flags & PS_TRACED) {
d1668 1
d1674 1
a1674 1
	sigset_t mask;
d1676 2
d1679 2
a1680 1
	int error;
d1682 1
a1682 14
	m = NULL;
	mask = SCARG(uap, sigmask) &~ sigcantmask;

	/* pending signal for this thread? */
	if (p->p_siglist & mask)
		m = &p->p_siglist;
	else if (p->p_p->ps_mainproc->p_siglist & mask)
		m = &p->p_p->ps_mainproc->p_siglist;
	if (m != NULL) {
		int sig = ffs((long)(*m & mask));
		atomic_clearbits_int(m, sigmask(sig));
		*retval = sig;
		return (0);
	}
d1692 36
a1727 19
		to_ticks = (long long)hz * ts.tv_sec +
		    ts.tv_nsec / (tick * 1000);
		if (to_ticks > INT_MAX)
			to_ticks = INT_MAX;
	}

	p->p_sigwait = 0;
	atomic_setbits_int(&p->p_sigdivert, mask);
	error = tsleep(&p->p_sigdivert, PPAUSE|PCATCH, "sigwait",
	    (int)to_ticks);
	if (p->p_sigdivert) {
		/* interrupted */
		KASSERT(error != 0);
		atomic_clearbits_int(&p->p_sigdivert, ~0);
		if (error == EINTR)
			error = ERESTART;
		else if (error == ETIMEDOUT)
			error = EAGAIN;
		return (error);
d1729 2
a1731 2
	KASSERT(p->p_sigwait != 0);
	*retval = p->p_sigwait;
d1733 11
a1743 4
	if (SCARG(uap, info) == NULL) {
		error = 0;
	} else {
		siginfo_t si;
a1744 4
		memset(&si, 0, sizeof(si));
		si.si_signo = p->p_sigwait;
		error = copyout(&si, SCARG(uap, info), sizeof(si));
	}
@


1.173
log
@Introduce PS_NOBROADCASTKILL a process flag that excludes processes from
receiving broadcast signals (kill -1). The flag can be set via a new
sysctl KERN_PROC_NOBROADCASTKILL. This will be used by iscsid to survive
the mass killing by init(8) when terminating multi-user operations.
With and OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.172 2014/07/13 15:46:21 uebayasi Exp $	*/
d1484 1
a1484 1
	if (nosuidcoredump == 3) {
d1491 1
a1491 1
	} else if (nosuidcoredump == 2)
@


1.172
log
@KERNEL_ASSERT_LOCKED(9): Assertion for kernel lock (Rev. 3)

This adds a new assertion macro, KERNEL_ASSERT_LOCKED(), to assert that
kernel_lock is held.  In the long process of removing kernel_lock, there will
be a lot (hundreds or thousands) of use of this; virtually almost all functions
in !MP-safe subsystems should have this assertion.  Thus this assertion should
have a short, good name.

Not only that "KERNEL_ASSERT_LOCKED" is consistent with other KERNEL_* and
SCHED_ASSERT_LOCKED() macros.

Input from dlg@@ guenther@@ kettenis@@.

OK dlg@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d632 2
a633 1
			if (pr->ps_pid <= 1 || pr->ps_flags & PS_SYSTEM ||
@


1.171
log
@Refactor out dosigsuspend() function

Discussed with guenther and kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.170 2014/07/11 08:18:31 guenther Exp $	*/
d1900 1
a1900 3
#ifdef MULTIPROCESSOR
	KASSERT(__mp_lock_held(&kernel_lock));
#endif
d1997 1
a1997 3
#ifdef MULTIPROCESSOR
	KASSERT(__mp_lock_held(&kernel_lock));
#endif
@


1.170
log
@It's init as a process that's special, not init's original thread.
Remember initprocess instead of initproc.

ok matthew@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.169 2014/07/08 17:19:25 deraadt Exp $	*/
d475 14
d503 1
a503 10
	/*
	 * When returning from sigpause, we want
	 * the old mask to be restored after the
	 * signal handler has finished.  Thus, we
	 * save it here and mark the sigacts structure
	 * to indicate this.
	 */
	p->p_oldmask = p->p_sigmask;
	atomic_setbits_int(&p->p_flag, P_SIGSUSPEND);
	p->p_sigmask = SCARG(uap, mask) &~ sigcantmask;
@


1.169
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.168 2014/07/04 05:58:30 guenther Exp $	*/
d327 1
a327 1
		if (initproc->p_p->ps_sigacts != ps &&
@


1.168
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.167 2014/06/21 20:58:30 guenther Exp $	*/
a67 3


#include <uvm/uvm_extern.h>
@


1.167
log
@If the kernel generates a deadly trap signal (SEGV, BUS, etc) for
an untraced process but finds it blocking or ignoring it, just kill
the process instead of looping.  It's undefined behavor in POSIX but
quite annoying when encountered in practice.

improvements from kettenis@@
ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.166 2014/05/04 05:03:26 guenther Exp $	*/
d1061 1
a1061 1
		 * SRUN, SIDL, SZOMB do nothing with the signal,
a1965 1
		case SZOMB:
@


1.166
log
@Add PS_SYSTEM, the process-level mirror of the thread-level P_SYSTEM,
and FORK_SYSTEM as a flag to set them.  This eliminates needing to
peek into other processes threads in various places.  Inspired by NetBSD

ok miod@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.165 2014/05/04 03:53:37 deraadt Exp $	*/
d764 11
@


1.165
log
@When kern.nosuidcoredump=3, act like =2 but try to dump cores into
the /var/crash/programname/ directory, as root. For instance,
    # mkdir /var/crash/bgpd/
    # chmod 700 /var/crash/bgpd/    # If you skip this step, you are a moron
    # sysctl kern.nosuidcoredump=3
    # bgpd
    # pkill -ABRT bgpd
    # ls /var/crash/bgpd/
    14764.core   23207.core   6423.core
Of course, in real life the idea is that you don't kill the daemon but it
crashes and you collect parallel cores.  Careful you don't fill your /var.
Further tuneables are being considered.

Sorry to be picking on bgpd for this example.  I've watched the "too
difficult to debug privsep code" angst for far too long.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.164 2014/04/18 11:51:17 guenther Exp $	*/
a620 1
	struct proc *p;
d630 1
a630 2
			p = pr->ps_mainproc;
			if (pr->ps_pid <= 1 || p->p_flag & P_SYSTEM ||
d635 1
a635 1
				psignal(p, signum);
d649 1
a649 2
			p = pr->ps_mainproc;
			if (pr->ps_pid <= 1 || p->p_flag & P_SYSTEM ||
d653 2
a654 2
			if (signum && P_ZOMBIE(p) == 0)
				psignal(p, signum);
@


1.164
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.163 2014/03/30 21:54:48 guenther Exp $	*/
d54 1
d1450 3
a1452 3
	int error, len;
	char name[sizeof("/var/crash/") + MAXCOMLEN + sizeof(".core")];
	char *dir = "";
d1457 2
a1458 3
	 * Don't dump if not root and the process has used set user or
	 * group privileges, unless the nosuidcoredump sysctl is set to 2,
	 * in which case dumps are put into /var/crash/.
d1462 2
a1463 2
		if (nosuidcoredump == 2)
			dir = "/var/crash/";
d1473 12
a1484 1
	len = snprintf(name, sizeof(name), "%s%s.core", dir, p->p_comm);
d1489 3
a1491 1
	 * ... but actually write it as UID
d1493 16
a1508 3
	cred = crdup(cred);
	cred->cr_uid = cred->cr_ruid;
	cred->cr_gid = cred->cr_rgid;
@


1.163
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.162 2014/03/26 05:27:18 guenther Exp $	*/
d82 1
a82 1
int cansignal(struct process *, struct process *, int);
d90 1
a90 1
cansignal(struct process *pr, struct process *qr, int signum)
d92 2
a93 1
	struct ucred *uc = pr->ps_ucred;
d593 1
a593 1
			if (!cansignal(cp->p_p, p->p_p, signum))
d632 1
a632 1
			    pr == cp->p_p || !cansignal(cp->p_p, pr, signum))
d652 1
a652 1
			    !cansignal(cp->p_p, pr, signum))
@


1.162
log
@Simply cansignal(), passing it processes instead of procs and
dropping the pcred argument.  Fix handling of kill(-1, sig) from a
thread other than the original thread.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.161 2014/03/26 05:23:42 guenther Exp $	*/
d87 1
a87 1
 * Can process pr, send the signal signum to process qr?
d92 2
a93 1
	struct pcred *pc = pr->ps_cred;
d95 1
a95 1
	if (pc->pc_ucred->cr_uid == 0)
d101 4
d126 2
a127 2
			if (pc->p_ruid == qr->ps_cred->p_ruid ||
			    pc->pc_ucred->cr_uid == qr->ps_cred->p_ruid)
d133 4
a136 4
	if (pc->p_ruid == qr->ps_cred->p_ruid ||
	    pc->p_ruid == qr->ps_cred->p_svuid ||
	    pc->pc_ucred->cr_uid == qr->ps_cred->p_ruid ||
	    pc->pc_ucred->cr_uid == qr->ps_cred->p_svuid)
d587 1
d663 6
a668 6
	(uid) == (pr)->ps_cred->p_ruid || \
	(uid) == (pr)->ps_cred->p_svuid || \
	(uid) == (pr)->ps_cred->pc_ucred->cr_uid || \
	(euid) == (pr)->ps_cred->p_ruid || \
	(euid) == (pr)->ps_cred->p_svuid || \
	(euid) == (pr)->ps_cred->pc_ucred->cr_uid)
d1480 2
a1481 2
	cred->cr_uid = p->p_cred->p_ruid;
	cred->cr_gid = p->p_cred->p_rgid;
@


1.161
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.160 2014/03/24 03:48:00 guenther Exp $	*/
d82 1
a82 1
int cansignal(struct proc *, struct pcred *, struct proc *, int);
d87 1
a87 1
 * Can process p, with pcred pc, send the signal signum to process q?
d90 1
a90 1
cansignal(struct proc *p, struct pcred *pc, struct proc *q, int signum)
d92 2
d97 1
a97 1
	if (p == q)
d100 1
a100 1
	if (signum == SIGCONT && q->p_p->ps_session == p->p_p->ps_session)
d107 1
a107 1
	if (q->p_p->ps_flags & PS_SUGID) {
d121 2
a122 2
			if (pc->p_ruid == q->p_cred->p_ruid ||
			    pc->pc_ucred->cr_uid == q->p_cred->p_ruid)
d128 4
a131 4
	if (pc->p_ruid == q->p_cred->p_ruid ||
	    pc->p_ruid == q->p_cred->p_svuid ||
	    pc->pc_ucred->cr_uid == q->p_cred->p_ruid ||
	    pc->pc_ucred->cr_uid == q->p_cred->p_svuid)
a560 1
	struct pcred *pc = cp->p_cred;
d586 1
a586 1
			if (!cansignal(cp, pc, p, signum))
a614 1
	struct pcred *pc = cp->p_cred;
d624 2
a625 2
			if (p->p_pid <= 1 || p->p_flag & P_SYSTEM ||
			    p == cp || !cansignal(cp, pc, p, signum))
d644 2
a645 2
			if (p->p_pid <= 1 || p->p_flag & (P_SYSTEM|P_THREAD) ||
			    !cansignal(cp, pc, p, signum))
@


1.160
log
@The kernel isn't involved in times(3); <sys/times.h> should never be
included there
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.159 2014/03/22 06:05:45 guenther Exp $	*/
d745 1
a745 1
		(*p->p_emul->e_sendsig)(ps->ps_sigact[signum], signum,
d1289 2
a1290 1
	struct sigacts *ps = p->p_p->ps_sigacts;
d1379 1
a1379 1
		(*p->p_emul->e_sendsig)(action, signum, returnmask, trapno,
d1435 1
d1446 1
a1446 1
	p->p_p->ps_flags |= PS_COREDUMP;
d1453 2
a1454 2
	if (((p->p_p->ps_flags & PS_SUGID) && (error = suser(p, 0))) ||
	   ((p->p_p->ps_flags & PS_SUGID) && nosuidcoredump)) {
d1505 1
a1505 1
	p->p_p->ps_acflag |= ACORE;
d1515 1
a1515 1
		error = (*p->p_emul->e_coredump)(p, &io);
@


1.159
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.158 2014/02/09 11:17:19 kettenis Exp $	*/
a50 1
#include <sys/times.h>
@


1.158
log
@Fix the lock order reversal problem in the code that stops traced
multi-threaded  processes when they receive a signal:

1. Make the parent of the process (the tracer) wait for all threads to be
   stopped (in wait4(2)) instead of the thread that received the signal.
   This prevents us from calling tsleep(9) recursively.

2. Assume that we already hold the kernel lock if the P_SINTR flag is set
   (just like we already assumed we were holding the scheduler lock) and
   don't try to grab it again.

This should fix the panic that many people reported when debugging
multi-threaded programs with gdb(1).

ok & lots of help from guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.157 2014/01/21 01:48:44 tedu Exp $	*/
d152 1
a152 1
sigactsinit(struct proc *p)
d157 1
a157 1
	memcpy(ps, p->p_sigacts, sizeof(struct sigacts));
d166 1
a166 1
sigactsshare(struct proc *p)
d168 4
a171 2
	p->p_sigacts->ps_refcnt++;
	return p->p_sigacts;
d190 1
a190 1
sigactsunshare(struct proc *p)
d194 1
a194 1
	if (p->p_sigacts->ps_refcnt == 1)
d197 3
a199 3
	newps = sigactsinit(p);
	sigactsfree(p);
	p->p_sigacts = newps;
d206 1
a206 1
sigactsfree(struct proc *p)
d208 1
a208 1
	struct sigacts *ps = p->p_sigacts;
d213 1
a213 1
	p->p_sigacts = NULL;
d234 1
a234 1
	struct sigacts *ps = p->p_sigacts;
d296 1
a296 1
	struct sigacts *ps = p->p_sigacts;
d320 1
d322 1
a322 1
		if (initproc->p_sigacts != ps &&
d372 1
a372 1
siginit(struct proc *p)
d374 1
a374 1
	struct sigacts *ps = p->p_sigacts;
d384 1
a384 1
 * Reset signals for an exec of the specified process.
d392 2
a393 2
	sigactsunshare(p);
	ps = p->p_sigacts;
d481 2
a482 1
	struct sigacts *ps = p->p_sigacts;
d728 2
a729 1
	struct sigacts *ps = p->p_sigacts;
d733 1
a733 1
	if ((p->p_p->ps_flags & PS_TRACED) == 0 &&
d882 1
a882 1
		if (p->p_sigacts->ps_sigignore & mask)
d886 1
a886 1
		} else if (p->p_sigacts->ps_sigcatch & mask) {
d1105 1
a1105 1
		if (mask & p->p_sigacts->ps_sigignore &&
d1161 1
a1161 1
		switch ((long)p->p_sigacts->ps_sigact[signum]) {
d1276 1
a1276 2
		if ((pr->ps_pptr->ps_mainproc->p_sigacts->ps_flags &
		    SAS_NOCLDSTOP) == 0)
d1290 1
a1290 1
	struct sigacts *ps = p->p_sigacts;
@


1.157
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.156 2014/01/20 21:19:28 guenther Exp $	*/
d1074 3
d1111 5
a1115 3
			KERNEL_LOCK();
			single_thread_set(p, SINGLE_SUSPEND, 0);
			KERNEL_UNLOCK();
d1123 2
a1124 1
			KERNEL_LOCK();
d1126 2
a1127 1
			KERNEL_UNLOCK();
d1839 2
d1852 4
d1861 1
d1904 2
a1905 1
				if (mode == SINGLE_SUSPEND) {
d1931 9
a1942 1
	return 0;
d1952 4
a1955 1
	
@


1.156
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.155 2013/10/08 03:50:07 guenther Exp $	*/
d1677 1
a1677 1
		bzero(&si, sizeof si);
d1687 1
a1687 1
	bzero(si, sizeof *si);
@


1.155
log
@Fix delivery of SIGPROF and SIGVTALRM to threaded processes by having
hardclock() set a flag on the running thread and force AST processing,
and then have the thread signal itself from userret().

idea and flag names from FreeBSD
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.154 2013/10/08 03:36:48 guenther Exp $	*/
d619 3
a621 2
		LIST_FOREACH(p, &allproc, p_list) {
			if (p->p_pid <= 1 || p->p_flag & (P_SYSTEM|P_THREAD) ||
d1226 1
d1234 3
a1236 2
	atomic_clearbits_int(&p->p_p->ps_flags, PS_WAITED);
	atomic_setbits_int(&p->p_flag, P_STOPPED|P_SUSPSIG);
d1257 1
a1257 1
	struct proc *p;
d1259 2
a1260 2
	LIST_FOREACH(p, &allproc, p_list) {
		if ((p->p_flag & P_STOPPED) == 0)
d1262 1
a1262 1
		atomic_clearbits_int(&p->p_flag, P_STOPPED);
d1264 1
a1264 1
		if ((p->p_p->ps_pptr->ps_mainproc->p_sigacts->ps_flags &
d1266 2
a1267 2
			prsignal(p->p_p->ps_pptr, SIGCHLD);
		wakeup(p->p_p->ps_pptr);
@


1.154
log
@If a thread sends a signal to its own process, then have that thread
take the signal by preference if it's eligible (unblocked or sigwaiting).

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.153 2013/10/06 19:44:42 guenther Exp $	*/
d1750 14
@


1.153
log
@Tweak comment
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.152 2013/06/01 04:05:26 tedu Exp $	*/
d814 3
a816 6
		 * A process-wide signal can be diverted to a different
		 * thread that's in sigwait() for this signal.  If there
		 * isn't such a thread, then pick a thread that doesn't
		 * have it blocked so that the stop/kill consideration
		 * isn't delayed.  Otherwise, mark it pending on the
		 * main thread.
d818 28
a845 9
		TAILQ_FOREACH(q, &pr->ps_threads, p_thr_link) {
			/* ignore exiting threads */
			if (q->p_flag & P_WEXIT)
				continue;

			/* sigwait: definitely go to this thread */
			if (q->p_sigdivert & mask) {
				p = q;
				break;
a846 4

			/* unblocked: possibly go to this thread */
			if ((q->p_sigmask & mask) == 0)
				p = q;
@


1.152
log
@some small style changes that are distracting me from seeing a real bug
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.151 2013/04/29 17:06:20 matthew Exp $	*/
d1082 1
a1082 1
		 * only if P_TRACED was on when they were posted.
@


1.151
log
@Extend P_SIGSUSPEND handling in userret() to properly restore the
sigmask even if there are no pending signals under the temporary
sigmask.

Refactor existing select() and poll() system calls to introduce the
pselect() and ppoll() system calls.

Add rthread wrappers for pselect() and ppoll().  While there, update
cancellation point comments to reflect recent fdatasync() addition.

Minor bumps for libc and librthread due to new symbols.

ok guenther, millert, deraadt, jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.150 2013/04/06 06:08:20 tedu Exp $	*/
d866 1
a866 1
		if (p->p_sigmask & mask)
d868 1
a868 1
		else if (p->p_sigacts->ps_sigcatch & mask)
d870 1
a870 1
		else {
d889 1
a889 1
	if (prop & SA_CONT) {
a890 1
	}
d900 2
a901 2
	if (prop & (SA_CONT | SA_STOP) && type != SPROPAGATED) {
		TAILQ_FOREACH(q, &pr->ps_threads, p_thr_link) {
a903 2
		}
	}
a1136 1

a1179 1

a1189 1

d1334 1
a1334 1
		} else
d1336 1
d1562 1
a1562 1
			    len, data, (long long) io->io_offset, error);
@


1.150
log
@i missed a file, crap.  found by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.149 2013/03/28 16:55:25 deraadt Exp $	*/
d1746 14
@


1.149
log
@do not include machine/cpu.h from a .c file; it is the responsibility of
.h files to pull it in, if needed
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.148 2013/02/08 04:30:37 guenther Exp $	*/
a1613 3

	if (!rthreads_enabled)
		return (ENOTSUP);
@


1.148
log
@Insufficient levels of hops in the local brew led to Theo and I mucking
up the VFS calls in the error paths in coredump()

Pointed out by armani@@, ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.147 2013/01/15 02:03:38 deraadt Exp $	*/
a68 1
#include <machine/cpu.h>
@


1.147
log
@Allow SIGKILL to terminate coredumping processes.  Semantics decided
with kettenis guenther and beck.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.146 2013/01/15 01:34:27 deraadt Exp $	*/
d1460 2
a1461 4
	if (error) {
		crfree(cred);
		return (error);
	}
d1468 3
a1470 1
	if ((error = VOP_GETATTR(vp, &vattr, cred, p)) != 0)
d1472 1
d1477 2
d1493 3
a1495 6
	if (error) {
		vrele(vp);
		return (error);
	}

	error = (*p->p_emul->e_coredump)(p, &io);
a1497 1
	vrele(vp);
@


1.146
log
@Slice & dice coredump write requests into MAXPHYS blocks, and
yield between operations.  Re-grab the vnode every operation,
so that multiple coredumps can be saved at the same time.
ok guenther beck etc
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.145 2012/12/02 07:03:32 guenther Exp $	*/
d806 8
d1425 2
d1553 3
@


1.145
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.144 2012/10/17 04:48:52 guenther Exp $	*/
d1413 1
a1413 1
	int error, error1, len;
d1477 7
a1486 2
	VOP_UNLOCK(vp, 0, p);
	error1 = vn_close(vp, FWRITE, cred, p);
d1488 1
a1488 2
	if (error == 0)
		error = error1;
d1527 1
a1527 1
	    UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, NULL, p);
d1537 22
a1558 1
	int error;
d1560 3
a1562 10
	error = vn_rdwr(UIO_WRITE, io->io_vp, (void *)data, len,
	    io->io_offset, segflg,
	    IO_NODELOCKED|IO_UNIT, io->io_cred, NULL, io->io_proc);
	if (error) {
		printf("pid %d (%s): %s write of %lu@@%p at %lld failed: %d\n",
		    io->io_proc->p_pid, io->io_proc->p_comm,
		    segflg == UIO_USERSPACE ? "user" : "system",
		    len, data, (long long) io->io_offset, error);
		return (error);
	}
d1567 9
@


1.144
log
@If a thread calls __threxit() or _exit() immediately after another
thread coredumps, the former thread needs to be released by the
later single_thread_set(SINGLE_EXIT) call, even though its P_WEXIT
flag is set.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.143 2012/07/11 08:45:21 guenther Exp $	*/
d64 1
d498 9
d516 1
d522 7
a528 2
	if (oss && (error = copyout(&p->p_sigstk, oss, sizeof(p->p_sigstk))))
		return (error);
d534 1
a534 1
	if (p->p_sigstk.ss_flags & SS_ONSTACK)
@


1.143
log
@exit1(EXIT_THREAD) needs to call single_thread_check() so that it
can be suspended and/or decrement pr->ps_singlecount if necessary.
With that added, the call the other direction needs to use its own
flag (EXIT_THREAD_NOCHECK) to avoid looping.

problem diagnosed from a hang naddy@@ hit; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.142 2012/06/06 04:47:43 guenther Exp $	*/
d1777 1
a1777 1
		if (q == p || ISSET(q->p_flag, P_WEXIT))
d1779 11
@


1.142
log
@EVFILT_SIGNAL and EVFILT_PROC events need to track the process they're
attached to and not just the thread, which can go away.

Problem observed by jsg@@; ok jsg@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.141 2012/04/13 16:37:51 kettenis Exp $	*/
d1725 1
a1725 1
				exit1(p, 0, EXIT_THREAD);
@


1.141
log
@First stab at making ptrace(2) usable for debugging multi-threaded programs.
It implements a full-stop model where all threads are stopped before handing
over control to the debugger.  Events are reported as before through wait(2);
you will have to call ptrace(PT_GET_PROCESS_STATE, ...) to find out which
thread hit the event.  Since this changes the size of struct ptrace_state,
you will have to recompile gdb.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.140 2012/04/12 10:11:41 mikeb Exp $	*/
d1650 1
a1650 1
	struct proc *p = curproc;
d1652 1
a1652 1
	kn->kn_ptr.p_proc = p;
d1656 1
a1656 1
	SLIST_INSERT_HEAD(&p->p_p->ps_klist, kn, kn_selnext);
d1664 1
a1664 1
	struct proc *p = kn->kn_ptr.p_proc;
d1666 1
a1666 1
	SLIST_REMOVE(&p->p_p->ps_klist, kn, knote, kn_selnext);
@


1.140
log
@move accounting flags to struct process; idea and ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.139 2012/04/11 15:28:50 kettenis Exp $	*/
d1075 4
d1085 4
d1777 1
a1777 1
		if (q == p)
d1823 1
a1823 1
single_thread_clear(struct proc *p)
d1845 1
a1845 1
		if (q->p_stat == SSTOP && (q->p_flag & P_SUSPSIG) == 0) {
@


1.139
log
@Move the P_WAITED flag from struct proc to struct process.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.138 2012/03/23 15:51:26 guenther Exp $	*/
d1348 1
a1348 1
	p->p_acflag |= AXSIG;
d1447 1
a1447 1
	p->p_acflag |= ACORE;
@


1.138
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.137 2012/03/19 09:05:39 guenther Exp $	*/
d1195 1
a1195 1
	atomic_clearbits_int(&p->p_flag, P_WAITED);
@


1.137
log
@Add tracing and dumping of "pointer to struct" syscall arguments for
structs timespec, timeval, sigaction, and rlimit.

ok otto@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.136 2012/03/10 06:27:21 guenther Exp $	*/
d724 1
a724 1
		p->p_stats->p_ru.ru_nsignals++;
d1319 1
a1319 1
		p->p_stats->p_ru.ru_nsignals++;
@


1.136
log
@Give sigwait priority over ptrace to avoid panic
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.135 2012/03/10 05:54:28 guenther Exp $	*/
d226 3
d269 4
d278 4
d284 4
d1575 4
@


1.135
log
@Add PS_EXITING to better differentiate between the process exiting and
the main thread exiting.  c.f. regress/sys/kern/main-thread-exited/
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.134 2012/02/20 22:23:39 guenther Exp $	*/
d807 2
d810 1
a810 4
	if (pr->ps_flags & PS_TRACED) {
		action = SIG_DFL;
		atomic_setbits_int(&p->p_siglist, mask);
	} else if (p->p_sigdivert & mask) {
d815 3
@


1.134
log
@First steps for making ptrace work with rthreads:
 - move the P_TRACED and P_INEXEC flags, and p_oppid, p_ptmask, and
   p_ptstat member from struct proc to struct process
 - sort the PT_* requests into those that take a PID vs those that
   can also take a TID
 - stub in PT_GET_THREAD_FIRST and PT_GET_THREAD_NEXT

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.133 2012/01/25 06:12:13 guenther Exp $	*/
d759 1
a759 1
	struct process *pr;
d769 1
a769 1
	if (p->p_flag & P_WEXIT)
a773 1
	pr = p->p_p;
@


1.133
log
@A signal handled by __thrsigdivert() shouldn't be marked pending
for the thread handling it.  Otherwise (i.e., no sig divert), prefer
to deliver a process-aimed signal to some thread which doesn't have
the signal blocked.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.132 2012/01/17 02:34:18 guenther Exp $	*/
d697 2
a698 1
	if ((p->p_flag & P_TRACED) == 0 && (ps->ps_sigcatch & mask) != 0 &&
d809 1
a809 1
	if (p->p_flag & P_TRACED) {
d894 1
a894 1
		if (p->p_flag & P_TRACED)
d933 1
a933 1
		if (p->p_flag & P_TRACED)
d939 2
a940 1
		if (signum == SIGKILL)
d942 1
d956 1
d1029 1
d1036 1
a1036 1
		if (p->p_p->ps_flags & PS_PPWAIT)
d1049 1
a1049 1
		    (p->p_flag & P_TRACED) == 0)
d1052 1
a1052 2
		if (p->p_flag & P_TRACED &&
		    (p->p_p->ps_flags & PS_PPWAIT) == 0) {
d1069 1
a1069 1
			if ((p->p_flag & P_TRACED) == 0 || p->p_xstat == 0)
d1117 2
a1118 2
				if (p->p_flag & P_TRACED ||
		    		    (p->p_p->ps_pgrp->pg_jobc == 0 &&
d1145 1
a1145 1
			    (p->p_flag & P_TRACED) == 0)
@


1.132
log
@Reimplement mutexes, condvars, and rwlocks to eliminate bugs,
particularly the "consume the signal you just sent" hang, and putting
the wait queues in userspace.

Do cancellation handling in pthread_cond_*wait(), pthread_join(),
and sem_wait().

Add __ prefix to thr{sleep,wakeup,exit,sigdivert}() syscalls; add
'abort" argument to thrsleep to close cancellation race; make
thr{sleep,wakeup} return errno values via *retval to avoid touching
userspace errno.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.131 2011/12/11 19:42:28 guenther Exp $	*/
d758 1
d773 1
d775 9
a783 1
		TAILQ_FOREACH(q, &p->p_p->ps_threads, p_thr_link) {
d787 2
a789 2
				/* sigwait: convert to thread-specific */
				type = STHREAD;
d793 4
d801 1
a801 1
		KNOTE(&p->p_p->ps_klist, NOTE_SIGNAL | signum);
d808 1
a808 1
	if (p->p_flag & P_TRACED)
d810 2
a811 1
	else if (p->p_sigdivert & mask) {
d833 2
a834 2
			if (prop & SA_KILL &&  p->p_p->ps_nice > NZERO)
				 p->p_p->ps_nice = NZERO;
d842 1
a842 1
			if (prop & SA_TTYSTOP && p->p_p->ps_pgrp->pg_jobc == 0)
d845 2
a857 2
	atomic_setbits_int(&p->p_siglist, mask);

d862 1
a862 1
		TAILQ_FOREACH(q, &p->p_p->ps_threads, p_thr_link) {
d913 1
a913 1
			if (p->p_p->ps_flags & PS_PPWAIT)
d1007 1
a1007 1
		wakeup(p->p_p->ps_pptr);
@


1.131
log
@Suspend other rthreads before dumping core or execing; make them exit
when exec succeeds.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.130 2011/11/22 23:20:19 joshe Exp $	*/
d1506 1
a1506 1
sys_thrsigdivert(struct proc *p, void *v, register_t *retval)
d1508 1
a1508 1
	struct sys_thrsigdivert_args /* {
@


1.130
log
@Move struct proc's sigaltstack struct from the zeroed area into the
copied area, and initialize it properly in the FORK_THREAD case.

This restores the behavior of a forked process inheriting its parent's
signal stack.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.129 2011/11/16 20:50:19 deraadt Exp $	*/
d1161 1
a1161 1
	atomic_setbits_int(&p->p_flag, P_STOPPED);
d1316 6
d1649 6
d1656 150
@


1.129
log
@Make userret() MI.  On architectures which jammed stuff into it in the
past, pull that code out seperately.
ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.128 2011/11/09 20:57:38 guenther Exp $	*/
d173 11
d397 1
a397 3
	p->p_sigstk.ss_flags = SS_DISABLE;
	p->p_sigstk.ss_size = 0;
	p->p_sigstk.ss_sp = 0;
@


1.128
log
@Change fork1() and kthread_create() to match the rest of the tree
and use curp vs p instead of p1 vs p2.  Add curpr and pr variables
for the respective struct processes.  Make sigactsshare() return
the shared sigacts intead of taking the struct proc to update.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.127 2011/09/20 10:07:37 deraadt Exp $	*/
d1624 11
@


1.127
log
@MD trap() passes a MD "traptype" and siginfo-style "code" up to the MI
layers.  Then things get terribly confusing because the various MI layers
swap variable names for parameters, local variables, and structure fields
numerous times.  Unconfuse all this mess.

Note that exec_elf.c coredump cpi_sigcode used to contain the MD traptype
but will now contain the MI siginfo-style "code" value.
ok miod kettenis pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.126 2011/07/11 15:40:47 guenther Exp $	*/
d163 1
a163 1
 * Make p2 share p1's sigacts.
d165 2
a166 2
void
sigactsshare(struct proc *p1, struct proc *p2)
d168 2
a169 3

	p2->p_sigacts = p1->p_sigacts;
	p1->p_sigacts->ps_refcnt++;
@


1.126
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.123 2011/07/06 21:41:37 art Exp $	*/
d682 1
a682 1
trapsignal(struct proc *p, int signum, u_long code, int type,
d695 1
a695 1
			initsiginfo(&si, signum, code, type, sigval);
d697 1
a697 1
			    p->p_sigmask, type, &si);
d702 1
a702 1
		    p->p_sigmask, code, type, sigval);
d712 2
a713 2
		p->p_sicode = code;	/* XXX for core dump/debugger */
		p->p_sitype = type;
d1198 1
a1198 1
	u_long code;
d1201 1
a1201 1
	int s, type;
a1213 1
	type = SI_USER;
d1216 2
a1217 2
		code = 0;
		type = SI_USER;
d1220 1
a1221 1
		type = p->p_sitype;
d1229 1
a1229 1
		initsiginfo(&si, signum, code, type, sigval);
d1231 1
a1231 1
		    p->p_oldmask : p->p_sigmask, type, &si);
d1279 2
a1280 2
			p->p_sicode = 0;
			p->p_sitype = SI_USER;
d1284 2
a1285 2
		(*p->p_emul->e_sendsig)(action, signum, returnmask, code,
		    type, sigval);
d1433 1
a1433 1
	core.c_ucode = p->p_sicode;
d1563 1
a1563 1
initsiginfo(siginfo_t *si, int sig, u_long code, int type, union sigval val)
d1568 2
a1569 2
	si->si_code = type;
	if (type == SI_USER) {
d1578 1
a1578 1
			si->si_trapno = code;
@


1.125
log
@More syscalls.master cleanup:

sys_osigaltstack() is 7 years old and no longer needed; all glory to
the sys_sigaltstack()!

sys_ogetdirentries() is about 9 months old, but still acceptable
within our release cycle; move from STD to COMPAT_48 to make this
clearer for tedu@@ next year.

sys_sbrk() and sys_sstk() are completely obsolete: all they do is
return ENOSYS.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.124 2011/07/07 18:11:24 art Exp $	*/
d685 1
a685 1
	struct sigacts *ps;
a687 2
	KERNEL_LOCK();
	ps = p->p_sigacts;
a716 1
	KERNEL_UNLOCK();
@


1.124
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.123 2011/07/06 21:41:37 art Exp $	*/
a470 44
}

/* ARGSUSED */
int
sys_osigaltstack(struct proc *p, void *v, register_t *retval)
{
	struct sys_osigaltstack_args /* {
		syscallarg(const struct osigaltstack *) nss;
		syscallarg(struct osigaltstack *) oss;
	} */ *uap = v;
	struct osigaltstack ss;
	const struct osigaltstack *nss;
	struct osigaltstack *oss;
	int error;

	nss = SCARG(uap, nss);
	oss = SCARG(uap, oss);

	if (oss) {
		ss.ss_sp = p->p_sigstk.ss_sp;
		ss.ss_size = p->p_sigstk.ss_size;
		ss.ss_flags = p->p_sigstk.ss_flags;
		if ((error = copyout(&ss, oss, sizeof(ss))))
			return (error);
	}
	if (nss == NULL)
		return (0);
	error = copyin(nss, &ss, sizeof(ss));
	if (error)
		return (error);
	if (p->p_sigstk.ss_flags & SS_ONSTACK)
		return (EPERM);
	if (ss.ss_flags & ~SS_DISABLE)
		return (EINVAL);
	if (ss.ss_flags & SS_DISABLE) {
		p->p_sigstk.ss_flags = ss.ss_flags;
		return (0);
	}
	if (ss.ss_size < MINSIGSTKSZ)
		return (ENOMEM);
	p->p_sigstk.ss_sp = ss.ss_sp;
	p->p_sigstk.ss_size = ss.ss_size;
	p->p_sigstk.ss_flags = ss.ss_flags;
	return (0);
@


1.123
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.122 2011/07/05 04:48:02 guenther Exp $	*/
d729 1
a729 1
	struct sigacts *ps = p->p_sigacts;
d732 2
d763 1
@


1.122
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.121 2011/04/18 21:44:56 guenther Exp $	*/
d1252 1
a1252 1
	KERNEL_PROC_LOCK(p);
d1333 1
a1333 1
	KERNEL_PROC_UNLOCK(p);
@


1.121
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.119 2011/04/03 14:56:28 guenther Exp $	*/
d245 1
a245 1
			if ((p->p_flag & P_NOCLDSTOP) != 0)
d247 1
a247 1
			if ((p->p_flag & P_NOCLDWAIT) != 0)
d284 1
a284 1
			atomic_setbits_int(&p->p_flag, P_NOCLDSTOP);
d286 1
a286 1
			atomic_clearbits_int(&p->p_flag, P_NOCLDSTOP);
d291 1
a291 1
		 * init to do our dirty work we never set P_NOCLDWAIT
d294 2
a295 1
		if (p->p_pid != 1 && ((sa->sa_flags & SA_NOCLDWAIT) ||
d297 1
a297 1
			atomic_setbits_int(&p->p_flag, P_NOCLDWAIT);
d299 1
a299 1
			atomic_clearbits_int(&p->p_flag, P_NOCLDWAIT);
d318 1
a318 1
	 * Set bit in p_sigignore for signals that are set to SIG_IGN,
d320 1
a320 1
	 * However, don't put SIGCONT in p_sigignore,
d327 2
a328 2
			p->p_sigignore |= bit;	/* easier in psignal */
		p->p_sigcatch &= ~bit;
d330 1
a330 1
		p->p_sigignore &= ~bit;
d332 1
a332 1
			p->p_sigcatch &= ~bit;
d334 1
a334 1
			p->p_sigcatch |= bit;
d346 1
d351 2
a352 1
			p->p_sigignore |= sigmask(i);
d372 2
a373 2
	while (p->p_sigcatch) {
		nc = ffs((long)p->p_sigcatch);
d375 1
a375 1
		p->p_sigcatch &= ~mask;
d378 1
a378 1
				p->p_sigignore |= mask;
d387 4
a390 5
	ps->ps_sigstk.ss_flags = SS_DISABLE;
	ps->ps_sigstk.ss_size = 0;
	ps->ps_sigstk.ss_sp = 0;
	ps->ps_flags = 0;
	atomic_clearbits_int(&p->p_flag, P_NOCLDWAIT);
d464 2
a465 2
	ps->ps_oldmask = p->p_sigmask;
	ps->ps_flags |= SAS_OLDMASK;
a480 1
	struct sigacts *psp;
a488 3
	psp = p->p_sigacts;
	if ((psp->ps_flags & SAS_ALTSTACK) == 0)
		psp->ps_sigstk.ss_flags |= SS_DISABLE;
d490 3
a492 3
		ss.ss_sp = psp->ps_sigstk.ss_sp;
		ss.ss_size = psp->ps_sigstk.ss_size;
		ss.ss_flags = psp->ps_sigstk.ss_flags;
d501 4
d506 1
a506 4
		if (psp->ps_sigstk.ss_flags & SS_ONSTACK)
			return (EINVAL);
		psp->ps_flags &= ~SAS_ALTSTACK;
		psp->ps_sigstk.ss_flags = ss.ss_flags;
d511 3
a513 4
	psp->ps_flags |= SAS_ALTSTACK;
	psp->ps_sigstk.ss_sp = ss.ss_sp;
	psp->ps_sigstk.ss_size = ss.ss_size;
	psp->ps_sigstk.ss_flags = ss.ss_flags;
a523 1
	struct sigacts *psp;
d532 1
a532 5
	psp = p->p_sigacts;
	if ((psp->ps_flags & SAS_ALTSTACK) == 0)
		psp->ps_sigstk.ss_flags |= SS_DISABLE;
	if (oss && (error = copyout(&psp->ps_sigstk,
	    oss, sizeof(struct sigaltstack))))
d539 4
d544 1
a544 4
		if (psp->ps_sigstk.ss_flags & SS_ONSTACK)
			return (EINVAL);
		psp->ps_flags &= ~SAS_ALTSTACK;
		psp->ps_sigstk.ss_flags = ss.ss_flags;
d549 1
a549 2
	psp->ps_flags |= SAS_ALTSTACK;
	psp->ps_sigstk = ss;
d733 1
a733 1
	if ((p->p_flag & P_TRACED) == 0 && (p->p_sigcatch & mask) != 0 &&
d749 1
a749 1
			p->p_sigcatch &= ~mask;
d751 1
a751 1
				p->p_sigignore |= mask;
d755 4
a758 4
		ps->ps_sig = signum;
		ps->ps_code = code;	/* XXX for core dump/debugger */
		ps->ps_type = type;
		ps->ps_sigval = sigval;
d841 1
a841 1
		 * (Note: we don't set SIGCONT in p_sigignore,
d845 1
a845 1
		if (p->p_sigignore & mask)
d849 1
a849 1
		else if (p->p_sigcatch & mask)
d1064 2
a1065 1
		if (mask & p->p_sigignore && (p->p_flag & P_TRACED) == 0)
d1225 2
a1226 1
		if ((p->p_p->ps_pptr->ps_mainproc->p_flag & P_NOCLDSTOP) == 0)
d1260 1
a1260 1
	if (ps->ps_sig != signum) {
d1265 3
a1267 3
		code = ps->ps_code;
		type = ps->ps_type;
		sigval = ps->ps_sigval;
d1275 2
a1276 2
		ktrpsig(p, signum, action, ps->ps_flags & SAS_OLDMASK ?
		    ps->ps_oldmask : p->p_sigmask, type, &si);
d1308 3
a1310 3
		if (ps->ps_flags & SAS_OLDMASK) {
			returnmask = ps->ps_oldmask;
			ps->ps_flags &= ~SAS_OLDMASK;
d1315 1
a1315 1
			p->p_sigcatch &= ~mask;
d1317 1
a1317 1
				p->p_sigignore |= mask;
d1322 5
a1326 5
		if (ps->ps_sig == signum) {
			ps->ps_sig = 0;
			ps->ps_code = 0;
			ps->ps_type = SI_USER;
			ps->ps_sigval.sival_ptr = NULL;
d1352 1
a1352 1
		p->p_sigacts->ps_sig = signum;
d1477 2
a1478 2
	core.c_signo = p->p_sigacts->ps_sig;
	core.c_ucode = p->p_sigacts->ps_code;
@


1.120
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d245 1
a245 1
			if ((ps->ps_flags & SAS_NOCLDSTOP) != 0)
d247 1
a247 1
			if ((ps->ps_flags & SAS_NOCLDWAIT) != 0)
d284 1
a284 1
			atomic_setbits_int(&ps->ps_flags, SAS_NOCLDSTOP);
d286 1
a286 1
			atomic_clearbits_int(&ps->ps_flags, SAS_NOCLDSTOP);
d291 1
a291 1
		 * init to do our dirty work we never set SAS_NOCLDWAIT
d294 1
a294 2
		if (initproc->p_sigacts != ps &&
		    ((sa->sa_flags & SA_NOCLDWAIT) ||
d296 1
a296 1
			atomic_setbits_int(&ps->ps_flags, SAS_NOCLDWAIT);
d298 1
a298 1
			atomic_clearbits_int(&ps->ps_flags, SAS_NOCLDWAIT);
d317 1
a317 1
	 * Set bit in ps_sigignore for signals that are set to SIG_IGN,
d319 1
a319 1
	 * However, don't put SIGCONT in ps_sigignore,
d326 2
a327 2
			ps->ps_sigignore |= bit;	/* easier in psignal */
		ps->ps_sigcatch &= ~bit;
d329 1
a329 1
		ps->ps_sigignore &= ~bit;
d331 1
a331 1
			ps->ps_sigcatch &= ~bit;
d333 1
a333 1
			ps->ps_sigcatch |= bit;
a344 1
	struct sigacts *ps = p->p_sigacts;
d349 1
a349 2
			ps->ps_sigignore |= sigmask(i);
	ps->ps_flags = SAS_NOCLDWAIT | SAS_NOCLDSTOP;
d369 2
a370 2
	while (ps->ps_sigcatch) {
		nc = ffs((long)ps->ps_sigcatch);
d372 1
a372 1
		ps->ps_sigcatch &= ~mask;
d375 1
a375 1
				ps->ps_sigignore |= mask;
d384 5
a388 4
	p->p_sigstk.ss_flags = SS_DISABLE;
	p->p_sigstk.ss_size = 0;
	p->p_sigstk.ss_sp = 0;
	ps->ps_flags &= ~SAS_NOCLDWAIT;
d462 2
a463 2
	p->p_oldmask = p->p_sigmask;
	atomic_setbits_int(&p->p_flag, P_SIGSUSPEND);
d479 1
d488 3
d492 3
a494 3
		ss.ss_sp = p->p_sigstk.ss_sp;
		ss.ss_size = p->p_sigstk.ss_size;
		ss.ss_flags = p->p_sigstk.ss_flags;
a502 4
	if (p->p_sigstk.ss_flags & SS_ONSTACK)
		return (EPERM);
	if (ss.ss_flags & ~SS_DISABLE)
		return (EINVAL);
d504 4
a507 1
		p->p_sigstk.ss_flags = ss.ss_flags;
d512 4
a515 3
	p->p_sigstk.ss_sp = ss.ss_sp;
	p->p_sigstk.ss_size = ss.ss_size;
	p->p_sigstk.ss_flags = ss.ss_flags;
d526 1
d535 5
a539 1
	if (oss && (error = copyout(&p->p_sigstk, oss, sizeof(p->p_sigstk))))
a545 4
	if (p->p_sigstk.ss_flags & SS_ONSTACK)
		return (EPERM);
	if (ss.ss_flags & ~SS_DISABLE)
		return (EINVAL);
d547 4
a550 1
		p->p_sigstk.ss_flags = ss.ss_flags;
d555 2
a556 1
	p->p_sigstk = ss;
d740 1
a740 1
	if ((p->p_flag & P_TRACED) == 0 && (ps->ps_sigcatch & mask) != 0 &&
d756 1
a756 1
			ps->ps_sigcatch &= ~mask;
d758 1
a758 1
				ps->ps_sigignore |= mask;
d762 4
a765 4
		p->p_sisig = signum;
		p->p_sicode = code;	/* XXX for core dump/debugger */
		p->p_sitype = type;
		p->p_sigval = sigval;
d848 1
a848 1
		 * (Note: we don't set SIGCONT in ps_sigignore,
d852 1
a852 1
		if (p->p_sigacts->ps_sigignore & mask)
d856 1
a856 1
		else if (p->p_sigacts->ps_sigcatch & mask)
d1071 1
a1071 2
		if (mask & p->p_sigacts->ps_sigignore &&
		    (p->p_flag & P_TRACED) == 0)
d1231 1
a1231 2
		if ((p->p_p->ps_pptr->ps_mainproc->p_sigacts->ps_flags &
		    SAS_NOCLDSTOP) == 0)
d1265 1
a1265 1
	if (p->p_sisig != signum) {
d1270 3
a1272 3
		code = p->p_sicode;
		type = p->p_sitype;
		sigval = p->p_sigval;
d1280 2
a1281 2
		ktrpsig(p, signum, action, p->p_flag & P_SIGSUSPEND ?
		    p->p_oldmask : p->p_sigmask, type, &si);
d1313 3
a1315 3
		if (p->p_flag & P_SIGSUSPEND) {
			atomic_clearbits_int(&p->p_flag, P_SIGSUSPEND);
			returnmask = p->p_oldmask;
d1320 1
a1320 1
			ps->ps_sigcatch &= ~mask;
d1322 1
a1322 1
				ps->ps_sigignore |= mask;
d1327 5
a1331 5
		if (p->p_sisig == signum) {
			p->p_sisig = 0;
			p->p_sicode = 0;
			p->p_sitype = SI_USER;
			p->p_sigval.sival_ptr = NULL;
d1357 1
a1357 1
		p->p_sisig = signum;
d1482 2
a1483 2
	core.c_signo = p->p_sisig;
	core.c_ucode = p->p_sicode;
@


1.119
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.118 2011/04/02 17:04:35 guenther Exp $	*/
d245 1
a245 1
			if ((p->p_flag & P_NOCLDSTOP) != 0)
d247 1
a247 1
			if ((p->p_flag & P_NOCLDWAIT) != 0)
d284 1
a284 1
			atomic_setbits_int(&p->p_flag, P_NOCLDSTOP);
d286 1
a286 1
			atomic_clearbits_int(&p->p_flag, P_NOCLDSTOP);
d291 1
a291 1
		 * init to do our dirty work we never set P_NOCLDWAIT
d294 2
a295 1
		if (p->p_pid != 1 && ((sa->sa_flags & SA_NOCLDWAIT) ||
d297 1
a297 1
			atomic_setbits_int(&p->p_flag, P_NOCLDWAIT);
d299 1
a299 1
			atomic_clearbits_int(&p->p_flag, P_NOCLDWAIT);
d318 1
a318 1
	 * Set bit in p_sigignore for signals that are set to SIG_IGN,
d320 1
a320 1
	 * However, don't put SIGCONT in p_sigignore,
d327 2
a328 2
			p->p_sigignore |= bit;	/* easier in psignal */
		p->p_sigcatch &= ~bit;
d330 1
a330 1
		p->p_sigignore &= ~bit;
d332 1
a332 1
			p->p_sigcatch &= ~bit;
d334 1
a334 1
			p->p_sigcatch |= bit;
d346 1
d351 2
a352 1
			p->p_sigignore |= sigmask(i);
d372 2
a373 2
	while (p->p_sigcatch) {
		nc = ffs((long)p->p_sigcatch);
d375 1
a375 1
		p->p_sigcatch &= ~mask;
d378 1
a378 1
				p->p_sigignore |= mask;
d387 4
a390 5
	ps->ps_sigstk.ss_flags = SS_DISABLE;
	ps->ps_sigstk.ss_size = 0;
	ps->ps_sigstk.ss_sp = 0;
	ps->ps_flags = 0;
	atomic_clearbits_int(&p->p_flag, P_NOCLDWAIT);
d464 2
a465 2
	ps->ps_oldmask = p->p_sigmask;
	ps->ps_flags |= SAS_OLDMASK;
a480 1
	struct sigacts *psp;
a488 3
	psp = p->p_sigacts;
	if ((psp->ps_flags & SAS_ALTSTACK) == 0)
		psp->ps_sigstk.ss_flags |= SS_DISABLE;
d490 3
a492 3
		ss.ss_sp = psp->ps_sigstk.ss_sp;
		ss.ss_size = psp->ps_sigstk.ss_size;
		ss.ss_flags = psp->ps_sigstk.ss_flags;
d501 4
d506 1
a506 4
		if (psp->ps_sigstk.ss_flags & SS_ONSTACK)
			return (EINVAL);
		psp->ps_flags &= ~SAS_ALTSTACK;
		psp->ps_sigstk.ss_flags = ss.ss_flags;
d511 3
a513 4
	psp->ps_flags |= SAS_ALTSTACK;
	psp->ps_sigstk.ss_sp = ss.ss_sp;
	psp->ps_sigstk.ss_size = ss.ss_size;
	psp->ps_sigstk.ss_flags = ss.ss_flags;
a523 1
	struct sigacts *psp;
d532 1
a532 5
	psp = p->p_sigacts;
	if ((psp->ps_flags & SAS_ALTSTACK) == 0)
		psp->ps_sigstk.ss_flags |= SS_DISABLE;
	if (oss && (error = copyout(&psp->ps_sigstk,
	    oss, sizeof(struct sigaltstack))))
d539 4
d544 1
a544 4
		if (psp->ps_sigstk.ss_flags & SS_ONSTACK)
			return (EINVAL);
		psp->ps_flags &= ~SAS_ALTSTACK;
		psp->ps_sigstk.ss_flags = ss.ss_flags;
d549 1
a549 2
	psp->ps_flags |= SAS_ALTSTACK;
	psp->ps_sigstk = ss;
d733 1
a733 1
	if ((p->p_flag & P_TRACED) == 0 && (p->p_sigcatch & mask) != 0 &&
d749 1
a749 1
			p->p_sigcatch &= ~mask;
d751 1
a751 1
				p->p_sigignore |= mask;
d755 4
a758 4
		ps->ps_sig = signum;
		ps->ps_code = code;	/* XXX for core dump/debugger */
		ps->ps_type = type;
		ps->ps_sigval = sigval;
d841 1
a841 1
		 * (Note: we don't set SIGCONT in p_sigignore,
d845 1
a845 1
		if (p->p_sigignore & mask)
d849 1
a849 1
		else if (p->p_sigcatch & mask)
d1064 2
a1065 1
		if (mask & p->p_sigignore && (p->p_flag & P_TRACED) == 0)
d1225 2
a1226 1
		if ((p->p_p->ps_pptr->ps_mainproc->p_flag & P_NOCLDSTOP) == 0)
d1260 1
a1260 1
	if (ps->ps_sig != signum) {
d1265 3
a1267 3
		code = ps->ps_code;
		type = ps->ps_type;
		sigval = ps->ps_sigval;
d1275 2
a1276 2
		ktrpsig(p, signum, action, ps->ps_flags & SAS_OLDMASK ?
		    ps->ps_oldmask : p->p_sigmask, type, &si);
d1308 3
a1310 3
		if (ps->ps_flags & SAS_OLDMASK) {
			returnmask = ps->ps_oldmask;
			ps->ps_flags &= ~SAS_OLDMASK;
d1315 1
a1315 1
			p->p_sigcatch &= ~mask;
d1317 1
a1317 1
				p->p_sigignore |= mask;
d1322 5
a1326 5
		if (ps->ps_sig == signum) {
			ps->ps_sig = 0;
			ps->ps_code = 0;
			ps->ps_type = SI_USER;
			ps->ps_sigval.sival_ptr = NULL;
d1352 1
a1352 1
		p->p_sigacts->ps_sig = signum;
d1477 2
a1478 2
	core.c_signo = p->p_sigacts->ps_sig;
	core.c_ucode = p->p_sigacts->ps_code;
@


1.118
log
@Move P_SUGID and P_SUGIDEXEC from struct proc to struct process, so
that you can't evade the checks by doing the dirty work in an rthread

ok blambert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.117 2011/03/07 07:07:13 guenther Exp $	*/
d941 1
a941 1
			if (p->p_flag & P_PPWAIT)
d1059 1
a1059 1
		if (p->p_flag & P_PPWAIT)
d1074 2
a1075 1
		if (p->p_flag & P_TRACED && (p->p_flag & P_PPWAIT) == 0) {
@


1.117
log
@The scheduling 'nice' value is per-process, not per-thread, so move it
into struct process.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.116 2010/07/26 01:56:27 guenther Exp $	*/
d106 1
a106 1
	if (q->p_flag & P_SUGID) {
d1398 2
a1399 2
	if (((p->p_flag & P_SUGID) && (error = suser(p, 0))) ||
	   ((p->p_flag & P_SUGID) && nosuidcoredump)) {
@


1.116
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.115 2010/07/02 19:57:15 tedu Exp $	*/
d861 2
a862 2
			if (prop & SA_KILL && p->p_nice > NZERO)
				p->p_nice = NZERO;
@


1.115
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.114 2010/07/01 02:41:12 guenther Exp $	*/
d99 1
a99 1
	if (signum == SIGCONT && q->p_session == p->p_session)
d623 1
d645 1
a645 1
			pgrp = cp->p_pgrp;
d651 2
a652 1
		LIST_FOREACH(p, &pgrp->pg_members, p_pglist) {
d664 1
a664 1
#define CANDELIVER(uid, euid, p) \
d666 6
a671 6
	(uid) == (p)->p_cred->p_ruid || \
	(uid) == (p)->p_cred->p_svuid || \
	(uid) == (p)->p_ucred->cr_uid || \
	(euid) == (p)->p_cred->p_ruid || \
	(euid) == (p)->p_cred->p_svuid || \
	(euid) == (p)->p_ucred->cr_uid)
d681 1
a681 1
	struct proc *p;
d689 3
a691 3
		LIST_FOREACH(p, &pgrp->pg_members, p_pglist)
			if (CANDELIVER(uid, euid, p))
				psignal(p, signum);
d693 1
a693 1
		if ((p = pfind(pgid)) == NULL)
d695 2
a696 2
		if (CANDELIVER(uid, euid, p))
			psignal(p, signum);
d719 1
a719 1
	struct proc *p;
d722 3
a724 4
		LIST_FOREACH(p, &pgrp->pg_members, p_pglist)
			if ((checkctty == 0 || p->p_flag & P_CONTROLT) &&
			    (p->p_flag & P_THREAD) == 0)
				psignal(p, signum);
d870 1
a870 1
			if (prop & SA_TTYSTOP && p->p_pgrp->pg_jobc == 0)
d1035 1
a1035 1
		wakeup(p->p_pptr);
d1140 1
a1140 1
		    		    (p->p_pgrp->pg_jobc == 0 &&
d1230 3
a1232 3
		if ((p->p_pptr->p_flag & P_NOCLDSTOP) == 0)
			psignal(p->p_pptr, SIGCHLD);
		wakeup(p->p_pptr);
@


1.114
log
@Always identify threads with THREAD_PID_OFFSET, so that there's no
way a kill() intended for a thread can result in a separate process
getting the signal.
ok tedu@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.113 2010/06/30 01:47:35 tedu Exp $	*/
a315 11
#ifdef COMPAT_SUNOS
	{
		extern struct emul emul_sunos;
		if (p->p_emul == &emul_sunos) {
			if (sa->sa_flags & SA_USERTRAMP)
				ps->ps_usertramp |= bit;
			else
				ps->ps_usertramp &= ~bit;
		}
	}
#endif
@


1.113
log
@lots of SCARG simplification.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.112 2010/06/29 20:48:50 guenther Exp $	*/
a98 5
	/* a thread can only be signalled from within the same process */
	if (q->p_flag & P_THREAD) {
		return (p->p_p == q->p_p);
	}

d589 6
d598 1
a598 1
			if (p->p_flag & P_THREAD)
d605 3
a607 1
				type = STHREAD;
d610 1
a610 3
		/* kill single process */
		if (!cansignal(cp, pc, p, signum))
			return (EPERM);
@


1.112
log
@Strip out ancient bits in struct user that were still used only by
the now-removed HPUX compat code.
ok and build testing deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.111 2010/06/29 02:46:43 tedu Exp $	*/
d222 2
d229 3
d233 1
a233 1
	    (SCARG(uap, nsa) && (signum == SIGKILL || signum == SIGSTOP)))
d236 1
a236 1
	if (SCARG(uap, osa)) {
d258 1
a258 1
		error = copyout(sa, SCARG(uap, osa), sizeof (vec));
d262 2
a263 2
	if (SCARG(uap, nsa)) {
		error = copyin(SCARG(uap, nsa), sa, sizeof (vec));
d424 1
d427 1
d432 1
a432 1
		p->p_sigmask |= SCARG(uap, mask) &~ sigcantmask;
a433 1

d435 1
a435 1
		p->p_sigmask &= ~SCARG(uap, mask);
a436 1

d438 1
a438 1
		p->p_sigmask = SCARG(uap, mask) &~ sigcantmask;
a439 1

d497 2
d501 3
d507 1
a507 1
	if (SCARG(uap, oss)) {
d511 1
a511 1
		if ((error = copyout(&ss, SCARG(uap, oss), sizeof(ss))))
d514 1
a514 1
	if (SCARG(uap, nss) == NULL)
d516 1
a516 1
	error = copyin(SCARG(uap, nss), &ss, sizeof(ss));
d544 2
d548 3
d554 2
a555 2
	if (SCARG(uap, oss) && (error = copyout(&psp->ps_sigstk,
	    SCARG(uap, oss), sizeof(struct sigaltstack))))
d557 1
a557 1
	if (SCARG(uap, nss) == NULL)
d559 1
a559 1
	error = copyin(SCARG(uap, nss), &ss, sizeof(ss));
@


1.111
log
@less SCARG, more pretty.  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.110 2010/06/29 00:28:14 tedu Exp $	*/
a70 1
#include <sys/user.h>		/* for coredump */
a1442 2
	bcopy(p, &p->p_addr->u_kproc.kp_proc, sizeof(struct proc));
	fill_eproc(p, &p->p_addr->u_kproc.kp_eproc);
@


1.110
log
@Eliminate RTHREADS kernel option in favor of a sysctl.  The actual status
(not done) hasn't changed, but now it's less work to test things.
ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.109 2010/06/28 23:00:30 guenther Exp $	*/
d573 2
d576 1
a576 1
	if ((u_int)SCARG(uap, signum) >= NSIG)
d578 1
a578 1
	if (SCARG(uap, pid) > 0) {
d581 2
a582 3
		if (SCARG(uap, pid) > THREAD_PID_OFFSET) {
			if ((p = pfind(SCARG(uap, pid)
					- THREAD_PID_OFFSET)) == NULL)
d588 1
a588 1
			if ((p = pfind(SCARG(uap, pid))) == NULL)
d595 1
a595 1
		if (!cansignal(cp, pc, p, SCARG(uap, signum)))
d597 2
a598 2
		if (SCARG(uap, signum))
			ptsignal(p, SCARG(uap, signum), type);
d601 1
a601 1
	switch (SCARG(uap, pid)) {
d603 1
a603 1
		return (killpg1(cp, SCARG(uap, signum), 0, 1));
d605 1
a605 1
		return (killpg1(cp, SCARG(uap, signum), 0, 0));
d607 1
a607 1
		return (killpg1(cp, SCARG(uap, signum), -SCARG(uap, pid), 0));
@


1.109
log
@<sys/time.b> is for ftime(), which is just in libcompat and not the kernel,
so stop including it in kernel .c files.
"sure" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.108 2010/05/18 22:26:10 tedu Exp $	*/
a99 1
#ifdef RTHREADS
a103 1
#endif
a578 1
#ifdef RTHREADS
d586 1
a586 3
		} else
#endif
		{
a588 1
#ifdef RTHREADS
a590 1
#endif
a795 1
#ifdef RTHREADS
a796 1
#endif
a809 1
#ifdef RTHREADS
a822 1
#endif
a833 1
#ifdef RTHREADS
d839 1
a839 3
	}
#endif
	else {
a880 1
#ifdef RTHREADS
a889 1
#endif
a1536 1
#ifdef RTHREADS
d1550 3
a1606 1
#endif
@


1.108
log
@move knote list to struct process.  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.107 2009/11/27 19:43:55 guenther Exp $	*/
a50 1
#include <sys/timeb.h>
@


1.107
log
@Convert thrsigdivert to (almost) be sigtimedwait by adding siginfo_t
and struct timespec * argument.  sigtimedwait is just a one line
wrapper after this.

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.106 2009/11/04 19:14:10 kettenis Exp $	*/
d837 1
a837 1
		KNOTE(&p->p_klist, NOTE_SIGNAL | signum);
d1657 1
a1657 1
	SLIST_INSERT_HEAD(&p->p_klist, kn, kn_selnext);
d1667 1
a1667 1
	SLIST_REMOVE(&p->p_klist, kn, knote, kn_selnext);
@


1.106
log
@Get rid of __HAVE_GENERIC_SOFT_INTERRUPTS now that all our platforms support it.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.105 2009/06/06 21:25:19 deraadt Exp $	*/
d1560 2
d1565 1
d1583 10
d1595 2
a1596 1
	error = tsleep(&p->p_sigdivert, PPAUSE|PCATCH, "sigwait", 0);
d1603 2
d1610 11
a1620 1
	return (0);
@


1.105
log
@We need miod's no-coredumps-on-ramdisks diff, because we have grown the
media just a wee bit too much.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.104 2009/06/05 03:57:32 ray Exp $	*/
a1205 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
d1207 1
a1207 1
#endif
a1220 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a1221 3
#else
                setsoftclock();
#endif
@


1.104
log
@%zu is not meant for size_t in the kernel. Change to %lu.

OK miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.103 2009/03/05 19:52:24 kettenis Exp $	*/
d1397 3
d1481 1
d1487 3
d1520 1
d1523 1
d1544 1
@


1.103
log
@Make ELF platforms generate ELF core dumps.  Somewhat based on code from
NetBSD.

ok kurt@@, drahn@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.102 2009/01/29 22:18:06 guenther Exp $	*/
d1525 1
a1525 1
		printf("pid %d (%s): %s write of %zu@@%p at %lld failed: %d\n",
@


1.102
log
@Remove KASSERT() that could trigger when an rthread in sigwait()
got multiple signals before tsleep() could wakeup.  Also, POSIX
says that sigwait() should never return EINTR, so map that to
ERESTART.

ok kurt@@, tedu@@
fixes the panic encountered by ariane@@ with kaffe
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.101 2008/12/16 07:57:28 guenther Exp $	*/
d1383 7
d1402 1
a1405 1
	struct core core;
d1465 25
d1501 1
a1501 1
		goto out;
d1508 1
a1508 1
		goto out;
a1511 6
out:
	VOP_UNLOCK(vp, 0, p);
	error1 = vn_close(vp, FWRITE, cred, p);
	crfree(cred);
	if (error == 0)
		error = error1;
d1513 21
@


1.101
log
@Move the functionality of psignal() to a new function ptsignal()
that takes an additional argument "type" that indicates whether the
signal is for the process, just a particular thread, or propagated
to a thread because it's not caught or blocked.  psignal() becomes
a wrapper that does the first of those.

So that sys_kill() can tell apart signals for the process and signals
for the process's original thread, the tid of the original thread
is defined as its pid + THREAD_PID_OFFSET.

ok tedu@@ art@@ andreas@@ kurt@@   "better early than late" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.100 2008/10/03 04:22:37 guenther Exp $	*/
d1535 2
a1536 2
		if (error == ERESTART)
			error = EINTR;
a1539 1
	KASSERT(error == 0);
@


1.100
log
@Make sigwait() work correctly.  In particular, it'll work when the
signal is already pending in the calling thread or the main thread
and there's no longer a race condition where the signal could be
diverted but sigwait() would still block.  There were some off-by-one
errors too.

(The checking of the main thread's pending list is just until a
pending list for the process can be added to struct process.  For
now, such signals end up as pending on the main thread.)

oks tedu@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.99 2008/06/10 20:41:52 hshoexer Exp $	*/
d580 21
a601 2
		if ((p = pfind(SCARG(uap, pid))) == NULL)
			return (ESRCH);
d605 1
a605 1
			psignal(p, SCARG(uap, signum));
d636 1
a636 1
			if (p->p_pid <= 1 || p->p_flag & P_SYSTEM || 
d655 1
a655 1
			if (p->p_pid <= 1 || p->p_flag & P_SYSTEM ||
d769 1
a769 1
		psignal(p, signum);
d789 12
d821 11
a831 6
	TAILQ_FOREACH(q, &p->p_p->ps_threads, p_thr_link) {
		if (q == p)
			continue;
		if (q->p_sigdivert & mask) {
			psignal(q, signum);
			return;
d836 2
a837 1
	KNOTE(&p->p_klist, NOTE_SIGNAL | signum);
a885 6
#ifdef RTHREADS
		TAILQ_FOREACH(q, &p->p_p->ps_threads, p_thr_link) {
			if (q != p)
				psignal(q, signum);
		 }
#endif
a889 7
#ifdef RTHREADS
		
		TAILQ_FOREACH(q, &p->p_p->ps_threads, p_thr_link) {
			if (q != p)
				psignal(q, signum);
		 }
#endif
d896 12
d1498 1
a1498 1
	psignal(p, SIGSYS);
@


1.99
log
@posix compliant permission checks for sending signals.  Based on diffs
provided by christian ehrhardt (Christian_Ehrhardt@@genua.de) and micky,
thanks!

ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.98 2008/05/22 17:04:59 thib Exp $	*/
d787 2
d793 1
a793 2
		if (q->p_sigdivert & (1 << signum)) {
			q->p_sigdivert = 0;
a801 1
	mask = sigmask(signum);
d809 8
d1470 9
a1478 1
	struct sys_thrsigdivert_args *uap = v;
d1480 11
a1490 1
	p->p_sigdivert = SCARG(uap, sigmask);
d1492 15
@


1.98
log
@Use LIST_FOREACH() instead of handrolling.

From: Pierre Riteau pierre.riteau_att_gmail.com
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.97 2007/11/27 16:22:13 martynas Exp $	*/
d130 1
a130 3
			    pc->pc_ucred->cr_uid == q->p_cred->p_ruid ||
			    pc->p_ruid == q->p_ucred->cr_uid ||
			    pc->pc_ucred->cr_uid == q->p_ucred->cr_uid)
a135 4
	/* XXX
	 * because the P_SUGID test exists, this has extra tests which
	 * could be removed.
	 */
d139 1
a139 3
	    pc->pc_ucred->cr_uid == q->p_cred->p_svuid ||
	    pc->p_ruid == q->p_ucred->cr_uid ||
	    pc->pc_ucred->cr_uid == q->p_ucred->cr_uid)
@


1.97
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.96 2007/11/19 17:47:47 millert Exp $	*/
d624 1
a624 1
		for (p = LIST_FIRST(&allproc); p; p = LIST_NEXT(p, p_list)) {
@


1.96
log
@Don't overwrite a core file owned by a different user.  Makes the code
match the comment.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.95 2007/09/01 15:14:44 martin Exp $	*/
d1281 1
a1281 1
		 * occurences of this signal.
@


1.95
log
@replace the machine dependant bytes-to-clicks macro by the MI ptoa()
version for i386

more architectures and ctob() replacement is being worked on

prodded by and ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.94 2007/05/30 07:42:52 moritz Exp $	*/
a1408 1
	/* Don't dump to non-regular files or files with links. */
d1410 2
a1411 1
	    vattr.va_mode & ((VREAD | VWRITE) >> 3 | (VREAD | VWRITE) >> 6)) {
@


1.94
log
@Adjust filename buffer for the new /var/crash prefix to prevent
truncation and add an additional truncation check.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.93 2007/05/29 00:26:29 jcs Exp $	*/
d1378 1
a1378 1
	if (USPACE + ctob(vm->vm_dsize + vm->vm_ssize) >=
d1428 3
a1430 3
	core.c_tsize = (u_long)ctob(vm->vm_tsize);
	core.c_dsize = (u_long)ctob(vm->vm_dsize);
	core.c_ssize = (u_long)round_page(ctob(vm->vm_ssize));
@


1.93
log
@update comment re nosuidcoredump sysctl
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.92 2007/05/29 00:03:18 tedu Exp $	*/
d1359 2
a1360 2
	int error, error1;
	char name[MAXCOMLEN+6];		/* progname.core */
d1382 4
a1392 1
	snprintf(name, sizeof name, "%s%s.core", dir, p->p_comm);
@


1.92
log
@put suid coredumps into /var/crash if kern.nosuidcoredump is set to 2.
makes debugging easier, docs in a bit
ok beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.91 2007/05/08 14:16:36 miod Exp $	*/
d1366 2
a1367 1
	 * group privileges.
@


1.91
log
@Needs an extern decl for generic soft interrupts platforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.90 2007/05/08 11:16:31 art Exp $	*/
d1361 1
d1368 7
a1374 5
	if ((p->p_flag & P_SUGID) &&
	    (error = suser(p, 0)) != 0)
		return (error);
	if ((p->p_flag & P_SUGID) && nosuidcoredump)
		return (EPERM);
d1388 1
a1388 1
	snprintf(name, sizeof name, "%s.core", p->p_comm);
@


1.90
log
@First step in making the SCHED_LOCK not recursive.
 - Defer the sending of SIGCHLD and waking the parent when a process goes
   to sleep. We set a flag in the process "P_STOPPED" and schedule a
   timeout that checks all processes for this flag and sends SIGCHLD
   and wakes the parent on those processes that have this flag set.
 - Delay the waking of the parent in psignal on SIGCONT until we've
   released the SCHED_LOCK at the end.
 - In issignal, check for P_SINTR as a way to see we were called from
   the tsleep path with SCHED_LOCK locked and don't skip locking
   in that case. (This is slightly ugly, but it works until we have
   some better way).

miod@@ ok (after finding and fixing an MD bug on sgi)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.89 2007/04/03 08:05:43 art Exp $	*/
d1170 3
@


1.89
log
@Start moving state that is shared among threads in a process into
a new struct. Instead of doing a huge rename and deal with the fallout
for weeks, like other projects that need no mention, we will slowly and
carefully move things out of struct proc into a new struct process.

 - Create struct process and the infrastructure to create and remove them.
 - Move threads in a process into struct process.

deraadt@@, tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.88 2007/03/15 10:22:30 art Exp $	*/
d81 4
a84 1
void proc_stop(struct proc *p);
a151 1

d158 2
d784 1
d921 1
a921 3
			if ((p->p_pptr->p_flag & P_NOCLDSTOP) == 0)
				psignal(p->p_pptr, SIGCHLD);
			proc_stop(p);
d957 1
a957 1
			wakeup(p->p_pptr);
d1010 2
d1030 1
d1057 5
a1061 5
			SCHED_LOCK(s);	/* protect mi_switch */
			psignal(p->p_pptr, SIGCHLD);
			proc_stop(p);
			mi_switch();
			SCHED_UNLOCK(s);
d1120 5
a1124 6
				if ((p->p_pptr->p_flag & P_NOCLDSTOP) == 0)
					psignal(p->p_pptr, SIGCHLD);
				SCHED_LOCK(s);
				proc_stop(p);
				mi_switch();
				SCHED_UNLOCK(s);
d1168 1
a1168 1
proc_stop(struct proc *p)
d1176 36
a1211 1
	wakeup(p->p_pptr);
@


1.88
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.87 2007/02/06 18:42:37 art Exp $	*/
d100 3
a102 2
	if (q->p_flag & P_THREAD)
		return (p->p_thrparent == q->p_thrparent);
d791 3
a793 1
	LIST_FOREACH(q, &p->p_thrchildren, p_thrsib) {
d845 4
a848 2
		LIST_FOREACH(q, &p->p_thrchildren, p_thrsib)
			psignal(q, signum);
d855 5
a859 2
		LIST_FOREACH(q, &p->p_thrchildren, p_thrsib)
			psignal(q, signum);
@


1.87
log
@Use atomic.h operation for manipulating p_siglist in struct proc. Solves
the problem with lost signals in MP kernels.

miod@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.86 2007/01/17 23:08:18 art Exp $	*/
d291 1
a291 1
			p->p_flag |= P_NOCLDSTOP;
d293 1
a293 1
			p->p_flag &= ~P_NOCLDSTOP;
d303 1
a303 1
			p->p_flag |= P_NOCLDWAIT;
d305 1
a305 1
			p->p_flag &= ~P_NOCLDWAIT;
d406 1
a406 1
	p->p_flag &= ~P_NOCLDWAIT;
d854 1
a854 1
		p->p_flag &= ~P_CONTINUED;
d945 1
a945 1
			p->p_flag |= P_CONTINUED;
d1162 1
a1162 1
	p->p_flag &= ~P_WAITED;
d1282 1
a1282 1
	p->p_flag |= P_WEXIT;
@


1.86
log
@When sending signals, instead of checking if the process sending the
signal to is the curproc, check if it's SONPROC. That way we'll also
signotify processes on other CPUs. This gives MD code the opportunity
to actually deliver signals to other CPUs faster than the clock
interrupt (in the worst case).

This is a NOP until MD code is fixed.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.85 2007/01/16 17:52:18 thib Exp $	*/
d342 1
a342 1
		p->p_siglist &= ~bit;		/* never to be seen again */
d394 1
a394 1
			p->p_siglist &= ~mask;
d845 1
a845 1
		p->p_siglist &= ~stopsigmask;
d853 1
a853 1
		p->p_siglist &= ~contsigmask;
d857 1
a857 1
	p->p_siglist |= mask;
d892 1
a892 1
			p->p_siglist &= ~mask;
d906 1
a906 1
			p->p_siglist &= ~mask;
d948 1
a948 1
				p->p_siglist &= ~mask;
d962 1
a962 1
			p->p_siglist &= ~mask;		/* take it away */
d1027 1
a1027 1
		p->p_siglist &= ~mask;		/* take the signal! */
d1064 3
a1066 1
			p->p_siglist &= ~mask;		/* take the signal! */
d1145 1
a1145 1
	p->p_siglist |= mask;		/* leave the signal for later */
d1189 1
a1189 1
	p->p_siglist &= ~mask;
@


1.85
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.84 2006/06/15 20:08:01 miod Exp $	*/
d976 3
a984 2
		if (p == curproc)
			signotify(p);
@


1.84
log
@Nothing sets P_FSTRACE anymore, so remove all what's left of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.83 2006/06/07 18:58:39 miod Exp $	*/
a1355 1
	VOP_LEASE(vp, p, cred, LEASE_WRITE);
@


1.83
log
@killproc() is orphaned, so kill it; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.82 2006/03/04 10:22:20 miod Exp $	*/
d1043 3
a1045 15
			if (p->p_flag & P_FSTRACE) {
#ifdef	PROCFS
				/* procfs debugging */
				p->p_stat = SSTOP;
				wakeup(p);
				mi_switch();
#else
				panic("procfs debugging");
#endif
			} else {
				/* ptrace debugging */
				psignal(p->p_pptr, SIGCHLD);
				proc_stop(p);
				mi_switch();
			}
@


1.82
log
@Remove traditional coredump support since all our platforms have proper
cpu_coredump() behaviour.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.81 2006/02/20 19:39:11 miod Exp $	*/
a58 1
#include <sys/syslog.h>
a81 1
void killproc(struct proc *, char *);
a1276 12
}

/*
 * Kill the current process for stated reason.
 */
void
killproc(struct proc *p, char *why)
{

	log(LOG_ERR, "pid %d was killed: %s\n", p->p_pid, why);
	uprintf("sorry, pid %d was killed: %s\n", p->p_pid, why);
	psignal(p, SIGKILL);
@


1.81
log
@Compile out more rthreads stuff unless option RTHREADS;
discussed with a few, ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.80 2006/01/18 23:42:12 miod Exp $	*/
d1400 10
a1409 36
	if (core.c_midmag == 0) {
		/* XXX
		 * cpu_coredump() didn't bother to set the magic; assume
		 * this is a request to do a traditional dump. cpu_coredump()
		 * is still responsible for setting sensible values in
		 * the core header.
		 */
		if (core.c_cpusize == 0)
			core.c_cpusize = USPACE; /* Just in case */
		error = vn_rdwr(UIO_WRITE, vp, vm->vm_daddr,
		    (int)core.c_dsize,
		    (off_t)core.c_cpusize, UIO_USERSPACE,
		    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
		if (error)
			goto out;
		error = vn_rdwr(UIO_WRITE, vp,
#ifdef MACHINE_STACK_GROWS_UP
		    (caddr_t) USRSTACK,
#else
		    (caddr_t) trunc_page(USRSTACK - ctob(vm->vm_ssize)),
#endif
		    core.c_ssize,
		    (off_t)(core.c_cpusize + core.c_dsize), UIO_USERSPACE,
		    IO_NODELOCKED|IO_UNIT, cred, NULL, p);
	} else {
		/*
		 * vm_coredump() spits out all appropriate segments.
		 * All that's left to do is to write the core header.
		 */
		error = uvm_coredump(p, vp, cred, &core);
		if (error)
			goto out;
		error = vn_rdwr(UIO_WRITE, vp, (caddr_t)&core,
		    (int)core.c_hdrsize, (off_t)0,
		    UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, NULL, p);
	}
@


1.80
log
@Fix logic botch when checking for COMPAT_SUNOS binary specifics; repairs
some TIOCGPGRP result fallout.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.79 2005/12/22 06:58:20 tedu Exp $	*/
d100 1
d104 1
a104 1

d778 1
d780 1
d791 1
d799 1
d843 1
d846 1
d851 1
d854 1
@


1.79
log
@1.  when signalling a process group, don't deliver a copy to every thread
2.  when delivering a STOP or CONT signal to a process, now replicate
	to every thread.
makes ^Z and fg work nicer, first noticed by peter hessler.
signals and threads are not right, but this is at least a little less wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.78 2005/12/03 18:09:08 tedu Exp $	*/
d327 6
a332 4
		if (p->p_emul == &emul_sunos && sa->sa_flags & SA_USERTRAMP)
			ps->ps_usertramp |= bit;
		else
			ps->ps_usertramp &= ~bit;
@


1.78
log
@kernel support for threaded processes (rthreads).
uses rfork(RFTHREAD) to create threads, which are presently processes
that are a little more tightly bound together.  several new syscalls
added to facilitate a userland thread library.
all conditional on RTHREADS, currently disabled.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.77 2005/11/28 00:14:29 jsg Exp $	*/
d708 2
a709 1
			if (checkctty == 0 || p->p_flag & P_CONTROLT)
d835 3
a837 1
	if (prop & SA_CONT)
d839 1
d842 2
@


1.77
log
@ansi/deregister.
'go for it' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.76 2005/06/17 22:33:34 niklas Exp $	*/
d100 5
d774 1
d785 8
d1296 1
a1296 1
	exit1(p, W_EXITCODE(0, signum));
d1440 12
@


1.76
log
@A second approach at fixing the telnet localhost & problem
(but I tend to call it ssh localhost & now when telnetd is
history).  This is more localized patch, but leaves us with
a recursive lock for protecting scheduling and signal state.
Better care is taken to actually be symmetric over mi_switch.
Also, the dolock cruft in psignal can go with this solution.
Better test runs by more people for longer time has been
carried out compared to the c2k5 patch.

Long term the current mess with interruptible sleep, the
default action on stop signals and wakeup interactions need
to be revisited.  ok deraadt@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.75 2005/05/29 03:20:41 deraadt Exp $	*/
d92 1
a92 5
cansignal(p, pc, q, signum)
	struct proc *p;
	struct pcred *pc;
	struct proc *q;
	int signum;
d149 1
a149 1
signal_init()
d160 1
a160 2
sigactsinit(p)
	struct proc *p;
d174 1
a174 2
sigactsshare(p1, p2)
	struct proc *p1, *p2;
d186 1
a186 2
sigactsunshare(p)
	struct proc *p;
d202 1
a202 2
sigactsfree(p)
	struct proc *p;
d216 1
a216 4
sys_sigaction(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d218 1
a218 1
	register struct sys_sigaction_args /* {
d224 3
a226 3
	register struct sigaction *sa;
	register struct sigacts *ps = p->p_sigacts;
	register int signum;
d270 1
a270 4
setsigvec(p, signum, sa)
	register struct proc *p;
	int signum;
	register struct sigaction *sa;
d355 1
a355 2
siginit(p)
	struct proc *p;
d357 1
a357 1
	register int i;
d368 1
a368 2
execsigs(p)
	register struct proc *p;
d370 2
a371 2
	register struct sigacts *ps;
	register int nc, mask;
d412 1
a412 4
sys_sigprocmask(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
d447 1
a447 4
sys_sigpending(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d461 1
a461 4
sys_sigsuspend(p, v, retval)
	register struct proc *p;
	void *v;
	register_t *retval;
d466 1
a466 1
	register struct sigacts *ps = p->p_sigacts;
d486 1
a486 4
sys_osigaltstack(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d488 1
a488 1
	register struct sys_osigaltstack_args /* {
d528 1
a528 4
sys_sigaltstack(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d530 1
a530 1
	register struct sys_sigaltstack_args /* {
d565 1
a565 4
sys_kill(cp, v, retval)
	register struct proc *cp;
	void *v;
	register_t *retval;
d567 1
a567 1
	register struct sys_kill_args /* {
d571 2
a572 2
	register struct proc *p;
	register struct pcred *pc = cp->p_cred;
d602 1
a602 3
killpg1(cp, signum, pgid, all)
	register struct proc *cp;
	int signum, pgid, all;
d604 2
a605 2
	register struct proc *p;
	register struct pcred *pc = cp->p_cred;
d658 1
a658 4
csignal(pgid, signum, uid, euid)
	pid_t pgid;
	int signum;
	uid_t uid, euid;
d684 1
a684 2
gsignal(pgid, signum)
	int pgid, signum;
d697 1
a697 3
pgsignal(pgrp, signum, checkctty)
	struct pgrp *pgrp;
	int signum, checkctty;
d699 1
a699 1
	register struct proc *p;
d713 2
a714 6
trapsignal(p, signum, code, type, sigval)
	struct proc *p;
	register int signum;
	u_long code;
	int type;
	union sigval sigval;
d716 1
a716 1
	register struct sigacts *ps = p->p_sigacts;
d764 1
a764 3
psignal(p, signum)
	register struct proc *p;
	register int signum;
d766 2
a767 2
	register int s, prop;
	register sig_t action;
d1135 1
a1135 2
proc_stop(p)
	struct proc *p;
d1151 1
a1151 2
postsig(signum)
	register int signum;
d1254 1
a1254 3
killproc(p, why)
	struct proc *p;
	char *why;
d1271 1
a1271 3
sigexit(p, signum)
	register struct proc *p;
	int signum;
d1293 1
a1293 2
coredump(p)
	register struct proc *p;
d1295 3
a1297 3
	register struct vnode *vp;
	register struct ucred *cred = p->p_ucred;
	register struct vmspace *vm = p->p_vmspace;
d1420 1
a1420 4
sys_nosys(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
d1428 1
a1428 6
initsiginfo(si, sig, code, type, val)
	siginfo_t *si;
	int sig;
	u_long code;
	int type;
	union sigval val;
@


1.75
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.73 2004/12/26 21:22:13 miod Exp $	*/
a807 2
 *
 * XXXSMP: Invoked as psignal() or sched_psignal().
d810 1
a810 1
psignal1(p, signum, dolock)
a812 1
	int dolock;		/* XXXSMP: works, but icky */
a820 6

	/* XXXSMP: works, but icky */
	if (dolock)
		SCHED_ASSERT_UNLOCKED();
	else
		SCHED_ASSERT_LOCKED();
d884 2
a885 3
	/* XXXSMP: works, but icky */
	if (dolock)
		SCHED_LOCK(s);
d928 1
a928 5
				/*
				 * XXXSMP: recursive call; don't lock
				 * the second time around.
				 */
				sched_psignal(p->p_pptr, SIGCHLD);
d1016 1
a1016 3
	/* XXXSMP: works, but icky */
	if (dolock)
		SCHED_UNLOCK(s);
d1077 1
a1077 2
			SCHED_ASSERT_UNLOCKED();
			splx(s);
d1139 1
a1139 2
				SCHED_ASSERT_UNLOCKED();
				splx(s);
@


1.74
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@d808 2
d812 4
a815 1
psignal(struct proc *p, int signum)
d817 2
a818 2
	int s, prop;
	sig_t action;
d824 6
a830 1
	SCHED_ASSERT_UNLOCKED();
d893 3
a896 1
	SCHED_LOCK(s);
d937 6
a942 5
			if ((p->p_pptr->p_flag & P_NOCLDSTOP) == 0) {
				SCHED_UNLOCK(s);
				psignal(p->p_pptr, SIGCHLD);
				SCHED_LOCK(s);
			}
d979 1
a979 1
			sched_wakeup(p->p_pptr);
d1030 3
a1032 1
	SCHED_UNLOCK(s);
d1077 1
a1079 1
				SCHED_LOCK(s);
d1082 2
a1083 2
				sched_wakeup(p);
				mi_switch(s);
a1089 1
				SCHED_LOCK(s);
d1091 1
a1091 1
				mi_switch(s);
d1093 2
d1155 3
a1157 1
				mi_switch(s);
d1201 2
a1202 1
proc_stop(struct proc *p)
d1204 1
d1206 1
d1210 1
a1210 1
	sched_wakeup(p->p_pptr);
@


1.73
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.72 2004/07/04 13:35:01 niklas Exp $	*/
a807 2
 *
 * XXXSMP: Invoked as psignal() or sched_psignal().
d810 1
a810 4
psignal1(p, signum, dolock)
	register struct proc *p;
	register int signum;
	int dolock;		/* XXXSMP: works, but icky */
d812 2
a813 2
	register int s, prop;
	register sig_t action;
a818 6

	/* XXXSMP: works, but icky */
	if (dolock)
		SCHED_ASSERT_UNLOCKED();
	else
		SCHED_ASSERT_LOCKED();
d820 1
a882 3
	/* XXXSMP: works, but icky */
	if (dolock)
		SCHED_LOCK(s);
d884 1
d925 5
a929 6
			if ((p->p_pptr->p_flag & P_NOCLDSTOP) == 0)
				/*
				 * XXXSMP: recursive call; don't lock
				 * the second time around.
				 */
				sched_psignal(p->p_pptr, SIGCHLD);
d966 1
a966 1
			wakeup(p->p_pptr);
d1017 1
a1017 3
	/* XXXSMP: works, but icky */
	if (dolock)
		SCHED_UNLOCK(s);
a1061 1
			SCHED_LOCK(s);	/* protect mi_switch */
d1064 1
d1067 2
a1068 2
				wakeup(p);
				mi_switch();
d1075 1
d1077 1
a1077 1
				mi_switch();
a1078 2
			SCHED_ASSERT_UNLOCKED();
			splx(s);
d1139 1
a1139 3
				mi_switch();
				SCHED_ASSERT_UNLOCKED();
				splx(s);
d1183 1
a1183 2
proc_stop(p)
	struct proc *p;
a1184 1
#ifdef MULTIPROCESSOR
a1185 1
#endif
d1189 1
a1189 1
	wakeup(p->p_pptr);
@


1.72
log
@proc_stop needs sched_lock locked.  From art, verified with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.71 2004/06/13 21:49:26 niklas Exp $	*/
d668 1
a668 1
		for (p = pgrp->pg_members.lh_first; p != 0; p = p->p_pglist.le_next) {
d708 1
a708 2
		for (p = pgrp->pg_members.lh_first; p;
		    p = p->p_pglist.le_next)
d744 1
a744 1
		for (p = pgrp->pg_members.lh_first; p != 0; p = p->p_pglist.le_next)
@


1.71
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1154 1
a1155 1
				SCHED_LOCK(s);
@


1.70
log
@fix siginfo generation for posted signals and avoid double ktrpsig() call for the same signal; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.69 2004/01/14 05:23:25 tedu Exp $	*/
d65 1
d809 2
d813 1
a813 1
psignal(p, signum)
d816 1
d822 1
d826 7
d894 4
a897 1
	s = splhigh();
d939 5
a943 1
				psignal(p->p_pptr, SIGCHLD);
d1031 3
a1033 1
	splx(s);
d1078 1
a1078 1
			s = splstatclock();	/* protect mi_switch */
d1094 1
d1155 1
a1155 1
				s = splstatclock();
d1157 1
d1205 3
d1234 3
d1286 3
d1290 1
d1315 2
a1345 1

@


1.69
log
@change sigaltstack.ss_size type to size_t.  handle syscall fallout.
add stack_t and ucontext_t typedefs.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.68 2003/09/01 18:06:03 henning Exp $	*/
d765 3
d769 2
a770 2
	if (KTRPOINT(p, KTR_PSIG)) {
		siginfo_t si;
d772 4
a775 4
		initsiginfo(&si, signum, code, type, sigval);
		ktrpsig(p, signum, ps->ps_sigact[signum],
		    p->p_sigmask, code, &si);
	}
a776 3
	mask = sigmask(signum);
	if ((p->p_flag & P_TRACED) == 0 && (p->p_sigcatch & mask) != 0 &&
	    (p->p_sigmask & mask) == 0) {
d788 1
d790 2
d1201 2
a1202 2
	union sigval null_sigval;
	int s;
d1211 2
d1216 2
d1220 2
d1228 1
a1228 2
		null_sigval.sival_ptr = 0;
		initsiginfo(&si, signum, 0, SI_USER, null_sigval);
d1230 1
a1230 1
		    ps->ps_oldmask : p->p_sigmask, code, &si);
d1273 1
d1275 2
d1278 1
a1278 1
		null_sigval.sival_ptr = 0;
d1280 1
a1280 1
		    SI_USER, null_sigval);
@


1.68
log
@match syscallargs comments with reality
from Patrick Latifi <patrick.l@@hermes.usherb.ca>
ok jason@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.67 2003/08/15 20:32:18 tedu Exp $	*/
d510 45
d572 1
a572 1
	    SCARG(uap, oss), sizeof (struct sigaltstack))))
d576 1
a576 1
	error = copyin(SCARG(uap, nss), &ss, sizeof (ss));
@


1.67
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.66 2003/08/04 16:27:01 millert Exp $	*/
d230 1
a230 1
		syscallarg(struct sigaction *) nsa;
d516 1
a516 1
		syscallarg(struct sigaltstack *) nss;
@


1.66
log
@Use strlcpy(), not strncpy() when copying p->p_comm to core.c_name
to guarantee NUL termination; from Patrick Latifi.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.65 2003/08/03 19:25:49 millert Exp $	*/
d1293 1
a1293 1
	    (error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.65
log
@Implement the WCONTINUED flag to the wait(2) family of syscalls and the
associated WIFCONTINUED macro as per 1003.1-2001.  Adapted from FreeBSD.
A minor amount of trickiness is involved here.  The value for WCONTINUED
is chosen in such a way that _WSTATUS(_WCONTINUED) == _WSTOPPED and the
WIFSTOPPED macro has been modified such that WIFSTOPPED(_WCONTINUED) !=
_WSTOPPED.  This means we don't need to add an extra check to the
WIFSIGNALED and WIFSTOPPED macros.  deraadt@@ OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.64 2003/07/21 22:44:50 tedu Exp $	*/
d1342 1
a1342 1
	strncpy(core.c_name, p->p_comm, MAXCOMLEN);
@


1.64
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.63 2003/06/02 23:28:05 millert Exp $	*/
d821 1
a821 1
	if (prop & SA_STOP)
d823 2
d912 2
@


1.63
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.62 2003/05/03 21:14:59 deraadt Exp $	*/
d266 1
a266 2
		error = copyout((caddr_t)sa, (caddr_t)SCARG(uap, osa),
				sizeof (vec));
d271 1
a271 2
		error = copyin((caddr_t)SCARG(uap, nsa), (caddr_t)sa,
		    sizeof (vec));
d502 1
a502 1
	while (tsleep((caddr_t) ps, PPAUSE|PCATCH, "pause", 0) == 0)
d526 2
a527 2
	if (SCARG(uap, oss) && (error = copyout((caddr_t)&psp->ps_sigstk,
	    (caddr_t)SCARG(uap, oss), sizeof (struct sigaltstack))))
d531 1
a531 1
	error = copyin((caddr_t)SCARG(uap, nss), (caddr_t)&ss, sizeof (ss));
d1010 1
a1010 1
				wakeup((caddr_t)p);
d1133 1
a1133 1
	wakeup((caddr_t)p->p_pptr);
@


1.62
log
@string fixes; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.61 2002/10/01 17:33:39 art Exp $	*/
d22 1
a22 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.61
log
@Oppsie. Missing part from this commit:
Prevent two localhost crashes with proc filters.
- don't send NOTE_SIGNAL to exiting processes.
- null dereference on error condition.
from Peter Werner <peterw at ifost.org.au>
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.60 2002/07/14 02:44:30 deraadt Exp $	*/
d1312 1
a1312 1
	sprintf(name, "%s.core", p->p_comm);
@


1.60
log
@be more permissive, and let close relatives do SIGALRM
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.59 2002/06/11 08:19:17 art Exp $	*/
a778 2
	KNOTE(&p->p_klist, NOTE_SIGNAL | signum);

d782 2
@


1.59
log
@Protect mi_switch with splstatclock.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.58 2002/05/08 19:24:42 millert Exp $	*/
d120 1
@


1.58
log
@A process can always signal itself--no need to restrict signals even if
it is setugid.  deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.57 2002/04/18 08:25:04 miod Exp $	*/
d981 1
a981 2
issignal(p)
	register struct proc *p;
d983 2
a984 1
	register int signum, mask, prop;
d1010 1
d1026 1
d1086 1
d1088 1
@


1.57
log
@Provide the correct signal number to the ktrace PSIG information instead
of an uninitialized variable.
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.56 2002/03/14 01:27:04 millert Exp $	*/
d103 3
@


1.56
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.55 2002/02/22 19:19:28 deraadt Exp $	*/
d1157 7
d1213 1
a1213 4
		if (ps->ps_sig != signum) {
			code = 0;
		} else {
			code = ps->ps_code;
@


1.55
log
@include a siginfo_t with ktrace PSIG information, so that kdump can print
fault addresses and other information. (a small bug exists: in some signal
delivery cases, two PSIG records may be inserted, because postsig() is
unaware a PSIG record has already been placed.  but this small bug can
stay since the siginfo_t information helps us find and fix other bugs)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.54 2002/01/31 02:12:18 weingart Exp $	*/
d85 3
a87 3
void proc_stop __P((struct proc *p));
void killproc __P((struct proc *, char *));
int cansignal __P((struct proc *, struct pcred *, struct proc *, int));
@


1.54
log
@Ignore signals if/when we are exiting.
Prevents a hang in the NFS code when
dumping core and pressing ^C, etc.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.53 2002/01/23 00:39:47 art Exp $	*/
d722 9
a734 5
#ifdef KTRACE
		if (KTRPOINT(p, KTR_PSIG))
			ktrpsig(p, signum, ps->ps_sigact[signum],
			    p->p_sigmask, code);
#endif
d1158 5
a1162 1
	if (KTRPOINT(p, KTR_PSIG))
d1164 2
a1165 1
		    ps->ps_oldmask : p->p_sigmask, 0);
@


1.53
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.52 2002/01/19 19:00:14 millert Exp $	*/
d773 4
d1236 3
@


1.52
log
@If handler for SIGCHLD is SIG_IGN, reset to SIG_DLF.  This is consistent
with our handling of SA_NOCLDWAIT as well as other operating systems.
From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.51 2002/01/07 16:16:32 millert Exp $	*/
d155 1
a155 1
	    0, pool_page_alloc_nointr, pool_page_free_nointr, M_SUBPROC);
@


1.51
log
@If the handler for SIGCHLD is set to SIG_IGN, act as if the
SA_NOCLDWAIT (don't create zombies) flag has been specified.  This
is consistent with most other operating systems and is what XPG4.2
specifies.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.50 2001/11/06 19:53:20 miod Exp $	*/
d418 2
@


1.50
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.49 2001/09/21 21:36:48 deraadt Exp $	*/
d305 11
a315 12
		if (sa->sa_flags & SA_NOCLDWAIT) {
			/*
			 * Paranoia: since SA_NOCLDWAIT is implemented by
			 * reparenting the dying child to PID 1 (and
			 * trust it to reap the zombie), PID 1 itself is
			 * forbidden to set SA_NOCLDWAIT.
			 */
			if (p->p_pid == 1)
				p->p_flag &= ~P_NOCLDWAIT;
			else
				p->p_flag |= P_NOCLDWAIT;
		} else
@


1.50.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.54 2002/01/31 02:12:18 weingart Exp $	*/
d155 1
a155 1
	    &pool_allocator_nointr);
d305 12
a316 11
		/*
		 * If the SA_NOCLDWAIT flag is set or the handler
		 * is SIG_IGN we reparent the dying child to PID 1
		 * (init) which will reap the zombie.  Because we use
		 * init to do our dirty work we never set P_NOCLDWAIT
		 * for PID 1.
		 */
		if (p->p_pid != 1 && ((sa->sa_flags & SA_NOCLDWAIT) ||
		    sa->sa_handler == SIG_IGN))
			p->p_flag |= P_NOCLDWAIT;
		else
a418 2
	if (ps->ps_sigact[SIGCHLD] == SIG_IGN)
		ps->ps_sigact[SIGCHLD] = SIG_DFL;
a771 4
	/* Ignore signal if we are exiting */
	if (p->p_flag & P_WEXIT)
		return;

a1230 3

	/* Mark process as going away */
	p->p_flag |= P_WEXIT;
@


1.50.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.50.2.1 2002/01/31 22:55:40 niklas Exp $	*/
d85 3
a87 3
void proc_stop(struct proc *p);
void killproc(struct proc *, char *);
int cansignal(struct proc *, struct pcred *, struct proc *, int);
a103 3
	if (p == q)
		return (1);		/* process can always signal itself */

a721 9
#ifdef KTRACE
	if (KTRPOINT(p, KTR_PSIG)) {
		siginfo_t si;

		initsiginfo(&si, signum, code, type, sigval);
		ktrpsig(p, signum, ps->ps_sigact[signum],
		    p->p_sigmask, code, &si);
	}
#endif
d726 5
a1152 7

	if (ps->ps_sig != signum) {
		code = 0;
	} else {
		code = ps->ps_code;
	}

d1154 1
a1154 5
	if (KTRPOINT(p, KTR_PSIG)) {
		siginfo_t si;
		
		null_sigval.sival_ptr = 0;
		initsiginfo(&si, signum, 0, SI_USER, null_sigval);
d1156 1
a1156 2
		    ps->ps_oldmask : p->p_sigmask, code, &si);
	}
d1197 4
a1200 1
		if (ps->ps_sig == signum) {
@


1.50.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.50.2.2 2002/06/11 03:29:40 art Exp $	*/
a119 1
		case SIGALRM:
d778 2
a783 2
	KNOTE(&p->p_klist, NOTE_SIGNAL | signum);

d981 2
a982 1
issignal(struct proc *p)
d984 1
a984 2
	int signum, mask, prop;
	int s;
a1009 1
			s = splstatclock();	/* protect mi_switch */
a1024 1
			splx(s);
a1083 1
				s = splstatclock();
a1084 1
				splx(s);
@


1.50.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1312 1
a1312 1
	snprintf(name, sizeof name, "%s.core", p->p_comm);
@


1.49
log
@execsigs() could modify the wrong sigacts; based on David.Arana@@eng.sun.com saying he could not understand how this worked
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.48 2001/09/20 23:30:29 art Exp $	*/
d75 1
a75 1
#include <vm/vm.h>
a76 2

#include <uvm/uvm_extern.h>
@


1.49.2.1
log
@Pull in patch from current:
Ignore signals if/when we are exiting.
Prevents a hang in the NFS code when
dumping core and pressing ^C, etc.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.49 2001/09/21 21:36:48 deraadt Exp $	*/
a773 4
	/* Ignore signal if we are exiting */
	if (p->p_flag & P_WEXIT)
		return;

a1232 3

	/* Mark process as going away */
	p->p_flag |= P_WEXIT;
@


1.48
log
@cosmetic.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.47 2001/08/09 14:44:42 niklas Exp $	*/
d390 1
a390 1
	register struct sigacts *ps = p->p_sigacts;
d394 1
@


1.47
log
@Unshare signal actions on exec, from NetBSD.  While I am here a little KNF nit too
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.46 2001/06/27 04:49:44 art Exp $	*/
d546 1
a546 1
	psp->ps_sigstk= ss;
@


1.46
log
@remove old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.45 2001/06/22 14:14:09 deraadt Exp $	*/
d393 2
d531 1
a531 1
	if (SCARG(uap, nss) == 0)
@


1.45
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.44 2001/06/18 09:00:24 art Exp $	*/
a1353 1
#if defined(UVM)
a1354 3
#else
		error = vm_coredump(p, vp, cred, &core);
#endif
@


1.44
log
@trace_req is a nop.
rename stop -> proc_stop (stop is not a good function name).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.43 2001/05/16 05:07:52 millert Exp $	*/
d275 1
a275 1
			       sizeof (vec));
d417 1
a417 1
	p->p_flag &= ~P_NOCLDWAIT;	
d454 1
a454 1
	
d598 2
a599 2
	
	if (all)	
d601 1
a601 1
		 * broadcast 
d612 2
a613 2
		if (pgid == 0)		
			/* 
d726 2
a727 2
			ktrpsig(p, signum, ps->ps_sigact[signum], 
				p->p_sigmask, code);
d1442 1
a1442 1
 * signal knotes are shared with proc knotes, so we apply a mask to 
@


1.43
log
@kill COMPAT_{09,10,11} kernel options.  We still need kern_info_09.c and kern_ipc_10.c for other compat modules.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.42 2001/04/02 21:43:12 niklas Exp $	*/
d87 1
a87 1
void stop __P((struct proc *p));
d867 1
a867 1
			stop(p);
d1009 2
a1010 4
				do {
					stop(p);
					mi_switch();
				} while (!trace_req(p) && p->p_flag & P_TRACED);
d1070 1
a1070 1
				stop(p);
d1115 2
a1116 2
stop(p)
	register struct proc *p;
@


1.42
log
@On popular demand, the Linux-compatibility clone(2) implementation based
on NetBSD's code, as well as some faked Posix RT extensions by me.  This makes
at least simple linuxthreads tests work.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.41 2001/02/19 10:21:48 art Exp $	*/
a560 4

#ifdef COMPAT_09
	SCARG(uap, pid) = (short) SCARG(uap, pid);
#endif
@


1.42.2.1
log
@MFC, requested by weingart@@

Ignore signals if/when we are exiting.
Prevents a hang in the NFS code when
dumping core and pressing ^C, etc.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.42 2001/04/02 21:43:12 niklas Exp $	*/
a774 4
	/* Ignore signal if we are exiting */
	if (p->p_flag & P_WEXIT)
		return;

a1235 3

	/* Mark process as going away */
	p->p_flag |= P_WEXIT;
@


1.41
log
@Clean up spl handling.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.40 2000/11/16 20:02:17 provos Exp $	*/
d66 2
a77 1
#if defined(UVM)
a78 1
#endif
d91 2
d149 73
@


1.40
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.39 2000/11/10 18:15:47 art Exp $	*/
d214 3
a216 2
	register struct sigacts *ps = p->p_sigacts;
	register int bit;
d222 1
a222 1
	(void) splhigh();
d290 1
a290 1
	(void) spl0();
d362 1
d365 1
a365 1
	(void) splhigh();
d384 1
a384 1
	(void) spl0();
d1063 3
a1065 3
	register struct proc *p = curproc;
	register struct sigacts *ps = p->p_sigacts;
	register sig_t action;
d1069 1
d1107 1
a1107 1
		(void) splhigh();
d1120 1
a1120 1
		(void) spl0();
@


1.39
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.38 2000/06/05 11:02:50 art Exp $	*/
d49 1
d52 1
d80 7
d695 3
d1345 41
@


1.38
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.37 2000/04/21 15:47:27 millert Exp $	*/
d644 1
a644 1
			ktrpsig(p->p_tracep, signum, ps->ps_sigact[signum], 
d1065 1
a1065 2
		ktrpsig(p->p_tracep,
		    signum, action, ps->ps_flags & SAS_OLDMASK ?
@


1.37
log
@Change kernel-only open flag FNOSYMLINK to userland-visible O_NOFOLLOW;
adapated from FreeBSD.  Also change O_FSYNC to the more standard O_SYNC
and document it.  open(2) needs some real examples for proper usage,
to come later.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.36 2000/03/03 11:31:43 art Exp $	*/
d545 1
a545 1
			if (signum)
@


1.36
log
@Use LIST_ macros instead of internal field names to walk the allproc list.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.35 1999/11/05 01:18:01 mickey Exp $	*/
d1202 1
a1202 1
	error = vn_open(&nd, O_CREAT | FWRITE | FNOSYMLINK, S_IRUSR | S_IWUSR);
@


1.35
log
@more stack direction fixes; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.34 1999/07/18 17:05:13 deraadt Exp $	*/
d521 1
a521 1
		for (p = allproc.lh_first; p != 0; p = p->p_list.le_next) {
@


1.35.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d521 1
a521 1
		for (p = LIST_FIRST(&allproc); p; p = LIST_NEXT(p, p_list)) {
@


1.35.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.42 2001/04/02 21:43:12 niklas Exp $	*/
a48 1
#include <sys/queue.h>
a50 1
#include <sys/event.h>
a63 2
#include <sys/malloc.h>
#include <sys/pool.h>
d74 1
d76 1
a76 7

int	filt_sigattach(struct knote *kn);
void	filt_sigdetach(struct knote *kn);
int	filt_signal(struct knote *kn, long hint);

struct filterops sig_filtops =
	{ 0, filt_sigattach, filt_sigdetach, filt_signal };
a81 2
struct pool sigacts_pool;	/* memory pool for sigacts structures */

a138 73
/*
 * Initialize signal-related data structures.
 */
void
signal_init()
{
	pool_init(&sigacts_pool, sizeof(struct sigacts), 0, 0, 0, "sigapl",
	    0, pool_page_alloc_nointr, pool_page_free_nointr, M_SUBPROC);
}

/*
 * Create an initial sigacts structure, using the same signal state
 * as p.
 */
struct sigacts *
sigactsinit(p)
	struct proc *p;
{
	struct sigacts *ps;

	ps = pool_get(&sigacts_pool, PR_WAITOK);
	memcpy(ps, p->p_sigacts, sizeof(struct sigacts));
	ps->ps_refcnt = 1;
	return (ps);
}

/*
 * Make p2 share p1's sigacts.
 */
void
sigactsshare(p1, p2)
	struct proc *p1, *p2;
{

	p2->p_sigacts = p1->p_sigacts;
	p1->p_sigacts->ps_refcnt++;
}

/*
 * Make this process not share its sigacts, maintaining all
 * signal state.
 */
void
sigactsunshare(p)
	struct proc *p;
{
	struct sigacts *newps;

	if (p->p_sigacts->ps_refcnt == 1)
		return;

	newps = sigactsinit(p);
	sigactsfree(p);
	p->p_sigacts = newps;
}

/*
 * Release a sigacts structure.
 */
void
sigactsfree(p)
	struct proc *p;
{
	struct sigacts *ps = p->p_sigacts;

	if (--ps->ps_refcnt > 0)
		return;

	p->p_sigacts = NULL;

	pool_put(&sigacts_pool, ps);
}

d205 2
a206 3
	struct sigacts *ps = p->p_sigacts;
	int bit;
	int s;
d212 1
a212 1
	s = splhigh();
d280 1
a280 1
	splx(s);
a351 1
	int s;
d354 1
a354 1
	s = splhigh();
d373 1
a373 1
	splx(s);
d545 1
a545 1
			if (signum && P_ZOMBIE(p) == 0)
d644 1
a644 1
			ktrpsig(p, signum, ps->ps_sigact[signum], 
a685 3

	KNOTE(&p->p_klist, NOTE_SIGNAL | signum);

d1049 3
a1051 3
	struct proc *p = curproc;
	struct sigacts *ps = p->p_sigacts;
	sig_t action;
a1054 1
	int s;
d1065 2
a1066 1
		ktrpsig(p, signum, action, ps->ps_flags & SAS_OLDMASK ?
d1093 1
a1093 1
		s = splhigh();
d1106 1
a1106 1
		splx(s);
d1202 1
a1202 1
	error = vn_open(&nd, O_CREAT | FWRITE | O_NOFOLLOW, S_IRUSR | S_IWUSR);
a1333 41
}

int
filt_sigattach(struct knote *kn)
{
	struct proc *p = curproc;

	kn->kn_ptr.p_proc = p;
	kn->kn_flags |= EV_CLEAR;		/* automatically set */

	/* XXX lock the proc here while adding to the list? */
	SLIST_INSERT_HEAD(&p->p_klist, kn, kn_selnext);

	return (0);
}

void
filt_sigdetach(struct knote *kn)
{
	struct proc *p = kn->kn_ptr.p_proc;

	SLIST_REMOVE(&p->p_klist, kn, knote, kn_selnext);
}

/*
 * signal knotes are shared with proc knotes, so we apply a mask to 
 * the hint in order to differentiate them from process hints.  This
 * could be avoided by using a signal-specific knote list, but probably
 * isn't worth the trouble.
 */
int
filt_signal(struct knote *kn, long hint)
{

	if (hint & NOTE_SIGNAL) {
		hint &= ~NOTE_SIGNAL;

		if (kn->kn_id == hint)
			kn->kn_data++;
	}
	return (kn->kn_data != 0);
@


1.35.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.35.2.2 2001/05/14 22:32:41 niklas Exp $	*/
d87 1
a87 1
void proc_stop __P((struct proc *p));
d275 1
a275 1
		    sizeof (vec));
d417 1
a417 1
	p->p_flag &= ~P_NOCLDWAIT;
d454 1
a454 1

d562 4
d602 2
a603 2

	if (all)
d605 1
a605 1
		 * broadcast
d616 2
a617 2
		if (pgid == 0)
			/*
d730 2
a731 2
			ktrpsig(p, signum, ps->ps_sigact[signum],
			    p->p_sigmask, code);
d871 1
a871 1
			proc_stop(p);
d1013 4
a1016 2
				proc_stop(p);
				mi_switch();
d1076 1
a1076 1
				proc_stop(p);
d1121 2
a1122 2
proc_stop(p)
	struct proc *p;
d1360 1
d1362 3
d1448 1
a1448 1
 * signal knotes are shared with proc knotes, so we apply a mask to
@


1.35.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.35.2.3 2001/07/04 10:48:25 niklas Exp $	*/
d390 1
a390 1
	register struct sigacts *ps;
a392 3
	sigactsunshare(p);
	ps = p->p_sigacts;

d529 1
a529 1
	if (SCARG(uap, nss) == NULL)
d544 1
a544 1
	psp->ps_sigstk = ss;
@


1.35.2.5
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 3
a78 1
#include <sys/user.h>		/* for coredump */
@


1.35.2.6
log
@Merge in trunk
@
text
@d155 1
a155 1
	    &pool_allocator_nointr);
d305 12
a316 11
		/*
		 * If the SA_NOCLDWAIT flag is set or the handler
		 * is SIG_IGN we reparent the dying child to PID 1
		 * (init) which will reap the zombie.  Because we use
		 * init to do our dirty work we never set P_NOCLDWAIT
		 * for PID 1.
		 */
		if (p->p_pid != 1 && ((sa->sa_flags & SA_NOCLDWAIT) ||
		    sa->sa_handler == SIG_IGN))
			p->p_flag |= P_NOCLDWAIT;
		else
a418 2
	if (ps->ps_sigact[SIGCHLD] == SIG_IGN)
		ps->ps_sigact[SIGCHLD] = SIG_DFL;
a720 9
#ifdef KTRACE
	if (KTRPOINT(p, KTR_PSIG)) {
		siginfo_t si;

		initsiginfo(&si, signum, code, type, sigval);
		ktrpsig(p, signum, ps->ps_sigact[signum],
		    p->p_sigmask, code, &si);
	}
#endif
d725 5
a771 4
	/* Ignore signal if we are exiting */
	if (p->p_flag & P_WEXIT)
		return;

d1149 1
a1149 5
	if (KTRPOINT(p, KTR_PSIG)) {
		siginfo_t si;
		
		null_sigval.sival_ptr = 0;
		initsiginfo(&si, signum, 0, SI_USER, null_sigval);
d1151 1
a1151 2
		    ps->ps_oldmask : p->p_sigmask, code, &si);
	}
a1230 3

	/* Mark process as going away */
	p->p_flag |= P_WEXIT;
@


1.35.2.7
log
@Merge in -current from about a week ago
@
text
@d85 3
a87 3
void proc_stop(struct proc *p);
void killproc(struct proc *, char *);
int cansignal(struct proc *, struct pcred *, struct proc *, int);
@


1.35.2.8
log
@Sync the SMP branch with 3.3
@
text
@a103 3
	if (p == q)
		return (1);		/* process can always signal itself */

a116 1
		case SIGALRM:
d775 2
a780 2
	KNOTE(&p->p_klist, NOTE_SIGNAL | signum);

d978 2
a979 1
issignal(struct proc *p)
d981 1
a981 2
	int signum, mask, prop;
	int s;
a1006 1
			s = splstatclock();	/* protect mi_switch */
a1021 1
			splx(s);
a1080 1
				s = splstatclock();
a1081 1
				splx(s);
a1156 7

	if (ps->ps_sig != signum) {
		code = 0;
	} else {
		code = ps->ps_code;
	}

d1206 4
a1209 1
		if (ps->ps_sig == signum) {
@


1.35.2.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.35.2.8 2003/03/28 00:41:26 niklas Exp $	*/
d1312 1
a1312 1
	snprintf(name, sizeof name, "%s.core", p->p_comm);
@


1.35.2.10
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.35.2.9 2003/05/13 19:21:28 ho Exp $	*/
a765 2
 *
 * XXXSMP: Invoked as psignal() or sched_psignal().
d768 1
a768 1
psignal1(p, signum, dolock)
a770 1
	int dolock;		/* XXXSMP: works, but icky */
a775 1
#ifdef DIAGNOSTIC
a778 7
	/* XXXSMP: works, but icky */
	if (dolock)
		SCHED_ASSERT_UNLOCKED();
	else
		SCHED_ASSERT_LOCKED();
#endif

d838 1
a838 4
	/* XXXSMP: works, but icky */
	if (dolock)
		SCHED_LOCK(s);

d880 1
a880 5
				/*
				 * XXXSMP: recursive call; don't lock
				 * the second time around.
				 */
				sched_psignal(p->p_pptr, SIGCHLD);
d966 1
a966 3
	/* XXXSMP: works, but icky */
	if (dolock)
		SCHED_UNLOCK(s);
d1011 1
a1011 1
			SCHED_LOCK(s);	/* protect mi_switch */
a1026 1
			SCHED_ASSERT_UNLOCKED();
d1087 1
a1087 1
				SCHED_LOCK(s);
a1088 1
				SCHED_ASSERT_UNLOCKED();
a1135 1
	SCHED_ASSERT_LOCKED();
a1161 3

	KERNEL_PROC_LOCK(p);

d1206 1
a1206 1
		s = splsched();
a1227 2

	KERNEL_PROC_UNLOCK(p);
d1257 1
@


1.35.2.11
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.35.2.10 2003/05/15 04:08:02 niklas Exp $	*/
d22 5
a26 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.35.2.12
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d230 1
a230 1
		syscallarg(const struct sigaction *) nsa;
d266 2
a267 1
		error = copyout(sa, SCARG(uap, osa), sizeof (vec));
d272 2
a273 1
		error = copyin(SCARG(uap, nsa), sa, sizeof (vec));
d504 1
a504 1
	while (tsleep(ps, PPAUSE|PCATCH, "pause", 0) == 0)
a511 45
sys_osigaltstack(p, v, retval)
	struct proc *p;
	void *v;
	register_t *retval;
{
	register struct sys_osigaltstack_args /* {
		syscallarg(const struct osigaltstack *) nss;
		syscallarg(struct osigaltstack *) oss;
	} */ *uap = v;
	struct sigacts *psp;
	struct osigaltstack ss;
	int error;

	psp = p->p_sigacts;
	if ((psp->ps_flags & SAS_ALTSTACK) == 0)
		psp->ps_sigstk.ss_flags |= SS_DISABLE;
	if (SCARG(uap, oss)) {
		ss.ss_sp = psp->ps_sigstk.ss_sp;
		ss.ss_size = psp->ps_sigstk.ss_size;
		ss.ss_flags = psp->ps_sigstk.ss_flags;
		if ((error = copyout(&ss, SCARG(uap, oss), sizeof(ss))))
			return (error);
	}
	if (SCARG(uap, nss) == NULL)
		return (0);
	error = copyin(SCARG(uap, nss), &ss, sizeof(ss));
	if (error)
		return (error);
	if (ss.ss_flags & SS_DISABLE) {
		if (psp->ps_sigstk.ss_flags & SS_ONSTACK)
			return (EINVAL);
		psp->ps_flags &= ~SAS_ALTSTACK;
		psp->ps_sigstk.ss_flags = ss.ss_flags;
		return (0);
	}
	if (ss.ss_size < MINSIGSTKSZ)
		return (ENOMEM);
	psp->ps_flags |= SAS_ALTSTACK;
	psp->ps_sigstk.ss_sp = ss.ss_sp;
	psp->ps_sigstk.ss_size = ss.ss_size;
	psp->ps_sigstk.ss_flags = ss.ss_flags;
	return (0);
}

int
d518 1
a518 1
		syscallarg(const struct sigaltstack *) nss;
d528 2
a529 2
	if (SCARG(uap, oss) && (error = copyout(&psp->ps_sigstk,
	    SCARG(uap, oss), sizeof(struct sigaltstack))))
d533 1
a533 1
	error = copyin(SCARG(uap, nss), &ss, sizeof(ss));
d834 1
a834 1
	if (prop & SA_STOP) {
a835 2
		p->p_flag &= ~P_CONTINUED;
	}
a929 2
			p->p_flag |= P_CONTINUED;
			wakeup(p->p_pptr);
d1032 1
a1032 1
				wakeup(p);
d1158 1
a1158 1
	wakeup(p->p_pptr);
d1318 1
a1318 1
	    (error = suser(p, 0)) != 0)
d1367 1
a1367 1
	strlcpy(core.c_name, p->p_comm, sizeof(core.c_name));
@


1.35.2.13
log
@Merge with the trunk
@
text
@d765 9
a776 9
#ifdef KTRACE
		if (KTRPOINT(p, KTR_PSIG)) {
			siginfo_t si;

			initsiginfo(&si, signum, code, type, sigval);
			ktrpsig(p, signum, ps->ps_sigact[signum],
			    p->p_sigmask, type, &si);
		}
#endif
a787 1
		ps->ps_sig = signum;
a788 2
		ps->ps_type = type;
		ps->ps_sigval = sigval;
d1221 2
a1222 2
	union sigval sigval;
	int s, type;
a1233 2
	sigval.sival_ptr = 0;
	type = SI_USER;
a1236 2
		type = SI_USER;
		sigval.sival_ptr = 0;
a1238 2
		type = ps->ps_type;
		sigval = ps->ps_sigval;
d1245 2
a1246 1
		initsiginfo(&si, signum, code, type, sigval);
d1248 1
a1248 1
		    ps->ps_oldmask : p->p_sigmask, type, &si);
a1290 1
			ps->ps_sig = 0;
a1291 2
			ps->ps_type = SI_USER;
			ps->ps_sigval.sival_ptr = NULL;
d1293 1
a1293 1

d1295 1
a1295 1
		    type, sigval);
@


1.35.2.14
log
@few fixes to make non-smp compile
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.35.2.13 2004/06/05 23:13:01 niklas Exp $	*/
a64 1
#include <sys/sched.h>
@


1.35.2.15
log
@don't rely on curcpu() and other fixes for non-mp
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.35.2.14 2004/06/05 23:18:25 tedu Exp $	*/
a1204 1
#ifdef MULTIPROCESSOR
a1205 1
#endif
@


1.35.2.16
log
@splsched not in !MP
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.35.2.15 2004/06/06 21:46:12 tedu Exp $	*/
a1285 1
#ifdef MULTIPROCESSOR
a1286 3
#else
		s = splhigh();
#endif
@


1.34
log
@on exec, clear P_NOCLDWAIT; ambrisko@@whistle.com
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.33 1999/02/26 05:10:40 art Exp $	*/
d1258 3
d1262 1
@


1.33
log
@uvm allocation and name changes
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.32 1999/02/18 00:01:38 deraadt Exp $	*/
d332 1
@


1.32
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.31 1999/02/17 23:27:38 deraadt Exp $	*/
d74 4
d1266 3
d1270 1
@


1.31
log
@missing spl; christos
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.30 1998/06/07 20:17:25 deraadt Exp $	*/
a364 1
		(void) spl0();
@


1.30
log
@permit SIGUSR1/USR2 through as well in cansignal()
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.29 1998/05/30 20:54:42 deraadt Exp $	*/
d365 1
@


1.29
log
@permit sig 0 (existance checking) to setuid parents; ibo@@ragnarok.val-axs.net
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.28 1998/05/18 21:41:45 deraadt Exp $	*/
d109 2
@


1.28
log
@add more signals to setuid part of cansignal()
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.27 1998/05/17 19:38:43 deraadt Exp $	*/
d100 1
@


1.27
log
@convert CANSIGNAL() macro into a function, and then add significant constraints
regarding setuid/setgid targets (this is permitted by POSIX, and solves a
number of security issues).  This is due to a conversation months ago with
dholland@@hcs.harvard.edu.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.26 1998/02/20 14:46:18 niklas Exp $	*/
d104 4
@


1.26
log
@GCC 2.8 caught this type error, thanks
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.25 1998/01/09 16:41:09 csapuntz Exp $	*/
d76 1
d81 46
a126 9
#define CANSIGNAL(p, pc, q, signum) \
	((pc)->pc_ucred->cr_uid == 0 || \
	    (pc)->p_ruid == (q)->p_cred->p_ruid || \
	    (pc)->p_ruid == (q)->p_cred->p_svuid || \
	    (pc)->pc_ucred->cr_uid == (q)->p_cred->p_ruid || \
	    (pc)->pc_ucred->cr_uid == (q)->p_cred->p_svuid || \
	    (pc)->p_ruid == (q)->p_ucred->cr_uid || \
	    (pc)->pc_ucred->cr_uid == (q)->p_ucred->cr_uid || \
	    ((signum) == SIGCONT && (q)->p_session == (p)->p_session))
d474 1
a474 1
		if (!CANSIGNAL(cp, pc, p, SCARG(uap, signum)))
d511 1
a511 1
			    p == cp || !CANSIGNAL(cp, pc, p, signum))
d530 1
a530 1
			    !CANSIGNAL(cp, pc, p, signum))
@


1.25
log
@core dumps disabled for SUID programs is default again.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.24 1998/01/09 16:33:48 csapuntz Exp $	*/
d1004 1
d1064 1
d1066 1
a1066 1
		    SI_USER, (union sigval *)0);
@


1.24
log
@Get rid of dumping across symlinks. Races can cause this to be problematic
from a security standpoint (i.e. arbitrary files on the FS can be wiped out).
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.23 1997/12/08 21:25:36 deraadt Exp $	*/
d1106 1
a1106 1
int nosuidcoredump = 0;
@


1.23
log
@add kern.nosuidcoredump to lock things out even more
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.22 1997/11/06 05:58:18 csapuntz Exp $	*/
d1106 1
a1106 1
int nosuidcoredump = 1;
d1149 4
a1152 1
	if ((error = vn_open(&nd, O_CREAT | FWRITE, S_IRUSR | S_IWUSR)) != 0) {
@


1.22
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.21 1997/10/06 20:19:56 deraadt Exp $	*/
d1106 2
d1132 2
@


1.21
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.19 1997/09/15 05:46:13 millert Exp $	*/
d1216 1
a1216 1
	VOP_UNLOCK(vp);
@


1.20
log
@VFS Lite2 Changes
@
text
@d1216 1
a1216 1
	VOP_UNLOCK(vp, 0, p);
@


1.19
log
@From FreeBSD (joerg@@freebsd.org):
    Implement SA_NOCLDWAIT by reparenting kids of processes that have
    the appropriate bit set to PID 1, and let PID 1 handle the zombie.
    This assumes that PID 1 will wait for its kids (which is true of init).
    This also includes some FreeBSD sigaction.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.18 1997/09/12 02:47:34 deraadt Exp $	*/
d1216 1
a1216 1
	VOP_UNLOCK(vp);
@


1.18
log
@add copyright for the work i did in csignal()
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.17 1997/08/31 20:42:18 deraadt Exp $	*/
d129 2
d173 13
@


1.17
log
@for non-tty TIOCSPGRP/F_SETOWN/FIOSETOWN pgid setting calls, store uid
and euid as well, then deliver them using new csignal() interface
which ensures that pgid setting process is permitted to signal the
pgid process(es). Thanks to newsham@@aloha.net for extensive help and
discussion.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.16 1997/02/01 21:49:41 deraadt Exp $	*/
d5 1
@


1.16
log
@add type & union sigval args to sendsig/trapsignal
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.15 1997/01/27 22:48:36 deraadt Exp $	*/
d484 40
@


1.15
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.14 1997/01/27 01:15:32 deraadt Exp $	*/
d522 1
a522 1
trapsignal(p, signum, code, addr)
d526 2
a527 1
	caddr_t addr;
d542 1
a542 1
		    p->p_sigmask, code, addr);
d1007 2
a1008 1
		(*p->p_emul->e_sendsig)(action, signum, returnmask, code, 0);
d1185 1
a1185 1
initsiginfo(si, sig)
d1188 3
d1193 1
d1195 16
a1210 1
	si->si_addr = (caddr_t)-1;
@


1.14
log
@initial cut at SA_SIGINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.12 1996/10/27 04:56:51 tholo Exp $	*/
d522 1
a522 1
trapsignal(p, signum, code)
d526 1
d541 1
a541 1
		    p->p_sigmask, code);
d1006 1
a1006 1
		(*p->p_emul->e_sendsig)(action, signum, returnmask, code);
@


1.13
log
@Signal handling now fully POSIX.1-1990 compliant
@
text
@d123 2
d175 4
d1179 10
@


1.12
log
@Allow kill(, 0) on process groups that hold only zombies; per POSIX
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.11 1996/10/27 03:48:29 tholo Exp $	*/
d82 2
a84 1
	    (pc)->pc_ucred->cr_uid == (q)->p_cred->p_ruid || \
d109 1
a109 1
	    signum == SIGKILL || signum == SIGSTOP)
@


1.11
log
@Don't verify that euid has write permission
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.10 1996/10/27 02:26:55 tholo Exp $	*/
a468 1
			    p->p_stat == SZOMB ||
@


1.10
log
@Correct last fix
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.9 1996/10/26 07:28:13 tholo Exp $	*/
a1056 2
	uid_t uid;
	gid_t gid;
a1070 24
	sprintf(name, "%s.core", p->p_comm);

	/*
	 * Verify that EUID can write a core file...
	 */
	uid = cred->cr_uid;
	gid = cred->cr_gid;
	cred->cr_uid = p->p_cred->p_ruid;
	cred->cr_gid = p->p_cred->p_rgid;
	NDINIT(&nd, LOOKUP, NOFOLLOW | LOCKLEAF, UIO_SYSSPACE, name, p);
	if ((error = namei(&nd)) != 0) {
		cred->cr_uid = uid;
		cred->cr_gid = gid;
		return (error);
	}
	vp = nd.ni_vp;
	if ((error = vn_writechk(vp)) == 0)
		error = VOP_ACCESS(vp, VWRITE, cred, p);
	vput(vp);
	cred->cr_uid = uid;
	cred->cr_gid = gid;
	if (error)
		return (error);

d1078 1
@


1.9
log
@A process can send a signal to another process if the uid of the signalling
process is the same as the saved uid of the signalled process
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.8 1996/10/20 07:37:22 tholo Exp $	*/
d82 1
a82 1
	    (pc)->p_ruid == (q)->p_cred->p_svuid || \
@


1.8
log
@Further limit the cases where we write core files
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.7 1996/10/18 06:08:40 tholo Exp $	*/
d82 1
@


1.7
log
@From Keith Bostic, with some minor changes:
 The problem reported on BUGTRACK was that ftpd could be convinced to
 drop core after it had discarded its special permissions, but while
 it still had a copy of the encrypted passwords in its buffers.  Change
 coredump() to:

     + Don't drop core for any process that was ever setuid/setgid if
       it's not running as root.
     + Change errno returns from EFAULT to appropriate values -- this
       will be useful for when coredump() becomes a system call and
       gcore goes away.
     + Create core dump files mode 600, and don't dump to files that
       are owned by anyone else or readable or writable by anyone other
       than the owner.
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.6 1996/09/03 11:01:43 deraadt Exp $	*/
d1049 1
a1049 1
	register struct ucred *cred = p->p_cred->pc_ucred;
d1056 2
d1070 1
a1070 1
		return (EFAULT);
d1073 21
a1093 2
	NDINIT(&nd, LOOKUP, NOFOLLOW, UIO_SYSSPACE, name, p);
	if ((error = vn_open(&nd, O_CREAT | FWRITE, S_IRUSR | S_IWUSR)) != 0)
d1097 1
a1097 1
	 * Change euid to uid for coredump output
d1101 7
@


1.6
log
@another typo....
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.5 1996/09/03 05:01:45 deraadt Exp $	*/
d1049 1
a1049 2
	register struct pcred *pcred = p->p_cred;
	register struct ucred *cred = pcred->pc_ucred;
d1057 9
a1065 6
	if (!(pcred->p_svuid == pcred->p_ruid && pcred->p_ruid == 0) &&
	    (pcred->p_svuid != pcred->p_ruid ||
	    cred->cr_uid != pcred->p_ruid ||
	    pcred->p_svgid != pcred->p_rgid ||
	    cred->cr_gid != pcred->p_rgid))
		return (EFAULT);
d1069 1
d1071 2
a1072 3
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, name, p);
	error = vn_open(&nd, O_CREAT | FWRITE, S_IRUSR | S_IWUSR);
	if (error)
d1074 11
d1086 2
a1087 1

d1089 3
a1091 3
	if (vp->v_type != VREG ||
	    VOP_GETATTR(vp, &vattr, cred, p) || vattr.va_nlink != 1) {
		error = EFAULT;
d1126 1
a1126 1
		    IO_NODELOCKED|IO_UNIT, cred, (int *) NULL, p);
d1133 1
a1133 1
		    IO_NODELOCKED|IO_UNIT, cred, (int *) NULL, p);
d1144 1
a1144 1
		    UIO_SYSSPACE, IO_NODELOCKED|IO_UNIT, cred, (int *) NULL, p);
d1149 1
@


1.5
log
@do not coredump for setuid/setgid, unless run by root
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.4 1996/05/02 13:12:13 deraadt Exp $	*/
d1062 2
a1063 2
	    cred->cr_gid != pcred->p_rgid)
			return (EFAULT);
@


1.4
log
@sync syscalls, no sys/cpu.h
@
text
@d1 1
a1 1
/*	$OpenBSD: kern_sig.c,v 1.3 1996/03/03 17:19:54 niklas Exp $	*/
d1058 6
a1063 2
	if (pcred->p_svuid != pcred->p_ruid || pcred->p_svgid != pcred->p_rgid)
		return (EFAULT);
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: kern_sig.c,v 1.53 1996/02/09 18:59:47 christos Exp $	*/
a63 1
#include <sys/cpu.h>
@


1.2
log
@ss_sp is correct, ss_base is not. noticed by agc@@sde.uts.amdahl.com; netbsd pr#1784
@
text
@d1 2
a2 1
/*	$NetBSD: kern_sig.c,v 1.51 1996/01/04 22:23:14 jtc Exp $	*/
d63 2
d75 1
d89 1
d129 3
a131 2
		if (error = copyout((caddr_t)sa, (caddr_t)SCARG(uap, osa),
		    sizeof (vec)))
d135 3
a137 2
		if (error = copyin((caddr_t)SCARG(uap, nsa), (caddr_t)sa,
		    sizeof (vec)))
d144 1
d268 1
d305 1
d350 1
d372 2
a373 2
	if (error = copyin((caddr_t)SCARG(uap, nss), (caddr_t)&ss,
	    sizeof (ss)))
d434 1
d1006 1
d1025 1
a1025 1
int
d1066 2
a1067 1
	if (error = vn_open(&nd, O_CREAT | FWRITE, S_IRUSR | S_IWUSR))
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: kern_sig.c,v 1.50 1995/10/07 06:28:25 mycroft Exp $	*/
d250 1
a250 1
	ps->ps_sigstk.ss_base = 0;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
