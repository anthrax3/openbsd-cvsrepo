head	1.178;
access;
symbols
	OPENBSD_6_2:1.178.0.4
	OPENBSD_6_2_BASE:1.178
	OPENBSD_6_1:1.174.0.4
	OPENBSD_6_1_BASE:1.174
	OPENBSD_6_0:1.173.0.2
	OPENBSD_6_0_BASE:1.173
	OPENBSD_5_9:1.166.0.2
	OPENBSD_5_9_BASE:1.166
	OPENBSD_5_8:1.155.0.4
	OPENBSD_5_8_BASE:1.155
	OPENBSD_5_7:1.152.0.2
	OPENBSD_5_7_BASE:1.152
	OPENBSD_5_6:1.143.0.4
	OPENBSD_5_6_BASE:1.143
	OPENBSD_5_5:1.138.0.4
	OPENBSD_5_5_BASE:1.138
	OPENBSD_5_4:1.133.0.2
	OPENBSD_5_4_BASE:1.133
	OPENBSD_5_3:1.126.0.2
	OPENBSD_5_3_BASE:1.126
	OPENBSD_5_2:1.124.0.2
	OPENBSD_5_2_BASE:1.124
	OPENBSD_5_1_BASE:1.120
	OPENBSD_5_1:1.120.0.2
	OPENBSD_5_0:1.118.0.2
	OPENBSD_5_0_BASE:1.118
	OPENBSD_4_9:1.104.0.2
	OPENBSD_4_9_BASE:1.104
	OPENBSD_4_8:1.102.0.2
	OPENBSD_4_8_BASE:1.102
	OPENBSD_4_7:1.98.0.2
	OPENBSD_4_7_BASE:1.98
	OPENBSD_4_6:1.93.0.4
	OPENBSD_4_6_BASE:1.93
	OPENBSD_4_5:1.90.0.4
	OPENBSD_4_5_BASE:1.90
	OPENBSD_4_4:1.90.0.2
	OPENBSD_4_4_BASE:1.90
	OPENBSD_4_3:1.89.0.2
	OPENBSD_4_3_BASE:1.89
	OPENBSD_4_2:1.86.0.4
	OPENBSD_4_2_BASE:1.86
	OPENBSD_4_1:1.86.0.2
	OPENBSD_4_1_BASE:1.86
	OPENBSD_4_0:1.84.0.2
	OPENBSD_4_0_BASE:1.84
	OPENBSD_3_9:1.81.0.2
	OPENBSD_3_9_BASE:1.81
	OPENBSD_3_8:1.78.0.2
	OPENBSD_3_8_BASE:1.78
	OPENBSD_3_7:1.76.0.4
	OPENBSD_3_7_BASE:1.76
	OPENBSD_3_6:1.76.0.2
	OPENBSD_3_6_BASE:1.76
	SMP_SYNC_A:1.70
	SMP_SYNC_B:1.70
	OPENBSD_3_5:1.68.0.2
	OPENBSD_3_5_BASE:1.68
	OPENBSD_3_4:1.62.0.2
	OPENBSD_3_4_BASE:1.62
	UBC_SYNC_A:1.58
	OPENBSD_3_3:1.52.0.2
	OPENBSD_3_3_BASE:1.52
	OPENBSD_3_2:1.50.0.2
	OPENBSD_3_2_BASE:1.50
	OPENBSD_3_1:1.49.0.2
	OPENBSD_3_1_BASE:1.49
	UBC_SYNC_B:1.50
	UBC:1.47.0.4
	UBC_BASE:1.47
	OPENBSD_3_0:1.47.0.2
	OPENBSD_3_0_BASE:1.47
	OPENBSD_2_9_BASE:1.44
	OPENBSD_2_9:1.44.0.2
	OPENBSD_2_8:1.42.0.2
	OPENBSD_2_8_BASE:1.42
	OPENBSD_2_7:1.40.0.2
	OPENBSD_2_7_BASE:1.40
	SMP:1.38.0.2
	SMP_BASE:1.38
	kame_19991208:1.37
	OPENBSD_2_6:1.37.0.2
	OPENBSD_2_6_BASE:1.37
	OPENBSD_2_5:1.34.0.2
	OPENBSD_2_5_BASE:1.34
	OPENBSD_2_4:1.31.0.2
	OPENBSD_2_4_BASE:1.31
	OPENBSD_2_3:1.23.0.2
	OPENBSD_2_3_BASE:1.23
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.178
date	2017.09.25.23.00.33;	author espie;	state Exp;
branches;
next	1.177;
commitid	vl8MegKTD7zWuRDb;

1.177
date	2017.08.12.00.03.10;	author tedu;	state Exp;
branches;
next	1.176;
commitid	cUT8xG3ajI2ygOIy;

1.176
date	2017.04.28.13.50.55;	author mpi;	state Exp;
branches;
next	1.175;
commitid	34WECc0W9rocx17W;

1.175
date	2017.04.13.04.06.46;	author guenther;	state Exp;
branches;
next	1.174;
commitid	SVe5BdUCNRQed2sI;

1.174
date	2016.09.04.17.22.40;	author jsing;	state Exp;
branches;
next	1.173;
commitid	NpC0d7eh7RcmjtSO;

1.173
date	2016.06.27.16.50.07;	author jsing;	state Exp;
branches;
next	1.172;
commitid	vNiSMzS85BVJulyq;

1.172
date	2016.05.31.22.08.53;	author deraadt;	state Exp;
branches;
next	1.171;
commitid	VRV3qRKeJkyolbwt;

1.171
date	2016.05.31.22.06.29;	author deraadt;	state Exp;
branches;
next	1.170;
commitid	IvzSbipHHouoqHFy;

1.170
date	2016.05.17.08.12.06;	author mpi;	state Exp;
branches;
next	1.169;
commitid	xzZOSOXnh8nEL2Y6;

1.169
date	2016.03.30.07.49.11;	author guenther;	state Exp;
branches;
next	1.168;
commitid	CEQ2oOx0iodZAOMX;

1.168
date	2016.03.28.20.49.58;	author kettenis;	state Exp;
branches;
next	1.167;
commitid	uhHVZ2hCVC24VwS6;

1.167
date	2016.03.21.22.41.29;	author bluhm;	state Exp;
branches;
next	1.166;
commitid	hneUpr7ZOJCeNeHP;

1.166
date	2015.11.24.23.47.17;	author deraadt;	state Exp;
branches;
next	1.165;
commitid	V7BLs5V4QDzb5x07;

1.165
date	2015.11.10.04.30.59;	author guenther;	state Exp;
branches;
next	1.164;
commitid	GTAoVjpQRAdNHXVz;

1.164
date	2015.10.28.12.03.39;	author deraadt;	state Exp;
branches;
next	1.163;
commitid	mkxJ3rVL6ZrebUew;

1.163
date	2015.10.18.00.04.43;	author deraadt;	state Exp;
branches;
next	1.162;
commitid	19QhHGSTTsDpRV7q;

1.162
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.161;
commitid	av6ZVErLSWkVP5Zz;

1.161
date	2015.10.02.17.49.40;	author kettenis;	state Exp;
branches;
next	1.160;
commitid	M6Fe6QJDvkuyh5HT;

1.160
date	2015.09.26.15.38.53;	author tedu;	state Exp;
branches;
next	1.159;
commitid	bQD6P8WbwjBwBvc3;

1.159
date	2015.09.13.17.08.03;	author guenther;	state Exp;
branches;
next	1.158;
commitid	BssYI6s6zozAyfkk;

1.158
date	2015.09.09.17.56.59;	author deraadt;	state Exp;
branches;
next	1.157;
commitid	LR11yk102SoyZdKV;

1.157
date	2015.08.26.05.20.06;	author doug;	state Exp;
branches;
next	1.156;
commitid	B5zLNz9UGGYolarc;

1.156
date	2015.08.22.20.18.49;	author deraadt;	state Exp;
branches;
next	1.155;
commitid	6NDuzTPjBp2GqkfQ;

1.155
date	2015.07.20.00.56.10;	author guenther;	state Exp;
branches;
next	1.154;
commitid	pi31sn0pO464Xi5e;

1.154
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	1.153;
commitid	CJwjm9NDWu6nJ6ES;

1.153
date	2015.05.06.11.20.07;	author jsg;	state Exp;
branches;
next	1.152;
commitid	pfMlFdH5X7CpVznR;

1.152
date	2015.02.09.13.54.23;	author deraadt;	state Exp;
branches;
next	1.151;
commitid	zsZBDsYV3eZuB4xU;

1.151
date	2015.02.09.13.41.24;	author pelikan;	state Exp;
branches;
next	1.150;
commitid	A5GI5pfcmwpscN1L;

1.150
date	2015.02.09.13.34.19;	author deraadt;	state Exp;
branches;
next	1.149;
commitid	2BWqTLOQoFfPvFm5;

1.149
date	2014.12.08.20.56.11;	author guenther;	state Exp;
branches;
next	1.148;
commitid	W5ntmn0jpthTCbn0;

1.148
date	2014.10.09.03.35.06;	author tedu;	state Exp;
branches;
next	1.147;
commitid	bMhz4xLbYeHA3o1u;

1.147
date	2014.09.18.02.15.04;	author uebayasi;	state Exp;
branches;
next	1.146;
commitid	jXXUqzREIi58BEkt;

1.146
date	2014.09.17.19.26.06;	author millert;	state Exp;
branches;
next	1.145;
commitid	yJt5bEm99YJcufDq;

1.145
date	2014.09.01.05.09.53;	author doug;	state Exp;
branches;
next	1.144;
commitid	XQe4V1YtkyCx6uWd;

1.144
date	2014.08.31.01.42.36;	author guenther;	state Exp;
branches;
next	1.143;
commitid	zF5A8BuuSSyqaDyM;

1.143
date	2014.07.10.08.55.35;	author deraadt;	state Exp;
branches;
next	1.142;
commitid	pbN6jG3m5FuHrSxQ;

1.142
date	2014.07.07.19.59.00;	author matthew;	state Exp;
branches;
next	1.141;
commitid	1gs2kO50T1pIuDl2;

1.141
date	2014.07.06.20.55.58;	author kettenis;	state Exp;
branches;
next	1.140;
commitid	fosZ4K1teyXSrCgz;

1.140
date	2014.06.14.18.01.42;	author deraadt;	state Exp;
branches;
next	1.139;
commitid	mGZAeMJ1mGoco6ZP;

1.139
date	2014.06.13.08.26.10;	author deraadt;	state Exp;
branches;
next	1.138;
commitid	CpYJ4dq5gv2iN1W3;

1.138
date	2014.02.09.10.04.42;	author guenther;	state Exp;
branches;
next	1.137;

1.137
date	2013.09.14.01.35.01;	author guenther;	state Exp;
branches;
next	1.136;

1.136
date	2013.08.16.08.33.20;	author guenther;	state Exp;
branches;
next	1.135;

1.135
date	2013.08.14.05.26.14;	author guenther;	state Exp;
branches;
next	1.134;

1.134
date	2013.08.13.05.52.24;	author guenther;	state Exp;
branches;
next	1.133;

1.133
date	2013.06.09.13.10.19;	author miod;	state Exp;
branches;
next	1.132;

1.132
date	2013.06.01.16.27.37;	author tedu;	state Exp;
branches;
next	1.131;

1.131
date	2013.06.01.09.49.50;	author miod;	state Exp;
branches;
next	1.130;

1.130
date	2013.04.29.17.06.20;	author matthew;	state Exp;
branches;
next	1.129;

1.129
date	2013.04.15.15.32.19;	author jsing;	state Exp;
branches;
next	1.128;

1.128
date	2013.03.14.21.38.22;	author tedu;	state Exp;
branches;
next	1.127;

1.127
date	2013.03.02.07.05.18;	author guenther;	state Exp;
branches;
next	1.126;

1.126
date	2012.09.10.02.22.17;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2012.08.23.06.12.49;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2012.06.21.00.56.59;	author guenther;	state Exp;
branches;
next	1.123;

1.123
date	2012.04.12.12.33.03;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2012.04.12.11.16.24;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2012.04.12.11.07.19;	author deraadt;	state Exp;
branches;
next	1.120;

1.120
date	2012.01.17.02.34.18;	author guenther;	state Exp;
branches;
next	1.119;

1.119
date	2011.10.15.23.35.29;	author guenther;	state Exp;
branches;
next	1.118;

1.118
date	2011.07.18.00.16.54;	author matthew;	state Exp;
branches;
next	1.117;

1.117
date	2011.07.09.05.46.26;	author matthew;	state Exp;
branches;
next	1.116;

1.116
date	2011.07.09.05.31.26;	author matthew;	state Exp;
branches;
next	1.115;

1.115
date	2011.07.09.00.18.06;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2011.07.09.00.10.51;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2011.07.08.19.19.20;	author tedu;	state Exp;
branches;
next	1.112;

1.112
date	2011.07.08.05.01.27;	author matthew;	state Exp;
branches;
next	1.111;

1.111
date	2011.07.07.23.45.00;	author matthew;	state Exp;
branches;
next	1.110;

1.110
date	2011.07.07.18.30.50;	author tedu;	state Exp;
branches;
next	1.109;

1.109
date	2011.07.07.01.19.40;	author tedu;	state Exp;
branches;
next	1.108;

1.108
date	2011.06.30.13.43.14;	author tedu;	state Exp;
branches;
next	1.107;

1.107
date	2011.06.01.06.20.41;	author guenther;	state Exp;
branches;
next	1.106;

1.106
date	2011.06.01.06.18.07;	author guenther;	state Exp;
branches;
next	1.105;

1.105
date	2011.04.04.12.44.10;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2010.10.28.15.02.41;	author millert;	state Exp;
branches;
next	1.103;

1.103
date	2010.09.20.07.18.03;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.101;

1.101
date	2010.07.01.23.10.40;	author tedu;	state Exp;
branches;
next	1.100;

1.100
date	2010.07.01.01.54.38;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2010.06.29.00.28.14;	author tedu;	state Exp;
branches;
next	1.98;

1.98
date	2010.01.18.19.09.39;	author schwarze;	state Exp;
branches;
next	1.97;

1.97
date	2009.11.27.20.05.50;	author guenther;	state Exp;
branches;
next	1.96;

1.96
date	2009.11.27.19.45.53;	author guenther;	state Exp;
branches;
next	1.95;

1.95
date	2009.11.27.19.43.55;	author guenther;	state Exp;
branches;
next	1.94;

1.94
date	2009.11.27.19.42.24;	author guenther;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.03.15.42.03;	author jj;	state Exp;
branches;
next	1.92;

1.92
date	2009.06.03.14.45.54;	author jj;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.12.06.56.13;	author guenther;	state Exp;
branches;
next	1.90;

1.90
date	2008.03.16.19.42.57;	author otto;	state Exp;
branches;
next	1.89;

1.89
date	2008.01.05.00.36.13;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2007.11.28.13.47.02;	author deraadt;	state Exp;
branches;
next	1.87;

1.87
date	2007.11.27.18.04.47;	author art;	state Exp;
branches;
next	1.86;

1.86
date	2006.09.22.17.35.41;	author pedro;	state Exp;
branches;
next	1.85;

1.85
date	2006.09.22.14.36.24;	author pedro;	state Exp;
branches;
next	1.84;

1.84
date	2006.06.14.19.52.07;	author otto;	state Exp;
branches;
next	1.83;

1.83
date	2006.06.09.00.05.54;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2006.04.28.08.34.31;	author pedro;	state Exp;
branches;
next	1.81;

1.81
date	2005.12.30.04.02.17;	author tedu;	state Exp;
branches;
next	1.80;

1.80
date	2005.12.13.06.02.03;	author tedu;	state Exp;
branches;
next	1.79;

1.79
date	2005.12.03.18.09.08;	author tedu;	state Exp;
branches;
next	1.78;

1.78
date	2005.07.03.20.13.59;	author drahn;	state Exp;
branches;
next	1.77;

1.77
date	2005.06.17.20.39.14;	author millert;	state Exp;
branches;
next	1.76;

1.76
date	2004.07.15.14.35.34;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2004.07.15.11.24.46;	author millert;	state Exp;
branches;
next	1.74;

1.74
date	2004.07.14.23.45.11;	author millert;	state Exp;
branches;
next	1.73;

1.73
date	2004.07.14.18.00.48;	author millert;	state Exp;
branches;
next	1.72;

1.72
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.71;

1.71
date	2004.07.09.23.52.02;	author millert;	state Exp;
branches;
next	1.70;

1.70
date	2004.05.27.20.48.46;	author tedu;	state Exp;
branches;
next	1.69;

1.69
date	2004.05.03.17.38.48;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	2004.02.28.19.44.16;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2004.01.14.05.23.25;	author tedu;	state Exp;
branches;
next	1.66;

1.66
date	2004.01.12.18.06.51;	author tedu;	state Exp;
branches;
next	1.65;

1.65
date	2003.12.31.00.13.24;	author millert;	state Exp;
branches;
next	1.64;

1.64
date	2003.12.11.23.02.30;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2003.12.10.23.10.08;	author millert;	state Exp;
branches;
next	1.62;

1.62
date	2003.09.07.21.00.27;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2003.07.01.22.18.09;	author tedu;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.23.04.26.53;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.22.21.34.16;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2003.05.10.17.53.58;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2003.04.29.19.52.32;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2003.04.28.21.32.08;	author drahn;	state Exp;
branches;
next	1.55;

1.55
date	2003.04.25.20.32.07;	author drahn;	state Exp;
branches;
next	1.54;

1.54
date	2003.04.25.18.30.18;	author drahn;	state Exp;
branches;
next	1.53;

1.53
date	2003.04.14.04.53.50;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2003.01.30.03.29.49;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2002.10.30.20.02.58;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2002.07.06.19.14.20;	author nordin;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.14.00.42.25;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.22.20.37.45;	author drahn;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.26.19.56.52;	author dugsong;	state Exp;
branches
	1.47.4.1;
next	1.46;

1.46
date	2001.06.16.22.16.23;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.16.17.14.35;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2001.03.09.15.11.47;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2000.11.16.20.02.17;	author provos;	state Exp;
branches;
next	1.42;

1.42
date	2000.09.12.17.25.56;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2000.06.22.22.41.19;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	2000.05.01.23.10.58;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2000.04.20.06.32.23;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2000.02.07.04.49.27;	author assar;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	99.06.07.07.17.42;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	99.05.31.17.34.47;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	99.05.22.21.23.40;	author weingart;	state Exp;
branches;
next	1.34;

1.34
date	99.02.15.21.28.23;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	99.02.15.20.00.49;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	98.11.18.01.14.25;	author art;	state Exp;
branches;
next	1.31;

1.31
date	98.09.17.20.54.04;	author art;	state Exp;
branches;
next	1.30;

1.30
date	98.08.30.18.18.00;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	98.08.30.18.04.21;	author art;	state Exp;
branches;
next	1.28;

1.28
date	98.06.12.08.31.11;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	98.06.11.18.29.53;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	98.06.02.05.22.29;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	98.05.11.06.13.45;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.04.25.07.14.45;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.02.16.21.56.28;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	98.02.10.08.44.07;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.02.08.22.37.01;	author tholo;	state Exp;
branches;
next	1.20;

1.20
date	98.01.02.05.32.51;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.11.14.20.56.03;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	97.11.13.18.35.31;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.11.13.07.11.12;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	97.08.29.20.44.24;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.05.30.21.43.33;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.04.20.20.48.27;	author tholo;	state Exp;
branches;
next	1.13;

1.13
date	97.01.26.05.18.27;	author downsj;	state Exp;
branches;
next	1.12;

1.12
date	96.10.29.03.46.28;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.10.04.00.59.19;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.08.25.09.51.34;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.18.08.53.10;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.02.13.09.50;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.28.00.26.47;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.04.19.16.09.07;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.01.29.23.05.08;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.01.10.18.02.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.07.17.20.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.11.12;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.45;	author deraadt;	state Exp;
branches;
next	;

1.38.2.1
date	2001.05.14.22.32.44;	author niklas;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2001.07.04.10.48.38;	author niklas;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2002.03.06.02.13.23;	author niklas;	state Exp;
branches;
next	1.38.2.4;

1.38.2.4
date	2002.03.28.11.43.04;	author niklas;	state Exp;
branches;
next	1.38.2.5;

1.38.2.5
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.38.2.6;

1.38.2.6
date	2003.05.13.19.21.28;	author ho;	state Exp;
branches;
next	1.38.2.7;

1.38.2.7
date	2004.02.19.10.56.38;	author niklas;	state Exp;
branches;
next	1.38.2.8;

1.38.2.8
date	2004.06.05.23.13.02;	author niklas;	state Exp;
branches;
next	;

1.47.4.1
date	2002.06.11.03.29.40;	author art;	state Exp;
branches;
next	1.47.4.2;

1.47.4.2
date	2002.10.29.00.36.44;	author art;	state Exp;
branches;
next	1.47.4.3;

1.47.4.3
date	2003.05.19.22.31.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.178
log
@sendsyslog should take a const char * everywhere.

okay bluhm@@, deraadt@@
@
text
@;	$OpenBSD: syscalls.master,v 1.177 2017/08/12 00:03:10 tedu Exp $
;	$NetBSD: syscalls.master,v 1.32 1996/04/23 10:24:21 mycroft Exp $

;	@@(#)syscalls.master	8.2 (Berkeley) 1/13/94

; OpenBSD system call name/number "master" file.
; (See syscalls.conf to see what it is processed into.)
;
; Fields: number type [type-dependent ...]
;	number	system call number, must be in order
;	type	one of the types described below, or one of the
;		compatibility options defined in syscalls.conf
;
; types:
;	INDIR	included, but don't define the syscall args structure,
;		and allow it to be "really" varargs
;	NOARGS	included, but don't define the syscall args structure
;	NODEF	included, but don't define the syscall number
;	NOLOCK	don't acquire the kernel lock when calling this syscall
;	OBSOL	obsolete, not included in system
;	STD	always included
;	UNIMPL	unimplemented, not included in system
;
; The compat options are defined in the syscalls.conf file, and the
; compat option name is prefixed to the syscall name.  Other than
; that, they're like NODEF (for 'compat' options), or STD (for
; 'libcompat' options).
;
; The type-dependent arguments are as follows:
; For STD, NODEF, NOARGS, and compat syscalls:
;	{ pseudo-proto } [alias]
; For other syscalls:
;	[comment]
;
; #ifdef's, etc. may be included, and are copied to the output files.
; #include's are copied to the syscall switch definition file only.

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signal.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#include <sys/poll.h>

; Reserved/unimplemented system calls in the range 0-150 inclusive
; are reserved for use in future Berkeley releases.
; Additional system calls implemented in vendor and other
; redistributions should be placed in the reserved range at the end
; of the current calls.

0	INDIR		{ int sys_syscall(int number, ...); }
1	STD		{ void sys_exit(int rval); }
2	STD		{ int sys_fork(void); }
3	STD		{ ssize_t sys_read(int fd, void *buf, size_t nbyte); }
4	STD		{ ssize_t sys_write(int fd, const void *buf, \
			    size_t nbyte); }
5	STD		{ int sys_open(const char *path, \
			    int flags, ... mode_t mode); }
6	STD		{ int sys_close(int fd); }
7	STD NOLOCK	{ int sys_getentropy(void *buf, size_t nbyte); }
8	STD		{ int sys___tfork(const struct __tfork *param, \
			    size_t psize); }
9	STD		{ int sys_link(const char *path, const char *link); }
10	STD		{ int sys_unlink(const char *path); }
11	STD		{ pid_t sys_wait4(pid_t pid, int *status, \
			    int options, struct rusage *rusage); }
12	STD		{ int sys_chdir(const char *path); }
13	STD		{ int sys_fchdir(int fd); }
14	STD		{ int sys_mknod(const char *path, mode_t mode, \
			    dev_t dev); }
15	STD		{ int sys_chmod(const char *path, mode_t mode); }
16	STD		{ int sys_chown(const char *path, uid_t uid, \
			    gid_t gid); }
17	STD		{ int sys_obreak(char *nsize); } break
18	STD NOLOCK	{ int sys_getdtablecount(void); }
19	STD		{ int sys_getrusage(int who, \
			    struct rusage *rusage); }
20	STD NOLOCK	{ pid_t sys_getpid(void); }
21	STD		{ int sys_mount(const char *type, const char *path, \
			    int flags, void *data); }
22	STD		{ int sys_unmount(const char *path, int flags); }
23	STD		{ int sys_setuid(uid_t uid); }
24	STD NOLOCK	{ uid_t sys_getuid(void); }
25	STD NOLOCK	{ uid_t sys_geteuid(void); }
#ifdef PTRACE
26	STD		{ int sys_ptrace(int req, pid_t pid, caddr_t addr, \
			    int data); }
#else
26	UNIMPL		ptrace
#endif
27	STD		{ ssize_t sys_recvmsg(int s, struct msghdr *msg, \
			    int flags); }
28	STD		{ ssize_t sys_sendmsg(int s, \
			    const struct msghdr *msg, int flags); }
29	STD		{ ssize_t sys_recvfrom(int s, void *buf, size_t len, \
			    int flags, struct sockaddr *from, \
			    socklen_t *fromlenaddr); }
30	STD		{ int sys_accept(int s, struct sockaddr *name, \
			    socklen_t *anamelen); }
31	STD		{ int sys_getpeername(int fdes, struct sockaddr *asa, \
			    socklen_t *alen); }
32	STD		{ int sys_getsockname(int fdes, struct sockaddr *asa, \
			    socklen_t *alen); }
33	STD		{ int sys_access(const char *path, int amode); }
34	STD		{ int sys_chflags(const char *path, u_int flags); }
35	STD		{ int sys_fchflags(int fd, u_int flags); }
36	STD		{ void sys_sync(void); }
37	OBSOL		o58_kill
38	STD		{ int sys_stat(const char *path, struct stat *ub); }
39	STD		{ pid_t sys_getppid(void); }
40	STD		{ int sys_lstat(const char *path, struct stat *ub); }
41	STD		{ int sys_dup(int fd); }
42	STD		{ int sys_fstatat(int fd, const char *path, \
			    struct stat *buf, int flag); }
43	STD NOLOCK	{ gid_t sys_getegid(void); }
44	STD		{ int sys_profil(caddr_t samples, size_t size, \
			    u_long offset, u_int scale); }
#ifdef KTRACE
45	STD		{ int sys_ktrace(const char *fname, int ops, \
			    int facs, pid_t pid); }
#else
45	UNIMPL		ktrace
#endif
46	STD		{ int sys_sigaction(int signum, \
			    const struct sigaction *nsa, \
			    struct sigaction *osa); }
47	STD NOLOCK	{ gid_t sys_getgid(void); }
48	STD NOLOCK	{ int sys_sigprocmask(int how, sigset_t mask); }
49	OBSOL		ogetlogin
50	STD		{ int sys_setlogin(const char *namebuf); }
#ifdef ACCOUNTING
51	STD		{ int sys_acct(const char *path); }
#else
51	UNIMPL		acct
#endif
52	STD		{ int sys_sigpending(void); }
53	STD		{ int sys_fstat(int fd, struct stat *sb); }
54	STD		{ int sys_ioctl(int fd, \
			    u_long com, ... void *data); }
55	STD		{ int sys_reboot(int opt); }
56	STD		{ int sys_revoke(const char *path); }
57	STD		{ int sys_symlink(const char *path, \
			    const char *link); }
58	STD		{ ssize_t sys_readlink(const char *path, \
			    char *buf, size_t count); }
59	STD		{ int sys_execve(const char *path, \
			    char * const *argp, char * const *envp); }
60	STD		{ mode_t sys_umask(mode_t newmask); }
61	STD		{ int sys_chroot(const char *path); }
62	STD		{ int sys_getfsstat(struct statfs *buf, size_t bufsize, \
			    int flags); }
63	STD		{ int sys_statfs(const char *path, \
			    struct statfs *buf); }
64	STD		{ int sys_fstatfs(int fd, struct statfs *buf); }
65	STD		{ int sys_fhstatfs(const fhandle_t *fhp, \
			    struct statfs *buf); }
66	STD		{ int sys_vfork(void); }
67	STD NOLOCK	{ int sys_gettimeofday(struct timeval *tp, \
			    struct timezone *tzp); }
68	STD		{ int sys_settimeofday(const struct timeval *tv, \
			    const struct timezone *tzp); }
69	STD		{ int sys_setitimer(int which, \
			    const struct itimerval *itv, \
			    struct itimerval *oitv); }
70	STD		{ int sys_getitimer(int which, \
			    struct itimerval *itv); }
71	STD		{ int sys_select(int nd, fd_set *in, fd_set *ou, \
			    fd_set *ex, struct timeval *tv); }
72	STD		{ int sys_kevent(int fd, \
			    const struct kevent *changelist, int nchanges, \
			    struct kevent *eventlist, int nevents, \
			    const struct timespec *timeout); }
73	STD		{ int sys_munmap(void *addr, size_t len); }
74	STD		{ int sys_mprotect(void *addr, size_t len, \
			    int prot); }
75	STD		{ int sys_madvise(void *addr, size_t len, \
			    int behav); }
76	STD		{ int sys_utimes(const char *path, \
			    const struct timeval *tptr); }
77	STD		{ int sys_futimes(int fd, \
			    const struct timeval *tptr); }
78	STD		{ int sys_mincore(void *addr, size_t len, \
			    char *vec); }
79	STD NOLOCK	{ int sys_getgroups(int gidsetsize, \
			    gid_t *gidset); }
80	STD		{ int sys_setgroups(int gidsetsize, \
			    const gid_t *gidset); }
81	STD		{ int sys_getpgrp(void); }
82	STD		{ int sys_setpgid(pid_t pid, pid_t pgid); }
83	STD NOLOCK	{ int sys_futex(uint32_t *f, int op, int val, \
			    const struct timespec *timeout, uint32_t *g); }
84	STD		{ int sys_utimensat(int fd, const char *path, \
			    const struct timespec *times, int flag); }
85	STD		{ int sys_futimens(int fd, \
			    const struct timespec *times); }
86	STD		{ int sys_kbind(const struct __kbind *param, \
			    size_t psize, int64_t proc_cookie); }
87	STD NOLOCK	{ int sys_clock_gettime(clockid_t clock_id, \
			    struct timespec *tp); }
88	STD		{ int sys_clock_settime(clockid_t clock_id, \
			    const struct timespec *tp); }
89	STD NOLOCK	{ int sys_clock_getres(clockid_t clock_id, \
			    struct timespec *tp); }
90	STD		{ int sys_dup2(int from, int to); }
91	STD		{ int sys_nanosleep(const struct timespec *rqtp, \
			    struct timespec *rmtp); }
92	STD		{ int sys_fcntl(int fd, int cmd, ... void *arg); }
93	STD		{ int sys_accept4(int s, struct sockaddr *name, \
			    socklen_t *anamelen, int flags); }
94	STD		{ int sys___thrsleep(const volatile void *ident, \
			    clockid_t clock_id, const struct timespec *tp, \
			    void *lock, const int *abort); }
95	STD		{ int sys_fsync(int fd); }
96	STD		{ int sys_setpriority(int which, id_t who, int prio); }
97	STD		{ int sys_socket(int domain, int type, int protocol); }
98	STD		{ int sys_connect(int s, const struct sockaddr *name, \
			    socklen_t namelen); }
99	STD		{ int sys_getdents(int fd, void *buf, size_t buflen); }
100	STD		{ int sys_getpriority(int which, id_t who); }
101	STD		{ int sys_pipe2(int *fdp, int flags); }
102	STD		{ int sys_dup3(int from, int to, int flags); }
103	STD		{ int sys_sigreturn(struct sigcontext *sigcntxp); }
104	STD		{ int sys_bind(int s, const struct sockaddr *name, \
			    socklen_t namelen); }
105	STD		{ int sys_setsockopt(int s, int level, int name, \
			    const void *val, socklen_t valsize); }
106	STD		{ int sys_listen(int s, int backlog); }
107	STD		{ int sys_chflagsat(int fd, const char *path, \
			    u_int flags, int atflags); }
108	STD 		{ int sys_pledge(const char *request, const char **paths); }
109	STD		{ int sys_ppoll(struct pollfd *fds, \
			    u_int nfds, const struct timespec *ts, \
			    const sigset_t *mask); }
110	STD		{ int sys_pselect(int nd, fd_set *in, fd_set *ou, \
			    fd_set *ex, const struct timespec *ts, \
			    const sigset_t *mask); }
111	STD		{ int sys_sigsuspend(int mask); }
112	STD		{ int sys_sendsyslog(const char *buf, size_t nbyte, \
			    int flags); }
#ifdef KTRACE
113	STD		{ int sys_fktrace(int fd, int ops, \
			    int facs, pid_t pid); }
#else
113	UNIMPL		fktrace
#endif
114	OBSOL		osendmsg
115	OBSOL		vtrace
116	OBSOL		t32_gettimeofday
117	OBSOL		t32_getrusage
118	STD		{ int sys_getsockopt(int s, int level, int name, \
			    void *val, socklen_t *avalsize); }
119	STD		{ int sys_thrkill(pid_t tid, int signum, void *tcb); }
120	STD		{ ssize_t sys_readv(int fd, \
			    const struct iovec *iovp, int iovcnt); }
121	STD		{ ssize_t sys_writev(int fd, \
			    const struct iovec *iovp, int iovcnt); }
122	STD		{ int sys_kill(int pid, int signum); }
123	STD		{ int sys_fchown(int fd, uid_t uid, gid_t gid); }
124	STD		{ int sys_fchmod(int fd, mode_t mode); }
125	OBSOL		orecvfrom
126	STD		{ int sys_setreuid(uid_t ruid, uid_t euid); }
127	STD		{ int sys_setregid(gid_t rgid, gid_t egid); }
128	STD		{ int sys_rename(const char *from, const char *to); }
129	OBSOL		otruncate
130	OBSOL		oftruncate
131	STD		{ int sys_flock(int fd, int how); }
132	STD		{ int sys_mkfifo(const char *path, mode_t mode); }
133	STD		{ ssize_t sys_sendto(int s, const void *buf, \
			    size_t len, int flags, const struct sockaddr *to, \
			    socklen_t tolen); }
134	STD		{ int sys_shutdown(int s, int how); }
135	STD		{ int sys_socketpair(int domain, int type, \
			    int protocol, int *rsv); }
136	STD		{ int sys_mkdir(const char *path, mode_t mode); }
137	STD		{ int sys_rmdir(const char *path); }
138	OBSOL		t32_utimes
139	OBSOL		4.2 sigreturn
140	STD		{ int sys_adjtime(const struct timeval *delta, \
			    struct timeval *olddelta); }
141	STD		{ int sys_getlogin_r(char *namebuf, u_int namelen); }
142	OBSOL		ogethostid
143	OBSOL		osethostid
144	OBSOL		ogetrlimit
145	OBSOL		osetrlimit
146	OBSOL		okillpg
147	STD		{ int sys_setsid(void); }
148	STD		{ int sys_quotactl(const char *path, int cmd, \
			    int uid, char *arg); }
149	OBSOL		oquota
150	OBSOL		ogetsockname

; Syscalls 151-180 inclusive are reserved for vendor-specific
; system calls.  (This includes various calls added for compatibility
; with other Unix variants.)
; Some of these calls are now supported by BSD...
151	UNIMPL
152	UNIMPL
153	UNIMPL
154	UNIMPL
#if defined(NFSCLIENT) || defined(NFSSERVER)
155	STD		{ int sys_nfssvc(int flag, void *argp); }
#else
155	UNIMPL
#endif
156	OBSOL		ogetdirentries
157	OBSOL		statfs25
158	OBSOL		fstatfs25
159	UNIMPL
160	UNIMPL
161	STD		{ int sys_getfh(const char *fname, fhandle_t *fhp); }
162	OBSOL		ogetdomainname
163	OBSOL		osetdomainname
164	UNIMPL		ouname
165	STD		{ int sys_sysarch(int op, void *parms); }
166	UNIMPL
167	UNIMPL
168	UNIMPL
169	OBSOL		semsys10
170	OBSOL		msgsys10
171	OBSOL		shmsys10
172	UNIMPL
173	STD		{ ssize_t sys_pread(int fd, void *buf, \
			  size_t nbyte, int pad, off_t offset); }
174	STD		{ ssize_t sys_pwrite(int fd, const void *buf, \
			  size_t nbyte, int pad, off_t offset); }
175	UNIMPL		ntp_gettime
176	UNIMPL		ntp_adjtime
177	UNIMPL
178	UNIMPL
179	UNIMPL
180	UNIMPL

; Syscalls 181-199 are used by/reserved for BSD
181	STD		{ int sys_setgid(gid_t gid); }
182	STD		{ int sys_setegid(gid_t egid); }
183	STD		{ int sys_seteuid(uid_t euid); }
184	OBSOL		lfs_bmapv
185	OBSOL		lfs_markv
186	OBSOL		lfs_segclean
187	OBSOL		lfs_segwait
188	OBSOL		stat35
189	OBSOL		fstat35
190	OBSOL		lstat35
191	STD		{ long sys_pathconf(const char *path, int name); }
192	STD		{ long sys_fpathconf(int fd, int name); }
193	STD		{ int sys_swapctl(int cmd, const void *arg, int misc); }
194	STD		{ int sys_getrlimit(int which, \
			    struct rlimit *rlp); }
195	STD		{ int sys_setrlimit(int which, \
			    const struct rlimit *rlp); }
196	OBSOL		ogetdirentries48
197	STD		{ void *sys_mmap(void *addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }
198	INDIR		{ quad_t sys___syscall(quad_t num, ...); }
199	STD		{ off_t sys_lseek(int fd, int pad, off_t offset, \
			    int whence); }
200	STD		{ int sys_truncate(const char *path, int pad, \
			    off_t length); }
201	STD		{ int sys_ftruncate(int fd, int pad, off_t length); }
202	STD		{ int sys_sysctl(const int *name, u_int namelen, \
			    void *old, size_t *oldlenp, void *new, \
			    size_t newlen); }
203	STD		{ int sys_mlock(const void *addr, size_t len); }
204	STD		{ int sys_munlock(const void *addr, size_t len); }
205	UNIMPL		sys_undelete
206	OBSOL		t32_futimes
207	STD		{ pid_t sys_getpgid(pid_t pid); }
208	OBSOL		nnpfspioctl
209	STD		{ int sys_utrace(const char *label, const void *addr, \
			    size_t len); }
;
; Syscalls 210-219 were reserved for dynamically loaded syscalls
;
210	UNIMPL
211	UNIMPL
212	UNIMPL
213	UNIMPL
214	UNIMPL
215	UNIMPL
216	UNIMPL
217	UNIMPL
218	UNIMPL
219	UNIMPL
; System calls 220-240 are reserved for use by OpenBSD
#ifdef SYSVSEM
220	UNIMPL
221	STD		{ int sys_semget(key_t key, int nsems, int semflg); }
#else
220	UNIMPL		semctl
221	UNIMPL		semget
#endif
222	OBSOL		semop35
223	OBSOL		semconfig35
#ifdef SYSVMSG
224	UNIMPL
225	STD		{ int sys_msgget(key_t key, int msgflg); }
226	STD		{ int sys_msgsnd(int msqid, const void *msgp, size_t msgsz, \
			    int msgflg); }
227	STD		{ int sys_msgrcv(int msqid, void *msgp, size_t msgsz, \
			    long msgtyp, int msgflg); }
#else
224	UNIMPL		msgctl
225	UNIMPL		msgget
226	UNIMPL		msgsnd
227	UNIMPL		msgrcv
#endif
#ifdef SYSVSHM
228	STD		{ void *sys_shmat(int shmid, const void *shmaddr, \
			    int shmflg); }
229	UNIMPL
230	STD		{ int sys_shmdt(const void *shmaddr); }
#else
228	UNIMPL		shmat
229	UNIMPL		shmctl
230	UNIMPL		shmdt
#endif
231	OBSOL		shmget35
232	OBSOL		t32_clock_gettime
233	OBSOL		t32_clock_settime
234	OBSOL		t32_clock_getres
235	UNIMPL		timer_create
236	UNIMPL		timer_delete
237	UNIMPL		timer_settime
238	UNIMPL		timer_gettime
239	UNIMPL		timer_getoverrun
;
; System calls 240-249 are reserved for other IEEE Std1003.1b syscalls
;
240	OBSOL		t32_nanosleep
241	UNIMPL
242	UNIMPL
243	UNIMPL
244	UNIMPL
245	UNIMPL
246	UNIMPL
247	UNIMPL
248	UNIMPL
249	UNIMPL
250	STD		{ int sys_minherit(void *addr, size_t len, \
			    int inherit); }
251	OBSOL		rfork
252	STD		{ int sys_poll(struct pollfd *fds, \
			    u_int nfds, int timeout); }
253	STD NOLOCK	{ int sys_issetugid(void); }
254	STD		{ int sys_lchown(const char *path, uid_t uid, gid_t gid); }
255	STD		{ pid_t sys_getsid(pid_t pid); }
256	STD		{ int sys_msync(void *addr, size_t len, int flags); }
257	OBSOL		semctl35
258	OBSOL		shmctl35
259	OBSOL		msgctl35
260	UNIMPL
261	UNIMPL
262	UNIMPL
263	STD		{ int sys_pipe(int *fdp); }
264	STD		{ int sys_fhopen(const fhandle_t *fhp, int flags); }
265	UNIMPL
266	UNIMPL
267	STD		{ ssize_t sys_preadv(int fd, \
			  const struct iovec *iovp, int iovcnt, \
			  int pad, off_t offset); }
268	STD		{ ssize_t sys_pwritev(int fd, \
			  const struct iovec *iovp, int iovcnt, \
			  int pad, off_t offset); }
269	STD		{ int sys_kqueue(void); }
270	OBSOL		t32_kevent
271	STD		{ int sys_mlockall(int flags); }
272	STD		{ int sys_munlockall(void); }
273	UNIMPL		sys_getpeereid
274	UNIMPL		sys_extattrctl
275	UNIMPL		sys_extattr_set_file
276	UNIMPL		sys_extattr_get_file
277	UNIMPL		sys_extattr_delete_file
278	UNIMPL		sys_extattr_set_fd
279	UNIMPL		sys_extattr_get_fd
280	UNIMPL		sys_extattr_delete_fd
281	STD NOLOCK	{ int sys_getresuid(uid_t *ruid, uid_t *euid, \
			    uid_t *suid); }
282	STD		{ int sys_setresuid(uid_t ruid, uid_t euid, \
			    uid_t suid); }
283	STD NOLOCK	{ int sys_getresgid(gid_t *rgid, gid_t *egid, \
			    gid_t *sgid); }
284	STD		{ int sys_setresgid(gid_t rgid, gid_t egid, \
			    gid_t sgid); }
285	OBSOL		sys_omquery
286	STD		{ void *sys_mquery(void *addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }
287	STD		{ int sys_closefrom(int fd); }
288	STD		{ int sys_sigaltstack(const struct sigaltstack *nss, \
			    struct sigaltstack *oss); }
#ifdef SYSVSHM
289	STD		{ int sys_shmget(key_t key, size_t size, int shmflg); }
#else
289	UNIMPL		shmget
#endif
#ifdef SYSVSEM
290	STD		{ int sys_semop(int semid, struct sembuf *sops, \
			    size_t nsops); }
#else
290    UNIMPL		semop
#endif
291	OBSOL		t32_stat
292	OBSOL		t32_fstat
293	OBSOL		t32_lstat
294	STD		{ int sys_fhstat(const fhandle_t *fhp, \
			    struct stat *sb); }
#ifdef SYSVSEM
295	STD		{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); }
#else
295	UNIMPL
#endif
#ifdef SYSVSHM
296	STD		{ int sys_shmctl(int shmid, int cmd, \
			    struct shmid_ds *buf); }
#else
296	UNIMPL
#endif
#ifdef SYSVMSG
297	STD		{ int sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds *buf); }
#else
297	UNIMPL
#endif
298	STD		{ int sys_sched_yield(void); }
299	STD NOLOCK	{ pid_t sys_getthrid(void); }
300	OBSOL		t32___thrsleep
301	STD		{ int sys___thrwakeup(const volatile void *ident, \
			    int n); }
302	STD		{ void sys___threxit(pid_t *notdead); }
303	STD		{ int sys___thrsigdivert(sigset_t sigmask, \
			    siginfo_t *info, const struct timespec *timeout); }
304	STD		{ int sys___getcwd(char *buf, size_t len); }
305	STD		{ int sys_adjfreq(const int64_t *freq, \
			    int64_t *oldfreq); }
306	OBSOL		getfsstat53
307	OBSOL		statfs53
308	OBSOL		fstatfs53
309	OBSOL		fhstatfs53
310	STD		{ int sys_setrtable(int rtableid); }
311	STD NOLOCK	{ int sys_getrtable(void); }
312	OBSOL		t32_getdirentries
313	STD		{ int sys_faccessat(int fd, const char *path, \
			    int amode, int flag); }
314	STD		{ int sys_fchmodat(int fd, const char *path, \
			    mode_t mode, int flag); }
315	STD		{ int sys_fchownat(int fd, const char *path, \
			    uid_t uid, gid_t gid, int flag); }
316	OBSOL		t32_fstatat
317	STD		{ int sys_linkat(int fd1, const char *path1, int fd2, \
			    const char *path2, int flag); }
318	STD		{ int sys_mkdirat(int fd, const char *path, \
			    mode_t mode); }
319	STD		{ int sys_mkfifoat(int fd, const char *path, \
			    mode_t mode); }
320	STD		{ int sys_mknodat(int fd, const char *path, \
			    mode_t mode, dev_t dev); }
321	STD		{ int sys_openat(int fd, const char *path, int flags, \
			    ... mode_t mode); }
322	STD		{ ssize_t sys_readlinkat(int fd, const char *path, \
			    char *buf, size_t count); }
323	STD		{ int sys_renameat(int fromfd, const char *from, \
			    int tofd, const char *to); }
324	STD		{ int sys_symlinkat(const char *path, int fd, \
			    const char *link); }
325	STD		{ int sys_unlinkat(int fd, const char *path, \
			    int flag); }
326	OBSOL		t32_utimensat
327	OBSOL		t32_futimens
328	OBSOL		__tfork51
329	STD NOLOCK	{ void sys___set_tcb(void *tcb); }
330	STD NOLOCK	{ void *sys___get_tcb(void); }
@


1.177
log
@add a fktrace syscall that takes a file descriptor instead of a name.
libc and man page parts to come.
ok guenther
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.176 2017/04/28 13:50:55 mpi Exp $
d238 1
a238 1
112	STD		{ int sys_sendsyslog(const void *buf, size_t nbyte, \
@


1.176
log
@Add futex(2) syscall based on a sane subset of its Linux equivalent.

The syscall is marked NOLOCK and only FUTEX_WAIT grabs the KERNEL_LOCK()
because of PCATCH and the signal nightmare.

Serialization of threads is currently done with a global & exclusive
rwlock.

Note that the current implementation still use copyin(9) which is not
guaranteed to be atomic.  Committing now such that remaining issues can
be addressed in-tree.

With inputs from guenther@@, kettenis@@ and visa@@.

ok deraadt@@, visa@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.175 2017/04/13 04:06:46 guenther Exp $
d240 6
a245 1
113	OBSOL		orecvmsg
@


1.175
log
@Delete the getlogin59 syscall, which was last used one year, two releases,
and four libc major versions ago

ok sthen@@ jsing@@ deraadt@@ jca@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.174 2016/09/04 17:22:40 jsing Exp $
d190 2
a191 1
83	OBSOL		osendsyslog
@


1.174
log
@Remove sys_o58_kill since OpenBSD 6.0 has been tagged/released.

ok deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.173 2016/06/27 16:50:07 jsing Exp $
d129 1
a129 1
49	STD		{ int sys_getlogin59(char *namebuf, u_int namelen); }
@


1.173
log
@Restore the sys_o58_kill system call.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.170 2016/05/17 08:12:06 mpi Exp $
d108 1
a108 1
37	STD		{ int sys_o58_kill(int pid, int signum); }
@


1.172
log
@sys_osendsyslog can go away; we have transitioned to the new version with
a flags argument
ok guenther sthen
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.171 2016/05/31 22:06:29 deraadt Exp $
d108 1
a108 1
37	OBSOL		o58_kill
@


1.171
log
@sys_o58_kill is no longer needed for compat.
ok guenther sthen
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.170 2016/05/17 08:12:06 mpi Exp $
d190 1
a190 1
83	STD		{ int sys_osendsyslog(const void *buf, size_t nbyte); }
@


1.170
log
@Document NOLOCK, from Michal Mazurek.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.169 2016/03/30 07:49:11 guenther Exp $
d108 1
a108 1
37	STD		{ int sys_o58_kill(int pid, int signum); }
@


1.169
log
@Add getlogin_r syscall that checks and returns errors like userspace
getlogin_r() API; keep existing syscall as getlogin59 for temporary compat.

ok kettenis@@ deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.168 2016/03/28 20:49:58 kettenis Exp $
d11 2
a12 2
;	type	one of STD, OBSOL, UNIMPL, NODEF, NOARGS, or one of
;		the compatibility options defined in syscalls.conf.
d15 6
a21 1
;	OBSOL	obsolete, not included in system
a22 4
;	NODEF	included, but don't define the syscall number
;	NOARGS	included, but don't define the syscall args structure
;	INDIR	included, but don't define the syscall args structure,
;		and allow it to be "really" varargs.
@


1.168
log
@Make sure that a thread that calls sched_yield(2) ends up on the run queue
behind all other threads in the process by temporarily lowering its priority.
This isn't optimal but it is the easiest way to guarantee that we make
progress when we're waiting on an other thread to release a lock.  This
results in significant improvements for processes that suffer from lock
contention, most notably firefox.  Unfortunately this means that sched_yield(2)
needs to grab the kernel lock again.

All the hard work was done by mpi@@, based on observations of the behaviour
of the BFS scheduler diff by Michal Mazurek.

ok deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.167 2016/03/21 22:41:29 bluhm Exp $
d128 1
a128 1
49	STD		{ int sys_getlogin(char *namebuf, u_int namelen); }
d273 1
a273 1
141	OBSOL		ogetpeername
@


1.167
log
@Rename the system call sendsyslog2 to sendsyslog.  Keep the old one
as osendsyslog for a while.  The three argument variant is the only
one that will stay.
input kettenis@@;  OK deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.166 2015/11/24 23:47:17 deraadt Exp $
d517 1
a517 1
298	STD NOLOCK	{ int sys_sched_yield(void); }
@


1.166
log
@Add sendsyslog2... this has an additional flags variable to permit
passing LOG_CONS
ok millert kettenis beck
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.165 2015/11/10 04:30:59 guenther Exp $
d189 1
a189 1
83	STD		{ int sys_sendsyslog(const void *buf, size_t nbyte); }
d236 1
a236 1
112	STD		{ int sys_sendsyslog2(const void *buf, size_t nbyte, \
@


1.165
log
@Split the intra-thread functionality from kill(2) into its own syscall
thrkill(2), rolling the kill(2) syscall number with the ABI change to
avoid breaking binaries during during the transition.  thrkill(2) includes
a 'tcb' argument that eliminates the need for locking in pthread_kill()
and simplifies pthread_cancel().  Switch __stack_smash_handler() to use
thrkill(2) and explicitly unblock SIGABRT.

Minor bump to both libc and libpthread: make sure you install a new kernel!

ok semarie@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.164 2015/10/28 12:03:39 deraadt Exp $
d236 2
a237 1
112	OBSOL		osigstack
@


1.164
log
@The short-lived dnssocket/dnsconnect calls are being required because we
suspect everyone has upgraded through the approx week-long window since
SOCK_DNS became available and the libc resolver started using them.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.163 2015/10/18 00:04:43 deraadt Exp $
d107 1
a107 1
37	STD		{ int sys_kill(int pid, int signum); }
d244 1
a244 1
119	OBSOL		resuba
d249 1
a249 1
122	OBSOL		t32_settimeofday
@


1.163
log
@Add two new system calls: dnssocket() and dnsconnect().  This creates a
SS_DNS tagged socket which has limited functionality (for example, you
cannot accept on them...)  The libc resolver will switch to using these,
therefore pledge can identify a DNS transaction better.
ok tedu guenther kettenis beck and others
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.162 2015/10/09 01:10:27 deraadt Exp $
d300 2
a301 3
159	STD		{ int sys_dnsconnect(int s, const struct sockaddr *name, \
			    socklen_t namelen); }
160	STD		{ int sys_dnssocket(int domain, int type, int protocol); }
@


1.162
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.161 2015/10/02 17:49:40 kettenis Exp $
d300 3
a302 2
159	UNIMPL
160	UNIMPL
@


1.161
log
@Revert previous commit; something is not quite right yet in the bowels of uvm
as Theo is seeing vnode-related panics on several architectures in the
codepath that implements mmap(2).
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.160 2015/09/26 15:38:53 tedu Exp $
d228 1
a228 1
108	STD 		{ int sys_tame(const char *request, const char **paths); }
@


1.160
log
@unlock the mmap! reminded and ok kettenis
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.159 2015/09/13 17:08:03 guenther Exp $
d344 1
a344 1
197	STD NOLOCK	{ void *sys_mmap(void *addr, size_t len, int prot, \
@


1.159
log
@Rename __sysctl syscall to just sysctl, as the userland wrapper is no longer
necessary

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.158 2015/09/09 17:56:59 deraadt Exp $
d344 1
a344 1
197	STD		{ void *sys_mmap(void *addr, size_t len, int prot, \
@


1.158
log
@Move to next tame() API.  The flags are now passed as a very simple string,
which results in tame() code placements being much more recognizeable.
tame() can be moved to unistd.h and does not need cpp symbols to turn the
bits on and off.  The resulting API is a bit unexpected, but simplifies the
mapping to enabling bits in the kernel substantially.
vague ok's from various including guenther doug semarie
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.158 2015/09/09 17:49:31 deraadt Exp $
d352 1
a352 1
202	STD		{ int sys___sysctl(const int *name, u_int namelen, \
@


1.157
log
@Convert paths argument of tame(2) to const char **.

The path will not be modified and this reduces casts.  Discussed with many.

ok deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.156 2015/08/22 20:18:49 deraadt Exp $
d228 1
a228 1
108	STD 		{ int sys_tame(int flags, const char **paths); }
@


1.156
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.155 2015/07/20 00:56:10 guenther Exp $
d228 1
a228 1
108	STD 		{ int sys_tame(int flags, char **paths); }
@


1.155
log
@Add kbind, a syscall for ld.so to use to securely and efficiently update
memory for lazy binding

ok deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.154 2015/07/19 02:35:35 deraadt Exp $
d228 1
a228 1
108	STD 		{ int sys_tame(int flags); }
@


1.154
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.153 2015/05/06 11:20:07 jsg Exp $
d194 2
a195 1
86	OBSOL		t32_getitimer
@


1.153
log
@#include <sys/event.h> was removed from init_sysent.c but not
syscalls.master where the file is generated from.  Fix this by removing
it from syscalls.master so it doesn't come back.

From Nicolas Bedos.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.152 2015/02/09 13:54:23 deraadt Exp $
d227 1
a227 1
108	OBSOL		osigvec
@


1.152
log
@getrtable() can operate NOLOCK; ok guenther
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.151 2015/02/09 13:41:24 pelikan Exp $
a42 1
#include <sys/event.h>
@


1.151
log
@make sigprocmask(2) not take the kernel lock

Tests on a 4-core CPU show setjmp(3) run four times as fast under load.

discussed on tech@@ some time ago, now by kettenis and guenther, ok deraadt
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.150 2015/02/09 13:34:19 deraadt Exp $
d532 1
a532 1
311	STD		{ int sys_getrtable(void); }
@


1.150
log
@getdtablecount() can go NOLOCK
ok guenther
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.149 2014/12/08 20:56:11 guenther Exp $
d128 1
a128 1
48	STD		{ int sys_sigprocmask(int how, sigset_t mask); }
@


1.149
log
@Add chflagsat(), modeled on fchmodat() with name to match FreeBSD.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.148 2014/10/09 03:35:06 tedu Exp $
d75 1
a75 1
18	STD		{ int sys_getdtablecount(void); }
@


1.148
log
@delete LKM syscall stubs
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.147 2014/09/18 02:15:04 uebayasi Exp $
d226 2
a227 1
107	OBSOL		vtimes
@


1.147
log
@Correct argument name (int flags -> int amode) in sys_access().

OK guenther@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.146 2014/09/17 19:26:06 millert Exp $
d363 1
a363 1
; Syscalls 210-219 are reserved for dynamically loaded syscalls
a364 12
#ifdef LKM
210	NODEF		{ int sys_lkmnosys(void); }
211	NODEF		{ int sys_lkmnosys(void); }
212	NODEF		{ int sys_lkmnosys(void); }
213	NODEF		{ int sys_lkmnosys(void); }
214	NODEF		{ int sys_lkmnosys(void); }
215	NODEF		{ int sys_lkmnosys(void); }
216	NODEF		{ int sys_lkmnosys(void); }
217	NODEF		{ int sys_lkmnosys(void); }
218	NODEF		{ int sys_lkmnosys(void); }
219	NODEF		{ int sys_lkmnosys(void); }
#else	/* !LKM */
a374 1
#endif	/* !LKM */
@


1.146
log
@The  2nd arg of setpgid(2) should be pid_t, not int.
No functional change as pid_t is defined as int32_t.
OK miod@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.145 2014/09/01 05:09:53 doug Exp $
d104 1
a104 1
33	STD		{ int sys_access(const char *path, int flags); }
@


1.145
log
@Sync readlink(2) with IEEE Std 1003.1-2008.

discussion, help and ok guenther@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.144 2014/08/31 01:42:36 guenther Exp $
d189 1
a189 1
82	STD		{ int sys_setpgid(pid_t pid, int pgid); }
@


1.144
log
@Add additional kernel interfaces for setting close-on-exec on fds
when creating them: pipe2(), dup3(), accept4(), MSG_CMSG_CLOEXEC,
SOCK_CLOEXEC.  Includes SOCK_NONBLOCK support.

ok matthew@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.143 2014/07/10 08:55:35 deraadt Exp $
d144 2
a145 2
58	STD		{ int sys_readlink(const char *path, char *buf, \
			    size_t count); }
@


1.143
log
@Add new sendsyslog(const char *, size_t) system call which simply passes
a message up into syslogd's /dev/log interface.  This will be used to make
syslog_r work during file descriptor exhaustion, or inside sandboxes which
prohibit socket, connect, sendto, etc.
The system call is being added about a week before the library and daemon
changes.
ok guenther tedu miod matthew
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.142 2014/07/07 19:59:00 matthew Exp $
d206 2
a207 1
93	OBSOL		t32_select
d218 2
a219 2
101	OBSOL		osend
102	OBSOL		orecv
@


1.142
log
@Mark get{,e,res}{u,g}id() and getgroups() as NOLOCK

A little while back, guenther moved user credentials to a per-process
property, but also kept a per-thread cache that would remain stable
for the duration of a thread's system call.  These system calls now
only access the thread's cached credentials, so they're safe to run
without the kernel lock.

ok kettenis, guenther
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.141 2014/07/06 20:55:58 kettenis Exp $
d190 1
a190 1
83	OBSOL		t32_setitimer
@


1.141
log
@getentropy(2) doesn't need the kernel lock, so mark it with NOLOCK.

ok matthew@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.140 2014/06/14 18:01:42 deraadt Exp $
d83 2
a84 2
24	STD		{ uid_t sys_getuid(void); }
25	STD		{ uid_t sys_geteuid(void); }
d115 1
a115 1
43	STD		{ gid_t sys_getegid(void); }
d127 1
a127 1
47	STD		{ gid_t sys_getgid(void); }
d184 1
a184 1
79	STD		{ int sys_getgroups(int gidsetsize, \
d479 1
a479 1
281	STD		{ int sys_getresuid(uid_t *ruid, uid_t *euid, \
d483 1
a483 1
283	STD		{ int sys_getresgid(gid_t *rgid, gid_t *egid, \
@


1.140
log
@Change return value of getentropy() to int 0 for success.  Maximum
buffersize is enforced strictly, this supplies sufficient entropy
payload to act as seed material.  Discourage general use of this
API, but lock down this function name as the go-to for userland
PRNG seeding.  Improve documentation.
ok miod matthew
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.139 2014/06/13 08:26:10 deraadt Exp $
d60 1
a60 1
7	STD		{ int sys_getentropy(void *buf, size_t nbyte); }
@


1.139
log
@Add new getentropy() system call.  Code and pressure from matthew.
I accepted that he's right (again) to seperate this out from heavy
sysctl API and this will simply a variety of things.  Functionname
is not used by anyone in the ports tree, so we guess we can use it.
Shocking that no application has a function called this.
ok matthew & others who pushed him to start this early on
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.138 2014/02/09 10:04:42 guenther Exp $
d60 1
a60 1
7	STD		{ ssize_t sys_getentropy(void *buf, size_t nbyte); }
@


1.138
log
@nanosleep() isn't actually NOLOCK safe yet: tsleep() still requires kernel
lock for PCATCH and ktrace(CSW) handling

ok kettenis@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.137 2013/09/14 01:35:01 guenther Exp $
d60 1
a60 1
7	OBSOL		t32_wait4
@


1.137
log
@Snapshots for all archs have been built, so remove the T32 code
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.136 2013/08/16 08:33:20 guenther Exp $
d203 1
a203 1
91	STD NOLOCK	{ int sys_nanosleep(const struct timespec *rqtp, \
@


1.136
log
@Tweak the getdents() kernel prototype to use "void *"
Provide a declaration for userspace
Fix the kernel's sanity check on the buflen argument

lack of prototype pointed out by sthen@@ and landry@@
ok kettenis@@ otto@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.135 2013/08/14 05:26:14 guenther Exp $
d60 1
a60 2
7	T32		{ pid_t sys_wait4(pid_t pid, int *status, \
			    int options, struct rusage32 *rusage); }
d190 1
a190 3
83	T32		{ int sys_setitimer(int which, \
			    const struct itimerval32 *itv, \
			    struct itimerval32 *oitv); }
d195 1
a195 2
86	T32		{ int sys_getitimer(int which, \
			    struct itimerval32 *itv); }
d206 1
a206 2
93	T32		{ int sys_select(int nd, fd_set *in, fd_set *ou, \
			    fd_set *ex, struct timeval32 *tv); }
d238 2
a239 4
116	T32 NOLOCK	{ int sys_gettimeofday(struct timeval32 *tp, \
			    struct timezone *tzp); }
117	T32		{ int sys_getrusage(int who, \
			    struct rusage32 *rusage); }
d247 1
a247 2
122	T32		{ int sys_settimeofday(const struct timeval32 *tv, \
			    const struct timezone *tzp); }
d266 1
a266 2
138	T32		{ int sys_utimes(const char *path, \
			    const struct timeval32 *tptr); }
d356 1
a356 2
206	T32		{ int sys_futimes(int fd, \
			    const struct timeval32 *tptr); }
d421 3
a423 6
232	T32 NOLOCK	{ int sys_clock_gettime(clockid_t clock_id, \
			    struct timespec32 *tp); }
233	T32		{ int sys_clock_settime(clockid_t clock_id, \
			    const struct timespec32 *tp); }
234	T32 NOLOCK	{ int sys_clock_getres(clockid_t clock_id, \
			    struct timespec32 *tp); }
d432 1
a432 2
240	T32 NOLOCK	{ int sys_nanosleep(const struct timespec32 *rqtp, \
			    struct timespec32 *rmtp); }
d468 1
a468 4
270	T32		{ int sys_kevent(int fd, \
			    const struct kevent32 *changelist, int nchanges, \
			    struct kevent32 *eventlist, int nevents, \
			    const struct timespec32 *timeout); }
d504 3
a506 3
291	T32		{ int sys_stat(const char *path, struct stat32 *ub); }
292	T32		{ int sys_fstat(int fd, struct stat32 *sb); }
293	T32		{ int sys_lstat(const char *path, struct stat32 *ub); }
d529 1
a529 3
300	T32		{ int sys___thrsleep(const volatile void *ident, \
			    clockid_t clock_id, const struct timespec32 *tp, \
			    void *lock, const int *abort); }
d544 1
a544 2
312	T32		{ int sys_getdirentries(int fd, char *buf, \
			    int count, off_t *basep); }
d551 1
a551 2
316	T32		{ int sys_fstatat(int fd, const char *path, \
			    struct stat32 *buf, int flag); }
d570 2
a571 4
326	T32		{ int sys_utimensat(int fd, const char *path, \
			    const struct timespec32 *times, int flag); }
327	T32		{ int sys_futimens(int fd, \
			    const struct timespec32 *times); }
@


1.135
log
@The last user of the old __tfork() was updated to the current one,
so COMPAT_O51 can go.  The complete ABI role means COMPAT_O53 can
be removed as well.

ok jsing@@ tedu@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.134 2013/08/13 05:52:24 guenther Exp $
d220 1
a220 2
99	STD		{ int sys_getdents(int fd, struct dirent *buf, \
			    size_t buflen); }
@


1.134
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.133 2013/06/09 13:10:19 miod Exp $
d558 4
a561 7
306	COMPAT_O53	{ int sys_getfsstat(struct statfs53 *buf, \
			    size_t bufsize, int flags); }
307	COMPAT_O53	{ int sys_statfs(const char *path, \
			    struct statfs53 *buf); }
308	COMPAT_O53	{ int sys_fstatfs(int fd, struct statfs53 *buf); }
309	COMPAT_O53	{ int sys_fhstatfs(const fhandle_t *fhp, \
			    struct statfs53 *buf); }
d596 1
a596 1
328	COMPAT_O51	{ int sys___tfork(struct __tfork51 *param); }
@


1.133
log
@Constify the mib argument of sysctl().
ok matthew@@ millert@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.132 2013/06/01 16:27:37 tedu Exp $
d60 2
a61 2
7	STD		{ pid_t sys_wait4(pid_t pid, int *status, int options, \
			    struct rusage *rusage); }
d66 2
a67 1
11	OBSOL		execv
d77 2
a78 1
19	OBSOL		olseek
d110 1
a110 1
38	OBSOL		stat43
d112 1
a112 1
40	OBSOL		lstat43
d114 2
a115 1
42	OBSOL		opipe
d138 1
a138 1
53	OBSOL		osigaltstack
d159 15
a173 6
67	OBSOL		vread
68	OBSOL		vwrite
69	OBSOL		sbrk
70	OBSOL		sstk
71	OBSOL		ommap
72	OBSOL		vadvise
d179 4
a182 2
76	OBSOL		vhangup
77	OBSOL		vlimit
d191 15
a205 10
83	STD		{ int sys_setitimer(int which, \
			    const struct itimerval *itv, \
			    struct itimerval *oitv); }
84	OBSOL		owait
85	OBSOL		swapon25
86	STD		{ int sys_getitimer(int which, \
			    struct itimerval *itv); }
87	OBSOL		ogethostname
88	OBSOL		osethostname
89	OBSOL		ogetdtablesize
d207 2
a208 1
91	UNIMPL		getdopt
d210 5
a214 3
93	STD		{ int sys_select(int nd, fd_set *in, fd_set *ou, \
			    fd_set *ex, struct timeval *tv); }
94	UNIMPL		setdopt
d220 2
a221 1
99	OBSOL		oaccept
d244 1
a244 1
116	STD NOLOCK	{ int sys_gettimeofday(struct timeval *tp, \
d246 2
a247 1
117	STD		{ int sys_getrusage(int who, struct rusage *rusage); }
d255 1
a255 1
122	STD		{ int sys_settimeofday(const struct timeval *tv, \
d275 2
a276 2
138	STD		{ int sys_utimes(const char *path, \
			    const struct timeval *tptr); }
d366 2
a367 2
206	STD		{ int sys_futimes(int fd, \
			    const struct timeval *tptr); }
d432 6
a437 6
232	STD NOLOCK	{ int sys_clock_gettime(clockid_t clock_id, \
			    struct timespec *tp); }
233	STD		{ int sys_clock_settime(clockid_t clock_id, \
			    const struct timespec *tp); }
234	STD NOLOCK	{ int sys_clock_getres(clockid_t clock_id, \
			    struct timespec *tp); }
d446 2
a447 2
240	STD NOLOCK	{ int sys_nanosleep(const struct timespec *rqtp, \
			    struct timespec *rmtp); }
d483 4
a486 4
270	STD		{ int sys_kevent(int fd, \
			    const struct kevent *changelist, int nchanges, \
			    struct kevent *eventlist, int nevents, \
			    const struct timespec *timeout); }
d522 3
a524 3
291	STD		{ int sys_stat(const char *path, struct stat *ub); }
292	STD		{ int sys_fstat(int fd, struct stat *sb); }
293	STD		{ int sys_lstat(const char *path, struct stat *ub); }
d547 2
a548 2
300	STD		{ int sys___thrsleep(const volatile void *ident, \
			    clockid_t clock_id, const struct timespec *tp, \
d567 1
a567 1
312	STD		{ int sys_getdirentries(int fd, char *buf, \
d575 2
a576 2
316	STD		{ int sys_fstatat(int fd, const char *path, \
			    struct stat *buf, int flag); }
d595 4
a598 4
326	STD		{ int sys_utimensat(int fd, const char *path, \
			    const struct timespec *times, int flag); }
327	STD		{ int sys_futimens(int fd, \
			    const struct timespec *times); }
@


1.132
log
@always implement stub utrace syscall, but keep the body #ifdef KTRACE
ok guenther matthew
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.131 2013/06/01 09:49:50 miod Exp $
d336 1
a336 1
202	STD		{ int sys___sysctl(int *name, u_int namelen, \
@


1.131
log
@Add utrace(2), a system call allowing for userland to send its own ktrace
records. From FreeBSD via otto@@, with tweaks suggested by guenther@@.
Commite on behalf of otto@@ who is not around, to ride the libc minor bump.
Causes a librthread minor bump as well (new syscall).
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.130 2013/04/29 17:06:20 matthew Exp $
a345 1
#ifdef KTRACE
a347 3
#else
209	UNIMPL
#endif
@


1.130
log
@Extend P_SIGSUSPEND handling in userret() to properly restore the
sigmask even if there are no pending signals under the temporary
sigmask.

Refactor existing select() and poll() system calls to introduce the
pselect() and ppoll() system calls.

Add rthread wrappers for pselect() and ppoll().  While there, update
cancellation point comments to reflect recent fdatasync() addition.

Minor bumps for libc and librthread due to new symbols.

ok guenther, millert, deraadt, jmc
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.129 2013/04/15 15:32:19 jsing Exp $
d346 4
d351 1
@


1.129
log
@Add an f_mntfromspec member to struct statfs, which specifies the name of
the special provided when the mount was requested. This may be the same as
the special that was actually used for the mount (e.g. in the case of a
device node) or it may be different (e.g. in the case of a DUID).

Whilst here, change f_ctime to a 64 bit type and remove the pointless
f_spare members.

Compatibility goo courtesy of guenther@@

ok krw@@ millert@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.128 2013/03/14 21:38:22 tedu Exp $
d210 6
a215 2
109	OBSOL		osigblock
110	OBSOL		osigsetmask
@


1.128
log
@the 5.1 era tfork syscall claws its way out of the grave. we failed to
fully deprecate it (notably the go port was still using it as of 5.3)
so to give users a little more time to update, __tfork51 lives again.
okish deraadt guenther
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.126 2012/09/10 02:22:17 deraadt Exp $
d148 7
a154 4
62	OBSOL		fstat43
63	OBSOL		ogetkerninfo
64	OBSOL		ogetpagesize
65	OBSOL		omsync25
d529 7
a535 7
306	STD		{ int sys_getfsstat(struct statfs *buf, size_t bufsize, \
			    int flags); }
307	STD		{ int sys_statfs(const char *path, \
			    struct statfs *buf); }
308	STD		{ int sys_fstatfs(int fd, struct statfs *buf); }
309	STD		{ int sys_fhstatfs(const fhandle_t *fhp, \
			    struct statfs *buf); }
@


1.127
log
@No longer need the 5.1 version of the __tfork syscall

ok deraadt@@
@
text
@d567 1
a567 1
328	OBSOL		otfork51
@


1.126
log
@compat_o48_sys_getdirentries can die; ok guenther
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.125 2012/08/23 06:12:49 deraadt Exp $
d567 1
a567 1
328	COMPAT_O51	{ int sys___tfork(struct __tfork51 *param); }
@


1.125
log
@kill nnpfs dead
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.124 2012/06/21 00:56:59 guenther Exp $
d320 1
a320 2
196	COMPAT_O48	{ int sys_getdirentries(int fd, char *buf, \
			    int count, long *basep); }
@


1.124
log
@__tfork() needs to set the stack address of the new thread in the kernel,
so that it can't get a signal while still running on the parent thread's
stack.  Also, pass in sizeof(struct __tfork) to provide forward compat
when more members are added.  This is an ABI change, so switch syscall
numbers and bump lib majors this time.

ok deraadt@@ matthew@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.123 2012/04/12 12:33:03 deraadt Exp $
a43 1
#include <nnpfs/nnpfs_pioctl.h>
d339 1
a339 3
208	STD		{ int sys_nnpfspioctl(int operation, char *a_pathP, \
			    int a_opcode, struct ViceIoctl *a_paramsP, \
			    int a_followSymlinks); }
@


1.123
log
@remove rfork(); ok guenther miod
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.122 2012/04/12 11:16:24 deraadt Exp $
d63 2
a64 1
8	OBSOL		ocreat
d571 1
a571 1
328	STD		{ int sys___tfork(struct __tfork *param); }
@


1.122
log
@kill lfs system call lines and libc stubs
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.121 2012/04/12 11:07:19 deraadt Exp $
d430 1
a430 1
251	STD		{ int sys_rfork(int flags); }
@


1.121
log
@New system call: getdtablecount(2) returns the number of file
descriptors the process currently has open.
ok guenther miod gilles ...
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.120 2012/01/17 02:34:18 guenther Exp $
d306 4
a309 13
#ifdef LFS
184	STD		{ int lfs_bmapv(fsid_t *fsidp, \
			    struct block_info *blkiov, int blkcnt); }
185	STD		{ int lfs_markv(fsid_t *fsidp, \
			    struct block_info *blkiov, int blkcnt); }
186	STD		{ int lfs_segclean(fsid_t *fsidp, u_long segment); }
187	STD		{ int lfs_segwait(fsid_t *fsidp, struct timeval *tv); }
#else
184	UNIMPL
185	UNIMPL
186	UNIMPL
187	UNIMPL
#endif
@


1.120
log
@Reimplement mutexes, condvars, and rwlocks to eliminate bugs,
particularly the "consume the signal you just sent" hang, and putting
the wait queues in userspace.

Do cancellation handling in pthread_cond_*wait(), pthread_join(),
and sem_wait().

Add __ prefix to thr{sleep,wakeup,exit,sigdivert}() syscalls; add
'abort" argument to thrsleep to close cancellation race; make
thr{sleep,wakeup} return errno values via *retval to avoid touching
userspace errno.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.119 2011/10/15 23:35:29 guenther Exp $
d75 1
a75 1
18	OBSOL		getfsstat25
@


1.119
log
@"TLS-lite": add kernel support for a per-thread userspace pointer,
for pointing to the thread-control-block.  Support for mapping this
to the correct hardware register can be added as it's finished;
start with support for amd64, sparc, and sparc64.  Includes syscalls
for getting and setting it (for a portable __errno implementation) as
well as creating a new thread with an initial value for it.

discussed with miod@@, kettenis@@, deraadt@@; committing to get the syscalls
in with the impending libc bump and do further refinements in tree
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.118 2011/07/18 00:16:54 matthew Exp $
d527 7
a533 5
300	STD		{ int sys_thrsleep(void *ident, clockid_t clock_id, \
			    const struct timespec *tp, void *lock); }
301	STD		{ int sys_thrwakeup(void *ident, int n); }
302	STD		{ void sys_threxit(pid_t *notdead); }
303	STD		{ int sys_thrsigdivert(sigset_t sigmask, \
@


1.118
log
@Add support for UTIME_OMIT and UTIME_NOW to utimensat(2), add the
futimens(2) system call, and refactor futimes(2) to share the same
code.  (As with other openat(2) system call stuff, this is not exposed
to userland yet.)

naddy@@ pointed out rsync expects UTIME_* if openat(2) is available
tweaks and ok guenther@@; tested by naddy@@ in a bulk build
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.117 2011/07/09 05:46:26 matthew Exp $
d577 3
@


1.117
log
@Fix up previous diff: use COMPAT_O48 instead of COMPAT_48, add option
to GENERIC, wrap compat_o48_sys_getdirentries() with an appropriate
#ifdef, and use struct compat_o48_sys_getdirentries_args instead of
struct sys_getdirentries_args.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.116 2011/07/09 05:31:26 matthew Exp $
d575 2
@


1.116
log
@More syscalls.master cleanup:

sys_osigaltstack() is 7 years old and no longer needed; all glory to
the sys_sigaltstack()!

sys_ogetdirentries() is about 9 months old, but still acceptable
within our release cycle; move from STD to COMPAT_48 to make this
clearer for tedu@@ next year.

sys_sbrk() and sys_sstk() are completely obsolete: all they do is
return ENOSYS.

ok guenther@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.115 2011/07/09 00:18:06 deraadt Exp $
d329 1
a329 1
196	COMPAT_48	{ int sys_getdirentries(int fd, char *buf, \
@


1.115
log
@mark an obsolete call with the release we killed it; reminded by tedu
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.114 2011/07/09 00:10:51 deraadt Exp $
d135 1
a135 2
53	STD		{ int sys_osigaltstack(const struct osigaltstack *nss, \
			    struct osigaltstack *oss); }
d155 2
a156 2
69	STD		{ int sys_sbrk(int incr); }
70	STD		{ int sys_sstk(int incr); }
d329 1
a329 1
196	STD		{ int sys_ogetdirentries(int fd, char *buf, \
@


1.114
log
@Remove COMPAT_25.  The one piece moved by COMPAT_LINUX moves there.
ok guenther
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.113 2011/07/08 19:19:20 tedu Exp $
d277 1
a277 1
158	OBSOL		fstatfs
@


1.113
log
@remove all traces of COMPAT_09 and COMPAT_10. ok deraadt
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.112 2011/07/08 05:01:27 matthew Exp $
d75 1
a75 2
18	COMPAT_25	{ int sys_getfsstat(struct statfs *buf, long bufsize, \
			    int flags); } ogetfsstat
d152 1
a152 1
65	COMPAT_25	{ int sys_omsync(caddr_t addr, size_t len); }
d179 1
a179 1
85	COMPAT_25	{ int sys_swapon(const char *name); }
d198 2
a199 2
101	OBSOL	osend
102	OBSOL	orecv
d276 2
a277 4
157	COMPAT_25	{ int sys_statfs(const char *path, \
			    struct ostatfs *buf); } ostatfs
158	COMPAT_25	{ int sys_fstatfs(int fd, struct ostatfs *buf); } \
			    ostatfs
@


1.112
log
@Remove the sys_opipe() kernel entry point.  sys_pipe() is the future.

While here, switch compat_linux to just use sys_pipe() rather than
incorrectly wrapping sys_opipe().

ok tedu@@, miod@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.111 2011/07/07 23:45:00 matthew Exp $
d284 2
a285 4
162	COMPAT_09	{ int sys_getdomainname(char *domainname, int len); } \
			    ogetdomainname
163	COMPAT_09	{ int sys_setdomainname(char *domainname, int len); } \
			    osetdomainname
d291 3
a293 18
#if defined(SYSVSEM) && !defined(__LP64__)
169	COMPAT_10	{ int sys_semsys(int which, int a2, int a3, int a4, \
			    int a5); } osemsys
#else
169	UNIMPL		1.0 semsys
#endif
#if defined(SYSVMSG) && !defined(__LP64__)
170	COMPAT_10	{ int sys_msgsys(int which, int a2, int a3, int a4, \
			    int a5, int a6); } omsgsys
#else
170	UNIMPL		1.0 msgsys
#endif
#if defined(SYSVSHM) && !defined(__LP64__)
171	COMPAT_10	{ int sys_shmsys(int which, int a2, int a3, int a4); } \
			    oshmsys
#else
171	UNIMPL		1.0 shmsys
#endif
@


1.111
log
@Add new syscall entries to support the openat(2) family of functions
added in POSIX Issue 7: openat(), mknodat(), mkfifoat(), linkat(),
symlinkat(), unlinkat(), faccessat(), fstatat(), readlinkat(),
fchmodat(), fchownat(), utimensat(), renameat(), and mkdirat().

This diff mostly just refactors the existing sys_foo() logic into a
common dofooat() function that can then be called by both sys_foo()
and sys_fooat().  Some of the new system calls support new flags to
control their behavior, and proper support for these will be added in
subsequent diffs.

Incorporating suggestions from thib@@, guenther@@, and tedu@@.

ok tedu@@, thib@@, deraadt@@, guenther@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.110 2011/07/07 18:30:50 tedu Exp $
d113 1
a113 1
42	STD		{ int sys_opipe(void); }
@


1.110
log
@getpid is NOLOCK again.  ok deraadt guenther
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.109 2011/07/07 01:19:40 tedu Exp $
d568 28
@


1.109
log
@remove all the old COMPAT_43 syscalls.  The option itself remains for
the other things it enables.  Move a few old wrappers into linux compat
where they are still being used.
ok deraadt guenther
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.108 2011/06/30 13:43:14 tedu Exp $
d78 1
a78 1
20	STD		{ pid_t sys_getpid(void); }
@


1.108
log
@compat_35 has not been enabled for sometime, time to remove it
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.107 2011/06/01 06:20:41 guenther Exp $
d63 1
a63 1
8	COMPAT_43	{ int sys_creat(const char *path, mode_t mode); } ocreat
d77 1
a77 2
19	COMPAT_43	{ long sys_lseek(int fd, long offset, int whence); } \
			    olseek
d109 1
a109 2
38	COMPAT_43	{ int sys_stat(const char *path, struct stat43 *ub); } \
			    stat43
d111 1
a111 2
40	COMPAT_43	{ int sys_lstat(char *path, \
			    struct stat43 *ub); } lstat43
d150 3
a152 4
62	COMPAT_43	{ int sys_fstat(int fd, struct stat43 *sb); } fstat43
63	COMPAT_43	{ int sys_getkerninfo(int op, char *where, int *size, \
			    int arg); } ogetkerninfo
64	COMPAT_43	{ int sys_getpagesize(void); } ogetpagesize
d159 1
a159 2
71	COMPAT_43	{ int sys_mmap(caddr_t addr, size_t len, int prot, \
			    int flags, int fd, long pos); } ommap
d179 1
a179 1
84	COMPAT_43	{ int sys_wait(void); } owait
d183 3
a185 5
87	COMPAT_43	{ int sys_gethostname(char *hostname, u_int len); } \
			    ogethostname
88	COMPAT_43	{ int sys_sethostname(char *hostname, u_int len); } \
			    osethostname
89	COMPAT_43	{ int sys_getdtablesize(void); } ogetdtablesize
d197 1
a197 2
99	COMPAT_43	{ int sys_accept(int s, caddr_t name, \
			    int *anamelen); } oaccept
d199 2
a200 4
101	COMPAT_43	{ int sys_send(int s, caddr_t buf, int len, \
			    int flags); } osend
102	COMPAT_43	{ int sys_recv(int s, caddr_t buf, int len, \
			    int flags); } orecv
d208 3
a210 4
108	COMPAT_43	{ int sys_sigvec(int signum, struct sigvec *nsv, \
			    struct sigvec *osv); } osigvec
109	COMPAT_43	{ int sys_sigblock(int mask); } osigblock
110	COMPAT_43	{ int sys_sigsetmask(int mask); } osigsetmask
d212 3
a214 6
112	COMPAT_43	{ int sys_sigstack(struct sigstack *nss, \
			    struct sigstack *oss); } osigstack
113	COMPAT_43	{ int sys_recvmsg(int s, struct omsghdr *msg, \
			    int flags); } orecvmsg
114	COMPAT_43	{ int sys_sendmsg(int s, caddr_t msg, int flags); } \
			    osendmsg
d230 1
a230 3
125	COMPAT_43	{ int sys_recvfrom(int s, caddr_t buf, size_t len, \
			    int flags, caddr_t from, int *fromlenaddr); } \
			    orecvfrom
d234 2
a235 3
129	COMPAT_43	{ int sys_truncate(const char *path, long length); } \
			    otruncate
130	COMPAT_43	{ int sys_ftruncate(int fd, long length); } oftruncate
d251 6
a256 9
141	COMPAT_43	{ int sys_getpeername(int fdes, caddr_t asa, \
			    socklen_t *alen); } ogetpeername
142	COMPAT_43	{ int32_t sys_gethostid(void); } ogethostid
143	COMPAT_43	{ int sys_sethostid(int32_t hostid); } osethostid
144	COMPAT_43	{ int sys_getrlimit(int which, \
			    struct ogetrlimit *rlp); } ogetrlimit
145	COMPAT_43	{ int sys_setrlimit(int which, \
			    struct ogetrlimit *rlp); } osetrlimit
146	COMPAT_43	{ int sys_killpg(int pgid, int signum); } okillpg
d260 2
a261 3
149	COMPAT_43	{ int sys_quota(void); } oquota
150	COMPAT_43	{ int sys_getsockname(int fdec, caddr_t asa, \
			    int *alen); } ogetsockname
d276 1
a276 2
156	COMPAT_43	{ int sys_getdirentries(int fd, char *buf, \
			    int count, long *basep); } ogetdirentries
@


1.107
log
@Mark some system calls that don't require big lock with NOLOCK

ok matthew@@, deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.106 2011/06/01 06:18:07 guenther Exp $
d362 3
a364 6
188	COMPAT_35	{ int sys_stat(const char *path, struct stat35 *ub); } \
			    stat35
189	COMPAT_35	{ int sys_fstat(int fd, struct stat35 *sb); } \
			    fstat35
190	COMPAT_35	{ int sys_lstat(const char *path, \
			    struct stat35 *ub); } lstat35
a424 3
222	COMPAT_35	{ int sys_semop(int semid, struct sembuf *sops, \
			    u_int nsops); }
223	OBSOL		sys_semconfig
a427 2
222	UNIMPL		semop
223	UNIMPL		semconfig
d429 2
a448 1
231	COMPAT_35	{ int sys_shmget(key_t key, int size, int shmflg); }
a452 1
231	UNIMPL		shmget
d454 1
d489 3
a491 18
#ifdef SYSVSEM
257	COMPAT_35	{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); } semctl35
#else
257	UNIMPL
#endif
#ifdef SYSVSHM
258	COMPAT_35	{ int sys_shmctl(int shmid, int cmd, \
			    struct shmid_ds35 *buf); } shmctl35
#else
258	UNIMPL
#endif
#ifdef SYSVMSG
259	COMPAT_35	{ int sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds35 *buf); } msgctl35
#else
259	UNIMPL
#endif
@


1.106
log
@sys_getpid() isn't really NOLOCK safe, as the compat bits inside it require
the p_pptr member to stay valid

ok dlg@@, matthew@@, deraadt@@, kettenis@@, and others
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.105 2011/04/04 12:44:10 deraadt Exp $
d230 1
a230 1
116	STD		{ int sys_gettimeofday(struct timeval *tp, \
d462 1
a462 1
232	STD		{ int sys_clock_gettime(clockid_t clock_id, \
d466 1
a466 1
234	STD		{ int sys_clock_getres(clockid_t clock_id, \
d476 1
a476 1
240	STD		{ int sys_nanosleep(const struct timespec *rqtp, \
d492 1
a492 1
253	STD		{ int sys_issetugid(void); }
d590 2
a591 2
298	STD		{ int sys_sched_yield(void); }
299	STD		{ pid_t sys_getthrid(void); }
@


1.105
log
@COMPAT_O47 (kernel getpeereid, which was replaced by libc getpeereid)
can go away
ok guenther
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.104 2010/10/28 15:02:41 millert Exp $
d79 1
a79 1
20	STD NOLOCK	{ pid_t sys_getpid(void); }
@


1.104
log
@Change basep parameter of getdirentries() to be off_t *, not long *
so it works correctly with large offsets (and matches other systems).
This requires adding a new getdirentries syscall, with the old one
renamed to ogetdirentries.  All in-tree consumers of getdirentries()
have been updated.  Bump libc and libpthread major numbers.
OK and with deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.103 2010/09/20 07:18:03 deraadt Exp $
d534 1
a534 1
273	COMPAT_O47	{ int sys_getpeereid(int fdes, uid_t *euid, gid_t *egid); }
@


1.103
log
@Move getpeereid(2) into COMPAT_O47.  In 4.8 and onwards it is library
code using socket options.
ok matthew
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.102 2010/07/03 04:44:51 guenther Exp $
d375 1
a375 1
196	STD		{ int sys_getdirentries(int fd, char *buf, \
d610 2
@


1.102
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.101 2010/07/01 23:10:40 tedu Exp $
d534 1
a534 1
273	STD		{ int sys_getpeereid(int fdes, uid_t *euid, gid_t *egid); }
@


1.101
log
@3.5 compat is old, but relied upon by other compats still in tree.  the
fhstat syscall, however, isn't needed and can go away.  ok deraadt
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.100 2010/07/01 01:54:38 deraadt Exp $
d608 2
a609 2
310	STD		{ int sys_setrdomain(int rdomain); }
311	STD		{ int sys_getrdomain(void); }
@


1.100
log
@compat_o43 and compat_23 can die
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.99 2010/06/29 00:28:14 tedu Exp $
d519 1
a519 2
265	COMPAT_35	{ int sys_fhstat(const fhandle_t *fhp, \
			    struct stat35 *sb); }
@


1.99
log
@Eliminate RTHREADS kernel option in favor of a sysctl.  The actual status
(not done) hasn't changed, but now it's less work to test things.
ok art deraadt
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.98 2010/01/18 19:09:39 schwarze Exp $
d426 1
a426 2
220	COMPAT_23	{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); } semctl23
d438 1
a438 2
224	COMPAT_23	{ int sys_msgctl(int msqid, int cmd, \
			    struct omsqid_ds *buf); } msgctl23
d453 1
a453 2
229	COMPAT_23	{ int sys_shmctl(int shmid, int cmd, \
			    struct oshmid_ds *buf); } shmctl23
d514 3
a516 5
260	COMPAT_O43	{ int sys_getfsstat(struct o43statfs *buf, size_t bufsize, \
			    int flags); }
261	COMPAT_O43	{ int sys_statfs(const char *path, \
			    struct o43statfs *buf); }
262	COMPAT_O43	{ int sys_fstatfs(int fd, struct o43statfs *buf); }
d521 1
a521 2
266	COMPAT_O43	{ int sys_fhstatfs(const fhandle_t *fhp, \
			    struct o43statfs *buf); }
@


1.98
log
@fix a spelling error in a comment, no code change; from Brad Tilley
ok miod@@ art@@
@
text
@d1 1
a1 1
;	$OpenBSD$
a597 1
#ifdef RTHREADS
a604 7
#else
299	UNIMPL
300	UNIMPL
301	UNIMPL
302	UNIMPL
303	UNIMPL
#endif
@


1.97
log
@Add setrdomain() and getrdomain() system calls.  Committing now to
catch the libc major bump per request from deraadt@@

Diff by reyk.

ok guenther@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.96 2009/11/27 19:45:53 guenther Exp $
d285 1
a285 1
; system calls.  (This includes various calls added for compatibity
@


1.96
log
@Convert thrsleep() to an absolute timeout with clockid to eliminate a
race condition and prep for later support of pthread_condattr_setclock()

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.95 2009/11/27 19:43:55 guenther Exp $
d623 2
@


1.95
log
@Convert thrsigdivert to (almost) be sigtimedwait by adding siginfo_t
and struct timespec * argument.  sigtimedwait is just a one line
wrapper after this.

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.94 2009/11/27 19:42:24 guenther Exp $
d600 2
a601 1
300	STD		{ int sys_thrsleep(void *ident, int timeout, void *lock); }
@


1.94
log
@Change threxit() to take a pointer to a pid_t to zero out from the
kernel so that librthread can detect when a thread is completely
done with its stack without need a kqueue.  The dying thread moves
itself to a GC list, other threads scan the GC list on pthread_create()
and pthread_join() and free the stack and handle once the thread's
thread id is zeroed.

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.93 2009/06/03 15:42:03 jj Exp $
d603 2
a604 1
303	STD		{ int sys_thrsigdivert(sigset_t sigmask); }
@


1.93
log
@remove bad #ifdef from syscall.master
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.92 2009/06/03 14:45:54 jj Exp $
d602 1
a602 1
302	STD		{ void sys_threxit(int rval); }
@


1.92
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.91 2009/03/12 06:56:13 guenther Exp $
a393 1
#ifdef NNPFS
a396 3
#else
208	UNIMPL
#endif
@


1.91
log
@threxit() can't return, so its return type is really void

"probably does not need a crank, so perhaps just go for it" deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.90 2008/03/16 19:42:57 otto Exp $
d44 1
a44 1
#include <xfs/xfs_pioctl.h>
d394 2
a395 1
208	STD		{ int sys_xfspioctl(int operation, char *a_pathP, \
d398 3
@


1.90
log
@Widen some struct statfs fields to support large filesystem stata
and add some to be able to support statvfs(2). Do the compat dance
to provide backward compatibility.  ok thib@@ miod@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.89 2008/01/05 00:36:13 miod Exp $
d602 1
a602 1
302	STD		{ int sys_threxit(int rval); }
@


1.89
log
@Mark vadvise(2) as obsolete and remove its implementation, so instead of
returning EINVAL, you'll get ENOSYS. No serious code has used this system
call in at least fifteen years.

The libc stub will be removed at the next major crank time.

ok henning@@ deraadt@@ krw@@ toby@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.88 2007/11/28 13:47:02 deraadt Exp $
d517 1
a517 1
260	STD		{ int sys_getfsstat(struct statfs *buf, size_t bufsize, \
d519 3
a521 3
261	STD		{ int sys_statfs(const char *path, \
			    struct statfs *buf); }
262	STD		{ int sys_fstatfs(int fd, struct statfs *buf); }
d526 2
a527 2
266	STD		{ int sys_fhstatfs(const fhandle_t *fhp, \
			    struct statfs *buf); }
d614 7
@


1.88
log
@COMPAT_09 uname is only used by freebsd compat, so move it to the right place
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.87 2007/11/27 18:04:47 art Exp $
d165 1
a165 1
72	STD		{ int sys_ovadvise(int anom); } vadvise
@


1.87
log
@Mark getpid as NOLOCK just for testing.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.86 2006/09/22 17:35:41 pedro Exp $
d310 1
a310 1
164	COMPAT_09	{ int sys_uname(struct outsname *name); } ouname
@


1.86
log
@Put the LFS syscall stubs back in, turns out libc is unable to build
without those, even though they're currently not implemented
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.84 2006/06/14 19:52:07 otto Exp $
d79 1
a79 1
20	STD		{ pid_t sys_getpid(void); }
@


1.85
log
@Remove LFS system calls
@
text
@d349 8
d361 1
@


1.84
log
@Introducing adjfreq(2), to adjust the clock frequency.
Loosely based on dragonfly code. ok deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.83 2006/06/09 00:05:54 deraadt Exp $
a348 8
#ifdef LFS
184	STD		{ int lfs_bmapv(fsid_t *fsidp, \
			    struct block_info *blkiov, int blkcnt); }
185	STD		{ int lfs_markv(fsid_t *fsidp, \
			    struct block_info *blkiov, int blkcnt); }
186	STD		{ int lfs_segclean(fsid_t *fsidp, u_long segment); }
187	STD		{ int lfs_segwait(fsid_t *fsidp, struct timeval *tv); }
#else
a352 1
#endif
@


1.83
log
@spacing that made a grep look very suspicious
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.82 2006/04/28 08:34:31 pedro Exp $
d612 2
@


1.82
log
@Instrumentation for an in-kernel getcwd() implementation.
Not yet activated. Diff by marius@@ long ago, from NetBSD.
Okay miod@@ and krw@@.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.81 2005/12/30 04:02:17 tedu Exp $
d533 1
a533 1
			  int pad, off_t offset); }                    
d560 1
a560 1
287	STD		{ int sys_closefrom(int fd); }			    
d572 1
a572 1
290    UNIMPL          semop
@


1.81
log
@change thrwakeup to take an argument which specifies how many threads
to wakeup.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.80 2005/12/13 06:02:03 tedu Exp $
d611 1
@


1.80
log
@change the first arg to thrsleep and thrwakeup to a void *.
i had initially selected long since the kernel doesn't attempt
to interpret this value in any way, but since it is always a
pointer value in practice, this makes a little more sense.
binary compat in any case.  suggestion from deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.79 2005/12/03 18:09:08 tedu Exp $
d601 1
a601 1
301	STD		{ int sys_thrwakeup(void *ident); }
@


1.79
log
@kernel support for threaded processes (rthreads).
uses rfork(RFTHREAD) to create threads, which are presently processes
that are a little more tightly bound together.  several new syscalls
added to facilitate a userland thread library.
all conditional on RTHREADS, currently disabled.
ok deraadt
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.78 2005/07/03 20:13:59 drahn Exp $
d600 2
a601 2
300	STD		{ int sys_thrsleep(long ident, int timeout, void *lock); }
301	STD		{ int sys_thrwakeup(long ident); }
@


1.78
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.77 2005/06/17 20:39:14 millert Exp $
d596 14
@


1.77
log
@remove undelete syscall
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.76 2004/07/15 14:35:34 deraadt Exp $
a541 21
#ifdef UFS_EXTATTR
274	STD		{ int sys_extattrctl(const char *path, int cmd, \
			    const char *filename, int attrnamespace, \
			    const char *attrname); }
275	STD		{ int sys_extattr_set_file(const char *path, \
			    int attrnamespace, const char *attrname, \
			    const void *data, size_t nbytes); }
276	STD		{ ssize_t sys_extattr_get_file(const char *path, \
			    int attrnamespace, const char *attrname, \
			    void *data, size_t nbytes); }
277	STD		{ int sys_extattr_delete_file(const char *path, \
			    int attrnamespace, const char *attrname); }
278	STD		{ int sys_extattr_set_fd(int fd, int attrnamespace, \
			    const char *attrname, const void *data, \
			    size_t nbytes); }
279	STD		{ ssize_t sys_extattr_get_fd(int fd, \
			    int attrnamespace, const char *attrname, \
			    void *data, size_t nbytes); }
280	STD		{ int sys_extattr_delete_fd(int fd, int attrnamespace, \
			    const char *attrname); }
#else
a548 1
#endif
@


1.76
log
@3 functions had inexact types; millert ok
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.75 2004/07/15 11:24:46 millert Exp $
d390 1
a390 1
205	STD		{ int sys_undelete(const char *path); }
@


1.75
log
@Rename structs oipc_perm, omsqid_ds, osemid_ds, oshmid_ds to ipc_perm23,
etc to avoid confusion and for consistency with the *35 ones.
Remove *n2o functions that don't belong outside of compat.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.74 2004/07/14 23:45:11 millert Exp $
d102 1
a102 1
			    int *alen); }
d548 1
a548 1
			    void *data, size_t nbytes); }
d555 1
a555 1
			    const char *attrname, void *data, \
@


1.74
log
@Because mode_t is used in struct ipc_perm we need new versions of
the msgctl, semctl, and shmctl system calls.  This moves the old
versions to COMPAT_35 and adds new ones.

WARNING: While this fixes things like shared memory in the X server
for old (pre-mode_t change) binaries, it will break binaries that
use shared memory built between the time of the mode_t change (Jul
13th) and now.  If you rebuild X during that interval you will need
to do it again after updating the rest of userland.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.73 2004/07/14 18:00:48 millert Exp $
d427 1
a427 1
			    union semun *arg); } __osemctl
d440 1
a440 1
			    struct omsqid_ds *buf); } omsgctl
d456 1
a456 1
			    struct oshmid_ds *buf); } oshmctl
@


1.73
log
@fhstat(2) uses struct stat too and so needs replacing as well.
OK miod@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.72 2004/07/13 21:04:29 millert Exp $
d500 2
a501 2
257	STD		{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); }
d506 2
a507 2
258	STD		{ int sys_shmctl(int shmid, int cmd, \
			    struct shmid_ds *buf); }
d512 2
a513 2
259	STD		{ int sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds *buf); }
d601 18
@


1.72
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.71 2004/07/09 23:52:02 millert Exp $
d524 2
a525 2
265	STD		{ int sys_fhstat(const fhandle_t *fhp, \
			    struct stat *sb); }
d599 2
@


1.71
log
@Rename ostat -> stat43 to disambiguate from upcoming struct stat changes.
Idea from NetBSD, OK deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.70 2004/05/27 20:48:46 tedu Exp $
d59 1
a59 1
			    int flags, ... int mode); }
d63 1
a63 1
8	COMPAT_43	{ int sys_creat(const char *path, int mode); } ocreat
d69 1
a69 1
14	STD		{ int sys_mknod(const char *path, int mode, \
d71 1
a71 1
15	STD		{ int sys_chmod(const char *path, int mode); }
d151 1
a151 1
60	STD		{ int sys_umask(int newmask); }
d243 1
a243 1
124	STD		{ int sys_fchmod(int fd, int mode); }
d254 1
a254 1
132	STD		{ int sys_mkfifo(const char *path, int mode); }
d261 1
a261 1
136	STD		{ int sys_mkdir(const char *path, int mode); }
d362 6
a367 3
188	STD		{ int sys_stat(const char *path, struct stat *ub); }
189	STD		{ int sys_fstat(int fd, struct stat *sb); }
190	STD		{ int sys_lstat(const char *path, struct stat *ub); }
d596 3
@


1.70
log
@make acct(2) optional with ACCOUNTING
ok art@@ deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.69 2004/05/03 17:38:48 millert Exp $
d110 2
a111 2
38	COMPAT_43	{ int sys_stat(const char *path, struct ostat *ub); } \
			    ostat
d114 1
a114 1
			    struct ostat *ub); } olstat
d153 1
a153 1
62	COMPAT_43	{ int sys_fstat(int fd, struct ostat *sb); } ofstat
@


1.69
log
@POSIX says the length parameter for semop(2) and shmget(2) should be size_t.
Create new syscalls with the correct parameters and add compat versions
for the old ones under COMPAT_35.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.68 2004/02/28 19:44:16 miod Exp $
d133 1
d135 3
@


1.68
log
@Rather than adding amd64 to the 64-bit platform which do not require the
old COMPAT_10 SysV syscalls, check for __LP64__ instead.

ok deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.67 2004/01/14 05:23:25 tedu Exp $
d422 1
a422 1
222	STD		{ int sys_semop(int semid, struct sembuf *sops, \
d451 1
a451 1
231	STD		{ int sys_shmget(key_t key, int size, int shmflg); }
d578 11
@


1.67
log
@change sigaltstack.ss_size type to size_t.  handle syscall fallout.
add stack_t and ucontext_t typedefs.
ok deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.66 2004/01/12 18:06:51 tedu Exp $
d311 1
a311 2
; XXX more generally, never on machines where sizeof(void *) != sizeof(int)
#if defined(SYSVSEM) && !defined(alpha) && !defined(__sparc64__)
d317 1
a317 2
; XXX more generally, never on machines where sizeof(void *) != sizeof(int)
#if defined(SYSVMSG) && !defined(alpha) && !defined(__sparc64__)
d323 1
a323 2
; XXX more generally, never on machines where sizeof(void *) != sizeof(int)
#if defined(SYSVSHM) && !defined(alpha) && !defined(__sparc64__)
@


1.66
log
@new syscall closefrom(int fd) closes all fds equal and greater than fd.
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.65 2003/12/31 00:13:24 millert Exp $
d135 2
a136 2
53	STD		{ int sys_sigaltstack(const struct sigaltstack *nss, \
			    struct sigaltstack *oss); }
d579 2
@


1.65
log
@wait4(2) takes and returns pid_t, not int.  OK deraadt@@ and miod@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.64 2003/12/11 23:02:30 millert Exp $
d578 1
@


1.64
log
@Add id_t type as per POSIX and use it for [gs]etpriority(2).
OK henning@@ and deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.63 2003/12/10 23:10:08 millert Exp $
d61 1
a61 1
7	STD		{ int sys_wait4(int pid, int *status, int options, \
@


1.63
log
@Add an nfds_t type as per POSIX and also add pollfd_t like Solaris has.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.62 2003/09/07 21:00:27 miod Exp $
d196 1
a196 1
96	STD		{ int sys_setpriority(int which, int who, int prio); }
d202 1
a202 1
100	STD		{ int sys_getpriority(int which, int who); }
@


1.62
log
@No COMPAT_10 SYSVSHM syscalls on sparc64; ok deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.61 2003/07/01 22:18:09 tedu Exp $
d490 1
a490 1
			    int nfds, int timeout); }
@


1.61
log
@remove sys_omquery.  it was only used for two weeks, and you can't
source upgrade from a system that used it anyway.
ok art deraadt drahn
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.60 2003/06/23 04:26:53 deraadt Exp $
d312 1
a312 1
#if defined(SYSVSEM) && !defined(alpha)
d319 1
a319 1
#if defined(SYSVMSG) && !defined(alpha)
d326 1
a326 1
#if defined(SYSVSHM) && !defined(alpha)
@


1.60
log
@fix nfds type; tedu marc ok
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.59 2003/06/22 21:34:16 deraadt Exp $
d575 1
a575 2
285	STD		{ int sys_omquery(int flags, void **addr, \
			    size_t size, int fd, off_t off); }
@


1.59
log
@extra headers
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.58 2003/05/10 17:53:58 miod Exp $
d490 1
a490 1
			    unsigned long nfds, int timeout); }
@


1.58
log
@Deprecate the swapon system call and move it to COMPAT_25 land, since swapctl
has been introduced for this release.

ok deraadt@@ weingart@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.57 2003/04/29 19:52:32 miod Exp $
d43 2
@


1.57
log
@Deprecate omsync syscall, and only enable it if COMPAT_25 is required.
ok deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.56 2003/04/28 21:32:08 drahn Exp $
d179 1
a179 1
85	STD		{ int sys_swapon(const char *name); }
@


1.56
log
@Change mquery() function call signature to be the same a mmap(). It
needs the prot/flags info and passing the addresses via arg/return allows
it to be traced via ktrace better than an in/out paramter.
This adds a new mquery syscall and renames the old one to omquery.
New kernel _MUST_ be built, booted, and 'make includes' before building
ld.so with this change.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.55 2003/04/25 20:32:07 drahn Exp $
d151 1
a151 1
65	STD		{ int sys_omsync(caddr_t addr, size_t len); }
@


1.55
log
@backout mquery change, something broke when not combined with a different diff.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.53 2003/04/14 04:53:50 art Exp $
d573 4
a576 2
285	STD		{ int sys_mquery(int flags, void **addr, size_t size, \
			    int fd, off_t off); }
@


1.54
log
@change mquery() function call signature to be the same a mmap(). It
needs the prot/flags info and passing the addresses via arg/return allows
it to be traced via ktrace better than an in/out paramter.
This adds a new mquery syscall and renames the old one to omquery.
New kernel _MUST_ be built and installed before building ld.so with this change.
ok millert@@ tedu@@
@
text
@d573 2
a574 4
285	STD		{ int sys_omquery(int flags, void **addr, \
			    size_t size, int fd, off_t off); }
286	STD		{ void *sys_mquery(void *addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }
@


1.53
log
@There are two related changes.

The first one is an mquery(2) syscall. It's for asking the VM system
about where to map things. It will be used by ld.so, read the man page
for details.

The second change is related and is a centralization of uvm_map hint
that all callers of uvm_map calculated. This will allow us to adjust
this hint on architectures that have segments for non-exec mappings.

deraadt@@ drahn@@ ok.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.52 2003/01/30 03:29:49 millert Exp $
d573 4
a576 2
285	STD		{ int sys_mquery(int flags, void **addr, size_t size, \
			    int fd, off_t off); }
@


1.52
log
@Bring back setreuid(2) and setregid(2) as first class syscalls
(but still implemented via setres[ug]id(2)).  Basically this just
moves them from COMPAT_43 into kern_prot.c.  Also fixes a typo in my
old implementation.  The userland portion will follow in a few days.
deraadt@@ OK
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.51 2002/10/30 20:02:58 millert Exp $
d573 2
@


1.51
log
@Implement setresuid(2), getresuid(2), setresgid(2), getresgid(2), based
partly on the Linux emul code and FreeBSD versions.
We need these for Linux, FreeBSD, and HP-UX emulation.
Also change sys_setreuid() and sys_setregid() to use uid_t and gid_t
respectively.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.50 2002/07/06 19:14:20 nordin Exp $
d241 2
a242 2
126	COMPAT_43	{ int sys_setreuid(uid_t ruid, uid_t euid); } osetreuid
127	COMPAT_43	{ int sys_setregid(gid_t rgid, gid_t egid); } osetregid
@


1.50
log
@Remove kernel support for NTP. ok deraadt@@ and tholo@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.49 2002/03/14 00:42:25 miod Exp $
d241 2
a242 2
126	COMPAT_43	{ int sys_setreuid(int ruid, int euid); } osetreuid
127	COMPAT_43	{ int sys_setregid(int rgid, int egid); } osetregid
d565 8
@


1.49
log
@Turn the ptrace(2) syscall into a kernel compile option, option PTRACE in
your kernel configuration file.
By default, GENERIC will enable this.

When PTRACE is not enabled, several ptrace-like features of the procfs
filesystem will be disabled as well (namely, the ability to read and write
any process' registers, as well as attching, single stepping and detaching
to/from processes).

This should help paranoid people build better sandboxens, and us to build
smaller ramdisks.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.48 2002/02/22 20:37:45 drahn Exp $
a334 4
#ifdef NTP
175	STD		{ int sys_ntp_gettime(struct ntptimeval *ntvp); }
176	STD		{ int sys_ntp_adjtime(struct timex *tp); }
#else
a336 1
#endif
@


1.48
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.47 2001/06/26 19:56:52 dugsong Exp $
d84 1
d87 3
@


1.47
log
@implement djb's getpeereid(2), to allow local-domain servers to determine client credentials. mostly from superscript.com. deraadt@@ ok
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.46 2001/06/16 22:16:23 deraadt Exp $
d537 29
a565 1

@


1.47.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.47 2001/06/26 19:56:52 dugsong Exp $
a83 1
#ifdef PTRACE
a85 3
#else
26	UNIMPL		ptrace
#endif
d537 1
a537 29
#ifdef UFS_EXTATTR
274	STD		{ int sys_extattrctl(const char *path, int cmd, \
			    const char *filename, int attrnamespace, \
			    const char *attrname); }
275	STD		{ int sys_extattr_set_file(const char *path, \
			    int attrnamespace, const char *attrname, \
			    void *data, size_t nbytes); }
276	STD		{ ssize_t sys_extattr_get_file(const char *path, \
			    int attrnamespace, const char *attrname, \
			    void *data, size_t nbytes); }
277	STD		{ int sys_extattr_delete_file(const char *path, \
			    int attrnamespace, const char *attrname); }
278	STD		{ int sys_extattr_set_fd(int fd, int attrnamespace, \
			    const char *attrname, void *data, \
			    size_t nbytes); }
279	STD		{ ssize_t sys_extattr_get_fd(int fd, \
			    int attrnamespace, const char *attrname, \
			    void *data, size_t nbytes); }
280	STD		{ int sys_extattr_delete_fd(int fd, int attrnamespace, \
			    const char *attrname); }
#else
274	UNIMPL		sys_extattrctl
275	UNIMPL		sys_extattr_set_file
276	UNIMPL		sys_extattr_get_file
277	UNIMPL		sys_extattr_delete_file
278	UNIMPL		sys_extattr_set_fd
279	UNIMPL		sys_extattr_get_fd
280	UNIMPL		sys_extattr_delete_fd
#endif
@


1.47.4.2
log
@sync to -current
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.47.4.1 2002/06/11 03:29:40 art Exp $
d335 4
d341 1
@


1.47.4.3
log
@sync
@
text
@d1 1
a1 1
;	$OpenBSD$
d151 1
a151 1
65	COMPAT_25	{ int sys_omsync(caddr_t addr, size_t len); }
d179 1
a179 1
85	COMPAT_25	{ int sys_swapon(const char *name); }
d241 2
a242 2
126	STD		{ int sys_setreuid(uid_t ruid, uid_t euid); }
127	STD		{ int sys_setregid(gid_t rgid, gid_t egid); }
a564 12
281	STD		{ int sys_getresuid(uid_t *ruid, uid_t *euid, \
			    uid_t *suid); }
282	STD		{ int sys_setresuid(uid_t ruid, uid_t euid, \
			    uid_t suid); }
283	STD		{ int sys_getresgid(gid_t *rgid, gid_t *egid, \
			    gid_t *sgid); }
284	STD		{ int sys_setresgid(gid_t rgid, gid_t egid, \
			    gid_t sgid); }
285	STD		{ int sys_omquery(int flags, void **addr, \
			    size_t size, int fd, off_t off); }
286	STD		{ void *sys_mquery(void *addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }
@


1.46
log
@sysarch() takes a void *
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.45 2001/05/16 17:14:35 millert Exp $
d536 1
@


1.45
log
@Create COMPAT_25 and move ogetfsstat, ostatfs and ostatfs into it.
Create COMPAT_23 and move __osemctl, omsgctl, oshmctl there.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.44 2001/03/09 15:11:47 art Exp $
d301 1
a301 1
165	STD		{ int sys_sysarch(int op, char *parms); }
@


1.44
log
@Add mlockall and munlockall (dummy for the old vm system).
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.43 2000/11/16 20:02:17 provos Exp $
d73 2
a74 2
18	STD		{ int sys_ogetfsstat(struct statfs *buf, long bufsize, \
			    int flags); }
d289 4
a292 3
157	STD		{ int sys_ostatfs(const char *path, \
			    struct ostatfs *buf); }
158	STD		{ int sys_ofstatfs(int fd, struct ostatfs *buf); }
d421 2
a422 2
220	STD		{ int sys___osemctl(int semid, int semnum, int cmd, \
			    union semun *arg); }
d434 2
a435 2
224	STD		{ int sys_omsgctl(int msqid, int cmd, \
			    struct omsqid_ds *buf); }
d450 2
a451 2
229	STD		{ int sys_oshmctl(int shmid, int cmd, \
			    struct oshmid_ds *buf); }
@


1.43
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.42 2000/09/12 17:25:56 millert Exp $
d533 3
@


1.42
log
@sys_getsid() and sys_getpgid() return pid_t, not int (though pid_t *is*
an int so this didn't break anything).
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.41 2000/06/22 22:41:19 mickey Exp $
d528 5
@


1.41
log
@make vtrace always obsolte; art@@
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.40 2000/05/01 23:10:58 deraadt Exp $
d387 1
a387 1
207	STD		{ int sys_getpgid(pid_t pid); }
d491 1
a491 1
255	STD		{ int sys_getsid(pid_t pid); }
@


1.40
log
@sys_semconfig goes away
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.39 2000/04/20 06:32:23 deraadt Exp $
a218 3
#ifdef TRACE
115	STD		{ int sys_vtrace(int request, int value); }
#else
a219 1
#endif
@


1.39
log
@system call hookup for p{read,write}{,v}
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.38 2000/02/07 04:49:27 assar Exp $
d429 1
a429 1
223	STD		{ int sys_semconfig(int flag); }
@


1.38
log
@always include sys_getfh.  add fhopen, fhstat, and fhstatfs
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.37 1999/06/07 07:17:42 deraadt Exp $
d330 4
a333 2
173	UNIMPL
174	UNIMPL
d526 6
@


1.38.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.44 2001/03/09 15:11:47 art Exp $
d219 3
d223 1
d330 2
a331 4
173	STD		{ ssize_t sys_pread(int fd, void *buf, \
			  size_t nbyte, int pad, off_t offset); }
174	STD		{ ssize_t sys_pwrite(int fd, const void *buf, \
			  size_t nbyte, int pad, off_t offset); }
d389 1
a389 1
207	STD		{ pid_t sys_getpgid(pid_t pid); }
d427 1
a427 1
223	OBSOL		sys_semconfig
d493 1
a493 1
255	STD		{ pid_t sys_getsid(pid_t pid); }
a523 14
267	STD		{ ssize_t sys_preadv(int fd, \
			  const struct iovec *iovp, int iovcnt, \
			  int pad, off_t offset); }
268	STD		{ ssize_t sys_pwritev(int fd, \
			  const struct iovec *iovp, int iovcnt, \
			  int pad, off_t offset); }                    
269	STD		{ int sys_kqueue(void); }
270	STD		{ int sys_kevent(int fd, \
			    const struct kevent *changelist, int nchanges, \
			    struct kevent *eventlist, int nevents, \
			    const struct timespec *timeout); }
271	STD		{ int sys_mlockall(int flags); }
272	STD		{ int sys_munlockall(void); }

@


1.38.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.38.2.1 2001/05/14 22:32:44 niklas Exp $
d73 2
a74 2
18	COMPAT_25	{ int sys_getfsstat(struct statfs *buf, long bufsize, \
			    int flags); } ogetfsstat
d289 3
a291 4
157	COMPAT_25	{ int sys_statfs(const char *path, \
			    struct ostatfs *buf); } ostatfs
158	COMPAT_25	{ int sys_fstatfs(int fd, struct ostatfs *buf); } \
			    ostatfs
d300 1
a300 1
165	STD		{ int sys_sysarch(int op, void *parms); }
d420 2
a421 2
220	COMPAT_23	{ int sys___semctl(int semid, int semnum, int cmd, \
			    union semun *arg); } __osemctl
d433 2
a434 2
224	COMPAT_23	{ int sys_msgctl(int msqid, int cmd, \
			    struct omsqid_ds *buf); } omsgctl
d449 2
a450 2
229	COMPAT_23	{ int sys_shmctl(int shmid, int cmd, \
			    struct oshmid_ds *buf); } oshmctl
a534 1
273	STD		{ int sys_getpeereid(int fdes, uid_t *euid, gid_t *egid); }
@


1.38.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
;	$OpenBSD$
d537 1
a537 29
#ifdef UFS_EXTATTR
274	STD		{ int sys_extattrctl(const char *path, int cmd, \
			    const char *filename, int attrnamespace, \
			    const char *attrname); }
275	STD		{ int sys_extattr_set_file(const char *path, \
			    int attrnamespace, const char *attrname, \
			    void *data, size_t nbytes); }
276	STD		{ ssize_t sys_extattr_get_file(const char *path, \
			    int attrnamespace, const char *attrname, \
			    void *data, size_t nbytes); }
277	STD		{ int sys_extattr_delete_file(const char *path, \
			    int attrnamespace, const char *attrname); }
278	STD		{ int sys_extattr_set_fd(int fd, int attrnamespace, \
			    const char *attrname, void *data, \
			    size_t nbytes); }
279	STD		{ ssize_t sys_extattr_get_fd(int fd, \
			    int attrnamespace, const char *attrname, \
			    void *data, size_t nbytes); }
280	STD		{ int sys_extattr_delete_fd(int fd, int attrnamespace, \
			    const char *attrname); }
#else
274	UNIMPL		sys_extattrctl
275	UNIMPL		sys_extattr_set_file
276	UNIMPL		sys_extattr_get_file
277	UNIMPL		sys_extattr_delete_file
278	UNIMPL		sys_extattr_set_fd
279	UNIMPL		sys_extattr_get_fd
280	UNIMPL		sys_extattr_delete_fd
#endif
@


1.38.2.4
log
@Merge in -current from about a week ago
@
text
@a83 1
#ifdef PTRACE
a85 3
#else
26	UNIMPL		ptrace
#endif
@


1.38.2.5
log
@Sync the SMP branch with 3.3
@
text
@d241 2
a242 2
126	STD		{ int sys_setreuid(uid_t ruid, uid_t euid); }
127	STD		{ int sys_setregid(gid_t rgid, gid_t egid); }
d335 4
d341 1
a569 8
281	STD		{ int sys_getresuid(uid_t *ruid, uid_t *euid, \
			    uid_t *suid); }
282	STD		{ int sys_setresuid(uid_t ruid, uid_t euid, \
			    uid_t suid); }
283	STD		{ int sys_getresgid(gid_t *rgid, gid_t *egid, \
			    gid_t *sgid); }
284	STD		{ int sys_setresgid(gid_t rgid, gid_t egid, \
			    gid_t sgid); }
@


1.38.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.38.2.5 2003/03/28 00:41:27 niklas Exp $
d151 1
a151 1
65	COMPAT_25	{ int sys_omsync(caddr_t addr, size_t len); }
d179 1
a179 1
85	COMPAT_25	{ int sys_swapon(const char *name); }
a572 4
285	STD		{ int sys_omquery(int flags, void **addr, \
			    size_t size, int fd, off_t off); }
286	STD		{ void *sys_mquery(void *addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }
@


1.38.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
;	$OpenBSD$
a42 2
#include <sys/event.h>
#include <xfs/xfs_pioctl.h>
d59 1
a59 1
7	STD		{ pid_t sys_wait4(pid_t pid, int *status, int options, \
d133 2
a134 2
53	STD		{ int sys_osigaltstack(const struct osigaltstack *nss, \
			    struct osigaltstack *oss); }
d194 1
a194 1
96	STD		{ int sys_setpriority(int which, id_t who, int prio); }
d200 1
a200 1
100	STD		{ int sys_getpriority(int which, id_t who); }
d310 1
a310 1
#if defined(SYSVSEM) && !defined(alpha) && !defined(__sparc64__)
d317 1
a317 1
#if defined(SYSVMSG) && !defined(alpha) && !defined(__sparc64__)
d324 1
a324 1
#if defined(SYSVSHM) && !defined(alpha) && !defined(__sparc64__)
d488 1
a488 1
			    u_int nfds, int timeout); }
d573 2
a574 1
285	OBSOL		sys_omquery
a576 3
287	STD		{ int sys_closefrom(int fd); }			    
288	STD		{ int sys_sigaltstack(const struct sigaltstack *nss, \
			    struct sigaltstack *oss); }
@


1.38.2.8
log
@Merge with the trunk
@
text
@a132 1
#ifdef ACCOUNTING
a133 3
#else
51	UNIMPL		acct
#endif
d311 2
a312 1
#if defined(SYSVSEM) && !defined(__LP64__)
d318 2
a319 1
#if defined(SYSVMSG) && !defined(__LP64__)
d325 2
a326 1
#if defined(SYSVSHM) && !defined(__LP64__)
d425 1
a425 1
222	COMPAT_35	{ int sys_semop(int semid, struct sembuf *sops, \
d454 1
a454 1
231	COMPAT_35	{ int sys_shmget(key_t key, int size, int shmflg); }
a580 11
#ifdef SYSVSHM
289	STD		{ int sys_shmget(key_t key, size_t size, int shmflg); }
#else
289	UNIMPL		shmget
#endif
#ifdef SYSVSEM
290	STD		{ int sys_semop(int semid, struct sembuf *sops, \
			    size_t nsops); }
#else
290    UNIMPL          semop
#endif
@


1.37
log
@replacement pipe() system call; copies data into place inside kernel, so
that EFAULT return value is possible
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.36 1999/05/31 17:34:47 millert Exp $
a297 1
#if defined(NFSCLIENT) || defined(NFSSERVER)
a298 3
#else
161	UNIMPL		getfh
#endif
d519 5
@


1.36
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.35 1999/05/22 21:23:40 weingart Exp $
d110 1
a110 1
42	STD		{ int sys_pipe(void); }
d522 1
@


1.35
log
@Add swapctl(2) system call.
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.34 1999/02/15 21:28:23 millert Exp $
d73 1
a73 1
18	STD		{ int sys_getfsstat(struct statfs *buf, long bufsize, \
d293 3
a295 3
157	STD		{ int sys_statfs(const char *path, \
			    struct statfs *buf); }
158	STD		{ int sys_fstatfs(int fd, struct statfs *buf); }
d517 5
@


1.34
log
@sendto(2) takes a socklen_t as well
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.33 1999/02/15 20:00:49 millert Exp $
d348 1
a348 1
; Syscalls 180-199 are used by/reserved for BSD
d370 1
a370 1
193	UNIMPL
d476 3
@


1.33
log
@use socklen_t
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.32 1998/11/18 01:14:25 art Exp $
d251 1
a251 1
			    int tolen); }
@


1.32
log
@syscalls behind #ifdef should have an #else
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.31 1998/09/17 20:54:04 art Exp $
d92 1
a92 1
			    int *fromlenaddr); }
d94 1
a94 1
			    int *anamelen); }
d98 1
a98 1
			    int *alen); }
d193 1
a193 1
			    int namelen); }
d203 1
a203 1
			    int namelen); }
d205 1
a205 1
			    const void *val, int valsize); }
d228 1
a228 1
			    void *val, int *avalsize); }
d263 1
a263 1
			    int *alen); } ogetpeername
@


1.31
log
@always use xfspioctl
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.30 1998/08/30 18:18:00 deraadt Exp $
d424 1
a424 1
; System calls 220-240 are reserved for use by NetBSD
d499 2
d505 2
d511 2
@


1.30
log
@clean
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.29 1998/08/30 18:04:21 art Exp $
a393 1
#ifdef XFS
a396 3
#else
208	UNIMPL		xfspioctl
#endif
@


1.29
log
@glue for xfspioctl syscall
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.28 1998/06/12 08:31:11 deraadt Exp $
d395 1
a395 1
208	STD		{ int sys_xfspioctl(int operation, char * a_pathP, \
d399 1
a399 1
208	UNIMPL		pioctl
@


1.28
log
@ifdef the new sem/shm/msg syscalls
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.27 1998/06/11 18:29:53 deraadt Exp $
d394 7
a400 1
208	UNIMPL
@


1.27
log
@move shm/msg/sem calls because ipc.h is getting uid_t and friends
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.26 1998/06/02 05:22:29 deraadt Exp $
d494 1
d497 2
d501 2
d505 1
@


1.26
log
@const mlock(2) and munlock(2)
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.25 1998/05/11 06:13:45 deraadt Exp $
d424 1
a424 1
220	STD		{ int sys___semctl(int semid, int semnum, int cmd, \
d437 2
a438 2
224	STD		{ int sys_msgctl(int msqid, int cmd, \
			    struct msqid_ds *buf); }
d453 2
a454 2
229	STD		{ int sys_shmctl(int shmid, int cmd, \
			    struct shmid_ds *buf); }
d494 6
@


1.25
log
@const a few more calls
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.24 1998/04/25 07:14:45 deraadt Exp $
d388 2
a389 2
203	STD		{ int sys_mlock(void *addr, size_t len); }
204	STD		{ int sys_munlock(void *addr, size_t len); }
@


1.24
log
@readlink() 3rd param is size_t; XPG
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.23 1998/02/16 21:56:28 millert Exp $
d440 1
a440 1
226	STD		{ int sys_msgsnd(int msqid, void *msgp, size_t msgsz, \
d451 1
a451 1
228	STD		{ void *sys_shmat(int shmid, void *shmaddr, \
d455 1
a455 1
230	STD		{ int sys_shmdt(void *shmaddr); }
@


1.23
log
@Make "flags" field in f?chflags(2) consistent--unsigned int
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.22 1998/02/10 08:44:07 deraadt Exp $
d138 1
a138 1
			    int count); }
@


1.22
log
@revert mode_t things to int, obviously requires more thought and work
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.21 1998/02/08 22:37:01 tholo Exp $
d100 2
a101 2
34	STD		{ int sys_chflags(const char *path, u_long flags); }
35	STD		{ int sys_fchflags(int fd, u_long flags); }
@


1.21
log
@Correct many types
@
text
@d1 1
a1 1
;	$OpenBSD: syscalls.master,v 1.20 1998/01/02 05:32:51 deraadt Exp $
d57 1
a57 1
			    int flags, ... mode_t mode); }
d61 1
a61 1
8	COMPAT_43	{ int sys_creat(const char *path, mode_t mode); } ocreat
d67 1
a67 1
14	STD		{ int sys_mknod(const char *path, mode_t mode, \
d69 1
a69 1
15	STD		{ int sys_chmod(const char *path, mode_t mode); }
d141 1
a141 1
60	STD		{ mode_t sys_umask(mode_t newmask); }
d237 1
a237 1
124	STD		{ int sys_fchmod(int fd, mode_t mode); }
d248 1
a248 1
132	STD		{ int sys_mkfifo(const char *path, mode_t mode); }
d255 1
a255 1
136	STD		{ int sys_mkdir(const char *path, mode_t mode); }
@


1.20
log
@make mmap() return void *, add MAP_FAILED
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.19 1997/11/14 20:56:03 deraadt Exp $
d20 2
d50 2
a51 2
0	STD		{ int sys_nosys(void); } syscall
1	STD		{ int sys_exit(int rval); }
d53 5
a57 3
3	STD		{ int sys_read(int fd, char *buf, u_int nbyte); }
4	STD		{ int sys_write(int fd, char *buf, u_int nbyte); }
5	STD		{ int sys_open(char *path, int flags, int mode); }
d61 3
a63 3
8	COMPAT_43	{ int sys_creat(char *path, int mode); } ocreat
9	STD		{ int sys_link(char *path, char *link); }
10	STD		{ int sys_unlink(char *path); }
d65 1
a65 1
12	STD		{ int sys_chdir(char *path); }
d67 5
a71 3
14	STD		{ int sys_mknod(char *path, int mode, int dev); }
15	STD		{ int sys_chmod(char *path, int mode); }
16	STD		{ int sys_chown(char *path, int uid, int gid); }
d78 3
a80 3
21	STD		{ int sys_mount(char *type, char *path, int flags, \
			    caddr_t data); }
22	STD		{ int sys_unmount(char *path, int flags); }
d86 1
a86 1
27	STD		{ int sys_recvmsg(int s, struct msghdr *msg, \
d88 8
a95 5
28	STD		{ int sys_sendmsg(int s, caddr_t msg, int flags); }
29	STD		{ int sys_recvfrom(int s, caddr_t buf, size_t len, \
			    int flags, caddr_t from, int *fromlenaddr); }
30	STD		{ int sys_accept(int s, caddr_t name, int *anamelen); }
31	STD		{ int sys_getpeername(int fdes, caddr_t asa, \
d97 1
a97 1
32	STD		{ int sys_getsockname(int fdes, caddr_t asa, \
d99 4
a102 4
33	STD		{ int sys_access(char *path, int flags); }
34	STD		{ int sys_chflags(char *path, int flags); }
35	STD		{ int sys_fchflags(int fd, int flags); }
36	STD		{ int sys_sync(void); }
d104 2
a105 1
38	COMPAT_43	{ int sys_stat(char *path, struct ostat *ub); } ostat
d107 3
a109 2
40	COMPAT_43	{ int sys_lstat(char *path, struct ostat *ub); } olstat
41	STD		{ int sys_dup(u_int fd); }
d112 1
a112 1
44	STD		{ int sys_profil(char *samples, size_t size, \
d115 2
a116 2
45	STD		{ int sys_ktrace(char *fname, int ops, int facs, \
			    int pid); }
d120 3
a122 2
46	STD		{ int sys_sigaction(int signum, struct sigaction \
			    *nsa, struct sigaction *osa); }
d126 2
a127 2
50	STD		{ int sys_setlogin(char *namebuf); }
51	STD		{ int sys_acct(char *path); }
d129 1
a129 1
53	STD		{ int sys_sigaltstack(struct sigaltstack *nss, \
d131 2
a132 1
54	STD		{ int sys_ioctl(int fd, u_long com, caddr_t data); }
d134 9
a142 7
56	STD		{ int sys_revoke(char *path); }
57	STD		{ int sys_symlink(char *path, char *link); }
58	STD		{ int sys_readlink(char *path, char *buf, int count); }
59	STD		{ int sys_execve(char *path, char **argp, \
			    char **envp); }
60	STD		{ int sys_umask(int newmask); }
61	STD		{ int sys_chroot(char *path); }
d165 4
a168 2
79	STD		{ int sys_getgroups(u_int gidsetsize, gid_t *gidset); }
80	STD		{ int sys_setgroups(u_int gidsetsize, gid_t *gidset); }
d170 4
a173 3
82	STD		{ int sys_setpgid(int pid, int pgid); }
83	STD		{ int sys_setitimer(u_int which, \
			    struct itimerval *itv, struct itimerval *oitv); }
d175 2
a176 2
85	STD		{ int sys_swapon(char *name); }
86	STD		{ int sys_getitimer(u_int which, \
d183 1
a183 1
90	STD		{ int sys_dup2(u_int from, u_int to); }
d185 2
a186 2
92	STD		{ int sys_fcntl(int fd, int cmd, void *arg); }
93	STD		{ int sys_select(u_int nd, fd_set *in, fd_set *ou, \
d192 2
a193 1
98	STD		{ int sys_connect(int s, caddr_t name, int namelen); }
d202 2
a203 1
104	STD		{ int sys_bind(int s, caddr_t name, int namelen); }
d205 1
a205 1
			    caddr_t val, int valsize); }
d228 1
a228 1
			    caddr_t val, int *avalsize); }
d230 8
a237 8
120	STD		{ int sys_readv(int fd, struct iovec *iovp, \
			    u_int iovcnt); }
121	STD		{ int sys_writev(int fd, struct iovec *iovp, \
			    u_int iovcnt); }
122	STD		{ int sys_settimeofday(struct timeval *tv, \
			    struct timezone *tzp); }
123	STD		{ int sys_fchown(int fd, int uid, int gid); }
124	STD		{ int sys_fchmod(int fd, int mode); }
d243 2
a244 2
128	STD		{ int sys_rename(char *from, char *to); }
129	COMPAT_43	{ int sys_truncate(char *path, long length); } \
d248 4
a251 3
132	STD		{ int sys_mkfifo(char *path, int mode); }
133	STD		{ int sys_sendto(int s, caddr_t buf, size_t len, \
			    int flags, caddr_t to, int tolen); }
d255 4
a258 3
136	STD		{ int sys_mkdir(char *path, int mode); }
137	STD		{ int sys_rmdir(char *path); }
138	STD		{ int sys_utimes(char *path, struct timeval *tptr); }
d260 1
a260 1
140	STD		{ int sys_adjtime(struct timeval *delta, \
d266 1
a266 1
144	COMPAT_43	{ int sys_getrlimit(u_int which, \
d268 1
a268 1
145	COMPAT_43	{ int sys_setrlimit(u_int which, \
d272 2
a273 2
148	STD		{ int sys_quotactl(char *path, int cmd, int uid, \
			    caddr_t arg); }
d287 1
a287 1
155	STD		{ int sys_nfssvc(int flag, caddr_t argp); }
d292 3
a294 2
			    u_int count, long *basep); } ogetdirentries
157	STD		{ int sys_statfs(char *path, struct statfs *buf); }
d299 1
a299 1
161	STD		{ int sys_getfh(char *fname, fhandle_t *fhp); }
d328 2
a329 2
171	COMPAT_10	{ int sys_shmsys(int which, int a2, int a3, \
			    int a4); } oshmsys
d337 1
a337 1
175	STD		{ int sys_ntp_gettime(struct timex *tp); }
d365 1
a365 1
188	STD		{ int sys_stat(char *path, struct stat *ub); }
d367 3
a369 3
190	STD		{ int sys_lstat(char *path, struct stat *ub); }
191	STD		{ int sys_pathconf(char *path, int name); }
192	STD		{ int sys_fpathconf(int fd, int name); }
d371 4
a374 2
194	STD		{ int sys_getrlimit(u_int which, struct rlimit *rlp); }
195	STD		{ int sys_setrlimit(u_int which, struct rlimit *rlp); }
d376 4
a379 5
			    u_int count, long *basep); }
197	STD		{ void *sys_mmap(void *addr, size_t len, \
			    int prot, int flags, int fd, long pad, \
			    off_t pos); }
198	STD		{ int sys_nosys(void); } __syscall
d382 1
a382 1
200	STD		{ int sys_truncate(char *path, int pad, \
d390 3
a392 2
205	STD		{ int sys_undelete(char *path); }
206	STD		{ int sys_futimes(int fd, struct timeval *tptr); }
d451 2
a452 1
228	STD		{ int sys_shmat(int shmid, void *shmaddr, int shmflg); }
d464 1
a464 1
				struct timespec *tp); }
d466 1
a466 1
				const struct timespec *tp); }
d468 1
a468 1
				struct timespec *tp); }
d475 1
a475 1
				struct timespec *rmtp); }
d491 1
a491 1
254	STD		{ int sys_lchown(char *path, int uid, int gid); }
@


1.19
log
@convert to void *addr
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.18 1997/11/13 18:35:31 deraadt Exp $
d352 1
a352 1
197	STD		{ caddr_t sys_mmap(void *addr, size_t len, \
@


1.18
log
@make msync() have 3 args
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.17 1997/11/13 07:11:12 deraadt Exp $
d141 2
a142 2
73	STD		{ int sys_munmap(caddr_t addr, size_t len); }
74	STD		{ int sys_mprotect(caddr_t addr, size_t len, \
d144 1
a144 1
75	STD		{ int sys_madvise(caddr_t addr, size_t len, \
d148 1
a148 1
78	STD		{ int sys_mincore(caddr_t addr, size_t len, \
d352 1
a352 1
197	STD		{ caddr_t sys_mmap(caddr_t addr, size_t len, \
d364 2
a365 2
203	STD		{ int sys_mlock(caddr_t addr, size_t len); }
204	STD		{ int sys_munlock(caddr_t addr, size_t len); }
d459 1
a459 1
250	STD		{ int sys_minherit(caddr_t addr, size_t len, \
@


1.17
log
@add getsid(2), XPG4
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.16 1997/08/29 20:44:24 kstailey Exp $
d132 1
a132 1
65	STD		{ int sys_msync(caddr_t addr, size_t len); }
d467 1
@


1.16
log
@prefix ntp system calls with sys_ like other system calls
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.15 1997/05/30 21:43:33 kstailey Exp $
d466 1
@


1.15
log
@add getpgid(2) from NetBSD
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.14 1997/04/20 20:48:27 tholo Exp $
d314 2
a315 2
175	STD		{ int ntp_gettime(struct timex *tp); }
176	STD		{ int ntp_adjtime(struct timex *tp); }
@


1.14
log
@Add new POSIX 1003.1b related syscalls; from pk@@NetBSD
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.13 1997/01/26 05:18:27 downsj Exp $
d368 1
a368 1
207	UNIMPL
@


1.13
log
@Add lchown(2).
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.12 1996/10/29 03:46:28 deraadt Exp $
d437 13
a449 9
232	UNIMPL
233	UNIMPL
234	UNIMPL
235	UNIMPL
236	UNIMPL
237	UNIMPL
238	UNIMPL
239	UNIMPL
240	UNIMPL
@


1.12
log
@pretty
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.11 1996/10/04 00:59:19 deraadt Exp $
d6 1
a6 1
; NetBSD system call name/number "master" file.
d461 1
@


1.11
log
@sys_getfh is NFSCLIENT|NFSSERVER
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.10 1996/08/25 09:51:34 deraadt Exp $
d109 2
a110 2
46	STD		{ int sys_sigaction(int signum, struct sigaction *nsa, \
			    struct sigaction *osa); }
d175 2
a176 2
99	COMPAT_43	{ int sys_accept(int s, caddr_t name, int *anamelen); } \
			    oaccept
d305 2
a306 2
171	COMPAT_10	{ int sys_shmsys(int which, int a2, int a3, int a4); } \
			    oshmsys
d352 3
a354 2
197	STD		{ caddr_t sys_mmap(caddr_t addr, size_t len, int prot, \
			    int flags, int fd, long pad, off_t pos); }
d358 2
a359 1
200	STD		{ int sys_truncate(char *path, int pad, off_t length); }
d458 2
a459 2
252	STD		{ int sys_poll(struct pollfd *fds, unsigned long nfds, \
			    int timeout); }
@


1.10
log
@issetugid() system call discovers if a process was started setuid or setgid
@
text
@d1 1
a1 1
	$OpenBSD: syscalls.master,v 1.9 1996/05/18 08:53:10 deraadt Exp $
d275 1
a275 1
#ifdef NFSCLIENT
@


1.9
log
@poll() as a system call
@
text
@d1 1
a1 1
	$OpenBSD$
d458 1
@


1.8
log
@Implement futimes()
@
text
@d40 1
d456 2
@


1.7
log
@First argument to profil(2) should be `char *', not `caddr_t'.
@
text
@d2 1
a2 1
;	$NetBSD: syscalls.master,v 1.31 1996/02/27 04:20:41 jonathan Exp $
d364 1
a364 1
206	UNIMPL
@


1.6
log
@NetBSD 960317 merge
@
text
@d100 1
a100 1
44	STD		{ int sys_profil(caddr_t samples, size_t size, \
@


1.5
log
@Add kernel PLL for system clock
Add ntp_adjtime() and ntp_gettime() system calls
Mostly stolen from FreeBSD
@
text
@d1 2
a2 1
	$NetBSD: syscalls.master,v 1.30 1995/11/22 23:07:29 cgd Exp $
d312 8
a319 3
175	UNIMPL
176	STD		{ int sys_ntp_adjtime(struct timex *tp); }
177	STD		{ int sys_ntp_gettime(struct ntptimeval *tp); }
@


1.4
log
@plan9-like rfork() implimentation by me based on some earlier incomplete
work by rminnich@@Sarnoff.COM. still needs RFNOWAIT support.
@
text
@d312 2
a313 2
176	UNIMPL
177	UNIMPL
@


1.3
log
@add minherit() system call
@
text
@d448 1
@


1.2
log
@from netbsd; change profil() arguments
@
text
@d428 20
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
	$NetBSD: syscalls.master,v 1.29 1995/10/10 01:32:53 mycroft Exp $
d99 2
a100 2
44	STD		{ int sys_profil(caddr_t samples, u_int size, \
			    u_int offset, u_int scale); }
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
