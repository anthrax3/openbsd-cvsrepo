head	1.23;
access;
symbols
	OPENBSD_6_1_BASE:1.23
	OPENBSD_6_0:1.23.0.2
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.12
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.10
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.13.0.10
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.12
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.8
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.6
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.4
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.12.0.6
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.12
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.10
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.8
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.8.0.6
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.4
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2016.06.19.11.54.34;	author natano;	state Exp;
branches;
next	1.22;
commitid	wHLNY5GFNXJSFYaC;

1.22
date	2015.03.14.03.38.53;	author jsg;	state Exp;
branches;
next	1.21;
commitid	p4LJxGKbi0BU2cG6;

1.21
date	2015.01.09.05.01.57;	author tedu;	state Exp;
branches;
next	1.20;
commitid	KWogeIYA2sxG3IjB;

1.20
date	2014.11.17.00.59.31;	author dlg;	state Exp;
branches;
next	1.19;
commitid	VXTJ1JGefQgUbZMW;

1.19
date	2014.09.14.14.17.27;	author jsg;	state Exp;
branches;
next	1.18;
commitid	uzzBR7hz9ncd4O6G;

1.18
date	2014.04.14.22.25.40;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2013.05.30.19.19.09;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.19.21.13.43;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.19.20.58.21;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.23.19.57.43;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2007.03.21.17.29.32;	author thib;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.19.02.18.02;	author pedro;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.10.22.01.14;	author pedro;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.26.21.22.14;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.08.12.06.13;	author art;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	99.04.28.09.28.18;	author art;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	98.01.09.20.38.05;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.11.06.05.59.26;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.20.21.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.06.15.27.37;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.21.26;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches;
next	;

1.7.4.1
date	2001.05.14.22.47.43;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	;

1.8.6.1
date	2003.05.20.04.18.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@/*	$OpenBSD: ufs_ihash.c,v 1.22 2015/03/14 03:38:53 jsg Exp $	*/
/*	$NetBSD: ufs_ihash.c,v 1.3 1996/02/09 22:36:04 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_ihash.c	8.4 (Berkeley) 12/30/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/vnode.h>
#include <sys/malloc.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufs_extern.h>

#include <crypto/siphash.h>

/*
 * Structures associated with inode cacheing.
 */
LIST_HEAD(ihashhead, inode) *ihashtbl;
u_long	ihash;		/* size of hash table - 1 */
SIPHASH_KEY ihashkey;

struct ihashhead *ufs_ihash(dev_t, ufsino_t);
#define INOHASH(device, inum) ufs_ihash((device), (inum))

struct ihashhead *
ufs_ihash(dev_t dev, ufsino_t inum)
{
	SIPHASH_CTX ctx;

	SipHash24_Init(&ctx, &ihashkey);
	SipHash24_Update(&ctx, &dev, sizeof(dev));
	SipHash24_Update(&ctx, &inum, sizeof(inum));

	return (&ihashtbl[SipHash24_End(&ctx) & ihash]);
}

/*
 * Initialize inode hash table.
 */
void
ufs_ihashinit(void)
{
	ihashtbl = hashinit(initialvnodes, M_UFSMNT, M_WAITOK, &ihash);
	arc4random_buf(&ihashkey, sizeof(ihashkey));
}

/*
 * Use the device/inum pair to find the incore inode, and return a pointer
 * to it. If it is in core, return it, even if it is locked.
 */
struct vnode *
ufs_ihashlookup(dev_t dev, ufsino_t inum)
{
        struct inode *ip;
	struct ihashhead *ipp;

	/* XXXLOCKING lock hash list */
	ipp = INOHASH(dev, inum);
	LIST_FOREACH(ip, ipp, i_hash) {
		if (inum == ip->i_number && dev == ip->i_dev)
			break;
	}
	/* XXXLOCKING unlock hash list? */

	if (ip)
		return (ITOV(ip));

	return (NULLVP);
}

/*
 * Use the device/inum pair to find the incore inode, and return a pointer
 * to it. If it is in core, but locked, wait for it.
 */
struct vnode *
ufs_ihashget(dev_t dev, ufsino_t inum)
{
	struct proc *p = curproc;
	struct ihashhead *ipp;
	struct inode *ip;
	struct vnode *vp;
loop:
	/* XXXLOCKING lock hash list */
	ipp = INOHASH(dev, inum);
	LIST_FOREACH(ip, ipp, i_hash) {
		if (inum == ip->i_number && dev == ip->i_dev) {
			vp = ITOV(ip);
			/* XXXLOCKING unlock hash list? */
			if (vget(vp, LK_EXCLUSIVE, p))
				goto loop;
			return (vp);
 		}
	}
	/* XXXLOCKING unlock hash list? */
	return (NULL);
}

/*
 * Insert the inode into the hash table, and return it locked.
 */
int
ufs_ihashins(struct inode *ip)
{
	struct   inode *curip;
	struct   ihashhead *ipp;
	dev_t    dev = ip->i_dev;
	ufsino_t inum = ip->i_number;

	/* lock the inode, then put it on the appropriate hash list */
	rrw_enter(&ip->i_lock, RW_WRITE);

	/* XXXLOCKING lock hash list */

	ipp = INOHASH(dev, inum);
	LIST_FOREACH(curip, ipp, i_hash) {
		if (inum == curip->i_number && dev == curip->i_dev) {
			/* XXXLOCKING unlock hash list? */
			rrw_exit(&ip->i_lock);
			return (EEXIST);
		}
	}

	SET(ip->i_flag, IN_HASHED);
	LIST_INSERT_HEAD(ipp, ip, i_hash);
	/* XXXLOCKING unlock hash list? */

	return (0);
}

/*
 * Remove the inode from the hash table.
 */
void
ufs_ihashrem(struct inode *ip)
{
	/* XXXLOCKING lock hash list */

	if (ip->i_hash.le_prev == NULL)
		return;
	if (ISSET(ip->i_flag, IN_HASHED)) {
		LIST_REMOVE(ip, i_hash);
		CLR(ip->i_flag, IN_HASHED);
	}
#ifdef DIAGNOSTIC
	ip->i_hash.le_next = NULL;
	ip->i_hash.le_prev = NULL;
#endif
	/* XXXLOCKING unlock hash list? */
}
@


1.22
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.21 2015/01/09 05:01:57 tedu Exp $	*/
d141 1
a141 1
	lockmgr(&ip->i_lock, LK_EXCLUSIVE, NULL);
d149 1
a149 1
			lockmgr(&ip->i_lock, LK_RELEASE, NULL);
@


1.21
log
@rename desiredvnodes to initialvnodes. less of a lie. ok beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.20 2014/11/17 00:59:31 dlg Exp $	*/
a43 1
#include <dev/rndvar.h>
@


1.20
log
@apply siphash to the key selection for the ufs inode hash.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.19 2014/09/14 14:17:27 jsg Exp $	*/
d75 1
a75 1
	ihashtbl = hashinit(desiredvnodes, M_UFSMNT, M_WAITOK, &ihash);
@


1.19
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.18 2014/04/14 22:25:40 beck Exp $	*/
d44 3
d52 16
a67 1
#define	INOHASH(device, inum)	(&ihashtbl[((device) + (inum)) & ihash])
d76 1
d87 1
d90 2
a91 1
	LIST_FOREACH(ip, INOHASH(dev, inum), i_hash)
d94 1
d111 1
d116 2
a117 1
	LIST_FOREACH(ip, INOHASH(dev, inum), i_hash) {
d146 2
a147 1
	LIST_FOREACH(curip, INOHASH(dev, inum), i_hash) {
a154 1
	ipp = INOHASH(dev, inum);
@


1.18
log
@fix potential race where an allocated inode could fail to get added,
noticed by pedro@@ in bitrig.
ok philip@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.17 2013/05/30 19:19:09 guenther Exp $	*/
a38 1
#include <sys/proc.h>
@


1.17
log
@UFS does't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

otto wrote the original diff for libsa to keep bootblock from overflowing
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.16 2010/07/19 21:13:43 deraadt Exp $	*/
d132 1
d149 4
a152 2

	LIST_REMOVE(ip, i_hash);
@


1.16
log
@Not enough OK's, and from the wrong people.  You should know how to do
collaborative development by now, Owain
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.14 2010/04/23 19:57:43 oga Exp $	*/
d66 1
a66 1
ufs_ihashlookup(dev_t dev, ino_t inum)
d87 1
a87 1
ufs_ihashget(dev_t dev, ino_t inum)
d113 4
a116 4
	struct inode *curip;
	struct ihashhead *ipp;
	dev_t  dev = ip->i_dev;
	ino_t  inum = ip->i_number;
@


1.15
log
@Replace XXXLOCKING comments by me (replacing simple_locks that are the
same thing) with mutexes.

From Gabriel Kihlman (gk AT stacken DOT kth DOT se); thanks!

ok art@@ ages ago.
@
text
@a38 1
#include <sys/mutex.h>
a50 1
struct mutex ihash_mtx = MUTEX_INITIALIZER(IPL_NONE);
d70 1
a70 1
	mtx_enter(&ihash_mtx);
d74 1
a74 1
	mtx_leave(&ihash_mtx);
d93 1
a93 1
	mtx_enter(&ihash_mtx);
d97 1
a97 1
			mtx_leave(&ihash_mtx);
d103 1
a103 1
	mtx_leave(&ihash_mtx);
d121 1
a121 1
	mtx_enter(&ihash_mtx);
d125 1
a125 1
			mtx_leave(&ihash_mtx);
d133 1
a133 1
	mtx_leave(&ihash_mtx);
d144 1
a144 1
	mtx_enter(&ihash_mtx);
d154 1
a154 1
	mtx_leave(&ihash_mtx);
@


1.14
log
@simple_lock -> XXXLOCKING for ufh ihash.

I'm actually 99% sure that these locks are right and could be almost
trivially converted to an IPL_NONE mutex protecting the hashtable. Any
takers?
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.13 2007/03/21 17:29:32 thib Exp $	*/
d39 1
d52 1
d72 1
a72 1
	/* XXXLOCKING lock hash list */
d76 1
a76 1
	/* XXXLOCKING unlock hash list? */
d95 1
a95 1
	/* XXXLOCKING lock hash list */
d99 1
a99 1
			/* XXXLOCKING unlock hash list? */
d105 1
a105 1
	/* XXXLOCKING unlock hash list? */
d123 1
a123 1
	/* XXXLOCKING lock hash list */
d127 1
a127 1
			/* XXXLOCKING unlock hash list? */
d135 1
a135 1
	/* XXXLOCKING unlock hash list? */
d146 1
a146 1
	/* XXXLOCKING lock hash list */
d156 1
a156 1
	/* XXXLOCKING unlock hash list? */
@


1.13
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.12 2005/11/19 02:18:02 pedro Exp $	*/
a50 1
struct simplelock ufs_ihash_slock;
a58 1
	simple_lock_init(&ufs_ihash_slock);
d70 1
a70 1
	simple_lock(&ufs_ihash_slock);
d74 1
a74 1
	simple_unlock(&ufs_ihash_slock);
d93 1
a93 1
	simple_lock(&ufs_ihash_slock);
d97 1
a97 1
			simple_unlock(&ufs_ihash_slock);
d103 1
a103 1
	simple_unlock(&ufs_ihash_slock);
d121 1
a121 1
	simple_lock(&ufs_ihash_slock);
d125 1
a125 1
		        simple_unlock(&ufs_ihash_slock);
d133 1
a133 1
	simple_unlock(&ufs_ihash_slock);
d144 1
a144 1
	simple_lock(&ufs_ihash_slock);
d154 1
a154 2
	simple_unlock(&ufs_ihash_slock);

@


1.12
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.11 2005/11/10 22:01:14 pedro Exp $	*/
a98 1
			simple_lock(&vp->v_interlock);
d100 1
a100 1
			if (vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, p))
@


1.11
log
@Use ANSI function declarations and deregister, no binary change.
Diff from Rui Reis <rui@@rui.cx>, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.10 2004/12/26 21:22:14 miod Exp $	*/
a116 1
	struct proc *p = curproc;
d122 1
a122 1
	lockmgr(&ip->i_lock, LK_EXCLUSIVE, (struct simplelock *)0, p);
d129 1
a129 1
			lockmgr(&ip->i_lock, LK_RELEASE, (struct simplelock *)0, p);
@


1.10
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.9 2003/06/02 23:28:23 millert Exp $	*/
d57 1
a57 1
ufs_ihashinit()
a58 1

d68 1
a68 3
ufs_ihashlookup(dev, inum)
	dev_t dev;
	ino_t inum;
d80 1
d89 1
a89 3
ufs_ihashget(dev, inum)
	dev_t dev;
	ino_t inum;
d114 1
a114 2
ufs_ihashins(ip)
	struct inode *ip;
d117 1
a117 1
	struct proc *p = curproc;		/* XXX */
d146 1
a146 2
ufs_ihashrem(ip)
	struct inode *ip;
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.8 2001/03/08 12:06:13 art Exp $	*/
d76 1
a76 1
	for (ip = INOHASH(dev, inum)->lh_first; ip; ip = ip->i_hash.le_next)
d100 1
a100 1
	for (ip = INOHASH(dev, inum)->lh_first; ip; ip = ip->i_hash.le_next) {
a108 1

d132 1
a132 2
	for (curip = INOHASH(dev, inum)->lh_first; curip; 
	     curip = curip->i_hash.le_next) {
@


1.8
log
@indentation
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.7 1999/04/28 09:28:18 art Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8.6.1
log
@use vnode lock in place of inode lock, switch to genfs_lock
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.8 2001/03/08 12:06:13 art Exp $	*/
d133 1
a133 1
	lockmgr(&ITOV(ip)->v_lock, LK_EXCLUSIVE, (struct simplelock *)0, p);
d141 1
a141 1
			lockmgr(&ITOV(ip)->v_lock, LK_RELEASE, (struct simplelock *)0, p);
@


1.7
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.6 1998/01/09 20:38:05 csapuntz Exp $	*/
d166 1
a166 1
 #ifdef DIAGNOSTIC
d169 1
a169 1
 #endif
@


1.7.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.8 2001/03/08 12:06:13 art Exp $	*/
d166 1
a166 1
#ifdef DIAGNOSTIC
d169 1
a169 1
#endif
@


1.7.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.7.4.1 2001/05/14 22:47:43 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6
log
@Prevent double insertions into the inode hash queue
Silently allow removal of inodes that aren't on the hash queues
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.5 1997/11/06 05:59:26 csapuntz Exp $	*/
d64 1
a64 1
	ihashtbl = hashinit(desiredvnodes, M_UFSMNT, &ihash);
@


1.5
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.4 1997/10/06 20:21:45 deraadt Exp $	*/
d122 1
a122 1
void
d126 1
d129 2
d134 1
a134 1
 
d136 11
a146 1
	ipp = INOHASH(ip->i_dev, ip->i_number);
d149 2
d161 4
@


1.4
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_ihash.c,v 1.2 1996/02/27 07:21:26 niklas Exp $	*/
d52 1
a52 1
struct inode **ihashtbl;
d54 2
a55 1
#define	INOHASH(device, inum)	(((device) + (inum)) & ihash)
d65 1
d73 2
a74 2
ufs_ihashlookup(device, inum)
	dev_t device;
d77 1
a77 1
	register struct inode *ip;
d79 9
a87 7
	for (ip = ihashtbl[INOHASH(device, inum)];; ip = ip->i_next) {
		if (ip == NULL)
			return (NULL);
		if (inum == ip->i_number && device == ip->i_dev)
			return (ITOV(ip));
	}
	/* NOTREACHED */
d95 2
a96 2
ufs_ihashget(device, inum)
	dev_t device;
d99 2
a100 1
	register struct inode *ip;
d102 11
d114 3
a116 17
	for (;;)
		for (ip = ihashtbl[INOHASH(device, inum)];; ip = ip->i_next) {
			if (ip == NULL)
				return (NULL);
			if (inum == ip->i_number && device == ip->i_dev) {
				if (ip->i_flag & IN_LOCKED) {
					ip->i_flag |= IN_WANTED;
					sleep(ip, PINOD);
					break;
				}
				vp = ITOV(ip);
				if (!vget(vp, 1))
					return (vp);
				break;
			}
		}
	/* NOTREACHED */
d126 2
a127 1
	struct inode **ipp, *iq;
d129 7
a135 13
	ipp = &ihashtbl[INOHASH(ip->i_dev, ip->i_number)];
	if ((iq = *ipp) != NULL)
		iq->i_prev = &ip->i_next;
	ip->i_next = iq;
	ip->i_prev = ipp;
	*ipp = ip;
	if (ip->i_flag & IN_LOCKED)
		panic("ufs_ihashins: already locked");
	if (curproc)
		ip->i_lockholder = curproc->p_pid;
	else
		ip->i_lockholder = -1;
	ip->i_flag |= IN_LOCKED;
d143 1
a143 1
	register struct inode *ip;
d145 7
a151 1
	register struct inode *iq;
a152 7
	if ((iq = ip->i_next) != NULL)
		iq->i_prev = ip->i_prev;
	*ip->i_prev = iq;
#ifdef DIAGNOSTIC
	ip->i_next = NULL;
	ip->i_prev = NULL;
#endif
@


1.3
log
@VFS Lite2 Changes
@
text
@d52 1
a52 1
LIST_HEAD(ihashhead, inode) *ihashtbl;
d54 1
a54 2
#define	INOHASH(device, inum)	(&ihashtbl[((device) + (inum)) & ihash])
struct simplelock ufs_ihash_slock;
a63 1
	simple_lock_init(&ufs_ihash_slock);
d71 2
a72 2
ufs_ihashlookup(dev, inum)
	dev_t dev;
d75 1
a75 1
        struct inode *ip;
d77 7
a83 9
	simple_lock(&ufs_ihash_slock);
	for (ip = INOHASH(dev, inum)->lh_first; ip; ip = ip->i_hash.le_next)
		if (inum == ip->i_number && dev == ip->i_dev)
			break;
	simple_unlock(&ufs_ihash_slock);

	if (ip)
		return (ITOV(ip));
	return (NULLVP);
d91 2
a92 2
ufs_ihashget(dev, inum)
	dev_t dev;
d95 1
a95 2
	struct proc *p = curproc;
	struct inode *ip;
a96 11
loop:
	simple_lock(&ufs_ihash_slock);
	for (ip = INOHASH(dev, inum)->lh_first; ip; ip = ip->i_hash.le_next) {
		if (inum == ip->i_number && dev == ip->i_dev) {
			vp = ITOV(ip);
			simple_lock(&vp->v_interlock);
			simple_unlock(&ufs_ihash_slock);
			if (vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, p))
				goto loop;
			return (vp);
 		}
d98 17
a114 3
	}
	simple_unlock(&ufs_ihash_slock);
	return (NULL);
d124 1
a124 2
	struct proc *p = curproc;		/* XXX */
	struct ihashhead *ipp;
d126 13
a138 7
	/* lock the inode, then put it on the appropriate hash list */
	lockmgr(&ip->i_lock, LK_EXCLUSIVE, (struct simplelock *)0, p);
 
	simple_lock(&ufs_ihash_slock);
	ipp = INOHASH(ip->i_dev, ip->i_number);
	LIST_INSERT_HEAD(ipp, ip, i_hash);
	simple_unlock(&ufs_ihash_slock);
d146 1
a146 1
	struct inode *ip;
d148 1
a148 7
	simple_lock(&ufs_ihash_slock);
	LIST_REMOVE(ip, i_hash);
 #ifdef DIAGNOSTIC
	ip->i_hash.le_next = NULL;
	ip->i_hash.le_prev = NULL;
 #endif
	simple_unlock(&ufs_ihash_slock);
d150 7
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d52 1
a52 1
struct inode **ihashtbl;
d54 2
a55 1
#define	INOHASH(device, inum)	(((device) + (inum)) & ihash)
d65 1
d73 2
a74 2
ufs_ihashlookup(device, inum)
	dev_t device;
d77 1
a77 1
	register struct inode *ip;
d79 9
a87 7
	for (ip = ihashtbl[INOHASH(device, inum)];; ip = ip->i_next) {
		if (ip == NULL)
			return (NULL);
		if (inum == ip->i_number && device == ip->i_dev)
			return (ITOV(ip));
	}
	/* NOTREACHED */
d95 2
a96 2
ufs_ihashget(device, inum)
	dev_t device;
d99 2
a100 1
	register struct inode *ip;
d102 11
d114 3
a116 17
	for (;;)
		for (ip = ihashtbl[INOHASH(device, inum)];; ip = ip->i_next) {
			if (ip == NULL)
				return (NULL);
			if (inum == ip->i_number && device == ip->i_dev) {
				if (ip->i_flag & IN_LOCKED) {
					ip->i_flag |= IN_WANTED;
					sleep(ip, PINOD);
					break;
				}
				vp = ITOV(ip);
				if (!vget(vp, 1))
					return (vp);
				break;
			}
		}
	/* NOTREACHED */
d126 2
a127 1
	struct inode **ipp, *iq;
d129 7
a135 13
	ipp = &ihashtbl[INOHASH(ip->i_dev, ip->i_number)];
	if ((iq = *ipp) != NULL)
		iq->i_prev = &ip->i_next;
	ip->i_next = iq;
	ip->i_prev = ipp;
	*ipp = ip;
	if (ip->i_flag & IN_LOCKED)
		panic("ufs_ihashins: already locked");
	if (curproc)
		ip->i_lockholder = curproc->p_pid;
	else
		ip->i_lockholder = -1;
	ip->i_flag |= IN_LOCKED;
d143 1
a143 1
	register struct inode *ip;
d145 7
a151 1
	register struct inode *iq;
a152 7
	if ((iq = ip->i_next) != NULL)
		iq->i_prev = ip->i_prev;
	*ip->i_prev = iq;
#ifdef DIAGNOSTIC
	ip->i_next = NULL;
	ip->i_prev = NULL;
#endif
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ufs_ihash.c,v 1.2 1994/06/29 06:47:26 cgd Exp $	*/
d127 1
a127 1
	if (iq = *ipp)
d150 1
a150 1
	if (iq = ip->i_next)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
