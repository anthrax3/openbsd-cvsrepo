head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.4
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.35.0.12
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.8
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.10
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.35.0.6
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.34.0.2
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.32.0.10
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.8
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.6
	OPENBSD_5_0:1.32.0.4
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.29.0.12
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.8
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.10
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.6
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.4
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.25.0.6
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.4
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.2
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.6
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.18
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.9.0.6
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2016.08.10.08.04.57;	author natano;	state Exp;
branches;
next	1.35;
commitid	a3QYlN9gTOdBi75t;

1.35
date	2014.01.25.23.31.13;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2013.06.11.16.42.19;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2013.05.30.19.19.09;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2010.12.21.20.14.44;	author thib;	state Exp;
branches;
next	1.31;

1.31
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.29;

1.29
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.09.17.04.22;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.26;

1.26
date	2006.10.03.19.49.06;	author pedro;	state Exp;
branches;
next	1.25;

1.25
date	2005.07.20.16.30.35;	author pedro;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.10.17.37.41;	author pedro;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.28.02.02.50;	author pedro;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.07.04.37.28;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.07.01.40.16;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.03.16.13;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.27.15;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.10.04.45.32;	author art;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.12.04.22.44.32;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.21.21.23.56;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.01.20.54.36;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.21.23.24.31;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.07.04.57.19;	author assar;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	98.08.06.19.35.13;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	98.01.09.20.38.03;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.12.02.17.11.10;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.11.06.05.59.26;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.20.21.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.06.15.27.36;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.21.25;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	2001.05.14.22.47.43;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2004.02.19.11.01.43;	author niklas;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2004.06.05.23.13.12;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.05.20.04.18.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@ufs_vinit() should really be called ffs_vinit(); it's only called from
ffs code.
ok mpi tedu
@
text
@/*	$OpenBSD: ufs_extern.h,v 1.35 2014/01/25 23:31:13 guenther Exp $	*/
/*	$NetBSD: ufs_extern.h,v 1.5 1996/02/09 22:36:03 christos Exp $	*/

/*-
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_extern.h	8.6 (Berkeley) 8/10/94
 */

struct buf;
struct componentname;
struct direct;
struct disklabel;
struct dquot;
struct fid;
struct flock;
struct indir;
struct inode;
struct mbuf;
struct mount;
struct nameidata;
struct proc;
struct ucred;
struct ufs_args;
struct ufsmount;
struct uio;
struct vattr;
struct vfsconf;
struct vnode;

int	 ufs_access(void *);
int	 ufs_advlock(void *);
int	 ufs_bmap(void *);
int	 ufs_close(void *);
int	 ufs_create(void *);
int	 ufs_getattr(void *);
int	 ufs_inactive(void *);
int	 ufs_ioctl(void *);
int	 ufs_islocked(void *);
int	 ufs_link(void *);
int	 ufs_lock(void *);
int	 ufs_lookup(void *);
int	 ufs_mkdir(void *);
int	 ufs_mknod(void *);
int	 ufs_mmap(void *);
int	 ufs_open(void *);
int	 ufs_pathconf(void *);
int	 ufs_print(void *);
int	 ufs_readdir(void *);
int	 ufs_readlink(void *);
int	 ufs_remove(void *);
int	 ufs_rename(void *);
int	 ufs_rmdir(void *);
int	 ufs_poll(void *);
int	 ufs_kqfilter(void *);
int	 ufs_setattr(void *);
int	 ufs_strategy(void *);
int	 ufs_symlink(void *);
int	 ufs_unlock(void *);
int	 ufsspec_close(void *);
int	 ufsspec_read(void *);
int	 ufsspec_write(void *);

#ifdef FIFO
int	ufsfifo_read(void *);
int	ufsfifo_write(void *);
int	ufsfifo_close(void *);
#endif

/* ufs_bmap.c */
int ufs_bmaparray(struct vnode *, daddr_t, daddr_t *, struct indir *,
		       int *, int *);
int ufs_getlbns(struct vnode *, daddr_t, struct indir *, int *);

/* ufs_ihash.c */
void ufs_ihashinit(void);
struct vnode *ufs_ihashlookup(dev_t, ufsino_t);
struct vnode *ufs_ihashget(dev_t, ufsino_t);
int ufs_ihashins(struct inode *);
void ufs_ihashrem(struct inode *);

/* ufs_inode.c */
int ufs_init(struct vfsconf *);
int ufs_reclaim(struct vnode *, struct proc *);

/* ufs_lookup.c */
void ufs_dirbad(struct inode *, doff_t, char *);
int ufs_dirbadentry(struct vnode *, struct direct *, int);
void ufs_makedirentry(struct inode *, struct componentname *,
			   struct direct *);
int ufs_direnter(struct vnode *, struct vnode *, struct direct *,
		      struct componentname *, struct buf *);
int ufs_dirremove(struct vnode *, struct inode *, int, int);
int ufs_dirrewrite(struct inode *, struct inode *,
		        ufsino_t, int, int);
int ufs_dirempty(struct inode *, ufsino_t, struct ucred *);
int ufs_checkpath(struct inode *, struct inode *, struct ucred *);

/* ufs_vfsops.c */
int ufs_start(struct mount *, int, struct proc *);
int ufs_root(struct mount *, struct vnode **);
int ufs_quotactl(struct mount *, int, uid_t, caddr_t, struct proc *);
int ufs_fhtovp(struct mount *, struct ufid *, struct vnode **);
int ufs_check_export(struct mount *, struct mbuf *, int *,
		struct ucred **);

/* ufs_vnops.c */
void ufs_itimes(struct vnode *);
int ufs_makeinode(int, struct vnode *, struct vnode **,
		  struct componentname *);

 
/*
 * Soft dependency function prototypes.
 */
int  softdep_setup_directory_add(struct buf *, struct inode *, off_t,
          long, struct buf *, int);
void  softdep_change_directoryentry_offset(struct inode *, caddr_t,
          caddr_t, caddr_t, int);
void  softdep_setup_remove(struct buf *,struct inode *, struct inode *,
          int);
void  softdep_setup_directory_change(struct buf *, struct inode *,
          struct inode *, long, int);
void  softdep_change_linkcnt(struct inode *, int);
int   softdep_slowdown(struct vnode *);
@


1.35
log
@ufs_setattr() was assuming that the flag bits that indicate
atime/mtime/ctime need to be updated weren't already set.  When
they are, the code will end up treating the VNOVAL value from the
VFS layer as a time_t.  Port the fix from FreeBSD: the critical bit
is to process the existing flag values before possibly setting them
again in ufs_setattr().  This diff pulls in a larger change from
FreeBSD to replace the macro ITIMES() with a function ufs_itimes()
and to remove the atime and mtime arguments from ffs_update(): only
ufs_setattr() used them so it makes more sense to just do the those
bits directly there.

tweaks and ok tedu@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.34 2013/06/11 16:42:19 deraadt Exp $	*/
a132 1
int ufs_vinit(struct mount *, struct vops *, struct vops *, struct vnode **);
@


1.34
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.33 2013/05/30 19:19:09 guenther Exp $	*/
d134 1
@


1.33
log
@UFS does't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

otto wrote the original diff for libsa to keep bootblock from overflowing
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.32 2010/12/21 20:14:44 thib Exp $	*/
d96 1
a96 1
int ufs_bmaparray(struct vnode *, daddr64_t, daddr64_t *, struct indir *,
d98 1
a98 1
int ufs_getlbns(struct vnode *, daddr64_t, struct indir *, int *);
@


1.32
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.31 2010/09/10 16:34:09 thib Exp $	*/
d102 2
a103 2
struct vnode *ufs_ihashlookup(dev_t, ino_t);
struct vnode *ufs_ihashget(dev_t, ino_t);
d120 2
a121 2
		        ino_t, int, int);
int ufs_dirempty(struct inode *, ino_t, struct ucred *);
@


1.31
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.30 2010/09/06 23:44:10 thib Exp $	*/
a55 1
__BEGIN_DECLS
a77 1
#define  ufs_revoke  vop_generic_revoke
d133 1
a133 2
int ufs_vinit(struct mount *, int (**)(void *),
	      int (**)(void *), struct vnode **);
a150 2

__END_DECLS
@


1.30
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.29 2008/01/05 19:49:26 otto Exp $	*/
d56 1
d79 1
d135 2
a136 1
int ufs_vinit(struct mount *, struct vops *, struct vops *, struct vnode **);
d154 2
@


1.29
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.28 2007/05/09 17:04:22 deraadt Exp $	*/
a55 1
__BEGIN_DECLS
a77 1
#define  ufs_revoke  vop_generic_revoke
d133 1
a133 2
int ufs_vinit(struct mount *, int (**)(void *),
	      int (**)(void *), struct vnode **);
a150 2

__END_DECLS
@


1.28
log
@unused function; ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.27 2007/01/16 17:52:18 thib Exp $	*/
d98 1
a98 1
int ufs_bmaparray(struct vnode *, daddr_t, daddr64_t *, struct indir *,
d100 1
a100 1
int ufs_getlbns(struct vnode *, daddr_t, struct indir *, int *);
@


1.27
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.26 2006/10/03 19:49:06 pedro Exp $	*/
a80 1
int	 ufs_seek(void *);
@


1.26
log
@Introduce daddr64_t and use it for physical block numbers
Okay weingart@@, "I'm game with putting my name on it" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.25 2005/07/20 16:30:35 pedro Exp $	*/
a65 6
#ifdef NFSSERVER
int	 lease_check(void *);
#define	 ufs_lease_check lease_check
#else
#define	 ufs_lease_check ((int (*)(void *))nullop)
#endif
@


1.25
log
@Reintroduce the changes made by tedu in revision 1.50 of ffs_softdep.c,
this time with a small tweak: when flushing the dependencies, don't
update the inode twice, but update once, and then, if needed, fsync it.
Doing so fixes the inode hangs some people were seeing.

Various testing for a while, especially krw@@ and millert@@, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.24 2005/06/10 17:37:41 pedro Exp $	*/
d105 1
a105 1
int ufs_bmaparray(struct vnode *, daddr_t, daddr_t *, struct indir *,
@


1.24
log
@Tweak softdep_change_linkcnt() so we can specify whether we're willing
to be co-opted by softdep or not, and use this new interface to inform
softdep in ufs_inactive() that the inode mode has changed.

We don't want to be co-opted there as that might lead to undesired
circular dependencies such as a vput() depending on another vput() to
complete, or a process that is trying to free up a vnode being blocked
trying to acquire a new vnode.

Okay tedu@@ deraadt@@, thanks to all those who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.23 2005/05/28 02:02:50 pedro Exp $	*/
d151 2
a152 2
void  softdep_setup_directory_add(struct buf *, struct inode *, off_t,
          long, struct buf *);
@


1.23
log
@ufs_whiteout() is now pointless, remove it, okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.22 2004/12/07 04:37:28 tedu Exp $	*/
d159 1
a159 1
void  softdep_change_linkcnt(struct inode *);
@


1.22
log
@prev softdep merge could lead to inode wait deadlock for unknown reasons.
revert.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.21 2004/05/07 01:40:16 tedu Exp $	*/
a93 1
int	 ufs_whiteout(void *);
@


1.21
log
@fatty softdep merge with freebsd.  fixes a variety of possible issues.
relevant changes to ffs_softdep.c were 1.95, 1.96, 1.97, 1.98, 1.103, and
1.107 in freebsd.  testing marc and otto.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.20 2003/09/23 16:51:13 millert Exp $	*/
d152 2
a153 2
int  softdep_setup_directory_add(struct buf *, struct inode *, off_t,
          long, struct buf *, int);
@


1.20
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.19 2003/06/02 23:28:23 millert Exp $	*/
d152 2
a153 2
void  softdep_setup_directory_add(struct buf *, struct inode *, off_t,
          long, struct buf *);
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.18 2002/03/14 03:16:13 millert Exp $	*/
d88 1
a88 1
int	 ufs_select(void *);
@


1.18
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.17 2002/03/14 01:27:15 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.16 2001/12/19 08:58:07 art Exp $	*/
d147 2
a148 2
int ufs_vinit __P((struct mount *, int (**)(void *),
		   int (**)(void *), struct vnode **));
d150 1
a150 1
		       struct componentname *);
@


1.16
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.12 2001/11/21 21:23:56 csapuntz Exp $	*/
d61 9
a69 9
int	 ufs_access	__P((void *));
int	 ufs_advlock	__P((void *));
int	 ufs_bmap	__P((void *));
int	 ufs_close	__P((void *));
int	 ufs_create	__P((void *));
int	 ufs_getattr	__P((void *));
int	 ufs_inactive	__P((void *));
int	 ufs_ioctl	__P((void *));
int	 ufs_islocked	__P((void *));
d71 1
a71 1
int	 lease_check	__P((void *));
d74 1
a74 1
#define	 ufs_lease_check ((int (*) __P((void *)))nullop)
d76 13
a88 13
int	 ufs_link	__P((void *));
int	 ufs_lock	__P((void *));
int	 ufs_lookup	__P((void *));
int	 ufs_mkdir	__P((void *));
int	 ufs_mknod	__P((void *));
int	 ufs_mmap	__P((void *));
int	 ufs_open	__P((void *));
int	 ufs_pathconf	__P((void *));
int	 ufs_print	__P((void *));
int	 ufs_readdir	__P((void *));
int	 ufs_readlink	__P((void *));
int	 ufs_remove	__P((void *));
int	 ufs_rename	__P((void *));
d90 12
a101 12
int	 ufs_rmdir	__P((void *));
int	 ufs_seek	__P((void *));
int	 ufs_select	__P((void *));
int	 ufs_kqfilter	__P((void *));
int	 ufs_setattr	__P((void *));
int	 ufs_strategy	__P((void *));
int	 ufs_symlink	__P((void *));
int	 ufs_unlock	__P((void *));
int	 ufs_whiteout	__P((void *));
int	 ufsspec_close	__P((void *));
int	 ufsspec_read	__P((void *));
int	 ufsspec_write	__P((void *));
d104 3
a106 3
int	ufsfifo_read	__P((void *));
int	ufsfifo_write	__P((void *));
int	ufsfifo_close	__P((void *));
d110 3
a112 3
int ufs_bmaparray __P((struct vnode *, daddr_t, daddr_t *, struct indir *,
		       int *, int *));
int ufs_getlbns __P((struct vnode *, daddr_t, struct indir *, int *));
d115 5
a119 5
void ufs_ihashinit __P((void));
struct vnode *ufs_ihashlookup __P((dev_t, ino_t));
struct vnode *ufs_ihashget __P((dev_t, ino_t));
int ufs_ihashins __P((struct inode *));
void ufs_ihashrem __P((struct inode *));
d122 2
a123 2
int ufs_init __P((struct vfsconf *));
int ufs_reclaim __P((struct vnode *, struct proc *));
d126 11
a136 11
void ufs_dirbad __P((struct inode *, doff_t, char *));
int ufs_dirbadentry __P((struct vnode *, struct direct *, int));
void ufs_makedirentry __P((struct inode *, struct componentname *,
			   struct direct *));
int ufs_direnter __P((struct vnode *, struct vnode *, struct direct *,
		      struct componentname *, struct buf *));
int ufs_dirremove __P((struct vnode *, struct inode *, int, int));
int ufs_dirrewrite __P((struct inode *, struct inode *,
		        ino_t, int, int));
int ufs_dirempty __P((struct inode *, ino_t, struct ucred *));
int ufs_checkpath __P((struct inode *, struct inode *, struct ucred *));
d139 6
a144 6
int ufs_start __P((struct mount *, int, struct proc *));
int ufs_root __P((struct mount *, struct vnode **));
int ufs_quotactl __P((struct mount *, int, uid_t, caddr_t, struct proc *));
int ufs_fhtovp __P((struct mount *, struct ufid *, struct vnode **));
int ufs_check_export __P((struct mount *, struct mbuf *, int *,
		struct ucred **));
d147 4
a150 4
int ufs_vinit __P((struct mount *, int (**) __P((void *)),
		   int (**) __P((void *)), struct vnode **));
int ufs_makeinode __P((int, struct vnode *, struct vnode **,
		       struct componentname *));
d156 10
a165 10
void  softdep_setup_directory_add __P((struct buf *, struct inode *, off_t,
          long, struct buf *));
void  softdep_change_directoryentry_offset __P((struct inode *, caddr_t,
          caddr_t, caddr_t, int));
void  softdep_setup_remove __P((struct buf *,struct inode *, struct inode *,
          int));
void  softdep_setup_directory_change __P((struct buf *, struct inode *,
          struct inode *, long, int));
void  softdep_change_linkcnt __P((struct inode *));
int   softdep_slowdown __P((struct vnode *));
@


1.15
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.14 2001/12/04 22:44:32 art Exp $	*/
d81 1
a101 1
#define	 ufs_mmap vop_generic_mmap
a123 1
int ufs_balloc_range __P((struct vnode *, off_t, off_t, struct ucred *, int));
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.15 2001/12/10 04:45:32 art Exp $	*/
d61 9
a69 9
int	 ufs_access(void *);
int	 ufs_advlock(void *);
int	 ufs_bmap(void *);
int	 ufs_close(void *);
int	 ufs_create(void *);
int	 ufs_getattr(void *);
int	 ufs_inactive(void *);
int	 ufs_ioctl(void *);
int	 ufs_islocked(void *);
d71 1
a71 1
int	 lease_check(void *);
d74 1
a74 1
#define	 ufs_lease_check ((int (*)(void *))nullop)
d76 12
a87 12
int	 ufs_link(void *);
int	 ufs_lock(void *);
int	 ufs_lookup(void *);
int	 ufs_mkdir(void *);
int	 ufs_mknod(void *);
int	 ufs_open(void *);
int	 ufs_pathconf(void *);
int	 ufs_print(void *);
int	 ufs_readdir(void *);
int	 ufs_readlink(void *);
int	 ufs_remove(void *);
int	 ufs_rename(void *);
d89 12
a101 13
int	ufs_rmdir(void *);
int	ufs_seek(void *);
int	ufs_select(void *);
int	ufs_kqfilter(void *);
int	ufs_setattr(void *);
int	ufs_strategy(void *);
int	ufs_symlink(void *);
int	ufs_unlock(void *);
int	ufs_whiteout(void *);
int	ufsspec_close(void *);
int	ufsspec_read(void *);
int	ufsspec_write(void *);

d104 3
a106 3
int	ufsfifo_read(void *);
int	ufsfifo_write(void *);
int	ufsfifo_close(void *);
d110 3
a112 3
int ufs_bmaparray(struct vnode *, daddr_t, daddr_t *, struct indir *,
		       int *, int *);
int ufs_getlbns(struct vnode *, daddr_t, struct indir *, int *);
d115 5
a119 5
void ufs_ihashinit(void);
struct vnode *ufs_ihashlookup(dev_t, ino_t);
struct vnode *ufs_ihashget(dev_t, ino_t);
int ufs_ihashins(struct inode *);
void ufs_ihashrem(struct inode *);
d122 3
a124 3
int ufs_init(struct vfsconf *);
int ufs_reclaim(struct vnode *, struct proc *);
int ufs_balloc_range(struct vnode *, off_t, off_t, struct ucred *, int);
d127 11
a137 11
void ufs_dirbad(struct inode *, doff_t, char *);
int ufs_dirbadentry(struct vnode *, struct direct *, int);
void ufs_makedirentry(struct inode *, struct componentname *,
			   struct direct *);
int ufs_direnter(struct vnode *, struct vnode *, struct direct *,
		      struct componentname *, struct buf *);
int ufs_dirremove(struct vnode *, struct inode *, int, int);
int ufs_dirrewrite(struct inode *, struct inode *,
		        ino_t, int, int);
int ufs_dirempty(struct inode *, ino_t, struct ucred *);
int ufs_checkpath(struct inode *, struct inode *, struct ucred *);
d140 6
a145 6
int ufs_start(struct mount *, int, struct proc *);
int ufs_root(struct mount *, struct vnode **);
int ufs_quotactl(struct mount *, int, uid_t, caddr_t, struct proc *);
int ufs_fhtovp(struct mount *, struct ufid *, struct vnode **);
int ufs_check_export(struct mount *, struct mbuf *, int *,
		struct ucred **);
d148 4
a151 4
int ufs_vinit(struct mount *, int (**)(void *),
	      int (**)(void *), struct vnode **);
int ufs_makeinode(int, struct vnode *, struct vnode **,
		  struct componentname *);
d157 10
a166 10
void  softdep_setup_directory_add(struct buf *, struct inode *, off_t,
          long, struct buf *);
void  softdep_change_directoryentry_offset(struct inode *, caddr_t,
          caddr_t, caddr_t, int);
void  softdep_setup_remove(struct buf *,struct inode *, struct inode *,
          int);
void  softdep_setup_directory_change(struct buf *, struct inode *,
          struct inode *, long, int);
void  softdep_change_linkcnt(struct inode *);
int   softdep_slowdown(struct vnode *);
@


1.15.2.2
log
@use vnode lock in place of inode lock, switch to genfs_lock
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.15.2.1 2002/06/11 03:32:50 art Exp $	*/
d69 1
a69 1
#define	 ufs_islocked	genfs_islocked
d77 1
a77 1
#define	 ufs_lock	genfs_lock
d97 1
a97 1
#define	ufs_unlock	genfs_unlock
@


1.14
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.13 2001/11/27 05:27:12 art Exp $	*/
d101 1
a101 1
#define	 ufs_mmap genfs_mmap
@


1.13
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.12 2001/11/21 21:23:56 csapuntz Exp $	*/
a80 1
int	 ufs_mmap	__P((void *));
d101 1
@


1.12
log
@Don't use #define QUOTA - use stub file instead

Pass over the quota code in ufs/. Make code paths clearer. Clean up some names.
Move all code that manipulates quotas directly into ufs_quota.c

Use vfs_mount_foreach_vnode to traverse list of vnodes in mountpoint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.11 2001/03/01 20:54:36 provos Exp $	*/
d124 1
@


1.11
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.10 2001/02/21 23:24:31 csapuntz Exp $	*/
a136 20

/* ufs_quota.c */
int getinoquota __P((struct inode *));
int chkdq __P((struct inode *, long, struct ucred *, int));
int chkdqchg __P((struct inode *, long, struct ucred *, int));
int chkiq __P((struct inode *, long, struct ucred *, int));
int chkiqchg __P((struct inode *, long, struct ucred *, int));
void chkdquot __P((struct inode *));
int quotaon __P((struct proc *, struct mount *, int, caddr_t));
int quotaoff __P((struct proc *, struct mount *, int));
int getquota __P((struct mount *, u_long, int, caddr_t));
int setquota __P((struct mount *, u_long, int, caddr_t));
int setuse __P((struct mount *, u_long, int, caddr_t));
int qsync __P((struct mount *));
int dqget __P((struct vnode *, u_long, struct ufsmount *, int,
	       struct dquot **));
void dqref __P((struct dquot *));
void dqrele __P((struct vnode *, struct dquot *));
int dqsync __P((struct vnode *, struct dquot *));
void dqflush __P((struct vnode *));
@


1.10
log
@

Latest soft updates from FreeBSD/Kirk McKusick

Snapshot-related code has been commented out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.9 2000/02/07 04:57:19 assar Exp $	*/
d93 1
@


1.9
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.8 1998/08/06 19:35:13 csapuntz Exp $	*/
d183 2
a184 1
void  softdep_increase_linkcnt __P((struct inode *));
@


1.9.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.11 2001/03/01 20:54:36 provos Exp $	*/
a92 1
int	 ufs_kqfilter	__P((void *));
d183 1
a183 2
void  softdep_change_linkcnt __P((struct inode *));
int   softdep_slowdown __P((struct vnode *));
@


1.9.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a123 1
int ufs_balloc_range __P((struct vnode *, off_t, off_t, struct ucred *, int));
d137 20
@


1.9.2.3
log
@Merge in trunk
@
text
@d124 1
@


1.9.2.4
log
@Merge in -current from roughly a week ago
@
text
@d61 9
a69 9
int	 ufs_access(void *);
int	 ufs_advlock(void *);
int	 ufs_bmap(void *);
int	 ufs_close(void *);
int	 ufs_create(void *);
int	 ufs_getattr(void *);
int	 ufs_inactive(void *);
int	 ufs_ioctl(void *);
int	 ufs_islocked(void *);
d71 1
a71 1
int	 lease_check(void *);
d74 1
a74 1
#define	 ufs_lease_check ((int (*)(void *))nullop)
d76 13
a88 13
int	 ufs_link(void *);
int	 ufs_lock(void *);
int	 ufs_lookup(void *);
int	 ufs_mkdir(void *);
int	 ufs_mknod(void *);
int	 ufs_mmap(void *);
int	 ufs_open(void *);
int	 ufs_pathconf(void *);
int	 ufs_print(void *);
int	 ufs_readdir(void *);
int	 ufs_readlink(void *);
int	 ufs_remove(void *);
int	 ufs_rename(void *);
d90 12
a101 12
int	 ufs_rmdir(void *);
int	 ufs_seek(void *);
int	 ufs_select(void *);
int	 ufs_kqfilter(void *);
int	 ufs_setattr(void *);
int	 ufs_strategy(void *);
int	 ufs_symlink(void *);
int	 ufs_unlock(void *);
int	 ufs_whiteout(void *);
int	 ufsspec_close(void *);
int	 ufsspec_read(void *);
int	 ufsspec_write(void *);
d104 3
a106 3
int	ufsfifo_read(void *);
int	ufsfifo_write(void *);
int	ufsfifo_close(void *);
d110 3
a112 3
int ufs_bmaparray(struct vnode *, daddr_t, daddr_t *, struct indir *,
		       int *, int *);
int ufs_getlbns(struct vnode *, daddr_t, struct indir *, int *);
d115 5
a119 5
void ufs_ihashinit(void);
struct vnode *ufs_ihashlookup(dev_t, ino_t);
struct vnode *ufs_ihashget(dev_t, ino_t);
int ufs_ihashins(struct inode *);
void ufs_ihashrem(struct inode *);
d122 2
a123 2
int ufs_init(struct vfsconf *);
int ufs_reclaim(struct vnode *, struct proc *);
d126 11
a136 11
void ufs_dirbad(struct inode *, doff_t, char *);
int ufs_dirbadentry(struct vnode *, struct direct *, int);
void ufs_makedirentry(struct inode *, struct componentname *,
			   struct direct *);
int ufs_direnter(struct vnode *, struct vnode *, struct direct *,
		      struct componentname *, struct buf *);
int ufs_dirremove(struct vnode *, struct inode *, int, int);
int ufs_dirrewrite(struct inode *, struct inode *,
		        ino_t, int, int);
int ufs_dirempty(struct inode *, ino_t, struct ucred *);
int ufs_checkpath(struct inode *, struct inode *, struct ucred *);
d139 6
a144 6
int ufs_start(struct mount *, int, struct proc *);
int ufs_root(struct mount *, struct vnode **);
int ufs_quotactl(struct mount *, int, uid_t, caddr_t, struct proc *);
int ufs_fhtovp(struct mount *, struct ufid *, struct vnode **);
int ufs_check_export(struct mount *, struct mbuf *, int *,
		struct ucred **);
d147 4
a150 4
int ufs_vinit(struct mount *, int (**)(void *),
	      int (**)(void *), struct vnode **);
int ufs_makeinode(int, struct vnode *, struct vnode **,
		  struct componentname *);
d156 10
a165 10
void  softdep_setup_directory_add(struct buf *, struct inode *, off_t,
          long, struct buf *);
void  softdep_change_directoryentry_offset(struct inode *, caddr_t,
          caddr_t, caddr_t, int);
void  softdep_setup_remove(struct buf *,struct inode *, struct inode *,
          int);
void  softdep_setup_directory_change(struct buf *, struct inode *,
          struct inode *, long, int);
void  softdep_change_linkcnt(struct inode *);
int   softdep_slowdown(struct vnode *);
@


1.9.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.9.2.4 2002/03/28 14:54:26 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 1
a88 1
int	 ufs_poll(void *);
@


1.9.2.7
log
@Merge with the trunk
@
text
@d152 2
a153 2
int  softdep_setup_directory_add(struct buf *, struct inode *, off_t,
          long, struct buf *, int);
@


1.8
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.7 1998/01/09 20:38:03 csapuntz Exp $	*/
d161 3
a163 2
int ufs_check_export __P((struct mount *, struct ufid *, struct mbuf *,
			  struct vnode **, int *, struct ucred **));
@


1.7
log
@Prevent double insertions into the inode hash queue
Silently allow removal of inodes that aren't on the hash queues
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.6 1997/12/02 17:11:10 csapuntz Exp $	*/
a60 1
int	 ufs_abortop	__P((void *));
d89 1
a89 1
#define  ufs_revoke  vop_revoke
@


1.6
log
@Unlock child temporarily while truncating directory. This prevents
a double locking bug in the soft updates code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.5 1997/11/06 05:59:26 csapuntz Exp $	*/
d118 1
a118 1
void ufs_ihashins __P((struct inode *));
@


1.5
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.4 1997/10/06 20:21:45 deraadt Exp $	*/
d130 1
a130 1
int ufs_direnter __P((struct vnode *, struct direct *,
@


1.4
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_extern.h,v 1.2 1996/02/27 07:21:25 niklas Exp $	*/
d57 1
d90 1
d122 2
a123 2
void ufs_init __P((void));
int ufs_reclaim __P((struct vnode *));
d128 5
a132 5
int ufs_direnter __P((struct inode *, struct vnode *,
		      struct componentname *));
int ufs_direnter2 __P((struct vnode *, struct direct *, struct ucred *,
		       struct proc *));
int ufs_dirremove __P((struct vnode *, struct componentname *));
d134 1
a134 1
			struct componentname *));
d170 15
@


1.3
log
@VFS Lite2 Changes
@
text
@a56 1
struct vfsconf;
a88 1
#define  ufs_revoke  vop_revoke
d120 2
a121 2
int ufs_init __P((struct vfsconf *));
int ufs_reclaim __P((struct vnode *, struct proc *));
d126 5
a130 5
void ufs_makedirentry __P((struct inode *, struct componentname *,
			   struct direct *));
int ufs_direnter __P((struct vnode *, struct direct *,
		      struct componentname *, struct buf *));
int ufs_dirremove __P((struct vnode *, struct inode *, int, int));
d132 1
a132 1
		        ino_t, int, int));
a167 15

 
/*
 * Soft dependency function prototypes.
 */
void  softdep_setup_directory_add __P((struct buf *, struct inode *, off_t,
          long, struct buf *));
void  softdep_change_directoryentry_offset __P((struct inode *, caddr_t,
          caddr_t, caddr_t, int));
void  softdep_setup_remove __P((struct buf *,struct inode *, struct inode *,
          int));
void  softdep_setup_directory_change __P((struct buf *, struct inode *,
          struct inode *, long, int));
void  softdep_increase_linkcnt __P((struct inode *));

@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
d90 1
d122 2
a123 2
void ufs_init __P((void));
int ufs_reclaim __P((struct vnode *));
d128 5
a132 5
int ufs_direnter __P((struct inode *, struct vnode *,
		      struct componentname *));
int ufs_direnter2 __P((struct vnode *, struct direct *, struct ucred *,
		       struct proc *));
int ufs_dirremove __P((struct vnode *, struct componentname *));
d134 1
a134 1
			struct componentname *));
d170 15
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ufs_extern.h,v 1.4 1994/12/14 13:03:58 mycroft Exp $	*/
d40 1
d43 1
d46 1
d53 2
a57 1
struct ufs_args;
d60 10
a69 29
int	 ufs_abortop __P((struct vop_abortop_args *));
int	 ufs_access __P((struct vop_access_args *));
int	 ufs_advlock __P((struct vop_advlock_args *));
int	 ufs_bmap __P((struct vop_bmap_args *));
int	 ufs_check_export __P((struct mount *, struct ufid *, struct mbuf *,
		struct vnode **, int *exflagsp, struct ucred **));
int	 ufs_checkpath __P((struct inode *, struct inode *, struct ucred *));
int	 ufs_close __P((struct vop_close_args *));
int	 ufs_create __P((struct vop_create_args *));
void	 ufs_dirbad __P((struct inode *, doff_t, char *));
int	 ufs_dirbadentry __P((struct vnode *, struct direct *, int));
int	 ufs_dirempty __P((struct inode *, ino_t, struct ucred *));
int	 ufs_direnter __P((struct inode *, struct vnode *,struct componentname *));
int	 ufs_dirremove __P((struct vnode *, struct componentname*));
int	 ufs_dirrewrite
	    __P((struct inode *, struct inode *, struct componentname *));
int	 ufs_getattr __P((struct vop_getattr_args *));
int	 ufs_getlbns __P((struct vnode *, daddr_t, struct indir *, int *));
struct vnode *
	 ufs_ihashget __P((dev_t, ino_t));
void	 ufs_ihashinit __P((void));
void	 ufs_ihashins __P((struct inode *));
struct vnode *
	 ufs_ihashlookup __P((dev_t, ino_t));
void	 ufs_ihashrem __P((struct inode *));
int	 ufs_inactive __P((struct vop_inactive_args *));
int	 ufs_init __P((void));
int	 ufs_ioctl __P((struct vop_ioctl_args *));
int	 ufs_islocked __P((struct vop_islocked_args *));
d71 1
a71 1
int	 lease_check __P((struct vop_lease_args *));
d74 1
a74 1
#define	 ufs_lease_check ((int (*) __P((struct vop_lease_args *)))nullop)
d76 24
a99 30
int	 ufs_link __P((struct vop_link_args *));
int	 ufs_lock __P((struct vop_lock_args *));
int	 ufs_lookup __P((struct vop_lookup_args *));
int	 ufs_makeinode __P((int mode, struct vnode *, struct vnode **, struct componentname *));
int	 ufs_mkdir __P((struct vop_mkdir_args *));
int	 ufs_mknod __P((struct vop_mknod_args *));
int	 ufs_mmap __P((struct vop_mmap_args *));
int	 ufs_open __P((struct vop_open_args *));
int	 ufs_pathconf __P((struct vop_pathconf_args *));
int	 ufs_print __P((struct vop_print_args *));
int	 ufs_readdir __P((struct vop_readdir_args *));
int	 ufs_readlink __P((struct vop_readlink_args *));
int	 ufs_reclaim __P((struct vnode *));
int	 ufs_remove __P((struct vop_remove_args *));
int	 ufs_rename __P((struct vop_rename_args *));
int	 ufs_rmdir __P((struct vop_rmdir_args *));
int	 ufs_root __P((struct mount *, struct vnode **));
int	 ufs_seek __P((struct vop_seek_args *));
int	 ufs_select __P((struct vop_select_args *));
int	 ufs_setattr __P((struct vop_setattr_args *));
int	 ufs_start __P((struct mount *, int, struct proc *));
int	 ufs_strategy __P((struct vop_strategy_args *));
int	 ufs_symlink __P((struct vop_symlink_args *));
int	 ufs_unlock __P((struct vop_unlock_args *));
int	 ufs_whiteout __P((struct vop_whiteout_args *));
int	 ufs_vinit __P((struct mount *,
	    int (**)(), int (**)(), struct vnode **));
int	 ufsspec_close __P((struct vop_close_args *));
int	 ufsspec_read __P((struct vop_read_args *));
int	 ufsspec_write __P((struct vop_write_args *));
d102 3
a104 3
int	ufsfifo_read __P((struct vop_read_args *));
int	ufsfifo_write __P((struct vop_write_args *));
int	ufsfifo_close __P((struct vop_close_args *));
d106 62
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
