head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.39.0.2
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.37.0.4
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.37.0.6
	OPENBSD_5_8_BASE:1.37
	OPENBSD_5_7:1.37.0.2
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.22
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.20
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.18
	OPENBSD_5_0:1.30.0.16
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.14
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.30.0.12
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.30.0.8
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.10
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.6
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.4
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.7.0.12
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.10
	OPENBSD_2_8:1.7.0.8
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.6
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.4
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.38;
commitid	gAjwyca5TfuoJAhn;

1.38
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.37;
commitid	kCz5QgxnxRMKOzNf;

1.37
date	2015.01.09.05.01.57;	author tedu;	state Exp;
branches;
next	1.36;
commitid	KWogeIYA2sxG3IjB;

1.36
date	2014.11.18.10.42.15;	author dlg;	state Exp;
branches;
next	1.35;
commitid	4DOHz2gKfCx7RejS;

1.35
date	2014.10.13.03.46.33;	author guenther;	state Exp;
branches;
next	1.34;
commitid	GfyJFt2AC6kVCsla;

1.34
date	2014.10.13.03.40.42;	author guenther;	state Exp;
branches;
next	1.33;
commitid	B49GZAEORsqk4E0B;

1.33
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2013.12.12.19.00.10;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2013.06.11.16.42.19;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.01.16.39.30;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.03.18.41.44;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2007.03.21.17.29.32;	author thib;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.25.15.01.54;	author sturm;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.14.20.01.50;	author sturm;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.30.14.20.08;	author sturm;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.30.10.35.08;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.11.16.27.52;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.03.20.14.03;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.26.21.22.14;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.20.03.44.06;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.15.20.32.21;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.15;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.12.20.42.08;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.22.20.37.46;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.20.18.40.49;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.22.04.41.38;	author csapuntz;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.11.21.21.23.56;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	99.04.28.09.28.18;	author art;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	97.11.06.05.59.28;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.20.21.48;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.15.27.38;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	97.05.30.08.35.10;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.21.29;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches;
next	;

1.7.4.1
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.7.4.4;

1.7.4.4
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.7.4.5;

1.7.4.5
date	2004.02.19.11.01.43;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@/*	$OpenBSD: ufs_quota.c,v 1.38 2016/03/14 23:08:06 krw Exp $	*/
/*	$NetBSD: ufs_quota.c,v 1.8 1996/02/09 22:36:09 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1990, 1993, 1995
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Robert Elz at The University of Melbourne.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_quota.c	8.5 (Berkeley) 8/19/94
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/malloc.h>
#include <sys/file.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/ktrace.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#include <sys/queue.h>

#include <crypto/siphash.h>

/*
 * The following structure records disk usage for a user or group on a
 * filesystem. There is one allocated for each quota that exists on any
 * filesystem for the current user or group. A cache is kept of recently
 * used entries.
 */
struct dquot {
	LIST_ENTRY(dquot) dq_hash;	/* hash list */
	TAILQ_ENTRY(dquot) dq_freelist;	/* free list */
	u_int16_t dq_flags;		/* flags, see below */
	u_int16_t dq_type;		/* quota type of this dquot */
	u_int32_t dq_cnt;		/* count of active references */
	u_int32_t dq_id;		/* identifier this applies to */
	struct  vnode *dq_vp;           /* file backing this quota */
	struct  ucred  *dq_cred;        /* credentials for writing file */
	struct	dqblk dq_dqb;		/* actual usage & quotas */
};

/*
 * Flag values.
 */
#define	DQ_LOCK		0x01		/* this quota locked (no MODS) */
#define	DQ_WANT		0x02		/* wakeup on unlock */
#define	DQ_MOD		0x04		/* this quota modified since read */
#define	DQ_FAKE		0x08		/* no limits here, just usage */
#define	DQ_BLKS		0x10		/* has been warned about blk limit */
#define	DQ_INODS	0x20		/* has been warned about inode limit */

/*
 * Shorthand notation.
 */
#define	dq_bhardlimit	dq_dqb.dqb_bhardlimit
#define	dq_bsoftlimit	dq_dqb.dqb_bsoftlimit
#define	dq_curblocks	dq_dqb.dqb_curblocks
#define	dq_ihardlimit	dq_dqb.dqb_ihardlimit
#define	dq_isoftlimit	dq_dqb.dqb_isoftlimit
#define	dq_curinodes	dq_dqb.dqb_curinodes
#define	dq_btime	dq_dqb.dqb_btime
#define	dq_itime	dq_dqb.dqb_itime

/*
 * If the system has never checked for a quota for this file, then it is
 * set to NODQUOT.  Once a write attempt is made the inode pointer is set
 * to reference a dquot structure.
 */
#define	NODQUOT		NULL

void	dqref(struct dquot *);
void	dqrele(struct vnode *, struct dquot *);
int	dqsync(struct vnode *, struct dquot *);

#ifdef DIAGNOSTIC
void	chkdquot(struct inode *);
#endif

int	getquota(struct mount *, u_long, int, caddr_t);
int	quotaon(struct proc *, struct mount *, int, caddr_t);
int	setquota(struct mount *, u_long, int, caddr_t);
int	setuse(struct mount *, u_long, int, caddr_t);

int	chkdqchg(struct inode *, long, struct ucred *, int);
int	chkiqchg(struct inode *, long, struct ucred *, int);

int dqget(struct vnode *, u_long, struct ufsmount *, int,
	       struct dquot **);

int     quotaon_vnode(struct vnode *, void *);
int     quotaoff_vnode(struct vnode *, void *);
int     qsync_vnode(struct vnode *, void *);

/*
 * Quota name to error message mapping.
 */
static char *quotatypes[] = INITQFNAMES;

/*
 * Obtain a reference to a dquot.
 */
void
dqref(struct dquot *dq)
{
	dq->dq_cnt++;
}

/*
 * Set up the quotas for an inode.
 *
 * This routine completely defines the semantics of quotas.
 * If other criterion want to be used to establish quotas, the
 * MAXQUOTAS value in quotas.h should be increased, and the
 * additional dquots set up here.
 */
int
getinoquota(struct inode *ip)
{
	struct ufsmount *ump;
	struct vnode *vp = ITOV(ip);
	int error;

	ump = ip->i_ump;
	/*
	 * Set up the user quota based on file uid.
	 * EINVAL means that quotas are not enabled.
	 */
	if (ip->i_dquot[USRQUOTA] == NODQUOT &&
	    (error =
		dqget(vp, DIP(ip, uid), ump, USRQUOTA, &ip->i_dquot[USRQUOTA])) &&
	    error != EINVAL)
		return (error);
	/*
	 * Set up the group quota based on file gid.
	 * EINVAL means that quotas are not enabled.
	 */
	if (ip->i_dquot[GRPQUOTA] == NODQUOT &&
	    (error =
		dqget(vp, DIP(ip, gid), ump, GRPQUOTA, &ip->i_dquot[GRPQUOTA])) &&
	    error != EINVAL)
		return (error);
	return (0);
}

/*
 * Update disk usage, and take corrective action.
 */
int 
ufs_quota_alloc_blocks2(struct inode *ip, daddr_t change,
    struct ucred *cred, enum ufs_quota_flags flags)
{
	struct dquot *dq;
	int i;
	int error;

#ifdef DIAGNOSTIC
	chkdquot(ip);
#endif

	if (change == 0)
		return (0);

	if ((flags & UFS_QUOTA_FORCE) == 0 && 
	    (cred != NOCRED && cred->cr_uid != 0)) {
		for (i = 0; i < MAXQUOTAS; i++) {
			if (flags & (1 << i)) 
				continue;
			if ((dq = ip->i_dquot[i]) == NODQUOT)
				continue;
			if ((error = chkdqchg(ip, change, cred, i)) != 0)
				return (error);
		}
	}
	for (i = 0; i < MAXQUOTAS; i++) {
		if (flags & (1 << i))
			continue;
		if ((dq = ip->i_dquot[i]) == NODQUOT)
			continue;
		while (dq->dq_flags & DQ_LOCK) {
			dq->dq_flags |= DQ_WANT;
			(void) tsleep(dq, PINOD+1, "chkdq", 0);
		}
		dq->dq_curblocks += change;
		dq->dq_flags |= DQ_MOD;
	}
	return (0);
}

int
ufs_quota_free_blocks2(struct inode *ip, daddr_t change,
    struct ucred *cred, enum ufs_quota_flags flags)
{
	struct dquot *dq;
	int i;

#ifdef DIAGNOSTIC
	if (!VOP_ISLOCKED(ITOV(ip))) 
		panic ("ufs_quota_free_blocks2: vnode is not locked");
#endif

	if (change == 0) 
		return (0);

	for (i = 0; i < MAXQUOTAS; i++) {
		if (flags & (1 << i))
			continue;
		if ((dq = ip->i_dquot[i]) == NODQUOT)
			continue;
		while (dq->dq_flags & DQ_LOCK) {
			dq->dq_flags |= DQ_WANT;
			(void) tsleep(dq, PINOD+1, "chkdq", 0);
		}
		if (dq->dq_curblocks >= change)
			dq->dq_curblocks -= change;
		else
			dq->dq_curblocks = 0;
		dq->dq_flags &= ~DQ_BLKS;
		dq->dq_flags |= DQ_MOD;
	}
	return (0);
}

/*
 * Check for a valid change to a users allocation.
 * Issue an error message if appropriate.
 */
int
chkdqchg(struct inode *ip, long change, struct ucred *cred, int type)
{
	struct dquot *dq = ip->i_dquot[type];
	long ncurblocks = dq->dq_curblocks + change;

	/*
	 * If user would exceed their hard limit, disallow space allocation.
	 */
	if (ncurblocks >= dq->dq_bhardlimit && dq->dq_bhardlimit) {
		if ((dq->dq_flags & DQ_BLKS) == 0 &&
		    DIP(ip, uid) == cred->cr_uid) {
			uprintf("\n%s: write failed, %s disk limit reached\n",
			    ITOV(ip)->v_mount->mnt_stat.f_mntonname,
			    quotatypes[type]);
			dq->dq_flags |= DQ_BLKS;
		}
		return (EDQUOT);
	}
	/*
	 * If user is over their soft limit for too long, disallow space
	 * allocation. Reset time limit as they cross their soft limit.
	 */
	if (ncurblocks >= dq->dq_bsoftlimit && dq->dq_bsoftlimit) {
		if (dq->dq_curblocks < dq->dq_bsoftlimit) {
			dq->dq_btime = time_second +
			    ip->i_ump->um_btime[type];
			if (DIP(ip, uid) == cred->cr_uid)
				uprintf("\n%s: warning, %s %s\n",
				    ITOV(ip)->v_mount->mnt_stat.f_mntonname,
				    quotatypes[type], "disk quota exceeded");
			return (0);
		}
		if (time_second > dq->dq_btime) {
			if ((dq->dq_flags & DQ_BLKS) == 0 &&
			    DIP(ip, uid) == cred->cr_uid) {
				uprintf("\n%s: write failed, %s %s\n",
				    ITOV(ip)->v_mount->mnt_stat.f_mntonname,
				    quotatypes[type],
				    "disk quota exceeded for too long");
				dq->dq_flags |= DQ_BLKS;
			}
			return (EDQUOT);
		}
	}
	return (0);
}

/*
 * Check the inode limit, applying corrective action.
 */
int
ufs_quota_alloc_inode2(struct inode *ip, struct ucred *cred,
    enum ufs_quota_flags flags)
{
	struct dquot *dq;
	int i;
	int error;

#ifdef DIAGNOSTIC
	chkdquot(ip);
#endif

	if ((flags & UFS_QUOTA_FORCE) == 0 && cred->cr_uid != 0) {
		for (i = 0; i < MAXQUOTAS; i++) {
			if (flags & (1 << i)) 
				continue;
			if ((dq = ip->i_dquot[i]) == NODQUOT)
				continue;
			if ((error = chkiqchg(ip, 1, cred, i)) != 0)
				return (error);
		}
	}
	for (i = 0; i < MAXQUOTAS; i++) {
		if (flags & (1 << i)) 
			continue;
		if ((dq = ip->i_dquot[i]) == NODQUOT)
			continue;
		while (dq->dq_flags & DQ_LOCK) {
			dq->dq_flags |= DQ_WANT;
			(void) tsleep(dq, PINOD+1, "chkiq", 0);
		}
		dq->dq_curinodes++;
		dq->dq_flags |= DQ_MOD;
	}
	return (0);
}

int
ufs_quota_free_inode2(struct inode *ip, struct ucred *cred,
    enum ufs_quota_flags flags)
{
	struct dquot *dq;
	int i;

#ifdef DIAGNOSTIC
	if (!VOP_ISLOCKED(ITOV(ip))) 
		panic ("ufs_quota_free_blocks2: vnode is not locked");
#endif

	for (i = 0; i < MAXQUOTAS; i++) {
		if (flags & (1 << i)) 
			continue;
		if ((dq = ip->i_dquot[i]) == NODQUOT)
			continue;
		while (dq->dq_flags & DQ_LOCK) {
			dq->dq_flags |= DQ_WANT;
			(void) tsleep(dq, PINOD+1, "chkiq", 0);
		}
		if (dq->dq_curinodes > 0)
			dq->dq_curinodes--;
		dq->dq_flags &= ~DQ_INODS;
		dq->dq_flags |= DQ_MOD;
	}
	return (0);
}

/*
 * Check for a valid change to a users allocation.
 * Issue an error message if appropriate.
 */
int
chkiqchg(struct inode *ip, long change, struct ucred *cred, int type)
{
	struct dquot *dq = ip->i_dquot[type];
	long ncurinodes = dq->dq_curinodes + change;

	/*
	 * If user would exceed their hard limit, disallow inode allocation.
	 */
	if (ncurinodes >= dq->dq_ihardlimit && dq->dq_ihardlimit) {
		if ((dq->dq_flags & DQ_INODS) == 0 &&
		    DIP(ip, uid) == cred->cr_uid) {
			uprintf("\n%s: write failed, %s inode limit reached\n",
			    ITOV(ip)->v_mount->mnt_stat.f_mntonname,
			    quotatypes[type]);
			dq->dq_flags |= DQ_INODS;
		}
		return (EDQUOT);
	}
	/*
	 * If user is over their soft limit for too long, disallow inode
	 * allocation. Reset time limit as they cross their soft limit.
	 */
	if (ncurinodes >= dq->dq_isoftlimit && dq->dq_isoftlimit) {
		if (dq->dq_curinodes < dq->dq_isoftlimit) {
			dq->dq_itime = time_second +
			    ip->i_ump->um_itime[type];
			if (DIP(ip, uid) == cred->cr_uid)
				uprintf("\n%s: warning, %s %s\n",
				    ITOV(ip)->v_mount->mnt_stat.f_mntonname,
				    quotatypes[type], "inode quota exceeded");
			return (0);
		}
		if (time_second > dq->dq_itime) {
			if ((dq->dq_flags & DQ_INODS) == 0 &&
			    DIP(ip, uid) == cred->cr_uid) {
				uprintf("\n%s: write failed, %s %s\n",
				    ITOV(ip)->v_mount->mnt_stat.f_mntonname,
				    quotatypes[type],
				    "inode quota exceeded for too long");
				dq->dq_flags |= DQ_INODS;
			}
			return (EDQUOT);
		}
	}
	return (0);
}

#ifdef DIAGNOSTIC
/*
 * On filesystems with quotas enabled, it is an error for a file to change
 * size and not to have a dquot structure associated with it.
 */
void
chkdquot(struct inode *ip)
{
	struct ufsmount *ump = ip->i_ump;
	int i;
	struct vnode *vp = ITOV(ip);

	if (!VOP_ISLOCKED(vp)) 
		panic ("chkdquot: vnode is not locked");
		
	for (i = 0; i < MAXQUOTAS; i++) {
		if (ump->um_quotas[i] == NULLVP ||
		    (ump->um_qflags[i] & (QTF_OPENING|QTF_CLOSING)))
			continue;
		if (ip->i_dquot[i] == NODQUOT) {
			vprint("chkdquot: missing dquot", ITOV(ip));
			panic("missing dquot");
		}
	}
}
#endif

/*
 * Code to process quotactl commands.
 */

int
quotaon_vnode(struct vnode *vp, void *arg) 
{
	int error;
	struct proc *p = (struct proc *)arg;

	if (vp->v_type == VNON || vp->v_writecount == 0)
		return (0);

	if (vget(vp, LK_EXCLUSIVE, p)) {
		return (0);
	}

	error = getinoquota(VTOI(vp));
	vput(vp);
	
	return (error);
}

/*
 * Q_QUOTAON - set up a quota file for a particular file system.
 */
int
quotaon(struct proc *p, struct mount *mp, int type, caddr_t fname)
{
	struct ufsmount *ump = VFSTOUFS(mp);
	struct vnode *vp, **vpp;
	struct dquot *dq;
	int error;
	struct nameidata nd;

#ifdef DIAGNOSTIC
	if (!vfs_isbusy(mp))
		panic ("quotaon: mount point not busy");
#endif

	vpp = &ump->um_quotas[type];
	NDINIT(&nd, LOOKUP, FOLLOW, UIO_USERSPACE, fname, p);
	if ((error = vn_open(&nd, FREAD|FWRITE, 0)) != 0)
		return (error);
	vp = nd.ni_vp;
	VOP_UNLOCK(vp, p);
	if (vp->v_type != VREG) {
		(void) vn_close(vp, FREAD|FWRITE, p->p_ucred, p);
		return (EACCES);
	}

	/*
	 * Update the vnode and ucred for quota file updates
	 */
	if (*vpp != vp) {
		quotaoff(p, mp, type);
		*vpp = vp;
		crhold(p->p_ucred);
		ump->um_cred[type] = p->p_ucred;
	} else {
		struct ucred *ocred = ump->um_cred[type];

		(void) vn_close(vp, FREAD|FWRITE, ocred, p);
		if (ocred != p->p_ucred) {
			crhold(p->p_ucred);
			ump->um_cred[type] = p->p_ucred;
			crfree(ocred);
		}
	}

	ump->um_qflags[type] |= QTF_OPENING;
	mp->mnt_flag |= MNT_QUOTA;
	vp->v_flag |= VSYSTEM;
	/*
	 * Set up the time limits for this quota.
	 */
	ump->um_btime[type] = MAX_DQ_TIME;
	ump->um_itime[type] = MAX_IQ_TIME;
	if (dqget(NULLVP, 0, ump, type, &dq) == 0) {
		if (dq->dq_btime > 0)
			ump->um_btime[type] = dq->dq_btime;
		if (dq->dq_itime > 0)
			ump->um_itime[type] = dq->dq_itime;
		dqrele(NULLVP, dq);
	}
	/*
	 * Search vnodes associated with this mount point,
	 * adding references to quota file being opened.
	 * NB: only need to add dquot's for inodes being modified.
	 */
	error = vfs_mount_foreach_vnode(mp, quotaon_vnode, p);

	ump->um_qflags[type] &= ~QTF_OPENING;
	if (error)
		quotaoff(p, mp, type);
	return (error);
}

struct quotaoff_arg {
	struct proc *p;
	int type;
};

int
quotaoff_vnode(struct vnode *vp, void *arg) 
{
	struct quotaoff_arg *qa = (struct quotaoff_arg *)arg;
	struct inode *ip;
	struct dquot *dq;

	if (vp->v_type == VNON)
		return (0);


	if (vget(vp, LK_EXCLUSIVE, qa->p))
		return (0);
	ip = VTOI(vp);
	dq = ip->i_dquot[qa->type];
	ip->i_dquot[qa->type] = NODQUOT;
	dqrele(vp, dq);
	vput(vp);
	return (0);
}

/*
 * Q_QUOTAOFF - turn off disk quotas for a filesystem.
 */
int
quotaoff(struct proc *p, struct mount *mp, int type)
{
	struct vnode *qvp;
	struct ufsmount *ump = VFSTOUFS(mp);
	struct quotaoff_arg qa;
	int error;
	
#ifdef DIAGNOSTIC
	if (!vfs_isbusy(mp))
		panic ("quotaoff: mount point not busy");
#endif
	if ((qvp = ump->um_quotas[type]) == NULLVP)
		return (0);
	ump->um_qflags[type] |= QTF_CLOSING;
	/*
	 * Search vnodes associated with this mount point,
	 * deleting any references to quota file being closed.
	 */
	qa.p = p;
	qa.type = type;
	vfs_mount_foreach_vnode(mp, quotaoff_vnode, &qa);

	error = vn_close(qvp, FREAD|FWRITE, p->p_ucred, p);
	ump->um_quotas[type] = NULLVP;
	crfree(ump->um_cred[type]);
	ump->um_cred[type] = NOCRED;
	ump->um_qflags[type] &= ~QTF_CLOSING;
	for (type = 0; type < MAXQUOTAS; type++)
		if (ump->um_quotas[type] != NULLVP)
			break;
	if (type == MAXQUOTAS)
		mp->mnt_flag &= ~MNT_QUOTA;
	return (error);
}

/*
 * Q_GETQUOTA - return current values in a dqblk structure.
 */
int
getquota(struct mount *mp, u_long id, int type, caddr_t addr)
{
	struct dquot *dq;
	int error;

	if ((error = dqget(NULLVP, id, VFSTOUFS(mp), type, &dq)) != 0)
		return (error);
	error = copyout((caddr_t)&dq->dq_dqb, addr, sizeof (struct dqblk));
#ifdef KTRACE
	if (error == 0) {
		struct proc *p = curproc;
		if (KTRPOINT(p, KTR_STRUCT))
			ktrquota(p, &dq->dq_dqb);
	}
#endif

	dqrele(NULLVP, dq);
	return (error);
}

/*
 * Q_SETQUOTA - assign an entire dqblk structure.
 */
int
setquota(struct mount *mp, u_long id, int type, caddr_t addr)
{
	struct dquot *dq;
	struct dquot *ndq;
	struct ufsmount *ump = VFSTOUFS(mp);
	struct dqblk newlim;
	int error;

	error = copyin(addr, (caddr_t)&newlim, sizeof (struct dqblk));
	if (error)
		return (error);
#ifdef KTRACE
	{
		struct proc *p = curproc;
		if (KTRPOINT(p, KTR_STRUCT))
			ktrquota(p, &newlim);
	}
#endif

	if ((error = dqget(NULLVP, id, ump, type, &ndq)) != 0)
		return (error);
	dq = ndq;
	while (dq->dq_flags & DQ_LOCK) {
		dq->dq_flags |= DQ_WANT;
		(void) tsleep(dq, PINOD+1, "setquota", 0);
	}
	/*
	 * Copy all but the current values.
	 * Reset time limit if previously had no soft limit or were
	 * under it, but now have a soft limit and are over it.
	 */
	newlim.dqb_curblocks = dq->dq_curblocks;
	newlim.dqb_curinodes = dq->dq_curinodes;
	if (dq->dq_id != 0) {
		newlim.dqb_btime = dq->dq_btime;
		newlim.dqb_itime = dq->dq_itime;
	}
	if (newlim.dqb_bsoftlimit &&
	    dq->dq_curblocks >= newlim.dqb_bsoftlimit &&
	    (dq->dq_bsoftlimit == 0 || dq->dq_curblocks < dq->dq_bsoftlimit))
		newlim.dqb_btime = time_second + ump->um_btime[type];
	if (newlim.dqb_isoftlimit &&
	    dq->dq_curinodes >= newlim.dqb_isoftlimit &&
	    (dq->dq_isoftlimit == 0 || dq->dq_curinodes < dq->dq_isoftlimit))
		newlim.dqb_itime = time_second + ump->um_itime[type];
	dq->dq_dqb = newlim;
	if (dq->dq_curblocks < dq->dq_bsoftlimit)
		dq->dq_flags &= ~DQ_BLKS;
	if (dq->dq_curinodes < dq->dq_isoftlimit)
		dq->dq_flags &= ~DQ_INODS;
	if (dq->dq_isoftlimit == 0 && dq->dq_bsoftlimit == 0 &&
	    dq->dq_ihardlimit == 0 && dq->dq_bhardlimit == 0)
		dq->dq_flags |= DQ_FAKE;
	else
		dq->dq_flags &= ~DQ_FAKE;
	dq->dq_flags |= DQ_MOD;
	dqrele(NULLVP, dq);
	return (0);
}

/*
 * Q_SETUSE - set current inode and block usage.
 */
int
setuse(struct mount *mp, u_long id, int type, caddr_t addr)
{
	struct dquot *dq;
	struct ufsmount *ump = VFSTOUFS(mp);
	struct dquot *ndq;
	struct dqblk usage;
	int error;

	error = copyin(addr, (caddr_t)&usage, sizeof (struct dqblk));
	if (error)
		return (error);
#ifdef KTRACE
	{
		struct proc *p = curproc;
		if (KTRPOINT(p, KTR_STRUCT))
			ktrquota(p, &usage);
	}
#endif

	if ((error = dqget(NULLVP, id, ump, type, &ndq)) != 0)
		return (error);
	dq = ndq;
	while (dq->dq_flags & DQ_LOCK) {
		dq->dq_flags |= DQ_WANT;
		(void) tsleep(dq, PINOD+1, "setuse", 0);
	}
	/*
	 * Reset time limit if have a soft limit and were
	 * previously under it, but are now over it.
	 */
	if (dq->dq_bsoftlimit && dq->dq_curblocks < dq->dq_bsoftlimit &&
	    usage.dqb_curblocks >= dq->dq_bsoftlimit)
		dq->dq_btime = time_second + ump->um_btime[type];
	if (dq->dq_isoftlimit && dq->dq_curinodes < dq->dq_isoftlimit &&
	    usage.dqb_curinodes >= dq->dq_isoftlimit)
		dq->dq_itime = time_second + ump->um_itime[type];
	dq->dq_curblocks = usage.dqb_curblocks;
	dq->dq_curinodes = usage.dqb_curinodes;
	if (dq->dq_curblocks < dq->dq_bsoftlimit)
		dq->dq_flags &= ~DQ_BLKS;
	if (dq->dq_curinodes < dq->dq_isoftlimit)
		dq->dq_flags &= ~DQ_INODS;
	dq->dq_flags |= DQ_MOD;
	dqrele(NULLVP, dq);
	return (0);
}

int
qsync_vnode(struct vnode *vp, void *arg)
{
	int i;
	struct proc *p = curproc;
	struct dquot *dq;
	    
	if (vp->v_type == VNON)
		return (0);

	if (vget(vp, LK_EXCLUSIVE | LK_NOWAIT, p))
		return (0);

	for (i = 0; i < MAXQUOTAS; i++) {
		dq = VTOI(vp)->i_dquot[i];
		if (dq != NODQUOT && (dq->dq_flags & DQ_MOD))
			dqsync(vp, dq);
	}
	vput(vp);
	return (0);
}

/*
 * Q_SYNC - sync quota files to disk.
 */
int
qsync(struct mount *mp)
{
	struct ufsmount *ump = VFSTOUFS(mp);
	int i;

	/*
	 * Check if the mount point has any quotas.
	 * If not, simply return.
	 */
	for (i = 0; i < MAXQUOTAS; i++)
		if (ump->um_quotas[i] != NULLVP)
			break;
	if (i == MAXQUOTAS)
		return (0);
	/*
	 * Search vnodes associated with this mount point,
	 * synchronizing any modified dquot structures.
	 */
	vfs_mount_foreach_vnode(mp, qsync_vnode, NULL);
	return (0);
}

/*
 * Code pertaining to management of the in-core dquot data structures.
 */
LIST_HEAD(dqhash, dquot) *dqhashtbl;
SIPHASH_KEY dqhashkey;
u_long dqhash;

/*
 * Dquot free list.
 */
#define	DQUOTINC	5	/* minimum free dquots desired */
TAILQ_HEAD(dqfreelist, dquot) dqfreelist;
long numdquot, desireddquot = DQUOTINC;

/*
 * Initialize the quota system.
 */
void
ufs_quota_init(void)
{
	dqhashtbl = hashinit(initialvnodes, M_DQUOT, M_WAITOK, &dqhash);
	arc4random_buf(&dqhashkey, sizeof(dqhashkey));
	TAILQ_INIT(&dqfreelist);
}

/*
 * Obtain a dquot structure for the specified identifier and quota file
 * reading the information from the file if necessary.
 */
int
dqget(struct vnode *vp, u_long id, struct ufsmount *ump, int type,
    struct dquot **dqp)
{
	SIPHASH_CTX ctx;
	struct proc *p = curproc;
	struct dquot *dq;
	struct dqhash *dqh;
	struct vnode *dqvp;
	struct iovec aiov;
	struct uio auio;
	int error;

	dqvp = ump->um_quotas[type];
	if (dqvp == NULLVP || (ump->um_qflags[type] & QTF_CLOSING)) {
		*dqp = NODQUOT;
		return (EINVAL);
	}
	/*
	 * Check the cache first.
	 */
	SipHash24_Init(&ctx, &dqhashkey);
	SipHash24_Update(&ctx, &dqvp, sizeof(dqvp));
	SipHash24_Update(&ctx, &id, sizeof(id));
	dqh = &dqhashtbl[SipHash24_End(&ctx) & dqhash];

	LIST_FOREACH(dq, dqh, dq_hash) {
		if (dq->dq_id != id ||
		    dq->dq_vp != dqvp)
			continue;
		/*
		 * Cache hit with no references.  Take
		 * the structure off the free list.
		 */
		if (dq->dq_cnt == 0)
			TAILQ_REMOVE(&dqfreelist, dq, dq_freelist);
		dqref(dq);
		*dqp = dq;
		return (0);
	}
	/*
	 * Not in cache, allocate a new one.
	 */
	if (TAILQ_FIRST(&dqfreelist) == NODQUOT &&
	    numdquot < MAXQUOTAS * initialvnodes)
		desireddquot += DQUOTINC;
	if (numdquot < desireddquot) {
		dq = malloc(sizeof *dq, M_DQUOT, M_WAITOK | M_ZERO);
		numdquot++;
	} else {
		if ((dq = TAILQ_FIRST(&dqfreelist)) == NULL) {
			tablefull("dquot");
			*dqp = NODQUOT;
			return (EUSERS);
		}
		if (dq->dq_cnt || (dq->dq_flags & DQ_MOD))
			panic("free dquot isn't");
		TAILQ_REMOVE(&dqfreelist, dq, dq_freelist);
		LIST_REMOVE(dq, dq_hash);
		crfree(dq->dq_cred);
		dq->dq_cred = NOCRED;
	}
	/*
	 * Initialize the contents of the dquot structure.
	 */
	if (vp != dqvp)
		vn_lock(dqvp, LK_EXCLUSIVE | LK_RETRY, p);
	LIST_INSERT_HEAD(dqh, dq, dq_hash);
	dqref(dq);
	dq->dq_flags = DQ_LOCK;
	dq->dq_id = id;
	dq->dq_vp = dqvp;
	dq->dq_type = type;
	crhold(ump->um_cred[type]);
	dq->dq_cred = ump->um_cred[type];
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	aiov.iov_base = (caddr_t)&dq->dq_dqb;
	aiov.iov_len = sizeof (struct dqblk);
	auio.uio_resid = sizeof (struct dqblk);
	auio.uio_offset = (off_t)(id * sizeof (struct dqblk));
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_rw = UIO_READ;
	auio.uio_procp = NULL;
	error = VOP_READ(dqvp, &auio, 0, dq->dq_cred);
	if (auio.uio_resid == sizeof(struct dqblk) && error == 0)
		memset(&dq->dq_dqb, 0, sizeof(struct dqblk));
	if (vp != dqvp)
		VOP_UNLOCK(dqvp, p);
	if (dq->dq_flags & DQ_WANT)
		wakeup(dq);
	dq->dq_flags = 0;
	/*
	 * I/O error in reading quota file, release
	 * quota structure and reflect problem to caller.
	 */
	if (error) {
		LIST_REMOVE(dq, dq_hash);
		dqrele(vp, dq);
		*dqp = NODQUOT;
		return (error);
	}
	/*
	 * Check for no limit to enforce.
	 * Initialize time values if necessary.
	 */
	if (dq->dq_isoftlimit == 0 && dq->dq_bsoftlimit == 0 &&
	    dq->dq_ihardlimit == 0 && dq->dq_bhardlimit == 0)
		dq->dq_flags |= DQ_FAKE;
	if (dq->dq_id != 0) {
		if (dq->dq_btime == 0)
			dq->dq_btime = time_second + ump->um_btime[type];
		if (dq->dq_itime == 0)
			dq->dq_itime = time_second + ump->um_itime[type];
	}
	*dqp = dq;
	return (0);
}

/*
 * Release a reference to a dquot.
 */
void
dqrele(struct vnode *vp, struct dquot *dq)
{

	if (dq == NODQUOT)
		return;
	if (dq->dq_cnt > 1) {
		dq->dq_cnt--;
		return;
	}
	if (dq->dq_flags & DQ_MOD)
		(void) dqsync(vp, dq);
	if (--dq->dq_cnt > 0)
		return;
	TAILQ_INSERT_TAIL(&dqfreelist, dq, dq_freelist);
}

/*
 * Update the disk quota in the quota file.
 */
int
dqsync(struct vnode *vp, struct dquot *dq)
{
	struct proc *p = curproc;
	struct vnode *dqvp;
	struct iovec aiov;
	struct uio auio;
	int error;

	if (dq == NODQUOT)
		panic("dqsync: dquot");
	if ((dq->dq_flags & DQ_MOD) == 0)
		return (0);
	if ((dqvp = dq->dq_vp) == NULLVP)
		panic("dqsync: file");

	if (vp != dqvp)
		vn_lock(dqvp, LK_EXCLUSIVE | LK_RETRY, p);
	while (dq->dq_flags & DQ_LOCK) {
		dq->dq_flags |= DQ_WANT;
		(void) tsleep(dq, PINOD+2, "dqsync", 0);
		if ((dq->dq_flags & DQ_MOD) == 0) {
			if (vp != dqvp)
				VOP_UNLOCK(dqvp, p);
			return (0);
		}
	}
	dq->dq_flags |= DQ_LOCK;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	aiov.iov_base = (caddr_t)&dq->dq_dqb;
	aiov.iov_len = sizeof (struct dqblk);
	auio.uio_resid = sizeof (struct dqblk);
	auio.uio_offset = (off_t)(dq->dq_id * sizeof (struct dqblk));
	auio.uio_segflg = UIO_SYSSPACE;
	auio.uio_rw = UIO_WRITE;
	auio.uio_procp = NULL;
	error = VOP_WRITE(dqvp, &auio, 0, dq->dq_cred);
	if (auio.uio_resid && error == 0)
		error = EIO;
	if (dq->dq_flags & DQ_WANT)
		wakeup(dq);
	dq->dq_flags &= ~(DQ_MOD|DQ_LOCK|DQ_WANT);
	if (vp != dqvp)
		VOP_UNLOCK(dqvp, p);
	return (error);
}

int
ufs_quota_delete(struct inode *ip)
{
	struct vnode *vp = ITOV(ip);
	int i;
	for (i = 0; i < MAXQUOTAS; i++) {
		if (ip->i_dquot[i] != NODQUOT) {
			dqrele(vp, ip->i_dquot[i]);
			ip->i_dquot[i] = NODQUOT;
		}
	}

	return (0);
}

/*
 * Do operations associated with quotas
 */
int
ufs_quotactl(struct mount *mp, int cmds, uid_t uid, caddr_t arg,
    struct proc *p)
{
	int cmd, type, error;

	if (uid == -1)
		uid = p->p_ucred->cr_ruid;
	cmd = cmds >> SUBCMDSHIFT;

	switch (cmd) {
	case Q_SYNC:
		break;
	case Q_GETQUOTA:
		if (uid == p->p_ucred->cr_ruid)
			break;
		/* FALLTHROUGH */
	default:
		if ((error = suser(p, 0)) != 0)
			return (error);
	}

	type = cmds & SUBCMDMASK;
	if ((u_int)type >= MAXQUOTAS)
		return (EINVAL);

	if (vfs_busy(mp, VB_READ|VB_NOWAIT))
		return (0);
 

	switch (cmd) {

	case Q_QUOTAON:
		error = quotaon(p, mp, type, arg);
		break;

	case Q_QUOTAOFF:
		error = quotaoff(p, mp, type);
		break;

	case Q_SETQUOTA:
		error = setquota(mp, uid, type, arg) ;
		break;

	case Q_SETUSE:
		error = setuse(mp, uid, type, arg);
		break;

	case Q_GETQUOTA:
		error = getquota(mp, uid, type, arg);
		break;

	case Q_SYNC:
		error = qsync(mp);
		break;

	default:
		error = EINVAL;
		break;
	}

	vfs_unbusy(mp);
	return (error);
}
@


1.38
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.37 2015/01/09 05:01:57 tedu Exp $	*/
d502 1
a502 1
	VOP_UNLOCK(vp, 0, p);
d924 1
a924 1
		VOP_UNLOCK(dqvp, 0, p);
d1001 1
a1001 1
				VOP_UNLOCK(dqvp, 0, p);
d1022 1
a1022 1
		VOP_UNLOCK(dqvp, 0, p);
@


1.37
log
@rename desiredvnodes to initialvnodes. less of a lie. ok beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.36 2014/11/18 10:42:15 dlg Exp $	*/
d919 1
a919 1
	auio.uio_procp = (struct proc *)0;
d1014 1
a1014 1
	auio.uio_procp = (struct proc *)0;
@


1.36
log
@use siphash for key lookups in all the filesystem hashes.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.35 2014/10/13 03:46:33 guenther Exp $	*/
d827 1
a827 1
	dqhashtbl = hashinit(desiredvnodes, M_DQUOT, M_WAITOK, &dqhash);
d880 1
a880 1
	    numdquot < MAXQUOTAS * desiredvnodes)
@


1.35
log
@Add dumping of struct dqblk done by quotactl(2)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.34 2014/10/13 03:40:42 guenther Exp $	*/
d56 2
a809 2
#define DQHASH(dqvp, id) \
	(&dqhashtbl[((((long)(dqvp)) >> 8) + id) & dqhash])
d811 1
d828 1
d840 1
d857 5
a861 1
	dqh = DQHASH(dqvp, id);
@


1.34
log
@Calling quotactl(QCMD(Q_QUOTAON)) twice with the same filesystem,
type, and path shouldn't leak vnode or ucred references.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.33 2014/03/30 21:54:48 guenther Exp $	*/
d47 1
d630 8
d657 8
d721 8
@


1.33
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.32 2013/12/12 19:00:10 tedu Exp $	*/
d504 5
a508 1
	if (*vpp != vp)
d510 14
a526 1
	*vpp = vp;
a527 1
	 * Save the credential of the process that turned on quotas.
a529 2
	crhold(p->p_ucred);
	ump->um_cred[type] = p->p_ucred;
@


1.32
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.31 2013/06/11 16:42:19 deraadt Exp $	*/
d1005 1
a1005 1
		uid = p->p_cred->p_ruid;
d1012 1
a1012 1
		if (uid == p->p_cred->p_ruid)
@


1.31
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.30 2008/01/05 19:49:26 otto Exp $	*/
d876 1
a876 1
		bzero((caddr_t)&dq->dq_dqb, sizeof(struct dqblk));
@


1.30
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.29 2007/10/01 16:39:30 krw Exp $	*/
d180 1
a180 1
ufs_quota_alloc_blocks2(struct inode *ip, daddr64_t change,
d221 1
a221 1
ufs_quota_free_blocks2(struct inode *ip, daddr64_t change,
@


1.29
log
@Last of the really easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'
where obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.28 2007/08/03 18:41:44 millert Exp $	*/
d180 1
a180 1
ufs_quota_alloc_blocks2(struct inode *ip, int32_t change, 
d221 1
a221 1
ufs_quota_free_blocks2(struct inode *ip, int32_t change, 
@


1.28
log
@Increase dq_cnt in struct dquot from 16 to 32bits.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.27 2007/03/21 17:29:32 thib Exp $	*/
d837 1
a837 2
		dq = (struct dquot *)malloc(sizeof *dq, M_DQUOT, M_WAITOK);
		bzero((char *)dq, sizeof *dq);
@


1.27
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.26 2007/02/14 00:53:48 jsg Exp $	*/
a64 2
	u_int16_t dq_cnt;		/* count of active references */
	u_int16_t dq_spare;		/* unused spare padding */
d66 1
@


1.26
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.25 2006/06/25 15:01:54 sturm Exp $	*/
d465 1
a465 2
	if (vp->v_type == VNON || vp->v_writecount == 0) {
		simple_unlock(&vp->v_interlock);
a466 1
	}
d468 1
a468 1
	if (vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, p)) {
d551 1
a551 2
	if (vp->v_type == VNON) {
		simple_unlock(&vp->v_interlock);
a552 1
	}
d554 2
a555 1
	if (vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, qa->p))
d726 1
a726 2
	if (vp->v_type == VNON) {
		simple_unlock(&vp->v_interlock);
a727 1
	}
d729 1
a729 1
	if (vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, p))
@


1.25
log
@rename vfs_busy() flags VB_UMIGNORE/VB_UMWAIT to VB_NOWAIT/VB_WAIT

requested by and ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.24 2006/06/14 20:01:50 sturm Exp $	*/
d1021 1
a1021 1
		/* fall through */
@


1.24
log
@move vfs_busy() to rwlocks and properly hide the locking api from vfs

ok tedu, pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.23 2006/04/30 14:20:08 sturm Exp $	*/
d1031 1
a1031 1
	if (vfs_busy(mp, VB_READ|VB_UMIGNORE))
@


1.23
log
@remove the simplelock argument from vfs_busy() which is currently not
used and will never be used this way in VFS

requested by and ok pedro, ok krw, biorn
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.22 2005/12/28 20:48:18 pedro Exp $	*/
d1031 1
a1031 1
	if (vfs_busy(mp, LK_NOWAIT))
@


1.22
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.21 2005/11/30 10:35:08 pedro Exp $	*/
d1031 1
a1031 1
	if (vfs_busy(mp, LK_NOWAIT, NULL))
@


1.21
log
@No need for vfs_busy() and vfs_unbusy() to take a process pointer
anymore. Testing by jolan@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.20 2005/11/11 16:27:52 pedro Exp $	*/
d162 1
a162 1
		dqget(vp, ip->i_ffs_uid, ump, USRQUOTA, &ip->i_dquot[USRQUOTA])) &&
d171 1
a171 1
		dqget(vp, ip->i_ffs_gid, ump, GRPQUOTA, &ip->i_dquot[GRPQUOTA])) &&
d270 1
a270 1
		    ip->i_ffs_uid == cred->cr_uid) {
d286 1
a286 1
			if (ip->i_ffs_uid == cred->cr_uid)
d294 1
a294 1
			    ip->i_ffs_uid == cred->cr_uid) {
d391 1
a391 1
		    ip->i_ffs_uid == cred->cr_uid) {
d407 1
a407 1
			if (ip->i_ffs_uid == cred->cr_uid)
d415 1
a415 1
			    ip->i_ffs_uid == cred->cr_uid) {
@


1.20
log
@Use ANSI function declarations and deregister, no binary change.
Diff from Rui Reis <rui@@rui.cx>, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.19 2005/07/03 20:14:03 drahn Exp $	*/
d1031 1
a1031 1
	if (vfs_busy(mp, LK_NOWAIT, 0, p))
d1066 1
a1066 1
	vfs_unbusy(mp, p);
@


1.19
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.18 2004/12/26 21:22:14 miod Exp $	*/
d37 1
d73 1
d83 1
d135 1
a135 2
dqref(dq)
	struct dquot *dq;
a136 1

a139 1

d149 1
a149 2
getinoquota(ip)
	struct inode *ip;
d182 2
a183 1
    struct ucred *cred, enum ufs_quota_flags flags) {
d223 2
a224 1
    struct ucred *cred, enum ufs_quota_flags flags) {
d260 1
a260 5
chkdqchg(ip, change, cred, type)
	struct inode *ip;
	long change;
	struct ucred *cred;
	int type;
d312 2
a313 1
    enum ufs_quota_flags flags) {
d349 2
a350 1
    enum ufs_quota_flags flags) {
d381 1
a381 5
chkiqchg(ip, change, cred, type)
	struct inode *ip;
	long change;
	struct ucred *cred;
	int type;
d434 1
a434 2
chkdquot(ip)
	struct inode *ip;
d484 1
a484 5
quotaon(p, mp, type, fname)
	struct proc *p;
	struct mount *mp;
	int type;
	caddr_t fname;
d572 1
a572 4
quotaoff(p, mp, type)
	struct proc *p;
	struct mount *mp;
	int type;
d611 1
a611 5
getquota(mp, id, type, addr)
	struct mount *mp;
	u_long id;
	int type;
	caddr_t addr;
d627 1
a627 5
setquota(mp, id, type, addr)
	struct mount *mp;
	u_long id;
	int type;
	caddr_t addr;
d683 1
a683 5
setuse(mp, id, type, addr)
	struct mount *mp;
	u_long id;
	int type;
	caddr_t addr;
a721 2


d723 2
a724 1
qsync_vnode(struct vnode *vp, void *arg) {
d750 1
a750 2
qsync(mp)
	struct mount *mp;
d791 1
a791 1
ufs_quota_init()
a792 1

d802 2
a803 6
dqget(vp, id, ump, type, dqp)
	struct vnode *vp;
	u_long id;
	struct ufsmount *ump;
	int type;
	struct dquot **dqp;
d920 1
a920 3
dqrele(vp, dq)
	struct vnode *vp;
	struct dquot *dq;
d940 1
a940 3
dqsync(vp, dq)
	struct vnode *vp;
	struct dquot *dq;
d988 2
a989 1
ufs_quota_delete(struct inode *ip) {
d1006 2
a1007 6
ufs_quotactl(mp, cmds, uid, arg, p)
	struct mount *mp;
	int cmds;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
@


1.18
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.17 2004/06/21 23:50:38 tholo Exp $	*/
a46 1
#include <ufs/ufs/extattr.h>
@


1.17
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.16 2004/01/20 03:44:06 tedu Exp $	*/
d855 1
a855 1
	for (dq = dqh->lh_first; dq; dq = dq->dq_hash.le_next) {
d872 1
a872 1
	if (dqfreelist.tqh_first == NODQUOT &&
d880 1
a880 1
		if ((dq = dqfreelist.tqh_first) == NULL) {
@


1.16
log
@some pieces of ufs2.  help testing otto sturm
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.15 2003/08/15 20:32:21 tedu Exp $	*/
d288 1
a288 1
			dq->dq_btime = time.tv_sec +
d296 1
a296 1
		if (time.tv_sec > dq->dq_btime) {
d411 1
a411 1
			dq->dq_itime = time.tv_sec +
d419 1
a419 1
		if (time.tv_sec > dq->dq_itime) {
d681 1
a681 1
		newlim.dqb_btime = time.tv_sec + ump->um_btime[type];
d685 1
a685 1
		newlim.dqb_itime = time.tv_sec + ump->um_itime[type];
d733 1
a733 1
		dq->dq_btime = time.tv_sec + ump->um_btime[type];
d736 1
a736 1
		dq->dq_itime = time.tv_sec + ump->um_itime[type];
d941 1
a941 1
			dq->dq_btime = time.tv_sec + ump->um_btime[type];
d943 1
a943 1
			dq->dq_itime = time.tv_sec + ump->um_itime[type];
@


1.15
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.14 2003/06/02 23:28:23 millert Exp $	*/
d157 1
a157 1
	ump = VFSTOUFS(vp->v_mount);
d289 1
a289 1
			    VFSTOUFS(ITOV(ip)->v_mount)->um_btime[type];
d412 1
a412 1
			    VFSTOUFS(ITOV(ip)->v_mount)->um_itime[type];
d443 1
a443 1
	struct ufsmount *ump = VFSTOUFS(ITOV(ip)->v_mount);
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.13 2002/03/14 01:27:15 millert Exp $	*/
d1063 1
a1063 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.12 2002/03/12 20:42:08 csapuntz Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@Credentials now freed on re-use of dq structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.11 2002/02/22 20:37:46 drahn Exp $	*/
d105 3
a107 3
void	dqref __P((struct dquot *));
void	dqrele __P((struct vnode *, struct dquot *));
int	dqsync __P((struct vnode *, struct dquot *));
d110 1
a110 1
void	chkdquot __P((struct inode *));
d113 4
a116 4
int	getquota __P((struct mount *, u_long, int, caddr_t));
int	quotaon __P((struct proc *, struct mount *, int, caddr_t));
int	setquota __P((struct mount *, u_long, int, caddr_t));
int	setuse __P((struct mount *, u_long, int, caddr_t));
d118 2
a119 2
int	chkdqchg __P((struct inode *, long, struct ucred *, int));
int	chkiqchg __P((struct inode *, long, struct ucred *, int));
d121 2
a122 2
int dqget __P((struct vnode *, u_long, struct ufsmount *, int,
	       struct dquot **));
@


1.11
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.10 2002/02/20 18:40:49 csapuntz Exp $	*/
d893 2
a971 2
	crfree(dq->dq_cred);
	dq->dq_cred = NOCRED;
@


1.10
log
@Don't rely on vp for anything in dqsync as it can be null
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.9 2001/11/22 04:41:38 csapuntz Exp $	*/
d51 1
@


1.9
log
@

Changes to allow two partitions to share a quota file
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.8 2001/11/21 21:23:56 csapuntz Exp $	*/
d73 1
d904 2
d915 1
a915 1
	error = VOP_READ(dqvp, &auio, 0, ump->um_cred[type]);
d969 2
a986 1
	struct ufsmount *ump = VFSTOUFS(vp->v_mount);
d994 1
d1016 1
a1016 1
	error = VOP_WRITE(dqvp, &auio, 0, ump->um_cred[dq->dq_type]);
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.9 2001/11/22 04:41:38 csapuntz Exp $	*/
a50 1
#include <ufs/ufs/extattr.h>
a72 1
	struct  ucred  *dq_cred;        /* credentials for writing file */
d103 3
a105 3
void	dqref(struct dquot *);
void	dqrele(struct vnode *, struct dquot *);
int	dqsync(struct vnode *, struct dquot *);
d108 1
a108 1
void	chkdquot(struct inode *);
d111 4
a114 4
int	getquota(struct mount *, u_long, int, caddr_t);
int	quotaon(struct proc *, struct mount *, int, caddr_t);
int	setquota(struct mount *, u_long, int, caddr_t);
int	setuse(struct mount *, u_long, int, caddr_t);
d116 2
a117 2
int	chkdqchg(struct inode *, long, struct ucred *, int);
int	chkiqchg(struct inode *, long, struct ucred *, int);
d119 2
a120 2
int dqget(struct vnode *, u_long, struct ufsmount *, int,
	       struct dquot **);
a890 2
		crfree(dq->dq_cred);
		dq->dq_cred = NOCRED;
a902 2
	crhold(ump->um_cred[type]);
	dq->dq_cred = ump->um_cred[type];
d912 1
a912 1
	error = VOP_READ(dqvp, &auio, 0, dq->dq_cred);
d982 1
a989 1

d1011 1
a1011 1
	error = VOP_WRITE(dqvp, &auio, 0, dq->dq_cred);
@


1.8
log
@Don't use #define QUOTA - use stub file instead

Pass over the quota code in ufs/. Make code paths clearer. Clean up some names.
Move all code that manipulates quotas directly into ufs_quota.c

Use vfs_mount_foreach_vnode to traverse list of vnodes in mountpoint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.7 1999/04/28 09:28:18 art Exp $	*/
d72 1
a72 1
	struct	ufsmount *dq_ump;	/* filesystem that this is taken from */
a102 9
/*
 * Macros to avoid subroutine calls to trivial functions.
 */
#ifdef DIAGNOSTIC
#define	DQREF(dq)	dqref(dq)
#else
#define	DQREF(dq)	(dq)->dq_cnt++
#endif

a120 1
void	dqflush __P((struct vnode *));
d132 12
a609 2
	dqflush(qvp);
	qvp->v_flag &= ~VSYSTEM;
d859 1
a859 1
		    dq->dq_ump->um_quotas[dq->dq_type] != dqvp)
d867 1
a867 1
		DQREF(dq);
d898 1
a898 1
	DQREF(dq);
d901 1
a901 1
	dq->dq_ump = ump;
a947 11
 * Obtain a reference to a dquot.
 */
void
dqref(dq)
	struct dquot *dq;
{

	dq->dq_cnt++;
}

/*
d982 1
d988 1
a988 1
	if ((dqvp = dq->dq_ump->um_quotas[dq->dq_type]) == NULLVP)
d1011 1
a1011 1
	error = VOP_WRITE(dqvp, &auio, 0, dq->dq_ump->um_cred[dq->dq_type]);
a1019 28
}

/*
 * Flush all entries from the cache for a particular vnode.
 */
void
dqflush(vp)
	struct vnode *vp;
{
	struct dquot *dq, *nextdq;
	struct dqhash *dqh;

	/*
	 * Move all dquot's that used to refer to this quota
	 * file off their hash chains (they will eventually
	 * fall off the head of the free list and be re-used).
	 */
	for (dqh = &dqhashtbl[dqhash]; dqh >= dqhashtbl; dqh--) {
		for (dq = dqh->lh_first; dq; dq = nextdq) {
			nextdq = dq->dq_hash.le_next;
			if (dq->dq_ump->um_quotas[dq->dq_type] != vp)
				continue;
			if (dq->dq_cnt)
				panic("dqflush: stray dquot");
			LIST_REMOVE(dq, dq_hash);
			dq->dq_ump = (struct ufsmount *)0;
		}
	}
@


1.7
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.6 1997/11/06 05:59:28 csapuntz Exp $	*/
d5 1
a5 1
 * Copyright (c) 1982, 1986, 1990, 1993
d39 1
a39 1
 *	@@(#)ufs_quota.c	8.3 (Berkeley) 8/19/94
d56 80
d151 1
a151 1
	register struct inode *ip;
d182 6
a187 10
int
chkdq(ip, change, cred, flags)
	register struct inode *ip;
	long change;
	struct ucred *cred;
	int flags;
{
	register struct dquot *dq;
	register int i;
	int ncurblocks, error;
d190 1
a190 2
	if ((flags & CHOWN) == 0)
		chkdquot(ip);
d192 1
d195 3
a197 1
	if (change < 0) {
d199 1
a199 1
			if ((dq = ip->i_dquot[i]) == NODQUOT)
a200 16
			while (dq->dq_flags & DQ_LOCK) {
				dq->dq_flags |= DQ_WANT;
				sleep((caddr_t)dq, PINOD+1);
			}
			ncurblocks = dq->dq_curblocks + change;
			if (ncurblocks >= 0)
				dq->dq_curblocks = ncurblocks;
			else
				dq->dq_curblocks = 0;
			dq->dq_flags &= ~DQ_BLKS;
			dq->dq_flags |= DQ_MOD;
		}
		return (0);
	}
	if ((flags & FORCE) == 0 && cred->cr_uid != 0) {
		for (i = 0; i < MAXQUOTAS; i++) {
d208 2
d214 1
a214 1
			sleep((caddr_t)dq, PINOD+1);
d222 33
d266 1
a266 1
	register struct dquot *dq = ip->i_dquot[type];
d315 5
a319 9
chkiq(ip, change, cred, flags)
	register struct inode *ip;
	long change;
	struct ucred *cred;
	int flags;
{
	register struct dquot *dq;
	register int i;
	int ncurinodes, error;
d322 1
a322 2
	if ((flags & CHOWN) == 0)
		chkdquot(ip);
d324 2
a325 3
	if (change == 0)
		return (0);
	if (change < 0) {
d327 1
a327 1
			if ((dq = ip->i_dquot[i]) == NODQUOT)
a328 16
			while (dq->dq_flags & DQ_LOCK) {
				dq->dq_flags |= DQ_WANT;
				sleep((caddr_t)dq, PINOD+1);
			}
			ncurinodes = dq->dq_curinodes + change;
			if (ncurinodes >= 0)
				dq->dq_curinodes = ncurinodes;
			else
				dq->dq_curinodes = 0;
			dq->dq_flags &= ~DQ_INODS;
			dq->dq_flags |= DQ_MOD;
		}
		return (0);
	}
	if ((flags & FORCE) == 0 && cred->cr_uid != 0) {
		for (i = 0; i < MAXQUOTAS; i++) {
d331 1
a331 1
			if ((error = chkiqchg(ip, change, cred, i)) != 0)
d336 2
d342 1
a342 1
			sleep((caddr_t)dq, PINOD+1);
d344 29
a372 1
		dq->dq_curinodes += change;
d389 1
a389 1
	register struct dquot *dq = ip->i_dquot[type];
d441 1
a441 1
	register struct inode *ip;
d444 2
a445 1
	register int i;
d447 3
d466 21
d494 1
a494 1
	register int type;
d497 2
a498 3
	register struct ufsmount *ump = VFSTOUFS(mp);
	register struct vnode *vp, **vpp;
	struct vnode *nextvp;
d503 5
d544 2
a545 15
again:
	for (vp = mp->mnt_vnodelist.lh_first; vp != NULL; vp = nextvp) {
		nextvp = vp->v_mntvnodes.le_next;
		if (vp->v_type == VNON || vp->v_writecount == 0)
			continue;
		if (vget(vp, LK_EXCLUSIVE, p))
			goto again;
		if ((error = getinoquota(VTOI(vp))) != 0) {
			vput(vp);
			break;
		}
		vput(vp);
		if (vp->v_mntvnodes.le_next != nextvp || vp->v_mount != mp)
			goto again;
	}
d552 27
d586 1
a586 1
	register int type;
d588 1
a588 2
	register struct vnode *vp;
	struct vnode *qvp, *nextvp;
d590 1
a590 2
	register struct dquot *dq;
	register struct inode *ip;
d593 4
d604 4
a607 15
again:
	for (vp = mp->mnt_vnodelist.lh_first; vp != NULL; vp = nextvp) {
		nextvp = vp->v_mntvnodes.le_next;
		if (vp->v_type == VNON)
			continue;
		if (vget(vp, LK_EXCLUSIVE, p))
			goto again;
		ip = VTOI(vp);
		dq = ip->i_dquot[type];
		ip->i_dquot[type] = NODQUOT;
		dqrele(vp, dq);
		vput(vp);
		if (vp->v_mntvnodes.le_next != nextvp || vp->v_mount != mp)
			goto again;
	}
d653 1
a653 1
	register struct dquot *dq;
d667 1
a667 1
		sleep((caddr_t)dq, PINOD+1);
d713 1
a713 1
	register struct dquot *dq;
d727 1
a727 1
		sleep((caddr_t)dq, PINOD+1);
d750 25
d783 1
a783 5
	struct proc *p = curproc;
	register struct vnode *vp, *nextvp;
	register struct dquot *dq;
	register int i;
	int error = 0;
d798 1
a798 28
	simple_lock(&mntvnode_slock);
again:
 	for (vp = mp->mnt_vnodelist.lh_first; vp != NULL; vp = nextvp) {
		if (vp->v_mount != mp)
			goto again;
 		nextvp = vp->v_mntvnodes.le_next;
		if (vp->v_type == VNON)
			continue;
		simple_lock(&vp->v_interlock);
		simple_unlock(&mntvnode_slock);
		error = vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, p);
		if (error) {
			simple_lock(&mntvnode_slock);
			if (error == ENOENT)
				goto again;
 			continue;
		}
		for (i = 0; i < MAXQUOTAS; i++) {
			dq = VTOI(vp)->i_dquot[i];
			if (dq != NODQUOT && (dq->dq_flags & DQ_MOD))
				dqsync(vp, dq);
		}
		vput(vp);
		simple_lock(&mntvnode_slock);
		if (vp->v_mntvnodes.le_next != nextvp)
 			goto again;
 	}
	simple_unlock(&mntvnode_slock);
d821 1
a821 1
dqinit()
d836 2
a837 2
	register struct ufsmount *ump;
	register int type;
d841 1
a841 1
	register struct dquot *dq;
d843 1
a843 1
	register struct vnode *dqvp;
d918 1
a918 1
		wakeup((caddr_t)dq);
d964 1
a964 1
	register struct dquot *dq;
d986 1
a986 1
	register struct dquot *dq;
d1004 1
a1004 1
		sleep((caddr_t)dq, PINOD+2);
d1025 1
a1025 1
		wakeup((caddr_t)dq);
d1037 1
a1037 1
	register struct vnode *vp;
d1039 1
a1039 1
	register struct dquot *dq, *nextdq;
d1058 86
@


1.7.4.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d5 1
a5 1
 * Copyright (c) 1982, 1986, 1990, 1993, 1995
d39 1
a39 1
 *	@@(#)ufs_quota.c	8.5 (Berkeley) 8/19/94
a55 70
#include <sys/queue.h>

/*
 * The following structure records disk usage for a user or group on a
 * filesystem. There is one allocated for each quota that exists on any
 * filesystem for the current user or group. A cache is kept of recently
 * used entries.
 */
struct dquot {
	LIST_ENTRY(dquot) dq_hash;	/* hash list */
	TAILQ_ENTRY(dquot) dq_freelist;	/* free list */
	u_int16_t dq_flags;		/* flags, see below */
	u_int16_t dq_cnt;		/* count of active references */
	u_int16_t dq_spare;		/* unused spare padding */
	u_int16_t dq_type;		/* quota type of this dquot */
	u_int32_t dq_id;		/* identifier this applies to */
	struct  vnode *dq_vp;           /* file backing this quota */
	struct	dqblk dq_dqb;		/* actual usage & quotas */
};
/*
 * Flag values.
 */
#define	DQ_LOCK		0x01		/* this quota locked (no MODS) */
#define	DQ_WANT		0x02		/* wakeup on unlock */
#define	DQ_MOD		0x04		/* this quota modified since read */
#define	DQ_FAKE		0x08		/* no limits here, just usage */
#define	DQ_BLKS		0x10		/* has been warned about blk limit */
#define	DQ_INODS	0x20		/* has been warned about inode limit */
/*
 * Shorthand notation.
 */
#define	dq_bhardlimit	dq_dqb.dqb_bhardlimit
#define	dq_bsoftlimit	dq_dqb.dqb_bsoftlimit
#define	dq_curblocks	dq_dqb.dqb_curblocks
#define	dq_ihardlimit	dq_dqb.dqb_ihardlimit
#define	dq_isoftlimit	dq_dqb.dqb_isoftlimit
#define	dq_curinodes	dq_dqb.dqb_curinodes
#define	dq_btime	dq_dqb.dqb_btime
#define	dq_itime	dq_dqb.dqb_itime

/*
 * If the system has never checked for a quota for this file, then it is
 * set to NODQUOT.  Once a write attempt is made the inode pointer is set
 * to reference a dquot structure.
 */
#define	NODQUOT		NULL

void	dqref __P((struct dquot *));
void	dqrele __P((struct vnode *, struct dquot *));
int	dqsync __P((struct vnode *, struct dquot *));

#ifdef DIAGNOSTIC
void	chkdquot __P((struct inode *));
#endif

int	getquota __P((struct mount *, u_long, int, caddr_t));
int	quotaon __P((struct proc *, struct mount *, int, caddr_t));
int	setquota __P((struct mount *, u_long, int, caddr_t));
int	setuse __P((struct mount *, u_long, int, caddr_t));

int	chkdqchg __P((struct inode *, long, struct ucred *, int));
int	chkiqchg __P((struct inode *, long, struct ucred *, int));

int dqget __P((struct vnode *, u_long, struct ufsmount *, int,
	       struct dquot **));

int     quotaon_vnode(struct vnode *, void *);
int     quotaoff_vnode(struct vnode *, void *);
int     qsync_vnode(struct vnode *, void *);

a61 12
 * Obtain a reference to a dquot.
 */
void
dqref(dq)
	struct dquot *dq;
{

	dq->dq_cnt++;
}


/*
d71 1
a71 1
	struct inode *ip;
d102 10
a111 6
int 
ufs_quota_alloc_blocks2(struct inode *ip, int32_t change, 
    struct ucred *cred, enum ufs_quota_flags flags) {
	struct dquot *dq;
	int i;
	int error;
d114 2
a115 1
	chkdquot(ip);
a116 1

d119 1
a119 3

	if ((flags & UFS_QUOTA_FORCE) == 0 && 
	    (cred != NOCRED && cred->cr_uid != 0)) {
d121 1
a121 1
			if (flags & (1 << i)) 
d123 16
a145 2
		if (flags & (1 << i))
			continue;
d150 1
a150 1
			(void) tsleep(dq, PINOD+1, "chkdq", 0);
a157 33
int
ufs_quota_free_blocks2(struct inode *ip, int32_t change, 
    struct ucred *cred, enum ufs_quota_flags flags) {
	struct dquot *dq;
	int i;

#ifdef DIAGNOSTIC
	if (!VOP_ISLOCKED(ITOV(ip))) 
		panic ("ufs_quota_free_blocks2: vnode is not locked");
#endif

	if (change == 0) 
		return (0);

	for (i = 0; i < MAXQUOTAS; i++) {
		if (flags & (1 << i))
			continue;
		if ((dq = ip->i_dquot[i]) == NODQUOT)
			continue;
		while (dq->dq_flags & DQ_LOCK) {
			dq->dq_flags |= DQ_WANT;
			(void) tsleep(dq, PINOD+1, "chkdq", 0);
		}
		if (dq->dq_curblocks >= change)
			dq->dq_curblocks -= change;
		else
			dq->dq_curblocks = 0;
		dq->dq_flags &= ~DQ_BLKS;
		dq->dq_flags |= DQ_MOD;
	}
	return (0);
}

d169 1
a169 1
	struct dquot *dq = ip->i_dquot[type];
d218 9
a226 5
ufs_quota_alloc_inode2(struct inode *ip, struct ucred *cred,
    enum ufs_quota_flags flags) {
	struct dquot *dq;
	int i;
	int error;
d229 2
a230 1
	chkdquot(ip);
d232 3
a234 2

	if ((flags & UFS_QUOTA_FORCE) == 0 && cred->cr_uid != 0) {
d236 1
a236 1
			if (flags & (1 << i)) 
d238 16
d256 1
a256 1
			if ((error = chkiqchg(ip, 1, cred, i)) != 0)
a260 28
		if (flags & (1 << i)) 
			continue;
		if ((dq = ip->i_dquot[i]) == NODQUOT)
			continue;
		while (dq->dq_flags & DQ_LOCK) {
			dq->dq_flags |= DQ_WANT;
			(void) tsleep(dq, PINOD+1, "chkiq", 0);
		}
		dq->dq_curinodes++;
		dq->dq_flags |= DQ_MOD;
	}
	return (0);
}

int
ufs_quota_free_inode2(struct inode *ip, struct ucred *cred,
    enum ufs_quota_flags flags) {
	struct dquot *dq;
	int i;

#ifdef DIAGNOSTIC
	if (!VOP_ISLOCKED(ITOV(ip))) 
		panic ("ufs_quota_free_blocks2: vnode is not locked");
#endif

	for (i = 0; i < MAXQUOTAS; i++) {
		if (flags & (1 << i)) 
			continue;
d265 1
a265 1
			(void) tsleep(dq, PINOD+1, "chkiq", 0);
d267 1
a267 3
		if (dq->dq_curinodes > 0)
			dq->dq_curinodes--;
		dq->dq_flags &= ~DQ_INODS;
d284 1
a284 1
	struct dquot *dq = ip->i_dquot[type];
d336 1
a336 1
	struct inode *ip;
d339 1
a339 2
	int i;
	struct vnode *vp = ITOV(ip);
a340 3
	if (!VOP_ISLOCKED(vp)) 
		panic ("chkdquot: vnode is not locked");
		
a356 21
int
quotaon_vnode(struct vnode *vp, void *arg) 
{
	int error;
	struct proc *p = (struct proc *)arg;

	if (vp->v_type == VNON || vp->v_writecount == 0) {
		simple_unlock(&vp->v_interlock);
		return (0);
	}

	if (vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, p)) {
		return (0);
	}

	error = getinoquota(VTOI(vp));
	vput(vp);
	
	return (error);
}

d364 1
a364 1
	int type;
d367 3
a369 2
	struct ufsmount *ump = VFSTOUFS(mp);
	struct vnode *vp, **vpp;
a373 5
#ifdef DIAGNOSTIC
	if (!vfs_isbusy(mp))
		panic ("quotaon: mount point not busy");
#endif

d410 15
a424 2
	error = vfs_mount_foreach_vnode(mp, quotaon_vnode, p);

a430 27
struct quotaoff_arg {
	struct proc *p;
	int type;
};

int
quotaoff_vnode(struct vnode *vp, void *arg) 
{
	struct quotaoff_arg *qa = (struct quotaoff_arg *)arg;
	struct inode *ip;
	struct dquot *dq;

	if (vp->v_type == VNON) {
		simple_unlock(&vp->v_interlock);
		return (0);
	}

	if (vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, qa->p))
		return (0);
	ip = VTOI(vp);
	dq = ip->i_dquot[qa->type];
	ip->i_dquot[qa->type] = NODQUOT;
	dqrele(vp, dq);
	vput(vp);
	return (0);
}

d438 1
a438 1
	int type;
d440 2
a441 1
	struct vnode *qvp;
d443 2
a444 1
	struct quotaoff_arg qa;
a446 4
#ifdef DIAGNOSTIC
	if (!vfs_isbusy(mp))
		panic ("quotaoff: mount point not busy");
#endif
d454 17
a470 4
	qa.p = p;
	qa.type = type;
	vfs_mount_foreach_vnode(mp, quotaoff_vnode, &qa);

d514 1
a514 1
	struct dquot *dq;
d528 1
a528 1
		(void) tsleep(dq, PINOD+1, "setquota", 0);
d574 1
a574 1
	struct dquot *dq;
d588 1
a588 1
		(void) tsleep(dq, PINOD+1, "setuse", 0);
a610 25


int
qsync_vnode(struct vnode *vp, void *arg) {
	int i;
	struct proc *p = curproc;
	struct dquot *dq;
	    
	if (vp->v_type == VNON) {
		simple_unlock(&vp->v_interlock);
		return (0);
	}

	if (vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, p))
		return (0);

	for (i = 0; i < MAXQUOTAS; i++) {
		dq = VTOI(vp)->i_dquot[i];
		if (dq != NODQUOT && (dq->dq_flags & DQ_MOD))
			dqsync(vp, dq);
	}
	vput(vp);
	return (0);
}

d619 5
a623 1
	int i;
d638 28
a665 1
	vfs_mount_foreach_vnode(mp, qsync_vnode, NULL);
d688 1
a688 1
ufs_quota_init()
d703 2
a704 2
	struct ufsmount *ump;
	int type;
d708 1
a708 1
	struct dquot *dq;
d710 1
a710 1
	struct vnode *dqvp;
d726 1
a726 1
		    dq->dq_vp != dqvp)
d734 1
a734 1
		dqref(dq);
d765 1
a765 1
	dqref(dq);
d768 1
a768 1
	dq->dq_vp = dqvp;
d785 1
a785 1
		wakeup(dq);
d815 11
d831 1
a831 1
	struct dquot *dq;
d853 1
a853 1
	struct dquot *dq;
a859 1
	struct ufsmount *ump = VFSTOUFS(vp->v_mount);
d865 1
a865 1
	if ((dqvp = dq->dq_vp) == NULLVP)
d871 1
a871 1
		(void) tsleep(dq, PINOD+2, "dqsync", 0);
d888 1
a888 1
	error = VOP_WRITE(dqvp, &auio, 0, ump->um_cred[dq->dq_type]);
d892 1
a892 1
		wakeup(dq);
a898 14
int
ufs_quota_delete(struct inode *ip) {
	struct vnode *vp = ITOV(ip);
	int i;
	for (i = 0; i < MAXQUOTAS; i++) {
		if (ip->i_dquot[i] != NODQUOT) {
			dqrele(vp, ip->i_dquot[i]);
			ip->i_dquot[i] = NODQUOT;
		}
	}

	return (0);
}

d900 1
a900 1
 * Do operations associated with quotas
d902 3
a904 7
int
ufs_quotactl(mp, cmds, uid, arg, p)
	struct mount *mp;
	int cmds;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
d906 2
a907 1
	int cmd, type, error;
d909 15
a923 53
	if (uid == -1)
		uid = p->p_cred->p_ruid;
	cmd = cmds >> SUBCMDSHIFT;

	switch (cmd) {
	case Q_SYNC:
		break;
	case Q_GETQUOTA:
		if (uid == p->p_cred->p_ruid)
			break;
		/* fall through */
	default:
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
			return (error);
	}

	type = cmds & SUBCMDMASK;
	if ((u_int)type >= MAXQUOTAS)
		return (EINVAL);

	if (vfs_busy(mp, LK_NOWAIT, 0, p))
		return (0);
 

	switch (cmd) {

	case Q_QUOTAON:
		error = quotaon(p, mp, type, arg);
		break;

	case Q_QUOTAOFF:
		error = quotaoff(p, mp, type);
		break;

	case Q_SETQUOTA:
		error = setquota(mp, uid, type, arg) ;
		break;

	case Q_SETUSE:
		error = setuse(mp, uid, type, arg);
		break;

	case Q_GETQUOTA:
		error = getquota(mp, uid, type, arg);
		break;

	case Q_SYNC:
		error = qsync(mp);
		break;

	default:
		error = EINVAL;
		break;
a924 3

	vfs_unbusy(mp, p);
	return (error);
@


1.7.4.2
log
@Merge in trunk
@
text
@a50 1
#include <ufs/ufs/extattr.h>
a72 1
	struct  ucred  *dq_cred;        /* credentials for writing file */
a902 2
	crhold(ump->um_cred[type]);
	dq->dq_cred = ump->um_cred[type];
d912 1
a912 1
	error = VOP_READ(dqvp, &auio, 0, dq->dq_cred);
a965 2
	crfree(dq->dq_cred);
	dq->dq_cred = NOCRED;
d982 1
a989 1

d1011 1
a1011 1
	error = VOP_WRITE(dqvp, &auio, 0, dq->dq_cred);
@


1.7.4.3
log
@Merge in -current from roughly a week ago
@
text
@d105 3
a107 3
void	dqref(struct dquot *);
void	dqrele(struct vnode *, struct dquot *);
int	dqsync(struct vnode *, struct dquot *);
d110 1
a110 1
void	chkdquot(struct inode *);
d113 4
a116 4
int	getquota(struct mount *, u_long, int, caddr_t);
int	quotaon(struct proc *, struct mount *, int, caddr_t);
int	setquota(struct mount *, u_long, int, caddr_t);
int	setuse(struct mount *, u_long, int, caddr_t);
d118 2
a119 2
int	chkdqchg(struct inode *, long, struct ucred *, int);
int	chkiqchg(struct inode *, long, struct ucred *, int);
d121 2
a122 2
int dqget(struct vnode *, u_long, struct ufsmount *, int,
	       struct dquot **);
a892 2
		crfree(dq->dq_cred);
		dq->dq_cred = NOCRED;
d970 2
@


1.7.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.7.4.3 2002/03/28 14:54:26 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d157 1
a157 1
	ump = ip->i_ump;
d289 1
a289 1
			    ip->i_ump->um_btime[type];
d412 1
a412 1
			    ip->i_ump->um_itime[type];
d443 1
a443 1
	struct ufsmount *ump = ip->i_ump;
d1063 1
a1063 1
		if ((error = suser(p, 0)) != 0)
@


1.6
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.5 1997/10/06 20:21:48 deraadt Exp $	*/
d691 1
a691 1
	dqhashtbl = hashinit(desiredvnodes, M_DQUOT, &dqhash);
@


1.5
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.3 1997/05/30 08:35:10 downsj Exp $	*/
d379 1
a379 1
	VOP_UNLOCK(vp);
a383 4
	if (vfs_busy(mp)) {
		(void) vn_close(vp, FREAD|FWRITE, p->p_ucred, p);
		return (EBUSY);
	}
d413 1
a413 1
		if (vp->v_writecount == 0)
d415 1
a415 1
		if (vget(vp, 1))
a427 1
	vfs_unbusy(mp);
a446 2
	if ((mp->mnt_flag & MNT_MPBUSY) == 0)
		panic("quotaoff: not busy");
d457 3
a459 1
		if (vget(vp, 1))
d619 1
d623 1
a628 2
	if ((mp->mnt_flag & MNT_MPBUSY) == 0)
		panic("qsync: not busy");
d638 1
d640 5
a644 3
	for (vp = mp->mnt_vnodelist.lh_first; vp != NULL; vp = nextvp) {
		nextvp = vp->v_mntvnodes.le_next;
		if (VOP_ISLOCKED(vp))
d646 9
a654 2
		if (vget(vp, 1))
			goto again;
d661 5
a665 3
		if (vp->v_mntvnodes.le_next != nextvp || vp->v_mount != mp)
			goto again;
	}
d707 1
d763 1
a763 1
		VOP_LOCK(dqvp);
d783 1
a783 1
		VOP_UNLOCK(dqvp);
d855 1
d868 1
a868 1
		VOP_LOCK(dqvp);
d874 1
a874 1
				VOP_UNLOCK(dqvp);
d895 1
a895 1
		VOP_UNLOCK(dqvp);
@


1.4
log
@VFS Lite2 Changes
@
text
@d379 1
a379 1
	VOP_UNLOCK(vp, 0, p);
d384 4
d417 1
a417 1
		if (vp->v_type == VNON || vp->v_writecount == 0)
d419 1
a419 1
		if (vget(vp, LK_EXCLUSIVE, p))
d432 1
d452 2
d464 1
a464 3
		if (vp->v_type == VNON)
			continue;
		if (vget(vp, LK_EXCLUSIVE, p))
a623 1
	struct proc *p = curproc;
a626 1
	int error = 0;
d632 2
a642 1
	simple_lock(&mntvnode_slock);
d644 5
a648 2
 	for (vp = mp->mnt_vnodelist.lh_first; vp != NULL; vp = nextvp) {
		if (vp->v_mount != mp)
a649 12
 		nextvp = vp->v_mntvnodes.le_next;
		if (vp->v_type == VNON)
			continue;
		simple_lock(&vp->v_interlock);
		simple_unlock(&mntvnode_slock);
		error = vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, p);
		if (error) {
			simple_lock(&mntvnode_slock);
			if (error == ENOENT)
				goto again;
 			continue;
		}
d656 3
a658 5
		simple_lock(&mntvnode_slock);
		if (vp->v_mntvnodes.le_next != nextvp)
 			goto again;
 	}
	simple_unlock(&mntvnode_slock);
a699 1
	struct proc *p = curproc;
d755 1
a755 1
		vn_lock(dqvp, LK_EXCLUSIVE | LK_RETRY, p);
d775 1
a775 1
		VOP_UNLOCK(dqvp, 0, p);
a846 1
	struct proc *p = curproc;
d859 1
a859 1
		vn_lock(dqvp, LK_EXCLUSIVE | LK_RETRY, p);
d865 1
a865 1
				VOP_UNLOCK(dqvp, 0, p);
d886 1
a886 1
		VOP_UNLOCK(dqvp, 0, p);
@


1.3
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_quota.c,v 1.2 1996/02/27 07:21:29 niklas Exp $	*/
d379 1
a379 1
	VOP_UNLOCK(vp);
a383 4
	if (vfs_busy(mp)) {
		(void) vn_close(vp, FREAD|FWRITE, p->p_ucred, p);
		return (EBUSY);
	}
d413 1
a413 1
		if (vp->v_writecount == 0)
d415 1
a415 1
		if (vget(vp, 1))
a427 1
	vfs_unbusy(mp);
a446 2
	if ((mp->mnt_flag & MNT_MPBUSY) == 0)
		panic("quotaoff: not busy");
d457 3
a459 1
		if (vget(vp, 1))
d619 1
d623 1
a628 2
	if ((mp->mnt_flag & MNT_MPBUSY) == 0)
		panic("qsync: not busy");
d638 1
d640 5
a644 3
	for (vp = mp->mnt_vnodelist.lh_first; vp != NULL; vp = nextvp) {
		nextvp = vp->v_mntvnodes.le_next;
		if (VOP_ISLOCKED(vp))
d646 9
a654 2
		if (vget(vp, 1))
			goto again;
d661 5
a665 3
		if (vp->v_mntvnodes.le_next != nextvp || vp->v_mount != mp)
			goto again;
	}
d707 1
d763 1
a763 1
		VOP_LOCK(dqvp);
d783 1
a783 1
		VOP_UNLOCK(dqvp);
d855 1
d868 1
a868 1
		VOP_LOCK(dqvp);
d874 1
a874 1
				VOP_UNLOCK(dqvp);
d895 1
a895 1
		VOP_UNLOCK(dqvp);
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 1
a84 1
		dqget(vp, ip->i_uid, ump, USRQUOTA, &ip->i_dquot[USRQUOTA])) &&
d93 1
a93 1
		dqget(vp, ip->i_gid, ump, GRPQUOTA, &ip->i_dquot[GRPQUOTA])) &&
d177 1
a177 1
		    ip->i_uid == cred->cr_uid) {
d193 1
a193 1
			if (ip->i_uid == cred->cr_uid)
d201 1
a201 1
			    ip->i_uid == cred->cr_uid) {
d292 1
a292 1
		    ip->i_uid == cred->cr_uid) {
d308 1
a308 1
			if (ip->i_uid == cred->cr_uid)
d316 1
a316 1
			    ip->i_uid == cred->cr_uid) {
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ufs_quota.c,v 1.7 1995/03/08 01:51:38 cgd Exp $	*/
d141 1
a141 1
			if (error = chkdqchg(ip, change, cred, i))
d256 1
a256 1
			if (error = chkiqchg(ip, change, cred, i))
d376 1
a376 1
	if (error = vn_open(&nd, FREAD|FWRITE, 0))
d421 1
a421 1
		if (error = getinoquota(VTOI(vp))) {
d502 1
a502 1
	if (error = dqget(NULLVP, id, VFSTOUFS(mp), type, &dq))
d525 2
a526 1
	if (error = copyin(addr, (caddr_t)&newlim, sizeof (struct dqblk)))
d528 1
a528 1
	if (error = dqget(NULLVP, id, ump, type, &ndq))
d585 2
a586 1
	if (error = copyin(addr, (caddr_t)&usage, sizeof (struct dqblk)))
d588 1
a588 1
	if (error = dqget(NULLVP, id, ump, type, &ndq))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
