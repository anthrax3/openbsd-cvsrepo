head	1.35;
access;
symbols
	OPENBSD_6_1:1.35.0.8
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.6
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.34.0.6
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.4
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.2
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.29.0.12
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.10
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.6
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.29.0.8
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.4
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.2
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.9.0.6
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.4
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.8
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.6
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.4
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2015.03.14.03.38.53;	author jsg;	state Exp;
branches;
next	1.34;
commitid	p4LJxGKbi0BU2cG6;

1.34
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2013.06.11.16.42.19;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2011.09.18.11.18.28;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.12.06.58.40;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.11.12.35.46;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.10.20.14.37;	author beck;	state Exp;
branches;
next	1.26;

1.26
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.01.07.44.27;	author otto;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.01.07.36.19;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.01.06.38.56;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.10.03.19.49.06;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.01.02.43.05;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.10.22.01.14;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.03.20.14.02;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.26.18.33.17;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.13.18.26.13;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.22.20.37.46;	author drahn;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.27.05.27.12;	author art;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.11.21.22.24.24;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.23.02.14.39;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.13.14.07.54;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.11.17.09.23.54;	author art;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.11.17.09.19.10;	author art;	state Exp;
branches;
next	1.5;

1.5
date	99.04.25.00.36.47;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.05.30.08.35.02;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.10.18.14.51.15;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.21.24;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2000.03.24.09.09.47;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.05.14.22.47.43;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.29.00.36.50;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: ufs_bmap.c,v 1.34 2013/11/01 17:36:19 krw Exp $	*/
/*	$NetBSD: ufs_bmap.c,v 1.3 1996/02/09 22:36:00 christos Exp $	*/

/*
 * Copyright (c) 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_bmap.c	8.6 (Berkeley) 1/21/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/specdev.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

/*
 * Bmap converts a the logical block number of a file to its physical block
 * number on the disk. The conversion is done by using the logical block
 * number to index into the array of block pointers described by the dinode.
 */
int
ufs_bmap(void *v)
{
	struct vop_bmap_args *ap = v;

	/*
	 * Check for underlying vnode requests and ensure that logical
	 * to physical mapping is requested.
	 */
	if (ap->a_vpp != NULL)
		*ap->a_vpp = VTOI(ap->a_vp)->i_devvp;
	if (ap->a_bnp == NULL)
		return (0);

	return (ufs_bmaparray(ap->a_vp, ap->a_bn, ap->a_bnp, NULL, NULL,
	    ap->a_runp));
}

/*
 * Indirect blocks are now on the vnode for the file.  They are given negative
 * logical block numbers.  Indirect blocks are addressed by the negative
 * address of the first data block to which they point.  Double indirect blocks
 * are addressed by one less than the address of the first indirect block to
 * which they point.  Triple indirect blocks are addressed by one less than
 * the address of the first double indirect block to which they point.
 *
 * ufs_bmaparray does the bmap conversion, and if requested returns the
 * array of logical blocks which must be traversed to get to a block.
 * Each entry contains the offset into that block that gets you to the
 * next block and the disk address of the block (if it is assigned).
 */
int
ufs_bmaparray(struct vnode *vp, daddr_t bn, daddr_t *bnp, struct indir *ap,
    int *nump, int *runp)
{
	struct inode *ip;
	struct buf *bp;
	struct ufsmount *ump;
	struct mount *mp;
	struct vnode *devvp;
	struct indir a[NIADDR+1], *xap;
	daddr_t daddr, metalbn;
	int error, maxrun = 0, num;

	ip = VTOI(vp);
	mp = vp->v_mount;
	ump = VFSTOUFS(mp);
#ifdef DIAGNOSTIC
	if ((ap != NULL && nump == NULL) || (ap == NULL && nump != NULL))
		panic("ufs_bmaparray: invalid arguments");
#endif

	if (runp) {
		/*
		 * XXX
		 * If MAXBSIZE is the largest transfer the disks can handle,
		 * we probably want maxrun to be 1 block less so that we
		 * don't create a block larger than the device can handle.
		 */
		*runp = 0;
		maxrun = MAXBSIZE / mp->mnt_stat.f_iosize - 1;
	}

	xap = ap == NULL ? a : ap;
	if (!nump)
		nump = &num;
	if ((error = ufs_getlbns(vp, bn, xap, nump)) != 0)
		return (error);

	num = *nump;
	if (num == 0) {
		*bnp = blkptrtodb(ump, DIP(ip, db[bn]));
		if (*bnp == 0)
			*bnp = -1;
		else if (runp)
			for (++bn; bn < NDADDR && *runp < maxrun &&
			    is_sequential(ump, DIP(ip, db[bn - 1]),
			        DIP(ip, db[bn]));
			    ++bn, ++*runp);
		return (0);
	}


	/* Get disk address out of indirect block array */
	daddr = DIP(ip, ib[xap->in_off]);

	devvp = VFSTOUFS(vp->v_mount)->um_devvp;
	for (bp = NULL, ++xap; --num; ++xap) {
		/* 
		 * Exit the loop if there is no disk address assigned yet and
		 * the indirect block isn't in the cache, or if we were
		 * looking for an indirect block and we've found it.
		 */

		metalbn = xap->in_lbn;
		if ((daddr == 0 && !incore(vp, metalbn)) || metalbn == bn)
			break;
		/*
		 * If we get here, we've either got the block in the cache
		 * or we have a disk address for it, go fetch it.
		 */
		if (bp)
			brelse(bp);

		xap->in_exists = 1;
		bp = getblk(vp, metalbn, mp->mnt_stat.f_iosize, 0, 0);
		if (bp->b_flags & (B_DONE | B_DELWRI)) {
			;
		}
#ifdef DIAGNOSTIC
		else if (!daddr)
			panic("ufs_bmaparray: indirect block not in cache");
#endif
		else {
			bp->b_blkno = blkptrtodb(ump, daddr);
			bp->b_flags |= B_READ;
			bcstats.pendingreads++;
			bcstats.numreads++;
			VOP_STRATEGY(bp);
			curproc->p_ru.ru_inblock++;		/* XXX */
			if ((error = biowait(bp)) != 0) {
				brelse(bp);
				return (error);
			}
		}

#ifdef FFS2
		if (ip->i_ump->um_fstype == UM_UFS2) {
			daddr = ((int64_t *)bp->b_data)[xap->in_off];
			if (num == 1 && daddr && runp)
				for (bn = xap->in_off + 1;
				    bn < MNINDIR(ump) && *runp < maxrun &&
				    is_sequential(ump,
					((int64_t *)bp->b_data)[bn - 1],
					((int64_t *)bp->b_data)[bn]);
				    ++bn, ++*runp);

                        continue;
		}

#endif /* FFS2 */

		daddr = ((int32_t *)bp->b_data)[xap->in_off];
		if (num == 1 && daddr && runp)
			for (bn = xap->in_off + 1;
			    bn < MNINDIR(ump) && *runp < maxrun &&
			    is_sequential(ump,
				((int32_t *)bp->b_data)[bn - 1],
				((int32_t *)bp->b_data)[bn]);
			    ++bn, ++*runp);
	}
	if (bp)
		brelse(bp);

	daddr = blkptrtodb(ump, daddr);
	*bnp = daddr == 0 ? -1 : daddr;
	return (0);
}

/*
 * Create an array of logical block number/offset pairs which represent the
 * path of indirect blocks required to access a data block.  The first "pair"
 * contains the logical block number of the appropriate single, double or
 * triple indirect block and the offset into the inode indirect block array.
 * Note, the logical block number of the inode single/double/triple indirect
 * block appears twice in the array, once with the offset into the i_ffs_ib and
 * once with the offset into the page itself.
 */
int
ufs_getlbns(struct vnode *vp, daddr_t bn, struct indir *ap, int *nump)
{
	daddr_t metalbn, realbn;
	struct ufsmount *ump;
	int64_t blockcnt;
	int i, numlevels, off;

	ump = VFSTOUFS(vp->v_mount);
	if (nump)
		*nump = 0;
	numlevels = 0;
	realbn = bn;
	if (bn < 0)
		bn = -bn;

#ifdef DIAGNOSTIC
	if (realbn < 0 && realbn > -NDADDR) {
		panic ("ufs_getlbns: Invalid indirect block %lld specified",
		    (long long)realbn);
	}
#endif

	/* The first NDADDR blocks are direct blocks. */
	if (bn < NDADDR)
		return (0);

	/* 
	 * Determine the number of levels of indirection.  After this loop
	 * is done, blockcnt indicates the number of data blocks possible
	 * at the given level of indirection, and NIADDR - i is the number
	 * of levels of indirection needed to locate the requested block.
	 */
	for (blockcnt = 1, i = NIADDR, bn -= NDADDR;; i--, bn -= blockcnt) {
		if (i == 0)
			return (EFBIG);
		blockcnt *= MNINDIR(ump);
		if (bn < blockcnt)
			break;
	}

	/* Calculate the address of the first meta-block. */
	if (realbn >= 0)
		metalbn = -(realbn - bn + NIADDR - i);
	else
		metalbn = -(-realbn - bn + NIADDR - i);

	/* 
	 * At each iteration, off is the offset into the bap array which is
	 * an array of disk addresses at the current level of indirection.
	 * The logical block number and the offset in that block are stored
	 * into the argument array.
	 */
	ap->in_lbn = metalbn;
	ap->in_off = off = NIADDR - i;
	ap->in_exists = 0;
	ap++;
	for (++numlevels; i <= NIADDR; i++) {
		/* If searching for a meta-data block, quit when found. */
		if (metalbn == realbn)
			break;

		blockcnt /= MNINDIR(ump);
		off = (bn / blockcnt) % MNINDIR(ump);

		++numlevels;
		ap->in_lbn = metalbn;
		ap->in_off = off;
		ap->in_exists = 0;
		++ap;

		metalbn -= -1 + off * blockcnt;
	}
#ifdef DIAGNOSTIC
	if (realbn < 0 && metalbn != realbn) {
		panic("ufs_getlbns: indirect block %lld not found",
		    (long long)realbn);
	}
#endif
	if (nump)
		*nump = numlevels;
	return (0);
}
@


1.34
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.33 2013/06/11 16:42:19 deraadt Exp $	*/
a45 1
#include <sys/resourcevar.h>
@


1.33
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.32 2012/03/23 15:51:26 guenther Exp $	*/
d246 1
a246 1
		    realbn);
d302 2
a303 1
		panic("ufs_getlbns: indirect block %lld not found", realbn);
@


1.32
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.31 2011/09/18 11:18:28 miod Exp $	*/
d91 1
a91 1
ufs_bmaparray(struct vnode *vp, daddr64_t bn, daddr64_t *bnp, struct indir *ap,
d100 1
a100 1
	daddr64_t daddr, metalbn;
d228 1
a228 1
ufs_getlbns(struct vnode *vp, daddr64_t bn, struct indir *ap, int *nump)
d230 1
a230 1
	daddr64_t metalbn, realbn;
@


1.31
log
@Make sure daddr64_t values get printed with %lld.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.30 2011/07/04 20:35:35 deraadt Exp $	*/
d178 1
a178 1
			curproc->p_stats->p_ru.ru_inblock++;	/* XXX */
@


1.30
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.29 2008/06/12 06:58:40 deraadt Exp $	*/
d245 1
a245 1
		panic ("ufs_getlbns: Invalid indirect block %d specified",
d302 1
a302 1
		panic("ufs_getlbns: indirect block %d not found", realbn);
@


1.29
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.27 2008/06/10 20:14:37 beck Exp $	*/
d47 1
a47 2

#include <miscfs/specfs/specdev.h>
@


1.28
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.26 2008/01/05 19:49:26 otto Exp $	*/
d176 2
@


1.27
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@a175 2
			bcstats.pendingreads++;
			bcstats.numreads++;
@


1.26
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.25 2007/06/01 23:47:57 deraadt Exp $	*/
d176 2
@


1.25
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.24 2007/06/01 07:44:27 otto Exp $	*/
d92 1
a92 1
ufs_bmaparray(struct vnode *vp, daddr_t bn, daddr64_t *bnp, struct indir *ap,
d101 1
a101 2
	daddr64_t daddr;
	long metalbn;
d186 1
a186 1
			daddr = ((daddr64_t *)bp->b_data)[xap->in_off];
d191 2
a192 2
					((daddr64_t *)bp->b_data)[bn - 1],
					((daddr64_t *)bp->b_data)[bn]);
d200 1
a200 1
		daddr = ((daddr_t *)bp->b_data)[xap->in_off];
d205 2
a206 2
				((daddr_t *)bp->b_data)[bn - 1],
				((daddr_t *)bp->b_data)[bn]);
d227 1
a227 1
ufs_getlbns(struct vnode *vp, daddr_t bn, struct indir *ap, int *nump)
d229 1
a229 1
	long metalbn, realbn;
d239 2
a240 2
	if ((long)bn < 0)
		bn = -(long)bn;
@


1.24
log
@and don't forget the other daddr var in the comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.23 2007/06/01 07:36:19 otto Exp $	*/
d63 2
a64 7
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr64_t  a_bn;
		struct vnode **a_vpp;
		daddr64_t *a_bnp;
		int *a_runp;
	} */ *ap = v;
@


1.23
log
@fix struct vop_bmap_args comment. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.22 2007/06/01 06:38:56 deraadt Exp $	*/
d67 1
a67 1
		daddr_t *a_bnp;
@


1.22
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.21 2006/10/03 19:49:06 pedro Exp $	*/
d65 1
a65 1
		daddr_t  a_bn;
@


1.21
log
@Introduce daddr64_t and use it for physical block numbers
Okay weingart@@, "I'm game with putting my name on it" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.20 2006/04/01 02:43:05 pedro Exp $	*/
d106 1
a106 1
	ufs2_daddr_t daddr;
d192 1
a192 1
			daddr = ((ufs2_daddr_t *)bp->b_data)[xap->in_off];
d197 2
a198 2
					((ufs2_daddr_t *)bp->b_data)[bn - 1],
					((ufs2_daddr_t *)bp->b_data)[bn]);
@


1.20
log
@Correctly map blocks for FFS2 in ufs_bmaparray()
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.19 2005/12/28 20:48:18 pedro Exp $	*/
d97 1
a97 1
ufs_bmaparray(struct vnode *vp, daddr_t bn, daddr_t *bnp, struct indir *ap,
@


1.19
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.18 2005/11/10 22:01:14 pedro Exp $	*/
d106 1
a106 1
	daddr_t daddr;
d189 16
@


1.18
log
@Use ANSI function declarations and deregister, no binary change.
Diff from Rui Reis <rui@@rui.cx>, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.17 2005/07/03 20:14:02 drahn Exp $	*/
d137 1
a137 1
		*bnp = blkptrtodb(ump, ip->i_ffs_db[bn]);
d142 2
a143 1
			    is_sequential(ump, ip->i_ffs_db[bn - 1], ip->i_ffs_db[bn]);
d150 1
a150 1
	daddr = ip->i_ffs_ib[xap->in_off];
@


1.17
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.16 2003/06/02 23:28:23 millert Exp $	*/
d61 1
a61 2
ufs_bmap(v)
	void *v;
a95 1

d97 2
a98 7
ufs_bmaparray(vp, bn, bnp, ap, nump, runp)
	struct vnode *vp;
	daddr_t bn;
	daddr_t *bnp;
	struct indir *ap;
	int *nump;
	int *runp;
d216 1
a216 5
ufs_getlbns(vp, bn, ap, nump)
	struct vnode *vp;
	daddr_t bn;
	struct indir *ap;
	int *nump;
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.15 2003/05/26 18:33:17 tedu Exp $	*/
a49 1
#include <ufs/ufs/extattr.h>
@


1.15
log
@fiddle with some type names.  change most instances of ufs_daddr_t to
ufs1_daddr_t, a few to daddr_t.  ufs_daddr_t typedef is retained, but consider
it deprecated.  no functional changes.  inspired by freebsd.  ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.14 2002/10/13 18:26:13 krw Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14
log
@Remove more '\n's from panic() statements.  From Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.13 2002/02/22 20:37:46 drahn Exp $	*/
d106 2
a107 2
	ufs_daddr_t bn;
	ufs_daddr_t *bnp;
d118 1
a118 1
	ufs_daddr_t daddr;
d201 1
a201 1
		daddr = ((ufs_daddr_t *)bp->b_data)[xap->in_off];
d206 2
a207 2
				((ufs_daddr_t *)bp->b_data)[bn - 1],
				((ufs_daddr_t *)bp->b_data)[bn]);
d230 1
a230 1
	ufs_daddr_t bn;
@


1.13
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.12 2001/12/19 08:58:07 art Exp $	*/
d249 1
a249 1
		panic ("ufs_getlbns: Invalid indirect block %d specified\n",
@


1.12
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.10 2001/11/21 22:24:24 csapuntz Exp $	*/
d54 1
@


1.11
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@a235 1
	int lbc;
d263 1
a263 2
	bn -= NDADDR;
	for (lbc = 0, i = NIADDR;; i--, bn -= blockcnt) {
d266 1
a266 4

		lbc += ump->um_lognindir;
		blockcnt = (int64_t)1 << lbc;

d292 2
a293 3
		lbc -= ump->um_lognindir;
		blockcnt = (int64_t)1 << lbc;
		off = (bn >> lbc) & (MNINDIR(ump) - 1);
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.11 2001/11/27 05:27:12 art Exp $	*/
a53 1
#include <ufs/ufs/extattr.h>
@


1.11.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.11.2.1 2002/06/11 03:32:50 art Exp $	*/
d250 1
a250 1
		panic ("ufs_getlbns: Invalid indirect block %d specified",
@


1.11.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.11.2.2 2002/10/29 00:36:50 art Exp $	*/
d141 8
a148 3
	if (bn >= 0 && bn < NDADDR) {
		if (nump != NULL)
			*nump = 0;
a158 7
	xap = ap == NULL ? a : ap;
	if (!nump)
		nump = &num;
	if ((error = ufs_getlbns(vp, bn, xap, nump)) != 0)
		return (error);

	num = *nump;
d308 1
a308 1
		metalbn -= -1 + (off << lbc);
@


1.10
log
@Added sanity checks
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.9 2000/06/23 02:14:39 mickey Exp $	*/
d236 1
d264 2
a265 1
	for (blockcnt = 1, i = NIADDR, bn -= NDADDR;; i--, bn -= blockcnt) {
d268 4
a271 1
		blockcnt *= MNINDIR(ump);
d297 3
a299 2
		blockcnt /= MNINDIR(ump);
		off = (bn / blockcnt) % MNINDIR(ump);
@


1.9
log
@remove obsolete vtrace guts; art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.8 2000/03/13 14:07:54 art Exp $	*/
d246 7
d303 5
@


1.8
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.7 1999/11/17 09:23:54 art Exp $	*/
a50 1
#include <sys/trace.h>
d183 1
a183 1
			trace(TR_BREADHIT, pack(vp, size), metalbn);
a189 1
			trace(TR_BREADMISS, pack(vp, size), metalbn);
@


1.7
log
@Avoid overflowing when calculating blocks at the third level of indirection.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.6 1999/11/17 09:19:10 art Exp $	*/
d188 1
a188 1
			panic("ufs_bmaparry: indirect block not in cache");
@


1.7.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d188 1
a188 1
			panic("ufs_bmaparray: indirect block not in cache");
@


1.7.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.9 2000/06/23 02:14:39 mickey Exp $	*/
d51 1
d184 1
a184 1
			;
d191 1
@


1.7.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a235 1
	int lbc;
a245 7
#ifdef DIAGNOSTIC
	if (realbn < 0 && realbn > -NDADDR) {
		panic ("ufs_getlbns: Invalid indirect block %d specified\n",
		    realbn);
	}
#endif

d256 1
a256 2
	bn -= NDADDR;
	for (lbc = 0, i = NIADDR;; i--, bn -= blockcnt) {
d259 1
a259 4

		lbc += ump->um_lognindir;
		blockcnt = (int64_t)1 << lbc;

d285 2
a286 3
		lbc -= ump->um_lognindir;
		blockcnt = (int64_t)1 << lbc;
		off = (bn >> lbc) & (MNINDIR(ump) - 1);
a295 5
#ifdef DIAGNOSTIC
	if (realbn < 0 && metalbn != realbn) {
		panic("ufs_getlbns: indirect block %d not found", realbn);
	}
#endif
@


1.7.2.4
log
@Merge in trunk
@
text
@a53 1
#include <ufs/ufs/extattr.h>
d236 1
d264 2
a265 1
	for (blockcnt = 1, i = NIADDR, bn -= NDADDR;; i--, bn -= blockcnt) {
d268 4
a271 1
		blockcnt *= MNINDIR(ump);
d297 3
a299 2
		blockcnt /= MNINDIR(ump);
		off = (bn / blockcnt) % MNINDIR(ump);
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@d249 1
a249 1
		panic ("ufs_getlbns: Invalid indirect block %d specified",
@


1.7.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.7.2.5 2003/03/28 00:08:47 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
d106 2
a107 2
	daddr_t bn;
	daddr_t *bnp;
d118 1
a118 1
	daddr_t daddr;
d201 1
a201 1
		daddr = ((daddr_t *)bp->b_data)[xap->in_off];
d206 2
a207 2
				((daddr_t *)bp->b_data)[bn - 1],
				((daddr_t *)bp->b_data)[bn]);
d230 1
a230 1
	daddr_t bn;
@


1.6
log
@daddr_t vs. ufs_daddr_t cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.5 1999/04/25 00:36:47 millert Exp $	*/
d237 2
a238 1
	int blockcnt, i, numlevels, off;
@


1.5
log
@Reading large file from ext2fs caused vm_fault; gluk@@ecsc.mipt.ru
Approved by csapuntz@@openbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.4 1997/05/30 08:35:02 downsj Exp $	*/
d106 2
a107 2
	register daddr_t bn;
	daddr_t *bnp;
d112 1
a112 1
	register struct inode *ip;
d118 1
a118 1
	daddr_t daddr;
a119 3
#ifdef	TRACE
	long size;
#endif
d202 1
a202 1
		daddr = ((daddr_t *)bp->b_data)[xap->in_off];
d206 3
a208 2
			    is_sequential(ump, ((daddr_t *)bp->b_data)[bn - 1],
			    ((daddr_t *)bp->b_data)[bn]);
d231 1
a231 1
	register daddr_t bn;
@


1.4
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.3 1996/10/18 14:51:15 mickey Exp $	*/
d117 1
a117 1
	struct indir a[NIADDR], *xap;
@


1.3
log
@-Wall happieness
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_bmap.c,v 1.2 1996/02/27 07:21:24 niklas Exp $	*/
d152 1
a152 1
		*bnp = blkptrtodb(ump, ip->i_db[bn]);
d157 1
a157 1
			    is_sequential(ump, ip->i_db[bn - 1], ip->i_db[bn]);
d164 1
a164 1
	daddr = ip->i_ib[xap->in_off];
d227 1
a227 1
 * block appears twice in the array, once with the offset into the i_ib and
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d120 3
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ufs_bmap.c,v 1.2 1994/06/29 06:47:24 cgd Exp $	*/
d45 1
d66 3
a68 1
ufs_bmap(ap)
d75 1
a75 2
	} */ *ap;
{
d120 1
a120 1
	int error, maxrun, num;
d126 1
a126 1
	if (ap != NULL && nump == NULL || ap == NULL && nump != NULL)
d144 1
a144 1
	if (error = ufs_getlbns(vp, bn, xap, nump))
d172 1
a172 1
		if (daddr == 0 && !incore(vp, metalbn) || metalbn == bn)
d196 1
a196 1
			if (error = biowait(bp)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
