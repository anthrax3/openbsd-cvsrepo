head	1.134;
access;
symbols
	OPENBSD_6_2:1.134.0.4
	OPENBSD_6_2_BASE:1.134
	OPENBSD_6_1:1.133.0.4
	OPENBSD_6_1_BASE:1.133
	OPENBSD_6_0:1.129.0.2
	OPENBSD_6_0_BASE:1.129
	OPENBSD_5_9:1.125.0.2
	OPENBSD_5_9_BASE:1.125
	OPENBSD_5_8:1.121.0.4
	OPENBSD_5_8_BASE:1.121
	OPENBSD_5_7:1.119.0.2
	OPENBSD_5_7_BASE:1.119
	OPENBSD_5_6:1.115.0.4
	OPENBSD_5_6_BASE:1.115
	OPENBSD_5_5:1.112.0.4
	OPENBSD_5_5_BASE:1.112
	OPENBSD_5_4:1.107.0.2
	OPENBSD_5_4_BASE:1.107
	OPENBSD_5_3:1.104.0.4
	OPENBSD_5_3_BASE:1.104
	OPENBSD_5_2:1.104.0.2
	OPENBSD_5_2_BASE:1.104
	OPENBSD_5_1_BASE:1.102
	OPENBSD_5_1:1.102.0.2
	OPENBSD_5_0:1.101.0.2
	OPENBSD_5_0_BASE:1.101
	OPENBSD_4_9:1.97.0.2
	OPENBSD_4_9_BASE:1.97
	OPENBSD_4_8:1.92.0.2
	OPENBSD_4_8_BASE:1.92
	OPENBSD_4_7:1.90.0.2
	OPENBSD_4_7_BASE:1.90
	OPENBSD_4_6:1.90.0.4
	OPENBSD_4_6_BASE:1.90
	OPENBSD_4_5:1.89.0.2
	OPENBSD_4_5_BASE:1.89
	OPENBSD_4_4:1.87.0.2
	OPENBSD_4_4_BASE:1.87
	OPENBSD_4_3:1.86.0.2
	OPENBSD_4_3_BASE:1.86
	OPENBSD_4_2:1.82.0.2
	OPENBSD_4_2_BASE:1.82
	OPENBSD_4_1:1.73.0.2
	OPENBSD_4_1_BASE:1.73
	OPENBSD_4_0:1.72.0.4
	OPENBSD_4_0_BASE:1.72
	OPENBSD_3_9:1.72.0.2
	OPENBSD_3_9_BASE:1.72
	OPENBSD_3_8:1.67.0.2
	OPENBSD_3_8_BASE:1.67
	OPENBSD_3_7:1.60.0.2
	OPENBSD_3_7_BASE:1.60
	OPENBSD_3_6:1.58.0.2
	OPENBSD_3_6_BASE:1.58
	SMP_SYNC_A:1.55
	SMP_SYNC_B:1.55
	OPENBSD_3_5:1.54.0.2
	OPENBSD_3_5_BASE:1.54
	OPENBSD_3_4:1.49.0.2
	OPENBSD_3_4_BASE:1.49
	UBC_SYNC_A:1.45
	OPENBSD_3_3:1.45.0.4
	OPENBSD_3_3_BASE:1.45
	OPENBSD_3_2:1.45.0.2
	OPENBSD_3_2_BASE:1.45
	OPENBSD_3_1:1.44.0.2
	OPENBSD_3_1_BASE:1.44
	UBC_SYNC_B:1.45
	UBC:1.41.0.2
	UBC_BASE:1.41
	OPENBSD_3_0:1.37.0.2
	OPENBSD_3_0_BASE:1.37
	OPENBSD_2_9_BASE:1.31
	OPENBSD_2_9:1.31.0.2
	OPENBSD_2_8:1.27.0.10
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.27.0.8
	OPENBSD_2_7_BASE:1.27
	SMP:1.27.0.6
	SMP_BASE:1.27
	kame_19991208:1.27
	OPENBSD_2_6:1.27.0.4
	OPENBSD_2_6_BASE:1.27
	OPENBSD_2_5:1.27.0.2
	OPENBSD_2_5_BASE:1.27
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.18.0.2
	OPENBSD_2_3_BASE:1.18
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.134
date	2017.04.19.17.26.13;	author dhill;	state Exp;
branches;
next	1.133;
commitid	aLxN36pMFUktModQ;

1.133
date	2016.10.07.07.51.16;	author natano;	state Exp;
branches;
next	1.132;
commitid	qA4j0ggcaNPZxKqs;

1.132
date	2016.10.06.21.00.00;	author natano;	state Exp;
branches;
next	1.131;
commitid	cWl43e0WVCVGeA5I;

1.131
date	2016.09.10.16.53.30;	author natano;	state Exp;
branches;
next	1.130;
commitid	OheBN9SCINTycSAi;

1.130
date	2016.08.10.08.04.57;	author natano;	state Exp;
branches;
next	1.129;
commitid	a3QYlN9gTOdBi75t;

1.129
date	2016.07.14.03.34.28;	author guenther;	state Exp;
branches;
next	1.128;
commitid	9XYWPmb2AFirGSto;

1.128
date	2016.06.19.11.54.34;	author natano;	state Exp;
branches;
next	1.127;
commitid	wHLNY5GFNXJSFYaC;

1.127
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.126;
commitid	gAjwyca5TfuoJAhn;

1.126
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.125;
commitid	gFybgYMymUyTbVeS;

1.125
date	2016.02.16.17.56.12;	author stefan;	state Exp;
branches
	1.125.2.1;
next	1.124;
commitid	6HMhQmvFL5xr8Rk9;

1.124
date	2016.02.04.12.45.03;	author mikeb;	state Exp;
branches;
next	1.123;
commitid	BtQZV8VbJP1k9tKY;

1.123
date	2015.12.08.15.31.01;	author tedu;	state Exp;
branches;
next	1.122;
commitid	cHTSAP0SUm96uAH9;

1.122
date	2015.09.23.15.37.26;	author tedu;	state Exp;
branches;
next	1.121;
commitid	xTdRXaXuj71z4icR;

1.121
date	2015.04.17.04.43.21;	author guenther;	state Exp;
branches
	1.121.4.1;
next	1.120;
commitid	zOwbm07fp3gPB2qr;

1.120
date	2015.03.14.03.38.53;	author jsg;	state Exp;
branches;
next	1.119;
commitid	p4LJxGKbi0BU2cG6;

1.119
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.118;
commitid	C5iGb36LQxjM60Q3;

1.118
date	2015.01.11.03.05.03;	author guenther;	state Exp;
branches;
next	1.117;
commitid	5gOXYWK6HwhlcEvO;

1.117
date	2014.12.29.05.29.28;	author miod;	state Exp;
branches;
next	1.116;
commitid	UbmX4MifiudCV4qQ;

1.116
date	2014.11.03.21.28.35;	author tedu;	state Exp;
branches;
next	1.115;
commitid	EkuwmBeHv2Tqmdnx;

1.115
date	2014.07.12.18.44.01;	author tedu;	state Exp;
branches;
next	1.114;
commitid	bDGgAR6yEQVcVl5u;

1.114
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.113;
commitid	EF98ch02VpFassUi;

1.113
date	2014.03.19.04.17.33;	author guenther;	state Exp;
branches;
next	1.112;

1.112
date	2014.01.25.23.31.13;	author guenther;	state Exp;
branches;
next	1.111;

1.111
date	2013.12.12.19.00.10;	author tedu;	state Exp;
branches;
next	1.110;

1.110
date	2013.11.23.19.07.51;	author guenther;	state Exp;
branches;
next	1.109;

1.109
date	2013.09.22.17.14.55;	author guenther;	state Exp;
branches;
next	1.108;

1.108
date	2013.08.13.05.52.27;	author guenther;	state Exp;
branches;
next	1.107;

1.107
date	2013.06.11.16.42.19;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2013.03.28.03.29.44;	author guenther;	state Exp;
branches;
next	1.105;

1.105
date	2013.03.28.02.08.39;	author guenther;	state Exp;
branches;
next	1.104;

1.104
date	2012.06.20.17.30.22;	author matthew;	state Exp;
branches;
next	1.103;

1.103
date	2012.06.19.00.09.55;	author matthew;	state Exp;
branches;
next	1.102;

1.102
date	2011.09.18.23.20.28;	author bluhm;	state Exp;
branches;
next	1.101;

1.101
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2011.07.03.18.23.10;	author tedu;	state Exp;
branches;
next	1.99;

1.99
date	2011.07.02.22.20.08;	author nicm;	state Exp;
branches;
next	1.98;

1.98
date	2011.07.02.15.52.25;	author thib;	state Exp;
branches;
next	1.97;

1.97
date	2010.12.21.20.14.44;	author thib;	state Exp;
branches;
next	1.96;

1.96
date	2010.09.23.18.49.39;	author oga;	state Exp;
branches;
next	1.95;

1.95
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.94;

1.94
date	2010.09.09.10.37.04;	author thib;	state Exp;
branches;
next	1.93;

1.93
date	2010.09.06.23.44.11;	author thib;	state Exp;
branches;
next	1.92;

1.92
date	2010.08.02.02.03.21;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	2010.07.03.02.08.35;	author thib;	state Exp;
branches;
next	1.90;

1.90
date	2009.06.04.21.10.47;	author thib;	state Exp;
branches;
next	1.89;

1.89
date	2009.01.17.18.50.25;	author grange;	state Exp;
branches;
next	1.88;

1.88
date	2008.08.13.15.45.30;	author thib;	state Exp;
branches;
next	1.87;

1.87
date	2008.06.09.23.38.37;	author millert;	state Exp;
branches;
next	1.86;

1.86
date	2008.01.17.11.31.56;	author fgsch;	state Exp;
branches;
next	1.85;

1.85
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.84;

1.84
date	2007.10.29.17.06.20;	author chl;	state Exp;
branches;
next	1.83;

1.83
date	2007.09.23.20.15.07;	author millert;	state Exp;
branches;
next	1.82;

1.82
date	2007.06.20.15.03.40;	author thib;	state Exp;
branches;
next	1.81;

1.81
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2007.05.17.23.46.28;	author thib;	state Exp;
branches;
next	1.79;

1.79
date	2007.05.09.17.04.22;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2007.04.13.17.09.22;	author thib;	state Exp;
branches;
next	1.77;

1.77
date	2007.04.10.17.47.56;	author miod;	state Exp;
branches;
next	1.76;

1.76
date	2007.04.10.11.21.17;	author pedro;	state Exp;
branches;
next	1.75;

1.75
date	2007.04.02.10.57.17;	author pedro;	state Exp;
branches;
next	1.74;

1.74
date	2007.03.21.17.29.32;	author thib;	state Exp;
branches;
next	1.73;

1.73
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.72;

1.72
date	2006.01.09.12.43.17;	author pedro;	state Exp;
branches;
next	1.71;

1.71
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.70;

1.70
date	2005.12.16.04.52.24;	author pedro;	state Exp;
branches;
next	1.69;

1.69
date	2005.11.19.02.18.02;	author pedro;	state Exp;
branches;
next	1.68;

1.68
date	2005.11.11.16.27.52;	author pedro;	state Exp;
branches;
next	1.67;

1.67
date	2005.07.24.05.43.36;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2005.07.03.20.14.03;	author drahn;	state Exp;
branches;
next	1.65;

1.65
date	2005.06.18.18.09.43;	author millert;	state Exp;
branches;
next	1.64;

1.64
date	2005.06.10.17.37.41;	author pedro;	state Exp;
branches;
next	1.63;

1.63
date	2005.05.28.02.02.50;	author pedro;	state Exp;
branches;
next	1.62;

1.62
date	2005.05.22.21.12.42;	author pedro;	state Exp;
branches;
next	1.61;

1.61
date	2005.04.23.15.13.57;	author pedro;	state Exp;
branches;
next	1.60;

1.60
date	2005.02.17.18.07.37;	author jfb;	state Exp;
branches;
next	1.59;

1.59
date	2004.09.18.22.01.18;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2004.07.25.23.09.19;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2004.06.25.00.54.28;	author tholo;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.24.19.35.27;	author tholo;	state Exp;
branches;
next	1.55;

1.55
date	2004.05.14.04.00.34;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2003.12.28.17.20.16;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2003.12.17.02.43.25;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2003.11.19.03.29.31;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	2003.11.19.02.46.04;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2003.08.15.20.32.21;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.11.21.53.10;	author tedu;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2003.05.26.18.33.17;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.23.12.46.42;	author art;	state Exp;
branches
	1.45.2.1
	1.45.4.1;
next	1.44;

1.44
date	2002.03.14.01.27.18;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2002.02.22.20.51.24;	author drahn;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.04.22.44.32;	author art;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.11.21.21.23.56;	author csapuntz;	state Exp;
branches;
next	1.38;

1.38
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2001.09.05.19.22.23;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.26.20.24.47;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2001.07.26.02.10.41;	author assar;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.27.04.58.49;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.23.02.07.57;	author csapuntz;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.04.15.11.47;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.25.21.31.17;	author csapuntz;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2001.03.01.20.54.36;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	2001.02.21.23.24.32;	author csapuntz;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.21.21.49.57;	author provos;	state Exp;
branches;
next	1.27;

1.27
date	99.03.09.21.16.28;	author art;	state Exp;
branches
	1.27.6.1;
next	1.26;

1.26
date	99.02.26.05.55.10;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	99.02.26.03.35.18;	author art;	state Exp;
branches;
next	1.24;

1.24
date	99.02.25.07.30.50;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	99.01.16.12.56.27;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	98.12.05.16.58.26;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	98.11.12.04.30.03;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	98.08.06.19.35.15;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	98.07.28.00.13.18;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.12.11.04.25.46;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	97.12.02.17.11.13;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	97.11.06.23.07.24;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	97.11.06.17.23.01;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	97.11.06.05.59.29;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	97.10.06.20.21.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.10.06.19.37.27;	author kstailey;	state Exp;
branches;
next	1.11;

1.11
date	97.10.06.15.27.40;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.07.03.17.49.49;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.05.30.08.35.18;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.11.12.15.39.04;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.10.27.22.30.35;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.06.27.06.42.09;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.06.24.03.35.04;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.05.22.11.47.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.02.27.22.56.14;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.21.33;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches;
next	;

1.27.6.1
date	2001.05.14.22.47.43;	author niklas;	state Exp;
branches;
next	1.27.6.2;

1.27.6.2
date	2001.07.04.11.00.57;	author niklas;	state Exp;
branches;
next	1.27.6.3;

1.27.6.3
date	2001.10.31.03.32.14;	author nate;	state Exp;
branches;
next	1.27.6.4;

1.27.6.4
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.27.6.5;

1.27.6.5
date	2001.12.05.01.19.55;	author niklas;	state Exp;
branches;
next	1.27.6.6;

1.27.6.6
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.27.6.7;

1.27.6.7
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.27.6.8;

1.27.6.8
date	2003.03.28.00.08.48;	author niklas;	state Exp;
branches;
next	1.27.6.9;

1.27.6.9
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.27.6.10;

1.27.6.10
date	2004.02.19.11.01.43;	author niklas;	state Exp;
branches;
next	1.27.6.11;

1.27.6.11
date	2004.06.05.23.13.12;	author niklas;	state Exp;
branches;
next	;

1.31.2.1
date	2001.06.07.04.42.54;	author jason;	state Exp;
branches;
next	;

1.41.2.1
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2003.05.20.04.18.42;	author tedu;	state Exp;
branches;
next	;

1.45.2.1
date	2003.08.22.00.02.56;	author brad;	state Exp;
branches;
next	;

1.45.4.1
date	2003.08.21.23.36.36;	author brad;	state Exp;
branches;
next	;

1.121.4.1
date	2016.07.14.03.37.42;	author guenther;	state Exp;
branches;
next	;
commitid	jesPiDlIsD7Q1tnT;

1.125.2.1
date	2016.07.14.03.37.14;	author guenther;	state Exp;
branches;
next	;
commitid	jarUjeEh3AfL8yTo;


desc
@@


1.134
log
@Add size to free()

ok deraadt@@ visa@@
@
text
@/*	$OpenBSD: ufs_vnops.c,v 1.133 2016/10/07 07:51:16 natano Exp $	*/
/*	$NetBSD: ufs_vnops.c,v 1.18 1996/05/11 18:28:04 mycroft Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_vnops.c	8.14 (Berkeley) 10/26/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/resourcevar.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/dirent.h>
#include <sys/lockf.h>
#include <sys/event.h>
#include <sys/poll.h>
#include <sys/specdev.h>
#include <sys/unistd.h>

#include <miscfs/fifofs/fifo.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>
#ifdef UFS_DIRHASH
#include <ufs/ufs/dirhash.h>
#endif
#include <ufs/ext2fs/ext2fs_extern.h>

#include <uvm/uvm_extern.h>

int ufs_chmod(struct vnode *, int, struct ucred *, struct proc *);
int ufs_chown(struct vnode *, uid_t, gid_t, struct ucred *, struct proc *);
int filt_ufsread(struct knote *, long);
int filt_ufswrite(struct knote *, long);
int filt_ufsvnode(struct knote *, long);
void filt_ufsdetach(struct knote *);

/*
 * A virgin directory (no blushing please).
 */
static struct dirtemplate mastertemplate = {
	0, 12, DT_DIR, 1, ".",
	0, DIRBLKSIZ - 12, DT_DIR, 2, ".."
};
static struct odirtemplate omastertemplate = {
	0, 12, 1, ".",
	0, DIRBLKSIZ - 12, 2, ".."
};

/*
 * Update the times in the inode
 */
void
ufs_itimes(struct vnode *vp)
{
	struct inode *ip;
	struct timespec ts;

	ip = VTOI(vp);
	if ((ip->i_flag & (IN_ACCESS | IN_CHANGE | IN_UPDATE)) == 0)
		return;

	if (vp->v_mount->mnt_flag & MNT_RDONLY)
		goto out;

#ifdef EXT2FS
	if (IS_EXT2_VNODE(ip->i_vnode)) {
		EXT2FS_ITIMES(ip);
		goto out;
	}
#endif

	if ((vp->v_type == VBLK || vp->v_type == VCHR) && !DOINGSOFTDEP(vp))
		ip->i_flag |= IN_LAZYMOD;
	else
		ip->i_flag |= IN_MODIFIED;

	getnanotime(&ts);
	if (ip->i_flag & IN_ACCESS) {
		DIP_ASSIGN(ip, atime, ts.tv_sec);
		DIP_ASSIGN(ip, atimensec, ts.tv_nsec);
	}
	if (ip->i_flag & IN_UPDATE) {
		DIP_ASSIGN(ip, mtime, ts.tv_sec);
		DIP_ASSIGN(ip, mtimensec, ts.tv_nsec);
	}
	if (ip->i_flag & IN_CHANGE) {
		DIP_ASSIGN(ip, ctime, ts.tv_sec);
		DIP_ASSIGN(ip, ctimensec, ts.tv_nsec);
		ip->i_modrev++;
	}

 out:
	ip->i_flag &= ~(IN_ACCESS | IN_CHANGE | IN_UPDATE);
}


/*
 * Create a regular file
 */
int
ufs_create(void *v)
{
	struct vop_create_args *ap = v;
	int error;

	error =
	    ufs_makeinode(MAKEIMODE(ap->a_vap->va_type, ap->a_vap->va_mode),
			  ap->a_dvp, ap->a_vpp, ap->a_cnp);
	if (error)
		return (error);
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);
	return (0);
}

/*
 * Mknod vnode call
 */
int
ufs_mknod(void *v)
{
	struct vop_mknod_args *ap = v;
	struct vattr *vap = ap->a_vap;
	struct vnode **vpp = ap->a_vpp;
	struct inode *ip;
	int error;

	if ((error =
	    ufs_makeinode(MAKEIMODE(vap->va_type, vap->va_mode),
	    ap->a_dvp, vpp, ap->a_cnp)) != 0)
		return (error);
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);
	ip = VTOI(*vpp);
	ip->i_flag |= IN_ACCESS | IN_CHANGE | IN_UPDATE;
	if (vap->va_rdev != VNOVAL) {
		/*
		 * Want to be able to use this to make badblock
		 * inodes, so don't truncate the dev number.
		 */
		DIP_ASSIGN(ip, rdev, vap->va_rdev);
	}
	/*
	 * Remove inode so that it will be reloaded by VFS_VGET and
	 * checked to see if it is an alias of an existing entry in
	 * the inode cache.
	 */
	vput(*vpp);
	(*vpp)->v_type = VNON;
	vgone(*vpp);
	*vpp = NULL;
	return (0);
}

/*
 * Open called.
 *
 * Nothing to do.
 */
int
ufs_open(void *v)
{
	struct vop_open_args *ap = v;
	struct inode *ip = VTOI(ap->a_vp);

	/*
	 * Files marked append-only must be opened for appending.
	 */
	if ((DIP(ip, flags) & APPEND) &&
	    (ap->a_mode & (FWRITE | O_APPEND)) == FWRITE)
		return (EPERM);

	if (ap->a_mode & O_TRUNC)
		ip->i_flag |= IN_CHANGE | IN_UPDATE;

	return (0);
}

/*
 * Close called.
 *
 * Update the times on the inode.
 */
int
ufs_close(void *v)
{
	struct vop_close_args *ap = v;
	struct vnode *vp = ap->a_vp;

	if (vp->v_usecount > 1)
		ufs_itimes(vp);
	return (0);
}

int
ufs_access(void *v)
{
	struct vop_access_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	mode_t mode = ap->a_mode;

	/*
	 * Disallow write attempts on read-only file systems;
	 * unless the file is a socket, fifo, or a block or
	 * character device resident on the file system.
	 */
	if (mode & VWRITE) {
		switch (vp->v_type) {
			int error;
		case VDIR:
		case VLNK:
		case VREG:
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);

			if ((error = getinoquota(ip)) != 0)
				return (error);
			break;
		case VBAD:
		case VBLK:
		case VCHR:
		case VSOCK:
		case VFIFO:
		case VNON:
			break;

		}
	}

	/* If immutable bit set, nobody gets to write it. */
	if ((mode & VWRITE) && (DIP(ip, flags) & IMMUTABLE))
		return (EPERM);

	if ((vp->v_mount->mnt_flag & MNT_NOPERM) &&
	    (vp->v_flag & VROOT) == 0)
		return (0);

	return (vaccess(vp->v_type, DIP(ip, mode), DIP(ip, uid), DIP(ip, gid),
	    mode, ap->a_cred));
}

int
ufs_getattr(void *v)
{
	struct vop_getattr_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct vattr *vap = ap->a_vap;

	ufs_itimes(vp);

	/*
	 * Copy from inode table
	 */
	vap->va_fsid = ip->i_dev;
	vap->va_fileid = ip->i_number;
	vap->va_mode = DIP(ip, mode) & ~IFMT;
	vap->va_nlink = ip->i_effnlink;
	vap->va_uid = DIP(ip, uid);
	vap->va_gid = DIP(ip, gid);
	vap->va_rdev = (dev_t) DIP(ip, rdev);
	vap->va_size = DIP(ip, size);
	vap->va_atime.tv_sec = DIP(ip, atime);
	vap->va_atime.tv_nsec = DIP(ip, atimensec);
	vap->va_mtime.tv_sec = DIP(ip, mtime);
	vap->va_mtime.tv_nsec = DIP(ip, mtimensec);
	vap->va_ctime.tv_sec = DIP(ip, ctime);
	vap->va_ctime.tv_nsec = DIP(ip, ctimensec);
	vap->va_flags = DIP(ip, flags);
	vap->va_gen = DIP(ip, gen);
	/* this doesn't belong here */
	if (vp->v_type == VBLK)
		vap->va_blocksize = BLKDEV_IOSIZE;
	else if (vp->v_type == VCHR)
		vap->va_blocksize = MAXBSIZE;
	else
		vap->va_blocksize = vp->v_mount->mnt_stat.f_iosize;
	vap->va_bytes = dbtob((u_quad_t) DIP(ip, blocks));
	vap->va_type = vp->v_type;
	vap->va_filerev = ip->i_modrev;
	return (0);
}

/*
 * Set attribute vnode op. called from several syscalls
 */
int
ufs_setattr(void *v)
{
	struct vop_setattr_args *ap = v;
	struct vattr *vap = ap->a_vap;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct ucred *cred = ap->a_cred;
	struct proc *p = ap->a_p;
	int error;
	long hint = NOTE_ATTRIB;
	u_quad_t oldsize;

	/*
	 * Check for unsettable attributes.
	 */
	if ((vap->va_type != VNON) || (vap->va_nlink != VNOVAL) ||
	    (vap->va_fsid != VNOVAL) || (vap->va_fileid != VNOVAL) ||
	    (vap->va_blocksize != VNOVAL) || (vap->va_rdev != VNOVAL) ||
	    ((int)vap->va_bytes != VNOVAL) || (vap->va_gen != VNOVAL)) {
		return (EINVAL);
	}
	if (vap->va_flags != VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
		if (cred->cr_uid != DIP(ip, uid) &&
		    (vp->v_mount->mnt_flag & MNT_NOPERM) == 0 &&
		    (error = suser_ucred(cred)))
			return (error);
		if (cred->cr_uid == 0) {
			if ((DIP(ip, flags) & (SF_IMMUTABLE | SF_APPEND)) &&
			    securelevel > 0)
				return (EPERM);
			DIP_ASSIGN(ip, flags, vap->va_flags);
		} else {
			if (DIP(ip, flags) & (SF_IMMUTABLE | SF_APPEND) ||
			    (vap->va_flags & UF_SETTABLE) != vap->va_flags)
				return (EPERM);
			DIP_AND(ip, flags, SF_SETTABLE);
			DIP_OR(ip, flags, vap->va_flags & UF_SETTABLE);
		}
		ip->i_flag |= IN_CHANGE;
		if (vap->va_flags & (IMMUTABLE | APPEND))
			return (0);
	}
	if (DIP(ip, flags) & (IMMUTABLE | APPEND))
		return (EPERM);
	/*
	 * Go through the fields and update if not VNOVAL.
	 */
	if (vap->va_uid != (uid_t)VNOVAL || vap->va_gid != (gid_t)VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
		error = ufs_chown(vp, vap->va_uid, vap->va_gid, cred, p);
		if (error)
			return (error);
	}
	if (vap->va_size != VNOVAL) {
		oldsize = DIP(ip, size);
		/*
		 * Disallow write attempts on read-only file systems;
		 * unless the file is a socket, fifo, or a block or
		 * character device resident on the file system.
		 */
		switch (vp->v_type) {
		case VDIR:
 			return (EISDIR);
		case VLNK:
		case VREG:
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
			break;
		default:
			break;
		}
 		if ((error = UFS_TRUNCATE(ip, vap->va_size, 0, cred)) != 0)
 			return (error);
		if (vap->va_size < oldsize)
			hint |= NOTE_TRUNCATE;
	}
	if ((vap->va_vaflags & VA_UTIMES_CHANGE) ||
	    vap->va_atime.tv_nsec != VNOVAL ||
	    vap->va_mtime.tv_nsec != VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
		if (cred->cr_uid != DIP(ip, uid) &&
		    (vp->v_mount->mnt_flag & MNT_NOPERM) == 0 &&
		    (error = suser_ucred(cred)) &&
		    ((vap->va_vaflags & VA_UTIMES_NULL) == 0 || 
		    (error = VOP_ACCESS(vp, VWRITE, cred, p))))
			return (error);
		if (vap->va_mtime.tv_nsec != VNOVAL)
			ip->i_flag |= IN_CHANGE | IN_UPDATE;
		else if (vap->va_vaflags & VA_UTIMES_CHANGE)
			ip->i_flag |= IN_CHANGE;
		if (vap->va_atime.tv_nsec != VNOVAL) {
			if (!(vp->v_mount->mnt_flag & MNT_NOATIME) ||
			    (ip->i_flag & (IN_CHANGE | IN_UPDATE)))
				ip->i_flag |= IN_ACCESS;
		}
		ufs_itimes(vp);
		if (vap->va_mtime.tv_nsec != VNOVAL) {
			DIP_ASSIGN(ip, mtime, vap->va_mtime.tv_sec);
			DIP_ASSIGN(ip, mtimensec, vap->va_mtime.tv_nsec);
		}
		if (vap->va_atime.tv_nsec != VNOVAL) {
			DIP_ASSIGN(ip, atime, vap->va_atime.tv_sec);
			DIP_ASSIGN(ip, atimensec, vap->va_atime.tv_nsec);
		}
		error = UFS_UPDATE(ip, 0);
		if (error)
			return (error);
	}
	error = 0;
	if (vap->va_mode != (mode_t)VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
		error = ufs_chmod(vp, (int)vap->va_mode, cred, p);
	}
	VN_KNOTE(vp, hint);
	return (error);
}

/*
 * Change the mode on a file.
 * Inode must be locked before calling.
 */
int
ufs_chmod(struct vnode *vp, int mode, struct ucred *cred, struct proc *p)
{
	struct inode *ip = VTOI(vp);
	int error;

	if (cred->cr_uid != DIP(ip, uid) &&
	    (vp->v_mount->mnt_flag & MNT_NOPERM) == 0 &&
	    (error = suser_ucred(cred)))
		return (error);
	if (cred->cr_uid &&
	    (vp->v_mount->mnt_flag & MNT_NOPERM) == 0) {
		if (vp->v_type != VDIR && (mode & S_ISTXT))
			return (EFTYPE);
		if (!groupmember(DIP(ip, gid), cred) && (mode & ISGID))
			return (EPERM);
	}
	DIP_AND(ip, mode, ~ALLPERMS);
	DIP_OR(ip, mode, mode & ALLPERMS);
	ip->i_flag |= IN_CHANGE;
	if ((vp->v_flag & VTEXT) && (DIP(ip, mode) & S_ISTXT) == 0)
		(void) uvm_vnp_uncache(vp);
	return (0);
}

/*
 * Perform chown operation on inode ip;
 * inode must be locked prior to call.
 */
int
ufs_chown(struct vnode *vp, uid_t uid, gid_t gid, struct ucred *cred,
    struct proc *p)
{
	struct inode *ip = VTOI(vp);
	uid_t ouid;
	gid_t ogid;
	int error = 0;
	daddr_t change;
	enum ufs_quota_flags quota_flags = 0;

	if (uid == (uid_t)VNOVAL)
		uid = DIP(ip, uid);
	if (gid == (gid_t)VNOVAL)
		gid = DIP(ip, gid);
	/*
	 * If we don't own the file, are trying to change the owner
	 * of the file, or are not a member of the target group,
	 * the caller must be superuser or the call fails.
	 */
	if ((cred->cr_uid != DIP(ip, uid) || uid != DIP(ip, uid) ||
	    (gid != DIP(ip, gid) && !groupmember(gid, cred))) &&
	    (vp->v_mount->mnt_flag & MNT_NOPERM) == 0 &&
	    (error = suser_ucred(cred)))
		return (error);
	ogid = DIP(ip, gid);
	ouid = DIP(ip, uid);
	change = DIP(ip, blocks);

	if (ouid == uid)
		quota_flags |= UFS_QUOTA_NOUID;
	
	if (ogid == gid)
		quota_flags |= UFS_QUOTA_NOGID;

	if ((error = getinoquota(ip)) != 0)
		return (error);
	(void) ufs_quota_free_blocks2(ip, change, cred, quota_flags);
	(void) ufs_quota_free_inode2(ip, cred, quota_flags);
	(void) ufs_quota_delete(ip);

	DIP_ASSIGN(ip, gid, gid);
	DIP_ASSIGN(ip, uid, uid);

	if ((error = getinoquota(ip)) != 0)
		goto error;

	if ((error = ufs_quota_alloc_blocks2(ip, change, cred, 
		 quota_flags)) != 0) 
		goto error;

	if ((error = ufs_quota_alloc_inode2(ip, cred ,
		 quota_flags)) != 0) {
		(void)ufs_quota_free_blocks2(ip, change, cred, 
		    quota_flags);		
		goto error;
	}

	if (getinoquota(ip))
		panic("chown: lost quota");

	if (ouid != uid || ogid != gid)
		ip->i_flag |= IN_CHANGE;
	if (ouid != uid && cred->cr_uid != 0 &&
	    (vp->v_mount->mnt_flag & MNT_NOPERM) == 0)
		DIP_AND(ip, mode, ~ISUID);
	if (ogid != gid && cred->cr_uid != 0 &&
	    (vp->v_mount->mnt_flag & MNT_NOPERM) == 0)
		DIP_AND(ip, mode, ~ISGID);
	return (0);

error:
	(void) ufs_quota_delete(ip);

	DIP_ASSIGN(ip, gid, ogid);
	DIP_ASSIGN(ip, uid, ouid);

	if (getinoquota(ip) == 0) {
		(void) ufs_quota_alloc_blocks2(ip, change, cred, 
		    quota_flags | UFS_QUOTA_FORCE);
		(void) ufs_quota_alloc_inode2(ip, cred,
		    quota_flags | UFS_QUOTA_FORCE);
		(void) getinoquota(ip);
	}
	return (error);

}

/* ARGSUSED */
int
ufs_ioctl(void *v)
{
#if 0
	struct vop_ioctl_args *ap = v;
#endif
	return (ENOTTY);
}

int
ufs_poll(void *v)
{
	struct vop_poll_args *ap = v;

	/*
	 * We should really check to see if I/O is possible.
	 */
	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
}

int
ufs_remove(void *v)
{
	struct vop_remove_args *ap = v;
	struct inode *ip;
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	int error;

	ip = VTOI(vp);
	if (vp->v_type == VDIR || (DIP(ip, flags) & (IMMUTABLE | APPEND)) ||
	    (DIP(VTOI(dvp), flags) & APPEND)) {
		error = EPERM;
		goto out;
	}
	error = ufs_dirremove(dvp, ip, ap->a_cnp->cn_flags, 0);
	VN_KNOTE(vp, NOTE_DELETE);
	VN_KNOTE(dvp, NOTE_WRITE);
 out:
	if (dvp == vp)
		vrele(vp);
	else
		vput(vp);
	vput(dvp);
	return (error);
}

/*
 * link vnode call
 */
int
ufs_link(void *v)
{
	struct vop_link_args *ap = v;
	struct vnode *dvp = ap->a_dvp;
	struct vnode *vp = ap->a_vp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
	struct inode *ip;
	struct direct newdir;
	int error;

#ifdef DIAGNOSTIC
	if ((cnp->cn_flags & HASBUF) == 0)
		panic("ufs_link: no name");
#endif
	if (vp->v_type == VDIR) {
		VOP_ABORTOP(dvp, cnp);
		error = EPERM;
		goto out2;
	}
	if (dvp->v_mount != vp->v_mount) {
		VOP_ABORTOP(dvp, cnp);
		error = EXDEV;
		goto out2;
	}
	if (dvp != vp && (error = vn_lock(vp, LK_EXCLUSIVE, p))) {
		VOP_ABORTOP(dvp, cnp);
		goto out2;
	}
	ip = VTOI(vp);
	if ((nlink_t) DIP(ip, nlink) >= LINK_MAX) {
		VOP_ABORTOP(dvp, cnp);
		error = EMLINK;
		goto out1;
	}
	if (DIP(ip, flags) & (IMMUTABLE | APPEND)) {
		VOP_ABORTOP(dvp, cnp);
		error = EPERM;
		goto out1;
	}
	ip->i_effnlink++;
	DIP_ADD(ip, nlink, 1);
	ip->i_flag |= IN_CHANGE;
	if (DOINGSOFTDEP(vp))
		softdep_change_linkcnt(ip, 0);
	if ((error = UFS_UPDATE(ip, !DOINGSOFTDEP(vp))) == 0) {
		ufs_makedirentry(ip, cnp, &newdir);
		error = ufs_direnter(dvp, vp, &newdir, cnp, NULL);
	}
	if (error) {
		ip->i_effnlink--;
		DIP_ADD(ip, nlink, -1);
		ip->i_flag |= IN_CHANGE;
		if (DOINGSOFTDEP(vp))
			softdep_change_linkcnt(ip, 0);
	}
	pool_put(&namei_pool, cnp->cn_pnbuf);
	VN_KNOTE(vp, NOTE_LINK);
	VN_KNOTE(dvp, NOTE_WRITE);
out1:
	if (dvp != vp)
		VOP_UNLOCK(vp, p);
out2:
	vput(dvp);
	return (error);
}

/*
 * Rename system call.
 * 	rename("foo", "bar");
 * is essentially
 *	unlink("bar");
 *	link("foo", "bar");
 *	unlink("foo");
 * but ``atomically''.  Can't do full commit without saving state in the
 * inode on disk which isn't feasible at this time.  Best we can do is
 * always guarantee the target exists.
 *
 * Basic algorithm is:
 *
 * 1) Bump link count on source while we're linking it to the
 *    target.  This also ensure the inode won't be deleted out
 *    from underneath us while we work (it may be truncated by
 *    a concurrent `trunc' or `open' for creation).
 * 2) Link source to destination.  If destination already exists,
 *    delete it first.
 * 3) Unlink source reference to inode if still around. If a
 *    directory was moved and the parent of the destination
 *    is different from the source, patch the ".." entry in the
 *    directory.
 */
int
ufs_rename(void *v)
{
	struct vop_rename_args *ap = v;
	struct vnode *tvp = ap->a_tvp;
	struct vnode *tdvp = ap->a_tdvp;
	struct vnode *fvp = ap->a_fvp;
	struct vnode *fdvp = ap->a_fdvp;
	struct componentname *tcnp = ap->a_tcnp;
	struct componentname *fcnp = ap->a_fcnp;
	struct proc *p = fcnp->cn_proc;
	struct inode *ip, *xp, *dp;
	struct direct newdir;
	int doingdirectory = 0, oldparent = 0, newparent = 0;
	int error = 0;

#ifdef DIAGNOSTIC
	if ((tcnp->cn_flags & HASBUF) == 0 ||
	    (fcnp->cn_flags & HASBUF) == 0)
		panic("ufs_rename: no name");
#endif
	/*
	 * Check for cross-device rename.
	 */
	if ((fvp->v_mount != tdvp->v_mount) ||
	    (tvp && (fvp->v_mount != tvp->v_mount))) {
		error = EXDEV;
abortit:
		VOP_ABORTOP(tdvp, tcnp);
		if (tdvp == tvp)
			vrele(tdvp);
		else
			vput(tdvp);
		if (tvp)
			vput(tvp);
		VOP_ABORTOP(fdvp, fcnp);
		vrele(fdvp);
		vrele(fvp);
		return (error);
	}

	if (tvp && ((DIP(VTOI(tvp), flags) & (IMMUTABLE | APPEND)) ||
	    (DIP(VTOI(tdvp), flags) & APPEND))) {
		error = EPERM;
		goto abortit;
	}

	/*
	 * Check if just deleting a link name or if we've lost a race.
	 * If another process completes the same rename after we've looked
	 * up the source and have blocked looking up the target, then the
	 * source and target inodes may be identical now although the
	 * names were never linked.
	 */
	if (fvp == tvp) {
		if (fvp->v_type == VDIR) {
			/*
			 * Linked directories are impossible, so we must
			 * have lost the race.  Pretend that the rename
			 * completed before the lookup.
			 */
			error = ENOENT;
			goto abortit;
		}

		/* Release destination completely. */
		VOP_ABORTOP(tdvp, tcnp);
		vput(tdvp);
		vput(tvp);

		/*
		 * Delete source.  There is another race now that everything
		 * is unlocked, but this doesn't cause any new complications.
		 * relookup() may find a file that is unrelated to the
		 * original one, or it may fail.  Too bad.
		 */
		vrele(fvp);
		fcnp->cn_flags &= ~MODMASK;
		fcnp->cn_flags |= LOCKPARENT | LOCKLEAF;
		if ((fcnp->cn_flags & SAVESTART) == 0)
			panic("ufs_rename: lost from startdir");
		fcnp->cn_nameiop = DELETE;
		if ((error = vfs_relookup(fdvp, &fvp, fcnp)) != 0)
			return (error);		/* relookup did vrele() */
		vrele(fdvp);
		return (VOP_REMOVE(fdvp, fvp, fcnp));
	}

	if ((error = vn_lock(fvp, LK_EXCLUSIVE, p)) != 0)
		goto abortit;

	/* fvp, tdvp, tvp now locked */
	dp = VTOI(fdvp);
	ip = VTOI(fvp);
	if ((nlink_t) DIP(ip, nlink) >= LINK_MAX) {
		VOP_UNLOCK(fvp, p);
		error = EMLINK;
		goto abortit;
	}
	if ((DIP(ip, flags) & (IMMUTABLE | APPEND)) ||
	    (DIP(dp, flags) & APPEND)) {
		VOP_UNLOCK(fvp, p);
		error = EPERM;
		goto abortit;
	}
	if ((DIP(ip, mode) & IFMT) == IFDIR) {
		error = VOP_ACCESS(fvp, VWRITE, tcnp->cn_cred, tcnp->cn_proc);
		if (!error && tvp)
			error = VOP_ACCESS(tvp, VWRITE, tcnp->cn_cred, tcnp->cn_proc);
		if (error) {
			VOP_UNLOCK(fvp, p);
			error = EACCES;
			goto abortit;
		}
		/*
		 * Avoid ".", "..", and aliases of "." for obvious reasons.
		 */
		if ((fcnp->cn_namelen == 1 && fcnp->cn_nameptr[0] == '.') ||
		    dp == ip ||
		    (fcnp->cn_flags & ISDOTDOT) ||
		    (tcnp->cn_flags & ISDOTDOT) ||
		    (ip->i_flag & IN_RENAME)) {
			VOP_UNLOCK(fvp, p);
			error = EINVAL;
			goto abortit;
		}
		ip->i_flag |= IN_RENAME;
		oldparent = dp->i_number;
		doingdirectory = 1;
	}
	VN_KNOTE(fdvp, NOTE_WRITE);		/* XXX right place? */

	/*
	 * When the target exists, both the directory
	 * and target vnodes are returned locked.
	 */
	dp = VTOI(tdvp);
	xp = NULL;
	if (tvp)
		xp = VTOI(tvp);

	/*
	 * 1) Bump link count while we're moving stuff
	 *    around.  If we crash somewhere before
	 *    completing our work, the link count
	 *    may be wrong, but correctable.
	 */
	ip->i_effnlink++;
	DIP_ADD(ip, nlink, 1);
	ip->i_flag |= IN_CHANGE;
	if (DOINGSOFTDEP(fvp))
		softdep_change_linkcnt(ip, 0);
	if ((error = UFS_UPDATE(ip, !DOINGSOFTDEP(fvp))) != 0) {
		VOP_UNLOCK(fvp, p);
		goto bad;
	}

	/*
	 * If ".." must be changed (ie the directory gets a new
	 * parent) then the source directory must not be in the
	 * directory hierarchy above the target, as this would
	 * orphan everything below the source directory. Also
	 * the user must have write permission in the source so
	 * as to be able to change "..". We must repeat the call 
	 * to namei, as the parent directory is unlocked by the
	 * call to checkpath().
	 */
	error = VOP_ACCESS(fvp, VWRITE, tcnp->cn_cred, tcnp->cn_proc);
	VOP_UNLOCK(fvp, p);

	/* tdvp and tvp locked */
	if (oldparent != dp->i_number)
		newparent = dp->i_number;
	if (doingdirectory && newparent) {
		if (error)	/* write access check above */
			goto bad;
		if (xp != NULL)
			vput(tvp);
		/*
		 * Compensate for the reference ufs_checkpath() loses.
		 */
		vref(tdvp);
		/* Only tdvp is locked */
		if ((error = ufs_checkpath(ip, dp, tcnp->cn_cred)) != 0) {
			vrele(tdvp);
			goto out;
		}
		if ((tcnp->cn_flags & SAVESTART) == 0)
			panic("ufs_rename: lost to startdir");
		if ((error = vfs_relookup(tdvp, &tvp, tcnp)) != 0)
			goto out;
		vrele(tdvp); /* relookup() acquired a reference */
		dp = VTOI(tdvp);
		xp = NULL;
		if (tvp)
			xp = VTOI(tvp);
	}
	/*
	 * 2) If target doesn't exist, link the target
	 *    to the source and unlink the source. 
	 *    Otherwise, rewrite the target directory
	 *    entry to reference the source inode and
	 *    expunge the original entry's existence.
	 */
	if (xp == NULL) {
		if (dp->i_dev != ip->i_dev)
			panic("rename: EXDEV");
		/*
		 * Account for ".." in new directory.
		 * When source and destination have the same
		 * parent we don't fool with the link count.
		 */
		if (doingdirectory && newparent) {
			if ((nlink_t) DIP(dp, nlink) >= LINK_MAX) {
				error = EMLINK;
				goto bad;
			}
			dp->i_effnlink++;
			DIP_ADD(dp, nlink, 1);
			dp->i_flag |= IN_CHANGE;
			if (DOINGSOFTDEP(tdvp))
				softdep_change_linkcnt(dp, 0);
			if ((error = UFS_UPDATE(dp, !DOINGSOFTDEP(tdvp))) 
			    != 0) {
				dp->i_effnlink--;
				DIP_ADD(dp, nlink, -1);
				dp->i_flag |= IN_CHANGE;
				if (DOINGSOFTDEP(tdvp))
					softdep_change_linkcnt(dp, 0);
				goto bad;
			}
		}
		ufs_makedirentry(ip, tcnp, &newdir);
		if ((error = ufs_direnter(tdvp, NULL, &newdir, tcnp, NULL)) != 0) {
			if (doingdirectory && newparent) {
				dp->i_effnlink--;
				DIP_ADD(dp, nlink, -1);
				dp->i_flag |= IN_CHANGE;
				if (DOINGSOFTDEP(tdvp))
					softdep_change_linkcnt(dp, 0);
				(void)UFS_UPDATE(dp, 1);
			}
			goto bad;
		}
		VN_KNOTE(tdvp, NOTE_WRITE);
		vput(tdvp);
	} else {
		if (xp->i_dev != dp->i_dev || xp->i_dev != ip->i_dev)
			panic("rename: EXDEV");
		/*
		 * Short circuit rename(foo, foo).
		 */
		if (xp->i_number == ip->i_number)
			panic("ufs_rename: same file");
		/*
		 * If the parent directory is "sticky", then the user must
		 * own the parent directory, or the destination of the rename,
		 * otherwise the destination may not be changed (except by
		 * root). This implements append-only directories.
		 */
		if ((DIP(dp, mode) & S_ISTXT) && tcnp->cn_cred->cr_uid != 0 &&
		    tcnp->cn_cred->cr_uid != DIP(dp, uid) &&
		    DIP(xp, uid )!= tcnp->cn_cred->cr_uid &&
		    (tdvp->v_mount->mnt_flag & MNT_NOPERM) == 0) {
			error = EPERM;
			goto bad;
		}
		/*
		 * Target must be empty if a directory and have no links
		 * to it. Also, ensure source and target are compatible
		 * (both directories, or both not directories).
		 */
		if ((DIP(xp, mode) & IFMT) == IFDIR) {
			if (xp->i_effnlink > 2 ||
			    !ufs_dirempty(xp, dp->i_number, tcnp->cn_cred)) {
				error = ENOTEMPTY;
				goto bad;
			}
			if (!doingdirectory) {
				error = ENOTDIR;
				goto bad;
			}
			cache_purge(tdvp);
		} else if (doingdirectory) {
			error = EISDIR;
			goto bad;
		}
		
		if ((error = ufs_dirrewrite(dp, xp, ip->i_number,
		    IFTODT(DIP(ip, mode)), (doingdirectory && newparent) ?
		    newparent : doingdirectory)) != 0)
			goto bad;
		if (doingdirectory) {
			if (!newparent) {
				dp->i_effnlink--;
				if (DOINGSOFTDEP(tdvp))
					softdep_change_linkcnt(dp, 0);
			}
			xp->i_effnlink--;
			if (DOINGSOFTDEP(tvp))
				softdep_change_linkcnt(xp, 0);
		}
		if (doingdirectory && !DOINGSOFTDEP(tvp)) {
			/*
			* Truncate inode. The only stuff left in the directory
			* is "." and "..". The "." reference is inconsequential
			* since we are quashing it. We have removed the "."
			* reference and the reference in the parent directory,
			* but there may be other hard links. The soft
			* dependency code will arrange to do these operations
			* after the parent directory entry has been deleted on
			* disk, so when running with that code we avoid doing
			* them now.
			*/
			if (!newparent) {
				DIP_ADD(dp, nlink, -1);
				dp->i_flag |= IN_CHANGE;
			}

			DIP_ADD(xp, nlink, -1);
			xp->i_flag |= IN_CHANGE;
			if ((error = UFS_TRUNCATE(VTOI(tvp), (off_t)0, IO_SYNC,
			    tcnp->cn_cred)) != 0)
				goto bad;
		}
		VN_KNOTE(tdvp, NOTE_WRITE);
		vput(tdvp);
		VN_KNOTE(tvp, NOTE_DELETE);
		vput(tvp);
		xp = NULL;
	}

	/*
	 * 3) Unlink the source.
	 */
	fcnp->cn_flags &= ~MODMASK;
	fcnp->cn_flags |= LOCKPARENT | LOCKLEAF;
	if ((fcnp->cn_flags & SAVESTART) == 0)
		panic("ufs_rename: lost from startdir");
	if ((error = vfs_relookup(fdvp, &fvp, fcnp)) != 0) {
		vrele(ap->a_fvp);
		return (error);
	}
	vrele(fdvp);
	if (fvp == NULL) {
		/*
		 * From name has disappeared.
		 */
		if (doingdirectory)
			panic("ufs_rename: lost dir entry");
		vrele(ap->a_fvp);
		return (0);
	}

	xp = VTOI(fvp);
	dp = VTOI(fdvp);

	/*
	 * Ensure that the directory entry still exists and has not
	 * changed while the new name has been entered. If the source is
	 * a file then the entry may have been unlinked or renamed. In
	 * either case there is no further work to be done. If the source
	 * is a directory then it cannot have been rmdir'ed; the IN_RENAME 
	 * flag ensures that it cannot be moved by another rename or removed
	 * by a rmdir.
	 */
	if (xp != ip) {
		if (doingdirectory)
			panic("ufs_rename: lost dir entry");
	} else {
		/*
		 * If the source is a directory with a
		 * new parent, the link count of the old
		 * parent directory must be decremented
		 * and ".." set to point to the new parent.
		 */
		if (doingdirectory && newparent) {
			xp->i_offset = mastertemplate.dot_reclen;
			ufs_dirrewrite(xp, dp, newparent, DT_DIR, 0);
			cache_purge(fdvp);
		}
		error = ufs_dirremove(fdvp, xp, fcnp->cn_flags, 0);
		xp->i_flag &= ~IN_RENAME;
	}
	VN_KNOTE(fvp, NOTE_RENAME);
	if (dp)
		vput(fdvp);
	if (xp)
		vput(fvp);
	vrele(ap->a_fvp);
	return (error);

bad:
	if (xp)
		vput(ITOV(xp));
	vput(ITOV(dp));
out:
	vrele(fdvp);
	if (doingdirectory)
		ip->i_flag &= ~IN_RENAME;
	if (vn_lock(fvp, LK_EXCLUSIVE, p) == 0) {
		ip->i_effnlink--;
		DIP_ADD(ip, nlink, -1);
		ip->i_flag |= IN_CHANGE;
		ip->i_flag &= ~IN_RENAME;
		if (DOINGSOFTDEP(fvp))
			softdep_change_linkcnt(ip, 0);
		vput(fvp);
	} else
		vrele(fvp);
	return (error);
}

/*
 * Mkdir system call
 */
int
ufs_mkdir(void *v)
{
	struct vop_mkdir_args *ap = v;
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct componentname *cnp = ap->a_cnp;
	struct inode *ip, *dp;
	struct vnode *tvp;
	struct buf *bp;
	struct direct newdir;
	struct dirtemplate dirtemplate, *dtp;
	int error, dmode, blkoff;

#ifdef DIAGNOSTIC
	if ((cnp->cn_flags & HASBUF) == 0)
		panic("ufs_mkdir: no name");
#endif
	dp = VTOI(dvp);
	if ((nlink_t) DIP(dp, nlink) >= LINK_MAX) {
		error = EMLINK;
		goto out;
	}
	dmode = vap->va_mode & 0777;
	dmode |= IFDIR;
	/*
	 * Must simulate part of ufs_makeinode here to acquire the inode,
	 * but not have it entered in the parent directory. The entry is
	 * made later after writing "." and ".." entries.
	 */
	if ((error = UFS_INODE_ALLOC(dp, dmode, cnp->cn_cred, &tvp)) != 0)
		goto out;

	ip = VTOI(tvp);

	DIP_ASSIGN(ip, uid, cnp->cn_cred->cr_uid);
	DIP_ASSIGN(ip, gid, DIP(dp, gid));

	if ((error = getinoquota(ip)) ||
	    (error = ufs_quota_alloc_inode(ip, cnp->cn_cred))) {
		pool_put(&namei_pool, cnp->cn_pnbuf);
		UFS_INODE_FREE(ip, ip->i_number, dmode);
		vput(tvp);
		vput(dvp);
		return (error);
	}

	ip->i_flag |= IN_ACCESS | IN_CHANGE | IN_UPDATE;
	DIP_ASSIGN(ip, mode, dmode);
	tvp->v_type = VDIR;	/* Rest init'd in getnewvnode(). */
	ip->i_effnlink = 2;
	DIP_ASSIGN(ip, nlink, 2);
	if (DOINGSOFTDEP(tvp))
		softdep_change_linkcnt(ip, 0);

	/*
	 * Bump link count in parent directory to reflect work done below.
	 * Should be done before reference is create so cleanup is 
	 * possible if we crash.
	 */
	dp->i_effnlink++;
	DIP_ADD(dp, nlink, 1);
	dp->i_flag |= IN_CHANGE;
	if (DOINGSOFTDEP(dvp))
		softdep_change_linkcnt(dp, 0);
	if ((error = UFS_UPDATE(dp, !DOINGSOFTDEP(dvp))) != 0)
		goto bad;

	/* 
	 * Initialize directory with "." and ".." from static template.
	 */
	if (dp->i_ump->um_maxsymlinklen > 0)
		dtp = &mastertemplate;
	else
		dtp = (struct dirtemplate *)&omastertemplate;
	dirtemplate = *dtp;
	dirtemplate.dot_ino = ip->i_number;
	dirtemplate.dotdot_ino = dp->i_number;

	if ((error = UFS_BUF_ALLOC(ip, (off_t)0, DIRBLKSIZ, cnp->cn_cred,
	    B_CLRBUF, &bp)) != 0)
		goto bad;
	DIP_ASSIGN(ip, size, DIRBLKSIZ);
	ip->i_flag |= IN_CHANGE | IN_UPDATE;
	uvm_vnp_setsize(tvp, DIP(ip, size));
	memcpy(bp->b_data, &dirtemplate, sizeof(dirtemplate));
	if (DOINGSOFTDEP(tvp)) {
		/*
		 * Ensure that the entire newly allocated block is a
		 * valid directory so that future growth within the
		 * block does not have to ensure that the block is
		 * written before the inode
		 */
		blkoff = DIRBLKSIZ;
		while (blkoff < bp->b_bcount) {
			((struct direct *)
			 (bp->b_data + blkoff))->d_reclen = DIRBLKSIZ;
			blkoff += DIRBLKSIZ;
		}
	}
	if ((error = UFS_UPDATE(ip, !DOINGSOFTDEP(tvp))) != 0) {
		(void)VOP_BWRITE(bp);
		goto bad;
	}

	/*
	 * Directory set up, now install its entry in the parent directory.
	 *
	 * If we are not doing soft dependencies, then we must write out the
	 * buffer containing the new directory body before entering the new
	 * name in the parent. If we are doing soft dependencies, then the
	 * buffer containing the new directory body will be passed to and
	 * released in the soft dependency code after the code has attached
	 * an appropriate ordering dependency to the buffer which ensures that
	 * the buffer is written before the new name is written in the parent.
	 */
	if (!DOINGSOFTDEP(dvp) && ((error = VOP_BWRITE(bp)) != 0))
		goto bad;
	ufs_makedirentry(ip, cnp, &newdir);
	error = ufs_direnter(dvp, tvp, &newdir, cnp, bp);
  
bad:
	if (error == 0) {
		VN_KNOTE(dvp, NOTE_WRITE | NOTE_LINK);
		*ap->a_vpp = tvp;
	} else {
		dp->i_effnlink--;
		DIP_ADD(dp, nlink, -1);
		dp->i_flag |= IN_CHANGE;
		if (DOINGSOFTDEP(dvp))
			softdep_change_linkcnt(dp, 0);
		/*
		 * No need to do an explicit VOP_TRUNCATE here, vrele will
		 * do this for us because we set the link count to 0.
		 */
		ip->i_effnlink = 0;
		DIP_ASSIGN(ip, nlink, 0);
		ip->i_flag |= IN_CHANGE;
		if (DOINGSOFTDEP(tvp))
			softdep_change_linkcnt(ip, 0);
		vput(tvp);
	}
out:
	pool_put(&namei_pool, cnp->cn_pnbuf);
	vput(dvp);

	return (error);
}

/*
 * Rmdir system call.
 */
int
ufs_rmdir(void *v)
{
	struct vop_rmdir_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	struct inode *ip, *dp;
	int error;

	ip = VTOI(vp);
	dp = VTOI(dvp);
	/*
	 * No rmdir "." or of mounted on directories.
	 */
	if (dp == ip || vp->v_mountedhere != NULL) {
		if (dp == ip)
			vrele(dvp);
		else
			vput(dvp);
		vput(vp);
		return (EINVAL);
	}
	/*
	 * Do not remove a directory that is in the process of being renamed.
	 * Verify the directory is empty (and valid). Rmdir ".." will not be
	 * valid since ".." will contain a reference to the current directory
	 * and thus be non-empty.
	 */
	error = 0;
	if (ip->i_flag & IN_RENAME) {
		error = EINVAL;
		goto out;
	}
	if (ip->i_effnlink != 2 ||
	    !ufs_dirempty(ip, dp->i_number, cnp->cn_cred)) {
		error = ENOTEMPTY;
		goto out;
	}
	if ((DIP(dp, flags) & APPEND) ||
		(DIP(ip, flags) & (IMMUTABLE | APPEND))) {
		error = EPERM;
		goto out;
	}
	/*
	 * Delete reference to directory before purging
	 * inode.  If we crash in between, the directory
	 * will be reattached to lost+found,
	 */
	dp->i_effnlink--;
	ip->i_effnlink--;
	if (DOINGSOFTDEP(vp)) {
		softdep_change_linkcnt(dp, 0);
		softdep_change_linkcnt(ip, 0);
	}
	if ((error = ufs_dirremove(dvp, ip, cnp->cn_flags, 1)) != 0) {
		dp->i_effnlink++;
		ip->i_effnlink++;
		if (DOINGSOFTDEP(vp)) {
			softdep_change_linkcnt(dp, 0);
			softdep_change_linkcnt(ip, 0);
		}
		goto out;
	}

	VN_KNOTE(dvp, NOTE_WRITE | NOTE_LINK);
	cache_purge(dvp);
	/*
	 * Truncate inode. The only stuff left in the directory is "." and
	 * "..". The "." reference is inconsequential since we are quashing
	 * it. The soft dependency code will arrange to do these operations
	 * after the parent directory entry has been deleted on disk, so
	 * when running with that code we avoid doing them now.
	 */
	if (!DOINGSOFTDEP(vp)) {
		int ioflag;

		DIP_ADD(dp, nlink, -1);
		dp->i_flag |= IN_CHANGE;
		DIP_ADD(ip, nlink, -1);
		ip->i_flag |= IN_CHANGE;
		ioflag = DOINGASYNC(vp) ? 0 : IO_SYNC;
		error = UFS_TRUNCATE(ip, (off_t)0, ioflag, cnp->cn_cred);
	}
	cache_purge(vp);
#ifdef UFS_DIRHASH
	/* Kill any active hash; i_effnlink == 0, so it will not come back. */
	if (ip->i_dirhash != NULL)
		ufsdirhash_free(ip);
#endif

out:
	VN_KNOTE(vp, NOTE_DELETE);
	vput(dvp);
	vput(vp);
	return (error);
}

/*
 * symlink -- make a symbolic link
 */
int
ufs_symlink(void *v)
{
	struct vop_symlink_args *ap = v;
	struct vnode *vp, **vpp = ap->a_vpp;
	struct inode *ip;
	int len, error;

	error = ufs_makeinode(IFLNK | ap->a_vap->va_mode, ap->a_dvp,
	    vpp, ap->a_cnp);
	if (error)
		return (error);
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);
	vp = *vpp;
	ip = VTOI(vp);
	len = strlen(ap->a_target);
	if (len < ip->i_ump->um_maxsymlinklen) {
		memcpy(SHORTLINK(ip), ap->a_target, len);
		DIP_ASSIGN(ip, size, len);
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
	} else
		error = vn_rdwr(UIO_WRITE, vp, ap->a_target, len, (off_t)0,
		    UIO_SYSSPACE, IO_NODELOCKED, ap->a_cnp->cn_cred, NULL,
		    curproc);
	vput(vp);
	return (error);
}

/*
 * Vnode op for reading directories.
 * 
 * This routine converts the on-disk struct direct entries to the
 * struct dirent entries expected by userland and the rest of the kernel.
 */
int
ufs_readdir(void *v)
{
	struct vop_readdir_args *ap = v;
	struct uio auio, *uio = ap->a_uio;
	struct iovec aiov;
	union {
		struct	dirent dn;
		char __pad[roundup(sizeof(struct dirent), 8)];
	} u;
	off_t off = uio->uio_offset;
	struct direct *dp;
	char *edp;
	caddr_t diskbuf;
	size_t count, entries;
	int bufsize, readcnt, error;
#if (BYTE_ORDER == LITTLE_ENDIAN)
	int ofmt = VTOI(ap->a_vp)->i_ump->um_maxsymlinklen == 0;
#endif

	if (uio->uio_rw != UIO_READ)
		return (EINVAL);

	count = uio->uio_resid;
	entries = (uio->uio_offset + count) & (DIRBLKSIZ - 1);

	/* Make sure we don't return partial entries. */
	if (count <= entries)
		return (EINVAL);

	/*
	 * Convert and copy back the on-disk struct direct format to
	 * the user-space struct dirent format, one entry at a time
	 */

	/* read from disk, stopping on a block boundary, max 64kB */
	readcnt = min(count, 64*1024) - entries;

	auio = *uio;
	auio.uio_iov = &aiov;
	auio.uio_iovcnt = 1;
	auio.uio_resid = readcnt;
	auio.uio_segflg = UIO_SYSSPACE;
	aiov.iov_len = readcnt;
	bufsize = readcnt;
	diskbuf = malloc(bufsize, M_TEMP, M_WAITOK);
	aiov.iov_base = diskbuf;
	error = VOP_READ(ap->a_vp, &auio, 0, ap->a_cred);
	readcnt -= auio.uio_resid;
	dp = (struct direct *)diskbuf;
	edp = &diskbuf[readcnt];

	memset(&u, 0, sizeof(u));

	/*
	 * While
	 *  - we haven't failed to VOP_READ or uiomove()
	 *  - there's space in the read buf for the head of an entry
	 *  - that entry has a valid d_reclen, and
	 *  - there's space for the *entire* entry
	 * then we're good to process this one.
	 */
	while (error == 0 &&
	    (char *)dp + offsetof(struct direct, d_name) < edp &&
	    dp->d_reclen > offsetof(struct direct, d_name) &&
	    (char *)dp + dp->d_reclen <= edp) {
		u.dn.d_reclen = roundup(dp->d_namlen+1 +
		    offsetof(struct dirent, d_name), 8);
		if (u.dn.d_reclen > uio->uio_resid)
			break;
		off += dp->d_reclen;
		u.dn.d_off = off;
		u.dn.d_fileno = dp->d_ino;
#if (BYTE_ORDER == LITTLE_ENDIAN)
		if (ofmt) {
			u.dn.d_type = dp->d_namlen;
			u.dn.d_namlen = dp->d_type;
		} else
#endif
		{
			u.dn.d_type = dp->d_type;
			u.dn.d_namlen = dp->d_namlen;
		}
		memcpy(u.dn.d_name, dp->d_name, u.dn.d_namlen);
		memset(u.dn.d_name + u.dn.d_namlen, 0, u.dn.d_reclen
		    - u.dn.d_namlen - offsetof(struct dirent, d_name));

		error = uiomove(&u.dn, u.dn.d_reclen, uio);
		dp = (struct direct *)((char *)dp + dp->d_reclen);
	}

	/*
	 * If there was room for an entry in what we read but its
	 * d_reclen is bogus, fail
	 */
	if ((char *)dp + offsetof(struct direct, d_name) < edp &&
	    dp->d_reclen <= offsetof(struct direct, d_name))
		error = EIO;
	free(diskbuf, M_TEMP, bufsize);

	uio->uio_offset = off;
	*ap->a_eofflag = DIP(VTOI(ap->a_vp), size) <= off;

	return (error);
}

/*
 * Return target name of a symbolic link
 */
int
ufs_readlink(void *v)
{
	struct vop_readlink_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	u_int64_t isize;

	isize = DIP(ip, size);
	if (isize < ip->i_ump->um_maxsymlinklen ||
	    (ip->i_ump->um_maxsymlinklen == 0 && DIP(ip, blocks) == 0)) {
		return (uiomove((char *)SHORTLINK(ip), isize, ap->a_uio));
	}
	return (VOP_READ(vp, ap->a_uio, 0, ap->a_cred));
}

/*
 * Lock an inode. If its already locked, set the WANT bit and sleep.
 */
int
ufs_lock(void *v)
{
	struct vop_lock_args *ap = v;
	struct vnode *vp = ap->a_vp;

	return rrw_enter(&VTOI(vp)->i_lock, ap->a_flags & LK_RWFLAGS);
}

/*
 * Unlock an inode.  If WANT bit is on, wakeup.
 */
int
ufs_unlock(void *v)
{
	struct vop_unlock_args *ap = v;
	struct vnode *vp = ap->a_vp;

	rrw_exit(&VTOI(vp)->i_lock);
	return 0;
}

/*
 * Check for a locked inode.
 */
int
ufs_islocked(void *v)
{
	struct vop_islocked_args *ap = v;

	return rrw_status(&VTOI(ap->a_vp)->i_lock);
}

/*
 * Calculate the logical to physical mapping if not done already,
 * then call the device strategy routine.
 */
int
ufs_strategy(void *v)
{
	struct vop_strategy_args *ap = v;
	struct buf *bp = ap->a_bp;
	struct vnode *vp = bp->b_vp;
	struct inode *ip;
	int error;
	int s;

	ip = VTOI(vp);
	if (vp->v_type == VBLK || vp->v_type == VCHR)
		panic("ufs_strategy: spec");
	if (bp->b_blkno == bp->b_lblkno) {
		error = VOP_BMAP(vp, bp->b_lblkno, NULL, &bp->b_blkno,
				 NULL);
		if (error) {
			bp->b_error = error;
			bp->b_flags |= B_ERROR;
			s = splbio();
			biodone(bp);
			splx(s);
			return (error);
		}
		if (bp->b_blkno == -1)
			clrbuf(bp);
	}
	if (bp->b_blkno == -1) {
		s = splbio();
		biodone(bp);
		splx(s);
		return (0);
	}
	vp = ip->i_devvp;
	bp->b_dev = vp->v_rdev;
	(vp->v_op->vop_strategy)(ap);
	return (0);
}

/*
 * Print out the contents of an inode.
 */
int
ufs_print(void *v)
{
#ifdef DIAGNOSTIC
	struct vop_print_args *ap = v;

	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);

	printf("tag VT_UFS, ino %u, on dev %d, %d", ip->i_number,
		major(ip->i_dev), minor(ip->i_dev));
	printf(" flags 0x%x, effnlink %d, nlink %d\n",
	   ip->i_flag, ip->i_effnlink, DIP(ip, nlink));
	printf("\tmode 0%o, owner %d, group %d, size %lld",
	    DIP(ip, mode), DIP(ip, uid), DIP(ip, gid), DIP(ip, size));

#ifdef FIFO
	if (vp->v_type == VFIFO)
		fifo_printinfo(vp);
#endif /* FIFO */
	printf("\n");

#endif /* DIAGNOSTIC */

	return (0);
}

/*
 * Read wrapper for special devices.
 */
int
ufsspec_read(void *v)
{
	struct vop_read_args *ap = v;

	/*
	 * Set access flag.
	 */
	VTOI(ap->a_vp)->i_flag |= IN_ACCESS;
	return (spec_read(ap));
}

/*
 * Write wrapper for special devices.
 */
int
ufsspec_write(void *v)
{
	struct vop_write_args *ap = v;

	/*
	 * Set update and change flags.
	 */
	VTOI(ap->a_vp)->i_flag |= IN_CHANGE | IN_UPDATE;
	return (spec_write(ap));
}

/*
 * Close wrapper for special devices.
 *
 * Update the times on the inode then do device close.
 */
int
ufsspec_close(void *v)
{
	struct vop_close_args *ap = v;
	struct vnode *vp = ap->a_vp;

	if (vp->v_usecount > 1)
		ufs_itimes(vp);
	return (spec_close(ap));
}

#ifdef FIFO
/*
 * Read wrapper for fifo's
 */
int
ufsfifo_read(void *v)
{
	struct vop_read_args *ap = v;

	/*
	 * Set access flag.
	 */
	VTOI(ap->a_vp)->i_flag |= IN_ACCESS;
	return (fifo_read(ap));
}

/*
 * Write wrapper for fifo's.
 */
int
ufsfifo_write(void *v)
{
	struct vop_write_args *ap = v;

	/*
	 * Set update and change flags.
	 */
	VTOI(ap->a_vp)->i_flag |= IN_CHANGE | IN_UPDATE;
	return (fifo_write(ap));
}

/*
 * Close wrapper for fifo's.
 *
 * Update the times on the inode then do device close.
 */
int
ufsfifo_close(void *v)
{
	struct vop_close_args *ap = v;
	struct vnode *vp = ap->a_vp;

	if (vp->v_usecount > 1)
		ufs_itimes(vp);
	return (fifo_close(ap));
}
#endif /* FIFO */

/*
 * Return POSIX pathconf information applicable to ufs filesystems.
 */
int
ufs_pathconf(void *v)
{
	struct vop_pathconf_args *ap = v;
	int error = 0;

	switch (ap->a_name) {
	case _PC_LINK_MAX:
		*ap->a_retval = LINK_MAX;
		break;
	case _PC_NAME_MAX:
		*ap->a_retval = NAME_MAX;
		break;
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		break;
	case _PC_NO_TRUNC:
		*ap->a_retval = 1;
		break;
	case _PC_ALLOC_SIZE_MIN:
		*ap->a_retval = ap->a_vp->v_mount->mnt_stat.f_bsize;
		break;
	case _PC_FILESIZEBITS:
		*ap->a_retval = 64;
		break;
	case _PC_REC_INCR_XFER_SIZE:
		*ap->a_retval = ap->a_vp->v_mount->mnt_stat.f_iosize;
		break;
	case _PC_REC_MAX_XFER_SIZE:
		*ap->a_retval = -1; /* means ``unlimited'' */
		break;
	case _PC_REC_MIN_XFER_SIZE:
		*ap->a_retval = ap->a_vp->v_mount->mnt_stat.f_iosize;
		break;
	case _PC_REC_XFER_ALIGN:
		*ap->a_retval = PAGE_SIZE;
		break;
	case _PC_SYMLINK_MAX:
		*ap->a_retval = MAXPATHLEN;
		break;
	case _PC_2_SYMLINKS:
		*ap->a_retval = 1;
		break;
	case _PC_TIMESTAMP_RESOLUTION:
		*ap->a_retval = 1;
		break;
	default:
		error = EINVAL;
		break;
	}

	return (error);
}

/*
 * Advisory record locking support
 */
int
ufs_advlock(void *v)
{
	struct vop_advlock_args *ap = v;
	struct inode *ip = VTOI(ap->a_vp);

	return (lf_advlock(&ip->i_lockf, DIP(ip, size), ap->a_id, ap->a_op,
	    ap->a_fl, ap->a_flags));
}

/*
 * Allocate a new inode.
 */
int
ufs_makeinode(int mode, struct vnode *dvp, struct vnode **vpp,
    struct componentname *cnp)
{
	struct inode *ip, *pdir;
	struct direct newdir;
	struct vnode *tvp;
	int error;

	pdir = VTOI(dvp);
#ifdef DIAGNOSTIC
	if ((cnp->cn_flags & HASBUF) == 0)
		panic("ufs_makeinode: no name");
#endif
	*vpp = NULL;
	if ((mode & IFMT) == 0)
		mode |= IFREG;

	if ((error = UFS_INODE_ALLOC(pdir, mode, cnp->cn_cred, &tvp)) != 0) {
		pool_put(&namei_pool, cnp->cn_pnbuf);
		vput(dvp);
		return (error);
	}

	ip = VTOI(tvp);

	DIP_ASSIGN(ip, gid, DIP(pdir, gid));
	DIP_ASSIGN(ip, uid, cnp->cn_cred->cr_uid);

	if ((error = getinoquota(ip)) ||
	    (error = ufs_quota_alloc_inode(ip, cnp->cn_cred))) {
		pool_put(&namei_pool, cnp->cn_pnbuf);
		UFS_INODE_FREE(ip, ip->i_number, mode);
		vput(tvp);
		vput(dvp);
		return (error);
	}

	ip->i_flag |= IN_ACCESS | IN_CHANGE | IN_UPDATE;
	DIP_ASSIGN(ip, mode, mode);
	tvp->v_type = IFTOVT(mode);	/* Rest init'd in getnewvnode(). */
	ip->i_effnlink = 1;
	DIP_ASSIGN(ip, nlink, 1);
	if (DOINGSOFTDEP(tvp))
		softdep_change_linkcnt(ip, 0);
	if ((DIP(ip, mode) & ISGID) &&
		!groupmember(DIP(ip, gid), cnp->cn_cred) &&
	    (dvp->v_mount->mnt_flag & MNT_NOPERM) == 0 &&
	    suser_ucred(cnp->cn_cred))
		DIP_AND(ip, mode, ~ISGID);

	/*
	 * Make sure inode goes to disk before directory entry.
	 */
	if ((error = UFS_UPDATE(ip, !DOINGSOFTDEP(tvp))) != 0)
		goto bad;

	ufs_makedirentry(ip, cnp, &newdir);
	if ((error = ufs_direnter(dvp, tvp, &newdir, cnp, NULL)) != 0)
		goto bad;

	if ((cnp->cn_flags & SAVESTART) == 0)
		pool_put(&namei_pool, cnp->cn_pnbuf);
	vput(dvp);
	*vpp = tvp;
	return (0);

bad:
	/*
	 * Write error occurred trying to update the inode
	 * or the directory so must deallocate the inode.
	 */
	pool_put(&namei_pool, cnp->cn_pnbuf);
	vput(dvp);
	ip->i_effnlink = 0;
	DIP_ASSIGN(ip, nlink, 0);
	ip->i_flag |= IN_CHANGE;
	if (DOINGSOFTDEP(tvp))
		softdep_change_linkcnt(ip, 0);
	tvp->v_type = VNON;
	vput(tvp);

	return (error);
}

struct filterops ufsread_filtops = 
	{ 1, NULL, filt_ufsdetach, filt_ufsread };
struct filterops ufswrite_filtops = 
	{ 1, NULL, filt_ufsdetach, filt_ufswrite };
struct filterops ufsvnode_filtops = 
	{ 1, NULL, filt_ufsdetach, filt_ufsvnode };

int
ufs_kqfilter(void *v)
{
	struct vop_kqfilter_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct knote *kn = ap->a_kn;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &ufsread_filtops;
		break;
	case EVFILT_WRITE:
		kn->kn_fop = &ufswrite_filtops;
		break;
	case EVFILT_VNODE:
		kn->kn_fop = &ufsvnode_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)vp;

	SLIST_INSERT_HEAD(&vp->v_selectinfo.si_note, kn, kn_selnext);

	return (0);
}

void
filt_ufsdetach(struct knote *kn)
{
	struct vnode *vp = (struct vnode *)kn->kn_hook;

	SLIST_REMOVE(&vp->v_selectinfo.si_note, kn, knote, kn_selnext);
}

int
filt_ufsread(struct knote *kn, long hint)
{
	struct vnode *vp = (struct vnode *)kn->kn_hook;
	struct inode *ip = VTOI(vp);

	/*
	 * filesystem is gone, so set the EOF flag and schedule 
	 * the knote for deletion.
	 */
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
		return (1);
	}

	kn->kn_data = DIP(ip, size) - kn->kn_fp->f_offset;
	if (kn->kn_data == 0 && kn->kn_sfflags & NOTE_EOF) {
		kn->kn_fflags |= NOTE_EOF;
		return (1);
	}

	return (kn->kn_data != 0);
}

int
filt_ufswrite(struct knote *kn, long hint)
{
	/*
	 * filesystem is gone, so set the EOF flag and schedule 
	 * the knote for deletion.
	 */
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
		return (1);
	}

	kn->kn_data = 0;
	return (1);
}

int
filt_ufsvnode(struct knote *kn, long hint)
{
	if (kn->kn_sfflags & hint)
		kn->kn_fflags |= hint;
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= EV_EOF;
		return (1);
	}
	return (kn->kn_fflags != 0);
}
@


1.133
log
@Extra parentheses in conditional; no binary change.
from brynet, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.132 2016/10/06 21:00:00 natano Exp $	*/
d1435 1
a1435 1
	int readcnt, error;
d1464 2
a1465 1
	diskbuf = malloc(readcnt, M_TEMP, M_WAITOK);
d1518 1
a1518 1
	free(diskbuf, M_TEMP, 0);
@


1.132
log
@On noperm mount points honor the permissions of the root directory, so
access can be locked down.

ok deraadt tb
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.131 2016/09/10 16:53:30 natano Exp $	*/
d277 1
a277 1
	if (vp->v_mount->mnt_flag & MNT_NOPERM &&
@


1.131
log
@Add a noperm mount flag for FFS to be used for building release sets
without root privileges. This is only the kernel/mount flag; additional
work in the build Makefile's will be necessary such that the files in
$DESTDIR are created with correct permissions.

tedu couldn't find anything wrong with it in a quick review
idea & ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.130 2016/08/10 08:04:57 natano Exp $	*/
d277 2
a278 1
	if (vp->v_mount->mnt_flag & MNT_NOPERM)
@


1.130
log
@ufs_vinit() should really be called ffs_vinit(); it's only called from
ffs code.
ok mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.129 2016/07/14 03:34:28 guenther Exp $	*/
d277 3
d355 1
d415 1
d463 1
d466 2
a467 1
	if (cred->cr_uid) {
d507 1
d548 2
a549 1
	if (ouid != uid && cred->cr_uid != 0)
d551 2
a552 1
	if (ogid != gid && cred->cr_uid != 0)
d978 2
a979 1
		    DIP(xp, uid )!= tcnp->cn_cred->cr_uid) {
d1866 1
@


1.129
log
@ufs_readdir() buffer was meant to be limited to 64kB; reversed test
permitted very big mallocs to panic the kernel.

reported by Tim Newsham
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.128 2016/06/19 11:54:34 natano Exp $	*/
a1802 66
}

/*
 * Initialize the vnode associated with a new inode, handle aliased
 * vnodes.
 */
int
ufs_vinit(struct mount *mntp, struct vops *specops, struct vops *fifoops,
    struct vnode **vpp)
{
	struct inode *ip;
	struct vnode *vp, *nvp;
	struct timeval mtv;

	vp = *vpp;
	ip = VTOI(vp);
	switch(vp->v_type = IFTOVT(DIP(ip, mode))) {
	case VCHR:
	case VBLK:
		vp->v_op = specops;
		if ((nvp = checkalias(vp, DIP(ip, rdev), mntp)) != NULL) {
			/*
			 * Discard unneeded vnode, but save its inode.
			 * Note that the lock is carried over in the inode
			 * to the replacement vnode.
			 */
			nvp->v_data = vp->v_data;
			vp->v_data = NULL;
			vp->v_op = &spec_vops;
#ifdef VFSLCKDEBUG
			vp->v_flag &= ~VLOCKSWORK;
#endif
			vrele(vp);
			vgone(vp);
			/*
			 * Reinitialize aliased inode.
			 */
			vp = nvp;
			ip->i_vnode = vp;
		}
		break;
	case VFIFO:
#ifdef FIFO
		vp->v_op = fifoops;
		break;
#else
		return (EOPNOTSUPP);
#endif
	case VNON:
	case VBAD:
	case VSOCK:
	case VLNK:
	case VDIR:
	case VREG:
		break;
	}
	if (ip->i_number == ROOTINO)
		vp->v_flag |= VROOT;
	/*
	 * Initialize modrev times
	 */
	getmicrouptime(&mtv);
	ip->i_modrev = (u_quad_t)mtv.tv_sec << 32;
	ip->i_modrev |= (u_quad_t)mtv.tv_usec * 4294;
	*vpp = vp;
	return (0);
@


1.128
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.127 2016/03/19 12:04:16 natano Exp $	*/
d1444 1
a1444 1
	readcnt = max(count, 64*1024) - entries;
@


1.127
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.126 2016/02/27 18:50:38 natano Exp $	*/
d1541 1
a1541 1
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags, NULL));
d1553 2
a1554 1
	return (lockmgr(&VTOI(vp)->i_lock, LK_RELEASE, NULL));
d1565 1
a1565 1
	return (lockstatus(&VTOI(ap->a_vp)->i_lock));
@


1.126
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.125 2016/02/16 17:56:12 stefan Exp $	*/
d676 1
a676 1
		VOP_UNLOCK(vp, 0, p);
d801 1
a801 1
		VOP_UNLOCK(fvp, 0, p);
d807 1
a807 1
		VOP_UNLOCK(fvp, 0, p);
d816 1
a816 1
			VOP_UNLOCK(fvp, 0, p);
d828 1
a828 1
			VOP_UNLOCK(fvp, 0, p);
d859 1
a859 1
		VOP_UNLOCK(fvp, 0, p);
d874 1
a874 1
	VOP_UNLOCK(fvp, 0, p);
d1553 1
a1553 1
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags | LK_RELEASE, NULL));
@


1.125
log
@Convert to uiomove. From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.124 2016/02/04 12:45:03 mikeb Exp $	*/
d1192 1
a1192 1
	if (dvp->v_mount->mnt_maxsymlinklen > 0)
d1388 1
d1390 1
a1390 2
	if (len < vp->v_mount->mnt_maxsymlinklen) {
		ip = VTOI(vp);
d1425 1
a1425 1
	int ofmt = ap->a_vp->v_mount->mnt_maxsymlinklen <= 0;
d1525 2
a1526 2
	if (isize < vp->v_mount->mnt_maxsymlinklen ||
	    (vp->v_mount->mnt_maxsymlinklen == 0 && DIP(ip, blocks) == 0)) {
@


1.125.2.1
log
@backport 1.129

ufs_readdir() buffer was meant to be limited to 64kB; reversed test
permitted very big mallocs to panic the kernel.

reported by Tim Newsham
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.125 2016/02/16 17:56:12 stefan Exp $	*/
d1444 1
a1444 1
	readcnt = min(count, 64*1024) - entries;
@


1.124
log
@Prevent signed overflow when calculating i_modrev initial value

Reported and fixed by Martin Natano <natano at natano ! net>, thanks!
ok stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.123 2015/12/08 15:31:01 tedu Exp $	*/
d1494 1
a1494 1
		error = uiomovei(&u.dn, u.dn.d_reclen, uio);
d1522 1
a1522 1
	int isize;
d1527 1
a1527 1
		return (uiomovei((char *)SHORTLINK(ip), isize, ap->a_uio));
@


1.123
log
@correct errant spacing here before it continues spreading
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.122 2015/09/23 15:37:26 tedu Exp $	*/
a80 18
union _qcvt {
	int64_t	qcvt;
	int32_t val[2];
};

#define SETHIGH(q, h) { \
	union _qcvt tmp; \
	tmp.qcvt = (q); \
	tmp.val[_QUAD_HIGHWORD] = (h); \
	(q) = tmp.qcvt; \
}
#define SETLOW(q, l) { \
	union _qcvt tmp; \
	tmp.qcvt = (q); \
	tmp.val[_QUAD_LOWWORD] = (l); \
	(q) = tmp.qcvt; \
}

d1864 2
a1865 2
	SETHIGH(ip->i_modrev, mtv.tv_sec);
	SETLOW(ip->i_modrev, mtv.tv_usec * 4294);
@


1.122
log
@remove lockmgr_printinfo stubs. from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.121 2015/04/17 04:43:21 guenther Exp $	*/
d185 1
a185 1
        struct vnode **vpp = ap->a_vpp;
d190 2
a191 2
	     ufs_makeinode(MAKEIMODE(vap->va_type, vap->va_mode),
			   ap->a_dvp, vpp, ap->a_cnp)) != 0)
d945 1
a945 1
                               softdep_change_linkcnt(dp, 0);
d1012 3
a1014 3
                   IFTODT(DIP(ip, mode)), (doingdirectory && newparent) ?
		   newparent : doingdirectory)) != 0)
                        goto bad;
d1026 1
a1026 1
		       /*
d1029 8
a1036 8
                        * since we are quashing it. We have removed the "."
                        * reference and the reference in the parent directory,
                        * but there may be other hard links. The soft
                        * dependency code will arrange to do these operations
                        * after the parent directory entry has been deleted on
                        * disk, so when running with that code we avoid doing
                        * them now.
                        */
d1045 1
a1045 1
			        tcnp->cn_cred)) != 0)
d1047 1
a1047 1
                }
d1049 1
a1049 1
	        vput(tdvp);
d1219 1
a1219 1
            B_CLRBUF, &bp)) != 0)
d1245 14
a1258 14
         * Directory set up, now install its entry in the parent directory.
         *
         * If we are not doing soft dependencies, then we must write out the
         * buffer containing the new directory body before entering the new
         * name in the parent. If we are doing soft dependencies, then the
         * buffer containing the new directory body will be passed to and
         * released in the soft dependency code after the code has attached
         * an appropriate ordering dependency to the buffer which ensures that
         * the buffer is written before the new name is written in the parent.
	 */
        if (!DOINGSOFTDEP(dvp) && ((error = VOP_BWRITE(bp)) != 0))
                goto bad;
        ufs_makedirentry(ip, cnp, &newdir);
        error = ufs_direnter(dvp, tvp, &newdir, cnp, bp);
d1261 1
a1261 1
        if (error == 0) {
d1263 5
a1267 5
                *ap->a_vpp = tvp;
        } else {
                dp->i_effnlink--;
                DIP_ADD(dp, nlink, -1);
                dp->i_flag |= IN_CHANGE;
d1270 7
a1276 7
                /*
                 * No need to do an explicit VOP_TRUNCATE here, vrele will
                 * do this for us because we set the link count to 0.
                 */
                ip->i_effnlink = 0;
                DIP_ASSIGN(ip, nlink, 0);
                ip->i_flag |= IN_CHANGE;
d1315 4
a1318 4
         * Do not remove a directory that is in the process of being renamed.
         * Verify the directory is empty (and valid). Rmdir ".." will not be
         * valid since ".." will contain a reference to the current directory
         * and thus be non-empty.
d1358 1
a1358 1
        /*
d1384 1
a1384 1
        vput(dvp);
d1401 1
a1401 1
			      vpp, ap->a_cnp);
d1643 1
a1643 1
	       ip->i_flag, ip->i_effnlink, DIP(ip, nlink));
d1645 1
a1645 1
	       DIP(ip, mode), DIP(ip, uid), DIP(ip, gid), DIP(ip, size));
d1877 1
a1877 1
                vp->v_flag |= VROOT;
d2033 1
a2033 1
        kn->kn_data = DIP(ip, size) - kn->kn_fp->f_offset;
d2039 1
a2039 1
        return (kn->kn_data != 0);
d2054 2
a2055 2
        kn->kn_data = 0;
        return (1);
@


1.121
log
@Tweaks utimensat/futimens handling to always update ctime, even when both
atime and mtime are UTIME_OMIT (at least for ufs, tmpfs, and ext2fs), and
to correctly handle a timestamp of -1.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.120 2015/03/14 03:38:53 jsg Exp $	*/
a1650 1
	lockmgr_printinfo(&ip->i_lock);
@


1.121.4.1
log
@backport 1.129

ufs_readdir() buffer was meant to be limited to 64kB; reversed test
permitted very big mallocs to panic the kernel.

reported by Tim Newsham
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.121 2015/04/17 04:43:21 guenther Exp $	*/
d1462 1
a1462 1
	readcnt = min(count, 64*1024) - entries;
@


1.120
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.119 2015/02/10 21:56:10 miod Exp $	*/
d423 3
a425 1
	if (vap->va_atime.tv_sec != VNOVAL || vap->va_mtime.tv_sec != VNOVAL) {
d433 1
a433 1
		if (vap->va_mtime.tv_sec != VNOVAL)
d435 3
a437 1
		if (vap->va_atime.tv_sec != VNOVAL) {
d443 1
a443 1
		if (vap->va_mtime.tv_sec != VNOVAL) {
d447 1
a447 1
		if (vap->va_atime.tv_sec != VNOVAL) {
@


1.119
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.118 2015/01/11 03:05:03 guenther Exp $	*/
a48 1
#include <sys/conf.h>
@


1.118
log
@Casting a gid_t to gid_t for a gid_t argument is overkill
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.117 2014/12/29 05:29:28 miod Exp $	*/
d1509 1
a1509 1
		error = uiomove(&u.dn, u.dn.d_reclen, uio);
d1542 1
a1542 1
		return (uiomove((char *)SHORTLINK(ip), isize, ap->a_uio));
@


1.117
log
@Explicitely include <uvm/uvm_extern.h> in order to build on variable page size
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.116 2014/11/03 21:28:35 tedu Exp $	*/
d514 1
a514 1
	    (gid != DIP(ip, gid) && !groupmember((gid_t)gid, cred))) &&
@


1.116
log
@include sys/unistd.h where needed instead of indirect reliance. ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.115 2014/07/12 18:44:01 tedu Exp $	*/
d72 2
@


1.115
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.114 2014/07/08 17:19:26 deraadt Exp $	*/
d59 1
@


1.114
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.113 2014/03/19 04:17:33 guenther Exp $	*/
d1517 1
a1517 1
	free(diskbuf, M_TEMP);
@


1.113
log
@Pull in FreeBSD r37363 and r37887:
--
Sync timestamp changes for inodes of special files to disk as late
as possible (when the inode is reclaimed).  Temporarily only do
this if option UFS_LAZYMOD configured and softupdates aren't enabled.
UFS_LAZYMOD is intentionally left out of /sys/conf/options.

This is mainly to avoid almost useless disk i/o on battery powered
machines.  It's silly to write to disk (on the next sync or when the
inode becomes inactive) just because someone hit a key or something
wrote to the screen or /dev/null.
--
Made lazy syncing of timestamps for special files non-optional.
--

Also, include support in 'pstat -v' to display the IN_LAZYMOD flag.

ok tedu@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.112 2014/01/25 23:31:13 guenther Exp $	*/
a58 2

#include <uvm/uvm_extern.h>
@


1.112
log
@ufs_setattr() was assuming that the flag bits that indicate
atime/mtime/ctime need to be updated weren't already set.  When
they are, the code will end up treating the VNOVAL value from the
VFS layer as a time_t.  Port the fix from FreeBSD: the critical bit
is to process the existing flag values before possibly setting them
again in ufs_setattr().  This diff pulls in a larger change from
FreeBSD to replace the macro ITIMES() with a function ufs_itimes()
and to remove the atime and mtime arguments from ffs_update(): only
ufs_setattr() used them so it makes more sense to just do the those
bits directly there.

tweaks and ok tedu@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.111 2013/12/12 19:00:10 tedu Exp $	*/
d134 4
a137 1
	ip->i_flag |= IN_MODIFIED;
@


1.111
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.110 2013/11/23 19:07:51 guenther Exp $	*/
d112 45
a245 1
	struct inode *ip = VTOI(vp);
d247 2
a248 6
	if (vp->v_usecount > 1) {
		struct timeval tv;

		getmicrotime(&tv);
		ITIMES(ip, &tv, &tv);
	}
a302 1
	struct timeval tv;
d304 2
a305 2
	getmicrotime(&tv);
	ITIMES(ip, &tv, &tv);
d435 10
a444 1
		error = UFS_UPDATE2(ip, &vap->va_atime, &vap->va_mtime, 0);
a1691 4
	struct inode *ip = VTOI(vp);

	if (ap->a_vp->v_usecount > 1) {
		struct timeval tv;
d1693 2
a1694 3
		getmicrotime(&tv);
		ITIMES(ip, &tv, &tv);
	}
a1738 1
	struct inode *ip = VTOI(vp);
d1740 2
a1741 6
	if (ap->a_vp->v_usecount > 1) {
		struct timeval tv;

		getmicrotime(&tv);
		ITIMES(ip, &tv, &tv);
	}
@


1.110
log
@Verify that the directory entry being looked at is entirely present in
the read buffer before trying to process it, so that invalidated
or bogus offsets can't trigger access past the end of the read buffer.
Also, zero out the dirent buffer to avoid leaking stack garbage to userspace.

Problem pointed out by Pedro Martelletto (pedro (at) ambientworks.net)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.109 2013/09/22 17:14:55 guenther Exp $	*/
d1169 1
a1169 1
	bcopy((caddr_t)&dirtemplate, (caddr_t)bp->b_data, sizeof dirtemplate);
d1354 1
a1354 1
		bcopy(ap->a_target, (char *)SHORTLINK(ip), len);
d1454 1
a1454 1
		bzero(u.dn.d_name + u.dn.d_namlen, u.dn.d_reclen
@


1.109
log
@Delete a T32 chunk that I missed before and update the comment on
ufs_readdir() to match
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.108 2013/08/13 05:52:27 guenther Exp $	*/
d1382 2
a1383 1
	struct direct *dp, *edp;
d1420 16
a1435 6
	edp = (struct direct *)&diskbuf[readcnt];
	while (error == 0 && dp < edp) {
		if (dp->d_reclen <= offsetof(struct direct, d_name)) {
			error = EIO;
			break;
		}
d1460 8
@


1.108
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.107 2013/06/11 16:42:19 deraadt Exp $	*/
d1368 2
a1369 6
 * If the 0x10 bit in uio_segflg is set then this routine will assume
 * that the caller wants the on-disk format of the directory, which
 * 'happens' to be the same as that defined by struct direct32 in
 * <sys/dirent.h>.
 * Otherwise, this routine will convert struct direct entries to struct
 * dirent entries.
a1398 52

#if T32
	if (uio->uio_segflg & 0x10) {
		uio->uio_segflg &= ~0x10;

		count -= entries;
		uio->uio_resid = count;
		uio->uio_iov->iov_len = count;

#	if (BYTE_ORDER == LITTLE_ENDIAN)
		if (! ofmt)
			error = VOP_READ(ap->a_vp, uio, 0, ap->a_cred);
		else {
			caddr_t dirbuf;
			u_char tmp;

			auio = *uio;
			auio.uio_iov = &aiov;
			auio.uio_iovcnt = 1;
			auio.uio_segflg = UIO_SYSSPACE;
			aiov.iov_len = count;
			dirbuf = malloc(count, M_TEMP, M_WAITOK);
			aiov.iov_base = dirbuf;
			error = VOP_READ(ap->a_vp, &auio, 0, ap->a_cred);
			if (error == 0) {
				readcnt = count - auio.uio_resid;
				edp = (struct direct *)&dirbuf[readcnt];
				for (dp = (struct direct *)dirbuf; dp < edp; ) {
					tmp = dp->d_namlen;
					dp->d_namlen = dp->d_type;
					dp->d_type = tmp;
					if (dp->d_reclen > 0) {
						dp = (struct direct *)
						    ((char *)dp + dp->d_reclen);
					} else {
						error = EIO;
						break;
					}
				}
				if (dp >= edp)
					error = uiomove(dirbuf, readcnt, uio);
			}
			free(dirbuf, M_TEMP);
		}
#	else
		error = VOP_READ(ap->a_vp, uio, 0, ap->a_cred);
#	endif

		*ap->a_eofflag = DIP(VTOI(ap->a_vp), size) <= uio->uio_offset;
		return error;
	}
#endif /* T32 */
@


1.107
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.106 2013/03/28 03:29:44 guenther Exp $	*/
d1368 6
a1373 5
 * The routine below assumes that the on-disk format of a directory
 * is the same as that defined by <sys/dirent.h>. If the on-disk
 * format changes, then it will be necessary to do a conversion
 * from the on-disk format that read returns to the format defined
 * by <sys/dirent.h>.
d1379 6
a1384 3
	struct uio *uio = ap->a_uio;
	int error;
	size_t count, lost, entries;
d1386 10
d1404 8
a1411 4
	count -= entries;
	lost = uio->uio_resid - count;
	uio->uio_resid = count;
	uio->uio_iov->iov_len = count;
d1413 1
a1413 1
		if (ap->a_vp->v_mount->mnt_maxsymlinklen > 0) {
d1415 1
a1415 4
		} else {
			struct dirent *dp, *edp;
			struct uio auio;
			struct iovec aiov;
a1416 1
			int readcnt;
d1429 2
a1430 2
				edp = (struct dirent *)&dirbuf[readcnt];
				for (dp = (struct dirent *)dirbuf; dp < edp; ) {
d1435 1
a1435 1
						dp = (struct dirent *)
a1449 5
	if (!error && ap->a_ncookies) {
		struct dirent *dp, *dpstart;
		off_t offstart;
		u_long *cookies;
		int ncookies;
d1451 9
a1459 7
		/*
		 * Only the NFS server and emulations use cookies, and they
		 * load the directory block into system space, so we can
		 * just look at it directly.
		 */
		if (uio->uio_segflg != UIO_SYSSPACE || uio->uio_iovcnt != 1)
			panic("ufs_readdir: lost in space");
d1461 36
a1496 21
		dpstart = (struct dirent *)
			((char *)uio->uio_iov->iov_base -
			(uio->uio_offset - off));
                offstart = off;
                for (dp = dpstart, ncookies = 0; off < uio->uio_offset; ) {
                        if (dp->d_reclen == 0)
                                break;
                        off += dp->d_reclen;
                        ncookies++;
                        dp = (struct dirent *)((caddr_t)dp + dp->d_reclen);
                }
                lost += uio->uio_offset - off;
                uio->uio_offset = off;
                cookies = malloc(ncookies * sizeof(u_long), M_TEMP, M_WAITOK);
                *ap->a_ncookies = ncookies;
                *ap->a_cookies = cookies;
                for (off = offstart, dp = dpstart; off < uio->uio_offset; ) {
			off += dp->d_reclen;
                        *cookies = off;
			cookies++;
                        dp = (struct dirent *)((caddr_t)dp + dp->d_reclen);
d1498 6
d1505 1
d1507 2
a1508 2
	uio->uio_resid += lost;
	*ap->a_eofflag = DIP(VTOI(ap->a_vp), size) <= uio->uio_offset;
@


1.106
log
@Add support for _PC_TIMESTAMP_RESOLUTION for ffs/mfs, cd9600, ext2,
msdos, NFS, fifos and devices, plus support for querying it in
getconf(2) and the requisite pathconf(2) manpage blurb

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.105 2013/03/28 02:08:39 guenther Exp $	*/
d449 1
a449 1
	daddr64_t change;
@


1.105
log
@Handle the pathconf _PC_PATH_MAX, _PC_PIPE_BUF, _PC_ASYNC_IO,
_PC_PRIO_IO, and _PC_SYNC_IO names in VOP_PATHCONF(), as they're
fs-independent for us.  Since we don't support latter three on any
fs, we can also define the related _POSIX_{ASYNC,PRIO,SYNC}_IO
symbols in <unistd.h> (via sys/unistd.h) with value -1.

Also, zap pointless tty-only values from procfs(!).

ok beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.104 2012/06/20 17:30:22 matthew Exp $	*/
d1756 3
@


1.104
log
@Cleanup our filesystem pathconf() code a little bit to make it easier
to diff against FreeBSD's.

From Brad; no object file change on amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.103 2012/06/19 00:09:55 matthew Exp $	*/
a1727 6
	case _PC_PATH_MAX:
		*ap->a_retval = PATH_MAX;
		break;
	case _PC_PIPE_BUF:
		*ap->a_retval = PIPE_BUF;
		break;
a1732 6
		break;
	case _PC_PRIO_IO:
		*ap->a_retval = 0;
		break;
	case _PC_SYNC_IO:
		*ap->a_retval = 0;
@


1.103
log
@Add more pathconf(2) variables from POSIX.

From FreeBSD via Brad; ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.102 2011/09/18 23:20:28 bluhm Exp $	*/
d1719 1
d1724 1
a1724 1
		return (0);
d1727 1
a1727 1
		return (0);
d1730 1
a1730 1
		return (0);
d1733 1
a1733 1
		return (0);
d1736 1
a1736 1
		return (0);
d1739 1
a1739 1
		return (0);
d1742 1
a1742 1
		return (0);
d1745 1
a1745 1
		return (0);
d1748 1
a1748 1
		return (0);
d1751 1
a1751 1
		return (0);
d1754 1
a1754 1
		return (0);
d1757 1
a1757 1
		return (0);
d1760 1
a1760 1
		return (0);
d1763 1
a1763 1
		return (0);
d1766 1
a1766 1
		return (0);
d1769 1
a1769 1
		return (0);
d1771 2
a1772 1
		return (EINVAL);
d1774 2
a1775 1
	/* NOTREACHED */
@


1.102
log
@Fix more printf format string bugs in sys/ufs.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.101 2011/07/04 20:35:35 deraadt Exp $	*/
d1737 30
@


1.101
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.100 2011/07/03 18:23:10 tedu Exp $	*/
d1589 1
a1589 1
	printf("tag VT_UFS, ino %d, on dev %d, %d", ip->i_number,
@


1.100
log
@correctify NULL 0 confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.99 2011/07/02 22:20:08 nicm Exp $	*/
d58 1
a61 1
#include <miscfs/specfs/specdev.h>
@


1.99
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.98 2011/07/02 15:52:25 thib Exp $	*/
d163 1
a163 1
	*vpp = 0;
d1251 1
a1251 1
	if (dp == ip || vp->v_mountedhere != 0) {
@


1.98
log
@rename VFSDEBUG to VFLCKDEBUG;

prompted by tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.97 2010/12/21 20:14:44 thib Exp $	*/
d1936 1
a1936 1
		return (1);
@


1.97
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.96 2010/09/23 18:49:39 oga Exp $	*/
d1785 1
a1785 1
#ifdef VFSDEBUG
@


1.96
log
@The only sensible argument for VOP_* calls that take a struct proc pointer is
curproc. A bunch of callers were passing in 0 (not even NULL, 0) as this
pointer, which was fine until the called vnode function tried to do
something with it. Typically, this code was then copy/pasted to various
parts of the tree.

Accept the facts of life and switch all of these over to passing curproc
for now until the argument can be removed.

Discovered by stsp trying to create a softraid on top of a vnd, which
crashed with a NULL deref in vndioctl.

softraid bits tested by mikeb and jsing. raidframe bits tested by pea,
matthieu and naddy. The rest tested by at least thib, jsing and myself.

ok thib@@, jsing@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.95 2010/09/10 16:34:09 thib Exp $	*/
d1573 1
a1573 1
	VOCALL(vp->v_op, VOFFSET(vop_strategy), ap);
d1620 1
a1620 1
	return (VOCALL (spec_vnodeop_p, VOFFSET(vop_read), ap));
d1635 1
a1635 1
	return (VOCALL (spec_vnodeop_p, VOFFSET(vop_write), ap));
d1656 1
a1656 1
	return (VOCALL (spec_vnodeop_p, VOFFSET(vop_close), ap));
a1666 1
	extern int (**fifo_vnodeop_p)(void *);
d1672 1
a1672 1
	return (VOCALL (fifo_vnodeop_p, VOFFSET(vop_read), ap));
a1681 1
	extern int (**fifo_vnodeop_p)(void *);
d1687 1
a1687 1
	return (VOCALL (fifo_vnodeop_p, VOFFSET(vop_write), ap));
a1698 1
	extern int (**fifo_vnodeop_p)(void *);
d1708 1
a1708 1
	return (VOCALL (fifo_vnodeop_p, VOFFSET(vop_close), ap));
d1763 2
a1764 2
ufs_vinit(struct mount *mntp, int (**specops)(void *),
    int (**fifoops)(void *), struct vnode **vpp)
d1784 1
a1784 1
			vp->v_op = spec_vnodeop_p;
@


1.95
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.94 2010/09/09 10:37:04 thib Exp $	*/
d1360 1
a1360 1
		    (struct proc *)0);
@


1.94
log
@Rename lookup/relookup to vfs_lookup/vfs_relookup.

OK oga@@, beck@@, matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.93 2010/09/06 23:44:11 thib Exp $	*/
d1573 1
a1573 1
	(vp->v_op->vop_strategy)(ap);
d1620 1
a1620 1
	return (spec_read(ap));
d1635 1
a1635 1
	return (spec_write(ap));
d1656 1
a1656 1
	return (spec_close(ap));
d1667 1
d1673 1
a1673 1
	return (fifo_read(ap));
d1683 1
d1689 1
a1689 1
	return (fifo_write(ap));
d1701 1
d1711 1
a1711 1
	return (fifo_close(ap));
d1766 2
a1767 2
ufs_vinit(struct mount *mntp, struct vops *specops, struct vops *fifoops,
    struct vnode **vpp)
d1787 1
a1787 1
			vp->v_op = &spec_vops;
@


1.93
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.92 2010/08/02 02:03:21 matthew Exp $	*/
d751 1
a751 1
		if ((error = relookup(fdvp, &fvp, fcnp)) != 0)
d858 1
a858 1
		if ((error = relookup(tdvp, &tvp, tcnp)) != 0)
d1007 1
a1007 1
	if ((error = relookup(fdvp, &fvp, fcnp)) != 0) {
@


1.92
log
@Fix readlink(2) on FFS and ext2 filesystems to consistently return
EFAULT when appropriate.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.91 2010/07/03 02:08:35 thib Exp $	*/
d1573 1
a1573 1
	VOCALL(vp->v_op, VOFFSET(vop_strategy), ap);
d1620 1
a1620 1
	return (VOCALL (spec_vnodeop_p, VOFFSET(vop_read), ap));
d1635 1
a1635 1
	return (VOCALL (spec_vnodeop_p, VOFFSET(vop_write), ap));
d1656 1
a1656 1
	return (VOCALL (spec_vnodeop_p, VOFFSET(vop_close), ap));
a1666 1
	extern int (**fifo_vnodeop_p)(void *);
d1672 1
a1672 1
	return (VOCALL (fifo_vnodeop_p, VOFFSET(vop_read), ap));
a1681 1
	extern int (**fifo_vnodeop_p)(void *);
d1687 1
a1687 1
	return (VOCALL (fifo_vnodeop_p, VOFFSET(vop_write), ap));
a1698 1
	extern int (**fifo_vnodeop_p)(void *);
d1708 1
a1708 1
	return (VOCALL (fifo_vnodeop_p, VOFFSET(vop_close), ap));
d1763 2
a1764 2
ufs_vinit(struct mount *mntp, int (**specops)(void *),
    int (**fifoops)(void *), struct vnode **vpp)
d1784 1
a1784 1
			vp->v_op = spec_vnodeop_p;
@


1.91
log
@de-static ufs_chown and ufs_chmod so they show up in DDB.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.90 2009/06/04 21:10:47 thib Exp $	*/
d1494 1
a1494 2
		uiomove((char *)SHORTLINK(ip), isize, ap->a_uio);
		return (0);
@


1.90
log
@tiny tiny space nit
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.88 2008/08/13 15:45:30 thib Exp $	*/
d74 2
a75 2
static int ufs_chmod(struct vnode *, int, struct ucred *, struct proc *);
static int ufs_chown(struct vnode *, uid_t, gid_t, struct ucred *, struct proc *);
d414 1
a414 1
static int
d441 1
a441 1
static int
@


1.89
log
@Use proper assignment macros for dinode manipulations instead of
abusing the DIP() macro which is an rvalue and can't be used
as an lvalue. No functional changes.

ok tedu@@ pedro@@
@
text
@d1574 1
a1574 1
	VOCALL (vp->v_op, VOFFSET(vop_strategy), ap);
@


1.88
log
@remove a bunch of bogus ARGSUSED
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.87 2008/06/09 23:38:37 millert Exp $	*/
d339 2
a340 2
			DIP(ip, flags) &= SF_SETTABLE;
			DIP(ip, flags) |= (vap->va_flags & UF_SETTABLE);
d429 2
a430 2
	DIP(ip, mode) &= ~ALLPERMS;
	DIP(ip, mode) |= (mode & ALLPERMS);
d504 1
a504 1
		DIP(ip, mode) &= ~ISUID;
d506 1
a506 1
		DIP(ip, mode) &= ~ISGID;
d1879 1
a1879 1
		DIP(ip, mode) &= ~ISGID;
@


1.87
log
@Update access(2) to have modern semantics with respect to X_OK and
the superuser.  access(2) will now only indicate success for X_OK on
non-directories if there is at least one execute bit set on the file.
OK deraadt@@ thib@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.86 2008/01/17 11:31:56 fgsch Exp $	*/
a131 1
/* ARGSUSED */
a171 1
/* ARGSUSED */
a195 1
/* ARGSUSED */
a255 1
/* ARGSUSED */
a535 1
/* ARGSUSED */
a1957 1
/*ARGSUSED*/
@


1.86
log
@Notify us of NOTE_LINK on mkdir(2) as well.
ok thib and miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.85 2008/01/05 19:49:26 otto Exp $	*/
d255 2
a256 2
	return (vaccess(DIP(ip, mode), DIP(ip, uid), DIP(ip, gid), mode,
	    ap->a_cred));
@


1.85
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.84 2007/10/29 17:06:20 chl Exp $	*/
d1212 1
a1212 1
		VN_KNOTE(dvp, NOTE_WRITE);
@


1.84
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.83 2007/09/23 20:15:07 millert Exp $	*/
d453 1
a453 1
	daddr_t change;
d1568 1
a1568 1
		if ((long)bp->b_blkno == -1)
d1571 1
a1571 1
	if ((long)bp->b_blkno == -1) {
@


1.83
log
@Move notatime check from ffs_update() to ffs_read() and ufs_setattr().
Fixes a couple cases where atime was being updated even when the
filesystem was mounted with the noatime option.
Adapted from similar placement in FreeBSD and NetBSD.
Tested by myself and naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.82 2007/06/20 15:03:40 thib Exp $	*/
d1415 1
a1415 1
			MALLOC(dirbuf, caddr_t, count, M_TEMP, M_WAITOK);
d1436 1
a1436 1
			FREE(dirbuf, M_TEMP);
d1468 1
a1468 2
                MALLOC(cookies, u_long *, ncookies * sizeof(u_long), M_TEMP,
                    M_WAITOK);
@


1.82
log
@remove an XXX comment;
Basically the reason why we dont do VOP_ABORTOP()'s in NFS
is that sys_rename() actually handles the garbage collection
of the pathname buffers, the calls in ufs are actually fluff
too, but will be delt with later.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.81 2007/06/01 23:47:57 deraadt Exp $	*/
a392 2
		if (vap->va_atime.tv_sec != VNOVAL)
			ip->i_flag |= IN_ACCESS;
d395 5
@


1.81
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.80 2007/05/17 23:46:28 thib Exp $	*/
d699 1
a699 1
		VOP_ABORTOP(tdvp, tcnp); /* XXX, why not in NFS? */
d706 1
a706 1
		VOP_ABORTOP(fdvp, fcnp); /* XXX, why not in NFS? */
@


1.80
log
@Collapse struct v_selectinfo in struct vnode, remove the
simplelock and reuse the name for the selinfo member.
Clean-up accordingly.

ok tedu@@,art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.79 2007/05/09 17:04:22 deraadt Exp $	*/
d117 1
a117 6
	struct vop_create_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
d136 1
a136 6
	struct vop_mknod_args /* {
				 struct vnode *a_dvp;
				 struct vnode **a_vpp;
				 struct componentname *a_cnp;
				 struct vattr *a_vap;
				 } */ *ap = v;
d177 1
a177 6
	struct vop_open_args /* {
				struct vnode *a_vp;
				int  a_mode;
				struct ucred *a_cred;
				struct proc *a_p;
	} */ *ap = v;
d202 1
a202 6
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d218 1
a218 6
	struct vop_access_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d263 1
a263 6
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d309 1
a309 6
	struct vop_setattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d532 1
a532 8
	struct vop_ioctl_args /* {
		struct vnode *a_vp;
		u_long a_command;
		caddr_t  a_data;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d541 1
a541 5
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int  a_events;
		struct proc *a_p;
	} */ *ap = v;
d552 1
a552 5
	struct vop_remove_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d582 1
a582 5
	struct vop_link_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d674 1
a674 8
	struct vop_rename_args  /* {
		struct vnode *a_fdvp;
		struct vnode *a_fvp;
		struct componentname *a_fcnp;
		struct vnode *a_tdvp;
		struct vnode *a_tvp;
		struct componentname *a_tcnp;
	} */ *ap = v;
d1089 1
a1089 6
	struct vop_mkdir_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
d1241 1
a1241 5
	struct vop_rmdir_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d1342 1
a1342 7
	struct vop_symlink_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
		char *a_target;
	} */ *ap = v;
d1379 1
a1379 8
	struct vop_readdir_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
		int *a_eofflag;
		u_long **a_cookies;
		int *ncookies;
	} */ *ap = v;
d1489 1
a1489 5
	struct vop_readlink_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
	} */ *ap = v;
d1509 1
a1509 5
	struct vop_lock_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;
d1521 1
a1521 5
	struct vop_unlock_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;
d1533 1
a1533 3
	struct vop_islocked_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d1545 1
a1545 3
	struct vop_strategy_args /* {
		struct buf *a_bp;
	} */ *ap = v;
d1588 1
a1588 3
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d1618 1
a1618 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d1633 1
a1633 6
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d1650 1
a1650 6
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d1670 1
a1670 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d1686 1
a1686 6
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int  a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d1704 1
a1704 6
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d1725 1
a1725 5
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		register_t *a_retval;
	} */ *ap = v;
d1758 1
a1758 7
	struct vop_advlock_args /* {
		struct vnode *a_vp;
		caddr_t  a_id;
		int  a_op;
		struct flock *a_fl;
		int  a_flags;
	} */ *ap = v;
d1928 1
a1928 4
	struct vop_kqfilter_args /* {
		struct vnode *a_vp;
		struct knote *a_kn;
	} */ *ap = v;
@


1.79
log
@unused function; ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.78 2007/04/13 17:09:22 thib Exp $	*/
d2092 1
a2092 3
	simple_lock(&vp->v_selectinfo.vsi_lock);
	SLIST_INSERT_HEAD(&vp->v_selectinfo.vsi_selinfo.si_note, kn, kn_selnext);
	simple_unlock(&vp->v_selectinfo.vsi_lock);
d2102 1
a2102 4
	simple_lock(&vp->v_selectinfo.vsi_lock);
	SLIST_REMOVE(&vp->v_selectinfo.vsi_selinfo.si_note,
	    kn, knote, kn_selnext);
	simple_unlock(&vp->v_selectinfo.vsi_lock);
@


1.78
log
@Move the declaration of VN_KNOTE() into vnode.h instead of having
multiple defines all over;

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.77 2007/04/10 17:47:56 miod Exp $	*/
a592 21
}

/*
 * Seek on a file
 *
 * Nothing to do, so just return.
 */
/* ARGSUSED */
int
ufs_seek(void *v)
{
#if 0
	struct vop_seek_args /* {
		struct vnode *a_vp;
		off_t  a_oldoff;
		off_t  a_newoff;
		struct ucred *a_cred;
	} */ *ap = v;
#endif

	return (0);
@


1.77
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.76 2007/04/10 11:21:17 pedro Exp $	*/
a97 3
#define VN_KNOTE(vp, b) \
	KNOTE(&vp->v_selectinfo.vsi_selinfo.si_note, (b))

@


1.76
log
@Fix yet another vnode leak. If relookup() succeeds, we no longer need
the compensation acquired before ufs_checkpath(). OK tom@@ mickey@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.75 2007/04/02 10:57:17 pedro Exp $	*/
d1282 1
a1282 1
         * Directory set up, now install it's entry in the parent directory.
@


1.75
log
@vrele() the destination directory vnode in ufs_rename() if the call to
ufs_checkpath() fails, okay krw@@ tom@@ thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.74 2007/03/21 17:29:32 thib Exp $	*/
d947 1
@


1.74
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.73 2006/12/29 13:04:37 pedro Exp $	*/
d939 2
a940 1
		if ((error = ufs_checkpath(ip, dp, tcnp->cn_cred)) != 0)
d942 1
@


1.73
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.72 2006/01/09 12:43:17 pedro Exp $	*/
a228 1
	simple_lock(&vp->v_interlock);
a234 1
	simple_unlock(&vp->v_interlock);
d1624 1
a1624 1
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags, &vp->v_interlock));
d1640 1
a1640 2
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags | LK_RELEASE,
		&vp->v_interlock));
a1790 1
	simple_lock(&vp->v_interlock);
a1796 1
	simple_unlock(&vp->v_interlock);
a1860 1
	simple_lock(&vp->v_interlock);
a1866 1
	simple_unlock(&vp->v_interlock);
@


1.72
log
@Put vprint() under DIAGNOSTIC, as to save space in generated ramdisks.
Inspiration from miod@@, okay deraadt@@. Tested on i386, macppc and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.71 2005/12/28 20:48:18 pedro Exp $	*/
d1559 2
a1560 1
			(uio->uio_iov->iov_base - (uio->uio_offset - off));
@


1.71
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.70 2005/12/16 04:52:24 pedro Exp $	*/
d1709 1
d1713 1
d1730 3
@


1.70
log
@Fix unsigned < 0 check in ufs_readdir(), okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.69 2005/11/19 02:18:02 pedro Exp $	*/
d167 1
a167 1
		ip->i_ffs_rdev = vap->va_rdev;
d201 1
a201 1
	if ((ip->i_ffs_flags & APPEND) &&
d282 1
a282 1
	if ((mode & VWRITE) && (ip->i_ffs_flags & IMMUTABLE))
d285 2
a286 2
	return (vaccess(ip->i_ffs_mode, ip->i_ffs_uid, ip->i_ffs_gid,
					mode, ap->a_cred));
d311 1
a311 1
	vap->va_mode = ip->i_ffs_mode & ~IFMT;
d313 12
a324 12
	vap->va_uid = ip->i_ffs_uid;
	vap->va_gid = ip->i_ffs_gid;
	vap->va_rdev = (dev_t)ip->i_ffs_rdev;
	vap->va_size = ip->i_ffs_size;
	vap->va_atime.tv_sec = ip->i_ffs_atime;
	vap->va_atime.tv_nsec = ip->i_ffs_atimensec;
	vap->va_mtime.tv_sec = ip->i_ffs_mtime;
	vap->va_mtime.tv_nsec = ip->i_ffs_mtimensec;
	vap->va_ctime.tv_sec = ip->i_ffs_ctime;
	vap->va_ctime.tv_nsec = ip->i_ffs_ctimensec;
	vap->va_flags = ip->i_ffs_flags;
	vap->va_gen = ip->i_ffs_gen;
d332 1
a332 1
	vap->va_bytes = dbtob((u_quad_t)ip->i_ffs_blocks);
d371 1
a371 1
		if (cred->cr_uid != ip->i_ffs_uid &&
d375 1
a375 1
			if ((ip->i_ffs_flags & (SF_IMMUTABLE | SF_APPEND)) &&
d378 1
a378 1
			ip->i_ffs_flags = vap->va_flags;
d380 1
a380 1
			if (ip->i_ffs_flags & (SF_IMMUTABLE | SF_APPEND) ||
d383 2
a384 2
			ip->i_ffs_flags &= SF_SETTABLE;
			ip->i_ffs_flags |= (vap->va_flags & UF_SETTABLE);
d390 1
a390 1
	if (ip->i_ffs_flags & (IMMUTABLE | APPEND))
d403 1
a403 1
		oldsize = ip->i_ffs_size;
d428 1
a428 1
		if (cred->cr_uid != ip->i_ffs_uid &&
d461 1
a461 1
	if (cred->cr_uid != ip->i_ffs_uid &&
d467 1
a467 1
		if (!groupmember(ip->i_ffs_gid, cred) && (mode & ISGID))
d470 2
a471 2
	ip->i_ffs_mode &= ~ALLPERMS;
	ip->i_ffs_mode |= (mode & ALLPERMS);
d473 1
a473 1
	if ((vp->v_flag & VTEXT) && (ip->i_ffs_mode & S_ISTXT) == 0)
d494 1
a494 1
		uid = ip->i_ffs_uid;
d496 1
a496 1
		gid = ip->i_ffs_gid;
d502 2
a503 2
	if ((cred->cr_uid != ip->i_ffs_uid || uid != ip->i_ffs_uid ||
	    (gid != ip->i_ffs_gid && !groupmember((gid_t)gid, cred))) &&
d506 3
a508 3
	ogid = ip->i_ffs_gid;
	ouid = ip->i_ffs_uid;
	change = ip->i_ffs_blocks;
d522 2
a523 2
	ip->i_ffs_gid = gid;
	ip->i_ffs_uid = uid;
d545 1
a545 1
		ip->i_ffs_mode &= ~ISUID;
d547 1
a547 1
		ip->i_ffs_mode &= ~ISGID;
d553 3
a555 2
	ip->i_ffs_gid = ogid;
	ip->i_ffs_uid = ouid;
d635 2
a636 2
	if (vp->v_type == VDIR || (ip->i_ffs_flags & (IMMUTABLE | APPEND)) ||
	    (VTOI(dvp)->i_ffs_flags & APPEND)) {
d690 1
a690 1
	if ((nlink_t)ip->i_ffs_nlink >= LINK_MAX) {
d695 1
a695 1
	if (ip->i_ffs_flags & (IMMUTABLE | APPEND)) {
d701 1
a701 1
	ip->i_ffs_nlink++;
d711 1
a711 1
		ip->i_ffs_nlink--;
d799 2
a800 2
	if (tvp && ((VTOI(tvp)->i_ffs_flags & (IMMUTABLE | APPEND)) ||
	    (VTOI(tdvp)->i_ffs_flags & APPEND))) {
d852 1
a852 1
	if ((nlink_t)ip->i_ffs_nlink >= LINK_MAX) {
d857 2
a858 2
	if ((ip->i_ffs_flags & (IMMUTABLE | APPEND)) ||
	    (dp->i_ffs_flags & APPEND)) {
d863 1
a863 1
	if ((ip->i_ffs_mode & IFMT) == IFDIR) {
d906 1
a906 1
	ip->i_ffs_nlink++;
d968 1
a968 1
			if ((nlink_t)dp->i_ffs_nlink >= LINK_MAX) {
d973 1
a973 1
			dp->i_ffs_nlink++;
d980 1
a980 1
				dp->i_ffs_nlink--;
d991 1
a991 1
				dp->i_ffs_nlink--;
d1015 3
a1017 3
		if ((dp->i_ffs_mode & S_ISTXT) && tcnp->cn_cred->cr_uid != 0 &&
		    tcnp->cn_cred->cr_uid != dp->i_ffs_uid &&
		    xp->i_ffs_uid != tcnp->cn_cred->cr_uid) {
d1026 1
a1026 1
		if ((xp->i_ffs_mode & IFMT) == IFDIR) {
d1043 1
a1043 1
                   IFTODT(ip->i_ffs_mode), (doingdirectory && newparent) ?
d1069 1
a1069 1
				dp->i_ffs_nlink--;
d1073 1
a1073 1
			xp->i_ffs_nlink--;
d1156 1
a1156 1
		ip->i_ffs_nlink--;
d1194 1
a1194 1
	if ((nlink_t)dp->i_ffs_nlink >= LINK_MAX) {
d1207 1
d1209 3
a1211 2
	ip->i_ffs_uid = cnp->cn_cred->cr_uid;
	ip->i_ffs_gid = dp->i_ffs_gid;
d1223 1
a1223 1
	ip->i_ffs_mode = dmode;
d1226 1
a1226 1
	ip->i_ffs_nlink = 2;
d1236 1
a1236 1
	dp->i_ffs_nlink++;
d1257 1
a1257 1
	ip->i_ffs_size = DIRBLKSIZ;
d1259 1
a1259 1
	uvm_vnp_setsize(tvp, ip->i_ffs_size);
d1302 1
a1302 1
                dp->i_ffs_nlink--;
d1311 1
a1311 1
                ip->i_ffs_nlink = 0;
d1370 2
a1371 2
	if ((dp->i_ffs_flags & APPEND) ||
		(ip->i_ffs_flags & (IMMUTABLE | APPEND))) {
d1408 1
a1408 1
		dp->i_ffs_nlink--;
d1410 1
a1410 1
		ip->i_ffs_nlink--;
d1455 2
a1456 2
		bcopy(ap->a_target, (char *)ip->i_ffs_shortlink, len);
		ip->i_ffs_size = len;
d1581 1
d1583 2
a1584 1
	*ap->a_eofflag = VTOI(ap->a_vp)->i_ffs_size <= uio->uio_offset;
d1603 1
a1603 1
	isize = ip->i_ffs_size;
d1605 2
a1606 2
	    (vp->v_mount->mnt_maxsymlinklen == 0 && ip->i_ffs_blocks == 0)) {
		uiomove((char *)ip->i_ffs_shortlink, isize, ap->a_uio);
d1718 1
a1718 1
	       ip->i_flag, ip->i_effnlink, ip->i_ffs_nlink);
d1720 1
a1720 1
	       ip->i_ffs_mode, ip->i_ffs_uid, ip->i_ffs_gid, ip->i_ffs_size);
d1924 1
a1924 1
	return (lf_advlock(&ip->i_lockf, ip->i_ffs_size, ap->a_id, ap->a_op,
d1942 1
a1942 1
	switch(vp->v_type = IFTOVT(ip->i_ffs_mode)) {
d1946 1
a1946 1
		if ((nvp = checkalias(vp, ip->i_ffs_rdev, mntp)) != NULL) {
d2020 1
d2022 3
a2024 2
	ip->i_ffs_gid = pdir->i_ffs_gid;
	ip->i_ffs_uid = cnp->cn_cred->cr_uid;
d2036 1
a2036 1
	ip->i_ffs_mode = mode;
d2039 1
a2039 1
	ip->i_ffs_nlink = 1;
d2042 2
a2043 2
	if ((ip->i_ffs_mode & ISGID) &&
		!groupmember(ip->i_ffs_gid, cnp->cn_cred) &&
d2045 1
a2045 1
		ip->i_ffs_mode &= ~ISGID;
d2071 1
a2071 1
	ip->i_ffs_nlink = 0;
d2148 1
a2148 1
        kn->kn_data = ip->i_ffs_size - kn->kn_fp->f_offset;
@


1.69
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.68 2005/11/11 16:27:52 pedro Exp $	*/
d1485 1
a1485 1
	size_t count, lost;
d1489 2
d1492 1
a1492 2
	count -= (uio->uio_offset + count) & (DIRBLKSIZ -1);
	if (count <= 0)
d1494 2
@


1.68
log
@Use ANSI function declarations and deregister, no binary change.
Diff from Rui Reis <rui@@rui.cx>, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.67 2005/07/24 05:43:36 millert Exp $	*/
d1617 1
a1617 2
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags, &vp->v_interlock,
		ap->a_p));
d1634 1
a1634 1
		&vp->v_interlock, ap->a_p));
@


1.67
log
@Fix a bug introduced in rev 1.58.  When relookup() is called with
SAVESTART set in cn_flags, it will add an extra reference to the
directory vnode pointer, but only when () succeeds.  We were doing
vrele() regardless of relookup()'s return value, which caused the
reference count to be decremented on error when it shouldn't be.
OK pedro@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.66 2005/07/03 20:14:03 drahn Exp $	*/
d76 4
a79 4
int filt_ufsread(struct knote *kn, long hint);
int filt_ufswrite(struct knote *kn, long hint);
int filt_ufsvnode(struct knote *kn, long hint);
void filt_ufsdetach(struct knote *kn);
d85 1
d118 1
a118 2
ufs_create(v)
	void *v;
d142 1
a142 2
ufs_mknod(v)
	void *v;
d188 1
a188 2
ufs_open(v)
	void *v;
d218 1
a218 2
ufs_close(v)
	void *v;
d241 1
a241 2
ufs_access(v)
	void *v;
d291 1
a291 2
ufs_getattr(v)
	void *v;
d342 1
a342 2
ufs_setattr(v)
	void *v;
d456 1
a456 5
ufs_chmod(vp, mode, cred, p)
	struct vnode *vp;
	int mode;
	struct ucred *cred;
	struct proc *p;
d483 2
a484 6
ufs_chown(vp, uid, gid, cred, p)
	struct vnode *vp;
	uid_t uid;
	gid_t gid;
	struct ucred *cred;
	struct proc *p;
d568 1
a568 2
ufs_ioctl(v)
	void *v;
d585 1
a585 2
ufs_poll(v)
	void *v;
d606 1
a606 2
ufs_seek(v)
	void *v;
d621 1
a621 2
ufs_remove(v)
	void *v;
d655 1
a655 2
ufs_link(v)
	void *v;
d751 1
a751 2
ufs_rename(v)
	void *v;
d1170 1
a1170 2
ufs_mkdir(v)
	void *v;
d1325 1
a1325 2
ufs_rmdir(v)
	void *v;
d1430 1
a1430 2
ufs_symlink(v)
	void *v;
d1473 1
a1473 2
ufs_readdir(v)
	void *v;
d1584 1
a1584 2
ufs_readlink(v)
	void *v;
d1608 1
a1608 2
ufs_lock(v)
	void *v;
d1625 1
a1625 2
ufs_unlock(v)
	void *v;
d1642 1
a1642 2
ufs_islocked(v)
	void *v;
d1656 1
a1656 2
ufs_strategy(v)
	void *v;
d1700 1
a1700 2
ufs_print(v)
	void *v;
d1728 1
a1728 2
ufsspec_read(v)
	void *v;
d1748 1
a1748 2
ufsspec_write(v)
	void *v;
d1770 1
a1770 2
ufsspec_close(v)
	void *v;
d1797 1
a1797 2
ufsfifo_read(v)
	void *v;
d1818 1
a1818 2
ufsfifo_write(v)
	void *v;
d1841 1
a1841 2
ufsfifo_close(v)
	void *v;
d1869 1
a1869 2
ufs_pathconf(v)
	void *v;
d1906 1
a1906 2
ufs_advlock(v)
	void *v;
d1926 2
a1927 5
ufs_vinit(mntp, specops, fifoops, vpp)
	struct mount *mntp;
	int (**specops)(void *);
	int (**fifoops)(void *);
	struct vnode **vpp;
d1991 2
a1992 5
ufs_makeinode(mode, dvp, vpp, cnp)
	int mode;
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
d2080 1
a2080 2
ufs_kqfilter(v)
	void *v;
@


1.66
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.65 2005/06/18 18:09:43 millert Exp $	*/
d859 2
a860 1
		error = relookup(fdvp, &fvp, fcnp);
a861 5
		if (error)
			return (error);
		if (fvp == NULL) {
			return (ENOENT);
		}
d1112 1
a1112 3
	error = relookup(fdvp, &fvp, fcnp);
	vrele(fdvp);
	if (error) {
d1116 1
@


1.65
log
@Remove remaining whiteout tentacles; OK deraadt@@ miod@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.64 2005/06/10 17:37:41 pedro Exp $	*/
a63 1
#include <ufs/ufs/extattr.h>
@


1.64
log
@Tweak softdep_change_linkcnt() so we can specify whether we're willing
to be co-opted by softdep or not, and use this new interface to inform
softdep in ufs_inactive() that the inode mode has changed.

We don't want to be co-opted there as that might lead to undesired
circular dependencies such as a vput() depending on another vput() to
complete, or a process that is trying to free up a vnode being blocked
trying to acquire a new vnode.

Okay tedu@@ deraadt@@, thanks to all those who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.63 2005/05/28 02:02:50 pedro Exp $	*/
a1253 3
	if (cnp->cn_flags & ISWHITEOUT)
		ip->i_ffs_flags |= UF_OPAQUE;

a2086 3

	if (cnp->cn_flags & ISWHITEOUT)
		ip->i_ffs_flags |= UF_OPAQUE;
@


1.63
log
@ufs_whiteout() is now pointless, remove it, okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.62 2005/05/22 21:12:42 pedro Exp $	*/
d723 1
a723 1
		softdep_change_linkcnt(ip);
d733 1
a733 1
			softdep_change_linkcnt(ip);
d933 1
a933 1
		softdep_change_linkcnt(ip);
d1000 1
a1000 1
                               softdep_change_linkcnt(dp);
d1007 1
a1007 1
					softdep_change_linkcnt(dp);
d1018 1
a1018 1
					softdep_change_linkcnt(dp);
d1074 1
a1074 1
					softdep_change_linkcnt(dp);
d1078 1
a1078 1
				softdep_change_linkcnt(xp);
d1185 1
a1185 1
			softdep_change_linkcnt(ip);
d1252 1
a1252 1
		softdep_change_linkcnt(ip);
d1266 1
a1266 1
		softdep_change_linkcnt(dp);
d1332 1
a1332 1
			softdep_change_linkcnt(dp);
d1341 1
a1341 1
			softdep_change_linkcnt(ip);
d1411 2
a1412 2
		softdep_change_linkcnt(dp);
		softdep_change_linkcnt(ip);
d1418 2
a1419 2
			softdep_change_linkcnt(dp);
			softdep_change_linkcnt(ip);
d2085 1
a2085 1
		softdep_change_linkcnt(ip);
d2121 1
a2121 1
		softdep_change_linkcnt(ip);
@


1.62
log
@put VLOCKSWORK stuff under a single option, VFSDEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.61 2005/04/23 15:13:57 pedro Exp $	*/
a744 62

/*
 * whiteout vnode call
 */
int
ufs_whiteout(v)
	void *v;
{
	struct vop_whiteout_args /* {
		struct vnode *a_dvp;
		struct componentname *a_cnp;
		int a_flags;
	} */ *ap = v;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	struct direct newdir;
	int error = 0;

	switch (ap->a_flags) {
	case LOOKUP:
		/* 4.4 format directories support whiteout operations */
		if (dvp->v_mount->mnt_maxsymlinklen > 0)
			return (0);
		return (EOPNOTSUPP);

	case CREATE:
		/* create a new directory whiteout */
#ifdef DIAGNOSTIC
		if ((cnp->cn_flags & SAVENAME) == 0)
			panic("ufs_whiteout: missing name");
		if (dvp->v_mount->mnt_maxsymlinklen <= 0)
			panic("ufs_whiteout: old format filesystem");
#endif

		newdir.d_ino = WINO;
		newdir.d_namlen = cnp->cn_namelen;
		bcopy(cnp->cn_nameptr, newdir.d_name, (unsigned)cnp->cn_namelen + 1);
		newdir.d_type = DT_WHT;
		error = ufs_direnter(dvp, NULL, &newdir, cnp, NULL);
		break;

	case DELETE:
		/* remove an existing directory whiteout */
#ifdef DIAGNOSTIC
		if (dvp->v_mount->mnt_maxsymlinklen <= 0)
			panic("ufs_whiteout: old format filesystem");
#endif

		cnp->cn_flags &= ~DOWHITEOUT;
		error = ufs_dirremove(dvp, NULL, cnp->cn_flags, 0);
		break;
	default:
		panic("ufs_whiteout: unknown op");
		/* NOTREACHED */
	}
	if (cnp->cn_flags & HASBUF) {
		pool_put(&namei_pool, cnp->cn_pnbuf);
		cnp->cn_flags &= ~HASBUF;
	}
	return (error);
}

@


1.61
log
@pay attention to failed relookups, compensate for a reference lost in
ufs_checkpath(), optimize a if/else's logical structure. diff mostly
from netbsd, okay tedu@@ fgsch@@ deraadt@@, tested by many, jcs@@ in
particular, thanks. fixes PRs 4040, 4126, 4169 and 4180.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.60 2005/02/17 18:07:37 jfb Exp $	*/
d2060 1
a2060 1
#ifdef DIAGNOSTIC
@


1.60
log
@miscellaneous typo fixes:
- sturct -> struct (spotted by pedro)
- elimination of consecutive 'the' words

ok jmc@@, henning@@, krw@@, robert@@, some whining by jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.59 2004/09/18 22:01:18 tedu Exp $	*/
d913 1
a913 1
		 * Relookup() may find a file that is unrelated to the
d922 1
a922 1
		(void) relookup(fdvp, &fvp, fcnp);
d924 2
d1022 4
a1025 1

d1179 1
a1179 1
	(void) relookup(fdvp, &fvp, fcnp);
d1181 5
a1185 4
	if (fvp != NULL) {
		xp = VTOI(fvp);
		dp = VTOI(fdvp);
	} else {
d1194 4
@


1.59
log
@hierarchy is spelled hierarchy, from Jonathan Gray
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.58 2004/07/25 23:09:19 tedu Exp $	*/
d1700 1
a1700 1
		sturct proc *a_p;
@


1.58
log
@more consistent handling of vnode recount during rename.
should solve some panics.  various testing for a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.57 2004/06/25 00:54:28 tholo Exp $	*/
d1002 1
a1002 1
	 * directory heirarchy above the target, as this would
@


1.57
log
@Minor fixes suggested by nordin@@ and henning@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.56 2004/06/24 19:35:27 tholo Exp $	*/
a915 1
		vrele(fdvp);
d923 1
a972 2
	/* Why? */
	vrele(fdvp);
d1175 1
d1228 1
@


1.56
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.55 2004/05/14 04:00:34 tedu Exp $	*/
d2082 1
a2082 1
	microuptime(&mtv);
@


1.55
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.54 2003/12/28 17:20:16 tedu Exp $	*/
d234 6
a239 2
	if (vp->v_usecount > 1)
		ITIMES(ip, &time, &time);
d308 1
d310 2
a311 1
	ITIMES(ip, &time, &time);
d1876 6
a1881 2
	if (ap->a_vp->v_usecount > 1)
		ITIMES(ip, &time, &time);
d1951 6
a1956 2
	if (ap->a_vp->v_usecount > 1)
		ITIMES(ip, &time, &time);
d2033 1
d2082 3
a2084 2
	SETHIGH(ip->i_modrev, mono_time.tv_sec);
	SETLOW(ip->i_modrev, mono_time.tv_usec * 4294);
@


1.54
log
@add ian dowse's dirhash code from freebsd.
by building a hash table for large directories, lookups and deletions
become about constant time.  this is an excellent improvement for dirs with
10k or more files.
some more cleanup to come, but the code works.
enabled with option UFS_DIRHASH
testing brad millert otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.53 2003/12/17 02:43:25 tedu Exp $	*/
d53 1
d729 1
a729 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
d795 1
a795 1
		FREE(cnp->cn_pnbuf, M_NAMEI);
d1285 1
a1285 1
		free(cnp->cn_pnbuf, M_NAMEI);
d1391 1
a1391 1
	FREE(cnp->cn_pnbuf, M_NAMEI);
d2098 1
a2098 1
		free(cnp->cn_pnbuf, M_NAMEI);
d2108 1
a2108 1
		free(cnp->cn_pnbuf, M_NAMEI);
d2141 1
a2141 1
		FREE(cnp->cn_pnbuf, M_NAMEI);
d2151 1
a2151 1
	free(cnp->cn_pnbuf, M_NAMEI);
@


1.53
log
@add NOTE_EOF (return on EOF) and NOTE_TRUNCATE (vnode was truncated)
to kqueue
from marius@@monkey  tested by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.52 2003/11/19 03:29:31 mickey Exp $	*/
d69 3
d1489 6
@


1.52
log
@undo boolshit unapproved changes the author does not even care about to fix
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.50 2003/09/23 16:51:13 millert Exp $	*/
d353 2
d400 1
d419 2
d444 1
a444 1
	VN_KNOTE(vp, NOTE_ATTRIB);
d2223 5
a2230 1

a2249 1

a2257 3



@


1.51
log
@MALLOC is not meant for variable size allocations
@
text
@d1576 1
a1576 1
			dirbuf = malloc(count, M_TEMP, M_WAITOK);
d1628 2
a1629 1
                cookies = malloc(ncookies * sizeof(u_long), M_TEMP, M_WAITOK);
@


1.50
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.49 2003/08/15 20:32:21 tedu Exp $	*/
d1576 1
a1576 1
			MALLOC(dirbuf, caddr_t, count, M_TEMP, M_WAITOK);
d1628 1
a1628 2
                MALLOC(cookies, u_long *, ncookies * sizeof(u_long), M_TEMP,
                    M_WAITOK);
@


1.49
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.48 2003/08/11 21:53:10 tedu Exp $	*/
d56 1
d586 1
a586 1
ufs_select(v)
d589 1
a589 2
#if 0
	struct vop_select_args /* {
d591 1
a591 3
		int  a_which;
		int  a_fflags;
		struct ucred *a_cred;
a593 1
#endif
d598 1
a598 1
	return (1);
@


1.48
log
@if we run out of space, make the dead vnode VNON.  if a VBLK gets out, it
causes trouble later.  netbsd pr22419
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.47 2003/06/02 23:28:23 millert Exp $	*/
d366 1
a366 1
		    (error = suser(cred, &p->p_acflag)))
d420 1
a420 1
		    (error = suser(cred, &p->p_acflag)) &&
d457 1
a457 1
	    (error = suser(cred, &p->p_acflag)))
d503 1
a503 1
	    (error = suser(cred, &p->p_acflag)))
d2112 1
a2112 1
	    suser(cnp->cn_cred, NULL))
@


1.47
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.46 2003/05/26 18:33:17 tedu Exp $	*/
d2146 1
@


1.46
log
@fiddle with some type names.  change most instances of ufs_daddr_t to
ufs1_daddr_t, a few to daddr_t.  ufs_daddr_t typedef is retained, but consider
it deprecated.  no functional changes.  inspired by freebsd.  ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.45 2002/05/23 12:46:42 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.45
log
@protect biodone calls with splbio.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.44 2002/03/14 01:27:18 millert Exp $	*/
d493 1
a493 1
	ufs_daddr_t change;
@


1.45.2.1
log
@MFC:
Fix by tedu@@

if we run out of space, make the dead vnode VNON.  if a VBLK gets out, it
causes trouble later.  netbsd pr22419

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.45 2002/05/23 12:46:42 art Exp $	*/
a2149 1
	tvp->v_type = VNON;
@


1.45.4.1
log
@MFC:
Fix by tedu@@

if we run out of space, make the dead vnode VNON.  if a VBLK gets out, it
causes trouble later.  netbsd pr22419

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.45 2002/05/23 12:46:42 art Exp $	*/
a2149 1
	tvp->v_type = VNON;
@


1.44
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.43 2002/02/22 20:51:24 drahn Exp $	*/
d1741 1
d1752 1
d1754 1
d1761 1
d1763 1
@


1.43
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.42 2001/12/19 08:58:07 art Exp $	*/
d74 6
a79 7
static int ufs_chmod __P((struct vnode *, int, struct ucred *, struct proc *));
static int ufs_chown
	__P((struct vnode *, uid_t, gid_t, struct ucred *, struct proc *));
int filt_ufsread __P((struct knote *kn, long hint));
int filt_ufswrite __P((struct knote *kn, long hint));
int filt_ufsvnode __P((struct knote *kn, long hint));
void filt_ufsdetach __P((struct knote *kn));
d1877 1
a1877 1
	extern int (**fifo_vnodeop_p) __P((void *));
d1899 1
a1899 1
	extern int (**fifo_vnodeop_p) __P((void *));
d1923 1
a1923 1
	extern int (**fifo_vnodeop_p) __P((void *));
d2000 2
a2001 2
	int (**specops) __P((void *));
	int (**fifoops) __P((void *));
@


1.42
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.39 2001/11/21 21:23:56 csapuntz Exp $	*/
d66 1
@


1.41
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.40 2001/11/27 05:27:12 art Exp $	*/
d472 2
@


1.41.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.41 2001/12/04 22:44:32 art Exp $	*/
d315 1
a315 1
	vap->va_size = vp->v_size;
@


1.41.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.41.2.1 2002/02/02 03:28:26 art Exp $	*/
a65 1
#include <ufs/ufs/extattr.h>
d73 7
a79 6
static int ufs_chmod(struct vnode *, int, struct ucred *, struct proc *);
static int ufs_chown(struct vnode *, uid_t, gid_t, struct ucred *, struct proc *);
int filt_ufsread(struct knote *kn, long hint);
int filt_ufswrite(struct knote *kn, long hint);
int filt_ufsvnode(struct knote *kn, long hint);
void filt_ufsdetach(struct knote *kn);
a1738 1
	int s;
a1748 1
			s = splbio();
a1749 1
			splx(s);
a1755 1
		s = splbio();
a1756 1
		splx(s);
d1875 1
a1875 1
	extern int (**fifo_vnodeop_p)(void *);
d1897 1
a1897 1
	extern int (**fifo_vnodeop_p)(void *);
d1921 1
a1921 1
	extern int (**fifo_vnodeop_p)(void *);
d1998 2
a1999 2
	int (**specops)(void *);
	int (**fifoops)(void *);
@


1.41.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.41.2.2 2002/06/11 03:32:50 art Exp $	*/
d714 1
a714 1
	if ((error = UFS_UPDATE(ip, UPDATE_DIROP)) == 0) {
d986 1
a986 1
	if ((error = UFS_UPDATE(ip, UPDATE_DIROP)) != 0) {
d1050 1
a1050 1
			if ((error = UFS_UPDATE(dp, UPDATE_DIROP)) 
d1068 1
a1068 1
				UFS_UPDATE(dp, UPDATE_WAIT|UPDATE_DIROP);
d1309 1
a1309 1
	if ((error = UFS_UPDATE(dp, UPDATE_DIROP)) != 0)
d1344 1
a1344 1
	if ((error = UFS_UPDATE(ip, UPDATE_DIROP)) != 0) {
d2123 1
a2123 1
	if ((error = UFS_UPDATE(ip, UPDATE_DIROP)) != 0)
@


1.41.2.4
log
@use vnode lock in place of inode lock, switch to genfs_lock
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.41.2.3 2002/11/04 18:02:32 art Exp $	*/
d1675 50
d1794 1
a1794 1
	lockmgr_printinfo(&ITOV(ip)->v_lock);
a2008 1
	struct proc *p = curproc;
d2019 2
a2023 1
			VOP_UNLOCK(vp, 0, p);
a2029 1
			lockmgr(&nvp->v_lock, LK_EXCLUSIVE, &nvp->v_interlock, p);
@


1.40
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.39 2001/11/21 21:23:56 csapuntz Exp $	*/
a603 22
}

/*
 * Mmap a file
 *
 * NB Currently unsupported.
 */
/* ARGSUSED */
int
ufs_mmap(v)
	void *v;
{
#if 0
	struct vop_mmap_args /* {
		struct vnode *a_vp;
		int  a_fflags;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
#endif

	return (EINVAL);
@


1.39
log
@Don't use #define QUOTA - use stub file instead

Pass over the quota code in ufs/. Make code paths clearer. Clean up some names.
Move all code that manipulates quotas directly into ufs_quota.c

Use vfs_mount_foreach_vnode to traverse list of vnodes in mountpoint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.38 2001/11/06 19:53:21 miod Exp $	*/
a471 2
	if ((vp->v_flag & VTEXT) && (ip->i_ffs_mode & S_ISTXT) == 0)
		(void) uvm_vnp_uncache(vp);
@


1.38
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.37 2001/09/05 19:22:23 deraadt Exp $	*/
a259 1
#ifdef QUOTA
a260 1
#endif
d266 1
a266 1
#ifdef QUOTA
a268 1
#endif
d493 2
a494 4
#ifdef QUOTA
	int i;
	long change;
#endif
d511 8
a518 1
#ifdef QUOTA
d521 4
a524 16
	if (ouid == uid) {
		dqrele(vp, ip->i_dquot[USRQUOTA]);
		ip->i_dquot[USRQUOTA] = NODQUOT;
	}
	if (ogid == gid) {
		dqrele(vp, ip->i_dquot[GRPQUOTA]);
		ip->i_dquot[GRPQUOTA] = NODQUOT;
	}
	change = ip->i_ffs_blocks;
	(void) chkdq(ip, -change, cred, CHOWN);
	(void) chkiq(ip, -1, cred, CHOWN);
	for (i = 0; i < MAXQUOTAS; i++) {
		dqrele(vp, ip->i_dquot[i]);
		ip->i_dquot[i] = NODQUOT;
	}
#endif
d527 13
a539 20
#ifdef QUOTA
	if ((error = getinoquota(ip)) == 0) {
		if (ouid == uid) {
			dqrele(vp, ip->i_dquot[USRQUOTA]);
			ip->i_dquot[USRQUOTA] = NODQUOT;
		}
		if (ogid == gid) {
			dqrele(vp, ip->i_dquot[GRPQUOTA]);
			ip->i_dquot[GRPQUOTA] = NODQUOT;
		}
		if ((error = chkdq(ip, change, cred, CHOWN)) == 0) {
			if ((error = chkiq(ip, 1, cred, CHOWN)) == 0)
				goto good;
			else
				(void) chkdq(ip, -change, cred, CHOWN|FORCE);
		}
		for (i = 0; i < MAXQUOTAS; i++) {
			dqrele(vp, ip->i_dquot[i]);
			ip->i_dquot[i] = NODQUOT;
		}
d541 1
a541 17
	ip->i_ffs_gid = ogid;
	ip->i_ffs_uid = ouid;
	if (getinoquota(ip) == 0) {
		if (ouid == uid) {
			dqrele(vp, ip->i_dquot[USRQUOTA]);
			ip->i_dquot[USRQUOTA] = NODQUOT;
		}
		if (ogid == gid) {
			dqrele(vp, ip->i_dquot[GRPQUOTA]);
			ip->i_dquot[GRPQUOTA] = NODQUOT;
		}
		(void) chkdq(ip, change, cred, FORCE|CHOWN);
		(void) chkiq(ip, 1, cred, FORCE|CHOWN);
		(void) getinoquota(ip);
	}
	return (error);
good:
d544 1
a544 1
#endif /* QUOTA */
d552 15
d1302 1
a1302 1
#ifdef QUOTA
d1304 1
a1304 1
	    (error = chkiq(ip, 1, cnp->cn_cred, 0))) {
d1311 1
a1311 1
#endif
d2114 1
a2114 1
#ifdef QUOTA
d2116 1
a2116 1
	    (error = chkiq(ip, 1, cnp->cn_cred, 0))) {
d2123 1
a2123 1
#endif
@


1.37
log
@use %ll instead of %q
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.36 2001/07/26 20:24:47 millert Exp $	*/
a59 2

#include <vm/vm.h>
@


1.36
log
@Back out changes to symlink and mknod that were not well tested.
A simple mknod at causes a kernel panic (uvm_fault).
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.34 2001/06/27 04:58:49 art Exp $	*/
d1826 1
a1826 1
	printf("\tmode 0%o, owner %d, group %d, size %qd",
@


1.35
log
@change vop_symlink and vop_mknod to return vpp (the created node)
refed, so that the caller can actually use it.  update callers and
file systems that implement these vnode operations

ok'd by art
@
text
@a154 2
	struct mount *mp;	
	ino_t	     ino;
d180 1
a180 5
	error = VFS_VGET(mp, ino, vpp);
	if (error != 0) {
		*vpp = NULL;
		return (error);
	}
d1571 1
a1571 2
	if (error)
		vput(vp);
@


1.34
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.33 2001/06/23 02:07:57 csapuntz Exp $	*/
d155 2
d182 5
a186 1
	*vpp = 0;
d1577 2
a1578 1
	vput(vp);
@


1.33
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.32 2001/06/04 15:11:47 provos Exp $	*/
a62 1
#if defined(UVM)
a63 1
#endif
a477 1
#if defined(UVM)
a478 3
#else
		(void) vnode_pager_uncache(vp);
#endif
a1371 1
#if defined(UVM)
a1372 3
#else
	vnode_pager_setsize(tvp, (u_long)ip->i_ffs_size);
#endif
@


1.32
log
@make kqueue behave like select when testing for write instead of bailing
out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.31 2001/04/25 21:31:17 csapuntz Exp $	*/
d424 1
a424 1
 		if ((error = VOP_TRUNCATE(vp, vap->va_size, 0, cred, p)) != 0)
a426 1
	ip = VTOI(vp);
d439 1
a439 1
		error = VOP_UPDATE(vp, &vap->va_atime, &vap->va_mtime, 0);
a727 1
	struct timespec ts;
d764 1
a764 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	if ((error = VOP_UPDATE(vp, &ts, &ts, !DOINGSOFTDEP(vp))) == 0) {
a892 1
	struct timespec ts;
d1036 1
a1036 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	if ((error = VOP_UPDATE(fvp, &ts, &ts, !DOINGSOFTDEP(fvp))) != 0) {
d1100 2
a1101 2
			if ((error = VOP_UPDATE(tdvp, &ts, &ts,
						!DOINGSOFTDEP(tdvp))) != 0) {
d1118 1
a1118 1
				(void)VOP_UPDATE(tdvp, &ts, &ts, 1);
d1198 2
a1199 2
			if ((error = VOP_TRUNCATE(tvp, (off_t)0, IO_SYNC,
			        tcnp->cn_cred, tcnp->cn_proc)) != 0)
a1304 1
	struct timespec ts;
d1323 1
a1323 1
	if ((error = VOP_VALLOC(dvp, dmode, cnp->cn_cred, &tvp)) != 0)
d1332 1
a1332 1
		VOP_VFREE(tvp, ip->i_number, dmode);
d1359 1
a1359 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	if ((error = VOP_UPDATE(dvp, &ts, &ts, !DOINGSOFTDEP(dvp))) != 0)
d1373 1
a1373 1
	if ((error = VOP_BALLOC(tvp, (off_t)0, DIRBLKSIZ, cnp->cn_cred,
d1398 1
a1398 1
	if ((error = VOP_UPDATE(tvp, &ts, &ts, !DOINGSOFTDEP(tvp))) != 0) {
d1537 1
a1537 2
		error = VOP_TRUNCATE(vp, (off_t)0, ioflag, cnp->cn_cred,
		    cnp->cn_proc);
a2123 1
	struct timespec ts;
d2136 1
a2136 1
	if ((error = VOP_VALLOC(dvp, mode, cnp->cn_cred, &tvp)) != 0) {
d2148 1
a2148 1
		VOP_VFREE(tvp, ip->i_number, mode);
d2172 1
a2172 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	if ((error = VOP_UPDATE(tvp, &ts, &ts, !DOINGSOFTDEP(tvp))) != 0)
@


1.31
log
@

Quick fix for code path in RENAME in case relookup doesn't find the file again

Also, get rid of a bogus comment.

Patch from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.30 2001/03/01 20:54:36 provos Exp $	*/
d81 1
d2214 2
d2234 3
d2282 17
@


1.31.2.1
log
@Pull in patch from current:
Fix (provos):
make kqueue behave like select when testing for write instead of bailing out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.31 2001/04/25 21:31:17 csapuntz Exp $	*/
a80 1
int filt_ufswrite __P((struct knote *kn, long hint));
a2212 2
struct filterops ufswrite_filtops = 
	{ 1, NULL, filt_ufsdetach, filt_ufswrite };
a2230 3
	case EVFILT_WRITE:
		kn->kn_fop = &ufswrite_filtops;
		break;
a2275 17
}


int
filt_ufswrite(struct knote *kn, long hint)
{
	/*
	 * filesystem is gone, so set the EOF flag and schedule 
	 * the knote for deletion.
	 */
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
		return (1);
	}

        kn->kn_data = 0;
        return (1);
@


1.30
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.29 2001/02/21 23:24:32 csapuntz Exp $	*/
a923 3
	/*
	 * Check if just deleting a link name.
	 */
d967 3
@


1.29
log
@

Latest soft updates from FreeBSD/Kirk McKusick

Snapshot-related code has been commented out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.28 2000/11/21 21:49:57 provos Exp $	*/
d80 3
d2210 81
@


1.28
log
@support for kernel events on vnodes, from jlemon@@freebsd.org, okay art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.27 1999/03/09 21:16:28 art Exp $	*/
d761 1
a761 1
		softdep_increase_linkcnt(ip);
d771 2
d929 8
d939 6
a944 1
			error = EINVAL;
d953 6
a958 1
		/* Delete source. */
d1035 1
a1035 1
		softdep_increase_linkcnt(ip);
d1100 1
a1100 1
                               softdep_increase_linkcnt(dp);
d1106 2
d1117 2
d1132 1
a1132 1
			panic("rename: same file");
d1173 2
a1174 1
				dp->i_flag |= IN_CHANGE;
d1177 2
a1178 1
			xp->i_flag |= IN_CHANGE;
d1192 1
a1192 1
			if (!newparent)
d1194 2
d1198 1
d1226 1
a1226 1
			panic("rename: lost dir entry");
d1241 1
a1241 1
			panic("rename: lost dir entry");
d1276 3
d1346 1
a1346 1
		softdep_increase_linkcnt(ip);
d1360 1
a1360 1
		softdep_increase_linkcnt(dp);
d1430 2
d1439 2
a1440 1

d1507 13
a1519 1
	if ((error = ufs_dirremove(dvp, ip, cnp->cn_flags, 1)) != 0)
d1521 2
d1528 3
a1530 5
	 * it. We have removed the "." reference and the reference in the
	 * parent directory, but there may be other hard links. The soft
	 * update code will arange to do these operations after the parent
	 * directory has been deleted on disk, so when running with
	 * that code we avoid doing them now.
a1531 4
	dp->i_effnlink--;
	dp->i_flag |= IN_CHANGE;
	ip->i_effnlink--;
	ip->i_flag |= IN_CHANGE;
d1533 2
d1536 1
d1538 4
a1541 2
		error = VOP_TRUNCATE(vp, (off_t)0, IO_SYNC, cnp->cn_cred,
		   cnp->cn_proc);
d2165 1
a2165 1
		softdep_increase_linkcnt(ip);
d2201 2
@


1.27
log
@POSIX says:
If O_TRUNC is set and the file did previously exist, upon successful
completion the open() function shall mark for update the st_ctime and st_mtime
fields of the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.26 1999/02/26 05:55:10 millert Exp $	*/
d59 1
d97 2
d126 3
a128 1
	return
d131 4
d160 1
d446 1
d691 1
a691 1
	    (VTOI(dvp)->i_ffs_flags & APPEND))
d693 6
a698 3
	else
		error = ufs_dirremove(dvp, ip, ap->a_cnp->cn_flags, 0);

d773 2
d992 1
d1099 1
d1174 1
d1176 1
d1228 1
d1392 1
d1474 1
d1497 1
d1525 1
@


1.27.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.30 2001/03/01 20:54:36 provos Exp $	*/
a58 1
#include <sys/event.h>
a78 3
int filt_ufsread __P((struct knote *kn, long hint));
int filt_ufsvnode __P((struct knote *kn, long hint));
void filt_ufsdetach __P((struct knote *kn));
a95 2
#define VN_KNOTE(vp, b) \
	KNOTE(&vp->v_selectinfo.vsi_selinfo.si_note, (b))
d123 1
a123 3
	int error;

	error =
a125 4
	if (error)
		return (error);
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);
	return (0);
a150 1
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);
a435 1
	VN_KNOTE(vp, NOTE_ATTRIB);
d680 1
a680 1
	    (VTOI(dvp)->i_ffs_flags & APPEND)) {
d682 3
a684 6
		goto out;
	}
	error = ufs_dirremove(dvp, ip, ap->a_cnp->cn_flags, 0);
	VN_KNOTE(vp, NOTE_DELETE);
	VN_KNOTE(dvp, NOTE_WRITE);
 out:
d747 1
a747 1
		softdep_change_linkcnt(ip);
a756 2
		if (DOINGSOFTDEP(vp))
			softdep_change_linkcnt(ip);
a758 2
	VN_KNOTE(vp, NOTE_LINK);
	VN_KNOTE(dvp, NOTE_WRITE);
a910 8

	/*
	 * Check if just deleting a link name or if we've lost a race.
	 * If another process completes the same rename after we've looked
	 * up the source and have blocked looking up the target, then the
	 * source and target inodes may be identical now although the
	 * names were never linked.
	 */
d913 1
a913 6
			/*
			 * Linked directories are impossible, so we must
			 * have lost the race.  Pretend that the rename
			 * completed before the lookup.
			 */
			error = ENOENT;
d922 1
a922 6
		/*
		 * Delete source.  There is another race now that everything
		 * is unlocked, but this doesn't cause any new complications.
		 * Relookup() may find a file that is unrelated to the
		 * original one, or it may fail.  Too bad.
		 */
a975 1
	VN_KNOTE(fdvp, NOTE_WRITE);		/* XXX right place? */
d998 1
a998 1
		softdep_change_linkcnt(ip);
d1063 1
a1063 1
                               softdep_change_linkcnt(dp);
a1068 2
				if (DOINGSOFTDEP(tdvp))
					softdep_change_linkcnt(dp);
a1077 2
				if (DOINGSOFTDEP(tdvp))
					softdep_change_linkcnt(dp);
a1081 1
		VN_KNOTE(tdvp, NOTE_WRITE);
d1090 1
a1090 1
			panic("ufs_rename: same file");
d1131 1
a1131 2
				if (DOINGSOFTDEP(tdvp))
					softdep_change_linkcnt(dp);
d1134 1
a1134 2
			if (DOINGSOFTDEP(tvp))
				softdep_change_linkcnt(xp);
d1148 1
a1148 1
			if (!newparent) {
a1149 2
				dp->i_flag |= IN_CHANGE;
			}
a1151 1
			xp->i_flag |= IN_CHANGE;
a1155 1
		VN_KNOTE(tdvp, NOTE_WRITE);
a1156 1
		VN_KNOTE(tvp, NOTE_DELETE);
d1177 1
a1177 1
			panic("ufs_rename: lost dir entry");
d1192 1
a1192 1
			panic("ufs_rename: lost dir entry");
a1207 1
	VN_KNOTE(fvp, NOTE_RENAME);
a1225 3
		ip->i_flag &= ~IN_RENAME;
		if (DOINGSOFTDEP(fvp))
			softdep_change_linkcnt(ip);
d1293 1
a1293 1
		softdep_change_linkcnt(ip);
d1307 1
a1307 1
		softdep_change_linkcnt(dp);
a1370 1
		VN_KNOTE(dvp, NOTE_WRITE);
a1375 2
		if (DOINGSOFTDEP(dvp))
			softdep_change_linkcnt(dp);
d1383 1
a1383 2
		if (DOINGSOFTDEP(tvp))
			softdep_change_linkcnt(ip);
d1450 1
a1450 13
	dp->i_effnlink--;
	ip->i_effnlink--;
	if (DOINGSOFTDEP(vp)) {
		softdep_change_linkcnt(dp);
		softdep_change_linkcnt(ip);
	}
	if ((error = ufs_dirremove(dvp, ip, cnp->cn_flags, 1)) != 0) {
		dp->i_effnlink++;
		ip->i_effnlink++;
		if (DOINGSOFTDEP(vp)) {
			softdep_change_linkcnt(dp);
			softdep_change_linkcnt(ip);
		}
a1451 3
	}

	VN_KNOTE(dvp, NOTE_WRITE | NOTE_LINK);
d1456 5
a1460 3
	 * it. The soft dependency code will arrange to do these operations
	 * after the parent directory entry has been deleted on disk, so
	 * when running with that code we avoid doing them now.
d1462 4
a1466 2
		int ioflag;

a1467 1
		dp->i_flag |= IN_CHANGE;
d1469 2
a1470 4
		ip->i_flag |= IN_CHANGE;
		ioflag = DOINGASYNC(vp) ? 0 : IO_SYNC;
		error = VOP_TRUNCATE(vp, (off_t)0, ioflag, cnp->cn_cred,
		    cnp->cn_proc);
a1473 1
	VN_KNOTE(vp, NOTE_DELETE);
a1500 1
	VN_KNOTE(ap->a_dvp, NOTE_WRITE);
d2092 1
a2092 1
		softdep_change_linkcnt(ip);
a2127 2
	if (DOINGSOFTDEP(tvp))
		softdep_change_linkcnt(ip);
a2131 81

struct filterops ufsread_filtops = 
	{ 1, NULL, filt_ufsdetach, filt_ufsread };
struct filterops ufsvnode_filtops = 
	{ 1, NULL, filt_ufsdetach, filt_ufsvnode };

int
ufs_kqfilter(v)
	void *v;
{
	struct vop_kqfilter_args /* {
		struct vnode *a_vp;
		struct knote *a_kn;
	} */ *ap = v;
	struct vnode *vp = ap->a_vp;
	struct knote *kn = ap->a_kn;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &ufsread_filtops;
		break;
	case EVFILT_VNODE:
		kn->kn_fop = &ufsvnode_filtops;
		break;
	default:
		return (1);
	}

	kn->kn_hook = (caddr_t)vp;

	simple_lock(&vp->v_selectinfo.vsi_lock);
	SLIST_INSERT_HEAD(&vp->v_selectinfo.vsi_selinfo.si_note, kn, kn_selnext);
	simple_unlock(&vp->v_selectinfo.vsi_lock);

	return (0);
}

void
filt_ufsdetach(struct knote *kn)
{
	struct vnode *vp = (struct vnode *)kn->kn_hook;

	simple_lock(&vp->v_selectinfo.vsi_lock);
	SLIST_REMOVE(&vp->v_selectinfo.vsi_selinfo.si_note,
	    kn, knote, kn_selnext);
	simple_unlock(&vp->v_selectinfo.vsi_lock);
}

/*ARGSUSED*/
int
filt_ufsread(struct knote *kn, long hint)
{
	struct vnode *vp = (struct vnode *)kn->kn_hook;
	struct inode *ip = VTOI(vp);

	/*
	 * filesystem is gone, so set the EOF flag and schedule 
	 * the knote for deletion.
	 */
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
		return (1);
	}

        kn->kn_data = ip->i_ffs_size - kn->kn_fp->f_offset;
        return (kn->kn_data != 0);
}

int
filt_ufsvnode(struct knote *kn, long hint)
{

	if (kn->kn_sfflags & hint)
		kn->kn_fflags |= hint;
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= EV_EOF;
		return (1);
	}
	return (kn->kn_fflags != 0);
}

@


1.27.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.27.6.1 2001/05/14 22:47:43 niklas Exp $	*/
d63 1
d65 1
a80 1
int filt_ufswrite __P((struct knote *kn, long hint));
d423 1
a423 1
 		if ((error = UFS_TRUNCATE(ip, vap->va_size, 0, cred)) != 0)
d426 1
d439 1
a439 1
		error = UFS_UPDATE2(ip, &vap->va_atime, &vap->va_mtime, 0);
d480 1
d482 3
d728 1
d765 2
a766 1
	if ((error = UFS_UPDATE(ip, !DOINGSOFTDEP(vp))) == 0) {
d895 1
d924 3
a969 3
		if (fvp == NULL) {
			return (ENOENT);
		}
d1039 2
a1040 1
	if ((error = UFS_UPDATE(ip, !DOINGSOFTDEP(fvp))) != 0) {
d1104 2
a1105 2
			if ((error = UFS_UPDATE(dp, !DOINGSOFTDEP(tdvp))) 
			    != 0) {
d1122 1
a1122 1
				(void)UFS_UPDATE(dp, 1);
d1202 2
a1203 2
			if ((error = UFS_TRUNCATE(VTOI(tvp), (off_t)0, IO_SYNC,
			        tcnp->cn_cred)) != 0)
d1309 1
d1328 1
a1328 1
	if ((error = UFS_INODE_ALLOC(dp, dmode, cnp->cn_cred, &tvp)) != 0)
d1337 1
a1337 1
		UFS_INODE_FREE(ip, ip->i_number, dmode);
d1364 2
a1365 1
	if ((error = UFS_UPDATE(dp, !DOINGSOFTDEP(dvp))) != 0)
d1379 1
a1379 1
	if ((error = UFS_BUF_ALLOC(ip, (off_t)0, DIRBLKSIZ, cnp->cn_cred,
d1384 1
d1386 3
d1404 1
a1404 1
	if ((error = UFS_UPDATE(ip, !DOINGSOFTDEP(tvp))) != 0) {
d1543 2
a1544 1
		error = UFS_TRUNCATE(ip, (off_t)0, ioflag, cnp->cn_cred);
d2131 1
d2144 1
a2144 1
	if ((error = UFS_INODE_ALLOC(pdir, mode, cnp->cn_cred, &tvp)) != 0) {
d2156 1
a2156 1
		UFS_INODE_FREE(ip, ip->i_number, mode);
d2180 2
a2181 1
	if ((error = UFS_UPDATE(ip, !DOINGSOFTDEP(tvp))) != 0)
a2212 2
struct filterops ufswrite_filtops = 
	{ 1, NULL, filt_ufsdetach, filt_ufswrite };
a2230 3
	case EVFILT_WRITE:
		kn->kn_fop = &ufswrite_filtops;
		break;
a2275 17
}


int
filt_ufswrite(struct knote *kn, long hint)
{
	/*
	 * filesystem is gone, so set the EOF flag and schedule 
	 * the knote for deletion.
	 */
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
		return (1);
	}

        kn->kn_data = 0;
        return (1);
@


1.27.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.27.6.2 2001/07/04 11:00:57 niklas Exp $	*/
d1826 1
a1826 1
	printf("\tmode 0%o, owner %d, group %d, size %lld",
@


1.27.6.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 2
@


1.27.6.5
log
@Merge in -current
@
text
@d260 1
d262 1
d268 1
a268 1

d271 1
d475 2
d496 4
a499 2
	ufs_daddr_t change;
	enum ufs_quota_flags quota_flags = 0;
d516 1
a516 8
	change = ip->i_ffs_blocks;

	if (ouid == uid)
		quota_flags |= UFS_QUOTA_NOUID;
	
	if (ogid == gid)
		quota_flags |= UFS_QUOTA_NOGID;

d519 16
a534 4
	(void) ufs_quota_free_blocks2(ip, change, cred, quota_flags);
	(void) ufs_quota_free_inode2(ip, cred, quota_flags);
	(void) ufs_quota_delete(ip);

d537 35
a571 13

	if ((error = getinoquota(ip)) != 0)
		goto error;

	if ((error = ufs_quota_alloc_blocks2(ip, change, cred, 
		 quota_flags)) != 0) 
		goto error;

	if ((error = ufs_quota_alloc_inode2(ip, cred ,
		 quota_flags)) != 0) {
		(void)ufs_quota_free_blocks2(ip, change, cred, 
		    quota_flags);		
		goto error;
d573 2
a574 1

d577 1
a577 1

a584 15

error:
	(void) ufs_quota_delete(ip);

	ip->i_ffs_gid = ogid;
	ip->i_ffs_uid = ouid;
	if (getinoquota(ip) == 0) {
		(void) ufs_quota_alloc_blocks2(ip, change, cred, 
		    quota_flags | UFS_QUOTA_FORCE);
		(void) ufs_quota_alloc_inode2(ip, cred,
		    quota_flags | UFS_QUOTA_FORCE);
		(void) getinoquota(ip);
	}
	return (error);

d1320 1
a1320 1

d1322 1
a1322 1
	    (error = ufs_quota_alloc_inode(ip, cnp->cn_cred))) {
d1329 1
a1329 1

d2132 1
a2132 1

d2134 1
a2134 1
	    (error = ufs_quota_alloc_inode(ip, cnp->cn_cred))) {
d2141 1
a2141 1

@


1.27.6.6
log
@Merge in trunk
@
text
@a65 1
#include <ufs/ufs/extattr.h>
a471 2
	if ((vp->v_flag & VTEXT) && (ip->i_ffs_mode & S_ISTXT) == 0)
		(void) uvm_vnp_uncache(vp);
d604 22
@


1.27.6.7
log
@Merge in -current from roughly a week ago
@
text
@d74 7
a80 6
static int ufs_chmod(struct vnode *, int, struct ucred *, struct proc *);
static int ufs_chown(struct vnode *, uid_t, gid_t, struct ucred *, struct proc *);
int filt_ufsread(struct knote *kn, long hint);
int filt_ufswrite(struct knote *kn, long hint);
int filt_ufsvnode(struct knote *kn, long hint);
void filt_ufsdetach(struct knote *kn);
d1878 1
a1878 1
	extern int (**fifo_vnodeop_p)(void *);
d1900 1
a1900 1
	extern int (**fifo_vnodeop_p)(void *);
d1924 1
a1924 1
	extern int (**fifo_vnodeop_p)(void *);
d2001 2
a2002 2
	int (**specops)(void *);
	int (**fifoops)(void *);
@


1.27.6.8
log
@Sync the SMP branch with 3.3
@
text
@a1740 1
	int s;
a1750 1
			s = splbio();
a1751 1
			splx(s);
a1757 1
		s = splbio();
a1758 1
		splx(s);
@


1.27.6.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.27.6.8 2003/03/28 00:08:48 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
d493 1
a493 1
	daddr_t change;
@


1.27.6.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a55 1
#include <sys/poll.h>
a67 3
#ifdef UFS_DIRHASH
#include <ufs/ufs/dirhash.h>
#endif
a351 2
	long hint = NOTE_ATTRIB;
	u_quad_t oldsize;
d366 1
a366 1
		    (error = suser_ucred(cred)))
a396 1
		oldsize = ip->i_ffs_size;
a414 2
		if (vap->va_size < oldsize)
			hint |= NOTE_TRUNCATE;
d420 1
a420 1
		    (error = suser_ucred(cred)) &&
d438 1
a438 1
	VN_KNOTE(vp, hint);
d457 1
a457 1
	    (error = suser_ucred(cred)))
d503 1
a503 1
	    (error = suser_ucred(cred)))
d585 1
a585 1
ufs_poll(v)
d588 2
a589 1
	struct vop_poll_args /* {
d591 3
a593 1
		int  a_events;
d596 1
d601 1
a601 1
	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
a1483 6
#ifdef UFS_DIRHASH
	/* Kill any active hash; i_effnlink == 0, so it will not come back. */
	if (ip->i_dirhash != NULL)
		ufsdirhash_free(ip);
#endif

d2112 1
a2112 1
	    suser_ucred(cnp->cn_cred))
a2145 1
	tvp->v_type = VNON;
a2219 5
	if (kn->kn_data == 0 && kn->kn_sfflags & NOTE_EOF) {
		kn->kn_fflags |= NOTE_EOF;
		return (1);
	}

d2223 1
d2243 1
d2252 3
@


1.27.6.11
log
@Merge with the trunk
@
text
@a52 1
#include <sys/pool.h>
d728 1
a728 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d794 1
a794 1
		pool_put(&namei_pool, cnp->cn_pnbuf);
d1284 1
a1284 1
		pool_put(&namei_pool, cnp->cn_pnbuf);
d1390 1
a1390 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
d2097 1
a2097 1
		pool_put(&namei_pool, cnp->cn_pnbuf);
d2107 1
a2107 1
		pool_put(&namei_pool, cnp->cn_pnbuf);
d2140 1
a2140 1
		pool_put(&namei_pool, cnp->cn_pnbuf);
d2150 1
a2150 1
	pool_put(&namei_pool, cnp->cn_pnbuf);
@


1.26
log
@Better fix for i_nlink oflow from imp@@openbsd.org
Move the check up with the other sanity checks and unlock the vnode
properly and jump to abortit, not bad when >= LINK_MAX.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.25 1999/02/26 03:35:18 art Exp $	*/
d187 2
a188 1
				} */ *ap = v;
d193 1
a193 1
	if ((VTOI(ap->a_vp)->i_ffs_flags & APPEND) &&
d196 4
@


1.25
log
@compat with uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.24 1999/02/25 07:30:50 millert Exp $	*/
d935 5
a988 4
	if ((nlink_t)dp->i_ffs_nlink >= LINK_MAX) {
		error = EMLINK;
		goto bad;
	}
@


1.24
log
@Add missing check for i_ffs_nlink > LINK_MAX; marcs@@znep.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.23 1999/01/16 12:56:27 niklas Exp $	*/
d62 4
d461 3
d465 1
d1322 3
d1326 1
@


1.23
log
@Do not lose st_blocks when files > 2GB
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.22 1998/12/05 16:58:26 csapuntz Exp $	*/
d976 4
@


1.22
log
@

Make sure the VLOCKSWORK diagnostic flag is correctly maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.21 1998/11/12 04:30:03 csapuntz Exp $	*/
d315 1
a315 1
	vap->va_bytes = dbtob(ip->i_ffs_blocks);
@


1.21
log
@

Integrate latest soft updates patches for McKusick.

Integrate cleaner ffs mount code from FreeBSD. Most notably, this mount
code prevents you from mounting an unclean file system read-write.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.20 1998/08/06 19:35:15 csapuntz Exp $	*/
d1983 3
@


1.20
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.19 1998/07/28 00:13:18 millert Exp $	*/
d667 1
a667 1
	    (VTOI(dvp)->i_ffs_flags & APPEND)) {
d669 3
a671 5
		goto out;
	}
	if ((error = ufs_dirremove(dvp, ip, ap->a_cnp->cn_flags, 0)) != 0)
		goto out;
out:
d956 1
a956 1
		doingdirectory++;
d1047 4
a1050 1
						!DOINGSOFTDEP(tdvp))) != 0)
d1052 1
d1107 2
a1108 1
                   IFTODT(ip->i_ffs_mode), doingdirectory)) != 0)
d1111 4
a1114 2
			dp->i_effnlink--;
			dp->i_flag |= IN_CHANGE;
d1130 3
a1132 1
			dp->i_ffs_nlink--;
d1236 1
a1236 1
	int error, dmode;
d1312 14
d1392 1
a1392 1
	 * No rmdir "." please.
d1394 5
a1398 2
	if (dp == ip) {
		vrele(dvp);
d1435 4
a1438 6
	 * parent directory, but there may be other hard links. So,
	 * ufs_dirremove will set the UF_IMMUTABLE flag to ensure that no
	 * new entries are made. The soft dependency code will arrange to
	 * do these operations after the parent directory entry has been
	 * deleted on disk, so when running with that code we avoid doing
	 * them now.
@


1.19
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.18 1997/12/11 04:25:46 csapuntz Exp $	*/
a1612 18
}

/*
 * Ufs abort op, called after namei() when a CREATE/DELETE isn't actually
 * done. If a buffer has been saved in anticipation of a CREATE, delete it.
 */
/* ARGSUSED */
int
ufs_abortop(v)
	void *v;
{
	struct vop_abortop_args /* {
		struct vnode *a_dvp;
		struct componentname *a_cnp;
	} */ *ap = v;
	if ((ap->a_cnp->cn_flags & (HASBUF | SAVESTART)) == HASBUF)
		FREE(ap->a_cnp->cn_pnbuf, M_NAMEI);
	return (0);
@


1.18
log
@Fix rename in a better way
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.17 1997/12/02 17:11:13 csapuntz Exp $	*/
d1466 1
a1466 1
		    UIO_SYSSPACE, IO_NODELOCKED, ap->a_cnp->cn_cred, (int *)0,
@


1.17
log
@Unlock child temporarily while truncating directory. This prevents
a double locking bug in the soft updates code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.16 1997/11/06 23:07:24 csapuntz Exp $	*/
d922 1
d925 2
d960 1
d1001 2
d1010 2
d1053 1
a1053 1
		if ((error = ufs_direnter(tdvp, fvp, &newdir, tcnp, NULL)) != 0) {
@


1.16
log
@Small fix to compile with DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.15 1997/11/06 17:23:01 kstailey Exp $	*/
d740 1
a740 1
		error = ufs_direnter(dvp, &newdir, cnp, NULL);
d793 1
a793 1
		error = ufs_direnter(dvp, &newdir, cnp, NULL);
d1045 1
a1045 1
		if ((error = ufs_direnter(tdvp, &newdir, tcnp, NULL)) != 0) {
d1316 1
a1316 1
        error = ufs_direnter(dvp, &newdir, cnp, bp);
d1731 5
d2072 1
a2072 1
	if ((error = ufs_direnter(dvp, &newdir, cnp, NULL)) != 0)
@


1.15
log
@fix warning about unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.14 1997/11/06 05:59:29 csapuntz Exp $	*/
d1797 2
a1798 1
	struct inode *ip = VTOI(ap->a_vp);
@


1.14
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.13 1997/10/06 20:21:50 deraadt Exp $	*/
d241 1
d243 1
@


1.13
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.10 1997/07/03 17:49:49 deraadt Exp $	*/
d93 13
d133 8
a140 8
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
	register struct vattr *vap = ap->a_vap;
	register struct vnode **vpp = ap->a_vpp;
	register struct inode *ip;
d144 2
a145 2
	    ufs_makeinode(MAKEIMODE(vap->va_type, vap->va_mode),
	    ap->a_dvp, vpp, ap->a_cnp)) != 0)
d179 5
a183 5
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d210 2
a211 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d213 2
a214 1
	if (vp->v_usecount > 1 && !(ip->i_flag & IN_LOCKED))
d216 1
d230 2
a231 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d234 6
a239 8
#ifdef DIAGNOSTIC
	if (!VOP_ISLOCKED(vp)) {
		vprint("ufs_access: not locked", vp);
		panic("ufs_access: not locked");
	}
#endif
#ifdef QUOTA
	if (mode & VWRITE)
d245 3
d250 1
d259 1
d261 1
a261 1
#endif
d282 3
a284 3
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
	register struct vattr *vap = ap->a_vap;
d293 1
a293 1
	vap->va_nlink = ip->i_ffs_nlink;
d332 5
a336 5
	register struct vattr *vap = ap->a_vap;
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
	register struct ucred *cred = ap->a_cred;
	register struct proc *p = ap->a_p;
d349 2
d360 2
a361 1
			if (ip->i_ffs_flags & (SF_IMMUTABLE | SF_APPEND))
d376 2
d383 18
a400 5
		if (vp->v_type == VDIR)
			return (EISDIR);
		error = VOP_TRUNCATE(vp, vap->va_size, 0, cred, p);
		if (error)
			return (error);
d404 2
d415 1
a415 1
		error = VOP_UPDATE(vp, &vap->va_atime, &vap->va_mtime, 1);
d420 3
a422 1
	if (vap->va_mode != (mode_t)VNOVAL)
d424 1
d434 3
a436 3
	register struct vnode *vp;
	register int mode;
	register struct ucred *cred;
d439 1
a439 1
	register struct inode *ip = VTOI(vp);
d465 1
a465 1
	register struct vnode *vp;
d471 1
a471 1
	register struct inode *ip = VTOI(vp);
d476 1
a476 1
	register int i;
d658 3
a660 3
	register struct inode *ip;
	register struct vnode *vp = ap->a_vp;
	register struct vnode *dvp = ap->a_dvp;
d669 2
a670 4
	if ((error = ufs_dirremove(dvp, ap->a_cnp)) == 0) {
		ip->i_ffs_nlink--;
		ip->i_flag |= IN_CHANGE;
	}
d692 6
a697 4
	register struct vnode *dvp = ap->a_dvp;
	register struct vnode *vp = ap->a_vp;
	register struct componentname *cnp = ap->a_cnp;
	register struct inode *ip;
d715 1
a715 1
	if (dvp != vp && (error = VOP_LOCK(vp))) {
d730 1
d733 2
d736 4
a739 3
	error = VOP_UPDATE(vp, &ts, &ts, 1);
	if (!error)
		error = ufs_direnter(ip, dvp, cnp);
d741 1
d748 1
a748 1
		VOP_UNLOCK(vp);
d791 1
a791 1
		error = ufs_direnter2(dvp, &newdir, cnp->cn_cred, cnp->cn_proc);
d802 1
a802 1
		error = ufs_dirremove(dvp, cnp);
d804 3
d853 1
a853 1
	register struct vnode *tdvp = ap->a_tdvp;
d855 6
a860 5
	register struct vnode *fdvp = ap->a_fdvp;
	register struct componentname *tcnp = ap->a_tcnp;
	register struct componentname *fcnp = ap->a_fcnp;
	register struct inode *ip, *xp, *dp;
	struct dirtemplate dirbuf;
a863 1
	u_char namlen;
d920 1
a920 1
	if ((error = VOP_LOCK(fvp)) != 0)
d926 1
a926 1
		VOP_UNLOCK(fvp);
d935 1
a935 1
			VOP_UNLOCK(fvp);
d947 1
a947 1
			VOP_UNLOCK(fvp);
d972 1
d975 2
d978 2
a979 2
	if ((error = VOP_UPDATE(fvp, &ts, &ts, 1)) != 0) {
		VOP_UNLOCK(fvp);
d994 1
a994 1
	VOP_UNLOCK(fvp);
d1033 1
d1036 4
a1039 1
			if ((error = VOP_UPDATE(tdvp, &ts, &ts, 1)) != 0)
d1042 2
a1043 1
		if ((error = ufs_direnter(ip, tdvp, tcnp)) != 0) {
d1045 1
d1079 2
a1080 2
			if (!ufs_dirempty(xp, dp->i_number, tcnp->cn_cred) || 
				xp->i_ffs_nlink > 2) {
d1093 6
a1098 10
		if ((error = ufs_dirrewrite(dp, ip, tcnp)) != 0)
			goto bad;
		/*
		 * If the target directory is in the same
		 * directory as the source directory,
		 * decrement the link count on the parent
		 * of the target directory.
		 */
		 if (doingdirectory && !newparent) {
			dp->i_ffs_nlink--;
d1100 2
d1103 19
a1121 19
		vput(tdvp);
		/*
		 * Adjust the link count of the target to
		 * reflect the dirrewrite above.  If this is
		 * a directory it is empty and there are
		 * no links to it, so we can squash the inode and
		 * any space associated with it.  We disallowed
		 * renaming over top of a directory with links to
		 * it above, as the remaining link would point to
		 * a directory without "." or ".." entries.
		 */
		xp->i_ffs_nlink--;
		if (doingdirectory) {
			if (--xp->i_ffs_nlink != 0)
				panic("rename: linked directory");
			error = VOP_TRUNCATE(tvp, (off_t)0, IO_SYNC,
			    tcnp->cn_cred, tcnp->cn_proc);
		}
		xp->i_flag |= IN_CHANGE;
d1151 3
a1153 4
	 * is a directory then it cannot have been rmdir'ed; its link
	 * count of three would cause a rmdir to fail with ENOTEMPTY.
	 * The IRENAME flag ensures that it cannot be moved by another
	 * rename.
d1166 3
a1168 37
			dp->i_ffs_nlink--;
			dp->i_flag |= IN_CHANGE;
			error = vn_rdwr(UIO_READ, fvp, (caddr_t)&dirbuf,
				sizeof (struct dirtemplate), (off_t)0,
				UIO_SYSSPACE, IO_NODELOCKED, 
				tcnp->cn_cred, (int *)0, (struct proc *)0);
			if (error == 0) {
#				if (BYTE_ORDER == LITTLE_ENDIAN)
					if (fvp->v_mount->mnt_maxsymlinklen <= 0)
						namlen = dirbuf.dotdot_type;
					else
						namlen = dirbuf.dotdot_namlen;
#				else
					namlen = dirbuf.dotdot_namlen;
#				endif
				if (namlen != 2 ||
				    dirbuf.dotdot_name[0] != '.' ||
				    dirbuf.dotdot_name[1] != '.') {
					ufs_dirbad(xp, (doff_t)12,
					    "rename: mangled dir");
				} else {
					dirbuf.dotdot_ino = newparent;
					(void) vn_rdwr(UIO_WRITE, fvp,
					    (caddr_t)&dirbuf,
					    sizeof (struct dirtemplate),
					    (off_t)0, UIO_SYSSPACE,
					    IO_NODELOCKED|IO_SYNC,
					    tcnp->cn_cred, (int *)0,
					    (struct proc *)0);
					cache_purge(fdvp);
				}
			}
		}
		error = ufs_dirremove(fdvp, fcnp);
		if (!error) {
			xp->i_ffs_nlink--;
			xp->i_flag |= IN_CHANGE;
d1170 1
d1187 2
a1188 1
	if (VOP_LOCK(fvp) == 0) {
a1197 12
 * A virgin directory (no blushing please).
 */
static struct dirtemplate mastertemplate = {
	0, 12, DT_DIR, 1, ".",
	0, DIRBLKSIZ - 12, DT_DIR, 2, ".."
};
static struct odirtemplate omastertemplate = {
	0, 12, 1, ".",
	0, DIRBLKSIZ - 12, 2, ".."
};

/*
d1210 4
a1213 4
	register struct vnode *dvp = ap->a_dvp;
	register struct vattr *vap = ap->a_vap;
	register struct componentname *cnp = ap->a_cnp;
	register struct inode *ip, *dp;
d1215 2
d1255 1
d1257 3
a1261 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	error = VOP_UPDATE(tvp, &ts, &ts, 1);
d1264 3
a1266 4
	 * Bump link count in parent directory
	 * to reflect work done below.  Should
	 * be done before reference is created
	 * so reparation is possible if we crash.
d1268 1
d1271 4
a1274 1
	if ((error = VOP_UPDATE(dvp, &ts, &ts, 1)) != 0)
d1277 3
a1279 1
	/* Initialize directory with "." and ".." from static template. */
d1287 10
a1296 6
	error = vn_rdwr(UIO_WRITE, tvp, (caddr_t)&dirtemplate,
	    sizeof (dirtemplate), (off_t)0, UIO_SYSSPACE,
	    IO_NODELOCKED|IO_SYNC, cnp->cn_cred, (int *)0, (struct proc *)0);
	if (error) {
		dp->i_ffs_nlink--;
		dp->i_flag |= IN_CHANGE;
a1298 6
	if (DIRBLKSIZ > VFSTOUFS(dvp->v_mount)->um_mountp->mnt_stat.f_bsize)
		panic("ufs_mkdir: blksize"); /* XXX should grow with balloc() */
	else {
		ip->i_ffs_size = DIRBLKSIZ;
		ip->i_flag |= IN_CHANGE;
	}
d1300 16
a1315 5
	/* Directory set up, now install it's entry in the parent directory. */
	if ((error = ufs_direnter(ip, dvp, cnp)) != 0) {
		dp->i_ffs_nlink--;
		dp->i_flag |= IN_CHANGE;
	}
d1317 14
a1330 7
	/*
	 * No need to do an explicit VOP_TRUNCATE here, vrele will do this
	 * for us because we set the link count to 0.
	 */
	if (error) {
		ip->i_ffs_nlink = 0;
		ip->i_flag |= IN_CHANGE;
d1332 1
a1332 2
	} else
		*ap->a_vpp = tvp;
d1336 1
d1352 4
a1355 4
	register struct vnode *vp = ap->a_vp;
	register struct vnode *dvp = ap->a_dvp;
	register struct componentname *cnp = ap->a_cnp;
	register struct inode *ip, *dp;
d1369 4
a1372 5
	 * Verify the directory is empty (and valid).
	 * (Rmdir ".." won't be valid since
	 *  ".." will contain a reference to
	 *  the current directory and thus be
	 *  non-empty.)
d1375 5
a1379 1
	if (ip->i_ffs_nlink != 2 ||
d1394 1
a1394 1
	if ((error = ufs_dirremove(dvp, cnp)) != 0)
d1396 13
a1408 1
	dp->i_ffs_nlink--;
d1410 9
a1418 18
	cache_purge(dvp);
	vput(dvp);
	dvp = NULL;
	/*
	 * Truncate inode.  The only stuff left
	 * in the directory is "." and "..".  The
	 * "." reference is inconsequential since
	 * we're quashing it.  The ".." reference
	 * has already been adjusted above.  We've
	 * removed the "." reference and the reference
	 * in the parent directory, but there may be
	 * other hard links so decrement by 2 and
	 * worry about them later.
	 */
	ip->i_ffs_nlink -= 2;
	error = VOP_TRUNCATE(vp, (off_t)0, IO_SYNC, cnp->cn_cred,
	    cnp->cn_proc);
	cache_purge(ITOV(ip));
d1420 1
a1420 2
	if (dvp)
		vput(dvp);
d1439 2
a1440 2
	register struct vnode *vp, **vpp = ap->a_vpp;
	register struct inode *ip;
d1480 2
a1481 2
		u_long *a_cookies;
		int ncookies;
d1483 1
a1483 1
	register struct uio *uio = ap->a_uio;
d1539 4
a1542 3
		register struct dirent *dp;
		register u_long *cookies = ap->a_cookies;
		register int ncookies = ap->a_ncookies;
d1551 18
a1568 5
		dp = (struct dirent *)
		     (uio->uio_iov->iov_base - (uio->uio_offset - off));
		while (ncookies-- && off < uio->uio_offset) {
			if (dp->d_reclen == 0)
				break;
d1570 3
a1572 2
			*(cookies++) = off;
			dp = (struct dirent *)((caddr_t)dp + dp->d_reclen);
a1573 2
		lost += uio->uio_offset - off;
		uio->uio_offset = off;
d1592 2
a1593 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d1632 2
d1635 1
a1635 5
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip;
#ifdef DIAGNOSTIC
	struct proc *p = curproc;	/* XXX */
#endif
d1637 2
a1638 34
start:
	while (vp->v_flag & VXLOCK) {
		vp->v_flag |= VXWANT;
		sleep((caddr_t)vp, PINOD);
	}
	if (vp->v_tag == VT_NON)
		return (ENOENT);
	ip = VTOI(vp);
	if (ip->i_flag & IN_LOCKED) {
		ip->i_flag |= IN_WANTED;
#ifdef DIAGNOSTIC
		if (p) {
			if (p->p_pid == ip->i_lockholder)
				panic("locking against myself");
			ip->i_lockwaiter = p->p_pid;
		} else
			ip->i_lockwaiter = -1;
#endif
		(void) sleep((caddr_t)ip, PINOD);
		goto start;
	}
#ifdef DIAGNOSTIC
	ip->i_lockwaiter = 0;
	if (ip->i_lockholder != 0)
		panic("lockholder (%d) != 0", ip->i_lockholder);
	if (p && p->p_pid == 0)
		printf("locking by process 0\n");
	if (p)
		ip->i_lockholder = p->p_pid;
	else
		ip->i_lockholder = -1;
#endif
	ip->i_flag |= IN_LOCKED;
	return (0);
a1643 1
int lockcount = 90;
d1650 2
d1653 1
a1653 4
	register struct inode *ip = VTOI(ap->a_vp);
#ifdef DIAGNOSTIC
	struct proc *p = curproc;	/* XXX */
#endif
d1655 2
a1656 17
#ifdef DIAGNOSTIC
	if ((ip->i_flag & IN_LOCKED) == 0) {
		vprint("ufs_unlock: unlocked inode", ap->a_vp);
		panic("ufs_unlock NOT LOCKED");
	}
	if (p && p->p_pid != ip->i_lockholder && p->p_pid > -1 &&
	    ip->i_lockholder > -1 && lockcount++ < 100)
		panic("unlocker (%d) != lock holder (%d)",
		    p->p_pid, ip->i_lockholder);
	ip->i_lockholder = 0;
#endif
	ip->i_flag &= ~IN_LOCKED;
	if (ip->i_flag & IN_WANTED) {
		ip->i_flag &= ~IN_WANTED;
		wakeup((caddr_t)ip);
	}
	return (0);
d1670 1
a1670 3
	if (VTOI(ap->a_vp)->i_flag & IN_LOCKED)
		return (1);
	return (0);
d1684 3
a1686 3
	register struct buf *bp = ap->a_bp;
	register struct vnode *vp = bp->b_vp;
	register struct inode *ip;
d1724 2
a1725 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d1733 1
a1733 6
	printf("%s\n", (ip->i_flag & IN_LOCKED) ? " (LOCKED)" : "");
	if (ip->i_lockholder == 0)
		return (0);
	printf("\towner pid %d", ip->i_lockholder);
	if (ip->i_lockwaiter)
		printf(" waiting pid %d", ip->i_lockwaiter);
d1795 1
a1795 1
	register struct inode *ip = VTOI(ap->a_vp);
d1797 2
a1798 1
	if (ap->a_vp->v_usecount > 1 && !(ip->i_flag & IN_LOCKED))
d1800 1
d1865 2
a1866 1
	register struct inode *ip = VTOI(ap->a_vp);
d1868 2
a1869 1
	if (ap->a_vp->v_usecount > 1 && !(ip->i_flag & IN_LOCKED))
d1871 1
d1928 1
a1928 1
	register struct inode *ip = VTOI(ap->a_vp);
d1957 2
a1959 2
			ufs_ihashrem(ip);
			VOP_UNLOCK(vp);
a1969 1
			ufs_ihashins(ip);
d2008 2
a2009 1
	register struct inode *ip, *pdir;
d2044 1
d2046 2
d2060 1
a2060 1
	if ((error = VOP_UPDATE(tvp, &ts, &ts, 1)) != 0)
d2062 3
a2064 1
	if ((error = ufs_direnter(ip, dvp, cnp)) != 0)
d2066 1
d2080 1
d2084 1
d2087 2
@


1.12
log
@warning: unused variable "error"
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.11 1997/10/06 15:27:40 csapuntz Exp $	*/
a92 13

/*
 * A virgin directory (no blushing please).
 */
static struct dirtemplate mastertemplate = {
	0, 12, DT_DIR, 1, ".",
	0, DIRBLKSIZ - 12, DT_DIR, 2, ".."
};
static struct odirtemplate omastertemplate = {
	0, 12, 1, ".",
	0, DIRBLKSIZ - 12, 2, ".."
};

d120 8
a127 8
				 struct vnode *a_dvp;
				 struct vnode **a_vpp;
				 struct componentname *a_cnp;
				 struct vattr *a_vap;
				 } */ *ap = v;
	struct vattr *vap = ap->a_vap;
        struct vnode **vpp = ap->a_vpp;
	struct inode *ip;
d131 2
a132 2
	     ufs_makeinode(MAKEIMODE(vap->va_type, vap->va_mode),
			   ap->a_dvp, vpp, ap->a_cnp)) != 0)
d166 5
a170 5
				struct vnode *a_vp;
				int  a_mode;
				struct ucred *a_cred;
				struct proc *a_p;
				} */ *ap = v;
d197 2
a198 2
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
d200 1
a200 2
	simple_lock(&vp->v_interlock);
	if (vp->v_usecount > 1)
a201 1
	simple_unlock(&vp->v_interlock);
d215 2
a216 2
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
d219 8
a226 6
	/*
	 * Disallow write attempts on read-only file systems;
	 * unless the file is a socket, fifo, or a block or
	 * character device resident on the file system.
	 */
	if (mode & VWRITE) {
a227 1
#ifdef QUOTA
a228 1
#endif
a231 3
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
#ifdef QUOTA
a233 1
#endif
a241 1

d243 1
a243 1
	}
d264 3
a266 3
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct vattr *vap = ap->a_vap;
d275 1
a275 1
	vap->va_nlink = ip->i_effnlink;
d314 5
a318 5
	struct vattr *vap = ap->a_vap;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct ucred *cred = ap->a_cred;
	struct proc *p = ap->a_p;
a330 2
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
d340 1
a340 2
			if (ip->i_ffs_flags & (SF_IMMUTABLE | SF_APPEND) ||
			    (vap->va_flags & UF_SETTABLE) != vap->va_flags)
a354 2
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
d360 5
a364 18
		/*
		 * Disallow write attempts on read-only file systems;
		 * unless the file is a socket, fifo, or a block or
		 * character device resident on the file system.
		 */
		switch (vp->v_type) {
		case VDIR:
 			return (EISDIR);
		case VLNK:
		case VREG:
			if (vp->v_mount->mnt_flag & MNT_RDONLY)
				return (EROFS);
			break;
		default:
			break;
		}
 		if ((error = VOP_TRUNCATE(vp, vap->va_size, 0, cred, p)) != 0)
 			return (error);
a367 2
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
d377 1
a377 1
		error = VOP_UPDATE(vp, &vap->va_atime, &vap->va_mtime, 0);
d382 1
a382 3
	if (vap->va_mode != (mode_t)VNOVAL) {
		if (vp->v_mount->mnt_flag & MNT_RDONLY)
			return (EROFS);
a383 1
	}
d393 3
a395 3
	struct vnode *vp;
	int mode;
	struct ucred *cred;
d398 1
a398 1
	struct inode *ip = VTOI(vp);
d424 1
a424 1
	struct vnode *vp;
d430 1
a430 1
	struct inode *ip = VTOI(vp);
d435 1
a435 1
	int i;
d617 3
a619 3
	struct inode *ip;
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
d628 4
a631 2
	if ((error = ufs_dirremove(dvp, ip, ap->a_cnp->cn_flags, 0)) != 0)
		goto out;
d653 4
a656 6
	struct vnode *dvp = ap->a_dvp;
	struct vnode *vp = ap->a_vp;
	struct componentname *cnp = ap->a_cnp;
	struct proc *p = cnp->cn_proc;
	struct inode *ip;
	struct direct newdir;
d674 1
a674 1
	if (dvp != vp && (error = vn_lock(vp, LK_EXCLUSIVE, p))) {
a688 1
	ip->i_effnlink++;
a690 2
	if (DOINGSOFTDEP(vp))
		softdep_increase_linkcnt(ip);
d692 3
a694 4
	if ((error = VOP_UPDATE(vp, &ts, &ts, !DOINGSOFTDEP(vp))) == 0) {
		ufs_makedirentry(ip, cnp, &newdir);
		error = ufs_direnter(dvp, &newdir, cnp, NULL);
	}
a695 1
		ip->i_effnlink--;
d702 1
a702 1
		VOP_UNLOCK(vp, 0, p);
d745 1
a745 1
		error = ufs_direnter(dvp, &newdir, cnp, NULL);
d756 1
a756 1
		error = ufs_dirremove(dvp, NULL, cnp->cn_flags, 0);
a757 3
	default:
		panic("ufs_whiteout: unknown op");
		/* NOTREACHED */
d804 1
a804 1
	struct vnode *tdvp = ap->a_tdvp;
d806 5
a810 6
	struct vnode *fdvp = ap->a_fdvp;
	struct componentname *tcnp = ap->a_tcnp;
	struct componentname *fcnp = ap->a_fcnp;
	struct proc *p = fcnp->cn_proc;
	struct inode *ip, *xp, *dp;
	struct direct newdir;
d814 1
d871 1
a871 1
	if ((error = vn_lock(fvp, LK_EXCLUSIVE, p)) != 0)
d877 1
a877 1
		VOP_UNLOCK(fvp, 0, p);
d886 1
a886 1
			VOP_UNLOCK(fvp, 0, p);
d898 1
a898 1
			VOP_UNLOCK(fvp, 0, p);
a922 1
	ip->i_effnlink++;
a924 2
	if (DOINGSOFTDEP(fvp))
		softdep_increase_linkcnt(ip);
d926 2
a927 2
	if ((error = VOP_UPDATE(fvp, &ts, &ts, !DOINGSOFTDEP(fvp))) != 0) {
		VOP_UNLOCK(fvp, 0, p);
d942 1
a942 1
	VOP_UNLOCK(fvp, 0, p);
a980 1
			dp->i_effnlink++;
d983 1
a983 4
			if (DOINGSOFTDEP(tdvp))
                               softdep_increase_linkcnt(dp);
			if ((error = VOP_UPDATE(tdvp, &ts, &ts,
						!DOINGSOFTDEP(tdvp))) != 0)
d986 1
a986 2
		ufs_makedirentry(ip, tcnp, &newdir);
		if ((error = ufs_direnter(tdvp, &newdir, tcnp, NULL)) != 0) {
a987 1
				dp->i_effnlink--;
d1021 2
a1022 2
			if (xp->i_effnlink > 2 ||
			    !ufs_dirempty(xp, dp->i_number, tcnp->cn_cred)) {
d1035 24
a1058 4
		
		if ((error = ufs_dirrewrite(dp, xp, ip->i_number,
                   IFTODT(ip->i_ffs_mode), doingdirectory)) != 0)
                        goto bad;
d1060 4
a1063 4
			dp->i_effnlink--;
			dp->i_flag |= IN_CHANGE;
			xp->i_effnlink--;
			xp->i_flag |= IN_CHANGE;
d1065 1
a1065 19
		if (doingdirectory && !DOINGSOFTDEP(tvp)) {
		       /*
			* Truncate inode. The only stuff left in the directory
			* is "." and "..". The "." reference is inconsequential
                        * since we are quashing it. We have removed the "."
                        * reference and the reference in the parent directory,
                        * but there may be other hard links. The soft
                        * dependency code will arrange to do these operations
                        * after the parent directory entry has been deleted on
                        * disk, so when running with that code we avoid doing
                        * them now.
                        */
			dp->i_ffs_nlink--;
			xp->i_ffs_nlink--;
			if ((error = VOP_TRUNCATE(tvp, (off_t)0, IO_SYNC,
			        tcnp->cn_cred, tcnp->cn_proc)) != 0)
				goto bad;
                }
	        vput(tdvp);
d1095 4
a1098 3
	 * is a directory then it cannot have been rmdir'ed; the IN_RENAME 
	 * flag ensures that it cannot be moved by another rename or removed
	 * by a rmdir.
d1111 37
a1147 3
			xp->i_offset = mastertemplate.dot_reclen;
			ufs_dirrewrite(xp, dp, newparent, DT_DIR, 0);
			cache_purge(fdvp);
a1148 1
		error = ufs_dirremove(fdvp, xp, fcnp->cn_flags, 0);
d1165 1
a1165 2
	if (vn_lock(fvp, LK_EXCLUSIVE, p) == 0) {
		ip->i_effnlink--;
d1175 12
d1199 4
a1202 4
	struct vnode *dvp = ap->a_dvp;
	struct vattr *vap = ap->a_vap;
	struct componentname *cnp = ap->a_cnp;
	struct inode *ip, *dp;
a1203 2
	struct buf *bp;
	struct direct newdir;
a1241 1
	ip->i_effnlink = 2;
a1242 3
	if (DOINGSOFTDEP(tvp))
		softdep_increase_linkcnt(ip);

d1245 2
d1249 4
a1252 3
	 * Bump link count in parent directory to reflect work done below.
	 * Should be done before reference is create so cleanup is 
	 * possible if we crash.
a1253 1
	dp->i_effnlink++;
d1256 1
a1256 4
	if (DOINGSOFTDEP(dvp))
		softdep_increase_linkcnt(dp);
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	if ((error = VOP_UPDATE(dvp, &ts, &ts, !DOINGSOFTDEP(dvp))) != 0)
d1259 1
a1259 3
	/* 
	 * Initialize directory with "." and ".." from static template.
	 */
d1267 6
a1272 10

	if ((error = VOP_BALLOC(tvp, (off_t)0, DIRBLKSIZ, cnp->cn_cred,
            B_CLRBUF, &bp)) != 0)
		goto bad;
	ip->i_ffs_size = DIRBLKSIZ;
	ip->i_flag |= IN_CHANGE | IN_UPDATE;
	vnode_pager_setsize(tvp, (u_long)ip->i_ffs_size);
	bcopy((caddr_t)&dirtemplate, (caddr_t)bp->b_data, sizeof dirtemplate);
	if ((error = VOP_UPDATE(tvp, &ts, &ts, !DOINGSOFTDEP(tvp))) != 0) {
		(void)VOP_BWRITE(bp);
d1274 6
d1282 6
d1289 6
a1294 30
         * Directory set up, now install it's entry in the parent directory.
         *
         * If we are not doing soft dependencies, then we must write out the
         * buffer containing the new directory body before entering the new
         * name in the parent. If we are doing soft dependencies, then the
         * buffer containing the new directory body will be passed to and
         * released in the soft dependency code after the code has attached
         * an appropriate ordering dependency to the buffer which ensures that
         * the buffer is written before the new name is written in the parent.
	 */
        if (!DOINGSOFTDEP(dvp) && ((error = VOP_BWRITE(bp)) != 0))
                goto bad;
        ufs_makedirentry(ip, cnp, &newdir);
        error = ufs_direnter(dvp, &newdir, cnp, bp);
  
bad:
        if (error == 0) {
                *ap->a_vpp = tvp;
        } else {
                dp->i_effnlink--;
                dp->i_ffs_nlink--;
                dp->i_flag |= IN_CHANGE;
                /*
                 * No need to do an explicit VOP_TRUNCATE here, vrele will
                 * do this for us because we set the link count to 0.
                 */
                ip->i_effnlink = 0;
                ip->i_ffs_nlink = 0;
                ip->i_flag |= IN_CHANGE;

d1296 2
a1297 1
	}
a1300 1

d1316 4
a1319 4
	struct vnode *vp = ap->a_vp;
	struct vnode *dvp = ap->a_dvp;
	struct componentname *cnp = ap->a_cnp;
	struct inode *ip, *dp;
d1333 5
a1337 4
         * Do not remove a directory that is in the process of being renamed.
         * Verify the directory is empty (and valid). Rmdir ".." will not be
         * valid since ".." will contain a reference to the current directory
         * and thus be non-empty.
d1340 1
a1340 5
	if (ip->i_flag & IN_RENAME) {
		error = EINVAL;
		goto out;
	}
	if (ip->i_effnlink != 2 ||
d1355 1
a1355 1
	if ((error = ufs_dirremove(dvp, ip, cnp->cn_flags, 1)) != 0)
d1357 2
d1360 17
a1376 22
        /*
	 * Truncate inode. The only stuff left in the directory is "." and
	 * "..". The "." reference is inconsequential since we are quashing
	 * it. We have removed the "." reference and the reference in the
	 * parent directory, but there may be other hard links. So,
	 * ufs_dirremove will set the UF_IMMUTABLE flag to ensure that no
	 * new entries are made. The soft dependency code will arrange to
	 * do these operations after the parent directory entry has been
	 * deleted on disk, so when running with that code we avoid doing
	 * them now.
	 */
	dp->i_effnlink--;
	dp->i_flag |= IN_CHANGE;
	ip->i_effnlink--;
	ip->i_flag |= IN_CHANGE;
	if (!DOINGSOFTDEP(vp)) {
		dp->i_ffs_nlink--;
		ip->i_ffs_nlink--;
		error = VOP_TRUNCATE(vp, (off_t)0, IO_SYNC, cnp->cn_cred,
		   cnp->cn_proc);
	}
	cache_purge(vp);
d1378 2
a1379 1
        vput(dvp);
d1398 2
a1399 2
	struct vnode *vp, **vpp = ap->a_vpp;
	struct inode *ip;
d1439 2
a1440 2
		u_long **a_cookies;
		int *ncookies;
d1442 1
a1442 1
	struct uio *uio = ap->a_uio;
d1498 3
a1500 4
		struct dirent *dp, *dpstart;
		off_t offstart;
		u_long *cookies;
		int ncookies;
d1509 5
a1513 19

		dpstart = (struct dirent *)
			(uio->uio_iov->iov_base - (uio->uio_offset - off));
                offstart = off;
                for (dp = dpstart, ncookies = 0; off < uio->uio_offset; ) {
                        if (dp->d_reclen == 0)
                                break;
                        off += dp->d_reclen;
                        ncookies++;
                        dp = (struct dirent *)((caddr_t)dp + dp->d_reclen);
                }
                lost += uio->uio_offset - off;
                uio->uio_offset = off;
                MALLOC(cookies, u_long *, ncookies * sizeof(u_long), M_TEMP,
                    M_WAITOK);
                *ap->a_ncookies = ncookies;
                *ap->a_cookies = cookies;
                for (off = offstart, dp = dpstart; off < uio->uio_offset; ) {
                        *(cookies++) = off;
d1515 2
a1516 1
                        dp = (struct dirent *)((caddr_t)dp + dp->d_reclen);
d1518 2
d1538 2
a1539 2
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
a1577 2
		int a_flags;
		sturct proc *a_p;
d1579 5
a1583 1
	struct vnode *vp = ap->a_vp;
d1585 34
a1618 2
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags, &vp->v_interlock,
		ap->a_p));
d1624 1
a1630 2
		int a_flags;
		struct proc *a_p;
d1632 4
a1635 1
	struct vnode *vp = ap->a_vp;
d1637 17
a1653 2
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags | LK_RELEASE,
		&vp->v_interlock, ap->a_p));
d1667 3
a1669 1
	return (lockstatus(&VTOI(ap->a_vp)->i_lock));
d1683 3
a1685 3
	struct buf *bp = ap->a_bp;
	struct vnode *vp = bp->b_vp;
	struct inode *ip;
d1723 2
a1724 2
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
d1732 6
a1737 1
	lockmgr_printinfo(&ip->i_lock);
d1799 1
a1799 1
	struct inode *ip = VTOI(ap->a_vp);
d1801 1
a1801 2
	simple_lock(&vp->v_interlock);
	if (ap->a_vp->v_usecount > 1)
a1802 1
	simple_unlock(&vp->v_interlock);
d1867 1
a1867 2
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
d1869 1
a1869 2
	simple_lock(&vp->v_interlock);
	if (ap->a_vp->v_usecount > 1)
a1870 1
	simple_unlock(&vp->v_interlock);
d1927 1
a1927 1
	struct inode *ip = VTOI(ap->a_vp);
a1955 2
			 * Note that the lock is carried over in the inode
			 * to the replacement vnode.
d1957 2
d1969 1
d2008 1
a2008 2
	struct inode *ip, *pdir;
	struct direct newdir;
a2042 1
	ip->i_effnlink = 1;
a2043 2
	if (DOINGSOFTDEP(tvp))
		softdep_increase_linkcnt(ip);
d2056 1
a2056 1
	if ((error = VOP_UPDATE(tvp, &ts, &ts, !DOINGSOFTDEP(tvp))) != 0)
d2058 1
a2058 3

	ufs_makedirentry(ip, cnp, &newdir);
	if ((error = ufs_direnter(dvp, &newdir, cnp, NULL)) != 0)
a2059 1

a2072 1
	ip->i_effnlink = 0;
a2075 1

a2077 2


@


1.11
log
@VFS Lite2 Changes
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.10 1997/07/03 17:49:49 deraadt Exp $	*/
d241 1
d243 1
@


1.10
log
@rm of dir returns EPERM; more careful about ..; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.9 1997/05/30 08:35:18 downsj Exp $	*/
d93 13
d133 8
a140 8
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
	} */ *ap = v;
	register struct vattr *vap = ap->a_vap;
	register struct vnode **vpp = ap->a_vpp;
	register struct inode *ip;
d144 2
a145 2
	    ufs_makeinode(MAKEIMODE(vap->va_type, vap->va_mode),
	    ap->a_dvp, vpp, ap->a_cnp)) != 0)
d179 5
a183 5
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d210 2
a211 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d213 2
a214 1
	if (vp->v_usecount > 1 && !(ip->i_flag & IN_LOCKED))
d216 1
d230 2
a231 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d234 6
a239 8
#ifdef DIAGNOSTIC
	if (!VOP_ISLOCKED(vp)) {
		vprint("ufs_access: not locked", vp);
		panic("ufs_access: not locked");
	}
#endif
#ifdef QUOTA
	if (mode & VWRITE)
d245 3
d250 1
d259 1
d261 1
a261 1
#endif
d282 3
a284 3
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
	register struct vattr *vap = ap->a_vap;
d293 1
a293 1
	vap->va_nlink = ip->i_ffs_nlink;
d332 5
a336 5
	register struct vattr *vap = ap->a_vap;
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
	register struct ucred *cred = ap->a_cred;
	register struct proc *p = ap->a_p;
d349 2
d360 2
a361 1
			if (ip->i_ffs_flags & (SF_IMMUTABLE | SF_APPEND))
d376 2
d383 18
a400 5
		if (vp->v_type == VDIR)
			return (EISDIR);
		error = VOP_TRUNCATE(vp, vap->va_size, 0, cred, p);
		if (error)
			return (error);
d404 2
d415 1
a415 1
		error = VOP_UPDATE(vp, &vap->va_atime, &vap->va_mtime, 1);
d420 3
a422 1
	if (vap->va_mode != (mode_t)VNOVAL)
d424 1
d434 3
a436 3
	register struct vnode *vp;
	register int mode;
	register struct ucred *cred;
d439 1
a439 1
	register struct inode *ip = VTOI(vp);
d465 1
a465 1
	register struct vnode *vp;
d471 1
a471 1
	register struct inode *ip = VTOI(vp);
d476 1
a476 1
	register int i;
d658 3
a660 3
	register struct inode *ip;
	register struct vnode *vp = ap->a_vp;
	register struct vnode *dvp = ap->a_dvp;
d669 2
a670 4
	if ((error = ufs_dirremove(dvp, ap->a_cnp)) == 0) {
		ip->i_ffs_nlink--;
		ip->i_flag |= IN_CHANGE;
	}
d692 6
a697 4
	register struct vnode *dvp = ap->a_dvp;
	register struct vnode *vp = ap->a_vp;
	register struct componentname *cnp = ap->a_cnp;
	register struct inode *ip;
d715 1
a715 1
	if (dvp != vp && (error = VOP_LOCK(vp))) {
d730 1
d733 2
d736 4
a739 3
	error = VOP_UPDATE(vp, &ts, &ts, 1);
	if (!error)
		error = ufs_direnter(ip, dvp, cnp);
d741 1
d748 1
a748 1
		VOP_UNLOCK(vp);
d791 1
a791 1
		error = ufs_direnter2(dvp, &newdir, cnp->cn_cred, cnp->cn_proc);
d802 1
a802 1
		error = ufs_dirremove(dvp, cnp);
d804 3
d853 1
a853 1
	register struct vnode *tdvp = ap->a_tdvp;
d855 6
a860 5
	register struct vnode *fdvp = ap->a_fdvp;
	register struct componentname *tcnp = ap->a_tcnp;
	register struct componentname *fcnp = ap->a_fcnp;
	register struct inode *ip, *xp, *dp;
	struct dirtemplate dirbuf;
a863 1
	u_char namlen;
d920 1
a920 1
	if ((error = VOP_LOCK(fvp)) != 0)
d926 1
a926 1
		VOP_UNLOCK(fvp);
d935 1
a935 1
			VOP_UNLOCK(fvp);
d947 1
a947 1
			VOP_UNLOCK(fvp);
d972 1
d975 2
d978 2
a979 2
	if ((error = VOP_UPDATE(fvp, &ts, &ts, 1)) != 0) {
		VOP_UNLOCK(fvp);
d994 1
a994 1
	VOP_UNLOCK(fvp);
d1033 1
d1036 4
a1039 1
			if ((error = VOP_UPDATE(tdvp, &ts, &ts, 1)) != 0)
d1042 2
a1043 1
		if ((error = ufs_direnter(ip, tdvp, tcnp)) != 0) {
d1045 1
d1079 2
a1080 2
			if (!ufs_dirempty(xp, dp->i_number, tcnp->cn_cred) || 
				xp->i_ffs_nlink > 2) {
d1093 6
a1098 10
		if ((error = ufs_dirrewrite(dp, ip, tcnp)) != 0)
			goto bad;
		/*
		 * If the target directory is in the same
		 * directory as the source directory,
		 * decrement the link count on the parent
		 * of the target directory.
		 */
		 if (doingdirectory && !newparent) {
			dp->i_ffs_nlink--;
d1100 2
d1103 19
a1121 19
		vput(tdvp);
		/*
		 * Adjust the link count of the target to
		 * reflect the dirrewrite above.  If this is
		 * a directory it is empty and there are
		 * no links to it, so we can squash the inode and
		 * any space associated with it.  We disallowed
		 * renaming over top of a directory with links to
		 * it above, as the remaining link would point to
		 * a directory without "." or ".." entries.
		 */
		xp->i_ffs_nlink--;
		if (doingdirectory) {
			if (--xp->i_ffs_nlink != 0)
				panic("rename: linked directory");
			error = VOP_TRUNCATE(tvp, (off_t)0, IO_SYNC,
			    tcnp->cn_cred, tcnp->cn_proc);
		}
		xp->i_flag |= IN_CHANGE;
d1151 3
a1153 4
	 * is a directory then it cannot have been rmdir'ed; its link
	 * count of three would cause a rmdir to fail with ENOTEMPTY.
	 * The IRENAME flag ensures that it cannot be moved by another
	 * rename.
d1166 3
a1168 37
			dp->i_ffs_nlink--;
			dp->i_flag |= IN_CHANGE;
			error = vn_rdwr(UIO_READ, fvp, (caddr_t)&dirbuf,
				sizeof (struct dirtemplate), (off_t)0,
				UIO_SYSSPACE, IO_NODELOCKED, 
				tcnp->cn_cred, (int *)0, (struct proc *)0);
			if (error == 0) {
#				if (BYTE_ORDER == LITTLE_ENDIAN)
					if (fvp->v_mount->mnt_maxsymlinklen <= 0)
						namlen = dirbuf.dotdot_type;
					else
						namlen = dirbuf.dotdot_namlen;
#				else
					namlen = dirbuf.dotdot_namlen;
#				endif
				if (namlen != 2 ||
				    dirbuf.dotdot_name[0] != '.' ||
				    dirbuf.dotdot_name[1] != '.') {
					ufs_dirbad(xp, (doff_t)12,
					    "rename: mangled dir");
				} else {
					dirbuf.dotdot_ino = newparent;
					(void) vn_rdwr(UIO_WRITE, fvp,
					    (caddr_t)&dirbuf,
					    sizeof (struct dirtemplate),
					    (off_t)0, UIO_SYSSPACE,
					    IO_NODELOCKED|IO_SYNC,
					    tcnp->cn_cred, (int *)0,
					    (struct proc *)0);
					cache_purge(fdvp);
				}
			}
		}
		error = ufs_dirremove(fdvp, fcnp);
		if (!error) {
			xp->i_ffs_nlink--;
			xp->i_flag |= IN_CHANGE;
d1170 1
d1187 2
a1188 1
	if (VOP_LOCK(fvp) == 0) {
a1197 12
 * A virgin directory (no blushing please).
 */
static struct dirtemplate mastertemplate = {
	0, 12, DT_DIR, 1, ".",
	0, DIRBLKSIZ - 12, DT_DIR, 2, ".."
};
static struct odirtemplate omastertemplate = {
	0, 12, 1, ".",
	0, DIRBLKSIZ - 12, 2, ".."
};

/*
d1210 4
a1213 4
	register struct vnode *dvp = ap->a_dvp;
	register struct vattr *vap = ap->a_vap;
	register struct componentname *cnp = ap->a_cnp;
	register struct inode *ip, *dp;
d1215 2
d1255 1
d1257 3
a1261 2
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	error = VOP_UPDATE(tvp, &ts, &ts, 1);
d1264 3
a1266 4
	 * Bump link count in parent directory
	 * to reflect work done below.  Should
	 * be done before reference is created
	 * so reparation is possible if we crash.
d1268 1
d1271 4
a1274 1
	if ((error = VOP_UPDATE(dvp, &ts, &ts, 1)) != 0)
d1277 3
a1279 1
	/* Initialize directory with "." and ".." from static template. */
d1287 10
a1296 6
	error = vn_rdwr(UIO_WRITE, tvp, (caddr_t)&dirtemplate,
	    sizeof (dirtemplate), (off_t)0, UIO_SYSSPACE,
	    IO_NODELOCKED|IO_SYNC, cnp->cn_cred, (int *)0, (struct proc *)0);
	if (error) {
		dp->i_ffs_nlink--;
		dp->i_flag |= IN_CHANGE;
a1298 6
	if (DIRBLKSIZ > VFSTOUFS(dvp->v_mount)->um_mountp->mnt_stat.f_bsize)
		panic("ufs_mkdir: blksize"); /* XXX should grow with balloc() */
	else {
		ip->i_ffs_size = DIRBLKSIZ;
		ip->i_flag |= IN_CHANGE;
	}
d1300 16
a1315 5
	/* Directory set up, now install it's entry in the parent directory. */
	if ((error = ufs_direnter(ip, dvp, cnp)) != 0) {
		dp->i_ffs_nlink--;
		dp->i_flag |= IN_CHANGE;
	}
d1317 14
a1330 7
	/*
	 * No need to do an explicit VOP_TRUNCATE here, vrele will do this
	 * for us because we set the link count to 0.
	 */
	if (error) {
		ip->i_ffs_nlink = 0;
		ip->i_flag |= IN_CHANGE;
d1332 1
a1332 2
	} else
		*ap->a_vpp = tvp;
d1336 1
d1352 4
a1355 4
	register struct vnode *vp = ap->a_vp;
	register struct vnode *dvp = ap->a_dvp;
	register struct componentname *cnp = ap->a_cnp;
	register struct inode *ip, *dp;
d1369 4
a1372 5
	 * Verify the directory is empty (and valid).
	 * (Rmdir ".." won't be valid since
	 *  ".." will contain a reference to
	 *  the current directory and thus be
	 *  non-empty.)
d1375 5
a1379 1
	if (ip->i_ffs_nlink != 2 ||
d1394 1
a1394 1
	if ((error = ufs_dirremove(dvp, cnp)) != 0)
d1396 13
a1408 1
	dp->i_ffs_nlink--;
d1410 9
a1418 18
	cache_purge(dvp);
	vput(dvp);
	dvp = NULL;
	/*
	 * Truncate inode.  The only stuff left
	 * in the directory is "." and "..".  The
	 * "." reference is inconsequential since
	 * we're quashing it.  The ".." reference
	 * has already been adjusted above.  We've
	 * removed the "." reference and the reference
	 * in the parent directory, but there may be
	 * other hard links so decrement by 2 and
	 * worry about them later.
	 */
	ip->i_ffs_nlink -= 2;
	error = VOP_TRUNCATE(vp, (off_t)0, IO_SYNC, cnp->cn_cred,
	    cnp->cn_proc);
	cache_purge(ITOV(ip));
d1420 1
a1420 2
	if (dvp)
		vput(dvp);
d1439 2
a1440 2
	register struct vnode *vp, **vpp = ap->a_vpp;
	register struct inode *ip;
d1480 2
a1481 2
		u_long *a_cookies;
		int ncookies;
d1483 1
a1483 1
	register struct uio *uio = ap->a_uio;
d1539 4
a1542 3
		register struct dirent *dp;
		register u_long *cookies = ap->a_cookies;
		register int ncookies = ap->a_ncookies;
d1551 19
a1569 5
		dp = (struct dirent *)
		     (uio->uio_iov->iov_base - (uio->uio_offset - off));
		while (ncookies-- && off < uio->uio_offset) {
			if (dp->d_reclen == 0)
				break;
d1571 1
a1571 2
			*(cookies++) = off;
			dp = (struct dirent *)((caddr_t)dp + dp->d_reclen);
a1572 2
		lost += uio->uio_offset - off;
		uio->uio_offset = off;
d1591 2
a1592 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d1631 2
d1634 1
a1634 5
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip;
#ifdef DIAGNOSTIC
	struct proc *p = curproc;	/* XXX */
#endif
d1636 2
a1637 34
start:
	while (vp->v_flag & VXLOCK) {
		vp->v_flag |= VXWANT;
		sleep((caddr_t)vp, PINOD);
	}
	if (vp->v_tag == VT_NON)
		return (ENOENT);
	ip = VTOI(vp);
	if (ip->i_flag & IN_LOCKED) {
		ip->i_flag |= IN_WANTED;
#ifdef DIAGNOSTIC
		if (p) {
			if (p->p_pid == ip->i_lockholder)
				panic("locking against myself");
			ip->i_lockwaiter = p->p_pid;
		} else
			ip->i_lockwaiter = -1;
#endif
		(void) sleep((caddr_t)ip, PINOD);
		goto start;
	}
#ifdef DIAGNOSTIC
	ip->i_lockwaiter = 0;
	if (ip->i_lockholder != 0)
		panic("lockholder (%d) != 0", ip->i_lockholder);
	if (p && p->p_pid == 0)
		printf("locking by process 0\n");
	if (p)
		ip->i_lockholder = p->p_pid;
	else
		ip->i_lockholder = -1;
#endif
	ip->i_flag |= IN_LOCKED;
	return (0);
a1642 1
int lockcount = 90;
d1649 2
d1652 1
a1652 4
	register struct inode *ip = VTOI(ap->a_vp);
#ifdef DIAGNOSTIC
	struct proc *p = curproc;	/* XXX */
#endif
d1654 2
a1655 17
#ifdef DIAGNOSTIC
	if ((ip->i_flag & IN_LOCKED) == 0) {
		vprint("ufs_unlock: unlocked inode", ap->a_vp);
		panic("ufs_unlock NOT LOCKED");
	}
	if (p && p->p_pid != ip->i_lockholder && p->p_pid > -1 &&
	    ip->i_lockholder > -1 && lockcount++ < 100)
		panic("unlocker (%d) != lock holder (%d)",
		    p->p_pid, ip->i_lockholder);
	ip->i_lockholder = 0;
#endif
	ip->i_flag &= ~IN_LOCKED;
	if (ip->i_flag & IN_WANTED) {
		ip->i_flag &= ~IN_WANTED;
		wakeup((caddr_t)ip);
	}
	return (0);
d1669 1
a1669 3
	if (VTOI(ap->a_vp)->i_flag & IN_LOCKED)
		return (1);
	return (0);
d1683 3
a1685 3
	register struct buf *bp = ap->a_bp;
	register struct vnode *vp = bp->b_vp;
	register struct inode *ip;
d1723 2
a1724 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d1732 1
a1732 6
	printf("%s\n", (ip->i_flag & IN_LOCKED) ? " (LOCKED)" : "");
	if (ip->i_lockholder == 0)
		return (0);
	printf("\towner pid %d", ip->i_lockholder);
	if (ip->i_lockwaiter)
		printf(" waiting pid %d", ip->i_lockwaiter);
d1794 1
a1794 1
	register struct inode *ip = VTOI(ap->a_vp);
d1796 2
a1797 1
	if (ap->a_vp->v_usecount > 1 && !(ip->i_flag & IN_LOCKED))
d1799 1
d1864 2
a1865 1
	register struct inode *ip = VTOI(ap->a_vp);
d1867 2
a1868 1
	if (ap->a_vp->v_usecount > 1 && !(ip->i_flag & IN_LOCKED))
d1870 1
d1927 1
a1927 1
	register struct inode *ip = VTOI(ap->a_vp);
d1956 2
a1958 2
			ufs_ihashrem(ip);
			VOP_UNLOCK(vp);
a1968 1
			ufs_ihashins(ip);
d2007 2
a2008 1
	register struct inode *ip, *pdir;
d2043 1
d2045 2
d2059 1
a2059 1
	if ((error = VOP_UPDATE(tvp, &ts, &ts, 1)) != 0)
d2061 3
a2063 1
	if ((error = ufs_direnter(ip, dvp, cnp)) != 0)
d2065 1
d2079 1
d2083 1
d2086 2
@


1.9
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.8 1996/11/12 15:39:04 mickey Exp $	*/
a621 4
	if (vp->v_type == VDIR) {
		error = EISDIR;
		goto out;
	}
d623 1
a623 1
	if ((ip->i_ffs_flags & (IMMUTABLE | APPEND)) ||
d894 3
a896 1
		    dp == ip || (fcnp->cn_flags&ISDOTDOT) ||
@


1.8
log
@comment typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.7 1996/10/27 22:30:35 tholo Exp $	*/
d70 1
a75 6
#ifdef EXT2FS
#include <gnu/ext2fs/ext2_extern.h>
#include <gnu/ext2fs/ext2_fs.h>
#include <gnu/ext2fs/ext2_fs_sb.h>
#endif /* EXT2FS */

d141 1
a141 1
		ip->i_rdev = vap->va_rdev;
d175 1
a175 1
	if ((VTOI(ap->a_vp)->i_flags & APPEND) &&
d246 1
a246 1
	if ((mode & VWRITE) && (ip->i_flags & IMMUTABLE))
d249 2
a250 1
	return (vaccess(ip->i_mode, ip->i_uid, ip->i_gid, mode, ap->a_cred));
d274 14
a287 14
	vap->va_mode = ip->i_mode & ~IFMT;
	vap->va_nlink = ip->i_nlink;
	vap->va_uid = ip->i_uid;
	vap->va_gid = ip->i_gid;
	vap->va_rdev = (dev_t)ip->i_rdev;
	vap->va_size = ip->i_din.di_size;
	vap->va_atime.tv_sec = ip->i_atime;
	vap->va_atime.tv_nsec = ip->i_atimensec;
	vap->va_mtime.tv_sec = ip->i_mtime;
	vap->va_mtime.tv_nsec = ip->i_mtimensec;
	vap->va_ctime.tv_sec = ip->i_ctime;
	vap->va_ctime.tv_nsec = ip->i_ctimensec;
	vap->va_flags = ip->i_flags;
	vap->va_gen = ip->i_gen;
d295 1
a295 1
	vap->va_bytes = dbtob(ip->i_blocks);
d331 1
a331 1
		if (cred->cr_uid != ip->i_uid &&
d335 1
a335 1
			if ((ip->i_flags & (SF_IMMUTABLE | SF_APPEND)) &&
d338 1
a338 1
			ip->i_flags = vap->va_flags;
d340 1
a340 1
			if (ip->i_flags & (SF_IMMUTABLE | SF_APPEND))
d342 2
a343 2
			ip->i_flags &= SF_SETTABLE;
			ip->i_flags |= (vap->va_flags & UF_SETTABLE);
d349 1
a349 1
	if (ip->i_flags & (IMMUTABLE | APPEND))
d368 1
a368 1
		if (cred->cr_uid != ip->i_uid &&
d401 1
a401 1
	if (cred->cr_uid != ip->i_uid &&
d407 1
a407 1
		if (!groupmember(ip->i_gid, cred) && (mode & ISGID))
d410 2
a411 2
	ip->i_mode &= ~ALLPERMS;
	ip->i_mode |= (mode & ALLPERMS);
d413 1
a413 1
	if ((vp->v_flag & VTEXT) && (ip->i_mode & S_ISTXT) == 0)
d440 1
a440 1
		uid = ip->i_uid;
d442 1
a442 1
		gid = ip->i_gid;
d448 2
a449 2
	if ((cred->cr_uid != ip->i_uid || uid != ip->i_uid ||
	    (gid != ip->i_gid && !groupmember((gid_t)gid, cred))) &&
d452 2
a453 2
	ogid = ip->i_gid;
	ouid = ip->i_uid;
d465 1
a465 1
	change = ip->i_blocks;
d473 2
a474 2
	ip->i_gid = gid;
	ip->i_uid = uid;
d496 2
a497 2
	ip->i_gid = ogid;
	ip->i_uid = ouid;
d519 1
a519 1
		ip->i_mode &= ~ISUID;
d521 1
a521 1
		ip->i_mode &= ~ISGID;
d627 2
a628 2
	if ((ip->i_flags & (IMMUTABLE | APPEND)) ||
	    (VTOI(dvp)->i_flags & APPEND)) {
d632 2
a633 3
	error = VN_DIRREMOVE(dvp, ap->a_cnp);
	if (error == 0) {
		ip->i_nlink--;
d683 1
a683 1
	if ((nlink_t)ip->i_nlink >= LINK_MAX) {
d688 1
a688 1
	if (ip->i_flags & (IMMUTABLE | APPEND)) {
d693 1
a693 1
	ip->i_nlink++;
d698 1
a698 2
		error = VN_DIRENTER(ip, dvp, cnp);

d700 1
a700 1
		ip->i_nlink--;
d749 1
a749 1
		error = ufs_direnter2(dvp, &newdir, cnp->cn_cred, cnp->cn_proc); /* FIXME */
d760 1
a760 1
		error = VN_DIRREMOVE(dvp, cnp);
d848 2
a849 2
	if (tvp && ((VTOI(tvp)->i_flags & (IMMUTABLE | APPEND)) ||
	    (VTOI(tdvp)->i_flags & APPEND))) {
d879 2
a880 1
	if ((ip->i_flags & (IMMUTABLE | APPEND)) || (dp->i_flags & APPEND)) {
d885 1
a885 1
	if ((ip->i_mode & IFMT) == IFDIR) {
d925 1
a925 1
	ip->i_nlink++;
d952 1
a952 2
		error = VN_CHECKPATH(tdvp, ip, dp, tcnp->cn_cred);
		if (error != 0)
d979 1
a979 1
			if ((nlink_t)dp->i_nlink >= LINK_MAX) {
d983 1
a983 1
			dp->i_nlink++;
d988 1
a988 2
		error = VN_DIRENTER(ip, tdvp, tcnp);
		if (error != 0) {
d990 1
a990 1
				dp->i_nlink--;
d1011 3
a1013 3
		if ((dp->i_mode & S_ISTXT) && tcnp->cn_cred->cr_uid != 0 &&
		    tcnp->cn_cred->cr_uid != dp->i_uid &&
		    xp->i_uid != tcnp->cn_cred->cr_uid) {
d1022 3
a1024 3
		if ((xp->i_mode&IFMT) == IFDIR) {
			if (!VN_DIREMPTY(ITOV(xp), xp, dp->i_number,
					  tcnp->cn_cred) || xp->i_nlink > 2) {
d1037 1
a1037 2
		error = VN_DIRREWRITE(ITOV(dp), dp, ip, tcnp);
		if (error != 0)
d1046 1
a1046 1
			dp->i_nlink--;
d1060 1
a1060 1
		xp->i_nlink--;
d1062 1
a1062 1
			if (--xp->i_nlink != 0)
d1113 1
a1113 1
			dp->i_nlink--;
a1127 5
#ifdef EXT2FS
				if(IS_EXT2_VNODE(fvp))
					namlen = ((struct odirtemplate *)
						    &dirbuf)->dotdot_namlen;
#endif /* EXT2FS */
d1146 1
a1146 1
		error = VN_DIRREMOVE(fdvp, fcnp);
d1148 1
a1148 1
			xp->i_nlink--;
d1168 1
a1168 1
		ip->i_nlink--;
d1215 1
a1215 1
	if ((nlink_t)dp->i_nlink >= LINK_MAX) {
d1229 2
a1230 2
	ip->i_uid = cnp->cn_cred->cr_uid;
	ip->i_gid = dp->i_gid;
d1242 1
a1242 1
	ip->i_mode = dmode;
d1244 1
a1244 1
	ip->i_nlink = 2;
d1246 1
a1246 1
		ip->i_flags |= UF_OPAQUE;
d1256 1
a1256 1
	dp->i_nlink++;
d1262 1
a1262 6
	if (dvp->v_mount->mnt_maxsymlinklen > 0
#ifdef EXT2FS
		/* omastertemplate is want we want for EXT2 */
		&& !IS_EXT2_VNODE(dvp)
#endif /* EXT2FS */
	)
a1268 10
#ifdef EXT2FS
	/* note that in ext2 DIRBLKSIZ == blocksize, not DEV_BSIZE
	 * so let's just redefine it - for this function only
	 */
#undef  DIRBLKSIZ
#define DIRBLKSIZ (IS_EXT2_VNODE(dvp) ? \
		   VTOI(dvp)->i_e2fs->s_blocksize : DEV_BSIZE)
	if(IS_EXT2_VNODE(dvp))
		dirtemplate.dotdot_reclen = DIRBLKSIZ - 12;
#endif /* EXT2FS */
d1273 1
a1273 1
		dp->i_nlink--;
d1280 1
a1280 1
		ip->i_size = DIRBLKSIZ;
d1285 2
a1286 3
	error = VN_DIRENTER(ip, dvp, cnp);
	if (error != 0) {
		dp->i_nlink--;
d1295 1
a1295 1
		ip->i_nlink = 0;
a1303 4
#ifdef EXT2FS
#undef	DIRBLKSIZ
#define	DIRBLKSIZ	DEV_BSIZE
#endif /* EXT2FS */
d1342 2
a1343 2
	if (ip->i_nlink != 2 ||
	    !VN_DIREMPTY(ITOV(ip), ip, dp->i_number, cnp->cn_cred)) {
d1347 2
a1348 1
	if ((dp->i_flags & APPEND) || (ip->i_flags & (IMMUTABLE | APPEND))) {
d1357 1
a1357 2
	error = VN_DIRREMOVE(dvp, cnp);
	if (error != 0)
d1359 1
a1359 1
	dp->i_nlink--;
d1375 1
a1375 1
	ip->i_nlink -= 2;
d1412 2
a1413 2
		bcopy(ap->a_target, (char *)ip->i_shortlink, len);
		ip->i_size = len;
d1524 1
a1524 1
	*ap->a_eofflag = VTOI(ap->a_vp)->i_size <= uio->uio_offset;
d1544 1
a1544 1
	isize = ip->i_size;
d1546 2
a1547 2
	    (vp->v_mount->mnt_maxsymlinklen == 0 && ip->i_din.di_blocks == 0)) {
		uiomove((char *)ip->i_shortlink, isize, ap->a_uio);
d1931 1
a1931 1
	return (lf_advlock(&ip->i_lockf, ip->i_size, ap->a_id, ap->a_op,
d1951 1
a1951 1
	switch(vp->v_type = IFTOVT(ip->i_mode)) {
d1955 1
a1955 1
		if ((nvp = checkalias(vp, ip->i_rdev, mntp)) != NULL) {
d2030 2
a2031 2
	ip->i_gid = pdir->i_gid;
	ip->i_uid = cnp->cn_cred->cr_uid;
d2043 1
a2043 1
	ip->i_mode = mode;
d2045 3
a2047 2
	ip->i_nlink = 1;
	if ((ip->i_mode & ISGID) && !groupmember(ip->i_gid, cnp->cn_cred) &&
d2049 1
a2049 1
		ip->i_mode &= ~ISGID;
d2052 1
a2052 1
		ip->i_flags |= UF_OPAQUE;
d2060 1
a2060 2
	error = VN_DIRENTER(ip, dvp, cnp);
	if (error != 0)
d2075 1
a2075 1
	ip->i_nlink = 0;
@


1.7
log
@Correct error return for link(2) to directories
Fail rename(2) on directories if one or both directories does not have
write permission
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.6 1996/06/27 06:42:09 downsj Exp $	*/
d356 1
a356 1
	 * Go through the fields and update iff not VNOVAL.
@


1.6
log
@Moving some things around; struct inode still ends up bigger, though.
This should, hopefully, be the last UFS changes required.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.5 1996/06/24 03:35:04 downsj Exp $	*/
d675 1
a675 1
		error = EISDIR;
d891 8
@


1.5
log
@ufs changes: add the notion of directory operators.

gnu/ext2fs: add the second extended filesystem.

Note that I'm commiting this now for the sake of the ufs changes; ext2fs
is not yet fully integrated into the system.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vnops.c,v 1.4 1996/05/22 11:47:22 deraadt Exp $	*/
d636 1
a636 1
	error = VTOI(dvp)->i_dirops->dirremove(dvp, ap->a_cnp);
d703 1
a703 1
		error = VTOI(dvp)->i_dirops->direnter(ip, dvp, cnp);
d755 1
a755 1
		error = ufs_direnter2(dvp, &newdir, cnp->cn_cred, cnp->cn_proc);
d766 1
a766 1
		error = ufs_dirremove(dvp, cnp);
d949 1
a949 1
		error = VTOI(tdvp)->i_dirops->checkpath(ip, dp, tcnp->cn_cred);
d986 1
a986 1
		error = VTOI(tdvp)->i_dirops->direnter(ip, tdvp, tcnp);
d1022 2
a1023 3
			if (! xp->i_dirops->dirempty
				(xp, dp->i_number, tcnp->cn_cred) || 
			    xp->i_nlink > 2) {
d1036 1
a1036 1
		error = dp->i_dirops->dirrewrite(dp, ip, tcnp);
d1151 1
a1151 1
		error = VTOI(fdvp)->i_dirops->dirremove(fdvp, fcnp);
d1305 1
a1305 1
	error = VTOI(dvp)->i_dirops->direnter(ip, dvp, cnp);
d1368 1
a1368 1
	    !ip->i_dirops->dirempty(ip, dp->i_number, cnp->cn_cred)) {
d1381 1
a1381 1
	error = VTOI(dvp)->i_dirops->dirremove(dvp, cnp);
d2084 1
a2084 1
	error = VTOI(dvp)->i_dirops->direnter(ip, dvp, cnp);
@


1.4
log
@Change VOP_UPDATE() semantics:
* Make 2nd and 3rd args timespecs, not timevals.
* Consistently pass a Boolean as the 4th arg (except in LFS).
Also, fix ffs_update() and lfs_update() to actually change the nsec fields.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 6
d636 2
a637 1
	if ((error = ufs_dirremove(dvp, ap->a_cnp)) == 0) {
d703 2
a704 1
		error = ufs_direnter(ip, dvp, cnp);
d949 2
a950 1
		if ((error = ufs_checkpath(ip, dp, tcnp->cn_cred)) != 0)
d986 2
a987 1
		if ((error = ufs_direnter(ip, tdvp, tcnp)) != 0) {
d1022 2
a1023 1
			if (!ufs_dirempty(xp, dp->i_number, tcnp->cn_cred) || 
d1037 2
a1038 1
		if ((error = ufs_dirrewrite(dp, ip, tcnp)) != 0)
d1129 5
d1152 1
a1152 1
		error = ufs_dirremove(fdvp, fcnp);
d1268 6
a1273 1
	if (dvp->v_mount->mnt_maxsymlinklen > 0)
d1280 10
d1306 2
a1307 1
	if ((error = ufs_direnter(ip, dvp, cnp)) != 0) {
d1326 4
d1369 1
a1369 1
	    !ufs_dirempty(ip, dp->i_number, cnp->cn_cred)) {
d1382 2
a1383 1
	if ((error = ufs_dirremove(dvp, cnp)) != 0)
d2085 2
a2086 1
	if ((error = ufs_direnter(ip, dvp, cnp)) != 0)
@


1.3
log
@Remove CVS conflicts that got in by mistake in my last checkin
@
text
@d2 1
a2 1
/*	$NetBSD: ufs_vnops.c,v 1.17 1996/02/11 02:06:13 christos Exp $	*/
a316 1
	struct timeval atimeval, mtimeval;
d375 1
a375 5
		atimeval.tv_sec = vap->va_atime.tv_sec;
		atimeval.tv_usec = vap->va_atime.tv_nsec / 1000;
		mtimeval.tv_sec = vap->va_mtime.tv_sec;
		mtimeval.tv_usec = vap->va_mtime.tv_nsec / 1000;
		error = VOP_UPDATE(vp, &atimeval, &mtimeval, 1);
d659 1
a659 1
	struct timeval tv;
d693 2
a694 2
	tv = time;
	error = VOP_UPDATE(vp, &tv, &tv, 1);
d813 1
a813 1
	struct timeval tv;
d916 2
a917 2
	tv = time;
	if ((error = VOP_UPDATE(fvp, &tv, &tv, 1)) != 0) {
d974 1
a974 1
			if ((error = VOP_UPDATE(tdvp, &tv, &tv, 1)) != 0)
d981 1
a981 1
				(void)VOP_UPDATE(tdvp, &tv, &tv, 1);
d1196 1
a1196 1
	struct timeval tv;
d1236 2
a1237 2
	tv = time;
	error = VOP_UPDATE(tvp, &tv, &tv, 1);
d1247 1
a1247 1
	if ((error = VOP_UPDATE(dvp, &tv, &tv, 1)) != 0)
d1999 1
a1999 1
	struct timeval tv;
d2044 2
a2045 2
	tv = time;
	if ((error = VOP_UPDATE(tvp, &tv, &tv, 1)) != 0)
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ufs_vnops.c,v 1.11 1995/10/09 11:19:32 mycroft Exp $	*/
d63 1
d96 3
a98 1
ufs_create(ap)
d104 2
a105 5
	} */ *ap;
{
	int error;

	if (error =
d107 1
a107 3
	    ap->a_dvp, ap->a_vpp, ap->a_cnp))
		return (error);
	return (0);
d115 3
a117 1
ufs_mknod(ap)
d123 1
a123 2
	} */ *ap;
{
d129 1
a129 1
	if (error =
d131 1
a131 1
	    ap->a_dvp, vpp, ap->a_cnp))
d161 3
a163 1
ufs_open(ap)
d169 1
a169 2
	} */ *ap;
{
d187 3
a189 1
ufs_close(ap)
d195 1
a195 2
	} */ *ap;
{
d205 3
a207 1
ufs_access(ap)
d213 1
a213 2
	} */ *ap;
{
a216 1
	int error;
d227 1
d231 1
a231 1
			if (error = getinoquota(ip))
d234 7
d253 3
a255 1
ufs_getattr(ap)
d261 1
a261 2
	} */ *ap;
{
d278 6
a283 6
	vap->va_atime.ts_sec = ip->i_atime;
	vap->va_atime.ts_nsec = ip->i_atimensec;
	vap->va_mtime.ts_sec = ip->i_mtime;
	vap->va_mtime.ts_nsec = ip->i_mtimensec;
	vap->va_ctime.ts_sec = ip->i_ctime;
	vap->va_ctime.ts_nsec = ip->i_ctimensec;
d303 3
a305 1
ufs_setattr(ap)
d311 1
a311 2
	} */ *ap;
{
d353 3
a355 2
	if (vap->va_uid != (uid_t)VNOVAL || vap->va_gid != (gid_t)VNOVAL)
		if (error = ufs_chown(vp, vap->va_uid, vap->va_gid, cred, p))
d357 1
d361 2
a362 1
		if (error = VOP_TRUNCATE(vp, vap->va_size, 0, cred, p))
d366 1
a366 1
	if (vap->va_atime.ts_sec != VNOVAL || vap->va_mtime.ts_sec != VNOVAL) {
d372 1
a372 1
		if (vap->va_atime.ts_sec != VNOVAL)
d374 1
a374 1
		if (vap->va_mtime.ts_sec != VNOVAL)
d376 6
a381 5
		atimeval.tv_sec = vap->va_atime.ts_sec;
		atimeval.tv_usec = vap->va_atime.ts_nsec / 1000;
		mtimeval.tv_sec = vap->va_mtime.ts_sec;
		mtimeval.tv_usec = vap->va_mtime.ts_nsec / 1000;
		if (error = VOP_UPDATE(vp, &atimeval, &mtimeval, 1))
d458 1
a458 1
	if (error = getinoquota(ip))
d530 4
a533 1
ufs_ioctl(ap)
d541 2
a542 3
	} */ *ap;
{

d548 4
a551 1
ufs_select(ap)
d558 2
a559 2
	} */ *ap;
{
d574 4
a577 1
ufs_mmap(ap)
d583 2
a584 2
	} */ *ap;
{
d596 4
a599 1
ufs_seek(ap)
d605 2
a606 2
	} */ *ap;
{
d612 3
a614 1
ufs_remove(ap)
d619 1
a619 2
	} */ *ap;
{
d625 4
d652 3
a654 1
ufs_link(ap)
d656 1
a657 1
		struct vnode *a_tdvp;
d659 2
a660 2
	} */ *ap;
{
a661 1
	register struct vnode *tdvp = ap->a_tdvp;
d671 7
a677 2
	if (vp->v_mount != tdvp->v_mount) {
		VOP_ABORTOP(vp, cnp);
d681 2
a682 2
	if (vp != tdvp && (error = VOP_LOCK(tdvp))) {
		VOP_ABORTOP(vp, cnp);
d685 1
a685 1
	ip = VTOI(tdvp);
d687 1
a687 1
		VOP_ABORTOP(vp, cnp);
d692 1
a692 1
		VOP_ABORTOP(vp, cnp);
d699 1
a699 1
	error = VOP_UPDATE(tdvp, &tv, &tv, 1);
d701 1
a701 1
		error = ufs_direnter(ip, vp, cnp);
d708 2
a709 2
	if (vp != tdvp)
		VOP_UNLOCK(tdvp);
d711 1
a711 1
	vput(vp);
d719 3
a721 1
ufs_whiteout(ap)
d726 1
a726 2
	} */ *ap;
{
d730 1
a730 1
	int error;
d799 3
a801 1
ufs_rename(ap)
d809 1
a809 2
	} */ *ap;
{
d878 1
a878 1
	if (error = VOP_LOCK(fvp))
d922 1
a922 1
	if (error = VOP_UPDATE(fvp, &tv, &tv, 1)) {
d946 1
a946 1
		if (error = ufs_checkpath(ip, dp, tcnp->cn_cred))
d950 1
a950 1
		if (error = relookup(tdvp, &tvp, tcnp))
d979 1
a979 1
			if (error = VOP_UPDATE(tdvp, &tv, &tv, 1))
d982 1
a982 1
		if (error = ufs_direnter(ip, tdvp, tcnp)) {
d1031 1
a1031 1
		if (error = ufs_dirrewrite(dp, ip, tcnp))
d1186 3
a1188 1
ufs_mkdir(ap)
d1194 1
a1194 2
	} */ *ap;
{
d1220 1
a1220 1
	if (error = VOP_VALLOC(dvp, dmode, cnp->cn_cred, &tvp))
d1252 1
a1252 1
	if (error = VOP_UPDATE(dvp, &tv, &tv, 1))
d1279 1
a1279 1
	if (error = ufs_direnter(ip, dvp, cnp)) {
d1304 3
a1306 1
ufs_rmdir(ap)
d1311 1
a1311 2
	} */ *ap;
{
d1350 1
a1350 1
	if (error = ufs_dirremove(dvp, cnp))
d1383 3
a1385 1
ufs_symlink(ap)
d1392 1
a1392 2
	} */ *ap;
{
d1397 3
a1399 2
	if (error = ufs_makeinode(IFLNK | ap->a_vap->va_mode, ap->a_dvp,
	    vpp, ap->a_cnp))
d1426 3
a1428 1
ufs_readdir(ap)
d1436 1
a1436 2
	} */ *ap;
{
d1525 3
a1527 1
ufs_readlink(ap)
d1532 1
a1532 2
	} */ *ap;
{
d1552 3
a1554 1
ufs_abortop(ap)
d1558 1
a1558 2
	} */ *ap;
{
d1568 3
a1570 1
ufs_lock(ap)
d1573 1
a1573 2
	} */ *ap;
{
d1576 1
d1578 1
d1621 3
a1623 1
ufs_unlock(ap)
d1626 1
a1626 2
	} */ *ap;
{
d1628 1
d1630 1
d1655 3
a1657 1
ufs_islocked(ap)
d1660 1
a1660 2
	} */ *ap;
{
d1672 3
a1674 1
ufs_strategy(ap)
d1677 1
a1677 2
	} */ *ap;
{
d1687 3
a1689 2
		if (error =
		    VOP_BMAP(vp, bp->b_lblkno, NULL, &bp->b_blkno, NULL)) {
d1712 3
a1714 1
ufs_print(ap)
d1717 1
a1717 2
	} */ *ap;
{
d1741 3
a1743 1
ufsspec_read(ap)
d1749 1
a1749 2
	} */ *ap;
{
d1762 3
a1764 1
ufsspec_write(ap)
d1770 1
a1770 2
	} */ *ap;
{
d1785 3
a1787 1
ufsspec_close(ap)
d1793 1
a1793 2
	} */ *ap;
{
d1806 3
a1808 1
ufsfifo_read(ap)
d1814 2
a1815 3
	} */ *ap;
{
	extern int (**fifo_vnodeop_p)();
d1828 3
a1830 1
ufsfifo_write(ap)
d1836 2
a1837 3
	} */ *ap;
{
	extern int (**fifo_vnodeop_p)();
d1851 4
a1854 1
ufsfifo_close(ap)
d1860 2
a1861 3
	} */ *ap;
{
	extern int (**fifo_vnodeop_p)();
d1873 4
a1876 1
ufs_pathconf(ap)
d1881 1
a1881 2
	} */ *ap;
{
d1912 3
a1914 1
ufs_advlock(ap)
d1921 1
a1921 2
	} */ *ap;
{
d1935 2
a1936 2
	int (**specops)();
	int (**fifoops)();
d1948 1
a1948 1
		if (nvp = checkalias(vp, ip->i_rdev, mntp)) {
d1974 7
d2017 1
a2017 1
	if (error = VOP_VALLOC(dvp, mode, cnp->cn_cred, &tvp)) {
d2024 1
a2024 4
	if ((mode & IFMT) == IFLNK)
		ip->i_uid = pdir->i_uid;
	else
		ip->i_uid = cnp->cn_cred->cr_uid;
d2050 1
a2050 1
	if (error = VOP_UPDATE(tvp, &tv, &tv, 1))
d2052 1
a2052 1
	if (error = ufs_direnter(ip, dvp, cnp))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
