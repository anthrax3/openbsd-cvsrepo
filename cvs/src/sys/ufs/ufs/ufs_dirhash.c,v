head	1.39;
access;
symbols
	OPENBSD_6_2:1.39.0.2
	OPENBSD_6_2_BASE:1.39
	OPENBSD_6_1:1.38.0.4
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.33.0.4
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.4
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.2
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.23.0.6
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.23
	OPENBSD_5_1:1.23.0.4
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.15.0.2
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	SMP:1.6.0.2;
locks; strict;
comment	@ * @;


1.39
date	2017.04.19.17.26.45;	author dhill;	state Exp;
branches;
next	1.38;
commitid	Wcn0QI8awdXjU9kV;

1.38
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.37;
commitid	RlO92XR575sygHqm;

1.37
date	2016.06.19.10.21.56;	author dlg;	state Exp;
branches;
next	1.36;
commitid	J5HRbCm5olgUBGNw;

1.36
date	2016.04.03.17.05.51;	author natano;	state Exp;
branches;
next	1.35;
commitid	X1FownqnrTueZC71;

1.35
date	2016.03.23.19.39.48;	author natano;	state Exp;
branches;
next	1.34;
commitid	BfNrL2MaozlSjLwS;

1.34
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.33;
commitid	gFybgYMymUyTbVeS;

1.33
date	2015.03.14.03.38.53;	author jsg;	state Exp;
branches;
next	1.32;
commitid	p4LJxGKbi0BU2cG6;

1.32
date	2014.12.23.01.53.34;	author tedu;	state Exp;
branches;
next	1.31;
commitid	6nkNTy1tuOQfzz0f;

1.31
date	2014.12.04.00.01.08;	author tedu;	state Exp;
branches;
next	1.30;
commitid	dXbv0AV1ph4GNkfk;

1.30
date	2014.09.14.14.17.27;	author jsg;	state Exp;
branches;
next	1.29;
commitid	uzzBR7hz9ncd4O6G;

1.29
date	2014.07.14.08.11.34;	author beck;	state Exp;
branches;
next	1.28;
commitid	7DbQuyiuCuM93wWy;

1.28
date	2014.07.13.23.33.26;	author tedu;	state Exp;
branches;
next	1.27;
commitid	zHb3aykioHZHOHpW;

1.27
date	2014.07.13.23.18.01;	author tedu;	state Exp;
branches;
next	1.26;
commitid	QarzyP4qVGwE1Eu0;

1.26
date	2014.07.12.18.44.01;	author tedu;	state Exp;
branches;
next	1.25;
commitid	bDGgAR6yEQVcVl5u;

1.25
date	2013.12.12.19.15.32;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2012.08.16.04.52.51;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2011.06.28.20.07.18;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2010.04.25.14.43.07;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2009.08.20.19.18.05;	author jasper;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.12.06.58.40;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.11.12.35.47;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.10.20.14.37;	author beck;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.08.19.26.48;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.05.16.46.30;	author thib;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.23.17.28.25;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.21.09.50.52;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2006.05.30.15.09.18;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.29.23.09.45;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.10;

1.10
date	2005.10.13.22.03.11;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.03.20.14.02;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.21.12.10.20;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.16.06.28.27;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.16.05.50.33;	author tedu;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2004.02.02.19.34.39;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.07.20.47.47;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.07.19.09.35;	author tedu;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.28.23.55.01;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.28.17.20.16;	author tedu;	state Exp;
branches;
next	;

1.6.2.1
date	2004.02.19.11.01.43;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2004.06.05.23.13.12;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Add sizes to free()

ok deraadt@@ visa@@
@
text
@/* $OpenBSD: ufs_dirhash.c,v 1.38 2016/09/15 02:00:18 dlg Exp $	*/
/*
 * Copyright (c) 2001, 2002 Ian Dowse.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * This implements a hash-based lookup scheme for UFS directories.
 */

#if 0
__FBSDID("$FreeBSD: src/sys/ufs/ufs/ufs_dirhash.c,v 1.18 2004/02/15 21:39:35 dwmalone Exp $");
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/lock.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/sysctl.h>
#include <sys/mutex.h>

#include <crypto/siphash.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ufs/dirhash.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#define WRAPINCR(val, limit)	(((val) + 1 == (limit)) ? 0 : ((val) + 1))
#define WRAPDECR(val, limit)	(((val) == 0) ? ((limit) - 1) : ((val) - 1))
#define OFSFMT(ip)		((ip)->i_ump->um_maxsymlinklen == 0)
#define BLKFREE2IDX(n)		((n) > DH_NFSTATS ? DH_NFSTATS : (n))

int ufs_mindirhashsize;
int ufs_dirhashmaxmem;
int ufs_dirhashmem;
int ufs_dirhashcheck;

SIPHASH_KEY ufsdirhash_key;

int ufsdirhash_hash(struct dirhash *dh, char *name, int namelen);
void ufsdirhash_adjfree(struct dirhash *dh, doff_t offset, int diff);
void ufsdirhash_delslot(struct dirhash *dh, int slot);
int ufsdirhash_findslot(struct dirhash *dh, char *name, int namelen,
   doff_t offset);
doff_t ufsdirhash_getprev(struct direct *dp, doff_t offset);
int ufsdirhash_recycle(int wanted);

struct pool		ufsdirhash_pool;

#define	DIRHASHLIST_LOCK()	mtx_enter(&ufsdirhash_mtx)
#define	DIRHASHLIST_UNLOCK()	mtx_leave(&ufsdirhash_mtx)
#define	DIRHASH_LOCK(dh)	mtx_enter(&(dh)->dh_mtx)
#define	DIRHASH_UNLOCK(dh)	mtx_leave(&(dh)->dh_mtx)
#define	DIRHASH_BLKALLOC()	pool_get(&ufsdirhash_pool, PR_NOWAIT)
#define	DIRHASH_BLKFREE(v)	pool_put(&ufsdirhash_pool, v)

#define	mtx_assert(l, f)	/* nothing */
#define DIRHASH_ASSERT(e, m)	KASSERT((e))

/* Dirhash list; recently-used entries are near the tail. */
TAILQ_HEAD(, dirhash) ufsdirhash_list;

/* Protects: ufsdirhash_list, `dh_list' field, ufs_dirhashmem. */
struct mutex ufsdirhash_mtx;

/*
 * Locking order:
 *	ufsdirhash_mtx
 *	dh_mtx
 *
 * The dh_mtx mutex should be acquired either via the inode lock, or via
 * ufsdirhash_mtx. Only the owner of the inode may free the associated
 * dirhash, but anything can steal its memory and set dh_hash to NULL.
 */

/*
 * Attempt to build up a hash table for the directory contents in
 * inode 'ip'. Returns 0 on success, or -1 of the operation failed.
 */
int
ufsdirhash_build(struct inode *ip)
{
	struct dirhash *dh;
	struct buf *bp = NULL;
	struct direct *ep;
	struct vnode *vp;
	doff_t bmask, pos;
	int dirblocks, i, j, memreqd, nblocks, narrays, nslots, slot;

	/* Check if we can/should use dirhash. */
	if (ip->i_dirhash == NULL) {
		if (DIP(ip, size) < ufs_mindirhashsize || OFSFMT(ip))
			return (-1);
	} else {
		/* Hash exists, but sysctls could have changed. */
		if (DIP(ip, size) < ufs_mindirhashsize ||
		    ufs_dirhashmem > ufs_dirhashmaxmem) {
			ufsdirhash_free(ip);
			return (-1);
		}
		/* Check if hash exists and is intact (note: unlocked read). */
		if (ip->i_dirhash->dh_hash != NULL)
			return (0);
		/* Free the old, recycled hash and build a new one. */
		ufsdirhash_free(ip);
	}

	/* Don't hash removed directories. */
	if (ip->i_effnlink == 0)
		return (-1);

	vp = ip->i_vnode;
	/* Allocate 50% more entries than this dir size could ever need. */
	DIRHASH_ASSERT(DIP(ip, size) >= DIRBLKSIZ, ("ufsdirhash_build size"));
	nslots = DIP(ip, size) / DIRECTSIZ(1);
	nslots = (nslots * 3 + 1) / 2;
	narrays = howmany(nslots, DH_NBLKOFF);
	nslots = narrays * DH_NBLKOFF;
	dirblocks = howmany(DIP(ip, size), DIRBLKSIZ);
	nblocks = (dirblocks * 3 + 1) / 2;

	memreqd = sizeof(*dh) + narrays * sizeof(*dh->dh_hash) +
	    narrays * DH_NBLKOFF * sizeof(**dh->dh_hash) +
	    nblocks * sizeof(*dh->dh_blkfree);
	DIRHASHLIST_LOCK();
	if (memreqd + ufs_dirhashmem > ufs_dirhashmaxmem) {
		DIRHASHLIST_UNLOCK();
		if (memreqd > ufs_dirhashmaxmem / 2)
			return (-1);

		/* Try to free some space. */
		if (ufsdirhash_recycle(memreqd) != 0)
			return (-1);
		/* Enough was freed, and list has been locked. */
	}
	ufs_dirhashmem += memreqd;
	DIRHASHLIST_UNLOCK();

	/*
	 * Use non-blocking mallocs so that we will revert to a linear
	 * lookup on failure rather than potentially blocking forever.
	 */
	dh = malloc(sizeof(*dh), M_DIRHASH, M_NOWAIT|M_ZERO);
	if (dh == NULL) {
		DIRHASHLIST_LOCK();
		ufs_dirhashmem -= memreqd;
		DIRHASHLIST_UNLOCK();
		return (-1);
	}
	dh->dh_hash = mallocarray(narrays, sizeof(dh->dh_hash[0]),
	    M_DIRHASH, M_NOWAIT|M_ZERO);
	dh->dh_blkfree = mallocarray(nblocks, sizeof(dh->dh_blkfree[0]),
	    M_DIRHASH, M_NOWAIT | M_ZERO);
	if (dh->dh_hash == NULL || dh->dh_blkfree == NULL)
		goto fail;
	for (i = 0; i < narrays; i++) {
		if ((dh->dh_hash[i] = DIRHASH_BLKALLOC()) == NULL)
			goto fail;
		for (j = 0; j < DH_NBLKOFF; j++)
			dh->dh_hash[i][j] = DIRHASH_EMPTY;
	}

	/* Initialise the hash table and block statistics. */
	mtx_init(&dh->dh_mtx, IPL_NONE);
	dh->dh_narrays = narrays;
	dh->dh_hlen = nslots;
	dh->dh_nblk = nblocks;
	dh->dh_dirblks = dirblocks;
	for (i = 0; i < dirblocks; i++)
		dh->dh_blkfree[i] = DIRBLKSIZ / DIRALIGN;
	for (i = 0; i < DH_NFSTATS; i++)
		dh->dh_firstfree[i] = -1;
	dh->dh_firstfree[DH_NFSTATS] = 0;
	dh->dh_seqopt = 0;
	dh->dh_seqoff = 0;
	dh->dh_score = DH_SCOREINIT;
	ip->i_dirhash = dh;

	bmask = VFSTOUFS(vp->v_mount)->um_mountp->mnt_stat.f_iosize - 1;
	pos = 0;
	while (pos < DIP(ip, size)) {
		/* If necessary, get the next directory block. */
		if ((pos & bmask) == 0) {
			if (bp != NULL)
				brelse(bp);
			if (UFS_BUFATOFF(ip, (off_t)pos, NULL, &bp) != 0)
				goto fail;
		}
		/* Add this entry to the hash. */
		ep = (struct direct *)((char *)bp->b_data + (pos & bmask));
		if (ep->d_reclen == 0 || ep->d_reclen >
		    DIRBLKSIZ - (pos & (DIRBLKSIZ - 1))) {
			/* Corrupted directory. */
			brelse(bp);
			goto fail;
		}
		if (ep->d_ino != 0) {
			/* Add the entry (simplified ufsdirhash_add). */
			slot = ufsdirhash_hash(dh, ep->d_name, ep->d_namlen);
			while (DH_ENTRY(dh, slot) != DIRHASH_EMPTY)
				slot = WRAPINCR(slot, dh->dh_hlen);
			dh->dh_hused++;
			DH_ENTRY(dh, slot) = pos;
			ufsdirhash_adjfree(dh, pos, -DIRSIZ(0, ep));
		}
		pos += ep->d_reclen;
	}

	if (bp != NULL)
		brelse(bp);
	DIRHASHLIST_LOCK();
	TAILQ_INSERT_TAIL(&ufsdirhash_list, dh, dh_list);
	dh->dh_onlist = 1;
	DIRHASHLIST_UNLOCK();
	return (0);

fail:
	if (dh->dh_hash != NULL) {
		for (i = 0; i < narrays; i++)
			if (dh->dh_hash[i] != NULL)
				DIRHASH_BLKFREE(dh->dh_hash[i]);
		free(dh->dh_hash, M_DIRHASH,
		    narrays * sizeof(dh->dh_hash[0]));
	}
	if (dh->dh_blkfree != NULL)
		free(dh->dh_blkfree, M_DIRHASH,
		    nblocks * sizeof(dh->dh_blkfree[0]));
	free(dh, M_DIRHASH, sizeof(*dh));
	ip->i_dirhash = NULL;
	DIRHASHLIST_LOCK();
	ufs_dirhashmem -= memreqd;
	DIRHASHLIST_UNLOCK();
	return (-1);
}

/*
 * Free any hash table associated with inode 'ip'.
 */
void
ufsdirhash_free(struct inode *ip)
{
	struct dirhash *dh;
	int i, mem;

	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASHLIST_LOCK();
	DIRHASH_LOCK(dh);
	if (dh->dh_onlist)
		TAILQ_REMOVE(&ufsdirhash_list, dh, dh_list);
	DIRHASH_UNLOCK(dh);
	DIRHASHLIST_UNLOCK();

	/* The dirhash pointed to by 'dh' is exclusively ours now. */

	mem = sizeof(*dh);
	if (dh->dh_hash != NULL) {
		for (i = 0; i < dh->dh_narrays; i++)
			DIRHASH_BLKFREE(dh->dh_hash[i]);
		free(dh->dh_hash, M_DIRHASH,
		    dh->dh_narrays * sizeof(dh->dh_hash[0]));
		free(dh->dh_blkfree, M_DIRHASH,
		    dh->dh_nblk * sizeof(dh->dh_blkfree[0]));
		mem += dh->dh_narrays * sizeof(*dh->dh_hash) +
		    dh->dh_narrays * DH_NBLKOFF * sizeof(**dh->dh_hash) +
		    dh->dh_nblk * sizeof(*dh->dh_blkfree);
	}
	free(dh, M_DIRHASH, sizeof(*dh));
	ip->i_dirhash = NULL;

	DIRHASHLIST_LOCK();
	ufs_dirhashmem -= mem;
	DIRHASHLIST_UNLOCK();
}

/*
 * Find the offset of the specified name within the given inode.
 * Returns 0 on success, ENOENT if the entry does not exist, or
 * EJUSTRETURN if the caller should revert to a linear search.
 *
 * If successful, the directory offset is stored in *offp, and a
 * pointer to a struct buf containing the entry is stored in *bpp. If
 * prevoffp is non-NULL, the offset of the previous entry within
 * the DIRBLKSIZ-sized block is stored in *prevoffp (if the entry
 * is the first in a block, the start of the block is used).
 */
int
ufsdirhash_lookup(struct inode *ip, char *name, int namelen, doff_t *offp,
    struct buf **bpp, doff_t *prevoffp)
{
	struct dirhash *dh, *dh_next;
	struct direct *dp;
	struct vnode *vp;
	struct buf *bp;
	doff_t blkoff, bmask, offset, prevoff;
	int i, slot;

	if ((dh = ip->i_dirhash) == NULL)
		return (EJUSTRETURN);
	/*
	 * Move this dirhash towards the end of the list if it has a
	 * score higher than the next entry, and acquire the dh_mtx.
	 * Optimise the case where it's already the last by performing
	 * an unlocked read of the TAILQ_NEXT pointer.
	 *
	 * In both cases, end up holding just dh_mtx.
	 */
	if (TAILQ_NEXT(dh, dh_list) != NULL) {
		DIRHASHLIST_LOCK();
		DIRHASH_LOCK(dh);
		/*
		 * If the new score will be greater than that of the next
		 * entry, then move this entry past it. With both mutexes
		 * held, dh_next won't go away, but its dh_score could
		 * change; that's not important since it is just a hint.
		 */
		if (dh->dh_hash != NULL &&
		    (dh_next = TAILQ_NEXT(dh, dh_list)) != NULL &&
		    dh->dh_score >= dh_next->dh_score) {
			DIRHASH_ASSERT(dh->dh_onlist, ("dirhash: not on list"));
			TAILQ_REMOVE(&ufsdirhash_list, dh, dh_list);
			TAILQ_INSERT_AFTER(&ufsdirhash_list, dh_next, dh,
			    dh_list);
		}
		DIRHASHLIST_UNLOCK();
	} else {
		/* Already the last, though that could change as we wait. */
		DIRHASH_LOCK(dh);
	}
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return (EJUSTRETURN);
	}

	/* Update the score. */
	if (dh->dh_score < DH_SCOREMAX)
		dh->dh_score++;

	vp = ip->i_vnode;
	bmask = VFSTOUFS(vp->v_mount)->um_mountp->mnt_stat.f_iosize - 1;
	blkoff = -1;
	bp = NULL;
restart:
	slot = ufsdirhash_hash(dh, name, namelen);

	if (dh->dh_seqopt) {
		/*
		 * Sequential access optimisation. dh_seqoff contains the
		 * offset of the directory entry immediately following
		 * the last entry that was looked up. Check if this offset
		 * appears in the hash chain for the name we are looking for.
		 */
		for (i = slot; (offset = DH_ENTRY(dh, i)) != DIRHASH_EMPTY;
		    i = WRAPINCR(i, dh->dh_hlen))
			if (offset == dh->dh_seqoff)
				break;
		if (offset == dh->dh_seqoff) {
			/*
			 * We found an entry with the expected offset. This
			 * is probably the entry we want, but if not, the
			 * code below will turn off seqopt and retry.
			 */
			slot = i;
		} else
			dh->dh_seqopt = 0;
	}

	for (; (offset = DH_ENTRY(dh, slot)) != DIRHASH_EMPTY;
	    slot = WRAPINCR(slot, dh->dh_hlen)) {
		if (offset == DIRHASH_DEL)
			continue;
		DIRHASH_UNLOCK(dh);

		if (offset < 0 || offset >= DIP(ip, size))
			panic("ufsdirhash_lookup: bad offset in hash array");
		if ((offset & ~bmask) != blkoff) {
			if (bp != NULL)
				brelse(bp);
			blkoff = offset & ~bmask;
			if (UFS_BUFATOFF(ip, (off_t)blkoff, NULL, &bp) != 0)
				return (EJUSTRETURN);
		}
		dp = (struct direct *)(bp->b_data + (offset & bmask));
		if (dp->d_reclen == 0 || dp->d_reclen >
		    DIRBLKSIZ - (offset & (DIRBLKSIZ - 1))) {
			/* Corrupted directory. */
			brelse(bp);
			return (EJUSTRETURN);
		}
		if (dp->d_namlen == namelen &&
		    memcmp(dp->d_name, name, namelen) == 0) {
			/* Found. Get the prev offset if needed. */
			if (prevoffp != NULL) {
				if (offset & (DIRBLKSIZ - 1)) {
					prevoff = ufsdirhash_getprev(dp,
					    offset);
					if (prevoff == -1) {
						brelse(bp);
						return (EJUSTRETURN);
					}
				} else
					prevoff = offset;
				*prevoffp = prevoff;
			}

			/* Check for sequential access, and update offset. */
			if (dh->dh_seqopt == 0 && dh->dh_seqoff == offset)
				dh->dh_seqopt = 1;
			dh->dh_seqoff = offset + DIRSIZ(0, dp);

			*bpp = bp;
			*offp = offset;
			return (0);
		}

		DIRHASH_LOCK(dh);
		if (dh->dh_hash == NULL) {
			DIRHASH_UNLOCK(dh);
			if (bp != NULL)
				brelse(bp);
			ufsdirhash_free(ip);
			return (EJUSTRETURN);
		}
		/*
		 * When the name doesn't match in the seqopt case, go back
		 * and search normally.
		 */
		if (dh->dh_seqopt) {
			dh->dh_seqopt = 0;
			goto restart;
		}
	}
	DIRHASH_UNLOCK(dh);
	if (bp != NULL)
		brelse(bp);
	return (ENOENT);
}

/*
 * Find a directory block with room for 'slotneeded' bytes. Returns
 * the offset of the directory entry that begins the free space.
 * This will either be the offset of an existing entry that has free
 * space at the end, or the offset of an entry with d_ino == 0 at
 * the start of a DIRBLKSIZ block.
 *
 * To use the space, the caller may need to compact existing entries in
 * the directory. The total number of bytes in all of the entries involved
 * in the compaction is stored in *slotsize. In other words, all of
 * the entries that must be compacted are exactly contained in the
 * region beginning at the returned offset and spanning *slotsize bytes.
 *
 * Returns -1 if no space was found, indicating that the directory
 * must be extended.
 */
doff_t
ufsdirhash_findfree(struct inode *ip, int slotneeded, int *slotsize)
{
	struct direct *dp;
	struct dirhash *dh;
	struct buf *bp;
	doff_t pos, slotstart;
	int dirblock, error, freebytes, i;

	if ((dh = ip->i_dirhash) == NULL)
		return (-1);
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return (-1);
	}

	/* Find a directory block with the desired free space. */
	dirblock = -1;
	for (i = howmany(slotneeded, DIRALIGN); i <= DH_NFSTATS; i++)
		if ((dirblock = dh->dh_firstfree[i]) != -1)
			break;
	if (dirblock == -1) {
		DIRHASH_UNLOCK(dh);
		return (-1);
	}

	DIRHASH_ASSERT(dirblock < dh->dh_nblk &&
	    dh->dh_blkfree[dirblock] >= howmany(slotneeded, DIRALIGN),
	    ("ufsdirhash_findfree: bad stats"));
	DIRHASH_UNLOCK(dh);
	pos = dirblock * DIRBLKSIZ;
	error = UFS_BUFATOFF(ip, (off_t)pos, (char **)&dp, &bp);
	if (error)
		return (-1);

	/* Find the first entry with free space. */
	for (i = 0; i < DIRBLKSIZ; ) {
		if (dp->d_reclen == 0) {
			brelse(bp);
			return (-1);
		}
		if (dp->d_ino == 0 || dp->d_reclen > DIRSIZ(0, dp))
			break;
		i += dp->d_reclen;
		dp = (struct direct *)((char *)dp + dp->d_reclen);
	}
	if (i > DIRBLKSIZ) {
		brelse(bp);
		return (-1);
	}
	slotstart = pos + i;

	/* Find the range of entries needed to get enough space */
	freebytes = 0;
	while (i < DIRBLKSIZ && freebytes < slotneeded) {
		freebytes += dp->d_reclen;
		if (dp->d_ino != 0)
			freebytes -= DIRSIZ(0, dp);
		if (dp->d_reclen == 0) {
			brelse(bp);
			return (-1);
		}
		i += dp->d_reclen;
		dp = (struct direct *)((char *)dp + dp->d_reclen);
	}
	if (i > DIRBLKSIZ) {
		brelse(bp);
		return (-1);
	}
	if (freebytes < slotneeded)
		panic("ufsdirhash_findfree: free mismatch");
	brelse(bp);
	*slotsize = pos + i - slotstart;
	return (slotstart);
}

/*
 * Return the start of the unused space at the end of a directory, or
 * -1 if there are no trailing unused blocks.
 */
doff_t
ufsdirhash_enduseful(struct inode *ip)
{

	struct dirhash *dh;
	int i;

	if ((dh = ip->i_dirhash) == NULL)
		return (-1);
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return (-1);
	}

	if (dh->dh_blkfree[dh->dh_dirblks - 1] != DIRBLKSIZ / DIRALIGN) {
		DIRHASH_UNLOCK(dh);
		return (-1);
	}

	for (i = dh->dh_dirblks - 1; i >= 0; i--)
		if (dh->dh_blkfree[i] != DIRBLKSIZ / DIRALIGN)
			break;
	DIRHASH_UNLOCK(dh);
	return ((doff_t)(i + 1) * DIRBLKSIZ);
}

/*
 * Insert information into the hash about a new directory entry. dirp
 * points to a struct direct containing the entry, and offset specifies
 * the offset of this entry.
 */
void
ufsdirhash_add(struct inode *ip, struct direct *dirp, doff_t offset)
{
	struct dirhash *dh;
	int slot;

	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	DIRHASH_ASSERT(offset < dh->dh_dirblks * DIRBLKSIZ,
	    ("ufsdirhash_add: bad offset"));
	/*
	 * Normal hash usage is < 66%. If the usage gets too high then
	 * remove the hash entirely and let it be rebuilt later.
	 */
	if (dh->dh_hused >= (dh->dh_hlen * 3) / 4) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	/* Find a free hash slot (empty or deleted), and add the entry. */
	slot = ufsdirhash_hash(dh, dirp->d_name, dirp->d_namlen);
	while (DH_ENTRY(dh, slot) >= 0)
		slot = WRAPINCR(slot, dh->dh_hlen);
	if (DH_ENTRY(dh, slot) == DIRHASH_EMPTY)
		dh->dh_hused++;
	DH_ENTRY(dh, slot) = offset;

	/* Update the per-block summary info. */
	ufsdirhash_adjfree(dh, offset, -DIRSIZ(0, dirp));
	DIRHASH_UNLOCK(dh);
}

/*
 * Remove the specified directory entry from the hash. The entry to remove
 * is defined by the name in `dirp', which must exist at the specified
 * `offset' within the directory.
 */
void
ufsdirhash_remove(struct inode *ip, struct direct *dirp, doff_t offset)
{
	struct dirhash *dh;
	int slot;

	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	DIRHASH_ASSERT(offset < dh->dh_dirblks * DIRBLKSIZ,
	    ("ufsdirhash_remove: bad offset"));
	/* Find the entry */
	slot = ufsdirhash_findslot(dh, dirp->d_name, dirp->d_namlen, offset);

	/* Remove the hash entry. */
	ufsdirhash_delslot(dh, slot);

	/* Update the per-block summary info. */
	ufsdirhash_adjfree(dh, offset, DIRSIZ(0, dirp));
	DIRHASH_UNLOCK(dh);
}

/*
 * Change the offset associated with a directory entry in the hash. Used
 * when compacting directory blocks.
 */
void
ufsdirhash_move(struct inode *ip, struct direct *dirp, doff_t oldoff,
    doff_t newoff)
{
	struct dirhash *dh;
	int slot;

	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	DIRHASH_ASSERT(oldoff < dh->dh_dirblks * DIRBLKSIZ &&
	    newoff < dh->dh_dirblks * DIRBLKSIZ,
	    ("ufsdirhash_move: bad offset"));
	/* Find the entry, and update the offset. */
	slot = ufsdirhash_findslot(dh, dirp->d_name, dirp->d_namlen, oldoff);
	DH_ENTRY(dh, slot) = newoff;
	DIRHASH_UNLOCK(dh);
}

/*
 * Inform dirhash that the directory has grown by one block that
 * begins at offset (i.e. the new length is offset + DIRBLKSIZ).
 */
void
ufsdirhash_newblk(struct inode *ip, doff_t offset)
{
	struct dirhash *dh;
	int block;

	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	DIRHASH_ASSERT(offset == dh->dh_dirblks * DIRBLKSIZ,
	    ("ufsdirhash_newblk: bad offset"));
	block = offset / DIRBLKSIZ;
	if (block >= dh->dh_nblk) {
		/* Out of space; must rebuild. */
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}
	dh->dh_dirblks = block + 1;

	/* Account for the new free block. */
	dh->dh_blkfree[block] = DIRBLKSIZ / DIRALIGN;
	if (dh->dh_firstfree[DH_NFSTATS] == -1)
		dh->dh_firstfree[DH_NFSTATS] = block;
	DIRHASH_UNLOCK(dh);
}

/*
 * Inform dirhash that the directory is being truncated.
 */
void
ufsdirhash_dirtrunc(struct inode *ip, doff_t offset)
{
	struct dirhash *dh;
	int block, i;

	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	DIRHASH_ASSERT(offset <= dh->dh_dirblks * DIRBLKSIZ,
	    ("ufsdirhash_dirtrunc: bad offset"));
	block = howmany(offset, DIRBLKSIZ);
	/*
	 * If the directory shrinks to less than 1/8 of dh_nblk blocks
	 * (about 20% of its original size due to the 50% extra added in
	 * ufsdirhash_build) then free it, and let the caller rebuild
	 * if necessary.
	 */
	if (block < dh->dh_nblk / 8 && dh->dh_narrays > 1) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	/*
	 * Remove any `first free' information pertaining to the
	 * truncated blocks. All blocks we're removing should be
	 * completely unused.
	 */
	if (dh->dh_firstfree[DH_NFSTATS] >= block)
		dh->dh_firstfree[DH_NFSTATS] = -1;
	for (i = block; i < dh->dh_dirblks; i++)
		if (dh->dh_blkfree[i] != DIRBLKSIZ / DIRALIGN)
			panic("ufsdirhash_dirtrunc: blocks in use");
	for (i = 0; i < DH_NFSTATS; i++)
		if (dh->dh_firstfree[i] >= block)
			panic("ufsdirhash_dirtrunc: first free corrupt");
	dh->dh_dirblks = block;
	DIRHASH_UNLOCK(dh);
}

/*
 * Debugging function to check that the dirhash information about
 * a directory block matches its actual contents. Panics if a mismatch
 * is detected.
 *
 * On entry, `buf' should point to the start of an in-core
 * DIRBLKSIZ-sized directory block, and `offset' should contain the
 * offset from the start of the directory of that block.
 */
void
ufsdirhash_checkblock(struct inode *ip, char *buf, doff_t offset)
{
	struct dirhash *dh;
	struct direct *dp;
	int block, ffslot, i, nfree;

	if (!ufs_dirhashcheck)
		return;
	if ((dh = ip->i_dirhash) == NULL)
		return;
	DIRHASH_LOCK(dh);
	if (dh->dh_hash == NULL) {
		DIRHASH_UNLOCK(dh);
		ufsdirhash_free(ip);
		return;
	}

	block = offset / DIRBLKSIZ;
	if ((offset & (DIRBLKSIZ - 1)) != 0 || block >= dh->dh_dirblks)
		panic("ufsdirhash_checkblock: bad offset");

	nfree = 0;
	for (i = 0; i < DIRBLKSIZ; i += dp->d_reclen) {
		dp = (struct direct *)(buf + i);
		if (dp->d_reclen == 0 || i + dp->d_reclen > DIRBLKSIZ)
			panic("ufsdirhash_checkblock: bad dir");

		if (dp->d_ino == 0) {
#if 0
			/*
			 * XXX entries with d_ino == 0 should only occur
			 * at the start of a DIRBLKSIZ block. However the
			 * ufs code is tolerant of such entries at other
			 * offsets, and fsck does not fix them.
			 */
			if (i != 0)
				panic("ufsdirhash_checkblock: bad dir inode");
#endif
			nfree += dp->d_reclen;
			continue;
		}

		/* Check that the entry	exists (will panic if it doesn't). */
		ufsdirhash_findslot(dh, dp->d_name, dp->d_namlen, offset + i);

		nfree += dp->d_reclen - DIRSIZ(0, dp);
	}
	if (i != DIRBLKSIZ)
		panic("ufsdirhash_checkblock: bad dir end");

	if (dh->dh_blkfree[block] * DIRALIGN != nfree)
		panic("ufsdirhash_checkblock: bad free count");

	ffslot = BLKFREE2IDX(nfree / DIRALIGN);
	for (i = 0; i <= DH_NFSTATS; i++)
		if (dh->dh_firstfree[i] == block && i != ffslot)
			panic("ufsdirhash_checkblock: bad first-free");
	if (dh->dh_firstfree[ffslot] == -1)
		panic("ufsdirhash_checkblock: missing first-free entry");
	DIRHASH_UNLOCK(dh);
}

/*
 * Hash the specified filename into a dirhash slot.
 */
int
ufsdirhash_hash(struct dirhash *dh, char *name, int namelen)
{
	return SipHash24(&ufsdirhash_key, name, namelen) % dh->dh_hlen;
}

/*
 * Adjust the number of free bytes in the block containing `offset'
 * by the value specified by `diff'.
 *
 * The caller must ensure we have exclusive access to `dh'; normally
 * that means that dh_mtx should be held, but this is also called
 * from ufsdirhash_build() where exclusive access can be assumed.
 */
void
ufsdirhash_adjfree(struct dirhash *dh, doff_t offset, int diff)
{
	int block, i, nfidx, ofidx;

	/* Update the per-block summary info. */
	block = offset / DIRBLKSIZ;
	DIRHASH_ASSERT(block < dh->dh_nblk && block < dh->dh_dirblks,
	     ("dirhash bad offset"));
	ofidx = BLKFREE2IDX(dh->dh_blkfree[block]);
	dh->dh_blkfree[block] = (int)dh->dh_blkfree[block] + (diff / DIRALIGN);
	nfidx = BLKFREE2IDX(dh->dh_blkfree[block]);

	/* Update the `first free' list if necessary. */
	if (ofidx != nfidx) {
		/* If removing, scan forward for the next block. */
		if (dh->dh_firstfree[ofidx] == block) {
			for (i = block + 1; i < dh->dh_dirblks; i++)
				if (BLKFREE2IDX(dh->dh_blkfree[i]) == ofidx)
					break;
			dh->dh_firstfree[ofidx] = (i < dh->dh_dirblks) ? i : -1;
		}

		/* Make this the new `first free' if necessary */
		if (dh->dh_firstfree[nfidx] > block ||
		    dh->dh_firstfree[nfidx] == -1)
			dh->dh_firstfree[nfidx] = block;
	}
}

/*
 * Find the specified name which should have the specified offset.
 * Returns a slot number, and panics on failure.
 *
 * `dh' must be locked on entry and remains so on return.
 */
int
ufsdirhash_findslot(struct dirhash *dh, char *name, int namelen, doff_t offset)
{
	int slot;

	mtx_assert(&dh->dh_mtx, MA_OWNED);

	/* Find the entry. */
	DIRHASH_ASSERT(dh->dh_hused < dh->dh_hlen, ("dirhash find full"));
	slot = ufsdirhash_hash(dh, name, namelen);
	while (DH_ENTRY(dh, slot) != offset &&
	    DH_ENTRY(dh, slot) != DIRHASH_EMPTY)
		slot = WRAPINCR(slot, dh->dh_hlen);
	if (DH_ENTRY(dh, slot) != offset)
		panic("ufsdirhash_findslot: '%.*s' not found", namelen, name);

	return (slot);
}

/*
 * Remove the entry corresponding to the specified slot from the hash array.
 *
 * `dh' must be locked on entry and remains so on return.
 */
void
ufsdirhash_delslot(struct dirhash *dh, int slot)
{
	int i;

	mtx_assert(&dh->dh_mtx, MA_OWNED);

	/* Mark the entry as deleted. */
	DH_ENTRY(dh, slot) = DIRHASH_DEL;

	/* If this is the end of a chain of DIRHASH_DEL slots, remove them. */
	for (i = slot; DH_ENTRY(dh, i) == DIRHASH_DEL; )
		i = WRAPINCR(i, dh->dh_hlen);
	if (DH_ENTRY(dh, i) == DIRHASH_EMPTY) {
		i = WRAPDECR(i, dh->dh_hlen);
		while (DH_ENTRY(dh, i) == DIRHASH_DEL) {
			DH_ENTRY(dh, i) = DIRHASH_EMPTY;
			dh->dh_hused--;
			i = WRAPDECR(i, dh->dh_hlen);
		}
		DIRHASH_ASSERT(dh->dh_hused >= 0, ("ufsdirhash_delslot neg hlen"));
	}
}

/*
 * Given a directory entry and its offset, find the offset of the
 * previous entry in the same DIRBLKSIZ-sized block. Returns an
 * offset, or -1 if there is no previous entry in the block or some
 * other problem occurred.
 */
doff_t
ufsdirhash_getprev(struct direct *dirp, doff_t offset)
{
	struct direct *dp;
	char *blkbuf;
	doff_t blkoff, prevoff;
	int entrypos, i;

	blkoff = offset & ~(DIRBLKSIZ - 1);	/* offset of start of block */
	entrypos = offset & (DIRBLKSIZ - 1);	/* entry relative to block */
	blkbuf = (char *)dirp - entrypos;
	prevoff = blkoff;

	/* If `offset' is the start of a block, there is no previous entry. */
	if (entrypos == 0)
		return (-1);

	/* Scan from the start of the block until we get to the entry. */
	for (i = 0; i < entrypos; i += dp->d_reclen) {
		dp = (struct direct *)(blkbuf + i);
		if (dp->d_reclen == 0 || i + dp->d_reclen > entrypos)
			return (-1);	/* Corrupted directory. */
		prevoff = blkoff + i;
	}
	return (prevoff);
}

/*
 * Try to free up `wanted' bytes by stealing memory from existing
 * dirhashes. Returns zero with list locked if successful.
 */
int
ufsdirhash_recycle(int wanted)
{
	struct dirhash *dh;
	doff_t **hash;
	u_int8_t *blkfree;
	int i, mem, narrays, nblk;

	DIRHASHLIST_LOCK();
	while (wanted + ufs_dirhashmem > ufs_dirhashmaxmem) {
		/* Find a dirhash, and lock it. */
		if ((dh = TAILQ_FIRST(&ufsdirhash_list)) == NULL) {
			DIRHASHLIST_UNLOCK();
			return (-1);
		}
		DIRHASH_LOCK(dh);
		DIRHASH_ASSERT(dh->dh_hash != NULL, ("dirhash: NULL hash on list"));

		/* Decrement the score; only recycle if it becomes zero. */
		if (--dh->dh_score > 0) {
			DIRHASH_UNLOCK(dh);
			DIRHASHLIST_UNLOCK();
			return (-1);
		}

		/* Remove it from the list and detach its memory. */
		TAILQ_REMOVE(&ufsdirhash_list, dh, dh_list);
		dh->dh_onlist = 0;
		hash = dh->dh_hash;
		dh->dh_hash = NULL;
		blkfree = dh->dh_blkfree;
		dh->dh_blkfree = NULL;
		narrays = dh->dh_narrays;
		nblk = dh->dh_nblk;
		mem = narrays * sizeof(*dh->dh_hash) +
		    narrays * DH_NBLKOFF * sizeof(**dh->dh_hash) +
		    dh->dh_nblk * sizeof(*dh->dh_blkfree);

		/* Unlock everything, free the detached memory. */
		DIRHASH_UNLOCK(dh);
		DIRHASHLIST_UNLOCK();
		for (i = 0; i < narrays; i++)
			DIRHASH_BLKFREE(hash[i]);
		free(hash, M_DIRHASH, narrays * sizeof(hash[0]));
		free(blkfree, M_DIRHASH, nblk * sizeof(blkfree[0]));

		/* Account for the returned memory, and repeat if necessary. */
		DIRHASHLIST_LOCK();
		ufs_dirhashmem -= mem;
	}
	/* Success; return with list locked. */
	return (0);
}


void
ufsdirhash_init(void)
{
	pool_init(&ufsdirhash_pool, DH_NBLKOFF * sizeof(doff_t), 0, IPL_NONE,
	    PR_WAITOK, "dirhash", NULL);
	mtx_init(&ufsdirhash_mtx, IPL_NONE);
	arc4random_buf(&ufsdirhash_key, sizeof(ufsdirhash_key));
	TAILQ_INIT(&ufsdirhash_list);
	ufs_dirhashmaxmem = 2 * 1024 * 1024;
	ufs_mindirhashsize = 5 * DIRBLKSIZ;
}

void
ufsdirhash_uninit(void)
{
	DIRHASH_ASSERT(TAILQ_EMPTY(&ufsdirhash_list), ("ufsdirhash_uninit"));
	pool_destroy(&ufsdirhash_pool);
}
@


1.38
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.37 2016/06/19 10:21:56 dlg Exp $	*/
d249 2
a250 1
		free(dh->dh_hash, M_DIRHASH, 0);
d253 3
a255 2
		free(dh->dh_blkfree, M_DIRHASH, 0);
	free(dh, M_DIRHASH, 0);
d287 4
a290 2
		free(dh->dh_hash, M_DIRHASH, 0);
		free(dh->dh_blkfree, M_DIRHASH, 0);
d295 1
a295 1
	free(dh, M_DIRHASH, 0);
d1003 1
a1003 1
	int i, mem, narrays;
d1030 1
d1040 2
a1041 2
		free(hash, M_DIRHASH, 0);
		free(blkfree, M_DIRHASH, 0);
@


1.37
log
@add pool_setipl on all pools.

ok tedu@@ visa@@
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.36 2016/04/03 17:05:51 natano Exp $	*/
d1050 1
a1050 1
	pool_init(&ufsdirhash_pool, DH_NBLKOFF * sizeof(doff_t), 0, 0,
a1051 1
	pool_setipl(&ufsdirhash_pool, IPL_NONE);
@


1.36
log
@Remove sparc special-casing from ufsdirhash_init(). This is not required
anymore since the kernel VM space increase work done in sparc about one
year ago.

from Miod Vallat; thanks!
ok tobiasu
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.35 2016/03/23 19:39:48 natano Exp $	*/
d1052 1
@


1.35
log
@remove vax handling
ok millert
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.34 2016/02/27 18:50:38 natano Exp $	*/
d1055 1
a1055 4
#if defined (__sparc__) && !defined (__sparc64__)
	if (!CPU_ISSUN4OR4C)
#endif
		ufs_dirhashmaxmem = 2 * 1024 * 1024;
@


1.34
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.33 2015/03/14 03:38:53 jsg Exp $	*/
a1056 2
#elif defined (__vax__)
	if (0)
@


1.33
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.32 2014/12/23 01:53:34 tedu Exp $	*/
d57 1
a57 1
#define OFSFMT(vp)		((vp)->v_mount->mnt_maxsymlinklen <= 0)
d119 1
a119 1
		if (DIP(ip, size) < ufs_mindirhashsize || OFSFMT(ip->i_vnode))
@


1.32
log
@change pool_init allocator to NULL and pass PR_WAITOK in flags as a sign
that these don't need to support interrupts
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.31 2014/12/04 00:01:08 tedu Exp $	*/
a36 1
#include <sys/kernel.h>
@


1.31
log
@use siphash for dirhash. ok deraadt dlg
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.30 2014/09/14 14:17:27 jsg Exp $	*/
d1051 2
a1052 2
	pool_init(&ufsdirhash_pool, DH_NBLKOFF * sizeof(doff_t), 0, 0, 0,
	    "dirhash", &pool_allocator_nointr);
@


1.30
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.29 2014/07/14 08:11:34 beck Exp $	*/
a44 1
#include <sys/hash.h>
d47 2
d66 1
d862 1
a862 11
	u_int32_t hash;

	/*
	 * We hash the name and then some other bit of data that is
	 * invariant over the dirhash's lifetime. Otherwise names
	 * differing only in the last byte are placed close to one
	 * another in the table, which is bad for linear probing.
	 */
	hash = hash32_buf(name, namelen, HASHINIT);
	hash = hash32_buf(&dh, sizeof(dh), hash);
	return (hash % dh->dh_hlen);
d1054 1
@


1.29
log
@revert free checks in here. this seems to be a bit too agressive at the
moment and now is not the time. hitting these in here causes chaos.
We need to do these, but at a better time than right after a hackathon
and before release.
ok guenther@@
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.28 2014/07/13 23:33:26 tedu Exp $	*/
a40 1
#include <sys/proc.h>
@


1.28
log
@pass correct sizes to free()
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.27 2014/07/13 23:18:01 tedu Exp $	*/
d249 1
a249 1
		free(dh->dh_hash, M_DIRHASH, narrays * sizeof(dh->dh_hash[0]));
d252 2
a253 3
		free(dh->dh_blkfree, M_DIRHASH,
		    nblocks * sizeof(dh->dh_blkfree[0]));
	free(dh, M_DIRHASH, sizeof(*dh));
d285 2
a286 2
		free(dh->dh_hash, M_DIRHASH, dh->dh_narrays * sizeof(*dh->dh_hash));
		free(dh->dh_blkfree, M_DIRHASH, dh->dh_nblk * sizeof(*dh->dh_blkfree));
d291 1
a291 1
	free(dh, M_DIRHASH, sizeof(*dh));
d1045 2
a1046 2
		free(hash, M_DIRHASH, narrays * sizeof(*dh->dh_hash));
		free(blkfree, M_DIRHASH, dh->dh_nblk * sizeof(*dh->dh_blkfree));
@


1.27
log
@use mallocarray
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.26 2014/07/12 18:44:01 tedu Exp $	*/
d249 1
a249 1
		free(dh->dh_hash, M_DIRHASH, 0);
d252 3
a254 2
		free(dh->dh_blkfree, M_DIRHASH, 0);
	free(dh, M_DIRHASH, 0);
d286 2
a287 2
		free(dh->dh_hash, M_DIRHASH, 0);
		free(dh->dh_blkfree, M_DIRHASH, 0);
d292 1
a292 1
	free(dh, M_DIRHASH, 0);
d1046 2
a1047 2
		free(hash, M_DIRHASH, 0);
		free(blkfree, M_DIRHASH, 0);
@


1.26
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.25 2013/12/12 19:15:32 tedu Exp $	*/
d177 1
a177 1
	dh->dh_hash = malloc(narrays * sizeof(dh->dh_hash[0]),
d179 1
a179 1
	dh->dh_blkfree = malloc(nblocks * sizeof(dh->dh_blkfree[0]),
@


1.25
log
@bcmp -> memcmp
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.24 2012/08/16 04:52:51 tedu Exp $	*/
d249 1
a249 1
		free(dh->dh_hash, M_DIRHASH);
d252 2
a253 2
		free(dh->dh_blkfree, M_DIRHASH);
	free(dh, M_DIRHASH);
d285 2
a286 2
		free(dh->dh_hash, M_DIRHASH);
		free(dh->dh_blkfree, M_DIRHASH);
d291 1
a291 1
	free(dh, M_DIRHASH);
d1045 2
a1046 2
		free(hash, M_DIRHASH);
		free(blkfree, M_DIRHASH);
@


1.24
log
@remove pool hiwat call.  hiwat is less useful than it used to be.
less greedy pools are nicer pools.
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.23 2011/06/28 20:07:18 tedu Exp $	*/
d415 1
a415 1
		    bcmp(dp->d_name, name, namelen) == 0) {
@


1.23
log
@change two function defs with () to (void)
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.22 2010/04/25 14:43:07 tedu Exp $	*/
a1061 1
	pool_sethiwat(&ufsdirhash_pool, 512);
@


1.22
log
@dirhash cna cope with real locks (and has before), enable mutexes here.
ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.21 2009/08/20 19:18:05 jasper Exp $	*/
d1058 1
a1058 1
ufsdirhash_init()
d1075 1
a1075 1
ufsdirhash_uninit()
@


1.21
log
@- reference correct variable in comment

ok tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.20 2008/06/12 06:58:40 deraadt Exp $	*/
a38 1
#include <sys/rwlock.h>
d47 1
d77 4
a80 4
#define	DIRHASHLIST_LOCK()
#define	DIRHASHLIST_UNLOCK()
#define	DIRHASH_LOCK(dh)
#define	DIRHASH_UNLOCK(dh)
d91 1
d191 1
d1063 1
@


1.20
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.18 2008/06/10 20:14:37 beck Exp $	*/
d383 1
a383 1
			 * code below will turn off seqoff and retry.
@


1.19
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.17 2007/10/08 19:26:48 krw Exp $	*/
a213 1

@


1.18
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@d214 1
@


1.17
log
@Initialize dh_blkfree with zero's.

ok beck@@
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.16 2007/10/05 16:46:30 thib Exp $	*/
a213 1

@


1.16
log
@MALLOC/FREE -> malloc/free + M_ZERO.

As a side effect, this probably fixes PR5596, if the allocation
of dh_hash succeeds and the dh_blkfree fails, we jump into the
fail case, but we haven't initialized dh_hash properly, that is
filling the array with memory from the dirhash pool, but the
!= NULL check holds, since the memory hasn't been zeroed and
so we start pool_put()'ing, causing the crash in PR5596.

PR5596 debugging by pedro.

ok art@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.15 2007/07/23 17:28:25 kettenis Exp $	*/
d179 1
a179 1
	    M_DIRHASH, M_NOWAIT);
@


1.15
log
@Since __sparc__ gets defined on sparc64 too, add a !defined (__sparc64__)
to the condition that protects CPU_ISSUN4OR4C.  While we currently define
that macro on sparc64 too, we won't in the near future.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.14 2006/06/21 09:50:52 mickey Exp $	*/
d169 1
a169 1
	MALLOC(dh, struct dirhash *, sizeof *dh, M_DIRHASH, M_NOWAIT);
a175 1
	memset(dh, 0, sizeof *dh);
d177 1
a177 1
	    M_DIRHASH, M_NOWAIT);
a181 1
	memset(dh->dh_hash, 0, narrays * sizeof(dh->dh_hash[0]));
d252 1
a252 1
	FREE(dh, M_DIRHASH);
d290 1
a290 1
	FREE(dh, M_DIRHASH);
@


1.14
log
@do not wait in pool_get() here as we can recover from no memory; tedu@@ pedro@@ ok; tested by many
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.13 2006/05/30 15:09:18 mickey Exp $	*/
d1065 1
a1065 1
#if defined (__sparc__)
@


1.13
log
@do not deref a ptr before NULL check; pedro@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.12 2006/04/29 23:09:45 tedu Exp $	*/
d81 2
a82 2
#define	DIRHASH_BLKALLOC_WAITOK()	pool_get(&ufsdirhash_pool, PR_WAITOK)
#define	DIRHASH_BLKFREE(v)		pool_put(&ufsdirhash_pool, v)
d185 1
a185 1
		if ((dh->dh_hash[i] = DIRHASH_BLKALLOC_WAITOK()) == NULL)
@


1.12
log
@no need for using rwlocks in dirhash.  i was confused about the purpose
freebsd's mutexes served here, but they are only for smp protection.
the code is careful not to block and needs no rwlocks.
ok pedro and an assortment of testers
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.11 2005/12/28 20:48:18 pedro Exp $	*/
a178 1
	memset(dh->dh_hash, 0, narrays * sizeof(dh->dh_hash[0]));
d183 1
@


1.11
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.10 2005/10/13 22:03:11 mickey Exp $	*/
d77 4
a80 4
#define	DIRHASHLIST_LOCK()	rw_enter_write(&ufsdirhash_mtx)
#define	DIRHASHLIST_UNLOCK()	rw_exit_write(&ufsdirhash_mtx)
#define	DIRHASH_LOCK(dh)	rw_enter_write(&(dh)->dh_mtx)
#define	DIRHASH_UNLOCK(dh)	rw_exit_write(&(dh)->dh_mtx)
a90 1
struct rwlock		ufsdirhash_mtx;
a191 1
	rw_init(&dh->dh_mtx);
a1063 1
	rw_init(&ufsdirhash_mtx);
@


1.10
log
@pump up the high water mark on the dirhash pool to avoid page allocation throttling; pedro@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.9 2005/07/03 20:14:02 drahn Exp $	*/
d119 1
a119 1
		if (ip->i_size < ufs_mindirhashsize || OFSFMT(ip->i_vnode))
d123 1
a123 1
		if (ip->i_size < ufs_mindirhashsize ||
d141 2
a142 2
	DIRHASH_ASSERT(ip->i_size >= DIRBLKSIZ, ("ufsdirhash_build size"));
	nslots = ip->i_size / DIRECTSIZ(1);
d146 1
a146 1
	dirblocks = howmany(ip->i_size, DIRBLKSIZ);
d210 1
a210 1
	while (pos < ip->i_size) {
d401 1
a401 1
		if (offset < 0 || offset >= ip->i_size)
@


1.9
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.8 2004/07/21 12:10:20 art Exp $	*/
d1065 1
@


1.8
log
@I was wrong. The assymetry created by the proc argument to rw_enter_write
is horrible and doesn't add anything.

Remove it.
XXX - the fdplock macro will need a separate cleanup.

niklas@@ markus@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.7 2004/03/16 06:28:27 tedu Exp $	*/
a52 1
#include <ufs/ufs/extattr.h>
@


1.7
log
@re-add fbsd id so i can track this thing
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.6 2004/02/16 05:50:33 tedu Exp $	*/
d78 1
a78 1
#define	DIRHASHLIST_LOCK()	rw_enter_write(&ufsdirhash_mtx, curproc)
d80 1
a80 1
#define	DIRHASH_LOCK(dh)	rw_enter_write(&(dh)->dh_mtx, curproc)
@


1.6
log
@sync MACRO names with freebsd.
@
text
@d1 1
a1 1
/* $OpenBSD: ufs_dirhash.c,v 1.5 2004/02/02 19:34:39 tedu Exp $	*/
d30 4
@


1.6.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d72 12
d87 1
a87 4
struct pool		ufsdirhash_pool;
#define		DIRHASH_ALLOC()	pool_get(&ufsdirhash_pool, PR_WAITOK)
#define		DIRHASH_FREE(v)	pool_put(&ufsdirhash_pool, v)

a88 5
#define		DIRHASH_LOCK(l)		rw_enter_write(l, curproc)
#define		DIRHASH_UNLOCK(l)	rw_exit_write(l)
#define		mtx_assert(l, f)	/* nothing */

#define DIRHASH_ASSERT(e, m)	KASSERT((e))
d149 1
a149 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d151 1
a151 1
		DIRHASH_UNLOCK(&ufsdirhash_mtx);
d158 1
a158 1
		/* Enough was freed, and ufsdirhash_mtx has been locked. */
d161 1
a161 1
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d169 1
a169 1
		DIRHASH_LOCK(&ufsdirhash_mtx);
d171 1
a171 1
		DIRHASH_UNLOCK(&ufsdirhash_mtx);
d183 1
a183 1
		if ((dh->dh_hash[i] = DIRHASH_ALLOC()) == NULL)
d238 1
a238 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d241 1
a241 1
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d248 1
a248 1
				DIRHASH_FREE(dh->dh_hash[i]);
d255 1
a255 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d257 1
a257 1
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d272 2
a273 2
	DIRHASH_LOCK(&ufsdirhash_mtx);
	DIRHASH_LOCK(&dh->dh_mtx);
d276 2
a277 2
	DIRHASH_UNLOCK(&dh->dh_mtx);
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d284 1
a284 1
			DIRHASH_FREE(dh->dh_hash[i]);
d294 1
a294 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d296 1
a296 1
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d332 2
a333 2
		DIRHASH_LOCK(&ufsdirhash_mtx);
		DIRHASH_LOCK(&dh->dh_mtx);
d348 1
a348 1
		DIRHASH_UNLOCK(&ufsdirhash_mtx);
d351 1
a351 1
		DIRHASH_LOCK(&dh->dh_mtx);
d354 1
a354 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d396 1
a396 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d440 1
a440 1
		DIRHASH_LOCK(&dh->dh_mtx);
d442 1
a442 1
			DIRHASH_UNLOCK(&dh->dh_mtx);
d457 1
a457 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d490 1
a490 1
	DIRHASH_LOCK(&dh->dh_mtx);
d492 1
a492 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d503 1
a503 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d510 1
a510 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d570 1
a570 1
	DIRHASH_LOCK(&dh->dh_mtx);
d572 1
a572 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d578 1
a578 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d585 1
a585 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d602 1
a602 1
	DIRHASH_LOCK(&dh->dh_mtx);
d604 1
a604 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d616 1
a616 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d631 1
a631 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d647 1
a647 1
	DIRHASH_LOCK(&dh->dh_mtx);
d649 1
a649 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d664 1
a664 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d680 1
a680 1
	DIRHASH_LOCK(&dh->dh_mtx);
d682 1
a682 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d693 1
a693 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d708 1
a708 1
	DIRHASH_LOCK(&dh->dh_mtx);
d710 1
a710 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d720 1
a720 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d730 1
a730 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d744 1
a744 1
	DIRHASH_LOCK(&dh->dh_mtx);
d746 1
a746 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d761 1
a761 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d780 1
a780 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d803 1
a803 1
	DIRHASH_LOCK(&dh->dh_mtx);
d805 1
a805 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d852 1
a852 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d1001 1
a1001 1
 * dirhashes. Returns zero with ufsdirhash_mtx locked if successful.
d1011 1
a1011 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d1015 1
a1015 1
			DIRHASH_UNLOCK(&ufsdirhash_mtx);
d1018 1
a1018 1
		DIRHASH_LOCK(&dh->dh_mtx);
d1023 2
a1024 2
			DIRHASH_UNLOCK(&dh->dh_mtx);
			DIRHASH_UNLOCK(&ufsdirhash_mtx);
d1041 2
a1042 2
		DIRHASH_UNLOCK(&dh->dh_mtx);
		DIRHASH_UNLOCK(&ufsdirhash_mtx);
d1044 1
a1044 1
			DIRHASH_FREE(hash[i]);
d1049 1
a1049 1
		DIRHASH_LOCK(&ufsdirhash_mtx);
d1052 1
a1052 1
	/* Success; return with ufsdirhash_mtx locked. */
@


1.6.2.2
log
@Merge with the trunk
@
text
@a30 4
#if 0
__FBSDID("$FreeBSD: src/sys/ufs/ufs/ufs_dirhash.c,v 1.18 2004/02/15 21:39:35 dwmalone Exp $");
#endif

d72 3
d76 2
d79 4
a82 6
#define	DIRHASHLIST_LOCK()	rw_enter_write(&ufsdirhash_mtx, curproc)
#define	DIRHASHLIST_UNLOCK()	rw_exit_write(&ufsdirhash_mtx)
#define	DIRHASH_LOCK(dh)	rw_enter_write(&(dh)->dh_mtx, curproc)
#define	DIRHASH_UNLOCK(dh)	rw_exit_write(&(dh)->dh_mtx)
#define	DIRHASH_BLKALLOC_WAITOK()	pool_get(&ufsdirhash_pool, PR_WAITOK)
#define	DIRHASH_BLKFREE(v)		pool_put(&ufsdirhash_pool, v)
a83 1
#define	mtx_assert(l, f)	/* nothing */
a85 6
/* Dirhash list; recently-used entries are near the tail. */
TAILQ_HEAD(, dirhash) ufsdirhash_list;

/* Protects: ufsdirhash_list, `dh_list' field, ufs_dirhashmem. */
struct rwlock		ufsdirhash_mtx;

d145 1
a145 1
	DIRHASHLIST_LOCK();
d147 1
a147 1
		DIRHASHLIST_UNLOCK();
d154 1
a154 1
		/* Enough was freed, and list has been locked. */
d157 1
a157 1
	DIRHASHLIST_UNLOCK();
d165 1
a165 1
		DIRHASHLIST_LOCK();
d167 1
a167 1
		DIRHASHLIST_UNLOCK();
d179 1
a179 1
		if ((dh->dh_hash[i] = DIRHASH_BLKALLOC_WAITOK()) == NULL)
d234 1
a234 1
	DIRHASHLIST_LOCK();
d237 1
a237 1
	DIRHASHLIST_UNLOCK();
d244 1
a244 1
				DIRHASH_BLKFREE(dh->dh_hash[i]);
d251 1
a251 1
	DIRHASHLIST_LOCK();
d253 1
a253 1
	DIRHASHLIST_UNLOCK();
d268 2
a269 2
	DIRHASHLIST_LOCK();
	DIRHASH_LOCK(dh);
d272 2
a273 2
	DIRHASH_UNLOCK(dh);
	DIRHASHLIST_UNLOCK();
d280 1
a280 1
			DIRHASH_BLKFREE(dh->dh_hash[i]);
d290 1
a290 1
	DIRHASHLIST_LOCK();
d292 1
a292 1
	DIRHASHLIST_UNLOCK();
d328 2
a329 2
		DIRHASHLIST_LOCK();
		DIRHASH_LOCK(dh);
d344 1
a344 1
		DIRHASHLIST_UNLOCK();
d347 1
a347 1
		DIRHASH_LOCK(dh);
d350 1
a350 1
		DIRHASH_UNLOCK(dh);
d392 1
a392 1
		DIRHASH_UNLOCK(dh);
d436 1
a436 1
		DIRHASH_LOCK(dh);
d438 1
a438 1
			DIRHASH_UNLOCK(dh);
d453 1
a453 1
	DIRHASH_UNLOCK(dh);
d486 1
a486 1
	DIRHASH_LOCK(dh);
d488 1
a488 1
		DIRHASH_UNLOCK(dh);
d499 1
a499 1
		DIRHASH_UNLOCK(dh);
d506 1
a506 1
	DIRHASH_UNLOCK(dh);
d566 1
a566 1
	DIRHASH_LOCK(dh);
d568 1
a568 1
		DIRHASH_UNLOCK(dh);
d574 1
a574 1
		DIRHASH_UNLOCK(dh);
d581 1
a581 1
	DIRHASH_UNLOCK(dh);
d598 1
a598 1
	DIRHASH_LOCK(dh);
d600 1
a600 1
		DIRHASH_UNLOCK(dh);
d612 1
a612 1
		DIRHASH_UNLOCK(dh);
d627 1
a627 1
	DIRHASH_UNLOCK(dh);
d643 1
a643 1
	DIRHASH_LOCK(dh);
d645 1
a645 1
		DIRHASH_UNLOCK(dh);
d660 1
a660 1
	DIRHASH_UNLOCK(dh);
d676 1
a676 1
	DIRHASH_LOCK(dh);
d678 1
a678 1
		DIRHASH_UNLOCK(dh);
d689 1
a689 1
	DIRHASH_UNLOCK(dh);
d704 1
a704 1
	DIRHASH_LOCK(dh);
d706 1
a706 1
		DIRHASH_UNLOCK(dh);
d716 1
a716 1
		DIRHASH_UNLOCK(dh);
d726 1
a726 1
	DIRHASH_UNLOCK(dh);
d740 1
a740 1
	DIRHASH_LOCK(dh);
d742 1
a742 1
		DIRHASH_UNLOCK(dh);
d757 1
a757 1
		DIRHASH_UNLOCK(dh);
d776 1
a776 1
	DIRHASH_UNLOCK(dh);
d799 1
a799 1
	DIRHASH_LOCK(dh);
d801 1
a801 1
		DIRHASH_UNLOCK(dh);
d848 1
a848 1
	DIRHASH_UNLOCK(dh);
d997 1
a997 1
 * dirhashes. Returns zero with list locked if successful.
d1007 1
a1007 1
	DIRHASHLIST_LOCK();
d1011 1
a1011 1
			DIRHASHLIST_UNLOCK();
d1014 1
a1014 1
		DIRHASH_LOCK(dh);
d1019 2
a1020 2
			DIRHASH_UNLOCK(dh);
			DIRHASHLIST_UNLOCK();
d1037 2
a1038 2
		DIRHASH_UNLOCK(dh);
		DIRHASHLIST_UNLOCK();
d1040 1
a1040 1
			DIRHASH_BLKFREE(hash[i]);
d1045 1
a1045 1
		DIRHASHLIST_LOCK();
d1048 1
a1048 1
	/* Success; return with list locked. */
@


1.5
log
@gluk points out i missed tags
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
d72 12
d87 1
a87 4
struct pool		ufsdirhash_pool;
#define		DIRHASH_ALLOC()	pool_get(&ufsdirhash_pool, PR_WAITOK)
#define		DIRHASH_FREE(v)	pool_put(&ufsdirhash_pool, v)

a88 5
#define		DIRHASH_LOCK(l)		rw_enter_write(l, curproc)
#define		DIRHASH_UNLOCK(l)	rw_exit_write(l)
#define		mtx_assert(l, f)	/* nothing */

#define DIRHASH_ASSERT(e, m)	KASSERT((e))
d149 1
a149 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d151 1
a151 1
		DIRHASH_UNLOCK(&ufsdirhash_mtx);
d158 1
a158 1
		/* Enough was freed, and ufsdirhash_mtx has been locked. */
d161 1
a161 1
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d169 1
a169 1
		DIRHASH_LOCK(&ufsdirhash_mtx);
d171 1
a171 1
		DIRHASH_UNLOCK(&ufsdirhash_mtx);
d183 1
a183 1
		if ((dh->dh_hash[i] = DIRHASH_ALLOC()) == NULL)
d238 1
a238 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d241 1
a241 1
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d248 1
a248 1
				DIRHASH_FREE(dh->dh_hash[i]);
d255 1
a255 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d257 1
a257 1
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d272 2
a273 2
	DIRHASH_LOCK(&ufsdirhash_mtx);
	DIRHASH_LOCK(&dh->dh_mtx);
d276 2
a277 2
	DIRHASH_UNLOCK(&dh->dh_mtx);
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d284 1
a284 1
			DIRHASH_FREE(dh->dh_hash[i]);
d294 1
a294 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d296 1
a296 1
	DIRHASH_UNLOCK(&ufsdirhash_mtx);
d332 2
a333 2
		DIRHASH_LOCK(&ufsdirhash_mtx);
		DIRHASH_LOCK(&dh->dh_mtx);
d348 1
a348 1
		DIRHASH_UNLOCK(&ufsdirhash_mtx);
d351 1
a351 1
		DIRHASH_LOCK(&dh->dh_mtx);
d354 1
a354 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d396 1
a396 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d440 1
a440 1
		DIRHASH_LOCK(&dh->dh_mtx);
d442 1
a442 1
			DIRHASH_UNLOCK(&dh->dh_mtx);
d457 1
a457 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d490 1
a490 1
	DIRHASH_LOCK(&dh->dh_mtx);
d492 1
a492 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d503 1
a503 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d510 1
a510 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d570 1
a570 1
	DIRHASH_LOCK(&dh->dh_mtx);
d572 1
a572 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d578 1
a578 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d585 1
a585 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d602 1
a602 1
	DIRHASH_LOCK(&dh->dh_mtx);
d604 1
a604 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d616 1
a616 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d631 1
a631 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d647 1
a647 1
	DIRHASH_LOCK(&dh->dh_mtx);
d649 1
a649 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d664 1
a664 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d680 1
a680 1
	DIRHASH_LOCK(&dh->dh_mtx);
d682 1
a682 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d693 1
a693 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d708 1
a708 1
	DIRHASH_LOCK(&dh->dh_mtx);
d710 1
a710 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d720 1
a720 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d730 1
a730 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d744 1
a744 1
	DIRHASH_LOCK(&dh->dh_mtx);
d746 1
a746 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d761 1
a761 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d780 1
a780 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d803 1
a803 1
	DIRHASH_LOCK(&dh->dh_mtx);
d805 1
a805 1
		DIRHASH_UNLOCK(&dh->dh_mtx);
d852 1
a852 1
	DIRHASH_UNLOCK(&dh->dh_mtx);
d1001 1
a1001 1
 * dirhashes. Returns zero with ufsdirhash_mtx locked if successful.
d1011 1
a1011 1
	DIRHASH_LOCK(&ufsdirhash_mtx);
d1015 1
a1015 1
			DIRHASH_UNLOCK(&ufsdirhash_mtx);
d1018 1
a1018 1
		DIRHASH_LOCK(&dh->dh_mtx);
d1023 2
a1024 2
			DIRHASH_UNLOCK(&dh->dh_mtx);
			DIRHASH_UNLOCK(&ufsdirhash_mtx);
d1041 2
a1042 2
		DIRHASH_UNLOCK(&dh->dh_mtx);
		DIRHASH_UNLOCK(&ufsdirhash_mtx);
d1044 1
a1044 1
			DIRHASH_FREE(hash[i]);
d1049 1
a1049 1
		DIRHASH_LOCK(&ufsdirhash_mtx);
d1052 1
a1052 1
	/* Success; return with ufsdirhash_mtx locked. */
@


1.4
log
@sysctls for dirhash variables.  with a hint from miod.  ok deraadt
@
text
@d1 1
@


1.3
log
@remove FreeBSD ifdef
@
text
@d57 2
a58 2
int ufs_mindirhashsize = DIRBLKSIZ * 5;
int ufs_dirhashmaxmem = 2 * 1024 * 1024;
d60 1
a60 1
int ufs_dirhashcheck = 0;
d1059 7
@


1.2
log
@do not use MALLOC on variable sized allocations
@
text
@a73 10
#ifdef __FreeBSD__
static uma_zone_t	ufsdirhash_zone;
#define		DIRHASH_ALLOC()	uma_zalloc(ufsdirhash_zone, M_WAITOK)
#define		DIRHASH_FREE(v)	uma_zfree(ufsdirhash_zone, v)

/* Protects: ufsdirhash_list, `dh_list' field, ufs_dirhashmem. */
static struct mtx	ufsdirhash_mtx;
#define		LOCK(l)		mtx_lock(l)
#define		UNLOCK(l)	mtx_unlock(l)
#else
d79 2
a80 2
#define		LOCK(l)		rw_enter_write(l, curproc)
#define		UNLOCK(l)	rw_exit_write(l)
a83 1
#endif
d144 1
a144 1
	LOCK(&ufsdirhash_mtx);
d146 1
a146 1
		UNLOCK(&ufsdirhash_mtx);
d156 1
a156 1
	UNLOCK(&ufsdirhash_mtx);
d164 1
a164 1
		LOCK(&ufsdirhash_mtx);
d166 1
a166 1
		UNLOCK(&ufsdirhash_mtx);
a184 3
#ifdef __FreeBSD__
	mtx_init(&dh->dh_mtx, "dirhash", NULL, MTX_DEF);
#else
a185 1
#endif
d233 1
a233 1
	LOCK(&ufsdirhash_mtx);
d236 1
a236 1
	UNLOCK(&ufsdirhash_mtx);
d250 1
a250 1
	LOCK(&ufsdirhash_mtx);
d252 1
a252 1
	UNLOCK(&ufsdirhash_mtx);
d267 2
a268 2
	LOCK(&ufsdirhash_mtx);
	LOCK(&dh->dh_mtx);
d271 2
a272 2
	UNLOCK(&dh->dh_mtx);
	UNLOCK(&ufsdirhash_mtx);
a285 3
#ifdef __FreeBSD__
	mtx_destroy(&dh->dh_mtx);
#endif
d289 1
a289 1
	LOCK(&ufsdirhash_mtx);
d291 1
a291 1
	UNLOCK(&ufsdirhash_mtx);
d327 2
a328 2
		LOCK(&ufsdirhash_mtx);
		LOCK(&dh->dh_mtx);
d343 1
a343 1
		UNLOCK(&ufsdirhash_mtx);
d346 1
a346 1
		LOCK(&dh->dh_mtx);
d349 1
a349 1
		UNLOCK(&dh->dh_mtx);
d391 1
a391 1
		UNLOCK(&dh->dh_mtx);
d435 1
a435 1
		LOCK(&dh->dh_mtx);
d437 1
a437 1
			UNLOCK(&dh->dh_mtx);
d452 1
a452 1
	UNLOCK(&dh->dh_mtx);
d485 1
a485 1
	LOCK(&dh->dh_mtx);
d487 1
a487 1
		UNLOCK(&dh->dh_mtx);
d498 1
a498 1
		UNLOCK(&dh->dh_mtx);
d505 1
a505 1
	UNLOCK(&dh->dh_mtx);
d565 1
a565 1
	LOCK(&dh->dh_mtx);
d567 1
a567 1
		UNLOCK(&dh->dh_mtx);
d573 1
a573 1
		UNLOCK(&dh->dh_mtx);
d580 1
a580 1
	UNLOCK(&dh->dh_mtx);
d597 1
a597 1
	LOCK(&dh->dh_mtx);
d599 1
a599 1
		UNLOCK(&dh->dh_mtx);
d611 1
a611 1
		UNLOCK(&dh->dh_mtx);
d626 1
a626 1
	UNLOCK(&dh->dh_mtx);
d642 1
a642 1
	LOCK(&dh->dh_mtx);
d644 1
a644 1
		UNLOCK(&dh->dh_mtx);
d659 1
a659 1
	UNLOCK(&dh->dh_mtx);
d675 1
a675 1
	LOCK(&dh->dh_mtx);
d677 1
a677 1
		UNLOCK(&dh->dh_mtx);
d688 1
a688 1
	UNLOCK(&dh->dh_mtx);
d703 1
a703 1
	LOCK(&dh->dh_mtx);
d705 1
a705 1
		UNLOCK(&dh->dh_mtx);
d715 1
a715 1
		UNLOCK(&dh->dh_mtx);
d725 1
a725 1
	UNLOCK(&dh->dh_mtx);
d739 1
a739 1
	LOCK(&dh->dh_mtx);
d741 1
a741 1
		UNLOCK(&dh->dh_mtx);
d756 1
a756 1
		UNLOCK(&dh->dh_mtx);
d775 1
a775 1
	UNLOCK(&dh->dh_mtx);
d798 1
a798 1
	LOCK(&dh->dh_mtx);
d800 1
a800 1
		UNLOCK(&dh->dh_mtx);
d847 1
a847 1
	UNLOCK(&dh->dh_mtx);
d1006 1
a1006 1
	LOCK(&ufsdirhash_mtx);
d1010 1
a1010 1
			UNLOCK(&ufsdirhash_mtx);
d1013 1
a1013 1
		LOCK(&dh->dh_mtx);
d1018 2
a1019 2
			UNLOCK(&dh->dh_mtx);
			UNLOCK(&ufsdirhash_mtx);
d1036 2
a1037 2
		UNLOCK(&dh->dh_mtx);
		UNLOCK(&ufsdirhash_mtx);
d1044 1
a1044 1
		LOCK(&ufsdirhash_mtx);
a1054 5
#ifdef __FreeBSD__
	ufsdirhash_zone = uma_zcreate("DIRHASH", DH_NBLKOFF * sizeof(doff_t),
	    NULL, NULL, NULL, NULL, UMA_ALIGN_PTR, 0);
	mtx_init(&ufsdirhash_mtx, "dirhash list", NULL, MTX_DEF);
#else
a1057 1
#endif
a1064 4
#ifdef __FreeBSD__
	uma_zdestroy(ufsdirhash_zone);
	mtx_destroy(&ufsdirhash_mtx);
#else
a1065 1
#endif
@


1.1
log
@add ian dowse's dirhash code from freebsd.
by building a hash table for large directories, lookups and deletions
become about constant time.  this is an excellent improvement for dirs with
10k or more files.
some more cleanup to come, but the code works.
enabled with option UFS_DIRHASH
testing brad millert otto
@
text
@d181 1
a181 1
	MALLOC(dh->dh_hash, doff_t **, narrays * sizeof(dh->dh_hash[0]),
d184 1
a184 1
	MALLOC(dh->dh_blkfree, u_int8_t *, nblocks * sizeof(dh->dh_blkfree[0]),
d259 1
a259 1
		FREE(dh->dh_hash, M_DIRHASH);
d262 1
a262 1
		FREE(dh->dh_blkfree, M_DIRHASH);
d295 2
a296 2
		FREE(dh->dh_hash, M_DIRHASH);
		FREE(dh->dh_blkfree, M_DIRHASH);
d1058 2
a1059 2
		FREE(hash, M_DIRHASH);
		FREE(blkfree, M_DIRHASH);
@

