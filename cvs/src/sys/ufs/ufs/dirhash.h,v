head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.26
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.22
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.24
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.16
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.20
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.18
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.14
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.12
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.10
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.8
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.4
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.4.0.14
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.16
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.12
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.10
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.8
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.3.0.12
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.10
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.8
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.6
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.5
date	2010.04.25.14.43.07;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.29.23.09.45;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.02.19.34.39;	author tedu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2004.01.07.20.47.47;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.28.17.20.16;	author tedu;	state Exp;
branches;
next	;

1.3.2.1
date	2004.02.19.11.01.42;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.5
log
@dirhash cna cope with real locks (and has before), enable mutexes here.
ok deraadt
@
text
@/* $OpenBSD: dirhash.h,v 1.4 2006/04/29 23:09:45 tedu Exp $	*/
/*
 * Copyright (c) 2001 Ian Dowse.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/ufs/ufs/dirhash.h,v 1.4 2003/01/01 18:48:59 schweikh Exp $
 */

#ifndef _UFS_UFS_DIRHASH_H_
#define _UFS_UFS_DIRHASH_H_

#include <sys/mutex.h>

/*
 * For fast operations on large directories, we maintain a hash
 * that maps the file name to the offset of the directory entry within
 * the directory file.
 *
 * The hashing uses a dumb spillover to the next free slot on
 * collisions, so we must keep the utilisation low to avoid
 * long linear searches. Deleted entries that are not the last
 * in a chain must be marked DIRHASH_DEL.
 *
 * We also maintain information about free space in each block
 * to speed up creations.
 */
#define DIRHASH_EMPTY	(-1)	/* entry unused */
#define DIRHASH_DEL	(-2)	/* deleted entry; may be part of chain */

#define DIRALIGN	4
#define DH_NFSTATS	(DIRECTSIZ(MAXNAMLEN + 1) / DIRALIGN)
				 /* max DIRALIGN words in a directory entry */

/*
 * Dirhash uses a score mechanism to achieve a hybrid between a
 * least-recently-used and a least-often-used algorithm for entry
 * recycling. The score is incremented when a directory is used, and
 * decremented when the directory is a candidate for recycling. When
 * the score reaches zero, the hash is recycled. Hashes are linked
 * together on a TAILQ list, and hashes with higher scores filter
 * towards the tail (most recently used) end of the list.
 *
 * New hash entries are given an inital score of DH_SCOREINIT and are
 * placed at the most-recently-used end of the list. This helps a lot
 * in the worst-case case scenario where every directory access is
 * to a directory that is not hashed (i.e. the working set of hash
 * candidates is much larger than the configured memry limit). In this
 * case it limits the number of hash builds to 1/DH_SCOREINIT of the
 * number of accesses.
 */
#define DH_SCOREINIT	8	/* initial dh_score when dirhash built */
#define DH_SCOREMAX	64	/* max dh_score value */

/*
 * The main hash table has 2 levels. It is an array of pointers to
 * blocks of DH_NBLKOFF offsets.
 */
#define DH_BLKOFFSHIFT	8
#define DH_NBLKOFF	(1 << DH_BLKOFFSHIFT)
#define DH_BLKOFFMASK	(DH_NBLKOFF - 1)

#define DH_ENTRY(dh, slot) \
    ((dh)->dh_hash[(slot) >> DH_BLKOFFSHIFT][(slot) & DH_BLKOFFMASK])

struct dirhash {
	struct mutex dh_mtx;	/* protects all fields except dh_list */
	doff_t	**dh_hash;	/* the hash array (2-level) */
	int	dh_narrays;	/* number of entries in dh_hash */
	int	dh_hlen;	/* total slots in the 2-level hash array */
	int	dh_hused;	/* entries in use */

	/* Free space statistics. XXX assumes DIRBLKSIZ is 512. */
	u_int8_t *dh_blkfree;	/* free DIRALIGN words in each dir block */
	int	dh_nblk;	/* size of dh_blkfree array */
	int	dh_dirblks;	/* number of DIRBLKSIZ blocks in dir */
	int	dh_firstfree[DH_NFSTATS + 1]; /* first blk with N words free */

	int	dh_seqopt;	/* sequential access optimisation enabled */
	doff_t	dh_seqoff;	/* sequential access optimisation offset */

	int	dh_score;	/* access count for this dirhash */

	int	dh_onlist;	/* true if on the ufsdirhash_list chain */

	/* Protected by ufsdirhash_mtx. */
	TAILQ_ENTRY(dirhash) dh_list;	/* chain of all dirhashes */
};

extern	int ufs_mindirhashsize;
extern	int ufs_dirhashmaxmem;
extern	int ufs_dirhashmem;

/*
 * Dirhash functions.
 */
void	ufsdirhash_init(void);
void	ufsdirhash_uninit(void);
int	ufsdirhash_build(struct inode *);
doff_t	ufsdirhash_findfree(struct inode *, int, int *);
doff_t	ufsdirhash_enduseful(struct inode *);
int	ufsdirhash_lookup(struct inode *, char *, int, doff_t *, struct buf **,
	    doff_t *);
void	ufsdirhash_newblk(struct inode *, doff_t);
void	ufsdirhash_add(struct inode *, struct direct *, doff_t);
void	ufsdirhash_remove(struct inode *, struct direct *, doff_t);
void	ufsdirhash_move(struct inode *, struct direct *, doff_t, doff_t);
void	ufsdirhash_dirtrunc(struct inode *, doff_t);
void	ufsdirhash_free(struct inode *);

void	ufsdirhash_checkblock(struct inode *, char *, doff_t);

#endif /* !_UFS_UFS_DIRHASH_H_ */
@


1.4
log
@no need for using rwlocks in dirhash.  i was confused about the purpose
freebsd's mutexes served here, but they are only for smp protection.
the code is careful not to block and needs no rwlocks.
ok pedro and an assortment of testers
@
text
@d1 1
a1 1
/* $OpenBSD: dirhash.h,v 1.3 2004/02/02 19:34:39 tedu Exp $	*/
d32 1
a32 1
#include <sys/rwlock.h>
d86 1
@


1.3
log
@gluk points out i missed tags
@
text
@d1 1
a1 1
/* $OpenBSD$	*/
a85 2
	struct rwlock dh_mtx;	/* protects all fields except dh_list */

@


1.3.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@@


1.2
log
@sysctls for dirhash variables.  with a hint from miod.  ok deraadt
@
text
@d1 1
@


1.1
log
@add ian dowse's dirhash code from freebsd.
by building a hash table for large directories, lookups and deletions
become about constant time.  this is an excellent improvement for dirs with
10k or more files.
some more cleanup to come, but the code works.
enabled with option UFS_DIRHASH
testing brad millert otto
@
text
@d109 3
@

