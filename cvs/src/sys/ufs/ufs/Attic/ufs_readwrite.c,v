head	1.30;
access;
symbols
	OPENBSD_4_0:1.28.0.4
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.26.0.6
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.4
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.6
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.4
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.24
	UBC:1.22.0.2
	UBC_BASE:1.22
	OPENBSD_3_0:1.19.0.2
	OPENBSD_3_0_BASE:1.19
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.15.0.10
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.8
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.6
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.4
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.30
date	2006.10.29.00.53.37;	author thib;	state dead;
branches;
next	1.29;

1.29
date	2006.10.16.11.27.53;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.11.16.27.52;	author pedro;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.09.17.55.56;	author tholo;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.10.03.04.58;	author art;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.27.04.58.49;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.23.02.07.57;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.23.14.42.39;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	2000.11.21.21.49.57;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	99.02.26.03.35.18;	author art;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	98.08.17.19.30.30;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	98.03.01.08.07.13;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.11.06.05.59.28;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.10.06.20.21.48;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.10.06.15.27.39;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.05.30.08.35.13;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.11.04.01.55.18;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.10.29.08.03.22;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	96.07.13.21.49.19;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.07.01.06.52.24;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.06.24.03.35.04;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.47.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.21.31;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches;
next	;

1.15.6.1
date	2001.05.14.22.47.43;	author niklas;	state Exp;
branches;
next	1.15.6.2;

1.15.6.2
date	2001.07.04.11.00.57;	author niklas;	state Exp;
branches;
next	1.15.6.3;

1.15.6.3
date	2001.12.05.01.19.55;	author niklas;	state Exp;
branches;
next	1.15.6.4;

1.15.6.4
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.15.6.5;

1.15.6.5
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	;

1.22.2.1
date	2002.01.31.22.55.50;	author niklas;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.30
log
@LFS and FFS shared the same read and write vnops, through
the macro games in ufs_readwrite.c (LFS_READWRITE) now that
LFS has gone, make these functions ffs specific and move them
into ffs/ffs_vnops.c zapping ufs_readwrite.c in the process.
Also, remove lfs fields from the inode and ufsmount structs.

ok toby@@,deraadt@@,pedro@@
testing and ok krw@@
@
text
@/*	$OpenBSD: ufs_readwrite.c,v 1.29 2006/10/16 11:27:53 pedro Exp $	*/
/*	$NetBSD: ufs_readwrite.c,v 1.9 1996/05/11 18:27:57 mycroft Exp $	*/

/*
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_readwrite.c	8.11 (Berkeley) 5/8/95
 */

#ifdef LFS_READWRITE
#define	BLKSIZE(a, b, c)	blksize(a, b, c)
#define	FS			struct lfs
#define	I_FS			i_lfs
#define	READ			lfs_read
#define	READ_S			"lfs_read"
#define	WRITE			lfs_write
#define	WRITE_S			"lfs_write"
#define	fs_bsize		lfs_bsize
#define MAXFILESIZE		fs->lfs_maxfilesize
#else
#define	BLKSIZE(a, b, c)	blksize(a, b, c)
#define	FS			struct fs
#define	I_FS			i_fs
#define	READ			ffs_read
#define	READ_S			"ffs_read"
#define	WRITE			ffs_write
#define	WRITE_S			"ffs_write"
#define MAXFILESIZE		fs->fs_maxfilesize
#endif

#include <sys/event.h>

#define VN_KNOTE(vp, b) \
	KNOTE((struct klist *)&vp->v_selectinfo.vsi_selinfo.si_note, (b))

/*
 * Vnode op for reading.
 */
/* ARGSUSED */
int
READ(void *v)
{
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
	struct vnode *vp;
	struct inode *ip;
	struct uio *uio;
	FS *fs;
	struct buf *bp;
	daddr64_t lbn, nextlbn;
	off_t bytesinfile;
	long size, xfersize, blkoffset;
	mode_t mode;
	int error;

	vp = ap->a_vp;
	ip = VTOI(vp);
	mode = DIP(ip, mode);
	uio = ap->a_uio;

#ifdef DIAGNOSTIC
	if (uio->uio_rw != UIO_READ)
		panic("%s: mode", READ_S);

	if (vp->v_type == VLNK) {
		if ((int)DIP(ip, size) < vp->v_mount->mnt_maxsymlinklen ||
		    (vp->v_mount->mnt_maxsymlinklen == 0 &&
		     DIP(ip, blocks) == 0))
			panic("%s: short symlink", READ_S);
	} else if (vp->v_type != VREG && vp->v_type != VDIR)
		panic("%s: type %d", READ_S, vp->v_type);
#endif
	fs = ip->I_FS;
	if ((u_int64_t)uio->uio_offset > MAXFILESIZE)
		return (EFBIG);

	if (uio->uio_resid == 0)
		return (0);

	for (error = 0, bp = NULL; uio->uio_resid > 0; bp = NULL) {
		if ((bytesinfile = DIP(ip, size) - uio->uio_offset) <= 0)
			break;
		lbn = lblkno(fs, uio->uio_offset);
		nextlbn = lbn + 1;
		size = BLKSIZE(fs, ip, lbn);
		blkoffset = blkoff(fs, uio->uio_offset);
		xfersize = fs->fs_bsize - blkoffset;
		if (uio->uio_resid < xfersize)
			xfersize = uio->uio_resid;
		if (bytesinfile < xfersize)
			xfersize = bytesinfile;

#ifdef LFS_READWRITE
		(void)lfs_check(vp, lbn);
		error = cluster_read(vp, &ip->i_ci, DIP(ip, size), lbn, 
		    size, NOCRED, &bp);
#else
		if (lblktosize(fs, nextlbn) >= DIP(ip, size))
			error = bread(vp, lbn, size, NOCRED, &bp);
		else if (doclusterread)
			error = cluster_read(vp, &ip->i_ci,
			    DIP(ip, size), lbn, size, NOCRED, &bp);
		else if (lbn - 1 == ip->i_ci.ci_lastr) {
			int nextsize = BLKSIZE(fs, ip, nextlbn);
			error = breadn(vp, lbn,
			    size, &nextlbn, &nextsize, 1, NOCRED, &bp);
		} else
			error = bread(vp, lbn, size, NOCRED, &bp);
#endif
		if (error)
			break;
		ip->i_ci.ci_lastr = lbn;

		/*
		 * We should only get non-zero b_resid when an I/O error
		 * has occurred, which should cause us to break above.
		 * However, if the short read did not cause an error,
		 * then we want to ensure that we do not uiomove bad
		 * or uninitialized data.
		 */
		size -= bp->b_resid;
		if (size < xfersize) {
			if (size == 0)
				break;
			xfersize = size;
		}
		error = uiomove((char *)bp->b_data + blkoffset, (int)xfersize,
				uio);
		if (error)
			break;
		brelse(bp);
	}
	if (bp != NULL)
		brelse(bp);
	ip->i_flag |= IN_ACCESS;
	return (error);
}

/*
 * Vnode op for writing.
 */
int
WRITE(void *v)
{
	struct vop_write_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
	struct vnode *vp;
	struct uio *uio;
	struct inode *ip;
	FS *fs;
	struct buf *bp;
	struct proc *p;
	daddr_t lbn;
	off_t osize;
	int blkoffset, error, extended, flags, ioflag, resid, size, xfersize;

	extended = 0;
	ioflag = ap->a_ioflag;
	uio = ap->a_uio;
	vp = ap->a_vp;
	ip = VTOI(vp);

#ifdef DIAGNOSTIC
	if (uio->uio_rw != UIO_WRITE)
		panic("%s: mode", WRITE_S);
#endif

	/*
	 * If writing 0 bytes, succeed and do not change
	 * update time or file offset (standards compliance)
	 */
	if (uio->uio_resid == 0)
		return (0);

	switch (vp->v_type) {
	case VREG:
		if (ioflag & IO_APPEND)
			uio->uio_offset = DIP(ip, size);
		if ((DIP(ip, flags) & APPEND) && uio->uio_offset != DIP(ip, size))
			return (EPERM);
		/* FALLTHROUGH */
	case VLNK:
		break;
	case VDIR:
		if ((ioflag & IO_SYNC) == 0)
			panic("%s: nonsync dir write", WRITE_S);
		break;
	default:
		panic("%s: type", WRITE_S);
	}

	fs = ip->I_FS;
	if (uio->uio_offset < 0 ||
	    (u_int64_t)uio->uio_offset + uio->uio_resid > MAXFILESIZE)
		return (EFBIG);
	/*
	 * Maybe this should be above the vnode op call, but so long as
	 * file servers have no limits, I don't think it matters.
	 */
	p = uio->uio_procp;
	if (vp->v_type == VREG && p &&
	    uio->uio_offset + uio->uio_resid >
	    p->p_rlimit[RLIMIT_FSIZE].rlim_cur) {
		psignal(p, SIGXFSZ);
		return (EFBIG);
	}

	resid = uio->uio_resid;
	osize = DIP(ip, size);
	flags = ioflag & IO_SYNC ? B_SYNC : 0;

	for (error = 0; uio->uio_resid > 0;) {
		lbn = lblkno(fs, uio->uio_offset);
		blkoffset = blkoff(fs, uio->uio_offset);
		xfersize = fs->fs_bsize - blkoffset;
		if (uio->uio_resid < xfersize)
			xfersize = uio->uio_resid;
		if (fs->fs_bsize > xfersize)
			flags |= B_CLRBUF;
		else
			flags &= ~B_CLRBUF;

		if ((error = UFS_BUF_ALLOC(ip, uio->uio_offset, xfersize,
			 ap->a_cred, flags, &bp)) != 0)
			break;
		if (uio->uio_offset + xfersize > DIP(ip, size)) {
			DIP_ASSIGN(ip, size, uio->uio_offset + xfersize);
			uvm_vnp_setsize(vp, DIP(ip, size));
			extended = 1;
		}
		(void)uvm_vnp_uncache(vp);

		size = BLKSIZE(fs, ip, lbn) - bp->b_resid;
		if (size < xfersize)
			xfersize = size;

		error =
		    uiomove((char *)bp->b_data + blkoffset, xfersize, uio);

		if (error != 0)
			bzero((char *)bp->b_data + blkoffset, xfersize);

#ifdef LFS_READWRITE
		(void)VOP_BWRITE(bp);
#else
		if (ioflag & IO_SYNC)
			(void)bwrite(bp);
		else if (xfersize + blkoffset == fs->fs_bsize) {
			if (doclusterwrite)
				cluster_write(bp, &ip->i_ci, DIP(ip, size));
			else
				bawrite(bp);
		} else
			bdwrite(bp);
#endif
		if (error || xfersize == 0)
			break;
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
	}
	/*
	 * If we successfully wrote any data, and we are not the superuser
	 * we clear the setuid and setgid bits as a precaution against
	 * tampering.
	 */
	if (resid > uio->uio_resid && ap->a_cred && ap->a_cred->cr_uid != 0)
		DIP(ip, mode) &= ~(ISUID | ISGID);
	if (resid > uio->uio_resid)
		VN_KNOTE(vp, NOTE_WRITE | (extended ? NOTE_EXTEND : 0));
	if (error) {
		if (ioflag & IO_UNIT) {
			(void)UFS_TRUNCATE(ip, osize,
			    ioflag & IO_SYNC, ap->a_cred);
			uio->uio_offset -= resid - uio->uio_resid;
			uio->uio_resid = resid;
		}
	} else if (resid > uio->uio_resid && (ioflag & IO_SYNC)) {
		error = UFS_UPDATE(ip, MNT_WAIT);
	}
	return (error);
}
@


1.29
log
@Use daddr64_t for logical blocks, okay krw@@ thib@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.28 2005/12/28 20:48:18 pedro Exp $	*/
@


1.28
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.27 2005/11/11 16:27:52 pedro Exp $	*/
d79 1
a79 1
	daddr_t lbn, nextlbn;
@


1.27
log
@Use ANSI function declarations and deregister, no binary change.
Diff from Rui Reis <rui@@rui.cx>, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.26 2004/07/13 21:04:29 millert Exp $	*/
d87 1
a87 1
	mode = ip->i_ffs_mode;
d95 1
a95 1
		if ((int)ip->i_ffs_size < vp->v_mount->mnt_maxsymlinklen ||
d97 1
a97 1
		     ip->i_ffs_blocks == 0))
d110 1
a110 1
		if ((bytesinfile = ip->i_ffs_size - uio->uio_offset) <= 0)
d124 1
a124 1
		error = cluster_read(vp, &ip->i_ci, ip->i_ffs_size, lbn, 
d127 1
a127 1
		if (lblktosize(fs, nextlbn) >= ip->i_ffs_size)
d131 1
a131 1
			    ip->i_ffs_size, lbn, size, NOCRED, &bp);
d211 2
a212 2
			uio->uio_offset = ip->i_ffs_size;
		if ((ip->i_ffs_flags & APPEND) && uio->uio_offset != ip->i_ffs_size)
d242 1
a242 1
	osize = ip->i_ffs_size;
d259 3
a261 3
		if (uio->uio_offset + xfersize > ip->i_ffs_size) {
			ip->i_ffs_size = uio->uio_offset + xfersize;
			uvm_vnp_setsize(vp, ip->i_ffs_size);
d283 1
a283 1
				cluster_write(bp, &ip->i_ci, ip->i_ffs_size);
d299 1
a299 1
		ip->i_ffs_mode &= ~(ISUID | ISGID);
@


1.26
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.25 2003/06/02 23:28:23 millert Exp $	*/
d4 1
a4 1
/*-
d66 1
a66 2
READ(v)
	void *v;
d74 4
a77 4
	register struct vnode *vp;
	register struct inode *ip;
	register struct uio *uio;
	register FS *fs;
d172 1
a172 2
WRITE(v)
	void *v;
d180 4
a183 4
	register struct vnode *vp;
	register struct uio *uio;
	register struct inode *ip;
	register FS *fs;
@


1.25
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.24 2002/01/09 17:55:56 tholo Exp $	*/
d83 1
a84 1
	u_short mode;
@


1.24
log
@If a write(2) is done with a length of zero bytes, short-circuit and do not
update the modification time -- required by POSIX.  ok millert@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.23 2001/12/19 08:58:07 art Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.23
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.19 2001/06/27 04:58:49 art Exp $	*/
d206 7
@


1.22
log
@Remove LFS crud.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.21 2001/12/10 02:19:34 art Exp $	*/
d79 4
a82 6
	struct vnode *vp;
	struct inode *ip;
	struct uio *uio;
	FS *fs;
	void *win;
	vsize_t bytelen;
d88 1
d92 1
a93 1
	error = 0;
a112 18
	if (uio->uio_offset >= ip->i_ffs_size)
		goto out;

	if (vp->v_type == VREG) {
		while (uio->uio_resid > 0) {
			bytelen = min(ip->i_ffs_size - uio->uio_offset,
			    uio->uio_resid);
			if (bytelen == 0)
				break;
			win = ubc_alloc(&vp->v_uobj, uio->uio_offset,
			    &bytelen, UBC_READ);
			error = uiomove(win, bytelen, uio);
			ubc_release(win, 0);
			if (error)
			        break;
		}
		goto out;
	}
d127 5
d134 3
d143 1
d161 1
a161 1
		error = uiomove((char *)bp->b_data + blkoffset, xfersize,
a168 1
out:
d186 4
a189 4
	struct vnode *vp;
	struct uio *uio;
	struct inode *ip;
	FS *fs;
a194 4
	void *win;
	vsize_t bytelen;
	off_t oldoff;
	boolean_t rv;
d242 1
a242 21
	error = 0;

	if (vp->v_type != VREG)
		goto bcache;

	while (uio->uio_resid > 0) {
		struct uvm_object *uobj = &vp->v_uobj;
		oldoff = uio->uio_offset;
		blkoffset = blkoff(fs, uio->uio_offset);
		bytelen = min(fs->fs_bsize - blkoffset, uio->uio_resid);
 
		/*
		 * XXXUBC if file is mapped and this is the last block,
		 * process one page at a time.
		 */

		error = ufs_balloc_range(vp, uio->uio_offset, bytelen,
		    ap->a_cred, ioflag & IO_SYNC ? B_SYNC : 0);
		if (error) {
			return error;
		}
d244 1
a244 48
		win = ubc_alloc(uobj, uio->uio_offset, &bytelen, UBC_WRITE);
		error = uiomove(win, bytelen, uio);
		ubc_release(win, 0);

		/*
		 * flush what we just wrote if necessary.
		 * XXXUBC simplistic async flushing.
		 */

		if (ioflag & IO_SYNC) {
			simple_lock(&uobj->vmobjlock);
#if 1
			/*
			 * XXX 
			 * flush whole blocks in case there are deps.
			 * otherwise we can dirty and flush part of
			 * a block multiple times and the softdep code
			 * will get confused.  fixing this the right way
			 * is complicated so we'll work around it for now.
			 */
                      
			rv = uobj->pgops->pgo_flush(
			    uobj, oldoff & ~(fs->fs_bsize - 1),
			    (oldoff + bytelen + fs->fs_bsize - 1) &
			    ~(fs->fs_bsize - 1),
			    PGO_CLEANIT|PGO_SYNCIO);
#else
			rv = uobj->pgops->pgo_flush(
			    uobj, oldoff, oldoff + bytelen,
			    PGO_CLEANIT|PGO_SYNCIO);
#endif
			simple_unlock(uobj->vmobjlock);
		} else if (oldoff >> 16 != uio->uio_offset >> 16) {
			simple_lock(&uobj->vmobjlock);
			rv = uobj->pgops->pgo_flush(uobj,
			    (oldoff >> 16) << 16,
			    (uio->uio_offset >> 16) << 16, PGO_CLEANIT);
			simple_unlock(&uobj->vmobjlock);
		}
		if (error) {
			break;
		}
	}
	goto out;

bcache:
	flags = ioflag & IO_SYNC ? B_SYNC : 0;
	while (uio->uio_resid > 0) {
d263 1
d269 2
a270 1
		error = uiomove((char *)bp->b_data + blkoffset, xfersize, uio);
d275 3
d287 1
d290 1
a296 2
out:
	ip->i_flag |= IN_CHANGE | IN_UPDATE;
@


1.22.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.24 2002/01/09 17:55:56 tholo Exp $	*/
a220 7

	/*
	 * If writing 0 bytes, succeed and do not change
	 * update time or file offset (standards compliance)
	 */
	if (uio->uio_resid == 0)
		return (0);
@


1.22.2.2
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.22.2.1 2002/01/31 22:55:50 niklas Exp $	*/
a199 1
	struct genfs_node *gp;
a202 1
	struct ucred *cred;
d204 1
a204 1
	off_t osize, origoff, oldoff, preallocoff, endallocoff, nsize;
a205 2
	int bsize, aflag;
	int ubc_alloc_flags;
d208 2
a209 1
	boolean_t alloced;
a210 1
	cred = ap->a_cred;
a215 1
	gp = VTOG(vp);
a263 1
	bsize = fs->fs_bsize;
a268 23
	preallocoff = round_page(blkroundup(fs, MAX(osize, uio->uio_offset)));
	aflag = ioflag & IO_SYNC ? B_SYNC : 0;
	nsize = MAX(osize, uio->uio_offset + uio->uio_resid);
	endallocoff = nsize - blkoff(fs, nsize);

	/*
	 * if we're increasing the file size, deal with expanding
	 * the fragment if there is one.
	 */

	if (nsize > osize && lblkno(fs, osize) < NDADDR &&
	    lblkno(fs, osize) != lblkno(fs, nsize) &&
	    blkroundup(fs, osize) != osize) {
		error = ufs_balloc_range(vp, osize, blkroundup(fs, osize) -
		    osize, cred, aflag);
		if (error) {
			goto out;
		}
	}

	alloced = FALSE;
	ubc_alloc_flags = UBC_WRITE;
	origoff = uio->uio_offset;
d276 2
a277 5
		 * if we're filling in a hole, allocate the blocks now and
		 * initialize the pages first.  if we're extending the file,
		 * we can safely allocate blocks without initializing pages
		 * since the new blocks will be inaccessible until the write
		 * is complete.
d280 4
a283 20
		if (uio->uio_offset < preallocoff ||
		    uio->uio_offset >= endallocoff) {
			error = ufs_balloc_range(vp, uio->uio_offset, bytelen,
			    cred, aflag);
			if (error) {
				break;
			}
			ubc_alloc_flags &= ~UBC_FAULTBUSY;
		} else if (!alloced) {
			lockmgr(&gp->g_glock, LK_EXCLUSIVE, NULL, p);
			error = GOP_ALLOC(vp, uio->uio_offset, uio->uio_resid,
			    aflag, cred);
			lockmgr(&gp->g_glock, LK_RELEASE, NULL, p);
			if (error) {
				(void)UFS_TRUNCATE(ip, preallocoff,
				    ioflag & IO_SYNC, ap->a_cred);
				break;
			}
			alloced = TRUE;
			ubc_alloc_flags |= UBC_FAULTBUSY;
d286 1
a286 6
		/*
		 * copy the data
		 */

		win = ubc_alloc(uobj, uio->uio_offset, &bytelen,
		    ubc_alloc_flags);
a288 3
		if (error) {
			break;
		}
d291 2
a292 2
		 * update UVM's notion of the size now that we've
		 * copied the data into the vnode's pages.
d295 29
a323 2
		if (vp->v_size < uio->uio_offset) {
			uvm_vnp_setsize(vp, uio->uio_offset);
d325 2
a326 13

		/*
		 * flush what we just wrote if necessary.
		 * XXXUBC simplistic async flushing.
		 */
		if (oldoff >> 16 != uio->uio_offset >> 16) {
			simple_lock(&vp->v_uobj.vmobjlock);
			error = (vp->v_uobj.pgops->pgo_put)(&vp->v_uobj,
			    (oldoff >> 16) << 16, (uio->uio_offset >> 16) << 16,
			    PGO_CLEANIT);
			if (error) {
				break;
			}
a328 6
	if (error == 0 && ioflag & IO_SYNC) {
		simple_lock(&vp->v_uobj.vmobjlock);
		error = (vp->v_uobj.pgops->pgo_put)(&vp->v_uobj,
		    origoff & ~(bsize - 1), blkroundup(fs, uio->uio_offset),
		    PGO_CLEANIT|PGO_SYNCIO);
	}
d386 6
a391 3
		(void)UFS_TRUNCATE(ip, osize, ioflag & IO_SYNC, ap->a_cred);
		uio->uio_offset -= resid - uio->uio_resid;
		uio->uio_resid = resid;
@


1.22.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.22.2.2 2002/02/02 03:28:26 art Exp $	*/
d70 2
a71 1
READ(void *v)
d119 1
a119 1
			bytelen = MIN(ip->i_ffs_size - uio->uio_offset,
d128 1
a128 1
				break;
d148 1
a148 1
		else {
d152 2
a153 1
		}
d156 1
d171 2
a172 1
		error = uiomove((char *)bp->b_data + blkoffset, xfersize, uio);
d188 2
a189 1
WRITE(void *v)
d205 1
a205 1
	ufs_daddr_t lbn;
d207 1
a207 1
	int blkoffset, error, flags, ioflag, resid, size, xfersize;
a209 1
	int extended=0;
d212 1
a212 2
	boolean_t async;
	boolean_t usepc = FALSE;
d215 1
a266 3
	flags = ioflag & IO_SYNC ? B_SYNC : 0;
	async = vp->v_mount->mnt_flag & MNT_ASYNC;
	origoff = uio->uio_offset;
d272 1
a272 2
	usepc = vp->v_type == VREG;
	if (!usepc) {
a273 1
	}
a292 6
		if (flags & B_SYNC) {
			vp->v_size = blkroundup(fs, osize);
			simple_lock(&vp->v_interlock);
			VOP_PUTPAGES(vp, trunc_page(osize & ~(bsize - 1)),
			    round_page(vp->v_size), PGO_CLEANIT | PGO_SYNCIO);
		}
d295 1
d297 1
d299 1
a299 3
		boolean_t extending; /* if we're extending a whole block */
		off_t newoff;

d302 2
a303 2
		bytelen = MIN(fs->fs_bsize - blkoffset, uio->uio_resid);

a310 2
		extending = uio->uio_offset >= preallocoff &&
		    uio->uio_offset < endallocoff;
d312 2
a313 1
		if (!extending) {
d320 1
a320 1
		} else {
d322 1
a322 1
			error = GOP_ALLOC(vp, uio->uio_offset, bytelen,
d326 2
d330 1
d335 1
a335 1
		 * copy the data.
d338 1
a338 1
		win = ubc_alloc(&vp->v_uobj, uio->uio_offset, &bytelen,
d341 3
a343 7
		if (error && extending) {
			/*
			 * if we haven't initialized the pages yet,
			 * do it now.  it's safe to use memset here
			 * because we just mapped the pages above.
			 */
			memset(win, 0, bytelen);
a344 1
		ubc_release(win, 0);
a348 3
		 *
		 * we should update the size even when uiomove failed.
		 * otherwise ffs_truncate can't flush soft update states.
d351 2
a352 8
		newoff = oldoff + bytelen;
		if (vp->v_size < newoff) {
			uvm_vnp_setsize(vp, newoff);
			extended = 1;
		}

		if (error) {
			break;
d359 5
a363 4
		if (!async && oldoff >> 16 != uio->uio_offset >> 16) {
			simple_lock(&vp->v_interlock);
			error = VOP_PUTPAGES(vp, (oldoff >> 16) << 16,
			    (uio->uio_offset >> 16) << 16, PGO_CLEANIT);
d370 4
a373 4
		simple_lock(&vp->v_interlock);
		error = VOP_PUTPAGES(vp, trunc_page(origoff & ~(bsize - 1)),
		    round_page(blkroundup(fs, uio->uio_offset)),
		    PGO_CLEANIT | PGO_SYNCIO);
d378 1
a378 3
	simple_lock(&vp->v_interlock);
	VOP_PUTPAGES(vp, trunc_page(origoff), round_page(origoff + resid),
	    PGO_CLEANIT | PGO_FREE | PGO_SYNCIO);
d382 3
a384 1
		xfersize = MIN(fs->fs_bsize - blkoffset, uio->uio_resid);
d398 1
d400 1
a400 1
		if (xfersize > size)
d405 2
a406 10
		/*
		 * if we didn't clear the block and the uiomove failed,
		 * the buf will now contain part of some other file,
		 * so we need to invalidate it.
		 */
		if (error && (flags & B_CLRBUF) == 0) {
			bp->b_flags |= B_INVAL;
			brelse(bp);
			break;
		}
d410 6
a415 3
		else if (xfersize + blkoffset == fs->fs_bsize)
			bawrite(bp);
		else
d436 1
a436 1
		error = UFS_UPDATE(ip, UPDATE_WAIT);
@


1.21
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.20 2001/11/27 05:27:12 art Exp $	*/
a145 5
#ifdef LFS_READWRITE
		(void)lfs_check(vp, lbn);
		error = cluster_read(vp, &ip->i_ci, ip->i_ffs_size, lbn, 
		    size, NOCRED, &bp);
#else
a153 1
#endif
a354 3
#ifdef LFS_READWRITE
		(void)VOP_BWRITE(bp);
#else
a363 1
#endif
@


1.20
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.19 2001/06/27 04:58:49 art Exp $	*/
d123 1
a123 1
			win = ubc_alloc(&vp->v_uvm.u_obj, uio->uio_offset,
d269 1
d285 1
a285 2
		win = ubc_alloc(&vp->v_uvm.u_obj, uio->uio_offset, &bytelen,
				UBC_WRITE);
d295 1
a295 1
			simple_lock(&vp->v_uvm.u_obj.vmobjlock);
d306 2
a307 3
			rv = vp->v_uvm.u_obj.pgops->pgo_flush(
			    &vp->v_uvm.u_obj,
			    oldoff & ~(fs->fs_bsize - 1),
d312 2
a313 2
			rv = vp->v_uvm.u_obj.pgops->pgo_flush(
			    &vp->v_uvm.u_obj, oldoff, oldoff + bytelen,
d316 1
a316 1
			simple_unlock(&vp->v_uvm.u_obj.vmobjlock);
d318 3
a320 3
			simple_lock(&vp->v_uvm.u_obj.vmobjlock);
			rv = vp->v_uvm.u_obj.pgops->pgo_flush(
			    &vp->v_uvm.u_obj, (oldoff >> 16) << 16,
d322 1
a322 1
			simple_unlock(&vp->v_uvm.u_obj.vmobjlock);
@


1.19
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.18 2001/06/23 02:07:57 csapuntz Exp $	*/
d79 6
a84 4
	register struct vnode *vp;
	register struct inode *ip;
	register struct uio *uio;
	register FS *fs;
a89 1
	u_short mode;
a92 1
	mode = ip->i_ffs_mode;
d94 1
d114 18
a152 3
		else if (doclusterread)
			error = cluster_read(vp, &ip->i_ci,
			    ip->i_ffs_size, lbn, size, NOCRED, &bp);
d177 1
a177 1
		error = uiomove((char *)bp->b_data + blkoffset, (int)xfersize,
d185 1
d203 4
a206 4
	register struct vnode *vp;
	register struct uio *uio;
	register struct inode *ip;
	register FS *fs;
d212 4
d263 69
d333 1
a333 2

	for (error = 0; uio->uio_resid > 0;) {
a351 1
		(void)uvm_vnp_uncache(vp);
d357 1
a357 2
		error =
		    uiomove((char *)bp->b_data + blkoffset, xfersize, uio);
a376 1
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
d383 2
@


1.18
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.17 2001/02/23 14:42:39 csapuntz Exp $	*/
a259 1
#if defined(UVM)
a260 3
#else
			vnode_pager_setsize(vp, (u_long)ip->i_ffs_size);
#endif
a262 1
#if defined(UVM)
a263 3
#else
		(void)vnode_pager_uncache(vp);
#endif
@


1.17
log
@

Remove the clustering fields from the vnodes and place them in the
file system inode instead
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.16 2000/11/21 21:49:57 provos Exp $	*/
a194 1
	struct timespec ts;
d255 2
a256 2
		if ((error = VOP_BALLOC(vp, uio->uio_offset, xfersize,
					ap->a_cred, flags, &bp)) != 0)
d311 2
a312 2
			(void)VOP_TRUNCATE(vp, osize,
			    ioflag & IO_SYNC, ap->a_cred, uio->uio_procp);
d317 1
a317 2
		TIMEVAL_TO_TIMESPEC(&time, &ts);
		error = VOP_UPDATE(vp, &ts, &ts, 1);
@


1.16
log
@support for kernel events on vnodes, from jlemon@@freebsd.org, okay art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.15 1999/02/26 03:35:18 art Exp $	*/
d129 2
a130 2
		error = cluster_read(vp, ip->i_ffs_size, lbn, size, NOCRED,
		    &bp);
d135 1
a135 1
			error = cluster_read(vp,
d137 1
a137 1
		else if (lbn - 1 == vp->v_lastr) {
d146 1
a146 1
		vp->v_lastr = lbn;
d291 1
a291 1
				cluster_write(bp, ip->i_ffs_size);
@


1.15
log
@compat with uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.14 1998/08/17 19:30:30 csapuntz Exp $	*/
d60 5
d194 1
a194 1
	int blkoffset, error, flags, ioflag, resid, size, xfersize;
d197 1
d266 1
d308 2
@


1.15.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.17 2001/02/23 14:42:39 csapuntz Exp $	*/
a59 5
#include <sys/event.h>

#define VN_KNOTE(vp, b) \
	KNOTE((struct klist *)&vp->v_selectinfo.vsi_selinfo.si_note, (b))

d124 2
a125 2
		error = cluster_read(vp, &ip->i_ci, ip->i_ffs_size, lbn, 
		    size, NOCRED, &bp);
d130 1
a130 1
			error = cluster_read(vp, &ip->i_ci,
d132 1
a132 1
		else if (lbn - 1 == ip->i_ci.ci_lastr) {
d141 1
a141 1
		ip->i_ci.ci_lastr = lbn;
d189 1
a189 1
	int blkoffset, error, extended, flags, ioflag, resid, size, xfersize;
a191 1
	extended = 0;
a259 1
			extended = 1;
d284 1
a284 1
				cluster_write(bp, &ip->i_ci, ip->i_ffs_size);
a300 2
	if (resid > uio->uio_resid)
		VN_KNOTE(vp, NOTE_WRITE | (extended ? NOTE_EXTEND : 0));
@


1.15.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.15.6.1 2001/05/14 22:47:43 niklas Exp $	*/
d195 1
d256 2
a257 2
		if ((error = UFS_BUF_ALLOC(ip, uio->uio_offset, xfersize,
			 ap->a_cred, flags, &bp)) != 0)
d261 1
d263 3
d268 1
d270 3
d312 2
a313 2
			(void)UFS_TRUNCATE(ip, osize,
			    ioflag & IO_SYNC, ap->a_cred);
d318 2
a319 1
		error = UFS_UPDATE(ip, MNT_WAIT);
@


1.15.6.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 4
a82 6
	struct vnode *vp;
	struct inode *ip;
	struct uio *uio;
	FS *fs;
	void *win;
	vsize_t bytelen;
d88 1
d92 1
a93 1
	error = 0;
a112 18
	if (uio->uio_offset >= ip->i_ffs_size)
		goto out;

	if (vp->v_type == VREG) {
		while (uio->uio_resid > 0) {
			bytelen = min(ip->i_ffs_size - uio->uio_offset,
			    uio->uio_resid);
			if (bytelen == 0)
				break;
			win = ubc_alloc(&vp->v_uvm.u_obj, uio->uio_offset,
			    &bytelen, UBC_READ);
			error = uiomove(win, bytelen, uio);
			ubc_release(win, 0);
			if (error)
			        break;
		}
		goto out;
	}
d134 3
d161 1
a161 1
		error = uiomove((char *)bp->b_data + blkoffset, xfersize,
a168 1
out:
d186 4
a189 4
	struct vnode *vp;
	struct uio *uio;
	struct inode *ip;
	FS *fs;
a194 4
	void *win;
	vsize_t bytelen;
	off_t oldoff;
	boolean_t rv;
d242 1
a242 20
	error = 0;

	if (vp->v_type != VREG)
		goto bcache;

	while (uio->uio_resid > 0) {
		oldoff = uio->uio_offset;
		blkoffset = blkoff(fs, uio->uio_offset);
		bytelen = min(fs->fs_bsize - blkoffset, uio->uio_resid);
 
		/*
		 * XXXUBC if file is mapped and this is the last block,
		 * process one page at a time.
		 */

		error = ufs_balloc_range(vp, uio->uio_offset, bytelen,
		    ap->a_cred, ioflag & IO_SYNC ? B_SYNC : 0);
		if (error) {
			return error;
		}
d244 1
a244 50
		win = ubc_alloc(&vp->v_uvm.u_obj, uio->uio_offset, &bytelen,
				UBC_WRITE);
		error = uiomove(win, bytelen, uio);
		ubc_release(win, 0);

		/*
		 * flush what we just wrote if necessary.
		 * XXXUBC simplistic async flushing.
		 */

		if (ioflag & IO_SYNC) {
			simple_lock(&vp->v_uvm.u_obj.vmobjlock);
#if 1
			/*
			 * XXX 
			 * flush whole blocks in case there are deps.
			 * otherwise we can dirty and flush part of
			 * a block multiple times and the softdep code
			 * will get confused.  fixing this the right way
			 * is complicated so we'll work around it for now.
			 */
                      
			rv = vp->v_uvm.u_obj.pgops->pgo_flush(
			    &vp->v_uvm.u_obj,
			    oldoff & ~(fs->fs_bsize - 1),
			    (oldoff + bytelen + fs->fs_bsize - 1) &
			    ~(fs->fs_bsize - 1),
			    PGO_CLEANIT|PGO_SYNCIO);
#else
			rv = vp->v_uvm.u_obj.pgops->pgo_flush(
			    &vp->v_uvm.u_obj, oldoff, oldoff + bytelen,
			    PGO_CLEANIT|PGO_SYNCIO);
#endif
			simple_unlock(&vp->v_uvm.u_obj.vmobjlock);
		} else if (oldoff >> 16 != uio->uio_offset >> 16) {
			simple_lock(&vp->v_uvm.u_obj.vmobjlock);
			rv = vp->v_uvm.u_obj.pgops->pgo_flush(
			    &vp->v_uvm.u_obj, (oldoff >> 16) << 16,
			    (uio->uio_offset >> 16) << 16, PGO_CLEANIT);
			simple_unlock(&vp->v_uvm.u_obj.vmobjlock);
		}
		if (error) {
			break;
		}
	}
	goto out;

bcache:
	flags = ioflag & IO_SYNC ? B_SYNC : 0;
	while (uio->uio_resid > 0) {
d263 1
d269 2
a270 1
		error = uiomove((char *)bp->b_data + blkoffset, xfersize, uio);
d290 1
a296 2
out:
	ip->i_flag |= IN_CHANGE | IN_UPDATE;
@


1.15.6.4
log
@Merge in trunk
@
text
@d79 6
a84 4
	register struct vnode *vp;
	register struct inode *ip;
	register struct uio *uio;
	register FS *fs;
a89 1
	u_short mode;
a92 1
	mode = ip->i_ffs_mode;
d94 1
d114 18
a152 3
		else if (doclusterread)
			error = cluster_read(vp, &ip->i_ci,
			    ip->i_ffs_size, lbn, size, NOCRED, &bp);
d177 1
a177 1
		error = uiomove((char *)bp->b_data + blkoffset, (int)xfersize,
d185 1
d203 4
a206 4
	register struct vnode *vp;
	register struct uio *uio;
	register struct inode *ip;
	register FS *fs;
d212 4
a227 7
	/*
	 * If writing 0 bytes, succeed and do not change
	 * update time or file offset (standards compliance)
	 */
	if (uio->uio_resid == 0)
		return (0);

d263 69
d333 1
a333 2

	for (error = 0; uio->uio_resid > 0;) {
a351 1
		(void)uvm_vnp_uncache(vp);
d357 1
a357 2
		error =
		    uiomove((char *)bp->b_data + blkoffset, xfersize, uio);
a376 1
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
d383 2
@


1.15.6.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.15.6.4 2002/03/06 02:17:14 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.14
log
@

Fix for FFS leaking buffer cache data on segfaults during write.

Thanks to Chuck Silvers (chuq@@chuq.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.13 1998/03/01 08:07:13 niklas Exp $	*/
d255 3
d259 1
d261 3
d265 1
@


1.13
log
@GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.12 1997/11/06 05:59:28 csapuntz Exp $	*/
d264 5
a268 1
		    uiomove((char *)bp->b_data + blkoffset, (int)xfersize, uio);
@


1.12
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.11 1997/10/06 20:21:48 deraadt Exp $	*/
d270 1
a270 1
		else if (xfersize + blkoffset == fs->fs_bsize)
d275 1
a275 1
		else
@


1.11
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.9 1997/05/30 08:35:13 downsj Exp $	*/
a244 4
#ifdef LFS_READWRITE
		(void)lfs_check(vp, lbn);
		error = lfs_balloc(vp, blkoffset, xfersize, lbn, &bp);
#else
d250 2
a251 4
		error = ffs_balloc(ip,
		    lbn, blkoffset + xfersize, ap->a_cred, &bp, flags);
#endif
		if (error)
@


1.10
log
@VFS Lite2 Changes
@
text
@d245 4
d254 4
a257 2
		if ((error = VOP_BALLOC(vp, uio->uio_offset, xfersize,
					ap->a_cred, flags, &bp)) != 0)
@


1.9
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.8 1996/11/04 01:55:18 tholo Exp $	*/
a244 4
#ifdef LFS_READWRITE
		(void)lfs_check(vp, lbn);
		error = lfs_balloc(vp, blkoffset, xfersize, lbn, &bp);
#else
d250 2
a251 4
		error = ffs_balloc(ip,
		    lbn, blkoffset + xfersize, ap->a_cred, &bp, flags);
#endif
		if (error)
@


1.8
log
@Redo access time change; it should be updated on a read of 0 bytes when
more than 0 bytes were requested, but not when 0 bytes were requested
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.7 1996/10/29 08:03:22 tholo Exp $	*/
a38 5
/*
 * ext2fs support added to this module by Jason Downs, based on Godmar Back's
 * original ext2_readwrite.c.
 */

a49 11
#ifdef EXT2_READWRITE
#define BLKSIZE(a, b, c)	blksize(a, b, c)
#define FS			struct ext2_sb_info
#define I_FS			i_e2fs
#define READ			ext2_read
#define READ_S			"ext2_read"
#define WRITE			ext2_write
#define WRITE_S			"ext2_write"
#define fs_bsize		s_frag_size
#define MAXFILESIZE		((u_int64_t)0x80000000 * fs->s_frag_size - 1)
#else
a58 1
#endif
d87 1
a87 1
	mode = ip->i_mode;
d95 1
a95 1
		if ((int)ip->i_size < vp->v_mount->mnt_maxsymlinklen ||
d97 1
a97 1
		     ip->i_din.di_blocks == 0))
d110 1
a110 1
		if ((bytesinfile = ip->i_size - uio->uio_offset) <= 0)
d124 2
a125 1
		error = cluster_read(vp, ip->i_size, lbn, size, NOCRED, &bp);
d127 1
a127 5
#ifdef EXT2_READWRITE
		if (lblktosize(fs, nextlbn) > ip->i_size)
#else
		if (lblktosize(fs, nextlbn) >= ip->i_size)
#endif
d131 1
a131 1
			    ip->i_size, lbn, size, NOCRED, &bp);
d205 2
a206 2
			uio->uio_offset = ip->i_size;
		if ((ip->i_flags & APPEND) && uio->uio_offset != ip->i_size)
d236 1
a236 1
	osize = ip->i_size;
a253 3
#ifdef EXT2_READWRITE
		error = ext2_balloc(ip,
#else
a254 1
#endif
d259 3
a261 3
		if (uio->uio_offset + xfersize > ip->i_size) {
			ip->i_size = uio->uio_offset + xfersize;
			vnode_pager_setsize(vp, (u_long)ip->i_size);
d278 1
a278 1
				cluster_write(bp, ip->i_size);
d294 1
a294 1
		ip->i_mode &= ~(ISUID | ISGID);
@


1.7
log
@Do not update access time if no bytes were read
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.6 1996/07/13 21:49:19 downsj Exp $	*/
d99 1
a99 1
	int error, anyread = 0;
d123 3
a175 1
		anyread = 1;
d184 1
a184 2
	if (anyread)
		ip->i_flag |= IN_ACCESS;
@


1.6
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.5 1996/07/01 06:52:24 downsj Exp $	*/
d99 1
a99 1
	int error;
d173 1
d182 2
a183 1
	ip->i_flag |= IN_ACCESS;
@


1.5
log
@dinode.h: protect from multiple inclusion.
ufs_readwrite.c: changes for new LFS.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.4 1996/06/24 03:35:04 downsj Exp $	*/
d53 1
a53 1
#define	fs_maxfilesize		lfs_maxfilesize
d73 1
a119 1
#ifdef EXT2_READWRITE
a120 3
#else
	if ((u_int64_t)uio->uio_offset > fs->fs_maxfilesize)
#endif
a237 1
#ifdef EXT2_READWRITE
a238 3
#else
	    (u_int64_t)uio->uio_offset + uio->uio_resid > fs->fs_maxfilesize)
#endif
@


1.4
log
@ufs changes: add the notion of directory operators.

gnu/ext2fs: add the second extended filesystem.

Note that I'm commiting this now for the sake of the ufs changes; ext2fs
is not yet fully integrated into the system.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_readwrite.c,v 1.3 1996/05/22 11:47:21 deraadt Exp $	*/
d36 1
a36 1
 *	@@(#)ufs_readwrite.c	8.8 (Berkeley) 8/4/94
d45 1
a45 1
#define	BLKSIZE(a, b, c)	blksize(a)
d271 1
a271 1
		error = lfs_balloc(vp, xfersize, lbn, &bp);
@


1.3
log
@Change VOP_UPDATE() semantics:
* Make 2nd and 3rd args timespecs, not timevals.
* Consistently pass a Boolean as the 4th arg (except in LFS).
Also, fix ffs_update() and lfs_update() to actually change the nsec fields.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 5
d55 11
d74 1
d119 3
d123 1
d143 3
d147 1
d241 3
d245 1
d278 3
d282 1
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d2 1
a2 1
/*	$NetBSD: ufs_readwrite.c,v 1.8 1996/02/09 22:36:11 christos Exp $	*/
d185 1
d297 4
a300 3
	} else if (resid > uio->uio_resid && (ioflag & IO_SYNC))
		error = VOP_UPDATE(vp, (struct timeval *)&time,
		    (struct timeval *)&time, 1);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ufs_readwrite.c,v 1.7 1995/07/24 21:20:53 cgd Exp $	*/
d63 4
a66 1
READ(ap)
d72 1
a72 2
	} */ *ap;
{
d151 3
a153 2
		if (error =
		    uiomove((char *)bp->b_data + blkoffset, (int)xfersize, uio))
d166 4
a169 1
WRITE(ap)
d175 1
a175 2
	} */ *ap;
{
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

