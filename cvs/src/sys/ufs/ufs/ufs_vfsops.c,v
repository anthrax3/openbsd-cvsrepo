head	1.19;
access;
symbols
	OPENBSD_6_2:1.19.0.8
	OPENBSD_6_2_BASE:1.19
	OPENBSD_6_1:1.19.0.10
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.6
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.4
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.17.0.8
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.6
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.16.0.8
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.20
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.18
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.14
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.16
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.12
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.10
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.8
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.6
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.10
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.8
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.03.14.03.38.53;	author jsg;	state Exp;
branches;
next	1.18;
commitid	p4LJxGKbi0BU2cG6;

1.18
date	2014.09.14.14.17.27;	author jsg;	state Exp;
branches;
next	1.17;
commitid	uzzBR7hz9ncd4O6G;

1.17
date	2013.05.01.14.43.09;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.04.11.21.40;	author pedro;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.13;

1.13
date	2005.11.11.16.27.52;	author pedro;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.03.20.14.03;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.28.17.20.16;	author tedu;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.22.20.51.24;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.21.21.23.56;	author csapuntz;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.02.07.04.57.19;	author assar;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	97.11.06.05.59.28;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.20.21.49;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.15.27.39;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	97.05.30.08.35.15;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.21.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2001.12.05.01.19.55;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2004.02.19.11.01.43;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: ufs_vfsops.c,v 1.18 2014/09/14 14:17:27 jsg Exp $	*/
/*	$NetBSD: ufs_vfsops.c,v 1.4 1996/02/09 22:36:12 christos Exp $	*/

/*
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_vfsops.c	8.4 (Berkeley) 4/16/94
 */

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <sys/specdev.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>
#ifdef UFS_DIRHASH
#include <ufs/ufs/dir.h>
#include <ufs/ufs/dirhash.h>
#endif

/*
 * Make a filesystem operational.
 * Nothing to do at the moment.
 */
/* ARGSUSED */
int
ufs_start(struct mount *mp, int flags, struct proc *p)
{
	return (0);
}

/*
 * Return the root of a filesystem.
 */
int
ufs_root(struct mount *mp, struct vnode **vpp)
{
	struct vnode *nvp;
	int error;

	if ((error = VFS_VGET(mp, ROOTINO, &nvp)) != 0)
		return (error);
	*vpp = nvp;
	return (0);
}

/*
 * Verify a remote client has export rights and return these rights via.
 * exflagsp and credanonp.
 */
int
ufs_check_export(struct mount *mp, struct mbuf *nam, int *exflagsp,
    struct ucred **credanonp) 
{
	struct netcred *np;
	struct ufsmount *ump = VFSTOUFS(mp);

	/*
	 * Get the export permission structure for this <mp, client> tuple.
	 */
	np = vfs_export_lookup(mp, &ump->um_export, nam);
	if (np == NULL)
		return (EACCES);

	*exflagsp = np->netc_exflags;
	*credanonp = &np->netc_anon;
	return (0);
}

/*
 * Initialize UFS file systems, done only once.
 */
int
ufs_init(struct vfsconf *vfsp)
{
	static int done;

	if (done)
		return (0);
	done = 1;
	ufs_ihashinit();
	ufs_quota_init();
#ifdef UFS_DIRHASH
	ufsdirhash_init();
#endif

	return (0);
}

/*
 * This is the generic part of fhtovp called after the underlying
 * filesystem has validated the file handle.
 */
int
ufs_fhtovp(struct mount *mp, struct ufid *ufhp, struct vnode **vpp)
{
	struct inode *ip;
	struct vnode *nvp;
	int error;

	if ((error = VFS_VGET(mp, ufhp->ufid_ino, &nvp)) != 0) {
		*vpp = NULLVP;
		return (error);
	}
	ip = VTOI(nvp);
	if (DIP(ip, mode) == 0 || DIP(ip, gen) != ufhp->ufid_gen) {
		vput(nvp);
		*vpp = NULLVP;
		return (ESTALE);
	}
	*vpp = nvp;
	return (0);
}
@


1.18
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.17 2013/05/01 14:43:09 millert Exp $	*/
a42 1
#include <sys/buf.h>
@


1.17
log
@Remove useless cast of ROOT_INFO to ino_t.  OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.16 2011/07/04 20:35:35 deraadt Exp $	*/
a42 1
#include <sys/proc.h>
@


1.16
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.15 2006/04/04 11:21:40 pedro Exp $	*/
d78 1
a78 1
	if ((error = VFS_VGET(mp, (ino_t)ROOTINO, &nvp)) != 0)
@


1.15
log
@Fix a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.14 2005/12/28 20:48:18 pedro Exp $	*/
d47 1
a47 2

#include <miscfs/specfs/specdev.h>
@


1.14
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.13 2005/11/11 16:27:52 pedro Exp $	*/
d109 1
a109 1
 * Initial UFS filesystems, done only once.
@


1.13
log
@Use ANSI function declarations and deregister, no binary change.
Diff from Rui Reis <rui@@rui.cx>, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.12 2005/07/03 20:14:03 drahn Exp $	*/
d144 1
a144 1
	if (ip->i_ffs_mode == 0 || ip->i_ffs_gen != ufhp->ufid_gen) {
@


1.12
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.11 2003/12/28 17:20:16 tedu Exp $	*/
d65 1
a65 4
ufs_start(mp, flags, p)
	struct mount *mp;
	int flags;
	struct proc *p;
a66 1

d74 1
a74 3
ufs_root(mp, vpp)
	struct mount *mp;
	struct vnode **vpp;
d90 2
a91 5
ufs_check_export(mp, nam, exflagsp, credanonp)
	register struct mount *mp;
	struct mbuf *nam;
	int *exflagsp;
	struct ucred **credanonp;
d93 2
a94 2
	register struct netcred *np;
	register struct ufsmount *ump = VFSTOUFS(mp);
d112 1
a112 2
ufs_init(vfsp)
	struct vfsconf *vfsp;
d133 1
a133 4
ufs_fhtovp(mp, ufhp, vpp)
	register struct mount *mp;
	struct ufid *ufhp;
	struct vnode **vpp;
d135 1
a135 1
	register struct inode *ip;
@


1.11
log
@add ian dowse's dirhash code from freebsd.
by building a hash table for large directories, lookups and deletions
become about constant time.  this is an excellent improvement for dirs with
10k or more files.
some more cleanup to come, but the code works.
enabled with option UFS_DIRHASH
testing brad millert otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.10 2003/06/02 23:28:23 millert Exp $	*/
a49 1
#include <ufs/ufs/extattr.h>
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.9 2002/02/22 20:51:24 drahn Exp $	*/
d55 4
d132 3
@


1.9
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.8 2001/11/21 21:23:56 csapuntz Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@Don't use #define QUOTA - use stub file instead

Pass over the quota code in ufs/. Make code paths clearer. Clean up some names.
Move all code that manipulates quotas directly into ufs_quota.c

Use vfs_mount_foreach_vnode to traverse list of vnodes in mountpoint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.7 2000/02/07 04:57:19 assar Exp $	*/
d54 1
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.8 2001/11/21 21:23:56 csapuntz Exp $	*/
a53 1
#include <ufs/ufs/extattr.h>
@


1.7
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.6 1997/11/06 05:59:28 csapuntz Exp $	*/
a91 78
 * Do operations associated with quotas
 */
int
ufs_quotactl(mp, cmds, uid, arg, p)
	struct mount *mp;
	int cmds;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
{

#ifndef QUOTA
	return (EOPNOTSUPP);
#else
	int cmd, type, error;

	if (uid == -1)
		uid = p->p_cred->p_ruid;
	cmd = cmds >> SUBCMDSHIFT;

	switch (cmd) {
	case Q_SYNC:
		break;
	case Q_GETQUOTA:
		if (uid == p->p_cred->p_ruid)
			break;
		/* fall through */
	default:
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
			return (error);
	}

	type = cmds & SUBCMDMASK;
	if ((u_int)type >= MAXQUOTAS)
		return (EINVAL);

	if (vfs_busy(mp, LK_NOWAIT, 0, p))
		return (0);
 

	switch (cmd) {

	case Q_QUOTAON:
		error = quotaon(p, mp, type, arg);
		break;

	case Q_QUOTAOFF:
		error = quotaoff(p, mp, type);
		break;

	case Q_SETQUOTA:
		error = setquota(mp, uid, type, arg) ;
		break;

	case Q_SETUSE:
		error = setuse(mp, uid, type, arg);
		break;

	case Q_GETQUOTA:
		error = getquota(mp, uid, type, arg);
		break;

	case Q_SYNC:
		error = qsync(mp);
		break;

	default:
		error = EINVAL;
		break;
	}

	vfs_unbusy(mp, p);
	return (error);
#endif
}


/*
d130 2
a131 3
#ifdef QUOTA
	dqinit();
#endif
@


1.7.2.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 78
d208 3
a210 2
	ufs_quota_init();

@


1.7.2.2
log
@Merge in trunk
@
text
@a53 1
#include <ufs/ufs/extattr.h>
@


1.7.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.7.2.2 2002/03/06 02:17:14 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a54 4
#ifdef UFS_DIRHASH
#include <ufs/ufs/dir.h>
#include <ufs/ufs/dirhash.h>
#endif
a127 3
#ifdef UFS_DIRHASH
	ufsdirhash_init();
#endif
@


1.6
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.5 1997/10/06 20:21:49 deraadt Exp $	*/
d170 26
a216 3
 *
 * Verify that a host should have access to a filesystem, and if so
 * return a vnode for the presented file handle.
d219 1
a219 1
ufs_check_export(mp, ufhp, nam, vpp, exflagsp, credanonp)
a221 1
	struct mbuf *nam;
a222 2
	int *exflagsp;
	struct ucred **credanonp;
a224 2
	register struct netcred *np;
	register struct ufsmount *ump = VFSTOUFS(mp);
a227 7
	/*
	 * Get the export permission structure for this <mp, client> tuple.
	 */
	np = vfs_export_lookup(mp, &ump->um_export, nam);
	if (np == NULL)
		return (EACCES);

a238 2
	*exflagsp = np->netc_exflags;
	*credanonp = &np->netc_anon;
@


1.5
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.3 1997/05/30 08:35:15 downsj Exp $	*/
d128 4
d135 2
a136 1
		return (quotaon(p, mp, type, arg));
a138 2
		if (vfs_busy(mp))
			return (0);
d140 1
a140 2
		vfs_unbusy(mp);
		return (error);
d143 2
a144 1
		return (setquota(mp, uid, type, arg));
d147 2
a148 1
		return (setuse(mp, uid, type, arg));
d151 2
a152 1
		return (getquota(mp, uid, type, arg));
a154 2
		if (vfs_busy(mp))
			return (0);
d156 1
a156 2
		vfs_unbusy(mp);
		return (error);
d159 2
a160 1
		return (EINVAL);
d162 3
a164 1
	/* NOTREACHED */
d166 20
@


1.4
log
@VFS Lite2 Changes
@
text
@a127 4
	if (vfs_busy(mp, LK_NOWAIT, 0, p))
		return (0);
 

d131 1
a131 2
		error = quotaon(p, mp, type, arg);
		break;
d134 2
d137 2
a138 1
		break;
d141 1
a141 2
		error = setquota(mp, uid, type, arg) ;
		break;
d144 1
a144 2
		error = setuse(mp, uid, type, arg);
		break;
d147 1
a147 2
		error = getquota(mp, uid, type, arg);
		break;
d150 2
d153 2
a154 1
		break;
d157 1
a157 2
		error = EINVAL;
		break;
d159 1
a159 22

	vfs_unbusy(mp, p);
	return (error);
#endif
}


/*
 * Initial UFS filesystems, done only once.
 */
int
ufs_init(vfsp)
	struct vfsconf *vfsp;
{
	static int done;

	if (done)
		return (0);
	done = 1;
	ufs_ihashinit();
#ifdef QUOTA
	dqinit();
a160 1
	return (0);
@


1.3
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_vfsops.c,v 1.2 1996/02/27 07:21:32 niklas Exp $	*/
d128 4
d135 2
a136 1
		return (quotaon(p, mp, type, arg));
a138 2
		if (vfs_busy(mp))
			return (0);
d140 1
a140 2
		vfs_unbusy(mp);
		return (error);
d143 2
a144 1
		return (setquota(mp, uid, type, arg));
d147 2
a148 1
		return (setuse(mp, uid, type, arg));
d151 2
a152 1
		return (getquota(mp, uid, type, arg));
a154 2
		if (vfs_busy(mp))
			return (0);
d156 1
a156 2
		vfs_unbusy(mp);
		return (error);
d159 2
a160 1
		return (EINVAL);
d162 3
a164 1
	/* NOTREACHED */
d166 20
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d197 1
a197 1
	if (ip->i_mode == 0 || ip->i_gen != ufhp->ufid_gen) {
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ufs_vfsops.c,v 1.3 1995/05/10 18:00:45 cgd Exp $	*/
d85 1
a85 1
	if (error = VFS_VGET(mp, (ino_t)ROOTINO, &nvp))
a101 1
	int cmd, type, error;
d106 2
d120 1
a120 1
		if (error = suser(p->p_ucred, &p->p_acflag))
d192 1
a192 1
	if (error = VFS_VGET(mp, ufhp->ufid_ino, &nvp)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
