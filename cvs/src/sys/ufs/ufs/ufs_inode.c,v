head	1.42;
access;
symbols
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.42.0.2
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.38.0.20
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.16
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.38.0.14
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.12
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.10
	OPENBSD_5_0:1.38.0.8
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.6
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.4
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.37.0.12
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.8
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.37.0.6
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.4
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.35.0.2
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.34.0.4
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.30.0.2
	OPENBSD_3_8_BASE:1.30
	OPENBSD_3_7:1.26.0.2
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.16
	OPENBSD_2_8:1.7.0.14
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.12
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.10
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.41;
commitid	gAjwyca5TfuoJAhn;

1.41
date	2015.03.14.03.38.53;	author jsg;	state Exp;
branches;
next	1.40;
commitid	p4LJxGKbi0BU2cG6;

1.40
date	2014.09.14.14.17.27;	author jsg;	state Exp;
branches;
next	1.39;
commitid	uzzBR7hz9ncd4O6G;

1.39
date	2014.03.19.04.17.33;	author guenther;	state Exp;
branches;
next	1.38;

1.38
date	2009.08.14.20.55.05;	author jasper;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.04.11.16.08.50;	author thib;	state Exp;
branches;
next	1.35;

1.35
date	2006.12.28.20.33.24;	author thib;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.09.12.43.17;	author pedro;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.32;

1.32
date	2005.12.17.13.56.01;	author pedro;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.10.22.01.14;	author pedro;	state Exp;
branches;
next	1.30;

1.30
date	2005.07.03.20.14.03;	author drahn;	state Exp;
branches;
next	1.29;

1.29
date	2005.06.10.17.37.41;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.28.17.56.28;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.23.21.16.28;	author pedro;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.17.18.07.37;	author jfb;	state Exp;
branches;
next	1.25;

1.25
date	2005.02.17.11.46.39;	author pedro;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.06.04.24.55;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2004.10.10.14.16.59;	author pedro;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.20.03.44.06;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.28.17.20.16;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.10.19.35.29;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.22.20.37.46;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.10.04.45.32;	author art;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.30.00.32.58;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.28.00.45.40;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.21.21.23.56;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.16.02.56.48;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.23.02.07.57;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.59.26;	author csapuntz;	state Exp;
branches
	1.7.10.1;
next	1.6;

1.6
date	97.10.06.20.21.46;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.27.37;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.05.30.08.35.04;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.47.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.21.27;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches;
next	;

1.7.10.1
date	2001.07.04.11.00.56;	author niklas;	state Exp;
branches;
next	1.7.10.2;

1.7.10.2
date	2001.10.31.03.32.14;	author nate;	state Exp;
branches;
next	1.7.10.3;

1.7.10.3
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.7.10.4;

1.7.10.4
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.7.10.5;

1.7.10.5
date	2003.03.28.00.08.48;	author niklas;	state Exp;
branches;
next	1.7.10.6;

1.7.10.6
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.7.10.7;

1.7.10.7
date	2004.02.19.11.01.43;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2003.05.19.22.38.11;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@/*	$OpenBSD: ufs_inode.c,v 1.41 2015/03/14 03:38:53 jsg Exp $	*/
/*	$NetBSD: ufs_inode.c,v 1.7 1996/05/11 18:27:52 mycroft Exp $	*/

/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_inode.c	8.7 (Berkeley) 7/22/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/malloc.h>
#include <sys/namei.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>
#ifdef UFS_DIRHASH
#include <ufs/ufs/dir.h>
#include <ufs/ufs/dirhash.h>
#endif

/*
 * Last reference to an inode.  If necessary, write or delete it.
 */
int
ufs_inactive(void *v)
{
	struct vop_inactive_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct proc *p = ap->a_p;
	mode_t mode;
	int error = 0;
#ifdef DIAGNOSTIC
	extern int prtactive;

	if (prtactive && vp->v_usecount != 0)
		vprint("ufs_inactive: pushing active", vp);
#endif

	/*
	 * Ignore inodes related to stale file handles.
	 */
	if (ip->i_din1 == NULL || DIP(ip, mode) == 0)
		goto out;

	if (DIP(ip, nlink) <= 0 && (vp->v_mount->mnt_flag & MNT_RDONLY) == 0) {
		if (getinoquota(ip) == 0)
			(void)ufs_quota_free_inode(ip, NOCRED);

		error = UFS_TRUNCATE(ip, (off_t)0, 0, NOCRED);

		DIP_ASSIGN(ip, rdev, 0);
		mode = DIP(ip, mode);
		DIP_ASSIGN(ip, mode, 0);
		ip->i_flag |= IN_CHANGE | IN_UPDATE;

		/*
		 * Setting the mode to zero needs to wait for the inode to be
		 * written just as does a change to the link count. So, rather
		 * than creating a new entry point to do the same thing, we
		 * just use softdep_change_linkcnt(). Also, we can't let
		 * softdep co-opt us to help on its worklist, as we may end up
		 * trying to recycle vnodes and getting to this same point a
		 * couple of times, blowing the kernel stack. However, this
		 * could be optimized by checking if we are coming from
		 * vrele(), vput() or vclean() (by checking for VXLOCK) and
		 * just avoiding the co-opt to happen in the last case.
		 */
		if (DOINGSOFTDEP(vp))
			softdep_change_linkcnt(ip, 1);

		UFS_INODE_FREE(ip, ip->i_number, mode);
	}

	if (ip->i_flag & (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) {
		UFS_UPDATE(ip, 0);
	}
out:
	VOP_UNLOCK(vp, p);

	/*
	 * If we are done with the inode, reclaim it
	 * so that it can be reused immediately.
	 */
	if (ip->i_din1 == NULL || DIP(ip, mode) == 0)
		vrecycle(vp, p);

	return (error);
}

/*
 * Reclaim an inode so that it can be used for other purposes.
 */
int
ufs_reclaim(struct vnode *vp, struct proc *p)
{
	struct inode *ip;
#ifdef DIAGNOSTIC
	extern int prtactive;

	if (prtactive && vp->v_usecount != 0)
		vprint("ufs_reclaim: pushing active", vp);
#endif

	ip = VTOI(vp);

	/*
	 * Stop deferring timestamp writes
	 */
	if (ip->i_flag & IN_LAZYMOD) {
		ip->i_flag |= IN_MODIFIED;
		UFS_UPDATE(ip, 0);
	}

	/*
	 * Remove the inode from its hash chain.
	 */
	ufs_ihashrem(ip);
	/*
	 * Purge old data structures associated with the inode.
	 */
	cache_purge(vp);

	if (ip->i_devvp) {
		vrele(ip->i_devvp);
	}
#ifdef UFS_DIRHASH
	if (ip->i_dirhash != NULL)
		ufsdirhash_free(ip);
#endif
	ufs_quota_delete(ip);
	return (0);
}
@


1.41
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.40 2014/09/14 14:17:27 jsg Exp $	*/
d114 1
a114 1
	VOP_UNLOCK(vp, 0, p);
@


1.40
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.39 2014/03/19 04:17:33 guenther Exp $	*/
a43 1
#include <sys/kernel.h>
@


1.39
log
@Pull in FreeBSD r37363 and r37887:
--
Sync timestamp changes for inodes of special files to disk as late
as possible (when the inode is reclaimed).  Temporarily only do
this if option UFS_LAZYMOD configured and softupdates aren't enabled.
UFS_LAZYMOD is intentionally left out of /sys/conf/options.

This is mainly to avoid almost useless disk i/o on battery powered
machines.  It's silly to write to disk (on the next sync or when the
inode becomes inactive) just because someone hit a key or something
wrote to the screen or /dev/null.
--
Made lazy syncing of timestamps for special files non-optional.
--

Also, include support in 'pstat -v' to display the IN_LAZYMOD flag.

ok tedu@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.38 2009/08/14 20:55:05 jasper Exp $	*/
a41 1
#include <sys/proc.h>
@


1.38
log
@- fix function name in vprint()

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.37 2007/06/01 23:47:57 deraadt Exp $	*/
d142 10
a154 1
	ip = VTOI(vp);
@


1.37
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.36 2007/04/11 16:08:50 thib Exp $	*/
d74 1
a74 1
		vprint("ffs_inactive: pushing active", vp);
@


1.36
log
@Remove the simplelock argument from vrecycle();

ok pedro@@, sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.35 2006/12/28 20:33:24 thib Exp $	*/
d64 1
a64 4
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
@


1.35
log
@Zap nextgennumber, unused since LFS went up into the attic.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.34 2006/01/09 12:43:17 pedro Exp $	*/
d126 1
a126 1
		vrecycle(vp, NULL, p);
@


1.34
log
@Put vprint() under DIAGNOSTIC, as to save space in generated ramdisks.
Inspiration from miod@@, okay deraadt@@. Tested on i386, macppc and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.33 2005/12/28 20:48:18 pedro Exp $	*/
a56 2

u_long	nextgennumber;		/* Next generation number to assign. */
@


1.33
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.32 2005/12/17 13:56:01 pedro Exp $	*/
d75 1
d80 1
d140 1
d145 2
@


1.32
log
@Remove the 'on disk' inode (dinode) from the 'in memory' inode in UFS.
Instead of having the dinode inside the inode structure itself, we now
have just a pointer to it, and use a separate pool to allocate dinodes
as needed. Inspiration from FreeBSD, various testing for a while, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.31 2005/11/10 22:01:14 pedro Exp $	*/
d83 1
a83 1
	if (ip->i_din1 == NULL || ip->i_ffs_mode == 0)
d86 1
a86 1
	if (ip->i_ffs_nlink <= 0 && (vp->v_mount->mnt_flag & MNT_RDONLY) == 0) {
d92 3
a94 3
		ip->i_ffs_rdev = 0;
		mode = ip->i_ffs_mode;
		ip->i_ffs_mode = 0;
d125 1
a125 1
	if (ip->i_din1 == NULL || ip->i_ffs_mode == 0)
@


1.31
log
@Use ANSI function declarations and deregister, no binary change.
Diff from Rui Reis <rui@@rui.cx>, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.30 2005/07/03 20:14:03 drahn Exp $	*/
d83 1
a83 1
	if (ip->i_ffs_mode == 0)
d125 1
a125 1
	if (ip->i_ffs_mode == 0)
@


1.30
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.29 2005/06/10 17:37:41 pedro Exp $	*/
d64 1
a64 2
ufs_inactive(v)
	void *v;
d135 1
a135 3
ufs_reclaim(vp, p)
	register struct vnode *vp;
	struct proc *p;
d137 1
a137 1
	register struct inode *ip;
@


1.29
log
@Tweak softdep_change_linkcnt() so we can specify whether we're willing
to be co-opted by softdep or not, and use this new interface to inform
softdep in ufs_inactive() that the inode mode has changed.

We don't want to be co-opted there as that might lead to undesired
circular dependencies such as a vput() depending on another vput() to
complete, or a process that is trying to free up a vnode being blocked
trying to acquire a new vnode.

Okay tedu@@ deraadt@@, thanks to all those who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.28 2005/05/28 17:56:28 art Exp $	*/
a48 1
#include <ufs/ufs/extattr.h>
@


1.28
log
@Disable the recently enabled optimization since it seems to cause a
loop in the kernel that makes us overwrite the stack and anything else
we might run into.

beck@@ pedro@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.27 2005/05/23 21:16:28 pedro Exp $	*/
a98 1
#if 0
d103 7
a109 1
		 * just use softdep_change_linkcnt().
d112 1
a112 2
			softdep_change_linkcnt(ip);
#endif
@


1.27
log
@re-enable softdep notification of inode mode change,
talked over with marius@@ and tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.26 2005/02/17 18:07:37 jfb Exp $	*/
d99 1
d108 1
@


1.26
log
@miscellaneous typo fixes:
- sturct -> struct (spotted by pedro)
- elimination of consecutive 'the' words

ok jmc@@, henning@@, krw@@, robert@@, some whining by jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.25 2005/02/17 11:46:39 pedro Exp $	*/
a98 5
#if 0
		/*
		 * disabled.  this can wrap around to the point getnewvnode
		 * will try to recycle us, causing a lockmgr panic.
		 */
a106 1
#endif
@


1.25
log
@Remove dead code that has moved to ufs_vfsops.c long ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.24 2004/11/06 04:24:55 tedu Exp $	*/
d70 1
a70 1
		sturct proc *a_p;
@


1.24
log
@disable changing softdep linkcnt (last commit).  it can cause a loop that
locks the vnode twice, and we can't fix it right now.  discussed with pedro.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.23 2004/10/10 14:16:59 pedro Exp $	*/
a60 15
#if 0
void
ufs_init()
{
	static int done = 0;

	if (done)
		return;
	done = 1;
	ufs_ihashinit();
	ufs_quota_init();

	return;
}
#endif
@


1.23
log
@inform softdep of inode mode change, from freebsd. while i'm at it,
check for ufs_truncate failure and do a bit of the usual null for
pointers, spacing stuff. ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.22 2004/07/13 21:04:29 millert Exp $	*/
d114 5
d127 1
@


1.22
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.21 2004/01/20 03:44:06 tedu Exp $	*/
d102 1
d107 2
a108 1
		(void) UFS_TRUNCATE(ip, (off_t)0, 0, NOCRED);
d113 10
d125 1
d131 1
d137 2
a138 1
		vrecycle(vp, (struct simplelock *)0, p);
d164 1
@


1.21
log
@some pieces of ufs2.  help testing otto sturm
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.20 2003/12/28 17:20:16 tedu Exp $	*/
d90 2
a91 1
	int mode, error = 0;
@


1.20
log
@add ian dowse's dirhash code from freebsd.
by building a hash table for large directories, lookups and deletions
become about constant time.  this is an excellent improvement for dirs with
10k or more files.
some more cleanup to come, but the code works.
enabled with option UFS_DIRHASH
testing brad millert otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.19 2003/06/02 23:28:23 millert Exp $	*/
a149 1
		ip->i_devvp = 0;
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.18 2003/03/10 19:35:29 tedu Exp $	*/
d54 4
d152 4
@


1.18
log
@fix really old typo that prevented inode quotas from ever working.

help testing and eyeballing henric tdeval miod
ok costa deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.17 2002/02/22 20:37:46 drahn Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.16 2001/12/19 08:58:07 art Exp $	*/
d102 1
a102 1
		if (getinoquota(ip) != 0)
@


1.16
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.10 2001/11/21 21:23:56 csapuntz Exp $	*/
d53 1
@


1.15
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.14 2001/12/10 02:19:34 art Exp $	*/
d104 1
a104 3
		if (ip->i_ffs_size != 0) {
			(void) UFS_TRUNCATE(ip, (off_t)0, 0, NOCRED);
		}
a152 150
}

/*
 * allocate a range of blocks in a file.
 * after this function returns, any page entirely contained within the range
 * will map to invalid data and thus must be overwritten before it is made
 * accessible to others.
 */

int
ufs_balloc_range(vp, off, len, cred, flags)
	struct vnode *vp;
	off_t off, len;
	struct ucred *cred;
	int flags;
{
	off_t oldeof, neweof, oldeob, neweob, oldpagestart, pagestart;
	struct uvm_object *uobj;
	struct genfs_node *gp = VTOG(vp);
	int i, delta, error, npages1, npages2;
	int bshift = vp->v_mount->mnt_fs_bshift;
	int bsize = 1 << bshift;
	int ppb = MAX(bsize >> PAGE_SHIFT, 1);
	struct vm_page *pgs1[ppb], *pgs2[ppb];
	UVMHIST_FUNC("ufs_balloc_range"); UVMHIST_CALLED(ubchist);
	UVMHIST_LOG(ubchist, "vp %p off 0x%x len 0x%x u_size 0x%x",
		    vp, off, len, vp->v_size);

	oldeof = vp->v_size;
	GOP_SIZE(vp, oldeof, &oldeob);

	neweof = MAX(vp->v_size, off + len);
	GOP_SIZE(vp, neweof, &neweob);

	error = 0;
	uobj = &vp->v_uobj;
	pgs1[0] = pgs2[0] = NULL;

	/*
	 * if the last block in the file is not a full block (ie. it is a
	 * fragment), and this allocation is causing the fragment to change
	 * size (either to expand the fragment or promote it to a full block),
	 * cache the old last block (at its new size).
	 */

	oldpagestart = trunc_page(oldeof) & ~(bsize - 1);
	if ((oldeob & (bsize - 1)) != 0 && oldeob != neweob) {
		npages1 = MIN(ppb, (round_page(neweob) - oldpagestart) >>
			      PAGE_SHIFT);
		memset(pgs1, 0, npages1 * sizeof(struct vm_page *));
		simple_lock(&uobj->vmobjlock);
		error = VOP_GETPAGES(vp, oldpagestart, pgs1, &npages1,
		    0, VM_PROT_READ, 0, PGO_SYNCIO|PGO_PASTEOF);
		if (error) {
			goto out;
		}
		simple_lock(&uobj->vmobjlock);
		uvm_lock_pageq();
		for (i = 0; i < npages1; i++) {
			UVMHIST_LOG(ubchist, "got pgs1[%d] %p", i, pgs1[i],0,0);
			KASSERT((pgs1[i]->flags & PG_RELEASED) == 0);
			pgs1[i]->flags &= ~PG_CLEAN;
			uvm_pageactivate(pgs1[i]);
		}
		uvm_unlock_pageq();
		simple_unlock(&uobj->vmobjlock);
	}

	/*
	 * cache the new range as well.  this will create zeroed pages
	 * where the new block will be and keep them locked until the
	 * new block is allocated, so there will be no window where
	 * the old contents of the new block is visible to racing threads.
	 */

	pagestart = trunc_page(off) & ~(bsize - 1);
	if (pagestart != oldpagestart || pgs1[0] == NULL) {
		npages2 = MIN(ppb, (round_page(neweob) - pagestart) >>
			      PAGE_SHIFT);
		memset(pgs2, 0, npages2 * sizeof(struct vm_page *));
		simple_lock(&uobj->vmobjlock);
		error = VOP_GETPAGES(vp, pagestart, pgs2, &npages2, 0,
		    VM_PROT_READ, 0, PGO_SYNCIO|PGO_PASTEOF);
		if (error) {
			goto out;
		}
		simple_lock(&uobj->vmobjlock);
		uvm_lock_pageq();
		for (i = 0; i < npages2; i++) {
			UVMHIST_LOG(ubchist, "got pgs2[%d] %p", i, pgs2[i],0,0);
			KASSERT((pgs2[i]->flags & PG_RELEASED) == 0);
			pgs2[i]->flags &= ~PG_CLEAN;
			uvm_pageactivate(pgs2[i]);
		}
		uvm_unlock_pageq();
		simple_unlock(&uobj->vmobjlock);
	}

	/*
	 * adjust off to be block-aligned.
	 */

	delta = off & (bsize - 1);
	off -= delta;
	len += delta;

	/*
	 * now allocate the range.
	 */

	lockmgr(&gp->g_glock, LK_EXCLUSIVE, NULL, curproc);
	error = GOP_ALLOC(vp, off, len, flags, cred);
	lockmgr(&gp->g_glock, LK_RELEASE, NULL, curproc);

	/*
	 * clear PG_RDONLY on any pages we are holding
	 * (since they now have backing store) and unbusy them.
	 * if we got an error, free any pages we created past the old eob.
	 */

out:
	simple_lock(&uobj->vmobjlock);
	if (error) {
		(void) (uobj->pgops->pgo_flush)(uobj, round_page(oldeob), 0,
		    PGO_FREE);
	}
	if (pgs1[0] != NULL) {
		for (i = 0; i < npages1; i++) {
			pgs1[i]->flags &= ~PG_RDONLY;
		}
		uvm_page_unbusy(pgs1, npages1);

		/*
		 * The data in the frag might be moving to a new disk location.
		 * We need to flush pages to the new disk locations.
		 */

		if ((flags & B_SYNC) == 0)
			(*uobj->pgops->pgo_flush)(uobj, oldeof & ~(bsize - 1),
			    MIN((oldeof + bsize) & ~(bsize - 1), neweof),
			    PGO_CLEANIT | PGO_SYNCIO);
	}
	if (pgs2[0] != NULL) {
		for (i = 0; i < npages2; i++) {
			pgs2[i]->flags &= ~PG_RDONLY;
		}
		uvm_page_unbusy(pgs2, npages2);
	}
	simple_unlock(&uobj->vmobjlock);
	return error;
@


1.15.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.15 2001/12/10 04:45:32 art Exp $	*/
d278 1
a278 1
		(void) (uobj->pgops->pgo_put)(uobj, round_page(oldeob), 0,
a279 1
		simple_lock(&uobj->vmobjlock);
d292 4
a295 6
		if (flags & B_SYNC) {
			(*uobj->pgops->pgo_put)(uobj, oldeof & ~(bsize - 1),
			    MIN((oldeof + bsize) & ~(bsize - 1),
				round_page(neweob)), PGO_CLEANIT | PGO_SYNCIO);
			simple_lock(&uobj->vmobjlock);
		}
@


1.15.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.15.2.1 2002/02/02 03:28:26 art Exp $	*/
a52 1
#include <ufs/ufs/extattr.h>
@


1.15.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.15.2.2 2002/06/11 03:32:50 art Exp $	*/
d85 1
a85 1
		struct proc *a_p;
d94 1
a94 1
		vprint("ufs_inactive: pushing active", vp);
d124 1
a124 1
		vrecycle(vp, NULL, p);
d133 1
a133 1
	struct vnode *vp;
d136 1
a136 1
	struct inode *ip;
d172 1
a172 1
	off_t oldeof, neweof, oldeob, neweob, pagestart;
d175 1
a175 1
	int i, delta, error, npages;
d179 1
a179 1
	struct vm_page *pgs[ppb];
d192 1
a192 1
	pgs[0] = NULL;
d195 34
a228 4
	 * read or create pages covering the range of the allocation and
	 * keep them locked until the new block is allocated, so there
	 * will be no window where the old contents of the new block are
	 * visible to racing threads.
d232 20
a251 15
	npages = MIN(ppb, (round_page(neweob) - pagestart) >> PAGE_SHIFT);
	memset(pgs, 0, npages * sizeof(struct vm_page *));
	simple_lock(&uobj->vmobjlock);
	error = VOP_GETPAGES(vp, pagestart, pgs, &npages, 0,
	    VM_PROT_READ, 0, PGO_SYNCIO|PGO_PASTEOF);
	if (error) {
		return error;
	}
	simple_lock(&uobj->vmobjlock);
	uvm_lock_pageq();
	for (i = 0; i < npages; i++) {
		UVMHIST_LOG(ubchist, "got pgs[%d] %p", i, pgs[i],0,0);
		KASSERT((pgs[i]->flags & PG_RELEASED) == 0);
		pgs[i]->flags &= ~PG_CLEAN;
		uvm_pageactivate(pgs[i]);
a252 2
	uvm_unlock_pageq();
	simple_unlock(&uobj->vmobjlock);
d273 1
d276 1
d278 21
a298 4
	for (i = 0; i < npages; i++) {
		pgs[i]->flags &= ~PG_RDONLY;
		if (error) {
			pgs[i]->flags |= PG_RELEASED;
d301 5
a305 6
	if (error) {
		uvm_lock_pageq();
		uvm_page_unbusy(pgs, npages);
		uvm_unlock_pageq();
	} else {
		uvm_page_unbusy(pgs, npages);
@


1.15.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d102 1
a102 1
		if (getinoquota(ip) == 0)
@


1.14
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.13 2001/11/30 00:32:58 art Exp $	*/
d173 1
d184 1
a184 4
	error = VOP_SIZE(vp, oldeof, &oldeob);
	if (error) {
		return error;
	}
d187 1
a187 4
	error = VOP_SIZE(vp, neweof, &neweob);
	if (error) {
		return error;
	}
d265 3
a267 3
	lockmgr(&vp->v_glock, LK_EXCLUSIVE, NULL, curproc);
	error = VOP_BALLOCN(vp, off, len, cred, flags);
	lockmgr(&vp->v_glock, LK_RELEASE, NULL, curproc);
@


1.13
log
@Fix a mergeo and don't truncate a 0 length file when freeing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.12 2001/11/28 00:45:40 art Exp $	*/
d180 1
a180 1
		    vp, off, len, vp->v_uvm.u_size);
d182 1
a182 1
	oldeof = vp->v_uvm.u_size;
d188 1
a188 1
	neweof = MAX(vp->v_uvm.u_size, off + len);
d195 1
a195 1
	uobj = &vp->v_uvm.u_obj;
@


1.12
log
@Bunch of bug fixes from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.11 2001/11/27 05:27:12 art Exp $	*/
d104 3
a106 1
		(void) UFS_TRUNCATE(ip, (off_t)0, 0, NOCRED);
d297 4
a300 3
		(uobj->pgops->pgo_flush)(uobj, oldeof & ~(bsize - 1),
		    MIN((oldeof + bsize) & ~(bsize - 1), neweof),
		    PGO_CLEANIT | PGO_SYNCIO);
@


1.11
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.10 2001/11/21 21:23:56 csapuntz Exp $	*/
d273 2
a274 1
	 * unbusy any pages we are holding.
d285 3
d297 1
a297 1
		    PGO_CLEANIT | ((flags & B_SYNC) ? PGO_SYNCIO : 0));
d300 3
@


1.10
log
@Don't use #define QUOTA - use stub file instead

Pass over the quota code in ufs/. Make code paths clearer. Clean up some names.
Move all code that manipulates quotas directly into ufs_quota.c

Use vfs_mount_foreach_vnode to traverse list of vnodes in mountpoint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.9 2001/07/16 02:56:48 csapuntz Exp $	*/
d153 147
@


1.9
log
@

Don't try to truncate anything except for symlinks, directories, and
regular files.

ftruncate and truncate that go through FFS/EXT2FS/MFS will now return
EINVAL when done on devices.

Bug introduced when VOP_TRUNCATE was removed, thus removing spec_truncate.

Thanks to millert@@ for tracking this one down.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.8 2001/06/23 02:07:57 csapuntz Exp $	*/
d70 2
a71 3
#ifdef QUOTA
	dqinit();
#endif
d101 3
a103 4
#ifdef QUOTA
		if (!getinoquota(ip))
			(void)chkiq(ip, -1, NOCRED, 0);
#endif
d151 1
a151 11
#ifdef QUOTA
	{
		int i;
		for (i = 0; i < MAXQUOTAS; i++) {
			if (ip->i_dquot[i] != NODQUOT) {
				dqrele(vp, ip->i_dquot[i]);
				ip->i_dquot[i] = NODQUOT;
			}
		}
	}
#endif
@


1.8
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.7 1997/11/06 05:59:26 csapuntz Exp $	*/
d106 1
a106 1
		error = UFS_TRUNCATE(ip, (off_t)0, 0, NOCRED);
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.6 1997/10/06 20:21:46 deraadt Exp $	*/
a89 1
	struct timespec ts;
d106 1
a106 1
		error = VOP_TRUNCATE(vp, (off_t)0, 0, NOCRED, p);
d111 1
a111 1
		VOP_VFREE(vp, ip->i_number, mode);
d114 1
a114 2
		TIMEVAL_TO_TIMESPEC(&time, &ts);
		VOP_UPDATE(vp, &ts, &ts, 0);
@


1.7.10.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.7 1997/11/06 05:59:26 csapuntz Exp $	*/
d90 1
d107 1
a107 1
		error = UFS_TRUNCATE(ip, (off_t)0, 0, NOCRED);
d112 1
a112 1
		UFS_INODE_FREE(ip, ip->i_number, mode);
d115 2
a116 1
		UFS_UPDATE(ip, 0);
@


1.7.10.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.7.10.1 2001/07/04 11:00:56 niklas Exp $	*/
d106 1
a106 1
		(void) UFS_TRUNCATE(ip, (off_t)0, 0, NOCRED);
@


1.7.10.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 3
a72 2
	ufs_quota_init();

d102 5
a106 6
		if (getinoquota(ip) != 0)
			(void)ufs_quota_free_inode(ip, NOCRED);

		if (ip->i_ffs_size != 0) {
			(void) UFS_TRUNCATE(ip, (off_t)0, 0, NOCRED);
		}
d153 8
a160 70
	ufs_quota_delete(ip);
	return (0);
}

/*
 * allocate a range of blocks in a file.
 * after this function returns, any page entirely contained within the range
 * will map to invalid data and thus must be overwritten before it is made
 * accessible to others.
 */

int
ufs_balloc_range(vp, off, len, cred, flags)
	struct vnode *vp;
	off_t off, len;
	struct ucred *cred;
	int flags;
{
	off_t oldeof, neweof, oldeob, neweob, oldpagestart, pagestart;
	struct uvm_object *uobj;
	int i, delta, error, npages1, npages2;
	int bshift = vp->v_mount->mnt_fs_bshift;
	int bsize = 1 << bshift;
	int ppb = MAX(bsize >> PAGE_SHIFT, 1);
	struct vm_page *pgs1[ppb], *pgs2[ppb];
	UVMHIST_FUNC("ufs_balloc_range"); UVMHIST_CALLED(ubchist);
	UVMHIST_LOG(ubchist, "vp %p off 0x%x len 0x%x u_size 0x%x",
		    vp, off, len, vp->v_uvm.u_size);

	oldeof = vp->v_uvm.u_size;
	error = VOP_SIZE(vp, oldeof, &oldeob);
	if (error) {
		return error;
	}

	neweof = MAX(vp->v_uvm.u_size, off + len);
	error = VOP_SIZE(vp, neweof, &neweob);
	if (error) {
		return error;
	}

	error = 0;
	uobj = &vp->v_uvm.u_obj;
	pgs1[0] = pgs2[0] = NULL;

	/*
	 * if the last block in the file is not a full block (ie. it is a
	 * fragment), and this allocation is causing the fragment to change
	 * size (either to expand the fragment or promote it to a full block),
	 * cache the old last block (at its new size).
	 */

	oldpagestart = trunc_page(oldeof) & ~(bsize - 1);
	if ((oldeob & (bsize - 1)) != 0 && oldeob != neweob) {
		npages1 = MIN(ppb, (round_page(neweob) - oldpagestart) >>
			      PAGE_SHIFT);
		memset(pgs1, 0, npages1 * sizeof(struct vm_page *));
		simple_lock(&uobj->vmobjlock);
		error = VOP_GETPAGES(vp, oldpagestart, pgs1, &npages1,
		    0, VM_PROT_READ, 0, PGO_SYNCIO|PGO_PASTEOF);
		if (error) {
			goto out;
		}
		simple_lock(&uobj->vmobjlock);
		uvm_lock_pageq();
		for (i = 0; i < npages1; i++) {
			UVMHIST_LOG(ubchist, "got pgs1[%d] %p", i, pgs1[i],0,0);
			KASSERT((pgs1[i]->flags & PG_RELEASED) == 0);
			pgs1[i]->flags &= ~PG_CLEAN;
			uvm_pageactivate(pgs1[i]);
a161 2
		uvm_unlock_pageq();
		simple_unlock(&uobj->vmobjlock);
d163 2
a164 83

	/*
	 * cache the new range as well.  this will create zeroed pages
	 * where the new block will be and keep them locked until the
	 * new block is allocated, so there will be no window where
	 * the old contents of the new block is visible to racing threads.
	 */

	pagestart = trunc_page(off) & ~(bsize - 1);
	if (pagestart != oldpagestart || pgs1[0] == NULL) {
		npages2 = MIN(ppb, (round_page(neweob) - pagestart) >>
			      PAGE_SHIFT);
		memset(pgs2, 0, npages2 * sizeof(struct vm_page *));
		simple_lock(&uobj->vmobjlock);
		error = VOP_GETPAGES(vp, pagestart, pgs2, &npages2, 0,
		    VM_PROT_READ, 0, PGO_SYNCIO|PGO_PASTEOF);
		if (error) {
			goto out;
		}
		simple_lock(&uobj->vmobjlock);
		uvm_lock_pageq();
		for (i = 0; i < npages2; i++) {
			UVMHIST_LOG(ubchist, "got pgs2[%d] %p", i, pgs2[i],0,0);
			KASSERT((pgs2[i]->flags & PG_RELEASED) == 0);
			pgs2[i]->flags &= ~PG_CLEAN;
			uvm_pageactivate(pgs2[i]);
		}
		uvm_unlock_pageq();
		simple_unlock(&uobj->vmobjlock);
	}

	/*
	 * adjust off to be block-aligned.
	 */

	delta = off & (bsize - 1);
	off -= delta;
	len += delta;

	/*
	 * now allocate the range.
	 */

	lockmgr(&vp->v_glock, LK_EXCLUSIVE, NULL, curproc);
	error = VOP_BALLOCN(vp, off, len, cred, flags);
	lockmgr(&vp->v_glock, LK_RELEASE, NULL, curproc);

	/*
	 * clear PG_RDONLY on any pages we are holding
	 * (since they now have backing store) and unbusy them.
	 * if we got an error, free any pages we created past the old eob.
	 */

out:
	simple_lock(&uobj->vmobjlock);
	if (error) {
		(void) (uobj->pgops->pgo_flush)(uobj, round_page(oldeob), 0,
		    PGO_FREE);
	}
	if (pgs1[0] != NULL) {
		for (i = 0; i < npages1; i++) {
			pgs1[i]->flags &= ~PG_RDONLY;
		}
		uvm_page_unbusy(pgs1, npages1);

		/*
		 * The data in the frag might be moving to a new disk location.
		 * We need to flush pages to the new disk locations.
		 */

		if ((flags & B_SYNC) == 0)
			(*uobj->pgops->pgo_flush)(uobj, oldeof & ~(bsize - 1),
			    MIN((oldeof + bsize) & ~(bsize - 1), neweof),
			    PGO_CLEANIT | PGO_SYNCIO);
	}
	if (pgs2[0] != NULL) {
		for (i = 0; i < npages2; i++) {
			pgs2[i]->flags &= ~PG_RDONLY;
		}
		uvm_page_unbusy(pgs2, npages2);
	}
	simple_unlock(&uobj->vmobjlock);
	return error;
@


1.7.10.4
log
@Merge in trunk
@
text
@a52 1
#include <ufs/ufs/extattr.h>
d104 3
a106 1
		(void) UFS_TRUNCATE(ip, (off_t)0, 0, NOCRED);
d155 155
@


1.7.10.5
log
@Sync the SMP branch with 3.3
@
text
@d102 1
a102 1
		if (getinoquota(ip) == 0)
@


1.7.10.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.7.10.5 2003/03/28 00:08:48 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.10.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a53 4
#ifdef UFS_DIRHASH
#include <ufs/ufs/dir.h>
#include <ufs/ufs/dirhash.h>
#endif
d146 1
a147 4
#ifdef UFS_DIRHASH
	if (ip->i_dirhash != NULL)
		ufsdirhash_free(ip);
#endif
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.4 1997/05/30 08:35:04 downsj Exp $	*/
d60 1
d75 1
a75 1

d85 1
d87 3
a89 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d91 1
a91 1
	int mode, error;
d97 5
a101 17
	/* Get rid of inodes related to stale file handles. */
	if (ip->i_ffs_mode == 0) {
		if ((vp->v_flag & VXLOCK) == 0)
			vgone(vp);
		return (0);
	}

	error = 0;
#ifdef DIAGNOSTIC
	if (VOP_ISLOCKED(vp))
		panic("ffs_inactive: locked inode");
	if (curproc)
		ip->i_lockholder = curproc->p_pid;
	else
		ip->i_lockholder = -1;
#endif
	ip->i_flag |= IN_LOCKED;
d107 1
a107 1
		error = VOP_TRUNCATE(vp, (off_t)0, 0, NOCRED, NULL);
d118 2
a119 1
	VOP_UNLOCK(vp);
d124 2
a125 2
	if (vp->v_usecount == 0 && ip->i_ffs_mode == 0)
		vgone(vp);
d133 1
a133 1
ufs_reclaim(vp)
d135 1
@


1.5
log
@VFS Lite2 Changes
@
text
@a59 1
#if 0
d74 1
a74 1
#endif
a83 1
		sturct proc *a_p;
d85 2
a86 3
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct proc *p = ap->a_p;
d88 1
a88 1
	int mode, error = 0;
d94 17
a110 5
	/*
	 * Ignore inodes related to stale file handles.
	 */
	if (ip->i_ffs_mode == 0)
		goto out;
d116 1
a116 1
		error = VOP_TRUNCATE(vp, (off_t)0, 0, NOCRED, p);
d127 1
a127 2
out:
	VOP_UNLOCK(vp, 0, p);
d132 2
a133 2
	if (ip->i_ffs_mode == 0)
		vrecycle(vp, (struct simplelock *)0, p);
d141 1
a141 1
ufs_reclaim(vp, p)
a142 1
	struct proc *p;
@


1.4
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_inode.c,v 1.3 1996/05/22 11:47:21 deraadt Exp $	*/
d60 1
d75 1
a75 1

d85 1
d87 3
a89 2
	register struct vnode *vp = ap->a_vp;
	register struct inode *ip = VTOI(vp);
d91 1
a91 1
	int mode, error;
d97 5
a101 17
	/* Get rid of inodes related to stale file handles. */
	if (ip->i_ffs_mode == 0) {
		if ((vp->v_flag & VXLOCK) == 0)
			vgone(vp);
		return (0);
	}

	error = 0;
#ifdef DIAGNOSTIC
	if (VOP_ISLOCKED(vp))
		panic("ffs_inactive: locked inode");
	if (curproc)
		ip->i_lockholder = curproc->p_pid;
	else
		ip->i_lockholder = -1;
#endif
	ip->i_flag |= IN_LOCKED;
d107 1
a107 1
		error = VOP_TRUNCATE(vp, (off_t)0, 0, NOCRED, NULL);
d118 2
a119 1
	VOP_UNLOCK(vp);
d124 2
a125 2
	if (vp->v_usecount == 0 && ip->i_ffs_mode == 0)
		vgone(vp);
d133 1
a133 1
ufs_reclaim(vp)
d135 1
@


1.3
log
@Change VOP_UPDATE() semantics:
* Make 2nd and 3rd args timespecs, not timevals.
* Consistently pass a Boolean as the 4th arg (except in LFS).
Also, fix ffs_update() and lfs_update() to actually change the nsec fields.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d95 1
a95 1
	if (ip->i_mode == 0) {
d111 1
a111 1
	if (ip->i_nlink <= 0 && (vp->v_mount->mnt_flag & MNT_RDONLY) == 0) {
d117 3
a119 3
		ip->i_rdev = 0;
		mode = ip->i_mode;
		ip->i_mode = 0;
d132 1
a132 1
	if (vp->v_usecount == 0 && ip->i_mode == 0)
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d2 1
a2 1
/*	$NetBSD: ufs_inode.c,v 1.6 1996/02/09 22:36:05 christos Exp $	*/
d87 1
a87 1
	struct timeval tv;
d124 2
a125 2
		tv = time;
		VOP_UPDATE(vp, &tv, &tv, 0);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ufs_inode.c,v 1.5 1994/12/14 13:03:59 mycroft Exp $	*/
d51 1
d60 1
a60 1
int
d63 1
a63 1
	static int done;
d66 1
a66 1
		return (0);
d72 1
a72 1
	return (0);
d79 3
a81 1
ufs_inactive(ap)
d84 1
a84 2
	} */ *ap;
{
a144 1
	int i;
d163 7
a169 4
	for (i = 0; i < MAXQUOTAS; i++) {
		if (ip->i_dquot[i] != NODQUOT) {
			dqrele(vp, ip->i_dquot[i]);
			ip->i_dquot[i] = NODQUOT;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
