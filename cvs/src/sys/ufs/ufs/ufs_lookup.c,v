head	1.50;
access;
symbols
	OPENBSD_6_2:1.50.0.6
	OPENBSD_6_2_BASE:1.50
	OPENBSD_6_1:1.50.0.4
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.49.0.2
	OPENBSD_6_0_BASE:1.49
	OPENBSD_5_9:1.47.0.2
	OPENBSD_5_9_BASE:1.47
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.42.0.2
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.41.0.6
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.4
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.2
	OPENBSD_5_0:1.40.0.4
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.37.0.12
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.8
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.37.0.6
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.4
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.37.0.2
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.35.0.4
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.25.0.2
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.12.0.10
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.8
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.6
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.50
date	2016.09.10.16.53.30;	author natano;	state Exp;
branches;
next	1.49;
commitid	OheBN9SCINTycSAi;

1.49
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.48;
commitid	gAjwyca5TfuoJAhn;

1.48
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.47;
commitid	gFybgYMymUyTbVeS;

1.47
date	2015.03.14.03.38.53;	author jsg;	state Exp;
branches;
next	1.46;
commitid	p4LJxGKbi0BU2cG6;

1.46
date	2014.12.07.21.12.22;	author tedu;	state Exp;
branches;
next	1.45;
commitid	sMWz3Wq4mNfamxm9;

1.45
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.44;
commitid	EF98ch02VpFassUi;

1.44
date	2013.12.12.19.15.32;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2013.12.12.19.00.10;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2013.05.30.19.19.09;	author guenther;	state Exp;
branches;
next	1.41;

1.41
date	2011.09.18.23.20.28;	author bluhm;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.23.18.49.39;	author oga;	state Exp;
branches;
next	1.39;

1.39
date	2010.04.20.22.05.44;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.01.23.47.57;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.17.11.09.00;	author pedro;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.10.22.01.14;	author pedro;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.20.16.30.35;	author pedro;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.03.20.14.03;	author drahn;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.19.00.44.01;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2005.06.18.18.09.43;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2005.06.10.17.37.41;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.07.04.37.28;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.07.01.40.17;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.16.22.41.50;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2004.01.09.03.01.03;	author tedu;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2004.01.06.04.22.59;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.28.17.20.16;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.12.14.41.08;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2003.01.31.17.37.50;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.22.20.37.46;	author drahn;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.06.27.04.58.49;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.23.02.07.57;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.27.09.52.56;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.27.09.47.55;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.21.23.24.31;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	99.02.26.03.35.18;	author art;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	98.07.28.00.13.17;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	97.12.11.04.25.45;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.12.11.01.03.17;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.12.02.17.11.11;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.59.27;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.21.47;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.27.38;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.05.30.08.35.08;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.31.09.24.10;	author pefo;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.21.28;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.35;	author deraadt;	state Exp;
branches;
next	;

1.12.6.1
date	2001.05.14.22.47.43;	author niklas;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2001.07.04.11.00.56;	author niklas;	state Exp;
branches;
next	1.12.6.3;

1.12.6.3
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.12.6.4;

1.12.6.4
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.12.6.5;

1.12.6.5
date	2003.03.28.00.08.48;	author niklas;	state Exp;
branches;
next	1.12.6.6;

1.12.6.6
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.12.6.7;

1.12.6.7
date	2004.02.19.11.01.43;	author niklas;	state Exp;
branches;
next	1.12.6.8;

1.12.6.8
date	2004.06.05.23.13.12;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2003.05.19.22.38.11;	author tedu;	state Exp;
branches;
next	;

1.25.2.1
date	2004.05.01.01.37.58;	author brad;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Add a noperm mount flag for FFS to be used for building release sets
without root privileges. This is only the kernel/mount flag; additional
work in the build Makefile's will be necessary such that the files in
$DESTDIR are created with correct permissions.

tedu couldn't find anything wrong with it in a quick review
idea & ok deraadt
@
text
@/*	$OpenBSD: ufs_lookup.c,v 1.49 2016/03/19 12:04:16 natano Exp $	*/
/*	$NetBSD: ufs_lookup.c,v 1.7 1996/02/09 22:36:06 christos Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ufs_lookup.c	8.9 (Berkeley) 8/11/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/namei.h>
#include <sys/buf.h>
#include <sys/stat.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/vnode.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/dir.h>
#ifdef UFS_DIRHASH
#include <ufs/ufs/dirhash.h>
#endif
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

extern	struct nchstats nchstats;

#ifdef DIAGNOSTIC
int	dirchk = 1;
#else
int	dirchk = 0;
#endif

#define OFSFMT(ip)	((ip)->i_ump->um_maxsymlinklen == 0)

/*
 * Convert a component of a pathname into a pointer to a locked inode.
 * This is a very central and rather complicated routine.
 * If the file system is not maintained in a strict tree hierarchy,
 * this can result in a deadlock situation (see comments in code below).
 *
 * The cnp->cn_nameiop argument is LOOKUP, CREATE, RENAME, or DELETE depending
 * on whether the name is to be looked up, created, renamed, or deleted.
 * When CREATE, RENAME, or DELETE is specified, information usable in
 * creating, renaming, or deleting a directory entry may be calculated.
 * If flag has LOCKPARENT or'ed into it and the target of the pathname
 * exists, lookup returns both the target and its parent directory locked.
 * When creating or renaming and LOCKPARENT is specified, the target may
 * not be ".".  When deleting and LOCKPARENT is specified, the target may
 * be "."., but the caller must check to ensure it does an vrele and vput
 * instead of two vputs.
 *
 * Overall outline of ufs_lookup:
 *
 *	check accessibility of directory
 *	look for name in cache, if found, then if at end of path
 *	  and deleting or creating, drop it, else return name
 *	search for name in directory, to found or notfound
 * notfound:
 *	if creating, return locked directory, leaving info on available slots
 *	else return error
 * found:
 *	if at end of path and deleting, return information to allow delete
 *	if at end of path and rewriting (RENAME and LOCKPARENT), lock target
 *	  inode and return info to allow rewrite
 *	if not at end, add name to cache; if at end and neither creating
 *	  nor deleting, add name to cache
 */
int
ufs_lookup(void *v)
{
	struct vop_lookup_args *ap = v;
	struct vnode *vdp;		/* vnode for directory being searched */
	struct inode *dp;		/* inode for directory being searched */
	struct buf *bp;			/* a buffer of directory entries */
	struct direct *ep;		/* the current directory entry */
	int entryoffsetinblock;		/* offset of ep in bp's buffer */
	enum {NONE, COMPACT, FOUND} slotstatus;
	doff_t slotoffset;		/* offset of area with free space */
	int slotsize;			/* size of area at slotoffset */
	int slotfreespace;		/* amount of space free in slot */
	int slotneeded;			/* size of the entry we're seeking */
	int numdirpasses;		/* strategy for directory search */
	doff_t endsearch;		/* offset to end directory search */
	doff_t prevoff;			/* prev entry dp->i_offset */
	struct vnode *pdp;		/* saved dp during symlink work */
	struct vnode *tdp;		/* returned by VFS_VGET */
	doff_t enduseful;		/* pointer past last used dir slot */
	u_long bmask;			/* block offset mask */
	int lockparent;			/* 1 => lockparent flag is set */
	int wantparent;			/* 1 => wantparent or lockparent flag */
	int namlen, error;
	struct vnode **vpp = ap->a_vpp;
	struct componentname *cnp = ap->a_cnp;
	struct ucred *cred = cnp->cn_cred;
	int flags;
	int nameiop = cnp->cn_nameiop;
	struct proc *p = cnp->cn_proc;

	cnp->cn_flags &= ~PDIRUNLOCK;
	flags = cnp->cn_flags;

	bp = NULL;
	slotoffset = -1;
	*vpp = NULL;
	vdp = ap->a_dvp;
	dp = VTOI(vdp);
	lockparent = flags & LOCKPARENT;
	wantparent = flags & (LOCKPARENT|WANTPARENT);

	/*
	 * Check accessiblity of directory.
	 */
	if ((DIP(dp, mode) & IFMT) != IFDIR)
		return (ENOTDIR);
	if ((error = VOP_ACCESS(vdp, VEXEC, cred, cnp->cn_proc)) != 0)
		return (error);

	if ((flags & ISLASTCN) && (vdp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);

	/*
	 * We now have a segment name to search for, and a directory to search.
	 *
	 * Before tediously performing a linear scan of the directory,
	 * check the name cache to see if the directory/name pair
	 * we are looking for is known already.
	 */
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);

	/*
	 * Suppress search for slots unless creating
	 * file and at end of pathname, in which case
	 * we watch for a place to put the new file in
	 * case it doesn't already exist.
	 */
	slotstatus = FOUND;
	slotfreespace = slotsize = slotneeded = 0;
	if ((nameiop == CREATE || nameiop == RENAME) &&
	    (flags & ISLASTCN)) {
		slotstatus = NONE;
		slotneeded = (sizeof(struct direct) - MAXNAMLEN +
			cnp->cn_namelen + 3) &~ 3;
	}

	/*
	 * If there is cached information on a previous search of
	 * this directory, pick up where we last left off.
	 * We cache only lookups as these are the most common
	 * and have the greatest payoff. Caching CREATE has little
	 * benefit as it usually must search the entire directory
	 * to determine that the entry does not exist. Caching the
	 * location of the last DELETE or RENAME has not reduced
	 * profiling time and hence has been removed in the interest
	 * of simplicity.
	 */
	bmask = VFSTOUFS(vdp->v_mount)->um_mountp->mnt_stat.f_iosize - 1;

#ifdef UFS_DIRHASH
	/*
	 * Use dirhash for fast operations on large directories. The logic
	 * to determine whether to hash the directory is contained within
	 * ufsdirhash_build(); a zero return means that it decided to hash
	 * this directory and it successfully built up the hash table.
	 */
	if (ufsdirhash_build(dp) == 0) {
		/* Look for a free slot if needed. */
		enduseful = DIP(dp, size);
		if (slotstatus != FOUND) {
			slotoffset = ufsdirhash_findfree(dp, slotneeded,
			    &slotsize);
			if (slotoffset >= 0) {
				slotstatus = COMPACT;
				enduseful = ufsdirhash_enduseful(dp);
				if (enduseful < 0)
					enduseful = DIP(dp, size);
			}
		}
		/* Look up the component. */
		numdirpasses = 1;
		entryoffsetinblock = 0; /* silence compiler warning */
		switch (ufsdirhash_lookup(dp, cnp->cn_nameptr, cnp->cn_namelen,
		    &dp->i_offset, &bp, nameiop == DELETE ? &prevoff : NULL)) {
		case 0:
			ep = (struct direct *)((char *)bp->b_data +
			    (dp->i_offset & bmask));
			goto foundentry;
		case ENOENT:
#define roundup2(x, y)	(((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */
			dp->i_offset = roundup2(DIP(dp, size), DIRBLKSIZ);
			goto notfound;
		default:
			/* Something failed; just do a linear search. */
			break;
		}
	}
#endif /* UFS_DIRHASH */

	if (nameiop != LOOKUP || dp->i_diroff == 0 ||
	    dp->i_diroff >= DIP(dp, size)) {
		entryoffsetinblock = 0;
		dp->i_offset = 0;
		numdirpasses = 1;
	} else {
		dp->i_offset = dp->i_diroff;
		if ((entryoffsetinblock = dp->i_offset & bmask) &&
		    (error = UFS_BUFATOFF(dp, (off_t)dp->i_offset, NULL, &bp)))
			return (error);
		numdirpasses = 2;
		nchstats.ncs_2passes++;
	}
	prevoff = dp->i_offset;
	endsearch = roundup(DIP(dp, size), DIRBLKSIZ);
	enduseful = 0;

searchloop:
	while (dp->i_offset < endsearch) {
		/*
		 * If necessary, get the next directory block.
		 */
		if ((dp->i_offset & bmask) == 0) {
			if (bp != NULL)
				brelse(bp);
			error = UFS_BUFATOFF(dp, (off_t)dp->i_offset, NULL,
					     &bp);
			if (error)
				return (error);
			entryoffsetinblock = 0;
		}
		/*
		 * If still looking for a slot, and at a DIRBLKSIZE
		 * boundary, have to start looking for free space again.
		 */
		if (slotstatus == NONE &&
		    (entryoffsetinblock & (DIRBLKSIZ - 1)) == 0) {
			slotoffset = -1;
			slotfreespace = 0;
		}
		/*
		 * Get pointer to next entry.
		 * Full validation checks are slow, so we only check
		 * enough to insure forward progress through the
		 * directory. Complete checks can be run by patching
		 * "dirchk" to be true.
		 */
		ep = (struct direct *)((char *)bp->b_data + entryoffsetinblock);
		if (ep->d_reclen == 0 ||
		    (dirchk && ufs_dirbadentry(vdp, ep, entryoffsetinblock))) {
			int i;

			ufs_dirbad(dp, dp->i_offset, "mangled entry");
			i = DIRBLKSIZ - (entryoffsetinblock & (DIRBLKSIZ - 1));
			dp->i_offset += i;
			entryoffsetinblock += i;
			continue;
		}

		/*
		 * If an appropriate sized slot has not yet been found,
		 * check to see if one is available. Also accumulate space
		 * in the current block so that we can determine if
		 * compaction is viable.
		 */
		if (slotstatus != FOUND) {
			int size = ep->d_reclen;

			if (ep->d_ino != 0)
				size -= DIRSIZ(OFSFMT(dp), ep);
			if (size > 0) {
				if (size >= slotneeded) {
					slotstatus = FOUND;
					slotoffset = dp->i_offset;
					slotsize = ep->d_reclen;
				} else if (slotstatus == NONE) {
					slotfreespace += size;
					if (slotoffset == -1)
						slotoffset = dp->i_offset;
					if (slotfreespace >= slotneeded) {
						slotstatus = COMPACT;
						slotsize = dp->i_offset +
						      ep->d_reclen - slotoffset;
					}
				}
			}
		}

		/*
		 * Check for a name match.
		 */
		if (ep->d_ino) {
#			if (BYTE_ORDER == LITTLE_ENDIAN)
				if (OFSFMT(dp))
					namlen = ep->d_type;
				else
					namlen = ep->d_namlen;
#			else
				namlen = ep->d_namlen;
#			endif
			if (namlen == cnp->cn_namelen &&
			    !memcmp(cnp->cn_nameptr, ep->d_name, namlen)) {
#ifdef UFS_DIRHASH
foundentry:
#endif
				/*
				 * Save directory entry's inode number and
				 * reclen in ndp->ni_ufs area, and release
				 * directory buffer.
				 */
				dp->i_ino = ep->d_ino;
				dp->i_reclen = ep->d_reclen;
				goto found;
			}
		}
		prevoff = dp->i_offset;
		dp->i_offset += ep->d_reclen;
		entryoffsetinblock += ep->d_reclen;
		if (ep->d_ino)
			enduseful = dp->i_offset;
	}
#ifdef UFS_DIRHASH
notfound:
#endif
	/*
	 * If we started in the middle of the directory and failed
	 * to find our target, we must check the beginning as well.
	 */
	if (numdirpasses == 2) {
		numdirpasses--;
		dp->i_offset = 0;
		endsearch = dp->i_diroff;
		goto searchloop;
	}
	if (bp != NULL)
		brelse(bp);
	/*
	 * If creating, and at end of pathname and current
	 * directory has not been removed, then can consider
	 * allowing file to be created.
	 */
	if ((nameiop == CREATE || nameiop == RENAME) &&
	    (flags & ISLASTCN) && dp->i_effnlink != 0) {
		/*
		 * Access for write is interpreted as allowing
		 * creation of files in the directory.
		 */
		error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc);
		if (error)
			return (error);
		/*
		 * Return an indication of where the new directory
		 * entry should be put.  If we didn't find a slot,
		 * then set dp->i_count to 0 indicating
		 * that the new slot belongs at the end of the
		 * directory. If we found a slot, then the new entry
		 * can be put in the range from dp->i_offset to
		 * dp->i_offset + dp->i_count.
		 */
		if (slotstatus == NONE) {
			dp->i_offset = roundup(DIP(dp, size), DIRBLKSIZ);
			dp->i_count = 0;
			enduseful = dp->i_offset;
		} else if (nameiop == DELETE) {
			dp->i_offset = slotoffset;
			if ((dp->i_offset & (DIRBLKSIZ - 1)) == 0)
				dp->i_count = 0;
			else
				dp->i_count = dp->i_offset - prevoff;
		} else {
			dp->i_offset = slotoffset;
			dp->i_count = slotsize;
			if (enduseful < slotoffset + slotsize)
				enduseful = slotoffset + slotsize;
		}
		dp->i_endoff = roundup(enduseful, DIRBLKSIZ);
		/*
		 * We return with the directory locked, so that
		 * the parameters we set up above will still be
		 * valid if we actually decide to do a direnter().
		 * We return ni_vp == NULL to indicate that the entry
		 * does not currently exist; we leave a pointer to
		 * the (locked) directory inode in ndp->ni_dvp.
		 * The pathname buffer is saved so that the name
		 * can be obtained later.
		 *
		 * NB - if the directory is unlocked, then this
		 * information cannot be used.
		 */
		cnp->cn_flags |= SAVENAME;
		if (!lockparent) {
			VOP_UNLOCK(vdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (EJUSTRETURN);
	}
	/*
	 * Insert name into cache (as non-existent) if appropriate.
	 */
	if ((cnp->cn_flags & MAKEENTRY) && nameiop != CREATE)
		cache_enter(vdp, *vpp, cnp);
	return (ENOENT);

found:
	if (numdirpasses == 2)
		nchstats.ncs_pass2++;
	/*
	 * Check that directory length properly reflects presence
	 * of this entry.
	 */
	if (dp->i_offset + DIRSIZ(OFSFMT(dp), ep) > DIP(dp, size)) {
		ufs_dirbad(dp, dp->i_offset, "i_ffs_size too small");
		DIP_ASSIGN(dp, size, dp->i_offset + DIRSIZ(OFSFMT(dp), ep));
		dp->i_flag |= IN_CHANGE | IN_UPDATE;
	}
	brelse(bp);

	/*
	 * Found component in pathname.
	 * If the final component of path name, save information
	 * in the cache as to where the entry was found.
	 */
	if ((flags & ISLASTCN) && nameiop == LOOKUP)
		dp->i_diroff = dp->i_offset &~ (DIRBLKSIZ - 1);

	/*
	 * If deleting, and at end of pathname, return
	 * parameters which can be used to remove file.
	 * If the wantparent flag isn't set, we return only
	 * the directory (in ndp->ni_dvp), otherwise we go
	 * on and lock the inode, being careful with ".".
	 */
	if (nameiop == DELETE && (flags & ISLASTCN)) {
		/*
		 * Write access to directory required to delete files.
		 */
		error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc);
		if (error)
			return (error);
		/*
		 * Return pointer to current entry in dp->i_offset,
		 * and distance past previous entry (if there
		 * is a previous entry in this block) in dp->i_count.
		 * Save directory inode pointer in ndp->ni_dvp for dirremove().
		 */
		if ((dp->i_offset & (DIRBLKSIZ - 1)) == 0)
			dp->i_count = 0;
		else
			dp->i_count = dp->i_offset - prevoff;
		if (dp->i_number == dp->i_ino) {
			vref(vdp);
			*vpp = vdp;
			return (0);
		}
		error = VFS_VGET(vdp->v_mount, dp->i_ino, &tdp);
		if (error)
			return (error);
		/*
		 * If directory is "sticky", then user must own
		 * the directory, or the file in it, else she
		 * may not delete it (unless she's root). This
		 * implements append-only directories.
		 */
		if ((DIP(dp, mode) & ISVTX) &&
		    cred->cr_uid != 0 &&
		    cred->cr_uid != DIP(dp, uid) &&
		    (vdp->v_mount->mnt_flag & MNT_NOPERM) == 0 &&
		    DIP(VTOI(tdp), uid) != cred->cr_uid) {
			vput(tdp);
			return (EPERM);
		}
		*vpp = tdp;
		if (!lockparent) {
			VOP_UNLOCK(vdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (0);
	}

	/*
	 * If rewriting (RENAME), return the inode and the
	 * information required to rewrite the present directory
	 * Must get inode of directory entry to verify it's a
	 * regular file, or empty directory.
	 */
	if (nameiop == RENAME && wantparent &&
	    (flags & ISLASTCN)) {
		error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc);
		if (error)
			return (error);
		/*
		 * Careful about locking second inode.
		 * This can only occur if the target is ".".
		 */
		if (dp->i_number == dp->i_ino)
			return (EISDIR);
		error = VFS_VGET(vdp->v_mount, dp->i_ino, &tdp);
		if (error)
			return (error);
		*vpp = tdp;
		cnp->cn_flags |= SAVENAME;
		if (!lockparent) {
			VOP_UNLOCK(vdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		return (0);
	}

	/*
	 * Step through the translation in the name.  We do not `vput' the
	 * directory because we may need it again if a symbolic link
	 * is relative to the current directory.  Instead we save it
	 * unlocked as "pdp".  We must get the target inode before unlocking
	 * the directory to insure that the inode will not be removed
	 * before we get it.  We prevent deadlock by always fetching
	 * inodes from the root, moving down the directory tree. Thus
	 * when following backward pointers ".." we must unlock the
	 * parent directory before getting the requested directory.
	 * There is a potential race condition here if both the current
	 * and parent directories are removed before the VFS_VGET for the
	 * inode associated with ".." returns.  We hope that this occurs
	 * infrequently since we cannot avoid this race condition without
	 * implementing a sophisticated deadlock detection algorithm.
	 * Note also that this simple deadlock detection scheme will not
	 * work if the file system has any hard links other than ".."
	 * that point backwards in the directory structure.
	 */
	pdp = vdp;
	if (flags & ISDOTDOT) {
		VOP_UNLOCK(pdp, p);	/* race to get the inode */
		cnp->cn_flags |= PDIRUNLOCK;
		error = VFS_VGET(vdp->v_mount, dp->i_ino, &tdp);
		if (error) {
			if (vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
			return (error);
		}
		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(pdp, LK_EXCLUSIVE, p))) {
				vput(tdp);
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
		}
		*vpp = tdp;
	} else if (dp->i_number == dp->i_ino) {
		vref(vdp);	/* we want ourself, ie "." */
		*vpp = vdp;
	} else {
		error = VFS_VGET(vdp->v_mount, dp->i_ino, &tdp);
		if (error)
			return (error);
		if (!lockparent || !(flags & ISLASTCN)) {
			VOP_UNLOCK(pdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		*vpp = tdp;
	}

	/*
	 * Insert name into cache if appropriate.
	 */
	if (cnp->cn_flags & MAKEENTRY)
		cache_enter(vdp, *vpp, cnp);
	return (0);
}

void
ufs_dirbad(struct inode *ip, doff_t offset, char *how)
{
	struct mount *mp;

	mp = ITOV(ip)->v_mount;
	(void)printf("%s: bad dir ino %u at offset %d: %s\n",
	    mp->mnt_stat.f_mntonname, ip->i_number, offset, how);
	if ((mp->mnt_stat.f_flags & MNT_RDONLY) == 0)
		panic("bad dir");
}

/*
 * Do consistency checking on a directory entry:
 *	record length must be multiple of 4
 *	entry must fit in rest of its DIRBLKSIZ block
 *	record must be large enough to contain entry
 *	name is not longer than MAXNAMLEN
 *	name must be as long as advertised, and null terminated
 */
int
ufs_dirbadentry(struct vnode *vdp, struct direct *ep, int entryoffsetinblock)
{
	struct inode *dp;
	int i;
	int namlen;

	dp = VTOI(vdp);

#	if (BYTE_ORDER == LITTLE_ENDIAN)
		if (OFSFMT(dp))
			namlen = ep->d_type;
		else
			namlen = ep->d_namlen;
#	else
		namlen = ep->d_namlen;
#	endif
	if ((ep->d_reclen & 0x3) != 0 ||
	    ep->d_reclen > DIRBLKSIZ - (entryoffsetinblock & (DIRBLKSIZ - 1)) ||
	    ep->d_reclen < DIRSIZ(OFSFMT(dp), ep) || namlen > MAXNAMLEN) {
		/*return (1); */
		printf("First bad\n");
		goto bad;
	}
	if (ep->d_ino == 0)
		return (0);
	for (i = 0; i < namlen; i++)
		if (ep->d_name[i] == '\0') {
			/*return (1); */
			printf("Second bad\n");
			goto bad;
	}
	if (ep->d_name[i])
		goto bad;
	return (0);
bad:
	return (1);
}

/*
 * Construct a new directory entry after a call to namei, using the
 * parameters that it left in the componentname argument cnp. The
 * argument ip is the inode to which the new directory entry will refer.
 */
void
ufs_makedirentry(struct inode *ip, struct componentname *cnp,
    struct direct *newdirp)
{
#ifdef DIAGNOSTIC
  	if ((cnp->cn_flags & SAVENAME) == 0)
		panic("ufs_makedirentry: missing name");
#endif
	newdirp->d_ino = ip->i_number;
	newdirp->d_namlen = cnp->cn_namelen;
	memcpy(newdirp->d_name, cnp->cn_nameptr, cnp->cn_namelen + 1);
	if (OFSFMT(ip)) {
		newdirp->d_type = 0;
#		if (BYTE_ORDER == LITTLE_ENDIAN)
			{ u_char tmp = newdirp->d_namlen;
			newdirp->d_namlen = newdirp->d_type;
			newdirp->d_type = tmp; }
#		endif
	} else
		newdirp->d_type = IFTODT(DIP(ip, mode));
}
  
/*
 * Write a directory entry after a call to namei, using the parameters
 * that it left in nameidata. The argument dirp is the new directory
 * entry contents. Dvp is a pointer to the directory to be written,
 * which was left locked by namei. Remaining parameters (dp->i_offset,
 * dp->i_count) indicate how the space for the new entry is to be obtained.
 * Non-null bp indicates that a directory is being created (for the
 * soft dependency code).
 */
int
ufs_direnter(struct vnode *dvp, struct vnode *tvp, struct direct *dirp,
    struct componentname *cnp, struct buf *newdirbp)
{
  	struct ucred *cr;
  	struct proc *p;
  	int newentrysize;
  	struct inode *dp;
  	struct buf *bp;
  	u_int dsize;
  	struct direct *ep, *nep;
	int error, ret, blkoff, loc, spacefree, flags;
  	char *dirbuf;

 	error = 0;
 	cr = cnp->cn_cred;
 	p = cnp->cn_proc;
  	dp = VTOI(dvp);
	newentrysize = DIRSIZ(OFSFMT(dp), dirp);

	if (dp->i_count == 0) {
		/*
		 * If dp->i_count is 0, then namei could find no
		 * space in the directory. Here, dp->i_offset will
		 * be on a directory block boundary and we will write the
  		 * new entry into a fresh block.
  		 */
  		if (dp->i_offset & (DIRBLKSIZ - 1))
			panic("ufs_direnter: newblk");
		flags = B_CLRBUF;
		if (!DOINGSOFTDEP(dvp))
			flags |= B_SYNC;
		if ((error = UFS_BUF_ALLOC(dp, (off_t)dp->i_offset, DIRBLKSIZ,
		    cr, flags, &bp)) != 0) {
			if (DOINGSOFTDEP(dvp) && newdirbp != NULL)
				bdwrite(newdirbp);
			return (error);
		}
		DIP_ASSIGN(dp, size, dp->i_offset + DIRBLKSIZ);
		dp->i_flag |= IN_CHANGE | IN_UPDATE;
		uvm_vnp_setsize(dvp, DIP(dp, size));
  		dirp->d_reclen = DIRBLKSIZ;
		blkoff = dp->i_offset &
		    (VFSTOUFS(dvp->v_mount)->um_mountp->mnt_stat.f_iosize - 1);
		memcpy(bp->b_data + blkoff, dirp, newentrysize);

#ifdef UFS_DIRHASH
		if (dp->i_dirhash != NULL) {
			ufsdirhash_newblk(dp, dp->i_offset);
			ufsdirhash_add(dp, dirp, dp->i_offset);
			ufsdirhash_checkblock(dp, (char *)bp->b_data + blkoff,
			dp->i_offset);
		}
#endif

		if (DOINGSOFTDEP(dvp)) {
			/*
			 * Ensure that the entire newly allocated block is a
			 * valid directory so that future growth within the
			 * block does not have to ensure that the block is
			 * written before the inode.
			 */
			blkoff += DIRBLKSIZ;
			while (blkoff < bp->b_bcount) {
				((struct direct *)
				   (bp->b_data + blkoff))->d_reclen = DIRBLKSIZ;
				blkoff += DIRBLKSIZ;
			}
			if (softdep_setup_directory_add(bp, dp, dp->i_offset,
			    dirp->d_ino, newdirbp, 1) == 0) {
				bdwrite(bp);
				return (UFS_UPDATE(dp, 0));
			}
			/* We have just allocated a directory block in an
			 * indirect block. Rather than tracking when it gets
			 * claimed by the inode, we simply do a VOP_FSYNC
			 * now to ensure that it is there (in case the user
			 * does a future fsync). Note that we have to unlock
			 * the inode for the entry that we just entered, as
			 * the VOP_FSYNC may need to lock other inodes which
			 * can lead to deadlock if we also hold a lock on
			 * the newly entered node.
			 */
			if ((error = VOP_BWRITE(bp)))
				return (error);
			if (tvp != NULL)
				VOP_UNLOCK(tvp, p);
			error = VOP_FSYNC(dvp, p->p_ucred, MNT_WAIT, p);
			if (tvp != NULL)
				vn_lock(tvp, LK_EXCLUSIVE | LK_RETRY, p);
			return (error);
		}
		error = VOP_BWRITE(bp);
 		ret = UFS_UPDATE(dp, !DOINGSOFTDEP(dvp));
 		if (error == 0)
 			return (ret);
  		return (error);
  	}
  
  	/*
	 * If dp->i_count is non-zero, then namei found space for the new
	 * entry in the range dp->i_offset to dp->i_offset + dp->i_count
	 * in the directory. To use this space, we may have to compact
	 * the entries located there, by copying them together towards the
	 * beginning of the block, leaving the free space in one usable
	 * chunk at the end.
  	 */
  
  	/*
	 * Increase size of directory if entry eats into new space.
	 * This should never push the size past a new multiple of
	 * DIRBLKSIZE.
	 *
	 * N.B. - THIS IS AN ARTIFACT OF 4.2 AND SHOULD NEVER HAPPEN.
	 */
	if (dp->i_offset + dp->i_count > DIP(dp, size))
		DIP_ASSIGN(dp, size, dp->i_offset + dp->i_count);
	/*
	 * Get the block containing the space for the new directory entry.
	 */
 	if ((error = UFS_BUFATOFF(dp, (off_t)dp->i_offset, &dirbuf, &bp)) 
	    != 0) {
 		if (DOINGSOFTDEP(dvp) && newdirbp != NULL)
 			bdwrite(newdirbp);
  		return (error);
 	}
	/*
	 * Find space for the new entry. In the simple case, the entry at
	 * offset base will have the space. If it does not, then namei
	 * arranged that compacting the region dp->i_offset to
	 * dp->i_offset + dp->i_count would yield the space.
	 */
	ep = (struct direct *)dirbuf;
	dsize = ep->d_ino ? DIRSIZ(OFSFMT(dp), ep) : 0;
	spacefree = ep->d_reclen - dsize;
	for (loc = ep->d_reclen; loc < dp->i_count; ) {
		nep = (struct direct *)(dirbuf + loc);

		/* Trim the existing slot (NB: dsize may be zero). */
		ep->d_reclen = dsize;
		ep = (struct direct *)((char *)ep + dsize);

		/* Read nep->d_reclen now as the memmove() may clobber it. */
		loc += nep->d_reclen;
		if (nep->d_ino == 0) {
			/*
			 * A mid-block unused entry. Such entries are
			 * never created by the kernel, but fsck_ffs
			 * can create them (and it doesn't fix them).
			 *
			 * Add up the free space, and initialise the
			 * relocated entry since we don't memmove it.
			 */
			spacefree += nep->d_reclen;
			ep->d_ino = 0;
			dsize = 0;
			continue;
		}
		dsize = DIRSIZ(OFSFMT(dp), nep);
		spacefree += nep->d_reclen - dsize;
#ifdef UFS_DIRHASH
		if (dp->i_dirhash != NULL)
			ufsdirhash_move(dp, nep,
			    dp->i_offset + ((char *)nep - dirbuf),
			    dp->i_offset + ((char *)ep - dirbuf));
#endif
 		if (DOINGSOFTDEP(dvp))
 			softdep_change_directoryentry_offset(dp, dirbuf,
 			    (caddr_t)nep, (caddr_t)ep, dsize); 
 		else
 			memmove(ep, nep, dsize);
	}
	/*
	 * Here, `ep' points to a directory entry containing `dsize' in-use
	 * bytes followed by `spacefree' unused bytes. If ep->d_ino == 0,
	 * then the entry is completely unused (dsize == 0). The value
	 * of ep->d_reclen is always indeterminate.
	 *
	 * Update the pointer fields in the previous entry (if any),
	 * copy in the new entry, and write out the block.
	 */
	if (ep->d_ino == 0) {
		if (spacefree + dsize < newentrysize)
			panic("ufs_direnter: compact1");
		dirp->d_reclen = spacefree + dsize;
	} else {
		if (spacefree < newentrysize)
			panic("ufs_direnter: compact2");
		dirp->d_reclen = spacefree;
		ep->d_reclen = dsize;
		ep = (struct direct *)((char *)ep + dsize);
	}

#ifdef UFS_DIRHASH
	if (dp->i_dirhash != NULL && (ep->d_ino == 0 ||
	    dirp->d_reclen == spacefree))
		ufsdirhash_add(dp, dirp, dp->i_offset + ((char *)ep - dirbuf));
#endif
	memcpy(ep, dirp, newentrysize);
#ifdef UFS_DIRHASH
	if (dp->i_dirhash != NULL)
		ufsdirhash_checkblock(dp, dirbuf -
		    (dp->i_offset & (DIRBLKSIZ - 1)),
		    dp->i_offset & ~(DIRBLKSIZ - 1));
#endif

  	if (DOINGSOFTDEP(dvp)) {
  		(void)softdep_setup_directory_add(bp, dp,
  		    dp->i_offset + (caddr_t)ep - dirbuf,
		    dirp->d_ino, newdirbp, 0);
  		bdwrite(bp);
  	} else {
  		error = VOP_BWRITE(bp);
  	}
	dp->i_flag |= IN_CHANGE | IN_UPDATE;

 	/*
 	 * If all went well, and the directory can be shortened, proceed
 	 * with the truncation. Note that we have to unlock the inode for
 	 * the entry that we just entered, as the truncation may need to
 	 * lock other inodes which can lead to deadlock if we also hold a
 	 * lock on the newly entered node.
 	 */

	if (error == 0 && dp->i_endoff && dp->i_endoff < DIP(dp, size)) {
		if (tvp != NULL)
			VOP_UNLOCK(tvp, p);
		error = UFS_TRUNCATE(dp, (off_t)dp->i_endoff, IO_SYNC, cr);
#ifdef UFS_DIRHASH
		if (error == 0 && dp->i_dirhash != NULL)
			ufsdirhash_dirtrunc(dp, dp->i_endoff);
#endif
		if (tvp != NULL)
			vn_lock(tvp, LK_EXCLUSIVE | LK_RETRY, p);
	}
	return (error);
}

/*
 * Remove a directory entry after a call to namei, using
 * the parameters which it left in nameidata. The entry
 * dp->i_offset contains the offset into the directory of the
 * entry to be eliminated.  The dp->i_count field contains the
 * size of the previous record in the directory.  If this
 * is 0, the first entry is being deleted, so we need only
 * zero the inode number to mark the entry as free.  If the
 * entry is not the first in the directory, we must reclaim
 * the space of the now empty record by adding the record size
 * to the size of the previous entry.
 */
int
ufs_dirremove(struct vnode *dvp, struct inode *ip, int flags, int isrmdir)
{
	struct inode *dp;
	struct direct *ep;
	struct buf *bp;
	int error;

	dp = VTOI(dvp);

	if ((error = UFS_BUFATOFF(dp,
	    (off_t)(dp->i_offset - dp->i_count), (char **)&ep, &bp)) != 0)
		return (error);
#ifdef UFS_DIRHASH
	/*
	 * Remove the dirhash entry. This is complicated by the fact
	 * that `ep' is the previous entry when dp->i_count != 0.
	 */
	if (dp->i_dirhash != NULL)
		ufsdirhash_remove(dp, (dp->i_count == 0) ? ep :
		(struct direct *)((char *)ep + ep->d_reclen), dp->i_offset);
#endif

	if (dp->i_count == 0) {
		/*
		 * First entry in block: set d_ino to zero.
		 */
		ep->d_ino = 0;
	} else {
 		/*
 		 * Collapse new free space into previous entry.
 		 */
 		ep->d_reclen += dp->i_reclen;
	}
#ifdef UFS_DIRHASH
	if (dp->i_dirhash != NULL)
		ufsdirhash_checkblock(dp, (char *)ep -
		    ((dp->i_offset - dp->i_count) & (DIRBLKSIZ - 1)),
		    dp->i_offset & ~(DIRBLKSIZ - 1));
#endif
 	if (DOINGSOFTDEP(dvp)) {
		if (ip) {
			ip->i_effnlink--;
			softdep_change_linkcnt(ip, 0);
			softdep_setup_remove(bp, dp, ip, isrmdir);
		}
		if (softdep_slowdown(dvp)) {
			error = bwrite(bp);
		} else {
			bdwrite(bp);
			error = 0;
		}
 	} else {
		if (ip) {
			ip->i_effnlink--;
			DIP_ADD(ip, nlink, -1);
			ip->i_flag |= IN_CHANGE;
		}
		if (DOINGASYNC(dvp) && dp->i_count != 0) {
			bdwrite(bp);
			error = 0;
		} else
			error = bwrite(bp);
	}
	dp->i_flag |= IN_CHANGE | IN_UPDATE;
	return (error);
}

/*
 * Rewrite an existing directory entry to point at the inode
 * supplied.  The parameters describing the directory entry are
 * set up by a call to namei.
 */
int
ufs_dirrewrite(struct inode *dp, struct inode *oip, ufsino_t newinum,
    int newtype, int isrmdir)
{
	struct buf *bp;
	struct direct *ep;
	struct vnode *vdp = ITOV(dp);
	int error;

	error = UFS_BUFATOFF(dp, (off_t)dp->i_offset, (char **)&ep, &bp);
	if (error)
		return (error);
	ep->d_ino = newinum;
	if (!OFSFMT(dp))
 		ep->d_type = newtype;
 	oip->i_effnlink--;
 	if (DOINGSOFTDEP(vdp)) {
		softdep_change_linkcnt(oip, 0);
 		softdep_setup_directory_change(bp, dp, oip, newinum, isrmdir);
 		bdwrite(bp);
 	} else {
		DIP_ADD(oip, nlink, -1);
		oip->i_flag |= IN_CHANGE;
		if (DOINGASYNC(vdp)) {
			bdwrite(bp);
			error = 0;
		} else {
			error = VOP_BWRITE(bp);
		}
 	}
	dp->i_flag |= IN_CHANGE | IN_UPDATE;
	return (error);
}

/*
 * Check if a directory is empty or not.
 * Inode supplied must be locked.
 *
 * Using a struct dirtemplate here is not precisely
 * what we want, but better than using a struct direct.
 *
 * NB: does not handle corrupted directories.
 */
int
ufs_dirempty(struct inode *ip, ufsino_t parentino, struct ucred *cred)
{
	off_t off, m;
	struct dirtemplate dbuf;
	struct direct *dp = (struct direct *)&dbuf;
	int error, namlen;
	size_t count;
#define	MINDIRSIZ (sizeof (struct dirtemplate) / 2)

	m = DIP(ip, size);
	for (off = 0; off < m; off += dp->d_reclen) {
		error = vn_rdwr(UIO_READ, ITOV(ip), (caddr_t)dp, MINDIRSIZ, off,
		   UIO_SYSSPACE, IO_NODELOCKED, cred, &count, curproc);
		/*
		 * Since we read MINDIRSIZ, residual must
		 * be 0 unless we're at end of file.
		 */
		if (error || count != 0)
			return (0);
		/* avoid infinite loops */
		if (dp->d_reclen == 0)
			return (0);
		/* skip empty entries */
		if (dp->d_ino == 0)
			continue;
		/* accept only "." and ".." */
#		if (BYTE_ORDER == LITTLE_ENDIAN)
			if (OFSFMT(ip))
				namlen = dp->d_type;
			else
				namlen = dp->d_namlen;
#		else
			namlen = dp->d_namlen;
#		endif
		if (namlen > 2)
			return (0);
		if (dp->d_name[0] != '.')
			return (0);
		/*
		 * At this point namlen must be 1 or 2.
		 * 1 implies ".", 2 implies ".." if second
		 * char is also "."
		 */
		if (namlen == 1 && dp->d_ino == ip->i_number)
			continue;
		if (dp->d_name[1] == '.' && dp->d_ino == parentino)
			continue;
		return (0);
	}
	return (1);
}

/*
 * Check if source directory is in the path of the target directory.
 * Target is supplied locked, source is unlocked.
 * The target is always vput before returning.
 */
int
ufs_checkpath(struct inode *source, struct inode *target, struct ucred *cred)
{
	struct vnode *vp;
	int error, rootino, namlen;
	struct dirtemplate dirbuf;

	vp = ITOV(target);
	if (target->i_number == source->i_number) {
		error = EEXIST;
		goto out;
	}
	rootino = ROOTINO;
	error = 0;
	if (target->i_number == rootino)
		goto out;

	for (;;) {
		if (vp->v_type != VDIR) {
			error = ENOTDIR;
			break;
		}
		error = vn_rdwr(UIO_READ, vp, (caddr_t)&dirbuf,
			sizeof (struct dirtemplate), (off_t)0, UIO_SYSSPACE,
			IO_NODELOCKED, cred, NULL, curproc);
		if (error != 0)
			break;
#		if (BYTE_ORDER == LITTLE_ENDIAN)
			if (OFSFMT(VTOI(vp)))
				namlen = dirbuf.dotdot_type;
			else
				namlen = dirbuf.dotdot_namlen;
#		else
			namlen = dirbuf.dotdot_namlen;
#		endif
		if (namlen != 2 ||
		    dirbuf.dotdot_name[0] != '.' ||
		    dirbuf.dotdot_name[1] != '.') {
			error = ENOTDIR;
			break;
		}
		if (dirbuf.dotdot_ino == source->i_number) {
			error = EINVAL;
			break;
		}
		if (dirbuf.dotdot_ino == rootino)
			break;
		vput(vp);
		error = VFS_VGET(vp->v_mount, dirbuf.dotdot_ino, &vp);
		if (error) {
			vp = NULL;
			break;
		}
	}

out:
	if (error == ENOTDIR)
		printf("checkpath: .. not a directory\n");
	if (vp != NULL)
		vput(vp);
	return (error);
}
@


1.49
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.48 2016/02/27 18:50:38 natano Exp $	*/
d500 1
@


1.48
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.47 2015/03/14 03:38:53 jsg Exp $	*/
d425 1
a425 1
			VOP_UNLOCK(vdp, 0, p);
d506 1
a506 1
			VOP_UNLOCK(vdp, 0, p);
d535 1
a535 1
			VOP_UNLOCK(vdp, 0, p);
d562 1
a562 1
		VOP_UNLOCK(pdp, 0, p);	/* race to get the inode */
d586 1
a586 1
			VOP_UNLOCK(pdp, 0, p);
d781 1
a781 1
				VOP_UNLOCK(tvp, 0, p);
d921 1
a921 1
			VOP_UNLOCK(tvp, 0, p);
@


1.47
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.46 2014/12/07 21:12:22 tedu Exp $	*/
d67 1
a67 1
#define FSFMT(vp)	((vp)->v_mount->mnt_maxsymlinklen <= 0)
d303 1
a303 1
				size -= DIRSIZ(FSFMT(vdp), ep);
d327 3
a329 1
				if (vdp->v_mount->mnt_maxsymlinklen > 0)
a330 2
				else
					namlen = ep->d_type;
d444 1
a444 1
	if (dp->i_offset + DIRSIZ(FSFMT(vdp), ep) > DIP(dp, size)) {
d446 1
a446 1
		DIP_ASSIGN(dp, size, dp->i_offset + DIRSIZ(FSFMT(vdp), ep));
d621 1
a621 1
ufs_dirbadentry(struct vnode *dp, struct direct *ep, int entryoffsetinblock)
d623 1
d627 2
d630 3
a632 1
		if (dp->v_mount->mnt_maxsymlinklen > 0)
a633 2
		else
			namlen = ep->d_type;
d639 1
a639 1
	    ep->d_reclen < DIRSIZ(FSFMT(dp), ep) || namlen > MAXNAMLEN) {
d675 1
a675 3
	if (ITOV(ip)->v_mount->mnt_maxsymlinklen > 0)
		newdirp->d_type = IFTODT(DIP(ip, mode));
  	else {
d682 2
a683 1
  	}
d713 1
a713 1
  	newentrysize = DIRSIZ(FSFMT(dvp), dirp);
d828 1
a828 1
	dsize = ep->d_ino ? DIRSIZ(FSFMT(dvp), ep) : 0;
d853 1
a853 1
		dsize = DIRSIZ(FSFMT(dvp), nep);
d1031 1
a1031 1
	if (vdp->v_mount->mnt_maxsymlinklen > 0)
d1089 3
a1091 1
			if (ITOV(ip)->v_mount->mnt_maxsymlinklen > 0)
a1092 2
			else
				namlen = dp->d_type;
d1147 3
a1149 1
			if (vp->v_mount->mnt_maxsymlinklen > 0)
a1150 2
			else
				namlen = dirbuf.dotdot_type;
@


1.46
log
@don't truncate the dirhash if ufs truncate fails.
adapted from a freebsd commit by david hill
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.45 2014/07/08 17:19:26 deraadt Exp $	*/
a44 1
#include <sys/file.h>
@


1.45
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.44 2013/12/12 19:15:32 tedu Exp $	*/
d921 1
d923 1
a923 1
		if (dp->i_dirhash != NULL)
a925 4


		error = UFS_TRUNCATE(dp, (off_t)dp->i_endoff, IO_SYNC, cr);

@


1.44
log
@bcmp -> memcmp
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.43 2013/12/12 19:00:10 tedu Exp $	*/
a49 2

#include <uvm/uvm_extern.h>
@


1.43
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.42 2013/05/30 19:19:09 guenther Exp $	*/
d338 1
a338 2
			    !bcmp(cnp->cn_nameptr, ep->d_name,
				(unsigned)namlen)) {
@


1.42
log
@UFS does't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

otto wrote the original diff for libsa to keep bootblock from overflowing
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.41 2011/09/18 23:20:28 bluhm Exp $	*/
d675 1
a675 1
	bcopy(cnp->cn_nameptr, newdirp->d_name, (unsigned)cnp->cn_namelen + 1);
d741 1
a741 1
		bcopy((caddr_t)dirp, (caddr_t)bp->b_data + blkoff,newentrysize);
d839 1
a839 1
		/* Read nep->d_reclen now as the bcopy() may clobber it. */
d848 1
a848 1
			 * relocated entry since we don't bcopy it.
d867 1
a867 1
 			bcopy((caddr_t)nep, (caddr_t)ep, dsize);
d895 1
a895 1
	bcopy((caddr_t)dirp, (caddr_t)ep, (u_int)newentrysize);
@


1.41
log
@Fix more printf format string bugs in sys/ufs.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.40 2010/09/23 18:49:39 oga Exp $	*/
d1024 2
a1025 2
ufs_dirrewrite(struct inode *dp, struct inode *oip, ino_t newinum, int newtype,
    int isrmdir)
d1067 1
a1067 1
ufs_dirempty(struct inode *ip, ino_t parentino, struct ucred *cred)
@


1.40
log
@The only sensible argument for VOP_* calls that take a struct proc pointer is
curproc. A bunch of callers were passing in 0 (not even NULL, 0) as this
pointer, which was fine until the called vnode function tried to do
something with it. Typically, this code was then copy/pasted to various
parts of the tree.

Accept the facts of life and switch all of these over to passing curproc
for now until the argument can be removed.

Discovered by stsp trying to create a softraid on top of a vnd, which
crashed with a NULL deref in vndioctl.

softraid bits tested by mikeb and jsing. raidframe bits tested by pea,
matthieu and naddy. The rest tested by at least thib, jsing and myself.

ok thib@@, jsing@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.39 2010/04/20 22:05:44 tedu Exp $	*/
d610 1
a610 1
	(void)printf("%s: bad dir ino %d at offset %d: %s\n",
@


1.39
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.38 2009/07/09 22:29:56 thib Exp $	*/
d1079 1
a1079 1
		   UIO_SYSSPACE, IO_NODELOCKED, cred, &count, (struct proc *)0);
d1148 1
a1148 1
			IO_NODELOCKED, cred, NULL, (struct proc *)0);
@


1.38
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.36 2006/11/17 11:09:00 pedro Exp $	*/
d48 1
@


1.37
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d487 1
a487 1
			VREF(vdp);
d582 1
a582 1
		VREF(vdp);	/* we want ourself, ie "." */
@


1.36
log
@There is no need to set IN_CHANGE or IN_UPDATE when no on-disk data is
being touched, fixes PR 3634, okay mickey@@, thib@@ and beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.35 2005/12/28 20:48:18 pedro Exp $	*/
d107 1
a107 5
	struct vop_lookup_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
	} */ *ap = v;
@


1.35
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.34 2005/11/10 22:01:14 pedro Exp $	*/
a416 1
		dp->i_flag |= IN_CHANGE | IN_UPDATE;
@


1.34
log
@Use ANSI function declarations and deregister, no binary change.
Diff from Rui Reis <rui@@rui.cx>, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.33 2005/07/20 16:30:35 pedro Exp $	*/
d153 1
a153 1
	if ((dp->i_ffs_mode & IFMT) != IFDIR)
d209 1
a209 1
		enduseful = dp->i_size;
d217 1
a217 1
					enduseful = dp->i_size;
d231 1
a231 1
			dp->i_offset = roundup2(dp->i_size, DIRBLKSIZ);
d241 1
a241 1
	    dp->i_diroff >= dp->i_ffs_size) {
d254 1
a254 1
	endsearch = roundup(dp->i_ffs_size, DIRBLKSIZ);
d401 1
a401 1
			dp->i_offset = roundup(dp->i_ffs_size, DIRBLKSIZ);
d452 1
a452 1
	if (dp->i_offset + DIRSIZ(FSFMT(vdp), ep) > dp->i_ffs_size) {
d454 1
a454 1
		dp->i_ffs_size = dp->i_offset + DIRSIZ(FSFMT(vdp), ep);
d505 1
a505 1
		if ((dp->i_ffs_mode & ISVTX) &&
d507 2
a508 2
		    cred->cr_uid != dp->i_ffs_uid &&
		    VTOI(tdp)->i_ffs_uid != cred->cr_uid) {
d681 1
a681 1
		newdirp->d_type = IFTODT(ip->i_ffs_mode);
d739 1
a739 1
		dp->i_ffs_size = dp->i_offset + DIRBLKSIZ;
d741 1
a741 1
		uvm_vnp_setsize(dvp, dp->i_ffs_size);
d816 2
a817 2
	if (dp->i_offset + dp->i_count > dp->i_ffs_size)
		dp->i_ffs_size = dp->i_offset + dp->i_count;
d925 1
a925 1
	if (error == 0 && dp->i_endoff && dp->i_endoff < dp->i_ffs_size) {
d1009 1
a1009 1
			ip->i_ffs_nlink--;
d1048 1
a1048 1
 		oip->i_ffs_nlink--;
d1080 1
a1080 1
	m = ip->i_ffs_size;
@


1.33
log
@Reintroduce the changes made by tedu in revision 1.50 of ffs_softdep.c,
this time with a small tweak: when flushing the dependencies, don't
update the inode twice, but update once, and then, if needed, fsync it.
Doing so fixes the inode hangs some people were seeing.

Various testing for a while, especially krw@@ and millert@@, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.32 2005/07/03 20:14:03 drahn Exp $	*/
d105 1
a105 2
ufs_lookup(v)
	void *v;
d112 2
a113 2
	register struct vnode *vdp;	/* vnode for directory being searched */
	register struct inode *dp;	/* inode for directory being searched */
d115 1
a115 1
	register struct direct *ep;	/* the current directory entry */
d609 1
a609 4
ufs_dirbad(ip, offset, how)
	struct inode *ip;
	doff_t offset;
	char *how;
d629 1
a629 4
ufs_dirbadentry(dp, ep, entryoffsetinblock)
	struct vnode *dp;
	register struct direct *ep;
	int entryoffsetinblock;
d631 1
a631 1
	register int i;
d670 2
a671 4
ufs_makedirentry(ip, cnp, newdirp)
  	struct inode *ip;
	struct componentname *cnp;
	struct direct *newdirp;
a672 1
  
d702 2
a703 6
ufs_direnter(dvp, tvp, dirp, cnp, newdirbp)
  	struct vnode *dvp;
	struct vnode *tvp;
  	struct direct *dirp;
 	struct componentname *cnp;
 	struct buf *newdirbp;
d955 1
a955 5
ufs_dirremove(dvp, ip, flags, isrmdir)
	struct vnode *dvp;
	struct inode *ip;
	int flags;
	int isrmdir;
d1028 2
a1029 5
ufs_dirrewrite(dp, oip, newinum, newtype, isrmdir)
	struct inode *dp, *oip;
	ino_t newinum;
	int newtype;
	int isrmdir;
d1071 1
a1071 4
ufs_dirempty(ip, parentino, cred)
	struct inode *ip;
	ino_t parentino;
	struct ucred *cred;
d1129 1
a1129 3
ufs_checkpath(source, target, cred)
	struct inode *source, *target;
	struct ucred *cred;
@


1.32
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.31 2005/06/19 00:44:01 deraadt Exp $	*/
d783 25
a807 6
			softdep_setup_directory_add(bp, dp, dp->i_offset,
			    dirp->d_ino, newdirbp);
			bdwrite(bp);
		} else {
			error = VOP_BWRITE(bp);
  		}
d922 3
a924 2
  		softdep_setup_directory_add(bp, dp,
  		    dp->i_offset + (caddr_t)ep - dirbuf, dirp->d_ino, newdirbp);
@


1.31
log
@wrap a goto label in the proper #ifdef
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.30 2005/06/18 18:09:43 millert Exp $	*/
a51 1
#include <ufs/ufs/extattr.h>
@


1.30
log
@Remove remaining whiteout tentacles; OK deraadt@@ miod@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.29 2005/06/10 17:37:41 pedro Exp $	*/
d364 1
d366 1
@


1.29
log
@Tweak softdep_change_linkcnt() so we can specify whether we're willing
to be co-opted by softdep or not, and use this new interface to inform
softdep in ufs_inactive() that the inode mode has changed.

We don't want to be co-opted there as that might lead to undesired
circular dependencies such as a vput() depending on another vput() to
complete, or a process that is trying to free up a vnode being blocked
trying to acquire a new vnode.

Okay tedu@@ deraadt@@, thanks to all those who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.28 2004/12/07 04:37:28 tedu Exp $	*/
a352 27
				if (vdp->v_mount->mnt_maxsymlinklen > 0 &&
				    ep->d_type == DT_WHT) {
					slotstatus = FOUND;
					slotoffset = dp->i_offset;
					slotsize = ep->d_reclen;
					dp->i_reclen = slotsize;
					/*
					 * This is used to set dp->i_endoff,
					 * which may be used by ufs_direnter2()
					 * as a length to truncate the
					 * directory to.  Therefore, it must
					 * point past the end of the last
					 * non-empty directory entry.  We don't
					 * know where that is in this case, so
					 * we effectively disable shrinking by
					 * using the existing size of the
					 * directory.
					 *
					 * Note that we wouldn't expect to
					 * shrink the directory while rewriting
					 * an existing entry anyway.
					 */
					enduseful = endsearch;
					ap->a_cnp->cn_flags |= ISWHITEOUT;
					numdirpasses--;
					goto notfound;
				}
d382 1
a382 4
	if ((nameiop == CREATE || nameiop == RENAME ||
	     (nameiop == DELETE &&
	      (ap->a_cnp->cn_flags & DOWHITEOUT) &&
	      (ap->a_cnp->cn_flags & ISWHITEOUT))) &&
d876 1
a876 3
	if (ep->d_ino == 0 ||
	    (ep->d_ino == WINO &&
	     bcmp(ep->d_name, dirp->d_name, dirp->d_namlen) == 0)) {
a960 13
	if (flags & DOWHITEOUT) {
		/*
		 * Whiteout entry: set d_ino to WINO.
		 */
		error = UFS_BUFATOFF(dp, (off_t)dp->i_offset, (char **)&ep,
				     &bp);
		if (error)
			return (error);
		ep->d_ino = WINO;
		ep->d_type = DT_WHT;
		goto out;
	}

a990 1
out:
d1009 1
a1009 3
		if (flags & DOWHITEOUT)
			error = bwrite(bp);
		else if (DOINGASYNC(dvp) && dp->i_count != 0) {
d1097 1
a1097 1
		if (dp->d_ino == 0 || dp->d_ino == WINO)
@


1.28
log
@prev softdep merge could lead to inode wait deadlock for unknown reasons.
revert.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.27 2004/05/07 01:40:17 tedu Exp $	*/
d1040 1
a1040 1
			softdep_change_linkcnt(ip);
d1092 1
a1092 1
		softdep_change_linkcnt(oip);
@


1.27
log
@fatty softdep merge with freebsd.  fixes a variety of possible issues.
relevant changes to ffs_softdep.c were 1.95, 1.96, 1.97, 1.98, 1.103, and
1.107 in freebsd.  testing marc and otto.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.26 2004/04/16 22:41:50 tedu Exp $	*/
d812 6
a817 25
			if (softdep_setup_directory_add(bp, dp, dp->i_offset,
			    dirp->d_ino, newdirbp, 1) == 0) {
				bdwrite(bp);
				return (UFS_UPDATE(dp, 0));
			}
			/* We have just allocated a directory block in an
			 * indirect block. Rather than tracking when it gets
			 * claimed by the inode, we simply do a VOP_FSYNC
			 * now to ensure that it is there (in case the user
			 * does a future fsync). Note that we have to unlock
			 * the inode for the entry that we just entered, as
			 * the VOP_FSYNC may need to lock other inodes which
			 * can lead to deadlock if we also hold a lock on
			 * the newly entered node.
			 */
			if ((error = VOP_BWRITE(bp)))
				return (error);
			if (tvp != NULL)
				VOP_UNLOCK(tvp, 0, p);
			error = VOP_FSYNC(dvp, p->p_ucred, MNT_WAIT, p);
			if (tvp != NULL)
				vn_lock(tvp, LK_EXCLUSIVE | LK_RETRY, p);
			return (error);
		}
		error = VOP_BWRITE(bp);
d934 2
a935 3
  		(void)softdep_setup_directory_add(bp, dp,
  		    dp->i_offset + (caddr_t)ep - dirbuf,
		    dirp->d_ino, newdirbp, 0);
@


1.26
log
@fix niklas's panic and pr3672 with freebsd rev 1.54 (don't trust DIRSIZ)
extra testing otto@@ sturm@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.25 2004/01/09 03:01:03 tedu Exp $	*/
d812 25
a836 6
			softdep_setup_directory_add(bp, dp, dp->i_offset,
			    dirp->d_ino, newdirbp);
			bdwrite(bp);
		} else {
			error = VOP_BWRITE(bp);
  		}
d953 3
a955 2
  		softdep_setup_directory_add(bp, dp,
  		    dp->i_offset + (caddr_t)ep - dirbuf, dirp->d_ino, newdirbp);
@


1.25
log
@back out vnode parents.  weird breakge found in ports tree
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.24 2004/01/06 04:22:59 tedu Exp $	*/
d858 1
a858 1
	dsize = DIRSIZ(FSFMT(dvp), ep);
d862 20
a881 7
		if (ep->d_ino) {
			/* trim the existing slot */
			ep->d_reclen = dsize;
			ep = (struct direct *)((char *)ep + dsize);
		} else {
			/* overwrite; nothing there; header is ours */
			spacefree += dsize;
a884 1
		loc += nep->d_reclen;
d898 5
@


1.25.2.1
log
@MFC:
Fix by tedu@@

fix niklas's panic and pr3672 with freebsd rev 1.54 (don't trust DIRSIZ)
extra testing otto@@ sturm@@ tdeval@@

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.25 2004/01/09 03:01:03 tedu Exp $	*/
d858 1
a858 1
	dsize = ep->d_ino ? DIRSIZ(FSFMT(dvp), ep) : 0;
d862 7
a868 20

		/* Trim the existing slot (NB: dsize may be zero). */
		ep->d_reclen = dsize;
		ep = (struct direct *)((char *)ep + dsize);

		/* Read nep->d_reclen now as the bcopy() may clobber it. */
		loc += nep->d_reclen;
		if (nep->d_ino == 0) {
			/*
			 * A mid-block unused entry. Such entries are
			 * never created by the kernel, but fsck_ffs
			 * can create them (and it doesn't fix them).
			 *
			 * Add up the free space, and initialise the
			 * relocated entry since we don't bcopy it.
			 */
			spacefree += nep->d_reclen;
			ep->d_ino = 0;
			dsize = 0;
			continue;
d872 1
a885 5
	 * Here, `ep' points to a directory entry containing `dsize' in-use
	 * bytes followed by `spacefree' unused bytes. If ep->d_ino == 0,
	 * then the entry is completely unused (dsize == 0). The value
	 * of ep->d_reclen is always indeterminate.
	 *
@


1.24
log
@keep track of a vnode's parent dir.  ufs only, and unused atm, but
the fun stuff is coming.  testing by brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.23 2003/12/28 17:20:16 tedu Exp $	*/
a626 4
		vref(vdp);
		if (tdp->v_parent)
			vrele(tdp->v_parent);
		tdp->v_parent = vdp;
@


1.23
log
@add ian dowse's dirhash code from freebsd.
by building a hash table for large directories, lookups and deletions
become about constant time.  this is an excellent improvement for dirs with
10k or more files.
some more cleanup to come, but the code works.
enabled with option UFS_DIRHASH
testing brad millert otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.22 2003/06/02 23:28:23 millert Exp $	*/
d627 4
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.21 2003/02/12 14:41:08 jason Exp $	*/
d56 3
d201 41
d345 3
d789 10
d873 6
d902 6
d909 6
d934 1
a934 1
	        if (tvp != NULL)
d936 5
d989 12
a1000 3
 	if ((error = UFS_BUFATOFF(dp,
 	    (off_t)(dp->i_offset - dp->i_count), (char **)&ep, &bp)) != 0)
 		return (error);
d1013 6
@


1.21
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.20 2003/01/31 17:37:50 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.20
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.19 2002/02/22 20:37:46 drahn Exp $	*/
d63 2
a64 1
struct	nchstats nchstats;
@


1.19
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.18 2001/11/06 19:53:21 miod Exp $	*/
d137 1
a137 1
	int flags = cnp->cn_flags;
d141 3
d171 2
a172 45
	if ((error = cache_lookup(vdp, vpp, cnp)) != 0) {
		int vpid;	/* capability number of vnode */

		if (error == ENOENT)
			return (error);
		/*
		 * Get the next vnode in the path.
		 * See comment below starting `Step through' for
		 * an explaination of the locking protocol.
		 */
		pdp = vdp;
		dp = VTOI(*vpp);
		vdp = *vpp;
		vpid = vdp->v_id;
		if (pdp == vdp) {   /* lookup on "." */
			VREF(vdp);
			error = 0;
		} else if (flags & ISDOTDOT) {
			VOP_UNLOCK(pdp, 0, p);
			error = vget(vdp, LK_EXCLUSIVE, p);
			if (!error && lockparent && (flags & ISLASTCN))
				error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
		} else {
			error = vget(vdp, LK_EXCLUSIVE, p);
			if (!lockparent || error || !(flags & ISLASTCN))
				VOP_UNLOCK(pdp, 0, p);
		}
		/*
		 * Check that the capability number did not change
		 * while we were waiting for the lock.
		 */
		if (!error) {
			if (vpid == vdp->v_id)
				return (0);
			vput(vdp);
			if (lockparent && pdp != vdp && (flags & ISLASTCN))
				VOP_UNLOCK(pdp, 0, p);
		}
		*vpp = NULL;

		if ((error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p)) != 0)
			return (error);
		vdp = pdp;
		dp = VTOI(pdp);
	}
d418 1
a418 1
		if (!lockparent)
d420 2
d499 1
a499 1
		if (!lockparent)
d501 2
d528 1
a528 1
		if (!lockparent)
d530 2
d557 1
d560 2
a561 1
			vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
d564 6
a569 4
		if (lockparent && (flags & ISLASTCN) &&
		    (error = vn_lock(pdp, LK_EXCLUSIVE, p))) {
			vput(tdp);
			return (error);
d579 1
a579 1
		if (!lockparent || !(flags & ISLASTCN))
d581 2
@


1.18
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.17 2001/06/27 04:58:49 art Exp $	*/
d56 1
@


1.18.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.18 2001/11/06 19:53:21 miod Exp $	*/
a55 1
#include <ufs/ufs/extattr.h>
@


1.18.2.2
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.18.2.1 2002/06/11 03:32:50 art Exp $	*/
d792 1
a792 1
 		ret = UFS_UPDATE(dp, UPDATE_DIROP);
@


1.18.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
a63 2
extern	struct nchstats nchstats;

d137 1
a137 1
	int flags;
a140 3
	cnp->cn_flags &= ~PDIRUNLOCK;
	flags = cnp->cn_flags;

d168 45
a212 2
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);
d458 1
a458 1
		if (!lockparent) {
a459 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
d537 1
a537 1
		if (!lockparent) {
a538 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
d564 1
a564 1
		if (!lockparent) {
a565 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
a590 1
		cnp->cn_flags |= PDIRUNLOCK;
d593 1
a593 2
			if (vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
d596 4
a599 6
		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(pdp, LK_EXCLUSIVE, p))) {
				vput(tdp);
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
d609 1
a609 1
		if (!lockparent || !(flags & ISLASTCN)) {
a610 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
@


1.17
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.16 2001/06/23 02:07:57 csapuntz Exp $	*/
d54 1
a54 1
#include <vm/vm.h>
@


1.16
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.15 2001/02/27 09:52:56 art Exp $	*/
a766 1
#if defined(UVM)
a767 3
#else
		vnode_pager_setsize(dvp, (u_long)dp->i_ffs_size);
#endif
@


1.15
log
@Cosmetic fixes.
From FreeBSD, through NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.14 2001/02/27 09:47:55 art Exp $	*/
d248 1
a248 1
		    (error = VOP_BLKATOFF(vdp, (off_t)dp->i_offset, NULL, &bp)))
d265 1
a265 1
			error = VOP_BLKATOFF(vdp, (off_t)dp->i_offset, NULL,
a739 1
	struct timespec ts;
d759 1
a759 1
		if ((error = VOP_BALLOC(dvp, (off_t)dp->i_offset, DIRBLKSIZ,
d795 1
a795 2
		TIMEVAL_TO_TIMESPEC(&time, &ts);
 		ret = VOP_UPDATE(dvp, &ts, &ts, !DOINGSOFTDEP(dvp));
d822 1
a822 1
 	if ((error = VOP_BLKATOFF(dvp, (off_t)dp->i_offset, &dirbuf, &bp)) 
d896 1
a896 1
		error = VOP_TRUNCATE(dvp, (off_t)dp->i_endoff, IO_SYNC, cr, p);
d934 1
a934 1
		error = VOP_BLKATOFF(dvp, (off_t)dp->i_offset, (char **)&ep,
d943 1
a943 1
 	if ((error = VOP_BLKATOFF(dvp,
d1006 1
a1006 1
	error = VOP_BLKATOFF(vdp, (off_t)dp->i_offset, (char **)&ep, &bp);
@


1.14
log
@Move a brelse to after the last access to bp->b_data.
I found this in 1998. Why didn't I commit it then?
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.13 2001/02/21 23:24:31 csapuntz Exp $	*/
d241 1
a241 1
	    dp->i_diroff > dp->i_ffs_size) {
d475 1
a475 1
	if (entryoffsetinblock + DIRSIZ(FSFMT(vdp), ep) > dp->i_ffs_size) {
d477 1
a477 1
		dp->i_ffs_size = entryoffsetinblock + DIRSIZ(FSFMT(vdp), ep);
@


1.13
log
@

Latest soft updates from FreeBSD/Kirk McKusick

Snapshot-related code has been commented out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.12 1999/02/26 03:35:18 art Exp $	*/
a376 1
				brelse(bp);
d480 1
@


1.12
log
@compat with uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.11 1998/07/28 00:13:17 millert Exp $	*/
a960 4
 	if (ip) {
 		ip->i_effnlink--;
 		ip->i_flag |= IN_CHANGE;
 	}
d962 11
a972 3
 		if (ip)
 			softdep_setup_remove(bp, dp, ip, isrmdir);
 		bdwrite(bp);
d974 12
a985 4
 		if (ip)
 			ip->i_ffs_nlink--;   /* XXX */

		error = VOP_BWRITE(bp);
a1014 1
 	oip->i_flag |= IN_CHANGE;
d1016 1
d1020 8
a1027 2
 		oip->i_ffs_nlink--; /* XXX */
 		error = VOP_BWRITE(bp);
@


1.12.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.15 2001/02/27 09:52:56 art Exp $	*/
d241 1
a241 1
	    dp->i_diroff >= dp->i_ffs_size) {
d377 1
d476 1
a476 1
	if (dp->i_offset + DIRSIZ(FSFMT(vdp), ep) > dp->i_ffs_size) {
d478 1
a478 1
		dp->i_ffs_size = dp->i_offset + DIRSIZ(FSFMT(vdp), ep);
a480 1
	brelse(bp);
d961 4
d966 3
a968 11
		if (ip) {
			ip->i_effnlink--;
			softdep_change_linkcnt(ip);
			softdep_setup_remove(bp, dp, ip, isrmdir);
		}
		if (softdep_slowdown(dvp)) {
			error = bwrite(bp);
		} else {
			bdwrite(bp);
			error = 0;
		}
d970 4
a973 12
		if (ip) {
			ip->i_effnlink--;
			ip->i_ffs_nlink--;
			ip->i_flag |= IN_CHANGE;
		}
		if (flags & DOWHITEOUT)
			error = bwrite(bp);
		else if (DOINGASYNC(dvp) && dp->i_count != 0) {
			bdwrite(bp);
			error = 0;
		} else
			error = bwrite(bp);
d1003 1
a1004 1
		softdep_change_linkcnt(oip);
d1008 2
a1009 8
 		oip->i_ffs_nlink--;
		oip->i_flag |= IN_CHANGE;
		if (DOINGASYNC(vdp)) {
			bdwrite(bp);
			error = 0;
		} else {
			error = VOP_BWRITE(bp);
		}
@


1.12.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.12.6.1 2001/05/14 22:47:43 niklas Exp $	*/
d248 1
a248 1
		    (error = UFS_BUFATOFF(dp, (off_t)dp->i_offset, NULL, &bp)))
d265 1
a265 1
			error = UFS_BUFATOFF(dp, (off_t)dp->i_offset, NULL,
d740 1
d760 1
a760 1
		if ((error = UFS_BUF_ALLOC(dp, (off_t)dp->i_offset, DIRBLKSIZ,
d768 1
d770 3
d796 2
a797 1
 		ret = UFS_UPDATE(dp, !DOINGSOFTDEP(dvp));
d824 1
a824 1
 	if ((error = UFS_BUFATOFF(dp, (off_t)dp->i_offset, &dirbuf, &bp)) 
d898 1
a898 1
		error = UFS_TRUNCATE(dp, (off_t)dp->i_endoff, IO_SYNC, cr);
d936 1
a936 1
		error = UFS_BUFATOFF(dp, (off_t)dp->i_offset, (char **)&ep,
d945 1
a945 1
 	if ((error = UFS_BUFATOFF(dp,
d1008 1
a1008 1
	error = UFS_BUFATOFF(dp, (off_t)dp->i_offset, (char **)&ep, &bp);
@


1.12.6.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
a54 1
#include <uvm/uvm_extern.h>
@


1.12.6.4
log
@Merge in trunk
@
text
@a55 1
#include <ufs/ufs/extattr.h>
@


1.12.6.5
log
@Sync the SMP branch with 3.3
@
text
@d63 1
a63 2
extern	struct nchstats nchstats;

d137 1
a137 1
	int flags;
a140 3
	cnp->cn_flags &= ~PDIRUNLOCK;
	flags = cnp->cn_flags;

d168 45
a212 2
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);
d458 1
a458 1
		if (!lockparent) {
a459 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
d537 1
a537 1
		if (!lockparent) {
a538 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
d564 1
a564 1
		if (!lockparent) {
a565 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
a590 1
		cnp->cn_flags |= PDIRUNLOCK;
d593 1
a593 2
			if (vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
d596 4
a599 6
		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(pdp, LK_EXCLUSIVE, p))) {
				vput(tdp);
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
d609 1
a609 1
		if (!lockparent || !(flags & ISLASTCN)) {
a610 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
@


1.12.6.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.12.6.5 2003/03/28 00:08:48 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12.6.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a55 3
#ifdef UFS_DIRHASH
#include <ufs/ufs/dirhash.h>
#endif
a197 41

#ifdef UFS_DIRHASH
	/*
	 * Use dirhash for fast operations on large directories. The logic
	 * to determine whether to hash the directory is contained within
	 * ufsdirhash_build(); a zero return means that it decided to hash
	 * this directory and it successfully built up the hash table.
	 */
	if (ufsdirhash_build(dp) == 0) {
		/* Look for a free slot if needed. */
		enduseful = dp->i_size;
		if (slotstatus != FOUND) {
			slotoffset = ufsdirhash_findfree(dp, slotneeded,
			    &slotsize);
			if (slotoffset >= 0) {
				slotstatus = COMPACT;
				enduseful = ufsdirhash_enduseful(dp);
				if (enduseful < 0)
					enduseful = dp->i_size;
			}
		}
		/* Look up the component. */
		numdirpasses = 1;
		entryoffsetinblock = 0; /* silence compiler warning */
		switch (ufsdirhash_lookup(dp, cnp->cn_nameptr, cnp->cn_namelen,
		    &dp->i_offset, &bp, nameiop == DELETE ? &prevoff : NULL)) {
		case 0:
			ep = (struct direct *)((char *)bp->b_data +
			    (dp->i_offset & bmask));
			goto foundentry;
		case ENOENT:
#define roundup2(x, y)	(((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */
			dp->i_offset = roundup2(dp->i_size, DIRBLKSIZ);
			goto notfound;
		default:
			/* Something failed; just do a linear search. */
			break;
		}
	}
#endif /* UFS_DIRHASH */

a300 3
#ifdef UFS_DIRHASH
foundentry:
#endif
a741 10

#ifdef UFS_DIRHASH
		if (dp->i_dirhash != NULL) {
			ufsdirhash_newblk(dp, dp->i_offset);
			ufsdirhash_add(dp, dirp, dp->i_offset);
			ufsdirhash_checkblock(dp, (char *)bp->b_data + blkoff,
			dp->i_offset);
		}
#endif

a815 6
#ifdef UFS_DIRHASH
		if (dp->i_dirhash != NULL)
			ufsdirhash_move(dp, nep,
			    dp->i_offset + ((char *)nep - dirbuf),
			    dp->i_offset + ((char *)ep - dirbuf));
#endif
a838 6

#ifdef UFS_DIRHASH
	if (dp->i_dirhash != NULL && (ep->d_ino == 0 ||
	    dirp->d_reclen == spacefree))
		ufsdirhash_add(dp, dirp, dp->i_offset + ((char *)ep - dirbuf));
#endif
a839 6
#ifdef UFS_DIRHASH
	if (dp->i_dirhash != NULL)
		ufsdirhash_checkblock(dp, dirbuf -
		    (dp->i_offset & (DIRBLKSIZ - 1)),
		    dp->i_offset & ~(DIRBLKSIZ - 1));
#endif
d859 1
a859 1
		if (tvp != NULL)
a860 5
#ifdef UFS_DIRHASH
		if (dp->i_dirhash != NULL)
			ufsdirhash_dirtrunc(dp, dp->i_endoff);
#endif

d909 3
a911 12
	if ((error = UFS_BUFATOFF(dp,
	    (off_t)(dp->i_offset - dp->i_count), (char **)&ep, &bp)) != 0)
		return (error);
#ifdef UFS_DIRHASH
	/*
	 * Remove the dirhash entry. This is complicated by the fact
	 * that `ep' is the previous entry when dp->i_count != 0.
	 */
	if (dp->i_dirhash != NULL)
		ufsdirhash_remove(dp, (dp->i_count == 0) ? ep :
		(struct direct *)((char *)ep + ep->d_reclen), dp->i_offset);
#endif
a923 6
#ifdef UFS_DIRHASH
	if (dp->i_dirhash != NULL)
		ufsdirhash_checkblock(dp, (char *)ep -
		    ((dp->i_offset - dp->i_count) & (DIRBLKSIZ - 1)),
		    dp->i_offset & ~(DIRBLKSIZ - 1));
#endif
@


1.12.6.8
log
@Merge with the trunk
@
text
@d812 6
a817 25
			if (softdep_setup_directory_add(bp, dp, dp->i_offset,
			    dirp->d_ino, newdirbp, 1) == 0) {
				bdwrite(bp);
				return (UFS_UPDATE(dp, 0));
			}
			/* We have just allocated a directory block in an
			 * indirect block. Rather than tracking when it gets
			 * claimed by the inode, we simply do a VOP_FSYNC
			 * now to ensure that it is there (in case the user
			 * does a future fsync). Note that we have to unlock
			 * the inode for the entry that we just entered, as
			 * the VOP_FSYNC may need to lock other inodes which
			 * can lead to deadlock if we also hold a lock on
			 * the newly entered node.
			 */
			if ((error = VOP_BWRITE(bp)))
				return (error);
			if (tvp != NULL)
				VOP_UNLOCK(tvp, 0, p);
			error = VOP_FSYNC(dvp, p->p_ucred, MNT_WAIT, p);
			if (tvp != NULL)
				vn_lock(tvp, LK_EXCLUSIVE | LK_RETRY, p);
			return (error);
		}
		error = VOP_BWRITE(bp);
d858 1
a858 1
	dsize = ep->d_ino ? DIRSIZ(FSFMT(dvp), ep) : 0;
d862 7
a868 20

		/* Trim the existing slot (NB: dsize may be zero). */
		ep->d_reclen = dsize;
		ep = (struct direct *)((char *)ep + dsize);

		/* Read nep->d_reclen now as the bcopy() may clobber it. */
		loc += nep->d_reclen;
		if (nep->d_ino == 0) {
			/*
			 * A mid-block unused entry. Such entries are
			 * never created by the kernel, but fsck_ffs
			 * can create them (and it doesn't fix them).
			 *
			 * Add up the free space, and initialise the
			 * relocated entry since we don't bcopy it.
			 */
			spacefree += nep->d_reclen;
			ep->d_ino = 0;
			dsize = 0;
			continue;
d872 1
a885 5
	 * Here, `ep' points to a directory entry containing `dsize' in-use
	 * bytes followed by `spacefree' unused bytes. If ep->d_ino == 0,
	 * then the entry is completely unused (dsize == 0). The value
	 * of ep->d_reclen is always indeterminate.
	 *
d917 2
a918 3
  		(void)softdep_setup_directory_add(bp, dp,
  		    dp->i_offset + (caddr_t)ep - dirbuf,
		    dirp->d_ino, newdirbp, 0);
@


1.11
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.10 1997/12/11 04:25:45 csapuntz Exp $	*/
d768 3
d772 1
@


1.10
log
@Fix rename in a better way
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.9 1997/12/11 01:03:17 csapuntz Exp $	*/
d1029 2
a1030 1
	int error, count, namlen;
d1107 1
a1107 1
			IO_NODELOCKED, cred, (int *)0, (struct proc *)0);
@


1.9
log
@Earlier patch broke rename. Disalbed it temporarily as I search for a solution.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.8 1997/12/02 17:11:11 csapuntz Exp $	*/
a890 1
#if 0  /* This code is breaking rename */
a892 1
#endif
d895 1
a895 1
#if 0
a897 1
#endif
@


1.8
log
@Unlock child temporarily while truncating directory. This prevents
a double locking bug in the soft updates code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.7 1997/11/06 05:59:27 csapuntz Exp $	*/
d891 1
d894 1
d897 1
d900 1
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.6 1997/10/06 20:21:47 deraadt Exp $	*/
d724 1
a724 1
ufs_direnter(dvp, dirp, cnp, newdirbp)
d726 1
d881 13
a893 1
	if (error == 0 && dp->i_endoff && dp->i_endoff < dp->i_ffs_size)
d895 3
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.4 1997/05/30 08:35:08 downsj Exp $	*/
d46 1
d50 1
d54 2
d138 1
d156 4
d185 2
a186 2
			VOP_UNLOCK(pdp);
			error = vget(vdp, 1);
d188 1
a188 1
				error = VOP_LOCK(pdp);
d190 1
a190 1
			error = vget(vdp, 1);
d192 1
a192 1
				VOP_UNLOCK(pdp);
d203 1
a203 1
				VOP_UNLOCK(pdp);
d205 3
a207 1
		if ((error = VOP_LOCK(pdp)) != 0)
a210 1
		*vpp = NULL;
d409 1
a409 1
	    (flags & ISLASTCN) && dp->i_ffs_nlink != 0) {
d459 1
a459 1
			VOP_UNLOCK(vdp);
d537 1
a537 1
			VOP_UNLOCK(vdp);
d564 1
a564 1
			VOP_UNLOCK(vdp);
d589 1
a589 1
		VOP_UNLOCK(pdp);	/* race to get the inode */
d592 1
a592 1
			VOP_LOCK(pdp);
d596 1
a596 1
		    (error = VOP_LOCK(pdp))) {
d609 1
a609 1
			VOP_UNLOCK(pdp);
d684 3
a686 6
 * Write a directory entry after a call to namei, using the parameters
 * that it left in nameidata.  The argument ip is the inode which the new
 * directory entry will refer to.  Dvp is a pointer to the directory to
 * be written, which was left locked by namei. Remaining parameters
 * (dp->i_offset, dp->i_count) indicate how the space for the new
 * entry is to be obtained.
d688 5
a692 5
int
ufs_direnter(ip, dvp, cnp)
	struct inode *ip;
	struct vnode *dvp;
	register struct componentname *cnp;
d694 1
a694 3
	register struct inode *dp;
	struct direct newdir;

d696 2
a697 2
	if ((cnp->cn_flags & SAVENAME) == 0)
		panic("direnter: missing name");
d699 7
a705 8
	dp = VTOI(dvp);
	newdir.d_ino = ip->i_number;
	newdir.d_namlen = cnp->cn_namelen;
	bcopy(cnp->cn_nameptr, newdir.d_name, (unsigned)cnp->cn_namelen + 1);
	if (dvp->v_mount->mnt_maxsymlinklen > 0)
		newdir.d_type = IFTODT(ip->i_ffs_mode);
	else {
		newdir.d_type = 0;
d707 3
a709 3
			{ u_char tmp = newdir.d_namlen;
			newdir.d_namlen = newdir.d_type;
			newdir.d_type = tmp; }
d711 1
a711 2
	}
	return (ufs_direnter2(dvp, &newdir, cnp->cn_cred, cnp->cn_proc));
d713 1
a713 1

d715 7
a721 2
 * Common entry point for directory entry removal used by ufs_direnter
 * and ufs_whiteout
d724 5
a728 5
ufs_direnter2(dvp, dirp, cr, p)
	struct vnode *dvp;
	struct direct *dirp;
	struct ucred *cr;
	struct proc *p;
d730 16
a745 12
	int newentrysize;
	struct inode *dp;
	struct buf *bp;
	struct iovec aiov;
	struct uio auio;
	u_int dsize;
	struct direct *ep, *nep;
	int error, loc, spacefree;
	char *dirbuf;

	dp = VTOI(dvp);
	newentrysize = DIRSIZ(FSFMT(dvp), dirp);
d752 12
a763 22
		 * new entry into a fresh block.
		 */
		if (dp->i_offset & (DIRBLKSIZ - 1))
			panic("ufs_direnter2: newblk");
		auio.uio_offset = dp->i_offset;
		dirp->d_reclen = DIRBLKSIZ;
		auio.uio_resid = newentrysize;
		aiov.iov_len = newentrysize;
		aiov.iov_base = (caddr_t)dirp;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_rw = UIO_WRITE;
		auio.uio_segflg = UIO_SYSSPACE;
		auio.uio_procp = (struct proc *)0;
		error = VOP_WRITE(dvp, &auio, IO_SYNC, cr);
		if (DIRBLKSIZ >
		    VFSTOUFS(dvp->v_mount)->um_mountp->mnt_stat.f_bsize)
			/* XXX should grow with balloc() */
			panic("ufs_direnter2: frag size");
		else if (!error) {
			dp->i_ffs_size = roundup(dp->i_ffs_size, DIRBLKSIZ);
			dp->i_flag |= IN_CHANGE;
d765 43
a807 13
		return (error);
	}

	/*
	 * If dp->i_count is non-zero, then namei found space
	 * for the new entry in the range dp->i_offset to
	 * dp->i_offset + dp->i_count in the directory.
	 * To use this space, we may have to compact the entries located
	 * there, by copying them together towards the beginning of the
	 * block, leaving the free space in one usable chunk at the end.
	 */

	/*
d819 6
a824 3
	error = VOP_BLKATOFF(dvp, (off_t)dp->i_offset, &dirbuf, &bp);
	if (error)
		return (error);
d829 1
a829 2
	 * dp->i_offset + dp->i_count would yield the
	 * space.
d847 5
a851 1
		bcopy((caddr_t)nep, (caddr_t)ep, dsize);
d861 1
a861 1
			panic("ufs_direnter2: compact1");
d865 1
a865 1
			panic("ufs_direnter2: compact2");
d871 8
a878 1
	error = VOP_BWRITE(bp);
d880 1
a880 1
	if (!error && dp->i_endoff && dp->i_endoff < dp->i_ffs_size)
d898 1
a898 1
ufs_dirremove(dvp, cnp)
d900 3
a902 1
	struct componentname *cnp;
d904 1
a904 1
	register struct inode *dp;
d911 1
a911 1
	if (cnp->cn_flags & DOWHITEOUT) {
d921 1
a921 3
		error = VOP_BWRITE(bp);
		dp->i_flag |= IN_CHANGE | IN_UPDATE;
		return (error);
d924 4
a931 4
		error = VOP_BLKATOFF(dvp, (off_t)dp->i_offset, (char **)&ep,
				     &bp);
		if (error)
			return (error);
d933 19
a952 2
		dp->i_flag |= IN_CHANGE | IN_UPDATE;
		return (error);
a953 9
	/*
	 * Collapse new free space into previous entry.
	 */
	error = VOP_BLKATOFF(dvp, (off_t)(dp->i_offset - dp->i_count),
			     (char **)&ep, &bp);
	if (error)
		return (error);
	ep->d_reclen += dp->i_reclen;
	error = VOP_BWRITE(bp);
d964 5
a968 3
ufs_dirrewrite(dp, ip, cnp)
	struct inode *dp, *ip;
	struct componentname *cnp;
d978 1
a978 1
	ep->d_ino = ip->i_number;
d980 10
a989 2
		ep->d_type = IFTODT(ip->i_ffs_mode);
	error = VOP_BWRITE(bp);
d1049 1
a1049 1
		if (namlen == 1)
@


1.5
log
@VFS Lite2 Changes
@
text
@a45 1
#include <sys/kernel.h>
a48 1
#include <sys/stat.h>
a51 2
#include <vm/vm.h>

a133 1
	struct proc *p = cnp->cn_proc;
a150 4
	if ((flags & ISLASTCN) && (vdp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);

d176 2
a177 2
			VOP_UNLOCK(pdp, 0, p);
			error = vget(vdp, LK_EXCLUSIVE, p);
d179 1
a179 1
				error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
d181 1
a181 1
			error = vget(vdp, LK_EXCLUSIVE, p);
d183 1
a183 1
				VOP_UNLOCK(pdp, 0, p);
d194 1
a194 1
				VOP_UNLOCK(pdp, 0, p);
d196 1
a196 3
		*vpp = NULL;

		if ((error = vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p)) != 0)
d200 1
d399 1
a399 1
	    (flags & ISLASTCN) && dp->i_effnlink != 0) {
d449 1
a449 1
			VOP_UNLOCK(vdp, 0, p);
d527 1
a527 1
			VOP_UNLOCK(vdp, 0, p);
d554 1
a554 1
			VOP_UNLOCK(vdp, 0, p);
d579 1
a579 1
		VOP_UNLOCK(pdp, 0, p);	/* race to get the inode */
d582 1
a582 1
			vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
d586 1
a586 1
		    (error = vn_lock(pdp, LK_EXCLUSIVE, p))) {
d599 1
a599 1
			VOP_UNLOCK(pdp, 0, p);
d674 6
a679 3
 * Construct a new directory entry after a call to namei, using the
 * parameters that it left in the componentname argument cnp. The
 * argument ip is the inode to which the new directory entry will refer.
d681 5
a685 5
void
ufs_makedirentry(ip, cnp, newdirp)
  	struct inode *ip;
	struct componentname *cnp;
	struct direct *newdirp;
d687 3
a689 1
  
d691 2
a692 2
  	if ((cnp->cn_flags & SAVENAME) == 0)
		panic("ufs_makedirentry: missing name");
d694 8
a701 7
	newdirp->d_ino = ip->i_number;
	newdirp->d_namlen = cnp->cn_namelen;
	bcopy(cnp->cn_nameptr, newdirp->d_name, (unsigned)cnp->cn_namelen + 1);
	if (ITOV(ip)->v_mount->mnt_maxsymlinklen > 0)
		newdirp->d_type = IFTODT(ip->i_ffs_mode);
  	else {
		newdirp->d_type = 0;
d703 3
a705 3
			{ u_char tmp = newdirp->d_namlen;
			newdirp->d_namlen = newdirp->d_type;
			newdirp->d_type = tmp; }
d707 2
a708 1
  	}
d710 1
a710 1
  
d712 2
a713 7
 * Write a directory entry after a call to namei, using the parameters
 * that it left in nameidata. The argument dirp is the new directory
 * entry contents. Dvp is a pointer to the directory to be written,
 * which was left locked by namei. Remaining parameters (dp->i_offset,
 * dp->i_count) indicate how the space for the new entry is to be obtained.
 * Non-null bp indicates that a directory is being created (for the
 * soft dependency code).
d716 5
a720 5
ufs_direnter(dvp, dirp, cnp, newdirbp)
  	struct vnode *dvp;
  	struct direct *dirp;
 	struct componentname *cnp;
 	struct buf *newdirbp;
d722 12
a733 16
  	struct ucred *cr;
  	struct proc *p;
  	int newentrysize;
  	struct inode *dp;
  	struct buf *bp;
  	u_int dsize;
  	struct direct *ep, *nep;
	int error, ret, blkoff, loc, spacefree, flags;
  	char *dirbuf;
	struct timespec ts;

 	error = 0;
 	cr = cnp->cn_cred;
 	p = cnp->cn_proc;
  	dp = VTOI(dvp);
  	newentrysize = DIRSIZ(FSFMT(dvp), dirp);
d740 22
a761 12
  		 * new entry into a fresh block.
  		 */
  		if (dp->i_offset & (DIRBLKSIZ - 1))
			panic("ufs_direnter: newblk");
		flags = B_CLRBUF;
		if (!DOINGSOFTDEP(dvp))
			flags |= B_SYNC;
		if ((error = VOP_BALLOC(dvp, (off_t)dp->i_offset, DIRBLKSIZ,
		    cr, flags, &bp)) != 0) {
			if (DOINGSOFTDEP(dvp) && newdirbp != NULL)
				bdwrite(newdirbp);
			return (error);
d763 13
a775 43
		dp->i_ffs_size = dp->i_offset + DIRBLKSIZ;
		dp->i_flag |= IN_CHANGE | IN_UPDATE;
		vnode_pager_setsize(dvp, (u_long)dp->i_ffs_size);
  		dirp->d_reclen = DIRBLKSIZ;
		blkoff = dp->i_offset &
		    (VFSTOUFS(dvp->v_mount)->um_mountp->mnt_stat.f_iosize - 1);
		bcopy((caddr_t)dirp, (caddr_t)bp->b_data + blkoff,newentrysize);
		if (DOINGSOFTDEP(dvp)) {
			/*
			 * Ensure that the entire newly allocated block is a
			 * valid directory so that future growth within the
			 * block does not have to ensure that the block is
			 * written before the inode.
			 */
			blkoff += DIRBLKSIZ;
			while (blkoff < bp->b_bcount) {
				((struct direct *)
				   (bp->b_data + blkoff))->d_reclen = DIRBLKSIZ;
				blkoff += DIRBLKSIZ;
			}
			softdep_setup_directory_add(bp, dp, dp->i_offset,
			    dirp->d_ino, newdirbp);
			bdwrite(bp);
		} else {
			error = VOP_BWRITE(bp);
  		}
		TIMEVAL_TO_TIMESPEC(&time, &ts);
 		ret = VOP_UPDATE(dvp, &ts, &ts, !DOINGSOFTDEP(dvp));
 		if (error == 0)
 			return (ret);
  		return (error);
  	}
  
  	/*
	 * If dp->i_count is non-zero, then namei found space for the new
	 * entry in the range dp->i_offset to dp->i_offset + dp->i_count
	 * in the directory. To use this space, we may have to compact
	 * the entries located there, by copying them together towards the
	 * beginning of the block, leaving the free space in one usable
	 * chunk at the end.
  	 */
  
  	/*
d787 3
a789 6
 	if ((error = VOP_BLKATOFF(dvp, (off_t)dp->i_offset, &dirbuf, &bp)) 
	    != 0) {
 		if (DOINGSOFTDEP(dvp) && newdirbp != NULL)
 			bdwrite(newdirbp);
  		return (error);
 	}
d794 2
a795 1
	 * dp->i_offset + dp->i_count would yield the space.
d813 1
a813 5
 		if (DOINGSOFTDEP(dvp))
 			softdep_change_directoryentry_offset(dp, dirbuf,
 			    (caddr_t)nep, (caddr_t)ep, dsize); 
 		else
 			bcopy((caddr_t)nep, (caddr_t)ep, dsize);
d823 1
a823 1
			panic("ufs_direnter: compact1");
d827 1
a827 1
			panic("ufs_direnter: compact2");
d833 1
a833 8

  	if (DOINGSOFTDEP(dvp)) {
  		softdep_setup_directory_add(bp, dp,
  		    dp->i_offset + (caddr_t)ep - dirbuf, dirp->d_ino, newdirbp);
  		bdwrite(bp);
  	} else {
  		error = VOP_BWRITE(bp);
  	}
d835 1
a835 1
	if (error == 0 && dp->i_endoff && dp->i_endoff < dp->i_ffs_size)
d853 1
a853 1
ufs_dirremove(dvp, ip, flags, isrmdir)
d855 1
a855 3
	struct inode *ip;
	int flags;
	int isrmdir;
d857 1
a857 1
	struct inode *dp;
d864 1
a864 1
	if (flags & DOWHITEOUT) {
d874 3
a876 1
		goto out;
a878 4
 	if ((error = VOP_BLKATOFF(dvp,
 	    (off_t)(dp->i_offset - dp->i_count), (char **)&ep, &bp)) != 0)
 		return (error);

d883 4
a887 19
	} else {
 		/*
 		 * Collapse new free space into previous entry.
 		 */
 		ep->d_reclen += dp->i_reclen;
	}
out:
 	if (ip) {
 		ip->i_effnlink--;
 		ip->i_flag |= IN_CHANGE;
 	}
 	if (DOINGSOFTDEP(dvp)) {
 		if (ip)
 			softdep_setup_remove(bp, dp, ip, isrmdir);
 		bdwrite(bp);
 	} else {
 		if (ip)
 			ip->i_ffs_nlink--;   /* XXX */

d889 2
d892 9
d911 3
a913 5
ufs_dirrewrite(dp, oip, newinum, newtype, isrmdir)
	struct inode *dp, *oip;
	ino_t newinum;
	int newtype;
	int isrmdir;
d923 1
a923 1
	ep->d_ino = newinum;
d925 2
a926 10
 		ep->d_type = newtype;
 	oip->i_effnlink--;
 	oip->i_flag |= IN_CHANGE;
 	if (DOINGSOFTDEP(vdp)) {
 		softdep_setup_directory_change(bp, dp, oip, newinum, isrmdir);
 		bdwrite(bp);
 	} else {
 		oip->i_ffs_nlink--; /* XXX */
 		error = VOP_BWRITE(bp);
 	}
d986 1
a986 1
		if (namlen == 1 && dp->d_ino == ip->i_number)
@


1.4
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs_lookup.c,v 1.3 1996/08/31 09:24:10 pefo Exp $	*/
d46 1
d50 1
d54 2
d138 1
d156 4
d185 2
a186 2
			VOP_UNLOCK(pdp);
			error = vget(vdp, 1);
d188 1
a188 1
				error = VOP_LOCK(pdp);
d190 1
a190 1
			error = vget(vdp, 1);
d192 1
a192 1
				VOP_UNLOCK(pdp);
d203 1
a203 1
				VOP_UNLOCK(pdp);
d205 3
a207 1
		if ((error = VOP_LOCK(pdp)) != 0)
a210 1
		*vpp = NULL;
d409 1
a409 1
	    (flags & ISLASTCN) && dp->i_ffs_nlink != 0) {
d459 1
a459 1
			VOP_UNLOCK(vdp);
d537 1
a537 1
			VOP_UNLOCK(vdp);
d564 1
a564 1
			VOP_UNLOCK(vdp);
d589 1
a589 1
		VOP_UNLOCK(pdp);	/* race to get the inode */
d592 1
a592 1
			VOP_LOCK(pdp);
d596 1
a596 1
		    (error = VOP_LOCK(pdp))) {
d609 1
a609 1
			VOP_UNLOCK(pdp);
d684 3
a686 6
 * Write a directory entry after a call to namei, using the parameters
 * that it left in nameidata.  The argument ip is the inode which the new
 * directory entry will refer to.  Dvp is a pointer to the directory to
 * be written, which was left locked by namei. Remaining parameters
 * (dp->i_offset, dp->i_count) indicate how the space for the new
 * entry is to be obtained.
d688 5
a692 5
int
ufs_direnter(ip, dvp, cnp)
	struct inode *ip;
	struct vnode *dvp;
	register struct componentname *cnp;
d694 1
a694 3
	register struct inode *dp;
	struct direct newdir;

d696 2
a697 2
	if ((cnp->cn_flags & SAVENAME) == 0)
		panic("direnter: missing name");
d699 7
a705 8
	dp = VTOI(dvp);
	newdir.d_ino = ip->i_number;
	newdir.d_namlen = cnp->cn_namelen;
	bcopy(cnp->cn_nameptr, newdir.d_name, (unsigned)cnp->cn_namelen + 1);
	if (dvp->v_mount->mnt_maxsymlinklen > 0)
		newdir.d_type = IFTODT(ip->i_ffs_mode);
	else {
		newdir.d_type = 0;
d707 3
a709 3
			{ u_char tmp = newdir.d_namlen;
			newdir.d_namlen = newdir.d_type;
			newdir.d_type = tmp; }
d711 1
a711 2
	}
	return (ufs_direnter2(dvp, &newdir, cnp->cn_cred, cnp->cn_proc));
d713 1
a713 1

d715 7
a721 2
 * Common entry point for directory entry removal used by ufs_direnter
 * and ufs_whiteout
d724 5
a728 5
ufs_direnter2(dvp, dirp, cr, p)
	struct vnode *dvp;
	struct direct *dirp;
	struct ucred *cr;
	struct proc *p;
d730 16
a745 12
	int newentrysize;
	struct inode *dp;
	struct buf *bp;
	struct iovec aiov;
	struct uio auio;
	u_int dsize;
	struct direct *ep, *nep;
	int error, loc, spacefree;
	char *dirbuf;

	dp = VTOI(dvp);
	newentrysize = DIRSIZ(FSFMT(dvp), dirp);
d752 12
a763 22
		 * new entry into a fresh block.
		 */
		if (dp->i_offset & (DIRBLKSIZ - 1))
			panic("ufs_direnter2: newblk");
		auio.uio_offset = dp->i_offset;
		dirp->d_reclen = DIRBLKSIZ;
		auio.uio_resid = newentrysize;
		aiov.iov_len = newentrysize;
		aiov.iov_base = (caddr_t)dirp;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_rw = UIO_WRITE;
		auio.uio_segflg = UIO_SYSSPACE;
		auio.uio_procp = (struct proc *)0;
		error = VOP_WRITE(dvp, &auio, IO_SYNC, cr);
		if (DIRBLKSIZ >
		    VFSTOUFS(dvp->v_mount)->um_mountp->mnt_stat.f_bsize)
			/* XXX should grow with balloc() */
			panic("ufs_direnter2: frag size");
		else if (!error) {
			dp->i_ffs_size = roundup(dp->i_ffs_size, DIRBLKSIZ);
			dp->i_flag |= IN_CHANGE;
d765 43
a807 13
		return (error);
	}

	/*
	 * If dp->i_count is non-zero, then namei found space
	 * for the new entry in the range dp->i_offset to
	 * dp->i_offset + dp->i_count in the directory.
	 * To use this space, we may have to compact the entries located
	 * there, by copying them together towards the beginning of the
	 * block, leaving the free space in one usable chunk at the end.
	 */

	/*
d819 6
a824 3
	error = VOP_BLKATOFF(dvp, (off_t)dp->i_offset, &dirbuf, &bp);
	if (error)
		return (error);
d829 1
a829 2
	 * dp->i_offset + dp->i_count would yield the
	 * space.
d847 5
a851 1
		bcopy((caddr_t)nep, (caddr_t)ep, dsize);
d861 1
a861 1
			panic("ufs_direnter2: compact1");
d865 1
a865 1
			panic("ufs_direnter2: compact2");
d871 8
a878 1
	error = VOP_BWRITE(bp);
d880 1
a880 1
	if (!error && dp->i_endoff && dp->i_endoff < dp->i_ffs_size)
d898 1
a898 1
ufs_dirremove(dvp, cnp)
d900 3
a902 1
	struct componentname *cnp;
d904 1
a904 1
	register struct inode *dp;
d911 1
a911 1
	if (cnp->cn_flags & DOWHITEOUT) {
d921 1
a921 3
		error = VOP_BWRITE(bp);
		dp->i_flag |= IN_CHANGE | IN_UPDATE;
		return (error);
d924 4
a931 4
		error = VOP_BLKATOFF(dvp, (off_t)dp->i_offset, (char **)&ep,
				     &bp);
		if (error)
			return (error);
d933 19
a952 2
		dp->i_flag |= IN_CHANGE | IN_UPDATE;
		return (error);
a953 9
	/*
	 * Collapse new free space into previous entry.
	 */
	error = VOP_BLKATOFF(dvp, (off_t)(dp->i_offset - dp->i_count),
			     (char **)&ep, &bp);
	if (error)
		return (error);
	ep->d_reclen += dp->i_reclen;
	error = VOP_BWRITE(bp);
d964 5
a968 3
ufs_dirrewrite(dp, ip, cnp)
	struct inode *dp, *ip;
	struct componentname *cnp;
d978 1
a978 1
	ep->d_ino = ip->i_number;
d980 10
a989 2
		ep->d_type = IFTODT(ip->i_ffs_mode);
	error = VOP_BWRITE(bp);
d1049 1
a1049 1
		if (namlen == 1)
@


1.3
log
@Cleanup exec
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d146 1
a146 1
	if ((dp->i_mode & IFMT) != IFDIR)
d231 1
a231 1
	    dp->i_diroff > dp->i_size) {
d244 1
a244 1
	endsearch = roundup(dp->i_size, DIRBLKSIZ);
d399 1
a399 1
	    (flags & ISLASTCN) && dp->i_nlink != 0) {
d417 1
a417 1
			dp->i_offset = roundup(dp->i_size, DIRBLKSIZ);
d466 3
a468 3
	if (entryoffsetinblock + DIRSIZ(FSFMT(vdp), ep) > dp->i_size) {
		ufs_dirbad(dp, dp->i_offset, "i_size too small");
		dp->i_size = entryoffsetinblock + DIRSIZ(FSFMT(vdp), ep);
d518 1
a518 1
		if ((dp->i_mode & ISVTX) &&
d520 2
a521 2
		    cred->cr_uid != dp->i_uid &&
		    VTOI(tdp)->i_uid != cred->cr_uid) {
d699 1
a699 1
		newdir.d_type = IFTODT(ip->i_mode);
d760 1
a760 1
			dp->i_size = roundup(dp->i_size, DIRBLKSIZ);
d782 2
a783 2
	if (dp->i_offset + dp->i_count > dp->i_size)
		dp->i_size = dp->i_offset + dp->i_count;
d835 1
a835 1
	if (!error && dp->i_endoff && dp->i_endoff < dp->i_size)
d925 1
a925 1
		ep->d_type = IFTODT(ip->i_mode);
d952 1
a952 1
	m = ip->i_size;
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d942 1
a942 1
	register struct inode *ip;
d946 1
a946 1
	register off_t off;
d948 1
a948 1
	register struct direct *dp = (struct direct *)&dbuf;
d952 2
a953 1
	for (off = 0; off < ip->i_size; off += dp->d_reclen) {
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ufs_lookup.c,v 1.6 1995/05/30 11:41:38 mycroft Exp $	*/
d45 1
d101 3
a103 1
ufs_lookup(ap)
d108 1
a108 2
	} */ *ap;
{
d148 1
a148 1
	if (error = VOP_ACCESS(vdp, VEXEC, cred, cnp->cn_proc))
d158 1
a158 1
	if (error = cache_lookup(vdp, vpp, cnp)) {
d196 1
a196 1
		if (error = VOP_LOCK(pdp))
d255 3
a257 2
			if (error =
			    VOP_BLKATOFF(vdp, (off_t)dp->i_offset, NULL, &bp))
d279 1
a279 1
		    dirchk && ufs_dirbadentry(vdp, ep, entryoffsetinblock)) {
d404 2
a405 1
		if (error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc))
d491 2
a492 1
		if (error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc))
d509 2
a510 1
		if (error = VFS_VGET(vdp->v_mount, dp->i_ino, &tdp))
d539 2
a540 1
		if (error = VOP_ACCESS(vdp, VWRITE, cred, cnp->cn_proc))
d548 2
a549 1
		if (error = VFS_VGET(vdp->v_mount, dp->i_ino, &tdp))
d580 2
a581 1
		if (error = VFS_VGET(vdp->v_mount, dp->i_ino, &tdp)) {
d595 2
a596 1
		if (error = VFS_VGET(vdp->v_mount, dp->i_ino, &tdp))
d715 1
d787 2
a788 1
	if (error = VOP_BLKATOFF(dvp, (off_t)dp->i_offset, &dirbuf, &bp))
d868 3
a870 2
		if (error =
		    VOP_BLKATOFF(dvp, (off_t)dp->i_offset, (char **)&ep, &bp))
d883 3
a885 2
		if (error =
		    VOP_BLKATOFF(dvp, (off_t)dp->i_offset, (char **)&ep, &bp))
d895 3
a897 2
	if (error = VOP_BLKATOFF(dvp, (off_t)(dp->i_offset - dp->i_count),
	    (char **)&ep, &bp))
d920 2
a921 1
	if (error = VOP_BLKATOFF(vdp, (off_t)dp->i_offset, (char **)&ep, &bp))
d1049 2
a1050 1
		if (error = VFS_VGET(vp->v_mount, dirbuf.dotdot_ino, &vp)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
