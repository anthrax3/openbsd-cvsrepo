head	1.76;
access;
symbols
	OPENBSD_6_0:1.76.0.2
	OPENBSD_6_0_BASE:1.76
	OPENBSD_5_9:1.75.0.2
	OPENBSD_5_9_BASE:1.75
	OPENBSD_5_8:1.74.0.4
	OPENBSD_5_8_BASE:1.74
	OPENBSD_5_7:1.73.0.2
	OPENBSD_5_7_BASE:1.73
	OPENBSD_5_6:1.73.0.4
	OPENBSD_5_6_BASE:1.73
	OPENBSD_5_5:1.67.0.4
	OPENBSD_5_5_BASE:1.67
	OPENBSD_5_4:1.64.0.2
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.62.0.2
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.61.0.2
	OPENBSD_5_2_BASE:1.61
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.4
	OPENBSD_5_0:1.60.0.2
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.56.0.10
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.56.0.8
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.56.0.4
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.56.0.6
	OPENBSD_4_6_BASE:1.56
	OPENBSD_4_5:1.56.0.2
	OPENBSD_4_5_BASE:1.56
	OPENBSD_4_4:1.55.0.2
	OPENBSD_4_4_BASE:1.55
	OPENBSD_4_3:1.52.0.2
	OPENBSD_4_3_BASE:1.52
	OPENBSD_4_2:1.49.0.2
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.37.0.4
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.37.0.2
	OPENBSD_3_6_BASE:1.37
	SMP_SYNC_A:1.36
	SMP_SYNC_B:1.36
	OPENBSD_3_5:1.36.0.2
	OPENBSD_3_5_BASE:1.36
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	UBC_SYNC_A:1.32
	OPENBSD_3_3:1.32.0.6
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.32.0.4
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	UBC_SYNC_B:1.32
	UBC:1.28.0.2
	UBC_BASE:1.28
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.19
	OPENBSD_2_9:1.19.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.4
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.2
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.9.0.4
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.76
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.75;
commitid	gFybgYMymUyTbVeS;

1.75
date	2015.11.28.21.52.02;	author beck;	state Exp;
branches;
next	1.74;
commitid	RTnjsXZgItH5OlTY;

1.74
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.73;
commitid	p4LJxGKbi0BU2cG6;

1.73
date	2014.07.14.08.11.34;	author beck;	state Exp;
branches;
next	1.72;
commitid	7DbQuyiuCuM93wWy;

1.72
date	2014.07.13.23.33.26;	author tedu;	state Exp;
branches;
next	1.71;
commitid	zHb3aykioHZHOHpW;

1.71
date	2014.07.12.18.44.01;	author tedu;	state Exp;
branches;
next	1.70;
commitid	bDGgAR6yEQVcVl5u;

1.70
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	EF98ch02VpFassUi;

1.69
date	2014.05.22.02.02.39;	author guenther;	state Exp;
branches;
next	1.68;

1.68
date	2014.03.19.04.17.33;	author guenther;	state Exp;
branches;
next	1.67;

1.67
date	2014.01.25.23.31.12;	author guenther;	state Exp;
branches;
next	1.66;

1.66
date	2013.12.12.19.00.09;	author tedu;	state Exp;
branches;
next	1.65;

1.65
date	2013.11.02.00.08.17;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2013.04.22.02.07.46;	author tedu;	state Exp;
branches;
next	1.62;

1.62
date	2013.01.16.22.41.47;	author beck;	state Exp;
branches;
next	1.61;

1.61
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.60;

1.60
date	2011.08.16.14.36.39;	author thib;	state Exp;
branches;
next	1.59;

1.59
date	2011.08.03.20.21.19;	author beck;	state Exp;
branches;
next	1.58;

1.58
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.12.19.45.43;	author beck;	state Exp;
branches;
next	1.56;

1.56
date	2009.01.15.07.58.36;	author grange;	state Exp;
branches;
next	1.55;

1.55
date	2008.06.12.06.58.40;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2008.06.11.12.35.46;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2008.06.10.20.14.37;	author beck;	state Exp;
branches;
next	1.52;

1.52
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.29.17.06.20;	author chl;	state Exp;
branches;
next	1.50;

1.50
date	2007.09.23.20.15.07;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.01.18.54.27;	author pedro;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.01.06.38.54;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.46;

1.46
date	2006.09.20.22.54.29;	author pedro;	state Exp;
branches;
next	1.45;

1.45
date	2006.09.20.13.43.47;	author pedro;	state Exp;
branches;
next	1.44;

1.44
date	2006.04.05.12.59.20;	author pedro;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.05.12.55.53;	author pedro;	state Exp;
branches;
next	1.42;

1.42
date	2005.12.28.20.48.17;	author pedro;	state Exp;
branches;
next	1.41;

1.41
date	2005.12.17.13.56.01;	author pedro;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.09.15.35.53;	author pedro;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.09.02.29.11;	author pedro;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.03.20.14.01;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2004.06.24.19.35.26;	author tholo;	state Exp;
branches;
next	1.36;

1.36
date	2003.11.19.03.29.31;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2003.11.19.02.52.13;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2003.08.25.23.26.55;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.02.22.20.37.46;	author drahn;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.04.03.53.23;	author nordin;	state Exp;
branches;
next	1.29;

1.29
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.12.10.04.45.32;	author art;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.21.21.23.56;	author csapuntz;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.16.03.44.23;	author csapuntz;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.16.02.56.48;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.27.04.58.48;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.23.02.07.54;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.20.19.50.30;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.23.14.42.39;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.21.23.24.31;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.23.02.14.39;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	99.12.06.07.23.21;	author art;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	99.12.06.07.03.04;	author art;	state Exp;
branches;
next	1.13;

1.13
date	99.12.06.06.55.41;	author art;	state Exp;
branches;
next	1.12;

1.12
date	99.02.26.03.56.30;	author art;	state Exp;
branches;
next	1.11;

1.11
date	98.12.01.23.32.52;	author art;	state Exp;
branches;
next	1.10;

1.10
date	98.11.29.03.47.15;	author art;	state Exp;
branches;
next	1.9;

1.9
date	97.11.06.05.59.18;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.10.06.20.21.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.15.26.30;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.05.30.08.34.21;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	97.03.02.09.38.13;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	96.11.05.03.30.12;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.47.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.27.37;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches;
next	;

1.15.2.1
date	2001.05.14.22.47.40;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2001.07.04.11.00.49;	author niklas;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.15.2.5;

1.15.2.5
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.15.2.6;

1.15.2.6
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.15.2.7;

1.15.2.7
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.15.2.8;

1.15.2.8
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.15.2.9;

1.15.2.9
date	2004.02.19.11.01.36;	author niklas;	state Exp;
branches;
next	;

1.28.2.1
date	2002.01.31.22.55.49;	author niklas;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.28.2.4;

1.28.2.4
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.76
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@/*	$OpenBSD: ffs_inode.c,v 1.75 2015/11/28 21:52:02 beck Exp $	*/
/*	$NetBSD: ffs_inode.c,v 1.10 1996/05/11 18:27:19 mycroft Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ffs_inode.c	8.8 (Berkeley) 10/19/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mount.h>
#include <sys/proc.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/resourcevar.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/ffs/fs.h>
#include <ufs/ffs/ffs_extern.h>

int ffs_indirtrunc(struct inode *, daddr_t, daddr_t, daddr_t, int, long *);

/*
 * Update the access, modified, and inode change times as specified by the
 * IN_ACCESS, IN_UPDATE, and IN_CHANGE flags respectively. The IN_MODIFIED
 * flag is used to specify that the inode needs to be updated but that the
 * times have already been set.  The IN_LAZYMOD flag is used to specify
 * that the inode needs to be updated at some point, by reclaim if not
 * in the course of other changes; this is used to defer writes just to
 * update device timestamps.  If waitfor is set, then wait for the disk
 * write of the inode to complete.
 */
int
ffs_update(struct inode *ip, int waitfor)
{
	struct vnode *vp;
	struct fs *fs;
	struct buf *bp;
	int error;

	vp = ITOV(ip);
	ufs_itimes(vp);

	if ((ip->i_flag & IN_MODIFIED) == 0 && waitfor == 0)
		return (0);

	ip->i_flag &= ~(IN_MODIFIED | IN_LAZYMOD);
	fs = ip->i_fs;

	/*
	 * Ensure that uid and gid are correct. This is a temporary
	 * fix until fsck has been changed to do the update.
	 */
	if (fs->fs_magic == FS_UFS1_MAGIC && fs->fs_inodefmt < FS_44INODEFMT) {
		ip->i_din1->di_ouid = ip->i_ffs1_uid;
		ip->i_din1->di_ogid = ip->i_ffs1_gid;
	}

	error = bread(ip->i_devvp, fsbtodb(fs, ino_to_fsba(fs, ip->i_number)),
	    (int)fs->fs_bsize, &bp);
	if (error) {
		brelse(bp);
		return (error);
	}

	if (DOINGSOFTDEP(vp))
		softdep_update_inodeblock(ip, bp, waitfor);
	else if (ip->i_effnlink != DIP(ip, nlink))
		panic("ffs_update: bad link cnt");

#ifdef FFS2
	if (ip->i_ump->um_fstype == UM_UFS2)
		*((struct ufs2_dinode *)bp->b_data +
		    ino_to_fsbo(fs, ip->i_number)) = *ip->i_din2;
	else
#endif
		*((struct ufs1_dinode *)bp->b_data +
		    ino_to_fsbo(fs, ip->i_number)) = *ip->i_din1;

	if (waitfor && !DOINGASYNC(vp)) {
		return (bwrite(bp));
	} else {
		bdwrite(bp);
		return (0);
	}
}

#define	SINGLE	0	/* index of single indirect block */
#define	DOUBLE	1	/* index of double indirect block */
#define	TRIPLE	2	/* index of triple indirect block */

/*
 * Truncate the inode oip to at most length size, freeing the
 * disk blocks.
 */
int
ffs_truncate(struct inode *oip, off_t length, int flags, struct ucred *cred)
{
	struct vnode *ovp;
	daddr_t lastblock;
	daddr_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
	daddr_t oldblks[NDADDR + NIADDR], newblks[NDADDR + NIADDR];
	struct fs *fs;
	struct buf *bp;
	int offset, size, level;
	long count, nblocks, vflags, blocksreleased = 0;
	int i, aflags, error, allerror;
	off_t osize;

	if (length < 0)
		return (EINVAL);
	ovp = ITOV(oip);

	if (ovp->v_type != VREG &&
	    ovp->v_type != VDIR &&
	    ovp->v_type != VLNK)
		return (0);

	if (DIP(oip, size) == length)
		return (0);

	if (ovp->v_type == VLNK &&
	    (DIP(oip, size) < oip->i_ump->um_maxsymlinklen ||
	     (oip->i_ump->um_maxsymlinklen == 0 &&
	      oip->i_din1->di_blocks == 0))) {
#ifdef DIAGNOSTIC
		if (length != 0)
			panic("ffs_truncate: partial truncate of symlink");
#endif
		memset(SHORTLINK(oip), 0, (size_t) DIP(oip, size));
		DIP_ASSIGN(oip, size, 0);
		oip->i_flag |= IN_CHANGE | IN_UPDATE;
		return (UFS_UPDATE(oip, 1));
	}

	if ((error = getinoquota(oip)) != 0)
		return (error);

	uvm_vnp_setsize(ovp, length);
	oip->i_ci.ci_lasta = oip->i_ci.ci_clen 
	    = oip->i_ci.ci_cstart = oip->i_ci.ci_lastw = 0;

	if (DOINGSOFTDEP(ovp)) {
		if (length > 0 || softdep_slowdown(ovp)) {
			/*
			 * If a file is only partially truncated, then
			 * we have to clean up the data structures
			 * describing the allocation past the truncation
			 * point. Finding and deallocating those structures
			 * is a lot of work. Since partial truncation occurs
			 * rarely, we solve the problem by syncing the file
			 * so that it will have no data structures left.
			 */
			if ((error = VOP_FSYNC(ovp, cred, MNT_WAIT,
					       curproc)) != 0)
				return (error);
		} else {
			(void)ufs_quota_free_blocks(oip, DIP(oip, blocks),
			    NOCRED);
			softdep_setup_freeblocks(oip, length);
			(void) vinvalbuf(ovp, 0, cred, curproc, 0, 0);
			oip->i_flag |= IN_CHANGE | IN_UPDATE;
			return (UFS_UPDATE(oip, 0));
		}
	}

	fs = oip->i_fs;
	osize = DIP(oip, size);
	/*
	 * Lengthen the size of the file. We must ensure that the
	 * last byte of the file is allocated. Since the smallest
	 * value of osize is 0, length will be at least 1.
	 */
	if (osize < length) {
		if (length > fs->fs_maxfilesize)
			return (EFBIG);
		aflags = B_CLRBUF;
		if (flags & IO_SYNC)
			aflags |= B_SYNC;
		error = UFS_BUF_ALLOC(oip, length - 1, 1, 
				   cred, aflags, &bp);
		if (error)
			return (error);
		DIP_ASSIGN(oip, size, length);
		uvm_vnp_setsize(ovp, length);
		(void) uvm_vnp_uncache(ovp);
		if (aflags & B_SYNC)
			bwrite(bp);
		else
			bawrite(bp);
		oip->i_flag |= IN_CHANGE | IN_UPDATE;
		return (UFS_UPDATE(oip, 1));
	}
	uvm_vnp_setsize(ovp, length);

	/*
	 * Shorten the size of the file. If the file is not being
	 * truncated to a block boundary, the contents of the
	 * partial block following the end of the file must be
	 * zero'ed in case it ever becomes accessible again because
	 * of subsequent file growth. Directories however are not
	 * zero'ed as they should grow back initialized to empty.
	 */
	offset = blkoff(fs, length);
	if (offset == 0) {
		DIP_ASSIGN(oip, size, length);
	} else {
		lbn = lblkno(fs, length);
		aflags = B_CLRBUF;
		if (flags & IO_SYNC)
			aflags |= B_SYNC;
		error = UFS_BUF_ALLOC(oip, length - 1, 1,
				   cred, aflags, &bp);
		if (error)
			return (error);
		/*
		 * When we are doing soft updates and the UFS_BALLOC
		 * above fills in a direct block hole with a full sized
		 * block that will be truncated down to a fragment below,
		 * we must flush out the block dependency with an FSYNC
		 * so that we do not get a soft updates inconsistency
		 * when we create the fragment below.
		 */
		if (DOINGSOFTDEP(ovp) && lbn < NDADDR &&
		    fragroundup(fs, blkoff(fs, length)) < fs->fs_bsize &&
		    (error = VOP_FSYNC(ovp, cred, MNT_WAIT, curproc)) != 0)
			return (error);
		DIP_ASSIGN(oip, size, length);
		size = blksize(fs, oip, lbn);
		(void) uvm_vnp_uncache(ovp);
		if (ovp->v_type != VDIR)
			memset(bp->b_data + offset, 0, size - offset);
		buf_adjcnt(bp, size);
		if (aflags & B_SYNC)
			bwrite(bp);
		else
			bawrite(bp);
	}
	/*
	 * Calculate index into inode's block list of
	 * last direct and indirect blocks (if any)
	 * which we want to keep.  Lastblock is -1 when
	 * the file is truncated to 0.
	 */
	lastblock = lblkno(fs, length + fs->fs_bsize - 1) - 1;
	lastiblock[SINGLE] = lastblock - NDADDR;
	lastiblock[DOUBLE] = lastiblock[SINGLE] - NINDIR(fs);
	lastiblock[TRIPLE] = lastiblock[DOUBLE] - NINDIR(fs) * NINDIR(fs);
	nblocks = btodb(fs->fs_bsize);

	/*
	 * Update file and block pointers on disk before we start freeing
	 * blocks.  If we crash before free'ing blocks below, the blocks
	 * will be returned to the free list.  lastiblock values are also
	 * normalized to -1 for calls to ffs_indirtrunc below.
	 */
	for (level = TRIPLE; level >= SINGLE; level--) {
		oldblks[NDADDR + level] = DIP(oip, ib[level]);
		if (lastiblock[level] < 0) {
			DIP_ASSIGN(oip, ib[level], 0);
			lastiblock[level] = -1;
		}
	}

	for (i = 0; i < NDADDR; i++) {
		oldblks[i] = DIP(oip, db[i]);
		if (i > lastblock)
			DIP_ASSIGN(oip, db[i], 0);
	}

	oip->i_flag |= IN_CHANGE | IN_UPDATE;
	if ((error = UFS_UPDATE(oip, 1)) != 0)
		allerror = error;

	/*
	 * Having written the new inode to disk, save its new configuration
	 * and put back the old block pointers long enough to process them.
	 * Note that we save the new block configuration so we can check it
	 * when we are done.
	 */
	for (i = 0; i < NDADDR; i++) {
		newblks[i] = DIP(oip, db[i]);
		DIP_ASSIGN(oip, db[i], oldblks[i]);
	}

	for (i = 0; i < NIADDR; i++) {
		newblks[NDADDR + i] = DIP(oip, ib[i]);
		DIP_ASSIGN(oip, ib[i], oldblks[NDADDR + i]);
	}

	DIP_ASSIGN(oip, size, osize);
	vflags = ((length > 0) ? V_SAVE : 0) | V_SAVEMETA;
	allerror = vinvalbuf(ovp, vflags, cred, curproc, 0, 0);

	/*
	 * Indirect blocks first.
	 */
	indir_lbn[SINGLE] = -NDADDR;
	indir_lbn[DOUBLE] = indir_lbn[SINGLE] - NINDIR(fs) - 1;
	indir_lbn[TRIPLE] = indir_lbn[DOUBLE] - NINDIR(fs) * NINDIR(fs) - 1;
	for (level = TRIPLE; level >= SINGLE; level--) {
		bn = DIP(oip, ib[level]);
		if (bn != 0) {
			error = ffs_indirtrunc(oip, indir_lbn[level],
			    fsbtodb(fs, bn), lastiblock[level], level, &count);
			if (error)
				allerror = error;
			blocksreleased += count;
			if (lastiblock[level] < 0) {
				DIP_ASSIGN(oip, ib[level], 0);
				ffs_blkfree(oip, bn, fs->fs_bsize);
				blocksreleased += nblocks;
			}
		}
		if (lastiblock[level] >= 0)
			goto done;
	}

	/*
	 * All whole direct blocks or frags.
	 */
	for (i = NDADDR - 1; i > lastblock; i--) {
		long bsize;

		bn = DIP(oip, db[i]);
		if (bn == 0)
			continue;

		DIP_ASSIGN(oip, db[i], 0);
		bsize = blksize(fs, oip, i);
		ffs_blkfree(oip, bn, bsize);
		blocksreleased += btodb(bsize);
	}
	if (lastblock < 0)
		goto done;

	/*
	 * Finally, look for a change in size of the
	 * last direct block; release any frags.
	 */
	bn = DIP(oip, db[lastblock]);
	if (bn != 0) {
		long oldspace, newspace;

		/*
		 * Calculate amount of space we're giving
		 * back as old block size minus new block size.
		 */
		oldspace = blksize(fs, oip, lastblock);
		DIP_ASSIGN(oip, size, length);
		newspace = blksize(fs, oip, lastblock);
		if (newspace == 0)
			panic("ffs_truncate: newspace");
		if (oldspace - newspace > 0) {
			/*
			 * Block number of space to be free'd is
			 * the old block # plus the number of frags
			 * required for the storage we're keeping.
			 */
			bn += numfrags(fs, newspace);
			ffs_blkfree(oip, bn, oldspace - newspace);
			blocksreleased += btodb(oldspace - newspace);
		}
	}
done:
#ifdef DIAGNOSTIC
	for (level = SINGLE; level <= TRIPLE; level++)
		if (newblks[NDADDR + level] != DIP(oip, ib[level]))
			panic("ffs_truncate1");
	for (i = 0; i < NDADDR; i++)
		if (newblks[i] != DIP(oip, db[i]))
			panic("ffs_truncate2");
#endif /* DIAGNOSTIC */
	/*
	 * Put back the real size.
	 */
	DIP_ASSIGN(oip, size, length);
	if (DIP(oip, blocks) >= blocksreleased)
		DIP_ADD(oip, blocks, -blocksreleased);
	else	/* sanity */
		DIP_ASSIGN(oip, blocks, 0);
	oip->i_flag |= IN_CHANGE;
	(void)ufs_quota_free_blocks(oip, blocksreleased, NOCRED);
	return (allerror);
}

#ifdef FFS2
#define BAP(ip, i) (((ip)->i_ump->um_fstype == UM_UFS2) ? bap2[i] : bap1[i])
#define BAP_ASSIGN(ip, i, value)					\
	do {								\
		if ((ip)->i_ump->um_fstype == UM_UFS2)			\
			bap2[i] = (value);				\
		else							\
			bap1[i] = (value);				\
	} while (0)
#else
#define BAP(ip, i) bap1[i]
#define BAP_ASSIGN(ip, i, value) do { bap1[i] = (value); } while (0)
#endif /* FFS2 */

/*
 * Release blocks associated with the inode ip and stored in the indirect
 * block bn.  Blocks are free'd in LIFO order up to (but not including)
 * lastbn.  If level is greater than SINGLE, the block is an indirect block
 * and recursive calls to indirtrunc must be used to cleanse other indirect
 * blocks.
 *
 * NB: triple indirect blocks are untested.
 */
int
ffs_indirtrunc(struct inode *ip, daddr_t lbn, daddr_t dbn,
    daddr_t lastbn, int level, long *countp)
{
	int i;
	struct buf *bp;
	struct fs *fs = ip->i_fs;
	struct vnode *vp;
	void *copy = NULL;
	daddr_t nb, nlbn, last;
	long blkcount, factor;
	int nblocks, blocksreleased = 0;
	int error = 0, allerror = 0;
	int32_t *bap1 = NULL;
#ifdef FFS2
	int64_t *bap2 = NULL;
#endif

	/*
	 * Calculate index in current block of last
	 * block to be kept.  -1 indicates the entire
	 * block so we need not calculate the index.
	 */
	factor = 1;
	for (i = SINGLE; i < level; i++)
		factor *= NINDIR(fs);
	last = lastbn;
	if (lastbn > 0)
		last /= factor;
	nblocks = btodb(fs->fs_bsize);
	/*
	 * Get buffer of block pointers, zero those entries corresponding
	 * to blocks to be free'd, and update on disk copy first.  Since
	 * double(triple) indirect before single(double) indirect, calls
	 * to bmap on these blocks will fail.  However, we already have
	 * the on disk address, so we have to set the b_blkno field
	 * explicitly instead of letting bread do everything for us.
	 */
	vp = ITOV(ip);
	bp = getblk(vp, lbn, (int)fs->fs_bsize, 0, 0);
	if (!(bp->b_flags & (B_DONE | B_DELWRI))) {
		curproc->p_ru.ru_inblock++;		/* pay for read */
		bcstats.pendingreads++;
		bcstats.numreads++;
		bp->b_flags |= B_READ;
		if (bp->b_bcount > bp->b_bufsize)
			panic("ffs_indirtrunc: bad buffer size");
		bp->b_blkno = dbn;
		VOP_STRATEGY(bp);
		error = biowait(bp);
	}
	if (error) {
		brelse(bp);
		*countp = 0;
		return (error);
	}

#ifdef FFS2
	if (ip->i_ump->um_fstype == UM_UFS2)
		bap2 = (int64_t *)bp->b_data;
	else
#endif
		bap1 = (int32_t *)bp->b_data;

	if (lastbn != -1) {
		copy = malloc(fs->fs_bsize, M_TEMP, M_WAITOK);
		memcpy(copy, bp->b_data, fs->fs_bsize);

		for (i = last + 1; i < NINDIR(fs); i++)
			BAP_ASSIGN(ip, i, 0);

		if (!DOINGASYNC(vp)) {
			error = bwrite(bp);
			if (error)
				allerror = error;
		} else {
			bawrite(bp);
		}

#ifdef FFS2
		if (ip->i_ump->um_fstype == UM_UFS2)
			bap2 = (int64_t *)copy;
		else
#endif
			bap1 = (int32_t *)copy;
	}

	/*
	 * Recursively free totally unused blocks.
	 */
	for (i = NINDIR(fs) - 1, nlbn = lbn + 1 - i * factor; i > last;
	    i--, nlbn += factor) {
		nb = BAP(ip, i);
		if (nb == 0)
			continue;
		if (level > SINGLE) {
			error = ffs_indirtrunc(ip, nlbn, fsbtodb(fs, nb),
					       -1, level - 1, &blkcount);
			if (error)
				allerror = error;
			blocksreleased += blkcount;
		}
		ffs_blkfree(ip, nb, fs->fs_bsize);
		blocksreleased += nblocks;
	}

	/*
	 * Recursively free last partial block.
	 */
	if (level > SINGLE && lastbn >= 0) {
		last = lastbn % factor;
		nb = BAP(ip, i);
		if (nb != 0) {
			error = ffs_indirtrunc(ip, nlbn, fsbtodb(fs, nb),
					       last, level - 1, &blkcount);
			if (error)
				allerror = error;
			blocksreleased += blkcount;
		}
	}
	if (copy != NULL) {
		free(copy, M_TEMP, 0);
	} else {
		bp->b_flags |= B_INVAL;
		brelse(bp);
	}
		
	*countp = blocksreleased;
	return (allerror);
}
@


1.75
log
@move buffer size adjustment to buf_adjcnt - from Walter Neto
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.74 2015/03/14 03:38:52 jsg Exp $	*/
d155 2
a156 2
	    (DIP(oip, size) < ovp->v_mount->mnt_maxsymlinklen ||
	     (ovp->v_mount->mnt_maxsymlinklen == 0 &&
@


1.74
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.73 2014/07/14 08:11:34 beck Exp $	*/
d265 1
a265 1
		bp->b_bcount = size;
@


1.73
log
@revert free checks in here. this seems to be a bit too agressive at the
moment and now is not the time. hitting these in here causes chaos.
We need to do these, but at a better time than right after a hackathon
and before release.
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.72 2014/07/13 23:33:26 tedu Exp $	*/
a38 1
#include <sys/file.h>
@


1.72
log
@pass correct sizes to free()
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.71 2014/07/12 18:44:01 tedu Exp $	*/
d564 1
a564 1
		free(copy, M_TEMP, fs->fs_bsize);
@


1.71
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.70 2014/07/08 17:19:26 deraadt Exp $	*/
d564 1
a564 1
		free(copy, M_TEMP, 0);
@


1.70
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.69 2014/05/22 02:02:39 guenther Exp $	*/
d564 1
a564 1
		free(copy, M_TEMP);
@


1.69
log
@From FreeBSD: the second argument to UFS_UPDATE/ffs_update is just a
boolean, not a MNT_* flag.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.68 2014/03/19 04:17:33 guenther Exp $	*/
a44 2

#include <uvm/uvm_extern.h>
@


1.68
log
@Pull in FreeBSD r37363 and r37887:
--
Sync timestamp changes for inodes of special files to disk as late
as possible (when the inode is reclaimed).  Temporarily only do
this if option UFS_LAZYMOD configured and softupdates aren't enabled.
UFS_LAZYMOD is intentionally left out of /sys/conf/options.

This is mainly to avoid almost useless disk i/o on battery powered
machines.  It's silly to write to disk (on the next sync or when the
inode becomes inactive) just because someone hit a key or something
wrote to the screen or /dev/null.
--
Made lazy syncing of timestamps for special files non-optional.
--

Also, include support in 'pstat -v' to display the IN_LAZYMOD flag.

ok tedu@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.67 2014/01/25 23:31:12 guenther Exp $	*/
d79 1
a79 1
	if ((ip->i_flag & IN_MODIFIED) == 0 && waitfor != MNT_WAIT)
d168 1
a168 1
		return (UFS_UPDATE(oip, MNT_WAIT));
d227 1
a227 1
		return (UFS_UPDATE(oip, MNT_WAIT));
d307 1
a307 1
	if ((error = UFS_UPDATE(oip, MNT_WAIT)) != 0)
@


1.67
log
@ufs_setattr() was assuming that the flag bits that indicate
atime/mtime/ctime need to be updated weren't already set.  When
they are, the code will end up treating the VNOVAL value from the
VFS layer as a time_t.  Port the fix from FreeBSD: the critical bit
is to process the existing flag values before possibly setting them
again in ufs_setattr().  This diff pulls in a larger change from
FreeBSD to replace the macro ITIMES() with a function ufs_itimes()
and to remove the atime and mtime arguments from ffs_update(): only
ufs_setattr() used them so it makes more sense to just do the those
bits directly there.

tweaks and ok tedu@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.66 2013/12/12 19:00:09 tedu Exp $	*/
d62 5
a66 2
 * times have already been set.  If waitfor is set, then wait for
 * the disk write of the inode to complete.
d82 1
a82 1
	ip->i_flag &= ~IN_MODIFIED;
@


1.66
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.65 2013/11/02 00:08:17 krw Exp $	*/
d62 2
a63 4
 * times have already been set. The access and modified times are taken from
 * the second and third parameters; the inode change time is always taken
 * from the current time. If waitfor is set, then wait for the disk write
 * of the inode to complete.
d66 1
a66 2
ffs_update(struct inode *ip, struct timespec *atime, 
    struct timespec *mtime, int waitfor)
a71 1
	struct timespec ts;
d74 1
a74 5
	if (vp->v_mount->mnt_flag & MNT_RDONLY) {
		ip->i_flag &=
		    ~(IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE);
		return (0);
	}
d76 1
a76 3
	if ((ip->i_flag &
	    (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0 &&
	    waitfor != MNT_WAIT)
d79 1
a79 19
	getnanotime(&ts);

	if (ip->i_flag & IN_ACCESS) {
		DIP_ASSIGN(ip, atime, atime ? atime->tv_sec : ts.tv_sec);
		DIP_ASSIGN(ip, atimensec, atime ? atime->tv_nsec : ts.tv_nsec);
	}

	if (ip->i_flag & IN_UPDATE) {
		DIP_ASSIGN(ip, mtime, mtime ? mtime->tv_sec : ts.tv_sec);
		DIP_ASSIGN(ip, mtimensec, mtime ? mtime->tv_nsec : ts.tv_nsec);
		ip->i_modrev++;
	}

	if (ip->i_flag & IN_CHANGE) {
		DIP_ASSIGN(ip, ctime, ts.tv_sec);
		DIP_ASSIGN(ip, ctimensec, ts.tv_nsec);
	}

	ip->i_flag &= ~(IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE);
@


1.65
log
@No need to cast constants or simple variables to (daddr_t). Use
(u_int64_t) instead of (daddr_t) when casting a variable in an
expression passed to DL_SETDSIZE().

Change a variable counting open files from daddr_t to int64_t.

ok deraadt@@ with the tweak to fix that pesky expression.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.64 2013/06/11 16:42:18 deraadt Exp $	*/
d292 1
a292 2
			bzero((char *)bp->b_data + offset,
			      (u_int)(size - offset));
d536 1
a536 1
		bcopy(bp->b_data, copy, (u_int) fs->fs_bsize);
@


1.64
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.63 2013/04/22 02:07:46 tedu Exp $	*/
d568 1
a568 2
					       (daddr_t)-1, level - 1,
					       &blkcount);
@


1.63
log
@ffs2 blockcount is unsigned, so we must check for underflow beforehand.
from freebsd. ok deraadt guenther otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.62 2013/01/16 22:41:47 beck Exp $	*/
d56 1
a56 1
int ffs_indirtrunc(struct inode *, daddr64_t, daddr64_t, daddr64_t, int, long *);
d160 3
a162 3
	daddr64_t lastblock;
	daddr64_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
	daddr64_t oldblks[NDADDR + NIADDR], newblks[NDADDR + NIADDR];
d472 2
a473 2
ffs_indirtrunc(struct inode *ip, daddr64_t lbn, daddr64_t dbn,
    daddr64_t lastbn, int level, long *countp)
d480 1
a480 1
	daddr64_t nb, nlbn, last;
d568 1
a568 1
					       (daddr64_t)-1, level - 1,
@


1.62
log
@re-backout the infamous softdep diff - originally committed to get around
the problem of the cleaner not being able to get softdep out of trouble
due to the removal of a reserve back in vienna.  Been run by me for a long
time and beat up, along with a bunch of others. Hopefully this nasty piece
of workaround can stay out for good now.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.61 2012/03/23 15:51:26 guenther Exp $	*/
d439 3
a441 2
	DIP_ADD(oip, blocks, -blocksreleased);
	if (DIP(oip, blocks) < 0)	/* Sanity */
@


1.61
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.60 2011/08/16 14:36:39 thib Exp $	*/
d167 1
a167 1
	int i, aflags, error, allerror, indirect = 0;
a168 2
	extern int num_indirdep;
	extern int max_indirdep;
a243 2
		if (bp->b_lblkno >= NDADDR)
			indirect = 1;
d252 1
a252 14
		error = UFS_UPDATE(oip, MNT_WAIT);
		if (DOINGSOFTDEP(ovp) && num_indirdep > max_indirdep)
			if (indirect) {
				/*
				 * If the number of pending indirect block
				 * dependencies is sufficiently close to the
				 * maximum number of simultaneously mappable
				 * buffers force a sync on the vnode to prevent
				 * buffer cache exhaustion.
				 */
				VOP_FSYNC(ovp, curproc->p_ucred, MNT_WAIT,
				    curproc);
			}
		return (error);
@


1.60
log
@Put back the pedro diff for VOP_FSYNC of softdep when its
limit is reached.

Added twist, clamp the max_softdeps to 64 as it is still
possible to exhaust bufkva.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.59 2011/08/03 20:21:19 beck Exp $	*/
d528 1
a528 1
		curproc->p_stats->p_ru.ru_inblock++;	/* pay for read */
@


1.59
log
@back out pedro diff for VOP_FSYNC of softdep when limit is reached.

The basic analysys is correct, however, the problem in this case is that by forcing
softdept to synchornously flush everything across *all* softdep filesystems we cause a
huge performance problem when we take a 3 second pause and slam everything synchronously.

the right way to fix this is to fix the speedup_softdep code, not make the filesystem
go synchronous when we hit a limit - if we are doing that we may as well not run softdep
it will be faster.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.58 2011/07/04 04:30:41 tedu Exp $	*/
d167 1
a167 1
	int i, aflags, error, allerror;
d169 2
d246 2
d256 14
a269 1
		return (UFS_UPDATE(oip, MNT_WAIT));
@


1.58
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.57 2011/04/12 19:45:43 beck Exp $	*/
d167 1
a167 1
	int i, aflags, error, allerror, indirect = 0;
a168 2
	extern int num_indirdep;
	extern int max_indirdep;
a243 2
		if (bp->b_lblkno >= NDADDR)
			indirect = 1;
d252 1
a252 14
		error = UFS_UPDATE(oip, MNT_WAIT);
		if (DOINGSOFTDEP(ovp) && num_indirdep > max_indirdep)
			if (indirect) {
				/*
				 * If the number of pending indirect block
				 * dependencies is sufficiently close to the
				 * maximum number of simultaneously mappable
				 * buffers force a sync on the vnode to prevent
				 * buffer cache exhaustion.
				 */
				VOP_FSYNC(ovp, curproc->p_ucred, MNT_WAIT,
				    curproc);
			}
		return (error);
@


1.57
log
@Avoid kvm starvation due to softdeps waiting on too many mapped buffers,
thus possibly consuming all of our available kva mapping buffers for
deps. Diff and analysis actually comes from Pedro Martelleto (thanks!)
tested by me and thib

ok thib@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.56 2009/01/15 07:58:36 grange Exp $	*/
d120 1
a120 1
		(int)fs->fs_bsize, NOCRED, &bp);
@


1.56
log
@Use proper *_ASSIGN() macros in assigments instead of abusing rvalue macros.
No binary change.

ok tedu@@

My 1000th commit!
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.55 2008/06/12 06:58:40 deraadt Exp $	*/
d167 1
a167 1
	int i, aflags, error, allerror;
d169 2
d246 2
d256 14
a269 1
		return (UFS_UPDATE(oip, MNT_WAIT));
@


1.55
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.53 2008/06/10 20:14:37 beck Exp $	*/
d449 7
d458 1
d539 1
a539 1
			BAP(ip, i) = 0;
@


1.54
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.52 2008/01/05 19:49:26 otto Exp $	*/
d504 2
@


1.53
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@a503 2
		bcstats.pendingreads++;
		bcstats.numreads++;
@


1.52
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.51 2007/10/29 17:06:20 chl Exp $	*/
d504 2
@


1.51
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.50 2007/09/23 20:15:07 millert Exp $	*/
d56 1
a56 1
int ffs_indirtrunc(struct inode *, daddr_t, daddr_t, daddr_t, int, long *);
d463 2
a464 2
ffs_indirtrunc(struct inode *ip, daddr_t lbn, daddr_t dbn, daddr_t lastbn,
    int level, long *countp)
d471 1
a471 1
	daddr_t nb, nlbn, last;
d557 1
a557 1
					       (daddr_t)-1, level - 1,
@


1.50
log
@Move notatime check from ffs_update() to ffs_read() and ufs_setattr().
Fixes a couple cases where atime was being updated even when the
filesystem was mounted with the noatime option.
Adapted from similar placement in FreeBSD and NetBSD.
Tested by myself and naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.49 2007/06/01 18:54:27 pedro Exp $	*/
d525 1
a525 1
		MALLOC(copy, void *, fs->fs_bsize, M_TEMP, M_WAITOK);
d582 1
a582 1
		FREE(copy, M_TEMP);
@


1.49
log
@cleanup of 'ufs1_daddr_t', first round, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.48 2007/06/01 06:38:54 deraadt Exp $	*/
a81 5
	}

	if ((vp->v_mount->mnt_flag & MNT_NOATIME) &&
	    !(ip->i_flag & (IN_CHANGE | IN_UPDATE))) {
		ip->i_flag &= ~IN_ACCESS;
@


1.48
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.47 2007/05/26 20:26:51 pedro Exp $	*/
d480 1
a480 1
	ufs1_daddr_t *bap1 = NULL;
d482 1
a482 1
	daddr64_t *bap2 = NULL;
d524 1
a524 1
		bap2 = (daddr64_t *) bp->b_data;
d527 1
a527 1
		bap1 = (ufs1_daddr_t *) bp->b_data;
d546 1
a546 1
			bap2 = (daddr64_t *) copy;
d549 1
a549 1
			bap1 = (ufs1_daddr_t *) copy;
@


1.47
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.46 2006/09/20 22:54:29 pedro Exp $	*/
d165 3
a167 3
	ufs2_daddr_t lastblock;
	ufs2_daddr_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
	ufs2_daddr_t oldblks[NDADDR + NIADDR], newblks[NDADDR + NIADDR];
d482 1
a482 1
	ufs2_daddr_t *bap2 = NULL;
d524 1
a524 1
		bap2 = (ufs2_daddr_t *) bp->b_data;
d546 1
a546 1
			bap2 = (ufs2_daddr_t *) copy;
@


1.46
log
@Use void * where void * is meant, spotted by tedu@@
No binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.45 2006/09/20 13:43:47 pedro Exp $	*/
d299 1
a299 1
		allocbuf(bp, size);
@


1.45
log
@Replace a bzero() by a loop in ffs_indirtrunc(), making the code FFS2
compatible, adapted from FreeBSD, okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.44 2006/04/05 12:59:20 pedro Exp $	*/
d475 1
a475 1
	caddr_t copy = NULL;
d530 1
a530 1
		MALLOC(copy, caddr_t, fs->fs_bsize, M_TEMP, M_WAITOK);
@


1.44
log
@Teach ffs_update() how to update FFS2 inodes
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.43 2006/04/05 12:55:53 pedro Exp $	*/
d56 1
a56 2
static int ffs_indirtrunc(struct inode *, daddr_t, daddr_t, daddr_t, int,
			       long *);
d452 6
d467 1
a467 1
static int
a473 1
	daddr_t *bap;
d475 2
a476 1
	daddr_t *copy = NULL, nb, nlbn, last;
d480 4
d522 7
a528 1
	bap = (daddr_t *)bp->b_data;
d530 6
a535 4
		MALLOC(copy, daddr_t *, fs->fs_bsize, M_TEMP, M_WAITOK);
		bcopy((caddr_t)bap, (caddr_t)copy, (u_int)fs->fs_bsize);
		bzero((caddr_t)&bap[last + 1],
		    (u_int)(NINDIR(fs) - (last + 1)) * sizeof (daddr_t));
d543 7
a549 1
		bap = copy;
d557 1
a557 1
		nb = bap[i];
d577 1
a577 1
		nb = bap[i];
@


1.43
log
@Make ffs_truncate() compatible with FFS2, from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.42 2005/12/28 20:48:17 pedro Exp $	*/
d137 9
a145 2
	*((struct ufs1_dinode *)bp->b_data +
	    ino_to_fsbo(fs, ip->i_number)) = *ip->i_din1;
@


1.42
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.41 2005/12/17 13:56:01 pedro Exp $	*/
d159 3
a161 3
	daddr_t lastblock;
	daddr_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
	daddr_t oldblks[NDADDR + NIADDR], newblks[NDADDR + NIADDR];
d317 2
a318 7

	if (fs->fs_magic == FS_UFS2_MAGIC)
		bcopy(&oip->i_ffs2_db[0], oldblks, sizeof(oldblks));
	else
		bcopy(&oip->i_ffs1_db[0], oldblks, sizeof(oldblks));

	for (level = TRIPLE; level >= SINGLE; level--)
d323 1
d325 5
a329 2
	for (i = NDADDR - 1; i > lastblock; i--)
		DIP_ASSIGN(oip, db[i], 0);
d341 4
d346 3
a348 6
	if (fs->fs_magic == FS_UFS2_MAGIC) {
		bcopy(&oip->i_ffs2_db[0], newblks, sizeof(newblks));
		bcopy(oldblks, &oip->i_ffs2_db[0], sizeof(oldblks));
	} else {
		bcopy(&oip->i_ffs1_db[0], newblks, sizeof(newblks));
		bcopy(oldblks, &oip->i_ffs1_db[0], sizeof(oldblks));
@


1.41
log
@Remove the 'on disk' inode (dinode) from the 'in memory' inode in UFS.
Instead of having the dinode inside the inode structure itself, we now
have just a pointer to it, and use a separate pool to allocate dinodes
as needed. Inspiration from FreeBSD, various testing for a while, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.40 2005/11/09 15:35:53 pedro Exp $	*/
d98 2
a99 2
		ip->i_ffs_atime = atime ? atime->tv_sec : ts.tv_sec;
		ip->i_ffs_atimensec = atime ? atime->tv_nsec : ts.tv_nsec;
d103 2
a104 2
		ip->i_ffs_mtime = mtime ? mtime->tv_sec : ts.tv_sec;
		ip->i_ffs_mtimensec = mtime ? mtime->tv_nsec : ts.tv_nsec;
d109 2
a110 2
		ip->i_ffs_ctime = ts.tv_sec;
		ip->i_ffs_ctimensec = ts.tv_nsec;
d120 3
a122 3
	if (fs->fs_inodefmt < FS_44INODEFMT) {
		ip->i_din1->di_ouid = ip->i_ffs_uid;
		ip->i_din1->di_ogid = ip->i_ffs_gid;
d134 1
a134 1
	else if (ip->i_effnlink != ip->i_ffs_nlink) 
d178 1
a178 1
	if (oip->i_ffs_size == length)
d180 1
d182 1
a182 1
	    (oip->i_ffs_size < ovp->v_mount->mnt_maxsymlinklen ||
d189 2
a190 2
		bzero((char *)&oip->i_ffs_shortlink, (u_int)oip->i_ffs_size);
		oip->i_ffs_size = 0;
d217 1
a217 1
			(void)ufs_quota_free_blocks(oip, oip->i_ffs_blocks, 
d227 1
a227 1
	osize = oip->i_ffs_size; 
d243 1
a243 1
		oip->i_ffs_size = length;
d265 1
a265 1
		oip->i_ffs_size = length;
d287 1
a287 1
		oip->i_ffs_size = length;
d310 1
d317 6
a322 1
	bcopy((caddr_t)&oip->i_ffs_db[0], (caddr_t)oldblks, sizeof oldblks);
d325 1
a325 1
			oip->i_ffs_ib[level] = 0;
d328 1
d330 2
a331 1
		oip->i_ffs_db[i] = 0;
d335 1
d342 10
a351 3
	bcopy((caddr_t)&oip->i_ffs_db[0], (caddr_t)newblks, sizeof newblks);
	bcopy((caddr_t)oldblks, (caddr_t)&oip->i_ffs_db[0], sizeof oldblks);
	oip->i_ffs_size = osize;
d362 1
a362 1
		bn = oip->i_ffs_ib[level];
d370 1
a370 1
				oip->i_ffs_ib[level] = 0;
d385 1
a385 1
		bn = oip->i_ffs_db[i];
d388 2
a389 1
		oip->i_ffs_db[i] = 0;
d401 1
a401 1
	bn = oip->i_ffs_db[lastblock];
d410 1
a410 1
		oip->i_ffs_size = length;
d428 1
a428 1
		if (newblks[NDADDR + level] != oip->i_ffs_ib[level])
d431 1
a431 1
		if (newblks[i] != oip->i_ffs_db[i])
d437 4
a440 4
	oip->i_ffs_size = length;
	oip->i_ffs_blocks -= blocksreleased;
	if (oip->i_ffs_blocks < 0)			/* sanity */
		oip->i_ffs_blocks = 0;
@


1.40
log
@ANSI function declarations and deregister, only ffs_softdep left to go
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.39 2005/11/09 02:29:11 pedro Exp $	*/
d121 2
a122 2
		ip->i_din1.di_ouid = ip->i_ffs_uid;		/* XXX */
		ip->i_din1.di_ogid = ip->i_ffs_gid;		/* XXX */
d138 1
a138 1
	    ino_to_fsbo(fs, ip->i_number)) = ip->i_din1;
d183 1
a183 1
	      oip->i_din1.di_blocks == 0))) {
@


1.39
log
@- Don't getnanotime() for read-only mountpoints or unmodified inodes,
  since we won't use that information.
- Don't call getnanotime() a second time for IN_CHANGE inodes.
- Space the code a bit, so it's actually readable.

Testing jolan@@ and krw@@, okay krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.38 2005/07/03 20:14:01 drahn Exp $	*/
d150 1
d166 1
a166 2
	register int i;
	int aflags, error, allerror;
d366 1
a366 1
		register long bsize;
d438 2
a439 6
ffs_indirtrunc(ip, lbn, dbn, lastbn, level, countp)
	register struct inode *ip;
	daddr_t lbn, lastbn;
	daddr_t dbn;
	int level;
	long *countp;
d441 1
a441 1
	register int i;
d443 2
a444 2
	register struct fs *fs = ip->i_fs;
	register daddr_t *bap;
@


1.38
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.37 2004/06/24 19:35:26 tholo Exp $	*/
a77 1
	getnanotime(&ts);
d83 3
a85 1
	} else if ((vp->v_mount->mnt_flag & MNT_NOATIME) &&
d89 1
d94 3
d101 1
d107 1
a108 3
		struct timespec ts;

		getnanotime(&ts);
d112 1
d115 1
d120 1
a120 1
	if (fs->fs_inodefmt < FS_44INODEFMT) {		/* XXX */
d123 2
a124 1
	}						/* XXX */
@


1.37
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.36 2003/11/19 03:29:31 mickey Exp $	*/
a47 1
#include <ufs/ufs/extattr.h>
@


1.36
log
@undo boolshit unapproved changes the author does not even care about to fix
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.34 2003/08/25 23:26:55 tedu Exp $	*/
d79 1
a79 1
	TIMEVAL_TO_TIMESPEC(&time, &ts);
d103 5
a107 2
		ip->i_ffs_ctime = time.tv_sec;
		ip->i_ffs_ctimensec = time.tv_usec * 1000;
@


1.35
log
@MALLOC is not meant for variable size allocations
@
text
@d485 1
a485 1
		copy = malloc(fs->fs_bsize, M_TEMP, M_WAITOK);
@


1.34
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
few other little cleanups.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.33 2003/06/02 23:28:23 millert Exp $	*/
d485 1
a485 1
		MALLOC(copy, daddr_t *, fs->fs_bsize, M_TEMP, M_WAITOK);
@


1.33
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.32 2002/03/14 01:27:14 millert Exp $	*/
d113 2
a114 2
		ip->i_din.ffs_din.di_ouid = ip->i_ffs_uid;		/* XXX */
		ip->i_din.ffs_din.di_ogid = ip->i_ffs_gid;		/* XXX */
d128 2
a129 2
	*((struct dinode *)bp->b_data +
	    ino_to_fsbo(fs, ip->i_number)) = ip->i_din.ffs_din;
d174 1
a174 1
	      oip->i_din.ffs_din.di_blocks == 0))) {
@


1.32
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.31 2002/02/22 20:37:46 drahn Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.31
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.30 2002/01/04 03:53:23 nordin Exp $	*/
d61 2
a62 2
static int ffs_indirtrunc __P((struct inode *, daddr_t, daddr_t, daddr_t, int,
			       long *));
@


1.30
log
@Handle truncation to the middle of a file hole. deraadt@@ ok
From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.29 2001/12/19 08:58:07 art Exp $	*/
d52 1
@


1.29
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.25 2001/11/21 21:23:56 csapuntz Exp $	*/
d267 12
@


1.28
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.27 2001/12/10 02:19:34 art Exp $	*/
d151 1
a151 2
	struct vnode *ovp = ITOV(oip);
	struct genfs_node *gp = VTOG(ovp);
d153 1
a153 1
	daddr_t bn, lastiblock[NIADDR], indir_lbn[NIADDR];
d156 1
a156 1
	struct proc *p = curproc;
d160 1
a160 1
	int error, allerror;
d165 1
d191 1
a191 4
	fs = oip->i_fs;
	if (length > fs->fs_maxfilesize)
		return (EFBIG);
	osize = oip->i_ffs_size; 
a194 42
	/*
	 * Lengthen the size of the file. We must ensure that the
	 * last byte of the file is allocated. Since the smallest
	 * value of osize is 0, length will be at least 1.
	 */

	if (osize < length) {
		ufs_balloc_range(ovp, length - 1, 1, cred,
		    flags & IO_SYNC ? B_SYNC : 0);
		oip->i_flag |= IN_CHANGE | IN_UPDATE;
		return (UFS_UPDATE(oip, 1));
	}

	/*
	 * When truncating a regular file down to a non-block-aligned size,
	 * we must zero the part of last block which is past the new EOF.
	 * We must synchronously flush the zeroed pages to disk
	 * since the new pages will be invalidated as soon as we
	 * inform the VM system of the new, smaller size.
	 * We must to this before acquiring the GLOCK, since fetching
	 * the pages will acquire the GLOCK internally.
	 * So there is a window where another thread could see a whole
	 * zeroed page past EOF, but that's life.
	 */

	offset = blkoff(fs, length);
	if (ovp->v_type == VREG && length < osize && offset != 0) {
		struct uvm_object *uobj;
		voff_t eoz;

		size = blksize(fs, oip, lblkno(fs, length));
		eoz = min(lblktosize(fs, lblkno(fs, length)) + size, osize);
		uvm_vnp_zerorange(ovp, length, eoz - length);
		uobj = &ovp->v_uobj;
		simple_lock(&uobj->vmobjlock);
		uobj->pgops->pgo_flush(uobj, length, eoz,
		    PGO_CLEANIT|PGO_DEACTIVATE|PGO_SYNCIO);
		simple_unlock(&uobj->vmobjlock);
	}

	lockmgr(&gp->g_glock, LK_EXCLUSIVE, NULL, p);

d207 1
a207 2
			    curproc)) != 0) {
				lockmgr(&gp->g_glock, LK_RELEASE, NULL, p);
a208 1
			}
a209 1
			uvm_vnp_setsize(ovp, length);
a213 1
			lockmgr(&gp->g_glock, LK_RELEASE, NULL, p);
d219 2
d222 3
a224 1
	 * Reduce the size of the file.
d226 20
a245 1
	oip->i_ffs_size = length;
d249 32
a404 1
	lockmgr(&gp->g_glock, LK_RELEASE, NULL, p);
@


1.28.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.30 2002/01/04 03:53:23 nordin Exp $	*/
a272 4


/* XXXUBC - see revision 1.30 of ffs_inode.c */

@


1.28.2.2
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.28.2.1 2002/01/31 22:55:49 niklas Exp $	*/
a206 1
		uvm_vnp_setsize(ovp, length);
d233 3
a235 5
		error = (uobj->pgops->pgo_put)(uobj, trunc_page(length),
		    round_page(eoz), PGO_CLEANIT|PGO_DEACTIVATE|PGO_SYNCIO);
		if (error) {
			return (error);
		}
@


1.28.2.3
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.28.2.2 2002/02/02 03:28:26 art Exp $	*/
a51 1
#include <ufs/ufs/extattr.h>
d60 2
a61 2
static int ffs_indirtrunc(struct inode *, daddr_t, daddr_t, daddr_t, int,
			       long *);
@


1.28.2.4
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.28.2.3 2002/06/11 03:32:50 art Exp $	*/
d75 1
a75 1
    struct timespec *mtime, int flags)
a81 1
	int waitfor;
d93 3
a95 10

	if ((ip->i_flag & IN_MODIFIED) != 0 && !DOINGASYNC(vp)) {
		waitfor = flags & UPDATE_WAIT;
		if ((flags & UPDATE_DIROP) && !DOINGSOFTDEP(vp))
			waitfor |= UPDATE_WAIT;
	} else
		waitfor = 0;

	if (!waitfor && (ip->i_flag &
	    (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0)
d134 1
a134 1
	if (waitfor) {
d161 2
a162 2
	int i, ioflag, aflag;
	int error, allerror = 0;
d173 2
d186 1
a186 1
		return (UFS_UPDATE(oip, UPDATE_WAIT));
a188 4
	if (oip->i_ffs_size == length) {
		oip->i_flag |= IN_CHANGE | IN_UPDATE;
		return (UFS_UPDATE(oip, 0));
	}
d195 3
a197 3
	osize = oip->i_ffs_size;
	ioflag = flags;
	aflag = ioflag & IO_SYNC ? B_SYNC : 0;
d206 2
a207 24
		if (lblkno(fs, osize) < NDADDR &&
		    lblkno(fs, osize) != lblkno(fs, length) &&
		    blkroundup(fs, osize) != osize) {
			error = ufs_balloc_range(ovp, osize,
			    blkroundup(fs, osize) - osize, cred, aflag);
			if (error) {
				return error;
			}
			if (ioflag & IO_SYNC) {
				ovp->v_size = blkroundup(fs, osize);
				simple_lock(&ovp->v_interlock);
				VOP_PUTPAGES(ovp,
				    trunc_page(osize & ~(fs->fs_bsize - 1)),
				    round_page(ovp->v_size),
				    PGO_CLEANIT | PGO_SYNCIO);
			}
		}
		error = ufs_balloc_range(ovp, length - 1, 1, cred,
		    aflag);
		if (error) {
			UFS_TRUNCATE(oip, osize, ioflag & IO_SYNC,
			    cred);
			return (error);
		}
d210 1
a210 1
		return (UFS_UPDATE(oip, UPDATE_WAIT));
d219 1
a219 1
	 * We must do this before acquiring the GLOCK, since fetching
d227 1
a229 5
		error = ufs_balloc_range(ovp, length - 1, 1, cred,
		    aflag);
		if (error) {
			return error;
		}
d231 1
a231 1
		eoz = MIN(lblktosize(fs, lblkno(fs, length)) + size, osize);
d233 4
a236 3
		simple_lock(&ovp->v_interlock);
		error = VOP_PUTPAGES(ovp, trunc_page(length), round_page(eoz),
		    PGO_CLEANIT | PGO_DEACTIVATE | PGO_SYNCIO);
d278 4
d308 1
a308 2
	error = UFS_UPDATE(oip, UPDATE_WAIT);
	if (error && !allerror)
d320 1
a320 3
	error = vinvalbuf(ovp, vflags, cred, curproc, 0, 0);
	if (error && !allerror)
		allerror = error;
d350 1
a350 1
		long bsize;
d424 1
a424 1
	struct inode *ip;
d430 1
a430 1
	int i;
d432 2
a433 2
	struct fs *fs = ip->i_fs;
	ufs_daddr_t *bap;
d435 1
a435 1
	ufs_daddr_t *copy = NULL, nb, nlbn, last;
d477 3
a479 3
	bap = (ufs_daddr_t *)bp->b_data;
	if (lastbn >= 0) {
		copy = (ufs_daddr_t *)malloc(fs->fs_bsize, M_TEMP, M_WAITOK);
a526 1

d528 1
a528 1
		free(copy, M_TEMP);
d533 1
a533 1

@


1.27
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.26 2001/11/27 05:27:12 art Exp $	*/
d151 2
a152 1
	struct vnode *ovp;
a165 1
	ovp = ITOV(oip);
d238 1
a238 1
	lockmgr(&ovp->v_glock, LK_EXCLUSIVE, NULL, p);
d253 1
a253 1
				lockmgr(&ovp->v_glock, LK_RELEASE, NULL, p);
d262 1
a262 1
			lockmgr(&ovp->v_glock, LK_RELEASE, NULL, p);
d399 1
a399 1
	lockmgr(&ovp->v_glock, LK_RELEASE, NULL, p);
@


1.26
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.25 2001/11/21 21:23:56 csapuntz Exp $	*/
d231 1
a231 1
		uobj = &ovp->v_uvm.u_obj;
d235 1
a235 1
		simple_unlock(&ovp->v_uvm.u_obj.vmobjlock);
@


1.25
log
@Don't use #define QUOTA - use stub file instead

Pass over the quota code in ufs/. Make code paths clearer. Clean up some names.
Move all code that manipulates quotas directly into ufs_quota.c

Use vfs_mount_foreach_vnode to traverse list of vnodes in mountpoint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.24 2001/11/06 19:53:21 miod Exp $	*/
d153 1
a153 1
	daddr_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
d156 1
a156 1
	struct buf *bp;
d160 1
a160 1
	int aflags, error, allerror;
d191 4
a194 1
	uvm_vnp_setsize(ovp, length);
d198 42
d252 2
a253 1
					       curproc)) != 0)
d255 1
d257 1
d262 1
a267 2
	fs = oip->i_fs;
	osize = oip->i_ffs_size; 
d269 1
a269 3
	 * Lengthen the size of the file. We must ensure that the
	 * last byte of the file is allocated. Since the smallest
	 * value of osize is 0, length will be at least 1.
d271 1
a271 20
	if (osize < length) {
		if (length > fs->fs_maxfilesize)
			return (EFBIG);
		aflags = B_CLRBUF;
		if (flags & IO_SYNC)
			aflags |= B_SYNC;
		error = UFS_BUF_ALLOC(oip, length - 1, 1, 
				   cred, aflags, &bp);
		if (error)
			return (error);
		oip->i_ffs_size = length;
		uvm_vnp_setsize(ovp, length);
		(void) uvm_vnp_uncache(ovp);
		if (aflags & B_SYNC)
			bwrite(bp);
		else
			bawrite(bp);
		oip->i_flag |= IN_CHANGE | IN_UPDATE;
		return (UFS_UPDATE(oip, MNT_WAIT));
	}
a274 32
	 * Shorten the size of the file. If the file is not being
	 * truncated to a block boundary, the contents of the
	 * partial block following the end of the file must be
	 * zero'ed in case it ever becomes accessible again because
	 * of subsequent file growth. Directories however are not
	 * zero'ed as they should grow back initialized to empty.
	 */
	offset = blkoff(fs, length);
	if (offset == 0) {
		oip->i_ffs_size = length;
	} else {
		lbn = lblkno(fs, length);
		aflags = B_CLRBUF;
		if (flags & IO_SYNC)
			aflags |= B_SYNC;
		error = UFS_BUF_ALLOC(oip, length - 1, 1,
				   cred, aflags, &bp);
		if (error)
			return (error);
		oip->i_ffs_size = length;
		size = blksize(fs, oip, lbn);
		(void) uvm_vnp_uncache(ovp);
		if (ovp->v_type != VDIR)
			bzero((char *)bp->b_data + offset,
			      (u_int)(size - offset));
		allocbuf(bp, size);
		if (aflags & B_SYNC)
			bwrite(bp);
		else
			bawrite(bp);
	}
	/*
d399 1
@


1.24
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.23 2001/07/16 03:44:23 csapuntz Exp $	*/
d187 1
a187 1
#ifdef QUOTA
d190 1
a190 1
#endif
d210 2
a211 3
#ifdef QUOTA
			(void) chkdq(oip, -oip->i_ffs_blocks, NOCRED, 0);
#endif
d406 1
a406 3
#ifdef QUOTA
	(void) chkdq(oip, -blocksreleased, NOCRED, 0);
#endif
@


1.23
log
@

Make truncating a device a no-op instead of returning an error. We can
fix the rest of the kernel some other time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.22 2001/07/16 02:56:48 csapuntz Exp $	*/
a48 2

#include <vm/vm.h>
@


1.22
log
@

Don't try to truncate anything except for symlinks, directories, and
regular files.

ftruncate and truncate that go through FFS/EXT2FS/MFS will now return
EINVAL when done on devices.

Bug introduced when VOP_TRUNCATE was removed, thus removing spec_truncate.

Thanks to millert@@ for tracking this one down.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.21 2001/06/27 04:58:48 art Exp $	*/
d172 1
a172 1
		return (EINVAL);
@


1.21
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.20 2001/06/23 02:07:54 csapuntz Exp $	*/
d168 6
@


1.20
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.19 2001/03/20 19:50:30 art Exp $	*/
a51 1
#if defined(UVM)
a52 1
#endif
a186 1
#if defined(UVM)
a187 3
#else
	vnode_pager_setsize(ovp, (u_long)length);
#endif
a233 1
#if defined(UVM)
a235 4
#else
		vnode_pager_setsize(ovp, (u_long)length);
		(void) vnode_pager_uncache(ovp);
#endif
a242 1
#if defined(UVM)
a243 3
#else
	vnode_pager_setsize(ovp, (u_long)length);
#endif
a266 1
#if defined(UVM)
a267 3
#else
		(void) vnode_pager_uncache(ovp);
#endif
@


1.19
log
@cleaning
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.18 2001/02/23 14:42:39 csapuntz Exp $	*/
d77 2
a78 2
ffs_update(v)
	void *v;
d80 2
a81 7
	struct vop_update_args /* {
		struct vnode *a_vp;
		struct timespec *a_access;
		struct timespec *a_modify;
		int a_waitfor;
	} */ *ap = v;
	register struct fs *fs;
a82 1
	struct inode *ip;
d84 1
d86 3
a88 2
	ip = VTOI(ap->a_vp);
	if (ap->a_vp->v_mount->mnt_flag & MNT_RDONLY) {
d92 1
a92 1
	} else if ((ap->a_vp->v_mount->mnt_flag & MNT_NOATIME) &&
d98 1
a98 1
	    ap->a_waitfor != MNT_WAIT)
d101 2
a102 2
		ip->i_ffs_atime = ap->a_access->tv_sec;
		ip->i_ffs_atimensec = ap->a_access->tv_nsec;
d105 2
a106 2
		ip->i_ffs_mtime = ap->a_modify->tv_sec;
		ip->i_ffs_mtimensec = ap->a_modify->tv_nsec;
d130 2
a131 2
	if (DOINGSOFTDEP(ap->a_vp))
		softdep_update_inodeblock(ip, bp, ap->a_waitfor);
d137 1
a137 1
	if (ap->a_waitfor && !DOINGASYNC(ap->a_vp)) {
d153 1
a153 2
ffs_truncate(v)
	void *v;
d155 2
a156 10
	struct vop_truncate_args /* {
		struct vnode *a_vp;
		off_t a_length;
		int a_flags;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	register struct vnode *ovp = ap->a_vp;
	register daddr_t lastblock;
	register struct inode *oip;
d159 1
a159 2
	off_t length = ap->a_length;
	register struct fs *fs;
a162 1
	struct timespec ts;
d169 1
a169 1
	oip = VTOI(ovp);
a171 1
	TIMEVAL_TO_TIMESPEC(&time, &ts);
d183 1
a183 1
		return (VOP_UPDATE(ovp, &ts, &ts, 1));
d208 2
a209 2
			if ((error = VOP_FSYNC(ovp, ap->a_cred, MNT_WAIT,
					       ap->a_p)) != 0)
d216 1
a216 1
			(void) vinvalbuf(ovp, 0, ap->a_cred, ap->a_p, 0, 0);
d218 1
a218 1
			return (VOP_UPDATE(ovp, &ts, &ts, 0));
d233 1
a233 1
		if (ap->a_flags & IO_SYNC)
d235 2
a236 2
		error = VOP_BALLOC(ovp, length - 1, 1, 
				   ap->a_cred, aflags, &bp);
d252 1
a252 1
		return (VOP_UPDATE(ovp, &ts, &ts, 1));
d274 1
a274 1
		if (ap->a_flags & IO_SYNC)
d276 2
a277 2
		error = VOP_BALLOC(ovp, length - 1, 1,
				   ap->a_cred, aflags, &bp);
d322 1
a322 1
	if ((error = VOP_UPDATE(ovp, &ts, &ts, 1)) != 0)
d334 1
a334 1
	allerror = vinvalbuf(ovp, vflags, ap->a_cred, ap->a_p, 0, 0);
@


1.18
log
@

Remove the clustering fields from the vnodes and place them in the
file system inode instead
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.17 2001/02/21 23:24:31 csapuntz Exp $	*/
d69 6
a74 6
 * IACCESS, IUPDATE, and ICHANGE flags respectively. The IMODIFIED flag is
 * used to specify that the inode needs to be updated but that the times have
 * already been set. The access and modified times are taken from the second
 * and third parameters; the inode change time is always taken from the current
 * time. If waitfor is set, then wait for the disk write of the inode to
 * complete.
d127 2
a128 3
	error = bread(ip->i_devvp,
		      fsbtodb(fs, ino_to_fsba(fs, ip->i_number)),
		      (int)fs->fs_bsize, NOCRED, &bp);
d251 1
a251 1
		error = VOP_BALLOC(ovp, length -1, 1, 
d280 1
a280 1
	 * zero'ed in case it ever become accessible again because
d409 1
a409 1
			panic("itrunc: newspace");
d425 1
a425 1
			panic("itrunc1");
d428 1
a428 1
			panic("itrunc2");
d466 1
a466 1
	daddr_t *copy, nb, nlbn, last;
d558 1
a558 1
	if (lastbn != -1) {
@


1.17
log
@

Latest soft updates from FreeBSD/Kirk McKusick

Snapshot-related code has been commented out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.16 2000/06/23 02:14:39 mickey Exp $	*/
d211 3
a213 1
	ovp->v_lasta = ovp->v_clen = ovp->v_cstart = ovp->v_lastw = 0;
@


1.16
log
@remove obsolete vtrace guts; art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.15 1999/12/06 07:23:21 art Exp $	*/
d142 1
a142 1
	if (ap->a_waitfor && (ap->a_vp->v_mount->mnt_flag & MNT_ASYNC) == 0) {
d213 1
a213 1
		if (length > 0) {
d513 1
a513 1
		if ((vp->v_mount->mnt_flag & MNT_ASYNC) == 0) {
@


1.15
log
@When truncating directories by less than a block we shouldn't zero the
part of the block that we're deallocating.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.14 1999/12/06 07:03:04 art Exp $	*/
a47 1
#include <sys/trace.h>
d492 1
a492 5
	if (bp->b_flags & (B_DONE | B_DELWRI)) {
		/* Braces must be here in case trace evaluates to nothing. */
		trace(TR_BREADHIT, pack(vp, fs->fs_bsize), lbn);
	} else {
		trace(TR_BREADMISS, pack(vp, fs->fs_bsize), lbn);
@


1.15.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.19 2001/03/20 19:50:30 art Exp $	*/
d48 1
d70 6
a75 6
 * IN_ACCESS, IN_UPDATE, and IN_CHANGE flags respectively. The IN_MODIFIED
 * flag is used to specify that the inode needs to be updated but that the
 * times have already been set. The access and modified times are taken from
 * the second and third parameters; the inode change time is always taken
 * from the current time. If waitfor is set, then wait for the disk write
 * of the inode to complete.
d128 3
a130 2
	error = bread(ip->i_devvp, fsbtodb(fs, ino_to_fsba(fs, ip->i_number)),
		(int)fs->fs_bsize, NOCRED, &bp);
d143 1
a143 1
	if (ap->a_waitfor && !DOINGASYNC(ap->a_vp)) {
d212 1
a212 3
	oip->i_ci.ci_lasta = oip->i_ci.ci_clen 
	    = oip->i_ci.ci_cstart = oip->i_ci.ci_lastw = 0;

d214 1
a214 1
		if (length > 0 || softdep_slowdown(ovp)) {
d251 1
a251 1
		error = VOP_BALLOC(ovp, length - 1, 1, 
d280 1
a280 1
	 * zero'ed in case it ever becomes accessible again because
d409 1
a409 1
			panic("ffs_truncate: newspace");
d425 1
a425 1
			panic("ffs_truncate1");
d428 1
a428 1
			panic("ffs_truncate2");
d466 1
a466 1
	daddr_t *copy = NULL, nb, nlbn, last;
d493 5
a497 1
	if (!(bp->b_flags & (B_DONE | B_DELWRI))) {
d518 1
a518 1
		if (!DOINGASYNC(vp)) {
d562 1
a562 1
	if (copy != NULL) {
@


1.15.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.15.2.1 2001/05/14 22:47:40 niklas Exp $	*/
d52 1
d54 1
d77 2
a78 2
ffs_update(struct inode *ip, struct timespec *atime, 
    struct timespec *mtime, int waitfor)
d80 7
a86 2
	struct vnode *vp;
	struct fs *fs;
d88 1
a89 1
	struct timespec ts;
d91 2
a92 3
	TIMEVAL_TO_TIMESPEC(&time, &ts);
	vp = ITOV(ip);
	if (vp->v_mount->mnt_flag & MNT_RDONLY) {
d96 1
a96 1
	} else if ((vp->v_mount->mnt_flag & MNT_NOATIME) &&
d102 1
a102 1
	    waitfor != MNT_WAIT)
d105 2
a106 2
		ip->i_ffs_atime = atime ? atime->tv_sec : ts.tv_sec;
		ip->i_ffs_atimensec = atime ? atime->tv_nsec : ts.tv_nsec;
d109 2
a110 2
		ip->i_ffs_mtime = mtime ? mtime->tv_sec : ts.tv_sec;
		ip->i_ffs_mtimensec = mtime ? mtime->tv_nsec : ts.tv_nsec;
d134 2
a135 2
	if (DOINGSOFTDEP(vp))
		softdep_update_inodeblock(ip, bp, waitfor);
d141 1
a141 1
	if (waitfor && !DOINGASYNC(vp)) {
d157 2
a158 1
ffs_truncate(struct inode *oip, off_t length, int flags, struct ucred *cred)
d160 10
a169 2
	struct vnode *ovp;
	daddr_t lastblock;
d172 2
a173 1
	struct fs *fs;
d177 1
d184 1
a184 1
	ovp = ITOV(oip);
d187 1
d199 1
a199 1
		return (UFS_UPDATE(oip, MNT_WAIT));
d205 1
d207 3
d224 2
a225 2
			if ((error = VOP_FSYNC(ovp, cred, MNT_WAIT,
					       curproc)) != 0)
d232 1
a232 1
			(void) vinvalbuf(ovp, 0, cred, curproc, 0, 0);
d234 1
a234 1
			return (UFS_UPDATE(oip, 0));
d249 1
a249 1
		if (flags & IO_SYNC)
d251 2
a252 2
		error = UFS_BUF_ALLOC(oip, length - 1, 1, 
				   cred, aflags, &bp);
d256 1
d259 4
d268 1
a268 1
		return (UFS_UPDATE(oip, MNT_WAIT));
d270 1
d272 3
d290 1
a290 1
		if (flags & IO_SYNC)
d292 2
a293 2
		error = UFS_BUF_ALLOC(oip, length - 1, 1,
				   cred, aflags, &bp);
d298 1
d300 3
d338 1
a338 1
	if ((error = UFS_UPDATE(oip, MNT_WAIT)) != 0)
d350 1
a350 1
	allerror = vinvalbuf(ovp, vflags, cred, curproc, 0, 0);
@


1.15.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.15.2.2 2001/07/04 11:00:49 niklas Exp $	*/
a167 6

	if (ovp->v_type != VREG &&
	    ovp->v_type != VDIR &&
	    ovp->v_type != VLNK)
		return (0);

@


1.15.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d49 2
@


1.15.2.5
log
@Merge in -current
@
text
@d153 1
a153 1
	daddr_t bn, lastiblock[NIADDR], indir_lbn[NIADDR];
d156 1
a156 1
	struct proc *p = curproc;
d160 1
a160 1
	int error, allerror;
d187 1
a187 1

d190 2
a191 5

	fs = oip->i_fs;
	if (length > fs->fs_maxfilesize)
		return (EFBIG);
	osize = oip->i_ffs_size; 
a194 42
	/*
	 * Lengthen the size of the file. We must ensure that the
	 * last byte of the file is allocated. Since the smallest
	 * value of osize is 0, length will be at least 1.
	 */

	if (osize < length) {
		ufs_balloc_range(ovp, length - 1, 1, cred,
		    flags & IO_SYNC ? B_SYNC : 0);
		oip->i_flag |= IN_CHANGE | IN_UPDATE;
		return (UFS_UPDATE(oip, 1));
	}

	/*
	 * When truncating a regular file down to a non-block-aligned size,
	 * we must zero the part of last block which is past the new EOF.
	 * We must synchronously flush the zeroed pages to disk
	 * since the new pages will be invalidated as soon as we
	 * inform the VM system of the new, smaller size.
	 * We must to this before acquiring the GLOCK, since fetching
	 * the pages will acquire the GLOCK internally.
	 * So there is a window where another thread could see a whole
	 * zeroed page past EOF, but that's life.
	 */

	offset = blkoff(fs, length);
	if (ovp->v_type == VREG && length < osize && offset != 0) {
		struct uvm_object *uobj;
		voff_t eoz;

		size = blksize(fs, oip, lblkno(fs, length));
		eoz = min(lblktosize(fs, lblkno(fs, length)) + size, osize);
		uvm_vnp_zerorange(ovp, length, eoz - length);
		uobj = &ovp->v_uvm.u_obj;
		simple_lock(&uobj->vmobjlock);
		uobj->pgops->pgo_flush(uobj, length, eoz,
		    PGO_CLEANIT|PGO_DEACTIVATE|PGO_SYNCIO);
		simple_unlock(&ovp->v_uvm.u_obj.vmobjlock);
	}

	lockmgr(&ovp->v_glock, LK_EXCLUSIVE, NULL, p);

d207 1
a207 2
			    curproc)) != 0) {
				lockmgr(&ovp->v_glock, LK_RELEASE, NULL, p);
a208 1
			}
d210 3
a212 3
			uvm_vnp_setsize(ovp, length);
			(void)ufs_quota_free_blocks(oip, oip->i_ffs_blocks, 
			    NOCRED);
a214 1
			lockmgr(&ovp->v_glock, LK_RELEASE, NULL, p);
d220 2
d223 3
a225 1
	 * Reduce the size of the file.
d227 20
a246 1
	oip->i_ffs_size = length;
d250 32
a405 1
	lockmgr(&ovp->v_glock, LK_RELEASE, NULL, p);
d407 3
a409 1
	(void)ufs_quota_free_blocks(oip, blocksreleased, NOCRED);
@


1.15.2.6
log
@Merge in trunk
@
text
@a51 1
#include <ufs/ufs/extattr.h>
d153 1
a153 1
	daddr_t bn, lbn, lastiblock[NIADDR], indir_lbn[NIADDR];
d156 1
a156 1
	struct buf *bp;
d160 1
a160 1
	int aflags, error, allerror;
d191 4
a194 1
	uvm_vnp_setsize(ovp, length);
d198 42
d252 2
a253 1
					       curproc)) != 0)
d255 1
d257 1
d262 1
a267 2
	fs = oip->i_fs;
	osize = oip->i_ffs_size; 
d269 1
a269 3
	 * Lengthen the size of the file. We must ensure that the
	 * last byte of the file is allocated. Since the smallest
	 * value of osize is 0, length will be at least 1.
d271 1
a271 20
	if (osize < length) {
		if (length > fs->fs_maxfilesize)
			return (EFBIG);
		aflags = B_CLRBUF;
		if (flags & IO_SYNC)
			aflags |= B_SYNC;
		error = UFS_BUF_ALLOC(oip, length - 1, 1, 
				   cred, aflags, &bp);
		if (error)
			return (error);
		oip->i_ffs_size = length;
		uvm_vnp_setsize(ovp, length);
		(void) uvm_vnp_uncache(ovp);
		if (aflags & B_SYNC)
			bwrite(bp);
		else
			bawrite(bp);
		oip->i_flag |= IN_CHANGE | IN_UPDATE;
		return (UFS_UPDATE(oip, MNT_WAIT));
	}
a274 44
	 * Shorten the size of the file. If the file is not being
	 * truncated to a block boundary, the contents of the
	 * partial block following the end of the file must be
	 * zero'ed in case it ever becomes accessible again because
	 * of subsequent file growth. Directories however are not
	 * zero'ed as they should grow back initialized to empty.
	 */
	offset = blkoff(fs, length);
	if (offset == 0) {
		oip->i_ffs_size = length;
	} else {
		lbn = lblkno(fs, length);
		aflags = B_CLRBUF;
		if (flags & IO_SYNC)
			aflags |= B_SYNC;
		error = UFS_BUF_ALLOC(oip, length - 1, 1,
				   cred, aflags, &bp);
		if (error)
			return (error);
		/*
		 * When we are doing soft updates and the UFS_BALLOC
		 * above fills in a direct block hole with a full sized
		 * block that will be truncated down to a fragment below,
		 * we must flush out the block dependency with an FSYNC
		 * so that we do not get a soft updates inconsistency
		 * when we create the fragment below.
		 */
		if (DOINGSOFTDEP(ovp) && lbn < NDADDR &&
		    fragroundup(fs, blkoff(fs, length)) < fs->fs_bsize &&
		    (error = VOP_FSYNC(ovp, cred, MNT_WAIT, curproc)) != 0)
			return (error);
		oip->i_ffs_size = length;
		size = blksize(fs, oip, lbn);
		(void) uvm_vnp_uncache(ovp);
		if (ovp->v_type != VDIR)
			bzero((char *)bp->b_data + offset,
			      (u_int)(size - offset));
		allocbuf(bp, size);
		if (aflags & B_SYNC)
			bwrite(bp);
		else
			bawrite(bp);
	}
	/*
d399 1
@


1.15.2.7
log
@Merge in -current from roughly a week ago
@
text
@d61 2
a62 2
static int ffs_indirtrunc(struct inode *, daddr_t, daddr_t, daddr_t, int,
			       long *);
@


1.15.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.15.2.7 2002/03/28 14:54:26 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.15.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 2
a114 2
		ip->i_din1.di_ouid = ip->i_ffs_uid;		/* XXX */
		ip->i_din1.di_ogid = ip->i_ffs_gid;		/* XXX */
d128 2
a129 2
	*((struct ufs1_dinode *)bp->b_data +
	    ino_to_fsbo(fs, ip->i_number)) = ip->i_din1;
d174 1
a174 1
	      oip->i_din1.di_blocks == 0))) {
@


1.14
log
@ffs_init is a vfsop. Move it to ffs_vfsops.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.13 1999/12/06 06:55:41 art Exp $	*/
d278 1
a278 1
	 * truncated to a block boundry, the contents of the
d280 3
a282 2
	 * zero'ed in case it ever become accessable again because
	 * of subsequent file growth.
d303 3
a305 1
		bzero((char *)bp->b_data + offset, (u_int)(size - offset));
@


1.13
log
@Don't compute values that we don't use later.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.12 1999/02/26 03:56:30 art Exp $	*/
a66 8

int
ffs_init(vfsp)
	struct vfsconf *vfsp;
{
	softdep_initialize();
	return (ufs_init(vfsp));
}
@


1.12
log
@compat with uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.11 1998/12/01 23:32:52 art Exp $	*/
a255 2
		offset = blkoff(fs, length - 1);
		lbn = lblkno(fs, length - 1);
@


1.11
log
@remove the itrunc3 panic
(if someone can convince me that the call to vinvalbuf won't keep the buffers
for the metadata, I will put it back)
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.10 1998/11/29 03:47:15 art Exp $	*/
d53 4
d215 3
d219 1
d266 4
d272 1
d280 3
d284 1
d307 3
d311 1
@


1.10
log
@remove unreached code
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.9 1997/11/06 05:59:18 csapuntz Exp $	*/
a414 3
	if (length == 0 &&
	    (ovp->v_dirtyblkhd.lh_first || ovp->v_cleanblkhd.lh_first))
		panic("itrunc3");
@


1.9
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.8 1997/10/06 20:21:36 deraadt Exp $	*/
a205 4
	}
	if (oip->i_ffs_size == length) {
		oip->i_flag |= IN_CHANGE | IN_UPDATE;
		return (VOP_UPDATE(ovp, &ts, &ts, 0));
@


1.8
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.6 1997/05/30 08:34:21 downsj Exp $	*/
d64 3
a66 2
void
ffs_init()
d68 2
a69 1
	ufs_init();
d106 2
a107 1
	    (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0)
d139 6
d147 1
a147 1
	if (ap->a_waitfor)
d149 1
a149 1
	else {
d191 2
d216 26
d243 1
a243 1
	osize = oip->i_ffs_size;
d257 2
a258 2
		error = ffs_balloc(oip, lbn, offset + 1, ap->a_cred, &bp,
				   aflags);
d262 1
d271 2
d288 2
a289 1
		error = ffs_balloc(oip, lbn, offset, ap->a_cred, &bp, aflags);
@


1.7
log
@VFS Lite2 Changes
@
text
@d64 2
a65 3
int
ffs_init(vfsp)
	struct vfsconf *vfsp;
d67 1
a67 2
	softdep_initialize();
	return (ufs_init(vfsp));
d104 1
a104 2
	    (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0 &&
	    ap->a_waitfor != MNT_WAIT)
a135 6

	if (DOINGSOFTDEP(ap->a_vp))
		softdep_update_inodeblock(ip, bp, ap->a_waitfor);
	else if (ip->i_effnlink != ip->i_ffs_nlink) 
		panic("ffs_update: bad link cnt");

d138 1
a138 1
	if (ap->a_waitfor && (ap->a_vp->v_mount->mnt_flag & MNT_ASYNC) == 0) {
d140 1
a140 1
	} else {
a181 2
	if (oip->i_ffs_size == length)
		return (0);
a204 26
	ovp->v_lasta = ovp->v_clen = ovp->v_cstart = ovp->v_lastw = 0;
	if (DOINGSOFTDEP(ovp)) {
		if (length > 0) {
			/*
			 * If a file is only partially truncated, then
			 * we have to clean up the data structures
			 * describing the allocation past the truncation
			 * point. Finding and deallocating those structures
			 * is a lot of work. Since partial truncation occurs
			 * rarely, we solve the problem by syncing the file
			 * so that it will have no data structures left.
			 */
			if ((error = VOP_FSYNC(ovp, ap->a_cred, MNT_WAIT,
					       ap->a_p)) != 0)
				return (error);
		} else {
#ifdef QUOTA
			(void) chkdq(oip, -oip->i_ffs_blocks, NOCRED, 0);
#endif
			softdep_setup_freeblocks(oip, length);
			(void) vinvalbuf(ovp, 0, ap->a_cred, ap->a_p, 0, 0);
			oip->i_flag |= IN_CHANGE | IN_UPDATE;
			return (VOP_UPDATE(ovp, &ts, &ts, 0));
		}
	}

d206 1
a206 1
	osize = oip->i_ffs_size; 
d220 2
a221 2
		error = VOP_BALLOC(ovp, length -1, 1, 
				   ap->a_cred, aflags, &bp);
a224 1
		vnode_pager_setsize(ovp, (u_long)length);
a232 2
	vnode_pager_setsize(ovp, (u_long)length);

d248 1
a248 2
		error = VOP_BALLOC(ovp, length - 1, 1,
				   ap->a_cred, aflags, &bp);
@


1.6
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.5 1997/03/02 09:38:13 millert Exp $	*/
d64 3
a66 2
void
ffs_init()
d68 2
a69 1
	ufs_init();
d106 2
a107 1
	    (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0)
d139 6
d147 1
a147 1
	if (ap->a_waitfor)
d149 1
a149 1
	else {
d191 2
d216 26
d243 1
a243 1
	osize = oip->i_ffs_size;
d257 2
a258 2
		error = ffs_balloc(oip, lbn, offset + 1, ap->a_cred, &bp,
				   aflags);
d262 1
d271 2
d288 2
a289 1
		error = ffs_balloc(oip, lbn, offset, ap->a_cred, &bp, aflags);
@


1.5
log
@Add noatime option to not update atime on files in a filesystem (unless
ctime or mtime has changed).  Useful for laptops and news servers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.4 1996/11/05 03:30:12 tholo Exp $	*/
d107 2
a108 2
		ip->i_atime = ap->a_access->tv_sec;
		ip->i_atimensec = ap->a_access->tv_nsec;
d111 2
a112 2
		ip->i_mtime = ap->a_modify->tv_sec;
		ip->i_mtimensec = ap->a_modify->tv_nsec;
d116 2
a117 2
		ip->i_ctime = time.tv_sec;
		ip->i_ctimensec = time.tv_usec * 1000;
d126 2
a127 2
		ip->i_din.di_ouid = ip->i_uid;		/* XXX */
		ip->i_din.di_ogid = ip->i_gid;		/* XXX */
d137 1
a137 1
	    ino_to_fsbo(fs, ip->i_number)) = ip->i_din;
d184 1
a184 1
	    (oip->i_size < ovp->v_mount->mnt_maxsymlinklen ||
d186 1
a186 1
	      oip->i_din.di_blocks == 0))) {
d191 2
a192 2
		bzero((char *)&oip->i_shortlink, (u_int)oip->i_size);
		oip->i_size = 0;
d196 1
a196 1
	if (oip->i_size == length) {
d206 1
a206 1
	osize = oip->i_size;
d224 1
a224 1
		oip->i_size = length;
d242 1
a242 1
		oip->i_size = length;
d251 1
a251 1
		oip->i_size = length;
d278 1
a278 1
	bcopy((caddr_t)&oip->i_db[0], (caddr_t)oldblks, sizeof oldblks);
d281 1
a281 1
			oip->i_ib[level] = 0;
d285 1
a285 1
		oip->i_db[i] = 0;
d295 3
a297 3
	bcopy((caddr_t)&oip->i_db[0], (caddr_t)newblks, sizeof newblks);
	bcopy((caddr_t)oldblks, (caddr_t)&oip->i_db[0], sizeof oldblks);
	oip->i_size = osize;
d308 1
a308 1
		bn = oip->i_ib[level];
d316 1
a316 1
				oip->i_ib[level] = 0;
d331 1
a331 1
		bn = oip->i_db[i];
d334 1
a334 1
		oip->i_db[i] = 0;
d346 1
a346 1
	bn = oip->i_db[lastblock];
d355 1
a355 1
		oip->i_size = length;
d373 1
a373 1
		if (newblks[NDADDR + level] != oip->i_ib[level])
d376 1
a376 1
		if (newblks[i] != oip->i_db[i])
d385 4
a388 4
	oip->i_size = length;
	oip->i_blocks -= blocksreleased;
	if (oip->i_blocks < 0)			/* sanity */
		oip->i_blocks = 0;
@


1.4
log
@Patch from Kirk McKusick:
  The following change eliminates an unnecessary synchronous write
  from the filesystem. When freeing an indirect block, there is no
  need to write it (synchronously, no less!) before tossing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_inode.c,v 1.3 1996/05/22 11:47:18 deraadt Exp $	*/
d99 3
@


1.3
log
@Change VOP_UPDATE() semantics:
* Make 2nd and 3rd args timespecs, not timevals.
* Consistently pass a Boolean as the 4th arg (except in LFS).
Also, fix ffs_update() and lfs_update() to actually change the nsec fields.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d462 14
a475 10
	MALLOC(copy, daddr_t *, fs->fs_bsize, M_TEMP, M_WAITOK);
	bcopy((caddr_t)bap, (caddr_t)copy, (u_int)fs->fs_bsize);
	bzero((caddr_t)&bap[last + 1],
	  (u_int)(NINDIR(fs) - (last + 1)) * sizeof (daddr_t));
	if (last == -1)
		bp->b_flags |= B_INVAL;
	error = bwrite(bp);
	if (error)
		allerror = error;
	bap = copy;
d511 7
a517 1
	FREE(copy, M_TEMP);
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d2 1
a2 1
/*	$NetBSD: ffs_inode.c,v 1.9 1996/02/09 22:22:23 christos Exp $	*/
d85 2
a86 2
		struct timeval *a_access;
		struct timeval *a_modify;
d103 1
a103 1
	if (ip->i_flag & IN_ACCESS)
d105 2
d109 1
d112 1
a112 1
	if (ip->i_flag & IN_CHANGE)
d114 2
d171 1
a171 1
	struct timeval tv;
d179 1
a179 1
	tv = time;
d191 1
a191 1
		return (VOP_UPDATE(ovp, &tv, &tv, 1));
d195 1
a195 1
		return (VOP_UPDATE(ovp, &tv, &tv, 0));
d228 1
a228 1
		return (VOP_UPDATE(ovp, &tv, &tv, 1));
d284 1
a284 1
	if ((error = VOP_UPDATE(ovp, &tv, &tv, MNT_WAIT)) != 0)
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ffs_inode.c,v 1.8 1995/06/15 23:22:41 cgd Exp $	*/
d62 1
a62 1
	    long *));
d64 1
a64 1
int
d67 1
a67 1
	return (ufs_init());
d80 3
a82 1
ffs_update(ap)
d88 1
a88 2
	} */ *ap;
{
d121 4
a124 3
	if (error = bread(ip->i_devvp,
	    fsbtodb(fs, ino_to_fsba(fs, ip->i_number)),
		(int)fs->fs_bsize, NOCRED, &bp)) {
d145 4
a148 1
ffs_truncate(ap)
d155 1
a155 2
	} */ *ap;
{
d193 1
a193 1
	if (error = getinoquota(oip))
d212 3
a214 2
		if (error = ffs_balloc(oip, lbn, offset + 1, ap->a_cred, &bp,
		    aflags))
d240 2
a241 2
		if (error = ffs_balloc(oip, lbn, offset, ap->a_cred, &bp,
		    aflags))
d279 1
a279 1
	if (error = VOP_UPDATE(ovp, &tv, &tv, MNT_WAIT))
d477 4
a480 2
			if (error = ffs_indirtrunc(ip, nlbn,
			    fsbtodb(fs, nb), (daddr_t)-1, level - 1, &blkcount))
d495 3
a497 2
			if (error = ffs_indirtrunc(ip, nlbn, fsbtodb(fs, nb),
			    last, level - 1, &blkcount))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
