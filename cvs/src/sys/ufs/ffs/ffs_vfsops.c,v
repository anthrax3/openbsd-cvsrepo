head	1.164;
access;
symbols
	OPENBSD_6_1_BASE:1.164
	OPENBSD_6_0:1.160.0.2
	OPENBSD_6_0_BASE:1.160
	OPENBSD_5_9:1.150.0.2
	OPENBSD_5_9_BASE:1.150
	OPENBSD_5_8:1.149.0.4
	OPENBSD_5_8_BASE:1.149
	OPENBSD_5_7:1.148.0.2
	OPENBSD_5_7_BASE:1.148
	OPENBSD_5_6:1.143.0.4
	OPENBSD_5_6_BASE:1.143
	OPENBSD_5_5:1.140.0.4
	OPENBSD_5_5_BASE:1.140
	OPENBSD_5_4:1.138.0.2
	OPENBSD_5_4_BASE:1.138
	OPENBSD_5_3:1.135.0.2
	OPENBSD_5_3_BASE:1.135
	OPENBSD_5_2:1.134.0.2
	OPENBSD_5_2_BASE:1.134
	OPENBSD_5_1_BASE:1.133
	OPENBSD_5_1:1.133.0.4
	OPENBSD_5_0:1.133.0.2
	OPENBSD_5_0_BASE:1.133
	OPENBSD_4_9:1.128.0.2
	OPENBSD_4_9_BASE:1.128
	OPENBSD_4_8:1.125.0.2
	OPENBSD_4_8_BASE:1.125
	OPENBSD_4_7:1.121.0.2
	OPENBSD_4_7_BASE:1.121
	OPENBSD_4_6:1.119.0.6
	OPENBSD_4_6_BASE:1.119
	OPENBSD_4_5:1.119.0.2
	OPENBSD_4_5_BASE:1.119
	OPENBSD_4_4:1.114.0.2
	OPENBSD_4_4_BASE:1.114
	OPENBSD_4_3:1.112.0.2
	OPENBSD_4_3_BASE:1.112
	OPENBSD_4_2:1.109.0.2
	OPENBSD_4_2_BASE:1.109
	OPENBSD_4_1:1.98.0.2
	OPENBSD_4_1_BASE:1.98
	OPENBSD_4_0:1.96.0.2
	OPENBSD_4_0_BASE:1.96
	OPENBSD_3_9:1.80.0.2
	OPENBSD_3_9_BASE:1.80
	OPENBSD_3_8:1.70.0.2
	OPENBSD_3_8_BASE:1.70
	OPENBSD_3_7:1.68.0.4
	OPENBSD_3_7_BASE:1.68
	OPENBSD_3_6:1.68.0.2
	OPENBSD_3_6_BASE:1.68
	SMP_SYNC_A:1.65
	SMP_SYNC_B:1.65
	OPENBSD_3_5:1.64.0.2
	OPENBSD_3_5_BASE:1.64
	OPENBSD_3_4:1.59.0.2
	OPENBSD_3_4_BASE:1.59
	UBC_SYNC_A:1.54
	OPENBSD_3_3:1.54.0.4
	OPENBSD_3_3_BASE:1.54
	OPENBSD_3_2:1.54.0.2
	OPENBSD_3_2_BASE:1.54
	OPENBSD_3_1:1.52.0.2
	OPENBSD_3_1_BASE:1.52
	UBC_SYNC_B:1.54
	UBC:1.47.0.2
	UBC_BASE:1.47
	OPENBSD_3_0:1.43.0.2
	OPENBSD_3_0_BASE:1.43
	OPENBSD_2_9_BASE:1.41
	OPENBSD_2_9:1.41.0.2
	OPENBSD_2_8:1.28.0.6
	OPENBSD_2_8_BASE:1.28
	OPENBSD_2_7:1.28.0.4
	OPENBSD_2_7_BASE:1.28
	SMP:1.28.0.2
	SMP_BASE:1.28
	kame_19991208:1.26
	OPENBSD_2_6:1.23.0.2
	OPENBSD_2_6_BASE:1.23
	OPENBSD_2_5:1.22.0.2
	OPENBSD_2_5_BASE:1.22
	OPENBSD_2_4:1.17.0.4
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.164
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.163;
commitid	RlO92XR575sygHqm;

1.163
date	2016.09.07.17.30.13;	author natano;	state Exp;
branches;
next	1.162;
commitid	D0avTYSlvEmEjLyB;

1.162
date	2016.08.13.21.28.09;	author guenther;	state Exp;
branches;
next	1.161;
commitid	4rRWJtWC5CyaufQd;

1.161
date	2016.08.10.08.04.57;	author natano;	state Exp;
branches;
next	1.160;
commitid	a3QYlN9gTOdBi75t;

1.160
date	2016.06.19.11.54.34;	author natano;	state Exp;
branches;
next	1.159;
commitid	wHLNY5GFNXJSFYaC;

1.159
date	2016.06.19.10.21.56;	author dlg;	state Exp;
branches;
next	1.158;
commitid	J5HRbCm5olgUBGNw;

1.158
date	2016.05.23.09.31.28;	author natano;	state Exp;
branches;
next	1.157;
commitid	wckQrShbScIX7TCE;

1.157
date	2016.05.22.20.27.04;	author bluhm;	state Exp;
branches;
next	1.156;
commitid	IMex9jbP378m0AFa;

1.156
date	2016.05.10.10.37.57;	author krw;	state Exp;
branches;
next	1.155;
commitid	TBd2AAdq73GMtNzl;

1.155
date	2016.03.27.11.39.37;	author bluhm;	state Exp;
branches;
next	1.154;
commitid	C0IKsjKoZxFScK3M;

1.154
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.153;
commitid	gAjwyca5TfuoJAhn;

1.153
date	2016.03.17.18.52.32;	author bluhm;	state Exp;
branches;
next	1.152;
commitid	XOU3hWgTktDOU9BT;

1.152
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.151;
commitid	gFybgYMymUyTbVeS;

1.151
date	2016.02.26.08.56.10;	author natano;	state Exp;
branches;
next	1.150;
commitid	1wcjndbWCkf5R7p2;

1.150
date	2016.01.12.11.41.00;	author mpi;	state Exp;
branches;
next	1.149;
commitid	PdHHohncj6RrnJZN;

1.149
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.148;
commitid	p4LJxGKbi0BU2cG6;

1.148
date	2014.12.29.05.29.28;	author miod;	state Exp;
branches;
next	1.147;
commitid	UbmX4MifiudCV4qQ;

1.147
date	2014.12.23.01.53.34;	author tedu;	state Exp;
branches;
next	1.146;
commitid	6nkNTy1tuOQfzz0f;

1.146
date	2014.12.12.22.58.48;	author tedu;	state Exp;
branches;
next	1.145;
commitid	S6FZd75V6lfF8pbZ;

1.145
date	2014.12.12.19.02.07;	author tedu;	state Exp;
branches;
next	1.144;
commitid	P5As3naUI8YDCuRx;

1.144
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.143;
commitid	Z1vcFtHO8wRH0yRt;

1.143
date	2014.07.14.08.11.34;	author beck;	state Exp;
branches;
next	1.142;
commitid	7DbQuyiuCuM93wWy;

1.142
date	2014.07.13.23.33.26;	author tedu;	state Exp;
branches;
next	1.141;
commitid	zHb3aykioHZHOHpW;

1.141
date	2014.07.12.18.44.01;	author tedu;	state Exp;
branches;
next	1.140;
commitid	bDGgAR6yEQVcVl5u;

1.140
date	2013.12.12.19.00.10;	author tedu;	state Exp;
branches;
next	1.139;

1.139
date	2013.12.01.16.40.56;	author krw;	state Exp;
branches;
next	1.138;

1.138
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.137;

1.137
date	2013.05.30.19.19.09;	author guenther;	state Exp;
branches;
next	1.136;

1.136
date	2013.04.15.15.32.19;	author jsing;	state Exp;
branches;
next	1.135;

1.135
date	2012.09.10.11.11.00;	author jsing;	state Exp;
branches;
next	1.134;

1.134
date	2012.06.10.21.29.04;	author krw;	state Exp;
branches;
next	1.133;

1.133
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.131;

1.131
date	2011.07.03.18.23.10;	author tedu;	state Exp;
branches;
next	1.130;

1.130
date	2011.07.02.16.23.47;	author krw;	state Exp;
branches;
next	1.129;

1.129
date	2011.07.02.15.52.25;	author thib;	state Exp;
branches;
next	1.128;

1.128
date	2010.12.21.20.14.44;	author thib;	state Exp;
branches;
next	1.127;

1.127
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.126;

1.126
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.125;

1.125
date	2010.07.23.17.31.54;	author ray;	state Exp;
branches;
next	1.124;

1.124
date	2010.06.29.14.48.08;	author thib;	state Exp;
branches;
next	1.123;

1.123
date	2010.06.09.12.58.57;	author jsing;	state Exp;
branches;
next	1.122;

1.122
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.121;

1.121
date	2009.12.19.00.27.17;	author krw;	state Exp;
branches;
next	1.120;

1.120
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.119;

1.119
date	2008.11.06.18.13.31;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2008.11.02.08.53.06;	author otto;	state Exp;
branches;
next	1.117;

1.117
date	2008.09.12.12.27.27;	author blambert;	state Exp;
branches;
next	1.116;

1.116
date	2008.08.08.23.49.53;	author krw;	state Exp;
branches;
next	1.115;

1.115
date	2008.08.08.09.02.25;	author thib;	state Exp;
branches;
next	1.114;

1.114
date	2008.07.09.09.30.51;	author thib;	state Exp;
branches;
next	1.113;

1.113
date	2008.03.16.19.42.57;	author otto;	state Exp;
branches;
next	1.112;

1.112
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.111;

1.111
date	2007.09.10.20.57.04;	author thib;	state Exp;
branches;
next	1.110;

1.110
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.109;

1.109
date	2007.08.04.03.33.31;	author art;	state Exp;
branches;
next	1.108;

1.108
date	2007.06.06.09.53.16;	author pedro;	state Exp;
branches;
next	1.107;

1.107
date	2007.06.01.06.38.54;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2007.05.29.19.02.33;	author otto;	state Exp;
branches;
next	1.105;

1.105
date	2007.05.29.18.40.53;	author pedro;	state Exp;
branches;
next	1.104;

1.104
date	2007.04.24.12.10.28;	author millert;	state Exp;
branches;
next	1.103;

1.103
date	2007.04.11.15.17.46;	author thib;	state Exp;
branches;
next	1.102;

1.102
date	2007.03.31.15.30.07;	author pedro;	state Exp;
branches;
next	1.101;

1.101
date	2007.03.21.17.29.32;	author thib;	state Exp;
branches;
next	1.100;

1.100
date	2007.03.19.19.57.58;	author pedro;	state Exp;
branches;
next	1.99;

1.99
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.98;

1.98
date	2006.12.28.20.33.24;	author thib;	state Exp;
branches;
next	1.97;

1.97
date	2006.10.20.13.01.10;	author pedro;	state Exp;
branches;
next	1.96;

1.96
date	2006.08.07.15.50.42;	author pedro;	state Exp;
branches;
next	1.95;

1.95
date	2006.08.06.18.42.01;	author thib;	state Exp;
branches;
next	1.94;

1.94
date	2006.06.17.16.30.58;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2006.05.20.16.03.46;	author pedro;	state Exp;
branches;
next	1.92;

1.92
date	2006.04.19.11.55.55;	author pedro;	state Exp;
branches;
next	1.91;

1.91
date	2006.04.12.03.46.52;	author tedu;	state Exp;
branches;
next	1.90;

1.90
date	2006.04.07.11.11.38;	author pedro;	state Exp;
branches;
next	1.89;

1.89
date	2006.04.01.11.24.47;	author pedro;	state Exp;
branches;
next	1.88;

1.88
date	2006.03.31.16.24.58;	author pedro;	state Exp;
branches;
next	1.87;

1.87
date	2006.03.31.13.16.58;	author pedro;	state Exp;
branches;
next	1.86;

1.86
date	2006.03.31.12.55.04;	author pedro;	state Exp;
branches;
next	1.85;

1.85
date	2006.03.31.12.45.01;	author pedro;	state Exp;
branches;
next	1.84;

1.84
date	2006.03.31.12.19.42;	author pedro;	state Exp;
branches;
next	1.83;

1.83
date	2006.03.31.08.13.07;	author pedro;	state Exp;
branches;
next	1.82;

1.82
date	2006.03.09.13.25.02;	author pedro;	state Exp;
branches;
next	1.81;

1.81
date	2006.03.09.13.21.12;	author pedro;	state Exp;
branches;
next	1.80;

1.80
date	2006.02.14.12.42.11;	author mickey;	state Exp;
branches;
next	1.79;

1.79
date	2006.01.03.12.20.54;	author pedro;	state Exp;
branches;
next	1.78;

1.78
date	2005.12.28.20.48.17;	author pedro;	state Exp;
branches;
next	1.77;

1.77
date	2005.12.17.13.56.01;	author pedro;	state Exp;
branches;
next	1.76;

1.76
date	2005.11.30.17.01.17;	author pedro;	state Exp;
branches;
next	1.75;

1.75
date	2005.11.30.10.35.08;	author pedro;	state Exp;
branches;
next	1.74;

1.74
date	2005.11.08.02.29.51;	author pedro;	state Exp;
branches;
next	1.73;

1.73
date	2005.11.06.00.24.17;	author pedro;	state Exp;
branches;
next	1.72;

1.72
date	2005.11.05.23.24.43;	author pedro;	state Exp;
branches;
next	1.71;

1.71
date	2005.09.29.22.31.30;	author pedro;	state Exp;
branches;
next	1.70;

1.70
date	2005.07.03.20.14.02;	author drahn;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.22.21.12.42;	author pedro;	state Exp;
branches;
next	1.68;

1.68
date	2004.08.12.07.48.53;	author otto;	state Exp;
branches;
next	1.67;

1.67
date	2004.07.14.18.48.43;	author pedro;	state Exp;
branches;
next	1.66;

1.66
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.65;

1.65
date	2004.06.04.08.06.05;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2004.01.25.20.02.52;	author tedu;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.20.03.44.06;	author tedu;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.07.20.47.47;	author tedu;	state Exp;
branches;
next	1.61;

1.61
date	2003.10.17.15.08.11;	author mpech;	state Exp;
branches;
next	1.60;

1.60
date	2003.10.04.18.47.08;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2003.08.25.23.26.55;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2003.08.14.07.46.40;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2003.07.10.22.32.20;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.10.17.51.02;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2002.08.01.16.41.33;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.52;

1.52
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2002.02.22.20.37.46;	author drahn;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.25.02.30.27;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2002.01.23.00.39.48;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.10.04.45.32;	author art;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2001.11.21.22.21.48;	author csapuntz;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.21.21.23.56;	author csapuntz;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.23.02.07.55;	author csapuntz;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.15.23.44.41;	author ho;	state Exp;
branches;
next	1.41;

1.41
date	2001.04.22.21.33.46;	author gluk;	state Exp;
branches;
next	1.40;

1.40
date	2001.04.19.16.22.17;	author gluk;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.15.23.46.29;	author gluk;	state Exp;
branches;
next	1.38;

1.38
date	2001.04.13.02.39.05;	author gluk;	state Exp;
branches;
next	1.37;

1.37
date	2001.04.12.17.16.52;	author csapuntz;	state Exp;
branches;
next	1.36;

1.36
date	2001.04.06.20.43.31;	author gluk;	state Exp;
branches;
next	1.35;

1.35
date	2001.04.04.20.19.04;	author gluk;	state Exp;
branches;
next	1.34;

1.34
date	2001.03.22.00.20.54;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.22.00.11.36;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.14.18.46.18;	author gluk;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.13.18.17.25;	author gluk;	state Exp;
branches;
next	1.30;

1.30
date	2001.02.21.23.24.31;	author csapuntz;	state Exp;
branches;
next	1.29;

1.29
date	2001.02.20.01.50.12;	author assar;	state Exp;
branches;
next	1.28;

1.28
date	2000.02.07.04.57.18;	author assar;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2000.01.14.19.17.56;	author art;	state Exp;
branches;
next	1.26;

1.26
date	99.12.06.07.03.04;	author art;	state Exp;
branches;
next	1.25;

1.25
date	99.12.06.06.59.36;	author art;	state Exp;
branches;
next	1.24;

1.24
date	99.12.03.21.29.29;	author art;	state Exp;
branches;
next	1.23;

1.23
date	99.05.31.17.34.54;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	98.12.05.18.57.07;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	98.12.05.17.01.09;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	98.11.27.22.52.42;	author art;	state Exp;
branches;
next	1.19;

1.19
date	98.11.20.02.42.19;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	98.11.12.04.30.03;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	98.02.08.22.41.50;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	98.01.17.18.20.54;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	98.01.09.20.39.54;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	97.12.09.04.54.42;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.11.11.15.28.44;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	97.11.06.05.59.20;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.10.06.20.21.37;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.10.06.15.26.31;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.06.20.14.04.32;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	97.05.30.08.34.25;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	97.02.11.06.59.28;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	96.06.27.06.42.06;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.06.24.03.35.01;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.02.27.07.27.39;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	95.12.21.14.59.51;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.06.21.19.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches;
next	;

1.28.2.1
date	2001.05.14.22.47.41;	author niklas;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2001.07.04.11.00.51;	author niklas;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.28.2.4;

1.28.2.4
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.28.2.5;

1.28.2.5
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.28.2.6;

1.28.2.6
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.28.2.7;

1.28.2.7
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.28.2.8;

1.28.2.8
date	2004.02.19.11.01.41;	author niklas;	state Exp;
branches;
next	1.28.2.9;

1.28.2.9
date	2004.06.05.23.13.11;	author niklas;	state Exp;
branches;
next	;

1.47.2.1
date	2002.01.31.22.55.50;	author niklas;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.47.2.3;

1.47.2.3
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.47.2.4;

1.47.2.4
date	2002.10.29.00.36.50;	author art;	state Exp;
branches;
next	1.47.2.5;

1.47.2.5
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	1.47.2.6;

1.47.2.6
date	2003.05.20.04.18.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.164
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@/*	$OpenBSD: ffs_vfsops.c,v 1.163 2016/09/07 17:30:13 natano Exp $	*/
/*	$NetBSD: ffs_vfsops.c,v 1.19 1996/02/09 22:22:26 christos Exp $	*/

/*
 * Copyright (c) 1989, 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ffs_vfsops.c	8.14 (Berkeley) 11/28/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/vnode.h>
#include <sys/socket.h>
#include <sys/mount.h>
#include <sys/buf.h>
#include <sys/mbuf.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/sysctl.h>
#include <sys/pool.h>
#include <sys/dkio.h>
#include <sys/disk.h>
#include <sys/specdev.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/dir.h>
#include <ufs/ufs/ufs_extern.h>
#include <ufs/ufs/dirhash.h>

#include <ufs/ffs/fs.h>
#include <ufs/ffs/ffs_extern.h>

#include <uvm/uvm_extern.h>

int ffs_sbupdate(struct ufsmount *, int);
int ffs_reload_vnode(struct vnode *, void *);
int ffs_sync_vnode(struct vnode *, void *);
int ffs_validate(struct fs *);

void ffs1_compat_read(struct fs *, struct ufsmount *, daddr_t);
void ffs1_compat_write(struct fs *, struct ufsmount *);

const struct vfsops ffs_vfsops = {
	ffs_mount,
	ufs_start,
	ffs_unmount,
	ufs_root,
	ufs_quotactl,
	ffs_statfs,
	ffs_sync,
	ffs_vget,
	ffs_fhtovp,
	ffs_vptofh,
	ffs_init,
	ffs_sysctl,
	ufs_check_export
};

struct inode_vtbl ffs_vtbl = {
	ffs_truncate,
	ffs_update,
	ffs_inode_alloc,
	ffs_inode_free,
	ffs_balloc,
	ffs_bufatoff
};

int
ffs_checkrange(struct mount *mp, uint32_t ino)
{
	struct buf *bp;
	struct cg *cgp;
	struct fs *fs;
	struct ufsmount *ump;
	int cg, error;

	fs = VFSTOUFS(mp)->um_fs;
	if (ino < ROOTINO || ino >= fs->fs_ncg * fs->fs_ipg)
		return ESTALE;

	/*
	 * Need to check if inode is initialized because ffsv2 does
	 * lazy initialization and we can get here from nfs_fhtovp
	 */
	if (fs->fs_magic != FS_UFS2_MAGIC)
		return 0;

	cg = ino_to_cg(fs, ino);
	ump = VFSTOUFS(mp);

	error = bread(ump->um_devvp, fsbtodb(fs, cgtod(fs, cg)),
	    (int)fs->fs_cgsize, &bp);
	if (error)
		return error;

	cgp = (struct cg *)bp->b_data;
	if (!cg_chkmagic(cgp)) {
		brelse(bp);
		return ESTALE;
	}

	brelse(bp);

	if (cg * fs->fs_ipg + cgp->cg_initediblk < ino)
		return ESTALE;

	return 0;
}

/*
 * Called by main() when ufs is going to be mounted as root.
 */

struct pool ffs_ino_pool;
struct pool ffs_dinode1_pool;
#ifdef FFS2
struct pool ffs_dinode2_pool;
#endif

int
ffs_mountroot(void)
{
	struct fs *fs;
	struct mount *mp;
	struct proc *p = curproc;	/* XXX */
	struct ufsmount *ump;
	int error;

	/*
	 * Get vnodes for swapdev and rootdev.
	 */
	swapdev_vp = NULL;
	if ((error = bdevvp(swapdev, &swapdev_vp)) ||
	    (error = bdevvp(rootdev, &rootvp))) {
		printf("ffs_mountroot: can't setup bdevvp's\n");
		if (swapdev_vp)
			vrele(swapdev_vp);
		return (error);
	}

	if ((error = vfs_rootmountalloc("ffs", "root_device", &mp)) != 0) {
		vrele(swapdev_vp);
		vrele(rootvp);
		return (error);
	}

	if ((error = ffs_mountfs(rootvp, mp, p)) != 0) {
		mp->mnt_vfc->vfc_refcount--;
		vfs_unbusy(mp);
		free(mp, M_MOUNT, sizeof(*mp));
		vrele(swapdev_vp);
		vrele(rootvp);
		return (error);
	}

	TAILQ_INSERT_TAIL(&mountlist, mp, mnt_list);
	ump = VFSTOUFS(mp);
	fs = ump->um_fs;
	strlcpy(fs->fs_fsmnt, mp->mnt_stat.f_mntonname, sizeof(fs->fs_fsmnt));
	(void)ffs_statfs(mp, &mp->mnt_stat, p);
	vfs_unbusy(mp);
	inittodr(fs->fs_time);

	return (0);
}

/*
 * VFS Operations.
 *
 * mount system call
 */
int
ffs_mount(struct mount *mp, const char *path, void *data,
    struct nameidata *ndp, struct proc *p)
{
	struct vnode *devvp;
	struct ufs_args args;
	struct ufsmount *ump = NULL;
	struct fs *fs;
	char fname[MNAMELEN];
	char fspec[MNAMELEN];
	int error = 0, flags;
	int ronly;

	error = copyin(data, &args, sizeof(struct ufs_args));
	if (error)
		return (error);

#ifndef FFS_SOFTUPDATES
	if (mp->mnt_flag & MNT_SOFTDEP) {
		printf("WARNING: soft updates isn't compiled in\n");
		mp->mnt_flag &= ~MNT_SOFTDEP;
	}
#endif

	/*
	 * Soft updates is incompatible with "async",
	 * so if we are doing softupdates stop the user
	 * from setting the async flag.
	 */
	if ((mp->mnt_flag & (MNT_SOFTDEP | MNT_ASYNC)) ==
	    (MNT_SOFTDEP | MNT_ASYNC)) {
		return (EINVAL);
	}
	/*
	 * If updating, check whether changing from read-only to
	 * read/write; if there is no device name, that's all we do.
	 */
	if (mp->mnt_flag & MNT_UPDATE) {
		ump = VFSTOUFS(mp);
		fs = ump->um_fs;
		devvp = ump->um_devvp;
		error = 0;
		ronly = fs->fs_ronly;

		if (ronly == 0 && (mp->mnt_flag & MNT_RDONLY)) {
			/* Flush any dirty data */
			mp->mnt_flag &= ~MNT_RDONLY;
			VFS_SYNC(mp, MNT_WAIT, p->p_ucred, p);
			mp->mnt_flag |= MNT_RDONLY;

			/*
			 * Get rid of files open for writing.
			 */
			flags = WRITECLOSE;
			if (mp->mnt_flag & MNT_FORCE)
				flags |= FORCECLOSE;
			if (fs->fs_flags & FS_DOSOFTDEP) {
				error = softdep_flushfiles(mp, flags, p);
				mp->mnt_flag &= ~MNT_SOFTDEP;
			} else
				error = ffs_flushfiles(mp, flags, p);
			ronly = 1;
		}

		/*
		 * Flush soft dependencies if disabling it via an update
		 * mount. This may leave some items to be processed,
		 * so don't do this yet XXX.
		 */
		if ((fs->fs_flags & FS_DOSOFTDEP) &&
		    !(mp->mnt_flag & MNT_SOFTDEP) &&
		    !(mp->mnt_flag & MNT_RDONLY) && fs->fs_ronly == 0) {
#if 0
			flags = WRITECLOSE;
			if (mp->mnt_flag & MNT_FORCE)
				flags |= FORCECLOSE;
			error = softdep_flushfiles(mp, flags, p);
#elif FFS_SOFTUPDATES
			mp->mnt_flag |= MNT_SOFTDEP;
#endif
		}
		/*
		 * When upgrading to a softdep mount, we must first flush
		 * all vnodes. (not done yet -- see above)
		 */
		if (!(fs->fs_flags & FS_DOSOFTDEP) &&
		    (mp->mnt_flag & MNT_SOFTDEP) && fs->fs_ronly == 0) {
#if 0
			flags = WRITECLOSE;
			if (mp->mnt_flag & MNT_FORCE)
				flags |= FORCECLOSE;
			error = ffs_flushfiles(mp, flags, p);
#else
			mp->mnt_flag &= ~MNT_SOFTDEP;
#endif
		}

		if (!error && (mp->mnt_flag & MNT_RELOAD))
			error = ffs_reload(mp, ndp->ni_cnd.cn_cred, p);
		if (error)
			goto error_1;

		if (ronly && (mp->mnt_flag & MNT_WANTRDWR)) {
			if (fs->fs_clean == 0) {
#if 0
				/*
				 * It is safe to mount an unclean file system
				 * if it was previously mounted with softdep
				 * but we may lose space and must
				 * sometimes run fsck manually.
				 */
				if (fs->fs_flags & FS_DOSOFTDEP)
					printf(
"WARNING: %s was not properly unmounted\n",
					    fs->fs_fsmnt);
				else
#endif
				if (mp->mnt_flag & MNT_FORCE) {
					printf(
"WARNING: %s was not properly unmounted\n",
					    fs->fs_fsmnt);
				} else {
					printf(
"WARNING: R/W mount of %s denied.  Filesystem is not clean - run fsck\n",
					    fs->fs_fsmnt);
					error = EROFS;
					goto error_1;
				}
			}

			if ((fs->fs_flags & FS_DOSOFTDEP)) {
				error = softdep_mount(devvp, mp, fs,
						      p->p_ucred);
				if (error)
					goto error_1;
			}
			fs->fs_contigdirs = malloc((u_long)fs->fs_ncg,
			     M_UFSMNT, M_WAITOK|M_ZERO);

			ronly = 0;
		}
		if (args.fspec == NULL) {
			/*
			 * Process export requests.
			 */
			error = vfs_export(mp, &ump->um_export, 
			    &args.export_info);
			if (error)
				goto error_1;
			else
				goto success;
		}
	}

	/*
	 * Not an update, or updating the name: look up the name
	 * and verify that it refers to a sensible block device.
	 */
	error = copyinstr(args.fspec, fspec, sizeof(fspec), NULL);
	if (error)
		goto error_1;

	if (disk_map(fspec, fname, MNAMELEN, DM_OPENBLCK) == -1)
		memcpy(fname, fspec, sizeof(fname));

	NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE, fname, p);
	if ((error = namei(ndp)) != 0)
		goto error_1;

	devvp = ndp->ni_vp;

	if (devvp->v_type != VBLK) {
		error = ENOTBLK;
		goto error_2;
	}

	if (major(devvp->v_rdev) >= nblkdev) {
		error = ENXIO;
		goto error_2;
	}

	if (mp->mnt_flag & MNT_UPDATE) {
		/*
		 * UPDATE
		 * If it's not the same vnode, or at least the same device
		 * then it's not correct.
		 */

		if (devvp != ump->um_devvp) {
			if (devvp->v_rdev == ump->um_devvp->v_rdev) {
				vrele(devvp);
			} else {
				error = EINVAL;	/* needs translation */
			}
		} else
			vrele(devvp);
		/*
		 * Update device name only on success
		 */
		if (!error) {
			/*
			 * Save "mounted from" info for mount point (NULL pad)
			 */
			memset(mp->mnt_stat.f_mntfromname, 0, MNAMELEN);
			strlcpy(mp->mnt_stat.f_mntfromname, fname, MNAMELEN);
			memset(mp->mnt_stat.f_mntfromspec, 0, MNAMELEN);
			strlcpy(mp->mnt_stat.f_mntfromspec, fspec, MNAMELEN);
		}
	} else {
		/*
		 * Since this is a new mount, we want the names for
		 * the device and the mount point copied in.  If an
		 * error occurs,  the mountpoint is discarded by the
		 * upper level code.
		 */
		memset(mp->mnt_stat.f_mntonname, 0, MNAMELEN);
		strlcpy(mp->mnt_stat.f_mntonname, path, MNAMELEN);
		memset(mp->mnt_stat.f_mntfromname, 0, MNAMELEN);
		strlcpy(mp->mnt_stat.f_mntfromname, fname, MNAMELEN);
		memset(mp->mnt_stat.f_mntfromspec, 0, MNAMELEN);
		strlcpy(mp->mnt_stat.f_mntfromspec, fspec, MNAMELEN);

		error = ffs_mountfs(devvp, mp, p);
	}

	if (error)
		goto error_2;

	/*
	 * Initialize FS stat information in mount struct; uses both
	 * mp->mnt_stat.f_mntonname and mp->mnt_stat.f_mntfromname
	 *
	 * This code is common to root and non-root mounts
	 */
	memcpy(&mp->mnt_stat.mount_info.ufs_args, &args, sizeof(args));
	VFS_STATFS(mp, &mp->mnt_stat, p);

success:
	if (path && (mp->mnt_flag & MNT_UPDATE)) {
		/* Update clean flag after changing read-onlyness. */
		fs = ump->um_fs;
		if (ronly != fs->fs_ronly) {
			fs->fs_ronly = ronly;
			fs->fs_clean = ronly &&
			    (fs->fs_flags & FS_UNCLEAN) == 0 ? 1 : 0;
			if (ronly)
				free(fs->fs_contigdirs, M_UFSMNT, 0);
		}
		if (!ronly) {
			if (mp->mnt_flag & MNT_SOFTDEP)
				fs->fs_flags |= FS_DOSOFTDEP;
			else
				fs->fs_flags &= ~FS_DOSOFTDEP;
		}
		ffs_sbupdate(ump, MNT_WAIT);
	}
	return (0);

error_2:	/* error with devvp held */
	vrele (devvp);

error_1:	/* no state to back out */
	return (error);
}

struct ffs_reload_args {
	struct fs *fs;
	struct proc *p;
	struct ucred *cred;
	struct vnode *devvp;
};

int
ffs_reload_vnode(struct vnode *vp, void *args) 
{
	struct ffs_reload_args *fra = args;
	struct inode *ip;
	struct buf *bp;
	int error;

	/*
	 * Step 4: invalidate all inactive vnodes.
	 */
	if (vp->v_usecount == 0) {
		vgonel(vp, fra->p);
		return (0);
	}

	/*
	 * Step 5: invalidate all cached file data.
	 */
	if (vget(vp, LK_EXCLUSIVE, fra->p))
		return (0);

	if (vinvalbuf(vp, 0, fra->cred, fra->p, 0, 0))
		panic("ffs_reload: dirty2");

	/*
	 * Step 6: re-read inode data for all active vnodes.
	 */
	ip = VTOI(vp);

	error = bread(fra->devvp, 
	    fsbtodb(fra->fs, ino_to_fsba(fra->fs, ip->i_number)),
	    (int)fra->fs->fs_bsize, &bp);
	if (error) {
		brelse(bp);
		vput(vp);
		return (error);
	}

	*ip->i_din1 = *((struct ufs1_dinode *)bp->b_data +
	    ino_to_fsbo(fra->fs, ip->i_number));
	ip->i_effnlink = DIP(ip, nlink);
	brelse(bp);
	vput(vp);
	return (0);
}

/*
 * Reload all incore data for a filesystem (used after running fsck on
 * the root filesystem and finding things to fix). The filesystem must
 * be mounted read-only.
 *
 * Things to do to update the mount:
 *	1) invalidate all cached meta-data.
 *	2) re-read superblock from disk.
 *	3) re-read summary information from disk.
 *	4) invalidate all inactive vnodes.
 *	5) invalidate all cached file data.
 *	6) re-read inode data for all active vnodes.
 */
int
ffs_reload(struct mount *mountp, struct ucred *cred, struct proc *p)
{
	struct vnode *devvp;
	caddr_t space;
	struct fs *fs, *newfs;
	int i, blks, size, error;
	int32_t *lp;
	struct buf *bp = NULL;
	struct ffs_reload_args fra;

	if ((mountp->mnt_flag & MNT_RDONLY) == 0)
		return (EINVAL);
	/*
	 * Step 1: invalidate all cached meta-data.
	 */
	devvp = VFSTOUFS(mountp)->um_devvp;
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = vinvalbuf(devvp, 0, cred, p, 0, 0);
	VOP_UNLOCK(devvp, p);
	if (error)
		panic("ffs_reload: dirty1");

	/*
	 * Step 2: re-read superblock from disk.
	 */
	fs = VFSTOUFS(mountp)->um_fs;

	error = bread(devvp, fs->fs_sblockloc / DEV_BSIZE, SBSIZE, &bp);
	if (error) {
		brelse(bp);
		return (error);
	}

	newfs = (struct fs *)bp->b_data;
	if (ffs_validate(newfs) == 0) {
		brelse(bp);
		return (EINVAL);
	}

	/*
	 * Copy pointer fields back into superblock before copying in	XXX
	 * new superblock. These should really be in the ufsmount.	XXX
	 * Note that important parameters (eg fs_ncg) are unchanged.
	 */
	newfs->fs_csp = fs->fs_csp;
	newfs->fs_maxcluster = fs->fs_maxcluster;
	newfs->fs_ronly = fs->fs_ronly;
	memcpy(fs, newfs, fs->fs_sbsize);
	if (fs->fs_sbsize < SBSIZE)
		bp->b_flags |= B_INVAL;
	brelse(bp);
	VFSTOUFS(mountp)->um_maxsymlinklen = fs->fs_maxsymlinklen;
	ffs1_compat_read(fs, VFSTOUFS(mountp), fs->fs_sblockloc);
	ffs_oldfscompat(fs);
	(void)ffs_statfs(mountp, &mountp->mnt_stat, p);
	/*
	 * Step 3: re-read summary information from disk.
	 */
	blks = howmany(fs->fs_cssize, fs->fs_fsize);
	space = (caddr_t)fs->fs_csp;
	for (i = 0; i < blks; i += fs->fs_frag) {
		size = fs->fs_bsize;
		if (i + fs->fs_frag > blks)
			size = (blks - i) * fs->fs_fsize;
		error = bread(devvp, fsbtodb(fs, fs->fs_csaddr + i), size, &bp);
		if (error) {
			brelse(bp);
			return (error);
		}
		memcpy(space, bp->b_data, size);
		space += size;
		brelse(bp);
	}
	if ((fs->fs_flags & FS_DOSOFTDEP))
		(void) softdep_mount(devvp, mountp, fs, cred);
	/*
	 * We no longer know anything about clusters per cylinder group.
	 */
	if (fs->fs_contigsumsize > 0) {
		lp = fs->fs_maxcluster;
		for (i = 0; i < fs->fs_ncg; i++)
			*lp++ = fs->fs_contigsumsize;
	}

	fra.p = p;
	fra.cred = cred;
	fra.fs = fs;
	fra.devvp = devvp;

	error = vfs_mount_foreach_vnode(mountp, ffs_reload_vnode, &fra);

	return (error);
}

/*
 * Checks if a super block is sane enough to be mounted.
 */
int
ffs_validate(struct fs *fsp)
{
#ifdef FFS2
	if (fsp->fs_magic != FS_UFS2_MAGIC && fsp->fs_magic != FS_UFS1_MAGIC)
		return (0); /* Invalid magic */
#else
	if (fsp->fs_magic != FS_UFS1_MAGIC)
		return (0); /* Invalid magic */
#endif /* FFS2 */

	if ((u_int)fsp->fs_bsize > MAXBSIZE)
		return (0); /* Invalid block size */

	if ((u_int)fsp->fs_bsize < sizeof(struct fs))
		return (0); /* Invalid block size */

	if ((u_int)fsp->fs_sbsize > SBSIZE)
		return (0); /* Invalid super block size */

	if ((u_int)fsp->fs_frag > MAXFRAG || fragtbl[fsp->fs_frag] == NULL)
		return (0); /* Invalid number of fragments */

	if (fsp->fs_inodefmt == FS_42INODEFMT)
		fsp->fs_maxsymlinklen = 0;
	else if (fsp->fs_maxsymlinklen < 0)
		return (0); /* Invalid max size of short symlink */

	return (1); /* Super block is okay */
}

/*
 * Possible locations for the super-block.
 */
const int sbtry[] = SBLOCKSEARCH;

/*
 * Common code for mount and mountroot
 */
int
ffs_mountfs(struct vnode *devvp, struct mount *mp, struct proc *p)
{
	struct ufsmount *ump;
	struct buf *bp;
	struct fs *fs;
	dev_t dev;
	caddr_t space;
	daddr_t sbloc;
	int error, i, blks, size, ronly;
	int32_t *lp;
	struct ucred *cred;
	u_int64_t maxfilesize;					/* XXX */

	dev = devvp->v_rdev;
	cred = p ? p->p_ucred : NOCRED;
	/*
	 * Disallow multiple mounts of the same device.
	 * Disallow mounting of a device that is currently in use
	 * (except for root, which might share swap device for miniroot).
	 * Flush out any old buffers remaining from a previous use.
	 */
	if ((error = vfs_mountedon(devvp)) != 0)
		return (error);
	if (vcount(devvp) > 1 && devvp != rootvp)
		return (EBUSY);
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = vinvalbuf(devvp, V_SAVE, cred, p, 0, 0);
	VOP_UNLOCK(devvp, p);
	if (error)
		return (error);

	ronly = (mp->mnt_flag & MNT_RDONLY) != 0;
	error = VOP_OPEN(devvp, ronly ? FREAD : FREAD|FWRITE, FSCRED, p);
	if (error)
		return (error);

	bp = NULL;
	ump = NULL;

	/*
	 * Try reading the super-block in each of its possible locations.
	 */
	for (i = 0; sbtry[i] != -1; i++) {
		if (bp != NULL) {
			bp->b_flags |= B_NOCACHE;
			brelse(bp);
			bp = NULL;
		}

		error = bread(devvp, sbtry[i] / DEV_BSIZE, SBSIZE, &bp);
		if (error)
			goto out;

		fs = (struct fs *) bp->b_data;
		sbloc = sbtry[i];

#if 0
		if (fs->fs_magic == FS_UFS2_MAGIC) {
			printf("ffs_mountfs(): Sorry, no UFS2 support (yet)\n");
			error = EFTYPE;
			goto out;
		}
#endif

		/*
		 * Do not look for an FFS1 file system at SBLOCK_UFS2. Doing so
		 * will find the wrong super-block for file systems with 64k
		 * block size.
		 */
		if (fs->fs_magic == FS_UFS1_MAGIC && sbloc == SBLOCK_UFS2)
			continue;

		if (ffs_validate(fs))
			break; /* Super block validated */
	}

	if (sbtry[i] == -1) {
		error = EINVAL;
		goto out;
	}

	fs->fs_fmod = 0;
	fs->fs_flags &= ~FS_UNCLEAN;
	if (fs->fs_clean == 0) {
#if 0
		/*
		 * It is safe to mount an unclean file system
		 * if it was previously mounted with softdep
		 * but we may lose space and must
		 * sometimes run fsck manually.
		 */
		if (fs->fs_flags & FS_DOSOFTDEP)
			printf(
"WARNING: %s was not properly unmounted\n",
			    fs->fs_fsmnt);
		else
#endif
		if (ronly || (mp->mnt_flag & MNT_FORCE)) {
			printf(
"WARNING: %s was not properly unmounted\n",
			    fs->fs_fsmnt);
		} else {
			printf(
"WARNING: R/W mount of %s denied.  Filesystem is not clean - run fsck\n",
			    fs->fs_fsmnt);
			error = EROFS;
			goto out;
		}
	}

	if (fs->fs_postblformat == FS_42POSTBLFMT && !ronly) {
#ifndef SMALL_KERNEL
		printf("ffs_mountfs(): obsolete rotational table format, "
		    "please use fsck_ffs(8) -c 1\n");
#endif
		error = EFTYPE;
		goto out;
	}

	ump = malloc(sizeof *ump, M_UFSMNT, M_WAITOK|M_ZERO);
	ump->um_fs = malloc((u_long)fs->fs_sbsize, M_UFSMNT,
	    M_WAITOK);

	if (fs->fs_magic == FS_UFS1_MAGIC)
		ump->um_fstype = UM_UFS1;
#ifdef FFS2
	else
		ump->um_fstype = UM_UFS2;
#endif

	memcpy(ump->um_fs, bp->b_data, fs->fs_sbsize);
	if (fs->fs_sbsize < SBSIZE)
		bp->b_flags |= B_INVAL;
	brelse(bp);
	bp = NULL;
	fs = ump->um_fs;

	ffs1_compat_read(fs, ump, sbloc);

	if (fs->fs_clean == 0)
		fs->fs_flags |= FS_UNCLEAN;
	fs->fs_ronly = ronly;
	size = fs->fs_cssize;
	blks = howmany(size, fs->fs_fsize);
	if (fs->fs_contigsumsize > 0)
		size += fs->fs_ncg * sizeof(int32_t);
	space = malloc((u_long)size, M_UFSMNT, M_WAITOK);
	fs->fs_csp = (struct csum *)space;
	for (i = 0; i < blks; i += fs->fs_frag) {
		size = fs->fs_bsize;
		if (i + fs->fs_frag > blks)
			size = (blks - i) * fs->fs_fsize;
		error = bread(devvp, fsbtodb(fs, fs->fs_csaddr + i), size, &bp);
		if (error) {
			free(fs->fs_csp, M_UFSMNT, 0);
			goto out;
		}
		memcpy(space, bp->b_data, size);
		space += size;
		brelse(bp);
		bp = NULL;
	}
	if (fs->fs_contigsumsize > 0) {
		fs->fs_maxcluster = lp = (int32_t *)space;
		for (i = 0; i < fs->fs_ncg; i++)
			*lp++ = fs->fs_contigsumsize;
	}
	mp->mnt_data = ump;
	mp->mnt_stat.f_fsid.val[0] = (long)dev;
	/* Use on-disk fsid if it exists, else fake it */
	if (fs->fs_id[0] != 0 && fs->fs_id[1] != 0)
		mp->mnt_stat.f_fsid.val[1] = fs->fs_id[1];
	else
		mp->mnt_stat.f_fsid.val[1] = mp->mnt_vfc->vfc_typenum;
	mp->mnt_stat.f_namemax = MAXNAMLEN;
	mp->mnt_flag |= MNT_LOCAL;
	ump->um_mountp = mp;
	ump->um_dev = dev;
	ump->um_devvp = devvp;
	ump->um_nindir = fs->fs_nindir;
	ump->um_bptrtodb = fs->fs_fsbtodb;
	ump->um_seqinc = fs->fs_frag;
	ump->um_maxsymlinklen = fs->fs_maxsymlinklen;
	for (i = 0; i < MAXQUOTAS; i++)
		ump->um_quotas[i] = NULLVP;

	devvp->v_specmountpoint = mp;
	ffs_oldfscompat(fs);

	if (ronly)
		fs->fs_contigdirs = NULL;
	else {
		fs->fs_contigdirs = malloc((u_long)fs->fs_ncg,
		    M_UFSMNT, M_WAITOK|M_ZERO);
	}

	/*
	 * Set FS local "last mounted on" information (NULL pad)
	 */
	memset(fs->fs_fsmnt, 0, sizeof(fs->fs_fsmnt));
	strlcpy(fs->fs_fsmnt, mp->mnt_stat.f_mntonname, sizeof(fs->fs_fsmnt));

#if 0
	if( mp->mnt_flag & MNT_ROOTFS) {
		/*
		 * Root mount; update timestamp in mount structure.
		 * this will be used by the common root mount code
		 * to update the system clock.
		 */
		mp->mnt_time = fs->fs_time;
	}
#endif

	/*
	 * XXX
	 * Limit max file size.  Even though ffs can handle files up to 16TB,
	 * we do limit the max file to 2^31 pages to prevent overflow of
	 * a 32-bit unsigned int.  The buffer cache has its own checks but
	 * a little added paranoia never hurts.
	 */
	ump->um_savedmaxfilesize = fs->fs_maxfilesize;		/* XXX */
	maxfilesize = FS_KERNMAXFILESIZE(PAGE_SIZE, fs);
	if (fs->fs_maxfilesize > maxfilesize)			/* XXX */
		fs->fs_maxfilesize = maxfilesize;		/* XXX */
	if (ronly == 0) {
		if ((fs->fs_flags & FS_DOSOFTDEP) &&
		    (error = softdep_mount(devvp, mp, fs, cred)) != 0) {
			free(fs->fs_csp, M_UFSMNT, 0);
			free(fs->fs_contigdirs, M_UFSMNT, 0);
			goto out;
		}
		fs->fs_fmod = 1;
		fs->fs_clean = 0;
		if (mp->mnt_flag & MNT_SOFTDEP)
			fs->fs_flags |= FS_DOSOFTDEP;
		else
			fs->fs_flags &= ~FS_DOSOFTDEP;
		error = ffs_sbupdate(ump, MNT_WAIT);
		if (error == EROFS)
			goto out;
	}
	return (0);
out:
	if (devvp->v_specinfo)
		devvp->v_specmountpoint = NULL;
	if (bp)
		brelse(bp);

	vn_lock(devvp, LK_EXCLUSIVE|LK_RETRY, p);
	(void)VOP_CLOSE(devvp, ronly ? FREAD : FREAD|FWRITE, cred, p);
	VOP_UNLOCK(devvp, p);

	if (ump) {
		free(ump->um_fs, M_UFSMNT, ump->um_fs->fs_sbsize);
		free(ump, M_UFSMNT, sizeof(*ump));
		mp->mnt_data = NULL;
	}
	return (error);
}

/*
 * Sanity checks for old file systems.
 */
int
ffs_oldfscompat(struct fs *fs)
{
	int i;

	fs->fs_npsect = max(fs->fs_npsect, fs->fs_nsect);	/* XXX */
	fs->fs_interleave = max(fs->fs_interleave, 1);		/* XXX */
	if (fs->fs_postblformat == FS_42POSTBLFMT)		/* XXX */
		fs->fs_nrpos = 8;				/* XXX */
	if (fs->fs_inodefmt < FS_44INODEFMT) {			/* XXX */
		u_int64_t sizepb = fs->fs_bsize;		/* XXX */
								/* XXX */
		fs->fs_maxfilesize = fs->fs_bsize * NDADDR - 1;	/* XXX */
		for (i = 0; i < NIADDR; i++) {			/* XXX */
			sizepb *= NINDIR(fs);			/* XXX */
			fs->fs_maxfilesize += sizepb;		/* XXX */
		}						/* XXX */
		fs->fs_qbmask = ~fs->fs_bmask;			/* XXX */
		fs->fs_qfmask = ~fs->fs_fmask;			/* XXX */
	}							/* XXX */
	if (fs->fs_avgfilesize <= 0)				/* XXX */
		fs->fs_avgfilesize = AVFILESIZ;			/* XXX */
	if (fs->fs_avgfpdir <= 0)				/* XXX */
		fs->fs_avgfpdir = AFPDIR;			/* XXX */
	return (0);
}

/*
 * Auxiliary function for reading FFS1 super blocks.
 */
void
ffs1_compat_read(struct fs *fs, struct ufsmount *ump, daddr_t sbloc)
{
	if (fs->fs_magic == FS_UFS2_MAGIC)
		return; /* UFS2 */
#if 0
	if (fs->fs_ffs1_flags & FS_FLAGS_UPDATED)
		return; /* Already updated */
#endif
	fs->fs_flags = fs->fs_ffs1_flags;
	fs->fs_sblockloc = sbloc;
	fs->fs_maxbsize = fs->fs_bsize;
	fs->fs_time = fs->fs_ffs1_time;
	fs->fs_size = fs->fs_ffs1_size;
	fs->fs_dsize = fs->fs_ffs1_dsize;
	fs->fs_csaddr = fs->fs_ffs1_csaddr;
	fs->fs_cstotal.cs_ndir = fs->fs_ffs1_cstotal.cs_ndir;
	fs->fs_cstotal.cs_nbfree = fs->fs_ffs1_cstotal.cs_nbfree;
	fs->fs_cstotal.cs_nifree = fs->fs_ffs1_cstotal.cs_nifree;
	fs->fs_cstotal.cs_nffree = fs->fs_ffs1_cstotal.cs_nffree;
	fs->fs_ffs1_flags |= FS_FLAGS_UPDATED;
}

/*
 * Auxiliary function for writing FFS1 super blocks.
 */
void
ffs1_compat_write(struct fs *fs, struct ufsmount *ump)
{
	if (fs->fs_magic != FS_UFS1_MAGIC)
		return; /* UFS2 */

	fs->fs_ffs1_time = fs->fs_time;
	fs->fs_ffs1_cstotal.cs_ndir = fs->fs_cstotal.cs_ndir;
	fs->fs_ffs1_cstotal.cs_nbfree = fs->fs_cstotal.cs_nbfree;
	fs->fs_ffs1_cstotal.cs_nifree = fs->fs_cstotal.cs_nifree;
	fs->fs_ffs1_cstotal.cs_nffree = fs->fs_cstotal.cs_nffree;
}

/*
 * unmount system call
 */
int
ffs_unmount(struct mount *mp, int mntflags, struct proc *p)
{
	struct ufsmount *ump;
	struct fs *fs;
	int error, flags;

	flags = 0;
	if (mntflags & MNT_FORCE)
		flags |= FORCECLOSE;

	ump = VFSTOUFS(mp);
	fs = ump->um_fs;
	if (mp->mnt_flag & MNT_SOFTDEP)
		error = softdep_flushfiles(mp, flags, p);
	else
		error = ffs_flushfiles(mp, flags, p);
	if (error != 0)
		return (error);

	if (fs->fs_ronly == 0) {
		fs->fs_clean = (fs->fs_flags & FS_UNCLEAN) ? 0 : 1;
		error = ffs_sbupdate(ump, MNT_WAIT);
		/* ignore write errors if mounted RW on read-only device */
		if (error && error != EROFS) {
			fs->fs_clean = 0;
			return (error);
		}
		free(fs->fs_contigdirs, M_UFSMNT, 0);
	}
	ump->um_devvp->v_specmountpoint = NULL;

	vn_lock(ump->um_devvp, LK_EXCLUSIVE | LK_RETRY, p);
	vinvalbuf(ump->um_devvp, V_SAVE, NOCRED, p, 0, 0);
	(void)VOP_CLOSE(ump->um_devvp, fs->fs_ronly ? FREAD : FREAD|FWRITE,
	    NOCRED, p);
	vput(ump->um_devvp);
	free(fs->fs_csp, M_UFSMNT, 0);
	free(fs, M_UFSMNT, fs->fs_sbsize);
	free(ump, M_UFSMNT, sizeof(*ump));
	mp->mnt_data = NULL;
	mp->mnt_flag &= ~MNT_LOCAL;
	return (0);
}

/*
 * Flush out all the files in a filesystem.
 */
int
ffs_flushfiles(struct mount *mp, int flags, struct proc *p)
{
	struct ufsmount *ump;
	int error;

	ump = VFSTOUFS(mp);
	if (mp->mnt_flag & MNT_QUOTA) {
		int i;
		if ((error = vflush(mp, NULLVP, SKIPSYSTEM|flags)) != 0)
			return (error);
		for (i = 0; i < MAXQUOTAS; i++) {
			if (ump->um_quotas[i] == NULLVP)
				continue;
			quotaoff(p, mp, i);
		}
		/*
		 * Here we fall through to vflush again to ensure
		 * that we have gotten rid of all the system vnodes.
		 */
	}

	/*
	 * Flush all the files.
	 */
	if ((error = vflush(mp, NULL, flags)) != 0)
		return (error);
	/*
	 * Flush filesystem metadata.
	 */
	vn_lock(ump->um_devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = VOP_FSYNC(ump->um_devvp, p->p_ucred, MNT_WAIT, p);
	VOP_UNLOCK(ump->um_devvp, p);
	return (error);
}

/*
 * Get file system statistics.
 */
int
ffs_statfs(struct mount *mp, struct statfs *sbp, struct proc *p)
{
	struct ufsmount *ump;
	struct fs *fs;

	ump = VFSTOUFS(mp);
	fs = ump->um_fs;

#ifdef FFS2
	if (fs->fs_magic != FS_MAGIC && fs->fs_magic != FS_UFS2_MAGIC)
		panic("ffs_statfs");
#else
	if (fs->fs_magic != FS_MAGIC)
		panic("ffs_statfs");
#endif /* FFS2 */

	sbp->f_bsize = fs->fs_fsize;
	sbp->f_iosize = fs->fs_bsize;
	sbp->f_blocks = fs->fs_dsize;
	sbp->f_bfree = fs->fs_cstotal.cs_nbfree * fs->fs_frag +
	    fs->fs_cstotal.cs_nffree;
	sbp->f_bavail = sbp->f_bfree -
	    ((int64_t)fs->fs_dsize * fs->fs_minfree / 100);
	sbp->f_files = fs->fs_ncg * fs->fs_ipg - ROOTINO;
	sbp->f_ffree = fs->fs_cstotal.cs_nifree;
	sbp->f_favail = sbp->f_ffree;
	copy_statfs_info(sbp, mp);

	return (0);
}

struct ffs_sync_args {
	int allerror;
	struct proc *p;
	int waitfor;
	struct ucred *cred;
};

int
ffs_sync_vnode(struct vnode *vp, void *arg) {
	struct ffs_sync_args *fsa = arg;
	struct inode *ip;
	int error;

	ip = VTOI(vp);
	if (vp->v_type == VNON || 
	    ((ip->i_flag &
		(IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0	&&
		LIST_EMPTY(&vp->v_dirtyblkhd)) ) {
		return (0);
	}

	if (vget(vp, LK_EXCLUSIVE | LK_NOWAIT, fsa->p))
		return (0);

	if ((error = VOP_FSYNC(vp, fsa->cred, fsa->waitfor, fsa->p)))
		fsa->allerror = error;
	VOP_UNLOCK(vp, fsa->p);
	vrele(vp);

	return (0);
}

/*
 * Go through the disk queues to initiate sandbagged IO;
 * go through the inodes to write those that have been modified;
 * initiate the writing of the super block if it has been modified.
 *
 * Should always be called with the mount point locked.
 */
int
ffs_sync(struct mount *mp, int waitfor, struct ucred *cred, struct proc *p)
{
	struct ufsmount *ump = VFSTOUFS(mp);
	struct fs *fs;
	int error, allerror = 0, count;
	struct ffs_sync_args fsa;

	fs = ump->um_fs;
	/*
	 * Write back modified superblock.
	 * Consistency check that the superblock
	 * is still in the buffer cache.
	 */
	if (fs->fs_fmod != 0 && fs->fs_ronly != 0) {
		printf("fs = %s\n", fs->fs_fsmnt);
		panic("update: rofs mod");
	}
 loop:
	/*
	 * Write back each (modified) inode.
	 */
	fsa.allerror = 0;
	fsa.p = p;
	fsa.cred = cred;
	fsa.waitfor = waitfor;

	/*
	 * Don't traverse the vnode list if we want to skip all of them.
	 */
	if (waitfor != MNT_LAZY) {
		vfs_mount_foreach_vnode(mp, ffs_sync_vnode, &fsa);
		allerror = fsa.allerror;
	}

	/*
	 * Force stale file system control information to be flushed.
	 */
	if ((ump->um_mountp->mnt_flag & MNT_SOFTDEP) && waitfor == MNT_WAIT) {
		if ((error = softdep_flushworklist(ump->um_mountp, &count, p)))
			allerror = error;
		/* Flushed work items may create new vnodes to clean */
		if (count) 
			goto loop;
	}
	if (waitfor != MNT_LAZY) {
		vn_lock(ump->um_devvp, LK_EXCLUSIVE | LK_RETRY, p);
		if ((error = VOP_FSYNC(ump->um_devvp, cred, waitfor, p)) != 0)
			allerror = error;
		VOP_UNLOCK(ump->um_devvp, p);
	}
	qsync(mp);
	/*
	 * Write back modified superblock.
	 */

	if (fs->fs_fmod != 0 && (error = ffs_sbupdate(ump, waitfor)) != 0)
		allerror = error;

	return (allerror);
}

/*
 * Look up a FFS dinode number to find its incore vnode, otherwise read it
 * in from disk.  If it is in core, wait for the lock bit to clear, then
 * return the inode locked.  Detection and handling of mount points must be
 * done by the calling routine.
 */
int
ffs_vget(struct mount *mp, ino_t ino, struct vnode **vpp)
{
	struct fs *fs;
	struct inode *ip;
	struct ufs1_dinode *dp1;
#ifdef FFS2
	struct ufs2_dinode *dp2;
#endif
	struct ufsmount *ump;
	struct buf *bp;
	struct vnode *vp;
	dev_t dev;
	int error;

	if (ino > (ufsino_t)-1)
		panic("ffs_vget: alien ino_t %llu", (unsigned long long)ino);

	ump = VFSTOUFS(mp);
	dev = ump->um_dev;
retry:
	if ((*vpp = ufs_ihashget(dev, ino)) != NULL)
		return (0);

	/* Allocate a new vnode/inode. */
	if ((error = getnewvnode(VT_UFS, mp, &ffs_vops, &vp)) != 0) {
		*vpp = NULL;
		return (error);
	}

#ifdef VFSLCKDEBUG
	vp->v_flag |= VLOCKSWORK;
#endif
	ip = pool_get(&ffs_ino_pool, PR_WAITOK|PR_ZERO);
	rrw_init(&ip->i_lock, "inode");
	ip->i_ump = ump;
	vref(ip->i_devvp);
	vp->v_data = ip;
	ip->i_vnode = vp;
	ip->i_fs = fs = ump->um_fs;
	ip->i_dev = dev;
	ip->i_number = ino;
	ip->i_vtbl = &ffs_vtbl;

	/*
	 * Put it onto its hash chain and lock it so that other requests for
	 * this inode will block if they arrive while we are sleeping waiting
	 * for old data structures to be purged or for the contents of the
	 * disk portion of this inode to be read.
	 */
	error = ufs_ihashins(ip);
	
	if (error) {
		/*
		 * VOP_INACTIVE will treat this as a stale file
		 * and recycle it quickly
		 */
		vrele(vp);

		if (error == EEXIST)
			goto retry;

		return (error);
	}


	/* Read in the disk contents for the inode, copy into the inode. */
	error = bread(ump->um_devvp, fsbtodb(fs, ino_to_fsba(fs, ino)),
	    (int)fs->fs_bsize, &bp);
	if (error) {
		/*
		 * The inode does not contain anything useful, so it would
		 * be misleading to leave it on its hash chain. With mode
		 * still zero, it will be unlinked and returned to the free
		 * list by vput().
		 */
		vput(vp);
		brelse(bp);
		*vpp = NULL;
		return (error);
	}

#ifdef FFS2
	if (ip->i_ump->um_fstype == UM_UFS2) {
		ip->i_din2 = pool_get(&ffs_dinode2_pool, PR_WAITOK);
		dp2 = (struct ufs2_dinode *) bp->b_data + ino_to_fsbo(fs, ino);
		*ip->i_din2 = *dp2;
	} else
#endif
	{
		ip->i_din1 = pool_get(&ffs_dinode1_pool, PR_WAITOK);
		dp1 = (struct ufs1_dinode *) bp->b_data + ino_to_fsbo(fs, ino);
		*ip->i_din1 = *dp1;
	}

	brelse(bp);

	if (DOINGSOFTDEP(vp))
		softdep_load_inodeblock(ip);
	else
		ip->i_effnlink = DIP(ip, nlink);

	/*
	 * Initialize the vnode from the inode, check for aliases.
	 * Note that the underlying vnode may have changed.
	 */
	if ((error = ffs_vinit(mp, &vp)) != 0) {
		vput(vp);
		*vpp = NULL;
		return (error);
	}

	/*
	 * Set up a generation number for this inode if it does not
	 * already have one. This should only happen on old filesystems.
	 */
	if (DIP(ip, gen) == 0) {
		DIP_ASSIGN(ip, gen, arc4random() & INT_MAX);
		if (DIP(ip, gen) == 0 || DIP(ip, gen) == -1)
			DIP_ASSIGN(ip, gen, 1);	/* Shouldn't happen */
		if ((vp->v_mount->mnt_flag & MNT_RDONLY) == 0)
			ip->i_flag |= IN_MODIFIED;
	}

	/*
	 * Ensure that uid and gid are correct. This is a temporary
	 * fix until fsck has been changed to do the update.
	 */
	if (fs->fs_magic == FS_UFS1_MAGIC && fs->fs_inodefmt < FS_44INODEFMT) {
		ip->i_ffs1_uid = ip->i_din1->di_ouid;
		ip->i_ffs1_gid = ip->i_din1->di_ogid;
	}

	*vpp = vp;

	return (0);
}

/*
 * File handle to vnode
 *
 * Have to be really careful about stale file handles.
 */
int
ffs_fhtovp(struct mount *mp, struct fid *fhp, struct vnode **vpp)
{
	struct ufid *ufhp;
	int error;

	ufhp = (struct ufid *)fhp;
	if (ufhp->ufid_len != sizeof(*ufhp))
		return EINVAL;

	if ((error = ffs_checkrange(mp, ufhp->ufid_ino)) != 0)
		return error;

	return (ufs_fhtovp(mp, ufhp, vpp));
}

/*
 * Vnode pointer to File handle
 */
int
ffs_vptofh(struct vnode *vp, struct fid *fhp)
{
	struct inode *ip;
	struct ufid *ufhp;

	ip = VTOI(vp);
	ufhp = (struct ufid *)fhp;
	ufhp->ufid_len = sizeof(struct ufid);
	ufhp->ufid_ino = ip->i_number;
	ufhp->ufid_gen = DIP(ip, gen);

	return (0);
}

/*
 * Write a superblock and associated information back to disk.
 */
int
ffs_sbupdate(struct ufsmount *mp, int waitfor)
{
	struct fs *dfs, *fs = mp->um_fs;
	struct buf *bp;
	int blks;
	caddr_t space;
	int i, size, error, allerror = 0;

	/*
	 * First write back the summary information.
	 */
	blks = howmany(fs->fs_cssize, fs->fs_fsize);
	space = (caddr_t)fs->fs_csp;
	for (i = 0; i < blks; i += fs->fs_frag) {
		size = fs->fs_bsize;
		if (i + fs->fs_frag > blks)
			size = (blks - i) * fs->fs_fsize;
		bp = getblk(mp->um_devvp, fsbtodb(fs, fs->fs_csaddr + i),
			    size, 0, 0);
		memcpy(bp->b_data, space, size);
		space += size;
		if (waitfor != MNT_WAIT)
			bawrite(bp);
		else if ((error = bwrite(bp)))
			allerror = error;
	}

	/*
	 * Now write back the superblock itself. If any errors occurred
	 * up to this point, then fail so that the superblock avoids
	 * being written out as clean.
	 */
	if (allerror) {
		return (allerror);
	}

	bp = getblk(mp->um_devvp,
	    fs->fs_sblockloc >> (fs->fs_fshift - fs->fs_fsbtodb),
	    (int)fs->fs_sbsize, 0, 0);
	fs->fs_fmod = 0;
	fs->fs_time = time_second;
	memcpy(bp->b_data, fs, fs->fs_sbsize);
	/* Restore compatibility to old file systems.		   XXX */
	dfs = (struct fs *)bp->b_data;				/* XXX */
	if (fs->fs_postblformat == FS_42POSTBLFMT)		/* XXX */
		dfs->fs_nrpos = -1;				/* XXX */
	if (fs->fs_inodefmt < FS_44INODEFMT) {			/* XXX */
		int32_t *lp, tmp;				/* XXX */
								/* XXX */
		lp = (int32_t *)&dfs->fs_qbmask;		/* XXX */
		tmp = lp[4];					/* XXX */
		for (i = 4; i > 0; i--)				/* XXX */
			lp[i] = lp[i-1];			/* XXX */
		lp[0] = tmp;					/* XXX */
	}							/* XXX */
	dfs->fs_maxfilesize = mp->um_savedmaxfilesize;		/* XXX */

	ffs1_compat_write(dfs, mp);

	if (waitfor != MNT_WAIT)
		bawrite(bp);
	else if ((error = bwrite(bp)))
		allerror = error;

	return (allerror);
}

int
ffs_init(struct vfsconf *vfsp)
{
	static int done;

	if (done)
		return (0);

	done = 1;

	pool_init(&ffs_ino_pool, sizeof(struct inode), 0, IPL_NONE,
	    PR_WAITOK, "ffsino", NULL);
	pool_init(&ffs_dinode1_pool, sizeof(struct ufs1_dinode), 0, IPL_NONE,
	    PR_WAITOK, "dino1pl", NULL);
#ifdef FFS2
	pool_init(&ffs_dinode2_pool, sizeof(struct ufs2_dinode), 0, IPL_NONE,
	    PR_WAITOK, "dino2pl", NULL);
#endif

	softdep_initialize();

	return (ufs_init(vfsp));
}

/*
 * fast filesystem related variables.
 */
int
ffs_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
#ifdef FFS_SOFTUPDATES
	extern int max_softdeps, tickdelay, stat_worklist_push;
	extern int stat_blk_limit_push, stat_ino_limit_push, stat_blk_limit_hit;
	extern int stat_ino_limit_hit, stat_sync_limit_hit, stat_indir_blk_ptrs;
	extern int stat_inode_bitmap, stat_direct_blk_ptrs, stat_dir_entry;
#endif

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case FFS_CLUSTERREAD:
	case FFS_CLUSTERWRITE:
	case FFS_REALLOCBLKS:
	case FFS_ASYNCFREE:
		return (EOPNOTSUPP);
#ifdef FFS_SOFTUPDATES
	case FFS_MAX_SOFTDEPS:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &max_softdeps));
	case FFS_SD_TICKDELAY:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &tickdelay));
	case FFS_SD_WORKLIST_PUSH:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_worklist_push));
	case FFS_SD_BLK_LIMIT_PUSH:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_blk_limit_push));
	case FFS_SD_INO_LIMIT_PUSH:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_ino_limit_push));
	case FFS_SD_BLK_LIMIT_HIT:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_blk_limit_hit));
	case FFS_SD_INO_LIMIT_HIT:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_ino_limit_hit));
	case FFS_SD_SYNC_LIMIT_HIT:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_sync_limit_hit));
	case FFS_SD_INDIR_BLK_PTRS:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_indir_blk_ptrs));
	case FFS_SD_INODE_BITMAP:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_inode_bitmap));
	case FFS_SD_DIRECT_BLK_PTRS:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_direct_blk_ptrs));
	case FFS_SD_DIR_ENTRY:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_dir_entry));
#endif
#ifdef UFS_DIRHASH
	case FFS_DIRHASH_DIRSIZE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &ufs_mindirhashsize));
	case FFS_DIRHASH_MAXMEM:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &ufs_dirhashmaxmem));
	case FFS_DIRHASH_MEM:
		return (sysctl_rdint(oldp, oldlenp, newp, ufs_dirhashmem));
#endif

	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}
@


1.163
log
@Remove usermount remnants. ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.162 2016/08/13 21:28:09 guenther Exp $	*/
d1493 3
a1495 4
	pool_init(&ffs_ino_pool, sizeof(struct inode), 0, 0, PR_WAITOK,
	    "ffsino", NULL);
	pool_setipl(&ffs_ino_pool, IPL_NONE);
	pool_init(&ffs_dinode1_pool, sizeof(struct ufs1_dinode), 0, 0,
a1496 1
	pool_setipl(&ffs_dinode1_pool, IPL_NONE);
d1498 1
a1498 1
	pool_init(&ffs_dinode2_pool, sizeof(struct ufs2_dinode), 0, 0,
a1499 1
	pool_setipl(&ffs_dinode2_pool, IPL_NONE);
@


1.162
log
@Missed a couple qaddr_t casts
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.161 2016/08/10 08:04:57 natano Exp $	*/
a215 1
	mode_t accessmode;
a306 13
			/*
			 * If upgrade to read-write by non-root, then verify
			 * that user has necessary permissions on the device.
			 */
			if (suser(p, 0)) {
				vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
				error = VOP_ACCESS(devvp, VREAD | VWRITE,
						   p->p_ucred, p);
				VOP_UNLOCK(devvp, p);
				if (error)
					goto error_1;
			}

a382 15
	}

	/*
	 * If mount by non-root, then verify that user has necessary
	 * permissions on the device.
	 */
	if (suser(p, 0)) {
		accessmode = VREAD;
		if ((mp->mnt_flag & MNT_RDONLY) == 0)
			accessmode |= VWRITE;
		vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
		error = VOP_ACCESS(devvp, accessmode, p->p_ucred, p);
		VOP_UNLOCK(devvp, p);
		if (error)
			goto error_2;
@


1.161
log
@ufs_vinit() should really be called ffs_vinit(); it's only called from
ffs code.
ok mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.160 2016/06/19 11:54:34 natano Exp $	*/
d870 1
a870 1
	mp->mnt_data = (qaddr_t)ump;
@


1.160
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.159 2016/06/19 10:21:56 dlg Exp $	*/
d1370 1
a1370 2
	error = ufs_vinit(mp, &ffs_specvops, FFS_FIFOOPS, &vp);
	if (error) {
@


1.159
log
@add pool_setipl on all pools.

ok tedu@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.158 2016/05/23 09:31:28 natano Exp $	*/
d1298 1
a1298 1
	lockinit(&ip->i_lock, PINOD, "inode", 0, 0);
@


1.158
log
@VOP_REALLOCBLKS() and related code is unused since the removal of
cluster_write().
ok beck zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.157 2016/05/22 20:27:04 bluhm Exp $	*/
d1525 1
d1528 1
d1532 1
@


1.157
log
@When pulling an msdos formated umass stick during mount while the
usb stack was busy, the kernel could trigger an uvm fault.  There
is a race between vop_generic_revoke() and sys_mount() where vgonel()
could reset v_specinfo.  Then v_specmountpoint is no longer valid.
So after sleeping, msdosfs_mountfs() could crash in the error path.
The code in the different *_mountfs() functions was inconsistent,
implement the same check everywhere.
OK krw@@ natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.156 2016/05/10 10:37:57 krw Exp $	*/
a1543 1
	extern int doreallocblks, doasyncfree;
a1557 1
		return (EOPNOTSUPP);
a1558 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &doreallocblks));
d1560 1
a1560 1
		return (sysctl_int(oldp, oldlenp, newp, newlen, &doasyncfree));
@


1.156
log
@FFS2 does lazy inode initialization, so try harder to avoid using
random data on the disk as an inode. Thus avoiding crashes when
translating a bogus filehandle to a vnode. Yes, I'm looking at you,
NFS!

Adapted from a diff by Christos Zoulas via NetBSD, pointed out by
kurt@@.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.155 2016/03/27 11:39:37 bluhm Exp $	*/
d946 2
a947 1
	devvp->v_specmountpoint = NULL;
@


1.155
log
@When pulling and unmounting an umass USB stick, the file system
could end up in an inconsistent state.  The fstype dependent
mp->mnt_data was NULL, but the general mp was still listed as a
valid mount point.  Next access to the file system would crash with
a NULL pointer dereference.
If closing the device fails, the mount point must go away anyway.
There is nothing we can do about it.  Remove the workaround for the
EIO error in the general unmount code, but do not generate any error
in the file system specific unmount functions.
OK natano@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.154 2016/03/19 12:04:16 natano Exp $	*/
d100 41
d1405 1
a1405 4
 * Have to be really careful about stale file handles:
 * - check that the inode number is valid
 * - call ffs_vget() to get the locked inode
 * - check for an unallocated inode (i_mode == 0)
d1411 1
a1411 1
	struct fs *fs;
d1414 6
a1419 5
	fs = VFSTOUFS(mp)->um_fs;
	if (ufhp->ufid_len != sizeof(*ufhp) ||
	    ufhp->ufid_ino < ROOTINO ||
	    ufhp->ufid_ino >= fs->fs_ncg * fs->fs_ipg)
		return (ESTALE);
@


1.154
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.153 2016/03/17 18:52:32 bluhm Exp $	*/
d1030 2
a1031 2
	error = VOP_CLOSE(ump->um_devvp, fs->fs_ronly ? FREAD : FREAD|FWRITE,
		NOCRED, p);
d1038 1
a1038 1
	return (error);
@


1.153
log
@Set mnt_data to NULL after freeing the file system specific mount point.
OK krw@@ natano@@ as part of a larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.152 2016/02/27 18:50:38 natano Exp $	*/
d275 1
a275 1
				VOP_UNLOCK(devvp, 0, p);
d368 1
a368 1
		VOP_UNLOCK(devvp, 0, p);
d543 1
a543 1
	VOP_UNLOCK(devvp, 0, p);
d689 1
a689 1
	VOP_UNLOCK(devvp, 0, p);
d911 1
a911 1
	VOP_UNLOCK(devvp, 0, p);
d1076 1
a1076 1
	VOP_UNLOCK(ump->um_devvp, 0, p);
d1141 1
a1141 1
	VOP_UNLOCK(vp, 0, fsa->p);
d1203 1
a1203 1
		VOP_UNLOCK(ump->um_devvp, 0, p);
@


1.152
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.151 2016/02/26 08:56:10 natano Exp $	*/
d1036 1
a1036 1
	mp->mnt_data = (qaddr_t)0;
@


1.151
log
@Convert mnt_maxsymlinklen to unsigned.

This allows to remove some truncating casts in symlink handling code.
Also, validate fs_maxsymlinklen in the superblock at mount time and on
fsck to make sure we don't use bogus data.

discussion & ok millert@@, stefan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.150 2016/01/12 11:41:00 mpi Exp $	*/
d576 1
a576 1
	mountp->mnt_maxsymlinklen = fs->fs_maxsymlinklen;
a836 1
	mp->mnt_maxsymlinklen = fs->fs_maxsymlinklen;
d844 1
@


1.150
log
@Remove the "doclusterread" and "doclusterwrite" buttons.

Cluster read is unconditionnally enabled for FFS since some years and
toggling "doclusterread" has no effect.

OpenBSD no longer support write clustering since the Dynamic Buffer
Cache went in, so there is reason to delay the call to bawrite(9).

Tested by Mathieu, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.149 2015/03/14 03:38:52 jsg Exp $	*/
d644 5
@


1.149
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.148 2014/12/29 05:29:28 miod Exp $	*/
d1499 1
a1499 1
	extern int doclusterread, doclusterwrite, doreallocblks, doasyncfree;
a1512 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &doclusterread));
d1514 1
a1514 2
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &doclusterwrite));
@


1.148
log
@Explicitely include <uvm/uvm_extern.h> in order to build on variable page size
architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.147 2014/12/23 01:53:34 tedu Exp $	*/
a45 1
#include <sys/disklabel.h>
@


1.147
log
@change pool_init allocator to NULL and pass PR_WAITOK in flags as a sign
that these don't need to support interrupts
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.146 2014/12/12 22:58:48 tedu Exp $	*/
d65 2
@


1.146
log
@free correct size. it's variable!
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.145 2014/12/12 19:02:07 tedu Exp $	*/
d1477 4
a1480 4
	pool_init(&ffs_ino_pool, sizeof(struct inode), 0, 0, 0, "ffsino",
	    &pool_allocator_nointr);
	pool_init(&ffs_dinode1_pool, sizeof(struct ufs1_dinode), 0, 0, 0,
	    "dino1pl", &pool_allocator_nointr);
d1482 2
a1483 2
	pool_init(&ffs_dinode2_pool, sizeof(struct ufs2_dinode), 0, 0, 0,
	    "dino2pl", &pool_allocator_nointr);
@


1.145
log
@sizeof(*ptr) for some free()
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.144 2014/11/18 02:37:31 tedu Exp $	*/
d908 1
a908 1
		free(ump->um_fs, M_UFSMNT, sizeof(*ump->um_fs));
d1028 1
a1028 1
	free(fs, M_UFSMNT, sizeof(*fs));
@


1.144
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.143 2014/07/14 08:11:34 beck Exp $	*/
d140 1
a140 1
		free(mp, M_MOUNT, 0);
d908 2
a909 2
		free(ump->um_fs, M_UFSMNT, 0);
		free(ump, M_UFSMNT, 0);
d1028 2
a1029 2
	free(fs, M_UFSMNT, 0);
	free(ump, M_UFSMNT, 0);
@


1.143
log
@revert free checks in here. this seems to be a bit too agressive at the
moment and now is not the time. hitting these in here causes chaos.
We need to do these, but at a better time than right after a hackathon
and before release.
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.142 2014/07/13 23:33:26 tedu Exp $	*/
a54 2

#include <dev/rndvar.h>
@


1.142
log
@pass correct sizes to free()
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.141 2014/07/12 18:44:01 tedu Exp $	*/
d142 1
a142 1
		free(mp, M_MOUNT, sizeof(*mp));
d910 2
a911 2
		free(ump->um_fs, M_UFSMNT, sizeof(*ump->um_fs));
		free(ump, M_UFSMNT, sizeof(*ump));
d1030 2
a1031 2
	free(fs, M_UFSMNT, sizeof(*fs));
	free(ump, M_UFSMNT, sizeof(*ump));
@


1.141
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.140 2013/12/12 19:00:10 tedu Exp $	*/
d142 1
a142 1
		free(mp, M_MOUNT, 0);
d910 3
a912 3
		free(ump->um_fs, M_UFSMNT, 0);
		free(ump, M_UFSMNT, 0);
		mp->mnt_data = (qaddr_t)0;
d1030 2
a1031 2
	free(fs, M_UFSMNT, 0);
	free(ump, M_UFSMNT, 0);
@


1.140
log
@replace old bcopy/bzero with standard functions. ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.139 2013/12/01 16:40:56 krw Exp $	*/
d142 1
a142 1
		free(mp, M_MOUNT);
d439 1
a439 1
				free(fs->fs_contigdirs, M_UFSMNT);
d812 1
a812 1
			free(fs->fs_csp, M_UFSMNT);
d885 2
a886 2
			free(fs->fs_csp, M_UFSMNT);
			free(fs->fs_contigdirs, M_UFSMNT);
d910 2
a911 2
		free(ump->um_fs, M_UFSMNT);
		free(ump, M_UFSMNT);
d1020 1
a1020 1
		free(fs->fs_contigdirs, M_UFSMNT);
d1029 3
a1031 3
	free(fs->fs_csp, M_UFSMNT);
	free(fs, M_UFSMNT);
	free(ump, M_UFSMNT);
@


1.139
log
@Change 'mountlist' from CIRCLEQ to TAILQ. Be paranoid and
use TAILQ_*_SAFE more than might be needed.

Bulk ports build by sthen@@ showed nobody sticking their fingers
so deep into the kernel.

Feedback and suggestions from millert@@. ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.138 2013/06/11 16:42:18 deraadt Exp $	*/
d151 1
a151 2
	(void)copystr(mp->mnt_stat.f_mntonname, fs->fs_fsmnt, MNAMELEN - 1,
	    NULL);
d341 1
a341 1
		bcopy(fspec, fname, sizeof(fname));
d396 1
a396 1
			bzero(mp->mnt_stat.f_mntfromname, MNAMELEN);
d398 1
a398 1
			bzero(mp->mnt_stat.f_mntfromspec, MNAMELEN);
d408 1
a408 1
		bzero(mp->mnt_stat.f_mntonname, MNAMELEN);
d410 1
a410 1
		bzero(mp->mnt_stat.f_mntfromname, MNAMELEN);
d412 1
a412 1
		bzero(mp->mnt_stat.f_mntfromspec, MNAMELEN);
d427 1
a427 1
	bcopy(&args, &mp->mnt_stat.mount_info.ufs_args, sizeof(args));
d573 1
a573 1
	bcopy(newfs, fs, (u_int)fs->fs_sbsize);
d595 1
a595 1
		bcopy(bp->b_data, space, (u_int)size);
a667 1
	size_t strsize;
d788 1
a788 1
	bcopy(bp->b_data, ump->um_fs, (u_int)fs->fs_sbsize);
d815 1
a815 1
		bcopy(bp->b_data, space, (u_int)size);
d857 2
a858 5
	copystr(mp->mnt_stat.f_mntonname,	/* mount point*/
		fs->fs_fsmnt,			/* copy area*/
		sizeof(fs->fs_fsmnt) - 1,	/* max size*/
		&strsize);			/* real size*/
	bzero(fs->fs_fsmnt + strsize, sizeof(fs->fs_fsmnt) - strsize);
d1421 1
a1421 1
		bcopy(space, bp->b_data, (u_int)size);
d1443 1
a1443 1
	bcopy((caddr_t)fs, bp->b_data, (u_int)fs->fs_sbsize);
@


1.138
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.137 2013/05/30 19:19:09 guenther Exp $	*/
d148 1
a148 1
	CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
@


1.137
log
@UFS does't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

otto wrote the original diff for libsa to keep bootblock from overflowing
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.136 2013/04/15 15:32:19 jsing Exp $	*/
d73 1
a73 1
void ffs1_compat_read(struct fs *, struct ufsmount *, daddr64_t);
d666 1
a666 1
	daddr64_t sbloc;
d956 1
a956 1
ffs1_compat_read(struct fs *fs, struct ufsmount *ump, daddr64_t sbloc)
@


1.136
log
@Add an f_mntfromspec member to struct statfs, which specifies the name of
the special provided when the mount was requested. This may be the same as
the special that was actually used for the mount (e.g. in the case of a
device node) or it may be different (e.g. in the case of a DUID).

Whilst here, change f_ctime to a 64 bit type and remove the pointless
f_spare members.

Compatibility goo courtesy of guenther@@

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.135 2012/09/10 11:11:00 jsing Exp $	*/
d1238 3
d1378 2
a1379 1
	if (ufhp->ufid_ino < ROOTINO ||
@


1.135
log
@Cleanup VFS mount string handling:

- Avoid using copyinstr() without checking the return value.

- sys_mount() has already copied the path in, so pass this to the
  filesystem mount code so that it does not have to copy it in again.

- Avoid copyinstr()/bzero() dance when we can simply bzero() and strlcpy().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.133 2011/07/04 20:35:35 deraadt Exp $	*/
d173 1
a177 1
	size_t size;
d179 1
a179 1
	error = copyin(data, &args, sizeof (struct ufs_args));
d339 4
a342 2
		goto error_1; 
	disk_map(fspec, fspec, MNAMELEN, DM_OPENBLCK);
d344 1
a344 1
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE, fspec, p);
d397 4
a400 4
			size = strlcpy(mp->mnt_stat.f_mntfromname, fspec,
			    MNAMELEN - 1);
			bzero(mp->mnt_stat.f_mntfromname + size,
			      MNAMELEN - size);
d412 3
a414 1
		strlcpy(mp->mnt_stat.f_mntfromname, fspec, MNAMELEN);
@


1.134
log
@Do NOT make all check condition results report EIO. Only use EIO
when b_error has not already been set to something more informative,
e.g. EROFS.

DO check the result of ffs_sbupdate() and error out of a mount()
call when ffs_sbupdate() reports EROFS while attempting a rw mount.

Letting RW mounts proceed regardless of EROFS led to crashes and
usb problems for Oliver Seufer while using the RW/RO switches on
some usb devices. Fix developed using devices kindly supplied by
Oliver & Co.

ok miod@@
@
text
@d173 1
a177 1
	char *fspec = NULL;
d320 1
a320 1
		if (args.fspec == 0) {
d337 3
a339 2
	fspec = malloc(MNAMELEN, M_MOUNT, M_WAITOK);
	copyinstr(args.fspec, fspec, MNAMELEN - 1, &size);
d407 4
a410 10
		/* Save "last mounted on" info for mount point (NULL pad)*/
		copyinstr(path,				/* mount point*/
			  mp->mnt_stat.f_mntonname,	/* save area*/
			  MNAMELEN - 1,			/* max size*/
			  &size);			/* real size*/
		bzero(mp->mnt_stat.f_mntonname + size, MNAMELEN - size);

		/* Save "mounted from" info for mount point (NULL pad)*/
		size = strlcpy(mp->mnt_stat.f_mntfromname, fspec, MNAMELEN - 1);
		bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
d425 1
a425 1
	(void)VFS_STATFS(mp, &mp->mnt_stat, p);
a451 4

	if (fspec)
		free(fspec, M_MOUNT);

@


1.133
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.132 2011/07/04 04:30:41 tedu Exp $	*/
d905 3
a907 1
		(void) ffs_sbupdate(ump, MNT_WAIT);
@


1.132
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.131 2011/07/03 18:23:10 tedu Exp $	*/
d54 1
a56 2

#include <miscfs/specfs/specdev.h>
@


1.131
log
@correctify NULL 0 confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.130 2011/07/02 16:23:47 krw Exp $	*/
d504 1
a504 1
	    (int)fra->fs->fs_bsize, NOCRED, &bp);
d560 1
a560 2
	error = bread(devvp, (daddr64_t)(fs->fs_sblockloc / DEV_BSIZE), SBSIZE,
	    NOCRED, &bp);
d597 1
a597 2
		error = bread(devvp, fsbtodb(fs, fs->fs_csaddr + i), size,
			      NOCRED, &bp);
d715 1
a715 1
		error = bread(devvp, sbtry[i] / DEV_BSIZE, SBSIZE, cred, &bp);
d818 1
a818 2
		error = bread(devvp, fsbtodb(fs, fs->fs_csaddr + i), size,
			      cred, &bp);
d1292 1
a1292 1
		      (int)fs->fs_bsize, NOCRED, &bp);
@


1.130
log
@Getting a disklabel to extract d_secsize to initialize a variable that is then
re-initialized before use is silly. ffs shouldn't know of or worry about the
physical disk sector size.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.129 2011/07/02 15:52:25 thib Exp $	*/
d152 2
a153 1
	(void) copystr(mp->mnt_stat.f_mntonname, fs->fs_fsmnt, MNAMELEN - 1, 0);
@


1.129
log
@rename VFSDEBUG to VFLCKDEBUG;

prompted by tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.128 2010/12/21 20:14:44 thib Exp $	*/
a536 1
	struct partinfo dpart;
a556 5
	if (VOP_IOCTL(devvp, DIOCGPART, (caddr_t)&dpart, FREAD, NOCRED, p) != 0)
		size = DEV_BSIZE;
	else
		size = dpart.disklab->d_secsize;

a671 1
	struct partinfo dpart;
a701 4
	if (VOP_IOCTL(devvp, DIOCGPART, (caddr_t)&dpart, FREAD, cred, p) != 0)
		size = DEV_BSIZE;
	else
		size = dpart.disklab->d_secsize;
@


1.128
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.127 2010/09/10 16:34:09 thib Exp $	*/
d1266 2
a1267 1
#ifdef VFSDEBUG
@


1.127
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.126 2010/09/06 23:44:10 thib Exp $	*/
d1262 1
a1262 1
	if ((error = getnewvnode(VT_UFS, mp, ffs_vnodeop_p, &vp)) != 0) {
d1342 1
a1342 1
	error = ufs_vinit(mp, ffs_specop_p, FFS_FIFOOPS, &vp);
@


1.126
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.125 2010/07/23 17:31:54 ray Exp $	*/
d1262 1
a1262 1
	if ((error = getnewvnode(VT_UFS, mp, &ffs_vops, &vp)) != 0) {
d1342 1
a1342 1
	error = ufs_vinit(mp, &ffs_specvops, FFS_FIFOOPS, &vp);
@


1.125
log
@Improve English.

Help by jmc, earlier version OK thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.124 2010/06/29 14:48:08 thib Exp $	*/
d1262 1
a1262 1
	if ((error = getnewvnode(VT_UFS, mp, ffs_vnodeop_p, &vp)) != 0) {
d1342 1
a1342 1
	error = ufs_vinit(mp, ffs_specop_p, FFS_FIFOOPS, &vp);
@


1.124
log
@remove lies. the arguments are actually used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.123 2010/06/09 12:58:57 jsing Exp $	*/
d285 1
a285 1
				 * It is safe mount unclean file system
d287 1
a287 1
				 * but we may loss space and must
d764 1
a764 1
		 * It is safe mount unclean file system
d766 1
a766 1
		 * but we may loss space and must
@


1.123
log
@Teach FFS mounts about disklabel UIDs. This allows file systems to be
mounted by specifying a disklabel UID followed by a dot and a partition.
For example:

mount -t ffs 0123456789abcdef.a /mnt

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.121 2009/12/19 00:27:17 krw Exp $	*/
a1399 1
/* ARGSUSED */
@


1.122
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d53 1
d177 1
d332 1
d337 5
a341 1
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_USERSPACE, args.fspec, p);
d394 2
a395 4
			copyinstr(args.fspec,
				  mp->mnt_stat.f_mntfromname,
				  MNAMELEN - 1,
				  &size);
d414 1
a414 4
		copyinstr(args.fspec,			/* device name*/
			  mp->mnt_stat.f_mntfromname,	/* save area*/
			  MNAMELEN - 1,			/* max size*/
			  &size);			/* real size*/
d455 1
d457 4
@


1.121
log
@Re-introduce the remaining bits of thib@@'s Aug 2006 VOP_CLOSE()
locking fixes. Tweak cd9660 code to be the same as everywhere else,
no functional change.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.120 2009/07/09 22:29:56 thib Exp $	*/
d52 1
@


1.120
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.118 2008/11/02 08:53:06 otto Exp $	*/
d918 2
d921 2
@


1.119
log
@use PAGE_SIZE in FS_KERNMAXFILESIZE() use, note this is not the same as getpagesize() elsewhere.  otto, please fix correctly after
@
text
@d1260 1
a1260 1
	VREF(ip->i_devvp);
@


1.118
log
@introduce a macro for max file size, instead of hardcoding it; ok
millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.117 2008/09/12 12:27:27 blambert Exp $	*/
d895 1
a895 1
	maxfilesize = FS_KERNMAXFILESIZE(fs);
@


1.117
log
@Remove bzero/memset calls after pool_gets by passing the PR_ZERO
flag to the pool_get call.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.116 2008/08/08 23:49:53 krw Exp $	*/
d895 1
a895 1
	maxfilesize = (u_int64_t)0x80000000 * MIN(PAGE_SIZE, fs->fs_bsize) - 1;
@


1.116
log
@Admit b_blkno means block number; a block is DEV_BSIZE (a.k.a.
512) bytes; ffs is inextricably tied to using b_blkno and disklabel
always uses sectorsize units.

Thus use DEV_BSIZE units for all fields describing ffs filesystems
and convert to/from sectors where required. This enables the creation
and use of ffs filesystems on non-512 byte sectorsize devices.

This diff allows i386 and sgi (the two test platforms) to find
disklabels that are not on a sectorsize boundary. Same change to
further archs coming.

This is a no-op on 512-byte sectorsize devices.

This work triggered by jsing@@'s need to create ffs filesystems on
sgi cdroms so we can create cdrom install media for sgi.

sgi testing by jsing@@

ok jsing@@ pedro@@ "looks sane" beck@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.115 2008/08/08 09:02:25 thib Exp $	*/
d1257 1
a1257 2
	ip = pool_get(&ffs_ino_pool, PR_WAITOK);
	bzero((caddr_t)ip, sizeof(struct inode));
@


1.115
log
@spacing + wrap a line at 79chars.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.114 2008/07/09 09:30:51 thib Exp $	*/
d557 1
a557 1
	error = bread(devvp, (daddr64_t)(fs->fs_sblockloc / size), SBSIZE,
d719 1
a719 1
		error = bread(devvp, sbtry[i] / size, SBSIZE, cred, &bp);
@


1.114
log
@Remove an XXX comment about using the same pool for mfs and ffs, since
mfs is using the ffs code and its the same object it would make no sense
having two seperate pools...

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.113 2008/03/16 19:42:57 otto Exp $	*/
d1110 3
a1112 2
		fs->fs_cstotal.cs_nffree;
	sbp->f_bavail = sbp->f_bfree - ((int64_t)fs->fs_dsize * fs->fs_minfree / 100);
@


1.113
log
@Widen some struct statfs fields to support large filesystem stata
and add some to be able to support statvfs(2). Do the compat dance
to provide backward compatibility.  ok thib@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.112 2008/01/05 19:49:26 otto Exp $	*/
a1255 1
	/* XXX - we use the same pool for ffs and mfs */
@


1.112
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.111 2007/09/10 20:57:04 thib Exp $	*/
d845 1
d1114 2
a1115 7
	if (sbp != &mp->mnt_stat) {
		bcopy(mp->mnt_stat.f_mntonname, sbp->f_mntonname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromname, sbp->f_mntfromname, MNAMELEN);
		bcopy(&mp->mnt_stat.mount_info.ufs_args,
		    &sbp->mount_info.ufs_args, sizeof(struct ufs_args));
	}
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
@


1.111
log
@Lock the vnode in ffs_unmount() before passing it too vinvalbuf()
and VOP_CLOSE() since both of them expected it too be locked.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.110 2007/09/07 15:00:20 art Exp $	*/
d557 1
a557 1
	error = bread(devvp, (daddr_t)(fs->fs_sblockloc / size), SBSIZE,
@


1.110
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.109 2007/08/04 03:33:31 art Exp $	*/
d1033 1
d1037 1
a1037 1
	vrele(ump->um_devvp);
@


1.109
log
@When we're writing out the summary information and fail on some block
we'll just randomly brelse a random block that might or might no have
been the block that failed. Which wouldn't be necessary anyway since
bwrite releases the block wether the write succeeded or not.  And if
someone won the race for that block (perfectly possible since we're
sleeping in this function) we'll just release a live block under his
feet.

beck@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.108 2007/06/06 09:53:16 pedro Exp $	*/
d312 2
a313 3
			fs->fs_contigdirs=(u_int8_t*)malloc((u_long)fs->fs_ncg,
							    M_UFSMNT, M_WAITOK);
			bzero(fs->fs_contigdirs, fs->fs_ncg);
d789 1
a789 2
	ump = malloc(sizeof *ump, M_UFSMNT, M_WAITOK);
	bzero(ump, sizeof *ump);
d862 2
a863 3
		fs->fs_contigdirs = (u_int8_t*)malloc((u_long)fs->fs_ncg,
						      M_UFSMNT, M_WAITOK);
		bzero(fs->fs_contigdirs, fs->fs_ncg);
@


1.108
log
@Don't promote MNT_WAIT to MNT_NOWAIT when syncing the device vnode of a
mounted softdep file system, okay mickey@@ beck@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.107 2007/06/01 06:38:54 deraadt Exp $	*/
a1447 1
		brelse(bp);
@


1.107
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.106 2007/05/29 19:02:33 otto Exp $	*/
a1210 2
		if (ump->um_mountp->mnt_flag & MNT_SOFTDEP)
			waitfor = MNT_NOWAIT;
@


1.106
log
@when mount -f'ing a dirty filesystem, do not clear the unclean flag,
the fs remains dirty. ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.105 2007/05/29 18:40:53 pedro Exp $	*/
d72 1
a72 1
void ffs1_compat_read(struct fs *, struct ufsmount *, ufs2_daddr_t);
d673 1
a673 1
	ufs2_daddr_t sbloc;
d963 1
a963 1
ffs1_compat_read(struct fs *fs, struct ufsmount *ump, ufs2_daddr_t sbloc)
@


1.105
log
@FFS2-aware code for ffs_sbupdate() and ffs_reload().
Okay otto@@ millert@@ krw@@ beck@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.104 2007/04/24 12:10:28 millert Exp $	*/
a754 1
		fs->fs_flags |= FS_UNCLEAN;
d811 2
@


1.104
log
@Fix mounting of ffs2 via "mount -a".  ffs2 is not separate from ffs
and should not have its own MOUNT_XXX define.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.103 2007/04/11 15:17:46 thib Exp $	*/
d556 4
a559 1
	error = bread(devvp, (daddr_t)(SBOFF / size), SBSIZE, NOCRED, &bp);
d570 1
a570 1
	fs = VFSTOUFS(mountp)->um_fs;
d584 1
a584 1
	ffs1_compat_read(fs, VFSTOUFS(mountp), SBOFF);
d1442 1
d1448 2
a1449 1
	if (allerror)
d1451 1
d1453 3
a1455 2
	bp = getblk(mp->um_devvp, SBOFF >> (fs->fs_fshift - fs->fs_fsbtodb),
		    (int)fs->fs_sbsize, 0, 0);
d1480 1
@


1.103
log
@in ffs_reload() use ffs_validate() to check if the
superblock is OK; Makes it work for FFS2.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.102 2007/03/31 15:30:07 pedro Exp $	*/
d1117 1
a1117 7

#ifdef FFS2
	if (fs->fs_magic == FS_UFS2_MAGIC)
		strncpy(sbp->f_fstypename, MOUNT_FFS2, MFSNAMELEN);
	else
#endif
		strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
@


1.102
log
@deregister, no change in object code
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.101 2007/03/21 17:29:32 thib Exp $	*/
d563 1
a563 3
	if (newfs->fs_magic != FS_MAGIC || (u_int)newfs->fs_bsize > MAXBSIZE ||
	    newfs->fs_bsize < sizeof(struct fs) ||
	    (u_int)newfs->fs_sbsize > SBSIZE) {
d565 1
a565 1
		return (EIO);		/* XXX needs translation */
@


1.101
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.100 2007/03/19 19:57:58 pedro Exp $	*/
d1242 2
a1243 2
	register struct fs *fs;
	register struct inode *ip;
@


1.100
log
@Also shift superblock fields in ffs_reload(), okay beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.99 2007/03/19 13:27:47 pedro Exp $	*/
d483 1
a483 1
	if (vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, fra->p))
a1147 1
		simple_unlock(&vp->v_interlock);
d1151 1
a1151 1
	if (vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, fsa->p))
@


1.99
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.98 2006/12/28 20:33:24 thib Exp $	*/
d583 1
@


1.98
log
@Zap nextgennumber, unused since LFS went up into the attic.

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.97 2006/10/20 13:01:10 pedro Exp $	*/
d72 3
d725 1
d731 1
d808 2
d957 42
d1474 2
@


1.97
log
@brelse() after failed bread(), from Christoph Egger, okay mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.96 2006/08/07 15:50:42 pedro Exp $	*/
a96 1
extern u_long nextgennumber;
@


1.96
log
@Revert last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.94 2006/06/17 16:30:58 miod Exp $	*/
d486 1
d491 1
d496 1
d500 1
d553 1
d555 2
a556 1
	if (error)
d558 2
d594 2
a595 1
		if (error)
d597 1
@


1.95
log
@obey the locking disaplince wrt to VOP_CLOSE during umounts
and mount error paths.

ok sturm@@ pedro@@
@
text
@a900 1
	vn_lock(devvp, LK_EXCLUSIVE|LK_RETRY, p);
a901 1
	VOP_UNLOCK(devvp, 0, p);
a974 1
	vn_lock(ump->um_devvp, LK_EXCLUSIVE|LK_RETRY, p);
d978 1
a978 2
	vput(ump->um_devvp);
	
@


1.94
log
@Refuse to mount a ffs fielsystems whose number of frags is not 1, 2, 4 or 8,
and remove the corresponding panics in low level code.
ok pedro@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.93 2006/05/20 16:03:46 pedro Exp $	*/
d901 1
d903 1
d977 1
d981 2
a982 1
	vrele(ump->um_devvp);
@


1.93
log
@Don't mark a mount point read-only if we are about to sync it, otherwise
stuff that relies on ffs_update() to flush an inode will fail.

Fixes PR 4997, okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.92 2006/04/19 11:55:55 pedro Exp $	*/
d635 3
@


1.92
log
@Remove unused mount list simple_lock() goo
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.91 2006/04/12 03:46:52 tedu Exp $	*/
d206 2
a207 3
			/*
			 * Flush any dirty data.
			 */
d209 2
@


1.91
log
@revert the new superblock format.  it violates the rule that new
kernels and old tools are safe.
i'm leaving in the "updated" flag, so that fsck will continue to remove
it from filesystems.  the kernel no longer attempts to upgrade
superblocks and will use the old format.
post-mortem discussions have concluded that maybe jamming ffs2 fields
into random locations in the superblock is asking for trouble, and we
need to talk about this some more.  my bad for not thinking fast enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.90 2006/04/07 11:11:38 pedro Exp $	*/
d144 1
a144 1
	simple_lock(&mountlist_slock);
a145 1
	simple_unlock(&mountlist_slock);
d152 1
@


1.90
log
@Add and use ffs_validate(), a function for sanity checking super blocks
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.89 2006/04/01 11:24:47 pedro Exp $	*/
a71 3
void ffs1_compat_read(struct fs *, struct ufsmount *, ufs2_daddr_t);
void ffs1_compat_write(struct fs *, struct ufsmount *);

a789 2
	ffs1_compat_read(fs, ump, sbloc);

a936 42
 * Auxiliary function for reading FFS1 super blocks.
 */
void
ffs1_compat_read(struct fs *fs, struct ufsmount *ump, ufs2_daddr_t sbloc)
{
	if (fs->fs_magic == FS_UFS2_MAGIC)
		return; /* UFS2 */

	if (fs->fs_ffs1_flags & FS_FLAGS_UPDATED)
		return; /* Already updated */

	fs->fs_flags = fs->fs_ffs1_flags;
	fs->fs_sblockloc = sbloc;
	fs->fs_maxbsize = fs->fs_bsize;
	fs->fs_time = fs->fs_ffs1_time;
	fs->fs_size = fs->fs_ffs1_size;
	fs->fs_dsize = fs->fs_ffs1_dsize;
	fs->fs_csaddr = fs->fs_ffs1_csaddr;
	fs->fs_cstotal.cs_ndir = fs->fs_ffs1_cstotal.cs_ndir;
	fs->fs_cstotal.cs_nbfree = fs->fs_ffs1_cstotal.cs_nbfree;
	fs->fs_cstotal.cs_nifree = fs->fs_ffs1_cstotal.cs_nifree;
	fs->fs_cstotal.cs_nffree = fs->fs_ffs1_cstotal.cs_nffree;
	fs->fs_ffs1_flags |= FS_FLAGS_UPDATED;
}

/*
 * Auxiliary function for writing FFS1 super blocks.
 */
void
ffs1_compat_write(struct fs *fs, struct ufsmount *ump)
{
	if (fs->fs_magic != FS_UFS1_MAGIC)
		return; /* UFS2 */

	fs->fs_ffs1_time = fs->fs_time;
	fs->fs_ffs1_cstotal.cs_ndir = fs->fs_cstotal.cs_ndir;
	fs->fs_ffs1_cstotal.cs_nbfree = fs->fs_cstotal.cs_nbfree;
	fs->fs_ffs1_cstotal.cs_nifree = fs->fs_cstotal.cs_nifree;
	fs->fs_ffs1_cstotal.cs_nffree = fs->fs_cstotal.cs_nffree;
}

/*
a1411 2

	ffs1_compat_write(dfs, mp);
@


1.89
log
@Mark FFS2 file systems with UM_UFS2
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.88 2006/03/31 16:24:58 pedro Exp $	*/
d70 1
d616 26
d726 2
a727 5
		if ((fs->fs_magic == FS_UFS1_MAGIC) &&
		    ((u_int)fs->fs_bsize <= MAXBSIZE) &&
		    ((u_int)fs->fs_bsize >= sizeof(struct fs)) &&
		    ((u_int)fs->fs_sbsize <= SBSIZE))
			break; /* Validate super-block */
@


1.88
log
@FFS2 dinode pool needs to be defined here too
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.87 2006/03/31 13:16:58 pedro Exp $	*/
d754 2
a755 1
	if (fs->fs_magic == FS_UFS1_MAGIC) {
d757 5
a761 1
	}
@


1.87
log
@Make ffs_statfs() tag FFS2 file systems as such
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.86 2006/03/31 12:55:04 pedro Exp $	*/
d107 3
@


1.86
log
@ffs_statfs() should not panic on FFS2 file systems
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.85 2006/03/31 12:45:01 pedro Exp $	*/
d1071 8
a1078 1
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
@


1.85
log
@Teach ffs_vget() to allocate and associate FFS2 dinodes
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.84 2006/03/31 12:19:42 pedro Exp $	*/
d1048 5
d1055 2
@


1.84
log
@Add a pool for FFS2 dinodes
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.83 2006/03/31 08:13:07 pedro Exp $	*/
d1184 3
d1258 12
a1269 3
	ip->i_din1 = pool_get(&ffs_dinode1_pool, PR_WAITOK);
	dp1 = (struct ufs1_dinode *) bp->b_data + ino_to_fsbo(fs, ino);
	*ip->i_din1 = *dp1;
@


1.83
log
@Super block changes for FFS2, thanks to all who tested.
Silent okay after almost 3 weeks, hackers@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.82 2006/03/09 13:25:02 pedro Exp $	*/
d1425 4
@


1.82
log
@- Slightly more informative error message (requested by krw@@)
- Bring back '&& !ronly' into the conditional, so these ancient file
  systems can be mounted again read-only (requested by millert@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.81 2006/03/09 13:21:12 pedro Exp $	*/
d71 3
d760 3
d910 42
d1401 3
@


1.81
log
@Better handling of ancient file systems that still have 4.2 BSD
rotational layout tables. Okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.80 2006/02/14 12:42:11 mickey Exp $	*/
d735 1
a735 1
	if (fs->fs_postblformat == FS_42POSTBLFMT) {
d738 1
a738 1
		    "please use fsck -c\n");
@


1.80
log
@if updating supablock fails w/ EROFS just procede w/ unmount thus allowing unmounting rw mounts on top of ro devices; pedro@@ ok and comments
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.79 2006/01/03 12:20:54 pedro Exp $	*/
d734 7
a740 3
	/* XXX updating 4.2 FFS superblocks trashes rotational layout tables */
	if (fs->fs_postblformat == FS_42POSTBLFMT && !ronly) {
		error = EROFS;		/* XXX what should be returned? */
d743 1
@


1.79
log
@Fix UFS2 detection by looking for the super-block at every possible
location, testing krw@@ and moritz@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.78 2005/12/28 20:48:17 pedro Exp $	*/
d924 2
a925 1
		if (error) {
@


1.78
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.77 2005/12/17 13:56:01 pedro Exp $	*/
d609 5
d625 1
d661 41
a701 10
	error = bread(devvp, (daddr_t)(SBOFF / size), SBSIZE, cred, &bp);
	if (error)
		goto out;
	fs = (struct fs *)bp->b_data;
	if (fs->fs_magic != FS_UFS1_MAGIC || (u_int)fs->fs_bsize > MAXBSIZE ||
	    fs->fs_bsize < sizeof(struct fs) ||
	    (u_int)fs->fs_sbsize > SBSIZE) {
		if (fs->fs_magic == FS_UFS2_MAGIC)
			printf("no UFS2 support\n");
		error = EFTYPE;		/* Inappropriate format */
d704 1
@


1.77
log
@Remove the 'on disk' inode (dinode) from the 'in memory' inode in UFS.
Instead of having the dinode inside the inode structure itself, we now
have just a pointer to it, and use a separate pool to allocate dinodes
as needed. Inspiration from FreeBSD, various testing for a while, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.76 2005/11/30 17:01:17 pedro Exp $	*/
d494 1
a494 1
	ip->i_effnlink = ip->i_ffs_nlink;
d1172 1
a1172 1
		ip->i_effnlink = ip->i_ffs_nlink;
d1184 1
d1189 4
a1192 4
	if (ip->i_ffs_gen == 0) {
		ip->i_ffs_gen = arc4random() & INT_MAX;
		if (ip->i_ffs_gen == 0 || ip->i_ffs_gen == -1)
			ip->i_ffs_gen = 1;		/* shouldn't happen */
d1196 1
d1201 3
a1203 3
	if (fs->fs_inodefmt < FS_44INODEFMT) {
		ip->i_ffs_uid = ip->i_din1->di_ouid;
		ip->i_ffs_gid = ip->i_din1->di_ogid;
d1207 1
d1247 1
a1247 1
	ufhp->ufid_gen = ip->i_ffs_gen;
@


1.76
log
@Use suser() to check for root privileges, okay hshoexer@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.75 2005/11/30 10:35:08 pedro Exp $	*/
d103 1
d492 1
a492 1
	ip->i_din1 = *((struct ufs1_dinode *)bp->b_data +
d1091 1
d1162 7
a1168 1
	ip->i_din1 = *((struct ufs1_dinode *)bp->b_data + ino_to_fsbo(fs, ino));
a1172 1
	brelse(bp);
d1199 4
a1202 4
	if (fs->fs_inodefmt < FS_44INODEFMT) {			/* XXX */
		ip->i_ffs_uid = ip->i_din1.di_ouid;		/* XXX */
		ip->i_ffs_gid = ip->i_din1.di_ogid;		/* XXX */
	}							/* XXX */
d1322 1
d1325 3
@


1.75
log
@No need for vfs_busy() and vfs_unbusy() to take a process pointer
anymore. Testing by jolan@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.74 2005/11/08 02:29:51 pedro Exp $	*/
d262 1
a262 1
			if (p->p_ucred->cr_uid != 0) {
d346 1
a346 1
	if (p->p_ucred->cr_uid != 0) {
@


1.74
log
@Use ANSI function declarations and deregister, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.73 2005/11/06 00:24:17 pedro Exp $	*/
d133 1
a133 1
		vfs_unbusy(mp, p);
d146 1
a146 1
	vfs_unbusy(mp, p);
@


1.73
log
@Replace obsolete comment with one that better describes reality.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.72 2005/11/05 23:24:43 pedro Exp $	*/
d105 1
a105 1
ffs_mountroot()
d157 2
a158 6
ffs_mount(mp, path, data, ndp, p)
	register struct mount *mp;
	const char *path;
	void *data;
	struct nameidata *ndp;
	struct proc *p;
d163 1
a163 1
	register struct fs *fs;
a448 1

d513 1
a513 4
ffs_reload(mountp, cred, p)
	register struct mount *mountp;
	struct ucred *cred;
	struct proc *p;
d611 1
a611 4
ffs_mountfs(devvp, mp, p)
	register struct vnode *devvp;
	struct mount *mp;
	struct proc *p;
d613 1
a613 1
	register struct ufsmount *ump;
d615 1
a615 1
	register struct fs *fs;
a830 2
 *
 * XXX - goes away some day.
d833 1
a833 2
ffs_oldfscompat(fs)
	struct fs *fs;
d863 1
a863 4
ffs_unmount(mp, mntflags, p)
	struct mount *mp;
	int mntflags;
	struct proc *p;
d865 2
a866 2
	register struct ufsmount *ump;
	register struct fs *fs;
d909 1
a909 4
ffs_flushfiles(mp, flags, p)
	register struct mount *mp;
	int flags;
	struct proc *p;
d911 1
a911 1
	register struct ufsmount *ump;
d948 1
a948 4
ffs_statfs(mp, sbp, p)
	struct mount *mp;
	register struct statfs *sbp;
	struct proc *p;
d950 2
a951 2
	register struct ufsmount *ump;
	register struct fs *fs;
a974 1

d1016 1
a1016 5
ffs_sync(mp, waitfor, cred, p)
	struct mount *mp;
	int waitfor;
	struct ucred *cred;
	struct proc *p;
a1032 1

d1086 1
a1086 4
ffs_vget(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
a1097 1

d1210 1
a1210 4
ffs_fhtovp(mp, fhp, vpp)
	register struct mount *mp;
	struct fid *fhp;
	struct vnode **vpp;
d1212 1
a1212 1
	register struct ufid *ufhp;
d1228 1
a1228 3
ffs_vptofh(vp, fhp)
	struct vnode *vp;
	struct fid *fhp;
d1230 2
a1231 2
	register struct inode *ip;
	register struct ufid *ufhp;
d1238 1
d1246 1
a1246 3
ffs_sbupdate(mp, waitfor)
	struct ufsmount *mp;
	int waitfor;
d1248 2
a1249 2
	register struct fs *dfs, *fs = mp->um_fs;
	register struct buf *bp;
d1307 1
a1307 2
ffs_init(vfsp)
	struct vfsconf *vfsp;
d1313 1
d1318 1
d1326 2
a1327 8
ffs_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
@


1.72
log
@Don't go through the mountpoint vnode list if we want to skip them all.
Based on a similar change made to NFS. Tested by many, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.71 2005/09/29 22:31:30 pedro Exp $	*/
d1037 1
a1037 1
 * Note: we are always called with the filesystem marked `MPBUSY'.
@


1.71
log
@Sync dirty data when going from read-write to read-only.
Verified against FreeBSD, closes PR 4526, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.70 2005/07/03 20:14:02 drahn Exp $	*/
d1013 1
a1013 2
	if (fsa->waitfor == MNT_LAZY ||
	    vp->v_type == VNON || 
d1071 7
a1077 1
	vfs_mount_foreach_vnode(mp, ffs_sync_vnode, &fsa);
a1078 2
	if (fsa.allerror != 0)
		allerror = fsa.allerror;
@


1.70
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.69 2005/05/22 21:12:42 pedro Exp $	*/
d205 7
@


1.69
log
@put VLOCKSWORK stuff under a single option, VFSDEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.68 2004/08/12 07:48:53 otto Exp $	*/
a56 1
#include <ufs/ufs/extattr.h>
d84 1
a84 6
	ufs_check_export,
#ifdef UFS_EXTATTR
	ufs_extattrctl,
#else
	vfs_stdextattrctl,
#endif
a760 3
#ifdef UFS_EXTATTR
	ufs_extattr_uepm_init(&ump->um_extattr);
#endif
a818 15
#ifdef UFS_EXTATTR
#ifdef UFS_EXTATTR_AUTOSTART
	/*
	 *
	 * Auto-starting does the following:
	 *	- check for /.attribute in the fs, and extattr_start if so
	 *	- for each file in .attribute, enable that file with
	 *	  an attribute of the same name.
	 * Not clear how to report errors -- probably eat them.
	 * This would all happen while the file system was busy/not
	 * available, so would effectively be "atomic".
	 */
	(void) ufs_extattr_autostart(mp, p);
#endif /* !UFS_EXTATTR_AUTOSTART */
#endif /* !UFS_EXTATTR */
a884 9
#ifdef UFS_EXTATTR
	if ((error = ufs_extattr_stop(mp, p))) {
		if (error != EOPNOTSUPP)
			printf("ffs_unmount: ufs_extattr_stop returned %d\n",
			    error);
	} else {
		ufs_extattr_uepm_destroy(&ump->um_extattr);
	}
#endif
@


1.68
log
@Prevent a panic by validating the super block size as recorded in the
superblock; make the block size check also catch negative values.
ok miller@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.67 2004/07/14 18:48:43 pedro Exp $	*/
d1163 1
a1163 1
#ifdef LOCKDEBUG
@


1.67
log
@trailing '\n' in printf, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.66 2004/06/21 23:50:38 tholo Exp $	*/
d554 3
a556 2
	if (newfs->fs_magic != FS_MAGIC || newfs->fs_bsize > MAXBSIZE ||
	    newfs->fs_bsize < sizeof(struct fs)) {
d668 3
a670 2
	if (fs->fs_magic != FS_UFS1_MAGIC || fs->fs_bsize > MAXBSIZE ||
	    fs->fs_bsize < sizeof(struct fs)) {
@


1.66
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.65 2004/06/04 08:06:05 tedu Exp $	*/
d125 1
a125 1
		printf("ffs_mountroot: can't setup bdevvp's");
@


1.65
log
@rootvp is already externed in systm.h, no need for a local extern
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.64 2004/01/25 20:02:52 tedu Exp $	*/
d1343 1
a1343 1
	fs->fs_time = time.tv_sec;
@


1.64
log
@vref device vnodes early, so we don't get mismatched vrele calls.
problem found, fix tested naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.63 2004/01/20 03:44:06 tedu Exp $	*/
a112 1
	extern struct vnode *rootvp;
a631 1
	extern struct vnode *rootvp;
@


1.63
log
@some pieces of ufs2.  help testing otto sturm
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.62 2004/01/07 20:47:47 tedu Exp $	*/
d1171 1
a1232 4
	/*
	 * Finish inode initialization now that aliasing has been resolved.
	 */
	VREF(ip->i_devvp);
@


1.62
log
@sysctls for dirhash variables.  with a hint from miod.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.61 2003/10/17 15:08:11 mpech Exp $	*/
d669 1
a669 1
	if (fs->fs_magic != FS_MAGIC || fs->fs_bsize > MAXBSIZE ||
d671 2
d711 1
a711 1
	bzero((caddr_t)ump, sizeof *ump);
d714 3
d1170 1
a1234 1
	ip->i_devvp = ump->um_devvp;
@


1.61
log
@Be sure i_ffs_gen is always positive.

millert@@, beck@@, tedu@@, deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.60 2003/10/04 18:47:08 mickey Exp $	*/
d63 1
d1444 11
@


1.60
log
@vrele swap and/or root vnode should we fail during mountroot; found by mpech@@ and tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.59 2003/08/25 23:26:55 tedu Exp $	*/
d1235 1
a1235 1
		ip->i_ffs_gen = arc4random();
@


1.59
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
few other little cleanups.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.58 2003/08/14 07:46:40 mickey Exp $	*/
d122 1
d126 2
d131 3
a133 1
	if ((error = vfs_rootmountalloc("ffs", "root_device", &mp)) != 0)
d135 2
d141 2
@


1.58
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.57 2003/07/10 22:32:20 tedu Exp $	*/
d486 1
a486 1
	ip->i_din.ffs_din = *((struct dinode *)bp->b_data +
d1199 1
a1199 1
	ip->i_din.ffs_din = *((struct dinode *)bp->b_data + ino_to_fsbo(fs, ino));
d1237 2
a1238 2
		ip->i_ffs_uid = ip->i_din.ffs_din.di_ouid;	/* XXX */
		ip->i_ffs_gid = ip->i_din.ffs_din.di_ogid;	/* XXX */
@


1.57
log
@in statfs, cast disk size to int64_t to prevent overflow on large disks.
from Peter Galbavy
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.56 2003/06/10 17:51:02 millert Exp $	*/
d71 1
a71 1
struct vfsops ffs_vfsops = {
@


1.56
log
@o make mount(2) return EROFS, not EPERM if ffs is dirty
o document EROFS in man page (2 possible causes)
o recognize EROFS in mount_ffs and try to give a reasonable error message
deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.55 2003/06/02 23:28:23 millert Exp $	*/
d996 1
a996 1
	sbp->f_bavail = sbp->f_bfree - fs->fs_dsize * fs->fs_minfree / 100;
@


1.55
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.54 2002/08/01 16:41:33 millert Exp $	*/
d287 1
a287 1
					error = EPERM;
d689 1
a689 1
			error = EPERM;
@


1.54
log
@Limit max file size based on PAGE_SIZE.  Even though ffs can handle
files up to 16TB, we do limit the max file to 2^31 pages to prevent
overflow of a 32-bit unsigned int.  The buffer cache has its own
checks but a little added paranoia never hurts.  Adapted from a patch
in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.53 2002/04/23 18:54:12 espie Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.53
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.52 2002/03/14 01:27:14 millert Exp $	*/
d791 7
d799 1
a799 1
	maxfilesize = (u_int64_t)0x80000000 * fs->fs_bsize - 1;	/* XXX */
@


1.52
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.51 2002/02/22 20:37:46 drahn Exp $	*/
d312 2
a313 1
			error = vfs_export(mp, &ump->um_export, &args.export);
@


1.51
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.50 2002/01/25 02:30:27 millert Exp $	*/
d71 1
a71 1
int ffs_sbupdate __P((struct ufsmount *, int));
@


1.50
log
@Move softdep sysctls from debug to vfs.ffs; art@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.49 2002/01/23 00:39:48 art Exp $	*/
d61 1
d88 6
a93 1
	ufs_check_export
d755 4
d809 15
d890 9
@


1.49
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.48 2001/12/19 08:58:07 art Exp $	*/
d1347 6
d1370 26
@


1.48
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.45 2001/11/21 22:21:48 csapuntz Exp $	*/
d1328 1
a1328 1
	    0, pool_page_alloc_nointr, pool_page_free_nointr, M_FFSNODE);
@


1.47
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.46 2001/11/27 05:27:12 art Exp $	*/
a98 5
struct genfs_ops ffs_genfsops = {
	ffs_gop_size,
	ffs_gop_alloc,
};

a739 2
	mp->mnt_fs_bshift = fs->fs_bshift;
	mp->mnt_dev_bshift = DEV_BSHIFT;
a744 1
	ump->um_lognindir = ffs(fs->fs_nindir) - 1;
a1121 1
	LIST_INIT(&ip->i_pcbufhd);
a1180 2

	genfs_node_init(vp, &ffs_genfsops);
a1201 1
	uvm_vnp_setsize(vp, ip->i_ffs_size);
@


1.47.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.50 2002/01/25 02:30:27 millert Exp $	*/
d1340 1
a1340 1
	    &pool_allocator_nointr);
a1358 6
#ifdef FFS_SOFTUPDATES
	extern int max_softdeps, tickdelay, stat_worklist_push;
	extern int stat_blk_limit_push, stat_ino_limit_push, stat_blk_limit_hit;
	extern int stat_ino_limit_hit, stat_sync_limit_hit, stat_indir_blk_ptrs;
	extern int stat_inode_bitmap, stat_direct_blk_ptrs, stat_dir_entry;
#endif
a1375 26
#ifdef FFS_SOFTUPDATES
	case FFS_MAX_SOFTDEPS:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &max_softdeps));
	case FFS_SD_TICKDELAY:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &tickdelay));
	case FFS_SD_WORKLIST_PUSH:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_worklist_push));
	case FFS_SD_BLK_LIMIT_PUSH:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_blk_limit_push));
	case FFS_SD_INO_LIMIT_PUSH:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_ino_limit_push));
	case FFS_SD_BLK_LIMIT_HIT:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_blk_limit_hit));
	case FFS_SD_INO_LIMIT_HIT:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_ino_limit_hit));
	case FFS_SD_SYNC_LIMIT_HIT:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_sync_limit_hit));
	case FFS_SD_INDIR_BLK_PTRS:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_indir_blk_ptrs));
	case FFS_SD_INODE_BITMAP:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_inode_bitmap));
	case FFS_SD_DIRECT_BLK_PTRS:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_direct_blk_ptrs));
	case FFS_SD_DIR_ENTRY:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_dir_entry));
#endif
@


1.47.2.2
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.47.2.1 2002/01/31 22:55:50 niklas Exp $	*/
a101 1
	genfs_gop_write
@


1.47.2.3
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.47.2.2 2002/02/02 03:28:26 art Exp $	*/
a60 1
#include <ufs/ufs/extattr.h>
d70 1
a70 1
int ffs_sbupdate(struct ufsmount *, int);
d87 1
a87 6
	ufs_check_export,
#ifdef UFS_EXTATTR
	ufs_extattrctl,
#else
	vfs_stdextattrctl,
#endif
d312 1
a312 2
			error = vfs_export(mp, &ump->um_export, 
			    &args.export_info);
a757 4
#ifdef UFS_EXTATTR
	ufs_extattr_uepm_init(&ump->um_extattr);
#endif

a807 15
#ifdef UFS_EXTATTR
#ifdef UFS_EXTATTR_AUTOSTART
	/*
	 *
	 * Auto-starting does the following:
	 *	- check for /.attribute in the fs, and extattr_start if so
	 *	- for each file in .attribute, enable that file with
	 *	  an attribute of the same name.
	 * Not clear how to report errors -- probably eat them.
	 * This would all happen while the file system was busy/not
	 * available, so would effectively be "atomic".
	 */
	(void) ufs_extattr_autostart(mp, p);
#endif /* !UFS_EXTATTR_AUTOSTART */
#endif /* !UFS_EXTATTR */
a873 9
#ifdef UFS_EXTATTR
	if ((error = ufs_extattr_stop(mp, p))) {
		if (error != EOPNOTSUPP)
			printf("ffs_unmount: ufs_extattr_stop returned %d\n",
			    error);
	} else {
		ufs_extattr_uepm_destroy(&ump->um_extattr);
	}
#endif
@


1.47.2.4
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.47.2.3 2002/06/11 03:32:50 art Exp $	*/
a799 7
	/*
	 * XXX
	 * Limit max file size.  Even though ffs can handle files up to 16TB,
	 * we do limit the max file to 2^31 pages to prevent overflow of
	 * a 32-bit unsigned int.  The buffer cache has its own checks but
	 * a little added paranoia never hurts.
	 */
d801 1
a801 1
	maxfilesize = (u_int64_t)0x80000000 * MIN(PAGE_SIZE, fs->fs_bsize) - 1;
@


1.47.2.5
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.47.2.4 2002/10/29 00:36:50 art Exp $	*/
a648 1

@


1.47.2.6
log
@use vnode lock in place of inode lock, switch to genfs_lock
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.47.2.5 2002/11/04 18:02:32 art Exp $	*/
d1168 1
a1168 1
	vp->v_vnlock = &vp->v_lock;
@


1.46
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.45 2001/11/21 22:21:48 csapuntz Exp $	*/
d99 5
d1190 2
@


1.45
log
@Use vfs_mount_foreach_vnode
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.44 2001/11/21 21:23:56 csapuntz Exp $	*/
d740 2
d747 1
d1125 1
d1206 1
@


1.44
log
@Don't use #define QUOTA - use stub file instead

Pass over the quota code in ufs/. Make code paths clearer. Clean up some names.
Move all code that manipulates quotas directly into ufs_quota.c

Use vfs_mount_foreach_vnode to traverse list of vnodes in mountpoint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.43 2001/06/23 02:07:55 csapuntz Exp $	*/
d71 2
d440 51
d510 1
a510 2
	register struct vnode *vp, *nvp, *devvp;
	struct inode *ip;
a511 1
	struct buf *bp;
d516 2
d591 4
a594 7
loop:
	simple_lock(&mntvnode_slock);
	for (vp = LIST_FIRST(&mountp->mnt_vnodelist); vp != NULL; vp = nvp) {
		if (vp->v_mount != mountp) {
			simple_unlock(&mntvnode_slock);
			goto loop;
		}
d596 1
a596 6
		nvp = LIST_NEXT(vp, v_mntvnodes);
		/*
		 * Step 4: invalidate all inactive vnodes.
		 */
		if (vrecycle(vp, &mntvnode_slock, p))
			goto loop;
d598 1
a598 28
		/*
		 * Step 5: invalidate all cached file data.
		 */
		simple_lock(&vp->v_interlock);
		simple_unlock(&mntvnode_slock);
		if (vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, p))
			goto loop;
		if (vinvalbuf(vp, 0, cred, p, 0, 0))
			panic("ffs_reload: dirty2");
		/*
		 * Step 6: re-read inode data for all active vnodes.
		 */
		ip = VTOI(vp);
		error = bread(devvp, fsbtodb(fs, ino_to_fsba(fs, ip->i_number)),
			      (int)fs->fs_bsize, NOCRED, &bp);
		if (error) {
			vput(vp);
			return (error);
		}
		ip->i_din.ffs_din = *((struct dinode *)bp->b_data +
		    ino_to_fsbo(fs, ip->i_number));
		ip->i_effnlink = ip->i_ffs_nlink;
		brelse(bp);
		vput(vp);
		simple_lock(&mntvnode_slock);
	}
	simple_unlock(&mntvnode_slock);
	return (0);
d971 35
d1020 2
a1021 4
	register struct vnode *vp, *nvp;
	register struct inode *ip;
	register struct ufsmount *ump = VFSTOUFS(mp);
	register struct fs *fs;
d1023 1
d1036 1
d1040 6
a1045 9
	simple_lock(&mntvnode_slock);
loop:
	for (vp = LIST_FIRST(&mp->mnt_vnodelist); vp != NULL; vp = nvp) {
		/*
		 * If the vnode that we are about to sync is no longer
		 * associated with this mount point, start over.
		 */
		if (vp->v_mount != mp)
			goto loop;
d1047 2
a1048 25
		simple_lock(&vp->v_interlock);
		nvp = LIST_NEXT(vp, v_mntvnodes);
		ip = VTOI(vp);
		if (vp->v_type == VNON || ((ip->i_flag &
		    (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0 &&
		    LIST_EMPTY(&vp->v_dirtyblkhd)) ||
		    waitfor == MNT_LAZY) {
			simple_unlock(&vp->v_interlock);
			continue;
		}
		simple_unlock(&mntvnode_slock);
		error = vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, p);
		if (error) {
			simple_lock(&mntvnode_slock);
			if (error == ENOENT)
				goto loop;
			continue;
		}
		if ((error = VOP_FSYNC(vp, cred, waitfor, p)))
			allerror = error;
		VOP_UNLOCK(vp, 0, p);
		vrele(vp);
		simple_lock(&mntvnode_slock);
	}
	simple_unlock(&mntvnode_slock);
d1056 1
a1056 2
		if (count) {
			simple_lock(&mntvnode_slock);
a1057 1
		}
@


1.43
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.42 2001/05/15 23:44:41 ho Exp $	*/
a889 1
#ifdef QUOTA
d904 1
a904 1
#endif
a1041 1
#ifdef QUOTA
a1042 1
#endif
a1098 8
#ifdef QUOTA
	{
		int i;

		for (i = 0; i < MAXQUOTAS; i++)
			ip->i_dquot[i] = NODQUOT;
	}
#endif
d1106 1
a1106 1

a1343 1

@


1.42
log
@Correct memory type for free(). (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.41 2001/04/22 21:33:46 gluk Exp $	*/
d88 9
d1100 2
@


1.41
log
@Free fs->fs_contigdirs array only on successful rw->ro update. This
fixes "duplicated free" panic. Update file system from read-write to
read-only freed memory but may fail later if file system busy.

deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.40 2001/04/19 16:22:17 gluk Exp $	*/
d411 1
a411 1
				free(fs->fs_contigdirs, M_WAITOK);
@


1.40
log
@Cleanup dirpref and synhronize superblock with freebsd.
From FreeBSD with little changes.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.39 2001/04/15 23:46:29 gluk Exp $	*/
a196 1
			free(fs->fs_contigdirs, M_WAITOK);
d410 2
d493 1
@


1.39
log
@Avoid panic on unmounting read-only fs, which previously use softupdates.
This problem occur only on kernels without soft-updates support.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.38 2001/04/13 02:39:05 gluk Exp $	*/
d810 4
@


1.38
log
@Fix overflow in superblock. From FreeBSD.

FreeBSD's log:
> The ffs superblock includes a 128-byte region for use by temporary
> in-core pointers to summary information. An array in this region
> (fs_csp) could overflow on filesystems with a very large number of
> cylinder groups (~16000 on i386 with 8k blocks). When this happens,
> other fields in the superblock get corrupted, and fsck refuses to
> check the filesystem.
>
> Solve this problem by replacing the fs_csp array in 'struct fs'
> with a single pointer, and add padding to keep the length of the
> 128-byte region fixed. Update the kernel and userland utilities
> to use just this single pointer.
>
> With this change, the kernel no longer makes use of the superblock
> fields 'fs_csshift' and 'fs_csmask'. Add a comment to newfs/mkfs.c
> to indicate that these fields must be calculated for compatibility
> with older kernels.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.37 2001/04/12 17:16:52 csapuntz Exp $	*/
d832 1
a832 1
	if (fs->fs_flags & FS_DOSOFTDEP)
@


1.37
log
@

Allow kernels with just MFS and no FFS. Fixes PR#323.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.36 2001/04/06 20:43:31 gluk Exp $	*/
d449 1
a449 1
	struct csum *space;
d490 1
a490 1
	bcopy(&fs->fs_csp[0], &newfs->fs_csp[0], sizeof(fs->fs_csp));
d503 1
a503 1
	space = fs->fs_csp[0];
d512 2
a513 1
		bcopy(bp->b_data, fs->fs_csp[fragstoblks(fs, i)], (u_int)size);
d586 1
a586 1
	caddr_t base, space;
d681 2
a682 1
	base = space = malloc((u_long)size, M_UFSMNT, M_WAITOK);
d690 1
a690 1
			free(base, M_UFSMNT);
a693 1
		fs->fs_csp[fragstoblks(fs, i)] = (struct csum *)space;
d758 1
a758 1
			free(base, M_UFSMNT);
d854 1
a854 1
	free(fs->fs_csp[0], M_UFSMNT);
d1239 1
a1239 1
	space = (caddr_t)fs->fs_csp[0];
@


1.36
log
@Replace FFS directory preference algorithm(dirpref) by new one.
It allocates directory inode in the same cylinder group as a parent
directory in. This speedup file/directory intensive operations on
a big file systems in times.

Don't forget to recompile fsck_ffs with updated fs.h or you will get
"VALUES IN SUPER BLOCK DISAGREE WITH THOSE IN FIRST ALTERNATE" at
the next boot. In any case you can ignore this error safely.

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.35 2001/04/04 20:19:04 gluk Exp $	*/
d1290 1
d1292 3
d1296 1
a1296 1
		0, pool_page_alloc_nointr, pool_page_free_nointr, M_FFSNODE);
@


1.35
log
@Add "softdep" option to mount. Update from rw/async to softdep
and otherwise are disabled.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.34 2001/03/22 00:20:54 art Exp $	*/
d197 1
d286 3
d722 8
d758 1
d845 1
@


1.34
log
@Sigh. PR_WAITOK, not M_WAITOK
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.33 2001/03/22 00:11:36 art Exp $	*/
d160 17
d192 1
a192 1
			if (mp->mnt_flag & MNT_SOFTDEP)
d194 2
a195 1
			else
d199 34
d253 13
a287 11
		/*
		 * Soft updates is incompatible with "async",
		 * so if we are doing softupdates stop the user
		 * from setting the async flag in an update.
		 * Softdep_mount() clears it in an initial mount
		 * or ro->rw remount.
		 */
		if (mp->mnt_flag & MNT_SOFTDEP) {
			mp->mnt_flag &= ~MNT_ASYNC;
		}

a399 2
	if ((mp->mnt_flag & MNT_SOFTDEP))
		mp->mnt_flag &= ~MNT_ASYNC;
a406 1
			ffs_sbupdate(ump, MNT_WAIT);
d408 7
a512 2
	else
		mountp->mnt_flag &= ~MNT_SOFTDEP;
d631 13
a671 4
	if (ronly == 0) {
		fs->fs_fmod = 1;
		fs->fs_clean = 0;
	}
d748 1
d750 4
a814 7
	if (mp->mnt_flag & MNT_SOFTDEP) {
		if ((error = softdep_flushfiles(mp, flags, p)) != 0)
			return (error);
	} else {
		if ((error = ffs_flushfiles(mp, flags, p)) != 0)
			return (error);
	}
d818 7
d954 1
d1152 4
a1155 4
	if (fs->fs_inodefmt < FS_44INODEFMT) {		/* XXX */
		ip->i_ffs_uid = ip->i_din.ffs_din.di_ouid;		/* XXX */
		ip->i_ffs_gid = ip->i_din.ffs_din.di_ogid;		/* XXX */
	}						/* XXX */
@


1.33
log
@Change the ffs inode allocation from using malloc to pool.
Saves approx. 256k memory on a GENERIC i386 and moves 670k out of kmem_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.32 2001/03/14 18:46:18 gluk Exp $	*/
d991 1
a991 1
	ip = pool_get(&ffs_ino_pool, M_WAITOK);
@


1.32
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.31 2001/03/13 18:17:25 gluk Exp $	*/
d55 1
d94 2
d973 1
a973 1
	int type, error;
d990 2
a991 2
	type = ump->um_devvp->v_tag == VT_MFS ? M_MFSNODE : M_FFSNODE; /* XXX */
	MALLOC(ip, struct inode *, sizeof(struct inode), type, M_WAITOK);
d1205 3
@


1.31
log
@correct softdep integration error, add missed lock;
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.30 2001/02/21 23:24:31 csapuntz Exp $	*/
d102 1
a102 1
	
d106 1
a106 1
	if ((error = bdevvp(swapdev, &swapdev_vp)) || 
d117 3
a119 3
 		free(mp, M_MOUNT);
 		return (error);
 	}
d123 2
a124 2
 	ump = VFSTOUFS(mp);
 	fs = ump->um_fs;
d126 1
a126 1
 	(void)ffs_statfs(mp, &mp->mnt_stat, p);
d128 2
a129 2
 	inittodr(fs->fs_time);
 	return (0);
d178 1
a178 1
		if (!error && (mp->mnt_flag & MNT_RELOAD)) 
d191 1
a191 1
						 p->p_ucred, p);
d197 3
a199 3
                        if (fs->fs_clean == 0) {
                                if (mp->mnt_flag & MNT_FORCE) {
                                        printf(
d201 3
a203 3
                                            fs->fs_fsmnt);
                                } else {
                                        printf(
d205 5
a209 5
                                            fs->fs_fsmnt);
                                        error = EPERM;
                                        goto error_1;
                                }
                        }
d220 10
a229 10
                /*
                 * Soft updates is incompatible with "async",
                 * so if we are doing softupdates stop the user
                 * from setting the async flag in an update.
                 * Softdep_mount() clears it in an initial mount 
                 * or ro->rw remount.
                 */
                if (mp->mnt_flag & MNT_SOFTDEP) {
                        mp->mnt_flag &= ~MNT_ASYNC;
                }
d256 1
a256 1
	
d273 1
a273 1
		if (error) 
d277 19
a295 21
        if (mp->mnt_flag & MNT_UPDATE) {
                /*
                 ********************
                 * UPDATE
                 * If it's not the same vnode, or at least the same device
                 * then it's not correct.
                 ********************
                 */

                if (devvp != ump->um_devvp) {
                        if (devvp->v_rdev == ump->um_devvp->v_rdev) {
                                vrele(devvp);
                        } else {
                                error = EINVAL;   /* needs translation */
                        }
                } else
                        vrele(devvp);
                /*
                 * Update device name only on success
                 */
                if (!error) {
d299 1
a299 1
                        copyinstr(args.fspec,
d303 1
a303 1
                        bzero(mp->mnt_stat.f_mntfromname + size,
d307 19
a325 19
                /*
                 * Since this is a new mount, we want the names for
                 * the device and the mount point copied in.  If an
                 * error occurs,  the mountpoint is discarded by the
                 * upper level code.
                 */
                /* Save "last mounted on" info for mount point (NULL pad)*/
                copyinstr(path,                           /* mount point*/
			  mp->mnt_stat.f_mntonname,       /* save area*/
			  MNAMELEN - 1,                   /* max size*/
			  &size);                         /* real size*/
                bzero(mp->mnt_stat.f_mntonname + size, MNAMELEN - size);

                /* Save "mounted from" info for mount point (NULL pad)*/
                copyinstr(args.fspec,                     /* device name*/
                          mp->mnt_stat.f_mntfromname,     /* save area*/
			  MNAMELEN - 1,                   /* max size*/
			  &size);                         /* real size*/
                bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
d327 1
a327 1
                error = ffs_mountfs(devvp, mp, p);
d332 7
a338 7
	
        /*
         * Initialize FS stat information in mount struct; uses both
         * mp->mnt_stat.f_mntonname and mp->mnt_stat.f_mntfromname
         *
         * This code is common to root and non-root mounts
         */
d340 1
a340 1
        (void)VFS_STATFS(mp, &mp->mnt_stat, p);
d345 10
a354 10
        if (path && (mp->mnt_flag & MNT_UPDATE)) {
                /* Update clean flag after changing read-onlyness. */
                fs = ump->um_fs;
                if (ronly != fs->fs_ronly) {
                        fs->fs_ronly = ronly;
                        fs->fs_clean = ronly &&
                            (fs->fs_flags & FS_UNCLEAN) == 0 ? 1 : 0;
                        ffs_sbupdate(ump, MNT_WAIT);
                }
        }
d357 1
a357 1
error_2:        /* error with devvp held */
d359 2
a360 2
error_1:        /* no state to back out */
        return (error);
d420 1
a420 1
	/* 
d465 1
a465 1
	for (vp = mountp->mnt_vnodelist.lh_first; vp != NULL; vp = nvp) {
d471 1
a471 1
		nvp = vp->v_mntvnodes.le_next;
d483 1
a483 1
		if (vget(vp, LK_EXCLUSIVE  | LK_INTERLOCK, p))
d839 1
a839 1
	sbp->f_files =  fs->fs_ncg * fs->fs_ipg - ROOTINO;
d877 1
a877 1
	if (fs->fs_fmod != 0  && fs->fs_ronly != 0) {
d886 1
a886 3
	for (vp = mp->mnt_vnodelist.lh_first;
	     vp != NULL;
	     vp = nvp) {
d895 1
a895 1
		nvp = vp->v_mntvnodes.le_next;
d898 2
a899 2
		     (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0 &&
		     vp->v_dirtyblkhd.lh_first == NULL) || 
d931 8
a938 8
        if (waitfor != MNT_LAZY) {
                if (ump->um_mountp->mnt_flag & MNT_SOFTDEP)
                        waitfor = MNT_NOWAIT;
                vn_lock(ump->um_devvp, LK_EXCLUSIVE | LK_RETRY, p);
                if ((error = VOP_FSYNC(ump->um_devvp, cred, waitfor, p)) != 0)
                        allerror = error;
                VOP_UNLOCK(ump->um_devvp, 0, p);
        }
d943 1
a943 1
         * Write back modified superblock.
d1013 4
a1016 2
		/* VOP_INACTIVE will treat this as a stale file
		   and recycle it quickly */
d1025 1
a1025 1
	
d1156 1
a1156 1
		    size, 0, 0);
d1173 1
a1173 1
	    (int)fs->fs_sbsize, 0, 0);
@


1.30
log
@

Latest soft updates from FreeBSD/Kirk McKusick

Snapshot-related code has been commented out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.29 2001/02/20 01:50:12 assar Exp $	*/
d927 1
a927 2
		if ((error == softdep_flushworklist(ump->um_mountp, &count, p))
		    != 0)
d929 3
a931 1
		if (count)
d933 1
@


1.29
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.28 2000/02/07 04:57:18 assar Exp $	*/
d871 1
a871 1
	int error, allerror = 0;
d926 7
@


1.28
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.27 2000/01/14 19:17:56 art Exp $	*/
d141 1
a141 1
	caddr_t data;
d154 1
a154 1
	error = copyin(data, (caddr_t)&args, sizeof (struct ufs_args));
@


1.28.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.39 2001/04/15 23:46:29 gluk Exp $	*/
a54 1
#include <sys/pool.h>
a92 2
struct pool ffs_ino_pool;

d102 1
a102 1

d106 1
a106 1
	if ((error = bdevvp(swapdev, &swapdev_vp)) ||
d117 3
a119 3
		free(mp, M_MOUNT);
		return (error);
	}
d123 2
a124 2
	ump = VFSTOUFS(mp);
	fs = ump->um_fs;
d126 1
a126 1
	(void)ffs_statfs(mp, &mp->mnt_stat, p);
d128 2
a129 2
	inittodr(fs->fs_time);
	return (0);
d141 1
a141 1
	void *data;
d154 1
a154 1
	error = copyin(data, &args, sizeof (struct ufs_args));
a156 17

#ifndef FFS_SOFTUPDATES
	if (mp->mnt_flag & MNT_SOFTDEP) {
		printf("WARNING: soft updates isn't compiled in\n");
		mp->mnt_flag &= ~MNT_SOFTDEP;
	}
#endif

	/*
	 * Soft updates is incompatible with "async",
	 * so if we are doing softupdates stop the user
	 * from setting the async flag.
	 */
	if ((mp->mnt_flag & (MNT_SOFTDEP | MNT_ASYNC)) ==
	    (MNT_SOFTDEP | MNT_ASYNC)) {
		return (EINVAL);
	}
d172 1
a172 1
			if (fs->fs_flags & FS_DOSOFTDEP) {
d174 1
a174 2
				mp->mnt_flag &= ~MNT_SOFTDEP;
			} else
a175 1
			free(fs->fs_contigdirs, M_WAITOK);
d178 1
a178 35

		/*
		 * Flush soft dependencies if disabling it via an update
		 * mount. This may leave some items to be processed,
		 * so don't do this yet XXX.
		 */
		if ((fs->fs_flags & FS_DOSOFTDEP) &&
		    !(mp->mnt_flag & MNT_SOFTDEP) &&
		    !(mp->mnt_flag & MNT_RDONLY) && fs->fs_ronly == 0) {
#if 0
			flags = WRITECLOSE;
			if (mp->mnt_flag & MNT_FORCE)
				flags |= FORCECLOSE;
			error = softdep_flushfiles(mp, flags, p);
#elif FFS_SOFTUPDATES
			mp->mnt_flag |= MNT_SOFTDEP;
#endif
		}
		/*
		 * When upgrading to a softdep mount, we must first flush
		 * all vnodes. (not done yet -- see above)
		 */
		if (!(fs->fs_flags & FS_DOSOFTDEP) &&
		    (mp->mnt_flag & MNT_SOFTDEP) && fs->fs_ronly == 0) {
#if 0
			flags = WRITECLOSE;
			if (mp->mnt_flag & MNT_FORCE)
				flags |= FORCECLOSE;
			error = ffs_flushfiles(mp, flags, p);
#else
			mp->mnt_flag &= ~MNT_SOFTDEP;
#endif
		}

		if (!error && (mp->mnt_flag & MNT_RELOAD))
d191 1
a191 1
						   p->p_ucred, p);
d197 3
a199 10
			if (fs->fs_clean == 0) {
#if 0
				/*
				 * It is safe mount unclean file system
				 * if it was previously mounted with softdep
				 * but we may loss space and must
				 * sometimes run fsck manually.
				 */
				if (fs->fs_flags & FS_DOSOFTDEP)
					printf(
d201 3
a203 9
					    fs->fs_fsmnt);
				else
#endif
				if (mp->mnt_flag & MNT_FORCE) {
					printf(
"WARNING: %s was not properly unmounted\n",
					    fs->fs_fsmnt);
				} else {
					printf(
d205 5
a209 5
					    fs->fs_fsmnt);
					error = EPERM;
					goto error_1;
				}
			}
a216 3
			fs->fs_contigdirs=(u_int8_t*)malloc((u_long)fs->fs_ncg,
							    M_UFSMNT, M_WAITOK);
			bzero(fs->fs_contigdirs, fs->fs_ncg);
d220 11
d256 1
a256 1

d273 1
a273 1
		if (error)
d277 21
a297 19
	if (mp->mnt_flag & MNT_UPDATE) {
		/*
		 * UPDATE
		 * If it's not the same vnode, or at least the same device
		 * then it's not correct.
		 */

		if (devvp != ump->um_devvp) {
			if (devvp->v_rdev == ump->um_devvp->v_rdev) {
				vrele(devvp);
			} else {
				error = EINVAL;	/* needs translation */
			}
		} else
			vrele(devvp);
		/*
		 * Update device name only on success
		 */
		if (!error) {
d301 1
a301 1
			copyinstr(args.fspec,
d305 1
a305 1
			bzero(mp->mnt_stat.f_mntfromname + size,
d309 19
a327 19
		/*
		 * Since this is a new mount, we want the names for
		 * the device and the mount point copied in.  If an
		 * error occurs,  the mountpoint is discarded by the
		 * upper level code.
		 */
		/* Save "last mounted on" info for mount point (NULL pad)*/
		copyinstr(path,				/* mount point*/
			  mp->mnt_stat.f_mntonname,	/* save area*/
			  MNAMELEN - 1,			/* max size*/
			  &size);			/* real size*/
		bzero(mp->mnt_stat.f_mntonname + size, MNAMELEN - size);

		/* Save "mounted from" info for mount point (NULL pad)*/
		copyinstr(args.fspec,			/* device name*/
			  mp->mnt_stat.f_mntfromname,	/* save area*/
			  MNAMELEN - 1,			/* max size*/
			  &size);			/* real size*/
		bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
d329 1
a329 1
		error = ffs_mountfs(devvp, mp, p);
d334 7
a340 7

	/*
	 * Initialize FS stat information in mount struct; uses both
	 * mp->mnt_stat.f_mntonname and mp->mnt_stat.f_mntfromname
	 *
	 * This code is common to root and non-root mounts
	 */
d342 1
a342 1
	(void)VFS_STATFS(mp, &mp->mnt_stat, p);
d345 12
a356 16
	if (path && (mp->mnt_flag & MNT_UPDATE)) {
		/* Update clean flag after changing read-onlyness. */
		fs = ump->um_fs;
		if (ronly != fs->fs_ronly) {
			fs->fs_ronly = ronly;
			fs->fs_clean = ronly &&
			    (fs->fs_flags & FS_UNCLEAN) == 0 ? 1 : 0;
		}
		if (!ronly) {
			if (mp->mnt_flag & MNT_SOFTDEP)
				fs->fs_flags |= FS_DOSOFTDEP;
			else
				fs->fs_flags &= ~FS_DOSOFTDEP;
		}
		ffs_sbupdate(ump, MNT_WAIT);
	}
d359 1
a359 1
error_2:	/* error with devvp held */
d361 2
a362 2
error_1:	/* no state to back out */
	return (error);
d386 1
a386 1
	caddr_t space;
d422 1
a422 1
	/*
d427 1
a427 1
	newfs->fs_csp = fs->fs_csp;
d440 1
a440 1
	space = (caddr_t)fs->fs_csp;
d449 1
a449 2
		bcopy(bp->b_data, space, (u_int)size);
		space += size;
d454 2
d467 1
a467 1
	for (vp = LIST_FIRST(&mountp->mnt_vnodelist); vp != NULL; vp = nvp) {
d473 1
a473 1
		nvp = LIST_NEXT(vp, v_mntvnodes);
d485 1
a485 1
		if (vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, p))
d524 1
a524 1
	caddr_t space;
a573 13
#if 0
		/*
		 * It is safe mount unclean file system
		 * if it was previously mounted with softdep
		 * but we may loss space and must
		 * sometimes run fsck manually.
		 */
		if (fs->fs_flags & FS_DOSOFTDEP)
			printf(
"WARNING: %s was not properly unmounted\n",
			    fs->fs_fsmnt);
		else
#endif
d602 4
d610 1
a610 2
	space = malloc((u_long)size, M_UFSMNT, M_WAITOK);
	fs->fs_csp = (struct csum *)space;
d618 1
a618 1
			free(fs->fs_csp, M_UFSMNT);
d622 1
a651 8
	if (ronly)
		fs->fs_contigdirs = NULL;
	else {
		fs->fs_contigdirs = (u_int8_t*)malloc((u_long)fs->fs_ncg,
						      M_UFSMNT, M_WAITOK);
		bzero(fs->fs_contigdirs, fs->fs_ncg);
	}

d679 1
a679 2
			free(fs->fs_csp, M_UFSMNT);
			free(fs->fs_contigdirs, M_UFSMNT);
a681 1
		fs->fs_fmod = 1;
a682 4
		if (mp->mnt_flag & MNT_SOFTDEP)
			fs->fs_flags |= FS_DOSOFTDEP;
		else
			fs->fs_flags &= ~FS_DOSOFTDEP;
d744 7
a753 7
	if (mp->mnt_flag & MNT_SOFTDEP)
		error = softdep_flushfiles(mp, flags, p);
	else
		error = ffs_flushfiles(mp, flags, p);
	if (error != 0)
		return (error);

a760 1
		free(fs->fs_contigdirs, M_UFSMNT);
d768 1
a768 1
	free(fs->fs_csp, M_UFSMNT);
d841 1
a841 1
	sbp->f_files = fs->fs_ncg * fs->fs_ipg - ROOTINO;
d871 1
a871 1
	int error, allerror = 0, count;
d879 1
a879 1
	if (fs->fs_fmod != 0 && fs->fs_ronly != 0) {
a882 1

d888 3
a890 1
	for (vp = LIST_FIRST(&mp->mnt_vnodelist); vp != NULL; vp = nvp) {
d899 1
a899 1
		nvp = LIST_NEXT(vp, v_mntvnodes);
d902 2
a903 2
		    (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0 &&
		    LIST_EMPTY(&vp->v_dirtyblkhd)) ||
d926 8
a933 17
	if ((ump->um_mountp->mnt_flag & MNT_SOFTDEP) && waitfor == MNT_WAIT) {
		if ((error = softdep_flushworklist(ump->um_mountp, &count, p)))
			allerror = error;
		/* Flushed work items may create new vnodes to clean */
		if (count) {
			simple_lock(&mntvnode_slock);
			goto loop;
		}
	}
	if (waitfor != MNT_LAZY) {
		if (ump->um_mountp->mnt_flag & MNT_SOFTDEP)
			waitfor = MNT_NOWAIT;
		vn_lock(ump->um_devvp, LK_EXCLUSIVE | LK_RETRY, p);
		if ((error = VOP_FSYNC(ump->um_devvp, cred, waitfor, p)) != 0)
			allerror = error;
		VOP_UNLOCK(ump->um_devvp, 0, p);
	}
d938 1
a938 1
	 * Write back modified superblock.
d965 1
a965 1
	int error;
d982 2
a983 2
	/* XXX - we use the same pool for ffs and mfs */
	ip = pool_get(&ffs_ino_pool, PR_WAITOK);
d1008 2
a1009 4
		/*
		 * VOP_INACTIVE will treat this as a stale file
		 * and recycle it quickly
		 */
d1018 1
a1018 1

d1071 4
a1074 4
	if (fs->fs_inodefmt < FS_44INODEFMT) {			/* XXX */
		ip->i_ffs_uid = ip->i_din.ffs_din.di_ouid;	/* XXX */
		ip->i_ffs_gid = ip->i_din.ffs_din.di_ogid;	/* XXX */
	}							/* XXX */
d1143 1
a1143 1
	space = (caddr_t)fs->fs_csp;
d1149 1
a1149 1
			    size, 0, 0);
d1166 1
a1166 1
		    (int)fs->fs_sbsize, 0, 0);
a1194 7
	static int done;

	if (done)
		return (0);
	done = 1;
	pool_init(&ffs_ino_pool, sizeof(struct inode), 0, 0, 0, "ffsino",
	    0, pool_page_alloc_nointr, pool_page_free_nointr, M_FFSNODE);
@


1.28.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.28.2.1 2001/05/14 22:47:41 niklas Exp $	*/
a87 9
struct inode_vtbl ffs_vtbl = {
	ffs_truncate,
	ffs_update,
	ffs_inode_alloc,
	ffs_inode_free,
	ffs_balloc,
	ffs_bufatoff
};

d197 1
a410 2
			if (ronly)
				free(fs->fs_contigdirs, M_UFSMNT);
a491 1
	newfs->fs_ronly = fs->fs_ronly;
a809 4
	if (fs->fs_avgfilesize <= 0)				/* XXX */
		fs->fs_avgfilesize = AVFILESIZ;			/* XXX */
	if (fs->fs_avgfpdir <= 0)				/* XXX */
		fs->fs_avgfpdir = AFPDIR;			/* XXX */
a1084 2
	ip->i_vtbl = &ffs_vtbl;

@


1.28.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a70 2
int ffs_reload_vnode(struct vnode *, void *);
int ffs_sync_vnode(struct vnode *, void *);
a437 51

struct ffs_reload_args {
	struct fs *fs;
	struct proc *p;
	struct ucred *cred;
	struct vnode *devvp;
};

int
ffs_reload_vnode(struct vnode *vp, void *args) 
{
	struct ffs_reload_args *fra = args;
	struct inode *ip;
	struct buf *bp;
	int error;

	/*
	 * Step 4: invalidate all inactive vnodes.
	 */
	if (vp->v_usecount == 0) {
		vgonel(vp, fra->p);
		return (0);
	}

	/*
	 * Step 5: invalidate all cached file data.
	 */
	if (vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, fra->p))
		return (0);

	if (vinvalbuf(vp, 0, fra->cred, fra->p, 0, 0))
		panic("ffs_reload: dirty2");
	/*
	 * Step 6: re-read inode data for all active vnodes.
	 */
	ip = VTOI(vp);
	error = bread(fra->devvp, 
	    fsbtodb(fra->fs, ino_to_fsba(fra->fs, ip->i_number)),
	    (int)fra->fs->fs_bsize, NOCRED, &bp);
	if (error) {
		vput(vp);
		return (error);
	}
	ip->i_din.ffs_din = *((struct dinode *)bp->b_data +
	    ino_to_fsbo(fra->fs, ip->i_number));
	ip->i_effnlink = ip->i_ffs_nlink;
	brelse(bp);
	vput(vp);
	return (0);
}

d457 2
a458 1
	struct vnode *devvp;
d460 1
a464 2
	struct buf *bp = NULL;
	struct ffs_reload_args fra;
d538 7
a544 4
	fra.p = p;
	fra.cred = cred;
	fra.fs = fs;
	fra.devvp = devvp;
d546 6
a551 1
	error = vfs_mount_foreach_vnode(mountp, ffs_reload_vnode, &fra);
d553 28
a580 1
	return (error);
a721 2
	mp->mnt_fs_bshift = fs->fs_bshift;
	mp->mnt_dev_bshift = DEV_BSHIFT;
a726 1
	ump->um_lognindir = ffs(fs->fs_nindir) - 1;
d890 1
d905 1
a905 1

a953 35

struct ffs_sync_args {
	int allerror;
	struct proc *p;
	int waitfor;
	struct ucred *cred;
};

int
ffs_sync_vnode(struct vnode *vp, void *arg) {
	struct ffs_sync_args *fsa = arg;
	struct inode *ip;
	int error;

	ip = VTOI(vp);
	if (fsa->waitfor == MNT_LAZY ||
	    vp->v_type == VNON || 
	    ((ip->i_flag &
		(IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0	&&
		LIST_EMPTY(&vp->v_dirtyblkhd)) ) {
		simple_unlock(&vp->v_interlock);
		return (0);
	}

	if (vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, fsa->p))
		return (0);

	if ((error = VOP_FSYNC(vp, fsa->cred, fsa->waitfor, fsa->p)))
		fsa->allerror = error;
	VOP_UNLOCK(vp, 0, fsa->p);
	vrele(vp);

	return (0);
}

d968 4
a971 2
	struct ufsmount *ump = VFSTOUFS(mp);
	struct fs *fs;
a972 1
	struct ffs_sync_args fsa;
a984 1
 loop:
d988 9
a996 4
	fsa.allerror = 0;
	fsa.p = p;
	fsa.cred = cred;
	fsa.waitfor = waitfor;
d998 25
a1022 4
	vfs_mount_foreach_vnode(mp, ffs_sync_vnode, &fsa);

	if (fsa.allerror != 0)
		allerror = fsa.allerror;
d1030 2
a1031 1
		if (count) 
d1033 1
d1043 1
d1045 1
a1099 1
	LIST_INIT(&ip->i_pcbufhd);
d1102 8
d1117 1
a1117 1
	
a1187 1
	uvm_vnp_setsize(vp, ip->i_ffs_size);
d1355 1
@


1.28.2.4
log
@Merge in trunk
@
text
@a60 1
#include <ufs/ufs/extattr.h>
d87 1
a87 6
	ufs_check_export,
#ifdef UFS_EXTATTR
	ufs_extattrctl,
#else
	vfs_stdextattrctl,
#endif
d740 2
d747 1
a751 4
#ifdef UFS_EXTATTR
	ufs_extattr_uepm_init(&ump->um_extattr);
#endif

a801 15
#ifdef UFS_EXTATTR
#ifdef UFS_EXTATTR_AUTOSTART
	/*
	 *
	 * Auto-starting does the following:
	 *	- check for /.attribute in the fs, and extattr_start if so
	 *	- for each file in .attribute, enable that file with
	 *	  an attribute of the same name.
	 * Not clear how to report errors -- probably eat them.
	 * This would all happen while the file system was busy/not
	 * available, so would effectively be "atomic".
	 */
	(void) ufs_extattr_autostart(mp, p);
#endif /* !UFS_EXTATTR_AUTOSTART */
#endif /* !UFS_EXTATTR */
a867 9
#ifdef UFS_EXTATTR
	if ((error = ufs_extattr_stop(mp, p))) {
		if (error != EOPNOTSUPP)
			printf("ffs_unmount: ufs_extattr_stop returned %d\n",
			    error);
	} else {
		ufs_extattr_uepm_destroy(&ump->um_extattr);
	}
#endif
d1125 1
d1206 1
d1333 1
a1333 1
	    &pool_allocator_nointr);
a1351 6
#ifdef FFS_SOFTUPDATES
	extern int max_softdeps, tickdelay, stat_worklist_push;
	extern int stat_blk_limit_push, stat_ino_limit_push, stat_blk_limit_hit;
	extern int stat_ino_limit_hit, stat_sync_limit_hit, stat_indir_blk_ptrs;
	extern int stat_inode_bitmap, stat_direct_blk_ptrs, stat_dir_entry;
#endif
a1368 26
#ifdef FFS_SOFTUPDATES
	case FFS_MAX_SOFTDEPS:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &max_softdeps));
	case FFS_SD_TICKDELAY:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &tickdelay));
	case FFS_SD_WORKLIST_PUSH:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_worklist_push));
	case FFS_SD_BLK_LIMIT_PUSH:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_blk_limit_push));
	case FFS_SD_INO_LIMIT_PUSH:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_ino_limit_push));
	case FFS_SD_BLK_LIMIT_HIT:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_blk_limit_hit));
	case FFS_SD_INO_LIMIT_HIT:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_ino_limit_hit));
	case FFS_SD_SYNC_LIMIT_HIT:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_sync_limit_hit));
	case FFS_SD_INDIR_BLK_PTRS:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_indir_blk_ptrs));
	case FFS_SD_INODE_BITMAP:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_inode_bitmap));
	case FFS_SD_DIRECT_BLK_PTRS:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_direct_blk_ptrs));
	case FFS_SD_DIR_ENTRY:
		return (sysctl_rdint(oldp, oldlenp, newp, stat_dir_entry));
#endif
@


1.28.2.5
log
@Merge in -current from roughly a week ago
@
text
@d71 1
a71 1
int ffs_sbupdate(struct ufsmount *, int);
@


1.28.2.6
log
@Sync the SMP branch with 3.3
@
text
@d312 1
a312 2
			error = vfs_export(mp, &ump->um_export, 
			    &args.export_info);
a789 7
	/*
	 * XXX
	 * Limit max file size.  Even though ffs can handle files up to 16TB,
	 * we do limit the max file to 2^31 pages to prevent overflow of
	 * a 32-bit unsigned int.  The buffer cache has its own checks but
	 * a little added paranoia never hurts.
	 */
d791 1
a791 1
	maxfilesize = (u_int64_t)0x80000000 * MIN(PAGE_SIZE, fs->fs_bsize) - 1;
@


1.28.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.28.2.6 2003/03/28 00:08:47 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.28.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a62 1
#include <ufs/ufs/dirhash.h>
d71 1
a71 1
const struct vfsops ffs_vfsops = {
a121 1
	swapdev_vp = NULL;
a124 2
		if (swapdev_vp)
			vrele(swapdev_vp);
d128 1
a128 3
	if ((error = vfs_rootmountalloc("ffs", "root_device", &mp)) != 0) {
		vrele(swapdev_vp);
		vrele(rootvp);
a129 2
	}

a133 2
		vrele(swapdev_vp);
		vrele(rootvp);
d287 1
a287 1
					error = EROFS;
d486 1
a486 1
	ip->i_din1 = *((struct ufs1_dinode *)bp->b_data +
d659 1
a659 1
	if (fs->fs_magic != FS_UFS1_MAGIC || fs->fs_bsize > MAXBSIZE ||
a660 2
		if (fs->fs_magic == FS_UFS2_MAGIC)
			printf("no UFS2 support\n");
d689 1
a689 1
			error = EROFS;
d699 1
a699 1
	bzero(ump, sizeof *ump);
a701 3
	if (fs->fs_magic == FS_UFS1_MAGIC) {
		ump->um_fstype = UM_UFS1;
	}
d996 1
a996 1
	sbp->f_bavail = sbp->f_bfree - ((int64_t)fs->fs_dsize * fs->fs_minfree / 100);
a1154 2
	ip->i_ump = ump;
	VREF(ip->i_devvp);
d1199 1
a1199 1
	ip->i_din1 = *((struct ufs1_dinode *)bp->b_data + ino_to_fsbo(fs, ino));
d1217 5
d1226 1
a1226 1
		ip->i_ffs_gen = arc4random() & INT_MAX;
d1237 2
a1238 2
		ip->i_ffs_uid = ip->i_din1.di_ouid;		/* XXX */
		ip->i_ffs_gid = ip->i_din1.di_ogid;		/* XXX */
a1433 11
#ifdef UFS_DIRHASH
	case FFS_DIRHASH_DIRSIZE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &ufs_mindirhashsize));
	case FFS_DIRHASH_MAXMEM:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &ufs_dirhashmaxmem));
	case FFS_DIRHASH_MEM:
		return (sysctl_rdint(oldp, oldlenp, newp, ufs_dirhashmem));
#endif

@


1.28.2.9
log
@Merge with the trunk
@
text
@d113 1
d633 1
@


1.27
log
@rename DEBUGLOCKS to LOCKDEBUG to be consistent with the rest of the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.26 1999/12/06 07:03:04 art Exp $	*/
d83 2
a84 1
	ffs_sysctl
a1086 2
 * - check that the given client host has export rights and return
 *   those rights via. exflagsp and credanonp
d1089 1
a1089 1
ffs_fhtovp(mp, fhp, nam, vpp, exflagsp, credanonp)
a1091 1
	struct mbuf *nam;
a1092 2
	int *exflagsp;
	struct ucred **credanonp;
d1102 1
a1102 1
	return (ufs_check_export(mp, ufhp, nam, vpp, exflagsp, credanonp));
@


1.26
log
@ffs_init is a vfsop. Move it to ffs_vfsops.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.25 1999/12/06 06:59:36 art Exp $	*/
d978 1
a978 1
#ifdef DEBUGLOCKS
@


1.25
log
@Always make sure that softdep mounts are not async.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.24 1999/12/03 21:29:29 art Exp $	*/
d1193 8
@


1.24
log
@Clean up ffs_mount.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.23 1999/05/31 17:34:54 millert Exp $	*/
d344 2
@


1.23
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.22 1998/12/05 18:57:07 csapuntz Exp $	*/
d148 1
a148 1
	int err = 0, flags;
d153 3
a155 3
	err = copyin(data, (caddr_t)&args, sizeof (struct ufs_args));
	if (err)
		return (err);
d164 1
a164 1
		err = 0;
d172 1
a172 1
				err = softdep_flushfiles(mp, flags, p);
d174 1
a174 1
				err = ffs_flushfiles(mp, flags, p);
d177 3
a179 3
		if (!err && (mp->mnt_flag & MNT_RELOAD)) 
			err = ffs_reload(mp, ndp->ni_cnd.cn_cred, p);
		if (err)
d189 1
a189 1
				err = VOP_ACCESS(devvp, VREAD | VWRITE,
d192 2
a193 1
				if (err) goto error_1;
d205 1
a205 1
                                        err = EPERM;
d211 3
a213 2
				err = softdep_mount(devvp, mp, fs, p->p_ucred);
				if (err)
d234 2
a235 2
			err = vfs_export(mp, &ump->um_export, &args.export);
			if (err)
d246 1
a246 1
	if ((err = namei(ndp)) != 0)
d252 1
a252 1
		err = ENOTBLK;
d257 1
a257 1
		err = ENXIO;
d270 1
a270 1
		err = VOP_ACCESS(devvp, accessmode, p->p_ucred, p);
d272 1
a272 1
		if (err) 
d289 1
a289 1
                                err = EINVAL;   /* needs translation */
d296 4
a299 2
                if (!err) {
                        /* Save "mounted from" info for mount point (NULL pad)*/
d304 2
a305 1
                        bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
d328 1
a328 1
                err = ffs_mountfs(devvp, mp, p);
d331 2
a332 1
	if (err) goto error_2;
d359 1
a359 1
        return (err);
@


1.22
log
@

There's still a good bit of lock debugging that needs to happen. Don't
turn it on by default or people will be getting too many panics.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.21 1998/12/05 17:01:09 csapuntz Exp $	*/
d334 1
a825 5
#ifdef COMPAT_09
	sbp->f_type = 1;
#else
	sbp->f_type = 0;
#endif
a834 1
		sbp->f_type = mp->mnt_vfc->vfc_typenum;
d837 2
@


1.21
log
@

Finally, enable lock checking for FFS, which has full-blown lock support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.20 1998/11/27 22:52:42 art Exp $	*/
d973 1
a973 1
#ifdef DIAGNOSTIC
@


1.20
log
@indentation police
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.19 1998/11/20 02:42:19 millert Exp $	*/
d973 3
@


1.19
log
@s/dismounted/unmounted/
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.18 1998/11/12 04:30:03 csapuntz Exp $	*/
d903 1
a903 2
		error =
		  vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, p);
@


1.18
log
@

Integrate latest soft updates patches for McKusick.

Integrate cleaner ffs mount code from FreeBSD. Most notably, this mount
code prevents you from mounting an unclean file system read-write.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.17 1998/02/08 22:41:50 tholo Exp $	*/
d198 1
a198 1
"WARNING: %s was not properly dismounted\n",
d566 1
a566 1
"WARNING: %s was not properly dismounted\n",
@


1.17
log
@Updates to match type changes in syscall tables
@
text
@a125 1

d148 3
a151 2
	int error, flags;
	mode_t accessmode;
d153 3
a155 3
	error = copyin(data, (caddr_t)&args, sizeof (struct ufs_args));
	if (error)
		return (error);
d163 5
a167 1
		if (fs->fs_ronly == 0 && (mp->mnt_flag & MNT_RDONLY)) {
d172 1
a172 1
				error = softdep_flushfiles(mp, flags, p);
d174 2
a175 15
				error = ffs_flushfiles(mp, flags, p);
			if (error == 0 &&
			    ffs_cgupdate(ump, MNT_WAIT) == 0 &&
			    fs->fs_clean & FS_WASCLEAN) {
				fs->fs_clean = FS_ISCLEAN;
				(void) ffs_sbupdate(ump, MNT_WAIT);
			}
			if (error)
				return (error);
			fs->fs_ronly = 1;
		}
		if (mp->mnt_flag & MNT_RELOAD) {
			error = ffs_reload(mp, ndp->ni_cnd.cn_cred, p);
			if (error)
				return (error);
d177 6
a182 1
		if (fs->fs_ronly && (mp->mnt_flag & MNT_WANTRDWR)) {
a187 1
				devvp = ump->um_devvp;
d189 2
a190 6
				error = VOP_ACCESS(devvp, VREAD | VWRITE,
						   p->p_ucred, p);
				if (error) {
					VOP_UNLOCK(devvp, 0, p);
					return (error);
				}
d192 1
d194 22
a215 5
			fs->fs_ronly = 0;
			if (fs->fs_clean & FS_ISCLEAN)
			  fs->fs_clean = FS_WASCLEAN;
			fs->fs_fmod = 1;
			(void) ffs_sbupdate(ump, MNT_WAIT);
d217 11
d232 5
a236 1
			return (vfs_export(mp, &ump->um_export, &args.export));
d244 3
a246 2
	if ((error = namei(ndp)) != 0)
		return (error);
d250 2
a251 2
		vrele(devvp);
		return (ENOTBLK);
d253 1
d255 2
a256 2
		vrele(devvp);
		return (ENXIO);
d258 1
d268 1
a268 5
		error = VOP_ACCESS(devvp, accessmode, p->p_ucred, p);
		if (error) {
			vput(devvp);
			return (error);
		}
d270 2
d273 51
a323 28
	if ((mp->mnt_flag & MNT_UPDATE) == 0)
		error = ffs_mountfs(devvp, mp, p);
	else {
		if (devvp != ump->um_devvp)
			error = EINVAL;	/* XXX needs translation */
		else
			vrele(devvp);
	}
	if (error) {
		vrele(devvp);
		return (error);
	}
	ump = VFSTOUFS(mp);
	fs = ump->um_fs;
	(void) copyinstr(path, fs->fs_fsmnt, sizeof(fs->fs_fsmnt) - 1, &size);
	bzero(fs->fs_fsmnt + size, sizeof(fs->fs_fsmnt) - size);
	bcopy(fs->fs_fsmnt, mp->mnt_stat.f_mntonname, MNAMELEN);
	(void) copyinstr(args.fspec, mp->mnt_stat.f_mntfromname, MNAMELEN - 1, 
	    &size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
	if (fs->fs_fmod != 0) {	/* XXX */
		fs->fs_fmod = 0;
		if (fs->fs_clean & FS_WASCLEAN)
			fs->fs_time = time.tv_sec;
		else
			printf("%s: file system not clean; please fsck(8)\n",
			    mp->mnt_stat.f_mntfromname);
		(void) ffs_cgupdate(ump, MNT_WAIT);
d325 22
d348 5
d425 1
d442 4
d517 1
d560 16
d592 4
d630 1
d641 21
d672 1
a672 3
		if (fs->fs_clean & FS_ISCLEAN)
		  fs->fs_clean = FS_WASCLEAN;

d744 7
a750 5
	if (fs->fs_ronly == 0 &&
	    ffs_cgupdate(ump, MNT_WAIT) == 0 &&
	    fs->fs_clean & FS_WASCLEAN) {
		fs->fs_clean = FS_ISCLEAN;
		(void) ffs_sbupdate(ump, MNT_WAIT);
d753 2
d762 1
d903 2
a904 1
       		error = vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, p);
d911 1
a911 1
		if ((error = VOP_FSYNC(vp, cred, waitfor, p)) != 0)
a1131 33
	int i, error = 0;

	bp = getblk(mp->um_devvp, SBOFF >> (fs->fs_fshift - fs->fs_fsbtodb),
	    (int)fs->fs_sbsize, 0, 0);
	bcopy((caddr_t)fs, bp->b_data, (u_int)fs->fs_sbsize);
	/* Restore compatibility to old file systems.		   XXX */
	dfs = (struct fs *)bp->b_data;				/* XXX */
	if (fs->fs_postblformat == FS_42POSTBLFMT)		/* XXX */
		dfs->fs_nrpos = -1;				/* XXX */
	if (fs->fs_inodefmt < FS_44INODEFMT) {			/* XXX */
		int32_t *lp, tmp;				/* XXX */
								/* XXX */
		lp = (int32_t *)&dfs->fs_qbmask;		/* XXX */
		tmp = lp[4];					/* XXX */
		for (i = 4; i > 0; i--)				/* XXX */
			lp[i] = lp[i-1];			/* XXX */
		lp[0] = tmp;					/* XXX */
	}							/* XXX */
	dfs->fs_maxfilesize = mp->um_savedmaxfilesize;		/* XXX */
	if (waitfor == MNT_WAIT)
		error = bwrite(bp);
	else
		bawrite(bp);
	return (error);
}

int
ffs_cgupdate(mp, waitfor)
	struct ufsmount *mp;
	int waitfor;
{
	register struct fs *fs = mp->um_fs, *dfs;
	register struct buf *bp;
d1134 1
a1134 1
	int i, size, error = 0, allerror = 0;
d1136 3
a1138 1
	allerror = ffs_sbupdate(mp, waitfor);
d1149 1
a1149 3
		if (waitfor == MNT_WAIT)
			error = bwrite(bp);
		else
d1151 2
a1153 1

d1161 3
a1163 1
	bp = getblk(mp->um_devvp, SBLOCK, (int)fs->fs_sbsize, 0, 0);
d1183 1
a1183 1
	else if ((error = bwrite(bp)) != 0)
a1184 1

@


1.16
log
@right f_bavail calculation
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.15 1998/01/09 20:39:54 csapuntz Exp $	*/
d140 1
a140 1
	char *path;
@


1.15
log
@Correction of long-standing race condition in vnode creation due to
possible sleep in MALLOC
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.14 1997/12/09 04:54:42 deraadt Exp $	*/
d709 1
a709 2
	sbp->f_bavail = (fs->fs_dsize * (100 - fs->fs_minfree) / 100) -
		(fs->fs_dsize - sbp->f_bfree);
@


1.14
log
@when downgrading a filesystem to read-only, use softdep_flushfiles; mckusick
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.13 1997/11/11 15:28:44 csapuntz Exp $	*/
d838 2
d871 9
a879 1
	ufs_ihashins(ip);
d881 4
@


1.13
log
@Make sure the clean bits are set correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.12 1997/11/06 05:59:20 csapuntz Exp $	*/
d167 4
a170 1
			error = ffs_flushfiles(mp, flags, p);
@


1.12
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.11 1997/10/06 20:21:37 deraadt Exp $	*/
d200 2
a201 1
			fs->fs_clean <<= 1;
d546 3
a548 1
		fs->fs_clean = 0;
@


1.11
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.9 1997/06/20 14:04:32 kstailey Exp $	*/
d54 1
a71 1
	MOUNT_FFS,
d83 1
a89 2
 *
 * Name is updated by mount(8) after booting.
a90 1
#define ROOTNAME	"root_device"
d96 2
a97 2
	register struct fs *fs;
	register struct mount *mp;
a99 1
	size_t size;
d105 3
a107 9
	if (bdevvp(swapdev, &swapdev_vp) || bdevvp(rootdev, &rootvp))
		panic("ffs_mountroot: can't setup bdevvp's");

	mp = malloc((u_long)sizeof(struct mount), M_MOUNT, M_WAITOK);
	bzero((char *)mp, (u_long)sizeof(struct mount));
	mp->mnt_op = &ffs_vfsops;
	mp->mnt_flag = MNT_RDONLY;
	if ((error = ffs_mountfs(rootvp, mp, p)) != 0) {
		free(mp, M_MOUNT);
d110 2
a111 3
	if ((error = vfs_lock(mp)) != 0) {
		(void)ffs_unmount(mp, 0, p);
		free(mp, M_MOUNT);
d113 7
a119 1
	}
d121 9
a129 13
	mp->mnt_vnodecovered = NULLVP;
	ump = VFSTOUFS(mp);
	fs = ump->um_fs;
	bzero(fs->fs_fsmnt, sizeof(fs->fs_fsmnt));
	fs->fs_fsmnt[0] = '/';
	bcopy(fs->fs_fsmnt, mp->mnt_stat.f_mntonname, MNAMELEN);
	(void) copystr(ROOTNAME, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
	    &size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
	(void)ffs_statfs(mp, &mp->mnt_stat, p);
	vfs_unlock(mp);
	inittodr(fs->fs_time);
	return (0);
a166 2
			if (vfs_busy(mp))
				return (EBUSY);
a173 1
			vfs_unbusy(mp);
d190 1
a190 1
				VOP_LOCK(devvp);
d194 1
a194 1
					VOP_UNLOCK(devvp);
d197 1
a197 1
				VOP_UNLOCK(devvp);
d202 1
d236 1
a236 1
		VOP_LOCK(devvp);
d242 1
a242 1
		VOP_UNLOCK(devvp);
d310 4
a313 1
	if (vinvalbuf(devvp, 0, cred, p, 0, 0))
d315 1
d372 1
d374 5
d383 3
a385 4
		if (vp->v_usecount == 0) {
			vgone(vp);
			continue;
		}
d389 3
a391 1
		if (vget(vp, 1))
d407 1
d410 1
a410 2
		if (vp->v_mount != mountp)
			goto loop;
d412 1
d431 1
a431 2
	int blks;
	int error, i, size, ronly;
d449 4
a452 1
	if ((error = vinvalbuf(devvp, V_SAVE, cred, p, 0, 0)) != 0)
a490 4
	if (ronly == 0) {
		fs->fs_clean <<= 1;
		fs->fs_fmod = 1;
	}
d523 1
a523 1
		mp->mnt_stat.f_fsid.val[1] = makefstype(MOUNT_FFS);
a524 1
	mp->mnt_flag |= MNT_LOCAL;
d533 1
a533 1
	devvp->v_specflags |= SI_MOUNTEDON;
d539 9
d550 1
d607 8
a614 2
	if ((error = ffs_flushfiles(mp, flags, p)) != 0)
		return (error);
d623 1
a623 1
	ump->um_devvp->v_specflags &= ~SI_MOUNTEDON;
a630 1
	mp->mnt_flag &= ~MNT_LOCAL;
a642 1
	extern int doforce;
a645 2
	if (!doforce)
		flags &= ~FORCECLOSE;
d663 11
a673 1
	error = vflush(mp, NULLVP, flags);
d708 1
d712 1
a712 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
d730 1
a730 1
	register struct vnode *vp;
d742 3
a744 8
	if (fs->fs_fmod != 0) {
		if (fs->fs_ronly != 0) {		/* XXX */
			printf("fs = %s\n", fs->fs_fsmnt);
			panic("update: rofs mod");
		}
		fs->fs_fmod = 0;
		fs->fs_time = time.tv_sec;
		allerror = ffs_cgupdate(ump, waitfor);
d749 1
d753 1
a753 1
	     vp = vp->v_mntvnodes.le_next) {
d760 9
a768 1
		if (VOP_ISLOCKED(vp))
d770 7
a776 4
		ip = VTOI(vp);
		if ((ip->i_flag &
		    (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0 &&
		    vp->v_dirtyblkhd.lh_first == NULL)
d778 1
a778 2
		if (vget(vp, 1))
			goto loop;
d781 3
a783 1
		vput(vp);
d785 1
d789 8
a796 2
	if ((error = VOP_FSYNC(ump->um_devvp, cred, waitfor, p)) != 0)
		allerror = error;
d800 7
d843 1
d881 4
d1017 1
a1017 1
	register struct fs *fs = mp->um_fs;
d1039 29
a1067 1
	if (!allerror && error)
d1069 1
d1072 38
@


1.10
log
@VFS Lite2 Changes
@
text
@a53 1
#include <sys/sysctl.h>
d71 1
a82 1
	ffs_sysctl
d89 2
d92 1
d98 2
a99 2
	struct fs *fs;
	struct mount *mp;
d102 1
d108 9
a116 3
	if ((error = bdevvp(swapdev, &swapdev_vp)) || 
	    (error = bdevvp(rootdev, &rootvp))) {
		printf("ffs_mountroot: can't setup bdevvp's");
d119 3
a121 2

	if ((error = vfs_rootmountalloc("ffs", "root_device", &mp)) != 0)
d123 1
a123 7
	if ((error = ffs_mountfs(rootvp, mp, p)) != 0) {
		mp->mnt_vfc->vfc_refcount--;
		vfs_unbusy(mp, p);
 		free(mp, M_MOUNT);
 		return (error);
 	}
	simple_lock(&mountlist_slock);
d125 13
a137 9
	simple_unlock(&mountlist_slock);
 	ump = VFSTOUFS(mp);
 	fs = ump->um_fs;
	(void) copystr(mp->mnt_stat.f_mntonname, fs->fs_fsmnt, MNAMELEN - 1, 0);
 	(void)ffs_statfs(mp, &mp->mnt_stat, p);

	vfs_unbusy(mp, p);
 	inittodr(fs->fs_time);
 	return (0);
d175 2
d184 1
d201 1
a201 1
				vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
d205 1
a205 1
					VOP_UNLOCK(devvp, 0, p);
d208 1
a208 1
				VOP_UNLOCK(devvp, 0, p);
a212 1
			(void) ffs_sbupdate(ump, MNT_WAIT);
d246 1
a246 1
		vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
d252 1
a252 1
		VOP_UNLOCK(devvp, 0, p);
d320 1
a320 4
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = vinvalbuf(devvp, 0, cred, p, 0, 0);
	VOP_UNLOCK(devvp, 0, p);
	if (error)
a321 1

a377 1
	simple_lock(&mntvnode_slock);
a378 5
		if (vp->v_mount != mountp) {
			simple_unlock(&mntvnode_slock);
			goto loop;
		}

d383 4
a386 3
		if (vrecycle(vp, &mntvnode_slock, p))
			goto loop;

d390 1
a390 3
		simple_lock(&vp->v_interlock);
		simple_unlock(&mntvnode_slock);
		if (vget(vp, LK_EXCLUSIVE  | LK_INTERLOCK, p))
a405 1
		ip->i_effnlink = ip->i_ffs_nlink;
d408 2
a409 1
		simple_lock(&mntvnode_slock);
a410 1
	simple_unlock(&mntvnode_slock);
d429 2
a430 1
	int error, i, blks, size, ronly;
d448 1
a448 4
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = vinvalbuf(devvp, V_SAVE, cred, p, 0, 0);
	VOP_UNLOCK(devvp, 0, p);
	if (error)
d487 4
d523 1
a523 1
		mp->mnt_stat.f_fsid.val[1] = mp->mnt_vfc->vfc_typenum;
d525 1
d534 1
a534 1
	devvp->v_specmountpoint = mp;
a539 9
	if (ronly == 0) {
		if ((fs->fs_flags & FS_DOSOFTDEP) &&
		    (error = softdep_mount(devvp, mp, fs, cred)) != 0) {
			free(base, M_UFSMNT);
			goto out;
		}
		fs->fs_clean = 0;
		(void) ffs_sbupdate(ump, MNT_WAIT);
	}
a541 1
	devvp->v_specmountpoint = NULL;
d598 2
a599 8
	if (mp->mnt_flag & MNT_SOFTDEP) {
		if ((error = softdep_flushfiles(mp, flags, p)) != 0)
			return (error);
	} else {
		if ((error = ffs_flushfiles(mp, flags, p)) != 0)
			return (error);
	}

d608 1
a608 1
	ump->um_devvp->v_specmountpoint = NULL;
d616 1
d629 1
d633 2
d652 1
a652 11
	/*
	 * Flush all the files.
	 */
	if ((error = vflush(mp, NULL, flags)) != 0)
		return (error);
	/*
	 * Flush filesystem metadata.
	 */
	vn_lock(ump->um_devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = VOP_FSYNC(ump->um_devvp, p->p_ucred, MNT_WAIT, p);
	VOP_UNLOCK(ump->um_devvp, 0, p);
a686 1
		sbp->f_type = mp->mnt_vfc->vfc_typenum;
d690 1
a690 1
	strncpy(sbp->f_fstypename, mp->mnt_vfc->vfc_name, MFSNAMELEN);
d708 1
a708 1
	register struct vnode *vp, *nvp;
d720 8
a727 3
	if (fs->fs_fmod != 0  && fs->fs_ronly != 0) {
		printf("fs = %s\n", fs->fs_fsmnt);
		panic("update: rofs mod");
a731 1
	simple_lock(&mntvnode_slock);
d735 1
a735 1
	     vp = nvp) {
d742 2
a743 3

		simple_lock(&vp->v_interlock);
		nvp = vp->v_mntvnodes.le_next;
d745 3
a747 5
		if (vp->v_type == VNON || ((ip->i_flag &
		     (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0 &&
		     vp->v_dirtyblkhd.lh_first == NULL) || 
		    waitfor == MNT_LAZY) {
			simple_unlock(&vp->v_interlock);
d749 2
a750 9
		}
		simple_unlock(&mntvnode_slock);
       		error = vget(vp, LK_EXCLUSIVE | LK_NOWAIT | LK_INTERLOCK, p);
		if (error) {
			simple_lock(&mntvnode_slock);
			if (error == ENOENT)
				goto loop;
			continue;
		}
d753 1
a753 3
		VOP_UNLOCK(vp, 0, p);
		vrele(vp);
		simple_lock(&mntvnode_slock);
a754 1
	simple_unlock(&mntvnode_slock);
d758 2
a759 8
        if (waitfor != MNT_LAZY) {
                if (ump->um_mountp->mnt_flag & MNT_SOFTDEP)
                        waitfor = MNT_NOWAIT;
                vn_lock(ump->um_devvp, LK_EXCLUSIVE | LK_RETRY, p);
                if ((error = VOP_FSYNC(ump->um_devvp, cred, waitfor, p)) != 0)
                        allerror = error;
                VOP_UNLOCK(ump->um_devvp, 0, p);
        }
a762 7
	/*
         * Write back modified superblock.
	 */

	if (fs->fs_fmod != 0 && (error = ffs_sbupdate(ump, waitfor)) != 0)
		allerror = error;

a798 1
	lockinit(&ip->i_lock, PINOD, "inode", 0, 0);
a835 4
	if (DOINGSOFTDEP(vp))
		softdep_load_inodeblock(ip);
	else
		ip->i_effnlink = ip->i_ffs_nlink;
d968 1
a968 1
	register struct fs *fs = mp->um_fs, *dfs;
d990 1
a990 29

	/*
	 * Now write back the superblock itself. If any errors occurred
	 * up to this point, then fail so that the superblock avoids
	 * being written out as clean.
	 */
	if (allerror)
		return (allerror);
	bp = getblk(mp->um_devvp, SBLOCK, (int)fs->fs_sbsize, 0, 0);
	fs->fs_fmod = 0;
	fs->fs_time = time.tv_sec;
	bcopy((caddr_t)fs, bp->b_data, (u_int)fs->fs_sbsize);
	/* Restore compatibility to old file systems.		   XXX */
	dfs = (struct fs *)bp->b_data;				/* XXX */
	if (fs->fs_postblformat == FS_42POSTBLFMT)		/* XXX */
		dfs->fs_nrpos = -1;				/* XXX */
	if (fs->fs_inodefmt < FS_44INODEFMT) {			/* XXX */
		int32_t *lp, tmp;				/* XXX */
								/* XXX */
		lp = (int32_t *)&dfs->fs_qbmask;		/* XXX */
		tmp = lp[4];					/* XXX */
		for (i = 4; i > 0; i--)				/* XXX */
			lp[i] = lp[i-1];			/* XXX */
		lp[0] = tmp;					/* XXX */
	}							/* XXX */
	dfs->fs_maxfilesize = mp->um_savedmaxfilesize;		/* XXX */
	if (waitfor != MNT_WAIT)
		bawrite(bp);
	else if ((error = bwrite(bp)) != 0)
a991 1

a993 38

/*
 * fast filesystem related variables.
 */
int
ffs_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	extern int doclusterread, doclusterwrite, doreallocblks, doasyncfree;

	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case FFS_CLUSTERREAD:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &doclusterread));
	case FFS_CLUSTERWRITE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &doclusterwrite));
	case FFS_REALLOCBLKS:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &doreallocblks));
	case FFS_ASYNCFREE:
		return (sysctl_int(oldp, oldlenp, newp, newlen, &doasyncfree));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

@


1.9
log
@Change errno cause by mounting invalid filesystems from EINVAL to EFTYPE.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.8 1997/05/30 08:34:25 downsj Exp $	*/
d54 1
a71 1
	MOUNT_FFS,
d83 1
a89 2
 *
 * Name is updated by mount(8) after booting.
a90 1
#define ROOTNAME	"root_device"
d96 2
a97 2
	register struct fs *fs;
	register struct mount *mp;
a99 1
	size_t size;
d105 3
a107 9
	if (bdevvp(swapdev, &swapdev_vp) || bdevvp(rootdev, &rootvp))
		panic("ffs_mountroot: can't setup bdevvp's");

	mp = malloc((u_long)sizeof(struct mount), M_MOUNT, M_WAITOK);
	bzero((char *)mp, (u_long)sizeof(struct mount));
	mp->mnt_op = &ffs_vfsops;
	mp->mnt_flag = MNT_RDONLY;
	if ((error = ffs_mountfs(rootvp, mp, p)) != 0) {
		free(mp, M_MOUNT);
d110 2
a111 3
	if ((error = vfs_lock(mp)) != 0) {
		(void)ffs_unmount(mp, 0, p);
		free(mp, M_MOUNT);
d113 7
a119 1
	}
d121 9
a129 13
	mp->mnt_vnodecovered = NULLVP;
	ump = VFSTOUFS(mp);
	fs = ump->um_fs;
	bzero(fs->fs_fsmnt, sizeof(fs->fs_fsmnt));
	fs->fs_fsmnt[0] = '/';
	bcopy(fs->fs_fsmnt, mp->mnt_stat.f_mntonname, MNAMELEN);
	(void) copystr(ROOTNAME, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
	    &size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
	(void)ffs_statfs(mp, &mp->mnt_stat, p);
	vfs_unlock(mp);
	inittodr(fs->fs_time);
	return (0);
a166 2
			if (vfs_busy(mp))
				return (EBUSY);
a173 1
			vfs_unbusy(mp);
d190 1
a190 1
				VOP_LOCK(devvp);
d194 1
a194 1
					VOP_UNLOCK(devvp);
d197 1
a197 1
				VOP_UNLOCK(devvp);
d202 1
d236 1
a236 1
		VOP_LOCK(devvp);
d242 1
a242 1
		VOP_UNLOCK(devvp);
d310 4
a313 1
	if (vinvalbuf(devvp, 0, cred, p, 0, 0))
d315 1
d372 1
d374 5
d383 3
a385 4
		if (vp->v_usecount == 0) {
			vgone(vp);
			continue;
		}
d389 3
a391 1
		if (vget(vp, 1))
d407 1
d410 1
a410 2
		if (vp->v_mount != mountp)
			goto loop;
d412 1
d431 1
a431 2
	int blks;
	int error, i, size, ronly;
d449 4
a452 1
	if ((error = vinvalbuf(devvp, V_SAVE, cred, p, 0, 0)) != 0)
a490 4
	if (ronly == 0) {
		fs->fs_clean <<= 1;
		fs->fs_fmod = 1;
	}
d523 1
a523 1
		mp->mnt_stat.f_fsid.val[1] = makefstype(MOUNT_FFS);
a524 1
	mp->mnt_flag |= MNT_LOCAL;
d533 1
a533 1
	devvp->v_specflags |= SI_MOUNTEDON;
d539 9
d550 1
d607 8
a614 2
	if ((error = ffs_flushfiles(mp, flags, p)) != 0)
		return (error);
d623 1
a623 1
	ump->um_devvp->v_specflags &= ~SI_MOUNTEDON;
a630 1
	mp->mnt_flag &= ~MNT_LOCAL;
a642 1
	extern int doforce;
a645 2
	if (!doforce)
		flags &= ~FORCECLOSE;
d663 11
a673 1
	error = vflush(mp, NULLVP, flags);
d708 1
d712 1
a712 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
d730 1
a730 1
	register struct vnode *vp;
d742 3
a744 8
	if (fs->fs_fmod != 0) {
		if (fs->fs_ronly != 0) {		/* XXX */
			printf("fs = %s\n", fs->fs_fsmnt);
			panic("update: rofs mod");
		}
		fs->fs_fmod = 0;
		fs->fs_time = time.tv_sec;
		allerror = ffs_cgupdate(ump, waitfor);
d749 1
d753 1
a753 1
	     vp = vp->v_mntvnodes.le_next) {
d760 9
a768 1
		if (VOP_ISLOCKED(vp))
d770 7
a776 4
		ip = VTOI(vp);
		if ((ip->i_flag &
		    (IN_ACCESS | IN_CHANGE | IN_MODIFIED | IN_UPDATE)) == 0 &&
		    vp->v_dirtyblkhd.lh_first == NULL)
d778 1
a778 2
		if (vget(vp, 1))
			goto loop;
d781 3
a783 1
		vput(vp);
d785 1
d789 8
a796 2
	if ((error = VOP_FSYNC(ump->um_devvp, cred, waitfor, p)) != 0)
		allerror = error;
d800 7
d843 1
d881 4
d1017 1
a1017 1
	register struct fs *fs = mp->um_fs;
d1039 29
a1067 1
	if (!allerror && error)
d1069 1
d1072 38
@


1.8
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.7 1997/02/11 06:59:28 millert Exp $	*/
d258 1
a258 1
			error = EINVAL;	/* needs translation */
d468 1
a468 1
		error = EINVAL;		/* XXX needs translation */
@


1.7
log
@Add fs_id support and random inode generation numbers for ffs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.6 1996/06/27 06:42:06 downsj Exp $	*/
a84 8
static struct ufs_dirops ffs_dirops = {
	ufs_dirremove,
	ufs_direnter, 
	ufs_dirempty,
	ufs_dirrewrite,
	ufs_checkpath,
};

d404 1
a404 1
		ip->i_din = *((struct dinode *)bp->b_data +
a531 1
	ump->um_dirops = &ffs_dirops;
d835 1
a835 1
	ip->i_din = *((struct dinode *)bp->b_data + ino_to_fsbo(fs, ino));
d857 4
a860 4
	if (ip->i_gen == 0) {
		ip->i_gen = arc4random();
		if (ip->i_gen == 0 || ip->i_gen == -1)
			ip->i_gen = 1;			/* shouldn't happen */
d869 2
a870 2
		ip->i_uid = ip->i_din.di_ouid;		/* XXX */
		ip->i_gid = ip->i_din.di_ogid;		/* XXX */
d923 1
a923 1
	ufhp->ufid_gen = ip->i_gen;
@


1.6
log
@Moving some things around; struct inode still ends up bigger, though.
This should, hopefully, be the last UFS changes required.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.5 1996/06/24 03:35:01 downsj Exp $	*/
d55 2
d527 5
a531 1
	mp->mnt_stat.f_fsid.val[1] = makefstype(MOUNT_FFS);
d867 3
a869 3
		if (++nextgennumber < (u_long)time.tv_sec)
			nextgennumber = time.tv_sec;
		ip->i_gen = nextgennumber;
@


1.5
log
@ufs changes: add the notion of directory operators.

gnu/ext2fs: add the second extended filesystem.

Note that I'm commiting this now for the sake of the ufs changes; ext2fs
is not yet fully integrated into the system.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_vfsops.c,v 1.4 1996/02/27 07:27:39 niklas Exp $	*/
d534 1
a806 1
	ip->i_dirops = &ffs_dirops;
@


1.4
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 1
d83 8
d806 1
@


1.3
log
@from netbsd:
Fix from Lite-2: when reloading the file system, save fs_maxcluster and
the old summary structure pointers, and recalculate cluster per cyl. grp.
information.
@
text
@d1 2
a2 1
/*	$NetBSD: ffs_vfsops.c,v 1.18 1995/12/19 23:27:53 cgd Exp $	*/
d91 1
d112 1
a112 1
	if (error = ffs_mountfs(rootvp, mp, p)) {
d116 1
a116 1
	if (error = vfs_lock(mp)) {
d152 1
a152 1
	struct ufsmount *ump;
d158 2
a159 1
	if (error = copyin(data, (caddr_t)&args, sizeof (struct ufs_args)))
d199 3
a201 2
				if (error = VOP_ACCESS(devvp, VREAD | VWRITE,
				    p->p_ucred, p)) {
d223 1
a223 1
	if (error = namei(ndp))
d244 2
a245 1
		if (error = VOP_ACCESS(devvp, accessmode, p->p_ucred, p)) {
d296 1
d326 2
a327 1
	if (error = bread(devvp, (daddr_t)(SBOFF / size), SBSIZE, NOCRED, &bp))
d358 3
a360 2
		if (error = bread(devvp, fsbtodb(fs, fs->fs_csaddr + i), size,
		    NOCRED, &bp))
d395 3
a397 3
		if (error =
		    bread(devvp, fsbtodb(fs, ino_to_fsba(fs, ip->i_number)),
		    (int)fs->fs_bsize, NOCRED, &bp)) {
d441 1
a441 1
	if (error = vfs_mountedon(devvp))
d445 1
a445 1
	if (error = vinvalbuf(devvp, V_SAVE, cred, p, 0, 0))
d449 2
a450 1
	if (error = VOP_OPEN(devvp, ronly ? FREAD : FREAD|FWRITE, FSCRED, p))
d459 2
a460 1
	if (error = bread(devvp, (daddr_t)(SBOFF / size), SBSIZE, cred, &bp))
d497 3
a499 2
		if (error = bread(devvp, fsbtodb(fs, fs->fs_csaddr + i), size,
		    cred, &bp)) {
d551 1
d591 1
a591 1
	if (error = ffs_flushfiles(mp, flags, p))
d616 1
d624 1
a624 1
	int i, error;
d631 2
a632 1
		if (error = vflush(mp, NULLVP, SKIPSYSTEM|flags))
d744 1
a744 1
		if (error = VOP_FSYNC(vp, cred, waitfor, p))
d751 1
a751 1
	if (error = VOP_FSYNC(ump->um_devvp, cred, waitfor, p))
d777 1
a777 1
	int i, type, error;
d785 1
a785 1
	if (error = getnewvnode(VT_UFS, mp, ffs_vnodeop_p, &vp)) {
d798 6
a803 2
	for (i = 0; i < MAXQUOTAS; i++)
		ip->i_dquot[i] = NODQUOT;
d814 3
a816 2
	if (error = bread(ump->um_devvp, fsbtodb(fs, ino_to_fsba(fs, ino)),
	    (int)fs->fs_bsize, NOCRED, &bp)) {
d835 2
a836 1
	if (error = ufs_vinit(mp, ffs_specop_p, FFS_FIFOOPS, &vp)) {
d904 1
@


1.2
log
@complete ufs -> ffs change (From John Kohl; PR #1403)
@
text
@d1 1
a1 1
/*	$NetBSD: ffs_vfsops.c,v 1.16.2.1 1995/11/01 00:06:34 jtc Exp $	*/
d300 1
a300 1
	struct fs *fs;
d303 1
d322 3
a324 3
	fs = (struct fs *)bp->b_data;
	if (fs->fs_magic != FS_MAGIC || fs->fs_bsize > MAXBSIZE ||
	    fs->fs_bsize < sizeof(struct fs)) {
d329 8
a336 3
	bcopy(&fs->fs_csp[0], &((struct fs *)bp->b_data)->fs_csp[0],
	    sizeof(fs->fs_csp));
	bcopy(bp->b_data, fs, (u_int)fs->fs_sbsize);
d357 9
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ffs_vfsops.c,v 1.16 1995/06/18 14:48:22 cgd Exp $	*/
d66 2
a67 2
struct vfsops ufs_vfsops = {
	MOUNT_UFS,
d108 1
a108 1
	mp->mnt_op = &ufs_vfsops;
d490 1
a490 1
	mp->mnt_stat.f_fsid.val[1] = makefstype(MOUNT_UFS);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
