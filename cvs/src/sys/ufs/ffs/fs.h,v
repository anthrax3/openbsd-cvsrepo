head	1.42;
access;
symbols
	OPENBSD_6_0:1.41.0.8
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.4
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.6
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.35.0.18
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.16
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.14
	OPENBSD_5_0:1.35.0.12
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.35.0.10
	OPENBSD_4_9_BASE:1.35
	OPENBSD_4_8:1.35.0.8
	OPENBSD_4_8_BASE:1.35
	OPENBSD_4_7:1.35.0.4
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.6
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.33.0.4
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.17.0.4
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.2
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.12
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.10
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.8
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.12.0.6
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.6
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2016.11.27.13.27.55;	author reyk;	state Exp;
branches;
next	1.41;
commitid	aWbnE1CS7mXLWAuN;

1.41
date	2015.01.20.18.08.16;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	WmjopUuWwzSWEYgG;

1.40
date	2014.05.29.12.02.50;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2013.11.12.14.20.52;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2013.06.18.21.06.03;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2013.04.23.20.42.38;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.06.18.01.45;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2008.11.02.08.53.06;	author otto;	state Exp;
branches;
next	1.33;

1.33
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.01.07.03.27;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.01.06.50.56;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.03.20.11.55;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.23.10.18.30;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.20.16.30.31;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2007.03.19.13.27.47;	author pedro;	state Exp;
branches;
next	1.26;

1.26
date	2007.02.17.14.32.38;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2007.01.07.15.37.23;	author sturm;	state Exp;
branches;
next	1.24;

1.24
date	2006.04.12.03.46.52;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2006.04.02.22.28.32;	author pedro;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.02.16.58.52;	author pedro;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.31.08.13.07;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.22.13.39.10;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.09.13.35.02;	author pedro;	state Exp;
branches;
next	1.18;

1.18
date	2005.12.28.20.48.18;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.01.13.30.50;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.20.03.44.06;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.26.16.10.57;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.25.23.26.55;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.19.16.22.16;	author gluk;	state Exp;
branches;
next	1.11;

1.11
date	2001.04.13.02.39.04;	author gluk;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.07.17.25.38;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.04.06.20.43.30;	author gluk;	state Exp;
branches;
next	1.8;

1.8
date	98.11.29.00.45.30;	author art;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	97.11.06.05.59.21;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.21.39;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.26.32;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.05.30.08.34.28;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.02.24.14.27.13;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.02.11.06.59.28;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches;
next	;

1.8.6.1
date	2001.05.14.22.47.41;	author niklas;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2001.07.04.11.00.53;	author niklas;	state Exp;
branches;
next	1.8.6.3;

1.8.6.3
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.8.6.4;

1.8.6.4
date	2004.02.19.11.01.41;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Fix signedness warnings with careful casts and replace a re-defined variable.
(Missed this chunk as part of previous commit to libsa/ufs.c)

OK krw@@
@
text
@/*	$OpenBSD: fs.h,v 1.41 2015/01/20 18:08:16 deraadt Exp $	*/
/*	$NetBSD: fs.h,v 1.6 1995/04/12 21:21:02 mycroft Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fs.h	8.10 (Berkeley) 10/27/94
 */

/*
 * Each disk drive contains some number of file systems.
 * A file system consists of a number of cylinder groups.
 * Each cylinder group has inodes and data.
 *
 * A file system is described by its super-block, which in turn
 * describes the cylinder groups.  The super-block is critical
 * data and is replicated in each cylinder group to protect against
 * catastrophic loss.  This is done at `newfs' time and the critical
 * super-block data does not change, so the copies need not be
 * referenced further unless disaster strikes.
 *
 * For file system fs, the offsets of the various blocks of interest
 * are given in the super block as:
 *	[fs->fs_sblkno]		Super-block
 *	[fs->fs_cblkno]		Cylinder group block
 *	[fs->fs_iblkno]		Inode blocks
 *	[fs->fs_dblkno]		Data blocks
 * The beginning of cylinder group cg in fs, is given by
 * the ``cgbase(fs, cg)'' macro.
 *
 * The first boot and super blocks are given in absolute disk addresses.
 * The byte-offset forms are preferred, as they don't imply a sector size.
 */
#define BBSIZE		8192
#define SBSIZE		8192
#define	BBOFF		((off_t)(0))
#define	SBOFF		((off_t)(BBOFF + BBSIZE))
#define	BBLOCK		((daddr_t)(0))
#define	SBLOCK		((daddr_t)(BBLOCK + BBSIZE / DEV_BSIZE))
#define	SBLOCK_UFS1	8192
#define	SBLOCK_UFS2	65536
#define	SBLOCK_PIGGY	262144
#define	SBLOCKSIZE	8192
#define	SBLOCKSEARCH \
	{ SBLOCK_UFS2, SBLOCK_UFS1, SBLOCK_PIGGY, -1 }

/*
 * Addresses stored in inodes are capable of addressing fragments
 * of `blocks'. File system blocks of at most size MAXBSIZE can 
 * be optionally broken into 2, 4, or 8 pieces, each of which is
 * addressible; these pieces may be DEV_BSIZE, or some multiple of
 * a DEV_BSIZE unit.
 *
 * Large files consist of exclusively large data blocks.  To avoid
 * undue wasted disk space, the last data block of a small file may be
 * allocated as only as many fragments of a large block as are
 * necessary.  The file system format retains only a single pointer
 * to such a fragment, which is a piece of a single large block that
 * has been divided.  The size of such a fragment is determinable from
 * information in the inode, using the ``blksize(fs, ip, lbn)'' macro.
 *
 * The file system records space availability at the fragment level;
 * to determine block availability, aligned fragments are examined.
 */

#define MAXFRAG 	8

/*
 * MINBSIZE is the smallest allowable block size.
 * In order to insure that it is possible to create files of size
 * 2^32 with only two levels of indirection, MINBSIZE is set to 4096.
 * MINBSIZE must be big enough to hold a cylinder group block,
 * thus changes to (struct cg) must keep its size within MINBSIZE.
 * Note that super blocks are always of size SBSIZE,
 * and that both SBSIZE and MAXBSIZE must be >= MINBSIZE.
 */
#define MINBSIZE	4096

/*
 * The path name on which the file system is mounted is maintained
 * in fs_fsmnt. MAXMNTLEN defines the amount of space allocated in
 * the super block for this name.
 */
#define MAXMNTLEN	468

/*
 * The volume name for this file system is kept in fs_volname.
 * MAXVOLLEN defines the length of the buffer allocated.
 */
#define MAXVOLLEN	32

/*
 * There is a 128-byte region in the superblock reserved for in-core
 * pointers to summary information. Originally this included an array
 * of pointers to blocks of struct csum; now there are just three
 * pointers and the remaining space is padded with fs_ocsp[].
 *
 * NOCSPTRS determines the size of this padding. One pointer (fs_csp)
 * is taken away to point to a contiguous array of struct csum for
 * all cylinder groups; a second (fs_maxcluster) points to an array
 * of cluster sizes that is computed as cylinder groups are inspected,
 * and the third points to an array that tracks the creation of new
 * directories.
 */
#define NOCSPTRS	((128 / sizeof(void *)) - 4)

/*
 * A summary of contiguous blocks of various sizes is maintained
 * in each cylinder group. Normally this is set by the initial
 * value of fs_maxcontig. To conserve space, a maximum summary size
 * is set by FS_MAXCONTIG.
 */
#define FS_MAXCONTIG	16

/*
 * MINFREE gives the minimum acceptable percentage of file system
 * blocks which may be free. If the freelist drops below this level
 * only the superuser may continue to allocate blocks. This may
 * be set to 0 if no reserve of free blocks is deemed necessary,
 * however throughput drops by fifty percent if the file system
 * is run at between 95% and 100% full; thus the minimum default
 * value of fs_minfree is 5%. However, to get good clustering
 * performance, 10% is a better choice. With 5% free space,
 * fragmentation is not a problem, so we choose to optimize for time.
 */
#define MINFREE		5
#define DEFAULTOPT	FS_OPTTIME

/*
 * The directory preference algorithm(dirpref) can be tuned by adjusting
 * the following parameters which tell the system the average file size
 * and the average number of files per directory. These defaults are well
 * selected for typical filesystems, but may need to be tuned for odd
 * cases like filesystems being used for squid caches or news spools.
 */
#define AVFILESIZ	16384	/* expected average file size */
#define AFPDIR		64	/* expected number of files per directory */

/*
 * Size of superblock space reserved for snapshots.
 */
#define FSMAXSNAP	20

/*
 * Per cylinder group information; summarized in blocks allocated
 * from first cylinder group data blocks.  These blocks have to be
 * read in from fs_csaddr (size fs_cssize) in addition to the
 * super block.
 */
struct csum {
	int32_t	cs_ndir;		/* number of directories */
	int32_t	cs_nbfree;		/* number of free blocks */
	int32_t	cs_nifree;		/* number of free inodes */
	int32_t	cs_nffree;		/* number of free frags */
};

struct csum_total {
	int64_t cs_ndir;		/* number of directories */
	int64_t cs_nbfree;		/* number of free blocks */
	int64_t cs_nifree;		/* number of free inodes */
	int64_t cs_nffree;		/* number of free frags */
	int64_t cs_spare[4];		/* future expansion */
};

/*
 * Super block for an FFS file system.
 */
struct fs {
	int32_t	 fs_firstfield;		/* historic file system linked list, */
	int32_t	 fs_unused_1;		/*     used for incore super blocks */
	int32_t	 fs_sblkno;		/* addr of super-block / frags */
	int32_t	 fs_cblkno;		/* offset of cyl-block / frags */
	int32_t	 fs_iblkno;		/* offset of inode-blocks / frags */
	int32_t	 fs_dblkno;		/* offset of first data / frags */
	int32_t	 fs_cgoffset;		/* cylinder group offset in cylinder */
	int32_t	 fs_cgmask;		/* used to calc mod fs_ntrak */
	int32_t	 fs_ffs1_time;		/* last time written */
	int32_t	 fs_ffs1_size;		/* # of blocks in fs / frags */
	int32_t	 fs_ffs1_dsize;		/* # of data blocks in fs */
	int32_t	 fs_ncg;		/* # of cylinder groups */
	int32_t	 fs_bsize;		/* size of basic blocks / bytes */
	int32_t	 fs_fsize;		/* size of frag blocks / bytes */
	int32_t	 fs_frag;		/* # of frags in a block in fs */
/* these are configuration parameters */
	int32_t	 fs_minfree;		/* minimum percentage of free blocks */
	int32_t	 fs_rotdelay;		/* # of ms for optimal next block */
	int32_t	 fs_rps;		/* disk revolutions per second */
/* these fields can be computed from the others */
	int32_t	 fs_bmask;		/* ``blkoff'' calc of blk offsets */
	int32_t	 fs_fmask;		/* ``fragoff'' calc of frag offsets */
	int32_t	 fs_bshift;		/* ``lblkno'' calc of logical blkno */
	int32_t	 fs_fshift;		/* ``numfrags'' calc # of frags */
/* these are configuration parameters */
	int32_t	 fs_maxcontig;		/* max # of contiguous blks */
	int32_t	 fs_maxbpg;		/* max # of blks per cyl group */
/* these fields can be computed from the others */
	int32_t	 fs_fragshift;		/* block to frag shift */
	int32_t	 fs_fsbtodb;		/* fsbtodb and dbtofsb shift constant */
	int32_t	 fs_sbsize;		/* actual size of super block */
	int32_t	 fs_csmask;		/* csum block offset (now unused) */
	int32_t	 fs_csshift;		/* csum block number (now unused) */
	int32_t	 fs_nindir;		/* value of NINDIR */
	int32_t	 fs_inopb;		/* inodes per file system block */
	int32_t	 fs_nspf;		/* DEV_BSIZE sectors per frag */
/* yet another configuration parameter */
	int32_t	 fs_optim;		/* optimization preference, see below */
/* these fields are derived from the hardware */
	int32_t	 fs_npsect;		/* DEV_BSIZE sectors/track + spares */
	int32_t	 fs_interleave;		/* DEV_BSIZE sector interleave */
	int32_t	 fs_trackskew;		/* sector 0 skew, per track */
/* fs_id takes the space of the unused fs_headswitch and fs_trkseek fields */
	int32_t  fs_id[2];		/* unique filesystem id */
/* sizes determined by number of cylinder groups and their sizes */
	int32_t	 fs_ffs1_csaddr;	/* blk addr of cyl grp summary area */
	int32_t	 fs_cssize;		/* cyl grp summary area size / bytes */
	int32_t	 fs_cgsize;		/* cyl grp block size / bytes */
/* these fields are derived from the hardware */
	int32_t	 fs_ntrak;		/* tracks per cylinder */
	int32_t	 fs_nsect;		/* DEV_BSIZE sectors per track */
	int32_t	 fs_spc;		/* DEV_BSIZE sectors per cylinder */
/* this comes from the disk driver partitioning */
	int32_t	 fs_ncyl;		/* cylinders in file system */
/* these fields can be computed from the others */
	int32_t	 fs_cpg;		/* cylinders per group */
	int32_t	 fs_ipg;		/* inodes per group */
	int32_t	 fs_fpg;		/* blocks per group * fs_frag */
/* this data must be re-computed after crashes */
	struct	csum fs_ffs1_cstotal;	/* cylinder summary information */
/* these fields are cleared at mount time */
	int8_t	 fs_fmod;		/* super block modified flag */
	int8_t	 fs_clean;		/* file system is clean flag */
	int8_t	 fs_ronly;		/* mounted read-only flag */
	int8_t	 fs_ffs1_flags;		/* see FS_ below */
	u_char	 fs_fsmnt[MAXMNTLEN];	/* name mounted on */
	u_char	 fs_volname[MAXVOLLEN];	/* volume name */
	u_int64_t fs_swuid;		/* system-wide uid */
	int32_t	 fs_pad;		/* due to alignment of fs_swuid */
/* these fields retain the current block allocation info */
	int32_t	 fs_cgrotor;		/* last cg searched */
	void    *fs_ocsp[NOCSPTRS];	/* padding; was list of fs_cs buffers */
	u_int8_t *fs_contigdirs;	/* # of contiguously allocated dirs */
	struct csum *fs_csp;		/* cg summary info buffer for fs_cs */
	int32_t	*fs_maxcluster;		/* max cluster in each cyl group */
	u_char	*fs_active;		/* reserved for snapshots */
	int32_t	 fs_cpc;		/* cyl per cycle in postbl */
/* this area is only allocated if fs_ffs1_flags & FS_FLAGS_UPDATED */
	int32_t	 fs_maxbsize;           /* maximum blocking factor permitted */
	int64_t	 fs_spareconf64[17];    /* old rotation block list head */
	int64_t	 fs_sblockloc;          /* offset of standard super block */
	struct	csum_total fs_cstotal;  /* cylinder summary information */
	int64_t	 fs_time;               /* time last written */
	int64_t	 fs_size;               /* number of blocks in fs */
	int64_t	 fs_dsize;              /* number of data blocks in fs */
	int64_t	 fs_csaddr;             /* blk addr of cyl grp summary area */
	int64_t	 fs_pendingblocks;      /* blocks in process of being freed */
	int32_t	 fs_pendinginodes;      /* inodes in process of being freed */
	int32_t	 fs_snapinum[FSMAXSNAP];/* space reserved for snapshots */
/* back to stuff that has been around a while */
	int32_t	 fs_avgfilesize;	/* expected average file size */
	int32_t	 fs_avgfpdir;		/* expected # of files per directory */
	int32_t	 fs_sparecon[26];	/* reserved for future constants */
	u_int32_t fs_flags;		/* see FS_ flags below */
	int32_t	 fs_fscktime;		/* last time fsck(8)ed */
	int32_t	 fs_contigsumsize;	/* size of cluster summary array */ 
	int32_t	 fs_maxsymlinklen;	/* max length of an internal symlink */
	int32_t	 fs_inodefmt;		/* format of on-disk inodes */
	u_int64_t fs_maxfilesize;	/* maximum representable file size */
	int64_t	 fs_qbmask;		/* ~fs_bmask - for use with quad size */
	int64_t	 fs_qfmask;		/* ~fs_fmask - for use with quad size */
	int32_t	 fs_state;		/* validate fs_clean field */
	int32_t	 fs_postblformat;	/* format of positional layout tables */
	int32_t	 fs_nrpos;		/* number of rotational positions */
	int32_t	 fs_postbloff;		/* (u_int16) rotation block list head */
	int32_t	 fs_rotbloff;		/* (u_int8) blocks for each rotation */
	int32_t	 fs_magic;		/* magic number */
	u_int8_t fs_space[1];		/* list of blocks for each rotation */
/* actually longer */
};

/*
 * Filesystem identification
 */
#define	FS_MAGIC	0x011954	/* the fast filesystem magic number */
#define	FS_UFS1_MAGIC	0x011954	/* the fast filesystem magic number */
#define	FS_UFS2_MAGIC	0x19540119	/* UFS fast filesystem magic number */
#define	FS_OKAY		0x7c269d38	/* superblock checksum */
#define FS_42INODEFMT	-1		/* 4.2BSD inode format */
#define FS_44INODEFMT	2		/* 4.4BSD inode format */

/*
 * Filesystem clean flags
 */
#define	FS_ISCLEAN	0x01
#define	FS_WASCLEAN	0x02

/*
 * Preference for optimization.
 */
#define FS_OPTTIME	0	/* minimize allocation time */
#define FS_OPTSPACE	1	/* minimize disk fragmentation */

/* 
 * Filesystem flags.
 */
#define FS_UNCLEAN	0x01	/* filesystem not clean at mount */
#define FS_DOSOFTDEP	0x02	/* filesystem using soft dependencies */
/*
 * The following flag is used to detect a FFS1 file system that had its flags
 * moved to the new (FFS2) location for compatibility.
 */
#define FS_FLAGS_UPDATED	0x80	/* file system has FFS2-like flags */

/*
 * Rotational layout table format types
 */
#define FS_42POSTBLFMT		-1	/* 4.2BSD rotational table format */
#define FS_DYNAMICPOSTBLFMT	1	/* dynamic rotational table format */
/*
 * Macros for access to superblock array structures
 */
#define fs_rotbl(fs) \
    (((fs)->fs_postblformat == FS_42POSTBLFMT) \
    ? ((fs)->fs_space) \
    : ((u_int8_t *)((u_int8_t *)(fs) + (fs)->fs_rotbloff)))

/*
 * The size of a cylinder group is calculated by CGSIZE. The maximum size
 * is limited by the fact that cylinder groups are at most one block.
 * Its size is derived from the size of the maps maintained in the
 * cylinder group and the (struct cg) size.
 */
#define CGSIZE(fs) \
    /* base cg */	(sizeof(struct cg) + sizeof(int32_t) + \
    /* blktot size */	(fs)->fs_cpg * sizeof(int32_t) + \
    /* blks size */	(fs)->fs_cpg * (fs)->fs_nrpos * sizeof(int16_t) + \
    /* inode map */	howmany((fs)->fs_ipg, NBBY) + \
    /* block map */	howmany((fs)->fs_fpg, NBBY) + \
    /* if present */	((fs)->fs_contigsumsize <= 0 ? 0 : \
    /* cluster sum */	(fs)->fs_contigsumsize * sizeof(int32_t) + \
    /* cluster map */	howmany(fragstoblks(fs, (fs)->fs_fpg), NBBY)))

/*
 * Convert cylinder group to base address of its global summary info.
 */
#define fs_cs(fs, indx) fs_csp[indx]

/*
 * Cylinder group block for a file system.
 */
#define	CG_MAGIC	0x090255
struct cg {
	int32_t	 cg_firstfield;		/* historic cyl groups linked list */
	int32_t	 cg_magic;		/* magic number */
	int32_t	 cg_time;		/* time last written */
	int32_t	 cg_cgx;		/* we are the cgx'th cylinder group */
	int16_t	 cg_ncyl;		/* number of cyl's this cg */
	int16_t	 cg_niblk;		/* number of inode blocks this cg */
	int32_t	 cg_ndblk;		/* number of data blocks this cg */
	struct	csum cg_cs;		/* cylinder summary information */
	int32_t	 cg_rotor;		/* position of last used block */
	int32_t	 cg_frotor;		/* position of last used frag */
	int32_t	 cg_irotor;		/* position of last used inode */
	int32_t	 cg_frsum[MAXFRAG];	/* counts of available frags */
	int32_t	 cg_btotoff;		/* (int32) block totals per cylinder */
	int32_t	 cg_boff;		/* (u_int16) free block positions */
	int32_t	 cg_iusedoff;		/* (u_int8) used inode map */
	int32_t	 cg_freeoff;		/* (u_int8) free block map */
	int32_t	 cg_nextfreeoff;	/* (u_int8) next available space */
	int32_t	 cg_clustersumoff;	/* (u_int32) counts of avail clusters */
	int32_t	 cg_clusteroff;		/* (u_int8) free cluster map */
	int32_t	 cg_nclusterblks;	/* number of clusters this cg */
	int32_t	 cg_ffs2_niblk;		/* number of inode blocks this cg */
	int32_t	 cg_initediblk;		/* last initialized inode */
	int32_t	 cg_sparecon32[3];	/* reserved for future use */
	int64_t	 cg_ffs2_time;		/* time last written */
	int64_t	 cg_sparecon64[3];	/* reserved for future use */
/* actually longer */
};

/*
 * Macros for access to cylinder group array structures
 */
#define cg_blktot(cgp) \
    (((cgp)->cg_magic != CG_MAGIC) \
    ? (((struct ocg *)(cgp))->cg_btot) \
    : ((int32_t *)((u_int8_t *)(cgp) + (cgp)->cg_btotoff)))
#define cg_blks(fs, cgp, cylno) \
    (((cgp)->cg_magic != CG_MAGIC) \
    ? (((struct ocg *)(cgp))->cg_b[cylno]) \
    : ((int16_t *)((u_int8_t *)(cgp) + \
	(cgp)->cg_boff) + (cylno) * (fs)->fs_nrpos))
#define cg_inosused(cgp) \
    (((cgp)->cg_magic != CG_MAGIC) \
    ? (((struct ocg *)(cgp))->cg_iused) \
    : ((u_int8_t *)((u_int8_t *)(cgp) + (cgp)->cg_iusedoff)))
#define cg_blksfree(cgp) \
    (((cgp)->cg_magic != CG_MAGIC) \
    ? (((struct ocg *)(cgp))->cg_free) \
    : ((u_int8_t *)((u_int8_t *)(cgp) + (cgp)->cg_freeoff)))
#define cg_chkmagic(cgp) \
    ((cgp)->cg_magic == CG_MAGIC || ((struct ocg *)(cgp))->cg_magic == CG_MAGIC)
#define cg_clustersfree(cgp) \
    ((u_int8_t *)((u_int8_t *)(cgp) + (cgp)->cg_clusteroff))
#define cg_clustersum(cgp) \
    ((int32_t *)((u_int8_t *)(cgp) + (cgp)->cg_clustersumoff))

/*
 * The following structure is defined
 * for compatibility with old file systems.
 */
struct ocg {
	int32_t	 cg_firstfield;		/* historic linked list of cyl groups */
	int32_t	 cg_unused_1;		/*     used for incore cyl groups */
	int32_t	 cg_time;		/* time last written */
	int32_t	 cg_cgx;		/* we are the cgx'th cylinder group */
	int16_t	 cg_ncyl;		/* number of cyl's this cg */
	int16_t	 cg_niblk;		/* number of inode blocks this cg */
	int32_t	 cg_ndblk;		/* number of data blocks this cg */
	struct	csum cg_cs;		/* cylinder summary information */
	int32_t	 cg_rotor;		/* position of last used block */
	int32_t	 cg_frotor;		/* position of last used frag */
	int32_t	 cg_irotor;		/* position of last used inode */
	int32_t	 cg_frsum[8];		/* counts of available frags */
	int32_t	 cg_btot[32];		/* block totals per cylinder */
	int16_t	 cg_b[32][8];		/* positions of free blocks */
	u_int8_t cg_iused[256];		/* used inode map */
	int32_t	 cg_magic;		/* magic number */
	u_int8_t cg_free[1];		/* free block map */
/* actually longer */
};

/*
 * Turn file system block numbers into disk block addresses.
 * This maps file system blocks to DEV_BSIZE (a.k.a. 512-byte) size disk
 * blocks.
 */
#define fsbtodb(fs, b)	((b) << (fs)->fs_fsbtodb)
#define	dbtofsb(fs, b)	((b) >> (fs)->fs_fsbtodb)

/*
 * Cylinder group macros to locate things in cylinder groups.
 * They calc file system addresses of cylinder group data structures.
 */
#define	cgbase(fs, c)	((daddr_t)(fs)->fs_fpg * (c))
#define	cgdata(fs, c)	(cgdmin(fs, c) + (fs)->fs_minfree)	/* data zone */
#define	cgmeta(fs, c)	(cgdmin(fs, c))				/* meta data */
#define	cgdmin(fs, c)	(cgstart(fs, c) + (fs)->fs_dblkno)	/* 1st data */
#define	cgimin(fs, c)	(cgstart(fs, c) + (fs)->fs_iblkno)	/* inode blk */
#define	cgsblock(fs, c)	(cgstart(fs, c) + (fs)->fs_sblkno)	/* super blk */
#define	cgtod(fs, c)	(cgstart(fs, c) + (fs)->fs_cblkno)	/* cg block */
#define cgstart(fs, c)							\
	(cgbase(fs, c) + (fs)->fs_cgoffset * ((c) & ~((fs)->fs_cgmask)))

/*
 * Macros for handling inode numbers:
 *     inode number to file system block offset.
 *     inode number to cylinder group number.
 *     inode number to file system block address.
 */
#define	ino_to_cg(fs, x)	((x) / (fs)->fs_ipg)
#define	ino_to_fsba(fs, x)						\
	((daddr_t)(cgimin(fs, ino_to_cg(fs, x)) +			\
	    (blkstofrags((fs), (((x) % (fs)->fs_ipg) / INOPB(fs))))))
#define	ino_to_fsbo(fs, x)	((x) % INOPB(fs))

/*
 * Give cylinder group number for a file system block.
 * Give frag block number in cylinder group for a file system block.
 */
#define	dtog(fs, d)	((d) / (fs)->fs_fpg)
#define	dtogd(fs, d)	((d) % (fs)->fs_fpg)

/*
 * Extract the bits for a block from a map.
 * Compute the cylinder and rotational position of a cyl block addr.
 */
#define blkmap(fs, map, loc) \
    (((map)[(loc) / NBBY] >> ((loc) % NBBY)) & (0xff >> (NBBY - (fs)->fs_frag)))
#define cbtocylno(fs, bno) \
    (fsbtodb(fs, bno) / (fs)->fs_spc)
#define cbtorpos(fs, bno) \
    ((fs)->fs_nrpos <= 1 ? 0 : \
     (fsbtodb(fs, bno) % (fs)->fs_spc / (fs)->fs_nsect * (fs)->fs_trackskew + \
     fsbtodb(fs, bno) % (fs)->fs_spc % (fs)->fs_nsect * (fs)->fs_interleave) % \
     (fs)->fs_nsect * (fs)->fs_nrpos / (fs)->fs_npsect)

/*
 * The following macros optimize certain frequently calculated
 * quantities by using shifts and masks in place of divisions
 * modulos and multiplications.
 */
#define blkoff(fs, loc)		/* calculates (loc % fs->fs_bsize) */ \
	((loc) & (fs)->fs_qbmask)
#define fragoff(fs, loc)	/* calculates (loc % fs->fs_fsize) */ \
	((loc) & (fs)->fs_qfmask)
#define lblktosize(fs, blk)	/* calculates ((off_t)blk * fs->fs_bsize) */ \
	((off_t)(blk) << (fs)->fs_bshift)
#define lblkno(fs, loc)		/* calculates (loc / fs->fs_bsize) */ \
	((loc) >> (fs)->fs_bshift)
#define numfrags(fs, loc)	/* calculates (loc / fs->fs_fsize) */ \
	((loc) >> (fs)->fs_fshift)
#define blkroundup(fs, size)	/* calculates roundup(size, fs->fs_bsize) */ \
	(((size) + (fs)->fs_qbmask) & (fs)->fs_bmask)
#define fragroundup(fs, size)	/* calculates roundup(size, fs->fs_fsize) */ \
	(((size) + (fs)->fs_qfmask) & (fs)->fs_fmask)
#define fragstoblks(fs, frags)	/* calculates (frags / fs->fs_frag) */ \
	((frags) >> (fs)->fs_fragshift)
#define blkstofrags(fs, blks)	/* calculates (blks * fs->fs_frag) */ \
	((blks) << (fs)->fs_fragshift)
#define fragnum(fs, fsb)	/* calculates (fsb % fs->fs_frag) */ \
	((fsb) & ((fs)->fs_frag - 1))
#define blknum(fs, fsb)		/* calculates rounddown(fsb, fs->fs_frag) */ \
	((fsb) &~ ((fs)->fs_frag - 1))

/*
 * Determine the number of available frags given a
 * percentage to hold in reserve.
 */
#define freespace(fs, percentreserved) \
	(blkstofrags((fs), (fs)->fs_cstotal.cs_nbfree) + \
	(fs)->fs_cstotal.cs_nffree - ((fs)->fs_dsize * (percentreserved) / 100))

/*
 * Determining the size of a file block in the file system.
 */
#define blksize(fs, ip, lbn) \
	(((lbn) >= NDADDR || DIP((ip), size) >= ((lbn) + 1) << (fs)->fs_bshift) \
	    ? (u_int64_t)(fs)->fs_bsize \
	    : (fragroundup(fs, blkoff(fs, DIP((ip), size)))))
#define dblksize(fs, dip, lbn) \
	(((lbn) >= NDADDR || (dip)->di_size >= ((lbn) + 1) << (fs)->fs_bshift) \
	    ? (u_int64_t)(fs)->fs_bsize \
	    : (fragroundup(fs, blkoff(fs, (dip)->di_size))))

#define sblksize(fs, size, lbn) \
        (((lbn) >= NDADDR || (size) >= ((lbn) + 1) << (fs)->fs_bshift) \
            ? (u_int64_t)(fs)->fs_bsize \
            : (fragroundup(fs, blkoff(fs, (size)))))


/*
 * Number of disk sectors per block/fragment; assumes DEV_BSIZE byte
 * sector size.
 */
#define	NSPB(fs)	((fs)->fs_nspf << (fs)->fs_fragshift)
#define	NSPF(fs)	((fs)->fs_nspf)

/* Number of inodes per file system block (fs->fs_bsize) */
#define	INOPB(fs)	((fs)->fs_inopb)
/* Number of inodes per file system fragment (fs->fs_fsize) */
#define	INOPF(fs)	((fs)->fs_inopb >> (fs)->fs_fragshift)

/*
 * Number of indirects in a file system block.
 */
#define	NINDIR(fs)	((fs)->fs_nindir)

/* Maximum file size the kernel allows.
 * Even though ffs can handle files up to 16TB, we do limit the max file
 * to 2^31 pages to prevent overflow of a 32-bit unsigned int.  The buffer
 * cache has its own checks but a little added paranoia never hurts.
 */
#define FS_KERNMAXFILESIZE(pgsiz, fs)	((u_int64_t)0x80000000 * \
    MIN((pgsiz), (fs)->fs_bsize) - 1)

extern const int inside[], around[];
extern const u_char *fragtbl[];
@


1.41
log
@MAXFRAG was always placed incorrectly in <sys/param.h>  It is primarily
used in disklabel type tools, newfs, fsck, when related to ufs or
ufs-derived filesystems, but also in a struct. Those things always include
<ufs/ffs/fs.h>.  Move it there
ok guenther, tested in ports by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.40 2014/05/29 12:02:50 krw Exp $	*/
d553 1
a553 1
	    ? (fs)->fs_bsize \
d557 1
a557 1
	    ? (fs)->fs_bsize \
d562 1
a562 1
            ? (fs)->fs_bsize \
@


1.40
log
@fsck should use the same values in checking as newfs does in creating
a filesystem. fs_nspf and its derivitives like fs_spc are DEV_BSIZE
values, not actual hardware disk sector values. Adjust initializations
accordingly.

Tweak header and man page comments to make the DEV_BSIZE'ness more
obvious for future spelunkers.

No-op for DEV_BSIZE (a.k.a. 512-byte) sector devices but should help
checking filesystems on, e.g., 4k-byte sector devices.

ok jmc@@ on the man page tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.39 2013/11/12 14:20:52 krw Exp $	*/
d90 2
@


1.39
log
@Tweak comment to explicitly mention that disk blocks are DEV_BSIZE
(a.k.a. 512-bytes) as far as ffs is concerned.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.38 2013/06/18 21:06:03 miod Exp $	*/
d227 1
a227 1
	int32_t	 fs_nspf;		/* value of NSPF */
d231 2
a232 2
	int32_t	 fs_npsect;		/* # sectors/track including spares */
	int32_t	 fs_interleave;		/* hardware sector interleave */
d242 2
a243 2
	int32_t	 fs_nsect;		/* sectors per track */
	int32_t	 fs_spc;		/* sectors per cylinder */
@


1.38
log
@sqiud -> squid
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.37 2013/06/11 16:42:18 deraadt Exp $	*/
d457 2
a458 1
 * This maps file system blocks to device size blocks.
@


1.37
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.36 2013/04/23 20:42:38 tedu Exp $	*/
d157 1
a157 1
 * cases like filesystems being used for sqiud caches or news spools.
@


1.36
log
@change ffs layout policy. try to pack meta data in close to the start of
each cylinder group, which should speed up disk access a little and fsck
substantially. adapted from freebsd.
for more info: www.mckusick.com/publications/faster_fsck.pdf
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.35 2008/11/06 18:01:45 deraadt Exp $	*/
d63 2
a64 2
#define	BBLOCK		((daddr64_t)(0))
#define	SBLOCK		((daddr64_t)(BBLOCK + BBSIZE / DEV_BSIZE))
d466 1
a466 1
#define	cgbase(fs, c)	((daddr64_t)(fs)->fs_fpg * (c))
d484 1
a484 1
	((daddr64_t)(cgimin(fs, ino_to_cg(fs, x)) +			\
@


1.35
log
@Have called pass pagesize into FS_KERNMAXFILESIZE(), because there is no
automatic symbol that has this information.  PAGE_SIZE is simply not
portable, or even fixed on some systems.
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.34 2008/11/02 08:53:06 otto Exp $	*/
d467 2
@


1.34
log
@introduce a macro for max file size, instead of hardcoding it; ok
millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.33 2008/01/05 19:49:26 otto Exp $	*/
d583 2
a584 2
#define FS_KERNMAXFILESIZE(fs)	((u_int64_t)0x80000000 * \
    MIN(PAGE_SIZE, (fs)->fs_bsize) - 1)
@


1.33
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.32 2007/06/01 07:03:27 otto Exp $	*/
d577 8
@


1.32
log
@revert previous comment "fix", must have been sleeping
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.30 2007/05/03 20:11:55 millert Exp $	*/
d63 2
a64 2
#define	BBLOCK		((daddr_t)(0))
#define	SBLOCK		((daddr_t)(BBLOCK + BBSIZE / DEV_BSIZE))
d466 1
a466 1
#define	cgbase(fs, c)	((daddr_t)((fs)->fs_fpg * (c)))
d482 1
a482 1
	((daddr_t)(cgimin(fs, ino_to_cg(fs, x)) +			\
@


1.31
log
@fix comment, fs_ipg is inode *blocks* per cylinder group
@
text
@d248 1
a248 1
	int32_t	 fs_ipg;		/* inode blocks per group */
@


1.30
log
@Update CGSIZE macro so that it is no longer based on fs_cpg.
This was part of the ffs2 changes but was not committed earlier in
order to make the userland and kernel changes independent.

NOTE: the change to newfs require an updated fs.h; building an
updated newfs with the old fs.h may result in a broken filesystem.
OK otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.29 2007/04/23 10:18:30 pedro Exp $	*/
d248 1
a248 1
	int32_t	 fs_ipg;		/* inodes per group */
@


1.29
log
@Remove 'cg_space' from 'struct cg'. Due to the alignment on 64-bit
architectures, CGSIZE() was returning something sligthly over one block.
The 'new' fsck would round this value up to a fragment boundary, and end
up trying to access memory beyond allocated space. From mickey@@, okay
pedro@@, millert@@ and otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.28 2007/04/20 16:30:31 millert Exp $	*/
d360 1
a360 1
    /* block map */	howmany((fs)->fs_cpg * (fs)->fs_spc / NSPF(fs), NBBY) +\
d363 1
a363 1
    /* cluster map */	howmany((fs)->fs_cpg * (fs)->fs_spc / NSPB(fs), NBBY)))
d500 1
a500 1
    ((bno) * NSPF(fs) / (fs)->fs_spc)
d502 3
a504 2
    (((bno) * NSPF(fs) % (fs)->fs_spc / (fs)->fs_nsect * (fs)->fs_trackskew + \
     (bno) * NSPF(fs) % (fs)->fs_spc % (fs)->fs_nsect * (fs)->fs_interleave) % \
@


1.28
log
@Do not use time_t for on-disk data structures, use int32_t instead
since time_t will have to be crank to 64 bits at some point in the
future.  OK pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.27 2007/03/19 13:27:47 pedro Exp $	*/
a399 1
	u_int8_t cg_space[1];		/* space for cylinder group maps */
@


1.27
log
@Add FFS2 fields to the superblock, change file system tools to keep
accessing FFS1 fields, okay art@@, quite some testing by ckuethe@@, simon@@
and thib@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.26 2007/02/17 14:32:38 mickey Exp $	*/
d200 1
a200 1
	time_t	 fs_ffs1_time;		/* last time written */
d286 1
a286 1
	time_t	 fs_fscktime;		/* last time fsck(8)ed */
d377 1
a377 1
	time_t	 cg_time;		/* time last written */
d438 1
a438 1
	time_t	 cg_time;		/* time last written */
@


1.26
log
@do not look for sblock at offset 0; pedro@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.25 2007/01/07 15:37:23 sturm Exp $	*/
d107 7
a113 1
#define MAXMNTLEN	512
d128 1
a128 1
#define		NOCSPTRS	((128 / sizeof(void *)) - 3)
d163 5
d180 8
d200 3
a202 3
	time_t 	 fs_time;		/* last time written */
	int32_t	 fs_size;		/* # of blocks in fs / frags */
	int32_t	 fs_dsize;		/* # of data blocks in fs */
d237 1
a237 1
	int32_t  fs_csaddr;		/* blk addr of cyl grp summary area */
d251 1
a251 1
	struct	csum fs_cstotal;	/* cylinder summary information */
d256 1
a256 1
	int8_t	 fs_flags;		/* see FS_ below */
d258 3
d267 1
d269 13
a281 2
	int16_t	 fs_opostbl[16][8];	/* old rotation block list head */
	int32_t  fs_snapinum[20];	/* reserved for snapshot inode nums */
d284 2
a285 1
	int32_t	 fs_sparecon[27];	/* reserved for future constants */
a302 2
#define	fs_opostbl_start	fs_opostbl[0][0]

d328 7
a334 3
#define FS_UNCLEAN    0x01   /* filesystem not clean at mount */
#define FS_DOSOFTDEP  0x02   /* filesystem using soft dependencies */
#define FS_FLAGS_UPDATED 0x80	/* XXX using ffs2 style superblock */
@


1.25
log
@document the unit of sizes in struct fs (bytes or frags)
some 'number' -> '#'

ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.24 2006/04/12 03:46:52 tedu Exp $	*/
a64 1
#define	SBLOCK_FLOPPY	0
d70 1
a70 1
	{ SBLOCK_UFS2, SBLOCK_UFS1, SBLOCK_FLOPPY, SBLOCK_PIGGY, -1 }
@


1.24
log
@revert the new superblock format.  it violates the rule that new
kernels and old tools are safe.
i'm leaving in the "updated" flag, so that fsck will continue to remove
it from filesystems.  the kernel no longer attempts to upgrade
superblocks and will use the old format.
post-mortem discussions have concluded that maybe jamming ffs2 fields
into random locations in the superblock is asking for trouble, and we
need to talk about this some more.  my bad for not thinking fast enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.22 2006/04/02 16:58:52 pedro Exp $	*/
d176 4
a179 4
	int32_t	 fs_sblkno;		/* addr of super-block in filesys */
	int32_t	 fs_cblkno;		/* offset of cyl-block in filesys */
	int32_t	 fs_iblkno;		/* offset of inode-blocks in filesys */
	int32_t	 fs_dblkno;		/* offset of first data after cg */
d183 6
a188 6
	int32_t	 fs_size;		/* number of blocks in fs */
	int32_t	 fs_dsize;		/* number of data blocks in fs */
	int32_t	 fs_ncg;		/* number of cylinder groups */
	int32_t	 fs_bsize;		/* size of basic blocks in fs */
	int32_t	 fs_fsize;		/* size of frag blocks in fs */
	int32_t	 fs_frag;		/* number of frags in a block in fs */
d191 1
a191 1
	int32_t	 fs_rotdelay;		/* num of ms for optimal next block */
d197 1
a197 1
	int32_t	 fs_fshift;		/* ``numfrags'' calc number of frags */
d199 2
a200 2
	int32_t	 fs_maxcontig;		/* max number of contiguous blks */
	int32_t	 fs_maxbpg;		/* max number of blks per cyl group */
d220 2
a221 2
	int32_t	 fs_cssize;		/* size of cyl grp summary area */
	int32_t	 fs_cgsize;		/* cylinder group size */
d453 1
a453 1
 * Give cylinder group block number for a file system block.
@


1.23
log
@There's no need for some comments to be so utterly cryptic
@
text
@d108 1
a108 7
#define MAXMNTLEN	468

/*
 * The volume name for this file system is kept in fs_volname.
 * MAXVOLLEN defines the length of the buffer allocated.
 */
#define MAXVOLLEN	32
d123 1
a123 1
#define NOCSPTRS	((128 / sizeof(void *)) - 4)
a157 5
 * Size of super block space reserved for snapshots.
 */
#define FSMAXSNAP	20

/*
a169 8
struct csum_total {
	int64_t	cs_ndir;		/* number of directories */
	int64_t	cs_nbfree;		/* number of free blocks */
	int64_t	cs_nifree;		/* number of free inodes */
	int64_t	cs_nffree;		/* number of free frags */
	int64_t	cs_spare[4];		/* future expansion */
};

d182 3
a184 3
	time_t 	 fs_ffs1_time;		/* last time written */
	int32_t	 fs_ffs1_size;		/* number of blocks in fs */
	int32_t	 fs_ffs1_dsize;		/* number of data blocks in fs */
d219 1
a219 1
	int32_t  fs_ffs1_csaddr;	/* blk addr of cyl grp summary area */
d233 1
a233 1
	struct	csum fs_ffs1_cstotal;	/* cylinder summary information */
d238 1
a238 1
	u_int8_t fs_ffs1_flags;		/* see FS_ below */
a239 3
	u_char	 fs_volname[MAXVOLLEN];	/* volume name */
	u_int64_t fs_swuid;		/* system-wide uid */
	int32_t	 fs_pad;		/* due to alignment of fs_swuid */
a245 1
	u_char	*fs_active;		/* reserved for snapshots */
d247 2
a248 13
/* this area is only allocated if fs_ffs1_flags & FS_FLAGS_UPDATED */
	int32_t	 fs_maxbsize;		/* maximum blocking factor permitted */
	int64_t	 fs_spareconf64[17];	/* old rotation block list head */
	int64_t	 fs_sblockloc;		/* offset of standard super block */
	struct	csum_total fs_cstotal;	/* cylinder summary information */
	int64_t	 fs_time;		/* time last written */
	int64_t	 fs_size;		/* number of blocks in fs */
	int64_t	 fs_dsize;		/* number of data blocks in fs */
	int64_t	 fs_csaddr;		/* blk addr of cyl grp summary area */
	int64_t	 fs_pendingblocks;	/* blocks in process of being freed */
	int32_t	 fs_pendinginodes;	/* inodes in process of being freed */
	int32_t	 fs_snapinum[FSMAXSNAP];/* space reserved for snapshots */
/* back to stuff that has been around a while */
d251 1
a251 2
	int32_t	 fs_sparecon[26];	/* reserved for future constants */
	u_int32_t fs_flags;		/* see FS_ flags below */
d269 1
a269 13
#ifndef _KERNEL
/*
 * Trick userland tools into accessing FFS1 fields until they all get switched
 * to correctly use the new ones.
 */
#define fs_opostbl_start	fs_maxbsize
#define fs_flags		fs_ffs1_flags
#define fs_time			fs_ffs1_time
#define fs_size			fs_ffs1_size
#define fs_dsize		fs_ffs1_dsize
#define fs_csaddr		fs_ffs1_csaddr
#define fs_cstotal		fs_ffs1_cstotal
#endif /* !_KERNEL */
d296 3
a298 7
#define FS_UNCLEAN		0x01	/* file system not clean at mount */
#define FS_DOSOFTDEP		0x02	/* file system using softdeps */
/*
 * The following flag is used to detect a FFS1 file system that had its flags
 * moved to the new (FFS2) location for compatibility.
 */
#define FS_FLAGS_UPDATED	0x80	/* file system has FFS2-like flags */
@


1.22
log
@In the cylinder groups, use part of the reserved space to sprinkle a
couple of new fields needed by FFS2, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.21 2006/03/31 08:13:07 pedro Exp $	*/
d227 1
a227 1
	int32_t	 fs_inopb;		/* value of INOPB */
d583 1
a583 3
/*
 * Number of inodes in a secondary storage block/fragment.
 */
d585 1
@


1.21
log
@Super block changes for FFS2, thanks to all who tested.
Silent okay after almost 3 weeks, hackers@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.20 2006/03/22 13:39:10 pedro Exp $	*/
d410 5
a414 1
	int32_t	 cg_sparecon[13];	/* reserved for future use */
@


1.20
log
@Fix comment about MINFREE, from Thordur I. Bjornsson <thib@@mi.is>
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.19 2006/03/09 13:35:02 pedro Exp $	*/
d108 7
a114 1
#define MAXMNTLEN	512
d129 1
a129 1
#define		NOCSPTRS	((128 / sizeof(void *)) - 3)
d164 5
d181 8
d201 3
a203 3
	time_t 	 fs_time;		/* last time written */
	int32_t	 fs_size;		/* number of blocks in fs */
	int32_t	 fs_dsize;		/* number of data blocks in fs */
d238 1
a238 1
	int32_t  fs_csaddr;		/* blk addr of cyl grp summary area */
d252 1
a252 1
	struct	csum fs_cstotal;	/* cylinder summary information */
d257 1
a257 1
	int8_t	 fs_flags;		/* see FS_ below */
d259 3
d268 1
d270 13
a282 2
	int16_t	 fs_opostbl[16][8];	/* old rotation block list head */
	int32_t  fs_snapinum[20];	/* reserved for snapshot inode nums */
d285 2
a286 1
	int32_t	 fs_sparecon[27];	/* reserved for future constants */
d304 13
a316 1
#define	fs_opostbl_start	fs_opostbl[0][0]
d343 7
a349 2
#define FS_UNCLEAN    0x01   /* filesystem not clean at mount */
#define FS_DOSOFTDEP  0x02   /* filesystem using soft dependencies */
@


1.19
log
@Remove option -n from newfs as well as all references to fs_postbl()
Various testing for a while, okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.18 2005/12/28 20:48:18 pedro Exp $	*/
d141 2
a142 3
 * performance, 10% is a better choice. hence we use 10% as our
 * default value. With 10% free space, fragmentation is not a
 * problem, so we choose to optimize for time.
@


1.18
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.17 2005/03/01 13:30:50 aaron Exp $	*/
d270 2
a307 5
#define fs_postbl(fs, cylno) \
    (((fs)->fs_postblformat == FS_42POSTBLFMT) \
    ? ((fs)->fs_opostbl[cylno]) \
    : ((int16_t *)((u_int8_t *)(fs) + \
	(fs)->fs_postbloff) + (cylno) * (fs)->fs_nrpos))
@


1.17
log
@Avoid 32-bit overflow by casting blk arg to lblktosize() to (off_t).  Solves
performance loss issue in some cases when reading past the 2GB boundary in
large files.  Testing by drahn@@, otto@@, danh@@, krw@@, tom@@, jaredy@@.

From FreeBSD.  tedu@@, pedro@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.16 2004/01/20 03:44:06 tedu Exp $	*/
d510 1
a510 1
	(((lbn) >= NDADDR || (ip)->i_ffs_size >= ((lbn) + 1) << (fs)->fs_bshift) \
d512 1
a512 1
	    : (fragroundup(fs, blkoff(fs, (ip)->i_ffs_size))))
@


1.16
log
@some pieces of ufs2.  help testing otto sturm
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.15 2003/08/26 16:10:57 mickey Exp $	*/
d479 2
a480 2
#define lblktosize(fs, blk)	/* calculates (blk * fs->fs_bsize) */ \
	((blk) << (fs)->fs_bshift)
@


1.15
log
@constify ffs_tables
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.14 2003/08/25 23:26:55 tedu Exp $	*/
d65 7
d274 2
@


1.14
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
few other little cleanups.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.13 2003/06/02 23:28:23 millert Exp $	*/
d533 2
a534 2
extern int inside[], around[];
extern u_char *fragtbl[];
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.12 2001/04/19 16:22:16 gluk Exp $	*/
d170 4
a173 4
	daddr_t	 fs_sblkno;		/* addr of super-block in filesys */
	daddr_t	 fs_cblkno;		/* offset of cyl-block in filesys */
	daddr_t	 fs_iblkno;		/* offset of inode-blocks in filesys */
	daddr_t	 fs_dblkno;		/* offset of first data after cg */
d213 1
a213 1
	daddr_t  fs_csaddr;		/* blk addr of cyl grp summary area */
@


1.12
log
@Cleanup dirpref and synhronize superblock with freebsd.
From FreeBSD with little changes.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.11 2001/04/13 02:39:04 gluk Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@Fix overflow in superblock. From FreeBSD.

FreeBSD's log:
> The ffs superblock includes a 128-byte region for use by temporary
> in-core pointers to summary information. An array in this region
> (fs_csp) could overflow on filesystems with a very large number of
> cylinder groups (~16000 on i386 with 8k blocks). When this happens,
> other fields in the superblock get corrupted, and fsck refuses to
> check the filesystem.
>
> Solve this problem by replacing the fs_csp array in 'struct fs'
> with a single pointer, and add padding to keep the length of the
> 128-byte region fixed. Update the kernel and userland utilities
> to use just this single pointer.
>
> With this change, the kernel no longer makes use of the superblock
> fields 'fs_csshift' and 'fs_csmask'. Add a comment to newfs/mkfs.c
> to indicate that these fields must be calculated for compatibility
> with older kernels.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.10 2001/04/07 17:25:38 millert Exp $	*/
d120 1
a120 1
#define		NOCSPTRS	((128 / sizeof(void *)) - 2)
d146 10
d241 1
d246 1
a246 7
#if LONG_BIT == 64
	int32_t	 fs_sparecon[45];	/* reserved for future constants */
#else
	int32_t	 fs_sparecon[46];	/* reserved for future constants */
#endif
/* these fields used in dirpref routine for optimization */
	u_int8_t *fs_contigdirs;	/* # of contiguously allocated dirs */
d249 1
@


1.10
log
@Reduce the count of fs_sparecon's by 1 for 64 bit architectures
since fs_contigdirs takes 64 bits on those platforms.  This fixes
a problem on alpha where "struct fs" grew.  A better solution is
to make fs_csp into a pointer and use the remainder for pointer
spares and allocate fs_contigdirs from those.  This will happen
some time post-2.9.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.9 2001/04/06 20:43:30 gluk Exp $	*/
d108 11
a118 6
 * The limit on the amount of summary information per file system
 * is defined by MAXCSBUFS. It is currently parameterized for a
 * size of 128 bytes (2 million cylinder groups on machines with
 * 32-bit pointers, and 1 million on 64-bit machines). One pointer
 * is taken away to point to an array of cluster sizes that is
 * computed as cylinder groups are inspected.
d120 1
a120 1
#define	MAXCSBUFS	((128 / sizeof(void *)) - 1)
a149 3
 *
 * N.B. sizeof(struct csum) must be a power of two in order for
 * the ``fs_cs'' macro to work (see below).
d193 2
a194 2
	int32_t	 fs_csmask;		/* csum block offset */
	int32_t	 fs_csshift;		/* csum block number */
d230 3
a232 2
	struct	csum *fs_csp[MAXCSBUFS];/* list of fs_cs info buffers */
	int32_t	 *fs_maxcluster;	/* max cluster in each cyl group */
a322 2
 *
 * N.B. This macro assumes that sizeof(struct csum) is a power of two.
d324 1
a324 2
#define fs_cs(fs, indx) \
	fs_csp[(indx) >> (fs)->fs_csshift][(indx) & ~(fs)->fs_csmask]
@


1.9
log
@Replace FFS directory preference algorithm(dirpref) by new one.
It allocates directory inode in the same cylinder group as a parent
directory in. This speedup file/directory intensive operations on
a big file systems in times.

Don't forget to recompile fsck_ffs with updated fs.h or you will get
"VALUES IN SUPER BLOCK DISAGREE WITH THOSE IN FIRST ALTERNATE" at
the next boot. In any case you can ignore this error safely.

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.8 1998/11/29 00:45:30 art Exp $	*/
d232 3
d236 1
@


1.8
log
@spleling
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.7 1997/11/06 05:59:21 csapuntz Exp $	*/
d232 5
a236 1
	int32_t	 fs_sparecon[49];	/* reserved for future constants */
@


1.8.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.11 2001/04/13 02:39:04 gluk Exp $	*/
d108 6
a113 11
 * There is a 128-byte region in the superblock reserved for in-core
 * pointers to summary information. Originally this included an array
 * of pointers to blocks of struct csum; now there are just three
 * pointers and the remaining space is padded with fs_ocsp[].
 *
 * NOCSPTRS determines the size of this padding. One pointer (fs_csp)
 * is taken away to point to a contiguous array of struct csum for
 * all cylinder groups; a second (fs_maxcluster) points to an array
 * of cluster sizes that is computed as cylinder groups are inspected,
 * and the third points to an array that tracks the creation of new
 * directories.
d115 1
a115 1
#define		NOCSPTRS	((128 / sizeof(void *)) - 2)
d145 3
d191 2
a192 2
	int32_t	 fs_csmask;		/* csum block offset (now unused) */
	int32_t	 fs_csshift;		/* csum block number (now unused) */
d228 2
a229 3
	void    *fs_ocsp[NOCSPTRS];	/* padding; was list of fs_cs buffers */
	struct csum *fs_csp;		/* cg summary info buffer for fs_cs */
	int32_t	*fs_maxcluster;		/* max cluster in each cyl group */
d232 1
a232 9
#if LONG_BIT == 64
	int32_t	 fs_sparecon[45];	/* reserved for future constants */
#else
	int32_t	 fs_sparecon[46];	/* reserved for future constants */
#endif
/* these fields used in dirpref routine for optimization */
	u_int8_t *fs_contigdirs;	/* # of contiguously allocated dirs */
	int32_t	 fs_avgfilesize;	/* expected average file size */
	int32_t	 fs_avgfpdir;		/* expected # of files per directory */
d312 2
d315 2
a316 1
#define fs_cs(fs, indx) fs_csp[indx]
@


1.8.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.8.6.1 2001/05/14 22:47:41 niklas Exp $	*/
d120 1
a120 1
#define		NOCSPTRS	((128 / sizeof(void *)) - 3)
a145 10
 * The directory preference algorithm(dirpref) can be tuned by adjusting
 * the following parameters which tell the system the average file size
 * and the average number of files per directory. These defaults are well
 * selected for typical filesystems, but may need to be tuned for odd
 * cases like filesystems being used for sqiud caches or news spools.
 */
#define AVFILESIZ	16384	/* expected average file size */
#define AFPDIR		64	/* expected number of files per directory */

/*
a230 1
	u_int8_t *fs_contigdirs;	/* # of contiguously allocated dirs */
d235 7
a241 1
	int32_t  fs_snapinum[20];	/* reserved for snapshot inode nums */
a243 1
	int32_t	 fs_sparecon[27];	/* reserved for future constants */
@


1.8.6.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.8.6.2 2001/07/04 11:00:53 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8.6.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a64 7
#define	SBLOCK_FLOPPY	0
#define	SBLOCK_UFS1	8192
#define	SBLOCK_UFS2	65536
#define	SBLOCK_PIGGY	262144
#define	SBLOCKSIZE	8192
#define	SBLOCKSEARCH \
	{ SBLOCK_UFS2, SBLOCK_UFS1, SBLOCK_FLOPPY, SBLOCK_PIGGY, -1 }
d170 4
a173 4
	int32_t	 fs_sblkno;		/* addr of super-block in filesys */
	int32_t	 fs_cblkno;		/* offset of cyl-block in filesys */
	int32_t	 fs_iblkno;		/* offset of inode-blocks in filesys */
	int32_t	 fs_dblkno;		/* offset of first data after cg */
d213 1
a213 1
	int32_t  fs_csaddr;		/* blk addr of cyl grp summary area */
a266 2
#define	FS_UFS1_MAGIC	0x011954	/* the fast filesystem magic number */
#define	FS_UFS2_MAGIC	0x19540119	/* UFS fast filesystem magic number */
d533 2
a534 2
extern const int inside[], around[];
extern const u_char *fragtbl[];
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.6 1997/10/06 20:21:39 deraadt Exp $	*/
d271 1
a271 1
 * Filesystem falgs.
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.4 1997/05/30 08:34:28 downsj Exp $	*/
d224 1
a224 1
	int8_t	 fs_flags;		/* currently unused flag */
d270 6
d498 6
@


1.5
log
@VFS Lite2 Changes
@
text
@d224 1
a224 1
	int8_t	 fs_flags;		/* see FS_ below */
a269 6
/* 
 * Filesystem falgs.
 */
#define FS_UNCLEAN    0x01   /* filesystem not clean at mount */
#define FS_DOSOFTDEP  0x02   /* filesystem using soft dependencies */

a491 6

#define sblksize(fs, size, lbn) \
        (((lbn) >= NDADDR || (size) >= ((lbn) + 1) << (fs)->fs_bshift) \
            ? (fs)->fs_bsize \
            : (fragroundup(fs, blkoff(fs, (size)))))

@


1.4
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.3 1997/02/24 14:27:13 niklas Exp $	*/
d224 1
a224 1
	int8_t	 fs_flags;		/* currently unused flag */
d270 6
d498 6
@


1.3
log
@OpenBSD tags
@
text
@d1 1
a1 1
/*	$OpenBSD: fs.h,v 1.6 1995/04/12 21:21:02 mycroft Exp $	*/
d485 1
a485 1
	(((lbn) >= NDADDR || (ip)->i_size >= ((lbn) + 1) << (fs)->fs_bshift) \
d487 1
a487 1
	    : (fragroundup(fs, blkoff(fs, (ip)->i_size))))
@


1.2
log
@Add fs_id support and random inode generation numbers for ffs.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d201 2
a202 2
	int32_t	 fs_headswitch;		/* head switch time, usec */
	int32_t	 fs_trkseek;		/* track-to-track seek, usec */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
