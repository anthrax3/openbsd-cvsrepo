head	1.44;
access;
symbols
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.44.0.4
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.37.0.8
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.6
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.4
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.36.0.14
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.12
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.8
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.10
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.6
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.4
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.31.0.2
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.26.0.2
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.24.0.10
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.8
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.6
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.22.0.6
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.22
	UBC:1.21.0.2
	UBC_BASE:1.21
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2015.11.28.21.52.02;	author beck;	state Exp;
branches;
next	1.43;
commitid	RTnjsXZgItH5OlTY;

1.43
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.42;
commitid	p4LJxGKbi0BU2cG6;

1.42
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.41;
commitid	EF98ch02VpFassUi;

1.41
date	2014.05.22.02.02.39;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2014.01.25.23.31.12;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2013.04.23.20.42.38;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.27.16.22.14;	author martynas;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.01.18.54.27;	author pedro;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.01.06.38.54;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.31;

1.31
date	2007.01.17.20.47.13;	author sturm;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.16.21.04.31;	author sturm;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.14.21.50.05;	author pedro;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.12.14.33.01;	author pedro;	state Exp;
branches;
next	1.27;

1.27
date	2007.01.11.08.47.52;	author pedro;	state Exp;
branches;
next	1.26;

1.26
date	2006.03.11.21.00.48;	author pedro;	state Exp;
branches;
next	1.25;

1.25
date	2005.12.28.20.48.17;	author pedro;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.26.18.33.16;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.10.04.45.32;	author art;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.21.21.23.56;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.13.16.01.10;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.13.00.10.56;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.27.04.58.48;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.23.02.07.53;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.20.19.33.06;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.15.11.43.20;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.20.14.41.57;	author art;	state Exp;
branches;
next	1.9;

1.9
date	99.05.27.20.36.21;	author art;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	99.02.26.03.56.30;	author art;	state Exp;
branches;
next	1.7;

1.7
date	99.01.11.05.12.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	97.11.06.05.59.17;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.20.21.34;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.15.26.29;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	97.05.30.08.34.19;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.27.35;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches;
next	;

1.9.4.1
date	2001.05.14.22.47.40;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2001.07.04.11.00.48;	author niklas;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.9.4.6;

1.9.4.6
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	;

1.21.2.1
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.44
log
@move buffer size adjustment to buf_adjcnt - from Walter Neto
ok mpi@@
@
text
@/*	$OpenBSD: ffs_balloc.c,v 1.43 2015/03/14 03:38:52 jsg Exp $	*/
/*	$NetBSD: ffs_balloc.c,v 1.3 1996/02/09 22:22:21 christos Exp $	*/

/*
 * Copyright (c) 2002 Networks Associates Technology, Inc.
 * All rights reserved.
 *
 * This software was developed for the FreeBSD Project by Marshall
 * Kirk McKusick and Network Associates Laboratories, the Security
 * Research Division of Network Associates, Inc. under DARPA/SPAWAR
 * contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA CHATS
 * research program.
 *
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ffs_balloc.c	8.4 (Berkeley) 9/23/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/proc.h>
#include <sys/mount.h>
#include <sys/vnode.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/ffs/fs.h>
#include <ufs/ffs/ffs_extern.h>

int ffs1_balloc(struct inode *, off_t, int, struct ucred *, int, struct buf **);
#ifdef FFS2
int ffs2_balloc(struct inode *, off_t, int, struct ucred *, int, struct buf **);
#endif

/*
 * Balloc defines the structure of file system storage
 * by allocating the physical blocks on a device given
 * the inode and the logical block number in a file.
 */
int
ffs1_balloc(struct inode *ip, off_t startoffset, int size, struct ucred *cred,
    int flags, struct buf **bpp)
{
	daddr_t lbn, nb, newb, pref;
	struct fs *fs;
	struct buf *bp, *nbp;
	struct vnode *vp;
	struct proc *p;
	struct indir indirs[NIADDR + 2];
	int32_t *bap;
	int deallocated, osize, nsize, num, i, error;
	int32_t *allocib, *blkp, *allocblk, allociblk[NIADDR+1];
	int unwindidx = -1;

	vp = ITOV(ip);
	fs = ip->i_fs;
	p = curproc;
	lbn = lblkno(fs, startoffset);
	size = blkoff(fs, startoffset) + size;
	if (size > fs->fs_bsize)
		panic("ffs1_balloc: blk too big");
	if (bpp != NULL)
		*bpp = NULL;
	if (lbn < 0)
		return (EFBIG);

	/*
	 * If the next write will extend the file into a new block,
	 * and the file is currently composed of a fragment
	 * this fragment has to be extended to be a full block.
	 */
	nb = lblkno(fs, ip->i_ffs1_size);
	if (nb < NDADDR && nb < lbn) {
		osize = blksize(fs, ip, nb);
		if (osize < fs->fs_bsize && osize > 0) {
			error = ffs_realloccg(ip, nb,
			    ffs1_blkpref(ip, nb, (int)nb, &ip->i_ffs1_db[0]),
			    osize, (int)fs->fs_bsize, cred, bpp, &newb);
			if (error)
				return (error);
			if (DOINGSOFTDEP(vp))
				softdep_setup_allocdirect(ip, nb, newb,
				    ip->i_ffs1_db[nb], fs->fs_bsize, osize,
				    bpp ? *bpp : NULL);

			ip->i_ffs1_size = lblktosize(fs, nb + 1);
			uvm_vnp_setsize(vp, ip->i_ffs1_size);
			ip->i_ffs1_db[nb] = newb;
			ip->i_flag |= IN_CHANGE | IN_UPDATE;
			if (bpp != NULL) {
				if (flags & B_SYNC)
					bwrite(*bpp);
				else
					bawrite(*bpp);
			}
		}
	}
	/*
	 * The first NDADDR blocks are direct blocks
	 */
	if (lbn < NDADDR) {
		nb = ip->i_ffs1_db[lbn];
		if (nb != 0 && ip->i_ffs1_size >= lblktosize(fs, lbn + 1)) {
			/*
			 * The block is an already-allocated direct block
			 * and the file already extends past this block,
			 * thus this must be a whole block.
			 * Just read the block (if requested).
			 */

			if (bpp != NULL) {
				error = bread(vp, lbn, fs->fs_bsize, bpp);
				if (error) {
					brelse(*bpp);
					return (error);
				}
			}
			return (0);
		}
		if (nb != 0) {
			/*
			 * Consider need to reallocate a fragment.
			 */
			osize = fragroundup(fs, blkoff(fs, ip->i_ffs1_size));
			nsize = fragroundup(fs, size);
			if (nsize <= osize) {
				/*
				 * The existing block is already
				 * at least as big as we want.
				 * Just read the block (if requested).
				 */
				if (bpp != NULL) {
					error = bread(vp, lbn, fs->fs_bsize,
					    bpp);
					if (error) {
						brelse(*bpp);
						return (error);
					}
					buf_adjcnt((*bpp), osize);
				}
				return (0);
			} else {
				/*
				 * The existing block is smaller than we
				 * want, grow it.
				 */
				error = ffs_realloccg(ip, lbn,
				    ffs1_blkpref(ip, lbn, (int)lbn,
					&ip->i_ffs1_db[0]),
				    osize, nsize, cred, bpp, &newb);
				if (error)
					return (error);
				if (DOINGSOFTDEP(vp))
					softdep_setup_allocdirect(ip, lbn,
					    newb, nb, nsize, osize,
					    bpp ? *bpp : NULL);
			}
		} else {
			/*
			 * The block was not previously allocated,
			 * allocate a new block or fragment.
			 */

			if (ip->i_ffs1_size < lblktosize(fs, lbn + 1))
				nsize = fragroundup(fs, size);
			else
				nsize = fs->fs_bsize;
			error = ffs_alloc(ip, lbn,
			    ffs1_blkpref(ip, lbn, (int)lbn, &ip->i_ffs1_db[0]),
			    nsize, cred, &newb);
			if (error)
				return (error);
			if (bpp != NULL) {
				*bpp = getblk(vp, lbn, fs->fs_bsize, 0, 0);
				if (nsize < fs->fs_bsize)
					(*bpp)->b_bcount = nsize;
				(*bpp)->b_blkno = fsbtodb(fs, newb);
				if (flags & B_CLRBUF)
					clrbuf(*bpp);
			}
			if (DOINGSOFTDEP(vp))
				softdep_setup_allocdirect(ip, lbn, newb, 0,
				    nsize, 0, bpp ? *bpp : NULL);
		}
		ip->i_ffs1_db[lbn] = newb;
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
		return (0);
	}

	/*
	 * Determine the number of levels of indirection.
	 */
	pref = 0;
	if ((error = ufs_getlbns(vp, lbn, indirs, &num)) != 0)
		return(error);
#ifdef DIAGNOSTIC
	if (num < 1)
		panic ("ffs1_balloc: ufs_bmaparray returned indirect block");
#endif
	/*
	 * Fetch the first indirect block allocating if necessary.
	 */
	--num;
	nb = ip->i_ffs1_ib[indirs[0].in_off];

	allocib = NULL;
	allocblk = allociblk;
	if (nb == 0) {
		pref = ffs1_blkpref(ip, lbn, -indirs[0].in_off - 1, NULL);
	        error = ffs_alloc(ip, lbn, pref, (int)fs->fs_bsize,
				  cred, &newb);
		if (error)
			goto fail;
		nb = newb;

		*allocblk++ = nb;
		bp = getblk(vp, indirs[1].in_lbn, fs->fs_bsize, 0, 0);
		bp->b_blkno = fsbtodb(fs, nb);
		clrbuf(bp);

		if (DOINGSOFTDEP(vp)) {
			softdep_setup_allocdirect(ip, NDADDR + indirs[0].in_off,
			    newb, 0, fs->fs_bsize, 0, bp);
			bdwrite(bp);
		} else {
			/*
			 * Write synchronously so that indirect blocks
			 * never point at garbage.
			 */
			if ((error = bwrite(bp)) != 0)
				goto fail;
		}
		allocib = &ip->i_ffs1_ib[indirs[0].in_off];
		*allocib = nb;
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
	}

	/*
	 * Fetch through the indirect blocks, allocating as necessary.
	 */
	for (i = 1;;) {
		error = bread(vp, indirs[i].in_lbn, (int)fs->fs_bsize, &bp);
		if (error) {
			brelse(bp);
			goto fail;
		}
		bap = (int32_t *)bp->b_data;
		nb = bap[indirs[i].in_off];
		if (i == num)
			break;
		i++;
		if (nb != 0) {
			brelse(bp);
			continue;
		}
		if (pref == 0)
			pref = ffs1_blkpref(ip, lbn, i - num - 1, NULL);
		error = ffs_alloc(ip, lbn, pref, (int)fs->fs_bsize, cred,
				  &newb);
		if (error) {
			brelse(bp);
			goto fail;
		}
		nb = newb;
		*allocblk++ = nb;
		nbp = getblk(vp, indirs[i].in_lbn, fs->fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
		clrbuf(nbp);

		if (DOINGSOFTDEP(vp)) {
			softdep_setup_allocindir_meta(nbp, ip, bp,
			    indirs[i - 1].in_off, nb);
			bdwrite(nbp);
		} else {
			/*
			 * Write synchronously so that indirect blocks
			 * never point at garbage.
			 */
			if ((error = bwrite(nbp)) != 0) {
				brelse(bp);
				goto fail;
			}
		}
		bap[indirs[i - 1].in_off] = nb;
		if (allocib == NULL && unwindidx < 0)
			unwindidx = i - 1;
		/*
		 * If required, write synchronously, otherwise use
		 * delayed write.
		 */
		if (flags & B_SYNC) {
			bwrite(bp);
		} else {
			bdwrite(bp);
		}
	}
	/*
	 * Get the data block, allocating if necessary.
	 */
	if (nb == 0) {
		pref = ffs1_blkpref(ip, lbn, indirs[i].in_off, &bap[0]);
		error = ffs_alloc(ip, lbn, pref, (int)fs->fs_bsize, cred,
				  &newb);
		if (error) {
			brelse(bp);
			goto fail;
		}
		nb = newb;
		*allocblk++ = nb;
		if (bpp != NULL) {
			nbp = getblk(vp, lbn, fs->fs_bsize, 0, 0);
			nbp->b_blkno = fsbtodb(fs, nb);
			if (flags & B_CLRBUF)
				clrbuf(nbp);
			*bpp = nbp;
		}
		if (DOINGSOFTDEP(vp))
			softdep_setup_allocindir_page(ip, lbn, bp,
			    indirs[i].in_off, nb, 0, bpp ? *bpp : NULL);
		bap[indirs[i].in_off] = nb;
		/*
		 * If required, write synchronously, otherwise use
		 * delayed write.
		 */
		if (flags & B_SYNC) {
			bwrite(bp);
		} else {
			bdwrite(bp);
		}
		return (0);
	}
	brelse(bp);
	if (bpp != NULL) {
		if (flags & B_CLRBUF) {
			error = bread(vp, lbn, (int)fs->fs_bsize, &nbp);
			if (error) {
				brelse(nbp);
				goto fail;
			}
		} else {
			nbp = getblk(vp, lbn, fs->fs_bsize, 0, 0);
			nbp->b_blkno = fsbtodb(fs, nb);
		}
		*bpp = nbp;
	}
	return (0);

fail:
	/*
	 * If we have failed to allocate any blocks, simply return the error.
	 * This is the usual case and avoids the need to fsync the file.
	 */
	if (allocblk == allociblk && allocib == NULL && unwindidx == -1)
		return (error);
	/*
	 * If we have failed part way through block allocation, we have to
	 * deallocate any indirect blocks that we have allocated. We have to
	 * fsync the file before we start to get rid of all of its
	 * dependencies so that we do not leave them dangling. We have to sync
	 * it at the end so that the softdep code does not find any untracked
	 * changes. Although this is really slow, running out of disk space is
	 * not expected to be a common occurrence. The error return from fsync
	 * is ignored as we already have an error to return to the user.
	 */
	VOP_FSYNC(vp, p->p_ucred, MNT_WAIT, p);
	for (deallocated = 0, blkp = allociblk; blkp < allocblk; blkp++) {
		ffs_blkfree(ip, *blkp, fs->fs_bsize);
		deallocated += fs->fs_bsize;
	}
	if (allocib != NULL) {
		*allocib = 0;
	} else if (unwindidx >= 0) {
		int r;

		r = bread(vp, indirs[unwindidx].in_lbn, (int)fs->fs_bsize, &bp);
		if (r)
			panic("Could not unwind indirect block, error %d", r);
		bap = (int32_t *)bp->b_data;
		bap[indirs[unwindidx].in_off] = 0;
		if (flags & B_SYNC) {
			bwrite(bp);
		} else {
			bdwrite(bp);
		}
	}
	if (deallocated) {
		/*
		 * Restore user's disk quota because allocation failed.
		 */
		(void)ufs_quota_free_blocks(ip, btodb(deallocated), cred);

		ip->i_ffs1_blocks -= btodb(deallocated);
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
	}
	VOP_FSYNC(vp, p->p_ucred, MNT_WAIT, p);
	return (error);
}

#ifdef FFS2
int
ffs2_balloc(struct inode *ip, off_t off, int size, struct ucred *cred,
    int flags, struct buf **bpp)
{
	daddr_t lbn, lastlbn, nb, newb, *blkp;
	daddr_t pref, *allocblk, allociblk[NIADDR + 1];
	daddr_t *bap, *allocib;
	int deallocated, osize, nsize, num, i, error, unwindidx, r;
	struct buf *bp, *nbp;
	struct indir indirs[NIADDR + 2];
	struct fs *fs;
	struct vnode *vp;
	struct proc *p;
	
	vp = ITOV(ip);
	fs = ip->i_fs;
	p = curproc;
	unwindidx = -1;

	lbn = lblkno(fs, off);
	size = blkoff(fs, off) + size;

	if (size > fs->fs_bsize)
		panic("ffs2_balloc: block too big");

	if (bpp != NULL)
		*bpp = NULL;

	if (lbn < 0)
		return (EFBIG);

	/*
	 * If the next write will extend the file into a new block, and the
	 * file is currently composed of a fragment, this fragment has to be
	 * extended to be a full block.
	 */
	lastlbn = lblkno(fs, ip->i_ffs2_size);
	if (lastlbn < NDADDR && lastlbn < lbn) {
		nb = lastlbn;
		osize = blksize(fs, ip, nb);
		if (osize < fs->fs_bsize && osize > 0) {
			error = ffs_realloccg(ip, nb, ffs2_blkpref(ip,
			    lastlbn, nb, &ip->i_ffs2_db[0]), osize,
			    (int) fs->fs_bsize, cred, bpp, &newb);
			if (error)
				return (error);

			if (DOINGSOFTDEP(vp))
				softdep_setup_allocdirect(ip, nb, newb,
				    ip->i_ffs2_db[nb], fs->fs_bsize, osize,
				    bpp ? *bpp : NULL);

			ip->i_ffs2_size = lblktosize(fs, nb + 1);
			uvm_vnp_setsize(vp, ip->i_ffs2_size);
			ip->i_ffs2_db[nb] = newb;
			ip->i_flag |= IN_CHANGE | IN_UPDATE;

			if (bpp) {
				if (flags & B_SYNC)
					bwrite(*bpp);
				else
					bawrite(*bpp);
			}
		}
	}

	/*
	 * The first NDADDR blocks are direct.
	 */
	if (lbn < NDADDR) {

		nb = ip->i_ffs2_db[lbn];

		if (nb != 0 && ip->i_ffs2_size >= lblktosize(fs, lbn + 1)) {
			/*
			 * The direct block is already allocated and the file
			 * extends past this block, thus this must be a whole
			 * block. Just read it, if requested.
			 */
			if (bpp != NULL) {
				error = bread(vp, lbn, fs->fs_bsize, bpp);
				if (error) {
					brelse(*bpp);
					return (error);
				}
			}

			return (0);
		}

		if (nb != 0) {
			/*
			 * Consider the need to allocate a fragment.
			 */
			osize = fragroundup(fs, blkoff(fs, ip->i_ffs2_size));
			nsize = fragroundup(fs, size);

			if (nsize <= osize) {
				/*
				 * The existing block is already at least as
				 * big as we want. Just read it, if requested.
				 */
				if (bpp != NULL) {
					error = bread(vp, lbn, fs->fs_bsize,
					    bpp);
					if (error) {
						brelse(*bpp);
						return (error);
					}
					buf_adjcnt((*bpp), osize);
				}

				return (0);
			} else {
				/*
				 * The existing block is smaller than we want,
				 * grow it.
				 */
				error = ffs_realloccg(ip, lbn,
				    ffs2_blkpref(ip, lbn, (int) lbn,
				    &ip->i_ffs2_db[0]), osize, nsize, cred,
				    bpp, &newb);
				if (error)
					return (error);

				if (DOINGSOFTDEP(vp))
					softdep_setup_allocdirect(ip, lbn,
					    newb, nb, nsize, osize,
					    bpp ? *bpp : NULL);
			}
		} else {
			/*
			 * The block was not previously allocated, allocate a
			 * new block or fragment.
			 */
			if (ip->i_ffs2_size < lblktosize(fs, lbn + 1))
				nsize = fragroundup(fs, size);
			else
				nsize = fs->fs_bsize;

			error = ffs_alloc(ip, lbn, ffs2_blkpref(ip, lbn,
			    (int) lbn, &ip->i_ffs2_db[0]), nsize, cred, &newb);
			if (error)
				return (error);

			if (bpp != NULL) {
				bp = getblk(vp, lbn, fs->fs_bsize, 0, 0);
				if (nsize < fs->fs_bsize)
					bp->b_bcount = nsize;
				bp->b_blkno = fsbtodb(fs, newb);
				if (flags & B_CLRBUF)
					clrbuf(bp);
				*bpp = bp;
			}

			if (DOINGSOFTDEP(vp))
				softdep_setup_allocdirect(ip, lbn, newb, 0,
				    nsize, 0, bpp ? *bpp : NULL);
		}

		ip->i_ffs2_db[lbn] = newb;
		ip->i_flag |= IN_CHANGE | IN_UPDATE;

		return (0);
	}

	/*
	 * Determine the number of levels of indirection.
	 */
	pref = 0;
	error = ufs_getlbns(vp, lbn, indirs, &num);
	if (error)
		return (error);

#ifdef DIAGNOSTIC
	if (num < 1)
		panic("ffs2_balloc: ufs_bmaparray returned indirect block");
#endif

	/*
	 * Fetch the first indirect block allocating it necessary.
	 */
	--num;
	nb = ip->i_ffs2_ib[indirs[0].in_off];
	allocib = NULL;
	allocblk = allociblk;

	if (nb == 0) {
		pref = ffs2_blkpref(ip, lbn, -indirs[0].in_off - 1, NULL);
		error = ffs_alloc(ip, lbn, pref, (int) fs->fs_bsize, cred,
		    &newb);
		if (error)
			goto fail;

		nb = newb;
		*allocblk++ = nb;
		bp = getblk(vp, indirs[1].in_lbn, fs->fs_bsize, 0, 0);
		bp->b_blkno = fsbtodb(fs, nb);
		clrbuf(bp);

		if (DOINGSOFTDEP(vp)) {
			softdep_setup_allocdirect(ip, NDADDR + indirs[0].in_off,
			    newb, 0, fs->fs_bsize, 0, bp);
			bdwrite(bp);
		} else {
			/*
			 * Write synchronously so that indirect blocks never
			 * point at garbage.
			 */
			error = bwrite(bp);
			if (error)
				goto fail;
		}

		unwindidx = 0;
		allocib = &ip->i_ffs2_ib[indirs[0].in_off];
		*allocib = nb;
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
	}

	/*
	 * Fetch through the indirect blocks, allocating as necessary.
	 */
	for (i = 1;;) {
		error = bread(vp, indirs[i].in_lbn, (int)fs->fs_bsize, &bp);
		if (error) {
			brelse(bp);
			goto fail;
		}

		bap = (int64_t *) bp->b_data;
		nb = bap[indirs[i].in_off];

		if (i == num)
			break;

		i++;

		if (nb != 0) {
			brelse(bp);
			continue;
		}

		if (pref == 0)
			pref = ffs2_blkpref(ip, lbn, i - num - 1, NULL);

		error = ffs_alloc(ip, lbn, pref, (int) fs->fs_bsize, cred,
		    &newb);
		if (error) {
			brelse(bp);
			goto fail;
		}

		nb = newb;
		*allocblk++ = nb;
		nbp = getblk(vp, indirs[i].in_lbn, fs->fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
		clrbuf(nbp);

		if (DOINGSOFTDEP(vp)) {
			softdep_setup_allocindir_meta(nbp, ip, bp,
			    indirs[i - 1].in_off, nb);
			bdwrite(nbp);
		} else {
			/*
			 * Write synchronously so that indirect blocks never
			 * point at garbage.
			 */
			error = bwrite(nbp);
			if (error) {
				brelse(bp);
				goto fail;
			}
		}

		if (unwindidx < 0)
			unwindidx = i - 1;

		bap[indirs[i - 1].in_off] = nb;

		/*
		 * If required, write synchronously, otherwise use delayed
		 * write.
		 */
		if (flags & B_SYNC)
			bwrite(bp);
		else
			bdwrite(bp);
	}

	/*
	 * Get the data block, allocating if necessary.
	 */
	if (nb == 0) {
		pref = ffs2_blkpref(ip, lbn, indirs[num].in_off, &bap[0]);

		error = ffs_alloc(ip, lbn, pref, (int)fs->fs_bsize, cred,
		    &newb);
		if (error) {
			brelse(bp);
			goto fail;
		}

		nb = newb;
		*allocblk++ = nb;

		if (bpp != NULL) {
			nbp = getblk(vp, lbn, fs->fs_bsize, 0, 0);
			nbp->b_blkno = fsbtodb(fs, nb);
			if (flags & B_CLRBUF)
				clrbuf(nbp);
			*bpp = nbp;
		}

		if (DOINGSOFTDEP(vp))
			softdep_setup_allocindir_page(ip, lbn, bp,
			    indirs[num].in_off, nb, 0, bpp ? *bpp : NULL);

		bap[indirs[num].in_off] = nb;

		if (allocib == NULL && unwindidx < 0)
			unwindidx = i - 1;

		/*
		 * If required, write synchronously, otherwise use delayed
		 * write.
		 */
		if (flags & B_SYNC)
			bwrite(bp);
		else
			bdwrite(bp);

		return (0);
	}

	brelse(bp);

	if (bpp != NULL) {
		if (flags & B_CLRBUF) {
			error = bread(vp, lbn, (int)fs->fs_bsize, &nbp);
			if (error) {
				brelse(nbp);
				goto fail;
			}
		} else {
			nbp = getblk(vp, lbn, fs->fs_bsize, 0, 0);
			nbp->b_blkno = fsbtodb(fs, nb);
			clrbuf(nbp);
		}

		*bpp = nbp;
	}

	return (0);

fail:
	/*
	 * If we have failed to allocate any blocks, simply return the error.
	 * This is the usual case and avoids the need to fsync the file.
	 */
	if (allocblk == allociblk && allocib == NULL && unwindidx == -1)
		return (error);
	/*
	 * If we have failed part way through block allocation, we have to
	 * deallocate any indirect blocks that we have allocated. We have to
	 * fsync the file before we start to get rid of all of its
	 * dependencies so that we do not leave them dangling. We have to sync
	 * it at the end so that the softdep code does not find any untracked
	 * changes. Although this is really slow, running out of disk space is
	 * not expected to be a common occurrence. The error return from fsync
	 * is ignored as we already have an error to return to the user.
	 */
	VOP_FSYNC(vp, p->p_ucred, MNT_WAIT, p);
	if (unwindidx >= 0) {
		/*
		 * First write out any buffers we've created to resolve their
		 * softdeps. This must be done in reverse order of creation so
		 * that we resolve the dependencies in one pass.
		 * Write the cylinder group buffers for these buffers too.
		 */
		 for (i = num; i >= unwindidx; i--) {
		 	if (i == 0)
				break;

			bp = getblk(vp, indirs[i].in_lbn, (int) fs->fs_bsize,
			    0, 0);
			if (bp->b_flags & B_DELWRI) {
				nb = fsbtodb(fs, cgtod(fs, dtog(fs,
				    dbtofsb(fs, bp->b_blkno))));
				bwrite(bp);
				bp = getblk(ip->i_devvp, nb,
				    (int) fs->fs_cgsize, 0, 0);
				if (bp->b_flags & B_DELWRI)
					bwrite(bp);
				else {
					bp->b_flags |= B_INVAL;
					brelse(bp);
				}
			} else {
				bp->b_flags |= B_INVAL;
				brelse(bp);
			}
		}

		if (DOINGSOFTDEP(vp) && unwindidx == 0) {
			ip->i_flag |= IN_CHANGE | IN_UPDATE;
			ffs_update(ip, 1);
		}

		/*
		 * Now that any dependencies that we created have been
		 * resolved, we can undo the partial allocation.
		 */
		if (unwindidx == 0) {
			*allocib = 0;
			ip->i_flag |= IN_CHANGE | IN_UPDATE;
			if (DOINGSOFTDEP(vp))
				ffs_update(ip, 1);
		} else {
			r = bread(vp, indirs[unwindidx].in_lbn,
			    (int)fs->fs_bsize, &bp);
			if (r)
				panic("ffs2_balloc: unwind failed");

			bap = (int64_t *) bp->b_data;
			bap[indirs[unwindidx].in_off] = 0;
			bwrite(bp);
		}

		for (i = unwindidx + 1; i <= num; i++) {
			bp = getblk(vp, indirs[i].in_lbn, (int)fs->fs_bsize, 0,
			    0);
			bp->b_flags |= B_INVAL;
			brelse(bp);
		}
	}

	for (deallocated = 0, blkp = allociblk; blkp < allocblk; blkp++) {
		ffs_blkfree(ip, *blkp, fs->fs_bsize);
		deallocated += fs->fs_bsize;
	}

	if (deallocated) {
		/*
	 	 * Restore user's disk quota because allocation failed.
	 	 */
		(void) ufs_quota_free_blocks(ip, btodb(deallocated), cred);

		ip->i_ffs2_blocks -= btodb(deallocated);
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
	}
	VOP_FSYNC(vp, p->p_ucred, MNT_WAIT, p);
	return (error);
}
#endif /* FFS2 */

/*
 * Balloc defines the structure of file system storage by allocating the
 * physical blocks given the inode and the logical block number in a file.
 */
int
ffs_balloc(struct inode *ip, off_t off, int size, struct ucred *cred,
    int flags, struct buf **bpp)
{
#ifdef FFS2
	if (ip->i_fs->fs_magic == FS_UFS2_MAGIC)
		return (ffs2_balloc(ip, off, size, cred, flags, bpp));
	else
#endif
		return (ffs1_balloc(ip, off, size, cred, flags, bpp));
}
@


1.43
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.42 2014/07/08 17:19:26 deraadt Exp $	*/
d168 1
a168 1
					(*bpp)->b_bcount = osize;
d538 1
a538 1
					(*bpp)->b_bcount = osize;
@


1.42
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.41 2014/05/22 02:02:39 guenther Exp $	*/
a47 1
#include <sys/file.h>
@


1.41
log
@From FreeBSD: the second argument to UFS_UPDATE/ffs_update is just a
boolean, not a MNT_* flag.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.40 2014/01/25 23:31:12 guenther Exp $	*/
a50 2

#include <uvm/uvm_extern.h>
@


1.40
log
@ufs_setattr() was assuming that the flag bits that indicate
atime/mtime/ctime need to be updated weren't already set.  When
they are, the code will end up treating the VNOVAL value from the
VFS layer as a time_t.  Port the fix from FreeBSD: the critical bit
is to process the existing flag values before possibly setting them
again in ufs_setattr().  This diff pulls in a larger change from
FreeBSD to replace the macro ITIMES() with a function ufs_itimes()
and to remove the atime and mtime arguments from ffs_update(): only
ufs_setattr() used them so it makes more sense to just do the those
bits directly there.

tweaks and ok tedu@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.39 2013/06/11 16:42:18 deraadt Exp $	*/
d838 1
a838 1
			ffs_update(ip, MNT_WAIT);
d849 1
a849 1
				ffs_update(ip, MNT_WAIT);
@


1.39
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.38 2013/04/23 20:42:38 tedu Exp $	*/
d838 1
a838 1
			ffs_update(ip, NULL, NULL, MNT_WAIT);
d849 1
a849 1
				ffs_update(ip, NULL, NULL, MNT_WAIT);
@


1.38
log
@change ffs layout policy. try to pack meta data in close to the start of
each cylinder group, which should speed up disk access a little and fsck
substantially. adapted from freebsd.
for more info: www.mckusick.com/publications/faster_fsck.pdf
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.37 2011/07/04 04:30:41 tedu Exp $	*/
d76 1
a76 1
	daddr64_t lbn, nb, newb, pref;
d436 3
a438 3
	daddr64_t lbn, lastlbn, nb, newb, *blkp;
	daddr64_t pref, *allocblk, allociblk[NIADDR + 1];
	daddr64_t *bap, *allocib;
@


1.37
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.36 2008/01/05 19:49:26 otto Exp $	*/
d241 1
a241 1
		pref = ffs1_blkpref(ip, lbn, 0, (int32_t *)0);
d289 1
a289 1
			pref = ffs1_blkpref(ip, lbn, 0, (int32_t *)0);
d620 1
a620 1
		pref = ffs2_blkpref(ip, lbn, 0, NULL);
d676 1
a676 1
			pref = ffs2_blkpref(ip, lbn, 0, NULL);
@


1.36
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.35 2007/11/27 16:22:14 martynas Exp $	*/
d144 1
a144 2
				error = bread(vp, lbn, fs->fs_bsize, NOCRED,
				    bpp);
d166 1
a166 1
					    NOCRED, bpp);
d274 1
a274 2
		error = bread(vp,
		    indirs[i].in_lbn, (int)fs->fs_bsize, NOCRED, &bp);
d367 1
a367 1
			error = bread(vp, lbn, (int)fs->fs_bsize, NOCRED, &nbp);
d407 1
a407 2
		r = bread(vp, indirs[unwindidx].in_lbn, 
		    (int)fs->fs_bsize, NOCRED, &bp);
d512 1
a512 2
				error = bread(vp, lbn, fs->fs_bsize, NOCRED,
				    bpp);
d536 1
a536 1
					    NOCRED, bpp);
d656 1
a656 2
		error = bread(vp, indirs[i].in_lbn, (int) fs->fs_bsize,
		    NOCRED, &bp);
d771 1
a771 1
			error = bread(vp, lbn, (int)fs->fs_bsize, NOCRED, &nbp);
d852 1
a852 1
			    (int) fs->fs_bsize, NOCRED, &bp);
@


1.35
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.34 2007/06/01 18:54:27 pedro Exp $	*/
d76 1
a76 1
	daddr_t lbn;
a77 1
	daddr_t nb;
d82 1
a82 1
	int32_t newb, *bap, pref;
d242 1
a242 1
		pref = ffs1_blkpref(ip, lbn, 0, (daddr_t *)0);
d281 1
a281 1
		bap = (daddr_t *)bp->b_data;
d291 1
a291 1
			pref = ffs1_blkpref(ip, lbn, 0, (daddr_t *)0);
d413 1
a413 1
		bap = (daddr_t *)bp->b_data;
d439 2
a440 2
	daddr_t lbn, lastlbn, nb, newb, *blkp;
	daddr_t pref, *allocblk, allociblk[NIADDR + 1];
@


1.34
log
@cleanup of 'ufs1_daddr_t', first round, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.33 2007/06/01 06:38:54 deraadt Exp $	*/
d397 1
a397 1
	 * not expected to be a common occurence. The error return from fsync
d807 1
a807 1
	 * not expected to be a common occurence. The error return from fsync
@


1.33
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.32 2007/05/26 20:26:51 pedro Exp $	*/
d83 1
a83 1
	ufs1_daddr_t newb, *bap, pref;
d85 1
a85 1
	ufs1_daddr_t *allocib, *blkp, *allocblk, allociblk[NIADDR+1];
@


1.32
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.31 2007/01/17 20:47:13 sturm Exp $	*/
d442 1
a442 1
	ufs2_daddr_t *bap, *allocib;
@


1.31
log
@"correctly deallocate dependencies when growing into an indirect block
and failing to acquire a data block, from freebsd"

fix this in ffs2_balloc() as well

requested by and ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.29 2007/01/14 21:50:05 pedro Exp $	*/
d167 2
a168 2
					error = bread(vp, lbn, osize, NOCRED,
					    bpp);
d173 1
d208 3
a210 1
				*bpp = getblk(vp, lbn, nsize, 0, 0);
d540 2
a541 2
					error = bread(vp, lbn, osize, NOCRED,
					    bpp);
d546 1
d583 3
a585 1
				bp = getblk(vp, lbn, nsize, 0, 0);
@


1.30
log
@correctly initialise unwindidx in ffs2_balloc()

ok pedro
@
text
@d445 1
d449 1
d788 6
a793 1

d796 7
a802 1
	 * deallocate any indirect blocks that we have allocated.
d804 1
d883 1
a883 1

@


1.29
log
@Fix growing of direct blocks in ffs2_balloc()
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.28 2007/01/12 14:33:01 pedro Exp $	*/
d448 1
a448 1
	unwindidx = 1;
@


1.28
log
@Also check for 'num < 1' in ffs2_balloc(), no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.27 2007/01/11 08:47:52 pedro Exp $	*/
d587 1
d589 2
a590 5
			ip->i_ffs2_db[lbn] = newb;
			ip->i_flag |= IN_CHANGE | IN_UPDATE;

			return (0);
		}
d592 1
@


1.27
log
@correctly deallocate dependencies when growing into an indirect block
and failing to acquire a data block, from freebsd, okay krw@@, mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.26 2006/03/11 21:00:48 pedro Exp $	*/
d603 5
@


1.26
log
@Add UFS2 block allocation functions, okay tedu@@.
Thanks to all those who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.25 2005/12/28 20:48:17 pedro Exp $	*/
d81 1
d90 1
d382 2
a383 2
	 * If we have failed part way through block allocation, we
	 * have to deallocate any indirect blocks that we have allocated.
d385 13
d428 1
a428 1

@


1.25
log
@Use the DIP macros to uniformly access fields from UFS1 and UFS2 dinodes.
No functional change, okay tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.24 2003/06/02 23:28:22 millert Exp $	*/
d5 9
d62 5
d73 1
a73 1
ffs_balloc(struct inode *ip, off_t startoffset, int size, struct ucred *cred,
d82 1
a82 1
	daddr_t newb, *bap, pref;
d84 1
a84 1
	daddr_t *allocib, *blkp, *allocblk, allociblk[NIADDR+1];
d92 1
a92 1
		panic("ffs_balloc: blk too big");
d108 1
a108 1
			    ffs_blkpref(ip, nb, (int)nb, &ip->i_ffs1_db[0]),
d179 1
a179 1
				    ffs_blkpref(ip, lbn, (int)lbn,
d200 1
a200 1
			    ffs_blkpref(ip, lbn, (int)lbn, &ip->i_ffs1_db[0]),
d227 1
a227 1
		panic ("ffs_balloc: ufs_bmaparray returned indirect block");
d238 1
a238 1
		pref = ffs_blkpref(ip, lbn, 0, (daddr_t *)0);
d287 1
a287 1
			pref = ffs_blkpref(ip, lbn, 0, (daddr_t *)0);
d331 1
a331 1
		pref = ffs_blkpref(ip, lbn, indirs[i].in_off, &bap[0]);
d415 454
@


1.24
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.23 2003/05/26 18:33:16 tedu Exp $	*/
d47 1
d89 1
a89 1
	nb = lblkno(fs, ip->i_ffs_size);
d94 1
a94 1
			    ffs_blkpref(ip, nb, (int)nb, &ip->i_ffs_db[0]),
d100 1
a100 1
				    ip->i_ffs_db[nb], fs->fs_bsize, osize,
d103 3
a105 3
			ip->i_ffs_size = lblktosize(fs, nb + 1);
			uvm_vnp_setsize(vp, ip->i_ffs_size);
			ip->i_ffs_db[nb] = newb;
d119 2
a120 2
		nb = ip->i_ffs_db[lbn];
		if (nb != 0 && ip->i_ffs_size >= lblktosize(fs, lbn + 1)) {
d142 1
a142 1
			osize = fragroundup(fs, blkoff(fs, ip->i_ffs_size));
d166 1
a166 1
					&ip->i_ffs_db[0]),
d181 1
a181 1
			if (ip->i_ffs_size < lblktosize(fs, lbn + 1))
d186 1
a186 1
			    ffs_blkpref(ip, lbn, (int)lbn, &ip->i_ffs_db[0]),
d200 1
a200 1
		ip->i_ffs_db[lbn] = newb;
d219 1
a219 1
	nb = ip->i_ffs_ib[indirs[0].in_off];
d248 1
a248 1
		allocib = &ip->i_ffs_ib[indirs[0].in_off];
d396 1
a396 1
		ip->i_ffs_blocks -= btodb(deallocated);
@


1.23
log
@fiddle with some type names.  change most instances of ufs_daddr_t to
ufs1_daddr_t, a few to daddr_t.  ufs_daddr_t typedef is retained, but consider
it deprecated.  no functional changes.  inspired by freebsd.  ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.22 2001/12/19 08:58:07 art Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.22
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.18 2001/11/21 21:23:56 csapuntz Exp $	*/
d385 1
a385 1
		bap = (ufs_daddr_t *)bp->b_data;
@


1.21
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.20 2001/12/10 02:19:34 art Exp $	*/
a404 44

int
ffs_gop_alloc(struct vnode *vp, off_t off, off_t len, int flags,
    struct ucred *cred)
{
	struct inode *ip = VTOI(vp);
	struct fs *fs = ip->i_fs;
	int error, delta, bshift, bsize;

	error = 0;
	bshift = fs->fs_bshift;
	bsize = 1 << bshift;

	delta = off & (bsize - 1);
	off -= delta;
	len += delta;

	while (len > 0) {
		bsize = MIN(bsize, len);

		error = ffs_balloc(ip, off, bsize, cred, flags, NULL);
		if (error) {
			goto out;
		}

		/*
		 * increase file size now, VOP_BALLOC() requires that
		 * EOF be up-to-date before each call.
		 */

		if (ip->i_ffs_size < off + bsize) {
			ip->i_ffs_size = off + bsize;
			if (vp->v_size < ip->i_ffs_size) {
				uvm_vnp_setsize(vp, ip->i_ffs_size);
			}
		}

		off += bsize;
		len -= bsize;
	}

out:
	return error;
 }
@


1.21.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.21 2001/12/10 04:45:32 art Exp $	*/
d437 3
@


1.21.2.2
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.21.2.1 2002/02/02 03:28:26 art Exp $	*/
d213 1
a213 1
		return (error);
a250 1
		unwindidx = 0;
d339 1
a339 5
		bap[indirs[num].in_off] = nb;
		if (allocib == NULL && unwindidx < 0) {
			unwindidx = i - 1;
		}

a343 1

a361 1
			clrbuf(nbp);
a371 68

	if (unwindidx >= 0) {

		/*
		 * First write out any buffers we've created to resolve their
		 * softdeps.  This must be done in reverse order of creation
		 * so that we resolve the dependencies in one pass.
		 * Write the cylinder group buffers for these buffers too.
		 */

		for (i = num; i >= unwindidx; i--) {
			if (i == 0) {
				break;
			}
			bp = getblk(vp, indirs[i].in_lbn, (int)fs->fs_bsize, 0,
			    0);
			if (bp->b_flags & B_DELWRI) {
				nb = fsbtodb(fs, cgtod(fs, dtog(fs,
				    dbtofsb(fs, bp->b_blkno))));
				bwrite(bp);
				bp = getblk(ip->i_devvp, nb, (int)fs->fs_cgsize,
				    0, 0);
				if (bp->b_flags & B_DELWRI) {
					bwrite(bp);
				} else {
					bp->b_flags |= B_INVAL;
					brelse(bp);
				}
			} else {
				bp->b_flags |= B_INVAL;
				brelse(bp);
			}
		}
		if (unwindidx == 0) {
			ip->i_flag |= IN_MODIFIED | IN_CHANGE | IN_UPDATE;
			UFS_UPDATE(ip, UPDATE_WAIT);
		}

		/*
		 * Now that any dependencies that we created have been
		 * resolved, we can undo the partial allocation.
		 */

		if (unwindidx == 0) {
			*allocib = 0;
			ip->i_flag |= IN_MODIFIED | IN_CHANGE | IN_UPDATE;
			UFS_UPDATE(ip, UPDATE_WAIT);
		} else {
			int r;

			r = bread(vp, indirs[unwindidx].in_lbn,
			    (int)fs->fs_bsize, NOCRED, &bp);
			if (r) {
				panic("Could not unwind indirect block, error %d", r);
				brelse(bp);
			} else {
				bap = (ufs_daddr_t *)bp->b_data;
				bap[indirs[unwindidx].in_off] = 0;
				bwrite(bp);
			}
		}
		for (i = unwindidx + 1; i <= num; i++) {
			bp = getblk(vp, indirs[i].in_lbn, (int)fs->fs_bsize, 0,
			    0);
			bp->b_flags |= B_INVAL;
			brelse(bp);
		}
	}
d376 17
d398 1
d402 1
d445 1
a445 1
}
@


1.20
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.19 2001/11/27 05:27:12 art Exp $	*/
d407 2
a408 2
ffs_ballocn(v)
	void *v;
a409 10
	struct vop_ballocn_args /* {
		struct vnode *a_vp;
		off_t a_offset;
		off_t a_length;
		struct ucred *a_cred;
		int a_flags;
	} */ *ap = v;

	off_t off, len;
	struct vnode *vp = ap->a_vp;
a417 3
	off = ap->a_offset;
	len = ap->a_length;

d423 1
a423 1
		bsize = min(bsize, len);
d425 1
a425 2
		error = ffs_balloc(ip, off, bsize, ap->a_cred, ap->a_flags,
				   NULL);
@


1.19
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.18 2001/11/21 21:23:56 csapuntz Exp $	*/
d451 1
a451 1
			if (vp->v_uvm.u_size < ip->i_ffs_size) {
@


1.18
log
@Don't use #define QUOTA - use stub file instead

Pass over the quota code in ufs/. Make code paths clearer. Clean up some names.
Move all code that manipulates quotas directly into ufs_quota.c

Use vfs_mount_foreach_vnode to traverse list of vnodes in mountpoint.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.17 2001/11/13 16:01:10 art Exp $	*/
d405 58
@


1.17
log
@Allow balloc to get NULL for bpp. Don't get the buffer in that case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.16 2001/11/13 00:10:56 art Exp $	*/
a393 1
#ifdef QUOTA
d397 2
a398 2
		(void)chkdq(ip, (long)-btodb(deallocated), cred, FORCE);
#endif
@


1.16
log
@Allow the bpp arguemnt on ffs_realloccg to be NULL, don't return the
buffer in that case. Also add a new argument - blknop, which can be used to
return the allocated blkno.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.15 2001/11/06 19:53:21 miod Exp $	*/
d82 2
a83 1
	*bpp = NULL;
d98 1
a98 1
			    osize, (int)fs->fs_bsize, cred, &bp, &newb);
d103 2
a104 1
				    ip->i_ffs_db[nb], fs->fs_bsize, osize, bp);
d110 6
a115 4
			if (flags & B_SYNC)
				bwrite(bp);
			else
				bawrite(bp);
d124 14
a137 4
			error = bread(vp, lbn, fs->fs_bsize, NOCRED, &bp);
			if (error) {
				brelse(bp);
				return (error);
a138 1
			*bpp = bp;
d148 12
a159 4
				error = bread(vp, lbn, osize, NOCRED, &bp);
				if (error) {
					brelse(bp);
					return (error);
d161 1
d163 4
d170 1
a170 1
				    osize, nsize, cred, &bp, &newb);
d175 2
a176 1
					    newb, nb, nsize, osize, bp);
d179 5
d193 6
a198 4
			bp = getblk(vp, lbn, nsize, 0, 0);
			bp->b_blkno = fsbtodb(fs, newb);
			if (flags & B_CLRBUF)
				clrbuf(bp);
d201 1
a201 1
				    nsize, 0, bp);
d203 1
a203 1
		ip->i_ffs_db[lbn] = dbtofsb(fs, bp->b_blkno);
a204 1
		*bpp = bp;
d207 1
d231 1
a231 1
			return (error);
d255 1
d329 7
a335 4
		nbp = getblk(vp, lbn, fs->fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
		if (flags & B_CLRBUF)
			clrbuf(nbp);
d338 1
a338 1
			    indirs[i].in_off, nb, 0, nbp);
a348 1
		*bpp = nbp;
d352 10
a361 5
	if (flags & B_CLRBUF) {
		error = bread(vp, lbn, (int)fs->fs_bsize, NOCRED, &nbp);
		if (error) {
			brelse(nbp);
			goto fail;
d363 1
a363 3
	} else {
		nbp = getblk(vp, lbn, fs->fs_bsize, 0, 0);
		nbp->b_blkno = fsbtodb(fs, nb);
a364 1
	*bpp = nbp;
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.14 2001/06/27 04:58:48 art Exp $	*/
d96 2
a97 2
				ffs_blkpref(ip, nb, (int)nb, &ip->i_ffs_db[0]),
				osize, (int)fs->fs_bsize, cred, &bp);
d101 2
a102 3
				softdep_setup_allocdirect(ip, nb,
				    dbtofsb(fs, bp->b_blkno), ip->i_ffs_db[nb],
				    fs->fs_bsize, osize, bp);
d106 1
a106 1
			ip->i_ffs_db[nb] = dbtofsb(fs, bp->b_blkno);
d144 1
a144 1
				    osize, nsize, cred, &bp);
d149 1
a149 2
					    dbtofsb(fs, bp->b_blkno), nb,
					    nsize, osize, bp);
@


1.14
log
@Remove old vm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.13 2001/06/23 02:07:53 csapuntz Exp $	*/
a45 2

#include <vm/vm.h>
@


1.13
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.12 2001/03/20 19:33:06 art Exp $	*/
a48 1
#if defined(UVM)
a49 1
#endif
a107 1
#if defined(UVM)
a108 3
#else
			vnode_pager_setsize(vp, (u_long)ip->i_ffs_size);
#endif
@


1.12
log
@cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.11 2001/03/15 11:43:20 art Exp $	*/
d66 2
a67 2
ffs_balloc(v)
	void *v;
a68 9
	struct vop_balloc_args /* {
		struct vnode *a_vp;
		off_t a_startpoint;
		int a_size;
		struct ucred *a_cred;
		int a_flags;
		struct buf **a_bpp;
	} */ *ap = v;
	struct inode *ip;
a69 3
	int size;
	struct ucred *cred;
	int flags;
d80 1
a80 2
	vp = ap->a_vp;
	ip = VTOI(vp);
d82 2
a83 2
	lbn = lblkno(fs, ap->a_startoffset);
	size = blkoff(fs, ap->a_startoffset) + ap->a_size;
d86 1
a86 1
	*ap->a_bpp = NULL;
a88 2
	cred = ap->a_cred;
	flags = ap->a_flags;
d134 1
a134 1
			*ap->a_bpp = bp;
d181 1
a181 1
		*ap->a_bpp = bp;
d321 1
a321 1
		*ap->a_bpp = nbp;
d335 1
a335 1
	*ap->a_bpp = nbp;
@


1.11
log
@cosmetic cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.10 2000/04/20 14:41:57 art Exp $	*/
d98 1
a98 1
		panic("ffs_balloc; blk too big");
d166 1
a166 1
				    ffs_blkpref(ip, lbn, (int)lbn, 
d174 1
a174 1
                                            nsize, osize, bp);
a192 1

@


1.10
log
@Fix a problem that occurs when the filesystem fills up.
When the filesystem is able to allocate an indirect block but not the data
block, it incorrectly unwinds the indirect block leaving a dangling pointer
to a free block.
This is said to fix the "freeing free block" panics people were seeing.

From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.9 1999/05/27 20:36:21 art Exp $	*/
d75 2
a76 3
		struct buf *a_bpp;
        } */ *ap = v;

d231 12
a242 12
                if (DOINGSOFTDEP(vp)) {
                        softdep_setup_allocdirect(ip, NDADDR + indirs[0].in_off,
                            newb, 0, fs->fs_bsize, 0, bp);
                        bdwrite(bp);
                } else {
                        /*
                         * Write synchronously so that indirect blocks
                         * never point at garbage.
                         */
                        if ((error = bwrite(bp)) != 0)
                                goto fail;
                }
d261 1
a261 1
		i += 1;
d280 13
a292 13
                if (DOINGSOFTDEP(vp)) {
                        softdep_setup_allocindir_meta(nbp, ip, bp,
                            indirs[i - 1].in_off, nb);
                        bdwrite(nbp);
                } else {
                        /*
                         * Write synchronously so that indirect blocks
                         * never point at garbage.
                         */
                        if ((error = bwrite(nbp)) != 0) {
                                brelse(bp);
                                goto fail;
                        }
d385 1
a385 1
		(void) chkdq(ip, (long)-btodb(deallocated), cred, FORCE);
@


1.9
log
@Use lblktosize(fs, foo) instead of foo*fs->fs_bsize
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.8 1999/02/26 03:56:30 art Exp $	*/
d91 1
d296 2
d364 1
a364 1
	if (allocib != NULL)
d366 15
d391 1
a392 1

@


1.9.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.12 2001/03/20 19:33:06 art Exp $	*/
d75 3
a77 2
		struct buf **a_bpp;
	} */ *ap = v;
a90 1
	int unwindidx = -1;
d98 1
a98 1
		panic("ffs_balloc: blk too big");
d166 1
a166 1
				    ffs_blkpref(ip, lbn, (int)lbn,
d174 1
a174 1
					    nsize, osize, bp);
d193 1
d231 12
a242 12
		if (DOINGSOFTDEP(vp)) {
			softdep_setup_allocdirect(ip, NDADDR + indirs[0].in_off,
			    newb, 0, fs->fs_bsize, 0, bp);
			bdwrite(bp);
		} else {
			/*
			 * Write synchronously so that indirect blocks
			 * never point at garbage.
			 */
			if ((error = bwrite(bp)) != 0)
				goto fail;
		}
d261 1
a261 1
		i++;
d280 13
a292 13
		if (DOINGSOFTDEP(vp)) {
			softdep_setup_allocindir_meta(nbp, ip, bp,
			    indirs[i - 1].in_off, nb);
			bdwrite(nbp);
		} else {
			/*
			 * Write synchronously so that indirect blocks
			 * never point at garbage.
			 */
			if ((error = bwrite(nbp)) != 0) {
				brelse(bp);
				goto fail;
			}
a294 2
		if (allocib == NULL && unwindidx < 0)
			unwindidx = i - 1;
d361 1
a361 1
	if (allocib != NULL) {
a362 15
	} else if (unwindidx >= 0) {
		int r;

		r = bread(vp, indirs[unwindidx].in_lbn, 
		    (int)fs->fs_bsize, NOCRED, &bp);
		if (r)
			panic("Could not unwind indirect block, error %d", r);
		bap = (ufs_daddr_t *)bp->b_data;
		bap[indirs[unwindidx].in_off] = 0;
		if (flags & B_SYNC) {
			bwrite(bp);
		} else {
			bdwrite(bp);
		}
	}
d368 1
a368 1
		(void)chkdq(ip, (long)-btodb(deallocated), cred, FORCE);
d373 1
a374 1
	return (error);
@


1.9.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.9.4.1 2001/05/14 22:47:40 niklas Exp $	*/
d49 1
d51 1
d66 2
a67 2
ffs_balloc(struct inode *ip, off_t startoffset, int size, struct ucred *cred,
    int flags, struct buf **bpp)
d69 9
d79 3
d92 2
a93 1
	vp = ITOV(ip);
d95 2
a96 2
	lbn = lblkno(fs, startoffset);
	size = blkoff(fs, startoffset) + size;
d99 1
a99 1
	*bpp = NULL;
d102 2
d125 1
d127 3
d149 1
a149 1
			*bpp = bp;
d196 1
a196 1
		*bpp = bp;
d336 1
a336 1
		*bpp = nbp;
d350 1
a350 1
	*bpp = nbp;
@


1.9.4.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 2
@


1.9.4.4
log
@Merge in -current
@
text
@d82 1
a82 2
	if (bpp != NULL)
		*bpp = NULL;
d96 2
a97 2
			    ffs_blkpref(ip, nb, (int)nb, &ip->i_ffs_db[0]),
			    osize, (int)fs->fs_bsize, cred, bpp, &newb);
d101 3
a103 3
				softdep_setup_allocdirect(ip, nb, newb,
				    ip->i_ffs_db[nb], fs->fs_bsize, osize,
				    bpp ? *bpp : NULL);
d107 1
a107 1
			ip->i_ffs_db[nb] = newb;
d109 4
a112 6
			if (bpp != NULL) {
				if (flags & B_SYNC)
					bwrite(*bpp);
				else
					bawrite(*bpp);
			}
d121 4
a124 14
			/*
			 * The block is an already-allocated direct block
			 * and the file already extends past this block,
			 * thus this must be a whole block.
			 * Just read the block (if requested).
			 */

			if (bpp != NULL) {
				error = bread(vp, lbn, fs->fs_bsize, NOCRED,
				    bpp);
				if (error) {
					brelse(*bpp);
					return (error);
				}
d126 1
d136 4
a139 12
				/*
				 * The existing block is already
				 * at least as big as we want.
				 * Just read the block (if requested).
				 */
				if (bpp != NULL) {
					error = bread(vp, lbn, osize, NOCRED,
					    bpp);
					if (error) {
						brelse(*bpp);
						return (error);
					}
a140 1
				return (0);
a141 4
				/*
				 * The existing block is smaller than we
				 * want, grow it.
				 */
d145 1
a145 1
				    osize, nsize, cred, bpp, &newb);
d150 2
a151 2
					    newb, nb, nsize, osize,
					    bpp ? *bpp : NULL);
a153 5
			/*
			 * The block was not previously allocated,
			 * allocate a new block or fragment.
			 */

d163 4
a166 6
			if (bpp != NULL) {
				*bpp = getblk(vp, lbn, nsize, 0, 0);
				(*bpp)->b_blkno = fsbtodb(fs, newb);
				if (flags & B_CLRBUF)
					clrbuf(*bpp);
			}
d169 1
a169 1
				    nsize, 0, bpp ? *bpp : NULL);
d171 1
a171 1
		ip->i_ffs_db[lbn] = newb;
d173 1
a175 1

d199 1
a199 1
			goto fail;
a222 1

d296 4
a299 7
		if (bpp != NULL) {
			nbp = getblk(vp, lbn, fs->fs_bsize, 0, 0);
			nbp->b_blkno = fsbtodb(fs, nb);
			if (flags & B_CLRBUF)
				clrbuf(nbp);
			*bpp = nbp;
		}
d302 1
a302 1
			    indirs[i].in_off, nb, 0, bpp ? *bpp : NULL);
d313 1
d317 5
a321 10
	if (bpp != NULL) {
		if (flags & B_CLRBUF) {
			error = bread(vp, lbn, (int)fs->fs_bsize, NOCRED, &nbp);
			if (error) {
				brelse(nbp);
				goto fail;
			}
		} else {
			nbp = getblk(vp, lbn, fs->fs_bsize, 0, 0);
			nbp->b_blkno = fsbtodb(fs, nb);
d323 3
a325 1
		*bpp = nbp;
d327 1
d357 1
d361 2
a362 2
		(void)ufs_quota_free_blocks(ip, btodb(deallocated), cred);

a368 58

int
ffs_ballocn(v)
	void *v;
{
	struct vop_ballocn_args /* {
		struct vnode *a_vp;
		off_t a_offset;
		off_t a_length;
		struct ucred *a_cred;
		int a_flags;
	} */ *ap = v;

	off_t off, len;
	struct vnode *vp = ap->a_vp;
	struct inode *ip = VTOI(vp);
	struct fs *fs = ip->i_fs;
	int error, delta, bshift, bsize;

	error = 0;
	bshift = fs->fs_bshift;
	bsize = 1 << bshift;

	off = ap->a_offset;
	len = ap->a_length;

	delta = off & (bsize - 1);
	off -= delta;
	len += delta;

	while (len > 0) {
		bsize = min(bsize, len);

		error = ffs_balloc(ip, off, bsize, ap->a_cred, ap->a_flags,
				   NULL);
		if (error) {
			goto out;
		}

		/*
		 * increase file size now, VOP_BALLOC() requires that
		 * EOF be up-to-date before each call.
		 */

		if (ip->i_ffs_size < off + bsize) {
			ip->i_ffs_size = off + bsize;
			if (vp->v_uvm.u_size < ip->i_ffs_size) {
				uvm_vnp_setsize(vp, ip->i_ffs_size);
			}
		}

		off += bsize;
		len -= bsize;
	}

out:
	return error;
 }
@


1.9.4.5
log
@Merge in trunk
@
text
@d405 58
@


1.9.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.9.4.5 2002/03/06 02:17:13 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d385 1
a385 1
		bap = (daddr_t *)bp->b_data;
@


1.8
log
@compat with uvm vnode pager
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.7 1999/01/11 05:12:37 millert Exp $	*/
d124 1
a124 1
			ip->i_ffs_size = (nb + 1) * fs->fs_bsize;
d143 1
a143 1
		if (nb != 0 && ip->i_ffs_size >= (lbn + 1) * fs->fs_bsize) {
d177 1
a177 1
			if (ip->i_ffs_size < (lbn + 1) * fs->fs_bsize)
@


1.7
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.6 1997/11/06 05:59:17 csapuntz Exp $	*/
d49 4
d125 3
d129 1
@


1.6
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.5 1997/10/06 20:21:34 deraadt Exp $	*/
d200 1
a200 1
		panic ("ffs_balloc: ufs_bmaparray returned indirect block\n");
@


1.5
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.3 1997/05/30 08:34:19 downsj Exp $	*/
d44 1
d62 14
a75 3
ffs_balloc(ip, bn, size, cred, bpp, flags)
	register struct inode *ip;
	register daddr_t bn;
a77 1
	struct buf **bpp;
d79 2
a80 3
{
	register struct fs *fs;
	register daddr_t nb;
d82 1
a82 1
	struct vnode *vp = ITOV(ip);
d84 3
a86 2
	daddr_t newb, lbn, *bap, pref;
	int osize, nsize, num, i, error;
d88 9
a96 2
	*bpp = NULL;
	if (bn < 0)
d98 2
a99 2
	fs = ip->i_fs;
	lbn = bn;
d107 1
a107 1
	if (nb < NDADDR && nb < bn) {
d115 5
d133 4
a136 4
	if (bn < NDADDR) {
		nb = ip->i_ffs_db[bn];
		if (nb != 0 && ip->i_ffs_size >= (bn + 1) * fs->fs_bsize) {
			error = bread(vp, bn, fs->fs_bsize, NOCRED, &bp);
d141 1
a141 1
			*bpp = bp;
d151 1
a151 1
				error = bread(vp, bn, osize, NOCRED, &bp);
d157 3
a159 2
				error = ffs_realloccg(ip, bn,
				    ffs_blkpref(ip, bn, (int)bn, &ip->i_ffs_db[0]),
d163 4
d169 1
a169 1
			if (ip->i_ffs_size < (bn + 1) * fs->fs_bsize)
d173 2
a174 2
			error = ffs_alloc(ip, bn,
			    ffs_blkpref(ip, bn, (int)bn, &ip->i_ffs_db[0]),
d178 1
a178 1
			bp = getblk(vp, bn, nsize, 0, 0);
d182 4
d187 1
a187 1
		ip->i_ffs_db[bn] = dbtofsb(fs, bp->b_blkno);
d189 1
a189 1
		*bpp = bp;
d196 1
a196 1
	if ((error = ufs_getlbns(vp, bn, indirs, &num)) != 0)
d207 3
d217 2
d220 1
a220 1
		bp->b_blkno = fsbtodb(fs, newb);
d222 15
a236 9
		/*
		 * Write synchronously so that indirect blocks
		 * never point at garbage.
		 */
		if ((error = bwrite(bp)) != 0) {
			ffs_blkfree(ip, nb, fs->fs_bsize);
			return (error);
		}
		ip->i_ffs_ib[indirs[0].in_off] = newb;
d247 1
a247 1
			return (error);
d264 1
a264 1
			return (error);
d267 1
d271 14
a284 8
		/*
		 * Write synchronously so that indirect blocks
		 * never point at garbage.
		 */
		if ((error = bwrite(nbp)) != 0) {
			ffs_blkfree(ip, nb, fs->fs_bsize);
			brelse(bp);
			return (error);
d306 1
a306 1
			return (error);
d309 1
d314 3
d327 1
a327 1
		*bpp = nbp;
d335 1
a335 1
			return (error);
d341 1
a341 1
	*bpp = nbp;
d343 24
@


1.4
log
@VFS Lite2 Changes
@
text
@a43 1
#include <sys/mount.h>
d61 3
a63 14
ffs_balloc(v)
	void *v;
{
	struct vop_balloc_args /* {
		struct vnode *a_vp;
		off_t a_startpoint;
		int a_size;
		struct ucred *a_cred;
		int a_flags;
		struct buf *a_bpp;
        } */ *ap = v;

	struct inode *ip;
	daddr_t lbn;
d66 1
d68 3
a70 2
	struct fs *fs;
	daddr_t nb;
d72 1
a72 1
	struct vnode *vp;
d74 2
a75 3
	daddr_t newb, *bap, pref;
	int deallocated, osize, nsize, num, i, error;
	daddr_t *allocib, *blkp, *allocblk, allociblk[NIADDR+1];
d77 3
a79 2
	vp = ap->a_vp;
	ip = VTOI(vp);
d81 1
a81 9
	lbn = lblkno(fs, ap->a_startoffset);
	size = blkoff(fs, ap->a_startoffset) + ap->a_size;
	if (size > fs->fs_bsize)
		panic("ffs_balloc; blk too big");
	*ap->a_bpp = NULL;
	if (lbn < 0)
		return (EFBIG);
	cred = ap->a_cred;
	flags = ap->a_flags;
d89 1
a89 1
	if (nb < NDADDR && nb < lbn) {
a96 5
			if (DOINGSOFTDEP(vp))
				softdep_setup_allocdirect(ip, nb,
				    dbtofsb(fs, bp->b_blkno), ip->i_ffs_db[nb],
				    fs->fs_bsize, osize, bp);

d110 4
a113 4
	if (lbn < NDADDR) {
		nb = ip->i_ffs_db[lbn];
		if (nb != 0 && ip->i_ffs_size >= (lbn + 1) * fs->fs_bsize) {
			error = bread(vp, lbn, fs->fs_bsize, NOCRED, &bp);
d118 1
a118 1
			*ap->a_bpp = bp;
d128 1
a128 1
				error = bread(vp, lbn, osize, NOCRED, &bp);
d134 2
a135 3
				error = ffs_realloccg(ip, lbn,
				    ffs_blkpref(ip, lbn, (int)lbn, 
					&ip->i_ffs_db[0]),
a138 4
				if (DOINGSOFTDEP(vp))
					softdep_setup_allocdirect(ip, lbn,
					    dbtofsb(fs, bp->b_blkno), nb,
                                            nsize, osize, bp);
d141 1
a141 1
			if (ip->i_ffs_size < (lbn + 1) * fs->fs_bsize)
d145 2
a146 2
			error = ffs_alloc(ip, lbn,
			    ffs_blkpref(ip, lbn, (int)lbn, &ip->i_ffs_db[0]),
d150 1
a150 1
			bp = getblk(vp, lbn, nsize, 0, 0);
a153 4
			if (DOINGSOFTDEP(vp))
				softdep_setup_allocdirect(ip, lbn, newb, 0,
				    nsize, 0, bp);

d155 1
a155 1
		ip->i_ffs_db[lbn] = dbtofsb(fs, bp->b_blkno);
d157 1
a157 1
		*ap->a_bpp = bp;
d164 1
a164 1
	if ((error = ufs_getlbns(vp, lbn, indirs, &num)) != 0)
a174 3

	allocib = NULL;
	allocblk = allociblk;
a181 2

		*allocblk++ = nb;
d183 1
a183 1
		bp->b_blkno = fsbtodb(fs, nb);
d185 9
a193 15

                if (DOINGSOFTDEP(vp)) {
                        softdep_setup_allocdirect(ip, NDADDR + indirs[0].in_off,
                            newb, 0, fs->fs_bsize, 0, bp);
                        bdwrite(bp);
                } else {
                        /*
                         * Write synchronously so that indirect blocks
                         * never point at garbage.
                         */
                        if ((error = bwrite(bp)) != 0)
                                goto fail;
                }
		allocib = &ip->i_ffs_ib[indirs[0].in_off];
		*allocib = nb;
d204 1
a204 1
			goto fail;
d221 1
a221 1
			goto fail;
a223 1
		*allocblk++ = nb;
d227 8
a234 14

                if (DOINGSOFTDEP(vp)) {
                        softdep_setup_allocindir_meta(nbp, ip, bp,
                            indirs[i - 1].in_off, nb);
                        bdwrite(nbp);
                } else {
                        /*
                         * Write synchronously so that indirect blocks
                         * never point at garbage.
                         */
                        if ((error = bwrite(nbp)) != 0) {
                                brelse(bp);
                                goto fail;
                        }
d256 1
a256 1
			goto fail;
a258 1
		*allocblk++ = nb;
a262 3
		if (DOINGSOFTDEP(vp))
			softdep_setup_allocindir_page(ip, lbn, bp,
			    indirs[i].in_off, nb, 0, nbp);
d273 1
a273 1
		*ap->a_bpp = nbp;
d281 1
a281 1
			goto fail;
d287 1
a287 1
	*ap->a_bpp = nbp;
a288 24

fail:
	/*
	 * If we have failed part way through block allocation, we
	 * have to deallocate any indirect blocks that we have allocated.
	 */
	for (deallocated = 0, blkp = allociblk; blkp < allocblk; blkp++) {
		ffs_blkfree(ip, *blkp, fs->fs_bsize);
		deallocated += fs->fs_bsize;
	}
	if (allocib != NULL)
		*allocib = 0;
	if (deallocated) {
#ifdef QUOTA
		/*
		 * Restore user's disk quota because allocation failed.
		 */
		(void) chkdq(ip, (long)-btodb(deallocated), cred, FORCE);
#endif
		ip->i_ffs_blocks -= btodb(deallocated);
		ip->i_flag |= IN_CHANGE | IN_UPDATE;
	}
	return (error);

@


1.3
log
@Integrate new ext2fs, reverting ufs support for the old one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_balloc.c,v 1.2 1996/02/27 07:27:35 niklas Exp $	*/
d44 1
d62 14
a75 3
ffs_balloc(ip, bn, size, cred, bpp, flags)
	register struct inode *ip;
	register daddr_t bn;
a77 1
	struct buf **bpp;
d79 2
a80 3
{
	register struct fs *fs;
	register daddr_t nb;
d82 1
a82 1
	struct vnode *vp = ITOV(ip);
d84 3
a86 2
	daddr_t newb, lbn, *bap, pref;
	int osize, nsize, num, i, error;
d88 9
a96 2
	*bpp = NULL;
	if (bn < 0)
d98 2
a99 2
	fs = ip->i_fs;
	lbn = bn;
d107 1
a107 1
	if (nb < NDADDR && nb < bn) {
d115 5
d133 4
a136 4
	if (bn < NDADDR) {
		nb = ip->i_ffs_db[bn];
		if (nb != 0 && ip->i_ffs_size >= (bn + 1) * fs->fs_bsize) {
			error = bread(vp, bn, fs->fs_bsize, NOCRED, &bp);
d141 1
a141 1
			*bpp = bp;
d151 1
a151 1
				error = bread(vp, bn, osize, NOCRED, &bp);
d157 3
a159 2
				error = ffs_realloccg(ip, bn,
				    ffs_blkpref(ip, bn, (int)bn, &ip->i_ffs_db[0]),
d163 4
d169 1
a169 1
			if (ip->i_ffs_size < (bn + 1) * fs->fs_bsize)
d173 2
a174 2
			error = ffs_alloc(ip, bn,
			    ffs_blkpref(ip, bn, (int)bn, &ip->i_ffs_db[0]),
d178 1
a178 1
			bp = getblk(vp, bn, nsize, 0, 0);
d182 4
d187 1
a187 1
		ip->i_ffs_db[bn] = dbtofsb(fs, bp->b_blkno);
d189 1
a189 1
		*bpp = bp;
d196 1
a196 1
	if ((error = ufs_getlbns(vp, bn, indirs, &num)) != 0)
d207 3
d217 2
d220 1
a220 1
		bp->b_blkno = fsbtodb(fs, newb);
d222 15
a236 9
		/*
		 * Write synchronously so that indirect blocks
		 * never point at garbage.
		 */
		if ((error = bwrite(bp)) != 0) {
			ffs_blkfree(ip, nb, fs->fs_bsize);
			return (error);
		}
		ip->i_ffs_ib[indirs[0].in_off] = newb;
d247 1
a247 1
			return (error);
d264 1
a264 1
			return (error);
d267 1
d271 14
a284 8
		/*
		 * Write synchronously so that indirect blocks
		 * never point at garbage.
		 */
		if ((error = bwrite(nbp)) != 0) {
			ffs_blkfree(ip, nb, fs->fs_bsize);
			brelse(bp);
			return (error);
d306 1
a306 1
			return (error);
d309 1
d314 3
d327 1
a327 1
		*bpp = nbp;
d335 1
a335 1
			return (error);
d341 1
a341 1
	*bpp = nbp;
d343 24
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 1
a88 1
	nb = lblkno(fs, ip->i_size);
d93 1
a93 1
				ffs_blkpref(ip, nb, (int)nb, &ip->i_db[0]),
d97 3
a99 3
			ip->i_size = (nb + 1) * fs->fs_bsize;
			vnode_pager_setsize(vp, (u_long)ip->i_size);
			ip->i_db[nb] = dbtofsb(fs, bp->b_blkno);
d111 2
a112 2
		nb = ip->i_db[bn];
		if (nb != 0 && ip->i_size >= (bn + 1) * fs->fs_bsize) {
d125 1
a125 1
			osize = fragroundup(fs, blkoff(fs, ip->i_size));
d135 1
a135 1
				    ffs_blkpref(ip, bn, (int)bn, &ip->i_db[0]),
d141 1
a141 1
			if (ip->i_size < (bn + 1) * fs->fs_bsize)
d146 1
a146 1
			    ffs_blkpref(ip, bn, (int)bn, &ip->i_db[0]),
d155 1
a155 1
		ip->i_db[bn] = dbtofsb(fs, bp->b_blkno);
d174 1
a174 1
	nb = ip->i_ib[indirs[0].in_off];
d193 1
a193 1
		ip->i_ib[indirs[0].in_off] = newb;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ffs_balloc.c,v 1.2 1994/06/29 06:46:29 cgd Exp $	*/
d60 1
d164 1
a164 1
	if (error = ufs_getlbns(vp, bn, indirs, &num))
d177 3
a179 2
	        if (error = ffs_alloc(ip, lbn, pref, (int)fs->fs_bsize,
		    cred, &newb))
d189 1
a189 1
		if (error = bwrite(bp)) {
d217 3
a219 2
		if (error =
		    ffs_alloc(ip, lbn, pref, (int)fs->fs_bsize, cred, &newb)) {
d231 1
a231 1
		if (error = bwrite(nbp)) {
d252 3
a254 2
		if (error = ffs_alloc(ip,
		    lbn, pref, (int)fs->fs_bsize, cred, &newb)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
