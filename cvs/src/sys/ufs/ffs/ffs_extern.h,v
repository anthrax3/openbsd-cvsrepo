head	1.43;
access;
symbols
	OPENBSD_6_1:1.43.0.4
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.42.0.2
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.40.0.10
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.40.0.6
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.37.0.10
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.8
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.6
	OPENBSD_5_0:1.37.0.4
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.2
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.34.0.4
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.33.0.10
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.6
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.4
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.24.0.6
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.4
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.9.0.6
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.8
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2016.08.10.08.04.57;	author natano;	state Exp;
branches;
next	1.42;
commitid	a3QYlN9gTOdBi75t;

1.42
date	2016.05.23.09.31.28;	author natano;	state Exp;
branches;
next	1.41;
commitid	wckQrShbScIX7TCE;

1.41
date	2016.01.12.11.41.00;	author mpi;	state Exp;
branches;
next	1.40;
commitid	PdHHohncj6RrnJZN;

1.40
date	2014.01.25.23.31.12;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2013.05.30.19.19.09;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2010.12.21.20.14.44;	author thib;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.34;

1.34
date	2009.08.14.13.05.08;	author jasper;	state Exp;
branches;
next	1.33;

1.33
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.01.20.23.25;	author pedro;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.01.18.54.27;	author pedro;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.01.06.38.54;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.21.10.01.10;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.31.12.19.42;	author pedro;	state Exp;
branches;
next	1.27;

1.27
date	2006.03.11.21.00.48;	author pedro;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.17.13.56.01;	author pedro;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.09.15.35.53;	author pedro;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.03.02.05.46.01;	author tedu;	state Exp;
branches;
next	1.22;

1.22
date	2004.01.07.20.47.47;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2003.05.26.18.33.17;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches
	1.19.6.1;
next	1.18;

1.18
date	2002.01.25.02.30.26;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.10.04.45.32;	author art;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.13.00.10.56;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.23.02.07.53;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.22.00.11.36;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.21.23.24.31;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.20.01.50.12;	author assar;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.07.04.57.18;	author assar;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.12.05.08.30.38;	author art;	state Exp;
branches;
next	1.7;

1.7
date	98.02.08.22.41.49;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	97.11.09.19.54.34;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.11.06.05.59.18;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.20.21.35;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.06.15.26.29;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.27.36;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	2001.05.14.22.47.40;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.07.04.11.00.48;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2002.03.28.14.54.25;	author niklas;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2004.02.19.11.01.36;	author niklas;	state Exp;
branches;
next	1.9.2.8;

1.9.2.8
date	2004.06.05.23.13.11;	author niklas;	state Exp;
branches;
next	;

1.16.2.1
date	2002.01.31.22.55.49;	author niklas;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	;

1.19.6.1
date	2004.03.03.08.50.13;	author brad;	state Exp;
branches;
next	;

1.21.2.1
date	2004.03.03.08.32.11;	author brad;	state Exp;
branches;
next	;


desc
@@


1.43
log
@ufs_vinit() should really be called ffs_vinit(); it's only called from
ffs code.
ok mpi tedu
@
text
@/*	$OpenBSD: ffs_extern.h,v 1.42 2016/05/23 09:31:28 natano Exp $	*/
/*	$NetBSD: ffs_extern.h,v 1.4 1996/02/09 22:22:22 christos Exp $	*/

/*
 * Copyright (c) 1991, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ffs_extern.h	8.3 (Berkeley) 4/16/94
 */

#define FFS_CLUSTERREAD		1	/* cluster reading enabled */
#define FFS_CLUSTERWRITE	2	/* cluster writing enabled */
#define FFS_REALLOCBLKS		3	/* block reallocation enabled */
#define FFS_ASYNCFREE		4	/* asynchronous block freeing enabled */
#define	FFS_MAX_SOFTDEPS	5	/* maximum structs before slowdown */
#define	FFS_SD_TICKDELAY	6	/* ticks to pause during slowdown */
#define	FFS_SD_WORKLIST_PUSH	7	/* # of worklist cleanups */
#define	FFS_SD_BLK_LIMIT_PUSH	8	/* # of times block limit neared */
#define	FFS_SD_INO_LIMIT_PUSH	9	/* # of times inode limit neared */
#define	FFS_SD_BLK_LIMIT_HIT	10	/* # of times block slowdown imposed */
#define	FFS_SD_INO_LIMIT_HIT	11	/* # of times inode slowdown imposed */
#define	FFS_SD_SYNC_LIMIT_HIT	12	/* # of synchronous slowdowns imposed */
#define	FFS_SD_INDIR_BLK_PTRS	13	/* bufs redirtied as indir ptrs not written */
#define	FFS_SD_INODE_BITMAP	14	/* bufs redirtied as inode bitmap not written */
#define	FFS_SD_DIRECT_BLK_PTRS	15	/* bufs redirtied as direct ptrs not written */
#define	FFS_SD_DIR_ENTRY	16	/* bufs redirtied as dir entry cannot write */
#define	FFS_DIRHASH_DIRSIZE	17	/* min directory size, in bytes */
#define	FFS_DIRHASH_MAXMEM	18	/* max kvm to use, in bytes */
#define	FFS_DIRHASH_MEM		19	/* current mem usage, in bytes */
#define	FFS_MAXID		20	/* number of valid ffs ids */

#define FFS_NAMES { \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "max_softdeps", CTLTYPE_INT }, \
	{ "sd_tickdelay", CTLTYPE_INT }, \
	{ "sd_worklist_push", CTLTYPE_INT }, \
	{ "sd_blk_limit_push", CTLTYPE_INT }, \
	{ "sd_ino_limit_push", CTLTYPE_INT }, \
	{ "sd_blk_limit_hit", CTLTYPE_INT }, \
	{ "sd_ino_limit_hit", CTLTYPE_INT }, \
	{ "sd_sync_limit_hit", CTLTYPE_INT }, \
	{ "sd_indir_blk_ptrs", CTLTYPE_INT }, \
	{ "sd_inode_bitmap", CTLTYPE_INT }, \
	{ "sd_direct_blk_ptrs", CTLTYPE_INT }, \
	{ "sd_dir_entry", CTLTYPE_INT }, \
	{ "dirhash_dirsize", CTLTYPE_INT }, \
	{ "dirhash_maxmem", CTLTYPE_INT }, \
	{ "dirhash_mem", CTLTYPE_INT }, \
}

struct buf;
struct fid;
struct fs;
struct inode;
struct mount;
struct nameidata;
struct proc;
struct statfs;
struct timeval;
struct ucred;
struct ufsmount;
struct vfsconf;
struct uio;
struct vnode;
struct mbuf;
struct cg;
struct vop_vfree_args;

extern struct vops	ffs_vops;
extern struct vops	ffs_specvops;
extern struct vops	ffs_fifovops;

/* ffs_alloc.c */
int ffs_alloc(struct inode *, daddr_t, daddr_t , int, struct ucred *,
		   daddr_t *);
int ffs_realloccg(struct inode *, daddr_t, daddr_t, int, int ,
		       struct ucred *, struct buf **, daddr_t *);
int ffs_inode_alloc(struct inode *, mode_t, struct ucred *, struct vnode **);
int ffs_inode_free(struct inode *, ufsino_t, mode_t);
int ffs_freefile(struct inode *, ufsino_t, mode_t);

int32_t ffs1_blkpref(struct inode *, daddr_t, int, int32_t *);
#ifdef FFS2
int64_t ffs2_blkpref(struct inode *, daddr_t, int, int64_t *);
#endif
void ffs_blkfree(struct inode *, daddr_t, long);
void ffs_clusteracct(struct fs *, struct cg *, daddr_t, int);

/* ffs_balloc.c */
int ffs_balloc(struct inode *, off_t, int, struct ucred *, int, struct buf **);

/* ffs_inode.c */
int ffs_init(struct vfsconf *);
int ffs_update(struct inode *, int);
int ffs_truncate(struct inode *, off_t, int, struct ucred *);

/* ffs_subr.c */
int  ffs_bufatoff(struct inode *, off_t, char **, struct buf **);
void ffs_fragacct(struct fs *, int, int32_t[], int);
#ifdef DIAGNOSTIC
void	ffs_checkoverlap(struct buf *, struct inode *);
#endif
int  ffs_isfreeblock(struct fs *, u_char *, daddr_t);
int  ffs_isblock(struct fs *, u_char *, daddr_t);
void ffs_clrblock(struct fs *, u_char *, daddr_t);
void ffs_setblock(struct fs *, u_char *, daddr_t);
int  ffs_vinit(struct mount *, struct vnode **);

/* ffs_vfsops.c */
int ffs_mountroot(void);
int ffs_mount(struct mount *, const char *, void *, struct nameidata *,
		   struct proc *);
int ffs_reload(struct mount *, struct ucred *, struct proc *);
int ffs_mountfs(struct vnode *, struct mount *, struct proc *);
int ffs_oldfscompat(struct fs *);
int ffs_unmount(struct mount *, int, struct proc *);
int ffs_flushfiles(struct mount *, int, struct proc *);
int ffs_statfs(struct mount *, struct statfs *, struct proc *);
int ffs_sync(struct mount *, int, struct ucred *, struct proc *);
int ffs_vget(struct mount *, ino_t, struct vnode **);
int ffs_fhtovp(struct mount *, struct fid *, struct vnode **);
int ffs_vptofh(struct vnode *, struct fid *);
int ffs_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *);
int ffs_sbupdate(struct ufsmount *, int);
int ffs_cgupdate(struct ufsmount *, int);

/* ffs_vnops.c */
int ffs_read(void *);
int ffs_write(void *);
int ffs_fsync(void *);
int ffs_reclaim(void *);
int ffsfifo_reclaim(void *);

/*
 * Soft dependency function prototypes.
 */

struct vop_vfree_args;
struct vop_fsync_args;

void  softdep_initialize(void);
int   softdep_process_worklist(struct mount *);
int   softdep_mount(struct vnode *, struct mount *, struct fs *,
          struct ucred *);
int   softdep_flushworklist(struct mount *, int *, struct proc *);
int   softdep_flushfiles(struct mount *, int, struct proc *);
void  softdep_update_inodeblock(struct inode *, struct buf *, int);
void  softdep_load_inodeblock(struct inode *);
void  softdep_freefile(struct vnode *, ufsino_t, mode_t);
void  softdep_setup_freeblocks(struct inode *, off_t);
void  softdep_setup_inomapdep(struct buf *, struct inode *, ufsino_t);
void  softdep_setup_blkmapdep(struct buf *, struct fs *, daddr_t);
void  softdep_setup_allocdirect(struct inode *, daddr_t, daddr_t,
            daddr_t, long, long, struct buf *);
void  softdep_setup_allocindir_meta(struct buf *, struct inode *,
            struct buf *, int, daddr_t);
void  softdep_setup_allocindir_page(struct inode *, daddr_t,
            struct buf *, int, daddr_t, daddr_t, struct buf *);
void  softdep_fsync_mountdev(struct vnode *, int);
int   softdep_sync_metadata(struct vop_fsync_args *);
int   softdep_fsync(struct vnode *);

extern struct pool ffs_ino_pool;	/* memory pool for inodes */
extern struct pool ffs_dinode1_pool;	/* memory pool for UFS1 dinodes */
#ifdef FFS2
extern struct pool ffs_dinode2_pool;	/* memory pool for UFS2 dinodes */
#endif
@


1.42
log
@VOP_REALLOCBLKS() and related code is unused since the removal of
cluster_write().
ok beck zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.41 2016/01/12 11:41:00 mpi Exp $	*/
d135 1
a190 6

#ifdef FIFO
#define FFS_FIFOOPS &ffs_fifovops
#else
#define FFS_FIFOOPS NULL
#endif
@


1.41
log
@Remove the "doclusterread" and "doclusterwrite" buttons.

Cluster read is unconditionnally enabled for FFS since some years and
toggling "doclusterread" has no effect.

OpenBSD no longer support write clustering since the Dynamic Buffer
Cache went in, so there is reason to delay the call to bawrite(9).

Tested by Mathieu, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.40 2014/01/25 23:31:12 guenther Exp $	*/
d60 2
a61 2
	{ "doreallocblks", CTLTYPE_INT }, \
	{ "doasyncfree", CTLTYPE_INT }, \
a105 1
int ffs_reallocblks(void *);
@


1.40
log
@ufs_setattr() was assuming that the flag bits that indicate
atime/mtime/ctime need to be updated weren't already set.  When
they are, the code will end up treating the VNOVAL value from the
VFS layer as a time_t.  Port the fix from FreeBSD: the critical bit
is to process the existing flag values before possibly setting them
again in ufs_setattr().  This diff pulls in a larger change from
FreeBSD to replace the macro ITIMES() with a function ufs_itimes()
and to remove the atime and mtime arguments from ffs_update(): only
ufs_setattr() used them so it makes more sense to just do the those
bits directly there.

tweaks and ok tedu@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.39 2013/06/11 16:42:18 deraadt Exp $	*/
d58 2
a59 2
	{ "doclusterread", CTLTYPE_INT }, \
	{ "doclusterwrite", CTLTYPE_INT }, \
@


1.39
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.38 2013/05/30 19:19:09 guenther Exp $	*/
d123 1
a123 1
int ffs_update(struct inode *, struct timespec *, struct timespec *, int);
@


1.38
log
@UFS does't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

otto wrote the original diff for libsa to keep bootblock from overflowing
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.37 2010/12/21 20:14:44 thib Exp $	*/
d102 4
a105 4
int ffs_alloc(struct inode *, daddr64_t, daddr64_t , int, struct ucred *,
		   daddr64_t *);
int ffs_realloccg(struct inode *, daddr64_t, daddr64_t, int, int ,
		       struct ucred *, struct buf **, daddr64_t *);
d111 1
a111 1
int32_t ffs1_blkpref(struct inode *, daddr64_t, int, int32_t *);
d113 1
a113 1
int64_t ffs2_blkpref(struct inode *, daddr64_t, int, int64_t *);
d115 2
a116 2
void ffs_blkfree(struct inode *, daddr64_t, long);
void ffs_clusteracct(struct fs *, struct cg *, daddr64_t, int);
d132 4
a135 4
int  ffs_isfreeblock(struct fs *, u_char *, daddr64_t);
int  ffs_isblock(struct fs *, u_char *, daddr64_t);
void ffs_clrblock(struct fs *, u_char *, daddr64_t);
void ffs_setblock(struct fs *, u_char *, daddr64_t);
d181 3
a183 3
void  softdep_setup_blkmapdep(struct buf *, struct fs *, daddr64_t);
void  softdep_setup_allocdirect(struct inode *, daddr64_t, daddr64_t,
            daddr64_t, long, long, struct buf *);
d185 3
a187 3
            struct buf *, int, daddr64_t);
void  softdep_setup_allocindir_page(struct inode *, daddr64_t,
            struct buf *, int, daddr64_t, daddr64_t, struct buf *);
@


1.37
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.36 2010/09/10 16:34:09 thib Exp $	*/
d108 2
a109 2
int ffs_inode_free(struct inode *, ino_t, mode_t);
int ffs_freefile(struct inode *, ino_t, mode_t);
d178 1
a178 1
void  softdep_freefile(struct vnode *, ino_t, mode_t);
d180 1
a180 1
void  softdep_setup_inomapdep(struct buf *, struct inode *, ino_t);
@


1.36
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.35 2010/09/06 23:44:10 thib Exp $	*/
d97 3
a99 1
__BEGIN_DECLS
a190 1
__END_DECLS
a191 2
extern int (**ffs_vnodeop_p)(void *);
extern int (**ffs_specop_p)(void *);
d193 1
a193 2
extern int (**ffs_fifoop_p)(void *);
#define FFS_FIFOOPS ffs_fifoop_p
@


1.35
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.34 2009/08/14 13:05:08 jasper Exp $	*/
d97 1
a97 3
extern struct vops	ffs_vops;
extern struct vops	ffs_specvops;
extern struct vops	ffs_fifovops;
d189 1
d191 2
d194 2
a195 1
#define FFS_FIFOOPS &ffs_fifovops
@


1.34
log
@- use u_char consistently
- minor formatting

ok oga@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.33 2008/01/05 19:49:26 otto Exp $	*/
d97 3
a99 1
__BEGIN_DECLS
a190 1
__END_DECLS
a191 2
extern int (**ffs_vnodeop_p)(void *);
extern int (**ffs_specop_p)(void *);
d193 1
a193 2
extern int (**ffs_fifoop_p)(void *);
#define FFS_FIFOOPS ffs_fifoop_p
@


1.33
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.32 2007/06/01 20:23:25 pedro Exp $	*/
d125 1
a125 1
int ffs_bufatoff(struct inode *, off_t, char **, struct buf **);
d130 2
a131 2
int   ffs_isfreeblock(struct fs *, unsigned char *, daddr64_t);
int ffs_isblock(struct fs *, unsigned char *, daddr64_t);
d133 1
a133 1
void ffs_setblock(struct fs *, unsigned char *, daddr64_t);
@


1.32
log
@Nuke 'ufs_lbn_t', okay otto@@ deraadt@@ krw@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.31 2007/06/01 18:54:27 pedro Exp $	*/
d100 4
a103 4
int ffs_alloc(struct inode *, daddr_t, daddr_t , int, struct ucred *,
		   daddr_t *);
int ffs_realloccg(struct inode *, daddr_t, daddr_t, int, int ,
		       struct ucred *, struct buf **, daddr_t *);
d109 1
a109 1
int32_t ffs1_blkpref(struct inode *, daddr_t, int, int32_t *);
d111 1
a111 1
int64_t ffs2_blkpref(struct inode *, daddr_t, int, int64_t *);
d114 1
a114 1
void ffs_clusteracct(struct fs *, struct cg *, daddr_t, int);
d130 4
a133 4
int   ffs_isfreeblock(struct fs *, unsigned char *, daddr_t);
int ffs_isblock(struct fs *, unsigned char *, daddr_t);
void ffs_clrblock(struct fs *, u_char *, daddr_t);
void ffs_setblock(struct fs *, unsigned char *, daddr_t);
d179 3
a181 3
void  softdep_setup_blkmapdep(struct buf *, struct fs *, daddr_t);
void  softdep_setup_allocdirect(struct inode *, daddr64_t, daddr_t,
            daddr_t, long, long, struct buf *);
d183 1
a183 1
            struct buf *, int, daddr_t);
d185 1
a185 1
            struct buf *, int, daddr_t, daddr_t, struct buf *);
@


1.31
log
@cleanup of 'ufs1_daddr_t', first round, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.30 2007/06/01 06:38:54 deraadt Exp $	*/
d180 1
a180 1
void  softdep_setup_allocdirect(struct inode *, ufs_lbn_t, daddr_t,
d184 1
a184 1
void  softdep_setup_allocindir_page(struct inode *, ufs_lbn_t,
@


1.30
log
@convert ufs2_daddr_t -> daddr64_t for greater clarity; ok pedro otto thib
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.29 2006/06/21 10:01:10 mickey Exp $	*/
d109 1
a109 1
ufs1_daddr_t ffs1_blkpref(struct inode *, daddr_t, int, ufs1_daddr_t *);
d111 1
a111 1
daddr64_t ffs2_blkpref(struct inode *, daddr_t, int, daddr64_t *);
d113 1
a113 1
void ffs_blkfree(struct inode *, daddr_t, long);
@


1.29
log
@propagate the wait flag from fsync down to softdep_fsync_mountdev()
and do not perform synchronous sync there is no wait requested by
skipping the drain_output() call. this fixes a problem where
update kthread would sleep forever on some vnode since work is created
faster than it can be flushed. pedro@@ ok; tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.28 2006/03/31 12:19:42 pedro Exp $	*/
d111 1
a111 1
ufs2_daddr_t ffs2_blkpref(struct inode *, daddr_t, int, ufs2_daddr_t *);
@


1.28
log
@Add a pool for FFS2 dinodes
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.27 2006/03/11 21:00:48 pedro Exp $	*/
d186 1
a186 1
void  softdep_fsync_mountdev(struct vnode *);
@


1.27
log
@Add UFS2 block allocation functions, okay tedu@@.
Thanks to all those who tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.26 2005/12/17 13:56:01 pedro Exp $	*/
d202 3
@


1.26
log
@Remove the 'on disk' inode (dinode) from the 'in memory' inode in UFS.
Instead of having the dinode inside the inode structure itself, we now
have just a pointer to it, and use a separate pool to allocate dinodes
as needed. Inspiration from FreeBSD, various testing for a while, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.25 2005/11/09 15:35:53 pedro Exp $	*/
d109 4
a112 1
daddr_t ffs_blkpref(struct inode *, daddr_t, int, daddr_t *);
@


1.25
log
@ANSI function declarations and deregister, only ffs_softdep left to go
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.24 2004/07/13 21:04:29 millert Exp $	*/
d197 2
a198 1
extern struct pool ffs_ino_pool;
@


1.24
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.23 2004/03/02 05:46:01 tedu Exp $	*/
d4 1
a4 1
/*-
a78 1

a157 1

d185 1
a185 1
int   softdep_fsync(struct vnode *vp);
@


1.23
log
@silly fifos aren't a real fs, so we have to be sure to call reclaim
in the host fs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.22 2004/01/07 20:47:47 tedu Exp $	*/
d106 3
a108 3
int ffs_inode_alloc(struct inode *, int, struct ucred *, struct vnode **);
int ffs_inode_free(struct inode *, ino_t, int);
int ffs_freefile(struct inode *, ino_t, int);
d175 1
a175 1
void  softdep_freefile(struct vnode *, ino_t, int);
@


1.22
log
@sysctls for dirhash variables.  with a hint from miod.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.21 2003/06/02 23:28:23 millert Exp $	*/
d157 1
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.20 2003/05/26 18:33:17 tedu Exp $	*/
d51 4
a54 1
#define	FFS_MAXID		17	/* number of valid ffs ids */
d74 3
@


1.21.2.1
log
@MFC:
Fix from tedu@@

prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.21 2003/06/02 23:28:23 millert Exp $	*/
a150 1
int ffsfifo_reclaim(void *);
@


1.20
log
@fiddle with some type names.  change most instances of ufs_daddr_t to
ufs1_daddr_t, a few to daddr_t.  ufs_daddr_t typedef is retained, but consider
it deprecated.  no functional changes.  inspired by freebsd.  ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.19 2002/03/14 01:27:14 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.18 2002/01/25 02:30:26 millert Exp $	*/
d175 3
a177 3
void  softdep_setup_blkmapdep(struct buf *, struct fs *, ufs_daddr_t);
void  softdep_setup_allocdirect(struct inode *, ufs_lbn_t, ufs_daddr_t,
            ufs_daddr_t, long, long, struct buf *);
d179 1
a179 1
            struct buf *, int, ufs_daddr_t);
d181 1
a181 1
            struct buf *, int, ufs_daddr_t, ufs_daddr_t, struct buf *);
@


1.19.6.1
log
@MFC:
Fix from tedu@@

prevent memory leak on revoke by freeing resources in a real reclaim
function.
also check fifoinfo is valid before deref.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.19 2002/03/14 01:27:14 millert Exp $	*/
a154 1
int ffsfifo_reclaim(void *);
@


1.18
log
@Move softdep sysctls from debug to vfs.ffs; art@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.17 2001/12/19 08:58:07 art Exp $	*/
d99 5
a103 5
int ffs_alloc __P((struct inode *, daddr_t, daddr_t , int, struct ucred *,
		   daddr_t *));
int ffs_realloccg __P((struct inode *, daddr_t, daddr_t, int, int ,
		       struct ucred *, struct buf **, daddr_t *));
int ffs_reallocblks __P((void *));
d108 3
a110 3
daddr_t ffs_blkpref __P((struct inode *, daddr_t, int, daddr_t *));
void ffs_blkfree __P((struct inode *, daddr_t, long));
void ffs_clusteracct __P((struct fs *, struct cg *, daddr_t, int));
d116 1
a116 1
int ffs_init __P((struct vfsconf *));
d122 1
a122 1
void ffs_fragacct __P((struct fs *, int, int32_t[], int));
d124 1
a124 1
void	ffs_checkoverlap __P((struct buf *, struct inode *));
d126 4
a129 4
int   ffs_isfreeblock __P((struct fs *, unsigned char *, daddr_t));
int ffs_isblock __P((struct fs *, unsigned char *, daddr_t));
void ffs_clrblock __P((struct fs *, u_char *, daddr_t));
void ffs_setblock __P((struct fs *, unsigned char *, daddr_t));
d132 17
a148 17
int ffs_mountroot __P((void));
int ffs_mount __P((struct mount *, const char *, void *, struct nameidata *,
		   struct proc *));
int ffs_reload __P((struct mount *, struct ucred *, struct proc *));
int ffs_mountfs __P((struct vnode *, struct mount *, struct proc *));
int ffs_oldfscompat __P((struct fs *));
int ffs_unmount __P((struct mount *, int, struct proc *));
int ffs_flushfiles __P((struct mount *, int, struct proc *));
int ffs_statfs __P((struct mount *, struct statfs *, struct proc *));
int ffs_sync __P((struct mount *, int, struct ucred *, struct proc *));
int ffs_vget __P((struct mount *, ino_t, struct vnode **));
int ffs_fhtovp __P((struct mount *, struct fid *, struct vnode **));
int ffs_vptofh __P((struct vnode *, struct fid *));
int ffs_sysctl __P((int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *));
int ffs_sbupdate __P((struct ufsmount *, int));
int ffs_cgupdate __P((struct ufsmount *, int));
d151 4
a154 4
int ffs_read __P((void *));
int ffs_write __P((void *));
int ffs_fsync __P((void *));
int ffs_reclaim __P((void *));
d164 21
a184 21
void  softdep_initialize __P((void));
int   softdep_process_worklist __P((struct mount *));
int   softdep_mount __P((struct vnode *, struct mount *, struct fs *,
          struct ucred *));
int   softdep_flushworklist __P((struct mount *, int *, struct proc *));
int   softdep_flushfiles __P((struct mount *, int, struct proc *));
void  softdep_update_inodeblock __P((struct inode *, struct buf *, int));
void  softdep_load_inodeblock __P((struct inode *));
void  softdep_freefile __P((struct vnode *, ino_t, int));
void  softdep_setup_freeblocks __P((struct inode *, off_t));
void  softdep_setup_inomapdep __P((struct buf *, struct inode *, ino_t));
void  softdep_setup_blkmapdep __P((struct buf *, struct fs *, ufs_daddr_t));
void  softdep_setup_allocdirect __P((struct inode *, ufs_lbn_t, ufs_daddr_t,
            ufs_daddr_t, long, long, struct buf *));
void  softdep_setup_allocindir_meta __P((struct buf *, struct inode *,
            struct buf *, int, ufs_daddr_t));
void  softdep_setup_allocindir_page __P((struct inode *, ufs_lbn_t,
            struct buf *, int, ufs_daddr_t, ufs_daddr_t, struct buf *));
void  softdep_fsync_mountdev __P((struct vnode *));
int   softdep_sync_metadata __P((struct vop_fsync_args *));
int   softdep_fsync __P((struct vnode *vp));
d187 2
a188 2
extern int (**ffs_vnodeop_p) __P((void *));
extern int (**ffs_specop_p) __P((void *));
d190 1
a190 1
extern int (**ffs_fifoop_p) __P((void *));
@


1.17
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.14 2001/11/13 00:10:56 art Exp $	*/
d43 13
a55 1
#define	FFS_MAXID		5	/* number of valid ffs ids */
d63 12
@


1.16
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.15 2001/11/27 05:27:12 art Exp $	*/
a89 1
int ffs_gop_alloc(struct vnode *, off_t, off_t, int, struct ucred *);
d131 1
a131 1
void ffs_gop_size __P((struct vnode *, off_t, off_t *));
@


1.16.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.18 2002/01/25 02:30:26 millert Exp $	*/
d43 1
a43 13
#define	FFS_MAX_SOFTDEPS	5	/* maximum structs before slowdown */
#define	FFS_SD_TICKDELAY	6	/* ticks to pause during slowdown */
#define	FFS_SD_WORKLIST_PUSH	7	/* # of worklist cleanups */
#define	FFS_SD_BLK_LIMIT_PUSH	8	/* # of times block limit neared */
#define	FFS_SD_INO_LIMIT_PUSH	9	/* # of times inode limit neared */
#define	FFS_SD_BLK_LIMIT_HIT	10	/* # of times block slowdown imposed */
#define	FFS_SD_INO_LIMIT_HIT	11	/* # of times inode slowdown imposed */
#define	FFS_SD_SYNC_LIMIT_HIT	12	/* # of synchronous slowdowns imposed */
#define	FFS_SD_INDIR_BLK_PTRS	13	/* bufs redirtied as indir ptrs not written */
#define	FFS_SD_INODE_BITMAP	14	/* bufs redirtied as inode bitmap not written */
#define	FFS_SD_DIRECT_BLK_PTRS	15	/* bufs redirtied as direct ptrs not written */
#define	FFS_SD_DIR_ENTRY	16	/* bufs redirtied as dir entry cannot write */
#define	FFS_MAXID		17	/* number of valid ffs ids */
a50 12
	{ "max_softdeps", CTLTYPE_INT }, \
	{ "sd_tickdelay", CTLTYPE_INT }, \
	{ "sd_worklist_push", CTLTYPE_INT }, \
	{ "sd_blk_limit_push", CTLTYPE_INT }, \
	{ "sd_ino_limit_push", CTLTYPE_INT }, \
	{ "sd_blk_limit_hit", CTLTYPE_INT }, \
	{ "sd_ino_limit_hit", CTLTYPE_INT }, \
	{ "sd_sync_limit_hit", CTLTYPE_INT }, \
	{ "sd_indir_blk_ptrs", CTLTYPE_INT }, \
	{ "sd_inode_bitmap", CTLTYPE_INT }, \
	{ "sd_direct_blk_ptrs", CTLTYPE_INT }, \
	{ "sd_dir_entry", CTLTYPE_INT }, \
@


1.16.2.2
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.16.2.1 2002/01/31 22:55:49 niklas Exp $	*/
a155 1
int ffs_getpages __P((void *));
@


1.16.2.3
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.16.2.2 2002/02/02 03:28:26 art Exp $	*/
d99 5
a103 5
int ffs_alloc(struct inode *, daddr_t, daddr_t , int, struct ucred *,
		   daddr_t *);
int ffs_realloccg(struct inode *, daddr_t, daddr_t, int, int ,
		       struct ucred *, struct buf **, daddr_t *);
int ffs_reallocblks(void *);
d108 3
a110 3
daddr_t ffs_blkpref(struct inode *, daddr_t, int, daddr_t *);
void ffs_blkfree(struct inode *, daddr_t, long);
void ffs_clusteracct(struct fs *, struct cg *, daddr_t, int);
d117 1
a117 1
int ffs_init(struct vfsconf *);
d123 1
a123 1
void ffs_fragacct(struct fs *, int, int32_t[], int);
d125 1
a125 1
void	ffs_checkoverlap(struct buf *, struct inode *);
d127 4
a130 4
int   ffs_isfreeblock(struct fs *, unsigned char *, daddr_t);
int ffs_isblock(struct fs *, unsigned char *, daddr_t);
void ffs_clrblock(struct fs *, u_char *, daddr_t);
void ffs_setblock(struct fs *, unsigned char *, daddr_t);
d133 17
a149 17
int ffs_mountroot(void);
int ffs_mount(struct mount *, const char *, void *, struct nameidata *,
		   struct proc *);
int ffs_reload(struct mount *, struct ucred *, struct proc *);
int ffs_mountfs(struct vnode *, struct mount *, struct proc *);
int ffs_oldfscompat(struct fs *);
int ffs_unmount(struct mount *, int, struct proc *);
int ffs_flushfiles(struct mount *, int, struct proc *);
int ffs_statfs(struct mount *, struct statfs *, struct proc *);
int ffs_sync(struct mount *, int, struct ucred *, struct proc *);
int ffs_vget(struct mount *, ino_t, struct vnode **);
int ffs_fhtovp(struct mount *, struct fid *, struct vnode **);
int ffs_vptofh(struct vnode *, struct fid *);
int ffs_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *);
int ffs_sbupdate(struct ufsmount *, int);
int ffs_cgupdate(struct ufsmount *, int);
d152 6
a157 7
int ffs_read(void *);
int ffs_write(void *);
int ffs_fsync(void *);
int ffs_reclaim(void *);
int ffs_getpages(void *);
void ffs_gop_size(struct vnode *, off_t, off_t *);

d166 21
a186 21
void  softdep_initialize(void);
int   softdep_process_worklist(struct mount *);
int   softdep_mount(struct vnode *, struct mount *, struct fs *,
          struct ucred *);
int   softdep_flushworklist(struct mount *, int *, struct proc *);
int   softdep_flushfiles(struct mount *, int, struct proc *);
void  softdep_update_inodeblock(struct inode *, struct buf *, int);
void  softdep_load_inodeblock(struct inode *);
void  softdep_freefile(struct vnode *, ino_t, int);
void  softdep_setup_freeblocks(struct inode *, off_t);
void  softdep_setup_inomapdep(struct buf *, struct inode *, ino_t);
void  softdep_setup_blkmapdep(struct buf *, struct fs *, ufs_daddr_t);
void  softdep_setup_allocdirect(struct inode *, ufs_lbn_t, ufs_daddr_t,
            ufs_daddr_t, long, long, struct buf *);
void  softdep_setup_allocindir_meta(struct buf *, struct inode *,
            struct buf *, int, ufs_daddr_t);
void  softdep_setup_allocindir_page(struct inode *, ufs_lbn_t,
            struct buf *, int, ufs_daddr_t, ufs_daddr_t, struct buf *);
void  softdep_fsync_mountdev(struct vnode *);
int   softdep_sync_metadata(struct vop_fsync_args *);
int   softdep_fsync(struct vnode *vp);
d189 2
a190 2
extern int (**ffs_vnodeop_p)(void *);
extern int (**ffs_specop_p)(void *);
d192 1
a192 1
extern int (**ffs_fifoop_p)(void *);
@


1.16.2.4
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.16.2.3 2002/06/11 03:32:50 art Exp $	*/
a156 1
int ffs_putpages(void *);
@


1.15
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.14 2001/11/13 00:10:56 art Exp $	*/
d90 1
a90 1
int ffs_ballocn(void *);
d132 1
a132 1
int ffs_size __P((void *));
@


1.14
log
@Allow the bpp arguemnt on ffs_realloccg to be NULL, don't return the
buffer in that case. Also add a new argument - blknop, which can be used to
return the allocated blkno.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.13 2001/06/23 02:07:53 csapuntz Exp $	*/
d90 1
d132 1
a132 1

@


1.13
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.12 2001/03/22 00:11:36 art Exp $	*/
d78 1
a78 1
		       struct ucred *, struct buf **));
@


1.12
log
@Change the ffs inode allocation from using malloc to pool.
Saves approx. 256k memory on a GENERIC i386 and moves 670k out of kmem_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.11 2001/02/21 23:24:31 csapuntz Exp $	*/
d80 4
a83 1
int ffs_valloc __P((void *));
a85 1
int ffs_vfree __P((void *));
d89 1
a89 1
int ffs_balloc __P((void *));
d93 2
a94 2
int ffs_update __P((void *));
int ffs_truncate __P((void *));
d97 1
a97 1
int ffs_blkatoff __P((void *));
a101 1
int   ffs_freefile __P((struct vop_vfree_args *));
@


1.11
log
@

Latest soft updates from FreeBSD/Kirk McKusick

Snapshot-related code has been commented out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.10 2001/02/20 01:50:12 assar Exp $	*/
d170 2
@


1.10
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.9 2000/02/07 04:57:18 assar Exp $	*/
d143 1
d147 1
a147 2
int   softdep_fsync __P((struct vnode *));
void  softdep_freefile __P((struct vop_vfree_args *));
a148 1
void  softdep_deallocate_dependencies __P((struct buf *));
d150 3
a152 3
void  softdep_setup_blkmapdep __P((struct buf *, struct fs *, daddr_t));
void  softdep_setup_allocdirect __P((struct inode *, ufs_lbn_t, daddr_t,
          daddr_t, long, long, struct buf *));
d154 1
a154 1
          struct buf *, int, daddr_t));
d156 2
a157 3
          struct buf *, int, daddr_t, daddr_t, struct buf *));
void  softdep_disk_io_initiation __P((struct buf *));
void  softdep_disk_write_complete __P((struct buf *));
d159 1
a159 1
void  softdep_fsync_mountdev __P((struct vnode *));
@


1.9
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.8 1999/12/05 08:30:38 art Exp $	*/
d108 1
a108 1
int ffs_mount __P((struct mount *, const char *, caddr_t, struct nameidata *,
@


1.9.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.12 2001/03/22 00:11:36 art Exp $	*/
d108 1
a108 1
int ffs_mount __P((struct mount *, const char *, void *, struct nameidata *,
a142 1
int   softdep_flushworklist __P((struct mount *, int *, struct proc *));
d146 2
a147 1
void  softdep_freefile __P((struct vnode *, ino_t, int));
d149 1
d151 3
a153 3
void  softdep_setup_blkmapdep __P((struct buf *, struct fs *, ufs_daddr_t));
void  softdep_setup_allocdirect __P((struct inode *, ufs_lbn_t, ufs_daddr_t,
            ufs_daddr_t, long, long, struct buf *));
d155 1
a155 1
            struct buf *, int, ufs_daddr_t));
d157 4
a160 1
            struct buf *, int, ufs_daddr_t, ufs_daddr_t, struct buf *));
a161 2
int   softdep_sync_metadata __P((struct vop_fsync_args *));
int   softdep_fsync __P((struct vnode *vp));
a171 2

extern struct pool ffs_ino_pool;
@


1.9.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.9.2.1 2001/05/14 22:47:40 niklas Exp $	*/
d80 1
a80 4
int ffs_inode_alloc(struct inode *, int, struct ucred *, struct vnode **);
int ffs_inode_free(struct inode *, ino_t, int);
int ffs_freefile(struct inode *, ino_t, int);

d83 1
d87 1
a87 1
int ffs_balloc(struct inode *, off_t, int, struct ucred *, int, struct buf **);
d91 2
a92 2
int ffs_update(struct inode *, struct timespec *, struct timespec *, int);
int ffs_truncate(struct inode *, off_t, int, struct ucred *);
d95 1
a95 1
int ffs_bufatoff(struct inode *, off_t, char **, struct buf **);
d100 1
@


1.9.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 1
a78 1
		       struct ucred *, struct buf **, daddr_t *));
a89 1
int ffs_ballocn(void *);
d131 1
a131 1
int ffs_size __P((void *));
@


1.9.2.4
log
@Merge in trunk
@
text
@d43 1
a43 13
#define	FFS_MAX_SOFTDEPS	5	/* maximum structs before slowdown */
#define	FFS_SD_TICKDELAY	6	/* ticks to pause during slowdown */
#define	FFS_SD_WORKLIST_PUSH	7	/* # of worklist cleanups */
#define	FFS_SD_BLK_LIMIT_PUSH	8	/* # of times block limit neared */
#define	FFS_SD_INO_LIMIT_PUSH	9	/* # of times inode limit neared */
#define	FFS_SD_BLK_LIMIT_HIT	10	/* # of times block slowdown imposed */
#define	FFS_SD_INO_LIMIT_HIT	11	/* # of times inode slowdown imposed */
#define	FFS_SD_SYNC_LIMIT_HIT	12	/* # of synchronous slowdowns imposed */
#define	FFS_SD_INDIR_BLK_PTRS	13	/* bufs redirtied as indir ptrs not written */
#define	FFS_SD_INODE_BITMAP	14	/* bufs redirtied as inode bitmap not written */
#define	FFS_SD_DIRECT_BLK_PTRS	15	/* bufs redirtied as direct ptrs not written */
#define	FFS_SD_DIR_ENTRY	16	/* bufs redirtied as dir entry cannot write */
#define	FFS_MAXID		17	/* number of valid ffs ids */
a50 12
	{ "max_softdeps", CTLTYPE_INT }, \
	{ "sd_tickdelay", CTLTYPE_INT }, \
	{ "sd_worklist_push", CTLTYPE_INT }, \
	{ "sd_blk_limit_push", CTLTYPE_INT }, \
	{ "sd_ino_limit_push", CTLTYPE_INT }, \
	{ "sd_blk_limit_hit", CTLTYPE_INT }, \
	{ "sd_ino_limit_hit", CTLTYPE_INT }, \
	{ "sd_sync_limit_hit", CTLTYPE_INT }, \
	{ "sd_indir_blk_ptrs", CTLTYPE_INT }, \
	{ "sd_inode_bitmap", CTLTYPE_INT }, \
	{ "sd_direct_blk_ptrs", CTLTYPE_INT }, \
	{ "sd_dir_entry", CTLTYPE_INT }, \
d90 1
d132 1
a132 1

@


1.9.2.5
log
@Merge in -current from roughly a week ago
@
text
@d99 5
a103 5
int ffs_alloc(struct inode *, daddr_t, daddr_t , int, struct ucred *,
		   daddr_t *);
int ffs_realloccg(struct inode *, daddr_t, daddr_t, int, int ,
		       struct ucred *, struct buf **, daddr_t *);
int ffs_reallocblks(void *);
d108 3
a110 3
daddr_t ffs_blkpref(struct inode *, daddr_t, int, daddr_t *);
void ffs_blkfree(struct inode *, daddr_t, long);
void ffs_clusteracct(struct fs *, struct cg *, daddr_t, int);
d116 1
a116 1
int ffs_init(struct vfsconf *);
d122 1
a122 1
void ffs_fragacct(struct fs *, int, int32_t[], int);
d124 1
a124 1
void	ffs_checkoverlap(struct buf *, struct inode *);
d126 4
a129 4
int   ffs_isfreeblock(struct fs *, unsigned char *, daddr_t);
int ffs_isblock(struct fs *, unsigned char *, daddr_t);
void ffs_clrblock(struct fs *, u_char *, daddr_t);
void ffs_setblock(struct fs *, unsigned char *, daddr_t);
d132 17
a148 17
int ffs_mountroot(void);
int ffs_mount(struct mount *, const char *, void *, struct nameidata *,
		   struct proc *);
int ffs_reload(struct mount *, struct ucred *, struct proc *);
int ffs_mountfs(struct vnode *, struct mount *, struct proc *);
int ffs_oldfscompat(struct fs *);
int ffs_unmount(struct mount *, int, struct proc *);
int ffs_flushfiles(struct mount *, int, struct proc *);
int ffs_statfs(struct mount *, struct statfs *, struct proc *);
int ffs_sync(struct mount *, int, struct ucred *, struct proc *);
int ffs_vget(struct mount *, ino_t, struct vnode **);
int ffs_fhtovp(struct mount *, struct fid *, struct vnode **);
int ffs_vptofh(struct vnode *, struct fid *);
int ffs_sysctl(int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *);
int ffs_sbupdate(struct ufsmount *, int);
int ffs_cgupdate(struct ufsmount *, int);
d151 4
a154 4
int ffs_read(void *);
int ffs_write(void *);
int ffs_fsync(void *);
int ffs_reclaim(void *);
d164 21
a184 21
void  softdep_initialize(void);
int   softdep_process_worklist(struct mount *);
int   softdep_mount(struct vnode *, struct mount *, struct fs *,
          struct ucred *);
int   softdep_flushworklist(struct mount *, int *, struct proc *);
int   softdep_flushfiles(struct mount *, int, struct proc *);
void  softdep_update_inodeblock(struct inode *, struct buf *, int);
void  softdep_load_inodeblock(struct inode *);
void  softdep_freefile(struct vnode *, ino_t, int);
void  softdep_setup_freeblocks(struct inode *, off_t);
void  softdep_setup_inomapdep(struct buf *, struct inode *, ino_t);
void  softdep_setup_blkmapdep(struct buf *, struct fs *, ufs_daddr_t);
void  softdep_setup_allocdirect(struct inode *, ufs_lbn_t, ufs_daddr_t,
            ufs_daddr_t, long, long, struct buf *);
void  softdep_setup_allocindir_meta(struct buf *, struct inode *,
            struct buf *, int, ufs_daddr_t);
void  softdep_setup_allocindir_page(struct inode *, ufs_lbn_t,
            struct buf *, int, ufs_daddr_t, ufs_daddr_t, struct buf *);
void  softdep_fsync_mountdev(struct vnode *);
int   softdep_sync_metadata(struct vop_fsync_args *);
int   softdep_fsync(struct vnode *vp);
d187 2
a188 2
extern int (**ffs_vnodeop_p)(void *);
extern int (**ffs_specop_p)(void *);
d190 1
a190 1
extern int (**ffs_fifoop_p)(void *);
@


1.9.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.9.2.5 2002/03/28 14:54:25 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d175 3
a177 3
void  softdep_setup_blkmapdep(struct buf *, struct fs *, daddr_t);
void  softdep_setup_allocdirect(struct inode *, ufs_lbn_t, daddr_t,
            daddr_t, long, long, struct buf *);
d179 1
a179 1
            struct buf *, int, daddr_t);
d181 1
a181 1
            struct buf *, int, daddr_t, daddr_t, struct buf *);
@


1.9.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 1
a51 4
#define	FFS_DIRHASH_DIRSIZE	17	/* min directory size, in bytes */
#define	FFS_DIRHASH_MAXMEM	18	/* max kvm to use, in bytes */
#define	FFS_DIRHASH_MEM		19	/* current mem usage, in bytes */
#define	FFS_MAXID		20	/* number of valid ffs ids */
a70 3
	{ "dirhash_dirsize", CTLTYPE_INT }, \
	{ "dirhash_maxmem", CTLTYPE_INT }, \
	{ "dirhash_mem", CTLTYPE_INT }, \
@


1.9.2.8
log
@Merge with the trunk
@
text
@a156 1
int ffsfifo_reclaim(void *);
@


1.8
log
@Integrate the latest soft updates code.
From mckusick@@mckusick.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.7 1998/02/08 22:41:49 tholo Exp $	*/
d118 1
a118 2
int ffs_fhtovp __P((struct mount *, struct fid *, struct mbuf *,
		    struct vnode **, int *, struct ucred **));
@


1.7
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.6 1997/11/09 19:54:34 millert Exp $	*/
d162 1
a162 1

@


1.6
log
@Include stub decl for struct vop_vfree_args to avoid copiler warnings.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.5 1997/11/06 05:59:18 csapuntz Exp $	*/
d108 1
a108 1
int ffs_mount __P((struct mount *, char *, caddr_t, struct nameidata *,
@


1.5
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.4 1997/10/06 20:21:35 deraadt Exp $	*/
d70 1
@


1.4
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_extern.h,v 1.2 1996/02/27 07:27:36 niklas Exp $	*/
d39 15
d65 1
d86 1
a86 2
int ffs_balloc __P((struct inode *, daddr_t, int, struct ucred *,
		    struct buf **, int));
d89 1
a89 1
void ffs_init __P((void));
d99 2
d120 2
d130 32
@


1.3
log
@VFS Lite2 Changes
@
text
@a38 15
#define FFS_CLUSTERREAD		1	/* cluster reading enabled */
#define FFS_CLUSTERWRITE	2	/* cluster writing enabled */
#define FFS_REALLOCBLKS		3	/* block reallocation enabled */
#define FFS_ASYNCFREE		4	/* asynchronous block freeing enabled */
#define	FFS_MAXID		5	/* number of valid ffs ids */

#define FFS_NAMES { \
	{ 0, 0 }, \
	{ "doclusterread", CTLTYPE_INT }, \
	{ "doclusterwrite", CTLTYPE_INT }, \
	{ "doreallocblks", CTLTYPE_INT }, \
	{ "doasyncfree", CTLTYPE_INT }, \
}


a49 1
struct vfsconf;
d70 2
a71 1
int ffs_balloc __P((void *));
d74 1
a74 1
int ffs_init __P((struct vfsconf *));
a83 2
int   ffs_freefile __P((struct vop_vfree_args *));
int   ffs_isfreeblock __P((struct fs *, unsigned char *, daddr_t));
a102 2
int ffs_sysctl __P((int *, u_int, void *, size_t *, void *, size_t,
		    struct proc *));
a110 32


/*
 * Soft dependency function prototypes.
 */

struct vop_vfree_args;
struct vop_fsync_args;

void  softdep_initialize __P((void));
int   softdep_process_worklist __P((struct mount *));
int   softdep_mount __P((struct vnode *, struct mount *, struct fs *,
          struct ucred *));
int   softdep_flushfiles __P((struct mount *, int, struct proc *));
void  softdep_update_inodeblock __P((struct inode *, struct buf *, int));
void  softdep_load_inodeblock __P((struct inode *));
int   softdep_fsync __P((struct vnode *));
void  softdep_freefile __P((struct vop_vfree_args *));
void  softdep_setup_freeblocks __P((struct inode *, off_t));
void  softdep_deallocate_dependencies __P((struct buf *));
void  softdep_setup_inomapdep __P((struct buf *, struct inode *, ino_t));
void  softdep_setup_blkmapdep __P((struct buf *, struct fs *, daddr_t));
void  softdep_setup_allocdirect __P((struct inode *, ufs_lbn_t, daddr_t,
          daddr_t, long, long, struct buf *));
void  softdep_setup_allocindir_meta __P((struct buf *, struct inode *,
          struct buf *, int, daddr_t));
void  softdep_setup_allocindir_page __P((struct inode *, ufs_lbn_t,
          struct buf *, int, daddr_t, daddr_t, struct buf *));
void  softdep_disk_io_initiation __P((struct buf *));
void  softdep_disk_write_complete __P((struct buf *));
int   softdep_sync_metadata __P((struct vop_fsync_args *));

@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 15
d65 1
d86 1
a86 2
int ffs_balloc __P((struct inode *, daddr_t, int, struct ucred *,
		    struct buf **, int));
d89 1
a89 1
void ffs_init __P((void));
d99 2
d120 2
d130 32
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ffs_extern.h,v 1.3 1994/10/20 04:20:57 cgd Exp $	*/
d49 1
d53 1
a55 37
int	ffs_alloc __P((struct inode *,
	    daddr_t, daddr_t, int, struct ucred *, daddr_t *));
int	ffs_balloc __P((struct inode *,
	    daddr_t, int, struct ucred *, struct buf **, int));
int	ffs_blkatoff __P((struct vop_blkatoff_args *));
int	ffs_blkfree __P((struct inode *, daddr_t, long));
daddr_t	ffs_blkpref __P((struct inode *, daddr_t, int, daddr_t *));
int	ffs_bmap __P((struct vop_bmap_args *));
void	ffs_clrblock __P((struct fs *, u_char *, daddr_t));
int	ffs_fhtovp __P((struct mount *, struct fid *, struct mbuf *,
	    struct vnode **, int *, struct ucred **));
void	ffs_fragacct __P((struct fs *, int, int32_t [], int));
int	ffs_fsync __P((struct vop_fsync_args *));
int	ffs_init __P((void));
int	ffs_isblock __P((struct fs *, u_char *, daddr_t));
int	ffs_mount __P((struct mount *,
	    char *, caddr_t, struct nameidata *, struct proc *));
int	ffs_mountfs __P((struct vnode *, struct mount *, struct proc *));
int	ffs_mountroot __P((void));
int	ffs_read __P((struct vop_read_args *));
int	ffs_reallocblks __P((struct vop_reallocblks_args *));
int	ffs_realloccg __P((struct inode *,
	    daddr_t, daddr_t, int, int, struct ucred *, struct buf **));
int	ffs_reclaim __P((struct vop_reclaim_args *));
void	ffs_setblock __P((struct fs *, u_char *, daddr_t));
int	ffs_statfs __P((struct mount *, struct statfs *, struct proc *));
int	ffs_sync __P((struct mount *, int, struct ucred *, struct proc *));
int	ffs_truncate __P((struct vop_truncate_args *));
int	ffs_unmount __P((struct mount *, int, struct proc *));
int	ffs_update __P((struct vop_update_args *));
int	ffs_valloc __P((struct vop_valloc_args *));
int	ffs_vfree __P((struct vop_vfree_args *));
int	ffs_vget __P((struct mount *, ino_t, struct vnode **));
int	ffs_vptofh __P((struct vnode *, struct fid *));
int	ffs_write __P((struct vop_write_args *));

int	bwrite();		/* FFS needs a bwrite routine.  XXX */
d57 24
d84 27
d113 2
a114 2
extern int (**ffs_vnodeop_p)();
extern int (**ffs_specop_p)();
d116 1
a116 1
extern int (**ffs_fifoop_p)();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
