head	1.32;
access;
symbols
	OPENBSD_6_2:1.32.0.6
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.29.0.10
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.6
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.8
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.6
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.4
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.24.0.6
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.22.0.4
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.21.0.6
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.4
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.2
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.4
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.2
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.14
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.12
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.10
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.32
date	2016.08.10.11.33.01;	author natano;	state Exp;
branches;
next	1.31;
commitid	gEXby5kl9so5SSnF;

1.31
date	2016.08.10.08.04.57;	author natano;	state Exp;
branches;
next	1.30;
commitid	a3QYlN9gTOdBi75t;

1.30
date	2015.11.28.21.52.02;	author beck;	state Exp;
branches;
next	1.29;
commitid	RTnjsXZgItH5OlTY;

1.29
date	2013.11.02.00.08.17;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2011.07.03.18.23.10;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2009.08.14.13.05.08;	author jasper;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.14.12.50.33;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.02.12.35.06;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2008.01.05.19.49.26;	author otto;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.06.23.30.42;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.17.16.30.58;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.11.08.02.29.51;	author pedro;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.03.20.14.02;	author drahn;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.20.03.44.06;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.26.07.58.47;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.28.23;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.22.20.37.46;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.01.19.12.25;	author deraadt;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.07.06.08.29.29;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.23.02.07.55;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.20.19.54.08;	author art;	state Exp;
branches;
next	1.6;

1.6
date	97.11.06.05.59.19;	author csapuntz;	state Exp;
branches
	1.6.10.1;
next	1.5;

1.5
date	97.10.06.20.21.36;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.15.26.31;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.32.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.27.07.27.39;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.32;	author deraadt;	state Exp;
branches;
next	;

1.6.10.1
date	2001.05.14.22.47.41;	author niklas;	state Exp;
branches;
next	1.6.10.2;

1.6.10.2
date	2001.07.04.11.00.51;	author niklas;	state Exp;
branches;
next	1.6.10.3;

1.6.10.3
date	2001.10.31.03.32.13;	author nate;	state Exp;
branches;
next	1.6.10.4;

1.6.10.4
date	2001.12.05.01.02.41;	author niklas;	state Exp;
branches;
next	1.6.10.5;

1.6.10.5
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.6.10.6;

1.6.10.6
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.6.10.7;

1.6.10.7
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.6.10.8;

1.6.10.8
date	2004.02.19.11.01.40;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.32.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.32
log
@fix previous; ffs_vinit() requires #ifdef _KERNEL to not break the
sbin/fsck_ffs build. bad natano!
reported by naddy
@
text
@/*	$OpenBSD: ffs_subr.c,v 1.31 2016/08/10 08:04:57 natano Exp $	*/
/*	$NetBSD: ffs_subr.c,v 1.6 1996/03/17 02:16:23 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ffs_subr.c	8.2 (Berkeley) 9/21/93
 */

#include <sys/param.h>
#include <ufs/ffs/fs.h>

#ifdef _KERNEL
#include <sys/systm.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/buf.h>

#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

#include <ufs/ffs/ffs_extern.h>

/*
 * Return buffer with the contents of block "offset" from the beginning of
 * directory "ip".  If "res" is non-zero, fill it in with a pointer to the
 * remaining space in the directory.
 */
int
ffs_bufatoff(struct inode *ip, off_t offset, char **res, struct buf **bpp)
{
	struct fs *fs;
	struct vnode *vp;
	struct buf *bp;
	daddr_t lbn;
	int bsize, error;

	vp = ITOV(ip);
	fs = ip->i_fs;
	lbn = lblkno(fs, offset);
	bsize = blksize(fs, ip, lbn);

	*bpp = NULL;
	if ((error = bread(vp, lbn, fs->fs_bsize, &bp)) != 0) {
		brelse(bp);
		return (error);
	}
	buf_adjcnt(bp, bsize);
	if (res)
		*res = (char *)bp->b_data + blkoff(fs, offset);
	*bpp = bp;
	return (0);
}
#else
/* Prototypes for userland */
void	ffs_fragacct(struct fs *, int, int32_t[], int);
int	ffs_isfreeblock(struct fs *, u_char *, daddr_t);
int	ffs_isblock(struct fs *, u_char *, daddr_t);
void	ffs_clrblock(struct fs *, u_char *, daddr_t);
void	ffs_setblock(struct fs *, u_char *, daddr_t);
__dead void panic(const char *, ...);
#endif

/*
 * Update the frsum fields to reflect addition or deletion
 * of some frags.
 */
void
ffs_fragacct(struct fs *fs, int fragmap, int32_t fraglist[], int cnt)
{
	int inblk;
	int field, subfield;
	int siz, pos;

	inblk = (int)(fragtbl[fs->fs_frag][fragmap]) << 1;
	fragmap <<= 1;
	for (siz = 1; siz < fs->fs_frag; siz++) {
		if ((inblk & (1 << (siz + (fs->fs_frag % NBBY)))) == 0)
			continue;
		field = around[siz];
		subfield = inside[siz];
		for (pos = siz; pos <= fs->fs_frag; pos++) {
			if ((fragmap & field) == subfield) {
				fraglist[siz] += cnt;
				pos += siz;
				field <<= siz;
				subfield <<= siz;
			}
			field <<= 1;
			subfield <<= 1;
		}
	}
}

#if defined(_KERNEL) && defined(DIAGNOSTIC)
void
ffs_checkoverlap(struct buf *bp, struct inode *ip)
{
	daddr_t start, last;
	struct vnode *vp;
	struct buf *ep;

	start = bp->b_blkno;
	last = start + btodb(bp->b_bcount) - 1;
	LIST_FOREACH(ep, &bufhead, b_list) {
		if (ep == bp || (ep->b_flags & B_INVAL) ||
		    ep->b_vp == NULLVP)
			continue;
		if (VOP_BMAP(ep->b_vp, 0, &vp, NULL, NULL))
			continue;
		if (vp != ip->i_devvp)
			continue;
		/* look for overlap */
		if (ep->b_bcount == 0 || ep->b_blkno > last ||
		    ep->b_blkno + btodb(ep->b_bcount) <= start)
			continue;
		vprint("Disk overlap", vp);
		(void)printf("\tstart %lld, end %lld overlap start %llu, "
		    "end %llu\n", (long long)start, (long long)last,
		    (long long)ep->b_blkno,
		    (long long)(ep->b_blkno + btodb(ep->b_bcount) - 1));
		panic("Disk buffer overlap");
	}
}
#endif /* DIAGNOSTIC */

/*
 * block operations
 *
 * check if a block is available
 */
int
ffs_isblock(struct fs *fs, u_char *cp, daddr_t h)
{
	u_char mask;

	switch (fs->fs_frag) {
	default:
	case 8:
		return (cp[h] == 0xff);
	case 4:
		mask = 0x0f << ((h & 0x1) << 2);
		return ((cp[h >> 1] & mask) == mask);
	case 2:
		mask = 0x03 << ((h & 0x3) << 1);
		return ((cp[h >> 2] & mask) == mask);
	case 1:
		mask = 0x01 << (h & 0x7);
		return ((cp[h >> 3] & mask) == mask);
	}
}

/*
 * take a block out of the map
 */
void
ffs_clrblock(struct fs *fs, u_char *cp, daddr_t h)
{

	switch (fs->fs_frag) {
	default:
	case 8:
		cp[h] = 0;
		return;
	case 4:
		cp[h >> 1] &= ~(0x0f << ((h & 0x1) << 2));
		return;
	case 2:
		cp[h >> 2] &= ~(0x03 << ((h & 0x3) << 1));
		return;
	case 1:
		cp[h >> 3] &= ~(0x01 << (h & 0x7));
		return;
	}
}

/*
 * put a block into the map
 */
void
ffs_setblock(struct fs *fs, u_char *cp, daddr_t h)
{

	switch (fs->fs_frag) {
	default:
	case 8:
		cp[h] = 0xff;
		return;
	case 4:
		cp[h >> 1] |= (0x0f << ((h & 0x1) << 2));
		return;
	case 2:
		cp[h >> 2] |= (0x03 << ((h & 0x3) << 1));
		return;
	case 1:
		cp[h >> 3] |= (0x01 << (h & 0x7));
		return;
	}
}

/*
 * check if a block is free
 */
int
ffs_isfreeblock(struct fs *fs, u_char *cp, daddr_t h)
{

	switch (fs->fs_frag) {
	default:
	case 8:
		return (cp[h] == 0);
	case 4:
		return ((cp[h >> 1] & (0x0f << ((h & 0x1) << 2))) == 0);
	case 2:
		return ((cp[h >> 2] & (0x03 << ((h & 0x3) << 1))) == 0);
	case 1:
		return ((cp[h >> 3] & (0x01 << (h & 0x7))) == 0);
	}
}

#ifdef _KERNEL
/*
 * Initialize the vnode associated with a new inode, handle aliased
 * vnodes.
 */
int
ffs_vinit(struct mount *mntp, struct vnode **vpp)
{
	struct inode *ip;
	struct vnode *vp, *nvp;
	struct timeval mtv;

	vp = *vpp;
	ip = VTOI(vp);
	switch(vp->v_type = IFTOVT(DIP(ip, mode))) {
	case VCHR:
	case VBLK:
		vp->v_op = &ffs_specvops;
		if ((nvp = checkalias(vp, DIP(ip, rdev), mntp)) != NULL) {
			/*
			 * Discard unneeded vnode, but save its inode.
			 * Note that the lock is carried over in the inode
			 * to the replacement vnode.
			 */
			nvp->v_data = vp->v_data;
			vp->v_data = NULL;
			vp->v_op = &spec_vops;
#ifdef VFSLCKDEBUG
			vp->v_flag &= ~VLOCKSWORK;
#endif
			vrele(vp);
			vgone(vp);
			/*
			 * Reinitialize aliased inode.
			 */
			vp = nvp;
			ip->i_vnode = vp;
		}
		break;
	case VFIFO:
#ifdef FIFO
		vp->v_op = &ffs_fifovops;
		break;
#else
		return (EOPNOTSUPP);
#endif
	case VNON:
	case VBAD:
	case VSOCK:
	case VLNK:
	case VDIR:
	case VREG:
		break;
	}
	if (ip->i_number == ROOTINO)
		vp->v_flag |= VROOT;
	/*
	 * Initialize modrev times
	 */
	getmicrouptime(&mtv);
	ip->i_modrev = (u_quad_t)mtv.tv_sec << 32;
	ip->i_modrev |= (u_quad_t)mtv.tv_usec * 4294;
	*vpp = vp;
	return (0);
}
#endif /* _KERNEL */
@


1.31
log
@ufs_vinit() should really be called ffs_vinit(); it's only called from
ffs code.
ok mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.30 2015/11/28 21:52:02 beck Exp $	*/
d248 1
d313 1
@


1.30
log
@move buffer size adjustment to buf_adjcnt - from Walter Neto
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.29 2013/11/02 00:08:17 krw Exp $	*/
d246 65
@


1.29
log
@No need to cast constants or simple variables to (daddr_t). Use
(u_int64_t) instead of (daddr_t) when casting a variable in an
expression passed to DL_SETDSIZE().

Change a variable counting open files from daddr_t to int64_t.

ok deraadt@@ with the tweak to fix that pesky expression.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.28 2013/11/01 17:36:19 krw Exp $	*/
d75 1
a75 1
	bp->b_bcount = bsize;
@


1.28
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.27 2013/06/11 16:42:18 deraadt Exp $	*/
d136 1
a136 1
		if (VOP_BMAP(ep->b_vp, (daddr_t)0, &vp, NULL, NULL))
@


1.27
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.26 2011/07/04 04:30:41 tedu Exp $	*/
d145 4
a148 3
		(void)printf("\tstart %lld, end %lld overlap start %llu, end %llu\n",
			start, last, ep->b_blkno,
			ep->b_blkno + btodb(ep->b_bcount) - 1);
@


1.26
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.25 2011/07/03 18:23:10 tedu Exp $	*/
d62 1
a62 1
	daddr64_t lbn;
d84 4
a87 4
int	ffs_isfreeblock(struct fs *, u_char *, daddr64_t);
int	ffs_isblock(struct fs *, u_char *, daddr64_t);
void	ffs_clrblock(struct fs *, u_char *, daddr64_t);
void	ffs_setblock(struct fs *, u_char *, daddr64_t);
d126 1
a126 1
	daddr64_t start, last;
d136 1
a136 1
		if (VOP_BMAP(ep->b_vp, (daddr64_t)0, &vp, NULL, NULL))
d159 1
a159 1
ffs_isblock(struct fs *fs, u_char *cp, daddr64_t h)
d183 1
a183 1
ffs_clrblock(struct fs *fs, u_char *cp, daddr64_t h)
d207 1
a207 1
ffs_setblock(struct fs *fs, u_char *cp, daddr64_t h)
d231 1
a231 1
ffs_isfreeblock(struct fs *fs, u_char *cp, daddr64_t h)
@


1.25
log
@correctify NULL 0 confusion
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.24 2009/08/14 13:05:08 jasper Exp $	*/
d71 1
a71 1
	if ((error = bread(vp, lbn, fs->fs_bsize, NOCRED, &bp)) != 0) {
@


1.24
log
@- use u_char consistently
- minor formatting

ok oga@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.23 2009/08/14 12:50:33 jasper Exp $	*/
d136 1
a136 1
		if (VOP_BMAP(ep->b_vp, (daddr64_t)0, &vp, (daddr64_t)0, NULL))
@


1.23
log
@- fix format string for daddr64_t to %lld

ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.22 2009/06/02 12:35:06 deraadt Exp $	*/
d84 2
a85 2
int	ffs_isfreeblock(struct fs *, unsigned char *, daddr64_t);
int	ffs_isblock(struct fs *, unsigned char *, daddr64_t);
d87 1
a87 1
void	ffs_setblock(struct fs *, unsigned char *, daddr64_t);
d159 1
a159 1
ffs_isblock(struct fs *fs, unsigned char *cp, daddr64_t h)
d161 1
a161 1
	unsigned char mask;
d207 1
a207 1
ffs_setblock(struct fs *fs, unsigned char *cp, daddr64_t h)
d231 1
a231 1
ffs_isfreeblock(struct fs *fs, unsigned char *cp, daddr64_t h)
@


1.22
log
@blkno's are 64 bit so need %llu, found by Parfait
ok oga
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.21 2008/01/05 19:49:26 otto Exp $	*/
d145 1
a145 1
		(void)printf("\tstart %d, end %d overlap start %llu, end %llu\n",
@


1.21
log
@Make the ffs code 64-bit disk block number clean.  Based on a diff
from Pedro Martelleto.  Two things remain: the on-disk quota
structures are still 32-bit and statfs does not do 64-bit numbers
yet. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.20 2007/05/26 20:26:51 pedro Exp $	*/
d145 1
a145 1
		(void)printf("\tstart %d, end %d overlap start %d, end %ld\n",
@


1.20
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.19 2007/01/06 23:30:42 tedu Exp $	*/
d62 1
a62 1
	daddr_t lbn;
d84 4
a87 4
int	ffs_isfreeblock(struct fs *, unsigned char *, daddr_t);
int	ffs_isblock(struct fs *, unsigned char *, daddr_t);
void	ffs_clrblock(struct fs *, u_char *, daddr_t);
void	ffs_setblock(struct fs *, unsigned char *, daddr_t);
d126 1
a126 1
	daddr_t start, last;
d136 1
a136 1
		if (VOP_BMAP(ep->b_vp, (daddr_t)0, &vp, (daddr_t)0, NULL))
d159 1
a159 1
ffs_isblock(struct fs *fs, unsigned char *cp, daddr_t h)
d183 1
a183 1
ffs_clrblock(struct fs *fs, u_char *cp, daddr_t h)
d207 1
a207 1
ffs_setblock(struct fs *fs, unsigned char *cp, daddr_t h)
d231 1
a231 1
ffs_isfreeblock(struct fs *fs, unsigned char *cp, daddr_t h)
@


1.19
log
@stop printing messages when changing space/time optimizations.
it's not all that important, and mostly seems to just scare people.
ok pedro henning thib ...
also remove dumb casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.18 2006/06/17 16:30:58 miod Exp $	*/
d71 1
a71 1
	if ((error = bread(vp, lbn, bsize, NOCRED, &bp)) != 0) {
d75 1
a125 1
	struct buf *ebp, *ep;
d128 1
a129 1
	ebp = &buf[nbuf];
d132 1
a132 1
	for (ep = buf; ep < ebp; ep++) {
@


1.18
log
@Refuse to mount a ffs fielsystems whose number of frags is not 1, 2, 4 or 8,
and remove the corresponding panics in low level code.
ok pedro@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.17 2005/11/08 02:29:51 pedro Exp $	*/
d163 1
a163 1
	switch ((int)fs->fs_frag) {
d186 1
a186 1
	switch ((int)fs->fs_frag) {
d210 1
a210 1
	switch ((int)fs->fs_frag) {
d234 1
a234 1
	switch ((int)fs->fs_frag) {
@


1.17
log
@Use ANSI function declarations and deregister, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.16 2005/07/03 20:14:02 drahn Exp $	*/
d164 1
a175 2
	default:
		panic("ffs_isblock");
d187 1
a199 2
	default:
		panic("ffs_clrblock");
d211 1
a211 1

a223 2
	default:
		panic("ffs_setblock");
d235 1
a243 2
	default:
		panic("ffs_isfreeblock");
@


1.16
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.15 2004/01/20 03:44:06 tedu Exp $	*/
d95 1
a95 5
ffs_fragacct(fs, fragmap, fraglist, cnt)
	struct fs *fs;
	int fragmap;
	int32_t fraglist[];
	int cnt;
d98 2
a99 2
	register int field, subfield;
	register int siz, pos;
d123 1
a123 3
ffs_checkoverlap(bp, ip)
	struct buf *bp;
	struct inode *ip;
d125 2
a126 2
	register struct buf *ebp, *ep;
	register daddr_t start, last;
d159 1
a159 4
ffs_isblock(fs, cp, h)
	struct fs *fs;
	unsigned char *cp;
	daddr_t h;
d184 1
a184 4
ffs_clrblock(fs, cp, h)
	struct fs *fs;
	u_char *cp;
	daddr_t h;
d209 1
a209 4
ffs_setblock(fs, cp, h)
	struct fs *fs;
	unsigned char *cp;
	daddr_t h;
a230 1

d235 1
a235 4
ffs_isfreeblock(fs, cp, h)
	struct fs *fs;
	unsigned char *cp;
	daddr_t h;
@


1.15
log
@some pieces of ufs2.  help testing otto sturm
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.14 2003/06/26 07:58:47 tedu Exp $	*/
a43 1
#include <ufs/ufs/extattr.h>
@


1.14
log
@add prototypes for userland code that reaches over.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.13 2003/06/02 23:28:23 millert Exp $	*/
d41 1
d43 1
d47 3
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.12 2002/03/14 01:27:14 millert Exp $	*/
d76 8
a153 4

#ifndef _KERNEL
void panic(const char *, ...);
#endif
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.11 2002/02/22 20:37:46 drahn Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.10 2001/12/01 19:12:25 deraadt Exp $	*/
d152 1
a152 1
void panic __P((const char *, ...));
@


1.10
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.9 2001/07/06 08:29:29 deraadt Exp $	*/
d46 1
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.10 2001/12/01 19:12:25 deraadt Exp $	*/
a45 1
#include <ufs/ufs/extattr.h>
d151 1
a151 1
void panic(const char *, ...);
@


1.9
log
@prototypes for userland side
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.8 2001/06/23 02:07:55 csapuntz Exp $	*/
d247 3
a249 3
      struct fs *fs;
      unsigned char *cp;
      daddr_t h;
d252 12
a263 12
      switch ((int)fs->fs_frag) {
      case 8:
              return (cp[h] == 0);
      case 4:
              return ((cp[h >> 1] & (0x0f << ((h & 0x1) << 2))) == 0);
      case 2:
              return ((cp[h >> 2] & (0x03 << ((h & 0x3) << 1))) == 0);
      case 1:
              return ((cp[h >> 3] & (0x01 << (h & 0x7))) == 0);
      default:
              panic("ffs_isfreeblock");
      }
a264 2


@


1.8
log
@Privatize several vnode operations that are not used by the generic code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.7 2001/03/20 19:54:08 art Exp $	*/
d149 4
@


1.7
log
@dangling space in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.6 1997/11/06 05:59:19 csapuntz Exp $	*/
d56 1
a56 2
ffs_blkatoff(v)
	void *v;
d58 2
a59 8
	struct vop_blkatoff_args /* {
		struct vnode *a_vp;
		off_t a_offset;
		char **a_res;
		struct buf **a_bpp;
	} */ *ap = v;
	struct inode *ip;
	register struct fs *fs;
d64 1
a64 1
	ip = VTOI(ap->a_vp);
d66 1
a66 1
	lbn = lblkno(fs, ap->a_offset);
d69 2
a70 2
	*ap->a_bpp = NULL;
	if ((error = bread(ap->a_vp, lbn, bsize, NOCRED, &bp)) != 0) {
d74 3
a76 3
	if (ap->a_res)
		*ap->a_res = (char *)bp->b_data + blkoff(fs, ap->a_offset);
	*ap->a_bpp = bp;
@


1.6
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.5 1997/10/06 20:21:36 deraadt Exp $	*/
d89 1
a89 1
 * Update the frsum fields to reflect addition or deletion 
@


1.6.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.7 2001/03/20 19:54:08 art Exp $	*/
d89 1
a89 1
 * Update the frsum fields to reflect addition or deletion
@


1.6.10.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.6.10.1 2001/05/14 22:47:41 niklas Exp $	*/
d56 2
a57 1
ffs_bufatoff(struct inode *ip, off_t offset, char **res, struct buf **bpp)
d59 8
a66 2
	struct fs *fs;
	struct vnode *vp;
d71 1
a71 1
	vp = ITOV(ip);
d73 1
a73 1
	lbn = lblkno(fs, offset);
d76 2
a77 2
	*bpp = NULL;
	if ((error = bread(vp, lbn, bsize, NOCRED, &bp)) != 0) {
d81 3
a83 3
	if (res)
		*res = (char *)bp->b_data + blkoff(fs, offset);
	*bpp = bp;
@


1.6.10.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.6.10.2 2001/07/04 11:00:51 niklas Exp $	*/
a148 4

#ifndef _KERNEL
void panic __P((const char *, ...));
#endif
@


1.6.10.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d247 3
a249 3
	struct fs *fs;
	unsigned char *cp;
	daddr_t h;
d252 12
a263 12
	switch ((int)fs->fs_frag) {
	case 8:
		return (cp[h] == 0);
	case 4:
		return ((cp[h >> 1] & (0x0f << ((h & 0x1) << 2))) == 0);
	case 2:
		return ((cp[h >> 2] & (0x03 << ((h & 0x3) << 1))) == 0);
	case 1:
		return ((cp[h >> 3] & (0x01 << (h & 0x7))) == 0);
	default:
		panic("ffs_isfreeblock");
	}
d265 2
@


1.6.10.5
log
@Merge in trunk
@
text
@a45 1
#include <ufs/ufs/extattr.h>
@


1.6.10.6
log
@Merge in -current from roughly a week ago
@
text
@d152 1
a152 1
void panic(const char *, ...);
@


1.6.10.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.6.10.6 2002/03/28 14:54:26 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.10.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a40 1
#include <sys/mount.h>
a41 1

a44 3
#include <ufs/ufs/ufsmount.h>
#include <ufs/ufs/ufs_extern.h>

a75 8
#else
/* Prototypes for userland */
void	ffs_fragacct(struct fs *, int, int32_t[], int);
int	ffs_isfreeblock(struct fs *, unsigned char *, daddr_t);
int	ffs_isblock(struct fs *, unsigned char *, daddr_t);
void	ffs_clrblock(struct fs *, u_char *, daddr_t);
void	ffs_setblock(struct fs *, unsigned char *, daddr_t);
__dead void panic(const char *, ...);
d146 4
@


1.5
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.3 1996/04/21 22:32:33 deraadt Exp $	*/
a44 1
#include <ufs/ffs/ffs_extern.h>
d48 1
d243 27
@


1.4
log
@VFS Lite2 Changes
@
text
@d45 1
a48 1
#include <ufs/ffs/ffs_extern.h>
a242 27


/*
 * check if a block is free
 */
int
ffs_isfreeblock(fs, cp, h)
      struct fs *fs;
      unsigned char *cp;
      daddr_t h;
{

      switch ((int)fs->fs_frag) {
      case 8:
              return (cp[h] == 0);
      case 4:
              return ((cp[h >> 1] & (0x0f << ((h & 0x1) << 2))) == 0);
      case 2:
              return ((cp[h >> 2] & (0x03 << ((h & 0x3) << 1))) == 0);
      case 1:
              return ((cp[h >> 3] & (0x01 << (h & 0x7))) == 0);
      default:
              panic("ffs_isfreeblock");
      }
}


@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: ffs_subr.c,v 1.2 1996/02/27 07:27:39 niklas Exp $	*/
a44 1
#include <ufs/ffs/ffs_extern.h>
d48 1
d243 27
@


1.2
log
@From NetBSD: update to 960217 sources
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ffs_subr.c,v 1.5 1996/02/09 22:22:24 christos Exp $	*/
d149 1
a149 1
		(void)printf("\tstart %d, end %d overlap start %d, end %d\n",
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ffs_subr.c,v 1.4 1995/03/28 20:01:44 jtc Exp $	*/
d56 3
a58 1
ffs_blkatoff(ap)
d64 1
a64 2
	} */ *ap;
{
d77 1
a77 1
	if (error = bread(ap->a_vp, lbn, bsize, NOCRED, &bp)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
